<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gdataset.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gconvert.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gdataset.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gdataset.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 121 /**
 122  * GData:
 123  *
 124  * The #GData struct is an opaque data structure to represent a
 125  * [Keyed Data List][glib-Keyed-Data-Lists]. It should only be
 126  * accessed via the following functions.
 127  **/
 128 
 129 /**
 130  * GDestroyNotify:
 131  * @data: the data element.
 132  *
 133  * Specifies the type of function which is called when a data element
 134  * is destroyed. It is passed the pointer to the data element and
 135  * should free any memory and resources allocated for it.
 136  **/
 137 
 138 #define G_DATALIST_FLAGS_MASK_INTERNAL 0x7
 139 
 140 /* datalist pointer accesses have to be carried out atomically */
<span class="line-modified"> 141 #define G_DATALIST_GET_POINTER(datalist)                        \</span>
 142   ((GData*) ((gsize) g_atomic_pointer_get (datalist) &amp; ~(gsize) G_DATALIST_FLAGS_MASK_INTERNAL))
 143 
 144 #define G_DATALIST_SET_POINTER(datalist, pointer)       G_STMT_START {                  \
 145   gpointer _oldv, _newv;                                                                \
 146   do {                                                                                  \
 147     _oldv = g_atomic_pointer_get (datalist);                                            \
 148     _newv = (gpointer) (((gsize) _oldv &amp; G_DATALIST_FLAGS_MASK_INTERNAL) | (gsize) pointer);     \
 149   } while (!g_atomic_pointer_compare_and_exchange ((void**) datalist, _oldv, _newv));   \
 150 } G_STMT_END
 151 
 152 /* --- structures --- */
 153 typedef struct {
 154   GQuark          key;
 155   gpointer        data;
 156   GDestroyNotify  destroy;
 157 } GDataElt;
 158 
 159 typedef struct _GDataset GDataset;
 160 struct _GData
 161 {
 162   guint32  len;     /* Number of elements */
 163   guint32  alloc;   /* Number of allocated elements */
 164   GDataElt data[1]; /* Flexible array */
 165 };
 166 
 167 struct _GDataset
 168 {
 169   gconstpointer location;
 170   GData        *datalist;
 171 };
 172 
 173 
 174 /* --- prototypes --- */
<span class="line-modified"> 175 static inline GDataset* g_dataset_lookup        (gconstpointer    dataset_location);</span>
<span class="line-modified"> 176 static inline void  g_datalist_clear_i      (GData      **datalist);</span>
<span class="line-modified"> 177 static void     g_dataset_destroy_internal  (GDataset    *dataset);</span>
<span class="line-modified"> 178 static inline gpointer  g_data_set_internal     (GData      **datalist,</span>
<span class="line-modified"> 179                              GQuark       key_id,</span>
<span class="line-modified"> 180                              gpointer         data,</span>
<span class="line-modified"> 181                              GDestroyNotify   destroy_func,</span>
<span class="line-modified"> 182                              GDataset    *dataset);</span>
<span class="line-modified"> 183 static void     g_data_initialize       (void);</span>
 184 
 185 /* Locking model:
 186  * Each standalone GDataList is protected by a bitlock in the datalist pointer,
 187  * which protects that modification of the non-flags part of the datalist pointer
 188  * and the contents of the datalist.
 189  *
 190  * For GDataSet we have a global lock g_dataset_global that protects
 191  * the global dataset hash and cache, and additionally it protects the
 192  * datalist such that we can avoid to use the bit lock in a few places
 193  * where it is easy.
 194  */
 195 
 196 /* --- variables --- */
 197 G_LOCK_DEFINE_STATIC (g_dataset_global);
 198 static GHashTable   *g_dataset_location_ht = NULL;
 199 static GDataset     *g_dataset_cached = NULL; /* should this be
<span class="line-modified"> 200                          thread specific? */</span>
 201 
 202 /* --- functions --- */
 203 
 204 #define DATALIST_LOCK_BIT 2
 205 
 206 static void
 207 g_datalist_lock (GData **datalist)
 208 {
 209   g_pointer_bit_lock ((void **)datalist, DATALIST_LOCK_BIT);
 210 }
 211 
 212 static void
 213 g_datalist_unlock (GData **datalist)
 214 {
 215   g_pointer_bit_unlock ((void **)datalist, DATALIST_LOCK_BIT);
 216 }
 217 
 218 /* Called with the datalist lock held, or the dataset global
 219  * lock for dataset lists
 220  */
 221 static void
 222 g_datalist_clear_i (GData **datalist)
 223 {
 224   GData *data;
<span class="line-modified"> 225   gint i;</span>
 226 
 227   data = G_DATALIST_GET_POINTER (datalist);
 228   G_DATALIST_SET_POINTER (datalist, NULL);
 229 
 230   if (data)
 231     {
 232       G_UNLOCK (g_dataset_global);
 233       for (i = 0; i &lt; data-&gt;len; i++)
 234         {
 235           if (data-&gt;data[i].data &amp;&amp; data-&gt;data[i].destroy)
 236             data-&gt;data[i].destroy (data-&gt;data[i].data);
 237         }
 238       G_LOCK (g_dataset_global);
 239 
 240       g_free (data);
 241     }
 242 
 243 }
 244 
 245 /**
 246  * g_datalist_clear: (skip)
 247  * @datalist: a datalist.
 248  *
 249  * Frees all the data elements of the datalist.
 250  * The data elements&#39; destroy functions are called
 251  * if they have been set.
 252  **/
 253 void
 254 g_datalist_clear (GData **datalist)
 255 {
 256   GData *data;
<span class="line-modified"> 257   gint i;</span>
 258 
 259   g_return_if_fail (datalist != NULL);
 260 
 261   g_datalist_lock (datalist);
 262 
 263   data = G_DATALIST_GET_POINTER (datalist);
 264   G_DATALIST_SET_POINTER (datalist, NULL);
 265 
 266   g_datalist_unlock (datalist);
 267 
 268   if (data)
 269     {
 270       for (i = 0; i &lt; data-&gt;len; i++)
 271         {
 272           if (data-&gt;data[i].data &amp;&amp; data-&gt;data[i].destroy)
 273             data-&gt;data[i].destroy (data-&gt;data[i].data);
 274         }
 275 
 276       g_free (data);
 277     }
</pre>
<hr />
<pre>
 286   if (g_dataset_cached &amp;&amp; g_dataset_cached-&gt;location == dataset_location)
 287     return g_dataset_cached;
 288 
 289   dataset = g_hash_table_lookup (g_dataset_location_ht, dataset_location);
 290   if (dataset)
 291     g_dataset_cached = dataset;
 292 
 293   return dataset;
 294 }
 295 
 296 /* HOLDS: g_dataset_global_lock */
 297 static void
 298 g_dataset_destroy_internal (GDataset *dataset)
 299 {
 300   gconstpointer dataset_location;
 301 
 302   dataset_location = dataset-&gt;location;
 303   while (dataset)
 304     {
 305       if (G_DATALIST_GET_POINTER(&amp;dataset-&gt;datalist) == NULL)
<span class="line-modified"> 306     {</span>
<span class="line-modified"> 307       if (dataset == g_dataset_cached)</span>
<span class="line-modified"> 308         g_dataset_cached = NULL;</span>
<span class="line-modified"> 309       g_hash_table_remove (g_dataset_location_ht, dataset_location);</span>
<span class="line-modified"> 310       g_slice_free (GDataset, dataset);</span>
<span class="line-modified"> 311       break;</span>
<span class="line-modified"> 312     }</span>
 313 
 314       g_datalist_clear_i (&amp;dataset-&gt;datalist);
 315       dataset = g_dataset_lookup (dataset_location);
 316     }
 317 }
 318 
 319 /**
 320  * g_dataset_destroy:
 321  * @dataset_location: (not nullable): the location identifying the dataset.
 322  *
 323  * Destroys the dataset, freeing all memory allocated, and calling any
 324  * destroy functions set for data elements.
 325  */
 326 void
 327 g_dataset_destroy (gconstpointer  dataset_location)
 328 {
 329   g_return_if_fail (dataset_location != NULL);
 330 
 331   G_LOCK (g_dataset_global);
 332   if (g_dataset_location_ht)
 333     {
 334       GDataset *dataset;
 335 
 336       dataset = g_dataset_lookup (dataset_location);
 337       if (dataset)
<span class="line-modified"> 338     g_dataset_destroy_internal (dataset);</span>
 339     }
 340   G_UNLOCK (g_dataset_global);
 341 }
 342 
 343 /* HOLDS: g_dataset_global_lock if dataset != null */
 344 static inline gpointer
 345 g_data_set_internal (GData    **datalist,
<span class="line-modified"> 346                      GQuark         key_id,</span>
<span class="line-modified"> 347                      gpointer       new_data,</span>
<span class="line-modified"> 348                      GDestroyNotify new_destroy_func,</span>
<span class="line-modified"> 349              GDataset      *dataset)</span>
 350 {
 351   GData *d, *old_d;
 352   GDataElt old, *data, *data_last, *data_end;
 353 
 354   g_datalist_lock (datalist);
 355 
 356   d = G_DATALIST_GET_POINTER (datalist);
 357 
 358   if (new_data == NULL) /* remove */
 359     {
 360       if (d)






 361     {
<span class="line-modified"> 362       data = d-&gt;data;</span>
<span class="line-modified"> 363       data_last = data + d-&gt;len - 1;</span>
<span class="line-modified"> 364       while (data &lt;= data_last)</span>
<span class="line-modified"> 365         {</span>
<span class="line-removed"> 366           if (data-&gt;key == key_id)</span>
<span class="line-removed"> 367         {</span>
<span class="line-removed"> 368           old = *data;</span>
<span class="line-removed"> 369           if (data != data_last)</span>
<span class="line-removed"> 370             *data = *data_last;</span>
<span class="line-removed"> 371           d-&gt;len--;</span>
 372 
<span class="line-modified"> 373           /* We don&#39;t bother to shrink, but if all data are now gone</span>
<span class="line-modified"> 374            * we at least free the memory</span>
 375                    */
<span class="line-modified"> 376           if (d-&gt;len == 0)</span>
<span class="line-modified"> 377             {</span>
<span class="line-modified"> 378               G_DATALIST_SET_POINTER (datalist, NULL);</span>
<span class="line-modified"> 379               g_free (d);</span>
<span class="line-modified"> 380               /* datalist may be situated in dataset, so must not be</span>
<span class="line-modified"> 381                * unlocked after we free it</span>
<span class="line-removed"> 382                */</span>
<span class="line-removed"> 383               g_datalist_unlock (datalist);</span>
<span class="line-removed"> 384 </span>
<span class="line-removed"> 385               /* the dataset destruction *must* be done</span>
<span class="line-removed"> 386                * prior to invocation of the data destroy function</span>
<span class="line-removed"> 387                */</span>
<span class="line-removed"> 388               if (dataset)</span>
<span class="line-removed"> 389             g_dataset_destroy_internal (dataset);</span>
<span class="line-removed"> 390             }</span>
<span class="line-removed"> 391           else</span>
<span class="line-removed"> 392             {</span>
<span class="line-removed"> 393               g_datalist_unlock (datalist);</span>
<span class="line-removed"> 394             }</span>
<span class="line-removed"> 395 </span>
<span class="line-removed"> 396           /* We found and removed an old value</span>
<span class="line-removed"> 397            * the GData struct *must* already be unlinked</span>
<span class="line-removed"> 398            * when invoking the destroy function.</span>
<span class="line-removed"> 399            * we use (new_data==NULL &amp;&amp; new_destroy_func!=NULL) as</span>
<span class="line-removed"> 400            * a special hint combination to &quot;steal&quot;</span>
<span class="line-removed"> 401            * data without destroy notification</span>
 402            */
<span class="line-modified"> 403           if (old.destroy &amp;&amp; !new_destroy_func)</span>
<span class="line-removed"> 404             {</span>
<span class="line-removed"> 405               if (dataset)</span>
<span class="line-removed"> 406             G_UNLOCK (g_dataset_global);</span>
<span class="line-removed"> 407               old.destroy (old.data);</span>
<span class="line-removed"> 408               if (dataset)</span>
<span class="line-removed"> 409             G_LOCK (g_dataset_global);</span>
<span class="line-removed"> 410               old.data = NULL;</span>
<span class="line-removed"> 411             }</span>
 412 
<span class="line-modified"> 413           return old.data;</span>




 414         }
<span class="line-modified"> 415           data++;</span>


 416         }



















 417     }



 418     }
 419   else
 420     {
 421       old.data = NULL;
 422       if (d)






 423     {
<span class="line-modified"> 424       data = d-&gt;data;</span>
<span class="line-removed"> 425       data_end = data + d-&gt;len;</span>
<span class="line-removed"> 426       while (data &lt; data_end)</span>
<span class="line-removed"> 427         {</span>
<span class="line-removed"> 428           if (data-&gt;key == key_id)</span>
 429         {
<span class="line-modified"> 430           if (!data-&gt;destroy)</span>
<span class="line-modified"> 431             {</span>
<span class="line-modified"> 432               data-&gt;data = new_data;</span>
<span class="line-removed"> 433               data-&gt;destroy = new_destroy_func;</span>
<span class="line-removed"> 434               g_datalist_unlock (datalist);</span>
<span class="line-removed"> 435             }</span>
<span class="line-removed"> 436           else</span>
<span class="line-removed"> 437             {</span>
<span class="line-removed"> 438               old = *data;</span>
<span class="line-removed"> 439               data-&gt;data = new_data;</span>
<span class="line-removed"> 440               data-&gt;destroy = new_destroy_func;</span>
<span class="line-removed"> 441 </span>
<span class="line-removed"> 442               g_datalist_unlock (datalist);</span>
<span class="line-removed"> 443 </span>
<span class="line-removed"> 444               /* We found and replaced an old value</span>
<span class="line-removed"> 445                * the GData struct *must* already be unlinked</span>
<span class="line-removed"> 446                * when invoking the destroy function.</span>
<span class="line-removed"> 447                */</span>
<span class="line-removed"> 448               if (dataset)</span>
<span class="line-removed"> 449             G_UNLOCK (g_dataset_global);</span>
<span class="line-removed"> 450               old.destroy (old.data);</span>
<span class="line-removed"> 451               if (dataset)</span>
<span class="line-removed"> 452             G_LOCK (g_dataset_global);</span>
<span class="line-removed"> 453             }</span>
<span class="line-removed"> 454           return NULL;</span>
 455         }
<span class="line-modified"> 456           data++;</span>
















 457         }

 458     }



 459 
 460       /* The key was not found, insert it */
 461       old_d = d;
 462       if (d == NULL)
<span class="line-modified"> 463     {</span>
<span class="line-modified"> 464       d = g_malloc (sizeof (GData));</span>
<span class="line-modified"> 465       d-&gt;len = 0;</span>
<span class="line-modified"> 466       d-&gt;alloc = 1;</span>
<span class="line-modified"> 467     }</span>
 468       else if (d-&gt;len == d-&gt;alloc)
<span class="line-modified"> 469     {</span>
<span class="line-modified"> 470       d-&gt;alloc = d-&gt;alloc * 2;</span>
<span class="line-modified"> 471       d = g_realloc (d, sizeof (GData) + (d-&gt;alloc - 1) * sizeof (GDataElt));</span>
<span class="line-modified"> 472     }</span>
 473       if (old_d != d)
<span class="line-modified"> 474     G_DATALIST_SET_POINTER (datalist, d);</span>
 475 
 476       d-&gt;data[d-&gt;len].key = key_id;
 477       d-&gt;data[d-&gt;len].data = new_data;
 478       d-&gt;data[d-&gt;len].destroy = new_destroy_func;
 479       d-&gt;len++;
 480     }
 481 
 482   g_datalist_unlock (datalist);
 483 
 484   return NULL;
 485 
 486 }
 487 
 488 /**
 489  * g_dataset_id_set_data_full: (skip)
 490  * @dataset_location: (not nullable): the location identifying the dataset.
 491  * @key_id: the #GQuark id to identify the data element.
 492  * @data: the data element.
 493  * @destroy_func: the function to call when the data element is
 494  *                removed. This function will be called with the data
</pre>
<hr />
<pre>
 531  * Sets the data corresponding to the given string identifier.
 532  **/
 533 /**
 534  * g_dataset_id_remove_data:
 535  * @l: the location identifying the dataset.
 536  * @k: the #GQuark id identifying the data element.
 537  *
 538  * Removes a data element from a dataset. The data element&#39;s destroy
 539  * function is called if it has been set.
 540  **/
 541 /**
 542  * g_dataset_remove_data:
 543  * @l: the location identifying the dataset.
 544  * @k: the string identifying the data element.
 545  *
 546  * Removes a data element corresponding to a string. Its destroy
 547  * function is called if it has been set.
 548  **/
 549 void
 550 g_dataset_id_set_data_full (gconstpointer  dataset_location,
<span class="line-modified"> 551                 GQuark         key_id,</span>
<span class="line-modified"> 552                 gpointer       data,</span>
<span class="line-modified"> 553                 GDestroyNotify destroy_func)</span>
 554 {
 555   GDataset *dataset;
 556 
 557   g_return_if_fail (dataset_location != NULL);
 558   if (!data)
 559     g_return_if_fail (destroy_func == NULL);
 560   if (!key_id)
 561     {
 562       if (data)
<span class="line-modified"> 563     g_return_if_fail (key_id &gt; 0);</span>
 564       else
<span class="line-modified"> 565     return;</span>
 566     }
 567 
 568   G_LOCK (g_dataset_global);
 569   if (!g_dataset_location_ht)
 570     g_data_initialize ();
 571 
 572   dataset = g_dataset_lookup (dataset_location);
 573   if (!dataset)
 574     {
 575       dataset = g_slice_new (GDataset);
 576 #ifdef GSTREAMER_LITE
 577       if (dataset == NULL) {
 578         G_UNLOCK (g_dataset_global);
 579         return;
 580       }
 581 #endif // GSTREAMER_LITE
 582       dataset-&gt;location = dataset_location;
 583       g_datalist_init (&amp;dataset-&gt;datalist);
 584       g_hash_table_insert (g_dataset_location_ht,
<span class="line-modified"> 585                (gpointer) dataset-&gt;location,</span>
<span class="line-modified"> 586                dataset);</span>
 587     }
 588 
 589   g_data_set_internal (&amp;dataset-&gt;datalist, key_id, data, destroy_func, dataset);
 590   G_UNLOCK (g_dataset_global);
 591 }
 592 
 593 /**
 594  * g_datalist_id_set_data_full: (skip)
 595  * @datalist: a datalist.
 596  * @key_id: the #GQuark to identify the data element.
 597  * @data: (nullable): the data element or %NULL to remove any previous element
 598  *        corresponding to @key_id.
 599  * @destroy_func: (nullable): the function to call when the data element is
 600  *                removed. This function will be called with the data
 601  *                element and can be used to free any memory allocated
 602  *                for it. If @data is %NULL, then @destroy_func must
 603  *                also be %NULL.
 604  *
 605  * Sets the data corresponding to the given #GQuark id, and the
 606  * function to be called when the element is removed from the datalist.
</pre>
<hr />
<pre>
 641  *
 642  * Sets the data element corresponding to the given string identifier.
 643  **/
 644 /**
 645  * g_datalist_id_remove_data:
 646  * @dl: a datalist.
 647  * @q: the #GQuark identifying the data element.
 648  *
 649  * Removes an element, using its #GQuark identifier.
 650  **/
 651 /**
 652  * g_datalist_remove_data:
 653  * @dl: a datalist.
 654  * @k: the string identifying the data element.
 655  *
 656  * Removes an element using its string identifier. The data element&#39;s
 657  * destroy function is called if it has been set.
 658  **/
 659 void
 660 g_datalist_id_set_data_full (GData    **datalist,
<span class="line-modified"> 661                              GQuark         key_id,</span>
<span class="line-modified"> 662                              gpointer       data,</span>
<span class="line-modified"> 663                              GDestroyNotify destroy_func)</span>
 664 {
 665   g_return_if_fail (datalist != NULL);
 666   if (!data)
 667     g_return_if_fail (destroy_func == NULL);
 668   if (!key_id)
 669     {
 670       if (data)
<span class="line-modified"> 671     g_return_if_fail (key_id &gt; 0);</span>
 672       else
<span class="line-modified"> 673     return;</span>
 674     }
 675 
 676   g_data_set_internal (datalist, key_id, data, destroy_func, NULL);
 677 }
 678 
 679 /**
 680  * g_dataset_id_remove_no_notify: (skip)
 681  * @dataset_location: (not nullable): the location identifying the dataset.
 682  * @key_id: the #GQuark ID identifying the data element.
 683  *
 684  * Removes an element, without calling its destroy notification
 685  * function.
 686  *
 687  * Returns: (nullable): the data previously stored at @key_id,
 688  *          or %NULL if none.
 689  **/
 690 /**
 691  * g_dataset_remove_no_notify: (skip)
 692  * @l: the location identifying the dataset.
 693  * @k: the string identifying the data element.
 694  *
 695  * Removes an element, without calling its destroy notifier.
 696  **/
 697 gpointer
 698 g_dataset_id_remove_no_notify (gconstpointer  dataset_location,
<span class="line-modified"> 699                    GQuark         key_id)</span>
 700 {
 701   gpointer ret_data = NULL;
 702 
 703   g_return_val_if_fail (dataset_location != NULL, NULL);
 704 
 705   G_LOCK (g_dataset_global);
 706   if (key_id &amp;&amp; g_dataset_location_ht)
 707     {
 708       GDataset *dataset;
 709 
 710       dataset = g_dataset_lookup (dataset_location);
 711       if (dataset)
<span class="line-modified"> 712     ret_data = g_data_set_internal (&amp;dataset-&gt;datalist, key_id, NULL, (GDestroyNotify) 42, dataset);</span>
 713     }
 714   G_UNLOCK (g_dataset_global);
 715 
 716   return ret_data;
 717 }
 718 
 719 /**
 720  * g_datalist_id_remove_no_notify: (skip)
 721  * @datalist: a datalist.
 722  * @key_id: the #GQuark identifying a data element.
 723  *
 724  * Removes an element, without calling its destroy notification
 725  * function.
 726  *
 727  * Returns: (nullable): the data previously stored at @key_id,
 728  *          or %NULL if none.
 729  **/
 730 /**
 731  * g_datalist_remove_no_notify: (skip)
 732  * @dl: a datalist.
 733  * @k: the string identifying the data element.
 734  *
 735  * Removes an element, without calling its destroy notifier.
 736  **/
 737 gpointer
<span class="line-modified"> 738 g_datalist_id_remove_no_notify (GData   **datalist,</span>
<span class="line-modified"> 739                                 GQuark    key_id)</span>
 740 {
 741   gpointer ret_data = NULL;
 742 
 743   g_return_val_if_fail (datalist != NULL, NULL);
 744 
 745   if (key_id)
 746     ret_data = g_data_set_internal (datalist, key_id, NULL, (GDestroyNotify) 42, NULL);
 747 
 748   return ret_data;
 749 }
 750 
 751 /**
 752  * g_dataset_id_get_data:
 753  * @dataset_location: (not nullable): the location identifying the dataset.
 754  * @key_id: the #GQuark id to identify the data element.
 755  *
 756  * Gets the data element corresponding to a #GQuark.
 757  *
 758  * Returns: (transfer none) (nullable): the data element corresponding to
 759  *          the #GQuark, or %NULL if it is not found.
 760  **/
 761 /**
 762  * g_dataset_get_data:
 763  * @l: the location identifying the dataset.
 764  * @k: the string identifying the data element.
 765  *
 766  * Gets the data element corresponding to a string.
 767  *
 768  * Returns: (transfer none) (nullable): the data element corresponding to
 769  *          the string, or %NULL if it is not found.
 770  **/
 771 gpointer
 772 g_dataset_id_get_data (gconstpointer  dataset_location,
<span class="line-modified"> 773                        GQuark         key_id)</span>
 774 {
 775   gpointer retval = NULL;
 776 
 777   g_return_val_if_fail (dataset_location != NULL, NULL);
 778 
 779   G_LOCK (g_dataset_global);
 780   if (key_id &amp;&amp; g_dataset_location_ht)
 781     {
 782       GDataset *dataset;
 783 
 784       dataset = g_dataset_lookup (dataset_location);
 785       if (dataset)
<span class="line-modified"> 786     retval = g_datalist_id_get_data (&amp;dataset-&gt;datalist, key_id);</span>
 787     }
 788   G_UNLOCK (g_dataset_global);
 789 
 790   return retval;
 791 }
 792 
 793 /**
 794  * g_datalist_id_get_data:
 795  * @datalist: a datalist.
 796  * @key_id: the #GQuark identifying a data element.
 797  *
 798  * Retrieves the data element corresponding to @key_id.
 799  *
 800  * Returns: (transfer none) (nullable): the data element, or %NULL if
 801  *          it is not found.
 802  */
 803 gpointer
 804 g_datalist_id_get_data (GData  **datalist,
<span class="line-modified"> 805                         GQuark   key_id)</span>
 806 {
 807   return g_datalist_id_dup_data (datalist, key_id, NULL, NULL);
 808 }
 809 
 810 /**
 811  * GDuplicateFunc:
 812  * @data: the data to duplicate
 813  * @user_data: (closure): user data that was specified in
 814  *             g_datalist_id_dup_data()
 815  *
 816  * The type of functions that are used to &#39;duplicate&#39; an object.
 817  * What this means depends on the context, it could just be
 818  * incrementing the reference count, if @data is a ref-counted
 819  * object.
 820  *
 821  * Returns: a duplicate of data
 822  */
 823 
 824 /**
 825  * g_datalist_id_dup_data: (skip)
</pre>
<hr />
<pre>
 967                      if (d-&gt;len == 0)
 968                        {
 969                          G_DATALIST_SET_POINTER (datalist, NULL);
 970                          g_free (d);
 971                        }
 972                    }
 973                 }
 974               break;
 975             }
 976           data++;
 977         }
 978     }
 979 
 980   if (val == NULL &amp;&amp; oldval == NULL &amp;&amp; newval != NULL)
 981     {
 982       GData *old_d;
 983 
 984       /* insert newval */
 985       old_d = d;
 986       if (d == NULL)
<span class="line-modified"> 987     {</span>
 988           d = g_malloc (sizeof (GData));
 989           d-&gt;len = 0;
 990           d-&gt;alloc = 1;
 991         }
 992       else if (d-&gt;len == d-&gt;alloc)
 993         {
 994           d-&gt;alloc = d-&gt;alloc * 2;
 995           d = g_realloc (d, sizeof (GData) + (d-&gt;alloc - 1) * sizeof (GDataElt));
 996         }
 997       if (old_d != d)
 998         G_DATALIST_SET_POINTER (datalist, d);
 999 
1000       d-&gt;data[d-&gt;len].key = key_id;
1001       d-&gt;data[d-&gt;len].data = newval;
1002       d-&gt;data[d-&gt;len].destroy = destroy;
1003       d-&gt;len++;
1004     }
1005 
1006   g_datalist_unlock (datalist);
1007 
1008   return val == oldval;
1009 }
1010 
1011 /**
1012  * g_datalist_get_data:
1013  * @datalist: a datalist.
1014  * @key: the string identifying a data element.
1015  *
1016  * Gets a data element, using its string identifier. This is slower than
1017  * g_datalist_id_get_data() because it compares strings.
1018  *
1019  * Returns: (transfer none) (nullable): the data element, or %NULL if it
1020  *          is not found.
1021  **/
1022 gpointer
1023 g_datalist_get_data (GData   **datalist,
<span class="line-modified">1024                      const gchar *key)</span>
1025 {
1026   gpointer res = NULL;
1027   GData *d;
1028   GDataElt *data, *data_end;
1029 
1030   g_return_val_if_fail (datalist != NULL, NULL);
1031 
1032   g_datalist_lock (datalist);
1033 
1034   d = G_DATALIST_GET_POINTER (datalist);
1035   if (d)
1036     {
1037       data = d-&gt;data;
1038       data_end = data + d-&gt;len;
1039       while (data &lt; data_end)
<span class="line-modified">1040     {</span>
<span class="line-modified">1041       if (g_strcmp0 (g_quark_to_string (data-&gt;key), key) == 0)</span>
<span class="line-modified">1042         {</span>
<span class="line-modified">1043           res = data-&gt;data;</span>
<span class="line-modified">1044           break;</span>
<span class="line-modified">1045         }</span>
<span class="line-modified">1046       data++;</span>
<span class="line-modified">1047     }</span>
1048     }
1049 
1050   g_datalist_unlock (datalist);
1051 
1052   return res;
1053 }
1054 
1055 /**
1056  * GDataForeachFunc:
1057  * @key_id: the #GQuark id to identifying the data element.
1058  * @data: the data element.
1059  * @user_data: (closure): user data passed to g_dataset_foreach().
1060  *
1061  * Specifies the type of function passed to g_dataset_foreach(). It is
1062  * called with each #GQuark id and associated data element, together
1063  * with the @user_data parameter supplied to g_dataset_foreach().
1064  **/
1065 
1066 /**
1067  * g_dataset_foreach:
1068  * @dataset_location: (not nullable): the location identifying the dataset.
1069  * @func: (scope call): the function to call for each data element.
1070  * @user_data: (closure): user data to pass to the function.
1071  *
1072  * Calls the given function for each data element which is associated
1073  * with the given location. Note that this function is NOT thread-safe.
1074  * So unless @dataset_location can be protected from any modifications
1075  * during invocation of this function, it should not be called.
1076  *
1077  * @func can make changes to the dataset, but the iteration will not
1078  * reflect changes made during the g_dataset_foreach() call, other
1079  * than skipping over elements that are removed.
1080  **/
1081 void
1082 g_dataset_foreach (gconstpointer    dataset_location,
<span class="line-modified">1083            GDataForeachFunc func,</span>
<span class="line-modified">1084            gpointer         user_data)</span>
1085 {
1086   GDataset *dataset;
1087 
1088   g_return_if_fail (dataset_location != NULL);
1089   g_return_if_fail (func != NULL);
1090 
1091   G_LOCK (g_dataset_global);
1092   if (g_dataset_location_ht)
1093     {
1094       dataset = g_dataset_lookup (dataset_location);
1095       G_UNLOCK (g_dataset_global);
1096       if (dataset)
<span class="line-modified">1097     g_datalist_foreach (&amp;dataset-&gt;datalist, func, user_data);</span>
1098     }
1099   else
1100     {
1101       G_UNLOCK (g_dataset_global);
1102     }
1103 }
1104 
1105 /**
1106  * g_datalist_foreach:
1107  * @datalist: a datalist.
1108  * @func: (scope call): the function to call for each data element.
1109  * @user_data: (closure): user data to pass to the function.
1110  *
1111  * Calls the given function for each data element of the datalist. The
1112  * function is called with each data element&#39;s #GQuark id and data,
1113  * together with the given @user_data parameter. Note that this
1114  * function is NOT thread-safe. So unless @datalist can be protected
1115  * from any modifications during invocation of this function, it should
1116  * not be called.
1117  *
1118  * @func can make changes to @datalist, but the iteration will not
1119  * reflect changes made during the g_datalist_foreach() call, other
1120  * than skipping over elements that are removed.
1121  **/
1122 void
<span class="line-modified">1123 g_datalist_foreach (GData      **datalist,</span>
<span class="line-modified">1124                     GDataForeachFunc func,</span>
<span class="line-modified">1125                     gpointer         user_data)</span>
1126 {
1127   GData *d;
<span class="line-modified">1128   int i, j, len;</span>
1129   GQuark *keys;
1130 
1131   g_return_if_fail (datalist != NULL);
1132   g_return_if_fail (func != NULL);
1133 
1134   d = G_DATALIST_GET_POINTER (datalist);
1135   if (d == NULL)
1136     return;
1137 
1138   /* We make a copy of the keys so that we can handle it changing
1139      in the callback */
1140   len = d-&gt;len;
1141   keys = g_new (GQuark, len);
1142   for (i = 0; i &lt; len; i++)
1143     keys[i] = d-&gt;data[i].key;
1144 
1145   for (i = 0; i &lt; len; i++)
1146     {
1147       /* A previous callback might have removed a later item, so always check that
<span class="line-modified">1148      it still exists before calling */</span>
1149       d = G_DATALIST_GET_POINTER (datalist);
1150 
1151       if (d == NULL)
<span class="line-modified">1152     break;</span>
1153       for (j = 0; j &lt; d-&gt;len; j++)
<span class="line-modified">1154     {</span>
<span class="line-modified">1155       if (d-&gt;data[j].key == keys[i]) {</span>
<span class="line-modified">1156         func (d-&gt;data[i].key, d-&gt;data[i].data, user_data);</span>
<span class="line-modified">1157         break;</span>
<span class="line-removed">1158       }</span>
1159     }

1160     }
1161   g_free (keys);
1162 }
1163 
1164 /**
1165  * g_datalist_init: (skip)
1166  * @datalist: a pointer to a pointer to a datalist.
1167  *
1168  * Resets the datalist to %NULL. It does not free any memory or call
1169  * any destroy functions.
1170  **/
1171 void
1172 g_datalist_init (GData **datalist)
1173 {
1174   g_return_if_fail (datalist != NULL);
1175 
1176   g_atomic_pointer_set (datalist, NULL);
1177 }
1178 
1179 /**
1180  * g_datalist_set_flags:
1181  * @datalist: pointer to the location that holds a list
1182  * @flags: the flags to turn on. The values of the flags are
1183  *   restricted by %G_DATALIST_FLAGS_MASK (currently
1184  *   3; giving two possible boolean flags).
1185  *   A value for @flags that doesn&#39;t fit within the mask is
1186  *   an error.
1187  *
1188  * Turns on flag values for a data list. This function is used
1189  * to keep a small number of boolean flags in an object with
1190  * a data list without using any additional space. It is
1191  * not generally useful except in circumstances where space
1192  * is very tight. (It is used in the base #GObject type, for
1193  * example.)
1194  *
1195  * Since: 2.8
1196  **/
1197 void
1198 g_datalist_set_flags (GData **datalist,
<span class="line-modified">1199                       guint   flags)</span>
1200 {
1201   g_return_if_fail (datalist != NULL);
1202   g_return_if_fail ((flags &amp; ~G_DATALIST_FLAGS_MASK) == 0);
1203 
1204   g_atomic_pointer_or (datalist, (gsize)flags);
1205 }
1206 
1207 /**
1208  * g_datalist_unset_flags:
1209  * @datalist: pointer to the location that holds a list
1210  * @flags: the flags to turn off. The values of the flags are
1211  *   restricted by %G_DATALIST_FLAGS_MASK (currently
1212  *   3: giving two possible boolean flags).
1213  *   A value for @flags that doesn&#39;t fit within the mask is
1214  *   an error.
1215  *
1216  * Turns off flag values for a data list. See g_datalist_unset_flags()
1217  *
1218  * Since: 2.8
1219  **/
1220 void
1221 g_datalist_unset_flags (GData **datalist,
<span class="line-modified">1222                         guint   flags)</span>
1223 {
1224   g_return_if_fail (datalist != NULL);
1225   g_return_if_fail ((flags &amp; ~G_DATALIST_FLAGS_MASK) == 0);
1226 
1227   g_atomic_pointer_and (datalist, ~(gsize)flags);
1228 }
1229 
1230 /**
1231  * g_datalist_get_flags:
1232  * @datalist: pointer to the location that holds a list
1233  *
1234  * Gets flags values packed in together with the datalist.
1235  * See g_datalist_set_flags().
1236  *
1237  * Returns: the flags of the datalist
1238  *
1239  * Since: 2.8
1240  **/
1241 guint
1242 g_datalist_get_flags (GData **datalist)
</pre>
</td>
<td>
<hr />
<pre>
 121 /**
 122  * GData:
 123  *
 124  * The #GData struct is an opaque data structure to represent a
 125  * [Keyed Data List][glib-Keyed-Data-Lists]. It should only be
 126  * accessed via the following functions.
 127  **/
 128 
 129 /**
 130  * GDestroyNotify:
 131  * @data: the data element.
 132  *
 133  * Specifies the type of function which is called when a data element
 134  * is destroyed. It is passed the pointer to the data element and
 135  * should free any memory and resources allocated for it.
 136  **/
 137 
 138 #define G_DATALIST_FLAGS_MASK_INTERNAL 0x7
 139 
 140 /* datalist pointer accesses have to be carried out atomically */
<span class="line-modified"> 141 #define G_DATALIST_GET_POINTER(datalist)            \</span>
 142   ((GData*) ((gsize) g_atomic_pointer_get (datalist) &amp; ~(gsize) G_DATALIST_FLAGS_MASK_INTERNAL))
 143 
 144 #define G_DATALIST_SET_POINTER(datalist, pointer)       G_STMT_START {                  \
 145   gpointer _oldv, _newv;                                                                \
 146   do {                                                                                  \
 147     _oldv = g_atomic_pointer_get (datalist);                                            \
 148     _newv = (gpointer) (((gsize) _oldv &amp; G_DATALIST_FLAGS_MASK_INTERNAL) | (gsize) pointer);     \
 149   } while (!g_atomic_pointer_compare_and_exchange ((void**) datalist, _oldv, _newv));   \
 150 } G_STMT_END
 151 
 152 /* --- structures --- */
 153 typedef struct {
 154   GQuark          key;
 155   gpointer        data;
 156   GDestroyNotify  destroy;
 157 } GDataElt;
 158 
 159 typedef struct _GDataset GDataset;
 160 struct _GData
 161 {
 162   guint32  len;     /* Number of elements */
 163   guint32  alloc;   /* Number of allocated elements */
 164   GDataElt data[1]; /* Flexible array */
 165 };
 166 
 167 struct _GDataset
 168 {
 169   gconstpointer location;
 170   GData        *datalist;
 171 };
 172 
 173 
 174 /* --- prototypes --- */
<span class="line-modified"> 175 static inline GDataset* g_dataset_lookup    (gconstpointer    dataset_location);</span>
<span class="line-modified"> 176 static inline void  g_datalist_clear_i    (GData    **datalist);</span>
<span class="line-modified"> 177 static void   g_dataset_destroy_internal  (GDataset  *dataset);</span>
<span class="line-modified"> 178 static inline gpointer  g_data_set_internal   (GData      **datalist,</span>
<span class="line-modified"> 179                GQuark       key_id,</span>
<span class="line-modified"> 180                gpointer         data,</span>
<span class="line-modified"> 181                GDestroyNotify   destroy_func,</span>
<span class="line-modified"> 182                GDataset  *dataset);</span>
<span class="line-modified"> 183 static void   g_data_initialize   (void);</span>
 184 
 185 /* Locking model:
 186  * Each standalone GDataList is protected by a bitlock in the datalist pointer,
 187  * which protects that modification of the non-flags part of the datalist pointer
 188  * and the contents of the datalist.
 189  *
 190  * For GDataSet we have a global lock g_dataset_global that protects
 191  * the global dataset hash and cache, and additionally it protects the
 192  * datalist such that we can avoid to use the bit lock in a few places
 193  * where it is easy.
 194  */
 195 
 196 /* --- variables --- */
 197 G_LOCK_DEFINE_STATIC (g_dataset_global);
 198 static GHashTable   *g_dataset_location_ht = NULL;
 199 static GDataset     *g_dataset_cached = NULL; /* should this be
<span class="line-modified"> 200              thread specific? */</span>
 201 
 202 /* --- functions --- */
 203 
 204 #define DATALIST_LOCK_BIT 2
 205 
 206 static void
 207 g_datalist_lock (GData **datalist)
 208 {
 209   g_pointer_bit_lock ((void **)datalist, DATALIST_LOCK_BIT);
 210 }
 211 
 212 static void
 213 g_datalist_unlock (GData **datalist)
 214 {
 215   g_pointer_bit_unlock ((void **)datalist, DATALIST_LOCK_BIT);
 216 }
 217 
 218 /* Called with the datalist lock held, or the dataset global
 219  * lock for dataset lists
 220  */
 221 static void
 222 g_datalist_clear_i (GData **datalist)
 223 {
 224   GData *data;
<span class="line-modified"> 225   guint i;</span>
 226 
 227   data = G_DATALIST_GET_POINTER (datalist);
 228   G_DATALIST_SET_POINTER (datalist, NULL);
 229 
 230   if (data)
 231     {
 232       G_UNLOCK (g_dataset_global);
 233       for (i = 0; i &lt; data-&gt;len; i++)
 234         {
 235           if (data-&gt;data[i].data &amp;&amp; data-&gt;data[i].destroy)
 236             data-&gt;data[i].destroy (data-&gt;data[i].data);
 237         }
 238       G_LOCK (g_dataset_global);
 239 
 240       g_free (data);
 241     }
 242 
 243 }
 244 
 245 /**
 246  * g_datalist_clear: (skip)
 247  * @datalist: a datalist.
 248  *
 249  * Frees all the data elements of the datalist.
 250  * The data elements&#39; destroy functions are called
 251  * if they have been set.
 252  **/
 253 void
 254 g_datalist_clear (GData **datalist)
 255 {
 256   GData *data;
<span class="line-modified"> 257   guint i;</span>
 258 
 259   g_return_if_fail (datalist != NULL);
 260 
 261   g_datalist_lock (datalist);
 262 
 263   data = G_DATALIST_GET_POINTER (datalist);
 264   G_DATALIST_SET_POINTER (datalist, NULL);
 265 
 266   g_datalist_unlock (datalist);
 267 
 268   if (data)
 269     {
 270       for (i = 0; i &lt; data-&gt;len; i++)
 271         {
 272           if (data-&gt;data[i].data &amp;&amp; data-&gt;data[i].destroy)
 273             data-&gt;data[i].destroy (data-&gt;data[i].data);
 274         }
 275 
 276       g_free (data);
 277     }
</pre>
<hr />
<pre>
 286   if (g_dataset_cached &amp;&amp; g_dataset_cached-&gt;location == dataset_location)
 287     return g_dataset_cached;
 288 
 289   dataset = g_hash_table_lookup (g_dataset_location_ht, dataset_location);
 290   if (dataset)
 291     g_dataset_cached = dataset;
 292 
 293   return dataset;
 294 }
 295 
 296 /* HOLDS: g_dataset_global_lock */
 297 static void
 298 g_dataset_destroy_internal (GDataset *dataset)
 299 {
 300   gconstpointer dataset_location;
 301 
 302   dataset_location = dataset-&gt;location;
 303   while (dataset)
 304     {
 305       if (G_DATALIST_GET_POINTER(&amp;dataset-&gt;datalist) == NULL)
<span class="line-modified"> 306   {</span>
<span class="line-modified"> 307     if (dataset == g_dataset_cached)</span>
<span class="line-modified"> 308       g_dataset_cached = NULL;</span>
<span class="line-modified"> 309     g_hash_table_remove (g_dataset_location_ht, dataset_location);</span>
<span class="line-modified"> 310     g_slice_free (GDataset, dataset);</span>
<span class="line-modified"> 311     break;</span>
<span class="line-modified"> 312   }</span>
 313 
 314       g_datalist_clear_i (&amp;dataset-&gt;datalist);
 315       dataset = g_dataset_lookup (dataset_location);
 316     }
 317 }
 318 
 319 /**
 320  * g_dataset_destroy:
 321  * @dataset_location: (not nullable): the location identifying the dataset.
 322  *
 323  * Destroys the dataset, freeing all memory allocated, and calling any
 324  * destroy functions set for data elements.
 325  */
 326 void
 327 g_dataset_destroy (gconstpointer  dataset_location)
 328 {
 329   g_return_if_fail (dataset_location != NULL);
 330 
 331   G_LOCK (g_dataset_global);
 332   if (g_dataset_location_ht)
 333     {
 334       GDataset *dataset;
 335 
 336       dataset = g_dataset_lookup (dataset_location);
 337       if (dataset)
<span class="line-modified"> 338   g_dataset_destroy_internal (dataset);</span>
 339     }
 340   G_UNLOCK (g_dataset_global);
 341 }
 342 
 343 /* HOLDS: g_dataset_global_lock if dataset != null */
 344 static inline gpointer
 345 g_data_set_internal (GData    **datalist,
<span class="line-modified"> 346          GQuark         key_id,</span>
<span class="line-modified"> 347          gpointer       new_data,</span>
<span class="line-modified"> 348          GDestroyNotify new_destroy_func,</span>
<span class="line-modified"> 349          GDataset    *dataset)</span>
 350 {
 351   GData *d, *old_d;
 352   GDataElt old, *data, *data_last, *data_end;
 353 
 354   g_datalist_lock (datalist);
 355 
 356   d = G_DATALIST_GET_POINTER (datalist);
 357 
 358   if (new_data == NULL) /* remove */
 359     {
 360       if (d)
<span class="line-added"> 361   {</span>
<span class="line-added"> 362     data = d-&gt;data;</span>
<span class="line-added"> 363     data_last = data + d-&gt;len - 1;</span>
<span class="line-added"> 364     while (data &lt;= data_last)</span>
<span class="line-added"> 365       {</span>
<span class="line-added"> 366         if (data-&gt;key == key_id)</span>
 367     {
<span class="line-modified"> 368       old = *data;</span>
<span class="line-modified"> 369       if (data != data_last)</span>
<span class="line-modified"> 370         *data = *data_last;</span>
<span class="line-modified"> 371       d-&gt;len--;</span>






 372 
<span class="line-modified"> 373       /* We don&#39;t bother to shrink, but if all data are now gone</span>
<span class="line-modified"> 374        * we at least free the memory</span>
 375                    */
<span class="line-modified"> 376       if (d-&gt;len == 0)</span>
<span class="line-modified"> 377         {</span>
<span class="line-modified"> 378           G_DATALIST_SET_POINTER (datalist, NULL);</span>
<span class="line-modified"> 379           g_free (d);</span>
<span class="line-modified"> 380           /* datalist may be situated in dataset, so must not be</span>
<span class="line-modified"> 381            * unlocked after we free it</span>




















 382            */
<span class="line-modified"> 383           g_datalist_unlock (datalist);</span>








 384 
<span class="line-modified"> 385           /* the dataset destruction *must* be done</span>
<span class="line-added"> 386            * prior to invocation of the data destroy function</span>
<span class="line-added"> 387            */</span>
<span class="line-added"> 388           if (dataset)</span>
<span class="line-added"> 389       g_dataset_destroy_internal (dataset);</span>
 390         }
<span class="line-modified"> 391       else</span>
<span class="line-added"> 392         {</span>
<span class="line-added"> 393           g_datalist_unlock (datalist);</span>
 394         }
<span class="line-added"> 395 </span>
<span class="line-added"> 396       /* We found and removed an old value</span>
<span class="line-added"> 397        * the GData struct *must* already be unlinked</span>
<span class="line-added"> 398        * when invoking the destroy function.</span>
<span class="line-added"> 399        * we use (new_data==NULL &amp;&amp; new_destroy_func!=NULL) as</span>
<span class="line-added"> 400        * a special hint combination to &quot;steal&quot;</span>
<span class="line-added"> 401        * data without destroy notification</span>
<span class="line-added"> 402        */</span>
<span class="line-added"> 403       if (old.destroy &amp;&amp; !new_destroy_func)</span>
<span class="line-added"> 404         {</span>
<span class="line-added"> 405           if (dataset)</span>
<span class="line-added"> 406       G_UNLOCK (g_dataset_global);</span>
<span class="line-added"> 407           old.destroy (old.data);</span>
<span class="line-added"> 408           if (dataset)</span>
<span class="line-added"> 409       G_LOCK (g_dataset_global);</span>
<span class="line-added"> 410           old.data = NULL;</span>
<span class="line-added"> 411         }</span>
<span class="line-added"> 412 </span>
<span class="line-added"> 413       return old.data;</span>
 414     }
<span class="line-added"> 415         data++;</span>
<span class="line-added"> 416       }</span>
<span class="line-added"> 417   }</span>
 418     }
 419   else
 420     {
 421       old.data = NULL;
 422       if (d)
<span class="line-added"> 423   {</span>
<span class="line-added"> 424     data = d-&gt;data;</span>
<span class="line-added"> 425     data_end = data + d-&gt;len;</span>
<span class="line-added"> 426     while (data &lt; data_end)</span>
<span class="line-added"> 427       {</span>
<span class="line-added"> 428         if (data-&gt;key == key_id)</span>
 429     {
<span class="line-modified"> 430       if (!data-&gt;destroy)</span>




 431         {
<span class="line-modified"> 432           data-&gt;data = new_data;</span>
<span class="line-modified"> 433           data-&gt;destroy = new_destroy_func;</span>
<span class="line-modified"> 434           g_datalist_unlock (datalist);</span>






















 435         }
<span class="line-modified"> 436       else</span>
<span class="line-added"> 437         {</span>
<span class="line-added"> 438           old = *data;</span>
<span class="line-added"> 439           data-&gt;data = new_data;</span>
<span class="line-added"> 440           data-&gt;destroy = new_destroy_func;</span>
<span class="line-added"> 441 </span>
<span class="line-added"> 442           g_datalist_unlock (datalist);</span>
<span class="line-added"> 443 </span>
<span class="line-added"> 444           /* We found and replaced an old value</span>
<span class="line-added"> 445            * the GData struct *must* already be unlinked</span>
<span class="line-added"> 446            * when invoking the destroy function.</span>
<span class="line-added"> 447            */</span>
<span class="line-added"> 448           if (dataset)</span>
<span class="line-added"> 449       G_UNLOCK (g_dataset_global);</span>
<span class="line-added"> 450           old.destroy (old.data);</span>
<span class="line-added"> 451           if (dataset)</span>
<span class="line-added"> 452       G_LOCK (g_dataset_global);</span>
 453         }
<span class="line-added"> 454       return NULL;</span>
 455     }
<span class="line-added"> 456         data++;</span>
<span class="line-added"> 457       }</span>
<span class="line-added"> 458   }</span>
 459 
 460       /* The key was not found, insert it */
 461       old_d = d;
 462       if (d == NULL)
<span class="line-modified"> 463   {</span>
<span class="line-modified"> 464     d = g_malloc (sizeof (GData));</span>
<span class="line-modified"> 465     d-&gt;len = 0;</span>
<span class="line-modified"> 466     d-&gt;alloc = 1;</span>
<span class="line-modified"> 467   }</span>
 468       else if (d-&gt;len == d-&gt;alloc)
<span class="line-modified"> 469   {</span>
<span class="line-modified"> 470     d-&gt;alloc = d-&gt;alloc * 2;</span>
<span class="line-modified"> 471     d = g_realloc (d, sizeof (GData) + (d-&gt;alloc - 1) * sizeof (GDataElt));</span>
<span class="line-modified"> 472   }</span>
 473       if (old_d != d)
<span class="line-modified"> 474   G_DATALIST_SET_POINTER (datalist, d);</span>
 475 
 476       d-&gt;data[d-&gt;len].key = key_id;
 477       d-&gt;data[d-&gt;len].data = new_data;
 478       d-&gt;data[d-&gt;len].destroy = new_destroy_func;
 479       d-&gt;len++;
 480     }
 481 
 482   g_datalist_unlock (datalist);
 483 
 484   return NULL;
 485 
 486 }
 487 
 488 /**
 489  * g_dataset_id_set_data_full: (skip)
 490  * @dataset_location: (not nullable): the location identifying the dataset.
 491  * @key_id: the #GQuark id to identify the data element.
 492  * @data: the data element.
 493  * @destroy_func: the function to call when the data element is
 494  *                removed. This function will be called with the data
</pre>
<hr />
<pre>
 531  * Sets the data corresponding to the given string identifier.
 532  **/
 533 /**
 534  * g_dataset_id_remove_data:
 535  * @l: the location identifying the dataset.
 536  * @k: the #GQuark id identifying the data element.
 537  *
 538  * Removes a data element from a dataset. The data element&#39;s destroy
 539  * function is called if it has been set.
 540  **/
 541 /**
 542  * g_dataset_remove_data:
 543  * @l: the location identifying the dataset.
 544  * @k: the string identifying the data element.
 545  *
 546  * Removes a data element corresponding to a string. Its destroy
 547  * function is called if it has been set.
 548  **/
 549 void
 550 g_dataset_id_set_data_full (gconstpointer  dataset_location,
<span class="line-modified"> 551           GQuark         key_id,</span>
<span class="line-modified"> 552           gpointer       data,</span>
<span class="line-modified"> 553           GDestroyNotify destroy_func)</span>
 554 {
 555   GDataset *dataset;
 556 
 557   g_return_if_fail (dataset_location != NULL);
 558   if (!data)
 559     g_return_if_fail (destroy_func == NULL);
 560   if (!key_id)
 561     {
 562       if (data)
<span class="line-modified"> 563   g_return_if_fail (key_id &gt; 0);</span>
 564       else
<span class="line-modified"> 565   return;</span>
 566     }
 567 
 568   G_LOCK (g_dataset_global);
 569   if (!g_dataset_location_ht)
 570     g_data_initialize ();
 571 
 572   dataset = g_dataset_lookup (dataset_location);
 573   if (!dataset)
 574     {
 575       dataset = g_slice_new (GDataset);
 576 #ifdef GSTREAMER_LITE
 577       if (dataset == NULL) {
 578         G_UNLOCK (g_dataset_global);
 579         return;
 580       }
 581 #endif // GSTREAMER_LITE
 582       dataset-&gt;location = dataset_location;
 583       g_datalist_init (&amp;dataset-&gt;datalist);
 584       g_hash_table_insert (g_dataset_location_ht,
<span class="line-modified"> 585          (gpointer) dataset-&gt;location,</span>
<span class="line-modified"> 586          dataset);</span>
 587     }
 588 
 589   g_data_set_internal (&amp;dataset-&gt;datalist, key_id, data, destroy_func, dataset);
 590   G_UNLOCK (g_dataset_global);
 591 }
 592 
 593 /**
 594  * g_datalist_id_set_data_full: (skip)
 595  * @datalist: a datalist.
 596  * @key_id: the #GQuark to identify the data element.
 597  * @data: (nullable): the data element or %NULL to remove any previous element
 598  *        corresponding to @key_id.
 599  * @destroy_func: (nullable): the function to call when the data element is
 600  *                removed. This function will be called with the data
 601  *                element and can be used to free any memory allocated
 602  *                for it. If @data is %NULL, then @destroy_func must
 603  *                also be %NULL.
 604  *
 605  * Sets the data corresponding to the given #GQuark id, and the
 606  * function to be called when the element is removed from the datalist.
</pre>
<hr />
<pre>
 641  *
 642  * Sets the data element corresponding to the given string identifier.
 643  **/
 644 /**
 645  * g_datalist_id_remove_data:
 646  * @dl: a datalist.
 647  * @q: the #GQuark identifying the data element.
 648  *
 649  * Removes an element, using its #GQuark identifier.
 650  **/
 651 /**
 652  * g_datalist_remove_data:
 653  * @dl: a datalist.
 654  * @k: the string identifying the data element.
 655  *
 656  * Removes an element using its string identifier. The data element&#39;s
 657  * destroy function is called if it has been set.
 658  **/
 659 void
 660 g_datalist_id_set_data_full (GData    **datalist,
<span class="line-modified"> 661            GQuark         key_id,</span>
<span class="line-modified"> 662            gpointer       data,</span>
<span class="line-modified"> 663            GDestroyNotify destroy_func)</span>
 664 {
 665   g_return_if_fail (datalist != NULL);
 666   if (!data)
 667     g_return_if_fail (destroy_func == NULL);
 668   if (!key_id)
 669     {
 670       if (data)
<span class="line-modified"> 671   g_return_if_fail (key_id &gt; 0);</span>
 672       else
<span class="line-modified"> 673   return;</span>
 674     }
 675 
 676   g_data_set_internal (datalist, key_id, data, destroy_func, NULL);
 677 }
 678 
 679 /**
 680  * g_dataset_id_remove_no_notify: (skip)
 681  * @dataset_location: (not nullable): the location identifying the dataset.
 682  * @key_id: the #GQuark ID identifying the data element.
 683  *
 684  * Removes an element, without calling its destroy notification
 685  * function.
 686  *
 687  * Returns: (nullable): the data previously stored at @key_id,
 688  *          or %NULL if none.
 689  **/
 690 /**
 691  * g_dataset_remove_no_notify: (skip)
 692  * @l: the location identifying the dataset.
 693  * @k: the string identifying the data element.
 694  *
 695  * Removes an element, without calling its destroy notifier.
 696  **/
 697 gpointer
 698 g_dataset_id_remove_no_notify (gconstpointer  dataset_location,
<span class="line-modified"> 699              GQuark         key_id)</span>
 700 {
 701   gpointer ret_data = NULL;
 702 
 703   g_return_val_if_fail (dataset_location != NULL, NULL);
 704 
 705   G_LOCK (g_dataset_global);
 706   if (key_id &amp;&amp; g_dataset_location_ht)
 707     {
 708       GDataset *dataset;
 709 
 710       dataset = g_dataset_lookup (dataset_location);
 711       if (dataset)
<span class="line-modified"> 712   ret_data = g_data_set_internal (&amp;dataset-&gt;datalist, key_id, NULL, (GDestroyNotify) 42, dataset);</span>
 713     }
 714   G_UNLOCK (g_dataset_global);
 715 
 716   return ret_data;
 717 }
 718 
 719 /**
 720  * g_datalist_id_remove_no_notify: (skip)
 721  * @datalist: a datalist.
 722  * @key_id: the #GQuark identifying a data element.
 723  *
 724  * Removes an element, without calling its destroy notification
 725  * function.
 726  *
 727  * Returns: (nullable): the data previously stored at @key_id,
 728  *          or %NULL if none.
 729  **/
 730 /**
 731  * g_datalist_remove_no_notify: (skip)
 732  * @dl: a datalist.
 733  * @k: the string identifying the data element.
 734  *
 735  * Removes an element, without calling its destroy notifier.
 736  **/
 737 gpointer
<span class="line-modified"> 738 g_datalist_id_remove_no_notify (GData **datalist,</span>
<span class="line-modified"> 739         GQuark    key_id)</span>
 740 {
 741   gpointer ret_data = NULL;
 742 
 743   g_return_val_if_fail (datalist != NULL, NULL);
 744 
 745   if (key_id)
 746     ret_data = g_data_set_internal (datalist, key_id, NULL, (GDestroyNotify) 42, NULL);
 747 
 748   return ret_data;
 749 }
 750 
 751 /**
 752  * g_dataset_id_get_data:
 753  * @dataset_location: (not nullable): the location identifying the dataset.
 754  * @key_id: the #GQuark id to identify the data element.
 755  *
 756  * Gets the data element corresponding to a #GQuark.
 757  *
 758  * Returns: (transfer none) (nullable): the data element corresponding to
 759  *          the #GQuark, or %NULL if it is not found.
 760  **/
 761 /**
 762  * g_dataset_get_data:
 763  * @l: the location identifying the dataset.
 764  * @k: the string identifying the data element.
 765  *
 766  * Gets the data element corresponding to a string.
 767  *
 768  * Returns: (transfer none) (nullable): the data element corresponding to
 769  *          the string, or %NULL if it is not found.
 770  **/
 771 gpointer
 772 g_dataset_id_get_data (gconstpointer  dataset_location,
<span class="line-modified"> 773            GQuark         key_id)</span>
 774 {
 775   gpointer retval = NULL;
 776 
 777   g_return_val_if_fail (dataset_location != NULL, NULL);
 778 
 779   G_LOCK (g_dataset_global);
 780   if (key_id &amp;&amp; g_dataset_location_ht)
 781     {
 782       GDataset *dataset;
 783 
 784       dataset = g_dataset_lookup (dataset_location);
 785       if (dataset)
<span class="line-modified"> 786   retval = g_datalist_id_get_data (&amp;dataset-&gt;datalist, key_id);</span>
 787     }
 788   G_UNLOCK (g_dataset_global);
 789 
 790   return retval;
 791 }
 792 
 793 /**
 794  * g_datalist_id_get_data:
 795  * @datalist: a datalist.
 796  * @key_id: the #GQuark identifying a data element.
 797  *
 798  * Retrieves the data element corresponding to @key_id.
 799  *
 800  * Returns: (transfer none) (nullable): the data element, or %NULL if
 801  *          it is not found.
 802  */
 803 gpointer
 804 g_datalist_id_get_data (GData  **datalist,
<span class="line-modified"> 805       GQuark   key_id)</span>
 806 {
 807   return g_datalist_id_dup_data (datalist, key_id, NULL, NULL);
 808 }
 809 
 810 /**
 811  * GDuplicateFunc:
 812  * @data: the data to duplicate
 813  * @user_data: (closure): user data that was specified in
 814  *             g_datalist_id_dup_data()
 815  *
 816  * The type of functions that are used to &#39;duplicate&#39; an object.
 817  * What this means depends on the context, it could just be
 818  * incrementing the reference count, if @data is a ref-counted
 819  * object.
 820  *
 821  * Returns: a duplicate of data
 822  */
 823 
 824 /**
 825  * g_datalist_id_dup_data: (skip)
</pre>
<hr />
<pre>
 967                      if (d-&gt;len == 0)
 968                        {
 969                          G_DATALIST_SET_POINTER (datalist, NULL);
 970                          g_free (d);
 971                        }
 972                    }
 973                 }
 974               break;
 975             }
 976           data++;
 977         }
 978     }
 979 
 980   if (val == NULL &amp;&amp; oldval == NULL &amp;&amp; newval != NULL)
 981     {
 982       GData *old_d;
 983 
 984       /* insert newval */
 985       old_d = d;
 986       if (d == NULL)
<span class="line-modified"> 987   {</span>
 988           d = g_malloc (sizeof (GData));
 989           d-&gt;len = 0;
 990           d-&gt;alloc = 1;
 991         }
 992       else if (d-&gt;len == d-&gt;alloc)
 993         {
 994           d-&gt;alloc = d-&gt;alloc * 2;
 995           d = g_realloc (d, sizeof (GData) + (d-&gt;alloc - 1) * sizeof (GDataElt));
 996         }
 997       if (old_d != d)
 998         G_DATALIST_SET_POINTER (datalist, d);
 999 
1000       d-&gt;data[d-&gt;len].key = key_id;
1001       d-&gt;data[d-&gt;len].data = newval;
1002       d-&gt;data[d-&gt;len].destroy = destroy;
1003       d-&gt;len++;
1004     }
1005 
1006   g_datalist_unlock (datalist);
1007 
1008   return val == oldval;
1009 }
1010 
1011 /**
1012  * g_datalist_get_data:
1013  * @datalist: a datalist.
1014  * @key: the string identifying a data element.
1015  *
1016  * Gets a data element, using its string identifier. This is slower than
1017  * g_datalist_id_get_data() because it compares strings.
1018  *
1019  * Returns: (transfer none) (nullable): the data element, or %NULL if it
1020  *          is not found.
1021  **/
1022 gpointer
1023 g_datalist_get_data (GData   **datalist,
<span class="line-modified">1024          const gchar *key)</span>
1025 {
1026   gpointer res = NULL;
1027   GData *d;
1028   GDataElt *data, *data_end;
1029 
1030   g_return_val_if_fail (datalist != NULL, NULL);
1031 
1032   g_datalist_lock (datalist);
1033 
1034   d = G_DATALIST_GET_POINTER (datalist);
1035   if (d)
1036     {
1037       data = d-&gt;data;
1038       data_end = data + d-&gt;len;
1039       while (data &lt; data_end)
<span class="line-modified">1040   {</span>
<span class="line-modified">1041     if (g_strcmp0 (g_quark_to_string (data-&gt;key), key) == 0)</span>
<span class="line-modified">1042       {</span>
<span class="line-modified">1043         res = data-&gt;data;</span>
<span class="line-modified">1044         break;</span>
<span class="line-modified">1045       }</span>
<span class="line-modified">1046     data++;</span>
<span class="line-modified">1047   }</span>
1048     }
1049 
1050   g_datalist_unlock (datalist);
1051 
1052   return res;
1053 }
1054 
1055 /**
1056  * GDataForeachFunc:
1057  * @key_id: the #GQuark id to identifying the data element.
1058  * @data: the data element.
1059  * @user_data: (closure): user data passed to g_dataset_foreach().
1060  *
1061  * Specifies the type of function passed to g_dataset_foreach(). It is
1062  * called with each #GQuark id and associated data element, together
1063  * with the @user_data parameter supplied to g_dataset_foreach().
1064  **/
1065 
1066 /**
1067  * g_dataset_foreach:
1068  * @dataset_location: (not nullable): the location identifying the dataset.
1069  * @func: (scope call): the function to call for each data element.
1070  * @user_data: (closure): user data to pass to the function.
1071  *
1072  * Calls the given function for each data element which is associated
1073  * with the given location. Note that this function is NOT thread-safe.
1074  * So unless @dataset_location can be protected from any modifications
1075  * during invocation of this function, it should not be called.
1076  *
1077  * @func can make changes to the dataset, but the iteration will not
1078  * reflect changes made during the g_dataset_foreach() call, other
1079  * than skipping over elements that are removed.
1080  **/
1081 void
1082 g_dataset_foreach (gconstpointer    dataset_location,
<span class="line-modified">1083        GDataForeachFunc func,</span>
<span class="line-modified">1084        gpointer         user_data)</span>
1085 {
1086   GDataset *dataset;
1087 
1088   g_return_if_fail (dataset_location != NULL);
1089   g_return_if_fail (func != NULL);
1090 
1091   G_LOCK (g_dataset_global);
1092   if (g_dataset_location_ht)
1093     {
1094       dataset = g_dataset_lookup (dataset_location);
1095       G_UNLOCK (g_dataset_global);
1096       if (dataset)
<span class="line-modified">1097   g_datalist_foreach (&amp;dataset-&gt;datalist, func, user_data);</span>
1098     }
1099   else
1100     {
1101       G_UNLOCK (g_dataset_global);
1102     }
1103 }
1104 
1105 /**
1106  * g_datalist_foreach:
1107  * @datalist: a datalist.
1108  * @func: (scope call): the function to call for each data element.
1109  * @user_data: (closure): user data to pass to the function.
1110  *
1111  * Calls the given function for each data element of the datalist. The
1112  * function is called with each data element&#39;s #GQuark id and data,
1113  * together with the given @user_data parameter. Note that this
1114  * function is NOT thread-safe. So unless @datalist can be protected
1115  * from any modifications during invocation of this function, it should
1116  * not be called.
1117  *
1118  * @func can make changes to @datalist, but the iteration will not
1119  * reflect changes made during the g_datalist_foreach() call, other
1120  * than skipping over elements that are removed.
1121  **/
1122 void
<span class="line-modified">1123 g_datalist_foreach (GData    **datalist,</span>
<span class="line-modified">1124         GDataForeachFunc func,</span>
<span class="line-modified">1125         gpointer         user_data)</span>
1126 {
1127   GData *d;
<span class="line-modified">1128   guint i, j, len;</span>
1129   GQuark *keys;
1130 
1131   g_return_if_fail (datalist != NULL);
1132   g_return_if_fail (func != NULL);
1133 
1134   d = G_DATALIST_GET_POINTER (datalist);
1135   if (d == NULL)
1136     return;
1137 
1138   /* We make a copy of the keys so that we can handle it changing
1139      in the callback */
1140   len = d-&gt;len;
1141   keys = g_new (GQuark, len);
1142   for (i = 0; i &lt; len; i++)
1143     keys[i] = d-&gt;data[i].key;
1144 
1145   for (i = 0; i &lt; len; i++)
1146     {
1147       /* A previous callback might have removed a later item, so always check that
<span class="line-modified">1148    it still exists before calling */</span>
1149       d = G_DATALIST_GET_POINTER (datalist);
1150 
1151       if (d == NULL)
<span class="line-modified">1152   break;</span>
1153       for (j = 0; j &lt; d-&gt;len; j++)
<span class="line-modified">1154   {</span>
<span class="line-modified">1155     if (d-&gt;data[j].key == keys[i]) {</span>
<span class="line-modified">1156       func (d-&gt;data[i].key, d-&gt;data[i].data, user_data);</span>
<span class="line-modified">1157       break;</span>

1158     }
<span class="line-added">1159   }</span>
1160     }
1161   g_free (keys);
1162 }
1163 
1164 /**
1165  * g_datalist_init: (skip)
1166  * @datalist: a pointer to a pointer to a datalist.
1167  *
1168  * Resets the datalist to %NULL. It does not free any memory or call
1169  * any destroy functions.
1170  **/
1171 void
1172 g_datalist_init (GData **datalist)
1173 {
1174   g_return_if_fail (datalist != NULL);
1175 
1176   g_atomic_pointer_set (datalist, NULL);
1177 }
1178 
1179 /**
1180  * g_datalist_set_flags:
1181  * @datalist: pointer to the location that holds a list
1182  * @flags: the flags to turn on. The values of the flags are
1183  *   restricted by %G_DATALIST_FLAGS_MASK (currently
1184  *   3; giving two possible boolean flags).
1185  *   A value for @flags that doesn&#39;t fit within the mask is
1186  *   an error.
1187  *
1188  * Turns on flag values for a data list. This function is used
1189  * to keep a small number of boolean flags in an object with
1190  * a data list without using any additional space. It is
1191  * not generally useful except in circumstances where space
1192  * is very tight. (It is used in the base #GObject type, for
1193  * example.)
1194  *
1195  * Since: 2.8
1196  **/
1197 void
1198 g_datalist_set_flags (GData **datalist,
<span class="line-modified">1199           guint   flags)</span>
1200 {
1201   g_return_if_fail (datalist != NULL);
1202   g_return_if_fail ((flags &amp; ~G_DATALIST_FLAGS_MASK) == 0);
1203 
1204   g_atomic_pointer_or (datalist, (gsize)flags);
1205 }
1206 
1207 /**
1208  * g_datalist_unset_flags:
1209  * @datalist: pointer to the location that holds a list
1210  * @flags: the flags to turn off. The values of the flags are
1211  *   restricted by %G_DATALIST_FLAGS_MASK (currently
1212  *   3: giving two possible boolean flags).
1213  *   A value for @flags that doesn&#39;t fit within the mask is
1214  *   an error.
1215  *
1216  * Turns off flag values for a data list. See g_datalist_unset_flags()
1217  *
1218  * Since: 2.8
1219  **/
1220 void
1221 g_datalist_unset_flags (GData **datalist,
<span class="line-modified">1222       guint   flags)</span>
1223 {
1224   g_return_if_fail (datalist != NULL);
1225   g_return_if_fail ((flags &amp; ~G_DATALIST_FLAGS_MASK) == 0);
1226 
1227   g_atomic_pointer_and (datalist, ~(gsize)flags);
1228 }
1229 
1230 /**
1231  * g_datalist_get_flags:
1232  * @datalist: pointer to the location that holds a list
1233  *
1234  * Gets flags values packed in together with the datalist.
1235  * See g_datalist_set_flags().
1236  *
1237  * Returns: the flags of the datalist
1238  *
1239  * Since: 2.8
1240  **/
1241 guint
1242 g_datalist_get_flags (GData **datalist)
</pre>
</td>
</tr>
</table>
<center><a href="gconvert.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gdataset.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>