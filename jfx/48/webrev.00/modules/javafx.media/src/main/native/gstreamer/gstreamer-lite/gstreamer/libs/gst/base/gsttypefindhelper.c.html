<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gsttypefindhelper.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /* GStreamer
  2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
  3  * Copyright (C) 2000,2005 Wim Taymans &lt;wim@fluendo.com&gt;
  4  * Copyright (C) 2006      Tim-Philipp MÃ¼ller &lt;tim centricular net&gt;
  5  *
  6  * gsttypefindhelper.c:
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public
 19  * License along with this library; if not, write to the
 20  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  */
 23 
 24 /**
 25  * SECTION:gsttypefindhelper
 26  * @title: GstTypeFindHelper
 27  * @short_description: Utility functions for typefinding
 28  *
 29  * Utility functions for elements doing typefinding:
 30  * gst_type_find_helper() does typefinding in pull mode, while
 31  * gst_type_find_helper_for_buffer() is useful for elements needing to do
 32  * typefinding in push mode from a chain function.
 33  */
 34 
 35 #ifdef HAVE_CONFIG_H
 36 #  include &quot;config.h&quot;
 37 #endif
 38 
 39 #include &lt;stdlib.h&gt;
 40 #include &lt;string.h&gt;
 41 
 42 #include &quot;gsttypefindhelper.h&quot;
 43 
 44 /* ********************** typefinding in pull mode ************************ */
 45 
 46 static void
 47 helper_find_suggest (gpointer data, guint probability, GstCaps * caps);
 48 
 49 typedef struct
 50 {
 51   GstBuffer *buffer;
 52   GstMapInfo map;
 53 } GstMappedBuffer;
 54 
 55 typedef struct
 56 {
 57   GSList *buffers;              /* buffer cache */
 58   guint64 size;
 59   guint64 last_offset;
 60   GstTypeFindHelperGetRangeFunction func;
 61   GstTypeFindProbability best_probability;
 62   GstCaps *caps;
 63   GstTypeFindFactory *factory;  /* for logging */
 64   GstObject *obj;               /* for logging */
 65   GstObject *parent;
 66   GstFlowReturn flow_ret;
 67 } GstTypeFindHelper;
 68 
 69 /*
 70  * helper_find_peek:
 71  * @data: helper data struct
 72  * @off: stream offset
 73  * @size: block size
 74  *
 75  * Get data pointer within a stream. Keeps a cache of read buffers (partly
 76  * for performance reasons, but mostly because pointers returned by us need
 77  * to stay valid until typefinding has finished)
 78  *
 79  * Returns: (nullable): address of the data or %NULL if buffer does not cover
 80  * the requested range.
 81  */
 82 static const guint8 *
 83 helper_find_peek (gpointer data, gint64 offset, guint size)
 84 {
 85   GstTypeFindHelper *helper;
 86   GstBuffer *buffer;
 87   GSList *insert_pos = NULL;
 88   gsize buf_size;
 89   guint64 buf_offset;
 90   GstMappedBuffer *bmap;
 91 #if 0
 92   GstCaps *caps;
 93 #endif
 94 
 95   helper = (GstTypeFindHelper *) data;
 96 
 97   GST_LOG_OBJECT (helper-&gt;obj, &quot;&#39;%s&#39; called peek (%&quot; G_GINT64_FORMAT
 98       &quot;, %u)&quot;, GST_OBJECT_NAME (helper-&gt;factory), offset, size);
 99 
100   if (size == 0)
101     return NULL;
102 
103   if (offset &lt; 0) {
104     if (helper-&gt;size == -1 || helper-&gt;size &lt; -offset)
105       return NULL;
106 
107     offset += helper-&gt;size;
108   }
109 
110   /* see if we have a matching buffer already in our list */
111   if (size &gt; 0 &amp;&amp; offset &lt;= helper-&gt;last_offset) {
112     GSList *walk;
113 
114     for (walk = helper-&gt;buffers; walk; walk = walk-&gt;next) {
115       GstMappedBuffer *bmp = (GstMappedBuffer *) walk-&gt;data;
116       GstBuffer *buf = GST_BUFFER_CAST (bmp-&gt;buffer);
117 
118       buf_offset = GST_BUFFER_OFFSET (buf);
119       buf_size = bmp-&gt;map.size;
120 
121       /* buffers are kept sorted by end offset (highest first) in the list, so
122        * at this point we save the current position and stop searching if
123        * we&#39;re after the searched end offset */
124       if (buf_offset &lt;= offset) {
125         if ((offset + size) &lt; (buf_offset + buf_size)) {
126           /* must already have been mapped before */
127           return (guint8 *) bmp-&gt;map.data + (offset - buf_offset);
128         }
129       } else if (offset + size &gt;= buf_offset + buf_size) {
130         insert_pos = walk;
131         break;
132       }
133     }
134   }
135 
136   buffer = NULL;
137   /* some typefinders go in 1 byte steps over 1k of data and request
138    * small buffers. It is really inefficient to pull each time, and pulling
139    * a larger chunk is almost free. Trying to pull a larger chunk at the end
140    * of the file is also not a problem here, we&#39;ll just get a truncated buffer
141    * in that case (and we&#39;ll have to double-check the size we actually get
142    * anyway, see below) */
143   helper-&gt;flow_ret =
144       helper-&gt;func (helper-&gt;obj, helper-&gt;parent, offset, MAX (size, 4096),
145       &amp;buffer);
146 
147   if (helper-&gt;flow_ret != GST_FLOW_OK)
148     goto error;
149 
150 #if 0
151   caps = GST_BUFFER_CAPS (buffer);
152 
153   if (caps &amp;&amp; !gst_caps_is_empty (caps) &amp;&amp; !gst_caps_is_any (caps)) {
154     GST_DEBUG (&quot;buffer has caps %&quot; GST_PTR_FORMAT &quot;, suggest max probability&quot;,
155         caps);
156 
157     gst_caps_replace (&amp;helper-&gt;caps, caps);
158     helper-&gt;best_probability = GST_TYPE_FIND_MAXIMUM;
159 
160     gst_buffer_unref (buffer);
161     return NULL;
162   }
163 #endif
164 
165   /* getrange might silently return shortened buffers at the end of a file,
166    * we must, however, always return either the full requested data or %NULL */
167   buf_offset = GST_BUFFER_OFFSET (buffer);
168   buf_size = gst_buffer_get_size (buffer);
169 
170   if (buf_size &lt; size) {
171     GST_DEBUG (&quot;dropping short buffer of size %&quot; G_GSIZE_FORMAT &quot;,&quot;
172         &quot;requested size was %u&quot;, buf_size, size);
173     gst_buffer_unref (buffer);
174     return NULL;
175   }
176 
177   if (buf_offset != -1 &amp;&amp; buf_offset != offset) {
178     GST_DEBUG (&quot;dropping buffer with unexpected offset %&quot; G_GUINT64_FORMAT &quot;, &quot;
179         &quot;expected offset was %&quot; G_GUINT64_FORMAT, buf_offset, offset);
180     gst_buffer_unref (buffer);
181     return NULL;
182   }
183 
184   bmap = g_slice_new0 (GstMappedBuffer);
185 
186   if (!gst_buffer_map (buffer, &amp;bmap-&gt;map, GST_MAP_READ))
187     goto map_failed;
188 
189   bmap-&gt;buffer = buffer;
190 
191   if (insert_pos) {
192     helper-&gt;buffers = g_slist_insert_before (helper-&gt;buffers, insert_pos, bmap);
193   } else {
194     /* if insert_pos is not set, our offset is bigger than the largest offset
195      * we have so far; since we keep the list sorted with highest offsets
196      * first, we need to prepend the buffer to the list */
197     helper-&gt;last_offset = GST_BUFFER_OFFSET (buffer) + buf_size;
198     helper-&gt;buffers = g_slist_prepend (helper-&gt;buffers, bmap);
199   }
200 
201   return bmap-&gt;map.data;
202 
203 error:
204   {
205     GST_INFO (&quot;typefind function returned: %s&quot;,
206         gst_flow_get_name (helper-&gt;flow_ret));
207     return NULL;
208   }
209 map_failed:
210   {
211     GST_ERROR (&quot;map failed&quot;);
212     gst_buffer_unref (buffer);
213     g_slice_free (GstMappedBuffer, bmap);
214     return NULL;
215   }
216 }
217 
218 /*
219  * helper_find_suggest:
220  * @data: helper data struct
221  * @probability: probability of the match
222  * @caps: caps of the type
223  *
224  * If given @probability is higher, replace previously store caps.
225  */
226 static void
227 helper_find_suggest (gpointer data, guint probability, GstCaps * caps)
228 {
229   GstTypeFindHelper *helper = (GstTypeFindHelper *) data;
230 
231   GST_LOG_OBJECT (helper-&gt;obj,
232       &quot;&#39;%s&#39; called suggest (%u, %&quot; GST_PTR_FORMAT &quot;)&quot;,
233       GST_OBJECT_NAME (helper-&gt;factory), probability, caps);
234 
235   if (probability &gt; helper-&gt;best_probability) {
236     gst_caps_replace (&amp;helper-&gt;caps, caps);
237     helper-&gt;best_probability = probability;
238   }
239 }
240 
241 static guint64
242 helper_find_get_length (gpointer data)
243 {
244   GstTypeFindHelper *helper = (GstTypeFindHelper *) data;
245 
246   GST_LOG_OBJECT (helper-&gt;obj, &quot;&#39;%s&#39; called get_length, returning %&quot;
247       G_GUINT64_FORMAT, GST_OBJECT_NAME (helper-&gt;factory), helper-&gt;size);
248 
249   return helper-&gt;size;
250 }
251 
252 static GList *
253 prioritize_extension (GstObject * obj, GList * type_list,
254     const gchar * extension)
255 {
256   gint pos = 0;
257   GList *next, *l;
258 
259   if (!extension)
260     return type_list;
261 
262   /* move the typefinders for the extension first in the list. The idea is that
263    * when one of them returns MAX we don&#39;t need to search further as there is a
264    * very high chance we got the right type. */
265 
266   GST_LOG_OBJECT (obj, &quot;sorting typefind for extension %s to head&quot;, extension);
267 
268   for (l = type_list; l; l = next) {
269     const gchar *const *ext;
270     GstTypeFindFactory *factory;
271 
272     next = l-&gt;next;
273 
274     factory = GST_TYPE_FIND_FACTORY (l-&gt;data);
275 
276     ext = gst_type_find_factory_get_extensions (factory);
277     if (ext == NULL)
278       continue;
279 
280     GST_LOG_OBJECT (obj, &quot;testing factory %s for extension %s&quot;,
281         GST_OBJECT_NAME (factory), extension);
282 
283     while (*ext != NULL) {
284       if (strcmp (*ext, extension) == 0) {
285         /* found extension, move in front */
286         GST_LOG_OBJECT (obj, &quot;moving typefind for extension %s to head&quot;,
287             extension);
288         /* remove entry from list */
289         type_list = g_list_delete_link (type_list, l);
290         /* insert at the position */
291         type_list = g_list_insert (type_list, factory, pos);
292         /* next element will be inserted after this one */
293         pos++;
294         break;
295       }
296       ++ext;
297     }
298   }
299 
300   return type_list;
301 }
302 
303 /**
304  * gst_type_find_helper_get_range:
305  * @obj: A #GstObject that will be passed as first argument to @func
306  * @parent: (allow-none): the parent of @obj or %NULL
307  * @func: (scope call): A generic #GstTypeFindHelperGetRangeFunction that will
308  *        be used to access data at random offsets when doing the typefinding
309  * @size: The length in bytes
310  * @extension: (allow-none): extension of the media, or %NULL
311  * @prob: (out) (allow-none): location to store the probability of the found
312  *     caps, or %NULL
313  *
314  * Utility function to do pull-based typefinding. Unlike gst_type_find_helper()
315  * however, this function will use the specified function @func to obtain the
316  * data needed by the typefind functions, rather than operating on a given
317  * source pad. This is useful mostly for elements like tag demuxers which
318  * strip off data at the beginning and/or end of a file and want to typefind
319  * the stripped data stream before adding their own source pad (the specified
320  * callback can then call the upstream peer pad with offsets adjusted for the
321  * tag size, for example).
322  *
323  * When @extension is not %NULL, this function will first try the typefind
324  * functions for the given extension, which might speed up the typefinding
325  * in many cases.
326  *
327  * Free-function: gst_caps_unref
328  *
329  * Returns: (transfer full) (nullable): the #GstCaps corresponding to the data
330  *     stream.  Returns %NULL if no #GstCaps matches the data stream.
331  */
332 GstCaps *
333 gst_type_find_helper_get_range (GstObject * obj, GstObject * parent,
334     GstTypeFindHelperGetRangeFunction func, guint64 size,
335     const gchar * extension, GstTypeFindProbability * prob)
336 {
337   GstCaps *caps = NULL;
338 
339   gst_type_find_helper_get_range_full (obj, parent, func, size, extension,
340       &amp;caps, prob);
341 
342   return caps;
343 }
344 
345 /**
346  * gst_type_find_helper_get_range_full:
347  * @obj: A #GstObject that will be passed as first argument to @func
348  * @parent: (allow-none): the parent of @obj or %NULL
349  * @func: (scope call): A generic #GstTypeFindHelperGetRangeFunction that will
350  *        be used to access data at random offsets when doing the typefinding
351  * @size: The length in bytes
352  * @extension: (allow-none): extension of the media, or %NULL
353  * @caps: (out) (transfer full): returned caps
354  * @prob: (out) (allow-none): location to store the probability of the found
355  *     caps, or %NULL
356  *
357  * Utility function to do pull-based typefinding. Unlike gst_type_find_helper()
358  * however, this function will use the specified function @func to obtain the
359  * data needed by the typefind functions, rather than operating on a given
360  * source pad. This is useful mostly for elements like tag demuxers which
361  * strip off data at the beginning and/or end of a file and want to typefind
362  * the stripped data stream before adding their own source pad (the specified
363  * callback can then call the upstream peer pad with offsets adjusted for the
364  * tag size, for example).
365  *
366  * When @extension is not %NULL, this function will first try the typefind
367  * functions for the given extension, which might speed up the typefinding
368  * in many cases.
369  *
370  * Returns: the last %GstFlowReturn from pulling a buffer or %GST_FLOW_OK if
371  *          typefinding was successful.
372  *
373  * Since: 1.14.3
374  */
375 GstFlowReturn
376 gst_type_find_helper_get_range_full (GstObject * obj, GstObject * parent,
377     GstTypeFindHelperGetRangeFunction func, guint64 size,
378     const gchar * extension, GstCaps ** caps, GstTypeFindProbability * prob)
379 {
380   GstTypeFindHelper helper;
381   GstTypeFind find;
382   GSList *walk;
383   GList *l, *type_list;
384   GstCaps *result = NULL;
385 
386   g_return_val_if_fail (GST_IS_OBJECT (obj), GST_FLOW_ERROR);
387   g_return_val_if_fail (func != NULL, GST_FLOW_ERROR);
388   g_return_val_if_fail (caps != NULL, GST_FLOW_ERROR);
389 
390   *caps = NULL;
391 
392   helper.buffers = NULL;
393   helper.size = size;
394   helper.last_offset = 0;
395   helper.func = func;
396   helper.best_probability = GST_TYPE_FIND_NONE;
397   helper.caps = NULL;
398   helper.obj = obj;
399   helper.parent = parent;
400   helper.flow_ret = GST_FLOW_OK;
401 
402   find.data = &amp;helper;
403   find.peek = helper_find_peek;
404   find.suggest = helper_find_suggest;
405 
406   if (size == 0 || size == (guint64) - 1) {
407     find.get_length = NULL;
408   } else {
409     find.get_length = helper_find_get_length;
410   }
411 
412   type_list = gst_type_find_factory_get_list ();
413   type_list = prioritize_extension (obj, type_list, extension);
414 
415   for (l = type_list; l; l = l-&gt;next) {
416     helper.factory = GST_TYPE_FIND_FACTORY (l-&gt;data);
417     gst_type_find_factory_call_function (helper.factory, &amp;find);
418     if (helper.best_probability &gt;= GST_TYPE_FIND_MAXIMUM) {
419       /* Any other flow return can be ignored here, we found
420        * something before any error with highest probability */
421       helper.flow_ret = GST_FLOW_OK;
422       break;
423     } else if (helper.flow_ret != GST_FLOW_OK
424         &amp;&amp; helper.flow_ret != GST_FLOW_EOS) {
425       /* We had less than maximum probability and an error, don&#39;t return
426        * any caps as they might be with a lower probability than what
427        * we would&#39;ve gotten when continuing if there was no error */
428       gst_caps_replace (&amp;helper.caps, NULL);
429       break;
430     }
431   }
432   gst_plugin_feature_list_free (type_list);
433 
434   for (walk = helper.buffers; walk; walk = walk-&gt;next) {
435     GstMappedBuffer *bmap = (GstMappedBuffer *) walk-&gt;data;
436 
437     gst_buffer_unmap (bmap-&gt;buffer, &amp;bmap-&gt;map);
438     gst_buffer_unref (bmap-&gt;buffer);
439     g_slice_free (GstMappedBuffer, bmap);
440   }
441   g_slist_free (helper.buffers);
442 
443   if (helper.best_probability &gt; 0)
444     result = helper.caps;
445 
446   if (prob)
447     *prob = helper.best_probability;
448 
449   *caps = result;
450   if (helper.flow_ret == GST_FLOW_EOS) {
451     /* Some typefinder might&#39;ve tried to read too much, if we
452      * didn&#39;t get any meaningful caps because of that this is
453      * just a normal error */
454     helper.flow_ret = GST_FLOW_ERROR;
455   }
456 
457   GST_LOG_OBJECT (obj, &quot;Returning %&quot; GST_PTR_FORMAT &quot; (probability = %u)&quot;,
458       result, (guint) helper.best_probability);
459 
460   return helper.flow_ret;
461 }
462 
463 /**
464  * gst_type_find_helper:
465  * @src: A source #GstPad
466  * @size: The length in bytes
467  *
468  * Tries to find what type of data is flowing from the given source #GstPad.
469  *
470  * Free-function: gst_caps_unref
471  *
472  * Returns: (transfer full) (nullable): the #GstCaps corresponding to the data
473  *     stream.  Returns %NULL if no #GstCaps matches the data stream.
474  */
475 
476 GstCaps *
477 gst_type_find_helper (GstPad * src, guint64 size)
478 {
479   GstTypeFindHelperGetRangeFunction func;
480 
481   g_return_val_if_fail (GST_IS_OBJECT (src), NULL);
482   g_return_val_if_fail (GST_PAD_GETRANGEFUNC (src) != NULL, NULL);
483 
484   func = (GstTypeFindHelperGetRangeFunction) (GST_PAD_GETRANGEFUNC (src));
485 
486   return gst_type_find_helper_get_range (GST_OBJECT (src),
487       GST_OBJECT_PARENT (src), func, size, NULL, NULL);
488 }
489 
490 /* ********************** typefinding for buffers ************************* */
491 
492 typedef struct
493 {
494   const guint8 *data;           /* buffer data */
495   gsize size;
496   GstTypeFindProbability best_probability;
497   GstCaps *caps;
498   GstTypeFindFactory *factory;  /* for logging */
499   GstObject *obj;               /* for logging */
500 } GstTypeFindBufHelper;
501 
502 /*
503  * buf_helper_find_peek:
504  * @data: helper data struct
505  * @off: stream offset
506  * @size: block size
507  *
508  * Get data pointer within a buffer.
509  *
510  * Returns: (nullable): address inside the buffer or %NULL if buffer does not
511  * cover the requested range.
512  */
513 static const guint8 *
514 buf_helper_find_peek (gpointer data, gint64 off, guint size)
515 {
516   GstTypeFindBufHelper *helper;
517 
518   helper = (GstTypeFindBufHelper *) data;
519   GST_LOG_OBJECT (helper-&gt;obj, &quot;&#39;%s&#39; called peek (%&quot; G_GINT64_FORMAT &quot;, %u)&quot;,
520       GST_OBJECT_NAME (helper-&gt;factory), off, size);
521 
522   if (size == 0)
523     return NULL;
524 
525   if (off &lt; 0) {
526     GST_LOG_OBJECT (helper-&gt;obj, &quot;&#39;%s&#39; wanted to peek at end; not supported&quot;,
527         GST_OBJECT_NAME (helper-&gt;factory));
528     return NULL;
529   }
530 
531   /* If we request beyond the available size, we&#39;re sure we can&#39;t return
532    * anything regardless of the requested offset */
533   if (size &gt; helper-&gt;size)
534     return NULL;
535 
536   /* Only return data if there&#39;s enough room left for the given offset.
537    * This is the same as &quot;if (off + size &lt;= helper-&gt;size)&quot; except that
538    * it doesn&#39;t exceed type limits */
539   if (off &lt;= helper-&gt;size - size)
540     return helper-&gt;data + off;
541 
542   return NULL;
543 }
544 
545 /*
546  * buf_helper_find_suggest:
547  * @data: helper data struct
548  * @probability: probability of the match
549  * @caps: caps of the type
550  *
551  * If given @probability is higher, replace previously store caps.
552  */
553 static void
554 buf_helper_find_suggest (gpointer data, guint probability, GstCaps * caps)
555 {
556   GstTypeFindBufHelper *helper = (GstTypeFindBufHelper *) data;
557 
558   GST_LOG_OBJECT (helper-&gt;obj,
559       &quot;&#39;%s&#39; called suggest (%u, %&quot; GST_PTR_FORMAT &quot;)&quot;,
560       GST_OBJECT_NAME (helper-&gt;factory), probability, caps);
561 
562   /* Note: not &gt;= as we call typefinders in order of rank, highest first */
563   if (probability &gt; helper-&gt;best_probability) {
564     gst_caps_replace (&amp;helper-&gt;caps, caps);
565     helper-&gt;best_probability = probability;
566   }
567 }
568 
569 /**
570  * gst_type_find_helper_for_data:
571  * @obj: (allow-none): object doing the typefinding, or %NULL (used for logging)
572  * @data: (transfer none) (array length=size): * a pointer with data to typefind
573  * @size: the size of @data
574  * @prob: (out) (allow-none): location to store the probability of the found
575  *     caps, or %NULL
576  *
577  * Tries to find what type of data is contained in the given @data, the
578  * assumption being that the data represents the beginning of the stream or
579  * file.
580  *
581  * All available typefinders will be called on the data in order of rank. If
582  * a typefinding function returns a probability of %GST_TYPE_FIND_MAXIMUM,
583  * typefinding is stopped immediately and the found caps will be returned
584  * right away. Otherwise, all available typefind functions will the tried,
585  * and the caps with the highest probability will be returned, or %NULL if
586  * the content of @data could not be identified.
587  *
588  * Free-function: gst_caps_unref
589  *
590  * Returns: (transfer full) (nullable): the #GstCaps corresponding to the data,
591  *     or %NULL if no type could be found. The caller should free the caps
592  *     returned with gst_caps_unref().
593  */
594 GstCaps *
595 gst_type_find_helper_for_data (GstObject * obj, const guint8 * data, gsize size,
596     GstTypeFindProbability * prob)
597 {
598   return gst_type_find_helper_for_data_with_extension (obj, data, size, NULL,
599       prob);
600 }
601 
602 /**
603  * gst_type_find_helper_for_data_with_extension:
604  * @obj: (allow-none): object doing the typefinding, or %NULL (used for logging)
605  * @data: (transfer none) (array length=size): * a pointer with data to typefind
606  * @size: the size of @data
607  * @extension: (allow-none): extension of the media, or %NULL
608  * @prob: (out) (allow-none): location to store the probability of the found
609  *     caps, or %NULL
610  *
611  * Tries to find what type of data is contained in the given @data, the
612  * assumption being that the data represents the beginning of the stream or
613  * file.
614  *
615  * All available typefinders will be called on the data in order of rank. If
616  * a typefinding function returns a probability of %GST_TYPE_FIND_MAXIMUM,
617  * typefinding is stopped immediately and the found caps will be returned
618  * right away. Otherwise, all available typefind functions will the tried,
619  * and the caps with the highest probability will be returned, or %NULL if
620  * the content of @data could not be identified.
621  *
622  * When @extension is not %NULL, this function will first try the typefind
623  * functions for the given extension, which might speed up the typefinding
624  * in many cases.
625  *
626  * Free-function: gst_caps_unref
627  *
628  * Returns: (transfer full) (nullable): the #GstCaps corresponding to the data,
629  *     or %NULL if no type could be found. The caller should free the caps
630  *     returned with gst_caps_unref().
631  *
632  * Since: 1.16
633  *
634  */
635 GstCaps *
636 gst_type_find_helper_for_data_with_extension (GstObject * obj,
637     const guint8 * data, gsize size, const gchar * extension,
638     GstTypeFindProbability * prob)
639 {
640   GstTypeFindBufHelper helper;
641   GstTypeFind find;
642   GList *l, *type_list;
643   GstCaps *result = NULL;
644 
645   g_return_val_if_fail (data != NULL, NULL);
646 
647   helper.data = data;
648   helper.size = size;
649   helper.best_probability = GST_TYPE_FIND_NONE;
650   helper.caps = NULL;
651   helper.obj = obj;
652 
653   if (helper.data == NULL || helper.size == 0)
654     return NULL;
655 
656   find.data = &amp;helper;
657   find.peek = buf_helper_find_peek;
658   find.suggest = buf_helper_find_suggest;
659   find.get_length = NULL;
660 
661   type_list = gst_type_find_factory_get_list ();
662   type_list = prioritize_extension (obj, type_list, extension);
663 
664   for (l = type_list; l; l = l-&gt;next) {
665     helper.factory = GST_TYPE_FIND_FACTORY (l-&gt;data);
666     gst_type_find_factory_call_function (helper.factory, &amp;find);
667     if (helper.best_probability &gt;= GST_TYPE_FIND_MAXIMUM)
668       break;
669   }
670   gst_plugin_feature_list_free (type_list);
671 
672   if (helper.best_probability &gt; 0)
673     result = helper.caps;
674 
675   if (prob)
676     *prob = helper.best_probability;
677 
678   GST_LOG_OBJECT (obj, &quot;Returning %&quot; GST_PTR_FORMAT &quot; (probability = %u)&quot;,
679       result, (guint) helper.best_probability);
680 
681   return result;
682 }
683 
684 /**
685  * gst_type_find_helper_for_buffer:
686  * @obj: (allow-none): object doing the typefinding, or %NULL (used for logging)
687  * @buf: (in) (transfer none): a #GstBuffer with data to typefind
688  * @prob: (out) (allow-none): location to store the probability of the found
689  *     caps, or %NULL
690  *
691  * Tries to find what type of data is contained in the given #GstBuffer, the
692  * assumption being that the buffer represents the beginning of the stream or
693  * file.
694  *
695  * All available typefinders will be called on the data in order of rank. If
696  * a typefinding function returns a probability of %GST_TYPE_FIND_MAXIMUM,
697  * typefinding is stopped immediately and the found caps will be returned
698  * right away. Otherwise, all available typefind functions will the tried,
699  * and the caps with the highest probability will be returned, or %NULL if
700  * the content of the buffer could not be identified.
701  *
702  * Free-function: gst_caps_unref
703  *
704  * Returns: (transfer full) (nullable): the #GstCaps corresponding to the data,
705  *     or %NULL if no type could be found. The caller should free the caps
706  *     returned with gst_caps_unref().
707  */
708 GstCaps *
709 gst_type_find_helper_for_buffer (GstObject * obj, GstBuffer * buf,
710     GstTypeFindProbability * prob)
711 {
712   return gst_type_find_helper_for_buffer_with_extension (obj, buf, NULL, prob);
713 }
714 
715 /**
716  * gst_type_find_helper_for_buffer_with_extension:
717  * @obj: (allow-none): object doing the typefinding, or %NULL (used for logging)
718  * @buf: (in) (transfer none): a #GstBuffer with data to typefind
719  * @extension: (allow-none): extension of the media, or %NULL
720  * @prob: (out) (allow-none): location to store the probability of the found
721  *     caps, or %NULL
722  *
723  * Tries to find what type of data is contained in the given #GstBuffer, the
724  * assumption being that the buffer represents the beginning of the stream or
725  * file.
726  *
727  * All available typefinders will be called on the data in order of rank. If
728  * a typefinding function returns a probability of %GST_TYPE_FIND_MAXIMUM,
729  * typefinding is stopped immediately and the found caps will be returned
730  * right away. Otherwise, all available typefind functions will the tried,
731  * and the caps with the highest probability will be returned, or %NULL if
732  * the content of the buffer could not be identified.
733  *
734  * When @extension is not %NULL, this function will first try the typefind
735  * functions for the given extension, which might speed up the typefinding
736  * in many cases.
737  *
738  * Free-function: gst_caps_unref
739  *
740  * Returns: (transfer full) (nullable): the #GstCaps corresponding to the data,
741  *     or %NULL if no type could be found. The caller should free the caps
742  *     returned with gst_caps_unref().
743  *
744  * Since: 1.16
745  *
746  */
747 GstCaps *
748 gst_type_find_helper_for_buffer_with_extension (GstObject * obj,
749     GstBuffer * buf, const gchar * extension, GstTypeFindProbability * prob)
750 {
751   GstCaps *result;
752   GstMapInfo info;
753 
754   g_return_val_if_fail (buf != NULL, NULL);
755   g_return_val_if_fail (GST_IS_BUFFER (buf), NULL);
756   g_return_val_if_fail (GST_BUFFER_OFFSET (buf) == 0 ||
757       GST_BUFFER_OFFSET (buf) == GST_BUFFER_OFFSET_NONE, NULL);
758 
759   if (!gst_buffer_map (buf, &amp;info, GST_MAP_READ))
760     return NULL;
761   result =
762       gst_type_find_helper_for_data_with_extension (obj, info.data, info.size,
763       extension, prob);
764   gst_buffer_unmap (buf, &amp;info);
765 
766   return result;
767 }
768 
769 /**
770  * gst_type_find_helper_for_extension:
771  * @obj: (allow-none): object doing the typefinding, or %NULL (used for logging)
772  * @extension: an extension
773  *
774  * Tries to find the best #GstCaps associated with @extension.
775  *
776  * All available typefinders will be checked against the extension in order
777  * of rank. The caps of the first typefinder that can handle @extension will be
778  * returned.
779  *
780  * Free-function: gst_caps_unref
781  *
782  * Returns: (transfer full) (nullable): the #GstCaps corresponding to
783  *     @extension, or %NULL if no type could be found. The caller should free
784  *     the caps returned with gst_caps_unref().
785  */
786 GstCaps *
787 gst_type_find_helper_for_extension (GstObject * obj, const gchar * extension)
788 {
789   GList *l, *type_list;
790   GstCaps *result = NULL;
791 
792   g_return_val_if_fail (extension != NULL, NULL);
793 
794   GST_LOG_OBJECT (obj, &quot;finding caps for extension %s&quot;, extension);
795 
796   type_list = gst_type_find_factory_get_list ();
797 
798   for (l = type_list; l; l = g_list_next (l)) {
799     GstTypeFindFactory *factory;
800     const gchar *const *ext;
801 
802     factory = GST_TYPE_FIND_FACTORY (l-&gt;data);
803 
804     /* we only want to check those factories without a function */
805     if (gst_type_find_factory_has_function (factory))
806       continue;
807 
808     /* get the extension that this typefind factory can handle */
809     ext = gst_type_find_factory_get_extensions (factory);
810     if (ext == NULL)
811       continue;
812 
813     /* there are extension, see if one of them matches the requested
814      * extension */
815     while (*ext != NULL) {
816       if (strcmp (*ext, extension) == 0) {
817         /* we found a matching extension, take the caps */
818         if ((result = gst_type_find_factory_get_caps (factory))) {
819           gst_caps_ref (result);
820           goto done;
821         }
822       }
823       ++ext;
824     }
825   }
826 done:
827   gst_plugin_feature_list_free (type_list);
828 
829   GST_LOG_OBJECT (obj, &quot;Returning %&quot; GST_PTR_FORMAT, result);
830 
831   return result;
832 }
    </pre>
  </body>
</html>