<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstclock.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstclock.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstcontext.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstclock.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
196  * Convert a struct timespec (see man pselect) to a #GstClockTime.
197  */
198 #define GST_TIMESPEC_TO_TIME(ts)        (GstClockTime)((ts).tv_sec * GST_SECOND + (ts).tv_nsec * GST_NSECOND)
199 /**
200  * GST_TIME_TO_TIMESPEC:
201  * @t: The #GstClockTime to convert
202  * @ts: The target timespec
203  *
204  * Convert a #GstClockTime to a struct timespec (see man pselect)
205  */
206 #define GST_TIME_TO_TIMESPEC(t,ts)                                \
207 G_STMT_START {                                                    \
208   g_assert (&quot;Value of time &quot; #t &quot; is out of timespec&#39;s range&quot; &amp;&amp;  \
209       ((t) / GST_SECOND) &lt; G_MAXLONG);                            \
210   (ts).tv_sec  =  (glong) ((t) / GST_SECOND);                     \
211   (ts).tv_nsec = (glong) (((t) - (ts).tv_sec * GST_SECOND) / GST_NSECOND);        \
212 } G_STMT_END
213 
214 /* timestamp debugging macros */
215 /**
<span class="line-modified">216  * GST_TIME_FORMAT:</span>
217  *
218  * A string that can be used in printf-like format strings to display a
219  * #GstClockTime value in h:m:s format.  Use GST_TIME_ARGS() to construct
220  * the matching arguments.
221  *
222  * Example:
223  * |[&lt;!-- language=&quot;C&quot; --&gt;
224  * printf(&quot;%&quot; GST_TIME_FORMAT &quot;\n&quot;, GST_TIME_ARGS(ts));
225  * ]|
226  */
227 #define GST_TIME_FORMAT &quot;u:%02u:%02u.%09u&quot;
228 /**
<span class="line-modified">229  * GST_TIME_ARGS:</span>
230  * @t: a #GstClockTime
231  *
232  * Format @t for the #GST_TIME_FORMAT format string. Note: @t will be
233  * evaluated more than once.
234  */
235 #define GST_TIME_ARGS(t) \
236         GST_CLOCK_TIME_IS_VALID (t) ? \
237         (guint) (((GstClockTime)(t)) / (GST_SECOND * 60 * 60)) : 99, \
238         GST_CLOCK_TIME_IS_VALID (t) ? \
239         (guint) ((((GstClockTime)(t)) / (GST_SECOND * 60)) % 60) : 99, \
240         GST_CLOCK_TIME_IS_VALID (t) ? \
241         (guint) ((((GstClockTime)(t)) / GST_SECOND) % 60) : 99, \
242         GST_CLOCK_TIME_IS_VALID (t) ? \
243         (guint) (((GstClockTime)(t)) % GST_SECOND) : 999999999
244 /**
<span class="line-modified">245  * GST_STIME_FORMAT:</span>
246  *
247  * A string that can be used in printf-like format strings to display a signed
248  * #GstClockTimeDiff or #gint64 value in h:m:s format.  Use GST_TIME_ARGS() to
249  * construct the matching arguments.
250  *
251  * Example:
252  * |[
253  * printf(&quot;%&quot; GST_STIME_FORMAT &quot;\n&quot;, GST_STIME_ARGS(ts));
254  * ]|
255  *
256  * Since: 1.6
257  */
258 #define GST_STIME_FORMAT &quot;c%&quot; GST_TIME_FORMAT
259 /**
<span class="line-modified">260  * GST_STIME_ARGS:</span>
261  * @t: a #GstClockTimeDiff or #gint64
262  *
263  * Format @t for the #GST_STIME_FORMAT format string. Note: @t will be
264  * evaluated more than once.
265  *
266  * Since: 1.6
267  */
<span class="line-modified">268 #define GST_STIME_ARGS(t)                       \</span>
<span class="line-modified">269   ((t) == GST_CLOCK_STIME_NONE || (t) &gt;= 0) ? &#39;+&#39; : &#39;-&#39;,        \</span>
<span class="line-modified">270     GST_CLOCK_STIME_IS_VALID (t) ?                  \</span>
<span class="line-modified">271     (guint) (((GstClockTime)(ABS(t))) / (GST_SECOND * 60 * 60)) : 99,   \</span>
<span class="line-modified">272     GST_CLOCK_STIME_IS_VALID (t) ?                  \</span>
273     (guint) ((((GstClockTime)(ABS(t))) / (GST_SECOND * 60)) % 60) : 99, \
<span class="line-modified">274     GST_CLOCK_STIME_IS_VALID (t) ?                  \</span>
<span class="line-modified">275     (guint) ((((GstClockTime)(ABS(t))) / GST_SECOND) % 60) : 99,    \</span>
<span class="line-modified">276     GST_CLOCK_STIME_IS_VALID (t) ?                  \</span>
277     (guint) (((GstClockTime)(ABS(t))) % GST_SECOND) : 999999999
278 
279 typedef struct _GstClockEntry   GstClockEntry;
280 typedef struct _GstClock        GstClock;
281 typedef struct _GstClockClass   GstClockClass;
282 typedef struct _GstClockPrivate GstClockPrivate;
283 
284 /* --- prototype for async callbacks --- */
285 /**
286  * GstClockCallback:
287  * @clock: The clock that triggered the callback
288  * @time: The time it was triggered
289  * @id: The #GstClockID that expired
290  * @user_data: user data passed in the gst_clock_id_wait_async() function
291  *
292  * The function prototype of the callback.
293  *
294  * Returns: %TRUE or %FALSE (currently unused)
295  */
296 typedef gboolean        (*GstClockCallback)     (GstClock *clock, GstClockTime time,
</pre>
<hr />
<pre>
322 
323 /**
324  * GstClockEntryType:
325  * @GST_CLOCK_ENTRY_SINGLE: a single shot timeout
326  * @GST_CLOCK_ENTRY_PERIODIC: a periodic timeout request
327  *
328  * The type of the clock entry
329  */
330 typedef enum {
331   GST_CLOCK_ENTRY_SINGLE,
332   GST_CLOCK_ENTRY_PERIODIC
333 } GstClockEntryType;
334 
335 /**
336  * GST_CLOCK_ENTRY:
337  * @entry: the entry to cast
338  *
339  * Cast to a clock entry
340  */
341 #define GST_CLOCK_ENTRY(entry)          ((GstClockEntry *)(entry))


342 /**
343  * GST_CLOCK_ENTRY_CLOCK:
344  * @entry: the entry to query
345  *
346  * Get the owner clock of the entry


347  */
348 #define GST_CLOCK_ENTRY_CLOCK(entry)    ((entry)-&gt;clock)

349 /**
350  * GST_CLOCK_ENTRY_TYPE:
351  * @entry: the entry to query
352  *
353  * Get the type of the clock entry
354  */
355 #define GST_CLOCK_ENTRY_TYPE(entry)     ((entry)-&gt;type)
356 /**
357  * GST_CLOCK_ENTRY_TIME:
358  * @entry: the entry to query
359  *
360  * Get the requested time of this entry
361  */
362 #define GST_CLOCK_ENTRY_TIME(entry)     ((entry)-&gt;time)
363 /**
364  * GST_CLOCK_ENTRY_INTERVAL:
365  * @entry: the entry to query
366  *
367  * Get the interval of this periodic entry
368  */
</pre>
<hr />
<pre>
370 /**
371  * GST_CLOCK_ENTRY_STATUS:
372  * @entry: the entry to query
373  *
374  * The status of the entry
375  */
376 #define GST_CLOCK_ENTRY_STATUS(entry)   ((entry)-&gt;status)
377 
378 /**
379  * GstClockEntry:
380  * @refcount: reference counter (read-only)
381  *
382  * All pending timeouts or periodic notifies are converted into
383  * an entry.
384  * Note that GstClockEntry should be treated as an opaque structure. It must
385  * not be extended or allocated using a custom allocator.
386  */
387 struct _GstClockEntry {
388   gint                  refcount;
389   /*&lt; protected &gt;*/


390   GstClock              *clock;




391   GstClockEntryType      type;
392   GstClockTime           time;
393   GstClockTime           interval;
394   GstClockReturn         status;
395   GstClockCallback       func;
396   gpointer               user_data;
397   GDestroyNotify         destroy_data;
398   gboolean               unscheduled;
399   gboolean               woken_up;
400 
401   /*&lt; private &gt;*/
402   gpointer _gst_reserved[GST_PADDING];
403 };
404 
405 #include &lt;gst/gstobject.h&gt;
406 
407 /**
408  * GstClockFlags:
409  * @GST_CLOCK_FLAG_CAN_DO_SINGLE_SYNC: clock can do a single sync timeout request
410  * @GST_CLOCK_FLAG_CAN_DO_SINGLE_ASYNC: clock can do a single async timeout request
411  * @GST_CLOCK_FLAG_CAN_DO_PERIODIC_SYNC: clock can do sync periodic timeout requests
412  * @GST_CLOCK_FLAG_CAN_DO_PERIODIC_ASYNC: clock can do async periodic timeout callbacks
413  * @GST_CLOCK_FLAG_CAN_SET_RESOLUTION: clock&#39;s resolution can be changed
414  * @GST_CLOCK_FLAG_CAN_SET_MASTER: clock can be slaved to a master clock
415  * @GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC: clock needs to be synced before it can be used
<span class="line-modified">416  *     (Since 1.6)</span>
417  * @GST_CLOCK_FLAG_LAST: subclasses can add additional flags starting from this flag
418  *
419  * The capabilities of this clock
420  */
421 typedef enum {
422   GST_CLOCK_FLAG_CAN_DO_SINGLE_SYNC     = (GST_OBJECT_FLAG_LAST &lt;&lt; 0),
423   GST_CLOCK_FLAG_CAN_DO_SINGLE_ASYNC    = (GST_OBJECT_FLAG_LAST &lt;&lt; 1),
424   GST_CLOCK_FLAG_CAN_DO_PERIODIC_SYNC   = (GST_OBJECT_FLAG_LAST &lt;&lt; 2),
425   GST_CLOCK_FLAG_CAN_DO_PERIODIC_ASYNC  = (GST_OBJECT_FLAG_LAST &lt;&lt; 3),
426   GST_CLOCK_FLAG_CAN_SET_RESOLUTION     = (GST_OBJECT_FLAG_LAST &lt;&lt; 4),
427   GST_CLOCK_FLAG_CAN_SET_MASTER         = (GST_OBJECT_FLAG_LAST &lt;&lt; 5),
428   GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC     = (GST_OBJECT_FLAG_LAST &lt;&lt; 6),
429   /* padding */
430   GST_CLOCK_FLAG_LAST                   = (GST_OBJECT_FLAG_LAST &lt;&lt; 8)
431 } GstClockFlags;
432 
433 /**
434  * GST_CLOCK_FLAGS:
435  * @clock: the clock to query
436  *
</pre>
<hr />
<pre>
583 GstClockID              gst_clock_new_single_shot_id    (GstClock *clock,
584                                                          GstClockTime time);
585 GST_API
586 GstClockID              gst_clock_new_periodic_id       (GstClock *clock,
587                                                          GstClockTime start_time,
588                                                          GstClockTime interval);
589 
590 /* reference counting */
591 
592 GST_API
593 GstClockID              gst_clock_id_ref                (GstClockID id);
594 
595 GST_API
596 void                    gst_clock_id_unref              (GstClockID id);
597 
598 /* operations on IDs */
599 
600 GST_API
601 gint                    gst_clock_id_compare_func       (gconstpointer id1, gconstpointer id2);
602 






603 GST_API
604 GstClockTime            gst_clock_id_get_time           (GstClockID id);
605 
606 GST_API
607 GstClockReturn          gst_clock_id_wait               (GstClockID id,
608                                                          GstClockTimeDiff *jitter);
609 GST_API
610 GstClockReturn          gst_clock_id_wait_async         (GstClockID id,
611                                                          GstClockCallback func,
612                                                          gpointer user_data,
613                                                          GDestroyNotify destroy_data);
614 GST_API
615 void                    gst_clock_id_unschedule         (GstClockID id);
616 
617 GST_API
618 gboolean                gst_clock_single_shot_id_reinit (GstClock * clock,
619                                                          GstClockID id,
620                                                          GstClockTime time);
621 GST_API
622 gboolean                gst_clock_periodic_id_reinit    (GstClock * clock,
</pre>
</td>
<td>
<hr />
<pre>
196  * Convert a struct timespec (see man pselect) to a #GstClockTime.
197  */
198 #define GST_TIMESPEC_TO_TIME(ts)        (GstClockTime)((ts).tv_sec * GST_SECOND + (ts).tv_nsec * GST_NSECOND)
199 /**
200  * GST_TIME_TO_TIMESPEC:
201  * @t: The #GstClockTime to convert
202  * @ts: The target timespec
203  *
204  * Convert a #GstClockTime to a struct timespec (see man pselect)
205  */
206 #define GST_TIME_TO_TIMESPEC(t,ts)                                \
207 G_STMT_START {                                                    \
208   g_assert (&quot;Value of time &quot; #t &quot; is out of timespec&#39;s range&quot; &amp;&amp;  \
209       ((t) / GST_SECOND) &lt; G_MAXLONG);                            \
210   (ts).tv_sec  =  (glong) ((t) / GST_SECOND);                     \
211   (ts).tv_nsec = (glong) (((t) - (ts).tv_sec * GST_SECOND) / GST_NSECOND);        \
212 } G_STMT_END
213 
214 /* timestamp debugging macros */
215 /**
<span class="line-modified">216  * GST_TIME_FORMAT: (skip):</span>
217  *
218  * A string that can be used in printf-like format strings to display a
219  * #GstClockTime value in h:m:s format.  Use GST_TIME_ARGS() to construct
220  * the matching arguments.
221  *
222  * Example:
223  * |[&lt;!-- language=&quot;C&quot; --&gt;
224  * printf(&quot;%&quot; GST_TIME_FORMAT &quot;\n&quot;, GST_TIME_ARGS(ts));
225  * ]|
226  */
227 #define GST_TIME_FORMAT &quot;u:%02u:%02u.%09u&quot;
228 /**
<span class="line-modified">229  * GST_TIME_ARGS: (skip):</span>
230  * @t: a #GstClockTime
231  *
232  * Format @t for the #GST_TIME_FORMAT format string. Note: @t will be
233  * evaluated more than once.
234  */
235 #define GST_TIME_ARGS(t) \
236         GST_CLOCK_TIME_IS_VALID (t) ? \
237         (guint) (((GstClockTime)(t)) / (GST_SECOND * 60 * 60)) : 99, \
238         GST_CLOCK_TIME_IS_VALID (t) ? \
239         (guint) ((((GstClockTime)(t)) / (GST_SECOND * 60)) % 60) : 99, \
240         GST_CLOCK_TIME_IS_VALID (t) ? \
241         (guint) ((((GstClockTime)(t)) / GST_SECOND) % 60) : 99, \
242         GST_CLOCK_TIME_IS_VALID (t) ? \
243         (guint) (((GstClockTime)(t)) % GST_SECOND) : 999999999
244 /**
<span class="line-modified">245  * GST_STIME_FORMAT: (skip):</span>
246  *
247  * A string that can be used in printf-like format strings to display a signed
248  * #GstClockTimeDiff or #gint64 value in h:m:s format.  Use GST_TIME_ARGS() to
249  * construct the matching arguments.
250  *
251  * Example:
252  * |[
253  * printf(&quot;%&quot; GST_STIME_FORMAT &quot;\n&quot;, GST_STIME_ARGS(ts));
254  * ]|
255  *
256  * Since: 1.6
257  */
258 #define GST_STIME_FORMAT &quot;c%&quot; GST_TIME_FORMAT
259 /**
<span class="line-modified">260  * GST_STIME_ARGS: (skip):</span>
261  * @t: a #GstClockTimeDiff or #gint64
262  *
263  * Format @t for the #GST_STIME_FORMAT format string. Note: @t will be
264  * evaluated more than once.
265  *
266  * Since: 1.6
267  */
<span class="line-modified">268 #define GST_STIME_ARGS(t)           \</span>
<span class="line-modified">269   ((t) == GST_CLOCK_STIME_NONE || (t) &gt;= 0) ? &#39;+&#39; : &#39;-&#39;,    \</span>
<span class="line-modified">270     GST_CLOCK_STIME_IS_VALID (t) ?          \</span>
<span class="line-modified">271     (guint) (((GstClockTime)(ABS(t))) / (GST_SECOND * 60 * 60)) : 99, \</span>
<span class="line-modified">272     GST_CLOCK_STIME_IS_VALID (t) ?          \</span>
273     (guint) ((((GstClockTime)(ABS(t))) / (GST_SECOND * 60)) % 60) : 99, \
<span class="line-modified">274     GST_CLOCK_STIME_IS_VALID (t) ?          \</span>
<span class="line-modified">275     (guint) ((((GstClockTime)(ABS(t))) / GST_SECOND) % 60) : 99,  \</span>
<span class="line-modified">276     GST_CLOCK_STIME_IS_VALID (t) ?          \</span>
277     (guint) (((GstClockTime)(ABS(t))) % GST_SECOND) : 999999999
278 
279 typedef struct _GstClockEntry   GstClockEntry;
280 typedef struct _GstClock        GstClock;
281 typedef struct _GstClockClass   GstClockClass;
282 typedef struct _GstClockPrivate GstClockPrivate;
283 
284 /* --- prototype for async callbacks --- */
285 /**
286  * GstClockCallback:
287  * @clock: The clock that triggered the callback
288  * @time: The time it was triggered
289  * @id: The #GstClockID that expired
290  * @user_data: user data passed in the gst_clock_id_wait_async() function
291  *
292  * The function prototype of the callback.
293  *
294  * Returns: %TRUE or %FALSE (currently unused)
295  */
296 typedef gboolean        (*GstClockCallback)     (GstClock *clock, GstClockTime time,
</pre>
<hr />
<pre>
322 
323 /**
324  * GstClockEntryType:
325  * @GST_CLOCK_ENTRY_SINGLE: a single shot timeout
326  * @GST_CLOCK_ENTRY_PERIODIC: a periodic timeout request
327  *
328  * The type of the clock entry
329  */
330 typedef enum {
331   GST_CLOCK_ENTRY_SINGLE,
332   GST_CLOCK_ENTRY_PERIODIC
333 } GstClockEntryType;
334 
335 /**
336  * GST_CLOCK_ENTRY:
337  * @entry: the entry to cast
338  *
339  * Cast to a clock entry
340  */
341 #define GST_CLOCK_ENTRY(entry)          ((GstClockEntry *)(entry))
<span class="line-added">342 </span>
<span class="line-added">343 #ifndef GST_DISABLE_DEPRECATED</span>
344 /**
345  * GST_CLOCK_ENTRY_CLOCK:
346  * @entry: the entry to query
347  *
348  * Get the owner clock of the entry
<span class="line-added">349  *</span>
<span class="line-added">350  * Deprecated: Use gst_clock_id_get_clock() instead.</span>
351  */
352 #define GST_CLOCK_ENTRY_CLOCK(entry)    ((entry)-&gt;clock)
<span class="line-added">353 #endif</span>
354 /**
355  * GST_CLOCK_ENTRY_TYPE:
356  * @entry: the entry to query
357  *
358  * Get the type of the clock entry
359  */
360 #define GST_CLOCK_ENTRY_TYPE(entry)     ((entry)-&gt;type)
361 /**
362  * GST_CLOCK_ENTRY_TIME:
363  * @entry: the entry to query
364  *
365  * Get the requested time of this entry
366  */
367 #define GST_CLOCK_ENTRY_TIME(entry)     ((entry)-&gt;time)
368 /**
369  * GST_CLOCK_ENTRY_INTERVAL:
370  * @entry: the entry to query
371  *
372  * Get the interval of this periodic entry
373  */
</pre>
<hr />
<pre>
375 /**
376  * GST_CLOCK_ENTRY_STATUS:
377  * @entry: the entry to query
378  *
379  * The status of the entry
380  */
381 #define GST_CLOCK_ENTRY_STATUS(entry)   ((entry)-&gt;status)
382 
383 /**
384  * GstClockEntry:
385  * @refcount: reference counter (read-only)
386  *
387  * All pending timeouts or periodic notifies are converted into
388  * an entry.
389  * Note that GstClockEntry should be treated as an opaque structure. It must
390  * not be extended or allocated using a custom allocator.
391  */
392 struct _GstClockEntry {
393   gint                  refcount;
394   /*&lt; protected &gt;*/
<span class="line-added">395 #ifndef GST_REMOVE_DEPRECATED</span>
<span class="line-added">396 #ifndef GST_DISABLE_DEPRECATED</span>
397   GstClock              *clock;
<span class="line-added">398 #else</span>
<span class="line-added">399   gpointer               _clock;</span>
<span class="line-added">400 #endif</span>
<span class="line-added">401 #endif</span>
402   GstClockEntryType      type;
403   GstClockTime           time;
404   GstClockTime           interval;
405   GstClockReturn         status;
406   GstClockCallback       func;
407   gpointer               user_data;
408   GDestroyNotify         destroy_data;
409   gboolean               unscheduled;
410   gboolean               woken_up;
411 
412   /*&lt; private &gt;*/
413   gpointer _gst_reserved[GST_PADDING];
414 };
415 
416 #include &lt;gst/gstobject.h&gt;
417 
418 /**
419  * GstClockFlags:
420  * @GST_CLOCK_FLAG_CAN_DO_SINGLE_SYNC: clock can do a single sync timeout request
421  * @GST_CLOCK_FLAG_CAN_DO_SINGLE_ASYNC: clock can do a single async timeout request
422  * @GST_CLOCK_FLAG_CAN_DO_PERIODIC_SYNC: clock can do sync periodic timeout requests
423  * @GST_CLOCK_FLAG_CAN_DO_PERIODIC_ASYNC: clock can do async periodic timeout callbacks
424  * @GST_CLOCK_FLAG_CAN_SET_RESOLUTION: clock&#39;s resolution can be changed
425  * @GST_CLOCK_FLAG_CAN_SET_MASTER: clock can be slaved to a master clock
426  * @GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC: clock needs to be synced before it can be used
<span class="line-modified">427  *     (Since: 1.6)</span>
428  * @GST_CLOCK_FLAG_LAST: subclasses can add additional flags starting from this flag
429  *
430  * The capabilities of this clock
431  */
432 typedef enum {
433   GST_CLOCK_FLAG_CAN_DO_SINGLE_SYNC     = (GST_OBJECT_FLAG_LAST &lt;&lt; 0),
434   GST_CLOCK_FLAG_CAN_DO_SINGLE_ASYNC    = (GST_OBJECT_FLAG_LAST &lt;&lt; 1),
435   GST_CLOCK_FLAG_CAN_DO_PERIODIC_SYNC   = (GST_OBJECT_FLAG_LAST &lt;&lt; 2),
436   GST_CLOCK_FLAG_CAN_DO_PERIODIC_ASYNC  = (GST_OBJECT_FLAG_LAST &lt;&lt; 3),
437   GST_CLOCK_FLAG_CAN_SET_RESOLUTION     = (GST_OBJECT_FLAG_LAST &lt;&lt; 4),
438   GST_CLOCK_FLAG_CAN_SET_MASTER         = (GST_OBJECT_FLAG_LAST &lt;&lt; 5),
439   GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC     = (GST_OBJECT_FLAG_LAST &lt;&lt; 6),
440   /* padding */
441   GST_CLOCK_FLAG_LAST                   = (GST_OBJECT_FLAG_LAST &lt;&lt; 8)
442 } GstClockFlags;
443 
444 /**
445  * GST_CLOCK_FLAGS:
446  * @clock: the clock to query
447  *
</pre>
<hr />
<pre>
594 GstClockID              gst_clock_new_single_shot_id    (GstClock *clock,
595                                                          GstClockTime time);
596 GST_API
597 GstClockID              gst_clock_new_periodic_id       (GstClock *clock,
598                                                          GstClockTime start_time,
599                                                          GstClockTime interval);
600 
601 /* reference counting */
602 
603 GST_API
604 GstClockID              gst_clock_id_ref                (GstClockID id);
605 
606 GST_API
607 void                    gst_clock_id_unref              (GstClockID id);
608 
609 /* operations on IDs */
610 
611 GST_API
612 gint                    gst_clock_id_compare_func       (gconstpointer id1, gconstpointer id2);
613 
<span class="line-added">614 GST_API</span>
<span class="line-added">615 GstClock *              gst_clock_id_get_clock          (GstClockID id);</span>
<span class="line-added">616 </span>
<span class="line-added">617 GST_API</span>
<span class="line-added">618 gboolean                gst_clock_id_uses_clock         (GstClockID id, GstClock * clock);</span>
<span class="line-added">619 </span>
620 GST_API
621 GstClockTime            gst_clock_id_get_time           (GstClockID id);
622 
623 GST_API
624 GstClockReturn          gst_clock_id_wait               (GstClockID id,
625                                                          GstClockTimeDiff *jitter);
626 GST_API
627 GstClockReturn          gst_clock_id_wait_async         (GstClockID id,
628                                                          GstClockCallback func,
629                                                          gpointer user_data,
630                                                          GDestroyNotify destroy_data);
631 GST_API
632 void                    gst_clock_id_unschedule         (GstClockID id);
633 
634 GST_API
635 gboolean                gst_clock_single_shot_id_reinit (GstClock * clock,
636                                                          GstClockID id,
637                                                          GstClockTime time);
638 GST_API
639 gboolean                gst_clock_periodic_id_reinit    (GstClock * clock,
</pre>
</td>
</tr>
</table>
<center><a href="gstclock.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstcontext.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>