<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gthreadpool.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gthread.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gthreadprivate.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gthreadpool.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Lesser General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Lesser General Public
  18  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  19  */
  20 
  21 /*
  22  * MT safe
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 
  27 #include &quot;gthreadpool.h&quot;
  28 
  29 #include &quot;gasyncqueue.h&quot;
  30 #include &quot;gasyncqueueprivate.h&quot;
  31 #include &quot;gmain.h&quot;
  32 #include &quot;gtestutils.h&quot;
  33 #include &quot;gtimer.h&quot;

  34 
  35 /**
  36  * SECTION:thread_pools
  37  * @title: Thread Pools
  38  * @short_description: pools of threads to execute work concurrently
  39  * @see_also: #GThread
  40  *
  41  * Sometimes you wish to asynchronously fork out the execution of work
  42  * and continue working in your own thread. If that will happen often,
  43  * the overhead of starting and destroying a thread each time might be
  44  * too high. In such cases reusing already started threads seems like a
  45  * good idea. And it indeed is, but implementing this can be tedious
  46  * and error-prone.
  47  *
  48  * Therefore GLib provides thread pools for your convenience. An added
  49  * advantage is, that the threads can be shared between the different
  50  * subsystems of your program, when they are using GLib.
  51  *
  52  * To create a new thread pool, you use g_thread_pool_new().
  53  * It is destroyed by g_thread_pool_free().
</pre>
<hr />
<pre>
  73 /* #define DEBUG_MSG(args) g_printerr args ; g_printerr (&quot;\n&quot;);    */
  74 
  75 typedef struct _GRealThreadPool GRealThreadPool;
  76 
  77 /**
  78  * GThreadPool:
  79  * @func: the function to execute in the threads of this pool
  80  * @user_data: the user data for the threads of this pool
  81  * @exclusive: are all threads exclusive to this pool
  82  *
  83  * The #GThreadPool struct represents a thread pool. It has three
  84  * public read-only members, but the underlying struct is bigger,
  85  * so you must not copy this struct.
  86  */
  87 struct _GRealThreadPool
  88 {
  89   GThreadPool pool;
  90   GAsyncQueue *queue;
  91   GCond cond;
  92   gint max_threads;
<span class="line-modified">  93   gint num_threads;</span>
  94   gboolean running;
  95   gboolean immediate;
  96   gboolean waiting;
  97   GCompareDataFunc sort_func;
  98   gpointer sort_user_data;
  99 };
 100 
 101 /* The following is just an address to mark the wakeup order for a
 102  * thread, it could be any address (as long, as it isn&#39;t a valid
 103  * GThreadPool address)
 104  */
 105 static const gpointer wakeup_thread_marker = (gpointer) &amp;g_thread_pool_new;
 106 static gint wakeup_thread_serial = 0;
 107 
 108 /* Here all unused threads are waiting  */
 109 static GAsyncQueue *unused_thread_queue = NULL;
 110 static gint unused_threads = 0;
 111 static gint max_unused_threads = 2;
 112 static gint kill_unused_threads = 0;
 113 static guint max_idle_time = 15 * 1000;
</pre>
<hr />
<pre>
 136 }
 137 
 138 static GRealThreadPool*
 139 g_thread_pool_wait_for_new_pool (void)
 140 {
 141   GRealThreadPool *pool;
 142   gint local_wakeup_thread_serial;
 143   guint local_max_unused_threads;
 144   gint local_max_idle_time;
 145   gint last_wakeup_thread_serial;
 146   gboolean have_relayed_thread_marker = FALSE;
 147 
 148   local_max_unused_threads = g_atomic_int_get (&amp;max_unused_threads);
 149   local_max_idle_time = g_atomic_int_get (&amp;max_idle_time);
 150   last_wakeup_thread_serial = g_atomic_int_get (&amp;wakeup_thread_serial);
 151 
 152   g_atomic_int_inc (&amp;unused_threads);
 153 
 154   do
 155     {
<span class="line-modified"> 156       if (g_atomic_int_get (&amp;unused_threads) &gt;= local_max_unused_threads)</span>
 157         {
 158           /* If this is a superfluous thread, stop it. */
 159           pool = NULL;
 160         }
 161       else if (local_max_idle_time &gt; 0)
 162         {
 163           /* If a maximal idle time is given, wait for the given time. */
 164           DEBUG_MSG ((&quot;thread %p waiting in global pool for %f seconds.&quot;,
 165                       g_thread_self (), local_max_idle_time / 1000.0));
 166 
 167           pool = g_async_queue_timeout_pop (unused_thread_queue,
<span class="line-modified"> 168                         local_max_idle_time * 1000);</span>
 169         }
 170       else
 171         {
 172           /* If no maximal idle time is given, wait indefinitely. */
 173           DEBUG_MSG ((&quot;thread %p waiting in global pool.&quot;, g_thread_self ()));
 174           pool = g_async_queue_pop (unused_thread_queue);
 175         }
 176 
 177       if (pool == wakeup_thread_marker)
 178         {
 179           local_wakeup_thread_serial = g_atomic_int_get (&amp;wakeup_thread_serial);
 180           if (last_wakeup_thread_serial == local_wakeup_thread_serial)
 181             {
 182               if (!have_relayed_thread_marker)
 183               {
 184                 /* If this wakeup marker has been received for
 185                  * the second time, relay it.
 186                  */
 187                 DEBUG_MSG ((&quot;thread %p relaying wakeup message to &quot;
 188                             &quot;waiting thread with lower serial.&quot;,
</pre>
<hr />
<pre>
 216               have_relayed_thread_marker = FALSE;
 217             }
 218         }
 219     }
 220   while (pool == wakeup_thread_marker);
 221 
 222   g_atomic_int_add (&amp;unused_threads, -1);
 223 
 224   return pool;
 225 }
 226 
 227 static gpointer
 228 g_thread_pool_wait_for_new_task (GRealThreadPool *pool)
 229 {
 230   gpointer task = NULL;
 231 
 232   if (pool-&gt;running || (!pool-&gt;immediate &amp;&amp;
 233                         g_async_queue_length_unlocked (pool-&gt;queue) &gt; 0))
 234     {
 235       /* This thread pool is still active. */
<span class="line-modified"> 236       if (pool-&gt;num_threads &gt; pool-&gt;max_threads &amp;&amp; pool-&gt;max_threads != -1)</span>
 237         {
 238           /* This is a superfluous thread, so it goes to the global pool. */
 239           DEBUG_MSG ((&quot;superfluous thread %p in pool %p.&quot;,
 240                       g_thread_self (), pool));
 241         }
 242       else if (pool-&gt;pool.exclusive)
 243         {
 244           /* Exclusive threads stay attached to the pool. */
 245           task = g_async_queue_pop_unlocked (pool-&gt;queue);
 246 
 247           DEBUG_MSG ((&quot;thread %p in exclusive pool %p waits for task &quot;
 248                       &quot;(%d running, %d unprocessed).&quot;,
 249                       g_thread_self (), pool, pool-&gt;num_threads,
 250                       g_async_queue_length_unlocked (pool-&gt;queue)));
 251         }
 252       else
 253         {
 254           /* A thread will wait for new tasks for at most 1/2
 255            * second before going to the global pool.
 256            */
 257           DEBUG_MSG ((&quot;thread %p in pool %p waits for up to a 1/2 second for task &quot;
 258                       &quot;(%d running, %d unprocessed).&quot;,
 259                       g_thread_self (), pool, pool-&gt;num_threads,
 260                       g_async_queue_length_unlocked (pool-&gt;queue)));
 261 
 262           task = g_async_queue_timeout_pop_unlocked (pool-&gt;queue,
<span class="line-modified"> 263                              G_USEC_PER_SEC / 2);</span>
 264         }
 265     }
 266   else
 267     {
 268       /* This thread pool is inactive, it will no longer process tasks. */
 269       DEBUG_MSG ((&quot;pool %p not active, thread %p will go to global pool &quot;
 270                   &quot;(running: %s, immediate: %s, len: %d).&quot;,
 271                   pool, g_thread_self (),
 272                   pool-&gt;running ? &quot;true&quot; : &quot;false&quot;,
 273                   pool-&gt;immediate ? &quot;true&quot; : &quot;false&quot;,
 274                   g_async_queue_length_unlocked (pool-&gt;queue)));
 275     }
 276 
 277   return task;
 278 }
 279 
 280 
 281 static gpointer
 282 g_thread_pool_thread_proxy (gpointer data)
 283 {
</pre>
<hr />
<pre>
 322               if (!pool-&gt;waiting)
 323                 {
 324                   if (pool-&gt;num_threads == 0)
 325                     {
 326                       /* If the pool is not running and no other
 327                        * thread is waiting for this thread pool to
 328                        * finish and this is the last thread of this
 329                        * pool, free the pool.
 330                        */
 331                       free_pool = TRUE;
 332                     }
 333                   else
 334                     {
 335                       /* If the pool is not running and no other
 336                        * thread is waiting for this thread pool to
 337                        * finish and this is not the last thread of
 338                        * this pool and there are no tasks left in the
 339                        * queue, wakeup the remaining threads.
 340                        */
 341                       if (g_async_queue_length_unlocked (pool-&gt;queue) ==
<span class="line-modified"> 342                           - pool-&gt;num_threads)</span>
 343                         g_thread_pool_wakeup_and_stop_all (pool);
 344                     }
 345                 }
 346               else if (pool-&gt;immediate ||
 347                        g_async_queue_length_unlocked (pool-&gt;queue) &lt;= 0)
 348                 {
 349                   /* If the pool is not running and another thread is
 350                    * waiting for this thread pool to finish and there
 351                    * are either no tasks left or the pool shall stop
 352                    * immediately, inform the waiting thread of a change
 353                    * of the thread pool state.
 354                    */
 355                   g_cond_broadcast (&amp;pool-&gt;cond);
 356                 }
 357             }
 358 
 359           g_async_queue_unlock (pool-&gt;queue);
 360 
 361           if (free_pool)
 362             g_thread_pool_free_internal (pool);
</pre>
<hr />
<pre>
 368 
 369           DEBUG_MSG ((&quot;thread %p entering pool %p from global pool.&quot;,
 370                       g_thread_self (), pool));
 371 
 372           /* pool-&gt;num_threads++ is not done here, but in
 373            * g_thread_pool_start_thread to make the new started
 374            * thread known to the pool before itself can do it.
 375            */
 376         }
 377     }
 378 
 379   return NULL;
 380 }
 381 
 382 static gboolean
 383 g_thread_pool_start_thread (GRealThreadPool  *pool,
 384                             GError          **error)
 385 {
 386   gboolean success = FALSE;
 387 
<span class="line-modified"> 388   if (pool-&gt;num_threads &gt;= pool-&gt;max_threads &amp;&amp; pool-&gt;max_threads != -1)</span>
 389     /* Enough threads are already running */
 390     return TRUE;
 391 
 392   g_async_queue_lock (unused_thread_queue);
 393 
 394   if (g_async_queue_length_unlocked (unused_thread_queue) &lt; 0)
 395     {
 396       g_async_queue_push_unlocked (unused_thread_queue, pool);
 397       success = TRUE;
 398     }
 399 
 400   g_async_queue_unlock (unused_thread_queue);
 401 
 402   if (!success)
 403     {


 404       GThread *thread;
 405 



 406       /* No thread was found, we have to start a new one */
<span class="line-modified"> 407       thread = g_thread_try_new (&quot;pool&quot;, g_thread_pool_thread_proxy, pool, error);</span>
 408 
 409       if (thread == NULL)
 410         return FALSE;
 411 
 412       g_thread_unref (thread);
 413     }
 414 
 415   /* See comment in g_thread_pool_thread_proxy as to why this is done
 416    * here and not there
 417    */
 418   pool-&gt;num_threads++;
 419 
 420   return TRUE;
 421 }
 422 
 423 /**
 424  * g_thread_pool_new:
 425  * @func: a function to execute in the threads of the new thread pool
 426  * @user_data: user data that is handed over to @func every time it
 427  *     is called
</pre>
<hr />
<pre>
 481   retval-&gt;pool.exclusive = exclusive;
 482   retval-&gt;queue = g_async_queue_new ();
 483   g_cond_init (&amp;retval-&gt;cond);
 484   retval-&gt;max_threads = max_threads;
 485   retval-&gt;num_threads = 0;
 486   retval-&gt;running = TRUE;
 487   retval-&gt;immediate = FALSE;
 488   retval-&gt;waiting = FALSE;
 489   retval-&gt;sort_func = NULL;
 490   retval-&gt;sort_user_data = NULL;
 491 
 492   G_LOCK (init);
 493   if (!unused_thread_queue)
 494       unused_thread_queue = g_async_queue_new ();
 495   G_UNLOCK (init);
 496 
 497   if (retval-&gt;pool.exclusive)
 498     {
 499       g_async_queue_lock (retval-&gt;queue);
 500 
<span class="line-modified"> 501       while (retval-&gt;num_threads &lt; retval-&gt;max_threads)</span>
 502         {
 503           GError *local_error = NULL;
 504 
 505           if (!g_thread_pool_start_thread (retval, &amp;local_error))
 506             {
 507               g_propagate_error (error, local_error);
 508               break;
 509             }
 510         }
 511 
 512       g_async_queue_unlock (retval-&gt;queue);
 513     }
 514 
 515   return (GThreadPool*) retval;
 516 }
 517 
 518 /**
 519  * g_thread_pool_push:
 520  * @pool: a #GThreadPool
 521  * @data: a new task for @pool
</pre>
<hr />
<pre>
 754   real = (GRealThreadPool*) pool;
 755 
 756   g_return_if_fail (real);
 757   g_return_if_fail (real-&gt;running);
 758 
 759   /* If there&#39;s no thread allowed here, there is not much sense in
 760    * not stopping this pool immediately, when it&#39;s not empty
 761    */
 762   g_return_if_fail (immediate ||
 763                     real-&gt;max_threads != 0 ||
 764                     g_async_queue_length (real-&gt;queue) == 0);
 765 
 766   g_async_queue_lock (real-&gt;queue);
 767 
 768   real-&gt;running = FALSE;
 769   real-&gt;immediate = immediate;
 770   real-&gt;waiting = wait_;
 771 
 772   if (wait_)
 773     {
<span class="line-modified"> 774       while (g_async_queue_length_unlocked (real-&gt;queue) != -real-&gt;num_threads &amp;&amp;</span>
 775              !(immediate &amp;&amp; real-&gt;num_threads == 0))
 776         g_cond_wait (&amp;real-&gt;cond, _g_async_queue_get_mutex (real-&gt;queue));
 777     }
 778 
<span class="line-modified"> 779   if (immediate || g_async_queue_length_unlocked (real-&gt;queue) == -real-&gt;num_threads)</span>
 780     {
 781       /* No thread is currently doing something (and nothing is left
 782        * to process in the queue)
 783        */
 784       if (real-&gt;num_threads == 0)
 785         {
 786           /* No threads left, we clean up */
 787           g_async_queue_unlock (real-&gt;queue);
 788           g_thread_pool_free_internal (real);
 789           return;
 790         }
 791 
 792       g_thread_pool_wakeup_and_stop_all (real);
 793     }
 794 
 795   /* The last thread should cleanup the pool */
 796   real-&gt;waiting = FALSE;
 797   g_async_queue_unlock (real-&gt;queue);
 798 }
 799 
</pre>
</td>
<td>
<hr />
<pre>
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Lesser General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Lesser General Public
  18  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  19  */
  20 
  21 /*
  22  * MT safe
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 
  27 #include &quot;gthreadpool.h&quot;
  28 
  29 #include &quot;gasyncqueue.h&quot;
  30 #include &quot;gasyncqueueprivate.h&quot;
  31 #include &quot;gmain.h&quot;
  32 #include &quot;gtestutils.h&quot;
  33 #include &quot;gtimer.h&quot;
<span class="line-added">  34 #include &quot;gutils.h&quot;</span>
  35 
  36 /**
  37  * SECTION:thread_pools
  38  * @title: Thread Pools
  39  * @short_description: pools of threads to execute work concurrently
  40  * @see_also: #GThread
  41  *
  42  * Sometimes you wish to asynchronously fork out the execution of work
  43  * and continue working in your own thread. If that will happen often,
  44  * the overhead of starting and destroying a thread each time might be
  45  * too high. In such cases reusing already started threads seems like a
  46  * good idea. And it indeed is, but implementing this can be tedious
  47  * and error-prone.
  48  *
  49  * Therefore GLib provides thread pools for your convenience. An added
  50  * advantage is, that the threads can be shared between the different
  51  * subsystems of your program, when they are using GLib.
  52  *
  53  * To create a new thread pool, you use g_thread_pool_new().
  54  * It is destroyed by g_thread_pool_free().
</pre>
<hr />
<pre>
  74 /* #define DEBUG_MSG(args) g_printerr args ; g_printerr (&quot;\n&quot;);    */
  75 
  76 typedef struct _GRealThreadPool GRealThreadPool;
  77 
  78 /**
  79  * GThreadPool:
  80  * @func: the function to execute in the threads of this pool
  81  * @user_data: the user data for the threads of this pool
  82  * @exclusive: are all threads exclusive to this pool
  83  *
  84  * The #GThreadPool struct represents a thread pool. It has three
  85  * public read-only members, but the underlying struct is bigger,
  86  * so you must not copy this struct.
  87  */
  88 struct _GRealThreadPool
  89 {
  90   GThreadPool pool;
  91   GAsyncQueue *queue;
  92   GCond cond;
  93   gint max_threads;
<span class="line-modified">  94   guint num_threads;</span>
  95   gboolean running;
  96   gboolean immediate;
  97   gboolean waiting;
  98   GCompareDataFunc sort_func;
  99   gpointer sort_user_data;
 100 };
 101 
 102 /* The following is just an address to mark the wakeup order for a
 103  * thread, it could be any address (as long, as it isn&#39;t a valid
 104  * GThreadPool address)
 105  */
 106 static const gpointer wakeup_thread_marker = (gpointer) &amp;g_thread_pool_new;
 107 static gint wakeup_thread_serial = 0;
 108 
 109 /* Here all unused threads are waiting  */
 110 static GAsyncQueue *unused_thread_queue = NULL;
 111 static gint unused_threads = 0;
 112 static gint max_unused_threads = 2;
 113 static gint kill_unused_threads = 0;
 114 static guint max_idle_time = 15 * 1000;
</pre>
<hr />
<pre>
 137 }
 138 
 139 static GRealThreadPool*
 140 g_thread_pool_wait_for_new_pool (void)
 141 {
 142   GRealThreadPool *pool;
 143   gint local_wakeup_thread_serial;
 144   guint local_max_unused_threads;
 145   gint local_max_idle_time;
 146   gint last_wakeup_thread_serial;
 147   gboolean have_relayed_thread_marker = FALSE;
 148 
 149   local_max_unused_threads = g_atomic_int_get (&amp;max_unused_threads);
 150   local_max_idle_time = g_atomic_int_get (&amp;max_idle_time);
 151   last_wakeup_thread_serial = g_atomic_int_get (&amp;wakeup_thread_serial);
 152 
 153   g_atomic_int_inc (&amp;unused_threads);
 154 
 155   do
 156     {
<span class="line-modified"> 157       if ((guint) g_atomic_int_get (&amp;unused_threads) &gt;= local_max_unused_threads)</span>
 158         {
 159           /* If this is a superfluous thread, stop it. */
 160           pool = NULL;
 161         }
 162       else if (local_max_idle_time &gt; 0)
 163         {
 164           /* If a maximal idle time is given, wait for the given time. */
 165           DEBUG_MSG ((&quot;thread %p waiting in global pool for %f seconds.&quot;,
 166                       g_thread_self (), local_max_idle_time / 1000.0));
 167 
 168           pool = g_async_queue_timeout_pop (unused_thread_queue,
<span class="line-modified"> 169               local_max_idle_time * 1000);</span>
 170         }
 171       else
 172         {
 173           /* If no maximal idle time is given, wait indefinitely. */
 174           DEBUG_MSG ((&quot;thread %p waiting in global pool.&quot;, g_thread_self ()));
 175           pool = g_async_queue_pop (unused_thread_queue);
 176         }
 177 
 178       if (pool == wakeup_thread_marker)
 179         {
 180           local_wakeup_thread_serial = g_atomic_int_get (&amp;wakeup_thread_serial);
 181           if (last_wakeup_thread_serial == local_wakeup_thread_serial)
 182             {
 183               if (!have_relayed_thread_marker)
 184               {
 185                 /* If this wakeup marker has been received for
 186                  * the second time, relay it.
 187                  */
 188                 DEBUG_MSG ((&quot;thread %p relaying wakeup message to &quot;
 189                             &quot;waiting thread with lower serial.&quot;,
</pre>
<hr />
<pre>
 217               have_relayed_thread_marker = FALSE;
 218             }
 219         }
 220     }
 221   while (pool == wakeup_thread_marker);
 222 
 223   g_atomic_int_add (&amp;unused_threads, -1);
 224 
 225   return pool;
 226 }
 227 
 228 static gpointer
 229 g_thread_pool_wait_for_new_task (GRealThreadPool *pool)
 230 {
 231   gpointer task = NULL;
 232 
 233   if (pool-&gt;running || (!pool-&gt;immediate &amp;&amp;
 234                         g_async_queue_length_unlocked (pool-&gt;queue) &gt; 0))
 235     {
 236       /* This thread pool is still active. */
<span class="line-modified"> 237       if (pool-&gt;max_threads != -1 &amp;&amp; pool-&gt;num_threads &gt; (guint) pool-&gt;max_threads)</span>
 238         {
 239           /* This is a superfluous thread, so it goes to the global pool. */
 240           DEBUG_MSG ((&quot;superfluous thread %p in pool %p.&quot;,
 241                       g_thread_self (), pool));
 242         }
 243       else if (pool-&gt;pool.exclusive)
 244         {
 245           /* Exclusive threads stay attached to the pool. */
 246           task = g_async_queue_pop_unlocked (pool-&gt;queue);
 247 
 248           DEBUG_MSG ((&quot;thread %p in exclusive pool %p waits for task &quot;
 249                       &quot;(%d running, %d unprocessed).&quot;,
 250                       g_thread_self (), pool, pool-&gt;num_threads,
 251                       g_async_queue_length_unlocked (pool-&gt;queue)));
 252         }
 253       else
 254         {
 255           /* A thread will wait for new tasks for at most 1/2
 256            * second before going to the global pool.
 257            */
 258           DEBUG_MSG ((&quot;thread %p in pool %p waits for up to a 1/2 second for task &quot;
 259                       &quot;(%d running, %d unprocessed).&quot;,
 260                       g_thread_self (), pool, pool-&gt;num_threads,
 261                       g_async_queue_length_unlocked (pool-&gt;queue)));
 262 
 263           task = g_async_queue_timeout_pop_unlocked (pool-&gt;queue,
<span class="line-modified"> 264                  G_USEC_PER_SEC / 2);</span>
 265         }
 266     }
 267   else
 268     {
 269       /* This thread pool is inactive, it will no longer process tasks. */
 270       DEBUG_MSG ((&quot;pool %p not active, thread %p will go to global pool &quot;
 271                   &quot;(running: %s, immediate: %s, len: %d).&quot;,
 272                   pool, g_thread_self (),
 273                   pool-&gt;running ? &quot;true&quot; : &quot;false&quot;,
 274                   pool-&gt;immediate ? &quot;true&quot; : &quot;false&quot;,
 275                   g_async_queue_length_unlocked (pool-&gt;queue)));
 276     }
 277 
 278   return task;
 279 }
 280 
 281 
 282 static gpointer
 283 g_thread_pool_thread_proxy (gpointer data)
 284 {
</pre>
<hr />
<pre>
 323               if (!pool-&gt;waiting)
 324                 {
 325                   if (pool-&gt;num_threads == 0)
 326                     {
 327                       /* If the pool is not running and no other
 328                        * thread is waiting for this thread pool to
 329                        * finish and this is the last thread of this
 330                        * pool, free the pool.
 331                        */
 332                       free_pool = TRUE;
 333                     }
 334                   else
 335                     {
 336                       /* If the pool is not running and no other
 337                        * thread is waiting for this thread pool to
 338                        * finish and this is not the last thread of
 339                        * this pool and there are no tasks left in the
 340                        * queue, wakeup the remaining threads.
 341                        */
 342                       if (g_async_queue_length_unlocked (pool-&gt;queue) ==
<span class="line-modified"> 343                           (gint) -pool-&gt;num_threads)</span>
 344                         g_thread_pool_wakeup_and_stop_all (pool);
 345                     }
 346                 }
 347               else if (pool-&gt;immediate ||
 348                        g_async_queue_length_unlocked (pool-&gt;queue) &lt;= 0)
 349                 {
 350                   /* If the pool is not running and another thread is
 351                    * waiting for this thread pool to finish and there
 352                    * are either no tasks left or the pool shall stop
 353                    * immediately, inform the waiting thread of a change
 354                    * of the thread pool state.
 355                    */
 356                   g_cond_broadcast (&amp;pool-&gt;cond);
 357                 }
 358             }
 359 
 360           g_async_queue_unlock (pool-&gt;queue);
 361 
 362           if (free_pool)
 363             g_thread_pool_free_internal (pool);
</pre>
<hr />
<pre>
 369 
 370           DEBUG_MSG ((&quot;thread %p entering pool %p from global pool.&quot;,
 371                       g_thread_self (), pool));
 372 
 373           /* pool-&gt;num_threads++ is not done here, but in
 374            * g_thread_pool_start_thread to make the new started
 375            * thread known to the pool before itself can do it.
 376            */
 377         }
 378     }
 379 
 380   return NULL;
 381 }
 382 
 383 static gboolean
 384 g_thread_pool_start_thread (GRealThreadPool  *pool,
 385                             GError          **error)
 386 {
 387   gboolean success = FALSE;
 388 
<span class="line-modified"> 389   if (pool-&gt;max_threads != -1 &amp;&amp; pool-&gt;num_threads &gt;= (guint) pool-&gt;max_threads)</span>
 390     /* Enough threads are already running */
 391     return TRUE;
 392 
 393   g_async_queue_lock (unused_thread_queue);
 394 
 395   if (g_async_queue_length_unlocked (unused_thread_queue) &lt; 0)
 396     {
 397       g_async_queue_push_unlocked (unused_thread_queue, pool);
 398       success = TRUE;
 399     }
 400 
 401   g_async_queue_unlock (unused_thread_queue);
 402 
 403   if (!success)
 404     {
<span class="line-added"> 405       const gchar *prgname = g_get_prgname ();</span>
<span class="line-added"> 406       gchar name[16] = &quot;pool&quot;;</span>
 407       GThread *thread;
 408 
<span class="line-added"> 409       if (prgname)</span>
<span class="line-added"> 410         g_snprintf (name, sizeof (name), &quot;pool-%s&quot;, prgname);</span>
<span class="line-added"> 411 </span>
 412       /* No thread was found, we have to start a new one */
<span class="line-modified"> 413       thread = g_thread_try_new (name, g_thread_pool_thread_proxy, pool, error);</span>
 414 
 415       if (thread == NULL)
 416         return FALSE;
 417 
 418       g_thread_unref (thread);
 419     }
 420 
 421   /* See comment in g_thread_pool_thread_proxy as to why this is done
 422    * here and not there
 423    */
 424   pool-&gt;num_threads++;
 425 
 426   return TRUE;
 427 }
 428 
 429 /**
 430  * g_thread_pool_new:
 431  * @func: a function to execute in the threads of the new thread pool
 432  * @user_data: user data that is handed over to @func every time it
 433  *     is called
</pre>
<hr />
<pre>
 487   retval-&gt;pool.exclusive = exclusive;
 488   retval-&gt;queue = g_async_queue_new ();
 489   g_cond_init (&amp;retval-&gt;cond);
 490   retval-&gt;max_threads = max_threads;
 491   retval-&gt;num_threads = 0;
 492   retval-&gt;running = TRUE;
 493   retval-&gt;immediate = FALSE;
 494   retval-&gt;waiting = FALSE;
 495   retval-&gt;sort_func = NULL;
 496   retval-&gt;sort_user_data = NULL;
 497 
 498   G_LOCK (init);
 499   if (!unused_thread_queue)
 500       unused_thread_queue = g_async_queue_new ();
 501   G_UNLOCK (init);
 502 
 503   if (retval-&gt;pool.exclusive)
 504     {
 505       g_async_queue_lock (retval-&gt;queue);
 506 
<span class="line-modified"> 507       while (retval-&gt;num_threads &lt; (guint) retval-&gt;max_threads)</span>
 508         {
 509           GError *local_error = NULL;
 510 
 511           if (!g_thread_pool_start_thread (retval, &amp;local_error))
 512             {
 513               g_propagate_error (error, local_error);
 514               break;
 515             }
 516         }
 517 
 518       g_async_queue_unlock (retval-&gt;queue);
 519     }
 520 
 521   return (GThreadPool*) retval;
 522 }
 523 
 524 /**
 525  * g_thread_pool_push:
 526  * @pool: a #GThreadPool
 527  * @data: a new task for @pool
</pre>
<hr />
<pre>
 760   real = (GRealThreadPool*) pool;
 761 
 762   g_return_if_fail (real);
 763   g_return_if_fail (real-&gt;running);
 764 
 765   /* If there&#39;s no thread allowed here, there is not much sense in
 766    * not stopping this pool immediately, when it&#39;s not empty
 767    */
 768   g_return_if_fail (immediate ||
 769                     real-&gt;max_threads != 0 ||
 770                     g_async_queue_length (real-&gt;queue) == 0);
 771 
 772   g_async_queue_lock (real-&gt;queue);
 773 
 774   real-&gt;running = FALSE;
 775   real-&gt;immediate = immediate;
 776   real-&gt;waiting = wait_;
 777 
 778   if (wait_)
 779     {
<span class="line-modified"> 780       while (g_async_queue_length_unlocked (real-&gt;queue) != (gint) -real-&gt;num_threads &amp;&amp;</span>
 781              !(immediate &amp;&amp; real-&gt;num_threads == 0))
 782         g_cond_wait (&amp;real-&gt;cond, _g_async_queue_get_mutex (real-&gt;queue));
 783     }
 784 
<span class="line-modified"> 785   if (immediate || g_async_queue_length_unlocked (real-&gt;queue) == (gint) -real-&gt;num_threads)</span>
 786     {
 787       /* No thread is currently doing something (and nothing is left
 788        * to process in the queue)
 789        */
 790       if (real-&gt;num_threads == 0)
 791         {
 792           /* No threads left, we clean up */
 793           g_async_queue_unlock (real-&gt;queue);
 794           g_thread_pool_free_internal (real);
 795           return;
 796         }
 797 
 798       g_thread_pool_wakeup_and_stop_all (real);
 799     }
 800 
 801   /* The last thread should cleanup the pool */
 802   real-&gt;waiting = FALSE;
 803   g_async_queue_unlock (real-&gt;queue);
 804 }
 805 
</pre>
</td>
</tr>
</table>
<center><a href="gthread.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gthreadprivate.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>