<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gtree.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #include &quot;gtree.h&quot;
  32 
  33 #include &quot;gatomic.h&quot;
  34 #include &quot;gtestutils.h&quot;
  35 #include &quot;gslice.h&quot;
  36 
  37 /**
  38  * SECTION:trees-binary
  39  * @title: Balanced Binary Trees
  40  * @short_description: a sorted collection of key/value pairs optimized
  41  *                     for searching and traversing in order
  42  *
  43  * The #GTree structure and its associated functions provide a sorted
  44  * collection of key/value pairs optimized for searching and traversing
  45  * in order.
  46  *
  47  * To create a new #GTree use g_tree_new().
  48  *
  49  * To insert a key/value pair into a #GTree use g_tree_insert().
  50  *
<a name="1" id="anc1"></a><span class="line-modified">  51  * To lookup the value corresponding to a given key, use</span>
  52  * g_tree_lookup() and g_tree_lookup_extended().
  53  *
  54  * To find out the number of nodes in a #GTree, use g_tree_nnodes(). To
  55  * get the height of a #GTree, use g_tree_height().
  56  *
  57  * To traverse a #GTree, calling a function for each node visited in
  58  * the traversal, use g_tree_foreach().
  59  *
  60  * To remove a key/value pair use g_tree_remove().
  61  *
  62  * To destroy a #GTree, use g_tree_destroy().
  63  **/
  64 
  65 #undef G_TREE_DEBUG
  66 
  67 #define MAX_GTREE_HEIGHT 40
  68 
  69 typedef struct _GTreeNode  GTreeNode;
  70 
  71 /**
  72  * GTree:
  73  *
  74  * The GTree struct is an opaque data structure representing a
  75  * [balanced binary tree][glib-Balanced-Binary-Trees]. It should be
  76  * accessed only by using the following functions.
  77  */
  78 struct _GTree
  79 {
  80   GTreeNode        *root;
  81   GCompareDataFunc  key_compare;
  82   GDestroyNotify    key_destroy_func;
  83   GDestroyNotify    value_destroy_func;
  84   gpointer          key_compare_data;
  85   guint             nnodes;
  86   gint              ref_count;
  87 };
  88 
  89 struct _GTreeNode
  90 {
  91   gpointer   key;         /* key for this node */
  92   gpointer   value;       /* value stored at this node */
  93   GTreeNode *left;        /* left subtree */
  94   GTreeNode *right;       /* right subtree */
  95   gint8      balance;     /* height (right) - height (left) */
  96   guint8     left_child;
  97   guint8     right_child;
  98 };
  99 
 100 
 101 static GTreeNode* g_tree_node_new                   (gpointer       key,
 102                                                      gpointer       value);
 103 static void       g_tree_insert_internal            (GTree         *tree,
 104                                                      gpointer       key,
 105                                                      gpointer       value,
 106                                                      gboolean       replace);
 107 static gboolean   g_tree_remove_internal            (GTree         *tree,
 108                                                      gconstpointer  key,
 109                                                      gboolean       steal);
 110 static GTreeNode* g_tree_node_balance               (GTreeNode     *node);
 111 static GTreeNode *g_tree_find_node                  (GTree         *tree,
 112                                                      gconstpointer  key);
 113 static gint       g_tree_node_pre_order             (GTreeNode     *node,
 114                                                      GTraverseFunc  traverse_func,
 115                                                      gpointer       data);
 116 static gint       g_tree_node_in_order              (GTreeNode     *node,
 117                                                      GTraverseFunc  traverse_func,
 118                                                      gpointer       data);
 119 static gint       g_tree_node_post_order            (GTreeNode     *node,
 120                                                      GTraverseFunc  traverse_func,
 121                                                      gpointer       data);
 122 static gpointer   g_tree_node_search                (GTreeNode     *node,
 123                                                      GCompareFunc   search_func,
 124                                                      gconstpointer  data);
 125 static GTreeNode* g_tree_node_rotate_left           (GTreeNode     *node);
 126 static GTreeNode* g_tree_node_rotate_right          (GTreeNode     *node);
 127 #ifdef G_TREE_DEBUG
 128 static void       g_tree_node_check                 (GTreeNode     *node);
 129 #endif
 130 
 131 
 132 static GTreeNode*
 133 g_tree_node_new (gpointer key,
 134                  gpointer value)
 135 {
 136   GTreeNode *node = g_slice_new (GTreeNode);
 137 #ifdef GSTREAMER_LITE
 138   if (node == NULL) {
 139     return NULL;
 140   }
 141 #endif // GSTREAMER_LITE
 142 
 143   node-&gt;balance = 0;
 144   node-&gt;left = NULL;
 145   node-&gt;right = NULL;
 146   node-&gt;left_child = FALSE;
 147   node-&gt;right_child = FALSE;
 148   node-&gt;key = key;
 149   node-&gt;value = value;
 150 
 151   return node;
 152 }
 153 
 154 /**
 155  * g_tree_new:
 156  * @key_compare_func: the function used to order the nodes in the #GTree.
 157  *   It should return values similar to the standard strcmp() function -
 158  *   0 if the two arguments are equal, a negative value if the first argument
 159  *   comes before the second, or a positive value if the first argument comes
 160  *   after the second.
 161  *
 162  * Creates a new #GTree.
 163  *
 164  * Returns: a newly allocated #GTree
 165  */
 166 GTree *
 167 g_tree_new (GCompareFunc key_compare_func)
 168 {
 169   g_return_val_if_fail (key_compare_func != NULL, NULL);
 170 
 171   return g_tree_new_full ((GCompareDataFunc) key_compare_func, NULL,
 172                           NULL, NULL);
 173 }
 174 
 175 /**
 176  * g_tree_new_with_data:
 177  * @key_compare_func: qsort()-style comparison function
 178  * @key_compare_data: data to pass to comparison function
 179  *
 180  * Creates a new #GTree with a comparison function that accepts user data.
 181  * See g_tree_new() for more details.
 182  *
 183  * Returns: a newly allocated #GTree
 184  */
 185 GTree *
 186 g_tree_new_with_data (GCompareDataFunc key_compare_func,
 187                       gpointer         key_compare_data)
 188 {
 189   g_return_val_if_fail (key_compare_func != NULL, NULL);
 190 
 191   return g_tree_new_full (key_compare_func, key_compare_data,
 192                           NULL, NULL);
 193 }
 194 
 195 /**
 196  * g_tree_new_full:
 197  * @key_compare_func: qsort()-style comparison function
 198  * @key_compare_data: data to pass to comparison function
 199  * @key_destroy_func: a function to free the memory allocated for the key
 200  *   used when removing the entry from the #GTree or %NULL if you don&#39;t
 201  *   want to supply such a function
 202  * @value_destroy_func: a function to free the memory allocated for the
 203  *   value used when removing the entry from the #GTree or %NULL if you
 204  *   don&#39;t want to supply such a function
 205  *
 206  * Creates a new #GTree like g_tree_new() and allows to specify functions
 207  * to free the memory allocated for the key and value that get called when
 208  * removing the entry from the #GTree.
 209  *
 210  * Returns: a newly allocated #GTree
 211  */
 212 GTree *
 213 g_tree_new_full (GCompareDataFunc key_compare_func,
 214                  gpointer         key_compare_data,
 215                  GDestroyNotify   key_destroy_func,
 216                  GDestroyNotify   value_destroy_func)
 217 {
 218   GTree *tree;
 219 
 220   g_return_val_if_fail (key_compare_func != NULL, NULL);
 221 
 222   tree = g_slice_new (GTree);
 223 #ifdef GSTREAMER_LITE
 224   if (tree == NULL) {
 225     return NULL;
 226   }
 227 #endif // GSTREAMER_LITE
 228   tree-&gt;root               = NULL;
 229   tree-&gt;key_compare        = key_compare_func;
 230   tree-&gt;key_destroy_func   = key_destroy_func;
 231   tree-&gt;value_destroy_func = value_destroy_func;
 232   tree-&gt;key_compare_data   = key_compare_data;
 233   tree-&gt;nnodes             = 0;
 234   tree-&gt;ref_count          = 1;
 235 
 236   return tree;
 237 }
 238 
 239 static inline GTreeNode *
 240 g_tree_first_node (GTree *tree)
 241 {
 242   GTreeNode *tmp;
 243 
 244   if (!tree-&gt;root)
 245     return NULL;
 246 
 247   tmp = tree-&gt;root;
 248 
 249   while (tmp-&gt;left_child)
 250     tmp = tmp-&gt;left;
 251 
 252   return tmp;
 253 }
 254 
 255 static inline GTreeNode *
 256 g_tree_node_previous (GTreeNode *node)
 257 {
 258   GTreeNode *tmp;
 259 
 260   tmp = node-&gt;left;
 261 
 262   if (node-&gt;left_child)
 263     while (tmp-&gt;right_child)
 264       tmp = tmp-&gt;right;
 265 
 266   return tmp;
 267 }
 268 
 269 static inline GTreeNode *
 270 g_tree_node_next (GTreeNode *node)
 271 {
 272   GTreeNode *tmp;
 273 
 274   tmp = node-&gt;right;
 275 
 276   if (node-&gt;right_child)
 277     while (tmp-&gt;left_child)
 278       tmp = tmp-&gt;left;
 279 
 280   return tmp;
 281 }
 282 
 283 static void
 284 g_tree_remove_all (GTree *tree)
 285 {
 286   GTreeNode *node;
 287   GTreeNode *next;
 288 
 289   g_return_if_fail (tree != NULL);
 290 
 291   node = g_tree_first_node (tree);
 292 
 293   while (node)
 294     {
 295       next = g_tree_node_next (node);
 296 
 297       if (tree-&gt;key_destroy_func)
 298         tree-&gt;key_destroy_func (node-&gt;key);
 299       if (tree-&gt;value_destroy_func)
 300         tree-&gt;value_destroy_func (node-&gt;value);
 301       g_slice_free (GTreeNode, node);
 302 
 303       node = next;
 304     }
 305 
 306   tree-&gt;root = NULL;
 307   tree-&gt;nnodes = 0;
 308 }
 309 
 310 /**
 311  * g_tree_ref:
 312  * @tree: a #GTree
 313  *
 314  * Increments the reference count of @tree by one.
 315  *
 316  * It is safe to call this function from any thread.
 317  *
 318  * Returns: the passed in #GTree
 319  *
 320  * Since: 2.22
 321  */
 322 GTree *
 323 g_tree_ref (GTree *tree)
 324 {
 325   g_return_val_if_fail (tree != NULL, NULL);
 326 
 327   g_atomic_int_inc (&amp;tree-&gt;ref_count);
 328 
 329   return tree;
 330 }
 331 
 332 /**
 333  * g_tree_unref:
 334  * @tree: a #GTree
 335  *
 336  * Decrements the reference count of @tree by one.
 337  * If the reference count drops to 0, all keys and values will
 338  * be destroyed (if destroy functions were specified) and all
 339  * memory allocated by @tree will be released.
 340  *
 341  * It is safe to call this function from any thread.
 342  *
 343  * Since: 2.22
 344  */
 345 void
 346 g_tree_unref (GTree *tree)
 347 {
 348   g_return_if_fail (tree != NULL);
 349 
 350   if (g_atomic_int_dec_and_test (&amp;tree-&gt;ref_count))
 351     {
 352       g_tree_remove_all (tree);
 353       g_slice_free (GTree, tree);
 354     }
 355 }
 356 
 357 /**
 358  * g_tree_destroy:
 359  * @tree: a #GTree
 360  *
 361  * Removes all keys and values from the #GTree and decreases its
 362  * reference count by one. If keys and/or values are dynamically
 363  * allocated, you should either free them first or create the #GTree
 364  * using g_tree_new_full(). In the latter case the destroy functions
 365  * you supplied will be called on all keys and values before destroying
 366  * the #GTree.
 367  */
 368 void
 369 g_tree_destroy (GTree *tree)
 370 {
 371   g_return_if_fail (tree != NULL);
 372 
 373   g_tree_remove_all (tree);
 374   g_tree_unref (tree);
 375 }
 376 
 377 /**
 378  * g_tree_insert:
 379  * @tree: a #GTree
 380  * @key: the key to insert
 381  * @value: the value corresponding to the key
 382  *
 383  * Inserts a key/value pair into a #GTree.
 384  *
 385  * If the given key already exists in the #GTree its corresponding value
 386  * is set to the new value. If you supplied a @value_destroy_func when
 387  * creating the #GTree, the old value is freed using that function. If
 388  * you supplied a @key_destroy_func when creating the #GTree, the passed
 389  * key is freed using that function.
 390  *
 391  * The tree is automatically &#39;balanced&#39; as new key/value pairs are added,
 392  * so that the distance from the root to every leaf is as small as possible.
 393  */
 394 void
 395 g_tree_insert (GTree    *tree,
 396                gpointer  key,
 397                gpointer  value)
 398 {
 399   g_return_if_fail (tree != NULL);
 400 
 401   g_tree_insert_internal (tree, key, value, FALSE);
 402 
 403 #ifdef G_TREE_DEBUG
 404   g_tree_node_check (tree-&gt;root);
 405 #endif
 406 }
 407 
 408 /**
 409  * g_tree_replace:
 410  * @tree: a #GTree
 411  * @key: the key to insert
 412  * @value: the value corresponding to the key
 413  *
 414  * Inserts a new key and value into a #GTree similar to g_tree_insert().
 415  * The difference is that if the key already exists in the #GTree, it gets
 416  * replaced by the new key. If you supplied a @value_destroy_func when
 417  * creating the #GTree, the old value is freed using that function. If you
 418  * supplied a @key_destroy_func when creating the #GTree, the old key is
 419  * freed using that function.
 420  *
 421  * The tree is automatically &#39;balanced&#39; as new key/value pairs are added,
 422  * so that the distance from the root to every leaf is as small as possible.
 423  */
 424 void
 425 g_tree_replace (GTree    *tree,
 426                 gpointer  key,
 427                 gpointer  value)
 428 {
 429   g_return_if_fail (tree != NULL);
 430 
 431   g_tree_insert_internal (tree, key, value, TRUE);
 432 
 433 #ifdef G_TREE_DEBUG
 434   g_tree_node_check (tree-&gt;root);
 435 #endif
 436 }
 437 
 438 /* internal insert routine */
 439 static void
 440 g_tree_insert_internal (GTree    *tree,
 441                         gpointer  key,
 442                         gpointer  value,
 443                         gboolean  replace)
 444 {
 445   GTreeNode *node;
 446   GTreeNode *path[MAX_GTREE_HEIGHT];
 447   int idx;
 448 
 449   g_return_if_fail (tree != NULL);
 450 
 451   if (!tree-&gt;root)
 452     {
 453       tree-&gt;root = g_tree_node_new (key, value);
 454       tree-&gt;nnodes++;
 455       return;
 456     }
 457 
 458   idx = 0;
 459   path[idx++] = NULL;
 460   node = tree-&gt;root;
 461 
 462   while (1)
 463     {
 464       int cmp = tree-&gt;key_compare (key, node-&gt;key, tree-&gt;key_compare_data);
 465 
 466       if (cmp == 0)
 467         {
 468           if (tree-&gt;value_destroy_func)
 469             tree-&gt;value_destroy_func (node-&gt;value);
 470 
 471           node-&gt;value = value;
 472 
 473           if (replace)
 474             {
 475               if (tree-&gt;key_destroy_func)
 476                 tree-&gt;key_destroy_func (node-&gt;key);
 477 
 478               node-&gt;key = key;
 479             }
 480           else
 481             {
 482               /* free the passed key */
 483               if (tree-&gt;key_destroy_func)
 484                 tree-&gt;key_destroy_func (key);
 485             }
 486 
 487           return;
 488         }
 489       else if (cmp &lt; 0)
 490         {
 491           if (node-&gt;left_child)
 492             {
 493               path[idx++] = node;
 494               node = node-&gt;left;
 495             }
 496           else
 497             {
 498               GTreeNode *child = g_tree_node_new (key, value);
 499 #ifdef GSTREAMER_LITE
 500               if (child == NULL) {
 501                 return;
 502               }
 503 #endif // GSTREAMER_LITE
 504 
 505               child-&gt;left = node-&gt;left;
 506               child-&gt;right = node;
 507               node-&gt;left = child;
 508               node-&gt;left_child = TRUE;
 509               node-&gt;balance -= 1;
 510 
 511               tree-&gt;nnodes++;
 512 
 513               break;
 514             }
 515         }
 516       else
 517         {
 518           if (node-&gt;right_child)
 519             {
 520               path[idx++] = node;
 521               node = node-&gt;right;
 522             }
 523           else
 524             {
 525               GTreeNode *child = g_tree_node_new (key, value);
 526 #ifdef GSTREAMER_LITE
 527               if (child == NULL) {
 528                 return;
 529               }
 530 #endif // GSTREAMER_LITE
 531 
 532               child-&gt;right = node-&gt;right;
 533               child-&gt;left = node;
 534               node-&gt;right = child;
 535               node-&gt;right_child = TRUE;
 536               node-&gt;balance += 1;
 537 
 538               tree-&gt;nnodes++;
 539 
 540               break;
 541             }
 542         }
 543     }
 544 
 545   /* Restore balance. This is the goodness of a non-recursive
 546    * implementation, when we are done with balancing we &#39;break&#39;
 547    * the loop and we are done.
 548    */
 549   while (1)
 550     {
 551       GTreeNode *bparent = path[--idx];
 552       gboolean left_node = (bparent &amp;&amp; node == bparent-&gt;left);
 553       g_assert (!bparent || bparent-&gt;left == node || bparent-&gt;right == node);
 554 
 555       if (node-&gt;balance &lt; -1 || node-&gt;balance &gt; 1)
 556         {
 557           node = g_tree_node_balance (node);
 558           if (bparent == NULL)
 559             tree-&gt;root = node;
 560           else if (left_node)
 561             bparent-&gt;left = node;
 562           else
 563             bparent-&gt;right = node;
 564         }
 565 
 566       if (node-&gt;balance == 0 || bparent == NULL)
 567         break;
 568 
 569       if (left_node)
 570         bparent-&gt;balance -= 1;
 571       else
 572         bparent-&gt;balance += 1;
 573 
 574       node = bparent;
 575     }
 576 }
 577 
 578 /**
 579  * g_tree_remove:
 580  * @tree: a #GTree
 581  * @key: the key to remove
 582  *
 583  * Removes a key/value pair from a #GTree.
 584  *
 585  * If the #GTree was created using g_tree_new_full(), the key and value
 586  * are freed using the supplied destroy functions, otherwise you have to
 587  * make sure that any dynamically allocated values are freed yourself.
 588  * If the key does not exist in the #GTree, the function does nothing.
 589  *
 590  * Returns: %TRUE if the key was found (prior to 2.8, this function
 591  *     returned nothing)
 592  */
 593 gboolean
 594 g_tree_remove (GTree         *tree,
 595                gconstpointer  key)
 596 {
 597   gboolean removed;
 598 
 599   g_return_val_if_fail (tree != NULL, FALSE);
 600 
 601   removed = g_tree_remove_internal (tree, key, FALSE);
 602 
 603 #ifdef G_TREE_DEBUG
 604   g_tree_node_check (tree-&gt;root);
 605 #endif
 606 
 607   return removed;
 608 }
 609 
 610 /**
 611  * g_tree_steal:
 612  * @tree: a #GTree
 613  * @key: the key to remove
 614  *
 615  * Removes a key and its associated value from a #GTree without calling
 616  * the key and value destroy functions.
 617  *
 618  * If the key does not exist in the #GTree, the function does nothing.
 619  *
 620  * Returns: %TRUE if the key was found (prior to 2.8, this function
 621  *     returned nothing)
 622  */
 623 gboolean
 624 g_tree_steal (GTree         *tree,
 625               gconstpointer  key)
 626 {
 627   gboolean removed;
 628 
 629   g_return_val_if_fail (tree != NULL, FALSE);
 630 
 631   removed = g_tree_remove_internal (tree, key, TRUE);
 632 
 633 #ifdef G_TREE_DEBUG
 634   g_tree_node_check (tree-&gt;root);
 635 #endif
 636 
 637   return removed;
 638 }
 639 
 640 /* internal remove routine */
 641 static gboolean
 642 g_tree_remove_internal (GTree         *tree,
 643                         gconstpointer  key,
 644                         gboolean       steal)
 645 {
 646   GTreeNode *node, *parent, *balance;
 647   GTreeNode *path[MAX_GTREE_HEIGHT];
 648   int idx;
 649   gboolean left_node;
 650 
 651   g_return_val_if_fail (tree != NULL, FALSE);
 652 
 653   if (!tree-&gt;root)
 654     return FALSE;
 655 
 656   idx = 0;
 657   path[idx++] = NULL;
 658   node = tree-&gt;root;
 659 
 660   while (1)
 661     {
 662       int cmp = tree-&gt;key_compare (key, node-&gt;key, tree-&gt;key_compare_data);
 663 
 664       if (cmp == 0)
 665         break;
 666       else if (cmp &lt; 0)
 667         {
 668           if (!node-&gt;left_child)
 669             return FALSE;
 670 
 671           path[idx++] = node;
 672           node = node-&gt;left;
 673         }
 674       else
 675         {
 676           if (!node-&gt;right_child)
 677             return FALSE;
 678 
 679           path[idx++] = node;
 680           node = node-&gt;right;
 681         }
 682     }
 683 
 684   /* The following code is almost equal to g_tree_remove_node,
 685    * except that we do not have to call g_tree_node_parent.
 686    */
 687   balance = parent = path[--idx];
 688   g_assert (!parent || parent-&gt;left == node || parent-&gt;right == node);
 689   left_node = (parent &amp;&amp; node == parent-&gt;left);
 690 
 691   if (!node-&gt;left_child)
 692     {
 693       if (!node-&gt;right_child)
 694         {
 695           if (!parent)
 696             tree-&gt;root = NULL;
 697           else if (left_node)
 698             {
 699               parent-&gt;left_child = FALSE;
 700               parent-&gt;left = node-&gt;left;
 701               parent-&gt;balance += 1;
 702             }
 703           else
 704             {
 705               parent-&gt;right_child = FALSE;
 706               parent-&gt;right = node-&gt;right;
 707               parent-&gt;balance -= 1;
 708             }
 709         }
 710       else /* node has a right child */
 711         {
 712           GTreeNode *tmp = g_tree_node_next (node);
 713           tmp-&gt;left = node-&gt;left;
 714 
 715           if (!parent)
 716             tree-&gt;root = node-&gt;right;
 717           else if (left_node)
 718             {
 719               parent-&gt;left = node-&gt;right;
 720               parent-&gt;balance += 1;
 721             }
 722           else
 723             {
 724               parent-&gt;right = node-&gt;right;
 725               parent-&gt;balance -= 1;
 726             }
 727         }
 728     }
 729   else /* node has a left child */
 730     {
 731       if (!node-&gt;right_child)
 732         {
 733           GTreeNode *tmp = g_tree_node_previous (node);
 734           tmp-&gt;right = node-&gt;right;
 735 
 736           if (parent == NULL)
 737             tree-&gt;root = node-&gt;left;
 738           else if (left_node)
 739             {
 740               parent-&gt;left = node-&gt;left;
 741               parent-&gt;balance += 1;
 742             }
 743           else
 744             {
 745               parent-&gt;right = node-&gt;left;
 746               parent-&gt;balance -= 1;
 747             }
 748         }
 749       else /* node has a both children (pant, pant!) */
 750         {
 751           GTreeNode *prev = node-&gt;left;
 752           GTreeNode *next = node-&gt;right;
 753           GTreeNode *nextp = node;
 754           int old_idx = idx + 1;
 755           idx++;
 756 
 757           /* path[idx] == parent */
 758           /* find the immediately next node (and its parent) */
 759           while (next-&gt;left_child)
 760             {
 761               path[++idx] = nextp = next;
 762               next = next-&gt;left;
 763             }
 764 
 765           path[old_idx] = next;
 766           balance = path[idx];
 767 
 768           /* remove &#39;next&#39; from the tree */
 769           if (nextp != node)
 770             {
 771               if (next-&gt;right_child)
 772                 nextp-&gt;left = next-&gt;right;
 773               else
 774                 nextp-&gt;left_child = FALSE;
 775               nextp-&gt;balance += 1;
 776 
 777               next-&gt;right_child = TRUE;
 778               next-&gt;right = node-&gt;right;
 779             }
 780           else
 781             node-&gt;balance -= 1;
 782 
 783           /* set the prev to point to the right place */
 784           while (prev-&gt;right_child)
 785             prev = prev-&gt;right;
 786           prev-&gt;right = next;
 787 
 788           /* prepare &#39;next&#39; to replace &#39;node&#39; */
 789           next-&gt;left_child = TRUE;
 790           next-&gt;left = node-&gt;left;
 791           next-&gt;balance = node-&gt;balance;
 792 
 793           if (!parent)
 794             tree-&gt;root = next;
 795           else if (left_node)
 796             parent-&gt;left = next;
 797           else
 798             parent-&gt;right = next;
 799         }
 800     }
 801 
 802   /* restore balance */
 803   if (balance)
 804     while (1)
 805       {
 806         GTreeNode *bparent = path[--idx];
 807         g_assert (!bparent || bparent-&gt;left == balance || bparent-&gt;right == balance);
 808         left_node = (bparent &amp;&amp; balance == bparent-&gt;left);
 809 
 810         if(balance-&gt;balance &lt; -1 || balance-&gt;balance &gt; 1)
 811           {
 812             balance = g_tree_node_balance (balance);
 813             if (!bparent)
 814               tree-&gt;root = balance;
 815             else if (left_node)
 816               bparent-&gt;left = balance;
 817             else
 818               bparent-&gt;right = balance;
 819           }
 820 
 821         if (balance-&gt;balance != 0 || !bparent)
 822           break;
 823 
 824         if (left_node)
 825           bparent-&gt;balance += 1;
 826         else
 827           bparent-&gt;balance -= 1;
 828 
 829         balance = bparent;
 830       }
 831 
 832   if (!steal)
 833     {
 834       if (tree-&gt;key_destroy_func)
 835         tree-&gt;key_destroy_func (node-&gt;key);
 836       if (tree-&gt;value_destroy_func)
 837         tree-&gt;value_destroy_func (node-&gt;value);
 838     }
 839 
 840   g_slice_free (GTreeNode, node);
 841 
 842   tree-&gt;nnodes--;
 843 
 844   return TRUE;
 845 }
 846 
 847 /**
 848  * g_tree_lookup:
 849  * @tree: a #GTree
 850  * @key: the key to look up
 851  *
 852  * Gets the value corresponding to the given key. Since a #GTree is
 853  * automatically balanced as key/value pairs are added, key lookup
 854  * is O(log n) (where n is the number of key/value pairs in the tree).
 855  *
 856  * Returns: the value corresponding to the key, or %NULL
 857  *     if the key was not found
 858  */
 859 gpointer
 860 g_tree_lookup (GTree         *tree,
 861                gconstpointer  key)
 862 {
 863   GTreeNode *node;
 864 
 865   g_return_val_if_fail (tree != NULL, NULL);
 866 
 867   node = g_tree_find_node (tree, key);
 868 
 869   return node ? node-&gt;value : NULL;
 870 }
 871 
 872 /**
 873  * g_tree_lookup_extended:
 874  * @tree: a #GTree
 875  * @lookup_key: the key to look up
<a name="2" id="anc2"></a><span class="line-modified"> 876  * @orig_key: (optional) (nullable): returns the original key</span>
<span class="line-modified"> 877  * @value: (optional) (nullable): returns the value associated with the key</span>
 878  *
 879  * Looks up a key in the #GTree, returning the original key and the
 880  * associated value. This is useful if you need to free the memory
 881  * allocated for the original key, for example before calling
 882  * g_tree_remove().
 883  *
 884  * Returns: %TRUE if the key was found in the #GTree
 885  */
 886 gboolean
 887 g_tree_lookup_extended (GTree         *tree,
 888                         gconstpointer  lookup_key,
 889                         gpointer      *orig_key,
 890                         gpointer      *value)
 891 {
 892   GTreeNode *node;
 893 
 894   g_return_val_if_fail (tree != NULL, FALSE);
 895 
 896   node = g_tree_find_node (tree, lookup_key);
 897 
 898   if (node)
 899     {
 900       if (orig_key)
 901         *orig_key = node-&gt;key;
 902       if (value)
 903         *value = node-&gt;value;
 904       return TRUE;
 905     }
 906   else
 907     return FALSE;
 908 }
 909 
 910 /**
 911  * g_tree_foreach:
 912  * @tree: a #GTree
 913  * @func: the function to call for each node visited.
 914  *     If this function returns %TRUE, the traversal is stopped.
 915  * @user_data: user data to pass to the function
 916  *
 917  * Calls the given function for each of the key/value pairs in the #GTree.
 918  * The function is passed the key and value of each pair, and the given
 919  * @data parameter. The tree is traversed in sorted order.
 920  *
 921  * The tree may not be modified while iterating over it (you can&#39;t
 922  * add/remove items). To remove all items matching a predicate, you need
 923  * to add each item to a list in your #GTraverseFunc as you walk over
 924  * the tree, then walk the list and remove each item.
 925  */
 926 void
 927 g_tree_foreach (GTree         *tree,
 928                 GTraverseFunc  func,
 929                 gpointer       user_data)
 930 {
 931   GTreeNode *node;
 932 
 933   g_return_if_fail (tree != NULL);
 934 
 935   if (!tree-&gt;root)
 936     return;
 937 
 938   node = g_tree_first_node (tree);
 939 
 940   while (node)
 941     {
 942       if ((*func) (node-&gt;key, node-&gt;value, user_data))
 943         break;
 944 
 945       node = g_tree_node_next (node);
 946     }
 947 }
 948 
 949 /**
 950  * g_tree_traverse:
 951  * @tree: a #GTree
 952  * @traverse_func: the function to call for each node visited. If this
 953  *   function returns %TRUE, the traversal is stopped.
 954  * @traverse_type: the order in which nodes are visited, one of %G_IN_ORDER,
 955  *   %G_PRE_ORDER and %G_POST_ORDER
 956  * @user_data: user data to pass to the function
 957  *
 958  * Calls the given function for each node in the #GTree.
 959  *
 960  * Deprecated:2.2: The order of a balanced tree is somewhat arbitrary.
 961  *     If you just want to visit all nodes in sorted order, use
 962  *     g_tree_foreach() instead. If you really need to visit nodes in
 963  *     a different order, consider using an [n-ary tree][glib-N-ary-Trees].
 964  */
 965 /**
 966  * GTraverseFunc:
 967  * @key: a key of a #GTree node
 968  * @value: the value corresponding to the key
 969  * @data: user data passed to g_tree_traverse()
 970  *
 971  * Specifies the type of function passed to g_tree_traverse(). It is
 972  * passed the key and value of each node, together with the @user_data
 973  * parameter passed to g_tree_traverse(). If the function returns
 974  * %TRUE, the traversal is stopped.
 975  *
 976  * Returns: %TRUE to stop the traversal
 977  */
 978 void
 979 g_tree_traverse (GTree         *tree,
 980                  GTraverseFunc  traverse_func,
 981                  GTraverseType  traverse_type,
 982                  gpointer       user_data)
 983 {
 984   g_return_if_fail (tree != NULL);
 985 
 986   if (!tree-&gt;root)
 987     return;
 988 
 989   switch (traverse_type)
 990     {
 991     case G_PRE_ORDER:
 992       g_tree_node_pre_order (tree-&gt;root, traverse_func, user_data);
 993       break;
 994 
 995     case G_IN_ORDER:
 996       g_tree_node_in_order (tree-&gt;root, traverse_func, user_data);
 997       break;
 998 
 999     case G_POST_ORDER:
1000       g_tree_node_post_order (tree-&gt;root, traverse_func, user_data);
1001       break;
1002 
1003     case G_LEVEL_ORDER:
1004       g_warning (&quot;g_tree_traverse(): traverse type G_LEVEL_ORDER isn&#39;t implemented.&quot;);
1005       break;
1006     }
1007 }
1008 
1009 /**
1010  * g_tree_search:
1011  * @tree: a #GTree
1012  * @search_func: a function used to search the #GTree
1013  * @user_data: the data passed as the second argument to @search_func
1014  *
1015  * Searches a #GTree using @search_func.
1016  *
1017  * The @search_func is called with a pointer to the key of a key/value
1018  * pair in the tree, and the passed in @user_data. If @search_func returns
1019  * 0 for a key/value pair, then the corresponding value is returned as
1020  * the result of g_tree_search(). If @search_func returns -1, searching
1021  * will proceed among the key/value pairs that have a smaller key; if
1022  * @search_func returns 1, searching will proceed among the key/value
1023  * pairs that have a larger key.
1024  *
1025  * Returns: the value corresponding to the found key, or %NULL
1026  *     if the key was not found
1027  */
1028 gpointer
1029 g_tree_search (GTree         *tree,
1030                GCompareFunc   search_func,
1031                gconstpointer  user_data)
1032 {
1033   g_return_val_if_fail (tree != NULL, NULL);
1034 
1035   if (tree-&gt;root)
1036     return g_tree_node_search (tree-&gt;root, search_func, user_data);
1037   else
1038     return NULL;
1039 }
1040 
1041 /**
1042  * g_tree_height:
1043  * @tree: a #GTree
1044  *
1045  * Gets the height of a #GTree.
1046  *
1047  * If the #GTree contains no nodes, the height is 0.
1048  * If the #GTree contains only one root node the height is 1.
1049  * If the root node has children the height is 2, etc.
1050  *
1051  * Returns: the height of @tree
1052  */
1053 gint
1054 g_tree_height (GTree *tree)
1055 {
1056   GTreeNode *node;
1057   gint height;
1058 
1059   g_return_val_if_fail (tree != NULL, 0);
1060 
1061   if (!tree-&gt;root)
1062     return 0;
1063 
1064   height = 0;
1065   node = tree-&gt;root;
1066 
1067   while (1)
1068     {
1069       height += 1 + MAX(node-&gt;balance, 0);
1070 
1071       if (!node-&gt;left_child)
1072         return height;
1073 
1074       node = node-&gt;left;
1075     }
1076 }
1077 
1078 /**
1079  * g_tree_nnodes:
1080  * @tree: a #GTree
1081  *
1082  * Gets the number of nodes in a #GTree.
1083  *
1084  * Returns: the number of nodes in @tree
1085  */
1086 gint
1087 g_tree_nnodes (GTree *tree)
1088 {
1089   g_return_val_if_fail (tree != NULL, 0);
1090 
1091   return tree-&gt;nnodes;
1092 }
1093 
1094 static GTreeNode *
1095 g_tree_node_balance (GTreeNode *node)
1096 {
1097   if (node-&gt;balance &lt; -1)
1098     {
1099       if (node-&gt;left-&gt;balance &gt; 0)
1100         node-&gt;left = g_tree_node_rotate_left (node-&gt;left);
1101       node = g_tree_node_rotate_right (node);
1102     }
1103   else if (node-&gt;balance &gt; 1)
1104     {
1105       if (node-&gt;right-&gt;balance &lt; 0)
1106         node-&gt;right = g_tree_node_rotate_right (node-&gt;right);
1107       node = g_tree_node_rotate_left (node);
1108     }
1109 
1110   return node;
1111 }
1112 
1113 static GTreeNode *
1114 g_tree_find_node (GTree        *tree,
1115                   gconstpointer key)
1116 {
1117   GTreeNode *node;
1118   gint cmp;
1119 
1120   node = tree-&gt;root;
1121   if (!node)
1122     return NULL;
1123 
1124   while (1)
1125     {
1126       cmp = tree-&gt;key_compare (key, node-&gt;key, tree-&gt;key_compare_data);
1127       if (cmp == 0)
1128         return node;
1129       else if (cmp &lt; 0)
1130         {
1131           if (!node-&gt;left_child)
1132             return NULL;
1133 
1134           node = node-&gt;left;
1135         }
1136       else
1137         {
1138           if (!node-&gt;right_child)
1139             return NULL;
1140 
1141           node = node-&gt;right;
1142         }
1143     }
1144 }
1145 
1146 static gint
1147 g_tree_node_pre_order (GTreeNode     *node,
1148                        GTraverseFunc  traverse_func,
1149                        gpointer       data)
1150 {
1151   if ((*traverse_func) (node-&gt;key, node-&gt;value, data))
1152     return TRUE;
1153 
1154   if (node-&gt;left_child)
1155     {
1156       if (g_tree_node_pre_order (node-&gt;left, traverse_func, data))
1157         return TRUE;
1158     }
1159 
1160   if (node-&gt;right_child)
1161     {
1162       if (g_tree_node_pre_order (node-&gt;right, traverse_func, data))
1163         return TRUE;
1164     }
1165 
1166   return FALSE;
1167 }
1168 
1169 static gint
1170 g_tree_node_in_order (GTreeNode     *node,
1171                       GTraverseFunc  traverse_func,
1172                       gpointer       data)
1173 {
1174   if (node-&gt;left_child)
1175     {
1176       if (g_tree_node_in_order (node-&gt;left, traverse_func, data))
1177         return TRUE;
1178     }
1179 
1180   if ((*traverse_func) (node-&gt;key, node-&gt;value, data))
1181     return TRUE;
1182 
1183   if (node-&gt;right_child)
1184     {
1185       if (g_tree_node_in_order (node-&gt;right, traverse_func, data))
1186         return TRUE;
1187     }
1188 
1189   return FALSE;
1190 }
1191 
1192 static gint
1193 g_tree_node_post_order (GTreeNode     *node,
1194                         GTraverseFunc  traverse_func,
1195                         gpointer       data)
1196 {
1197   if (node-&gt;left_child)
1198     {
1199       if (g_tree_node_post_order (node-&gt;left, traverse_func, data))
1200         return TRUE;
1201     }
1202 
1203   if (node-&gt;right_child)
1204     {
1205       if (g_tree_node_post_order (node-&gt;right, traverse_func, data))
1206         return TRUE;
1207     }
1208 
1209   if ((*traverse_func) (node-&gt;key, node-&gt;value, data))
1210     return TRUE;
1211 
1212   return FALSE;
1213 }
1214 
1215 static gpointer
1216 g_tree_node_search (GTreeNode     *node,
1217                     GCompareFunc   search_func,
1218                     gconstpointer  data)
1219 {
1220   gint dir;
1221 
1222   if (!node)
1223     return NULL;
1224 
1225   while (1)
1226     {
1227       dir = (* search_func) (node-&gt;key, data);
1228       if (dir == 0)
1229         return node-&gt;value;
1230       else if (dir &lt; 0)
1231         {
1232           if (!node-&gt;left_child)
1233             return NULL;
1234 
1235           node = node-&gt;left;
1236         }
1237       else
1238         {
1239           if (!node-&gt;right_child)
1240             return NULL;
1241 
1242           node = node-&gt;right;
1243         }
1244     }
1245 }
1246 
1247 static GTreeNode *
1248 g_tree_node_rotate_left (GTreeNode *node)
1249 {
1250   GTreeNode *right;
1251   gint a_bal;
1252   gint b_bal;
1253 
1254   right = node-&gt;right;
1255 
1256   if (right-&gt;left_child)
1257     node-&gt;right = right-&gt;left;
1258   else
1259     {
1260       node-&gt;right_child = FALSE;
1261       right-&gt;left_child = TRUE;
1262     }
1263   right-&gt;left = node;
1264 
1265   a_bal = node-&gt;balance;
1266   b_bal = right-&gt;balance;
1267 
1268   if (b_bal &lt;= 0)
1269     {
1270       if (a_bal &gt;= 1)
1271         right-&gt;balance = b_bal - 1;
1272       else
1273         right-&gt;balance = a_bal + b_bal - 2;
1274       node-&gt;balance = a_bal - 1;
1275     }
1276   else
1277     {
1278       if (a_bal &lt;= b_bal)
1279         right-&gt;balance = a_bal - 2;
1280       else
1281         right-&gt;balance = b_bal - 1;
1282       node-&gt;balance = a_bal - b_bal - 1;
1283     }
1284 
1285   return right;
1286 }
1287 
1288 static GTreeNode *
1289 g_tree_node_rotate_right (GTreeNode *node)
1290 {
1291   GTreeNode *left;
1292   gint a_bal;
1293   gint b_bal;
1294 
1295   left = node-&gt;left;
1296 
1297   if (left-&gt;right_child)
1298     node-&gt;left = left-&gt;right;
1299   else
1300     {
1301       node-&gt;left_child = FALSE;
1302       left-&gt;right_child = TRUE;
1303     }
1304   left-&gt;right = node;
1305 
1306   a_bal = node-&gt;balance;
1307   b_bal = left-&gt;balance;
1308 
1309   if (b_bal &lt;= 0)
1310     {
1311       if (b_bal &gt; a_bal)
1312         left-&gt;balance = b_bal + 1;
1313       else
1314         left-&gt;balance = a_bal + 2;
1315       node-&gt;balance = a_bal - b_bal + 1;
1316     }
1317   else
1318     {
1319       if (a_bal &lt;= -1)
1320         left-&gt;balance = b_bal + 1;
1321       else
1322         left-&gt;balance = a_bal + b_bal + 2;
1323       node-&gt;balance = a_bal + 1;
1324     }
1325 
1326   return left;
1327 }
1328 
1329 #ifdef G_TREE_DEBUG
1330 static gint
1331 g_tree_node_height (GTreeNode *node)
1332 {
1333   gint left_height;
1334   gint right_height;
1335 
1336   if (node)
1337     {
1338       left_height = 0;
1339       right_height = 0;
1340 
1341       if (node-&gt;left_child)
1342         left_height = g_tree_node_height (node-&gt;left);
1343 
1344       if (node-&gt;right_child)
1345         right_height = g_tree_node_height (node-&gt;right);
1346 
1347       return MAX (left_height, right_height) + 1;
1348     }
1349 
1350   return 0;
1351 }
1352 
1353 static void
1354 g_tree_node_check (GTreeNode *node)
1355 {
1356   gint left_height;
1357   gint right_height;
1358   gint balance;
1359   GTreeNode *tmp;
1360 
1361   if (node)
1362     {
1363       if (node-&gt;left_child)
1364         {
1365           tmp = g_tree_node_previous (node);
1366           g_assert (tmp-&gt;right == node);
1367         }
1368 
1369       if (node-&gt;right_child)
1370         {
1371           tmp = g_tree_node_next (node);
1372           g_assert (tmp-&gt;left == node);
1373         }
1374 
1375       left_height = 0;
1376       right_height = 0;
1377 
1378       if (node-&gt;left_child)
1379         left_height = g_tree_node_height (node-&gt;left);
1380       if (node-&gt;right_child)
1381         right_height = g_tree_node_height (node-&gt;right);
1382 
1383       balance = right_height - left_height;
1384       g_assert (balance == node-&gt;balance);
1385 
1386       if (node-&gt;left_child)
1387         g_tree_node_check (node-&gt;left);
1388       if (node-&gt;right_child)
1389         g_tree_node_check (node-&gt;right);
1390     }
1391 }
1392 
1393 static void
1394 g_tree_node_dump (GTreeNode *node,
1395                   gint       indent)
1396 {
1397   g_print (&quot;%*s%c\n&quot;, indent, &quot;&quot;, *(char *)node-&gt;key);
1398 
1399   if (node-&gt;left_child)
1400     g_tree_node_dump (node-&gt;left, indent + 2);
1401   else if (node-&gt;left)
1402     g_print (&quot;%*s&lt;%c\n&quot;, indent + 2, &quot;&quot;, *(char *)node-&gt;left-&gt;key);
1403 
1404   if (node-&gt;right_child)
1405     g_tree_node_dump (node-&gt;right, indent + 2);
1406   else if (node-&gt;right)
1407     g_print (&quot;%*s&gt;%c\n&quot;, indent + 2, &quot;&quot;, *(char *)node-&gt;right-&gt;key);
1408 }
1409 
1410 
1411 void
1412 g_tree_dump (GTree *tree)
1413 {
1414   if (tree-&gt;root)
1415     g_tree_node_dump (tree-&gt;root, 0);
1416 }
1417 #endif
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>