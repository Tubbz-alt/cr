<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gtype.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GObject - GLib Type, Object, Parameter and Signal Library
   2  * Copyright (C) 1998-1999, 2000-2001 Tim Janik and Red Hat, Inc.
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General
  15  * Public License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * MT safe
  20  */
  21 
  22 #include &quot;config.h&quot;
  23 
  24 #include &quot;../glib/gvalgrind.h&quot;
  25 #include &lt;string.h&gt;
  26 
  27 #include &quot;gtype.h&quot;
  28 #include &quot;gtype-private.h&quot;
  29 #include &quot;gtypeplugin.h&quot;
  30 #include &quot;gvaluecollector.h&quot;
  31 #include &quot;gatomicarray.h&quot;
  32 #include &quot;gobject_trace.h&quot;
  33 
  34 #include &quot;glib-private.h&quot;
  35 #include &quot;gconstructor.h&quot;
  36 
  37 #ifdef G_OS_WIN32
  38 #include &lt;windows.h&gt;
  39 #endif
  40 
  41 #ifdef  G_ENABLE_DEBUG
  42 #define IF_DEBUG(debug_type)  if (_g_type_debug_flags &amp; G_TYPE_DEBUG_ ## debug_type)
  43 #endif
  44 
  45 /**
  46  * SECTION:gtype
  47  * @short_description: The GLib Runtime type identification and
  48  *     management system
  49  * @title:Type Information
  50  *
  51  * The GType API is the foundation of the GObject system.  It provides the
  52  * facilities for registering and managing all fundamental data types,
  53  * user-defined object and interface types.
  54  *
  55  * For type creation and registration purposes, all types fall into one of
  56  * two categories: static or dynamic.  Static types are never loaded or
  57  * unloaded at run-time as dynamic types may be.  Static types are created
  58  * with g_type_register_static() that gets type specific information passed
  59  * in via a #GTypeInfo structure.
  60  *
  61  * Dynamic types are created with g_type_register_dynamic() which takes a
  62  * #GTypePlugin structure instead. The remaining type information (the
  63  * #GTypeInfo structure) is retrieved during runtime through #GTypePlugin
  64  * and the g_type_plugin_*() API.
  65  *
  66  * These registration functions are usually called only once from a
  67  * function whose only purpose is to return the type identifier for a
  68  * specific class.  Once the type (or class or interface) is registered,
  69  * it may be instantiated, inherited, or implemented depending on exactly
  70  * what sort of type it is.
  71  *
  72  * There is also a third registration function for registering fundamental
  73  * types called g_type_register_fundamental() which requires both a #GTypeInfo
  74  * structure and a #GTypeFundamentalInfo structure but it is seldom used
  75  * since most fundamental types are predefined rather than user-defined.
  76  *
  77  * Type instance and class structs are limited to a total of 64 KiB,
  78  * including all parent types. Similarly, type instances&#39; private data
  79  * (as created by G_ADD_PRIVATE()) are limited to a total of
  80  * 64 KiB. If a type instance needs a large static buffer, allocate it
  81  * separately (typically by using #GArray or #GPtrArray) and put a pointer
  82  * to the buffer in the structure.
  83  *
  84  * As mentioned in the [GType conventions][gtype-conventions], type names must
  85  * be at least three characters long. There is no upper length limit. The first
  86  * character must be a letter (a or A) or an underscore (). Subsequent
  87  * characters can be letters, numbers or any of .
  88  */
  89 
  90 
  91 /* NOTE: some functions (some internal variants and exported ones)
  92  * invalidate data portions of the TypeNodes. if external functions/callbacks
  93  * are called, pointers to memory maintained by TypeNodes have to be looked up
  94  * again. this affects most of the struct TypeNode fields, e.g. -&gt;children or
  95  * CLASSED_NODE_IFACES_ENTRIES() respectively IFACE_NODE_PREREQUISITES() (but
  96  * not -&gt;supers[]), as all those memory portions can get realloc()ed during
  97  * callback invocation.
  98  *
  99  * LOCKING:
 100  * lock handling issues when calling static functions are indicated by
 101  * uppercase letter postfixes, all static functions have to have
 102  * one of the below postfixes:
 103  * - _I:  [Indifferent about locking]
 104  *   function doesn&#39;t care about locks at all
 105  * - _U:  [Unlocked invocation]
 106  *   no read or write lock has to be held across function invocation
 107  *   (locks may be acquired and released during invocation though)
 108  * - _L:  [Locked invocation]
 109  *   a write lock or more than 0 read locks have to be held across
 110  *   function invocation
 111  * - _W:  [Write-locked invocation]
 112  *   a write lock has to be held across function invocation
 113  * - _Wm: [Write-locked invocation, mutatable]
 114  *   like _W, but the write lock might be released and reacquired
 115  *   during invocation, watch your pointers
 116  * - _WmREC:    [Write-locked invocation, mutatable, recursive]
 117  *   like _Wm, but also acquires recursive mutex class_init_rec_mutex
 118  */
 119 
 120 #ifdef LOCK_DEBUG
 121 #define G_READ_LOCK(rw_lock)    do { g_printerr (G_STRLOC &quot;: readL++\n&quot;); g_rw_lock_reader_lock (rw_lock); } while (0)
 122 #define G_READ_UNLOCK(rw_lock)  do { g_printerr (G_STRLOC &quot;: readL--\n&quot;); g_rw_lock_reader_unlock (rw_lock); } while (0)
 123 #define G_WRITE_LOCK(rw_lock)   do { g_printerr (G_STRLOC &quot;: writeL++\n&quot;); g_rw_lock_writer_lock (rw_lock); } while (0)
 124 #define G_WRITE_UNLOCK(rw_lock) do { g_printerr (G_STRLOC &quot;: writeL--\n&quot;); g_rw_lock_writer_unlock (rw_lock); } while (0)
 125 #else
 126 #define G_READ_LOCK(rw_lock)    g_rw_lock_reader_lock (rw_lock)
 127 #define G_READ_UNLOCK(rw_lock)  g_rw_lock_reader_unlock (rw_lock)
 128 #define G_WRITE_LOCK(rw_lock)   g_rw_lock_writer_lock (rw_lock)
 129 #define G_WRITE_UNLOCK(rw_lock) g_rw_lock_writer_unlock (rw_lock)
 130 #endif
 131 #define INVALID_RECURSION(func, arg, type_name) G_STMT_START{ \
 132     static const gchar _action[] = &quot; invalidly modified type &quot;;  \
 133     gpointer _arg = (gpointer) (arg); const gchar *_tname = (type_name), *_fname = (func); \
 134     if (_arg) \
 135       g_error (&quot;%s(%p)%s&#39;%s&#39;&quot;, _fname, _arg, _action, _tname); \
 136     else \
 137       g_error (&quot;%s()%s&#39;%s&#39;&quot;, _fname, _action, _tname); \
 138 }G_STMT_END
 139 #define g_assert_type_system_initialized() \
 140   g_assert (static_quark_type_flags)
 141 
 142 #define TYPE_FUNDAMENTAL_FLAG_MASK (G_TYPE_FLAG_CLASSED | \
 143             G_TYPE_FLAG_INSTANTIATABLE | \
 144             G_TYPE_FLAG_DERIVABLE | \
 145             G_TYPE_FLAG_DEEP_DERIVABLE)
 146 #define TYPE_FLAG_MASK       (G_TYPE_FLAG_ABSTRACT | G_TYPE_FLAG_VALUE_ABSTRACT)
 147 #define SIZEOF_FUNDAMENTAL_INFO    ((gssize) MAX (MAX (sizeof (GTypeFundamentalInfo), \
 148                    sizeof (gpointer)), \
 149                                                   sizeof (glong)))
 150 
 151 /* The 2*sizeof(size_t) alignment here is borrowed from
 152  * GNU libc, so it should be good most everywhere.
 153  * It is more conservative than is needed on some 64-bit
 154  * platforms, but ia64 does require a 16-byte alignment.
 155  * The SIMD extensions for x86 and ppc32 would want a
 156  * larger alignment than this, but we don&#39;t need to
 157  * do better than malloc.
 158  */
 159 #define STRUCT_ALIGNMENT (2 * sizeof (gsize))
 160 #define ALIGN_STRUCT(offset) \
 161       ((offset + (STRUCT_ALIGNMENT - 1)) &amp; -STRUCT_ALIGNMENT)
 162 
 163 
 164 /* --- typedefs --- */
 165 typedef struct _TypeNode        TypeNode;
 166 typedef struct _CommonData      CommonData;
 167 typedef struct _BoxedData       BoxedData;
 168 typedef struct _IFaceData       IFaceData;
 169 typedef struct _ClassData       ClassData;
 170 typedef struct _InstanceData    InstanceData;
 171 typedef union  _TypeData        TypeData;
 172 typedef struct _IFaceEntries    IFaceEntries;
 173 typedef struct _IFaceEntry      IFaceEntry;
 174 typedef struct _IFaceHolder IFaceHolder;
 175 
 176 
 177 /* --- prototypes --- */
 178 static inline GTypeFundamentalInfo* type_node_fundamental_info_I  (TypeNode   *node);
 179 static        void      type_add_flags_W    (TypeNode   *node,
 180                    GTypeFlags    flags);
 181 static        void      type_data_make_W    (TypeNode   *node,
 182                    const GTypeInfo  *info,
 183                    const GTypeValueTable  *value_table);
 184 static inline void      type_data_ref_Wm    (TypeNode   *node);
 185 static inline void      type_data_unref_U               (TypeNode   *node,
 186                    gboolean    uncached);
 187 static void       type_data_last_unref_Wm   (TypeNode *              node,
 188                    gboolean    uncached);
 189 static inline gpointer      type_get_qdata_L    (TypeNode   *node,
 190                    GQuark      quark);
 191 static inline void      type_set_qdata_W    (TypeNode   *node,
 192                    GQuark      quark,
 193                    gpointer    data);
 194 static IFaceHolder*     type_iface_peek_holder_L  (TypeNode   *iface,
 195                    GType       instance_type);
 196 static gboolean                         type_iface_vtable_base_init_Wm  (TypeNode               *iface,
 197                                                                          TypeNode               *node);
 198 static void                             type_iface_vtable_iface_init_Wm (TypeNode               *iface,
 199                                                                          TypeNode               *node);
 200 static gboolean       type_node_is_a_L    (TypeNode   *node,
 201                    TypeNode   *iface_node);
 202 
 203 
 204 /* --- enumeration --- */
 205 
 206 /* The InitState enumeration is used to track the progress of initializing
 207  * both classes and interface vtables. Keeping the state of initialization
 208  * is necessary to handle new interfaces being added while we are initializing
 209  * the class or other interfaces.
 210  */
 211 typedef enum
 212 {
 213   UNINITIALIZED,
 214   BASE_CLASS_INIT,
 215   BASE_IFACE_INIT,
 216   CLASS_INIT,
 217   IFACE_INIT,
 218   INITIALIZED
 219 } InitState;
 220 
 221 /* --- structures --- */
 222 struct _TypeNode
 223 {
 224   guint volatile ref_count;
 225 #ifdef G_ENABLE_DEBUG
 226   guint volatile instance_count;
 227 #endif
 228   GTypePlugin *plugin;
 229   guint        n_children; /* writable with lock */
 230   guint        n_supers : 8;
 231   guint        n_prerequisites : 9;
 232   guint        is_classed : 1;
 233   guint        is_instantiatable : 1;
 234   guint        mutatable_check_cache : 1; /* combines some common path checks */
 235   GType       *children; /* writable with lock */
 236   TypeData * volatile data;
 237   GQuark       qname;
 238   GData       *global_gdata;
 239   union {
 240     GAtomicArray iface_entries;   /* for !iface types */
 241     GAtomicArray offsets;
 242   } _prot;
 243   GType       *prerequisites;
 244   GType        supers[1]; /* flexible array */
 245 };
 246 
 247 #define SIZEOF_BASE_TYPE_NODE()     (G_STRUCT_OFFSET (TypeNode, supers))
 248 #define MAX_N_SUPERS        (255)
 249 #define MAX_N_CHILDREN        (G_MAXUINT)
 250 #define MAX_N_INTERFACES      (255) /* Limited by offsets being 8 bits */
 251 #define MAX_N_PREREQUISITES     (511)
 252 #define NODE_TYPE(node)       (node-&gt;supers[0])
 253 #define NODE_PARENT_TYPE(node)      (node-&gt;supers[1])
 254 #define NODE_FUNDAMENTAL_TYPE(node)   (node-&gt;supers[node-&gt;n_supers])
 255 #define NODE_NAME(node)       (g_quark_to_string (node-&gt;qname))
 256 #define NODE_REFCOUNT(node)                     ((guint) g_atomic_int_get ((int *) &amp;(node)-&gt;ref_count))
 257 #define NODE_IS_BOXED(node)     (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_BOXED)
 258 #define NODE_IS_IFACE(node)     (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_INTERFACE)
 259 #define CLASSED_NODE_IFACES_ENTRIES(node) (&amp;(node)-&gt;_prot.iface_entries)
 260 #define CLASSED_NODE_IFACES_ENTRIES_LOCKED(node)(G_ATOMIC_ARRAY_GET_LOCKED(CLASSED_NODE_IFACES_ENTRIES((node)), IFaceEntries))
 261 #define IFACE_NODE_N_PREREQUISITES(node)  ((node)-&gt;n_prerequisites)
 262 #define IFACE_NODE_PREREQUISITES(node)    ((node)-&gt;prerequisites)
 263 #define iface_node_get_holders_L(node)    ((IFaceHolder*) type_get_qdata_L ((node), static_quark_iface_holder))
 264 #define iface_node_set_holders_W(node, holders) (type_set_qdata_W ((node), static_quark_iface_holder, (holders)))
 265 #define iface_node_get_dependants_array_L(n)  ((GType*) type_get_qdata_L ((n), static_quark_dependants_array))
 266 #define iface_node_set_dependants_array_W(n,d)  (type_set_qdata_W ((n), static_quark_dependants_array, (d)))
 267 #define TYPE_ID_MASK        ((GType) ((1 &lt;&lt; G_TYPE_FUNDAMENTAL_SHIFT) - 1))
 268 
 269 #define NODE_IS_ANCESTOR(ancestor, node)                                                    \
 270         ((ancestor)-&gt;n_supers &lt;= (node)-&gt;n_supers &amp;&amp;                                        \
 271    (node)-&gt;supers[(node)-&gt;n_supers - (ancestor)-&gt;n_supers] == NODE_TYPE (ancestor))
 272 
 273 struct _IFaceHolder
 274 {
 275   GType           instance_type;
 276   GInterfaceInfo *info;
 277   GTypePlugin    *plugin;
 278   IFaceHolder    *next;
 279 };
 280 
 281 struct _IFaceEntry
 282 {
 283   GType           iface_type;
 284   GTypeInterface *vtable;
 285   InitState       init_state;
 286 };
 287 
 288 struct _IFaceEntries {
 289   guint offset_index;
 290   IFaceEntry entry[1];
 291 };
 292 
 293 #define IFACE_ENTRIES_HEADER_SIZE (sizeof(IFaceEntries) - sizeof(IFaceEntry))
 294 #define IFACE_ENTRIES_N_ENTRIES(_entries) ( (G_ATOMIC_ARRAY_DATA_SIZE((_entries)) - IFACE_ENTRIES_HEADER_SIZE) / sizeof(IFaceEntry) )
 295 
 296 struct _CommonData
 297 {
 298   GTypeValueTable  *value_table;
 299 };
 300 
 301 struct _BoxedData
 302 {
 303   CommonData         data;
 304   GBoxedCopyFunc     copy_func;
 305   GBoxedFreeFunc     free_func;
 306 };
 307 
 308 struct _IFaceData
 309 {
 310   CommonData         common;
 311   guint16            vtable_size;
 312   GBaseInitFunc      vtable_init_base;
 313   GBaseFinalizeFunc  vtable_finalize_base;
 314   GClassInitFunc     dflt_init;
 315   GClassFinalizeFunc dflt_finalize;
 316   gconstpointer      dflt_data;
 317   gpointer           dflt_vtable;
 318 };
 319 
 320 struct _ClassData
 321 {
 322   CommonData         common;
 323   guint16            class_size;
 324   guint16            class_private_size;
 325   int volatile       init_state; /* atomic - g_type_class_ref reads it unlocked */
 326   GBaseInitFunc      class_init_base;
 327   GBaseFinalizeFunc  class_finalize_base;
 328   GClassInitFunc     class_init;
 329   GClassFinalizeFunc class_finalize;
 330   gconstpointer      class_data;
 331   gpointer           class;
 332 };
 333 
 334 struct _InstanceData
 335 {
 336   CommonData         common;
 337   guint16            class_size;
 338   guint16            class_private_size;
 339   int volatile       init_state; /* atomic - g_type_class_ref reads it unlocked */
 340   GBaseInitFunc      class_init_base;
 341   GBaseFinalizeFunc  class_finalize_base;
 342   GClassInitFunc     class_init;
 343   GClassFinalizeFunc class_finalize;
 344   gconstpointer      class_data;
 345   gpointer           class;
 346   guint16            instance_size;
 347   guint16            private_size;
 348   guint16            n_preallocs;
 349   GInstanceInitFunc  instance_init;
 350 };
 351 
 352 union _TypeData
 353 {
 354   CommonData         common;
 355   BoxedData          boxed;
 356   IFaceData          iface;
 357   ClassData          class;
 358   InstanceData       instance;
 359 };
 360 
 361 typedef struct {
 362   gpointer            cache_data;
 363   GTypeClassCacheFunc cache_func;
 364 } ClassCacheFunc;
 365 
 366 typedef struct {
 367   gpointer                check_data;
 368   GTypeInterfaceCheckFunc check_func;
 369 } IFaceCheckFunc;
 370 
 371 
 372 /* --- variables --- */
 373 static GRWLock         type_rw_lock;
 374 static GRecMutex       class_init_rec_mutex;
 375 static guint           static_n_class_cache_funcs = 0;
 376 static ClassCacheFunc *static_class_cache_funcs = NULL;
 377 static guint           static_n_iface_check_funcs = 0;
 378 static IFaceCheckFunc *static_iface_check_funcs = NULL;
 379 static GQuark          static_quark_type_flags = 0;
 380 static GQuark          static_quark_iface_holder = 0;
 381 static GQuark          static_quark_dependants_array = 0;
 382 static guint           type_registration_serial = 0;
 383 
 384 G_GNUC_BEGIN_IGNORE_DEPRECATIONS
 385 GTypeDebugFlags        _g_type_debug_flags = 0;
 386 G_GNUC_END_IGNORE_DEPRECATIONS
 387 
 388 /* --- type nodes --- */
 389 static GHashTable       *static_type_nodes_ht = NULL;
 390 static TypeNode   *static_fundamental_type_nodes[(G_TYPE_FUNDAMENTAL_MAX &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT) + 1] = { NULL, };
 391 static GType     static_fundamental_next = G_TYPE_RESERVED_USER_FIRST;
 392 
 393 static inline TypeNode*
 394 lookup_type_node_I (GType utype)
 395 {
 396   if (utype &gt; G_TYPE_FUNDAMENTAL_MAX)
 397     return (TypeNode*) (utype &amp; ~TYPE_ID_MASK);
 398   else
 399     return static_fundamental_type_nodes[utype &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT];
 400 }
 401 
 402 /**
 403  * g_type_get_type_registration_serial:
 404  *
 405  * Returns an opaque serial number that represents the state of the set
 406  * of registered types. Any time a type is registered this serial changes,
 407  * which means you can cache information based on type lookups (such as
 408  * g_type_from_name()) and know if the cache is still valid at a later
 409  * time by comparing the current serial with the one at the type lookup.
 410  *
 411  * Since: 2.36
 412  *
 413  * Returns: An unsigned int, representing the state of type registrations
 414  */
 415 guint
 416 g_type_get_type_registration_serial (void)
 417 {
 418   return (guint)g_atomic_int_get ((gint *)&amp;type_registration_serial);
 419 }
 420 
 421 static TypeNode*
 422 type_node_any_new_W (TypeNode             *pnode,
 423          GType                 ftype,
 424          const gchar          *name,
 425          GTypePlugin          *plugin,
 426          GTypeFundamentalFlags type_flags)
 427 {
 428   guint n_supers;
 429   GType type;
 430   TypeNode *node;
 431   guint i, node_size = 0;
 432 
 433   n_supers = pnode ? pnode-&gt;n_supers + 1 : 0;
 434 
 435   if (!pnode)
 436     node_size += SIZEOF_FUNDAMENTAL_INFO;       /* fundamental type info */
 437   node_size += SIZEOF_BASE_TYPE_NODE ();        /* TypeNode structure */
 438   node_size += (sizeof (GType) * (1 + n_supers + 1)); /* self + ancestors + (0) for -&gt;supers[] */
 439   node = g_malloc0 (node_size);
 440   if (!pnode)               /* offset fundamental types */
 441     {
 442       node = G_STRUCT_MEMBER_P (node, SIZEOF_FUNDAMENTAL_INFO);
 443       static_fundamental_type_nodes[ftype &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT] = node;
 444       type = ftype;
 445     }
 446   else
 447     type = (GType) node;
 448 
 449   g_assert ((type &amp; TYPE_ID_MASK) == 0);
 450 
 451   node-&gt;n_supers = n_supers;
 452   if (!pnode)
 453     {
 454       node-&gt;supers[0] = type;
 455       node-&gt;supers[1] = 0;
 456 
 457       node-&gt;is_classed = (type_flags &amp; G_TYPE_FLAG_CLASSED) != 0;
 458       node-&gt;is_instantiatable = (type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) != 0;
 459 
 460       if (NODE_IS_IFACE (node))
 461   {
 462           IFACE_NODE_N_PREREQUISITES (node) = 0;
 463     IFACE_NODE_PREREQUISITES (node) = NULL;
 464   }
 465       else
 466   _g_atomic_array_init (CLASSED_NODE_IFACES_ENTRIES (node));
 467     }
 468   else
 469     {
 470       node-&gt;supers[0] = type;
 471       memcpy (node-&gt;supers + 1, pnode-&gt;supers, sizeof (GType) * (1 + pnode-&gt;n_supers + 1));
 472 
 473       node-&gt;is_classed = pnode-&gt;is_classed;
 474       node-&gt;is_instantiatable = pnode-&gt;is_instantiatable;
 475 
 476       if (NODE_IS_IFACE (node))
 477   {
 478     IFACE_NODE_N_PREREQUISITES (node) = 0;
 479     IFACE_NODE_PREREQUISITES (node) = NULL;
 480   }
 481       else
 482   {
 483     guint j;
 484     IFaceEntries *entries;
 485 
 486     entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (pnode),
 487             IFACE_ENTRIES_HEADER_SIZE,
 488             0);
 489     if (entries)
 490       {
 491         for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (entries); j++)
 492     {
 493       entries-&gt;entry[j].vtable = NULL;
 494       entries-&gt;entry[j].init_state = UNINITIALIZED;
 495     }
 496         _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node),
 497               entries);
 498       }
 499   }
 500 
 501       i = pnode-&gt;n_children++;
 502       pnode-&gt;children = g_renew (GType, pnode-&gt;children, pnode-&gt;n_children);
 503       pnode-&gt;children[i] = type;
 504     }
 505 
 506   TRACE(GOBJECT_TYPE_NEW(name, node-&gt;supers[1], type));
 507 
 508   node-&gt;plugin = plugin;
 509   node-&gt;n_children = 0;
 510   node-&gt;children = NULL;
 511   node-&gt;data = NULL;
 512   node-&gt;qname = g_quark_from_string (name);
 513   node-&gt;global_gdata = NULL;
 514   g_hash_table_insert (static_type_nodes_ht,
 515            (gpointer) g_quark_to_string (node-&gt;qname),
 516            (gpointer) type);
 517 
 518   g_atomic_int_inc ((gint *)&amp;type_registration_serial);
 519 
 520   return node;
 521 }
 522 
 523 static inline GTypeFundamentalInfo*
 524 type_node_fundamental_info_I (TypeNode *node)
 525 {
 526   GType ftype = NODE_FUNDAMENTAL_TYPE (node);
 527 
 528   if (ftype != NODE_TYPE (node))
 529     node = lookup_type_node_I (ftype);
 530 
 531   return node ? G_STRUCT_MEMBER_P (node, -SIZEOF_FUNDAMENTAL_INFO) : NULL;
 532 }
 533 
 534 static TypeNode*
 535 type_node_fundamental_new_W (GType                 ftype,
 536            const gchar          *name,
 537            GTypeFundamentalFlags type_flags)
 538 {
 539   GTypeFundamentalInfo *finfo;
 540   TypeNode *node;
 541 
 542   g_assert ((ftype &amp; TYPE_ID_MASK) == 0);
 543   g_assert (ftype &lt;= G_TYPE_FUNDAMENTAL_MAX);
 544 
 545   if (ftype &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT == static_fundamental_next)
 546     static_fundamental_next++;
 547 
 548   type_flags &amp;= TYPE_FUNDAMENTAL_FLAG_MASK;
 549 
 550   node = type_node_any_new_W (NULL, ftype, name, NULL, type_flags);
 551 
 552   finfo = type_node_fundamental_info_I (node);
 553   finfo-&gt;type_flags = type_flags;
 554 
 555   return node;
 556 }
 557 
 558 static TypeNode*
 559 type_node_new_W (TypeNode    *pnode,
 560      const gchar *name,
 561      GTypePlugin *plugin)
 562 
 563 {
 564   g_assert (pnode);
 565   g_assert (pnode-&gt;n_supers &lt; MAX_N_SUPERS);
 566   g_assert (pnode-&gt;n_children &lt; MAX_N_CHILDREN);
 567 
 568   return type_node_any_new_W (pnode, NODE_FUNDAMENTAL_TYPE (pnode), name, plugin, 0);
 569 }
 570 
 571 static inline IFaceEntry*
 572 lookup_iface_entry_I (volatile IFaceEntries *entries,
 573           TypeNode *iface_node)
 574 {
 575   guint8 *offsets;
 576   guint offset_index;
 577   IFaceEntry *check;
 578   int index;
 579   IFaceEntry *entry;
 580 
 581   if (entries == NULL)
 582     return NULL;
 583 
 584   G_ATOMIC_ARRAY_DO_TRANSACTION
 585     (&amp;iface_node-&gt;_prot.offsets, guint8,
 586 
 587      entry = NULL;
 588      offsets = transaction_data;
 589      offset_index = entries-&gt;offset_index;
 590      if (offsets != NULL &amp;&amp;
 591    offset_index &lt; G_ATOMIC_ARRAY_DATA_SIZE(offsets))
 592        {
 593    index = offsets[offset_index];
 594    if (index &gt; 0)
 595      {
 596        /* zero means unset, subtract one to get real index */
 597        index -= 1;
 598 
 599        if (index &lt; IFACE_ENTRIES_N_ENTRIES (entries))
 600          {
 601      check = (IFaceEntry *)&amp;entries-&gt;entry[index];
 602      if (check-&gt;iface_type == NODE_TYPE (iface_node))
 603        entry = check;
 604          }
 605      }
 606        }
 607      );
 608 
 609  return entry;
 610 }
 611 
 612 static inline IFaceEntry*
 613 type_lookup_iface_entry_L (TypeNode *node,
 614          TypeNode *iface_node)
 615 {
 616   if (!NODE_IS_IFACE (iface_node))
 617     return NULL;
 618 
 619   return lookup_iface_entry_I (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node),
 620              iface_node);
 621 }
 622 
 623 
 624 static inline gboolean
 625 type_lookup_iface_vtable_I (TypeNode *node,
 626           TypeNode *iface_node,
 627           gpointer *vtable_ptr)
 628 {
 629   IFaceEntry *entry;
 630   gboolean res;
 631 
 632   if (!NODE_IS_IFACE (iface_node))
 633     {
 634       if (vtable_ptr)
 635   *vtable_ptr = NULL;
 636       return FALSE;
 637     }
 638 
 639   G_ATOMIC_ARRAY_DO_TRANSACTION
 640     (CLASSED_NODE_IFACES_ENTRIES (node), IFaceEntries,
 641 
 642      entry = lookup_iface_entry_I (transaction_data, iface_node);
 643      res = entry != NULL;
 644      if (vtable_ptr)
 645        {
 646    if (entry)
 647      *vtable_ptr = entry-&gt;vtable;
 648    else
 649      *vtable_ptr = NULL;
 650        }
 651      );
 652 
 653   return res;
 654 }
 655 
 656 static inline gboolean
 657 type_lookup_prerequisite_L (TypeNode *iface,
 658           GType     prerequisite_type)
 659 {
 660   if (NODE_IS_IFACE (iface) &amp;&amp; IFACE_NODE_N_PREREQUISITES (iface))
 661     {
 662       GType *prerequisites = IFACE_NODE_PREREQUISITES (iface) - 1;
 663       guint n_prerequisites = IFACE_NODE_N_PREREQUISITES (iface);
 664 
 665       do
 666   {
 667     guint i;
 668     GType *check;
 669 
 670     i = (n_prerequisites + 1) &gt;&gt; 1;
 671     check = prerequisites + i;
 672     if (prerequisite_type == *check)
 673       return TRUE;
 674     else if (prerequisite_type &gt; *check)
 675       {
 676         n_prerequisites -= i;
 677         prerequisites = check;
 678       }
 679     else /* if (prerequisite_type &lt; *check) */
 680       n_prerequisites = i - 1;
 681   }
 682       while (n_prerequisites);
 683     }
 684   return FALSE;
 685 }
 686 
 687 static const gchar*
 688 type_descriptive_name_I (GType type)
 689 {
 690   if (type)
 691     {
 692       TypeNode *node = lookup_type_node_I (type);
 693 
 694       return node ? NODE_NAME (node) : &quot;&lt;unknown&gt;&quot;;
 695     }
 696   else
 697     return &quot;&lt;invalid&gt;&quot;;
 698 }
 699 
 700 
 701 /* --- type consistency checks --- */
 702 static gboolean
 703 check_plugin_U (GTypePlugin *plugin,
 704     gboolean     need_complete_type_info,
 705     gboolean     need_complete_interface_info,
 706     const gchar *type_name)
 707 {
 708   /* G_IS_TYPE_PLUGIN() and G_TYPE_PLUGIN_GET_CLASS() are external calls: _U
 709    */
 710   if (!plugin)
 711     {
 712       g_warning (&quot;plugin handle for type &#39;%s&#39; is NULL&quot;,
 713      type_name);
 714       return FALSE;
 715     }
 716   if (!G_IS_TYPE_PLUGIN (plugin))
 717     {
 718       g_warning (&quot;plugin pointer (%p) for type &#39;%s&#39; is invalid&quot;,
 719      plugin, type_name);
 720       return FALSE;
 721     }
 722   if (need_complete_type_info &amp;&amp; !G_TYPE_PLUGIN_GET_CLASS (plugin)-&gt;complete_type_info)
 723     {
 724       g_warning (&quot;plugin for type &#39;%s&#39; has no complete_type_info() implementation&quot;,
 725      type_name);
 726       return FALSE;
 727     }
 728   if (need_complete_interface_info &amp;&amp; !G_TYPE_PLUGIN_GET_CLASS (plugin)-&gt;complete_interface_info)
 729     {
 730       g_warning (&quot;plugin for type &#39;%s&#39; has no complete_interface_info() implementation&quot;,
 731      type_name);
 732       return FALSE;
 733     }
 734   return TRUE;
 735 }
 736 
 737 static gboolean
 738 check_type_name_I (const gchar *type_name)
 739 {
 740   static const gchar extra_chars[] = &quot;-_+&quot;;
 741   const gchar *p = type_name;
 742   gboolean name_valid;
 743 
 744   if (!type_name[0] || !type_name[1] || !type_name[2])
 745     {
 746       g_warning (&quot;type name &#39;%s&#39; is too short&quot;, type_name);
 747       return FALSE;
 748     }
 749   /* check the first letter */
 750   name_valid = (p[0] &gt;= &#39;A&#39; &amp;&amp; p[0] &lt;= &#39;Z&#39;) || (p[0] &gt;= &#39;a&#39; &amp;&amp; p[0] &lt;= &#39;z&#39;) || p[0] == &#39;_&#39;;
 751   for (p = type_name + 1; *p; p++)
 752     name_valid &amp;= ((p[0] &gt;= &#39;A&#39; &amp;&amp; p[0] &lt;= &#39;Z&#39;) ||
 753        (p[0] &gt;= &#39;a&#39; &amp;&amp; p[0] &lt;= &#39;z&#39;) ||
 754        (p[0] &gt;= &#39;0&#39; &amp;&amp; p[0] &lt;= &#39;9&#39;) ||
 755        strchr (extra_chars, p[0]));
 756   if (!name_valid)
 757     {
 758       g_warning (&quot;type name &#39;%s&#39; contains invalid characters&quot;, type_name);
 759       return FALSE;
 760     }
 761   if (g_type_from_name (type_name))
 762     {
 763       g_warning (&quot;cannot register existing type &#39;%s&#39;&quot;, type_name);
 764       return FALSE;
 765     }
 766 
 767   return TRUE;
 768 }
 769 
 770 static gboolean
 771 check_derivation_I (GType        parent_type,
 772         const gchar *type_name)
 773 {
 774   TypeNode *pnode;
 775   GTypeFundamentalInfo* finfo;
 776 
 777   pnode = lookup_type_node_I (parent_type);
 778   if (!pnode)
 779     {
 780       g_warning (&quot;cannot derive type &#39;%s&#39; from invalid parent type &#39;%s&#39;&quot;,
 781      type_name,
 782      type_descriptive_name_I (parent_type));
 783       return FALSE;
 784     }
 785   finfo = type_node_fundamental_info_I (pnode);
 786   /* ensure flat derivability */
 787   if (!(finfo-&gt;type_flags &amp; G_TYPE_FLAG_DERIVABLE))
 788     {
 789       g_warning (&quot;cannot derive &#39;%s&#39; from non-derivable parent type &#39;%s&#39;&quot;,
 790      type_name,
 791      NODE_NAME (pnode));
 792       return FALSE;
 793     }
 794   /* ensure deep derivability */
 795   if (parent_type != NODE_FUNDAMENTAL_TYPE (pnode) &amp;&amp;
 796       !(finfo-&gt;type_flags &amp; G_TYPE_FLAG_DEEP_DERIVABLE))
 797     {
 798       g_warning (&quot;cannot derive &#39;%s&#39; from non-fundamental parent type &#39;%s&#39;&quot;,
 799      type_name,
 800      NODE_NAME (pnode));
 801       return FALSE;
 802     }
 803 
 804   return TRUE;
 805 }
 806 
 807 static gboolean
 808 check_collect_format_I (const gchar *collect_format)
 809 {
 810   const gchar *p = collect_format;
 811   gchar valid_format[] = { G_VALUE_COLLECT_INT, G_VALUE_COLLECT_LONG,
 812          G_VALUE_COLLECT_INT64, G_VALUE_COLLECT_DOUBLE,
 813          G_VALUE_COLLECT_POINTER, 0 };
 814 
 815   while (*p)
 816     if (!strchr (valid_format, *p++))
 817       return FALSE;
 818   return p - collect_format &lt;= G_VALUE_COLLECT_FORMAT_MAX_LENGTH;
 819 }
 820 
 821 static gboolean
 822 check_value_table_I (const gchar           *type_name,
 823          const GTypeValueTable *value_table)
 824 {
 825   if (!value_table)
 826     return FALSE;
 827   else if (value_table-&gt;value_init == NULL)
 828     {
 829       if (value_table-&gt;value_free || value_table-&gt;value_copy ||
 830     value_table-&gt;value_peek_pointer ||
 831     value_table-&gt;collect_format || value_table-&gt;collect_value ||
 832     value_table-&gt;lcopy_format || value_table-&gt;lcopy_value)
 833   g_warning (&quot;cannot handle uninitializable values of type &#39;%s&#39;&quot;,
 834        type_name);
 835       return FALSE;
 836     }
 837   else /* value_table-&gt;value_init != NULL */
 838     {
 839       if (!value_table-&gt;value_free)
 840   {
 841     /* +++ optional +++
 842      * g_warning (&quot;missing &#39;value_free()&#39; for type &#39;%s&#39;&quot;, type_name);
 843      * return FALSE;
 844      */
 845   }
 846       if (!value_table-&gt;value_copy)
 847   {
 848     g_warning (&quot;missing &#39;value_copy()&#39; for type &#39;%s&#39;&quot;, type_name);
 849     return FALSE;
 850   }
 851       if ((value_table-&gt;collect_format || value_table-&gt;collect_value) &amp;&amp;
 852     (!value_table-&gt;collect_format || !value_table-&gt;collect_value))
 853   {
 854     g_warning (&quot;one of &#39;collect_format&#39; and &#39;collect_value()&#39; is unspecified for type &#39;%s&#39;&quot;,
 855          type_name);
 856     return FALSE;
 857   }
 858       if (value_table-&gt;collect_format &amp;&amp; !check_collect_format_I (value_table-&gt;collect_format))
 859   {
 860     g_warning (&quot;the &#39;%s&#39; specification for type &#39;%s&#39; is too long or invalid&quot;,
 861          &quot;collect_format&quot;,
 862          type_name);
 863     return FALSE;
 864   }
 865       if ((value_table-&gt;lcopy_format || value_table-&gt;lcopy_value) &amp;&amp;
 866     (!value_table-&gt;lcopy_format || !value_table-&gt;lcopy_value))
 867   {
 868     g_warning (&quot;one of &#39;lcopy_format&#39; and &#39;lcopy_value()&#39; is unspecified for type &#39;%s&#39;&quot;,
 869          type_name);
 870     return FALSE;
 871   }
 872       if (value_table-&gt;lcopy_format &amp;&amp; !check_collect_format_I (value_table-&gt;lcopy_format))
 873   {
 874     g_warning (&quot;the &#39;%s&#39; specification for type &#39;%s&#39; is too long or invalid&quot;,
 875          &quot;lcopy_format&quot;,
 876          type_name);
 877     return FALSE;
 878   }
 879     }
 880   return TRUE;
 881 }
 882 
 883 static gboolean
 884 check_type_info_I (TypeNode        *pnode,
 885        GType            ftype,
 886        const gchar     *type_name,
 887        const GTypeInfo *info)
 888 {
 889   GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (lookup_type_node_I (ftype));
 890   gboolean is_interface = ftype == G_TYPE_INTERFACE;
 891 
 892   g_assert (ftype &lt;= G_TYPE_FUNDAMENTAL_MAX &amp;&amp; !(ftype &amp; TYPE_ID_MASK));
 893 
 894   /* check instance members */
 895   if (!(finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) &amp;&amp;
 896       (info-&gt;instance_size || info-&gt;n_preallocs || info-&gt;instance_init))
 897     {
 898       if (pnode)
 899   g_warning (&quot;cannot instantiate &#39;%s&#39;, derived from non-instantiatable parent type &#39;%s&#39;&quot;,
 900        type_name,
 901        NODE_NAME (pnode));
 902       else
 903   g_warning (&quot;cannot instantiate &#39;%s&#39; as non-instantiatable fundamental&quot;,
 904        type_name);
 905       return FALSE;
 906     }
 907   /* check class &amp; interface members */
 908   if (!((finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED) || is_interface) &amp;&amp;
 909       (info-&gt;class_init || info-&gt;class_finalize || info-&gt;class_data ||
 910        info-&gt;class_size || info-&gt;base_init || info-&gt;base_finalize))
 911     {
 912       if (pnode)
 913   g_warning (&quot;cannot create class for &#39;%s&#39;, derived from non-classed parent type &#39;%s&#39;&quot;,
 914        type_name,
 915                    NODE_NAME (pnode));
 916       else
 917   g_warning (&quot;cannot create class for &#39;%s&#39; as non-classed fundamental&quot;,
 918        type_name);
 919       return FALSE;
 920     }
 921   /* check interface size */
 922   if (is_interface &amp;&amp; info-&gt;class_size &lt; sizeof (GTypeInterface))
 923     {
 924       g_warning (&quot;specified interface size for type &#39;%s&#39; is smaller than &#39;GTypeInterface&#39; size&quot;,
 925      type_name);
 926       return FALSE;
 927     }
 928   /* check class size */
 929   if (finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED)
 930     {
 931       if (info-&gt;class_size &lt; sizeof (GTypeClass))
 932   {
 933     g_warning (&quot;specified class size for type &#39;%s&#39; is smaller than &#39;GTypeClass&#39; size&quot;,
 934          type_name);
 935     return FALSE;
 936   }
 937       if (pnode &amp;&amp; info-&gt;class_size &lt; pnode-&gt;data-&gt;class.class_size)
 938   {
 939     g_warning (&quot;specified class size for type &#39;%s&#39; is smaller &quot;
 940          &quot;than the parent type&#39;s &#39;%s&#39; class size&quot;,
 941          type_name,
 942          NODE_NAME (pnode));
 943     return FALSE;
 944   }
 945     }
 946   /* check instance size */
 947   if (finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE)
 948     {
 949       if (info-&gt;instance_size &lt; sizeof (GTypeInstance))
 950   {
 951     g_warning (&quot;specified instance size for type &#39;%s&#39; is smaller than &#39;GTypeInstance&#39; size&quot;,
 952          type_name);
 953     return FALSE;
 954   }
 955       if (pnode &amp;&amp; info-&gt;instance_size &lt; pnode-&gt;data-&gt;instance.instance_size)
 956   {
 957     g_warning (&quot;specified instance size for type &#39;%s&#39; is smaller &quot;
 958          &quot;than the parent type&#39;s &#39;%s&#39; instance size&quot;,
 959          type_name,
 960          NODE_NAME (pnode));
 961     return FALSE;
 962   }
 963     }
 964 
 965   return TRUE;
 966 }
 967 
 968 static TypeNode*
 969 find_conforming_child_type_L (TypeNode *pnode,
 970             TypeNode *iface)
 971 {
 972   TypeNode *node = NULL;
 973   guint i;
 974 
 975   if (type_lookup_iface_entry_L (pnode, iface))
 976     return pnode;
 977 
 978   for (i = 0; i &lt; pnode-&gt;n_children &amp;&amp; !node; i++)
 979     node = find_conforming_child_type_L (lookup_type_node_I (pnode-&gt;children[i]), iface);
 980 
 981   return node;
 982 }
 983 
 984 static gboolean
 985 check_add_interface_L (GType instance_type,
 986            GType iface_type)
 987 {
 988   TypeNode *node = lookup_type_node_I (instance_type);
 989   TypeNode *iface = lookup_type_node_I (iface_type);
 990   IFaceEntry *entry;
 991   TypeNode *tnode;
 992   GType *prerequisites;
 993   guint i;
 994 
 995 
 996   if (!node || !node-&gt;is_instantiatable)
 997     {
 998       g_warning (&quot;cannot add interfaces to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
 999      type_descriptive_name_I (instance_type));
1000       return FALSE;
1001     }
1002   if (!iface || !NODE_IS_IFACE (iface))
1003     {
1004       g_warning (&quot;cannot add invalid (non-interface) type &#39;%s&#39; to type &#39;%s&#39;&quot;,
1005      type_descriptive_name_I (iface_type),
1006      NODE_NAME (node));
1007       return FALSE;
1008     }
1009   if (node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class)
1010     {
1011       g_warning (&quot;attempting to add an interface (%s) to class (%s) after class_init&quot;,
1012                  NODE_NAME (iface), NODE_NAME (node));
1013       return FALSE;
1014     }
1015   tnode = lookup_type_node_I (NODE_PARENT_TYPE (iface));
1016   if (NODE_PARENT_TYPE (tnode) &amp;&amp; !type_lookup_iface_entry_L (node, tnode))
1017     {
1018       /* 2001/7/31:timj: erk, i guess this warning is junk as interface derivation is flat */
1019       g_warning (&quot;cannot add sub-interface &#39;%s&#39; to type &#39;%s&#39; which does not conform to super-interface &#39;%s&#39;&quot;,
1020      NODE_NAME (iface),
1021      NODE_NAME (node),
1022      NODE_NAME (tnode));
1023       return FALSE;
1024     }
1025   /* allow overriding of interface type introduced for parent type */
1026   entry = type_lookup_iface_entry_L (node, iface);
1027   if (entry &amp;&amp; entry-&gt;vtable == NULL &amp;&amp; !type_iface_peek_holder_L (iface, NODE_TYPE (node)))
1028     {
1029       /* ok, we do conform to this interface already, but the interface vtable was not
1030        * yet intialized, and we just conform to the interface because it got added to
1031        * one of our parents. so we allow overriding of holder info here.
1032        */
1033       return TRUE;
1034     }
1035   /* check whether one of our children already conforms (or whether the interface
1036    * got added to this node already)
1037    */
1038   tnode = find_conforming_child_type_L (node, iface);  /* tnode is_a node */
1039   if (tnode)
1040     {
1041       g_warning (&quot;cannot add interface type &#39;%s&#39; to type &#39;%s&#39;, since type &#39;%s&#39; already conforms to interface&quot;,
1042      NODE_NAME (iface),
1043      NODE_NAME (node),
1044      NODE_NAME (tnode));
1045       return FALSE;
1046     }
1047   prerequisites = IFACE_NODE_PREREQUISITES (iface);
1048   for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
1049     {
1050       tnode = lookup_type_node_I (prerequisites[i]);
1051       if (!type_node_is_a_L (node, tnode))
1052   {
1053     g_warning (&quot;cannot add interface type &#39;%s&#39; to type &#39;%s&#39; which does not conform to prerequisite &#39;%s&#39;&quot;,
1054          NODE_NAME (iface),
1055          NODE_NAME (node),
1056          NODE_NAME (tnode));
1057     return FALSE;
1058   }
1059     }
1060   return TRUE;
1061 }
1062 
1063 static gboolean
1064 check_interface_info_I (TypeNode             *iface,
1065       GType                 instance_type,
1066       const GInterfaceInfo *info)
1067 {
1068   if ((info-&gt;interface_finalize || info-&gt;interface_data) &amp;&amp; !info-&gt;interface_init)
1069     {
1070       g_warning (&quot;interface type &#39;%s&#39; for type &#39;%s&#39; comes without initializer&quot;,
1071      NODE_NAME (iface),
1072      type_descriptive_name_I (instance_type));
1073       return FALSE;
1074     }
1075 
1076   return TRUE;
1077 }
1078 
1079 /* --- type info (type node data) --- */
1080 static void
1081 type_data_make_W (TypeNode              *node,
1082       const GTypeInfo       *info,
1083       const GTypeValueTable *value_table)
1084 {
1085   TypeData *data;
1086   GTypeValueTable *vtable = NULL;
1087   guint vtable_size = 0;
1088 
1089   g_assert (node-&gt;data == NULL &amp;&amp; info != NULL);
1090 
1091   if (!value_table)
1092     {
1093       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
1094 
1095       if (pnode)
1096   vtable = pnode-&gt;data-&gt;common.value_table;
1097       else
1098   {
1099     static const GTypeValueTable zero_vtable = { NULL, };
1100 
1101     value_table = &amp;zero_vtable;
1102   }
1103     }
1104   if (value_table)
1105     {
1106       /* need to setup vtable_size since we have to allocate it with data in one chunk */
1107       vtable_size = sizeof (GTypeValueTable);
1108       if (value_table-&gt;collect_format)
1109   vtable_size += strlen (value_table-&gt;collect_format);
1110       if (value_table-&gt;lcopy_format)
1111   vtable_size += strlen (value_table-&gt;lcopy_format);
1112       vtable_size += 2;
1113     }
1114 
1115   if (node-&gt;is_instantiatable) /* careful, is_instantiatable is also is_classed */
1116     {
1117       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
1118 
1119       data = g_malloc0 (sizeof (InstanceData) + vtable_size);
1120 #ifdef GSTREAMER_LITE
1121       if (data == NULL)
1122           return;
1123 #endif // GSTREAMER_LITE
1124       if (vtable_size)
1125   vtable = G_STRUCT_MEMBER_P (data, sizeof (InstanceData));
1126       data-&gt;instance.class_size = info-&gt;class_size;
1127       data-&gt;instance.class_init_base = info-&gt;base_init;
1128       data-&gt;instance.class_finalize_base = info-&gt;base_finalize;
1129       data-&gt;instance.class_init = info-&gt;class_init;
1130       data-&gt;instance.class_finalize = info-&gt;class_finalize;
1131       data-&gt;instance.class_data = info-&gt;class_data;
1132       data-&gt;instance.class = NULL;
1133       data-&gt;instance.init_state = UNINITIALIZED;
1134       data-&gt;instance.instance_size = info-&gt;instance_size;
1135       /* We&#39;ll set the final value for data-&gt;instance.private size
1136        * after the parent class has been initialized
1137        */
1138       data-&gt;instance.private_size = 0;
1139       data-&gt;instance.class_private_size = 0;
1140       if (pnode)
1141         data-&gt;instance.class_private_size = pnode-&gt;data-&gt;instance.class_private_size;
1142       data-&gt;instance.n_preallocs = MIN (info-&gt;n_preallocs, 1024);
1143       data-&gt;instance.instance_init = info-&gt;instance_init;
1144     }
1145   else if (node-&gt;is_classed) /* only classed */
1146     {
1147       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
1148 
1149       data = g_malloc0 (sizeof (ClassData) + vtable_size);
1150       if (vtable_size)
1151   vtable = G_STRUCT_MEMBER_P (data, sizeof (ClassData));
1152       data-&gt;class.class_size = info-&gt;class_size;
1153       data-&gt;class.class_init_base = info-&gt;base_init;
1154       data-&gt;class.class_finalize_base = info-&gt;base_finalize;
1155       data-&gt;class.class_init = info-&gt;class_init;
1156       data-&gt;class.class_finalize = info-&gt;class_finalize;
1157       data-&gt;class.class_data = info-&gt;class_data;
1158       data-&gt;class.class = NULL;
1159       data-&gt;class.class_private_size = 0;
1160       if (pnode)
1161         data-&gt;class.class_private_size = pnode-&gt;data-&gt;class.class_private_size;
1162       data-&gt;class.init_state = UNINITIALIZED;
1163     }
1164   else if (NODE_IS_IFACE (node))
1165     {
1166       data = g_malloc0 (sizeof (IFaceData) + vtable_size);
1167       if (vtable_size)
1168   vtable = G_STRUCT_MEMBER_P (data, sizeof (IFaceData));
1169       data-&gt;iface.vtable_size = info-&gt;class_size;
1170       data-&gt;iface.vtable_init_base = info-&gt;base_init;
1171       data-&gt;iface.vtable_finalize_base = info-&gt;base_finalize;
1172       data-&gt;iface.dflt_init = info-&gt;class_init;
1173       data-&gt;iface.dflt_finalize = info-&gt;class_finalize;
1174       data-&gt;iface.dflt_data = info-&gt;class_data;
1175       data-&gt;iface.dflt_vtable = NULL;
1176     }
1177   else if (NODE_IS_BOXED (node))
1178     {
1179       data = g_malloc0 (sizeof (BoxedData) + vtable_size);
1180       if (vtable_size)
1181   vtable = G_STRUCT_MEMBER_P (data, sizeof (BoxedData));
1182     }
1183   else
1184     {
1185       data = g_malloc0 (sizeof (CommonData) + vtable_size);
1186       if (vtable_size)
1187   vtable = G_STRUCT_MEMBER_P (data, sizeof (CommonData));
1188     }
1189 
1190   node-&gt;data = data;
1191 
1192   if (vtable_size)
1193     {
1194       gchar *p;
1195 
1196       /* we allocate the vtable and its strings together with the type data, so
1197        * children can take over their parent&#39;s vtable pointer, and we don&#39;t
1198        * need to worry freeing it or not when the child data is destroyed
1199        */
1200       *vtable = *value_table;
1201       p = G_STRUCT_MEMBER_P (vtable, sizeof (*vtable));
1202       p[0] = 0;
1203       vtable-&gt;collect_format = p;
1204       if (value_table-&gt;collect_format)
1205   {
1206     strcat (p, value_table-&gt;collect_format);
1207     p += strlen (value_table-&gt;collect_format);
1208   }
1209       p++;
1210       p[0] = 0;
1211       vtable-&gt;lcopy_format = p;
1212       if (value_table-&gt;lcopy_format)
1213   strcat  (p, value_table-&gt;lcopy_format);
1214     }
1215   node-&gt;data-&gt;common.value_table = vtable;
1216   node-&gt;mutatable_check_cache = (node-&gt;data-&gt;common.value_table-&gt;value_init != NULL &amp;&amp;
1217          !((G_TYPE_FLAG_VALUE_ABSTRACT | G_TYPE_FLAG_ABSTRACT) &amp;
1218            GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))));
1219 
1220   g_assert (node-&gt;data-&gt;common.value_table != NULL); /* paranoid */
1221 
1222   g_atomic_int_set ((int *) &amp;node-&gt;ref_count, 1);
1223 }
1224 
1225 static inline void
1226 type_data_ref_Wm (TypeNode *node)
1227 {
1228   if (!node-&gt;data)
1229     {
1230       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
1231       GTypeInfo tmp_info;
1232       GTypeValueTable tmp_value_table;
1233 
1234       g_assert (node-&gt;plugin != NULL);
1235 
1236       if (pnode)
1237   {
1238     type_data_ref_Wm (pnode);
1239     if (node-&gt;data)
1240       INVALID_RECURSION (&quot;g_type_plugin_*&quot;, node-&gt;plugin, NODE_NAME (node));
1241   }
1242 
1243       memset (&amp;tmp_info, 0, sizeof (tmp_info));
1244       memset (&amp;tmp_value_table, 0, sizeof (tmp_value_table));
1245 
1246       G_WRITE_UNLOCK (&amp;type_rw_lock);
1247       g_type_plugin_use (node-&gt;plugin);
1248       g_type_plugin_complete_type_info (node-&gt;plugin, NODE_TYPE (node), &amp;tmp_info, &amp;tmp_value_table);
1249       G_WRITE_LOCK (&amp;type_rw_lock);
1250       if (node-&gt;data)
1251   INVALID_RECURSION (&quot;g_type_plugin_*&quot;, node-&gt;plugin, NODE_NAME (node));
1252 
1253       check_type_info_I (pnode, NODE_FUNDAMENTAL_TYPE (node), NODE_NAME (node), &amp;tmp_info);
1254       type_data_make_W (node, &amp;tmp_info,
1255       check_value_table_I (NODE_NAME (node),
1256                &amp;tmp_value_table) ? &amp;tmp_value_table : NULL);
1257     }
1258   else
1259     {
1260       g_assert (NODE_REFCOUNT (node) &gt; 0);
1261 
1262       g_atomic_int_inc ((int *) &amp;node-&gt;ref_count);
1263     }
1264 }
1265 
1266 static inline gboolean
1267 type_data_ref_U (TypeNode *node)
1268 {
1269   guint current;
1270 
1271   do {
1272     current = NODE_REFCOUNT (node);
1273 
1274     if (current &lt; 1)
1275       return FALSE;
1276   } while (!g_atomic_int_compare_and_exchange ((int *) &amp;node-&gt;ref_count, current, current + 1));
1277 
1278   return TRUE;
1279 }
1280 
1281 static gboolean
1282 iface_node_has_available_offset_L (TypeNode *iface_node,
1283            int offset,
1284            int for_index)
1285 {
1286   guint8 *offsets;
1287 
1288   offsets = G_ATOMIC_ARRAY_GET_LOCKED (&amp;iface_node-&gt;_prot.offsets, guint8);
1289   if (offsets == NULL)
1290     return TRUE;
1291 
1292   if (G_ATOMIC_ARRAY_DATA_SIZE (offsets) &lt;= offset)
1293     return TRUE;
1294 
1295   if (offsets[offset] == 0 ||
1296       offsets[offset] == for_index+1)
1297     return TRUE;
1298 
1299   return FALSE;
1300 }
1301 
1302 static int
1303 find_free_iface_offset_L (IFaceEntries *entries)
1304 {
1305   IFaceEntry *entry;
1306   TypeNode *iface_node;
1307   int offset;
1308   int i;
1309   int n_entries;
1310 
1311   n_entries = IFACE_ENTRIES_N_ENTRIES (entries);
1312   offset = -1;
1313   do
1314     {
1315       offset++;
1316       for (i = 0; i &lt; n_entries; i++)
1317   {
1318     entry = &amp;entries-&gt;entry[i];
1319     iface_node = lookup_type_node_I (entry-&gt;iface_type);
1320 
1321     if (!iface_node_has_available_offset_L (iface_node, offset, i))
1322       break;
1323   }
1324     }
1325   while (i != n_entries);
1326 
1327   return offset;
1328 }
1329 
1330 static void
1331 iface_node_set_offset_L (TypeNode *iface_node,
1332        int offset,
1333        int index)
1334 {
1335   guint8 *offsets, *old_offsets;
1336   int new_size, old_size;
1337   int i;
1338 
1339   old_offsets = G_ATOMIC_ARRAY_GET_LOCKED (&amp;iface_node-&gt;_prot.offsets, guint8);
1340   if (old_offsets == NULL)
1341     old_size = 0;
1342   else
1343     {
1344       old_size = G_ATOMIC_ARRAY_DATA_SIZE (old_offsets);
1345       if (offset &lt; old_size &amp;&amp;
1346     old_offsets[offset] == index + 1)
1347   return; /* Already set to this index, return */
1348     }
1349   new_size = MAX (old_size, offset + 1);
1350 
1351   offsets = _g_atomic_array_copy (&amp;iface_node-&gt;_prot.offsets,
1352           0, new_size - old_size);
1353 
1354   /* Mark new area as unused */
1355   for (i = old_size; i &lt; new_size; i++)
1356     offsets[i] = 0;
1357 
1358   offsets[offset] = index + 1;
1359 
1360   _g_atomic_array_update (&amp;iface_node-&gt;_prot.offsets, offsets);
1361 }
1362 
1363 static void
1364 type_node_add_iface_entry_W (TypeNode   *node,
1365            GType       iface_type,
1366                              IFaceEntry *parent_entry)
1367 {
1368   IFaceEntries *entries;
1369   IFaceEntry *entry;
1370   TypeNode *iface_node;
1371   guint i, j;
1372   int num_entries;
1373 
1374   g_assert (node-&gt;is_instantiatable);
1375 
1376   entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
1377   if (entries != NULL)
1378     {
1379       num_entries = IFACE_ENTRIES_N_ENTRIES (entries);
1380 
1381       g_assert (num_entries &lt; MAX_N_INTERFACES);
1382 
1383       for (i = 0; i &lt; num_entries; i++)
1384   {
1385     entry = &amp;entries-&gt;entry[i];
1386     if (entry-&gt;iface_type == iface_type)
1387       {
1388         /* this can happen in two cases:
1389          * - our parent type already conformed to iface_type and node
1390          *   got its own holder info. here, our children already have
1391          *   entries and NULL vtables, since this will only work for
1392          *   uninitialized classes.
1393          * - an interface type is added to an ancestor after it was
1394          *   added to a child type.
1395          */
1396         if (!parent_entry)
1397     g_assert (entry-&gt;vtable == NULL &amp;&amp; entry-&gt;init_state == UNINITIALIZED);
1398         else
1399     {
1400       /* sick, interface is added to ancestor *after* child type;
1401        * nothing todo, the entry and our children were already setup correctly
1402        */
1403     }
1404         return;
1405       }
1406   }
1407     }
1408 
1409   entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (node),
1410           IFACE_ENTRIES_HEADER_SIZE,
1411           sizeof (IFaceEntry));
1412   num_entries = IFACE_ENTRIES_N_ENTRIES (entries);
1413   i = num_entries - 1;
1414   if (i == 0)
1415     entries-&gt;offset_index = 0;
1416   entries-&gt;entry[i].iface_type = iface_type;
1417   entries-&gt;entry[i].vtable = NULL;
1418   entries-&gt;entry[i].init_state = UNINITIALIZED;
1419 
1420   if (parent_entry)
1421     {
1422       if (node-&gt;data &amp;&amp; node-&gt;data-&gt;class.init_state &gt;= BASE_IFACE_INIT)
1423         {
1424           entries-&gt;entry[i].init_state = INITIALIZED;
1425           entries-&gt;entry[i].vtable = parent_entry-&gt;vtable;
1426         }
1427     }
1428 
1429   /* Update offsets in iface */
1430   iface_node = lookup_type_node_I (iface_type);
1431 
1432   if (iface_node_has_available_offset_L (iface_node,
1433            entries-&gt;offset_index,
1434            i))
1435     {
1436       iface_node_set_offset_L (iface_node,
1437              entries-&gt;offset_index, i);
1438     }
1439   else
1440    {
1441       entries-&gt;offset_index =
1442   find_free_iface_offset_L (entries);
1443       for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (entries); j++)
1444   {
1445     entry = &amp;entries-&gt;entry[j];
1446     iface_node =
1447       lookup_type_node_I (entry-&gt;iface_type);
1448     iface_node_set_offset_L (iface_node,
1449            entries-&gt;offset_index, j);
1450   }
1451     }
1452 
1453   _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node), entries);
1454 
1455   if (parent_entry)
1456     {
1457       for (i = 0; i &lt; node-&gt;n_children; i++)
1458         type_node_add_iface_entry_W (lookup_type_node_I (node-&gt;children[i]), iface_type, &amp;entries-&gt;entry[i]);
1459     }
1460 }
1461 
1462 static void
1463 type_add_interface_Wm (TypeNode             *node,
1464                        TypeNode             *iface,
1465                        const GInterfaceInfo *info,
1466                        GTypePlugin          *plugin)
1467 {
1468   IFaceHolder *iholder = g_new0 (IFaceHolder, 1);
1469   IFaceEntry *entry;
1470   guint i;
1471 
1472   g_assert (node-&gt;is_instantiatable &amp;&amp; NODE_IS_IFACE (iface) &amp;&amp; ((info &amp;&amp; !plugin) || (!info &amp;&amp; plugin)));
1473 
1474   iholder-&gt;next = iface_node_get_holders_L (iface);
1475   iface_node_set_holders_W (iface, iholder);
1476   iholder-&gt;instance_type = NODE_TYPE (node);
1477   iholder-&gt;info = info ? g_memdup (info, sizeof (*info)) : NULL;
1478   iholder-&gt;plugin = plugin;
1479 
1480   /* create an iface entry for this type */
1481   type_node_add_iface_entry_W (node, NODE_TYPE (iface), NULL);
1482 
1483   /* if the class is already (partly) initialized, we may need to base
1484    * initalize and/or initialize the new interface.
1485    */
1486   if (node-&gt;data)
1487     {
1488       InitState class_state = node-&gt;data-&gt;class.init_state;
1489 
1490       if (class_state &gt;= BASE_IFACE_INIT)
1491         type_iface_vtable_base_init_Wm (iface, node);
1492 
1493       if (class_state &gt;= IFACE_INIT)
1494         type_iface_vtable_iface_init_Wm (iface, node);
1495     }
1496 
1497   /* create iface entries for children of this type */
1498   entry = type_lookup_iface_entry_L (node, iface);
1499   for (i = 0; i &lt; node-&gt;n_children; i++)
1500     type_node_add_iface_entry_W (lookup_type_node_I (node-&gt;children[i]), NODE_TYPE (iface), entry);
1501 }
1502 
1503 static void
1504 type_iface_add_prerequisite_W (TypeNode *iface,
1505              TypeNode *prerequisite_node)
1506 {
1507   GType prerequisite_type = NODE_TYPE (prerequisite_node);
1508   GType *prerequisites, *dependants;
1509   guint n_dependants, i;
1510 
1511   g_assert (NODE_IS_IFACE (iface) &amp;&amp;
1512       IFACE_NODE_N_PREREQUISITES (iface) &lt; MAX_N_PREREQUISITES &amp;&amp;
1513       (prerequisite_node-&gt;is_instantiatable || NODE_IS_IFACE (prerequisite_node)));
1514 
1515   prerequisites = IFACE_NODE_PREREQUISITES (iface);
1516   for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
1517     if (prerequisites[i] == prerequisite_type)
1518       return;     /* we already have that prerequisiste */
1519     else if (prerequisites[i] &gt; prerequisite_type)
1520       break;
1521   IFACE_NODE_N_PREREQUISITES (iface) += 1;
1522   IFACE_NODE_PREREQUISITES (iface) = g_renew (GType,
1523                 IFACE_NODE_PREREQUISITES (iface),
1524                 IFACE_NODE_N_PREREQUISITES (iface));
1525   prerequisites = IFACE_NODE_PREREQUISITES (iface);
1526   memmove (prerequisites + i + 1, prerequisites + i,
1527            sizeof (prerequisites[0]) * (IFACE_NODE_N_PREREQUISITES (iface) - i - 1));
1528   prerequisites[i] = prerequisite_type;
1529 
1530   /* we want to get notified when prerequisites get added to prerequisite_node */
1531   if (NODE_IS_IFACE (prerequisite_node))
1532     {
1533       dependants = iface_node_get_dependants_array_L (prerequisite_node);
1534       n_dependants = dependants ? dependants[0] : 0;
1535       n_dependants += 1;
1536       dependants = g_renew (GType, dependants, n_dependants + 1);
1537       dependants[n_dependants] = NODE_TYPE (iface);
1538       dependants[0] = n_dependants;
1539       iface_node_set_dependants_array_W (prerequisite_node, dependants);
1540     }
1541 
1542   /* we need to notify all dependants */
1543   dependants = iface_node_get_dependants_array_L (iface);
1544   n_dependants = dependants ? dependants[0] : 0;
1545   for (i = 1; i &lt;= n_dependants; i++)
1546     type_iface_add_prerequisite_W (lookup_type_node_I (dependants[i]), prerequisite_node);
1547 }
1548 
1549 /**
1550  * g_type_interface_add_prerequisite:
1551  * @interface_type: #GType value of an interface type
1552  * @prerequisite_type: #GType value of an interface or instantiatable type
1553  *
1554  * Adds @prerequisite_type to the list of prerequisites of @interface_type.
1555  * This means that any type implementing @interface_type must also implement
1556  * @prerequisite_type. Prerequisites can be thought of as an alternative to
1557  * interface derivation (which GType doesn&#39;t support). An interface can have
1558  * at most one instantiatable prerequisite type.
1559  */
1560 void
1561 g_type_interface_add_prerequisite (GType interface_type,
1562            GType prerequisite_type)
1563 {
1564   TypeNode *iface, *prerequisite_node;
1565   IFaceHolder *holders;
1566 
1567   g_return_if_fail (G_TYPE_IS_INTERFACE (interface_type));  /* G_TYPE_IS_INTERFACE() is an external call: _U */
1568   g_return_if_fail (!g_type_is_a (interface_type, prerequisite_type));
1569   g_return_if_fail (!g_type_is_a (prerequisite_type, interface_type));
1570 
1571   iface = lookup_type_node_I (interface_type);
1572   prerequisite_node = lookup_type_node_I (prerequisite_type);
1573   if (!iface || !prerequisite_node || !NODE_IS_IFACE (iface))
1574     {
1575       g_warning (&quot;interface type &#39;%s&#39; or prerequisite type &#39;%s&#39; invalid&quot;,
1576      type_descriptive_name_I (interface_type),
1577      type_descriptive_name_I (prerequisite_type));
1578       return;
1579     }
1580   G_WRITE_LOCK (&amp;type_rw_lock);
1581   holders = iface_node_get_holders_L (iface);
1582   if (holders)
1583     {
1584       G_WRITE_UNLOCK (&amp;type_rw_lock);
1585       g_warning (&quot;unable to add prerequisite &#39;%s&#39; to interface &#39;%s&#39; which is already in use for &#39;%s&#39;&quot;,
1586      type_descriptive_name_I (prerequisite_type),
1587      type_descriptive_name_I (interface_type),
1588      type_descriptive_name_I (holders-&gt;instance_type));
1589       return;
1590     }
1591   if (prerequisite_node-&gt;is_instantiatable)
1592     {
1593       guint i;
1594 
1595       /* can have at most one publicly installable instantiatable prerequisite */
1596       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
1597   {
1598     TypeNode *prnode = lookup_type_node_I (IFACE_NODE_PREREQUISITES (iface)[i]);
1599 
1600     if (prnode-&gt;is_instantiatable)
1601       {
1602         G_WRITE_UNLOCK (&amp;type_rw_lock);
1603         g_warning (&quot;adding prerequisite &#39;%s&#39; to interface &#39;%s&#39; conflicts with existing prerequisite &#39;%s&#39;&quot;,
1604        type_descriptive_name_I (prerequisite_type),
1605        type_descriptive_name_I (interface_type),
1606        type_descriptive_name_I (NODE_TYPE (prnode)));
1607         return;
1608       }
1609   }
1610 
1611       for (i = 0; i &lt; prerequisite_node-&gt;n_supers + 1; i++)
1612   type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisite_node-&gt;supers[i]));
1613       G_WRITE_UNLOCK (&amp;type_rw_lock);
1614     }
1615   else if (NODE_IS_IFACE (prerequisite_node))
1616     {
1617       GType *prerequisites;
1618       guint i;
1619 
1620       prerequisites = IFACE_NODE_PREREQUISITES (prerequisite_node);
1621       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (prerequisite_node); i++)
1622   type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisites[i]));
1623       type_iface_add_prerequisite_W (iface, prerequisite_node);
1624       G_WRITE_UNLOCK (&amp;type_rw_lock);
1625     }
1626   else
1627     {
1628       G_WRITE_UNLOCK (&amp;type_rw_lock);
1629       g_warning (&quot;prerequisite &#39;%s&#39; for interface &#39;%s&#39; is neither instantiatable nor interface&quot;,
1630      type_descriptive_name_I (prerequisite_type),
1631      type_descriptive_name_I (interface_type));
1632     }
1633 }
1634 
1635 /**
1636  * g_type_interface_prerequisites:
1637  * @interface_type: an interface type
1638  * @n_prerequisites: (out) (optional): location to return the number
1639  *     of prerequisites, or %NULL
1640  *
1641  * Returns the prerequisites of an interfaces type.
1642  *
1643  * Since: 2.2
1644  *
1645  * Returns: (array length=n_prerequisites) (transfer full): a
1646  *     newly-allocated zero-terminated array of #GType containing
1647  *     the prerequisites of @interface_type
1648  */
1649 GType*
1650 g_type_interface_prerequisites (GType  interface_type,
1651         guint *n_prerequisites)
1652 {
1653   TypeNode *iface;
1654 
1655   g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);
1656 
1657   iface = lookup_type_node_I (interface_type);
1658   if (iface)
1659     {
1660       GType *types;
1661       TypeNode *inode = NULL;
1662       guint i, n = 0;
1663 
1664       G_READ_LOCK (&amp;type_rw_lock);
1665       types = g_new0 (GType, IFACE_NODE_N_PREREQUISITES (iface) + 1);
1666       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
1667   {
1668     GType prerequisite = IFACE_NODE_PREREQUISITES (iface)[i];
1669     TypeNode *node = lookup_type_node_I (prerequisite);
1670     if (node-&gt;is_instantiatable)
1671             {
1672               if (!inode || type_node_is_a_L (node, inode))
1673           inode = node;
1674             }
1675     else
1676       types[n++] = NODE_TYPE (node);
1677   }
1678       if (inode)
1679   types[n++] = NODE_TYPE (inode);
1680 
1681       if (n_prerequisites)
1682   *n_prerequisites = n;
1683       G_READ_UNLOCK (&amp;type_rw_lock);
1684 
1685       return types;
1686     }
1687   else
1688     {
1689       if (n_prerequisites)
1690   *n_prerequisites = 0;
1691 
1692       return NULL;
1693     }
1694 }
1695 
1696 
1697 static IFaceHolder*
1698 type_iface_peek_holder_L (TypeNode *iface,
1699         GType     instance_type)
1700 {
1701   IFaceHolder *iholder;
1702 
1703   g_assert (NODE_IS_IFACE (iface));
1704 
1705   iholder = iface_node_get_holders_L (iface);
1706   while (iholder &amp;&amp; iholder-&gt;instance_type != instance_type)
1707     iholder = iholder-&gt;next;
1708   return iholder;
1709 }
1710 
1711 static IFaceHolder*
1712 type_iface_retrieve_holder_info_Wm (TypeNode *iface,
1713             GType     instance_type,
1714             gboolean  need_info)
1715 {
1716   IFaceHolder *iholder = type_iface_peek_holder_L (iface, instance_type);
1717 
1718   if (iholder &amp;&amp; !iholder-&gt;info &amp;&amp; need_info)
1719     {
1720       GInterfaceInfo tmp_info;
1721 
1722       g_assert (iholder-&gt;plugin != NULL);
1723 
1724       type_data_ref_Wm (iface);
1725       if (iholder-&gt;info)
1726   INVALID_RECURSION (&quot;g_type_plugin_*&quot;, iface-&gt;plugin, NODE_NAME (iface));
1727 
1728       memset (&amp;tmp_info, 0, sizeof (tmp_info));
1729 
1730       G_WRITE_UNLOCK (&amp;type_rw_lock);
1731       g_type_plugin_use (iholder-&gt;plugin);
1732       g_type_plugin_complete_interface_info (iholder-&gt;plugin, instance_type, NODE_TYPE (iface), &amp;tmp_info);
1733       G_WRITE_LOCK (&amp;type_rw_lock);
1734       if (iholder-&gt;info)
1735         INVALID_RECURSION (&quot;g_type_plugin_*&quot;, iholder-&gt;plugin, NODE_NAME (iface));
1736 
1737       check_interface_info_I (iface, instance_type, &amp;tmp_info);
1738       iholder-&gt;info = g_memdup (&amp;tmp_info, sizeof (tmp_info));
1739     }
1740 
1741   return iholder; /* we don&#39;t modify write lock upon returning NULL */
1742 }
1743 
1744 static void
1745 type_iface_blow_holder_info_Wm (TypeNode *iface,
1746         GType     instance_type)
1747 {
1748   IFaceHolder *iholder = iface_node_get_holders_L (iface);
1749 
1750   g_assert (NODE_IS_IFACE (iface));
1751 
1752 #ifdef GSTREAMER_LITE
1753   if (iholder == NULL)
1754       return;
1755 #endif // GSTREAMER_LITE
1756 
1757   while (iholder-&gt;instance_type != instance_type)
1758     iholder = iholder-&gt;next;
1759 
1760   if (iholder-&gt;info &amp;&amp; iholder-&gt;plugin)
1761     {
1762       g_free (iholder-&gt;info);
1763       iholder-&gt;info = NULL;
1764 
1765       G_WRITE_UNLOCK (&amp;type_rw_lock);
1766       g_type_plugin_unuse (iholder-&gt;plugin);
1767       type_data_unref_U (iface, FALSE);
1768       G_WRITE_LOCK (&amp;type_rw_lock);
1769     }
1770 }
1771 
1772 /**
1773  * g_type_create_instance: (skip)
1774  * @type: an instantiatable type to create an instance for
1775  *
1776  * Creates and initializes an instance of @type if @type is valid and
1777  * can be instantiated. The type system only performs basic allocation
1778  * and structure setups for instances: actual instance creation should
1779  * happen through functions supplied by the type&#39;s fundamental type
1780  * implementation.  So use of g_type_create_instance() is reserved for
1781  * implementators of fundamental types only. E.g. instances of the
1782  * #GObject hierarchy should be created via g_object_new() and never
1783  * directly through g_type_create_instance() which doesn&#39;t handle things
1784  * like singleton objects or object construction.
1785  *
1786  * The extended members of the returned instance are guaranteed to be filled
1787  * with zeros.
1788  *
1789  * Note: Do not use this function, unless you&#39;re implementing a
1790  * fundamental type. Also language bindings should not use this
1791  * function, but g_object_new() instead.
1792  *
1793  * Returns: an allocated and initialized instance, subject to further
1794  *     treatment by the fundamental type implementation
1795  */
1796 GTypeInstance*
1797 g_type_create_instance (GType type)
1798 {
1799   TypeNode *node;
1800   GTypeInstance *instance;
1801   GTypeClass *class;
1802   gchar *allocated;
1803   gint private_size;
1804   gint ivar_size;
1805   guint i;
1806 
1807   node = lookup_type_node_I (type);
1808   if (!node || !node-&gt;is_instantiatable)
1809     {
1810       g_error (&quot;cannot create new instance of invalid (non-instantiatable) type &#39;%s&#39;&quot;,
1811      type_descriptive_name_I (type));
1812     }
1813   /* G_TYPE_IS_ABSTRACT() is an external call: _U */
1814   if (!node-&gt;mutatable_check_cache &amp;&amp; G_TYPE_IS_ABSTRACT (type))
1815     {
1816       g_error (&quot;cannot create instance of abstract (non-instantiatable) type &#39;%s&#39;&quot;,
1817      type_descriptive_name_I (type));
1818     }
1819 
1820   class = g_type_class_ref (type);
1821 
1822   /* We allocate the &#39;private&#39; areas before the normal instance data, in
1823    * reverse order.  This allows the private area of a particular class
1824    * to always be at a constant relative address to the instance data.
1825    * If we stored the private data after the instance data this would
1826    * not be the case (since a subclass that added more instance
1827    * variables would push the private data further along).
1828    *
1829    * This presents problems for valgrindability, of course, so we do a
1830    * workaround for that case.  We identify the start of the object to
1831    * valgrind as an allocated block (so that pointers to objects show up
1832    * as &#39;reachable&#39; instead of &#39;possibly lost&#39;).  We then add an extra
1833    * pointer at the end of the object, after all instance data, back to
1834    * the start of the private area so that it is also recorded as
1835    * reachable.  We also add extra private space at the start because
1836    * valgrind doesn&#39;t seem to like us claiming to have allocated an
1837    * address that it saw allocated by malloc().
1838    */
1839   private_size = node-&gt;data-&gt;instance.private_size;
1840   ivar_size = node-&gt;data-&gt;instance.instance_size;
1841 
1842 #ifdef ENABLE_VALGRIND
1843   if (private_size &amp;&amp; RUNNING_ON_VALGRIND)
1844     {
1845       private_size += ALIGN_STRUCT (1);
1846 
1847       /* Allocate one extra pointer size... */
1848       allocated = g_slice_alloc0 (private_size + ivar_size + sizeof (gpointer));
1849       /* ... and point it back to the start of the private data. */
1850       *(gpointer *) (allocated + private_size + ivar_size) = allocated + ALIGN_STRUCT (1);
1851 
1852       /* Tell valgrind that it should treat the object itself as such */
1853       VALGRIND_MALLOCLIKE_BLOCK (allocated + private_size, ivar_size + sizeof (gpointer), 0, TRUE);
1854       VALGRIND_MALLOCLIKE_BLOCK (allocated + ALIGN_STRUCT (1), private_size - ALIGN_STRUCT (1), 0, TRUE);
1855     }
1856   else
1857 #endif
1858     allocated = g_slice_alloc0 (private_size + ivar_size);
1859 
1860   instance = (GTypeInstance *) (allocated + private_size);
1861 
1862   for (i = node-&gt;n_supers; i &gt; 0; i--)
1863     {
1864       TypeNode *pnode;
1865 
1866       pnode = lookup_type_node_I (node-&gt;supers[i]);
1867       if (pnode-&gt;data-&gt;instance.instance_init)
1868   {
1869     instance-&gt;g_class = pnode-&gt;data-&gt;instance.class;
1870     pnode-&gt;data-&gt;instance.instance_init (instance, class);
1871   }
1872     }
1873 
1874   instance-&gt;g_class = class;
1875   if (node-&gt;data-&gt;instance.instance_init)
1876     node-&gt;data-&gt;instance.instance_init (instance, class);
1877 
1878 #ifdef  G_ENABLE_DEBUG
1879   IF_DEBUG (INSTANCE_COUNT)
1880     {
1881       g_atomic_int_inc ((int *) &amp;node-&gt;instance_count);
1882     }
1883 #endif
1884 
1885   TRACE(GOBJECT_OBJECT_NEW(instance, type));
1886 
1887   return instance;
1888 }
1889 
1890 /**
1891  * g_type_free_instance:
1892  * @instance: an instance of a type
1893  *
1894  * Frees an instance of a type, returning it to the instance pool for
1895  * the type, if there is one.
1896  *
1897  * Like g_type_create_instance(), this function is reserved for
1898  * implementors of fundamental types.
1899  */
1900 void
1901 g_type_free_instance (GTypeInstance *instance)
1902 {
1903   TypeNode *node;
1904   GTypeClass *class;
1905   gchar *allocated;
1906   gint private_size;
1907   gint ivar_size;
1908 
1909   g_return_if_fail (instance != NULL &amp;&amp; instance-&gt;g_class != NULL);
1910 
1911   class = instance-&gt;g_class;
1912   node = lookup_type_node_I (class-&gt;g_type);
1913   if (!node || !node-&gt;is_instantiatable || !node-&gt;data || node-&gt;data-&gt;class.class != (gpointer) class)
1914     {
1915       g_warning (&quot;cannot free instance of invalid (non-instantiatable) type &#39;%s&#39;&quot;,
1916      type_descriptive_name_I (class-&gt;g_type));
1917       return;
1918     }
1919   /* G_TYPE_IS_ABSTRACT() is an external call: _U */
1920   if (!node-&gt;mutatable_check_cache &amp;&amp; G_TYPE_IS_ABSTRACT (NODE_TYPE (node)))
1921     {
1922       g_warning (&quot;cannot free instance of abstract (non-instantiatable) type &#39;%s&#39;&quot;,
1923      NODE_NAME (node));
1924       return;
1925     }
1926 
1927   instance-&gt;g_class = NULL;
1928   private_size = node-&gt;data-&gt;instance.private_size;
1929   ivar_size = node-&gt;data-&gt;instance.instance_size;
1930   allocated = ((gchar *) instance) - private_size;
1931 
1932 #ifdef G_ENABLE_DEBUG
1933   memset (allocated, 0xaa, ivar_size + private_size);
1934 #endif
1935 
1936 #ifdef ENABLE_VALGRIND
1937   /* See comment in g_type_create_instance() about what&#39;s going on here.
1938    * We&#39;re basically unwinding what we put into motion there.
1939    */
1940   if (private_size &amp;&amp; RUNNING_ON_VALGRIND)
1941     {
1942       private_size += ALIGN_STRUCT (1);
1943       allocated -= ALIGN_STRUCT (1);
1944 
1945       /* Clear out the extra pointer... */
1946       *(gpointer *) (allocated + private_size + ivar_size) = NULL;
1947       /* ... and ensure we include it in the size we free. */
1948       g_slice_free1 (private_size + ivar_size + sizeof (gpointer), allocated);
1949 
1950       VALGRIND_FREELIKE_BLOCK (allocated + ALIGN_STRUCT (1), 0);
1951       VALGRIND_FREELIKE_BLOCK (instance, 0);
1952     }
1953   else
1954 #endif
1955     g_slice_free1 (private_size + ivar_size, allocated);
1956 
1957 #ifdef  G_ENABLE_DEBUG
1958   IF_DEBUG (INSTANCE_COUNT)
1959     {
1960       g_atomic_int_add ((int *) &amp;node-&gt;instance_count, -1);
1961     }
1962 #endif
1963 
1964   g_type_class_unref (class);
1965 }
1966 
1967 static void
1968 type_iface_ensure_dflt_vtable_Wm (TypeNode *iface)
1969 {
1970   g_assert (iface-&gt;data);
1971 
1972   if (!iface-&gt;data-&gt;iface.dflt_vtable)
1973     {
1974       GTypeInterface *vtable = g_malloc0 (iface-&gt;data-&gt;iface.vtable_size);
1975 #ifdef GSTREAMER_LITE
1976       if (vtable == NULL)
1977           return;
1978 #endif // GSTREAMER_LITE
1979       iface-&gt;data-&gt;iface.dflt_vtable = vtable;
1980       vtable-&gt;g_type = NODE_TYPE (iface);
1981       vtable-&gt;g_instance_type = 0;
1982       if (iface-&gt;data-&gt;iface.vtable_init_base ||
1983           iface-&gt;data-&gt;iface.dflt_init)
1984         {
1985           G_WRITE_UNLOCK (&amp;type_rw_lock);
1986           if (iface-&gt;data-&gt;iface.vtable_init_base)
1987             iface-&gt;data-&gt;iface.vtable_init_base (vtable);
1988           if (iface-&gt;data-&gt;iface.dflt_init)
1989             iface-&gt;data-&gt;iface.dflt_init (vtable, (gpointer) iface-&gt;data-&gt;iface.dflt_data);
1990           G_WRITE_LOCK (&amp;type_rw_lock);
1991         }
1992     }
1993 }
1994 
1995 
1996 /* This is called to allocate and do the first part of initializing
1997  * the interface vtable; type_iface_vtable_iface_init_Wm() does the remainder.
1998  *
1999  * A FALSE return indicates that we didn&#39;t find an init function for
2000  * this type/iface pair, so the vtable from the parent type should
2001  * be used. Note that the write lock is not modified upon a FALSE
2002  * return.
2003  */
2004 static gboolean
2005 type_iface_vtable_base_init_Wm (TypeNode *iface,
2006         TypeNode *node)
2007 {
2008   IFaceEntry *entry;
2009   IFaceHolder *iholder;
2010   GTypeInterface *vtable = NULL;
2011   TypeNode *pnode;
2012 
2013   /* type_iface_retrieve_holder_info_Wm() doesn&#39;t modify write lock for returning NULL */
2014   iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), TRUE);
2015   if (!iholder)
2016     return FALSE; /* we don&#39;t modify write lock upon FALSE */
2017 
2018   type_iface_ensure_dflt_vtable_Wm (iface);
2019 
2020   entry = type_lookup_iface_entry_L (node, iface);
2021 #ifdef GSTREAMER_LITE
2022   if (entry == NULL)
2023     return FALSE;
2024 #endif // GSTREAMER_LITE
2025 
2026   g_assert (iface-&gt;data &amp;&amp; entry &amp;&amp; entry-&gt;vtable == NULL &amp;&amp; iholder &amp;&amp; iholder-&gt;info);
2027 
2028   entry-&gt;init_state = IFACE_INIT;
2029 
2030   pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
2031   if (pnode)  /* want to copy over parent iface contents */
2032     {
2033       IFaceEntry *pentry = type_lookup_iface_entry_L (pnode, iface);
2034 
2035       if (pentry)
2036   vtable = g_memdup (pentry-&gt;vtable, iface-&gt;data-&gt;iface.vtable_size);
2037     }
2038   if (!vtable)
2039     vtable = g_memdup (iface-&gt;data-&gt;iface.dflt_vtable, iface-&gt;data-&gt;iface.vtable_size);
2040   entry-&gt;vtable = vtable;
2041   vtable-&gt;g_type = NODE_TYPE (iface);
2042   vtable-&gt;g_instance_type = NODE_TYPE (node);
2043 
2044   if (iface-&gt;data-&gt;iface.vtable_init_base)
2045     {
2046       G_WRITE_UNLOCK (&amp;type_rw_lock);
2047       iface-&gt;data-&gt;iface.vtable_init_base (vtable);
2048       G_WRITE_LOCK (&amp;type_rw_lock);
2049     }
2050   return TRUE;  /* initialized the vtable */
2051 }
2052 
2053 /* Finishes what type_iface_vtable_base_init_Wm started by
2054  * calling the interface init function.
2055  * this function may only be called for types with their
2056  * own interface holder info, i.e. types for which
2057  * g_type_add_interface*() was called and not children thereof.
2058  */
2059 static void
2060 type_iface_vtable_iface_init_Wm (TypeNode *iface,
2061          TypeNode *node)
2062 {
2063   IFaceEntry *entry = type_lookup_iface_entry_L (node, iface);
2064   IFaceHolder *iholder = type_iface_peek_holder_L (iface, NODE_TYPE (node));
2065   GTypeInterface *vtable = NULL;
2066   guint i;
2067 
2068   /* iholder-&gt;info should have been filled in by type_iface_vtable_base_init_Wm() */
2069   g_assert (iface-&gt;data &amp;&amp; entry &amp;&amp; iholder &amp;&amp; iholder-&gt;info);
2070   g_assert (entry-&gt;init_state == IFACE_INIT); /* assert prior base_init() */
2071 #ifdef GSTREAMER_LITE
2072   if (entry == NULL)
2073     return;
2074 #endif // GSTREAMER_LITE
2075 
2076   entry-&gt;init_state = INITIALIZED;
2077 
2078   vtable = entry-&gt;vtable;
2079 
2080   if (iholder-&gt;info-&gt;interface_init)
2081     {
2082       G_WRITE_UNLOCK (&amp;type_rw_lock);
2083       if (iholder-&gt;info-&gt;interface_init)
2084   iholder-&gt;info-&gt;interface_init (vtable, iholder-&gt;info-&gt;interface_data);
2085       G_WRITE_LOCK (&amp;type_rw_lock);
2086     }
2087 
2088   for (i = 0; i &lt; static_n_iface_check_funcs; i++)
2089     {
2090       GTypeInterfaceCheckFunc check_func = static_iface_check_funcs[i].check_func;
2091       gpointer check_data = static_iface_check_funcs[i].check_data;
2092 
2093       G_WRITE_UNLOCK (&amp;type_rw_lock);
2094       check_func (check_data, (gpointer)vtable);
2095       G_WRITE_LOCK (&amp;type_rw_lock);
2096     }
2097 }
2098 
2099 static gboolean
2100 type_iface_vtable_finalize_Wm (TypeNode       *iface,
2101              TypeNode       *node,
2102              GTypeInterface *vtable)
2103 {
2104   IFaceEntry *entry = type_lookup_iface_entry_L (node, iface);
2105   IFaceHolder *iholder;
2106 
2107   /* type_iface_retrieve_holder_info_Wm() doesn&#39;t modify write lock for returning NULL */
2108   iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), FALSE);
2109   if (!iholder)
2110     return FALSE; /* we don&#39;t modify write lock upon FALSE */
2111 
2112   g_assert (entry &amp;&amp; entry-&gt;vtable == vtable &amp;&amp; iholder-&gt;info);
2113 
2114   entry-&gt;vtable = NULL;
2115   entry-&gt;init_state = UNINITIALIZED;
2116   if (iholder-&gt;info-&gt;interface_finalize || iface-&gt;data-&gt;iface.vtable_finalize_base)
2117     {
2118       G_WRITE_UNLOCK (&amp;type_rw_lock);
2119       if (iholder-&gt;info-&gt;interface_finalize)
2120   iholder-&gt;info-&gt;interface_finalize (vtable, iholder-&gt;info-&gt;interface_data);
2121       if (iface-&gt;data-&gt;iface.vtable_finalize_base)
2122   iface-&gt;data-&gt;iface.vtable_finalize_base (vtable);
2123       G_WRITE_LOCK (&amp;type_rw_lock);
2124     }
2125   vtable-&gt;g_type = 0;
2126   vtable-&gt;g_instance_type = 0;
2127   g_free (vtable);
2128 
2129   type_iface_blow_holder_info_Wm (iface, NODE_TYPE (node));
2130 
2131   return TRUE;  /* write lock modified */
2132 }
2133 
2134 static void
2135 type_class_init_Wm (TypeNode   *node,
2136         GTypeClass *pclass)
2137 {
2138   GSList *slist, *init_slist = NULL;
2139   GTypeClass *class;
2140   IFaceEntries *entries;
2141   IFaceEntry *entry;
2142   TypeNode *bnode, *pnode;
2143   guint i;
2144 
2145   /* Accessing data-&gt;class will work for instantiable types
2146    * too because ClassData is a subset of InstanceData
2147    */
2148   g_assert (node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp;
2149       node-&gt;data-&gt;class.class_size &amp;&amp;
2150       !node-&gt;data-&gt;class.class &amp;&amp;
2151       node-&gt;data-&gt;class.init_state == UNINITIALIZED);
2152   if (node-&gt;data-&gt;class.class_private_size)
2153     class = g_malloc0 (ALIGN_STRUCT (node-&gt;data-&gt;class.class_size) + node-&gt;data-&gt;class.class_private_size);
2154   else
2155     class = g_malloc0 (node-&gt;data-&gt;class.class_size);
2156   node-&gt;data-&gt;class.class = class;
2157   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, BASE_CLASS_INIT);
2158 
2159   if (pclass)
2160     {
2161       TypeNode *pnode = lookup_type_node_I (pclass-&gt;g_type);
2162 
2163       memcpy (class, pclass, pnode-&gt;data-&gt;class.class_size);
2164       memcpy (G_STRUCT_MEMBER_P (class, ALIGN_STRUCT (node-&gt;data-&gt;class.class_size)), G_STRUCT_MEMBER_P (pclass, ALIGN_STRUCT (pnode-&gt;data-&gt;class.class_size)), pnode-&gt;data-&gt;class.class_private_size);
2165 
2166       if (node-&gt;is_instantiatable)
2167   {
2168     /* We need to initialize the private_size here rather than in
2169      * type_data_make_W() since the class init for the parent
2170      * class may have changed pnode-&gt;data-&gt;instance.private_size.
2171      */
2172     node-&gt;data-&gt;instance.private_size = pnode-&gt;data-&gt;instance.private_size;
2173   }
2174     }
2175   class-&gt;g_type = NODE_TYPE (node);
2176 
2177   G_WRITE_UNLOCK (&amp;type_rw_lock);
2178 
2179   /* stack all base class initialization functions, so we
2180    * call them in ascending order.
2181    */
2182   for (bnode = node; bnode; bnode = lookup_type_node_I (NODE_PARENT_TYPE (bnode)))
2183     if (bnode-&gt;data-&gt;class.class_init_base)
2184       init_slist = g_slist_prepend (init_slist, (gpointer) bnode-&gt;data-&gt;class.class_init_base);
2185   for (slist = init_slist; slist; slist = slist-&gt;next)
2186     {
2187       GBaseInitFunc class_init_base = (GBaseInitFunc) slist-&gt;data;
2188 
2189       class_init_base (class);
2190     }
2191   g_slist_free (init_slist);
2192 
2193   G_WRITE_LOCK (&amp;type_rw_lock);
2194 
2195   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, BASE_IFACE_INIT);
2196 
2197   /* Before we initialize the class, base initialize all interfaces, either
2198    * from parent, or through our holder info
2199    */
2200   pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
2201 
2202   i = 0;
2203   while ((entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node)) != NULL &amp;&amp;
2204     i &lt; IFACE_ENTRIES_N_ENTRIES (entries))
2205     {
2206       entry = &amp;entries-&gt;entry[i];
2207       while (i &lt; IFACE_ENTRIES_N_ENTRIES (entries) &amp;&amp;
2208        entry-&gt;init_state == IFACE_INIT)
2209   {
2210     entry++;
2211     i++;
2212   }
2213 
2214       if (i == IFACE_ENTRIES_N_ENTRIES (entries))
2215   break;
2216 
2217       if (!type_iface_vtable_base_init_Wm (lookup_type_node_I (entry-&gt;iface_type), node))
2218   {
2219     guint j;
2220     IFaceEntries *pentries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (pnode);
2221 
2222     /* need to get this interface from parent, type_iface_vtable_base_init_Wm()
2223      * doesn&#39;t modify write lock upon FALSE, so entry is still valid;
2224      */
2225     g_assert (pnode != NULL);
2226 
2227     if (pentries)
2228       for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (pentries); j++)
2229         {
2230     IFaceEntry *pentry = &amp;pentries-&gt;entry[j];
2231 
2232     if (pentry-&gt;iface_type == entry-&gt;iface_type)
2233       {
2234         entry-&gt;vtable = pentry-&gt;vtable;
2235         entry-&gt;init_state = INITIALIZED;
2236         break;
2237       }
2238         }
2239     g_assert (entry-&gt;vtable != NULL);
2240   }
2241 
2242       /* If the write lock was released, additional interface entries might
2243        * have been inserted into CLASSED_NODE_IFACES_ENTRIES (node); they&#39;ll
2244        * be base-initialized when inserted, so we don&#39;t have to worry that
2245        * we might miss them. Uninitialized entries can only be moved higher
2246        * when new ones are inserted.
2247        */
2248       i++;
2249     }
2250 
2251   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, CLASS_INIT);
2252 
2253   G_WRITE_UNLOCK (&amp;type_rw_lock);
2254 
2255   if (node-&gt;data-&gt;class.class_init)
2256     node-&gt;data-&gt;class.class_init (class, (gpointer) node-&gt;data-&gt;class.class_data);
2257 
2258   G_WRITE_LOCK (&amp;type_rw_lock);
2259 
2260   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, IFACE_INIT);
2261 
2262   /* finish initializing the interfaces through our holder info.
2263    * inherited interfaces are already init_state == INITIALIZED, because
2264    * they either got setup in the above base_init loop, or during
2265    * class_init from within type_add_interface_Wm() for this or
2266    * an anchestor type.
2267    */
2268   i = 0;
2269   while ((entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node)) != NULL)
2270     {
2271       entry = &amp;entries-&gt;entry[i];
2272       while (i &lt; IFACE_ENTRIES_N_ENTRIES (entries) &amp;&amp;
2273        entry-&gt;init_state == INITIALIZED)
2274   {
2275     entry++;
2276     i++;
2277   }
2278 
2279       if (i == IFACE_ENTRIES_N_ENTRIES (entries))
2280   break;
2281 
2282       type_iface_vtable_iface_init_Wm (lookup_type_node_I (entry-&gt;iface_type), node);
2283 
2284       /* As in the loop above, additional initialized entries might be inserted
2285        * if the write lock is released, but that&#39;s harmless because the entries
2286        * we need to initialize only move higher in the list.
2287        */
2288       i++;
2289     }
2290 
2291   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, INITIALIZED);
2292 }
2293 
2294 static void
2295 type_data_finalize_class_ifaces_Wm (TypeNode *node)
2296 {
2297   guint i;
2298   IFaceEntries *entries;
2299 
2300   g_assert (node-&gt;is_instantiatable &amp;&amp; node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class &amp;&amp; NODE_REFCOUNT (node) == 0);
2301 
2302  reiterate:
2303   entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
2304   for (i = 0; entries != NULL &amp;&amp; i &lt; IFACE_ENTRIES_N_ENTRIES (entries); i++)
2305     {
2306       IFaceEntry *entry = &amp;entries-&gt;entry[i];
2307       if (entry-&gt;vtable)
2308   {
2309           if (type_iface_vtable_finalize_Wm (lookup_type_node_I (entry-&gt;iface_type), node, entry-&gt;vtable))
2310             {
2311               /* refetch entries, IFACES_ENTRIES might be modified */
2312               goto reiterate;
2313             }
2314           else
2315             {
2316               /* type_iface_vtable_finalize_Wm() doesn&#39;t modify write lock upon FALSE,
2317                * iface vtable came from parent
2318                */
2319               entry-&gt;vtable = NULL;
2320               entry-&gt;init_state = UNINITIALIZED;
2321             }
2322   }
2323     }
2324 }
2325 
2326 static void
2327 type_data_finalize_class_U (TypeNode  *node,
2328           ClassData *cdata)
2329 {
2330   GTypeClass *class = cdata-&gt;class;
2331   TypeNode *bnode;
2332 
2333   g_assert (cdata-&gt;class &amp;&amp; NODE_REFCOUNT (node) == 0);
2334 
2335   if (cdata-&gt;class_finalize)
2336     cdata-&gt;class_finalize (class, (gpointer) cdata-&gt;class_data);
2337 
2338   /* call all base class destruction functions in descending order
2339    */
2340   if (cdata-&gt;class_finalize_base)
2341     cdata-&gt;class_finalize_base (class);
2342   for (bnode = lookup_type_node_I (NODE_PARENT_TYPE (node)); bnode; bnode = lookup_type_node_I (NODE_PARENT_TYPE (bnode)))
2343     if (bnode-&gt;data-&gt;class.class_finalize_base)
2344       bnode-&gt;data-&gt;class.class_finalize_base (class);
2345 
2346   g_free (cdata-&gt;class);
2347 }
2348 
2349 static void
2350 type_data_last_unref_Wm (TypeNode *node,
2351        gboolean  uncached)
2352 {
2353   g_return_if_fail (node != NULL &amp;&amp; node-&gt;plugin != NULL);
2354 
2355   if (!node-&gt;data || NODE_REFCOUNT (node) == 0)
2356     {
2357       g_warning (&quot;cannot drop last reference to unreferenced type &#39;%s&#39;&quot;,
2358      NODE_NAME (node));
2359       return;
2360     }
2361 
2362   /* call class cache hooks */
2363   if (node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class &amp;&amp; static_n_class_cache_funcs &amp;&amp; !uncached)
2364     {
2365       guint i;
2366 
2367       G_WRITE_UNLOCK (&amp;type_rw_lock);
2368       G_READ_LOCK (&amp;type_rw_lock);
2369       for (i = 0; i &lt; static_n_class_cache_funcs; i++)
2370   {
2371     GTypeClassCacheFunc cache_func = static_class_cache_funcs[i].cache_func;
2372     gpointer cache_data = static_class_cache_funcs[i].cache_data;
2373     gboolean need_break;
2374 
2375     G_READ_UNLOCK (&amp;type_rw_lock);
2376     need_break = cache_func (cache_data, node-&gt;data-&gt;class.class);
2377     G_READ_LOCK (&amp;type_rw_lock);
2378     if (!node-&gt;data || NODE_REFCOUNT (node) == 0)
2379       INVALID_RECURSION (&quot;GType class cache function &quot;, cache_func, NODE_NAME (node));
2380     if (need_break)
2381       break;
2382   }
2383       G_READ_UNLOCK (&amp;type_rw_lock);
2384       G_WRITE_LOCK (&amp;type_rw_lock);
2385     }
2386 
2387   /* may have been re-referenced meanwhile */
2388   if (g_atomic_int_dec_and_test ((int *) &amp;node-&gt;ref_count))
2389     {
2390       GType ptype = NODE_PARENT_TYPE (node);
2391       TypeData *tdata;
2392 
2393       if (node-&gt;is_instantiatable)
2394   {
2395     /* destroy node-&gt;data-&gt;instance.mem_chunk */
2396   }
2397 
2398       tdata = node-&gt;data;
2399       if (node-&gt;is_classed &amp;&amp; tdata-&gt;class.class)
2400   {
2401     if (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node) != NULL)
2402       type_data_finalize_class_ifaces_Wm (node);
2403     node-&gt;mutatable_check_cache = FALSE;
2404     node-&gt;data = NULL;
2405     G_WRITE_UNLOCK (&amp;type_rw_lock);
2406     type_data_finalize_class_U (node, &amp;tdata-&gt;class);
2407     G_WRITE_LOCK (&amp;type_rw_lock);
2408   }
2409       else if (NODE_IS_IFACE (node) &amp;&amp; tdata-&gt;iface.dflt_vtable)
2410         {
2411           node-&gt;mutatable_check_cache = FALSE;
2412           node-&gt;data = NULL;
2413           if (tdata-&gt;iface.dflt_finalize || tdata-&gt;iface.vtable_finalize_base)
2414             {
2415               G_WRITE_UNLOCK (&amp;type_rw_lock);
2416               if (tdata-&gt;iface.dflt_finalize)
2417                 tdata-&gt;iface.dflt_finalize (tdata-&gt;iface.dflt_vtable, (gpointer) tdata-&gt;iface.dflt_data);
2418               if (tdata-&gt;iface.vtable_finalize_base)
2419                 tdata-&gt;iface.vtable_finalize_base (tdata-&gt;iface.dflt_vtable);
2420               G_WRITE_LOCK (&amp;type_rw_lock);
2421             }
2422           g_free (tdata-&gt;iface.dflt_vtable);
2423         }
2424       else
2425         {
2426           node-&gt;mutatable_check_cache = FALSE;
2427           node-&gt;data = NULL;
2428         }
2429 
2430       /* freeing tdata-&gt;common.value_table and its contents is taken care of
2431        * by allocating it in one chunk with tdata
2432        */
2433       g_free (tdata);
2434 
2435       G_WRITE_UNLOCK (&amp;type_rw_lock);
2436       g_type_plugin_unuse (node-&gt;plugin);
2437       if (ptype)
2438   type_data_unref_U (lookup_type_node_I (ptype), FALSE);
2439       G_WRITE_LOCK (&amp;type_rw_lock);
2440     }
2441 }
2442 
2443 static inline void
2444 type_data_unref_U (TypeNode *node,
2445                    gboolean  uncached)
2446 {
2447   guint current;
2448 
2449   do {
2450     current = NODE_REFCOUNT (node);
2451 
2452     if (current &lt;= 1)
2453     {
2454       if (!node-&gt;plugin)
2455   {
2456     g_warning (&quot;static type &#39;%s&#39; unreferenced too often&quot;,
2457          NODE_NAME (node));
2458     return;
2459   }
2460       else
2461         {
2462           /* This is the last reference of a type from a plugin.  We are
2463            * experimentally disabling support for unloading type
2464            * plugins, so don&#39;t allow the last ref to drop.
2465            */
2466           return;
2467         }
2468 
2469       g_assert (current &gt; 0);
2470 
2471       g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
2472       G_WRITE_LOCK (&amp;type_rw_lock);
2473       type_data_last_unref_Wm (node, uncached);
2474       G_WRITE_UNLOCK (&amp;type_rw_lock);
2475       g_rec_mutex_unlock (&amp;class_init_rec_mutex);
2476       return;
2477     }
2478   } while (!g_atomic_int_compare_and_exchange ((int *) &amp;node-&gt;ref_count, current, current - 1));
2479 }
2480 
2481 /**
2482  * g_type_add_class_cache_func: (skip)
2483  * @cache_data: data to be passed to @cache_func
2484  * @cache_func: a #GTypeClassCacheFunc
2485  *
2486  * Adds a #GTypeClassCacheFunc to be called before the reference count of a
2487  * class goes from one to zero. This can be used to prevent premature class
2488  * destruction. All installed #GTypeClassCacheFunc functions will be chained
2489  * until one of them returns %TRUE. The functions have to check the class id
2490  * passed in to figure whether they actually want to cache the class of this
2491  * type, since all classes are routed through the same #GTypeClassCacheFunc
2492  * chain.
2493  */
2494 void
2495 g_type_add_class_cache_func (gpointer            cache_data,
2496            GTypeClassCacheFunc cache_func)
2497 {
2498   guint i;
2499 
2500   g_return_if_fail (cache_func != NULL);
2501 
2502   G_WRITE_LOCK (&amp;type_rw_lock);
2503   i = static_n_class_cache_funcs++;
2504   static_class_cache_funcs = g_renew (ClassCacheFunc, static_class_cache_funcs, static_n_class_cache_funcs);
2505   static_class_cache_funcs[i].cache_data = cache_data;
2506   static_class_cache_funcs[i].cache_func = cache_func;
2507   G_WRITE_UNLOCK (&amp;type_rw_lock);
2508 }
2509 
2510 /**
2511  * g_type_remove_class_cache_func: (skip)
2512  * @cache_data: data that was given when adding @cache_func
2513  * @cache_func: a #GTypeClassCacheFunc
2514  *
2515  * Removes a previously installed #GTypeClassCacheFunc. The cache
2516  * maintained by @cache_func has to be empty when calling
2517  * g_type_remove_class_cache_func() to avoid leaks.
2518  */
2519 void
2520 g_type_remove_class_cache_func (gpointer            cache_data,
2521         GTypeClassCacheFunc cache_func)
2522 {
2523   gboolean found_it = FALSE;
2524   guint i;
2525 
2526   g_return_if_fail (cache_func != NULL);
2527 
2528   G_WRITE_LOCK (&amp;type_rw_lock);
2529   for (i = 0; i &lt; static_n_class_cache_funcs; i++)
2530     if (static_class_cache_funcs[i].cache_data == cache_data &amp;&amp;
2531   static_class_cache_funcs[i].cache_func == cache_func)
2532       {
2533   static_n_class_cache_funcs--;
2534   memmove (static_class_cache_funcs + i,
2535                  static_class_cache_funcs + i + 1,
2536                  sizeof (static_class_cache_funcs[0]) * (static_n_class_cache_funcs - i));
2537   static_class_cache_funcs = g_renew (ClassCacheFunc, static_class_cache_funcs, static_n_class_cache_funcs);
2538   found_it = TRUE;
2539   break;
2540       }
2541   G_WRITE_UNLOCK (&amp;type_rw_lock);
2542 
2543   if (!found_it)
2544     g_warning (G_STRLOC &quot;: cannot remove unregistered class cache func %p with data %p&quot;,
2545          cache_func, cache_data);
2546 }
2547 
2548 
2549 /**
2550  * g_type_add_interface_check: (skip)
2551  * @check_data: data to pass to @check_func
2552  * @check_func: function to be called after each interface
2553  *     is initialized
2554  *
2555  * Adds a function to be called after an interface vtable is
2556  * initialized for any class (i.e. after the @interface_init
2557  * member of #GInterfaceInfo has been called).
2558  *
2559  * This function is useful when you want to check an invariant
2560  * that depends on the interfaces of a class. For instance, the
2561  * implementation of #GObject uses this facility to check that an
2562  * object implements all of the properties that are defined on its
2563  * interfaces.
2564  *
2565  * Since: 2.4
2566  */
2567 void
2568 g_type_add_interface_check (gpointer              check_data,
2569           GTypeInterfaceCheckFunc check_func)
2570 {
2571   guint i;
2572 
2573   g_return_if_fail (check_func != NULL);
2574 
2575   G_WRITE_LOCK (&amp;type_rw_lock);
2576   i = static_n_iface_check_funcs++;
2577   static_iface_check_funcs = g_renew (IFaceCheckFunc, static_iface_check_funcs, static_n_iface_check_funcs);
2578   static_iface_check_funcs[i].check_data = check_data;
2579   static_iface_check_funcs[i].check_func = check_func;
2580   G_WRITE_UNLOCK (&amp;type_rw_lock);
2581 }
2582 
2583 /**
2584  * g_type_remove_interface_check: (skip)
2585  * @check_data: callback data passed to g_type_add_interface_check()
2586  * @check_func: callback function passed to g_type_add_interface_check()
2587  *
2588  * Removes an interface check function added with
2589  * g_type_add_interface_check().
2590  *
2591  * Since: 2.4
2592  */
2593 void
2594 g_type_remove_interface_check (gpointer                check_data,
2595              GTypeInterfaceCheckFunc check_func)
2596 {
2597   gboolean found_it = FALSE;
2598   guint i;
2599 
2600   g_return_if_fail (check_func != NULL);
2601 
2602   G_WRITE_LOCK (&amp;type_rw_lock);
2603   for (i = 0; i &lt; static_n_iface_check_funcs; i++)
2604     if (static_iface_check_funcs[i].check_data == check_data &amp;&amp;
2605   static_iface_check_funcs[i].check_func == check_func)
2606       {
2607   static_n_iface_check_funcs--;
2608   memmove (static_iface_check_funcs + i,
2609                  static_iface_check_funcs + i + 1,
2610                  sizeof (static_iface_check_funcs[0]) * (static_n_iface_check_funcs - i));
2611   static_iface_check_funcs = g_renew (IFaceCheckFunc, static_iface_check_funcs, static_n_iface_check_funcs);
2612   found_it = TRUE;
2613   break;
2614       }
2615   G_WRITE_UNLOCK (&amp;type_rw_lock);
2616 
2617   if (!found_it)
2618     g_warning (G_STRLOC &quot;: cannot remove unregistered class check func %p with data %p&quot;,
2619          check_func, check_data);
2620 }
2621 
2622 /* --- type registration --- */
2623 /**
2624  * g_type_register_fundamental:
2625  * @type_id: a predefined type identifier
2626  * @type_name: 0-terminated string used as the name of the new type
2627  * @info: #GTypeInfo structure for this type
2628  * @finfo: #GTypeFundamentalInfo structure for this type
2629  * @flags: bitwise combination of #GTypeFlags values
2630  *
2631  * Registers @type_id as the predefined identifier and @type_name as the
2632  * name of a fundamental type. If @type_id is already registered, or a
2633  * type named @type_name is already registered, the behaviour is undefined.
2634  * The type system uses the information contained in the #GTypeInfo structure
2635  * pointed to by @info and the #GTypeFundamentalInfo structure pointed to by
2636  * @finfo to manage the type and its instances. The value of @flags determines
2637  * additional characteristics of the fundamental type.
2638  *
2639  * Returns: the predefined type identifier
2640  */
2641 GType
2642 g_type_register_fundamental (GType                       type_id,
2643            const gchar                *type_name,
2644            const GTypeInfo            *info,
2645            const GTypeFundamentalInfo *finfo,
2646            GTypeFlags      flags)
2647 {
2648   TypeNode *node;
2649 
2650   g_assert_type_system_initialized ();
2651   g_return_val_if_fail (type_id &gt; 0, 0);
2652   g_return_val_if_fail (type_name != NULL, 0);
2653   g_return_val_if_fail (info != NULL, 0);
2654   g_return_val_if_fail (finfo != NULL, 0);
2655 
2656   if (!check_type_name_I (type_name))
2657     return 0;
2658   if ((type_id &amp; TYPE_ID_MASK) ||
2659       type_id &gt; G_TYPE_FUNDAMENTAL_MAX)
2660     {
2661       g_warning (&quot;attempt to register fundamental type &#39;%s&#39; with invalid type id (%&quot; G_GSIZE_FORMAT &quot;)&quot;,
2662      type_name,
2663      type_id);
2664       return 0;
2665     }
2666   if ((finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) &amp;&amp;
2667       !(finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED))
2668     {
2669       g_warning (&quot;cannot register instantiatable fundamental type &#39;%s&#39; as non-classed&quot;,
2670      type_name);
2671       return 0;
2672     }
2673   if (lookup_type_node_I (type_id))
2674     {
2675       g_warning (&quot;cannot register existing fundamental type &#39;%s&#39; (as &#39;%s&#39;)&quot;,
2676      type_descriptive_name_I (type_id),
2677      type_name);
2678       return 0;
2679     }
2680 
2681   G_WRITE_LOCK (&amp;type_rw_lock);
2682   node = type_node_fundamental_new_W (type_id, type_name, finfo-&gt;type_flags);
2683   type_add_flags_W (node, flags);
2684 
2685   if (check_type_info_I (NULL, NODE_FUNDAMENTAL_TYPE (node), type_name, info))
2686     type_data_make_W (node, info,
2687           check_value_table_I (type_name, info-&gt;value_table) ? info-&gt;value_table : NULL);
2688   G_WRITE_UNLOCK (&amp;type_rw_lock);
2689 
2690   return NODE_TYPE (node);
2691 }
2692 
2693 /**
2694  * g_type_register_static_simple: (skip)
2695  * @parent_type: type from which this type will be derived
2696  * @type_name: 0-terminated string used as the name of the new type
2697  * @class_size: size of the class structure (see #GTypeInfo)
2698  * @class_init: location of the class initialization function (see #GTypeInfo)
2699  * @instance_size: size of the instance structure (see #GTypeInfo)
2700  * @instance_init: location of the instance initialization function (see #GTypeInfo)
2701  * @flags: bitwise combination of #GTypeFlags values
2702  *
2703  * Registers @type_name as the name of a new static type derived from
2704  * @parent_type.  The value of @flags determines the nature (e.g.
2705  * abstract or not) of the type. It works by filling a #GTypeInfo
2706  * struct and calling g_type_register_static().
2707  *
2708  * Since: 2.12
2709  *
2710  * Returns: the new type identifier
2711  */
2712 GType
2713 g_type_register_static_simple (GType             parent_type,
2714              const gchar      *type_name,
2715              guint             class_size,
2716              GClassInitFunc    class_init,
2717              guint             instance_size,
2718              GInstanceInitFunc instance_init,
2719              GTypeFlags  flags)
2720 {
2721   GTypeInfo info;
2722 
2723   /* Instances are not allowed to be larger than this. If you have a big
2724    * fixed-length array or something, point to it instead.
2725    */
2726   g_return_val_if_fail (class_size &lt;= G_MAXUINT16, G_TYPE_INVALID);
2727   g_return_val_if_fail (instance_size &lt;= G_MAXUINT16, G_TYPE_INVALID);
2728 
2729   info.class_size = class_size;
2730   info.base_init = NULL;
2731   info.base_finalize = NULL;
2732   info.class_init = class_init;
2733   info.class_finalize = NULL;
2734   info.class_data = NULL;
2735   info.instance_size = instance_size;
2736   info.n_preallocs = 0;
2737   info.instance_init = instance_init;
2738   info.value_table = NULL;
2739 
2740   return g_type_register_static (parent_type, type_name, &amp;info, flags);
2741 }
2742 
2743 /**
2744  * g_type_register_static:
2745  * @parent_type: type from which this type will be derived
2746  * @type_name: 0-terminated string used as the name of the new type
2747  * @info: #GTypeInfo structure for this type
2748  * @flags: bitwise combination of #GTypeFlags values
2749  *
2750  * Registers @type_name as the name of a new static type derived from
2751  * @parent_type. The type system uses the information contained in the
2752  * #GTypeInfo structure pointed to by @info to manage the type and its
2753  * instances (if not abstract). The value of @flags determines the nature
2754  * (e.g. abstract or not) of the type.
2755  *
2756  * Returns: the new type identifier
2757  */
2758 GType
2759 g_type_register_static (GType            parent_type,
2760       const gchar     *type_name,
2761       const GTypeInfo *info,
2762       GTypeFlags   flags)
2763 {
2764   TypeNode *pnode, *node;
2765   GType type = 0;
2766 
2767   g_assert_type_system_initialized ();
2768   g_return_val_if_fail (parent_type &gt; 0, 0);
2769   g_return_val_if_fail (type_name != NULL, 0);
2770   g_return_val_if_fail (info != NULL, 0);
2771 
2772   if (!check_type_name_I (type_name) ||
2773       !check_derivation_I (parent_type, type_name))
2774     return 0;
2775   if (info-&gt;class_finalize)
2776     {
2777       g_warning (&quot;class finalizer specified for static type &#39;%s&#39;&quot;,
2778      type_name);
2779       return 0;
2780     }
2781 
2782   pnode = lookup_type_node_I (parent_type);
2783   G_WRITE_LOCK (&amp;type_rw_lock);
2784   type_data_ref_Wm (pnode);
2785   if (check_type_info_I (pnode, NODE_FUNDAMENTAL_TYPE (pnode), type_name, info))
2786     {
2787       node = type_node_new_W (pnode, type_name, NULL);
2788       type_add_flags_W (node, flags);
2789       type = NODE_TYPE (node);
2790       type_data_make_W (node, info,
2791       check_value_table_I (type_name, info-&gt;value_table) ? info-&gt;value_table : NULL);
2792     }
2793   G_WRITE_UNLOCK (&amp;type_rw_lock);
2794 
2795   return type;
2796 }
2797 
2798 /**
2799  * g_type_register_dynamic:
2800  * @parent_type: type from which this type will be derived
2801  * @type_name: 0-terminated string used as the name of the new type
2802  * @plugin: #GTypePlugin structure to retrieve the #GTypeInfo from
2803  * @flags: bitwise combination of #GTypeFlags values
2804  *
2805  * Registers @type_name as the name of a new dynamic type derived from
2806  * @parent_type.  The type system uses the information contained in the
2807  * #GTypePlugin structure pointed to by @plugin to manage the type and its
2808  * instances (if not abstract).  The value of @flags determines the nature
2809  * (e.g. abstract or not) of the type.
2810  *
2811  * Returns: the new type identifier or #G_TYPE_INVALID if registration failed
2812  */
2813 GType
2814 g_type_register_dynamic (GType        parent_type,
2815        const gchar *type_name,
2816        GTypePlugin *plugin,
2817        GTypeFlags   flags)
2818 {
2819   TypeNode *pnode, *node;
2820   GType type;
2821 
2822   g_assert_type_system_initialized ();
2823   g_return_val_if_fail (parent_type &gt; 0, 0);
2824   g_return_val_if_fail (type_name != NULL, 0);
2825   g_return_val_if_fail (plugin != NULL, 0);
2826 
2827   if (!check_type_name_I (type_name) ||
2828       !check_derivation_I (parent_type, type_name) ||
2829       !check_plugin_U (plugin, TRUE, FALSE, type_name))
2830     return 0;
2831 
2832   G_WRITE_LOCK (&amp;type_rw_lock);
2833   pnode = lookup_type_node_I (parent_type);
2834   node = type_node_new_W (pnode, type_name, plugin);
2835   type_add_flags_W (node, flags);
2836   type = NODE_TYPE (node);
2837   G_WRITE_UNLOCK (&amp;type_rw_lock);
2838 
2839   return type;
2840 }
2841 
2842 /**
2843  * g_type_add_interface_static:
2844  * @instance_type: #GType value of an instantiable type
2845  * @interface_type: #GType value of an interface type
2846  * @info: #GInterfaceInfo structure for this
2847  *        (@instance_type, @interface_type) combination
2848  *
2849  * Adds the static @interface_type to @instantiable_type.
2850  * The information contained in the #GInterfaceInfo structure
2851  * pointed to by @info is used to manage the relationship.
2852  */
2853 void
2854 g_type_add_interface_static (GType                 instance_type,
2855            GType                 interface_type,
2856            const GInterfaceInfo *info)
2857 {
2858   /* G_TYPE_IS_INSTANTIATABLE() is an external call: _U */
2859   g_return_if_fail (G_TYPE_IS_INSTANTIATABLE (instance_type));
2860   g_return_if_fail (g_type_parent (interface_type) == G_TYPE_INTERFACE);
2861 
2862   /* we only need to lock class_init_rec_mutex if instance_type already has its
2863    * class initialized, however this function is rarely enough called to take
2864    * the simple route and always acquire class_init_rec_mutex.
2865    */
2866   g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
2867   G_WRITE_LOCK (&amp;type_rw_lock);
2868   if (check_add_interface_L (instance_type, interface_type))
2869     {
2870       TypeNode *node = lookup_type_node_I (instance_type);
2871       TypeNode *iface = lookup_type_node_I (interface_type);
2872       if (check_interface_info_I (iface, NODE_TYPE (node), info))
2873         type_add_interface_Wm (node, iface, info, NULL);
2874     }
2875   G_WRITE_UNLOCK (&amp;type_rw_lock);
2876   g_rec_mutex_unlock (&amp;class_init_rec_mutex);
2877 }
2878 
2879 /**
2880  * g_type_add_interface_dynamic:
2881  * @instance_type: #GType value of an instantiable type
2882  * @interface_type: #GType value of an interface type
2883  * @plugin: #GTypePlugin structure to retrieve the #GInterfaceInfo from
2884  *
2885  * Adds the dynamic @interface_type to @instantiable_type. The information
2886  * contained in the #GTypePlugin structure pointed to by @plugin
2887  * is used to manage the relationship.
2888  */
2889 void
2890 g_type_add_interface_dynamic (GType        instance_type,
2891             GType        interface_type,
2892             GTypePlugin *plugin)
2893 {
2894   TypeNode *node;
2895   /* G_TYPE_IS_INSTANTIATABLE() is an external call: _U */
2896   g_return_if_fail (G_TYPE_IS_INSTANTIATABLE (instance_type));
2897   g_return_if_fail (g_type_parent (interface_type) == G_TYPE_INTERFACE);
2898 
2899   node = lookup_type_node_I (instance_type);
2900   if (!check_plugin_U (plugin, FALSE, TRUE, NODE_NAME (node)))
2901     return;
2902 
2903   /* see comment in g_type_add_interface_static() about class_init_rec_mutex */
2904   g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
2905   G_WRITE_LOCK (&amp;type_rw_lock);
2906   if (check_add_interface_L (instance_type, interface_type))
2907     {
2908       TypeNode *iface = lookup_type_node_I (interface_type);
2909       type_add_interface_Wm (node, iface, NULL, plugin);
2910     }
2911   G_WRITE_UNLOCK (&amp;type_rw_lock);
2912   g_rec_mutex_unlock (&amp;class_init_rec_mutex);
2913 }
2914 
2915 
2916 /* --- public API functions --- */
2917 /**
2918  * g_type_class_ref:
2919  * @type: type ID of a classed type
2920  *
2921  * Increments the reference count of the class structure belonging to
2922  * @type. This function will demand-create the class if it doesn&#39;t
2923  * exist already.
2924  *
2925  * Returns: (type GObject.TypeClass) (transfer none): the #GTypeClass
2926  *     structure for the given type ID
2927  */
2928 gpointer
2929 g_type_class_ref (GType type)
2930 {
2931   TypeNode *node;
2932   GType ptype;
2933   gboolean holds_ref;
2934   GTypeClass *pclass;
2935 
2936   /* optimize for common code path */
2937   node = lookup_type_node_I (type);
2938   if (!node || !node-&gt;is_classed)
2939     {
2940       g_warning (&quot;cannot retrieve class for invalid (unclassed) type &#39;%s&#39;&quot;,
2941      type_descriptive_name_I (type));
2942       return NULL;
2943     }
2944 
2945   if (G_LIKELY (type_data_ref_U (node)))
2946     {
2947       if (G_LIKELY (g_atomic_int_get (&amp;node-&gt;data-&gt;class.init_state) == INITIALIZED))
2948         return node-&gt;data-&gt;class.class;
2949       holds_ref = TRUE;
2950     }
2951   else
2952     holds_ref = FALSE;
2953 
2954   /* here, we either have node-&gt;data-&gt;class.class == NULL, or a recursive
2955    * call to g_type_class_ref() with a partly initialized class, or
2956    * node-&gt;data-&gt;class.init_state == INITIALIZED, because any
2957    * concurrently running initialization was guarded by class_init_rec_mutex.
2958    */
2959   g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
2960 
2961   /* we need an initialized parent class for initializing derived classes */
2962   ptype = NODE_PARENT_TYPE (node);
2963   pclass = ptype ? g_type_class_ref (ptype) : NULL;
2964 
2965   G_WRITE_LOCK (&amp;type_rw_lock);
2966 
2967   if (!holds_ref)
2968     type_data_ref_Wm (node);
2969 
2970   if (!node-&gt;data-&gt;class.class) /* class uninitialized */
2971     type_class_init_Wm (node, pclass);
2972 
2973   G_WRITE_UNLOCK (&amp;type_rw_lock);
2974 
2975   if (pclass)
2976     g_type_class_unref (pclass);
2977 
2978   g_rec_mutex_unlock (&amp;class_init_rec_mutex);
2979 
2980   return node-&gt;data-&gt;class.class;
2981 }
2982 
2983 /**
2984  * g_type_class_unref:
2985  * @g_class: (type GObject.TypeClass): a #GTypeClass structure to unref
2986  *
2987  * Decrements the reference count of the class structure being passed in.
2988  * Once the last reference count of a class has been released, classes
2989  * may be finalized by the type system, so further dereferencing of a
2990  * class pointer after g_type_class_unref() are invalid.
2991  */
2992 void
2993 g_type_class_unref (gpointer g_class)
2994 {
2995   TypeNode *node;
2996   GTypeClass *class = g_class;
2997 
2998   g_return_if_fail (g_class != NULL);
2999 
3000   node = lookup_type_node_I (class-&gt;g_type);
3001   if (node &amp;&amp; node-&gt;is_classed &amp;&amp; NODE_REFCOUNT (node))
3002     type_data_unref_U (node, FALSE);
3003   else
3004     g_warning (&quot;cannot unreference class of invalid (unclassed) type &#39;%s&#39;&quot;,
3005          type_descriptive_name_I (class-&gt;g_type));
3006 }
3007 
3008 /**
3009  * g_type_class_unref_uncached: (skip)
3010  * @g_class: (type GObject.TypeClass): a #GTypeClass structure to unref
3011  *
3012  * A variant of g_type_class_unref() for use in #GTypeClassCacheFunc
3013  * implementations. It unreferences a class without consulting the chain
3014  * of #GTypeClassCacheFuncs, avoiding the recursion which would occur
3015  * otherwise.
3016  */
3017 void
3018 g_type_class_unref_uncached (gpointer g_class)
3019 {
3020   TypeNode *node;
3021   GTypeClass *class = g_class;
3022 
3023   g_return_if_fail (g_class != NULL);
3024 
3025   node = lookup_type_node_I (class-&gt;g_type);
3026   if (node &amp;&amp; node-&gt;is_classed &amp;&amp; NODE_REFCOUNT (node))
3027     type_data_unref_U (node, TRUE);
3028   else
3029     g_warning (&quot;cannot unreference class of invalid (unclassed) type &#39;%s&#39;&quot;,
3030          type_descriptive_name_I (class-&gt;g_type));
3031 }
3032 
3033 /**
3034  * g_type_class_peek:
3035  * @type: type ID of a classed type
3036  *
3037  * This function is essentially the same as g_type_class_ref(),
3038  * except that the classes reference count isn&#39;t incremented.
3039  * As a consequence, this function may return %NULL if the class
3040  * of the type passed in does not currently exist (hasn&#39;t been
3041  * referenced before).
3042  *
3043  * Returns: (type GObject.TypeClass) (transfer none): the #GTypeClass
3044  *     structure for the given type ID or %NULL if the class does not
3045  *     currently exist
3046  */
3047 gpointer
3048 g_type_class_peek (GType type)
3049 {
3050   TypeNode *node;
3051   gpointer class;
3052 
3053   node = lookup_type_node_I (type);
3054   if (node &amp;&amp; node-&gt;is_classed &amp;&amp; NODE_REFCOUNT (node) &amp;&amp;
3055       g_atomic_int_get (&amp;node-&gt;data-&gt;class.init_state) == INITIALIZED)
3056     /* ref_count _may_ be 0 */
3057     class = node-&gt;data-&gt;class.class;
3058   else
3059     class = NULL;
3060 
3061   return class;
3062 }
3063 
3064 /**
3065  * g_type_class_peek_static:
3066  * @type: type ID of a classed type
3067  *
3068  * A more efficient version of g_type_class_peek() which works only for
3069  * static types.
3070  *
3071  * Returns: (type GObject.TypeClass) (transfer none): the #GTypeClass
3072  *     structure for the given type ID or %NULL if the class does not
3073  *     currently exist or is dynamically loaded
3074  *
3075  * Since: 2.4
3076  */
3077 gpointer
3078 g_type_class_peek_static (GType type)
3079 {
3080   TypeNode *node;
3081   gpointer class;
3082 
3083   node = lookup_type_node_I (type);
3084   if (node &amp;&amp; node-&gt;is_classed &amp;&amp; NODE_REFCOUNT (node) &amp;&amp;
3085       /* peek only static types: */ node-&gt;plugin == NULL &amp;&amp;
3086       g_atomic_int_get (&amp;node-&gt;data-&gt;class.init_state) == INITIALIZED)
3087     /* ref_count _may_ be 0 */
3088     class = node-&gt;data-&gt;class.class;
3089   else
3090     class = NULL;
3091 
3092   return class;
3093 }
3094 
3095 /**
3096  * g_type_class_peek_parent:
3097  * @g_class: (type GObject.TypeClass): the #GTypeClass structure to
3098  *     retrieve the parent class for
3099  *
3100  * This is a convenience function often needed in class initializers.
3101  * It returns the class structure of the immediate parent type of the
3102  * class passed in.  Since derived classes hold a reference count on
3103  * their parent classes as long as they are instantiated, the returned
3104  * class will always exist.
3105  *
3106  * This function is essentially equivalent to:
3107  * g_type_class_peek (g_type_parent (G_TYPE_FROM_CLASS (g_class)))
3108  *
3109  * Returns: (type GObject.TypeClass) (transfer none): the parent class
3110  *     of @g_class
3111  */
3112 gpointer
3113 g_type_class_peek_parent (gpointer g_class)
3114 {
3115   TypeNode *node;
3116   gpointer class = NULL;
3117 
3118   g_return_val_if_fail (g_class != NULL, NULL);
3119 
3120   node = lookup_type_node_I (G_TYPE_FROM_CLASS (g_class));
3121   /* We used to acquire a read lock here. That is not necessary, since
3122    * parent-&gt;data-&gt;class.class is constant as long as the derived class
3123    * exists.
3124    */
3125   if (node &amp;&amp; node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp; NODE_PARENT_TYPE (node))
3126     {
3127       node = lookup_type_node_I (NODE_PARENT_TYPE (node));
3128       class = node-&gt;data-&gt;class.class;
3129     }
3130   else if (NODE_PARENT_TYPE (node))
3131     g_warning (G_STRLOC &quot;: invalid class pointer &#39;%p&#39;&quot;, g_class);
3132 
3133   return class;
3134 }
3135 
3136 /**
3137  * g_type_interface_peek:
3138  * @instance_class: (type GObject.TypeClass): a #GTypeClass structure
3139  * @iface_type: an interface ID which this class conforms to
3140  *
3141  * Returns the #GTypeInterface structure of an interface to which the
3142  * passed in class conforms.
3143  *
3144  * Returns: (type GObject.TypeInterface) (transfer none): the #GTypeInterface
3145  *     structure of @iface_type if implemented by @instance_class, %NULL
3146  *     otherwise
3147  */
3148 gpointer
3149 g_type_interface_peek (gpointer instance_class,
3150            GType    iface_type)
3151 {
3152   TypeNode *node;
3153   TypeNode *iface;
3154   gpointer vtable = NULL;
3155   GTypeClass *class = instance_class;
3156 
3157   g_return_val_if_fail (instance_class != NULL, NULL);
3158 
3159   node = lookup_type_node_I (class-&gt;g_type);
3160   iface = lookup_type_node_I (iface_type);
3161   if (node &amp;&amp; node-&gt;is_instantiatable &amp;&amp; iface)
3162     type_lookup_iface_vtable_I (node, iface, &amp;vtable);
3163   else
3164     g_warning (G_STRLOC &quot;: invalid class pointer &#39;%p&#39;&quot;, class);
3165 
3166   return vtable;
3167 }
3168 
3169 /**
3170  * g_type_interface_peek_parent:
3171  * @g_iface: (type GObject.TypeInterface): a #GTypeInterface structure
3172  *
3173  * Returns the corresponding #GTypeInterface structure of the parent type
3174  * of the instance type to which @g_iface belongs. This is useful when
3175  * deriving the implementation of an interface from the parent type and
3176  * then possibly overriding some methods.
3177  *
3178  * Returns: (transfer none) (type GObject.TypeInterface): the
3179  *     corresponding #GTypeInterface structure of the parent type of the
3180  *     instance type to which @g_iface belongs, or %NULL if the parent
3181  *     type doesn&#39;t conform to the interface
3182  */
3183 gpointer
3184 g_type_interface_peek_parent (gpointer g_iface)
3185 {
3186   TypeNode *node;
3187   TypeNode *iface;
3188   gpointer vtable = NULL;
3189   GTypeInterface *iface_class = g_iface;
3190 
3191   g_return_val_if_fail (g_iface != NULL, NULL);
3192 
3193   iface = lookup_type_node_I (iface_class-&gt;g_type);
3194   node = lookup_type_node_I (iface_class-&gt;g_instance_type);
3195   if (node)
3196     node = lookup_type_node_I (NODE_PARENT_TYPE (node));
3197   if (node &amp;&amp; node-&gt;is_instantiatable &amp;&amp; iface)
3198     type_lookup_iface_vtable_I (node, iface, &amp;vtable);
3199   else if (node)
3200     g_warning (G_STRLOC &quot;: invalid interface pointer &#39;%p&#39;&quot;, g_iface);
3201 
3202   return vtable;
3203 }
3204 
3205 /**
3206  * g_type_default_interface_ref:
3207  * @g_type: an interface type
3208  *
3209  * Increments the reference count for the interface type @g_type,
3210  * and returns the default interface vtable for the type.
3211  *
3212  * If the type is not currently in use, then the default vtable
3213  * for the type will be created and initalized by calling
3214  * the base interface init and default vtable init functions for
3215  * the type (the @base_init and @class_init members of #GTypeInfo).
3216  * Calling g_type_default_interface_ref() is useful when you
3217  * want to make sure that signals and properties for an interface
3218  * have been installed.
3219  *
3220  * Since: 2.4
3221  *
3222  * Returns: (type GObject.TypeInterface) (transfer none): the default
3223  *     vtable for the interface; call g_type_default_interface_unref()
3224  *     when you are done using the interface.
3225  */
3226 gpointer
3227 g_type_default_interface_ref (GType g_type)
3228 {
3229   TypeNode *node;
3230   gpointer dflt_vtable;
3231 
3232   G_WRITE_LOCK (&amp;type_rw_lock);
3233 
3234   node = lookup_type_node_I (g_type);
3235   if (!node || !NODE_IS_IFACE (node) ||
3236       (node-&gt;data &amp;&amp; NODE_REFCOUNT (node) == 0))
3237     {
3238       G_WRITE_UNLOCK (&amp;type_rw_lock);
3239       g_warning (&quot;cannot retrieve default vtable for invalid or non-interface type &#39;%s&#39;&quot;,
3240      type_descriptive_name_I (g_type));
3241       return NULL;
3242     }
3243 
3244   if (!node-&gt;data || !node-&gt;data-&gt;iface.dflt_vtable)
3245     {
3246       G_WRITE_UNLOCK (&amp;type_rw_lock);
3247       g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
3248       G_WRITE_LOCK (&amp;type_rw_lock);
3249       node = lookup_type_node_I (g_type);
3250       type_data_ref_Wm (node);
3251       type_iface_ensure_dflt_vtable_Wm (node);
3252       g_rec_mutex_unlock (&amp;class_init_rec_mutex);
3253     }
3254   else
3255     type_data_ref_Wm (node); /* ref_count &gt;= 1 already */
3256 
3257   dflt_vtable = node-&gt;data-&gt;iface.dflt_vtable;
3258   G_WRITE_UNLOCK (&amp;type_rw_lock);
3259 
3260   return dflt_vtable;
3261 }
3262 
3263 /**
3264  * g_type_default_interface_peek:
3265  * @g_type: an interface type
3266  *
3267  * If the interface type @g_type is currently in use, returns its
3268  * default interface vtable.
3269  *
3270  * Since: 2.4
3271  *
3272  * Returns: (type GObject.TypeInterface) (transfer none): the default
3273  *     vtable for the interface, or %NULL if the type is not currently
3274  *     in use
3275  */
3276 gpointer
3277 g_type_default_interface_peek (GType g_type)
3278 {
3279   TypeNode *node;
3280   gpointer vtable;
3281 
3282   node = lookup_type_node_I (g_type);
3283   if (node &amp;&amp; NODE_IS_IFACE (node) &amp;&amp; NODE_REFCOUNT (node))
3284     vtable = node-&gt;data-&gt;iface.dflt_vtable;
3285   else
3286     vtable = NULL;
3287 
3288   return vtable;
3289 }
3290 
3291 /**
3292  * g_type_default_interface_unref:
3293  * @g_iface: (type GObject.TypeInterface): the default vtable
3294  *     structure for an interface, as returned by g_type_default_interface_ref()
3295  *
3296  * Decrements the reference count for the type corresponding to the
3297  * interface default vtable @g_iface. If the type is dynamic, then
3298  * when no one is using the interface and all references have
3299  * been released, the finalize function for the interface&#39;s default
3300  * vtable (the @class_finalize member of #GTypeInfo) will be called.
3301  *
3302  * Since: 2.4
3303  */
3304 void
3305 g_type_default_interface_unref (gpointer g_iface)
3306 {
3307   TypeNode *node;
3308   GTypeInterface *vtable = g_iface;
3309 
3310   g_return_if_fail (g_iface != NULL);
3311 
3312   node = lookup_type_node_I (vtable-&gt;g_type);
3313   if (node &amp;&amp; NODE_IS_IFACE (node))
3314     type_data_unref_U (node, FALSE);
3315   else
3316     g_warning (&quot;cannot unreference invalid interface default vtable for &#39;%s&#39;&quot;,
3317          type_descriptive_name_I (vtable-&gt;g_type));
3318 }
3319 
3320 /**
3321  * g_type_name:
3322  * @type: type to return name for
3323  *
3324  * Get the unique name that is assigned to a type ID.  Note that this
3325  * function (like all other GType API) cannot cope with invalid type
3326  * IDs. %G_TYPE_INVALID may be passed to this function, as may be any
3327  * other validly registered type ID, but randomized type IDs should
3328  * not be passed in and will most likely lead to a crash.
3329  *
3330  * Returns: static type name or %NULL
3331  */
3332 const gchar *
3333 g_type_name (GType type)
3334 {
3335   TypeNode *node;
3336 
3337   g_assert_type_system_initialized ();
3338 
3339   node = lookup_type_node_I (type);
3340 
3341   return node ? NODE_NAME (node) : NULL;
3342 }
3343 
3344 /**
3345  * g_type_qname:
3346  * @type: type to return quark of type name for
3347  *
3348  * Get the corresponding quark of the type IDs name.
3349  *
3350  * Returns: the type names quark or 0
3351  */
3352 GQuark
3353 g_type_qname (GType type)
3354 {
3355   TypeNode *node;
3356 
3357   node = lookup_type_node_I (type);
3358 
3359   return node ? node-&gt;qname : 0;
3360 }
3361 
3362 /**
3363  * g_type_from_name:
3364  * @name: type name to look up
3365  *
3366  * Look up the type ID from a given type name, returning 0 if no type
3367  * has been registered under this name (this is the preferred method
3368  * to find out by name whether a specific type has been registered
3369  * yet).
3370  *
3371  * Returns: corresponding type ID or 0
3372  */
3373 GType
3374 g_type_from_name (const gchar *name)
3375 {
3376   GType type = 0;
3377 
3378   g_return_val_if_fail (name != NULL, 0);
3379 
3380   G_READ_LOCK (&amp;type_rw_lock);
3381   type = (GType) g_hash_table_lookup (static_type_nodes_ht, name);
3382   G_READ_UNLOCK (&amp;type_rw_lock);
3383 
3384   return type;
3385 }
3386 
3387 /**
3388  * g_type_parent:
3389  * @type: the derived type
3390  *
3391  * Return the direct parent type of the passed in type. If the passed
3392  * in type has no parent, i.e. is a fundamental type, 0 is returned.
3393  *
3394  * Returns: the parent type
3395  */
3396 GType
3397 g_type_parent (GType type)
3398 {
3399   TypeNode *node;
3400 
3401   node = lookup_type_node_I (type);
3402 
3403   return node ? NODE_PARENT_TYPE (node) : 0;
3404 }
3405 
3406 /**
3407  * g_type_depth:
3408  * @type: a #GType
3409  *
3410  * Returns the length of the ancestry of the passed in type. This
3411  * includes the type itself, so that e.g. a fundamental type has depth 1.
3412  *
3413  * Returns: the depth of @type
3414  */
3415 guint
3416 g_type_depth (GType type)
3417 {
3418   TypeNode *node;
3419 
3420   node = lookup_type_node_I (type);
3421 
3422   return node ? node-&gt;n_supers + 1 : 0;
3423 }
3424 
3425 /**
3426  * g_type_next_base:
3427  * @leaf_type: descendant of @root_type and the type to be returned
3428  * @root_type: immediate parent of the returned type
3429  *
3430  * Given a @leaf_type and a @root_type which is contained in its
3431  * anchestry, return the type that @root_type is the immediate parent
3432  * of. In other words, this function determines the type that is
3433  * derived directly from @root_type which is also a base class of
3434  * @leaf_type.  Given a root type and a leaf type, this function can
3435  * be used to determine the types and order in which the leaf type is
3436  * descended from the root type.
3437  *
3438  * Returns: immediate child of @root_type and anchestor of @leaf_type
3439  */
3440 GType
3441 g_type_next_base (GType type,
3442       GType base_type)
3443 {
3444   GType atype = 0;
3445   TypeNode *node;
3446 
3447   node = lookup_type_node_I (type);
3448   if (node)
3449     {
3450       TypeNode *base_node = lookup_type_node_I (base_type);
3451 
3452       if (base_node &amp;&amp; base_node-&gt;n_supers &lt; node-&gt;n_supers)
3453   {
3454     guint n = node-&gt;n_supers - base_node-&gt;n_supers;
3455 
3456     if (node-&gt;supers[n] == base_type)
3457       atype = node-&gt;supers[n - 1];
3458   }
3459     }
3460 
3461   return atype;
3462 }
3463 
3464 static inline gboolean
3465 type_node_check_conformities_UorL (TypeNode *node,
3466            TypeNode *iface_node,
3467            /*        support_inheritance */
3468            gboolean  support_interfaces,
3469            gboolean  support_prerequisites,
3470            gboolean  have_lock)
3471 {
3472   gboolean match;
3473 
3474   if (/* support_inheritance &amp;&amp; */
3475       NODE_IS_ANCESTOR (iface_node, node))
3476     return TRUE;
3477 
3478   support_interfaces = support_interfaces &amp;&amp; node-&gt;is_instantiatable &amp;&amp; NODE_IS_IFACE (iface_node);
3479   support_prerequisites = support_prerequisites &amp;&amp; NODE_IS_IFACE (node);
3480   match = FALSE;
3481   if (support_interfaces)
3482     {
3483       if (have_lock)
3484   {
3485     if (type_lookup_iface_entry_L (node, iface_node))
3486       match = TRUE;
3487   }
3488       else
3489   {
3490     if (type_lookup_iface_vtable_I (node, iface_node, NULL))
3491       match = TRUE;
3492   }
3493     }
3494   if (!match &amp;&amp;
3495       support_prerequisites)
3496     {
3497       if (!have_lock)
3498   G_READ_LOCK (&amp;type_rw_lock);
3499       if (support_prerequisites &amp;&amp; type_lookup_prerequisite_L (node, NODE_TYPE (iface_node)))
3500   match = TRUE;
3501       if (!have_lock)
3502   G_READ_UNLOCK (&amp;type_rw_lock);
3503     }
3504   return match;
3505 }
3506 
3507 static gboolean
3508 type_node_is_a_L (TypeNode *node,
3509       TypeNode *iface_node)
3510 {
3511   return type_node_check_conformities_UorL (node, iface_node, TRUE, TRUE, TRUE);
3512 }
3513 
3514 static inline gboolean
3515 type_node_conforms_to_U (TypeNode *node,
3516        TypeNode *iface_node,
3517        gboolean  support_interfaces,
3518        gboolean  support_prerequisites)
3519 {
3520   return type_node_check_conformities_UorL (node, iface_node, support_interfaces, support_prerequisites, FALSE);
3521 }
3522 
3523 /**
3524  * g_type_is_a:
3525  * @type: type to check anchestry for
3526  * @is_a_type: possible anchestor of @type or interface that @type
3527  *     could conform to
3528  *
3529  * If @is_a_type is a derivable type, check whether @type is a
3530  * descendant of @is_a_type. If @is_a_type is an interface, check
3531  * whether @type conforms to it.
3532  *
3533  * Returns: %TRUE if @type is a @is_a_type
3534  */
3535 gboolean
3536 g_type_is_a (GType type,
3537        GType iface_type)
3538 {
3539   TypeNode *node, *iface_node;
3540   gboolean is_a;
3541 
3542   if (type == iface_type)
3543     return TRUE;
3544 
3545   node = lookup_type_node_I (type);
3546   iface_node = lookup_type_node_I (iface_type);
3547   is_a = node &amp;&amp; iface_node &amp;&amp; type_node_conforms_to_U (node, iface_node, TRUE, TRUE);
3548 
3549   return is_a;
3550 }
3551 
3552 /**
3553  * g_type_children:
3554  * @type: the parent type
3555  * @n_children: (out) (optional): location to store the length of
3556  *     the returned array, or %NULL
3557  *
3558  * Return a newly allocated and 0-terminated array of type IDs, listing
3559  * the child types of @type.
3560  *
3561  * Returns: (array length=n_children) (transfer full): Newly allocated
3562  *     and 0-terminated array of child types, free with g_free()
3563  */
3564 GType*
3565 g_type_children (GType  type,
3566      guint *n_children)
3567 {
3568   TypeNode *node;
3569 
3570   node = lookup_type_node_I (type);
3571   if (node)
3572     {
3573       GType *children;
3574 
3575       G_READ_LOCK (&amp;type_rw_lock);  /* -&gt;children is relocatable */
3576       children = g_new (GType, node-&gt;n_children + 1);
3577       if (node-&gt;n_children != 0)
3578         memcpy (children, node-&gt;children, sizeof (GType) * node-&gt;n_children);
3579       children[node-&gt;n_children] = 0;
3580 
3581       if (n_children)
3582   *n_children = node-&gt;n_children;
3583       G_READ_UNLOCK (&amp;type_rw_lock);
3584 
3585       return children;
3586     }
3587   else
3588     {
3589       if (n_children)
3590   *n_children = 0;
3591 
3592       return NULL;
3593     }
3594 }
3595 
3596 /**
3597  * g_type_interfaces:
3598  * @type: the type to list interface types for
3599  * @n_interfaces: (out) (optional): location to store the length of
3600  *     the returned array, or %NULL
3601  *
3602  * Return a newly allocated and 0-terminated array of type IDs, listing
3603  * the interface types that @type conforms to.
3604  *
3605  * Returns: (array length=n_interfaces) (transfer full): Newly allocated
3606  *     and 0-terminated array of interface types, free with g_free()
3607  */
3608 GType*
3609 g_type_interfaces (GType  type,
3610        guint *n_interfaces)
3611 {
3612   TypeNode *node;
3613 
3614   node = lookup_type_node_I (type);
3615   if (node &amp;&amp; node-&gt;is_instantiatable)
3616     {
3617       IFaceEntries *entries;
3618       GType *ifaces;
3619       guint i;
3620 
3621       G_READ_LOCK (&amp;type_rw_lock);
3622       entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
3623       if (entries)
3624   {
3625     ifaces = g_new (GType, IFACE_ENTRIES_N_ENTRIES (entries) + 1);
3626     for (i = 0; i &lt; IFACE_ENTRIES_N_ENTRIES (entries); i++)
3627       ifaces[i] = entries-&gt;entry[i].iface_type;
3628   }
3629       else
3630   {
3631     ifaces = g_new (GType, 1);
3632     i = 0;
3633   }
3634       ifaces[i] = 0;
3635 
3636       if (n_interfaces)
3637   *n_interfaces = i;
3638       G_READ_UNLOCK (&amp;type_rw_lock);
3639 
3640       return ifaces;
3641     }
3642   else
3643     {
3644       if (n_interfaces)
3645   *n_interfaces = 0;
3646 
3647       return NULL;
3648     }
3649 }
3650 
3651 typedef struct _QData QData;
3652 struct _GData
3653 {
3654   guint  n_qdatas;
3655   QData *qdatas;
3656 };
3657 struct _QData
3658 {
3659   GQuark   quark;
3660   gpointer data;
3661 };
3662 
3663 static inline gpointer
3664 type_get_qdata_L (TypeNode *node,
3665       GQuark    quark)
3666 {
3667   GData *gdata = node-&gt;global_gdata;
3668 
3669   if (quark &amp;&amp; gdata &amp;&amp; gdata-&gt;n_qdatas)
3670     {
3671       QData *qdatas = gdata-&gt;qdatas - 1;
3672       guint n_qdatas = gdata-&gt;n_qdatas;
3673 
3674       do
3675   {
3676     guint i;
3677     QData *check;
3678 
3679     i = (n_qdatas + 1) / 2;
3680     check = qdatas + i;
3681     if (quark == check-&gt;quark)
3682       return check-&gt;data;
3683     else if (quark &gt; check-&gt;quark)
3684       {
3685         n_qdatas -= i;
3686         qdatas = check;
3687       }
3688     else /* if (quark &lt; check-&gt;quark) */
3689       n_qdatas = i - 1;
3690   }
3691       while (n_qdatas);
3692     }
3693   return NULL;
3694 }
3695 
3696 /**
3697  * g_type_get_qdata:
3698  * @type: a #GType
3699  * @quark: a #GQuark id to identify the data
3700  *
3701  * Obtains data which has previously been attached to @type
3702  * with g_type_set_qdata().
3703  *
3704  * Note that this does not take subtyping into account; data
3705  * attached to one type with g_type_set_qdata() cannot
3706  * be retrieved from a subtype using g_type_get_qdata().
3707  *
3708  * Returns: (transfer none): the data, or %NULL if no data was found
3709  */
3710 gpointer
3711 g_type_get_qdata (GType  type,
3712       GQuark quark)
3713 {
3714   TypeNode *node;
3715   gpointer data;
3716 
3717   node = lookup_type_node_I (type);
3718   if (node)
3719     {
3720       G_READ_LOCK (&amp;type_rw_lock);
3721       data = type_get_qdata_L (node, quark);
3722       G_READ_UNLOCK (&amp;type_rw_lock);
3723     }
3724   else
3725     {
3726       g_return_val_if_fail (node != NULL, NULL);
3727       data = NULL;
3728     }
3729   return data;
3730 }
3731 
3732 static inline void
3733 type_set_qdata_W (TypeNode *node,
3734       GQuark    quark,
3735       gpointer  data)
3736 {
3737   GData *gdata;
3738   QData *qdata;
3739   guint i;
3740 
3741   /* setup qdata list if necessary */
3742   if (!node-&gt;global_gdata)
3743     node-&gt;global_gdata = g_new0 (GData, 1);
3744   gdata = node-&gt;global_gdata;
3745 
3746   /* try resetting old data */
3747   qdata = gdata-&gt;qdatas;
3748   for (i = 0; i &lt; gdata-&gt;n_qdatas; i++)
3749     if (qdata[i].quark == quark)
3750       {
3751   qdata[i].data = data;
3752   return;
3753       }
3754 
3755   /* add new entry */
3756   gdata-&gt;n_qdatas++;
3757   gdata-&gt;qdatas = g_renew (QData, gdata-&gt;qdatas, gdata-&gt;n_qdatas);
3758   qdata = gdata-&gt;qdatas;
3759   for (i = 0; i &lt; gdata-&gt;n_qdatas - 1; i++)
3760     if (qdata[i].quark &gt; quark)
3761       break;
3762   memmove (qdata + i + 1, qdata + i, sizeof (qdata[0]) * (gdata-&gt;n_qdatas - i - 1));
3763   qdata[i].quark = quark;
3764   qdata[i].data = data;
3765 }
3766 
3767 /**
3768  * g_type_set_qdata:
3769  * @type: a #GType
3770  * @quark: a #GQuark id to identify the data
3771  * @data: the data
3772  *
3773  * Attaches arbitrary data to a type.
3774  */
3775 void
3776 g_type_set_qdata (GType    type,
3777       GQuark   quark,
3778       gpointer data)
3779 {
3780   TypeNode *node;
3781 
3782   g_return_if_fail (quark != 0);
3783 
3784   node = lookup_type_node_I (type);
3785   if (node)
3786     {
3787       G_WRITE_LOCK (&amp;type_rw_lock);
3788       type_set_qdata_W (node, quark, data);
3789       G_WRITE_UNLOCK (&amp;type_rw_lock);
3790     }
3791   else
3792     g_return_if_fail (node != NULL);
3793 }
3794 
3795 static void
3796 type_add_flags_W (TypeNode  *node,
3797       GTypeFlags flags)
3798 {
3799   guint dflags;
3800 
3801   g_return_if_fail ((flags &amp; ~TYPE_FLAG_MASK) == 0);
3802   g_return_if_fail (node != NULL);
3803 
3804   if ((flags &amp; TYPE_FLAG_MASK) &amp;&amp; node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class)
3805     g_warning (&quot;tagging type &#39;%s&#39; as abstract after class initialization&quot;, NODE_NAME (node));
3806   dflags = GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags));
3807   dflags |= flags;
3808   type_set_qdata_W (node, static_quark_type_flags, GUINT_TO_POINTER (dflags));
3809 }
3810 
3811 /**
3812  * g_type_query:
3813  * @type: #GType of a static, classed type
3814  * @query: (out caller-allocates): a user provided structure that is
3815  *     filled in with constant values upon success
3816  *
3817  * Queries the type system for information about a specific type.
3818  * This function will fill in a user-provided structure to hold
3819  * type-specific information. If an invalid #GType is passed in, the
3820  * @type member of the #GTypeQuery is 0. All members filled into the
3821  * #GTypeQuery structure should be considered constant and have to be
3822  * left untouched.
3823  */
3824 void
3825 g_type_query (GType       type,
3826         GTypeQuery *query)
3827 {
3828   TypeNode *node;
3829 
3830   g_return_if_fail (query != NULL);
3831 
3832   /* if node is not static and classed, we won&#39;t allow query */
3833   query-&gt;type = 0;
3834   node = lookup_type_node_I (type);
3835   if (node &amp;&amp; node-&gt;is_classed &amp;&amp; !node-&gt;plugin)
3836     {
3837       /* type is classed and probably even instantiatable */
3838       G_READ_LOCK (&amp;type_rw_lock);
3839       if (node-&gt;data) /* type is static or referenced */
3840   {
3841     query-&gt;type = NODE_TYPE (node);
3842     query-&gt;type_name = NODE_NAME (node);
3843     query-&gt;class_size = node-&gt;data-&gt;class.class_size;
3844     query-&gt;instance_size = node-&gt;is_instantiatable ? node-&gt;data-&gt;instance.instance_size : 0;
3845   }
3846       G_READ_UNLOCK (&amp;type_rw_lock);
3847     }
3848 }
3849 
3850 /**
3851  * g_type_get_instance_count:
3852  * @type: a #GType
3853  *
3854  * Returns the number of instances allocated of the particular type;
3855  * this is only available if GLib is built with debugging support and
3856  * the instance_count debug flag is set (by setting the GOBJECT_DEBUG
3857  * variable to include instance-count).
3858  *
3859  * Returns: the number of instances allocated of the given type;
3860  *   if instance counts are not available, returns 0.
3861  *
3862  * Since: 2.44
3863  */
3864 int
3865 g_type_get_instance_count (GType type)
3866 {
3867 #ifdef G_ENABLE_DEBUG
3868   TypeNode *node;
3869 
3870   node = lookup_type_node_I (type);
3871   g_return_val_if_fail (node != NULL, 0);
3872 
3873   return g_atomic_int_get (&amp;node-&gt;instance_count);
3874 #else
3875   return 0;
3876 #endif
3877 }
3878 
3879 /* --- implementation details --- */
3880 gboolean
3881 g_type_test_flags (GType type,
3882        guint flags)
3883 {
3884   TypeNode *node;
3885   gboolean result = FALSE;
3886 
3887   node = lookup_type_node_I (type);
3888   if (node)
3889     {
3890       guint fflags = flags &amp; TYPE_FUNDAMENTAL_FLAG_MASK;
3891       guint tflags = flags &amp; TYPE_FLAG_MASK;
3892 
3893       if (fflags)
3894   {
3895     GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (node);
3896 
3897     fflags = (finfo-&gt;type_flags &amp; fflags) == fflags;
3898   }
3899       else
3900   fflags = TRUE;
3901 
3902       if (tflags)
3903   {
3904     G_READ_LOCK (&amp;type_rw_lock);
3905     tflags = (tflags &amp; GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))) == tflags;
3906     G_READ_UNLOCK (&amp;type_rw_lock);
3907   }
3908       else
3909   tflags = TRUE;
3910 
3911       result = tflags &amp;&amp; fflags;
3912     }
3913 
3914   return result;
3915 }
3916 
3917 /**
3918  * g_type_get_plugin:
3919  * @type: #GType to retrieve the plugin for
3920  *
3921  * Returns the #GTypePlugin structure for @type.
3922  *
3923  * Returns: (transfer none): the corresponding plugin
3924  *     if @type is a dynamic type, %NULL otherwise
3925  */
3926 GTypePlugin*
3927 g_type_get_plugin (GType type)
3928 {
3929   TypeNode *node;
3930 
3931   node = lookup_type_node_I (type);
3932 
3933   return node ? node-&gt;plugin : NULL;
3934 }
3935 
3936 /**
3937  * g_type_interface_get_plugin:
3938  * @instance_type: #GType of an instantiatable type
3939  * @interface_type: #GType of an interface type
3940  *
3941  * Returns the #GTypePlugin structure for the dynamic interface
3942  * @interface_type which has been added to @instance_type, or %NULL
3943  * if @interface_type has not been added to @instance_type or does
3944  * not have a #GTypePlugin structure. See g_type_add_interface_dynamic().
3945  *
3946  * Returns: (transfer none): the #GTypePlugin for the dynamic
3947  *     interface @interface_type of @instance_type
3948  */
3949 GTypePlugin*
3950 g_type_interface_get_plugin (GType instance_type,
3951            GType interface_type)
3952 {
3953   TypeNode *node;
3954   TypeNode *iface;
3955 
3956   g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);  /* G_TYPE_IS_INTERFACE() is an external call: _U */
3957 
3958   node = lookup_type_node_I (instance_type);
3959   iface = lookup_type_node_I (interface_type);
3960   if (node &amp;&amp; iface)
3961     {
3962       IFaceHolder *iholder;
3963       GTypePlugin *plugin;
3964 
3965       G_READ_LOCK (&amp;type_rw_lock);
3966 
3967       iholder = iface_node_get_holders_L (iface);
3968       while (iholder &amp;&amp; iholder-&gt;instance_type != instance_type)
3969   iholder = iholder-&gt;next;
3970       plugin = iholder ? iholder-&gt;plugin : NULL;
3971 
3972       G_READ_UNLOCK (&amp;type_rw_lock);
3973 
3974       return plugin;
3975     }
3976 
3977   g_return_val_if_fail (node == NULL, NULL);
3978   g_return_val_if_fail (iface == NULL, NULL);
3979 
3980   g_warning (G_STRLOC &quot;: attempt to look up plugin for invalid instance/interface type pair.&quot;);
3981 
3982   return NULL;
3983 }
3984 
3985 /**
3986  * g_type_fundamental_next:
3987  *
3988  * Returns the next free fundamental type id which can be used to
3989  * register a new fundamental type with g_type_register_fundamental().
3990  * The returned type ID represents the highest currently registered
3991  * fundamental type identifier.
3992  *
3993  * Returns: the next available fundamental type ID to be registered,
3994  *     or 0 if the type system ran out of fundamental type IDs
3995  */
3996 GType
3997 g_type_fundamental_next (void)
3998 {
3999   GType type;
4000 
4001   G_READ_LOCK (&amp;type_rw_lock);
4002   type = static_fundamental_next;
4003   G_READ_UNLOCK (&amp;type_rw_lock);
4004   type = G_TYPE_MAKE_FUNDAMENTAL (type);
4005   return type &lt;= G_TYPE_FUNDAMENTAL_MAX ? type : 0;
4006 }
4007 
4008 /**
4009  * g_type_fundamental:
4010  * @type_id: valid type ID
4011  *
4012  * Internal function, used to extract the fundamental type ID portion.
4013  * Use G_TYPE_FUNDAMENTAL() instead.
4014  *
4015  * Returns: fundamental type ID
4016  */
4017 GType
4018 g_type_fundamental (GType type_id)
4019 {
4020   TypeNode *node = lookup_type_node_I (type_id);
4021 
4022   return node ? NODE_FUNDAMENTAL_TYPE (node) : 0;
4023 }
4024 
4025 gboolean
4026 g_type_check_instance_is_a (GTypeInstance *type_instance,
4027           GType          iface_type)
4028 {
4029   TypeNode *node, *iface;
4030   gboolean check;
4031 
4032   if (!type_instance || !type_instance-&gt;g_class)
4033     return FALSE;
4034 
4035   node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);
4036   iface = lookup_type_node_I (iface_type);
4037   check = node &amp;&amp; node-&gt;is_instantiatable &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, TRUE, FALSE);
4038 
4039   return check;
4040 }
4041 
4042 gboolean
4043 g_type_check_instance_is_fundamentally_a (GTypeInstance *type_instance,
4044                                           GType          fundamental_type)
4045 {
4046   TypeNode *node;
4047   if (!type_instance || !type_instance-&gt;g_class)
4048     return FALSE;
4049   node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);
4050   return node &amp;&amp; (NODE_FUNDAMENTAL_TYPE(node) == fundamental_type);
4051 }
4052 
4053 gboolean
4054 g_type_check_class_is_a (GTypeClass *type_class,
4055        GType       is_a_type)
4056 {
4057   TypeNode *node, *iface;
4058   gboolean check;
4059 
4060   if (!type_class)
4061     return FALSE;
4062 
4063   node = lookup_type_node_I (type_class-&gt;g_type);
4064   iface = lookup_type_node_I (is_a_type);
4065   check = node &amp;&amp; node-&gt;is_classed &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, FALSE, FALSE);
4066 
4067   return check;
4068 }
4069 
4070 GTypeInstance*
4071 g_type_check_instance_cast (GTypeInstance *type_instance,
4072           GType          iface_type)
4073 {
4074   if (type_instance)
4075     {
4076       if (type_instance-&gt;g_class)
4077   {
4078     TypeNode *node, *iface;
4079     gboolean is_instantiatable, check;
4080 
4081     node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);
4082     is_instantiatable = node &amp;&amp; node-&gt;is_instantiatable;
4083     iface = lookup_type_node_I (iface_type);
4084     check = is_instantiatable &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, TRUE, FALSE);
4085     if (check)
4086       return type_instance;
4087 
4088     if (is_instantiatable)
4089       g_warning (&quot;invalid cast from &#39;%s&#39; to &#39;%s&#39;&quot;,
4090            type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type),
4091            type_descriptive_name_I (iface_type));
4092     else
4093       g_warning (&quot;invalid uninstantiatable type &#39;%s&#39; in cast to &#39;%s&#39;&quot;,
4094            type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type),
4095            type_descriptive_name_I (iface_type));
4096   }
4097       else
4098   g_warning (&quot;invalid unclassed pointer in cast to &#39;%s&#39;&quot;,
4099        type_descriptive_name_I (iface_type));
4100     }
4101 
4102   return type_instance;
4103 }
4104 
4105 GTypeClass*
4106 g_type_check_class_cast (GTypeClass *type_class,
4107        GType       is_a_type)
4108 {
4109   if (type_class)
4110     {
4111       TypeNode *node, *iface;
4112       gboolean is_classed, check;
4113 
4114       node = lookup_type_node_I (type_class-&gt;g_type);
4115       is_classed = node &amp;&amp; node-&gt;is_classed;
4116       iface = lookup_type_node_I (is_a_type);
4117       check = is_classed &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, FALSE, FALSE);
4118       if (check)
4119   return type_class;
4120 
4121       if (is_classed)
4122   g_warning (&quot;invalid class cast from &#39;%s&#39; to &#39;%s&#39;&quot;,
4123        type_descriptive_name_I (type_class-&gt;g_type),
4124        type_descriptive_name_I (is_a_type));
4125       else
4126   g_warning (&quot;invalid unclassed type &#39;%s&#39; in class cast to &#39;%s&#39;&quot;,
4127        type_descriptive_name_I (type_class-&gt;g_type),
4128        type_descriptive_name_I (is_a_type));
4129     }
4130   else
4131     g_warning (&quot;invalid class cast from (NULL) pointer to &#39;%s&#39;&quot;,
4132          type_descriptive_name_I (is_a_type));
4133   return type_class;
4134 }
4135 
4136 /**
4137  * g_type_check_instance:
4138  * @instance: a valid #GTypeInstance structure
4139  *
4140  * Private helper function to aid implementation of the
4141  * G_TYPE_CHECK_INSTANCE() macro.
4142  *
4143  * Returns: %TRUE if @instance is valid, %FALSE otherwise
4144  */
4145 gboolean
4146 g_type_check_instance (GTypeInstance *type_instance)
4147 {
4148   /* this function is just here to make the signal system
4149    * conveniently elaborated on instance checks
4150    */
4151   if (type_instance)
4152     {
4153       if (type_instance-&gt;g_class)
4154   {
4155     TypeNode *node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);
4156 
4157     if (node &amp;&amp; node-&gt;is_instantiatable)
4158       return TRUE;
4159 
4160     g_warning (&quot;instance of invalid non-instantiatable type &#39;%s&#39;&quot;,
4161          type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type));
4162   }
4163       else
4164   g_warning (&quot;instance with invalid (NULL) class pointer&quot;);
4165     }
4166   else
4167     g_warning (&quot;invalid (NULL) pointer instance&quot;);
4168 
4169   return FALSE;
4170 }
4171 
4172 static inline gboolean
4173 type_check_is_value_type_U (GType type)
4174 {
4175   GTypeFlags tflags = G_TYPE_FLAG_VALUE_ABSTRACT;
4176   TypeNode *node;
4177 
4178   /* common path speed up */
4179   node = lookup_type_node_I (type);
4180   if (node &amp;&amp; node-&gt;mutatable_check_cache)
4181     return TRUE;
4182 
4183   G_READ_LOCK (&amp;type_rw_lock);
4184  restart_check:
4185   if (node)
4186     {
4187       if (node-&gt;data &amp;&amp; NODE_REFCOUNT (node) &gt; 0 &amp;&amp;
4188     node-&gt;data-&gt;common.value_table-&gt;value_init)
4189   tflags = GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags));
4190       else if (NODE_IS_IFACE (node))
4191   {
4192     guint i;
4193 
4194     for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (node); i++)
4195       {
4196         GType prtype = IFACE_NODE_PREREQUISITES (node)[i];
4197         TypeNode *prnode = lookup_type_node_I (prtype);
4198 
4199         if (prnode-&gt;is_instantiatable)
4200     {
4201       type = prtype;
4202       node = lookup_type_node_I (type);
4203       goto restart_check;
4204     }
4205       }
4206   }
4207     }
4208   G_READ_UNLOCK (&amp;type_rw_lock);
4209 
4210   return !(tflags &amp; G_TYPE_FLAG_VALUE_ABSTRACT);
4211 }
4212 
4213 gboolean
4214 g_type_check_is_value_type (GType type)
4215 {
4216   return type_check_is_value_type_U (type);
4217 }
4218 
4219 gboolean
4220 g_type_check_value (const GValue *value)
4221 {
4222   return value &amp;&amp; type_check_is_value_type_U (value-&gt;g_type);
4223 }
4224 
4225 gboolean
4226 g_type_check_value_holds (const GValue *value,
4227         GType         type)
4228 {
4229   return value &amp;&amp; type_check_is_value_type_U (value-&gt;g_type) &amp;&amp; g_type_is_a (value-&gt;g_type, type);
4230 }
4231 
4232 /**
4233  * g_type_value_table_peek: (skip)
4234  * @type: a #GType
4235  *
4236  * Returns the location of the #GTypeValueTable associated with @type.
4237  *
4238  * Note that this function should only be used from source code
4239  * that implements or has internal knowledge of the implementation of
4240  * @type.
4241  *
4242  * Returns: location of the #GTypeValueTable associated with @type or
4243  *     %NULL if there is no #GTypeValueTable associated with @type
4244  */
4245 GTypeValueTable*
4246 g_type_value_table_peek (GType type)
4247 {
4248   GTypeValueTable *vtable = NULL;
4249   TypeNode *node = lookup_type_node_I (type);
4250   gboolean has_refed_data, has_table;
4251 
4252   if (node &amp;&amp; NODE_REFCOUNT (node) &amp;&amp; node-&gt;mutatable_check_cache)
4253     return node-&gt;data-&gt;common.value_table;
4254 
4255   G_READ_LOCK (&amp;type_rw_lock);
4256 
4257  restart_table_peek:
4258   has_refed_data = node &amp;&amp; node-&gt;data &amp;&amp; NODE_REFCOUNT (node) &gt; 0;
4259   has_table = has_refed_data &amp;&amp; node-&gt;data-&gt;common.value_table-&gt;value_init;
4260   if (has_refed_data)
4261     {
4262       if (has_table)
4263   vtable = node-&gt;data-&gt;common.value_table;
4264       else if (NODE_IS_IFACE (node))
4265   {
4266     guint i;
4267 
4268     for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (node); i++)
4269       {
4270         GType prtype = IFACE_NODE_PREREQUISITES (node)[i];
4271         TypeNode *prnode = lookup_type_node_I (prtype);
4272 
4273         if (prnode-&gt;is_instantiatable)
4274     {
4275       type = prtype;
4276       node = lookup_type_node_I (type);
4277       goto restart_table_peek;
4278     }
4279       }
4280   }
4281     }
4282 
4283   G_READ_UNLOCK (&amp;type_rw_lock);
4284 
4285   if (vtable)
4286     return vtable;
4287 
4288   if (!node)
4289     g_warning (G_STRLOC &quot;: type id &#39;%&quot; G_GSIZE_FORMAT &quot;&#39; is invalid&quot;, type);
4290   if (!has_refed_data)
4291     g_warning (&quot;can&#39;t peek value table for type &#39;%s&#39; which is not currently referenced&quot;,
4292          type_descriptive_name_I (type));
4293 
4294   return NULL;
4295 }
4296 
4297 const gchar *
4298 g_type_name_from_instance (GTypeInstance *instance)
4299 {
4300   if (!instance)
4301     return &quot;&lt;NULL-instance&gt;&quot;;
4302   else
4303     return g_type_name_from_class (instance-&gt;g_class);
4304 }
4305 
4306 const gchar *
4307 g_type_name_from_class (GTypeClass *g_class)
4308 {
4309   if (!g_class)
4310     return &quot;&lt;NULL-class&gt;&quot;;
4311   else
4312     return g_type_name (g_class-&gt;g_type);
4313 }
4314 
4315 
4316 /* --- private api for gboxed.c --- */
4317 gpointer
4318 _g_type_boxed_copy (GType type, gpointer value)
4319 {
4320   TypeNode *node = lookup_type_node_I (type);
4321 
4322   return node-&gt;data-&gt;boxed.copy_func (value);
4323 }
4324 
4325 void
4326 _g_type_boxed_free (GType type, gpointer value)
4327 {
4328   TypeNode *node = lookup_type_node_I (type);
4329 
4330   node-&gt;data-&gt;boxed.free_func (value);
4331 }
4332 
4333 void
4334 _g_type_boxed_init (GType          type,
4335                     GBoxedCopyFunc copy_func,
4336                     GBoxedFreeFunc free_func)
4337 {
4338   TypeNode *node = lookup_type_node_I (type);
4339 
4340   node-&gt;data-&gt;boxed.copy_func = copy_func;
4341   node-&gt;data-&gt;boxed.free_func = free_func;
4342 }
4343 
4344 /* --- initialization --- */
4345 /**
4346  * g_type_init_with_debug_flags:
4347  * @debug_flags: bitwise combination of #GTypeDebugFlags values for
4348  *     debugging purposes
4349  *
4350  * This function used to initialise the type system with debugging
4351  * flags.  Since GLib 2.36, the type system is initialised automatically
4352  * and this function does nothing.
4353  *
4354  * If you need to enable debugging features, use the GOBJECT_DEBUG
4355  * environment variable.
4356  *
4357  * Deprecated: 2.36: the type system is now initialised automatically
4358  */
4359 G_GNUC_BEGIN_IGNORE_DEPRECATIONS
4360 void
4361 g_type_init_with_debug_flags (GTypeDebugFlags debug_flags)
4362 {
4363   g_assert_type_system_initialized ();
4364 
4365   if (debug_flags)
4366     g_message (&quot;g_type_init_with_debug_flags() is no longer supported.  Use the GOBJECT_DEBUG environment variable.&quot;);
4367 }
4368 G_GNUC_END_IGNORE_DEPRECATIONS
4369 
4370 /**
4371  * g_type_init:
4372  *
4373  * This function used to initialise the type system.  Since GLib 2.36,
4374  * the type system is initialised automatically and this function does
4375  * nothing.
4376  *
4377  * Deprecated: 2.36: the type system is now initialised automatically
4378  */
4379 #if !(defined(GSTREAMER_LITE) &amp;&amp; defined(G_OS_WIN32))
4380 void
4381 g_type_init (void)
4382 {
4383   g_assert_type_system_initialized ();
4384 }
4385 #endif // GSTREAMER_LITE
4386 
4387 #if defined(GSTREAMER_LITE) &amp;&amp; defined(G_OS_WIN32)
4388 // We cannot due static initialization, since it will crash due to
4389 // threading system is not initialized yet.
4390 static void gobject_init (void);
4391 void
4392 g_type_init (void)
4393 {
4394   gobject_init ();
4395 }
4396 #endif // GSTREAMER_LITE
4397 
4398 static void
4399 gobject_init (void)
4400 {
4401   const gchar *env_string;
4402   GTypeInfo info;
4403   TypeNode *node;
4404   GType type G_GNUC_UNUSED  /* when compiling with G_DISABLE_ASSERT */;
4405 
4406   /* Ensure GLib is initialized first, see
4407    * https://bugzilla.gnome.org/show_bug.cgi?id=756139
4408    */
4409   GLIB_PRIVATE_CALL (glib_init) ();
4410 
4411   G_WRITE_LOCK (&amp;type_rw_lock);
4412 
4413   /* setup GObject library wide debugging flags */
4414   env_string = g_getenv (&quot;GOBJECT_DEBUG&quot;);
4415   if (env_string != NULL)
4416     {
4417       GDebugKey debug_keys[] = {
4418         { &quot;objects&quot;, G_TYPE_DEBUG_OBJECTS },
4419         { &quot;instance-count&quot;, G_TYPE_DEBUG_INSTANCE_COUNT },
4420         { &quot;signals&quot;, G_TYPE_DEBUG_SIGNALS },
4421       };
4422 
4423       _g_type_debug_flags = g_parse_debug_string (env_string, debug_keys, G_N_ELEMENTS (debug_keys));
4424     }
4425 
4426   /* quarks */
4427   static_quark_type_flags = g_quark_from_static_string (&quot;-g-type-private--GTypeFlags&quot;);
4428   static_quark_iface_holder = g_quark_from_static_string (&quot;-g-type-private--IFaceHolder&quot;);
4429   static_quark_dependants_array = g_quark_from_static_string (&quot;-g-type-private--dependants-array&quot;);
4430 
4431   /* type qname hash table */
4432   static_type_nodes_ht = g_hash_table_new (g_str_hash, g_str_equal);
4433 
4434   /* invalid type G_TYPE_INVALID (0)
4435    */
4436   static_fundamental_type_nodes[0] = NULL;
4437 
4438   /* void type G_TYPE_NONE
4439    */
4440   node = type_node_fundamental_new_W (G_TYPE_NONE, g_intern_static_string (&quot;void&quot;), 0);
4441   type = NODE_TYPE (node);
4442   g_assert (type == G_TYPE_NONE);
4443 
4444   /* interface fundamental type G_TYPE_INTERFACE (!classed)
4445    */
4446   memset (&amp;info, 0, sizeof (info));
4447   node = type_node_fundamental_new_W (G_TYPE_INTERFACE, g_intern_static_string (&quot;GInterface&quot;), G_TYPE_FLAG_DERIVABLE);
4448   type = NODE_TYPE (node);
4449   type_data_make_W (node, &amp;info, NULL);
4450   g_assert (type == G_TYPE_INTERFACE);
4451 
4452   G_WRITE_UNLOCK (&amp;type_rw_lock);
4453 
4454   _g_value_c_init ();
4455 
4456   /* G_TYPE_TYPE_PLUGIN
4457    */
4458   g_type_ensure (g_type_plugin_get_type ());
4459 
4460   /* G_TYPE_* value types
4461    */
4462   _g_value_types_init ();
4463 
4464   /* G_TYPE_ENUM &amp; G_TYPE_FLAGS
4465    */
4466   _g_enum_types_init ();
4467 
4468   /* G_TYPE_BOXED
4469    */
4470   _g_boxed_type_init ();
4471 
4472   /* G_TYPE_PARAM
4473    */
4474   _g_param_type_init ();
4475 
4476   /* G_TYPE_OBJECT
4477    */
4478   _g_object_type_init ();
4479 
4480   /* G_TYPE_PARAM_* pspec types
4481    */
4482   _g_param_spec_types_init ();
4483 
4484   /* Value Transformations
4485    */
4486   _g_value_transforms_init ();
4487 
4488   /* Signal system
4489    */
4490   _g_signal_init ();
4491 }
4492 
4493 #if defined (G_OS_WIN32)
4494 
4495 #ifndef GSTREAMER_LITE
4496 BOOL WINAPI DllMain (HINSTANCE hinstDLL,
4497                      DWORD     fdwReason,
4498                      LPVOID    lpvReserved);
4499 
4500 BOOL WINAPI
4501 DllMain (HINSTANCE hinstDLL,
4502          DWORD     fdwReason,
4503          LPVOID    lpvReserved)
4504 {
4505   switch (fdwReason)
4506     {
4507     case DLL_PROCESS_ATTACH:
4508       gobject_init ();
4509       break;
4510 
4511     default:
4512       /* do nothing */
4513       ;
4514     }
4515 
4516   return TRUE;
4517 }
4518 #endif // GSTREAMER_LITE
4519 
4520 #elif defined (G_HAS_CONSTRUCTORS)
4521 #ifdef G_DEFINE_CONSTRUCTOR_NEEDS_PRAGMA
4522 #pragma G_DEFINE_CONSTRUCTOR_PRAGMA_ARGS(gobject_init_ctor)
4523 #endif
4524 G_DEFINE_CONSTRUCTOR(gobject_init_ctor)
4525 
4526 static void
4527 gobject_init_ctor (void)
4528 {
4529   gobject_init ();
4530 }
4531 
4532 #else
4533 # error Your platform/compiler is missing constructor support
4534 #endif
4535 
4536 /**
4537  * g_type_class_add_private:
4538  * @g_class: (type GObject.TypeClass): class structure for an instantiatable
4539  *    type
4540  * @private_size: size of private structure
4541  *
4542  * Registers a private structure for an instantiatable type.
4543  *
4544  * When an object is allocated, the private structures for
4545  * the type and all of its parent types are allocated
4546  * sequentially in the same memory block as the public
4547  * structures, and are zero-filled.
4548  *
4549  * Note that the accumulated size of the private structures of
4550  * a type and all its parent types cannot exceed 64 KiB.
4551  *
4552  * This function should be called in the type&#39;s class_init() function.
4553  * The private structure can be retrieved using the
4554  * G_TYPE_INSTANCE_GET_PRIVATE() macro.
4555  *
4556  * The following example shows attaching a private structure
4557  * MyObjectPrivate to an object MyObject defined in the standard
4558  * GObject fashion in the type&#39;s class_init() function.
4559  *
4560  * Note the use of a structure member &quot;priv&quot; to avoid the overhead
4561  * of repeatedly calling MY_OBJECT_GET_PRIVATE().
4562  *
4563  * |[&lt;!-- language=&quot;C&quot; --&gt;
4564  * typedef struct _MyObject        MyObject;
4565  * typedef struct _MyObjectPrivate MyObjectPrivate;
4566  *
4567  * struct _MyObject {
4568  *  GObject parent;
4569  *
4570  *  MyObjectPrivate *priv;
4571  * };
4572  *
4573  * struct _MyObjectPrivate {
4574  *   int some_field;
4575  * };
4576  *
4577  * static void
4578  * my_object_class_init (MyObjectClass *klass)
4579  * {
4580  *   g_type_class_add_private (klass, sizeof (MyObjectPrivate));
4581  * }
4582  *
4583  * static void
4584  * my_object_init (MyObject *my_object)
4585  * {
4586  *   my_object-&gt;priv = G_TYPE_INSTANCE_GET_PRIVATE (my_object,
4587  *                                                  MY_TYPE_OBJECT,
4588  *                                                  MyObjectPrivate);
4589  *   // my_object-&gt;priv-&gt;some_field will be automatically initialised to 0
4590  * }
4591  *
4592  * static int
4593  * my_object_get_some_field (MyObject *my_object)
4594  * {
4595  *   MyObjectPrivate *priv;
4596  *
4597  *   g_return_val_if_fail (MY_IS_OBJECT (my_object), 0);
4598  *
4599  *   priv = my_object-&gt;priv;
4600  *
4601  *   return priv-&gt;some_field;
4602  * }
4603  * ]|
4604  *
4605  * Since: 2.4
4606  * Deprecated: 2.58: Use the G_ADD_PRIVATE() macro with the `G_DEFINE_*`
4607  *   family of macros to add instance private data to a type
4608  */
4609 void
4610 g_type_class_add_private (gpointer g_class,
4611         gsize    private_size)
4612 {
4613   GType instance_type = ((GTypeClass *)g_class)-&gt;g_type;
4614   TypeNode *node = lookup_type_node_I (instance_type);
4615 
4616   g_return_if_fail (private_size &gt; 0);
4617   g_return_if_fail (private_size &lt;= 0xffff);
4618 
4619   if (!node || !node-&gt;is_instantiatable || !node-&gt;data || node-&gt;data-&gt;class.class != g_class)
4620     {
4621       g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
4622      type_descriptive_name_I (instance_type));
4623       return;
4624     }
4625 
4626   if (NODE_PARENT_TYPE (node))
4627     {
4628       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
4629       if (node-&gt;data-&gt;instance.private_size != pnode-&gt;data-&gt;instance.private_size)
4630   {
4631     g_warning (&quot;g_type_class_add_private() called multiple times for the same type&quot;);
4632     return;
4633   }
4634     }
4635 
4636   G_WRITE_LOCK (&amp;type_rw_lock);
4637 
4638   private_size = ALIGN_STRUCT (node-&gt;data-&gt;instance.private_size + private_size);
4639   g_assert (private_size &lt;= 0xffff);
4640   node-&gt;data-&gt;instance.private_size = private_size;
4641 
4642   G_WRITE_UNLOCK (&amp;type_rw_lock);
4643 }
4644 
4645 /* semi-private, called only by the G_ADD_PRIVATE macro */
4646 gint
4647 g_type_add_instance_private (GType class_gtype,
4648                              gsize private_size)
4649 {
4650   TypeNode *node = lookup_type_node_I (class_gtype);
4651 
4652   g_return_val_if_fail (private_size &gt; 0, 0);
4653   g_return_val_if_fail (private_size &lt;= 0xffff, 0);
4654 
4655   if (!node || !node-&gt;is_classed || !node-&gt;is_instantiatable || !node-&gt;data)
4656     {
4657       g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
4658      type_descriptive_name_I (class_gtype));
4659       return 0;
4660     }
4661 
4662   if (node-&gt;plugin != NULL)
4663     {
4664       g_warning (&quot;cannot use g_type_add_instance_private() with dynamic type &#39;%s&#39;&quot;,
4665                  type_descriptive_name_I (class_gtype));
4666       return 0;
4667     }
4668 
4669   /* in the future, we want to register the private data size of a type
4670    * directly from the get_type() implementation so that we can take full
4671    * advantage of the type definition macros that we already have.
4672    *
4673    * unfortunately, this does not behave correctly if a class in the middle
4674    * of the type hierarchy uses the &quot;old style&quot; of private data registration
4675    * from the class_init() implementation, as the private data offset is not
4676    * going to be known until the full class hierarchy is initialized.
4677    *
4678    * in order to transition our code to the Glorious New Future(TM), we proceed
4679    * with a two-step implementation: first, we provide this new function to
4680    * register the private data size in the get_type() implementation and we
4681    * hide it behind a macro. the function will return the private size, instead
4682    * of the offset, which will be stored inside a static variable defined by
4683    * the G_DEFINE_TYPE_EXTENDED macro. the G_DEFINE_TYPE_EXTENDED macro will
4684    * check the variable and call g_type_class_add_instance_private(), which
4685    * will use the data size and actually register the private data, then
4686    * return the computed offset of the private data, which will be stored
4687    * inside the static variable, so we can use it to retrieve the pointer
4688    * to the private data structure.
4689    *
4690    * once all our code has been migrated to the new idiomatic form of private
4691    * data registration, we will change the g_type_add_instance_private()
4692    * function to actually perform the registration and return the offset
4693    * of the private data; g_type_class_add_instance_private() already checks
4694    * if the passed argument is negative (meaning that it&#39;s an offset in the
4695    * GTypeInstance allocation) and becomes a no-op if that&#39;s the case. this
4696    * should make the migration fully transparent even if we&#39;re effectively
4697    * copying this macro into everybody&#39;s code.
4698    */
4699   return private_size;
4700 }
4701 
4702 /* semi-private function, should only be used by G_DEFINE_TYPE_EXTENDED */
4703 void
4704 g_type_class_adjust_private_offset (gpointer  g_class,
4705                                     gint     *private_size_or_offset)
4706 {
4707   GType class_gtype = ((GTypeClass *) g_class)-&gt;g_type;
4708   TypeNode *node = lookup_type_node_I (class_gtype);
4709   gssize private_size;
4710 
4711   g_return_if_fail (private_size_or_offset != NULL);
4712 
4713   /* if we have been passed the offset instead of the private data size,
4714    * then we consider this as a no-op, and just return the value. see the
4715    * comment in g_type_add_instance_private() for the full explanation.
4716    */
4717   if (*private_size_or_offset &gt; 0)
4718     g_return_if_fail (*private_size_or_offset &lt;= 0xffff);
4719   else
4720     return;
4721 
4722   if (!node || !node-&gt;is_classed || !node-&gt;is_instantiatable || !node-&gt;data)
4723     {
4724       g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
4725      type_descriptive_name_I (class_gtype));
4726       *private_size_or_offset = 0;
4727       return;
4728     }
4729 
4730   if (NODE_PARENT_TYPE (node))
4731     {
4732       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
4733       if (node-&gt;data-&gt;instance.private_size != pnode-&gt;data-&gt;instance.private_size)
4734   {
4735     g_warning (&quot;g_type_add_instance_private() called multiple times for the same type&quot;);
4736           *private_size_or_offset = 0;
4737     return;
4738   }
4739     }
4740 
4741   G_WRITE_LOCK (&amp;type_rw_lock);
4742 
4743   private_size = ALIGN_STRUCT (node-&gt;data-&gt;instance.private_size + *private_size_or_offset);
4744   g_assert (private_size &lt;= 0xffff);
4745   node-&gt;data-&gt;instance.private_size = private_size;
4746 
4747   *private_size_or_offset = -(gint) node-&gt;data-&gt;instance.private_size;
4748 
4749   G_WRITE_UNLOCK (&amp;type_rw_lock);
4750 }
4751 
4752 gpointer
4753 g_type_instance_get_private (GTypeInstance *instance,
4754            GType          private_type)
4755 {
4756   TypeNode *node;
4757 
4758   g_return_val_if_fail (instance != NULL &amp;&amp; instance-&gt;g_class != NULL, NULL);
4759 
4760   node = lookup_type_node_I (private_type);
4761   if (G_UNLIKELY (!node || !node-&gt;is_instantiatable))
4762     {
4763       g_warning (&quot;instance of invalid non-instantiatable type &#39;%s&#39;&quot;,
4764                  type_descriptive_name_I (instance-&gt;g_class-&gt;g_type));
4765       return NULL;
4766     }
4767 
4768   return ((gchar *) instance) - node-&gt;data-&gt;instance.private_size;
4769 }
4770 
4771 /**
4772  * g_type_class_get_instance_private_offset: (skip)
4773  * @g_class: (type GObject.TypeClass): a #GTypeClass
4774  *
4775  * Gets the offset of the private data for instances of @g_class.
4776  *
4777  * This is how many bytes you should add to the instance pointer of a
4778  * class in order to get the private data for the type represented by
4779  * @g_class.
4780  *
4781  * You can only call this function after you have registered a private
4782  * data area for @g_class using g_type_class_add_private().
4783  *
4784  * Returns: the offset, in bytes
4785  *
4786  * Since: 2.38
4787  **/
4788 gint
4789 g_type_class_get_instance_private_offset (gpointer g_class)
4790 {
4791   GType instance_type;
4792   guint16 parent_size;
4793   TypeNode *node;
4794 
4795   g_assert (g_class != NULL);
4796 
4797   instance_type = ((GTypeClass *) g_class)-&gt;g_type;
4798   node = lookup_type_node_I (instance_type);
4799 
4800   g_assert (node != NULL);
4801   g_assert (node-&gt;is_instantiatable);
4802 
4803   if (NODE_PARENT_TYPE (node))
4804     {
4805       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
4806 
4807       parent_size = pnode-&gt;data-&gt;instance.private_size;
4808     }
4809   else
4810     parent_size = 0;
4811 
4812   if (node-&gt;data-&gt;instance.private_size == parent_size)
4813     g_error (&quot;g_type_class_get_instance_private_offset() called on class %s but it has no private data&quot;,
4814              g_type_name (instance_type));
4815 
4816   return -(gint) node-&gt;data-&gt;instance.private_size;
4817 }
4818 
4819 /**
4820  * g_type_add_class_private:
4821  * @class_type: GType of a classed type
4822  * @private_size: size of private structure
4823  *
4824  * Registers a private class structure for a classed type;
4825  * when the class is allocated, the private structures for
4826  * the class and all of its parent types are allocated
4827  * sequentially in the same memory block as the public
4828  * structures, and are zero-filled.
4829  *
4830  * This function should be called in the
4831  * type&#39;s get_type() function after the type is registered.
4832  * The private structure can be retrieved using the
4833  * G_TYPE_CLASS_GET_PRIVATE() macro.
4834  *
4835  * Since: 2.24
4836  */
4837 void
4838 g_type_add_class_private (GType    class_type,
4839         gsize    private_size)
4840 {
4841   TypeNode *node = lookup_type_node_I (class_type);
4842   gsize offset;
4843 
4844   g_return_if_fail (private_size &gt; 0);
4845 
4846   if (!node || !node-&gt;is_classed || !node-&gt;data)
4847     {
4848       g_warning (&quot;cannot add class private field to invalid type &#39;%s&#39;&quot;,
4849      type_descriptive_name_I (class_type));
4850       return;
4851     }
4852 
4853   if (NODE_PARENT_TYPE (node))
4854     {
4855       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
4856       if (node-&gt;data-&gt;class.class_private_size != pnode-&gt;data-&gt;class.class_private_size)
4857   {
4858     g_warning (&quot;g_type_add_class_private() called multiple times for the same type&quot;);
4859     return;
4860   }
4861     }
4862 
4863   G_WRITE_LOCK (&amp;type_rw_lock);
4864 
4865   offset = ALIGN_STRUCT (node-&gt;data-&gt;class.class_private_size);
4866   node-&gt;data-&gt;class.class_private_size = offset + private_size;
4867 
4868   G_WRITE_UNLOCK (&amp;type_rw_lock);
4869 }
4870 
4871 gpointer
4872 g_type_class_get_private (GTypeClass *klass,
4873         GType       private_type)
4874 {
4875   TypeNode *class_node;
4876   TypeNode *private_node;
4877   TypeNode *parent_node;
4878   gsize offset;
4879 
4880   g_return_val_if_fail (klass != NULL, NULL);
4881 
4882   class_node = lookup_type_node_I (klass-&gt;g_type);
4883   if (G_UNLIKELY (!class_node || !class_node-&gt;is_classed))
4884     {
4885       g_warning (&quot;class of invalid type &#39;%s&#39;&quot;,
4886      type_descriptive_name_I (klass-&gt;g_type));
4887       return NULL;
4888     }
4889 
4890   private_node = lookup_type_node_I (private_type);
4891   if (G_UNLIKELY (!private_node || !NODE_IS_ANCESTOR (private_node, class_node)))
4892     {
4893       g_warning (&quot;attempt to retrieve private data for invalid type &#39;%s&#39;&quot;,
4894      type_descriptive_name_I (private_type));
4895       return NULL;
4896     }
4897 
4898   offset = ALIGN_STRUCT (class_node-&gt;data-&gt;class.class_size);
4899 
4900   if (NODE_PARENT_TYPE (private_node))
4901     {
4902       parent_node = lookup_type_node_I (NODE_PARENT_TYPE (private_node));
4903       g_assert (parent_node-&gt;data &amp;&amp; NODE_REFCOUNT (parent_node) &gt; 0);
4904 
4905       if (G_UNLIKELY (private_node-&gt;data-&gt;class.class_private_size == parent_node-&gt;data-&gt;class.class_private_size))
4906   {
4907     g_warning (&quot;g_type_instance_get_class_private() requires a prior call to g_type_add_class_private()&quot;);
4908     return NULL;
4909   }
4910 
4911       offset += ALIGN_STRUCT (parent_node-&gt;data-&gt;class.class_private_size);
4912     }
4913 
4914   return G_STRUCT_MEMBER_P (klass, offset);
4915 }
4916 
4917 /**
4918  * g_type_ensure:
4919  * @type: a #GType
4920  *
4921  * Ensures that the indicated @type has been registered with the
4922  * type system, and its _class_init() method has been run.
4923  *
4924  * In theory, simply calling the type&#39;s _get_type() method (or using
4925  * the corresponding macro) is supposed take care of this. However,
4926  * _get_type() methods are often marked %G_GNUC_CONST for performance
4927  * reasons, even though this is technically incorrect (since
4928  * %G_GNUC_CONST requires that the function not have side effects,
4929  * which _get_type() methods do on the first call). As a result, if
4930  * you write a bare call to a _get_type() macro, it may get optimized
4931  * out by the compiler. Using g_type_ensure() guarantees that the
4932  * type&#39;s _get_type() method is called.
4933  *
4934  * Since: 2.34
4935  */
4936 void
4937 g_type_ensure (GType type)
4938 {
4939   /* In theory, @type has already been resolved and so there&#39;s nothing
4940    * to do here. But this protects us in the case where the function
4941    * gets inlined (as it might in gobject_init_ctor() above).
4942    */
4943   if (G_UNLIKELY (type == (GType)-1))
4944     g_error (&quot;can&#39;t happen&quot;);
4945 }
4946 
    </pre>
  </body>
</html>