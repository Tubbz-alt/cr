<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstmessage.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /* GStreamer
  2  * Copyright (C) 2004 Wim Taymans &lt;wim@fluendo.com&gt;
  3  *
  4  * gstmessage.h: Header for GstMessage subsystem
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public
 17  * License along with this library; if not, write to the
 18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #ifndef __GST_MESSAGE_H__
 23 #define __GST_MESSAGE_H__
 24 
 25 #include &lt;glib.h&gt;
 26 
 27 G_BEGIN_DECLS
 28 
 29 typedef struct _GstMessage GstMessage;
 30 
 31 /**
 32  * GstMessageType:
 33  * @GST_MESSAGE_UNKNOWN: an undefined message
 34  * @GST_MESSAGE_EOS: end-of-stream reached in a pipeline. The application will
 35  * only receive this message in the PLAYING state and every time it sets a
 36  * pipeline to PLAYING that is in the EOS state. The application can perform a
 37  * flushing seek in the pipeline, which will undo the EOS state again.
 38  * @GST_MESSAGE_ERROR: an error occurred. When the application receives an error
 39  * message it should stop playback of the pipeline and not assume that more
 40  * data will be played.
 41  * @GST_MESSAGE_WARNING: a warning occurred.
 42  * @GST_MESSAGE_INFO: an info message occurred
 43  * @GST_MESSAGE_TAG: a tag was found.
 44  * @GST_MESSAGE_BUFFERING: the pipeline is buffering. When the application
 45  * receives a buffering message in the PLAYING state for a non-live pipeline it
 46  * must PAUSE the pipeline until the buffering completes, when the percentage
 47  * field in the message is 100%. For live pipelines, no action must be
 48  * performed and the buffering percentage can be used to inform the user about
 49  * the progress.
 50  * @GST_MESSAGE_STATE_CHANGED: a state change happened
 51  * @GST_MESSAGE_STATE_DIRTY: an element changed state in a streaming thread.
 52  * This message is deprecated.
 53  * @GST_MESSAGE_STEP_DONE: a stepping operation finished.
 54  * @GST_MESSAGE_CLOCK_PROVIDE: an element notifies its capability of providing
 55  *                             a clock. This message is used internally and
 56  *                             never forwarded to the application.
 57  * @GST_MESSAGE_CLOCK_LOST: The current clock as selected by the pipeline became
 58  *                          unusable. The pipeline will select a new clock on
 59  *                          the next PLAYING state change. The application
 60  *                          should set the pipeline to PAUSED and back to
 61  *                          PLAYING when this message is received.
 62  * @GST_MESSAGE_NEW_CLOCK: a new clock was selected in the pipeline.
 63  * @GST_MESSAGE_STRUCTURE_CHANGE: the structure of the pipeline changed. This
 64  * message is used internally and never forwarded to the application.
 65  * @GST_MESSAGE_STREAM_STATUS: status about a stream, emitted when it starts,
 66  *                             stops, errors, etc..
 67  * @GST_MESSAGE_APPLICATION: message posted by the application, possibly
 68  *                           via an application-specific element.
 69  * @GST_MESSAGE_ELEMENT: element-specific message, see the specific element&#39;s
 70  *                       documentation
 71  * @GST_MESSAGE_SEGMENT_START: pipeline started playback of a segment. This
 72  * message is used internally and never forwarded to the application.
 73  * @GST_MESSAGE_SEGMENT_DONE: pipeline completed playback of a segment. This
 74  * message is forwarded to the application after all elements that posted
 75  * @GST_MESSAGE_SEGMENT_START posted a GST_MESSAGE_SEGMENT_DONE message.
 76  * @GST_MESSAGE_DURATION_CHANGED: The duration of a pipeline changed. The
 77  * application can get the new duration with a duration query.
 78  * @GST_MESSAGE_ASYNC_START: Posted by elements when they start an ASYNC
 79  * #GstStateChange. This message is not forwarded to the application but is used
 80  * internally.
 81  * @GST_MESSAGE_ASYNC_DONE: Posted by elements when they complete an ASYNC
 82  * #GstStateChange. The application will only receive this message from the toplevel
 83  * pipeline.
 84  * @GST_MESSAGE_LATENCY: Posted by elements when their latency changes. The
 85  * application should recalculate and distribute a new latency.
 86  * @GST_MESSAGE_REQUEST_STATE: Posted by elements when they want the pipeline to
 87  * change state. This message is a suggestion to the application which can
 88  * decide to perform the state change on (part of) the pipeline.
 89  * @GST_MESSAGE_STEP_START: A stepping operation was started.
 90  * @GST_MESSAGE_QOS: A buffer was dropped or an element changed its processing
 91  * strategy for Quality of Service reasons.
 92  * @GST_MESSAGE_PROGRESS: A progress message.
 93  * @GST_MESSAGE_TOC: A new table of contents (TOC) was found or previously found TOC
 94  * was updated.
 95  * @GST_MESSAGE_RESET_TIME: Message to request resetting the pipeline&#39;s
 96  *     running time from the pipeline. This is an internal message which
 97  *     applications will likely never receive.
 98  * @GST_MESSAGE_STREAM_START: Message indicating start of a new stream. Useful
 99  *     e.g. when using playbin in gapless playback mode, to get notified when
100  *     the next title actually starts playing (which will be some time after
101  *     the URI for the next title has been set).
102  * @GST_MESSAGE_NEED_CONTEXT: Message indicating that an element wants a specific context (Since: 1.2)
103  * @GST_MESSAGE_HAVE_CONTEXT: Message indicating that an element created a context (Since: 1.2)
104  * @GST_MESSAGE_EXTENDED: Message is an extended message type (see below).
105  *     These extended message IDs can&#39;t be used directly with mask-based API
106  *     like gst_bus_poll() or gst_bus_timed_pop_filtered(), but you can still
107  *     filter for GST_MESSAGE_EXTENDED and then check the result for the
108  *     specific type. (Since: 1.4)
109  * @GST_MESSAGE_DEVICE_ADDED: Message indicating a #GstDevice was added to
110  *     a #GstDeviceProvider (Since: 1.4)
111  * @GST_MESSAGE_DEVICE_REMOVED: Message indicating a #GstDevice was removed
112  *     from a #GstDeviceProvider (Since: 1.4)
113  * @GST_MESSAGE_PROPERTY_NOTIFY: Message indicating a #GObject property has
114  *     changed (Since: 1.10)
115  * @GST_MESSAGE_STREAM_COLLECTION: Message indicating a new #GstStreamCollection
116  *     is available (Since: 1.10)
117  * @GST_MESSAGE_STREAMS_SELECTED: Message indicating the active selection of
118  *     #GstStreams has changed (Since: 1.10)
119  * @GST_MESSAGE_REDIRECT: Message indicating to request the application to
120  *     try to play the given URL(s). Useful if for example a HTTP 302/303
121  *     response is received with a non-HTTP URL inside. (Since: 1.10)
122  * @GST_MESSAGE_DEVICE_CHANGED: Message indicating a #GstDevice was changed
123  *     a #GstDeviceProvider (Since: 1.16)
124  * @GST_MESSAGE_ANY: mask for all of the above messages.
125  *
126  * The different message types that are available.
127  */
128 /* NOTE: keep in sync with quark registration in gstmessage.c
129  * NOTE: keep GST_MESSAGE_ANY a valid gint to avoid compiler warnings.
130  */
131 /* FIXME: 2.0: Make it NOT flags, just a regular 1,2,3,4.. enumeration */
132 /* FIXME: For GST_MESSAGE_ANY ~0 -&gt; 0xffffffff see
133  *        https://bugzilla.gnome.org/show_bug.cgi?id=732633
134  */
135 typedef enum
136 {
137   GST_MESSAGE_UNKNOWN           = 0,
138   GST_MESSAGE_EOS               = (1 &lt;&lt; 0),
139   GST_MESSAGE_ERROR             = (1 &lt;&lt; 1),
140   GST_MESSAGE_WARNING           = (1 &lt;&lt; 2),
141   GST_MESSAGE_INFO              = (1 &lt;&lt; 3),
142   GST_MESSAGE_TAG               = (1 &lt;&lt; 4),
143   GST_MESSAGE_BUFFERING         = (1 &lt;&lt; 5),
144   GST_MESSAGE_STATE_CHANGED     = (1 &lt;&lt; 6),
145   GST_MESSAGE_STATE_DIRTY       = (1 &lt;&lt; 7),
146   GST_MESSAGE_STEP_DONE         = (1 &lt;&lt; 8),
147   GST_MESSAGE_CLOCK_PROVIDE     = (1 &lt;&lt; 9),
148   GST_MESSAGE_CLOCK_LOST        = (1 &lt;&lt; 10),
149   GST_MESSAGE_NEW_CLOCK         = (1 &lt;&lt; 11),
150   GST_MESSAGE_STRUCTURE_CHANGE  = (1 &lt;&lt; 12),
151   GST_MESSAGE_STREAM_STATUS     = (1 &lt;&lt; 13),
152   GST_MESSAGE_APPLICATION       = (1 &lt;&lt; 14),
153   GST_MESSAGE_ELEMENT           = (1 &lt;&lt; 15),
154   GST_MESSAGE_SEGMENT_START     = (1 &lt;&lt; 16),
155   GST_MESSAGE_SEGMENT_DONE      = (1 &lt;&lt; 17),
156   GST_MESSAGE_DURATION_CHANGED  = (1 &lt;&lt; 18),
157   GST_MESSAGE_LATENCY           = (1 &lt;&lt; 19),
158   GST_MESSAGE_ASYNC_START       = (1 &lt;&lt; 20),
159   GST_MESSAGE_ASYNC_DONE        = (1 &lt;&lt; 21),
160   GST_MESSAGE_REQUEST_STATE     = (1 &lt;&lt; 22),
161   GST_MESSAGE_STEP_START        = (1 &lt;&lt; 23),
162   GST_MESSAGE_QOS               = (1 &lt;&lt; 24),
163   GST_MESSAGE_PROGRESS          = (1 &lt;&lt; 25),
164   GST_MESSAGE_TOC               = (1 &lt;&lt; 26),
165   GST_MESSAGE_RESET_TIME        = (1 &lt;&lt; 27),
166   GST_MESSAGE_STREAM_START      = (1 &lt;&lt; 28),
167   GST_MESSAGE_NEED_CONTEXT      = (1 &lt;&lt; 29),
168   GST_MESSAGE_HAVE_CONTEXT      = (1 &lt;&lt; 30),
169   GST_MESSAGE_EXTENDED          = (gint) (1u &lt;&lt; 31),
170   GST_MESSAGE_DEVICE_ADDED      = GST_MESSAGE_EXTENDED + 1,
171   GST_MESSAGE_DEVICE_REMOVED    = GST_MESSAGE_EXTENDED + 2,
172   GST_MESSAGE_PROPERTY_NOTIFY   = GST_MESSAGE_EXTENDED + 3,
173   GST_MESSAGE_STREAM_COLLECTION = GST_MESSAGE_EXTENDED + 4,
174   GST_MESSAGE_STREAMS_SELECTED  = GST_MESSAGE_EXTENDED + 5,
175   GST_MESSAGE_REDIRECT          = GST_MESSAGE_EXTENDED + 6,
176   GST_MESSAGE_DEVICE_CHANGED    = GST_MESSAGE_EXTENDED + 7,
177   GST_MESSAGE_ANY               = (gint) (0xffffffff)
178 } GstMessageType;
179 
180 #include &lt;gst/gstminiobject.h&gt;
181 #include &lt;gst/gstobject.h&gt;
182 #include &lt;gst/gstelement.h&gt;
183 #include &lt;gst/gsttaglist.h&gt;
184 #include &lt;gst/gststructure.h&gt;
185 #include &lt;gst/gstquery.h&gt;
186 #include &lt;gst/gsttoc.h&gt;
187 #ifndef GSTREAMER_LITE
188 #include &lt;gst/gstdevice.h&gt;
189 #endif // GSTREAMER_LITE
190 #include &lt;gst/gststreams.h&gt;
191 #include &lt;gst/gststreamcollection.h&gt;
192 
193 #ifndef GSTREAMER_LITE
194 GST_API GType _gst_message_type;
195 #else // GSTREAMER_LITE
196 GST_EXPORT GType _gst_message_type;
197 #endif // GSTREAMER_LITE
198 
199 #define GST_TYPE_MESSAGE                         (_gst_message_type)
200 #define GST_IS_MESSAGE(obj)                      (GST_IS_MINI_OBJECT_TYPE (obj, GST_TYPE_MESSAGE))
201 #define GST_MESSAGE_CAST(obj)                    ((GstMessage*)(obj))
202 #define GST_MESSAGE(obj)                         (GST_MESSAGE_CAST(obj))
203 
204 /* the lock is used to handle the synchronous handling of messages,
205  * the emitting thread is blocked until the handling thread processed
206  * the message using this mutex/cond pair */
207 #define GST_MESSAGE_GET_LOCK(message)   (&amp;GST_MESSAGE_CAST(message)-&gt;lock)
208 #define GST_MESSAGE_LOCK(message)       g_mutex_lock(GST_MESSAGE_GET_LOCK(message))
209 #define GST_MESSAGE_UNLOCK(message)     g_mutex_unlock(GST_MESSAGE_GET_LOCK(message))
210 #define GST_MESSAGE_GET_COND(message)   (&amp;GST_MESSAGE_CAST(message)-&gt;cond)
211 #define GST_MESSAGE_WAIT(message)       g_cond_wait(GST_MESSAGE_GET_COND(message),GST_MESSAGE_GET_LOCK(message))
212 #define GST_MESSAGE_SIGNAL(message)     g_cond_signal(GST_MESSAGE_GET_COND(message))
213 
214 /**
215  * GST_MESSAGE_TYPE:
216  * @message: a #GstMessage
217  *
218  * Get the #GstMessageType of @message.
219  */
220 #define GST_MESSAGE_TYPE(message)       (GST_MESSAGE_CAST(message)-&gt;type)
221 /**
222  * GST_MESSAGE_TYPE_IS_EXTENDED:
223  * @message: a #GstMessage
224  *
225  * Check if the message is in the extended message group
226  * Since: 1.4
227  */
228 #define GST_MESSAGE_TYPE_IS_EXTENDED(message)       (!!(GST_MESSAGE_CAST(message)-&gt;type &amp; GST_MESSAGE_EXTENDED))
229 
230 /**
231  * GST_MESSAGE_TYPE_NAME:
232  * @message: a #GstMessage
233  *
234  * Get a constant string representation of the #GstMessageType of @message.
235  */
236 #define GST_MESSAGE_TYPE_NAME(message)  gst_message_type_get_name(GST_MESSAGE_TYPE(message))
237 /**
238  * GST_MESSAGE_TIMESTAMP:
239  * @message: a #GstMessage
240  *
241  * Get the timestamp of @message. This is the timestamp when the message
242  * was created.
243  */
244 #define GST_MESSAGE_TIMESTAMP(message)  (GST_MESSAGE_CAST(message)-&gt;timestamp)
245 /**
246  * GST_MESSAGE_SRC:
247  * @message: a #GstMessage
248  *
249  * Get the object that posted @message.
250  */
251 #define GST_MESSAGE_SRC(message)        (GST_MESSAGE_CAST(message)-&gt;src)
252 
253 /**
254  * GST_MESSAGE_SEQNUM:
255  * @message: a #GstMessage
256  *
257  * Get the sequence number of @message.
258  */
259 #define GST_MESSAGE_SEQNUM(message)     (GST_MESSAGE_CAST(message)-&gt;seqnum)
260 
261 /**
262  * GST_MESSAGE_SRC_NAME:
263  * @message: a #GstMessage
264  *
265  * Get the name of the object that posted @message. Returns &quot;(NULL)&quot; if
266  * the message has no source object set.
267  */
268 #define GST_MESSAGE_SRC_NAME(message)   (GST_MESSAGE_SRC(message) ? \
269     GST_OBJECT_NAME (GST_MESSAGE_SRC(message)) : &quot;(NULL)&quot;)
270 
271 /**
272  * GstStructureChangeType:
273  * @GST_STRUCTURE_CHANGE_TYPE_PAD_LINK: Pad linking is starting or done.
274  * @GST_STRUCTURE_CHANGE_TYPE_PAD_UNLINK: Pad unlinking is starting or done.
275  *
276  * The type of a %GST_MESSAGE_STRUCTURE_CHANGE.
277  */
278 typedef enum {
279   GST_STRUCTURE_CHANGE_TYPE_PAD_LINK   = 0,
280   GST_STRUCTURE_CHANGE_TYPE_PAD_UNLINK = 1
281 } GstStructureChangeType;
282 
283 /**
284  * GstStreamStatusType:
285  * @GST_STREAM_STATUS_TYPE_CREATE: A new thread need to be created.
286  * @GST_STREAM_STATUS_TYPE_ENTER: a thread entered its loop function
287  * @GST_STREAM_STATUS_TYPE_LEAVE: a thread left its loop function
288  * @GST_STREAM_STATUS_TYPE_DESTROY: a thread is destroyed
289  * @GST_STREAM_STATUS_TYPE_START: a thread is started
290  * @GST_STREAM_STATUS_TYPE_PAUSE: a thread is paused
291  * @GST_STREAM_STATUS_TYPE_STOP: a thread is stopped
292  *
293  * The type of a %GST_MESSAGE_STREAM_STATUS. The stream status messages inform the
294  * application of new streaming threads and their status.
295  */
296 typedef enum {
297   GST_STREAM_STATUS_TYPE_CREATE   = 0,
298   GST_STREAM_STATUS_TYPE_ENTER    = 1,
299   GST_STREAM_STATUS_TYPE_LEAVE    = 2,
300   GST_STREAM_STATUS_TYPE_DESTROY  = 3,
301 
302   GST_STREAM_STATUS_TYPE_START    = 8,
303   GST_STREAM_STATUS_TYPE_PAUSE    = 9,
304   GST_STREAM_STATUS_TYPE_STOP     = 10
305 } GstStreamStatusType;
306 
307 /**
308  * GstProgressType:
309  * @GST_PROGRESS_TYPE_START: A new task started.
310  * @GST_PROGRESS_TYPE_CONTINUE: A task completed and a new one continues.
311  * @GST_PROGRESS_TYPE_COMPLETE: A task completed.
312  * @GST_PROGRESS_TYPE_CANCELED: A task was canceled.
313  * @GST_PROGRESS_TYPE_ERROR: A task caused an error. An error message is also
314  *          posted on the bus.
315  *
316  * The type of a %GST_MESSAGE_PROGRESS. The progress messages inform the
317  * application of the status of asynchronous tasks.
318  */
319 typedef enum {
320   GST_PROGRESS_TYPE_START    = 0,
321   GST_PROGRESS_TYPE_CONTINUE = 1,
322   GST_PROGRESS_TYPE_COMPLETE = 2,
323   GST_PROGRESS_TYPE_CANCELED = 3,
324   GST_PROGRESS_TYPE_ERROR    = 4
325 } GstProgressType;
326 
327 /**
328  * GstMessage:
329  * @mini_object: the parent structure
330  * @type: the #GstMessageType of the message
331  * @timestamp: the timestamp of the message
332  * @src: the src of the message
333  * @seqnum: the sequence number of the message
334  *
335  * A #GstMessage.
336  */
337 struct _GstMessage
338 {
339   GstMiniObject   mini_object;
340 
341   /*&lt; public &gt; *//* with COW */
342   GstMessageType  type;
343   guint64         timestamp;
344   GstObject      *src;
345   guint32         seqnum;
346 
347   /*&lt; private &gt;*//* with MESSAGE_LOCK */
348   GMutex          lock;                 /* lock and cond for async delivery */
349   GCond           cond;
350 };
351 
352 #include &lt;gst/gstquery.h&gt;
353 
354 GST_API
355 GType           gst_message_get_type            (void);
356 
357 GST_API
358 const gchar*    gst_message_type_get_name       (GstMessageType type);
359 
360 GST_API
361 GQuark          gst_message_type_to_quark       (GstMessageType type);
362 
363 /* refcounting */
364 /**
365  * gst_message_ref:
366  * @msg: the message to ref
367  *
368  * Convenience macro to increase the reference count of the message.
369  *
370  * Returns: @msg (for convenience when doing assignments)
371  */
372 static inline GstMessage *
373 gst_message_ref (GstMessage * msg)
374 {
375   return (GstMessage *) gst_mini_object_ref (GST_MINI_OBJECT_CAST (msg));
376 }
377 
378 /**
379  * gst_message_unref:
380  * @msg: the message to unref
381  *
382  * Convenience macro to decrease the reference count of the message, possibly
383  * freeing it.
384  */
385 static inline void
386 gst_message_unref (GstMessage * msg)
387 {
388   gst_mini_object_unref (GST_MINI_OBJECT_CAST (msg));
389 }
390 
391 /**
392  * gst_clear_message: (skip)
393  * @msg_ptr: a pointer to a #GstMessage reference
394  *
395  * Clears a reference to a #GstMessage.
396  *
397  * @msg_ptr must not be %NULL.
398  *
399  * If the reference is %NULL then this function does nothing. Otherwise, the
400  * reference count of the message is decreased and the pointer is set to %NULL.
401  *
402  * Since: 1.16
403  */
404 static inline void
405 gst_clear_message (GstMessage ** msg_ptr)
406 {
407   gst_clear_mini_object ((GstMiniObject **) msg_ptr);
408 }
409 
410 /* copy message */
411 /**
412  * gst_message_copy:
413  * @msg: the message to copy
414  *
415  * Creates a copy of the message. Returns a copy of the message.
416  *
417  * Returns: (transfer full): a new copy of @msg.
418  *
419  * MT safe
420  */
421 static inline GstMessage *
422 gst_message_copy (const GstMessage * msg)
423 {
424   return GST_MESSAGE_CAST (gst_mini_object_copy (GST_MINI_OBJECT_CONST_CAST (msg)));
425 }
426 
427 /**
428  * gst_message_is_writable:
429  * @msg: a #GstMessage
430  *
431  * Tests if you can safely write into a message&#39;s structure or validly
432  * modify the seqnum and timestamp fields.
433  */
434 #define         gst_message_is_writable(msg)     gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (msg))
435 /**
436  * gst_message_make_writable:
437  * @msg: (transfer full): the message to make writable
438  *
439  * Checks if a message is writable. If not, a writable copy is made and
440  * returned.
441  *
442  * Returns: (transfer full): a message (possibly a duplicate) that is writable.
443  *
444  * MT safe
445  */
446 #define         gst_message_make_writable(msg)  GST_MESSAGE_CAST (gst_mini_object_make_writable (GST_MINI_OBJECT_CAST (msg)))
447 /**
448  * gst_message_replace:
449  * @old_message: (inout) (transfer full) (nullable): pointer to a
450  *     pointer to a #GstMessage to be replaced.
451  * @new_message: (allow-none) (transfer none): pointer to a #GstMessage that will
452  *     replace the message pointed to by @old_message.
453  *
454  * Modifies a pointer to a #GstMessage to point to a different #GstMessage. The
455  * modification is done atomically (so this is useful for ensuring thread safety
456  * in some cases), and the reference counts are updated appropriately (the old
457  * message is unreffed, the new one is reffed).
458  *
459  * Either @new_message or the #GstMessage pointed to by @old_message may be %NULL.
460  *
461  * Returns: %TRUE if @new_message was different from @old_message
462  */
463 static inline gboolean
464 gst_message_replace (GstMessage **old_message, GstMessage *new_message)
465 {
466   return gst_mini_object_replace ((GstMiniObject **) old_message, (GstMiniObject *) new_message);
467 }
468 
469 /**
470  * gst_message_take:
471  * @old_message: (inout) (transfer full): pointer to a pointer to a #GstMessage
472  *     to be replaced.
473  * @new_message: (transfer full) (allow-none): pointer to a #GstMessage that
474  *     will replace the message pointed to by @old_message.
475  *
476  * Modifies a pointer to a #GstMessage to point to a different #GstMessage. This
477  * function is similar to gst_message_replace() except that it takes ownership
478  * of @new_message.
479  *
480  * Returns: %TRUE if @new_message was different from @old_message
481  *
482  * Since: 1.16
483  */
484 static inline gboolean
485 gst_message_take (GstMessage **old_message, GstMessage *new_message)
486 {
487   return gst_mini_object_take ((GstMiniObject **) old_message,
488       (GstMiniObject *) new_message);
489 }
490 
491 
492 /* custom messages */
493 
494 GST_API
495 GstMessage *    gst_message_new_custom          (GstMessageType type,
496                                                  GstObject    * src,
497                                                  GstStructure * structure) G_GNUC_MALLOC;
498 GST_API
499 const GstStructure *
500                 gst_message_get_structure       (GstMessage *message);
501 
502 GST_API
503 GstStructure *  gst_message_writable_structure  (GstMessage *message);
504 
505 GST_API
506 gboolean        gst_message_has_name            (GstMessage *message, const gchar *name);
507 
508 /* identifiers for events and messages */
509 
510 GST_API
511 guint32         gst_message_get_seqnum          (GstMessage *message);
512 
513 GST_API
514 void            gst_message_set_seqnum          (GstMessage *message, guint32 seqnum);
515 
516 /* EOS */
517 
518 GST_API
519 GstMessage *    gst_message_new_eos             (GstObject * src) G_GNUC_MALLOC;
520 
521 /* ERROR */
522 
523 GST_API
524 GstMessage *    gst_message_new_error           (GstObject * src, GError * error, const gchar * debug) G_GNUC_MALLOC;
525 
526 GST_API
527 GstMessage *    gst_message_new_error_with_details (GstObject * src, GError * error, const gchar * debug, GstStructure * details) G_GNUC_MALLOC;
528 
529 GST_API
530 void            gst_message_parse_error         (GstMessage *message, GError **gerror, gchar **debug);
531 
532 GST_API
533 void            gst_message_parse_error_details (GstMessage *message, const GstStructure **structure);
534 
535 /* WARNING */
536 
537 GST_API
538 GstMessage *    gst_message_new_warning         (GstObject * src, GError * error, const gchar * debug) G_GNUC_MALLOC;
539 
540 GST_API
541 GstMessage *    gst_message_new_warning_with_details (GstObject * src, GError * error, const gchar * debug, GstStructure * details) G_GNUC_MALLOC;
542 
543 GST_API
544 void            gst_message_parse_warning       (GstMessage *message, GError **gerror, gchar **debug);
545 
546 GST_API
547 void            gst_message_parse_warning_details (GstMessage *message, const GstStructure **structure);
548 
549 /* INFO */
550 
551 GST_API
552 GstMessage *    gst_message_new_info            (GstObject * src, GError * error, const gchar * debug) G_GNUC_MALLOC;
553 
554 GST_API
555 GstMessage *    gst_message_new_info_with_details (GstObject * src, GError * error, const gchar * debug, GstStructure * details) G_GNUC_MALLOC;
556 
557 GST_API
558 void            gst_message_parse_info          (GstMessage *message, GError **gerror, gchar **debug);
559 
560 GST_API
561 void            gst_message_parse_info_details  (GstMessage *message, const GstStructure **structure);
562 
563 /* TAG */
564 
565 GST_API
566 GstMessage *    gst_message_new_tag             (GstObject * src, GstTagList * tag_list) G_GNUC_MALLOC;
567 
568 GST_API
569 void            gst_message_parse_tag           (GstMessage *message, GstTagList **tag_list);
570 
571 /* BUFFERING */
572 
573 GST_API
574 GstMessage *    gst_message_new_buffering         (GstObject * src, gint percent) G_GNUC_MALLOC;
575 
576 GST_API
577 void            gst_message_parse_buffering       (GstMessage *message, gint *percent);
578 
579 GST_API
580 void            gst_message_set_buffering_stats   (GstMessage *message, GstBufferingMode mode,
581                                                    gint avg_in, gint avg_out,
582                                                    gint64 buffering_left);
583 GST_API
584 void            gst_message_parse_buffering_stats (GstMessage *message, GstBufferingMode *mode,
585                                                    gint *avg_in, gint *avg_out,
586                                                    gint64 *buffering_left);
587 
588 /* STATE_CHANGED */
589 
590 GST_API
591 GstMessage *    gst_message_new_state_changed   (GstObject * src, GstState oldstate,
592                                                  GstState newstate, GstState pending) G_GNUC_MALLOC;
593 GST_API
594 void            gst_message_parse_state_changed (GstMessage *message, GstState *oldstate,
595                                                  GstState *newstate, GstState *pending);
596 
597 /* STATE_DIRTY */
598 
599 GST_API
600 GstMessage *    gst_message_new_state_dirty     (GstObject * src) G_GNUC_MALLOC;
601 
602 /* STEP_DONE */
603 
604 GST_API
605 GstMessage *    gst_message_new_step_done       (GstObject * src, GstFormat format, guint64 amount,
606                                                  gdouble rate, gboolean flush, gboolean intermediate,
607                                                  guint64 duration, gboolean eos) G_GNUC_MALLOC;
608 GST_API
609 void            gst_message_parse_step_done     (GstMessage * message, GstFormat *format, guint64 *amount,
610                                                  gdouble *rate, gboolean *flush, gboolean *intermediate,
611                                                  guint64 *duration, gboolean *eos);
612 /* CLOCK_PROVIDE */
613 
614 GST_API
615 GstMessage *    gst_message_new_clock_provide   (GstObject * src, GstClock *clock, gboolean ready) G_GNUC_MALLOC;
616 
617 GST_API
618 void            gst_message_parse_clock_provide (GstMessage *message, GstClock **clock,
619                                                  gboolean *ready);
620 
621 /* CLOCK_LOST */
622 
623 GST_API
624 GstMessage *    gst_message_new_clock_lost      (GstObject * src, GstClock *clock) G_GNUC_MALLOC;
625 
626 GST_API
627 void            gst_message_parse_clock_lost    (GstMessage *message, GstClock **clock);
628 
629 /* NEW_CLOCK */
630 
631 GST_API
632 GstMessage *    gst_message_new_new_clock       (GstObject * src, GstClock *clock) G_GNUC_MALLOC;
633 
634 GST_API
635 void            gst_message_parse_new_clock     (GstMessage *message, GstClock **clock);
636 
637 /* APPLICATION */
638 
639 GST_API
640 GstMessage *    gst_message_new_application     (GstObject * src, GstStructure * structure) G_GNUC_MALLOC;
641 
642 /* ELEMENT */
643 
644 GST_API
645 GstMessage *    gst_message_new_element         (GstObject * src, GstStructure * structure) G_GNUC_MALLOC;
646 
647 /* SEGMENT_START */
648 
649 GST_API
650 GstMessage *    gst_message_new_segment_start   (GstObject * src, GstFormat format, gint64 position) G_GNUC_MALLOC;
651 
652 GST_API
653 void            gst_message_parse_segment_start (GstMessage *message, GstFormat *format,
654                                                  gint64 *position);
655 
656 /* SEGMENT_DONE */
657 
658 GST_API
659 GstMessage *    gst_message_new_segment_done    (GstObject * src, GstFormat format, gint64 position) G_GNUC_MALLOC;
660 
661 GST_API
662 void            gst_message_parse_segment_done  (GstMessage *message, GstFormat *format,
663                                                  gint64 *position);
664 
665 /* DURATION_CHANGED */
666 
667 GST_API
668 GstMessage *    gst_message_new_duration_changed (GstObject * src) G_GNUC_MALLOC;
669 
670 /* LATENCY */
671 
672 GST_API
673 GstMessage *    gst_message_new_latency         (GstObject * src) G_GNUC_MALLOC;
674 
675 /* ASYNC_START */
676 
677 GST_API
678 GstMessage *    gst_message_new_async_start     (GstObject * src) G_GNUC_MALLOC;
679 
680 /* ASYNC_DONE */
681 
682 GST_API
683 GstMessage *    gst_message_new_async_done      (GstObject * src, GstClockTime running_time) G_GNUC_MALLOC;
684 
685 GST_API
686 void            gst_message_parse_async_done    (GstMessage *message, GstClockTime *running_time);
687 
688 /* STRUCTURE CHANGE */
689 
690 GST_API
691 GstMessage *    gst_message_new_structure_change   (GstObject * src, GstStructureChangeType type,
692                                                     GstElement *owner, gboolean busy) G_GNUC_MALLOC;
693 GST_API
694 void            gst_message_parse_structure_change (GstMessage *message, GstStructureChangeType *type,
695                                                     GstElement **owner, gboolean *busy);
696 
697 /* STREAM STATUS */
698 
699 GST_API
700 GstMessage *    gst_message_new_stream_status        (GstObject * src, GstStreamStatusType type,
701                                                       GstElement *owner) G_GNUC_MALLOC;
702 GST_API
703 void            gst_message_parse_stream_status      (GstMessage *message, GstStreamStatusType *type,
704                                                       GstElement **owner);
705 GST_API
706 void            gst_message_set_stream_status_object (GstMessage *message, const GValue *object);
707 
708 GST_API
709 const GValue *  gst_message_get_stream_status_object (GstMessage *message);
710 
711 /* REQUEST_STATE */
712 
713 GST_API
714 GstMessage *    gst_message_new_request_state   (GstObject * src, GstState state) G_GNUC_MALLOC;
715 
716 GST_API
717 void            gst_message_parse_request_state (GstMessage * message, GstState *state);
718 
719 /* STEP_START */
720 
721 GST_API
722 GstMessage *    gst_message_new_step_start      (GstObject * src, gboolean active, GstFormat format,
723                                                  guint64 amount, gdouble rate, gboolean flush,
724                                                  gboolean intermediate) G_GNUC_MALLOC;
725 GST_API
726 void            gst_message_parse_step_start    (GstMessage * message, gboolean *active, GstFormat *format,
727                                                  guint64 *amount, gdouble *rate, gboolean *flush,
728                                                  gboolean *intermediate);
729 
730 /* QOS */
731 
732 GST_API
733 GstMessage *    gst_message_new_qos             (GstObject * src, gboolean live, guint64 running_time,
734                                                  guint64 stream_time, guint64 timestamp, guint64 duration) G_GNUC_MALLOC;
735 GST_API
736 void            gst_message_set_qos_values      (GstMessage * message, gint64 jitter, gdouble proportion,
737                                                  gint quality);
738 GST_API
739 void            gst_message_set_qos_stats       (GstMessage * message, GstFormat format, guint64 processed,
740                                                  guint64 dropped);
741 GST_API
742 void            gst_message_parse_qos           (GstMessage * message, gboolean * live, guint64 * running_time,
743                                                  guint64 * stream_time, guint64 * timestamp, guint64 * duration);
744 GST_API
745 void            gst_message_parse_qos_values    (GstMessage * message, gint64 * jitter, gdouble * proportion,
746                                                  gint * quality);
747 GST_API
748 void            gst_message_parse_qos_stats     (GstMessage * message, GstFormat * format, guint64 * processed,
749                                                  guint64 * dropped);
750 /* PROGRESS */
751 
752 GST_API
753 GstMessage *    gst_message_new_progress           (GstObject * src, GstProgressType type, const gchar *code,
754                                                     const gchar *text) G_GNUC_MALLOC;
755 GST_API
756 void            gst_message_parse_progress         (GstMessage * message, GstProgressType * type, gchar ** code,
757                                                     gchar ** text);
758 
759 /* TOC */
760 
761 GST_API
762 GstMessage *    gst_message_new_toc             (GstObject *src, GstToc *toc, gboolean updated);
763 
764 GST_API
765 void            gst_message_parse_toc           (GstMessage *message, GstToc **toc, gboolean *updated);
766 
767 /* RESET_TIME */
768 
769 GST_API
770 GstMessage *    gst_message_new_reset_time      (GstObject * src, GstClockTime running_time) G_GNUC_MALLOC;
771 
772 GST_API
773 void            gst_message_parse_reset_time    (GstMessage *message, GstClockTime *running_time);
774 
775 /* STREAM_START */
776 
777 GST_API
778 GstMessage *    gst_message_new_stream_start    (GstObject * src) G_GNUC_MALLOC;
779 
780 GST_API
781 void            gst_message_set_group_id        (GstMessage *message, guint group_id);
782 
783 GST_API
784 gboolean        gst_message_parse_group_id      (GstMessage *message, guint *group_id);
785 
786 /* NEED_CONTEXT */
787 
788 GST_API
789 GstMessage *    gst_message_new_need_context    (GstObject * src, const gchar * context_type) G_GNUC_MALLOC;
790 
791 GST_API
792 gboolean        gst_message_parse_context_type  (GstMessage * message, const gchar ** context_type);
793 
794 /* HAVE_CONTEXT */
795 
796 GST_API
797 GstMessage *    gst_message_new_have_context    (GstObject * src, GstContext *context) G_GNUC_MALLOC;
798 
799 GST_API
800 void            gst_message_parse_have_context  (GstMessage *message, GstContext **context);
801 
802 #ifndef GSTREAMER_LITE
803 /* DEVICE_ADDED */
804 
805 GST_API
806 GstMessage *    gst_message_new_device_added    (GstObject * src, GstDevice * device) G_GNUC_MALLOC;
807 
808 GST_API
809 void            gst_message_parse_device_added  (GstMessage * message, GstDevice ** device);
810 
811 /* DEVICE_REMOVED */
812 
813 GST_API
814 GstMessage *    gst_message_new_device_removed    (GstObject * src, GstDevice * device) G_GNUC_MALLOC;
815 
816 GST_API
817 void            gst_message_parse_device_removed  (GstMessage * message, GstDevice ** device);
818 
819 /* DEVICE_CHANGED */
820 
821 GST_API
822 GstMessage *    gst_message_new_device_changed    (GstObject * src, GstDevice * device, GstDevice *changed_device);
823 
824 GST_API
825 void            gst_message_parse_device_changed  (GstMessage * message, GstDevice ** device, GstDevice ** changed_device);
826 
827 #endif // GSTREAMER_LITE
828 
829 /* PROPERTY_NOTIFY */
830 
831 GST_API
832 GstMessage *    gst_message_new_property_notify   (GstObject * src, const gchar * property_name, GValue * val) G_GNUC_MALLOC;
833 
834 GST_API
835 void            gst_message_parse_property_notify (GstMessage * message, GstObject ** object, const gchar ** property_name, const GValue ** property_value);
836 
837 /* STREAM_COLLECTION */
838 
839 GST_API
840 GstMessage *    gst_message_new_stream_collection   (GstObject * src, GstStreamCollection * collection) G_GNUC_MALLOC;
841 
842 GST_API
843 void            gst_message_parse_stream_collection (GstMessage *message, GstStreamCollection **collection);
844 
845 /* STREAMS_SELECTED */
846 
847 GST_API
848 GstMessage *    gst_message_new_streams_selected (GstObject *src, GstStreamCollection *collection);
849 
850 GST_API
851 void            gst_message_streams_selected_add (GstMessage *message, GstStream *stream);
852 
853 GST_API
854 void            gst_message_parse_streams_selected (GstMessage * message, GstStreamCollection **collection);
855 
856 GST_API
857 guint           gst_message_streams_selected_get_size (GstMessage * message);
858 
859 GST_API
860 GstStream      *gst_message_streams_selected_get_stream (GstMessage *message, guint idx);
861 
862 /* REDIRECT */
863 
864 GST_API
865 GstMessage *    gst_message_new_redirect             (GstObject * src, const gchar * location, GstTagList * tag_list, const GstStructure * entry_struct) G_GNUC_MALLOC;
866 
867 GST_API
868 void            gst_message_add_redirect_entry       (GstMessage * message, const gchar * location, GstTagList * tag_list, const GstStructure * entry_struct);
869 
870 GST_API
871 void            gst_message_parse_redirect_entry     (GstMessage * message, gsize entry_index, const gchar ** location, GstTagList ** tag_list, const GstStructure ** entry_struct);
872 
873 GST_API
874 gsize           gst_message_get_num_redirect_entries (GstMessage * message);
875 
876 #ifdef G_DEFINE_AUTOPTR_CLEANUP_FUNC
877 G_DEFINE_AUTOPTR_CLEANUP_FUNC(GstMessage, gst_message_unref)
878 #endif
879 
880 G_END_DECLS
881 
882 #endif /* __GST_MESSAGE_H__ */
    </pre>
  </body>
</html>