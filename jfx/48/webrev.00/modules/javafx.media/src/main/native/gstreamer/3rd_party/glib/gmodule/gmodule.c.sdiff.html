<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gmodule/gmodule.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gmodule-win32.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gmodule.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gmodule/gmodule.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 23  */
 24 
 25 /*
 26  * MT safe
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 
 31 #include &quot;glib.h&quot;
 32 #include &quot;gmodule.h&quot;
 33 
 34 #include &lt;errno.h&gt;
 35 #include &lt;string.h&gt;
 36 #include &lt;sys/types.h&gt;
 37 #include &lt;sys/stat.h&gt;
 38 #include &lt;fcntl.h&gt;
 39 #ifdef G_OS_UNIX
 40 #include &lt;unistd.h&gt;
 41 #endif
 42 #ifdef G_OS_WIN32
<span class="line-modified"> 43 #include &lt;io.h&gt;     /* For open() and close() prototypes. */</span>
 44 #endif
 45 
 46 #include &quot;gmoduleconf.h&quot;
 47 #include &quot;gstdio.h&quot;
 48 
 49 /**
 50  * SECTION:modules
 51  * @title: Dynamic Loading of Modules
 52  * @short_description: portable method for dynamically loading &#39;plug-ins&#39;
 53  *
 54  * These functions provide a portable way to dynamically load object files
 55  * (commonly known as &#39;plug-ins&#39;). The current implementation supports all
 56  * systems that provide an implementation of dlopen() (e.g. Linux/Sun), as
 57  * well as Windows platforms via DLLs.
 58  *
 59  * A program which wants to use these functions must be linked to the
 60  * libraries output by the command `pkg-config --libs gmodule-2.0`.
 61  *
 62  * To use them you must first determine whether dynamic loading
 63  * is supported on the platform by calling g_module_supported().
</pre>
<hr />
<pre>
187 /* We maintain a list of modules, so we can reference count them.
188  * That&#39;s needed because some platforms don&#39;t support references counts on
189  * modules. Also, the module for the program itself is kept seperately for
190  * faster access and because it has special semantics.
191  */
192 
193 
194 /* --- structures --- */
195 struct _GModule
196 {
197   gchar *file_name;
198   gpointer handle;
199   guint ref_count : 31;
200   guint is_resident : 1;
201   GModuleUnload unload;
202   GModule *next;
203 };
204 
205 
206 /* --- prototypes --- */
<span class="line-modified">207 static gpointer     _g_module_open      (const gchar    *file_name,</span>
<span class="line-modified">208                          gboolean    bind_lazy,</span>
<span class="line-modified">209                          gboolean    bind_local);</span>
<span class="line-modified">210 static void     _g_module_close     (gpointer    handle,</span>
<span class="line-modified">211                          gboolean    is_unref);</span>
<span class="line-modified">212 static gpointer     _g_module_self      (void);</span>
<span class="line-modified">213 static gpointer     _g_module_symbol    (gpointer    handle,</span>
<span class="line-modified">214                          const gchar    *symbol_name);</span>
<span class="line-modified">215 static gchar*       _g_module_build_path    (const gchar    *directory,</span>
<span class="line-modified">216                          const gchar    *module_name);</span>
<span class="line-modified">217 static inline void  g_module_set_error  (const gchar    *error);</span>
<span class="line-modified">218 static inline GModule*  g_module_find_by_handle (gpointer    handle);</span>
<span class="line-modified">219 static inline GModule*  g_module_find_by_name   (const gchar    *name);</span>
220 
221 
222 /* --- variables --- */
223 static GModule       *modules = NULL;
224 static GModule       *main_module = NULL;
225 static GPrivate       module_error_private = G_PRIVATE_INIT (g_free);
226 static gboolean       module_debug_initialized = FALSE;
<span class="line-modified">227 static guint          module_debug_flags = 0;</span>
228 
229 
230 /* --- inline functions --- */
231 static inline GModule*
232 g_module_find_by_handle (gpointer handle)
233 {
234   GModule *module;
235   GModule *retval = NULL;
236 
237   if (main_module &amp;&amp; main_module-&gt;handle == handle)
238     retval = main_module;
239   else
240     for (module = modules; module; module = module-&gt;next)
241       if (handle == module-&gt;handle)
<span class="line-modified">242     {</span>
<span class="line-modified">243       retval = module;</span>
<span class="line-modified">244       break;</span>
<span class="line-modified">245     }</span>
246 
247   return retval;
248 }
249 
250 static inline GModule*
251 g_module_find_by_name (const gchar *name)
252 {
253   GModule *module;
254   GModule *retval = NULL;
255 
256   for (module = modules; module; module = module-&gt;next)
257     if (strcmp (name, module-&gt;file_name) == 0)
<span class="line-modified">258     {</span>
<span class="line-modified">259       retval = module;</span>
<span class="line-modified">260       break;</span>
<span class="line-modified">261     }</span>
262 
263   return retval;
264 }
265 
266 static inline void
267 g_module_set_error_unduped (gchar *error)
268 {
269   g_private_replace (&amp;module_error_private, error);
270   errno = 0;
271 }
272 
273 static inline void
274 g_module_set_error (const gchar *error)
275 {
276   g_module_set_error_unduped (g_strdup (error));
277 }
278 
279 
280 /* --- include platform specifc code --- */
<span class="line-modified">281 #define SUPPORT_OR_RETURN(rv)   { g_module_set_error (NULL); }</span>
282 #if (G_MODULE_IMPL == G_MODULE_IMPL_DL)
283 #include &quot;gmodule-dl.c&quot;
<span class="line-modified">284 #elif   (G_MODULE_IMPL == G_MODULE_IMPL_WIN32)</span>
285 #include &quot;gmodule-win32.c&quot;
<span class="line-modified">286 #elif   (G_MODULE_IMPL == G_MODULE_IMPL_DYLD)</span>
287 #include &quot;gmodule-dyld.c&quot;
<span class="line-modified">288 #elif   (G_MODULE_IMPL == G_MODULE_IMPL_AR)</span>
289 #include &quot;gmodule-ar.c&quot;
290 #else
291 #undef  SUPPORT_OR_RETURN
<span class="line-modified">292 #define SUPPORT_OR_RETURN(rv)   { g_module_set_error (&quot;dynamic modules are &quot; \</span>
293                                               &quot;not supported by this system&quot;); return rv; }
294 static gpointer
295 _g_module_open (const gchar *file_name,
<span class="line-modified">296         gboolean     bind_lazy,</span>
<span class="line-modified">297         gboolean     bind_local)</span>
298 {
299   return NULL;
300 }
301 static void
<span class="line-modified">302 _g_module_close (gpointer    handle,</span>
<span class="line-modified">303          gboolean    is_unref)</span>
304 {
305 }
306 static gpointer
307 _g_module_self (void)
308 {
309   return NULL;
310 }
311 static gpointer
312 _g_module_symbol (gpointer   handle,
<span class="line-modified">313           const gchar   *symbol_name)</span>
314 {
315   return NULL;
316 }
317 static gchar*
318 _g_module_build_path (const gchar *directory,
<span class="line-modified">319               const gchar *module_name)</span>
320 {
321   return NULL;
322 }
323 #endif  /* no implementation */
324 
325 /* --- functions --- */
326 
327 /**
328  * g_module_supported:
329  *
330  * Checks if modules are supported on the current platform.
331  *
332  * Returns: %TRUE if modules are supported
333  */
334 gboolean
335 g_module_supported (void)
336 {
337   SUPPORT_OR_RETURN (FALSE);
338 
339   return TRUE;
</pre>
<hr />
<pre>
348   gchar *lt_dlname = NULL;
349   gboolean lt_installed = TRUE;
350   gchar *lt_libdir = NULL;
351   gchar *name;
352   GTokenType token;
353   GScanner *scanner;
354 
355   int fd = g_open (libtool_name, O_RDONLY, 0);
356   if (fd &lt; 0)
357     {
358       gchar *display_libtool_name = g_filename_display_name (libtool_name);
359       g_module_set_error_unduped (g_strdup_printf (&quot;failed to open libtool archive \&quot;%s\&quot;&quot;, display_libtool_name));
360       g_free (display_libtool_name);
361       return NULL;
362     }
363   /* search libtool&#39;s dlname specification  */
364   scanner = g_scanner_new (NULL);
365   g_scanner_input_file (scanner, fd);
366   scanner-&gt;config-&gt;symbol_2_token = TRUE;
367   g_scanner_scope_add_symbol (scanner, 0, &quot;dlname&quot;,
<span class="line-modified">368                   GUINT_TO_POINTER (TOKEN_DLNAME));</span>
369   g_scanner_scope_add_symbol (scanner, 0, &quot;installed&quot;,
<span class="line-modified">370                   GUINT_TO_POINTER (TOKEN_INSTALLED));</span>
371   g_scanner_scope_add_symbol (scanner, 0, &quot;libdir&quot;,
<span class="line-modified">372                   GUINT_TO_POINTER (TOKEN_LIBDIR));</span>
373   while (!g_scanner_eof (scanner))
374     {
375       token = g_scanner_get_next_token (scanner);
376       if (token == TOKEN_DLNAME || token == TOKEN_INSTALLED ||
<span class="line-modified">377       token == TOKEN_LIBDIR)</span>




















378     {
<span class="line-modified">379       if (g_scanner_get_next_token (scanner) != &#39;=&#39; ||</span>
<span class="line-modified">380           g_scanner_get_next_token (scanner) !=</span>
<span class="line-modified">381           (token == TOKEN_INSTALLED ?</span>
<span class="line-modified">382            G_TOKEN_IDENTIFIER : G_TOKEN_STRING))</span>
<span class="line-modified">383         {</span>
<span class="line-modified">384           gchar *display_libtool_name = g_filename_display_name (libtool_name);</span>
<span class="line-modified">385           g_module_set_error_unduped (g_strdup_printf (&quot;unable to parse libtool archive \&quot;%s\&quot;&quot;, display_libtool_name));</span>
<span class="line-modified">386           g_free (display_libtool_name);</span>
<span class="line-modified">387 </span>
<span class="line-modified">388           g_free (lt_dlname);</span>
<span class="line-removed">389           g_free (lt_libdir);</span>
<span class="line-removed">390           g_scanner_destroy (scanner);</span>
<span class="line-removed">391           close (fd);</span>
<span class="line-removed">392 </span>
<span class="line-removed">393           return NULL;</span>
<span class="line-removed">394         }</span>
<span class="line-removed">395       else</span>
<span class="line-removed">396         {</span>
<span class="line-removed">397           if (token == TOKEN_DLNAME)</span>
<span class="line-removed">398         {</span>
<span class="line-removed">399           g_free (lt_dlname);</span>
<span class="line-removed">400           lt_dlname = g_strdup (scanner-&gt;value.v_string);</span>
<span class="line-removed">401         }</span>
<span class="line-removed">402           else if (token == TOKEN_INSTALLED)</span>
<span class="line-removed">403         lt_installed =</span>
<span class="line-removed">404           strcmp (scanner-&gt;value.v_identifier, &quot;yes&quot;) == 0;</span>
<span class="line-removed">405           else /* token == TOKEN_LIBDIR */</span>
<span class="line-removed">406         {</span>
<span class="line-removed">407           g_free (lt_libdir);</span>
<span class="line-removed">408           lt_libdir = g_strdup (scanner-&gt;value.v_string);</span>
<span class="line-removed">409         }</span>
<span class="line-removed">410         }</span>
411     }


412     }
413 
414   if (!lt_installed)
415     {
416       gchar *dir = g_path_get_dirname (libtool_name);
417       g_free (lt_libdir);
418       lt_libdir = g_strconcat (dir, G_DIR_SEPARATOR_S &quot;.libs&quot;, NULL);
419       g_free (dir);
420     }
421 
422   name = g_strconcat (lt_libdir, G_DIR_SEPARATOR_S, lt_dlname, NULL);
423 
424   g_free (lt_dlname);
425   g_free (lt_libdir);
426   g_scanner_destroy (scanner);
427   close (fd);
428 
429   return name;
430 }
431 
432 static inline gboolean
433 str_check_suffix (const gchar* string,
<span class="line-modified">434           const gchar* suffix)</span>
435 {
436   gsize string_len = strlen (string);
437   gsize suffix_len = strlen (suffix);
438 
439   return string_len &gt;= suffix_len &amp;&amp;
440     strcmp (string + string_len - suffix_len, suffix) == 0;
441 }
442 
443 enum
444 {
445   G_MODULE_DEBUG_RESIDENT_MODULES = 1 &lt;&lt; 0,
446   G_MODULE_DEBUG_BIND_NOW_MODULES = 1 &lt;&lt; 1
447 };
448 
449 static void
450 _g_module_debug_init (void)
451 {
452   const GDebugKey keys[] = {
453     { &quot;resident-modules&quot;, G_MODULE_DEBUG_RESIDENT_MODULES },
454     { &quot;bind-now-modules&quot;, G_MODULE_DEBUG_BIND_NOW_MODULES }
</pre>
<hr />
<pre>
472  * @flags: the flags used for opening the module. This can be the
473  *     logical OR of any of the #GModuleFlags
474  *
475  * Opens a module. If the module has already been opened,
476  * its reference count is incremented.
477  *
478  * First of all g_module_open() tries to open @file_name as a module.
479  * If that fails and @file_name has the &quot;.la&quot;-suffix (and is a libtool
480  * archive) it tries to open the corresponding module. If that fails
481  * and it doesn&#39;t have the proper module suffix for the platform
482  * (#G_MODULE_SUFFIX), this suffix will be appended and the corresponding
483  * module will be opended. If that fails and @file_name doesn&#39;t have the
484  * &quot;.la&quot;-suffix, this suffix is appended and g_module_open() tries to open
485  * the corresponding module. If eventually that fails as well, %NULL is
486  * returned.
487  *
488  * Returns: a #GModule on success, or %NULL on failure
489  */
490 GModule*
491 g_module_open (const gchar    *file_name,
<span class="line-modified">492            GModuleFlags    flags)</span>
493 {
494   GModule *module;
495   gpointer handle = NULL;
496   gchar *name = NULL;
497 
498   SUPPORT_OR_RETURN (NULL);
499 
500   g_rec_mutex_lock (&amp;g_module_global_lock);
501 
502   if (G_UNLIKELY (!module_debug_initialized))
503     _g_module_debug_init ();
504 
505   if (module_debug_flags &amp; G_MODULE_DEBUG_BIND_NOW_MODULES)
506     flags &amp;= ~G_MODULE_BIND_LAZY;
507 
508   if (!file_name)
509     {
510       if (!main_module)
<span class="line-modified">511     {</span>
<span class="line-modified">512       handle = _g_module_self ();</span>
513 /* On Android 64 bit, RTLD_DEFAULT is (void *)0x0
514  * so it always fails to create main_module if file_name is NULL */
515 #if !defined(__BIONIC__) || !defined(__LP64__)
<span class="line-modified">516       if (handle)</span>
517 #endif
<span class="line-modified">518         {</span>
<span class="line-modified">519           main_module = g_new (GModule, 1);</span>
<span class="line-modified">520           main_module-&gt;file_name = NULL;</span>
<span class="line-modified">521           main_module-&gt;handle = handle;</span>
<span class="line-modified">522           main_module-&gt;ref_count = 1;</span>
<span class="line-modified">523           main_module-&gt;is_resident = TRUE;</span>
<span class="line-modified">524           main_module-&gt;unload = NULL;</span>
<span class="line-modified">525           main_module-&gt;next = NULL;</span>
<span class="line-modified">526         }</span>
<span class="line-modified">527     }</span>
528       else
<span class="line-modified">529     main_module-&gt;ref_count++;</span>
530 
531       g_rec_mutex_unlock (&amp;g_module_global_lock);
532       return main_module;
533     }
534 
535   /* we first search the module list by name */
536   module = g_module_find_by_name (file_name);
537   if (module)
538     {
539       module-&gt;ref_count++;
540 
541       g_rec_mutex_unlock (&amp;g_module_global_lock);
542       return module;
543     }
544 
545   /* check whether we have a readable file right away */
546   if (g_file_test (file_name, G_FILE_TEST_IS_REGULAR))
547     name = g_strdup (file_name);
548   /* try completing file name with standard library suffix */
549   if (!name)
550     {
551       name = g_strconcat (file_name, &quot;.&quot; G_MODULE_SUFFIX, NULL);
552       if (!g_file_test (name, G_FILE_TEST_IS_REGULAR))
<span class="line-modified">553     {</span>
<span class="line-modified">554       g_free (name);</span>
<span class="line-modified">555       name = NULL;</span>
<span class="line-modified">556     }</span>
557     }
558   /* try completing by appending libtool suffix */
559   if (!name)
560     {
561       name = g_strconcat (file_name, &quot;.la&quot;, NULL);
562       if (!g_file_test (name, G_FILE_TEST_IS_REGULAR))
<span class="line-modified">563     {</span>
<span class="line-modified">564       g_free (name);</span>
<span class="line-modified">565       name = NULL;</span>
<span class="line-modified">566     }</span>
567     }
568   /* we can&#39;t access() the file, lets hope the platform backends finds
569    * it via library paths
570    */
571   if (!name)
572     {
573       gchar *dot = strrchr (file_name, &#39;.&#39;);
574       gchar *slash = strrchr (file_name, G_DIR_SEPARATOR);
575 
576       /* make sure the name has a suffix */
577       if (!dot || dot &lt; slash)
<span class="line-modified">578     name = g_strconcat (file_name, &quot;.&quot; G_MODULE_SUFFIX, NULL);</span>
579       else
<span class="line-modified">580     name = g_strdup (file_name);</span>
581     }
582 
583   /* ok, try loading the module */
584   if (name)
585     {
586       /* if it&#39;s a libtool archive, figure library file to load */
587       if (str_check_suffix (name, &quot;.la&quot;)) /* libtool archive? */
<span class="line-modified">588     {</span>
<span class="line-modified">589       gchar *real_name = parse_libtool_archive (name);</span>
590 
<span class="line-modified">591       /* real_name might be NULL, but then module error is already set */</span>
<span class="line-modified">592       if (real_name)</span>
<span class="line-modified">593         {</span>
<span class="line-modified">594           g_free (name);</span>
<span class="line-modified">595           name = real_name;</span>
596             }
<span class="line-modified">597     }</span>
598       if (name)
<span class="line-modified">599     handle = _g_module_open (name, (flags &amp; G_MODULE_BIND_LAZY) != 0,</span>
<span class="line-modified">600             (flags &amp; G_MODULE_BIND_LOCAL) != 0);</span>
601     }
602   else
603     {
604       gchar *display_file_name = g_filename_display_name (file_name);
605       g_module_set_error_unduped (g_strdup_printf (&quot;unable to access file \&quot;%s\&quot;&quot;, display_file_name));
606       g_free (display_file_name);
607     }
608   g_free (name);
609 
610   if (handle)
611     {
612       gchar *saved_error;
613       GModuleCheckInit check_init;
614       const gchar *check_failed = NULL;
615 
616       /* search the module list by handle, since file names are not unique */
617       module = g_module_find_by_handle (handle);
618       if (module)
<span class="line-modified">619     {</span>
<span class="line-modified">620       _g_module_close (module-&gt;handle, TRUE);</span>
<span class="line-modified">621       module-&gt;ref_count++;</span>
<span class="line-modified">622       g_module_set_error (NULL);</span>
623 
<span class="line-modified">624       g_rec_mutex_unlock (&amp;g_module_global_lock);</span>
<span class="line-modified">625       return module;</span>
<span class="line-modified">626     }</span>
627 
628       saved_error = g_strdup (g_module_error ());
629       g_module_set_error (NULL);
630 
631       module = g_new (GModule, 1);
632       module-&gt;file_name = g_strdup (file_name);
633       module-&gt;handle = handle;
634       module-&gt;ref_count = 1;
635       module-&gt;is_resident = FALSE;
636       module-&gt;unload = NULL;
637       module-&gt;next = modules;
638       modules = module;
639 
640       /* check initialization */
641       if (g_module_symbol (module, &quot;g_module_check_init&quot;, (gpointer) &amp;check_init) &amp;&amp; check_init != NULL)
<span class="line-modified">642     check_failed = check_init (module);</span>
643 
644       /* we don&#39;t call unload() if the initialization check failed. */
645       if (!check_failed)
<span class="line-modified">646     g_module_symbol (module, &quot;g_module_unload&quot;, (gpointer) &amp;module-&gt;unload);</span>
647 
648       if (check_failed)
<span class="line-modified">649     {</span>
<span class="line-modified">650       gchar *error;</span>
651 
<span class="line-modified">652       error = g_strconcat (&quot;GModule (&quot;, file_name, &quot;) &quot;,</span>
653                                &quot;initialization check failed: &quot;,
654                                check_failed, NULL);
<span class="line-modified">655       g_module_close (module);</span>
<span class="line-modified">656       module = NULL;</span>
<span class="line-modified">657       g_module_set_error (error);</span>
<span class="line-modified">658       g_free (error);</span>
<span class="line-modified">659     }</span>
660       else
<span class="line-modified">661     g_module_set_error (saved_error);</span>
662 
663       g_free (saved_error);
664     }
665 
666   if (module != NULL &amp;&amp;
667       (module_debug_flags &amp; G_MODULE_DEBUG_RESIDENT_MODULES))
668     g_module_make_resident (module);
669 
670   g_rec_mutex_unlock (&amp;g_module_global_lock);
671   return module;
672 }
673 
674 /**
675  * g_module_close:
676  * @module: a #GModule to close
677  *
678  * Closes a module.
679  *
680  * Returns: %TRUE on success
681  */
</pre>
<hr />
<pre>
692   module-&gt;ref_count--;
693 
694   if (!module-&gt;ref_count &amp;&amp; !module-&gt;is_resident &amp;&amp; module-&gt;unload)
695     {
696       GModuleUnload unload;
697 
698       unload = module-&gt;unload;
699       module-&gt;unload = NULL;
700       unload (module);
701     }
702 
703   if (!module-&gt;ref_count &amp;&amp; !module-&gt;is_resident)
704     {
705       GModule *last;
706       GModule *node;
707 
708       last = NULL;
709 
710       node = modules;
711       while (node)
<span class="line-modified">712     {</span>
<span class="line-modified">713       if (node == module)</span>
<span class="line-modified">714         {</span>
<span class="line-modified">715           if (last)</span>
<span class="line-modified">716         last-&gt;next = node-&gt;next;</span>
<span class="line-modified">717           else</span>
<span class="line-modified">718         modules = node-&gt;next;</span>
<span class="line-modified">719           break;</span>
<span class="line-modified">720         }</span>
<span class="line-modified">721       last = node;</span>
<span class="line-modified">722       node = last-&gt;next;</span>
<span class="line-modified">723     }</span>
724       module-&gt;next = NULL;
725 
726       _g_module_close (module-&gt;handle, FALSE);
727       g_free (module-&gt;file_name);
728       g_free (module);
729     }
730 
731   g_rec_mutex_unlock (&amp;g_module_global_lock);
732   return g_module_error() == NULL;
733 }
734 
735 /**
736  * g_module_make_resident:
737  * @module: a #GModule to make permanently resident
738  *
739  * Ensures that a module will never be unloaded.
740  * Any future g_module_close() calls on the module will be ignored.
741  */
742 void
743 g_module_make_resident (GModule *module)
</pre>
<hr />
<pre>
779   const gchar *module_error;
780 
781   if (symbol)
782     *symbol = NULL;
783   SUPPORT_OR_RETURN (FALSE);
784 
785   g_return_val_if_fail (module != NULL, FALSE);
786   g_return_val_if_fail (symbol_name != NULL, FALSE);
787   g_return_val_if_fail (symbol != NULL, FALSE);
788 
789   g_rec_mutex_lock (&amp;g_module_global_lock);
790 
791 #ifdef  G_MODULE_NEED_USCORE
792   {
793     gchar *name;
794 
795     name = g_strconcat (&quot;_&quot;, symbol_name, NULL);
796     *symbol = _g_module_symbol (module-&gt;handle, name);
797     g_free (name);
798   }
<span class="line-modified">799 #else   /* !G_MODULE_NEED_USCORE */</span>
800   *symbol = _g_module_symbol (module-&gt;handle, symbol_name);
801 #endif  /* !G_MODULE_NEED_USCORE */
802 
803   module_error = g_module_error ();
804   if (module_error)
805     {
806       gchar *error;
807 
808       error = g_strconcat (&quot;&#39;&quot;, symbol_name, &quot;&#39;: &quot;, module_error, NULL);
809       g_module_set_error (error);
810       g_free (error);
811       *symbol = NULL;
812     }
813 
814   g_rec_mutex_unlock (&amp;g_module_global_lock);
815   return !module_error;
816 }
817 
818 /**
819  * g_module_name:
</pre>
</td>
<td>
<hr />
<pre>
 23  */
 24 
 25 /*
 26  * MT safe
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 
 31 #include &quot;glib.h&quot;
 32 #include &quot;gmodule.h&quot;
 33 
 34 #include &lt;errno.h&gt;
 35 #include &lt;string.h&gt;
 36 #include &lt;sys/types.h&gt;
 37 #include &lt;sys/stat.h&gt;
 38 #include &lt;fcntl.h&gt;
 39 #ifdef G_OS_UNIX
 40 #include &lt;unistd.h&gt;
 41 #endif
 42 #ifdef G_OS_WIN32
<span class="line-modified"> 43 #include &lt;io.h&gt;   /* For open() and close() prototypes. */</span>
 44 #endif
 45 
 46 #include &quot;gmoduleconf.h&quot;
 47 #include &quot;gstdio.h&quot;
 48 
 49 /**
 50  * SECTION:modules
 51  * @title: Dynamic Loading of Modules
 52  * @short_description: portable method for dynamically loading &#39;plug-ins&#39;
 53  *
 54  * These functions provide a portable way to dynamically load object files
 55  * (commonly known as &#39;plug-ins&#39;). The current implementation supports all
 56  * systems that provide an implementation of dlopen() (e.g. Linux/Sun), as
 57  * well as Windows platforms via DLLs.
 58  *
 59  * A program which wants to use these functions must be linked to the
 60  * libraries output by the command `pkg-config --libs gmodule-2.0`.
 61  *
 62  * To use them you must first determine whether dynamic loading
 63  * is supported on the platform by calling g_module_supported().
</pre>
<hr />
<pre>
187 /* We maintain a list of modules, so we can reference count them.
188  * That&#39;s needed because some platforms don&#39;t support references counts on
189  * modules. Also, the module for the program itself is kept seperately for
190  * faster access and because it has special semantics.
191  */
192 
193 
194 /* --- structures --- */
195 struct _GModule
196 {
197   gchar *file_name;
198   gpointer handle;
199   guint ref_count : 31;
200   guint is_resident : 1;
201   GModuleUnload unload;
202   GModule *next;
203 };
204 
205 
206 /* --- prototypes --- */
<span class="line-modified">207 static gpointer   _g_module_open    (const gchar  *file_name,</span>
<span class="line-modified">208              gboolean  bind_lazy,</span>
<span class="line-modified">209              gboolean  bind_local);</span>
<span class="line-modified">210 static void   _g_module_close   (gpointer  handle,</span>
<span class="line-modified">211              gboolean  is_unref);</span>
<span class="line-modified">212 static gpointer   _g_module_self    (void);</span>
<span class="line-modified">213 static gpointer   _g_module_symbol  (gpointer  handle,</span>
<span class="line-modified">214              const gchar  *symbol_name);</span>
<span class="line-modified">215 static gchar*   _g_module_build_path  (const gchar  *directory,</span>
<span class="line-modified">216              const gchar  *module_name);</span>
<span class="line-modified">217 static inline void  g_module_set_error  (const gchar  *error);</span>
<span class="line-modified">218 static inline GModule*  g_module_find_by_handle (gpointer  handle);</span>
<span class="line-modified">219 static inline GModule*  g_module_find_by_name (const gchar  *name);</span>
220 
221 
222 /* --- variables --- */
223 static GModule       *modules = NULL;
224 static GModule       *main_module = NULL;
225 static GPrivate       module_error_private = G_PRIVATE_INIT (g_free);
226 static gboolean       module_debug_initialized = FALSE;
<span class="line-modified">227 static guint        module_debug_flags = 0;</span>
228 
229 
230 /* --- inline functions --- */
231 static inline GModule*
232 g_module_find_by_handle (gpointer handle)
233 {
234   GModule *module;
235   GModule *retval = NULL;
236 
237   if (main_module &amp;&amp; main_module-&gt;handle == handle)
238     retval = main_module;
239   else
240     for (module = modules; module; module = module-&gt;next)
241       if (handle == module-&gt;handle)
<span class="line-modified">242   {</span>
<span class="line-modified">243     retval = module;</span>
<span class="line-modified">244     break;</span>
<span class="line-modified">245   }</span>
246 
247   return retval;
248 }
249 
250 static inline GModule*
251 g_module_find_by_name (const gchar *name)
252 {
253   GModule *module;
254   GModule *retval = NULL;
255 
256   for (module = modules; module; module = module-&gt;next)
257     if (strcmp (name, module-&gt;file_name) == 0)
<span class="line-modified">258   {</span>
<span class="line-modified">259     retval = module;</span>
<span class="line-modified">260     break;</span>
<span class="line-modified">261   }</span>
262 
263   return retval;
264 }
265 
266 static inline void
267 g_module_set_error_unduped (gchar *error)
268 {
269   g_private_replace (&amp;module_error_private, error);
270   errno = 0;
271 }
272 
273 static inline void
274 g_module_set_error (const gchar *error)
275 {
276   g_module_set_error_unduped (g_strdup (error));
277 }
278 
279 
280 /* --- include platform specifc code --- */
<span class="line-modified">281 #define SUPPORT_OR_RETURN(rv) { g_module_set_error (NULL); }</span>
282 #if (G_MODULE_IMPL == G_MODULE_IMPL_DL)
283 #include &quot;gmodule-dl.c&quot;
<span class="line-modified">284 #elif (G_MODULE_IMPL == G_MODULE_IMPL_WIN32)</span>
285 #include &quot;gmodule-win32.c&quot;
<span class="line-modified">286 #elif (G_MODULE_IMPL == G_MODULE_IMPL_DYLD)</span>
287 #include &quot;gmodule-dyld.c&quot;
<span class="line-modified">288 #elif (G_MODULE_IMPL == G_MODULE_IMPL_AR)</span>
289 #include &quot;gmodule-ar.c&quot;
290 #else
291 #undef  SUPPORT_OR_RETURN
<span class="line-modified">292 #define SUPPORT_OR_RETURN(rv) { g_module_set_error (&quot;dynamic modules are &quot; \</span>
293                                               &quot;not supported by this system&quot;); return rv; }
294 static gpointer
295 _g_module_open (const gchar *file_name,
<span class="line-modified">296     gboolean   bind_lazy,</span>
<span class="line-modified">297     gboolean   bind_local)</span>
298 {
299   return NULL;
300 }
301 static void
<span class="line-modified">302 _g_module_close (gpointer  handle,</span>
<span class="line-modified">303      gboolean  is_unref)</span>
304 {
305 }
306 static gpointer
307 _g_module_self (void)
308 {
309   return NULL;
310 }
311 static gpointer
312 _g_module_symbol (gpointer   handle,
<span class="line-modified">313       const gchar *symbol_name)</span>
314 {
315   return NULL;
316 }
317 static gchar*
318 _g_module_build_path (const gchar *directory,
<span class="line-modified">319           const gchar *module_name)</span>
320 {
321   return NULL;
322 }
323 #endif  /* no implementation */
324 
325 /* --- functions --- */
326 
327 /**
328  * g_module_supported:
329  *
330  * Checks if modules are supported on the current platform.
331  *
332  * Returns: %TRUE if modules are supported
333  */
334 gboolean
335 g_module_supported (void)
336 {
337   SUPPORT_OR_RETURN (FALSE);
338 
339   return TRUE;
</pre>
<hr />
<pre>
348   gchar *lt_dlname = NULL;
349   gboolean lt_installed = TRUE;
350   gchar *lt_libdir = NULL;
351   gchar *name;
352   GTokenType token;
353   GScanner *scanner;
354 
355   int fd = g_open (libtool_name, O_RDONLY, 0);
356   if (fd &lt; 0)
357     {
358       gchar *display_libtool_name = g_filename_display_name (libtool_name);
359       g_module_set_error_unduped (g_strdup_printf (&quot;failed to open libtool archive \&quot;%s\&quot;&quot;, display_libtool_name));
360       g_free (display_libtool_name);
361       return NULL;
362     }
363   /* search libtool&#39;s dlname specification  */
364   scanner = g_scanner_new (NULL);
365   g_scanner_input_file (scanner, fd);
366   scanner-&gt;config-&gt;symbol_2_token = TRUE;
367   g_scanner_scope_add_symbol (scanner, 0, &quot;dlname&quot;,
<span class="line-modified">368             GUINT_TO_POINTER (TOKEN_DLNAME));</span>
369   g_scanner_scope_add_symbol (scanner, 0, &quot;installed&quot;,
<span class="line-modified">370             GUINT_TO_POINTER (TOKEN_INSTALLED));</span>
371   g_scanner_scope_add_symbol (scanner, 0, &quot;libdir&quot;,
<span class="line-modified">372             GUINT_TO_POINTER (TOKEN_LIBDIR));</span>
373   while (!g_scanner_eof (scanner))
374     {
375       token = g_scanner_get_next_token (scanner);
376       if (token == TOKEN_DLNAME || token == TOKEN_INSTALLED ||
<span class="line-modified">377     token == TOKEN_LIBDIR)</span>
<span class="line-added">378   {</span>
<span class="line-added">379     if (g_scanner_get_next_token (scanner) != &#39;=&#39; ||</span>
<span class="line-added">380         g_scanner_get_next_token (scanner) !=</span>
<span class="line-added">381         (token == TOKEN_INSTALLED ?</span>
<span class="line-added">382          G_TOKEN_IDENTIFIER : G_TOKEN_STRING))</span>
<span class="line-added">383       {</span>
<span class="line-added">384         gchar *display_libtool_name = g_filename_display_name (libtool_name);</span>
<span class="line-added">385         g_module_set_error_unduped (g_strdup_printf (&quot;unable to parse libtool archive \&quot;%s\&quot;&quot;, display_libtool_name));</span>
<span class="line-added">386         g_free (display_libtool_name);</span>
<span class="line-added">387 </span>
<span class="line-added">388         g_free (lt_dlname);</span>
<span class="line-added">389         g_free (lt_libdir);</span>
<span class="line-added">390         g_scanner_destroy (scanner);</span>
<span class="line-added">391         close (fd);</span>
<span class="line-added">392 </span>
<span class="line-added">393         return NULL;</span>
<span class="line-added">394       }</span>
<span class="line-added">395     else</span>
<span class="line-added">396       {</span>
<span class="line-added">397         if (token == TOKEN_DLNAME)</span>
398     {
<span class="line-modified">399       g_free (lt_dlname);</span>
<span class="line-modified">400       lt_dlname = g_strdup (scanner-&gt;value.v_string);</span>
<span class="line-modified">401     }</span>
<span class="line-modified">402         else if (token == TOKEN_INSTALLED)</span>
<span class="line-modified">403     lt_installed =</span>
<span class="line-modified">404       strcmp (scanner-&gt;value.v_identifier, &quot;yes&quot;) == 0;</span>
<span class="line-modified">405         else /* token == TOKEN_LIBDIR */</span>
<span class="line-modified">406     {</span>
<span class="line-modified">407       g_free (lt_libdir);</span>
<span class="line-modified">408       lt_libdir = g_strdup (scanner-&gt;value.v_string);</span>






















409     }
<span class="line-added">410       }</span>
<span class="line-added">411   }</span>
412     }
413 
414   if (!lt_installed)
415     {
416       gchar *dir = g_path_get_dirname (libtool_name);
417       g_free (lt_libdir);
418       lt_libdir = g_strconcat (dir, G_DIR_SEPARATOR_S &quot;.libs&quot;, NULL);
419       g_free (dir);
420     }
421 
422   name = g_strconcat (lt_libdir, G_DIR_SEPARATOR_S, lt_dlname, NULL);
423 
424   g_free (lt_dlname);
425   g_free (lt_libdir);
426   g_scanner_destroy (scanner);
427   close (fd);
428 
429   return name;
430 }
431 
432 static inline gboolean
433 str_check_suffix (const gchar* string,
<span class="line-modified">434       const gchar* suffix)</span>
435 {
436   gsize string_len = strlen (string);
437   gsize suffix_len = strlen (suffix);
438 
439   return string_len &gt;= suffix_len &amp;&amp;
440     strcmp (string + string_len - suffix_len, suffix) == 0;
441 }
442 
443 enum
444 {
445   G_MODULE_DEBUG_RESIDENT_MODULES = 1 &lt;&lt; 0,
446   G_MODULE_DEBUG_BIND_NOW_MODULES = 1 &lt;&lt; 1
447 };
448 
449 static void
450 _g_module_debug_init (void)
451 {
452   const GDebugKey keys[] = {
453     { &quot;resident-modules&quot;, G_MODULE_DEBUG_RESIDENT_MODULES },
454     { &quot;bind-now-modules&quot;, G_MODULE_DEBUG_BIND_NOW_MODULES }
</pre>
<hr />
<pre>
472  * @flags: the flags used for opening the module. This can be the
473  *     logical OR of any of the #GModuleFlags
474  *
475  * Opens a module. If the module has already been opened,
476  * its reference count is incremented.
477  *
478  * First of all g_module_open() tries to open @file_name as a module.
479  * If that fails and @file_name has the &quot;.la&quot;-suffix (and is a libtool
480  * archive) it tries to open the corresponding module. If that fails
481  * and it doesn&#39;t have the proper module suffix for the platform
482  * (#G_MODULE_SUFFIX), this suffix will be appended and the corresponding
483  * module will be opended. If that fails and @file_name doesn&#39;t have the
484  * &quot;.la&quot;-suffix, this suffix is appended and g_module_open() tries to open
485  * the corresponding module. If eventually that fails as well, %NULL is
486  * returned.
487  *
488  * Returns: a #GModule on success, or %NULL on failure
489  */
490 GModule*
491 g_module_open (const gchar    *file_name,
<span class="line-modified">492          GModuleFlags    flags)</span>
493 {
494   GModule *module;
495   gpointer handle = NULL;
496   gchar *name = NULL;
497 
498   SUPPORT_OR_RETURN (NULL);
499 
500   g_rec_mutex_lock (&amp;g_module_global_lock);
501 
502   if (G_UNLIKELY (!module_debug_initialized))
503     _g_module_debug_init ();
504 
505   if (module_debug_flags &amp; G_MODULE_DEBUG_BIND_NOW_MODULES)
506     flags &amp;= ~G_MODULE_BIND_LAZY;
507 
508   if (!file_name)
509     {
510       if (!main_module)
<span class="line-modified">511   {</span>
<span class="line-modified">512     handle = _g_module_self ();</span>
513 /* On Android 64 bit, RTLD_DEFAULT is (void *)0x0
514  * so it always fails to create main_module if file_name is NULL */
515 #if !defined(__BIONIC__) || !defined(__LP64__)
<span class="line-modified">516     if (handle)</span>
517 #endif
<span class="line-modified">518       {</span>
<span class="line-modified">519         main_module = g_new (GModule, 1);</span>
<span class="line-modified">520         main_module-&gt;file_name = NULL;</span>
<span class="line-modified">521         main_module-&gt;handle = handle;</span>
<span class="line-modified">522         main_module-&gt;ref_count = 1;</span>
<span class="line-modified">523         main_module-&gt;is_resident = TRUE;</span>
<span class="line-modified">524         main_module-&gt;unload = NULL;</span>
<span class="line-modified">525         main_module-&gt;next = NULL;</span>
<span class="line-modified">526       }</span>
<span class="line-modified">527   }</span>
528       else
<span class="line-modified">529   main_module-&gt;ref_count++;</span>
530 
531       g_rec_mutex_unlock (&amp;g_module_global_lock);
532       return main_module;
533     }
534 
535   /* we first search the module list by name */
536   module = g_module_find_by_name (file_name);
537   if (module)
538     {
539       module-&gt;ref_count++;
540 
541       g_rec_mutex_unlock (&amp;g_module_global_lock);
542       return module;
543     }
544 
545   /* check whether we have a readable file right away */
546   if (g_file_test (file_name, G_FILE_TEST_IS_REGULAR))
547     name = g_strdup (file_name);
548   /* try completing file name with standard library suffix */
549   if (!name)
550     {
551       name = g_strconcat (file_name, &quot;.&quot; G_MODULE_SUFFIX, NULL);
552       if (!g_file_test (name, G_FILE_TEST_IS_REGULAR))
<span class="line-modified">553   {</span>
<span class="line-modified">554     g_free (name);</span>
<span class="line-modified">555     name = NULL;</span>
<span class="line-modified">556   }</span>
557     }
558   /* try completing by appending libtool suffix */
559   if (!name)
560     {
561       name = g_strconcat (file_name, &quot;.la&quot;, NULL);
562       if (!g_file_test (name, G_FILE_TEST_IS_REGULAR))
<span class="line-modified">563   {</span>
<span class="line-modified">564     g_free (name);</span>
<span class="line-modified">565     name = NULL;</span>
<span class="line-modified">566   }</span>
567     }
568   /* we can&#39;t access() the file, lets hope the platform backends finds
569    * it via library paths
570    */
571   if (!name)
572     {
573       gchar *dot = strrchr (file_name, &#39;.&#39;);
574       gchar *slash = strrchr (file_name, G_DIR_SEPARATOR);
575 
576       /* make sure the name has a suffix */
577       if (!dot || dot &lt; slash)
<span class="line-modified">578   name = g_strconcat (file_name, &quot;.&quot; G_MODULE_SUFFIX, NULL);</span>
579       else
<span class="line-modified">580   name = g_strdup (file_name);</span>
581     }
582 
583   /* ok, try loading the module */
584   if (name)
585     {
586       /* if it&#39;s a libtool archive, figure library file to load */
587       if (str_check_suffix (name, &quot;.la&quot;)) /* libtool archive? */
<span class="line-modified">588   {</span>
<span class="line-modified">589     gchar *real_name = parse_libtool_archive (name);</span>
590 
<span class="line-modified">591     /* real_name might be NULL, but then module error is already set */</span>
<span class="line-modified">592     if (real_name)</span>
<span class="line-modified">593       {</span>
<span class="line-modified">594         g_free (name);</span>
<span class="line-modified">595         name = real_name;</span>
596             }
<span class="line-modified">597   }</span>
598       if (name)
<span class="line-modified">599   handle = _g_module_open (name, (flags &amp; G_MODULE_BIND_LAZY) != 0,</span>
<span class="line-modified">600       (flags &amp; G_MODULE_BIND_LOCAL) != 0);</span>
601     }
602   else
603     {
604       gchar *display_file_name = g_filename_display_name (file_name);
605       g_module_set_error_unduped (g_strdup_printf (&quot;unable to access file \&quot;%s\&quot;&quot;, display_file_name));
606       g_free (display_file_name);
607     }
608   g_free (name);
609 
610   if (handle)
611     {
612       gchar *saved_error;
613       GModuleCheckInit check_init;
614       const gchar *check_failed = NULL;
615 
616       /* search the module list by handle, since file names are not unique */
617       module = g_module_find_by_handle (handle);
618       if (module)
<span class="line-modified">619   {</span>
<span class="line-modified">620     _g_module_close (module-&gt;handle, TRUE);</span>
<span class="line-modified">621     module-&gt;ref_count++;</span>
<span class="line-modified">622     g_module_set_error (NULL);</span>
623 
<span class="line-modified">624     g_rec_mutex_unlock (&amp;g_module_global_lock);</span>
<span class="line-modified">625     return module;</span>
<span class="line-modified">626   }</span>
627 
628       saved_error = g_strdup (g_module_error ());
629       g_module_set_error (NULL);
630 
631       module = g_new (GModule, 1);
632       module-&gt;file_name = g_strdup (file_name);
633       module-&gt;handle = handle;
634       module-&gt;ref_count = 1;
635       module-&gt;is_resident = FALSE;
636       module-&gt;unload = NULL;
637       module-&gt;next = modules;
638       modules = module;
639 
640       /* check initialization */
641       if (g_module_symbol (module, &quot;g_module_check_init&quot;, (gpointer) &amp;check_init) &amp;&amp; check_init != NULL)
<span class="line-modified">642   check_failed = check_init (module);</span>
643 
644       /* we don&#39;t call unload() if the initialization check failed. */
645       if (!check_failed)
<span class="line-modified">646   g_module_symbol (module, &quot;g_module_unload&quot;, (gpointer) &amp;module-&gt;unload);</span>
647 
648       if (check_failed)
<span class="line-modified">649   {</span>
<span class="line-modified">650     gchar *error;</span>
651 
<span class="line-modified">652     error = g_strconcat (&quot;GModule (&quot;, file_name, &quot;) &quot;,</span>
653                                &quot;initialization check failed: &quot;,
654                                check_failed, NULL);
<span class="line-modified">655     g_module_close (module);</span>
<span class="line-modified">656     module = NULL;</span>
<span class="line-modified">657     g_module_set_error (error);</span>
<span class="line-modified">658     g_free (error);</span>
<span class="line-modified">659   }</span>
660       else
<span class="line-modified">661   g_module_set_error (saved_error);</span>
662 
663       g_free (saved_error);
664     }
665 
666   if (module != NULL &amp;&amp;
667       (module_debug_flags &amp; G_MODULE_DEBUG_RESIDENT_MODULES))
668     g_module_make_resident (module);
669 
670   g_rec_mutex_unlock (&amp;g_module_global_lock);
671   return module;
672 }
673 
674 /**
675  * g_module_close:
676  * @module: a #GModule to close
677  *
678  * Closes a module.
679  *
680  * Returns: %TRUE on success
681  */
</pre>
<hr />
<pre>
692   module-&gt;ref_count--;
693 
694   if (!module-&gt;ref_count &amp;&amp; !module-&gt;is_resident &amp;&amp; module-&gt;unload)
695     {
696       GModuleUnload unload;
697 
698       unload = module-&gt;unload;
699       module-&gt;unload = NULL;
700       unload (module);
701     }
702 
703   if (!module-&gt;ref_count &amp;&amp; !module-&gt;is_resident)
704     {
705       GModule *last;
706       GModule *node;
707 
708       last = NULL;
709 
710       node = modules;
711       while (node)
<span class="line-modified">712   {</span>
<span class="line-modified">713     if (node == module)</span>
<span class="line-modified">714       {</span>
<span class="line-modified">715         if (last)</span>
<span class="line-modified">716     last-&gt;next = node-&gt;next;</span>
<span class="line-modified">717         else</span>
<span class="line-modified">718     modules = node-&gt;next;</span>
<span class="line-modified">719         break;</span>
<span class="line-modified">720       }</span>
<span class="line-modified">721     last = node;</span>
<span class="line-modified">722     node = last-&gt;next;</span>
<span class="line-modified">723   }</span>
724       module-&gt;next = NULL;
725 
726       _g_module_close (module-&gt;handle, FALSE);
727       g_free (module-&gt;file_name);
728       g_free (module);
729     }
730 
731   g_rec_mutex_unlock (&amp;g_module_global_lock);
732   return g_module_error() == NULL;
733 }
734 
735 /**
736  * g_module_make_resident:
737  * @module: a #GModule to make permanently resident
738  *
739  * Ensures that a module will never be unloaded.
740  * Any future g_module_close() calls on the module will be ignored.
741  */
742 void
743 g_module_make_resident (GModule *module)
</pre>
<hr />
<pre>
779   const gchar *module_error;
780 
781   if (symbol)
782     *symbol = NULL;
783   SUPPORT_OR_RETURN (FALSE);
784 
785   g_return_val_if_fail (module != NULL, FALSE);
786   g_return_val_if_fail (symbol_name != NULL, FALSE);
787   g_return_val_if_fail (symbol != NULL, FALSE);
788 
789   g_rec_mutex_lock (&amp;g_module_global_lock);
790 
791 #ifdef  G_MODULE_NEED_USCORE
792   {
793     gchar *name;
794 
795     name = g_strconcat (&quot;_&quot;, symbol_name, NULL);
796     *symbol = _g_module_symbol (module-&gt;handle, name);
797     g_free (name);
798   }
<span class="line-modified">799 #else /* !G_MODULE_NEED_USCORE */</span>
800   *symbol = _g_module_symbol (module-&gt;handle, symbol_name);
801 #endif  /* !G_MODULE_NEED_USCORE */
802 
803   module_error = g_module_error ();
804   if (module_error)
805     {
806       gchar *error;
807 
808       error = g_strconcat (&quot;&#39;&quot;, symbol_name, &quot;&#39;: &quot;, module_error, NULL);
809       g_module_set_error (error);
810       g_free (error);
811       *symbol = NULL;
812     }
813 
814   g_rec_mutex_unlock (&amp;g_module_global_lock);
815   return !module_error;
816 }
817 
818 /**
819  * g_module_name:
</pre>
</td>
</tr>
</table>
<center><a href="gmodule-win32.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gmodule.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>