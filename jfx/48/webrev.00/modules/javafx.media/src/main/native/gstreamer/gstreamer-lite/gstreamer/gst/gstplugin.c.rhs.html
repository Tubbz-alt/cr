<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstplugin.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2000 Wim Taymans &lt;wtay@chello.be&gt;
   4  *
   5  * gstplugin.c: Plugin subsystem for loading elements, types, and libs
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 
  23 /**
  24  * SECTION:gstplugin
  25  * @title: GstPlugin
  26  * @short_description: Container for features loaded from a shared object module
  27  * @see_also: #GstPluginFeature, #GstElementFactory
  28  *
  29  * GStreamer is extensible, so #GstElement instances can be loaded at runtime.
  30  * A plugin system can provide one or more of the basic
  31  * &lt;application&gt;GStreamer&lt;/application&gt; #GstPluginFeature subclasses.
  32  *
  33  * A plugin should export a symbol &lt;symbol&gt;gst_plugin_desc&lt;/symbol&gt; that is a
  34  * struct of type #GstPluginDesc.
  35  * the plugin loader will check the version of the core library the plugin was
  36  * linked against and will create a new #GstPlugin. It will then call the
  37  * #GstPluginInitFunc function that was provided in the
  38  * &lt;symbol&gt;gst_plugin_desc&lt;/symbol&gt;.
  39  *
  40  * Once you have a handle to a #GstPlugin (e.g. from the #GstRegistry), you
  41  * can add any object that subclasses #GstPluginFeature.
  42  *
  43  * Usually plugins are always automatically loaded so you don&#39;t need to call
  44  * gst_plugin_load() explicitly to bring it into memory. There are options to
  45  * statically link plugins to an app or even use GStreamer without a plugin
  46  * repository in which case gst_plugin_load() can be needed to bring the plugin
  47  * into memory.
  48  */
  49 
  50 #ifdef HAVE_CONFIG_H
  51 #include &quot;config.h&quot;
  52 #endif
  53 
  54 #include &quot;gst_private.h&quot;
  55 
  56 #include &lt;glib/gstdio.h&gt;
  57 #include &lt;sys/types.h&gt;
  58 #ifdef HAVE_DIRENT_H
  59 #include &lt;dirent.h&gt;
  60 #endif
  61 #ifdef HAVE_UNISTD_H
  62 #include &lt;unistd.h&gt;
  63 #endif
  64 #include &lt;signal.h&gt;
  65 #include &lt;errno.h&gt;
  66 #include &lt;string.h&gt;
  67 
  68 #include &quot;glib-compat-private.h&quot;
  69 
  70 #include &lt;gst/gst.h&gt;
  71 
  72 #ifndef GSTREAMER_LITE
  73 #define GST_CAT_DEFAULT GST_CAT_PLUGIN_LOADING
  74 #else // GSTREAMER_LITE
  75 #if !defined(GST_DISABLE_GST_DEBUG) || !defined(GST_REMOVE_DISABLED)
  76 #define GST_CAT_DEFAULT GST_CAT_PLUGIN_LOADING
  77 #else
  78 #define GST_CAT_DEFAULT NULL
  79 #endif
  80 #endif // GSTREAMER_LITE
  81 
  82 static guint _num_static_plugins;       /* 0    */
  83 static GstPluginDesc *_static_plugins;  /* NULL */
  84 static gboolean _gst_plugin_inited;
  85 static gchar **_plugin_loading_whitelist;       /* NULL */
  86 
  87 /* static variables for segfault handling of plugin loading */
  88 static char *_gst_plugin_fault_handler_filename = NULL;
  89 
  90 /* list of valid licenses.
  91  * One of these must be specified or the plugin won&#39;t be loaded
  92  * Please file a bug to request any additional license be added.
  93  *
  94  * GPL: http://www.gnu.org/copyleft/gpl.html
  95  * LGPL: http://www.gnu.org/copyleft/lesser.html
  96  * QPL: http://www.trolltech.com/licenses/qpl.html
  97  * MPL: http://www.opensource.org/licenses/mozilla1.1.php
  98  * MIT/X11: http://www.opensource.org/licenses/mit-license.php
<a name="1" id="anc1"></a><span class="line-modified">  99  * 3-clause BSD: https://opensource.org/licenses/BSD-3-Clause</span>
<span class="line-added"> 100  * Zero-Clause BSD: https://opensource.org/licenses/0BSD</span>
 101  */
 102 static const gchar valid_licenses[] = &quot;LGPL\000&quot;        /* GNU Lesser General Public License */
 103     &quot;GPL\000&quot;                   /* GNU General Public License */
 104     &quot;QPL\000&quot;                   /* Trolltech Qt Public License */
 105     &quot;GPL/QPL\000&quot;               /* Combi-license of GPL + QPL */
 106     &quot;MPL\000&quot;                   /* MPL 1.1 license */
 107     &quot;BSD\000&quot;                   /* 3-clause BSD license */
 108     &quot;MIT/X11\000&quot;               /* MIT/X11 license */
<a name="2" id="anc2"></a><span class="line-added"> 109     &quot;0BSD\000&quot;                  /* Zero-Clause BSD */</span>
 110     &quot;Proprietary\000&quot;           /* Proprietary license */
 111     GST_LICENSE_UNKNOWN;        /* some other license */
 112 
<a name="3" id="anc3"></a><span class="line-modified"> 113 static const guint8 valid_licenses_idx[] = { 0, 5, 9, 13, 21, 25, 29, 37, 42,</span>
<span class="line-added"> 114   54</span>
<span class="line-added"> 115 };</span>
 116 
 117 static GstPlugin *gst_plugin_register_func (GstPlugin * plugin,
 118     const GstPluginDesc * desc, gpointer user_data);
 119 static void gst_plugin_desc_copy (GstPluginDesc * dest,
 120     const GstPluginDesc * src);
 121 
 122 static void gst_plugin_ext_dep_free (GstPluginDep * dep);
 123 
<a name="4" id="anc4"></a><span class="line-modified"> 124 G_DEFINE_TYPE_WITH_PRIVATE (GstPlugin, gst_plugin, GST_TYPE_OBJECT);</span>
 125 
 126 static void
 127 gst_plugin_init (GstPlugin * plugin)
 128 {
<a name="5" id="anc5"></a><span class="line-modified"> 129   plugin-&gt;priv = gst_plugin_get_instance_private (plugin);</span>

 130 }
 131 
 132 static void
 133 gst_plugin_finalize (GObject * object)
 134 {
 135   GstPlugin *plugin = GST_PLUGIN_CAST (object);
 136 #ifndef GSTREAMER_LITE
 137 
 138   GST_DEBUG (&quot;finalizing plugin %&quot; GST_PTR_FORMAT, plugin);
 139 
 140   /* FIXME: make registry add a weak ref instead */
 141 #if 0
 142   GstRegistry *registry = gst_registry_get ();
 143   GList *g;
 144   for (g = registry-&gt;plugins; g; g = g-&gt;next) {
 145     if (g-&gt;data == (gpointer) plugin) {
 146       g_warning (&quot;removing plugin that is still in registry&quot;);
 147     }
 148   }
 149 #endif
 150 
 151 #endif // GSTREAMER_LITE
 152   g_free (plugin-&gt;filename);
 153   g_free (plugin-&gt;basename);
 154 
 155   g_list_foreach (plugin-&gt;priv-&gt;deps, (GFunc) gst_plugin_ext_dep_free, NULL);
 156   g_list_free (plugin-&gt;priv-&gt;deps);
 157   plugin-&gt;priv-&gt;deps = NULL;
 158 
 159   if (plugin-&gt;priv-&gt;cache_data) {
 160     gst_structure_free (plugin-&gt;priv-&gt;cache_data);
 161   }
 162 
 163   G_OBJECT_CLASS (gst_plugin_parent_class)-&gt;finalize (object);
 164 }
 165 
 166 static void
 167 gst_plugin_class_init (GstPluginClass * klass)
 168 {
 169   G_OBJECT_CLASS (klass)-&gt;finalize = gst_plugin_finalize;
<a name="6" id="anc6"></a>

 170 }
 171 
 172 GQuark
 173 gst_plugin_error_quark (void)
 174 {
 175   static GQuark quark = 0;
 176 
 177   if (!quark)
 178     quark = g_quark_from_static_string (&quot;gst_plugin_error&quot;);
 179   return quark;
 180 }
 181 
 182 /**
 183  * gst_plugin_register_static:
 184  * @major_version: the major version number of the GStreamer core that the
 185  *     plugin was compiled for, you can just use GST_VERSION_MAJOR here
 186  * @minor_version: the minor version number of the GStreamer core that the
 187  *     plugin was compiled for, you can just use GST_VERSION_MINOR here
 188  * @name: a unique name of the plugin (ideally prefixed with an application- or
 189  *     library-specific namespace prefix in order to avoid name conflicts in
 190  *     case a similar plugin with the same name ever gets added to GStreamer)
 191  * @description: description of the plugin
 192  * @init_func: (scope call): pointer to the init function of this plugin.
 193  * @version: version string of the plugin
 194  * @license: effective license of plugin. Must be one of the approved licenses
 195  *     (see #GstPluginDesc above) or the plugin will not be registered.
 196  * @source: source module plugin belongs to
 197  * @package: shipped package plugin belongs to
 198  * @origin: URL to provider of plugin
 199  *
 200  * Registers a static plugin, ie. a plugin which is private to an application
 201  * or library and contained within the application or library (as opposed to
 202  * being shipped as a separate module file).
 203  *
 204  * You must make sure that GStreamer has been initialised (with gst_init() or
 205  * via gst_init_get_option_group()) before calling this function.
 206  *
 207  * Returns: %TRUE if the plugin was registered correctly, otherwise %FALSE.
 208  */
 209 gboolean
 210 gst_plugin_register_static (gint major_version, gint minor_version,
 211     const gchar * name, const gchar * description, GstPluginInitFunc init_func,
 212     const gchar * version, const gchar * license, const gchar * source,
 213     const gchar * package, const gchar * origin)
 214 {
 215   GstPluginDesc desc = { major_version, minor_version, name, description,
 216     init_func, version, license, source, package, origin, NULL,
 217   };
 218   GstPlugin *plugin;
 219   gboolean res = FALSE;
 220 
 221   g_return_val_if_fail (name != NULL, FALSE);
 222   g_return_val_if_fail (description != NULL, FALSE);
 223   g_return_val_if_fail (init_func != NULL, FALSE);
 224   g_return_val_if_fail (version != NULL, FALSE);
 225   g_return_val_if_fail (license != NULL, FALSE);
 226   g_return_val_if_fail (source != NULL, FALSE);
 227   g_return_val_if_fail (package != NULL, FALSE);
 228   g_return_val_if_fail (origin != NULL, FALSE);
 229 
 230   /* make sure gst_init() has been called */
 231   g_return_val_if_fail (_gst_plugin_inited != FALSE, FALSE);
 232 
 233   GST_LOG (&quot;attempting to load static plugin \&quot;%s\&quot; now...&quot;, name);
 234   plugin = g_object_new (GST_TYPE_PLUGIN, NULL);
 235   if (gst_plugin_register_func (plugin, &amp;desc, NULL) != NULL) {
 236     GST_INFO (&quot;registered static plugin \&quot;%s\&quot;&quot;, name);
 237     res = gst_registry_add_plugin (gst_registry_get (), plugin);
 238     GST_INFO (&quot;added static plugin \&quot;%s\&quot;, result: %d&quot;, name, res);
 239   }
 240   return res;
 241 }
 242 
 243 /**
 244  * gst_plugin_register_static_full:
 245  * @major_version: the major version number of the GStreamer core that the
 246  *     plugin was compiled for, you can just use GST_VERSION_MAJOR here
 247  * @minor_version: the minor version number of the GStreamer core that the
 248  *     plugin was compiled for, you can just use GST_VERSION_MINOR here
 249  * @name: a unique name of the plugin (ideally prefixed with an application- or
 250  *     library-specific namespace prefix in order to avoid name conflicts in
 251  *     case a similar plugin with the same name ever gets added to GStreamer)
 252  * @description: description of the plugin
 253  * @init_full_func: (scope call): pointer to the init function with user data
 254  *     of this plugin.
 255  * @version: version string of the plugin
 256  * @license: effective license of plugin. Must be one of the approved licenses
 257  *     (see #GstPluginDesc above) or the plugin will not be registered.
 258  * @source: source module plugin belongs to
 259  * @package: shipped package plugin belongs to
 260  * @origin: URL to provider of plugin
 261  * @user_data: gpointer to user data
 262  *
 263  * Registers a static plugin, ie. a plugin which is private to an application
 264  * or library and contained within the application or library (as opposed to
 265  * being shipped as a separate module file) with a #GstPluginInitFullFunc
 266  * which allows user data to be passed to the callback function (useful
 267  * for bindings).
 268  *
 269  * You must make sure that GStreamer has been initialised (with gst_init() or
 270  * via gst_init_get_option_group()) before calling this function.
 271  *
 272  * Returns: %TRUE if the plugin was registered correctly, otherwise %FALSE.
 273  */
 274 gboolean
 275 gst_plugin_register_static_full (gint major_version, gint minor_version,
 276     const gchar * name, const gchar * description,
 277     GstPluginInitFullFunc init_full_func, const gchar * version,
 278     const gchar * license, const gchar * source, const gchar * package,
 279     const gchar * origin, gpointer user_data)
 280 {
 281   GstPluginDesc desc = { major_version, minor_version, name, description,
 282     (GstPluginInitFunc) init_full_func, version, license, source, package,
 283     origin, NULL,
 284   };
 285   GstPlugin *plugin;
 286   gboolean res = FALSE;
 287 
 288   g_return_val_if_fail (name != NULL, FALSE);
 289   g_return_val_if_fail (description != NULL, FALSE);
 290   g_return_val_if_fail (init_full_func != NULL, FALSE);
 291   g_return_val_if_fail (version != NULL, FALSE);
 292   g_return_val_if_fail (license != NULL, FALSE);
 293   g_return_val_if_fail (source != NULL, FALSE);
 294   g_return_val_if_fail (package != NULL, FALSE);
 295   g_return_val_if_fail (origin != NULL, FALSE);
 296 
 297   /* make sure gst_init() has been called */
 298   g_return_val_if_fail (_gst_plugin_inited != FALSE, FALSE);
 299 
 300   GST_LOG (&quot;attempting to load static plugin \&quot;%s\&quot; now...&quot;, name);
 301   plugin = g_object_new (GST_TYPE_PLUGIN, NULL);
 302   if (gst_plugin_register_func (plugin, &amp;desc, user_data) != NULL) {
 303     GST_INFO (&quot;registered static plugin \&quot;%s\&quot;&quot;, name);
 304     res = gst_registry_add_plugin (gst_registry_get (), plugin);
 305     GST_INFO (&quot;added static plugin \&quot;%s\&quot;, result: %d&quot;, name, res);
 306   }
 307   return res;
 308 }
 309 
 310 void
 311 _priv_gst_plugin_initialize (void)
 312 {
 313   const gchar *whitelist;
 314   guint i;
 315 
 316   _gst_plugin_inited = TRUE;
 317 
 318   whitelist = g_getenv (&quot;GST_PLUGIN_LOADING_WHITELIST&quot;);
 319   if (whitelist != NULL &amp;&amp; *whitelist != &#39;\0&#39;) {
 320     _plugin_loading_whitelist = g_strsplit (whitelist,
 321         G_SEARCHPATH_SEPARATOR_S, -1);
 322     for (i = 0; _plugin_loading_whitelist[i] != NULL; ++i) {
 323       GST_INFO (&quot;plugins whitelist entry: %s&quot;, _plugin_loading_whitelist[i]);
 324     }
 325   }
 326 
 327   /* now register all static plugins */
 328   GST_INFO (&quot;registering %u static plugins&quot;, _num_static_plugins);
 329   for (i = 0; i &lt; _num_static_plugins; ++i) {
 330     gst_plugin_register_static (_static_plugins[i].major_version,
 331         _static_plugins[i].minor_version, _static_plugins[i].name,
 332         _static_plugins[i].description, _static_plugins[i].plugin_init,
 333         _static_plugins[i].version, _static_plugins[i].license,
 334         _static_plugins[i].source, _static_plugins[i].package,
 335         _static_plugins[i].origin);
 336   }
 337 
 338   if (_static_plugins) {
 339     free (_static_plugins);
 340     _static_plugins = NULL;
 341     _num_static_plugins = 0;
 342   }
 343 }
 344 
 345 /* Whitelist entry format:
 346  *
 347  *   plugin1,plugin2@pathprefix or
 348  *   plugin1,plugin2@* or just
 349  *   plugin1,plugin2 or
 350  *   source-package@pathprefix or
 351  *   source-package@* or just
 352  *   source-package
 353  *
 354  * ie. the bit before the path will be checked against both the plugin
 355  * name and the plugin&#39;s source package name, to keep the format simple.
 356  */
 357 static gboolean
 358 gst_plugin_desc_matches_whitelist_entry (const GstPluginDesc * desc,
 359     const gchar * filename, const gchar * pattern)
 360 {
 361   const gchar *sep;
 362   gboolean ret = FALSE;
 363   gchar *name;
 364 
 365   GST_LOG (&quot;Whitelist pattern &#39;%s&#39;, plugin: %s of %s@%s&quot;, pattern, desc-&gt;name,
 366       desc-&gt;source, GST_STR_NULL (filename));
 367 
 368   /* do we have a path prefix? */
 369   sep = strchr (pattern, &#39;@&#39;);
 370   if (sep != NULL &amp;&amp; strcmp (sep, &quot;@*&quot;) != 0 &amp;&amp; strcmp (sep, &quot;@&quot;) != 0) {
 371     /* paths are not canonicalised or treated with realpath() here. This
 372      * should be good enough for our use case, since we just use the paths
 373      * autotools uses, and those will be constructed from the same prefix. */
 374     if (filename != NULL &amp;&amp; !g_str_has_prefix (filename, sep + 1))
 375       return FALSE;
 376 
 377     GST_LOG (&quot;%s matches path prefix %s&quot;, GST_STR_NULL (filename), sep + 1);
 378   }
 379 
 380   if (sep != NULL) {
 381     name = g_strndup (pattern, (gsize) (sep - pattern));
 382   } else {
 383     name = g_strdup (pattern);
 384   }
 385 
 386   g_strstrip (name);
 387   if (!g_ascii_isalnum (*name)) {
 388     GST_WARNING (&quot;Invalid whitelist pattern: %s&quot;, pattern);
 389     goto done;
 390   }
 391 
 392   /* now check plugin names / source package name */
 393   if (strchr (name, &#39;,&#39;) == NULL) {
 394     /* only a single name: either a plugin name or the source package name */
 395     ret = (strcmp (desc-&gt;source, name) == 0 || strcmp (desc-&gt;name, name) == 0);
 396   } else {
 397     gchar **n, **names;
 398 
 399     /* multiple names: assume these are plugin names */
 400     names = g_strsplit (name, &quot;,&quot;, -1);
 401     for (n = names; n != NULL &amp;&amp; *n != NULL; ++n) {
 402       g_strstrip (*n);
 403       if (strcmp (desc-&gt;name, *n) == 0) {
 404         ret = TRUE;
 405         break;
 406       }
 407     }
 408     g_strfreev (names);
 409   }
 410 
 411   GST_LOG (&quot;plugin / source package name match: %d&quot;, ret);
 412 
 413 done:
 414 
 415   g_free (name);
 416   return ret;
 417 }
 418 
 419 gboolean
 420 priv_gst_plugin_desc_is_whitelisted (const GstPluginDesc * desc,
 421     const gchar * filename)
 422 {
 423   gchar **entry;
 424 
 425   if (_plugin_loading_whitelist == NULL)
 426     return TRUE;
 427 
 428   for (entry = _plugin_loading_whitelist; *entry != NULL; ++entry) {
 429     if (gst_plugin_desc_matches_whitelist_entry (desc, filename, *entry)) {
 430       GST_LOG (&quot;Plugin %s is in whitelist&quot;, filename);
 431       return TRUE;
 432     }
 433   }
 434 
 435   GST_LOG (&quot;Plugin %s (package %s, file %s) not in whitelist&quot;, desc-&gt;name,
 436       desc-&gt;source, filename);
 437   return FALSE;
 438 }
 439 
 440 gboolean
 441 priv_gst_plugin_loading_have_whitelist (void)
 442 {
 443   return (_plugin_loading_whitelist != NULL);
 444 }
 445 
 446 guint32
 447 priv_gst_plugin_loading_get_whitelist_hash (void)
 448 {
 449   guint32 hash = 0;
 450 
 451   if (_plugin_loading_whitelist != NULL) {
 452     gchar **w;
 453 
 454     for (w = _plugin_loading_whitelist; *w != NULL; ++w)
 455       hash ^= g_str_hash (*w);
 456   }
 457 
 458   return hash;
 459 }
 460 
 461 /* this function could be extended to check if the plugin license matches the
 462  * applications license (would require the app to register its license somehow).
 463  * We&#39;ll wait for someone who&#39;s interested in it to code it :)
 464  */
 465 static gboolean
 466 gst_plugin_check_license (const gchar * license)
 467 {
 468   gint i;
 469 
 470   for (i = 0; i &lt; G_N_ELEMENTS (valid_licenses_idx); ++i) {
 471     if (strcmp (license, valid_licenses + valid_licenses_idx[i]) == 0)
 472       return TRUE;
 473   }
 474   return FALSE;
 475 }
 476 
 477 static gboolean
 478 gst_plugin_check_version (gint major, gint minor)
 479 {
 480   /* return NULL if the major and minor version numbers are not compatible */
 481   /* with ours. */
 482   if (major != GST_VERSION_MAJOR || minor &gt; GST_VERSION_MINOR)
 483     return FALSE;
 484 
 485   return TRUE;
 486 }
 487 
 488 static GstPlugin *
 489 gst_plugin_register_func (GstPlugin * plugin, const GstPluginDesc * desc,
 490     gpointer user_data)
 491 {
 492   if (!gst_plugin_check_version (desc-&gt;major_version, desc-&gt;minor_version)) {
 493     if (GST_CAT_DEFAULT)
 494       GST_WARNING (&quot;plugin \&quot;%s\&quot; has incompatible version &quot;
 495           &quot;(plugin: %d.%d, gst: %d,%d), not loading&quot;,
 496           GST_STR_NULL (plugin-&gt;filename), desc-&gt;major_version,
 497           desc-&gt;minor_version, GST_VERSION_MAJOR, GST_VERSION_MINOR);
 498     return NULL;
 499   }
 500 
 501   if (!desc-&gt;license || !desc-&gt;description || !desc-&gt;source ||
 502       !desc-&gt;package || !desc-&gt;origin) {
 503     if (GST_CAT_DEFAULT)
 504       GST_WARNING (&quot;plugin \&quot;%s\&quot; has missing detail in GstPluginDesc, not &quot;
 505           &quot;loading&quot;, GST_STR_NULL (plugin-&gt;filename));
 506     return NULL;
 507   }
 508 
 509   if (!gst_plugin_check_license (desc-&gt;license)) {
 510     if (GST_CAT_DEFAULT)
 511       GST_WARNING (&quot;plugin \&quot;%s\&quot; has invalid license \&quot;%s\&quot;, not loading&quot;,
 512           GST_STR_NULL (plugin-&gt;filename), desc-&gt;license);
 513     return NULL;
 514   }
 515 
 516   if (GST_CAT_DEFAULT)
 517     GST_LOG (&quot;plugin \&quot;%s\&quot; looks good&quot;, GST_STR_NULL (plugin-&gt;filename));
 518 
 519   gst_plugin_desc_copy (&amp;plugin-&gt;desc, desc);
 520 
 521   /* make resident so we&#39;re really sure it never gets unloaded again.
 522    * Theoretically this is not needed, but practically it doesn&#39;t hurt.
 523    * And we&#39;re rather safe than sorry. */
 524   if (plugin-&gt;module)
 525     g_module_make_resident (plugin-&gt;module);
 526 
 527   if (user_data) {
 528     if (!(((GstPluginInitFullFunc) (desc-&gt;plugin_init)) (plugin, user_data))) {
 529       if (GST_CAT_DEFAULT)
 530         GST_WARNING (&quot;plugin \&quot;%s\&quot; failed to initialise&quot;,
 531             GST_STR_NULL (plugin-&gt;filename));
 532       return NULL;
 533     }
 534   } else {
 535     if (!((desc-&gt;plugin_init) (plugin))) {
 536       if (GST_CAT_DEFAULT)
 537         GST_WARNING (&quot;plugin \&quot;%s\&quot; failed to initialise&quot;,
 538             GST_STR_NULL (plugin-&gt;filename));
 539       return NULL;
 540     }
 541   }
 542 
 543   if (GST_CAT_DEFAULT)
 544     GST_LOG (&quot;plugin \&quot;%s\&quot; initialised&quot;, GST_STR_NULL (plugin-&gt;filename));
 545 
 546   return plugin;
 547 }
 548 
 549 #ifdef HAVE_SIGACTION
 550 static struct sigaction oldaction;
 551 static gboolean _gst_plugin_fault_handler_is_setup = FALSE;
 552 
 553 /*
 554  * _gst_plugin_fault_handler_restore:
 555  * segfault handler restorer
 556  */
 557 static void
 558 _gst_plugin_fault_handler_restore (void)
 559 {
 560   if (!_gst_plugin_fault_handler_is_setup)
 561     return;
 562 
 563   _gst_plugin_fault_handler_is_setup = FALSE;
 564 
 565   sigaction (SIGSEGV, &amp;oldaction, NULL);
 566 }
 567 
 568 /*
 569  * _gst_plugin_fault_handler_sighandler:
 570  * segfault handler implementation
 571  */
 572 static void
 573 _gst_plugin_fault_handler_sighandler (int signum)
 574 {
 575   /* We need to restore the fault handler or we&#39;ll keep getting it */
 576   _gst_plugin_fault_handler_restore ();
 577 
 578   switch (signum) {
 579     case SIGSEGV:
 580       g_print (&quot;\nERROR: &quot;);
 581       g_print (&quot;Caught a segmentation fault while loading plugin file:\n&quot;);
 582       g_print (&quot;%s\n\n&quot;, _gst_plugin_fault_handler_filename);
 583       g_print (&quot;Please either:\n&quot;);
 584       g_print (&quot;- remove it and restart.\n&quot;);
 585       g_print
 586           (&quot;- run with --gst-disable-segtrap --gst-disable-registry-fork and debug.\n&quot;);
 587       exit (-1);
 588       break;
 589     default:
 590       g_print (&quot;Caught unhandled signal on plugin loading\n&quot;);
 591       break;
 592   }
 593 }
 594 
 595 /*
 596  * _gst_plugin_fault_handler_setup:
 597  * sets up the segfault handler
 598  */
 599 static void
 600 _gst_plugin_fault_handler_setup (void)
 601 {
 602   struct sigaction action;
 603 
 604   /* if asked to leave segfaults alone, just return */
 605   if (!gst_segtrap_is_enabled ())
 606     return;
 607 
 608   if (_gst_plugin_fault_handler_is_setup)
 609     return;
 610 
 611   _gst_plugin_fault_handler_is_setup = TRUE;
 612 
 613   memset (&amp;action, 0, sizeof (action));
 614   action.sa_handler = _gst_plugin_fault_handler_sighandler;
 615 
 616   sigaction (SIGSEGV, &amp;action, &amp;oldaction);
 617 }
 618 #else /* !HAVE_SIGACTION */
 619 static void
 620 _gst_plugin_fault_handler_restore (void)
 621 {
 622 }
 623 
 624 static void
 625 _gst_plugin_fault_handler_setup (void)
 626 {
 627 }
 628 #endif /* HAVE_SIGACTION */
 629 
 630 /* g_time_val_from_iso8601() doesn&#39;t do quite what we want */
 631 static gboolean
 632 check_release_datetime (const gchar * date_time)
 633 {
 634   guint64 val;
 635 
 636   /* we require YYYY-MM-DD or YYYY-MM-DDTHH:MMZ format */
 637   if (!g_ascii_isdigit (*date_time))
 638     return FALSE;
 639 
 640   val = g_ascii_strtoull (date_time, (gchar **) &amp; date_time, 10);
 641   if (val &lt; 2000 || val &gt; 2100 || *date_time != &#39;-&#39;)
 642     return FALSE;
 643 
 644   val = g_ascii_strtoull (date_time + 1, (gchar **) &amp; date_time, 10);
 645   if (val == 0 || val &gt; 12 || *date_time != &#39;-&#39;)
 646     return FALSE;
 647 
 648   val = g_ascii_strtoull (date_time + 1, (gchar **) &amp; date_time, 10);
 649   if (val == 0 || val &gt; 32)
 650     return FALSE;
 651 
 652   /* end of string or date/time separator + HH:MMZ */
 653   if (*date_time == &#39;T&#39; || *date_time == &#39; &#39;) {
 654     val = g_ascii_strtoull (date_time + 1, (gchar **) &amp; date_time, 10);
 655     if (val &gt; 24 || *date_time != &#39;:&#39;)
 656       return FALSE;
 657 
 658     val = g_ascii_strtoull (date_time + 1, (gchar **) &amp; date_time, 10);
 659     if (val &gt; 59 || *date_time != &#39;Z&#39;)
 660       return FALSE;
 661 
 662     ++date_time;
 663   }
 664 
 665   return (*date_time == &#39;\0&#39;);
 666 }
 667 
 668 static GMutex gst_plugin_loading_mutex;
 669 
 670 #define CHECK_PLUGIN_DESC_FIELD(desc,field,fn)                               \
 671   if (G_UNLIKELY ((desc)-&gt;field == NULL || *(desc)-&gt;field == &#39;\0&#39;)) {        \
 672     g_warning (&quot;Plugin description for &#39;%s&#39; has no valid %s field&quot;, fn, G_STRINGIFY (field)); \
 673     g_set_error (error, GST_PLUGIN_ERROR, GST_PLUGIN_ERROR_MODULE, \
 674         &quot;Plugin %s has invalid plugin description field &#39;%s&#39;&quot;, \
 675         filename, G_STRINGIFY (field)); \
 676     goto return_error;                                                       \
 677   }
 678 
 679 /**
 680  * gst_plugin_load_file:
 681  * @filename: (type filename): the plugin filename to load
 682  * @error: pointer to a %NULL-valued GError
 683  *
 684  * Loads the given plugin and refs it.  Caller needs to unref after use.
 685  *
 686  * Returns: (transfer full): a reference to the existing loaded GstPlugin, a
 687  * reference to the newly-loaded GstPlugin, or %NULL if an error occurred.
 688  */
 689 GstPlugin *
 690 gst_plugin_load_file (const gchar * filename, GError ** error)
 691 {
 692   return _priv_gst_plugin_load_file_for_registry (filename, NULL, error);
 693 }
 694 
 695 static gchar *
 696 extract_symname (const char *filename)
 697 {
 698   gchar *bname, *name, *symname;
 699   const gchar *dot;
 700   gsize prefix_len, len;
 701   int i;
 702 
 703   bname = g_path_get_basename (filename);
 704   for (i = 0; bname[i]; ++i) {
 705     if (bname[i] == &#39;-&#39;)
 706       bname[i] = &#39;_&#39;;
 707   }
 708 
 709   if (g_str_has_prefix (bname, &quot;libgst&quot;))
 710     prefix_len = 6;
 711   else if (g_str_has_prefix (bname, &quot;lib&quot;))
 712     prefix_len = 3;
 713   else if (g_str_has_prefix (bname, &quot;gst&quot;))
 714     prefix_len = 3;
 715   else
 716     prefix_len = 0;             /* use whole name (minus suffix) as plugin name */
 717 
 718   dot = g_utf8_strchr (bname, -1, &#39;.&#39;);
 719   if (dot)
 720     len = dot - bname - prefix_len;
 721   else
 722     len = strlen (bname + prefix_len);
 723 
 724   name = g_strndup (bname + prefix_len, len);
 725   g_free (bname);
 726 
 727   symname = g_strconcat (&quot;gst_plugin_&quot;, name, &quot;_get_desc&quot;, NULL);
 728   g_free (name);
 729 
 730   return symname;
 731 }
 732 
 733 /* Note: The return value is (transfer full) although we work with floating
 734  * references here. If a new plugin instance is created, it is always sinked
 735  * in the registry first and a new reference is returned
 736  */
 737 GstPlugin *
 738 _priv_gst_plugin_load_file_for_registry (const gchar * filename,
 739     GstRegistry * registry, GError ** error)
 740 {
 741   const GstPluginDesc *desc;
 742   GstPlugin *plugin;
 743   gchar *symname;
 744   GModule *module;
 745   gboolean ret;
 746   gpointer ptr;
 747   GStatBuf file_status;
 748   gboolean new_plugin = TRUE;
 749   GModuleFlags flags;
 750 
 751   g_return_val_if_fail (filename != NULL, NULL);
 752 
 753   if (registry == NULL)
<a name="7" id="anc7"></a><span class="line-modified"> 754     registry = gst_registry_get ();</span>
 755 
 756   g_mutex_lock (&amp;gst_plugin_loading_mutex);
 757 
 758   plugin = gst_registry_lookup (registry, filename);
 759   if (plugin) {
 760     if (plugin-&gt;module) {
 761       /* already loaded */
 762       g_mutex_unlock (&amp;gst_plugin_loading_mutex);
 763       return plugin;
 764     } else {
 765       /* load plugin and update fields */
 766       new_plugin = FALSE;
 767     }
 768   }
 769 
 770   GST_CAT_DEBUG (GST_CAT_PLUGIN_LOADING, &quot;attempt to load plugin \&quot;%s\&quot;&quot;,
 771       filename);
 772 
 773   if (!g_module_supported ()) {
 774     GST_CAT_DEBUG (GST_CAT_PLUGIN_LOADING, &quot;module loading not supported&quot;);
 775     g_set_error (error,
 776         GST_PLUGIN_ERROR,
 777         GST_PLUGIN_ERROR_MODULE, &quot;Dynamic loading not supported&quot;);
 778     goto return_error;
 779   }
 780 
 781   if (g_stat (filename, &amp;file_status)) {
 782     GST_CAT_DEBUG (GST_CAT_PLUGIN_LOADING, &quot;problem accessing file&quot;);
 783     g_set_error (error,
 784         GST_PLUGIN_ERROR,
 785         GST_PLUGIN_ERROR_MODULE, &quot;Problem accessing file %s: %s&quot;, filename,
 786         g_strerror (errno));
 787     goto return_error;
 788   }
 789 
 790   flags = G_MODULE_BIND_LOCAL;
 791   /* libgstpython.so is the gst-python plugin loader. It needs to be loaded with
 792    * G_MODULE_BIND_LAZY.
 793    *
 794    * Ideally there should be a generic way for plugins to specify that they
 795    * need to be loaded with _LAZY.
 796    * */
 797   if (strstr (filename, &quot;libgstpython&quot;))
 798     flags |= G_MODULE_BIND_LAZY;
 799 
 800   module = g_module_open (filename, flags);
 801   if (module == NULL) {
 802     GST_CAT_WARNING (GST_CAT_PLUGIN_LOADING, &quot;module_open failed: %s&quot;,
 803         g_module_error ());
 804     g_set_error (error,
 805         GST_PLUGIN_ERROR, GST_PLUGIN_ERROR_MODULE, &quot;Opening module failed: %s&quot;,
 806         g_module_error ());
 807     /* If we failed to open the shared object, then it&#39;s probably because a
 808      * plugin is linked against the wrong libraries. Print out an easy-to-see
 809      * message in this case. */
 810     g_warning (&quot;Failed to load plugin &#39;%s&#39;: %s&quot;, filename, g_module_error ());
 811     goto return_error;
 812   }
 813 
 814   symname = extract_symname (filename);
 815   ret = g_module_symbol (module, symname, &amp;ptr);
 816 
 817   if (ret) {
 818     GstPluginDesc *(*get_desc) (void) = ptr;
 819     ptr = get_desc ();
 820   } else {
 821     GST_DEBUG (&quot;Could not find symbol &#39;%s&#39;, falling back to gst_plugin_desc&quot;,
 822         symname);
<a name="8" id="anc8"></a><span class="line-modified"> 823     ret = g_module_symbol (module, &quot;gst_plugin_desc&quot;, &amp;ptr);</span>
 824   }
 825 
 826   g_free (symname);
 827 
 828   if (!ret) {
 829     GST_DEBUG (&quot;Could not find plugin entry point in \&quot;%s\&quot;&quot;, filename);
 830     g_set_error (error,
 831         GST_PLUGIN_ERROR,
 832         GST_PLUGIN_ERROR_MODULE,
 833         &quot;File \&quot;%s\&quot; is not a GStreamer plugin&quot;, filename);
 834     g_module_close (module);
 835     goto return_error;
 836   }
 837 
 838   desc = (const GstPluginDesc *) ptr;
 839 
 840   if (priv_gst_plugin_loading_have_whitelist () &amp;&amp;
 841       !priv_gst_plugin_desc_is_whitelisted (desc, filename)) {
 842     GST_INFO (&quot;Whitelist specified and plugin not in whitelist, not loading: &quot;
 843         &quot;name=%s, package=%s, file=%s&quot;, desc-&gt;name, desc-&gt;source, filename);
 844     g_set_error (error, GST_PLUGIN_ERROR, GST_PLUGIN_ERROR_MODULE,
 845         &quot;Not loading plugin file \&quot;%s\&quot;, not in whitelist&quot;, filename);
 846     g_module_close (module);
 847     goto return_error;
 848   }
 849 
 850   if (new_plugin) {
 851     plugin = g_object_new (GST_TYPE_PLUGIN, NULL);
 852     plugin-&gt;file_mtime = file_status.st_mtime;
 853     plugin-&gt;file_size = file_status.st_size;
 854     plugin-&gt;filename = g_strdup (filename);
 855     plugin-&gt;basename = g_path_get_basename (filename);
 856   }
 857 
 858   plugin-&gt;module = module;
 859 
 860   if (new_plugin) {
 861     /* check plugin description: complain about bad values and fail */
 862     CHECK_PLUGIN_DESC_FIELD (desc, name, filename);
 863     CHECK_PLUGIN_DESC_FIELD (desc, description, filename);
 864     CHECK_PLUGIN_DESC_FIELD (desc, version, filename);
 865     CHECK_PLUGIN_DESC_FIELD (desc, license, filename);
 866     CHECK_PLUGIN_DESC_FIELD (desc, source, filename);
 867     CHECK_PLUGIN_DESC_FIELD (desc, package, filename);
 868     CHECK_PLUGIN_DESC_FIELD (desc, origin, filename);
 869 
 870     if (desc-&gt;name != NULL &amp;&amp; desc-&gt;name[0] == &#39;&quot;&#39;) {
 871       g_warning (&quot;Invalid plugin name &#39;%s&#39; - fix your GST_PLUGIN_DEFINE &quot;
 872           &quot;(remove quotes around plugin name)&quot;, desc-&gt;name);
 873     }
 874 
 875     if (desc-&gt;release_datetime != NULL &amp;&amp;
 876         !check_release_datetime (desc-&gt;release_datetime)) {
 877       g_warning (&quot;GstPluginDesc for &#39;%s&#39; has invalid datetime &#39;%s&#39;&quot;,
 878           filename, desc-&gt;release_datetime);
 879       g_set_error (error, GST_PLUGIN_ERROR, GST_PLUGIN_ERROR_MODULE,
 880           &quot;Plugin %s has invalid plugin description field &#39;release_datetime&#39;&quot;,
 881           filename);
 882       goto return_error;
 883     }
 884   }
 885 
 886   GST_LOG (&quot;Plugin %p for file \&quot;%s\&quot; prepared, calling entry function...&quot;,
 887       plugin, filename);
 888 
 889   /* this is where we load the actual .so, so let&#39;s trap SIGSEGV */
 890   _gst_plugin_fault_handler_setup ();
 891   _gst_plugin_fault_handler_filename = plugin-&gt;filename;
 892 
 893   GST_LOG (&quot;Plugin %p for file \&quot;%s\&quot; prepared, registering...&quot;,
 894       plugin, filename);
 895 
 896   if (!gst_plugin_register_func (plugin, desc, NULL)) {
 897     /* remove signal handler */
 898     _gst_plugin_fault_handler_restore ();
 899     GST_DEBUG (&quot;gst_plugin_register_func failed for plugin \&quot;%s\&quot;&quot;, filename);
 900     /* plugin == NULL */
 901     g_set_error (error,
 902         GST_PLUGIN_ERROR,
 903         GST_PLUGIN_ERROR_MODULE,
 904         &quot;File \&quot;%s\&quot; appears to be a GStreamer plugin, but it failed to initialize&quot;,
 905         filename);
 906     goto return_error;
 907   }
 908 
 909   /* remove signal handler */
 910   _gst_plugin_fault_handler_restore ();
 911   _gst_plugin_fault_handler_filename = NULL;
 912   GST_INFO (&quot;plugin \&quot;%s\&quot; loaded&quot;, plugin-&gt;filename);
 913 
 914   if (new_plugin) {
 915     gst_object_ref (plugin);
 916     gst_registry_add_plugin (registry, plugin);
 917   }
 918 
 919   g_mutex_unlock (&amp;gst_plugin_loading_mutex);
 920   return plugin;
 921 
 922 return_error:
 923   {
 924     if (plugin)
 925       gst_object_unref (plugin);
 926     g_mutex_unlock (&amp;gst_plugin_loading_mutex);
 927     return NULL;
 928   }
 929 }
 930 
 931 static void
 932 gst_plugin_desc_copy (GstPluginDesc * dest, const GstPluginDesc * src)
 933 {
 934   dest-&gt;major_version = src-&gt;major_version;
 935   dest-&gt;minor_version = src-&gt;minor_version;
 936   dest-&gt;name = g_intern_string (src-&gt;name);
 937   dest-&gt;description = g_intern_string (src-&gt;description);
 938   dest-&gt;plugin_init = src-&gt;plugin_init;
 939   dest-&gt;version = g_intern_string (src-&gt;version);
 940   dest-&gt;license = g_intern_string (src-&gt;license);
 941   dest-&gt;source = g_intern_string (src-&gt;source);
 942   dest-&gt;package = g_intern_string (src-&gt;package);
 943   dest-&gt;origin = g_intern_string (src-&gt;origin);
 944   dest-&gt;release_datetime = g_intern_string (src-&gt;release_datetime);
 945 }
 946 
 947 /**
 948  * gst_plugin_get_name:
 949  * @plugin: plugin to get the name of
 950  *
 951  * Get the short name of the plugin
 952  *
 953  * Returns: the name of the plugin
 954  */
 955 const gchar *
 956 gst_plugin_get_name (GstPlugin * plugin)
 957 {
 958   g_return_val_if_fail (plugin != NULL, NULL);
 959 
 960   return plugin-&gt;desc.name;
 961 }
 962 
 963 /**
 964  * gst_plugin_get_description:
 965  * @plugin: plugin to get long name of
 966  *
 967  * Get the long descriptive name of the plugin
 968  *
 969  * Returns: the long name of the plugin
 970  */
 971 const gchar *
 972 gst_plugin_get_description (GstPlugin * plugin)
 973 {
 974   g_return_val_if_fail (plugin != NULL, NULL);
 975 
 976   return plugin-&gt;desc.description;
 977 }
 978 
 979 /**
 980  * gst_plugin_get_filename:
 981  * @plugin: plugin to get the filename of
 982  *
 983  * get the filename of the plugin
 984  *
 985  * Returns: (type filename): the filename of the plugin
 986  */
 987 const gchar *
 988 gst_plugin_get_filename (GstPlugin * plugin)
 989 {
 990   g_return_val_if_fail (plugin != NULL, NULL);
 991 
 992   return plugin-&gt;filename;
 993 }
 994 
 995 /**
 996  * gst_plugin_get_version:
 997  * @plugin: plugin to get the version of
 998  *
 999  * get the version of the plugin
1000  *
1001  * Returns: the version of the plugin
1002  */
1003 const gchar *
1004 gst_plugin_get_version (GstPlugin * plugin)
1005 {
1006   g_return_val_if_fail (plugin != NULL, NULL);
1007 
1008   return plugin-&gt;desc.version;
1009 }
1010 
1011 /**
1012  * gst_plugin_get_license:
1013  * @plugin: plugin to get the license of
1014  *
1015  * get the license of the plugin
1016  *
1017  * Returns: the license of the plugin
1018  */
1019 const gchar *
1020 gst_plugin_get_license (GstPlugin * plugin)
1021 {
1022   g_return_val_if_fail (plugin != NULL, NULL);
1023 
1024   return plugin-&gt;desc.license;
1025 }
1026 
1027 /**
1028  * gst_plugin_get_source:
1029  * @plugin: plugin to get the source of
1030  *
1031  * get the source module the plugin belongs to.
1032  *
1033  * Returns: the source of the plugin
1034  */
1035 const gchar *
1036 gst_plugin_get_source (GstPlugin * plugin)
1037 {
1038   g_return_val_if_fail (plugin != NULL, NULL);
1039 
1040   return plugin-&gt;desc.source;
1041 }
1042 
1043 /**
1044  * gst_plugin_get_package:
1045  * @plugin: plugin to get the package of
1046  *
1047  * get the package the plugin belongs to.
1048  *
1049  * Returns: the package of the plugin
1050  */
1051 const gchar *
1052 gst_plugin_get_package (GstPlugin * plugin)
1053 {
1054   g_return_val_if_fail (plugin != NULL, NULL);
1055 
1056   return plugin-&gt;desc.package;
1057 }
1058 
1059 /**
1060  * gst_plugin_get_origin:
1061  * @plugin: plugin to get the origin of
1062  *
1063  * get the URL where the plugin comes from
1064  *
1065  * Returns: the origin of the plugin
1066  */
1067 const gchar *
1068 gst_plugin_get_origin (GstPlugin * plugin)
1069 {
1070   g_return_val_if_fail (plugin != NULL, NULL);
1071 
1072   return plugin-&gt;desc.origin;
1073 }
1074 
1075 /**
1076  * gst_plugin_get_release_date_string:
1077  * @plugin: plugin to get the release date of
1078  *
1079  * Get the release date (and possibly time) in form of a string, if available.
1080  *
1081  * For normal GStreamer plugin releases this will usually just be a date in
1082  * the form of &quot;YYYY-MM-DD&quot;, while pre-releases and builds from git may contain
1083  * a time component after the date as well, in which case the string will be
1084  * formatted like &quot;YYYY-MM-DDTHH:MMZ&quot; (e.g. &quot;2012-04-30T09:30Z&quot;).
1085  *
1086  * There may be plugins that do not have a valid release date set on them.
1087  *
1088  * Returns: (nullable): the date string of the plugin, or %NULL if not
1089  * available.
1090  */
1091 const gchar *
1092 gst_plugin_get_release_date_string (GstPlugin * plugin)
1093 {
1094   g_return_val_if_fail (plugin != NULL, NULL);
1095 
1096   return plugin-&gt;desc.release_datetime;
1097 }
1098 
1099 /**
1100  * gst_plugin_is_loaded:
1101  * @plugin: plugin to query
1102  *
1103  * queries if the plugin is loaded into memory
1104  *
1105  * Returns: %TRUE is loaded, %FALSE otherwise
1106  */
1107 gboolean
1108 gst_plugin_is_loaded (GstPlugin * plugin)
1109 {
1110   g_return_val_if_fail (plugin != NULL, FALSE);
1111 
1112   return (plugin-&gt;module != NULL || plugin-&gt;filename == NULL);
1113 }
1114 
1115 /**
1116  * gst_plugin_get_cache_data:
1117  * @plugin: a plugin
1118  *
1119  * Gets the plugin specific data cache. If it is %NULL there is no cached data
1120  * stored. This is the case when the registry is getting rebuilt.
1121  *
1122  * Returns: (transfer none) (nullable): The cached data as a
1123  * #GstStructure or %NULL.
1124  */
1125 const GstStructure *
1126 gst_plugin_get_cache_data (GstPlugin * plugin)
1127 {
1128   g_return_val_if_fail (GST_IS_PLUGIN (plugin), NULL);
1129 
1130   return plugin-&gt;priv-&gt;cache_data;
1131 }
1132 
1133 /**
1134  * gst_plugin_set_cache_data:
1135  * @plugin: a plugin
1136  * @cache_data: (transfer full): a structure containing the data to cache
1137  *
1138  * Adds plugin specific data to cache. Passes the ownership of the structure to
1139  * the @plugin.
1140  *
1141  * The cache is flushed every time the registry is rebuilt.
1142  */
1143 void
1144 gst_plugin_set_cache_data (GstPlugin * plugin, GstStructure * cache_data)
1145 {
1146   g_return_if_fail (GST_IS_PLUGIN (plugin));
1147   g_return_if_fail (GST_IS_STRUCTURE (cache_data));
1148 
1149   if (plugin-&gt;priv-&gt;cache_data) {
1150     gst_structure_free (plugin-&gt;priv-&gt;cache_data);
1151   }
1152   plugin-&gt;priv-&gt;cache_data = cache_data;
1153 }
1154 
1155 #if 0
1156 /**
1157  * gst_plugin_feature_list:
1158  * @plugin: plugin to query
1159  * @filter: the filter to use
1160  * @first: only return first match
1161  * @user_data: user data passed to the filter function
1162  *
1163  * Runs a filter against all plugin features and returns a GList with
1164  * the results. If the first flag is set, only the first match is
1165  * returned (as a list with a single object).
1166  *
1167  * Returns: a GList of features, g_list_free after use.
1168  */
1169 GList *
1170 gst_plugin_feature_filter (GstPlugin * plugin,
1171     GstPluginFeatureFilter filter, gboolean first, gpointer user_data)
1172 {
1173   GList *list;
1174   GList *g;
1175 
1176   list = gst_filter_run (plugin-&gt;features, (GstFilterFunc) filter, first,
1177       user_data);
1178   for (g = list; g; g = g-&gt;next) {
1179     gst_object_ref (plugin);
1180   }
1181 
1182   return list;
1183 }
1184 
1185 typedef struct
1186 {
1187   GstPluginFeatureFilter filter;
1188   gboolean first;
1189   gpointer user_data;
1190   GList *result;
1191 }
1192 FeatureFilterData;
1193 
1194 static gboolean
1195 _feature_filter (GstPlugin * plugin, gpointer user_data)
1196 {
1197   GList *result;
1198   FeatureFilterData *data = (FeatureFilterData *) user_data;
1199 
1200   result = gst_plugin_feature_filter (plugin, data-&gt;filter, data-&gt;first,
1201       data-&gt;user_data);
1202   if (result) {
1203     data-&gt;result = g_list_concat (data-&gt;result, result);
1204     return TRUE;
1205   }
1206   return FALSE;
1207 }
1208 
1209 /**
1210  * gst_plugin_list_feature_filter:
1211  * @list: a #GList of plugins to query
1212  * @filter: the filter function to use
1213  * @first: only return first match
1214  * @user_data: user data passed to the filter function
1215  *
1216  * Runs a filter against all plugin features of the plugins in the given
1217  * list and returns a GList with the results.
1218  * If the first flag is set, only the first match is
1219  * returned (as a list with a single object).
1220  *
1221  * Returns: a GList of features, g_list_free after use.
1222  */
1223 GList *
1224 gst_plugin_list_feature_filter (GList * list,
1225     GstPluginFeatureFilter filter, gboolean first, gpointer user_data)
1226 {
1227   FeatureFilterData data;
1228   GList *result;
1229 
1230   data.filter = filter;
1231   data.first = first;
1232   data.user_data = user_data;
1233   data.result = NULL;
1234 
1235   result = gst_filter_run (list, (GstFilterFunc) _feature_filter, first, &amp;data);
1236   g_list_free (result);
1237 
1238   return data.result;
1239 }
1240 
1241 /**
1242  * gst_plugin_find_feature:
1243  * @plugin: plugin to get the feature from
1244  * @name: The name of the feature to find
1245  * @type: The type of the feature to find
1246  *
1247  * Find a feature of the given name and type in the given plugin.
1248  *
1249  * Returns: a GstPluginFeature or %NULL if the feature was not found.
1250  */
1251 GstPluginFeature *
1252 gst_plugin_find_feature (GstPlugin * plugin, const gchar * name, GType type)
1253 {
1254   GList *walk;
1255   GstPluginFeature *result = NULL;
1256   GstTypeNameData data;
1257 
1258   g_return_val_if_fail (name != NULL, NULL);
1259 
1260   data.type = type;
1261   data.name = name;
1262 
1263   walk = gst_filter_run (plugin-&gt;features,
1264       (GstFilterFunc) gst_plugin_feature_type_name_filter, TRUE, &amp;data);
1265 
1266   if (walk) {
1267     result = GST_PLUGIN_FEATURE (walk-&gt;data);
1268 
1269     gst_object_ref (result);
1270     gst_plugin_feature_list_free (walk);
1271   }
1272 
1273   return result;
1274 }
1275 #endif
1276 
1277 #if 0
1278 static gboolean
1279 gst_plugin_feature_name_filter (GstPluginFeature * feature, const gchar * name)
1280 {
1281   return !strcmp (name, GST_PLUGIN_FEATURE_NAME (feature));
1282 }
1283 #endif
1284 
1285 #if 0
1286 /**
1287  * gst_plugin_find_feature_by_name:
1288  * @plugin: plugin to get the feature from
1289  * @name: The name of the feature to find
1290  *
1291  * Find a feature of the given name in the given plugin.
1292  *
1293  * Returns: a GstPluginFeature or %NULL if the feature was not found.
1294  */
1295 GstPluginFeature *
1296 gst_plugin_find_feature_by_name (GstPlugin * plugin, const gchar * name)
1297 {
1298   GList *walk;
1299   GstPluginFeature *result = NULL;
1300 
1301   g_return_val_if_fail (name != NULL, NULL);
1302 
1303   walk = gst_filter_run (plugin-&gt;features,
1304       (GstFilterFunc) gst_plugin_feature_name_filter, TRUE, (void *) name);
1305 
1306   if (walk) {
1307     result = GST_PLUGIN_FEATURE (walk-&gt;data);
1308 
1309     gst_object_ref (result);
1310     gst_plugin_feature_list_free (walk);
1311   }
1312 
1313   return result;
1314 }
1315 #endif
1316 
1317 /**
1318  * gst_plugin_load_by_name:
1319  * @name: name of plugin to load
1320  *
1321  * Load the named plugin. Refs the plugin.
1322  *
1323  * Returns: (transfer full) (nullable): a reference to a loaded plugin, or
1324  * %NULL on error.
1325  */
1326 GstPlugin *
1327 gst_plugin_load_by_name (const gchar * name)
1328 {
1329   GstPlugin *plugin, *newplugin;
1330   GError *error = NULL;
1331 
1332   GST_DEBUG (&quot;looking up plugin %s in default registry&quot;, name);
1333   plugin = gst_registry_find_plugin (gst_registry_get (), name);
1334   if (plugin) {
1335     GST_DEBUG (&quot;loading plugin %s from file %s&quot;, name, plugin-&gt;filename);
1336     newplugin = gst_plugin_load_file (plugin-&gt;filename, &amp;error);
1337     gst_object_unref (plugin);
1338 
1339     if (!newplugin) {
1340       GST_WARNING (&quot;load_plugin error: %s&quot;, error-&gt;message);
1341       g_error_free (error);
1342       return NULL;
1343     }
1344     /* newplugin was reffed by load_file */
1345     return newplugin;
1346   }
1347 
1348   GST_DEBUG (&quot;Could not find plugin %s in registry&quot;, name);
1349   return NULL;
1350 }
1351 
1352 /**
1353  * gst_plugin_load:
1354  * @plugin: (transfer none): plugin to load
1355  *
1356  * Loads @plugin. Note that the *return value* is the loaded plugin; @plugin is
1357  * untouched. The normal use pattern of this function goes like this:
1358  *
1359  * |[
1360  * GstPlugin *loaded_plugin;
1361  * loaded_plugin = gst_plugin_load (plugin);
1362  * // presumably, we&#39;re no longer interested in the potentially-unloaded plugin
1363  * gst_object_unref (plugin);
1364  * plugin = loaded_plugin;
1365  * ]|
1366  *
1367  * Returns: (transfer full) (nullable): a reference to a loaded plugin, or
1368  * %NULL on error.
1369  */
1370 GstPlugin *
1371 gst_plugin_load (GstPlugin * plugin)
1372 {
1373   GError *error = NULL;
1374   GstPlugin *newplugin;
1375 
1376   if (gst_plugin_is_loaded (plugin)) {
1377     return gst_object_ref (plugin);
1378   }
1379 
1380   if (!(newplugin = gst_plugin_load_file (plugin-&gt;filename, &amp;error)))
1381     goto load_error;
1382 
1383   return newplugin;
1384 
1385 load_error:
1386   {
1387     GST_WARNING (&quot;load_plugin error: %s&quot;, error-&gt;message);
1388     g_error_free (error);
1389     return NULL;
1390   }
1391 }
1392 
1393 /**
1394  * gst_plugin_list_free:
1395  * @list: (transfer full) (element-type Gst.Plugin): list of #GstPlugin
1396  *
1397  * Unrefs each member of @list, then frees the list.
1398  */
1399 void
1400 gst_plugin_list_free (GList * list)
1401 {
1402   GList *g;
1403 
1404   for (g = list; g; g = g-&gt;next) {
1405     gst_object_unref (GST_PLUGIN_CAST (g-&gt;data));
1406   }
1407   g_list_free (list);
1408 }
1409 
1410 /* ===== plugin dependencies ===== */
1411 
1412 /* Scenarios:
1413  * ENV + xyz     where ENV can contain multiple values separated by SEPARATOR
1414  *               xyz may be &quot;&quot; (if ENV contains path to file rather than dir)
1415  * ENV + *xyz   same as above, but xyz acts as suffix filter
1416  * ENV + xyz*   same as above, but xyz acts as prefix filter (is this needed?)
1417  * ENV + *xyz*  same as above, but xyz acts as strstr filter (is this needed?)
1418  *
1419  * same as above, with additional paths hard-coded at compile-time:
1420  *   - only check paths + ... if ENV is not set or yields not paths
1421  *   - always check paths + ... in addition to ENV
1422  *
1423  * When user specifies set of environment variables, he/she may also use e.g.
1424  * &quot;HOME/.mystuff/plugins&quot;, and we&#39;ll expand the content of $HOME with the
1425  * remainder
1426  */
1427 
1428 /* we store in registry:
1429  *  sets of:
1430  *   {
1431  *     - environment variables (array of strings)
1432  *     - last hash of env variable contents (uint) (so we can avoid doing stats
1433  *       if one of the env vars has changed; premature optimisation galore)
1434  *     - hard-coded paths (array of strings)
1435  *     - xyz filename/suffix/prefix strings (array of strings)
1436  *     - flags (int)
1437  *     - last hash of file/dir stats (int)
1438  *   }
1439  *   (= struct GstPluginDep)
1440  */
1441 
1442 static guint
1443 gst_plugin_ext_dep_get_env_vars_hash (GstPlugin * plugin, GstPluginDep * dep)
1444 {
1445   gchar **e;
1446   guint hash;
1447 
1448   /* there&#39;s no deeper logic to what we do here; all we want to know (when
1449    * checking if the plugin needs to be rescanned) is whether the content of
1450    * one of the environment variables in the list is different from when it
1451    * was last scanned */
1452   hash = 0;
1453   for (e = dep-&gt;env_vars; e != NULL &amp;&amp; *e != NULL; ++e) {
1454     const gchar *val;
1455     gchar env_var[256];
1456 
1457     /* order matters: &quot;val&quot;,NULL needs to yield a different hash than
1458      * NULL,&quot;val&quot;, so do a shift here whether the var is set or not */
1459     hash = hash &lt;&lt; 5;
1460 
1461     /* want environment variable at beginning of string */
1462     if (!g_ascii_isalnum (**e)) {
1463       GST_WARNING_OBJECT (plugin, &quot;string prefix is not a valid environment &quot;
1464           &quot;variable string: %s&quot;, *e);
1465       continue;
1466     }
1467 
1468     /* user is allowed to specify e.g. &quot;HOME/.pitivi/plugins&quot; */
1469     g_strlcpy (env_var, *e, sizeof (env_var));
1470     g_strdelimit (env_var, &quot;/\\&quot;, &#39;\0&#39;);
1471 
1472     if ((val = g_getenv (env_var)))
1473       hash += g_str_hash (val);
1474   }
1475 
1476   return hash;
1477 }
1478 
1479 gboolean
1480 _priv_plugin_deps_env_vars_changed (GstPlugin * plugin)
1481 {
1482   GList *l;
1483 
1484   for (l = plugin-&gt;priv-&gt;deps; l != NULL; l = l-&gt;next) {
1485     GstPluginDep *dep = l-&gt;data;
1486 
1487     if (dep-&gt;env_hash != gst_plugin_ext_dep_get_env_vars_hash (plugin, dep))
1488       return TRUE;
1489   }
1490 
1491   return FALSE;
1492 }
1493 
1494 static void
1495 gst_plugin_ext_dep_extract_env_vars_paths (GstPlugin * plugin,
1496     GstPluginDep * dep, GQueue * paths)
1497 {
1498   gchar **evars;
1499 
1500   for (evars = dep-&gt;env_vars; evars != NULL &amp;&amp; *evars != NULL; ++evars) {
1501     const gchar *e;
1502     gchar **components;
1503 
1504     /* want environment variable at beginning of string */
1505     if (!g_ascii_isalnum (**evars)) {
1506       GST_WARNING_OBJECT (plugin, &quot;string prefix is not a valid environment &quot;
1507           &quot;variable string: %s&quot;, *evars);
1508       continue;
1509     }
1510 
1511     /* user is allowed to specify e.g. &quot;HOME/.pitivi/plugins&quot;, which we want to
1512      * split into the env_var name component and the path component */
1513     components = g_strsplit_set (*evars, &quot;/\\&quot;, 2);
1514     g_assert (components != NULL);
1515 
1516     e = g_getenv (components[0]);
1517     GST_LOG_OBJECT (plugin, &quot;expanding %s = &#39;%s&#39; (path suffix: %s)&quot;,
1518         components[0], GST_STR_NULL (e), GST_STR_NULL (components[1]));
1519 
1520     if (components[1] != NULL) {
1521       g_strdelimit (components[1], &quot;/\\&quot;, G_DIR_SEPARATOR);
1522     }
1523 
1524     if (e != NULL &amp;&amp; *e != &#39;\0&#39;) {
1525       gchar **arr;
1526       guint i;
1527 
1528       arr = g_strsplit (e, G_SEARCHPATH_SEPARATOR_S, -1);
1529 
1530       for (i = 0; arr != NULL &amp;&amp; arr[i] != NULL; ++i) {
1531         gchar *full_path;
1532 
1533         if (!g_path_is_absolute (arr[i])) {
1534           GST_INFO_OBJECT (plugin, &quot;ignoring environment variable content &#39;%s&#39;&quot;
1535               &quot;: either not an absolute path or not a path at all&quot;, arr[i]);
1536           continue;
1537         }
1538 
1539         if (components[1] != NULL) {
1540           full_path = g_build_filename (arr[i], components[1], NULL);
1541         } else {
1542           full_path = g_strdup (arr[i]);
1543         }
1544 
1545         if (!g_queue_find_custom (paths, full_path, (GCompareFunc) strcmp)) {
1546           GST_LOG_OBJECT (plugin, &quot;path: &#39;%s&#39;&quot;, full_path);
1547           g_queue_push_tail (paths, full_path);
1548           full_path = NULL;
1549         } else {
1550           GST_LOG_OBJECT (plugin, &quot;path: &#39;%s&#39; (duplicate,ignoring)&quot;, full_path);
1551           g_free (full_path);
1552         }
1553       }
1554 
1555       g_strfreev (arr);
1556     }
1557 
1558     g_strfreev (components);
1559   }
1560 
1561   GST_LOG_OBJECT (plugin, &quot;Extracted %d paths from environment&quot;, paths-&gt;length);
1562 }
1563 
1564 static guint
1565 gst_plugin_ext_dep_get_hash_from_stat_entry (GStatBuf * s)
1566 {
1567 #ifdef S_IFBLK
1568   if (!(s-&gt;st_mode &amp; (S_IFDIR | S_IFREG | S_IFBLK | S_IFCHR)))
1569 #else
1570   /* MSVC does not have S_IFBLK */
1571   if (!(s-&gt;st_mode &amp; (S_IFDIR | S_IFREG | S_IFCHR)))
1572 #endif
1573     return (guint) - 1;
1574 
1575   /* completely random formula */
1576   return ((s-&gt;st_size &lt;&lt; 3) + (s-&gt;st_mtime &lt;&lt; 5)) ^ s-&gt;st_ctime;
1577 }
1578 
1579 static gboolean
1580 gst_plugin_ext_dep_direntry_matches (GstPlugin * plugin, const gchar * entry,
1581     const gchar ** filenames, GstPluginDependencyFlags flags)
1582 {
1583   /* no filenames specified, match all entries for now (could probably
1584    * optimise by just taking the dir stat hash or so) */
1585   if (filenames == NULL || *filenames == NULL || **filenames == &#39;\0&#39;)
1586     return TRUE;
1587 
1588   while (*filenames != NULL) {
1589     /* suffix match? */
1590     if (((flags &amp; GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_SUFFIX)) &amp;&amp;
1591         g_str_has_suffix (entry, *filenames)) {
1592       return TRUE;
1593     } else if (((flags &amp; GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_PREFIX)) &amp;&amp;
1594         g_str_has_prefix (entry, *filenames)) {
1595       return TRUE;
1596       /* else it&#39;s an exact match that&#39;s needed */
1597     } else if (strcmp (entry, *filenames) == 0) {
1598       return TRUE;
1599     }
1600     GST_LOG (&quot;%s does not match %s, flags=0x%04x&quot;, entry, *filenames, flags);
1601     ++filenames;
1602   }
1603   return FALSE;
1604 }
1605 
1606 static guint
1607 gst_plugin_ext_dep_scan_dir_and_match_names (GstPlugin * plugin,
1608     const gchar * path, const gchar ** filenames,
1609     GstPluginDependencyFlags flags, int depth)
1610 {
1611   const gchar *entry;
1612   gboolean recurse_dirs;
1613   GError *err = NULL;
1614   GDir *dir;
1615   guint hash = 0;
1616 
1617   recurse_dirs = ! !(flags &amp; GST_PLUGIN_DEPENDENCY_FLAG_RECURSE);
1618 
1619   dir = g_dir_open (path, 0, &amp;err);
1620   if (dir == NULL) {
1621     GST_DEBUG_OBJECT (plugin, &quot;g_dir_open(%s) failed: %s&quot;, path, err-&gt;message);
1622     g_error_free (err);
1623     return (guint) - 1;
1624   }
1625 
1626   /* FIXME: we&#39;re assuming here that we always get the directory entries in
1627    * the same order, and not in a random order */
1628   while ((entry = g_dir_read_name (dir))) {
1629     gboolean have_match;
1630     GStatBuf s;
1631     gchar *full_path;
1632     guint fhash;
1633 
1634     have_match =
1635         gst_plugin_ext_dep_direntry_matches (plugin, entry, filenames, flags);
1636 
1637     /* avoid the stat if possible */
1638     if (!have_match &amp;&amp; !recurse_dirs)
1639       continue;
1640 
1641     full_path = g_build_filename (path, entry, NULL);
1642     if (g_stat (full_path, &amp;s) &lt; 0) {
1643       fhash = (guint) - 1;
1644       GST_LOG_OBJECT (plugin, &quot;stat: %s (error: %s)&quot;, full_path,
1645           g_strerror (errno));
1646     } else if (have_match) {
1647       fhash = gst_plugin_ext_dep_get_hash_from_stat_entry (&amp;s);
1648       GST_LOG_OBJECT (plugin, &quot;stat: %s (result: %u)&quot;, full_path, fhash);
1649     } else if ((s.st_mode &amp; (S_IFDIR))) {
1650       fhash = gst_plugin_ext_dep_scan_dir_and_match_names (plugin, full_path,
1651           filenames, flags, depth + 1);
1652     } else {
1653       /* it&#39;s not a name match, we want to recurse, but it&#39;s not a directory */
1654       g_free (full_path);
1655       continue;
1656     }
1657 
1658     hash = hash + fhash;
1659     g_free (full_path);
1660   }
1661 
1662   g_dir_close (dir);
1663   return hash;
1664 }
1665 
1666 static guint
1667 gst_plugin_ext_dep_scan_path_with_filenames (GstPlugin * plugin,
1668     const gchar * path, const gchar ** filenames,
1669     GstPluginDependencyFlags flags)
1670 {
1671   const gchar *empty_filenames[] = { &quot;&quot;, NULL };
1672   gboolean recurse_into_dirs, partial_names = FALSE;
1673   guint i, hash = 0;
1674 
1675   /* to avoid special-casing below (FIXME?) */
1676   if (filenames == NULL || *filenames == NULL)
1677     filenames = empty_filenames;
1678 
1679   recurse_into_dirs = ! !(flags &amp; GST_PLUGIN_DEPENDENCY_FLAG_RECURSE);
1680 
1681   if ((flags &amp; GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_SUFFIX) ||
1682       (flags &amp; GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_PREFIX))
1683     partial_names = TRUE;
1684 
1685   /* if we can construct the exact paths to check with the data we have, just
1686    * stat them one by one; this is more efficient than opening the directory
1687    * and going through each entry to see if it matches one of our filenames. */
1688   if (!recurse_into_dirs &amp;&amp; !partial_names) {
1689     for (i = 0; filenames[i] != NULL; ++i) {
1690       GStatBuf s;
1691       gchar *full_path;
1692       guint fhash;
1693 
1694       full_path = g_build_filename (path, filenames[i], NULL);
1695       if (g_stat (full_path, &amp;s) &lt; 0) {
1696         fhash = (guint) - 1;
1697         GST_LOG_OBJECT (plugin, &quot;stat: %s (error: %s)&quot;, full_path,
1698             g_strerror (errno));
1699       } else {
1700         fhash = gst_plugin_ext_dep_get_hash_from_stat_entry (&amp;s);
1701         GST_LOG_OBJECT (plugin, &quot;stat: %s (result: %08x)&quot;, full_path, fhash);
1702       }
1703       hash += fhash;
1704       g_free (full_path);
1705     }
1706   } else {
1707     hash = gst_plugin_ext_dep_scan_dir_and_match_names (plugin, path,
1708         filenames, flags, 0);
1709   }
1710 
1711   return hash;
1712 }
1713 
1714 static guint
1715 gst_plugin_ext_dep_get_stat_hash (GstPlugin * plugin, GstPluginDep * dep)
1716 {
1717   gboolean paths_are_default_only;
1718   gboolean paths_are_relative_to_exe;
1719   GQueue scan_paths = G_QUEUE_INIT;
1720   guint scan_hash = 0;
1721   gchar *path;
1722 
1723   GST_LOG_OBJECT (plugin, &quot;start&quot;);
1724 
1725   paths_are_default_only =
1726       dep-&gt;flags &amp; GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_DEFAULT_ONLY;
1727   paths_are_relative_to_exe =
1728       dep-&gt;flags &amp; GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_RELATIVE_TO_EXE;
1729 
1730   gst_plugin_ext_dep_extract_env_vars_paths (plugin, dep, &amp;scan_paths);
1731 
1732   if (g_queue_is_empty (&amp;scan_paths) || !paths_are_default_only) {
1733     gchar **paths;
1734 
1735     for (paths = dep-&gt;paths; paths != NULL &amp;&amp; *paths != NULL; ++paths) {
1736       const gchar *path = *paths;
1737       gchar *full_path;
1738 
1739       if (paths_are_relative_to_exe &amp;&amp; !g_path_is_absolute (path)) {
1740         gchar *appdir;
1741 
1742         if (!_gst_executable_path) {
1743           GST_FIXME_OBJECT (plugin,
1744               &quot;Path dependency %s relative to executable path but could not retrieve executable path&quot;,
1745               path);
1746           continue;
1747         }
1748         appdir = g_path_get_dirname (_gst_executable_path);
1749         full_path = g_build_filename (appdir, path, NULL);
1750         g_free (appdir);
1751       } else {
1752         full_path = g_strdup (path);
1753       }
1754 
1755       if (!g_queue_find_custom (&amp;scan_paths, full_path, (GCompareFunc) strcmp)) {
1756         GST_LOG_OBJECT (plugin, &quot;path: &#39;%s&#39;&quot;, full_path);
1757         g_queue_push_tail (&amp;scan_paths, full_path);
1758       } else {
1759         GST_LOG_OBJECT (plugin, &quot;path: &#39;%s&#39; (duplicate, ignoring)&quot;, full_path);
1760         g_free (full_path);
<a name="9" id="anc9"></a><span class="line-added">1761       }</span>
1762     }
1763   }
<a name="10" id="anc10"></a>
1764 
1765   while ((path = g_queue_pop_head (&amp;scan_paths))) {
1766     scan_hash += gst_plugin_ext_dep_scan_path_with_filenames (plugin, path,
1767         (const gchar **) dep-&gt;names, dep-&gt;flags);
1768     g_free (path);
1769   }
1770 
1771   GST_LOG_OBJECT (plugin, &quot;done, scan_hash: %08x&quot;, scan_hash);
1772   return scan_hash;
1773 }
1774 
1775 gboolean
1776 _priv_plugin_deps_files_changed (GstPlugin * plugin)
1777 {
1778   GList *l;
1779 
1780   for (l = plugin-&gt;priv-&gt;deps; l != NULL; l = l-&gt;next) {
1781     GstPluginDep *dep = l-&gt;data;
1782 
1783     if (dep-&gt;stat_hash != gst_plugin_ext_dep_get_stat_hash (plugin, dep))
1784       return TRUE;
1785   }
1786 
1787   return FALSE;
1788 }
1789 
1790 static void
1791 gst_plugin_ext_dep_free (GstPluginDep * dep)
1792 {
1793   g_strfreev (dep-&gt;env_vars);
1794   g_strfreev (dep-&gt;paths);
1795   g_strfreev (dep-&gt;names);
1796   g_slice_free (GstPluginDep, dep);
1797 }
1798 
1799 static gboolean
1800 gst_plugin_ext_dep_strv_equal (gchar ** arr1, gchar ** arr2)
1801 {
1802   if (arr1 == arr2)
1803     return TRUE;
1804   if (arr1 == NULL || arr2 == NULL)
1805     return FALSE;
1806   for (; *arr1 != NULL &amp;&amp; *arr2 != NULL; ++arr1, ++arr2) {
1807     if (strcmp (*arr1, *arr2) != 0)
1808       return FALSE;
1809   }
1810   return (*arr1 == *arr2);
1811 }
1812 
1813 static gboolean
1814 gst_plugin_ext_dep_equals (GstPluginDep * dep, const gchar ** env_vars,
1815     const gchar ** paths, const gchar ** names, GstPluginDependencyFlags flags)
1816 {
1817   if (dep-&gt;flags != flags)
1818     return FALSE;
1819 
1820   return gst_plugin_ext_dep_strv_equal (dep-&gt;env_vars, (gchar **) env_vars) &amp;&amp;
1821       gst_plugin_ext_dep_strv_equal (dep-&gt;paths, (gchar **) paths) &amp;&amp;
1822       gst_plugin_ext_dep_strv_equal (dep-&gt;names, (gchar **) names);
1823 }
1824 
1825 /**
1826  * gst_plugin_add_dependency:
1827  * @plugin: a #GstPlugin
1828  * @env_vars: (allow-none) (array zero-terminated=1): %NULL-terminated array of environment variables affecting the
1829  *     feature set of the plugin (e.g. an environment variable containing
1830  *     paths where to look for additional modules/plugins of a library),
1831  *     or %NULL. Environment variable names may be followed by a path component
1832  *      which will be added to the content of the environment variable, e.g.
1833  *      &quot;HOME/.mystuff/plugins&quot;.
1834  * @paths: (allow-none) (array zero-terminated=1): %NULL-terminated array of directories/paths where dependent files
1835  *     may be, or %NULL.
1836  * @names: (allow-none) (array zero-terminated=1): %NULL-terminated array of file names (or file name suffixes,
1837  *     depending on @flags) to be used in combination with the paths from
1838  *     @paths and/or the paths extracted from the environment variables in
1839  *     @env_vars, or %NULL.
1840  * @flags: optional flags, or #GST_PLUGIN_DEPENDENCY_FLAG_NONE
1841  *
1842  * Make GStreamer aware of external dependencies which affect the feature
1843  * set of this plugin (ie. the elements or typefinders associated with it).
1844  *
1845  * GStreamer will re-inspect plugins with external dependencies whenever any
1846  * of the external dependencies change. This is useful for plugins which wrap
1847  * other plugin systems, e.g. a plugin which wraps a plugin-based visualisation
1848  * library and makes visualisations available as GStreamer elements, or a
1849  * codec loader which exposes elements and/or caps dependent on what external
1850  * codec libraries are currently installed.
1851  */
1852 void
1853 gst_plugin_add_dependency (GstPlugin * plugin, const gchar ** env_vars,
1854     const gchar ** paths, const gchar ** names, GstPluginDependencyFlags flags)
1855 {
1856   GstPluginDep *dep;
1857   GList *l;
1858 
1859   g_return_if_fail (GST_IS_PLUGIN (plugin));
1860 
1861   if ((env_vars == NULL || env_vars[0] == NULL) &amp;&amp;
1862       (paths == NULL || paths[0] == NULL)) {
1863     GST_DEBUG_OBJECT (plugin,
1864         &quot;plugin registered empty dependency set. Ignoring&quot;);
1865     return;
1866   }
1867 
1868   for (l = plugin-&gt;priv-&gt;deps; l != NULL; l = l-&gt;next) {
1869     if (gst_plugin_ext_dep_equals (l-&gt;data, env_vars, paths, names, flags)) {
1870       GST_LOG_OBJECT (plugin, &quot;dependency already registered&quot;);
1871       return;
1872     }
1873   }
1874 
1875   dep = g_slice_new (GstPluginDep);
1876 
1877   dep-&gt;env_vars = g_strdupv ((gchar **) env_vars);
1878   dep-&gt;paths = g_strdupv ((gchar **) paths);
1879   dep-&gt;names = g_strdupv ((gchar **) names);
1880   dep-&gt;flags = flags;
1881 
1882   dep-&gt;env_hash = gst_plugin_ext_dep_get_env_vars_hash (plugin, dep);
1883   dep-&gt;stat_hash = gst_plugin_ext_dep_get_stat_hash (plugin, dep);
1884 
1885   plugin-&gt;priv-&gt;deps = g_list_append (plugin-&gt;priv-&gt;deps, dep);
1886 
1887   GST_DEBUG_OBJECT (plugin, &quot;added dependency:&quot;);
1888   for (; env_vars != NULL &amp;&amp; *env_vars != NULL; ++env_vars)
1889     GST_DEBUG_OBJECT (plugin, &quot; evar: %s&quot;, *env_vars);
1890   for (; paths != NULL &amp;&amp; *paths != NULL; ++paths)
1891     GST_DEBUG_OBJECT (plugin, &quot; path: %s&quot;, *paths);
1892   for (; names != NULL &amp;&amp; *names != NULL; ++names)
1893     GST_DEBUG_OBJECT (plugin, &quot; name: %s&quot;, *names);
1894 }
1895 
1896 /**
1897  * gst_plugin_add_dependency_simple:
1898  * @plugin: the #GstPlugin
1899  * @env_vars: (allow-none): one or more environment variables (separated by &#39;:&#39;, &#39;;&#39; or &#39;,&#39;),
1900  *      or %NULL. Environment variable names may be followed by a path component
1901  *      which will be added to the content of the environment variable, e.g.
1902  *      &quot;HOME/.mystuff/plugins:MYSTUFF_PLUGINS_PATH&quot;
1903  * @paths: (allow-none): one ore more directory paths (separated by &#39;:&#39; or &#39;;&#39; or &#39;,&#39;),
1904  *      or %NULL. Example: &quot;/usr/lib/mystuff/plugins&quot;
1905  * @names: (allow-none): one or more file names or file name suffixes (separated by commas),
1906  *      or %NULL
1907  * @flags: optional flags, or #GST_PLUGIN_DEPENDENCY_FLAG_NONE
1908  *
1909  * Make GStreamer aware of external dependencies which affect the feature
1910  * set of this plugin (ie. the elements or typefinders associated with it).
1911  *
1912  * GStreamer will re-inspect plugins with external dependencies whenever any
1913  * of the external dependencies change. This is useful for plugins which wrap
1914  * other plugin systems, e.g. a plugin which wraps a plugin-based visualisation
1915  * library and makes visualisations available as GStreamer elements, or a
1916  * codec loader which exposes elements and/or caps dependent on what external
1917  * codec libraries are currently installed.
1918  *
1919  * Convenience wrapper function for gst_plugin_add_dependency() which
1920  * takes simple strings as arguments instead of string arrays, with multiple
1921  * arguments separated by predefined delimiters (see above).
1922  */
1923 void
1924 gst_plugin_add_dependency_simple (GstPlugin * plugin,
1925     const gchar * env_vars, const gchar * paths, const gchar * names,
1926     GstPluginDependencyFlags flags)
1927 {
1928   gchar **a_evars = NULL;
1929   gchar **a_paths = NULL;
1930   gchar **a_names = NULL;
1931 
1932   if (env_vars)
1933     a_evars = g_strsplit_set (env_vars, &quot;:;,&quot;, -1);
1934   if (paths)
1935     a_paths = g_strsplit_set (paths, &quot;:;,&quot;, -1);
1936   if (names)
1937     a_names = g_strsplit_set (names, &quot;,&quot;, -1);
1938 
1939   gst_plugin_add_dependency (plugin, (const gchar **) a_evars,
1940       (const gchar **) a_paths, (const gchar **) a_names, flags);
1941 
1942   if (a_evars)
1943     g_strfreev (a_evars);
1944   if (a_paths)
1945     g_strfreev (a_paths);
1946   if (a_names)
1947     g_strfreev (a_names);
1948 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>