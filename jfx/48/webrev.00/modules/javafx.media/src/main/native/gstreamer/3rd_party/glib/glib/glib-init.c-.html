<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/glib-init.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright ï¿½ 2011 Canonical Limited
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Lesser General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2.1 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful, but
 10  * WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Lesser General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Lesser General Public
 15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 16  *
 17  * Author: Ryan Lortie &lt;desrt@desrt.ca&gt;
 18  */
 19 
 20 #include &quot;config.h&quot;
 21 
 22 #include &quot;glib-init.h&quot;
 23 
 24 #include &quot;glib-private.h&quot;
 25 #include &quot;gtypes.h&quot;
 26 #include &quot;gutils.h&quot;     /* for GDebugKey */
 27 #include &quot;gconstructor.h&quot;
 28 #include &quot;gmem.h&quot;       /* for g_mem_gc_friendly */
 29 
 30 #include &lt;string.h&gt;
 31 #include &lt;stdlib.h&gt;
 32 #include &lt;stdio.h&gt;
 33 #include &lt;ctype.h&gt;
 34 
 35 /* This seems as good a place as any to make static assertions about platform
 36  * assumptions we make throughout GLib. */
 37 
 38 /* We do not support 36-bit bytes or other historical curiosities. */
 39 G_STATIC_ASSERT (CHAR_BIT == 8);
 40 
 41 /* We assume that data pointers are the same size as function pointers... */
 42 G_STATIC_ASSERT (sizeof (gpointer) == sizeof (GFunc));
 43 G_STATIC_ASSERT (_g_alignof (gpointer) == _g_alignof (GFunc));
 44 /* ... and that all function pointers are the same size. */
 45 G_STATIC_ASSERT (sizeof (GFunc) == sizeof (GCompareDataFunc));
 46 G_STATIC_ASSERT (_g_alignof (GFunc) == _g_alignof (GCompareDataFunc));
 47 
 48 /* We assume that &quot;small&quot; enums (those where all values fit in INT32_MIN
 49  * to INT32_MAX) are exactly int-sized. In particular, we assume that if
 50  * an enum has no members that exceed the range of char/short, the
 51  * compiler will make it int-sized anyway, so adding a member later that
 52  * *does* exceed the range of char/short is not an ABI break. */
 53 typedef enum {
 54     TEST_CHAR_0 = 0
 55 } TestChar;
 56 typedef enum {
 57     TEST_SHORT_0 = 0,
 58     TEST_SHORT_256 = 256
 59 } TestShort;
 60 typedef enum {
 61     TEST_INT32_MIN = G_MININT32,
 62     TEST_INT32_MAX = G_MAXINT32
 63 } TestInt;
 64 G_STATIC_ASSERT (sizeof (TestChar) == sizeof (int));
 65 G_STATIC_ASSERT (sizeof (TestShort) == sizeof (int));
 66 G_STATIC_ASSERT (sizeof (TestInt) == sizeof (int));
 67 G_STATIC_ASSERT (_g_alignof (TestChar) == _g_alignof (int));
 68 G_STATIC_ASSERT (_g_alignof (TestShort) == _g_alignof (int));
 69 G_STATIC_ASSERT (_g_alignof (TestInt) == _g_alignof (int));
 70 
 71 /**
 72  * g_mem_gc_friendly:
 73  *
 74  * This variable is %TRUE if the `G_DEBUG` environment variable
 75  * includes the key `gc-friendly`.
 76  */
 77 gboolean g_mem_gc_friendly = FALSE;
 78 
 79 GLogLevelFlags g_log_msg_prefix = G_LOG_LEVEL_ERROR | G_LOG_LEVEL_WARNING |
 80                                   G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_DEBUG;
 81 GLogLevelFlags g_log_always_fatal = G_LOG_FATAL_MASK;
 82 
 83 static gboolean
 84 debug_key_matches (const gchar *key,
 85                    const gchar *token,
 86                    guint        length)
 87 {
 88   /* may not call GLib functions: see note in g_parse_debug_string() */
 89   for (; length; length--, key++, token++)
 90     {
 91       char k = (*key   == &#39;_&#39;) ? &#39;-&#39; : tolower (*key  );
 92       char t = (*token == &#39;_&#39;) ? &#39;-&#39; : tolower (*token);
 93 
 94       if (k != t)
 95         return FALSE;
 96     }
 97 
 98   return *key == &#39;\0&#39;;
 99 }
100 
101 /* The GVariant documentation indirectly says that int is at least 32 bits
102  * (by saying that b, y, n, q, i, u, h are promoted to int). On any
103  * reasonable platform, int is in fact *exactly* 32 bits long, because
104  * otherwise, {signed char, short, int} wouldn&#39;t be sufficient to provide
105  * {int8_t, int16_t, int32_t}. */
106 G_STATIC_ASSERT (sizeof (int) == sizeof (gint32));
107 
108 /**
109  * g_parse_debug_string:
110  * @string: (nullable): a list of debug options separated by colons, spaces, or
111  * commas, or %NULL.
112  * @keys: (array length=nkeys): pointer to an array of #GDebugKey which associate
113  *     strings with bit flags.
114  * @nkeys: the number of #GDebugKeys in the array.
115  *
116  * Parses a string containing debugging options
117  * into a %guint containing bit flags. This is used
118  * within GDK and GTK+ to parse the debug options passed on the
119  * command line or through environment variables.
120  *
121  * If @string is equal to &quot;all&quot;, all flags are set. Any flags
122  * specified along with &quot;all&quot; in @string are inverted; thus,
123  * &quot;all,foo,bar&quot; or &quot;foo,bar,all&quot; sets all flags except those
124  * corresponding to &quot;foo&quot; and &quot;bar&quot;.
125  *
126  * If @string is equal to &quot;help&quot;, all the available keys in @keys
127  * are printed out to standard error.
128  *
129  * Returns: the combined set of bit flags.
130  */
131 guint
132 g_parse_debug_string  (const gchar     *string,
133                        const GDebugKey *keys,
134                        guint            nkeys)
135 {
136   guint i;
137   guint result = 0;
138 
139   if (string == NULL)
140     return 0;
141 
142   /* this function is used during the initialisation of gmessages, gmem
143    * and gslice, so it may not do anything that causes memory to be
144    * allocated or risks messages being emitted.
145    *
146    * this means, more or less, that this code may not call anything
147    * inside GLib.
148    */
149 
150   if (!strcasecmp (string, &quot;help&quot;))
151     {
152       /* using stdio directly for the reason stated above */
153       fprintf (stderr, &quot;Supported debug values:&quot;);
154       for (i = 0; i &lt; nkeys; i++)
155        fprintf (stderr, &quot; %s&quot;, keys[i].key);
156       fprintf (stderr, &quot; all help\n&quot;);
157     }
158   else
159     {
160       const gchar *p = string;
161       const gchar *q;
162       gboolean invert = FALSE;
163 
164       while (*p)
165        {
166          q = strpbrk (p, &quot;:;, \t&quot;);
167          if (!q)
168            q = p + strlen (p);
169 
170          if (debug_key_matches (&quot;all&quot;, p, q - p))
171            {
172              invert = TRUE;
173            }
174          else
175            {
176              for (i = 0; i &lt; nkeys; i++)
177                if (debug_key_matches (keys[i].key, p, q - p))
178                  result |= keys[i].value;
179            }
180 
181          p = q;
182          if (*p)
183            p++;
184        }
185 
186       if (invert)
187         {
188           guint all_flags = 0;
189 
190           for (i = 0; i &lt; nkeys; i++)
191             all_flags |= keys[i].value;
192 
193           result = all_flags &amp; (~result);
194         }
195     }
196 
197   return result;
198 }
199 
200 static guint
201 g_parse_debug_envvar (const gchar     *envvar,
202                       const GDebugKey *keys,
203                       gint             n_keys,
204                       guint            default_value)
205 {
206   const gchar *value;
207 
208 #ifdef OS_WIN32
209   /* &quot;fatal-warnings,fatal-criticals,all,help&quot; is pretty short */
210   gchar buffer[100];
211 
212   if (GetEnvironmentVariable (envvar, buffer, 100) &lt; 100)
213     value = buffer;
214   else
215     return 0;
216 #else
217   value = getenv (envvar);
218 #endif
219 
220   if (value == NULL)
221     return default_value;
222 
223   return g_parse_debug_string (value, keys, n_keys);
224 }
225 
226 static void
227 g_messages_prefixed_init (void)
228 {
229   const GDebugKey keys[] = {
230     { &quot;error&quot;, G_LOG_LEVEL_ERROR },
231     { &quot;critical&quot;, G_LOG_LEVEL_CRITICAL },
232     { &quot;warning&quot;, G_LOG_LEVEL_WARNING },
233     { &quot;message&quot;, G_LOG_LEVEL_MESSAGE },
234     { &quot;info&quot;, G_LOG_LEVEL_INFO },
235     { &quot;debug&quot;, G_LOG_LEVEL_DEBUG }
236   };
237 
238   g_log_msg_prefix = g_parse_debug_envvar (&quot;G_MESSAGES_PREFIXED&quot;, keys, G_N_ELEMENTS (keys), g_log_msg_prefix);
239 }
240 
241 static void
242 g_debug_init (void)
243 {
244   const GDebugKey keys[] = {
245     { &quot;gc-friendly&quot;, 1 },
246     {&quot;fatal-warnings&quot;,  G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL },
247     {&quot;fatal-criticals&quot;, G_LOG_LEVEL_CRITICAL }
248   };
249   GLogLevelFlags flags;
250 
251   flags = g_parse_debug_envvar (&quot;G_DEBUG&quot;, keys, G_N_ELEMENTS (keys), 0);
252 
253   g_log_always_fatal |= flags &amp; G_LOG_LEVEL_MASK;
254 
255   g_mem_gc_friendly = flags &amp; 1;
256 }
257 
258 void
259 glib_init (void)
260 {
261   static gboolean glib_inited;
262 
263   if (glib_inited)
264     return;
265 
266   glib_inited = TRUE;
267 
268   g_messages_prefixed_init ();
269   g_debug_init ();
270   g_quark_init ();
271 }
272 
273 #if defined (G_OS_WIN32)
274 
275 BOOL WINAPI DllMain (HINSTANCE hinstDLL,
276                      DWORD     fdwReason,
277                      LPVOID    lpvReserved);
278 
279 HMODULE glib_dll;
280 
281 BOOL WINAPI
282 DllMain (HINSTANCE hinstDLL,
283          DWORD     fdwReason,
284          LPVOID    lpvReserved)
285 {
286   switch (fdwReason)
287     {
288     case DLL_PROCESS_ATTACH:
289       glib_dll = hinstDLL;
290       g_clock_win32_init ();
291 #ifdef THREADS_WIN32
292       g_thread_win32_init ();
293 #endif
294       glib_init ();
295       /* must go after glib_init */
296       g_console_win32_init ();
297       break;
298 
299     case DLL_THREAD_DETACH:
300 #ifdef THREADS_WIN32
301       g_thread_win32_thread_detach ();
302 #endif
303       break;
304 
305     case DLL_PROCESS_DETACH:
306 #ifdef THREADS_WIN32
307       if (lpvReserved == NULL)
308         g_thread_win32_process_detach ();
309 #endif
310       break;
311 
312     default:
313       /* do nothing */
314       ;
315     }
316 
317   return TRUE;
318 }
319 
320 #elif defined (G_HAS_CONSTRUCTORS)
321 
322 #ifdef G_DEFINE_CONSTRUCTOR_NEEDS_PRAGMA
323 #pragma G_DEFINE_CONSTRUCTOR_PRAGMA_ARGS(glib_init_ctor)
324 #endif
325 G_DEFINE_CONSTRUCTOR(glib_init_ctor)
326 
327 static void
328 glib_init_ctor (void)
329 {
330   glib_init ();
331 }
332 
333 #else
334 # error Your platform/compiler is missing constructor support
335 #endif
    </pre>
  </body>
</html>