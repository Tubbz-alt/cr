<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gutils.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1998  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe for the unix part, FIXME: make the win32 part MT safe as well.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #include &quot;gutils.h&quot;
  32 #include &quot;gutilsprivate.h&quot;
  33 
  34 #include &lt;stdarg.h&gt;
  35 #include &lt;stdlib.h&gt;
  36 #include &lt;stdio.h&gt;
  37 #include &lt;locale.h&gt;
  38 #include &lt;string.h&gt;
  39 #include &lt;ctype.h&gt;    /* For tolower() */
  40 #include &lt;errno.h&gt;
  41 #include &lt;sys/types.h&gt;
  42 #include &lt;sys/stat.h&gt;
  43 #ifdef G_OS_UNIX
  44 #include &lt;pwd.h&gt;
  45 #include &lt;unistd.h&gt;
  46 #endif
  47 #include &lt;sys/types.h&gt;
  48 #ifdef HAVE_SYS_PARAM_H
  49 #include &lt;sys/param.h&gt;
  50 #endif
  51 #ifdef HAVE_CRT_EXTERNS_H
  52 #include &lt;crt_externs.h&gt; /* for _NSGetEnviron */
  53 #endif
  54 #ifdef HAVE_SYS_AUXV_H
  55 #include &lt;sys/auxv.h&gt;
  56 #endif
  57 
  58 #include &quot;glib-init.h&quot;
  59 #include &quot;glib-private.h&quot;
  60 #include &quot;genviron.h&quot;
  61 #include &quot;gfileutils.h&quot;
  62 #include &quot;ggettext.h&quot;
  63 #include &quot;ghash.h&quot;
  64 #include &quot;gthread.h&quot;
  65 #include &quot;gtestutils.h&quot;
  66 #include &quot;gunicode.h&quot;
  67 #include &quot;gstrfuncs.h&quot;
  68 #include &quot;garray.h&quot;
  69 #include &quot;glibintl.h&quot;
  70 #include &quot;gstdio.h&quot;
  71 
  72 #ifdef G_PLATFORM_WIN32
  73 #include &quot;gconvert.h&quot;
  74 #include &quot;gwin32.h&quot;
  75 #endif
  76 
  77 
  78 /**
  79  * SECTION:misc_utils
  80  * @title: Miscellaneous Utility Functions
  81  * @short_description: a selection of portable utility functions
  82  *
  83  * These are portable utility functions.
  84  */
  85 
  86 #ifdef G_PLATFORM_WIN32
  87 #  include &lt;windows.h&gt;
  88 #  ifndef GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
  89 #    define GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT 2
  90 #    define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS 4
  91 #  endif
  92 #  include &lt;lmcons.h&gt;   /* For UNLEN */
  93 #endif /* G_PLATFORM_WIN32 */
  94 
  95 #ifdef G_OS_WIN32
  96 #  include &lt;direct.h&gt;
  97 #  include &lt;shlobj.h&gt;
  98 #  include &lt;process.h&gt;
  99 #endif
 100 
 101 #ifdef HAVE_CODESET
 102 #include &lt;langinfo.h&gt;
 103 #endif
 104 
 105 #ifdef G_PLATFORM_WIN32
 106 
 107 gchar *
 108 _glib_get_dll_directory (void)
 109 {
 110   gchar *retval;
 111   gchar *p;
 112   wchar_t wc_fn[MAX_PATH];
 113 
 114 #ifdef DLL_EXPORT
 115   if (glib_dll == NULL)
 116     return NULL;
 117 #endif
 118 
 119   /* This code is different from that in
 120    * g_win32_get_package_installation_directory_of_module() in that
 121    * here we return the actual folder where the GLib DLL is. We don&#39;t
 122    * do the check for it being in a &quot;bin&quot; or &quot;lib&quot; subfolder and then
 123    * returning the parent of that.
 124    *
 125    * In a statically built GLib, glib_dll will be NULL and we will
 126    * thus look up the application&#39;s .exe file&#39;s location.
 127    */
 128   if (!GetModuleFileNameW (glib_dll, wc_fn, MAX_PATH))
 129     return NULL;
 130 
 131   retval = g_utf16_to_utf8 (wc_fn, -1, NULL, NULL, NULL);
 132 
 133   p = strrchr (retval, G_DIR_SEPARATOR);
 134   if (p == NULL)
 135     {
 136       /* Wtf? */
 137       return NULL;
 138     }
 139   *p = &#39;\0&#39;;
 140 
 141   return retval;
 142 }
 143 
 144 #endif
 145 
 146 /**
 147  * g_memmove:
 148  * @dest: the destination address to copy the bytes to.
 149  * @src: the source address to copy the bytes from.
 150  * @len: the number of bytes to copy.
 151  *
 152  * Copies a block of memory @len bytes long, from @src to @dest.
 153  * The source and destination areas may overlap.
 154  *
 155  * Deprecated:2.40: Just use memmove().
 156  */
 157 
 158 #ifndef GSTREAMER_LITE
 159 
 160 #ifdef G_OS_WIN32
 161 #undef g_atexit
 162 #endif
 163 
 164 /**
 165  * g_atexit:
 166  * @func: (scope async): the function to call on normal program termination.
 167  *
 168  * Specifies a function to be called at normal program termination.
 169  *
 170  * Since GLib 2.8.2, on Windows g_atexit() actually is a preprocessor
 171  * macro that maps to a call to the atexit() function in the C
 172  * library. This means that in case the code that calls g_atexit(),
 173  * i.e. atexit(), is in a DLL, the function will be called when the
 174  * DLL is detached from the program. This typically makes more sense
 175  * than that the function is called when the GLib DLL is detached,
 176  * which happened earlier when g_atexit() was a function in the GLib
 177  * DLL.
 178  *
 179  * The behaviour of atexit() in the context of dynamically loaded
 180  * modules is not formally specified and varies wildly.
 181  *
 182  * On POSIX systems, calling g_atexit() (or atexit()) in a dynamically
 183  * loaded module which is unloaded before the program terminates might
 184  * well cause a crash at program exit.
 185  *
 186  * Some POSIX systems implement atexit() like Windows, and have each
 187  * dynamically loaded module maintain an own atexit chain that is
 188  * called when the module is unloaded.
 189  *
 190  * On other POSIX systems, before a dynamically loaded module is
 191  * unloaded, the registered atexit functions (if any) residing in that
 192  * module are called, regardless where the code that registered them
 193  * resided. This is presumably the most robust approach.
 194  *
 195  * As can be seen from the above, for portability it&#39;s best to avoid
 196  * calling g_atexit() (or atexit()) except in the main executable of a
 197  * program.
 198  *
 199  * Deprecated:2.32: It is best to avoid g_atexit().
 200  */
 201 G_GNUC_BEGIN_IGNORE_DEPRECATIONS
 202 void
 203 g_atexit (GVoidFunc func)
 204 {
 205   gint result;
 206   int errsv;
 207 
 208   result = atexit ((void (*)(void)) func);
 209   errsv = errno;
 210   if (result)
 211     {
 212       g_error (&quot;Could not register atexit() function: %s&quot;,
 213                g_strerror (errsv));
 214     }
 215 }
 216 G_GNUC_END_IGNORE_DEPRECATIONS
 217 
 218 #endif // GSTREAMER_LITE
 219 
 220 /* Based on execvp() from GNU Libc.
 221  * Some of this code is cut-and-pasted into gspawn.c
 222  */
 223 
 224 static gchar*
 225 my_strchrnul (const gchar *str,
 226         gchar        c)
 227 {
 228   gchar *p = (gchar*)str;
 229   while (*p &amp;&amp; (*p != c))
 230     ++p;
 231 
 232   return p;
 233 }
 234 
 235 #ifdef G_OS_WIN32
 236 
 237 static gchar *inner_find_program_in_path (const gchar *program);
 238 
 239 gchar*
 240 g_find_program_in_path (const gchar *program)
 241 {
 242   const gchar *last_dot = strrchr (program, &#39;.&#39;);
 243 
 244   if (last_dot == NULL ||
 245       strchr (last_dot, &#39;\\&#39;) != NULL ||
 246       strchr (last_dot, &#39;/&#39;) != NULL)
 247     {
 248       const gint program_length = strlen (program);
 249       gchar *pathext = g_build_path (&quot;;&quot;,
 250              &quot;.exe;.cmd;.bat;.com&quot;,
 251              g_getenv (&quot;PATHEXT&quot;),
 252              NULL);
 253       gchar *p;
 254       gchar *decorated_program;
 255       gchar *retval;
 256 
 257       p = pathext;
 258       do
 259   {
 260     gchar *q = my_strchrnul (p, &#39;;&#39;);
 261 
 262     decorated_program = g_malloc (program_length + (q-p) + 1);
 263     memcpy (decorated_program, program, program_length);
 264     memcpy (decorated_program+program_length, p, q-p);
 265     decorated_program [program_length + (q-p)] = &#39;\0&#39;;
 266 
 267     retval = inner_find_program_in_path (decorated_program);
 268     g_free (decorated_program);
 269 
 270     if (retval != NULL)
 271       {
 272         g_free (pathext);
 273         return retval;
 274       }
 275     p = q;
 276   } while (*p++ != &#39;\0&#39;);
 277       g_free (pathext);
 278       return NULL;
 279     }
 280   else
 281     return inner_find_program_in_path (program);
 282 }
 283 
 284 #endif
 285 
 286 /**
 287  * g_find_program_in_path:
 288  * @program: (type filename): a program name in the GLib file name encoding
 289  *
 290  * Locates the first executable named @program in the user&#39;s path, in the
 291  * same way that execvp() would locate it. Returns an allocated string
 292  * with the absolute path name, or %NULL if the program is not found in
 293  * the path. If @program is already an absolute path, returns a copy of
 294  * @program if @program exists and is executable, and %NULL otherwise.
 295  *
 296  * On Windows, if @program does not have a file type suffix, tries
 297  * with the suffixes .exe, .cmd, .bat and .com, and the suffixes in
 298  * the `PATHEXT` environment variable.
 299  *
 300  * On Windows, it looks for the file in the same way as CreateProcess()
 301  * would. This means first in the directory where the executing
 302  * program was loaded from, then in the current directory, then in the
 303  * Windows 32-bit system directory, then in the Windows directory, and
 304  * finally in the directories in the `PATH` environment variable. If
 305  * the program is found, the return value contains the full name
 306  * including the type suffix.
 307  *
 308  * Returns: (type filename): a newly-allocated string with the absolute path,
 309  *     or %NULL
 310  **/
 311 #ifdef G_OS_WIN32
 312 static gchar *
 313 inner_find_program_in_path (const gchar *program)
 314 #else
 315 gchar*
 316 g_find_program_in_path (const gchar *program)
 317 #endif
 318 {
 319   const gchar *path, *p;
 320   gchar *name, *freeme;
 321 #ifdef G_OS_WIN32
 322   const gchar *path_copy;
 323   gchar *filename = NULL, *appdir = NULL;
 324   gchar *sysdir = NULL, *windir = NULL;
 325   int n;
 326   wchar_t wfilename[MAXPATHLEN], wsysdir[MAXPATHLEN],
 327     wwindir[MAXPATHLEN];
 328 #endif
 329   gsize len;
 330   gsize pathlen;
 331 
 332   g_return_val_if_fail (program != NULL, NULL);
 333 
 334   /* If it is an absolute path, or a relative path including subdirectories,
 335    * don&#39;t look in PATH.
 336    */
 337   if (g_path_is_absolute (program)
 338       || strchr (program, G_DIR_SEPARATOR) != NULL
 339 #ifdef G_OS_WIN32
 340       || strchr (program, &#39;/&#39;) != NULL
 341 #endif
 342       )
 343     {
 344       if (g_file_test (program, G_FILE_TEST_IS_EXECUTABLE) &amp;&amp;
 345     !g_file_test (program, G_FILE_TEST_IS_DIR))
 346         return g_strdup (program);
 347       else
 348         return NULL;
 349     }
 350 
 351   path = g_getenv (&quot;PATH&quot;);
 352 #if defined(G_OS_UNIX)
 353   if (path == NULL)
 354     {
 355       /* There is no &#39;PATH&#39; in the environment.  The default
 356        * search path in GNU libc is the current directory followed by
 357        * the path &#39;confstr&#39; returns for &#39;_CS_PATH&#39;.
 358        */
 359 
 360       /* In GLib we put . last, for security, and don&#39;t use the
 361        * unportable confstr(); UNIX98 does not actually specify
 362        * what to search if PATH is unset. POSIX may, dunno.
 363        */
 364 
 365       path = &quot;/bin:/usr/bin:.&quot;;
 366     }
 367 #else
 368   n = GetModuleFileNameW (NULL, wfilename, MAXPATHLEN);
 369   if (n &gt; 0 &amp;&amp; n &lt; MAXPATHLEN)
 370     filename = g_utf16_to_utf8 (wfilename, -1, NULL, NULL, NULL);
 371 
 372   n = GetSystemDirectoryW (wsysdir, MAXPATHLEN);
 373   if (n &gt; 0 &amp;&amp; n &lt; MAXPATHLEN)
 374     sysdir = g_utf16_to_utf8 (wsysdir, -1, NULL, NULL, NULL);
 375 
 376   n = GetWindowsDirectoryW (wwindir, MAXPATHLEN);
 377   if (n &gt; 0 &amp;&amp; n &lt; MAXPATHLEN)
 378     windir = g_utf16_to_utf8 (wwindir, -1, NULL, NULL, NULL);
 379 
 380   if (filename)
 381     {
 382       appdir = g_path_get_dirname (filename);
 383       g_free (filename);
 384     }
 385 
 386   path = g_strdup (path);
 387 
 388   if (windir)
 389     {
 390       const gchar *tem = path;
 391       path = g_strconcat (windir, &quot;;&quot;, path, NULL);
 392       g_free ((gchar *) tem);
 393       g_free (windir);
 394     }
 395 
 396   if (sysdir)
 397     {
 398       const gchar *tem = path;
 399       path = g_strconcat (sysdir, &quot;;&quot;, path, NULL);
 400       g_free ((gchar *) tem);
 401       g_free (sysdir);
 402     }
 403 
 404   {
 405     const gchar *tem = path;
 406     path = g_strconcat (&quot;.;&quot;, path, NULL);
 407     g_free ((gchar *) tem);
 408   }
 409 
 410   if (appdir)
 411     {
 412       const gchar *tem = path;
 413       path = g_strconcat (appdir, &quot;;&quot;, path, NULL);
 414       g_free ((gchar *) tem);
 415       g_free (appdir);
 416     }
 417 
 418   path_copy = path;
 419 #endif
 420 
 421   len = strlen (program) + 1;
 422   pathlen = strlen (path);
 423   freeme = name = g_malloc (pathlen + len + 1);
 424 #ifdef GSTREAMER_LITE
 425   if (freeme == NULL)
 426       return NULL;
 427 #endif // GSTREAMER_LITE
 428 
 429   /* Copy the file name at the top, including &#39;\0&#39;  */
 430   memcpy (name + pathlen + 1, program, len);
 431   name = name + pathlen;
 432   /* And add the slash before the filename  */
 433   *name = G_DIR_SEPARATOR;
 434 
 435   p = path;
 436   do
 437     {
 438       char *startp;
 439 
 440       path = p;
 441       p = my_strchrnul (path, G_SEARCHPATH_SEPARATOR);
 442 
 443       if (p == path)
 444         /* Two adjacent colons, or a colon at the beginning or the end
 445          * of &#39;PATH&#39; means to search the current directory.
 446          */
 447         startp = name + 1;
 448       else
 449         startp = memcpy (name - (p - path), path, p - path);
 450 
 451       if (g_file_test (startp, G_FILE_TEST_IS_EXECUTABLE) &amp;&amp;
 452     !g_file_test (startp, G_FILE_TEST_IS_DIR))
 453         {
 454           gchar *ret;
 455           ret = g_strdup (startp);
 456           g_free (freeme);
 457 #ifdef G_OS_WIN32
 458     g_free ((gchar *) path_copy);
 459 #endif
 460           return ret;
 461         }
 462     }
 463   while (*p++ != &#39;\0&#39;);
 464 
 465   g_free (freeme);
 466 #ifdef G_OS_WIN32
 467   g_free ((gchar *) path_copy);
 468 #endif
 469 
 470   return NULL;
 471 }
 472 
 473 /* The functions below are defined this way for compatibility reasons.
 474  * See the note in gutils.h.
 475  */
 476 
 477 /**
 478  * g_bit_nth_lsf:
 479  * @mask: a #gulong containing flags
 480  * @nth_bit: the index of the bit to start the search from
 481  *
 482  * Find the position of the first bit set in @mask, searching
 483  * from (but not including) @nth_bit upwards. Bits are numbered
 484  * from 0 (least significant) to sizeof(#gulong) * 8 - 1 (31 or 63,
 485  * usually). To start searching from the 0th bit, set @nth_bit to -1.
 486  *
 487  * Returns: the index of the first bit set which is higher than @nth_bit, or -1
 488  *    if no higher bits are set
 489  */
 490 gint
 491 (g_bit_nth_lsf) (gulong mask,
 492                  gint   nth_bit)
 493 {
 494   return g_bit_nth_lsf_impl (mask, nth_bit);
 495 }
 496 
 497 /**
 498  * g_bit_nth_msf:
 499  * @mask: a #gulong containing flags
 500  * @nth_bit: the index of the bit to start the search from
 501  *
 502  * Find the position of the first bit set in @mask, searching
 503  * from (but not including) @nth_bit downwards. Bits are numbered
 504  * from 0 (least significant) to sizeof(#gulong) * 8 - 1 (31 or 63,
 505  * usually). To start searching from the last bit, set @nth_bit to
 506  * -1 or GLIB_SIZEOF_LONG * 8.
 507  *
 508  * Returns: the index of the first bit set which is lower than @nth_bit, or -1
 509  *    if no lower bits are set
 510  */
 511 gint
 512 (g_bit_nth_msf) (gulong mask,
 513                  gint   nth_bit)
 514 {
 515   return g_bit_nth_msf_impl (mask, nth_bit);
 516 }
 517 
 518 
 519 /**
 520  * g_bit_storage:
 521  * @number: a #guint
 522  *
 523  * Gets the number of bits used to hold @number,
 524  * e.g. if @number is 4, 3 bits are needed.
 525  *
 526  * Returns: the number of bits used to hold @number
 527  */
 528 guint
 529 (g_bit_storage) (gulong number)
 530 {
 531   return g_bit_storage_impl (number);
 532 }
 533 
 534 G_LOCK_DEFINE_STATIC (g_utils_global);
 535 
 536 typedef struct
 537 {
 538   gchar *user_name;
 539   gchar *real_name;
 540   gchar *home_dir;
 541 } UserDatabaseEntry;
 542 
 543 /* These must all be read/written with @g_utils_global held. */
 544 static  gchar   *g_user_data_dir = NULL;
 545 static  gchar  **g_system_data_dirs = NULL;
 546 static  gchar   *g_user_cache_dir = NULL;
 547 static  gchar   *g_user_config_dir = NULL;
 548 static  gchar   *g_user_runtime_dir = NULL;
 549 static  gchar  **g_system_config_dirs = NULL;
 550 static  gchar  **g_user_special_dirs = NULL;
 551 
 552 /* fifteen minutes of fame for everybody */
 553 #define G_USER_DIRS_EXPIRE      15 * 60
 554 
 555 #ifdef G_OS_WIN32
 556 
 557 static gchar *
 558 get_special_folder (int csidl)
 559 {
 560   wchar_t path[MAX_PATH+1];
 561   HRESULT hr;
 562   LPITEMIDLIST pidl = NULL;
 563   BOOL b;
 564   gchar *retval = NULL;
 565 
 566   hr = SHGetSpecialFolderLocation (NULL, csidl, &amp;pidl);
 567   if (hr == S_OK)
 568     {
 569       b = SHGetPathFromIDListW (pidl, path);
 570       if (b)
 571   retval = g_utf16_to_utf8 (path, -1, NULL, NULL, NULL);
 572       CoTaskMemFree (pidl);
 573     }
 574   return retval;
 575 }
 576 
 577 static char *
 578 get_windows_directory_root (void)
 579 {
 580   wchar_t wwindowsdir[MAX_PATH];
 581 
 582   if (GetWindowsDirectoryW (wwindowsdir, G_N_ELEMENTS (wwindowsdir)))
 583     {
 584       /* Usually X:\Windows, but in terminal server environments
 585        * might be an UNC path, AFAIK.
 586        */
 587       char *windowsdir = g_utf16_to_utf8 (wwindowsdir, -1, NULL, NULL, NULL);
 588       char *p;
 589 
 590       if (windowsdir == NULL)
 591   return g_strdup (&quot;C:\\&quot;);
 592 
 593       p = (char *) g_path_skip_root (windowsdir);
 594       if (G_IS_DIR_SEPARATOR (p[-1]) &amp;&amp; p[-2] != &#39;:&#39;)
 595   p--;
 596       *p = &#39;\0&#39;;
 597       return windowsdir;
 598     }
 599   else
 600     return g_strdup (&quot;C:\\&quot;);
 601 }
 602 
 603 #endif
 604 
 605 /* HOLDS: g_utils_global_lock */
 606 static UserDatabaseEntry *
 607 g_get_user_database_entry (void)
 608 {
 609   static UserDatabaseEntry *entry;
 610 
 611   if (g_once_init_enter (&amp;entry))
 612     {
 613       static UserDatabaseEntry e;
 614 
 615 #ifdef G_OS_UNIX
 616       {
 617         struct passwd *pw = NULL;
 618         gpointer buffer = NULL;
 619         gint error;
 620         gchar *logname;
 621 
 622 #  if defined (HAVE_GETPWUID_R)
 623         struct passwd pwd;
 624 #    ifdef _SC_GETPW_R_SIZE_MAX
 625         /* This reurns the maximum length */
 626         glong bufsize = sysconf (_SC_GETPW_R_SIZE_MAX);
 627 
 628         if (bufsize &lt; 0)
 629           bufsize = 64;
 630 #    else /* _SC_GETPW_R_SIZE_MAX */
 631         glong bufsize = 64;
 632 #    endif /* _SC_GETPW_R_SIZE_MAX */
 633 
 634         logname = (gchar *) g_getenv (&quot;LOGNAME&quot;);
 635 
 636         do
 637           {
 638             g_free (buffer);
 639             /* we allocate 6 extra bytes to work around a bug in
 640              * Mac OS &lt; 10.3. See #156446
 641              */
 642             buffer = g_malloc (bufsize + 6);
 643             errno = 0;
 644 
 645             if (logname) {
 646               error = getpwnam_r (logname, &amp;pwd, buffer, bufsize, &amp;pw);
 647               if (!pw || (pw-&gt;pw_uid != getuid ())) {
 648                 /* LOGNAME is lying, fall back to looking up the uid */
 649                 error = getpwuid_r (getuid (), &amp;pwd, buffer, bufsize, &amp;pw);
 650               }
 651             } else {
 652               error = getpwuid_r (getuid (), &amp;pwd, buffer, bufsize, &amp;pw);
 653             }
 654             error = error &lt; 0 ? errno : error;
 655 
 656             if (!pw)
 657               {
 658                 /* we bail out prematurely if the user id can&#39;t be found
 659                  * (should be pretty rare case actually), or if the buffer
 660                  * should be sufficiently big and lookups are still not
 661                  * successful.
 662                  */
 663                 if (error == 0 || error == ENOENT)
 664                   {
 665                     g_warning (&quot;getpwuid_r(): failed due to unknown user id (%lu)&quot;,
 666                                (gulong) getuid ());
 667                     break;
 668                   }
 669                 if (bufsize &gt; 32 * 1024)
 670                   {
 671                     g_warning (&quot;getpwuid_r(): failed due to: %s.&quot;,
 672                                g_strerror (error));
 673                     break;
 674                   }
 675 
 676                 bufsize *= 2;
 677               }
 678           }
 679         while (!pw);
 680 #  endif /* HAVE_GETPWUID_R */
 681 
 682         if (!pw)
 683           {
 684             pw = getpwuid (getuid ());
 685           }
 686         if (pw)
 687           {
 688             e.user_name = g_strdup (pw-&gt;pw_name);
 689 
 690 #ifndef __BIONIC__
 691             if (pw-&gt;pw_gecos &amp;&amp; *pw-&gt;pw_gecos != &#39;\0&#39;)
 692               {
 693                 gchar **gecos_fields;
 694                 gchar **name_parts;
 695 
 696                 /* split the gecos field and substitute &#39;&amp;&#39; */
 697                 gecos_fields = g_strsplit (pw-&gt;pw_gecos, &quot;,&quot;, 0);
 698                 name_parts = g_strsplit (gecos_fields[0], &quot;&amp;&quot;, 0);
 699                 pw-&gt;pw_name[0] = g_ascii_toupper (pw-&gt;pw_name[0]);
 700                 e.real_name = g_strjoinv (pw-&gt;pw_name, name_parts);
 701                 g_strfreev (gecos_fields);
 702                 g_strfreev (name_parts);
 703               }
 704 #endif
 705 
 706             if (!e.home_dir)
 707               e.home_dir = g_strdup (pw-&gt;pw_dir);
 708           }
 709         g_free (buffer);
 710       }
 711 
 712 #endif /* G_OS_UNIX */
 713 
 714 #ifdef G_OS_WIN32
 715       {
 716         guint len = UNLEN+1;
 717         wchar_t buffer[UNLEN+1];
 718 
 719         if (GetUserNameW (buffer, (LPDWORD) &amp;len))
 720           {
 721             e.user_name = g_utf16_to_utf8 (buffer, -1, NULL, NULL, NULL);
 722             e.real_name = g_strdup (e.user_name);
 723           }
 724       }
 725 #endif /* G_OS_WIN32 */
 726 
 727       if (!e.user_name)
 728         e.user_name = g_strdup (&quot;somebody&quot;);
 729       if (!e.real_name)
 730         e.real_name = g_strdup (&quot;Unknown&quot;);
 731 
 732       g_once_init_leave (&amp;entry, &amp;e);
 733     }
 734 
 735   return entry;
 736 }
 737 
 738 /**
 739  * g_get_user_name:
 740  *
 741  * Gets the user name of the current user. The encoding of the returned
 742  * string is system-defined. On UNIX, it might be the preferred file name
 743  * encoding, or something else, and there is no guarantee that it is even
 744  * consistent on a machine. On Windows, it is always UTF-8.
 745  *
 746  * Returns: (type filename): the user name of the current user.
 747  */
 748 const gchar *
 749 g_get_user_name (void)
 750 {
 751   UserDatabaseEntry *entry;
 752 
 753   entry = g_get_user_database_entry ();
 754 
 755   return entry-&gt;user_name;
 756 }
 757 
 758 /**
 759  * g_get_real_name:
 760  *
 761  * Gets the real name of the user. This usually comes from the user&#39;s
 762  * entry in the `passwd` file. The encoding of the returned string is
 763  * system-defined. (On Windows, it is, however, always UTF-8.) If the
 764  * real user name cannot be determined, the string &quot;Unknown&quot; is
 765  * returned.
 766  *
 767  * Returns: (type filename): the user&#39;s real name.
 768  */
 769 const gchar *
 770 g_get_real_name (void)
 771 {
 772   UserDatabaseEntry *entry;
 773 
 774   entry = g_get_user_database_entry ();
 775 
 776   return entry-&gt;real_name;
 777 }
 778 
 779 /* Protected by @g_utils_global_lock. */
 780 static gchar *g_home_dir = NULL;  /* (owned) (nullable before initialised) */
 781 
 782 static gchar *
 783 g_build_home_dir (void)
 784 {
 785   gchar *home_dir;
 786 
 787   /* We first check HOME and use it if it is set */
 788   home_dir = g_strdup (g_getenv (&quot;HOME&quot;));
 789 
 790 #ifdef G_OS_WIN32
 791   /* Only believe HOME if it is an absolute path and exists.
 792    *
 793    * We only do this check on Windows for a couple of reasons.
 794    * Historically, we only did it there because we used to ignore $HOME
 795    * on UNIX.  There are concerns about enabling it now on UNIX because
 796    * of things like autofs.  In short, if the user has a bogus value in
 797    * $HOME then they get what they pay for...
 798    */
 799   if (home_dir != NULL)
 800     {
 801       if (!(g_path_is_absolute (home_dir) &amp;&amp;
 802             g_file_test (home_dir, G_FILE_TEST_IS_DIR)))
 803         g_clear_pointer (&amp;home_dir, g_free);
 804     }
 805 
 806   /* In case HOME is Unix-style (it happens), convert it to
 807    * Windows style.
 808    */
 809   if (home_dir != NULL)
 810     {
 811       gchar *p;
 812       while ((p = strchr (home_dir, &#39;/&#39;)) != NULL)
 813         *p = &#39;\\&#39;;
 814     }
 815 
 816   if (home_dir == NULL)
 817     {
 818       /* USERPROFILE is probably the closest equivalent to $HOME? */
 819       if (g_getenv (&quot;USERPROFILE&quot;) != NULL)
 820         home_dir = g_strdup (g_getenv (&quot;USERPROFILE&quot;));
 821     }
 822 
 823   if (home_dir == NULL)
 824     home_dir = get_special_folder (CSIDL_PROFILE);
 825 
 826   if (home_dir == NULL)
 827     home_dir = get_windows_directory_root ();
 828 #endif /* G_OS_WIN32 */
 829 
 830   if (home_dir == NULL)
 831     {
 832       /* If we didn&#39;t get it from any of those methods, we will have
 833        * to read the user database entry.
 834        */
 835       UserDatabaseEntry *entry = g_get_user_database_entry ();
 836       home_dir = g_strdup (entry-&gt;home_dir);
 837     }
 838 
 839   /* If we have been denied access to /etc/passwd (for example, by an
 840    * overly-zealous LSM), make up a junk value. The return value at this
 841    * point is explicitly documented as &#39;undefined&#39;. */
 842   if (home_dir == NULL)
 843     {
 844       g_warning (&quot;Could not find home directory: $HOME is not set, and &quot;
 845                  &quot;user database could not be read.&quot;);
 846       home_dir = g_strdup (&quot;/&quot;);
 847     }
 848 
 849   return g_steal_pointer (&amp;home_dir);
 850 }
 851 
 852 /**
 853  * g_get_home_dir:
 854  *
 855  * Gets the current user&#39;s home directory.
 856  *
 857  * As with most UNIX tools, this function will return the value of the
 858  * `HOME` environment variable if it is set to an existing absolute path
 859  * name, falling back to the `passwd` file in the case that it is unset.
 860  *
 861  * If the path given in `HOME` is non-absolute, does not exist, or is
 862  * not a directory, the result is undefined.
 863  *
 864  * Before version 2.36 this function would ignore the `HOME` environment
 865  * variable, taking the value from the `passwd` database instead. This was
 866  * changed to increase the compatibility of GLib with other programs (and
 867  * the XDG basedir specification) and to increase testability of programs
 868  * based on GLib (by making it easier to run them from test frameworks).
 869  *
 870  * If your program has a strong requirement for either the new or the
 871  * old behaviour (and if you don&#39;t wish to increase your GLib
 872  * dependency to ensure that the new behaviour is in effect) then you
 873  * should either directly check the `HOME` environment variable yourself
 874  * or unset it before calling any functions in GLib.
 875  *
 876  * Returns: (type filename): the current user&#39;s home directory
 877  */
 878 const gchar *
 879 g_get_home_dir (void)
 880 {
 881   const gchar *home_dir;
 882 
 883   G_LOCK (g_utils_global);
 884 
 885   if (g_home_dir == NULL)
 886     g_home_dir = g_build_home_dir ();
 887   home_dir = g_home_dir;
 888 
 889   G_UNLOCK (g_utils_global);
 890 
 891   return home_dir;
 892 }
 893 
 894 /**
 895  * g_get_tmp_dir:
 896  *
 897  * Gets the directory to use for temporary files.
 898  *
 899  * On UNIX, this is taken from the `TMPDIR` environment variable.
 900  * If the variable is not set, `P_tmpdir` is
 901  * used, as defined by the system C library. Failing that, a
 902  * hard-coded default of &quot;/tmp&quot; is returned.
 903  *
 904  * On Windows, the `TEMP` environment variable is used, with the
 905  * root directory of the Windows installation (eg: &quot;C:\&quot;) used
 906  * as a default.
 907  *
 908  * The encoding of the returned string is system-defined. On Windows,
 909  * it is always UTF-8. The return value is never %NULL or the empty
 910  * string.
 911  *
 912  * Returns: (type filename): the directory to use for temporary files.
 913  */
 914 const gchar *
 915 g_get_tmp_dir (void)
 916 {
 917   static gchar *tmp_dir;
 918 
 919   if (g_once_init_enter (&amp;tmp_dir))
 920     {
 921       gchar *tmp;
 922 
 923 #ifdef G_OS_WIN32
 924       tmp = g_strdup (g_getenv (&quot;TEMP&quot;));
 925 
 926       if (tmp == NULL || *tmp == &#39;\0&#39;)
 927         {
 928           g_free (tmp);
 929           tmp = get_windows_directory_root ();
 930         }
 931 #else /* G_OS_WIN32 */
 932       tmp = g_strdup (g_getenv (&quot;TMPDIR&quot;));
 933 
 934 #ifdef P_tmpdir
 935       if (tmp == NULL || *tmp == &#39;\0&#39;)
 936         {
 937           gsize k;
 938           g_free (tmp);
 939           tmp = g_strdup (P_tmpdir);
 940           k = strlen (tmp);
 941           if (k &gt; 1 &amp;&amp; G_IS_DIR_SEPARATOR (tmp[k - 1]))
 942             tmp[k - 1] = &#39;\0&#39;;
 943         }
 944 #endif /* P_tmpdir */
 945 
 946       if (tmp == NULL || *tmp == &#39;\0&#39;)
 947         {
 948           g_free (tmp);
 949           tmp = g_strdup (&quot;/tmp&quot;);
 950         }
 951 #endif /* !G_OS_WIN32 */
 952 
 953       g_once_init_leave (&amp;tmp_dir, tmp);
 954     }
 955 
 956   return tmp_dir;
 957 }
 958 
 959 /**
 960  * g_get_host_name:
 961  *
 962  * Return a name for the machine.
 963  *
 964  * The returned name is not necessarily a fully-qualified domain name,
 965  * or even present in DNS or some other name service at all. It need
 966  * not even be unique on your local network or site, but usually it
 967  * is. Callers should not rely on the return value having any specific
 968  * properties like uniqueness for security purposes. Even if the name
 969  * of the machine is changed while an application is running, the
 970  * return value from this function does not change. The returned
 971  * string is owned by GLib and should not be modified or freed. If no
 972  * name can be determined, a default fixed string &quot;localhost&quot; is
 973  * returned.
 974  *
 975  * The encoding of the returned string is UTF-8.
 976  *
 977  * Returns: the host name of the machine.
 978  *
 979  * Since: 2.8
 980  */
 981 const gchar *
 982 g_get_host_name (void)
 983 {
 984   static gchar *hostname;
 985 
 986   if (g_once_init_enter (&amp;hostname))
 987     {
 988       gboolean failed;
 989       gchar *utmp;
 990 
 991 #ifndef G_OS_WIN32
 992       glong max;
 993       gsize size;
 994       /* The number 256 * 256 is taken from the value of _POSIX_HOST_NAME_MAX,
 995        * which is 255. Since we use _POSIX_HOST_NAME_MAX + 1 (= 256) in the
 996        * fallback case, we pick 256 * 256 as the size of the larger buffer here.
 997        * It should be large enough. It doesn&#39;t looks reasonable to name a host
 998        * with a string that is longer than 64 KiB.
 999        */
1000       const gsize size_large = (gsize) 256 * 256;
1001       gchar *tmp;
1002 
1003       max = sysconf (_SC_HOST_NAME_MAX);
1004       if (max &gt; 0 &amp;&amp; max &lt;= G_MAXSIZE - 1)
1005         size = (gsize) max + 1;
1006       else
1007 #ifdef HOST_NAME_MAX
1008         size = HOST_NAME_MAX + 1;
1009 #else
1010         size = _POSIX_HOST_NAME_MAX + 1;
1011 #endif
1012 
1013       tmp = g_malloc (size);
1014       failed = (gethostname (tmp, size) == -1);
1015       if (failed &amp;&amp; size &lt; size_large)
1016         {
1017           /* Try again with a larger buffer if &#39;size&#39; may be too small. */
1018           g_free (tmp);
1019           tmp = g_malloc (size_large);
1020           failed = (gethostname (tmp, size_large) == -1);
1021         }
1022 
1023       if (failed)
1024         g_clear_pointer (&amp;tmp, g_free);
1025       utmp = tmp;
1026 #else
1027       wchar_t tmp[MAX_COMPUTERNAME_LENGTH + 1];
1028       DWORD size = sizeof (tmp) / sizeof (tmp[0]);
1029       failed = (!GetComputerNameW (tmp, &amp;size));
1030       if (!failed)
1031         utmp = g_utf16_to_utf8 (tmp, size, NULL, NULL, NULL);
1032       if (utmp == NULL)
1033         failed = TRUE;
1034 #endif
1035 
1036       g_once_init_leave (&amp;hostname, failed ? g_strdup (&quot;localhost&quot;) : utmp);
1037     }
1038 
1039   return hostname;
1040 }
1041 
1042 G_LOCK_DEFINE_STATIC (g_prgname);
1043 static gchar *g_prgname = NULL;
1044 
1045 /**
1046  * g_get_prgname:
1047  *
1048  * Gets the name of the program. This name should not be localized,
1049  * in contrast to g_get_application_name().
1050  *
1051  * If you are using #GApplication the program name is set in
1052  * g_application_run(). In case of GDK or GTK+ it is set in
1053  * gdk_init(), which is called by gtk_init() and the
1054  * #GtkApplication::startup handler. The program name is found by
1055  * taking the last component of @argv[0].
1056  *
1057  * Returns: (nullable): the name of the program, or %NULL if it has not been
1058  *     set yet. The returned string belongs
1059  *     to GLib and must not be modified or freed.
1060  */
1061 const gchar*
1062 g_get_prgname (void)
1063 {
1064   gchar* retval;
1065 
1066   G_LOCK (g_prgname);
1067   retval = g_prgname;
1068   G_UNLOCK (g_prgname);
1069 
1070   return retval;
1071 }
1072 
1073 /**
1074  * g_set_prgname:
1075  * @prgname: the name of the program.
1076  *
1077  * Sets the name of the program. This name should not be localized,
1078  * in contrast to g_set_application_name().
1079  *
1080  * If you are using #GApplication the program name is set in
1081  * g_application_run(). In case of GDK or GTK+ it is set in
1082  * gdk_init(), which is called by gtk_init() and the
1083  * #GtkApplication::startup handler. The program name is found by
1084  * taking the last component of @argv[0].
1085  *
1086  * Note that for thread-safety reasons this function can only be called once.
1087  */
1088 void
1089 g_set_prgname (const gchar *prgname)
1090 {
1091   G_LOCK (g_prgname);
1092   g_free (g_prgname);
1093   g_prgname = g_strdup (prgname);
1094   G_UNLOCK (g_prgname);
1095 }
1096 
1097 G_LOCK_DEFINE_STATIC (g_application_name);
1098 static gchar *g_application_name = NULL;
1099 
1100 /**
1101  * g_get_application_name:
1102  *
1103  * Gets a human-readable name for the application, as set by
1104  * g_set_application_name(). This name should be localized if
1105  * possible, and is intended for display to the user.  Contrast with
1106  * g_get_prgname(), which gets a non-localized name. If
1107  * g_set_application_name() has not been called, returns the result of
1108  * g_get_prgname() (which may be %NULL if g_set_prgname() has also not
1109  * been called).
1110  *
1111  * Returns: human-readable application name. may return %NULL
1112  *
1113  * Since: 2.2
1114  **/
1115 const gchar *
1116 g_get_application_name (void)
1117 {
1118   gchar* retval;
1119 
1120   G_LOCK (g_application_name);
1121   retval = g_application_name;
1122   G_UNLOCK (g_application_name);
1123 
1124   if (retval == NULL)
1125     return g_get_prgname ();
1126 
1127   return retval;
1128 }
1129 
1130 /**
1131  * g_set_application_name:
1132  * @application_name: localized name of the application
1133  *
1134  * Sets a human-readable name for the application. This name should be
1135  * localized if possible, and is intended for display to the user.
1136  * Contrast with g_set_prgname(), which sets a non-localized name.
1137  * g_set_prgname() will be called automatically by gtk_init(),
1138  * but g_set_application_name() will not.
1139  *
1140  * Note that for thread safety reasons, this function can only
1141  * be called once.
1142  *
1143  * The application name will be used in contexts such as error messages,
1144  * or when displaying an application&#39;s name in the task list.
1145  *
1146  * Since: 2.2
1147  **/
1148 void
1149 g_set_application_name (const gchar *application_name)
1150 {
1151   gboolean already_set = FALSE;
1152 
1153   G_LOCK (g_application_name);
1154   if (g_application_name)
1155     already_set = TRUE;
1156   else
1157     g_application_name = g_strdup (application_name);
1158   G_UNLOCK (g_application_name);
1159 
1160   if (already_set)
1161     g_warning (&quot;g_set_application_name() called multiple times&quot;);
1162 }
1163 
1164 /* Set @global_str to a copy of @new_value if it&#39;s currently unset or has a
1165  * different value. If its current value matches @new_value, do nothing. If
1166  * replaced, we have to leak the old value as client code could still have
1167  * pointers to it. */
1168 static void
1169 set_str_if_different (gchar       **global_str,
1170                       const gchar  *type,
1171                       const gchar  *new_value)
1172 {
1173   if (*global_str == NULL ||
1174       !g_str_equal (new_value, *global_str))
1175     {
1176       g_debug (&quot;g_set_user_dirs: Setting %s to %s&quot;, type, new_value);
1177 
1178       /* We have to leak the old value, as user code could be retaining pointers
1179        * to it. */
1180       *global_str = g_strdup (new_value);
1181     }
1182 }
1183 
1184 static void
1185 set_strv_if_different (gchar                ***global_strv,
1186                        const gchar            *type,
1187                        const gchar  * const   *new_value)
1188 {
1189   if (*global_strv == NULL ||
1190       !g_strv_equal (new_value, (const gchar * const *) *global_strv))
1191     {
1192       gchar *new_value_str = g_strjoinv (&quot;:&quot;, (gchar **) new_value);
1193       g_debug (&quot;g_set_user_dirs: Setting %s to %s&quot;, type, new_value_str);
1194       g_free (new_value_str);
1195 
1196       /* We have to leak the old value, as user code could be retaining pointers
1197        * to it. */
1198       *global_strv = g_strdupv ((gchar **) new_value);
1199     }
1200 }
1201 
1202 /*
1203  * g_set_user_dirs:
1204  * @first_dir_type: Type of the first directory to set
1205  * @...: Value to set the first directory to, followed by additional type/value
1206  *    pairs, followed by %NULL
1207  *
1208  * Set one or more &#39;user&#39; directories to custom values. This is intended to be
1209  * used by test code (particularly with the %G_TEST_OPTION_ISOLATE_DIRS option)
1210  * to override the values returned by the following functions, so that test
1211  * code can be run without touching an installed system and user data:
1212  *
1213  *  - g_get_home_dir() - use type `HOME`, pass a string
1214  *  - g_get_user_cache_dir() - use type `XDG_CACHE_HOME`, pass a string
1215  *  - g_get_system_config_dirs() - use type `XDG_CONFIG_DIRS`, pass a
1216  *    %NULL-terminated string array
1217  *  - g_get_user_config_dir() - use type `XDG_CONFIG_HOME`, pass a string
1218  *  - g_get_system_data_dirs() - use type `XDG_DATA_DIRS`, pass a
1219  *    %NULL-terminated string array
1220  *  - g_get_user_data_dir() - use type `XDG_DATA_HOME`, pass a string
1221  *  - g_get_user_runtime_dir() - use type `XDG_RUNTIME_DIR`, pass a string
1222  *
1223  * The list must be terminated with a %NULL type. All of the values must be
1224  * non-%NULL - passing %NULL as a value won&#39;t reset a directory. If a reference
1225  * to a directory from the calling environment needs to be kept, copy it before
1226  * the first call to g_set_user_dirs(). g_set_user_dirs() can be called multiple
1227  * times.
1228  *
1229  * Since: 2.60
1230  */
1231 /*&lt; private &gt; */
1232 void
1233 g_set_user_dirs (const gchar *first_dir_type,
1234                  ...)
1235 {
1236   va_list args;
1237   const gchar *dir_type;
1238 
1239   G_LOCK (g_utils_global);
1240 
1241   va_start (args, first_dir_type);
1242 
1243   for (dir_type = first_dir_type; dir_type != NULL; dir_type = va_arg (args, const gchar *))
1244     {
1245       gconstpointer dir_value = va_arg (args, gconstpointer);
1246       g_assert (dir_value != NULL);
1247 
1248       if (g_str_equal (dir_type, &quot;HOME&quot;))
1249         set_str_if_different (&amp;g_home_dir, dir_type, dir_value);
1250       else if (g_str_equal (dir_type, &quot;XDG_CACHE_HOME&quot;))
1251         set_str_if_different (&amp;g_user_cache_dir, dir_type, dir_value);
1252       else if (g_str_equal (dir_type, &quot;XDG_CONFIG_DIRS&quot;))
1253         set_strv_if_different (&amp;g_system_config_dirs, dir_type, dir_value);
1254       else if (g_str_equal (dir_type, &quot;XDG_CONFIG_HOME&quot;))
1255         set_str_if_different (&amp;g_user_config_dir, dir_type, dir_value);
1256       else if (g_str_equal (dir_type, &quot;XDG_DATA_DIRS&quot;))
1257         set_strv_if_different (&amp;g_system_data_dirs, dir_type, dir_value);
1258       else if (g_str_equal (dir_type, &quot;XDG_DATA_HOME&quot;))
1259         set_str_if_different (&amp;g_user_data_dir, dir_type, dir_value);
1260       else if (g_str_equal (dir_type, &quot;XDG_RUNTIME_DIR&quot;))
1261         set_str_if_different (&amp;g_user_runtime_dir, dir_type, dir_value);
1262       else
1263         g_assert_not_reached ();
1264     }
1265 
1266   va_end (args);
1267 
1268   G_UNLOCK (g_utils_global);
1269 }
1270 
1271 static gchar *
1272 g_build_user_data_dir (void)
1273 {
1274   gchar *data_dir = NULL;
1275   const gchar *data_dir_env = g_getenv (&quot;XDG_DATA_HOME&quot;);
1276 
1277   if (data_dir_env &amp;&amp; data_dir_env[0])
1278     data_dir = g_strdup (data_dir_env);
1279 #ifdef G_OS_WIN32
1280   else
1281     data_dir = get_special_folder (CSIDL_LOCAL_APPDATA);
1282 #endif
1283   if (!data_dir || !data_dir[0])
1284     {
1285       gchar *home_dir = g_build_home_dir ();
1286       data_dir = g_build_filename (home_dir, &quot;.local&quot;, &quot;share&quot;, NULL);
1287       g_free (home_dir);
1288     }
1289 
1290   return g_steal_pointer (&amp;data_dir);
1291 }
1292 
1293 /**
1294  * g_get_user_data_dir:
1295  *
1296  * Returns a base directory in which to access application data such
1297  * as icons that is customized for a particular user.
1298  *
1299  * On UNIX platforms this is determined using the mechanisms described
1300  * in the
1301  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1302  * In this case the directory retrieved will be `XDG_DATA_HOME`.
1303  *
1304  * On Windows it follows XDG Base Directory Specification if `XDG_DATA_HOME`
1305  * is defined. If `XDG_DATA_HOME` is undefined, the folder to use for local (as
1306  * opposed to roaming) application data is used instead. See the
1307  * [documentation for `CSIDL_LOCAL_APPDATA`](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx#csidl_local_appdata).
1308  * Note that in this case on Windows it will be the same
1309  * as what g_get_user_config_dir() returns.
1310  *
1311  * Returns: (type filename): a string owned by GLib that must not be modified
1312  *               or freed.
1313  * Since: 2.6
1314  **/
1315 const gchar *
1316 g_get_user_data_dir (void)
1317 {
1318   const gchar *user_data_dir;
1319 
1320   G_LOCK (g_utils_global);
1321 
1322   if (g_user_data_dir == NULL)
1323     g_user_data_dir = g_build_user_data_dir ();
1324   user_data_dir = g_user_data_dir;
1325 
1326   G_UNLOCK (g_utils_global);
1327 
1328   return user_data_dir;
1329 }
1330 
1331 static gchar *
1332 g_build_user_config_dir (void)
1333 {
1334   gchar *config_dir = NULL;
1335   const gchar *config_dir_env = g_getenv (&quot;XDG_CONFIG_HOME&quot;);
1336 
1337   if (config_dir_env &amp;&amp; config_dir_env[0])
1338     config_dir = g_strdup (config_dir_env);
1339 #ifdef G_OS_WIN32
1340   else
1341     config_dir = get_special_folder (CSIDL_LOCAL_APPDATA);
1342 #endif
1343   if (!config_dir || !config_dir[0])
1344     {
1345       gchar *home_dir = g_build_home_dir ();
1346       config_dir = g_build_filename (home_dir, &quot;.config&quot;, NULL);
1347       g_free (home_dir);
1348     }
1349 
1350   return g_steal_pointer (&amp;config_dir);
1351 }
1352 
1353 /**
1354  * g_get_user_config_dir:
1355  *
1356  * Returns a base directory in which to store user-specific application
1357  * configuration information such as user preferences and settings.
1358  *
1359  * On UNIX platforms this is determined using the mechanisms described
1360  * in the
1361  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1362  * In this case the directory retrieved will be `XDG_CONFIG_HOME`.
1363  *
1364  * On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_HOME` is defined.
1365  * If `XDG_CONFIG_HOME` is undefined, the folder to use for local (as opposed
1366  * to roaming) application data is used instead. See the
1367  * [documentation for `CSIDL_LOCAL_APPDATA`](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx#csidl_local_appdata).
1368  * Note that in this case on Windows it will be  the same
1369  * as what g_get_user_data_dir() returns.
1370  *
1371  * Returns: (type filename): a string owned by GLib that must not be modified
1372  *               or freed.
1373  * Since: 2.6
1374  **/
1375 const gchar *
1376 g_get_user_config_dir (void)
1377 {
1378   const gchar *user_config_dir;
1379 
1380   G_LOCK (g_utils_global);
1381 
1382   if (g_user_config_dir == NULL)
1383     g_user_config_dir = g_build_user_config_dir ();
1384   user_config_dir = g_user_config_dir;
1385 
1386   G_UNLOCK (g_utils_global);
1387 
1388   return user_config_dir;
1389 }
1390 
1391 static gchar *
1392 g_build_user_cache_dir (void)
1393 {
1394   gchar *cache_dir = NULL;
1395   const gchar *cache_dir_env = g_getenv (&quot;XDG_CACHE_HOME&quot;);
1396 
1397   if (cache_dir_env &amp;&amp; cache_dir_env[0])
1398     cache_dir = g_strdup (cache_dir_env);
1399 #ifdef G_OS_WIN32
1400   else
1401     cache_dir = get_special_folder (CSIDL_INTERNET_CACHE);
1402 #endif
1403   if (!cache_dir || !cache_dir[0])
1404     {
1405       gchar *home_dir = g_build_home_dir ();
1406       cache_dir = g_build_filename (home_dir, &quot;.cache&quot;, NULL);
1407       g_free (home_dir);
1408     }
1409 
1410   return g_steal_pointer (&amp;cache_dir);
1411 }
1412 
1413 /**
1414  * g_get_user_cache_dir:
1415  *
1416  * Returns a base directory in which to store non-essential, cached
1417  * data specific to particular user.
1418  *
1419  * On UNIX platforms this is determined using the mechanisms described
1420  * in the
1421  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1422  * In this case the directory retrieved will be `XDG_CACHE_HOME`.
1423  *
1424  * On Windows it follows XDG Base Directory Specification if `XDG_CACHE_HOME` is defined.
1425  * If `XDG_CACHE_HOME` is undefined, the directory that serves as a common
1426  * repository for temporary Internet files is used instead. A typical path is
1427  * `C:\Documents and Settings\username\Local Settings\Temporary Internet Files`.
1428  * See the [documentation for `CSIDL_INTERNET_CACHE`](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx#csidl_internet_cache).
1429  *
1430  * Returns: (type filename): a string owned by GLib that must not be modified
1431  *               or freed.
1432  * Since: 2.6
1433  **/
1434 const gchar *
1435 g_get_user_cache_dir (void)
1436 {
1437   const gchar *user_cache_dir;
1438 
1439   G_LOCK (g_utils_global);
1440 
1441   if (g_user_cache_dir == NULL)
1442     g_user_cache_dir = g_build_user_cache_dir ();
1443   user_cache_dir = g_user_cache_dir;
1444 
1445   G_UNLOCK (g_utils_global);
1446 
1447   return user_cache_dir;
1448 }
1449 
1450 static gchar *
1451 g_build_user_runtime_dir (void)
1452 {
1453   gchar *runtime_dir = NULL;
1454   const gchar *runtime_dir_env = g_getenv (&quot;XDG_RUNTIME_DIR&quot;);
1455 
1456   if (runtime_dir_env &amp;&amp; runtime_dir_env[0])
1457     runtime_dir = g_strdup (runtime_dir_env);
1458   else
1459     {
1460       runtime_dir = g_build_user_cache_dir ();
1461 
1462       /* The user should be able to rely on the directory existing
1463        * when the function returns.  Probably it already does, but
1464        * let&#39;s make sure.  Just do mkdir() directly since it will be
1465        * no more expensive than a stat() in the case that the
1466        * directory already exists and is a lot easier.
1467        *
1468        * $XDG_CACHE_HOME is probably ~/.cache/ so as long as $HOME
1469        * exists this will work.  If the user changed $XDG_CACHE_HOME
1470        * then they can make sure that it exists...
1471        */
1472       (void) g_mkdir (runtime_dir, 0700);
1473     }
1474 
1475   return g_steal_pointer (&amp;runtime_dir);
1476 }
1477 
1478 /**
1479  * g_get_user_runtime_dir:
1480  *
1481  * Returns a directory that is unique to the current user on the local
1482  * system.
1483  *
1484  * This is determined using the mechanisms described
1485  * in the
1486  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1487  * This is the directory
1488  * specified in the `XDG_RUNTIME_DIR` environment variable.
1489  * In the case that this variable is not set, we return the value of
1490  * g_get_user_cache_dir(), after verifying that it exists.
1491  *
1492  * Returns: (type filename): a string owned by GLib that must not be
1493  *     modified or freed.
1494  *
1495  * Since: 2.28
1496  **/
1497 const gchar *
1498 g_get_user_runtime_dir (void)
1499 {
1500   const gchar *user_runtime_dir;
1501 
1502   G_LOCK (g_utils_global);
1503 
1504   if (g_user_runtime_dir == NULL)
1505     g_user_runtime_dir = g_build_user_runtime_dir ();
1506   user_runtime_dir = g_user_runtime_dir;
1507 
1508   G_UNLOCK (g_utils_global);
1509 
1510   return user_runtime_dir;
1511 }
1512 
1513 #ifdef HAVE_COCOA
1514 
1515 /* Implemented in gutils-macos.m */
1516 void load_user_special_dirs_macos (gchar **table);
1517 
1518 static void
1519 load_user_special_dirs (void)
1520 {
1521   load_user_special_dirs_macos (g_user_special_dirs);
1522 }
1523 
1524 #elif defined(G_OS_WIN32)
1525 
1526 static void
1527 load_user_special_dirs (void)
1528 {
1529   typedef HRESULT (WINAPI *t_SHGetKnownFolderPath) (const GUID *rfid,
1530                 DWORD dwFlags,
1531                 HANDLE hToken,
1532                 PWSTR *ppszPath);
1533   t_SHGetKnownFolderPath p_SHGetKnownFolderPath;
1534 
1535   static const GUID FOLDERID_Downloads =
1536     { 0x374de290, 0x123f, 0x4565, { 0x91, 0x64, 0x39, 0xc4, 0x92, 0x5e, 0x46, 0x7b } };
1537   static const GUID FOLDERID_Public =
1538     { 0xDFDF76A2, 0xC82A, 0x4D63, { 0x90, 0x6A, 0x56, 0x44, 0xAC, 0x45, 0x73, 0x85 } };
1539 
1540   wchar_t *wcp;
1541 
1542   p_SHGetKnownFolderPath = (t_SHGetKnownFolderPath) GetProcAddress (GetModuleHandle (&quot;shell32.dll&quot;),
1543                     &quot;SHGetKnownFolderPath&quot;);
1544 
1545   g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
1546   g_user_special_dirs[G_USER_DIRECTORY_DOCUMENTS] = get_special_folder (CSIDL_PERSONAL);
1547 
1548   if (p_SHGetKnownFolderPath == NULL)
1549     {
1550       g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
1551     }
1552   else
1553     {
1554       wcp = NULL;
1555       (*p_SHGetKnownFolderPath) (&amp;FOLDERID_Downloads, 0, NULL, &amp;wcp);
1556       if (wcp)
1557         {
1558           g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = g_utf16_to_utf8 (wcp, -1, NULL, NULL, NULL);
1559           if (g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] == NULL)
1560               g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
1561           CoTaskMemFree (wcp);
1562         }
1563       else
1564           g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
1565     }
1566 
1567   g_user_special_dirs[G_USER_DIRECTORY_MUSIC] = get_special_folder (CSIDL_MYMUSIC);
1568   g_user_special_dirs[G_USER_DIRECTORY_PICTURES] = get_special_folder (CSIDL_MYPICTURES);
1569 
1570   if (p_SHGetKnownFolderPath == NULL)
1571     {
1572       /* XXX */
1573       g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = get_special_folder (CSIDL_COMMON_DOCUMENTS);
1574     }
1575   else
1576     {
1577       wcp = NULL;
1578       (*p_SHGetKnownFolderPath) (&amp;FOLDERID_Public, 0, NULL, &amp;wcp);
1579       if (wcp)
1580         {
1581           g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = g_utf16_to_utf8 (wcp, -1, NULL, NULL, NULL);
1582           if (g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] == NULL)
1583               g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = get_special_folder (CSIDL_COMMON_DOCUMENTS);
1584           CoTaskMemFree (wcp);
1585         }
1586       else
1587           g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = get_special_folder (CSIDL_COMMON_DOCUMENTS);
1588     }
1589 
1590   g_user_special_dirs[G_USER_DIRECTORY_TEMPLATES] = get_special_folder (CSIDL_TEMPLATES);
1591   g_user_special_dirs[G_USER_DIRECTORY_VIDEOS] = get_special_folder (CSIDL_MYVIDEO);
1592 }
1593 
1594 #else /* default is unix */
1595 
1596 /* adapted from xdg-user-dir-lookup.c
1597  *
1598  * Copyright (C) 2007 Red Hat Inc.
1599  *
1600  * Permission is hereby granted, free of charge, to any person
1601  * obtaining a copy of this software and associated documentation files
1602  * (the &quot;Software&quot;), to deal in the Software without restriction,
1603  * including without limitation the rights to use, copy, modify, merge,
1604  * publish, distribute, sublicense, and/or sell copies of the Software,
1605  * and to permit persons to whom the Software is furnished to do so,
1606  * subject to the following conditions:
1607  *
1608  * The above copyright notice and this permission notice shall be
1609  * included in all copies or substantial portions of the Software.
1610  *
1611  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
1612  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
1613  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
1614  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
1615  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
1616  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
1617  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
1618  * SOFTWARE.
1619  */
1620 static void
1621 load_user_special_dirs (void)
1622 {
1623   gchar *config_dir = NULL;
1624   gchar *config_file;
1625   gchar *data;
1626   gchar **lines;
1627   gint n_lines, i;
1628 
1629   config_dir = g_build_user_config_dir ();
1630   config_file = g_build_filename (config_dir,
1631                                   &quot;user-dirs.dirs&quot;,
1632                                   NULL);
1633   g_free (config_dir);
1634 
1635   if (!g_file_get_contents (config_file, &amp;data, NULL, NULL))
1636     {
1637       g_free (config_file);
1638       return;
1639     }
1640 
1641   lines = g_strsplit (data, &quot;\n&quot;, -1);
1642   n_lines = g_strv_length (lines);
1643   g_free (data);
1644 
1645   for (i = 0; i &lt; n_lines; i++)
1646     {
1647       gchar *buffer = lines[i];
1648       gchar *d, *p;
1649       gint len;
1650       gboolean is_relative = FALSE;
1651       GUserDirectory directory;
1652 
1653       /* Remove newline at end */
1654       len = strlen (buffer);
1655       if (len &gt; 0 &amp;&amp; buffer[len - 1] == &#39;\n&#39;)
1656   buffer[len - 1] = 0;
1657 
1658       p = buffer;
1659       while (*p == &#39; &#39; || *p == &#39;\t&#39;)
1660   p++;
1661 
1662       if (strncmp (p, &quot;XDG_DESKTOP_DIR&quot;, strlen (&quot;XDG_DESKTOP_DIR&quot;)) == 0)
1663         {
1664           directory = G_USER_DIRECTORY_DESKTOP;
1665           p += strlen (&quot;XDG_DESKTOP_DIR&quot;);
1666         }
1667       else if (strncmp (p, &quot;XDG_DOCUMENTS_DIR&quot;, strlen (&quot;XDG_DOCUMENTS_DIR&quot;)) == 0)
1668         {
1669           directory = G_USER_DIRECTORY_DOCUMENTS;
1670           p += strlen (&quot;XDG_DOCUMENTS_DIR&quot;);
1671         }
1672       else if (strncmp (p, &quot;XDG_DOWNLOAD_DIR&quot;, strlen (&quot;XDG_DOWNLOAD_DIR&quot;)) == 0)
1673         {
1674           directory = G_USER_DIRECTORY_DOWNLOAD;
1675           p += strlen (&quot;XDG_DOWNLOAD_DIR&quot;);
1676         }
1677       else if (strncmp (p, &quot;XDG_MUSIC_DIR&quot;, strlen (&quot;XDG_MUSIC_DIR&quot;)) == 0)
1678         {
1679           directory = G_USER_DIRECTORY_MUSIC;
1680           p += strlen (&quot;XDG_MUSIC_DIR&quot;);
1681         }
1682       else if (strncmp (p, &quot;XDG_PICTURES_DIR&quot;, strlen (&quot;XDG_PICTURES_DIR&quot;)) == 0)
1683         {
1684           directory = G_USER_DIRECTORY_PICTURES;
1685           p += strlen (&quot;XDG_PICTURES_DIR&quot;);
1686         }
1687       else if (strncmp (p, &quot;XDG_PUBLICSHARE_DIR&quot;, strlen (&quot;XDG_PUBLICSHARE_DIR&quot;)) == 0)
1688         {
1689           directory = G_USER_DIRECTORY_PUBLIC_SHARE;
1690           p += strlen (&quot;XDG_PUBLICSHARE_DIR&quot;);
1691         }
1692       else if (strncmp (p, &quot;XDG_TEMPLATES_DIR&quot;, strlen (&quot;XDG_TEMPLATES_DIR&quot;)) == 0)
1693         {
1694           directory = G_USER_DIRECTORY_TEMPLATES;
1695           p += strlen (&quot;XDG_TEMPLATES_DIR&quot;);
1696         }
1697       else if (strncmp (p, &quot;XDG_VIDEOS_DIR&quot;, strlen (&quot;XDG_VIDEOS_DIR&quot;)) == 0)
1698         {
1699           directory = G_USER_DIRECTORY_VIDEOS;
1700           p += strlen (&quot;XDG_VIDEOS_DIR&quot;);
1701         }
1702       else
1703   continue;
1704 
1705       while (*p == &#39; &#39; || *p == &#39;\t&#39;)
1706   p++;
1707 
1708       if (*p != &#39;=&#39;)
1709   continue;
1710       p++;
1711 
1712       while (*p == &#39; &#39; || *p == &#39;\t&#39;)
1713   p++;
1714 
1715       if (*p != &#39;&quot;&#39;)
1716   continue;
1717       p++;
1718 
1719       if (strncmp (p, &quot;$HOME&quot;, 5) == 0)
1720   {
1721     p += 5;
1722     is_relative = TRUE;
1723   }
1724       else if (*p != &#39;/&#39;)
1725   continue;
1726 
1727       d = strrchr (p, &#39;&quot;&#39;);
1728       if (!d)
1729         continue;
1730       *d = 0;
1731 
1732       d = p;
1733 
1734       /* remove trailing slashes */
1735       len = strlen (d);
1736       if (d[len - 1] == &#39;/&#39;)
1737         d[len - 1] = 0;
1738 
1739       if (is_relative)
1740         {
1741           gchar *home_dir = g_build_home_dir ();
1742           g_user_special_dirs[directory] = g_build_filename (home_dir, d, NULL);
1743           g_free (home_dir);
1744         }
1745       else
1746   g_user_special_dirs[directory] = g_strdup (d);
1747     }
1748 
1749   g_strfreev (lines);
1750   g_free (config_file);
1751 }
1752 
1753 #endif /* platform-specific load_user_special_dirs implementations */
1754 
1755 
1756 /**
1757  * g_reload_user_special_dirs_cache:
1758  *
1759  * Resets the cache used for g_get_user_special_dir(), so
1760  * that the latest on-disk version is used. Call this only
1761  * if you just changed the data on disk yourself.
1762  *
1763  * Due to thread safety issues this may cause leaking of strings
1764  * that were previously returned from g_get_user_special_dir()
1765  * that can&#39;t be freed. We ensure to only leak the data for
1766  * the directories that actually changed value though.
1767  *
1768  * Since: 2.22
1769  */
1770 void
1771 g_reload_user_special_dirs_cache (void)
1772 {
1773   int i;
1774 
1775   G_LOCK (g_utils_global);
1776 
1777   if (g_user_special_dirs != NULL)
1778     {
1779       /* save a copy of the pointer, to check if some memory can be preserved */
1780       char **old_g_user_special_dirs = g_user_special_dirs;
1781       char *old_val;
1782 
1783       /* recreate and reload our cache */
1784       g_user_special_dirs = g_new0 (gchar *, G_USER_N_DIRECTORIES);
1785       load_user_special_dirs ();
1786 
1787       /* only leak changed directories */
1788       for (i = 0; i &lt; G_USER_N_DIRECTORIES; i++)
1789         {
1790           old_val = old_g_user_special_dirs[i];
1791           if (g_user_special_dirs[i] == NULL)
1792             {
1793               g_user_special_dirs[i] = old_val;
1794             }
1795           else if (g_strcmp0 (old_val, g_user_special_dirs[i]) == 0)
1796             {
1797               /* don&#39;t leak */
1798               g_free (g_user_special_dirs[i]);
1799               g_user_special_dirs[i] = old_val;
1800             }
1801           else
1802             g_free (old_val);
1803         }
1804 
1805       /* free the old array */
1806       g_free (old_g_user_special_dirs);
1807     }
1808 
1809   G_UNLOCK (g_utils_global);
1810 }
1811 
1812 /**
1813  * g_get_user_special_dir:
1814  * @directory: the logical id of special directory
1815  *
1816  * Returns the full path of a special directory using its logical id.
1817  *
1818  * On UNIX this is done using the XDG special user directories.
1819  * For compatibility with existing practise, %G_USER_DIRECTORY_DESKTOP
1820  * falls back to `$HOME/Desktop` when XDG special user directories have
1821  * not been set up.
1822  *
1823  * Depending on the platform, the user might be able to change the path
1824  * of the special directory without requiring the session to restart; GLib
1825  * will not reflect any change once the special directories are loaded.
1826  *
1827  * Returns: (type filename): the path to the specified special directory, or
1828  *   %NULL if the logical id was not found. The returned string is owned by
1829  *   GLib and should not be modified or freed.
1830  *
1831  * Since: 2.14
1832  */
1833 const gchar *
1834 g_get_user_special_dir (GUserDirectory directory)
1835 {
1836   const gchar *user_special_dir;
1837 
1838   g_return_val_if_fail (directory &gt;= G_USER_DIRECTORY_DESKTOP &amp;&amp;
1839                         directory &lt; G_USER_N_DIRECTORIES, NULL);
1840 
1841   G_LOCK (g_utils_global);
1842 
1843   if (G_UNLIKELY (g_user_special_dirs == NULL))
1844     {
1845       g_user_special_dirs = g_new0 (gchar *, G_USER_N_DIRECTORIES);
1846 
1847       load_user_special_dirs ();
1848 
1849       /* Special-case desktop for historical compatibility */
1850       if (g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] == NULL)
1851         {
1852           gchar *home_dir = g_build_home_dir ();
1853           g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = g_build_filename (home_dir, &quot;Desktop&quot;, NULL);
1854           g_free (home_dir);
1855         }
1856     }
1857   user_special_dir = g_user_special_dirs[directory];
1858 
1859   G_UNLOCK (g_utils_global);
1860 
1861   return user_special_dir;
1862 }
1863 
1864 #ifdef G_OS_WIN32
1865 
1866 #undef g_get_system_data_dirs
1867 
1868 static HMODULE
1869 get_module_for_address (gconstpointer address)
1870 {
1871   /* Holds the g_utils_global lock */
1872 
1873   static gboolean beenhere = FALSE;
1874   typedef BOOL (WINAPI *t_GetModuleHandleExA) (DWORD, LPCTSTR, HMODULE *);
1875   static t_GetModuleHandleExA p_GetModuleHandleExA = NULL;
1876   HMODULE hmodule = NULL;
1877 
1878   if (!address)
1879     return NULL;
1880 
1881   if (!beenhere)
1882     {
1883       p_GetModuleHandleExA =
1884   (t_GetModuleHandleExA) GetProcAddress (GetModuleHandle (&quot;kernel32.dll&quot;),
1885                  &quot;GetModuleHandleExA&quot;);
1886       beenhere = TRUE;
1887     }
1888 
1889   if (p_GetModuleHandleExA == NULL ||
1890       !(*p_GetModuleHandleExA) (GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT |
1891         GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,
1892         address, &amp;hmodule))
1893     {
1894       MEMORY_BASIC_INFORMATION mbi;
1895       VirtualQuery (address, &amp;mbi, sizeof (mbi));
1896       hmodule = (HMODULE) mbi.AllocationBase;
1897     }
1898 
1899   return hmodule;
1900 }
1901 
1902 static gchar *
1903 get_module_share_dir (gconstpointer address)
1904 {
1905   HMODULE hmodule;
1906   gchar *filename;
1907   gchar *retval;
1908 
1909   hmodule = get_module_for_address (address);
1910   if (hmodule == NULL)
1911     return NULL;
1912 
1913   filename = g_win32_get_package_installation_directory_of_module (hmodule);
1914   retval = g_build_filename (filename, &quot;share&quot;, NULL);
1915   g_free (filename);
1916 
1917   return retval;
1918 }
1919 
1920 static const gchar * const *
1921 g_win32_get_system_data_dirs_for_module_real (void (*address_of_function)(void))
1922 {
1923   GArray *data_dirs;
1924   HMODULE hmodule;
1925   static GHashTable *per_module_data_dirs = NULL;
1926   gchar **retval;
1927   gchar *p;
1928   gchar *exe_root;
1929 
1930   hmodule = NULL;
1931   if (address_of_function)
1932     {
1933       G_LOCK (g_utils_global);
1934       hmodule = get_module_for_address (address_of_function);
1935       if (hmodule != NULL)
1936   {
1937     if (per_module_data_dirs == NULL)
1938       per_module_data_dirs = g_hash_table_new (NULL, NULL);
1939     else
1940       {
1941         retval = g_hash_table_lookup (per_module_data_dirs, hmodule);
1942 
1943         if (retval != NULL)
1944     {
1945       G_UNLOCK (g_utils_global);
1946       return (const gchar * const *) retval;
1947     }
1948       }
1949   }
1950     }
1951 
1952   data_dirs = g_array_new (TRUE, TRUE, sizeof (char *));
1953 
1954   /* Documents and Settings\All Users\Application Data */
1955   p = get_special_folder (CSIDL_COMMON_APPDATA);
1956   if (p)
1957     g_array_append_val (data_dirs, p);
1958 
1959   /* Documents and Settings\All Users\Documents */
1960   p = get_special_folder (CSIDL_COMMON_DOCUMENTS);
1961   if (p)
1962     g_array_append_val (data_dirs, p);
1963 
1964   /* Using the above subfolders of Documents and Settings perhaps
1965    * makes sense from a Windows perspective.
1966    *
1967    * But looking at the actual use cases of this function in GTK+
1968    * and GNOME software, what we really want is the &quot;share&quot;
1969    * subdirectory of the installation directory for the package
1970    * our caller is a part of.
1971    *
1972    * The address_of_function parameter, if non-NULL, points to a
1973    * function in the calling module. Use that to determine that
1974    * module&#39;s installation folder, and use its &quot;share&quot; subfolder.
1975    *
1976    * Additionally, also use the &quot;share&quot; subfolder of the installation
1977    * locations of GLib and the .exe file being run.
1978    *
1979    * To guard against none of the above being what is really wanted,
1980    * callers of this function should have Win32-specific code to look
1981    * up their installation folder themselves, and handle a subfolder
1982    * &quot;share&quot; of it in the same way as the folders returned from this
1983    * function.
1984    */
1985 
1986   p = get_module_share_dir (address_of_function);
1987   if (p)
1988     g_array_append_val (data_dirs, p);
1989 
1990   if (glib_dll != NULL)
1991     {
1992       gchar *glib_root = g_win32_get_package_installation_directory_of_module (glib_dll);
1993       p = g_build_filename (glib_root, &quot;share&quot;, NULL);
1994       if (p)
1995   g_array_append_val (data_dirs, p);
1996       g_free (glib_root);
1997     }
1998 
1999   exe_root = g_win32_get_package_installation_directory_of_module (NULL);
2000   p = g_build_filename (exe_root, &quot;share&quot;, NULL);
2001   if (p)
2002     g_array_append_val (data_dirs, p);
2003   g_free (exe_root);
2004 
2005   retval = (gchar **) g_array_free (data_dirs, FALSE);
2006 
2007   if (address_of_function)
2008     {
2009       if (hmodule != NULL)
2010   g_hash_table_insert (per_module_data_dirs, hmodule, retval);
2011       G_UNLOCK (g_utils_global);
2012     }
2013 
2014   return (const gchar * const *) retval;
2015 }
2016 
2017 const gchar * const *
2018 g_win32_get_system_data_dirs_for_module (void (*address_of_function)(void))
2019 {
2020   gboolean should_call_g_get_system_data_dirs;
2021 
2022   should_call_g_get_system_data_dirs = TRUE;
2023   /* These checks are the same as the ones that g_build_system_data_dirs() does.
2024    * Please keep them in sync.
2025    */
2026   G_LOCK (g_utils_global);
2027 
2028   if (!g_system_data_dirs)
2029     {
2030       const gchar *data_dirs = g_getenv (&quot;XDG_DATA_DIRS&quot;);
2031 
2032       if (!data_dirs || !data_dirs[0])
2033         should_call_g_get_system_data_dirs = FALSE;
2034     }
2035 
2036   G_UNLOCK (g_utils_global);
2037 
2038   /* There is a subtle difference between g_win32_get_system_data_dirs_for_module (NULL),
2039    * which is what GLib code can normally call,
2040    * and g_win32_get_system_data_dirs_for_module (&amp;_g_win32_get_system_data_dirs),
2041    * which is what the inline function used by non-GLib code calls.
2042    * The former gets prefix relative to currently-running executable,
2043    * the latter - relative to the module that calls _g_win32_get_system_data_dirs()
2044    * (disguised as g_get_system_data_dirs()), which could be an executable or
2045    * a DLL that is located somewhere else.
2046    * This is why that inline function in gutils.h exists, and why we can&#39;t just
2047    * call g_get_system_data_dirs() from there - because we need to get the address
2048    * local to the non-GLib caller-module.
2049    */
2050 
2051   /*
2052    * g_get_system_data_dirs() will fall back to calling
2053    * g_win32_get_system_data_dirs_for_module_real(NULL) if XDG_DATA_DIRS is NULL
2054    * or an empty string. The checks above ensure that we do not call it in such
2055    * cases and use the address_of_function that we&#39;ve been given by the inline function.
2056    * The reason we&#39;re calling g_get_system_data_dirs /at all/ is to give
2057    * XDG_DATA_DIRS precedence (if it is set).
2058    */
2059   if (should_call_g_get_system_data_dirs)
2060     return g_get_system_data_dirs ();
2061 
2062   return g_win32_get_system_data_dirs_for_module_real (address_of_function);
2063 }
2064 
2065 #endif
2066 
2067 static gchar **
2068 g_build_system_data_dirs (void)
2069 {
2070   gchar **data_dir_vector = NULL;
2071   gchar *data_dirs = (gchar *) g_getenv (&quot;XDG_DATA_DIRS&quot;);
2072 
2073   /* These checks are the same as the ones that g_win32_get_system_data_dirs_for_module()
2074    * does. Please keep them in sync.
2075    */
2076 #ifndef G_OS_WIN32
2077   if (!data_dirs || !data_dirs[0])
2078     data_dirs = &quot;/usr/local/share/:/usr/share/&quot;;
2079 
2080   data_dir_vector = g_strsplit (data_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
2081 #else
2082   if (!data_dirs || !data_dirs[0])
2083     data_dir_vector = g_strdupv ((gchar **) g_win32_get_system_data_dirs_for_module_real (NULL));
2084   else
2085     data_dir_vector = g_strsplit (data_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
2086 #endif
2087 
2088   return g_steal_pointer (&amp;data_dir_vector);
2089 }
2090 
2091 /**
2092  * g_get_system_data_dirs:
2093  *
2094  * Returns an ordered list of base directories in which to access
2095  * system-wide application data.
2096  *
2097  * On UNIX platforms this is determined using the mechanisms described
2098  * in the
2099  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec)
2100  * In this case the list of directories retrieved will be `XDG_DATA_DIRS`.
2101  *
2102  * On Windows it follows XDG Base Directory Specification if `XDG_DATA_DIRS` is defined.
2103  * If `XDG_DATA_DIRS` is undefined,
2104  * the first elements in the list are the Application Data
2105  * and Documents folders for All Users. (These can be determined only
2106  * on Windows 2000 or later and are not present in the list on other
2107  * Windows versions.) See documentation for CSIDL_COMMON_APPDATA and
2108  * CSIDL_COMMON_DOCUMENTS.
2109  *
2110  * Then follows the &quot;share&quot; subfolder in the installation folder for
2111  * the package containing the DLL that calls this function, if it can
2112  * be determined.
2113  *
2114  * Finally the list contains the &quot;share&quot; subfolder in the installation
2115  * folder for GLib, and in the installation folder for the package the
2116  * application&#39;s .exe file belongs to.
2117  *
2118  * The installation folders above are determined by looking up the
2119  * folder where the module (DLL or EXE) in question is located. If the
2120  * folder&#39;s name is &quot;bin&quot;, its parent is used, otherwise the folder
2121  * itself.
2122  *
2123  * Note that on Windows the returned list can vary depending on where
2124  * this function is called.
2125  *
2126  * Returns: (array zero-terminated=1) (element-type filename) (transfer none):
2127  *     a %NULL-terminated array of strings owned by GLib that must not be
2128  *     modified or freed.
2129  *
2130  * Since: 2.6
2131  **/
2132 const gchar * const *
2133 g_get_system_data_dirs (void)
2134 {
2135   const gchar * const *system_data_dirs;
2136 
2137   G_LOCK (g_utils_global);
2138 
2139   if (g_system_data_dirs == NULL)
2140     g_system_data_dirs = g_build_system_data_dirs ();
2141   system_data_dirs = (const gchar * const *) g_system_data_dirs;
2142 
2143   G_UNLOCK (g_utils_global);
2144 
2145   return system_data_dirs;
2146 }
2147 
2148 static gchar **
2149 g_build_system_config_dirs (void)
2150 {
2151   gchar **conf_dir_vector = NULL;
2152   const gchar *conf_dirs = g_getenv (&quot;XDG_CONFIG_DIRS&quot;);
2153 #ifdef G_OS_WIN32
2154   if (conf_dirs)
2155     {
2156       conf_dir_vector = g_strsplit (conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
2157     }
2158   else
2159     {
2160       gchar *special_conf_dirs = get_special_folder (CSIDL_COMMON_APPDATA);
2161 
2162       if (special_conf_dirs)
2163         conf_dir_vector = g_strsplit (special_conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
2164       else
2165         /* Return empty list */
2166         conf_dir_vector = g_strsplit (&quot;&quot;, G_SEARCHPATH_SEPARATOR_S, 0);
2167 
2168       g_free (special_conf_dirs);
2169     }
2170 #else
2171   if (!conf_dirs || !conf_dirs[0])
2172     conf_dirs = &quot;/etc/xdg&quot;;
2173 
2174   conf_dir_vector = g_strsplit (conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
2175 #endif
2176 
2177   return g_steal_pointer (&amp;conf_dir_vector);
2178 }
2179 
2180 /**
2181  * g_get_system_config_dirs:
2182  *
2183  * Returns an ordered list of base directories in which to access
2184  * system-wide configuration information.
2185  *
2186  * On UNIX platforms this is determined using the mechanisms described
2187  * in the
2188  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
2189  * In this case the list of directories retrieved will be `XDG_CONFIG_DIRS`.
2190  *
2191  * On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_DIRS` is defined.
2192  * If `XDG_CONFIG_DIRS` is undefined, the directory that contains application
2193  * data for all users is used instead. A typical path is
2194  * `C:\Documents and Settings\All Users\Application Data`.
2195  * This folder is used for application data
2196  * that is not user specific. For example, an application can store
2197  * a spell-check dictionary, a database of clip art, or a log file in the
2198  * CSIDL_COMMON_APPDATA folder. This information will not roam and is available
2199  * to anyone using the computer.
2200  *
2201  * Returns: (array zero-terminated=1) (element-type filename) (transfer none):
2202  *     a %NULL-terminated array of strings owned by GLib that must not be
2203  *     modified or freed.
2204  *
2205  * Since: 2.6
2206  **/
2207 const gchar * const *
2208 g_get_system_config_dirs (void)
2209 {
2210   const gchar * const *system_config_dirs;
2211 
2212   G_LOCK (g_utils_global);
2213 
2214   if (g_system_config_dirs == NULL)
2215     g_system_config_dirs = g_build_system_config_dirs ();
2216   system_config_dirs = (const gchar * const *) g_system_config_dirs;
2217 
2218   G_UNLOCK (g_utils_global);
2219 
2220   return system_config_dirs;
2221 }
2222 
2223 /**
2224  * g_nullify_pointer:
2225  * @nullify_location: (not nullable): the memory address of the pointer.
2226  *
2227  * Set the pointer at the specified location to %NULL.
2228  **/
2229 void
2230 g_nullify_pointer (gpointer *nullify_location)
2231 {
2232   g_return_if_fail (nullify_location != NULL);
2233 
2234   *nullify_location = NULL;
2235 }
2236 
2237 #define KILOBYTE_FACTOR (G_GOFFSET_CONSTANT (1000))
2238 #define MEGABYTE_FACTOR (KILOBYTE_FACTOR * KILOBYTE_FACTOR)
2239 #define GIGABYTE_FACTOR (MEGABYTE_FACTOR * KILOBYTE_FACTOR)
2240 #define TERABYTE_FACTOR (GIGABYTE_FACTOR * KILOBYTE_FACTOR)
2241 #define PETABYTE_FACTOR (TERABYTE_FACTOR * KILOBYTE_FACTOR)
2242 #define EXABYTE_FACTOR  (PETABYTE_FACTOR * KILOBYTE_FACTOR)
2243 
2244 #define KIBIBYTE_FACTOR (G_GOFFSET_CONSTANT (1024))
2245 #define MEBIBYTE_FACTOR (KIBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2246 #define GIBIBYTE_FACTOR (MEBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2247 #define TEBIBYTE_FACTOR (GIBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2248 #define PEBIBYTE_FACTOR (TEBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2249 #define EXBIBYTE_FACTOR (PEBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2250 
2251 /**
2252  * g_format_size:
2253  * @size: a size in bytes
2254  *
2255  * Formats a size (for example the size of a file) into a human readable
2256  * string.  Sizes are rounded to the nearest size prefix (kB, MB, GB)
2257  * and are displayed rounded to the nearest tenth. E.g. the file size
2258  * 3292528 bytes will be converted into the string &quot;3.2 MB&quot;. The returned string
2259  * is UTF-8, and may use a non-breaking space to separate the number and units,
2260  * to ensure they aren&#39;t separated when line wrapped.
2261  *
2262  * The prefix units base is 1000 (i.e. 1 kB is 1000 bytes).
2263  *
2264  * This string should be freed with g_free() when not needed any longer.
2265  *
2266  * See g_format_size_full() for more options about how the size might be
2267  * formatted.
2268  *
2269  * Returns: a newly-allocated formatted string containing a human readable
2270  *     file size
2271  *
2272  * Since: 2.30
2273  */
2274 gchar *
2275 g_format_size (guint64 size)
2276 {
2277   return g_format_size_full (size, G_FORMAT_SIZE_DEFAULT);
2278 }
2279 
2280 /**
2281  * GFormatSizeFlags:
2282  * @G_FORMAT_SIZE_DEFAULT: behave the same as g_format_size()
2283  * @G_FORMAT_SIZE_LONG_FORMAT: include the exact number of bytes as part
2284  *     of the returned string.  For example, &quot;45.6 kB (45,612 bytes)&quot;.
2285  * @G_FORMAT_SIZE_IEC_UNITS: use IEC (base 1024) units with &quot;KiB&quot;-style
2286  *     suffixes. IEC units should only be used for reporting things with
2287  *     a strong &quot;power of 2&quot; basis, like RAM sizes or RAID stripe sizes.
2288  *     Network and storage sizes should be reported in the normal SI units.
2289  * @G_FORMAT_SIZE_BITS: set the size as a quantity in bits, rather than
2290  *     bytes, and return units in bits. For example, rather than .
2291  *
2292  * Flags to modify the format of the string returned by g_format_size_full().
2293  */
2294 
2295 #ifdef GSTREAMER_LITE
2296 #ifndef G_OS_WIN32
2297 #pragma GCC diagnostic push
2298 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
2299 #endif // G_OS_WIN32
2300 #else // GSTREAMER_LITE
2301 #pragma GCC diagnostic push
2302 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
2303 #endif // GSTREAMER_LITE
2304 
2305 /**
2306  * g_format_size_full:
2307  * @size: a size in bytes
2308  * @flags: #GFormatSizeFlags to modify the output
2309  *
2310  * Formats a size.
2311  *
2312  * This function is similar to g_format_size() but allows for flags
2313  * that modify the output. See #GFormatSizeFlags.
2314  *
2315  * Returns: a newly-allocated formatted string containing a human
2316  *     readable file size
2317  *
2318  * Since: 2.30
2319  */
2320 gchar *
2321 g_format_size_full (guint64          size,
2322                     GFormatSizeFlags flags)
2323 {
2324   struct Format
2325   {
2326     guint64 factor;
2327     char string[10];
2328   };
2329 
2330   typedef enum
2331   {
2332     FORMAT_BYTES,
2333     FORMAT_BYTES_IEC,
2334     FORMAT_BITS,
2335     FORMAT_BITS_IEC
2336   } FormatIndex;
2337 
2338   const struct Format formats[4][6] = {
2339     {
2340       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2341       { KILOBYTE_FACTOR, N_(&quot;%.1f kB&quot;) },
2342       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2343       { MEGABYTE_FACTOR, N_(&quot;%.1f MB&quot;) },
2344       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2345       { GIGABYTE_FACTOR, N_(&quot;%.1f GB&quot;) },
2346       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2347       { TERABYTE_FACTOR, N_(&quot;%.1f TB&quot;) },
2348       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2349       { PETABYTE_FACTOR, N_(&quot;%.1f PB&quot;) },
2350       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2351       { EXABYTE_FACTOR,  N_(&quot;%.1f EB&quot;) }
2352     },
2353     {
2354       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2355       { KIBIBYTE_FACTOR, N_(&quot;%.1f KiB&quot;) },
2356       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2357       { MEBIBYTE_FACTOR, N_(&quot;%.1f MiB&quot;) },
2358       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2359       { GIBIBYTE_FACTOR, N_(&quot;%.1f GiB&quot;) },
2360       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2361       { TEBIBYTE_FACTOR, N_(&quot;%.1f TiB&quot;) },
2362       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2363       { PEBIBYTE_FACTOR, N_(&quot;%.1f PiB&quot;) },
2364       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2365       { EXBIBYTE_FACTOR, N_(&quot;%.1f EiB&quot;) }
2366     },
2367     {
2368       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2369       { KILOBYTE_FACTOR, N_(&quot;%.1f kb&quot;) },
2370       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2371       { MEGABYTE_FACTOR, N_(&quot;%.1f Mb&quot;) },
2372       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2373       { GIGABYTE_FACTOR, N_(&quot;%.1f Gb&quot;) },
2374       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2375       { TERABYTE_FACTOR, N_(&quot;%.1f Tb&quot;) },
2376       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2377       { PETABYTE_FACTOR, N_(&quot;%.1f Pb&quot;) },
2378       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2379       { EXABYTE_FACTOR,  N_(&quot;%.1f Eb&quot;) }
2380     },
2381     {
2382       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2383       { KIBIBYTE_FACTOR, N_(&quot;%.1f Kib&quot;) },
2384       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2385       { MEBIBYTE_FACTOR, N_(&quot;%.1f Mib&quot;) },
2386       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2387       { GIBIBYTE_FACTOR, N_(&quot;%.1f Gib&quot;) },
2388       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2389       { TEBIBYTE_FACTOR, N_(&quot;%.1f Tib&quot;) },
2390       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2391       { PEBIBYTE_FACTOR, N_(&quot;%.1f Pib&quot;) },
2392       /* Translators: Keep the no-break space between %.1f and the unit symbol */
2393       { EXBIBYTE_FACTOR, N_(&quot;%.1f Eib&quot;) }
2394     }
2395   };
2396 
2397   GString *string;
2398   FormatIndex index;
2399 
2400   string = g_string_new (NULL);
2401 
2402   switch (flags &amp; ~G_FORMAT_SIZE_LONG_FORMAT)
2403     {
2404     case G_FORMAT_SIZE_DEFAULT:
2405       index = FORMAT_BYTES;
2406       break;
2407     case (G_FORMAT_SIZE_DEFAULT | G_FORMAT_SIZE_IEC_UNITS):
2408       index = FORMAT_BYTES_IEC;
2409       break;
2410     case G_FORMAT_SIZE_BITS:
2411       index = FORMAT_BITS;
2412       break;
2413     case (G_FORMAT_SIZE_BITS | G_FORMAT_SIZE_IEC_UNITS):
2414       index = FORMAT_BITS_IEC;
2415       break;
2416     default:
2417       g_assert_not_reached ();
2418     }
2419 
2420 
2421   if (size &lt; formats[index][0].factor)
2422     {
2423       const char * format;
2424 
2425       if (index == FORMAT_BYTES || index == FORMAT_BYTES_IEC)
2426         {
2427           format = g_dngettext (GETTEXT_PACKAGE, &quot;%u byte&quot;, &quot;%u bytes&quot;, (guint) size);
2428         }
2429       else
2430         {
2431           format = g_dngettext (GETTEXT_PACKAGE, &quot;%u bit&quot;, &quot;%u bits&quot;, (guint) size);
2432         }
2433 
2434       g_string_printf (string, format, (guint) size);
2435 
2436       flags &amp;= ~G_FORMAT_SIZE_LONG_FORMAT;
2437     }
2438   else
2439     {
2440       const gsize n = G_N_ELEMENTS (formats[index]);
2441       gsize i;
2442 
2443       /*
2444        * Point the last format (the highest unit) by default
2445        * and then then scan all formats, starting with the 2nd one
2446        * because the 1st is already managed by with the plural form
2447        */
2448       const struct Format * f = &amp;formats[index][n - 1];
2449 
2450       for (i = 1; i &lt; n; i++)
2451         {
2452           if (size &lt; formats[index][i].factor)
2453             {
2454               f = &amp;formats[index][i - 1];
2455               break;
2456             }
2457         }
2458 
2459       g_string_printf (string, _(f-&gt;string), (gdouble) size / (gdouble) f-&gt;factor);
2460     }
2461 
2462   if (flags &amp; G_FORMAT_SIZE_LONG_FORMAT)
2463     {
2464       /* First problem: we need to use the number of bytes to decide on
2465        * the plural form that is used for display, but the number of
2466        * bytes potentially exceeds the size of a guint (which is what
2467        * ngettext() takes).
2468        *
2469        * From a pragmatic standpoint, it seems that all known languages
2470        * base plural forms on one or both of the following:
2471        *
2472        *   - the lowest digits of the number
2473        *
2474        *   - if the number if greater than some small value
2475        *
2476        * Here&#39;s how we fake it:  Draw an arbitrary line at one thousand.
2477        * If the number is below that, then fine.  If it is above it,
2478        * then we take the modulus of the number by one thousand (in
2479        * order to keep the lowest digits) and add one thousand to that
2480        * (in order to ensure that 1001 is not treated the same as 1).
2481        */
2482       guint plural_form = size &lt; 1000 ? size : size % 1000 + 1000;
2483 
2484       /* Second problem: we need to translate the string &quot;%u byte/bit&quot; and
2485        * &quot;%u bytes/bits&quot; for pluralisation, but the correct number format to
2486        * use for a gsize is different depending on which architecture
2487        * we&#39;re on.
2488        *
2489        * Solution: format the number separately and use &quot;%s bytes/bits&quot; on
2490        * all platforms.
2491        */
2492       const gchar *translated_format;
2493       gchar *formatted_number;
2494 
2495       if (index == FORMAT_BYTES || index == FORMAT_BYTES_IEC)
2496         {
2497           /* Translators: the %s in &quot;%s bytes&quot; will always be replaced by a number. */
2498           translated_format = g_dngettext (GETTEXT_PACKAGE, &quot;%s byte&quot;, &quot;%s bytes&quot;, plural_form);
2499         }
2500       else
2501         {
2502           /* Translators: the %s in &quot;%s bits&quot; will always be replaced by a number. */
2503           translated_format = g_dngettext (GETTEXT_PACKAGE, &quot;%s bit&quot;, &quot;%s bits&quot;, plural_form);
2504         }
2505       formatted_number = g_strdup_printf (&quot;%&#39;&quot;G_GUINT64_FORMAT, size);
2506 
2507       g_string_append (string, &quot; (&quot;);
2508       g_string_append_printf (string, translated_format, formatted_number);
2509       g_free (formatted_number);
2510       g_string_append (string, &quot;)&quot;);
2511     }
2512 
2513   return g_string_free (string, FALSE);
2514 }
2515 
2516 #ifdef GSTREAMER_LITE
2517 #ifndef G_OS_WIN32
2518 #pragma GCC diagnostic pop
2519 #endif // G_OS_WIN32
2520 #else // GSTREAMER_LITE
2521 #pragma GCC diagnostic pop
2522 #endif // GSTREAMER_LITE
2523 
2524 /**
2525  * g_format_size_for_display:
2526  * @size: a size in bytes
2527  *
2528  * Formats a size (for example the size of a file) into a human
2529  * readable string. Sizes are rounded to the nearest size prefix
2530  * (KB, MB, GB) and are displayed rounded to the nearest tenth.
2531  * E.g. the file size 3292528 bytes will be converted into the
2532  * string &quot;3.1 MB&quot;.
2533  *
2534  * The prefix units base is 1024 (i.e. 1 KB is 1024 bytes).
2535  *
2536  * This string should be freed with g_free() when not needed any longer.
2537  *
2538  * Returns: a newly-allocated formatted string containing a human
2539  *     readable file size
2540  *
2541  * Since: 2.16
2542  *
2543  * Deprecated:2.30: This function is broken due to its use of SI
2544  *     suffixes to denote IEC units. Use g_format_size() instead.
2545  */
2546 gchar *
2547 g_format_size_for_display (goffset size)
2548 {
2549   if (size &lt; (goffset) KIBIBYTE_FACTOR)
2550     return g_strdup_printf (g_dngettext(GETTEXT_PACKAGE, &quot;%u byte&quot;, &quot;%u bytes&quot;,(guint) size), (guint) size);
2551   else
2552     {
2553       gdouble displayed_size;
2554 
2555       if (size &lt; (goffset) MEBIBYTE_FACTOR)
2556         {
2557           displayed_size = (gdouble) size / (gdouble) KIBIBYTE_FACTOR;
2558           /* Translators: this is from the deprecated function g_format_size_for_display() which uses &#39;KB&#39; to
2559            * mean 1024 bytes.  I am aware that &#39;KB&#39; is not correct, but it has been preserved for reasons of
2560            * compatibility.  Users will not see this string unless a program is using this deprecated function.
2561            * Please translate as literally as possible.
2562            */
2563           return g_strdup_printf (_(&quot;%.1f KB&quot;), displayed_size);
2564         }
2565       else if (size &lt; (goffset) GIBIBYTE_FACTOR)
2566         {
2567           displayed_size = (gdouble) size / (gdouble) MEBIBYTE_FACTOR;
2568           return g_strdup_printf (_(&quot;%.1f MB&quot;), displayed_size);
2569         }
2570       else if (size &lt; (goffset) TEBIBYTE_FACTOR)
2571         {
2572           displayed_size = (gdouble) size / (gdouble) GIBIBYTE_FACTOR;
2573           return g_strdup_printf (_(&quot;%.1f GB&quot;), displayed_size);
2574         }
2575       else if (size &lt; (goffset) PEBIBYTE_FACTOR)
2576         {
2577           displayed_size = (gdouble) size / (gdouble) TEBIBYTE_FACTOR;
2578           return g_strdup_printf (_(&quot;%.1f TB&quot;), displayed_size);
2579         }
2580       else if (size &lt; (goffset) EXBIBYTE_FACTOR)
2581         {
2582           displayed_size = (gdouble) size / (gdouble) PEBIBYTE_FACTOR;
2583           return g_strdup_printf (_(&quot;%.1f PB&quot;), displayed_size);
2584         }
2585       else
2586         {
2587           displayed_size = (gdouble) size / (gdouble) EXBIBYTE_FACTOR;
2588           return g_strdup_printf (_(&quot;%.1f EB&quot;), displayed_size);
2589         }
2590     }
2591 }
2592 
2593 #if defined (G_OS_WIN32) &amp;&amp; !defined (_WIN64)
2594 
2595 /* Binary compatibility versions. Not for newly compiled code. */
2596 
2597 _GLIB_EXTERN const gchar *g_get_user_name_utf8        (void);
2598 _GLIB_EXTERN const gchar *g_get_real_name_utf8        (void);
2599 _GLIB_EXTERN const gchar *g_get_home_dir_utf8         (void);
2600 _GLIB_EXTERN const gchar *g_get_tmp_dir_utf8          (void);
2601 _GLIB_EXTERN gchar       *g_find_program_in_path_utf8 (const gchar *program);
2602 
2603 gchar *
2604 g_find_program_in_path_utf8 (const gchar *program)
2605 {
2606   return g_find_program_in_path (program);
2607 }
2608 
2609 const gchar *g_get_user_name_utf8 (void) { return g_get_user_name (); }
2610 const gchar *g_get_real_name_utf8 (void) { return g_get_real_name (); }
2611 const gchar *g_get_home_dir_utf8 (void) { return g_get_home_dir (); }
2612 const gchar *g_get_tmp_dir_utf8 (void) { return g_get_tmp_dir (); }
2613 
2614 #endif
2615 
2616 /* Private API:
2617  *
2618  * Returns %TRUE if the current process was executed as setuid
2619  */
2620 gboolean
2621 g_check_setuid (void)
2622 {
2623 #if defined(HAVE_SYS_AUXV_H) &amp;&amp; defined(HAVE_GETAUXVAL) &amp;&amp; defined(AT_SECURE)
2624   unsigned long value;
2625   int errsv;
2626 
2627   errno = 0;
2628   value = getauxval (AT_SECURE);
2629   errsv = errno;
2630   if (errsv)
2631     g_error (&quot;getauxval () failed: %s&quot;, g_strerror (errsv));
2632   return value;
2633 #elif defined(HAVE_ISSETUGID) &amp;&amp; !defined(__BIONIC__)
2634   /* BSD: http://www.freebsd.org/cgi/man.cgi?query=issetugid&amp;sektion=2 */
2635 
2636   /* Android had it in older versions but the new 64 bit ABI does not
2637    * have it anymore, and some versions of the 32 bit ABI neither.
2638    * https://code.google.com/p/android-developer-preview/issues/detail?id=168
2639    */
2640   return issetugid ();
2641 #elif defined(G_OS_UNIX)
2642   uid_t ruid, euid, suid; /* Real, effective and saved user ID&#39;s */
2643   gid_t rgid, egid, sgid; /* Real, effective and saved group ID&#39;s */
2644 
2645   static gsize check_setuid_initialised;
2646   static gboolean is_setuid;
2647 
2648   if (g_once_init_enter (&amp;check_setuid_initialised))
2649     {
2650 #ifdef HAVE_GETRESUID
2651       /* These aren&#39;t in the header files, so we prototype them here.
2652        */
2653       int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid);
2654       int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid);
2655 
2656       if (getresuid (&amp;ruid, &amp;euid, &amp;suid) != 0 ||
2657           getresgid (&amp;rgid, &amp;egid, &amp;sgid) != 0)
2658 #endif /* HAVE_GETRESUID */
2659         {
2660           suid = ruid = getuid ();
2661           sgid = rgid = getgid ();
2662           euid = geteuid ();
2663           egid = getegid ();
2664         }
2665 
2666       is_setuid = (ruid != euid || ruid != suid ||
2667                    rgid != egid || rgid != sgid);
2668 
2669       g_once_init_leave (&amp;check_setuid_initialised, 1);
2670     }
2671   return is_setuid;
2672 #else
2673   return FALSE;
2674 #endif
2675 }
2676 
2677 #ifdef G_OS_WIN32
2678 /**
2679  * g_abort:
2680  *
2681  * A wrapper for the POSIX abort() function.
2682  *
2683  * On Windows it is a function that makes extra effort (including a call
2684  * to abort()) to ensure that a debugger-catchable exception is thrown
2685  * before the program terminates.
2686  *
2687  * See your C library manual for more details about abort().
2688  *
2689  * Since: 2.50
2690  */
2691 void
2692 g_abort (void)
2693 {
2694   /* One call to break the debugger */
2695   DebugBreak ();
2696   /* One call in case CRT does get saner about abort() behaviour */
2697   abort ();
2698   /* And one call to bind them all and terminate the program for sure */
2699   ExitProcess (127);
2700 }
2701 #endif
    </pre>
  </body>
</html>