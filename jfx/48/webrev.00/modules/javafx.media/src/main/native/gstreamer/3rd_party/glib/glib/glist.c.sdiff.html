<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/glist.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="glib.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="glist.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/glist.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 365 
 366   tmp_list = g_list_nth (list, position);
 367   if (!tmp_list)
 368     return g_list_append (list, data);
 369 
 370   new_list = _g_list_alloc ();
 371 #ifdef GSTREAMER_LITE
 372   if (new_list == NULL) {
 373     return NULL;
 374   }
 375 #endif // GSTREAMER_LITE
 376   new_list-&gt;data = data;
 377   new_list-&gt;prev = tmp_list-&gt;prev;
 378   tmp_list-&gt;prev-&gt;next = new_list;
 379   new_list-&gt;next = tmp_list;
 380   tmp_list-&gt;prev = new_list;
 381 
 382   return list;
 383 }
 384 


























































 385 /**
 386  * g_list_insert_before:
 387  * @list: a pointer to a #GList, this must point to the top of the list
 388  * @sibling: the list element before which the new element
 389  *     is inserted or %NULL to insert at the end of the list
 390  * @data: the data for the new element
 391  *
 392  * Inserts a new element into the list before the given position.
 393  *
 394  * Returns: the (possibly changed) start of the #GList
 395  */
 396 GList *
 397 g_list_insert_before (GList    *list,
 398                       GList    *sibling,
 399                       gpointer  data)
 400 {
<span class="line-modified"> 401   if (!list)</span>
 402     {
 403       list = g_list_alloc ();
 404       list-&gt;data = data;
 405       g_return_val_if_fail (sibling == NULL, list);
 406       return list;
 407     }
<span class="line-modified"> 408   else if (sibling)</span>
 409     {
 410       GList *node;
 411 
 412       node = _g_list_alloc ();
 413 #ifdef GSTREAMER_LITE
 414       if (node == NULL) {
 415         return NULL;
 416       }
 417 #endif // GSTREAMER_LITE
 418       node-&gt;data = data;
 419       node-&gt;prev = sibling-&gt;prev;
 420       node-&gt;next = sibling;
 421       sibling-&gt;prev = node;
<span class="line-modified"> 422       if (node-&gt;prev)</span>
 423         {
 424           node-&gt;prev-&gt;next = node;
 425           return list;
 426         }
 427       else
 428         {
 429           g_return_val_if_fail (sibling == list, node);
 430           return node;
 431         }
 432     }
 433   else
 434     {
 435       GList *last;
 436 
<span class="line-modified"> 437       last = list;</span>
<span class="line-removed"> 438       while (last-&gt;next)</span>
<span class="line-removed"> 439         last = last-&gt;next;</span>
 440 
 441       last-&gt;next = _g_list_alloc ();
 442 #ifdef GSTREAMER_LITE
 443       if (last-&gt;next == NULL) {
 444         return NULL;
 445       }
 446 #endif // GSTREAMER_LITE
 447       last-&gt;next-&gt;data = data;
 448       last-&gt;next-&gt;prev = last;
 449       last-&gt;next-&gt;next = NULL;
 450 
 451       return list;
 452     }
 453 }
 454 
 455 /**
 456  * g_list_concat:
 457  * @list1: a #GList, this must point to the top of the list
 458  * @list2: the #GList to add to the end of the first #GList,
 459  *     this must point  to the top of the list
</pre>
<hr />
<pre>
 659 g_list_copy (GList *list)
 660 {
 661   return g_list_copy_deep (list, NULL, NULL);
 662 }
 663 
 664 /**
 665  * g_list_copy_deep:
 666  * @list: a #GList, this must point to the top of the list
 667  * @func: a copy function used to copy every element in the list
 668  * @user_data: user data passed to the copy function @func, or %NULL
 669  *
 670  * Makes a full (deep) copy of a #GList.
 671  *
 672  * In contrast with g_list_copy(), this function uses @func to make
 673  * a copy of each list element, in addition to copying the list
 674  * container itself.
 675  *
 676  * @func, as a #GCopyFunc, takes two arguments, the data to be copied
 677  * and a @user_data pointer. On common processor architectures, it&#39;s safe to
 678  * pass %NULL as @user_data if the copy function takes only one argument. You
<span class="line-modified"> 679  * may get compiler warnings from this though if compiling with GCCâ€™s</span>
 680  * `-Wcast-function-type` warning.
 681  *
 682  * For instance, if @list holds a list of GObjects, you can do:
 683  * |[&lt;!-- language=&quot;C&quot; --&gt;
 684  * another_list = g_list_copy_deep (list, (GCopyFunc) g_object_ref, NULL);
 685  * ]|
 686  *
 687  * And, to entirely free the new list, you could do:
 688  * |[&lt;!-- language=&quot;C&quot; --&gt;
 689  * g_list_free_full (another_list, g_object_unref);
 690  * ]|
 691  *
 692  * Returns: the start of the new list that holds a full copy of @list,
 693  *     use g_list_free_full() to free it
 694  *
 695  * Since: 2.34
 696  */
 697 GList *
 698 g_list_copy_deep (GList     *list,
 699                   GCopyFunc  func,
 700                   gpointer   user_data)
 701 {
 702   GList *new_list = NULL;
 703 
 704   if (list)
 705     {
 706       GList *last;
 707 
 708       new_list = _g_list_alloc ();
<span class="line-modified"> 709  #ifdef GSTREAMER_LITE</span>
 710       if (new_list == NULL) {
 711         return NULL;
 712       }
<span class="line-modified"> 713  #endif // GSTREAMER_LITE</span>
 714       if (func)
 715         new_list-&gt;data = func (list-&gt;data, user_data);
 716       else
 717         new_list-&gt;data = list-&gt;data;
 718       new_list-&gt;prev = NULL;
 719       last = new_list;
 720       list = list-&gt;next;
 721       while (list)
 722         {
 723           last-&gt;next = _g_list_alloc ();
 724 #ifdef GSTREAMER_LITE
 725           if (last-&gt;next == NULL) {
 726             return NULL;
 727           }
 728 #endif // GSTREAMER_LITE
 729           last-&gt;next-&gt;prev = last;
 730           last = last-&gt;next;
 731           if (func)
 732             last-&gt;data = func (list-&gt;data, user_data);
 733           else
</pre>
</td>
<td>
<hr />
<pre>
 365 
 366   tmp_list = g_list_nth (list, position);
 367   if (!tmp_list)
 368     return g_list_append (list, data);
 369 
 370   new_list = _g_list_alloc ();
 371 #ifdef GSTREAMER_LITE
 372   if (new_list == NULL) {
 373     return NULL;
 374   }
 375 #endif // GSTREAMER_LITE
 376   new_list-&gt;data = data;
 377   new_list-&gt;prev = tmp_list-&gt;prev;
 378   tmp_list-&gt;prev-&gt;next = new_list;
 379   new_list-&gt;next = tmp_list;
 380   tmp_list-&gt;prev = new_list;
 381 
 382   return list;
 383 }
 384 
<span class="line-added"> 385 /**</span>
<span class="line-added"> 386  * g_list_insert_before_link:</span>
<span class="line-added"> 387  * @list: a pointer to a #GList, this must point to the top of the list</span>
<span class="line-added"> 388  * @sibling: (nullable): the list element before which the new element</span>
<span class="line-added"> 389  *     is inserted or %NULL to insert at the end of the list</span>
<span class="line-added"> 390  * @link_: the list element to be added, which must not be part of</span>
<span class="line-added"> 391  *     any other list</span>
<span class="line-added"> 392  *</span>
<span class="line-added"> 393  * Inserts @link_ into the list before the given position.</span>
<span class="line-added"> 394  *</span>
<span class="line-added"> 395  * Returns: the (possibly changed) start of the #GList</span>
<span class="line-added"> 396  *</span>
<span class="line-added"> 397  * Since: 2.62</span>
<span class="line-added"> 398  */</span>
<span class="line-added"> 399 GList *</span>
<span class="line-added"> 400 g_list_insert_before_link (GList *list,</span>
<span class="line-added"> 401                            GList *sibling,</span>
<span class="line-added"> 402                            GList *link_)</span>
<span class="line-added"> 403 {</span>
<span class="line-added"> 404   g_return_val_if_fail (link_ != NULL, list);</span>
<span class="line-added"> 405   g_return_val_if_fail (link_-&gt;prev == NULL, list);</span>
<span class="line-added"> 406   g_return_val_if_fail (link_-&gt;next == NULL, list);</span>
<span class="line-added"> 407 </span>
<span class="line-added"> 408   if (list == NULL)</span>
<span class="line-added"> 409     {</span>
<span class="line-added"> 410       g_return_val_if_fail (sibling == NULL, list);</span>
<span class="line-added"> 411       return link_;</span>
<span class="line-added"> 412     }</span>
<span class="line-added"> 413   else if (sibling != NULL)</span>
<span class="line-added"> 414     {</span>
<span class="line-added"> 415       link_-&gt;prev = sibling-&gt;prev;</span>
<span class="line-added"> 416       link_-&gt;next = sibling;</span>
<span class="line-added"> 417       sibling-&gt;prev = link_;</span>
<span class="line-added"> 418       if (link_-&gt;prev != NULL)</span>
<span class="line-added"> 419         {</span>
<span class="line-added"> 420           link_-&gt;prev-&gt;next = link_;</span>
<span class="line-added"> 421           return list;</span>
<span class="line-added"> 422         }</span>
<span class="line-added"> 423       else</span>
<span class="line-added"> 424         {</span>
<span class="line-added"> 425           g_return_val_if_fail (sibling == list, link_);</span>
<span class="line-added"> 426           return link_;</span>
<span class="line-added"> 427         }</span>
<span class="line-added"> 428     }</span>
<span class="line-added"> 429   else</span>
<span class="line-added"> 430     {</span>
<span class="line-added"> 431       GList *last;</span>
<span class="line-added"> 432 </span>
<span class="line-added"> 433       for (last = list; last-&gt;next != NULL; last = last-&gt;next) {}</span>
<span class="line-added"> 434 </span>
<span class="line-added"> 435       last-&gt;next = link_;</span>
<span class="line-added"> 436       last-&gt;next-&gt;prev = last;</span>
<span class="line-added"> 437       last-&gt;next-&gt;next = NULL;</span>
<span class="line-added"> 438 </span>
<span class="line-added"> 439       return list;</span>
<span class="line-added"> 440     }</span>
<span class="line-added"> 441 }</span>
<span class="line-added"> 442 </span>
 443 /**
 444  * g_list_insert_before:
 445  * @list: a pointer to a #GList, this must point to the top of the list
 446  * @sibling: the list element before which the new element
 447  *     is inserted or %NULL to insert at the end of the list
 448  * @data: the data for the new element
 449  *
 450  * Inserts a new element into the list before the given position.
 451  *
 452  * Returns: the (possibly changed) start of the #GList
 453  */
 454 GList *
 455 g_list_insert_before (GList    *list,
 456                       GList    *sibling,
 457                       gpointer  data)
 458 {
<span class="line-modified"> 459   if (list == NULL)</span>
 460     {
 461       list = g_list_alloc ();
 462       list-&gt;data = data;
 463       g_return_val_if_fail (sibling == NULL, list);
 464       return list;
 465     }
<span class="line-modified"> 466   else if (sibling != NULL)</span>
 467     {
 468       GList *node;
 469 
 470       node = _g_list_alloc ();
 471 #ifdef GSTREAMER_LITE
 472       if (node == NULL) {
 473         return NULL;
 474       }
 475 #endif // GSTREAMER_LITE
 476       node-&gt;data = data;
 477       node-&gt;prev = sibling-&gt;prev;
 478       node-&gt;next = sibling;
 479       sibling-&gt;prev = node;
<span class="line-modified"> 480       if (node-&gt;prev != NULL)</span>
 481         {
 482           node-&gt;prev-&gt;next = node;
 483           return list;
 484         }
 485       else
 486         {
 487           g_return_val_if_fail (sibling == list, node);
 488           return node;
 489         }
 490     }
 491   else
 492     {
 493       GList *last;
 494 
<span class="line-modified"> 495       for (last = list; last-&gt;next != NULL; last = last-&gt;next) {}</span>


 496 
 497       last-&gt;next = _g_list_alloc ();
 498 #ifdef GSTREAMER_LITE
 499       if (last-&gt;next == NULL) {
 500         return NULL;
 501       }
 502 #endif // GSTREAMER_LITE
 503       last-&gt;next-&gt;data = data;
 504       last-&gt;next-&gt;prev = last;
 505       last-&gt;next-&gt;next = NULL;
 506 
 507       return list;
 508     }
 509 }
 510 
 511 /**
 512  * g_list_concat:
 513  * @list1: a #GList, this must point to the top of the list
 514  * @list2: the #GList to add to the end of the first #GList,
 515  *     this must point  to the top of the list
</pre>
<hr />
<pre>
 715 g_list_copy (GList *list)
 716 {
 717   return g_list_copy_deep (list, NULL, NULL);
 718 }
 719 
 720 /**
 721  * g_list_copy_deep:
 722  * @list: a #GList, this must point to the top of the list
 723  * @func: a copy function used to copy every element in the list
 724  * @user_data: user data passed to the copy function @func, or %NULL
 725  *
 726  * Makes a full (deep) copy of a #GList.
 727  *
 728  * In contrast with g_list_copy(), this function uses @func to make
 729  * a copy of each list element, in addition to copying the list
 730  * container itself.
 731  *
 732  * @func, as a #GCopyFunc, takes two arguments, the data to be copied
 733  * and a @user_data pointer. On common processor architectures, it&#39;s safe to
 734  * pass %NULL as @user_data if the copy function takes only one argument. You
<span class="line-modified"> 735  * may get compiler warnings from this though if compiling with GCC&#39;s</span>
 736  * `-Wcast-function-type` warning.
 737  *
 738  * For instance, if @list holds a list of GObjects, you can do:
 739  * |[&lt;!-- language=&quot;C&quot; --&gt;
 740  * another_list = g_list_copy_deep (list, (GCopyFunc) g_object_ref, NULL);
 741  * ]|
 742  *
 743  * And, to entirely free the new list, you could do:
 744  * |[&lt;!-- language=&quot;C&quot; --&gt;
 745  * g_list_free_full (another_list, g_object_unref);
 746  * ]|
 747  *
 748  * Returns: the start of the new list that holds a full copy of @list,
 749  *     use g_list_free_full() to free it
 750  *
 751  * Since: 2.34
 752  */
 753 GList *
 754 g_list_copy_deep (GList     *list,
 755                   GCopyFunc  func,
 756                   gpointer   user_data)
 757 {
 758   GList *new_list = NULL;
 759 
 760   if (list)
 761     {
 762       GList *last;
 763 
 764       new_list = _g_list_alloc ();
<span class="line-modified"> 765 #ifdef GSTREAMER_LITE</span>
 766       if (new_list == NULL) {
 767         return NULL;
 768       }
<span class="line-modified"> 769 #endif // GSTREAMER_LITE</span>
 770       if (func)
 771         new_list-&gt;data = func (list-&gt;data, user_data);
 772       else
 773         new_list-&gt;data = list-&gt;data;
 774       new_list-&gt;prev = NULL;
 775       last = new_list;
 776       list = list-&gt;next;
 777       while (list)
 778         {
 779           last-&gt;next = _g_list_alloc ();
 780 #ifdef GSTREAMER_LITE
 781           if (last-&gt;next == NULL) {
 782             return NULL;
 783           }
 784 #endif // GSTREAMER_LITE
 785           last-&gt;next-&gt;prev = last;
 786           last = last-&gt;next;
 787           if (func)
 788             last-&gt;data = func (list-&gt;data, user_data);
 789           else
</pre>
</td>
</tr>
</table>
<center><a href="glib.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="glist.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>