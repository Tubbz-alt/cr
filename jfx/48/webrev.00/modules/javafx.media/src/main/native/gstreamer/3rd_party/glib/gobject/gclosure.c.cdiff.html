<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gclosure.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gboxed.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gclosure.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gclosure.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 84,39 ***</span>
   *
   * - g_closure_invalidate() and invalidation notifiers allow callbacks to be
   *   automatically removed when the objects they point to go away.
   */
  
<span class="line-modified">! #define CLOSURE_MAX_REF_COUNT       ((1 &lt;&lt; 15) - 1)</span>
<span class="line-modified">! #define CLOSURE_MAX_N_GUARDS        ((1 &lt;&lt; 1) - 1)</span>
<span class="line-modified">! #define CLOSURE_MAX_N_FNOTIFIERS    ((1 &lt;&lt; 2) - 1)</span>
<span class="line-modified">! #define CLOSURE_MAX_N_INOTIFIERS    ((1 &lt;&lt; 8) - 1)</span>
<span class="line-modified">! #define CLOSURE_N_MFUNCS(cl)        (((cl)-&gt;n_guards &lt;&lt; 1L))</span>
  /* same as G_CLOSURE_N_NOTIFIERS() (keep in sync) */
<span class="line-modified">! #define CLOSURE_N_NOTIFIERS(cl)     (CLOSURE_N_MFUNCS (cl) + \</span>
                                           (cl)-&gt;n_fnotifiers + \
                                           (cl)-&gt;n_inotifiers)
  
  typedef union {
    GClosure closure;
    volatile gint vint;
  } ClosureInt;
  
  #define CHANGE_FIELD(_closure, _field, _OP, _value, _must_set, _SET_OLD, _SET_NEW)      \
  G_STMT_START {                                                                          \
<span class="line-modified">!   ClosureInt *cunion = (ClosureInt*) _closure;                                      \</span>
<span class="line-modified">!   gint new_int, old_int, success;                                                   \</span>
<span class="line-modified">!   do                                                                            \</span>
<span class="line-modified">!     {                                                                           \</span>
<span class="line-modified">!       ClosureInt tmp;                                                           \</span>
<span class="line-modified">!       tmp.vint = old_int = cunion-&gt;vint;                                        \</span>
        _SET_OLD tmp.closure._field;                                                      \
<span class="line-modified">!       tmp.closure._field _OP _value;                                            \</span>
        _SET_NEW tmp.closure._field;                                                      \
<span class="line-modified">!       new_int = tmp.vint;                                                       \</span>
        success = g_atomic_int_compare_and_exchange (&amp;cunion-&gt;vint, old_int, new_int);    \
<span class="line-modified">!     }                                                                           \</span>
    while (!success &amp;&amp; _must_set);                                                        \
  } G_STMT_END
  
  #define SWAP(_closure, _field, _value, _oldv)   CHANGE_FIELD (_closure, _field, =, _value, TRUE, *(_oldv) =,     (void) )
  #define SET(_closure, _field, _value)           CHANGE_FIELD (_closure, _field, =, _value, TRUE,     (void),     (void) )
<span class="line-new-header">--- 84,39 ---</span>
   *
   * - g_closure_invalidate() and invalidation notifiers allow callbacks to be
   *   automatically removed when the objects they point to go away.
   */
  
<span class="line-modified">! #define CLOSURE_MAX_REF_COUNT   ((1 &lt;&lt; 15) - 1)</span>
<span class="line-modified">! #define CLOSURE_MAX_N_GUARDS    ((1 &lt;&lt; 1) - 1)</span>
<span class="line-modified">! #define CLOSURE_MAX_N_FNOTIFIERS  ((1 &lt;&lt; 2) - 1)</span>
<span class="line-modified">! #define CLOSURE_MAX_N_INOTIFIERS  ((1 &lt;&lt; 8) - 1)</span>
<span class="line-modified">! #define CLOSURE_N_MFUNCS(cl)    (((cl)-&gt;n_guards &lt;&lt; 1L))</span>
  /* same as G_CLOSURE_N_NOTIFIERS() (keep in sync) */
<span class="line-modified">! #define CLOSURE_N_NOTIFIERS(cl)   (CLOSURE_N_MFUNCS (cl) + \</span>
                                           (cl)-&gt;n_fnotifiers + \
                                           (cl)-&gt;n_inotifiers)
  
  typedef union {
    GClosure closure;
    volatile gint vint;
  } ClosureInt;
  
  #define CHANGE_FIELD(_closure, _field, _OP, _value, _must_set, _SET_OLD, _SET_NEW)      \
  G_STMT_START {                                                                          \
<span class="line-modified">!   ClosureInt *cunion = (ClosureInt*) _closure;                                    \</span>
<span class="line-modified">!   gint new_int, old_int, success;                                                 \</span>
<span class="line-modified">!   do                                                                        \</span>
<span class="line-modified">!     {                                                                       \</span>
<span class="line-modified">!       ClosureInt tmp;                                                       \</span>
<span class="line-modified">!       tmp.vint = old_int = cunion-&gt;vint;                                    \</span>
        _SET_OLD tmp.closure._field;                                                      \
<span class="line-modified">!       tmp.closure._field _OP _value;                                          \</span>
        _SET_NEW tmp.closure._field;                                                      \
<span class="line-modified">!       new_int = tmp.vint;                                                   \</span>
        success = g_atomic_int_compare_and_exchange (&amp;cunion-&gt;vint, old_int, new_int);    \
<span class="line-modified">!     }                                                                       \</span>
    while (!success &amp;&amp; _must_set);                                                        \
  } G_STMT_END
  
  #define SWAP(_closure, _field, _value, _oldv)   CHANGE_FIELD (_closure, _field, =, _value, TRUE, *(_oldv) =,     (void) )
  #define SET(_closure, _field, _value)           CHANGE_FIELD (_closure, _field, =, _value, TRUE,     (void),     (void) )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 188,11 ***</span>
   *
   * Returns: (transfer none): a floating reference to a new #GClosure
   */
  GClosure*
  g_closure_new_simple (guint           sizeof_closure,
<span class="line-modified">!               gpointer        data)</span>
  {
    GClosure *closure;
    gint private_size;
    gchar *allocated;
  
<span class="line-new-header">--- 188,11 ---</span>
   *
   * Returns: (transfer none): a floating reference to a new #GClosure
   */
  GClosure*
  g_closure_new_simple (guint           sizeof_closure,
<span class="line-modified">!           gpointer        data)</span>
  {
    GClosure *closure;
    gint private_size;
    gchar *allocated;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 234,11 ***</span>
    return closure;
  }
  
  static inline void
  closure_invoke_notifiers (GClosure *closure,
<span class="line-modified">!               guint     notify_type)</span>
  {
    /* notifier layout:
     *     n_guards    n_guards     n_fnotif.  n_inotifiers
     * -&gt;[[pre_guards][post_guards][fnotifiers][inotifiers]]
     *
<span class="line-new-header">--- 234,11 ---</span>
    return closure;
  }
  
  static inline void
  closure_invoke_notifiers (GClosure *closure,
<span class="line-modified">!         guint     notify_type)</span>
  {
    /* notifier layout:
     *     n_guards    n_guards     n_fnotif.  n_inotifiers
     * -&gt;[[pre_guards][post_guards][fnotifiers][inotifiers]]
     *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 259,62 ***</span>
      {
        GClosureNotifyData *ndata;
        guint i, offs;
      case FNOTIFY:
        while (closure-&gt;n_fnotifiers)
<span class="line-modified">!     {</span>
            guint n;
<span class="line-modified">!       DEC_ASSIGN (closure, n_fnotifiers, &amp;n);</span>
  
<span class="line-modified">!       ndata = closure-&gt;notifiers + CLOSURE_N_MFUNCS (closure) + n;</span>
<span class="line-modified">!       closure-&gt;marshal = (GClosureMarshal) ndata-&gt;notify;</span>
<span class="line-modified">!       closure-&gt;data = ndata-&gt;data;</span>
<span class="line-modified">!       ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified">!     }</span>
        closure-&gt;marshal = NULL;
        closure-&gt;data = NULL;
        break;
      case INOTIFY:
        SET (closure, in_inotify, TRUE);
        while (closure-&gt;n_inotifiers)
<span class="line-modified">!     {</span>
            guint n;
            DEC_ASSIGN (closure, n_inotifiers, &amp;n);
  
<span class="line-modified">!       ndata = closure-&gt;notifiers + CLOSURE_N_MFUNCS (closure) + closure-&gt;n_fnotifiers + n;</span>
<span class="line-modified">!       closure-&gt;marshal = (GClosureMarshal) ndata-&gt;notify;</span>
<span class="line-modified">!       closure-&gt;data = ndata-&gt;data;</span>
<span class="line-modified">!       ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified">!     }</span>
        closure-&gt;marshal = NULL;
        closure-&gt;data = NULL;
        SET (closure, in_inotify, FALSE);
        break;
      case PRE_NOTIFY:
        i = closure-&gt;n_guards;
        offs = 0;
        while (i--)
<span class="line-modified">!     {</span>
<span class="line-modified">!       ndata = closure-&gt;notifiers + offs + i;</span>
<span class="line-modified">!       ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified">!     }</span>
        break;
      case POST_NOTIFY:
        i = closure-&gt;n_guards;
        offs = i;
        while (i--)
<span class="line-modified">!     {</span>
<span class="line-modified">!       ndata = closure-&gt;notifiers + offs + i;</span>
<span class="line-modified">!       ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified">!     }</span>
        break;
      }
  }
  
  static void
  g_closure_set_meta_va_marshal (GClosure       *closure,
<span class="line-modified">!                    GVaClosureMarshal va_meta_marshal)</span>
  {
    GRealClosure *real_closure;
  
    g_return_if_fail (closure != NULL);
    g_return_if_fail (va_meta_marshal != NULL);
<span class="line-new-header">--- 259,62 ---</span>
      {
        GClosureNotifyData *ndata;
        guint i, offs;
      case FNOTIFY:
        while (closure-&gt;n_fnotifiers)
<span class="line-modified">!   {</span>
            guint n;
<span class="line-modified">!     DEC_ASSIGN (closure, n_fnotifiers, &amp;n);</span>
  
<span class="line-modified">!     ndata = closure-&gt;notifiers + CLOSURE_N_MFUNCS (closure) + n;</span>
<span class="line-modified">!     closure-&gt;marshal = (GClosureMarshal) ndata-&gt;notify;</span>
<span class="line-modified">!     closure-&gt;data = ndata-&gt;data;</span>
<span class="line-modified">!     ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified">!   }</span>
        closure-&gt;marshal = NULL;
        closure-&gt;data = NULL;
        break;
      case INOTIFY:
        SET (closure, in_inotify, TRUE);
        while (closure-&gt;n_inotifiers)
<span class="line-modified">!   {</span>
            guint n;
            DEC_ASSIGN (closure, n_inotifiers, &amp;n);
  
<span class="line-modified">!     ndata = closure-&gt;notifiers + CLOSURE_N_MFUNCS (closure) + closure-&gt;n_fnotifiers + n;</span>
<span class="line-modified">!     closure-&gt;marshal = (GClosureMarshal) ndata-&gt;notify;</span>
<span class="line-modified">!     closure-&gt;data = ndata-&gt;data;</span>
<span class="line-modified">!     ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified">!   }</span>
        closure-&gt;marshal = NULL;
        closure-&gt;data = NULL;
        SET (closure, in_inotify, FALSE);
        break;
      case PRE_NOTIFY:
        i = closure-&gt;n_guards;
        offs = 0;
        while (i--)
<span class="line-modified">!   {</span>
<span class="line-modified">!     ndata = closure-&gt;notifiers + offs + i;</span>
<span class="line-modified">!     ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified">!   }</span>
        break;
      case POST_NOTIFY:
        i = closure-&gt;n_guards;
        offs = i;
        while (i--)
<span class="line-modified">!   {</span>
<span class="line-modified">!     ndata = closure-&gt;notifiers + offs + i;</span>
<span class="line-modified">!     ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified">!   }</span>
        break;
      }
  }
  
  static void
  g_closure_set_meta_va_marshal (GClosure       *closure,
<span class="line-modified">!              GVaClosureMarshal va_meta_marshal)</span>
  {
    GRealClosure *real_closure;
  
    g_return_if_fail (closure != NULL);
    g_return_if_fail (va_meta_marshal != NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 350,12 ***</span>
   * the right callback and passes it to the marshaller as the
   * @marshal_data argument.
   */
  void
  g_closure_set_meta_marshal (GClosure       *closure,
<span class="line-modified">!                 gpointer        marshal_data,</span>
<span class="line-modified">!                 GClosureMarshal meta_marshal)</span>
  {
    GRealClosure *real_closure;
  
    g_return_if_fail (closure != NULL);
    g_return_if_fail (meta_marshal != NULL);
<span class="line-new-header">--- 350,12 ---</span>
   * the right callback and passes it to the marshaller as the
   * @marshal_data argument.
   */
  void
  g_closure_set_meta_marshal (GClosure       *closure,
<span class="line-modified">!           gpointer        marshal_data,</span>
<span class="line-modified">!           GClosureMarshal meta_marshal)</span>
  {
    GRealClosure *real_closure;
  
    g_return_if_fail (closure != NULL);
    g_return_if_fail (meta_marshal != NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 385,14 ***</span>
   * the extra arguments for the duration of the callback. See
   * g_object_watch_closure() for an example of marshal guards.
   */
  void
  g_closure_add_marshal_guards (GClosure      *closure,
<span class="line-modified">!                   gpointer       pre_marshal_data,</span>
<span class="line-modified">!                   GClosureNotify pre_marshal_notify,</span>
<span class="line-modified">!                   gpointer       post_marshal_data,</span>
<span class="line-modified">!                   GClosureNotify post_marshal_notify)</span>
  {
    guint i;
  
    g_return_if_fail (closure != NULL);
    g_return_if_fail (pre_marshal_notify != NULL);
<span class="line-new-header">--- 385,14 ---</span>
   * the extra arguments for the duration of the callback. See
   * g_object_watch_closure() for an example of marshal guards.
   */
  void
  g_closure_add_marshal_guards (GClosure      *closure,
<span class="line-modified">!             gpointer       pre_marshal_data,</span>
<span class="line-modified">!             GClosureNotify pre_marshal_notify,</span>
<span class="line-modified">!             gpointer       post_marshal_data,</span>
<span class="line-modified">!             GClosureNotify post_marshal_notify)</span>
  {
    guint i;
  
    g_return_if_fail (closure != NULL);
    g_return_if_fail (pre_marshal_notify != NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 402,27 ***</span>
    g_return_if_fail (closure-&gt;n_guards &lt; CLOSURE_MAX_N_GUARDS);
  
    closure-&gt;notifiers = g_renew (GClosureNotifyData, closure-&gt;notifiers, CLOSURE_N_NOTIFIERS (closure) + 2);
    if (closure-&gt;n_inotifiers)
      closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified">!             closure-&gt;n_fnotifiers +</span>
<span class="line-modified">!             closure-&gt;n_inotifiers + 1)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified">!                                       closure-&gt;n_fnotifiers + 0)];</span>
    if (closure-&gt;n_inotifiers &gt; 1)
      closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified">!             closure-&gt;n_fnotifiers +</span>
<span class="line-modified">!             closure-&gt;n_inotifiers)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified">!                                       closure-&gt;n_fnotifiers + 1)];</span>
    if (closure-&gt;n_fnotifiers)
      closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified">!             closure-&gt;n_fnotifiers + 1)] = closure-&gt;notifiers[CLOSURE_N_MFUNCS (closure) + 0];</span>
    if (closure-&gt;n_fnotifiers &gt; 1)
      closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified">!             closure-&gt;n_fnotifiers)] = closure-&gt;notifiers[CLOSURE_N_MFUNCS (closure) + 1];</span>
    if (closure-&gt;n_guards)
      closure-&gt;notifiers[(closure-&gt;n_guards +
<span class="line-modified">!             closure-&gt;n_guards + 1)] = closure-&gt;notifiers[closure-&gt;n_guards];</span>
    i = closure-&gt;n_guards;
    closure-&gt;notifiers[i].data = pre_marshal_data;
    closure-&gt;notifiers[i].notify = pre_marshal_notify;
    closure-&gt;notifiers[i + 1].data = post_marshal_data;
    closure-&gt;notifiers[i + 1].notify = post_marshal_notify;
<span class="line-new-header">--- 402,27 ---</span>
    g_return_if_fail (closure-&gt;n_guards &lt; CLOSURE_MAX_N_GUARDS);
  
    closure-&gt;notifiers = g_renew (GClosureNotifyData, closure-&gt;notifiers, CLOSURE_N_NOTIFIERS (closure) + 2);
    if (closure-&gt;n_inotifiers)
      closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified">!       closure-&gt;n_fnotifiers +</span>
<span class="line-modified">!       closure-&gt;n_inotifiers + 1)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified">!                     closure-&gt;n_fnotifiers + 0)];</span>
    if (closure-&gt;n_inotifiers &gt; 1)
      closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified">!       closure-&gt;n_fnotifiers +</span>
<span class="line-modified">!       closure-&gt;n_inotifiers)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified">!                       closure-&gt;n_fnotifiers + 1)];</span>
    if (closure-&gt;n_fnotifiers)
      closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified">!       closure-&gt;n_fnotifiers + 1)] = closure-&gt;notifiers[CLOSURE_N_MFUNCS (closure) + 0];</span>
    if (closure-&gt;n_fnotifiers &gt; 1)
      closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified">!       closure-&gt;n_fnotifiers)] = closure-&gt;notifiers[CLOSURE_N_MFUNCS (closure) + 1];</span>
    if (closure-&gt;n_guards)
      closure-&gt;notifiers[(closure-&gt;n_guards +
<span class="line-modified">!       closure-&gt;n_guards + 1)] = closure-&gt;notifiers[closure-&gt;n_guards];</span>
    i = closure-&gt;n_guards;
    closure-&gt;notifiers[i].data = pre_marshal_data;
    closure-&gt;notifiers[i].notify = pre_marshal_notify;
    closure-&gt;notifiers[i + 1].data = post_marshal_data;
    closure-&gt;notifiers[i + 1].notify = post_marshal_notify;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 442,25 ***</span>
   * both invalidated and finalized, then the invalidate notifiers will
   * be run before the finalize notifiers.
   */
  void
  g_closure_add_finalize_notifier (GClosure      *closure,
<span class="line-modified">!                  gpointer       notify_data,</span>
<span class="line-modified">!                  GClosureNotify notify_func)</span>
  {
    guint i;
  
    g_return_if_fail (closure != NULL);
    g_return_if_fail (notify_func != NULL);
    g_return_if_fail (closure-&gt;n_fnotifiers &lt; CLOSURE_MAX_N_FNOTIFIERS);
  
    closure-&gt;notifiers = g_renew (GClosureNotifyData, closure-&gt;notifiers, CLOSURE_N_NOTIFIERS (closure) + 1);
    if (closure-&gt;n_inotifiers)
      closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified">!             closure-&gt;n_fnotifiers +</span>
<span class="line-modified">!             closure-&gt;n_inotifiers)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified">!                                       closure-&gt;n_fnotifiers + 0)];</span>
    i = CLOSURE_N_MFUNCS (closure) + closure-&gt;n_fnotifiers;
    closure-&gt;notifiers[i].data = notify_data;
    closure-&gt;notifiers[i].notify = notify_func;
    INC (closure, n_fnotifiers);
  }
<span class="line-new-header">--- 442,25 ---</span>
   * both invalidated and finalized, then the invalidate notifiers will
   * be run before the finalize notifiers.
   */
  void
  g_closure_add_finalize_notifier (GClosure      *closure,
<span class="line-modified">!          gpointer       notify_data,</span>
<span class="line-modified">!          GClosureNotify notify_func)</span>
  {
    guint i;
  
    g_return_if_fail (closure != NULL);
    g_return_if_fail (notify_func != NULL);
    g_return_if_fail (closure-&gt;n_fnotifiers &lt; CLOSURE_MAX_N_FNOTIFIERS);
  
    closure-&gt;notifiers = g_renew (GClosureNotifyData, closure-&gt;notifiers, CLOSURE_N_NOTIFIERS (closure) + 1);
    if (closure-&gt;n_inotifiers)
      closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified">!       closure-&gt;n_fnotifiers +</span>
<span class="line-modified">!       closure-&gt;n_inotifiers)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified">!                       closure-&gt;n_fnotifiers + 0)];</span>
    i = CLOSURE_N_MFUNCS (closure) + closure-&gt;n_fnotifiers;
    closure-&gt;notifiers[i].data = notify_data;
    closure-&gt;notifiers[i].notify = notify_func;
    INC (closure, n_fnotifiers);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 476,12 ***</span>
   * notifiers are invoked before finalization notifiers, in an
   * unspecified order.
   */
  void
  g_closure_add_invalidate_notifier (GClosure      *closure,
<span class="line-modified">!                    gpointer       notify_data,</span>
<span class="line-modified">!                    GClosureNotify notify_func)</span>
  {
    guint i;
  
    g_return_if_fail (closure != NULL);
    g_return_if_fail (notify_func != NULL);
<span class="line-new-header">--- 476,12 ---</span>
   * notifiers are invoked before finalization notifiers, in an
   * unspecified order.
   */
  void
  g_closure_add_invalidate_notifier (GClosure      *closure,
<span class="line-modified">!            gpointer       notify_data,</span>
<span class="line-modified">!            GClosureNotify notify_func)</span>
  {
    guint i;
  
    g_return_if_fail (closure != NULL);
    g_return_if_fail (notify_func != NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 495,48 ***</span>
    INC (closure, n_inotifiers);
  }
  
  static inline gboolean
  closure_try_remove_inotify (GClosure       *closure,
<span class="line-modified">!                 gpointer       notify_data,</span>
<span class="line-modified">!                 GClosureNotify notify_func)</span>
  {
    GClosureNotifyData *ndata, *nlast;
  
    nlast = closure-&gt;notifiers + CLOSURE_N_NOTIFIERS (closure) - 1;
    for (ndata = nlast + 1 - closure-&gt;n_inotifiers; ndata &lt;= nlast; ndata++)
      if (ndata-&gt;notify == notify_func &amp;&amp; ndata-&gt;data == notify_data)
        {
<span class="line-modified">!     DEC (closure, n_inotifiers);</span>
<span class="line-modified">!     if (ndata &lt; nlast)</span>
<span class="line-modified">!       *ndata = *nlast;</span>
  
<span class="line-modified">!     return TRUE;</span>
        }
    return FALSE;
  }
  
  static inline gboolean
  closure_try_remove_fnotify (GClosure       *closure,
<span class="line-modified">!                 gpointer       notify_data,</span>
<span class="line-modified">!                 GClosureNotify notify_func)</span>
  {
    GClosureNotifyData *ndata, *nlast;
  
    nlast = closure-&gt;notifiers + CLOSURE_N_NOTIFIERS (closure) - closure-&gt;n_inotifiers - 1;
    for (ndata = nlast + 1 - closure-&gt;n_fnotifiers; ndata &lt;= nlast; ndata++)
      if (ndata-&gt;notify == notify_func &amp;&amp; ndata-&gt;data == notify_data)
        {
<span class="line-modified">!     DEC (closure, n_fnotifiers);</span>
<span class="line-modified">!     if (ndata &lt; nlast)</span>
<span class="line-modified">!       *ndata = *nlast;</span>
<span class="line-modified">!     if (closure-&gt;n_inotifiers)</span>
<span class="line-modified">!       closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified">!                   closure-&gt;n_fnotifiers)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified">!                                         closure-&gt;n_fnotifiers +</span>
<span class="line-modified">!                                         closure-&gt;n_inotifiers)];</span>
<span class="line-modified">!     return TRUE;</span>
        }
    return FALSE;
  }
  
  /**
<span class="line-new-header">--- 495,48 ---</span>
    INC (closure, n_inotifiers);
  }
  
  static inline gboolean
  closure_try_remove_inotify (GClosure       *closure,
<span class="line-modified">!           gpointer       notify_data,</span>
<span class="line-modified">!           GClosureNotify notify_func)</span>
  {
    GClosureNotifyData *ndata, *nlast;
  
    nlast = closure-&gt;notifiers + CLOSURE_N_NOTIFIERS (closure) - 1;
    for (ndata = nlast + 1 - closure-&gt;n_inotifiers; ndata &lt;= nlast; ndata++)
      if (ndata-&gt;notify == notify_func &amp;&amp; ndata-&gt;data == notify_data)
        {
<span class="line-modified">!   DEC (closure, n_inotifiers);</span>
<span class="line-modified">!   if (ndata &lt; nlast)</span>
<span class="line-modified">!     *ndata = *nlast;</span>
  
<span class="line-modified">!   return TRUE;</span>
        }
    return FALSE;
  }
  
  static inline gboolean
  closure_try_remove_fnotify (GClosure       *closure,
<span class="line-modified">!           gpointer       notify_data,</span>
<span class="line-modified">!           GClosureNotify notify_func)</span>
  {
    GClosureNotifyData *ndata, *nlast;
  
    nlast = closure-&gt;notifiers + CLOSURE_N_NOTIFIERS (closure) - closure-&gt;n_inotifiers - 1;
    for (ndata = nlast + 1 - closure-&gt;n_fnotifiers; ndata &lt;= nlast; ndata++)
      if (ndata-&gt;notify == notify_func &amp;&amp; ndata-&gt;data == notify_data)
        {
<span class="line-modified">!   DEC (closure, n_fnotifiers);</span>
<span class="line-modified">!   if (ndata &lt; nlast)</span>
<span class="line-modified">!     *ndata = *nlast;</span>
<span class="line-modified">!   if (closure-&gt;n_inotifiers)</span>
<span class="line-modified">!     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified">!             closure-&gt;n_fnotifiers)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified">!                       closure-&gt;n_fnotifiers +</span>
<span class="line-modified">!                       closure-&gt;n_inotifiers)];</span>
<span class="line-modified">!   return TRUE;</span>
        }
    return FALSE;
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 562,11 ***</span>
    return closure;
  }
  
  /**
   * g_closure_invalidate:
<span class="line-modified">!  * @closure: GClosure to invalidate</span>
   *
   * Sets a flag on the closure to indicate that its calling
   * environment has become invalid, and thus causes any future
   * invocations of g_closure_invoke() on this @closure to be
   * ignored. Also, invalidation notifiers installed on the closure will
<span class="line-new-header">--- 562,11 ---</span>
    return closure;
  }
  
  /**
   * g_closure_invalidate:
<span class="line-modified">!  * @closure: #GClosure to invalidate</span>
   *
   * Sets a flag on the closure to indicate that its calling
   * environment has become invalid, and thus causes any future
   * invocations of g_closure_invoke() on this @closure to be
   * ignored. Also, invalidation notifiers installed on the closure will
</pre>
<hr />
<pre>
<span class="line-old-header">*** 741,23 ***</span>
   *
   * Notice that notifiers are automatically removed after they are run.
   */
  void
  g_closure_remove_invalidate_notifier (GClosure      *closure,
<span class="line-modified">!                       gpointer       notify_data,</span>
<span class="line-modified">!                       GClosureNotify notify_func)</span>
  {
    g_return_if_fail (closure != NULL);
    g_return_if_fail (notify_func != NULL);
  
    if (closure-&gt;is_invalid &amp;&amp; closure-&gt;in_inotify &amp;&amp; /* account removal of notify_func() while it&#39;s called */
        ((gpointer) closure-&gt;marshal) == ((gpointer) notify_func) &amp;&amp;
        closure-&gt;data == notify_data)
      closure-&gt;marshal = NULL;
    else if (!closure_try_remove_inotify (closure, notify_data, notify_func))
      g_warning (G_STRLOC &quot;: unable to remove uninstalled invalidation notifier: %p (%p)&quot;,
<span class="line-modified">!            notify_func, notify_data);</span>
  }
  
  /**
   * g_closure_remove_finalize_notifier: (skip)
   * @closure: a #GClosure
<span class="line-new-header">--- 741,23 ---</span>
   *
   * Notice that notifiers are automatically removed after they are run.
   */
  void
  g_closure_remove_invalidate_notifier (GClosure      *closure,
<span class="line-modified">!               gpointer       notify_data,</span>
<span class="line-modified">!               GClosureNotify notify_func)</span>
  {
    g_return_if_fail (closure != NULL);
    g_return_if_fail (notify_func != NULL);
  
    if (closure-&gt;is_invalid &amp;&amp; closure-&gt;in_inotify &amp;&amp; /* account removal of notify_func() while it&#39;s called */
        ((gpointer) closure-&gt;marshal) == ((gpointer) notify_func) &amp;&amp;
        closure-&gt;data == notify_data)
      closure-&gt;marshal = NULL;
    else if (!closure_try_remove_inotify (closure, notify_data, notify_func))
      g_warning (G_STRLOC &quot;: unable to remove uninstalled invalidation notifier: %p (%p)&quot;,
<span class="line-modified">!          notify_func, notify_data);</span>
  }
  
  /**
   * g_closure_remove_finalize_notifier: (skip)
   * @closure: a #GClosure
</pre>
<hr />
<pre>
<span class="line-old-header">*** 769,12 ***</span>
   *
   * Notice that notifiers are automatically removed after they are run.
   */
  void
  g_closure_remove_finalize_notifier (GClosure      *closure,
<span class="line-modified">!                     gpointer       notify_data,</span>
<span class="line-modified">!                     GClosureNotify notify_func)</span>
  {
    g_return_if_fail (closure != NULL);
    g_return_if_fail (notify_func != NULL);
  
    if (closure-&gt;is_invalid &amp;&amp; !closure-&gt;in_inotify &amp;&amp; /* account removal of notify_func() while it&#39;s called */
<span class="line-new-header">--- 769,12 ---</span>
   *
   * Notice that notifiers are automatically removed after they are run.
   */
  void
  g_closure_remove_finalize_notifier (GClosure      *closure,
<span class="line-modified">!             gpointer       notify_data,</span>
<span class="line-modified">!             GClosureNotify notify_func)</span>
  {
    g_return_if_fail (closure != NULL);
    g_return_if_fail (notify_func != NULL);
  
    if (closure-&gt;is_invalid &amp;&amp; !closure-&gt;in_inotify &amp;&amp; /* account removal of notify_func() while it&#39;s called */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 800,14 ***</span>
   *
   * Invokes the closure, i.e. executes the callback represented by the @closure.
   */
  void
  g_closure_invoke (GClosure       *closure,
<span class="line-modified">!           GValue /*out*/ *return_value,</span>
<span class="line-modified">!           guint           n_param_values,</span>
<span class="line-modified">!           const GValue   *param_values,</span>
<span class="line-modified">!           gpointer        invocation_hint)</span>
  {
    GRealClosure *real_closure;
  
    g_return_if_fail (closure != NULL);
  
<span class="line-new-header">--- 800,14 ---</span>
   *
   * Invokes the closure, i.e. executes the callback represented by the @closure.
   */
  void
  g_closure_invoke (GClosure       *closure,
<span class="line-modified">!       GValue /*out*/ *return_value,</span>
<span class="line-modified">!       guint           n_param_values,</span>
<span class="line-modified">!       const GValue   *param_values,</span>
<span class="line-modified">!       gpointer        invocation_hint)</span>
  {
    GRealClosure *real_closure;
  
    g_return_if_fail (closure != NULL);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 822,28 ***</span>
  
        g_return_if_fail (closure-&gt;marshal || real_closure-&gt;meta_marshal);
  
        SET (closure, in_marshal, TRUE);
        if (real_closure-&gt;meta_marshal)
<span class="line-modified">!     {</span>
<span class="line-modified">!       marshal_data = real_closure-&gt;meta_marshal_data;</span>
<span class="line-modified">!       marshal = real_closure-&gt;meta_marshal;</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       marshal_data = NULL;</span>
<span class="line-modified">!       marshal = closure-&gt;marshal;</span>
<span class="line-modified">!     }</span>
        if (!in_marshal)
<span class="line-modified">!     closure_invoke_notifiers (closure, PRE_NOTIFY);</span>
        marshal (closure,
<span class="line-modified">!            return_value,</span>
<span class="line-modified">!            n_param_values, param_values,</span>
<span class="line-modified">!            invocation_hint,</span>
<span class="line-modified">!            marshal_data);</span>
        if (!in_marshal)
<span class="line-modified">!     closure_invoke_notifiers (closure, POST_NOTIFY);</span>
        SET (closure, in_marshal, in_marshal);
      }
    g_closure_unref (closure);
  }
  
<span class="line-new-header">--- 822,28 ---</span>
  
        g_return_if_fail (closure-&gt;marshal || real_closure-&gt;meta_marshal);
  
        SET (closure, in_marshal, TRUE);
        if (real_closure-&gt;meta_marshal)
<span class="line-modified">!   {</span>
<span class="line-modified">!     marshal_data = real_closure-&gt;meta_marshal_data;</span>
<span class="line-modified">!     marshal = real_closure-&gt;meta_marshal;</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     marshal_data = NULL;</span>
<span class="line-modified">!     marshal = closure-&gt;marshal;</span>
<span class="line-modified">!   }</span>
        if (!in_marshal)
<span class="line-modified">!   closure_invoke_notifiers (closure, PRE_NOTIFY);</span>
        marshal (closure,
<span class="line-modified">!          return_value,</span>
<span class="line-modified">!          n_param_values, param_values,</span>
<span class="line-modified">!          invocation_hint,</span>
<span class="line-modified">!          marshal_data);</span>
        if (!in_marshal)
<span class="line-modified">!   closure_invoke_notifiers (closure, POST_NOTIFY);</span>
        SET (closure, in_marshal, in_marshal);
      }
    g_closure_unref (closure);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 862,15 ***</span>
       real_closure-&gt;va_meta_marshal != NULL);
  }
  
  void
  _g_closure_invoke_va (GClosure       *closure,
<span class="line-modified">!               GValue /*out*/ *return_value,</span>
<span class="line-modified">!               gpointer        instance,</span>
<span class="line-modified">!               va_list         args,</span>
<span class="line-modified">!               int             n_params,</span>
<span class="line-modified">!               GType          *param_types)</span>
  {
    GRealClosure *real_closure;
  
    g_return_if_fail (closure != NULL);
  
<span class="line-new-header">--- 862,15 ---</span>
       real_closure-&gt;va_meta_marshal != NULL);
  }
  
  void
  _g_closure_invoke_va (GClosure       *closure,
<span class="line-modified">!           GValue /*out*/ *return_value,</span>
<span class="line-modified">!           gpointer        instance,</span>
<span class="line-modified">!           va_list         args,</span>
<span class="line-modified">!           int             n_params,</span>
<span class="line-modified">!           GType          *param_types)</span>
  {
    GRealClosure *real_closure;
  
    g_return_if_fail (closure != NULL);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 885,28 ***</span>
  
        g_return_if_fail (closure-&gt;marshal || real_closure-&gt;meta_marshal);
  
        SET (closure, in_marshal, TRUE);
        if (real_closure-&gt;va_meta_marshal)
<span class="line-modified">!     {</span>
<span class="line-modified">!       marshal_data = real_closure-&gt;meta_marshal_data;</span>
<span class="line-modified">!       marshal = real_closure-&gt;va_meta_marshal;</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       marshal_data = NULL;</span>
<span class="line-modified">!       marshal = real_closure-&gt;va_marshal;</span>
<span class="line-modified">!     }</span>
        if (!in_marshal)
<span class="line-modified">!     closure_invoke_notifiers (closure, PRE_NOTIFY);</span>
        marshal (closure,
<span class="line-modified">!            return_value,</span>
<span class="line-modified">!            instance, args,</span>
<span class="line-modified">!            marshal_data,</span>
<span class="line-modified">!            n_params, param_types);</span>
        if (!in_marshal)
<span class="line-modified">!     closure_invoke_notifiers (closure, POST_NOTIFY);</span>
        SET (closure, in_marshal, in_marshal);
      }
    g_closure_unref (closure);
  }
  
<span class="line-new-header">--- 885,28 ---</span>
  
        g_return_if_fail (closure-&gt;marshal || real_closure-&gt;meta_marshal);
  
        SET (closure, in_marshal, TRUE);
        if (real_closure-&gt;va_meta_marshal)
<span class="line-modified">!   {</span>
<span class="line-modified">!     marshal_data = real_closure-&gt;meta_marshal_data;</span>
<span class="line-modified">!     marshal = real_closure-&gt;va_meta_marshal;</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     marshal_data = NULL;</span>
<span class="line-modified">!     marshal = real_closure-&gt;va_marshal;</span>
<span class="line-modified">!   }</span>
        if (!in_marshal)
<span class="line-modified">!   closure_invoke_notifiers (closure, PRE_NOTIFY);</span>
        marshal (closure,
<span class="line-modified">!          return_value,</span>
<span class="line-modified">!          instance, args,</span>
<span class="line-modified">!          marshal_data,</span>
<span class="line-modified">!          n_params, param_types);</span>
        if (!in_marshal)
<span class="line-modified">!   closure_invoke_notifiers (closure, POST_NOTIFY);</span>
        SET (closure, in_marshal, in_marshal);
      }
    g_closure_unref (closure);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 923,36 ***</span>
   * functions), what it provides is a callback function to use instead of
   * @closure-&gt;callback.
   */
  void
  g_closure_set_marshal (GClosure       *closure,
<span class="line-modified">!                GClosureMarshal marshal)</span>
  {
    g_return_if_fail (closure != NULL);
    g_return_if_fail (marshal != NULL);
  
    if (closure-&gt;marshal &amp;&amp; closure-&gt;marshal != marshal)
      g_warning (&quot;attempt to override closure-&gt;marshal (%p) with new marshal (%p)&quot;,
<span class="line-modified">!            closure-&gt;marshal, marshal);</span>
    else
      closure-&gt;marshal = marshal;
  }
  
  void
  _g_closure_set_va_marshal (GClosure       *closure,
<span class="line-modified">!                GVaClosureMarshal marshal)</span>
  {
    GRealClosure *real_closure;
  
    g_return_if_fail (closure != NULL);
    g_return_if_fail (marshal != NULL);
  
    real_closure = G_REAL_CLOSURE (closure);
  
    if (real_closure-&gt;va_marshal &amp;&amp; real_closure-&gt;va_marshal != marshal)
      g_warning (&quot;attempt to override closure-&gt;va_marshal (%p) with new marshal (%p)&quot;,
<span class="line-modified">!            real_closure-&gt;va_marshal, marshal);</span>
    else
      real_closure-&gt;va_marshal = marshal;
  }
  
  /**
<span class="line-new-header">--- 923,36 ---</span>
   * functions), what it provides is a callback function to use instead of
   * @closure-&gt;callback.
   */
  void
  g_closure_set_marshal (GClosure       *closure,
<span class="line-modified">!            GClosureMarshal marshal)</span>
  {
    g_return_if_fail (closure != NULL);
    g_return_if_fail (marshal != NULL);
  
    if (closure-&gt;marshal &amp;&amp; closure-&gt;marshal != marshal)
      g_warning (&quot;attempt to override closure-&gt;marshal (%p) with new marshal (%p)&quot;,
<span class="line-modified">!          closure-&gt;marshal, marshal);</span>
    else
      closure-&gt;marshal = marshal;
  }
  
  void
  _g_closure_set_va_marshal (GClosure       *closure,
<span class="line-modified">!          GVaClosureMarshal marshal)</span>
  {
    GRealClosure *real_closure;
  
    g_return_if_fail (closure != NULL);
    g_return_if_fail (marshal != NULL);
  
    real_closure = G_REAL_CLOSURE (closure);
  
    if (real_closure-&gt;va_marshal &amp;&amp; real_closure-&gt;va_marshal != marshal)
      g_warning (&quot;attempt to override closure-&gt;va_marshal (%p) with new marshal (%p)&quot;,
<span class="line-modified">!          real_closure-&gt;va_marshal, marshal);</span>
    else
      real_closure-&gt;va_marshal = marshal;
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 962,16 ***</span>
   * @destroy_data: destroy notify to be called when @user_data is no longer used
   *
   * Creates a new closure which invokes @callback_func with @user_data as
   * the last parameter.
   *
   * Returns: (transfer none): a floating reference to a new #GCClosure
   */
  GClosure*
  g_cclosure_new (GCallback      callback_func,
<span class="line-modified">!         gpointer       user_data,</span>
<span class="line-modified">!         GClosureNotify destroy_data)</span>
  {
    GClosure *closure;
  
    g_return_val_if_fail (callback_func != NULL, NULL);
  
<span class="line-new-header">--- 962,18 ---</span>
   * @destroy_data: destroy notify to be called when @user_data is no longer used
   *
   * Creates a new closure which invokes @callback_func with @user_data as
   * the last parameter.
   *
<span class="line-added">+  * @destroy_data will be called as a finalize notifier on the #GClosure.</span>
<span class="line-added">+  *</span>
   * Returns: (transfer none): a floating reference to a new #GCClosure
   */
  GClosure*
  g_cclosure_new (GCallback      callback_func,
<span class="line-modified">!     gpointer       user_data,</span>
<span class="line-modified">!     GClosureNotify destroy_data)</span>
  {
    GClosure *closure;
  
    g_return_val_if_fail (callback_func != NULL, NULL);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 994,16 ***</span>
   * @destroy_data: destroy notify to be called when @user_data is no longer used
   *
   * Creates a new closure which invokes @callback_func with @user_data as
   * the first parameter.
   *
   * Returns: (transfer none): a floating reference to a new #GCClosure
   */
  GClosure*
  g_cclosure_new_swap (GCallback      callback_func,
<span class="line-modified">!              gpointer       user_data,</span>
<span class="line-modified">!              GClosureNotify destroy_data)</span>
  {
    GClosure *closure;
  
    g_return_val_if_fail (callback_func != NULL, NULL);
  
<span class="line-new-header">--- 996,18 ---</span>
   * @destroy_data: destroy notify to be called when @user_data is no longer used
   *
   * Creates a new closure which invokes @callback_func with @user_data as
   * the first parameter.
   *
<span class="line-added">+  * @destroy_data will be called as a finalize notifier on the #GClosure.</span>
<span class="line-added">+  *</span>
   * Returns: (transfer none): a floating reference to a new #GCClosure
   */
  GClosure*
  g_cclosure_new_swap (GCallback      callback_func,
<span class="line-modified">!          gpointer       user_data,</span>
<span class="line-modified">!          GClosureNotify destroy_data)</span>
  {
    GClosure *closure;
  
    g_return_val_if_fail (callback_func != NULL, NULL);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1020,39 ***</span>
    return closure;
  }
  
  static void
  g_type_class_meta_marshal (GClosure       *closure,
<span class="line-modified">!                GValue /*out*/ *return_value,</span>
<span class="line-modified">!                guint           n_param_values,</span>
<span class="line-modified">!                const GValue   *param_values,</span>
<span class="line-modified">!                gpointer        invocation_hint,</span>
<span class="line-modified">!                gpointer        marshal_data)</span>
  {
    GTypeClass *class;
    gpointer callback;
    /* GType itype = (GType) closure-&gt;data; */
    guint offset = GPOINTER_TO_UINT (marshal_data);
  
    class = G_TYPE_INSTANCE_GET_CLASS (g_value_peek_pointer (param_values + 0), itype, GTypeClass);
    callback = G_STRUCT_MEMBER (gpointer, class, offset);
    if (callback)
      closure-&gt;marshal (closure,
<span class="line-modified">!               return_value,</span>
<span class="line-modified">!               n_param_values, param_values,</span>
<span class="line-modified">!               invocation_hint,</span>
<span class="line-modified">!               callback);</span>
  }
  
  static void
  g_type_class_meta_marshalv (GClosure *closure,
<span class="line-modified">!                 GValue   *return_value,</span>
<span class="line-modified">!                 gpointer  instance,</span>
<span class="line-modified">!                 va_list   args,</span>
<span class="line-modified">!                 gpointer  marshal_data,</span>
<span class="line-modified">!                 int       n_params,</span>
<span class="line-modified">!                 GType    *param_types)</span>
  {
    GRealClosure *real_closure;
    GTypeClass *class;
    gpointer callback;
    /* GType itype = (GType) closure-&gt;data; */
<span class="line-new-header">--- 1024,39 ---</span>
    return closure;
  }
  
  static void
  g_type_class_meta_marshal (GClosure       *closure,
<span class="line-modified">!          GValue /*out*/ *return_value,</span>
<span class="line-modified">!          guint           n_param_values,</span>
<span class="line-modified">!          const GValue   *param_values,</span>
<span class="line-modified">!          gpointer        invocation_hint,</span>
<span class="line-modified">!          gpointer        marshal_data)</span>
  {
    GTypeClass *class;
    gpointer callback;
    /* GType itype = (GType) closure-&gt;data; */
    guint offset = GPOINTER_TO_UINT (marshal_data);
  
    class = G_TYPE_INSTANCE_GET_CLASS (g_value_peek_pointer (param_values + 0), itype, GTypeClass);
    callback = G_STRUCT_MEMBER (gpointer, class, offset);
    if (callback)
      closure-&gt;marshal (closure,
<span class="line-modified">!           return_value,</span>
<span class="line-modified">!           n_param_values, param_values,</span>
<span class="line-modified">!           invocation_hint,</span>
<span class="line-modified">!           callback);</span>
  }
  
  static void
  g_type_class_meta_marshalv (GClosure *closure,
<span class="line-modified">!           GValue   *return_value,</span>
<span class="line-modified">!           gpointer  instance,</span>
<span class="line-modified">!           va_list   args,</span>
<span class="line-modified">!           gpointer  marshal_data,</span>
<span class="line-modified">!           int       n_params,</span>
<span class="line-modified">!           GType    *param_types)</span>
  {
    GRealClosure *real_closure;
    GTypeClass *class;
    gpointer callback;
    /* GType itype = (GType) closure-&gt;data; */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1062,43 ***</span>
  
    class = G_TYPE_INSTANCE_GET_CLASS (instance, itype, GTypeClass);
    callback = G_STRUCT_MEMBER (gpointer, class, offset);
    if (callback)
      real_closure-&gt;va_marshal (closure,
<span class="line-modified">!                   return_value,</span>
<span class="line-modified">!                   instance, args,</span>
<span class="line-modified">!                   callback,</span>
<span class="line-modified">!                   n_params,</span>
<span class="line-modified">!                   param_types);</span>
  }
  
  static void
  g_type_iface_meta_marshal (GClosure       *closure,
<span class="line-modified">!                GValue /*out*/ *return_value,</span>
<span class="line-modified">!                guint           n_param_values,</span>
<span class="line-modified">!                const GValue   *param_values,</span>
<span class="line-modified">!                gpointer        invocation_hint,</span>
<span class="line-modified">!                gpointer        marshal_data)</span>
  {
    GTypeClass *class;
    gpointer callback;
    GType itype = (GType) closure-&gt;data;
    guint offset = GPOINTER_TO_UINT (marshal_data);
  
    class = G_TYPE_INSTANCE_GET_INTERFACE (g_value_peek_pointer (param_values + 0), itype, GTypeClass);
    callback = G_STRUCT_MEMBER (gpointer, class, offset);
    if (callback)
      closure-&gt;marshal (closure,
<span class="line-modified">!               return_value,</span>
<span class="line-modified">!               n_param_values, param_values,</span>
<span class="line-modified">!               invocation_hint,</span>
<span class="line-modified">!               callback);</span>
  }
  
  gboolean
  _g_closure_is_void (GClosure *closure,
<span class="line-modified">!             gpointer instance)</span>
  {
    GRealClosure *real_closure;
    GTypeClass *class;
    gpointer callback;
    GType itype;
<span class="line-new-header">--- 1066,43 ---</span>
  
    class = G_TYPE_INSTANCE_GET_CLASS (instance, itype, GTypeClass);
    callback = G_STRUCT_MEMBER (gpointer, class, offset);
    if (callback)
      real_closure-&gt;va_marshal (closure,
<span class="line-modified">!             return_value,</span>
<span class="line-modified">!             instance, args,</span>
<span class="line-modified">!             callback,</span>
<span class="line-modified">!             n_params,</span>
<span class="line-modified">!             param_types);</span>
  }
  
  static void
  g_type_iface_meta_marshal (GClosure       *closure,
<span class="line-modified">!          GValue /*out*/ *return_value,</span>
<span class="line-modified">!          guint           n_param_values,</span>
<span class="line-modified">!          const GValue   *param_values,</span>
<span class="line-modified">!          gpointer        invocation_hint,</span>
<span class="line-modified">!          gpointer        marshal_data)</span>
  {
    GTypeClass *class;
    gpointer callback;
    GType itype = (GType) closure-&gt;data;
    guint offset = GPOINTER_TO_UINT (marshal_data);
  
    class = G_TYPE_INSTANCE_GET_INTERFACE (g_value_peek_pointer (param_values + 0), itype, GTypeClass);
    callback = G_STRUCT_MEMBER (gpointer, class, offset);
    if (callback)
      closure-&gt;marshal (closure,
<span class="line-modified">!           return_value,</span>
<span class="line-modified">!           n_param_values, param_values,</span>
<span class="line-modified">!           invocation_hint,</span>
<span class="line-modified">!           callback);</span>
  }
  
  gboolean
  _g_closure_is_void (GClosure *closure,
<span class="line-modified">!         gpointer instance)</span>
  {
    GRealClosure *real_closure;
    GTypeClass *class;
    gpointer callback;
    GType itype;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1130,16 ***</span>
    return FALSE;
  }
  
  static void
  g_type_iface_meta_marshalv (GClosure *closure,
<span class="line-modified">!                 GValue   *return_value,</span>
<span class="line-modified">!                 gpointer  instance,</span>
<span class="line-modified">!                 va_list   args,</span>
<span class="line-modified">!                 gpointer  marshal_data,</span>
<span class="line-modified">!                 int       n_params,</span>
<span class="line-modified">!                 GType    *param_types)</span>
  {
    GRealClosure *real_closure;
    GTypeClass *class;
    gpointer callback;
    GType itype = (GType) closure-&gt;data;
<span class="line-new-header">--- 1134,16 ---</span>
    return FALSE;
  }
  
  static void
  g_type_iface_meta_marshalv (GClosure *closure,
<span class="line-modified">!           GValue   *return_value,</span>
<span class="line-modified">!           gpointer  instance,</span>
<span class="line-modified">!           va_list   args,</span>
<span class="line-modified">!           gpointer  marshal_data,</span>
<span class="line-modified">!           int       n_params,</span>
<span class="line-modified">!           GType    *param_types)</span>
  {
    GRealClosure *real_closure;
    GTypeClass *class;
    gpointer callback;
    GType itype = (GType) closure-&gt;data;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1149,15 ***</span>
  
    class = G_TYPE_INSTANCE_GET_INTERFACE (instance, itype, GTypeClass);
    callback = G_STRUCT_MEMBER (gpointer, class, offset);
    if (callback)
      real_closure-&gt;va_marshal (closure,
<span class="line-modified">!                   return_value,</span>
<span class="line-modified">!                   instance, args,</span>
<span class="line-modified">!                   callback,</span>
<span class="line-modified">!                   n_params,</span>
<span class="line-modified">!                   param_types);</span>
  }
  
  /**
   * g_signal_type_cclosure_new:
   * @itype: the #GType identifier of an interface or classed type
<span class="line-new-header">--- 1153,15 ---</span>
  
    class = G_TYPE_INSTANCE_GET_INTERFACE (instance, itype, GTypeClass);
    callback = G_STRUCT_MEMBER (gpointer, class, offset);
    if (callback)
      real_closure-&gt;va_marshal (closure,
<span class="line-modified">!             return_value,</span>
<span class="line-modified">!             instance, args,</span>
<span class="line-modified">!             callback,</span>
<span class="line-modified">!             n_params,</span>
<span class="line-modified">!             param_types);</span>
  }
  
  /**
   * g_signal_type_cclosure_new:
   * @itype: the #GType identifier of an interface or classed type
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1170,11 ***</span>
   *
   * Returns: (transfer none): a floating reference to a new #GCClosure
   */
  GClosure*
  g_signal_type_cclosure_new (GType    itype,
<span class="line-modified">!                 guint    struct_offset)</span>
  {
    GClosure *closure;
  
    g_return_val_if_fail (G_TYPE_IS_CLASSED (itype) || G_TYPE_IS_INTERFACE (itype), NULL);
    g_return_val_if_fail (struct_offset &gt;= sizeof (GTypeClass), NULL);
<span class="line-new-header">--- 1174,11 ---</span>
   *
   * Returns: (transfer none): a floating reference to a new #GCClosure
   */
  GClosure*
  g_signal_type_cclosure_new (GType    itype,
<span class="line-modified">!           guint    struct_offset)</span>
  {
    GClosure *closure;
  
    g_return_val_if_fail (G_TYPE_IS_CLASSED (itype) || G_TYPE_IS_INTERFACE (itype), NULL);
    g_return_val_if_fail (struct_offset &gt;= sizeof (GTypeClass), NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1368,12 ***</span>
    guint64 _guint64;
  } va_arg_storage;
  
  static ffi_type *
  va_to_ffi_type (GType gtype,
<span class="line-modified">!         va_list *va,</span>
<span class="line-modified">!         va_arg_storage *storage)</span>
  {
    ffi_type *rettype = NULL;
    GType type = g_type_fundamental (gtype);
    g_assert (type != G_TYPE_INVALID);
  
<span class="line-new-header">--- 1372,12 ---</span>
    guint64 _guint64;
  } va_arg_storage;
  
  static ffi_type *
  va_to_ffi_type (GType gtype,
<span class="line-modified">!     va_list *va,</span>
<span class="line-modified">!     va_arg_storage *storage)</span>
  {
    ffi_type *rettype = NULL;
    GType type = g_type_fundamental (gtype);
    g_assert (type != G_TYPE_INVALID);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1556,16 ***</span>
   *
   * Since: 2.30
   */
  void
  g_cclosure_marshal_generic_va (GClosure *closure,
<span class="line-modified">!                    GValue   *return_value,</span>
<span class="line-modified">!                    gpointer  instance,</span>
<span class="line-modified">!                    va_list   args_list,</span>
<span class="line-modified">!                    gpointer  marshal_data,</span>
<span class="line-modified">!                    int       n_params,</span>
<span class="line-modified">!                    GType    *param_types)</span>
  {
    ffi_type *rtype;
    void *rvalue;
    int n_args;
    ffi_type **atypes;
<span class="line-new-header">--- 1560,16 ---</span>
   *
   * Since: 2.30
   */
  void
  g_cclosure_marshal_generic_va (GClosure *closure,
<span class="line-modified">!              GValue   *return_value,</span>
<span class="line-modified">!              gpointer  instance,</span>
<span class="line-modified">!              va_list   args_list,</span>
<span class="line-modified">!              gpointer  marshal_data,</span>
<span class="line-modified">!              int       n_params,</span>
<span class="line-modified">!              GType    *param_types)</span>
  {
    ffi_type *rtype;
    void *rvalue;
    int n_args;
    ffi_type **atypes;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1617,27 ***</span>
      {
        GType type = param_types[i]  &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
        GType fundamental = G_TYPE_FUNDAMENTAL (type);
  
        atypes[i+1] = va_to_ffi_type (type,
<span class="line-modified">!                     &amp;args_copy,</span>
<span class="line-modified">!                     &amp;storage[i]);</span>
        args[i+1] = &amp;storage[i];
  
        if ((param_types[i]  &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0)
<span class="line-modified">!     {</span>
<span class="line-modified">!       if (fundamental == G_TYPE_STRING &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">!         storage[i]._gpointer = g_strdup (storage[i]._gpointer);</span>
<span class="line-modified">!       else if (fundamental == G_TYPE_PARAM &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">!         storage[i]._gpointer = g_param_spec_ref (storage[i]._gpointer);</span>
<span class="line-modified">!       else if (fundamental == G_TYPE_BOXED &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">!         storage[i]._gpointer = g_boxed_copy (type, storage[i]._gpointer);</span>
<span class="line-modified">!       else if (fundamental == G_TYPE_VARIANT &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">!         storage[i]._gpointer = g_variant_ref_sink (storage[i]._gpointer);</span>
<span class="line-modified">!     }</span>
        if (fundamental == G_TYPE_OBJECT &amp;&amp; storage[i]._gpointer != NULL)
<span class="line-modified">!     storage[i]._gpointer = g_object_ref (storage[i]._gpointer);</span>
      }
  
    va_end (args_copy);
  
    if (ffi_prep_cif (&amp;cif, FFI_DEFAULT_ABI, n_args, rtype, atypes) != FFI_OK)
<span class="line-new-header">--- 1621,27 ---</span>
      {
        GType type = param_types[i]  &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
        GType fundamental = G_TYPE_FUNDAMENTAL (type);
  
        atypes[i+1] = va_to_ffi_type (type,
<span class="line-modified">!             &amp;args_copy,</span>
<span class="line-modified">!             &amp;storage[i]);</span>
        args[i+1] = &amp;storage[i];
  
        if ((param_types[i]  &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0)
<span class="line-modified">!   {</span>
<span class="line-modified">!     if (fundamental == G_TYPE_STRING &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">!       storage[i]._gpointer = g_strdup (storage[i]._gpointer);</span>
<span class="line-modified">!     else if (fundamental == G_TYPE_PARAM &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">!       storage[i]._gpointer = g_param_spec_ref (storage[i]._gpointer);</span>
<span class="line-modified">!     else if (fundamental == G_TYPE_BOXED &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">!       storage[i]._gpointer = g_boxed_copy (type, storage[i]._gpointer);</span>
<span class="line-modified">!     else if (fundamental == G_TYPE_VARIANT &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">!       storage[i]._gpointer = g_variant_ref_sink (storage[i]._gpointer);</span>
<span class="line-modified">!   }</span>
        if (fundamental == G_TYPE_OBJECT &amp;&amp; storage[i]._gpointer != NULL)
<span class="line-modified">!   storage[i]._gpointer = g_object_ref (storage[i]._gpointer);</span>
      }
  
    va_end (args_copy);
  
    if (ffi_prep_cif (&amp;cif, FFI_DEFAULT_ABI, n_args, rtype, atypes) != FFI_OK)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1650,22 ***</span>
      {
        GType type = param_types[i]  &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
        GType fundamental = G_TYPE_FUNDAMENTAL (type);
  
        if ((param_types[i]  &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0)
<span class="line-modified">!     {</span>
<span class="line-modified">!       if (fundamental == G_TYPE_STRING &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">!         g_free (storage[i]._gpointer);</span>
<span class="line-modified">!       else if (fundamental == G_TYPE_PARAM &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">!         g_param_spec_unref (storage[i]._gpointer);</span>
<span class="line-modified">!       else if (fundamental == G_TYPE_BOXED &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">!         g_boxed_free (type, storage[i]._gpointer);</span>
<span class="line-modified">!       else if (fundamental == G_TYPE_VARIANT &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">!         g_variant_unref (storage[i]._gpointer);</span>
<span class="line-modified">!     }</span>
        if (fundamental == G_TYPE_OBJECT &amp;&amp; storage[i]._gpointer != NULL)
<span class="line-modified">!     g_object_unref (storage[i]._gpointer);</span>
      }
  
    if (return_value &amp;&amp; G_VALUE_TYPE (return_value))
      value_from_ffi_type (return_value, rvalue);
  }
<span class="line-new-header">--- 1654,22 ---</span>
      {
        GType type = param_types[i]  &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
        GType fundamental = G_TYPE_FUNDAMENTAL (type);
  
        if ((param_types[i]  &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0)
<span class="line-modified">!   {</span>
<span class="line-modified">!     if (fundamental == G_TYPE_STRING &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">!       g_free (storage[i]._gpointer);</span>
<span class="line-modified">!     else if (fundamental == G_TYPE_PARAM &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">!       g_param_spec_unref (storage[i]._gpointer);</span>
<span class="line-modified">!     else if (fundamental == G_TYPE_BOXED &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">!       g_boxed_free (type, storage[i]._gpointer);</span>
<span class="line-modified">!     else if (fundamental == G_TYPE_VARIANT &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">!       g_variant_unref (storage[i]._gpointer);</span>
<span class="line-modified">!   }</span>
        if (fundamental == G_TYPE_OBJECT &amp;&amp; storage[i]._gpointer != NULL)
<span class="line-modified">!   g_object_unref (storage[i]._gpointer);</span>
      }
  
    if (return_value &amp;&amp; G_VALUE_TYPE (return_value))
      value_from_ffi_type (return_value, rvalue);
  }
</pre>
<center><a href="gboxed.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gclosure.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>