<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gfileutils.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gerror.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gfileutils.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gfileutils.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  47 #endif
  48 
  49 #include &quot;gfileutils.h&quot;
  50 
  51 #include &quot;gstdio.h&quot;
  52 #include &quot;gstdioprivate.h&quot;
  53 #include &quot;glibintl.h&quot;
  54 
  55 #ifdef HAVE_LINUX_MAGIC_H /* for btrfs check */
  56 #include &lt;linux/magic.h&gt;
  57 #include &lt;sys/vfs.h&gt;
  58 #endif
  59 
  60 
  61 /**
  62  * SECTION:fileutils
  63  * @title: File Utilities
  64  * @short_description: various file-related functions
  65  *
  66  * Do not use these APIs unless you are porting a POSIX application to Windows.
<span class="line-modified">  67  * A more high-level file access API is provided as GIO see the documentation</span>
  68  * for #GFile.
  69  *
  70  * There is a group of functions which wrap the common POSIX functions
  71  * dealing with filenames (g_open(), g_rename(), g_mkdir(), g_stat(),
  72  * g_unlink(), g_remove(), g_fopen(), g_freopen()). The point of these
  73  * wrappers is to make it possible to handle file names with any Unicode
  74  * characters in them on Windows without having to use ifdefs and the
  75  * wide character API in the application code.
  76  *
  77  * On some Unix systems, these APIs may be defined as identical to their POSIX
  78  * counterparts. For this reason, you must check for and include the necessary
  79  * header files (such as `fcntl.h`) before using functions like g_creat(). You
  80  * must also define the relevant feature test macros.
  81  *
  82  * The pathname argument should be in the GLib file name encoding.
  83  * On POSIX this is the actual on-disk encoding which might correspond
  84  * to the locale settings of the process (or the `G_FILENAME_ENCODING`
  85  * environment variable), or not.
  86  *
  87  * On Windows the GLib file name encoding is UTF-8. Note that the
</pre>
<hr />
<pre>
 199  *     be a regular file.
 200  *
 201  * A test to perform on a file using g_file_test().
 202  */
 203 
 204 /**
 205  * g_mkdir_with_parents:
 206  * @pathname: (type filename): a pathname in the GLib file name encoding
 207  * @mode: permissions to use for newly created directories
 208  *
 209  * Create a directory if it doesn&#39;t already exist. Create intermediate
 210  * parent directories as needed, too.
 211  *
 212  * Returns: 0 if the directory already exists, or was successfully
 213  * created. Returns -1 if an error occurred, with errno set.
 214  *
 215  * Since: 2.8
 216  */
 217 int
 218 g_mkdir_with_parents (const gchar *pathname,
<span class="line-modified"> 219               int          mode)</span>
 220 {
 221   gchar *fn, *p;
 222 
 223   if (pathname == NULL || *pathname == &#39;\0&#39;)
 224     {
 225       errno = EINVAL;
 226       return -1;
 227     }
 228 














 229   fn = g_strdup (pathname);
 230 
 231   if (g_path_is_absolute (fn))
 232     p = (gchar *) g_path_skip_root (fn);
 233   else
 234     p = fn;
 235 
 236   do
 237     {
 238       while (*p &amp;&amp; !G_IS_DIR_SEPARATOR (*p))
<span class="line-modified"> 239     p++;</span>
 240 
 241       if (!*p)
<span class="line-modified"> 242     p = NULL;</span>
 243       else
<span class="line-modified"> 244     *p = &#39;\0&#39;;</span>
 245 
 246       if (!g_file_test (fn, G_FILE_TEST_EXISTS))
<span class="line-modified"> 247     {</span>
<span class="line-modified"> 248       if (g_mkdir (fn, mode) == -1 &amp;&amp; errno != EEXIST)</span>
<span class="line-modified"> 249         {</span>
<span class="line-modified"> 250           int errno_save = errno;</span>
<span class="line-modified"> 251           g_free (fn);</span>
<span class="line-modified"> 252           errno = errno_save;</span>
<span class="line-modified"> 253           return -1;</span>
<span class="line-modified"> 254         }</span>

 255     }


 256       else if (!g_file_test (fn, G_FILE_TEST_IS_DIR))
<span class="line-modified"> 257     {</span>
<span class="line-modified"> 258       g_free (fn);</span>
<span class="line-modified"> 259       errno = ENOTDIR;</span>
<span class="line-modified"> 260       return -1;</span>
<span class="line-modified"> 261     }</span>
 262       if (p)
<span class="line-modified"> 263     {</span>
<span class="line-modified"> 264       *p++ = G_DIR_SEPARATOR;</span>
<span class="line-modified"> 265       while (*p &amp;&amp; G_IS_DIR_SEPARATOR (*p))</span>
<span class="line-modified"> 266         p++;</span>
<span class="line-modified"> 267     }</span>
 268     }
 269   while (p);
 270 
 271   g_free (fn);
 272 
 273   return 0;
 274 }
 275 
 276 /**
 277  * g_file_test:
 278  * @filename: (type filename): a filename to test in the
 279  *     GLib file name encoding
 280  * @test: bitfield of #GFileTest flags
 281  *
 282  * Returns %TRUE if any of the tests in the bitfield @test are
 283  * %TRUE. For example, `(G_FILE_TEST_EXISTS | G_FILE_TEST_IS_DIR)`
 284  * will return %TRUE if the file exists; the check whether it&#39;s a
 285  * directory doesn&#39;t matter since the existence test is %TRUE. With
 286  * the current set of available tests, there&#39;s no point passing in
 287  * more than one test at a time.
</pre>
<hr />
<pre>
 343 #    define FILE_ATTRIBUTE_DEVICE 64
 344 #  endif
 345   wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 346 
 347   if (wfilename == NULL)
 348     return FALSE;
 349 
 350   attributes = GetFileAttributesW (wfilename);
 351 
 352   g_free (wfilename);
 353 
 354   if (attributes == INVALID_FILE_ATTRIBUTES)
 355     return FALSE;
 356 
 357   if (test &amp; G_FILE_TEST_EXISTS)
 358     return TRUE;
 359 
 360   if (test &amp; G_FILE_TEST_IS_REGULAR)
 361     {
 362       if ((attributes &amp; (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_DEVICE)) == 0)
<span class="line-modified"> 363     return TRUE;</span>
 364     }
 365 
 366   if (test &amp; G_FILE_TEST_IS_DIR)
 367     {
 368       if ((attributes &amp; FILE_ATTRIBUTE_DIRECTORY) != 0)
<span class="line-modified"> 369     return TRUE;</span>
 370     }
 371 
 372   /* &quot;while&quot; so that we can exit this &quot;loop&quot; with a simple &quot;break&quot; */
 373   while (test &amp; G_FILE_TEST_IS_EXECUTABLE)
 374     {
 375       const gchar *lastdot = strrchr (filename, &#39;.&#39;);
 376       const gchar *pathext = NULL, *p;
 377       int extlen;
 378 
 379       if (lastdot == NULL)
 380         break;
 381 
 382       if (_stricmp (lastdot, &quot;.exe&quot;) == 0 ||
<span class="line-modified"> 383       _stricmp (lastdot, &quot;.cmd&quot;) == 0 ||</span>
<span class="line-modified"> 384       _stricmp (lastdot, &quot;.bat&quot;) == 0 ||</span>
<span class="line-modified"> 385       _stricmp (lastdot, &quot;.com&quot;) == 0)</span>
<span class="line-modified"> 386     return TRUE;</span>
 387 
 388       /* Check if it is one of the types listed in %PATHEXT% */
 389 
 390       pathext = g_getenv (&quot;PATHEXT&quot;);
 391       if (pathext == NULL)
 392         break;
 393 
 394       pathext = g_utf8_casefold (pathext, -1);
 395 
 396       lastdot = g_utf8_casefold (lastdot, -1);
 397       extlen = strlen (lastdot);
 398 
 399       p = pathext;
 400       while (TRUE)
<span class="line-modified"> 401     {</span>
<span class="line-modified"> 402       const gchar *q = strchr (p, &#39;;&#39;);</span>
<span class="line-modified"> 403       if (q == NULL)</span>
<span class="line-modified"> 404         q = p + strlen (p);</span>
<span class="line-modified"> 405       if (extlen == q - p &amp;&amp;</span>
<span class="line-modified"> 406           memcmp (lastdot, p, extlen) == 0)</span>
<span class="line-modified"> 407         {</span>
<span class="line-modified"> 408           g_free ((gchar *) pathext);</span>
<span class="line-modified"> 409           g_free ((gchar *) lastdot);</span>
<span class="line-modified"> 410           return TRUE;</span>
<span class="line-modified"> 411         }</span>
<span class="line-modified"> 412       if (*q)</span>
<span class="line-modified"> 413         p = q + 1;</span>
<span class="line-modified"> 414       else</span>
<span class="line-modified"> 415         break;</span>
<span class="line-modified"> 416     }</span>
 417 
 418       g_free ((gchar *) pathext);
 419       g_free ((gchar *) lastdot);
 420       break;
 421     }
 422 
 423   return FALSE;
 424 #else
 425   if ((test &amp; G_FILE_TEST_EXISTS) &amp;&amp; (access (filename, F_OK) == 0))
 426     return TRUE;
 427 
 428   if ((test &amp; G_FILE_TEST_IS_EXECUTABLE) &amp;&amp; (access (filename, X_OK) == 0))
 429     {
 430       if (getuid () != 0)
<span class="line-modified"> 431     return TRUE;</span>
 432 
 433       /* For root, on some POSIX systems, access (filename, X_OK)
 434        * will succeed even if no executable bits are set on the
 435        * file. We fall through to a stat test to avoid that.
 436        */
 437     }
 438   else
 439     test &amp;= ~G_FILE_TEST_IS_EXECUTABLE;
 440 
 441   if (test &amp; G_FILE_TEST_IS_SYMLINK)
 442     {
 443       struct stat s;
 444 
 445       if ((lstat (filename, &amp;s) == 0) &amp;&amp; S_ISLNK (s.st_mode))
 446         return TRUE;
 447     }
 448 
 449   if (test &amp; (G_FILE_TEST_IS_REGULAR |
<span class="line-modified"> 450           G_FILE_TEST_IS_DIR |</span>
<span class="line-modified"> 451           G_FILE_TEST_IS_EXECUTABLE))</span>
 452     {
 453       struct stat s;
 454 
 455       if (stat (filename, &amp;s) == 0)
<span class="line-modified"> 456     {</span>
<span class="line-modified"> 457       if ((test &amp; G_FILE_TEST_IS_REGULAR) &amp;&amp; S_ISREG (s.st_mode))</span>
<span class="line-modified"> 458         return TRUE;</span>
 459 
<span class="line-modified"> 460       if ((test &amp; G_FILE_TEST_IS_DIR) &amp;&amp; S_ISDIR (s.st_mode))</span>
<span class="line-modified"> 461         return TRUE;</span>
 462 
<span class="line-modified"> 463       /* The extra test for root when access (file, X_OK) succeeds.</span>
<span class="line-modified"> 464        */</span>
<span class="line-modified"> 465       if ((test &amp; G_FILE_TEST_IS_EXECUTABLE) &amp;&amp;</span>
<span class="line-modified"> 466           ((s.st_mode &amp; S_IXOTH) ||</span>
<span class="line-modified"> 467            (s.st_mode &amp; S_IXUSR) ||</span>
<span class="line-modified"> 468            (s.st_mode &amp; S_IXGRP)))</span>
<span class="line-modified"> 469         return TRUE;</span>
<span class="line-modified"> 470     }</span>
 471     }
 472 
 473   return FALSE;
 474 #endif
 475 }
 476 
 477 G_DEFINE_QUARK (g-file-error-quark, g_file_error)
 478 
 479 /**
 480  * g_file_error_from_errno:
 481  * @err_no: an &quot;errno&quot; value
 482  *
 483  * Gets a #GFileError constant based on the passed-in @err_no.
 484  * For example, if you pass in `EEXIST` this function returns
 485  * #G_FILE_ERROR_EXIST. Unlike `errno` values, you can portably
 486  * assume that all #GFileError values will exist.
 487  *
 488  * Normally a #GFileError value goes into a #GError returned
 489  * from a function that manipulates files. So you would use
 490  * g_file_error_from_errno() when constructing a #GError.
</pre>
<hr />
<pre>
 711             {
 712               if (total_allocated &gt; G_MAXSIZE / 2)
 713                   goto file_too_large;
 714               total_allocated *= 2;
 715             }
 716           else
 717             {
 718               total_allocated = MIN (bytes + 1, sizeof (buf));
 719             }
 720 
 721           tmp = g_try_realloc (str, total_allocated);
 722 
 723           if (tmp == NULL)
 724             {
 725               display_filename = g_filename_display_name (filename);
 726               g_set_error (error,
 727                            G_FILE_ERROR,
 728                            G_FILE_ERROR_NOMEM,
 729                            g_dngettext (GETTEXT_PACKAGE, &quot;Could not allocate %lu byte to read file &#39;%s&#39;&quot;, &quot;Could not allocate %lu bytes to read file &#39;%s&#39;&quot;, (gulong)total_allocated),
 730                            (gulong) total_allocated,
<span class="line-modified"> 731                display_filename);</span>
 732               g_free (display_filename);
 733 
 734               goto error;
 735             }
 736 
<span class="line-modified"> 737       str = tmp;</span>
 738         }
 739 
 740       if (ferror (f))
 741         {
 742           display_filename = g_filename_display_name (filename);
 743           g_set_error (error,
 744                        G_FILE_ERROR,
 745                        g_file_error_from_errno (save_errno),
 746                        _(&quot;Error reading file &#39;%s&#39;: %s&quot;),
 747                        display_filename,
<span class="line-modified"> 748                g_strerror (save_errno));</span>
 749           g_free (display_filename);
 750 
 751           goto error;
 752         }
 753 
 754       g_assert (str != NULL);
 755       memcpy (str + total_bytes, buf, bytes);
 756 
 757       total_bytes += bytes;
 758     }
 759 
 760   fclose (f);
 761 
 762   if (total_allocated == 0)
 763     {
 764       str = g_new (gchar, 1);
 765       total_bytes = 0;
 766     }
 767 
 768   str[total_bytes] = &#39;\0&#39;;
</pre>
<hr />
<pre>
 803 {
 804   gchar *buf;
 805   gsize bytes_read;
 806   gsize size;
 807   gsize alloc_size;
 808   gchar *display_filename;
 809 
 810   size = stat_buf-&gt;st_size;
 811 
 812   alloc_size = size + 1;
 813   buf = g_try_malloc (alloc_size);
 814 
 815   if (buf == NULL)
 816     {
 817       display_filename = g_filename_display_name (filename);
 818       g_set_error (error,
 819                    G_FILE_ERROR,
 820                    G_FILE_ERROR_NOMEM,
 821                            g_dngettext (GETTEXT_PACKAGE, &quot;Could not allocate %lu byte to read file &#39;%s&#39;&quot;, &quot;Could not allocate %lu bytes to read file &#39;%s&#39;&quot;, (gulong)alloc_size),
 822                    (gulong) alloc_size,
<span class="line-modified"> 823            display_filename);</span>
 824       g_free (display_filename);
 825       goto error;
 826     }
 827 
 828   bytes_read = 0;
 829   while (bytes_read &lt; size)
 830     {
 831       gssize rc;
 832 
 833       rc = read (fd, buf + bytes_read, size - bytes_read);
 834 
 835       if (rc &lt; 0)
 836         {
 837           if (errno != EINTR)
 838             {
<span class="line-modified"> 839           int save_errno = errno;</span>
 840 
 841               g_free (buf);
 842               display_filename = g_filename_display_name (filename);
 843               g_set_error (error,
 844                            G_FILE_ERROR,
 845                            g_file_error_from_errno (save_errno),
 846                            _(&quot;Failed to read from file &#39;%s&#39;: %s&quot;),
 847                            display_filename,
<span class="line-modified"> 848                g_strerror (save_errno));</span>
 849               g_free (display_filename);
<span class="line-modified"> 850           goto error;</span>
 851             }
 852         }
 853       else if (rc == 0)
 854         break;
 855       else
 856         bytes_read += rc;
 857     }
 858 
 859   buf[bytes_read] = &#39;\0&#39;;
 860 
 861   if (length)
 862     *length = bytes_read;
 863 
 864   *contents = buf;
 865 
 866   close (fd);
 867 
 868   return TRUE;
 869 
 870  error:
</pre>
<hr />
<pre>
 896 
 897       return FALSE;
 898     }
 899 
 900   /* I don&#39;t think this will ever fail, aside from ENOMEM, but. */
 901   if (fstat (fd, &amp;stat_buf) &lt; 0)
 902     {
 903       int saved_errno = errno;
 904       set_file_error (error,
 905                       filename,
 906                       _(&quot;Failed to get attributes of file &#39;%s&#39;: fstat() failed: %s&quot;),
 907                       saved_errno);
 908       close (fd);
 909 
 910       return FALSE;
 911     }
 912 
 913   if (stat_buf.st_size &gt; 0 &amp;&amp; S_ISREG (stat_buf.st_mode))
 914     {
 915       gboolean retval = get_contents_regfile (filename,
<span class="line-modified"> 916                           &amp;stat_buf,</span>
<span class="line-modified"> 917                           fd,</span>
<span class="line-modified"> 918                           contents,</span>
<span class="line-modified"> 919                           length,</span>
<span class="line-modified"> 920                           error);</span>
 921 
 922       return retval;
 923     }
 924   else
 925     {
 926       FILE *f;
 927       gboolean retval;
 928 
 929       f = fdopen (fd, &quot;r&quot;);
 930 
 931       if (f == NULL)
 932         {
 933           int saved_errno = errno;
 934           set_file_error (error,
 935                           filename,
 936                           _(&quot;Failed to open file &#39;%s&#39;: fdopen() failed: %s&quot;),
 937                           saved_errno);
 938 
 939           return FALSE;
 940         }
 941 
 942       retval = get_contents_stdio (filename, f, contents, length, error);
 943 
 944       return retval;
 945     }
 946 }
 947 
 948 #else  /* G_OS_WIN32 */
 949 
 950 static gboolean
 951 get_contents_win32 (const gchar  *filename,
<span class="line-modified"> 952             gchar       **contents,</span>
<span class="line-modified"> 953             gsize        *length,</span>
<span class="line-modified"> 954             GError      **error)</span>
 955 {
 956   FILE *f;
 957   gboolean retval;
 958 
 959   f = g_fopen (filename, &quot;rb&quot;);
 960 
 961   if (f == NULL)
 962     {
 963       int saved_errno = errno;
 964       set_file_error (error,
 965                       filename,
 966                       _(&quot;Failed to open file &#39;%s&#39;: %s&quot;),
 967                       saved_errno);
 968 
 969       return FALSE;
 970     }
 971 
 972   retval = get_contents_stdio (filename, f, contents, length, error);
 973 
 974   return retval;
</pre>
<hr />
<pre>
1002                      gchar       **contents,
1003                      gsize        *length,
1004                      GError      **error)
1005 {
1006   g_return_val_if_fail (filename != NULL, FALSE);
1007   g_return_val_if_fail (contents != NULL, FALSE);
1008 
1009   *contents = NULL;
1010   if (length)
1011     *length = 0;
1012 
1013 #ifdef G_OS_WIN32
1014   return get_contents_win32 (filename, contents, length, error);
1015 #else
1016   return get_contents_posix (filename, contents, length, error);
1017 #endif
1018 }
1019 
1020 static gboolean
1021 rename_file (const char  *old_name,
<span class="line-modified">1022          const char  *new_name,</span>
<span class="line-modified">1023          GError     **err)</span>
1024 {
1025   errno = 0;
1026   if (g_rename (old_name, new_name) == -1)
1027     {
1028       int save_errno = errno;
1029       gchar *display_old_name = g_filename_display_name (old_name);
1030       gchar *display_new_name = g_filename_display_name (new_name);
1031 
1032       g_set_error (err,
<span class="line-modified">1033            G_FILE_ERROR,</span>
<span class="line-modified">1034            g_file_error_from_errno (save_errno),</span>
<span class="line-modified">1035            _(&quot;Failed to rename file &#39;%s&#39; to &#39;%s&#39;: g_rename() failed: %s&quot;),</span>
<span class="line-modified">1036            display_old_name,</span>
<span class="line-modified">1037            display_new_name,</span>
<span class="line-modified">1038            g_strerror (save_errno));</span>
1039 
1040       g_free (display_old_name);
1041       g_free (display_new_name);
1042 
1043       return FALSE;
1044     }
1045 
1046   return TRUE;
1047 }
1048 
1049 static gchar *
1050 write_to_temp_file (const gchar  *contents,
<span class="line-modified">1051             gssize        length,</span>
<span class="line-modified">1052             const gchar  *dest_file,</span>
<span class="line-modified">1053             GError      **err)</span>
1054 {
1055   gchar *tmp_name;
1056   gchar *retval;
1057   gint fd;
1058 
1059   retval = NULL;
1060 
1061   tmp_name = g_strdup_printf (&quot;%s.XXXXXX&quot;, dest_file);
1062 
1063   errno = 0;
1064   fd = g_mkstemp_full (tmp_name, O_RDWR | O_BINARY, 0666);
1065 
1066   if (fd == -1)
1067     {
1068       int saved_errno = errno;
1069       set_file_error (err,
1070                       tmp_name, _(&quot;Failed to create file &#39;%s&#39;: %s&quot;),
1071                       saved_errno);
1072       goto out;
1073     }
</pre>
<hr />
<pre>
1201  *   new name, so on Windows there is a race condition between the existing
1202  *   file being removed and the temporary file being renamed.
1203  *
1204  * - On Windows there is no way to remove a file that is open to some
1205  *   process, or mapped into memory. Thus, this function will fail if
1206  *   @filename already exists and is open.
1207  *
1208  * If the call was successful, it returns %TRUE. If the call was not successful,
1209  * it returns %FALSE and sets @error. The error domain is #G_FILE_ERROR.
1210  * Possible error codes are those in the #GFileError enumeration.
1211  *
1212  * Note that the name for the temporary file is constructed by appending up
1213  * to 7 characters to @filename.
1214  *
1215  * Returns: %TRUE on success, %FALSE if an error occurred
1216  *
1217  * Since: 2.8
1218  */
1219 gboolean
1220 g_file_set_contents (const gchar  *filename,
<span class="line-modified">1221                      const gchar  *contents,</span>
<span class="line-modified">1222              gssize    length,</span>
<span class="line-modified">1223              GError  **error)</span>
1224 {
1225   gchar *tmp_filename;
1226   gboolean retval;
1227   GError *rename_error = NULL;
1228 
1229   g_return_val_if_fail (filename != NULL, FALSE);
1230   g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
1231   g_return_val_if_fail (contents != NULL || length == 0, FALSE);
1232   g_return_val_if_fail (length &gt;= -1, FALSE);
1233 
1234   if (length == -1)
1235     length = strlen (contents);
1236 
1237   tmp_filename = write_to_temp_file (contents, length, filename, error);
1238 
1239   if (!tmp_filename)
1240     {
1241       retval = FALSE;
1242       goto out;
1243     }
1244 
1245   if (!rename_file (tmp_filename, filename, &amp;rename_error))
1246     {
1247 #ifndef G_OS_WIN32
1248 
1249       g_unlink (tmp_filename);
1250       g_propagate_error (error, rename_error);
1251       retval = FALSE;
1252       goto out;
1253 
1254 #else /* G_OS_WIN32 */
1255 
1256       /* Renaming failed, but on Windows this may just mean
1257        * the file already exists. So if the target file
1258        * exists, try deleting it and do the rename again.
1259        */
1260       if (!g_file_test (filename, G_FILE_TEST_EXISTS))
<span class="line-modified">1261     {</span>
<span class="line-modified">1262       g_unlink (tmp_filename);</span>
<span class="line-modified">1263       g_propagate_error (error, rename_error);</span>
<span class="line-modified">1264       retval = FALSE;</span>
<span class="line-modified">1265       goto out;</span>
<span class="line-modified">1266     }</span>
1267 
1268       g_error_free (rename_error);
1269 
1270       if (g_unlink (filename) == -1)
<span class="line-modified">1271     {</span>
1272           int saved_errno = errno;
1273           set_file_error (error,
1274                           filename,
<span class="line-modified">1275                   _(&quot;Existing file &#39;%s&#39; could not be removed: g_unlink() failed: %s&quot;),</span>
1276                           saved_errno);
<span class="line-modified">1277       g_unlink (tmp_filename);</span>
<span class="line-modified">1278       retval = FALSE;</span>
<span class="line-modified">1279       goto out;</span>
<span class="line-modified">1280     }</span>
1281 
1282       if (!rename_file (tmp_filename, filename, error))
<span class="line-modified">1283     {</span>
<span class="line-modified">1284       g_unlink (tmp_filename);</span>
<span class="line-modified">1285       retval = FALSE;</span>
<span class="line-modified">1286       goto out;</span>
<span class="line-modified">1287     }</span>
1288 
1289 #endif
1290     }
1291 
1292   retval = TRUE;
1293 
1294  out:
1295   g_free (tmp_filename);
1296   return retval;
1297 }
1298 
1299 /*
1300  * get_tmp_file based on the mkstemp implementation from the GNU C library.
1301  * Copyright (C) 1991,92,93,94,95,96,97,98,99 Free Software Foundation, Inc.
1302  */
1303 typedef gint (*GTmpFileCallback) (const gchar *, gint, gint);
1304 
1305 static gint
1306 get_tmp_file (gchar            *tmpl,
1307               GTmpFileCallback  f,
1308               int               flags,
1309               int               mode)
1310 {
1311   char *XXXXXX;
1312   int count, fd;
1313   static const char letters[] =
1314     &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;;
1315   static const int NLETTERS = sizeof (letters) - 1;
1316   glong value;
<span class="line-modified">1317   GTimeVal tv;</span>
1318   static int counter = 0;
1319 
1320   g_return_val_if_fail (tmpl != NULL, -1);
1321 
1322   /* find the last occurrence of &quot;XXXXXX&quot; */
1323   XXXXXX = g_strrstr (tmpl, &quot;XXXXXX&quot;);
1324 
1325   if (!XXXXXX || strncmp (XXXXXX, &quot;XXXXXX&quot;, 6))
1326     {
1327       errno = EINVAL;
1328       return -1;
1329     }
1330 
1331   /* Get some more or less random data.  */
<span class="line-modified">1332   g_get_current_time (&amp;tv);</span>
<span class="line-modified">1333   value = (tv.tv_usec ^ tv.tv_sec) + counter++;</span>
1334 
1335   for (count = 0; count &lt; 100; value += 7777, ++count)
1336     {
1337       glong v = value;
1338 
1339       /* Fill in the random bits.  */
1340       XXXXXX[0] = letters[v % NLETTERS];
1341       v /= NLETTERS;
1342       XXXXXX[1] = letters[v % NLETTERS];
1343       v /= NLETTERS;
1344       XXXXXX[2] = letters[v % NLETTERS];
1345       v /= NLETTERS;
1346       XXXXXX[3] = letters[v % NLETTERS];
1347       v /= NLETTERS;
1348       XXXXXX[4] = letters[v % NLETTERS];
1349       v /= NLETTERS;
1350       XXXXXX[5] = letters[v % NLETTERS];
1351 
1352       fd = f (tmpl, flags, mode);
1353 
</pre>
<hr />
<pre>
1676  *     returned and @error will be set.
1677  *
1678  * Since: 2.30
1679  */
1680 gchar *
1681 g_dir_make_tmp (const gchar  *tmpl,
1682                 GError      **error)
1683 {
1684   gchar *fulltemplate;
1685 
1686   g_return_val_if_fail (error == NULL || *error == NULL, NULL);
1687 
1688   if (g_get_tmp_name (tmpl, &amp;fulltemplate, wrap_g_mkdir, 0, 0700, error) == -1)
1689     return NULL;
1690   else
1691     return fulltemplate;
1692 }
1693 
1694 static gchar *
1695 g_build_path_va (const gchar  *separator,
<span class="line-modified">1696          const gchar  *first_element,</span>
<span class="line-modified">1697          va_list      *args,</span>
<span class="line-modified">1698          gchar       **str_array)</span>
1699 {
1700   GString *result;
1701   gint separator_len = strlen (separator);
1702   gboolean is_first = TRUE;
1703   gboolean have_leading = FALSE;
1704   const gchar *single_element = NULL;
1705   const gchar *next_element;
1706   const gchar *last_trailing = NULL;
1707   gint i = 0;
1708 
1709   result = g_string_new (NULL);
1710 
1711   if (str_array)
1712     next_element = str_array[i++];
1713   else
1714     next_element = first_element;
1715 
1716   while (TRUE)
1717     {
1718       const gchar *element;
1719       const gchar *start;
1720       const gchar *end;
1721 
1722       if (next_element)
<span class="line-modified">1723     {</span>
<span class="line-modified">1724       element = next_element;</span>
<span class="line-modified">1725       if (str_array)</span>
<span class="line-modified">1726         next_element = str_array[i++];</span>
<span class="line-modified">1727       else</span>
<span class="line-modified">1728         next_element = va_arg (*args, gchar *);</span>
<span class="line-modified">1729     }</span>
1730       else
<span class="line-modified">1731     break;</span>
1732 
1733       /* Ignore empty elements */
1734       if (!*element)
<span class="line-modified">1735     continue;</span>
1736 
1737       start = element;
1738 
1739       if (separator_len)
<span class="line-modified">1740     {</span>
<span class="line-modified">1741       while (strncmp (start, separator, separator_len) == 0)</span>
<span class="line-modified">1742         start += separator_len;</span>
1743         }
1744 
1745       end = start + strlen (start);
1746 
1747       if (separator_len)
<span class="line-modified">1748     {</span>
<span class="line-modified">1749       while (end &gt;= start + separator_len &amp;&amp;</span>
<span class="line-modified">1750          strncmp (end - separator_len, separator, separator_len) == 0)</span>
<span class="line-modified">1751         end -= separator_len;</span>
1752 
<span class="line-modified">1753       last_trailing = end;</span>
<span class="line-modified">1754       while (last_trailing &gt;= element + separator_len &amp;&amp;</span>
<span class="line-modified">1755          strncmp (last_trailing - separator_len, separator, separator_len) == 0)</span>
<span class="line-modified">1756         last_trailing -= separator_len;</span>
1757 
<span class="line-modified">1758       if (!have_leading)</span>
<span class="line-modified">1759         {</span>
<span class="line-modified">1760           /* If the leading and trailing separator strings are in the</span>
<span class="line-modified">1761            * same element and overlap, the result is exactly that element</span>
<span class="line-modified">1762            */</span>
<span class="line-modified">1763           if (last_trailing &lt;= start)</span>
<span class="line-modified">1764         single_element = element;</span>
<span class="line-modified">1765 </span>
<span class="line-modified">1766           g_string_append_len (result, element, start - element);</span>
<span class="line-modified">1767           have_leading = TRUE;</span>
<span class="line-modified">1768         }</span>
<span class="line-modified">1769       else</span>
<span class="line-modified">1770         single_element = NULL;</span>
<span class="line-modified">1771     }</span>
1772 
1773       if (end == start)
<span class="line-modified">1774     continue;</span>
1775 
1776       if (!is_first)
<span class="line-modified">1777     g_string_append (result, separator);</span>
1778 
1779       g_string_append_len (result, start, end - start);
1780       is_first = FALSE;
1781     }
1782 
1783   if (single_element)
1784     {
1785       g_string_free (result, TRUE);
1786       return g_strdup (single_element);
1787     }
1788   else
1789     {
1790       if (last_trailing)
<span class="line-modified">1791     g_string_append (result, last_trailing);</span>
1792 
1793       return g_string_free (result, FALSE);
1794     }
1795 }
1796 
1797 /**
1798  * g_build_pathv:
1799  * @separator: a string used to separator the elements of the path.
1800  * @args: (array zero-terminated=1) (element-type filename): %NULL-terminated
1801  *     array of strings containing the path elements.
1802  *
1803  * Behaves exactly like g_build_path(), but takes the path elements
1804  * as a string array, instead of varargs. This function is mainly
1805  * meant for language bindings.
1806  *
1807  * Returns: (type filename): a newly-allocated string that must be freed
1808  *     with g_free().
1809  *
1810  * Since: 2.8
1811  */
1812 gchar *
1813 g_build_pathv (const gchar  *separator,
<span class="line-modified">1814            gchar       **args)</span>
1815 {
1816   if (!args)
1817     return NULL;
1818 
1819   return g_build_path_va (separator, NULL, NULL, args);
1820 }
1821 
1822 
1823 /**
1824  * g_build_path:
1825  * @separator: (type filename): a string used to separator the elements of the path.
1826  * @first_element: (type filename): the first element in the path
1827  * @...: remaining elements in path, terminated by %NULL
1828  *
1829  * Creates a path from a series of elements using @separator as the
1830  * separator between elements. At the boundary between two elements,
1831  * any trailing occurrences of separator in the first element, or
1832  * leading occurrences of separator in the second element are removed
1833  * and exactly one copy of the separator is inserted.
1834  *
</pre>
<hr />
<pre>
1841  * The number of trailing copies of the separator on the result is
1842  * the same as the number of trailing copies of the separator on
1843  * the last non-empty element. (Determination of the number of
1844  * trailing copies is done without stripping leading copies, so
1845  * if the separator is `ABA`, then `ABABA` has 1 trailing copy.)
1846  *
1847  * However, if there is only a single non-empty element, and there
1848  * are no characters in that element not part of the leading or
1849  * trailing separators, then the result is exactly the original value
1850  * of that element.
1851  *
1852  * Other than for determination of the number of leading and trailing
1853  * copies of the separator, elements consisting only of copies
1854  * of the separator are ignored.
1855  *
1856  * Returns: (type filename): a newly-allocated string that must be freed with
1857  *     g_free().
1858  **/
1859 gchar *
1860 g_build_path (const gchar *separator,
<span class="line-modified">1861           const gchar *first_element,</span>
<span class="line-modified">1862           ...)</span>
1863 {
1864   gchar *str;
1865   va_list args;
1866 
1867   g_return_val_if_fail (separator != NULL, NULL);
1868 
1869   va_start (args, first_element);
1870   str = g_build_path_va (separator, first_element, &amp;args, NULL);
1871   va_end (args);
1872 
1873   return str;
1874 }
1875 
1876 #ifdef G_OS_WIN32
1877 
1878 static gchar *
1879 g_build_pathname_va (const gchar  *first_element,
<span class="line-modified">1880              va_list      *args,</span>
<span class="line-modified">1881              gchar       **str_array)</span>
1882 {
1883   /* Code copied from g_build_pathv(), and modified to use two
1884    * alternative single-character separators.
1885    */
1886   GString *result;
1887   gboolean is_first = TRUE;
1888   gboolean have_leading = FALSE;
1889   const gchar *single_element = NULL;
1890   const gchar *next_element;
1891   const gchar *last_trailing = NULL;
1892   gchar current_separator = &#39;\\&#39;;
1893   gint i = 0;
1894 
1895   result = g_string_new (NULL);
1896 
1897   if (str_array)
1898     next_element = str_array[i++];
1899   else
1900     next_element = first_element;
1901 
1902   while (TRUE)
1903     {
1904       const gchar *element;
1905       const gchar *start;
1906       const gchar *end;
1907 
1908       if (next_element)
<span class="line-modified">1909     {</span>
<span class="line-modified">1910       element = next_element;</span>
<span class="line-modified">1911       if (str_array)</span>
<span class="line-modified">1912         next_element = str_array[i++];</span>
<span class="line-modified">1913       else</span>
<span class="line-modified">1914         next_element = va_arg (*args, gchar *);</span>
<span class="line-modified">1915     }</span>
1916       else
<span class="line-modified">1917     break;</span>
1918 
1919       /* Ignore empty elements */
1920       if (!*element)
<span class="line-modified">1921     continue;</span>
1922 
1923       start = element;
1924 
1925       if (TRUE)
<span class="line-modified">1926     {</span>
<span class="line-modified">1927       while (start &amp;&amp;</span>
<span class="line-modified">1928          (*start == &#39;\\&#39; || *start == &#39;/&#39;))</span>
<span class="line-modified">1929         {</span>
<span class="line-modified">1930           current_separator = *start;</span>
<span class="line-modified">1931           start++;</span>
<span class="line-modified">1932         }</span>
<span class="line-modified">1933     }</span>
1934 
1935       end = start + strlen (start);
1936 
1937       if (TRUE)
<span class="line-modified">1938     {</span>
<span class="line-modified">1939       while (end &gt;= start + 1 &amp;&amp;</span>
<span class="line-modified">1940          (end[-1] == &#39;\\&#39; || end[-1] == &#39;/&#39;))</span>
<span class="line-modified">1941         {</span>
<span class="line-modified">1942           current_separator = end[-1];</span>
<span class="line-modified">1943           end--;</span>
<span class="line-modified">1944         }</span>
1945 
<span class="line-modified">1946       last_trailing = end;</span>
<span class="line-modified">1947       while (last_trailing &gt;= element + 1 &amp;&amp;</span>
<span class="line-modified">1948          (last_trailing[-1] == &#39;\\&#39; || last_trailing[-1] == &#39;/&#39;))</span>
<span class="line-modified">1949         last_trailing--;</span>
1950 
<span class="line-modified">1951       if (!have_leading)</span>
<span class="line-modified">1952         {</span>
<span class="line-modified">1953           /* If the leading and trailing separator strings are in the</span>
<span class="line-modified">1954            * same element and overlap, the result is exactly that element</span>
<span class="line-modified">1955            */</span>
<span class="line-modified">1956           if (last_trailing &lt;= start)</span>
<span class="line-modified">1957         single_element = element;</span>
<span class="line-modified">1958 </span>
<span class="line-modified">1959           g_string_append_len (result, element, start - element);</span>
<span class="line-modified">1960           have_leading = TRUE;</span>
<span class="line-modified">1961         }</span>
<span class="line-modified">1962       else</span>
<span class="line-modified">1963         single_element = NULL;</span>
<span class="line-modified">1964     }</span>
1965 
1966       if (end == start)
<span class="line-modified">1967     continue;</span>
1968 
1969       if (!is_first)
<span class="line-modified">1970     g_string_append_len (result, &amp;current_separator, 1);</span>
1971 
1972       g_string_append_len (result, start, end - start);
1973       is_first = FALSE;
1974     }
1975 
1976   if (single_element)
1977     {
1978       g_string_free (result, TRUE);
1979       return g_strdup (single_element);
1980     }
1981   else
1982     {
1983       if (last_trailing)
<span class="line-modified">1984     g_string_append (result, last_trailing);</span>
1985 
1986       return g_string_free (result, FALSE);
1987     }
1988 }
1989 
1990 #endif
1991 
1992 static gchar *
1993 g_build_filename_va (const gchar  *first_argument,
1994                      va_list      *args,
1995                      gchar       **str_array)
1996 {
1997   gchar *str;
1998 
1999 #ifndef G_OS_WIN32
2000   str = g_build_path_va (G_DIR_SEPARATOR_S, first_argument, args, str_array);
2001 #else
2002   str = g_build_pathname_va (first_argument, args, str_array);
2003 #endif
2004 
</pre>
<hr />
<pre>
2056  * separator for filenames.
2057  *
2058  * On Unix, this function behaves identically to `g_build_path
2059  * (G_DIR_SEPARATOR_S, first_element, ....)`.
2060  *
2061  * On Windows, it takes into account that either the backslash
2062  * (`\` or slash (`/`) can be used as separator in filenames, but
2063  * otherwise behaves as on UNIX. When file pathname separators need
2064  * to be inserted, the one that last previously occurred in the
2065  * parameters (reading from left to right) is used.
2066  *
2067  * No attempt is made to force the resulting filename to be an absolute
2068  * path. If the first element is a relative path, the result will
2069  * be a relative path.
2070  *
2071  * Returns: (type filename): a newly-allocated string that must be freed with
2072  *     g_free().
2073  **/
2074 gchar *
2075 g_build_filename (const gchar *first_element,
<span class="line-modified">2076           ...)</span>
2077 {
2078   gchar *str;
2079   va_list args;
2080 
2081   va_start (args, first_element);
2082   str = g_build_filename_va (first_element, &amp;args, NULL);
2083   va_end (args);
2084 
2085   return str;
2086 }
2087 
2088 /**
2089  * g_file_read_link:
2090  * @filename: (type filename): the symbolic link
2091  * @error: return location for a #GError
2092  *
2093  * Reads the contents of the symbolic link @filename like the POSIX
2094  * readlink() function.  The returned string is in the encoding used
2095  * for filenames. Use g_filename_to_utf8() to convert it to UTF-8.
2096  *
2097  * Returns: (type filename): A newly-allocated string with the contents of
2098  *     the symbolic link, or %NULL if an error occurred.
2099  *
2100  * Since: 2.4
2101  */
2102 gchar *
2103 g_file_read_link (const gchar  *filename,
<span class="line-modified">2104               GError      **error)</span>
2105 {
<span class="line-modified">2106 #if defined (HAVE_READLINK) || defined (G_OS_WIN32)</span>
2107   gchar *buffer;
2108   size_t size;
2109   gssize read_size;
2110 
2111   g_return_val_if_fail (filename != NULL, NULL);
2112   g_return_val_if_fail (error == NULL || *error == NULL, NULL);
2113 
2114   size = 256;
2115   buffer = g_malloc (size);
2116 
2117   while (TRUE)
2118     {
<span class="line-removed">2119 #ifndef G_OS_WIN32</span>
2120       read_size = readlink (filename, buffer, size);
<span class="line-removed">2121 #else</span>
<span class="line-removed">2122       read_size = g_win32_readlink_utf8 (filename, buffer, size);</span>
<span class="line-removed">2123 #endif</span>
2124       if (read_size &lt; 0)
2125         {
2126           int saved_errno = errno;
2127           set_file_error (error,
2128                           filename,
2129                           _(&quot;Failed to read the symbolic link &#39;%s&#39;: %s&quot;),
2130                           saved_errno);
2131           g_free (buffer);
2132           return NULL;
2133         }
2134 
2135       if ((size_t) read_size &lt; size)
2136         {
2137           buffer[read_size] = 0;
2138           return buffer;
2139         }
2140 
2141       size *= 2;
2142       buffer = g_realloc (buffer, size);
2143     }





















2144 #else
2145   g_return_val_if_fail (filename != NULL, NULL);
2146   g_return_val_if_fail (error == NULL || *error == NULL, NULL);
2147 
2148   g_set_error_literal (error,
2149                        G_FILE_ERROR,
2150                        G_FILE_ERROR_INVAL,
2151                        _(&quot;Symbolic links not supported&quot;));
2152 
2153   return NULL;
2154 #endif
2155 }
2156 
2157 /**
2158  * g_path_is_absolute:
2159  * @file_name: (type filename): a file name
2160  *
2161  * Returns %TRUE if the given @file_name is an absolute file name.
2162  * Note that this is a somewhat vague concept on Windows.
2163  *
</pre>
<hr />
<pre>
2383 }
2384 
2385 /**
2386  * g_dirname:
2387  * @file_name: (type filename): the name of the file
2388  *
2389  * Gets the directory components of a file name.
2390  *
2391  * If the file name has no directory components &quot;.&quot; is returned.
2392  * The returned string should be freed when no longer needed.
2393  *
2394  * Returns: (type filename): the directory components of the file
2395  *
2396  * Deprecated: use g_path_get_dirname() instead
2397  */
2398 
2399 /**
2400  * g_path_get_dirname:
2401  * @file_name: (type filename): the name of the file
2402  *
<span class="line-modified">2403  * Gets the directory components of a file name.</span>


2404  *
2405  * If the file name has no directory components &quot;.&quot; is returned.
2406  * The returned string should be freed when no longer needed.
2407  *
2408  * Returns: (type filename): the directory components of the file
2409  */
2410 gchar *
2411 g_path_get_dirname (const gchar *file_name)
2412 {
2413   gchar *base;
2414   gsize len;
2415 
2416   g_return_val_if_fail (file_name != NULL, NULL);
2417 
2418   base = strrchr (file_name, G_DIR_SEPARATOR);
2419 
2420 #ifdef G_OS_WIN32
2421   {
2422     gchar *q;
2423     q = strrchr (file_name, &#39;/&#39;);
</pre>
<hr />
<pre>
2733 #ifndef GSTREAMER_LITE
2734 #ifdef G_OS_WIN32
2735 
2736 /* Binary compatibility versions. Not for newly compiled code. */
2737 
2738 _GLIB_EXTERN gboolean g_file_test_utf8         (const gchar  *filename,
2739                                                 GFileTest     test);
2740 _GLIB_EXTERN gboolean g_file_get_contents_utf8 (const gchar  *filename,
2741                                                 gchar       **contents,
2742                                                 gsize        *length,
2743                                                 GError      **error);
2744 _GLIB_EXTERN gint     g_mkstemp_utf8           (gchar        *tmpl);
2745 _GLIB_EXTERN gint     g_file_open_tmp_utf8     (const gchar  *tmpl,
2746                                                 gchar       **name_used,
2747                                                 GError      **error);
2748 _GLIB_EXTERN gchar   *g_get_current_dir_utf8   (void);
2749 
2750 
2751 gboolean
2752 g_file_test_utf8 (const gchar *filename,
<span class="line-modified">2753              GFileTest    test)</span>
2754 {
2755   return g_file_test (filename, test);
2756 }
2757 
2758 gboolean
2759 g_file_get_contents_utf8 (const gchar  *filename,
<span class="line-modified">2760                      gchar       **contents,</span>
<span class="line-modified">2761                      gsize        *length,</span>
<span class="line-modified">2762                      GError      **error)</span>
2763 {
2764   return g_file_get_contents (filename, contents, length, error);
2765 }
2766 
2767 gint
2768 g_mkstemp_utf8 (gchar *tmpl)
2769 {
2770   return g_mkstemp (tmpl);
2771 }
2772 
2773 gint
2774 g_file_open_tmp_utf8 (const gchar  *tmpl,
<span class="line-modified">2775          gchar       **name_used,</span>
<span class="line-modified">2776          GError      **error)</span>
2777 {
2778   return g_file_open_tmp (tmpl, name_used, error);
2779 }
2780 
2781 gchar *
2782 g_get_current_dir_utf8 (void)
2783 {
2784   return g_get_current_dir ();
2785 }
2786 
2787 #endif
2788 #endif // GSTREAMER_LITE
</pre>
</td>
<td>
<hr />
<pre>
  47 #endif
  48 
  49 #include &quot;gfileutils.h&quot;
  50 
  51 #include &quot;gstdio.h&quot;
  52 #include &quot;gstdioprivate.h&quot;
  53 #include &quot;glibintl.h&quot;
  54 
  55 #ifdef HAVE_LINUX_MAGIC_H /* for btrfs check */
  56 #include &lt;linux/magic.h&gt;
  57 #include &lt;sys/vfs.h&gt;
  58 #endif
  59 
  60 
  61 /**
  62  * SECTION:fileutils
  63  * @title: File Utilities
  64  * @short_description: various file-related functions
  65  *
  66  * Do not use these APIs unless you are porting a POSIX application to Windows.
<span class="line-modified">  67  * A more high-level file access API is provided as GIO - see the documentation</span>
  68  * for #GFile.
  69  *
  70  * There is a group of functions which wrap the common POSIX functions
  71  * dealing with filenames (g_open(), g_rename(), g_mkdir(), g_stat(),
  72  * g_unlink(), g_remove(), g_fopen(), g_freopen()). The point of these
  73  * wrappers is to make it possible to handle file names with any Unicode
  74  * characters in them on Windows without having to use ifdefs and the
  75  * wide character API in the application code.
  76  *
  77  * On some Unix systems, these APIs may be defined as identical to their POSIX
  78  * counterparts. For this reason, you must check for and include the necessary
  79  * header files (such as `fcntl.h`) before using functions like g_creat(). You
  80  * must also define the relevant feature test macros.
  81  *
  82  * The pathname argument should be in the GLib file name encoding.
  83  * On POSIX this is the actual on-disk encoding which might correspond
  84  * to the locale settings of the process (or the `G_FILENAME_ENCODING`
  85  * environment variable), or not.
  86  *
  87  * On Windows the GLib file name encoding is UTF-8. Note that the
</pre>
<hr />
<pre>
 199  *     be a regular file.
 200  *
 201  * A test to perform on a file using g_file_test().
 202  */
 203 
 204 /**
 205  * g_mkdir_with_parents:
 206  * @pathname: (type filename): a pathname in the GLib file name encoding
 207  * @mode: permissions to use for newly created directories
 208  *
 209  * Create a directory if it doesn&#39;t already exist. Create intermediate
 210  * parent directories as needed, too.
 211  *
 212  * Returns: 0 if the directory already exists, or was successfully
 213  * created. Returns -1 if an error occurred, with errno set.
 214  *
 215  * Since: 2.8
 216  */
 217 int
 218 g_mkdir_with_parents (const gchar *pathname,
<span class="line-modified"> 219           int          mode)</span>
 220 {
 221   gchar *fn, *p;
 222 
 223   if (pathname == NULL || *pathname == &#39;\0&#39;)
 224     {
 225       errno = EINVAL;
 226       return -1;
 227     }
 228 
<span class="line-added"> 229   /* try to create the full path first */</span>
<span class="line-added"> 230   if (g_mkdir (pathname, mode) == 0)</span>
<span class="line-added"> 231     return 0;</span>
<span class="line-added"> 232   else if (errno == EEXIST)</span>
<span class="line-added"> 233     {</span>
<span class="line-added"> 234       if (!g_file_test (pathname, G_FILE_TEST_IS_DIR))</span>
<span class="line-added"> 235         {</span>
<span class="line-added"> 236           errno = ENOTDIR;</span>
<span class="line-added"> 237           return -1;</span>
<span class="line-added"> 238         }</span>
<span class="line-added"> 239       return 0;</span>
<span class="line-added"> 240     }</span>
<span class="line-added"> 241 </span>
<span class="line-added"> 242   /* walk the full path and try creating each element */</span>
 243   fn = g_strdup (pathname);
 244 
 245   if (g_path_is_absolute (fn))
 246     p = (gchar *) g_path_skip_root (fn);
 247   else
 248     p = fn;
 249 
 250   do
 251     {
 252       while (*p &amp;&amp; !G_IS_DIR_SEPARATOR (*p))
<span class="line-modified"> 253   p++;</span>
 254 
 255       if (!*p)
<span class="line-modified"> 256   p = NULL;</span>
 257       else
<span class="line-modified"> 258   *p = &#39;\0&#39;;</span>
 259 
 260       if (!g_file_test (fn, G_FILE_TEST_EXISTS))
<span class="line-modified"> 261   {</span>
<span class="line-modified"> 262     if (g_mkdir (fn, mode) == -1 &amp;&amp; errno != EEXIST)</span>
<span class="line-modified"> 263       {</span>
<span class="line-modified"> 264         int errno_save = errno;</span>
<span class="line-modified"> 265         if (errno != ENOENT || !p)</span>
<span class="line-modified"> 266                 {</span>
<span class="line-modified"> 267             g_free (fn);</span>
<span class="line-modified"> 268             errno = errno_save;</span>
<span class="line-added"> 269             return -1;</span>
 270     }
<span class="line-added"> 271       }</span>
<span class="line-added"> 272   }</span>
 273       else if (!g_file_test (fn, G_FILE_TEST_IS_DIR))
<span class="line-modified"> 274   {</span>
<span class="line-modified"> 275     g_free (fn);</span>
<span class="line-modified"> 276     errno = ENOTDIR;</span>
<span class="line-modified"> 277     return -1;</span>
<span class="line-modified"> 278   }</span>
 279       if (p)
<span class="line-modified"> 280   {</span>
<span class="line-modified"> 281     *p++ = G_DIR_SEPARATOR;</span>
<span class="line-modified"> 282     while (*p &amp;&amp; G_IS_DIR_SEPARATOR (*p))</span>
<span class="line-modified"> 283       p++;</span>
<span class="line-modified"> 284   }</span>
 285     }
 286   while (p);
 287 
 288   g_free (fn);
 289 
 290   return 0;
 291 }
 292 
 293 /**
 294  * g_file_test:
 295  * @filename: (type filename): a filename to test in the
 296  *     GLib file name encoding
 297  * @test: bitfield of #GFileTest flags
 298  *
 299  * Returns %TRUE if any of the tests in the bitfield @test are
 300  * %TRUE. For example, `(G_FILE_TEST_EXISTS | G_FILE_TEST_IS_DIR)`
 301  * will return %TRUE if the file exists; the check whether it&#39;s a
 302  * directory doesn&#39;t matter since the existence test is %TRUE. With
 303  * the current set of available tests, there&#39;s no point passing in
 304  * more than one test at a time.
</pre>
<hr />
<pre>
 360 #    define FILE_ATTRIBUTE_DEVICE 64
 361 #  endif
 362   wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 363 
 364   if (wfilename == NULL)
 365     return FALSE;
 366 
 367   attributes = GetFileAttributesW (wfilename);
 368 
 369   g_free (wfilename);
 370 
 371   if (attributes == INVALID_FILE_ATTRIBUTES)
 372     return FALSE;
 373 
 374   if (test &amp; G_FILE_TEST_EXISTS)
 375     return TRUE;
 376 
 377   if (test &amp; G_FILE_TEST_IS_REGULAR)
 378     {
 379       if ((attributes &amp; (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_DEVICE)) == 0)
<span class="line-modified"> 380   return TRUE;</span>
 381     }
 382 
 383   if (test &amp; G_FILE_TEST_IS_DIR)
 384     {
 385       if ((attributes &amp; FILE_ATTRIBUTE_DIRECTORY) != 0)
<span class="line-modified"> 386   return TRUE;</span>
 387     }
 388 
 389   /* &quot;while&quot; so that we can exit this &quot;loop&quot; with a simple &quot;break&quot; */
 390   while (test &amp; G_FILE_TEST_IS_EXECUTABLE)
 391     {
 392       const gchar *lastdot = strrchr (filename, &#39;.&#39;);
 393       const gchar *pathext = NULL, *p;
 394       int extlen;
 395 
 396       if (lastdot == NULL)
 397         break;
 398 
 399       if (_stricmp (lastdot, &quot;.exe&quot;) == 0 ||
<span class="line-modified"> 400     _stricmp (lastdot, &quot;.cmd&quot;) == 0 ||</span>
<span class="line-modified"> 401     _stricmp (lastdot, &quot;.bat&quot;) == 0 ||</span>
<span class="line-modified"> 402     _stricmp (lastdot, &quot;.com&quot;) == 0)</span>
<span class="line-modified"> 403   return TRUE;</span>
 404 
 405       /* Check if it is one of the types listed in %PATHEXT% */
 406 
 407       pathext = g_getenv (&quot;PATHEXT&quot;);
 408       if (pathext == NULL)
 409         break;
 410 
 411       pathext = g_utf8_casefold (pathext, -1);
 412 
 413       lastdot = g_utf8_casefold (lastdot, -1);
 414       extlen = strlen (lastdot);
 415 
 416       p = pathext;
 417       while (TRUE)
<span class="line-modified"> 418   {</span>
<span class="line-modified"> 419     const gchar *q = strchr (p, &#39;;&#39;);</span>
<span class="line-modified"> 420     if (q == NULL)</span>
<span class="line-modified"> 421       q = p + strlen (p);</span>
<span class="line-modified"> 422     if (extlen == q - p &amp;&amp;</span>
<span class="line-modified"> 423         memcmp (lastdot, p, extlen) == 0)</span>
<span class="line-modified"> 424       {</span>
<span class="line-modified"> 425         g_free ((gchar *) pathext);</span>
<span class="line-modified"> 426         g_free ((gchar *) lastdot);</span>
<span class="line-modified"> 427         return TRUE;</span>
<span class="line-modified"> 428       }</span>
<span class="line-modified"> 429     if (*q)</span>
<span class="line-modified"> 430       p = q + 1;</span>
<span class="line-modified"> 431     else</span>
<span class="line-modified"> 432       break;</span>
<span class="line-modified"> 433   }</span>
 434 
 435       g_free ((gchar *) pathext);
 436       g_free ((gchar *) lastdot);
 437       break;
 438     }
 439 
 440   return FALSE;
 441 #else
 442   if ((test &amp; G_FILE_TEST_EXISTS) &amp;&amp; (access (filename, F_OK) == 0))
 443     return TRUE;
 444 
 445   if ((test &amp; G_FILE_TEST_IS_EXECUTABLE) &amp;&amp; (access (filename, X_OK) == 0))
 446     {
 447       if (getuid () != 0)
<span class="line-modified"> 448   return TRUE;</span>
 449 
 450       /* For root, on some POSIX systems, access (filename, X_OK)
 451        * will succeed even if no executable bits are set on the
 452        * file. We fall through to a stat test to avoid that.
 453        */
 454     }
 455   else
 456     test &amp;= ~G_FILE_TEST_IS_EXECUTABLE;
 457 
 458   if (test &amp; G_FILE_TEST_IS_SYMLINK)
 459     {
 460       struct stat s;
 461 
 462       if ((lstat (filename, &amp;s) == 0) &amp;&amp; S_ISLNK (s.st_mode))
 463         return TRUE;
 464     }
 465 
 466   if (test &amp; (G_FILE_TEST_IS_REGULAR |
<span class="line-modified"> 467         G_FILE_TEST_IS_DIR |</span>
<span class="line-modified"> 468         G_FILE_TEST_IS_EXECUTABLE))</span>
 469     {
 470       struct stat s;
 471 
 472       if (stat (filename, &amp;s) == 0)
<span class="line-modified"> 473   {</span>
<span class="line-modified"> 474     if ((test &amp; G_FILE_TEST_IS_REGULAR) &amp;&amp; S_ISREG (s.st_mode))</span>
<span class="line-modified"> 475       return TRUE;</span>
 476 
<span class="line-modified"> 477     if ((test &amp; G_FILE_TEST_IS_DIR) &amp;&amp; S_ISDIR (s.st_mode))</span>
<span class="line-modified"> 478       return TRUE;</span>
 479 
<span class="line-modified"> 480     /* The extra test for root when access (file, X_OK) succeeds.</span>
<span class="line-modified"> 481      */</span>
<span class="line-modified"> 482     if ((test &amp; G_FILE_TEST_IS_EXECUTABLE) &amp;&amp;</span>
<span class="line-modified"> 483         ((s.st_mode &amp; S_IXOTH) ||</span>
<span class="line-modified"> 484          (s.st_mode &amp; S_IXUSR) ||</span>
<span class="line-modified"> 485          (s.st_mode &amp; S_IXGRP)))</span>
<span class="line-modified"> 486       return TRUE;</span>
<span class="line-modified"> 487   }</span>
 488     }
 489 
 490   return FALSE;
 491 #endif
 492 }
 493 
 494 G_DEFINE_QUARK (g-file-error-quark, g_file_error)
 495 
 496 /**
 497  * g_file_error_from_errno:
 498  * @err_no: an &quot;errno&quot; value
 499  *
 500  * Gets a #GFileError constant based on the passed-in @err_no.
 501  * For example, if you pass in `EEXIST` this function returns
 502  * #G_FILE_ERROR_EXIST. Unlike `errno` values, you can portably
 503  * assume that all #GFileError values will exist.
 504  *
 505  * Normally a #GFileError value goes into a #GError returned
 506  * from a function that manipulates files. So you would use
 507  * g_file_error_from_errno() when constructing a #GError.
</pre>
<hr />
<pre>
 728             {
 729               if (total_allocated &gt; G_MAXSIZE / 2)
 730                   goto file_too_large;
 731               total_allocated *= 2;
 732             }
 733           else
 734             {
 735               total_allocated = MIN (bytes + 1, sizeof (buf));
 736             }
 737 
 738           tmp = g_try_realloc (str, total_allocated);
 739 
 740           if (tmp == NULL)
 741             {
 742               display_filename = g_filename_display_name (filename);
 743               g_set_error (error,
 744                            G_FILE_ERROR,
 745                            G_FILE_ERROR_NOMEM,
 746                            g_dngettext (GETTEXT_PACKAGE, &quot;Could not allocate %lu byte to read file &#39;%s&#39;&quot;, &quot;Could not allocate %lu bytes to read file &#39;%s&#39;&quot;, (gulong)total_allocated),
 747                            (gulong) total_allocated,
<span class="line-modified"> 748          display_filename);</span>
 749               g_free (display_filename);
 750 
 751               goto error;
 752             }
 753 
<span class="line-modified"> 754     str = tmp;</span>
 755         }
 756 
 757       if (ferror (f))
 758         {
 759           display_filename = g_filename_display_name (filename);
 760           g_set_error (error,
 761                        G_FILE_ERROR,
 762                        g_file_error_from_errno (save_errno),
 763                        _(&quot;Error reading file &#39;%s&#39;: %s&quot;),
 764                        display_filename,
<span class="line-modified"> 765            g_strerror (save_errno));</span>
 766           g_free (display_filename);
 767 
 768           goto error;
 769         }
 770 
 771       g_assert (str != NULL);
 772       memcpy (str + total_bytes, buf, bytes);
 773 
 774       total_bytes += bytes;
 775     }
 776 
 777   fclose (f);
 778 
 779   if (total_allocated == 0)
 780     {
 781       str = g_new (gchar, 1);
 782       total_bytes = 0;
 783     }
 784 
 785   str[total_bytes] = &#39;\0&#39;;
</pre>
<hr />
<pre>
 820 {
 821   gchar *buf;
 822   gsize bytes_read;
 823   gsize size;
 824   gsize alloc_size;
 825   gchar *display_filename;
 826 
 827   size = stat_buf-&gt;st_size;
 828 
 829   alloc_size = size + 1;
 830   buf = g_try_malloc (alloc_size);
 831 
 832   if (buf == NULL)
 833     {
 834       display_filename = g_filename_display_name (filename);
 835       g_set_error (error,
 836                    G_FILE_ERROR,
 837                    G_FILE_ERROR_NOMEM,
 838                            g_dngettext (GETTEXT_PACKAGE, &quot;Could not allocate %lu byte to read file &#39;%s&#39;&quot;, &quot;Could not allocate %lu bytes to read file &#39;%s&#39;&quot;, (gulong)alloc_size),
 839                    (gulong) alloc_size,
<span class="line-modified"> 840        display_filename);</span>
 841       g_free (display_filename);
 842       goto error;
 843     }
 844 
 845   bytes_read = 0;
 846   while (bytes_read &lt; size)
 847     {
 848       gssize rc;
 849 
 850       rc = read (fd, buf + bytes_read, size - bytes_read);
 851 
 852       if (rc &lt; 0)
 853         {
 854           if (errno != EINTR)
 855             {
<span class="line-modified"> 856         int save_errno = errno;</span>
 857 
 858               g_free (buf);
 859               display_filename = g_filename_display_name (filename);
 860               g_set_error (error,
 861                            G_FILE_ERROR,
 862                            g_file_error_from_errno (save_errno),
 863                            _(&quot;Failed to read from file &#39;%s&#39;: %s&quot;),
 864                            display_filename,
<span class="line-modified"> 865          g_strerror (save_errno));</span>
 866               g_free (display_filename);
<span class="line-modified"> 867         goto error;</span>
 868             }
 869         }
 870       else if (rc == 0)
 871         break;
 872       else
 873         bytes_read += rc;
 874     }
 875 
 876   buf[bytes_read] = &#39;\0&#39;;
 877 
 878   if (length)
 879     *length = bytes_read;
 880 
 881   *contents = buf;
 882 
 883   close (fd);
 884 
 885   return TRUE;
 886 
 887  error:
</pre>
<hr />
<pre>
 913 
 914       return FALSE;
 915     }
 916 
 917   /* I don&#39;t think this will ever fail, aside from ENOMEM, but. */
 918   if (fstat (fd, &amp;stat_buf) &lt; 0)
 919     {
 920       int saved_errno = errno;
 921       set_file_error (error,
 922                       filename,
 923                       _(&quot;Failed to get attributes of file &#39;%s&#39;: fstat() failed: %s&quot;),
 924                       saved_errno);
 925       close (fd);
 926 
 927       return FALSE;
 928     }
 929 
 930   if (stat_buf.st_size &gt; 0 &amp;&amp; S_ISREG (stat_buf.st_mode))
 931     {
 932       gboolean retval = get_contents_regfile (filename,
<span class="line-modified"> 933                 &amp;stat_buf,</span>
<span class="line-modified"> 934                 fd,</span>
<span class="line-modified"> 935                 contents,</span>
<span class="line-modified"> 936                 length,</span>
<span class="line-modified"> 937                 error);</span>
 938 
 939       return retval;
 940     }
 941   else
 942     {
 943       FILE *f;
 944       gboolean retval;
 945 
 946       f = fdopen (fd, &quot;r&quot;);
 947 
 948       if (f == NULL)
 949         {
 950           int saved_errno = errno;
 951           set_file_error (error,
 952                           filename,
 953                           _(&quot;Failed to open file &#39;%s&#39;: fdopen() failed: %s&quot;),
 954                           saved_errno);
 955 
 956           return FALSE;
 957         }
 958 
 959       retval = get_contents_stdio (filename, f, contents, length, error);
 960 
 961       return retval;
 962     }
 963 }
 964 
 965 #else  /* G_OS_WIN32 */
 966 
 967 static gboolean
 968 get_contents_win32 (const gchar  *filename,
<span class="line-modified"> 969         gchar       **contents,</span>
<span class="line-modified"> 970         gsize        *length,</span>
<span class="line-modified"> 971         GError      **error)</span>
 972 {
 973   FILE *f;
 974   gboolean retval;
 975 
 976   f = g_fopen (filename, &quot;rb&quot;);
 977 
 978   if (f == NULL)
 979     {
 980       int saved_errno = errno;
 981       set_file_error (error,
 982                       filename,
 983                       _(&quot;Failed to open file &#39;%s&#39;: %s&quot;),
 984                       saved_errno);
 985 
 986       return FALSE;
 987     }
 988 
 989   retval = get_contents_stdio (filename, f, contents, length, error);
 990 
 991   return retval;
</pre>
<hr />
<pre>
1019                      gchar       **contents,
1020                      gsize        *length,
1021                      GError      **error)
1022 {
1023   g_return_val_if_fail (filename != NULL, FALSE);
1024   g_return_val_if_fail (contents != NULL, FALSE);
1025 
1026   *contents = NULL;
1027   if (length)
1028     *length = 0;
1029 
1030 #ifdef G_OS_WIN32
1031   return get_contents_win32 (filename, contents, length, error);
1032 #else
1033   return get_contents_posix (filename, contents, length, error);
1034 #endif
1035 }
1036 
1037 static gboolean
1038 rename_file (const char  *old_name,
<span class="line-modified">1039        const char  *new_name,</span>
<span class="line-modified">1040        GError     **err)</span>
1041 {
1042   errno = 0;
1043   if (g_rename (old_name, new_name) == -1)
1044     {
1045       int save_errno = errno;
1046       gchar *display_old_name = g_filename_display_name (old_name);
1047       gchar *display_new_name = g_filename_display_name (new_name);
1048 
1049       g_set_error (err,
<span class="line-modified">1050        G_FILE_ERROR,</span>
<span class="line-modified">1051        g_file_error_from_errno (save_errno),</span>
<span class="line-modified">1052        _(&quot;Failed to rename file &#39;%s&#39; to &#39;%s&#39;: g_rename() failed: %s&quot;),</span>
<span class="line-modified">1053        display_old_name,</span>
<span class="line-modified">1054        display_new_name,</span>
<span class="line-modified">1055        g_strerror (save_errno));</span>
1056 
1057       g_free (display_old_name);
1058       g_free (display_new_name);
1059 
1060       return FALSE;
1061     }
1062 
1063   return TRUE;
1064 }
1065 
1066 static gchar *
1067 write_to_temp_file (const gchar  *contents,
<span class="line-modified">1068         gssize        length,</span>
<span class="line-modified">1069         const gchar  *dest_file,</span>
<span class="line-modified">1070         GError      **err)</span>
1071 {
1072   gchar *tmp_name;
1073   gchar *retval;
1074   gint fd;
1075 
1076   retval = NULL;
1077 
1078   tmp_name = g_strdup_printf (&quot;%s.XXXXXX&quot;, dest_file);
1079 
1080   errno = 0;
1081   fd = g_mkstemp_full (tmp_name, O_RDWR | O_BINARY, 0666);
1082 
1083   if (fd == -1)
1084     {
1085       int saved_errno = errno;
1086       set_file_error (err,
1087                       tmp_name, _(&quot;Failed to create file &#39;%s&#39;: %s&quot;),
1088                       saved_errno);
1089       goto out;
1090     }
</pre>
<hr />
<pre>
1218  *   new name, so on Windows there is a race condition between the existing
1219  *   file being removed and the temporary file being renamed.
1220  *
1221  * - On Windows there is no way to remove a file that is open to some
1222  *   process, or mapped into memory. Thus, this function will fail if
1223  *   @filename already exists and is open.
1224  *
1225  * If the call was successful, it returns %TRUE. If the call was not successful,
1226  * it returns %FALSE and sets @error. The error domain is #G_FILE_ERROR.
1227  * Possible error codes are those in the #GFileError enumeration.
1228  *
1229  * Note that the name for the temporary file is constructed by appending up
1230  * to 7 characters to @filename.
1231  *
1232  * Returns: %TRUE on success, %FALSE if an error occurred
1233  *
1234  * Since: 2.8
1235  */
1236 gboolean
1237 g_file_set_contents (const gchar  *filename,
<span class="line-modified">1238          const gchar  *contents,</span>
<span class="line-modified">1239          gssize    length,</span>
<span class="line-modified">1240          GError  **error)</span>
1241 {
1242   gchar *tmp_filename;
1243   gboolean retval;
1244   GError *rename_error = NULL;
1245 
1246   g_return_val_if_fail (filename != NULL, FALSE);
1247   g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
1248   g_return_val_if_fail (contents != NULL || length == 0, FALSE);
1249   g_return_val_if_fail (length &gt;= -1, FALSE);
1250 
1251   if (length == -1)
1252     length = strlen (contents);
1253 
1254   tmp_filename = write_to_temp_file (contents, length, filename, error);
1255 
1256   if (!tmp_filename)
1257     {
1258       retval = FALSE;
1259       goto out;
1260     }
1261 
1262   if (!rename_file (tmp_filename, filename, &amp;rename_error))
1263     {
1264 #ifndef G_OS_WIN32
1265 
1266       g_unlink (tmp_filename);
1267       g_propagate_error (error, rename_error);
1268       retval = FALSE;
1269       goto out;
1270 
1271 #else /* G_OS_WIN32 */
1272 
1273       /* Renaming failed, but on Windows this may just mean
1274        * the file already exists. So if the target file
1275        * exists, try deleting it and do the rename again.
1276        */
1277       if (!g_file_test (filename, G_FILE_TEST_EXISTS))
<span class="line-modified">1278   {</span>
<span class="line-modified">1279     g_unlink (tmp_filename);</span>
<span class="line-modified">1280     g_propagate_error (error, rename_error);</span>
<span class="line-modified">1281     retval = FALSE;</span>
<span class="line-modified">1282     goto out;</span>
<span class="line-modified">1283   }</span>
1284 
1285       g_error_free (rename_error);
1286 
1287       if (g_unlink (filename) == -1)
<span class="line-modified">1288   {</span>
1289           int saved_errno = errno;
1290           set_file_error (error,
1291                           filename,
<span class="line-modified">1292               _(&quot;Existing file &#39;%s&#39; could not be removed: g_unlink() failed: %s&quot;),</span>
1293                           saved_errno);
<span class="line-modified">1294     g_unlink (tmp_filename);</span>
<span class="line-modified">1295     retval = FALSE;</span>
<span class="line-modified">1296     goto out;</span>
<span class="line-modified">1297   }</span>
1298 
1299       if (!rename_file (tmp_filename, filename, error))
<span class="line-modified">1300   {</span>
<span class="line-modified">1301     g_unlink (tmp_filename);</span>
<span class="line-modified">1302     retval = FALSE;</span>
<span class="line-modified">1303     goto out;</span>
<span class="line-modified">1304   }</span>
1305 
1306 #endif
1307     }
1308 
1309   retval = TRUE;
1310 
1311  out:
1312   g_free (tmp_filename);
1313   return retval;
1314 }
1315 
1316 /*
1317  * get_tmp_file based on the mkstemp implementation from the GNU C library.
1318  * Copyright (C) 1991,92,93,94,95,96,97,98,99 Free Software Foundation, Inc.
1319  */
1320 typedef gint (*GTmpFileCallback) (const gchar *, gint, gint);
1321 
1322 static gint
1323 get_tmp_file (gchar            *tmpl,
1324               GTmpFileCallback  f,
1325               int               flags,
1326               int               mode)
1327 {
1328   char *XXXXXX;
1329   int count, fd;
1330   static const char letters[] =
1331     &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;;
1332   static const int NLETTERS = sizeof (letters) - 1;
1333   glong value;
<span class="line-modified">1334   gint64 now_us;</span>
1335   static int counter = 0;
1336 
1337   g_return_val_if_fail (tmpl != NULL, -1);
1338 
1339   /* find the last occurrence of &quot;XXXXXX&quot; */
1340   XXXXXX = g_strrstr (tmpl, &quot;XXXXXX&quot;);
1341 
1342   if (!XXXXXX || strncmp (XXXXXX, &quot;XXXXXX&quot;, 6))
1343     {
1344       errno = EINVAL;
1345       return -1;
1346     }
1347 
1348   /* Get some more or less random data.  */
<span class="line-modified">1349   now_us = g_get_real_time ();</span>
<span class="line-modified">1350   value = ((now_us % G_USEC_PER_SEC) ^ (now_us / G_USEC_PER_SEC)) + counter++;</span>
1351 
1352   for (count = 0; count &lt; 100; value += 7777, ++count)
1353     {
1354       glong v = value;
1355 
1356       /* Fill in the random bits.  */
1357       XXXXXX[0] = letters[v % NLETTERS];
1358       v /= NLETTERS;
1359       XXXXXX[1] = letters[v % NLETTERS];
1360       v /= NLETTERS;
1361       XXXXXX[2] = letters[v % NLETTERS];
1362       v /= NLETTERS;
1363       XXXXXX[3] = letters[v % NLETTERS];
1364       v /= NLETTERS;
1365       XXXXXX[4] = letters[v % NLETTERS];
1366       v /= NLETTERS;
1367       XXXXXX[5] = letters[v % NLETTERS];
1368 
1369       fd = f (tmpl, flags, mode);
1370 
</pre>
<hr />
<pre>
1693  *     returned and @error will be set.
1694  *
1695  * Since: 2.30
1696  */
1697 gchar *
1698 g_dir_make_tmp (const gchar  *tmpl,
1699                 GError      **error)
1700 {
1701   gchar *fulltemplate;
1702 
1703   g_return_val_if_fail (error == NULL || *error == NULL, NULL);
1704 
1705   if (g_get_tmp_name (tmpl, &amp;fulltemplate, wrap_g_mkdir, 0, 0700, error) == -1)
1706     return NULL;
1707   else
1708     return fulltemplate;
1709 }
1710 
1711 static gchar *
1712 g_build_path_va (const gchar  *separator,
<span class="line-modified">1713      const gchar  *first_element,</span>
<span class="line-modified">1714      va_list      *args,</span>
<span class="line-modified">1715      gchar       **str_array)</span>
1716 {
1717   GString *result;
1718   gint separator_len = strlen (separator);
1719   gboolean is_first = TRUE;
1720   gboolean have_leading = FALSE;
1721   const gchar *single_element = NULL;
1722   const gchar *next_element;
1723   const gchar *last_trailing = NULL;
1724   gint i = 0;
1725 
1726   result = g_string_new (NULL);
1727 
1728   if (str_array)
1729     next_element = str_array[i++];
1730   else
1731     next_element = first_element;
1732 
1733   while (TRUE)
1734     {
1735       const gchar *element;
1736       const gchar *start;
1737       const gchar *end;
1738 
1739       if (next_element)
<span class="line-modified">1740   {</span>
<span class="line-modified">1741     element = next_element;</span>
<span class="line-modified">1742     if (str_array)</span>
<span class="line-modified">1743       next_element = str_array[i++];</span>
<span class="line-modified">1744     else</span>
<span class="line-modified">1745       next_element = va_arg (*args, gchar *);</span>
<span class="line-modified">1746   }</span>
1747       else
<span class="line-modified">1748   break;</span>
1749 
1750       /* Ignore empty elements */
1751       if (!*element)
<span class="line-modified">1752   continue;</span>
1753 
1754       start = element;
1755 
1756       if (separator_len)
<span class="line-modified">1757   {</span>
<span class="line-modified">1758     while (strncmp (start, separator, separator_len) == 0)</span>
<span class="line-modified">1759       start += separator_len;</span>
1760         }
1761 
1762       end = start + strlen (start);
1763 
1764       if (separator_len)
<span class="line-modified">1765   {</span>
<span class="line-modified">1766     while (end &gt;= start + separator_len &amp;&amp;</span>
<span class="line-modified">1767      strncmp (end - separator_len, separator, separator_len) == 0)</span>
<span class="line-modified">1768       end -= separator_len;</span>
1769 
<span class="line-modified">1770     last_trailing = end;</span>
<span class="line-modified">1771     while (last_trailing &gt;= element + separator_len &amp;&amp;</span>
<span class="line-modified">1772      strncmp (last_trailing - separator_len, separator, separator_len) == 0)</span>
<span class="line-modified">1773       last_trailing -= separator_len;</span>
1774 
<span class="line-modified">1775     if (!have_leading)</span>
<span class="line-modified">1776       {</span>
<span class="line-modified">1777         /* If the leading and trailing separator strings are in the</span>
<span class="line-modified">1778          * same element and overlap, the result is exactly that element</span>
<span class="line-modified">1779          */</span>
<span class="line-modified">1780         if (last_trailing &lt;= start)</span>
<span class="line-modified">1781     single_element = element;</span>
<span class="line-modified">1782 </span>
<span class="line-modified">1783         g_string_append_len (result, element, start - element);</span>
<span class="line-modified">1784         have_leading = TRUE;</span>
<span class="line-modified">1785       }</span>
<span class="line-modified">1786     else</span>
<span class="line-modified">1787       single_element = NULL;</span>
<span class="line-modified">1788   }</span>
1789 
1790       if (end == start)
<span class="line-modified">1791   continue;</span>
1792 
1793       if (!is_first)
<span class="line-modified">1794   g_string_append (result, separator);</span>
1795 
1796       g_string_append_len (result, start, end - start);
1797       is_first = FALSE;
1798     }
1799 
1800   if (single_element)
1801     {
1802       g_string_free (result, TRUE);
1803       return g_strdup (single_element);
1804     }
1805   else
1806     {
1807       if (last_trailing)
<span class="line-modified">1808   g_string_append (result, last_trailing);</span>
1809 
1810       return g_string_free (result, FALSE);
1811     }
1812 }
1813 
1814 /**
1815  * g_build_pathv:
1816  * @separator: a string used to separator the elements of the path.
1817  * @args: (array zero-terminated=1) (element-type filename): %NULL-terminated
1818  *     array of strings containing the path elements.
1819  *
1820  * Behaves exactly like g_build_path(), but takes the path elements
1821  * as a string array, instead of varargs. This function is mainly
1822  * meant for language bindings.
1823  *
1824  * Returns: (type filename): a newly-allocated string that must be freed
1825  *     with g_free().
1826  *
1827  * Since: 2.8
1828  */
1829 gchar *
1830 g_build_pathv (const gchar  *separator,
<span class="line-modified">1831          gchar       **args)</span>
1832 {
1833   if (!args)
1834     return NULL;
1835 
1836   return g_build_path_va (separator, NULL, NULL, args);
1837 }
1838 
1839 
1840 /**
1841  * g_build_path:
1842  * @separator: (type filename): a string used to separator the elements of the path.
1843  * @first_element: (type filename): the first element in the path
1844  * @...: remaining elements in path, terminated by %NULL
1845  *
1846  * Creates a path from a series of elements using @separator as the
1847  * separator between elements. At the boundary between two elements,
1848  * any trailing occurrences of separator in the first element, or
1849  * leading occurrences of separator in the second element are removed
1850  * and exactly one copy of the separator is inserted.
1851  *
</pre>
<hr />
<pre>
1858  * The number of trailing copies of the separator on the result is
1859  * the same as the number of trailing copies of the separator on
1860  * the last non-empty element. (Determination of the number of
1861  * trailing copies is done without stripping leading copies, so
1862  * if the separator is `ABA`, then `ABABA` has 1 trailing copy.)
1863  *
1864  * However, if there is only a single non-empty element, and there
1865  * are no characters in that element not part of the leading or
1866  * trailing separators, then the result is exactly the original value
1867  * of that element.
1868  *
1869  * Other than for determination of the number of leading and trailing
1870  * copies of the separator, elements consisting only of copies
1871  * of the separator are ignored.
1872  *
1873  * Returns: (type filename): a newly-allocated string that must be freed with
1874  *     g_free().
1875  **/
1876 gchar *
1877 g_build_path (const gchar *separator,
<span class="line-modified">1878         const gchar *first_element,</span>
<span class="line-modified">1879         ...)</span>
1880 {
1881   gchar *str;
1882   va_list args;
1883 
1884   g_return_val_if_fail (separator != NULL, NULL);
1885 
1886   va_start (args, first_element);
1887   str = g_build_path_va (separator, first_element, &amp;args, NULL);
1888   va_end (args);
1889 
1890   return str;
1891 }
1892 
1893 #ifdef G_OS_WIN32
1894 
1895 static gchar *
1896 g_build_pathname_va (const gchar  *first_element,
<span class="line-modified">1897          va_list      *args,</span>
<span class="line-modified">1898          gchar       **str_array)</span>
1899 {
1900   /* Code copied from g_build_pathv(), and modified to use two
1901    * alternative single-character separators.
1902    */
1903   GString *result;
1904   gboolean is_first = TRUE;
1905   gboolean have_leading = FALSE;
1906   const gchar *single_element = NULL;
1907   const gchar *next_element;
1908   const gchar *last_trailing = NULL;
1909   gchar current_separator = &#39;\\&#39;;
1910   gint i = 0;
1911 
1912   result = g_string_new (NULL);
1913 
1914   if (str_array)
1915     next_element = str_array[i++];
1916   else
1917     next_element = first_element;
1918 
1919   while (TRUE)
1920     {
1921       const gchar *element;
1922       const gchar *start;
1923       const gchar *end;
1924 
1925       if (next_element)
<span class="line-modified">1926   {</span>
<span class="line-modified">1927     element = next_element;</span>
<span class="line-modified">1928     if (str_array)</span>
<span class="line-modified">1929       next_element = str_array[i++];</span>
<span class="line-modified">1930     else</span>
<span class="line-modified">1931       next_element = va_arg (*args, gchar *);</span>
<span class="line-modified">1932   }</span>
1933       else
<span class="line-modified">1934   break;</span>
1935 
1936       /* Ignore empty elements */
1937       if (!*element)
<span class="line-modified">1938   continue;</span>
1939 
1940       start = element;
1941 
1942       if (TRUE)
<span class="line-modified">1943   {</span>
<span class="line-modified">1944     while (start &amp;&amp;</span>
<span class="line-modified">1945      (*start == &#39;\\&#39; || *start == &#39;/&#39;))</span>
<span class="line-modified">1946       {</span>
<span class="line-modified">1947         current_separator = *start;</span>
<span class="line-modified">1948         start++;</span>
<span class="line-modified">1949       }</span>
<span class="line-modified">1950   }</span>
1951 
1952       end = start + strlen (start);
1953 
1954       if (TRUE)
<span class="line-modified">1955   {</span>
<span class="line-modified">1956     while (end &gt;= start + 1 &amp;&amp;</span>
<span class="line-modified">1957      (end[-1] == &#39;\\&#39; || end[-1] == &#39;/&#39;))</span>
<span class="line-modified">1958       {</span>
<span class="line-modified">1959         current_separator = end[-1];</span>
<span class="line-modified">1960         end--;</span>
<span class="line-modified">1961       }</span>
1962 
<span class="line-modified">1963     last_trailing = end;</span>
<span class="line-modified">1964     while (last_trailing &gt;= element + 1 &amp;&amp;</span>
<span class="line-modified">1965      (last_trailing[-1] == &#39;\\&#39; || last_trailing[-1] == &#39;/&#39;))</span>
<span class="line-modified">1966       last_trailing--;</span>
1967 
<span class="line-modified">1968     if (!have_leading)</span>
<span class="line-modified">1969       {</span>
<span class="line-modified">1970         /* If the leading and trailing separator strings are in the</span>
<span class="line-modified">1971          * same element and overlap, the result is exactly that element</span>
<span class="line-modified">1972          */</span>
<span class="line-modified">1973         if (last_trailing &lt;= start)</span>
<span class="line-modified">1974     single_element = element;</span>
<span class="line-modified">1975 </span>
<span class="line-modified">1976         g_string_append_len (result, element, start - element);</span>
<span class="line-modified">1977         have_leading = TRUE;</span>
<span class="line-modified">1978       }</span>
<span class="line-modified">1979     else</span>
<span class="line-modified">1980       single_element = NULL;</span>
<span class="line-modified">1981   }</span>
1982 
1983       if (end == start)
<span class="line-modified">1984   continue;</span>
1985 
1986       if (!is_first)
<span class="line-modified">1987   g_string_append_len (result, &amp;current_separator, 1);</span>
1988 
1989       g_string_append_len (result, start, end - start);
1990       is_first = FALSE;
1991     }
1992 
1993   if (single_element)
1994     {
1995       g_string_free (result, TRUE);
1996       return g_strdup (single_element);
1997     }
1998   else
1999     {
2000       if (last_trailing)
<span class="line-modified">2001   g_string_append (result, last_trailing);</span>
2002 
2003       return g_string_free (result, FALSE);
2004     }
2005 }
2006 
2007 #endif
2008 
2009 static gchar *
2010 g_build_filename_va (const gchar  *first_argument,
2011                      va_list      *args,
2012                      gchar       **str_array)
2013 {
2014   gchar *str;
2015 
2016 #ifndef G_OS_WIN32
2017   str = g_build_path_va (G_DIR_SEPARATOR_S, first_argument, args, str_array);
2018 #else
2019   str = g_build_pathname_va (first_argument, args, str_array);
2020 #endif
2021 
</pre>
<hr />
<pre>
2073  * separator for filenames.
2074  *
2075  * On Unix, this function behaves identically to `g_build_path
2076  * (G_DIR_SEPARATOR_S, first_element, ....)`.
2077  *
2078  * On Windows, it takes into account that either the backslash
2079  * (`\` or slash (`/`) can be used as separator in filenames, but
2080  * otherwise behaves as on UNIX. When file pathname separators need
2081  * to be inserted, the one that last previously occurred in the
2082  * parameters (reading from left to right) is used.
2083  *
2084  * No attempt is made to force the resulting filename to be an absolute
2085  * path. If the first element is a relative path, the result will
2086  * be a relative path.
2087  *
2088  * Returns: (type filename): a newly-allocated string that must be freed with
2089  *     g_free().
2090  **/
2091 gchar *
2092 g_build_filename (const gchar *first_element,
<span class="line-modified">2093       ...)</span>
2094 {
2095   gchar *str;
2096   va_list args;
2097 
2098   va_start (args, first_element);
2099   str = g_build_filename_va (first_element, &amp;args, NULL);
2100   va_end (args);
2101 
2102   return str;
2103 }
2104 
2105 /**
2106  * g_file_read_link:
2107  * @filename: (type filename): the symbolic link
2108  * @error: return location for a #GError
2109  *
2110  * Reads the contents of the symbolic link @filename like the POSIX
2111  * readlink() function.  The returned string is in the encoding used
2112  * for filenames. Use g_filename_to_utf8() to convert it to UTF-8.
2113  *
2114  * Returns: (type filename): A newly-allocated string with the contents of
2115  *     the symbolic link, or %NULL if an error occurred.
2116  *
2117  * Since: 2.4
2118  */
2119 gchar *
2120 g_file_read_link (const gchar  *filename,
<span class="line-modified">2121             GError      **error)</span>
2122 {
<span class="line-modified">2123 #if defined (HAVE_READLINK)</span>
2124   gchar *buffer;
2125   size_t size;
2126   gssize read_size;
2127 
2128   g_return_val_if_fail (filename != NULL, NULL);
2129   g_return_val_if_fail (error == NULL || *error == NULL, NULL);
2130 
2131   size = 256;
2132   buffer = g_malloc (size);
2133 
2134   while (TRUE)
2135     {

2136       read_size = readlink (filename, buffer, size);



2137       if (read_size &lt; 0)
2138         {
2139           int saved_errno = errno;
2140           set_file_error (error,
2141                           filename,
2142                           _(&quot;Failed to read the symbolic link &#39;%s&#39;: %s&quot;),
2143                           saved_errno);
2144           g_free (buffer);
2145           return NULL;
2146         }
2147 
2148       if ((size_t) read_size &lt; size)
2149         {
2150           buffer[read_size] = 0;
2151           return buffer;
2152         }
2153 
2154       size *= 2;
2155       buffer = g_realloc (buffer, size);
2156     }
<span class="line-added">2157 #elif defined (G_OS_WIN32)</span>
<span class="line-added">2158   gchar *buffer;</span>
<span class="line-added">2159   gssize read_size;</span>
<span class="line-added">2160 </span>
<span class="line-added">2161   g_return_val_if_fail (filename != NULL, NULL);</span>
<span class="line-added">2162   g_return_val_if_fail (error == NULL || *error == NULL, NULL);</span>
<span class="line-added">2163 </span>
<span class="line-added">2164   read_size = g_win32_readlink_utf8 (filename, NULL, 0, &amp;buffer, TRUE);</span>
<span class="line-added">2165   if (read_size &lt; 0)</span>
<span class="line-added">2166     {</span>
<span class="line-added">2167       int saved_errno = errno;</span>
<span class="line-added">2168       set_file_error (error,</span>
<span class="line-added">2169                       filename,</span>
<span class="line-added">2170                       _(&quot;Failed to read the symbolic link &#39;%s&#39;: %s&quot;),</span>
<span class="line-added">2171                       saved_errno);</span>
<span class="line-added">2172       return NULL;</span>
<span class="line-added">2173     }</span>
<span class="line-added">2174   else if (read_size == 0)</span>
<span class="line-added">2175     return strdup (&quot;&quot;);</span>
<span class="line-added">2176   else</span>
<span class="line-added">2177     return buffer;</span>
2178 #else
2179   g_return_val_if_fail (filename != NULL, NULL);
2180   g_return_val_if_fail (error == NULL || *error == NULL, NULL);
2181 
2182   g_set_error_literal (error,
2183                        G_FILE_ERROR,
2184                        G_FILE_ERROR_INVAL,
2185                        _(&quot;Symbolic links not supported&quot;));
2186 
2187   return NULL;
2188 #endif
2189 }
2190 
2191 /**
2192  * g_path_is_absolute:
2193  * @file_name: (type filename): a file name
2194  *
2195  * Returns %TRUE if the given @file_name is an absolute file name.
2196  * Note that this is a somewhat vague concept on Windows.
2197  *
</pre>
<hr />
<pre>
2417 }
2418 
2419 /**
2420  * g_dirname:
2421  * @file_name: (type filename): the name of the file
2422  *
2423  * Gets the directory components of a file name.
2424  *
2425  * If the file name has no directory components &quot;.&quot; is returned.
2426  * The returned string should be freed when no longer needed.
2427  *
2428  * Returns: (type filename): the directory components of the file
2429  *
2430  * Deprecated: use g_path_get_dirname() instead
2431  */
2432 
2433 /**
2434  * g_path_get_dirname:
2435  * @file_name: (type filename): the name of the file
2436  *
<span class="line-modified">2437  * Gets the directory components of a file name. For example, the directory</span>
<span class="line-added">2438  * component of `/usr/bin/test` is `/usr/bin`. The directory component of `/`</span>
<span class="line-added">2439  * is `/`.</span>
2440  *
2441  * If the file name has no directory components &quot;.&quot; is returned.
2442  * The returned string should be freed when no longer needed.
2443  *
2444  * Returns: (type filename): the directory components of the file
2445  */
2446 gchar *
2447 g_path_get_dirname (const gchar *file_name)
2448 {
2449   gchar *base;
2450   gsize len;
2451 
2452   g_return_val_if_fail (file_name != NULL, NULL);
2453 
2454   base = strrchr (file_name, G_DIR_SEPARATOR);
2455 
2456 #ifdef G_OS_WIN32
2457   {
2458     gchar *q;
2459     q = strrchr (file_name, &#39;/&#39;);
</pre>
<hr />
<pre>
2769 #ifndef GSTREAMER_LITE
2770 #ifdef G_OS_WIN32
2771 
2772 /* Binary compatibility versions. Not for newly compiled code. */
2773 
2774 _GLIB_EXTERN gboolean g_file_test_utf8         (const gchar  *filename,
2775                                                 GFileTest     test);
2776 _GLIB_EXTERN gboolean g_file_get_contents_utf8 (const gchar  *filename,
2777                                                 gchar       **contents,
2778                                                 gsize        *length,
2779                                                 GError      **error);
2780 _GLIB_EXTERN gint     g_mkstemp_utf8           (gchar        *tmpl);
2781 _GLIB_EXTERN gint     g_file_open_tmp_utf8     (const gchar  *tmpl,
2782                                                 gchar       **name_used,
2783                                                 GError      **error);
2784 _GLIB_EXTERN gchar   *g_get_current_dir_utf8   (void);
2785 
2786 
2787 gboolean
2788 g_file_test_utf8 (const gchar *filename,
<span class="line-modified">2789                   GFileTest    test)</span>
2790 {
2791   return g_file_test (filename, test);
2792 }
2793 
2794 gboolean
2795 g_file_get_contents_utf8 (const gchar  *filename,
<span class="line-modified">2796                           gchar       **contents,</span>
<span class="line-modified">2797                           gsize        *length,</span>
<span class="line-modified">2798                           GError      **error)</span>
2799 {
2800   return g_file_get_contents (filename, contents, length, error);
2801 }
2802 
2803 gint
2804 g_mkstemp_utf8 (gchar *tmpl)
2805 {
2806   return g_mkstemp (tmpl);
2807 }
2808 
2809 gint
2810 g_file_open_tmp_utf8 (const gchar  *tmpl,
<span class="line-modified">2811                       gchar       **name_used,</span>
<span class="line-modified">2812                       GError      **error)</span>
2813 {
2814   return g_file_open_tmp (tmpl, name_used, error);
2815 }
2816 
2817 gchar *
2818 g_get_current_dir_utf8 (void)
2819 {
2820   return g_get_current_dir ();
2821 }
2822 
2823 #endif
2824 #endif // GSTREAMER_LITE
</pre>
</td>
</tr>
</table>
<center><a href="gerror.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gfileutils.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>