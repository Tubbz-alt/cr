diff a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/gstvideoencoder.c b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/gstvideoencoder.c
--- a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/gstvideoencoder.c
+++ b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/gstvideoencoder.c
@@ -109,14 +109,10 @@
 #include <string.h>
 
 GST_DEBUG_CATEGORY (videoencoder_debug);
 #define GST_CAT_DEFAULT videoencoder_debug
 
-#define GST_VIDEO_ENCODER_GET_PRIVATE(obj)  \
-    (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_VIDEO_ENCODER, \
-        GstVideoEncoderPrivate))
-
 /* properties */
 
 #define DEFAULT_QOS                 FALSE
 
 enum
@@ -209,10 +205,12 @@
 
   return evt;
 }
 
 static GstElementClass *parent_class = NULL;
+static gint private_offset = 0;
+
 static void gst_video_encoder_class_init (GstVideoEncoderClass * klass);
 static void gst_video_encoder_init (GstVideoEncoder * enc,
     GstVideoEncoderClass * klass);
 
 static void gst_video_encoder_finalize (GObject * object);
@@ -285,19 +283,27 @@
     };
 #endif // GSTREAMER_LITE
 
     _type = g_type_register_static (GST_TYPE_ELEMENT,
         "GstVideoEncoder", &info, G_TYPE_FLAG_ABSTRACT);
+    private_offset =
+        g_type_add_instance_private (_type, sizeof (GstVideoEncoderPrivate));
 #ifndef GSTREAMER_LITE
     g_type_add_interface_static (_type, GST_TYPE_PRESET,
         &preset_interface_info);
 #endif // GSTREAMER_LITE
     g_once_init_leave (&type, _type);
   }
   return type;
 }
 
+static inline GstVideoEncoderPrivate *
+gst_video_encoder_get_instance_private (GstVideoEncoder * self)
+{
+  return (G_STRUCT_MEMBER_P (self, private_offset));
+}
+
 static void
 gst_video_encoder_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec)
 {
   GstVideoEncoder *sink = GST_VIDEO_ENCODER (object);
@@ -340,11 +346,12 @@
   GST_DEBUG_CATEGORY_INIT (videoencoder_debug, "videoencoder", 0,
       "Base Video Encoder");
 
   parent_class = g_type_class_peek_parent (klass);
 
-  g_type_class_add_private (klass, sizeof (GstVideoEncoderPrivate));
+  if (private_offset != 0)
+    g_type_class_adjust_private_offset (klass, &private_offset);
 
   gobject_class->set_property = gst_video_encoder_set_property;
   gobject_class->get_property = gst_video_encoder_get_property;
   gobject_class->finalize = gst_video_encoder_finalize;
 
@@ -493,11 +500,11 @@
   GstPadTemplate *pad_template;
   GstPad *pad;
 
   GST_DEBUG_OBJECT (encoder, "gst_video_encoder_init");
 
-  priv = encoder->priv = GST_VIDEO_ENCODER_GET_PRIVATE (encoder);
+  priv = encoder->priv = gst_video_encoder_get_instance_private (encoder);
 
   pad_template =
       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (klass), "sink");
   g_return_if_fail (pad_template != NULL);
 
@@ -941,10 +948,13 @@
         break;
       }
 
       if (encoder->priv->time_adjustment != GST_CLOCK_TIME_NONE) {
         segment.start += encoder->priv->time_adjustment;
+        if (GST_CLOCK_TIME_IS_VALID (segment.position)) {
+          segment.position += encoder->priv->time_adjustment;
+        }
         if (GST_CLOCK_TIME_IS_VALID (segment.stop)) {
           segment.stop += encoder->priv->time_adjustment;
         }
       }
 
@@ -2289,11 +2299,13 @@
         GST_LOG_OBJECT (encoder, "marking discont");
         GST_BUFFER_FLAG_SET (tmpbuf, GST_BUFFER_FLAG_DISCONT);
         discont = FALSE;
       }
 
+      GST_VIDEO_ENCODER_STREAM_UNLOCK (encoder);
       gst_pad_push (encoder->srcpad, gst_buffer_ref (tmpbuf));
+      GST_VIDEO_ENCODER_STREAM_LOCK (encoder);
     }
     priv->new_headers = FALSE;
   }
 
   if (G_UNLIKELY (discont)) {
@@ -2327,12 +2339,15 @@
    * to the frame
    */
   gst_video_encoder_release_frame (encoder, frame);
   frame = NULL;
 
-  if (ret == GST_FLOW_OK)
+  if (ret == GST_FLOW_OK) {
+    GST_VIDEO_ENCODER_STREAM_UNLOCK (encoder);
     ret = gst_pad_push (encoder->srcpad, buffer);
+    GST_VIDEO_ENCODER_STREAM_LOCK (encoder);
+  }
 
 done:
   /* handed out */
   if (frame)
     gst_video_encoder_release_frame (encoder, frame);
@@ -2498,11 +2513,11 @@
   return (GstVideoCodecFrame *) frame;
 }
 
 /**
  * gst_video_encoder_get_frame:
- * @encoder: a #GstVideoEnccoder
+ * @encoder: a #GstVideoEncoder
  * @frame_number: system_frame_number of a frame
  *
  * Get a pending unfinished #GstVideoCodecFrame
  *
  * Returns: (transfer full): pending unfinished #GstVideoCodecFrame identified by @frame_number.
@@ -2597,11 +2612,11 @@
  * gst_video_encoder_get_allocator:
  * @encoder: a #GstVideoEncoder
  * @allocator: (out) (allow-none) (transfer full): the #GstAllocator
  * used
  * @params: (out) (allow-none) (transfer full): the
- * #GstAllocatorParams of @allocator
+ * #GstAllocationParams of @allocator
  *
  * Lets #GstVideoEncoder sub-classes to know the memory @allocator
  * used by the base class and its @params.
  *
  * Unref the @allocator after use it.
@@ -2628,11 +2643,11 @@
  * Request minimal value for PTS passed to handle_frame.
  *
  * For streams with reordered frames this can be used to ensure that there
  * is enough time to accomodate first DTS, which may be less than first PTS
  *
- * Since 1.6
+ * Since: 1.6
  */
 void
 gst_video_encoder_set_min_pts (GstVideoEncoder * encoder, GstClockTime min_pts)
 {
   g_return_if_fail (GST_IS_VIDEO_ENCODER (encoder));
