<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/ghash.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ggettext.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ghash.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/ghash.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -29,17 +29,39 @@</span>
  #include &quot;config.h&quot;
  
  #include &lt;string.h&gt;  /* memset */
  
  #include &quot;ghash.h&quot;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+ #include &quot;gmacros.h&quot;</span>
  #include &quot;glib-private.h&quot;
  #include &quot;gstrfuncs.h&quot;
  #include &quot;gatomic.h&quot;
  #include &quot;gtestutils.h&quot;
  #include &quot;gslice.h&quot;
  #include &quot;grefcount.h&quot;
<span class="udiff-line-added">+ #include &quot;gvalgrind.h&quot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /* The following #pragma is here so we can do this...</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  *   #ifndef USE_SMALL_ARRAYS</span>
<span class="udiff-line-added">+  *     is_big = TRUE;</span>
<span class="udiff-line-added">+  *   #endif</span>
<span class="udiff-line-added">+  *     return is_big ? *(((gpointer *) a) + index) : GUINT_TO_POINTER (*(((guint *) a) + index));</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * ...instead of this...</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  *   #ifndef USE_SMALL_ARRAYS</span>
<span class="udiff-line-added">+  *     return *(((gpointer *) a) + index);</span>
<span class="udiff-line-added">+  *   #else</span>
<span class="udiff-line-added">+  *     return is_big ? *(((gpointer *) a) + index) : GUINT_TO_POINTER (*(((guint *) a) + index));</span>
<span class="udiff-line-added">+  *   #endif</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * ...and still compile successfully when -Werror=duplicated-branches is passed. */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if defined(__GNUC__) &amp;&amp; __GNUC__ &gt; 6</span>
<span class="udiff-line-added">+ #pragma GCC diagnostic ignored &quot;-Wduplicated-branches&quot;</span>
<span class="udiff-line-added">+ #endif</span>
  
  /**
   * SECTION:hash_tables
   * @title: Hash Tables
   * @short_description: associations between keys and values so that
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -65,20 +87,20 @@</span>
   * To create a #GHashTable, use g_hash_table_new().
   *
   * To insert a key and value into a #GHashTable, use
   * g_hash_table_insert().
   *
<span class="udiff-line-modified-removed">-  * To lookup a value corresponding to a given key, use</span>
<span class="udiff-line-modified-added">+  * To look up a value corresponding to a given key, use</span>
   * g_hash_table_lookup() and g_hash_table_lookup_extended().
   *
   * g_hash_table_lookup_extended() can also be used to simply
   * check if a key is present in the hash table.
   *
   * To remove a key and value, use g_hash_table_remove().
   *
   * To call a function for each key and value pair use
<span class="udiff-line-modified-removed">-  * g_hash_table_foreach() or use a iterator to iterate over the</span>
<span class="udiff-line-modified-added">+  * g_hash_table_foreach() or use an iterator to iterate over the</span>
   * key/value pairs in the hash table, see #GHashTableIter.
   *
   * To destroy a #GHashTable use g_hash_table_destroy().
   *
   * A common use-case for hash tables is to store information about a
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -211,21 +233,36 @@</span>
  #define TOMBSTONE_HASH_VALUE 1
  #define HASH_IS_UNUSED(h_) ((h_) == UNUSED_HASH_VALUE)
  #define HASH_IS_TOMBSTONE(h_) ((h_) == TOMBSTONE_HASH_VALUE)
  #define HASH_IS_REAL(h_) ((h_) &gt;= 2)
  
<span class="udiff-line-added">+ /* If int is smaller than void * on our arch, we start out with</span>
<span class="udiff-line-added">+  * int-sized keys and values and resize to pointer-sized entries as</span>
<span class="udiff-line-added">+  * needed. This saves a good amount of memory when the HT is being</span>
<span class="udiff-line-added">+  * used with e.g. GUINT_TO_POINTER(). */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define BIG_ENTRY_SIZE (SIZEOF_VOID_P)</span>
<span class="udiff-line-added">+ #define SMALL_ENTRY_SIZE (SIZEOF_INT)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if SMALL_ENTRY_SIZE &lt; BIG_ENTRY_SIZE</span>
<span class="udiff-line-added">+ # define USE_SMALL_ARRAYS</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  struct _GHashTable
  {
<span class="udiff-line-modified-removed">-   gint             size;</span>
<span class="udiff-line-modified-added">+   gsize            size;</span>
    gint             mod;
    guint            mask;
    gint             nnodes;
    gint             noccupied;  /* nnodes + tombstones */
  
<span class="udiff-line-modified-removed">-   gpointer        *keys;</span>
<span class="udiff-line-modified-added">+   guint            have_big_keys : 1;</span>
<span class="udiff-line-added">+   guint            have_big_values : 1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   gpointer         keys;</span>
    guint           *hashes;
<span class="udiff-line-modified-removed">-   gpointer        *values;</span>
<span class="udiff-line-modified-added">+   gpointer         values;</span>
  
    GHashFunc        hash_func;
    GEqualFunc       key_equal_func;
    gatomicrefcount  ref_count;
  #ifndef G_DISABLE_ASSERT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -243,17 +280,17 @@</span>
  typedef struct
  {
    GHashTable  *hash_table;
    gpointer     dummy1;
    gpointer     dummy2;
<span class="udiff-line-modified-removed">-   int          position;</span>
<span class="udiff-line-modified-added">+   gint         position;</span>
    gboolean     dummy3;
<span class="udiff-line-modified-removed">-   int          version;</span>
<span class="udiff-line-modified-added">+   gint         version;</span>
  } RealIter;
  
  G_STATIC_ASSERT (sizeof (GHashTableIter) == sizeof (RealIter));
<span class="udiff-line-modified-removed">- G_STATIC_ASSERT (_g_alignof (GHashTableIter) &gt;= _g_alignof (RealIter));</span>
<span class="udiff-line-modified-added">+ G_STATIC_ASSERT (G_ALIGNOF (GHashTableIter) &gt;= G_ALIGNOF (RealIter));</span>
  
  /* Each table size has an associated prime modulo (the first prime
   * lower than the table size) used to find the initial bucket. Probing
   * then works modulo 2^n. The prime modulo is necessary to get a
   * good distribution with poor hash functions.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -295,23 +332,19 @@</span>
  };
  
  static void
  g_hash_table_set_shift (GHashTable *hash_table, gint shift)
  {
<span class="udiff-line-removed">-   gint i;</span>
<span class="udiff-line-removed">-   guint mask = 0;</span>
<span class="udiff-line-removed">- </span>
    hash_table-&gt;size = 1 &lt;&lt; shift;
    hash_table-&gt;mod  = prime_mod [shift];
  
<span class="udiff-line-modified-removed">-   for (i = 0; i &lt; shift; i++)</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       mask &lt;&lt;= 1;</span>
<span class="udiff-line-removed">-       mask |= 1;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   /* hash_table-&gt;size is always a power of two, so we can calculate the mask</span>
<span class="udiff-line-modified-added">+    * by simply subtracting 1 from it. The leading assertion ensures that</span>
<span class="udiff-line-modified-added">+    * we&#39;re really dealing with a power of two. */</span>
  
<span class="udiff-line-modified-removed">-   hash_table-&gt;mask = mask;</span>
<span class="udiff-line-modified-added">+   g_assert ((hash_table-&gt;size &amp; (hash_table-&gt;size - 1)) == 0);</span>
<span class="udiff-line-added">+   hash_table-&gt;mask = hash_table-&gt;size - 1;</span>
  }
  
  static gint
  g_hash_table_find_closest_shift (gint n)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -332,14 +365,75 @@</span>
    shift = MAX (shift, HASH_TABLE_MIN_SHIFT);
  
    g_hash_table_set_shift (hash_table, shift);
  }
  
<span class="udiff-line-added">+ static inline gpointer</span>
<span class="udiff-line-added">+ g_hash_table_realloc_key_or_value_array (gpointer a, guint size, G_GNUC_UNUSED gboolean is_big)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+ #ifdef USE_SMALL_ARRAYS</span>
<span class="udiff-line-added">+   return g_realloc (a, size * (is_big ? BIG_ENTRY_SIZE : SMALL_ENTRY_SIZE));</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+   return g_renew (gpointer, a, size);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static inline gpointer</span>
<span class="udiff-line-added">+ g_hash_table_fetch_key_or_value (gpointer a, guint index, gboolean is_big)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+ #ifndef USE_SMALL_ARRAYS</span>
<span class="udiff-line-added">+   is_big = TRUE;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   return is_big ? *(((gpointer *) a) + index) : GUINT_TO_POINTER (*(((guint *) a) + index));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static inline void</span>
<span class="udiff-line-added">+ g_hash_table_assign_key_or_value (gpointer a, guint index, gboolean is_big, gpointer v)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+ #ifndef USE_SMALL_ARRAYS</span>
<span class="udiff-line-added">+   is_big = TRUE;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   if (is_big)</span>
<span class="udiff-line-added">+     *(((gpointer *) a) + index) = v;</span>
<span class="udiff-line-added">+   else</span>
<span class="udiff-line-added">+     *(((guint *) a) + index) = GPOINTER_TO_UINT (v);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static inline gpointer</span>
<span class="udiff-line-added">+ g_hash_table_evict_key_or_value (gpointer a, guint index, gboolean is_big, gpointer v)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+ #ifndef USE_SMALL_ARRAYS</span>
<span class="udiff-line-added">+   is_big = TRUE;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   if (is_big)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       gpointer r = *(((gpointer *) a) + index);</span>
<span class="udiff-line-added">+       *(((gpointer *) a) + index) = v;</span>
<span class="udiff-line-added">+       return r;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   else</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       gpointer r = GUINT_TO_POINTER (*(((guint *) a) + index));</span>
<span class="udiff-line-added">+       *(((guint *) a) + index) = GPOINTER_TO_UINT (v);</span>
<span class="udiff-line-added">+       return r;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static inline guint</span>
<span class="udiff-line-added">+ g_hash_table_hash_to_index (GHashTable *hash_table, guint hash)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   /* Multiply the hash by a small prime before applying the modulo. This</span>
<span class="udiff-line-added">+    * prevents the table from becoming densely packed, even with a poor hash</span>
<span class="udiff-line-added">+    * function. A densely packed table would have poor performance on</span>
<span class="udiff-line-added">+    * workloads with many failed lookups or a high degree of churn. */</span>
<span class="udiff-line-added">+   return (hash * 11) % hash_table-&gt;mod;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /*
   * g_hash_table_lookup_node:
   * @hash_table: our #GHashTable
<span class="udiff-line-modified-removed">-  * @key: the key to lookup against</span>
<span class="udiff-line-modified-added">+  * @key: the key to look up against</span>
   * @hash_return: key hash return location
   *
   * Performs a lookup in the hash table, preserving extra information
   * usually needed for insertion.
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -380,22 +474,22 @@</span>
    if (G_UNLIKELY (!HASH_IS_REAL (hash_value)))
      hash_value = 2;
  
    *hash_return = hash_value;
  
<span class="udiff-line-modified-removed">-   node_index = hash_value % hash_table-&gt;mod;</span>
<span class="udiff-line-modified-added">+   node_index = g_hash_table_hash_to_index (hash_table, hash_value);</span>
    node_hash = hash_table-&gt;hashes[node_index];
  
    while (!HASH_IS_UNUSED (node_hash))
      {
        /* We first check if our full hash values
         * are equal so we can avoid calling the full-blown
         * key equality function in most cases.
         */
        if (node_hash == hash_value)
          {
<span class="udiff-line-modified-removed">-           gpointer node_key = hash_table-&gt;keys[node_index];</span>
<span class="udiff-line-modified-added">+           gpointer node_key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys);</span>
  
            if (hash_table-&gt;key_equal_func)
              {
                if (hash_table-&gt;key_equal_func (node_key, key))
                  return node_index;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -441,19 +535,19 @@</span>
                            gboolean      notify)
  {
    gpointer key;
    gpointer value;
  
<span class="udiff-line-modified-removed">-   key = hash_table-&gt;keys[i];</span>
<span class="udiff-line-modified-removed">-   value = hash_table-&gt;values[i];</span>
<span class="udiff-line-modified-added">+   key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys);</span>
<span class="udiff-line-modified-added">+   value = g_hash_table_fetch_key_or_value (hash_table-&gt;values, i, hash_table-&gt;have_big_values);</span>
  
    /* Erect tombstone */
    hash_table-&gt;hashes[i] = TOMBSTONE_HASH_VALUE;
  
    /* Be GC friendly */
<span class="udiff-line-modified-removed">-   hash_table-&gt;keys[i] = NULL;</span>
<span class="udiff-line-modified-removed">-   hash_table-&gt;values[i] = NULL;</span>
<span class="udiff-line-modified-added">+   g_hash_table_assign_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys, NULL);</span>
<span class="udiff-line-modified-added">+   g_hash_table_assign_key_or_value (hash_table-&gt;values, i, hash_table-&gt;have_big_values, NULL);</span>
  
    hash_table-&gt;nnodes--;
  
    if (notify &amp;&amp; hash_table-&gt;key_destroy_func)
      hash_table-&gt;key_destroy_func (key);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -461,20 +555,63 @@</span>
    if (notify &amp;&amp; hash_table-&gt;value_destroy_func)
      hash_table-&gt;value_destroy_func (value);
  
  }
  
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+  * g_hash_table_setup_storage:</span>
<span class="udiff-line-added">+  * @hash_table: our #GHashTable</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Initialise the hash table size, mask, mod, and arrays.</span>
<span class="udiff-line-added">+  */</span>
<span class="udiff-line-added">+ static void</span>
<span class="udiff-line-added">+ g_hash_table_setup_storage (GHashTable *hash_table)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   gboolean small;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   /* We want to use small arrays only if:</span>
<span class="udiff-line-added">+    *   - we are running on a system where that makes sense (64 bit); and</span>
<span class="udiff-line-added">+    *   - we are not running under valgrind.</span>
<span class="udiff-line-added">+    */</span>
<span class="udiff-line-added">+   small = FALSE;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef USE_SMALL_ARRAYS</span>
<span class="udiff-line-added">+   small = TRUE;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ # ifdef ENABLE_VALGRIND</span>
<span class="udiff-line-added">+   if (RUNNING_ON_VALGRIND)</span>
<span class="udiff-line-added">+     small = FALSE;</span>
<span class="udiff-line-added">+ # endif</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   g_hash_table_set_shift (hash_table, HASH_TABLE_MIN_SHIFT);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   hash_table-&gt;have_big_keys = !small;</span>
<span class="udiff-line-added">+   hash_table-&gt;have_big_values = !small;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   hash_table-&gt;keys   = g_hash_table_realloc_key_or_value_array (NULL, hash_table-&gt;size, hash_table-&gt;have_big_keys);</span>
<span class="udiff-line-added">+   hash_table-&gt;values = hash_table-&gt;keys;</span>
<span class="udiff-line-added">+   hash_table-&gt;hashes = g_new0 (guint, hash_table-&gt;size);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /*
   * g_hash_table_remove_all_nodes:
   * @hash_table: our #GHashTable
   * @notify: %TRUE if the destroy notify handlers are to be called
   *
<span class="udiff-line-modified-removed">-  * Removes all nodes from the table.  Since this may be a precursor to</span>
<span class="udiff-line-removed">-  * freeing the table entirely, no resize is performed.</span>
<span class="udiff-line-modified-added">+  * Removes all nodes from the table.</span>
   *
   * If @notify is %TRUE then the destroy notify functions are called
   * for the key and value of the hash node.
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Since this may be a precursor to freeing the table entirely, we&#39;d</span>
<span class="udiff-line-added">+  * ideally perform no resize, and we can indeed avoid that in some</span>
<span class="udiff-line-added">+  * cases.  However: in the case that we&#39;ll be making callbacks to user</span>
<span class="udiff-line-added">+  * code (via destroy notifies) we need to consider that the user code</span>
<span class="udiff-line-added">+  * might call back into the table again.  In this case, we setup a new</span>
<span class="udiff-line-added">+  * set of arrays so that any callers will see an empty (but valid)</span>
<span class="udiff-line-added">+  * table.</span>
   */
  static void
  g_hash_table_remove_all_nodes (GHashTable *hash_table,
                                 gboolean    notify,
                                 gboolean    destruction)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -484,84 +621,222 @@</span>
    gpointer value;
    gint old_size;
    gpointer *old_keys;
    gpointer *old_values;
    guint    *old_hashes;
<span class="udiff-line-added">+   gboolean  old_have_big_keys;</span>
<span class="udiff-line-added">+   gboolean  old_have_big_values;</span>
  
    /* If the hash table is already empty, there is nothing to be done. */
    if (hash_table-&gt;nnodes == 0)
      return;
  
    hash_table-&gt;nnodes = 0;
    hash_table-&gt;noccupied = 0;
  
<span class="udiff-line-added">+   /* Easy case: no callbacks, so we just zero out the arrays */</span>
    if (!notify ||
        (hash_table-&gt;key_destroy_func == NULL &amp;&amp;
         hash_table-&gt;value_destroy_func == NULL))
      {
        if (!destruction)
          {
<span class="udiff-line-modified-removed">-       memset (hash_table-&gt;hashes, 0, hash_table-&gt;size * sizeof (guint));</span>
<span class="udiff-line-modified-removed">-       memset (hash_table-&gt;keys, 0, hash_table-&gt;size * sizeof (gpointer));</span>
<span class="udiff-line-modified-removed">-       memset (hash_table-&gt;values, 0, hash_table-&gt;size * sizeof (gpointer));</span>
<span class="udiff-line-modified-added">+           memset (hash_table-&gt;hashes, 0, hash_table-&gt;size * sizeof (guint));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ #ifdef USE_SMALL_ARRAYS</span>
<span class="udiff-line-added">+           memset (hash_table-&gt;keys, 0, hash_table-&gt;size * (hash_table-&gt;have_big_keys ? BIG_ENTRY_SIZE : SMALL_ENTRY_SIZE));</span>
<span class="udiff-line-added">+           memset (hash_table-&gt;values, 0, hash_table-&gt;size * (hash_table-&gt;have_big_values ? BIG_ENTRY_SIZE : SMALL_ENTRY_SIZE));</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+           memset (hash_table-&gt;keys, 0, hash_table-&gt;size * sizeof (gpointer));</span>
<span class="udiff-line-added">+           memset (hash_table-&gt;values, 0, hash_table-&gt;size * sizeof (gpointer));</span>
<span class="udiff-line-added">+ #endif</span>
          }
  
        return;
      }
  
<span class="udiff-line-modified-removed">-   /* Keep the old storage space around to iterate over it. */</span>
<span class="udiff-line-modified-added">+   /* Hard case: we need to do user callbacks.  There are two</span>
<span class="udiff-line-added">+    * possibilities here:</span>
<span class="udiff-line-added">+    *</span>
<span class="udiff-line-added">+    *   1) there are no outstanding references on the table and therefore</span>
<span class="udiff-line-added">+    *   nobody should be calling into it again (destroying == true)</span>
<span class="udiff-line-added">+    *</span>
<span class="udiff-line-added">+    *   2) there are outstanding references, and there may be future</span>
<span class="udiff-line-added">+    *   calls into the table, either after we return, or from the destroy</span>
<span class="udiff-line-added">+    *   notifies that we&#39;re about to do (destroying == false)</span>
<span class="udiff-line-added">+    *</span>
<span class="udiff-line-added">+    * We handle both cases by taking the current state of the table into</span>
<span class="udiff-line-added">+    * local variables and replacing it with something else: in the &quot;no</span>
<span class="udiff-line-added">+    * outstanding references&quot; cases we replace it with a bunch of</span>
<span class="udiff-line-added">+    * null/zero values so that any access to the table will fail.  In the</span>
<span class="udiff-line-added">+    * &quot;may receive future calls&quot; case, we reinitialise the struct to</span>
<span class="udiff-line-added">+    * appear like a newly-created empty table.</span>
<span class="udiff-line-added">+    *</span>
<span class="udiff-line-added">+    * In both cases, we take over the references for the current state,</span>
<span class="udiff-line-added">+    * freeing them below.</span>
<span class="udiff-line-added">+    */</span>
    old_size = hash_table-&gt;size;
<span class="udiff-line-modified-removed">-   old_keys   = hash_table-&gt;keys;</span>
<span class="udiff-line-modified-removed">-   old_values = hash_table-&gt;values;</span>
<span class="udiff-line-modified-removed">-   old_hashes = hash_table-&gt;hashes;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   /* Now create a new storage space; If the table is destroyed we can use the</span>
<span class="udiff-line-modified-removed">-    * shortcut of not creating a new storage. This saves the allocation at the</span>
<span class="udiff-line-removed">-    * cost of not allowing any recursive access.</span>
<span class="udiff-line-removed">-    * However, the application doesn&#39;t own any reference anymore, so access</span>
<span class="udiff-line-removed">-    * is not allowed. If accesses are done, then either an assert or crash</span>
<span class="udiff-line-removed">-    * *will* happen. */</span>
<span class="udiff-line-removed">-   g_hash_table_set_shift (hash_table, HASH_TABLE_MIN_SHIFT);</span>
<span class="udiff-line-modified-added">+   old_have_big_keys = hash_table-&gt;have_big_keys;</span>
<span class="udiff-line-modified-added">+   old_have_big_values = hash_table-&gt;have_big_values;</span>
<span class="udiff-line-modified-added">+   old_keys   = g_steal_pointer (&amp;hash_table-&gt;keys);</span>
<span class="udiff-line-modified-added">+   old_values = g_steal_pointer (&amp;hash_table-&gt;values);</span>
<span class="udiff-line-modified-added">+   old_hashes = g_steal_pointer (&amp;hash_table-&gt;hashes);</span>
<span class="udiff-line-modified-added">+ </span>
    if (!destruction)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       hash_table-&gt;keys   = g_new0 (gpointer, hash_table-&gt;size);</span>
<span class="udiff-line-removed">-       hash_table-&gt;values = hash_table-&gt;keys;</span>
<span class="udiff-line-removed">-       hash_table-&gt;hashes = g_new0 (guint, hash_table-&gt;size);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     /* Any accesses will see an empty table */</span>
<span class="udiff-line-modified-added">+     g_hash_table_setup_storage (hash_table);</span>
    else
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-       hash_table-&gt;keys   = NULL;</span>
<span class="udiff-line-removed">-       hash_table-&gt;values = NULL;</span>
<span class="udiff-line-removed">-       hash_table-&gt;hashes = NULL;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     /* Will cause a quick crash on any attempted access */</span>
<span class="udiff-line-modified-added">+     hash_table-&gt;size = hash_table-&gt;mod = hash_table-&gt;mask = 0;</span>
  
<span class="udiff-line-added">+   /* Now do the actual destroy notifies */</span>
    for (i = 0; i &lt; old_size; i++)
      {
        if (HASH_IS_REAL (old_hashes[i]))
          {
<span class="udiff-line-modified-removed">-           key = old_keys[i];</span>
<span class="udiff-line-modified-removed">-           value = old_values[i];</span>
<span class="udiff-line-modified-added">+           key = g_hash_table_fetch_key_or_value (old_keys, i, old_have_big_keys);</span>
<span class="udiff-line-modified-added">+           value = g_hash_table_fetch_key_or_value (old_values, i, old_have_big_values);</span>
  
            old_hashes[i] = UNUSED_HASH_VALUE;
<span class="udiff-line-modified-removed">-           old_keys[i] = NULL;</span>
<span class="udiff-line-modified-removed">-           old_values[i] = NULL;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+           g_hash_table_assign_key_or_value (old_keys, i, old_have_big_keys, NULL);</span>
<span class="udiff-line-added">+           g_hash_table_assign_key_or_value (old_values, i, old_have_big_values, NULL);</span>
  
            if (hash_table-&gt;key_destroy_func != NULL)
              hash_table-&gt;key_destroy_func (key);
  
            if (hash_table-&gt;value_destroy_func != NULL)
              hash_table-&gt;value_destroy_func (value);
          }
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+     }</span>
  
    /* Destroy old storage space. */
    if (old_keys != old_values)
      g_free (old_values);
  
    g_free (old_keys);
    g_free (old_hashes);
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static void</span>
<span class="udiff-line-added">+ realloc_arrays (GHashTable *hash_table, gboolean is_a_set)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   hash_table-&gt;hashes = g_renew (guint, hash_table-&gt;hashes, hash_table-&gt;size);</span>
<span class="udiff-line-added">+   hash_table-&gt;keys = g_hash_table_realloc_key_or_value_array (hash_table-&gt;keys, hash_table-&gt;size, hash_table-&gt;have_big_keys);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (is_a_set)</span>
<span class="udiff-line-added">+     hash_table-&gt;values = hash_table-&gt;keys;</span>
<span class="udiff-line-added">+   else</span>
<span class="udiff-line-added">+     hash_table-&gt;values = g_hash_table_realloc_key_or_value_array (hash_table-&gt;values, hash_table-&gt;size, hash_table-&gt;have_big_values);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /* When resizing the table in place, we use a temporary bit array to keep</span>
<span class="udiff-line-added">+  * track of which entries have been assigned a proper location in the new</span>
<span class="udiff-line-added">+  * table layout.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Each bit corresponds to a bucket. A bit is set if an entry was assigned</span>
<span class="udiff-line-added">+  * its corresponding location during the resize and thus should not be</span>
<span class="udiff-line-added">+  * evicted. The array starts out cleared to zero. */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static inline gboolean</span>
<span class="udiff-line-added">+ get_status_bit (const guint32 *bitmap, guint index)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   return (bitmap[index / 32] &gt;&gt; (index % 32)) &amp; 1;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static inline void</span>
<span class="udiff-line-added">+ set_status_bit (guint32 *bitmap, guint index)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   bitmap[index / 32] |= 1U &lt;&lt; (index % 32);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /* By calling dedicated resize functions for sets and maps, we avoid 2x</span>
<span class="udiff-line-added">+  * test-and-branch per key in the inner loop. This yields a small</span>
<span class="udiff-line-added">+  * performance improvement at the cost of a bit of macro gunk. */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define DEFINE_RESIZE_FUNC(fname) \</span>
<span class="udiff-line-added">+ static void fname (GHashTable *hash_table, guint old_size, guint32 *reallocated_buckets_bitmap) \</span>
<span class="udiff-line-added">+ {                                                                       \</span>
<span class="udiff-line-added">+   guint i;                                                              \</span>
<span class="udiff-line-added">+                                                                         \</span>
<span class="udiff-line-added">+   for (i = 0; i &lt; old_size; i++)                                        \</span>
<span class="udiff-line-added">+     {                                                                   \</span>
<span class="udiff-line-added">+       guint node_hash = hash_table-&gt;hashes[i];                          \</span>
<span class="udiff-line-added">+       gpointer key, value G_GNUC_UNUSED;                                \</span>
<span class="udiff-line-added">+                                                                         \</span>
<span class="udiff-line-added">+       if (!HASH_IS_REAL (node_hash))                                    \</span>
<span class="udiff-line-added">+         {                                                               \</span>
<span class="udiff-line-added">+           /* Clear tombstones */                                        \</span>
<span class="udiff-line-added">+           hash_table-&gt;hashes[i] = UNUSED_HASH_VALUE;                    \</span>
<span class="udiff-line-added">+           continue;                                                     \</span>
<span class="udiff-line-added">+         }                                                               \</span>
<span class="udiff-line-added">+                                                                         \</span>
<span class="udiff-line-added">+       /* Skip entries relocated through eviction */                     \</span>
<span class="udiff-line-added">+       if (get_status_bit (reallocated_buckets_bitmap, i))               \</span>
<span class="udiff-line-added">+         continue;                                                       \</span>
<span class="udiff-line-added">+                                                                         \</span>
<span class="udiff-line-added">+       hash_table-&gt;hashes[i] = UNUSED_HASH_VALUE;                        \</span>
<span class="udiff-line-added">+       EVICT_KEYVAL (hash_table, i, NULL, NULL, key, value);             \</span>
<span class="udiff-line-added">+                                                                         \</span>
<span class="udiff-line-added">+       for (;;)                                                          \</span>
<span class="udiff-line-added">+         {                                                               \</span>
<span class="udiff-line-added">+           guint hash_val;                                               \</span>
<span class="udiff-line-added">+           guint replaced_hash;                                          \</span>
<span class="udiff-line-added">+           guint step = 0;                                               \</span>
<span class="udiff-line-added">+                                                                         \</span>
<span class="udiff-line-added">+           hash_val = g_hash_table_hash_to_index (hash_table, node_hash); \</span>
<span class="udiff-line-added">+                                                                         \</span>
<span class="udiff-line-added">+           while (get_status_bit (reallocated_buckets_bitmap, hash_val)) \</span>
<span class="udiff-line-added">+             {                                                           \</span>
<span class="udiff-line-added">+               step++;                                                   \</span>
<span class="udiff-line-added">+               hash_val += step;                                         \</span>
<span class="udiff-line-added">+               hash_val &amp;= hash_table-&gt;mask;                             \</span>
<span class="udiff-line-added">+             }                                                           \</span>
<span class="udiff-line-added">+                                                                         \</span>
<span class="udiff-line-added">+           set_status_bit (reallocated_buckets_bitmap, hash_val);        \</span>
<span class="udiff-line-added">+                                                                         \</span>
<span class="udiff-line-added">+           replaced_hash = hash_table-&gt;hashes[hash_val];                 \</span>
<span class="udiff-line-added">+           hash_table-&gt;hashes[hash_val] = node_hash;                     \</span>
<span class="udiff-line-added">+           if (!HASH_IS_REAL (replaced_hash))                            \</span>
<span class="udiff-line-added">+             {                                                           \</span>
<span class="udiff-line-added">+               ASSIGN_KEYVAL (hash_table, hash_val, key, value);         \</span>
<span class="udiff-line-added">+               break;                                                    \</span>
<span class="udiff-line-added">+             }                                                           \</span>
<span class="udiff-line-added">+                                                                         \</span>
<span class="udiff-line-added">+           node_hash = replaced_hash;                                    \</span>
<span class="udiff-line-added">+           EVICT_KEYVAL (hash_table, hash_val, key, value, key, value);  \</span>
<span class="udiff-line-added">+         }                                                               \</span>
<span class="udiff-line-added">+     }                                                                   \</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define ASSIGN_KEYVAL(ht, index, key, value) G_STMT_START{ \</span>
<span class="udiff-line-added">+     g_hash_table_assign_key_or_value ((ht)-&gt;keys, (index), (ht)-&gt;have_big_keys, (key)); \</span>
<span class="udiff-line-added">+     g_hash_table_assign_key_or_value ((ht)-&gt;values, (index), (ht)-&gt;have_big_values, (value)); \</span>
<span class="udiff-line-added">+   }G_STMT_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define EVICT_KEYVAL(ht, index, key, value, outkey, outvalue) G_STMT_START{ \</span>
<span class="udiff-line-added">+     (outkey) = g_hash_table_evict_key_or_value ((ht)-&gt;keys, (index), (ht)-&gt;have_big_keys, (key)); \</span>
<span class="udiff-line-added">+     (outvalue) = g_hash_table_evict_key_or_value ((ht)-&gt;values, (index), (ht)-&gt;have_big_values, (value)); \</span>
<span class="udiff-line-added">+   }G_STMT_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ DEFINE_RESIZE_FUNC (resize_map)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #undef ASSIGN_KEYVAL</span>
<span class="udiff-line-added">+ #undef EVICT_KEYVAL</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define ASSIGN_KEYVAL(ht, index, key, value) G_STMT_START{ \</span>
<span class="udiff-line-added">+     g_hash_table_assign_key_or_value ((ht)-&gt;keys, (index), (ht)-&gt;have_big_keys, (key)); \</span>
<span class="udiff-line-added">+   }G_STMT_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define EVICT_KEYVAL(ht, index, key, value, outkey, outvalue) G_STMT_START{ \</span>
<span class="udiff-line-added">+     (outkey) = g_hash_table_evict_key_or_value ((ht)-&gt;keys, (index), (ht)-&gt;have_big_keys, (key)); \</span>
<span class="udiff-line-added">+   }G_STMT_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ DEFINE_RESIZE_FUNC (resize_set)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #undef ASSIGN_KEYVAL</span>
<span class="udiff-line-added">+ #undef EVICT_KEYVAL</span>
  
  /*
   * g_hash_table_resize:
   * @hash_table: our #GHashTable
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -575,58 +850,51 @@</span>
   * the probe sequences.
   */
  static void
  g_hash_table_resize (GHashTable *hash_table)
  {
<span class="udiff-line-modified-removed">-   gpointer *new_keys;</span>
<span class="udiff-line-modified-removed">-   gpointer *new_values;</span>
<span class="udiff-line-modified-removed">-   guint *new_hashes;</span>
<span class="udiff-line-removed">-   gint old_size;</span>
<span class="udiff-line-removed">-   gint i;</span>
<span class="udiff-line-modified-added">+   guint32 *reallocated_buckets_bitmap;</span>
<span class="udiff-line-modified-added">+   gsize old_size;</span>
<span class="udiff-line-modified-added">+   gboolean is_a_set;</span>
  
    old_size = hash_table-&gt;size;
<span class="udiff-line-modified-removed">-   g_hash_table_set_shift_from_size (hash_table, hash_table-&gt;nnodes * 2);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   new_keys = g_new0 (gpointer, hash_table-&gt;size);</span>
<span class="udiff-line-removed">-   if (hash_table-&gt;keys == hash_table-&gt;values)</span>
<span class="udiff-line-removed">-     new_values = new_keys;</span>
<span class="udiff-line-removed">-   else</span>
<span class="udiff-line-removed">-     new_values = g_new0 (gpointer, hash_table-&gt;size);</span>
<span class="udiff-line-removed">-   new_hashes = g_new0 (guint, hash_table-&gt;size);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   for (i = 0; i &lt; old_size; i++)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       guint node_hash = hash_table-&gt;hashes[i];</span>
<span class="udiff-line-removed">-       guint hash_val;</span>
<span class="udiff-line-removed">-       guint step = 0;</span>
<span class="udiff-line-modified-added">+   is_a_set = hash_table-&gt;keys == hash_table-&gt;values;</span>
  
<span class="udiff-line-modified-removed">-       if (!HASH_IS_REAL (node_hash))</span>
<span class="udiff-line-modified-removed">-         continue;</span>
<span class="udiff-line-modified-added">+   /* The outer checks in g_hash_table_maybe_resize() will only consider</span>
<span class="udiff-line-modified-added">+    * cleanup/resize when the load factor goes below .25 (1/4, ignoring</span>
<span class="udiff-line-added">+    * tombstones) or above .9375 (15/16, including tombstones).</span>
<span class="udiff-line-added">+    *</span>
<span class="udiff-line-added">+    * Once this happens, tombstones will always be cleaned out. If our</span>
<span class="udiff-line-added">+    * load sans tombstones is greater than .75 (1/1.333, see below), we&#39;ll</span>
<span class="udiff-line-added">+    * take this opportunity to grow the table too.</span>
<span class="udiff-line-added">+    *</span>
<span class="udiff-line-added">+    * Immediately after growing, the load factor will be in the range</span>
<span class="udiff-line-added">+    * .375 .. .469. After shrinking, it will be exactly .5. */</span>
  
<span class="udiff-line-modified-removed">-       hash_val = node_hash % hash_table-&gt;mod;</span>
<span class="udiff-line-modified-added">+   g_hash_table_set_shift_from_size (hash_table, hash_table-&gt;nnodes * 1.333);</span>
  
<span class="udiff-line-modified-removed">-       while (!HASH_IS_UNUSED (new_hashes[hash_val]))</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           step++;</span>
<span class="udiff-line-modified-removed">-           hash_val += step;</span>
<span class="udiff-line-removed">-           hash_val &amp;= hash_table-&gt;mask;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+   if (hash_table-&gt;size &gt; old_size)</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       realloc_arrays (hash_table, is_a_set);</span>
<span class="udiff-line-modified-added">+       memset (&amp;hash_table-&gt;hashes[old_size], 0, (hash_table-&gt;size - old_size) * sizeof (guint));</span>
  
<span class="udiff-line-modified-removed">-       new_hashes[hash_val] = hash_table-&gt;hashes[i];</span>
<span class="udiff-line-modified-removed">-       new_keys[hash_val] = hash_table-&gt;keys[i];</span>
<span class="udiff-line-modified-removed">-       new_values[hash_val] = hash_table-&gt;values[i];</span>
<span class="udiff-line-modified-added">+       reallocated_buckets_bitmap = g_new0 (guint32, (hash_table-&gt;size + 31) / 32);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+   else</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       reallocated_buckets_bitmap = g_new0 (guint32, (old_size + 31) / 32);</span>
      }
  
<span class="udiff-line-modified-removed">-   if (hash_table-&gt;keys != hash_table-&gt;values)</span>
<span class="udiff-line-modified-removed">-     g_free (hash_table-&gt;values);</span>
<span class="udiff-line-modified-added">+   if (is_a_set)</span>
<span class="udiff-line-modified-added">+     resize_set (hash_table, old_size, reallocated_buckets_bitmap);</span>
<span class="udiff-line-added">+   else</span>
<span class="udiff-line-added">+     resize_map (hash_table, old_size, reallocated_buckets_bitmap);</span>
  
<span class="udiff-line-modified-removed">-   g_free (hash_table-&gt;keys);</span>
<span class="udiff-line-removed">-   g_free (hash_table-&gt;hashes);</span>
<span class="udiff-line-modified-added">+   g_free (reallocated_buckets_bitmap);</span>
  
<span class="udiff-line-modified-removed">-   hash_table-&gt;keys = new_keys;</span>
<span class="udiff-line-modified-removed">-   hash_table-&gt;values = new_values;</span>
<span class="udiff-line-removed">-   hash_table-&gt;hashes = new_hashes;</span>
<span class="udiff-line-modified-added">+   if (hash_table-&gt;size &lt; old_size)</span>
<span class="udiff-line-modified-added">+     realloc_arrays (hash_table, is_a_set);</span>
  
    hash_table-&gt;noccupied = hash_table-&gt;nnodes;
  }
  
  /*
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -647,10 +915,98 @@</span>
    if ((size &gt; hash_table-&gt;nnodes * 4 &amp;&amp; size &gt; 1 &lt;&lt; HASH_TABLE_MIN_SHIFT) ||
        (size &lt;= noccupied + (noccupied / 16)))
      g_hash_table_resize (hash_table);
  }
  
<span class="udiff-line-added">+ #ifdef USE_SMALL_ARRAYS</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static inline gboolean</span>
<span class="udiff-line-added">+ entry_is_big (gpointer v)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   return (((guintptr) v) &gt;&gt; ((BIG_ENTRY_SIZE - SMALL_ENTRY_SIZE) * 8)) != 0;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static inline gboolean</span>
<span class="udiff-line-added">+ g_hash_table_maybe_make_big_keys_or_values (gpointer *a_p, gpointer v, gint ht_size)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   if (entry_is_big (v))</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       guint *a = (guint *) *a_p;</span>
<span class="udiff-line-added">+       gpointer *a_new;</span>
<span class="udiff-line-added">+       gint i;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       a_new = g_new (gpointer, ht_size);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       for (i = 0; i &lt; ht_size; i++)</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+           a_new[i] = GUINT_TO_POINTER (a[i]);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       g_free (a);</span>
<span class="udiff-line-added">+       *a_p = a_new;</span>
<span class="udiff-line-added">+       return TRUE;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return FALSE;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static inline void</span>
<span class="udiff-line-added">+ g_hash_table_ensure_keyval_fits (GHashTable *hash_table, gpointer key, gpointer value)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   gboolean is_a_set = (hash_table-&gt;keys == hash_table-&gt;values);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef USE_SMALL_ARRAYS</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   /* Convert from set to map? */</span>
<span class="udiff-line-added">+   if (is_a_set)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       if (hash_table-&gt;have_big_keys)</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+           if (key != value)</span>
<span class="udiff-line-added">+             hash_table-&gt;values = g_memdup (hash_table-&gt;keys, sizeof (gpointer) * hash_table-&gt;size);</span>
<span class="udiff-line-added">+           /* Keys and values are both big now, so no need for further checks */</span>
<span class="udiff-line-added">+           return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       else</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+           if (key != value)</span>
<span class="udiff-line-added">+             {</span>
<span class="udiff-line-added">+               hash_table-&gt;values = g_memdup (hash_table-&gt;keys, sizeof (guint) * hash_table-&gt;size);</span>
<span class="udiff-line-added">+               is_a_set = FALSE;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   /* Make keys big? */</span>
<span class="udiff-line-added">+   if (!hash_table-&gt;have_big_keys)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       hash_table-&gt;have_big_keys = g_hash_table_maybe_make_big_keys_or_values (&amp;hash_table-&gt;keys, key, hash_table-&gt;size);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (is_a_set)</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+           hash_table-&gt;values = hash_table-&gt;keys;</span>
<span class="udiff-line-added">+           hash_table-&gt;have_big_values = hash_table-&gt;have_big_keys;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   /* Make values big? */</span>
<span class="udiff-line-added">+   if (!is_a_set &amp;&amp; !hash_table-&gt;have_big_values)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       hash_table-&gt;have_big_values = g_hash_table_maybe_make_big_keys_or_values (&amp;hash_table-&gt;values, value, hash_table-&gt;size);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   /* Just split if necessary */</span>
<span class="udiff-line-added">+   if (is_a_set &amp;&amp; key != value)</span>
<span class="udiff-line-added">+     hash_table-&gt;values = g_memdup (hash_table-&gt;keys, sizeof (gpointer) * hash_table-&gt;size);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /**
   * g_hash_table_new:
   * @hash_func: a function to create a hash value from a key
   * @key_equal_func: a function to check two keys for equality
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -718,24 +1074,22 @@</span>
  #ifdef GSTREAMER_LITE
    if (hash_table == NULL) {
      return NULL;
    }
  #endif // GSTREAMER_LITE
<span class="udiff-line-removed">-   g_hash_table_set_shift (hash_table, HASH_TABLE_MIN_SHIFT);</span>
    g_atomic_ref_count_init (&amp;hash_table-&gt;ref_count);
    hash_table-&gt;nnodes             = 0;
    hash_table-&gt;noccupied          = 0;
    hash_table-&gt;hash_func          = hash_func ? hash_func : g_direct_hash;
    hash_table-&gt;key_equal_func     = key_equal_func;
  #ifndef G_DISABLE_ASSERT
    hash_table-&gt;version            = 0;
  #endif
    hash_table-&gt;key_destroy_func   = key_destroy_func;
    hash_table-&gt;value_destroy_func = value_destroy_func;
<span class="udiff-line-modified-removed">-   hash_table-&gt;keys               = g_new0 (gpointer, hash_table-&gt;size);</span>
<span class="udiff-line-modified-removed">-   hash_table-&gt;values             = hash_table-&gt;keys;</span>
<span class="udiff-line-removed">-   hash_table-&gt;hashes             = g_new0 (guint, hash_table-&gt;size);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   g_hash_table_setup_storage (hash_table);</span>
  
    return hash_table;
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -799,29 +1153,29 @@</span>
  
    g_return_val_if_fail (iter != NULL, FALSE);
  #ifndef G_DISABLE_ASSERT
    g_return_val_if_fail (ri-&gt;version == ri-&gt;hash_table-&gt;version, FALSE);
  #endif
<span class="udiff-line-modified-removed">-   g_return_val_if_fail (ri-&gt;position &lt; ri-&gt;hash_table-&gt;size, FALSE);</span>
<span class="udiff-line-modified-added">+   g_return_val_if_fail (ri-&gt;position &lt; (gssize) ri-&gt;hash_table-&gt;size, FALSE);</span>
  
    position = ri-&gt;position;
  
    do
      {
        position++;
<span class="udiff-line-modified-removed">-       if (position &gt;= ri-&gt;hash_table-&gt;size)</span>
<span class="udiff-line-modified-added">+       if (position &gt;= (gssize) ri-&gt;hash_table-&gt;size)</span>
          {
            ri-&gt;position = position;
            return FALSE;
          }
      }
    while (!HASH_IS_REAL (ri-&gt;hash_table-&gt;hashes[position]));
  
    if (key != NULL)
<span class="udiff-line-modified-removed">-     *key = ri-&gt;hash_table-&gt;keys[position];</span>
<span class="udiff-line-modified-added">+     *key = g_hash_table_fetch_key_or_value (ri-&gt;hash_table-&gt;keys, position, ri-&gt;hash_table-&gt;have_big_keys);</span>
    if (value != NULL)
<span class="udiff-line-modified-removed">-     *value = ri-&gt;hash_table-&gt;values[position];</span>
<span class="udiff-line-modified-added">+     *value = g_hash_table_fetch_key_or_value (ri-&gt;hash_table-&gt;values, position, ri-&gt;hash_table-&gt;have_big_values);</span>
  
    ri-&gt;position = position;
    return TRUE;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -849,11 +1203,11 @@</span>
    g_return_if_fail (ri != NULL);
  #ifndef G_DISABLE_ASSERT
    g_return_if_fail (ri-&gt;version == ri-&gt;hash_table-&gt;version);
  #endif
    g_return_if_fail (ri-&gt;position &gt;= 0);
<span class="udiff-line-modified-removed">-   g_return_if_fail (ri-&gt;position &lt; ri-&gt;hash_table-&gt;size);</span>
<span class="udiff-line-modified-added">+   g_return_if_fail ((gsize) ri-&gt;position &lt; ri-&gt;hash_table-&gt;size);</span>
  
    g_hash_table_remove_node (ri-&gt;hash_table, ri-&gt;position, notify);
  
  #ifndef G_DISABLE_ASSERT
    ri-&gt;version++;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -920,10 +1274,11 @@</span>
                            gboolean    reusing_key)
  {
    gboolean already_exists;
    guint old_hash;
    gpointer key_to_free = NULL;
<span class="udiff-line-added">+   gpointer key_to_keep = NULL;</span>
    gpointer value_to_free = NULL;
  
    old_hash = hash_table-&gt;hashes[node_index];
    already_exists = HASH_IS_REAL (old_hash);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -949,35 +1304,35 @@</span>
      {
        /* Note: we must record the old value before writing the new key
         * because we might change the value in the event that the two
         * arrays are shared.
         */
<span class="udiff-line-modified-removed">-       value_to_free = hash_table-&gt;values[node_index];</span>
<span class="udiff-line-modified-added">+       value_to_free = g_hash_table_fetch_key_or_value (hash_table-&gt;values, node_index, hash_table-&gt;have_big_values);</span>
  
        if (keep_new_key)
          {
<span class="udiff-line-modified-removed">-           key_to_free = hash_table-&gt;keys[node_index];</span>
<span class="udiff-line-modified-removed">-           hash_table-&gt;keys[node_index] = new_key;</span>
<span class="udiff-line-modified-added">+           key_to_free = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys);</span>
<span class="udiff-line-modified-added">+           key_to_keep = new_key;</span>
          }
        else
<span class="udiff-line-modified-removed">-         key_to_free = new_key;</span>
<span class="udiff-line-modified-added">+         {</span>
<span class="udiff-line-added">+           key_to_free = new_key;</span>
<span class="udiff-line-added">+           key_to_keep = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys);</span>
<span class="udiff-line-added">+         }</span>
      }
    else
      {
        hash_table-&gt;hashes[node_index] = key_hash;
<span class="udiff-line-modified-removed">-       hash_table-&gt;keys[node_index] = new_key;</span>
<span class="udiff-line-modified-added">+       key_to_keep = new_key;</span>
      }
  
<span class="udiff-line-modified-removed">-   /* Step two: check if the value that we are about to write to the</span>
<span class="udiff-line-modified-removed">-    * table is the same as the key in the same position.  If it&#39;s not,</span>
<span class="udiff-line-modified-removed">-    * split the table.</span>
<span class="udiff-line-removed">-    */</span>
<span class="udiff-line-removed">-   if (G_UNLIKELY (hash_table-&gt;keys == hash_table-&gt;values &amp;&amp; hash_table-&gt;keys[node_index] != new_value))</span>
<span class="udiff-line-removed">-     hash_table-&gt;values = g_memdup (hash_table-&gt;keys, sizeof (gpointer) * hash_table-&gt;size);</span>
<span class="udiff-line-modified-added">+   /* Resize key/value arrays and split table as necessary */</span>
<span class="udiff-line-modified-added">+   g_hash_table_ensure_keyval_fits (hash_table, key_to_keep, new_value);</span>
<span class="udiff-line-modified-added">+   g_hash_table_assign_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys, key_to_keep);</span>
  
    /* Step 3: Actually do the write */
<span class="udiff-line-modified-removed">-   hash_table-&gt;values[node_index] = new_value;</span>
<span class="udiff-line-modified-added">+   g_hash_table_assign_key_or_value (hash_table-&gt;values, node_index, hash_table-&gt;have_big_values, new_value);</span>
  
    /* Now, the bookkeeping... */
    if (!already_exists)
      {
        hash_table-&gt;nnodes++;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1032,14 +1387,15 @@</span>
    g_return_if_fail (ri != NULL);
  #ifndef G_DISABLE_ASSERT
    g_return_if_fail (ri-&gt;version == ri-&gt;hash_table-&gt;version);
  #endif
    g_return_if_fail (ri-&gt;position &gt;= 0);
<span class="udiff-line-modified-removed">-   g_return_if_fail (ri-&gt;position &lt; ri-&gt;hash_table-&gt;size);</span>
<span class="udiff-line-modified-added">+   g_return_if_fail ((gsize) ri-&gt;position &lt; ri-&gt;hash_table-&gt;size);</span>
  
    node_hash = ri-&gt;hash_table-&gt;hashes[ri-&gt;position];
<span class="udiff-line-modified-removed">-   key = ri-&gt;hash_table-&gt;keys[ri-&gt;position];</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   key = g_hash_table_fetch_key_or_value (ri-&gt;hash_table-&gt;keys, ri-&gt;position, ri-&gt;hash_table-&gt;have_big_keys);</span>
  
    g_hash_table_insert_node (ri-&gt;hash_table, ri-&gt;position, node_hash, key, value, TRUE, TRUE);
  
  #ifndef G_DISABLE_ASSERT
    ri-&gt;version++;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1156,11 +1512,11 @@</span>
    g_return_val_if_fail (hash_table != NULL, NULL);
  
    node_index = g_hash_table_lookup_node (hash_table, key, &amp;node_hash);
  
    return HASH_IS_REAL (hash_table-&gt;hashes[node_index])
<span class="udiff-line-modified-removed">-     ? hash_table-&gt;values[node_index]</span>
<span class="udiff-line-modified-added">+     ? g_hash_table_fetch_key_or_value (hash_table-&gt;values, node_index, hash_table-&gt;have_big_values)</span>
      : NULL;
  }
  
  /**
   * g_hash_table_lookup_extended:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1193,17 +1549,24 @@</span>
    g_return_val_if_fail (hash_table != NULL, FALSE);
  
    node_index = g_hash_table_lookup_node (hash_table, lookup_key, &amp;node_hash);
  
    if (!HASH_IS_REAL (hash_table-&gt;hashes[node_index]))
<span class="udiff-line-modified-removed">-     return FALSE;</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-added">+       if (orig_key != NULL)</span>
<span class="udiff-line-added">+         *orig_key = NULL;</span>
<span class="udiff-line-added">+       if (value != NULL)</span>
<span class="udiff-line-added">+         *value = NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       return FALSE;</span>
<span class="udiff-line-added">+     }</span>
  
    if (orig_key)
<span class="udiff-line-modified-removed">-     *orig_key = hash_table-&gt;keys[node_index];</span>
<span class="udiff-line-modified-added">+     *orig_key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys);</span>
  
    if (value)
<span class="udiff-line-modified-removed">-     *value = hash_table-&gt;values[node_index];</span>
<span class="udiff-line-modified-added">+     *value = g_hash_table_fetch_key_or_value (hash_table-&gt;values, node_index, hash_table-&gt;have_big_values);</span>
  
    return TRUE;
  }
  
  /*
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1470,14 +1833,20 @@</span>
          *stolen_value = NULL;
        return FALSE;
      }
  
    if (stolen_key != NULL)
<span class="udiff-line-modified-removed">-     *stolen_key = g_steal_pointer (&amp;hash_table-&gt;keys[node_index]);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-added">+     *stolen_key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys);</span>
<span class="udiff-line-added">+     g_hash_table_assign_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys, NULL);</span>
<span class="udiff-line-added">+   }</span>
  
    if (stolen_value != NULL)
<span class="udiff-line-modified-removed">-     *stolen_value = g_steal_pointer (&amp;hash_table-&gt;values[node_index]);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-added">+     *stolen_value = g_hash_table_fetch_key_or_value (hash_table-&gt;values, node_index, hash_table-&gt;have_big_values);</span>
<span class="udiff-line-added">+     g_hash_table_assign_key_or_value (hash_table-&gt;values, node_index, hash_table-&gt;have_big_values, NULL);</span>
<span class="udiff-line-added">+   }</span>
  
    g_hash_table_remove_node (hash_table, node_index, FALSE);
    g_hash_table_maybe_resize (hash_table);
  
  #ifndef G_DISABLE_ASSERT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1559,20 +1928,20 @@</span>
                                        GHRFunc     func,
                                        gpointer    user_data,
                                        gboolean    notify)
  {
    guint deleted = 0;
<span class="udiff-line-modified-removed">-   gint i;</span>
<span class="udiff-line-modified-added">+   gsize i;</span>
  #ifndef G_DISABLE_ASSERT
    gint version = hash_table-&gt;version;
  #endif
  
    for (i = 0; i &lt; hash_table-&gt;size; i++)
      {
        guint node_hash = hash_table-&gt;hashes[i];
<span class="udiff-line-modified-removed">-       gpointer node_key = hash_table-&gt;keys[i];</span>
<span class="udiff-line-modified-removed">-       gpointer node_value = hash_table-&gt;values[i];</span>
<span class="udiff-line-modified-added">+       gpointer node_key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys);</span>
<span class="udiff-line-modified-added">+       gpointer node_value = g_hash_table_fetch_key_or_value (hash_table-&gt;values, i, hash_table-&gt;have_big_values);</span>
  
        if (HASH_IS_REAL (node_hash) &amp;&amp;
            (* func) (node_key, node_value, user_data))
          {
            g_hash_table_remove_node (hash_table, i, notify);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1668,11 +2037,11 @@</span>
  void
  g_hash_table_foreach (GHashTable *hash_table,
                        GHFunc      func,
                        gpointer    user_data)
  {
<span class="udiff-line-modified-removed">-   gint i;</span>
<span class="udiff-line-modified-added">+   gsize i;</span>
  #ifndef G_DISABLE_ASSERT
    gint version;
  #endif
  
    g_return_if_fail (hash_table != NULL);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1683,12 +2052,12 @@</span>
  #endif
  
    for (i = 0; i &lt; hash_table-&gt;size; i++)
      {
        guint node_hash = hash_table-&gt;hashes[i];
<span class="udiff-line-modified-removed">-       gpointer node_key = hash_table-&gt;keys[i];</span>
<span class="udiff-line-modified-removed">-       gpointer node_value = hash_table-&gt;values[i];</span>
<span class="udiff-line-modified-added">+       gpointer node_key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys);</span>
<span class="udiff-line-modified-added">+       gpointer node_value = g_hash_table_fetch_key_or_value (hash_table-&gt;values, i, hash_table-&gt;have_big_values);</span>
  
        if (HASH_IS_REAL (node_hash))
          (* func) (node_key, node_value, user_data);
  
  #ifndef G_DISABLE_ASSERT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1726,11 +2095,11 @@</span>
  gpointer
  g_hash_table_find (GHashTable *hash_table,
                     GHRFunc     predicate,
                     gpointer    user_data)
  {
<span class="udiff-line-modified-removed">-   gint i;</span>
<span class="udiff-line-modified-added">+   gsize i;</span>
  #ifndef G_DISABLE_ASSERT
    gint version;
  #endif
    gboolean match;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1744,12 +2113,12 @@</span>
    match = FALSE;
  
    for (i = 0; i &lt; hash_table-&gt;size; i++)
      {
        guint node_hash = hash_table-&gt;hashes[i];
<span class="udiff-line-modified-removed">-       gpointer node_key = hash_table-&gt;keys[i];</span>
<span class="udiff-line-modified-removed">-       gpointer node_value = hash_table-&gt;values[i];</span>
<span class="udiff-line-modified-added">+       gpointer node_key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys);</span>
<span class="udiff-line-modified-added">+       gpointer node_value = g_hash_table_fetch_key_or_value (hash_table-&gt;values, i, hash_table-&gt;have_big_values);</span>
  
        if (HASH_IS_REAL (node_hash))
          match = predicate (node_key, node_value, user_data);
  
  #ifndef G_DISABLE_ASSERT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1798,20 +2167,20 @@</span>
   * Since: 2.14
   */
  GList *
  g_hash_table_get_keys (GHashTable *hash_table)
  {
<span class="udiff-line-modified-removed">-   gint i;</span>
<span class="udiff-line-modified-added">+   gsize i;</span>
    GList *retval;
  
    g_return_val_if_fail (hash_table != NULL, NULL);
  
    retval = NULL;
    for (i = 0; i &lt; hash_table-&gt;size; i++)
      {
        if (HASH_IS_REAL (hash_table-&gt;hashes[i]))
<span class="udiff-line-modified-removed">-         retval = g_list_prepend (retval, hash_table-&gt;keys[i]);</span>
<span class="udiff-line-modified-added">+         retval = g_list_prepend (retval, g_hash_table_fetch_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys));</span>
      }
  
    return retval;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1846,17 +2215,17 @@</span>
  gpointer *
  g_hash_table_get_keys_as_array (GHashTable *hash_table,
                                  guint      *length)
  {
    gpointer *result;
<span class="udiff-line-modified-removed">-   guint i, j = 0;</span>
<span class="udiff-line-modified-added">+   gsize i, j = 0;</span>
  
    result = g_new (gpointer, hash_table-&gt;nnodes + 1);
    for (i = 0; i &lt; hash_table-&gt;size; i++)
      {
        if (HASH_IS_REAL (hash_table-&gt;hashes[i]))
<span class="udiff-line-modified-removed">-         result[j++] = hash_table-&gt;keys[i];</span>
<span class="udiff-line-modified-added">+         result[j++] = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys);</span>
      }
    g_assert_cmpint (j, ==, hash_table-&gt;nnodes);
    result[j] = NULL;
  
    if (length)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1884,20 +2253,20 @@</span>
   * Since: 2.14
   */
  GList *
  g_hash_table_get_values (GHashTable *hash_table)
  {
<span class="udiff-line-modified-removed">-   gint i;</span>
<span class="udiff-line-modified-added">+   gsize i;</span>
    GList *retval;
  
    g_return_val_if_fail (hash_table != NULL, NULL);
  
    retval = NULL;
    for (i = 0; i &lt; hash_table-&gt;size; i++)
      {
        if (HASH_IS_REAL (hash_table-&gt;hashes[i]))
<span class="udiff-line-modified-removed">-         retval = g_list_prepend (retval, hash_table-&gt;values[i]);</span>
<span class="udiff-line-modified-added">+         retval = g_list_prepend (retval, g_hash_table_fetch_key_or_value (hash_table-&gt;values, i, hash_table-&gt;have_big_values));</span>
      }
  
    return retval;
  }
  
</pre>
<center><a href="ggettext.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ghash.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>