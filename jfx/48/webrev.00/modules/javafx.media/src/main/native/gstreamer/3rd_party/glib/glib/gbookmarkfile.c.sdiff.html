<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gbookmarkfile.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gbitlock.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gbookmarkfile.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gbookmarkfile.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  78  * registered; the URI and MIME type of an icon, to be used when
  79  * displaying the bookmark inside a GUI.
  80  *
  81  * Here is an example of a bookmark file:
  82  * [bookmarks.xbel](https://git.gnome.org/browse/glib/tree/glib/tests/bookmarks.xbel)
  83  *
  84  * A bookmark file might contain more than one bookmark; each bookmark
  85  * is accessed through its URI.
  86  *
  87  * The important caveat of bookmark files is that when you add a new
  88  * bookmark you must also add the application that is registering it, using
  89  * g_bookmark_file_add_application() or g_bookmark_file_set_app_info().
  90  * If a bookmark has no applications then it won&#39;t be dumped when creating
  91  * the on disk representation, using g_bookmark_file_to_data() or
  92  * g_bookmark_file_to_file().
  93  *
  94  * The #GBookmarkFile parser was added in GLib 2.12.
  95  */
  96 
  97 /* XBEL 1.0 standard entities */
<span class="line-modified">  98 #define XBEL_VERSION        &quot;1.0&quot;</span>
<span class="line-modified">  99 #define XBEL_DTD_NICK       &quot;xbel&quot;</span>
<span class="line-modified"> 100 #define XBEL_DTD_SYSTEM     &quot;+//IDN python.org//DTD XML Bookmark &quot; \</span>
<span class="line-modified"> 101                 &quot;Exchange Language 1.0//EN//XML&quot;</span>
<span class="line-modified"> 102 </span>
<span class="line-modified"> 103 #define XBEL_DTD_URI        &quot;http://www.python.org/topics/xml/dtds/xbel-1.0.dtd&quot;</span>
<span class="line-modified"> 104 </span>
<span class="line-modified"> 105 #define XBEL_ROOT_ELEMENT   &quot;xbel&quot;</span>
<span class="line-modified"> 106 #define XBEL_FOLDER_ELEMENT &quot;folder&quot;    /* unused */</span>
<span class="line-modified"> 107 #define XBEL_BOOKMARK_ELEMENT   &quot;bookmark&quot;</span>
<span class="line-modified"> 108 #define XBEL_ALIAS_ELEMENT  &quot;alias&quot;     /* unused */</span>
<span class="line-modified"> 109 #define XBEL_SEPARATOR_ELEMENT  &quot;separator&quot;     /* unused */</span>
 110 #define XBEL_TITLE_ELEMENT  &quot;title&quot;
<span class="line-modified"> 111 #define XBEL_DESC_ELEMENT   &quot;desc&quot;</span>
<span class="line-modified"> 112 #define XBEL_INFO_ELEMENT   &quot;info&quot;</span>
<span class="line-modified"> 113 #define XBEL_METADATA_ELEMENT   &quot;metadata&quot;</span>
 114 
 115 #define XBEL_VERSION_ATTRIBUTE  &quot;version&quot;
<span class="line-modified"> 116 #define XBEL_FOLDED_ATTRIBUTE   &quot;folded&quot;    /* unused */</span>
<span class="line-modified"> 117 #define XBEL_OWNER_ATTRIBUTE    &quot;owner&quot;</span>
<span class="line-modified"> 118 #define XBEL_ADDED_ATTRIBUTE    &quot;added&quot;</span>
 119 #define XBEL_VISITED_ATTRIBUTE  &quot;visited&quot;
 120 #define XBEL_MODIFIED_ATTRIBUTE &quot;modified&quot;
<span class="line-modified"> 121 #define XBEL_ID_ATTRIBUTE   &quot;id&quot;</span>
 122 #define XBEL_HREF_ATTRIBUTE &quot;href&quot;
<span class="line-modified"> 123 #define XBEL_REF_ATTRIBUTE  &quot;ref&quot;       /* unused */</span>
 124 
<span class="line-modified"> 125 #define XBEL_YES_VALUE      &quot;yes&quot;</span>
<span class="line-modified"> 126 #define XBEL_NO_VALUE       &quot;no&quot;</span>
 127 
 128 /* Desktop bookmark spec entities */
<span class="line-modified"> 129 #define BOOKMARK_METADATA_OWNER     &quot;http://freedesktop.org&quot;</span>
<span class="line-modified"> 130 </span>
<span class="line-modified"> 131 #define BOOKMARK_NAMESPACE_NAME     &quot;bookmark&quot;</span>
<span class="line-modified"> 132 #define BOOKMARK_NAMESPACE_URI      &quot;http://www.freedesktop.org/standards/desktop-bookmarks&quot;</span>
<span class="line-modified"> 133 </span>
<span class="line-modified"> 134 #define BOOKMARK_GROUPS_ELEMENT     &quot;groups&quot;</span>
<span class="line-modified"> 135 #define BOOKMARK_GROUP_ELEMENT      &quot;group&quot;</span>
<span class="line-modified"> 136 #define BOOKMARK_APPLICATIONS_ELEMENT   &quot;applications&quot;</span>
<span class="line-modified"> 137 #define BOOKMARK_APPLICATION_ELEMENT    &quot;application&quot;</span>
<span class="line-modified"> 138 #define BOOKMARK_ICON_ELEMENT       &quot;icon&quot;</span>
<span class="line-modified"> 139 #define BOOKMARK_PRIVATE_ELEMENT    &quot;private&quot;</span>
<span class="line-modified"> 140 </span>
<span class="line-modified"> 141 #define BOOKMARK_NAME_ATTRIBUTE     &quot;name&quot;</span>
<span class="line-modified"> 142 #define BOOKMARK_EXEC_ATTRIBUTE     &quot;exec&quot;</span>
<span class="line-modified"> 143 #define BOOKMARK_COUNT_ATTRIBUTE    &quot;count&quot;</span>
<span class="line-modified"> 144 #define BOOKMARK_TIMESTAMP_ATTRIBUTE    &quot;timestamp&quot;     /* deprecated by &quot;modified&quot; */</span>
 145 #define BOOKMARK_MODIFIED_ATTRIBUTE     &quot;modified&quot;
<span class="line-modified"> 146 #define BOOKMARK_HREF_ATTRIBUTE     &quot;href&quot;</span>
<span class="line-modified"> 147 #define BOOKMARK_TYPE_ATTRIBUTE     &quot;type&quot;</span>
 148 
 149 /* Shared MIME Info entities */
<span class="line-modified"> 150 #define MIME_NAMESPACE_NAME         &quot;mime&quot;</span>
<span class="line-modified"> 151 #define MIME_NAMESPACE_URI      &quot;http://www.freedesktop.org/standards/shared-mime-info&quot;</span>
<span class="line-modified"> 152 #define MIME_TYPE_ELEMENT       &quot;mime-type&quot;</span>
<span class="line-modified"> 153 #define MIME_TYPE_ATTRIBUTE         &quot;type&quot;</span>
 154 
 155 
 156 typedef struct _BookmarkAppInfo  BookmarkAppInfo;
 157 typedef struct _BookmarkMetadata BookmarkMetadata;
 158 typedef struct _BookmarkItem     BookmarkItem;
 159 typedef struct _ParseData        ParseData;
 160 
 161 struct _BookmarkAppInfo
 162 {
 163   gchar *name;
 164   gchar *exec;
 165 
 166   guint count;
 167 
 168   time_t stamp;
 169 };
 170 
 171 struct _BookmarkMetadata
 172 {
 173   gchar *mime_type;
</pre>
<hr />
<pre>
 186 struct _BookmarkItem
 187 {
 188   gchar *uri;
 189 
 190   gchar *title;
 191   gchar *description;
 192 
 193   time_t added;
 194   time_t modified;
 195   time_t visited;
 196 
 197   BookmarkMetadata *metadata;
 198 };
 199 
 200 struct _GBookmarkFile
 201 {
 202   gchar *title;
 203   gchar *description;
 204 
 205   /* we store our items in a list and keep a copy inside
<span class="line-modified"> 206    * an hash table for faster lookup performances</span>
 207    */
 208   GList *items;
 209   GHashTable *items_by_uri;
 210 };
 211 
 212 /* parser state machine */
 213 typedef enum
 214 {
 215   STATE_STARTED        = 0,
 216 
 217   STATE_ROOT,
 218   STATE_BOOKMARK,
 219   STATE_TITLE,
 220   STATE_DESC,
 221   STATE_INFO,
 222   STATE_METADATA,
 223   STATE_APPLICATIONS,
 224   STATE_APPLICATION,
 225   STATE_GROUPS,
 226   STATE_GROUP,
 227   STATE_MIME,
 228   STATE_ICON,
 229 
 230   STATE_FINISHED
 231 } ParserState;
 232 
 233 static void          g_bookmark_file_init        (GBookmarkFile  *bookmark);
 234 static void          g_bookmark_file_clear       (GBookmarkFile  *bookmark);
 235 static gboolean      g_bookmark_file_parse       (GBookmarkFile  *bookmark,
<span class="line-modified"> 236                           const gchar    *buffer,</span>
<span class="line-modified"> 237                           gsize           length,</span>
<span class="line-modified"> 238                           GError        **error);</span>
 239 static gchar *       g_bookmark_file_dump        (GBookmarkFile  *bookmark,
<span class="line-modified"> 240                           gsize          *length,</span>
<span class="line-modified"> 241                           GError        **error);</span>
 242 static BookmarkItem *g_bookmark_file_lookup_item (GBookmarkFile  *bookmark,
<span class="line-modified"> 243                           const gchar    *uri);</span>
 244 static void          g_bookmark_file_add_item    (GBookmarkFile  *bookmark,
<span class="line-modified"> 245                           BookmarkItem   *item,</span>
<span class="line-modified"> 246                           GError        **error);</span>
 247 
<span class="line-modified"> 248 static time_t  timestamp_from_iso8601 (const gchar *iso_date);</span>
<span class="line-modified"> 249 static gchar * timestamp_to_iso8601   (time_t       timestamp);</span>


 250 
 251 /********************************
 252  * BookmarkAppInfo              *
 253  *                              *
 254  * Application metadata storage *
 255  ********************************/
 256 static BookmarkAppInfo *
 257 bookmark_app_info_new (const gchar *name)
 258 {
 259   BookmarkAppInfo *retval;
 260 
 261   g_warn_if_fail (name != NULL);
 262 
 263   retval = g_slice_new (BookmarkAppInfo);
 264 #ifdef GSTREAMER_LITE
 265   if (retval == NULL) {
 266     return NULL;
 267   }
 268 #endif // GSTREAMER_LITE
 269 
</pre>
<hr />
<pre>
 370 
 371   g_free (metadata-&gt;icon_href);
 372   g_free (metadata-&gt;icon_mime);
 373 
 374   g_slice_free (BookmarkMetadata, metadata);
 375 }
 376 
 377 static gchar *
 378 bookmark_metadata_dump (BookmarkMetadata *metadata)
 379 {
 380   GString *retval;
 381   gchar *buffer;
 382 
 383   if (!metadata-&gt;applications)
 384     return NULL;
 385 
 386   retval = g_string_sized_new (1024);
 387 
 388   /* metadata container */
 389   g_string_append (retval,
<span class="line-modified"> 390            &quot;      &quot;</span>
<span class="line-modified"> 391            &quot;&lt;&quot; XBEL_METADATA_ELEMENT</span>
<span class="line-modified"> 392            &quot; &quot; XBEL_OWNER_ATTRIBUTE &quot;=\&quot;&quot; BOOKMARK_METADATA_OWNER</span>
<span class="line-modified"> 393            &quot;\&quot;&gt;\n&quot;);</span>
 394 
 395   /* mime type */
 396   if (metadata-&gt;mime_type) {
 397     buffer = g_strconcat (&quot;        &quot;
<span class="line-modified"> 398               &quot;&lt;&quot; MIME_NAMESPACE_NAME &quot;:&quot; MIME_TYPE_ELEMENT &quot; &quot;</span>
<span class="line-modified"> 399               MIME_TYPE_ATTRIBUTE &quot;=\&quot;&quot;, metadata-&gt;mime_type, &quot;\&quot;/&gt;\n&quot;,</span>
<span class="line-modified"> 400               NULL);</span>
 401     g_string_append (retval, buffer);
 402     g_free (buffer);
 403   }
 404 
 405   if (metadata-&gt;groups)
 406     {
 407       GList *l;
 408 
 409       /* open groups container */
 410       g_string_append (retval,
<span class="line-modified"> 411                &quot;        &quot;</span>
<span class="line-modified"> 412                &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 413                &quot;:&quot; BOOKMARK_GROUPS_ELEMENT &quot;&gt;\n&quot;);</span>
 414 
 415       for (l = g_list_last (metadata-&gt;groups); l != NULL; l = l-&gt;prev)
 416         {
 417           gchar *group_name;
 418 
<span class="line-modified"> 419       group_name = g_markup_escape_text ((gchar *) l-&gt;data, -1);</span>
<span class="line-modified"> 420       buffer = g_strconcat (&quot;          &quot;</span>
<span class="line-modified"> 421                 &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 422                 &quot;:&quot; BOOKMARK_GROUP_ELEMENT &quot;&gt;&quot;,</span>
<span class="line-modified"> 423                 group_name,</span>
<span class="line-modified"> 424                 &quot;&lt;/&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 425                 &quot;:&quot;  BOOKMARK_GROUP_ELEMENT &quot;&gt;\n&quot;, NULL);</span>
<span class="line-modified"> 426       g_string_append (retval, buffer);</span>
 427 
<span class="line-modified"> 428       g_free (buffer);</span>
<span class="line-modified"> 429       g_free (group_name);</span>
 430         }
 431 
 432       /* close groups container */
 433       g_string_append (retval,
<span class="line-modified"> 434                &quot;        &quot;</span>
<span class="line-modified"> 435                &quot;&lt;/&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 436                &quot;:&quot; BOOKMARK_GROUPS_ELEMENT &quot;&gt;\n&quot;);</span>
 437     }
 438 
 439   if (metadata-&gt;applications)
 440     {
 441       GList *l;
 442 
 443       /* open applications container */
 444       g_string_append (retval,
<span class="line-modified"> 445                &quot;        &quot;</span>
<span class="line-modified"> 446                &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 447                &quot;:&quot; BOOKMARK_APPLICATIONS_ELEMENT &quot;&gt;\n&quot;);</span>
 448 
 449       for (l = g_list_last (metadata-&gt;applications); l != NULL; l = l-&gt;prev)
 450         {
 451           BookmarkAppInfo *app_info = (BookmarkAppInfo *) l-&gt;data;
 452           gchar *app_data;
 453 
<span class="line-modified"> 454       g_warn_if_fail (app_info != NULL);</span>
 455 
 456           app_data = bookmark_app_info_dump (app_info);
 457 
<span class="line-modified"> 458       if (app_data)</span>
 459             {
 460               retval = g_string_append (retval, app_data);
 461 
<span class="line-modified"> 462           g_free (app_data);</span>
<span class="line-modified"> 463         }</span>
 464         }
 465 
 466       /* close applications container */
 467       g_string_append (retval,
<span class="line-modified"> 468                &quot;        &quot;</span>
<span class="line-modified"> 469                &quot;&lt;/&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 470                &quot;:&quot; BOOKMARK_APPLICATIONS_ELEMENT &quot;&gt;\n&quot;);</span>
 471     }
 472 
 473   /* icon */
 474   if (metadata-&gt;icon_href)
 475     {
 476       if (!metadata-&gt;icon_mime)
 477         metadata-&gt;icon_mime = g_strdup (&quot;application/octet-stream&quot;);
 478 
 479       buffer = g_strconcat (&quot;       &quot;
<span class="line-modified"> 480                 &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 481                 &quot;:&quot; BOOKMARK_ICON_ELEMENT</span>
<span class="line-modified"> 482                 &quot; &quot; BOOKMARK_HREF_ATTRIBUTE &quot;=\&quot;&quot;, metadata-&gt;icon_href,</span>
<span class="line-modified"> 483                 &quot;\&quot; &quot; BOOKMARK_TYPE_ATTRIBUTE &quot;=\&quot;&quot;, metadata-&gt;icon_mime, &quot;\&quot;/&gt;\n&quot;, NULL);</span>
 484       g_string_append (retval, buffer);
 485 
 486       g_free (buffer);
 487     }
 488 
 489   /* private hint */
 490   if (metadata-&gt;is_private)
 491     g_string_append (retval,
<span class="line-modified"> 492              &quot;        &quot;</span>
<span class="line-modified"> 493              &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 494              &quot;:&quot; BOOKMARK_PRIVATE_ELEMENT &quot;/&gt;\n&quot;);</span>
 495 
 496   /* close metadata container */
 497   g_string_append (retval,
<span class="line-modified"> 498            &quot;      &quot;</span>
<span class="line-modified"> 499            &quot;&lt;/&quot; XBEL_METADATA_ELEMENT &quot;&gt;\n&quot;);</span>
 500 
 501   return g_string_free (retval, FALSE);
 502 }
 503 
 504 /******************************************************
 505  * BookmarkItem                                       *
 506  *                                                    *
 507  * Storage for a single bookmark item inside the list *
 508  ******************************************************/
 509 static BookmarkItem *
 510 bookmark_item_new (const gchar *uri)
 511 {
 512   BookmarkItem *item;
 513 
 514   g_warn_if_fail (uri != NULL);
 515 
 516   item = g_slice_new (BookmarkItem);
 517 #ifdef GSTREAMER_LITE
 518   if (item == NULL) {
 519     return NULL;
</pre>
<hr />
<pre>
 618                             escaped_desc,
 619                             &quot;&lt;/&quot; XBEL_DESC_ELEMENT &quot;&gt;\n&quot;,
 620                             NULL);
 621       g_string_append (retval, buffer);
 622 
 623       g_free (escaped_desc);
 624       g_free (buffer);
 625     }
 626 
 627   if (item-&gt;metadata)
 628     {
 629       gchar *metadata;
 630 
 631       metadata = bookmark_metadata_dump (item-&gt;metadata);
 632       if (metadata)
 633         {
 634           buffer = g_strconcat (&quot;    &quot;
 635                                 &quot;&lt;&quot; XBEL_INFO_ELEMENT &quot;&gt;\n&quot;,
 636                                 metadata,
 637                                 &quot;    &quot;
<span class="line-modified"> 638                 &quot;&lt;/&quot; XBEL_INFO_ELEMENT &quot;&gt;\n&quot;,</span>
 639                                 NULL);
 640           retval = g_string_append (retval, buffer);
 641 
 642           g_free (buffer);
<span class="line-modified"> 643       g_free (metadata);</span>
<span class="line-modified"> 644     }</span>
 645     }
 646 
 647   g_string_append (retval, &quot;  &lt;/&quot; XBEL_BOOKMARK_ELEMENT &quot;&gt;\n&quot;);
 648 
 649   return g_string_free (retval, FALSE);
 650 }
 651 
 652 static BookmarkAppInfo *
 653 bookmark_item_lookup_app_info (BookmarkItem *item,
<span class="line-modified"> 654                    const gchar  *app_name)</span>
 655 {
 656   g_warn_if_fail (item != NULL &amp;&amp; app_name != NULL);
 657 
 658   if (!item-&gt;metadata)
 659     return NULL;
 660 
 661   return g_hash_table_lookup (item-&gt;metadata-&gt;apps_by_name, app_name);
 662 }
 663 
 664 /*************************
 665  *    GBookmarkFile    *
 666  *************************/
 667 
 668 static void
 669 g_bookmark_file_init (GBookmarkFile *bookmark)
 670 {
 671   bookmark-&gt;title = NULL;
 672   bookmark-&gt;description = NULL;
 673 
 674   bookmark-&gt;items = NULL;
</pre>
<hr />
<pre>
 697 
 698 struct _ParseData
 699 {
 700   ParserState state;
 701 
 702   GHashTable *namespaces;
 703 
 704   GBookmarkFile *bookmark_file;
 705   BookmarkItem *current_item;
 706 };
 707 
 708 static ParseData *
 709 parse_data_new (void)
 710 {
 711   ParseData *retval;
 712 
 713   retval = g_new (ParseData, 1);
 714 
 715   retval-&gt;state = STATE_STARTED;
 716   retval-&gt;namespaces = g_hash_table_new_full (g_str_hash, g_str_equal,
<span class="line-modified"> 717                           (GDestroyNotify) g_free,</span>
<span class="line-modified"> 718                           (GDestroyNotify) g_free);</span>
 719   retval-&gt;bookmark_file = NULL;
 720   retval-&gt;current_item = NULL;
 721 
 722   return retval;
 723 }
 724 
 725 static void
 726 parse_data_free (ParseData *parse_data)
 727 {
 728   g_hash_table_destroy (parse_data-&gt;namespaces);
 729 
 730   g_free (parse_data);
 731 }
 732 
<span class="line-modified"> 733 #define IS_ATTRIBUTE(s,a)   ((0 == strcmp ((s), (a))))</span>
 734 
 735 static void
 736 parse_bookmark_element (GMarkupParseContext  *context,
<span class="line-modified"> 737             ParseData            *parse_data,</span>
<span class="line-modified"> 738             const gchar         **attribute_names,</span>
<span class="line-modified"> 739             const gchar         **attribute_values,</span>
<span class="line-modified"> 740             GError              **error)</span>
 741 {
 742   const gchar *uri, *added, *modified, *visited;
 743   const gchar *attr;
 744   gint i;
 745   BookmarkItem *item;
 746   GError *add_error;
 747 
 748   g_warn_if_fail ((parse_data != NULL) &amp;&amp; (parse_data-&gt;state == STATE_BOOKMARK));
 749 
 750   i = 0;
 751   uri = added = modified = visited = NULL;
 752   for (attr = attribute_names[i]; attr != NULL; attr = attribute_names[++i])
 753     {
 754       if (IS_ATTRIBUTE (attr, XBEL_HREF_ATTRIBUTE))
 755         uri = attribute_values[i];
 756       else if (IS_ATTRIBUTE (attr, XBEL_ADDED_ATTRIBUTE))
 757         added = attribute_values[i];
 758       else if (IS_ATTRIBUTE (attr, XBEL_MODIFIED_ATTRIBUTE))
 759         modified = attribute_values[i];
 760       else if (IS_ATTRIBUTE (attr, XBEL_VISITED_ATTRIBUTE))
 761         visited = attribute_values[i];
 762       else
 763         {
 764           /* bookmark is defined by the XBEL spec, so we need
 765            * to error out if the element has different or
 766            * missing attributes
 767            */
 768           g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified"> 769                        G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE,</span>
<span class="line-modified"> 770                        _(&quot;Unexpected attribute &#39;%s&#39; for element &#39;%s&#39;&quot;),</span>
<span class="line-modified"> 771                        attr,</span>
<span class="line-modified"> 772                        XBEL_BOOKMARK_ELEMENT);</span>
 773           return;
 774         }
 775     }
 776 
 777   if (!uri)
 778     {
 779       g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified"> 780                    G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified"> 781                    _(&quot;Attribute &#39;%s&#39; of element &#39;%s&#39; not found&quot;),</span>
<span class="line-modified"> 782                    XBEL_HREF_ATTRIBUTE,</span>
<span class="line-modified"> 783                    XBEL_BOOKMARK_ELEMENT);</span>
 784       return;
 785     }
 786 
 787   g_warn_if_fail (parse_data-&gt;current_item == NULL);
 788 
<span class="line-modified"> 789 item = bookmark_item_new (uri);</span>
 790 #ifdef GSTREAMER_LITE
 791   if (item == NULL) {
 792     return;
 793   }
 794 #endif // GSTREAMER_LITE
 795 
<span class="line-modified"> 796   if (added)</span>
<span class="line-modified"> 797     item-&gt;added = timestamp_from_iso8601 (added);</span>
 798 
<span class="line-modified"> 799   if (modified)</span>
<span class="line-modified"> 800     item-&gt;modified = timestamp_from_iso8601 (modified);</span>
 801 
<span class="line-modified"> 802   if (visited)</span>
<span class="line-modified"> 803     item-&gt;visited = timestamp_from_iso8601 (visited);</span>
 804 
 805   add_error = NULL;
 806   g_bookmark_file_add_item (parse_data-&gt;bookmark_file,
<span class="line-modified"> 807                 item,</span>
<span class="line-modified"> 808                 &amp;add_error);</span>
 809   if (add_error)
 810     {
 811       bookmark_item_free (item);
 812 
 813       g_propagate_error (error, add_error);
 814 
 815       return;
 816     }
 817 
 818   parse_data-&gt;current_item = item;
 819 }
 820 
 821 static void
 822 parse_application_element (GMarkupParseContext  *context,
<span class="line-modified"> 823                ParseData            *parse_data,</span>
<span class="line-modified"> 824                const gchar         **attribute_names,</span>
<span class="line-modified"> 825                const gchar         **attribute_values,</span>
<span class="line-modified"> 826                GError              **error)</span>
 827 {
 828   const gchar *name, *exec, *count, *stamp, *modified;
 829   const gchar *attr;
 830   gint i;
 831   BookmarkItem *item;
 832   BookmarkAppInfo *ai;
 833 
 834   g_warn_if_fail ((parse_data != NULL) &amp;&amp; (parse_data-&gt;state == STATE_APPLICATION));
 835 
 836   i = 0;
 837   name = exec = count = stamp = modified = NULL;
 838   for (attr = attribute_names[i]; attr != NULL; attr = attribute_names[++i])
 839     {
 840       if (IS_ATTRIBUTE (attr, BOOKMARK_NAME_ATTRIBUTE))
 841         name = attribute_values[i];
 842       else if (IS_ATTRIBUTE (attr, BOOKMARK_EXEC_ATTRIBUTE))
 843         exec = attribute_values[i];
 844       else if (IS_ATTRIBUTE (attr, BOOKMARK_COUNT_ATTRIBUTE))
 845         count = attribute_values[i];
 846       else if (IS_ATTRIBUTE (attr, BOOKMARK_TIMESTAMP_ATTRIBUTE))
 847         stamp = attribute_values[i];
 848       else if (IS_ATTRIBUTE (attr, BOOKMARK_MODIFIED_ATTRIBUTE))
 849         modified = attribute_values[i];
 850     }
 851 
 852   /* the &quot;name&quot; and &quot;exec&quot; attributes are mandatory */
 853   if (!name)
 854     {
 855       g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified"> 856                    G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified"> 857                    _(&quot;Attribute &#39;%s&#39; of element &#39;%s&#39; not found&quot;),</span>
<span class="line-modified"> 858                    BOOKMARK_NAME_ATTRIBUTE,</span>
<span class="line-modified"> 859                    BOOKMARK_APPLICATION_ELEMENT);</span>
 860       return;
 861     }
 862 
 863   if (!exec)
 864     {
 865       g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified"> 866                    G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified"> 867                    _(&quot;Attribute &#39;%s&#39; of element &#39;%s&#39; not found&quot;),</span>
<span class="line-modified"> 868                    BOOKMARK_EXEC_ATTRIBUTE,</span>
<span class="line-modified"> 869                    BOOKMARK_APPLICATION_ELEMENT);</span>
 870       return;
 871     }
 872 
 873   g_warn_if_fail (parse_data-&gt;current_item != NULL);
 874   item = parse_data-&gt;current_item;
 875 
 876   ai = bookmark_item_lookup_app_info (item, name);
 877   if (!ai)
 878     {
 879       ai = bookmark_app_info_new (name);
 880 #ifdef GSTREAMER_LITE
 881       if (ai == NULL) {
 882           g_set_error (error, G_MARKUP_ERROR,
 883                G_MARKUP_ERROR_INVALID_CONTENT,
 884                _(&quot;AI is NULL&quot;));
 885           return;
 886       }
 887 #endif // GSTREAMER_LITE
 888 
 889       if (!item-&gt;metadata)
<span class="line-modified"> 890         item-&gt;metadata = bookmark_metadata_new ();</span>
 891 
 892       item-&gt;metadata-&gt;applications = g_list_prepend (item-&gt;metadata-&gt;applications, ai);
 893       g_hash_table_replace (item-&gt;metadata-&gt;apps_by_name, ai-&gt;name, ai);
 894     }
 895 
 896   g_free (ai-&gt;exec);
 897   ai-&gt;exec = g_strdup (exec);
 898 
 899   if (count)
 900     ai-&gt;count = atoi (count);
 901   else
 902     ai-&gt;count = 1;
 903 
<span class="line-modified"> 904   if (modified)</span>
<span class="line-modified"> 905     ai-&gt;stamp = timestamp_from_iso8601 (modified);</span>



 906   else
 907     {
 908       /* the timestamp attribute has been deprecated but we still parse
 909        * it for backward compatibility
 910        */
 911       if (stamp)
 912         ai-&gt;stamp = (time_t) atol (stamp);
 913       else
 914         ai-&gt;stamp = time (NULL);
 915     }
 916 }
 917 
 918 static void
 919 parse_mime_type_element (GMarkupParseContext  *context,
<span class="line-modified"> 920              ParseData            *parse_data,</span>
<span class="line-modified"> 921              const gchar         **attribute_names,</span>
<span class="line-modified"> 922              const gchar         **attribute_values,</span>
<span class="line-modified"> 923              GError              **error)</span>
 924 {
 925   const gchar *type;
 926   const gchar *attr;
 927   gint i;
 928   BookmarkItem *item;
 929 
 930   g_warn_if_fail ((parse_data != NULL) &amp;&amp; (parse_data-&gt;state == STATE_MIME));
 931 
 932   i = 0;
 933   type = NULL;
 934   for (attr = attribute_names[i]; attr != NULL; attr = attribute_names[++i])
 935     {
 936       if (IS_ATTRIBUTE (attr, MIME_TYPE_ATTRIBUTE))
 937         type = attribute_values[i];
 938     }
 939 
 940   if (!type)
 941     type = &quot;application/octet-stream&quot;;
 942 
 943   g_warn_if_fail (parse_data-&gt;current_item != NULL);
 944   item = parse_data-&gt;current_item;
 945 
 946   if (!item-&gt;metadata)
 947     item-&gt;metadata = bookmark_metadata_new ();
 948 
 949   g_free (item-&gt;metadata-&gt;mime_type);
 950   item-&gt;metadata-&gt;mime_type = g_strdup (type);
 951 }
 952 
 953 static void
 954 parse_icon_element (GMarkupParseContext  *context,
<span class="line-modified"> 955             ParseData            *parse_data,</span>
<span class="line-modified"> 956             const gchar         **attribute_names,</span>
<span class="line-modified"> 957             const gchar         **attribute_values,</span>
<span class="line-modified"> 958             GError              **error)</span>
 959 {
 960   const gchar *href;
 961   const gchar *type;
 962   const gchar *attr;
 963   gint i;
 964   BookmarkItem *item;
 965 
 966   g_warn_if_fail ((parse_data != NULL) &amp;&amp; (parse_data-&gt;state == STATE_ICON));
 967 
 968   i = 0;
 969   href = NULL;
 970   type = NULL;
 971   for (attr = attribute_names[i]; attr != NULL; attr = attribute_names[++i])
 972     {
 973       if (IS_ATTRIBUTE (attr, BOOKMARK_HREF_ATTRIBUTE))
 974         href = attribute_values[i];
 975       else if (IS_ATTRIBUTE (attr, BOOKMARK_TYPE_ATTRIBUTE))
 976         type = attribute_values[i];
 977     }
 978 
 979   /* the &quot;href&quot; attribute is mandatory */
 980   if (!href)
 981     {
 982       g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified"> 983                    G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified"> 984                    _(&quot;Attribute &#39;%s&#39; of element &#39;%s&#39; not found&quot;),</span>
<span class="line-modified"> 985                    BOOKMARK_HREF_ATTRIBUTE,</span>
<span class="line-modified"> 986                    BOOKMARK_ICON_ELEMENT);</span>
 987       return;
 988     }
 989 
 990   if (!type)
 991     type = &quot;application/octet-stream&quot;;
 992 
 993   g_warn_if_fail (parse_data-&gt;current_item != NULL);
 994   item = parse_data-&gt;current_item;
 995 
 996   if (!item-&gt;metadata)
 997     item-&gt;metadata = bookmark_metadata_new ();
 998 
 999   g_free (item-&gt;metadata-&gt;icon_href);
1000   g_free (item-&gt;metadata-&gt;icon_mime);
1001   item-&gt;metadata-&gt;icon_href = g_strdup (href);
1002   item-&gt;metadata-&gt;icon_mime = g_strdup (type);
1003 }
1004 
1005 /* scans through the attributes of an element for the &quot;xmlns&quot; pragma, and
1006  * adds any resulting namespace declaration to a per-parser hashtable, using
1007  * the namespace name as a key for the namespace URI; if no key was found,
1008  * the namespace is considered as default, and stored under the &quot;default&quot; key.
1009  *
1010  * FIXME: this works on the assumption that the generator of the XBEL file
1011  * is either this code or is smart enough to place the namespace declarations
1012  * inside the main root node or inside the metadata node and does not redefine
1013  * a namespace inside an inner node; this does *not* conform to the
1014  * XML-NS standard, although is a close approximation.  In order to make this
1015  * conformant to the XML-NS specification we should use a per-element
1016  * namespace table inside GMarkup and ask it to resolve the namespaces for us.
1017  */
1018 static void
1019 map_namespace_to_name (ParseData    *parse_data,
1020                        const gchar **attribute_names,
<span class="line-modified">1021                const gchar **attribute_values)</span>
1022 {
1023   const gchar *attr;
1024   gint i;
1025 
1026   g_warn_if_fail (parse_data != NULL);
1027 
1028   if (!attribute_names || !attribute_names[0])
1029     return;
1030 
1031   i = 0;
1032   for (attr = attribute_names[i]; attr; attr = attribute_names[++i])
1033     {
1034       if (g_str_has_prefix (attr, &quot;xmlns&quot;))
1035         {
1036           gchar *namespace_name, *namespace_uri;
1037           gchar *p;
1038 
1039           p = g_utf8_strchr (attr, -1, &#39;:&#39;);
1040           if (p)
1041             p = g_utf8_next_char (p);
</pre>
<hr />
<pre>
1096       element_name = element_full;
1097     }
1098 
1099   ns_uri = g_hash_table_lookup (parse_data-&gt;namespaces, ns_name);
1100   if (!ns_uri)
1101     {
1102       /* no default namespace found */
1103       g_free (ns_name);
1104 
1105       return (0 == strcmp (element_full, element));
1106     }
1107 
1108   retval = (0 == strcmp (ns_uri, namespace) &amp;&amp;
1109             0 == strcmp (element_name, element));
1110 
1111   g_free (ns_name);
1112 
1113   return retval;
1114 }
1115 
<span class="line-modified">1116 #define IS_ELEMENT(p,s,e)   (is_element_full ((p), (s), NULL, (e), &#39;\0&#39;))</span>
1117 #define IS_ELEMENT_NS(p,s,n,e)  (is_element_full ((p), (s), (n), (e), &#39;|&#39;))
1118 
1119 static const gchar *
1120 parser_state_to_element_name (ParserState state)
1121 {
1122   switch (state)
1123     {
1124     case STATE_STARTED:
1125     case STATE_FINISHED:
1126       return &quot;(top-level)&quot;;
1127     case STATE_ROOT:
1128       return XBEL_ROOT_ELEMENT;
1129     case STATE_BOOKMARK:
1130       return XBEL_BOOKMARK_ELEMENT;
1131     case STATE_TITLE:
1132       return XBEL_TITLE_ELEMENT;
1133     case STATE_DESC:
1134       return XBEL_DESC_ELEMENT;
1135     case STATE_INFO:
1136       return XBEL_INFO_ELEMENT;
</pre>
<hr />
<pre>
1169    * only on the root node, where they usually are; this would probably break
1170    * on streams not produced by us or by &quot;smart&quot; generators
1171    */
1172   map_namespace_to_name (parse_data, attribute_names, attribute_values);
1173 
1174   switch (parse_data-&gt;state)
1175     {
1176     case STATE_STARTED:
1177       if (IS_ELEMENT (parse_data, element_name, XBEL_ROOT_ELEMENT))
1178         {
1179           const gchar *attr;
1180           gint i;
1181 
1182           i = 0;
1183           for (attr = attribute_names[i]; attr; attr = attribute_names[++i])
1184             {
1185               if ((IS_ATTRIBUTE (attr, XBEL_VERSION_ATTRIBUTE)) &amp;&amp;
1186                   (0 == strcmp (attribute_values[i], XBEL_VERSION)))
1187                 parse_data-&gt;state = STATE_ROOT;
1188             }
<span class="line-modified">1189     }</span>
1190       else
1191         g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified">1192                      G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified">1193                      _(&quot;Unexpected tag &#39;%s&#39;, tag &#39;%s&#39; expected&quot;),</span>
<span class="line-modified">1194                      element_name, XBEL_ROOT_ELEMENT);</span>
1195       break;
1196     case STATE_ROOT:
1197       if (IS_ELEMENT (parse_data, element_name, XBEL_TITLE_ELEMENT))
1198         parse_data-&gt;state = STATE_TITLE;
1199       else if (IS_ELEMENT (parse_data, element_name, XBEL_DESC_ELEMENT))
1200         parse_data-&gt;state = STATE_DESC;
1201       else if (IS_ELEMENT (parse_data, element_name, XBEL_BOOKMARK_ELEMENT))
1202         {
1203           GError *inner_error = NULL;
1204 
1205           parse_data-&gt;state = STATE_BOOKMARK;
1206 
1207           parse_bookmark_element (context,
<span class="line-modified">1208                       parse_data,</span>
<span class="line-modified">1209                       attribute_names,</span>
<span class="line-modified">1210                       attribute_values,</span>
<span class="line-modified">1211                       &amp;inner_error);</span>
1212           if (inner_error)
1213             g_propagate_error (error, inner_error);
1214         }
1215       else
1216         g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified">1217                      G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified">1218                      _(&quot;Unexpected tag &#39;%s&#39; inside &#39;%s&#39;&quot;),</span>
<span class="line-modified">1219                      element_name,</span>
<span class="line-modified">1220                      XBEL_ROOT_ELEMENT);</span>
1221       break;
1222     case STATE_BOOKMARK:
1223       if (IS_ELEMENT (parse_data, element_name, XBEL_TITLE_ELEMENT))
1224         parse_data-&gt;state = STATE_TITLE;
1225       else if (IS_ELEMENT (parse_data, element_name, XBEL_DESC_ELEMENT))
1226         parse_data-&gt;state = STATE_DESC;
1227       else if (IS_ELEMENT (parse_data, element_name, XBEL_INFO_ELEMENT))
1228         parse_data-&gt;state = STATE_INFO;
1229       else
1230         g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified">1231                      G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified">1232                      _(&quot;Unexpected tag &#39;%s&#39; inside &#39;%s&#39;&quot;),</span>
<span class="line-modified">1233                      element_name,</span>
<span class="line-modified">1234                      XBEL_BOOKMARK_ELEMENT);</span>
1235       break;
1236     case STATE_INFO:
1237       if (IS_ELEMENT (parse_data, element_name, XBEL_METADATA_ELEMENT))
1238         {
1239           const gchar *attr;
1240           gint i;
1241 
1242           i = 0;
1243           for (attr = attribute_names[i]; attr; attr = attribute_names[++i])
1244             {
1245               if ((IS_ATTRIBUTE (attr, XBEL_OWNER_ATTRIBUTE)) &amp;&amp;
1246                   (0 == strcmp (attribute_values[i], BOOKMARK_METADATA_OWNER)))
1247                 {
1248                   parse_data-&gt;state = STATE_METADATA;
1249 
1250                   if (!parse_data-&gt;current_item-&gt;metadata)
1251                     parse_data-&gt;current_item-&gt;metadata = bookmark_metadata_new ();
1252                 }
1253             }
1254         }
1255       else
1256         g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified">1257                      G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified">1258                      _(&quot;Unexpected tag &#39;%s&#39;, tag &#39;%s&#39; expected&quot;),</span>
<span class="line-modified">1259                      element_name,</span>
<span class="line-modified">1260                      XBEL_METADATA_ELEMENT);</span>
1261       break;
1262     case STATE_METADATA:
1263       if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_APPLICATIONS_ELEMENT))
1264         parse_data-&gt;state = STATE_APPLICATIONS;
1265       else if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_GROUPS_ELEMENT))
1266         parse_data-&gt;state = STATE_GROUPS;
1267       else if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_PRIVATE_ELEMENT))
1268         parse_data-&gt;current_item-&gt;metadata-&gt;is_private = TRUE;
1269       else if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_ICON_ELEMENT))
1270         {
1271           GError *inner_error = NULL;
1272 
<span class="line-modified">1273       parse_data-&gt;state = STATE_ICON;</span>
1274 
1275           parse_icon_element (context,
<span class="line-modified">1276                       parse_data,</span>
<span class="line-modified">1277                       attribute_names,</span>
<span class="line-modified">1278                       attribute_values,</span>
<span class="line-modified">1279                       &amp;inner_error);</span>
1280           if (inner_error)
1281             g_propagate_error (error, inner_error);
1282         }
1283       else if (IS_ELEMENT_NS (parse_data, element_name, MIME_NAMESPACE_URI, MIME_TYPE_ELEMENT))
1284         {
1285           GError *inner_error = NULL;
1286 
1287           parse_data-&gt;state = STATE_MIME;
1288 
1289           parse_mime_type_element (context,
<span class="line-modified">1290                        parse_data,</span>
<span class="line-modified">1291                        attribute_names,</span>
<span class="line-modified">1292                        attribute_values,</span>
<span class="line-modified">1293                        &amp;inner_error);</span>
1294           if (inner_error)
1295             g_propagate_error (error, inner_error);
1296         }
1297       else
1298         g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified">1299                      G_MARKUP_ERROR_UNKNOWN_ELEMENT,</span>
<span class="line-modified">1300                      _(&quot;Unexpected tag &#39;%s&#39; inside &#39;%s&#39;&quot;),</span>
<span class="line-modified">1301                     element_name,</span>
<span class="line-modified">1302                     XBEL_METADATA_ELEMENT);</span>
1303       break;
1304     case STATE_APPLICATIONS:
1305       if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_APPLICATION_ELEMENT))
1306         {
1307           GError *inner_error = NULL;
1308 
1309           parse_data-&gt;state = STATE_APPLICATION;
1310 
1311           parse_application_element (context,
<span class="line-modified">1312                          parse_data,</span>
<span class="line-modified">1313                          attribute_names,</span>
<span class="line-modified">1314                          attribute_values,</span>
<span class="line-modified">1315                          &amp;inner_error);</span>
1316           if (inner_error)
1317             g_propagate_error (error, inner_error);
1318         }
1319       else
1320         g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified">1321                      G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified">1322                      _(&quot;Unexpected tag &#39;%s&#39;, tag &#39;%s&#39; expected&quot;),</span>
<span class="line-modified">1323                      element_name,</span>
<span class="line-modified">1324                      BOOKMARK_APPLICATION_ELEMENT);</span>
1325       break;
1326     case STATE_GROUPS:
1327       if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_GROUP_ELEMENT))
1328         parse_data-&gt;state = STATE_GROUP;
1329       else
1330         g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified">1331                      G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified">1332                      _(&quot;Unexpected tag &#39;%s&#39;, tag &#39;%s&#39; expected&quot;),</span>
<span class="line-modified">1333                      element_name,</span>
<span class="line-modified">1334                      BOOKMARK_GROUP_ELEMENT);</span>
1335       break;
1336 
1337     case STATE_TITLE:
1338     case STATE_DESC:
1339     case STATE_APPLICATION:
1340     case STATE_GROUP:
1341     case STATE_MIME:
1342     case STATE_ICON:
1343     case STATE_FINISHED:
1344       g_set_error (error, G_MARKUP_ERROR,
1345                    G_MARKUP_ERROR_INVALID_CONTENT,
1346                    _(&quot;Unexpected tag &#39;%s&#39; inside &#39;%s&#39;&quot;),
1347                    element_name,
1348                    parser_state_to_element_name (parse_data-&gt;state));
1349       break;
1350 
1351     default:
1352       g_assert_not_reached ();
1353       break;
1354     }
</pre>
<hr />
<pre>
1460       break;
1461     default:
1462       g_warn_if_reached ();
1463       break;
1464     }
1465 
1466   g_free (payload);
1467 }
1468 
1469 static const GMarkupParser markup_parser =
1470 {
1471   start_element_raw_cb, /* start_element */
1472   end_element_raw_cb,   /* end_element */
1473   text_raw_cb,          /* text */
1474   NULL,                 /* passthrough */
1475   NULL
1476 };
1477 
1478 static gboolean
1479 g_bookmark_file_parse (GBookmarkFile  *bookmark,
<span class="line-modified">1480              const gchar  *buffer,</span>
<span class="line-modified">1481              gsize         length,</span>
<span class="line-modified">1482              GError       **error)</span>
1483 {
1484   GMarkupParseContext *context;
1485   ParseData *parse_data;
1486   GError *parse_error, *end_error;
1487   gboolean retval;
1488 
1489   g_warn_if_fail (bookmark != NULL);
1490 
1491   if (!buffer)
1492     return FALSE;
1493 
1494   parse_error = NULL;
1495   end_error = NULL;
1496 
1497   if (length == (gsize) -1)
1498     length = strlen (buffer);
1499 
1500   parse_data = parse_data_new ();
1501   parse_data-&gt;bookmark_file = bookmark;
1502 
1503   context = g_markup_parse_context_new (&amp;markup_parser,
<span class="line-modified">1504                     0,</span>
<span class="line-modified">1505                     parse_data,</span>
<span class="line-modified">1506                     (GDestroyNotify) parse_data_free);</span>
1507 
1508   retval = g_markup_parse_context_parse (context,
<span class="line-modified">1509                      buffer,</span>
<span class="line-modified">1510                      length,</span>
<span class="line-modified">1511                      &amp;parse_error);</span>
1512   if (!retval)
1513     g_propagate_error (error, parse_error);
1514   else
1515    {
1516      retval = g_markup_parse_context_end_parse (context, &amp;end_error);
1517       if (!retval)
1518         g_propagate_error (error, end_error);
1519    }
1520 
1521   g_markup_parse_context_free (context);
1522 
1523   return retval;
1524 }
1525 
1526 static gchar *
1527 g_bookmark_file_dump (GBookmarkFile  *bookmark,
<span class="line-modified">1528               gsize          *length,</span>
<span class="line-modified">1529               GError        **error)</span>
1530 {
1531   GString *retval;
1532   gchar *buffer;
1533   GList *l;
1534 
1535   retval = g_string_sized_new (4096);
1536 
1537   g_string_append (retval,
<span class="line-modified">1538            &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;</span>
1539 #if 0
<span class="line-modified">1540            /* XXX - do we really need the doctype? */</span>
<span class="line-modified">1541            &quot;&lt;!DOCTYPE &quot; XBEL_DTD_NICK &quot;\n&quot;</span>
<span class="line-modified">1542            &quot;  PUBLIC \&quot;&quot; XBEL_DTD_SYSTEM &quot;\&quot;\n&quot;</span>
<span class="line-modified">1543            &quot;         \&quot;&quot; XBEL_DTD_URI &quot;\&quot;&gt;\n&quot;</span>
1544 #endif
<span class="line-modified">1545            &quot;&lt;&quot; XBEL_ROOT_ELEMENT &quot; &quot; XBEL_VERSION_ATTRIBUTE &quot;=\&quot;&quot; XBEL_VERSION &quot;\&quot;\n&quot;</span>
<span class="line-modified">1546            &quot;      xmlns:&quot; BOOKMARK_NAMESPACE_NAME &quot;=\&quot;&quot; BOOKMARK_NAMESPACE_URI &quot;\&quot;\n&quot;</span>
<span class="line-modified">1547            &quot;      xmlns:&quot; MIME_NAMESPACE_NAME     &quot;=\&quot;&quot; MIME_NAMESPACE_URI &quot;\&quot;\n&gt;&quot;);</span>
1548 
1549   if (bookmark-&gt;title)
1550     {
1551       gchar *escaped_title;
1552 
1553       escaped_title = g_markup_escape_text (bookmark-&gt;title, -1);
1554 
1555       buffer = g_strconcat (&quot;  &quot;
<span class="line-modified">1556                 &quot;&lt;&quot; XBEL_TITLE_ELEMENT &quot;&gt;&quot;,</span>
<span class="line-modified">1557                 escaped_title,</span>
<span class="line-modified">1558                 &quot;&lt;/&quot; XBEL_TITLE_ELEMENT &quot;&gt;\n&quot;, NULL);</span>
1559 
1560       g_string_append (retval, buffer);
1561 
1562       g_free (buffer);
1563       g_free (escaped_title);
1564     }
1565 
1566   if (bookmark-&gt;description)
1567     {
1568       gchar *escaped_desc;
1569 
1570       escaped_desc = g_markup_escape_text (bookmark-&gt;description, -1);
1571 
1572       buffer = g_strconcat (&quot;  &quot;
<span class="line-modified">1573                 &quot;&lt;&quot; XBEL_DESC_ELEMENT &quot;&gt;&quot;,</span>
<span class="line-modified">1574                 escaped_desc,</span>
<span class="line-modified">1575                 &quot;&lt;/&quot; XBEL_DESC_ELEMENT &quot;&gt;\n&quot;, NULL);</span>
1576       g_string_append (retval, buffer);
1577 
1578       g_free (buffer);
1579       g_free (escaped_desc);
1580     }
1581 
1582   if (!bookmark-&gt;items)
1583     goto out;
1584   else
1585     retval = g_string_append (retval, &quot;\n&quot;);
1586 
1587   /* the items are stored in reverse order */
1588   for (l = g_list_last (bookmark-&gt;items);
1589        l != NULL;
1590        l = l-&gt;prev)
1591     {
1592       BookmarkItem *item = (BookmarkItem *) l-&gt;data;
1593       gchar *item_dump;
1594 
1595       item_dump = bookmark_item_dump (item);
</pre>
<hr />
<pre>
1603 
1604 out:
1605   g_string_append (retval, &quot;&lt;/&quot; XBEL_ROOT_ELEMENT &quot;&gt;&quot;);
1606 
1607   if (length)
1608     *length = retval-&gt;len;
1609 
1610   return g_string_free (retval, FALSE);
1611 }
1612 
1613 /**************
1614  *    Misc    *
1615  **************/
1616 
1617 /* converts a Unix timestamp in a ISO 8601 compliant string; you
1618  * should free the returned string.
1619  */
1620 static gchar *
1621 timestamp_to_iso8601 (time_t timestamp)
1622 {
<span class="line-modified">1623   GTimeVal stamp;</span>


1624 
<span class="line-modified">1625   if (timestamp == (time_t) -1)</span>
<span class="line-removed">1626     g_get_current_time (&amp;stamp);</span>
<span class="line-removed">1627   else</span>
<span class="line-removed">1628     {</span>
<span class="line-removed">1629       stamp.tv_sec = timestamp;</span>
<span class="line-removed">1630       stamp.tv_usec = 0;</span>
<span class="line-removed">1631     }</span>
<span class="line-removed">1632 </span>
<span class="line-removed">1633   return g_time_val_to_iso8601 (&amp;stamp);</span>
1634 }
1635 
<span class="line-modified">1636 static time_t</span>
<span class="line-modified">1637 timestamp_from_iso8601 (const gchar *iso_date)</span>


1638 {
<span class="line-modified">1639   GTimeVal stamp;</span>







1640 
<span class="line-modified">1641   if (!g_time_val_from_iso8601 (iso_date, &amp;stamp))</span>
<span class="line-modified">1642     return (time_t) -1;</span>
1643 
<span class="line-modified">1644   return (time_t) stamp.tv_sec;</span>

1645 }
1646 
1647 G_DEFINE_QUARK (g-bookmark-file-error-quark, g_bookmark_file_error)
1648 
1649 /********************
1650  *    Public API    *
1651  ********************/
1652 
1653 /**
1654  * g_bookmark_file_new: (constructor)
1655  *
1656  * Creates a new empty #GBookmarkFile object.
1657  *
1658  * Use g_bookmark_file_load_from_file(), g_bookmark_file_load_from_data()
1659  * or g_bookmark_file_load_from_data_dirs() to read an existing bookmark
1660  * file.
1661  *
1662  * Returns: an empty #GBookmarkFile
1663  *
1664  * Since: 2.12
</pre>
<hr />
<pre>
1695 }
1696 
1697 /**
1698  * g_bookmark_file_load_from_data:
1699  * @bookmark: an empty #GBookmarkFile struct
1700  * @data: (array length=length) (element-type guint8): desktop bookmarks
1701  *    loaded in memory
1702  * @length: the length of @data in bytes
1703  * @error: return location for a #GError, or %NULL
1704  *
1705  * Loads a bookmark file from memory into an empty #GBookmarkFile
1706  * structure.  If the object cannot be created then @error is set to a
1707  * #GBookmarkFileError.
1708  *
1709  * Returns: %TRUE if a desktop bookmark could be loaded.
1710  *
1711  * Since: 2.12
1712  */
1713 gboolean
1714 g_bookmark_file_load_from_data (GBookmarkFile  *bookmark,
<span class="line-modified">1715                 const gchar    *data,</span>
<span class="line-modified">1716                 gsize           length,</span>
<span class="line-modified">1717                 GError        **error)</span>
1718 {
1719   GError *parse_error;
1720   gboolean retval;
1721 
1722   g_return_val_if_fail (bookmark != NULL, FALSE);
1723 
1724   if (length == (gsize) -1)
1725     length = strlen (data);
1726 
1727   if (bookmark-&gt;items)
1728     {
1729       g_bookmark_file_clear (bookmark);
1730       g_bookmark_file_init (bookmark);
1731     }
1732 
1733   parse_error = NULL;
1734   retval = g_bookmark_file_parse (bookmark, data, length, &amp;parse_error);
1735 
1736   if (!retval)
1737     g_propagate_error (error, parse_error);
</pre>
<hr />
<pre>
1739   return retval;
1740 }
1741 
1742 /**
1743  * g_bookmark_file_load_from_file:
1744  * @bookmark: an empty #GBookmarkFile struct
1745  * @filename: (type filename): the path of a filename to load, in the
1746  *     GLib file name encoding
1747  * @error: return location for a #GError, or %NULL
1748  *
1749  * Loads a desktop bookmark file into an empty #GBookmarkFile structure.
1750  * If the file could not be loaded then @error is set to either a #GFileError
1751  * or #GBookmarkFileError.
1752  *
1753  * Returns: %TRUE if a desktop bookmark file could be loaded
1754  *
1755  * Since: 2.12
1756  */
1757 gboolean
1758 g_bookmark_file_load_from_file (GBookmarkFile  *bookmark,
<span class="line-modified">1759                 const gchar    *filename,</span>
<span class="line-modified">1760                 GError        **error)</span>
1761 {
1762   gboolean ret = FALSE;
1763   gchar *buffer = NULL;
1764   gsize len;
1765 
1766   g_return_val_if_fail (bookmark != NULL, FALSE);
1767   g_return_val_if_fail (filename != NULL, FALSE);
1768 
1769   if (!g_file_get_contents (filename, &amp;buffer, &amp;len, error))
1770     goto out;
1771 
1772   if (!g_bookmark_file_load_from_data (bookmark, buffer, len, error))
1773     goto out;
1774 
1775   ret = TRUE;
1776  out:
1777   g_free (buffer);
1778   return ret;
1779 }
1780 
</pre>
<hr />
<pre>
1851 /**
1852  * g_bookmark_file_load_from_data_dirs:
1853  * @bookmark: a #GBookmarkFile
1854  * @file: (type filename): a relative path to a filename to open and parse
1855  * @full_path: (out) (optional) (type filename): return location for a string
1856  *    containing the full path of the file, or %NULL
1857  * @error: return location for a #GError, or %NULL
1858  *
1859  * This function looks for a desktop bookmark file named @file in the
1860  * paths returned from g_get_user_data_dir() and g_get_system_data_dirs(),
1861  * loads the file into @bookmark and returns the file&#39;s full path in
1862  * @full_path.  If the file could not be loaded then @error is
1863  * set to either a #GFileError or #GBookmarkFileError.
1864  *
1865  * Returns: %TRUE if a key file could be loaded, %FALSE otherwise
1866  *
1867  * Since: 2.12
1868  */
1869 gboolean
1870 g_bookmark_file_load_from_data_dirs (GBookmarkFile  *bookmark,
<span class="line-modified">1871                      const gchar    *file,</span>
<span class="line-modified">1872                      gchar         **full_path,</span>
<span class="line-modified">1873                      GError        **error)</span>
1874 {
1875   GError *file_error = NULL;
1876   gchar **all_data_dirs, **data_dirs;
1877   const gchar *user_data_dir;
1878   const gchar * const * system_data_dirs;
1879   gsize i, j;
1880   gchar *output_path;
1881   gboolean found_file;
1882 
1883   g_return_val_if_fail (bookmark != NULL, FALSE);
1884   g_return_val_if_fail (!g_path_is_absolute (file), FALSE);
1885 
1886   user_data_dir = g_get_user_data_dir ();
1887   system_data_dirs = g_get_system_data_dirs ();
1888   all_data_dirs = g_new0 (gchar *, g_strv_length ((gchar **)system_data_dirs) + 2);
1889 
1890   i = 0;
1891   all_data_dirs[i++] = g_strdup (user_data_dir);
1892 
1893   j = 0;
1894   while (system_data_dirs[j] != NULL)
1895     all_data_dirs[i++] = g_strdup (system_data_dirs[j++]);
1896 
1897   found_file = FALSE;
1898   data_dirs = all_data_dirs;
1899   output_path = NULL;
1900   while (*data_dirs != NULL &amp;&amp; !found_file)
1901     {
1902       g_free (output_path);
1903 
1904       output_path = find_file_in_data_dirs (file, &amp;data_dirs, &amp;file_error);
1905 
1906       if (file_error)
1907         {
1908           g_propagate_error (error, file_error);
<span class="line-modified">1909       break;</span>
1910         }
1911 
1912       found_file = g_bookmark_file_load_from_file (bookmark,
<span class="line-modified">1913                                output_path,</span>
<span class="line-modified">1914                                &amp;file_error);</span>
1915       if (file_error)
1916         {
<span class="line-modified">1917       g_propagate_error (error, file_error);</span>
<span class="line-modified">1918       break;</span>
1919         }
1920     }
1921 
1922   if (found_file &amp;&amp; full_path)
1923     *full_path = output_path;
1924   else
1925     g_free (output_path);
1926 
1927   g_strfreev (all_data_dirs);
1928 
1929   return found_file;
1930 }
1931 
1932 
1933 /**
1934  * g_bookmark_file_to_data:
1935  * @bookmark: a #GBookmarkFile
1936  * @length: (out) (optional): return location for the length of the returned string, or %NULL
1937  * @error: return location for a #GError, or %NULL
1938  *
1939  * This function outputs @bookmark as a string.
1940  *
1941  * Returns: (array length=length) (element-type guint8):
1942  *   a newly allocated string holding the contents of the #GBookmarkFile
1943  *
1944  * Since: 2.12
1945  */
1946 gchar *
1947 g_bookmark_file_to_data (GBookmarkFile  *bookmark,
<span class="line-modified">1948              gsize          *length,</span>
<span class="line-modified">1949              GError        **error)</span>
1950 {
1951   GError *write_error = NULL;
1952   gchar *retval;
1953 
1954   g_return_val_if_fail (bookmark != NULL, NULL);
1955 
1956   retval = g_bookmark_file_dump (bookmark, length, &amp;write_error);
1957   if (write_error)
1958     {
1959       g_propagate_error (error, write_error);
1960 
1961       return NULL;
1962     }
1963 
1964   return retval;
1965 }
1966 
1967 /**
1968  * g_bookmark_file_to_file:
1969  * @bookmark: a #GBookmarkFile
1970  * @filename: (type filename): path of the output file
1971  * @error: return location for a #GError, or %NULL
1972  *
1973  * This function outputs @bookmark into a file.  The write process is
1974  * guaranteed to be atomic by using g_file_set_contents() internally.
1975  *
1976  * Returns: %TRUE if the file was successfully written.
1977  *
1978  * Since: 2.12
1979  */
1980 gboolean
1981 g_bookmark_file_to_file (GBookmarkFile  *bookmark,
<span class="line-modified">1982              const gchar    *filename,</span>
<span class="line-modified">1983              GError        **error)</span>
1984 {
1985   gchar *data;
1986   GError *data_error, *write_error;
1987   gsize len;
1988   gboolean retval;
1989 
1990   g_return_val_if_fail (bookmark != NULL, FALSE);
1991   g_return_val_if_fail (filename != NULL, FALSE);
1992 
1993   data_error = NULL;
1994   data = g_bookmark_file_to_data (bookmark, &amp;len, &amp;data_error);
1995   if (data_error)
1996     {
1997       g_propagate_error (error, data_error);
1998 
1999       return FALSE;
2000     }
2001 
2002   write_error = NULL;
2003   g_file_set_contents (filename, data, len, &amp;write_error);
2004   if (write_error)
2005     {
2006       g_propagate_error (error, write_error);
2007 
2008       retval = FALSE;
2009     }
2010   else
2011     retval = TRUE;
2012 
2013   g_free (data);
2014 
2015   return retval;
2016 }
2017 
2018 static BookmarkItem *
2019 g_bookmark_file_lookup_item (GBookmarkFile *bookmark,
<span class="line-modified">2020                  const gchar   *uri)</span>
2021 {
2022   g_warn_if_fail (bookmark != NULL &amp;&amp; uri != NULL);
2023 
2024   return g_hash_table_lookup (bookmark-&gt;items_by_uri, uri);
2025 }
2026 
2027 /* this function adds a new item to the list */
2028 static void
2029 g_bookmark_file_add_item (GBookmarkFile  *bookmark,
<span class="line-modified">2030               BookmarkItem   *item,</span>
<span class="line-modified">2031               GError        **error)</span>
2032 {
2033   g_warn_if_fail (bookmark != NULL);
2034   g_warn_if_fail (item != NULL);
2035 
2036 #ifdef GSTREAMER_LITE
2037   if (bookmark == NULL || item == NULL) {
2038     return;
2039   }
2040 #endif // GSTREAMER_LITE
2041 
2042   /* this should never happen; and if it does, then we are
2043    * screwing up something big time.
2044    */
2045   if (G_UNLIKELY (g_bookmark_file_has_item (bookmark, item-&gt;uri)))
2046     {
2047       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2048                    G_BOOKMARK_FILE_ERROR_INVALID_URI,</span>
<span class="line-modified">2049                    _(&quot;A bookmark for URI &#39;%s&#39; already exists&quot;),</span>
<span class="line-modified">2050                    item-&gt;uri);</span>
2051       return;
2052     }
2053 
2054   bookmark-&gt;items = g_list_prepend (bookmark-&gt;items, item);
2055 
2056   g_hash_table_replace (bookmark-&gt;items_by_uri,
<span class="line-modified">2057             item-&gt;uri,</span>
<span class="line-modified">2058             item);</span>
2059 
2060   if (item-&gt;added == (time_t) -1)
2061     item-&gt;added = time (NULL);
2062 
2063   if (item-&gt;modified == (time_t) -1)
2064     item-&gt;modified = time (NULL);
2065 }
2066 
2067 /**
2068  * g_bookmark_file_remove_item:
2069  * @bookmark: a #GBookmarkFile
2070  * @uri: a valid URI
2071  * @error: return location for a #GError, or %NULL
2072  *
2073  * Removes the bookmark for @uri from the bookmark file @bookmark.
2074  *
2075  * Returns: %TRUE if the bookmark was removed successfully.
2076  *
2077  * Since: 2.12
2078  */
2079 gboolean
2080 g_bookmark_file_remove_item (GBookmarkFile  *bookmark,
<span class="line-modified">2081                  const gchar    *uri,</span>
<span class="line-modified">2082                  GError        **error)</span>
2083 {
2084   BookmarkItem *item;
2085 
2086   g_return_val_if_fail (bookmark != NULL, FALSE);
2087   g_return_val_if_fail (uri != NULL, FALSE);
2088 
2089   item = g_bookmark_file_lookup_item (bookmark, uri);
2090 
2091   if (!item)
2092     {
2093       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2094                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2095                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2096                    uri);</span>
2097       return FALSE;
2098     }
2099 
2100   bookmark-&gt;items = g_list_remove (bookmark-&gt;items, item);
2101   g_hash_table_remove (bookmark-&gt;items_by_uri, item-&gt;uri);
2102 
2103   bookmark_item_free (item);
2104 
2105   return TRUE;
2106 }
2107 
2108 /**
2109  * g_bookmark_file_has_item:
2110  * @bookmark: a #GBookmarkFile
2111  * @uri: a valid URI
2112  *
2113  * Looks whether the desktop bookmark has an item with its URI set to @uri.
2114  *
2115  * Returns: %TRUE if @uri is inside @bookmark, %FALSE otherwise
2116  *
2117  * Since: 2.12
2118  */
2119 gboolean
2120 g_bookmark_file_has_item (GBookmarkFile *bookmark,
<span class="line-modified">2121               const gchar   *uri)</span>
2122 {
2123   g_return_val_if_fail (bookmark != NULL, FALSE);
2124   g_return_val_if_fail (uri != NULL, FALSE);
2125 
2126   return (NULL != g_hash_table_lookup (bookmark-&gt;items_by_uri, uri));
2127 }
2128 
2129 /**
2130  * g_bookmark_file_get_uris:
2131  * @bookmark: a #GBookmarkFile
2132  * @length: (out) (optional): return location for the number of returned URIs, or %NULL
2133  *
2134  * Returns all URIs of the bookmarks in the bookmark file @bookmark.
2135  * The array of returned URIs will be %NULL-terminated, so @length may
2136  * optionally be %NULL.
2137  *
2138  * Returns: (array length=length) (transfer full): a newly allocated %NULL-terminated array of strings.
2139  *   Use g_strfreev() to free it.
2140  *
2141  * Since: 2.12
2142  */
2143 gchar **
2144 g_bookmark_file_get_uris (GBookmarkFile *bookmark,
<span class="line-modified">2145               gsize         *length)</span>
2146 {
2147   GList *l;
2148   gchar **uris;
2149   gsize i, n_items;
2150 
2151   g_return_val_if_fail (bookmark != NULL, NULL);
2152 
2153   n_items = g_list_length (bookmark-&gt;items);
2154   uris = g_new0 (gchar *, n_items + 1);
2155 
2156   /* the items are stored in reverse order, so we walk the list backward */
2157   for (l = g_list_last (bookmark-&gt;items), i = 0; l != NULL; l = l-&gt;prev)
2158     {
2159       BookmarkItem *item = (BookmarkItem *) l-&gt;data;
2160 
2161       g_warn_if_fail (item != NULL);
2162 
2163       uris[i++] = g_strdup (item-&gt;uri);
2164     }
2165   uris[i] = NULL;
</pre>
<hr />
<pre>
2170   return uris;
2171 }
2172 
2173 /**
2174  * g_bookmark_file_set_title:
2175  * @bookmark: a #GBookmarkFile
2176  * @uri: (nullable): a valid URI or %NULL
2177  * @title: a UTF-8 encoded string
2178  *
2179  * Sets @title as the title of the bookmark for @uri inside the
2180  * bookmark file @bookmark.
2181  *
2182  * If @uri is %NULL, the title of @bookmark is set.
2183  *
2184  * If a bookmark for @uri cannot be found then it is created.
2185  *
2186  * Since: 2.12
2187  */
2188 void
2189 g_bookmark_file_set_title (GBookmarkFile *bookmark,
<span class="line-modified">2190                const gchar   *uri,</span>
<span class="line-modified">2191                const gchar   *title)</span>
2192 {
2193   g_return_if_fail (bookmark != NULL);
2194 
2195   if (!uri)
2196     {
2197       g_free (bookmark-&gt;title);
2198       bookmark-&gt;title = g_strdup (title);
2199     }
2200   else
2201     {
2202       BookmarkItem *item;
2203 
2204       item = g_bookmark_file_lookup_item (bookmark, uri);
2205       if (!item)
2206         {
2207           item = bookmark_item_new (uri);
2208           g_bookmark_file_add_item (bookmark, item, NULL);
2209         }
2210 
2211       g_free (item-&gt;title);
</pre>
<hr />
<pre>
2218 /**
2219  * g_bookmark_file_get_title:
2220  * @bookmark: a #GBookmarkFile
2221  * @uri: (nullable): a valid URI or %NULL
2222  * @error: return location for a #GError, or %NULL
2223  *
2224  * Returns the title of the bookmark for @uri.
2225  *
2226  * If @uri is %NULL, the title of @bookmark is returned.
2227  *
2228  * In the event the URI cannot be found, %NULL is returned and
2229  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2230  *
2231  * Returns: a newly allocated string or %NULL if the specified
2232  *   URI cannot be found.
2233  *
2234  * Since: 2.12
2235  */
2236 gchar *
2237 g_bookmark_file_get_title (GBookmarkFile  *bookmark,
<span class="line-modified">2238                const gchar    *uri,</span>
<span class="line-modified">2239                GError        **error)</span>
2240 {
2241   BookmarkItem *item;
2242 
2243   g_return_val_if_fail (bookmark != NULL, NULL);
2244 
2245   if (!uri)
2246     return g_strdup (bookmark-&gt;title);
2247 
2248   item = g_bookmark_file_lookup_item (bookmark, uri);
2249   if (!item)
2250     {
2251       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2252                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2253                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2254                    uri);</span>
2255       return NULL;
2256     }
2257 
2258   return g_strdup (item-&gt;title);
2259 }
2260 
2261 /**
2262  * g_bookmark_file_set_description:
2263  * @bookmark: a #GBookmarkFile
2264  * @uri: (nullable): a valid URI or %NULL
2265  * @description: a string
2266  *
2267  * Sets @description as the description of the bookmark for @uri.
2268  *
2269  * If @uri is %NULL, the description of @bookmark is set.
2270  *
2271  * If a bookmark for @uri cannot be found then it is created.
2272  *
2273  * Since: 2.12
2274  */
2275 void
2276 g_bookmark_file_set_description (GBookmarkFile *bookmark,
<span class="line-modified">2277                  const gchar   *uri,</span>
<span class="line-modified">2278                  const gchar   *description)</span>
2279 {
2280   g_return_if_fail (bookmark != NULL);
2281 
2282   if (!uri)
2283     {
2284       g_free (bookmark-&gt;description);
2285       bookmark-&gt;description = g_strdup (description);
2286     }
2287   else
2288     {
2289       BookmarkItem *item;
2290 
2291       item = g_bookmark_file_lookup_item (bookmark, uri);
2292       if (!item)
2293         {
2294           item = bookmark_item_new (uri);
2295           g_bookmark_file_add_item (bookmark, item, NULL);
2296         }
2297 
2298       g_free (item-&gt;description);
</pre>
<hr />
<pre>
2303 }
2304 
2305 /**
2306  * g_bookmark_file_get_description:
2307  * @bookmark: a #GBookmarkFile
2308  * @uri: a valid URI
2309  * @error: return location for a #GError, or %NULL
2310  *
2311  * Retrieves the description of the bookmark for @uri.
2312  *
2313  * In the event the URI cannot be found, %NULL is returned and
2314  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2315  *
2316  * Returns: a newly allocated string or %NULL if the specified
2317  *   URI cannot be found.
2318  *
2319  * Since: 2.12
2320  */
2321 gchar *
2322 g_bookmark_file_get_description (GBookmarkFile  *bookmark,
<span class="line-modified">2323                  const gchar    *uri,</span>
<span class="line-modified">2324                  GError        **error)</span>
2325 {
2326   BookmarkItem *item;
2327 
2328   g_return_val_if_fail (bookmark != NULL, NULL);
2329 
2330   if (!uri)
2331     return g_strdup (bookmark-&gt;description);
2332 
2333   item = g_bookmark_file_lookup_item (bookmark, uri);
2334   if (!item)
2335     {
2336       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2337                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2338                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2339                    uri);</span>
2340       return NULL;
2341     }
2342 
2343   return g_strdup (item-&gt;description);
2344 }
2345 
2346 /**
2347  * g_bookmark_file_set_mime_type:
2348  * @bookmark: a #GBookmarkFile
2349  * @uri: a valid URI
2350  * @mime_type: a MIME type
2351  *
2352  * Sets @mime_type as the MIME type of the bookmark for @uri.
2353  *
2354  * If a bookmark for @uri cannot be found then it is created.
2355  *
2356  * Since: 2.12
2357  */
2358 void
2359 g_bookmark_file_set_mime_type (GBookmarkFile *bookmark,
<span class="line-modified">2360                    const gchar   *uri,</span>
<span class="line-modified">2361                    const gchar   *mime_type)</span>
2362 {
2363   BookmarkItem *item;
2364 
2365   g_return_if_fail (bookmark != NULL);
2366   g_return_if_fail (uri != NULL);
2367   g_return_if_fail (mime_type != NULL);
2368 
2369   item = g_bookmark_file_lookup_item (bookmark, uri);
2370   if (!item)
2371     {
2372       item = bookmark_item_new (uri);
2373       g_bookmark_file_add_item (bookmark, item, NULL);
2374     }
2375 
2376   if (!item-&gt;metadata)
2377     item-&gt;metadata = bookmark_metadata_new ();
2378 
2379   g_free (item-&gt;metadata-&gt;mime_type);
2380 
2381   item-&gt;metadata-&gt;mime_type = g_strdup (mime_type);
</pre>
<hr />
<pre>
2385 /**
2386  * g_bookmark_file_get_mime_type:
2387  * @bookmark: a #GBookmarkFile
2388  * @uri: a valid URI
2389  * @error: return location for a #GError, or %NULL
2390  *
2391  * Retrieves the MIME type of the resource pointed by @uri.
2392  *
2393  * In the event the URI cannot be found, %NULL is returned and
2394  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
2395  * event that the MIME type cannot be found, %NULL is returned and
2396  * @error is set to #G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
2397  *
2398  * Returns: a newly allocated string or %NULL if the specified
2399  *   URI cannot be found.
2400  *
2401  * Since: 2.12
2402  */
2403 gchar *
2404 g_bookmark_file_get_mime_type (GBookmarkFile  *bookmark,
<span class="line-modified">2405                    const gchar    *uri,</span>
<span class="line-modified">2406                    GError        **error)</span>
2407 {
2408   BookmarkItem *item;
2409 
2410   g_return_val_if_fail (bookmark != NULL, NULL);
2411   g_return_val_if_fail (uri != NULL, NULL);
2412 
2413   item = g_bookmark_file_lookup_item (bookmark, uri);
2414   if (!item)
2415     {
2416       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2417                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2418                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2419                    uri);</span>
2420       return NULL;
2421     }
2422 
2423   if (!item-&gt;metadata)
2424     {
2425       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2426                    G_BOOKMARK_FILE_ERROR_INVALID_VALUE,</span>
<span class="line-modified">2427                    _(&quot;No MIME type defined in the bookmark for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2428                    uri);</span>
2429       return NULL;
2430     }
2431 
2432   return g_strdup (item-&gt;metadata-&gt;mime_type);
2433 }
2434 
2435 /**
2436  * g_bookmark_file_set_is_private:
2437  * @bookmark: a #GBookmarkFile
2438  * @uri: a valid URI
2439  * @is_private: %TRUE if the bookmark should be marked as private
2440  *
2441  * Sets the private flag of the bookmark for @uri.
2442  *
2443  * If a bookmark for @uri cannot be found then it is created.
2444  *
2445  * Since: 2.12
2446  */
2447 void
2448 g_bookmark_file_set_is_private (GBookmarkFile *bookmark,
<span class="line-modified">2449                 const gchar   *uri,</span>
<span class="line-modified">2450                 gboolean       is_private)</span>
2451 {
2452   BookmarkItem *item;
2453 
2454   g_return_if_fail (bookmark != NULL);
2455   g_return_if_fail (uri != NULL);
2456 
2457   item = g_bookmark_file_lookup_item (bookmark, uri);
2458   if (!item)
2459     {
2460       item = bookmark_item_new (uri);
2461       g_bookmark_file_add_item (bookmark, item, NULL);
2462     }
2463 
2464   if (!item-&gt;metadata)
2465     item-&gt;metadata = bookmark_metadata_new ();
2466 
2467   item-&gt;metadata-&gt;is_private = (is_private == TRUE);
2468   item-&gt;modified = time (NULL);
2469 }
2470 
2471 /**
2472  * g_bookmark_file_get_is_private:
2473  * @bookmark: a #GBookmarkFile
2474  * @uri: a valid URI
2475  * @error: return location for a #GError, or %NULL
2476  *
2477  * Gets whether the private flag of the bookmark for @uri is set.
2478  *
2479  * In the event the URI cannot be found, %FALSE is returned and
2480  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
2481  * event that the private flag cannot be found, %FALSE is returned and
2482  * @error is set to #G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
2483  *
2484  * Returns: %TRUE if the private flag is set, %FALSE otherwise.
2485  *
2486  * Since: 2.12
2487  */
2488 gboolean
2489 g_bookmark_file_get_is_private (GBookmarkFile  *bookmark,
<span class="line-modified">2490                 const gchar    *uri,</span>
<span class="line-modified">2491                 GError        **error)</span>
2492 {
2493   BookmarkItem *item;
2494 
2495   g_return_val_if_fail (bookmark != NULL, FALSE);
2496   g_return_val_if_fail (uri != NULL, FALSE);
2497 
2498   item = g_bookmark_file_lookup_item (bookmark, uri);
2499   if (!item)
2500     {
2501       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2502                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2503                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2504                    uri);</span>
2505       return FALSE;
2506     }
2507 
2508   if (!item-&gt;metadata)
2509     {
2510       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2511                    G_BOOKMARK_FILE_ERROR_INVALID_VALUE,</span>
<span class="line-modified">2512                    _(&quot;No private flag has been defined in bookmark for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2513                    uri);</span>
2514       return FALSE;
2515     }
2516 
2517   return item-&gt;metadata-&gt;is_private;
2518 }
2519 
2520 /**
2521  * g_bookmark_file_set_added:
2522  * @bookmark: a #GBookmarkFile
2523  * @uri: a valid URI
2524  * @added: a timestamp or -1 to use the current time
2525  *
2526  * Sets the time the bookmark for @uri was added into @bookmark.
2527  *
2528  * If no bookmark for @uri is found then it is created.
2529  *
2530  * Since: 2.12
2531  */
2532 void
2533 g_bookmark_file_set_added (GBookmarkFile *bookmark,
<span class="line-modified">2534                const gchar   *uri,</span>
<span class="line-modified">2535                time_t         added)</span>
2536 {
2537   BookmarkItem *item;
2538 
2539   g_return_if_fail (bookmark != NULL);
2540   g_return_if_fail (uri != NULL);
2541 
2542   item = g_bookmark_file_lookup_item (bookmark, uri);
2543   if (!item)
2544     {
2545       item = bookmark_item_new (uri);
2546       g_bookmark_file_add_item (bookmark, item, NULL);
2547     }
2548 
2549   if (added == (time_t) -1)
2550     time (&amp;added);
2551 
2552   item-&gt;added = added;
2553   item-&gt;modified = added;
2554 }
2555 
2556 /**
2557  * g_bookmark_file_get_added:
2558  * @bookmark: a #GBookmarkFile
2559  * @uri: a valid URI
2560  * @error: return location for a #GError, or %NULL
2561  *
2562  * Gets the time the bookmark for @uri was added to @bookmark
2563  *
2564  * In the event the URI cannot be found, -1 is returned and
2565  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2566  *
2567  * Returns: a timestamp
2568  *
2569  * Since: 2.12
2570  */
2571 time_t
2572 g_bookmark_file_get_added (GBookmarkFile  *bookmark,
<span class="line-modified">2573                const gchar    *uri,</span>
<span class="line-modified">2574                GError        **error)</span>
2575 {
2576   BookmarkItem *item;
2577 
2578   g_return_val_if_fail (bookmark != NULL, (time_t) -1);
2579   g_return_val_if_fail (uri != NULL, (time_t) -1);
2580 
2581   item = g_bookmark_file_lookup_item (bookmark, uri);
2582   if (!item)
2583     {
2584       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2585                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2586                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2587                    uri);</span>
2588       return (time_t) -1;
2589     }
2590 
2591   return item-&gt;added;
2592 }
2593 
2594 /**
2595  * g_bookmark_file_set_modified:
2596  * @bookmark: a #GBookmarkFile
2597  * @uri: a valid URI
2598  * @modified: a timestamp or -1 to use the current time
2599  *
2600  * Sets the last time the bookmark for @uri was last modified.
2601  *
2602  * If no bookmark for @uri is found then it is created.
2603  *
2604  * The &quot;modified&quot; time should only be set when the bookmark&#39;s meta-data
2605  * was actually changed.  Every function of #GBookmarkFile that
2606  * modifies a bookmark also changes the modification time, except for
2607  * g_bookmark_file_set_visited().
2608  *
2609  * Since: 2.12
2610  */
2611 void
2612 g_bookmark_file_set_modified (GBookmarkFile *bookmark,
<span class="line-modified">2613                   const gchar   *uri,</span>
<span class="line-modified">2614                   time_t         modified)</span>
2615 {
2616   BookmarkItem *item;
2617 
2618   g_return_if_fail (bookmark != NULL);
2619   g_return_if_fail (uri != NULL);
2620 
2621   item = g_bookmark_file_lookup_item (bookmark, uri);
2622   if (!item)
2623     {
2624       item = bookmark_item_new (uri);
2625       g_bookmark_file_add_item (bookmark, item, NULL);
2626     }
2627 
2628   if (modified == (time_t) -1)
2629     time (&amp;modified);
2630 
2631   item-&gt;modified = modified;
2632 }
2633 
2634 /**
2635  * g_bookmark_file_get_modified:
2636  * @bookmark: a #GBookmarkFile
2637  * @uri: a valid URI
2638  * @error: return location for a #GError, or %NULL
2639  *
2640  * Gets the time when the bookmark for @uri was last modified.
2641  *
2642  * In the event the URI cannot be found, -1 is returned and
2643  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2644  *
2645  * Returns: a timestamp
2646  *
2647  * Since: 2.12
2648  */
2649 time_t
2650 g_bookmark_file_get_modified (GBookmarkFile  *bookmark,
<span class="line-modified">2651                   const gchar    *uri,</span>
<span class="line-modified">2652                   GError        **error)</span>
2653 {
2654   BookmarkItem *item;
2655 
2656   g_return_val_if_fail (bookmark != NULL, (time_t) -1);
2657   g_return_val_if_fail (uri != NULL, (time_t) -1);
2658 
2659   item = g_bookmark_file_lookup_item (bookmark, uri);
2660   if (!item)
2661     {
2662       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2663                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2664                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2665                    uri);</span>
2666       return (time_t) -1;
2667     }
2668 
2669   return item-&gt;modified;
2670 }
2671 
2672 /**
2673  * g_bookmark_file_set_visited:
2674  * @bookmark: a #GBookmarkFile
2675  * @uri: a valid URI
2676  * @visited: a timestamp or -1 to use the current time
2677  *
2678  * Sets the time the bookmark for @uri was last visited.
2679  *
2680  * If no bookmark for @uri is found then it is created.
2681  *
2682  * The &quot;visited&quot; time should only be set if the bookmark was launched,
2683  * either using the command line retrieved by g_bookmark_file_get_app_info()
2684  * or by the default application for the bookmark&#39;s MIME type, retrieved
2685  * using g_bookmark_file_get_mime_type().  Changing the &quot;visited&quot; time
2686  * does not affect the &quot;modified&quot; time.
2687  *
2688  * Since: 2.12
2689  */
2690 void
2691 g_bookmark_file_set_visited (GBookmarkFile *bookmark,
<span class="line-modified">2692                  const gchar   *uri,</span>
<span class="line-modified">2693                  time_t         visited)</span>
2694 {
2695   BookmarkItem *item;
2696 
2697   g_return_if_fail (bookmark != NULL);
2698   g_return_if_fail (uri != NULL);
2699 
2700   item = g_bookmark_file_lookup_item (bookmark, uri);
2701   if (!item)
2702     {
2703       item = bookmark_item_new (uri);
2704       g_bookmark_file_add_item (bookmark, item, NULL);
2705     }
2706 
2707   if (visited == (time_t) -1)
2708     time (&amp;visited);
2709 
2710   item-&gt;visited = visited;
2711 }
2712 
2713 /**
2714  * g_bookmark_file_get_visited:
2715  * @bookmark: a #GBookmarkFile
2716  * @uri: a valid URI
2717  * @error: return location for a #GError, or %NULL
2718  *
2719  * Gets the time the bookmark for @uri was last visited.
2720  *
2721  * In the event the URI cannot be found, -1 is returned and
2722  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2723  *
2724  * Returns: a timestamp.
2725  *
2726  * Since: 2.12
2727  */
2728 time_t
2729 g_bookmark_file_get_visited (GBookmarkFile  *bookmark,
<span class="line-modified">2730                  const gchar    *uri,</span>
<span class="line-modified">2731                  GError        **error)</span>
2732 {
2733   BookmarkItem *item;
2734 
2735   g_return_val_if_fail (bookmark != NULL, (time_t) -1);
2736   g_return_val_if_fail (uri != NULL, (time_t) -1);
2737 
2738   item = g_bookmark_file_lookup_item (bookmark, uri);
2739   if (!item)
2740     {
2741       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2742                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2743                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2744                    uri);</span>
2745       return (time_t) -1;
2746     }
2747 
2748   return item-&gt;visited;
2749 }
2750 
2751 /**
2752  * g_bookmark_file_has_group:
2753  * @bookmark: a #GBookmarkFile
2754  * @uri: a valid URI
2755  * @group: the group name to be searched
2756  * @error: return location for a #GError, or %NULL
2757  *
2758  * Checks whether @group appears in the list of groups to which
2759  * the bookmark for @uri belongs to.
2760  *
2761  * In the event the URI cannot be found, %FALSE is returned and
2762  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2763  *
2764  * Returns: %TRUE if @group was found.
2765  *
2766  * Since: 2.12
2767  */
2768 gboolean
2769 g_bookmark_file_has_group (GBookmarkFile  *bookmark,
<span class="line-modified">2770                const gchar    *uri,</span>
<span class="line-modified">2771                const gchar    *group,</span>
<span class="line-modified">2772                GError        **error)</span>
2773 {
2774   BookmarkItem *item;
2775   GList *l;
2776 
2777   g_return_val_if_fail (bookmark != NULL, FALSE);
2778   g_return_val_if_fail (uri != NULL, FALSE);
2779 
2780   item = g_bookmark_file_lookup_item (bookmark, uri);
2781   if (!item)
2782     {
2783       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2784                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2785                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2786                    uri);</span>
2787       return FALSE;
2788     }
2789 
2790   if (!item-&gt;metadata)
2791     return FALSE;
2792 
2793   for (l = item-&gt;metadata-&gt;groups; l != NULL; l = l-&gt;next)
2794     {
2795       if (strcmp (l-&gt;data, group) == 0)
2796         return TRUE;
2797     }
2798 
2799   return FALSE;
2800 
2801 }
2802 
2803 /**
2804  * g_bookmark_file_add_group:
2805  * @bookmark: a #GBookmarkFile
2806  * @uri: a valid URI
2807  * @group: the group name to be added
2808  *
2809  * Adds @group to the list of groups to which the bookmark for @uri
2810  * belongs to.
2811  *
2812  * If no bookmark for @uri is found then it is created.
2813  *
2814  * Since: 2.12
2815  */
2816 void
2817 g_bookmark_file_add_group (GBookmarkFile *bookmark,
<span class="line-modified">2818                const gchar   *uri,</span>
<span class="line-modified">2819                const gchar   *group)</span>
2820 {
2821   BookmarkItem *item;
2822 
2823   g_return_if_fail (bookmark != NULL);
2824   g_return_if_fail (uri != NULL);
2825   g_return_if_fail (group != NULL &amp;&amp; group[0] != &#39;\0&#39;);
2826 
2827   item = g_bookmark_file_lookup_item (bookmark, uri);
2828   if (!item)
2829     {
2830       item = bookmark_item_new (uri);
2831       g_bookmark_file_add_item (bookmark, item, NULL);
2832     }
2833 
2834   if (!item-&gt;metadata)
2835     item-&gt;metadata = bookmark_metadata_new ();
2836 
2837   if (!g_bookmark_file_has_group (bookmark, uri, group, NULL))
2838     {
2839       item-&gt;metadata-&gt;groups = g_list_prepend (item-&gt;metadata-&gt;groups,
</pre>
<hr />
<pre>
2847  * g_bookmark_file_remove_group:
2848  * @bookmark: a #GBookmarkFile
2849  * @uri: a valid URI
2850  * @group: the group name to be removed
2851  * @error: return location for a #GError, or %NULL
2852  *
2853  * Removes @group from the list of groups to which the bookmark
2854  * for @uri belongs to.
2855  *
2856  * In the event the URI cannot be found, %FALSE is returned and
2857  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2858  * In the event no group was defined, %FALSE is returned and
2859  * @error is set to #G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
2860  *
2861  * Returns: %TRUE if @group was successfully removed.
2862  *
2863  * Since: 2.12
2864  */
2865 gboolean
2866 g_bookmark_file_remove_group (GBookmarkFile  *bookmark,
<span class="line-modified">2867                   const gchar    *uri,</span>
<span class="line-modified">2868                   const gchar    *group,</span>
<span class="line-modified">2869                   GError        **error)</span>
2870 {
2871   BookmarkItem *item;
2872   GList *l;
2873 
2874   g_return_val_if_fail (bookmark != NULL, FALSE);
2875   g_return_val_if_fail (uri != NULL, FALSE);
2876 
2877   item = g_bookmark_file_lookup_item (bookmark, uri);
2878   if (!item)
2879     {
2880       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2881                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2882                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2883                    uri);</span>
2884       return FALSE;
2885     }
2886 
2887   if (!item-&gt;metadata)
2888     {
2889       g_set_error (error, G_BOOKMARK_FILE_ERROR,
2890                    G_BOOKMARK_FILE_ERROR_INVALID_VALUE,
2891                    _(&quot;No groups set in bookmark for URI &#39;%s&#39;&quot;),
2892                    uri);
2893       return FALSE;
2894     }
2895 
2896   for (l = item-&gt;metadata-&gt;groups; l != NULL; l = l-&gt;next)
2897     {
2898       if (strcmp (l-&gt;data, group) == 0)
2899         {
2900           item-&gt;metadata-&gt;groups = g_list_remove_link (item-&gt;metadata-&gt;groups, l);
2901           g_free (l-&gt;data);
<span class="line-modified">2902       g_list_free_1 (l);</span>
2903 
2904           item-&gt;modified = time (NULL);
2905 
2906           return TRUE;
2907         }
2908     }
2909 
2910   return FALSE;
2911 }
2912 
2913 /**
2914  * g_bookmark_file_set_groups:
2915  * @bookmark: a #GBookmarkFile
2916  * @uri: an item&#39;s URI
2917  * @groups: (nullable) (array length=length) (element-type utf8): an array of
2918  *    group names, or %NULL to remove all groups
2919  * @length: number of group name values in @groups
2920  *
2921  * Sets a list of group names for the item with URI @uri.  Each previously
2922  * set group name list is removed.
2923  *
2924  * If @uri cannot be found then an item for it is created.
2925  *
2926  * Since: 2.12
2927  */
2928 void
2929 g_bookmark_file_set_groups (GBookmarkFile  *bookmark,
<span class="line-modified">2930                 const gchar    *uri,</span>
<span class="line-modified">2931                 const gchar   **groups,</span>
<span class="line-modified">2932                 gsize           length)</span>
2933 {
2934   BookmarkItem *item;
2935   gsize i;
2936 
2937   g_return_if_fail (bookmark != NULL);
2938   g_return_if_fail (uri != NULL);
2939   g_return_if_fail (groups != NULL);
2940 
2941   item = g_bookmark_file_lookup_item (bookmark, uri);
2942   if (!item)
2943     {
2944       item = bookmark_item_new (uri);
2945       g_bookmark_file_add_item (bookmark, item, NULL);
2946     }
2947 
2948   if (!item-&gt;metadata)
2949     item-&gt;metadata = bookmark_metadata_new ();
2950 
2951   g_list_free_full (item-&gt;metadata-&gt;groups, g_free);
2952   item-&gt;metadata-&gt;groups = NULL;
2953 
2954   if (groups)
2955     {
2956       for (i = 0; i &lt; length &amp;&amp; groups[i] != NULL; i++)
2957         item-&gt;metadata-&gt;groups = g_list_append (item-&gt;metadata-&gt;groups,
<span class="line-modified">2958                             g_strdup (groups[i]));</span>
2959     }
2960 
2961   item-&gt;modified = time (NULL);
2962 }
2963 
2964 /**
2965  * g_bookmark_file_get_groups:
2966  * @bookmark: a #GBookmarkFile
2967  * @uri: a valid URI
2968  * @length: (out) (optional): return location for the length of the returned string, or %NULL
2969  * @error: return location for a #GError, or %NULL
2970  *
2971  * Retrieves the list of group names of the bookmark for @uri.
2972  *
2973  * In the event the URI cannot be found, %NULL is returned and
2974  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2975  *
2976  * The returned array is %NULL terminated, so @length may optionally
2977  * be %NULL.
2978  *
2979  * Returns: (array length=length) (transfer full): a newly allocated %NULL-terminated array of group names.
2980  *   Use g_strfreev() to free it.
2981  *
2982  * Since: 2.12
2983  */
2984 gchar **
2985 g_bookmark_file_get_groups (GBookmarkFile  *bookmark,
<span class="line-modified">2986                 const gchar    *uri,</span>
<span class="line-modified">2987                 gsize          *length,</span>
<span class="line-modified">2988                 GError        **error)</span>
2989 {
2990   BookmarkItem *item;
2991   GList *l;
2992   gsize len, i;
2993   gchar **retval;
2994 
2995   g_return_val_if_fail (bookmark != NULL, NULL);
2996   g_return_val_if_fail (uri != NULL, NULL);
2997 
2998   item = g_bookmark_file_lookup_item (bookmark, uri);
2999   if (!item)
3000     {
3001       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3002                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3003                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3004                    uri);</span>
3005       return NULL;
3006     }
3007 
3008   if (!item-&gt;metadata)
3009     {
3010       if (length)
<span class="line-modified">3011     *length = 0;</span>
3012 
3013       return NULL;
3014     }
3015 
3016   len = g_list_length (item-&gt;metadata-&gt;groups);
3017   retval = g_new0 (gchar *, len + 1);
3018   for (l = g_list_last (item-&gt;metadata-&gt;groups), i = 0;
3019        l != NULL;
3020        l = l-&gt;prev)
3021     {
3022       gchar *group_name = (gchar *) l-&gt;data;
3023 
3024       g_warn_if_fail (group_name != NULL);
3025 
3026       retval[i++] = g_strdup (group_name);
3027     }
3028   retval[i] = NULL;
3029 
3030   if (length)
3031     *length = len;
</pre>
<hr />
<pre>
3051  * the bookmark has been registered by the application and the last
3052  * time the application registered this bookmark.
3053  *
3054  * If @name is %NULL, the name of the application will be the
3055  * same returned by g_get_application_name(); if @exec is %NULL, the
3056  * command line will be a composition of the program name as
3057  * returned by g_get_prgname() and the &quot;\%u&quot; modifier, which will be
3058  * expanded to the bookmark&#39;s URI.
3059  *
3060  * This function will automatically take care of updating the
3061  * registrations count and timestamping in case an application
3062  * with the same @name had already registered a bookmark for
3063  * @uri inside @bookmark.
3064  *
3065  * If no bookmark for @uri is found, one is created.
3066  *
3067  * Since: 2.12
3068  */
3069 void
3070 g_bookmark_file_add_application (GBookmarkFile *bookmark,
<span class="line-modified">3071                  const gchar   *uri,</span>
<span class="line-modified">3072                  const gchar   *name,</span>
<span class="line-modified">3073                  const gchar   *exec)</span>
3074 {
3075   BookmarkItem *item;
3076   gchar *app_name, *app_exec;
3077 
3078   g_return_if_fail (bookmark != NULL);
3079   g_return_if_fail (uri != NULL);
3080 
3081   item = g_bookmark_file_lookup_item (bookmark, uri);
3082   if (!item)
3083     {
3084       item = bookmark_item_new (uri);
3085       g_bookmark_file_add_item (bookmark, item, NULL);
3086     }
3087 
3088   if (name &amp;&amp; name[0] != &#39;\0&#39;)
3089     app_name = g_strdup (name);
3090   else
3091     app_name = g_strdup (g_get_application_name ());
3092 
3093   if (exec &amp;&amp; exec[0] != &#39;\0&#39;)
</pre>
<hr />
<pre>
3111  * @bookmark: a #GBookmarkFile
3112  * @uri: a valid URI
3113  * @name: the name of the application
3114  * @error: return location for a #GError or %NULL
3115  *
3116  * Removes application registered with @name from the list of applications
3117  * that have registered a bookmark for @uri inside @bookmark.
3118  *
3119  * In the event the URI cannot be found, %FALSE is returned and
3120  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3121  * In the event that no application with name @app_name has registered
3122  * a bookmark for @uri,  %FALSE is returned and error is set to
3123  * #G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.
3124  *
3125  * Returns: %TRUE if the application was successfully removed.
3126  *
3127  * Since: 2.12
3128  */
3129 gboolean
3130 g_bookmark_file_remove_application (GBookmarkFile  *bookmark,
<span class="line-modified">3131                     const gchar    *uri,</span>
<span class="line-modified">3132                     const gchar    *name,</span>
<span class="line-modified">3133                     GError        **error)</span>
3134 {
3135   GError *set_error;
3136   gboolean retval;
3137 
3138   g_return_val_if_fail (bookmark != NULL, FALSE);
3139   g_return_val_if_fail (uri != NULL, FALSE);
3140   g_return_val_if_fail (name != NULL, FALSE);
3141 
3142   set_error = NULL;
3143   retval = g_bookmark_file_set_app_info (bookmark, uri,
<span class="line-modified">3144                      name,</span>
<span class="line-modified">3145                      &quot;&quot;,</span>
<span class="line-modified">3146                      0,</span>
<span class="line-modified">3147                      (time_t) -1,</span>
<span class="line-modified">3148                      &amp;set_error);</span>
3149   if (set_error)
3150     {
3151       g_propagate_error (error, set_error);
3152 
3153       return FALSE;
3154     }
3155 
3156   return retval;
3157 }
3158 
3159 /**
3160  * g_bookmark_file_has_application:
3161  * @bookmark: a #GBookmarkFile
3162  * @uri: a valid URI
3163  * @name: the name of the application
3164  * @error: return location for a #GError or %NULL
3165  *
3166  * Checks whether the bookmark for @uri inside @bookmark has been
3167  * registered by application @name.
3168  *
3169  * In the event the URI cannot be found, %FALSE is returned and
3170  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3171  *
3172  * Returns: %TRUE if the application @name was found
3173  *
3174  * Since: 2.12
3175  */
3176 gboolean
3177 g_bookmark_file_has_application (GBookmarkFile  *bookmark,
<span class="line-modified">3178                  const gchar    *uri,</span>
<span class="line-modified">3179                  const gchar    *name,</span>
<span class="line-modified">3180                  GError        **error)</span>
3181 {
3182   BookmarkItem *item;
3183 
3184   g_return_val_if_fail (bookmark != NULL, FALSE);
3185   g_return_val_if_fail (uri != NULL, FALSE);
3186   g_return_val_if_fail (name != NULL, FALSE);
3187 
3188   item = g_bookmark_file_lookup_item (bookmark, uri);
3189   if (!item)
3190     {
3191       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3192                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3193                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3194                    uri);</span>
3195       return FALSE;
3196     }
3197 
3198   return (NULL != bookmark_item_lookup_app_info (item, name));
3199 }
3200 
3201 /**
3202  * g_bookmark_file_set_app_info:
3203  * @bookmark: a #GBookmarkFile
3204  * @uri: a valid URI
3205  * @name: an application&#39;s name
3206  * @exec: an application&#39;s command line
3207  * @count: the number of registrations done for this application
3208  * @stamp: the time of the last registration for this application
3209  * @error: return location for a #GError or %NULL
3210  *
3211  * Sets the meta-data of application @name inside the list of
3212  * applications that have registered a bookmark for @uri inside
3213  * @bookmark.
3214  *
</pre>
<hr />
<pre>
3227  * by one, if is 0, the application with @name will be removed from
3228  * the list of registered applications.
3229  * @stamp is the Unix time of the last registration; if it is -1, the
3230  * current time will be used.
3231  *
3232  * If you try to remove an application by setting its registration count to
3233  * zero, and no bookmark for @uri is found, %FALSE is returned and
3234  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND; similarly,
3235  * in the event that no application @name has registered a bookmark
3236  * for @uri,  %FALSE is returned and error is set to
3237  * #G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.  Otherwise, if no bookmark
3238  * for @uri is found, one is created.
3239  *
3240  * Returns: %TRUE if the application&#39;s meta-data was successfully
3241  *   changed.
3242  *
3243  * Since: 2.12
3244  */
3245 gboolean
3246 g_bookmark_file_set_app_info (GBookmarkFile  *bookmark,
<span class="line-modified">3247                   const gchar    *uri,</span>
<span class="line-modified">3248                   const gchar    *name,</span>
<span class="line-modified">3249                   const gchar    *exec,</span>
<span class="line-modified">3250                   gint            count,</span>
<span class="line-modified">3251                   time_t          stamp,</span>
<span class="line-modified">3252                   GError        **error)</span>
3253 {
3254   BookmarkItem *item;
3255   BookmarkAppInfo *ai;
3256 
3257   g_return_val_if_fail (bookmark != NULL, FALSE);
3258   g_return_val_if_fail (uri != NULL, FALSE);
3259   g_return_val_if_fail (name != NULL, FALSE);
3260   g_return_val_if_fail (exec != NULL, FALSE);
3261 
3262   item = g_bookmark_file_lookup_item (bookmark, uri);
3263   if (!item)
3264     {
3265       if (count == 0)
3266         {
3267           g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3268                        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3269                        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3270                        uri);</span>
<span class="line-modified">3271       return FALSE;</span>
<span class="line-modified">3272     }</span>
3273       else
3274         {
3275           item = bookmark_item_new (uri);
<span class="line-modified">3276       g_bookmark_file_add_item (bookmark, item, NULL);</span>
<span class="line-modified">3277     }</span>
3278     }
3279 
3280   if (!item-&gt;metadata)
3281     item-&gt;metadata = bookmark_metadata_new ();
3282 
3283   ai = bookmark_item_lookup_app_info (item, name);
3284   if (!ai)
3285     {
3286       if (count == 0)
3287         {
3288           g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3289                        G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED,</span>
<span class="line-modified">3290                        _(&quot;No application with name &#39;%s&#39; registered a bookmark for &#39;%s&#39;&quot;),</span>
<span class="line-modified">3291                        name,</span>
<span class="line-modified">3292                        uri);</span>
3293           return FALSE;
3294         }
3295       else
3296         {
3297           ai = bookmark_app_info_new (name);
3298 #ifdef GSTREAMER_LITE
3299           if (ai == NULL) {
3300             return FALSE;
3301           }
3302 #endif // GSTREAMER_LITE
3303 
3304           item-&gt;metadata-&gt;applications = g_list_prepend (item-&gt;metadata-&gt;applications, ai);
3305           g_hash_table_replace (item-&gt;metadata-&gt;apps_by_name, ai-&gt;name, ai);
3306         }
3307     }
3308 
3309   if (count == 0)
3310     {
3311       item-&gt;metadata-&gt;applications = g_list_remove (item-&gt;metadata-&gt;applications, ai);
3312       g_hash_table_remove (item-&gt;metadata-&gt;apps_by_name, ai-&gt;name);
</pre>
<hr />
<pre>
3323 
3324   if (stamp != (time_t) -1)
3325     ai-&gt;stamp = stamp;
3326   else
3327     ai-&gt;stamp = time (NULL);
3328 
3329   if (exec &amp;&amp; exec[0] != &#39;\0&#39;)
3330     {
3331       g_free (ai-&gt;exec);
3332       ai-&gt;exec = g_shell_quote (exec);
3333     }
3334 
3335   item-&gt;modified = time (NULL);
3336 
3337   return TRUE;
3338 }
3339 
3340 /* expands the application&#39;s command line */
3341 static gchar *
3342 expand_exec_line (const gchar *exec_fmt,
<span class="line-modified">3343           const gchar *uri)</span>
3344 {
3345   GString *exec;
3346   gchar ch;
3347 
3348   exec = g_string_sized_new (512);
3349   while ((ch = *exec_fmt++) != &#39;\0&#39;)
3350    {
3351      if (ch != &#39;%&#39;)
3352        {
3353          exec = g_string_append_c (exec, ch);
3354          continue;
3355        }
3356 
3357      ch = *exec_fmt++;
3358      switch (ch)
3359        {
3360        case &#39;\0&#39;:
<span class="line-modified">3361      goto out;</span>
3362        case &#39;U&#39;:
3363        case &#39;u&#39;:
3364          g_string_append (exec, uri);
3365          break;
3366        case &#39;F&#39;:
3367        case &#39;f&#39;:
3368          {
<span class="line-modified">3369        gchar *file = g_filename_from_uri (uri, NULL, NULL);</span>
3370            if (file)
3371              {
<span class="line-modified">3372            g_string_append (exec, file);</span>
<span class="line-modified">3373            g_free (file);</span>
3374              }
3375            else
3376              {
3377                g_string_free (exec, TRUE);
3378                return NULL;
3379              }
3380          }
3381          break;
3382        case &#39;%&#39;:
3383        default:
3384          exec = g_string_append_c (exec, ch);
3385          break;
3386        }
3387    }
3388 
3389  out:
3390   return g_string_free (exec, FALSE);
3391 }
3392 
3393 /**
</pre>
<hr />
<pre>
3403  * Gets the registration information of @app_name for the bookmark for
3404  * @uri.  See g_bookmark_file_set_app_info() for more information about
3405  * the returned data.
3406  *
3407  * The string returned in @app_exec must be freed.
3408  *
3409  * In the event the URI cannot be found, %FALSE is returned and
3410  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
3411  * event that no application with name @app_name has registered a bookmark
3412  * for @uri,  %FALSE is returned and error is set to
3413  * #G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. In the event that unquoting
3414  * the command line fails, an error of the #G_SHELL_ERROR domain is
3415  * set and %FALSE is returned.
3416  *
3417  * Returns: %TRUE on success.
3418  *
3419  * Since: 2.12
3420  */
3421 gboolean
3422 g_bookmark_file_get_app_info (GBookmarkFile  *bookmark,
<span class="line-modified">3423                   const gchar    *uri,</span>
<span class="line-modified">3424                   const gchar    *name,</span>
<span class="line-modified">3425                   gchar         **exec,</span>
<span class="line-modified">3426                   guint          *count,</span>
<span class="line-modified">3427                   time_t         *stamp,</span>
<span class="line-modified">3428                   GError        **error)</span>
3429 {
3430   BookmarkItem *item;
3431   BookmarkAppInfo *ai;
3432 
3433   g_return_val_if_fail (bookmark != NULL, FALSE);
3434   g_return_val_if_fail (uri != NULL, FALSE);
3435   g_return_val_if_fail (name != NULL, FALSE);
3436 
3437   item = g_bookmark_file_lookup_item (bookmark, uri);
3438   if (!item)
3439     {
3440       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3441                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3442                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3443                    uri);</span>
3444       return FALSE;
3445     }
3446 
3447   ai = bookmark_item_lookup_app_info (item, name);
3448   if (!ai)
3449     {
3450       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3451                    G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED,</span>
<span class="line-modified">3452                    _(&quot;No application with name &#39;%s&#39; registered a bookmark for &#39;%s&#39;&quot;),</span>
<span class="line-modified">3453                    name,</span>
<span class="line-modified">3454                    uri);</span>
3455       return FALSE;
3456     }
3457 
3458   if (exec)
3459     {
3460       GError *unquote_error = NULL;
3461       gchar *command_line;
3462 
3463       command_line = g_shell_unquote (ai-&gt;exec, &amp;unquote_error);
3464       if (unquote_error)
3465         {
3466           g_propagate_error (error, unquote_error);
3467           return FALSE;
3468         }
3469 
3470       *exec = expand_exec_line (command_line, uri);
3471       if (!*exec)
3472         {
3473           g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3474                        G_BOOKMARK_FILE_ERROR_INVALID_URI,</span>
<span class="line-modified">3475                        _(&quot;Failed to expand exec line &#39;%s&#39; with URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3476                        ai-&gt;exec, uri);</span>
3477           g_free (command_line);
3478 
3479           return FALSE;
3480         }
3481       else
3482         g_free (command_line);
3483     }
3484 
3485   if (count)
3486     *count = ai-&gt;count;
3487 
3488   if (stamp)
3489     *stamp = ai-&gt;stamp;
3490 
3491   return TRUE;
3492 }
3493 
3494 /**
3495  * g_bookmark_file_get_applications:
3496  * @bookmark: a #GBookmarkFile
3497  * @uri: a valid URI
3498  * @length: (out) (optional): return location of the length of the returned list, or %NULL
3499  * @error: return location for a #GError, or %NULL
3500  *
3501  * Retrieves the names of the applications that have registered the
3502  * bookmark for @uri.
3503  *
3504  * In the event the URI cannot be found, %NULL is returned and
3505  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3506  *
3507  * Returns: (array length=length) (transfer full): a newly allocated %NULL-terminated array of strings.
3508  *   Use g_strfreev() to free it.
3509  *
3510  * Since: 2.12
3511  */
3512 gchar **
3513 g_bookmark_file_get_applications (GBookmarkFile  *bookmark,
<span class="line-modified">3514                   const gchar    *uri,</span>
<span class="line-modified">3515                   gsize          *length,</span>
<span class="line-modified">3516                   GError        **error)</span>
3517 {
3518   BookmarkItem *item;
3519   GList *l;
3520   gchar **apps;
3521   gsize i, n_apps;
3522 
3523   g_return_val_if_fail (bookmark != NULL, NULL);
3524   g_return_val_if_fail (uri != NULL, NULL);
3525 
3526   item = g_bookmark_file_lookup_item (bookmark, uri);
3527   if (!item)
3528     {
3529       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3530                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3531                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3532                    uri);</span>
3533       return NULL;
3534     }
3535 
3536   if (!item-&gt;metadata)
3537     {
3538       if (length)
<span class="line-modified">3539     *length = 0;</span>
3540 
3541       return NULL;
3542     }
3543 
3544   n_apps = g_list_length (item-&gt;metadata-&gt;applications);
3545   apps = g_new0 (gchar *, n_apps + 1);
3546 
3547   for (l = g_list_last (item-&gt;metadata-&gt;applications), i = 0;
3548        l != NULL;
3549        l = l-&gt;prev)
3550     {
3551       BookmarkAppInfo *ai;
3552 
3553       ai = (BookmarkAppInfo *) l-&gt;data;
3554 
3555       g_warn_if_fail (ai != NULL);
3556       g_warn_if_fail (ai-&gt;name != NULL);
3557 
3558       apps[i++] = g_strdup (ai-&gt;name);
3559     }
</pre>
<hr />
<pre>
3586 /**
3587  * g_bookmark_file_move_item:
3588  * @bookmark: a #GBookmarkFile
3589  * @old_uri: a valid URI
3590  * @new_uri: (nullable): a valid URI, or %NULL
3591  * @error: return location for a #GError or %NULL
3592  *
3593  * Changes the URI of a bookmark item from @old_uri to @new_uri.  Any
3594  * existing bookmark for @new_uri will be overwritten.  If @new_uri is
3595  * %NULL, then the bookmark is removed.
3596  *
3597  * In the event the URI cannot be found, %FALSE is returned and
3598  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3599  *
3600  * Returns: %TRUE if the URI was successfully changed
3601  *
3602  * Since: 2.12
3603  */
3604 gboolean
3605 g_bookmark_file_move_item (GBookmarkFile  *bookmark,
<span class="line-modified">3606                const gchar    *old_uri,</span>
<span class="line-modified">3607                const gchar    *new_uri,</span>
<span class="line-modified">3608                GError        **error)</span>
3609 {
3610   BookmarkItem *item;
3611 
3612   g_return_val_if_fail (bookmark != NULL, FALSE);
3613   g_return_val_if_fail (old_uri != NULL, FALSE);
3614 
3615   item = g_bookmark_file_lookup_item (bookmark, old_uri);
3616   if (!item)
3617     {
3618       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3619                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3620                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3621                    old_uri);</span>
3622       return FALSE;
3623     }
3624 
3625   if (new_uri &amp;&amp; new_uri[0] != &#39;\0&#39;)
3626     {
3627       if (g_strcmp0 (old_uri, new_uri) == 0)
3628         return TRUE;
3629 
3630       if (g_bookmark_file_has_item (bookmark, new_uri))
3631         {
3632           if (!g_bookmark_file_remove_item (bookmark, new_uri, error))
3633             return FALSE;
3634         }
3635 
3636       g_hash_table_steal (bookmark-&gt;items_by_uri, item-&gt;uri);
3637 
3638       g_free (item-&gt;uri);
3639       item-&gt;uri = g_strdup (new_uri);
3640       item-&gt;modified = time (NULL);
3641 
</pre>
<hr />
<pre>
3652     }
3653 }
3654 
3655 /**
3656  * g_bookmark_file_set_icon:
3657  * @bookmark: a #GBookmarkFile
3658  * @uri: a valid URI
3659  * @href: (nullable): the URI of the icon for the bookmark, or %NULL
3660  * @mime_type: the MIME type of the icon for the bookmark
3661  *
3662  * Sets the icon for the bookmark for @uri. If @href is %NULL, unsets
3663  * the currently set icon. @href can either be a full URL for the icon
3664  * file or the icon name following the Icon Naming specification.
3665  *
3666  * If no bookmark for @uri is found one is created.
3667  *
3668  * Since: 2.12
3669  */
3670 void
3671 g_bookmark_file_set_icon (GBookmarkFile *bookmark,
<span class="line-modified">3672               const gchar   *uri,</span>
<span class="line-modified">3673               const gchar   *href,</span>
<span class="line-modified">3674               const gchar   *mime_type)</span>
3675 {
3676   BookmarkItem *item;
3677 
3678   g_return_if_fail (bookmark != NULL);
3679   g_return_if_fail (uri != NULL);
3680 
3681   item = g_bookmark_file_lookup_item (bookmark, uri);
3682   if (!item)
3683     {
3684       item = bookmark_item_new (uri);
3685       g_bookmark_file_add_item (bookmark, item, NULL);
3686     }
3687 
3688   if (!item-&gt;metadata)
3689     item-&gt;metadata = bookmark_metadata_new ();
3690 
3691   g_free (item-&gt;metadata-&gt;icon_href);
3692   g_free (item-&gt;metadata-&gt;icon_mime);
3693 
3694   item-&gt;metadata-&gt;icon_href = g_strdup (href);
</pre>
<hr />
<pre>
3704 /**
3705  * g_bookmark_file_get_icon:
3706  * @bookmark: a #GBookmarkFile
3707  * @uri: a valid URI
3708  * @href: (out) (optional): return location for the icon&#39;s location or %NULL
3709  * @mime_type: (out) (optional): return location for the icon&#39;s MIME type or %NULL
3710  * @error: return location for a #GError or %NULL
3711  *
3712  * Gets the icon of the bookmark for @uri.
3713  *
3714  * In the event the URI cannot be found, %FALSE is returned and
3715  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3716  *
3717  * Returns: %TRUE if the icon for the bookmark for the URI was found.
3718  *   You should free the returned strings.
3719  *
3720  * Since: 2.12
3721  */
3722 gboolean
3723 g_bookmark_file_get_icon (GBookmarkFile  *bookmark,
<span class="line-modified">3724               const gchar    *uri,</span>
<span class="line-modified">3725               gchar         **href,</span>
<span class="line-modified">3726               gchar         **mime_type,</span>
<span class="line-modified">3727               GError        **error)</span>
3728 {
3729   BookmarkItem *item;
3730 
3731   g_return_val_if_fail (bookmark != NULL, FALSE);
3732   g_return_val_if_fail (uri != NULL, FALSE);
3733 
3734   item = g_bookmark_file_lookup_item (bookmark, uri);
3735   if (!item)
3736     {
3737       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3738                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3739                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3740                    uri);</span>
3741       return FALSE;
3742     }
3743 
3744   if ((!item-&gt;metadata) || (!item-&gt;metadata-&gt;icon_href))
3745     return FALSE;
3746 
3747   if (href)
3748     *href = g_strdup (item-&gt;metadata-&gt;icon_href);
3749 
3750   if (mime_type)
3751     *mime_type = g_strdup (item-&gt;metadata-&gt;icon_mime);
3752 
3753   return TRUE;
3754 }
</pre>
</td>
<td>
<hr />
<pre>
  78  * registered; the URI and MIME type of an icon, to be used when
  79  * displaying the bookmark inside a GUI.
  80  *
  81  * Here is an example of a bookmark file:
  82  * [bookmarks.xbel](https://git.gnome.org/browse/glib/tree/glib/tests/bookmarks.xbel)
  83  *
  84  * A bookmark file might contain more than one bookmark; each bookmark
  85  * is accessed through its URI.
  86  *
  87  * The important caveat of bookmark files is that when you add a new
  88  * bookmark you must also add the application that is registering it, using
  89  * g_bookmark_file_add_application() or g_bookmark_file_set_app_info().
  90  * If a bookmark has no applications then it won&#39;t be dumped when creating
  91  * the on disk representation, using g_bookmark_file_to_data() or
  92  * g_bookmark_file_to_file().
  93  *
  94  * The #GBookmarkFile parser was added in GLib 2.12.
  95  */
  96 
  97 /* XBEL 1.0 standard entities */
<span class="line-modified">  98 #define XBEL_VERSION    &quot;1.0&quot;</span>
<span class="line-modified">  99 #define XBEL_DTD_NICK   &quot;xbel&quot;</span>
<span class="line-modified"> 100 #define XBEL_DTD_SYSTEM   &quot;+//IDN python.org//DTD XML Bookmark &quot; \</span>
<span class="line-modified"> 101         &quot;Exchange Language 1.0//EN//XML&quot;</span>
<span class="line-modified"> 102 </span>
<span class="line-modified"> 103 #define XBEL_DTD_URI    &quot;http://www.python.org/topics/xml/dtds/xbel-1.0.dtd&quot;</span>
<span class="line-modified"> 104 </span>
<span class="line-modified"> 105 #define XBEL_ROOT_ELEMENT &quot;xbel&quot;</span>
<span class="line-modified"> 106 #define XBEL_FOLDER_ELEMENT &quot;folder&quot;  /* unused */</span>
<span class="line-modified"> 107 #define XBEL_BOOKMARK_ELEMENT &quot;bookmark&quot;</span>
<span class="line-modified"> 108 #define XBEL_ALIAS_ELEMENT  &quot;alias&quot;   /* unused */</span>
<span class="line-modified"> 109 #define XBEL_SEPARATOR_ELEMENT  &quot;separator&quot;   /* unused */</span>
 110 #define XBEL_TITLE_ELEMENT  &quot;title&quot;
<span class="line-modified"> 111 #define XBEL_DESC_ELEMENT &quot;desc&quot;</span>
<span class="line-modified"> 112 #define XBEL_INFO_ELEMENT &quot;info&quot;</span>
<span class="line-modified"> 113 #define XBEL_METADATA_ELEMENT &quot;metadata&quot;</span>
 114 
 115 #define XBEL_VERSION_ATTRIBUTE  &quot;version&quot;
<span class="line-modified"> 116 #define XBEL_FOLDED_ATTRIBUTE &quot;folded&quot;  /* unused */</span>
<span class="line-modified"> 117 #define XBEL_OWNER_ATTRIBUTE  &quot;owner&quot;</span>
<span class="line-modified"> 118 #define XBEL_ADDED_ATTRIBUTE  &quot;added&quot;</span>
 119 #define XBEL_VISITED_ATTRIBUTE  &quot;visited&quot;
 120 #define XBEL_MODIFIED_ATTRIBUTE &quot;modified&quot;
<span class="line-modified"> 121 #define XBEL_ID_ATTRIBUTE &quot;id&quot;</span>
 122 #define XBEL_HREF_ATTRIBUTE &quot;href&quot;
<span class="line-modified"> 123 #define XBEL_REF_ATTRIBUTE  &quot;ref&quot;     /* unused */</span>
 124 
<span class="line-modified"> 125 #define XBEL_YES_VALUE    &quot;yes&quot;</span>
<span class="line-modified"> 126 #define XBEL_NO_VALUE   &quot;no&quot;</span>
 127 
 128 /* Desktop bookmark spec entities */
<span class="line-modified"> 129 #define BOOKMARK_METADATA_OWNER   &quot;http://freedesktop.org&quot;</span>
<span class="line-modified"> 130 </span>
<span class="line-modified"> 131 #define BOOKMARK_NAMESPACE_NAME   &quot;bookmark&quot;</span>
<span class="line-modified"> 132 #define BOOKMARK_NAMESPACE_URI    &quot;http://www.freedesktop.org/standards/desktop-bookmarks&quot;</span>
<span class="line-modified"> 133 </span>
<span class="line-modified"> 134 #define BOOKMARK_GROUPS_ELEMENT   &quot;groups&quot;</span>
<span class="line-modified"> 135 #define BOOKMARK_GROUP_ELEMENT    &quot;group&quot;</span>
<span class="line-modified"> 136 #define BOOKMARK_APPLICATIONS_ELEMENT &quot;applications&quot;</span>
<span class="line-modified"> 137 #define BOOKMARK_APPLICATION_ELEMENT  &quot;application&quot;</span>
<span class="line-modified"> 138 #define BOOKMARK_ICON_ELEMENT     &quot;icon&quot;</span>
<span class="line-modified"> 139 #define BOOKMARK_PRIVATE_ELEMENT  &quot;private&quot;</span>
<span class="line-modified"> 140 </span>
<span class="line-modified"> 141 #define BOOKMARK_NAME_ATTRIBUTE   &quot;name&quot;</span>
<span class="line-modified"> 142 #define BOOKMARK_EXEC_ATTRIBUTE   &quot;exec&quot;</span>
<span class="line-modified"> 143 #define BOOKMARK_COUNT_ATTRIBUTE  &quot;count&quot;</span>
<span class="line-modified"> 144 #define BOOKMARK_TIMESTAMP_ATTRIBUTE  &quot;timestamp&quot;     /* deprecated by &quot;modified&quot; */</span>
 145 #define BOOKMARK_MODIFIED_ATTRIBUTE     &quot;modified&quot;
<span class="line-modified"> 146 #define BOOKMARK_HREF_ATTRIBUTE   &quot;href&quot;</span>
<span class="line-modified"> 147 #define BOOKMARK_TYPE_ATTRIBUTE   &quot;type&quot;</span>
 148 
 149 /* Shared MIME Info entities */
<span class="line-modified"> 150 #define MIME_NAMESPACE_NAME     &quot;mime&quot;</span>
<span class="line-modified"> 151 #define MIME_NAMESPACE_URI    &quot;http://www.freedesktop.org/standards/shared-mime-info&quot;</span>
<span class="line-modified"> 152 #define MIME_TYPE_ELEMENT     &quot;mime-type&quot;</span>
<span class="line-modified"> 153 #define MIME_TYPE_ATTRIBUTE     &quot;type&quot;</span>
 154 
 155 
 156 typedef struct _BookmarkAppInfo  BookmarkAppInfo;
 157 typedef struct _BookmarkMetadata BookmarkMetadata;
 158 typedef struct _BookmarkItem     BookmarkItem;
 159 typedef struct _ParseData        ParseData;
 160 
 161 struct _BookmarkAppInfo
 162 {
 163   gchar *name;
 164   gchar *exec;
 165 
 166   guint count;
 167 
 168   time_t stamp;
 169 };
 170 
 171 struct _BookmarkMetadata
 172 {
 173   gchar *mime_type;
</pre>
<hr />
<pre>
 186 struct _BookmarkItem
 187 {
 188   gchar *uri;
 189 
 190   gchar *title;
 191   gchar *description;
 192 
 193   time_t added;
 194   time_t modified;
 195   time_t visited;
 196 
 197   BookmarkMetadata *metadata;
 198 };
 199 
 200 struct _GBookmarkFile
 201 {
 202   gchar *title;
 203   gchar *description;
 204 
 205   /* we store our items in a list and keep a copy inside
<span class="line-modified"> 206    * a hash table for faster lookup performances</span>
 207    */
 208   GList *items;
 209   GHashTable *items_by_uri;
 210 };
 211 
 212 /* parser state machine */
 213 typedef enum
 214 {
 215   STATE_STARTED        = 0,
 216 
 217   STATE_ROOT,
 218   STATE_BOOKMARK,
 219   STATE_TITLE,
 220   STATE_DESC,
 221   STATE_INFO,
 222   STATE_METADATA,
 223   STATE_APPLICATIONS,
 224   STATE_APPLICATION,
 225   STATE_GROUPS,
 226   STATE_GROUP,
 227   STATE_MIME,
 228   STATE_ICON,
 229 
 230   STATE_FINISHED
 231 } ParserState;
 232 
 233 static void          g_bookmark_file_init        (GBookmarkFile  *bookmark);
 234 static void          g_bookmark_file_clear       (GBookmarkFile  *bookmark);
 235 static gboolean      g_bookmark_file_parse       (GBookmarkFile  *bookmark,
<span class="line-modified"> 236               const gchar    *buffer,</span>
<span class="line-modified"> 237               gsize           length,</span>
<span class="line-modified"> 238               GError        **error);</span>
 239 static gchar *       g_bookmark_file_dump        (GBookmarkFile  *bookmark,
<span class="line-modified"> 240               gsize          *length,</span>
<span class="line-modified"> 241               GError        **error);</span>
 242 static BookmarkItem *g_bookmark_file_lookup_item (GBookmarkFile  *bookmark,
<span class="line-modified"> 243               const gchar    *uri);</span>
 244 static void          g_bookmark_file_add_item    (GBookmarkFile  *bookmark,
<span class="line-modified"> 245               BookmarkItem   *item,</span>
<span class="line-modified"> 246               GError        **error);</span>
 247 
<span class="line-modified"> 248 static gboolean  timestamp_from_iso8601 (const gchar  *iso_date,</span>
<span class="line-modified"> 249                                          time_t       *out_timestamp,</span>
<span class="line-added"> 250                                          GError      **error);</span>
<span class="line-added"> 251 static gchar    *timestamp_to_iso8601   (time_t        timestamp);</span>
 252 
 253 /********************************
 254  * BookmarkAppInfo              *
 255  *                              *
 256  * Application metadata storage *
 257  ********************************/
 258 static BookmarkAppInfo *
 259 bookmark_app_info_new (const gchar *name)
 260 {
 261   BookmarkAppInfo *retval;
 262 
 263   g_warn_if_fail (name != NULL);
 264 
 265   retval = g_slice_new (BookmarkAppInfo);
 266 #ifdef GSTREAMER_LITE
 267   if (retval == NULL) {
 268     return NULL;
 269   }
 270 #endif // GSTREAMER_LITE
 271 
</pre>
<hr />
<pre>
 372 
 373   g_free (metadata-&gt;icon_href);
 374   g_free (metadata-&gt;icon_mime);
 375 
 376   g_slice_free (BookmarkMetadata, metadata);
 377 }
 378 
 379 static gchar *
 380 bookmark_metadata_dump (BookmarkMetadata *metadata)
 381 {
 382   GString *retval;
 383   gchar *buffer;
 384 
 385   if (!metadata-&gt;applications)
 386     return NULL;
 387 
 388   retval = g_string_sized_new (1024);
 389 
 390   /* metadata container */
 391   g_string_append (retval,
<span class="line-modified"> 392        &quot;      &quot;</span>
<span class="line-modified"> 393        &quot;&lt;&quot; XBEL_METADATA_ELEMENT</span>
<span class="line-modified"> 394        &quot; &quot; XBEL_OWNER_ATTRIBUTE &quot;=\&quot;&quot; BOOKMARK_METADATA_OWNER</span>
<span class="line-modified"> 395        &quot;\&quot;&gt;\n&quot;);</span>
 396 
 397   /* mime type */
 398   if (metadata-&gt;mime_type) {
 399     buffer = g_strconcat (&quot;        &quot;
<span class="line-modified"> 400         &quot;&lt;&quot; MIME_NAMESPACE_NAME &quot;:&quot; MIME_TYPE_ELEMENT &quot; &quot;</span>
<span class="line-modified"> 401         MIME_TYPE_ATTRIBUTE &quot;=\&quot;&quot;, metadata-&gt;mime_type, &quot;\&quot;/&gt;\n&quot;,</span>
<span class="line-modified"> 402         NULL);</span>
 403     g_string_append (retval, buffer);
 404     g_free (buffer);
 405   }
 406 
 407   if (metadata-&gt;groups)
 408     {
 409       GList *l;
 410 
 411       /* open groups container */
 412       g_string_append (retval,
<span class="line-modified"> 413            &quot;        &quot;</span>
<span class="line-modified"> 414            &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 415            &quot;:&quot; BOOKMARK_GROUPS_ELEMENT &quot;&gt;\n&quot;);</span>
 416 
 417       for (l = g_list_last (metadata-&gt;groups); l != NULL; l = l-&gt;prev)
 418         {
 419           gchar *group_name;
 420 
<span class="line-modified"> 421     group_name = g_markup_escape_text ((gchar *) l-&gt;data, -1);</span>
<span class="line-modified"> 422     buffer = g_strconcat (&quot;          &quot;</span>
<span class="line-modified"> 423         &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 424         &quot;:&quot; BOOKMARK_GROUP_ELEMENT &quot;&gt;&quot;,</span>
<span class="line-modified"> 425         group_name,</span>
<span class="line-modified"> 426         &quot;&lt;/&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 427         &quot;:&quot;  BOOKMARK_GROUP_ELEMENT &quot;&gt;\n&quot;, NULL);</span>
<span class="line-modified"> 428     g_string_append (retval, buffer);</span>
 429 
<span class="line-modified"> 430     g_free (buffer);</span>
<span class="line-modified"> 431     g_free (group_name);</span>
 432         }
 433 
 434       /* close groups container */
 435       g_string_append (retval,
<span class="line-modified"> 436            &quot;        &quot;</span>
<span class="line-modified"> 437            &quot;&lt;/&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 438            &quot;:&quot; BOOKMARK_GROUPS_ELEMENT &quot;&gt;\n&quot;);</span>
 439     }
 440 
 441   if (metadata-&gt;applications)
 442     {
 443       GList *l;
 444 
 445       /* open applications container */
 446       g_string_append (retval,
<span class="line-modified"> 447            &quot;        &quot;</span>
<span class="line-modified"> 448            &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 449            &quot;:&quot; BOOKMARK_APPLICATIONS_ELEMENT &quot;&gt;\n&quot;);</span>
 450 
 451       for (l = g_list_last (metadata-&gt;applications); l != NULL; l = l-&gt;prev)
 452         {
 453           BookmarkAppInfo *app_info = (BookmarkAppInfo *) l-&gt;data;
 454           gchar *app_data;
 455 
<span class="line-modified"> 456     g_warn_if_fail (app_info != NULL);</span>
 457 
 458           app_data = bookmark_app_info_dump (app_info);
 459 
<span class="line-modified"> 460     if (app_data)</span>
 461             {
 462               retval = g_string_append (retval, app_data);
 463 
<span class="line-modified"> 464         g_free (app_data);</span>
<span class="line-modified"> 465       }</span>
 466         }
 467 
 468       /* close applications container */
 469       g_string_append (retval,
<span class="line-modified"> 470            &quot;        &quot;</span>
<span class="line-modified"> 471            &quot;&lt;/&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 472            &quot;:&quot; BOOKMARK_APPLICATIONS_ELEMENT &quot;&gt;\n&quot;);</span>
 473     }
 474 
 475   /* icon */
 476   if (metadata-&gt;icon_href)
 477     {
 478       if (!metadata-&gt;icon_mime)
 479         metadata-&gt;icon_mime = g_strdup (&quot;application/octet-stream&quot;);
 480 
 481       buffer = g_strconcat (&quot;       &quot;
<span class="line-modified"> 482           &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 483           &quot;:&quot; BOOKMARK_ICON_ELEMENT</span>
<span class="line-modified"> 484           &quot; &quot; BOOKMARK_HREF_ATTRIBUTE &quot;=\&quot;&quot;, metadata-&gt;icon_href,</span>
<span class="line-modified"> 485           &quot;\&quot; &quot; BOOKMARK_TYPE_ATTRIBUTE &quot;=\&quot;&quot;, metadata-&gt;icon_mime, &quot;\&quot;/&gt;\n&quot;, NULL);</span>
 486       g_string_append (retval, buffer);
 487 
 488       g_free (buffer);
 489     }
 490 
 491   /* private hint */
 492   if (metadata-&gt;is_private)
 493     g_string_append (retval,
<span class="line-modified"> 494          &quot;        &quot;</span>
<span class="line-modified"> 495          &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 496          &quot;:&quot; BOOKMARK_PRIVATE_ELEMENT &quot;/&gt;\n&quot;);</span>
 497 
 498   /* close metadata container */
 499   g_string_append (retval,
<span class="line-modified"> 500        &quot;      &quot;</span>
<span class="line-modified"> 501        &quot;&lt;/&quot; XBEL_METADATA_ELEMENT &quot;&gt;\n&quot;);</span>
 502 
 503   return g_string_free (retval, FALSE);
 504 }
 505 
 506 /******************************************************
 507  * BookmarkItem                                       *
 508  *                                                    *
 509  * Storage for a single bookmark item inside the list *
 510  ******************************************************/
 511 static BookmarkItem *
 512 bookmark_item_new (const gchar *uri)
 513 {
 514   BookmarkItem *item;
 515 
 516   g_warn_if_fail (uri != NULL);
 517 
 518   item = g_slice_new (BookmarkItem);
 519 #ifdef GSTREAMER_LITE
 520   if (item == NULL) {
 521     return NULL;
</pre>
<hr />
<pre>
 620                             escaped_desc,
 621                             &quot;&lt;/&quot; XBEL_DESC_ELEMENT &quot;&gt;\n&quot;,
 622                             NULL);
 623       g_string_append (retval, buffer);
 624 
 625       g_free (escaped_desc);
 626       g_free (buffer);
 627     }
 628 
 629   if (item-&gt;metadata)
 630     {
 631       gchar *metadata;
 632 
 633       metadata = bookmark_metadata_dump (item-&gt;metadata);
 634       if (metadata)
 635         {
 636           buffer = g_strconcat (&quot;    &quot;
 637                                 &quot;&lt;&quot; XBEL_INFO_ELEMENT &quot;&gt;\n&quot;,
 638                                 metadata,
 639                                 &quot;    &quot;
<span class="line-modified"> 640         &quot;&lt;/&quot; XBEL_INFO_ELEMENT &quot;&gt;\n&quot;,</span>
 641                                 NULL);
 642           retval = g_string_append (retval, buffer);
 643 
 644           g_free (buffer);
<span class="line-modified"> 645     g_free (metadata);</span>
<span class="line-modified"> 646   }</span>
 647     }
 648 
 649   g_string_append (retval, &quot;  &lt;/&quot; XBEL_BOOKMARK_ELEMENT &quot;&gt;\n&quot;);
 650 
 651   return g_string_free (retval, FALSE);
 652 }
 653 
 654 static BookmarkAppInfo *
 655 bookmark_item_lookup_app_info (BookmarkItem *item,
<span class="line-modified"> 656              const gchar  *app_name)</span>
 657 {
 658   g_warn_if_fail (item != NULL &amp;&amp; app_name != NULL);
 659 
 660   if (!item-&gt;metadata)
 661     return NULL;
 662 
 663   return g_hash_table_lookup (item-&gt;metadata-&gt;apps_by_name, app_name);
 664 }
 665 
 666 /*************************
 667  *    GBookmarkFile    *
 668  *************************/
 669 
 670 static void
 671 g_bookmark_file_init (GBookmarkFile *bookmark)
 672 {
 673   bookmark-&gt;title = NULL;
 674   bookmark-&gt;description = NULL;
 675 
 676   bookmark-&gt;items = NULL;
</pre>
<hr />
<pre>
 699 
 700 struct _ParseData
 701 {
 702   ParserState state;
 703 
 704   GHashTable *namespaces;
 705 
 706   GBookmarkFile *bookmark_file;
 707   BookmarkItem *current_item;
 708 };
 709 
 710 static ParseData *
 711 parse_data_new (void)
 712 {
 713   ParseData *retval;
 714 
 715   retval = g_new (ParseData, 1);
 716 
 717   retval-&gt;state = STATE_STARTED;
 718   retval-&gt;namespaces = g_hash_table_new_full (g_str_hash, g_str_equal,
<span class="line-modified"> 719                   (GDestroyNotify) g_free,</span>
<span class="line-modified"> 720                   (GDestroyNotify) g_free);</span>
 721   retval-&gt;bookmark_file = NULL;
 722   retval-&gt;current_item = NULL;
 723 
 724   return retval;
 725 }
 726 
 727 static void
 728 parse_data_free (ParseData *parse_data)
 729 {
 730   g_hash_table_destroy (parse_data-&gt;namespaces);
 731 
 732   g_free (parse_data);
 733 }
 734 
<span class="line-modified"> 735 #define IS_ATTRIBUTE(s,a) ((0 == strcmp ((s), (a))))</span>
 736 
 737 static void
 738 parse_bookmark_element (GMarkupParseContext  *context,
<span class="line-modified"> 739       ParseData            *parse_data,</span>
<span class="line-modified"> 740       const gchar         **attribute_names,</span>
<span class="line-modified"> 741       const gchar         **attribute_values,</span>
<span class="line-modified"> 742       GError              **error)</span>
 743 {
 744   const gchar *uri, *added, *modified, *visited;
 745   const gchar *attr;
 746   gint i;
 747   BookmarkItem *item;
 748   GError *add_error;
 749 
 750   g_warn_if_fail ((parse_data != NULL) &amp;&amp; (parse_data-&gt;state == STATE_BOOKMARK));
 751 
 752   i = 0;
 753   uri = added = modified = visited = NULL;
 754   for (attr = attribute_names[i]; attr != NULL; attr = attribute_names[++i])
 755     {
 756       if (IS_ATTRIBUTE (attr, XBEL_HREF_ATTRIBUTE))
 757         uri = attribute_values[i];
 758       else if (IS_ATTRIBUTE (attr, XBEL_ADDED_ATTRIBUTE))
 759         added = attribute_values[i];
 760       else if (IS_ATTRIBUTE (attr, XBEL_MODIFIED_ATTRIBUTE))
 761         modified = attribute_values[i];
 762       else if (IS_ATTRIBUTE (attr, XBEL_VISITED_ATTRIBUTE))
 763         visited = attribute_values[i];
 764       else
 765         {
 766           /* bookmark is defined by the XBEL spec, so we need
 767            * to error out if the element has different or
 768            * missing attributes
 769            */
 770           g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified"> 771            G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE,</span>
<span class="line-modified"> 772                    _(&quot;Unexpected attribute &#39;%s&#39; for element &#39;%s&#39;&quot;),</span>
<span class="line-modified"> 773                    attr,</span>
<span class="line-modified"> 774                    XBEL_BOOKMARK_ELEMENT);</span>
 775           return;
 776         }
 777     }
 778 
 779   if (!uri)
 780     {
 781       g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified"> 782              G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified"> 783              _(&quot;Attribute &#39;%s&#39; of element &#39;%s&#39; not found&quot;),</span>
<span class="line-modified"> 784              XBEL_HREF_ATTRIBUTE,</span>
<span class="line-modified"> 785              XBEL_BOOKMARK_ELEMENT);</span>
 786       return;
 787     }
 788 
 789   g_warn_if_fail (parse_data-&gt;current_item == NULL);
 790 
<span class="line-modified"> 791   item = bookmark_item_new (uri);</span>
 792 #ifdef GSTREAMER_LITE
 793   if (item == NULL) {
 794     return;
 795   }
 796 #endif // GSTREAMER_LITE
 797 
<span class="line-modified"> 798   if (added != NULL &amp;&amp; !timestamp_from_iso8601 (added, &amp;item-&gt;added, error))</span>
<span class="line-modified"> 799     return;</span>
 800 
<span class="line-modified"> 801   if (modified != NULL &amp;&amp; !timestamp_from_iso8601 (modified, &amp;item-&gt;modified, error))</span>
<span class="line-modified"> 802     return;</span>
 803 
<span class="line-modified"> 804   if (visited != NULL &amp;&amp; !timestamp_from_iso8601 (visited, &amp;item-&gt;visited, error))</span>
<span class="line-modified"> 805     return;</span>
 806 
 807   add_error = NULL;
 808   g_bookmark_file_add_item (parse_data-&gt;bookmark_file,
<span class="line-modified"> 809             item,</span>
<span class="line-modified"> 810             &amp;add_error);</span>
 811   if (add_error)
 812     {
 813       bookmark_item_free (item);
 814 
 815       g_propagate_error (error, add_error);
 816 
 817       return;
 818     }
 819 
 820   parse_data-&gt;current_item = item;
 821 }
 822 
 823 static void
 824 parse_application_element (GMarkupParseContext  *context,
<span class="line-modified"> 825          ParseData            *parse_data,</span>
<span class="line-modified"> 826          const gchar         **attribute_names,</span>
<span class="line-modified"> 827          const gchar         **attribute_values,</span>
<span class="line-modified"> 828          GError              **error)</span>
 829 {
 830   const gchar *name, *exec, *count, *stamp, *modified;
 831   const gchar *attr;
 832   gint i;
 833   BookmarkItem *item;
 834   BookmarkAppInfo *ai;
 835 
 836   g_warn_if_fail ((parse_data != NULL) &amp;&amp; (parse_data-&gt;state == STATE_APPLICATION));
 837 
 838   i = 0;
 839   name = exec = count = stamp = modified = NULL;
 840   for (attr = attribute_names[i]; attr != NULL; attr = attribute_names[++i])
 841     {
 842       if (IS_ATTRIBUTE (attr, BOOKMARK_NAME_ATTRIBUTE))
 843         name = attribute_values[i];
 844       else if (IS_ATTRIBUTE (attr, BOOKMARK_EXEC_ATTRIBUTE))
 845         exec = attribute_values[i];
 846       else if (IS_ATTRIBUTE (attr, BOOKMARK_COUNT_ATTRIBUTE))
 847         count = attribute_values[i];
 848       else if (IS_ATTRIBUTE (attr, BOOKMARK_TIMESTAMP_ATTRIBUTE))
 849         stamp = attribute_values[i];
 850       else if (IS_ATTRIBUTE (attr, BOOKMARK_MODIFIED_ATTRIBUTE))
 851         modified = attribute_values[i];
 852     }
 853 
 854   /* the &quot;name&quot; and &quot;exec&quot; attributes are mandatory */
 855   if (!name)
 856     {
 857       g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified"> 858              G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified"> 859              _(&quot;Attribute &#39;%s&#39; of element &#39;%s&#39; not found&quot;),</span>
<span class="line-modified"> 860              BOOKMARK_NAME_ATTRIBUTE,</span>
<span class="line-modified"> 861              BOOKMARK_APPLICATION_ELEMENT);</span>
 862       return;
 863     }
 864 
 865   if (!exec)
 866     {
 867       g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified"> 868              G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified"> 869              _(&quot;Attribute &#39;%s&#39; of element &#39;%s&#39; not found&quot;),</span>
<span class="line-modified"> 870              BOOKMARK_EXEC_ATTRIBUTE,</span>
<span class="line-modified"> 871              BOOKMARK_APPLICATION_ELEMENT);</span>
 872       return;
 873     }
 874 
 875   g_warn_if_fail (parse_data-&gt;current_item != NULL);
 876   item = parse_data-&gt;current_item;
 877 
 878   ai = bookmark_item_lookup_app_info (item, name);
 879   if (!ai)
 880     {
 881       ai = bookmark_app_info_new (name);
 882 #ifdef GSTREAMER_LITE
 883       if (ai == NULL) {
 884           g_set_error (error, G_MARKUP_ERROR,
 885                G_MARKUP_ERROR_INVALID_CONTENT,
 886                _(&quot;AI is NULL&quot;));
 887           return;
 888       }
 889 #endif // GSTREAMER_LITE
 890 
 891       if (!item-&gt;metadata)
<span class="line-modified"> 892   item-&gt;metadata = bookmark_metadata_new ();</span>
 893 
 894       item-&gt;metadata-&gt;applications = g_list_prepend (item-&gt;metadata-&gt;applications, ai);
 895       g_hash_table_replace (item-&gt;metadata-&gt;apps_by_name, ai-&gt;name, ai);
 896     }
 897 
 898   g_free (ai-&gt;exec);
 899   ai-&gt;exec = g_strdup (exec);
 900 
 901   if (count)
 902     ai-&gt;count = atoi (count);
 903   else
 904     ai-&gt;count = 1;
 905 
<span class="line-modified"> 906   if (modified != NULL)</span>
<span class="line-modified"> 907     {</span>
<span class="line-added"> 908       if (!timestamp_from_iso8601 (modified, &amp;ai-&gt;stamp, error))</span>
<span class="line-added"> 909         return;</span>
<span class="line-added"> 910     }</span>
 911   else
 912     {
 913       /* the timestamp attribute has been deprecated but we still parse
 914        * it for backward compatibility
 915        */
 916       if (stamp)
 917         ai-&gt;stamp = (time_t) atol (stamp);
 918       else
 919         ai-&gt;stamp = time (NULL);
 920     }
 921 }
 922 
 923 static void
 924 parse_mime_type_element (GMarkupParseContext  *context,
<span class="line-modified"> 925        ParseData            *parse_data,</span>
<span class="line-modified"> 926        const gchar         **attribute_names,</span>
<span class="line-modified"> 927        const gchar         **attribute_values,</span>
<span class="line-modified"> 928        GError              **error)</span>
 929 {
 930   const gchar *type;
 931   const gchar *attr;
 932   gint i;
 933   BookmarkItem *item;
 934 
 935   g_warn_if_fail ((parse_data != NULL) &amp;&amp; (parse_data-&gt;state == STATE_MIME));
 936 
 937   i = 0;
 938   type = NULL;
 939   for (attr = attribute_names[i]; attr != NULL; attr = attribute_names[++i])
 940     {
 941       if (IS_ATTRIBUTE (attr, MIME_TYPE_ATTRIBUTE))
 942         type = attribute_values[i];
 943     }
 944 
 945   if (!type)
 946     type = &quot;application/octet-stream&quot;;
 947 
 948   g_warn_if_fail (parse_data-&gt;current_item != NULL);
 949   item = parse_data-&gt;current_item;
 950 
 951   if (!item-&gt;metadata)
 952     item-&gt;metadata = bookmark_metadata_new ();
 953 
 954   g_free (item-&gt;metadata-&gt;mime_type);
 955   item-&gt;metadata-&gt;mime_type = g_strdup (type);
 956 }
 957 
 958 static void
 959 parse_icon_element (GMarkupParseContext  *context,
<span class="line-modified"> 960         ParseData            *parse_data,</span>
<span class="line-modified"> 961         const gchar         **attribute_names,</span>
<span class="line-modified"> 962         const gchar         **attribute_values,</span>
<span class="line-modified"> 963         GError              **error)</span>
 964 {
 965   const gchar *href;
 966   const gchar *type;
 967   const gchar *attr;
 968   gint i;
 969   BookmarkItem *item;
 970 
 971   g_warn_if_fail ((parse_data != NULL) &amp;&amp; (parse_data-&gt;state == STATE_ICON));
 972 
 973   i = 0;
 974   href = NULL;
 975   type = NULL;
 976   for (attr = attribute_names[i]; attr != NULL; attr = attribute_names[++i])
 977     {
 978       if (IS_ATTRIBUTE (attr, BOOKMARK_HREF_ATTRIBUTE))
 979         href = attribute_values[i];
 980       else if (IS_ATTRIBUTE (attr, BOOKMARK_TYPE_ATTRIBUTE))
 981         type = attribute_values[i];
 982     }
 983 
 984   /* the &quot;href&quot; attribute is mandatory */
 985   if (!href)
 986     {
 987       g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified"> 988              G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified"> 989              _(&quot;Attribute &#39;%s&#39; of element &#39;%s&#39; not found&quot;),</span>
<span class="line-modified"> 990              BOOKMARK_HREF_ATTRIBUTE,</span>
<span class="line-modified"> 991              BOOKMARK_ICON_ELEMENT);</span>
 992       return;
 993     }
 994 
 995   if (!type)
 996     type = &quot;application/octet-stream&quot;;
 997 
 998   g_warn_if_fail (parse_data-&gt;current_item != NULL);
 999   item = parse_data-&gt;current_item;
1000 
1001   if (!item-&gt;metadata)
1002     item-&gt;metadata = bookmark_metadata_new ();
1003 
1004   g_free (item-&gt;metadata-&gt;icon_href);
1005   g_free (item-&gt;metadata-&gt;icon_mime);
1006   item-&gt;metadata-&gt;icon_href = g_strdup (href);
1007   item-&gt;metadata-&gt;icon_mime = g_strdup (type);
1008 }
1009 
1010 /* scans through the attributes of an element for the &quot;xmlns&quot; pragma, and
1011  * adds any resulting namespace declaration to a per-parser hashtable, using
1012  * the namespace name as a key for the namespace URI; if no key was found,
1013  * the namespace is considered as default, and stored under the &quot;default&quot; key.
1014  *
1015  * FIXME: this works on the assumption that the generator of the XBEL file
1016  * is either this code or is smart enough to place the namespace declarations
1017  * inside the main root node or inside the metadata node and does not redefine
1018  * a namespace inside an inner node; this does *not* conform to the
1019  * XML-NS standard, although is a close approximation.  In order to make this
1020  * conformant to the XML-NS specification we should use a per-element
1021  * namespace table inside GMarkup and ask it to resolve the namespaces for us.
1022  */
1023 static void
1024 map_namespace_to_name (ParseData    *parse_data,
1025                        const gchar **attribute_names,
<span class="line-modified">1026            const gchar **attribute_values)</span>
1027 {
1028   const gchar *attr;
1029   gint i;
1030 
1031   g_warn_if_fail (parse_data != NULL);
1032 
1033   if (!attribute_names || !attribute_names[0])
1034     return;
1035 
1036   i = 0;
1037   for (attr = attribute_names[i]; attr; attr = attribute_names[++i])
1038     {
1039       if (g_str_has_prefix (attr, &quot;xmlns&quot;))
1040         {
1041           gchar *namespace_name, *namespace_uri;
1042           gchar *p;
1043 
1044           p = g_utf8_strchr (attr, -1, &#39;:&#39;);
1045           if (p)
1046             p = g_utf8_next_char (p);
</pre>
<hr />
<pre>
1101       element_name = element_full;
1102     }
1103 
1104   ns_uri = g_hash_table_lookup (parse_data-&gt;namespaces, ns_name);
1105   if (!ns_uri)
1106     {
1107       /* no default namespace found */
1108       g_free (ns_name);
1109 
1110       return (0 == strcmp (element_full, element));
1111     }
1112 
1113   retval = (0 == strcmp (ns_uri, namespace) &amp;&amp;
1114             0 == strcmp (element_name, element));
1115 
1116   g_free (ns_name);
1117 
1118   return retval;
1119 }
1120 
<span class="line-modified">1121 #define IS_ELEMENT(p,s,e) (is_element_full ((p), (s), NULL, (e), &#39;\0&#39;))</span>
1122 #define IS_ELEMENT_NS(p,s,n,e)  (is_element_full ((p), (s), (n), (e), &#39;|&#39;))
1123 
1124 static const gchar *
1125 parser_state_to_element_name (ParserState state)
1126 {
1127   switch (state)
1128     {
1129     case STATE_STARTED:
1130     case STATE_FINISHED:
1131       return &quot;(top-level)&quot;;
1132     case STATE_ROOT:
1133       return XBEL_ROOT_ELEMENT;
1134     case STATE_BOOKMARK:
1135       return XBEL_BOOKMARK_ELEMENT;
1136     case STATE_TITLE:
1137       return XBEL_TITLE_ELEMENT;
1138     case STATE_DESC:
1139       return XBEL_DESC_ELEMENT;
1140     case STATE_INFO:
1141       return XBEL_INFO_ELEMENT;
</pre>
<hr />
<pre>
1174    * only on the root node, where they usually are; this would probably break
1175    * on streams not produced by us or by &quot;smart&quot; generators
1176    */
1177   map_namespace_to_name (parse_data, attribute_names, attribute_values);
1178 
1179   switch (parse_data-&gt;state)
1180     {
1181     case STATE_STARTED:
1182       if (IS_ELEMENT (parse_data, element_name, XBEL_ROOT_ELEMENT))
1183         {
1184           const gchar *attr;
1185           gint i;
1186 
1187           i = 0;
1188           for (attr = attribute_names[i]; attr; attr = attribute_names[++i])
1189             {
1190               if ((IS_ATTRIBUTE (attr, XBEL_VERSION_ATTRIBUTE)) &amp;&amp;
1191                   (0 == strcmp (attribute_values[i], XBEL_VERSION)))
1192                 parse_data-&gt;state = STATE_ROOT;
1193             }
<span class="line-modified">1194   }</span>
1195       else
1196         g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified">1197          G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified">1198                  _(&quot;Unexpected tag &#39;%s&#39;, tag &#39;%s&#39; expected&quot;),</span>
<span class="line-modified">1199                  element_name, XBEL_ROOT_ELEMENT);</span>
1200       break;
1201     case STATE_ROOT:
1202       if (IS_ELEMENT (parse_data, element_name, XBEL_TITLE_ELEMENT))
1203         parse_data-&gt;state = STATE_TITLE;
1204       else if (IS_ELEMENT (parse_data, element_name, XBEL_DESC_ELEMENT))
1205         parse_data-&gt;state = STATE_DESC;
1206       else if (IS_ELEMENT (parse_data, element_name, XBEL_BOOKMARK_ELEMENT))
1207         {
1208           GError *inner_error = NULL;
1209 
1210           parse_data-&gt;state = STATE_BOOKMARK;
1211 
1212           parse_bookmark_element (context,
<span class="line-modified">1213                   parse_data,</span>
<span class="line-modified">1214                   attribute_names,</span>
<span class="line-modified">1215                   attribute_values,</span>
<span class="line-modified">1216                   &amp;inner_error);</span>
1217           if (inner_error)
1218             g_propagate_error (error, inner_error);
1219         }
1220       else
1221         g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified">1222                G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified">1223                _(&quot;Unexpected tag &#39;%s&#39; inside &#39;%s&#39;&quot;),</span>
<span class="line-modified">1224                element_name,</span>
<span class="line-modified">1225                XBEL_ROOT_ELEMENT);</span>
1226       break;
1227     case STATE_BOOKMARK:
1228       if (IS_ELEMENT (parse_data, element_name, XBEL_TITLE_ELEMENT))
1229         parse_data-&gt;state = STATE_TITLE;
1230       else if (IS_ELEMENT (parse_data, element_name, XBEL_DESC_ELEMENT))
1231         parse_data-&gt;state = STATE_DESC;
1232       else if (IS_ELEMENT (parse_data, element_name, XBEL_INFO_ELEMENT))
1233         parse_data-&gt;state = STATE_INFO;
1234       else
1235         g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified">1236                G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified">1237                  _(&quot;Unexpected tag &#39;%s&#39; inside &#39;%s&#39;&quot;),</span>
<span class="line-modified">1238                  element_name,</span>
<span class="line-modified">1239                  XBEL_BOOKMARK_ELEMENT);</span>
1240       break;
1241     case STATE_INFO:
1242       if (IS_ELEMENT (parse_data, element_name, XBEL_METADATA_ELEMENT))
1243         {
1244           const gchar *attr;
1245           gint i;
1246 
1247           i = 0;
1248           for (attr = attribute_names[i]; attr; attr = attribute_names[++i])
1249             {
1250               if ((IS_ATTRIBUTE (attr, XBEL_OWNER_ATTRIBUTE)) &amp;&amp;
1251                   (0 == strcmp (attribute_values[i], BOOKMARK_METADATA_OWNER)))
1252                 {
1253                   parse_data-&gt;state = STATE_METADATA;
1254 
1255                   if (!parse_data-&gt;current_item-&gt;metadata)
1256                     parse_data-&gt;current_item-&gt;metadata = bookmark_metadata_new ();
1257                 }
1258             }
1259         }
1260       else
1261         g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified">1262                G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified">1263                _(&quot;Unexpected tag &#39;%s&#39;, tag &#39;%s&#39; expected&quot;),</span>
<span class="line-modified">1264                element_name,</span>
<span class="line-modified">1265                XBEL_METADATA_ELEMENT);</span>
1266       break;
1267     case STATE_METADATA:
1268       if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_APPLICATIONS_ELEMENT))
1269         parse_data-&gt;state = STATE_APPLICATIONS;
1270       else if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_GROUPS_ELEMENT))
1271         parse_data-&gt;state = STATE_GROUPS;
1272       else if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_PRIVATE_ELEMENT))
1273         parse_data-&gt;current_item-&gt;metadata-&gt;is_private = TRUE;
1274       else if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_ICON_ELEMENT))
1275         {
1276           GError *inner_error = NULL;
1277 
<span class="line-modified">1278     parse_data-&gt;state = STATE_ICON;</span>
1279 
1280           parse_icon_element (context,
<span class="line-modified">1281                     parse_data,</span>
<span class="line-modified">1282                     attribute_names,</span>
<span class="line-modified">1283                     attribute_values,</span>
<span class="line-modified">1284                     &amp;inner_error);</span>
1285           if (inner_error)
1286             g_propagate_error (error, inner_error);
1287         }
1288       else if (IS_ELEMENT_NS (parse_data, element_name, MIME_NAMESPACE_URI, MIME_TYPE_ELEMENT))
1289         {
1290           GError *inner_error = NULL;
1291 
1292           parse_data-&gt;state = STATE_MIME;
1293 
1294           parse_mime_type_element (context,
<span class="line-modified">1295                    parse_data,</span>
<span class="line-modified">1296                    attribute_names,</span>
<span class="line-modified">1297                    attribute_values,</span>
<span class="line-modified">1298                    &amp;inner_error);</span>
1299           if (inner_error)
1300             g_propagate_error (error, inner_error);
1301         }
1302       else
1303         g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified">1304                G_MARKUP_ERROR_UNKNOWN_ELEMENT,</span>
<span class="line-modified">1305                _(&quot;Unexpected tag &#39;%s&#39; inside &#39;%s&#39;&quot;),</span>
<span class="line-modified">1306                element_name,</span>
<span class="line-modified">1307                XBEL_METADATA_ELEMENT);</span>
1308       break;
1309     case STATE_APPLICATIONS:
1310       if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_APPLICATION_ELEMENT))
1311         {
1312           GError *inner_error = NULL;
1313 
1314           parse_data-&gt;state = STATE_APPLICATION;
1315 
1316           parse_application_element (context,
<span class="line-modified">1317                      parse_data,</span>
<span class="line-modified">1318                      attribute_names,</span>
<span class="line-modified">1319                      attribute_values,</span>
<span class="line-modified">1320                      &amp;inner_error);</span>
1321           if (inner_error)
1322             g_propagate_error (error, inner_error);
1323         }
1324       else
1325         g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified">1326                G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified">1327                _(&quot;Unexpected tag &#39;%s&#39;, tag &#39;%s&#39; expected&quot;),</span>
<span class="line-modified">1328                element_name,</span>
<span class="line-modified">1329                BOOKMARK_APPLICATION_ELEMENT);</span>
1330       break;
1331     case STATE_GROUPS:
1332       if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_GROUP_ELEMENT))
1333         parse_data-&gt;state = STATE_GROUP;
1334       else
1335         g_set_error (error, G_MARKUP_ERROR,
<span class="line-modified">1336                G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified">1337                _(&quot;Unexpected tag &#39;%s&#39;, tag &#39;%s&#39; expected&quot;),</span>
<span class="line-modified">1338                element_name,</span>
<span class="line-modified">1339                BOOKMARK_GROUP_ELEMENT);</span>
1340       break;
1341 
1342     case STATE_TITLE:
1343     case STATE_DESC:
1344     case STATE_APPLICATION:
1345     case STATE_GROUP:
1346     case STATE_MIME:
1347     case STATE_ICON:
1348     case STATE_FINISHED:
1349       g_set_error (error, G_MARKUP_ERROR,
1350                    G_MARKUP_ERROR_INVALID_CONTENT,
1351                    _(&quot;Unexpected tag &#39;%s&#39; inside &#39;%s&#39;&quot;),
1352                    element_name,
1353                    parser_state_to_element_name (parse_data-&gt;state));
1354       break;
1355 
1356     default:
1357       g_assert_not_reached ();
1358       break;
1359     }
</pre>
<hr />
<pre>
1465       break;
1466     default:
1467       g_warn_if_reached ();
1468       break;
1469     }
1470 
1471   g_free (payload);
1472 }
1473 
1474 static const GMarkupParser markup_parser =
1475 {
1476   start_element_raw_cb, /* start_element */
1477   end_element_raw_cb,   /* end_element */
1478   text_raw_cb,          /* text */
1479   NULL,                 /* passthrough */
1480   NULL
1481 };
1482 
1483 static gboolean
1484 g_bookmark_file_parse (GBookmarkFile  *bookmark,
<span class="line-modified">1485        const gchar  *buffer,</span>
<span class="line-modified">1486        gsize         length,</span>
<span class="line-modified">1487        GError       **error)</span>
1488 {
1489   GMarkupParseContext *context;
1490   ParseData *parse_data;
1491   GError *parse_error, *end_error;
1492   gboolean retval;
1493 
1494   g_warn_if_fail (bookmark != NULL);
1495 
1496   if (!buffer)
1497     return FALSE;
1498 
1499   parse_error = NULL;
1500   end_error = NULL;
1501 
1502   if (length == (gsize) -1)
1503     length = strlen (buffer);
1504 
1505   parse_data = parse_data_new ();
1506   parse_data-&gt;bookmark_file = bookmark;
1507 
1508   context = g_markup_parse_context_new (&amp;markup_parser,
<span class="line-modified">1509             0,</span>
<span class="line-modified">1510             parse_data,</span>
<span class="line-modified">1511             (GDestroyNotify) parse_data_free);</span>
1512 
1513   retval = g_markup_parse_context_parse (context,
<span class="line-modified">1514              buffer,</span>
<span class="line-modified">1515              length,</span>
<span class="line-modified">1516              &amp;parse_error);</span>
1517   if (!retval)
1518     g_propagate_error (error, parse_error);
1519   else
1520    {
1521      retval = g_markup_parse_context_end_parse (context, &amp;end_error);
1522       if (!retval)
1523         g_propagate_error (error, end_error);
1524    }
1525 
1526   g_markup_parse_context_free (context);
1527 
1528   return retval;
1529 }
1530 
1531 static gchar *
1532 g_bookmark_file_dump (GBookmarkFile  *bookmark,
<span class="line-modified">1533           gsize          *length,</span>
<span class="line-modified">1534           GError        **error)</span>
1535 {
1536   GString *retval;
1537   gchar *buffer;
1538   GList *l;
1539 
1540   retval = g_string_sized_new (4096);
1541 
1542   g_string_append (retval,
<span class="line-modified">1543        &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;</span>
1544 #if 0
<span class="line-modified">1545        /* XXX - do we really need the doctype? */</span>
<span class="line-modified">1546        &quot;&lt;!DOCTYPE &quot; XBEL_DTD_NICK &quot;\n&quot;</span>
<span class="line-modified">1547        &quot;  PUBLIC \&quot;&quot; XBEL_DTD_SYSTEM &quot;\&quot;\n&quot;</span>
<span class="line-modified">1548        &quot;         \&quot;&quot; XBEL_DTD_URI &quot;\&quot;&gt;\n&quot;</span>
1549 #endif
<span class="line-modified">1550        &quot;&lt;&quot; XBEL_ROOT_ELEMENT &quot; &quot; XBEL_VERSION_ATTRIBUTE &quot;=\&quot;&quot; XBEL_VERSION &quot;\&quot;\n&quot;</span>
<span class="line-modified">1551        &quot;      xmlns:&quot; BOOKMARK_NAMESPACE_NAME &quot;=\&quot;&quot; BOOKMARK_NAMESPACE_URI &quot;\&quot;\n&quot;</span>
<span class="line-modified">1552        &quot;      xmlns:&quot; MIME_NAMESPACE_NAME     &quot;=\&quot;&quot; MIME_NAMESPACE_URI &quot;\&quot;\n&gt;&quot;);</span>
1553 
1554   if (bookmark-&gt;title)
1555     {
1556       gchar *escaped_title;
1557 
1558       escaped_title = g_markup_escape_text (bookmark-&gt;title, -1);
1559 
1560       buffer = g_strconcat (&quot;  &quot;
<span class="line-modified">1561           &quot;&lt;&quot; XBEL_TITLE_ELEMENT &quot;&gt;&quot;,</span>
<span class="line-modified">1562           escaped_title,</span>
<span class="line-modified">1563           &quot;&lt;/&quot; XBEL_TITLE_ELEMENT &quot;&gt;\n&quot;, NULL);</span>
1564 
1565       g_string_append (retval, buffer);
1566 
1567       g_free (buffer);
1568       g_free (escaped_title);
1569     }
1570 
1571   if (bookmark-&gt;description)
1572     {
1573       gchar *escaped_desc;
1574 
1575       escaped_desc = g_markup_escape_text (bookmark-&gt;description, -1);
1576 
1577       buffer = g_strconcat (&quot;  &quot;
<span class="line-modified">1578           &quot;&lt;&quot; XBEL_DESC_ELEMENT &quot;&gt;&quot;,</span>
<span class="line-modified">1579           escaped_desc,</span>
<span class="line-modified">1580           &quot;&lt;/&quot; XBEL_DESC_ELEMENT &quot;&gt;\n&quot;, NULL);</span>
1581       g_string_append (retval, buffer);
1582 
1583       g_free (buffer);
1584       g_free (escaped_desc);
1585     }
1586 
1587   if (!bookmark-&gt;items)
1588     goto out;
1589   else
1590     retval = g_string_append (retval, &quot;\n&quot;);
1591 
1592   /* the items are stored in reverse order */
1593   for (l = g_list_last (bookmark-&gt;items);
1594        l != NULL;
1595        l = l-&gt;prev)
1596     {
1597       BookmarkItem *item = (BookmarkItem *) l-&gt;data;
1598       gchar *item_dump;
1599 
1600       item_dump = bookmark_item_dump (item);
</pre>
<hr />
<pre>
1608 
1609 out:
1610   g_string_append (retval, &quot;&lt;/&quot; XBEL_ROOT_ELEMENT &quot;&gt;&quot;);
1611 
1612   if (length)
1613     *length = retval-&gt;len;
1614 
1615   return g_string_free (retval, FALSE);
1616 }
1617 
1618 /**************
1619  *    Misc    *
1620  **************/
1621 
1622 /* converts a Unix timestamp in a ISO 8601 compliant string; you
1623  * should free the returned string.
1624  */
1625 static gchar *
1626 timestamp_to_iso8601 (time_t timestamp)
1627 {
<span class="line-modified">1628   GDateTime *dt = g_date_time_new_from_unix_utc (timestamp);</span>
<span class="line-added">1629   gchar *iso8601_string = g_date_time_format_iso8601 (dt);</span>
<span class="line-added">1630   g_date_time_unref (dt);</span>
1631 
<span class="line-modified">1632   return g_steal_pointer (&amp;iso8601_string);</span>








1633 }
1634 
<span class="line-modified">1635 static gboolean</span>
<span class="line-modified">1636 timestamp_from_iso8601 (const gchar  *iso_date,</span>
<span class="line-added">1637                         time_t       *out_timestamp,</span>
<span class="line-added">1638                         GError      **error)</span>
1639 {
<span class="line-modified">1640   gint64 time_val;</span>
<span class="line-added">1641   GDateTime *dt = g_date_time_new_from_iso8601 (iso_date, NULL);</span>
<span class="line-added">1642   if (dt == NULL)</span>
<span class="line-added">1643     {</span>
<span class="line-added">1644       g_set_error (error, G_BOOKMARK_FILE_ERROR, G_BOOKMARK_FILE_ERROR_READ,</span>
<span class="line-added">1645                    _(&quot;Invalid date/time &#39;%s&#39; in bookmark file&quot;), iso_date);</span>
<span class="line-added">1646       return FALSE;</span>
<span class="line-added">1647     }</span>
1648 
<span class="line-modified">1649   time_val = g_date_time_to_unix (dt);</span>
<span class="line-modified">1650   g_date_time_unref (dt);</span>
1651 
<span class="line-modified">1652   *out_timestamp = time_val;</span>
<span class="line-added">1653   return TRUE;</span>
1654 }
1655 
1656 G_DEFINE_QUARK (g-bookmark-file-error-quark, g_bookmark_file_error)
1657 
1658 /********************
1659  *    Public API    *
1660  ********************/
1661 
1662 /**
1663  * g_bookmark_file_new: (constructor)
1664  *
1665  * Creates a new empty #GBookmarkFile object.
1666  *
1667  * Use g_bookmark_file_load_from_file(), g_bookmark_file_load_from_data()
1668  * or g_bookmark_file_load_from_data_dirs() to read an existing bookmark
1669  * file.
1670  *
1671  * Returns: an empty #GBookmarkFile
1672  *
1673  * Since: 2.12
</pre>
<hr />
<pre>
1704 }
1705 
1706 /**
1707  * g_bookmark_file_load_from_data:
1708  * @bookmark: an empty #GBookmarkFile struct
1709  * @data: (array length=length) (element-type guint8): desktop bookmarks
1710  *    loaded in memory
1711  * @length: the length of @data in bytes
1712  * @error: return location for a #GError, or %NULL
1713  *
1714  * Loads a bookmark file from memory into an empty #GBookmarkFile
1715  * structure.  If the object cannot be created then @error is set to a
1716  * #GBookmarkFileError.
1717  *
1718  * Returns: %TRUE if a desktop bookmark could be loaded.
1719  *
1720  * Since: 2.12
1721  */
1722 gboolean
1723 g_bookmark_file_load_from_data (GBookmarkFile  *bookmark,
<span class="line-modified">1724         const gchar    *data,</span>
<span class="line-modified">1725         gsize           length,</span>
<span class="line-modified">1726         GError        **error)</span>
1727 {
1728   GError *parse_error;
1729   gboolean retval;
1730 
1731   g_return_val_if_fail (bookmark != NULL, FALSE);
1732 
1733   if (length == (gsize) -1)
1734     length = strlen (data);
1735 
1736   if (bookmark-&gt;items)
1737     {
1738       g_bookmark_file_clear (bookmark);
1739       g_bookmark_file_init (bookmark);
1740     }
1741 
1742   parse_error = NULL;
1743   retval = g_bookmark_file_parse (bookmark, data, length, &amp;parse_error);
1744 
1745   if (!retval)
1746     g_propagate_error (error, parse_error);
</pre>
<hr />
<pre>
1748   return retval;
1749 }
1750 
1751 /**
1752  * g_bookmark_file_load_from_file:
1753  * @bookmark: an empty #GBookmarkFile struct
1754  * @filename: (type filename): the path of a filename to load, in the
1755  *     GLib file name encoding
1756  * @error: return location for a #GError, or %NULL
1757  *
1758  * Loads a desktop bookmark file into an empty #GBookmarkFile structure.
1759  * If the file could not be loaded then @error is set to either a #GFileError
1760  * or #GBookmarkFileError.
1761  *
1762  * Returns: %TRUE if a desktop bookmark file could be loaded
1763  *
1764  * Since: 2.12
1765  */
1766 gboolean
1767 g_bookmark_file_load_from_file (GBookmarkFile  *bookmark,
<span class="line-modified">1768         const gchar    *filename,</span>
<span class="line-modified">1769         GError        **error)</span>
1770 {
1771   gboolean ret = FALSE;
1772   gchar *buffer = NULL;
1773   gsize len;
1774 
1775   g_return_val_if_fail (bookmark != NULL, FALSE);
1776   g_return_val_if_fail (filename != NULL, FALSE);
1777 
1778   if (!g_file_get_contents (filename, &amp;buffer, &amp;len, error))
1779     goto out;
1780 
1781   if (!g_bookmark_file_load_from_data (bookmark, buffer, len, error))
1782     goto out;
1783 
1784   ret = TRUE;
1785  out:
1786   g_free (buffer);
1787   return ret;
1788 }
1789 
</pre>
<hr />
<pre>
1860 /**
1861  * g_bookmark_file_load_from_data_dirs:
1862  * @bookmark: a #GBookmarkFile
1863  * @file: (type filename): a relative path to a filename to open and parse
1864  * @full_path: (out) (optional) (type filename): return location for a string
1865  *    containing the full path of the file, or %NULL
1866  * @error: return location for a #GError, or %NULL
1867  *
1868  * This function looks for a desktop bookmark file named @file in the
1869  * paths returned from g_get_user_data_dir() and g_get_system_data_dirs(),
1870  * loads the file into @bookmark and returns the file&#39;s full path in
1871  * @full_path.  If the file could not be loaded then @error is
1872  * set to either a #GFileError or #GBookmarkFileError.
1873  *
1874  * Returns: %TRUE if a key file could be loaded, %FALSE otherwise
1875  *
1876  * Since: 2.12
1877  */
1878 gboolean
1879 g_bookmark_file_load_from_data_dirs (GBookmarkFile  *bookmark,
<span class="line-modified">1880              const gchar    *file,</span>
<span class="line-modified">1881              gchar         **full_path,</span>
<span class="line-modified">1882              GError        **error)</span>
1883 {
1884   GError *file_error = NULL;
1885   gchar **all_data_dirs, **data_dirs;
1886   const gchar *user_data_dir;
1887   const gchar * const * system_data_dirs;
1888   gsize i, j;
1889   gchar *output_path;
1890   gboolean found_file;
1891 
1892   g_return_val_if_fail (bookmark != NULL, FALSE);
1893   g_return_val_if_fail (!g_path_is_absolute (file), FALSE);
1894 
1895   user_data_dir = g_get_user_data_dir ();
1896   system_data_dirs = g_get_system_data_dirs ();
1897   all_data_dirs = g_new0 (gchar *, g_strv_length ((gchar **)system_data_dirs) + 2);
1898 
1899   i = 0;
1900   all_data_dirs[i++] = g_strdup (user_data_dir);
1901 
1902   j = 0;
1903   while (system_data_dirs[j] != NULL)
1904     all_data_dirs[i++] = g_strdup (system_data_dirs[j++]);
1905 
1906   found_file = FALSE;
1907   data_dirs = all_data_dirs;
1908   output_path = NULL;
1909   while (*data_dirs != NULL &amp;&amp; !found_file)
1910     {
1911       g_free (output_path);
1912 
1913       output_path = find_file_in_data_dirs (file, &amp;data_dirs, &amp;file_error);
1914 
1915       if (file_error)
1916         {
1917           g_propagate_error (error, file_error);
<span class="line-modified">1918     break;</span>
1919         }
1920 
1921       found_file = g_bookmark_file_load_from_file (bookmark,
<span class="line-modified">1922                      output_path,</span>
<span class="line-modified">1923                      &amp;file_error);</span>
1924       if (file_error)
1925         {
<span class="line-modified">1926     g_propagate_error (error, file_error);</span>
<span class="line-modified">1927     break;</span>
1928         }
1929     }
1930 
1931   if (found_file &amp;&amp; full_path)
1932     *full_path = output_path;
1933   else
1934     g_free (output_path);
1935 
1936   g_strfreev (all_data_dirs);
1937 
1938   return found_file;
1939 }
1940 
1941 
1942 /**
1943  * g_bookmark_file_to_data:
1944  * @bookmark: a #GBookmarkFile
1945  * @length: (out) (optional): return location for the length of the returned string, or %NULL
1946  * @error: return location for a #GError, or %NULL
1947  *
1948  * This function outputs @bookmark as a string.
1949  *
1950  * Returns: (array length=length) (element-type guint8):
1951  *   a newly allocated string holding the contents of the #GBookmarkFile
1952  *
1953  * Since: 2.12
1954  */
1955 gchar *
1956 g_bookmark_file_to_data (GBookmarkFile  *bookmark,
<span class="line-modified">1957        gsize          *length,</span>
<span class="line-modified">1958        GError        **error)</span>
1959 {
1960   GError *write_error = NULL;
1961   gchar *retval;
1962 
1963   g_return_val_if_fail (bookmark != NULL, NULL);
1964 
1965   retval = g_bookmark_file_dump (bookmark, length, &amp;write_error);
1966   if (write_error)
1967     {
1968       g_propagate_error (error, write_error);
1969 
1970       return NULL;
1971     }
1972 
1973   return retval;
1974 }
1975 
1976 /**
1977  * g_bookmark_file_to_file:
1978  * @bookmark: a #GBookmarkFile
1979  * @filename: (type filename): path of the output file
1980  * @error: return location for a #GError, or %NULL
1981  *
1982  * This function outputs @bookmark into a file.  The write process is
1983  * guaranteed to be atomic by using g_file_set_contents() internally.
1984  *
1985  * Returns: %TRUE if the file was successfully written.
1986  *
1987  * Since: 2.12
1988  */
1989 gboolean
1990 g_bookmark_file_to_file (GBookmarkFile  *bookmark,
<span class="line-modified">1991        const gchar    *filename,</span>
<span class="line-modified">1992        GError        **error)</span>
1993 {
1994   gchar *data;
1995   GError *data_error, *write_error;
1996   gsize len;
1997   gboolean retval;
1998 
1999   g_return_val_if_fail (bookmark != NULL, FALSE);
2000   g_return_val_if_fail (filename != NULL, FALSE);
2001 
2002   data_error = NULL;
2003   data = g_bookmark_file_to_data (bookmark, &amp;len, &amp;data_error);
2004   if (data_error)
2005     {
2006       g_propagate_error (error, data_error);
2007 
2008       return FALSE;
2009     }
2010 
2011   write_error = NULL;
2012   g_file_set_contents (filename, data, len, &amp;write_error);
2013   if (write_error)
2014     {
2015       g_propagate_error (error, write_error);
2016 
2017       retval = FALSE;
2018     }
2019   else
2020     retval = TRUE;
2021 
2022   g_free (data);
2023 
2024   return retval;
2025 }
2026 
2027 static BookmarkItem *
2028 g_bookmark_file_lookup_item (GBookmarkFile *bookmark,
<span class="line-modified">2029            const gchar   *uri)</span>
2030 {
2031   g_warn_if_fail (bookmark != NULL &amp;&amp; uri != NULL);
2032 
2033   return g_hash_table_lookup (bookmark-&gt;items_by_uri, uri);
2034 }
2035 
2036 /* this function adds a new item to the list */
2037 static void
2038 g_bookmark_file_add_item (GBookmarkFile  *bookmark,
<span class="line-modified">2039         BookmarkItem   *item,</span>
<span class="line-modified">2040         GError        **error)</span>
2041 {
2042   g_warn_if_fail (bookmark != NULL);
2043   g_warn_if_fail (item != NULL);
2044 
2045 #ifdef GSTREAMER_LITE
2046   if (bookmark == NULL || item == NULL) {
2047     return;
2048   }
2049 #endif // GSTREAMER_LITE
2050 
2051   /* this should never happen; and if it does, then we are
2052    * screwing up something big time.
2053    */
2054   if (G_UNLIKELY (g_bookmark_file_has_item (bookmark, item-&gt;uri)))
2055     {
2056       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2057        G_BOOKMARK_FILE_ERROR_INVALID_URI,</span>
<span class="line-modified">2058        _(&quot;A bookmark for URI &#39;%s&#39; already exists&quot;),</span>
<span class="line-modified">2059        item-&gt;uri);</span>
2060       return;
2061     }
2062 
2063   bookmark-&gt;items = g_list_prepend (bookmark-&gt;items, item);
2064 
2065   g_hash_table_replace (bookmark-&gt;items_by_uri,
<span class="line-modified">2066       item-&gt;uri,</span>
<span class="line-modified">2067       item);</span>
2068 
2069   if (item-&gt;added == (time_t) -1)
2070     item-&gt;added = time (NULL);
2071 
2072   if (item-&gt;modified == (time_t) -1)
2073     item-&gt;modified = time (NULL);
2074 }
2075 
2076 /**
2077  * g_bookmark_file_remove_item:
2078  * @bookmark: a #GBookmarkFile
2079  * @uri: a valid URI
2080  * @error: return location for a #GError, or %NULL
2081  *
2082  * Removes the bookmark for @uri from the bookmark file @bookmark.
2083  *
2084  * Returns: %TRUE if the bookmark was removed successfully.
2085  *
2086  * Since: 2.12
2087  */
2088 gboolean
2089 g_bookmark_file_remove_item (GBookmarkFile  *bookmark,
<span class="line-modified">2090            const gchar    *uri,</span>
<span class="line-modified">2091            GError        **error)</span>
2092 {
2093   BookmarkItem *item;
2094 
2095   g_return_val_if_fail (bookmark != NULL, FALSE);
2096   g_return_val_if_fail (uri != NULL, FALSE);
2097 
2098   item = g_bookmark_file_lookup_item (bookmark, uri);
2099 
2100   if (!item)
2101     {
2102       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2103        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2104        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2105        uri);</span>
2106       return FALSE;
2107     }
2108 
2109   bookmark-&gt;items = g_list_remove (bookmark-&gt;items, item);
2110   g_hash_table_remove (bookmark-&gt;items_by_uri, item-&gt;uri);
2111 
2112   bookmark_item_free (item);
2113 
2114   return TRUE;
2115 }
2116 
2117 /**
2118  * g_bookmark_file_has_item:
2119  * @bookmark: a #GBookmarkFile
2120  * @uri: a valid URI
2121  *
2122  * Looks whether the desktop bookmark has an item with its URI set to @uri.
2123  *
2124  * Returns: %TRUE if @uri is inside @bookmark, %FALSE otherwise
2125  *
2126  * Since: 2.12
2127  */
2128 gboolean
2129 g_bookmark_file_has_item (GBookmarkFile *bookmark,
<span class="line-modified">2130         const gchar   *uri)</span>
2131 {
2132   g_return_val_if_fail (bookmark != NULL, FALSE);
2133   g_return_val_if_fail (uri != NULL, FALSE);
2134 
2135   return (NULL != g_hash_table_lookup (bookmark-&gt;items_by_uri, uri));
2136 }
2137 
2138 /**
2139  * g_bookmark_file_get_uris:
2140  * @bookmark: a #GBookmarkFile
2141  * @length: (out) (optional): return location for the number of returned URIs, or %NULL
2142  *
2143  * Returns all URIs of the bookmarks in the bookmark file @bookmark.
2144  * The array of returned URIs will be %NULL-terminated, so @length may
2145  * optionally be %NULL.
2146  *
2147  * Returns: (array length=length) (transfer full): a newly allocated %NULL-terminated array of strings.
2148  *   Use g_strfreev() to free it.
2149  *
2150  * Since: 2.12
2151  */
2152 gchar **
2153 g_bookmark_file_get_uris (GBookmarkFile *bookmark,
<span class="line-modified">2154         gsize         *length)</span>
2155 {
2156   GList *l;
2157   gchar **uris;
2158   gsize i, n_items;
2159 
2160   g_return_val_if_fail (bookmark != NULL, NULL);
2161 
2162   n_items = g_list_length (bookmark-&gt;items);
2163   uris = g_new0 (gchar *, n_items + 1);
2164 
2165   /* the items are stored in reverse order, so we walk the list backward */
2166   for (l = g_list_last (bookmark-&gt;items), i = 0; l != NULL; l = l-&gt;prev)
2167     {
2168       BookmarkItem *item = (BookmarkItem *) l-&gt;data;
2169 
2170       g_warn_if_fail (item != NULL);
2171 
2172       uris[i++] = g_strdup (item-&gt;uri);
2173     }
2174   uris[i] = NULL;
</pre>
<hr />
<pre>
2179   return uris;
2180 }
2181 
2182 /**
2183  * g_bookmark_file_set_title:
2184  * @bookmark: a #GBookmarkFile
2185  * @uri: (nullable): a valid URI or %NULL
2186  * @title: a UTF-8 encoded string
2187  *
2188  * Sets @title as the title of the bookmark for @uri inside the
2189  * bookmark file @bookmark.
2190  *
2191  * If @uri is %NULL, the title of @bookmark is set.
2192  *
2193  * If a bookmark for @uri cannot be found then it is created.
2194  *
2195  * Since: 2.12
2196  */
2197 void
2198 g_bookmark_file_set_title (GBookmarkFile *bookmark,
<span class="line-modified">2199          const gchar   *uri,</span>
<span class="line-modified">2200          const gchar   *title)</span>
2201 {
2202   g_return_if_fail (bookmark != NULL);
2203 
2204   if (!uri)
2205     {
2206       g_free (bookmark-&gt;title);
2207       bookmark-&gt;title = g_strdup (title);
2208     }
2209   else
2210     {
2211       BookmarkItem *item;
2212 
2213       item = g_bookmark_file_lookup_item (bookmark, uri);
2214       if (!item)
2215         {
2216           item = bookmark_item_new (uri);
2217           g_bookmark_file_add_item (bookmark, item, NULL);
2218         }
2219 
2220       g_free (item-&gt;title);
</pre>
<hr />
<pre>
2227 /**
2228  * g_bookmark_file_get_title:
2229  * @bookmark: a #GBookmarkFile
2230  * @uri: (nullable): a valid URI or %NULL
2231  * @error: return location for a #GError, or %NULL
2232  *
2233  * Returns the title of the bookmark for @uri.
2234  *
2235  * If @uri is %NULL, the title of @bookmark is returned.
2236  *
2237  * In the event the URI cannot be found, %NULL is returned and
2238  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2239  *
2240  * Returns: a newly allocated string or %NULL if the specified
2241  *   URI cannot be found.
2242  *
2243  * Since: 2.12
2244  */
2245 gchar *
2246 g_bookmark_file_get_title (GBookmarkFile  *bookmark,
<span class="line-modified">2247          const gchar    *uri,</span>
<span class="line-modified">2248          GError        **error)</span>
2249 {
2250   BookmarkItem *item;
2251 
2252   g_return_val_if_fail (bookmark != NULL, NULL);
2253 
2254   if (!uri)
2255     return g_strdup (bookmark-&gt;title);
2256 
2257   item = g_bookmark_file_lookup_item (bookmark, uri);
2258   if (!item)
2259     {
2260       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2261        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2262        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2263        uri);</span>
2264       return NULL;
2265     }
2266 
2267   return g_strdup (item-&gt;title);
2268 }
2269 
2270 /**
2271  * g_bookmark_file_set_description:
2272  * @bookmark: a #GBookmarkFile
2273  * @uri: (nullable): a valid URI or %NULL
2274  * @description: a string
2275  *
2276  * Sets @description as the description of the bookmark for @uri.
2277  *
2278  * If @uri is %NULL, the description of @bookmark is set.
2279  *
2280  * If a bookmark for @uri cannot be found then it is created.
2281  *
2282  * Since: 2.12
2283  */
2284 void
2285 g_bookmark_file_set_description (GBookmarkFile *bookmark,
<span class="line-modified">2286          const gchar   *uri,</span>
<span class="line-modified">2287          const gchar   *description)</span>
2288 {
2289   g_return_if_fail (bookmark != NULL);
2290 
2291   if (!uri)
2292     {
2293       g_free (bookmark-&gt;description);
2294       bookmark-&gt;description = g_strdup (description);
2295     }
2296   else
2297     {
2298       BookmarkItem *item;
2299 
2300       item = g_bookmark_file_lookup_item (bookmark, uri);
2301       if (!item)
2302         {
2303           item = bookmark_item_new (uri);
2304           g_bookmark_file_add_item (bookmark, item, NULL);
2305         }
2306 
2307       g_free (item-&gt;description);
</pre>
<hr />
<pre>
2312 }
2313 
2314 /**
2315  * g_bookmark_file_get_description:
2316  * @bookmark: a #GBookmarkFile
2317  * @uri: a valid URI
2318  * @error: return location for a #GError, or %NULL
2319  *
2320  * Retrieves the description of the bookmark for @uri.
2321  *
2322  * In the event the URI cannot be found, %NULL is returned and
2323  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2324  *
2325  * Returns: a newly allocated string or %NULL if the specified
2326  *   URI cannot be found.
2327  *
2328  * Since: 2.12
2329  */
2330 gchar *
2331 g_bookmark_file_get_description (GBookmarkFile  *bookmark,
<span class="line-modified">2332          const gchar    *uri,</span>
<span class="line-modified">2333          GError        **error)</span>
2334 {
2335   BookmarkItem *item;
2336 
2337   g_return_val_if_fail (bookmark != NULL, NULL);
2338 
2339   if (!uri)
2340     return g_strdup (bookmark-&gt;description);
2341 
2342   item = g_bookmark_file_lookup_item (bookmark, uri);
2343   if (!item)
2344     {
2345       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2346        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2347        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2348        uri);</span>
2349       return NULL;
2350     }
2351 
2352   return g_strdup (item-&gt;description);
2353 }
2354 
2355 /**
2356  * g_bookmark_file_set_mime_type:
2357  * @bookmark: a #GBookmarkFile
2358  * @uri: a valid URI
2359  * @mime_type: a MIME type
2360  *
2361  * Sets @mime_type as the MIME type of the bookmark for @uri.
2362  *
2363  * If a bookmark for @uri cannot be found then it is created.
2364  *
2365  * Since: 2.12
2366  */
2367 void
2368 g_bookmark_file_set_mime_type (GBookmarkFile *bookmark,
<span class="line-modified">2369              const gchar   *uri,</span>
<span class="line-modified">2370              const gchar   *mime_type)</span>
2371 {
2372   BookmarkItem *item;
2373 
2374   g_return_if_fail (bookmark != NULL);
2375   g_return_if_fail (uri != NULL);
2376   g_return_if_fail (mime_type != NULL);
2377 
2378   item = g_bookmark_file_lookup_item (bookmark, uri);
2379   if (!item)
2380     {
2381       item = bookmark_item_new (uri);
2382       g_bookmark_file_add_item (bookmark, item, NULL);
2383     }
2384 
2385   if (!item-&gt;metadata)
2386     item-&gt;metadata = bookmark_metadata_new ();
2387 
2388   g_free (item-&gt;metadata-&gt;mime_type);
2389 
2390   item-&gt;metadata-&gt;mime_type = g_strdup (mime_type);
</pre>
<hr />
<pre>
2394 /**
2395  * g_bookmark_file_get_mime_type:
2396  * @bookmark: a #GBookmarkFile
2397  * @uri: a valid URI
2398  * @error: return location for a #GError, or %NULL
2399  *
2400  * Retrieves the MIME type of the resource pointed by @uri.
2401  *
2402  * In the event the URI cannot be found, %NULL is returned and
2403  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
2404  * event that the MIME type cannot be found, %NULL is returned and
2405  * @error is set to #G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
2406  *
2407  * Returns: a newly allocated string or %NULL if the specified
2408  *   URI cannot be found.
2409  *
2410  * Since: 2.12
2411  */
2412 gchar *
2413 g_bookmark_file_get_mime_type (GBookmarkFile  *bookmark,
<span class="line-modified">2414              const gchar    *uri,</span>
<span class="line-modified">2415              GError        **error)</span>
2416 {
2417   BookmarkItem *item;
2418 
2419   g_return_val_if_fail (bookmark != NULL, NULL);
2420   g_return_val_if_fail (uri != NULL, NULL);
2421 
2422   item = g_bookmark_file_lookup_item (bookmark, uri);
2423   if (!item)
2424     {
2425       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2426        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2427        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2428        uri);</span>
2429       return NULL;
2430     }
2431 
2432   if (!item-&gt;metadata)
2433     {
2434       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2435        G_BOOKMARK_FILE_ERROR_INVALID_VALUE,</span>
<span class="line-modified">2436        _(&quot;No MIME type defined in the bookmark for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2437        uri);</span>
2438       return NULL;
2439     }
2440 
2441   return g_strdup (item-&gt;metadata-&gt;mime_type);
2442 }
2443 
2444 /**
2445  * g_bookmark_file_set_is_private:
2446  * @bookmark: a #GBookmarkFile
2447  * @uri: a valid URI
2448  * @is_private: %TRUE if the bookmark should be marked as private
2449  *
2450  * Sets the private flag of the bookmark for @uri.
2451  *
2452  * If a bookmark for @uri cannot be found then it is created.
2453  *
2454  * Since: 2.12
2455  */
2456 void
2457 g_bookmark_file_set_is_private (GBookmarkFile *bookmark,
<span class="line-modified">2458         const gchar   *uri,</span>
<span class="line-modified">2459         gboolean       is_private)</span>
2460 {
2461   BookmarkItem *item;
2462 
2463   g_return_if_fail (bookmark != NULL);
2464   g_return_if_fail (uri != NULL);
2465 
2466   item = g_bookmark_file_lookup_item (bookmark, uri);
2467   if (!item)
2468     {
2469       item = bookmark_item_new (uri);
2470       g_bookmark_file_add_item (bookmark, item, NULL);
2471     }
2472 
2473   if (!item-&gt;metadata)
2474     item-&gt;metadata = bookmark_metadata_new ();
2475 
2476   item-&gt;metadata-&gt;is_private = (is_private == TRUE);
2477   item-&gt;modified = time (NULL);
2478 }
2479 
2480 /**
2481  * g_bookmark_file_get_is_private:
2482  * @bookmark: a #GBookmarkFile
2483  * @uri: a valid URI
2484  * @error: return location for a #GError, or %NULL
2485  *
2486  * Gets whether the private flag of the bookmark for @uri is set.
2487  *
2488  * In the event the URI cannot be found, %FALSE is returned and
2489  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
2490  * event that the private flag cannot be found, %FALSE is returned and
2491  * @error is set to #G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
2492  *
2493  * Returns: %TRUE if the private flag is set, %FALSE otherwise.
2494  *
2495  * Since: 2.12
2496  */
2497 gboolean
2498 g_bookmark_file_get_is_private (GBookmarkFile  *bookmark,
<span class="line-modified">2499         const gchar    *uri,</span>
<span class="line-modified">2500         GError        **error)</span>
2501 {
2502   BookmarkItem *item;
2503 
2504   g_return_val_if_fail (bookmark != NULL, FALSE);
2505   g_return_val_if_fail (uri != NULL, FALSE);
2506 
2507   item = g_bookmark_file_lookup_item (bookmark, uri);
2508   if (!item)
2509     {
2510       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2511        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2512        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2513        uri);</span>
2514       return FALSE;
2515     }
2516 
2517   if (!item-&gt;metadata)
2518     {
2519       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2520        G_BOOKMARK_FILE_ERROR_INVALID_VALUE,</span>
<span class="line-modified">2521        _(&quot;No private flag has been defined in bookmark for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2522         uri);</span>
2523       return FALSE;
2524     }
2525 
2526   return item-&gt;metadata-&gt;is_private;
2527 }
2528 
2529 /**
2530  * g_bookmark_file_set_added:
2531  * @bookmark: a #GBookmarkFile
2532  * @uri: a valid URI
2533  * @added: a timestamp or -1 to use the current time
2534  *
2535  * Sets the time the bookmark for @uri was added into @bookmark.
2536  *
2537  * If no bookmark for @uri is found then it is created.
2538  *
2539  * Since: 2.12
2540  */
2541 void
2542 g_bookmark_file_set_added (GBookmarkFile *bookmark,
<span class="line-modified">2543          const gchar   *uri,</span>
<span class="line-modified">2544          time_t         added)</span>
2545 {
2546   BookmarkItem *item;
2547 
2548   g_return_if_fail (bookmark != NULL);
2549   g_return_if_fail (uri != NULL);
2550 
2551   item = g_bookmark_file_lookup_item (bookmark, uri);
2552   if (!item)
2553     {
2554       item = bookmark_item_new (uri);
2555       g_bookmark_file_add_item (bookmark, item, NULL);
2556     }
2557 
2558   if (added == (time_t) -1)
2559     time (&amp;added);
2560 
2561   item-&gt;added = added;
2562   item-&gt;modified = added;
2563 }
2564 
2565 /**
2566  * g_bookmark_file_get_added:
2567  * @bookmark: a #GBookmarkFile
2568  * @uri: a valid URI
2569  * @error: return location for a #GError, or %NULL
2570  *
2571  * Gets the time the bookmark for @uri was added to @bookmark
2572  *
2573  * In the event the URI cannot be found, -1 is returned and
2574  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2575  *
2576  * Returns: a timestamp
2577  *
2578  * Since: 2.12
2579  */
2580 time_t
2581 g_bookmark_file_get_added (GBookmarkFile  *bookmark,
<span class="line-modified">2582          const gchar    *uri,</span>
<span class="line-modified">2583          GError        **error)</span>
2584 {
2585   BookmarkItem *item;
2586 
2587   g_return_val_if_fail (bookmark != NULL, (time_t) -1);
2588   g_return_val_if_fail (uri != NULL, (time_t) -1);
2589 
2590   item = g_bookmark_file_lookup_item (bookmark, uri);
2591   if (!item)
2592     {
2593       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2594        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2595        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2596        uri);</span>
2597       return (time_t) -1;
2598     }
2599 
2600   return item-&gt;added;
2601 }
2602 
2603 /**
2604  * g_bookmark_file_set_modified:
2605  * @bookmark: a #GBookmarkFile
2606  * @uri: a valid URI
2607  * @modified: a timestamp or -1 to use the current time
2608  *
2609  * Sets the last time the bookmark for @uri was last modified.
2610  *
2611  * If no bookmark for @uri is found then it is created.
2612  *
2613  * The &quot;modified&quot; time should only be set when the bookmark&#39;s meta-data
2614  * was actually changed.  Every function of #GBookmarkFile that
2615  * modifies a bookmark also changes the modification time, except for
2616  * g_bookmark_file_set_visited().
2617  *
2618  * Since: 2.12
2619  */
2620 void
2621 g_bookmark_file_set_modified (GBookmarkFile *bookmark,
<span class="line-modified">2622             const gchar   *uri,</span>
<span class="line-modified">2623             time_t         modified)</span>
2624 {
2625   BookmarkItem *item;
2626 
2627   g_return_if_fail (bookmark != NULL);
2628   g_return_if_fail (uri != NULL);
2629 
2630   item = g_bookmark_file_lookup_item (bookmark, uri);
2631   if (!item)
2632     {
2633       item = bookmark_item_new (uri);
2634       g_bookmark_file_add_item (bookmark, item, NULL);
2635     }
2636 
2637   if (modified == (time_t) -1)
2638     time (&amp;modified);
2639 
2640   item-&gt;modified = modified;
2641 }
2642 
2643 /**
2644  * g_bookmark_file_get_modified:
2645  * @bookmark: a #GBookmarkFile
2646  * @uri: a valid URI
2647  * @error: return location for a #GError, or %NULL
2648  *
2649  * Gets the time when the bookmark for @uri was last modified.
2650  *
2651  * In the event the URI cannot be found, -1 is returned and
2652  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2653  *
2654  * Returns: a timestamp
2655  *
2656  * Since: 2.12
2657  */
2658 time_t
2659 g_bookmark_file_get_modified (GBookmarkFile  *bookmark,
<span class="line-modified">2660             const gchar    *uri,</span>
<span class="line-modified">2661             GError        **error)</span>
2662 {
2663   BookmarkItem *item;
2664 
2665   g_return_val_if_fail (bookmark != NULL, (time_t) -1);
2666   g_return_val_if_fail (uri != NULL, (time_t) -1);
2667 
2668   item = g_bookmark_file_lookup_item (bookmark, uri);
2669   if (!item)
2670     {
2671       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2672        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2673        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2674        uri);</span>
2675       return (time_t) -1;
2676     }
2677 
2678   return item-&gt;modified;
2679 }
2680 
2681 /**
2682  * g_bookmark_file_set_visited:
2683  * @bookmark: a #GBookmarkFile
2684  * @uri: a valid URI
2685  * @visited: a timestamp or -1 to use the current time
2686  *
2687  * Sets the time the bookmark for @uri was last visited.
2688  *
2689  * If no bookmark for @uri is found then it is created.
2690  *
2691  * The &quot;visited&quot; time should only be set if the bookmark was launched,
2692  * either using the command line retrieved by g_bookmark_file_get_app_info()
2693  * or by the default application for the bookmark&#39;s MIME type, retrieved
2694  * using g_bookmark_file_get_mime_type().  Changing the &quot;visited&quot; time
2695  * does not affect the &quot;modified&quot; time.
2696  *
2697  * Since: 2.12
2698  */
2699 void
2700 g_bookmark_file_set_visited (GBookmarkFile *bookmark,
<span class="line-modified">2701            const gchar   *uri,</span>
<span class="line-modified">2702            time_t         visited)</span>
2703 {
2704   BookmarkItem *item;
2705 
2706   g_return_if_fail (bookmark != NULL);
2707   g_return_if_fail (uri != NULL);
2708 
2709   item = g_bookmark_file_lookup_item (bookmark, uri);
2710   if (!item)
2711     {
2712       item = bookmark_item_new (uri);
2713       g_bookmark_file_add_item (bookmark, item, NULL);
2714     }
2715 
2716   if (visited == (time_t) -1)
2717     time (&amp;visited);
2718 
2719   item-&gt;visited = visited;
2720 }
2721 
2722 /**
2723  * g_bookmark_file_get_visited:
2724  * @bookmark: a #GBookmarkFile
2725  * @uri: a valid URI
2726  * @error: return location for a #GError, or %NULL
2727  *
2728  * Gets the time the bookmark for @uri was last visited.
2729  *
2730  * In the event the URI cannot be found, -1 is returned and
2731  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2732  *
2733  * Returns: a timestamp.
2734  *
2735  * Since: 2.12
2736  */
2737 time_t
2738 g_bookmark_file_get_visited (GBookmarkFile  *bookmark,
<span class="line-modified">2739            const gchar    *uri,</span>
<span class="line-modified">2740            GError        **error)</span>
2741 {
2742   BookmarkItem *item;
2743 
2744   g_return_val_if_fail (bookmark != NULL, (time_t) -1);
2745   g_return_val_if_fail (uri != NULL, (time_t) -1);
2746 
2747   item = g_bookmark_file_lookup_item (bookmark, uri);
2748   if (!item)
2749     {
2750       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2751        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2752        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2753        uri);</span>
2754       return (time_t) -1;
2755     }
2756 
2757   return item-&gt;visited;
2758 }
2759 
2760 /**
2761  * g_bookmark_file_has_group:
2762  * @bookmark: a #GBookmarkFile
2763  * @uri: a valid URI
2764  * @group: the group name to be searched
2765  * @error: return location for a #GError, or %NULL
2766  *
2767  * Checks whether @group appears in the list of groups to which
2768  * the bookmark for @uri belongs to.
2769  *
2770  * In the event the URI cannot be found, %FALSE is returned and
2771  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2772  *
2773  * Returns: %TRUE if @group was found.
2774  *
2775  * Since: 2.12
2776  */
2777 gboolean
2778 g_bookmark_file_has_group (GBookmarkFile  *bookmark,
<span class="line-modified">2779          const gchar    *uri,</span>
<span class="line-modified">2780          const gchar    *group,</span>
<span class="line-modified">2781          GError        **error)</span>
2782 {
2783   BookmarkItem *item;
2784   GList *l;
2785 
2786   g_return_val_if_fail (bookmark != NULL, FALSE);
2787   g_return_val_if_fail (uri != NULL, FALSE);
2788 
2789   item = g_bookmark_file_lookup_item (bookmark, uri);
2790   if (!item)
2791     {
2792       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2793        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2794        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2795        uri);</span>
2796       return FALSE;
2797     }
2798 
2799   if (!item-&gt;metadata)
2800     return FALSE;
2801 
2802   for (l = item-&gt;metadata-&gt;groups; l != NULL; l = l-&gt;next)
2803     {
2804       if (strcmp (l-&gt;data, group) == 0)
2805         return TRUE;
2806     }
2807 
2808   return FALSE;
2809 
2810 }
2811 
2812 /**
2813  * g_bookmark_file_add_group:
2814  * @bookmark: a #GBookmarkFile
2815  * @uri: a valid URI
2816  * @group: the group name to be added
2817  *
2818  * Adds @group to the list of groups to which the bookmark for @uri
2819  * belongs to.
2820  *
2821  * If no bookmark for @uri is found then it is created.
2822  *
2823  * Since: 2.12
2824  */
2825 void
2826 g_bookmark_file_add_group (GBookmarkFile *bookmark,
<span class="line-modified">2827          const gchar   *uri,</span>
<span class="line-modified">2828          const gchar   *group)</span>
2829 {
2830   BookmarkItem *item;
2831 
2832   g_return_if_fail (bookmark != NULL);
2833   g_return_if_fail (uri != NULL);
2834   g_return_if_fail (group != NULL &amp;&amp; group[0] != &#39;\0&#39;);
2835 
2836   item = g_bookmark_file_lookup_item (bookmark, uri);
2837   if (!item)
2838     {
2839       item = bookmark_item_new (uri);
2840       g_bookmark_file_add_item (bookmark, item, NULL);
2841     }
2842 
2843   if (!item-&gt;metadata)
2844     item-&gt;metadata = bookmark_metadata_new ();
2845 
2846   if (!g_bookmark_file_has_group (bookmark, uri, group, NULL))
2847     {
2848       item-&gt;metadata-&gt;groups = g_list_prepend (item-&gt;metadata-&gt;groups,
</pre>
<hr />
<pre>
2856  * g_bookmark_file_remove_group:
2857  * @bookmark: a #GBookmarkFile
2858  * @uri: a valid URI
2859  * @group: the group name to be removed
2860  * @error: return location for a #GError, or %NULL
2861  *
2862  * Removes @group from the list of groups to which the bookmark
2863  * for @uri belongs to.
2864  *
2865  * In the event the URI cannot be found, %FALSE is returned and
2866  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2867  * In the event no group was defined, %FALSE is returned and
2868  * @error is set to #G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
2869  *
2870  * Returns: %TRUE if @group was successfully removed.
2871  *
2872  * Since: 2.12
2873  */
2874 gboolean
2875 g_bookmark_file_remove_group (GBookmarkFile  *bookmark,
<span class="line-modified">2876             const gchar    *uri,</span>
<span class="line-modified">2877             const gchar    *group,</span>
<span class="line-modified">2878             GError        **error)</span>
2879 {
2880   BookmarkItem *item;
2881   GList *l;
2882 
2883   g_return_val_if_fail (bookmark != NULL, FALSE);
2884   g_return_val_if_fail (uri != NULL, FALSE);
2885 
2886   item = g_bookmark_file_lookup_item (bookmark, uri);
2887   if (!item)
2888     {
2889       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">2890        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2891        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2892        uri);</span>
2893       return FALSE;
2894     }
2895 
2896   if (!item-&gt;metadata)
2897     {
2898       g_set_error (error, G_BOOKMARK_FILE_ERROR,
2899                    G_BOOKMARK_FILE_ERROR_INVALID_VALUE,
2900                    _(&quot;No groups set in bookmark for URI &#39;%s&#39;&quot;),
2901                    uri);
2902       return FALSE;
2903     }
2904 
2905   for (l = item-&gt;metadata-&gt;groups; l != NULL; l = l-&gt;next)
2906     {
2907       if (strcmp (l-&gt;data, group) == 0)
2908         {
2909           item-&gt;metadata-&gt;groups = g_list_remove_link (item-&gt;metadata-&gt;groups, l);
2910           g_free (l-&gt;data);
<span class="line-modified">2911     g_list_free_1 (l);</span>
2912 
2913           item-&gt;modified = time (NULL);
2914 
2915           return TRUE;
2916         }
2917     }
2918 
2919   return FALSE;
2920 }
2921 
2922 /**
2923  * g_bookmark_file_set_groups:
2924  * @bookmark: a #GBookmarkFile
2925  * @uri: an item&#39;s URI
2926  * @groups: (nullable) (array length=length) (element-type utf8): an array of
2927  *    group names, or %NULL to remove all groups
2928  * @length: number of group name values in @groups
2929  *
2930  * Sets a list of group names for the item with URI @uri.  Each previously
2931  * set group name list is removed.
2932  *
2933  * If @uri cannot be found then an item for it is created.
2934  *
2935  * Since: 2.12
2936  */
2937 void
2938 g_bookmark_file_set_groups (GBookmarkFile  *bookmark,
<span class="line-modified">2939           const gchar    *uri,</span>
<span class="line-modified">2940           const gchar   **groups,</span>
<span class="line-modified">2941           gsize           length)</span>
2942 {
2943   BookmarkItem *item;
2944   gsize i;
2945 
2946   g_return_if_fail (bookmark != NULL);
2947   g_return_if_fail (uri != NULL);
2948   g_return_if_fail (groups != NULL);
2949 
2950   item = g_bookmark_file_lookup_item (bookmark, uri);
2951   if (!item)
2952     {
2953       item = bookmark_item_new (uri);
2954       g_bookmark_file_add_item (bookmark, item, NULL);
2955     }
2956 
2957   if (!item-&gt;metadata)
2958     item-&gt;metadata = bookmark_metadata_new ();
2959 
2960   g_list_free_full (item-&gt;metadata-&gt;groups, g_free);
2961   item-&gt;metadata-&gt;groups = NULL;
2962 
2963   if (groups)
2964     {
2965       for (i = 0; i &lt; length &amp;&amp; groups[i] != NULL; i++)
2966         item-&gt;metadata-&gt;groups = g_list_append (item-&gt;metadata-&gt;groups,
<span class="line-modified">2967                   g_strdup (groups[i]));</span>
2968     }
2969 
2970   item-&gt;modified = time (NULL);
2971 }
2972 
2973 /**
2974  * g_bookmark_file_get_groups:
2975  * @bookmark: a #GBookmarkFile
2976  * @uri: a valid URI
2977  * @length: (out) (optional): return location for the length of the returned string, or %NULL
2978  * @error: return location for a #GError, or %NULL
2979  *
2980  * Retrieves the list of group names of the bookmark for @uri.
2981  *
2982  * In the event the URI cannot be found, %NULL is returned and
2983  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2984  *
2985  * The returned array is %NULL terminated, so @length may optionally
2986  * be %NULL.
2987  *
2988  * Returns: (array length=length) (transfer full): a newly allocated %NULL-terminated array of group names.
2989  *   Use g_strfreev() to free it.
2990  *
2991  * Since: 2.12
2992  */
2993 gchar **
2994 g_bookmark_file_get_groups (GBookmarkFile  *bookmark,
<span class="line-modified">2995           const gchar    *uri,</span>
<span class="line-modified">2996           gsize          *length,</span>
<span class="line-modified">2997           GError        **error)</span>
2998 {
2999   BookmarkItem *item;
3000   GList *l;
3001   gsize len, i;
3002   gchar **retval;
3003 
3004   g_return_val_if_fail (bookmark != NULL, NULL);
3005   g_return_val_if_fail (uri != NULL, NULL);
3006 
3007   item = g_bookmark_file_lookup_item (bookmark, uri);
3008   if (!item)
3009     {
3010       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3011        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3012        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3013        uri);</span>
3014       return NULL;
3015     }
3016 
3017   if (!item-&gt;metadata)
3018     {
3019       if (length)
<span class="line-modified">3020   *length = 0;</span>
3021 
3022       return NULL;
3023     }
3024 
3025   len = g_list_length (item-&gt;metadata-&gt;groups);
3026   retval = g_new0 (gchar *, len + 1);
3027   for (l = g_list_last (item-&gt;metadata-&gt;groups), i = 0;
3028        l != NULL;
3029        l = l-&gt;prev)
3030     {
3031       gchar *group_name = (gchar *) l-&gt;data;
3032 
3033       g_warn_if_fail (group_name != NULL);
3034 
3035       retval[i++] = g_strdup (group_name);
3036     }
3037   retval[i] = NULL;
3038 
3039   if (length)
3040     *length = len;
</pre>
<hr />
<pre>
3060  * the bookmark has been registered by the application and the last
3061  * time the application registered this bookmark.
3062  *
3063  * If @name is %NULL, the name of the application will be the
3064  * same returned by g_get_application_name(); if @exec is %NULL, the
3065  * command line will be a composition of the program name as
3066  * returned by g_get_prgname() and the &quot;\%u&quot; modifier, which will be
3067  * expanded to the bookmark&#39;s URI.
3068  *
3069  * This function will automatically take care of updating the
3070  * registrations count and timestamping in case an application
3071  * with the same @name had already registered a bookmark for
3072  * @uri inside @bookmark.
3073  *
3074  * If no bookmark for @uri is found, one is created.
3075  *
3076  * Since: 2.12
3077  */
3078 void
3079 g_bookmark_file_add_application (GBookmarkFile *bookmark,
<span class="line-modified">3080          const gchar   *uri,</span>
<span class="line-modified">3081          const gchar   *name,</span>
<span class="line-modified">3082          const gchar   *exec)</span>
3083 {
3084   BookmarkItem *item;
3085   gchar *app_name, *app_exec;
3086 
3087   g_return_if_fail (bookmark != NULL);
3088   g_return_if_fail (uri != NULL);
3089 
3090   item = g_bookmark_file_lookup_item (bookmark, uri);
3091   if (!item)
3092     {
3093       item = bookmark_item_new (uri);
3094       g_bookmark_file_add_item (bookmark, item, NULL);
3095     }
3096 
3097   if (name &amp;&amp; name[0] != &#39;\0&#39;)
3098     app_name = g_strdup (name);
3099   else
3100     app_name = g_strdup (g_get_application_name ());
3101 
3102   if (exec &amp;&amp; exec[0] != &#39;\0&#39;)
</pre>
<hr />
<pre>
3120  * @bookmark: a #GBookmarkFile
3121  * @uri: a valid URI
3122  * @name: the name of the application
3123  * @error: return location for a #GError or %NULL
3124  *
3125  * Removes application registered with @name from the list of applications
3126  * that have registered a bookmark for @uri inside @bookmark.
3127  *
3128  * In the event the URI cannot be found, %FALSE is returned and
3129  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3130  * In the event that no application with name @app_name has registered
3131  * a bookmark for @uri,  %FALSE is returned and error is set to
3132  * #G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.
3133  *
3134  * Returns: %TRUE if the application was successfully removed.
3135  *
3136  * Since: 2.12
3137  */
3138 gboolean
3139 g_bookmark_file_remove_application (GBookmarkFile  *bookmark,
<span class="line-modified">3140             const gchar    *uri,</span>
<span class="line-modified">3141             const gchar    *name,</span>
<span class="line-modified">3142             GError        **error)</span>
3143 {
3144   GError *set_error;
3145   gboolean retval;
3146 
3147   g_return_val_if_fail (bookmark != NULL, FALSE);
3148   g_return_val_if_fail (uri != NULL, FALSE);
3149   g_return_val_if_fail (name != NULL, FALSE);
3150 
3151   set_error = NULL;
3152   retval = g_bookmark_file_set_app_info (bookmark, uri,
<span class="line-modified">3153              name,</span>
<span class="line-modified">3154              &quot;&quot;,</span>
<span class="line-modified">3155              0,</span>
<span class="line-modified">3156              (time_t) -1,</span>
<span class="line-modified">3157              &amp;set_error);</span>
3158   if (set_error)
3159     {
3160       g_propagate_error (error, set_error);
3161 
3162       return FALSE;
3163     }
3164 
3165   return retval;
3166 }
3167 
3168 /**
3169  * g_bookmark_file_has_application:
3170  * @bookmark: a #GBookmarkFile
3171  * @uri: a valid URI
3172  * @name: the name of the application
3173  * @error: return location for a #GError or %NULL
3174  *
3175  * Checks whether the bookmark for @uri inside @bookmark has been
3176  * registered by application @name.
3177  *
3178  * In the event the URI cannot be found, %FALSE is returned and
3179  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3180  *
3181  * Returns: %TRUE if the application @name was found
3182  *
3183  * Since: 2.12
3184  */
3185 gboolean
3186 g_bookmark_file_has_application (GBookmarkFile  *bookmark,
<span class="line-modified">3187          const gchar    *uri,</span>
<span class="line-modified">3188          const gchar    *name,</span>
<span class="line-modified">3189          GError        **error)</span>
3190 {
3191   BookmarkItem *item;
3192 
3193   g_return_val_if_fail (bookmark != NULL, FALSE);
3194   g_return_val_if_fail (uri != NULL, FALSE);
3195   g_return_val_if_fail (name != NULL, FALSE);
3196 
3197   item = g_bookmark_file_lookup_item (bookmark, uri);
3198   if (!item)
3199     {
3200       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3201        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3202        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3203        uri);</span>
3204       return FALSE;
3205     }
3206 
3207   return (NULL != bookmark_item_lookup_app_info (item, name));
3208 }
3209 
3210 /**
3211  * g_bookmark_file_set_app_info:
3212  * @bookmark: a #GBookmarkFile
3213  * @uri: a valid URI
3214  * @name: an application&#39;s name
3215  * @exec: an application&#39;s command line
3216  * @count: the number of registrations done for this application
3217  * @stamp: the time of the last registration for this application
3218  * @error: return location for a #GError or %NULL
3219  *
3220  * Sets the meta-data of application @name inside the list of
3221  * applications that have registered a bookmark for @uri inside
3222  * @bookmark.
3223  *
</pre>
<hr />
<pre>
3236  * by one, if is 0, the application with @name will be removed from
3237  * the list of registered applications.
3238  * @stamp is the Unix time of the last registration; if it is -1, the
3239  * current time will be used.
3240  *
3241  * If you try to remove an application by setting its registration count to
3242  * zero, and no bookmark for @uri is found, %FALSE is returned and
3243  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND; similarly,
3244  * in the event that no application @name has registered a bookmark
3245  * for @uri,  %FALSE is returned and error is set to
3246  * #G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.  Otherwise, if no bookmark
3247  * for @uri is found, one is created.
3248  *
3249  * Returns: %TRUE if the application&#39;s meta-data was successfully
3250  *   changed.
3251  *
3252  * Since: 2.12
3253  */
3254 gboolean
3255 g_bookmark_file_set_app_info (GBookmarkFile  *bookmark,
<span class="line-modified">3256             const gchar    *uri,</span>
<span class="line-modified">3257             const gchar    *name,</span>
<span class="line-modified">3258             const gchar    *exec,</span>
<span class="line-modified">3259             gint            count,</span>
<span class="line-modified">3260             time_t          stamp,</span>
<span class="line-modified">3261             GError        **error)</span>
3262 {
3263   BookmarkItem *item;
3264   BookmarkAppInfo *ai;
3265 
3266   g_return_val_if_fail (bookmark != NULL, FALSE);
3267   g_return_val_if_fail (uri != NULL, FALSE);
3268   g_return_val_if_fail (name != NULL, FALSE);
3269   g_return_val_if_fail (exec != NULL, FALSE);
3270 
3271   item = g_bookmark_file_lookup_item (bookmark, uri);
3272   if (!item)
3273     {
3274       if (count == 0)
3275         {
3276           g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3277            G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3278            _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3279            uri);</span>
<span class="line-modified">3280     return FALSE;</span>
<span class="line-modified">3281   }</span>
3282       else
3283         {
3284           item = bookmark_item_new (uri);
<span class="line-modified">3285     g_bookmark_file_add_item (bookmark, item, NULL);</span>
<span class="line-modified">3286   }</span>
3287     }
3288 
3289   if (!item-&gt;metadata)
3290     item-&gt;metadata = bookmark_metadata_new ();
3291 
3292   ai = bookmark_item_lookup_app_info (item, name);
3293   if (!ai)
3294     {
3295       if (count == 0)
3296         {
3297           g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3298            G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED,</span>
<span class="line-modified">3299            _(&quot;No application with name &#39;%s&#39; registered a bookmark for &#39;%s&#39;&quot;),</span>
<span class="line-modified">3300            name,</span>
<span class="line-modified">3301            uri);</span>
3302           return FALSE;
3303         }
3304       else
3305         {
3306           ai = bookmark_app_info_new (name);
3307 #ifdef GSTREAMER_LITE
3308           if (ai == NULL) {
3309             return FALSE;
3310           }
3311 #endif // GSTREAMER_LITE
3312 
3313           item-&gt;metadata-&gt;applications = g_list_prepend (item-&gt;metadata-&gt;applications, ai);
3314           g_hash_table_replace (item-&gt;metadata-&gt;apps_by_name, ai-&gt;name, ai);
3315         }
3316     }
3317 
3318   if (count == 0)
3319     {
3320       item-&gt;metadata-&gt;applications = g_list_remove (item-&gt;metadata-&gt;applications, ai);
3321       g_hash_table_remove (item-&gt;metadata-&gt;apps_by_name, ai-&gt;name);
</pre>
<hr />
<pre>
3332 
3333   if (stamp != (time_t) -1)
3334     ai-&gt;stamp = stamp;
3335   else
3336     ai-&gt;stamp = time (NULL);
3337 
3338   if (exec &amp;&amp; exec[0] != &#39;\0&#39;)
3339     {
3340       g_free (ai-&gt;exec);
3341       ai-&gt;exec = g_shell_quote (exec);
3342     }
3343 
3344   item-&gt;modified = time (NULL);
3345 
3346   return TRUE;
3347 }
3348 
3349 /* expands the application&#39;s command line */
3350 static gchar *
3351 expand_exec_line (const gchar *exec_fmt,
<span class="line-modified">3352       const gchar *uri)</span>
3353 {
3354   GString *exec;
3355   gchar ch;
3356 
3357   exec = g_string_sized_new (512);
3358   while ((ch = *exec_fmt++) != &#39;\0&#39;)
3359    {
3360      if (ch != &#39;%&#39;)
3361        {
3362          exec = g_string_append_c (exec, ch);
3363          continue;
3364        }
3365 
3366      ch = *exec_fmt++;
3367      switch (ch)
3368        {
3369        case &#39;\0&#39;:
<span class="line-modified">3370    goto out;</span>
3371        case &#39;U&#39;:
3372        case &#39;u&#39;:
3373          g_string_append (exec, uri);
3374          break;
3375        case &#39;F&#39;:
3376        case &#39;f&#39;:
3377          {
<span class="line-modified">3378      gchar *file = g_filename_from_uri (uri, NULL, NULL);</span>
3379            if (file)
3380              {
<span class="line-modified">3381          g_string_append (exec, file);</span>
<span class="line-modified">3382          g_free (file);</span>
3383              }
3384            else
3385              {
3386                g_string_free (exec, TRUE);
3387                return NULL;
3388              }
3389          }
3390          break;
3391        case &#39;%&#39;:
3392        default:
3393          exec = g_string_append_c (exec, ch);
3394          break;
3395        }
3396    }
3397 
3398  out:
3399   return g_string_free (exec, FALSE);
3400 }
3401 
3402 /**
</pre>
<hr />
<pre>
3412  * Gets the registration information of @app_name for the bookmark for
3413  * @uri.  See g_bookmark_file_set_app_info() for more information about
3414  * the returned data.
3415  *
3416  * The string returned in @app_exec must be freed.
3417  *
3418  * In the event the URI cannot be found, %FALSE is returned and
3419  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
3420  * event that no application with name @app_name has registered a bookmark
3421  * for @uri,  %FALSE is returned and error is set to
3422  * #G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. In the event that unquoting
3423  * the command line fails, an error of the #G_SHELL_ERROR domain is
3424  * set and %FALSE is returned.
3425  *
3426  * Returns: %TRUE on success.
3427  *
3428  * Since: 2.12
3429  */
3430 gboolean
3431 g_bookmark_file_get_app_info (GBookmarkFile  *bookmark,
<span class="line-modified">3432             const gchar    *uri,</span>
<span class="line-modified">3433             const gchar    *name,</span>
<span class="line-modified">3434             gchar         **exec,</span>
<span class="line-modified">3435             guint          *count,</span>
<span class="line-modified">3436             time_t         *stamp,</span>
<span class="line-modified">3437             GError        **error)</span>
3438 {
3439   BookmarkItem *item;
3440   BookmarkAppInfo *ai;
3441 
3442   g_return_val_if_fail (bookmark != NULL, FALSE);
3443   g_return_val_if_fail (uri != NULL, FALSE);
3444   g_return_val_if_fail (name != NULL, FALSE);
3445 
3446   item = g_bookmark_file_lookup_item (bookmark, uri);
3447   if (!item)
3448     {
3449       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3450        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3451        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3452        uri);</span>
3453       return FALSE;
3454     }
3455 
3456   ai = bookmark_item_lookup_app_info (item, name);
3457   if (!ai)
3458     {
3459       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3460        G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED,</span>
<span class="line-modified">3461        _(&quot;No application with name &#39;%s&#39; registered a bookmark for &#39;%s&#39;&quot;),</span>
<span class="line-modified">3462        name,</span>
<span class="line-modified">3463        uri);</span>
3464       return FALSE;
3465     }
3466 
3467   if (exec)
3468     {
3469       GError *unquote_error = NULL;
3470       gchar *command_line;
3471 
3472       command_line = g_shell_unquote (ai-&gt;exec, &amp;unquote_error);
3473       if (unquote_error)
3474         {
3475           g_propagate_error (error, unquote_error);
3476           return FALSE;
3477         }
3478 
3479       *exec = expand_exec_line (command_line, uri);
3480       if (!*exec)
3481         {
3482           g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3483            G_BOOKMARK_FILE_ERROR_INVALID_URI,</span>
<span class="line-modified">3484            _(&quot;Failed to expand exec line &#39;%s&#39; with URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3485          ai-&gt;exec, uri);</span>
3486           g_free (command_line);
3487 
3488           return FALSE;
3489         }
3490       else
3491         g_free (command_line);
3492     }
3493 
3494   if (count)
3495     *count = ai-&gt;count;
3496 
3497   if (stamp)
3498     *stamp = ai-&gt;stamp;
3499 
3500   return TRUE;
3501 }
3502 
3503 /**
3504  * g_bookmark_file_get_applications:
3505  * @bookmark: a #GBookmarkFile
3506  * @uri: a valid URI
3507  * @length: (out) (optional): return location of the length of the returned list, or %NULL
3508  * @error: return location for a #GError, or %NULL
3509  *
3510  * Retrieves the names of the applications that have registered the
3511  * bookmark for @uri.
3512  *
3513  * In the event the URI cannot be found, %NULL is returned and
3514  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3515  *
3516  * Returns: (array length=length) (transfer full): a newly allocated %NULL-terminated array of strings.
3517  *   Use g_strfreev() to free it.
3518  *
3519  * Since: 2.12
3520  */
3521 gchar **
3522 g_bookmark_file_get_applications (GBookmarkFile  *bookmark,
<span class="line-modified">3523           const gchar    *uri,</span>
<span class="line-modified">3524           gsize          *length,</span>
<span class="line-modified">3525           GError        **error)</span>
3526 {
3527   BookmarkItem *item;
3528   GList *l;
3529   gchar **apps;
3530   gsize i, n_apps;
3531 
3532   g_return_val_if_fail (bookmark != NULL, NULL);
3533   g_return_val_if_fail (uri != NULL, NULL);
3534 
3535   item = g_bookmark_file_lookup_item (bookmark, uri);
3536   if (!item)
3537     {
3538       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3539        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3540        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3541        uri);</span>
3542       return NULL;
3543     }
3544 
3545   if (!item-&gt;metadata)
3546     {
3547       if (length)
<span class="line-modified">3548   *length = 0;</span>
3549 
3550       return NULL;
3551     }
3552 
3553   n_apps = g_list_length (item-&gt;metadata-&gt;applications);
3554   apps = g_new0 (gchar *, n_apps + 1);
3555 
3556   for (l = g_list_last (item-&gt;metadata-&gt;applications), i = 0;
3557        l != NULL;
3558        l = l-&gt;prev)
3559     {
3560       BookmarkAppInfo *ai;
3561 
3562       ai = (BookmarkAppInfo *) l-&gt;data;
3563 
3564       g_warn_if_fail (ai != NULL);
3565       g_warn_if_fail (ai-&gt;name != NULL);
3566 
3567       apps[i++] = g_strdup (ai-&gt;name);
3568     }
</pre>
<hr />
<pre>
3595 /**
3596  * g_bookmark_file_move_item:
3597  * @bookmark: a #GBookmarkFile
3598  * @old_uri: a valid URI
3599  * @new_uri: (nullable): a valid URI, or %NULL
3600  * @error: return location for a #GError or %NULL
3601  *
3602  * Changes the URI of a bookmark item from @old_uri to @new_uri.  Any
3603  * existing bookmark for @new_uri will be overwritten.  If @new_uri is
3604  * %NULL, then the bookmark is removed.
3605  *
3606  * In the event the URI cannot be found, %FALSE is returned and
3607  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3608  *
3609  * Returns: %TRUE if the URI was successfully changed
3610  *
3611  * Since: 2.12
3612  */
3613 gboolean
3614 g_bookmark_file_move_item (GBookmarkFile  *bookmark,
<span class="line-modified">3615          const gchar    *old_uri,</span>
<span class="line-modified">3616          const gchar    *new_uri,</span>
<span class="line-modified">3617          GError        **error)</span>
3618 {
3619   BookmarkItem *item;
3620 
3621   g_return_val_if_fail (bookmark != NULL, FALSE);
3622   g_return_val_if_fail (old_uri != NULL, FALSE);
3623 
3624   item = g_bookmark_file_lookup_item (bookmark, old_uri);
3625   if (!item)
3626     {
3627       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3628        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3629        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3630        old_uri);</span>
3631       return FALSE;
3632     }
3633 
3634   if (new_uri &amp;&amp; new_uri[0] != &#39;\0&#39;)
3635     {
3636       if (g_strcmp0 (old_uri, new_uri) == 0)
3637         return TRUE;
3638 
3639       if (g_bookmark_file_has_item (bookmark, new_uri))
3640         {
3641           if (!g_bookmark_file_remove_item (bookmark, new_uri, error))
3642             return FALSE;
3643         }
3644 
3645       g_hash_table_steal (bookmark-&gt;items_by_uri, item-&gt;uri);
3646 
3647       g_free (item-&gt;uri);
3648       item-&gt;uri = g_strdup (new_uri);
3649       item-&gt;modified = time (NULL);
3650 
</pre>
<hr />
<pre>
3661     }
3662 }
3663 
3664 /**
3665  * g_bookmark_file_set_icon:
3666  * @bookmark: a #GBookmarkFile
3667  * @uri: a valid URI
3668  * @href: (nullable): the URI of the icon for the bookmark, or %NULL
3669  * @mime_type: the MIME type of the icon for the bookmark
3670  *
3671  * Sets the icon for the bookmark for @uri. If @href is %NULL, unsets
3672  * the currently set icon. @href can either be a full URL for the icon
3673  * file or the icon name following the Icon Naming specification.
3674  *
3675  * If no bookmark for @uri is found one is created.
3676  *
3677  * Since: 2.12
3678  */
3679 void
3680 g_bookmark_file_set_icon (GBookmarkFile *bookmark,
<span class="line-modified">3681         const gchar   *uri,</span>
<span class="line-modified">3682         const gchar   *href,</span>
<span class="line-modified">3683         const gchar   *mime_type)</span>
3684 {
3685   BookmarkItem *item;
3686 
3687   g_return_if_fail (bookmark != NULL);
3688   g_return_if_fail (uri != NULL);
3689 
3690   item = g_bookmark_file_lookup_item (bookmark, uri);
3691   if (!item)
3692     {
3693       item = bookmark_item_new (uri);
3694       g_bookmark_file_add_item (bookmark, item, NULL);
3695     }
3696 
3697   if (!item-&gt;metadata)
3698     item-&gt;metadata = bookmark_metadata_new ();
3699 
3700   g_free (item-&gt;metadata-&gt;icon_href);
3701   g_free (item-&gt;metadata-&gt;icon_mime);
3702 
3703   item-&gt;metadata-&gt;icon_href = g_strdup (href);
</pre>
<hr />
<pre>
3713 /**
3714  * g_bookmark_file_get_icon:
3715  * @bookmark: a #GBookmarkFile
3716  * @uri: a valid URI
3717  * @href: (out) (optional): return location for the icon&#39;s location or %NULL
3718  * @mime_type: (out) (optional): return location for the icon&#39;s MIME type or %NULL
3719  * @error: return location for a #GError or %NULL
3720  *
3721  * Gets the icon of the bookmark for @uri.
3722  *
3723  * In the event the URI cannot be found, %FALSE is returned and
3724  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3725  *
3726  * Returns: %TRUE if the icon for the bookmark for the URI was found.
3727  *   You should free the returned strings.
3728  *
3729  * Since: 2.12
3730  */
3731 gboolean
3732 g_bookmark_file_get_icon (GBookmarkFile  *bookmark,
<span class="line-modified">3733         const gchar    *uri,</span>
<span class="line-modified">3734         gchar         **href,</span>
<span class="line-modified">3735         gchar         **mime_type,</span>
<span class="line-modified">3736         GError        **error)</span>
3737 {
3738   BookmarkItem *item;
3739 
3740   g_return_val_if_fail (bookmark != NULL, FALSE);
3741   g_return_val_if_fail (uri != NULL, FALSE);
3742 
3743   item = g_bookmark_file_lookup_item (bookmark, uri);
3744   if (!item)
3745     {
3746       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<span class="line-modified">3747        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3748        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3749        uri);</span>
3750       return FALSE;
3751     }
3752 
3753   if ((!item-&gt;metadata) || (!item-&gt;metadata-&gt;icon_href))
3754     return FALSE;
3755 
3756   if (href)
3757     *href = g_strdup (item-&gt;metadata-&gt;icon_href);
3758 
3759   if (mime_type)
3760     *mime_type = g_strdup (item-&gt;metadata-&gt;icon_mime);
3761 
3762   return TRUE;
3763 }
</pre>
</td>
</tr>
</table>
<center><a href="gbitlock.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gbookmarkfile.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>