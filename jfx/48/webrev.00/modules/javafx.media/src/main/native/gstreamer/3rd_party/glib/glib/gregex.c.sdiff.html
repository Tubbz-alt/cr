<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gregex.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="grefcount.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gregex.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gregex.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1449   compile_options = pcre_compile_options &amp; G_REGEX_COMPILE_PCRE_MASK;
1450 
1451   /* Don&#39;t leak PCRE_NEWLINE_ANY, which is part of PCRE_NEWLINE_ANYCRLF */
1452   if ((pcre_compile_options &amp; PCRE_NEWLINE_ANYCRLF) != PCRE_NEWLINE_ANYCRLF)
1453     compile_options &amp;= ~PCRE_NEWLINE_ANY;
1454 
1455   compile_options |= nonpcre_compile_options;
1456 
1457   if (!(compile_options &amp; G_REGEX_DUPNAMES))
1458     {
1459       gboolean jchanged = FALSE;
1460       pcre_fullinfo (re, NULL, PCRE_INFO_JCHANGED, &amp;jchanged);
1461       if (jchanged)
1462         compile_options |= G_REGEX_DUPNAMES;
1463     }
1464 
1465   if (compile_options_out != 0)
1466     *compile_options_out = compile_options;
1467 
1468   return re;
<span class="line-modified">1469         }</span>
1470 
1471 /**
1472  * g_regex_get_pattern:
1473  * @regex: a #GRegex structure
1474  *
1475  * Gets the pattern string associated with @regex, i.e. a copy of
1476  * the string passed to g_regex_new().
1477  *
1478  * Returns: the pattern of @regex
1479  *
1480  * Since: 2.14
1481  */
1482 const gchar *
1483 g_regex_get_pattern (const GRegex *regex)
1484 {
1485   g_return_val_if_fail (regex != NULL, NULL);
1486 
1487   return regex-&gt;pattern;
1488 }
1489 
</pre>
<hr />
<pre>
2037  * @match_options: match options, or 0
2038  *
2039  * Breaks the string on the pattern, and returns an array of
2040  * the tokens. If the pattern contains capturing parentheses,
2041  * then the text for each of the substrings will also be returned.
2042  * If the pattern does not match anywhere in the string, then the
2043  * whole string is returned as the first token.
2044  *
2045  * This function is equivalent to g_regex_split() but it does
2046  * not require to compile the pattern with g_regex_new(), avoiding
2047  * some lines of code when you need just to do a split without
2048  * extracting substrings, capture counts, and so on.
2049  *
2050  * If this function is to be called on the same @pattern more than
2051  * once, it&#39;s more efficient to compile the pattern once with
2052  * g_regex_new() and then use g_regex_split().
2053  *
2054  * As a special case, the result of splitting the empty string &quot;&quot;
2055  * is an empty vector, not a vector containing a single string.
2056  * The reason for this special case is that being able to represent
<span class="line-modified">2057  * a empty vector is typically more useful than consistent handling</span>
2058  * of empty elements. If you do need to represent empty elements,
2059  * you&#39;ll need to check for the empty string before calling this
2060  * function.
2061  *
2062  * A pattern that can match empty strings splits @string into
2063  * separate characters wherever it matches the empty string between
2064  * characters. For example splitting &quot;ab c&quot; using as a separator
2065  * &quot;\s*&quot;, you will get &quot;a&quot;, &quot;b&quot; and &quot;c&quot;.
2066  *
2067  * Returns: (transfer full): a %NULL-terminated array of strings. Free
2068  * it using g_strfreev()
2069  *
2070  * Since: 2.14
2071  **/
2072 gchar **
2073 g_regex_split_simple (const gchar        *pattern,
2074                       const gchar        *string,
2075                       GRegexCompileFlags  compile_options,
2076                       GRegexMatchFlags    match_options)
2077 {
</pre>
<hr />
<pre>
2084 
2085   result = g_regex_split_full (regex, string, -1, 0, match_options, 0, NULL);
2086   g_regex_unref (regex);
2087   return result;
2088 }
2089 
2090 /**
2091  * g_regex_split:
2092  * @regex: a #GRegex structure
2093  * @string: the string to split with the pattern
2094  * @match_options: match time option flags
2095  *
2096  * Breaks the string on the pattern, and returns an array of the tokens.
2097  * If the pattern contains capturing parentheses, then the text for each
2098  * of the substrings will also be returned. If the pattern does not match
2099  * anywhere in the string, then the whole string is returned as the first
2100  * token.
2101  *
2102  * As a special case, the result of splitting the empty string &quot;&quot; is an
2103  * empty vector, not a vector containing a single string. The reason for
<span class="line-modified">2104  * this special case is that being able to represent a empty vector is</span>
2105  * typically more useful than consistent handling of empty elements. If
2106  * you do need to represent empty elements, you&#39;ll need to check for the
2107  * empty string before calling this function.
2108  *
2109  * A pattern that can match empty strings splits @string into separate
2110  * characters wherever it matches the empty string between characters.
2111  * For example splitting &quot;ab c&quot; using as a separator &quot;\s*&quot;, you will get
2112  * &quot;a&quot;, &quot;b&quot; and &quot;c&quot;.
2113  *
2114  * Returns: (transfer full): a %NULL-terminated gchar ** array. Free
2115  * it using g_strfreev()
2116  *
2117  * Since: 2.14
2118  **/
2119 gchar **
2120 g_regex_split (const GRegex     *regex,
2121                const gchar      *string,
2122                GRegexMatchFlags  match_options)
2123 {
2124   return g_regex_split_full (regex, string, -1, 0,
</pre>
<hr />
<pre>
2127 
2128 /**
2129  * g_regex_split_full:
2130  * @regex: a #GRegex structure
2131  * @string: (array length=string_len): the string to split with the pattern
2132  * @string_len: the length of @string, in bytes, or -1 if @string is nul-terminated
2133  * @start_position: starting index of the string to match, in bytes
2134  * @match_options: match time option flags
2135  * @max_tokens: the maximum number of tokens to split @string into.
2136  *   If this is less than 1, the string is split completely
2137  * @error: return location for a #GError
2138  *
2139  * Breaks the string on the pattern, and returns an array of the tokens.
2140  * If the pattern contains capturing parentheses, then the text for each
2141  * of the substrings will also be returned. If the pattern does not match
2142  * anywhere in the string, then the whole string is returned as the first
2143  * token.
2144  *
2145  * As a special case, the result of splitting the empty string &quot;&quot; is an
2146  * empty vector, not a vector containing a single string. The reason for
<span class="line-modified">2147  * this special case is that being able to represent a empty vector is</span>
2148  * typically more useful than consistent handling of empty elements. If
2149  * you do need to represent empty elements, you&#39;ll need to check for the
2150  * empty string before calling this function.
2151  *
2152  * A pattern that can match empty strings splits @string into separate
2153  * characters wherever it matches the empty string between characters.
2154  * For example splitting &quot;ab c&quot; using as a separator &quot;\s*&quot;, you will get
2155  * &quot;a&quot;, &quot;b&quot; and &quot;c&quot;.
2156  *
2157  * Setting @start_position differs from just passing over a shortened
2158  * string and setting #G_REGEX_MATCH_NOTBOL in the case of a pattern
2159  * that begins with any kind of lookbehind assertion, such as &quot;\b&quot;.
2160  *
2161  * Returns: (transfer full): a %NULL-terminated gchar ** array. Free
2162  * it using g_strfreev()
2163  *
2164  * Since: 2.14
2165  **/
2166 gchar **
2167 g_regex_split_full (const GRegex      *regex,
</pre>
<hr />
<pre>
2520                   error_detail = _(&quot;illegal symbolic reference&quot;);
2521                   p = r;
2522                   goto error;
2523                 }
2524               r++;
2525             }
2526           while (r != p);
2527           data-&gt;text = g_strndup (q, p - q);
2528           data-&gt;type = REPL_TYPE_SYMBOLIC_REFERENCE;
2529         }
2530       p++;
2531       break;
2532     case &#39;0&#39;:
2533       /* if \0 is followed by a number is an octal number representing a
2534        * character, else it is a numeric reference. */
2535       if (g_ascii_digit_value (*g_utf8_next_char (p)) &gt;= 0)
2536         {
2537           base = 8;
2538           p = g_utf8_next_char (p);
2539         }

2540     case &#39;1&#39;:
2541     case &#39;2&#39;:
2542     case &#39;3&#39;:
2543     case &#39;4&#39;:
2544     case &#39;5&#39;:
2545     case &#39;6&#39;:
2546     case &#39;7&#39;:
2547     case &#39;8&#39;:
2548     case &#39;9&#39;:
2549       x = 0;
2550       d = 0;
2551       for (i = 0; i &lt; 3; i++)
2552         {
2553           h = g_ascii_digit_value (*p);
2554           if (h &lt; 0)
2555             break;
2556           if (h &gt; 7)
2557             {
2558               if (base == 8)
2559                 break;
</pre>
<hr />
<pre>
2577           data-&gt;type = REPL_TYPE_NUMERIC_REFERENCE;
2578           data-&gt;num = d;
2579         }
2580       break;
2581     case 0:
2582       error_detail = _(&quot;stray final &#39;\\&#39;&quot;);
2583       goto error;
2584       break;
2585     default:
2586       error_detail = _(&quot;unknown escape sequence&quot;);
2587       goto error;
2588     }
2589 
2590   return p;
2591 
2592  error:
2593   /* G_GSSIZE_FORMAT doesn&#39;t work with gettext, so we use %lu */
2594   tmp_error = g_error_new (G_REGEX_ERROR,
2595                            G_REGEX_ERROR_REPLACE,
2596                            _(&quot;Error while parsing replacement &quot;
<span class="line-modified">2597                              &quot;text \&quot;%s\&quot; at char %lu: %s&quot;),</span>
2598                            replacement,
2599                            (gulong)(p - replacement),
2600                            error_detail);
2601   g_propagate_error (error, tmp_error);
2602 
2603   return NULL;
2604 }
2605 
2606 static GList *
2607 split_replacement (const gchar  *replacement,
2608                    GError      **error)
2609 {
2610   GList *list = NULL;
2611   InterpolationData *data;
2612   const gchar *p, *start;
2613 
2614   start = p = replacement;
2615   while (*p)
2616     {
2617       if (*p == &#39;\\&#39;)
</pre>
</td>
<td>
<hr />
<pre>
1449   compile_options = pcre_compile_options &amp; G_REGEX_COMPILE_PCRE_MASK;
1450 
1451   /* Don&#39;t leak PCRE_NEWLINE_ANY, which is part of PCRE_NEWLINE_ANYCRLF */
1452   if ((pcre_compile_options &amp; PCRE_NEWLINE_ANYCRLF) != PCRE_NEWLINE_ANYCRLF)
1453     compile_options &amp;= ~PCRE_NEWLINE_ANY;
1454 
1455   compile_options |= nonpcre_compile_options;
1456 
1457   if (!(compile_options &amp; G_REGEX_DUPNAMES))
1458     {
1459       gboolean jchanged = FALSE;
1460       pcre_fullinfo (re, NULL, PCRE_INFO_JCHANGED, &amp;jchanged);
1461       if (jchanged)
1462         compile_options |= G_REGEX_DUPNAMES;
1463     }
1464 
1465   if (compile_options_out != 0)
1466     *compile_options_out = compile_options;
1467 
1468   return re;
<span class="line-modified">1469 }</span>
1470 
1471 /**
1472  * g_regex_get_pattern:
1473  * @regex: a #GRegex structure
1474  *
1475  * Gets the pattern string associated with @regex, i.e. a copy of
1476  * the string passed to g_regex_new().
1477  *
1478  * Returns: the pattern of @regex
1479  *
1480  * Since: 2.14
1481  */
1482 const gchar *
1483 g_regex_get_pattern (const GRegex *regex)
1484 {
1485   g_return_val_if_fail (regex != NULL, NULL);
1486 
1487   return regex-&gt;pattern;
1488 }
1489 
</pre>
<hr />
<pre>
2037  * @match_options: match options, or 0
2038  *
2039  * Breaks the string on the pattern, and returns an array of
2040  * the tokens. If the pattern contains capturing parentheses,
2041  * then the text for each of the substrings will also be returned.
2042  * If the pattern does not match anywhere in the string, then the
2043  * whole string is returned as the first token.
2044  *
2045  * This function is equivalent to g_regex_split() but it does
2046  * not require to compile the pattern with g_regex_new(), avoiding
2047  * some lines of code when you need just to do a split without
2048  * extracting substrings, capture counts, and so on.
2049  *
2050  * If this function is to be called on the same @pattern more than
2051  * once, it&#39;s more efficient to compile the pattern once with
2052  * g_regex_new() and then use g_regex_split().
2053  *
2054  * As a special case, the result of splitting the empty string &quot;&quot;
2055  * is an empty vector, not a vector containing a single string.
2056  * The reason for this special case is that being able to represent
<span class="line-modified">2057  * an empty vector is typically more useful than consistent handling</span>
2058  * of empty elements. If you do need to represent empty elements,
2059  * you&#39;ll need to check for the empty string before calling this
2060  * function.
2061  *
2062  * A pattern that can match empty strings splits @string into
2063  * separate characters wherever it matches the empty string between
2064  * characters. For example splitting &quot;ab c&quot; using as a separator
2065  * &quot;\s*&quot;, you will get &quot;a&quot;, &quot;b&quot; and &quot;c&quot;.
2066  *
2067  * Returns: (transfer full): a %NULL-terminated array of strings. Free
2068  * it using g_strfreev()
2069  *
2070  * Since: 2.14
2071  **/
2072 gchar **
2073 g_regex_split_simple (const gchar        *pattern,
2074                       const gchar        *string,
2075                       GRegexCompileFlags  compile_options,
2076                       GRegexMatchFlags    match_options)
2077 {
</pre>
<hr />
<pre>
2084 
2085   result = g_regex_split_full (regex, string, -1, 0, match_options, 0, NULL);
2086   g_regex_unref (regex);
2087   return result;
2088 }
2089 
2090 /**
2091  * g_regex_split:
2092  * @regex: a #GRegex structure
2093  * @string: the string to split with the pattern
2094  * @match_options: match time option flags
2095  *
2096  * Breaks the string on the pattern, and returns an array of the tokens.
2097  * If the pattern contains capturing parentheses, then the text for each
2098  * of the substrings will also be returned. If the pattern does not match
2099  * anywhere in the string, then the whole string is returned as the first
2100  * token.
2101  *
2102  * As a special case, the result of splitting the empty string &quot;&quot; is an
2103  * empty vector, not a vector containing a single string. The reason for
<span class="line-modified">2104  * this special case is that being able to represent an empty vector is</span>
2105  * typically more useful than consistent handling of empty elements. If
2106  * you do need to represent empty elements, you&#39;ll need to check for the
2107  * empty string before calling this function.
2108  *
2109  * A pattern that can match empty strings splits @string into separate
2110  * characters wherever it matches the empty string between characters.
2111  * For example splitting &quot;ab c&quot; using as a separator &quot;\s*&quot;, you will get
2112  * &quot;a&quot;, &quot;b&quot; and &quot;c&quot;.
2113  *
2114  * Returns: (transfer full): a %NULL-terminated gchar ** array. Free
2115  * it using g_strfreev()
2116  *
2117  * Since: 2.14
2118  **/
2119 gchar **
2120 g_regex_split (const GRegex     *regex,
2121                const gchar      *string,
2122                GRegexMatchFlags  match_options)
2123 {
2124   return g_regex_split_full (regex, string, -1, 0,
</pre>
<hr />
<pre>
2127 
2128 /**
2129  * g_regex_split_full:
2130  * @regex: a #GRegex structure
2131  * @string: (array length=string_len): the string to split with the pattern
2132  * @string_len: the length of @string, in bytes, or -1 if @string is nul-terminated
2133  * @start_position: starting index of the string to match, in bytes
2134  * @match_options: match time option flags
2135  * @max_tokens: the maximum number of tokens to split @string into.
2136  *   If this is less than 1, the string is split completely
2137  * @error: return location for a #GError
2138  *
2139  * Breaks the string on the pattern, and returns an array of the tokens.
2140  * If the pattern contains capturing parentheses, then the text for each
2141  * of the substrings will also be returned. If the pattern does not match
2142  * anywhere in the string, then the whole string is returned as the first
2143  * token.
2144  *
2145  * As a special case, the result of splitting the empty string &quot;&quot; is an
2146  * empty vector, not a vector containing a single string. The reason for
<span class="line-modified">2147  * this special case is that being able to represent an empty vector is</span>
2148  * typically more useful than consistent handling of empty elements. If
2149  * you do need to represent empty elements, you&#39;ll need to check for the
2150  * empty string before calling this function.
2151  *
2152  * A pattern that can match empty strings splits @string into separate
2153  * characters wherever it matches the empty string between characters.
2154  * For example splitting &quot;ab c&quot; using as a separator &quot;\s*&quot;, you will get
2155  * &quot;a&quot;, &quot;b&quot; and &quot;c&quot;.
2156  *
2157  * Setting @start_position differs from just passing over a shortened
2158  * string and setting #G_REGEX_MATCH_NOTBOL in the case of a pattern
2159  * that begins with any kind of lookbehind assertion, such as &quot;\b&quot;.
2160  *
2161  * Returns: (transfer full): a %NULL-terminated gchar ** array. Free
2162  * it using g_strfreev()
2163  *
2164  * Since: 2.14
2165  **/
2166 gchar **
2167 g_regex_split_full (const GRegex      *regex,
</pre>
<hr />
<pre>
2520                   error_detail = _(&quot;illegal symbolic reference&quot;);
2521                   p = r;
2522                   goto error;
2523                 }
2524               r++;
2525             }
2526           while (r != p);
2527           data-&gt;text = g_strndup (q, p - q);
2528           data-&gt;type = REPL_TYPE_SYMBOLIC_REFERENCE;
2529         }
2530       p++;
2531       break;
2532     case &#39;0&#39;:
2533       /* if \0 is followed by a number is an octal number representing a
2534        * character, else it is a numeric reference. */
2535       if (g_ascii_digit_value (*g_utf8_next_char (p)) &gt;= 0)
2536         {
2537           base = 8;
2538           p = g_utf8_next_char (p);
2539         }
<span class="line-added">2540       G_GNUC_FALLTHROUGH;</span>
2541     case &#39;1&#39;:
2542     case &#39;2&#39;:
2543     case &#39;3&#39;:
2544     case &#39;4&#39;:
2545     case &#39;5&#39;:
2546     case &#39;6&#39;:
2547     case &#39;7&#39;:
2548     case &#39;8&#39;:
2549     case &#39;9&#39;:
2550       x = 0;
2551       d = 0;
2552       for (i = 0; i &lt; 3; i++)
2553         {
2554           h = g_ascii_digit_value (*p);
2555           if (h &lt; 0)
2556             break;
2557           if (h &gt; 7)
2558             {
2559               if (base == 8)
2560                 break;
</pre>
<hr />
<pre>
2578           data-&gt;type = REPL_TYPE_NUMERIC_REFERENCE;
2579           data-&gt;num = d;
2580         }
2581       break;
2582     case 0:
2583       error_detail = _(&quot;stray final &#39;\\&#39;&quot;);
2584       goto error;
2585       break;
2586     default:
2587       error_detail = _(&quot;unknown escape sequence&quot;);
2588       goto error;
2589     }
2590 
2591   return p;
2592 
2593  error:
2594   /* G_GSSIZE_FORMAT doesn&#39;t work with gettext, so we use %lu */
2595   tmp_error = g_error_new (G_REGEX_ERROR,
2596                            G_REGEX_ERROR_REPLACE,
2597                            _(&quot;Error while parsing replacement &quot;
<span class="line-modified">2598                              &quot;text &#39;%s&#39; at char %lu: %s&quot;),</span>
2599                            replacement,
2600                            (gulong)(p - replacement),
2601                            error_detail);
2602   g_propagate_error (error, tmp_error);
2603 
2604   return NULL;
2605 }
2606 
2607 static GList *
2608 split_replacement (const gchar  *replacement,
2609                    GError      **error)
2610 {
2611   GList *list = NULL;
2612   InterpolationData *data;
2613   const gchar *p, *start;
2614 
2615   start = p = replacement;
2616   while (*p)
2617     {
2618       if (*p == &#39;\\&#39;)
</pre>
</td>
</tr>
</table>
<center><a href="grefcount.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gregex.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>