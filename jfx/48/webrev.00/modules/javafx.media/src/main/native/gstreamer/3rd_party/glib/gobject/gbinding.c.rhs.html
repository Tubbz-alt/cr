<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gbinding.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* gbinding.c: Binding for object properties
   2  *
   3  * Copyright (C) 2010  Intel Corp.
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General
  16  * Public License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  *
  18  * Author: Emmanuele Bassi &lt;ebassi@linux.intel.com&gt;
  19  */
  20 
  21 /**
  22  * SECTION:gbinding
  23  * @Title: GBinding
  24  * @Short_Description: Bind two object properties
  25  *
  26  * #GBinding is the representation of a binding between a property on a
  27  * #GObject instance (or source) and another property on another #GObject
  28  * instance (or target). Whenever the source property changes, the same
  29  * value is applied to the target property; for instance, the following
  30  * binding:
  31  *
  32  * |[&lt;!-- language=&quot;C&quot; --&gt;
  33  *   g_object_bind_property (object1, &quot;property-a&quot;,
  34  *                           object2, &quot;property-b&quot;,
  35  *                           G_BINDING_DEFAULT);
  36  * ]|
  37  *
  38  * will cause the property named &quot;property-b&quot; of @object2 to be updated
  39  * every time g_object_set() or the specific accessor changes the value of
  40  * the property &quot;property-a&quot; of @object1.
  41  *
  42  * It is possible to create a bidirectional binding between two properties
  43  * of two #GObject instances, so that if either property changes, the
  44  * other is updated as well, for instance:
  45  *
  46  * |[&lt;!-- language=&quot;C&quot; --&gt;
  47  *   g_object_bind_property (object1, &quot;property-a&quot;,
  48  *                           object2, &quot;property-b&quot;,
  49  *                           G_BINDING_BIDIRECTIONAL);
  50  * ]|
  51  *
  52  * will keep the two properties in sync.
  53  *
  54  * It is also possible to set a custom transformation function (in both
  55  * directions, in case of a bidirectional binding) to apply a custom
  56  * transformation from the source value to the target value before
  57  * applying it; for instance, the following binding:
  58  *
  59  * |[&lt;!-- language=&quot;C&quot; --&gt;
  60  *   g_object_bind_property_full (adjustment1, &quot;value&quot;,
  61  *                                adjustment2, &quot;value&quot;,
  62  *                                G_BINDING_BIDIRECTIONAL,
  63  *                                celsius_to_fahrenheit,
  64  *                                fahrenheit_to_celsius,
  65  *                                NULL, NULL);
  66  * ]|
  67  *
  68  * will keep the &quot;value&quot; property of the two adjustments in sync; the
  69  * @celsius_to_fahrenheit function will be called whenever the &quot;value&quot;
  70  * property of @adjustment1 changes and will transform the current value
  71  * of the property before applying it to the &quot;value&quot; property of @adjustment2.
  72  *
  73  * Vice versa, the @fahrenheit_to_celsius function will be called whenever
  74  * the &quot;value&quot; property of @adjustment2 changes, and will transform the
  75  * current value of the property before applying it to the &quot;value&quot; property
  76  * of @adjustment1.
  77  *
  78  * Note that #GBinding does not resolve cycles by itself; a cycle like
  79  *
  80  * |[
  81  *   object1:propertyA -&gt; object2:propertyB
  82  *   object2:propertyB -&gt; object3:propertyC
  83  *   object3:propertyC -&gt; object1:propertyA
  84  * ]|
  85  *
  86  * might lead to an infinite loop. The loop, in this particular case,
  87  * can be avoided if the objects emit the #GObject::notify signal only
  88  * if the value has effectively been changed. A binding is implemented
  89  * using the #GObject::notify signal, so it is susceptible to all the
  90  * various ways of blocking a signal emission, like g_signal_stop_emission()
  91  * or g_signal_handler_block().
  92  *
  93  * A binding will be severed, and the resources it allocates freed, whenever
  94  * either one of the #GObject instances it refers to are finalized, or when
  95  * the #GBinding instance loses its last reference.
  96  *
  97  * Bindings for languages with garbage collection can use
  98  * g_binding_unbind() to explicitly release a binding between the source
  99  * and target properties, instead of relying on the last reference on the
 100  * binding, source, and target instances to drop.
 101  *
 102  * #GBinding is available since GObject 2.26
 103  */
 104 
 105 #include &quot;config.h&quot;
 106 
 107 #include &lt;string.h&gt;
 108 
 109 #include &quot;gbinding.h&quot;
 110 #include &quot;genums.h&quot;
 111 #include &quot;gmarshal.h&quot;
 112 #include &quot;gobject.h&quot;
 113 #include &quot;gsignal.h&quot;
 114 #include &quot;gparamspecs.h&quot;
 115 #include &quot;gvaluetypes.h&quot;
 116 
 117 #include &quot;glibintl.h&quot;
 118 
 119 
 120 GType
 121 g_binding_flags_get_type (void)
 122 {
 123   static volatile gsize g_define_type_id__volatile = 0;
 124 
 125   if (g_once_init_enter (&amp;g_define_type_id__volatile))
 126     {
 127       static const GFlagsValue values[] = {
 128         { G_BINDING_DEFAULT, &quot;G_BINDING_DEFAULT&quot;, &quot;default&quot; },
 129         { G_BINDING_BIDIRECTIONAL, &quot;G_BINDING_BIDIRECTIONAL&quot;, &quot;bidirectional&quot; },
 130         { G_BINDING_SYNC_CREATE, &quot;G_BINDING_SYNC_CREATE&quot;, &quot;sync-create&quot; },
 131         { G_BINDING_INVERT_BOOLEAN, &quot;G_BINDING_INVERT_BOOLEAN&quot;, &quot;invert-boolean&quot; },
 132         { 0, NULL, NULL }
 133       };
 134       GType g_define_type_id =
 135         g_flags_register_static (g_intern_static_string (&quot;GBindingFlags&quot;), values);
 136       g_once_init_leave (&amp;g_define_type_id__volatile, g_define_type_id);
 137     }
 138 
 139   return g_define_type_id__volatile;
 140 }
 141 
 142 #define G_BINDING_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), G_TYPE_BINDING, GBindingClass))
 143 #define G_IS_BINDING_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), G_TYPE_BINDING))
 144 #define G_BINDING_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), G_TYPE_BINDING, GBindingClass))
 145 
 146 typedef struct _GBindingClass           GBindingClass;
 147 
 148 struct _GBinding
 149 {
 150   GObject parent_instance;
 151 
 152   /* no reference is held on the objects, to avoid cycles */
 153   GObject *source;
 154   GObject *target;
 155 
 156   /* the property names are interned, so they should not be freed */
 157   const gchar *source_property;
 158   const gchar *target_property;
 159 
 160   GParamSpec *source_pspec;
 161   GParamSpec *target_pspec;
 162 
 163   GBindingTransformFunc transform_s2t;
 164   GBindingTransformFunc transform_t2s;
 165 
 166   GBindingFlags flags;
 167 
 168   guint source_notify;
 169   guint target_notify;
 170 
 171   gpointer transform_data;
 172   GDestroyNotify notify;
 173 
 174   /* a guard, to avoid loops */
 175   guint is_frozen : 1;
 176 };
 177 
 178 struct _GBindingClass
 179 {
 180   GObjectClass parent_class;
 181 };
 182 
 183 enum
 184 {
 185   PROP_0,
 186 
 187   PROP_SOURCE,
 188   PROP_TARGET,
 189   PROP_SOURCE_PROPERTY,
 190   PROP_TARGET_PROPERTY,
 191   PROP_FLAGS
 192 };
 193 
 194 static guint gobject_notify_signal_id;
 195 
 196 G_DEFINE_TYPE (GBinding, g_binding, G_TYPE_OBJECT)
 197 
 198 /* the basic assumption is that if either the source or the target
 199  * goes away then the binding does not exist any more and it should
 200  * be reaped as well
 201  */
 202 static void
 203 weak_unbind (gpointer  user_data,
 204              GObject  *where_the_object_was)
 205 {
 206   GBinding *binding = user_data;
 207 
 208   /* if what went away was the source, unset it so that GBinding::finalize
 209    * does not try to access it; otherwise, disconnect everything and remove
 210    * the GBinding instance from the object&#39;s qdata
 211    */
 212   if (binding-&gt;source == where_the_object_was)
 213     binding-&gt;source = NULL;
 214   else
 215     {
 216       if (binding-&gt;source_notify != 0)
 217         g_signal_handler_disconnect (binding-&gt;source, binding-&gt;source_notify);
 218 
 219       g_object_weak_unref (binding-&gt;source, weak_unbind, user_data);
 220 
 221       binding-&gt;source_notify = 0;
 222       binding-&gt;source = NULL;
 223     }
 224 
 225   /* as above, but with the target */
 226   if (binding-&gt;target == where_the_object_was)
 227     binding-&gt;target = NULL;
 228   else
 229     {
 230       if (binding-&gt;target_notify != 0)
 231         g_signal_handler_disconnect (binding-&gt;target, binding-&gt;target_notify);
 232 
 233       g_object_weak_unref (binding-&gt;target, weak_unbind, user_data);
 234 
 235       binding-&gt;target_notify = 0;
 236       binding-&gt;target = NULL;
 237     }
 238 
 239   /* this will take care of the binding itself */
 240   g_object_unref (binding);
 241 }
 242 
 243 static gboolean
 244 default_transform (GBinding     *binding,
 245                    const GValue *value_a,
 246                    GValue       *value_b,
 247                    gpointer      user_data G_GNUC_UNUSED)
 248 {
 249   /* if it&#39;s not the same type, try to convert it using the GValue
 250    * transformation API; otherwise just copy it
 251    */
 252   if (!g_type_is_a (G_VALUE_TYPE (value_a), G_VALUE_TYPE (value_b)))
 253     {
 254       /* are these two types compatible (can be directly copied)? */
 255       if (g_value_type_compatible (G_VALUE_TYPE (value_a),
 256                                    G_VALUE_TYPE (value_b)))
 257         {
 258           g_value_copy (value_a, value_b);
 259           return TRUE;
 260         }
 261 
 262       if (g_value_type_transformable (G_VALUE_TYPE (value_a),
 263                                       G_VALUE_TYPE (value_b)))
 264         {
 265           if (g_value_transform (value_a, value_b))
 266             return TRUE;
 267         }
 268 
 269       g_warning (&quot;%s: Unable to convert a value of type %s to a &quot;
 270                  &quot;value of type %s&quot;,
 271                  G_STRLOC,
 272                  g_type_name (G_VALUE_TYPE (value_a)),
 273                  g_type_name (G_VALUE_TYPE (value_b)));
 274 
 275       return FALSE;
 276     }
 277 
 278   g_value_copy (value_a, value_b);
 279   return TRUE;
 280 }
 281 
 282 static gboolean
 283 default_invert_boolean_transform (GBinding     *binding,
 284                                   const GValue *value_a,
 285                                   GValue       *value_b,
 286                                   gpointer      user_data G_GNUC_UNUSED)
 287 {
 288   gboolean value;
 289 
 290   g_assert (G_VALUE_HOLDS_BOOLEAN (value_a));
 291   g_assert (G_VALUE_HOLDS_BOOLEAN (value_b));
 292 
 293   value = g_value_get_boolean (value_a);
 294   value = !value;
 295 
 296   g_value_set_boolean (value_b, value);
 297 
 298   return TRUE;
 299 }
 300 
 301 static void
 302 on_source_notify (GObject    *gobject,
 303                   GParamSpec *pspec,
 304                   GBinding   *binding)
 305 {
 306   GValue from_value = G_VALUE_INIT;
 307   GValue to_value = G_VALUE_INIT;
 308   gboolean res;
 309 
 310   if (binding-&gt;is_frozen)
 311     return;
 312 
 313   g_value_init (&amp;from_value, G_PARAM_SPEC_VALUE_TYPE (binding-&gt;source_pspec));
 314   g_value_init (&amp;to_value, G_PARAM_SPEC_VALUE_TYPE (binding-&gt;target_pspec));
 315 
 316   g_object_get_property (binding-&gt;source, binding-&gt;source_pspec-&gt;name, &amp;from_value);
 317 
 318   res = binding-&gt;transform_s2t (binding,
 319                                 &amp;from_value,
 320                                 &amp;to_value,
 321                                 binding-&gt;transform_data);
 322   if (res)
 323     {
 324       binding-&gt;is_frozen = TRUE;
 325 
 326       g_param_value_validate (binding-&gt;target_pspec, &amp;to_value);
 327       g_object_set_property (binding-&gt;target, binding-&gt;target_pspec-&gt;name, &amp;to_value);
 328 
 329       binding-&gt;is_frozen = FALSE;
 330     }
 331 
 332   g_value_unset (&amp;from_value);
 333   g_value_unset (&amp;to_value);
 334 }
 335 
 336 static void
 337 on_target_notify (GObject    *gobject,
 338                   GParamSpec *pspec,
 339                   GBinding   *binding)
 340 {
 341   GValue from_value = G_VALUE_INIT;
 342   GValue to_value = G_VALUE_INIT;
 343   gboolean res;
 344 
 345   if (binding-&gt;is_frozen)
 346     return;
 347 
 348   g_value_init (&amp;from_value, G_PARAM_SPEC_VALUE_TYPE (binding-&gt;target_pspec));
 349   g_value_init (&amp;to_value, G_PARAM_SPEC_VALUE_TYPE (binding-&gt;source_pspec));
 350 
 351   g_object_get_property (binding-&gt;target, binding-&gt;target_pspec-&gt;name, &amp;from_value);
 352 
 353   res = binding-&gt;transform_t2s (binding,
 354                                 &amp;from_value,
 355                                 &amp;to_value,
 356                                 binding-&gt;transform_data);
 357   if (res)
 358     {
 359       binding-&gt;is_frozen = TRUE;
 360 
 361       g_param_value_validate (binding-&gt;source_pspec, &amp;to_value);
 362       g_object_set_property (binding-&gt;source, binding-&gt;source_pspec-&gt;name, &amp;to_value);
 363 
 364       binding-&gt;is_frozen = FALSE;
 365     }
 366 
 367   g_value_unset (&amp;from_value);
 368   g_value_unset (&amp;to_value);
 369 }
 370 
 371 static inline void
 372 g_binding_unbind_internal (GBinding *binding,
 373                            gboolean  unref_binding)
 374 {
 375   gboolean source_is_target = binding-&gt;source == binding-&gt;target;
 376   gboolean binding_was_removed = FALSE;
 377 
 378   /* dispose of the transformation data */
 379   if (binding-&gt;notify != NULL)
 380     {
 381       binding-&gt;notify (binding-&gt;transform_data);
 382 
 383       binding-&gt;transform_data = NULL;
 384       binding-&gt;notify = NULL;
 385     }
 386 
 387   if (binding-&gt;source != NULL)
 388     {
 389       if (binding-&gt;source_notify != 0)
 390         g_signal_handler_disconnect (binding-&gt;source, binding-&gt;source_notify);
 391 
 392       g_object_weak_unref (binding-&gt;source, weak_unbind, binding);
 393 
 394       binding-&gt;source_notify = 0;
 395       binding-&gt;source = NULL;
 396       binding_was_removed = TRUE;
 397     }
 398 
 399   if (binding-&gt;target != NULL)
 400     {
 401       if (binding-&gt;target_notify != 0)
 402         g_signal_handler_disconnect (binding-&gt;target, binding-&gt;target_notify);
 403 
 404       if (!source_is_target)
 405         g_object_weak_unref (binding-&gt;target, weak_unbind, binding);
 406 
 407       binding-&gt;target_notify = 0;
 408       binding-&gt;target = NULL;
 409       binding_was_removed = TRUE;
 410     }
 411 
 412   if (binding_was_removed &amp;&amp; unref_binding)
 413     g_object_unref (binding);
 414 }
 415 
 416 static void
 417 g_binding_finalize (GObject *gobject)
 418 {
 419   GBinding *binding = G_BINDING (gobject);
 420 
 421   g_binding_unbind_internal (binding, FALSE);
 422 
 423   G_OBJECT_CLASS (g_binding_parent_class)-&gt;finalize (gobject);
 424 }
 425 
 426 static void
 427 g_binding_set_property (GObject      *gobject,
 428                         guint         prop_id,
 429                         const GValue *value,
 430                         GParamSpec   *pspec)
 431 {
 432   GBinding *binding = G_BINDING (gobject);
 433 
 434   switch (prop_id)
 435     {
 436     case PROP_SOURCE:
 437       binding-&gt;source = g_value_get_object (value);
 438       break;
 439 
 440     case PROP_SOURCE_PROPERTY:
 441       binding-&gt;source_property = g_intern_string (g_value_get_string (value));
 442       break;
 443 
 444     case PROP_TARGET:
 445       binding-&gt;target = g_value_get_object (value);
 446       break;
 447 
 448     case PROP_TARGET_PROPERTY:
 449       binding-&gt;target_property = g_intern_string (g_value_get_string (value));
 450       break;
 451 
 452     case PROP_FLAGS:
 453       binding-&gt;flags = g_value_get_flags (value);
 454       break;
 455 
 456     default:
 457       G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
 458       break;
 459     }
 460 }
 461 
 462 static void
 463 g_binding_get_property (GObject    *gobject,
 464                         guint       prop_id,
 465                         GValue     *value,
 466                         GParamSpec *pspec)
 467 {
 468   GBinding *binding = G_BINDING (gobject);
 469 
 470   switch (prop_id)
 471     {
 472     case PROP_SOURCE:
 473       g_value_set_object (value, binding-&gt;source);
 474       break;
 475 
 476     case PROP_SOURCE_PROPERTY:
 477       g_value_set_string (value, binding-&gt;source_property);
 478       break;
 479 
 480     case PROP_TARGET:
 481       g_value_set_object (value, binding-&gt;target);
 482       break;
 483 
 484     case PROP_TARGET_PROPERTY:
 485       g_value_set_string (value, binding-&gt;target_property);
 486       break;
 487 
 488     case PROP_FLAGS:
 489       g_value_set_flags (value, binding-&gt;flags);
 490       break;
 491 
 492     default:
 493       G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
 494       break;
 495     }
 496 }
 497 
 498 static void
 499 g_binding_constructed (GObject *gobject)
 500 {
 501   GBinding *binding = G_BINDING (gobject);
 502   GBindingTransformFunc transform_func = default_transform;
 503   GQuark source_property_detail;
 504   GClosure *source_notify_closure;
 505 
 506   /* assert that we were constructed correctly */
 507   g_assert (binding-&gt;source != NULL);
 508   g_assert (binding-&gt;target != NULL);
 509   g_assert (binding-&gt;source_property != NULL);
 510   g_assert (binding-&gt;target_property != NULL);
 511 
 512   /* we assume a check was performed prior to construction - since
 513    * g_object_bind_property_full() does it; we cannot fail construction
 514    * anyway, so it would be hard for use to properly warn here
 515    */
 516   binding-&gt;source_pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (binding-&gt;source), binding-&gt;source_property);
 517   binding-&gt;target_pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (binding-&gt;target), binding-&gt;target_property);
 518   g_assert (binding-&gt;source_pspec != NULL);
 519   g_assert (binding-&gt;target_pspec != NULL);
 520 
 521   /* switch to the invert boolean transform if needed */
 522   if (binding-&gt;flags &amp; G_BINDING_INVERT_BOOLEAN)
 523     transform_func = default_invert_boolean_transform;
 524 
 525   /* set the default transformation functions here */
 526   binding-&gt;transform_s2t = transform_func;
 527   binding-&gt;transform_t2s = transform_func;
 528 
 529   binding-&gt;transform_data = NULL;
 530   binding-&gt;notify = NULL;
 531 
 532   source_property_detail = g_quark_from_string (binding-&gt;source_property);
 533   source_notify_closure = g_cclosure_new (G_CALLBACK (on_source_notify),
 534                                           binding, NULL);
 535   binding-&gt;source_notify = g_signal_connect_closure_by_id (binding-&gt;source,
 536                                                            gobject_notify_signal_id,
 537                                                            source_property_detail,
 538                                                            source_notify_closure,
 539                                                            FALSE);
 540 
 541   g_object_weak_ref (binding-&gt;source, weak_unbind, binding);
 542 
 543   if (binding-&gt;flags &amp; G_BINDING_BIDIRECTIONAL)
 544     {
 545       GQuark target_property_detail;
 546       GClosure *target_notify_closure;
 547 
 548       target_property_detail = g_quark_from_string (binding-&gt;target_property);
 549       target_notify_closure = g_cclosure_new (G_CALLBACK (on_target_notify),
 550                                               binding, NULL);
 551       binding-&gt;target_notify = g_signal_connect_closure_by_id (binding-&gt;target,
 552                                                                gobject_notify_signal_id,
 553                                                                target_property_detail,
 554                                                                target_notify_closure,
 555                                                                FALSE);
 556     }
 557 
 558   if (binding-&gt;target != binding-&gt;source)
 559     g_object_weak_ref (binding-&gt;target, weak_unbind, binding);
 560 }
 561 
 562 static void
 563 g_binding_class_init (GBindingClass *klass)
 564 {
 565   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 566 
 567   gobject_notify_signal_id = g_signal_lookup (&quot;notify&quot;, G_TYPE_OBJECT);
 568   g_assert (gobject_notify_signal_id != 0);
 569 
 570   gobject_class-&gt;constructed = g_binding_constructed;
 571   gobject_class-&gt;set_property = g_binding_set_property;
 572   gobject_class-&gt;get_property = g_binding_get_property;
 573   gobject_class-&gt;finalize = g_binding_finalize;
 574 
 575   /**
 576    * GBinding:source:
 577    *
 578    * The #GObject that should be used as the source of the binding
 579    *
 580    * Since: 2.26
 581    */
 582   g_object_class_install_property (gobject_class, PROP_SOURCE,
 583                                    g_param_spec_object (&quot;source&quot;,
 584                                                         P_(&quot;Source&quot;),
 585                                                         P_(&quot;The source of the binding&quot;),
 586                                                         G_TYPE_OBJECT,
 587                                                         G_PARAM_CONSTRUCT_ONLY |
 588                                                         G_PARAM_READWRITE |
 589                                                         G_PARAM_STATIC_STRINGS));
 590   /**
 591    * GBinding:target:
 592    *
 593    * The #GObject that should be used as the target of the binding
 594    *
 595    * Since: 2.26
 596    */
 597   g_object_class_install_property (gobject_class, PROP_TARGET,
 598                                    g_param_spec_object (&quot;target&quot;,
 599                                                         P_(&quot;Target&quot;),
 600                                                         P_(&quot;The target of the binding&quot;),
 601                                                         G_TYPE_OBJECT,
 602                                                         G_PARAM_CONSTRUCT_ONLY |
 603                                                         G_PARAM_READWRITE |
 604                                                         G_PARAM_STATIC_STRINGS));
 605   /**
 606    * GBinding:source-property:
 607    *
 608    * The name of the property of #GBinding:source that should be used
 609    * as the source of the binding
 610    *
 611    * Since: 2.26
 612    */
 613   g_object_class_install_property (gobject_class, PROP_SOURCE_PROPERTY,
 614                                    g_param_spec_string (&quot;source-property&quot;,
 615                                                         P_(&quot;Source Property&quot;),
 616                                                         P_(&quot;The property on the source to bind&quot;),
 617                                                         NULL,
 618                                                         G_PARAM_CONSTRUCT_ONLY |
 619                                                         G_PARAM_READWRITE |
 620                                                         G_PARAM_STATIC_STRINGS));
 621   /**
 622    * GBinding:target-property:
 623    *
 624    * The name of the property of #GBinding:target that should be used
 625    * as the target of the binding
 626    *
 627    * Since: 2.26
 628    */
 629   g_object_class_install_property (gobject_class, PROP_TARGET_PROPERTY,
 630                                    g_param_spec_string (&quot;target-property&quot;,
 631                                                         P_(&quot;Target Property&quot;),
 632                                                         P_(&quot;The property on the target to bind&quot;),
 633                                                         NULL,
 634                                                         G_PARAM_CONSTRUCT_ONLY |
 635                                                         G_PARAM_READWRITE |
 636                                                         G_PARAM_STATIC_STRINGS));
 637   /**
 638    * GBinding:flags:
 639    *
 640    * Flags to be used to control the #GBinding
 641    *
 642    * Since: 2.26
 643    */
 644   g_object_class_install_property (gobject_class, PROP_FLAGS,
 645                                    g_param_spec_flags (&quot;flags&quot;,
 646                                                        P_(&quot;Flags&quot;),
 647                                                        P_(&quot;The binding flags&quot;),
 648                                                        G_TYPE_BINDING_FLAGS,
 649                                                        G_BINDING_DEFAULT,
 650                                                        G_PARAM_CONSTRUCT_ONLY |
 651                                                        G_PARAM_READWRITE |
 652                                                        G_PARAM_STATIC_STRINGS));
 653 }
 654 
 655 static void
 656 g_binding_init (GBinding *binding)
 657 {
 658 }
 659 
 660 /**
 661  * g_binding_get_flags:
 662  * @binding: a #GBinding
 663  *
 664  * Retrieves the flags passed when constructing the #GBinding.
 665  *
 666  * Returns: the #GBindingFlags used by the #GBinding
 667  *
 668  * Since: 2.26
 669  */
 670 GBindingFlags
 671 g_binding_get_flags (GBinding *binding)
 672 {
 673   g_return_val_if_fail (G_IS_BINDING (binding), G_BINDING_DEFAULT);
 674 
 675   return binding-&gt;flags;
 676 }
 677 
 678 /**
 679  * g_binding_get_source:
 680  * @binding: a #GBinding
 681  *
 682  * Retrieves the #GObject instance used as the source of the binding.
 683  *
 684  * Returns: (transfer none): the source #GObject
 685  *
 686  * Since: 2.26
 687  */
 688 GObject *
 689 g_binding_get_source (GBinding *binding)
 690 {
 691   g_return_val_if_fail (G_IS_BINDING (binding), NULL);
 692 
 693   return binding-&gt;source;
 694 }
 695 
 696 /**
 697  * g_binding_get_target:
 698  * @binding: a #GBinding
 699  *
 700  * Retrieves the #GObject instance used as the target of the binding.
 701  *
 702  * Returns: (transfer none): the target #GObject
 703  *
 704  * Since: 2.26
 705  */
 706 GObject *
 707 g_binding_get_target (GBinding *binding)
 708 {
 709   g_return_val_if_fail (G_IS_BINDING (binding), NULL);
 710 
 711   return binding-&gt;target;
 712 }
 713 
 714 /**
 715  * g_binding_get_source_property:
 716  * @binding: a #GBinding
 717  *
 718  * Retrieves the name of the property of #GBinding:source used as the source
 719  * of the binding.
 720  *
 721  * Returns: the name of the source property
 722  *
 723  * Since: 2.26
 724  */
 725 const gchar *
 726 g_binding_get_source_property (GBinding *binding)
 727 {
 728   g_return_val_if_fail (G_IS_BINDING (binding), NULL);
 729 
 730   return binding-&gt;source_property;
 731 }
 732 
 733 /**
 734  * g_binding_get_target_property:
 735  * @binding: a #GBinding
 736  *
 737  * Retrieves the name of the property of #GBinding:target used as the target
 738  * of the binding.
 739  *
 740  * Returns: the name of the target property
 741  *
 742  * Since: 2.26
 743  */
 744 const gchar *
 745 g_binding_get_target_property (GBinding *binding)
 746 {
 747   g_return_val_if_fail (G_IS_BINDING (binding), NULL);
 748 
 749   return binding-&gt;target_property;
 750 }
 751 
 752 /**
 753  * g_binding_unbind:
 754  * @binding: a #GBinding
 755  *
 756  * Explicitly releases the binding between the source and the target
 757  * property expressed by @binding.
 758  *
 759  * This function will release the reference that is being held on
 760  * the @binding instance; if you want to hold on to the #GBinding instance
 761  * after calling g_binding_unbind(), you will need to hold a reference
 762  * to it.
 763  *
 764  * Since: 2.38
 765  */
 766 void
 767 g_binding_unbind (GBinding *binding)
 768 {
 769   g_return_if_fail (G_IS_BINDING (binding));
 770 
 771   g_binding_unbind_internal (binding, TRUE);
 772 }
 773 
 774 /**
 775  * g_object_bind_property_full:
 776  * @source: (type GObject.Object): the source #GObject
 777  * @source_property: the property on @source to bind
 778  * @target: (type GObject.Object): the target #GObject
 779  * @target_property: the property on @target to bind
 780  * @flags: flags to pass to #GBinding
 781  * @transform_to: (scope notified) (nullable): the transformation function
 782  *     from the @source to the @target, or %NULL to use the default
 783  * @transform_from: (scope notified) (nullable): the transformation function
 784  *     from the @target to the @source, or %NULL to use the default
 785  * @user_data: custom data to be passed to the transformation functions,
 786  *     or %NULL
 787  * @notify: (nullable): a function to call when disposing the binding, to free
 788  *     resources used by the transformation functions, or %NULL if not required
 789  *
 790  * Complete version of g_object_bind_property().
 791  *
 792  * Creates a binding between @source_property on @source and @target_property
 793  * on @target, allowing you to set the transformation functions to be used by
 794  * the binding.
 795  *
 796  * If @flags contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
 797  * if @target_property on @target changes then the @source_property on @source
 798  * will be updated as well. The @transform_from function is only used in case
 799  * of bidirectional bindings, otherwise it will be ignored
 800  *
 801  * The binding will automatically be removed when either the @source or the
<a name="1" id="anc1"></a><span class="line-modified"> 802  * @target instances are finalized. This will release the reference that is</span>
<span class="line-modified"> 803  * being held on the #GBinding instance; if you want to hold on to the</span>
<span class="line-modified"> 804  * #GBinding instance, you will need to hold a reference to it.</span>
<span class="line-added"> 805  *</span>
<span class="line-added"> 806  * To remove the binding, call g_binding_unbind().</span>
 807  *
 808  * A #GObject can have multiple bindings.
 809  *
 810  * The same @user_data parameter will be used for both @transform_to
 811  * and @transform_from transformation functions; the @notify function will
 812  * be called once, when the binding is removed. If you need different data
 813  * for each transformation function, please use
 814  * g_object_bind_property_with_closures() instead.
 815  *
 816  * Returns: (transfer none): the #GBinding instance representing the
 817  *     binding between the two #GObject instances. The binding is released
 818  *     whenever the #GBinding reference count reaches zero.
 819  *
 820  * Since: 2.26
 821  */
 822 GBinding *
 823 g_object_bind_property_full (gpointer               source,
 824                              const gchar           *source_property,
 825                              gpointer               target,
 826                              const gchar           *target_property,
 827                              GBindingFlags          flags,
 828                              GBindingTransformFunc  transform_to,
 829                              GBindingTransformFunc  transform_from,
 830                              gpointer               user_data,
 831                              GDestroyNotify         notify)
 832 {
 833   GParamSpec *pspec;
 834   GBinding *binding;
 835 
 836   g_return_val_if_fail (G_IS_OBJECT (source), NULL);
 837   g_return_val_if_fail (source_property != NULL, NULL);
 838   g_return_val_if_fail (G_IS_OBJECT (target), NULL);
 839   g_return_val_if_fail (target_property != NULL, NULL);
 840 
 841   if (source == target &amp;&amp; g_strcmp0 (source_property, target_property) == 0)
 842     {
 843       g_warning (&quot;Unable to bind the same property on the same instance&quot;);
 844       return NULL;
 845     }
 846 
 847   /* remove the G_BINDING_INVERT_BOOLEAN flag in case we have
 848    * custom transformation functions
 849    */
 850   if ((flags &amp; G_BINDING_INVERT_BOOLEAN) &amp;&amp;
 851       (transform_to != NULL || transform_from != NULL))
 852     {
 853       flags &amp;= ~G_BINDING_INVERT_BOOLEAN;
 854     }
 855 
 856   pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (source), source_property);
 857   if (pspec == NULL)
 858     {
 859       g_warning (&quot;%s: The source object of type %s has no property called &#39;%s&#39;&quot;,
 860                  G_STRLOC,
 861                  G_OBJECT_TYPE_NAME (source),
 862                  source_property);
 863       return NULL;
 864     }
 865 
 866   if (!(pspec-&gt;flags &amp; G_PARAM_READABLE))
 867     {
 868       g_warning (&quot;%s: The source object of type %s has no readable property called &#39;%s&#39;&quot;,
 869                  G_STRLOC,
 870                  G_OBJECT_TYPE_NAME (source),
 871                  source_property);
 872       return NULL;
 873     }
 874 
 875   if ((flags &amp; G_BINDING_BIDIRECTIONAL) &amp;&amp;
 876       ((pspec-&gt;flags &amp; G_PARAM_CONSTRUCT_ONLY) || !(pspec-&gt;flags &amp; G_PARAM_WRITABLE)))
 877     {
 878       g_warning (&quot;%s: The source object of type %s has no writable property called &#39;%s&#39;&quot;,
 879                  G_STRLOC,
 880                  G_OBJECT_TYPE_NAME (source),
 881                  source_property);
 882       return NULL;
 883     }
 884 
 885   if ((flags &amp; G_BINDING_INVERT_BOOLEAN) &amp;&amp;
 886       !(G_PARAM_SPEC_VALUE_TYPE (pspec) == G_TYPE_BOOLEAN))
 887     {
 888       g_warning (&quot;%s: The G_BINDING_INVERT_BOOLEAN flag can only be used &quot;
 889                  &quot;when binding boolean properties; the source property &#39;%s&#39; &quot;
 890                  &quot;is of type &#39;%s&#39;&quot;,
 891                  G_STRLOC,
 892                  source_property,
 893                  g_type_name (G_PARAM_SPEC_VALUE_TYPE (pspec)));
 894       return NULL;
 895     }
 896 
 897   pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (target), target_property);
 898   if (pspec == NULL)
 899     {
 900       g_warning (&quot;%s: The target object of type %s has no property called &#39;%s&#39;&quot;,
 901                  G_STRLOC,
 902                  G_OBJECT_TYPE_NAME (target),
 903                  target_property);
 904       return NULL;
 905     }
 906 
 907   if ((pspec-&gt;flags &amp; G_PARAM_CONSTRUCT_ONLY) || !(pspec-&gt;flags &amp; G_PARAM_WRITABLE))
 908     {
 909       g_warning (&quot;%s: The target object of type %s has no writable property called &#39;%s&#39;&quot;,
 910                  G_STRLOC,
 911                  G_OBJECT_TYPE_NAME (target),
 912                  target_property);
 913       return NULL;
 914     }
 915 
 916   if ((flags &amp; G_BINDING_BIDIRECTIONAL) &amp;&amp;
 917       !(pspec-&gt;flags &amp; G_PARAM_READABLE))
 918     {
 919       g_warning (&quot;%s: The target object of type %s has no readable property called &#39;%s&#39;&quot;,
 920                  G_STRLOC,
 921                  G_OBJECT_TYPE_NAME (target),
 922                  target_property);
 923       return NULL;
 924     }
 925 
 926   if ((flags &amp; G_BINDING_INVERT_BOOLEAN) &amp;&amp;
 927       !(G_PARAM_SPEC_VALUE_TYPE (pspec) == G_TYPE_BOOLEAN))
 928     {
 929       g_warning (&quot;%s: The G_BINDING_INVERT_BOOLEAN flag can only be used &quot;
 930                  &quot;when binding boolean properties; the target property &#39;%s&#39; &quot;
 931                  &quot;is of type &#39;%s&#39;&quot;,
 932                  G_STRLOC,
 933                  target_property,
 934                  g_type_name (G_PARAM_SPEC_VALUE_TYPE (pspec)));
 935       return NULL;
 936     }
 937 
 938   binding = g_object_new (G_TYPE_BINDING,
 939                           &quot;source&quot;, source,
 940                           &quot;source-property&quot;, source_property,
 941                           &quot;target&quot;, target,
 942                           &quot;target-property&quot;, target_property,
 943                           &quot;flags&quot;, flags,
 944                           NULL);
 945 
 946   if (transform_to != NULL)
 947     binding-&gt;transform_s2t = transform_to;
 948 
 949   if (transform_from != NULL)
 950     binding-&gt;transform_t2s = transform_from;
 951 
 952   binding-&gt;transform_data = user_data;
 953   binding-&gt;notify = notify;
 954 
 955   /* synchronize the target with the source by faking an emission of
 956    * the ::notify signal for the source property; this will also take
 957    * care of the bidirectional binding case because the eventual change
 958    * will emit a notification on the target
 959    */
 960   if (flags &amp; G_BINDING_SYNC_CREATE)
 961     on_source_notify (binding-&gt;source, binding-&gt;source_pspec, binding);
 962 
 963   return binding;
 964 }
 965 
 966 /**
 967  * g_object_bind_property:
 968  * @source: (type GObject.Object): the source #GObject
 969  * @source_property: the property on @source to bind
 970  * @target: (type GObject.Object): the target #GObject
 971  * @target_property: the property on @target to bind
 972  * @flags: flags to pass to #GBinding
 973  *
 974  * Creates a binding between @source_property on @source and @target_property
 975  * on @target. Whenever the @source_property is changed the @target_property is
 976  * updated using the same value. For instance:
 977  *
 978  * |[
 979  *   g_object_bind_property (action, &quot;active&quot;, widget, &quot;sensitive&quot;, 0);
 980  * ]|
 981  *
 982  * Will result in the &quot;sensitive&quot; property of the widget #GObject instance to be
 983  * updated with the same value of the &quot;active&quot; property of the action #GObject
 984  * instance.
 985  *
 986  * If @flags contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
 987  * if @target_property on @target changes then the @source_property on @source
 988  * will be updated as well.
 989  *
 990  * The binding will automatically be removed when either the @source or the
 991  * @target instances are finalized. To remove the binding without affecting the
 992  * @source and the @target you can just call g_object_unref() on the returned
 993  * #GBinding instance.
 994  *
 995  * A #GObject can have multiple bindings.
 996  *
 997  * Returns: (transfer none): the #GBinding instance representing the
 998  *     binding between the two #GObject instances. The binding is released
 999  *     whenever the #GBinding reference count reaches zero.
1000  *
1001  * Since: 2.26
1002  */
1003 GBinding *
1004 g_object_bind_property (gpointer       source,
1005                         const gchar   *source_property,
1006                         gpointer       target,
1007                         const gchar   *target_property,
1008                         GBindingFlags  flags)
1009 {
1010   /* type checking is done in g_object_bind_property_full() */
1011 
1012   return g_object_bind_property_full (source, source_property,
1013                                       target, target_property,
1014                                       flags,
1015                                       NULL,
1016                                       NULL,
1017                                       NULL, NULL);
1018 }
1019 
1020 typedef struct _TransformData
1021 {
1022   GClosure *transform_to_closure;
1023   GClosure *transform_from_closure;
1024 } TransformData;
1025 
1026 static gboolean
1027 bind_with_closures_transform_to (GBinding     *binding,
1028                                  const GValue *source,
1029                                  GValue       *target,
1030                                  gpointer      data)
1031 {
1032   TransformData *t_data = data;
1033   GValue params[3] = { G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT };
1034   GValue retval = G_VALUE_INIT;
1035   gboolean res;
1036 
1037   g_value_init (&amp;params[0], G_TYPE_BINDING);
1038   g_value_set_object (&amp;params[0], binding);
1039 
1040   g_value_init (&amp;params[1], G_TYPE_VALUE);
1041   g_value_set_boxed (&amp;params[1], source);
1042 
1043   g_value_init (&amp;params[2], G_TYPE_VALUE);
1044   g_value_set_boxed (&amp;params[2], target);
1045 
1046   g_value_init (&amp;retval, G_TYPE_BOOLEAN);
1047   g_value_set_boolean (&amp;retval, FALSE);
1048 
1049   g_closure_invoke (t_data-&gt;transform_to_closure, &amp;retval, 3, params, NULL);
1050 
1051   res = g_value_get_boolean (&amp;retval);
1052   if (res)
1053     {
1054       const GValue *out_value = g_value_get_boxed (&amp;params[2]);
1055 
1056       g_assert (out_value != NULL);
1057 
1058       g_value_copy (out_value, target);
1059     }
1060 
1061   g_value_unset (&amp;params[0]);
1062   g_value_unset (&amp;params[1]);
1063   g_value_unset (&amp;params[2]);
1064   g_value_unset (&amp;retval);
1065 
1066   return res;
1067 }
1068 
1069 static gboolean
1070 bind_with_closures_transform_from (GBinding     *binding,
1071                                    const GValue *source,
1072                                    GValue       *target,
1073                                    gpointer      data)
1074 {
1075   TransformData *t_data = data;
1076   GValue params[3] = { G_VALUE_INIT, G_VALUE_INIT, G_VALUE_INIT };
1077   GValue retval = G_VALUE_INIT;
1078   gboolean res;
1079 
1080   g_value_init (&amp;params[0], G_TYPE_BINDING);
1081   g_value_set_object (&amp;params[0], binding);
1082 
1083   g_value_init (&amp;params[1], G_TYPE_VALUE);
1084   g_value_set_boxed (&amp;params[1], source);
1085 
1086   g_value_init (&amp;params[2], G_TYPE_VALUE);
1087   g_value_set_boxed (&amp;params[2], target);
1088 
1089   g_value_init (&amp;retval, G_TYPE_BOOLEAN);
1090   g_value_set_boolean (&amp;retval, FALSE);
1091 
1092   g_closure_invoke (t_data-&gt;transform_from_closure, &amp;retval, 3, params, NULL);
1093 
1094   res = g_value_get_boolean (&amp;retval);
1095   if (res)
1096     {
1097       const GValue *out_value = g_value_get_boxed (&amp;params[2]);
1098 
1099       g_assert (out_value != NULL);
1100 
1101       g_value_copy (out_value, target);
1102     }
1103 
1104   g_value_unset (&amp;params[0]);
1105   g_value_unset (&amp;params[1]);
1106   g_value_unset (&amp;params[2]);
1107   g_value_unset (&amp;retval);
1108 
1109   return res;
1110 }
1111 
1112 static void
1113 bind_with_closures_free_func (gpointer data)
1114 {
1115   TransformData *t_data = data;
1116 
1117   if (t_data-&gt;transform_to_closure != NULL)
1118     g_closure_unref (t_data-&gt;transform_to_closure);
1119 
1120   if (t_data-&gt;transform_from_closure != NULL)
1121     g_closure_unref (t_data-&gt;transform_from_closure);
1122 
1123   g_slice_free (TransformData, t_data);
1124 }
1125 
1126 /**
1127  * g_object_bind_property_with_closures: (rename-to g_object_bind_property_full)
1128  * @source: (type GObject.Object): the source #GObject
1129  * @source_property: the property on @source to bind
1130  * @target: (type GObject.Object): the target #GObject
1131  * @target_property: the property on @target to bind
1132  * @flags: flags to pass to #GBinding
1133  * @transform_to: a #GClosure wrapping the transformation function
1134  *     from the @source to the @target, or %NULL to use the default
1135  * @transform_from: a #GClosure wrapping the transformation function
1136  *     from the @target to the @source, or %NULL to use the default
1137  *
1138  * Creates a binding between @source_property on @source and @target_property
1139  * on @target, allowing you to set the transformation functions to be used by
1140  * the binding.
1141  *
1142  * This function is the language bindings friendly version of
1143  * g_object_bind_property_full(), using #GClosures instead of
1144  * function pointers.
1145  *
1146  * Returns: (transfer none): the #GBinding instance representing the
1147  *     binding between the two #GObject instances. The binding is released
1148  *     whenever the #GBinding reference count reaches zero.
1149  *
1150  * Since: 2.26
1151  */
1152 GBinding *
1153 g_object_bind_property_with_closures (gpointer       source,
1154                                       const gchar   *source_property,
1155                                       gpointer       target,
1156                                       const gchar   *target_property,
1157                                       GBindingFlags  flags,
1158                                       GClosure      *transform_to,
1159                                       GClosure      *transform_from)
1160 {
1161   TransformData *data;
1162 
1163   data = g_slice_new0 (TransformData);
1164 
1165   if (transform_to != NULL)
1166     {
1167       if (G_CLOSURE_NEEDS_MARSHAL (transform_to))
1168         g_closure_set_marshal (transform_to, g_cclosure_marshal_BOOLEAN__BOXED_BOXED);
1169 
1170       data-&gt;transform_to_closure = g_closure_ref (transform_to);
1171       g_closure_sink (data-&gt;transform_to_closure);
1172     }
1173 
1174   if (transform_from != NULL)
1175     {
1176       if (G_CLOSURE_NEEDS_MARSHAL (transform_from))
1177         g_closure_set_marshal (transform_from, g_cclosure_marshal_BOOLEAN__BOXED_BOXED);
1178 
1179       data-&gt;transform_from_closure = g_closure_ref (transform_from);
1180       g_closure_sink (data-&gt;transform_from_closure);
1181     }
1182 
1183   return g_object_bind_property_full (source, source_property,
1184                                       target, target_property,
1185                                       flags,
1186                                       transform_to != NULL ? bind_with_closures_transform_to : NULL,
1187                                       transform_from != NULL ? bind_with_closures_transform_from : NULL,
1188                                       data,
1189                                       bind_with_closures_free_func);
1190 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>