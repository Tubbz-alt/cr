<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstsegment.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 2005 Wim Taymans &lt;wim@fluendo.com&gt;
   3  *
   4  * gstsegment.c: GstSegment subsystem
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 #include &quot;gst_private.h&quot;
  23 
  24 #include &lt;math.h&gt;
  25 
  26 #include &quot;gstutils.h&quot;
  27 #include &quot;gstsegment.h&quot;
  28 
  29 /**
  30  * SECTION:gstsegment
  31  * @title: GstSegment
  32  * @short_description: Structure describing the configured region of interest
  33  *                     in a media file.
  34  * @see_also: #GstEvent
  35  *
  36  * This helper structure holds the relevant values for tracking the region of
  37  * interest in a media file, called a segment.
  38  *
  39  * The structure can be used for two purposes:
  40  *
  41  *   * performing seeks (handling seek events)
  42  *   * tracking playback regions (handling newsegment events)
  43  *
  44  * The segment is usually configured by the application with a seek event which
  45  * is propagated upstream and eventually handled by an element that performs the seek.
  46  *
  47  * The configured segment is then propagated back downstream with a newsegment event.
  48  * This information is then used to clip media to the segment boundaries.
  49  *
  50  * A segment structure is initialized with gst_segment_init(), which takes a #GstFormat
  51  * that will be used as the format of the segment values. The segment will be configured
  52  * with a start value of 0 and a stop/duration of -1, which is undefined. The default
  53  * rate and applied_rate is 1.0.
  54  *
  55  * The public duration field contains the duration of the segment. When using
  56  * the segment for seeking, the start and time members should normally be left
  57  * to their default 0 value. The stop position is left to -1 unless explicitly
  58  * configured to a different value after a seek event.
  59  *
  60  * The current position in the segment should be set by changing the position
  61  * member in the structure.
  62  *
  63  * For elements that perform seeks, the current segment should be updated with the
  64  * gst_segment_do_seek() and the values from the seek event. This method will update
  65  * all the segment fields. The position field will contain the new playback position.
  66  * If the start_type was different from GST_SEEK_TYPE_NONE, playback continues from
  67  * the position position, possibly with updated flags or rate.
  68  *
  69  * For elements that want to use #GstSegment to track the playback region,
  70  * update the segment fields with the information from the newsegment event.
  71  * The gst_segment_clip() method can be used to check and clip
  72  * the media data to the segment boundaries.
  73  *
  74  * For elements that want to synchronize to the pipeline clock, gst_segment_to_running_time()
  75  * can be used to convert a timestamp to a value that can be used to synchronize
  76  * to the clock. This function takes into account the base as well as
  77  * any rate or applied_rate conversions.
  78  *
  79  * For elements that need to perform operations on media data in stream_time,
  80  * gst_segment_to_stream_time() can be used to convert a timestamp and the segment
  81  * info to stream time (which is always between 0 and the duration of the stream).
  82  */
  83 
  84 /* FIXME 2.0: remove unused format parameter.
  85  * Most of the methods in gstsegment.c take and extra GstFormat format, just to
  86  * verify segment-&gt;format == format.
  87  * See https://bugzilla.gnome.org/show_bug.cgi?id=788979
  88  */
  89 
  90 /**
  91  * gst_segment_copy:
  92  * @segment: (transfer none): a #GstSegment
  93  *
  94  * Create a copy of given @segment.
  95  *
  96  * Free-function: gst_segment_free
  97  *
  98  * Returns: (transfer full): a new #GstSegment, free with gst_segment_free().
  99  */
 100 GstSegment *
 101 gst_segment_copy (const GstSegment * segment)
 102 {
 103   GstSegment *result = NULL;
 104 
 105   if (segment) {
 106     result = (GstSegment *) g_slice_copy (sizeof (GstSegment), segment);
 107   }
 108   return result;
 109 }
 110 
 111 /**
 112  * gst_segment_copy_into:
 113  * @src: (transfer none): a #GstSegment
 114  * @dest: (transfer none): a #GstSegment
 115  *
 116  * Copy the contents of @src into @dest.
 117  */
 118 void
 119 gst_segment_copy_into (const GstSegment * src, GstSegment * dest)
 120 {
 121   memcpy (dest, src, sizeof (GstSegment));
 122 }
 123 
 124 G_DEFINE_BOXED_TYPE (GstSegment, gst_segment,
 125     (GBoxedCopyFunc) gst_segment_copy, (GBoxedFreeFunc) gst_segment_free);
 126 
 127 /**
 128  * gst_segment_new:
 129  *
 130  * Allocate a new #GstSegment structure and initialize it using
 131  * gst_segment_init().
 132  *
 133  * Free-function: gst_segment_free
 134  *
 135  * Returns: (transfer full): a new #GstSegment, free with gst_segment_free().
 136  */
 137 GstSegment *
 138 gst_segment_new (void)
 139 {
 140   GstSegment *result;
 141 
 142   result = g_slice_new0 (GstSegment);
 143   gst_segment_init (result, GST_FORMAT_UNDEFINED);
 144 
 145   return result;
 146 }
 147 
 148 /**
 149  * gst_segment_free:
 150  * @segment: (in) (transfer full): a #GstSegment
 151  *
 152  * Free the allocated segment @segment.
 153  */
 154 void
 155 gst_segment_free (GstSegment * segment)
 156 {
 157   g_slice_free (GstSegment, segment);
 158 }
 159 
 160 /**
 161  * gst_segment_init:
 162  * @segment: a #GstSegment structure.
 163  * @format: the format of the segment.
 164  *
 165  * The start/position fields are set to 0 and the stop/duration
 166  * fields are set to -1 (unknown). The default rate of 1.0 and no
 167  * flags are set.
 168  *
 169  * Initialize @segment to its default values.
 170  */
 171 void
 172 gst_segment_init (GstSegment * segment, GstFormat format)
 173 {
 174   g_return_if_fail (segment != NULL);
 175 
 176   segment-&gt;flags = GST_SEGMENT_FLAG_NONE;
 177   segment-&gt;rate = 1.0;
 178   segment-&gt;applied_rate = 1.0;
 179   segment-&gt;format = format;
 180   segment-&gt;base = 0;
 181   segment-&gt;offset = 0;
 182   segment-&gt;start = 0;
 183   segment-&gt;stop = -1;
 184   segment-&gt;time = 0;
 185   segment-&gt;position = 0;
 186   segment-&gt;duration = -1;
 187 }
 188 
 189 /**
 190  * gst_segment_do_seek:
 191  * @segment: a #GstSegment structure.
 192  * @rate: the rate of the segment.
 193  * @format: the format of the segment.
 194  * @flags: the segment flags for the segment
 195  * @start_type: the seek method
 196  * @start: the seek start value
 197  * @stop_type: the seek method
 198  * @stop: the seek stop value
 199  * @update: (out) (allow-none): boolean holding whether position was updated.
 200  *
 201  * Update the segment structure with the field values of a seek event (see
 202  * gst_event_new_seek()).
 203  *
 204  * After calling this method, the segment field position and time will
 205  * contain the requested new position in the segment. The new requested
 206  * position in the segment depends on @rate and @start_type and @stop_type.
 207  *
 208  * For positive @rate, the new position in the segment is the new @segment
 209  * start field when it was updated with a @start_type different from
 210  * #GST_SEEK_TYPE_NONE. If no update was performed on @segment start position
 211  * (#GST_SEEK_TYPE_NONE), @start is ignored and @segment position is
 212  * unmodified.
 213  *
 214  * For negative @rate, the new position in the segment is the new @segment
 215  * stop field when it was updated with a @stop_type different from
 216  * #GST_SEEK_TYPE_NONE. If no stop was previously configured in the segment, the
 217  * duration of the segment will be used to update the stop position.
 218  * If no update was performed on @segment stop position (#GST_SEEK_TYPE_NONE),
 219  * @stop is ignored and @segment position is unmodified.
 220  *
 221  * The applied rate of the segment will be set to 1.0 by default.
 222  * If the caller can apply a rate change, it should update @segment
 223  * rate and applied_rate after calling this function.
 224  *
 225  * @update will be set to %TRUE if a seek should be performed to the segment
 226  * position field. This field can be %FALSE if, for example, only the @rate
 227  * has been changed but not the playback position.
 228  *
 229  * Returns: %TRUE if the seek could be performed.
 230  */
 231 gboolean
 232 gst_segment_do_seek (GstSegment * segment, gdouble rate,
 233     GstFormat format, GstSeekFlags flags,
 234     GstSeekType start_type, guint64 start,
 235     GstSeekType stop_type, guint64 stop, gboolean * update)
 236 {
 237   gboolean update_stop, update_start;
 238   guint64 position, base;
 239 
 240   g_return_val_if_fail (rate != 0.0, FALSE);
 241   g_return_val_if_fail (segment != NULL, FALSE);
 242   g_return_val_if_fail (segment-&gt;format == format, FALSE);
 243 
 244   update_start = update_stop = TRUE;
 245 
 246   position = segment-&gt;position;
 247 
 248   /* segment-&gt;start is never invalid */
 249   switch (start_type) {
 250     case GST_SEEK_TYPE_NONE:
 251       /* no update to segment, take previous start */
 252       start = segment-&gt;start;
 253       update_start = FALSE;
 254       break;
 255     case GST_SEEK_TYPE_SET:
 256       /* start holds desired position, map -1 to the start */
 257       if (start == -1)
 258         start = 0;
 259       break;
 260     case GST_SEEK_TYPE_END:
 261       if (segment-&gt;duration != -1) {
 262         /* add start to total length */
 263         start = segment-&gt;duration + start;
 264       } else {
 265         /* no update if duration unknown */
 266         start = segment-&gt;start;
 267         update_start = FALSE;
 268       }
 269       break;
 270   }
 271   /* bring in sane range */
 272   if (segment-&gt;duration != -1)
 273     start = MIN (start, segment-&gt;duration);
 274   else
 275     start = MAX ((gint64) start, 0);
 276 
 277   /* stop can be -1 if we have not configured a stop. */
 278   switch (stop_type) {
 279     case GST_SEEK_TYPE_NONE:
 280       stop = segment-&gt;stop;
 281       update_stop = FALSE;
 282       break;
 283     case GST_SEEK_TYPE_SET:
 284       /* stop holds required value */
 285       break;
 286     case GST_SEEK_TYPE_END:
 287       if (segment-&gt;duration != -1) {
 288         stop = segment-&gt;duration + stop;
 289       } else {
 290         stop = segment-&gt;stop;
 291         update_stop = FALSE;
 292       }
 293       break;
 294   }
 295 
 296   /* if we have a valid stop time, make sure it is clipped */
 297   if (stop != -1) {
 298     if (segment-&gt;duration != -1)
 299       stop = CLAMP ((gint64) stop, 0, (gint64) segment-&gt;duration);
 300     else
 301       stop = MAX ((gint64) stop, 0);
 302   }
 303 
 304   /* we can&#39;t have stop before start */
 305   if (stop != -1) {
 306     if (start &gt; stop) {
 307       GST_WARNING (&quot;segment update failed: start(%&quot; G_GUINT64_FORMAT
 308           &quot;) &gt; stop(%&quot; G_GUINT64_FORMAT &quot;)&quot;, start, stop);
 309       g_return_val_if_fail (start &lt;= stop, FALSE);
 310       return FALSE;
 311     }
 312   }
 313 
 314   if (flags &amp; GST_SEEK_FLAG_FLUSH) {
 315     /* flush resets the running_time */
 316     base = 0;
 317   } else {
 318     /* make sure the position is inside the segment start/stop */
 319     position = CLAMP (position, segment-&gt;start, segment-&gt;stop);
 320 
 321     /* remember the elapsed time */
 322     base = gst_segment_to_running_time (segment, format, position);
 323     GST_DEBUG (&quot;updated segment.base: %&quot; G_GUINT64_FORMAT, base);
 324   }
 325 
 326   if (update_start &amp;&amp; rate &gt; 0.0) {
 327     position = start;
 328   }
 329   if (update_stop &amp;&amp; rate &lt; 0.0) {
 330     if (stop != -1)
 331       position = stop;
 332     else {
 333       if (segment-&gt;duration != -1)
 334         position = segment-&gt;duration;
 335       else
 336         position = 0;
 337     }
 338   }
 339 
 340   /* set update arg to reflect update of position */
 341   if (update)
 342     *update = position != segment-&gt;position;
 343 
 344   /* update new values */
 345   /* be explicit about our GstSeekFlag -&gt; GstSegmentFlag conversion */
 346   segment-&gt;flags = GST_SEGMENT_FLAG_NONE;
 347   if ((flags &amp; GST_SEEK_FLAG_FLUSH) != 0)
 348     segment-&gt;flags |= GST_SEGMENT_FLAG_RESET;
 349   if ((flags &amp; GST_SEEK_FLAG_TRICKMODE) != 0)
 350     segment-&gt;flags |= GST_SEGMENT_FLAG_TRICKMODE;
 351   if ((flags &amp; GST_SEEK_FLAG_SEGMENT) != 0)
 352     segment-&gt;flags |= GST_SEGMENT_FLAG_SEGMENT;
 353   if ((flags &amp; GST_SEEK_FLAG_TRICKMODE_KEY_UNITS) != 0)
 354     segment-&gt;flags |= GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS;
 355   if ((flags &amp; GST_SEEK_FLAG_TRICKMODE_NO_AUDIO) != 0)
 356     segment-&gt;flags |= GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO;
 357 
 358   segment-&gt;rate = rate;
 359   segment-&gt;applied_rate = 1.0;
 360 
 361   segment-&gt;base = base;
 362   if (rate &gt; 0.0)
 363     segment-&gt;offset = position - start;
 364   else {
 365     if (stop != -1)
 366       segment-&gt;offset = stop - position;
 367     else if (segment-&gt;duration != -1)
 368       segment-&gt;offset = segment-&gt;duration - position;
 369     else
 370       segment-&gt;offset = 0;
 371   }
 372 
 373   segment-&gt;start = start;
 374   segment-&gt;stop = stop;
 375   segment-&gt;time = start;
 376   segment-&gt;position = position;
 377 
 378   GST_INFO (&quot;segment updated: %&quot; GST_SEGMENT_FORMAT, segment);
 379 
 380   return TRUE;
 381 }
 382 
 383 /**
 384  * gst_segment_to_stream_time_full:
 385  * @segment: a #GstSegment structure.
 386  * @format: the format of the segment.
 387  * @position: the position in the segment
 388  * @stream_time: (out): result stream-time
 389  *
 390  * Translate @position to the total stream time using the currently configured
 391  * segment. Compared to gst_segment_to_stream_time() this function can return
 392  * negative stream-time.
 393  *
 394  * This function is typically used by elements that need to synchronize buffers
<a name="1" id="anc1"></a><span class="line-modified"> 395  * against the clock or each other.</span>
 396  *
 397  * @position can be any value and the result of this function for values outside
 398  * of the segment is extrapolated.
 399  *
 400  * When 1 is returned, @position resulted in a positive stream-time returned
 401  * in @stream_time.
 402  *
 403  * When this function returns -1, the returned @stream_time should be negated
 404  * to get the real negative stream time.
 405  *
 406  * Returns: a 1 or -1 on success, 0 on failure.
 407  *
 408  * Since: 1.8
 409  */
 410 gint
 411 gst_segment_to_stream_time_full (const GstSegment * segment, GstFormat format,
 412     guint64 position, guint64 * stream_time)
 413 {
 414   guint64 start, stop, time;
 415   gdouble abs_applied_rate;
 416   gint res;
 417 
 418   /* format does not matter for -1 */
 419   if (G_UNLIKELY (position == -1)) {
 420     *stream_time = -1;
 421     return 0;
 422   }
 423 
 424   g_return_val_if_fail (segment != NULL, 0);
 425   g_return_val_if_fail (segment-&gt;format == format, 0);
 426 
 427   stop = segment-&gt;stop;
 428 
 429   start = segment-&gt;start;
 430   time = segment-&gt;time;
 431 
 432   /* time must be known */
 433   if (G_UNLIKELY (time == -1))
 434     return 0;
 435 
 436   abs_applied_rate = ABS (segment-&gt;applied_rate);
 437 
 438   /* add or subtract from segment time based on applied rate */
 439   if (G_LIKELY (segment-&gt;applied_rate &gt; 0.0)) {
 440     if (G_LIKELY (position &gt; start)) {
 441       /* bring to uncorrected position in segment */
 442       *stream_time = position - start;
 443       /* correct for applied rate if needed */
 444       if (G_UNLIKELY (abs_applied_rate != 1.0))
 445         *stream_time *= abs_applied_rate;
 446       /* correct for segment time */
 447       *stream_time += time;
 448       res = 1;
 449     } else {
 450       *stream_time = start - position;
 451       if (G_UNLIKELY (abs_applied_rate != 1.0))
 452         *stream_time *= abs_applied_rate;
 453       if (*stream_time &gt; time) {
 454         *stream_time -= time;
 455         res = -1;
 456       } else {
 457         *stream_time = time - *stream_time;
 458         res = 1;
 459       }
 460     }
 461   } else {
 462     /* correct for segment time. Streams with a negative applied_rate
 463      * have timestamps between start and stop, as usual, but have the
 464      * time member starting high and going backwards.  */
 465     /* cannot continue without a known segment stop */
 466     if (G_UNLIKELY (stop == -1))
 467       return 0;
 468     if (G_UNLIKELY (position &gt; stop)) {
 469       *stream_time = position - stop;
 470       if (G_UNLIKELY (abs_applied_rate != 1.0))
 471         *stream_time *= abs_applied_rate;
 472       if (*stream_time &gt; time) {
 473         *stream_time -= time;
 474         res = -1;
 475       } else {
 476         *stream_time = time - *stream_time;
 477         res = 1;
 478       }
 479     } else {
 480       *stream_time = stop - position;
 481       if (G_UNLIKELY (abs_applied_rate != 1.0))
 482         *stream_time *= abs_applied_rate;
 483       *stream_time += time;
 484       res = 1;
 485     }
 486   }
 487 
 488   return res;
 489 }
 490 
 491 /**
 492  * gst_segment_to_stream_time:
 493  * @segment: a #GstSegment structure.
 494  * @format: the format of the segment.
 495  * @position: the position in the segment
 496  *
 497  * Translate @position to stream time using the currently configured
 498  * segment. The @position value must be between @segment start and
 499  * stop value.
 500  *
 501  * This function is typically used by elements that need to operate on
 502  * the stream time of the buffers it receives, such as effect plugins.
 503  * In those use cases, @position is typically the buffer timestamp or
 504  * clock time that one wants to convert to the stream time.
 505  * The stream time is always between 0 and the total duration of the
 506  * media stream.
 507  *
 508  * Returns: the position in stream_time or -1 when an invalid position
 509  * was given.
 510  *
 511  * Since: 1.8
 512  */
 513 guint64
 514 gst_segment_to_stream_time (const GstSegment * segment, GstFormat format,
 515     guint64 position)
 516 {
 517   guint64 result;
 518 
 519   g_return_val_if_fail (segment != NULL, -1);
 520   g_return_val_if_fail (segment-&gt;format == format, -1);
 521 
 522   /* before the segment boundary */
 523   if (G_UNLIKELY (position &lt; segment-&gt;start)) {
 524     GST_DEBUG (&quot;position(%&quot; G_GUINT64_FORMAT &quot;) &lt; start(%&quot; G_GUINT64_FORMAT
 525         &quot;)&quot;, position, segment-&gt;start);
 526     return -1;
 527   }
 528   /* after the segment boundary */
 529   if (G_UNLIKELY (segment-&gt;stop != -1 &amp;&amp; position &gt; segment-&gt;stop)) {
 530     GST_DEBUG (&quot;position(%&quot; G_GUINT64_FORMAT &quot;) &gt; stop(%&quot; G_GUINT64_FORMAT
 531         &quot;)&quot;, position, segment-&gt;stop);
 532     return -1;
 533   }
 534 
 535 #ifdef GSTREAMER_LITE
 536   if (segment-&gt;format != format)
 537     return -1;
 538 #endif // GSTREAMER_LITE
 539 
 540   if (gst_segment_to_stream_time_full (segment, format, position, &amp;result) == 1)
 541     return result;
 542 
 543   return -1;
 544 }
 545 
 546 /**
 547  * gst_segment_position_from_stream_time_full:
 548  * @segment: a #GstSegment structure.
 549  * @format: the format of the segment.
 550  * @stream_time: the stream-time
 551  * @position: (out): the resulting position in the segment
 552  *
 553  * Translate @stream_time to the segment position using the currently configured
 554  * segment. Compared to gst_segment_position_from_stream_time() this function can
 555  * return negative segment position.
 556  *
 557  * This function is typically used by elements that need to synchronize buffers
 558  * against the clock or each other.
 559  *
 560  * @stream_time can be any value and the result of this function for values outside
 561  * of the segment is extrapolated.
 562  *
 563  * When 1 is returned, @stream_time resulted in a positive position returned
 564  * in @position.
 565  *
 566  * When this function returns -1, the returned @position should be negated
 567  * to get the real negative segment position.
 568  *
 569  * Returns: a 1 or -1 on success, 0 on failure.
 570  *
 571  * Since: 1.8
 572  */
 573 gint
 574 gst_segment_position_from_stream_time_full (const GstSegment * segment,
 575     GstFormat format, guint64 stream_time, guint64 * position)
 576 {
 577   guint64 start, time;
 578   gdouble abs_applied_rate;
 579   gint res;
 580 
 581   /* format does not matter for -1 */
 582   if (G_UNLIKELY (stream_time == -1)) {
 583     *position = -1;
 584     return 0;
 585   }
 586 
 587   g_return_val_if_fail (segment != NULL, -1);
 588   g_return_val_if_fail (segment-&gt;format == format, -1);
 589 
 590   start = segment-&gt;start;
 591   time = segment-&gt;time;
 592 
 593   /* time must be known */
 594   if (G_UNLIKELY (time == -1))
 595     return 0;
 596 
 597   abs_applied_rate = ABS (segment-&gt;applied_rate);
 598 
 599   if (G_LIKELY (segment-&gt;applied_rate &gt; 0.0)) {
 600     if (G_LIKELY (stream_time &gt; time)) {
 601       res = 1;
 602       *position = stream_time - time;
 603     } else {
 604       res = -1;
 605       *position = time - stream_time;
 606     }
 607     /* correct for applied rate if needed */
 608     if (G_UNLIKELY (abs_applied_rate != 1.0))
 609       *position /= abs_applied_rate;
 610 
 611     if (G_UNLIKELY (res == -1)) {
 612       if (*position &gt; start) {
 613         *position -= start;
 614       } else {
 615         *position = start - *position;
 616         res = 1;
 617       }
 618     } else {
 619       *position += start;
 620     }
 621   } else {
 622     GstClockTime stop = segment-&gt;stop;
 623     /* cannot continue without a known segment stop */
 624     if (G_UNLIKELY (stop == -1))
 625       return 0;
 626     if (G_UNLIKELY (time &gt; stream_time)) {
 627       res = -1;
 628       *position = time - stream_time;
 629     } else {
 630       res = 1;
 631       *position = stream_time - time;
 632     }
 633     if (G_UNLIKELY (abs_applied_rate != 1.0))
 634       *position /= abs_applied_rate;
 635     if (G_UNLIKELY (stop &lt; *position)) {
 636       if (G_LIKELY (res == 1)) {
 637         *position -= stop;
 638         res = -1;
 639       } else {
 640         *position += stop;
 641         res = 1;
 642       }
 643     } else {
 644       if (G_LIKELY (res == 1)) {
 645         *position = stop - *position;
 646         res = 1;
 647       } else {
 648         *position += stop;
 649         res = 1;
 650       }
 651     }
 652   }
 653 
 654   return res;
 655 }
 656 
 657 /**
 658  * gst_segment_position_from_stream_time:
 659  * @segment: a #GstSegment structure.
 660  * @format: the format of the segment.
 661  * @stream_time: the stream_time in the segment
 662  *
 663  * Convert @stream_time into a position in the segment so that
 664  * gst_segment_to_stream_time() with that position returns @stream_time.
 665  *
 666  * Returns: the position in the segment for @stream_time. This function returns
 667  * -1 when @stream_time is -1 or when it is not inside @segment.
 668  *
 669  * Since: 1.8
 670  */
 671 guint64
 672 gst_segment_position_from_stream_time (const GstSegment * segment,
 673     GstFormat format, guint64 stream_time)
 674 {
 675   guint64 position;
 676   gint res;
 677 
 678   g_return_val_if_fail (segment != NULL, -1);
 679   g_return_val_if_fail (segment-&gt;format == format, -1);
 680 
 681   res =
 682       gst_segment_position_from_stream_time_full (segment, format, stream_time,
 683       &amp;position);
 684 
 685   /* before the segment boundary */
 686   if (G_UNLIKELY (position &lt; segment-&gt;start)) {
 687     GST_DEBUG (&quot;position(%&quot; G_GUINT64_FORMAT &quot;) &lt; start(%&quot; G_GUINT64_FORMAT
 688         &quot;)&quot;, position, segment-&gt;start);
 689     return -1;
 690   }
 691 
 692   /* after the segment boundary */
 693   if (G_UNLIKELY (segment-&gt;stop != -1 &amp;&amp; position &gt; segment-&gt;stop)) {
 694     GST_DEBUG (&quot;position(%&quot; G_GUINT64_FORMAT &quot;) &gt; stop(%&quot; G_GUINT64_FORMAT
 695         &quot;)&quot;, position, segment-&gt;stop);
 696     return -1;
 697   }
 698 
 699   if (res == 1)
 700     return position;
 701 
<a name="2" id="anc2"></a><span class="line-modified"> 702   return -1;</span>
 703 }
 704 
 705 /**
 706  * gst_segment_to_running_time_full:
 707  * @segment: a #GstSegment structure.
 708  * @format: the format of the segment.
 709  * @position: the position in the segment
 710  * @running_time: (out) (allow-none): result running-time
 711  *
 712  * Translate @position to the total running time using the currently configured
 713  * segment. Compared to gst_segment_to_running_time() this function can return
 714  * negative running-time.
 715  *
 716  * This function is typically used by elements that need to synchronize buffers
<a name="3" id="anc3"></a><span class="line-modified"> 717  * against the clock or each other.</span>
 718  *
 719  * @position can be any value and the result of this function for values outside
 720  * of the segment is extrapolated.
 721  *
 722  * When 1 is returned, @position resulted in a positive running-time returned
 723  * in @running_time.
 724  *
 725  * When this function returns -1, the returned @running_time should be negated
 726  * to get the real negative running time.
 727  *
 728  * Returns: a 1 or -1 on success, 0 on failure.
 729  *
 730  * Since: 1.6
 731  */
 732 gint
 733 gst_segment_to_running_time_full (const GstSegment * segment, GstFormat format,
 734     guint64 position, guint64 * running_time)
 735 {
 736   gint res = 0;
 737   guint64 result;
 738   guint64 start, stop, offset;
 739   gdouble abs_rate;
 740 
 741   if (G_UNLIKELY (position == -1)) {
 742     GST_DEBUG (&quot;invalid position (-1)&quot;);
 743     goto done;
 744   }
 745 
 746   g_return_val_if_fail (segment != NULL, 0);
 747   g_return_val_if_fail (segment-&gt;format == format, 0);
 748 
 749   offset = segment-&gt;offset;
 750 
 751   if (G_LIKELY (segment-&gt;rate &gt; 0.0)) {
 752     start = segment-&gt;start + offset;
 753 
<a name="4" id="anc4"></a><span class="line-modified"> 754     /* bring to uncorrected position in segment */</span>
 755     if (position &lt; start) {
 756       /* negative value */
 757       result = start - position;
 758       res = -1;
 759     } else {
<a name="5" id="anc5"></a><span class="line-modified"> 760       result = position - start;</span>
 761       res = 1;
 762     }
 763   } else {
 764     stop = segment-&gt;stop;
 765 
<a name="6" id="anc6"></a><span class="line-added"> 766     if (stop == -1 &amp;&amp; segment-&gt;duration != -1)</span>
<span class="line-added"> 767       stop = segment-&gt;start + segment-&gt;duration;</span>
<span class="line-added"> 768 </span>
 769     /* cannot continue if no stop position set or invalid offset */
 770     g_return_val_if_fail (stop != -1, 0);
 771     g_return_val_if_fail (stop &gt;= offset, 0);
 772 
 773     stop -= offset;
 774 
 775     /* bring to uncorrected position in segment */
 776     if (position &gt; stop) {
 777       /* negative value */
 778       result = position - stop;
 779       res = -1;
<a name="7" id="anc7"></a><span class="line-modified"> 780     } else {</span>
 781       result = stop - position;
 782       res = 1;
<a name="8" id="anc8"></a><span class="line-modified"> 783     }</span>
 784   }
 785 
 786   if (running_time) {
 787     /* scale based on the rate, avoid division by and conversion to
 788      * float when not needed */
 789     abs_rate = ABS (segment-&gt;rate);
 790     if (G_UNLIKELY (abs_rate != 1.0))
 791       result /= abs_rate;
 792 
 793     /* correct for base of the segment */
 794     if (res == 1)
 795       /* positive, add base */
 796       *running_time = result + segment-&gt;base;
 797     else if (segment-&gt;base &gt;= result) {
 798       /* negative and base is bigger, subtract from base and we have a
 799        * positive value again */
 800       *running_time = segment-&gt;base - result;
 801       res = 1;
 802     } else {
 803       /* negative and base is smaller, subtract base and remainder is
 804        * negative */
 805       *running_time = result - segment-&gt;base;
<a name="9" id="anc9"></a><span class="line-modified"> 806     }</span>
 807   }
 808   return res;
 809 
 810 done:
 811   {
 812     if (running_time)
 813       *running_time = -1;
 814     return 0;
 815   }
 816 }
 817 
 818 /**
 819  * gst_segment_to_running_time:
 820  * @segment: a #GstSegment structure.
 821  * @format: the format of the segment.
 822  * @position: the position in the segment
 823  *
 824  * Translate @position to the total running time using the currently configured
 825  * segment. Position is a value between @segment start and stop time.
 826  *
 827  * This function is typically used by elements that need to synchronize to the
 828  * global clock in a pipeline. The running time is a constantly increasing value
 829  * starting from 0. When gst_segment_init() is called, this value will reset to
 830  * 0.
 831  *
 832  * This function returns -1 if the position is outside of @segment start and stop.
 833  *
 834  * Returns: the position as the total running time or -1 when an invalid position
 835  * was given.
 836  */
 837 guint64
 838 gst_segment_to_running_time (const GstSegment * segment, GstFormat format,
 839     guint64 position)
 840 {
 841   guint64 result;
 842 
 843 #ifdef GSTREAMER_LITE
 844   if (segment-&gt;format != format)
 845     return -1;
 846 #endif // GSTREAMER_LITE
 847 
 848   g_return_val_if_fail (segment != NULL, -1);
 849   g_return_val_if_fail (segment-&gt;format == format, -1);
 850 
 851   /* before the segment boundary */
 852   if (G_UNLIKELY (position &lt; segment-&gt;start)) {
 853     GST_DEBUG (&quot;position(%&quot; G_GUINT64_FORMAT &quot;) &lt; start(%&quot; G_GUINT64_FORMAT
 854         &quot;)&quot;, position, segment-&gt;start);
 855     return -1;
 856   }
 857   /* after the segment boundary */
 858   if (G_UNLIKELY (segment-&gt;stop != -1 &amp;&amp; position &gt; segment-&gt;stop)) {
<a name="10" id="anc10"></a><span class="line-modified"> 859     GST_DEBUG (&quot;position(%&quot; G_GUINT64_FORMAT &quot;) &gt; stop(%&quot; G_GUINT64_FORMAT</span>
 860         &quot;)&quot;, position, segment-&gt;stop);
<a name="11" id="anc11"></a><span class="line-modified"> 861     return -1;</span>
<span class="line-modified"> 862   }</span>
 863 
 864   if (gst_segment_to_running_time_full (segment, format, position,
 865           &amp;result) == 1)
 866     return result;
 867 
<a name="12" id="anc12"></a><span class="line-modified"> 868   return -1;</span>
<span class="line-modified"> 869 }</span>
 870 
 871 /**
 872  * gst_segment_clip:
 873  * @segment: a #GstSegment structure.
 874  * @format: the format of the segment.
 875  * @start: the start position in the segment
 876  * @stop: the stop position in the segment
 877  * @clip_start: (out) (allow-none): the clipped start position in the segment
 878  * @clip_stop: (out) (allow-none): the clipped stop position in the segment
 879  *
 880  * Clip the given @start and @stop values to the segment boundaries given
 881  * in @segment. @start and @stop are compared and clipped to @segment
 882  * start and stop values.
 883  *
 884  * If the function returns %FALSE, @start and @stop are known to fall
 885  * outside of @segment and @clip_start and @clip_stop are not updated.
 886  *
 887  * When the function returns %TRUE, @clip_start and @clip_stop will be
 888  * updated. If @clip_start or @clip_stop are different from @start or @stop
 889  * respectively, the region fell partially in the segment.
 890  *
 891  * Note that when @stop is -1, @clip_stop will be set to the end of the
 892  * segment. Depending on the use case, this may or may not be what you want.
 893  *
 894  * Returns: %TRUE if the given @start and @stop times fall partially or
 895  *     completely in @segment, %FALSE if the values are completely outside
 896  *     of the segment.
 897  */
 898 gboolean
 899 gst_segment_clip (const GstSegment * segment, GstFormat format, guint64 start,
 900     guint64 stop, guint64 * clip_start, guint64 * clip_stop)
 901 {
 902   g_return_val_if_fail (segment != NULL, FALSE);
 903   g_return_val_if_fail (segment-&gt;format == format, FALSE);
 904 
 905   /* if we have a stop position and a valid start and start is bigger,
 906    * we&#39;re outside of the segment. (Special case) segment start and
 907    * segment stop can be identical. In this case, if start is also identical,
 908    * it&#39;s inside of segment */
 909   if (G_UNLIKELY (segment-&gt;stop != -1 &amp;&amp; start != -1 &amp;&amp; (start &gt; segment-&gt;stop
 910               || (segment-&gt;start != segment-&gt;stop &amp;&amp; start == segment-&gt;stop))))
 911     return FALSE;
 912 
 913   /* if a stop position is given and is before the segment start,
 914    * we&#39;re outside of the segment. Special case is were start
 915    * and stop are equal to the segment start. In that case we
 916    * are inside the segment. */
 917   if (G_UNLIKELY (stop != -1 &amp;&amp; (stop &lt; segment-&gt;start || (start != stop
 918                   &amp;&amp; stop == segment-&gt;start))))
 919     return FALSE;
 920 
 921   if (clip_start) {
 922     if (start == -1)
 923       *clip_start = -1;
 924     else
 925       *clip_start = MAX (start, segment-&gt;start);
 926   }
 927 
 928   if (clip_stop) {
 929     if (stop == -1)
 930       *clip_stop = segment-&gt;stop;
 931     else if (segment-&gt;stop == -1)
 932       *clip_stop = stop;
 933     else
 934       *clip_stop = MIN (stop, segment-&gt;stop);
 935   }
 936 
 937   return TRUE;
 938 }
 939 
 940 /**
 941  * gst_segment_position_from_running_time:
 942  * @segment: a #GstSegment structure.
 943  * @format: the format of the segment.
 944  * @running_time: the running_time in the segment
 945  *
 946  * Convert @running_time into a position in the segment so that
 947  * gst_segment_to_running_time() with that position returns @running_time.
 948  *
 949  * Returns: the position in the segment for @running_time. This function returns
 950  * -1 when @running_time is -1 or when it is not inside @segment.
 951  *
 952  * Since: 1.8
 953  */
 954 guint64
 955 gst_segment_position_from_running_time (const GstSegment * segment,
 956     GstFormat format, guint64 running_time)
 957 {
 958   guint64 position;
 959   gint res;
 960 
 961   g_return_val_if_fail (segment != NULL, -1);
 962   g_return_val_if_fail (segment-&gt;format == format, -1);
 963 
 964   res =
 965       gst_segment_position_from_running_time_full (segment, format,
 966       running_time, &amp;position);
 967 
 968   if (res != 1)
 969     return -1;
 970 
 971   /* before the segment boundary */
 972   if (G_UNLIKELY (position &lt; segment-&gt;start)) {
 973     GST_DEBUG (&quot;position(%&quot; G_GUINT64_FORMAT &quot;) &lt; start(%&quot; G_GUINT64_FORMAT
 974         &quot;)&quot;, position, segment-&gt;start);
 975     return -1;
 976   }
 977 
 978   /* after the segment boundary */
 979   if (G_UNLIKELY (segment-&gt;stop != -1 &amp;&amp; position &gt; segment-&gt;stop)) {
 980     GST_DEBUG (&quot;position(%&quot; G_GUINT64_FORMAT &quot;) &gt; stop(%&quot; G_GUINT64_FORMAT
 981         &quot;)&quot;, position, segment-&gt;stop);
 982     return -1;
 983   }
 984 
 985   return position;
 986 }
 987 
 988 /**
 989  * gst_segment_position_from_running_time_full:
 990  * @segment: a #GstSegment structure.
 991  * @format: the format of the segment.
 992  * @running_time: the running-time
 993  * @position: (out): the resulting position in the segment
 994  *
 995  * Translate @running_time to the segment position using the currently configured
 996  * segment. Compared to gst_segment_position_from_running_time() this function can
 997  * return negative segment position.
 998  *
 999  * This function is typically used by elements that need to synchronize buffers
1000  * against the clock or each other.
1001  *
1002  * @running_time can be any value and the result of this function for values
1003  * outside of the segment is extrapolated.
1004  *
1005  * When 1 is returned, @running_time resulted in a positive position returned
1006  * in @position.
1007  *
1008  * When this function returns -1, the returned @position was &lt; 0, and the value
1009  * in the position variable should be negated to get the real negative segment
1010  * position.
1011  *
1012  * Returns: a 1 or -1 on success, 0 on failure.
1013  *
1014  * Since: 1.8
1015  */
1016 gint
1017 gst_segment_position_from_running_time_full (const GstSegment * segment,
1018     GstFormat format, guint64 running_time, guint64 * position)
1019 {
1020   gint res;
1021   guint64 start, stop, base;
1022   gdouble abs_rate;
1023 
1024   if (G_UNLIKELY (running_time == -1)) {
1025     *position = -1;
1026     return 0;
1027   }
1028 
1029   g_return_val_if_fail (segment != NULL, 0);
1030   g_return_val_if_fail (segment-&gt;format == format, 0);
1031 
1032   base = segment-&gt;base;
1033 
1034   abs_rate = ABS (segment-&gt;rate);
1035 
1036   start = segment-&gt;start;
1037   stop = segment-&gt;stop;
1038 
1039   if (G_LIKELY (segment-&gt;rate &gt; 0.0)) {
1040     /* start by subtracting the base time */
1041     if (G_LIKELY (running_time &gt;= base)) {
1042       *position = running_time - base;
1043       /* move into the segment at the right rate */
1044       if (G_UNLIKELY (abs_rate != 1.0))
1045         *position = ceil (*position * abs_rate);
<a name="13" id="anc13"></a><span class="line-modified">1046       /* bring to corrected position in segment */</span>
1047       *position += start + segment-&gt;offset;
1048       res = 1;
<a name="14" id="anc14"></a><span class="line-modified">1049     } else {</span>
1050       *position = base - running_time;
1051       if (G_UNLIKELY (abs_rate != 1.0))
1052         *position = ceil (*position * abs_rate);
1053       if (start + segment-&gt;offset &gt;= *position) {
1054         /* The TS is before the segment, but the result is &gt;= 0 */
1055         *position = start + segment-&gt;offset - *position;
1056         res = 1;
1057       } else {
1058         /* The TS is before the segment, and the result is &lt; 0
1059          * so negate the return result */
1060         *position = *position - (start + segment-&gt;offset);
1061         res = -1;
<a name="15" id="anc15"></a><span class="line-modified">1062       }</span>
<span class="line-modified">1063     }</span>
1064   } else {
1065     if (G_LIKELY (running_time &gt;= base)) {
1066       *position = running_time - base;
1067       if (G_UNLIKELY (abs_rate != 1.0))
1068         *position = ceil (*position * abs_rate);
1069       if (G_UNLIKELY (stop &lt; *position + segment-&gt;offset)) {
1070         *position += segment-&gt;offset - stop;
1071         res = -1;
1072       } else {
1073         *position = stop - *position - segment-&gt;offset;
1074         res = 1;
1075       }
1076     } else {
1077       /* This case is tricky. Requested running time precedes the
1078        * segment base, so in a reversed segment where rate &lt; 0, that
1079        * means it&#39;s before the alignment point of (stop - offset).
1080        * Before = always bigger than (stop-offset), which is usually +ve,
1081        * but could be -ve is offset is big enough. -ve position implies
1082        * that the offset has clipped away the entire segment anyway */
1083       *position = base - running_time;
1084       if (G_UNLIKELY (abs_rate != 1.0))
1085         *position = ceil (*position * abs_rate);
1086 
1087       if (G_LIKELY (stop + *position &gt;= segment-&gt;offset)) {
1088         *position = stop + *position - segment-&gt;offset;
1089         res = 1;
1090       } else {
1091         /* Requested position is still negative because offset is big,
1092          * so negate the result */
1093         *position = segment-&gt;offset - *position - stop;
1094         res = -1;
1095       }
1096     }
1097   }
1098   return res;
1099 }
1100 
1101 /**
1102  * gst_segment_to_position:
1103  * @segment: a #GstSegment structure.
1104  * @format: the format of the segment.
1105  * @running_time: the running_time in the segment
1106  *
1107  * Convert @running_time into a position in the segment so that
1108  * gst_segment_to_running_time() with that position returns @running_time.
1109  *
1110  * Returns: the position in the segment for @running_time. This function returns
1111  * -1 when @running_time is -1 or when it is not inside @segment.
1112  *
1113  * Deprecated: Use gst_segment_position_from_running_time() instead.
1114  */
1115 #ifndef GST_REMOVE_DEPRECATED
1116 guint64
1117 gst_segment_to_position (const GstSegment * segment, GstFormat format,
1118     guint64 running_time)
1119 {
1120   return gst_segment_position_from_running_time (segment, format, running_time);
1121 }
1122 #endif
1123 
1124 /**
1125  * gst_segment_set_running_time:
1126  * @segment: a #GstSegment structure.
1127  * @format: the format of the segment.
1128  * @running_time: the running_time in the segment
1129  *
1130  * Adjust the start/stop and base values of @segment such that the next valid
1131  * buffer will be one with @running_time.
1132  *
1133  * Returns: %TRUE if the segment could be updated successfully. If %FALSE is
1134  * returned, @running_time is -1 or not in @segment.
1135  */
1136 gboolean
1137 gst_segment_set_running_time (GstSegment * segment, GstFormat format,
1138     guint64 running_time)
1139 {
1140   guint64 position;
1141   guint64 start, stop;
1142 
1143   /* start by bringing the running_time into the segment position */
1144   position =
1145       gst_segment_position_from_running_time (segment, format, running_time);
1146 
1147   /* we must have a valid position now */
1148   if (G_UNLIKELY (position == -1))
1149     return FALSE;
1150 
1151   start = segment-&gt;start;
1152   stop = segment-&gt;stop;
1153 
1154   if (G_LIKELY (segment-&gt;rate &gt; 0.0)) {
1155     /* update the start and time values */
1156     start = position;
1157   } else {
1158     /* reverse, update stop */
1159     stop = position;
1160   }
1161   /* and base time is exactly the running time */
1162   segment-&gt;time = gst_segment_to_stream_time (segment, format, start);
1163   segment-&gt;start = start;
1164   segment-&gt;stop = stop;
1165   segment-&gt;base = running_time;
1166 
1167   return TRUE;
1168 }
1169 
1170 /**
1171  * gst_segment_offset_running_time:
1172  * @segment: a #GstSegment structure.
1173  * @format: the format of the segment.
1174  * @offset: the offset to apply in the segment
1175  *
1176  * Adjust the values in @segment so that @offset is applied to all
1177  * future running-time calculations.
1178  *
1179  * Since: 1.2.3
1180  *
1181  * Returns: %TRUE if the segment could be updated successfully. If %FALSE is
1182  * returned, @offset is not in @segment.
1183  */
1184 gboolean
1185 gst_segment_offset_running_time (GstSegment * segment, GstFormat format,
1186     gint64 offset)
1187 {
1188   g_return_val_if_fail (segment != NULL, FALSE);
1189   g_return_val_if_fail (segment-&gt;format == format, FALSE);
1190 
1191   if (offset == 0)
1192     return TRUE;
1193 
1194   if (offset &gt; 0) {
1195     /* positive offset, we can simply apply to the base time */
1196     segment-&gt;base += offset;
1197   } else {
1198     offset = -offset;
1199     /* negative offset, first try to subtract from base */
1200     if (segment-&gt;base &gt; offset) {
1201       segment-&gt;base -= offset;
1202     } else {
1203       guint64 position;
1204 
1205       /* subtract all from segment.base, remainder in offset */
1206       offset -= segment-&gt;base;
1207       segment-&gt;base = 0;
1208       position =
1209           gst_segment_position_from_running_time (segment, format, offset);
1210       if (position == -1)
1211         return FALSE;
1212 
1213       segment-&gt;offset = position - segment-&gt;start;
1214     }
1215   }
1216   return TRUE;
1217 }
1218 
1219 /**
1220  * gst_segment_is_equal:
1221  * @s0: a #GstSegment structure.
1222  * @s1: a #GstSegment structure.
1223  *
1224  * Checks for two segments being equal. Equality here is defined
1225  * as perfect equality, including floating point values.
1226  *
1227  * Since: 1.6
1228  *
1229  * Returns: %TRUE if the segments are equal, %FALSE otherwise.
1230  */
1231 gboolean
1232 gst_segment_is_equal (const GstSegment * s0, const GstSegment * s1)
1233 {
1234   if (s0-&gt;flags != s1-&gt;flags)
1235     return FALSE;
1236   if (s0-&gt;rate != s1-&gt;rate)
1237     return FALSE;
1238   if (s0-&gt;applied_rate != s1-&gt;applied_rate)
1239     return FALSE;
1240   if (s0-&gt;format != s1-&gt;format)
1241     return FALSE;
1242   if (s0-&gt;base != s1-&gt;base)
1243     return FALSE;
1244   if (s0-&gt;offset != s1-&gt;offset)
1245     return FALSE;
1246   if (s0-&gt;start != s1-&gt;start)
1247     return FALSE;
1248   if (s0-&gt;stop != s1-&gt;stop)
1249     return FALSE;
1250   if (s0-&gt;time != s1-&gt;time)
1251     return FALSE;
1252   if (s0-&gt;position != s1-&gt;position)
1253     return FALSE;
1254   if (s0-&gt;duration != s1-&gt;duration)
1255     return FALSE;
1256   return TRUE;
1257 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>