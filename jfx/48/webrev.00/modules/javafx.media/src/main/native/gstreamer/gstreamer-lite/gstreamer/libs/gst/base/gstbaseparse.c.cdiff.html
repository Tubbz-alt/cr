<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstbaseparse.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstadapter.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstbaseparse.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstbaseparse.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 45,81 ***</span>
   *
   * # Description of the parsing mechanism:
   *
   * ## Set-up phase
   *
<span class="line-modified">!  *  * #GstBaseParse calls @start to inform subclass that data processing is</span>
<span class="line-modified">!  *    about to start now.</span>
   *
<span class="line-modified">!  *  * #GstBaseParse class calls @set_sink_caps to inform the subclass about</span>
<span class="line-modified">!  *    incoming sinkpad caps. Subclass could already set the srcpad caps</span>
<span class="line-modified">!  *    accordingly, but this might be delayed until calling</span>
<span class="line-modified">!  *    gst_base_parse_finish_frame() with a non-queued frame.</span>
   *
   *  * At least at this point subclass needs to tell the #GstBaseParse class
<span class="line-modified">!  *    how big data chunks it wants to receive (min_frame_size). It can do</span>
<span class="line-modified">!  *    this with gst_base_parse_set_min_frame_size().</span>
   *
   *  * #GstBaseParse class sets up appropriate data passing mode (pull/push)
   *    and starts to process the data.
   *
   * ## Parsing phase
   *
   *  * #GstBaseParse gathers at least min_frame_size bytes of data either
   *    by pulling it from upstream or collecting buffers in an internal
   *    #GstAdapter.
   *
<span class="line-modified">!  *  * A buffer of (at least) min_frame_size bytes is passed to subclass with</span>
<span class="line-modified">!  *    @handle_frame. Subclass checks the contents and can optionally</span>
<span class="line-modified">!  *    return GST_FLOW_OK along with an amount of data to be skipped to find</span>
<span class="line-modified">!  *    a valid frame (which will result in a subsequent DISCONT).</span>
<span class="line-modified">!  *    If, otherwise, the buffer does not hold a complete frame,</span>
<span class="line-modified">!  *    @handle_frame can merely return and will be called again when additional</span>
<span class="line-modified">!  *    data is available.  In push mode this amounts to an</span>
<span class="line-modified">!  *    additional input buffer (thus minimal additional latency), in pull mode</span>
<span class="line-modified">!  *    this amounts to some arbitrary reasonable buffer size increase.</span>
<span class="line-modified">!  *    Of course, gst_base_parse_set_min_frame_size() could also be used if a</span>
<span class="line-modified">!  *    very specific known amount of additional data is required.</span>
<span class="line-modified">!  *    If, however, the buffer holds a complete valid frame, it can pass</span>
<span class="line-modified">!  *    the size of this frame to gst_base_parse_finish_frame().</span>
<span class="line-modified">!  *    If acting as a converter, it can also merely indicate consumed input data</span>
<span class="line-modified">!  *    while simultaneously providing custom output data.</span>
<span class="line-modified">!  *    Note that baseclass performs some processing (such as tracking</span>
<span class="line-modified">!  *    overall consumed data rate versus duration) for each finished frame,</span>
<span class="line-modified">!  *    but other state is only updated upon each call to @handle_frame</span>
   *    (such as tracking upstream input timestamp).
   *
   *    Subclass is also responsible for setting the buffer metadata
   *    (e.g. buffer timestamp and duration, or keyframe if applicable).
   *    (although the latter can also be done by #GstBaseParse if it is
   *    appropriately configured, see below).  Frame is provided with
   *    timestamp derived from upstream (as much as generally possible),
   *    duration obtained from configuration (see below), and offset
   *    if meaningful (in pull mode).
   *
<span class="line-modified">!  *    Note that @check_valid_frame might receive any small</span>
<span class="line-modified">!  *    amount of input data when leftover data is being drained (e.g. at EOS).</span>
   *
<span class="line-modified">!  *  * As part of finish frame processing,</span>
<span class="line-modified">!  *    just prior to actually pushing the buffer in question,</span>
<span class="line-modified">!  *    it is passed to @pre_push_frame which gives subclass yet one</span>
<span class="line-modified">!  *    last chance to examine buffer metadata, or to send some custom (tag)</span>
   *    events, or to perform custom (segment) filtering.
   *
   *  * During the parsing process #GstBaseParseClass will handle both srcpad
<span class="line-modified">!  *    and sinkpad events. They will be passed to subclass if @event or</span>
<span class="line-modified">!  *    @src_event callbacks have been provided.</span>
   *
   * ## Shutdown phase
   *
<span class="line-modified">!  * * #GstBaseParse class calls @stop to inform the subclass that data</span>
<span class="line-modified">!  *   parsing will be stopped.</span>
   *
<span class="line-modified">!  * Subclass is responsible for providing pad template caps for</span>
<span class="line-modified">!  * source and sink pads. The pads need to be named &quot;sink&quot; and &quot;src&quot;. It also</span>
<span class="line-modified">!  * needs to set the fixed caps on srcpad, when the format is ensured (e.g.</span>
<span class="line-modified">!  * when base class calls subclass&#39; @set_sink_caps function).</span>
   *
   * This base class uses %GST_FORMAT_DEFAULT as a meaning of frames. So,
   * subclass conversion routine needs to know that conversion from
   * %GST_FORMAT_TIME to %GST_FORMAT_DEFAULT must return the
   * frame number that can be found from the given byte position.
<span class="line-new-header">--- 45,86 ---</span>
   *
   * # Description of the parsing mechanism:
   *
   * ## Set-up phase
   *
<span class="line-modified">!  *  * #GstBaseParse calls #GstBaseParseClass.start() to inform subclass</span>
<span class="line-modified">!  *    that data processing is about to start now.</span>
   *
<span class="line-modified">!  *  * #GstBaseParse class calls #GstBaseParseClass.set_sink_caps() to</span>
<span class="line-modified">!  *    inform the subclass about incoming sinkpad caps. Subclass could</span>
<span class="line-modified">!  *    already set the srcpad caps accordingly, but this might be delayed</span>
<span class="line-modified">!  *    until calling gst_base_parse_finish_frame() with a non-queued frame.</span>
   *
   *  * At least at this point subclass needs to tell the #GstBaseParse class
<span class="line-modified">!  *    how big data chunks it wants to receive (minimum frame size ). It can</span>
<span class="line-modified">!  *    do this with gst_base_parse_set_min_frame_size().</span>
   *
   *  * #GstBaseParse class sets up appropriate data passing mode (pull/push)
   *    and starts to process the data.
   *
   * ## Parsing phase
   *
   *  * #GstBaseParse gathers at least min_frame_size bytes of data either
   *    by pulling it from upstream or collecting buffers in an internal
   *    #GstAdapter.
   *
<span class="line-modified">!  *  * A buffer of (at least) min_frame_size bytes is passed to subclass</span>
<span class="line-modified">!  *    with #GstBaseParseClass.handle_frame(). Subclass checks the contents</span>
<span class="line-modified">!  *    and can optionally return #GST_FLOW_OK along with an amount of data</span>
<span class="line-modified">!  *    to be skipped to find a valid frame (which will result in a</span>
<span class="line-modified">!  *    subsequent DISCONT).  If, otherwise, the buffer does not hold a</span>
<span class="line-modified">!  *    complete frame, #GstBaseParseClass.handle_frame() can merely return</span>
<span class="line-modified">!  *    and will be called again when additional data is available.  In push</span>
<span class="line-modified">!  *    mode this amounts to an additional input buffer (thus minimal</span>
<span class="line-modified">!  *    additional latency), in pull mode this amounts to some arbitrary</span>
<span class="line-modified">!  *    reasonable buffer size increase.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  *    Of course, gst_base_parse_set_min_frame_size() could also be used if</span>
<span class="line-modified">!  *    a very specific known amount of additional data is required.  If,</span>
<span class="line-modified">!  *    however, the buffer holds a complete valid frame, it can pass the</span>
<span class="line-modified">!  *    size of this frame to gst_base_parse_finish_frame().</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  *    If acting as a converter, it can also merely indicate consumed input</span>
<span class="line-modified">!  *    data while simultaneously providing custom output data.  Note that</span>
<span class="line-added">+  *    baseclass performs some processing (such as tracking overall consumed</span>
<span class="line-added">+  *    data rate versus duration) for each finished frame, but other state</span>
<span class="line-added">+  *    is only updated upon each call to #GstBaseParseClass.handle_frame()</span>
   *    (such as tracking upstream input timestamp).
   *
   *    Subclass is also responsible for setting the buffer metadata
   *    (e.g. buffer timestamp and duration, or keyframe if applicable).
   *    (although the latter can also be done by #GstBaseParse if it is
   *    appropriately configured, see below).  Frame is provided with
   *    timestamp derived from upstream (as much as generally possible),
   *    duration obtained from configuration (see below), and offset
   *    if meaningful (in pull mode).
   *
<span class="line-modified">!  *    Note that #GstBaseParseClass.handle_frame() might receive any small</span>
<span class="line-modified">!  *    amount of input data when leftover data is being drained (e.g. at</span>
<span class="line-added">+  *    EOS).</span>
   *
<span class="line-modified">!  *  * As part of finish frame processing, just prior to actually pushing</span>
<span class="line-modified">!  *    the buffer in question, it is passed to</span>
<span class="line-modified">!  *    #GstBaseParseClass.pre_push_frame() which gives subclass yet one last</span>
<span class="line-modified">!  *    chance to examine buffer metadata, or to send some custom (tag)</span>
   *    events, or to perform custom (segment) filtering.
   *
   *  * During the parsing process #GstBaseParseClass will handle both srcpad
<span class="line-modified">!  *    and sinkpad events. They will be passed to subclass if</span>
<span class="line-modified">!  *    #GstBaseParseClass.event() or #GstBaseParseClass.src_event()</span>
<span class="line-added">+  *    implementations have been provided.</span>
   *
   * ## Shutdown phase
   *
<span class="line-modified">!  * * #GstBaseParse class calls #GstBaseParseClass.stop() to inform the</span>
<span class="line-modified">!  *   subclass that data parsing will be stopped.</span>
   *
<span class="line-modified">!  * Subclass is responsible for providing pad template caps for source and</span>
<span class="line-modified">!  * sink pads. The pads need to be named &quot;sink&quot; and &quot;src&quot;. It also needs to</span>
<span class="line-modified">!  * set the fixed caps on srcpad, when the format is ensured (e.g.  when</span>
<span class="line-modified">!  * base class calls subclass&#39; #GstBaseParseClass.set_sink_caps() function).</span>
   *
   * This base class uses %GST_FORMAT_DEFAULT as a meaning of frames. So,
   * subclass conversion routine needs to know that conversion from
   * %GST_FORMAT_TIME to %GST_FORMAT_DEFAULT must return the
   * frame number that can be found from the given byte position.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 134,29 ***</span>
   *
   * * Provide pad templates
   * * Fixate the source pad caps when appropriate
   * * Inform base class how big data chunks should be retrieved. This is
   *   done with gst_base_parse_set_min_frame_size() function.
<span class="line-modified">!  * * Examine data chunks passed to subclass with @handle_frame and pass</span>
<span class="line-modified">!  *   proper frame(s) to gst_base_parse_finish_frame(), and setting src pad</span>
<span class="line-modified">!  *   caps and timestamps on frame.</span>
   * * Provide conversion functions
   * * Update the duration information with gst_base_parse_set_duration()
   * * Optionally passthrough using gst_base_parse_set_passthrough()
   * * Configure various baseparse parameters using
   *   gst_base_parse_set_average_bitrate(), gst_base_parse_set_syncable()
   *   and gst_base_parse_set_frame_rate().
   *
   * * In particular, if subclass is unable to determine a duration, but
   *   parsing (or specs) yields a frames per seconds rate, then this can be
<span class="line-modified">!  *   provided to #GstBaseParse to enable it to cater for</span>
<span class="line-modified">!  *   buffer time metadata (which will be taken from upstream as much as</span>
   *   possible). Internally keeping track of frame durations and respective
   *   sizes that have been pushed provides #GstBaseParse with an estimated
<span class="line-modified">!  *   bitrate. A default @convert (used if not overridden) will then use these</span>
<span class="line-modified">!  *   rates to perform obvious conversions.  These rates are also used to</span>
<span class="line-modified">!  *   update (estimated) duration at regular frame intervals.</span>
   *
   */
  
  /* TODO:
   *  - In push mode provide a queue of adapter-&quot;queued&quot; buffers for upstream
<span class="line-new-header">--- 139,31 ---</span>
   *
   * * Provide pad templates
   * * Fixate the source pad caps when appropriate
   * * Inform base class how big data chunks should be retrieved. This is
   *   done with gst_base_parse_set_min_frame_size() function.
<span class="line-modified">!  * * Examine data chunks passed to subclass with</span>
<span class="line-modified">!  *   #GstBaseParseClass.handle_frame() and pass proper frame(s) to</span>
<span class="line-modified">!  *   gst_base_parse_finish_frame(), and setting src pad caps and timestamps</span>
<span class="line-added">+  *   on frame.</span>
   * * Provide conversion functions
   * * Update the duration information with gst_base_parse_set_duration()
   * * Optionally passthrough using gst_base_parse_set_passthrough()
   * * Configure various baseparse parameters using
   *   gst_base_parse_set_average_bitrate(), gst_base_parse_set_syncable()
   *   and gst_base_parse_set_frame_rate().
   *
   * * In particular, if subclass is unable to determine a duration, but
   *   parsing (or specs) yields a frames per seconds rate, then this can be
<span class="line-modified">!  *   provided to #GstBaseParse to enable it to cater for buffer time</span>
<span class="line-modified">!  *   metadata (which will be taken from upstream as much as</span>
   *   possible). Internally keeping track of frame durations and respective
   *   sizes that have been pushed provides #GstBaseParse with an estimated
<span class="line-modified">!  *   bitrate. A default #GstBaseParseClass.convert() (used if not</span>
<span class="line-modified">!  *   overridden) will then use these rates to perform obvious conversions.</span>
<span class="line-modified">!  *   These rates are also used to update (estimated) duration at regular</span>
<span class="line-added">+  *   frame intervals.</span>
   *
   */
  
  /* TODO:
   *  - In push mode provide a queue of adapter-&quot;queued&quot; buffers for upstream
</pre>
<hr />
<pre>
<span class="line-old-header">*** 203,13 ***</span>
    GST_FORMAT_BYTES,
    GST_FORMAT_TIME,
    GST_FORMAT_UNDEFINED
  };
  
<span class="line-removed">- #define GST_BASE_PARSE_GET_PRIVATE(obj)  \</span>
<span class="line-removed">-     (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_BASE_PARSE, GstBaseParsePrivate))</span>
<span class="line-removed">- </span>
  struct _GstBaseParsePrivate
  {
    GstPadMode pad_mode;
  
    GstAdapter *adapter;
<span class="line-new-header">--- 210,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 339,10 ***</span>
<span class="line-new-header">--- 343,13 ---</span>
    /* Tag handling (stream tags only, global tags are passed through as-is) */
    GstTagList *upstream_tags;
    GstTagList *parser_tags;
    GstTagMergeMode parser_tags_merge_mode;
    gboolean tags_changed;
<span class="line-added">+ </span>
<span class="line-added">+   /* Current segment seqnum */</span>
<span class="line-added">+   guint32 segment_seqnum;</span>
  };
  
  typedef struct _GstBaseParseSeek
  {
    GstSegment segment;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 364,10 ***</span>
<span class="line-new-header">--- 371,11 ---</span>
    g_mutex_lock (&amp;parse-&gt;priv-&gt;index_lock);
  #define GST_BASE_PARSE_INDEX_UNLOCK(parse) \
    g_mutex_unlock (&amp;parse-&gt;priv-&gt;index_lock);
  
  static GstElementClass *parent_class = NULL;
<span class="line-added">+ static gint base_parse_private_offset = 0;</span>
  
  static void gst_base_parse_class_init (GstBaseParseClass * klass);
  static void gst_base_parse_init (GstBaseParse * parse,
      GstBaseParseClass * klass);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 390,15 ***</span>
<span class="line-new-header">--- 398,25 ---</span>
      };
      GType _type;
  
      _type = g_type_register_static (GST_TYPE_ELEMENT,
          &quot;GstBaseParse&quot;, &amp;base_parse_info, G_TYPE_FLAG_ABSTRACT);
<span class="line-added">+ </span>
<span class="line-added">+     base_parse_private_offset =</span>
<span class="line-added">+         g_type_add_instance_private (_type, sizeof (GstBaseParsePrivate));</span>
<span class="line-added">+ </span>
      g_once_init_leave (&amp;base_parse_type, _type);
    }
    return (GType) base_parse_type;
  }
  
<span class="line-added">+ static inline GstBaseParsePrivate *</span>
<span class="line-added">+ gst_base_parse_get_instance_private (GstBaseParse * self)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   return (G_STRUCT_MEMBER_P (self, base_parse_private_offset));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static void gst_base_parse_finalize (GObject * object);
  
  static GstStateChangeReturn gst_base_parse_change_state (GstElement * element,
      GstStateChange transition);
  static void gst_base_parse_reset (GstBaseParse * parse);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 524,11 ***</span>
  {
    GObjectClass *gobject_class;
    GstElementClass *gstelement_class;
  
    gobject_class = G_OBJECT_CLASS (klass);
<span class="line-modified">!   g_type_class_add_private (klass, sizeof (GstBaseParsePrivate));</span>
    parent_class = g_type_class_peek_parent (klass);
  
    gobject_class-&gt;finalize = GST_DEBUG_FUNCPTR (gst_base_parse_finalize);
    gobject_class-&gt;set_property = GST_DEBUG_FUNCPTR (gst_base_parse_set_property);
    gobject_class-&gt;get_property = GST_DEBUG_FUNCPTR (gst_base_parse_get_property);
<span class="line-new-header">--- 542,14 ---</span>
  {
    GObjectClass *gobject_class;
    GstElementClass *gstelement_class;
  
    gobject_class = G_OBJECT_CLASS (klass);
<span class="line-modified">! </span>
<span class="line-added">+   if (base_parse_private_offset != 0)</span>
<span class="line-added">+     g_type_class_adjust_private_offset (klass, &amp;base_parse_private_offset);</span>
<span class="line-added">+ </span>
    parent_class = g_type_class_peek_parent (klass);
  
    gobject_class-&gt;finalize = GST_DEBUG_FUNCPTR (gst_base_parse_finalize);
    gobject_class-&gt;set_property = GST_DEBUG_FUNCPTR (gst_base_parse_set_property);
    gobject_class-&gt;get_property = GST_DEBUG_FUNCPTR (gst_base_parse_get_property);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 574,11 ***</span>
  {
    GstPadTemplate *pad_template;
  
    GST_DEBUG_OBJECT (parse, &quot;gst_base_parse_init&quot;);
  
<span class="line-modified">!   parse-&gt;priv = GST_BASE_PARSE_GET_PRIVATE (parse);</span>
  
    pad_template =
        gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;sink&quot;);
    g_return_if_fail (pad_template != NULL);
    parse-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
<span class="line-new-header">--- 595,11 ---</span>
  {
    GstPadTemplate *pad_template;
  
    GST_DEBUG_OBJECT (parse, &quot;gst_base_parse_init&quot;);
  
<span class="line-modified">!   parse-&gt;priv = gst_base_parse_get_instance_private (parse);</span>
  
    pad_template =
        gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;sink&quot;);
    g_return_if_fail (pad_template != NULL);
    parse-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 624,10 ***</span>
<span class="line-new-header">--- 645,11 ---</span>
    GST_OBJECT_FLAG_SET (parse, GST_ELEMENT_FLAG_INDEXABLE);
  
    parse-&gt;priv-&gt;upstream_tags = NULL;
    parse-&gt;priv-&gt;parser_tags = NULL;
    parse-&gt;priv-&gt;parser_tags_merge_mode = GST_TAG_MERGE_APPEND;
<span class="line-added">+   parse-&gt;priv-&gt;disable_passthrough = DEFAULT_DISABLE_PASSTHROUGH;</span>
  }
  
  static void
  gst_base_parse_set_property (GObject * object, guint prop_id,
      const GValue * value, GParamSpec * pspec)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 658,10 ***</span>
<span class="line-new-header">--- 680,19 ---</span>
        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
        break;
    }
  }
  
<span class="line-added">+ /**</span>
<span class="line-added">+  * gst_base_parse_frame_copy:</span>
<span class="line-added">+  * @frame: a #GstBaseParseFrame</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Copies a #GstBaseParseFrame.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Returns: A copy of @frame</span>
<span class="line-added">+  */</span>
<span class="line-added">+ </span>
  GstBaseParseFrame *
  gst_base_parse_frame_copy (GstBaseParseFrame * frame)
  {
    GstBaseParseFrame *copy;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 672,10 ***</span>
<span class="line-new-header">--- 703,16 ---</span>
    GST_TRACE (&quot;copied frame %p -&gt; %p&quot;, frame, copy);
  
    return copy;
  }
  
<span class="line-added">+ /**</span>
<span class="line-added">+  * gst_base_parse_frame_free:</span>
<span class="line-added">+  * @frame: A #GstBaseParseFrame</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Frees the provided @frame.</span>
<span class="line-added">+  */</span>
  void
  gst_base_parse_frame_free (GstBaseParseFrame * frame)
  {
    GST_TRACE (&quot;freeing frame %p&quot;, frame);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 690,12 ***</span>
      memset (frame, 0, sizeof (*frame));
    }
  }
  
  G_DEFINE_BOXED_TYPE (GstBaseParseFrame, gst_base_parse_frame,
<span class="line-modified">!         (GBoxedCopyFunc) gst_base_parse_frame_copy,</span>
<span class="line-modified">!         (GBoxedFreeFunc) gst_base_parse_frame_free);</span>
  
  /**
   * gst_base_parse_frame_init:
   * @frame: #GstBaseParseFrame.
   *
<span class="line-new-header">--- 727,12 ---</span>
      memset (frame, 0, sizeof (*frame));
    }
  }
  
  G_DEFINE_BOXED_TYPE (GstBaseParseFrame, gst_base_parse_frame,
<span class="line-modified">!     (GBoxedCopyFunc) gst_base_parse_frame_copy,</span>
<span class="line-modified">!     (GBoxedFreeFunc) gst_base_parse_frame_free);</span>
  
  /**
   * gst_base_parse_frame_init:
   * @frame: #GstBaseParseFrame.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 800,11 ***</span>
    parse-&gt;priv-&gt;estimated_duration = -1;
    parse-&gt;priv-&gt;estimated_drift = 0;
    parse-&gt;priv-&gt;next_pts = GST_CLOCK_TIME_NONE;
    parse-&gt;priv-&gt;next_dts = 0;
    parse-&gt;priv-&gt;syncable = TRUE;
<span class="line-removed">-   parse-&gt;priv-&gt;disable_passthrough = DEFAULT_DISABLE_PASSTHROUGH;</span>
    parse-&gt;priv-&gt;passthrough = FALSE;
    parse-&gt;priv-&gt;pts_interpolate = TRUE;
    parse-&gt;priv-&gt;infer_ts = TRUE;
    parse-&gt;priv-&gt;has_timing_info = FALSE;
    parse-&gt;priv-&gt;min_bitrate = G_MAXUINT;
<span class="line-new-header">--- 837,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 862,10 ***</span>
<span class="line-new-header">--- 898,12 ---</span>
  
    g_list_foreach (parse-&gt;priv-&gt;detect_buffers, (GFunc) gst_buffer_unref, NULL);
    g_list_free (parse-&gt;priv-&gt;detect_buffers);
    parse-&gt;priv-&gt;detect_buffers = NULL;
    parse-&gt;priv-&gt;detect_buffers_size = 0;
<span class="line-added">+ </span>
<span class="line-added">+   parse-&gt;priv-&gt;segment_seqnum = GST_SEQNUM_INVALID;</span>
    GST_OBJECT_UNLOCK (parse);
  }
  
  static gboolean
  gst_base_parse_check_bitrate_tag (GstBaseParse * parse, const gchar * tag)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1167,18 ***</span>
      case GST_EVENT_SEGMENT:
      {
        const GstSegment *in_segment;
        GstSegment out_segment;
        gint64 offset = 0, next_dts;
<span class="line-removed">-       guint32 seqnum = gst_event_get_seqnum (event);</span>
  
        gst_event_parse_segment (event, &amp;in_segment);
        gst_segment_init (&amp;out_segment, GST_FORMAT_TIME);
        out_segment.rate = in_segment-&gt;rate;
        out_segment.applied_rate = in_segment-&gt;applied_rate;
  
<span class="line-modified">!       GST_DEBUG_OBJECT (parse, &quot;segment %&quot; GST_SEGMENT_FORMAT, in_segment);</span>
  
        parse-&gt;priv-&gt;upstream_format = in_segment-&gt;format;
        if (in_segment-&gt;format == GST_FORMAT_BYTES) {
          GstBaseParseSeek *seek = NULL;
          GSList *node;
<span class="line-new-header">--- 1205,20 ---</span>
      case GST_EVENT_SEGMENT:
      {
        const GstSegment *in_segment;
        GstSegment out_segment;
        gint64 offset = 0, next_dts;
  
<span class="line-added">+       parse-&gt;priv-&gt;segment_seqnum = gst_event_get_seqnum (event);</span>
        gst_event_parse_segment (event, &amp;in_segment);
        gst_segment_init (&amp;out_segment, GST_FORMAT_TIME);
        out_segment.rate = in_segment-&gt;rate;
        out_segment.applied_rate = in_segment-&gt;applied_rate;
  
<span class="line-modified">!       GST_DEBUG_OBJECT (parse, &quot;New segment %&quot; GST_SEGMENT_FORMAT, in_segment);</span>
<span class="line-added">+       GST_DEBUG_OBJECT (parse, &quot;Current segment %&quot; GST_SEGMENT_FORMAT,</span>
<span class="line-added">+           &amp;parse-&gt;segment);</span>
  
        parse-&gt;priv-&gt;upstream_format = in_segment-&gt;format;
        if (in_segment-&gt;format == GST_FORMAT_BYTES) {
          GstBaseParseSeek *seek = NULL;
          GSList *node;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1226,11 ***</span>
          }
  
          gst_event_unref (event);
  
          event = gst_event_new_segment (&amp;out_segment);
<span class="line-modified">!         gst_event_set_seqnum (event, seqnum);</span>
  
          GST_DEBUG_OBJECT (parse, &quot;Converted incoming segment to TIME. %&quot;
              GST_SEGMENT_FORMAT, in_segment);
  
        } else if (in_segment-&gt;format != GST_FORMAT_TIME) {
<span class="line-new-header">--- 1266,11 ---</span>
          }
  
          gst_event_unref (event);
  
          event = gst_event_new_segment (&amp;out_segment);
<span class="line-modified">!         gst_event_set_seqnum (event, parse-&gt;priv-&gt;segment_seqnum);</span>
  
          GST_DEBUG_OBJECT (parse, &quot;Converted incoming segment to TIME. %&quot;
              GST_SEGMENT_FORMAT, in_segment);
  
        } else if (in_segment-&gt;format != GST_FORMAT_TIME) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1241,26 ***</span>
          out_segment.start = 0;
          out_segment.stop = GST_CLOCK_TIME_NONE;
          out_segment.time = 0;
  
          event = gst_event_new_segment (&amp;out_segment);
<span class="line-modified">!         gst_event_set_seqnum (event, seqnum);</span>
  
          next_dts = 0;
        } else {
          /* not considered BYTE seekable if it is talking to us in TIME,
           * whatever else it might claim */
          parse-&gt;priv-&gt;upstream_seekable = FALSE;
          next_dts = in_segment-&gt;start;
          gst_event_copy_segment (event, &amp;out_segment);
        }
  
        memcpy (&amp;parse-&gt;segment, &amp;out_segment, sizeof (GstSegment));
  
        /*
           gst_segment_set_newsegment (&amp;parse-&gt;segment, update, rate,
<span class="line-modified">!           applied_rate, format, start, stop, start);</span>
         */
  
        ret = TRUE;
  
        /* save the segment for later, right before we push a new buffer so that
<span class="line-new-header">--- 1281,28 ---</span>
          out_segment.start = 0;
          out_segment.stop = GST_CLOCK_TIME_NONE;
          out_segment.time = 0;
  
          event = gst_event_new_segment (&amp;out_segment);
<span class="line-modified">!         gst_event_set_seqnum (event, parse-&gt;priv-&gt;segment_seqnum);</span>
  
          next_dts = 0;
        } else {
          /* not considered BYTE seekable if it is talking to us in TIME,
           * whatever else it might claim */
          parse-&gt;priv-&gt;upstream_seekable = FALSE;
          next_dts = in_segment-&gt;start;
          gst_event_copy_segment (event, &amp;out_segment);
        }
  
<span class="line-added">+       GST_DEBUG_OBJECT (parse, &quot;OUT segment %&quot; GST_SEGMENT_FORMAT,</span>
<span class="line-added">+           &amp;out_segment);</span>
        memcpy (&amp;parse-&gt;segment, &amp;out_segment, sizeof (GstSegment));
  
        /*
           gst_segment_set_newsegment (&amp;parse-&gt;segment, update, rate,
<span class="line-modified">!          applied_rate, format, start, stop, start);</span>
         */
  
        ret = TRUE;
  
        /* save the segment for later, right before we push a new buffer so that
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1430,11 ***</span>
  
        gst_event_parse_tag (event, &amp;tags);
  
        /* We only care about stream tags here, global tags we just forward */
        if (gst_tag_list_get_scope (tags) != GST_TAG_SCOPE_STREAM)
<span class="line-modified">!       break;</span>
  
        gst_base_parse_set_upstream_tags (parse, tags);
        gst_base_parse_queue_tag_event_update (parse);
        parse-&gt;priv-&gt;tags_changed = FALSE;
        gst_event_unref (event);
<span class="line-new-header">--- 1472,11 ---</span>
  
        gst_event_parse_tag (event, &amp;tags);
  
        /* We only care about stream tags here, global tags we just forward */
        if (gst_tag_list_get_scope (tags) != GST_TAG_SCOPE_STREAM)
<span class="line-modified">!         break;</span>
  
        gst_base_parse_set_upstream_tags (parse, tags);
        gst_base_parse_queue_tag_event_update (parse);
        parse-&gt;priv-&gt;tags_changed = FALSE;
        gst_event_unref (event);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1654,11 ***</span>
   * @src_format: #GstFormat describing the source format.
   * @src_value: Source value to be converted.
   * @dest_format: #GstFormat defining the converted format.
   * @dest_value: (out): Pointer where the conversion result will be put.
   *
<span class="line-modified">!  * Default implementation of &quot;convert&quot; vmethod in #GstBaseParse class.</span>
   *
   * Returns: %TRUE if conversion was successful.
   */
  gboolean
  gst_base_parse_convert_default (GstBaseParse * parse,
<span class="line-new-header">--- 1696,11 ---</span>
   * @src_format: #GstFormat describing the source format.
   * @src_value: Source value to be converted.
   * @dest_format: #GstFormat defining the converted format.
   * @dest_value: (out): Pointer where the conversion result will be put.
   *
<span class="line-modified">!  * Default implementation of #GstBaseParseClass.convert().</span>
   *
   * Returns: %TRUE if conversion was successful.
   */
  gboolean
  gst_base_parse_convert_default (GstBaseParse * parse,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1757,11 ***</span>
  no_slaved_conversions:
    {
      GST_DEBUG_OBJECT (parse,
          &quot;Can&#39;t do format conversions when upstream format is not BYTES&quot;);
      return FALSE;
<span class="line-modified">! }</span>
  }
  
  static void
  gst_base_parse_update_duration (GstBaseParse * parse)
  {
<span class="line-new-header">--- 1799,11 ---</span>
  no_slaved_conversions:
    {
      GST_DEBUG_OBJECT (parse,
          &quot;Can&#39;t do format conversions when upstream format is not BYTES&quot;);
      return FALSE;
<span class="line-modified">!   }</span>
  }
  
  static void
  gst_base_parse_update_duration (GstBaseParse * parse)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1780,17 ***</span>
    parse-&gt;priv-&gt;estimated_duration = dest_value;
    GST_LOG_OBJECT (parse,
        &quot;updated estimated duration to %&quot; GST_TIME_FORMAT,
        GST_TIME_ARGS (dest_value));
  
<span class="line-modified">!         if (parse-&gt;priv-&gt;estimated_drift &gt; GST_SECOND ||</span>
<span class="line-modified">!             parse-&gt;priv-&gt;estimated_drift &lt; -GST_SECOND) {</span>
<span class="line-modified">!           gst_element_post_message (GST_ELEMENT (parse),</span>
<span class="line-modified">!               gst_message_new_duration_changed (GST_OBJECT (parse)));</span>
<span class="line-modified">!           parse-&gt;priv-&gt;estimated_drift = 0;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       }</span>
  
  /* gst_base_parse_update_bitrates:
   * @parse: #GstBaseParse.
   * @buffer: Current frame as a #GstBuffer
   *
<span class="line-new-header">--- 1822,17 ---</span>
    parse-&gt;priv-&gt;estimated_duration = dest_value;
    GST_LOG_OBJECT (parse,
        &quot;updated estimated duration to %&quot; GST_TIME_FORMAT,
        GST_TIME_ARGS (dest_value));
  
<span class="line-modified">!   if (parse-&gt;priv-&gt;estimated_drift &gt; GST_SECOND ||</span>
<span class="line-modified">!       parse-&gt;priv-&gt;estimated_drift &lt; -GST_SECOND) {</span>
<span class="line-modified">!     gst_element_post_message (GST_ELEMENT (parse),</span>
<span class="line-modified">!         gst_message_new_duration_changed (GST_OBJECT (parse)));</span>
<span class="line-modified">!     parse-&gt;priv-&gt;estimated_drift = 0;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! }</span>
  
  /* gst_base_parse_update_bitrates:
   * @parse: #GstBaseParse.
   * @buffer: Current frame as a #GstBuffer
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1880,13 ***</span>
        guint64 diffprev = gst_util_uint64_scale (100,
            ABSDIFF (parse-&gt;priv-&gt;avg_bitrate, parse-&gt;priv-&gt;posted_avg_bitrate),
            parse-&gt;priv-&gt;avg_bitrate);
        if (diffprev &gt;= UPDATE_THRESHOLD)
          parse-&gt;priv-&gt;tags_changed = TRUE;
    }
  }
<span class="line-removed">- }</span>
  
  /**
   * gst_base_parse_add_index_entry:
   * @parse: #GstBaseParse.
   * @offset: offset of entry
<span class="line-new-header">--- 1922,13 ---</span>
        guint64 diffprev = gst_util_uint64_scale (100,
            ABSDIFF (parse-&gt;priv-&gt;avg_bitrate, parse-&gt;priv-&gt;posted_avg_bitrate),
            parse-&gt;priv-&gt;avg_bitrate);
        if (diffprev &gt;= UPDATE_THRESHOLD)
          parse-&gt;priv-&gt;tags_changed = TRUE;
<span class="line-added">+     }</span>
    }
  }
  
  /**
   * gst_base_parse_add_index_entry:
   * @parse: #GstBaseParse.
   * @offset: offset of entry
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2121,11 ***</span>
    gst_buffer_unref (buffer);
    gst_base_parse_update_frame (parse, frame);
  
    /* clear flags for next frame */
    parse-&gt;priv-&gt;discont = FALSE;
<span class="line-modified">!     parse-&gt;priv-&gt;new_frame = FALSE;</span>
  
    /* use default handler to provide initial (upstream) metadata */
    gst_base_parse_parse_frame (parse, frame);
  
    return frame;
<span class="line-new-header">--- 2163,11 ---</span>
    gst_buffer_unref (buffer);
    gst_base_parse_update_frame (parse, frame);
  
    /* clear flags for next frame */
    parse-&gt;priv-&gt;discont = FALSE;
<span class="line-modified">!   parse-&gt;priv-&gt;new_frame = FALSE;</span>
  
    /* use default handler to provide initial (upstream) metadata */
    gst_base_parse_parse_frame (parse, frame);
  
    return frame;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2201,19 ***</span>
        /* If we&#39;re asked to skip more than is available in the adapter,
           we need to remember what we need to skip for next iteration */
        gsize av = gst_adapter_available (parse-&gt;priv-&gt;adapter);
        GST_DEBUG (&quot;Asked to skip %u (%&quot; G_GSIZE_FORMAT &quot; available)&quot;, *skip, av);
        if (av &gt;= *skip) {
<span class="line-modified">!       gst_adapter_flush (parse-&gt;priv-&gt;adapter, *skip);</span>
        } else {
          GST_DEBUG
              (&quot;This is more than available, flushing %&quot; G_GSIZE_FORMAT
              &quot;, storing %u to skip&quot;, av, (guint) (*skip - av));
          parse-&gt;priv-&gt;skip = *skip - av;
          gst_adapter_flush (parse-&gt;priv-&gt;adapter, av);
          *skip = av;
<span class="line-modified">!     }</span>
      }
      if (!parse-&gt;priv-&gt;discont)
        parse-&gt;priv-&gt;sync_offset = parse-&gt;priv-&gt;offset;
      parse-&gt;priv-&gt;offset += *skip;
      parse-&gt;priv-&gt;discont = TRUE;
<span class="line-new-header">--- 2243,19 ---</span>
        /* If we&#39;re asked to skip more than is available in the adapter,
           we need to remember what we need to skip for next iteration */
        gsize av = gst_adapter_available (parse-&gt;priv-&gt;adapter);
        GST_DEBUG (&quot;Asked to skip %u (%&quot; G_GSIZE_FORMAT &quot; available)&quot;, *skip, av);
        if (av &gt;= *skip) {
<span class="line-modified">!         gst_adapter_flush (parse-&gt;priv-&gt;adapter, *skip);</span>
        } else {
          GST_DEBUG
              (&quot;This is more than available, flushing %&quot; G_GSIZE_FORMAT
              &quot;, storing %u to skip&quot;, av, (guint) (*skip - av));
          parse-&gt;priv-&gt;skip = *skip - av;
          gst_adapter_flush (parse-&gt;priv-&gt;adapter, av);
          *skip = av;
<span class="line-modified">!       }</span>
      }
      if (!parse-&gt;priv-&gt;discont)
        parse-&gt;priv-&gt;sync_offset = parse-&gt;priv-&gt;offset;
      parse-&gt;priv-&gt;offset += *skip;
      parse-&gt;priv-&gt;discont = TRUE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2454,26 ***</span>
        diff = GST_CLOCK_DIFF (parse-&gt;segment.position, last_start);
        if (G_UNLIKELY (diff &gt; 2 * GST_SECOND
                &amp;&amp; last_start &gt; parse-&gt;segment.start
                &amp;&amp; (!GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.stop)
                    || last_start &lt; parse-&gt;segment.stop))) {
  
          GST_DEBUG_OBJECT (parse,
              &quot;Gap of %&quot; G_GINT64_FORMAT &quot; ns detected in stream &quot; &quot;(%&quot;
              GST_TIME_FORMAT &quot; -&gt; %&quot; GST_TIME_FORMAT &quot;). &quot;
              &quot;Sending updated SEGMENT events&quot;, diff,
              GST_TIME_ARGS (parse-&gt;segment.position),
              GST_TIME_ARGS (last_start));
  
          /* skip gap FIXME */
<span class="line-modified">!           gst_pad_push_event (parse-&gt;srcpad,</span>
<span class="line-modified">!             gst_event_new_segment (&amp;parse-&gt;segment));</span>
  
          parse-&gt;segment.position = last_start;
<span class="line-removed">-         }</span>
        }
      }
  
    /* update bitrates and optionally post corresponding tags
     * (following newsegment) */
    gst_base_parse_update_bitrates (parse, frame);
  
<span class="line-new-header">--- 2496,29 ---</span>
        diff = GST_CLOCK_DIFF (parse-&gt;segment.position, last_start);
        if (G_UNLIKELY (diff &gt; 2 * GST_SECOND
                &amp;&amp; last_start &gt; parse-&gt;segment.start
                &amp;&amp; (!GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.stop)
                    || last_start &lt; parse-&gt;segment.stop))) {
<span class="line-added">+         GstEvent *topush;</span>
  
          GST_DEBUG_OBJECT (parse,
              &quot;Gap of %&quot; G_GINT64_FORMAT &quot; ns detected in stream &quot; &quot;(%&quot;
              GST_TIME_FORMAT &quot; -&gt; %&quot; GST_TIME_FORMAT &quot;). &quot;
              &quot;Sending updated SEGMENT events&quot;, diff,
              GST_TIME_ARGS (parse-&gt;segment.position),
              GST_TIME_ARGS (last_start));
  
          /* skip gap FIXME */
<span class="line-modified">!         topush = gst_event_new_segment (&amp;parse-&gt;segment);</span>
<span class="line-modified">!         if (parse-&gt;priv-&gt;segment_seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added">+           gst_event_set_seqnum (topush, parse-&gt;priv-&gt;segment_seqnum);</span>
<span class="line-added">+         gst_pad_push_event (parse-&gt;srcpad, topush);</span>
  
          parse-&gt;segment.position = last_start;
        }
      }
<span class="line-added">+   }</span>
  
    /* update bitrates and optionally post corresponding tags
     * (following newsegment) */
    gst_base_parse_update_bitrates (parse, frame);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2495,12 ***</span>
    if (frame-&gt;out_buffer) {
      buffer = frame-&gt;out_buffer;
      frame-&gt;out_buffer = NULL;
      gst_buffer_replace (&amp;frame-&gt;buffer, NULL);
    } else {
<span class="line-modified">!   buffer = frame-&gt;buffer;</span>
<span class="line-modified">!   frame-&gt;buffer = NULL;</span>
    }
  
    /* subclass must play nice */
    g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
  
<span class="line-new-header">--- 2540,12 ---</span>
    if (frame-&gt;out_buffer) {
      buffer = frame-&gt;out_buffer;
      frame-&gt;out_buffer = NULL;
      gst_buffer_replace (&amp;frame-&gt;buffer, NULL);
    } else {
<span class="line-modified">!     buffer = frame-&gt;buffer;</span>
<span class="line-modified">!     frame-&gt;buffer = NULL;</span>
    }
  
    /* subclass must play nice */
    g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2564,11 ***</span>
          GST_LOG_OBJECT (parse,
              &quot;pushing frame (%&quot; G_GSIZE_FORMAT &quot; bytes) now..&quot;, size);
          ret = gst_pad_push (parse-&gt;srcpad, buffer);
          GST_LOG_OBJECT (parse, &quot;frame pushed, flow %s&quot;,
              gst_flow_get_name (ret));
<span class="line-modified">!     } else {</span>
          GST_LOG_OBJECT (parse,
              &quot;frame (%&quot; G_GSIZE_FORMAT &quot; bytes) not pushed: %s&quot;, size,
              gst_flow_get_name (ret));
          gst_buffer_unref (buffer);
        }
<span class="line-new-header">--- 2609,11 ---</span>
          GST_LOG_OBJECT (parse,
              &quot;pushing frame (%&quot; G_GSIZE_FORMAT &quot; bytes) now..&quot;, size);
          ret = gst_pad_push (parse-&gt;srcpad, buffer);
          GST_LOG_OBJECT (parse, &quot;frame pushed, flow %s&quot;,
              gst_flow_get_name (ret));
<span class="line-modified">!       } else {</span>
          GST_LOG_OBJECT (parse,
              &quot;frame (%&quot; G_GSIZE_FORMAT &quot; bytes) not pushed: %s&quot;, size,
              gst_flow_get_name (ret));
          gst_buffer_unref (buffer);
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2854,11 ***</span>
    while (parse-&gt;priv-&gt;buffers_pending) {
      buf = GST_BUFFER_CAST (parse-&gt;priv-&gt;buffers_pending-&gt;data);
      if (prev_head) {
        GST_LOG_OBJECT (parse, &quot;adding pending buffer (size %&quot; G_GSIZE_FORMAT &quot;)&quot;,
            gst_buffer_get_size (buf));
<span class="line-modified">!     gst_adapter_push (parse-&gt;priv-&gt;adapter, buf);</span>
      } else {
        GST_LOG_OBJECT (parse, &quot;discarding head buffer&quot;);
        gst_buffer_unref (buf);
      }
      parse-&gt;priv-&gt;buffers_pending =
<span class="line-new-header">--- 2899,11 ---</span>
    while (parse-&gt;priv-&gt;buffers_pending) {
      buf = GST_BUFFER_CAST (parse-&gt;priv-&gt;buffers_pending-&gt;data);
      if (prev_head) {
        GST_LOG_OBJECT (parse, &quot;adding pending buffer (size %&quot; G_GSIZE_FORMAT &quot;)&quot;,
            gst_buffer_get_size (buf));
<span class="line-modified">!       gst_adapter_push (parse-&gt;priv-&gt;adapter, buf);</span>
      } else {
        GST_LOG_OBJECT (parse, &quot;discarding head buffer&quot;);
        gst_buffer_unref (buf);
      }
      parse-&gt;priv-&gt;buffers_pending =
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2887,14 ***</span>
            GST_TIME_ARGS (GST_BUFFER_PTS (buf)));
      } else if (GST_BUFFER_DURATION_IS_VALID (buf)) {
        if (GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;last_pts)) {
          if (G_LIKELY (GST_BUFFER_DURATION (buf) &lt;= parse-&gt;priv-&gt;last_pts))
            parse-&gt;priv-&gt;last_pts -= GST_BUFFER_DURATION (buf);
<span class="line-modified">!       else</span>
            parse-&gt;priv-&gt;last_pts = 0;
          GST_BUFFER_PTS (buf) = parse-&gt;priv-&gt;last_pts;
<span class="line-modified">!       GST_LOG_OBJECT (parse, &quot;applied time %&quot; GST_TIME_FORMAT,</span>
              GST_TIME_ARGS (GST_BUFFER_PTS (buf)));
        }
        if (GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;last_dts)) {
          if (G_LIKELY (GST_BUFFER_DURATION (buf) &lt;= parse-&gt;priv-&gt;last_dts))
            parse-&gt;priv-&gt;last_dts -= GST_BUFFER_DURATION (buf);
<span class="line-new-header">--- 2932,14 ---</span>
            GST_TIME_ARGS (GST_BUFFER_PTS (buf)));
      } else if (GST_BUFFER_DURATION_IS_VALID (buf)) {
        if (GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;last_pts)) {
          if (G_LIKELY (GST_BUFFER_DURATION (buf) &lt;= parse-&gt;priv-&gt;last_pts))
            parse-&gt;priv-&gt;last_pts -= GST_BUFFER_DURATION (buf);
<span class="line-modified">!         else</span>
            parse-&gt;priv-&gt;last_pts = 0;
          GST_BUFFER_PTS (buf) = parse-&gt;priv-&gt;last_pts;
<span class="line-modified">!         GST_LOG_OBJECT (parse, &quot;applied time %&quot; GST_TIME_FORMAT,</span>
              GST_TIME_ARGS (GST_BUFFER_PTS (buf)));
        }
        if (GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;last_dts)) {
          if (G_LIKELY (GST_BUFFER_DURATION (buf) &lt;= parse-&gt;priv-&gt;last_dts))
            parse-&gt;priv-&gt;last_dts -= GST_BUFFER_DURATION (buf);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3168,13 ***</span>
        ret = gst_base_parse_push_frame (parse, &amp;frame);
        gst_base_parse_frame_free (&amp;frame);
        return ret;
      }
      if (G_UNLIKELY (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT))) {
<span class="line-modified">!     /* upstream feeding us in reverse playback;</span>
<span class="line-modified">!      * finish previous fragment and start new upon DISCONT */</span>
<span class="line-modified">!     if (parse-&gt;segment.rate &lt; 0.0) {</span>
          GST_DEBUG_OBJECT (parse, &quot;buffer starts new reverse playback fragment&quot;);
          ret = gst_base_parse_finish_fragment (parse, TRUE);
          gst_base_parse_start_fragment (parse);
        } else {
          /* discont in the stream, drain and mark discont for next output */
<span class="line-new-header">--- 3213,13 ---</span>
        ret = gst_base_parse_push_frame (parse, &amp;frame);
        gst_base_parse_frame_free (&amp;frame);
        return ret;
      }
      if (G_UNLIKELY (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT))) {
<span class="line-modified">!       /* upstream feeding us in reverse playback;</span>
<span class="line-modified">!        * finish previous fragment and start new upon DISCONT */</span>
<span class="line-modified">!       if (parse-&gt;segment.rate &lt; 0.0) {</span>
          GST_DEBUG_OBJECT (parse, &quot;buffer starts new reverse playback fragment&quot;);
          ret = gst_base_parse_finish_fragment (parse, TRUE);
          gst_base_parse_start_fragment (parse);
        } else {
          /* discont in the stream, drain and mark discont for next output */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3191,26 ***</span>
      gint flush = 0;
      gboolean updated_prev_pts = FALSE;
  
      /* note: if subclass indicates MAX fsize,
       * this will not likely be available anyway ... */
<span class="line-modified">!       min_size = MAX (parse-&gt;priv-&gt;min_frame_size, fsize);</span>
<span class="line-modified">!       av = gst_adapter_available (parse-&gt;priv-&gt;adapter);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (G_UNLIKELY (parse-&gt;priv-&gt;drain)) {</span>
<span class="line-removed">-         min_size = av;</span>
<span class="line-removed">-         GST_DEBUG_OBJECT (parse, &quot;draining, data left: %d&quot;, min_size);</span>
<span class="line-removed">-         if (G_UNLIKELY (!min_size)) {</span>
<span class="line-removed">-           goto done;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
  
<span class="line-modified">!       /* Collect at least min_frame_size bytes */</span>
<span class="line-modified">!       if (av &lt; min_size) {</span>
<span class="line-modified">!       GST_DEBUG_OBJECT (parse, &quot;not enough data available (only %d bytes)&quot;, av);</span>
          goto done;
        }
  
      /* move along with upstream timestamp (if any),
       * but interpolate in between */
      pts = gst_adapter_prev_pts (parse-&gt;priv-&gt;adapter, NULL);
      dts = gst_adapter_prev_dts (parse-&gt;priv-&gt;adapter, NULL);
<span class="line-new-header">--- 3236,26 ---</span>
      gint flush = 0;
      gboolean updated_prev_pts = FALSE;
  
      /* note: if subclass indicates MAX fsize,
       * this will not likely be available anyway ... */
<span class="line-modified">!     min_size = MAX (parse-&gt;priv-&gt;min_frame_size, fsize);</span>
<span class="line-modified">!     av = gst_adapter_available (parse-&gt;priv-&gt;adapter);</span>
  
<span class="line-modified">!     if (G_UNLIKELY (parse-&gt;priv-&gt;drain)) {</span>
<span class="line-modified">!       min_size = av;</span>
<span class="line-modified">!       GST_DEBUG_OBJECT (parse, &quot;draining, data left: %d&quot;, min_size);</span>
<span class="line-added">+       if (G_UNLIKELY (!min_size)) {</span>
          goto done;
        }
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* Collect at least min_frame_size bytes */</span>
<span class="line-added">+     if (av &lt; min_size) {</span>
<span class="line-added">+       GST_DEBUG_OBJECT (parse, &quot;not enough data available (only %d bytes)&quot;, av);</span>
<span class="line-added">+       goto done;</span>
<span class="line-added">+     }</span>
  
      /* move along with upstream timestamp (if any),
       * but interpolate in between */
      pts = gst_adapter_prev_pts (parse-&gt;priv-&gt;adapter, NULL);
      dts = gst_adapter_prev_dts (parse-&gt;priv-&gt;adapter, NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3235,39 ***</span>
          &amp;&amp; GST_CLOCK_TIME_IS_VALID (pts)) {
        parse-&gt;priv-&gt;prev_dts = parse-&gt;priv-&gt;next_dts = pts;
        parse-&gt;priv-&gt;prev_dts_from_pts = TRUE;
      }
  
<span class="line-modified">!       /* always pass all available data */</span>
      tmpbuf = gst_adapter_get_buffer (parse-&gt;priv-&gt;adapter, av);
  
      /* already inform subclass what timestamps we have planned,
       * at least if provided by time-based upstream */
      if (parse-&gt;priv-&gt;upstream_format == GST_FORMAT_TIME) {
        tmpbuf = gst_buffer_make_writable (tmpbuf);
        GST_BUFFER_PTS (tmpbuf) = parse-&gt;priv-&gt;next_pts;
        GST_BUFFER_DTS (tmpbuf) = parse-&gt;priv-&gt;next_dts;
        GST_BUFFER_DURATION (tmpbuf) = GST_CLOCK_TIME_NONE;
<span class="line-modified">!       }</span>
  
      /* keep the adapter mapped, so keep track of what has to be flushed */
      ret = gst_base_parse_handle_buffer (parse, tmpbuf, &amp;skip, &amp;flush);
      tmpbuf = NULL;
  
      if (ret != GST_FLOW_OK &amp;&amp; ret != GST_FLOW_NOT_LINKED) {
<span class="line-modified">!           goto done;</span>
<span class="line-modified">!         }</span>
      if (skip == 0 &amp;&amp; flush == 0) {
        GST_LOG_OBJECT (parse, &quot;nothing skipped and no frames finished, &quot;
            &quot;breaking to get more data&quot;);
        /* ignore this return as it produced no data */
        ret = old_ret;
<span class="line-modified">!         goto done;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     if (old_ret == GST_FLOW_OK)</span>
<span class="line-removed">-     old_ret = ret;</span>
      }
  
  done:
    GST_LOG_OBJECT (parse, &quot;chain leaving&quot;);
    return ret;
  }
<span class="line-new-header">--- 3280,39 ---</span>
          &amp;&amp; GST_CLOCK_TIME_IS_VALID (pts)) {
        parse-&gt;priv-&gt;prev_dts = parse-&gt;priv-&gt;next_dts = pts;
        parse-&gt;priv-&gt;prev_dts_from_pts = TRUE;
      }
  
<span class="line-modified">!     /* always pass all available data */</span>
      tmpbuf = gst_adapter_get_buffer (parse-&gt;priv-&gt;adapter, av);
  
      /* already inform subclass what timestamps we have planned,
       * at least if provided by time-based upstream */
      if (parse-&gt;priv-&gt;upstream_format == GST_FORMAT_TIME) {
        tmpbuf = gst_buffer_make_writable (tmpbuf);
        GST_BUFFER_PTS (tmpbuf) = parse-&gt;priv-&gt;next_pts;
        GST_BUFFER_DTS (tmpbuf) = parse-&gt;priv-&gt;next_dts;
        GST_BUFFER_DURATION (tmpbuf) = GST_CLOCK_TIME_NONE;
<span class="line-modified">!     }</span>
  
      /* keep the adapter mapped, so keep track of what has to be flushed */
      ret = gst_base_parse_handle_buffer (parse, tmpbuf, &amp;skip, &amp;flush);
      tmpbuf = NULL;
  
      if (ret != GST_FLOW_OK &amp;&amp; ret != GST_FLOW_NOT_LINKED) {
<span class="line-modified">!       goto done;</span>
<span class="line-modified">!     }</span>
      if (skip == 0 &amp;&amp; flush == 0) {
        GST_LOG_OBJECT (parse, &quot;nothing skipped and no frames finished, &quot;
            &quot;breaking to get more data&quot;);
        /* ignore this return as it produced no data */
        ret = old_ret;
<span class="line-modified">!       goto done;</span>
      }
<span class="line-added">+     if (old_ret == GST_FLOW_OK)</span>
<span class="line-added">+       old_ret = ret;</span>
<span class="line-added">+   }</span>
  
  done:
    GST_LOG_OBJECT (parse, &quot;chain leaving&quot;);
    return ret;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3311,36 ***</span>
    if (ret != GST_FLOW_OK) {
      parse-&gt;priv-&gt;cache = NULL;
      return ret;
    }
  
<span class="line-removed">-   if (gst_buffer_get_size (parse-&gt;priv-&gt;cache) &gt;= size) {</span>
<span class="line-removed">-     *buffer =</span>
<span class="line-removed">-         gst_buffer_copy_region (parse-&gt;priv-&gt;cache, GST_BUFFER_COPY_ALL, 0,</span>
<span class="line-removed">-         size);</span>
<span class="line-removed">- #ifdef GSTREAMER_LITE</span>
<span class="line-removed">-     if (buffer == NULL)</span>
<span class="line-removed">-       return GST_FLOW_ERROR;</span>
<span class="line-removed">- #endif // GSTREAMER_LITE</span>
<span class="line-removed">-     GST_BUFFER_OFFSET (*buffer) = parse-&gt;priv-&gt;offset;</span>
<span class="line-removed">-     return GST_FLOW_OK;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   /* Not possible to get enough data, try a last time with</span>
<span class="line-removed">-    * requesting exactly the size we need */</span>
<span class="line-removed">-   gst_buffer_unref (parse-&gt;priv-&gt;cache);</span>
<span class="line-removed">-   parse-&gt;priv-&gt;cache = NULL;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ret = gst_pad_pull_range (parse-&gt;sinkpad, parse-&gt;priv-&gt;offset, size,</span>
<span class="line-removed">-       &amp;parse-&gt;priv-&gt;cache);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (ret != GST_FLOW_OK) {</span>
<span class="line-removed">-     GST_DEBUG_OBJECT (parse, &quot;pull_range returned %d&quot;, ret);</span>
<span class="line-removed">-     *buffer = NULL;</span>
<span class="line-removed">-     return ret;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    if (gst_buffer_get_size (parse-&gt;priv-&gt;cache) &lt; size) {
      GST_DEBUG_OBJECT (parse, &quot;Returning short buffer at offset %&quot;
          G_GUINT64_FORMAT &quot;: wanted %u bytes, got %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
          parse-&gt;priv-&gt;offset, size, gst_buffer_get_size (parse-&gt;priv-&gt;cache));
  
<span class="line-new-header">--- 3356,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3471,20 ***</span>
            return GST_FLOW_ERROR;
          } else {
            fsize += 64 * 1024;
            gst_buffer_unref (buffer);
            continue;
<span class="line-modified">!     }</span>
        } else if (ret != GST_FLOW_OK) {
<span class="line-modified">!     gst_buffer_unref (buffer);</span>
          GST_ERROR_OBJECT (parse, &quot;detect() returned %s&quot;,
              gst_flow_get_name (ret));
          return ret;
<span class="line-modified">!     }</span>
  
        /* Else handle this buffer normally */
<span class="line-modified">!   }</span>
  
      ret = gst_base_parse_handle_buffer (parse, buffer, &amp;skip, &amp;flushed);
      if (ret != GST_FLOW_OK)
        break;
  
<span class="line-new-header">--- 3490,20 ---</span>
            return GST_FLOW_ERROR;
          } else {
            fsize += 64 * 1024;
            gst_buffer_unref (buffer);
            continue;
<span class="line-modified">!         }</span>
        } else if (ret != GST_FLOW_OK) {
<span class="line-modified">!         gst_buffer_unref (buffer);</span>
          GST_ERROR_OBJECT (parse, &quot;detect() returned %s&quot;,
              gst_flow_get_name (ret));
          return ret;
<span class="line-modified">!       }</span>
  
        /* Else handle this buffer normally */
<span class="line-modified">!     }</span>
  
      ret = gst_base_parse_handle_buffer (parse, buffer, &amp;skip, &amp;flushed);
      if (ret != GST_FLOW_OK)
        break;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3511,11 ***</span>
      /* otherwise, get some more data
       * note that is checked this does not happen indefinitely */
      if (!skip) {
        GST_LOG_OBJECT (parse, &quot;getting some more data&quot;);
        fsize += 64 * 1024;
<span class="line-modified">!   }</span>
      parse-&gt;priv-&gt;drain = FALSE;
    }
  
  done:
    return ret;
<span class="line-new-header">--- 3530,11 ---</span>
      /* otherwise, get some more data
       * note that is checked this does not happen indefinitely */
      if (!skip) {
        GST_LOG_OBJECT (parse, &quot;getting some more data&quot;);
        fsize += 64 * 1024;
<span class="line-modified">!     }</span>
      parse-&gt;priv-&gt;drain = FALSE;
    }
  
  done:
    return ret;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3633,17 ***</span>
         * that we should stop now. */
        GST_ELEMENT_FLOW_ERROR (parse, ret);
        push_eos = TRUE;
      }
      if (push_eos) {
        if (parse-&gt;priv-&gt;estimated_duration &lt;= 0) {
          gst_base_parse_update_duration (parse);
        }
        /* Push pending events, including SEGMENT events */
        gst_base_parse_push_pending_events (parse);
  
<span class="line-modified">!       gst_pad_push_event (parse-&gt;srcpad, gst_event_new_eos ());</span>
      }
      gst_object_unref (parse);
    }
  }
  
<span class="line-new-header">--- 3652,23 ---</span>
         * that we should stop now. */
        GST_ELEMENT_FLOW_ERROR (parse, ret);
        push_eos = TRUE;
      }
      if (push_eos) {
<span class="line-added">+       GstEvent *topush;</span>
        if (parse-&gt;priv-&gt;estimated_duration &lt;= 0) {
          gst_base_parse_update_duration (parse);
        }
        /* Push pending events, including SEGMENT events */
        gst_base_parse_push_pending_events (parse);
  
<span class="line-modified">!       topush = gst_event_new_eos ();</span>
<span class="line-added">+       GST_DEBUG_OBJECT (parse, &quot;segment_seqnum:%&quot; G_GUINT32_FORMAT,</span>
<span class="line-added">+           parse-&gt;priv-&gt;segment_seqnum);</span>
<span class="line-added">+       if (parse-&gt;priv-&gt;segment_seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added">+         gst_event_set_seqnum (topush, parse-&gt;priv-&gt;segment_seqnum);</span>
<span class="line-added">+       gst_pad_push_event (parse-&gt;srcpad, topush);</span>
      }
      gst_object_unref (parse);
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3673,11 ***</span>
    gst_query_unref (query);
  
    if (!pull_mode)
      goto baseparse_push;
  
<span class="line-modified">!     GST_DEBUG_OBJECT (parse, &quot;trying to activate in pull mode&quot;);</span>
    if (!gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PULL, TRUE))
      goto baseparse_push;
  
    parse-&gt;priv-&gt;push_stream_start = TRUE;
    /* In pull mode, upstream is BYTES */
<span class="line-new-header">--- 3698,11 ---</span>
    gst_query_unref (query);
  
    if (!pull_mode)
      goto baseparse_push;
  
<span class="line-modified">!   GST_DEBUG_OBJECT (parse, &quot;trying to activate in pull mode&quot;);</span>
    if (!gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PULL, TRUE))
      goto baseparse_push;
  
    parse-&gt;priv-&gt;push_stream_start = TRUE;
    /* In pull mode, upstream is BYTES */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3741,18 ***</span>
    if (!gst_base_parse_activate (parse, active))
      goto activate_failed;
  
    switch (mode) {
      case GST_PAD_MODE_PULL:
<span class="line-modified">!     if (active) {</span>
          parse-&gt;priv-&gt;pending_events =
<span class="line-modified">!             g_list_prepend (parse-&gt;priv-&gt;pending_events,</span>
<span class="line-removed">-             gst_event_new_segment (&amp;parse-&gt;segment));</span>
          result = TRUE;
<span class="line-modified">!     } else {</span>
          result = gst_pad_stop_task (pad);
<span class="line-modified">!     }</span>
        break;
      default:
        result = TRUE;
        break;
    }
<span class="line-new-header">--- 3766,19 ---</span>
    if (!gst_base_parse_activate (parse, active))
      goto activate_failed;
  
    switch (mode) {
      case GST_PAD_MODE_PULL:
<span class="line-modified">!       if (active) {</span>
<span class="line-added">+         GstEvent *ev = gst_event_new_segment (&amp;parse-&gt;segment);</span>
<span class="line-added">+         parse-&gt;priv-&gt;segment_seqnum = gst_event_get_seqnum (ev);</span>
          parse-&gt;priv-&gt;pending_events =
<span class="line-modified">!             g_list_prepend (parse-&gt;priv-&gt;pending_events, ev);</span>
          result = TRUE;
<span class="line-modified">!       } else {</span>
          result = gst_pad_stop_task (pad);
<span class="line-modified">!       }</span>
        break;
      default:
        result = TRUE;
        break;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3839,15 ***</span>
  }
  
  /**
   * gst_base_parse_set_min_frame_size:
   * @parse: #GstBaseParse.
<span class="line-modified">!  * @min_size: Minimum size of the data that this base class should give to</span>
<span class="line-modified">!  *            subclass.</span>
   *
   * Subclass can use this function to tell the base class that it needs to
<span class="line-modified">!  * give at least #min_size buffers.</span>
   */
  void
  gst_base_parse_set_min_frame_size (GstBaseParse * parse, guint min_size)
  {
    g_return_if_fail (parse != NULL);
<span class="line-new-header">--- 3865,15 ---</span>
  }
  
  /**
   * gst_base_parse_set_min_frame_size:
   * @parse: #GstBaseParse.
<span class="line-modified">!  * @min_size: Minimum size in bytes of the data that this base class should</span>
<span class="line-modified">!  *       give to subclass.</span>
   *
   * Subclass can use this function to tell the base class that it needs to
<span class="line-modified">!  * be given buffers of at least @min_size bytes.</span>
   */
  void
  gst_base_parse_set_min_frame_size (GstBaseParse * parse, guint min_size)
  {
    g_return_if_fail (parse != NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3951,14 ***</span>
   * @passthrough: %TRUE if parser should run in passthrough mode
   *
   * Set if the nature of the format or configuration does not allow (much)
   * parsing, and the parser should operate in passthrough mode (which only
   * applies when operating in push mode). That is, incoming buffers are
<span class="line-modified">!  * pushed through unmodified, i.e. no @check_valid_frame or @parse_frame</span>
<span class="line-modified">!  * callbacks will be invoked, but @pre_push_frame will still be invoked,</span>
<span class="line-modified">!  * so subclass can perform as much or as little is appropriate for</span>
<span class="line-modified">!  * passthrough semantics in @pre_push_frame.</span>
   */
  void
  gst_base_parse_set_passthrough (GstBaseParse * parse, gboolean passthrough)
  {
    parse-&gt;priv-&gt;passthrough = passthrough;
<span class="line-new-header">--- 3977,14 ---</span>
   * @passthrough: %TRUE if parser should run in passthrough mode
   *
   * Set if the nature of the format or configuration does not allow (much)
   * parsing, and the parser should operate in passthrough mode (which only
   * applies when operating in push mode). That is, incoming buffers are
<span class="line-modified">!  * pushed through unmodified, i.e. no #GstBaseParseClass.handle_frame()</span>
<span class="line-modified">!  * will be invoked, but #GstBaseParseClass.pre_push_frame() will still be</span>
<span class="line-modified">!  * invoked, so subclass can perform as much or as little is appropriate for</span>
<span class="line-modified">!  * passthrough semantics in #GstBaseParseClass.pre_push_frame().</span>
   */
  void
  gst_base_parse_set_passthrough (GstBaseParse * parse, gboolean passthrough)
  {
    parse-&gt;priv-&gt;passthrough = passthrough;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4076,24 ***</span>
  
        /* try upstream first */
        res = gst_pad_query_default (pad, GST_OBJECT_CAST (parse), query);
        if (!res) {
          /* Fall back on interpreting segment */
<span class="line-modified">!       GST_OBJECT_LOCK (parse);</span>
          /* Only reply BYTES if upstream is in BYTES already, otherwise
           * we&#39;re not in charge */
          if (format == GST_FORMAT_BYTES
              &amp;&amp; parse-&gt;priv-&gt;upstream_format == GST_FORMAT_BYTES) {
<span class="line-modified">!         dest_value = parse-&gt;priv-&gt;offset;</span>
<span class="line-modified">!         res = TRUE;</span>
<span class="line-modified">!       } else if (format == parse-&gt;segment.format &amp;&amp;</span>
              GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.position)) {
            dest_value = gst_segment_to_stream_time (&amp;parse-&gt;segment,
                parse-&gt;segment.format, parse-&gt;segment.position);
<span class="line-modified">!         res = TRUE;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       GST_OBJECT_UNLOCK (parse);</span>
          if (!res &amp;&amp; parse-&gt;priv-&gt;upstream_format == GST_FORMAT_BYTES) {
            /* no precise result, upstream no idea either, then best estimate */
            /* priv-&gt;offset is updated in both PUSH/PULL modes, *iff* we&#39;re
             * in charge of things */
            res = gst_base_parse_convert (parse,
<span class="line-new-header">--- 4102,24 ---</span>
  
        /* try upstream first */
        res = gst_pad_query_default (pad, GST_OBJECT_CAST (parse), query);
        if (!res) {
          /* Fall back on interpreting segment */
<span class="line-modified">!         GST_OBJECT_LOCK (parse);</span>
          /* Only reply BYTES if upstream is in BYTES already, otherwise
           * we&#39;re not in charge */
          if (format == GST_FORMAT_BYTES
              &amp;&amp; parse-&gt;priv-&gt;upstream_format == GST_FORMAT_BYTES) {
<span class="line-modified">!           dest_value = parse-&gt;priv-&gt;offset;</span>
<span class="line-modified">!           res = TRUE;</span>
<span class="line-modified">!         } else if (format == parse-&gt;segment.format &amp;&amp;</span>
              GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.position)) {
            dest_value = gst_segment_to_stream_time (&amp;parse-&gt;segment,
                parse-&gt;segment.format, parse-&gt;segment.position);
<span class="line-modified">!           res = TRUE;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         GST_OBJECT_UNLOCK (parse);</span>
          if (!res &amp;&amp; parse-&gt;priv-&gt;upstream_format == GST_FORMAT_BYTES) {
            /* no precise result, upstream no idea either, then best estimate */
            /* priv-&gt;offset is updated in both PUSH/PULL modes, *iff* we&#39;re
             * in charge of things */
            res = gst_base_parse_convert (parse,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4189,11 ***</span>
              GST_TIME_FORMAT &quot; max %&quot; GST_TIME_FORMAT, live,
              GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
  
          GST_OBJECT_LOCK (parse);
          /* add our latency */
<span class="line-modified">!           min_latency += parse-&gt;priv-&gt;min_latency;</span>
          if (max_latency == -1 || parse-&gt;priv-&gt;max_latency == -1)
            max_latency = -1;
          else
            max_latency += parse-&gt;priv-&gt;max_latency;
          GST_OBJECT_UNLOCK (parse);
<span class="line-new-header">--- 4215,11 ---</span>
              GST_TIME_FORMAT &quot; max %&quot; GST_TIME_FORMAT, live,
              GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
  
          GST_OBJECT_LOCK (parse);
          /* add our latency */
<span class="line-modified">!         min_latency += parse-&gt;priv-&gt;min_latency;</span>
          if (max_latency == -1 || parse-&gt;priv-&gt;max_latency == -1)
            max_latency = -1;
          else
            max_latency += parse-&gt;priv-&gt;max_latency;
          GST_OBJECT_UNLOCK (parse);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4590,11 ***</span>
      seekpos = gst_base_parse_find_offset (parse, startpos, TRUE, &amp;start_ts);
      seekstop = gst_base_parse_find_offset (parse, seeksegment.stop, FALSE,
          NULL);
    } else {
      if (rate &gt;= 0)
<span class="line-modified">!     start_ts = seeksegment.position;</span>
      else
        start_ts = start;
  
      if (seeksegment.stop == -1 &amp;&amp; seeksegment.duration != -1)
        seeksegment.stop = seeksegment.start + seeksegment.duration;
<span class="line-new-header">--- 4616,11 ---</span>
      seekpos = gst_base_parse_find_offset (parse, startpos, TRUE, &amp;start_ts);
      seekstop = gst_base_parse_find_offset (parse, seeksegment.stop, FALSE,
          NULL);
    } else {
      if (rate &gt;= 0)
<span class="line-modified">!       start_ts = seeksegment.position;</span>
      else
        start_ts = start;
  
      if (seeksegment.stop == -1 &amp;&amp; seeksegment.duration != -1)
        seeksegment.stop = seeksegment.start + seeksegment.duration;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4753,11 ***</span>
        g_free (seek);
      }
    }
  
  done:
<span class="line-modified">!     gst_event_unref (event);</span>
    return res;
  
    /* ERRORS */
  negative_rate:
    {
<span class="line-new-header">--- 4779,11 ---</span>
        g_free (seek);
      }
    }
  
  done:
<span class="line-modified">!   gst_event_unref (event);</span>
    return res;
  
    /* ERRORS */
  negative_rate:
    {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4801,11 ***</span>
  
    if (taglist != NULL)
      parse-&gt;priv-&gt;upstream_tags = gst_tag_list_ref (taglist);
  
    gst_base_parse_check_bitrate_tags (parse);
<span class="line-modified">!   }</span>
  
  #if 0
  static void
  gst_base_parse_set_index (GstElement * element, GstIndex * index)
  {
<span class="line-new-header">--- 4827,11 ---</span>
  
    if (taglist != NULL)
      parse-&gt;priv-&gt;upstream_tags = gst_tag_list_ref (taglist);
  
    gst_base_parse_check_bitrate_tags (parse);
<span class="line-modified">! }</span>
  
  #if 0
  static void
  gst_base_parse_set_index (GstElement * element, GstIndex * index)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4922,11 ***</span>
      parse-&gt;priv-&gt;prev_pts = parse-&gt;priv-&gt;next_pts = pts;
  
    if (GST_CLOCK_TIME_IS_VALID (dts) &amp;&amp; (parse-&gt;priv-&gt;prev_dts != dts)) {
      parse-&gt;priv-&gt;prev_dts = parse-&gt;priv-&gt;next_dts = dts;
      parse-&gt;priv-&gt;prev_dts_from_pts = FALSE;
<span class="line-modified">! }</span>
  }
  
  /**
   * gst_base_parse_merge_tags:
   * @parse: a #GstBaseParse
<span class="line-new-header">--- 4948,11 ---</span>
      parse-&gt;priv-&gt;prev_pts = parse-&gt;priv-&gt;next_pts = pts;
  
    if (GST_CLOCK_TIME_IS_VALID (dts) &amp;&amp; (parse-&gt;priv-&gt;prev_dts != dts)) {
      parse-&gt;priv-&gt;prev_dts = parse-&gt;priv-&gt;next_dts = dts;
      parse-&gt;priv-&gt;prev_dts_from_pts = FALSE;
<span class="line-modified">!   }</span>
  }
  
  /**
   * gst_base_parse_merge_tags:
   * @parse: a #GstBaseParse
</pre>
<center><a href="gstadapter.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstbaseparse.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>