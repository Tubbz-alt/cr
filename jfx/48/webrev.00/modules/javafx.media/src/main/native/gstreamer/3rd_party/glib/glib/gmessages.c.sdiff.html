<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmessages.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gmem.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gmessages.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmessages.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  29 /**
  30  * SECTION:messages
  31  * @Title: Message Output and Debugging Functions
  32  * @Short_description: functions to output messages and help debug applications
  33  *
  34  * These functions provide support for outputting messages.
  35  *
  36  * The g_return family of macros (g_return_if_fail(),
  37  * g_return_val_if_fail(), g_return_if_reached(),
  38  * g_return_val_if_reached()) should only be used for programming
  39  * errors, a typical use case is checking for invalid parameters at
  40  * the beginning of a public function. They should not be used if
  41  * you just mean &quot;if (error) return&quot;, they should only be used if
  42  * you mean &quot;if (bug in program) return&quot;. The program behavior is
  43  * generally considered undefined after one of these checks fails.
  44  * They are not intended for normal control flow, only to give a
  45  * perhaps-helpful warning before giving up.
  46  *
  47  * Structured logging output is supported using g_log_structured(). This differs
  48  * from the traditional g_log() API in that log messages are handled as a
<span class="line-modified">  49  * collection of key�value pairs representing individual pieces of information,</span>
  50  * rather than as a single string containing all the information in an arbitrary
  51  * format.
  52  *
  53  * The convenience macros g_info(), g_message(), g_debug(), g_warning() and g_error()
  54  * will use the traditional g_log() API unless you define the symbol
  55  * %G_LOG_USE_STRUCTURED before including `glib.h`. But note that even messages
  56  * logged through the traditional g_log() API are ultimatively passed to
  57  * g_log_structured(), so that all log messages end up in same destination.
  58  * If %G_LOG_USE_STRUCTURED is defined, g_test_expect_message() will become
  59  * ineffective for the wrapper macros g_warning() and friends (see
  60  * [Testing for Messages][testing-for-messages]).
  61  *
  62  * The support for structured logging was motivated by the following needs (some
<span class="line-modified">  63  * of which were supported previously; others weren�t):</span>
  64  *  * Support for multiple logging levels.
  65  *  * Structured log support with the ability to add `MESSAGE_ID`s (see
  66  *    g_log_structured()).
  67  *  * Moving the responsibility for filtering log messages from the program to
<span class="line-modified">  68  *    the log viewer � instead of libraries and programs installing log handlers</span>
  69  *    (with g_log_set_handler()) which filter messages before output, all log
  70  *    messages are outputted, and the log viewer program (such as `journalctl`)
  71  *    must filter them. This is based on the idea that bugs are sometimes hard
  72  *    to reproduce, so it is better to log everything possible and then use
  73  *    tools to analyse the logs than it is to not be able to reproduce a bug to
  74  *    get additional log data. Code which uses logging in performance-critical
  75  *    sections should compile out the g_log_structured() calls in
  76  *    release builds, and compile them in in debugging builds.
  77  *  * A single writer function which handles all log messages in a process, from
  78  *    all libraries and program code; rather than multiple log handlers with
  79  *    poorly defined interactions between them. This allows a program to easily
  80  *    change its logging policy by changing the writer function, for example to
  81  *    log to an additional location or to change what logging output fallbacks
  82  *    are used. The log writer functions provided by GLib are exposed publicly
<span class="line-modified">  83  *    so they can be used from programs� log writers. This allows log writer</span>
  84  *    policy and implementation to be kept separate.
  85  *  * If a library wants to add standard information to all of its log messages
  86  *    (such as library state) or to redact private data (such as passwords or
  87  *    network credentials), it should use a wrapper function around its
  88  *    g_log_structured() calls or implement that in the single log writer
  89  *    function.
  90  *  * If a program wants to pass context data from a g_log_structured() call to
  91  *    its log writer function so that, for example, it can use the correct
  92  *    server connection to submit logs to, that user data can be passed as a
  93  *    zero-length #GLogField to g_log_structured_array().
  94  *  * Color output needed to be supported on the terminal, to make reading
  95  *    through logs easier.
  96  *
  97  * ## Using Structured Logging ## {#using-structured-logging}
  98  *
  99  * To use structured logging (rather than the old-style logging), either use
 100  * the g_log_structured() and g_log_structured_array() functions; or define
 101  * `G_LOG_USE_STRUCTURED` before including any GLib header, and use the
 102  * g_message(), g_debug(), g_error() (etc.) macros.
 103  *
 104  * You do not need to define `G_LOG_USE_STRUCTURED` to use g_log_structured(),
 105  * but it is a good idea to avoid confusion.
 106  *
 107  * ## Log Domains ## {#log-domains}
 108  *
 109  * Log domains may be used to broadly split up the origins of log messages.
 110  * Typically, there are one or a few log domains per application or library.
 111  * %G_LOG_DOMAIN should be used to define the default log domain for the current
<span class="line-modified"> 112  * compilation unit � it is typically defined at the top of a source file, or in</span>
 113  * the preprocessor flags for a group of source files.
 114  *
 115  * Log domains must be unique, and it is recommended that they are the
 116  * application or library name, optionally followed by a hyphen and a sub-domain
 117  * name. For example, `bloatpad` or `bloatpad-io`.
 118  *
 119  * ## Debug Message Output ## {#debug-message-output}
 120  *
 121  * The default log functions (g_log_default_handler() for the old-style API and
 122  * g_log_writer_default() for the structured API) both drop debug and
 123  * informational messages by default, unless the log domains of those messages
 124  * are listed in the `G_MESSAGES_DEBUG` environment variable (or it is set to
 125  * `all`).
 126  *
 127  * It is recommended that custom log writer functions re-use the
 128  * `G_MESSAGES_DEBUG` environment variable, rather than inventing a custom one,
 129  * so that developers can re-use the same debugging techniques and tools across
 130  * projects.
 131  *
 132  * ## Testing for Messages ## {#testing-for-messages}
</pre>
<hr />
<pre>
 140  *    cases, where messages might be emitted in several orders, some
 141  *    messages might not be emitted deterministically, or messages might be
 142  *    emitted by unrelated log domains.
 143  *  * They do not support structured log fields.
 144  *  * Examining the log output of code is a bad approach to testing it, and
 145  *    while it might be necessary for legacy code which uses g_log(), it should
 146  *    be avoided for new code using g_log_structured().
 147  *
 148  * They will continue to work as before if g_log() is in use (and
 149  * %G_LOG_USE_STRUCTURED is not defined). They will do nothing if used with the
 150  * structured logging API.
 151  *
 152  * Examining the log output of code is discouraged: libraries should not emit to
 153  * `stderr` during defined behaviour, and hence this should not be tested. If
 154  * the log emissions of a library during undefined behaviour need to be tested,
 155  * they should be limited to asserting that the library aborts and prints a
 156  * suitable error message before aborting. This should be done with
 157  * g_test_trap_assert_stderr().
 158  *
 159  * If it is really necessary to test the structured log messages emitted by a
<span class="line-modified"> 160  * particular piece of code � and the code cannot be restructured to be more</span>
<span class="line-modified"> 161  * suitable to more conventional unit testing � you should write a custom log</span>
 162  * writer function (see g_log_set_writer_func()) which appends all log messages
 163  * to a queue. When you want to check the log messages, examine and clear the
 164  * queue, ignoring irrelevant log messages (for example, from log domains other
 165  * than the one under test).
 166  */
 167 
 168 #include &quot;config.h&quot;
 169 
 170 #include &lt;stdlib.h&gt;
 171 #include &lt;stdarg.h&gt;
 172 #include &lt;stdio.h&gt;
 173 #include &lt;string.h&gt;
 174 #include &lt;signal.h&gt;
 175 #include &lt;locale.h&gt;
 176 #include &lt;errno.h&gt;
 177 
 178 #if defined(__linux__) &amp;&amp; !defined(__BIONIC__)
 179 #include &lt;sys/types.h&gt;
 180 #include &lt;sys/socket.h&gt;
 181 #include &lt;sys/un.h&gt;
</pre>
<hr />
<pre>
 186 #include &quot;glib-init.h&quot;
 187 #include &quot;galloca.h&quot;
 188 #include &quot;gbacktrace.h&quot;
 189 #include &quot;gcharset.h&quot;
 190 #include &quot;gconvert.h&quot;
 191 #include &quot;genviron.h&quot;
 192 #include &quot;gmain.h&quot;
 193 #include &quot;gmem.h&quot;
 194 #include &quot;gprintfint.h&quot;
 195 #include &quot;gtestutils.h&quot;
 196 #include &quot;gthread.h&quot;
 197 #include &quot;gstrfuncs.h&quot;
 198 #include &quot;gstring.h&quot;
 199 #include &quot;gpattern.h&quot;
 200 
 201 #ifdef G_OS_UNIX
 202 #include &lt;unistd.h&gt;
 203 #endif
 204 
 205 #ifdef G_OS_WIN32
<span class="line-modified"> 206 #include &lt;process.h&gt;        /* For getpid() */</span>
 207 #include &lt;io.h&gt;
 208 #  include &lt;windows.h&gt;
 209 
 210 #ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING
 211 #define ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004
 212 #endif
 213 
 214 #if defined (_MSC_VER) &amp;&amp; (_MSC_VER &gt;=1400)
 215 /* This is ugly, but we need it for isatty() in case we have bad fd&#39;s,
 216  * otherwise Windows will abort() the program on msvcrt80.dll and later
 217  */
 218 #include &lt;crtdbg.h&gt;
 219 
 220 _GLIB_EXTERN void
 221 myInvalidParameterHandler(const wchar_t *expression,
 222                           const wchar_t *function,
 223                           const wchar_t *file,
 224                           unsigned int   line,
 225                           uintptr_t      pReserved)
 226 {
</pre>
<hr />
<pre>
 476  * If g_log_default_handler() is used as the log handler function, a new-line
 477  * character will automatically be appended to @..., and need not be entered
 478  * manually.
 479  *
 480  * Such messages are suppressed by the g_log_default_handler() and
 481  * g_log_writer_default() unless the `G_MESSAGES_DEBUG` environment variable is
 482  * set appropriately.
 483  *
 484  * If structured logging is enabled, this will use g_log_structured();
 485  * otherwise it will use g_log(). See
 486  * [Using Structured Logging][using-structured-logging].
 487  *
 488  * Since: 2.6
 489  */
 490 
 491 /* --- structures --- */
 492 typedef struct _GLogDomain  GLogDomain;
 493 typedef struct _GLogHandler GLogHandler;
 494 struct _GLogDomain
 495 {
<span class="line-modified"> 496   gchar     *log_domain;</span>
 497   GLogLevelFlags fatal_mask;
<span class="line-modified"> 498   GLogHandler   *handlers;</span>
<span class="line-modified"> 499   GLogDomain    *next;</span>
 500 };
 501 struct _GLogHandler
 502 {
<span class="line-modified"> 503   guint      id;</span>
 504   GLogLevelFlags log_level;
 505   GLogFunc   log_func;
 506   gpointer   data;
 507   GDestroyNotify destroy;
<span class="line-modified"> 508   GLogHandler   *next;</span>
 509 };
 510 
 511 
 512 /* --- variables --- */
 513 static GMutex         g_messages_lock;
 514 static GLogDomain    *g_log_domains = NULL;
 515 static GPrintFunc     glib_print_func = NULL;
 516 static GPrintFunc     glib_printerr_func = NULL;
 517 static GPrivate       g_log_depth;
 518 static GPrivate       g_log_structured_depth;
 519 static GLogFunc       default_log_func = g_log_default_handler;
 520 static gpointer       default_log_data = NULL;
 521 static GTestLogFatalFunc fatal_log_func = NULL;
 522 static gpointer          fatal_log_data;
 523 static GLogWriterFunc log_writer_func = g_log_writer_default;
 524 static gpointer       log_writer_user_data = NULL;
 525 static GDestroyNotify log_writer_user_data_free = NULL;
 526 
 527 /* --- functions --- */
 528 
</pre>
<hr />
<pre>
 552 
 553   if (debugger_present &amp;&amp; breakpoint)
 554     G_BREAKPOINT ();
 555   else
 556     g_abort ();
 557 }
 558 
 559 #ifdef G_OS_WIN32
 560 static gboolean win32_keep_fatal_message = FALSE;
 561 
 562 /* This default message will usually be overwritten. */
 563 /* Yes, a fixed size buffer is bad. So sue me. But g_error() is never
 564  * called with huge strings, is it?
 565  */
 566 static gchar  fatal_msg_buf[1000] = &quot;Unspecified fatal error encountered, aborting.&quot;;
 567 static gchar *fatal_msg_ptr = fatal_msg_buf;
 568 
 569 #undef write
 570 static inline int
 571 dowrite (int          fd,
<span class="line-modified"> 572      const void  *buf,</span>
<span class="line-modified"> 573      unsigned int len)</span>
 574 {
 575   if (win32_keep_fatal_message)
 576     {
 577       memcpy (fatal_msg_ptr, buf, len);
 578       fatal_msg_ptr += len;
 579       *fatal_msg_ptr = 0;
 580       return len;
 581     }
 582 
 583   write (fd, buf, len);
 584 
 585   return len;
 586 }
 587 #define write(fd, buf, len) dowrite(fd, buf, len)
 588 
 589 #endif
 590 
 591 static void
 592 write_string (FILE        *stream,
<span class="line-modified"> 593           const gchar *string)</span>
 594 {
 595   fputs (string, stream);
 596 }
 597 
 598 static void
 599 write_string_sized (FILE        *stream,
 600                     const gchar *string,
 601                     gssize       length)
 602 {
 603   /* Is it nul-terminated? */
 604   if (length &lt; 0)
 605     write_string (stream, string);
 606   else
 607     fwrite (string, 1, length, stream);
 608 }
 609 
 610 static GLogDomain*
 611 g_log_find_domain_L (const gchar *log_domain)
 612 {
 613   GLogDomain *domain;
 614 
 615   domain = g_log_domains;
 616   while (domain)
 617     {
 618       if (strcmp (domain-&gt;log_domain, log_domain) == 0)
<span class="line-modified"> 619     return domain;</span>
 620       domain = domain-&gt;next;
 621     }
 622   return NULL;
 623 }
 624 
 625 static GLogDomain*
 626 g_log_domain_new_L (const gchar *log_domain)
 627 {
 628   GLogDomain *domain;
 629 
 630   domain = g_new (GLogDomain, 1);
 631   domain-&gt;log_domain = g_strdup (log_domain);
 632   domain-&gt;fatal_mask = G_LOG_FATAL_MASK;
 633   domain-&gt;handlers = NULL;
 634 
 635   domain-&gt;next = g_log_domains;
 636   g_log_domains = domain;
 637 
 638   return domain;
 639 }
 640 
 641 static void
 642 g_log_domain_check_free_L (GLogDomain *domain)
 643 {
 644   if (domain-&gt;fatal_mask == G_LOG_FATAL_MASK &amp;&amp;
 645       domain-&gt;handlers == NULL)
 646     {
 647       GLogDomain *last, *work;
 648 
 649       last = NULL;
 650 
 651       work = g_log_domains;
 652       while (work)
<span class="line-modified"> 653     {</span>
<span class="line-modified"> 654       if (work == domain)</span>
<span class="line-modified"> 655         {</span>
<span class="line-modified"> 656           if (last)</span>
<span class="line-modified"> 657         last-&gt;next = domain-&gt;next;</span>
<span class="line-modified"> 658           else</span>
<span class="line-modified"> 659         g_log_domains = domain-&gt;next;</span>
<span class="line-modified"> 660           g_free (domain-&gt;log_domain);</span>
<span class="line-modified"> 661           g_free (domain);</span>
<span class="line-modified"> 662           break;</span>
<span class="line-modified"> 663         }</span>
<span class="line-modified"> 664       last = work;</span>
<span class="line-modified"> 665       work = last-&gt;next;</span>
<span class="line-modified"> 666     }</span>
 667     }
 668 }
 669 
 670 static GLogFunc
 671 g_log_domain_get_handler_L (GLogDomain  *domain,
<span class="line-modified"> 672                             GLogLevelFlags log_level,</span>
<span class="line-modified"> 673                 gpointer    *data)</span>
 674 {
 675   if (domain &amp;&amp; log_level)
 676     {
 677       GLogHandler *handler;
 678 
 679       handler = domain-&gt;handlers;
 680       while (handler)
<span class="line-modified"> 681     {</span>
<span class="line-modified"> 682       if ((handler-&gt;log_level &amp; log_level) == log_level)</span>
<span class="line-modified"> 683         {</span>
<span class="line-modified"> 684           *data = handler-&gt;data;</span>
<span class="line-modified"> 685           return handler-&gt;log_func;</span>
<span class="line-modified"> 686         }</span>
<span class="line-modified"> 687       handler = handler-&gt;next;</span>
<span class="line-modified"> 688     }</span>
 689     }
 690 
 691   *data = default_log_data;
 692   return default_log_func;
 693 }
 694 
 695 /**
 696  * g_log_set_always_fatal:
 697  * @fatal_mask: the mask containing bits set for each level
 698  *     of error which is to be fatal
 699  *
 700  * Sets the message levels which are always fatal, in any log domain.
 701  * When a message with any of these levels is logged the program terminates.
 702  * You can only set the levels defined by GLib to be fatal.
 703  * %G_LOG_LEVEL_ERROR is always fatal.
 704  *
 705  * You can also make some message levels fatal at runtime by setting
 706  * the `G_DEBUG` environment variable (see
 707  * [Running GLib Applications](glib-running.html)).
 708  *
</pre>
<hr />
<pre>
 744  * @fatal_mask: the new fatal mask
 745  *
 746  * Sets the log levels which are fatal in the given domain.
 747  * %G_LOG_LEVEL_ERROR is always fatal.
 748  *
 749  * This has no effect on structured log messages (using g_log_structured() or
 750  * g_log_structured_array()). To change the fatal behaviour for specific log
 751  * messages, programs must install a custom log writer function using
 752  * g_log_set_writer_func(). See
 753  * [Using Structured Logging][using-structured-logging].
 754  *
 755  * This function is mostly intended to be used with
 756  * %G_LOG_LEVEL_CRITICAL.  You should typically not set
 757  * %G_LOG_LEVEL_WARNING, %G_LOG_LEVEL_MESSAGE, %G_LOG_LEVEL_INFO or
 758  * %G_LOG_LEVEL_DEBUG as fatal except inside of test programs.
 759  *
 760  * Returns: the old fatal mask for the log domain
 761  */
 762 GLogLevelFlags
 763 g_log_set_fatal_mask (const gchar   *log_domain,
<span class="line-modified"> 764               GLogLevelFlags fatal_mask)</span>
 765 {
 766   GLogLevelFlags old_flags;
 767   GLogDomain *domain;
 768 
 769   if (!log_domain)
 770     log_domain = &quot;&quot;;
 771 
 772   /* force errors to be fatal */
 773   fatal_mask |= G_LOG_LEVEL_ERROR;
 774   /* remove bogus flag */
 775   fatal_mask &amp;= ~G_LOG_FLAG_FATAL;
 776 
 777   g_mutex_lock (&amp;g_messages_lock);
 778 
 779   domain = g_log_find_domain_L (log_domain);
 780   if (!domain)
 781     domain = g_log_domain_new_L (log_domain);
 782   old_flags = domain-&gt;fatal_mask;
 783 
 784   domain-&gt;fatal_mask = fatal_mask;
</pre>
<hr />
<pre>
 903 
 904 /**
 905  * g_log_set_default_handler:
 906  * @log_func: the log handler function
 907  * @user_data: data passed to the log handler
 908  *
 909  * Installs a default log handler which is used if no
 910  * log handler has been set for the particular log domain
 911  * and log level combination. By default, GLib uses
 912  * g_log_default_handler() as default log handler.
 913  *
 914  * This has no effect if structured logging is enabled; see
 915  * [Using Structured Logging][using-structured-logging].
 916  *
 917  * Returns: the previous default log handler
 918  *
 919  * Since: 2.6
 920  */
 921 GLogFunc
 922 g_log_set_default_handler (GLogFunc log_func,
<span class="line-modified"> 923                gpointer user_data)</span>
 924 {
 925   GLogFunc old_log_func;
 926 
 927   g_mutex_lock (&amp;g_messages_lock);
 928   old_log_func = default_log_func;
 929   default_log_func = log_func;
 930   default_log_data = user_data;
 931   g_mutex_unlock (&amp;g_messages_lock);
 932 
 933   return old_log_func;
 934 }
 935 
 936 /**
 937  * g_test_log_set_fatal_handler:
 938  * @log_func: the log handler function.
 939  * @user_data: data passed to the log handler.
 940  *
 941  * Installs a non-error fatal log handler which can be
 942  * used to decide whether log messages which are counted
 943  * as fatal abort the program.
</pre>
<hr />
<pre>
 968 {
 969   g_mutex_lock (&amp;g_messages_lock);
 970   fatal_log_func = log_func;
 971   fatal_log_data = user_data;
 972   g_mutex_unlock (&amp;g_messages_lock);
 973 }
 974 
 975 /**
 976  * g_log_remove_handler:
 977  * @log_domain: the log domain
 978  * @handler_id: the id of the handler, which was returned
 979  *     in g_log_set_handler()
 980  *
 981  * Removes the log handler.
 982  *
 983  * This has no effect if structured logging is enabled; see
 984  * [Using Structured Logging][using-structured-logging].
 985  */
 986 void
 987 g_log_remove_handler (const gchar *log_domain,
<span class="line-modified"> 988               guint    handler_id)</span>
 989 {
 990   GLogDomain *domain;
 991 
 992   g_return_if_fail (handler_id &gt; 0);
 993 
 994   if (!log_domain)
 995     log_domain = &quot;&quot;;
 996 
 997   g_mutex_lock (&amp;g_messages_lock);
 998   domain = g_log_find_domain_L (log_domain);
 999   if (domain)
1000     {
1001       GLogHandler *work, *last;
1002 
1003       last = NULL;
1004       work = domain-&gt;handlers;
1005       while (work)
<span class="line-modified">1006     {</span>
<span class="line-modified">1007       if (work-&gt;id == handler_id)</span>
<span class="line-modified">1008         {</span>
<span class="line-modified">1009           if (last)</span>
<span class="line-modified">1010         last-&gt;next = work-&gt;next;</span>
<span class="line-modified">1011           else</span>
<span class="line-modified">1012         domain-&gt;handlers = work-&gt;next;</span>
<span class="line-modified">1013           g_log_domain_check_free_L (domain);</span>
<span class="line-modified">1014           g_mutex_unlock (&amp;g_messages_lock);</span>
1015               if (work-&gt;destroy)
1016                 work-&gt;destroy (work-&gt;data);
<span class="line-modified">1017           g_free (work);</span>
<span class="line-modified">1018           return;</span>
<span class="line-modified">1019         }</span>
<span class="line-modified">1020       last = work;</span>
<span class="line-modified">1021       work = last-&gt;next;</span>
<span class="line-modified">1022     }</span>
1023     }
1024   g_mutex_unlock (&amp;g_messages_lock);
1025   g_warning (&quot;%s: could not find handler with id &#39;%d&#39; for domain \&quot;%s\&quot;&quot;,
<span class="line-modified">1026          G_STRLOC, handler_id, log_domain);</span>
1027 }
1028 
1029 #define CHAR_IS_SAFE(wc) (!((wc &lt; 0x20 &amp;&amp; wc != &#39;\t&#39; &amp;&amp; wc != &#39;\n&#39; &amp;&amp; wc != &#39;\r&#39;) || \
<span class="line-modified">1030                 (wc == 0x7f) || \</span>
<span class="line-modified">1031                 (wc &gt;= 0x80 &amp;&amp; wc &lt; 0xa0)))</span>
1032 
1033 static gchar*
1034 strdup_convert (const gchar *string,
<span class="line-modified">1035         const gchar *charset)</span>
1036 {
1037   if (!g_utf8_validate (string, -1, NULL))
1038     {
1039       GString *gstring = g_string_new (&quot;[Invalid UTF-8] &quot;);
1040       guchar *p;
1041 
1042       for (p = (guchar *)string; *p; p++)
<span class="line-modified">1043     {</span>
<span class="line-modified">1044       if (CHAR_IS_SAFE(*p) &amp;&amp;</span>
<span class="line-modified">1045           !(*p == &#39;\r&#39; &amp;&amp; *(p + 1) != &#39;\n&#39;) &amp;&amp;</span>
<span class="line-modified">1046           *p &lt; 0x80)</span>
<span class="line-modified">1047         g_string_append_c (gstring, *p);</span>
<span class="line-modified">1048       else</span>
<span class="line-modified">1049         g_string_append_printf (gstring, &quot;\\x%02x&quot;, (guint)(guchar)*p);</span>
<span class="line-modified">1050     }</span>
1051 
1052       return g_string_free (gstring, FALSE);
1053     }
1054   else
1055     {
1056       GError *err = NULL;
1057 
1058       gchar *result = g_convert_with_fallback (string, -1, charset, &quot;UTF-8&quot;, &quot;?&quot;, NULL, NULL, &amp;err);
1059       if (result)
<span class="line-modified">1060     return result;</span>
1061       else
<span class="line-modified">1062     {</span>
<span class="line-modified">1063       /* Not thread-safe, but doesn&#39;t matter if we print the warning twice</span>
<span class="line-modified">1064        */</span>
<span class="line-modified">1065       static gboolean warned = FALSE;</span>
<span class="line-modified">1066       if (!warned)</span>
<span class="line-modified">1067         {</span>
<span class="line-modified">1068           warned = TRUE;</span>
<span class="line-modified">1069           _g_fprintf (stderr, &quot;GLib: Cannot convert message: %s\n&quot;, err-&gt;message);</span>
<span class="line-modified">1070         }</span>
<span class="line-modified">1071       g_error_free (err);</span>
<span class="line-modified">1072 </span>
<span class="line-modified">1073       return g_strdup (string);</span>
<span class="line-modified">1074     }</span>
1075     }
1076 }
1077 
1078 /* For a radix of 8 we need at most 3 output bytes for 1 input
1079  * byte. Additionally we might need up to 2 output bytes for the
1080  * readix prefix and 1 byte for the trailing NULL.
1081  */
1082 #define FORMAT_UNSIGNED_BUFSIZE ((GLIB_SIZEOF_LONG * 3) + 3)
1083 
1084 static void
1085 format_unsigned (gchar  *buf,
<span class="line-modified">1086          gulong  num,</span>
<span class="line-modified">1087          guint   radix)</span>
1088 {
1089   gulong tmp;
1090   gchar c;
1091   gint i, n;
1092 
1093   /* we may not call _any_ GLib functions here (or macros like g_return_if_fail()) */
1094 
1095   if (radix != 8 &amp;&amp; radix != 10 &amp;&amp; radix != 16)
1096     {
1097       *buf = &#39;\000&#39;;
1098       return;
1099     }
1100 
1101   if (!num)
1102     {
1103       *buf++ = &#39;0&#39;;
1104       *buf = &#39;\000&#39;;
1105       return;
1106     }
1107 
</pre>
<hr />
<pre>
1120   while (tmp)
1121     {
1122       tmp /= radix;
1123       n++;
1124     }
1125 
1126   i = n;
1127 
1128   /* Again we can&#39;t use g_assert; actually this check should _never_ fail. */
1129   if (n &gt; FORMAT_UNSIGNED_BUFSIZE - 3)
1130     {
1131       *buf = &#39;\000&#39;;
1132       return;
1133     }
1134 
1135   while (num)
1136     {
1137       i--;
1138       c = (num % radix);
1139       if (c &lt; 10)
<span class="line-modified">1140     buf[i] = c + &#39;0&#39;;</span>
1141       else
<span class="line-modified">1142     buf[i] = c + &#39;a&#39; - 10;</span>
1143       num /= radix;
1144     }
1145 
1146   buf[n] = &#39;\000&#39;;
1147 }
1148 
1149 /* string size big enough to hold level prefix */
1150 #define STRING_BUFFER_SIZE  (FORMAT_UNSIGNED_BUFSIZE + 32)
1151 
<span class="line-modified">1152 #define ALERT_LEVELS        (G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING)</span>
1153 
1154 /* these are emitted by the default log handler */
1155 #define DEFAULT_LEVELS (G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING | G_LOG_LEVEL_MESSAGE)
1156 /* these are filtered by G_MESSAGES_DEBUG by the default log handler */
1157 #define INFO_LEVELS (G_LOG_LEVEL_INFO | G_LOG_LEVEL_DEBUG)
1158 
1159 static const gchar *log_level_to_color (GLogLevelFlags log_level,
1160                                         gboolean       use_color);
1161 static const gchar *color_reset        (gboolean       use_color);
1162 
1163 static FILE *
1164 mklevel_prefix (gchar          level_prefix[STRING_BUFFER_SIZE],
1165                 GLogLevelFlags log_level,
1166                 gboolean       use_color)
1167 {
1168   gboolean to_stdout = TRUE;
1169 
1170   /* we may not call _any_ GLib functions here */
1171 
1172   strcpy (level_prefix, log_level_to_color (log_level, use_color));
</pre>
<hr />
<pre>
1180     case G_LOG_LEVEL_CRITICAL:
1181       strcat (level_prefix, &quot;CRITICAL&quot;);
1182       to_stdout = FALSE;
1183       break;
1184     case G_LOG_LEVEL_WARNING:
1185       strcat (level_prefix, &quot;WARNING&quot;);
1186       to_stdout = FALSE;
1187       break;
1188     case G_LOG_LEVEL_MESSAGE:
1189       strcat (level_prefix, &quot;Message&quot;);
1190       to_stdout = FALSE;
1191       break;
1192     case G_LOG_LEVEL_INFO:
1193       strcat (level_prefix, &quot;INFO&quot;);
1194       break;
1195     case G_LOG_LEVEL_DEBUG:
1196       strcat (level_prefix, &quot;DEBUG&quot;);
1197       break;
1198     default:
1199       if (log_level)
<span class="line-modified">1200     {</span>
<span class="line-modified">1201       strcat (level_prefix, &quot;LOG-&quot;);</span>
<span class="line-modified">1202       format_unsigned (level_prefix + 4, log_level &amp; G_LOG_LEVEL_MASK, 16);</span>
<span class="line-modified">1203     }</span>
1204       else
<span class="line-modified">1205     strcat (level_prefix, &quot;LOG&quot;);</span>
1206       break;
1207     }
1208 
1209   strcat (level_prefix, color_reset (use_color));
1210 
1211   if (log_level &amp; G_LOG_FLAG_RECURSION)
1212     strcat (level_prefix, &quot; (recursed)&quot;);
1213   if (log_level &amp; ALERT_LEVELS)
1214     strcat (level_prefix, &quot; **&quot;);
1215 
1216 #ifdef G_OS_WIN32
1217   if ((log_level &amp; G_LOG_FLAG_FATAL) != 0 &amp;&amp; !g_test_initialized ())
1218     win32_keep_fatal_message = TRUE;
1219 #endif
1220   return to_stdout ? stdout : stderr;
1221 }
1222 
1223 typedef struct {
1224   gchar          *log_domain;
1225   GLogLevelFlags  log_level;
</pre>
<hr />
<pre>
1234  * application domain
1235  * @log_level: the log level
1236  * @format: the message format. See the printf() documentation
1237  * @args: the parameters to insert into the format string
1238  *
1239  * Logs an error or debugging message.
1240  *
1241  * If the log level has been set as fatal, G_BREAKPOINT() is called
1242  * to terminate the program. See the documentation for G_BREAKPOINT() for
1243  * details of the debugging options this provides.
1244  *
1245  * If g_log_default_handler() is used as the log handler function, a new-line
1246  * character will automatically be appended to @..., and need not be entered
1247  * manually.
1248  *
1249  * If [structured logging is enabled][using-structured-logging] this will
1250  * output via the structured log writer function (see g_log_set_writer_func()).
1251  */
1252 void
1253 g_logv (const gchar   *log_domain,
<span class="line-modified">1254         GLogLevelFlags log_level,</span>
<span class="line-modified">1255         const gchar   *format,</span>
<span class="line-modified">1256     va_list        args)</span>
1257 {
1258   gboolean was_fatal = (log_level &amp; G_LOG_FLAG_FATAL) != 0;
1259   gboolean was_recursion = (log_level &amp; G_LOG_FLAG_RECURSION) != 0;
1260   gchar buffer[1025], *msg, *msg_alloc = NULL;
1261   gint i;
1262 
1263   log_level &amp;= G_LOG_LEVEL_MASK;
1264   if (!log_level)
1265     return;
1266 
1267   if (log_level &amp; G_LOG_FLAG_RECURSION)
1268     {
1269       /* we use a stack buffer of fixed size, since we&#39;re likely
1270        * in an out-of-memory situation
1271        */
1272       gsize size G_GNUC_UNUSED;
1273 
1274       size = _g_vsnprintf (buffer, 1024, format, args);
1275       msg = buffer;
1276     }
</pre>
<hr />
<pre>
1298           gchar level_prefix[STRING_BUFFER_SIZE];
1299           gchar *expected_message;
1300 
1301           mklevel_prefix (level_prefix, expected-&gt;log_level, FALSE);
1302           expected_message = g_strdup_printf (&quot;Did not see expected message %s-%s: %s&quot;,
1303                                               expected-&gt;log_domain ? expected-&gt;log_domain : &quot;**&quot;,
1304                                               level_prefix, expected-&gt;pattern);
1305           g_log_default_handler (G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL, expected_message, NULL);
1306           g_free (expected_message);
1307 
1308           log_level |= G_LOG_FLAG_FATAL;
1309         }
1310     }
1311 
1312   for (i = g_bit_nth_msf (log_level, -1); i &gt;= 0; i = g_bit_nth_msf (log_level, i))
1313     {
1314       GLogLevelFlags test_level;
1315 
1316       test_level = 1 &lt;&lt; i;
1317       if (log_level &amp; test_level)
<span class="line-modified">1318     {</span>
<span class="line-modified">1319       GLogDomain *domain;</span>
<span class="line-modified">1320       GLogFunc log_func;</span>
<span class="line-modified">1321       GLogLevelFlags domain_fatal_mask;</span>
<span class="line-modified">1322       gpointer data = NULL;</span>
1323           gboolean masquerade_fatal = FALSE;
1324           guint depth;
1325 
<span class="line-modified">1326       if (was_fatal)</span>
<span class="line-modified">1327         test_level |= G_LOG_FLAG_FATAL;</span>
<span class="line-modified">1328       if (was_recursion)</span>
<span class="line-modified">1329         test_level |= G_LOG_FLAG_RECURSION;</span>
1330 
<span class="line-modified">1331       /* check recursion and lookup handler */</span>
<span class="line-modified">1332       g_mutex_lock (&amp;g_messages_lock);</span>
1333           depth = GPOINTER_TO_UINT (g_private_get (&amp;g_log_depth));
<span class="line-modified">1334       domain = g_log_find_domain_L (log_domain ? log_domain : &quot;&quot;);</span>
<span class="line-modified">1335       if (depth)</span>
<span class="line-modified">1336         test_level |= G_LOG_FLAG_RECURSION;</span>
<span class="line-modified">1337       depth++;</span>
<span class="line-modified">1338       domain_fatal_mask = domain ? domain-&gt;fatal_mask : G_LOG_FATAL_MASK;</span>
<span class="line-modified">1339       if ((domain_fatal_mask | g_log_always_fatal) &amp; test_level)</span>
<span class="line-modified">1340         test_level |= G_LOG_FLAG_FATAL;</span>
<span class="line-modified">1341       if (test_level &amp; G_LOG_FLAG_RECURSION)</span>
<span class="line-modified">1342         log_func = _g_log_fallback_handler;</span>
<span class="line-modified">1343       else</span>
<span class="line-modified">1344         log_func = g_log_domain_get_handler_L (domain, test_level, &amp;data);</span>
<span class="line-modified">1345       domain = NULL;</span>
<span class="line-modified">1346       g_mutex_unlock (&amp;g_messages_lock);</span>
<span class="line-modified">1347 </span>
<span class="line-modified">1348       g_private_set (&amp;g_log_depth, GUINT_TO_POINTER (depth));</span>
1349 
1350           log_func (log_domain, test_level, msg, data);
1351 
1352           if ((test_level &amp; G_LOG_FLAG_FATAL)
1353               &amp;&amp; !(test_level &amp; G_LOG_LEVEL_ERROR))
1354             {
1355               masquerade_fatal = fatal_log_func
1356                 &amp;&amp; !fatal_log_func (log_domain, test_level, msg, fatal_log_data);
1357             }
1358 
1359           if ((test_level &amp; G_LOG_FLAG_FATAL) &amp;&amp; !masquerade_fatal)
1360             {
<span class="line-modified">1361 #ifdef G_OS_WIN32</span>


1362               if (win32_keep_fatal_message)
1363                 {
1364                   gchar *locale_msg = g_locale_from_utf8 (fatal_msg_buf, -1, NULL, NULL, NULL);
1365 
1366                   MessageBox (NULL, locale_msg, NULL,
1367                               MB_ICONERROR|MB_SETFOREGROUND);
1368                 }
<span class="line-modified">1369 #endif /* !G_OS_WIN32 */</span>
1370 
<span class="line-modified">1371           _g_log_abort (!(test_level &amp; G_LOG_FLAG_RECURSION));</span>
<span class="line-modified">1372         }</span>
1373 
<span class="line-modified">1374       depth--;</span>
<span class="line-modified">1375       g_private_set (&amp;g_log_depth, GUINT_TO_POINTER (depth));</span>
<span class="line-modified">1376     }</span>
1377     }
1378 
1379   g_free (msg_alloc);
1380 }
1381 
1382 /**
1383  * g_log:
1384  * @log_domain: (nullable): the log domain, usually #G_LOG_DOMAIN, or %NULL
1385  * for the default
1386  * @log_level: the log level, either from #GLogLevelFlags
1387  *     or a user-defined level
1388  * @format: the message format. See the printf() documentation
1389  * @...: the parameters to insert into the format string
1390  *
1391  * Logs an error or debugging message.
1392  *
1393  * If the log level has been set as fatal, G_BREAKPOINT() is called
1394  * to terminate the program. See the documentation for G_BREAKPOINT() for
1395  * details of the debugging options this provides.
1396  *
</pre>
<hr />
<pre>
2148  * Check whether the given @output_fd file descriptor is a connection to the
2149  * systemd journal, or something else (like a log file or `stdout` or
2150  * `stderr`).
2151  *
2152  * Invalid file descriptors are accepted and return %FALSE, which allows for
2153  * the following construct without needing any additional error handling:
2154  * |[&lt;!-- language=&quot;C&quot; --&gt;
2155  *   is_journald = g_log_writer_is_journald (fileno (stderr));
2156  * ]|
2157  *
2158  * Returns: %TRUE if @output_fd points to the journal, %FALSE otherwise
2159  * Since: 2.50
2160  */
2161 gboolean
2162 g_log_writer_is_journald (gint output_fd)
2163 {
2164 #if defined(__linux__) &amp;&amp; !defined(__BIONIC__)
2165   /* FIXME: Use the new journal API for detecting whether we&#39;re writing to the
2166    * journal. See: https://github.com/systemd/systemd/issues/2473
2167    */
<span class="line-modified">2168   static gsize initialized;</span>
<span class="line-modified">2169   static gboolean fd_is_journal = FALSE;</span>





2170 
2171   if (output_fd &lt; 0)
2172     return FALSE;
2173 
<span class="line-modified">2174   if (g_once_init_enter (&amp;initialized))</span>
<span class="line-modified">2175     {</span>
<span class="line-modified">2176       union {</span>
<span class="line-modified">2177         struct sockaddr_storage storage;</span>
<span class="line-modified">2178         struct sockaddr sa;</span>
<span class="line-removed">2179         struct sockaddr_un un;</span>
<span class="line-removed">2180       } addr;</span>
<span class="line-removed">2181       socklen_t addr_len = sizeof(addr);</span>
<span class="line-removed">2182       int err = getpeername (output_fd, &amp;addr.sa, &amp;addr_len);</span>
<span class="line-removed">2183       if (err == 0 &amp;&amp; addr.storage.ss_family == AF_UNIX)</span>
<span class="line-removed">2184         fd_is_journal = g_str_has_prefix (addr.un.sun_path, &quot;/run/systemd/journal/&quot;);</span>
<span class="line-removed">2185 </span>
<span class="line-removed">2186       g_once_init_leave (&amp;initialized, TRUE);</span>
<span class="line-removed">2187     }</span>
2188 
<span class="line-removed">2189   return fd_is_journal;</span>
<span class="line-removed">2190 #else</span>
2191   return FALSE;
<span class="line-removed">2192 #endif</span>
2193 }
2194 
2195 static void escape_string (GString *string);
2196 
2197 /**
2198  * g_log_writer_format_fields:
2199  * @log_level: log level, either from #GLogLevelFlags, or a user-defined
2200  *    level
2201  * @fields: (array length=n_fields): key-value pairs of structured data forming
2202  *    the log message
2203  * @n_fields: number of elements in the @fields array
2204  * @use_color: %TRUE to use ANSI color escape sequences when formatting the
2205  *    message, %FALSE to not
2206  *
2207  * Format a structured log message as a string suitable for outputting to the
2208  * terminal (or elsewhere). This will include the values of all fields it knows
2209  * how to interpret, which includes `MESSAGE` and `GLIB_DOMAIN` (see the
2210  * documentation for g_log_structured()). It does not include values from
2211  * unknown fields.
2212  *
</pre>
<hr />
<pre>
2281   now_tm = localtime (&amp;now_secs);
2282   strftime (time_buf, sizeof (time_buf), &quot;%H:%M:%S&quot;, now_tm);
2283 
2284   g_string_append_printf (gstring, &quot;%s%s.%03d%s: &quot;,
2285                           use_color ? &quot;\033[34m&quot; : &quot;&quot;,
2286                           time_buf, (gint) ((now / 1000) % 1000),
2287                           color_reset (use_color));
2288 
2289   if (message == NULL)
2290     {
2291       g_string_append (gstring, &quot;(NULL) message&quot;);
2292     }
2293   else
2294     {
2295       GString *msg;
2296       const gchar *charset;
2297 
2298       msg = g_string_new (message);
2299       escape_string (msg);
2300 
<span class="line-modified">2301       if (g_get_charset (&amp;charset))</span>
2302         {
2303           /* charset is UTF-8 already */
2304           g_string_append (gstring, msg-&gt;str);
2305         }
2306       else
2307         {
2308           gchar *lstring = strdup_convert (msg-&gt;str, charset);
2309           g_string_append (gstring, lstring);
2310           g_free (lstring);
2311         }
2312 
2313       g_string_free (msg, TRUE);
2314     }
2315 
2316   return g_string_free (gstring, FALSE);
2317 }
2318 
2319 /* Enable support for the journal if we&#39;re on a recent enough Linux */
2320 #if defined(__linux__) &amp;&amp; !defined(__BIONIC__) &amp;&amp; defined(HAVE_MKOSTEMP) &amp;&amp; defined(O_CLOEXEC)
2321 #define ENABLE_JOURNAL_SENDV
</pre>
<hr />
<pre>
2603  * Support for other platform-specific logging mechanisms may be added in
2604  * future. Distributors of GLib may modify this function to impose their own
2605  * (documented) platform-specific log writing policies.
2606  *
2607  * This is suitable for use as a #GLogWriterFunc, and is the default writer used
2608  * if no other is set using g_log_set_writer_func().
2609  *
2610  * As with g_log_default_handler(), this function drops debug and informational
2611  * messages unless their log domain (or `all`) is listed in the space-separated
2612  * `G_MESSAGES_DEBUG` environment variable.
2613  *
2614  * Returns: %G_LOG_WRITER_HANDLED on success, %G_LOG_WRITER_UNHANDLED otherwise
2615  * Since: 2.50
2616  */
2617 GLogWriterOutput
2618 g_log_writer_default (GLogLevelFlags   log_level,
2619                       const GLogField *fields,
2620                       gsize            n_fields,
2621                       gpointer         user_data)
2622 {



2623   g_return_val_if_fail (fields != NULL, G_LOG_WRITER_UNHANDLED);
2624   g_return_val_if_fail (n_fields &gt; 0, G_LOG_WRITER_UNHANDLED);
2625 
2626   /* Disable debug message output unless specified in G_MESSAGES_DEBUG. */
2627   if (!(log_level &amp; DEFAULT_LEVELS) &amp;&amp; !(log_level &gt;&gt; G_LOG_LEVEL_USER_SHIFT))
2628     {
2629       const gchar *domains, *log_domain = NULL;
2630       gsize i;
2631 
2632       domains = g_getenv (&quot;G_MESSAGES_DEBUG&quot;);
2633 
2634       if ((log_level &amp; INFO_LEVELS) == 0 ||
2635           domains == NULL)
2636         return G_LOG_WRITER_HANDLED;
2637 
2638       for (i = 0; i &lt; n_fields; i++)
2639         {
2640           if (g_strcmp0 (fields[i].key, &quot;GLIB_DOMAIN&quot;) == 0)
2641             {
2642               log_domain = fields[i].value;
2643               break;
2644             }
2645         }
2646 
2647       if (strcmp (domains, &quot;all&quot;) != 0 &amp;&amp;
2648           (log_domain == NULL || !strstr (domains, log_domain)))
2649         return G_LOG_WRITER_HANDLED;
2650     }
2651 
2652   /* Mark messages as fatal if they have a level set in
2653    * g_log_set_always_fatal().
2654    */
2655   if ((log_level &amp; g_log_always_fatal) &amp;&amp; !log_is_old_api (fields, n_fields))
2656     log_level |= G_LOG_FLAG_FATAL;
2657 
2658   /* Try logging to the systemd journal as first choice. */
<span class="line-modified">2659   if (g_log_writer_is_journald (fileno (stderr)) &amp;&amp;</span>






2660       g_log_writer_journald (log_level, fields, n_fields, user_data) ==
2661       G_LOG_WRITER_HANDLED)
2662     goto handled;
2663 
2664   /* FIXME: Add support for the Windows log. */
2665 
2666   if (g_log_writer_standard_streams (log_level, fields, n_fields, user_data) ==
2667       G_LOG_WRITER_HANDLED)
2668     goto handled;
2669 
2670   return G_LOG_WRITER_UNHANDLED;
2671 
2672 handled:
2673   /* Abort if the message was fatal. */
2674   if (log_level &amp; G_LOG_FLAG_FATAL)
2675     {
<span class="line-modified">2676 #ifdef G_OS_WIN32</span>


2677       if (!g_test_initialized ())
2678         {
2679           gchar *locale_msg = NULL;
2680 
2681           locale_msg = g_locale_from_utf8 (fatal_msg_buf, -1, NULL, NULL, NULL);
2682           MessageBox (NULL, locale_msg, NULL,
2683                       MB_ICONERROR | MB_SETFOREGROUND);
2684           g_free (locale_msg);
2685         }
2686 #endif /* !G_OS_WIN32 */
2687 
2688       _g_log_abort (!(log_level &amp; G_LOG_FLAG_RECURSION));
2689     }
2690 
2691   return G_LOG_WRITER_HANDLED;
2692 }
2693 
2694 static GLogWriterOutput
2695 _g_log_writer_fallback (GLogLevelFlags   log_level,
2696                         const GLogField *fields,
</pre>
<hr />
<pre>
2733       write_string (stream, field-&gt;key);
2734       write_string (stream, &quot;=&quot;);
2735       write_string_sized (stream, field-&gt;value, field-&gt;length);
2736     }
2737 
2738 #ifndef G_OS_WIN32
2739   {
2740     gchar pid_string[FORMAT_UNSIGNED_BUFSIZE];
2741 
2742     format_unsigned (pid_string, getpid (), 10);
2743     write_string (stream, &quot;_PID=&quot;);
2744     write_string (stream, pid_string);
2745   }
2746 #endif
2747 
2748   return G_LOG_WRITER_HANDLED;
2749 }
2750 
2751 /**
2752  * g_return_if_fail_warning: (skip)
<span class="line-modified">2753  * @log_domain: (nullable):</span>
<span class="line-modified">2754  * @pretty_function:</span>
<span class="line-modified">2755  * @expression: (nullable):</span>



2756  */
2757 void
2758 g_return_if_fail_warning (const char *log_domain,
<span class="line-modified">2759               const char *pretty_function,</span>
<span class="line-modified">2760               const char *expression)</span>
2761 {
2762   g_log (log_domain,
<span class="line-modified">2763      G_LOG_LEVEL_CRITICAL,</span>
<span class="line-modified">2764      &quot;%s: assertion &#39;%s&#39; failed&quot;,</span>
<span class="line-modified">2765      pretty_function,</span>
<span class="line-modified">2766      expression);</span>
2767 }
2768 
2769 /**
2770  * g_warn_message: (skip)
<span class="line-modified">2771  * @domain: (nullable):</span>
<span class="line-modified">2772  * @file:</span>
<span class="line-modified">2773  * @line:</span>
<span class="line-modified">2774  * @func:</span>
<span class="line-modified">2775  * @warnexpr: (nullable):</span>



2776  */
2777 void
2778 g_warn_message (const char     *domain,
2779                 const char     *file,
2780                 int             line,
2781                 const char     *func,
2782                 const char     *warnexpr)
2783 {
2784   char *s, lstr[32];
2785   g_snprintf (lstr, 32, &quot;%d&quot;, line);
2786   if (warnexpr)
2787     s = g_strconcat (&quot;(&quot;, file, &quot;:&quot;, lstr, &quot;):&quot;,
2788                      func, func[0] ? &quot;:&quot; : &quot;&quot;,
2789                      &quot; runtime check failed: (&quot;, warnexpr, &quot;)&quot;, NULL);
2790   else
2791     s = g_strconcat (&quot;(&quot;, file, &quot;:&quot;, lstr, &quot;):&quot;,
2792                      func, func[0] ? &quot;:&quot; : &quot;&quot;,
2793                      &quot; &quot;, &quot;code should not be reached&quot;, NULL);
2794   g_log (domain, G_LOG_LEVEL_WARNING, &quot;%s&quot;, s);
2795   g_free (s);
2796 }
2797 
2798 void
2799 g_assert_warning (const char *log_domain,
<span class="line-modified">2800           const char *file,</span>
<span class="line-modified">2801           const int   line,</span>
<span class="line-modified">2802           const char *pretty_function,</span>
<span class="line-modified">2803           const char *expression)</span>
2804 {
2805   if (expression)
2806     g_log (log_domain,
<span class="line-modified">2807        G_LOG_LEVEL_ERROR,</span>
<span class="line-modified">2808        &quot;file %s: line %d (%s): assertion failed: (%s)&quot;,</span>
<span class="line-modified">2809        file,</span>
<span class="line-modified">2810        line,</span>
<span class="line-modified">2811        pretty_function,</span>
<span class="line-modified">2812        expression);</span>
2813   else
2814     g_log (log_domain,
<span class="line-modified">2815        G_LOG_LEVEL_ERROR,</span>
<span class="line-modified">2816        &quot;file %s: line %d (%s): should not be reached&quot;,</span>
<span class="line-modified">2817        file,</span>
<span class="line-modified">2818        line,</span>
<span class="line-modified">2819        pretty_function);</span>
2820   _g_log_abort (FALSE);
2821   g_abort ();
2822 }
2823 
2824 /**
2825  * g_test_expect_message:
2826  * @log_domain: (nullable): the log domain of the message
2827  * @log_level: the log level of the message
2828  * @pattern: a glob-style [pattern][glib-Glob-style-pattern-matching]
2829  *
2830  * Indicates that a message with the given @log_domain and @log_level,
2831  * with text matching @pattern, is expected to be logged. When this
2832  * message is logged, it will not be printed, and the test case will
2833  * not abort.
2834  *
2835  * This API may only be used with the old logging API (g_log() without
2836  * %G_LOG_USE_STRUCTURED defined). It will not work with the structured logging
2837  * API. See [Testing for Messages][testing-for-messages].
2838  *
2839  * Use g_test_assert_expected_messages() to assert that all
</pre>
<hr />
<pre>
2907 }
2908 
2909 /**
2910  * g_test_assert_expected_messages:
2911  *
2912  * Asserts that all messages previously indicated via
2913  * g_test_expect_message() have been seen and suppressed.
2914  *
2915  * This API may only be used with the old logging API (g_log() without
2916  * %G_LOG_USE_STRUCTURED defined). It will not work with the structured logging
2917  * API. See [Testing for Messages][testing-for-messages].
2918  *
2919  * If messages at %G_LOG_LEVEL_DEBUG are emitted, but not explicitly
2920  * expected via g_test_expect_message() then they will be ignored.
2921  *
2922  * Since: 2.34
2923  */
2924 
2925 void
2926 _g_log_fallback_handler (const gchar   *log_domain,
<span class="line-modified">2927              GLogLevelFlags log_level,</span>
<span class="line-modified">2928              const gchar   *message,</span>
<span class="line-modified">2929              gpointer       unused_data)</span>
2930 {
2931   gchar level_prefix[STRING_BUFFER_SIZE];
2932 #ifndef G_OS_WIN32
2933   gchar pid_string[FORMAT_UNSIGNED_BUFSIZE];
2934 #endif
2935   FILE *stream;
2936 
2937   /* we cannot call _any_ GLib functions in this fallback handler,
2938    * which is why we skip UTF-8 conversion, etc.
2939    * since we either recursed or ran out of memory, we&#39;re in a pretty
2940    * pathologic situation anyways, what we can do is giving the
2941    * the process ID unconditionally however.
2942    */
2943 
2944   stream = mklevel_prefix (level_prefix, log_level, FALSE);
2945   if (!message)
2946     message = &quot;(NULL) message&quot;;
2947 
2948 #ifndef G_OS_WIN32
2949   format_unsigned (pid_string, getpid (), 10);
</pre>
<hr />
<pre>
2965       write_string (stream, log_domain);
2966       write_string (stream, &quot;-&quot;);
2967     }
2968   write_string (stream, level_prefix);
2969   write_string (stream, &quot;: &quot;);
2970   write_string (stream, message);
2971 }
2972 
2973 static void
2974 escape_string (GString *string)
2975 {
2976   const char *p = string-&gt;str;
2977   gunichar wc;
2978 
2979   while (p &lt; string-&gt;str + string-&gt;len)
2980     {
2981       gboolean safe;
2982 
2983       wc = g_utf8_get_char_validated (p, -1);
2984       if (wc == (gunichar)-1 || wc == (gunichar)-2)
<span class="line-modified">2985     {</span>
<span class="line-modified">2986       gchar *tmp;</span>
<span class="line-modified">2987       guint pos;</span>
2988 
<span class="line-modified">2989       pos = p - string-&gt;str;</span>
2990 
<span class="line-modified">2991       /* Emit invalid UTF-8 as hex escapes</span>
2992            */
<span class="line-modified">2993       tmp = g_strdup_printf (&quot;\\x%02x&quot;, (guint)(guchar)*p);</span>
<span class="line-modified">2994       g_string_erase (string, pos, 1);</span>
<span class="line-modified">2995       g_string_insert (string, pos, tmp);</span>
2996 
<span class="line-modified">2997       p = string-&gt;str + (pos + 4); /* Skip over escape sequence */</span>
2998 
<span class="line-modified">2999       g_free (tmp);</span>
<span class="line-modified">3000       continue;</span>
<span class="line-modified">3001     }</span>
3002       if (wc == &#39;\r&#39;)
<span class="line-modified">3003     {</span>
<span class="line-modified">3004       safe = *(p + 1) == &#39;\n&#39;;</span>
<span class="line-modified">3005     }</span>
3006       else
<span class="line-modified">3007     {</span>
<span class="line-modified">3008       safe = CHAR_IS_SAFE (wc);</span>
<span class="line-modified">3009     }</span>
3010 
3011       if (!safe)
<span class="line-modified">3012     {</span>
<span class="line-modified">3013       gchar *tmp;</span>
<span class="line-modified">3014       guint pos;</span>
3015 
<span class="line-modified">3016       pos = p - string-&gt;str;</span>
3017 
<span class="line-modified">3018       /* Largest char we escape is 0x0a, so we don&#39;t have to worry</span>
<span class="line-modified">3019        * about 8-digit \Uxxxxyyyy</span>
<span class="line-modified">3020        */</span>
<span class="line-modified">3021       tmp = g_strdup_printf (&quot;\\u%04x&quot;, wc);</span>
<span class="line-modified">3022       g_string_erase (string, pos, g_utf8_next_char (p) - p);</span>
<span class="line-modified">3023       g_string_insert (string, pos, tmp);</span>
<span class="line-modified">3024       g_free (tmp);</span>
3025 
<span class="line-modified">3026       p = string-&gt;str + (pos + 6); /* Skip over escape sequence */</span>
<span class="line-modified">3027     }</span>
3028       else
<span class="line-modified">3029     p = g_utf8_next_char (p);</span>
3030     }
3031 }
3032 
3033 /**
3034  * g_log_default_handler:
3035  * @log_domain: (nullable): the log domain of the message, or %NULL for the
3036  * default &quot;&quot; application domain
3037  * @log_level: the level of the message
3038  * @message: (nullable): the message
3039  * @unused_data: (nullable): data passed from g_log() which is unused
3040  *
3041  * The default log handler set up by GLib; g_log_set_default_handler()
3042  * allows to install an alternate default log handler.
3043  * This is used if no log handler has been set for the particular log
3044  * domain and log level combination. It outputs the message to stderr
3045  * or stdout and if the log level is fatal it calls G_BREAKPOINT(). It automatically
3046  * prints a new-line character after the message, so one does not need to be
3047  * manually included in @message.
3048  *
3049  * The behavior of this log handler can be influenced by a number of
3050  * environment variables:
3051  *
3052  * - `G_MESSAGES_PREFIXED`: A :-separated list of log levels for which
3053  *   messages should be prefixed by the program name and PID of the
3054  *   aplication.
3055  *
3056  * - `G_MESSAGES_DEBUG`: A space-separated list of log domains for
3057  *   which debug and informational messages are printed. By default
3058  *   these messages are not printed.
3059  *
3060  * stderr is used for levels %G_LOG_LEVEL_ERROR, %G_LOG_LEVEL_CRITICAL,
3061  * %G_LOG_LEVEL_WARNING and %G_LOG_LEVEL_MESSAGE. stdout is used for
3062  * the rest.
3063  *
3064  * This has no effect if structured logging is enabled; see
3065  * [Using Structured Logging][using-structured-logging].
3066  */
3067 void
3068 g_log_default_handler (const gchar   *log_domain,
<span class="line-modified">3069                        GLogLevelFlags log_level,</span>
<span class="line-modified">3070                        const gchar   *message,</span>
<span class="line-modified">3071                gpointer       unused_data)</span>
3072 {
3073   GLogField fields[4];
3074   int n_fields = 0;
3075 
3076   /* we can be called externally with recursion for whatever reason */
3077   if (log_level &amp; G_LOG_FLAG_RECURSION)
3078     {
3079       _g_log_fallback_handler (log_domain, log_level, message, unused_data);
3080       return;
3081     }
3082 
3083   fields[0].key = &quot;GLIB_OLD_LOG_API&quot;;
3084   fields[0].value = &quot;1&quot;;
3085   fields[0].length = -1;
3086   n_fields++;
3087 
3088   fields[1].key = &quot;MESSAGE&quot;;
3089   fields[1].value = message;
3090   fields[1].length = -1;
3091   n_fields++;
3092 
3093   fields[2].key = &quot;PRIORITY&quot;;
3094   fields[2].value = log_level_to_priority (log_level);
3095   fields[2].length = -1;
3096   n_fields++;
3097 
3098   if (log_domain)
3099     {
3100       fields[3].key = &quot;GLIB_DOMAIN&quot;;
3101       fields[3].value = log_domain;
3102       fields[3].length = -1;
3103       n_fields++;
3104     }
3105 
3106   /* Print out via the structured log API, but drop any fatal flags since we
3107    * have already handled them. The fatal handling in the structured logging
3108    * API is more coarse-grained than in the old g_log() API, so we don&#39;t want
3109    * to use it here.
3110    */
3111   g_log_structured_array (log_level &amp; ~G_LOG_FLAG_FATAL, fields, n_fields);
<span class="line-modified">3112     }</span>
3113 
3114 /**
3115  * g_set_print_handler:
3116  * @func: the new print handler
3117  *
3118  * Sets the print handler.
3119  *
3120  * Any messages passed to g_print() will be output via
3121  * the new handler. The default handler simply outputs
3122  * the message to stdout. By providing your own handler
3123  * you can redirect the output, to a GTK+ widget or a
3124  * log file for example.
3125  *
3126  * Returns: the old print handler
3127  */
3128 GPrintFunc
3129 g_set_print_handler (GPrintFunc func)
3130 {
3131   GPrintFunc old_print_func;
3132 
</pre>
<hr />
<pre>
3161   va_list args;
3162   gchar *string;
3163   GPrintFunc local_glib_print_func;
3164 
3165   g_return_if_fail (format != NULL);
3166 
3167   va_start (args, format);
3168   string = g_strdup_vprintf (format, args);
3169   va_end (args);
3170 
3171   g_mutex_lock (&amp;g_messages_lock);
3172   local_glib_print_func = glib_print_func;
3173   g_mutex_unlock (&amp;g_messages_lock);
3174 
3175   if (local_glib_print_func)
3176     local_glib_print_func (string);
3177   else
3178     {
3179       const gchar *charset;
3180 
<span class="line-modified">3181       if (g_get_charset (&amp;charset))</span>
3182         fputs (string, stdout); /* charset is UTF-8 already */
3183       else
3184         {
3185           gchar *lstring = strdup_convert (string, charset);
3186 
3187           fputs (lstring, stdout);
3188           g_free (lstring);
3189         }
3190       fflush (stdout);
3191     }
3192   g_free (string);
3193 }
3194 
3195 /**
3196  * g_set_printerr_handler:
3197  * @func: the new error message handler
3198  *
3199  * Sets the handler for printing error messages.
3200  *
3201  * Any messages passed to g_printerr() will be output via
</pre>
<hr />
<pre>
3240   va_list args;
3241   gchar *string;
3242   GPrintFunc local_glib_printerr_func;
3243 
3244   g_return_if_fail (format != NULL);
3245 
3246   va_start (args, format);
3247   string = g_strdup_vprintf (format, args);
3248   va_end (args);
3249 
3250   g_mutex_lock (&amp;g_messages_lock);
3251   local_glib_printerr_func = glib_printerr_func;
3252   g_mutex_unlock (&amp;g_messages_lock);
3253 
3254   if (local_glib_printerr_func)
3255     local_glib_printerr_func (string);
3256   else
3257     {
3258       const gchar *charset;
3259 
<span class="line-modified">3260       if (g_get_charset (&amp;charset))</span>
3261         fputs (string, stderr); /* charset is UTF-8 already */
3262       else
3263         {
3264           gchar *lstring = strdup_convert (string, charset);
3265 
3266           fputs (lstring, stderr);
3267           g_free (lstring);
3268         }
3269       fflush (stderr);
3270     }
3271   g_free (string);
3272 }
3273 
3274 /**
3275  * g_printf_string_upper_bound:
3276  * @format: the format string. See the printf() documentation
3277  * @args: the parameters to be inserted into the format string
3278  *
3279  * Calculates the maximum space needed to store the output
3280  * of the sprintf() function.
</pre>
</td>
<td>
<hr />
<pre>
  29 /**
  30  * SECTION:messages
  31  * @Title: Message Output and Debugging Functions
  32  * @Short_description: functions to output messages and help debug applications
  33  *
  34  * These functions provide support for outputting messages.
  35  *
  36  * The g_return family of macros (g_return_if_fail(),
  37  * g_return_val_if_fail(), g_return_if_reached(),
  38  * g_return_val_if_reached()) should only be used for programming
  39  * errors, a typical use case is checking for invalid parameters at
  40  * the beginning of a public function. They should not be used if
  41  * you just mean &quot;if (error) return&quot;, they should only be used if
  42  * you mean &quot;if (bug in program) return&quot;. The program behavior is
  43  * generally considered undefined after one of these checks fails.
  44  * They are not intended for normal control flow, only to give a
  45  * perhaps-helpful warning before giving up.
  46  *
  47  * Structured logging output is supported using g_log_structured(). This differs
  48  * from the traditional g_log() API in that log messages are handled as a
<span class="line-modified">  49  * collection of key-value pairs representing individual pieces of information,</span>
  50  * rather than as a single string containing all the information in an arbitrary
  51  * format.
  52  *
  53  * The convenience macros g_info(), g_message(), g_debug(), g_warning() and g_error()
  54  * will use the traditional g_log() API unless you define the symbol
  55  * %G_LOG_USE_STRUCTURED before including `glib.h`. But note that even messages
  56  * logged through the traditional g_log() API are ultimatively passed to
  57  * g_log_structured(), so that all log messages end up in same destination.
  58  * If %G_LOG_USE_STRUCTURED is defined, g_test_expect_message() will become
  59  * ineffective for the wrapper macros g_warning() and friends (see
  60  * [Testing for Messages][testing-for-messages]).
  61  *
  62  * The support for structured logging was motivated by the following needs (some
<span class="line-modified">  63  * of which were supported previously; others weren&#39;t):</span>
  64  *  * Support for multiple logging levels.
  65  *  * Structured log support with the ability to add `MESSAGE_ID`s (see
  66  *    g_log_structured()).
  67  *  * Moving the responsibility for filtering log messages from the program to
<span class="line-modified">  68  *    the log viewer - instead of libraries and programs installing log handlers</span>
  69  *    (with g_log_set_handler()) which filter messages before output, all log
  70  *    messages are outputted, and the log viewer program (such as `journalctl`)
  71  *    must filter them. This is based on the idea that bugs are sometimes hard
  72  *    to reproduce, so it is better to log everything possible and then use
  73  *    tools to analyse the logs than it is to not be able to reproduce a bug to
  74  *    get additional log data. Code which uses logging in performance-critical
  75  *    sections should compile out the g_log_structured() calls in
  76  *    release builds, and compile them in in debugging builds.
  77  *  * A single writer function which handles all log messages in a process, from
  78  *    all libraries and program code; rather than multiple log handlers with
  79  *    poorly defined interactions between them. This allows a program to easily
  80  *    change its logging policy by changing the writer function, for example to
  81  *    log to an additional location or to change what logging output fallbacks
  82  *    are used. The log writer functions provided by GLib are exposed publicly
<span class="line-modified">  83  *    so they can be used from programs&#39; log writers. This allows log writer</span>
  84  *    policy and implementation to be kept separate.
  85  *  * If a library wants to add standard information to all of its log messages
  86  *    (such as library state) or to redact private data (such as passwords or
  87  *    network credentials), it should use a wrapper function around its
  88  *    g_log_structured() calls or implement that in the single log writer
  89  *    function.
  90  *  * If a program wants to pass context data from a g_log_structured() call to
  91  *    its log writer function so that, for example, it can use the correct
  92  *    server connection to submit logs to, that user data can be passed as a
  93  *    zero-length #GLogField to g_log_structured_array().
  94  *  * Color output needed to be supported on the terminal, to make reading
  95  *    through logs easier.
  96  *
  97  * ## Using Structured Logging ## {#using-structured-logging}
  98  *
  99  * To use structured logging (rather than the old-style logging), either use
 100  * the g_log_structured() and g_log_structured_array() functions; or define
 101  * `G_LOG_USE_STRUCTURED` before including any GLib header, and use the
 102  * g_message(), g_debug(), g_error() (etc.) macros.
 103  *
 104  * You do not need to define `G_LOG_USE_STRUCTURED` to use g_log_structured(),
 105  * but it is a good idea to avoid confusion.
 106  *
 107  * ## Log Domains ## {#log-domains}
 108  *
 109  * Log domains may be used to broadly split up the origins of log messages.
 110  * Typically, there are one or a few log domains per application or library.
 111  * %G_LOG_DOMAIN should be used to define the default log domain for the current
<span class="line-modified"> 112  * compilation unit - it is typically defined at the top of a source file, or in</span>
 113  * the preprocessor flags for a group of source files.
 114  *
 115  * Log domains must be unique, and it is recommended that they are the
 116  * application or library name, optionally followed by a hyphen and a sub-domain
 117  * name. For example, `bloatpad` or `bloatpad-io`.
 118  *
 119  * ## Debug Message Output ## {#debug-message-output}
 120  *
 121  * The default log functions (g_log_default_handler() for the old-style API and
 122  * g_log_writer_default() for the structured API) both drop debug and
 123  * informational messages by default, unless the log domains of those messages
 124  * are listed in the `G_MESSAGES_DEBUG` environment variable (or it is set to
 125  * `all`).
 126  *
 127  * It is recommended that custom log writer functions re-use the
 128  * `G_MESSAGES_DEBUG` environment variable, rather than inventing a custom one,
 129  * so that developers can re-use the same debugging techniques and tools across
 130  * projects.
 131  *
 132  * ## Testing for Messages ## {#testing-for-messages}
</pre>
<hr />
<pre>
 140  *    cases, where messages might be emitted in several orders, some
 141  *    messages might not be emitted deterministically, or messages might be
 142  *    emitted by unrelated log domains.
 143  *  * They do not support structured log fields.
 144  *  * Examining the log output of code is a bad approach to testing it, and
 145  *    while it might be necessary for legacy code which uses g_log(), it should
 146  *    be avoided for new code using g_log_structured().
 147  *
 148  * They will continue to work as before if g_log() is in use (and
 149  * %G_LOG_USE_STRUCTURED is not defined). They will do nothing if used with the
 150  * structured logging API.
 151  *
 152  * Examining the log output of code is discouraged: libraries should not emit to
 153  * `stderr` during defined behaviour, and hence this should not be tested. If
 154  * the log emissions of a library during undefined behaviour need to be tested,
 155  * they should be limited to asserting that the library aborts and prints a
 156  * suitable error message before aborting. This should be done with
 157  * g_test_trap_assert_stderr().
 158  *
 159  * If it is really necessary to test the structured log messages emitted by a
<span class="line-modified"> 160  * particular piece of code - and the code cannot be restructured to be more</span>
<span class="line-modified"> 161  * suitable to more conventional unit testing - you should write a custom log</span>
 162  * writer function (see g_log_set_writer_func()) which appends all log messages
 163  * to a queue. When you want to check the log messages, examine and clear the
 164  * queue, ignoring irrelevant log messages (for example, from log domains other
 165  * than the one under test).
 166  */
 167 
 168 #include &quot;config.h&quot;
 169 
 170 #include &lt;stdlib.h&gt;
 171 #include &lt;stdarg.h&gt;
 172 #include &lt;stdio.h&gt;
 173 #include &lt;string.h&gt;
 174 #include &lt;signal.h&gt;
 175 #include &lt;locale.h&gt;
 176 #include &lt;errno.h&gt;
 177 
 178 #if defined(__linux__) &amp;&amp; !defined(__BIONIC__)
 179 #include &lt;sys/types.h&gt;
 180 #include &lt;sys/socket.h&gt;
 181 #include &lt;sys/un.h&gt;
</pre>
<hr />
<pre>
 186 #include &quot;glib-init.h&quot;
 187 #include &quot;galloca.h&quot;
 188 #include &quot;gbacktrace.h&quot;
 189 #include &quot;gcharset.h&quot;
 190 #include &quot;gconvert.h&quot;
 191 #include &quot;genviron.h&quot;
 192 #include &quot;gmain.h&quot;
 193 #include &quot;gmem.h&quot;
 194 #include &quot;gprintfint.h&quot;
 195 #include &quot;gtestutils.h&quot;
 196 #include &quot;gthread.h&quot;
 197 #include &quot;gstrfuncs.h&quot;
 198 #include &quot;gstring.h&quot;
 199 #include &quot;gpattern.h&quot;
 200 
 201 #ifdef G_OS_UNIX
 202 #include &lt;unistd.h&gt;
 203 #endif
 204 
 205 #ifdef G_OS_WIN32
<span class="line-modified"> 206 #include &lt;process.h&gt;    /* For getpid() */</span>
 207 #include &lt;io.h&gt;
 208 #  include &lt;windows.h&gt;
 209 
 210 #ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING
 211 #define ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004
 212 #endif
 213 
 214 #if defined (_MSC_VER) &amp;&amp; (_MSC_VER &gt;=1400)
 215 /* This is ugly, but we need it for isatty() in case we have bad fd&#39;s,
 216  * otherwise Windows will abort() the program on msvcrt80.dll and later
 217  */
 218 #include &lt;crtdbg.h&gt;
 219 
 220 _GLIB_EXTERN void
 221 myInvalidParameterHandler(const wchar_t *expression,
 222                           const wchar_t *function,
 223                           const wchar_t *file,
 224                           unsigned int   line,
 225                           uintptr_t      pReserved)
 226 {
</pre>
<hr />
<pre>
 476  * If g_log_default_handler() is used as the log handler function, a new-line
 477  * character will automatically be appended to @..., and need not be entered
 478  * manually.
 479  *
 480  * Such messages are suppressed by the g_log_default_handler() and
 481  * g_log_writer_default() unless the `G_MESSAGES_DEBUG` environment variable is
 482  * set appropriately.
 483  *
 484  * If structured logging is enabled, this will use g_log_structured();
 485  * otherwise it will use g_log(). See
 486  * [Using Structured Logging][using-structured-logging].
 487  *
 488  * Since: 2.6
 489  */
 490 
 491 /* --- structures --- */
 492 typedef struct _GLogDomain  GLogDomain;
 493 typedef struct _GLogHandler GLogHandler;
 494 struct _GLogDomain
 495 {
<span class="line-modified"> 496   gchar   *log_domain;</span>
 497   GLogLevelFlags fatal_mask;
<span class="line-modified"> 498   GLogHandler *handlers;</span>
<span class="line-modified"> 499   GLogDomain  *next;</span>
 500 };
 501 struct _GLogHandler
 502 {
<span class="line-modified"> 503   guint    id;</span>
 504   GLogLevelFlags log_level;
 505   GLogFunc   log_func;
 506   gpointer   data;
 507   GDestroyNotify destroy;
<span class="line-modified"> 508   GLogHandler *next;</span>
 509 };
 510 
 511 
 512 /* --- variables --- */
 513 static GMutex         g_messages_lock;
 514 static GLogDomain    *g_log_domains = NULL;
 515 static GPrintFunc     glib_print_func = NULL;
 516 static GPrintFunc     glib_printerr_func = NULL;
 517 static GPrivate       g_log_depth;
 518 static GPrivate       g_log_structured_depth;
 519 static GLogFunc       default_log_func = g_log_default_handler;
 520 static gpointer       default_log_data = NULL;
 521 static GTestLogFatalFunc fatal_log_func = NULL;
 522 static gpointer          fatal_log_data;
 523 static GLogWriterFunc log_writer_func = g_log_writer_default;
 524 static gpointer       log_writer_user_data = NULL;
 525 static GDestroyNotify log_writer_user_data_free = NULL;
 526 
 527 /* --- functions --- */
 528 
</pre>
<hr />
<pre>
 552 
 553   if (debugger_present &amp;&amp; breakpoint)
 554     G_BREAKPOINT ();
 555   else
 556     g_abort ();
 557 }
 558 
 559 #ifdef G_OS_WIN32
 560 static gboolean win32_keep_fatal_message = FALSE;
 561 
 562 /* This default message will usually be overwritten. */
 563 /* Yes, a fixed size buffer is bad. So sue me. But g_error() is never
 564  * called with huge strings, is it?
 565  */
 566 static gchar  fatal_msg_buf[1000] = &quot;Unspecified fatal error encountered, aborting.&quot;;
 567 static gchar *fatal_msg_ptr = fatal_msg_buf;
 568 
 569 #undef write
 570 static inline int
 571 dowrite (int          fd,
<span class="line-modified"> 572    const void  *buf,</span>
<span class="line-modified"> 573    unsigned int len)</span>
 574 {
 575   if (win32_keep_fatal_message)
 576     {
 577       memcpy (fatal_msg_ptr, buf, len);
 578       fatal_msg_ptr += len;
 579       *fatal_msg_ptr = 0;
 580       return len;
 581     }
 582 
 583   write (fd, buf, len);
 584 
 585   return len;
 586 }
 587 #define write(fd, buf, len) dowrite(fd, buf, len)
 588 
 589 #endif
 590 
 591 static void
 592 write_string (FILE        *stream,
<span class="line-modified"> 593         const gchar *string)</span>
 594 {
 595   fputs (string, stream);
 596 }
 597 
 598 static void
 599 write_string_sized (FILE        *stream,
 600                     const gchar *string,
 601                     gssize       length)
 602 {
 603   /* Is it nul-terminated? */
 604   if (length &lt; 0)
 605     write_string (stream, string);
 606   else
 607     fwrite (string, 1, length, stream);
 608 }
 609 
 610 static GLogDomain*
 611 g_log_find_domain_L (const gchar *log_domain)
 612 {
 613   GLogDomain *domain;
 614 
 615   domain = g_log_domains;
 616   while (domain)
 617     {
 618       if (strcmp (domain-&gt;log_domain, log_domain) == 0)
<span class="line-modified"> 619   return domain;</span>
 620       domain = domain-&gt;next;
 621     }
 622   return NULL;
 623 }
 624 
 625 static GLogDomain*
 626 g_log_domain_new_L (const gchar *log_domain)
 627 {
 628   GLogDomain *domain;
 629 
 630   domain = g_new (GLogDomain, 1);
 631   domain-&gt;log_domain = g_strdup (log_domain);
 632   domain-&gt;fatal_mask = G_LOG_FATAL_MASK;
 633   domain-&gt;handlers = NULL;
 634 
 635   domain-&gt;next = g_log_domains;
 636   g_log_domains = domain;
 637 
 638   return domain;
 639 }
 640 
 641 static void
 642 g_log_domain_check_free_L (GLogDomain *domain)
 643 {
 644   if (domain-&gt;fatal_mask == G_LOG_FATAL_MASK &amp;&amp;
 645       domain-&gt;handlers == NULL)
 646     {
 647       GLogDomain *last, *work;
 648 
 649       last = NULL;
 650 
 651       work = g_log_domains;
 652       while (work)
<span class="line-modified"> 653   {</span>
<span class="line-modified"> 654     if (work == domain)</span>
<span class="line-modified"> 655       {</span>
<span class="line-modified"> 656         if (last)</span>
<span class="line-modified"> 657     last-&gt;next = domain-&gt;next;</span>
<span class="line-modified"> 658         else</span>
<span class="line-modified"> 659     g_log_domains = domain-&gt;next;</span>
<span class="line-modified"> 660         g_free (domain-&gt;log_domain);</span>
<span class="line-modified"> 661         g_free (domain);</span>
<span class="line-modified"> 662         break;</span>
<span class="line-modified"> 663       }</span>
<span class="line-modified"> 664     last = work;</span>
<span class="line-modified"> 665     work = last-&gt;next;</span>
<span class="line-modified"> 666   }</span>
 667     }
 668 }
 669 
 670 static GLogFunc
 671 g_log_domain_get_handler_L (GLogDomain  *domain,
<span class="line-modified"> 672           GLogLevelFlags log_level,</span>
<span class="line-modified"> 673           gpointer  *data)</span>
 674 {
 675   if (domain &amp;&amp; log_level)
 676     {
 677       GLogHandler *handler;
 678 
 679       handler = domain-&gt;handlers;
 680       while (handler)
<span class="line-modified"> 681   {</span>
<span class="line-modified"> 682     if ((handler-&gt;log_level &amp; log_level) == log_level)</span>
<span class="line-modified"> 683       {</span>
<span class="line-modified"> 684         *data = handler-&gt;data;</span>
<span class="line-modified"> 685         return handler-&gt;log_func;</span>
<span class="line-modified"> 686       }</span>
<span class="line-modified"> 687     handler = handler-&gt;next;</span>
<span class="line-modified"> 688   }</span>
 689     }
 690 
 691   *data = default_log_data;
 692   return default_log_func;
 693 }
 694 
 695 /**
 696  * g_log_set_always_fatal:
 697  * @fatal_mask: the mask containing bits set for each level
 698  *     of error which is to be fatal
 699  *
 700  * Sets the message levels which are always fatal, in any log domain.
 701  * When a message with any of these levels is logged the program terminates.
 702  * You can only set the levels defined by GLib to be fatal.
 703  * %G_LOG_LEVEL_ERROR is always fatal.
 704  *
 705  * You can also make some message levels fatal at runtime by setting
 706  * the `G_DEBUG` environment variable (see
 707  * [Running GLib Applications](glib-running.html)).
 708  *
</pre>
<hr />
<pre>
 744  * @fatal_mask: the new fatal mask
 745  *
 746  * Sets the log levels which are fatal in the given domain.
 747  * %G_LOG_LEVEL_ERROR is always fatal.
 748  *
 749  * This has no effect on structured log messages (using g_log_structured() or
 750  * g_log_structured_array()). To change the fatal behaviour for specific log
 751  * messages, programs must install a custom log writer function using
 752  * g_log_set_writer_func(). See
 753  * [Using Structured Logging][using-structured-logging].
 754  *
 755  * This function is mostly intended to be used with
 756  * %G_LOG_LEVEL_CRITICAL.  You should typically not set
 757  * %G_LOG_LEVEL_WARNING, %G_LOG_LEVEL_MESSAGE, %G_LOG_LEVEL_INFO or
 758  * %G_LOG_LEVEL_DEBUG as fatal except inside of test programs.
 759  *
 760  * Returns: the old fatal mask for the log domain
 761  */
 762 GLogLevelFlags
 763 g_log_set_fatal_mask (const gchar   *log_domain,
<span class="line-modified"> 764           GLogLevelFlags fatal_mask)</span>
 765 {
 766   GLogLevelFlags old_flags;
 767   GLogDomain *domain;
 768 
 769   if (!log_domain)
 770     log_domain = &quot;&quot;;
 771 
 772   /* force errors to be fatal */
 773   fatal_mask |= G_LOG_LEVEL_ERROR;
 774   /* remove bogus flag */
 775   fatal_mask &amp;= ~G_LOG_FLAG_FATAL;
 776 
 777   g_mutex_lock (&amp;g_messages_lock);
 778 
 779   domain = g_log_find_domain_L (log_domain);
 780   if (!domain)
 781     domain = g_log_domain_new_L (log_domain);
 782   old_flags = domain-&gt;fatal_mask;
 783 
 784   domain-&gt;fatal_mask = fatal_mask;
</pre>
<hr />
<pre>
 903 
 904 /**
 905  * g_log_set_default_handler:
 906  * @log_func: the log handler function
 907  * @user_data: data passed to the log handler
 908  *
 909  * Installs a default log handler which is used if no
 910  * log handler has been set for the particular log domain
 911  * and log level combination. By default, GLib uses
 912  * g_log_default_handler() as default log handler.
 913  *
 914  * This has no effect if structured logging is enabled; see
 915  * [Using Structured Logging][using-structured-logging].
 916  *
 917  * Returns: the previous default log handler
 918  *
 919  * Since: 2.6
 920  */
 921 GLogFunc
 922 g_log_set_default_handler (GLogFunc log_func,
<span class="line-modified"> 923          gpointer user_data)</span>
 924 {
 925   GLogFunc old_log_func;
 926 
 927   g_mutex_lock (&amp;g_messages_lock);
 928   old_log_func = default_log_func;
 929   default_log_func = log_func;
 930   default_log_data = user_data;
 931   g_mutex_unlock (&amp;g_messages_lock);
 932 
 933   return old_log_func;
 934 }
 935 
 936 /**
 937  * g_test_log_set_fatal_handler:
 938  * @log_func: the log handler function.
 939  * @user_data: data passed to the log handler.
 940  *
 941  * Installs a non-error fatal log handler which can be
 942  * used to decide whether log messages which are counted
 943  * as fatal abort the program.
</pre>
<hr />
<pre>
 968 {
 969   g_mutex_lock (&amp;g_messages_lock);
 970   fatal_log_func = log_func;
 971   fatal_log_data = user_data;
 972   g_mutex_unlock (&amp;g_messages_lock);
 973 }
 974 
 975 /**
 976  * g_log_remove_handler:
 977  * @log_domain: the log domain
 978  * @handler_id: the id of the handler, which was returned
 979  *     in g_log_set_handler()
 980  *
 981  * Removes the log handler.
 982  *
 983  * This has no effect if structured logging is enabled; see
 984  * [Using Structured Logging][using-structured-logging].
 985  */
 986 void
 987 g_log_remove_handler (const gchar *log_domain,
<span class="line-modified"> 988           guint    handler_id)</span>
 989 {
 990   GLogDomain *domain;
 991 
 992   g_return_if_fail (handler_id &gt; 0);
 993 
 994   if (!log_domain)
 995     log_domain = &quot;&quot;;
 996 
 997   g_mutex_lock (&amp;g_messages_lock);
 998   domain = g_log_find_domain_L (log_domain);
 999   if (domain)
1000     {
1001       GLogHandler *work, *last;
1002 
1003       last = NULL;
1004       work = domain-&gt;handlers;
1005       while (work)
<span class="line-modified">1006   {</span>
<span class="line-modified">1007     if (work-&gt;id == handler_id)</span>
<span class="line-modified">1008       {</span>
<span class="line-modified">1009         if (last)</span>
<span class="line-modified">1010     last-&gt;next = work-&gt;next;</span>
<span class="line-modified">1011         else</span>
<span class="line-modified">1012     domain-&gt;handlers = work-&gt;next;</span>
<span class="line-modified">1013         g_log_domain_check_free_L (domain);</span>
<span class="line-modified">1014         g_mutex_unlock (&amp;g_messages_lock);</span>
1015               if (work-&gt;destroy)
1016                 work-&gt;destroy (work-&gt;data);
<span class="line-modified">1017         g_free (work);</span>
<span class="line-modified">1018         return;</span>
<span class="line-modified">1019       }</span>
<span class="line-modified">1020     last = work;</span>
<span class="line-modified">1021     work = last-&gt;next;</span>
<span class="line-modified">1022   }</span>
1023     }
1024   g_mutex_unlock (&amp;g_messages_lock);
1025   g_warning (&quot;%s: could not find handler with id &#39;%d&#39; for domain \&quot;%s\&quot;&quot;,
<span class="line-modified">1026        G_STRLOC, handler_id, log_domain);</span>
1027 }
1028 
1029 #define CHAR_IS_SAFE(wc) (!((wc &lt; 0x20 &amp;&amp; wc != &#39;\t&#39; &amp;&amp; wc != &#39;\n&#39; &amp;&amp; wc != &#39;\r&#39;) || \
<span class="line-modified">1030           (wc == 0x7f) || \</span>
<span class="line-modified">1031           (wc &gt;= 0x80 &amp;&amp; wc &lt; 0xa0)))</span>
1032 
1033 static gchar*
1034 strdup_convert (const gchar *string,
<span class="line-modified">1035     const gchar *charset)</span>
1036 {
1037   if (!g_utf8_validate (string, -1, NULL))
1038     {
1039       GString *gstring = g_string_new (&quot;[Invalid UTF-8] &quot;);
1040       guchar *p;
1041 
1042       for (p = (guchar *)string; *p; p++)
<span class="line-modified">1043   {</span>
<span class="line-modified">1044     if (CHAR_IS_SAFE(*p) &amp;&amp;</span>
<span class="line-modified">1045         !(*p == &#39;\r&#39; &amp;&amp; *(p + 1) != &#39;\n&#39;) &amp;&amp;</span>
<span class="line-modified">1046         *p &lt; 0x80)</span>
<span class="line-modified">1047       g_string_append_c (gstring, *p);</span>
<span class="line-modified">1048     else</span>
<span class="line-modified">1049       g_string_append_printf (gstring, &quot;\\x%02x&quot;, (guint)(guchar)*p);</span>
<span class="line-modified">1050   }</span>
1051 
1052       return g_string_free (gstring, FALSE);
1053     }
1054   else
1055     {
1056       GError *err = NULL;
1057 
1058       gchar *result = g_convert_with_fallback (string, -1, charset, &quot;UTF-8&quot;, &quot;?&quot;, NULL, NULL, &amp;err);
1059       if (result)
<span class="line-modified">1060   return result;</span>
1061       else
<span class="line-modified">1062   {</span>
<span class="line-modified">1063     /* Not thread-safe, but doesn&#39;t matter if we print the warning twice</span>
<span class="line-modified">1064      */</span>
<span class="line-modified">1065     static gboolean warned = FALSE;</span>
<span class="line-modified">1066     if (!warned)</span>
<span class="line-modified">1067       {</span>
<span class="line-modified">1068         warned = TRUE;</span>
<span class="line-modified">1069         _g_fprintf (stderr, &quot;GLib: Cannot convert message: %s\n&quot;, err-&gt;message);</span>
<span class="line-modified">1070       }</span>
<span class="line-modified">1071     g_error_free (err);</span>
<span class="line-modified">1072 </span>
<span class="line-modified">1073     return g_strdup (string);</span>
<span class="line-modified">1074   }</span>
1075     }
1076 }
1077 
1078 /* For a radix of 8 we need at most 3 output bytes for 1 input
1079  * byte. Additionally we might need up to 2 output bytes for the
1080  * readix prefix and 1 byte for the trailing NULL.
1081  */
1082 #define FORMAT_UNSIGNED_BUFSIZE ((GLIB_SIZEOF_LONG * 3) + 3)
1083 
1084 static void
1085 format_unsigned (gchar  *buf,
<span class="line-modified">1086      gulong  num,</span>
<span class="line-modified">1087      guint   radix)</span>
1088 {
1089   gulong tmp;
1090   gchar c;
1091   gint i, n;
1092 
1093   /* we may not call _any_ GLib functions here (or macros like g_return_if_fail()) */
1094 
1095   if (radix != 8 &amp;&amp; radix != 10 &amp;&amp; radix != 16)
1096     {
1097       *buf = &#39;\000&#39;;
1098       return;
1099     }
1100 
1101   if (!num)
1102     {
1103       *buf++ = &#39;0&#39;;
1104       *buf = &#39;\000&#39;;
1105       return;
1106     }
1107 
</pre>
<hr />
<pre>
1120   while (tmp)
1121     {
1122       tmp /= radix;
1123       n++;
1124     }
1125 
1126   i = n;
1127 
1128   /* Again we can&#39;t use g_assert; actually this check should _never_ fail. */
1129   if (n &gt; FORMAT_UNSIGNED_BUFSIZE - 3)
1130     {
1131       *buf = &#39;\000&#39;;
1132       return;
1133     }
1134 
1135   while (num)
1136     {
1137       i--;
1138       c = (num % radix);
1139       if (c &lt; 10)
<span class="line-modified">1140   buf[i] = c + &#39;0&#39;;</span>
1141       else
<span class="line-modified">1142   buf[i] = c + &#39;a&#39; - 10;</span>
1143       num /= radix;
1144     }
1145 
1146   buf[n] = &#39;\000&#39;;
1147 }
1148 
1149 /* string size big enough to hold level prefix */
1150 #define STRING_BUFFER_SIZE  (FORMAT_UNSIGNED_BUFSIZE + 32)
1151 
<span class="line-modified">1152 #define ALERT_LEVELS    (G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING)</span>
1153 
1154 /* these are emitted by the default log handler */
1155 #define DEFAULT_LEVELS (G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING | G_LOG_LEVEL_MESSAGE)
1156 /* these are filtered by G_MESSAGES_DEBUG by the default log handler */
1157 #define INFO_LEVELS (G_LOG_LEVEL_INFO | G_LOG_LEVEL_DEBUG)
1158 
1159 static const gchar *log_level_to_color (GLogLevelFlags log_level,
1160                                         gboolean       use_color);
1161 static const gchar *color_reset        (gboolean       use_color);
1162 
1163 static FILE *
1164 mklevel_prefix (gchar          level_prefix[STRING_BUFFER_SIZE],
1165                 GLogLevelFlags log_level,
1166                 gboolean       use_color)
1167 {
1168   gboolean to_stdout = TRUE;
1169 
1170   /* we may not call _any_ GLib functions here */
1171 
1172   strcpy (level_prefix, log_level_to_color (log_level, use_color));
</pre>
<hr />
<pre>
1180     case G_LOG_LEVEL_CRITICAL:
1181       strcat (level_prefix, &quot;CRITICAL&quot;);
1182       to_stdout = FALSE;
1183       break;
1184     case G_LOG_LEVEL_WARNING:
1185       strcat (level_prefix, &quot;WARNING&quot;);
1186       to_stdout = FALSE;
1187       break;
1188     case G_LOG_LEVEL_MESSAGE:
1189       strcat (level_prefix, &quot;Message&quot;);
1190       to_stdout = FALSE;
1191       break;
1192     case G_LOG_LEVEL_INFO:
1193       strcat (level_prefix, &quot;INFO&quot;);
1194       break;
1195     case G_LOG_LEVEL_DEBUG:
1196       strcat (level_prefix, &quot;DEBUG&quot;);
1197       break;
1198     default:
1199       if (log_level)
<span class="line-modified">1200   {</span>
<span class="line-modified">1201     strcat (level_prefix, &quot;LOG-&quot;);</span>
<span class="line-modified">1202     format_unsigned (level_prefix + 4, log_level &amp; G_LOG_LEVEL_MASK, 16);</span>
<span class="line-modified">1203   }</span>
1204       else
<span class="line-modified">1205   strcat (level_prefix, &quot;LOG&quot;);</span>
1206       break;
1207     }
1208 
1209   strcat (level_prefix, color_reset (use_color));
1210 
1211   if (log_level &amp; G_LOG_FLAG_RECURSION)
1212     strcat (level_prefix, &quot; (recursed)&quot;);
1213   if (log_level &amp; ALERT_LEVELS)
1214     strcat (level_prefix, &quot; **&quot;);
1215 
1216 #ifdef G_OS_WIN32
1217   if ((log_level &amp; G_LOG_FLAG_FATAL) != 0 &amp;&amp; !g_test_initialized ())
1218     win32_keep_fatal_message = TRUE;
1219 #endif
1220   return to_stdout ? stdout : stderr;
1221 }
1222 
1223 typedef struct {
1224   gchar          *log_domain;
1225   GLogLevelFlags  log_level;
</pre>
<hr />
<pre>
1234  * application domain
1235  * @log_level: the log level
1236  * @format: the message format. See the printf() documentation
1237  * @args: the parameters to insert into the format string
1238  *
1239  * Logs an error or debugging message.
1240  *
1241  * If the log level has been set as fatal, G_BREAKPOINT() is called
1242  * to terminate the program. See the documentation for G_BREAKPOINT() for
1243  * details of the debugging options this provides.
1244  *
1245  * If g_log_default_handler() is used as the log handler function, a new-line
1246  * character will automatically be appended to @..., and need not be entered
1247  * manually.
1248  *
1249  * If [structured logging is enabled][using-structured-logging] this will
1250  * output via the structured log writer function (see g_log_set_writer_func()).
1251  */
1252 void
1253 g_logv (const gchar   *log_domain,
<span class="line-modified">1254   GLogLevelFlags log_level,</span>
<span class="line-modified">1255   const gchar   *format,</span>
<span class="line-modified">1256   va_list        args)</span>
1257 {
1258   gboolean was_fatal = (log_level &amp; G_LOG_FLAG_FATAL) != 0;
1259   gboolean was_recursion = (log_level &amp; G_LOG_FLAG_RECURSION) != 0;
1260   gchar buffer[1025], *msg, *msg_alloc = NULL;
1261   gint i;
1262 
1263   log_level &amp;= G_LOG_LEVEL_MASK;
1264   if (!log_level)
1265     return;
1266 
1267   if (log_level &amp; G_LOG_FLAG_RECURSION)
1268     {
1269       /* we use a stack buffer of fixed size, since we&#39;re likely
1270        * in an out-of-memory situation
1271        */
1272       gsize size G_GNUC_UNUSED;
1273 
1274       size = _g_vsnprintf (buffer, 1024, format, args);
1275       msg = buffer;
1276     }
</pre>
<hr />
<pre>
1298           gchar level_prefix[STRING_BUFFER_SIZE];
1299           gchar *expected_message;
1300 
1301           mklevel_prefix (level_prefix, expected-&gt;log_level, FALSE);
1302           expected_message = g_strdup_printf (&quot;Did not see expected message %s-%s: %s&quot;,
1303                                               expected-&gt;log_domain ? expected-&gt;log_domain : &quot;**&quot;,
1304                                               level_prefix, expected-&gt;pattern);
1305           g_log_default_handler (G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL, expected_message, NULL);
1306           g_free (expected_message);
1307 
1308           log_level |= G_LOG_FLAG_FATAL;
1309         }
1310     }
1311 
1312   for (i = g_bit_nth_msf (log_level, -1); i &gt;= 0; i = g_bit_nth_msf (log_level, i))
1313     {
1314       GLogLevelFlags test_level;
1315 
1316       test_level = 1 &lt;&lt; i;
1317       if (log_level &amp; test_level)
<span class="line-modified">1318   {</span>
<span class="line-modified">1319     GLogDomain *domain;</span>
<span class="line-modified">1320     GLogFunc log_func;</span>
<span class="line-modified">1321     GLogLevelFlags domain_fatal_mask;</span>
<span class="line-modified">1322     gpointer data = NULL;</span>
1323           gboolean masquerade_fatal = FALSE;
1324           guint depth;
1325 
<span class="line-modified">1326     if (was_fatal)</span>
<span class="line-modified">1327       test_level |= G_LOG_FLAG_FATAL;</span>
<span class="line-modified">1328     if (was_recursion)</span>
<span class="line-modified">1329       test_level |= G_LOG_FLAG_RECURSION;</span>
1330 
<span class="line-modified">1331     /* check recursion and lookup handler */</span>
<span class="line-modified">1332     g_mutex_lock (&amp;g_messages_lock);</span>
1333           depth = GPOINTER_TO_UINT (g_private_get (&amp;g_log_depth));
<span class="line-modified">1334     domain = g_log_find_domain_L (log_domain ? log_domain : &quot;&quot;);</span>
<span class="line-modified">1335     if (depth)</span>
<span class="line-modified">1336       test_level |= G_LOG_FLAG_RECURSION;</span>
<span class="line-modified">1337     depth++;</span>
<span class="line-modified">1338     domain_fatal_mask = domain ? domain-&gt;fatal_mask : G_LOG_FATAL_MASK;</span>
<span class="line-modified">1339     if ((domain_fatal_mask | g_log_always_fatal) &amp; test_level)</span>
<span class="line-modified">1340       test_level |= G_LOG_FLAG_FATAL;</span>
<span class="line-modified">1341     if (test_level &amp; G_LOG_FLAG_RECURSION)</span>
<span class="line-modified">1342       log_func = _g_log_fallback_handler;</span>
<span class="line-modified">1343     else</span>
<span class="line-modified">1344       log_func = g_log_domain_get_handler_L (domain, test_level, &amp;data);</span>
<span class="line-modified">1345     domain = NULL;</span>
<span class="line-modified">1346     g_mutex_unlock (&amp;g_messages_lock);</span>
<span class="line-modified">1347 </span>
<span class="line-modified">1348     g_private_set (&amp;g_log_depth, GUINT_TO_POINTER (depth));</span>
1349 
1350           log_func (log_domain, test_level, msg, data);
1351 
1352           if ((test_level &amp; G_LOG_FLAG_FATAL)
1353               &amp;&amp; !(test_level &amp; G_LOG_LEVEL_ERROR))
1354             {
1355               masquerade_fatal = fatal_log_func
1356                 &amp;&amp; !fatal_log_func (log_domain, test_level, msg, fatal_log_data);
1357             }
1358 
1359           if ((test_level &amp; G_LOG_FLAG_FATAL) &amp;&amp; !masquerade_fatal)
1360             {
<span class="line-modified">1361               /* MessageBox is allowed on UWP apps only when building against</span>
<span class="line-added">1362                * the debug CRT, which will set -D_DEBUG */</span>
<span class="line-added">1363 #if defined(G_OS_WIN32) &amp;&amp; (defined(_DEBUG) || !defined(G_WINAPI_ONLY_APP))</span>
1364               if (win32_keep_fatal_message)
1365                 {
1366                   gchar *locale_msg = g_locale_from_utf8 (fatal_msg_buf, -1, NULL, NULL, NULL);
1367 
1368                   MessageBox (NULL, locale_msg, NULL,
1369                               MB_ICONERROR|MB_SETFOREGROUND);
1370                 }
<span class="line-modified">1371 #endif</span>
1372 
<span class="line-modified">1373               _g_log_abort (!(test_level &amp; G_LOG_FLAG_RECURSION));</span>
<span class="line-modified">1374       }</span>
1375 
<span class="line-modified">1376     depth--;</span>
<span class="line-modified">1377     g_private_set (&amp;g_log_depth, GUINT_TO_POINTER (depth));</span>
<span class="line-modified">1378   }</span>
1379     }
1380 
1381   g_free (msg_alloc);
1382 }
1383 
1384 /**
1385  * g_log:
1386  * @log_domain: (nullable): the log domain, usually #G_LOG_DOMAIN, or %NULL
1387  * for the default
1388  * @log_level: the log level, either from #GLogLevelFlags
1389  *     or a user-defined level
1390  * @format: the message format. See the printf() documentation
1391  * @...: the parameters to insert into the format string
1392  *
1393  * Logs an error or debugging message.
1394  *
1395  * If the log level has been set as fatal, G_BREAKPOINT() is called
1396  * to terminate the program. See the documentation for G_BREAKPOINT() for
1397  * details of the debugging options this provides.
1398  *
</pre>
<hr />
<pre>
2150  * Check whether the given @output_fd file descriptor is a connection to the
2151  * systemd journal, or something else (like a log file or `stdout` or
2152  * `stderr`).
2153  *
2154  * Invalid file descriptors are accepted and return %FALSE, which allows for
2155  * the following construct without needing any additional error handling:
2156  * |[&lt;!-- language=&quot;C&quot; --&gt;
2157  *   is_journald = g_log_writer_is_journald (fileno (stderr));
2158  * ]|
2159  *
2160  * Returns: %TRUE if @output_fd points to the journal, %FALSE otherwise
2161  * Since: 2.50
2162  */
2163 gboolean
2164 g_log_writer_is_journald (gint output_fd)
2165 {
2166 #if defined(__linux__) &amp;&amp; !defined(__BIONIC__)
2167   /* FIXME: Use the new journal API for detecting whether we&#39;re writing to the
2168    * journal. See: https://github.com/systemd/systemd/issues/2473
2169    */
<span class="line-modified">2170   union {</span>
<span class="line-modified">2171     struct sockaddr_storage storage;</span>
<span class="line-added">2172     struct sockaddr sa;</span>
<span class="line-added">2173     struct sockaddr_un un;</span>
<span class="line-added">2174   } addr;</span>
<span class="line-added">2175   socklen_t addr_len;</span>
<span class="line-added">2176   int err;</span>
2177 
2178   if (output_fd &lt; 0)
2179     return FALSE;
2180 
<span class="line-modified">2181   addr_len = sizeof(addr);</span>
<span class="line-modified">2182   err = getpeername (output_fd, &amp;addr.sa, &amp;addr_len);</span>
<span class="line-modified">2183   if (err == 0 &amp;&amp; addr.storage.ss_family == AF_UNIX)</span>
<span class="line-modified">2184     return g_str_has_prefix (addr.un.sun_path, &quot;/run/systemd/journal/&quot;);</span>
<span class="line-modified">2185 #endif</span>









2186 


2187   return FALSE;

2188 }
2189 
2190 static void escape_string (GString *string);
2191 
2192 /**
2193  * g_log_writer_format_fields:
2194  * @log_level: log level, either from #GLogLevelFlags, or a user-defined
2195  *    level
2196  * @fields: (array length=n_fields): key-value pairs of structured data forming
2197  *    the log message
2198  * @n_fields: number of elements in the @fields array
2199  * @use_color: %TRUE to use ANSI color escape sequences when formatting the
2200  *    message, %FALSE to not
2201  *
2202  * Format a structured log message as a string suitable for outputting to the
2203  * terminal (or elsewhere). This will include the values of all fields it knows
2204  * how to interpret, which includes `MESSAGE` and `GLIB_DOMAIN` (see the
2205  * documentation for g_log_structured()). It does not include values from
2206  * unknown fields.
2207  *
</pre>
<hr />
<pre>
2276   now_tm = localtime (&amp;now_secs);
2277   strftime (time_buf, sizeof (time_buf), &quot;%H:%M:%S&quot;, now_tm);
2278 
2279   g_string_append_printf (gstring, &quot;%s%s.%03d%s: &quot;,
2280                           use_color ? &quot;\033[34m&quot; : &quot;&quot;,
2281                           time_buf, (gint) ((now / 1000) % 1000),
2282                           color_reset (use_color));
2283 
2284   if (message == NULL)
2285     {
2286       g_string_append (gstring, &quot;(NULL) message&quot;);
2287     }
2288   else
2289     {
2290       GString *msg;
2291       const gchar *charset;
2292 
2293       msg = g_string_new (message);
2294       escape_string (msg);
2295 
<span class="line-modified">2296       if (g_get_console_charset (&amp;charset))</span>
2297         {
2298           /* charset is UTF-8 already */
2299           g_string_append (gstring, msg-&gt;str);
2300         }
2301       else
2302         {
2303           gchar *lstring = strdup_convert (msg-&gt;str, charset);
2304           g_string_append (gstring, lstring);
2305           g_free (lstring);
2306         }
2307 
2308       g_string_free (msg, TRUE);
2309     }
2310 
2311   return g_string_free (gstring, FALSE);
2312 }
2313 
2314 /* Enable support for the journal if we&#39;re on a recent enough Linux */
2315 #if defined(__linux__) &amp;&amp; !defined(__BIONIC__) &amp;&amp; defined(HAVE_MKOSTEMP) &amp;&amp; defined(O_CLOEXEC)
2316 #define ENABLE_JOURNAL_SENDV
</pre>
<hr />
<pre>
2598  * Support for other platform-specific logging mechanisms may be added in
2599  * future. Distributors of GLib may modify this function to impose their own
2600  * (documented) platform-specific log writing policies.
2601  *
2602  * This is suitable for use as a #GLogWriterFunc, and is the default writer used
2603  * if no other is set using g_log_set_writer_func().
2604  *
2605  * As with g_log_default_handler(), this function drops debug and informational
2606  * messages unless their log domain (or `all`) is listed in the space-separated
2607  * `G_MESSAGES_DEBUG` environment variable.
2608  *
2609  * Returns: %G_LOG_WRITER_HANDLED on success, %G_LOG_WRITER_UNHANDLED otherwise
2610  * Since: 2.50
2611  */
2612 GLogWriterOutput
2613 g_log_writer_default (GLogLevelFlags   log_level,
2614                       const GLogField *fields,
2615                       gsize            n_fields,
2616                       gpointer         user_data)
2617 {
<span class="line-added">2618   static gsize initialized = 0;</span>
<span class="line-added">2619   static gboolean stderr_is_journal = FALSE;</span>
<span class="line-added">2620 </span>
2621   g_return_val_if_fail (fields != NULL, G_LOG_WRITER_UNHANDLED);
2622   g_return_val_if_fail (n_fields &gt; 0, G_LOG_WRITER_UNHANDLED);
2623 
2624   /* Disable debug message output unless specified in G_MESSAGES_DEBUG. */
2625   if (!(log_level &amp; DEFAULT_LEVELS) &amp;&amp; !(log_level &gt;&gt; G_LOG_LEVEL_USER_SHIFT))
2626     {
2627       const gchar *domains, *log_domain = NULL;
2628       gsize i;
2629 
2630       domains = g_getenv (&quot;G_MESSAGES_DEBUG&quot;);
2631 
2632       if ((log_level &amp; INFO_LEVELS) == 0 ||
2633           domains == NULL)
2634         return G_LOG_WRITER_HANDLED;
2635 
2636       for (i = 0; i &lt; n_fields; i++)
2637         {
2638           if (g_strcmp0 (fields[i].key, &quot;GLIB_DOMAIN&quot;) == 0)
2639             {
2640               log_domain = fields[i].value;
2641               break;
2642             }
2643         }
2644 
2645       if (strcmp (domains, &quot;all&quot;) != 0 &amp;&amp;
2646           (log_domain == NULL || !strstr (domains, log_domain)))
2647         return G_LOG_WRITER_HANDLED;
2648     }
2649 
2650   /* Mark messages as fatal if they have a level set in
2651    * g_log_set_always_fatal().
2652    */
2653   if ((log_level &amp; g_log_always_fatal) &amp;&amp; !log_is_old_api (fields, n_fields))
2654     log_level |= G_LOG_FLAG_FATAL;
2655 
2656   /* Try logging to the systemd journal as first choice. */
<span class="line-modified">2657   if (g_once_init_enter (&amp;initialized))</span>
<span class="line-added">2658     {</span>
<span class="line-added">2659       stderr_is_journal = g_log_writer_is_journald (fileno (stderr));</span>
<span class="line-added">2660       g_once_init_leave (&amp;initialized, TRUE);</span>
<span class="line-added">2661     }</span>
<span class="line-added">2662 </span>
<span class="line-added">2663   if (stderr_is_journal &amp;&amp;</span>
2664       g_log_writer_journald (log_level, fields, n_fields, user_data) ==
2665       G_LOG_WRITER_HANDLED)
2666     goto handled;
2667 
2668   /* FIXME: Add support for the Windows log. */
2669 
2670   if (g_log_writer_standard_streams (log_level, fields, n_fields, user_data) ==
2671       G_LOG_WRITER_HANDLED)
2672     goto handled;
2673 
2674   return G_LOG_WRITER_UNHANDLED;
2675 
2676 handled:
2677   /* Abort if the message was fatal. */
2678   if (log_level &amp; G_LOG_FLAG_FATAL)
2679     {
<span class="line-modified">2680       /* MessageBox is allowed on UWP apps only when building against</span>
<span class="line-added">2681        * the debug CRT, which will set -D_DEBUG */</span>
<span class="line-added">2682 #if defined(G_OS_WIN32) &amp;&amp; (defined(_DEBUG) || !defined(G_WINAPI_ONLY_APP))</span>
2683       if (!g_test_initialized ())
2684         {
2685           gchar *locale_msg = NULL;
2686 
2687           locale_msg = g_locale_from_utf8 (fatal_msg_buf, -1, NULL, NULL, NULL);
2688           MessageBox (NULL, locale_msg, NULL,
2689                       MB_ICONERROR | MB_SETFOREGROUND);
2690           g_free (locale_msg);
2691         }
2692 #endif /* !G_OS_WIN32 */
2693 
2694       _g_log_abort (!(log_level &amp; G_LOG_FLAG_RECURSION));
2695     }
2696 
2697   return G_LOG_WRITER_HANDLED;
2698 }
2699 
2700 static GLogWriterOutput
2701 _g_log_writer_fallback (GLogLevelFlags   log_level,
2702                         const GLogField *fields,
</pre>
<hr />
<pre>
2739       write_string (stream, field-&gt;key);
2740       write_string (stream, &quot;=&quot;);
2741       write_string_sized (stream, field-&gt;value, field-&gt;length);
2742     }
2743 
2744 #ifndef G_OS_WIN32
2745   {
2746     gchar pid_string[FORMAT_UNSIGNED_BUFSIZE];
2747 
2748     format_unsigned (pid_string, getpid (), 10);
2749     write_string (stream, &quot;_PID=&quot;);
2750     write_string (stream, pid_string);
2751   }
2752 #endif
2753 
2754   return G_LOG_WRITER_HANDLED;
2755 }
2756 
2757 /**
2758  * g_return_if_fail_warning: (skip)
<span class="line-modified">2759  * @log_domain: (nullable): log domain</span>
<span class="line-modified">2760  * @pretty_function: function containing the assertion</span>
<span class="line-modified">2761  * @expression: (nullable): expression which failed</span>
<span class="line-added">2762  *</span>
<span class="line-added">2763  * Internal function used to print messages from the public g_return_if_fail()</span>
<span class="line-added">2764  * and g_return_val_if_fail() macros.</span>
2765  */
2766 void
2767 g_return_if_fail_warning (const char *log_domain,
<span class="line-modified">2768         const char *pretty_function,</span>
<span class="line-modified">2769         const char *expression)</span>
2770 {
2771   g_log (log_domain,
<span class="line-modified">2772    G_LOG_LEVEL_CRITICAL,</span>
<span class="line-modified">2773    &quot;%s: assertion &#39;%s&#39; failed&quot;,</span>
<span class="line-modified">2774    pretty_function,</span>
<span class="line-modified">2775    expression);</span>
2776 }
2777 
2778 /**
2779  * g_warn_message: (skip)
<span class="line-modified">2780  * @domain: (nullable): log domain</span>
<span class="line-modified">2781  * @file: file containing the warning</span>
<span class="line-modified">2782  * @line: line number of the warning</span>
<span class="line-modified">2783  * @func: function containing the warning</span>
<span class="line-modified">2784  * @warnexpr: (nullable): expression which failed</span>
<span class="line-added">2785  *</span>
<span class="line-added">2786  * Internal function used to print messages from the public g_warn_if_reached()</span>
<span class="line-added">2787  * and g_warn_if_fail() macros.</span>
2788  */
2789 void
2790 g_warn_message (const char     *domain,
2791                 const char     *file,
2792                 int             line,
2793                 const char     *func,
2794                 const char     *warnexpr)
2795 {
2796   char *s, lstr[32];
2797   g_snprintf (lstr, 32, &quot;%d&quot;, line);
2798   if (warnexpr)
2799     s = g_strconcat (&quot;(&quot;, file, &quot;:&quot;, lstr, &quot;):&quot;,
2800                      func, func[0] ? &quot;:&quot; : &quot;&quot;,
2801                      &quot; runtime check failed: (&quot;, warnexpr, &quot;)&quot;, NULL);
2802   else
2803     s = g_strconcat (&quot;(&quot;, file, &quot;:&quot;, lstr, &quot;):&quot;,
2804                      func, func[0] ? &quot;:&quot; : &quot;&quot;,
2805                      &quot; &quot;, &quot;code should not be reached&quot;, NULL);
2806   g_log (domain, G_LOG_LEVEL_WARNING, &quot;%s&quot;, s);
2807   g_free (s);
2808 }
2809 
2810 void
2811 g_assert_warning (const char *log_domain,
<span class="line-modified">2812       const char *file,</span>
<span class="line-modified">2813       const int   line,</span>
<span class="line-modified">2814       const char *pretty_function,</span>
<span class="line-modified">2815       const char *expression)</span>
2816 {
2817   if (expression)
2818     g_log (log_domain,
<span class="line-modified">2819      G_LOG_LEVEL_ERROR,</span>
<span class="line-modified">2820      &quot;file %s: line %d (%s): assertion failed: (%s)&quot;,</span>
<span class="line-modified">2821      file,</span>
<span class="line-modified">2822      line,</span>
<span class="line-modified">2823      pretty_function,</span>
<span class="line-modified">2824      expression);</span>
2825   else
2826     g_log (log_domain,
<span class="line-modified">2827      G_LOG_LEVEL_ERROR,</span>
<span class="line-modified">2828      &quot;file %s: line %d (%s): should not be reached&quot;,</span>
<span class="line-modified">2829      file,</span>
<span class="line-modified">2830      line,</span>
<span class="line-modified">2831      pretty_function);</span>
2832   _g_log_abort (FALSE);
2833   g_abort ();
2834 }
2835 
2836 /**
2837  * g_test_expect_message:
2838  * @log_domain: (nullable): the log domain of the message
2839  * @log_level: the log level of the message
2840  * @pattern: a glob-style [pattern][glib-Glob-style-pattern-matching]
2841  *
2842  * Indicates that a message with the given @log_domain and @log_level,
2843  * with text matching @pattern, is expected to be logged. When this
2844  * message is logged, it will not be printed, and the test case will
2845  * not abort.
2846  *
2847  * This API may only be used with the old logging API (g_log() without
2848  * %G_LOG_USE_STRUCTURED defined). It will not work with the structured logging
2849  * API. See [Testing for Messages][testing-for-messages].
2850  *
2851  * Use g_test_assert_expected_messages() to assert that all
</pre>
<hr />
<pre>
2919 }
2920 
2921 /**
2922  * g_test_assert_expected_messages:
2923  *
2924  * Asserts that all messages previously indicated via
2925  * g_test_expect_message() have been seen and suppressed.
2926  *
2927  * This API may only be used with the old logging API (g_log() without
2928  * %G_LOG_USE_STRUCTURED defined). It will not work with the structured logging
2929  * API. See [Testing for Messages][testing-for-messages].
2930  *
2931  * If messages at %G_LOG_LEVEL_DEBUG are emitted, but not explicitly
2932  * expected via g_test_expect_message() then they will be ignored.
2933  *
2934  * Since: 2.34
2935  */
2936 
2937 void
2938 _g_log_fallback_handler (const gchar   *log_domain,
<span class="line-modified">2939        GLogLevelFlags log_level,</span>
<span class="line-modified">2940        const gchar   *message,</span>
<span class="line-modified">2941        gpointer       unused_data)</span>
2942 {
2943   gchar level_prefix[STRING_BUFFER_SIZE];
2944 #ifndef G_OS_WIN32
2945   gchar pid_string[FORMAT_UNSIGNED_BUFSIZE];
2946 #endif
2947   FILE *stream;
2948 
2949   /* we cannot call _any_ GLib functions in this fallback handler,
2950    * which is why we skip UTF-8 conversion, etc.
2951    * since we either recursed or ran out of memory, we&#39;re in a pretty
2952    * pathologic situation anyways, what we can do is giving the
2953    * the process ID unconditionally however.
2954    */
2955 
2956   stream = mklevel_prefix (level_prefix, log_level, FALSE);
2957   if (!message)
2958     message = &quot;(NULL) message&quot;;
2959 
2960 #ifndef G_OS_WIN32
2961   format_unsigned (pid_string, getpid (), 10);
</pre>
<hr />
<pre>
2977       write_string (stream, log_domain);
2978       write_string (stream, &quot;-&quot;);
2979     }
2980   write_string (stream, level_prefix);
2981   write_string (stream, &quot;: &quot;);
2982   write_string (stream, message);
2983 }
2984 
2985 static void
2986 escape_string (GString *string)
2987 {
2988   const char *p = string-&gt;str;
2989   gunichar wc;
2990 
2991   while (p &lt; string-&gt;str + string-&gt;len)
2992     {
2993       gboolean safe;
2994 
2995       wc = g_utf8_get_char_validated (p, -1);
2996       if (wc == (gunichar)-1 || wc == (gunichar)-2)
<span class="line-modified">2997   {</span>
<span class="line-modified">2998     gchar *tmp;</span>
<span class="line-modified">2999     guint pos;</span>
3000 
<span class="line-modified">3001     pos = p - string-&gt;str;</span>
3002 
<span class="line-modified">3003     /* Emit invalid UTF-8 as hex escapes</span>
3004            */
<span class="line-modified">3005     tmp = g_strdup_printf (&quot;\\x%02x&quot;, (guint)(guchar)*p);</span>
<span class="line-modified">3006     g_string_erase (string, pos, 1);</span>
<span class="line-modified">3007     g_string_insert (string, pos, tmp);</span>
3008 
<span class="line-modified">3009     p = string-&gt;str + (pos + 4); /* Skip over escape sequence */</span>
3010 
<span class="line-modified">3011     g_free (tmp);</span>
<span class="line-modified">3012     continue;</span>
<span class="line-modified">3013   }</span>
3014       if (wc == &#39;\r&#39;)
<span class="line-modified">3015   {</span>
<span class="line-modified">3016     safe = *(p + 1) == &#39;\n&#39;;</span>
<span class="line-modified">3017   }</span>
3018       else
<span class="line-modified">3019   {</span>
<span class="line-modified">3020     safe = CHAR_IS_SAFE (wc);</span>
<span class="line-modified">3021   }</span>
3022 
3023       if (!safe)
<span class="line-modified">3024   {</span>
<span class="line-modified">3025     gchar *tmp;</span>
<span class="line-modified">3026     guint pos;</span>
3027 
<span class="line-modified">3028     pos = p - string-&gt;str;</span>
3029 
<span class="line-modified">3030     /* Largest char we escape is 0x0a, so we don&#39;t have to worry</span>
<span class="line-modified">3031      * about 8-digit \Uxxxxyyyy</span>
<span class="line-modified">3032      */</span>
<span class="line-modified">3033     tmp = g_strdup_printf (&quot;\\u%04x&quot;, wc);</span>
<span class="line-modified">3034     g_string_erase (string, pos, g_utf8_next_char (p) - p);</span>
<span class="line-modified">3035     g_string_insert (string, pos, tmp);</span>
<span class="line-modified">3036     g_free (tmp);</span>
3037 
<span class="line-modified">3038     p = string-&gt;str + (pos + 6); /* Skip over escape sequence */</span>
<span class="line-modified">3039   }</span>
3040       else
<span class="line-modified">3041   p = g_utf8_next_char (p);</span>
3042     }
3043 }
3044 
3045 /**
3046  * g_log_default_handler:
3047  * @log_domain: (nullable): the log domain of the message, or %NULL for the
3048  * default &quot;&quot; application domain
3049  * @log_level: the level of the message
3050  * @message: (nullable): the message
3051  * @unused_data: (nullable): data passed from g_log() which is unused
3052  *
3053  * The default log handler set up by GLib; g_log_set_default_handler()
3054  * allows to install an alternate default log handler.
3055  * This is used if no log handler has been set for the particular log
3056  * domain and log level combination. It outputs the message to stderr
3057  * or stdout and if the log level is fatal it calls G_BREAKPOINT(). It automatically
3058  * prints a new-line character after the message, so one does not need to be
3059  * manually included in @message.
3060  *
3061  * The behavior of this log handler can be influenced by a number of
3062  * environment variables:
3063  *
3064  * - `G_MESSAGES_PREFIXED`: A :-separated list of log levels for which
3065  *   messages should be prefixed by the program name and PID of the
3066  *   aplication.
3067  *
3068  * - `G_MESSAGES_DEBUG`: A space-separated list of log domains for
3069  *   which debug and informational messages are printed. By default
3070  *   these messages are not printed.
3071  *
3072  * stderr is used for levels %G_LOG_LEVEL_ERROR, %G_LOG_LEVEL_CRITICAL,
3073  * %G_LOG_LEVEL_WARNING and %G_LOG_LEVEL_MESSAGE. stdout is used for
3074  * the rest.
3075  *
3076  * This has no effect if structured logging is enabled; see
3077  * [Using Structured Logging][using-structured-logging].
3078  */
3079 void
3080 g_log_default_handler (const gchar   *log_domain,
<span class="line-modified">3081            GLogLevelFlags log_level,</span>
<span class="line-modified">3082            const gchar   *message,</span>
<span class="line-modified">3083            gpointer       unused_data)</span>
3084 {
3085   GLogField fields[4];
3086   int n_fields = 0;
3087 
3088   /* we can be called externally with recursion for whatever reason */
3089   if (log_level &amp; G_LOG_FLAG_RECURSION)
3090     {
3091       _g_log_fallback_handler (log_domain, log_level, message, unused_data);
3092       return;
3093     }
3094 
3095   fields[0].key = &quot;GLIB_OLD_LOG_API&quot;;
3096   fields[0].value = &quot;1&quot;;
3097   fields[0].length = -1;
3098   n_fields++;
3099 
3100   fields[1].key = &quot;MESSAGE&quot;;
3101   fields[1].value = message;
3102   fields[1].length = -1;
3103   n_fields++;
3104 
3105   fields[2].key = &quot;PRIORITY&quot;;
3106   fields[2].value = log_level_to_priority (log_level);
3107   fields[2].length = -1;
3108   n_fields++;
3109 
3110   if (log_domain)
3111     {
3112       fields[3].key = &quot;GLIB_DOMAIN&quot;;
3113       fields[3].value = log_domain;
3114       fields[3].length = -1;
3115       n_fields++;
3116     }
3117 
3118   /* Print out via the structured log API, but drop any fatal flags since we
3119    * have already handled them. The fatal handling in the structured logging
3120    * API is more coarse-grained than in the old g_log() API, so we don&#39;t want
3121    * to use it here.
3122    */
3123   g_log_structured_array (log_level &amp; ~G_LOG_FLAG_FATAL, fields, n_fields);
<span class="line-modified">3124 }</span>
3125 
3126 /**
3127  * g_set_print_handler:
3128  * @func: the new print handler
3129  *
3130  * Sets the print handler.
3131  *
3132  * Any messages passed to g_print() will be output via
3133  * the new handler. The default handler simply outputs
3134  * the message to stdout. By providing your own handler
3135  * you can redirect the output, to a GTK+ widget or a
3136  * log file for example.
3137  *
3138  * Returns: the old print handler
3139  */
3140 GPrintFunc
3141 g_set_print_handler (GPrintFunc func)
3142 {
3143   GPrintFunc old_print_func;
3144 
</pre>
<hr />
<pre>
3173   va_list args;
3174   gchar *string;
3175   GPrintFunc local_glib_print_func;
3176 
3177   g_return_if_fail (format != NULL);
3178 
3179   va_start (args, format);
3180   string = g_strdup_vprintf (format, args);
3181   va_end (args);
3182 
3183   g_mutex_lock (&amp;g_messages_lock);
3184   local_glib_print_func = glib_print_func;
3185   g_mutex_unlock (&amp;g_messages_lock);
3186 
3187   if (local_glib_print_func)
3188     local_glib_print_func (string);
3189   else
3190     {
3191       const gchar *charset;
3192 
<span class="line-modified">3193       if (g_get_console_charset (&amp;charset))</span>
3194         fputs (string, stdout); /* charset is UTF-8 already */
3195       else
3196         {
3197           gchar *lstring = strdup_convert (string, charset);
3198 
3199           fputs (lstring, stdout);
3200           g_free (lstring);
3201         }
3202       fflush (stdout);
3203     }
3204   g_free (string);
3205 }
3206 
3207 /**
3208  * g_set_printerr_handler:
3209  * @func: the new error message handler
3210  *
3211  * Sets the handler for printing error messages.
3212  *
3213  * Any messages passed to g_printerr() will be output via
</pre>
<hr />
<pre>
3252   va_list args;
3253   gchar *string;
3254   GPrintFunc local_glib_printerr_func;
3255 
3256   g_return_if_fail (format != NULL);
3257 
3258   va_start (args, format);
3259   string = g_strdup_vprintf (format, args);
3260   va_end (args);
3261 
3262   g_mutex_lock (&amp;g_messages_lock);
3263   local_glib_printerr_func = glib_printerr_func;
3264   g_mutex_unlock (&amp;g_messages_lock);
3265 
3266   if (local_glib_printerr_func)
3267     local_glib_printerr_func (string);
3268   else
3269     {
3270       const gchar *charset;
3271 
<span class="line-modified">3272       if (g_get_console_charset (&amp;charset))</span>
3273         fputs (string, stderr); /* charset is UTF-8 already */
3274       else
3275         {
3276           gchar *lstring = strdup_convert (string, charset);
3277 
3278           fputs (lstring, stderr);
3279           g_free (lstring);
3280         }
3281       fflush (stderr);
3282     }
3283   g_free (string);
3284 }
3285 
3286 /**
3287  * g_printf_string_upper_bound:
3288  * @format: the format string. See the printf() documentation
3289  * @args: the parameters to be inserted into the format string
3290  *
3291  * Calculates the maximum space needed to store the output
3292  * of the sprintf() function.
</pre>
</td>
</tr>
</table>
<center><a href="gmem.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gmessages.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>