<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gbookmarkfile.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* gbookmarkfile.c: parsing and building desktop bookmarks
   2  *
   3  * Copyright (C) 2005-2006 Emmanuele Bassi
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public License
  16  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  */
  18 
  19 #include &quot;config.h&quot;
  20 
  21 #include &quot;gbookmarkfile.h&quot;
  22 
  23 #include &lt;stdio.h&gt;
  24 #include &lt;stdlib.h&gt;
  25 #include &lt;string.h&gt;
  26 #include &lt;errno.h&gt;
  27 #include &lt;fcntl.h&gt;
  28 #include &lt;locale.h&gt;
  29 #include &lt;time.h&gt;
  30 #include &lt;stdarg.h&gt;
  31 
  32 #include &quot;gconvert.h&quot;
  33 #include &quot;gdataset.h&quot;
  34 #include &quot;gerror.h&quot;
  35 #include &quot;gfileutils.h&quot;
  36 #include &quot;ghash.h&quot;
  37 #include &quot;glibintl.h&quot;
  38 #include &quot;glist.h&quot;
  39 #include &quot;gmain.h&quot;
  40 #include &quot;gmarkup.h&quot;
  41 #include &quot;gmem.h&quot;
  42 #include &quot;gmessages.h&quot;
  43 #include &quot;gshell.h&quot;
  44 #include &quot;gslice.h&quot;
  45 #include &quot;gstdio.h&quot;
  46 #include &quot;gstring.h&quot;
  47 #include &quot;gstrfuncs.h&quot;
  48 #include &quot;gtimer.h&quot;
  49 #include &quot;gutils.h&quot;
  50 
  51 
  52 /**
  53  * SECTION:bookmarkfile
  54  * @title: Bookmark file parser
  55  * @short_description: parses files containing bookmarks
  56  *
  57  * GBookmarkFile lets you parse, edit or create files containing bookmarks
  58  * to URI, along with some meta-data about the resource pointed by the URI
  59  * like its MIME type, the application that is registering the bookmark and
  60  * the icon that should be used to represent the bookmark. The data is stored
  61  * using the
  62  * [Desktop Bookmark Specification](http://www.gnome.org/~ebassi/bookmark-spec).
  63  *
  64  * The syntax of the bookmark files is described in detail inside the
  65  * Desktop Bookmark Specification, here is a quick summary: bookmark
  66  * files use a sub-class of the XML Bookmark Exchange Language
  67  * specification, consisting of valid UTF-8 encoded XML, under the
  68  * &lt;xbel&gt; root element; each bookmark is stored inside a
  69  * &lt;bookmark&gt; element, using its URI: no relative paths can
  70  * be used inside a bookmark file. The bookmark may have a user defined
  71  * title and description, to be used instead of the URI. Under the
  72  * &lt;metadata&gt; element, with its owner attribute set to
  73  * `http://freedesktop.org`, is stored the meta-data about a resource
  74  * pointed by its URI. The meta-data consists of the resource&#39;s MIME
  75  * type; the applications that have registered a bookmark; the groups
  76  * to which a bookmark belongs to; a visibility flag, used to set the
  77  * bookmark as &quot;private&quot; to the applications and groups that has it
  78  * registered; the URI and MIME type of an icon, to be used when
  79  * displaying the bookmark inside a GUI.
  80  *
  81  * Here is an example of a bookmark file:
  82  * [bookmarks.xbel](https://git.gnome.org/browse/glib/tree/glib/tests/bookmarks.xbel)
  83  *
  84  * A bookmark file might contain more than one bookmark; each bookmark
  85  * is accessed through its URI.
  86  *
  87  * The important caveat of bookmark files is that when you add a new
  88  * bookmark you must also add the application that is registering it, using
  89  * g_bookmark_file_add_application() or g_bookmark_file_set_app_info().
  90  * If a bookmark has no applications then it won&#39;t be dumped when creating
  91  * the on disk representation, using g_bookmark_file_to_data() or
  92  * g_bookmark_file_to_file().
  93  *
  94  * The #GBookmarkFile parser was added in GLib 2.12.
  95  */
  96 
  97 /* XBEL 1.0 standard entities */
<a name="1" id="anc1"></a><span class="line-modified">  98 #define XBEL_VERSION        &quot;1.0&quot;</span>
<span class="line-modified">  99 #define XBEL_DTD_NICK       &quot;xbel&quot;</span>
<span class="line-modified"> 100 #define XBEL_DTD_SYSTEM     &quot;+//IDN python.org//DTD XML Bookmark &quot; \</span>
<span class="line-modified"> 101                 &quot;Exchange Language 1.0//EN//XML&quot;</span>
<span class="line-modified"> 102 </span>
<span class="line-modified"> 103 #define XBEL_DTD_URI        &quot;http://www.python.org/topics/xml/dtds/xbel-1.0.dtd&quot;</span>
<span class="line-modified"> 104 </span>
<span class="line-modified"> 105 #define XBEL_ROOT_ELEMENT   &quot;xbel&quot;</span>
<span class="line-modified"> 106 #define XBEL_FOLDER_ELEMENT &quot;folder&quot;    /* unused */</span>
<span class="line-modified"> 107 #define XBEL_BOOKMARK_ELEMENT   &quot;bookmark&quot;</span>
<span class="line-modified"> 108 #define XBEL_ALIAS_ELEMENT  &quot;alias&quot;     /* unused */</span>
<span class="line-modified"> 109 #define XBEL_SEPARATOR_ELEMENT  &quot;separator&quot;     /* unused */</span>
 110 #define XBEL_TITLE_ELEMENT  &quot;title&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 111 #define XBEL_DESC_ELEMENT   &quot;desc&quot;</span>
<span class="line-modified"> 112 #define XBEL_INFO_ELEMENT   &quot;info&quot;</span>
<span class="line-modified"> 113 #define XBEL_METADATA_ELEMENT   &quot;metadata&quot;</span>
 114 
 115 #define XBEL_VERSION_ATTRIBUTE  &quot;version&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 116 #define XBEL_FOLDED_ATTRIBUTE   &quot;folded&quot;    /* unused */</span>
<span class="line-modified"> 117 #define XBEL_OWNER_ATTRIBUTE    &quot;owner&quot;</span>
<span class="line-modified"> 118 #define XBEL_ADDED_ATTRIBUTE    &quot;added&quot;</span>
 119 #define XBEL_VISITED_ATTRIBUTE  &quot;visited&quot;
 120 #define XBEL_MODIFIED_ATTRIBUTE &quot;modified&quot;
<a name="4" id="anc4"></a><span class="line-modified"> 121 #define XBEL_ID_ATTRIBUTE   &quot;id&quot;</span>
 122 #define XBEL_HREF_ATTRIBUTE &quot;href&quot;
<a name="5" id="anc5"></a><span class="line-modified"> 123 #define XBEL_REF_ATTRIBUTE  &quot;ref&quot;       /* unused */</span>
 124 
<a name="6" id="anc6"></a><span class="line-modified"> 125 #define XBEL_YES_VALUE      &quot;yes&quot;</span>
<span class="line-modified"> 126 #define XBEL_NO_VALUE       &quot;no&quot;</span>
 127 
 128 /* Desktop bookmark spec entities */
<a name="7" id="anc7"></a><span class="line-modified"> 129 #define BOOKMARK_METADATA_OWNER     &quot;http://freedesktop.org&quot;</span>
<span class="line-modified"> 130 </span>
<span class="line-modified"> 131 #define BOOKMARK_NAMESPACE_NAME     &quot;bookmark&quot;</span>
<span class="line-modified"> 132 #define BOOKMARK_NAMESPACE_URI      &quot;http://www.freedesktop.org/standards/desktop-bookmarks&quot;</span>
<span class="line-modified"> 133 </span>
<span class="line-modified"> 134 #define BOOKMARK_GROUPS_ELEMENT     &quot;groups&quot;</span>
<span class="line-modified"> 135 #define BOOKMARK_GROUP_ELEMENT      &quot;group&quot;</span>
<span class="line-modified"> 136 #define BOOKMARK_APPLICATIONS_ELEMENT   &quot;applications&quot;</span>
<span class="line-modified"> 137 #define BOOKMARK_APPLICATION_ELEMENT    &quot;application&quot;</span>
<span class="line-modified"> 138 #define BOOKMARK_ICON_ELEMENT       &quot;icon&quot;</span>
<span class="line-modified"> 139 #define BOOKMARK_PRIVATE_ELEMENT    &quot;private&quot;</span>
<span class="line-modified"> 140 </span>
<span class="line-modified"> 141 #define BOOKMARK_NAME_ATTRIBUTE     &quot;name&quot;</span>
<span class="line-modified"> 142 #define BOOKMARK_EXEC_ATTRIBUTE     &quot;exec&quot;</span>
<span class="line-modified"> 143 #define BOOKMARK_COUNT_ATTRIBUTE    &quot;count&quot;</span>
<span class="line-modified"> 144 #define BOOKMARK_TIMESTAMP_ATTRIBUTE    &quot;timestamp&quot;     /* deprecated by &quot;modified&quot; */</span>
 145 #define BOOKMARK_MODIFIED_ATTRIBUTE     &quot;modified&quot;
<a name="8" id="anc8"></a><span class="line-modified"> 146 #define BOOKMARK_HREF_ATTRIBUTE     &quot;href&quot;</span>
<span class="line-modified"> 147 #define BOOKMARK_TYPE_ATTRIBUTE     &quot;type&quot;</span>
 148 
 149 /* Shared MIME Info entities */
<a name="9" id="anc9"></a><span class="line-modified"> 150 #define MIME_NAMESPACE_NAME         &quot;mime&quot;</span>
<span class="line-modified"> 151 #define MIME_NAMESPACE_URI      &quot;http://www.freedesktop.org/standards/shared-mime-info&quot;</span>
<span class="line-modified"> 152 #define MIME_TYPE_ELEMENT       &quot;mime-type&quot;</span>
<span class="line-modified"> 153 #define MIME_TYPE_ATTRIBUTE         &quot;type&quot;</span>
 154 
 155 
 156 typedef struct _BookmarkAppInfo  BookmarkAppInfo;
 157 typedef struct _BookmarkMetadata BookmarkMetadata;
 158 typedef struct _BookmarkItem     BookmarkItem;
 159 typedef struct _ParseData        ParseData;
 160 
 161 struct _BookmarkAppInfo
 162 {
 163   gchar *name;
 164   gchar *exec;
 165 
 166   guint count;
 167 
 168   time_t stamp;
 169 };
 170 
 171 struct _BookmarkMetadata
 172 {
 173   gchar *mime_type;
 174 
 175   GList *groups;
 176 
 177   GList *applications;
 178   GHashTable *apps_by_name;
 179 
 180   gchar *icon_href;
 181   gchar *icon_mime;
 182 
 183   guint is_private : 1;
 184 };
 185 
 186 struct _BookmarkItem
 187 {
 188   gchar *uri;
 189 
 190   gchar *title;
 191   gchar *description;
 192 
 193   time_t added;
 194   time_t modified;
 195   time_t visited;
 196 
 197   BookmarkMetadata *metadata;
 198 };
 199 
 200 struct _GBookmarkFile
 201 {
 202   gchar *title;
 203   gchar *description;
 204 
 205   /* we store our items in a list and keep a copy inside
<a name="10" id="anc10"></a><span class="line-modified"> 206    * an hash table for faster lookup performances</span>
 207    */
 208   GList *items;
 209   GHashTable *items_by_uri;
 210 };
 211 
 212 /* parser state machine */
 213 typedef enum
 214 {
 215   STATE_STARTED        = 0,
 216 
 217   STATE_ROOT,
 218   STATE_BOOKMARK,
 219   STATE_TITLE,
 220   STATE_DESC,
 221   STATE_INFO,
 222   STATE_METADATA,
 223   STATE_APPLICATIONS,
 224   STATE_APPLICATION,
 225   STATE_GROUPS,
 226   STATE_GROUP,
 227   STATE_MIME,
 228   STATE_ICON,
 229 
 230   STATE_FINISHED
 231 } ParserState;
 232 
 233 static void          g_bookmark_file_init        (GBookmarkFile  *bookmark);
 234 static void          g_bookmark_file_clear       (GBookmarkFile  *bookmark);
 235 static gboolean      g_bookmark_file_parse       (GBookmarkFile  *bookmark,
<a name="11" id="anc11"></a><span class="line-modified"> 236                           const gchar    *buffer,</span>
<span class="line-modified"> 237                           gsize           length,</span>
<span class="line-modified"> 238                           GError        **error);</span>
 239 static gchar *       g_bookmark_file_dump        (GBookmarkFile  *bookmark,
<a name="12" id="anc12"></a><span class="line-modified"> 240                           gsize          *length,</span>
<span class="line-modified"> 241                           GError        **error);</span>
 242 static BookmarkItem *g_bookmark_file_lookup_item (GBookmarkFile  *bookmark,
<a name="13" id="anc13"></a><span class="line-modified"> 243                           const gchar    *uri);</span>
 244 static void          g_bookmark_file_add_item    (GBookmarkFile  *bookmark,
<a name="14" id="anc14"></a><span class="line-modified"> 245                           BookmarkItem   *item,</span>
<span class="line-modified"> 246                           GError        **error);</span>
 247 
<a name="15" id="anc15"></a><span class="line-modified"> 248 static time_t  timestamp_from_iso8601 (const gchar *iso_date);</span>
<span class="line-modified"> 249 static gchar * timestamp_to_iso8601   (time_t       timestamp);</span>


 250 
 251 /********************************
 252  * BookmarkAppInfo              *
 253  *                              *
 254  * Application metadata storage *
 255  ********************************/
 256 static BookmarkAppInfo *
 257 bookmark_app_info_new (const gchar *name)
 258 {
 259   BookmarkAppInfo *retval;
 260 
 261   g_warn_if_fail (name != NULL);
 262 
 263   retval = g_slice_new (BookmarkAppInfo);
 264 #ifdef GSTREAMER_LITE
 265   if (retval == NULL) {
 266     return NULL;
 267   }
 268 #endif // GSTREAMER_LITE
 269 
 270   retval-&gt;name = g_strdup (name);
 271   retval-&gt;exec = NULL;
 272   retval-&gt;count = 0;
 273   retval-&gt;stamp = 0;
 274 
 275   return retval;
 276 }
 277 
 278 static void
 279 bookmark_app_info_free (BookmarkAppInfo *app_info)
 280 {
 281   if (!app_info)
 282     return;
 283 
 284   g_free (app_info-&gt;name);
 285   g_free (app_info-&gt;exec);
 286 
 287   g_slice_free (BookmarkAppInfo, app_info);
 288 }
 289 
 290 static gchar *
 291 bookmark_app_info_dump (BookmarkAppInfo *app_info)
 292 {
 293   gchar *retval;
 294   gchar *name, *exec, *modified, *count;
 295 
 296   g_warn_if_fail (app_info != NULL);
 297 
 298   if (app_info-&gt;count == 0)
 299     return NULL;
 300 
 301   name = g_markup_escape_text (app_info-&gt;name, -1);
 302   exec = g_markup_escape_text (app_info-&gt;exec, -1);
 303   modified = timestamp_to_iso8601 (app_info-&gt;stamp);
 304   count = g_strdup_printf (&quot;%u&quot;, app_info-&gt;count);
 305 
 306   retval = g_strconcat (&quot;          &quot;
 307                         &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME &quot;:&quot; BOOKMARK_APPLICATION_ELEMENT
 308                         &quot; &quot; BOOKMARK_NAME_ATTRIBUTE &quot;=\&quot;&quot;, name, &quot;\&quot;&quot;
 309                         &quot; &quot; BOOKMARK_EXEC_ATTRIBUTE &quot;=\&quot;&quot;, exec, &quot;\&quot;&quot;
 310                         &quot; &quot; BOOKMARK_MODIFIED_ATTRIBUTE &quot;=\&quot;&quot;, modified, &quot;\&quot;&quot;
 311                         &quot; &quot; BOOKMARK_COUNT_ATTRIBUTE &quot;=\&quot;&quot;, count, &quot;\&quot;/&gt;\n&quot;,
 312                         NULL);
 313 
 314   g_free (name);
 315   g_free (exec);
 316   g_free (modified);
 317   g_free (count);
 318 
 319   return retval;
 320 }
 321 
 322 
 323 /***********************
 324  * BookmarkMetadata    *
 325  *                     *
 326  * Metadata storage    *
 327  ***********************/
 328 static BookmarkMetadata *
 329 bookmark_metadata_new (void)
 330 {
 331   BookmarkMetadata *retval;
 332 
 333   retval = g_slice_new (BookmarkMetadata);
 334 #ifdef GSTREAMER_LITE
 335   if (retval == NULL) {
 336     return NULL;
 337   }
 338 #endif // GSTREAMER_LITE
 339 
 340   retval-&gt;mime_type = NULL;
 341 
 342   retval-&gt;groups = NULL;
 343 
 344   retval-&gt;applications = NULL;
 345   retval-&gt;apps_by_name = g_hash_table_new_full (g_str_hash,
 346                                                 g_str_equal,
 347                                                 NULL,
 348                                                 NULL);
 349 
 350   retval-&gt;is_private = FALSE;
 351 
 352   retval-&gt;icon_href = NULL;
 353   retval-&gt;icon_mime = NULL;
 354 
 355   return retval;
 356 }
 357 
 358 static void
 359 bookmark_metadata_free (BookmarkMetadata *metadata)
 360 {
 361   if (!metadata)
 362     return;
 363 
 364   g_free (metadata-&gt;mime_type);
 365 
 366   g_list_free_full (metadata-&gt;groups, g_free);
 367   g_list_free_full (metadata-&gt;applications, (GDestroyNotify) bookmark_app_info_free);
 368 
 369   g_hash_table_destroy (metadata-&gt;apps_by_name);
 370 
 371   g_free (metadata-&gt;icon_href);
 372   g_free (metadata-&gt;icon_mime);
 373 
 374   g_slice_free (BookmarkMetadata, metadata);
 375 }
 376 
 377 static gchar *
 378 bookmark_metadata_dump (BookmarkMetadata *metadata)
 379 {
 380   GString *retval;
 381   gchar *buffer;
 382 
 383   if (!metadata-&gt;applications)
 384     return NULL;
 385 
 386   retval = g_string_sized_new (1024);
 387 
 388   /* metadata container */
 389   g_string_append (retval,
<a name="16" id="anc16"></a><span class="line-modified"> 390            &quot;      &quot;</span>
<span class="line-modified"> 391            &quot;&lt;&quot; XBEL_METADATA_ELEMENT</span>
<span class="line-modified"> 392            &quot; &quot; XBEL_OWNER_ATTRIBUTE &quot;=\&quot;&quot; BOOKMARK_METADATA_OWNER</span>
<span class="line-modified"> 393            &quot;\&quot;&gt;\n&quot;);</span>
 394 
 395   /* mime type */
 396   if (metadata-&gt;mime_type) {
 397     buffer = g_strconcat (&quot;        &quot;
<a name="17" id="anc17"></a><span class="line-modified"> 398               &quot;&lt;&quot; MIME_NAMESPACE_NAME &quot;:&quot; MIME_TYPE_ELEMENT &quot; &quot;</span>
<span class="line-modified"> 399               MIME_TYPE_ATTRIBUTE &quot;=\&quot;&quot;, metadata-&gt;mime_type, &quot;\&quot;/&gt;\n&quot;,</span>
<span class="line-modified"> 400               NULL);</span>
 401     g_string_append (retval, buffer);
 402     g_free (buffer);
 403   }
 404 
 405   if (metadata-&gt;groups)
 406     {
 407       GList *l;
 408 
 409       /* open groups container */
 410       g_string_append (retval,
<a name="18" id="anc18"></a><span class="line-modified"> 411                &quot;        &quot;</span>
<span class="line-modified"> 412                &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 413                &quot;:&quot; BOOKMARK_GROUPS_ELEMENT &quot;&gt;\n&quot;);</span>
 414 
 415       for (l = g_list_last (metadata-&gt;groups); l != NULL; l = l-&gt;prev)
 416         {
 417           gchar *group_name;
 418 
<a name="19" id="anc19"></a><span class="line-modified"> 419       group_name = g_markup_escape_text ((gchar *) l-&gt;data, -1);</span>
<span class="line-modified"> 420       buffer = g_strconcat (&quot;          &quot;</span>
<span class="line-modified"> 421                 &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 422                 &quot;:&quot; BOOKMARK_GROUP_ELEMENT &quot;&gt;&quot;,</span>
<span class="line-modified"> 423                 group_name,</span>
<span class="line-modified"> 424                 &quot;&lt;/&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 425                 &quot;:&quot;  BOOKMARK_GROUP_ELEMENT &quot;&gt;\n&quot;, NULL);</span>
<span class="line-modified"> 426       g_string_append (retval, buffer);</span>
 427 
<a name="20" id="anc20"></a><span class="line-modified"> 428       g_free (buffer);</span>
<span class="line-modified"> 429       g_free (group_name);</span>
 430         }
 431 
 432       /* close groups container */
 433       g_string_append (retval,
<a name="21" id="anc21"></a><span class="line-modified"> 434                &quot;        &quot;</span>
<span class="line-modified"> 435                &quot;&lt;/&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 436                &quot;:&quot; BOOKMARK_GROUPS_ELEMENT &quot;&gt;\n&quot;);</span>
 437     }
 438 
 439   if (metadata-&gt;applications)
 440     {
 441       GList *l;
 442 
 443       /* open applications container */
 444       g_string_append (retval,
<a name="22" id="anc22"></a><span class="line-modified"> 445                &quot;        &quot;</span>
<span class="line-modified"> 446                &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 447                &quot;:&quot; BOOKMARK_APPLICATIONS_ELEMENT &quot;&gt;\n&quot;);</span>
 448 
 449       for (l = g_list_last (metadata-&gt;applications); l != NULL; l = l-&gt;prev)
 450         {
 451           BookmarkAppInfo *app_info = (BookmarkAppInfo *) l-&gt;data;
 452           gchar *app_data;
 453 
<a name="23" id="anc23"></a><span class="line-modified"> 454       g_warn_if_fail (app_info != NULL);</span>
 455 
 456           app_data = bookmark_app_info_dump (app_info);
 457 
<a name="24" id="anc24"></a><span class="line-modified"> 458       if (app_data)</span>
 459             {
 460               retval = g_string_append (retval, app_data);
 461 
<a name="25" id="anc25"></a><span class="line-modified"> 462           g_free (app_data);</span>
<span class="line-modified"> 463         }</span>
 464         }
 465 
 466       /* close applications container */
 467       g_string_append (retval,
<a name="26" id="anc26"></a><span class="line-modified"> 468                &quot;        &quot;</span>
<span class="line-modified"> 469                &quot;&lt;/&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 470                &quot;:&quot; BOOKMARK_APPLICATIONS_ELEMENT &quot;&gt;\n&quot;);</span>
 471     }
 472 
 473   /* icon */
 474   if (metadata-&gt;icon_href)
 475     {
 476       if (!metadata-&gt;icon_mime)
 477         metadata-&gt;icon_mime = g_strdup (&quot;application/octet-stream&quot;);
 478 
 479       buffer = g_strconcat (&quot;       &quot;
<a name="27" id="anc27"></a><span class="line-modified"> 480                 &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 481                 &quot;:&quot; BOOKMARK_ICON_ELEMENT</span>
<span class="line-modified"> 482                 &quot; &quot; BOOKMARK_HREF_ATTRIBUTE &quot;=\&quot;&quot;, metadata-&gt;icon_href,</span>
<span class="line-modified"> 483                 &quot;\&quot; &quot; BOOKMARK_TYPE_ATTRIBUTE &quot;=\&quot;&quot;, metadata-&gt;icon_mime, &quot;\&quot;/&gt;\n&quot;, NULL);</span>
 484       g_string_append (retval, buffer);
 485 
 486       g_free (buffer);
 487     }
 488 
 489   /* private hint */
 490   if (metadata-&gt;is_private)
 491     g_string_append (retval,
<a name="28" id="anc28"></a><span class="line-modified"> 492              &quot;        &quot;</span>
<span class="line-modified"> 493              &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME</span>
<span class="line-modified"> 494              &quot;:&quot; BOOKMARK_PRIVATE_ELEMENT &quot;/&gt;\n&quot;);</span>
 495 
 496   /* close metadata container */
 497   g_string_append (retval,
<a name="29" id="anc29"></a><span class="line-modified"> 498            &quot;      &quot;</span>
<span class="line-modified"> 499            &quot;&lt;/&quot; XBEL_METADATA_ELEMENT &quot;&gt;\n&quot;);</span>
 500 
 501   return g_string_free (retval, FALSE);
 502 }
 503 
 504 /******************************************************
 505  * BookmarkItem                                       *
 506  *                                                    *
 507  * Storage for a single bookmark item inside the list *
 508  ******************************************************/
 509 static BookmarkItem *
 510 bookmark_item_new (const gchar *uri)
 511 {
 512   BookmarkItem *item;
 513 
 514   g_warn_if_fail (uri != NULL);
 515 
 516   item = g_slice_new (BookmarkItem);
 517 #ifdef GSTREAMER_LITE
 518   if (item == NULL) {
 519     return NULL;
 520   }
 521 #endif // GSTREAMER_LITE
 522 
 523   item-&gt;uri = g_strdup (uri);
 524 
 525   item-&gt;title = NULL;
 526   item-&gt;description = NULL;
 527 
 528   item-&gt;added = (time_t) -1;
 529   item-&gt;modified = (time_t) -1;
 530   item-&gt;visited = (time_t) -1;
 531 
 532   item-&gt;metadata = NULL;
 533 
 534   return item;
 535 }
 536 
 537 static void
 538 bookmark_item_free (BookmarkItem *item)
 539 {
 540   if (!item)
 541     return;
 542 
 543   g_free (item-&gt;uri);
 544   g_free (item-&gt;title);
 545   g_free (item-&gt;description);
 546 
 547   if (item-&gt;metadata)
 548     bookmark_metadata_free (item-&gt;metadata);
 549 
 550   g_slice_free (BookmarkItem, item);
 551 }
 552 
 553 static gchar *
 554 bookmark_item_dump (BookmarkItem *item)
 555 {
 556   GString *retval;
 557   gchar *added, *visited, *modified;
 558   gchar *escaped_uri;
 559   gchar *buffer;
 560 
 561   /* at this point, we must have at least a registered application; if we don&#39;t
 562    * we don&#39;t screw up the bookmark file, and just skip this item
 563    */
 564   if (!item-&gt;metadata || !item-&gt;metadata-&gt;applications)
 565     {
 566       g_warning (&quot;Item for URI &#39;%s&#39; has no registered applications: skipping.&quot;, item-&gt;uri);
 567       return NULL;
 568     }
 569 
 570   retval = g_string_sized_new (4096);
 571 
 572   added = timestamp_to_iso8601 (item-&gt;added);
 573   modified = timestamp_to_iso8601 (item-&gt;modified);
 574   visited = timestamp_to_iso8601 (item-&gt;visited);
 575 
 576   escaped_uri = g_markup_escape_text (item-&gt;uri, -1);
 577 
 578   buffer = g_strconcat (&quot;  &lt;&quot;
 579                         XBEL_BOOKMARK_ELEMENT
 580                         &quot; &quot;
 581                         XBEL_HREF_ATTRIBUTE &quot;=\&quot;&quot;, escaped_uri, &quot;\&quot; &quot;
 582                         XBEL_ADDED_ATTRIBUTE &quot;=\&quot;&quot;, added, &quot;\&quot; &quot;
 583                         XBEL_MODIFIED_ATTRIBUTE &quot;=\&quot;&quot;, modified, &quot;\&quot; &quot;
 584                         XBEL_VISITED_ATTRIBUTE &quot;=\&quot;&quot;, visited, &quot;\&quot;&gt;\n&quot;,
 585                         NULL);
 586 
 587   g_string_append (retval, buffer);
 588 
 589   g_free (escaped_uri);
 590   g_free (visited);
 591   g_free (modified);
 592   g_free (added);
 593   g_free (buffer);
 594 
 595   if (item-&gt;title)
 596     {
 597       gchar *escaped_title;
 598 
 599       escaped_title = g_markup_escape_text (item-&gt;title, -1);
 600       buffer = g_strconcat (&quot;    &quot;
 601                             &quot;&lt;&quot; XBEL_TITLE_ELEMENT &quot;&gt;&quot;,
 602                             escaped_title,
 603                             &quot;&lt;/&quot; XBEL_TITLE_ELEMENT &quot;&gt;\n&quot;,
 604                             NULL);
 605       g_string_append (retval, buffer);
 606 
 607       g_free (escaped_title);
 608       g_free (buffer);
 609     }
 610 
 611   if (item-&gt;description)
 612     {
 613       gchar *escaped_desc;
 614 
 615       escaped_desc = g_markup_escape_text (item-&gt;description, -1);
 616       buffer = g_strconcat (&quot;    &quot;
 617                             &quot;&lt;&quot; XBEL_DESC_ELEMENT &quot;&gt;&quot;,
 618                             escaped_desc,
 619                             &quot;&lt;/&quot; XBEL_DESC_ELEMENT &quot;&gt;\n&quot;,
 620                             NULL);
 621       g_string_append (retval, buffer);
 622 
 623       g_free (escaped_desc);
 624       g_free (buffer);
 625     }
 626 
 627   if (item-&gt;metadata)
 628     {
 629       gchar *metadata;
 630 
 631       metadata = bookmark_metadata_dump (item-&gt;metadata);
 632       if (metadata)
 633         {
 634           buffer = g_strconcat (&quot;    &quot;
 635                                 &quot;&lt;&quot; XBEL_INFO_ELEMENT &quot;&gt;\n&quot;,
 636                                 metadata,
 637                                 &quot;    &quot;
<a name="30" id="anc30"></a><span class="line-modified"> 638                 &quot;&lt;/&quot; XBEL_INFO_ELEMENT &quot;&gt;\n&quot;,</span>
 639                                 NULL);
 640           retval = g_string_append (retval, buffer);
 641 
 642           g_free (buffer);
<a name="31" id="anc31"></a><span class="line-modified"> 643       g_free (metadata);</span>
<span class="line-modified"> 644     }</span>
 645     }
 646 
 647   g_string_append (retval, &quot;  &lt;/&quot; XBEL_BOOKMARK_ELEMENT &quot;&gt;\n&quot;);
 648 
 649   return g_string_free (retval, FALSE);
 650 }
 651 
 652 static BookmarkAppInfo *
 653 bookmark_item_lookup_app_info (BookmarkItem *item,
<a name="32" id="anc32"></a><span class="line-modified"> 654                    const gchar  *app_name)</span>
 655 {
 656   g_warn_if_fail (item != NULL &amp;&amp; app_name != NULL);
 657 
 658   if (!item-&gt;metadata)
 659     return NULL;
 660 
 661   return g_hash_table_lookup (item-&gt;metadata-&gt;apps_by_name, app_name);
 662 }
 663 
 664 /*************************
 665  *    GBookmarkFile    *
 666  *************************/
 667 
 668 static void
 669 g_bookmark_file_init (GBookmarkFile *bookmark)
 670 {
 671   bookmark-&gt;title = NULL;
 672   bookmark-&gt;description = NULL;
 673 
 674   bookmark-&gt;items = NULL;
 675   bookmark-&gt;items_by_uri = g_hash_table_new_full (g_str_hash,
 676                                                   g_str_equal,
 677                                                   NULL,
 678                                                   NULL);
 679 }
 680 
 681 static void
 682 g_bookmark_file_clear (GBookmarkFile *bookmark)
 683 {
 684   g_free (bookmark-&gt;title);
 685   g_free (bookmark-&gt;description);
 686 
 687   g_list_free_full (bookmark-&gt;items, (GDestroyNotify) bookmark_item_free);
 688   bookmark-&gt;items = NULL;
 689 
 690   if (bookmark-&gt;items_by_uri)
 691     {
 692       g_hash_table_destroy (bookmark-&gt;items_by_uri);
 693 
 694       bookmark-&gt;items_by_uri = NULL;
 695     }
 696 }
 697 
 698 struct _ParseData
 699 {
 700   ParserState state;
 701 
 702   GHashTable *namespaces;
 703 
 704   GBookmarkFile *bookmark_file;
 705   BookmarkItem *current_item;
 706 };
 707 
 708 static ParseData *
 709 parse_data_new (void)
 710 {
 711   ParseData *retval;
 712 
 713   retval = g_new (ParseData, 1);
 714 
 715   retval-&gt;state = STATE_STARTED;
 716   retval-&gt;namespaces = g_hash_table_new_full (g_str_hash, g_str_equal,
<a name="33" id="anc33"></a><span class="line-modified"> 717                           (GDestroyNotify) g_free,</span>
<span class="line-modified"> 718                           (GDestroyNotify) g_free);</span>
 719   retval-&gt;bookmark_file = NULL;
 720   retval-&gt;current_item = NULL;
 721 
 722   return retval;
 723 }
 724 
 725 static void
 726 parse_data_free (ParseData *parse_data)
 727 {
 728   g_hash_table_destroy (parse_data-&gt;namespaces);
 729 
 730   g_free (parse_data);
 731 }
 732 
<a name="34" id="anc34"></a><span class="line-modified"> 733 #define IS_ATTRIBUTE(s,a)   ((0 == strcmp ((s), (a))))</span>
 734 
 735 static void
 736 parse_bookmark_element (GMarkupParseContext  *context,
<a name="35" id="anc35"></a><span class="line-modified"> 737             ParseData            *parse_data,</span>
<span class="line-modified"> 738             const gchar         **attribute_names,</span>
<span class="line-modified"> 739             const gchar         **attribute_values,</span>
<span class="line-modified"> 740             GError              **error)</span>
 741 {
 742   const gchar *uri, *added, *modified, *visited;
 743   const gchar *attr;
 744   gint i;
 745   BookmarkItem *item;
 746   GError *add_error;
 747 
 748   g_warn_if_fail ((parse_data != NULL) &amp;&amp; (parse_data-&gt;state == STATE_BOOKMARK));
 749 
 750   i = 0;
 751   uri = added = modified = visited = NULL;
 752   for (attr = attribute_names[i]; attr != NULL; attr = attribute_names[++i])
 753     {
 754       if (IS_ATTRIBUTE (attr, XBEL_HREF_ATTRIBUTE))
 755         uri = attribute_values[i];
 756       else if (IS_ATTRIBUTE (attr, XBEL_ADDED_ATTRIBUTE))
 757         added = attribute_values[i];
 758       else if (IS_ATTRIBUTE (attr, XBEL_MODIFIED_ATTRIBUTE))
 759         modified = attribute_values[i];
 760       else if (IS_ATTRIBUTE (attr, XBEL_VISITED_ATTRIBUTE))
 761         visited = attribute_values[i];
 762       else
 763         {
 764           /* bookmark is defined by the XBEL spec, so we need
 765            * to error out if the element has different or
 766            * missing attributes
 767            */
 768           g_set_error (error, G_MARKUP_ERROR,
<a name="36" id="anc36"></a><span class="line-modified"> 769                        G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE,</span>
<span class="line-modified"> 770                        _(&quot;Unexpected attribute &#39;%s&#39; for element &#39;%s&#39;&quot;),</span>
<span class="line-modified"> 771                        attr,</span>
<span class="line-modified"> 772                        XBEL_BOOKMARK_ELEMENT);</span>
 773           return;
 774         }
 775     }
 776 
 777   if (!uri)
 778     {
 779       g_set_error (error, G_MARKUP_ERROR,
<a name="37" id="anc37"></a><span class="line-modified"> 780                    G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified"> 781                    _(&quot;Attribute &#39;%s&#39; of element &#39;%s&#39; not found&quot;),</span>
<span class="line-modified"> 782                    XBEL_HREF_ATTRIBUTE,</span>
<span class="line-modified"> 783                    XBEL_BOOKMARK_ELEMENT);</span>
 784       return;
 785     }
 786 
 787   g_warn_if_fail (parse_data-&gt;current_item == NULL);
 788 
<a name="38" id="anc38"></a><span class="line-modified"> 789 item = bookmark_item_new (uri);</span>
 790 #ifdef GSTREAMER_LITE
 791   if (item == NULL) {
 792     return;
 793   }
 794 #endif // GSTREAMER_LITE
 795 
<a name="39" id="anc39"></a><span class="line-modified"> 796   if (added)</span>
<span class="line-modified"> 797     item-&gt;added = timestamp_from_iso8601 (added);</span>
 798 
<a name="40" id="anc40"></a><span class="line-modified"> 799   if (modified)</span>
<span class="line-modified"> 800     item-&gt;modified = timestamp_from_iso8601 (modified);</span>
 801 
<a name="41" id="anc41"></a><span class="line-modified"> 802   if (visited)</span>
<span class="line-modified"> 803     item-&gt;visited = timestamp_from_iso8601 (visited);</span>
 804 
 805   add_error = NULL;
 806   g_bookmark_file_add_item (parse_data-&gt;bookmark_file,
<a name="42" id="anc42"></a><span class="line-modified"> 807                 item,</span>
<span class="line-modified"> 808                 &amp;add_error);</span>
 809   if (add_error)
 810     {
 811       bookmark_item_free (item);
 812 
 813       g_propagate_error (error, add_error);
 814 
 815       return;
 816     }
 817 
 818   parse_data-&gt;current_item = item;
 819 }
 820 
 821 static void
 822 parse_application_element (GMarkupParseContext  *context,
<a name="43" id="anc43"></a><span class="line-modified"> 823                ParseData            *parse_data,</span>
<span class="line-modified"> 824                const gchar         **attribute_names,</span>
<span class="line-modified"> 825                const gchar         **attribute_values,</span>
<span class="line-modified"> 826                GError              **error)</span>
 827 {
 828   const gchar *name, *exec, *count, *stamp, *modified;
 829   const gchar *attr;
 830   gint i;
 831   BookmarkItem *item;
 832   BookmarkAppInfo *ai;
 833 
 834   g_warn_if_fail ((parse_data != NULL) &amp;&amp; (parse_data-&gt;state == STATE_APPLICATION));
 835 
 836   i = 0;
 837   name = exec = count = stamp = modified = NULL;
 838   for (attr = attribute_names[i]; attr != NULL; attr = attribute_names[++i])
 839     {
 840       if (IS_ATTRIBUTE (attr, BOOKMARK_NAME_ATTRIBUTE))
 841         name = attribute_values[i];
 842       else if (IS_ATTRIBUTE (attr, BOOKMARK_EXEC_ATTRIBUTE))
 843         exec = attribute_values[i];
 844       else if (IS_ATTRIBUTE (attr, BOOKMARK_COUNT_ATTRIBUTE))
 845         count = attribute_values[i];
 846       else if (IS_ATTRIBUTE (attr, BOOKMARK_TIMESTAMP_ATTRIBUTE))
 847         stamp = attribute_values[i];
 848       else if (IS_ATTRIBUTE (attr, BOOKMARK_MODIFIED_ATTRIBUTE))
 849         modified = attribute_values[i];
 850     }
 851 
 852   /* the &quot;name&quot; and &quot;exec&quot; attributes are mandatory */
 853   if (!name)
 854     {
 855       g_set_error (error, G_MARKUP_ERROR,
<a name="44" id="anc44"></a><span class="line-modified"> 856                    G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified"> 857                    _(&quot;Attribute &#39;%s&#39; of element &#39;%s&#39; not found&quot;),</span>
<span class="line-modified"> 858                    BOOKMARK_NAME_ATTRIBUTE,</span>
<span class="line-modified"> 859                    BOOKMARK_APPLICATION_ELEMENT);</span>
 860       return;
 861     }
 862 
 863   if (!exec)
 864     {
 865       g_set_error (error, G_MARKUP_ERROR,
<a name="45" id="anc45"></a><span class="line-modified"> 866                    G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified"> 867                    _(&quot;Attribute &#39;%s&#39; of element &#39;%s&#39; not found&quot;),</span>
<span class="line-modified"> 868                    BOOKMARK_EXEC_ATTRIBUTE,</span>
<span class="line-modified"> 869                    BOOKMARK_APPLICATION_ELEMENT);</span>
 870       return;
 871     }
 872 
 873   g_warn_if_fail (parse_data-&gt;current_item != NULL);
 874   item = parse_data-&gt;current_item;
 875 
 876   ai = bookmark_item_lookup_app_info (item, name);
 877   if (!ai)
 878     {
 879       ai = bookmark_app_info_new (name);
 880 #ifdef GSTREAMER_LITE
 881       if (ai == NULL) {
 882           g_set_error (error, G_MARKUP_ERROR,
 883                G_MARKUP_ERROR_INVALID_CONTENT,
 884                _(&quot;AI is NULL&quot;));
 885           return;
 886       }
 887 #endif // GSTREAMER_LITE
 888 
 889       if (!item-&gt;metadata)
<a name="46" id="anc46"></a><span class="line-modified"> 890         item-&gt;metadata = bookmark_metadata_new ();</span>
 891 
 892       item-&gt;metadata-&gt;applications = g_list_prepend (item-&gt;metadata-&gt;applications, ai);
 893       g_hash_table_replace (item-&gt;metadata-&gt;apps_by_name, ai-&gt;name, ai);
 894     }
 895 
 896   g_free (ai-&gt;exec);
 897   ai-&gt;exec = g_strdup (exec);
 898 
 899   if (count)
 900     ai-&gt;count = atoi (count);
 901   else
 902     ai-&gt;count = 1;
 903 
<a name="47" id="anc47"></a><span class="line-modified"> 904   if (modified)</span>
<span class="line-modified"> 905     ai-&gt;stamp = timestamp_from_iso8601 (modified);</span>



 906   else
 907     {
 908       /* the timestamp attribute has been deprecated but we still parse
 909        * it for backward compatibility
 910        */
 911       if (stamp)
 912         ai-&gt;stamp = (time_t) atol (stamp);
 913       else
 914         ai-&gt;stamp = time (NULL);
 915     }
 916 }
 917 
 918 static void
 919 parse_mime_type_element (GMarkupParseContext  *context,
<a name="48" id="anc48"></a><span class="line-modified"> 920              ParseData            *parse_data,</span>
<span class="line-modified"> 921              const gchar         **attribute_names,</span>
<span class="line-modified"> 922              const gchar         **attribute_values,</span>
<span class="line-modified"> 923              GError              **error)</span>
 924 {
 925   const gchar *type;
 926   const gchar *attr;
 927   gint i;
 928   BookmarkItem *item;
 929 
 930   g_warn_if_fail ((parse_data != NULL) &amp;&amp; (parse_data-&gt;state == STATE_MIME));
 931 
 932   i = 0;
 933   type = NULL;
 934   for (attr = attribute_names[i]; attr != NULL; attr = attribute_names[++i])
 935     {
 936       if (IS_ATTRIBUTE (attr, MIME_TYPE_ATTRIBUTE))
 937         type = attribute_values[i];
 938     }
 939 
 940   if (!type)
 941     type = &quot;application/octet-stream&quot;;
 942 
 943   g_warn_if_fail (parse_data-&gt;current_item != NULL);
 944   item = parse_data-&gt;current_item;
 945 
 946   if (!item-&gt;metadata)
 947     item-&gt;metadata = bookmark_metadata_new ();
 948 
 949   g_free (item-&gt;metadata-&gt;mime_type);
 950   item-&gt;metadata-&gt;mime_type = g_strdup (type);
 951 }
 952 
 953 static void
 954 parse_icon_element (GMarkupParseContext  *context,
<a name="49" id="anc49"></a><span class="line-modified"> 955             ParseData            *parse_data,</span>
<span class="line-modified"> 956             const gchar         **attribute_names,</span>
<span class="line-modified"> 957             const gchar         **attribute_values,</span>
<span class="line-modified"> 958             GError              **error)</span>
 959 {
 960   const gchar *href;
 961   const gchar *type;
 962   const gchar *attr;
 963   gint i;
 964   BookmarkItem *item;
 965 
 966   g_warn_if_fail ((parse_data != NULL) &amp;&amp; (parse_data-&gt;state == STATE_ICON));
 967 
 968   i = 0;
 969   href = NULL;
 970   type = NULL;
 971   for (attr = attribute_names[i]; attr != NULL; attr = attribute_names[++i])
 972     {
 973       if (IS_ATTRIBUTE (attr, BOOKMARK_HREF_ATTRIBUTE))
 974         href = attribute_values[i];
 975       else if (IS_ATTRIBUTE (attr, BOOKMARK_TYPE_ATTRIBUTE))
 976         type = attribute_values[i];
 977     }
 978 
 979   /* the &quot;href&quot; attribute is mandatory */
 980   if (!href)
 981     {
 982       g_set_error (error, G_MARKUP_ERROR,
<a name="50" id="anc50"></a><span class="line-modified"> 983                    G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified"> 984                    _(&quot;Attribute &#39;%s&#39; of element &#39;%s&#39; not found&quot;),</span>
<span class="line-modified"> 985                    BOOKMARK_HREF_ATTRIBUTE,</span>
<span class="line-modified"> 986                    BOOKMARK_ICON_ELEMENT);</span>
 987       return;
 988     }
 989 
 990   if (!type)
 991     type = &quot;application/octet-stream&quot;;
 992 
 993   g_warn_if_fail (parse_data-&gt;current_item != NULL);
 994   item = parse_data-&gt;current_item;
 995 
 996   if (!item-&gt;metadata)
 997     item-&gt;metadata = bookmark_metadata_new ();
 998 
 999   g_free (item-&gt;metadata-&gt;icon_href);
1000   g_free (item-&gt;metadata-&gt;icon_mime);
1001   item-&gt;metadata-&gt;icon_href = g_strdup (href);
1002   item-&gt;metadata-&gt;icon_mime = g_strdup (type);
1003 }
1004 
1005 /* scans through the attributes of an element for the &quot;xmlns&quot; pragma, and
1006  * adds any resulting namespace declaration to a per-parser hashtable, using
1007  * the namespace name as a key for the namespace URI; if no key was found,
1008  * the namespace is considered as default, and stored under the &quot;default&quot; key.
1009  *
1010  * FIXME: this works on the assumption that the generator of the XBEL file
1011  * is either this code or is smart enough to place the namespace declarations
1012  * inside the main root node or inside the metadata node and does not redefine
1013  * a namespace inside an inner node; this does *not* conform to the
1014  * XML-NS standard, although is a close approximation.  In order to make this
1015  * conformant to the XML-NS specification we should use a per-element
1016  * namespace table inside GMarkup and ask it to resolve the namespaces for us.
1017  */
1018 static void
1019 map_namespace_to_name (ParseData    *parse_data,
1020                        const gchar **attribute_names,
<a name="51" id="anc51"></a><span class="line-modified">1021                const gchar **attribute_values)</span>
1022 {
1023   const gchar *attr;
1024   gint i;
1025 
1026   g_warn_if_fail (parse_data != NULL);
1027 
1028   if (!attribute_names || !attribute_names[0])
1029     return;
1030 
1031   i = 0;
1032   for (attr = attribute_names[i]; attr; attr = attribute_names[++i])
1033     {
1034       if (g_str_has_prefix (attr, &quot;xmlns&quot;))
1035         {
1036           gchar *namespace_name, *namespace_uri;
1037           gchar *p;
1038 
1039           p = g_utf8_strchr (attr, -1, &#39;:&#39;);
1040           if (p)
1041             p = g_utf8_next_char (p);
1042           else
1043             p = &quot;default&quot;;
1044 
1045           namespace_name = g_strdup (p);
1046           namespace_uri = g_strdup (attribute_values[i]);
1047 
1048           g_hash_table_replace (parse_data-&gt;namespaces,
1049                                 namespace_name,
1050                                 namespace_uri);
1051         }
1052      }
1053 }
1054 
1055 /* checks whether @element_full is equal to @element.
1056  *
1057  * if @namespace is set, it tries to resolve the namespace to a known URI,
1058  * and if found is prepended to the element name, from which is separated
1059  * using the character specified in the @sep parameter.
1060  */
1061 static gboolean
1062 is_element_full (ParseData   *parse_data,
1063                  const gchar *element_full,
1064                  const gchar *namespace,
1065                  const gchar *element,
1066                  const gchar  sep)
1067 {
1068   gchar *ns_uri, *ns_name;
1069   const gchar *p, *element_name;
1070   gboolean retval;
1071 
1072   g_warn_if_fail (parse_data != NULL);
1073   g_warn_if_fail (element_full != NULL);
1074 
1075   if (!element)
1076     return FALSE;
1077 
1078   /* no namespace requested: dumb element compare */
1079   if (!namespace)
1080     return (0 == strcmp (element_full, element));
1081 
1082   /* search for namespace separator; if none found, assume we are under the
1083    * default namespace, and set ns_name to our &quot;default&quot; marker; if no default
1084    * namespace has been set, just do a plain comparison between @full_element
1085    * and @element.
1086    */
1087   p = g_utf8_strchr (element_full, -1, &#39;:&#39;);
1088   if (p)
1089     {
1090       ns_name = g_strndup (element_full, p - element_full);
1091       element_name = g_utf8_next_char (p);
1092     }
1093   else
1094     {
1095       ns_name = g_strdup (&quot;default&quot;);
1096       element_name = element_full;
1097     }
1098 
1099   ns_uri = g_hash_table_lookup (parse_data-&gt;namespaces, ns_name);
1100   if (!ns_uri)
1101     {
1102       /* no default namespace found */
1103       g_free (ns_name);
1104 
1105       return (0 == strcmp (element_full, element));
1106     }
1107 
1108   retval = (0 == strcmp (ns_uri, namespace) &amp;&amp;
1109             0 == strcmp (element_name, element));
1110 
1111   g_free (ns_name);
1112 
1113   return retval;
1114 }
1115 
<a name="52" id="anc52"></a><span class="line-modified">1116 #define IS_ELEMENT(p,s,e)   (is_element_full ((p), (s), NULL, (e), &#39;\0&#39;))</span>
1117 #define IS_ELEMENT_NS(p,s,n,e)  (is_element_full ((p), (s), (n), (e), &#39;|&#39;))
1118 
1119 static const gchar *
1120 parser_state_to_element_name (ParserState state)
1121 {
1122   switch (state)
1123     {
1124     case STATE_STARTED:
1125     case STATE_FINISHED:
1126       return &quot;(top-level)&quot;;
1127     case STATE_ROOT:
1128       return XBEL_ROOT_ELEMENT;
1129     case STATE_BOOKMARK:
1130       return XBEL_BOOKMARK_ELEMENT;
1131     case STATE_TITLE:
1132       return XBEL_TITLE_ELEMENT;
1133     case STATE_DESC:
1134       return XBEL_DESC_ELEMENT;
1135     case STATE_INFO:
1136       return XBEL_INFO_ELEMENT;
1137     case STATE_METADATA:
1138       return XBEL_METADATA_ELEMENT;
1139     case STATE_APPLICATIONS:
1140       return BOOKMARK_APPLICATIONS_ELEMENT;
1141     case STATE_APPLICATION:
1142       return BOOKMARK_APPLICATION_ELEMENT;
1143     case STATE_GROUPS:
1144       return BOOKMARK_GROUPS_ELEMENT;
1145     case STATE_GROUP:
1146       return BOOKMARK_GROUP_ELEMENT;
1147     case STATE_MIME:
1148       return MIME_TYPE_ELEMENT;
1149     case STATE_ICON:
1150       return BOOKMARK_ICON_ELEMENT;
1151     default:
1152       g_assert_not_reached ();
1153     }
1154 }
1155 
1156 static void
1157 start_element_raw_cb (GMarkupParseContext *context,
1158                       const gchar         *element_name,
1159                       const gchar        **attribute_names,
1160                       const gchar        **attribute_values,
1161                       gpointer             user_data,
1162                       GError             **error)
1163 {
1164   ParseData *parse_data = (ParseData *) user_data;
1165 
1166   /* we must check for namespace declarations first
1167    *
1168    * XXX - we could speed up things by checking for namespace declarations
1169    * only on the root node, where they usually are; this would probably break
1170    * on streams not produced by us or by &quot;smart&quot; generators
1171    */
1172   map_namespace_to_name (parse_data, attribute_names, attribute_values);
1173 
1174   switch (parse_data-&gt;state)
1175     {
1176     case STATE_STARTED:
1177       if (IS_ELEMENT (parse_data, element_name, XBEL_ROOT_ELEMENT))
1178         {
1179           const gchar *attr;
1180           gint i;
1181 
1182           i = 0;
1183           for (attr = attribute_names[i]; attr; attr = attribute_names[++i])
1184             {
1185               if ((IS_ATTRIBUTE (attr, XBEL_VERSION_ATTRIBUTE)) &amp;&amp;
1186                   (0 == strcmp (attribute_values[i], XBEL_VERSION)))
1187                 parse_data-&gt;state = STATE_ROOT;
1188             }
<a name="53" id="anc53"></a><span class="line-modified">1189     }</span>
1190       else
1191         g_set_error (error, G_MARKUP_ERROR,
<a name="54" id="anc54"></a><span class="line-modified">1192                      G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified">1193                      _(&quot;Unexpected tag &#39;%s&#39;, tag &#39;%s&#39; expected&quot;),</span>
<span class="line-modified">1194                      element_name, XBEL_ROOT_ELEMENT);</span>
1195       break;
1196     case STATE_ROOT:
1197       if (IS_ELEMENT (parse_data, element_name, XBEL_TITLE_ELEMENT))
1198         parse_data-&gt;state = STATE_TITLE;
1199       else if (IS_ELEMENT (parse_data, element_name, XBEL_DESC_ELEMENT))
1200         parse_data-&gt;state = STATE_DESC;
1201       else if (IS_ELEMENT (parse_data, element_name, XBEL_BOOKMARK_ELEMENT))
1202         {
1203           GError *inner_error = NULL;
1204 
1205           parse_data-&gt;state = STATE_BOOKMARK;
1206 
1207           parse_bookmark_element (context,
<a name="55" id="anc55"></a><span class="line-modified">1208                       parse_data,</span>
<span class="line-modified">1209                       attribute_names,</span>
<span class="line-modified">1210                       attribute_values,</span>
<span class="line-modified">1211                       &amp;inner_error);</span>
1212           if (inner_error)
1213             g_propagate_error (error, inner_error);
1214         }
1215       else
1216         g_set_error (error, G_MARKUP_ERROR,
<a name="56" id="anc56"></a><span class="line-modified">1217                      G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified">1218                      _(&quot;Unexpected tag &#39;%s&#39; inside &#39;%s&#39;&quot;),</span>
<span class="line-modified">1219                      element_name,</span>
<span class="line-modified">1220                      XBEL_ROOT_ELEMENT);</span>
1221       break;
1222     case STATE_BOOKMARK:
1223       if (IS_ELEMENT (parse_data, element_name, XBEL_TITLE_ELEMENT))
1224         parse_data-&gt;state = STATE_TITLE;
1225       else if (IS_ELEMENT (parse_data, element_name, XBEL_DESC_ELEMENT))
1226         parse_data-&gt;state = STATE_DESC;
1227       else if (IS_ELEMENT (parse_data, element_name, XBEL_INFO_ELEMENT))
1228         parse_data-&gt;state = STATE_INFO;
1229       else
1230         g_set_error (error, G_MARKUP_ERROR,
<a name="57" id="anc57"></a><span class="line-modified">1231                      G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified">1232                      _(&quot;Unexpected tag &#39;%s&#39; inside &#39;%s&#39;&quot;),</span>
<span class="line-modified">1233                      element_name,</span>
<span class="line-modified">1234                      XBEL_BOOKMARK_ELEMENT);</span>
1235       break;
1236     case STATE_INFO:
1237       if (IS_ELEMENT (parse_data, element_name, XBEL_METADATA_ELEMENT))
1238         {
1239           const gchar *attr;
1240           gint i;
1241 
1242           i = 0;
1243           for (attr = attribute_names[i]; attr; attr = attribute_names[++i])
1244             {
1245               if ((IS_ATTRIBUTE (attr, XBEL_OWNER_ATTRIBUTE)) &amp;&amp;
1246                   (0 == strcmp (attribute_values[i], BOOKMARK_METADATA_OWNER)))
1247                 {
1248                   parse_data-&gt;state = STATE_METADATA;
1249 
1250                   if (!parse_data-&gt;current_item-&gt;metadata)
1251                     parse_data-&gt;current_item-&gt;metadata = bookmark_metadata_new ();
1252                 }
1253             }
1254         }
1255       else
1256         g_set_error (error, G_MARKUP_ERROR,
<a name="58" id="anc58"></a><span class="line-modified">1257                      G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified">1258                      _(&quot;Unexpected tag &#39;%s&#39;, tag &#39;%s&#39; expected&quot;),</span>
<span class="line-modified">1259                      element_name,</span>
<span class="line-modified">1260                      XBEL_METADATA_ELEMENT);</span>
1261       break;
1262     case STATE_METADATA:
1263       if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_APPLICATIONS_ELEMENT))
1264         parse_data-&gt;state = STATE_APPLICATIONS;
1265       else if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_GROUPS_ELEMENT))
1266         parse_data-&gt;state = STATE_GROUPS;
1267       else if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_PRIVATE_ELEMENT))
1268         parse_data-&gt;current_item-&gt;metadata-&gt;is_private = TRUE;
1269       else if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_ICON_ELEMENT))
1270         {
1271           GError *inner_error = NULL;
1272 
<a name="59" id="anc59"></a><span class="line-modified">1273       parse_data-&gt;state = STATE_ICON;</span>
1274 
1275           parse_icon_element (context,
<a name="60" id="anc60"></a><span class="line-modified">1276                       parse_data,</span>
<span class="line-modified">1277                       attribute_names,</span>
<span class="line-modified">1278                       attribute_values,</span>
<span class="line-modified">1279                       &amp;inner_error);</span>
1280           if (inner_error)
1281             g_propagate_error (error, inner_error);
1282         }
1283       else if (IS_ELEMENT_NS (parse_data, element_name, MIME_NAMESPACE_URI, MIME_TYPE_ELEMENT))
1284         {
1285           GError *inner_error = NULL;
1286 
1287           parse_data-&gt;state = STATE_MIME;
1288 
1289           parse_mime_type_element (context,
<a name="61" id="anc61"></a><span class="line-modified">1290                        parse_data,</span>
<span class="line-modified">1291                        attribute_names,</span>
<span class="line-modified">1292                        attribute_values,</span>
<span class="line-modified">1293                        &amp;inner_error);</span>
1294           if (inner_error)
1295             g_propagate_error (error, inner_error);
1296         }
1297       else
1298         g_set_error (error, G_MARKUP_ERROR,
<a name="62" id="anc62"></a><span class="line-modified">1299                      G_MARKUP_ERROR_UNKNOWN_ELEMENT,</span>
<span class="line-modified">1300                      _(&quot;Unexpected tag &#39;%s&#39; inside &#39;%s&#39;&quot;),</span>
<span class="line-modified">1301                     element_name,</span>
<span class="line-modified">1302                     XBEL_METADATA_ELEMENT);</span>
1303       break;
1304     case STATE_APPLICATIONS:
1305       if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_APPLICATION_ELEMENT))
1306         {
1307           GError *inner_error = NULL;
1308 
1309           parse_data-&gt;state = STATE_APPLICATION;
1310 
1311           parse_application_element (context,
<a name="63" id="anc63"></a><span class="line-modified">1312                          parse_data,</span>
<span class="line-modified">1313                          attribute_names,</span>
<span class="line-modified">1314                          attribute_values,</span>
<span class="line-modified">1315                          &amp;inner_error);</span>
1316           if (inner_error)
1317             g_propagate_error (error, inner_error);
1318         }
1319       else
1320         g_set_error (error, G_MARKUP_ERROR,
<a name="64" id="anc64"></a><span class="line-modified">1321                      G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified">1322                      _(&quot;Unexpected tag &#39;%s&#39;, tag &#39;%s&#39; expected&quot;),</span>
<span class="line-modified">1323                      element_name,</span>
<span class="line-modified">1324                      BOOKMARK_APPLICATION_ELEMENT);</span>
1325       break;
1326     case STATE_GROUPS:
1327       if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_GROUP_ELEMENT))
1328         parse_data-&gt;state = STATE_GROUP;
1329       else
1330         g_set_error (error, G_MARKUP_ERROR,
<a name="65" id="anc65"></a><span class="line-modified">1331                      G_MARKUP_ERROR_INVALID_CONTENT,</span>
<span class="line-modified">1332                      _(&quot;Unexpected tag &#39;%s&#39;, tag &#39;%s&#39; expected&quot;),</span>
<span class="line-modified">1333                      element_name,</span>
<span class="line-modified">1334                      BOOKMARK_GROUP_ELEMENT);</span>
1335       break;
1336 
1337     case STATE_TITLE:
1338     case STATE_DESC:
1339     case STATE_APPLICATION:
1340     case STATE_GROUP:
1341     case STATE_MIME:
1342     case STATE_ICON:
1343     case STATE_FINISHED:
1344       g_set_error (error, G_MARKUP_ERROR,
1345                    G_MARKUP_ERROR_INVALID_CONTENT,
1346                    _(&quot;Unexpected tag &#39;%s&#39; inside &#39;%s&#39;&quot;),
1347                    element_name,
1348                    parser_state_to_element_name (parse_data-&gt;state));
1349       break;
1350 
1351     default:
1352       g_assert_not_reached ();
1353       break;
1354     }
1355 }
1356 
1357 static void
1358 end_element_raw_cb (GMarkupParseContext *context,
1359                     const gchar         *element_name,
1360                     gpointer             user_data,
1361                     GError             **error)
1362 {
1363   ParseData *parse_data = (ParseData *) user_data;
1364 
1365   if (IS_ELEMENT (parse_data, element_name, XBEL_ROOT_ELEMENT))
1366     parse_data-&gt;state = STATE_FINISHED;
1367   else if (IS_ELEMENT (parse_data, element_name, XBEL_BOOKMARK_ELEMENT))
1368     {
1369       parse_data-&gt;current_item = NULL;
1370 
1371       parse_data-&gt;state = STATE_ROOT;
1372     }
1373   else if ((IS_ELEMENT (parse_data, element_name, XBEL_INFO_ELEMENT)) ||
1374            (IS_ELEMENT (parse_data, element_name, XBEL_TITLE_ELEMENT)) ||
1375            (IS_ELEMENT (parse_data, element_name, XBEL_DESC_ELEMENT)))
1376     {
1377       if (parse_data-&gt;current_item)
1378         parse_data-&gt;state = STATE_BOOKMARK;
1379       else
1380         parse_data-&gt;state = STATE_ROOT;
1381     }
1382   else if (IS_ELEMENT (parse_data, element_name, XBEL_METADATA_ELEMENT))
1383     parse_data-&gt;state = STATE_INFO;
1384   else if (IS_ELEMENT_NS (parse_data, element_name,
1385                           BOOKMARK_NAMESPACE_URI,
1386                           BOOKMARK_APPLICATION_ELEMENT))
1387     parse_data-&gt;state = STATE_APPLICATIONS;
1388   else if (IS_ELEMENT_NS (parse_data, element_name,
1389                           BOOKMARK_NAMESPACE_URI,
1390                           BOOKMARK_GROUP_ELEMENT))
1391     parse_data-&gt;state = STATE_GROUPS;
1392   else if ((IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_APPLICATIONS_ELEMENT)) ||
1393            (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_GROUPS_ELEMENT)) ||
1394            (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_PRIVATE_ELEMENT)) ||
1395            (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_ICON_ELEMENT)) ||
1396            (IS_ELEMENT_NS (parse_data, element_name, MIME_NAMESPACE_URI, MIME_TYPE_ELEMENT)))
1397     parse_data-&gt;state = STATE_METADATA;
1398 }
1399 
1400 static void
1401 text_raw_cb (GMarkupParseContext *context,
1402              const gchar         *text,
1403              gsize                length,
1404              gpointer             user_data,
1405              GError             **error)
1406 {
1407   ParseData *parse_data = (ParseData *) user_data;
1408   gchar *payload;
1409 
1410   payload = g_strndup (text, length);
1411 
1412   switch (parse_data-&gt;state)
1413     {
1414     case STATE_TITLE:
1415       if (parse_data-&gt;current_item)
1416         {
1417           g_free (parse_data-&gt;current_item-&gt;title);
1418           parse_data-&gt;current_item-&gt;title = g_strdup (payload);
1419         }
1420       else
1421         {
1422           g_free (parse_data-&gt;bookmark_file-&gt;title);
1423           parse_data-&gt;bookmark_file-&gt;title = g_strdup (payload);
1424         }
1425       break;
1426     case STATE_DESC:
1427       if (parse_data-&gt;current_item)
1428         {
1429           g_free (parse_data-&gt;current_item-&gt;description);
1430           parse_data-&gt;current_item-&gt;description = g_strdup (payload);
1431         }
1432       else
1433         {
1434           g_free (parse_data-&gt;bookmark_file-&gt;description);
1435           parse_data-&gt;bookmark_file-&gt;description = g_strdup (payload);
1436         }
1437       break;
1438     case STATE_GROUP:
1439       {
1440       GList *groups;
1441 
1442       g_warn_if_fail (parse_data-&gt;current_item != NULL);
1443 
1444       if (!parse_data-&gt;current_item-&gt;metadata)
1445         parse_data-&gt;current_item-&gt;metadata = bookmark_metadata_new ();
1446 
1447       groups = parse_data-&gt;current_item-&gt;metadata-&gt;groups;
1448       parse_data-&gt;current_item-&gt;metadata-&gt;groups = g_list_prepend (groups, g_strdup (payload));
1449       }
1450       break;
1451     case STATE_ROOT:
1452     case STATE_BOOKMARK:
1453     case STATE_INFO:
1454     case STATE_METADATA:
1455     case STATE_APPLICATIONS:
1456     case STATE_APPLICATION:
1457     case STATE_GROUPS:
1458     case STATE_MIME:
1459     case STATE_ICON:
1460       break;
1461     default:
1462       g_warn_if_reached ();
1463       break;
1464     }
1465 
1466   g_free (payload);
1467 }
1468 
1469 static const GMarkupParser markup_parser =
1470 {
1471   start_element_raw_cb, /* start_element */
1472   end_element_raw_cb,   /* end_element */
1473   text_raw_cb,          /* text */
1474   NULL,                 /* passthrough */
1475   NULL
1476 };
1477 
1478 static gboolean
1479 g_bookmark_file_parse (GBookmarkFile  *bookmark,
<a name="66" id="anc66"></a><span class="line-modified">1480              const gchar  *buffer,</span>
<span class="line-modified">1481              gsize         length,</span>
<span class="line-modified">1482              GError       **error)</span>
1483 {
1484   GMarkupParseContext *context;
1485   ParseData *parse_data;
1486   GError *parse_error, *end_error;
1487   gboolean retval;
1488 
1489   g_warn_if_fail (bookmark != NULL);
1490 
1491   if (!buffer)
1492     return FALSE;
1493 
1494   parse_error = NULL;
1495   end_error = NULL;
1496 
1497   if (length == (gsize) -1)
1498     length = strlen (buffer);
1499 
1500   parse_data = parse_data_new ();
1501   parse_data-&gt;bookmark_file = bookmark;
1502 
1503   context = g_markup_parse_context_new (&amp;markup_parser,
<a name="67" id="anc67"></a><span class="line-modified">1504                     0,</span>
<span class="line-modified">1505                     parse_data,</span>
<span class="line-modified">1506                     (GDestroyNotify) parse_data_free);</span>
1507 
1508   retval = g_markup_parse_context_parse (context,
<a name="68" id="anc68"></a><span class="line-modified">1509                      buffer,</span>
<span class="line-modified">1510                      length,</span>
<span class="line-modified">1511                      &amp;parse_error);</span>
1512   if (!retval)
1513     g_propagate_error (error, parse_error);
1514   else
1515    {
1516      retval = g_markup_parse_context_end_parse (context, &amp;end_error);
1517       if (!retval)
1518         g_propagate_error (error, end_error);
1519    }
1520 
1521   g_markup_parse_context_free (context);
1522 
1523   return retval;
1524 }
1525 
1526 static gchar *
1527 g_bookmark_file_dump (GBookmarkFile  *bookmark,
<a name="69" id="anc69"></a><span class="line-modified">1528               gsize          *length,</span>
<span class="line-modified">1529               GError        **error)</span>
1530 {
1531   GString *retval;
1532   gchar *buffer;
1533   GList *l;
1534 
1535   retval = g_string_sized_new (4096);
1536 
1537   g_string_append (retval,
<a name="70" id="anc70"></a><span class="line-modified">1538            &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;</span>
1539 #if 0
<a name="71" id="anc71"></a><span class="line-modified">1540            /* XXX - do we really need the doctype? */</span>
<span class="line-modified">1541            &quot;&lt;!DOCTYPE &quot; XBEL_DTD_NICK &quot;\n&quot;</span>
<span class="line-modified">1542            &quot;  PUBLIC \&quot;&quot; XBEL_DTD_SYSTEM &quot;\&quot;\n&quot;</span>
<span class="line-modified">1543            &quot;         \&quot;&quot; XBEL_DTD_URI &quot;\&quot;&gt;\n&quot;</span>
1544 #endif
<a name="72" id="anc72"></a><span class="line-modified">1545            &quot;&lt;&quot; XBEL_ROOT_ELEMENT &quot; &quot; XBEL_VERSION_ATTRIBUTE &quot;=\&quot;&quot; XBEL_VERSION &quot;\&quot;\n&quot;</span>
<span class="line-modified">1546            &quot;      xmlns:&quot; BOOKMARK_NAMESPACE_NAME &quot;=\&quot;&quot; BOOKMARK_NAMESPACE_URI &quot;\&quot;\n&quot;</span>
<span class="line-modified">1547            &quot;      xmlns:&quot; MIME_NAMESPACE_NAME     &quot;=\&quot;&quot; MIME_NAMESPACE_URI &quot;\&quot;\n&gt;&quot;);</span>
1548 
1549   if (bookmark-&gt;title)
1550     {
1551       gchar *escaped_title;
1552 
1553       escaped_title = g_markup_escape_text (bookmark-&gt;title, -1);
1554 
1555       buffer = g_strconcat (&quot;  &quot;
<a name="73" id="anc73"></a><span class="line-modified">1556                 &quot;&lt;&quot; XBEL_TITLE_ELEMENT &quot;&gt;&quot;,</span>
<span class="line-modified">1557                 escaped_title,</span>
<span class="line-modified">1558                 &quot;&lt;/&quot; XBEL_TITLE_ELEMENT &quot;&gt;\n&quot;, NULL);</span>
1559 
1560       g_string_append (retval, buffer);
1561 
1562       g_free (buffer);
1563       g_free (escaped_title);
1564     }
1565 
1566   if (bookmark-&gt;description)
1567     {
1568       gchar *escaped_desc;
1569 
1570       escaped_desc = g_markup_escape_text (bookmark-&gt;description, -1);
1571 
1572       buffer = g_strconcat (&quot;  &quot;
<a name="74" id="anc74"></a><span class="line-modified">1573                 &quot;&lt;&quot; XBEL_DESC_ELEMENT &quot;&gt;&quot;,</span>
<span class="line-modified">1574                 escaped_desc,</span>
<span class="line-modified">1575                 &quot;&lt;/&quot; XBEL_DESC_ELEMENT &quot;&gt;\n&quot;, NULL);</span>
1576       g_string_append (retval, buffer);
1577 
1578       g_free (buffer);
1579       g_free (escaped_desc);
1580     }
1581 
1582   if (!bookmark-&gt;items)
1583     goto out;
1584   else
1585     retval = g_string_append (retval, &quot;\n&quot;);
1586 
1587   /* the items are stored in reverse order */
1588   for (l = g_list_last (bookmark-&gt;items);
1589        l != NULL;
1590        l = l-&gt;prev)
1591     {
1592       BookmarkItem *item = (BookmarkItem *) l-&gt;data;
1593       gchar *item_dump;
1594 
1595       item_dump = bookmark_item_dump (item);
1596       if (!item_dump)
1597         continue;
1598 
1599       retval = g_string_append (retval, item_dump);
1600 
1601       g_free (item_dump);
1602     }
1603 
1604 out:
1605   g_string_append (retval, &quot;&lt;/&quot; XBEL_ROOT_ELEMENT &quot;&gt;&quot;);
1606 
1607   if (length)
1608     *length = retval-&gt;len;
1609 
1610   return g_string_free (retval, FALSE);
1611 }
1612 
1613 /**************
1614  *    Misc    *
1615  **************/
1616 
1617 /* converts a Unix timestamp in a ISO 8601 compliant string; you
1618  * should free the returned string.
1619  */
1620 static gchar *
1621 timestamp_to_iso8601 (time_t timestamp)
1622 {
<a name="75" id="anc75"></a><span class="line-modified">1623   GTimeVal stamp;</span>


1624 
<a name="76" id="anc76"></a><span class="line-modified">1625   if (timestamp == (time_t) -1)</span>
<span class="line-removed">1626     g_get_current_time (&amp;stamp);</span>
<span class="line-removed">1627   else</span>
<span class="line-removed">1628     {</span>
<span class="line-removed">1629       stamp.tv_sec = timestamp;</span>
<span class="line-removed">1630       stamp.tv_usec = 0;</span>
<span class="line-removed">1631     }</span>
<span class="line-removed">1632 </span>
<span class="line-removed">1633   return g_time_val_to_iso8601 (&amp;stamp);</span>
1634 }
1635 
<a name="77" id="anc77"></a><span class="line-modified">1636 static time_t</span>
<span class="line-modified">1637 timestamp_from_iso8601 (const gchar *iso_date)</span>


1638 {
<a name="78" id="anc78"></a><span class="line-modified">1639   GTimeVal stamp;</span>







1640 
<a name="79" id="anc79"></a><span class="line-modified">1641   if (!g_time_val_from_iso8601 (iso_date, &amp;stamp))</span>
<span class="line-modified">1642     return (time_t) -1;</span>
1643 
<a name="80" id="anc80"></a><span class="line-modified">1644   return (time_t) stamp.tv_sec;</span>

1645 }
1646 
1647 G_DEFINE_QUARK (g-bookmark-file-error-quark, g_bookmark_file_error)
1648 
1649 /********************
1650  *    Public API    *
1651  ********************/
1652 
1653 /**
1654  * g_bookmark_file_new: (constructor)
1655  *
1656  * Creates a new empty #GBookmarkFile object.
1657  *
1658  * Use g_bookmark_file_load_from_file(), g_bookmark_file_load_from_data()
1659  * or g_bookmark_file_load_from_data_dirs() to read an existing bookmark
1660  * file.
1661  *
1662  * Returns: an empty #GBookmarkFile
1663  *
1664  * Since: 2.12
1665  */
1666 GBookmarkFile *
1667 g_bookmark_file_new (void)
1668 {
1669   GBookmarkFile *bookmark;
1670 
1671   bookmark = g_new (GBookmarkFile, 1);
1672 
1673   g_bookmark_file_init (bookmark);
1674 
1675   return bookmark;
1676 }
1677 
1678 /**
1679  * g_bookmark_file_free:
1680  * @bookmark: a #GBookmarkFile
1681  *
1682  * Frees a #GBookmarkFile.
1683  *
1684  * Since: 2.12
1685  */
1686 void
1687 g_bookmark_file_free (GBookmarkFile *bookmark)
1688 {
1689   if (!bookmark)
1690     return;
1691 
1692   g_bookmark_file_clear (bookmark);
1693 
1694   g_free (bookmark);
1695 }
1696 
1697 /**
1698  * g_bookmark_file_load_from_data:
1699  * @bookmark: an empty #GBookmarkFile struct
1700  * @data: (array length=length) (element-type guint8): desktop bookmarks
1701  *    loaded in memory
1702  * @length: the length of @data in bytes
1703  * @error: return location for a #GError, or %NULL
1704  *
1705  * Loads a bookmark file from memory into an empty #GBookmarkFile
1706  * structure.  If the object cannot be created then @error is set to a
1707  * #GBookmarkFileError.
1708  *
1709  * Returns: %TRUE if a desktop bookmark could be loaded.
1710  *
1711  * Since: 2.12
1712  */
1713 gboolean
1714 g_bookmark_file_load_from_data (GBookmarkFile  *bookmark,
<a name="81" id="anc81"></a><span class="line-modified">1715                 const gchar    *data,</span>
<span class="line-modified">1716                 gsize           length,</span>
<span class="line-modified">1717                 GError        **error)</span>
1718 {
1719   GError *parse_error;
1720   gboolean retval;
1721 
1722   g_return_val_if_fail (bookmark != NULL, FALSE);
1723 
1724   if (length == (gsize) -1)
1725     length = strlen (data);
1726 
1727   if (bookmark-&gt;items)
1728     {
1729       g_bookmark_file_clear (bookmark);
1730       g_bookmark_file_init (bookmark);
1731     }
1732 
1733   parse_error = NULL;
1734   retval = g_bookmark_file_parse (bookmark, data, length, &amp;parse_error);
1735 
1736   if (!retval)
1737     g_propagate_error (error, parse_error);
1738 
1739   return retval;
1740 }
1741 
1742 /**
1743  * g_bookmark_file_load_from_file:
1744  * @bookmark: an empty #GBookmarkFile struct
1745  * @filename: (type filename): the path of a filename to load, in the
1746  *     GLib file name encoding
1747  * @error: return location for a #GError, or %NULL
1748  *
1749  * Loads a desktop bookmark file into an empty #GBookmarkFile structure.
1750  * If the file could not be loaded then @error is set to either a #GFileError
1751  * or #GBookmarkFileError.
1752  *
1753  * Returns: %TRUE if a desktop bookmark file could be loaded
1754  *
1755  * Since: 2.12
1756  */
1757 gboolean
1758 g_bookmark_file_load_from_file (GBookmarkFile  *bookmark,
<a name="82" id="anc82"></a><span class="line-modified">1759                 const gchar    *filename,</span>
<span class="line-modified">1760                 GError        **error)</span>
1761 {
1762   gboolean ret = FALSE;
1763   gchar *buffer = NULL;
1764   gsize len;
1765 
1766   g_return_val_if_fail (bookmark != NULL, FALSE);
1767   g_return_val_if_fail (filename != NULL, FALSE);
1768 
1769   if (!g_file_get_contents (filename, &amp;buffer, &amp;len, error))
1770     goto out;
1771 
1772   if (!g_bookmark_file_load_from_data (bookmark, buffer, len, error))
1773     goto out;
1774 
1775   ret = TRUE;
1776  out:
1777   g_free (buffer);
1778   return ret;
1779 }
1780 
1781 
1782 /* Iterates through all the directories in *dirs trying to
1783  * find file.  When it successfully locates file, returns a
1784  * string its absolute path.  It also leaves the unchecked
1785  * directories in *dirs.  You should free the returned string
1786  *
1787  * Adapted from gkeyfile.c
1788  */
1789 static gchar *
1790 find_file_in_data_dirs (const gchar   *file,
1791                         gchar       ***dirs,
1792                         GError       **error)
1793 {
1794   gchar **data_dirs, *data_dir, *path;
1795 
1796   path = NULL;
1797 
1798   if (dirs == NULL)
1799     return NULL;
1800 
1801   data_dirs = *dirs;
1802   path = NULL;
1803   while (data_dirs &amp;&amp; (data_dir = *data_dirs) &amp;&amp; !path)
1804     {
1805       gchar *candidate_file, *sub_dir;
1806 
1807       candidate_file = (gchar *) file;
1808       sub_dir = g_strdup (&quot;&quot;);
1809       while (candidate_file != NULL &amp;&amp; !path)
1810         {
1811           gchar *p;
1812 
1813           path = g_build_filename (data_dir, sub_dir,
1814                                    candidate_file, NULL);
1815 
1816           candidate_file = strchr (candidate_file, &#39;-&#39;);
1817 
1818           if (candidate_file == NULL)
1819             break;
1820 
1821           candidate_file++;
1822 
1823           g_free (sub_dir);
1824           sub_dir = g_strndup (file, candidate_file - file - 1);
1825 
1826           for (p = sub_dir; *p != &#39;\0&#39;; p++)
1827             {
1828               if (*p == &#39;-&#39;)
1829                 *p = G_DIR_SEPARATOR;
1830             }
1831         }
1832       g_free (sub_dir);
1833       data_dirs++;
1834     }
1835 
1836   *dirs = data_dirs;
1837 
1838   if (!path)
1839     {
1840       g_set_error_literal (error, G_BOOKMARK_FILE_ERROR,
1841                            G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND,
1842                            _(&quot;No valid bookmark file found in data dirs&quot;));
1843 
1844       return NULL;
1845     }
1846 
1847   return path;
1848 }
1849 
1850 
1851 /**
1852  * g_bookmark_file_load_from_data_dirs:
1853  * @bookmark: a #GBookmarkFile
1854  * @file: (type filename): a relative path to a filename to open and parse
1855  * @full_path: (out) (optional) (type filename): return location for a string
1856  *    containing the full path of the file, or %NULL
1857  * @error: return location for a #GError, or %NULL
1858  *
1859  * This function looks for a desktop bookmark file named @file in the
1860  * paths returned from g_get_user_data_dir() and g_get_system_data_dirs(),
1861  * loads the file into @bookmark and returns the file&#39;s full path in
1862  * @full_path.  If the file could not be loaded then @error is
1863  * set to either a #GFileError or #GBookmarkFileError.
1864  *
1865  * Returns: %TRUE if a key file could be loaded, %FALSE otherwise
1866  *
1867  * Since: 2.12
1868  */
1869 gboolean
1870 g_bookmark_file_load_from_data_dirs (GBookmarkFile  *bookmark,
<a name="83" id="anc83"></a><span class="line-modified">1871                      const gchar    *file,</span>
<span class="line-modified">1872                      gchar         **full_path,</span>
<span class="line-modified">1873                      GError        **error)</span>
1874 {
1875   GError *file_error = NULL;
1876   gchar **all_data_dirs, **data_dirs;
1877   const gchar *user_data_dir;
1878   const gchar * const * system_data_dirs;
1879   gsize i, j;
1880   gchar *output_path;
1881   gboolean found_file;
1882 
1883   g_return_val_if_fail (bookmark != NULL, FALSE);
1884   g_return_val_if_fail (!g_path_is_absolute (file), FALSE);
1885 
1886   user_data_dir = g_get_user_data_dir ();
1887   system_data_dirs = g_get_system_data_dirs ();
1888   all_data_dirs = g_new0 (gchar *, g_strv_length ((gchar **)system_data_dirs) + 2);
1889 
1890   i = 0;
1891   all_data_dirs[i++] = g_strdup (user_data_dir);
1892 
1893   j = 0;
1894   while (system_data_dirs[j] != NULL)
1895     all_data_dirs[i++] = g_strdup (system_data_dirs[j++]);
1896 
1897   found_file = FALSE;
1898   data_dirs = all_data_dirs;
1899   output_path = NULL;
1900   while (*data_dirs != NULL &amp;&amp; !found_file)
1901     {
1902       g_free (output_path);
1903 
1904       output_path = find_file_in_data_dirs (file, &amp;data_dirs, &amp;file_error);
1905 
1906       if (file_error)
1907         {
1908           g_propagate_error (error, file_error);
<a name="84" id="anc84"></a><span class="line-modified">1909       break;</span>
1910         }
1911 
1912       found_file = g_bookmark_file_load_from_file (bookmark,
<a name="85" id="anc85"></a><span class="line-modified">1913                                output_path,</span>
<span class="line-modified">1914                                &amp;file_error);</span>
1915       if (file_error)
1916         {
<a name="86" id="anc86"></a><span class="line-modified">1917       g_propagate_error (error, file_error);</span>
<span class="line-modified">1918       break;</span>
1919         }
1920     }
1921 
1922   if (found_file &amp;&amp; full_path)
1923     *full_path = output_path;
1924   else
1925     g_free (output_path);
1926 
1927   g_strfreev (all_data_dirs);
1928 
1929   return found_file;
1930 }
1931 
1932 
1933 /**
1934  * g_bookmark_file_to_data:
1935  * @bookmark: a #GBookmarkFile
1936  * @length: (out) (optional): return location for the length of the returned string, or %NULL
1937  * @error: return location for a #GError, or %NULL
1938  *
1939  * This function outputs @bookmark as a string.
1940  *
1941  * Returns: (array length=length) (element-type guint8):
1942  *   a newly allocated string holding the contents of the #GBookmarkFile
1943  *
1944  * Since: 2.12
1945  */
1946 gchar *
1947 g_bookmark_file_to_data (GBookmarkFile  *bookmark,
<a name="87" id="anc87"></a><span class="line-modified">1948              gsize          *length,</span>
<span class="line-modified">1949              GError        **error)</span>
1950 {
1951   GError *write_error = NULL;
1952   gchar *retval;
1953 
1954   g_return_val_if_fail (bookmark != NULL, NULL);
1955 
1956   retval = g_bookmark_file_dump (bookmark, length, &amp;write_error);
1957   if (write_error)
1958     {
1959       g_propagate_error (error, write_error);
1960 
1961       return NULL;
1962     }
1963 
1964   return retval;
1965 }
1966 
1967 /**
1968  * g_bookmark_file_to_file:
1969  * @bookmark: a #GBookmarkFile
1970  * @filename: (type filename): path of the output file
1971  * @error: return location for a #GError, or %NULL
1972  *
1973  * This function outputs @bookmark into a file.  The write process is
1974  * guaranteed to be atomic by using g_file_set_contents() internally.
1975  *
1976  * Returns: %TRUE if the file was successfully written.
1977  *
1978  * Since: 2.12
1979  */
1980 gboolean
1981 g_bookmark_file_to_file (GBookmarkFile  *bookmark,
<a name="88" id="anc88"></a><span class="line-modified">1982              const gchar    *filename,</span>
<span class="line-modified">1983              GError        **error)</span>
1984 {
1985   gchar *data;
1986   GError *data_error, *write_error;
1987   gsize len;
1988   gboolean retval;
1989 
1990   g_return_val_if_fail (bookmark != NULL, FALSE);
1991   g_return_val_if_fail (filename != NULL, FALSE);
1992 
1993   data_error = NULL;
1994   data = g_bookmark_file_to_data (bookmark, &amp;len, &amp;data_error);
1995   if (data_error)
1996     {
1997       g_propagate_error (error, data_error);
1998 
1999       return FALSE;
2000     }
2001 
2002   write_error = NULL;
2003   g_file_set_contents (filename, data, len, &amp;write_error);
2004   if (write_error)
2005     {
2006       g_propagate_error (error, write_error);
2007 
2008       retval = FALSE;
2009     }
2010   else
2011     retval = TRUE;
2012 
2013   g_free (data);
2014 
2015   return retval;
2016 }
2017 
2018 static BookmarkItem *
2019 g_bookmark_file_lookup_item (GBookmarkFile *bookmark,
<a name="89" id="anc89"></a><span class="line-modified">2020                  const gchar   *uri)</span>
2021 {
2022   g_warn_if_fail (bookmark != NULL &amp;&amp; uri != NULL);
2023 
2024   return g_hash_table_lookup (bookmark-&gt;items_by_uri, uri);
2025 }
2026 
2027 /* this function adds a new item to the list */
2028 static void
2029 g_bookmark_file_add_item (GBookmarkFile  *bookmark,
<a name="90" id="anc90"></a><span class="line-modified">2030               BookmarkItem   *item,</span>
<span class="line-modified">2031               GError        **error)</span>
2032 {
2033   g_warn_if_fail (bookmark != NULL);
2034   g_warn_if_fail (item != NULL);
2035 
2036 #ifdef GSTREAMER_LITE
2037   if (bookmark == NULL || item == NULL) {
2038     return;
2039   }
2040 #endif // GSTREAMER_LITE
2041 
2042   /* this should never happen; and if it does, then we are
2043    * screwing up something big time.
2044    */
2045   if (G_UNLIKELY (g_bookmark_file_has_item (bookmark, item-&gt;uri)))
2046     {
2047       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="91" id="anc91"></a><span class="line-modified">2048                    G_BOOKMARK_FILE_ERROR_INVALID_URI,</span>
<span class="line-modified">2049                    _(&quot;A bookmark for URI &#39;%s&#39; already exists&quot;),</span>
<span class="line-modified">2050                    item-&gt;uri);</span>
2051       return;
2052     }
2053 
2054   bookmark-&gt;items = g_list_prepend (bookmark-&gt;items, item);
2055 
2056   g_hash_table_replace (bookmark-&gt;items_by_uri,
<a name="92" id="anc92"></a><span class="line-modified">2057             item-&gt;uri,</span>
<span class="line-modified">2058             item);</span>
2059 
2060   if (item-&gt;added == (time_t) -1)
2061     item-&gt;added = time (NULL);
2062 
2063   if (item-&gt;modified == (time_t) -1)
2064     item-&gt;modified = time (NULL);
2065 }
2066 
2067 /**
2068  * g_bookmark_file_remove_item:
2069  * @bookmark: a #GBookmarkFile
2070  * @uri: a valid URI
2071  * @error: return location for a #GError, or %NULL
2072  *
2073  * Removes the bookmark for @uri from the bookmark file @bookmark.
2074  *
2075  * Returns: %TRUE if the bookmark was removed successfully.
2076  *
2077  * Since: 2.12
2078  */
2079 gboolean
2080 g_bookmark_file_remove_item (GBookmarkFile  *bookmark,
<a name="93" id="anc93"></a><span class="line-modified">2081                  const gchar    *uri,</span>
<span class="line-modified">2082                  GError        **error)</span>
2083 {
2084   BookmarkItem *item;
2085 
2086   g_return_val_if_fail (bookmark != NULL, FALSE);
2087   g_return_val_if_fail (uri != NULL, FALSE);
2088 
2089   item = g_bookmark_file_lookup_item (bookmark, uri);
2090 
2091   if (!item)
2092     {
2093       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="94" id="anc94"></a><span class="line-modified">2094                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2095                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2096                    uri);</span>
2097       return FALSE;
2098     }
2099 
2100   bookmark-&gt;items = g_list_remove (bookmark-&gt;items, item);
2101   g_hash_table_remove (bookmark-&gt;items_by_uri, item-&gt;uri);
2102 
2103   bookmark_item_free (item);
2104 
2105   return TRUE;
2106 }
2107 
2108 /**
2109  * g_bookmark_file_has_item:
2110  * @bookmark: a #GBookmarkFile
2111  * @uri: a valid URI
2112  *
2113  * Looks whether the desktop bookmark has an item with its URI set to @uri.
2114  *
2115  * Returns: %TRUE if @uri is inside @bookmark, %FALSE otherwise
2116  *
2117  * Since: 2.12
2118  */
2119 gboolean
2120 g_bookmark_file_has_item (GBookmarkFile *bookmark,
<a name="95" id="anc95"></a><span class="line-modified">2121               const gchar   *uri)</span>
2122 {
2123   g_return_val_if_fail (bookmark != NULL, FALSE);
2124   g_return_val_if_fail (uri != NULL, FALSE);
2125 
2126   return (NULL != g_hash_table_lookup (bookmark-&gt;items_by_uri, uri));
2127 }
2128 
2129 /**
2130  * g_bookmark_file_get_uris:
2131  * @bookmark: a #GBookmarkFile
2132  * @length: (out) (optional): return location for the number of returned URIs, or %NULL
2133  *
2134  * Returns all URIs of the bookmarks in the bookmark file @bookmark.
2135  * The array of returned URIs will be %NULL-terminated, so @length may
2136  * optionally be %NULL.
2137  *
2138  * Returns: (array length=length) (transfer full): a newly allocated %NULL-terminated array of strings.
2139  *   Use g_strfreev() to free it.
2140  *
2141  * Since: 2.12
2142  */
2143 gchar **
2144 g_bookmark_file_get_uris (GBookmarkFile *bookmark,
<a name="96" id="anc96"></a><span class="line-modified">2145               gsize         *length)</span>
2146 {
2147   GList *l;
2148   gchar **uris;
2149   gsize i, n_items;
2150 
2151   g_return_val_if_fail (bookmark != NULL, NULL);
2152 
2153   n_items = g_list_length (bookmark-&gt;items);
2154   uris = g_new0 (gchar *, n_items + 1);
2155 
2156   /* the items are stored in reverse order, so we walk the list backward */
2157   for (l = g_list_last (bookmark-&gt;items), i = 0; l != NULL; l = l-&gt;prev)
2158     {
2159       BookmarkItem *item = (BookmarkItem *) l-&gt;data;
2160 
2161       g_warn_if_fail (item != NULL);
2162 
2163       uris[i++] = g_strdup (item-&gt;uri);
2164     }
2165   uris[i] = NULL;
2166 
2167   if (length)
2168     *length = i;
2169 
2170   return uris;
2171 }
2172 
2173 /**
2174  * g_bookmark_file_set_title:
2175  * @bookmark: a #GBookmarkFile
2176  * @uri: (nullable): a valid URI or %NULL
2177  * @title: a UTF-8 encoded string
2178  *
2179  * Sets @title as the title of the bookmark for @uri inside the
2180  * bookmark file @bookmark.
2181  *
2182  * If @uri is %NULL, the title of @bookmark is set.
2183  *
2184  * If a bookmark for @uri cannot be found then it is created.
2185  *
2186  * Since: 2.12
2187  */
2188 void
2189 g_bookmark_file_set_title (GBookmarkFile *bookmark,
<a name="97" id="anc97"></a><span class="line-modified">2190                const gchar   *uri,</span>
<span class="line-modified">2191                const gchar   *title)</span>
2192 {
2193   g_return_if_fail (bookmark != NULL);
2194 
2195   if (!uri)
2196     {
2197       g_free (bookmark-&gt;title);
2198       bookmark-&gt;title = g_strdup (title);
2199     }
2200   else
2201     {
2202       BookmarkItem *item;
2203 
2204       item = g_bookmark_file_lookup_item (bookmark, uri);
2205       if (!item)
2206         {
2207           item = bookmark_item_new (uri);
2208           g_bookmark_file_add_item (bookmark, item, NULL);
2209         }
2210 
2211       g_free (item-&gt;title);
2212       item-&gt;title = g_strdup (title);
2213 
2214       item-&gt;modified = time (NULL);
2215     }
2216 }
2217 
2218 /**
2219  * g_bookmark_file_get_title:
2220  * @bookmark: a #GBookmarkFile
2221  * @uri: (nullable): a valid URI or %NULL
2222  * @error: return location for a #GError, or %NULL
2223  *
2224  * Returns the title of the bookmark for @uri.
2225  *
2226  * If @uri is %NULL, the title of @bookmark is returned.
2227  *
2228  * In the event the URI cannot be found, %NULL is returned and
2229  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2230  *
2231  * Returns: a newly allocated string or %NULL if the specified
2232  *   URI cannot be found.
2233  *
2234  * Since: 2.12
2235  */
2236 gchar *
2237 g_bookmark_file_get_title (GBookmarkFile  *bookmark,
<a name="98" id="anc98"></a><span class="line-modified">2238                const gchar    *uri,</span>
<span class="line-modified">2239                GError        **error)</span>
2240 {
2241   BookmarkItem *item;
2242 
2243   g_return_val_if_fail (bookmark != NULL, NULL);
2244 
2245   if (!uri)
2246     return g_strdup (bookmark-&gt;title);
2247 
2248   item = g_bookmark_file_lookup_item (bookmark, uri);
2249   if (!item)
2250     {
2251       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="99" id="anc99"></a><span class="line-modified">2252                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2253                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2254                    uri);</span>
2255       return NULL;
2256     }
2257 
2258   return g_strdup (item-&gt;title);
2259 }
2260 
2261 /**
2262  * g_bookmark_file_set_description:
2263  * @bookmark: a #GBookmarkFile
2264  * @uri: (nullable): a valid URI or %NULL
2265  * @description: a string
2266  *
2267  * Sets @description as the description of the bookmark for @uri.
2268  *
2269  * If @uri is %NULL, the description of @bookmark is set.
2270  *
2271  * If a bookmark for @uri cannot be found then it is created.
2272  *
2273  * Since: 2.12
2274  */
2275 void
2276 g_bookmark_file_set_description (GBookmarkFile *bookmark,
<a name="100" id="anc100"></a><span class="line-modified">2277                  const gchar   *uri,</span>
<span class="line-modified">2278                  const gchar   *description)</span>
2279 {
2280   g_return_if_fail (bookmark != NULL);
2281 
2282   if (!uri)
2283     {
2284       g_free (bookmark-&gt;description);
2285       bookmark-&gt;description = g_strdup (description);
2286     }
2287   else
2288     {
2289       BookmarkItem *item;
2290 
2291       item = g_bookmark_file_lookup_item (bookmark, uri);
2292       if (!item)
2293         {
2294           item = bookmark_item_new (uri);
2295           g_bookmark_file_add_item (bookmark, item, NULL);
2296         }
2297 
2298       g_free (item-&gt;description);
2299       item-&gt;description = g_strdup (description);
2300 
2301       item-&gt;modified = time (NULL);
2302     }
2303 }
2304 
2305 /**
2306  * g_bookmark_file_get_description:
2307  * @bookmark: a #GBookmarkFile
2308  * @uri: a valid URI
2309  * @error: return location for a #GError, or %NULL
2310  *
2311  * Retrieves the description of the bookmark for @uri.
2312  *
2313  * In the event the URI cannot be found, %NULL is returned and
2314  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2315  *
2316  * Returns: a newly allocated string or %NULL if the specified
2317  *   URI cannot be found.
2318  *
2319  * Since: 2.12
2320  */
2321 gchar *
2322 g_bookmark_file_get_description (GBookmarkFile  *bookmark,
<a name="101" id="anc101"></a><span class="line-modified">2323                  const gchar    *uri,</span>
<span class="line-modified">2324                  GError        **error)</span>
2325 {
2326   BookmarkItem *item;
2327 
2328   g_return_val_if_fail (bookmark != NULL, NULL);
2329 
2330   if (!uri)
2331     return g_strdup (bookmark-&gt;description);
2332 
2333   item = g_bookmark_file_lookup_item (bookmark, uri);
2334   if (!item)
2335     {
2336       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="102" id="anc102"></a><span class="line-modified">2337                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2338                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2339                    uri);</span>
2340       return NULL;
2341     }
2342 
2343   return g_strdup (item-&gt;description);
2344 }
2345 
2346 /**
2347  * g_bookmark_file_set_mime_type:
2348  * @bookmark: a #GBookmarkFile
2349  * @uri: a valid URI
2350  * @mime_type: a MIME type
2351  *
2352  * Sets @mime_type as the MIME type of the bookmark for @uri.
2353  *
2354  * If a bookmark for @uri cannot be found then it is created.
2355  *
2356  * Since: 2.12
2357  */
2358 void
2359 g_bookmark_file_set_mime_type (GBookmarkFile *bookmark,
<a name="103" id="anc103"></a><span class="line-modified">2360                    const gchar   *uri,</span>
<span class="line-modified">2361                    const gchar   *mime_type)</span>
2362 {
2363   BookmarkItem *item;
2364 
2365   g_return_if_fail (bookmark != NULL);
2366   g_return_if_fail (uri != NULL);
2367   g_return_if_fail (mime_type != NULL);
2368 
2369   item = g_bookmark_file_lookup_item (bookmark, uri);
2370   if (!item)
2371     {
2372       item = bookmark_item_new (uri);
2373       g_bookmark_file_add_item (bookmark, item, NULL);
2374     }
2375 
2376   if (!item-&gt;metadata)
2377     item-&gt;metadata = bookmark_metadata_new ();
2378 
2379   g_free (item-&gt;metadata-&gt;mime_type);
2380 
2381   item-&gt;metadata-&gt;mime_type = g_strdup (mime_type);
2382   item-&gt;modified = time (NULL);
2383 }
2384 
2385 /**
2386  * g_bookmark_file_get_mime_type:
2387  * @bookmark: a #GBookmarkFile
2388  * @uri: a valid URI
2389  * @error: return location for a #GError, or %NULL
2390  *
2391  * Retrieves the MIME type of the resource pointed by @uri.
2392  *
2393  * In the event the URI cannot be found, %NULL is returned and
2394  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
2395  * event that the MIME type cannot be found, %NULL is returned and
2396  * @error is set to #G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
2397  *
2398  * Returns: a newly allocated string or %NULL if the specified
2399  *   URI cannot be found.
2400  *
2401  * Since: 2.12
2402  */
2403 gchar *
2404 g_bookmark_file_get_mime_type (GBookmarkFile  *bookmark,
<a name="104" id="anc104"></a><span class="line-modified">2405                    const gchar    *uri,</span>
<span class="line-modified">2406                    GError        **error)</span>
2407 {
2408   BookmarkItem *item;
2409 
2410   g_return_val_if_fail (bookmark != NULL, NULL);
2411   g_return_val_if_fail (uri != NULL, NULL);
2412 
2413   item = g_bookmark_file_lookup_item (bookmark, uri);
2414   if (!item)
2415     {
2416       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="105" id="anc105"></a><span class="line-modified">2417                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2418                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2419                    uri);</span>
2420       return NULL;
2421     }
2422 
2423   if (!item-&gt;metadata)
2424     {
2425       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="106" id="anc106"></a><span class="line-modified">2426                    G_BOOKMARK_FILE_ERROR_INVALID_VALUE,</span>
<span class="line-modified">2427                    _(&quot;No MIME type defined in the bookmark for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2428                    uri);</span>
2429       return NULL;
2430     }
2431 
2432   return g_strdup (item-&gt;metadata-&gt;mime_type);
2433 }
2434 
2435 /**
2436  * g_bookmark_file_set_is_private:
2437  * @bookmark: a #GBookmarkFile
2438  * @uri: a valid URI
2439  * @is_private: %TRUE if the bookmark should be marked as private
2440  *
2441  * Sets the private flag of the bookmark for @uri.
2442  *
2443  * If a bookmark for @uri cannot be found then it is created.
2444  *
2445  * Since: 2.12
2446  */
2447 void
2448 g_bookmark_file_set_is_private (GBookmarkFile *bookmark,
<a name="107" id="anc107"></a><span class="line-modified">2449                 const gchar   *uri,</span>
<span class="line-modified">2450                 gboolean       is_private)</span>
2451 {
2452   BookmarkItem *item;
2453 
2454   g_return_if_fail (bookmark != NULL);
2455   g_return_if_fail (uri != NULL);
2456 
2457   item = g_bookmark_file_lookup_item (bookmark, uri);
2458   if (!item)
2459     {
2460       item = bookmark_item_new (uri);
2461       g_bookmark_file_add_item (bookmark, item, NULL);
2462     }
2463 
2464   if (!item-&gt;metadata)
2465     item-&gt;metadata = bookmark_metadata_new ();
2466 
2467   item-&gt;metadata-&gt;is_private = (is_private == TRUE);
2468   item-&gt;modified = time (NULL);
2469 }
2470 
2471 /**
2472  * g_bookmark_file_get_is_private:
2473  * @bookmark: a #GBookmarkFile
2474  * @uri: a valid URI
2475  * @error: return location for a #GError, or %NULL
2476  *
2477  * Gets whether the private flag of the bookmark for @uri is set.
2478  *
2479  * In the event the URI cannot be found, %FALSE is returned and
2480  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
2481  * event that the private flag cannot be found, %FALSE is returned and
2482  * @error is set to #G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
2483  *
2484  * Returns: %TRUE if the private flag is set, %FALSE otherwise.
2485  *
2486  * Since: 2.12
2487  */
2488 gboolean
2489 g_bookmark_file_get_is_private (GBookmarkFile  *bookmark,
<a name="108" id="anc108"></a><span class="line-modified">2490                 const gchar    *uri,</span>
<span class="line-modified">2491                 GError        **error)</span>
2492 {
2493   BookmarkItem *item;
2494 
2495   g_return_val_if_fail (bookmark != NULL, FALSE);
2496   g_return_val_if_fail (uri != NULL, FALSE);
2497 
2498   item = g_bookmark_file_lookup_item (bookmark, uri);
2499   if (!item)
2500     {
2501       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="109" id="anc109"></a><span class="line-modified">2502                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2503                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2504                    uri);</span>
2505       return FALSE;
2506     }
2507 
2508   if (!item-&gt;metadata)
2509     {
2510       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="110" id="anc110"></a><span class="line-modified">2511                    G_BOOKMARK_FILE_ERROR_INVALID_VALUE,</span>
<span class="line-modified">2512                    _(&quot;No private flag has been defined in bookmark for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2513                    uri);</span>
2514       return FALSE;
2515     }
2516 
2517   return item-&gt;metadata-&gt;is_private;
2518 }
2519 
2520 /**
2521  * g_bookmark_file_set_added:
2522  * @bookmark: a #GBookmarkFile
2523  * @uri: a valid URI
2524  * @added: a timestamp or -1 to use the current time
2525  *
2526  * Sets the time the bookmark for @uri was added into @bookmark.
2527  *
2528  * If no bookmark for @uri is found then it is created.
2529  *
2530  * Since: 2.12
2531  */
2532 void
2533 g_bookmark_file_set_added (GBookmarkFile *bookmark,
<a name="111" id="anc111"></a><span class="line-modified">2534                const gchar   *uri,</span>
<span class="line-modified">2535                time_t         added)</span>
2536 {
2537   BookmarkItem *item;
2538 
2539   g_return_if_fail (bookmark != NULL);
2540   g_return_if_fail (uri != NULL);
2541 
2542   item = g_bookmark_file_lookup_item (bookmark, uri);
2543   if (!item)
2544     {
2545       item = bookmark_item_new (uri);
2546       g_bookmark_file_add_item (bookmark, item, NULL);
2547     }
2548 
2549   if (added == (time_t) -1)
2550     time (&amp;added);
2551 
2552   item-&gt;added = added;
2553   item-&gt;modified = added;
2554 }
2555 
2556 /**
2557  * g_bookmark_file_get_added:
2558  * @bookmark: a #GBookmarkFile
2559  * @uri: a valid URI
2560  * @error: return location for a #GError, or %NULL
2561  *
2562  * Gets the time the bookmark for @uri was added to @bookmark
2563  *
2564  * In the event the URI cannot be found, -1 is returned and
2565  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2566  *
2567  * Returns: a timestamp
2568  *
2569  * Since: 2.12
2570  */
2571 time_t
2572 g_bookmark_file_get_added (GBookmarkFile  *bookmark,
<a name="112" id="anc112"></a><span class="line-modified">2573                const gchar    *uri,</span>
<span class="line-modified">2574                GError        **error)</span>
2575 {
2576   BookmarkItem *item;
2577 
2578   g_return_val_if_fail (bookmark != NULL, (time_t) -1);
2579   g_return_val_if_fail (uri != NULL, (time_t) -1);
2580 
2581   item = g_bookmark_file_lookup_item (bookmark, uri);
2582   if (!item)
2583     {
2584       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="113" id="anc113"></a><span class="line-modified">2585                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2586                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2587                    uri);</span>
2588       return (time_t) -1;
2589     }
2590 
2591   return item-&gt;added;
2592 }
2593 
2594 /**
2595  * g_bookmark_file_set_modified:
2596  * @bookmark: a #GBookmarkFile
2597  * @uri: a valid URI
2598  * @modified: a timestamp or -1 to use the current time
2599  *
2600  * Sets the last time the bookmark for @uri was last modified.
2601  *
2602  * If no bookmark for @uri is found then it is created.
2603  *
2604  * The &quot;modified&quot; time should only be set when the bookmark&#39;s meta-data
2605  * was actually changed.  Every function of #GBookmarkFile that
2606  * modifies a bookmark also changes the modification time, except for
2607  * g_bookmark_file_set_visited().
2608  *
2609  * Since: 2.12
2610  */
2611 void
2612 g_bookmark_file_set_modified (GBookmarkFile *bookmark,
<a name="114" id="anc114"></a><span class="line-modified">2613                   const gchar   *uri,</span>
<span class="line-modified">2614                   time_t         modified)</span>
2615 {
2616   BookmarkItem *item;
2617 
2618   g_return_if_fail (bookmark != NULL);
2619   g_return_if_fail (uri != NULL);
2620 
2621   item = g_bookmark_file_lookup_item (bookmark, uri);
2622   if (!item)
2623     {
2624       item = bookmark_item_new (uri);
2625       g_bookmark_file_add_item (bookmark, item, NULL);
2626     }
2627 
2628   if (modified == (time_t) -1)
2629     time (&amp;modified);
2630 
2631   item-&gt;modified = modified;
2632 }
2633 
2634 /**
2635  * g_bookmark_file_get_modified:
2636  * @bookmark: a #GBookmarkFile
2637  * @uri: a valid URI
2638  * @error: return location for a #GError, or %NULL
2639  *
2640  * Gets the time when the bookmark for @uri was last modified.
2641  *
2642  * In the event the URI cannot be found, -1 is returned and
2643  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2644  *
2645  * Returns: a timestamp
2646  *
2647  * Since: 2.12
2648  */
2649 time_t
2650 g_bookmark_file_get_modified (GBookmarkFile  *bookmark,
<a name="115" id="anc115"></a><span class="line-modified">2651                   const gchar    *uri,</span>
<span class="line-modified">2652                   GError        **error)</span>
2653 {
2654   BookmarkItem *item;
2655 
2656   g_return_val_if_fail (bookmark != NULL, (time_t) -1);
2657   g_return_val_if_fail (uri != NULL, (time_t) -1);
2658 
2659   item = g_bookmark_file_lookup_item (bookmark, uri);
2660   if (!item)
2661     {
2662       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="116" id="anc116"></a><span class="line-modified">2663                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2664                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2665                    uri);</span>
2666       return (time_t) -1;
2667     }
2668 
2669   return item-&gt;modified;
2670 }
2671 
2672 /**
2673  * g_bookmark_file_set_visited:
2674  * @bookmark: a #GBookmarkFile
2675  * @uri: a valid URI
2676  * @visited: a timestamp or -1 to use the current time
2677  *
2678  * Sets the time the bookmark for @uri was last visited.
2679  *
2680  * If no bookmark for @uri is found then it is created.
2681  *
2682  * The &quot;visited&quot; time should only be set if the bookmark was launched,
2683  * either using the command line retrieved by g_bookmark_file_get_app_info()
2684  * or by the default application for the bookmark&#39;s MIME type, retrieved
2685  * using g_bookmark_file_get_mime_type().  Changing the &quot;visited&quot; time
2686  * does not affect the &quot;modified&quot; time.
2687  *
2688  * Since: 2.12
2689  */
2690 void
2691 g_bookmark_file_set_visited (GBookmarkFile *bookmark,
<a name="117" id="anc117"></a><span class="line-modified">2692                  const gchar   *uri,</span>
<span class="line-modified">2693                  time_t         visited)</span>
2694 {
2695   BookmarkItem *item;
2696 
2697   g_return_if_fail (bookmark != NULL);
2698   g_return_if_fail (uri != NULL);
2699 
2700   item = g_bookmark_file_lookup_item (bookmark, uri);
2701   if (!item)
2702     {
2703       item = bookmark_item_new (uri);
2704       g_bookmark_file_add_item (bookmark, item, NULL);
2705     }
2706 
2707   if (visited == (time_t) -1)
2708     time (&amp;visited);
2709 
2710   item-&gt;visited = visited;
2711 }
2712 
2713 /**
2714  * g_bookmark_file_get_visited:
2715  * @bookmark: a #GBookmarkFile
2716  * @uri: a valid URI
2717  * @error: return location for a #GError, or %NULL
2718  *
2719  * Gets the time the bookmark for @uri was last visited.
2720  *
2721  * In the event the URI cannot be found, -1 is returned and
2722  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2723  *
2724  * Returns: a timestamp.
2725  *
2726  * Since: 2.12
2727  */
2728 time_t
2729 g_bookmark_file_get_visited (GBookmarkFile  *bookmark,
<a name="118" id="anc118"></a><span class="line-modified">2730                  const gchar    *uri,</span>
<span class="line-modified">2731                  GError        **error)</span>
2732 {
2733   BookmarkItem *item;
2734 
2735   g_return_val_if_fail (bookmark != NULL, (time_t) -1);
2736   g_return_val_if_fail (uri != NULL, (time_t) -1);
2737 
2738   item = g_bookmark_file_lookup_item (bookmark, uri);
2739   if (!item)
2740     {
2741       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="119" id="anc119"></a><span class="line-modified">2742                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2743                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2744                    uri);</span>
2745       return (time_t) -1;
2746     }
2747 
2748   return item-&gt;visited;
2749 }
2750 
2751 /**
2752  * g_bookmark_file_has_group:
2753  * @bookmark: a #GBookmarkFile
2754  * @uri: a valid URI
2755  * @group: the group name to be searched
2756  * @error: return location for a #GError, or %NULL
2757  *
2758  * Checks whether @group appears in the list of groups to which
2759  * the bookmark for @uri belongs to.
2760  *
2761  * In the event the URI cannot be found, %FALSE is returned and
2762  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2763  *
2764  * Returns: %TRUE if @group was found.
2765  *
2766  * Since: 2.12
2767  */
2768 gboolean
2769 g_bookmark_file_has_group (GBookmarkFile  *bookmark,
<a name="120" id="anc120"></a><span class="line-modified">2770                const gchar    *uri,</span>
<span class="line-modified">2771                const gchar    *group,</span>
<span class="line-modified">2772                GError        **error)</span>
2773 {
2774   BookmarkItem *item;
2775   GList *l;
2776 
2777   g_return_val_if_fail (bookmark != NULL, FALSE);
2778   g_return_val_if_fail (uri != NULL, FALSE);
2779 
2780   item = g_bookmark_file_lookup_item (bookmark, uri);
2781   if (!item)
2782     {
2783       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="121" id="anc121"></a><span class="line-modified">2784                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2785                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2786                    uri);</span>
2787       return FALSE;
2788     }
2789 
2790   if (!item-&gt;metadata)
2791     return FALSE;
2792 
2793   for (l = item-&gt;metadata-&gt;groups; l != NULL; l = l-&gt;next)
2794     {
2795       if (strcmp (l-&gt;data, group) == 0)
2796         return TRUE;
2797     }
2798 
2799   return FALSE;
2800 
2801 }
2802 
2803 /**
2804  * g_bookmark_file_add_group:
2805  * @bookmark: a #GBookmarkFile
2806  * @uri: a valid URI
2807  * @group: the group name to be added
2808  *
2809  * Adds @group to the list of groups to which the bookmark for @uri
2810  * belongs to.
2811  *
2812  * If no bookmark for @uri is found then it is created.
2813  *
2814  * Since: 2.12
2815  */
2816 void
2817 g_bookmark_file_add_group (GBookmarkFile *bookmark,
<a name="122" id="anc122"></a><span class="line-modified">2818                const gchar   *uri,</span>
<span class="line-modified">2819                const gchar   *group)</span>
2820 {
2821   BookmarkItem *item;
2822 
2823   g_return_if_fail (bookmark != NULL);
2824   g_return_if_fail (uri != NULL);
2825   g_return_if_fail (group != NULL &amp;&amp; group[0] != &#39;\0&#39;);
2826 
2827   item = g_bookmark_file_lookup_item (bookmark, uri);
2828   if (!item)
2829     {
2830       item = bookmark_item_new (uri);
2831       g_bookmark_file_add_item (bookmark, item, NULL);
2832     }
2833 
2834   if (!item-&gt;metadata)
2835     item-&gt;metadata = bookmark_metadata_new ();
2836 
2837   if (!g_bookmark_file_has_group (bookmark, uri, group, NULL))
2838     {
2839       item-&gt;metadata-&gt;groups = g_list_prepend (item-&gt;metadata-&gt;groups,
2840                                                g_strdup (group));
2841 
2842       item-&gt;modified = time (NULL);
2843     }
2844 }
2845 
2846 /**
2847  * g_bookmark_file_remove_group:
2848  * @bookmark: a #GBookmarkFile
2849  * @uri: a valid URI
2850  * @group: the group name to be removed
2851  * @error: return location for a #GError, or %NULL
2852  *
2853  * Removes @group from the list of groups to which the bookmark
2854  * for @uri belongs to.
2855  *
2856  * In the event the URI cannot be found, %FALSE is returned and
2857  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2858  * In the event no group was defined, %FALSE is returned and
2859  * @error is set to #G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
2860  *
2861  * Returns: %TRUE if @group was successfully removed.
2862  *
2863  * Since: 2.12
2864  */
2865 gboolean
2866 g_bookmark_file_remove_group (GBookmarkFile  *bookmark,
<a name="123" id="anc123"></a><span class="line-modified">2867                   const gchar    *uri,</span>
<span class="line-modified">2868                   const gchar    *group,</span>
<span class="line-modified">2869                   GError        **error)</span>
2870 {
2871   BookmarkItem *item;
2872   GList *l;
2873 
2874   g_return_val_if_fail (bookmark != NULL, FALSE);
2875   g_return_val_if_fail (uri != NULL, FALSE);
2876 
2877   item = g_bookmark_file_lookup_item (bookmark, uri);
2878   if (!item)
2879     {
2880       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="124" id="anc124"></a><span class="line-modified">2881                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">2882                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">2883                    uri);</span>
2884       return FALSE;
2885     }
2886 
2887   if (!item-&gt;metadata)
2888     {
2889       g_set_error (error, G_BOOKMARK_FILE_ERROR,
2890                    G_BOOKMARK_FILE_ERROR_INVALID_VALUE,
2891                    _(&quot;No groups set in bookmark for URI &#39;%s&#39;&quot;),
2892                    uri);
2893       return FALSE;
2894     }
2895 
2896   for (l = item-&gt;metadata-&gt;groups; l != NULL; l = l-&gt;next)
2897     {
2898       if (strcmp (l-&gt;data, group) == 0)
2899         {
2900           item-&gt;metadata-&gt;groups = g_list_remove_link (item-&gt;metadata-&gt;groups, l);
2901           g_free (l-&gt;data);
<a name="125" id="anc125"></a><span class="line-modified">2902       g_list_free_1 (l);</span>
2903 
2904           item-&gt;modified = time (NULL);
2905 
2906           return TRUE;
2907         }
2908     }
2909 
2910   return FALSE;
2911 }
2912 
2913 /**
2914  * g_bookmark_file_set_groups:
2915  * @bookmark: a #GBookmarkFile
2916  * @uri: an item&#39;s URI
2917  * @groups: (nullable) (array length=length) (element-type utf8): an array of
2918  *    group names, or %NULL to remove all groups
2919  * @length: number of group name values in @groups
2920  *
2921  * Sets a list of group names for the item with URI @uri.  Each previously
2922  * set group name list is removed.
2923  *
2924  * If @uri cannot be found then an item for it is created.
2925  *
2926  * Since: 2.12
2927  */
2928 void
2929 g_bookmark_file_set_groups (GBookmarkFile  *bookmark,
<a name="126" id="anc126"></a><span class="line-modified">2930                 const gchar    *uri,</span>
<span class="line-modified">2931                 const gchar   **groups,</span>
<span class="line-modified">2932                 gsize           length)</span>
2933 {
2934   BookmarkItem *item;
2935   gsize i;
2936 
2937   g_return_if_fail (bookmark != NULL);
2938   g_return_if_fail (uri != NULL);
2939   g_return_if_fail (groups != NULL);
2940 
2941   item = g_bookmark_file_lookup_item (bookmark, uri);
2942   if (!item)
2943     {
2944       item = bookmark_item_new (uri);
2945       g_bookmark_file_add_item (bookmark, item, NULL);
2946     }
2947 
2948   if (!item-&gt;metadata)
2949     item-&gt;metadata = bookmark_metadata_new ();
2950 
2951   g_list_free_full (item-&gt;metadata-&gt;groups, g_free);
2952   item-&gt;metadata-&gt;groups = NULL;
2953 
2954   if (groups)
2955     {
2956       for (i = 0; i &lt; length &amp;&amp; groups[i] != NULL; i++)
2957         item-&gt;metadata-&gt;groups = g_list_append (item-&gt;metadata-&gt;groups,
<a name="127" id="anc127"></a><span class="line-modified">2958                             g_strdup (groups[i]));</span>
2959     }
2960 
2961   item-&gt;modified = time (NULL);
2962 }
2963 
2964 /**
2965  * g_bookmark_file_get_groups:
2966  * @bookmark: a #GBookmarkFile
2967  * @uri: a valid URI
2968  * @length: (out) (optional): return location for the length of the returned string, or %NULL
2969  * @error: return location for a #GError, or %NULL
2970  *
2971  * Retrieves the list of group names of the bookmark for @uri.
2972  *
2973  * In the event the URI cannot be found, %NULL is returned and
2974  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2975  *
2976  * The returned array is %NULL terminated, so @length may optionally
2977  * be %NULL.
2978  *
2979  * Returns: (array length=length) (transfer full): a newly allocated %NULL-terminated array of group names.
2980  *   Use g_strfreev() to free it.
2981  *
2982  * Since: 2.12
2983  */
2984 gchar **
2985 g_bookmark_file_get_groups (GBookmarkFile  *bookmark,
<a name="128" id="anc128"></a><span class="line-modified">2986                 const gchar    *uri,</span>
<span class="line-modified">2987                 gsize          *length,</span>
<span class="line-modified">2988                 GError        **error)</span>
2989 {
2990   BookmarkItem *item;
2991   GList *l;
2992   gsize len, i;
2993   gchar **retval;
2994 
2995   g_return_val_if_fail (bookmark != NULL, NULL);
2996   g_return_val_if_fail (uri != NULL, NULL);
2997 
2998   item = g_bookmark_file_lookup_item (bookmark, uri);
2999   if (!item)
3000     {
3001       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="129" id="anc129"></a><span class="line-modified">3002                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3003                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3004                    uri);</span>
3005       return NULL;
3006     }
3007 
3008   if (!item-&gt;metadata)
3009     {
3010       if (length)
<a name="130" id="anc130"></a><span class="line-modified">3011     *length = 0;</span>
3012 
3013       return NULL;
3014     }
3015 
3016   len = g_list_length (item-&gt;metadata-&gt;groups);
3017   retval = g_new0 (gchar *, len + 1);
3018   for (l = g_list_last (item-&gt;metadata-&gt;groups), i = 0;
3019        l != NULL;
3020        l = l-&gt;prev)
3021     {
3022       gchar *group_name = (gchar *) l-&gt;data;
3023 
3024       g_warn_if_fail (group_name != NULL);
3025 
3026       retval[i++] = g_strdup (group_name);
3027     }
3028   retval[i] = NULL;
3029 
3030   if (length)
3031     *length = len;
3032 
3033   return retval;
3034 }
3035 
3036 /**
3037  * g_bookmark_file_add_application:
3038  * @bookmark: a #GBookmarkFile
3039  * @uri: a valid URI
3040  * @name: (nullable): the name of the application registering the bookmark
3041  *   or %NULL
3042  * @exec: (nullable): command line to be used to launch the bookmark or %NULL
3043  *
3044  * Adds the application with @name and @exec to the list of
3045  * applications that have registered a bookmark for @uri into
3046  * @bookmark.
3047  *
3048  * Every bookmark inside a #GBookmarkFile must have at least an
3049  * application registered.  Each application must provide a name, a
3050  * command line useful for launching the bookmark, the number of times
3051  * the bookmark has been registered by the application and the last
3052  * time the application registered this bookmark.
3053  *
3054  * If @name is %NULL, the name of the application will be the
3055  * same returned by g_get_application_name(); if @exec is %NULL, the
3056  * command line will be a composition of the program name as
3057  * returned by g_get_prgname() and the &quot;\%u&quot; modifier, which will be
3058  * expanded to the bookmark&#39;s URI.
3059  *
3060  * This function will automatically take care of updating the
3061  * registrations count and timestamping in case an application
3062  * with the same @name had already registered a bookmark for
3063  * @uri inside @bookmark.
3064  *
3065  * If no bookmark for @uri is found, one is created.
3066  *
3067  * Since: 2.12
3068  */
3069 void
3070 g_bookmark_file_add_application (GBookmarkFile *bookmark,
<a name="131" id="anc131"></a><span class="line-modified">3071                  const gchar   *uri,</span>
<span class="line-modified">3072                  const gchar   *name,</span>
<span class="line-modified">3073                  const gchar   *exec)</span>
3074 {
3075   BookmarkItem *item;
3076   gchar *app_name, *app_exec;
3077 
3078   g_return_if_fail (bookmark != NULL);
3079   g_return_if_fail (uri != NULL);
3080 
3081   item = g_bookmark_file_lookup_item (bookmark, uri);
3082   if (!item)
3083     {
3084       item = bookmark_item_new (uri);
3085       g_bookmark_file_add_item (bookmark, item, NULL);
3086     }
3087 
3088   if (name &amp;&amp; name[0] != &#39;\0&#39;)
3089     app_name = g_strdup (name);
3090   else
3091     app_name = g_strdup (g_get_application_name ());
3092 
3093   if (exec &amp;&amp; exec[0] != &#39;\0&#39;)
3094     app_exec = g_strdup (exec);
3095   else
3096     app_exec = g_strjoin (&quot; &quot;, g_get_prgname(), &quot;%u&quot;, NULL);
3097 
3098   g_bookmark_file_set_app_info (bookmark, uri,
3099                                 app_name,
3100                                 app_exec,
3101                                 -1,
3102                                 (time_t) -1,
3103                                 NULL);
3104 
3105   g_free (app_exec);
3106   g_free (app_name);
3107 }
3108 
3109 /**
3110  * g_bookmark_file_remove_application:
3111  * @bookmark: a #GBookmarkFile
3112  * @uri: a valid URI
3113  * @name: the name of the application
3114  * @error: return location for a #GError or %NULL
3115  *
3116  * Removes application registered with @name from the list of applications
3117  * that have registered a bookmark for @uri inside @bookmark.
3118  *
3119  * In the event the URI cannot be found, %FALSE is returned and
3120  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3121  * In the event that no application with name @app_name has registered
3122  * a bookmark for @uri,  %FALSE is returned and error is set to
3123  * #G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.
3124  *
3125  * Returns: %TRUE if the application was successfully removed.
3126  *
3127  * Since: 2.12
3128  */
3129 gboolean
3130 g_bookmark_file_remove_application (GBookmarkFile  *bookmark,
<a name="132" id="anc132"></a><span class="line-modified">3131                     const gchar    *uri,</span>
<span class="line-modified">3132                     const gchar    *name,</span>
<span class="line-modified">3133                     GError        **error)</span>
3134 {
3135   GError *set_error;
3136   gboolean retval;
3137 
3138   g_return_val_if_fail (bookmark != NULL, FALSE);
3139   g_return_val_if_fail (uri != NULL, FALSE);
3140   g_return_val_if_fail (name != NULL, FALSE);
3141 
3142   set_error = NULL;
3143   retval = g_bookmark_file_set_app_info (bookmark, uri,
<a name="133" id="anc133"></a><span class="line-modified">3144                      name,</span>
<span class="line-modified">3145                      &quot;&quot;,</span>
<span class="line-modified">3146                      0,</span>
<span class="line-modified">3147                      (time_t) -1,</span>
<span class="line-modified">3148                      &amp;set_error);</span>
3149   if (set_error)
3150     {
3151       g_propagate_error (error, set_error);
3152 
3153       return FALSE;
3154     }
3155 
3156   return retval;
3157 }
3158 
3159 /**
3160  * g_bookmark_file_has_application:
3161  * @bookmark: a #GBookmarkFile
3162  * @uri: a valid URI
3163  * @name: the name of the application
3164  * @error: return location for a #GError or %NULL
3165  *
3166  * Checks whether the bookmark for @uri inside @bookmark has been
3167  * registered by application @name.
3168  *
3169  * In the event the URI cannot be found, %FALSE is returned and
3170  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3171  *
3172  * Returns: %TRUE if the application @name was found
3173  *
3174  * Since: 2.12
3175  */
3176 gboolean
3177 g_bookmark_file_has_application (GBookmarkFile  *bookmark,
<a name="134" id="anc134"></a><span class="line-modified">3178                  const gchar    *uri,</span>
<span class="line-modified">3179                  const gchar    *name,</span>
<span class="line-modified">3180                  GError        **error)</span>
3181 {
3182   BookmarkItem *item;
3183 
3184   g_return_val_if_fail (bookmark != NULL, FALSE);
3185   g_return_val_if_fail (uri != NULL, FALSE);
3186   g_return_val_if_fail (name != NULL, FALSE);
3187 
3188   item = g_bookmark_file_lookup_item (bookmark, uri);
3189   if (!item)
3190     {
3191       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="135" id="anc135"></a><span class="line-modified">3192                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3193                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3194                    uri);</span>
3195       return FALSE;
3196     }
3197 
3198   return (NULL != bookmark_item_lookup_app_info (item, name));
3199 }
3200 
3201 /**
3202  * g_bookmark_file_set_app_info:
3203  * @bookmark: a #GBookmarkFile
3204  * @uri: a valid URI
3205  * @name: an application&#39;s name
3206  * @exec: an application&#39;s command line
3207  * @count: the number of registrations done for this application
3208  * @stamp: the time of the last registration for this application
3209  * @error: return location for a #GError or %NULL
3210  *
3211  * Sets the meta-data of application @name inside the list of
3212  * applications that have registered a bookmark for @uri inside
3213  * @bookmark.
3214  *
3215  * You should rarely use this function; use g_bookmark_file_add_application()
3216  * and g_bookmark_file_remove_application() instead.
3217  *
3218  * @name can be any UTF-8 encoded string used to identify an
3219  * application.
3220  * @exec can have one of these two modifiers: &quot;\%f&quot;, which will
3221  * be expanded as the local file name retrieved from the bookmark&#39;s
3222  * URI; &quot;\%u&quot;, which will be expanded as the bookmark&#39;s URI.
3223  * The expansion is done automatically when retrieving the stored
3224  * command line using the g_bookmark_file_get_app_info() function.
3225  * @count is the number of times the application has registered the
3226  * bookmark; if is &lt; 0, the current registration count will be increased
3227  * by one, if is 0, the application with @name will be removed from
3228  * the list of registered applications.
3229  * @stamp is the Unix time of the last registration; if it is -1, the
3230  * current time will be used.
3231  *
3232  * If you try to remove an application by setting its registration count to
3233  * zero, and no bookmark for @uri is found, %FALSE is returned and
3234  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND; similarly,
3235  * in the event that no application @name has registered a bookmark
3236  * for @uri,  %FALSE is returned and error is set to
3237  * #G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.  Otherwise, if no bookmark
3238  * for @uri is found, one is created.
3239  *
3240  * Returns: %TRUE if the application&#39;s meta-data was successfully
3241  *   changed.
3242  *
3243  * Since: 2.12
3244  */
3245 gboolean
3246 g_bookmark_file_set_app_info (GBookmarkFile  *bookmark,
<a name="136" id="anc136"></a><span class="line-modified">3247                   const gchar    *uri,</span>
<span class="line-modified">3248                   const gchar    *name,</span>
<span class="line-modified">3249                   const gchar    *exec,</span>
<span class="line-modified">3250                   gint            count,</span>
<span class="line-modified">3251                   time_t          stamp,</span>
<span class="line-modified">3252                   GError        **error)</span>
3253 {
3254   BookmarkItem *item;
3255   BookmarkAppInfo *ai;
3256 
3257   g_return_val_if_fail (bookmark != NULL, FALSE);
3258   g_return_val_if_fail (uri != NULL, FALSE);
3259   g_return_val_if_fail (name != NULL, FALSE);
3260   g_return_val_if_fail (exec != NULL, FALSE);
3261 
3262   item = g_bookmark_file_lookup_item (bookmark, uri);
3263   if (!item)
3264     {
3265       if (count == 0)
3266         {
3267           g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="137" id="anc137"></a><span class="line-modified">3268                        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3269                        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3270                        uri);</span>
<span class="line-modified">3271       return FALSE;</span>
<span class="line-modified">3272     }</span>
3273       else
3274         {
3275           item = bookmark_item_new (uri);
<a name="138" id="anc138"></a><span class="line-modified">3276       g_bookmark_file_add_item (bookmark, item, NULL);</span>
<span class="line-modified">3277     }</span>
3278     }
3279 
3280   if (!item-&gt;metadata)
3281     item-&gt;metadata = bookmark_metadata_new ();
3282 
3283   ai = bookmark_item_lookup_app_info (item, name);
3284   if (!ai)
3285     {
3286       if (count == 0)
3287         {
3288           g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="139" id="anc139"></a><span class="line-modified">3289                        G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED,</span>
<span class="line-modified">3290                        _(&quot;No application with name &#39;%s&#39; registered a bookmark for &#39;%s&#39;&quot;),</span>
<span class="line-modified">3291                        name,</span>
<span class="line-modified">3292                        uri);</span>
3293           return FALSE;
3294         }
3295       else
3296         {
3297           ai = bookmark_app_info_new (name);
3298 #ifdef GSTREAMER_LITE
3299           if (ai == NULL) {
3300             return FALSE;
3301           }
3302 #endif // GSTREAMER_LITE
3303 
3304           item-&gt;metadata-&gt;applications = g_list_prepend (item-&gt;metadata-&gt;applications, ai);
3305           g_hash_table_replace (item-&gt;metadata-&gt;apps_by_name, ai-&gt;name, ai);
3306         }
3307     }
3308 
3309   if (count == 0)
3310     {
3311       item-&gt;metadata-&gt;applications = g_list_remove (item-&gt;metadata-&gt;applications, ai);
3312       g_hash_table_remove (item-&gt;metadata-&gt;apps_by_name, ai-&gt;name);
3313       bookmark_app_info_free (ai);
3314 
3315       item-&gt;modified = time (NULL);
3316 
3317       return TRUE;
3318     }
3319   else if (count &gt; 0)
3320     ai-&gt;count = count;
3321   else
3322     ai-&gt;count += 1;
3323 
3324   if (stamp != (time_t) -1)
3325     ai-&gt;stamp = stamp;
3326   else
3327     ai-&gt;stamp = time (NULL);
3328 
3329   if (exec &amp;&amp; exec[0] != &#39;\0&#39;)
3330     {
3331       g_free (ai-&gt;exec);
3332       ai-&gt;exec = g_shell_quote (exec);
3333     }
3334 
3335   item-&gt;modified = time (NULL);
3336 
3337   return TRUE;
3338 }
3339 
3340 /* expands the application&#39;s command line */
3341 static gchar *
3342 expand_exec_line (const gchar *exec_fmt,
<a name="140" id="anc140"></a><span class="line-modified">3343           const gchar *uri)</span>
3344 {
3345   GString *exec;
3346   gchar ch;
3347 
3348   exec = g_string_sized_new (512);
3349   while ((ch = *exec_fmt++) != &#39;\0&#39;)
3350    {
3351      if (ch != &#39;%&#39;)
3352        {
3353          exec = g_string_append_c (exec, ch);
3354          continue;
3355        }
3356 
3357      ch = *exec_fmt++;
3358      switch (ch)
3359        {
3360        case &#39;\0&#39;:
<a name="141" id="anc141"></a><span class="line-modified">3361      goto out;</span>
3362        case &#39;U&#39;:
3363        case &#39;u&#39;:
3364          g_string_append (exec, uri);
3365          break;
3366        case &#39;F&#39;:
3367        case &#39;f&#39;:
3368          {
<a name="142" id="anc142"></a><span class="line-modified">3369        gchar *file = g_filename_from_uri (uri, NULL, NULL);</span>
3370            if (file)
3371              {
<a name="143" id="anc143"></a><span class="line-modified">3372            g_string_append (exec, file);</span>
<span class="line-modified">3373            g_free (file);</span>
3374              }
3375            else
3376              {
3377                g_string_free (exec, TRUE);
3378                return NULL;
3379              }
3380          }
3381          break;
3382        case &#39;%&#39;:
3383        default:
3384          exec = g_string_append_c (exec, ch);
3385          break;
3386        }
3387    }
3388 
3389  out:
3390   return g_string_free (exec, FALSE);
3391 }
3392 
3393 /**
3394  * g_bookmark_file_get_app_info:
3395  * @bookmark: a #GBookmarkFile
3396  * @uri: a valid URI
3397  * @name: an application&#39;s name
3398  * @exec: (out) (optional): return location for the command line of the application, or %NULL
3399  * @count: (out) (optional): return location for the registration count, or %NULL
3400  * @stamp: (out) (optional): return location for the last registration time, or %NULL
3401  * @error: return location for a #GError, or %NULL
3402  *
3403  * Gets the registration information of @app_name for the bookmark for
3404  * @uri.  See g_bookmark_file_set_app_info() for more information about
3405  * the returned data.
3406  *
3407  * The string returned in @app_exec must be freed.
3408  *
3409  * In the event the URI cannot be found, %FALSE is returned and
3410  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
3411  * event that no application with name @app_name has registered a bookmark
3412  * for @uri,  %FALSE is returned and error is set to
3413  * #G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. In the event that unquoting
3414  * the command line fails, an error of the #G_SHELL_ERROR domain is
3415  * set and %FALSE is returned.
3416  *
3417  * Returns: %TRUE on success.
3418  *
3419  * Since: 2.12
3420  */
3421 gboolean
3422 g_bookmark_file_get_app_info (GBookmarkFile  *bookmark,
<a name="144" id="anc144"></a><span class="line-modified">3423                   const gchar    *uri,</span>
<span class="line-modified">3424                   const gchar    *name,</span>
<span class="line-modified">3425                   gchar         **exec,</span>
<span class="line-modified">3426                   guint          *count,</span>
<span class="line-modified">3427                   time_t         *stamp,</span>
<span class="line-modified">3428                   GError        **error)</span>
3429 {
3430   BookmarkItem *item;
3431   BookmarkAppInfo *ai;
3432 
3433   g_return_val_if_fail (bookmark != NULL, FALSE);
3434   g_return_val_if_fail (uri != NULL, FALSE);
3435   g_return_val_if_fail (name != NULL, FALSE);
3436 
3437   item = g_bookmark_file_lookup_item (bookmark, uri);
3438   if (!item)
3439     {
3440       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="145" id="anc145"></a><span class="line-modified">3441                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3442                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3443                    uri);</span>
3444       return FALSE;
3445     }
3446 
3447   ai = bookmark_item_lookup_app_info (item, name);
3448   if (!ai)
3449     {
3450       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="146" id="anc146"></a><span class="line-modified">3451                    G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED,</span>
<span class="line-modified">3452                    _(&quot;No application with name &#39;%s&#39; registered a bookmark for &#39;%s&#39;&quot;),</span>
<span class="line-modified">3453                    name,</span>
<span class="line-modified">3454                    uri);</span>
3455       return FALSE;
3456     }
3457 
3458   if (exec)
3459     {
3460       GError *unquote_error = NULL;
3461       gchar *command_line;
3462 
3463       command_line = g_shell_unquote (ai-&gt;exec, &amp;unquote_error);
3464       if (unquote_error)
3465         {
3466           g_propagate_error (error, unquote_error);
3467           return FALSE;
3468         }
3469 
3470       *exec = expand_exec_line (command_line, uri);
3471       if (!*exec)
3472         {
3473           g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="147" id="anc147"></a><span class="line-modified">3474                        G_BOOKMARK_FILE_ERROR_INVALID_URI,</span>
<span class="line-modified">3475                        _(&quot;Failed to expand exec line &#39;%s&#39; with URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3476                        ai-&gt;exec, uri);</span>
3477           g_free (command_line);
3478 
3479           return FALSE;
3480         }
3481       else
3482         g_free (command_line);
3483     }
3484 
3485   if (count)
3486     *count = ai-&gt;count;
3487 
3488   if (stamp)
3489     *stamp = ai-&gt;stamp;
3490 
3491   return TRUE;
3492 }
3493 
3494 /**
3495  * g_bookmark_file_get_applications:
3496  * @bookmark: a #GBookmarkFile
3497  * @uri: a valid URI
3498  * @length: (out) (optional): return location of the length of the returned list, or %NULL
3499  * @error: return location for a #GError, or %NULL
3500  *
3501  * Retrieves the names of the applications that have registered the
3502  * bookmark for @uri.
3503  *
3504  * In the event the URI cannot be found, %NULL is returned and
3505  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3506  *
3507  * Returns: (array length=length) (transfer full): a newly allocated %NULL-terminated array of strings.
3508  *   Use g_strfreev() to free it.
3509  *
3510  * Since: 2.12
3511  */
3512 gchar **
3513 g_bookmark_file_get_applications (GBookmarkFile  *bookmark,
<a name="148" id="anc148"></a><span class="line-modified">3514                   const gchar    *uri,</span>
<span class="line-modified">3515                   gsize          *length,</span>
<span class="line-modified">3516                   GError        **error)</span>
3517 {
3518   BookmarkItem *item;
3519   GList *l;
3520   gchar **apps;
3521   gsize i, n_apps;
3522 
3523   g_return_val_if_fail (bookmark != NULL, NULL);
3524   g_return_val_if_fail (uri != NULL, NULL);
3525 
3526   item = g_bookmark_file_lookup_item (bookmark, uri);
3527   if (!item)
3528     {
3529       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="149" id="anc149"></a><span class="line-modified">3530                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3531                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3532                    uri);</span>
3533       return NULL;
3534     }
3535 
3536   if (!item-&gt;metadata)
3537     {
3538       if (length)
<a name="150" id="anc150"></a><span class="line-modified">3539     *length = 0;</span>
3540 
3541       return NULL;
3542     }
3543 
3544   n_apps = g_list_length (item-&gt;metadata-&gt;applications);
3545   apps = g_new0 (gchar *, n_apps + 1);
3546 
3547   for (l = g_list_last (item-&gt;metadata-&gt;applications), i = 0;
3548        l != NULL;
3549        l = l-&gt;prev)
3550     {
3551       BookmarkAppInfo *ai;
3552 
3553       ai = (BookmarkAppInfo *) l-&gt;data;
3554 
3555       g_warn_if_fail (ai != NULL);
3556       g_warn_if_fail (ai-&gt;name != NULL);
3557 
3558       apps[i++] = g_strdup (ai-&gt;name);
3559     }
3560   apps[i] = NULL;
3561 
3562   if (length)
3563     *length = i;
3564 
3565   return apps;
3566 }
3567 
3568 /**
3569  * g_bookmark_file_get_size:
3570  * @bookmark: a #GBookmarkFile
3571  *
3572  * Gets the number of bookmarks inside @bookmark.
3573  *
3574  * Returns: the number of bookmarks
3575  *
3576  * Since: 2.12
3577  */
3578 gint
3579 g_bookmark_file_get_size (GBookmarkFile *bookmark)
3580 {
3581   g_return_val_if_fail (bookmark != NULL, 0);
3582 
3583   return g_list_length (bookmark-&gt;items);
3584 }
3585 
3586 /**
3587  * g_bookmark_file_move_item:
3588  * @bookmark: a #GBookmarkFile
3589  * @old_uri: a valid URI
3590  * @new_uri: (nullable): a valid URI, or %NULL
3591  * @error: return location for a #GError or %NULL
3592  *
3593  * Changes the URI of a bookmark item from @old_uri to @new_uri.  Any
3594  * existing bookmark for @new_uri will be overwritten.  If @new_uri is
3595  * %NULL, then the bookmark is removed.
3596  *
3597  * In the event the URI cannot be found, %FALSE is returned and
3598  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3599  *
3600  * Returns: %TRUE if the URI was successfully changed
3601  *
3602  * Since: 2.12
3603  */
3604 gboolean
3605 g_bookmark_file_move_item (GBookmarkFile  *bookmark,
<a name="151" id="anc151"></a><span class="line-modified">3606                const gchar    *old_uri,</span>
<span class="line-modified">3607                const gchar    *new_uri,</span>
<span class="line-modified">3608                GError        **error)</span>
3609 {
3610   BookmarkItem *item;
3611 
3612   g_return_val_if_fail (bookmark != NULL, FALSE);
3613   g_return_val_if_fail (old_uri != NULL, FALSE);
3614 
3615   item = g_bookmark_file_lookup_item (bookmark, old_uri);
3616   if (!item)
3617     {
3618       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="152" id="anc152"></a><span class="line-modified">3619                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3620                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3621                    old_uri);</span>
3622       return FALSE;
3623     }
3624 
3625   if (new_uri &amp;&amp; new_uri[0] != &#39;\0&#39;)
3626     {
3627       if (g_strcmp0 (old_uri, new_uri) == 0)
3628         return TRUE;
3629 
3630       if (g_bookmark_file_has_item (bookmark, new_uri))
3631         {
3632           if (!g_bookmark_file_remove_item (bookmark, new_uri, error))
3633             return FALSE;
3634         }
3635 
3636       g_hash_table_steal (bookmark-&gt;items_by_uri, item-&gt;uri);
3637 
3638       g_free (item-&gt;uri);
3639       item-&gt;uri = g_strdup (new_uri);
3640       item-&gt;modified = time (NULL);
3641 
3642       g_hash_table_replace (bookmark-&gt;items_by_uri, item-&gt;uri, item);
3643 
3644       return TRUE;
3645     }
3646   else
3647     {
3648       if (!g_bookmark_file_remove_item (bookmark, old_uri, error))
3649         return FALSE;
3650 
3651       return TRUE;
3652     }
3653 }
3654 
3655 /**
3656  * g_bookmark_file_set_icon:
3657  * @bookmark: a #GBookmarkFile
3658  * @uri: a valid URI
3659  * @href: (nullable): the URI of the icon for the bookmark, or %NULL
3660  * @mime_type: the MIME type of the icon for the bookmark
3661  *
3662  * Sets the icon for the bookmark for @uri. If @href is %NULL, unsets
3663  * the currently set icon. @href can either be a full URL for the icon
3664  * file or the icon name following the Icon Naming specification.
3665  *
3666  * If no bookmark for @uri is found one is created.
3667  *
3668  * Since: 2.12
3669  */
3670 void
3671 g_bookmark_file_set_icon (GBookmarkFile *bookmark,
<a name="153" id="anc153"></a><span class="line-modified">3672               const gchar   *uri,</span>
<span class="line-modified">3673               const gchar   *href,</span>
<span class="line-modified">3674               const gchar   *mime_type)</span>
3675 {
3676   BookmarkItem *item;
3677 
3678   g_return_if_fail (bookmark != NULL);
3679   g_return_if_fail (uri != NULL);
3680 
3681   item = g_bookmark_file_lookup_item (bookmark, uri);
3682   if (!item)
3683     {
3684       item = bookmark_item_new (uri);
3685       g_bookmark_file_add_item (bookmark, item, NULL);
3686     }
3687 
3688   if (!item-&gt;metadata)
3689     item-&gt;metadata = bookmark_metadata_new ();
3690 
3691   g_free (item-&gt;metadata-&gt;icon_href);
3692   g_free (item-&gt;metadata-&gt;icon_mime);
3693 
3694   item-&gt;metadata-&gt;icon_href = g_strdup (href);
3695 
3696   if (mime_type &amp;&amp; mime_type[0] != &#39;\0&#39;)
3697     item-&gt;metadata-&gt;icon_mime = g_strdup (mime_type);
3698   else
3699     item-&gt;metadata-&gt;icon_mime = g_strdup (&quot;application/octet-stream&quot;);
3700 
3701   item-&gt;modified = time (NULL);
3702 }
3703 
3704 /**
3705  * g_bookmark_file_get_icon:
3706  * @bookmark: a #GBookmarkFile
3707  * @uri: a valid URI
3708  * @href: (out) (optional): return location for the icon&#39;s location or %NULL
3709  * @mime_type: (out) (optional): return location for the icon&#39;s MIME type or %NULL
3710  * @error: return location for a #GError or %NULL
3711  *
3712  * Gets the icon of the bookmark for @uri.
3713  *
3714  * In the event the URI cannot be found, %FALSE is returned and
3715  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3716  *
3717  * Returns: %TRUE if the icon for the bookmark for the URI was found.
3718  *   You should free the returned strings.
3719  *
3720  * Since: 2.12
3721  */
3722 gboolean
3723 g_bookmark_file_get_icon (GBookmarkFile  *bookmark,
<a name="154" id="anc154"></a><span class="line-modified">3724               const gchar    *uri,</span>
<span class="line-modified">3725               gchar         **href,</span>
<span class="line-modified">3726               gchar         **mime_type,</span>
<span class="line-modified">3727               GError        **error)</span>
3728 {
3729   BookmarkItem *item;
3730 
3731   g_return_val_if_fail (bookmark != NULL, FALSE);
3732   g_return_val_if_fail (uri != NULL, FALSE);
3733 
3734   item = g_bookmark_file_lookup_item (bookmark, uri);
3735   if (!item)
3736     {
3737       g_set_error (error, G_BOOKMARK_FILE_ERROR,
<a name="155" id="anc155"></a><span class="line-modified">3738                    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,</span>
<span class="line-modified">3739                    _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),</span>
<span class="line-modified">3740                    uri);</span>
3741       return FALSE;
3742     }
3743 
3744   if ((!item-&gt;metadata) || (!item-&gt;metadata-&gt;icon_href))
3745     return FALSE;
3746 
3747   if (href)
3748     *href = g_strdup (item-&gt;metadata-&gt;icon_href);
3749 
3750   if (mime_type)
3751     *mime_type = g_strdup (item-&gt;metadata-&gt;icon_mime);
3752 
3753   return TRUE;
3754 }
<a name="156" id="anc156"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="156" type="hidden" />
</body>
</html>