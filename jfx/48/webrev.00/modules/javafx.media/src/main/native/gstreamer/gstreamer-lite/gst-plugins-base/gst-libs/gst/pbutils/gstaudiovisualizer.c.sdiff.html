<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/pbutils/gstaudiovisualizer.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="descriptions.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstaudiovisualizer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/pbutils/gstaudiovisualizer.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   5  * gstaudiovisualizer.h: base class for audio visualisation elements
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 /**
  23  * SECTION:gstaudiovisualizer
  24  * @title: GstAudioVisualizer

  25  *
  26  * A baseclass for scopes (visualizers). It takes care of re-fitting the
  27  * audio-rate to video-rate and handles renegotiation (downstream video size
  28  * changes).
  29  *
  30  * It also provides several background shading effects. These effects are
  31  * applied to a previous picture before the render() implementation can draw a
  32  * new frame.
  33  */
  34 
  35 #ifdef HAVE_CONFIG_H
  36 #include &quot;config.h&quot;
  37 #endif
  38 
  39 #include &lt;string.h&gt;
  40 
  41 #include &lt;gst/video/video.h&gt;
  42 #include &lt;gst/video/gstvideometa.h&gt;
  43 #include &lt;gst/video/gstvideopool.h&gt;
  44 
  45 #include &quot;gstaudiovisualizer.h&quot;
  46 #include &quot;pbutils-enumtypes.h&quot;
  47 
  48 GST_DEBUG_CATEGORY_STATIC (audio_visualizer_debug);
  49 #define GST_CAT_DEFAULT (audio_visualizer_debug)
  50 
  51 #define DEFAULT_SHADER GST_AUDIO_VISUALIZER_SHADER_FADE
  52 #define DEFAULT_SHADE_AMOUNT   0x000a0a0a
  53 
  54 enum
  55 {
  56   PROP_0,
  57   PROP_SHADER,
  58   PROP_SHADE_AMOUNT
  59 };
  60 
  61 static GstBaseTransformClass *parent_class = NULL;

  62 
  63 static void gst_audio_visualizer_class_init (GstAudioVisualizerClass * klass);
  64 static void gst_audio_visualizer_init (GstAudioVisualizer * scope,
  65     GstAudioVisualizerClass * g_class);
  66 static void gst_audio_visualizer_set_property (GObject * object,
  67     guint prop_id, const GValue * value, GParamSpec * pspec);
  68 static void gst_audio_visualizer_get_property (GObject * object,
  69     guint prop_id, GValue * value, GParamSpec * pspec);
  70 static void gst_audio_visualizer_dispose (GObject * object);
  71 
  72 static gboolean gst_audio_visualizer_src_negotiate (GstAudioVisualizer * scope);
  73 static gboolean gst_audio_visualizer_src_setcaps (GstAudioVisualizer *
  74     scope, GstCaps * caps);
  75 static gboolean gst_audio_visualizer_sink_setcaps (GstAudioVisualizer *
  76     scope, GstCaps * caps);
  77 
  78 static GstFlowReturn gst_audio_visualizer_chain (GstPad * pad,
  79     GstObject * parent, GstBuffer * buffer);
  80 
  81 static gboolean gst_audio_visualizer_src_event (GstPad * pad,
  82     GstObject * parent, GstEvent * event);
  83 static gboolean gst_audio_visualizer_sink_event (GstPad * pad,
  84     GstObject * parent, GstEvent * event);
  85 
  86 static gboolean gst_audio_visualizer_src_query (GstPad * pad,
  87     GstObject * parent, GstQuery * query);
  88 
  89 static GstStateChangeReturn gst_audio_visualizer_change_state (GstElement *
  90     element, GstStateChange transition);
  91 
  92 static gboolean gst_audio_visualizer_do_bufferpool (GstAudioVisualizer * scope,
  93     GstCaps * outcaps);
  94 
  95 static gboolean
  96 default_decide_allocation (GstAudioVisualizer * scope, GstQuery * query);
  97 
<span class="line-removed">  98 #define GST_AUDIO_VISUALIZER_GET_PRIVATE(obj)  \</span>
<span class="line-removed">  99     (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_AUDIO_VISUALIZER, GstAudioVisualizerPrivate))</span>
<span class="line-removed"> 100 </span>
 101 struct _GstAudioVisualizerPrivate
 102 {
 103   gboolean negotiated;
 104 
 105   GstBufferPool *pool;
 106   gboolean pool_active;
 107   GstAllocator *allocator;
 108   GstAllocationParams params;
 109   GstQuery *query;
 110 
 111   /* pads */
 112   GstPad *srcpad, *sinkpad;
 113 
 114   GstAudioVisualizerShader shader_type;
 115   GstAudioVisualizerShaderFunc shader;
 116   guint32 shade_amount;
 117 
 118   GstAdapter *adapter;
 119 
 120   GstBuffer *inbuf;
</pre>
<hr />
<pre>
 502 {
 503   static volatile gsize audio_visualizer_type = 0;
 504 
 505   if (g_once_init_enter (&amp;audio_visualizer_type)) {
 506     static const GTypeInfo audio_visualizer_info = {
 507       sizeof (GstAudioVisualizerClass),
 508       NULL,
 509       NULL,
 510       (GClassInitFunc) gst_audio_visualizer_class_init,
 511       NULL,
 512       NULL,
 513       sizeof (GstAudioVisualizer),
 514       0,
 515       (GInstanceInitFunc) gst_audio_visualizer_init,
 516     };
 517     GType _type;
 518 
 519     /* TODO: rename when exporting it as a library */
 520     _type = g_type_register_static (GST_TYPE_ELEMENT,
 521         &quot;GstAudioVisualizer&quot;, &amp;audio_visualizer_info, G_TYPE_FLAG_ABSTRACT);




 522     g_once_init_leave (&amp;audio_visualizer_type, _type);
 523   }
 524   return (GType) audio_visualizer_type;
 525 }
 526 






 527 static void
 528 gst_audio_visualizer_class_init (GstAudioVisualizerClass * klass)
 529 {
 530   GObjectClass *gobject_class = (GObjectClass *) klass;
 531   GstElementClass *element_class = (GstElementClass *) klass;
 532 
<span class="line-modified"> 533   g_type_class_add_private (klass, sizeof (GstAudioVisualizerPrivate));</span>

 534 
 535   parent_class = g_type_class_peek_parent (klass);
 536 
 537   GST_DEBUG_CATEGORY_INIT (audio_visualizer_debug,
 538       &quot;baseaudiovisualizer-libvisual&quot;, 0,
 539       &quot;scope audio visualisation base class&quot;);
 540 
 541   gobject_class-&gt;set_property = gst_audio_visualizer_set_property;
 542   gobject_class-&gt;get_property = gst_audio_visualizer_get_property;
 543   gobject_class-&gt;dispose = gst_audio_visualizer_dispose;
 544 
 545   element_class-&gt;change_state =
 546       GST_DEBUG_FUNCPTR (gst_audio_visualizer_change_state);
 547 
 548   klass-&gt;decide_allocation = GST_DEBUG_FUNCPTR (default_decide_allocation);
 549 
 550   g_object_class_install_property (gobject_class, PROP_SHADER,
 551       g_param_spec_enum (&quot;shader&quot;, &quot;shader type&quot;,
 552           &quot;Shader function to apply on each frame&quot;,
 553           GST_TYPE_AUDIO_VISUALIZER_SHADER, DEFAULT_SHADER,
 554           G_PARAM_READWRITE | GST_PARAM_CONTROLLABLE | G_PARAM_STATIC_STRINGS));
 555   g_object_class_install_property (gobject_class, PROP_SHADE_AMOUNT,
 556       g_param_spec_uint (&quot;shade-amount&quot;, &quot;shade amount&quot;,
 557           &quot;Shading color to use (big-endian ARGB)&quot;, 0, G_MAXUINT32,
 558           DEFAULT_SHADE_AMOUNT,
 559           G_PARAM_READWRITE | GST_PARAM_CONTROLLABLE | G_PARAM_STATIC_STRINGS));
 560 }
 561 
 562 static void
 563 gst_audio_visualizer_init (GstAudioVisualizer * scope,
 564     GstAudioVisualizerClass * g_class)
 565 {
 566   GstPadTemplate *pad_template;
 567 
<span class="line-modified"> 568   scope-&gt;priv = GST_AUDIO_VISUALIZER_GET_PRIVATE (scope);</span>
 569 
 570   /* create the sink and src pads */
 571   pad_template =
 572       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (g_class), &quot;sink&quot;);
 573   g_return_if_fail (pad_template != NULL);
 574   scope-&gt;priv-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 575   gst_pad_set_chain_function (scope-&gt;priv-&gt;sinkpad,
 576       GST_DEBUG_FUNCPTR (gst_audio_visualizer_chain));
 577   gst_pad_set_event_function (scope-&gt;priv-&gt;sinkpad,
 578       GST_DEBUG_FUNCPTR (gst_audio_visualizer_sink_event));
 579   gst_element_add_pad (GST_ELEMENT (scope), scope-&gt;priv-&gt;sinkpad);
 580 
 581   pad_template =
 582       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (g_class), &quot;src&quot;);
 583   g_return_if_fail (pad_template != NULL);
 584   scope-&gt;priv-&gt;srcpad = gst_pad_new_from_template (pad_template, &quot;src&quot;);
 585   gst_pad_set_event_function (scope-&gt;priv-&gt;srcpad,
 586       GST_DEBUG_FUNCPTR (gst_audio_visualizer_src_event));
 587   gst_pad_set_query_function (scope-&gt;priv-&gt;srcpad,
 588       GST_DEBUG_FUNCPTR (gst_audio_visualizer_src_query));
</pre>
</td>
<td>
<hr />
<pre>
   5  * gstaudiovisualizer.h: base class for audio visualisation elements
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 /**
  23  * SECTION:gstaudiovisualizer
  24  * @title: GstAudioVisualizer
<span class="line-added">  25  * @short_description: Base class for visualizers.</span>
  26  *
  27  * A baseclass for scopes (visualizers). It takes care of re-fitting the
  28  * audio-rate to video-rate and handles renegotiation (downstream video size
  29  * changes).
  30  *
  31  * It also provides several background shading effects. These effects are
  32  * applied to a previous picture before the render() implementation can draw a
  33  * new frame.
  34  */
  35 
  36 #ifdef HAVE_CONFIG_H
  37 #include &quot;config.h&quot;
  38 #endif
  39 
  40 #include &lt;string.h&gt;
  41 
  42 #include &lt;gst/video/video.h&gt;
  43 #include &lt;gst/video/gstvideometa.h&gt;
  44 #include &lt;gst/video/gstvideopool.h&gt;
  45 
  46 #include &quot;gstaudiovisualizer.h&quot;
  47 #include &quot;pbutils-enumtypes.h&quot;
  48 
  49 GST_DEBUG_CATEGORY_STATIC (audio_visualizer_debug);
  50 #define GST_CAT_DEFAULT (audio_visualizer_debug)
  51 
  52 #define DEFAULT_SHADER GST_AUDIO_VISUALIZER_SHADER_FADE
  53 #define DEFAULT_SHADE_AMOUNT   0x000a0a0a
  54 
  55 enum
  56 {
  57   PROP_0,
  58   PROP_SHADER,
  59   PROP_SHADE_AMOUNT
  60 };
  61 
  62 static GstBaseTransformClass *parent_class = NULL;
<span class="line-added">  63 static gint private_offset = 0;</span>
  64 
  65 static void gst_audio_visualizer_class_init (GstAudioVisualizerClass * klass);
  66 static void gst_audio_visualizer_init (GstAudioVisualizer * scope,
  67     GstAudioVisualizerClass * g_class);
  68 static void gst_audio_visualizer_set_property (GObject * object,
  69     guint prop_id, const GValue * value, GParamSpec * pspec);
  70 static void gst_audio_visualizer_get_property (GObject * object,
  71     guint prop_id, GValue * value, GParamSpec * pspec);
  72 static void gst_audio_visualizer_dispose (GObject * object);
  73 
  74 static gboolean gst_audio_visualizer_src_negotiate (GstAudioVisualizer * scope);
  75 static gboolean gst_audio_visualizer_src_setcaps (GstAudioVisualizer *
  76     scope, GstCaps * caps);
  77 static gboolean gst_audio_visualizer_sink_setcaps (GstAudioVisualizer *
  78     scope, GstCaps * caps);
  79 
  80 static GstFlowReturn gst_audio_visualizer_chain (GstPad * pad,
  81     GstObject * parent, GstBuffer * buffer);
  82 
  83 static gboolean gst_audio_visualizer_src_event (GstPad * pad,
  84     GstObject * parent, GstEvent * event);
  85 static gboolean gst_audio_visualizer_sink_event (GstPad * pad,
  86     GstObject * parent, GstEvent * event);
  87 
  88 static gboolean gst_audio_visualizer_src_query (GstPad * pad,
  89     GstObject * parent, GstQuery * query);
  90 
  91 static GstStateChangeReturn gst_audio_visualizer_change_state (GstElement *
  92     element, GstStateChange transition);
  93 
  94 static gboolean gst_audio_visualizer_do_bufferpool (GstAudioVisualizer * scope,
  95     GstCaps * outcaps);
  96 
  97 static gboolean
  98 default_decide_allocation (GstAudioVisualizer * scope, GstQuery * query);
  99 



 100 struct _GstAudioVisualizerPrivate
 101 {
 102   gboolean negotiated;
 103 
 104   GstBufferPool *pool;
 105   gboolean pool_active;
 106   GstAllocator *allocator;
 107   GstAllocationParams params;
 108   GstQuery *query;
 109 
 110   /* pads */
 111   GstPad *srcpad, *sinkpad;
 112 
 113   GstAudioVisualizerShader shader_type;
 114   GstAudioVisualizerShaderFunc shader;
 115   guint32 shade_amount;
 116 
 117   GstAdapter *adapter;
 118 
 119   GstBuffer *inbuf;
</pre>
<hr />
<pre>
 501 {
 502   static volatile gsize audio_visualizer_type = 0;
 503 
 504   if (g_once_init_enter (&amp;audio_visualizer_type)) {
 505     static const GTypeInfo audio_visualizer_info = {
 506       sizeof (GstAudioVisualizerClass),
 507       NULL,
 508       NULL,
 509       (GClassInitFunc) gst_audio_visualizer_class_init,
 510       NULL,
 511       NULL,
 512       sizeof (GstAudioVisualizer),
 513       0,
 514       (GInstanceInitFunc) gst_audio_visualizer_init,
 515     };
 516     GType _type;
 517 
 518     /* TODO: rename when exporting it as a library */
 519     _type = g_type_register_static (GST_TYPE_ELEMENT,
 520         &quot;GstAudioVisualizer&quot;, &amp;audio_visualizer_info, G_TYPE_FLAG_ABSTRACT);
<span class="line-added"> 521 </span>
<span class="line-added"> 522     private_offset =</span>
<span class="line-added"> 523         g_type_add_instance_private (_type, sizeof (GstAudioVisualizerPrivate));</span>
<span class="line-added"> 524 </span>
 525     g_once_init_leave (&amp;audio_visualizer_type, _type);
 526   }
 527   return (GType) audio_visualizer_type;
 528 }
 529 
<span class="line-added"> 530 static inline GstAudioVisualizerPrivate *</span>
<span class="line-added"> 531 gst_audio_visualizer_get_instance_private (GstAudioVisualizer * self)</span>
<span class="line-added"> 532 {</span>
<span class="line-added"> 533   return (G_STRUCT_MEMBER_P (self, private_offset));</span>
<span class="line-added"> 534 }</span>
<span class="line-added"> 535 </span>
 536 static void
 537 gst_audio_visualizer_class_init (GstAudioVisualizerClass * klass)
 538 {
 539   GObjectClass *gobject_class = (GObjectClass *) klass;
 540   GstElementClass *element_class = (GstElementClass *) klass;
 541 
<span class="line-modified"> 542   if (private_offset != 0)</span>
<span class="line-added"> 543     g_type_class_adjust_private_offset (klass, &amp;private_offset);</span>
 544 
 545   parent_class = g_type_class_peek_parent (klass);
 546 
 547   GST_DEBUG_CATEGORY_INIT (audio_visualizer_debug,
 548       &quot;baseaudiovisualizer-libvisual&quot;, 0,
 549       &quot;scope audio visualisation base class&quot;);
 550 
 551   gobject_class-&gt;set_property = gst_audio_visualizer_set_property;
 552   gobject_class-&gt;get_property = gst_audio_visualizer_get_property;
 553   gobject_class-&gt;dispose = gst_audio_visualizer_dispose;
 554 
 555   element_class-&gt;change_state =
 556       GST_DEBUG_FUNCPTR (gst_audio_visualizer_change_state);
 557 
 558   klass-&gt;decide_allocation = GST_DEBUG_FUNCPTR (default_decide_allocation);
 559 
 560   g_object_class_install_property (gobject_class, PROP_SHADER,
 561       g_param_spec_enum (&quot;shader&quot;, &quot;shader type&quot;,
 562           &quot;Shader function to apply on each frame&quot;,
 563           GST_TYPE_AUDIO_VISUALIZER_SHADER, DEFAULT_SHADER,
 564           G_PARAM_READWRITE | GST_PARAM_CONTROLLABLE | G_PARAM_STATIC_STRINGS));
 565   g_object_class_install_property (gobject_class, PROP_SHADE_AMOUNT,
 566       g_param_spec_uint (&quot;shade-amount&quot;, &quot;shade amount&quot;,
 567           &quot;Shading color to use (big-endian ARGB)&quot;, 0, G_MAXUINT32,
 568           DEFAULT_SHADE_AMOUNT,
 569           G_PARAM_READWRITE | GST_PARAM_CONTROLLABLE | G_PARAM_STATIC_STRINGS));
 570 }
 571 
 572 static void
 573 gst_audio_visualizer_init (GstAudioVisualizer * scope,
 574     GstAudioVisualizerClass * g_class)
 575 {
 576   GstPadTemplate *pad_template;
 577 
<span class="line-modified"> 578   scope-&gt;priv = gst_audio_visualizer_get_instance_private (scope);</span>
 579 
 580   /* create the sink and src pads */
 581   pad_template =
 582       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (g_class), &quot;sink&quot;);
 583   g_return_if_fail (pad_template != NULL);
 584   scope-&gt;priv-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 585   gst_pad_set_chain_function (scope-&gt;priv-&gt;sinkpad,
 586       GST_DEBUG_FUNCPTR (gst_audio_visualizer_chain));
 587   gst_pad_set_event_function (scope-&gt;priv-&gt;sinkpad,
 588       GST_DEBUG_FUNCPTR (gst_audio_visualizer_sink_event));
 589   gst_element_add_pad (GST_ELEMENT (scope), scope-&gt;priv-&gt;sinkpad);
 590 
 591   pad_template =
 592       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (g_class), &quot;src&quot;);
 593   g_return_if_fail (pad_template != NULL);
 594   scope-&gt;priv-&gt;srcpad = gst_pad_new_from_template (pad_template, &quot;src&quot;);
 595   gst_pad_set_event_function (scope-&gt;priv-&gt;srcpad,
 596       GST_DEBUG_FUNCPTR (gst_audio_visualizer_src_event));
 597   gst_pad_set_query_function (scope-&gt;priv-&gt;srcpad,
 598       GST_DEBUG_FUNCPTR (gst_audio_visualizer_src_query));
</pre>
</td>
</tr>
</table>
<center><a href="descriptions.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstaudiovisualizer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>