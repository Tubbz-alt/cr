<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmarkup.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* gmarkup.c - Simple XML-like parser
   2  *
   3  *  Copyright 2000, 2003 Red Hat, Inc.
   4  *  Copyright 2007, 2008 Ryan Lortie &lt;desrt@desrt.ca&gt;
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Lesser General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2.1 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Lesser General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Lesser General Public License
  17  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  18  */
  19 
  20 #include &quot;config.h&quot;
  21 
  22 #include &lt;stdarg.h&gt;
  23 #include &lt;string.h&gt;
  24 #include &lt;stdio.h&gt;
  25 #include &lt;stdlib.h&gt;
  26 #include &lt;errno.h&gt;
  27 
  28 #include &quot;gmarkup.h&quot;
  29 
  30 #include &quot;gatomic.h&quot;
  31 #include &quot;gslice.h&quot;
  32 #include &quot;galloca.h&quot;
  33 #include &quot;gstrfuncs.h&quot;
  34 #include &quot;gstring.h&quot;
  35 #include &quot;gtestutils.h&quot;
  36 #include &quot;glibintl.h&quot;
  37 #include &quot;gthread.h&quot;
<a name="1" id="anc1"></a><span class="line-removed">  38 #include &quot;gunicodeprivate.h&quot;</span>
  39 
  40 /**
  41  * SECTION:markup
  42  * @Title: Simple XML Subset Parser
  43  * @Short_description: parses a subset of XML
  44  * @See_also: [XML Specification](http://www.w3.org/TR/REC-xml/)
  45  *
  46  * The &quot;GMarkup&quot; parser is intended to parse a simple markup format
  47  * that&#39;s a subset of XML. This is a small, efficient, easy-to-use
  48  * parser. It should not be used if you expect to interoperate with
<a name="2" id="anc2"></a><span class="line-modified">  49  * other applications generating full-scale XML. However, it&#39;s very</span>

  50  * useful for application data files, config files, etc. where you
  51  * know your application will be the only one writing the file.
  52  * Full-scale XML parsers should be able to parse the subset used by
  53  * GMarkup, so you can easily migrate to full-scale XML at a later
  54  * time if the need arises.
  55  *
  56  * GMarkup is not guaranteed to signal an error on all invalid XML;
  57  * the parser may accept documents that an XML parser would not.
  58  * However, XML documents which are not well-formed (which is a
  59  * weaker condition than being valid. See the
  60  * [XML specification](http://www.w3.org/TR/REC-xml/)
  61  * for definitions of these terms.) are not considered valid GMarkup
  62  * documents.
  63  *
  64  * Simplifications to XML include:
  65  *
  66  * - Only UTF-8 encoding is allowed
  67  *
  68  * - No user-defined entities
  69  *
  70  * - Processing instructions, comments and the doctype declaration
  71  *   are &quot;passed through&quot; but are not interpreted in any way
  72  *
  73  * - No DTD or validation
  74  *
  75  * The markup format does support:
  76  *
  77  * - Elements
  78  *
  79  * - Attributes
  80  *
  81  * - 5 standard entities: &amp;amp; &amp;lt; &amp;gt; &amp;quot; &amp;apos;
  82  *
  83  * - Character references
  84  *
  85  * - Sections marked as CDATA
  86  */
  87 
  88 G_DEFINE_QUARK (g-markup-error-quark, g_markup_error)
  89 
  90 typedef enum
  91 {
  92   STATE_START,
  93   STATE_AFTER_OPEN_ANGLE,
  94   STATE_AFTER_CLOSE_ANGLE,
  95   STATE_AFTER_ELISION_SLASH, /* the slash that obviates need for end element */
  96   STATE_INSIDE_OPEN_TAG_NAME,
  97   STATE_INSIDE_ATTRIBUTE_NAME,
  98   STATE_AFTER_ATTRIBUTE_NAME,
  99   STATE_BETWEEN_ATTRIBUTES,
 100   STATE_AFTER_ATTRIBUTE_EQUALS_SIGN,
 101   STATE_INSIDE_ATTRIBUTE_VALUE_SQ,
 102   STATE_INSIDE_ATTRIBUTE_VALUE_DQ,
 103   STATE_INSIDE_TEXT,
 104   STATE_AFTER_CLOSE_TAG_SLASH,
 105   STATE_INSIDE_CLOSE_TAG_NAME,
 106   STATE_AFTER_CLOSE_TAG_NAME,
 107   STATE_INSIDE_PASSTHROUGH,
 108   STATE_ERROR
 109 } GMarkupParseState;
 110 
 111 typedef struct
 112 {
 113   const char *prev_element;
 114   const GMarkupParser *prev_parser;
 115   gpointer prev_user_data;
 116 } GMarkupRecursionTracker;
 117 
 118 struct _GMarkupParseContext
 119 {
 120   const GMarkupParser *parser;
 121 
 122   volatile gint ref_count;
 123 
 124   GMarkupParseFlags flags;
 125 
 126   gint line_number;
 127   gint char_number;
 128 
 129   GMarkupParseState state;
 130 
 131   gpointer user_data;
 132   GDestroyNotify dnotify;
 133 
 134   /* A piece of character data or an element that
 135    * hasn&#39;t &quot;ended&quot; yet so we haven&#39;t yet called
 136    * the callback for it.
 137    */
 138   GString *partial_chunk;
 139   GSList *spare_chunks;
 140 
 141   GSList *tag_stack;
 142   GSList *tag_stack_gstr;
 143   GSList *spare_list_nodes;
 144 
 145   GString **attr_names;
 146   GString **attr_values;
 147   gint cur_attr;
 148   gint alloc_attrs;
 149 
 150   const gchar *current_text;
 151   gssize       current_text_len;
 152   const gchar *current_text_end;
 153 
 154   /* used to save the start of the last interesting thingy */
 155   const gchar *start;
 156 
 157   const gchar *iter;
 158 
 159   guint document_empty : 1;
 160   guint parsing : 1;
 161   guint awaiting_pop : 1;
 162   gint balance;
 163 
 164   /* subparser support */
 165   GSList *subparser_stack; /* (GMarkupRecursionTracker *) */
 166   const char *subparser_element;
 167   gpointer held_user_data;
 168 };
 169 
 170 /*
 171  * Helpers to reduce our allocation overhead, we have
 172  * a well defined allocation lifecycle.
 173  */
 174 static GSList *
 175 get_list_node (GMarkupParseContext *context, gpointer data)
 176 {
 177   GSList *node;
 178   if (context-&gt;spare_list_nodes != NULL)
 179     {
 180       node = context-&gt;spare_list_nodes;
 181       context-&gt;spare_list_nodes = g_slist_remove_link (context-&gt;spare_list_nodes, node);
 182     }
 183   else
 184     node = g_slist_alloc();
 185   node-&gt;data = data;
 186   return node;
 187 }
 188 
 189 static void
 190 free_list_node (GMarkupParseContext *context, GSList *node)
 191 {
 192   node-&gt;data = NULL;
 193   context-&gt;spare_list_nodes = g_slist_concat (node, context-&gt;spare_list_nodes);
 194 }
 195 
 196 static inline void
 197 string_blank (GString *string)
 198 {
 199   string-&gt;str[0] = &#39;\0&#39;;
 200   string-&gt;len = 0;
 201 }
 202 
 203 /**
 204  * g_markup_parse_context_new:
 205  * @parser: a #GMarkupParser
 206  * @flags: one or more #GMarkupParseFlags
 207  * @user_data: user data to pass to #GMarkupParser functions
 208  * @user_data_dnotify: user data destroy notifier called when
 209  *     the parse context is freed
 210  *
 211  * Creates a new parse context. A parse context is used to parse
 212  * marked-up documents. You can feed any number of documents into
 213  * a context, as long as no errors occur; once an error occurs,
 214  * the parse context can&#39;t continue to parse text (you have to
 215  * free it and create a new parse context).
 216  *
 217  * Returns: a new #GMarkupParseContext
 218  **/
 219 GMarkupParseContext *
 220 g_markup_parse_context_new (const GMarkupParser *parser,
 221                             GMarkupParseFlags    flags,
 222                             gpointer             user_data,
 223                             GDestroyNotify       user_data_dnotify)
 224 {
 225   GMarkupParseContext *context;
 226 
 227   g_return_val_if_fail (parser != NULL, NULL);
 228 
 229   context = g_new (GMarkupParseContext, 1);
 230 
 231   context-&gt;ref_count = 1;
 232   context-&gt;parser = parser;
 233   context-&gt;flags = flags;
 234   context-&gt;user_data = user_data;
 235   context-&gt;dnotify = user_data_dnotify;
 236 
 237   context-&gt;line_number = 1;
 238   context-&gt;char_number = 1;
 239 
 240   context-&gt;partial_chunk = NULL;
 241   context-&gt;spare_chunks = NULL;
 242   context-&gt;spare_list_nodes = NULL;
 243 
 244   context-&gt;state = STATE_START;
 245   context-&gt;tag_stack = NULL;
 246   context-&gt;tag_stack_gstr = NULL;
 247   context-&gt;attr_names = NULL;
 248   context-&gt;attr_values = NULL;
 249   context-&gt;cur_attr = -1;
 250   context-&gt;alloc_attrs = 0;
 251 
 252   context-&gt;current_text = NULL;
 253   context-&gt;current_text_len = -1;
 254   context-&gt;current_text_end = NULL;
 255 
 256   context-&gt;start = NULL;
 257   context-&gt;iter = NULL;
 258 
 259   context-&gt;document_empty = TRUE;
 260   context-&gt;parsing = FALSE;
 261 
 262   context-&gt;awaiting_pop = FALSE;
 263   context-&gt;subparser_stack = NULL;
 264   context-&gt;subparser_element = NULL;
 265 
 266   /* this is only looked at if awaiting_pop = TRUE.  initialise anyway. */
 267   context-&gt;held_user_data = NULL;
 268 
 269   context-&gt;balance = 0;
 270 
 271   return context;
 272 }
 273 
 274 /**
 275  * g_markup_parse_context_ref:
 276  * @context: a #GMarkupParseContext
 277  *
 278  * Increases the reference count of @context.
 279  *
 280  * Returns: the same @context
 281  *
 282  * Since: 2.36
 283  **/
 284 GMarkupParseContext *
 285 g_markup_parse_context_ref (GMarkupParseContext *context)
 286 {
 287   g_return_val_if_fail (context != NULL, NULL);
 288   g_return_val_if_fail (context-&gt;ref_count &gt; 0, NULL);
 289 
 290   g_atomic_int_inc (&amp;context-&gt;ref_count);
 291 
 292   return context;
 293 }
 294 
 295 /**
 296  * g_markup_parse_context_unref:
 297  * @context: a #GMarkupParseContext
 298  *
 299  * Decreases the reference count of @context.  When its reference count
 300  * drops to 0, it is freed.
 301  *
 302  * Since: 2.36
 303  **/
 304 void
 305 g_markup_parse_context_unref (GMarkupParseContext *context)
 306 {
 307   g_return_if_fail (context != NULL);
 308   g_return_if_fail (context-&gt;ref_count &gt; 0);
 309 
 310   if (g_atomic_int_dec_and_test (&amp;context-&gt;ref_count))
 311     g_markup_parse_context_free (context);
 312 }
 313 
 314 static void
 315 string_full_free (gpointer ptr)
 316 {
 317   g_string_free (ptr, TRUE);
 318 }
 319 
 320 static void clear_attributes (GMarkupParseContext *context);
 321 
 322 /**
 323  * g_markup_parse_context_free:
 324  * @context: a #GMarkupParseContext
 325  *
 326  * Frees a #GMarkupParseContext.
 327  *
 328  * This function can&#39;t be called from inside one of the
 329  * #GMarkupParser functions or while a subparser is pushed.
 330  */
 331 void
 332 g_markup_parse_context_free (GMarkupParseContext *context)
 333 {
 334   g_return_if_fail (context != NULL);
 335   g_return_if_fail (!context-&gt;parsing);
 336   g_return_if_fail (!context-&gt;subparser_stack);
 337   g_return_if_fail (!context-&gt;awaiting_pop);
 338 
 339   if (context-&gt;dnotify)
 340     (* context-&gt;dnotify) (context-&gt;user_data);
 341 
 342   clear_attributes (context);
 343   g_free (context-&gt;attr_names);
 344   g_free (context-&gt;attr_values);
 345 
 346   g_slist_free_full (context-&gt;tag_stack_gstr, string_full_free);
 347   g_slist_free (context-&gt;tag_stack);
 348 
 349   g_slist_free_full (context-&gt;spare_chunks, string_full_free);
 350   g_slist_free (context-&gt;spare_list_nodes);
 351 
 352   if (context-&gt;partial_chunk)
 353     g_string_free (context-&gt;partial_chunk, TRUE);
 354 
 355   g_free (context);
 356 }
 357 
 358 static void pop_subparser_stack (GMarkupParseContext *context);
 359 
 360 static void
 361 mark_error (GMarkupParseContext *context,
 362             GError              *error)
 363 {
 364   context-&gt;state = STATE_ERROR;
 365 
 366   if (context-&gt;parser-&gt;error)
 367     (*context-&gt;parser-&gt;error) (context, error, context-&gt;user_data);
 368 
 369   /* report the error all the way up to free all the user-data */
 370   while (context-&gt;subparser_stack)
 371     {
 372       pop_subparser_stack (context);
 373       context-&gt;awaiting_pop = FALSE; /* already been freed */
 374 
 375       if (context-&gt;parser-&gt;error)
 376         (*context-&gt;parser-&gt;error) (context, error, context-&gt;user_data);
 377     }
 378 }
 379 
 380 static void
 381 set_error (GMarkupParseContext  *context,
 382            GError              **error,
 383            GMarkupError          code,
 384            const gchar          *format,
 385            ...) G_GNUC_PRINTF (4, 5);
 386 
 387 static void
 388 set_error_literal (GMarkupParseContext  *context,
 389                    GError              **error,
 390                    GMarkupError          code,
 391                    const gchar          *message)
 392 {
 393   GError *tmp_error;
 394 
 395   tmp_error = g_error_new_literal (G_MARKUP_ERROR, code, message);
 396 
 397   g_prefix_error (&amp;tmp_error,
 398                   _(&quot;Error on line %d char %d: &quot;),
 399                   context-&gt;line_number,
 400                   context-&gt;char_number);
 401 
 402   mark_error (context, tmp_error);
 403 
 404   g_propagate_error (error, tmp_error);
 405 }
 406 
 407 G_GNUC_PRINTF(4, 5)
 408 static void
 409 set_error (GMarkupParseContext  *context,
 410            GError              **error,
 411            GMarkupError          code,
 412            const gchar          *format,
 413            ...)
 414 {
 415   gchar *s;
 416   gchar *s_valid;
 417   va_list args;
 418 
 419   va_start (args, format);
 420   s = g_strdup_vprintf (format, args);
 421   va_end (args);
 422 
 423   /* Make sure that the GError message is valid UTF-8
 424    * even if it is complaining about invalid UTF-8 in the markup
 425    */
 426   s_valid = g_utf8_make_valid (s, -1);
 427   set_error_literal (context, error, code, s);
 428 
 429   g_free (s);
 430   g_free (s_valid);
 431 }
 432 
 433 static void
 434 propagate_error (GMarkupParseContext  *context,
 435                  GError              **dest,
 436                  GError               *src)
 437 {
 438   if (context-&gt;flags &amp; G_MARKUP_PREFIX_ERROR_POSITION)
 439     g_prefix_error (&amp;src,
 440                     _(&quot;Error on line %d char %d: &quot;),
 441                     context-&gt;line_number,
 442                     context-&gt;char_number);
 443 
 444   mark_error (context, src);
 445 
 446   g_propagate_error (dest, src);
 447 }
 448 
 449 #define IS_COMMON_NAME_END_CHAR(c) \
 450   ((c) == &#39;=&#39; || (c) == &#39;/&#39; || (c) == &#39;&gt;&#39; || (c) == &#39; &#39;)
 451 
 452 static gboolean
 453 slow_name_validate (GMarkupParseContext  *context,
 454                     const gchar          *name,
 455                     GError              **error)
 456 {
 457   const gchar *p = name;
 458 
 459   if (!g_utf8_validate (name, -1, NULL))
 460     {
 461       set_error (context, error, G_MARKUP_ERROR_BAD_UTF8,
 462                  _(&quot;Invalid UTF-8 encoded text in name - not valid &#39;%s&#39;&quot;), name);
 463       return FALSE;
 464     }
 465 
 466   if (!(g_ascii_isalpha (*p) ||
 467         (!IS_COMMON_NAME_END_CHAR (*p) &amp;&amp;
 468          (*p == &#39;_&#39; ||
 469           *p == &#39;:&#39; ||
 470           g_unichar_isalpha (g_utf8_get_char (p))))))
 471     {
 472       set_error (context, error, G_MARKUP_ERROR_PARSE,
 473                  _(&quot;&#39;%s&#39; is not a valid name&quot;), name);
 474       return FALSE;
 475     }
 476 
 477   for (p = g_utf8_next_char (name); *p != &#39;\0&#39;; p = g_utf8_next_char (p))
 478     {
 479       /* is_name_char */
 480       if (!(g_ascii_isalnum (*p) ||
 481             (!IS_COMMON_NAME_END_CHAR (*p) &amp;&amp;
 482              (*p == &#39;.&#39; ||
 483               *p == &#39;-&#39; ||
 484               *p == &#39;_&#39; ||
 485               *p == &#39;:&#39; ||
 486               g_unichar_isalpha (g_utf8_get_char (p))))))
 487         {
 488           set_error (context, error, G_MARKUP_ERROR_PARSE,
 489                      _(&quot;&#39;%s&#39; is not a valid name: &#39;%c&#39;&quot;), name, *p);
 490           return FALSE;
 491         }
 492     }
 493   return TRUE;
 494 }
 495 
 496 /*
 497  * Use me for elements, attributes etc.
 498  */
 499 static gboolean
 500 name_validate (GMarkupParseContext  *context,
 501                const gchar          *name,
 502                GError              **error)
 503 {
 504   char mask;
 505   const char *p;
 506 
 507   /* name start char */
 508   p = name;
 509   if (G_UNLIKELY (IS_COMMON_NAME_END_CHAR (*p) ||
 510                   !(g_ascii_isalpha (*p) || *p == &#39;_&#39; || *p == &#39;:&#39;)))
 511     goto slow_validate;
 512 
 513   for (mask = *p++; *p != &#39;\0&#39;; p++)
 514     {
 515       mask |= *p;
 516 
 517       /* is_name_char */
 518       if (G_UNLIKELY (!(g_ascii_isalnum (*p) ||
 519                         (!IS_COMMON_NAME_END_CHAR (*p) &amp;&amp;
 520                          (*p == &#39;.&#39; ||
 521                           *p == &#39;-&#39; ||
 522                           *p == &#39;_&#39; ||
 523                           *p == &#39;:&#39;)))))
 524         goto slow_validate;
 525     }
 526 
 527   if (mask &amp; 0x80) /* un-common / non-ascii */
 528     goto slow_validate;
 529 
 530   return TRUE;
 531 
 532  slow_validate:
 533   return slow_name_validate (context, name, error);
 534 }
 535 
 536 static gboolean
 537 text_validate (GMarkupParseContext  *context,
 538                const gchar          *p,
 539                gint                  len,
 540                GError              **error)
 541 {
<a name="3" id="anc3"></a><span class="line-modified"> 542   if (!_g_utf8_validate_len (p, len, NULL))</span>
 543     {
 544       set_error (context, error, G_MARKUP_ERROR_BAD_UTF8,
 545                  _(&quot;Invalid UTF-8 encoded text in name - not valid &#39;%s&#39;&quot;), p);
 546       return FALSE;
 547     }
 548   else
 549     return TRUE;
 550 }
 551 
 552 static gchar*
 553 char_str (gunichar c,
 554           gchar   *buf)
 555 {
 556   memset (buf, 0, 8);
 557   g_unichar_to_utf8 (c, buf);
 558   return buf;
 559 }
 560 
 561 /* Format the next UTF-8 character as a gchar* for printing in error output
 562  * when we encounter a syntax error. This correctly handles invalid UTF-8,
 563  * emitting it as hex escapes. */
 564 static gchar*
 565 utf8_str (const gchar *utf8,
 566           gsize        max_len,
 567           gchar       *buf)
 568 {
 569   gunichar c = g_utf8_get_char_validated (utf8, max_len);
 570   if (c == (gunichar) -1 || c == (gunichar) -2)
 571     {
 572       guchar ch = (max_len &gt; 0) ? (guchar) *utf8 : 0;
 573       gchar *temp = g_strdup_printf (&quot;\\x%02x&quot;, (guint) ch);
 574       memset (buf, 0, 8);
 575       memcpy (buf, temp, strlen (temp));
 576       g_free (temp);
 577     }
 578   else
 579     char_str (c, buf);
 580   return buf;
 581 }
 582 
 583 G_GNUC_PRINTF(5, 6)
 584 static void
 585 set_unescape_error (GMarkupParseContext  *context,
 586                     GError              **error,
 587                     const gchar          *remaining_text,
 588                     GMarkupError          code,
 589                     const gchar          *format,
 590                     ...)
 591 {
 592   GError *tmp_error;
 593   gchar *s;
 594   va_list args;
 595   gint remaining_newlines;
 596   const gchar *p;
 597 
 598   remaining_newlines = 0;
 599   p = remaining_text;
 600   while (*p != &#39;\0&#39;)
 601     {
 602       if (*p == &#39;\n&#39;)
 603         ++remaining_newlines;
 604       ++p;
 605     }
 606 
 607   va_start (args, format);
 608   s = g_strdup_vprintf (format, args);
 609   va_end (args);
 610 
 611   tmp_error = g_error_new (G_MARKUP_ERROR,
 612                            code,
 613                            _(&quot;Error on line %d: %s&quot;),
 614                            context-&gt;line_number - remaining_newlines,
 615                            s);
 616 
 617   g_free (s);
 618 
 619   mark_error (context, tmp_error);
 620 
 621   g_propagate_error (error, tmp_error);
 622 }
 623 
 624 /*
 625  * re-write the GString in-place, unescaping anything that escaped.
 626  * most XML does not contain entities, or escaping.
 627  */
 628 static gboolean
 629 unescape_gstring_inplace (GMarkupParseContext  *context,
 630                           GString              *string,
 631                           gboolean             *is_ascii,
 632                           GError              **error)
 633 {
 634   char mask, *to;
 635   const char *from;
 636   gboolean normalize_attribute;
 637 
 638   *is_ascii = FALSE;
 639 
 640   /* are we unescaping an attribute or not ? */
 641   if (context-&gt;state == STATE_INSIDE_ATTRIBUTE_VALUE_SQ ||
 642       context-&gt;state == STATE_INSIDE_ATTRIBUTE_VALUE_DQ)
 643     normalize_attribute = TRUE;
 644   else
 645     normalize_attribute = FALSE;
 646 
 647   /*
 648    * Meeks&#39; theorem: unescaping can only shrink text.
 649    * for &amp;lt; etc. this is obvious, for &amp;#xffff; more
 650    * thought is required, but this is patently so.
 651    */
 652   mask = 0;
 653   for (from = to = string-&gt;str; *from != &#39;\0&#39;; from++, to++)
 654     {
 655       *to = *from;
 656 
 657       mask |= *to;
 658       if (normalize_attribute &amp;&amp; (*to == &#39;\t&#39; || *to == &#39;\n&#39;))
 659         *to = &#39; &#39;;
 660       if (*to == &#39;\r&#39;)
 661         {
 662           *to = normalize_attribute ? &#39; &#39; : &#39;\n&#39;;
 663           if (from[1] == &#39;\n&#39;)
 664             from++;
 665         }
 666       if (*from == &#39;&amp;&#39;)
 667         {
 668           from++;
 669           if (*from == &#39;#&#39;)
 670             {
 671               gint base = 10;
 672               gulong l;
 673               gchar *end = NULL;
 674 
 675               from++;
 676 
 677               if (*from == &#39;x&#39;)
 678                 {
 679                   base = 16;
 680                   from++;
 681                 }
 682 
 683               errno = 0;
 684               l = strtoul (from, &amp;end, base);
 685 
 686               if (end == from || errno != 0)
 687                 {
 688                   set_unescape_error (context, error,
 689                                       from, G_MARKUP_ERROR_PARSE,
 690                                       _(&quot;Failed to parse &#39;%-.*s&#39;, which &quot;
 691                                         &quot;should have been a digit &quot;
 692                                         &quot;inside a character reference &quot;
 693                                         &quot;(&amp;#234; for example) - perhaps &quot;
 694                                         &quot;the digit is too large&quot;),
 695                                       (int)(end - from), from);
 696                   return FALSE;
 697                 }
 698               else if (*end != &#39;;&#39;)
 699                 {
 700                   set_unescape_error (context, error,
 701                                       from, G_MARKUP_ERROR_PARSE,
 702                                       _(&quot;Character reference did not end with a &quot;
 703                                         &quot;semicolon; &quot;
 704                                         &quot;most likely you used an ampersand &quot;
 705                                         &quot;character without intending to start &quot;
 706                                         &quot;an entity - escape ampersand as &amp;amp;&quot;));
 707                   return FALSE;
 708                 }
 709               else
 710                 {
 711                   /* characters XML 1.1 permits */
 712                   if ((0 &lt; l &amp;&amp; l &lt;= 0xD7FF) ||
 713                       (0xE000 &lt;= l &amp;&amp; l &lt;= 0xFFFD) ||
 714                       (0x10000 &lt;= l &amp;&amp; l &lt;= 0x10FFFF))
 715                     {
 716                       gchar buf[8];
 717                       char_str (l, buf);
 718                       strcpy (to, buf);
 719                       to += strlen (buf) - 1;
 720                       from = end;
 721                       if (l &gt;= 0x80) /* not ascii */
 722                         mask |= 0x80;
 723                     }
 724                   else
 725                     {
 726                       set_unescape_error (context, error,
 727                                           from, G_MARKUP_ERROR_PARSE,
 728                                           _(&quot;Character reference &#39;%-.*s&#39; does not &quot;
 729                                             &quot;encode a permitted character&quot;),
 730                                           (int)(end - from), from);
 731                       return FALSE;
 732                     }
 733                 }
 734             }
 735 
 736           else if (strncmp (from, &quot;lt;&quot;, 3) == 0)
 737             {
 738               *to = &#39;&lt;&#39;;
 739               from += 2;
 740             }
 741           else if (strncmp (from, &quot;gt;&quot;, 3) == 0)
 742             {
 743               *to = &#39;&gt;&#39;;
 744               from += 2;
 745             }
 746           else if (strncmp (from, &quot;amp;&quot;, 4) == 0)
 747             {
 748               *to = &#39;&amp;&#39;;
 749               from += 3;
 750             }
 751           else if (strncmp (from, &quot;quot;&quot;, 5) == 0)
 752             {
 753               *to = &#39;&quot;&#39;;
 754               from += 4;
 755             }
 756           else if (strncmp (from, &quot;apos;&quot;, 5) == 0)
 757             {
 758               *to = &#39;\&#39;&#39;;
 759               from += 4;
 760             }
 761           else
 762             {
 763               if (*from == &#39;;&#39;)
 764                 set_unescape_error (context, error,
 765                                     from, G_MARKUP_ERROR_PARSE,
 766                                     _(&quot;Empty entity &#39;&amp;;&#39; seen; valid &quot;
 767                                       &quot;entities are: &amp;amp; &amp;quot; &amp;lt; &amp;gt; &amp;apos;&quot;));
 768               else
 769                 {
 770                   const char *end = strchr (from, &#39;;&#39;);
 771                   if (end)
 772                     set_unescape_error (context, error,
 773                                         from, G_MARKUP_ERROR_PARSE,
 774                                         _(&quot;Entity name &#39;%-.*s&#39; is not known&quot;),
 775                                         (int)(end - from), from);
 776                   else
 777                     set_unescape_error (context, error,
 778                                         from, G_MARKUP_ERROR_PARSE,
 779                                         _(&quot;Entity did not end with a semicolon; &quot;
 780                                           &quot;most likely you used an ampersand &quot;
 781                                           &quot;character without intending to start &quot;
 782                                           &quot;an entity - escape ampersand as &amp;amp;&quot;));
 783                 }
 784               return FALSE;
 785             }
 786         }
 787     }
 788 
<a name="4" id="anc4"></a><span class="line-modified"> 789   g_assert (to - string-&gt;str &lt;= string-&gt;len);</span>
<span class="line-modified"> 790   if (to - string-&gt;str != string-&gt;len)</span>
 791     g_string_truncate (string, to - string-&gt;str);
 792 
 793   *is_ascii = !(mask &amp; 0x80);
 794 
 795   return TRUE;
 796 }
 797 
 798 static inline gboolean
 799 advance_char (GMarkupParseContext *context)
 800 {
 801   context-&gt;iter++;
 802   context-&gt;char_number++;
 803 
 804   if (G_UNLIKELY (context-&gt;iter == context-&gt;current_text_end))
 805       return FALSE;
 806 
 807   else if (G_UNLIKELY (*context-&gt;iter == &#39;\n&#39;))
 808     {
 809       context-&gt;line_number++;
 810       context-&gt;char_number = 1;
 811     }
 812 
 813   return TRUE;
 814 }
 815 
 816 static inline gboolean
 817 xml_isspace (char c)
 818 {
 819   return c == &#39; &#39; || c == &#39;\t&#39; || c == &#39;\n&#39; || c == &#39;\r&#39;;
 820 }
 821 
 822 static void
 823 skip_spaces (GMarkupParseContext *context)
 824 {
 825   do
 826     {
 827       if (!xml_isspace (*context-&gt;iter))
 828         return;
 829     }
 830   while (advance_char (context));
 831 }
 832 
 833 static void
 834 advance_to_name_end (GMarkupParseContext *context)
 835 {
 836   do
 837     {
 838       if (IS_COMMON_NAME_END_CHAR (*(context-&gt;iter)))
 839         return;
 840       if (xml_isspace (*(context-&gt;iter)))
 841         return;
 842     }
 843   while (advance_char (context));
 844 }
 845 
 846 static void
 847 release_chunk (GMarkupParseContext *context, GString *str)
 848 {
 849   GSList *node;
 850   if (!str)
 851     return;
 852   if (str-&gt;allocated_len &gt; 256)
 853     { /* large strings are unusual and worth freeing */
 854       g_string_free (str, TRUE);
 855       return;
 856     }
 857   string_blank (str);
 858   node = get_list_node (context, str);
 859   context-&gt;spare_chunks = g_slist_concat (node, context-&gt;spare_chunks);
 860 }
 861 
 862 static void
 863 add_to_partial (GMarkupParseContext *context,
 864                 const gchar         *text_start,
 865                 const gchar         *text_end)
 866 {
 867   if (context-&gt;partial_chunk == NULL)
 868     { /* allocate a new chunk to parse into */
 869 
 870       if (context-&gt;spare_chunks != NULL)
 871         {
 872           GSList *node = context-&gt;spare_chunks;
 873           context-&gt;spare_chunks = g_slist_remove_link (context-&gt;spare_chunks, node);
 874           context-&gt;partial_chunk = node-&gt;data;
 875           free_list_node (context, node);
 876         }
 877       else
 878         context-&gt;partial_chunk = g_string_sized_new (MAX (28, text_end - text_start));
 879     }
 880 
 881   if (text_start != text_end)
 882     g_string_insert_len (context-&gt;partial_chunk, -1,
 883                          text_start, text_end - text_start);
 884 }
 885 
 886 static inline void
 887 truncate_partial (GMarkupParseContext *context)
 888 {
 889   if (context-&gt;partial_chunk != NULL)
 890     string_blank (context-&gt;partial_chunk);
 891 }
 892 
 893 static inline const gchar*
 894 current_element (GMarkupParseContext *context)
 895 {
 896   return context-&gt;tag_stack-&gt;data;
 897 }
 898 
 899 static void
 900 pop_subparser_stack (GMarkupParseContext *context)
 901 {
 902   GMarkupRecursionTracker *tracker;
 903 
 904   g_assert (context-&gt;subparser_stack);
 905 
 906   tracker = context-&gt;subparser_stack-&gt;data;
 907 
 908   context-&gt;awaiting_pop = TRUE;
 909   context-&gt;held_user_data = context-&gt;user_data;
 910 
 911   context-&gt;user_data = tracker-&gt;prev_user_data;
 912   context-&gt;parser = tracker-&gt;prev_parser;
 913   context-&gt;subparser_element = tracker-&gt;prev_element;
 914   g_slice_free (GMarkupRecursionTracker, tracker);
 915 
 916   context-&gt;subparser_stack = g_slist_delete_link (context-&gt;subparser_stack,
 917                                                   context-&gt;subparser_stack);
 918 }
 919 
 920 static void
 921 push_partial_as_tag (GMarkupParseContext *context)
 922 {
 923   GString *str = context-&gt;partial_chunk;
 924   /* sadly, this is exported by gmarkup_get_element_stack as-is */
 925   context-&gt;tag_stack = g_slist_concat (get_list_node (context, str-&gt;str), context-&gt;tag_stack);
 926   context-&gt;tag_stack_gstr = g_slist_concat (get_list_node (context, str), context-&gt;tag_stack_gstr);
 927   context-&gt;partial_chunk = NULL;
 928 }
 929 
 930 static void
 931 pop_tag (GMarkupParseContext *context)
 932 {
 933   GSList *nodea, *nodeb;
 934 
 935   nodea = context-&gt;tag_stack;
 936   nodeb = context-&gt;tag_stack_gstr;
 937   release_chunk (context, nodeb-&gt;data);
 938   context-&gt;tag_stack = g_slist_remove_link (context-&gt;tag_stack, nodea);
 939   context-&gt;tag_stack_gstr = g_slist_remove_link (context-&gt;tag_stack_gstr, nodeb);
 940   free_list_node (context, nodea);
 941   free_list_node (context, nodeb);
 942 }
 943 
 944 static void
 945 possibly_finish_subparser (GMarkupParseContext *context)
 946 {
 947   if (current_element (context) == context-&gt;subparser_element)
 948     pop_subparser_stack (context);
 949 }
 950 
 951 static void
 952 ensure_no_outstanding_subparser (GMarkupParseContext *context)
 953 {
 954   if (context-&gt;awaiting_pop)
 955     g_critical (&quot;During the first end_element call after invoking a &quot;
 956                 &quot;subparser you must pop the subparser stack and handle &quot;
 957                 &quot;the freeing of the subparser user_data.  This can be &quot;
 958                 &quot;done by calling the end function of the subparser.  &quot;
 959                 &quot;Very probably, your program just leaked memory.&quot;);
 960 
 961   /* let valgrind watch the pointer disappear... */
 962   context-&gt;held_user_data = NULL;
 963   context-&gt;awaiting_pop = FALSE;
 964 }
 965 
 966 static const gchar*
 967 current_attribute (GMarkupParseContext *context)
 968 {
 969   g_assert (context-&gt;cur_attr &gt;= 0);
 970   return context-&gt;attr_names[context-&gt;cur_attr]-&gt;str;
 971 }
 972 
 973 static void
 974 add_attribute (GMarkupParseContext *context, GString *str)
 975 {
 976   if (context-&gt;cur_attr + 2 &gt;= context-&gt;alloc_attrs)
 977     {
 978       context-&gt;alloc_attrs += 5; /* silly magic number */
 979       context-&gt;attr_names = g_realloc (context-&gt;attr_names, sizeof(GString*)*context-&gt;alloc_attrs);
 980       context-&gt;attr_values = g_realloc (context-&gt;attr_values, sizeof(GString*)*context-&gt;alloc_attrs);
 981     }
 982   context-&gt;cur_attr++;
 983   context-&gt;attr_names[context-&gt;cur_attr] = str;
 984   context-&gt;attr_values[context-&gt;cur_attr] = NULL;
 985   context-&gt;attr_names[context-&gt;cur_attr+1] = NULL;
 986   context-&gt;attr_values[context-&gt;cur_attr+1] = NULL;
 987 }
 988 
 989 static void
 990 clear_attributes (GMarkupParseContext *context)
 991 {
 992   /* Go ahead and free the attributes. */
 993   for (; context-&gt;cur_attr &gt;= 0; context-&gt;cur_attr--)
 994     {
 995       int pos = context-&gt;cur_attr;
 996       release_chunk (context, context-&gt;attr_names[pos]);
 997       release_chunk (context, context-&gt;attr_values[pos]);
 998       context-&gt;attr_names[pos] = context-&gt;attr_values[pos] = NULL;
 999     }
1000   g_assert (context-&gt;cur_attr == -1);
1001   g_assert (context-&gt;attr_names == NULL ||
1002             context-&gt;attr_names[0] == NULL);
1003   g_assert (context-&gt;attr_values == NULL ||
1004             context-&gt;attr_values[0] == NULL);
1005 }
1006 
1007 /* This has to be a separate function to ensure the alloca&#39;s
1008  * are unwound on exit - otherwise we grow &amp; blow the stack
1009  * with large documents
1010  */
1011 static inline void
1012 emit_start_element (GMarkupParseContext  *context,
1013                     GError              **error)
1014 {
1015   int i, j = 0;
1016   const gchar *start_name;
1017   const gchar **attr_names;
1018   const gchar **attr_values;
1019   GError *tmp_error;
1020 
1021   /* In case we want to ignore qualified tags and we see that we have
1022    * one here, we push a subparser.  This will ignore all tags inside of
1023    * the qualified tag.
1024    *
1025    * We deal with the end of the subparser from emit_end_element.
1026    */
1027   if ((context-&gt;flags &amp; G_MARKUP_IGNORE_QUALIFIED) &amp;&amp; strchr (current_element (context), &#39;:&#39;))
1028     {
1029       static const GMarkupParser ignore_parser;
1030       g_markup_parse_context_push (context, &amp;ignore_parser, NULL);
1031       clear_attributes (context);
1032       return;
1033     }
1034 
1035   attr_names = g_newa (const gchar *, context-&gt;cur_attr + 2);
1036   attr_values = g_newa (const gchar *, context-&gt;cur_attr + 2);
1037   for (i = 0; i &lt; context-&gt;cur_attr + 1; i++)
1038     {
1039       /* Possibly omit qualified attribute names from the list */
1040       if ((context-&gt;flags &amp; G_MARKUP_IGNORE_QUALIFIED) &amp;&amp; strchr (context-&gt;attr_names[i]-&gt;str, &#39;:&#39;))
1041         continue;
1042 
1043       attr_names[j] = context-&gt;attr_names[i]-&gt;str;
1044       attr_values[j] = context-&gt;attr_values[i]-&gt;str;
1045       j++;
1046     }
1047   attr_names[j] = NULL;
1048   attr_values[j] = NULL;
1049 
1050   /* Call user callback for element start */
1051   tmp_error = NULL;
1052   start_name = current_element (context);
1053 
1054   if (!name_validate (context, start_name, error))
1055     return;
1056 
1057   if (context-&gt;parser-&gt;start_element)
1058     (* context-&gt;parser-&gt;start_element) (context,
1059                                         start_name,
1060                                         (const gchar **)attr_names,
1061                                         (const gchar **)attr_values,
1062                                         context-&gt;user_data,
1063                                         &amp;tmp_error);
1064   clear_attributes (context);
1065 
1066   if (tmp_error != NULL)
1067     propagate_error (context, error, tmp_error);
1068 }
1069 
1070 static void
1071 emit_end_element (GMarkupParseContext  *context,
1072                   GError              **error)
1073 {
1074   /* We need to pop the tag stack and call the end_element
1075    * function, since this is the close tag
1076    */
1077   GError *tmp_error = NULL;
1078 
1079   g_assert (context-&gt;tag_stack != NULL);
1080 
1081   possibly_finish_subparser (context);
1082 
1083   /* We might have just returned from our ignore subparser */
1084   if ((context-&gt;flags &amp; G_MARKUP_IGNORE_QUALIFIED) &amp;&amp; strchr (current_element (context), &#39;:&#39;))
1085     {
1086       g_markup_parse_context_pop (context);
1087       pop_tag (context);
1088       return;
1089     }
1090 
1091   tmp_error = NULL;
1092   if (context-&gt;parser-&gt;end_element)
1093     (* context-&gt;parser-&gt;end_element) (context,
1094                                       current_element (context),
1095                                       context-&gt;user_data,
1096                                       &amp;tmp_error);
1097 
1098   ensure_no_outstanding_subparser (context);
1099 
1100   if (tmp_error)
1101     {
1102       mark_error (context, tmp_error);
1103       g_propagate_error (error, tmp_error);
1104     }
1105 
1106   pop_tag (context);
1107 }
1108 
1109 /**
1110  * g_markup_parse_context_parse:
1111  * @context: a #GMarkupParseContext
1112  * @text: chunk of text to parse
1113  * @text_len: length of @text in bytes
1114  * @error: return location for a #GError
1115  *
1116  * Feed some data to the #GMarkupParseContext.
1117  *
1118  * The data need not be valid UTF-8; an error will be signaled if
1119  * it&#39;s invalid. The data need not be an entire document; you can
1120  * feed a document into the parser incrementally, via multiple calls
1121  * to this function. Typically, as you receive data from a network
1122  * connection or file, you feed each received chunk of data into this
1123  * function, aborting the process if an error occurs. Once an error
1124  * is reported, no further data may be fed to the #GMarkupParseContext;
1125  * all errors are fatal.
1126  *
1127  * Returns: %FALSE if an error occurred, %TRUE on success
1128  */
1129 gboolean
1130 g_markup_parse_context_parse (GMarkupParseContext  *context,
1131                               const gchar          *text,
1132                               gssize                text_len,
1133                               GError              **error)
1134 {
1135   g_return_val_if_fail (context != NULL, FALSE);
1136   g_return_val_if_fail (text != NULL, FALSE);
1137   g_return_val_if_fail (context-&gt;state != STATE_ERROR, FALSE);
1138   g_return_val_if_fail (!context-&gt;parsing, FALSE);
1139 
1140   if (text_len &lt; 0)
1141     text_len = strlen (text);
1142 
1143   if (text_len == 0)
1144     return TRUE;
1145 
1146   context-&gt;parsing = TRUE;
1147 
1148 
1149   context-&gt;current_text = text;
1150   context-&gt;current_text_len = text_len;
1151   context-&gt;current_text_end = context-&gt;current_text + text_len;
1152   context-&gt;iter = context-&gt;current_text;
1153   context-&gt;start = context-&gt;iter;
1154 
1155   while (context-&gt;iter != context-&gt;current_text_end)
1156     {
1157       switch (context-&gt;state)
1158         {
1159         case STATE_START:
1160           /* Possible next state: AFTER_OPEN_ANGLE */
1161 
1162           g_assert (context-&gt;tag_stack == NULL);
1163 
1164           /* whitespace is ignored outside of any elements */
1165           skip_spaces (context);
1166 
1167           if (context-&gt;iter != context-&gt;current_text_end)
1168             {
1169               if (*context-&gt;iter == &#39;&lt;&#39;)
1170                 {
1171                   /* Move after the open angle */
1172                   advance_char (context);
1173 
1174                   context-&gt;state = STATE_AFTER_OPEN_ANGLE;
1175 
1176                   /* this could start a passthrough */
1177                   context-&gt;start = context-&gt;iter;
1178 
1179                   /* document is now non-empty */
1180                   context-&gt;document_empty = FALSE;
1181                 }
1182               else
1183                 {
1184                   set_error_literal (context,
1185                                      error,
1186                                      G_MARKUP_ERROR_PARSE,
1187                                      _(&quot;Document must begin with an element (e.g. &lt;book&gt;)&quot;));
1188                 }
1189             }
1190           break;
1191 
1192         case STATE_AFTER_OPEN_ANGLE:
1193           /* Possible next states: INSIDE_OPEN_TAG_NAME,
1194            *  AFTER_CLOSE_TAG_SLASH, INSIDE_PASSTHROUGH
1195            */
1196           if (*context-&gt;iter == &#39;?&#39; ||
1197               *context-&gt;iter == &#39;!&#39;)
1198             {
1199               /* include &lt; in the passthrough */
1200               const gchar *openangle = &quot;&lt;&quot;;
1201               add_to_partial (context, openangle, openangle + 1);
1202               context-&gt;start = context-&gt;iter;
1203               context-&gt;balance = 1;
1204               context-&gt;state = STATE_INSIDE_PASSTHROUGH;
1205             }
1206           else if (*context-&gt;iter == &#39;/&#39;)
1207             {
1208               /* move after it */
1209               advance_char (context);
1210 
1211               context-&gt;state = STATE_AFTER_CLOSE_TAG_SLASH;
1212             }
1213           else if (!IS_COMMON_NAME_END_CHAR (*(context-&gt;iter)))
1214             {
1215               context-&gt;state = STATE_INSIDE_OPEN_TAG_NAME;
1216 
1217               /* start of tag name */
1218               context-&gt;start = context-&gt;iter;
1219             }
1220           else
1221             {
1222               gchar buf[8];
1223 
1224               set_error (context,
1225                          error,
1226                          G_MARKUP_ERROR_PARSE,
1227                          _(&quot;&#39;%s&#39; is not a valid character following &quot;
1228                            &quot;a &#39;&lt;&#39; character; it may not begin an &quot;
1229                            &quot;element name&quot;),
1230                          utf8_str (context-&gt;iter,
1231                                    context-&gt;current_text_end - context-&gt;iter, buf));
1232             }
1233           break;
1234 
1235           /* The AFTER_CLOSE_ANGLE state is actually sort of
1236            * broken, because it doesn&#39;t correspond to a range
1237            * of characters in the input stream as the others do,
1238            * and thus makes things harder to conceptualize
1239            */
1240         case STATE_AFTER_CLOSE_ANGLE:
1241           /* Possible next states: INSIDE_TEXT, STATE_START */
1242           if (context-&gt;tag_stack == NULL)
1243             {
1244               context-&gt;start = NULL;
1245               context-&gt;state = STATE_START;
1246             }
1247           else
1248             {
1249               context-&gt;start = context-&gt;iter;
1250               context-&gt;state = STATE_INSIDE_TEXT;
1251             }
1252           break;
1253 
1254         case STATE_AFTER_ELISION_SLASH:
1255           /* Possible next state: AFTER_CLOSE_ANGLE */
1256           if (*context-&gt;iter == &#39;&gt;&#39;)
1257             {
1258               /* move after the close angle */
1259               advance_char (context);
1260               context-&gt;state = STATE_AFTER_CLOSE_ANGLE;
1261               emit_end_element (context, error);
1262             }
1263           else
1264             {
1265               gchar buf[8];
1266 
1267               set_error (context,
1268                          error,
1269                          G_MARKUP_ERROR_PARSE,
1270                          _(&quot;Odd character &#39;%s&#39;, expected a &#39;&gt;&#39; character &quot;
1271                            &quot;to end the empty-element tag &#39;%s&#39;&quot;),
1272                          utf8_str (context-&gt;iter,
1273                                    context-&gt;current_text_end - context-&gt;iter, buf),
1274                          current_element (context));
1275             }
1276           break;
1277 
1278         case STATE_INSIDE_OPEN_TAG_NAME:
1279           /* Possible next states: BETWEEN_ATTRIBUTES */
1280 
1281           /* if there&#39;s a partial chunk then it&#39;s the first part of the
1282            * tag name. If there&#39;s a context-&gt;start then it&#39;s the start
1283            * of the tag name in current_text, the partial chunk goes
1284            * before that start though.
1285            */
1286           advance_to_name_end (context);
1287 
1288           if (context-&gt;iter == context-&gt;current_text_end)
1289             {
1290               /* The name hasn&#39;t necessarily ended. Merge with
1291                * partial chunk, leave state unchanged.
1292                */
1293               add_to_partial (context, context-&gt;start, context-&gt;iter);
1294             }
1295           else
1296             {
1297               /* The name has ended. Combine it with the partial chunk
1298                * if any; push it on the stack; enter next state.
1299                */
1300               add_to_partial (context, context-&gt;start, context-&gt;iter);
1301               push_partial_as_tag (context);
1302 
1303               context-&gt;state = STATE_BETWEEN_ATTRIBUTES;
1304               context-&gt;start = NULL;
1305             }
1306           break;
1307 
1308         case STATE_INSIDE_ATTRIBUTE_NAME:
1309           /* Possible next states: AFTER_ATTRIBUTE_NAME */
1310 
1311           advance_to_name_end (context);
1312           add_to_partial (context, context-&gt;start, context-&gt;iter);
1313 
1314           /* read the full name, if we enter the equals sign state
1315            * then add the attribute to the list (without the value),
1316            * otherwise store a partial chunk to be prepended later.
1317            */
1318           if (context-&gt;iter != context-&gt;current_text_end)
1319             context-&gt;state = STATE_AFTER_ATTRIBUTE_NAME;
1320           break;
1321 
1322         case STATE_AFTER_ATTRIBUTE_NAME:
1323           /* Possible next states: AFTER_ATTRIBUTE_EQUALS_SIGN */
1324 
1325           skip_spaces (context);
1326 
1327           if (context-&gt;iter != context-&gt;current_text_end)
1328             {
1329               /* The name has ended. Combine it with the partial chunk
1330                * if any; push it on the stack; enter next state.
1331                */
1332               if (!name_validate (context, context-&gt;partial_chunk-&gt;str, error))
1333                 break;
1334 
1335               add_attribute (context, context-&gt;partial_chunk);
1336 
1337               context-&gt;partial_chunk = NULL;
1338               context-&gt;start = NULL;
1339 
1340               if (*context-&gt;iter == &#39;=&#39;)
1341                 {
1342                   advance_char (context);
1343                   context-&gt;state = STATE_AFTER_ATTRIBUTE_EQUALS_SIGN;
1344                 }
1345               else
1346                 {
1347                   gchar buf[8];
1348 
1349                   set_error (context,
1350                              error,
1351                              G_MARKUP_ERROR_PARSE,
1352                              _(&quot;Odd character &#39;%s&#39;, expected a &#39;=&#39; after &quot;
1353                                &quot;attribute name &#39;%s&#39; of element &#39;%s&#39;&quot;),
1354                              utf8_str (context-&gt;iter,
1355                                        context-&gt;current_text_end - context-&gt;iter, buf),
1356                              current_attribute (context),
1357                              current_element (context));
1358 
1359                 }
1360             }
1361           break;
1362 
1363         case STATE_BETWEEN_ATTRIBUTES:
1364           /* Possible next states: AFTER_CLOSE_ANGLE,
1365            * AFTER_ELISION_SLASH, INSIDE_ATTRIBUTE_NAME
1366            */
1367           skip_spaces (context);
1368 
1369           if (context-&gt;iter != context-&gt;current_text_end)
1370             {
1371               if (*context-&gt;iter == &#39;/&#39;)
1372                 {
1373                   advance_char (context);
1374                   context-&gt;state = STATE_AFTER_ELISION_SLASH;
1375                 }
1376               else if (*context-&gt;iter == &#39;&gt;&#39;)
1377                 {
1378                   advance_char (context);
1379                   context-&gt;state = STATE_AFTER_CLOSE_ANGLE;
1380                 }
1381               else if (!IS_COMMON_NAME_END_CHAR (*(context-&gt;iter)))
1382                 {
1383                   context-&gt;state = STATE_INSIDE_ATTRIBUTE_NAME;
1384                   /* start of attribute name */
1385                   context-&gt;start = context-&gt;iter;
1386                 }
1387               else
1388                 {
1389                   gchar buf[8];
1390 
1391                   set_error (context,
1392                              error,
1393                              G_MARKUP_ERROR_PARSE,
1394                              _(&quot;Odd character &#39;%s&#39;, expected a &#39;&gt;&#39; or &#39;/&#39; &quot;
1395                                &quot;character to end the start tag of &quot;
1396                                &quot;element &#39;%s&#39;, or optionally an attribute; &quot;
1397                                &quot;perhaps you used an invalid character in &quot;
1398                                &quot;an attribute name&quot;),
1399                              utf8_str (context-&gt;iter,
1400                                        context-&gt;current_text_end - context-&gt;iter, buf),
1401                              current_element (context));
1402                 }
1403 
1404               /* If we&#39;re done with attributes, invoke
1405                * the start_element callback
1406                */
1407               if (context-&gt;state == STATE_AFTER_ELISION_SLASH ||
1408                   context-&gt;state == STATE_AFTER_CLOSE_ANGLE)
1409                 emit_start_element (context, error);
1410             }
1411           break;
1412 
1413         case STATE_AFTER_ATTRIBUTE_EQUALS_SIGN:
1414           /* Possible next state: INSIDE_ATTRIBUTE_VALUE_[SQ/DQ] */
1415 
1416           skip_spaces (context);
1417 
1418           if (context-&gt;iter != context-&gt;current_text_end)
1419             {
1420               if (*context-&gt;iter == &#39;&quot;&#39;)
1421                 {
1422                   advance_char (context);
1423                   context-&gt;state = STATE_INSIDE_ATTRIBUTE_VALUE_DQ;
1424                   context-&gt;start = context-&gt;iter;
1425                 }
1426               else if (*context-&gt;iter == &#39;\&#39;&#39;)
1427                 {
1428                   advance_char (context);
1429                   context-&gt;state = STATE_INSIDE_ATTRIBUTE_VALUE_SQ;
1430                   context-&gt;start = context-&gt;iter;
1431                 }
1432               else
1433                 {
1434                   gchar buf[8];
1435 
1436                   set_error (context,
1437                              error,
1438                              G_MARKUP_ERROR_PARSE,
1439                              _(&quot;Odd character &#39;%s&#39;, expected an open quote mark &quot;
1440                                &quot;after the equals sign when giving value for &quot;
1441                                &quot;attribute &#39;%s&#39; of element &#39;%s&#39;&quot;),
1442                              utf8_str (context-&gt;iter,
1443                                        context-&gt;current_text_end - context-&gt;iter, buf),
1444                              current_attribute (context),
1445                              current_element (context));
1446                 }
1447             }
1448           break;
1449 
1450         case STATE_INSIDE_ATTRIBUTE_VALUE_SQ:
1451         case STATE_INSIDE_ATTRIBUTE_VALUE_DQ:
1452           /* Possible next states: BETWEEN_ATTRIBUTES */
1453           {
1454             gchar delim;
1455 
1456             if (context-&gt;state == STATE_INSIDE_ATTRIBUTE_VALUE_SQ)
1457               {
1458                 delim = &#39;\&#39;&#39;;
1459               }
1460             else
1461               {
1462                 delim = &#39;&quot;&#39;;
1463               }
1464 
1465             do
1466               {
1467                 if (*context-&gt;iter == delim)
1468                   break;
1469               }
1470             while (advance_char (context));
1471           }
1472           if (context-&gt;iter == context-&gt;current_text_end)
1473             {
1474               /* The value hasn&#39;t necessarily ended. Merge with
1475                * partial chunk, leave state unchanged.
1476                */
1477               add_to_partial (context, context-&gt;start, context-&gt;iter);
1478             }
1479           else
1480             {
1481               gboolean is_ascii;
1482               /* The value has ended at the quote mark. Combine it
1483                * with the partial chunk if any; set it for the current
1484                * attribute.
1485                */
1486               add_to_partial (context, context-&gt;start, context-&gt;iter);
1487 
1488               g_assert (context-&gt;cur_attr &gt;= 0);
1489 
1490               if (unescape_gstring_inplace (context, context-&gt;partial_chunk, &amp;is_ascii, error) &amp;&amp;
1491                   (is_ascii || text_validate (context, context-&gt;partial_chunk-&gt;str,
1492                                               context-&gt;partial_chunk-&gt;len, error)))
1493                 {
1494                   /* success, advance past quote and set state. */
1495                   context-&gt;attr_values[context-&gt;cur_attr] = context-&gt;partial_chunk;
1496                   context-&gt;partial_chunk = NULL;
1497                   advance_char (context);
1498                   context-&gt;state = STATE_BETWEEN_ATTRIBUTES;
1499                   context-&gt;start = NULL;
1500                 }
1501 
1502               truncate_partial (context);
1503             }
1504           break;
1505 
1506         case STATE_INSIDE_TEXT:
1507           /* Possible next states: AFTER_OPEN_ANGLE */
1508           do
1509             {
1510               if (*context-&gt;iter == &#39;&lt;&#39;)
1511                 break;
1512             }
1513           while (advance_char (context));
1514 
1515           /* The text hasn&#39;t necessarily ended. Merge with
1516            * partial chunk, leave state unchanged.
1517            */
1518 
1519           add_to_partial (context, context-&gt;start, context-&gt;iter);
1520 
1521           if (context-&gt;iter != context-&gt;current_text_end)
1522             {
1523               gboolean is_ascii;
1524 
1525               /* The text has ended at the open angle. Call the text
1526                * callback.
1527                */
1528               if (unescape_gstring_inplace (context, context-&gt;partial_chunk, &amp;is_ascii, error) &amp;&amp;
1529                   (is_ascii || text_validate (context, context-&gt;partial_chunk-&gt;str,
1530                                               context-&gt;partial_chunk-&gt;len, error)))
1531                 {
1532                   GError *tmp_error = NULL;
1533 
1534                   if (context-&gt;parser-&gt;text)
1535                     (*context-&gt;parser-&gt;text) (context,
1536                                               context-&gt;partial_chunk-&gt;str,
1537                                               context-&gt;partial_chunk-&gt;len,
1538                                               context-&gt;user_data,
1539                                               &amp;tmp_error);
1540 
1541                   if (tmp_error == NULL)
1542                     {
1543                       /* advance past open angle and set state. */
1544                       advance_char (context);
1545                       context-&gt;state = STATE_AFTER_OPEN_ANGLE;
1546                       /* could begin a passthrough */
1547                       context-&gt;start = context-&gt;iter;
1548                     }
1549                   else
1550                     propagate_error (context, error, tmp_error);
1551                 }
1552 
1553               truncate_partial (context);
1554             }
1555           break;
1556 
1557         case STATE_AFTER_CLOSE_TAG_SLASH:
1558           /* Possible next state: INSIDE_CLOSE_TAG_NAME */
1559           if (!IS_COMMON_NAME_END_CHAR (*(context-&gt;iter)))
1560             {
1561               context-&gt;state = STATE_INSIDE_CLOSE_TAG_NAME;
1562 
1563               /* start of tag name */
1564               context-&gt;start = context-&gt;iter;
1565             }
1566           else
1567             {
1568               gchar buf[8];
1569 
1570               set_error (context,
1571                          error,
1572                          G_MARKUP_ERROR_PARSE,
1573                          _(&quot;&#39;%s&#39; is not a valid character following &quot;
1574                            &quot;the characters &#39;&lt;/&#39;; &#39;%s&#39; may not begin an &quot;
1575                            &quot;element name&quot;),
1576                          utf8_str (context-&gt;iter,
1577                                    context-&gt;current_text_end - context-&gt;iter, buf),
1578                          utf8_str (context-&gt;iter,
1579                                    context-&gt;current_text_end - context-&gt;iter, buf));
1580             }
1581           break;
1582 
1583         case STATE_INSIDE_CLOSE_TAG_NAME:
1584           /* Possible next state: AFTER_CLOSE_TAG_NAME */
1585           advance_to_name_end (context);
1586           add_to_partial (context, context-&gt;start, context-&gt;iter);
1587 
1588           if (context-&gt;iter != context-&gt;current_text_end)
1589             context-&gt;state = STATE_AFTER_CLOSE_TAG_NAME;
1590           break;
1591 
1592         case STATE_AFTER_CLOSE_TAG_NAME:
1593           /* Possible next state: AFTER_CLOSE_TAG_SLASH */
1594 
1595           skip_spaces (context);
1596 
1597           if (context-&gt;iter != context-&gt;current_text_end)
1598             {
1599               GString *close_name;
1600 
1601               close_name = context-&gt;partial_chunk;
1602               context-&gt;partial_chunk = NULL;
1603 
1604               if (*context-&gt;iter != &#39;&gt;&#39;)
1605                 {
1606                   gchar buf[8];
1607 
1608                   set_error (context,
1609                              error,
1610                              G_MARKUP_ERROR_PARSE,
1611                              _(&quot;&#39;%s&#39; is not a valid character following &quot;
1612                                &quot;the close element name &#39;%s&#39;; the allowed &quot;
1613                                &quot;character is &#39;&gt;&#39;&quot;),
1614                              utf8_str (context-&gt;iter,
1615                                        context-&gt;current_text_end - context-&gt;iter, buf),
1616                              close_name-&gt;str);
1617                 }
1618               else if (context-&gt;tag_stack == NULL)
1619                 {
1620                   set_error (context,
1621                              error,
1622                              G_MARKUP_ERROR_PARSE,
1623                              _(&quot;Element &#39;%s&#39; was closed, no element &quot;
1624                                &quot;is currently open&quot;),
1625                              close_name-&gt;str);
1626                 }
1627               else if (strcmp (close_name-&gt;str, current_element (context)) != 0)
1628                 {
1629                   set_error (context,
1630                              error,
1631                              G_MARKUP_ERROR_PARSE,
1632                              _(&quot;Element &#39;%s&#39; was closed, but the currently &quot;
1633                                &quot;open element is &#39;%s&#39;&quot;),
1634                              close_name-&gt;str,
1635                              current_element (context));
1636                 }
1637               else
1638                 {
1639                   advance_char (context);
1640                   context-&gt;state = STATE_AFTER_CLOSE_ANGLE;
1641                   context-&gt;start = NULL;
1642 
1643                   emit_end_element (context, error);
1644                 }
1645               context-&gt;partial_chunk = close_name;
1646               truncate_partial (context);
1647             }
1648           break;
1649 
1650         case STATE_INSIDE_PASSTHROUGH:
1651           /* Possible next state: AFTER_CLOSE_ANGLE */
1652           do
1653             {
1654               if (*context-&gt;iter == &#39;&lt;&#39;)
1655                 context-&gt;balance++;
1656               if (*context-&gt;iter == &#39;&gt;&#39;)
1657                 {
1658                   gchar *str;
1659                   gsize len;
1660 
1661                   context-&gt;balance--;
1662                   add_to_partial (context, context-&gt;start, context-&gt;iter);
1663                   context-&gt;start = context-&gt;iter;
1664 
1665                   str = context-&gt;partial_chunk-&gt;str;
1666                   len = context-&gt;partial_chunk-&gt;len;
1667 
1668                   if (str[1] == &#39;?&#39; &amp;&amp; str[len - 1] == &#39;?&#39;)
1669                     break;
1670                   if (strncmp (str, &quot;&lt;!--&quot;, 4) == 0 &amp;&amp;
1671                       strcmp (str + len - 2, &quot;--&quot;) == 0)
1672                     break;
1673                   if (strncmp (str, &quot;&lt;![CDATA[&quot;, 9) == 0 &amp;&amp;
1674                       strcmp (str + len - 2, &quot;]]&quot;) == 0)
1675                     break;
1676                   if (strncmp (str, &quot;&lt;!DOCTYPE&quot;, 9) == 0 &amp;&amp;
1677                       context-&gt;balance == 0)
1678                     break;
1679                 }
1680             }
1681           while (advance_char (context));
1682 
1683           if (context-&gt;iter == context-&gt;current_text_end)
1684             {
1685               /* The passthrough hasn&#39;t necessarily ended. Merge with
1686                * partial chunk, leave state unchanged.
1687                */
1688                add_to_partial (context, context-&gt;start, context-&gt;iter);
1689             }
1690           else
1691             {
1692               /* The passthrough has ended at the close angle. Combine
1693                * it with the partial chunk if any. Call the passthrough
1694                * callback. Note that the open/close angles are
1695                * included in the text of the passthrough.
1696                */
1697               GError *tmp_error = NULL;
1698 
1699               advance_char (context); /* advance past close angle */
1700               add_to_partial (context, context-&gt;start, context-&gt;iter);
1701 
1702               if (context-&gt;flags &amp; G_MARKUP_TREAT_CDATA_AS_TEXT &amp;&amp;
1703                   strncmp (context-&gt;partial_chunk-&gt;str, &quot;&lt;![CDATA[&quot;, 9) == 0)
1704                 {
1705                   if (context-&gt;parser-&gt;text &amp;&amp;
1706                       text_validate (context,
1707                                      context-&gt;partial_chunk-&gt;str + 9,
1708                                      context-&gt;partial_chunk-&gt;len - 12,
1709                                      error))
1710                     (*context-&gt;parser-&gt;text) (context,
1711                                               context-&gt;partial_chunk-&gt;str + 9,
1712                                               context-&gt;partial_chunk-&gt;len - 12,
1713                                               context-&gt;user_data,
1714                                               &amp;tmp_error);
1715                 }
1716               else if (context-&gt;parser-&gt;passthrough &amp;&amp;
1717                        text_validate (context,
1718                                       context-&gt;partial_chunk-&gt;str,
1719                                       context-&gt;partial_chunk-&gt;len,
1720                                       error))
1721                 (*context-&gt;parser-&gt;passthrough) (context,
1722                                                  context-&gt;partial_chunk-&gt;str,
1723                                                  context-&gt;partial_chunk-&gt;len,
1724                                                  context-&gt;user_data,
1725                                                  &amp;tmp_error);
1726 
1727               truncate_partial (context);
1728 
1729               if (tmp_error == NULL)
1730                 {
1731                   context-&gt;state = STATE_AFTER_CLOSE_ANGLE;
1732                   context-&gt;start = context-&gt;iter; /* could begin text */
1733                 }
1734               else
1735                 propagate_error (context, error, tmp_error);
1736             }
1737           break;
1738 
1739         case STATE_ERROR:
1740           goto finished;
1741           break;
1742 
1743         default:
1744           g_assert_not_reached ();
1745           break;
1746         }
1747     }
1748 
1749  finished:
1750   context-&gt;parsing = FALSE;
1751 
1752   return context-&gt;state != STATE_ERROR;
1753 }
1754 
1755 /**
1756  * g_markup_parse_context_end_parse:
1757  * @context: a #GMarkupParseContext
1758  * @error: return location for a #GError
1759  *
1760  * Signals to the #GMarkupParseContext that all data has been
1761  * fed into the parse context with g_markup_parse_context_parse().
1762  *
1763  * This function reports an error if the document isn&#39;t complete,
1764  * for example if elements are still open.
1765  *
1766  * Returns: %TRUE on success, %FALSE if an error was set
1767  */
1768 gboolean
1769 g_markup_parse_context_end_parse (GMarkupParseContext  *context,
1770                                   GError              **error)
1771 {
1772   g_return_val_if_fail (context != NULL, FALSE);
1773   g_return_val_if_fail (!context-&gt;parsing, FALSE);
1774   g_return_val_if_fail (context-&gt;state != STATE_ERROR, FALSE);
1775 
1776   if (context-&gt;partial_chunk != NULL)
1777     {
1778       g_string_free (context-&gt;partial_chunk, TRUE);
1779       context-&gt;partial_chunk = NULL;
1780     }
1781 
1782   if (context-&gt;document_empty)
1783     {
1784       set_error_literal (context, error, G_MARKUP_ERROR_EMPTY,
1785                          _(&quot;Document was empty or contained only whitespace&quot;));
1786       return FALSE;
1787     }
1788 
1789   context-&gt;parsing = TRUE;
1790 
1791   switch (context-&gt;state)
1792     {
1793     case STATE_START:
1794       /* Nothing to do */
1795       break;
1796 
1797     case STATE_AFTER_OPEN_ANGLE:
1798       set_error_literal (context, error, G_MARKUP_ERROR_PARSE,
1799                          _(&quot;Document ended unexpectedly just after an open angle bracket &#39;&lt;&#39;&quot;));
1800       break;
1801 
1802     case STATE_AFTER_CLOSE_ANGLE:
1803       if (context-&gt;tag_stack != NULL)
1804         {
1805           /* Error message the same as for INSIDE_TEXT */
1806           set_error (context, error, G_MARKUP_ERROR_PARSE,
1807                      _(&quot;Document ended unexpectedly with elements still open - &quot;
1808                        &quot;&#39;%s&#39; was the last element opened&quot;),
1809                      current_element (context));
1810         }
1811       break;
1812 
1813     case STATE_AFTER_ELISION_SLASH:
1814       set_error (context, error, G_MARKUP_ERROR_PARSE,
1815                  _(&quot;Document ended unexpectedly, expected to see a close angle &quot;
1816                    &quot;bracket ending the tag &lt;%s/&gt;&quot;), current_element (context));
1817       break;
1818 
1819     case STATE_INSIDE_OPEN_TAG_NAME:
1820       set_error_literal (context, error, G_MARKUP_ERROR_PARSE,
1821                          _(&quot;Document ended unexpectedly inside an element name&quot;));
1822       break;
1823 
1824     case STATE_INSIDE_ATTRIBUTE_NAME:
1825     case STATE_AFTER_ATTRIBUTE_NAME:
1826       set_error_literal (context, error, G_MARKUP_ERROR_PARSE,
1827                          _(&quot;Document ended unexpectedly inside an attribute name&quot;));
1828       break;
1829 
1830     case STATE_BETWEEN_ATTRIBUTES:
1831       set_error_literal (context, error, G_MARKUP_ERROR_PARSE,
1832                          _(&quot;Document ended unexpectedly inside an element-opening &quot;
1833                            &quot;tag.&quot;));
1834       break;
1835 
1836     case STATE_AFTER_ATTRIBUTE_EQUALS_SIGN:
1837       set_error_literal (context, error, G_MARKUP_ERROR_PARSE,
1838                          _(&quot;Document ended unexpectedly after the equals sign &quot;
1839                            &quot;following an attribute name; no attribute value&quot;));
1840       break;
1841 
1842     case STATE_INSIDE_ATTRIBUTE_VALUE_SQ:
1843     case STATE_INSIDE_ATTRIBUTE_VALUE_DQ:
1844       set_error_literal (context, error, G_MARKUP_ERROR_PARSE,
1845                          _(&quot;Document ended unexpectedly while inside an attribute &quot;
1846                            &quot;value&quot;));
1847       break;
1848 
1849     case STATE_INSIDE_TEXT:
1850       g_assert (context-&gt;tag_stack != NULL);
1851       set_error (context, error, G_MARKUP_ERROR_PARSE,
1852                  _(&quot;Document ended unexpectedly with elements still open - &quot;
1853                    &quot;&#39;%s&#39; was the last element opened&quot;),
1854                  current_element (context));
1855       break;
1856 
1857     case STATE_AFTER_CLOSE_TAG_SLASH:
1858     case STATE_INSIDE_CLOSE_TAG_NAME:
1859     case STATE_AFTER_CLOSE_TAG_NAME:
1860       if (context-&gt;tag_stack != NULL)
1861         set_error (context, error, G_MARKUP_ERROR_PARSE,
1862                    _(&quot;Document ended unexpectedly inside the close tag for &quot;
<a name="5" id="anc5"></a><span class="line-modified">1863                    &quot;element &#39;%s&#39;&quot;), current_element (context));</span>
1864       else
1865         set_error (context, error, G_MARKUP_ERROR_PARSE,
1866                    _(&quot;Document ended unexpectedly inside the close tag for an &quot;
1867                      &quot;unopened element&quot;));
1868       break;
1869 
1870     case STATE_INSIDE_PASSTHROUGH:
1871       set_error_literal (context, error, G_MARKUP_ERROR_PARSE,
1872                          _(&quot;Document ended unexpectedly inside a comment or &quot;
1873                            &quot;processing instruction&quot;));
1874       break;
1875 
1876     case STATE_ERROR:
1877     default:
1878       g_assert_not_reached ();
1879       break;
1880     }
1881 
1882   context-&gt;parsing = FALSE;
1883 
1884   return context-&gt;state != STATE_ERROR;
1885 }
1886 
1887 /**
1888  * g_markup_parse_context_get_element:
1889  * @context: a #GMarkupParseContext
1890  *
1891  * Retrieves the name of the currently open element.
1892  *
1893  * If called from the start_element or end_element handlers this will
1894  * give the element_name as passed to those functions. For the parent
1895  * elements, see g_markup_parse_context_get_element_stack().
1896  *
1897  * Returns: the name of the currently open element, or %NULL
1898  *
1899  * Since: 2.2
1900  */
1901 const gchar *
1902 g_markup_parse_context_get_element (GMarkupParseContext *context)
1903 {
1904   g_return_val_if_fail (context != NULL, NULL);
1905 
1906   if (context-&gt;tag_stack == NULL)
1907     return NULL;
1908   else
1909     return current_element (context);
1910 }
1911 
1912 /**
1913  * g_markup_parse_context_get_element_stack:
1914  * @context: a #GMarkupParseContext
1915  *
1916  * Retrieves the element stack from the internal state of the parser.
1917  *
1918  * The returned #GSList is a list of strings where the first item is
1919  * the currently open tag (as would be returned by
1920  * g_markup_parse_context_get_element()) and the next item is its
1921  * immediate parent.
1922  *
1923  * This function is intended to be used in the start_element and
1924  * end_element handlers where g_markup_parse_context_get_element()
1925  * would merely return the name of the element that is being
1926  * processed.
1927  *
1928  * Returns: the element stack, which must not be modified
1929  *
1930  * Since: 2.16
1931  */
1932 const GSList *
1933 g_markup_parse_context_get_element_stack (GMarkupParseContext *context)
1934 {
1935   g_return_val_if_fail (context != NULL, NULL);
1936   return context-&gt;tag_stack;
1937 }
1938 
1939 /**
1940  * g_markup_parse_context_get_position:
1941  * @context: a #GMarkupParseContext
1942  * @line_number: (nullable): return location for a line number, or %NULL
1943  * @char_number: (nullable): return location for a char-on-line number, or %NULL
1944  *
1945  * Retrieves the current line number and the number of the character on
1946  * that line. Intended for use in error messages; there are no strict
1947  * semantics for what constitutes the &quot;current&quot; line number other than
1948  * &quot;the best number we could come up with for error messages.&quot;
1949  */
1950 void
1951 g_markup_parse_context_get_position (GMarkupParseContext *context,
1952                                      gint                *line_number,
1953                                      gint                *char_number)
1954 {
1955   g_return_if_fail (context != NULL);
1956 
1957   if (line_number)
1958     *line_number = context-&gt;line_number;
1959 
1960   if (char_number)
1961     *char_number = context-&gt;char_number;
1962 }
1963 
1964 /**
1965  * g_markup_parse_context_get_user_data:
1966  * @context: a #GMarkupParseContext
1967  *
1968  * Returns the user_data associated with @context.
1969  *
1970  * This will either be the user_data that was provided to
1971  * g_markup_parse_context_new() or to the most recent call
1972  * of g_markup_parse_context_push().
1973  *
1974  * Returns: the provided user_data. The returned data belongs to
1975  *     the markup context and will be freed when
1976  *     g_markup_parse_context_free() is called.
1977  *
1978  * Since: 2.18
1979  */
1980 gpointer
1981 g_markup_parse_context_get_user_data (GMarkupParseContext *context)
1982 {
1983   return context-&gt;user_data;
1984 }
1985 
1986 /**
1987  * g_markup_parse_context_push:
1988  * @context: a #GMarkupParseContext
1989  * @parser: a #GMarkupParser
1990  * @user_data: user data to pass to #GMarkupParser functions
1991  *
1992  * Temporarily redirects markup data to a sub-parser.
1993  *
1994  * This function may only be called from the start_element handler of
1995  * a #GMarkupParser. It must be matched with a corresponding call to
1996  * g_markup_parse_context_pop() in the matching end_element handler
1997  * (except in the case that the parser aborts due to an error).
1998  *
1999  * All tags, text and other data between the matching tags is
2000  * redirected to the subparser given by @parser. @user_data is used
2001  * as the user_data for that parser. @user_data is also passed to the
2002  * error callback in the event that an error occurs. This includes
2003  * errors that occur in subparsers of the subparser.
2004  *
2005  * The end tag matching the start tag for which this call was made is
2006  * handled by the previous parser (which is given its own user_data)
2007  * which is why g_markup_parse_context_pop() is provided to allow &quot;one
2008  * last access&quot; to the @user_data provided to this function. In the
2009  * case of error, the @user_data provided here is passed directly to
2010  * the error callback of the subparser and g_markup_parse_context_pop()
2011  * should not be called. In either case, if @user_data was allocated
2012  * then it ought to be freed from both of these locations.
2013  *
2014  * This function is not intended to be directly called by users
2015  * interested in invoking subparsers. Instead, it is intended to be
2016  * used by the subparsers themselves to implement a higher-level
2017  * interface.
2018  *
2019  * As an example, see the following implementation of a simple
2020  * parser that counts the number of tags encountered.
2021  *
2022  * |[&lt;!-- language=&quot;C&quot; --&gt;
2023  * typedef struct
2024  * {
2025  *   gint tag_count;
2026  * } CounterData;
2027  *
2028  * static void
2029  * counter_start_element (GMarkupParseContext  *context,
2030  *                        const gchar          *element_name,
2031  *                        const gchar         **attribute_names,
2032  *                        const gchar         **attribute_values,
2033  *                        gpointer              user_data,
2034  *                        GError              **error)
2035  * {
2036  *   CounterData *data = user_data;
2037  *
2038  *   data-&gt;tag_count++;
2039  * }
2040  *
2041  * static void
2042  * counter_error (GMarkupParseContext *context,
2043  *                GError              *error,
2044  *                gpointer             user_data)
2045  * {
2046  *   CounterData *data = user_data;
2047  *
2048  *   g_slice_free (CounterData, data);
2049  * }
2050  *
2051  * static GMarkupParser counter_subparser =
2052  * {
2053  *   counter_start_element,
2054  *   NULL,
2055  *   NULL,
2056  *   NULL,
2057  *   counter_error
2058  * };
2059  * ]|
2060  *
2061  * In order to allow this parser to be easily used as a subparser, the
2062  * following interface is provided:
2063  *
2064  * |[&lt;!-- language=&quot;C&quot; --&gt;
2065  * void
2066  * start_counting (GMarkupParseContext *context)
2067  * {
2068  *   CounterData *data = g_slice_new (CounterData);
2069  *
2070  *   data-&gt;tag_count = 0;
2071  *   g_markup_parse_context_push (context, &amp;counter_subparser, data);
2072  * }
2073  *
2074  * gint
2075  * end_counting (GMarkupParseContext *context)
2076  * {
2077  *   CounterData *data = g_markup_parse_context_pop (context);
2078  *   int result;
2079  *
2080  *   result = data-&gt;tag_count;
2081  *   g_slice_free (CounterData, data);
2082  *
2083  *   return result;
2084  * }
2085  * ]|
2086  *
2087  * The subparser would then be used as follows:
2088  *
2089  * |[&lt;!-- language=&quot;C&quot; --&gt;
2090  * static void start_element (context, element_name, ...)
2091  * {
2092  *   if (strcmp (element_name, &quot;count-these&quot;) == 0)
2093  *     start_counting (context);
2094  *
2095  *   // else, handle other tags...
2096  * }
2097  *
2098  * static void end_element (context, element_name, ...)
2099  * {
2100  *   if (strcmp (element_name, &quot;count-these&quot;) == 0)
2101  *     g_print (&quot;Counted %d tags\n&quot;, end_counting (context));
2102  *
2103  *   // else, handle other tags...
2104  * }
2105  * ]|
2106  *
2107  * Since: 2.18
2108  **/
2109 void
2110 g_markup_parse_context_push (GMarkupParseContext *context,
2111                              const GMarkupParser *parser,
2112                              gpointer             user_data)
2113 {
2114   GMarkupRecursionTracker *tracker;
2115 
2116   tracker = g_slice_new (GMarkupRecursionTracker);
2117 #ifdef GSTREAMER_LITE
2118   if (tracker == NULL) {
2119     return;
2120   }
2121 #endif // GSTREAMER_LITE
2122   tracker-&gt;prev_element = context-&gt;subparser_element;
2123   tracker-&gt;prev_parser = context-&gt;parser;
2124   tracker-&gt;prev_user_data = context-&gt;user_data;
2125 
2126   context-&gt;subparser_element = current_element (context);
2127   context-&gt;parser = parser;
2128   context-&gt;user_data = user_data;
2129 
2130   context-&gt;subparser_stack = g_slist_prepend (context-&gt;subparser_stack,
2131                                               tracker);
2132 }
2133 
2134 /**
2135  * g_markup_parse_context_pop:
2136  * @context: a #GMarkupParseContext
2137  *
2138  * Completes the process of a temporary sub-parser redirection.
2139  *
2140  * This function exists to collect the user_data allocated by a
2141  * matching call to g_markup_parse_context_push(). It must be called
2142  * in the end_element handler corresponding to the start_element
2143  * handler during which g_markup_parse_context_push() was called.
2144  * You must not call this function from the error callback -- the
2145  * @user_data is provided directly to the callback in that case.
2146  *
2147  * This function is not intended to be directly called by users
2148  * interested in invoking subparsers. Instead, it is intended to
2149  * be used by the subparsers themselves to implement a higher-level
2150  * interface.
2151  *
2152  * Returns: the user data passed to g_markup_parse_context_push()
2153  *
2154  * Since: 2.18
2155  */
2156 gpointer
2157 g_markup_parse_context_pop (GMarkupParseContext *context)
2158 {
2159   gpointer user_data;
2160 
2161   if (!context-&gt;awaiting_pop)
2162     possibly_finish_subparser (context);
2163 
2164   g_assert (context-&gt;awaiting_pop);
2165 
2166   context-&gt;awaiting_pop = FALSE;
2167 
2168   /* valgrind friendliness */
2169   user_data = context-&gt;held_user_data;
2170   context-&gt;held_user_data = NULL;
2171 
2172   return user_data;
2173 }
2174 
<a name="6" id="anc6"></a>


















2175 static void
2176 append_escaped_text (GString     *str,
2177                      const gchar *text,
2178                      gssize       length)
2179 {
<a name="7" id="anc7"></a><span class="line-modified">2180   const gchar *p;</span>
2181   const gchar *end;
<a name="8" id="anc8"></a><span class="line-removed">2182   gunichar c;</span>
2183 
<a name="9" id="anc9"></a><span class="line-modified">2184   p = text;</span>
2185   end = text + length;
2186 
<a name="10" id="anc10"></a><span class="line-modified">2187   while (p &lt; end)</span>
2188     {
<a name="11" id="anc11"></a><span class="line-modified">2189       const gchar *next;</span>
<span class="line-removed">2190       next = g_utf8_next_char (p);</span>
2191 
<a name="12" id="anc12"></a><span class="line-modified">2192       switch (*p)</span>
2193         {
2194         case &#39;&amp;&#39;:
<a name="13" id="anc13"></a>
2195           g_string_append (str, &quot;&amp;amp;&quot;);
2196           break;
2197 
2198         case &#39;&lt;&#39;:
<a name="14" id="anc14"></a>
2199           g_string_append (str, &quot;&amp;lt;&quot;);
2200           break;
2201 
2202         case &#39;&gt;&#39;:
<a name="15" id="anc15"></a>
2203           g_string_append (str, &quot;&amp;gt;&quot;);
2204           break;
2205 
2206         case &#39;\&#39;&#39;:
<a name="16" id="anc16"></a>
2207           g_string_append (str, &quot;&amp;apos;&quot;);
2208           break;
2209 
2210         case &#39;&quot;&#39;:
<a name="17" id="anc17"></a>
2211           g_string_append (str, &quot;&amp;quot;&quot;);
2212           break;
2213 
2214         default:
<a name="18" id="anc18"></a><span class="line-removed">2215           c = g_utf8_get_char (p);</span>
2216           if ((0x1 &lt;= c &amp;&amp; c &lt;= 0x8) ||
2217               (0xb &lt;= c &amp;&amp; c  &lt;= 0xc) ||
2218               (0xe &lt;= c &amp;&amp; c &lt;= 0x1f) ||
<a name="19" id="anc19"></a><span class="line-modified">2219               (0x7f &lt;= c &amp;&amp; c &lt;= 0x84) ||</span>
<span class="line-modified">2220               (0x86 &lt;= c &amp;&amp; c &lt;= 0x9f))</span>
<span class="line-modified">2221             g_string_append_printf (str, &quot;&amp;#x%x;&quot;, c);</span>























2222           else
<a name="20" id="anc20"></a><span class="line-modified">2223             g_string_append_len (str, p, next - p);</span>
2224           break;
2225         }
<a name="21" id="anc21"></a><span class="line-removed">2226 </span>
<span class="line-removed">2227       p = next;</span>
2228     }
<a name="22" id="anc22"></a>


2229 }
2230 
<a name="23" id="anc23"></a>

2231 /**
2232  * g_markup_escape_text:
2233  * @text: some valid UTF-8 text
2234  * @length: length of @text in bytes, or -1 if the text is nul-terminated
2235  *
2236  * Escapes text so that the markup parser will parse it verbatim.
2237  * Less than, greater than, ampersand, etc. are replaced with the
2238  * corresponding entities. This function would typically be used
2239  * when writing out a file to be parsed with the markup parser.
2240  *
2241  * Note that this function doesn&#39;t protect whitespace and line endings
2242  * from being processed according to the XML rules for normalization
2243  * of line endings and attribute values.
2244  *
2245  * Note also that this function will produce character references in
2246  * the range of &amp;#x1; ... &amp;#x1f; for all control sequences
2247  * except for tabstop, newline and carriage return.  The character
2248  * references in this range are not valid XML 1.0, but they are
2249  * valid XML 1.1 and will be accepted by the GMarkup parser.
2250  *
2251  * Returns: a newly allocated string with the escaped text
2252  */
2253 gchar*
2254 g_markup_escape_text (const gchar *text,
2255                       gssize       length)
2256 {
2257   GString *str;
2258 
2259   g_return_val_if_fail (text != NULL, NULL);
2260 
2261   if (length &lt; 0)
2262     length = strlen (text);
2263 
2264   /* prealloc at least as long as original text */
2265   str = g_string_sized_new (length);
2266   append_escaped_text (str, text, length);
2267 
2268   return g_string_free (str, FALSE);
2269 }
2270 
2271 /*
2272  * find_conversion:
2273  * @format: a printf-style format string
2274  * @after: location to store a pointer to the character after
2275  *     the returned conversion. On a %NULL return, returns the
2276  *     pointer to the trailing NUL in the string
2277  *
2278  * Find the next conversion in a printf-style format string.
2279  * Partially based on code from printf-parser.c,
2280  * Copyright (C) 1999-2000, 2002-2003 Free Software Foundation, Inc.
2281  *
2282  * Returns: pointer to the next conversion in @format,
2283  *  or %NULL, if none.
2284  */
2285 static const char *
2286 find_conversion (const char  *format,
2287                  const char **after)
2288 {
2289   const char *start = format;
2290   const char *cp;
2291 
2292   while (*start != &#39;\0&#39; &amp;&amp; *start != &#39;%&#39;)
2293     start++;
2294 
2295   if (*start == &#39;\0&#39;)
2296     {
2297       *after = start;
2298       return NULL;
2299     }
2300 
2301   cp = start + 1;
2302 
2303   if (*cp == &#39;\0&#39;)
2304     {
2305       *after = cp;
2306       return NULL;
2307     }
2308 
2309   /* Test for positional argument.  */
2310   if (*cp &gt;= &#39;0&#39; &amp;&amp; *cp &lt;= &#39;9&#39;)
2311     {
2312       const char *np;
2313 
2314       for (np = cp; *np &gt;= &#39;0&#39; &amp;&amp; *np &lt;= &#39;9&#39;; np++)
2315         ;
2316       if (*np == &#39;$&#39;)
2317         cp = np + 1;
2318     }
2319 
2320   /* Skip the flags.  */
2321   for (;;)
2322     {
2323       if (*cp == &#39;\&#39;&#39; ||
2324           *cp == &#39;-&#39; ||
2325           *cp == &#39;+&#39; ||
2326           *cp == &#39; &#39; ||
2327           *cp == &#39;#&#39; ||
2328           *cp == &#39;0&#39;)
2329         cp++;
2330       else
2331         break;
2332     }
2333 
2334   /* Skip the field width.  */
2335   if (*cp == &#39;*&#39;)
2336     {
2337       cp++;
2338 
2339       /* Test for positional argument.  */
2340       if (*cp &gt;= &#39;0&#39; &amp;&amp; *cp &lt;= &#39;9&#39;)
2341         {
2342           const char *np;
2343 
2344           for (np = cp; *np &gt;= &#39;0&#39; &amp;&amp; *np &lt;= &#39;9&#39;; np++)
2345             ;
2346           if (*np == &#39;$&#39;)
2347             cp = np + 1;
2348         }
2349     }
2350   else
2351     {
2352       for (; *cp &gt;= &#39;0&#39; &amp;&amp; *cp &lt;= &#39;9&#39;; cp++)
2353         ;
2354     }
2355 
2356   /* Skip the precision.  */
2357   if (*cp == &#39;.&#39;)
2358     {
2359       cp++;
2360       if (*cp == &#39;*&#39;)
2361         {
2362           /* Test for positional argument.  */
2363           if (*cp &gt;= &#39;0&#39; &amp;&amp; *cp &lt;= &#39;9&#39;)
2364             {
2365               const char *np;
2366 
2367               for (np = cp; *np &gt;= &#39;0&#39; &amp;&amp; *np &lt;= &#39;9&#39;; np++)
2368                 ;
2369               if (*np == &#39;$&#39;)
2370                 cp = np + 1;
2371             }
2372         }
2373       else
2374         {
2375           for (; *cp &gt;= &#39;0&#39; &amp;&amp; *cp &lt;= &#39;9&#39;; cp++)
2376             ;
2377         }
2378     }
2379 
2380   /* Skip argument type/size specifiers.  */
2381   while (*cp == &#39;h&#39; ||
2382          *cp == &#39;L&#39; ||
2383          *cp == &#39;l&#39; ||
2384          *cp == &#39;j&#39; ||
2385          *cp == &#39;z&#39; ||
2386          *cp == &#39;Z&#39; ||
2387          *cp == &#39;t&#39;)
2388     cp++;
2389 
2390   /* Skip the conversion character.  */
2391   cp++;
2392 
2393   *after = cp;
2394   return start;
2395 }
2396 
2397 /**
2398  * g_markup_vprintf_escaped:
2399  * @format: printf() style format string
2400  * @args: variable argument list, similar to vprintf()
2401  *
2402  * Formats the data in @args according to @format, escaping
2403  * all string and character arguments in the fashion
2404  * of g_markup_escape_text(). See g_markup_printf_escaped().
2405  *
2406  * Returns: newly allocated result from formatting
2407  *  operation. Free with g_free().
2408  *
2409  * Since: 2.4
2410  */
2411 
2412 #ifdef GSTREAMER_LITE
2413 #ifndef G_OS_WIN32
2414 #pragma GCC diagnostic push
2415 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
2416 #endif // G_OS_WIN32
2417 #else // GSTREAMER_LITE
2418 #pragma GCC diagnostic push
2419 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
2420 #endif // GSTREAMER_LITE
2421 
2422 gchar *
2423 g_markup_vprintf_escaped (const gchar *format,
2424                           va_list      args)
2425 {
2426   GString *format1;
2427   GString *format2;
2428   GString *result = NULL;
2429   gchar *output1 = NULL;
2430   gchar *output2 = NULL;
2431   const char *p, *op1, *op2;
2432   va_list args2;
2433 
2434   /* The technique here, is that we make two format strings that
2435    * have the identical conversions in the identical order to the
2436    * original strings, but differ in the text in-between. We
2437    * then use the normal g_strdup_vprintf() to format the arguments
2438    * with the two new format strings. By comparing the results,
2439    * we can figure out what segments of the output come from
2440    * the original format string, and what from the arguments,
2441    * and thus know what portions of the string to escape.
2442    *
2443    * For instance, for:
2444    *
2445    *  g_markup_printf_escaped (&quot;%s ate %d apples&quot;, &quot;Susan &amp; Fred&quot;, 5);
2446    *
2447    * We form the two format strings &quot;%sX%dX&quot; and %sY%sY&quot;. The results
2448    * of formatting with those two strings are
2449    *
2450    * &quot;%sX%dX&quot; =&gt; &quot;Susan &amp; FredX5X&quot;
2451    * &quot;%sY%dY&quot; =&gt; &quot;Susan &amp; FredY5Y&quot;
2452    *
2453    * To find the span of the first argument, we find the first position
2454    * where the two arguments differ, which tells us that the first
2455    * argument formatted to &quot;Susan &amp; Fred&quot;. We then escape that
2456    * to &quot;Susan &amp; Fred&quot; and join up with the intermediate portions
2457    * of the format string and the second argument to get
2458    * &quot;Susan &amp; Fred ate 5 apples&quot;.
2459    */
2460 
2461   /* Create the two modified format strings
2462    */
2463   format1 = g_string_new (NULL);
2464   format2 = g_string_new (NULL);
2465   p = format;
2466   while (TRUE)
2467     {
2468       const char *after;
2469       const char *conv = find_conversion (p, &amp;after);
2470       if (!conv)
2471         break;
2472 
2473       g_string_append_len (format1, conv, after - conv);
2474       g_string_append_c (format1, &#39;X&#39;);
2475       g_string_append_len (format2, conv, after - conv);
2476       g_string_append_c (format2, &#39;Y&#39;);
2477 
2478       p = after;
2479     }
2480 
2481   /* Use them to format the arguments
2482    */
2483   G_VA_COPY (args2, args);
2484 
2485   output1 = g_strdup_vprintf (format1-&gt;str, args);
2486 
2487   if (!output1)
2488     {
2489       va_end (args2);
2490       goto cleanup;
2491     }
2492 
2493   output2 = g_strdup_vprintf (format2-&gt;str, args2);
2494   va_end (args2);
2495   if (!output2)
2496     goto cleanup;
2497   result = g_string_new (NULL);
2498 
2499   /* Iterate through the original format string again,
2500    * copying the non-conversion portions and the escaped
2501    * converted arguments to the output string.
2502    */
2503   op1 = output1;
2504   op2 = output2;
2505   p = format;
2506   while (TRUE)
2507     {
2508       const char *after;
2509       const char *output_start;
2510       const char *conv = find_conversion (p, &amp;after);
2511       char *escaped;
2512 
2513       if (!conv)        /* The end, after points to the trailing \0 */
2514         {
2515           g_string_append_len (result, p, after - p);
2516           break;
2517         }
2518 
2519       g_string_append_len (result, p, conv - p);
2520       output_start = op1;
2521       while (*op1 == *op2)
2522         {
2523           op1++;
2524           op2++;
2525         }
2526 
2527       escaped = g_markup_escape_text (output_start, op1 - output_start);
2528       g_string_append (result, escaped);
2529       g_free (escaped);
2530 
2531       p = after;
2532       op1++;
2533       op2++;
2534     }
2535 
2536  cleanup:
2537   g_string_free (format1, TRUE);
2538   g_string_free (format2, TRUE);
2539   g_free (output1);
2540   g_free (output2);
2541 
2542   if (result)
2543     return g_string_free (result, FALSE);
2544   else
2545     return NULL;
2546 }
2547 
2548 #ifdef GSTREAMER_LITE
2549 #ifndef G_OS_WIN32
2550 #pragma GCC diagnostic pop
2551 #endif // G_OS_WIN32
2552 #else // GSTREAMER_LITE
2553 #pragma GCC diagnostic pop
2554 #endif // GSTREAMER_LITE
2555 
2556 /**
2557  * g_markup_printf_escaped:
2558  * @format: printf() style format string
2559  * @...: the arguments to insert in the format string
2560  *
2561  * Formats arguments according to @format, escaping
2562  * all string and character arguments in the fashion
2563  * of g_markup_escape_text(). This is useful when you
2564  * want to insert literal strings into XML-style markup
2565  * output, without having to worry that the strings
2566  * might themselves contain markup.
2567  *
2568  * |[&lt;!-- language=&quot;C&quot; --&gt;
2569  * const char *store = &quot;Fortnum &amp; Mason&quot;;
2570  * const char *item = &quot;Tea&quot;;
2571  * char *output;
2572  *
2573  * output = g_markup_printf_escaped (&quot;&lt;purchase&gt;&quot;
2574  *                                   &quot;&lt;store&gt;%s&lt;/store&gt;&quot;
2575  *                                   &quot;&lt;item&gt;%s&lt;/item&gt;&quot;
2576  *                                   &quot;&lt;/purchase&gt;&quot;,
2577  *                                   store, item);
2578  * ]|
2579  *
2580  * Returns: newly allocated result from formatting
2581  *    operation. Free with g_free().
2582  *
2583  * Since: 2.4
2584  */
2585 gchar *
2586 g_markup_printf_escaped (const gchar *format, ...)
2587 {
2588   char *result;
2589   va_list args;
2590 
2591   va_start (args, format);
2592   result = g_markup_vprintf_escaped (format, args);
2593   va_end (args);
2594 
2595   return result;
2596 }
2597 
2598 static gboolean
2599 g_markup_parse_boolean (const char  *string,
2600                         gboolean    *value)
2601 {
2602   char const * const falses[] = { &quot;false&quot;, &quot;f&quot;, &quot;no&quot;, &quot;n&quot;, &quot;0&quot; };
2603   char const * const trues[] = { &quot;true&quot;, &quot;t&quot;, &quot;yes&quot;, &quot;y&quot;, &quot;1&quot; };
<a name="24" id="anc24"></a><span class="line-modified">2604   int i;</span>
2605 
2606   for (i = 0; i &lt; G_N_ELEMENTS (falses); i++)
2607     {
2608       if (g_ascii_strcasecmp (string, falses[i]) == 0)
2609         {
2610           if (value != NULL)
2611             *value = FALSE;
2612 
2613           return TRUE;
2614         }
2615     }
2616 
2617   for (i = 0; i &lt; G_N_ELEMENTS (trues); i++)
2618     {
2619       if (g_ascii_strcasecmp (string, trues[i]) == 0)
2620         {
2621           if (value != NULL)
2622             *value = TRUE;
2623 
2624           return TRUE;
2625         }
2626     }
2627 
2628   return FALSE;
2629 }
2630 
2631 /**
2632  * GMarkupCollectType:
2633  * @G_MARKUP_COLLECT_INVALID: used to terminate the list of attributes
2634  *     to collect
2635  * @G_MARKUP_COLLECT_STRING: collect the string pointer directly from
2636  *     the attribute_values[] array. Expects a parameter of type (const
2637  *     char **). If %G_MARKUP_COLLECT_OPTIONAL is specified and the
2638  *     attribute isn&#39;t present then the pointer will be set to %NULL
2639  * @G_MARKUP_COLLECT_STRDUP: as with %G_MARKUP_COLLECT_STRING, but
2640  *     expects a parameter of type (char **) and g_strdup()s the
2641  *     returned pointer. The pointer must be freed with g_free()
2642  * @G_MARKUP_COLLECT_BOOLEAN: expects a parameter of type (gboolean *)
2643  *     and parses the attribute value as a boolean. Sets %FALSE if the
2644  *     attribute isn&#39;t present. Valid boolean values consist of
2645  *     (case-insensitive) &quot;false&quot;, &quot;f&quot;, &quot;no&quot;, &quot;n&quot;, &quot;0&quot; and &quot;true&quot;, &quot;t&quot;,
2646  *     &quot;yes&quot;, &quot;y&quot;, &quot;1&quot;
2647  * @G_MARKUP_COLLECT_TRISTATE: as with %G_MARKUP_COLLECT_BOOLEAN, but
2648  *     in the case of a missing attribute a value is set that compares
2649  *     equal to neither %FALSE nor %TRUE G_MARKUP_COLLECT_OPTIONAL is
2650  *     implied
2651  * @G_MARKUP_COLLECT_OPTIONAL: can be bitwise ORed with the other fields.
2652  *     If present, allows the attribute not to appear. A default value
2653  *     is set depending on what value type is used
2654  *
2655  * A mixed enumerated type and flags field. You must specify one type
2656  * (string, strdup, boolean, tristate).  Additionally, you may  optionally
2657  * bitwise OR the type with the flag %G_MARKUP_COLLECT_OPTIONAL.
2658  *
2659  * It is likely that this enum will be extended in the future to
2660  * support other types.
2661  */
2662 
2663 /**
2664  * g_markup_collect_attributes:
2665  * @element_name: the current tag name
2666  * @attribute_names: the attribute names
2667  * @attribute_values: the attribute values
2668  * @error: a pointer to a #GError or %NULL
2669  * @first_type: the #GMarkupCollectType of the first attribute
2670  * @first_attr: the name of the first attribute
2671  * @...: a pointer to the storage location of the first attribute
2672  *     (or %NULL), followed by more types names and pointers, ending
2673  *     with %G_MARKUP_COLLECT_INVALID
2674  *
2675  * Collects the attributes of the element from the data passed to the
2676  * #GMarkupParser start_element function, dealing with common error
2677  * conditions and supporting boolean values.
2678  *
2679  * This utility function is not required to write a parser but can save
2680  * a lot of typing.
2681  *
2682  * The @element_name, @attribute_names, @attribute_values and @error
2683  * parameters passed to the start_element callback should be passed
2684  * unmodified to this function.
2685  *
2686  * Following these arguments is a list of &quot;supported&quot; attributes to collect.
2687  * It is an error to specify multiple attributes with the same name. If any
2688  * attribute not in the list appears in the @attribute_names array then an
2689  * unknown attribute error will result.
2690  *
2691  * The #GMarkupCollectType field allows specifying the type of collection
2692  * to perform and if a given attribute must appear or is optional.
2693  *
2694  * The attribute name is simply the name of the attribute to collect.
2695  *
2696  * The pointer should be of the appropriate type (see the descriptions
2697  * under #GMarkupCollectType) and may be %NULL in case a particular
2698  * attribute is to be allowed but ignored.
2699  *
2700  * This function deals with issuing errors for missing attributes
2701  * (of type %G_MARKUP_ERROR_MISSING_ATTRIBUTE), unknown attributes
2702  * (of type %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE) and duplicate
2703  * attributes (of type %G_MARKUP_ERROR_INVALID_CONTENT) as well
2704  * as parse errors for boolean-valued attributes (again of type
2705  * %G_MARKUP_ERROR_INVALID_CONTENT). In all of these cases %FALSE
2706  * will be returned and @error will be set as appropriate.
2707  *
2708  * Returns: %TRUE if successful
2709  *
2710  * Since: 2.16
2711  **/
2712 gboolean
2713 g_markup_collect_attributes (const gchar         *element_name,
2714                              const gchar        **attribute_names,
2715                              const gchar        **attribute_values,
2716                              GError             **error,
2717                              GMarkupCollectType   first_type,
2718                              const gchar         *first_attr,
2719                              ...)
2720 {
2721   GMarkupCollectType type;
2722   const gchar *attr;
2723   guint64 collected;
2724   int written;
2725   va_list ap;
2726   int i;
2727 
2728   type = first_type;
2729   attr = first_attr;
2730   collected = 0;
2731   written = 0;
2732 
2733   va_start (ap, first_attr);
2734   while (type != G_MARKUP_COLLECT_INVALID)
2735     {
2736       gboolean mandatory;
2737       const gchar *value;
2738 
2739       mandatory = !(type &amp; G_MARKUP_COLLECT_OPTIONAL);
2740       type &amp;= (G_MARKUP_COLLECT_OPTIONAL - 1);
2741 
2742       /* tristate records a value != TRUE and != FALSE
2743        * for the case where the attribute is missing
2744        */
2745       if (type == G_MARKUP_COLLECT_TRISTATE)
2746         mandatory = FALSE;
2747 
2748       for (i = 0; attribute_names[i]; i++)
2749         if (i &gt;= 40 || !(collected &amp; (G_GUINT64_CONSTANT(1) &lt;&lt; i)))
2750           if (!strcmp (attribute_names[i], attr))
2751             break;
2752 
2753       /* ISO C99 only promises that the user can pass up to 127 arguments.
2754        * Subtracting the first 4 arguments plus the final NULL and dividing
2755        * by 3 arguments per collected attribute, we are left with a maximum
2756        * number of supported attributes of (127 - 5) / 3 = 40.
2757        *
2758        * In reality, nobody is ever going to call us with anywhere close to
2759        * 40 attributes to collect, so it is safe to assume that if i &gt; 40
2760        * then the user has given some invalid or repeated arguments.  These
2761        * problems will be caught and reported at the end of the function.
2762        *
2763        * We know at this point that we have an error, but we don&#39;t know
2764        * what error it is, so just continue...
2765        */
2766       if (i &lt; 40)
2767         collected |= (G_GUINT64_CONSTANT(1) &lt;&lt; i);
2768 
2769       value = attribute_values[i];
2770 
2771       if (value == NULL &amp;&amp; mandatory)
2772         {
2773           g_set_error (error, G_MARKUP_ERROR,
2774                        G_MARKUP_ERROR_MISSING_ATTRIBUTE,
2775                        &quot;element &#39;%s&#39; requires attribute &#39;%s&#39;&quot;,
2776                        element_name, attr);
2777 
2778           va_end (ap);
2779           goto failure;
2780         }
2781 
2782       switch (type)
2783         {
2784         case G_MARKUP_COLLECT_STRING:
2785           {
2786             const char **str_ptr;
2787 
2788             str_ptr = va_arg (ap, const char **);
2789 
2790             if (str_ptr != NULL)
2791               *str_ptr = value;
2792           }
2793           break;
2794 
2795         case G_MARKUP_COLLECT_STRDUP:
2796           {
2797             char **str_ptr;
2798 
2799             str_ptr = va_arg (ap, char **);
2800 
2801             if (str_ptr != NULL)
2802               *str_ptr = g_strdup (value);
2803           }
2804           break;
2805 
2806         case G_MARKUP_COLLECT_BOOLEAN:
2807         case G_MARKUP_COLLECT_TRISTATE:
2808           if (value == NULL)
2809             {
2810               gboolean *bool_ptr;
2811 
2812               bool_ptr = va_arg (ap, gboolean *);
2813 
2814               if (bool_ptr != NULL)
2815                 {
2816                   if (type == G_MARKUP_COLLECT_TRISTATE)
2817                     /* constructivists rejoice!
2818                      * neither false nor true...
2819                      */
2820                     *bool_ptr = -1;
2821 
2822                   else /* G_MARKUP_COLLECT_BOOLEAN */
2823                     *bool_ptr = FALSE;
2824                 }
2825             }
2826           else
2827             {
2828               if (!g_markup_parse_boolean (value, va_arg (ap, gboolean *)))
2829                 {
2830                   g_set_error (error, G_MARKUP_ERROR,
2831                                G_MARKUP_ERROR_INVALID_CONTENT,
2832                                &quot;element &#39;%s&#39;, attribute &#39;%s&#39;, value &#39;%s&#39; &quot;
2833                                &quot;cannot be parsed as a boolean value&quot;,
2834                                element_name, attr, value);
2835 
2836                   va_end (ap);
2837                   goto failure;
2838                 }
2839             }
2840 
2841           break;
2842 
2843         default:
2844           g_assert_not_reached ();
2845         }
2846 
<a name="25" id="anc25"></a><span class="line-removed">2847       type = va_arg (ap, GMarkupCollectType);</span>
<span class="line-removed">2848       attr = va_arg (ap, const char *);</span>
2849       written++;
<a name="26" id="anc26"></a>


2850     }
2851   va_end (ap);
2852 
2853   /* ensure we collected all the arguments */
2854   for (i = 0; attribute_names[i]; i++)
2855     if ((collected &amp; (G_GUINT64_CONSTANT(1) &lt;&lt; i)) == 0)
2856       {
2857         /* attribute not collected:  could be caused by two things.
2858          *
2859          * 1) it doesn&#39;t exist in our list of attributes
2860          * 2) it existed but was matched by a duplicate attribute earlier
2861          *
2862          * find out.
2863          */
2864         int j;
2865 
2866         for (j = 0; j &lt; i; j++)
2867           if (strcmp (attribute_names[i], attribute_names[j]) == 0)
2868             /* duplicate! */
2869             break;
2870 
2871         /* j is now the first occurrence of attribute_names[i] */
2872         if (i == j)
2873           g_set_error (error, G_MARKUP_ERROR,
2874                        G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE,
2875                        &quot;attribute &#39;%s&#39; invalid for element &#39;%s&#39;&quot;,
2876                        attribute_names[i], element_name);
2877         else
2878           g_set_error (error, G_MARKUP_ERROR,
2879                        G_MARKUP_ERROR_INVALID_CONTENT,
2880                        &quot;attribute &#39;%s&#39; given multiple times for element &#39;%s&#39;&quot;,
2881                        attribute_names[i], element_name);
2882 
2883         goto failure;
2884       }
2885 
2886   return TRUE;
2887 
2888 failure:
2889   /* replay the above to free allocations */
2890   type = first_type;
2891   attr = first_attr;
2892 
2893   va_start (ap, first_attr);
2894   while (type != G_MARKUP_COLLECT_INVALID)
2895     {
2896       gpointer ptr;
2897 
2898       ptr = va_arg (ap, gpointer);
2899 
2900       if (ptr != NULL)
2901         {
2902           switch (type &amp; (G_MARKUP_COLLECT_OPTIONAL - 1))
2903             {
2904             case G_MARKUP_COLLECT_STRDUP:
2905               if (written)
2906                 g_free (*(char **) ptr);
<a name="27" id="anc27"></a>

2907 
2908             case G_MARKUP_COLLECT_STRING:
2909               *(char **) ptr = NULL;
2910               break;
2911 
2912             case G_MARKUP_COLLECT_BOOLEAN:
2913               *(gboolean *) ptr = FALSE;
2914               break;
2915 
2916             case G_MARKUP_COLLECT_TRISTATE:
2917               *(gboolean *) ptr = -1;
2918               break;
2919             }
2920         }
2921 
2922       type = va_arg (ap, GMarkupCollectType);
<a name="28" id="anc28"></a><span class="line-modified">2923       attr = va_arg (ap, const char *);</span>

2924     }
2925   va_end (ap);
2926 
2927   return FALSE;
2928 }
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>