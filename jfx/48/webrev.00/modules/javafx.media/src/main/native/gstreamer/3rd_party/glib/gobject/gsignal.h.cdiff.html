<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gsignal.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gsignal.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gsourceclosure.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gsignal.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 19,38 ***</span>
  
  #if !defined (__GLIB_GOBJECT_H_INSIDE__) &amp;&amp; !defined (GOBJECT_COMPILATION)
  #error &quot;Only &lt;glib-object.h&gt; can be included directly.&quot;
  #endif
  
<span class="line-modified">! #include    &lt;gobject/gclosure.h&gt;</span>
<span class="line-modified">! #include    &lt;gobject/gvalue.h&gt;</span>
<span class="line-modified">! #include    &lt;gobject/gparam.h&gt;</span>
<span class="line-modified">! #include    &lt;gobject/gmarshal.h&gt;</span>
  
  G_BEGIN_DECLS
  
  /* --- typedefs --- */
<span class="line-modified">! typedef struct _GSignalQuery         GSignalQuery;</span>
<span class="line-modified">! typedef struct _GSignalInvocationHint    GSignalInvocationHint;</span>
  /**
   * GSignalCMarshaller:
   *
   * This is the signature of marshaller functions, required to marshall
   * arrays of parameter values to signal emissions into C language callback
   * invocations. It is merely an alias to #GClosureMarshal since the #GClosure
   * mechanism takes over responsibility of actual function invocation for the
   * signal system.
   */
<span class="line-modified">! typedef GClosureMarshal          GSignalCMarshaller;</span>
  /**
   * GSignalCVaMarshaller:
   *
   * This is the signature of va_list marshaller functions, an optional
   * marshaller that can be used in some situations to avoid
   * marshalling the signal argument into GValues.
   */
<span class="line-modified">! typedef GVaClosureMarshal        GSignalCVaMarshaller;</span>
  /**
   * GSignalEmissionHook:
   * @ihint: Signal invocation hint, see #GSignalInvocationHint.
   * @n_param_values: the number of parameters to the function, including
   *  the instance on which the signal was emitted.
<span class="line-new-header">--- 19,38 ---</span>
  
  #if !defined (__GLIB_GOBJECT_H_INSIDE__) &amp;&amp; !defined (GOBJECT_COMPILATION)
  #error &quot;Only &lt;glib-object.h&gt; can be included directly.&quot;
  #endif
  
<span class="line-modified">! #include  &lt;gobject/gclosure.h&gt;</span>
<span class="line-modified">! #include  &lt;gobject/gvalue.h&gt;</span>
<span class="line-modified">! #include  &lt;gobject/gparam.h&gt;</span>
<span class="line-modified">! #include  &lt;gobject/gmarshal.h&gt;</span>
  
  G_BEGIN_DECLS
  
  /* --- typedefs --- */
<span class="line-modified">! typedef struct _GSignalQuery     GSignalQuery;</span>
<span class="line-modified">! typedef struct _GSignalInvocationHint  GSignalInvocationHint;</span>
  /**
   * GSignalCMarshaller:
   *
   * This is the signature of marshaller functions, required to marshall
   * arrays of parameter values to signal emissions into C language callback
   * invocations. It is merely an alias to #GClosureMarshal since the #GClosure
   * mechanism takes over responsibility of actual function invocation for the
   * signal system.
   */
<span class="line-modified">! typedef GClosureMarshal      GSignalCMarshaller;</span>
  /**
   * GSignalCVaMarshaller:
   *
   * This is the signature of va_list marshaller functions, an optional
   * marshaller that can be used in some situations to avoid
   * marshalling the signal argument into GValues.
   */
<span class="line-modified">! typedef GVaClosureMarshal    GSignalCVaMarshaller;</span>
  /**
   * GSignalEmissionHook:
   * @ihint: Signal invocation hint, see #GSignalInvocationHint.
   * @n_param_values: the number of parameters to the function, including
   *  the instance on which the signal was emitted.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,13 ***</span>
   *
   * Returns: whether it wants to stay connected. If it returns %FALSE, the signal
   *  hook is disconnected (and destroyed).
   */
  typedef gboolean (*GSignalEmissionHook) (GSignalInvocationHint *ihint,
<span class="line-modified">!                      guint          n_param_values,</span>
<span class="line-modified">!                      const GValue          *param_values,</span>
<span class="line-modified">!                      gpointer       data);</span>
  /**
   * GSignalAccumulator:
   * @ihint: Signal invocation hint, see #GSignalInvocationHint.
   * @return_accu: Accumulator to collect callback return values in, this
   *  is the return value of the current signal emission.
<span class="line-new-header">--- 66,13 ---</span>
   *
   * Returns: whether it wants to stay connected. If it returns %FALSE, the signal
   *  hook is disconnected (and destroyed).
   */
  typedef gboolean (*GSignalEmissionHook) (GSignalInvocationHint *ihint,
<span class="line-modified">!            guint      n_param_values,</span>
<span class="line-modified">!            const GValue        *param_values,</span>
<span class="line-modified">!            gpointer   data);</span>
  /**
   * GSignalAccumulator:
   * @ihint: Signal invocation hint, see #GSignalInvocationHint.
   * @return_accu: Accumulator to collect callback return values in, this
   *  is the return value of the current signal emission.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,13 ***</span>
   * Returns: The accumulator function returns whether the signal emission
   *  should be aborted. Returning %FALSE means to abort the
   *  current emission and %TRUE is returned for continuation.
   */
  typedef gboolean (*GSignalAccumulator)  (GSignalInvocationHint *ihint,
<span class="line-modified">!                      GValue            *return_accu,</span>
<span class="line-modified">!                      const GValue          *handler_return,</span>
<span class="line-modified">!                      gpointer               data);</span>
  
  
  /* --- run, match and connect types --- */
  /**
   * GSignalFlags:
<span class="line-new-header">--- 89,13 ---</span>
   * Returns: The accumulator function returns whether the signal emission
   *  should be aborted. Returning %FALSE means to abort the
   *  current emission and %TRUE is returned for continuation.
   */
  typedef gboolean (*GSignalAccumulator)  (GSignalInvocationHint *ihint,
<span class="line-modified">!            GValue          *return_accu,</span>
<span class="line-modified">!            const GValue        *handler_return,</span>
<span class="line-modified">!            gpointer               data);</span>
  
  
  /* --- run, match and connect types --- */
  /**
   * GSignalFlags:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 124,16 ***</span>
   * signal description outlines how especially the RUN flags control the
   * stages of a signal emission.
   */
  typedef enum
  {
<span class="line-modified">!   G_SIGNAL_RUN_FIRST    = 1 &lt;&lt; 0,</span>
    G_SIGNAL_RUN_LAST = 1 &lt;&lt; 1,
    G_SIGNAL_RUN_CLEANUP  = 1 &lt;&lt; 2,
<span class="line-modified">!   G_SIGNAL_NO_RECURSE   = 1 &lt;&lt; 3,</span>
    G_SIGNAL_DETAILED = 1 &lt;&lt; 4,
<span class="line-modified">!   G_SIGNAL_ACTION   = 1 &lt;&lt; 5,</span>
    G_SIGNAL_NO_HOOKS = 1 &lt;&lt; 6,
    G_SIGNAL_MUST_COLLECT = 1 &lt;&lt; 7,
    G_SIGNAL_DEPRECATED   = 1 &lt;&lt; 8
  } GSignalFlags;
  /**
<span class="line-new-header">--- 124,16 ---</span>
   * signal description outlines how especially the RUN flags control the
   * stages of a signal emission.
   */
  typedef enum
  {
<span class="line-modified">!   G_SIGNAL_RUN_FIRST  = 1 &lt;&lt; 0,</span>
    G_SIGNAL_RUN_LAST = 1 &lt;&lt; 1,
    G_SIGNAL_RUN_CLEANUP  = 1 &lt;&lt; 2,
<span class="line-modified">!   G_SIGNAL_NO_RECURSE = 1 &lt;&lt; 3,</span>
    G_SIGNAL_DETAILED = 1 &lt;&lt; 4,
<span class="line-modified">!   G_SIGNAL_ACTION = 1 &lt;&lt; 5,</span>
    G_SIGNAL_NO_HOOKS = 1 &lt;&lt; 6,
    G_SIGNAL_MUST_COLLECT = 1 &lt;&lt; 7,
    G_SIGNAL_DEPRECATED   = 1 &lt;&lt; 8
  } GSignalFlags;
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 152,11 ***</span>
   * The connection flags are used to specify the behaviour of a signal&#39;s
   * connection.
   */
  typedef enum
  {
<span class="line-modified">!   G_CONNECT_AFTER   = 1 &lt;&lt; 0,</span>
    G_CONNECT_SWAPPED = 1 &lt;&lt; 1
  } GConnectFlags;
  /**
   * GSignalMatchType:
   * @G_SIGNAL_MATCH_ID: The signal id must be equal.
<span class="line-new-header">--- 152,11 ---</span>
   * The connection flags are used to specify the behaviour of a signal&#39;s
   * connection.
   */
  typedef enum
  {
<span class="line-modified">!   G_CONNECT_AFTER = 1 &lt;&lt; 0,</span>
    G_CONNECT_SWAPPED = 1 &lt;&lt; 1
  } GConnectFlags;
  /**
   * GSignalMatchType:
   * @G_SIGNAL_MATCH_ID: The signal id must be equal.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,12 ***</span>
  typedef enum
  {
    G_SIGNAL_MATCH_ID    = 1 &lt;&lt; 0,
    G_SIGNAL_MATCH_DETAIL    = 1 &lt;&lt; 1,
    G_SIGNAL_MATCH_CLOSURE   = 1 &lt;&lt; 2,
<span class="line-modified">!   G_SIGNAL_MATCH_FUNC      = 1 &lt;&lt; 3,</span>
<span class="line-modified">!   G_SIGNAL_MATCH_DATA      = 1 &lt;&lt; 4,</span>
    G_SIGNAL_MATCH_UNBLOCKED = 1 &lt;&lt; 5
  } GSignalMatchType;
  /**
   * G_SIGNAL_MATCH_MASK:
   *
<span class="line-new-header">--- 173,12 ---</span>
  typedef enum
  {
    G_SIGNAL_MATCH_ID    = 1 &lt;&lt; 0,
    G_SIGNAL_MATCH_DETAIL    = 1 &lt;&lt; 1,
    G_SIGNAL_MATCH_CLOSURE   = 1 &lt;&lt; 2,
<span class="line-modified">!   G_SIGNAL_MATCH_FUNC    = 1 &lt;&lt; 3,</span>
<span class="line-modified">!   G_SIGNAL_MATCH_DATA    = 1 &lt;&lt; 4,</span>
    G_SIGNAL_MATCH_UNBLOCKED = 1 &lt;&lt; 5
  } GSignalMatchType;
  /**
   * G_SIGNAL_MATCH_MASK:
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 220,12 ***</span>
   * The #GSignalInvocationHint structure is used to pass on additional information
   * to callbacks during a signal emission.
   */
  struct _GSignalInvocationHint
  {
<span class="line-modified">!   guint     signal_id;</span>
<span class="line-modified">!   GQuark    detail;</span>
    GSignalFlags  run_type;
  };
  /**
   * GSignalQuery:
   * @signal_id: The signal id of the signal being queried, or 0 if the
<span class="line-new-header">--- 220,12 ---</span>
   * The #GSignalInvocationHint structure is used to pass on additional information
   * to callbacks during a signal emission.
   */
  struct _GSignalInvocationHint
  {
<span class="line-modified">!   guint   signal_id;</span>
<span class="line-modified">!   GQuark  detail;</span>
    GSignalFlags  run_type;
  };
  /**
   * GSignalQuery:
   * @signal_id: The signal id of the signal being queried, or 0 if the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 246,54 ***</span>
   * A structure holding in-depth information for a specific signal. It is
   * filled in by the g_signal_query() function.
   */
  struct _GSignalQuery
  {
<span class="line-modified">!   guint     signal_id;</span>
    const gchar  *signal_name;
<span class="line-modified">!   GType     itype;</span>
    GSignalFlags  signal_flags;
<span class="line-modified">!   GType     return_type; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */</span>
<span class="line-modified">!   guint     n_params;</span>
    const GType  *param_types; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */
  };
  
  
  /* --- signals --- */
  GLIB_AVAILABLE_IN_ALL
  guint                 g_signal_newv         (const gchar        *signal_name,
<span class="line-modified">!                          GType               itype,</span>
<span class="line-modified">!                          GSignalFlags        signal_flags,</span>
<span class="line-modified">!                          GClosure           *class_closure,</span>
<span class="line-modified">!                          GSignalAccumulator  accumulator,</span>
<span class="line-modified">!                          gpointer        accu_data,</span>
<span class="line-modified">!                          GSignalCMarshaller  c_marshaller,</span>
<span class="line-modified">!                          GType               return_type,</span>
<span class="line-modified">!                          guint               n_params,</span>
<span class="line-modified">!                          GType              *param_types);</span>
  GLIB_AVAILABLE_IN_ALL
  guint                 g_signal_new_valist   (const gchar        *signal_name,
<span class="line-modified">!                          GType               itype,</span>
<span class="line-modified">!                          GSignalFlags        signal_flags,</span>
<span class="line-modified">!                          GClosure           *class_closure,</span>
<span class="line-modified">!                          GSignalAccumulator  accumulator,</span>
<span class="line-modified">!                          gpointer        accu_data,</span>
<span class="line-modified">!                          GSignalCMarshaller  c_marshaller,</span>
<span class="line-modified">!                          GType               return_type,</span>
<span class="line-modified">!                          guint               n_params,</span>
<span class="line-modified">!                          va_list             args);</span>
  GLIB_AVAILABLE_IN_ALL
  guint                 g_signal_new          (const gchar        *signal_name,
<span class="line-modified">!                          GType               itype,</span>
<span class="line-modified">!                          GSignalFlags        signal_flags,</span>
<span class="line-modified">!                          guint               class_offset,</span>
<span class="line-modified">!                          GSignalAccumulator  accumulator,</span>
<span class="line-modified">!                          gpointer        accu_data,</span>
<span class="line-modified">!                          GSignalCMarshaller  c_marshaller,</span>
<span class="line-modified">!                          GType               return_type,</span>
<span class="line-modified">!                          guint               n_params,</span>
<span class="line-modified">!                          ...);</span>
  GLIB_AVAILABLE_IN_ALL
  guint            g_signal_new_class_handler (const gchar        *signal_name,
                                               GType               itype,
                                               GSignalFlags        signal_flags,
                                               GCallback           class_handler,
<span class="line-new-header">--- 246,54 ---</span>
   * A structure holding in-depth information for a specific signal. It is
   * filled in by the g_signal_query() function.
   */
  struct _GSignalQuery
  {
<span class="line-modified">!   guint   signal_id;</span>
    const gchar  *signal_name;
<span class="line-modified">!   GType   itype;</span>
    GSignalFlags  signal_flags;
<span class="line-modified">!   GType   return_type; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */</span>
<span class="line-modified">!   guint   n_params;</span>
    const GType  *param_types; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */
  };
  
  
  /* --- signals --- */
  GLIB_AVAILABLE_IN_ALL
  guint                 g_signal_newv         (const gchar        *signal_name,
<span class="line-modified">!                GType               itype,</span>
<span class="line-modified">!                GSignalFlags        signal_flags,</span>
<span class="line-modified">!                GClosure           *class_closure,</span>
<span class="line-modified">!                GSignalAccumulator  accumulator,</span>
<span class="line-modified">!                gpointer    accu_data,</span>
<span class="line-modified">!                GSignalCMarshaller  c_marshaller,</span>
<span class="line-modified">!                GType               return_type,</span>
<span class="line-modified">!                guint               n_params,</span>
<span class="line-modified">!                GType              *param_types);</span>
  GLIB_AVAILABLE_IN_ALL
  guint                 g_signal_new_valist   (const gchar        *signal_name,
<span class="line-modified">!                GType               itype,</span>
<span class="line-modified">!                GSignalFlags        signal_flags,</span>
<span class="line-modified">!                GClosure           *class_closure,</span>
<span class="line-modified">!                GSignalAccumulator  accumulator,</span>
<span class="line-modified">!                gpointer    accu_data,</span>
<span class="line-modified">!                GSignalCMarshaller  c_marshaller,</span>
<span class="line-modified">!                GType               return_type,</span>
<span class="line-modified">!                guint               n_params,</span>
<span class="line-modified">!                va_list             args);</span>
  GLIB_AVAILABLE_IN_ALL
  guint                 g_signal_new          (const gchar        *signal_name,
<span class="line-modified">!                GType               itype,</span>
<span class="line-modified">!                GSignalFlags        signal_flags,</span>
<span class="line-modified">!                guint               class_offset,</span>
<span class="line-modified">!                GSignalAccumulator  accumulator,</span>
<span class="line-modified">!                gpointer    accu_data,</span>
<span class="line-modified">!                GSignalCMarshaller  c_marshaller,</span>
<span class="line-modified">!                GType               return_type,</span>
<span class="line-modified">!                guint               n_params,</span>
<span class="line-modified">!                ...);</span>
  GLIB_AVAILABLE_IN_ALL
  guint            g_signal_new_class_handler (const gchar        *signal_name,
                                               GType               itype,
                                               GSignalFlags        signal_flags,
                                               GCallback           class_handler,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 303,141 ***</span>
                                               GType               return_type,
                                               guint               n_params,
                                               ...);
  GLIB_AVAILABLE_IN_ALL
  void             g_signal_set_va_marshaller (guint              signal_id,
<span class="line-modified">!                          GType              instance_type,</span>
<span class="line-modified">!                          GSignalCVaMarshaller va_marshaller);</span>
  
  GLIB_AVAILABLE_IN_ALL
  void                  g_signal_emitv        (const GValue       *instance_and_params,
<span class="line-modified">!                          guint               signal_id,</span>
<span class="line-modified">!                          GQuark              detail,</span>
<span class="line-modified">!                          GValue             *return_value);</span>
  GLIB_AVAILABLE_IN_ALL
  void                  g_signal_emit_valist  (gpointer            instance,
<span class="line-modified">!                          guint               signal_id,</span>
<span class="line-modified">!                          GQuark              detail,</span>
<span class="line-modified">!                          va_list             var_args);</span>
  GLIB_AVAILABLE_IN_ALL
  void                  g_signal_emit         (gpointer            instance,
<span class="line-modified">!                          guint               signal_id,</span>
<span class="line-modified">!                          GQuark              detail,</span>
<span class="line-modified">!                          ...);</span>
  GLIB_AVAILABLE_IN_ALL
  void                  g_signal_emit_by_name (gpointer            instance,
<span class="line-modified">!                          const gchar        *detailed_signal,</span>
<span class="line-modified">!                          ...);</span>
  GLIB_AVAILABLE_IN_ALL
  guint                 g_signal_lookup       (const gchar        *name,
<span class="line-modified">!                          GType               itype);</span>
  GLIB_AVAILABLE_IN_ALL
  const gchar *         g_signal_name         (guint               signal_id);
  GLIB_AVAILABLE_IN_ALL
  void                  g_signal_query        (guint               signal_id,
<span class="line-modified">!                          GSignalQuery       *query);</span>
  GLIB_AVAILABLE_IN_ALL
  guint*                g_signal_list_ids     (GType               itype,
<span class="line-modified">!                          guint              *n_ids);</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gboolean          g_signal_parse_name   (const gchar    *detailed_signal,</span>
<span class="line-modified">!                          GType       itype,</span>
<span class="line-modified">!                          guint      *signal_id_p,</span>
<span class="line-modified">!                          GQuark     *detail_p,</span>
<span class="line-modified">!                          gboolean        force_detail_quark);</span>
  GLIB_AVAILABLE_IN_ALL
  GSignalInvocationHint* g_signal_get_invocation_hint (gpointer    instance);
  
  
  /* --- signal emissions --- */
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! void    g_signal_stop_emission          (gpointer         instance,</span>
<span class="line-modified">!                          guint        signal_id,</span>
<span class="line-modified">!                          GQuark       detail);</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! void    g_signal_stop_emission_by_name      (gpointer         instance,</span>
<span class="line-modified">!                          const gchar     *detailed_signal);</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gulong  g_signal_add_emission_hook      (guint        signal_id,</span>
<span class="line-modified">!                          GQuark       detail,</span>
<span class="line-modified">!                          GSignalEmissionHook  hook_func,</span>
<span class="line-modified">!                          gpointer             hook_data,</span>
<span class="line-modified">!                          GDestroyNotify   data_destroy);</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! void    g_signal_remove_emission_hook       (guint        signal_id,</span>
<span class="line-modified">!                          gulong       hook_id);</span>
  
  
  /* --- signal handlers --- */
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gboolean g_signal_has_handler_pending         (gpointer       instance,</span>
<span class="line-modified">!                            guint          signal_id,</span>
<span class="line-modified">!                            GQuark         detail,</span>
<span class="line-modified">!                            gboolean       may_be_blocked);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! gulong   g_signal_connect_closure_by_id       (gpointer       instance,</span>
<span class="line-modified">!                            guint          signal_id,</span>
<span class="line-modified">!                            GQuark         detail,</span>
<span class="line-modified">!                            GClosure      *closure,</span>
<span class="line-modified">!                            gboolean       after);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! gulong   g_signal_connect_closure         (gpointer       instance,</span>
<span class="line-modified">!                            const gchar       *detailed_signal,</span>
<span class="line-modified">!                            GClosure      *closure,</span>
<span class="line-modified">!                            gboolean       after);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! gulong   g_signal_connect_data            (gpointer       instance,</span>
<span class="line-modified">!                            const gchar   *detailed_signal,</span>
<span class="line-modified">!                            GCallback      c_handler,</span>
<span class="line-modified">!                            gpointer       data,</span>
<span class="line-modified">!                            GClosureNotify     destroy_data,</span>
<span class="line-modified">!                            GConnectFlags      connect_flags);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! void     g_signal_handler_block           (gpointer       instance,</span>
<span class="line-modified">!                            gulong         handler_id);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! void     g_signal_handler_unblock         (gpointer       instance,</span>
<span class="line-modified">!                            gulong         handler_id);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! void     g_signal_handler_disconnect          (gpointer       instance,</span>
<span class="line-modified">!                            gulong         handler_id);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! gboolean g_signal_handler_is_connected        (gpointer       instance,</span>
<span class="line-modified">!                            gulong         handler_id);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! gulong   g_signal_handler_find            (gpointer       instance,</span>
<span class="line-modified">!                            GSignalMatchType   mask,</span>
<span class="line-modified">!                            guint          signal_id,</span>
<span class="line-modified">!                            GQuark         detail,</span>
<span class="line-modified">!                            GClosure      *closure,</span>
<span class="line-modified">!                            gpointer       func,</span>
<span class="line-modified">!                            gpointer       data);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! guint    g_signal_handlers_block_matched      (gpointer       instance,</span>
<span class="line-modified">!                            GSignalMatchType   mask,</span>
<span class="line-modified">!                            guint          signal_id,</span>
<span class="line-modified">!                            GQuark         detail,</span>
<span class="line-modified">!                            GClosure      *closure,</span>
<span class="line-modified">!                            gpointer       func,</span>
<span class="line-modified">!                            gpointer       data);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! guint    g_signal_handlers_unblock_matched    (gpointer       instance,</span>
<span class="line-modified">!                            GSignalMatchType   mask,</span>
<span class="line-modified">!                            guint          signal_id,</span>
<span class="line-modified">!                            GQuark         detail,</span>
<span class="line-modified">!                            GClosure      *closure,</span>
<span class="line-modified">!                            gpointer       func,</span>
<span class="line-modified">!                            gpointer       data);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! guint    g_signal_handlers_disconnect_matched (gpointer       instance,</span>
<span class="line-modified">!                            GSignalMatchType   mask,</span>
<span class="line-modified">!                            guint          signal_id,</span>
<span class="line-modified">!                            GQuark         detail,</span>
<span class="line-modified">!                            GClosure      *closure,</span>
<span class="line-modified">!                            gpointer       func,</span>
<span class="line-modified">!                            gpointer       data);</span>
  
  
  /* --- overriding and chaining --- */
  GLIB_AVAILABLE_IN_ALL
  void    g_signal_override_class_closure       (guint              signal_id,
                                                 GType              instance_type,
<span class="line-new-header">--- 303,157 ---</span>
                                               GType               return_type,
                                               guint               n_params,
                                               ...);
  GLIB_AVAILABLE_IN_ALL
  void             g_signal_set_va_marshaller (guint              signal_id,
<span class="line-modified">!                GType              instance_type,</span>
<span class="line-modified">!                GSignalCVaMarshaller va_marshaller);</span>
  
  GLIB_AVAILABLE_IN_ALL
  void                  g_signal_emitv        (const GValue       *instance_and_params,
<span class="line-modified">!                guint               signal_id,</span>
<span class="line-modified">!                GQuark              detail,</span>
<span class="line-modified">!                GValue             *return_value);</span>
  GLIB_AVAILABLE_IN_ALL
  void                  g_signal_emit_valist  (gpointer            instance,
<span class="line-modified">!                guint               signal_id,</span>
<span class="line-modified">!                GQuark              detail,</span>
<span class="line-modified">!                va_list             var_args);</span>
  GLIB_AVAILABLE_IN_ALL
  void                  g_signal_emit         (gpointer            instance,
<span class="line-modified">!                guint               signal_id,</span>
<span class="line-modified">!                GQuark              detail,</span>
<span class="line-modified">!                ...);</span>
  GLIB_AVAILABLE_IN_ALL
  void                  g_signal_emit_by_name (gpointer            instance,
<span class="line-modified">!                const gchar        *detailed_signal,</span>
<span class="line-modified">!                ...);</span>
  GLIB_AVAILABLE_IN_ALL
  guint                 g_signal_lookup       (const gchar        *name,
<span class="line-modified">!                GType               itype);</span>
  GLIB_AVAILABLE_IN_ALL
  const gchar *         g_signal_name         (guint               signal_id);
  GLIB_AVAILABLE_IN_ALL
  void                  g_signal_query        (guint               signal_id,
<span class="line-modified">!                GSignalQuery       *query);</span>
  GLIB_AVAILABLE_IN_ALL
  guint*                g_signal_list_ids     (GType               itype,
<span class="line-modified">!                guint              *n_ids);</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gboolean        g_signal_parse_name   (const gchar  *detailed_signal,</span>
<span class="line-modified">!                GType     itype,</span>
<span class="line-modified">!                guint    *signal_id_p,</span>
<span class="line-modified">!                GQuark   *detail_p,</span>
<span class="line-modified">!                gboolean    force_detail_quark);</span>
  GLIB_AVAILABLE_IN_ALL
  GSignalInvocationHint* g_signal_get_invocation_hint (gpointer    instance);
  
  
  /* --- signal emissions --- */
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! void  g_signal_stop_emission        (gpointer     instance,</span>
<span class="line-modified">!                guint      signal_id,</span>
<span class="line-modified">!                GQuark     detail);</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! void  g_signal_stop_emission_by_name      (gpointer     instance,</span>
<span class="line-modified">!                const gchar   *detailed_signal);</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gulong  g_signal_add_emission_hook      (guint      signal_id,</span>
<span class="line-modified">!                GQuark     detail,</span>
<span class="line-modified">!                GSignalEmissionHook  hook_func,</span>
<span class="line-modified">!                gpointer           hook_data,</span>
<span class="line-modified">!                GDestroyNotify   data_destroy);</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! void  g_signal_remove_emission_hook     (guint      signal_id,</span>
<span class="line-modified">!                gulong     hook_id);</span>
  
  
  /* --- signal handlers --- */
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gboolean g_signal_has_handler_pending       (gpointer     instance,</span>
<span class="line-modified">!                  guint      signal_id,</span>
<span class="line-modified">!                  GQuark     detail,</span>
<span class="line-modified">!                  gboolean     may_be_blocked);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! gulong   g_signal_connect_closure_by_id       (gpointer     instance,</span>
<span class="line-modified">!                  guint      signal_id,</span>
<span class="line-modified">!                  GQuark     detail,</span>
<span class="line-modified">!                  GClosure    *closure,</span>
<span class="line-modified">!                  gboolean     after);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! gulong   g_signal_connect_closure       (gpointer     instance,</span>
<span class="line-modified">!                  const gchar       *detailed_signal,</span>
<span class="line-modified">!                  GClosure    *closure,</span>
<span class="line-modified">!                  gboolean     after);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! gulong   g_signal_connect_data          (gpointer     instance,</span>
<span class="line-modified">!                  const gchar   *detailed_signal,</span>
<span class="line-modified">!                  GCallback    c_handler,</span>
<span class="line-modified">!                  gpointer     data,</span>
<span class="line-modified">!                  GClosureNotify   destroy_data,</span>
<span class="line-modified">!                  GConnectFlags    connect_flags);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! void   g_signal_handler_block         (gpointer     instance,</span>
<span class="line-modified">!                  gulong     handler_id);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! void   g_signal_handler_unblock       (gpointer     instance,</span>
<span class="line-modified">!                  gulong     handler_id);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! void   g_signal_handler_disconnect        (gpointer     instance,</span>
<span class="line-modified">!                  gulong     handler_id);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! gboolean g_signal_handler_is_connected        (gpointer     instance,</span>
<span class="line-modified">!                  gulong     handler_id);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! gulong   g_signal_handler_find          (gpointer     instance,</span>
<span class="line-modified">!                  GSignalMatchType   mask,</span>
<span class="line-modified">!                  guint      signal_id,</span>
<span class="line-modified">!                  GQuark     detail,</span>
<span class="line-modified">!                  GClosure    *closure,</span>
<span class="line-modified">!                  gpointer     func,</span>
<span class="line-modified">!                  gpointer     data);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! guint  g_signal_handlers_block_matched      (gpointer     instance,</span>
<span class="line-modified">!                  GSignalMatchType   mask,</span>
<span class="line-modified">!                  guint      signal_id,</span>
<span class="line-modified">!                  GQuark     detail,</span>
<span class="line-modified">!                  GClosure    *closure,</span>
<span class="line-modified">!                  gpointer     func,</span>
<span class="line-modified">!                  gpointer     data);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! guint  g_signal_handlers_unblock_matched    (gpointer     instance,</span>
<span class="line-modified">!                  GSignalMatchType   mask,</span>
<span class="line-modified">!                  guint      signal_id,</span>
<span class="line-modified">!                  GQuark     detail,</span>
<span class="line-modified">!                  GClosure    *closure,</span>
<span class="line-modified">!                  gpointer     func,</span>
<span class="line-modified">!                  gpointer     data);</span>
<span class="line-modified">! GLIB_AVAILABLE_IN_ALL</span>
<span class="line-modified">! guint  g_signal_handlers_disconnect_matched (gpointer     instance,</span>
<span class="line-modified">!                  GSignalMatchType   mask,</span>
<span class="line-modified">!                  guint      signal_id,</span>
<span class="line-modified">!                  GQuark     detail,</span>
<span class="line-modified">!                  GClosure    *closure,</span>
<span class="line-modified">!                  gpointer     func,</span>
<span class="line-modified">!                  gpointer     data);</span>
  
<span class="line-added">+ GLIB_AVAILABLE_IN_2_62</span>
<span class="line-added">+ void   g_clear_signal_handler         (gulong            *handler_id_ptr,</span>
<span class="line-added">+                  gpointer           instance);</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define  g_clear_signal_handler(handler_id_ptr, instance)           \</span>
<span class="line-added">+   G_STMT_START {                                                    \</span>
<span class="line-added">+     G_STATIC_ASSERT (sizeof *(handler_id_ptr) == sizeof (gulong));  \</span>
<span class="line-added">+     gulong _handler_id = *(handler_id_ptr);                         \</span>
<span class="line-added">+                                                                     \</span>
<span class="line-added">+     if (_handler_id &gt; 0)                                            \</span>
<span class="line-added">+       {                                                             \</span>
<span class="line-added">+         g_signal_handler_disconnect ((instance), _handler_id);      \</span>
<span class="line-added">+         *(handler_id_ptr) = 0;                                      \</span>
<span class="line-added">+       }                                                             \</span>
<span class="line-added">+   } G_STMT_END                                                      \</span>
<span class="line-added">+   GLIB_AVAILABLE_MACRO_IN_2_62</span>
  
  /* --- overriding and chaining --- */
  GLIB_AVAILABLE_IN_ALL
  void    g_signal_override_class_closure       (guint              signal_id,
                                                 GType              instance_type,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 534,14 ***</span>
   *
   * Disconnects all handlers on an instance that match @func and @data.
   *
   * Returns: The number of handlers that matched.
   */
<span class="line-modified">! #define g_signal_handlers_disconnect_by_func(instance, func, data)                      \</span>
<span class="line-modified">!     g_signal_handlers_disconnect_matched ((instance),                               \</span>
<span class="line-modified">!                       (GSignalMatchType) (G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA),   \</span>
<span class="line-modified">!                       0, 0, NULL, (func), (data))</span>
  
  /**
   * g_signal_handlers_disconnect_by_data:
   * @instance: The instance to remove handlers from
   * @data: the closure data of the handlers&#39; closures
<span class="line-new-header">--- 550,14 ---</span>
   *
   * Disconnects all handlers on an instance that match @func and @data.
   *
   * Returns: The number of handlers that matched.
   */
<span class="line-modified">! #define g_signal_handlers_disconnect_by_func(instance, func, data)            \</span>
<span class="line-modified">!     g_signal_handlers_disconnect_matched ((instance),               \</span>
<span class="line-modified">!             (GSignalMatchType) (G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), \</span>
<span class="line-modified">!             0, 0, NULL, (func), (data))</span>
  
  /**
   * g_signal_handlers_disconnect_by_data:
   * @instance: The instance to remove handlers from
   * @data: the closure data of the handlers&#39; closures
</pre>
<hr />
<pre>
<span class="line-old-header">*** 563,45 ***</span>
   *
   * Blocks all handlers on an instance that match @func and @data.
   *
   * Returns: The number of handlers that matched.
   */
<span class="line-modified">! #define g_signal_handlers_block_by_func(instance, func, data)                           \</span>
<span class="line-modified">!     g_signal_handlers_block_matched      ((instance),                               \</span>
<span class="line-modified">!                           (GSignalMatchType) (G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA),   \</span>
<span class="line-modified">!                           0, 0, NULL, (func), (data))</span>
  /**
   * g_signal_handlers_unblock_by_func:
   * @instance: The instance to unblock handlers from.
   * @func: The C closure callback of the handlers (useless for non-C closures).
   * @data: The closure data of the handlers&#39; closures.
   *
   * Unblocks all handlers on an instance that match @func and @data.
   *
   * Returns: The number of handlers that matched.
   */
<span class="line-modified">! #define g_signal_handlers_unblock_by_func(instance, func, data)                         \</span>
<span class="line-modified">!     g_signal_handlers_unblock_matched    ((instance),                               \</span>
<span class="line-modified">!                           (GSignalMatchType) (G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA),   \</span>
<span class="line-modified">!                           0, 0, NULL, (func), (data))</span>
  
  
  GLIB_AVAILABLE_IN_ALL
  gboolean g_signal_accumulator_true_handled (GSignalInvocationHint *ihint,
<span class="line-modified">!                         GValue                *return_accu,</span>
<span class="line-modified">!                         const GValue          *handler_return,</span>
<span class="line-modified">!                         gpointer               dummy);</span>
  
  GLIB_AVAILABLE_IN_ALL
  gboolean g_signal_accumulator_first_wins   (GSignalInvocationHint *ihint,
                                              GValue                *return_accu,
                                              const GValue          *handler_return,
                                              gpointer               dummy);
  
  /*&lt; private &gt;*/
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! void     g_signal_handlers_destroy        (gpointer       instance);</span>
<span class="line-modified">! void     _g_signals_destroy           (GType          itype);</span>
  
  G_END_DECLS
  
  #endif /* __G_SIGNAL_H__ */
<span class="line-new-header">--- 579,45 ---</span>
   *
   * Blocks all handlers on an instance that match @func and @data.
   *
   * Returns: The number of handlers that matched.
   */
<span class="line-modified">! #define g_signal_handlers_block_by_func(instance, func, data)             \</span>
<span class="line-modified">!     g_signal_handlers_block_matched      ((instance),               \</span>
<span class="line-modified">!                   (GSignalMatchType) (G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), \</span>
<span class="line-modified">!                   0, 0, NULL, (func), (data))</span>
  /**
   * g_signal_handlers_unblock_by_func:
   * @instance: The instance to unblock handlers from.
   * @func: The C closure callback of the handlers (useless for non-C closures).
   * @data: The closure data of the handlers&#39; closures.
   *
   * Unblocks all handlers on an instance that match @func and @data.
   *
   * Returns: The number of handlers that matched.
   */
<span class="line-modified">! #define g_signal_handlers_unblock_by_func(instance, func, data)             \</span>
<span class="line-modified">!     g_signal_handlers_unblock_matched    ((instance),               \</span>
<span class="line-modified">!                   (GSignalMatchType) (G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), \</span>
<span class="line-modified">!                   0, 0, NULL, (func), (data))</span>
  
  
  GLIB_AVAILABLE_IN_ALL
  gboolean g_signal_accumulator_true_handled (GSignalInvocationHint *ihint,
<span class="line-modified">!               GValue                *return_accu,</span>
<span class="line-modified">!               const GValue          *handler_return,</span>
<span class="line-modified">!               gpointer               dummy);</span>
  
  GLIB_AVAILABLE_IN_ALL
  gboolean g_signal_accumulator_first_wins   (GSignalInvocationHint *ihint,
                                              GValue                *return_accu,
                                              const GValue          *handler_return,
                                              gpointer               dummy);
  
  /*&lt; private &gt;*/
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! void   g_signal_handlers_destroy        (gpointer     instance);</span>
<span class="line-modified">! void   _g_signals_destroy         (GType      itype);</span>
  
  G_END_DECLS
  
  #endif /* __G_SIGNAL_H__ */
</pre>
<center><a href="gsignal.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gsourceclosure.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>