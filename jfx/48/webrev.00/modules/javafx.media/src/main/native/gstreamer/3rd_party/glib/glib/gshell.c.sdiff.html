<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gshell.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gsequence.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gslice.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gshell.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
204 {
205   /* We always use single quotes, because the algorithm is cheesier.
206    * We could use double if we felt like it, that might be more
207    * human-readable.
208    */
209 
210   const gchar *p;
211   GString *dest;
212 
213   g_return_val_if_fail (unquoted_string != NULL, NULL);
214 
215   dest = g_string_new (&quot;&#39;&quot;);
216 
217   p = unquoted_string;
218 
219   /* could speed this up a lot by appending chunks of text at a
220    * time.
221    */
222   while (*p)
223     {
<span class="line-modified">224       /* Replace literal &#39; with a close &#39;, a \&#39;, and a open &#39; */</span>
225       if (*p == &#39;\&#39;&#39;)
226         g_string_append (dest, &quot;&#39;\\&#39;&#39;&quot;);
227       else
228         g_string_append_c (dest, *p);
229 
230       ++p;
231     }
232 
233   /* close the quote */
234   g_string_append_c (dest, &#39;\&#39;&#39;);
235 
236   return g_string_free (dest, FALSE);
237 }
238 
239 /**
240  * g_shell_unquote:
241  * @quoted_string: (type filename): shell-quoted string
242  * @error: error return location or NULL
243  *
244  * Unquotes a string as the shell (/bin/sh) would. Only handles
</pre>
<hr />
<pre>
513               break;
514 
515 
516               /* single/double quotes are appended to the token,
517                * escapes are maybe appended next time through the loop,
518                * comment chars are never appended.
519                */
520 
521             case &#39;\&#39;&#39;:
522             case &#39;&quot;&#39;:
523               ensure_token (&amp;current_token);
524               g_string_append_c (current_token, *p);
525 
526               /* FALL THRU */
527             case &#39;\\&#39;:
528               current_quote = *p;
529               break;
530 
531             case &#39;#&#39;:
532               if (p == command_line)
<span class="line-modified">533             { /* &#39;#&#39; was the first char */</span>
534                   current_quote = *p;
535                   break;
536                 }
537               switch(*(p-1))
538                 {
539                   case &#39; &#39;:
540                   case &#39;\n&#39;:
541                   case &#39;\0&#39;:
542                     current_quote = *p;
543                     break;
544                   default:
545                     ensure_token (&amp;current_token);
546                     g_string_append_c (current_token, *p);
<span class="line-modified">547             break;</span>
548                 }
549               break;
550 
551             default:
552               /* Combines rules 4) and 6) - if we have a token, append to it,
553                * otherwise create a new token.
554                */
555               ensure_token (&amp;current_token);
556               g_string_append_c (current_token, *p);
557               break;
558             }
559         }
560 
561       /* We need to count consecutive backslashes mod 2,
562        * to detect escaped doublequotes.
563        */
564       if (*p != &#39;\\&#39;)
<span class="line-modified">565     quoted = FALSE;</span>
566       else
<span class="line-modified">567     quoted = !quoted;</span>
568 
569       ++p;
570     }
571 
572   delimit_token (&amp;current_token, &amp;retval);
573 
574   if (current_quote)
575     {
576       if (current_quote == &#39;\\&#39;)
577         g_set_error (error,
578                      G_SHELL_ERROR,
579                      G_SHELL_ERROR_BAD_QUOTING,
580                      _(&quot;Text ended just after a &#39;\\&#39; character.&quot;
581                        &quot; (The text was &#39;%s&#39;)&quot;),
582                      command_line);
583       else
584         g_set_error (error,
585                      G_SHELL_ERROR,
586                      G_SHELL_ERROR_BAD_QUOTING,
587                      _(&quot;Text ended before matching quote was found for %c.&quot;
</pre>
</td>
<td>
<hr />
<pre>
204 {
205   /* We always use single quotes, because the algorithm is cheesier.
206    * We could use double if we felt like it, that might be more
207    * human-readable.
208    */
209 
210   const gchar *p;
211   GString *dest;
212 
213   g_return_val_if_fail (unquoted_string != NULL, NULL);
214 
215   dest = g_string_new (&quot;&#39;&quot;);
216 
217   p = unquoted_string;
218 
219   /* could speed this up a lot by appending chunks of text at a
220    * time.
221    */
222   while (*p)
223     {
<span class="line-modified">224       /* Replace literal &#39; with a close &#39;, a \&#39;, and an open &#39; */</span>
225       if (*p == &#39;\&#39;&#39;)
226         g_string_append (dest, &quot;&#39;\\&#39;&#39;&quot;);
227       else
228         g_string_append_c (dest, *p);
229 
230       ++p;
231     }
232 
233   /* close the quote */
234   g_string_append_c (dest, &#39;\&#39;&#39;);
235 
236   return g_string_free (dest, FALSE);
237 }
238 
239 /**
240  * g_shell_unquote:
241  * @quoted_string: (type filename): shell-quoted string
242  * @error: error return location or NULL
243  *
244  * Unquotes a string as the shell (/bin/sh) would. Only handles
</pre>
<hr />
<pre>
513               break;
514 
515 
516               /* single/double quotes are appended to the token,
517                * escapes are maybe appended next time through the loop,
518                * comment chars are never appended.
519                */
520 
521             case &#39;\&#39;&#39;:
522             case &#39;&quot;&#39;:
523               ensure_token (&amp;current_token);
524               g_string_append_c (current_token, *p);
525 
526               /* FALL THRU */
527             case &#39;\\&#39;:
528               current_quote = *p;
529               break;
530 
531             case &#39;#&#39;:
532               if (p == command_line)
<span class="line-modified">533           { /* &#39;#&#39; was the first char */</span>
534                   current_quote = *p;
535                   break;
536                 }
537               switch(*(p-1))
538                 {
539                   case &#39; &#39;:
540                   case &#39;\n&#39;:
541                   case &#39;\0&#39;:
542                     current_quote = *p;
543                     break;
544                   default:
545                     ensure_token (&amp;current_token);
546                     g_string_append_c (current_token, *p);
<span class="line-modified">547         break;</span>
548                 }
549               break;
550 
551             default:
552               /* Combines rules 4) and 6) - if we have a token, append to it,
553                * otherwise create a new token.
554                */
555               ensure_token (&amp;current_token);
556               g_string_append_c (current_token, *p);
557               break;
558             }
559         }
560 
561       /* We need to count consecutive backslashes mod 2,
562        * to detect escaped doublequotes.
563        */
564       if (*p != &#39;\\&#39;)
<span class="line-modified">565   quoted = FALSE;</span>
566       else
<span class="line-modified">567   quoted = !quoted;</span>
568 
569       ++p;
570     }
571 
572   delimit_token (&amp;current_token, &amp;retval);
573 
574   if (current_quote)
575     {
576       if (current_quote == &#39;\\&#39;)
577         g_set_error (error,
578                      G_SHELL_ERROR,
579                      G_SHELL_ERROR_BAD_QUOTING,
580                      _(&quot;Text ended just after a &#39;\\&#39; character.&quot;
581                        &quot; (The text was &#39;%s&#39;)&quot;),
582                      command_line);
583       else
584         g_set_error (error,
585                      G_SHELL_ERROR,
586                      G_SHELL_ERROR_BAD_QUOTING,
587                      _(&quot;Text ended before matching quote was found for %c.&quot;
</pre>
</td>
</tr>
</table>
<center><a href="gsequence.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gslice.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>