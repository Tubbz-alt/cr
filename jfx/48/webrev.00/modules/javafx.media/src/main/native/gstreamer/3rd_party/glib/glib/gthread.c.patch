diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gthread.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gthread.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gthread.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gthread.c
@@ -318,10 +318,14 @@
  * one thread at a time is allowed write access (by holding the 'writer'
  * lock via g_rw_lock_writer_lock()), multiple threads can gain
  * simultaneous read-only access (by holding the 'reader' lock via
  * g_rw_lock_reader_lock()).
  *
+ * It is unspecified whether readers or writers have priority in acquiring the
+ * lock when a reader already holds the lock and a writer is queued to acquire
+ * it.
+ *
  * Here is an example for an array with access functions:
  * |[<!-- language="C" -->
  *   GRWLock lock;
  *   GPtrArray *array;
  *
@@ -509,11 +513,36 @@
 static GSList   *g_once_init_list = NULL;
 
 static void g_thread_cleanup (gpointer data);
 static GPrivate     g_thread_specific_private = G_PRIVATE_INIT (g_thread_cleanup);
 
-G_LOCK_DEFINE_STATIC (g_thread_new);
+/*
+ * g_private_set_alloc0:
+ * @key: a #GPrivate
+ * @size: size of the allocation, in bytes
+ *
+ * Sets the thread local variable @key to have a newly-allocated and zero-filled
+ * value of given @size, and returns a pointer to that memory. Allocations made
+ * using this API will be suppressed in valgrind: it is intended to be used for
+ * one-time allocations which are known to be leaked, such as those for
+ * per-thread initialisation data. Otherwise, this function behaves the same as
+ * g_private_set().
+ *
+ * Returns: (transfer full): new thread-local heap allocation of size @size
+ * Since: 2.60
+ */
+/*< private >*/
+gpointer
+g_private_set_alloc0 (GPrivate *key,
+                      gsize     size)
+{
+  gpointer allocated = g_malloc0 (size);
+
+  g_private_set (key, allocated);
+
+  return g_steal_pointer (&allocated);
+}
 
 /* GOnce {{{1 ------------------------------------------------------------- */
 
 /**
  * GOnce:
@@ -587,12 +616,12 @@
  *
  * Since: 2.4
  */
 gpointer
 g_once_impl (GOnce       *once,
-         GThreadFunc  func,
-         gpointer     arg)
+       GThreadFunc  func,
+       gpointer     arg)
 {
   g_mutex_lock (&g_once_mutex);
 
   while (once->status == G_ONCE_STATUS_PROGRESS)
     g_cond_wait (&g_once_cond, &g_once_mutex);
@@ -689,14 +718,14 @@
 {
   volatile gsize *value_location = location;
 
   g_return_if_fail (g_atomic_pointer_get (value_location) == NULL);
   g_return_if_fail (result != 0);
-  g_return_if_fail (g_once_init_list != NULL);
 
   g_atomic_pointer_set (value_location, result);
   g_mutex_lock (&g_once_mutex);
+  g_return_if_fail (g_once_init_list != NULL);
   g_once_init_list = g_slist_remove (g_once_init_list, (void*) value_location);
   g_cond_broadcast (&g_once_cond);
   g_mutex_unlock (&g_once_mutex);
 }
 
@@ -759,20 +788,12 @@
 g_thread_proxy (gpointer data)
 {
   GRealThread* thread = data;
 
   g_assert (data);
-
-  /* This has to happen before G_LOCK, as that might call g_thread_self */
   g_private_set (&g_thread_specific_private, data);
 
-  /* The lock makes sure that g_thread_new_internal() has a chance to
-   * setup 'func' and 'data' before we make the call.
-   */
-  G_LOCK (g_thread_new);
-  G_UNLOCK (g_thread_new);
-
   TRACE (GLIB_THREAD_SPAWNED (thread->thread.func, thread->thread.data,
                               thread->name));
 
   if (thread->name)
     {
@@ -864,28 +885,14 @@
                        GThreadFunc    func,
                        gpointer       data,
                        gsize          stack_size,
                        GError       **error)
 {
-  GRealThread *thread;
-
   g_return_val_if_fail (func != NULL, NULL);
 
-  G_LOCK (g_thread_new);
-  thread = g_system_thread_new (proxy, stack_size, error);
-  if (thread)
-    {
-      thread->ref_count = 2;
-      thread->ours = TRUE;
-      thread->thread.joinable = TRUE;
-      thread->thread.func = func;
-      thread->thread.data = data;
-      thread->name = g_strdup (name);
-    }
-  G_UNLOCK (g_thread_new);
-
-  return (GThread*) thread;
+  return (GThread*) g_system_thread_new (proxy, stack_size, name,
+                                         func, data, error);
 }
 
 /**
  * g_thread_exit:
  * @retval: the return value of this thread
