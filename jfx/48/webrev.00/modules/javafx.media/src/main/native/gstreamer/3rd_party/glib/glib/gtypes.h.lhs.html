<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gtypes.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* GLIB - Library of useful routines for C programming
  2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Lesser General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2.1 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Lesser General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Lesser General Public
 15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 16  */
 17 
 18 /*
 19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
 20  * file for a list of people on the GLib Team.  See the ChangeLog
 21  * files for a list of changes.  These files are distributed with
 22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
 23  */
 24 
 25 #ifndef __G_TYPES_H__
 26 #define __G_TYPES_H__
 27 
 28 #if !defined (__GLIB_H_INSIDE__) &amp;&amp; !defined (GLIB_COMPILATION)
 29 #error &quot;Only &lt;glib.h&gt; can be included directly.&quot;
 30 #endif
 31 
 32 #include &lt;glibconfig.h&gt;
 33 #include &lt;glib/gmacros.h&gt;
 34 #include &lt;glib/gversionmacros.h&gt;
 35 #include &lt;time.h&gt;
 36 
 37 G_BEGIN_DECLS
 38 
 39 /* Provide type definitions for commonly used types.
 40  *  These are useful because a &quot;gint8&quot; can be adjusted
 41  *  to be 1 byte (8 bits) on all platforms. Similarly and
 42  *  more importantly, &quot;gint32&quot; can be adjusted to be
 43  *  4 bytes (32 bits) on all platforms.
 44  */
 45 
 46 typedef char   gchar;
 47 typedef short  gshort;
 48 typedef long   glong;
 49 typedef int    gint;
 50 typedef gint   gboolean;
 51 
 52 typedef unsigned char   guchar;
 53 typedef unsigned short  gushort;
 54 typedef unsigned long   gulong;
 55 typedef unsigned int    guint;
 56 
 57 typedef float   gfloat;
 58 typedef double  gdouble;
 59 
 60 /* Define min and max constants for the fixed size numerical types */
<a name="1" id="anc1"></a><span class="line-modified"> 61 #define G_MININT8   ((gint8) -0x80)</span>
<span class="line-modified"> 62 #define G_MAXINT8   ((gint8)  0x7f)</span>







 63 #define G_MAXUINT8  ((guint8) 0xff)
 64 
<a name="2" id="anc2"></a><span class="line-modified"> 65 #define G_MININT16  ((gint16) -0x8000)</span>







 66 #define G_MAXINT16  ((gint16)  0x7fff)
 67 #define G_MAXUINT16 ((guint16) 0xffff)
 68 
<a name="3" id="anc3"></a><span class="line-modified"> 69 #define G_MININT32  ((gint32) -0x80000000)</span>







 70 #define G_MAXINT32  ((gint32)  0x7fffffff)
 71 #define G_MAXUINT32 ((guint32) 0xffffffff)
 72 
<a name="4" id="anc4"></a><span class="line-modified"> 73 #define G_MININT64  ((gint64) G_GINT64_CONSTANT(-0x8000000000000000))</span>





 74 #define G_MAXINT64  G_GINT64_CONSTANT(0x7fffffffffffffff)
 75 #define G_MAXUINT64 G_GUINT64_CONSTANT(0xffffffffffffffff)
 76 
 77 typedef void* gpointer;
 78 typedef const void *gconstpointer;
 79 
 80 typedef gint            (*GCompareFunc)         (gconstpointer  a,
 81                                                  gconstpointer  b);
 82 typedef gint            (*GCompareDataFunc)     (gconstpointer  a,
 83                                                  gconstpointer  b,
<a name="5" id="anc5"></a><span class="line-modified"> 84                          gpointer       user_data);</span>
 85 typedef gboolean        (*GEqualFunc)           (gconstpointer  a,
 86                                                  gconstpointer  b);
 87 typedef void            (*GDestroyNotify)       (gpointer       data);
 88 typedef void            (*GFunc)                (gpointer       data,
 89                                                  gpointer       user_data);
 90 typedef guint           (*GHashFunc)            (gconstpointer  key);
 91 typedef void            (*GHFunc)               (gpointer       key,
 92                                                  gpointer       value,
 93                                                  gpointer       user_data);
 94 
<a name="6" id="anc6"></a>













 95 /**
 96  * GFreeFunc:
 97  * @data: a data pointer
 98  *
 99  * Declares a type of function which takes an arbitrary
100  * data pointer argument and has no return value. It is
101  * not currently used in GLib or GTK+.
102  */
103 typedef void            (*GFreeFunc)            (gpointer       data);
104 
105 /**
106  * GTranslateFunc:
107  * @str: the untranslated string
108  * @data: user data specified when installing the function, e.g.
109  *  in g_option_group_set_translate_func()
110  *
111  * The type of functions which are used to translate user-visible
112  * strings, for &lt;option&gt;--help&lt;/option&gt; output.
113  *
114  * Returns: a translation of the string for the current locale.
115  *  The returned string is owned by GLib and must not be freed.
116  */
117 typedef const gchar *   (*GTranslateFunc)       (const gchar   *str,
<a name="7" id="anc7"></a><span class="line-modified">118                          gpointer       data);</span>
119 
120 
121 /* Define some mathematical constants that aren&#39;t available
122  * symbolically in some strict ISO C implementations.
123  *
124  * Note that the large number of digits used in these definitions
125  * doesn&#39;t imply that GLib or current computers in general would be
126  * able to handle floating point numbers with an accuracy like this.
127  * It&#39;s mostly an exercise in futility and future proofing. For
128  * extended precision floating point support, look somewhere else
129  * than GLib.
130  */
131 #define G_E     2.7182818284590452353602874713526624977572470937000
132 #define G_LN2   0.69314718055994530941723212145817656807550013436026
133 #define G_LN10  2.3025850929940456840179914546843642076011014886288
134 #define G_PI    3.1415926535897932384626433832795028841971693993751
135 #define G_PI_2  1.5707963267948966192313216916397514420985846996876
136 #define G_PI_4  0.78539816339744830961566084581987572104929234984378
137 #define G_SQRT2 1.4142135623730950488016887242096980785696718753769
138 
139 /* Portable endian checks and conversions
140  *
141  * glibconfig.h defines G_BYTE_ORDER which expands to one of
142  * the below macros.
143  */
144 #define G_LITTLE_ENDIAN 1234
145 #define G_BIG_ENDIAN    4321
<a name="8" id="anc8"></a><span class="line-modified">146 #define G_PDP_ENDIAN    3412        /* unused, need specific PDP check */</span>
147 
148 
149 /* Basic bit swapping functions
150  */
<a name="9" id="anc9"></a><span class="line-modified">151 #define GUINT16_SWAP_LE_BE_CONSTANT(val)    ((guint16) ( \</span>
152     (guint16) ((guint16) (val) &gt;&gt; 8) |  \
153     (guint16) ((guint16) (val) &lt;&lt; 8)))
154 
<a name="10" id="anc10"></a><span class="line-modified">155 #define GUINT32_SWAP_LE_BE_CONSTANT(val)    ((guint32) ( \</span>
156     (((guint32) (val) &amp; (guint32) 0x000000ffU) &lt;&lt; 24) | \
157     (((guint32) (val) &amp; (guint32) 0x0000ff00U) &lt;&lt;  8) | \
158     (((guint32) (val) &amp; (guint32) 0x00ff0000U) &gt;&gt;  8) | \
159     (((guint32) (val) &amp; (guint32) 0xff000000U) &gt;&gt; 24)))
160 
<a name="11" id="anc11"></a><span class="line-modified">161 #define GUINT64_SWAP_LE_BE_CONSTANT(val)    ((guint64) ( \</span>
<span class="line-modified">162       (((guint64) (val) &amp;                       \</span>
<span class="line-modified">163     (guint64) G_GINT64_CONSTANT (0x00000000000000ffU)) &lt;&lt; 56) | \</span>
<span class="line-modified">164       (((guint64) (val) &amp;                       \</span>
<span class="line-modified">165     (guint64) G_GINT64_CONSTANT (0x000000000000ff00U)) &lt;&lt; 40) | \</span>
<span class="line-modified">166       (((guint64) (val) &amp;                       \</span>
<span class="line-modified">167     (guint64) G_GINT64_CONSTANT (0x0000000000ff0000U)) &lt;&lt; 24) | \</span>
<span class="line-modified">168       (((guint64) (val) &amp;                       \</span>
<span class="line-modified">169     (guint64) G_GINT64_CONSTANT (0x00000000ff000000U)) &lt;&lt;  8) | \</span>
<span class="line-modified">170       (((guint64) (val) &amp;                       \</span>
<span class="line-modified">171     (guint64) G_GINT64_CONSTANT (0x000000ff00000000U)) &gt;&gt;  8) | \</span>
<span class="line-modified">172       (((guint64) (val) &amp;                       \</span>
<span class="line-modified">173     (guint64) G_GINT64_CONSTANT (0x0000ff0000000000U)) &gt;&gt; 24) | \</span>
<span class="line-modified">174       (((guint64) (val) &amp;                       \</span>
<span class="line-modified">175     (guint64) G_GINT64_CONSTANT (0x00ff000000000000U)) &gt;&gt; 40) | \</span>
<span class="line-modified">176       (((guint64) (val) &amp;                       \</span>
<span class="line-modified">177     (guint64) G_GINT64_CONSTANT (0xff00000000000000U)) &gt;&gt; 56)))</span>
178 
179 /* Arch specific stuff for speed
180  */
181 #if defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 2) &amp;&amp; defined (__OPTIMIZE__)
182 
183 #  if __GNUC__ &gt;= 4 &amp;&amp; defined (__GNUC_MINOR__) &amp;&amp; __GNUC_MINOR__ &gt;= 3
184 #    define GUINT32_SWAP_LE_BE(val) ((guint32) __builtin_bswap32 ((guint32) (val)))
185 #    define GUINT64_SWAP_LE_BE(val) ((guint64) __builtin_bswap64 ((guint64) (val)))
186 #  endif
187 
188 #  if defined (__i386__)
189 #    define GUINT16_SWAP_LE_BE_IA32(val) \
<a name="12" id="anc12"></a><span class="line-modified">190        (G_GNUC_EXTENSION                    \</span>
<span class="line-modified">191     ({ guint16 __v, __x = ((guint16) (val));        \</span>
<span class="line-modified">192        if (__builtin_constant_p (__x))          \</span>
<span class="line-modified">193          __v = GUINT16_SWAP_LE_BE_CONSTANT (__x);       \</span>
<span class="line-modified">194        else                         \</span>
<span class="line-modified">195          __asm__ (&quot;rorw $8, %w0&quot;                \</span>
<span class="line-modified">196               : &quot;=r&quot; (__v)              \</span>
<span class="line-modified">197               : &quot;0&quot; (__x)               \</span>
<span class="line-modified">198               : &quot;cc&quot;);                  \</span>
<span class="line-modified">199         __v; }))</span>
200 #    if !defined (__i486__) &amp;&amp; !defined (__i586__) \
<a name="13" id="anc13"></a><span class="line-modified">201     &amp;&amp; !defined (__pentium__) &amp;&amp; !defined (__i686__) \</span>
<span class="line-modified">202     &amp;&amp; !defined (__pentiumpro__) &amp;&amp; !defined (__pentium4__)</span>
203 #       define GUINT32_SWAP_LE_BE_IA32(val) \
<a name="14" id="anc14"></a><span class="line-modified">204       (G_GNUC_EXTENSION                 \</span>
<span class="line-modified">205        ({ guint32 __v, __x = ((guint32) (val));     \</span>
<span class="line-modified">206           if (__builtin_constant_p (__x))           \</span>
<span class="line-modified">207         __v = GUINT32_SWAP_LE_BE_CONSTANT (__x);    \</span>
<span class="line-modified">208           else                      \</span>
<span class="line-modified">209         __asm__ (&quot;rorw $8, %w0\n\t&quot;         \</span>
<span class="line-modified">210              &quot;rorl $16, %0\n\t&quot;         \</span>
<span class="line-modified">211              &quot;rorw $8, %w0&quot;             \</span>
<span class="line-modified">212              : &quot;=r&quot; (__v)               \</span>
<span class="line-modified">213              : &quot;0&quot; (__x)                \</span>
<span class="line-modified">214              : &quot;cc&quot;);               \</span>
<span class="line-modified">215           __v; }))</span>
216 #    else /* 486 and higher has bswap */
217 #       define GUINT32_SWAP_LE_BE_IA32(val) \
<a name="15" id="anc15"></a><span class="line-modified">218       (G_GNUC_EXTENSION                 \</span>
<span class="line-modified">219        ({ guint32 __v, __x = ((guint32) (val));     \</span>
<span class="line-modified">220           if (__builtin_constant_p (__x))           \</span>
<span class="line-modified">221         __v = GUINT32_SWAP_LE_BE_CONSTANT (__x);    \</span>
<span class="line-modified">222           else                      \</span>
<span class="line-modified">223         __asm__ (&quot;bswap %0&quot;             \</span>
<span class="line-modified">224              : &quot;=r&quot; (__v)               \</span>
<span class="line-modified">225              : &quot;0&quot; (__x));              \</span>
<span class="line-modified">226           __v; }))</span>
227 #    endif /* processor specific 32-bit stuff */
228 #    define GUINT64_SWAP_LE_BE_IA32(val) \
<a name="16" id="anc16"></a><span class="line-modified">229        (G_GNUC_EXTENSION                        \</span>
<span class="line-modified">230     ({ union { guint64 __ll;                    \</span>
<span class="line-modified">231            guint32 __l[2]; } __w, __r;              \</span>
<span class="line-modified">232        __w.__ll = ((guint64) (val));                \</span>
<span class="line-modified">233        if (__builtin_constant_p (__w.__ll))             \</span>
<span class="line-modified">234          __r.__ll = GUINT64_SWAP_LE_BE_CONSTANT (__w.__ll);     \</span>
<span class="line-modified">235        else                             \</span>
<span class="line-modified">236          {                              \</span>
<span class="line-modified">237            __r.__l[0] = GUINT32_SWAP_LE_BE (__w.__l[1]);        \</span>
<span class="line-modified">238            __r.__l[1] = GUINT32_SWAP_LE_BE (__w.__l[0]);        \</span>
<span class="line-modified">239          }                              \</span>
<span class="line-modified">240        __r.__ll; }))</span>
241      /* Possibly just use the constant version and let gcc figure it out? */
242 #    define GUINT16_SWAP_LE_BE(val) (GUINT16_SWAP_LE_BE_IA32 (val))
243 #    ifndef GUINT32_SWAP_LE_BE
244 #      define GUINT32_SWAP_LE_BE(val) (GUINT32_SWAP_LE_BE_IA32 (val))
245 #    endif
246 #    ifndef GUINT64_SWAP_LE_BE
247 #      define GUINT64_SWAP_LE_BE(val) (GUINT64_SWAP_LE_BE_IA32 (val))
248 #    endif
249 #  elif defined (__ia64__)
250 #    define GUINT16_SWAP_LE_BE_IA64(val) \
<a name="17" id="anc17"></a><span class="line-modified">251        (G_GNUC_EXTENSION                    \</span>
<span class="line-modified">252     ({ guint16 __v, __x = ((guint16) (val));        \</span>
<span class="line-modified">253        if (__builtin_constant_p (__x))          \</span>
<span class="line-modified">254          __v = GUINT16_SWAP_LE_BE_CONSTANT (__x);       \</span>
<span class="line-modified">255        else                         \</span>
<span class="line-modified">256          __asm__ __volatile__ (&quot;shl %0 = %1, 48 ;;&quot;     \</span>
<span class="line-modified">257                    &quot;mux1 %0 = %0, @rev ;;&quot;  \</span>
<span class="line-modified">258                     : &quot;=r&quot; (__v)        \</span>
<span class="line-modified">259                     : &quot;r&quot; (__x));       \</span>
<span class="line-modified">260         __v; }))</span>
261 #    define GUINT32_SWAP_LE_BE_IA64(val) \
<a name="18" id="anc18"></a><span class="line-modified">262        (G_GNUC_EXTENSION                    \</span>
<span class="line-modified">263      ({ guint32 __v, __x = ((guint32) (val));       \</span>
<span class="line-modified">264         if (__builtin_constant_p (__x))         \</span>
<span class="line-modified">265           __v = GUINT32_SWAP_LE_BE_CONSTANT (__x);      \</span>
<span class="line-modified">266         else                        \</span>
<span class="line-modified">267          __asm__ __volatile__ (&quot;shl %0 = %1, 32 ;;&quot;     \</span>
<span class="line-modified">268                    &quot;mux1 %0 = %0, @rev ;;&quot;  \</span>
<span class="line-modified">269                     : &quot;=r&quot; (__v)        \</span>
<span class="line-modified">270                     : &quot;r&quot; (__x));       \</span>
<span class="line-modified">271         __v; }))</span>
272 #    define GUINT64_SWAP_LE_BE_IA64(val) \
<a name="19" id="anc19"></a><span class="line-modified">273        (G_GNUC_EXTENSION                    \</span>
<span class="line-modified">274     ({ guint64 __v, __x = ((guint64) (val));        \</span>
<span class="line-modified">275        if (__builtin_constant_p (__x))          \</span>
<span class="line-modified">276          __v = GUINT64_SWAP_LE_BE_CONSTANT (__x);       \</span>
<span class="line-modified">277        else                         \</span>
<span class="line-modified">278          __asm__ __volatile__ (&quot;mux1 %0 = %1, @rev ;;&quot;  \</span>
<span class="line-modified">279                    : &quot;=r&quot; (__v)         \</span>
<span class="line-modified">280                    : &quot;r&quot; (__x));        \</span>
<span class="line-modified">281        __v; }))</span>
282 #    define GUINT16_SWAP_LE_BE(val) (GUINT16_SWAP_LE_BE_IA64 (val))
283 #    ifndef GUINT32_SWAP_LE_BE
284 #      define GUINT32_SWAP_LE_BE(val) (GUINT32_SWAP_LE_BE_IA64 (val))
285 #    endif
286 #    ifndef GUINT64_SWAP_LE_BE
287 #      define GUINT64_SWAP_LE_BE(val) (GUINT64_SWAP_LE_BE_IA64 (val))
288 #    endif
289 #  elif defined (__x86_64__)
290 #    define GUINT32_SWAP_LE_BE_X86_64(val) \
<a name="20" id="anc20"></a><span class="line-modified">291        (G_GNUC_EXTENSION                    \</span>
<span class="line-modified">292      ({ guint32 __v, __x = ((guint32) (val));       \</span>
<span class="line-modified">293         if (__builtin_constant_p (__x))         \</span>
<span class="line-modified">294           __v = GUINT32_SWAP_LE_BE_CONSTANT (__x);      \</span>
<span class="line-modified">295         else                        \</span>
<span class="line-modified">296          __asm__ (&quot;bswapl %0&quot;               \</span>
<span class="line-modified">297               : &quot;=r&quot; (__v)              \</span>
<span class="line-modified">298               : &quot;0&quot; (__x));             \</span>
<span class="line-modified">299         __v; }))</span>
300 #    define GUINT64_SWAP_LE_BE_X86_64(val) \
<a name="21" id="anc21"></a><span class="line-modified">301        (G_GNUC_EXTENSION                    \</span>
<span class="line-modified">302     ({ guint64 __v, __x = ((guint64) (val));        \</span>
<span class="line-modified">303        if (__builtin_constant_p (__x))          \</span>
<span class="line-modified">304          __v = GUINT64_SWAP_LE_BE_CONSTANT (__x);       \</span>
<span class="line-modified">305        else                         \</span>
<span class="line-modified">306          __asm__ (&quot;bswapq %0&quot;               \</span>
<span class="line-modified">307               : &quot;=r&quot; (__v)              \</span>
<span class="line-modified">308               : &quot;0&quot; (__x));             \</span>
<span class="line-modified">309        __v; }))</span>
310      /* gcc seems to figure out optimal code for this on its own */
311 #    define GUINT16_SWAP_LE_BE(val) (GUINT16_SWAP_LE_BE_CONSTANT (val))
312 #    ifndef GUINT32_SWAP_LE_BE
313 #      define GUINT32_SWAP_LE_BE(val) (GUINT32_SWAP_LE_BE_X86_64 (val))
314 #    endif
315 #    ifndef GUINT64_SWAP_LE_BE
316 #      define GUINT64_SWAP_LE_BE(val) (GUINT64_SWAP_LE_BE_X86_64 (val))
317 #    endif
318 #  else /* generic gcc */
319 #    define GUINT16_SWAP_LE_BE(val) (GUINT16_SWAP_LE_BE_CONSTANT (val))
320 #    ifndef GUINT32_SWAP_LE_BE
321 #      define GUINT32_SWAP_LE_BE(val) (GUINT32_SWAP_LE_BE_CONSTANT (val))
322 #    endif
323 #    ifndef GUINT64_SWAP_LE_BE
324 #      define GUINT64_SWAP_LE_BE(val) (GUINT64_SWAP_LE_BE_CONSTANT (val))
325 #    endif
326 #  endif
327 #else /* generic */
328 #  define GUINT16_SWAP_LE_BE(val) (GUINT16_SWAP_LE_BE_CONSTANT (val))
329 #  define GUINT32_SWAP_LE_BE(val) (GUINT32_SWAP_LE_BE_CONSTANT (val))
330 #  define GUINT64_SWAP_LE_BE(val) (GUINT64_SWAP_LE_BE_CONSTANT (val))
331 #endif /* generic */
332 
<a name="22" id="anc22"></a><span class="line-modified">333 #define GUINT16_SWAP_LE_PDP(val)    ((guint16) (val))</span>
<span class="line-modified">334 #define GUINT16_SWAP_BE_PDP(val)    (GUINT16_SWAP_LE_BE (val))</span>
<span class="line-modified">335 #define GUINT32_SWAP_LE_PDP(val)    ((guint32) ( \</span>
336     (((guint32) (val) &amp; (guint32) 0x0000ffffU) &lt;&lt; 16) | \
337     (((guint32) (val) &amp; (guint32) 0xffff0000U) &gt;&gt; 16)))
<a name="23" id="anc23"></a><span class="line-modified">338 #define GUINT32_SWAP_BE_PDP(val)    ((guint32) ( \</span>
339     (((guint32) (val) &amp; (guint32) 0x00ff00ffU) &lt;&lt; 8) | \
340     (((guint32) (val) &amp; (guint32) 0xff00ff00U) &gt;&gt; 8)))
341 
342 /* The G*_TO_?E() macros are defined in glibconfig.h.
343  * The transformation is symmetric, so the FROM just maps to the TO.
344  */
345 #define GINT16_FROM_LE(val) (GINT16_TO_LE (val))
<a name="24" id="anc24"></a><span class="line-modified">346 #define GUINT16_FROM_LE(val)    (GUINT16_TO_LE (val))</span>
347 #define GINT16_FROM_BE(val) (GINT16_TO_BE (val))
<a name="25" id="anc25"></a><span class="line-modified">348 #define GUINT16_FROM_BE(val)    (GUINT16_TO_BE (val))</span>
349 #define GINT32_FROM_LE(val) (GINT32_TO_LE (val))
<a name="26" id="anc26"></a><span class="line-modified">350 #define GUINT32_FROM_LE(val)    (GUINT32_TO_LE (val))</span>
351 #define GINT32_FROM_BE(val) (GINT32_TO_BE (val))
<a name="27" id="anc27"></a><span class="line-modified">352 #define GUINT32_FROM_BE(val)    (GUINT32_TO_BE (val))</span>
353 
354 #define GINT64_FROM_LE(val) (GINT64_TO_LE (val))
<a name="28" id="anc28"></a><span class="line-modified">355 #define GUINT64_FROM_LE(val)    (GUINT64_TO_LE (val))</span>
356 #define GINT64_FROM_BE(val) (GINT64_TO_BE (val))
<a name="29" id="anc29"></a><span class="line-modified">357 #define GUINT64_FROM_BE(val)    (GUINT64_TO_BE (val))</span>
358 
359 #define GLONG_FROM_LE(val)  (GLONG_TO_LE (val))
360 #define GULONG_FROM_LE(val) (GULONG_TO_LE (val))
361 #define GLONG_FROM_BE(val)  (GLONG_TO_BE (val))
362 #define GULONG_FROM_BE(val) (GULONG_TO_BE (val))
363 
<a name="30" id="anc30"></a><span class="line-modified">364 #define GINT_FROM_LE(val)   (GINT_TO_LE (val))</span>
365 #define GUINT_FROM_LE(val)  (GUINT_TO_LE (val))
<a name="31" id="anc31"></a><span class="line-modified">366 #define GINT_FROM_BE(val)   (GINT_TO_BE (val))</span>
367 #define GUINT_FROM_BE(val)  (GUINT_TO_BE (val))
368 
369 #define GSIZE_FROM_LE(val)  (GSIZE_TO_LE (val))
370 #define GSSIZE_FROM_LE(val) (GSSIZE_TO_LE (val))
371 #define GSIZE_FROM_BE(val)  (GSIZE_TO_BE (val))
372 #define GSSIZE_FROM_BE(val) (GSSIZE_TO_BE (val))
373 
374 /* Portable versions of host-network order stuff
375  */
376 #define g_ntohl(val) (GUINT32_FROM_BE (val))
377 #define g_ntohs(val) (GUINT16_FROM_BE (val))
378 #define g_htonl(val) (GUINT32_TO_BE (val))
379 #define g_htons(val) (GUINT16_TO_BE (val))
380 
381 /* Overflow-checked unsigned integer arithmetic
382  */
383 #ifndef _GLIB_TEST_OVERFLOW_FALLBACK
384 /* https://bugzilla.gnome.org/show_bug.cgi?id=769104 */
385 #if __GNUC__ &gt;= 5 &amp;&amp; !defined(__INTEL_COMPILER)
386 #define _GLIB_HAVE_BUILTIN_OVERFLOW_CHECKS
387 #elif g_macro__has_builtin(__builtin_uadd_overflow)
388 #define _GLIB_HAVE_BUILTIN_OVERFLOW_CHECKS
389 #endif
390 #endif
391 
392 #define g_uint_checked_add(dest, a, b) \
393     _GLIB_CHECKED_ADD_U32(dest, a, b)
394 #define g_uint_checked_mul(dest, a, b) \
395     _GLIB_CHECKED_MUL_U32(dest, a, b)
396 
397 #define g_uint64_checked_add(dest, a, b) \
398     _GLIB_CHECKED_ADD_U64(dest, a, b)
399 #define g_uint64_checked_mul(dest, a, b) \
400     _GLIB_CHECKED_MUL_U64(dest, a, b)
401 
402 #if GLIB_SIZEOF_SIZE_T == 8
403 #define g_size_checked_add(dest, a, b) \
404     _GLIB_CHECKED_ADD_U64(dest, a, b)
405 #define g_size_checked_mul(dest, a, b) \
406     _GLIB_CHECKED_MUL_U64(dest, a, b)
407 #else
408 #define g_size_checked_add(dest, a, b) \
409     _GLIB_CHECKED_ADD_U32(dest, a, b)
410 #define g_size_checked_mul(dest, a, b) \
411     _GLIB_CHECKED_MUL_U32(dest, a, b)
412 #endif
413 
<a name="32" id="anc32"></a>


414 /* The names of the following inlines are private.  Use the macro
415  * definitions above.
416  */
417 #ifdef _GLIB_HAVE_BUILTIN_OVERFLOW_CHECKS
418 static inline gboolean _GLIB_CHECKED_ADD_U32 (guint32 *dest, guint32 a, guint32 b) {
419   return !__builtin_uadd_overflow(a, b, dest); }
420 static inline gboolean _GLIB_CHECKED_MUL_U32 (guint32 *dest, guint32 a, guint32 b) {
421   return !__builtin_umul_overflow(a, b, dest); }
422 static inline gboolean _GLIB_CHECKED_ADD_U64 (guint64 *dest, guint64 a, guint64 b) {
423   G_STATIC_ASSERT(sizeof (unsigned long long) == sizeof (guint64));
424   return !__builtin_uaddll_overflow(a, b, (unsigned long long *) dest); }
425 static inline gboolean _GLIB_CHECKED_MUL_U64 (guint64 *dest, guint64 a, guint64 b) {
426   return !__builtin_umulll_overflow(a, b, (unsigned long long *) dest); }
427 #else
428 static inline gboolean _GLIB_CHECKED_ADD_U32 (guint32 *dest, guint32 a, guint32 b) {
429   *dest = a + b; return *dest &gt;= a; }
430 static inline gboolean _GLIB_CHECKED_MUL_U32 (guint32 *dest, guint32 a, guint32 b) {
431   *dest = a * b; return !a || *dest / a == b; }
432 static inline gboolean _GLIB_CHECKED_ADD_U64 (guint64 *dest, guint64 a, guint64 b) {
433   *dest = a + b; return *dest &gt;= a; }
434 static inline gboolean _GLIB_CHECKED_MUL_U64 (guint64 *dest, guint64 a, guint64 b) {
435   *dest = a * b; return !a || *dest / a == b; }
436 #endif
<a name="33" id="anc33"></a>
437 
438 /* IEEE Standard 754 Single Precision Storage Format (gfloat):
439  *
440  *        31 30           23 22            0
441  * +--------+---------------+---------------+
442  * | s 1bit | e[30:23] 8bit | f[22:0] 23bit |
443  * +--------+---------------+---------------+
444  * B0-------------------&gt;B1-------&gt;B2--&gt;B3--&gt;
445  *
446  * IEEE Standard 754 Double Precision Storage Format (gdouble):
447  *
448  *        63 62            52 51            32   31            0
449  * +--------+----------------+----------------+ +---------------+
450  * | s 1bit | e[62:52] 11bit | f[51:32] 20bit | | f[31:0] 32bit |
451  * +--------+----------------+----------------+ +---------------+
452  * B0---------------&gt;B1----------&gt;B2---&gt;B3----&gt;  B4-&gt;B5-&gt;B6-&gt;B7-&gt;
453  */
454 /* subtract from biased_exponent to form base2 exponent (normal numbers) */
455 typedef union  _GDoubleIEEE754  GDoubleIEEE754;
<a name="34" id="anc34"></a><span class="line-modified">456 typedef union  _GFloatIEEE754   GFloatIEEE754;</span>
<span class="line-modified">457 #define G_IEEE754_FLOAT_BIAS    (127)</span>
<span class="line-modified">458 #define G_IEEE754_DOUBLE_BIAS   (1023)</span>
459 /* multiply with base2 exponent to get base10 exponent (normal numbers) */
<a name="35" id="anc35"></a><span class="line-modified">460 #define G_LOG_2_BASE_10     (0.30102999566398119521)</span>
461 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
462 union _GFloatIEEE754
463 {
464   gfloat v_float;
465   struct {
466     guint mantissa : 23;
467     guint biased_exponent : 8;
468     guint sign : 1;
469   } mpn;
470 };
471 union _GDoubleIEEE754
472 {
473   gdouble v_double;
474   struct {
475     guint mantissa_low : 32;
476     guint mantissa_high : 20;
477     guint biased_exponent : 11;
478     guint sign : 1;
479   } mpn;
480 };
481 #elif G_BYTE_ORDER == G_BIG_ENDIAN
482 union _GFloatIEEE754
483 {
484   gfloat v_float;
485   struct {
486     guint sign : 1;
487     guint biased_exponent : 8;
488     guint mantissa : 23;
489   } mpn;
490 };
491 union _GDoubleIEEE754
492 {
493   gdouble v_double;
494   struct {
495     guint sign : 1;
496     guint biased_exponent : 11;
497     guint mantissa_high : 20;
498     guint mantissa_low : 32;
499   } mpn;
500 };
501 #else /* !G_LITTLE_ENDIAN &amp;&amp; !G_BIG_ENDIAN */
502 #error unknown ENDIAN type
503 #endif /* !G_LITTLE_ENDIAN &amp;&amp; !G_BIG_ENDIAN */
504 
<a name="36" id="anc36"></a><span class="line-modified">505 typedef struct _GTimeVal                GTimeVal;</span>
506 
507 struct _GTimeVal
508 {
509   glong tv_sec;
510   glong tv_usec;
<a name="37" id="anc37"></a><span class="line-modified">511 };</span>
512 
513 typedef gint            grefcount;
514 typedef volatile gint   gatomicrefcount;
515 
516 G_END_DECLS
517 
518 /* We prefix variable declarations so they can
519  * properly get exported in Windows DLLs.
520  */
521 #ifndef GLIB_VAR
522 #  ifdef G_PLATFORM_WIN32
523 #    ifdef GLIB_STATIC_COMPILATION
524 #      define GLIB_VAR extern
525 #    else /* !GLIB_STATIC_COMPILATION */
526 #      ifdef GLIB_COMPILATION
527 #        ifdef DLL_EXPORT
528 #          define GLIB_VAR __declspec(dllexport)
529 #        else /* !DLL_EXPORT */
530 #          define GLIB_VAR extern
531 #        endif /* !DLL_EXPORT */
532 #      else /* !GLIB_COMPILATION */
533 #        define GLIB_VAR extern __declspec(dllimport)
534 #      endif /* !GLIB_COMPILATION */
535 #    endif /* !GLIB_STATIC_COMPILATION */
536 #  else /* !G_PLATFORM_WIN32 */
537 #    define GLIB_VAR _GLIB_EXTERN
538 #  endif /* !G_PLATFORM_WIN32 */
539 #endif /* GLIB_VAR */
540 
541 #endif /* __G_TYPES_H__ */
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>