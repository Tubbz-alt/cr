<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/pbutils/codec-utils.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer base utils library codec-specific utility functions
   2  * Copyright (C) 2010 Arun Raghavan &lt;arun.raghavan@collabora.co.uk&gt;
   3  *               2013 Sreerenj Balachandran &lt;sreerenj.balachandran@intel.com&gt;
   4  *               2010 Collabora Multimedia
   5  *               2010 Nokia Corporation
   6  *               2013 Intel Corporation
   7  *               2015 Sebastian Dr√∂ge &lt;sebastian@centricular.com&gt;
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public
  20  * License along with this library; if not, write to the
  21  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 
  25 /**
  26  * SECTION:gstpbutilscodecutils
  27  * @title: Codec utilities
  28  * @short_description: Miscellaneous codec-specific utility functions
  29  *
  30  * Provides codec-specific ulility functions such as functions to provide the
  31  * codec profile and level in human-readable string form from header data.
  32  *
  33  */
  34 
  35 #ifdef HAVE_CONFIG_H
  36 #include &quot;config.h&quot;
  37 #endif
  38 
  39 #include &quot;pbutils.h&quot;
  40 #include &lt;gst/base/base.h&gt;
  41 #include &lt;gst/base/gstbitreader.h&gt;
  42 #include &lt;gst/tag/tag.h&gt;
  43 
  44 #include &lt;string.h&gt;
  45 
  46 #define GST_SIMPLE_CAPS_HAS_NAME(caps,name) \
  47     gst_structure_has_name(gst_caps_get_structure((caps),0),(name))
  48 
  49 #define GST_SIMPLE_CAPS_HAS_FIELD(caps,field) \
  50     gst_structure_has_field(gst_caps_get_structure((caps),0),(field))
  51 
  52 static const guint aac_sample_rates[] = { 96000, 88200, 64000, 48000, 44100,
  53   32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350
  54 };
  55 
  56 static const gchar *
  57 digit_to_string (guint digit)
  58 {
  59   static const char itoa[][2] = {
  60     &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;
  61   };
  62 
  63   if (G_LIKELY (digit &lt; 10))
  64     return itoa[digit];
  65   else
  66     return NULL;
  67 }
  68 
  69 /**
  70  * gst_codec_utils_aac_get_sample_rate_from_index:
  71  * @sr_idx: Sample rate index as from the AudioSpecificConfig (MPEG-4
  72  *          container) or ADTS frame header
  73  *
  74  * Translates the sample rate index found in AAC headers to the actual sample
  75  * rate.
  76  *
  77  * Returns: The sample rate if @sr_idx is valid, 0 otherwise.
  78  */
  79 guint
  80 gst_codec_utils_aac_get_sample_rate_from_index (guint sr_idx)
  81 {
  82   if (G_LIKELY (sr_idx &lt; G_N_ELEMENTS (aac_sample_rates)))
  83     return aac_sample_rates[sr_idx];
  84 
  85   GST_WARNING (&quot;Invalid sample rate index %u&quot;, sr_idx);
  86   return 0;
  87 }
  88 
  89 /**
  90  * gst_codec_utils_aac_get_index_from_sample_rate:
  91  * @rate: Sample rate
  92  *
  93  * Translates the sample rate to the index corresponding to it in AAC spec.
  94  *
  95  * Returns: The AAC index for this sample rate, -1 if the rate is not a
  96  * valid AAC sample rate.
  97  */
  98 gint
  99 gst_codec_utils_aac_get_index_from_sample_rate (guint rate)
 100 {
 101   guint n;
 102 
 103   for (n = 0; n &lt; G_N_ELEMENTS (aac_sample_rates); n++)
 104     if (aac_sample_rates[n] == rate)
 105       return n;
 106 
 107   GST_WARNING (&quot;Invalid sample rate %u&quot;, rate);
 108   return -1;
 109 }
 110 
 111 static gboolean
 112 gst_codec_utils_aac_get_audio_object_type (GstBitReader * br,
 113     guint8 * audio_object_type)
 114 {
 115   guint8 aot;
 116 
 117   if (!gst_bit_reader_get_bits_uint8 (br, &amp;aot, 5))
 118     return FALSE;
 119 
 120   if (aot == 31) {
 121     if (!gst_bit_reader_get_bits_uint8 (br, &amp;aot, 6))
 122       return FALSE;
 123     aot += 32;
 124   }
 125 
 126   *audio_object_type = aot;
 127 
 128   return TRUE;
 129 }
 130 
 131 static gboolean
 132 gst_codec_utils_aac_get_audio_sample_rate (GstBitReader * br,
 133     guint * sample_rate)
 134 {
 135   guint8 sampling_freq_index;
 136   guint32 sampling_rate;
 137 
 138   if (!gst_bit_reader_get_bits_uint8 (br, &amp;sampling_freq_index, 4))
 139     return FALSE;
 140 
 141   if (sampling_freq_index == 0xf) {
 142     if (!gst_bit_reader_get_bits_uint32 (br, &amp;sampling_rate, 24))
 143       return FALSE;
 144   } else {
 145     sampling_rate =
 146         gst_codec_utils_aac_get_sample_rate_from_index (sampling_freq_index);
 147     if (!sampling_rate)
 148       return FALSE;
 149   }
 150 
 151   *sample_rate = sampling_rate;
 152 
 153   return TRUE;
 154 }
 155 
 156 static gboolean
 157 gst_codec_utils_aac_get_audio_object_type_full (GstBitReader * br,
 158     guint8 * audio_object_type, guint8 * channel_config, guint * sample_rate)
 159 {
 160   guint8 aot, channels;
 161   guint rate;
 162 
 163   if (!gst_codec_utils_aac_get_audio_object_type (br, &amp;aot))
 164     return FALSE;
 165 
 166   if (!gst_codec_utils_aac_get_audio_sample_rate (br, &amp;rate))
 167     return FALSE;
 168 
 169   if (!gst_bit_reader_get_bits_uint8 (br, &amp;channels, 4))
 170     return FALSE;
 171 
 172   /* 5 indicates SBR extension (i.e. HE-AAC) */
 173   /* 29 indicates PS extension */
 174   if (aot == 5 || aot == 29) {
 175     if (!gst_codec_utils_aac_get_audio_sample_rate (br, &amp;rate))
 176       return FALSE;
 177     if (!gst_codec_utils_aac_get_audio_object_type (br, &amp;aot))
 178       return FALSE;
 179   }
 180 
 181   *audio_object_type = aot;
 182   *sample_rate = rate;
 183   *channel_config = channels;
 184 
 185   return TRUE;
 186 }
 187 
 188 /**
 189  * gst_codec_utils_aac_get_sample_rate:
 190  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 191  *                as specified in the Elementary Stream Descriptor (esds)
 192  *                in ISO/IEC 14496-1.
 193  * @len: Length of @audio_config
 194  *
 195  * Translates the sample rate index found in AAC headers to the actual sample
 196  * rate.
 197  *
 198  * Returns: The sample rate if sr_idx is valid, 0 otherwise.
 199  *
 200  * Since: 1.10
 201  */
 202 guint
 203 gst_codec_utils_aac_get_sample_rate (const guint8 * audio_config, guint len)
 204 {
 205   guint sample_rate = 0;
 206   guint8 audio_object_type = 0, channel_config = 0;
 207   GstBitReader br = GST_BIT_READER_INIT (audio_config, len);
 208 
 209   if (len &lt; 2)
 210     return 0;
 211 
 212   gst_codec_utils_aac_get_audio_object_type_full (&amp;br, &amp;audio_object_type,
 213       &amp;channel_config, &amp;sample_rate);
 214 
 215   return sample_rate;
 216 }
 217 
 218 /**
 219  * gst_codec_utils_aac_get_channels:
 220  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 221  *                as specified in the Elementary Stream Descriptor (esds)
 222  *                in ISO/IEC 14496-1.
 223  * @len: Length of @audio_config in bytes
 224  *
 225  * Returns the channels of the given AAC stream.
 226  *
 227  * Returns: The channels or 0 if the channel could not be determined.
 228  *
 229  * Since: 1.10
 230  */
 231 guint
 232 gst_codec_utils_aac_get_channels (const guint8 * audio_config, guint len)
 233 {
 234   guint channels;
 235 
 236   if (len &lt; 2)
 237     return 0;
 238 
 239   channels = (audio_config[1] &amp; 0x7f) &gt;&gt; 3;
 240   if (channels &gt; 0 &amp;&amp; channels &lt; 7)
 241     return channels;
 242   else if (channels == 7)
 243     return 8;
 244   else
 245     return 0;
 246 }
 247 
 248 /**
 249  * gst_codec_utils_aac_get_profile:
 250  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 251  *                as specified in the Elementary Stream Descriptor (esds)
 252  *                in ISO/IEC 14496-1.
 253  * @len: Length of @audio_config in bytes
 254  *
 255  * Returns the profile of the given AAC stream as a string. The profile is
 256  * normally determined using the AudioObjectType field which is in the first
 257  * 5 bits of @audio_config
 258  *
 259  * Returns: The profile as a const string and %NULL if the profile could not be
 260  * determined.
 261  */
 262 const gchar *
 263 gst_codec_utils_aac_get_profile (const guint8 * audio_config, guint len)
 264 {
 265   const gchar *profile = NULL;
 266   guint sample_rate;
 267   guint8 audio_object_type, channel_config;
 268   GstBitReader br = GST_BIT_READER_INIT (audio_config, len);
 269 
 270   if (len &lt; 1)
 271     return NULL;
 272 
 273   GST_MEMDUMP (&quot;audio config&quot;, audio_config, len);
 274 
 275   if (!gst_codec_utils_aac_get_audio_object_type_full (&amp;br, &amp;audio_object_type,
 276           &amp;channel_config, &amp;sample_rate)) {
 277     return NULL;
 278   }
 279 
 280   switch (audio_object_type) {
 281     case 1:
 282       profile = &quot;main&quot;;
 283       break;
 284     case 2:
 285       profile = &quot;lc&quot;;
 286       break;
 287     case 3:
 288       profile = &quot;ssr&quot;;
 289       break;
 290     case 4:
 291       profile = &quot;ltp&quot;;
 292       break;
 293     default:
 294       GST_DEBUG (&quot;Invalid profile idx: %u&quot;, audio_object_type);
 295       break;
 296   }
 297 
 298   return profile;
 299 }
 300 
 301 /**
 302  * gst_codec_utils_aac_get_level:
 303  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 304  *                as specified in the Elementary Stream Descriptor (esds)
 305  *                in ISO/IEC 14496-1.
 306  * @len: Length of @audio_config in bytes
 307  *
 308  * Determines the level of a stream as defined in ISO/IEC 14496-3. For AAC LC
 309  * streams, the constraints from the AAC audio profile are applied. For AAC
 310  * Main, LTP, SSR and others, the Main profile is used.
 311  *
 312  * The @audio_config parameter follows the following format, starting from the
 313  * most significant bit of the first byte:
 314  *
 315  *   * Bit 0:4 contains the AudioObjectType (if this is 0x5, then the
 316  *     real AudioObjectType is carried after the rate and channel data)
 317  *   * Bit 5:8 contains the sample frequency index (if this is 0xf, then the
 318  *     next 24 bits define the actual sample frequency, and subsequent
 319  *     fields are appropriately shifted).
 320  *   * Bit 9:12 contains the channel configuration
 321  *
 322  * Returns: The level as a const string and %NULL if the level could not be
 323  * determined.
 324  */
 325 const gchar *
 326 gst_codec_utils_aac_get_level (const guint8 * audio_config, guint len)
 327 {
 328   guint8 audio_object_type = 0xFF, channel_config = 0xFF;
 329   guint rate;
 330   /* Number of single channel elements, channel pair elements, low frequency
 331    * elements, independently switched coupling channel elements, and
 332    * dependently switched coupling channel elements.
 333    *
 334    * Note: The 2 CCE types are ignored for now as they require us to actually
 335    * parse the first frame, and they are rarely found in actual streams.
 336    */
 337   int num_sce = 0, num_cpe = 0, num_lfe = 0, num_cce_indep = 0, num_cce_dep = 0;
 338   int num_channels;
 339   /* Processor and RAM Complexity Units (calculated and &quot;reference&quot; for single
 340    * channel) */
 341   int pcu = -1, rcu = -1, pcu_ref, rcu_ref;
 342   int ret = -1;
 343   GstBitReader br = GST_BIT_READER_INIT (audio_config, len);
 344 
 345   g_return_val_if_fail (audio_config != NULL, NULL);
 346 
 347   if (len &lt; 2)
 348     return NULL;
 349 
 350   GST_MEMDUMP (&quot;audio config&quot;, audio_config, len);
 351 
 352   if (!gst_codec_utils_aac_get_audio_object_type_full (&amp;br, &amp;audio_object_type,
 353           &amp;channel_config, &amp;rate)) {
 354     return NULL;
 355   }
 356 
 357   switch (channel_config) {
 358     case 0:
 359       /* Channel config is defined in the AudioObjectType&#39;s SpecificConfig,
 360        * which requires some amount of digging through the headers. I only see
 361        * this done in the MPEG conformance streams - FIXME */
 362       GST_WARNING (&quot;Found a stream with channel configuration in the &quot;
 363           &quot;AudioSpecificConfig. Please file a bug with a link to the media if &quot;
 364           &quot;possible.&quot;);
 365       return NULL;
 366     case 1:
 367       /* front center */
 368       num_sce = 1;
 369       break;
 370     case 2:
 371       /* front left and right */
 372       num_cpe = 1;
 373       break;
 374     case 3:
 375       /* front left, right, and center */
 376       num_sce = 1;
 377       num_cpe = 1;
 378       break;
 379     case 4:
 380       /* front left, right, and center; rear surround */
 381       num_sce = 2;
 382       num_cpe = 1;
 383       break;
 384     case 5:
 385       /* front left, right, and center; rear left and right surround */
 386       num_sce = 1;
 387       num_cpe = 2;
 388       break;
 389     case 6:
 390       /* front left, right, center and LFE; rear left and right surround */
 391       num_sce = 1;
 392       num_cpe = 2;
 393       break;
 394     case 7:
 395     case 12:
 396     case 14:
 397       /* front left, right, center and LFE; outside front left and right;
 398        * rear left and right surround */
 399       num_sce = 1;
 400       num_cpe = 3;
 401       num_lfe = 1;
 402       break;
 403     case 11:
 404       num_sce = 2;
 405       num_cpe = 2;
 406       num_lfe = 1;
 407       break;
 408     default:
 409       GST_WARNING (&quot;Unknown channel config in header: %d&quot;, channel_config);
 410       return NULL;
 411   }
 412 
 413   switch (audio_object_type) {
 414     case 0:                    /* NULL */
 415       GST_WARNING (&quot;profile 0 is not a valid profile&quot;);
 416       return NULL;
 417     case 2:                    /* LC */
 418       pcu_ref = 3;
 419       rcu_ref = 3;
 420       break;
 421     case 3:                    /* SSR */
 422       pcu_ref = 4;
 423       rcu_ref = 3;
 424       break;
 425     case 4:                    /* LTP */
 426       pcu_ref = 4;
 427       rcu_ref = 4;
 428       break;
 429     case 1:                    /* Main */
 430     default:
 431       /* Other than a couple of ER profiles, Main is the worst-case */
 432       pcu_ref = 5;
 433       rcu_ref = 5;
 434       break;
 435   }
 436 
 437   /* &quot;fs_ref&quot; is 48000 Hz for AAC Main/LC/SSR/LTP. SBR&#39;s fs_ref is defined as
 438    * 24000/48000 (in/out), for SBR streams. Actual support is a FIXME */
 439 
 440   pcu = ((float) rate / 48000) * pcu_ref *
 441       ((2 * num_cpe) + num_sce + num_lfe + num_cce_indep + (0.3 * num_cce_dep));
 442 
 443   rcu = ((float) rcu_ref) * (num_sce + (0.5 * num_lfe) + (0.5 * num_cce_indep) +
 444       (0.4 * num_cce_dep));
 445 
 446   if (num_cpe &lt; 2)
 447     rcu += (rcu_ref + (rcu_ref - 1)) * num_cpe;
 448   else
 449     rcu += (rcu_ref + (rcu_ref - 1) * ((2 * num_cpe) - 1));
 450 
 451   num_channels = num_sce + (2 * num_cpe) + num_lfe;
 452 
 453   if (audio_object_type == 2) {
 454     /* AAC LC =&gt; return the level as per the &#39;AAC Profile&#39; */
 455     if (num_channels &lt;= 2 &amp;&amp; rate &lt;= 24000 &amp;&amp; pcu &lt;= 3 &amp;&amp; rcu &lt;= 5)
 456       ret = 1;
 457     else if (num_channels &lt;= 2 &amp;&amp; rate &lt;= 48000 &amp;&amp; pcu &lt;= 6 &amp;&amp; rcu &lt;= 5)
 458       ret = 2;
 459     /* There is no level 3 for the AAC Profile */
 460     else if (num_channels &lt;= 5 &amp;&amp; rate &lt;= 48000 &amp;&amp; pcu &lt;= 19 &amp;&amp; rcu &lt;= 15)
 461       ret = 4;
 462     else if (num_channels &lt;= 5 &amp;&amp; rate &lt;= 96000 &amp;&amp; pcu &lt;= 38 &amp;&amp; rcu &lt;= 15)
 463       ret = 5;
 464     else if (num_channels &lt;= 7 &amp;&amp; rate &lt;= 48000 &amp;&amp; pcu &lt;= 25 &amp;&amp; rcu &lt;= 19)
 465       ret = 6;
 466     else if (num_channels &lt;= 7 &amp;&amp; rate &lt;= 96000 &amp;&amp; pcu &lt;= 50 &amp;&amp; rcu &lt;= 19)
 467       ret = 7;
 468   } else {
 469     /* Return the level as per the &#39;Main Profile&#39; */
 470     if (pcu &lt; 40 &amp;&amp; rcu &lt; 20)
 471       ret = 1;
 472     else if (pcu &lt; 80 &amp;&amp; rcu &lt; 64)
 473       ret = 2;
 474     else if (pcu &lt; 160 &amp;&amp; rcu &lt; 128)
 475       ret = 3;
 476     else if (pcu &lt; 320 &amp;&amp; rcu &lt; 256)
 477       ret = 4;
 478   }
 479 
 480   if (ret == -1) {
 481     GST_WARNING (&quot;couldn&#39;t determine level: profile=%u, rate=%u, &quot;
 482         &quot;channel_config=%u, pcu=%d,rcu=%d&quot;, audio_object_type, rate,
 483         channel_config, pcu, rcu);
 484     return NULL;
 485   } else {
 486     return digit_to_string (ret);
 487   }
 488 }
 489 
 490 /**
 491  * gst_codec_utils_aac_caps_set_level_and_profile:
 492  * @caps: the #GstCaps to which level and profile fields are to be added
 493  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 494  *                as specified in the Elementary Stream Descriptor (esds)
 495  *                in ISO/IEC 14496-1. (See below for more details)
 496  * @len: Length of @audio_config in bytes
 497  *
 498  * Sets the level and profile on @caps if it can be determined from
 499  * @audio_config. See gst_codec_utils_aac_get_level() and
 500  * gst_codec_utils_aac_get_profile() for more details on the parameters.
 501  * @caps must be audio/mpeg caps with an &quot;mpegversion&quot; field of either 2 or 4.
 502  * If mpegversion is 4, the &quot;base-profile&quot; field is also set in @caps.
 503  *
 504  * Returns: %TRUE if the level and profile could be set, %FALSE otherwise.
 505  */
 506 gboolean
 507 gst_codec_utils_aac_caps_set_level_and_profile (GstCaps * caps,
 508     const guint8 * audio_config, guint len)
 509 {
 510   GstStructure *s;
 511   const gchar *level, *profile;
 512   int mpegversion = 0;
 513 
 514   g_return_val_if_fail (GST_IS_CAPS (caps), FALSE);
 515   g_return_val_if_fail (GST_CAPS_IS_SIMPLE (caps), FALSE);
 516   g_return_val_if_fail (GST_SIMPLE_CAPS_HAS_NAME (caps, &quot;audio/mpeg&quot;), FALSE);
 517   g_return_val_if_fail (GST_SIMPLE_CAPS_HAS_FIELD (caps, &quot;mpegversion&quot;), FALSE);
 518   g_return_val_if_fail (audio_config != NULL, FALSE);
 519 
 520   s = gst_caps_get_structure (caps, 0);
 521 
 522   gst_structure_get_int (s, &quot;mpegversion&quot;, &amp;mpegversion);
 523   g_return_val_if_fail (mpegversion == 2 || mpegversion == 4, FALSE);
 524 
 525   level = gst_codec_utils_aac_get_level (audio_config, len);
 526 
 527   if (level != NULL)
 528     gst_structure_set (s, &quot;level&quot;, G_TYPE_STRING, level, NULL);
 529 
 530   profile = gst_codec_utils_aac_get_profile (audio_config, len);
 531 
 532   if (profile != NULL) {
 533     if (mpegversion == 4) {
 534       gst_structure_set (s, &quot;base-profile&quot;, G_TYPE_STRING, profile,
 535           &quot;profile&quot;, G_TYPE_STRING, profile, NULL);
 536     } else {
 537       gst_structure_set (s, &quot;profile&quot;, G_TYPE_STRING, profile, NULL);
 538     }
 539   }
 540 
 541   GST_LOG (&quot;profile : %s&quot;, (profile) ? profile : &quot;---&quot;);
 542   GST_LOG (&quot;level   : %s&quot;, (level) ? level : &quot;---&quot;);
 543 
 544   return (level != NULL &amp;&amp; profile != NULL);
 545 }
 546 
 547 /**
 548  * gst_codec_utils_h264_get_profile:
 549  * @sps: (array length=len): Pointer to the sequence parameter set for the stream.
 550  * @len: Length of the data available in @sps.
 551  *
 552  * Converts the profile indication (profile_idc) in the stream&#39;s
 553  * sequence parameter set into a string. The SPS is expected to have the
 554  * following format, as defined in the H.264 specification. The SPS is viewed
 555  * as a bitstream here, with bit 0 being the most significant bit of the first
 556  * byte.
 557  *
 558  * * Bit 0:7   - Profile indication
 559  * * Bit 8     - constraint_set0_flag
 560  * * Bit 9     - constraint_set1_flag
 561  * * Bit 10    - constraint_set2_flag
 562  * * Bit 11    - constraint_set3_flag
 563  * * Bit 12    - constraint_set3_flag
 564  * * Bit 13:15 - Reserved
 565  * * Bit 16:24 - Level indication
 566  *
 567  * Returns: The profile as a const string, or %NULL if there is an error.
 568  */
 569 const gchar *
 570 gst_codec_utils_h264_get_profile (const guint8 * sps, guint len)
 571 {
 572   const gchar *profile = NULL;
 573   gint csf1, csf3, csf5;
 574 
 575   g_return_val_if_fail (sps != NULL, NULL);
 576 
 577   if (len &lt; 2)
 578     return NULL;
 579 
 580   GST_MEMDUMP (&quot;SPS&quot;, sps, len);
 581 
 582   csf1 = (sps[1] &amp; 0x40) &gt;&gt; 6;
 583   csf3 = (sps[1] &amp; 0x10) &gt;&gt; 4;
 584   csf5 = (sps[1] &amp; 0x04) &gt;&gt; 2;
 585 
 586   switch (sps[0]) {
 587     case 66:
 588       if (csf1)
 589         profile = &quot;constrained-baseline&quot;;
 590       else
 591         profile = &quot;baseline&quot;;
 592       break;
 593     case 77:
 594       profile = &quot;main&quot;;
 595       break;
 596     case 88:
 597       profile = &quot;extended&quot;;
 598       break;
 599     case 100:
 600       profile = &quot;high&quot;;
 601       break;
 602     case 110:
 603       if (csf3)
 604         profile = &quot;high-10-intra&quot;;
 605       else
 606         profile = &quot;high-10&quot;;
 607       break;
 608     case 122:
 609       if (csf3)
 610         profile = &quot;high-4:2:2-intra&quot;;
 611       else
 612         profile = &quot;high-4:2:2&quot;;
 613       break;
 614     case 244:
 615       if (csf3)
 616         profile = &quot;high-4:4:4-intra&quot;;
 617       else
 618         profile = &quot;high-4:4:4&quot;;
 619       break;
 620     case 44:
 621       profile = &quot;cavlc-4:4:4-intra&quot;;
 622       break;
 623     case 118:
 624       profile = &quot;multiview-high&quot;;
 625       break;
 626     case 128:
 627       profile = &quot;stereo-high&quot;;
 628       break;
 629     case 83:
 630       if (csf5)
 631         profile = &quot;scalable-constrained-baseline&quot;;
 632       else
 633         profile = &quot;scalable-baseline&quot;;
 634       break;
 635     case 86:
 636       if (csf3)
 637         profile = &quot;scalable-high-intra&quot;;
 638       else if (csf5)
 639         profile = &quot;scalable-constrained-high&quot;;
 640       else
 641         profile = &quot;scalable-high&quot;;
 642       break;
 643     default:
 644       return NULL;
 645   }
 646 
 647   return profile;
 648 }
 649 
 650 /**
 651  * gst_codec_utils_h264_get_level:
 652  * @sps: (array length=len): Pointer to the sequence parameter set for the stream.
 653  * @len: Length of the data available in @sps.
 654  *
 655  * Converts the level indication (level_idc) in the stream&#39;s
 656  * sequence parameter set into a string. The SPS is expected to have the
 657  * same format as for gst_codec_utils_h264_get_profile().
 658  *
 659  * Returns: The level as a const string, or %NULL if there is an error.
 660  */
 661 const gchar *
 662 gst_codec_utils_h264_get_level (const guint8 * sps, guint len)
 663 {
 664   gint csf3;
 665 
 666   g_return_val_if_fail (sps != NULL, NULL);
 667 
 668   if (len &lt; 3)
 669     return NULL;
 670 
 671   GST_MEMDUMP (&quot;SPS&quot;, sps, len);
 672 
 673   csf3 = (sps[1] &amp; 0x10) &gt;&gt; 4;
 674 
 675   if (sps[2] == 0)
 676     return NULL;
 677   else if ((sps[2] == 11 &amp;&amp; csf3) || sps[2] == 9)
 678     return &quot;1b&quot;;
 679   else if (sps[2] % 10 == 0)
 680     return digit_to_string (sps[2] / 10);
 681   else {
 682     switch (sps[2]) {
 683       case 11:
 684         return &quot;1.1&quot;;
 685       case 12:
 686         return &quot;1.2&quot;;
 687       case 13:
 688         return &quot;1.3&quot;;
 689       case 21:
 690         return &quot;2.1&quot;;
 691       case 22:
 692         return &quot;2.2&quot;;
 693       case 31:
 694         return &quot;3.1&quot;;
 695       case 32:
 696         return &quot;3.2&quot;;
 697       case 41:
 698         return &quot;4.1&quot;;
 699       case 42:
 700         return &quot;4.2&quot;;
 701       case 51:
 702         return &quot;5.1&quot;;
 703       case 52:
 704         return &quot;5.2&quot;;
 705       default:
 706         return NULL;
 707     }
 708   }
 709 }
 710 
 711 /**
 712  * gst_codec_utils_h264_get_level_idc:
 713  * @level: A level string from caps
 714  *
 715  * Transform a level string from the caps into the level_idc
 716  *
 717  * Returns: the level_idc or 0 if the level is unknown
 718  */
 719 guint8
 720 gst_codec_utils_h264_get_level_idc (const gchar * level)
 721 {
 722   g_return_val_if_fail (level != NULL, 0);
 723 
 724   if (!strcmp (level, &quot;1&quot;))
 725     return 10;
 726   else if (!strcmp (level, &quot;1b&quot;))
 727     return 9;
 728   else if (!strcmp (level, &quot;1.1&quot;))
 729     return 11;
 730   else if (!strcmp (level, &quot;1.2&quot;))
 731     return 12;
 732   else if (!strcmp (level, &quot;1.3&quot;))
 733     return 13;
 734   else if (!strcmp (level, &quot;2&quot;))
 735     return 20;
 736   else if (!strcmp (level, &quot;2.1&quot;))
 737     return 21;
 738   else if (!strcmp (level, &quot;2.2&quot;))
 739     return 22;
 740   else if (!strcmp (level, &quot;3&quot;))
 741     return 30;
 742   else if (!strcmp (level, &quot;3.1&quot;))
 743     return 31;
 744   else if (!strcmp (level, &quot;3.2&quot;))
 745     return 32;
 746   else if (!strcmp (level, &quot;4&quot;))
 747     return 40;
 748   else if (!strcmp (level, &quot;4.1&quot;))
 749     return 41;
 750   else if (!strcmp (level, &quot;4.2&quot;))
 751     return 42;
 752   else if (!strcmp (level, &quot;5&quot;))
 753     return 50;
 754   else if (!strcmp (level, &quot;5.1&quot;))
 755     return 51;
 756   else if (!strcmp (level, &quot;5.2&quot;))
 757     return 52;
 758 
 759   GST_WARNING (&quot;Invalid level %s&quot;, level);
 760   return 0;
 761 }
 762 
 763 /**
 764  * gst_codec_utils_h264_caps_set_level_and_profile:
 765  * @caps: the #GstCaps to which the level and profile are to be added
 766  * @sps: (array length=len): Pointer to the sequence parameter set for the stream.
 767  * @len: Length of the data available in @sps.
 768  *
 769  * Sets the level and profile in @caps if it can be determined from @sps. See
 770  * gst_codec_utils_h264_get_level() and gst_codec_utils_h264_get_profile()
 771  * for more details on the parameters.
 772  *
 773  * Returns: %TRUE if the level and profile could be set, %FALSE otherwise.
 774  */
 775 gboolean
 776 gst_codec_utils_h264_caps_set_level_and_profile (GstCaps * caps,
 777     const guint8 * sps, guint len)
 778 {
 779   const gchar *level, *profile;
 780 
 781   g_return_val_if_fail (GST_IS_CAPS (caps), FALSE);
 782   g_return_val_if_fail (GST_CAPS_IS_SIMPLE (caps), FALSE);
 783   g_return_val_if_fail (GST_SIMPLE_CAPS_HAS_NAME (caps, &quot;video/x-h264&quot;), FALSE);
 784   g_return_val_if_fail (sps != NULL, FALSE);
 785 
 786   level = gst_codec_utils_h264_get_level (sps, len);
 787 
 788   if (level != NULL)
 789     gst_caps_set_simple (caps, &quot;level&quot;, G_TYPE_STRING, level, NULL);
 790 
 791   profile = gst_codec_utils_h264_get_profile (sps, len);
 792 
 793   if (profile != NULL)
 794     gst_caps_set_simple (caps, &quot;profile&quot;, G_TYPE_STRING, profile, NULL);
 795 
 796   GST_LOG (&quot;profile : %s&quot;, (profile) ? profile : &quot;---&quot;);
 797   GST_LOG (&quot;level   : %s&quot;, (level) ? level : &quot;---&quot;);
 798 
 799   return (level != NULL &amp;&amp; profile != NULL);
 800 }
 801 
 802 /**
 803  * gst_codec_utils_h265_get_profile:
 804  * @profile_tier_level: (array length=len): Pointer to the profile_tier_level
 805  *   structure for the stream.
 806  * @len: Length of the data available in @profile_tier_level
 807  *
 808  * Converts the profile indication (general_profile_idc) in the stream&#39;s
 809  * profile_level_tier structure into a string. The profile_tier_level is
 810  * expected to have the following format, as defined in the H.265
 811  * specification. The profile_tier_level is viewed as a bitstream here,
 812  * with bit 0 being the most significant bit of the first byte.
 813  *
 814  * * Bit 0:1   - general_profile_space
 815  * * Bit 2     - general_tier_flag
 816  * * Bit 3:7   - general_profile_idc
 817  * * Bit 8:39  - gernal_profile_compatibility_flags
 818  * * Bit 40    - general_progressive_source_flag
 819  * * Bit 41    - general_interlaced_source_flag
 820  * * Bit 42    - general_non_packed_constraint_flag
 821  * * Bit 43    - general_frame_only_constraint_flag
 822  * * Bit 44:87 - general_reserved_zero_44bits
 823  * * Bit 88:95 - general_level_idc
 824  *
 825  * Returns: The profile as a const string, or %NULL if there is an error.
 826  *
 827  * Since: 1.4
 828  */
 829 const gchar *
 830 gst_codec_utils_h265_get_profile (const guint8 * profile_tier_level, guint len)
 831 {
 832   const gchar *profile = NULL;
 833   gint profile_idc;
 834 
 835   g_return_val_if_fail (profile_tier_level != NULL, NULL);
 836 
 837   if (len &lt; 2)
 838     return NULL;
 839 
 840   GST_MEMDUMP (&quot;ProfileTierLevel&quot;, profile_tier_level, len);
 841 
 842   profile_idc = (profile_tier_level[0] &amp; 0x1f);
 843 
 844   if (profile_idc == 1)
 845     profile = &quot;main&quot;;
 846   else if (profile_idc == 2)
 847     profile = &quot;main-10&quot;;
 848   else if (profile_idc == 3)
 849     profile = &quot;main-still-picture&quot;;
 850   else
 851     profile = NULL;
 852 
 853   return profile;
 854 }
 855 
 856 /**
 857  * gst_codec_utils_h265_get_tier:
 858  * @profile_tier_level: (array length=len): Pointer to the profile_tier_level
 859  *   for the stream.
 860  * @len: Length of the data available in @profile_tier_level.
 861  *
 862  * Converts the tier indication (general_tier_flag) in the stream&#39;s
 863  * profile_tier_level structure into a string. The profile_tier_level
 864  * is expected to have the same format as for gst_codec_utils_h264_get_profile().
 865  *
 866  * Returns: The tier as a const string, or %NULL if there is an error.
 867  *
 868  * Since: 1.4
 869  */
 870 const gchar *
 871 gst_codec_utils_h265_get_tier (const guint8 * profile_tier_level, guint len)
 872 {
 873   const gchar *tier = NULL;
 874   gint tier_flag = 0;
 875 
 876   g_return_val_if_fail (profile_tier_level != NULL, NULL);
 877 
 878   if (len &lt; 1)
 879     return NULL;
 880 
 881   GST_MEMDUMP (&quot;ProfileTierLevel&quot;, profile_tier_level, len);
 882 
 883   tier_flag = (profile_tier_level[0] &amp; 0x20) &gt;&gt; 5;
 884 
 885   if (tier_flag)
 886     tier = &quot;high&quot;;
 887   else
 888     tier = &quot;main&quot;;
 889 
 890   return tier;
 891 }
 892 
 893 /**
 894  * gst_codec_utils_h265_get_level:
 895  * @profile_tier_level: (array length=len): Pointer to the profile_tier_level
 896  *   for the stream
 897  * @len: Length of the data available in @profile_tier_level.
 898  *
 899  * Converts the level indication (general_level_idc) in the stream&#39;s
 900  * profile_tier_level structure into a string. The profiel_tier_level is
 901  * expected to have the same format as for gst_codec_utils_h264_get_profile().
 902  *
 903  * Returns: The level as a const string, or %NULL if there is an error.
 904  *
 905  * Since: 1.4
 906  */
 907 const gchar *
 908 gst_codec_utils_h265_get_level (const guint8 * profile_tier_level, guint len)
 909 {
 910   g_return_val_if_fail (profile_tier_level != NULL, NULL);
 911 
 912   if (len &lt; 12)
 913     return NULL;
 914 
 915   GST_MEMDUMP (&quot;ProfileTierLevel&quot;, profile_tier_level, len);
 916 
 917   if (profile_tier_level[11] == 0)
 918     return NULL;
 919   else if (profile_tier_level[11] % 30 == 0)
 920     return digit_to_string (profile_tier_level[11] / 30);
 921   else {
 922     switch (profile_tier_level[11]) {
 923       case 63:
 924         return &quot;2.1&quot;;
 925         break;
 926       case 93:
 927         return &quot;3.1&quot;;
 928         break;
 929       case 123:
 930         return &quot;4.1&quot;;
 931         break;
 932       case 153:
 933         return &quot;5.1&quot;;
 934         break;
 935       case 156:
 936         return &quot;5.2&quot;;
 937         break;
 938       case 183:
 939         return &quot;6.1&quot;;
 940         break;
 941       case 186:
 942         return &quot;6.2&quot;;
 943         break;
 944       default:
 945         return NULL;
 946     }
 947   }
 948 }
 949 
 950 /**
 951  * gst_codec_utils_h265_get_level_idc:
 952  * @level: A level string from caps
 953  *
 954  * Transform a level string from the caps into the level_idc
 955  *
 956  * Returns: the level_idc or 0 if the level is unknown
 957  *
 958  * Since: 1.4
 959  */
 960 guint8
 961 gst_codec_utils_h265_get_level_idc (const gchar * level)
 962 {
 963   g_return_val_if_fail (level != NULL, 0);
 964 
 965   if (!strcmp (level, &quot;1&quot;))
 966     return 30;
 967   else if (!strcmp (level, &quot;2&quot;))
 968     return 60;
 969   else if (!strcmp (level, &quot;2.1&quot;))
 970     return 63;
 971   else if (!strcmp (level, &quot;3&quot;))
 972     return 90;
 973   else if (!strcmp (level, &quot;3.1&quot;))
 974     return 93;
 975   else if (!strcmp (level, &quot;4&quot;))
 976     return 120;
 977   else if (!strcmp (level, &quot;4.1&quot;))
 978     return 123;
 979   else if (!strcmp (level, &quot;5&quot;))
 980     return 150;
 981   else if (!strcmp (level, &quot;5.1&quot;))
 982     return 153;
 983   else if (!strcmp (level, &quot;5.2&quot;))
 984     return 156;
 985   else if (!strcmp (level, &quot;6&quot;))
 986     return 180;
 987   else if (!strcmp (level, &quot;6.1&quot;))
 988     return 183;
 989   else if (!strcmp (level, &quot;6.2&quot;))
 990     return 186;
 991 
 992   GST_WARNING (&quot;Invalid level %s&quot;, level);
 993   return 0;
 994 }
 995 
 996 /**
 997  * gst_codec_utils_h265_caps_set_level_tier_and_profile:
 998  * @caps: the #GstCaps to which the level, tier and profile are to be added
 999  * @profile_tier_level: (array length=len): Pointer to the profile_tier_level
1000  *   struct
1001  * @len: Length of the data available in @profile_tier_level.
1002  *
1003  * Sets the level, tier and profile in @caps if it can be determined from
1004  * @profile_tier_level. See gst_codec_utils_h265_get_level(),
1005  * gst_codec_utils_h265_get_tier() and gst_codec_utils_h265_get_profile()
1006  * for more details on the parameters.
1007  *
1008  * Returns: %TRUE if the level, tier, profile could be set, %FALSE otherwise.
1009  *
1010  * Since: 1.4
1011  */
1012 gboolean
1013 gst_codec_utils_h265_caps_set_level_tier_and_profile (GstCaps * caps,
1014     const guint8 * profile_tier_level, guint len)
1015 {
1016   const gchar *level, *tier, *profile;
1017 
1018   g_return_val_if_fail (GST_IS_CAPS (caps), FALSE);
1019   g_return_val_if_fail (GST_CAPS_IS_SIMPLE (caps), FALSE);
1020   g_return_val_if_fail (GST_SIMPLE_CAPS_HAS_NAME (caps, &quot;video/x-h265&quot;), FALSE);
1021   g_return_val_if_fail (profile_tier_level != NULL, FALSE);
1022 
1023   level = gst_codec_utils_h265_get_level (profile_tier_level, len);
1024   if (level != NULL)
1025     gst_caps_set_simple (caps, &quot;level&quot;, G_TYPE_STRING, level, NULL);
1026 
1027   tier = gst_codec_utils_h265_get_tier (profile_tier_level, len);
1028   if (tier != NULL)
1029     gst_caps_set_simple (caps, &quot;tier&quot;, G_TYPE_STRING, tier, NULL);
1030 
1031   profile = gst_codec_utils_h265_get_profile (profile_tier_level, len);
1032   if (profile != NULL)
1033     gst_caps_set_simple (caps, &quot;profile&quot;, G_TYPE_STRING, profile, NULL);
1034 
1035   GST_LOG (&quot;profile : %s&quot;, (profile) ? profile : &quot;---&quot;);
1036   GST_LOG (&quot;tier    : %s&quot;, (tier) ? tier : &quot;---&quot;);
1037   GST_LOG (&quot;level   : %s&quot;, (level) ? level : &quot;---&quot;);
1038 
1039   return (level != NULL &amp;&amp; tier != NULL &amp;&amp; profile != NULL);
1040 }
1041 
1042 /**
1043  * gst_codec_utils_mpeg4video_get_profile:
1044  * @vis_obj_seq: (array length=len): Pointer to the visual object
1045  *   sequence for the stream.
1046  * @len: Length of the data available in @sps.
1047  *
1048  * Converts the profile indication in the stream&#39;s visual object sequence into
1049  * a string. @vis_obj_seq is expected to be the data following the visual
1050  * object sequence start code. Only the first byte
1051  * (profile_and_level_indication) is used.
1052  *
1053  * Returns: The profile as a const string, or NULL if there is an error.
1054  */
1055 const gchar *
1056 gst_codec_utils_mpeg4video_get_profile (const guint8 * vis_obj_seq, guint len)
1057 {
1058   /* The profile/level codes are from 14496-2, table G-1, and the Wireshark
1059    * sources: epan/dissectors/packet-mp4ves.c */
1060 
1061   /* These are a direct mapping from the integer profile id -&gt; string. Profiles
1062    * 0x6, 0xe and 0xf can correspond to more than one profile depending on the
1063    * second 4 bits of vis_obj_seq[0], so they are handled separately. */
1064   static const char *profiles[] = { &quot;simple&quot;, &quot;simple-scalable&quot;, &quot;core&quot;,
1065     &quot;main&quot;, &quot;n-bit&quot;, &quot;scalable&quot;, NULL, &quot;basic-animated-texture&quot;, &quot;hybrid&quot;,
1066     &quot;advanced-real-time-simple&quot;, &quot;core-scalable&quot;, &quot;advanced-coding-efficiency&quot;,
1067     &quot;advanced-core&quot;, &quot;advanced-scalable-texture&quot;,
1068   };
1069   int profile_id, level_id;
1070 
1071   g_return_val_if_fail (vis_obj_seq != NULL, NULL);
1072 
1073   if (len &lt; 1)
1074     return NULL;
1075 
1076   GST_MEMDUMP (&quot;VOS&quot;, vis_obj_seq, len);
1077 
1078   profile_id = vis_obj_seq[0] &gt;&gt; 4;
1079   level_id = vis_obj_seq[0] &amp; 0xf;
1080 
1081   GST_LOG (&quot;profile_id = %d, level_id = %d&quot;, profile_id, level_id);
1082 
1083   if (profile_id != 6 &amp;&amp; profile_id &lt; 0xe)
1084     return profiles[profile_id];
1085 
1086   if (profile_id != 0xf &amp;&amp; level_id == 0)
1087     return NULL;
1088 
1089   switch (profile_id) {
1090     case 0x6:
1091       if (level_id &lt; 3)
1092         return &quot;simple-face&quot;;
1093       else if (level_id &lt; 5)
1094         return &quot;simple-fba&quot;;
1095       break;
1096 
1097     case 0xe:
1098       if (level_id &lt; 5)
1099         return &quot;simple-studio&quot;;
1100       else if (level_id &lt; 9)
1101         return &quot;core-studio&quot;;
1102       break;
1103 
1104     case 0xf:
1105       if (level_id &lt; 6)
1106         return &quot;advanced-simple&quot;;
1107       else if (level_id &gt; 7 &amp;&amp; level_id &lt; 0xe)
1108         return &quot;fine-granularity-scalable&quot;;
1109       break;
1110   }
1111 
1112   return NULL;
1113 }
1114 
1115 /**
1116  * gst_codec_utils_mpeg4video_get_level:
1117  * @vis_obj_seq: (array length=len): Pointer to the visual object
1118  *   sequence for the stream.
1119  * @len: Length of the data available in @sps.
1120  *
1121  * Converts the level indication in the stream&#39;s visual object sequence into
1122  * a string. @vis_obj_seq is expected to be the data following the visual
1123  * object sequence start code. Only the first byte
1124  * (profile_and_level_indication) is used.
1125  *
1126  * Returns: The level as a const string, or NULL if there is an error.
1127  */
1128 const gchar *
1129 gst_codec_utils_mpeg4video_get_level (const guint8 * vis_obj_seq, guint len)
1130 {
1131   /* The profile/level codes are from 14496-2, table G-1, the Wireshark
1132    * sources: epan/dissectors/packet-mp4ves.c and the Xvid Sources:
1133    * src/xvid.h.
1134    * Levels 4a and 5 for SP were added in Amendment 2, level 6 in Amendment 4
1135    * (see Xvid sources vfw/config.c)
1136    *
1137    * Each profile has a different maximum level it defines. Some of them still
1138    * need special case handling, because not all levels start from 1, and the
1139    * Simple profile defines an intermediate level as well. */
1140   static const int level_max[] = { 6, 2, 2, 4, 2, 1, 2, 2, 2, 4, 3, 4, 2, 3, 4,
1141     5
1142   };
1143   int profile_id, level_id;
1144 
1145   g_return_val_if_fail (vis_obj_seq != NULL, NULL);
1146 
1147   if (len &lt; 1)
1148     return NULL;
1149 
1150   GST_MEMDUMP (&quot;VOS&quot;, vis_obj_seq, len);
1151 
1152   profile_id = vis_obj_seq[0] &gt;&gt; 4;
1153   level_id = vis_obj_seq[0] &amp; 0xf;
1154 
1155   GST_LOG (&quot;profile_id = %d, level_id = %d&quot;, profile_id, level_id);
1156 
1157   if (profile_id != 0xf &amp;&amp; level_id == 0)
1158     return NULL;
1159 
1160   /* Let&#39;s do some validation of the level */
1161   switch (profile_id) {
1162     case 0x3:
1163       if (level_id == 1)
1164         return NULL;
1165       break;
1166 
1167     case 0x4:
1168       if (level_id != 2)
1169         return NULL;
1170       break;
1171 
1172     case 0x6:
1173       if (level_id &gt; 5)
1174         return NULL;
1175       break;
1176 
1177     case 0xe:
1178       if (level_id &gt; 9)
1179         return NULL;
1180       break;
1181 
1182     case 0xf:
1183       if (level_id == 6 || level_id == 7 || level_id &gt; 0xd)
1184         return NULL;
1185       break;
1186   }
1187 
1188   if (profile_id == 0 &amp;&amp; level_id == 8)
1189     /* Simple Profile / Level 0 */
1190     return &quot;0&quot;;
1191   else if (profile_id == 0 &amp;&amp; level_id == 9)
1192     /* Simple Profile / Level 0b */
1193     return &quot;0b&quot;;
1194   else if (profile_id == 0 &amp;&amp; level_id == 4)
1195     /* Simple Profile / Level 4a */
1196     return &quot;4a&quot;;
1197   else if (profile_id == 0xf &amp;&amp; level_id &gt; 7)
1198     /* Fine Granularity Scalable Profile */
1199     return digit_to_string (level_id - 8);
1200   else if (level_id &lt;= level_max[profile_id])
1201     /* Levels for all other cases */
1202     return digit_to_string (level_id);
1203 
1204   return NULL;
1205 }
1206 
1207 /**
1208  * gst_codec_utils_mpeg4video_caps_set_level_and_profile:
1209  * @caps: the #GstCaps to which the level and profile are to be added
1210  * @vis_obj_seq: (array length=len): Pointer to the visual object
1211  *   sequence for the stream.
1212  * @len: Length of the data available in @sps.
1213  *
1214  * Sets the level and profile in @caps if it can be determined from
1215  * @vis_obj_seq. See gst_codec_utils_mpeg4video_get_level() and
1216  * gst_codec_utils_mpeg4video_get_profile() for more details on the
1217  * parameters.
1218  *
1219  * Returns: %TRUE if the level and profile could be set, %FALSE otherwise.
1220  */
1221 gboolean
1222 gst_codec_utils_mpeg4video_caps_set_level_and_profile (GstCaps * caps,
1223     const guint8 * vis_obj_seq, guint len)
1224 {
1225   const gchar *profile, *level;
1226 
1227   g_return_val_if_fail (GST_IS_CAPS (caps), FALSE);
1228   g_return_val_if_fail (GST_CAPS_IS_SIMPLE (caps), FALSE);
1229   g_return_val_if_fail (vis_obj_seq != NULL, FALSE);
1230 
1231   profile = gst_codec_utils_mpeg4video_get_profile (vis_obj_seq, len);
1232 
1233   if (profile != NULL)
1234     gst_caps_set_simple (caps, &quot;profile&quot;, G_TYPE_STRING, profile, NULL);
1235 
1236   level = gst_codec_utils_mpeg4video_get_level (vis_obj_seq, len);
1237 
1238   if (level != NULL)
1239     gst_caps_set_simple (caps, &quot;level&quot;, G_TYPE_STRING, level, NULL);
1240 
1241   GST_LOG (&quot;profile : %s&quot;, (profile) ? profile : &quot;---&quot;);
1242   GST_LOG (&quot;level   : %s&quot;, (level) ? level : &quot;---&quot;);
1243 
1244   return (profile != NULL &amp;&amp; level != NULL);
1245 }
1246 
1247 #ifndef GSTREAMER_LITE
1248 /**
1249  * gst_codec_utils_opus_parse_caps:
1250  * @caps: the #GstCaps to parse the data from
1251  * @rate: (out): the sample rate
1252  * @channels: (out): the number of channels
1253  * @channel_mapping_family: (out): the channel mapping family
1254  * @stream_count: (out): the number of independent streams
1255  * @coupled_count: (out): the number of stereo streams
1256  * @channel_mapping: (out) (array fixed-size=256): the mapping between the streams
1257  *
1258  * Parses Opus caps and fills the different fields with defaults if possible.
1259  *
1260  * Returns: %TRUE if parsing was successful, %FALSE otherwise.
1261  *
1262  * Since: 1.8
1263  */
1264 gboolean
1265 gst_codec_utils_opus_parse_caps (GstCaps * caps,
1266     guint32 * rate,
1267     guint8 * channels,
1268     guint8 * channel_mapping_family,
1269     guint8 * stream_count, guint8 * coupled_count, guint8 channel_mapping[256])
1270 {
1271   GstStructure *s;
1272   gint c, f, sc, cc;
1273   const GValue *va, *v;
1274 
1275   g_return_val_if_fail (caps != NULL, FALSE);
1276   g_return_val_if_fail (gst_caps_is_fixed (caps), FALSE);
1277   g_return_val_if_fail (!gst_caps_is_empty (caps), FALSE);
1278 
1279   s = gst_caps_get_structure (caps, 0);
1280 
1281   g_return_val_if_fail (gst_structure_has_name (s, &quot;audio/x-opus&quot;), FALSE);
1282   g_return_val_if_fail (gst_structure_has_field_typed (s,
1283           &quot;channel-mapping-family&quot;, G_TYPE_INT), FALSE);
1284 
1285   if (rate) {
1286     gint r;
1287 
1288     if (gst_structure_get_int (s, &quot;rate&quot;, &amp;r))
1289       *rate = r;
1290     else
1291       *rate = 48000;
1292   }
1293 
1294   gst_structure_get_int (s, &quot;channel-mapping-family&quot;, &amp;f);
1295   if (channel_mapping_family)
1296     *channel_mapping_family = f;
1297 
1298   if (!gst_structure_get_int (s, &quot;channels&quot;, &amp;c)) {
1299     if (f == 0)
1300       c = 2;
1301     else
1302       return FALSE;
1303   }
1304 
1305   if (channels)
1306     *channels = c;
1307 
1308   /* RTP mapping */
1309   if (f == 0) {
1310     if (c &gt; 2)
1311       return FALSE;
1312 
1313     if (stream_count)
1314       *stream_count = 1;
1315     if (coupled_count)
1316       *coupled_count = c == 2 ? 1 : 0;
1317 
1318     if (channel_mapping) {
1319       channel_mapping[0] = 0;
1320       channel_mapping[1] = 1;
1321     }
1322 
1323     return TRUE;
1324   }
1325 
1326   if (!gst_structure_get_int (s, &quot;stream-count&quot;, &amp;sc))
1327     return FALSE;
1328   if (stream_count)
1329     *stream_count = sc;
1330 
1331   if (!gst_structure_get_int (s, &quot;coupled-count&quot;, &amp;cc))
1332     return FALSE;
1333   if (coupled_count)
1334     *coupled_count = cc;
1335 
1336   va = gst_structure_get_value (s, &quot;channel-mapping&quot;);
1337   if (!va || !G_VALUE_HOLDS (va, GST_TYPE_ARRAY))
1338     return FALSE;
1339 
1340   if (gst_value_array_get_size (va) != c)
1341     return FALSE;
1342 
1343   if (channel_mapping) {
1344     gint i;
1345 
1346     for (i = 0; i &lt; c; i++) {
1347       gint cm;
1348 
1349       v = gst_value_array_get_value (va, i);
1350 
1351       if (!G_VALUE_HOLDS (v, G_TYPE_INT))
1352         return FALSE;
1353 
1354       cm = g_value_get_int (v);
1355       if (cm &lt; 0 || cm &gt; 255)
1356         return FALSE;
1357 
1358       channel_mapping[i] = cm;
1359     }
1360   }
1361 
1362   return TRUE;
1363 }
1364 
1365 /**
1366  * gst_codec_utils_opus_create_caps:
1367  * @rate: the sample rate
1368  * @channels: the number of channels
1369  * @channel_mapping_family: the channel mapping family
1370  * @stream_count: the number of independent streams
1371  * @coupled_count: the number of stereo streams
1372  * @channel_mapping: (allow-none) (array): the mapping between the streams
1373  *
1374  * Creates Opus caps from the given parameters.
1375  *
1376  * Returns: The #GstCaps, or %NULL if the parameters would lead to
1377  * invalid Opus caps.
1378  *
1379  * Since: 1.8
1380  */
1381 GstCaps *
1382 gst_codec_utils_opus_create_caps (guint32 rate,
1383     guint8 channels,
1384     guint8 channel_mapping_family,
1385     guint8 stream_count, guint8 coupled_count, const guint8 * channel_mapping)
1386 {
1387   GstCaps *caps = NULL;
1388   GValue va = G_VALUE_INIT;
1389   GValue v = G_VALUE_INIT;
1390   gint i;
1391 
1392   if (rate == 0)
1393     rate = 48000;
1394 
1395   if (channel_mapping_family == 0) {
1396     if (channels &gt; 2) {
1397       GST_ERROR (&quot;Invalid channels count for channel_mapping_family 0: %d&quot;,
1398           channels);
1399       goto done;
1400     }
1401 
1402     if (stream_count &gt; 1) {
1403       GST_ERROR (&quot;Invalid stream count for channel_mapping_family 0: %d&quot;,
1404           stream_count);
1405       goto done;
1406     }
1407 
1408     if (coupled_count &gt; 1) {
1409       GST_ERROR (&quot;Invalid coupled count for channel_mapping_family 0: %d&quot;,
1410           coupled_count);
1411       goto done;
1412     }
1413 
1414     if (channels == 0)
1415       channels = 2;
1416 
1417     if (stream_count == 0)
1418       stream_count = 1;
1419 
1420     if (coupled_count == 0)
1421       coupled_count = channels == 2 ? 1 : 0;
1422 
1423     return gst_caps_new_simple (&quot;audio/x-opus&quot;,
1424         &quot;rate&quot;, G_TYPE_INT, rate,
1425         &quot;channels&quot;, G_TYPE_INT, channels,
1426         &quot;channel-mapping-family&quot;, G_TYPE_INT, channel_mapping_family,
1427         &quot;stream-count&quot;, G_TYPE_INT, stream_count,
1428         &quot;coupled-count&quot;, G_TYPE_INT, coupled_count, NULL);
1429   }
1430 
1431   if (channels == 0) {
1432     GST_ERROR (&quot;Invalid channels count: %d&quot;, channels);
1433     goto done;
1434   }
1435 
1436   if (stream_count == 0) {
1437     GST_ERROR (&quot;Invalid stream count: %d&quot;, stream_count);
1438     goto done;
1439   }
1440 
1441   if (coupled_count &gt; stream_count) {
1442     GST_ERROR (&quot;Coupled count %d &gt; stream count: %d&quot;, coupled_count,
1443         stream_count);
1444     goto done;
1445   }
1446 
1447   if (channel_mapping == NULL) {
1448     GST_ERROR
1449         (&quot;A non NULL channel-mapping is needed for channel_mapping_family != 0&quot;);
1450     goto done;
1451   }
1452 
1453   caps = gst_caps_new_simple (&quot;audio/x-opus&quot;,
1454       &quot;rate&quot;, G_TYPE_INT, rate,
1455       &quot;channels&quot;, G_TYPE_INT, channels,
1456       &quot;channel-mapping-family&quot;, G_TYPE_INT, channel_mapping_family,
1457       &quot;stream-count&quot;, G_TYPE_INT, stream_count,
1458       &quot;coupled-count&quot;, G_TYPE_INT, coupled_count, NULL);
1459 
1460   g_value_init (&amp;va, GST_TYPE_ARRAY);
1461   g_value_init (&amp;v, G_TYPE_INT);
1462   for (i = 0; i &lt; channels; i++) {
1463     g_value_set_int (&amp;v, channel_mapping[i]);
1464     gst_value_array_append_value (&amp;va, &amp;v);
1465   }
1466   gst_structure_set_value (gst_caps_get_structure (caps, 0), &quot;channel-mapping&quot;,
1467       &amp;va);
1468   g_value_unset (&amp;va);
1469   g_value_unset (&amp;v);
1470 
1471 done:
1472   return caps;
1473 }
1474 
1475 /*
1476  * (really really) FIXME: move into core (dixit tpm)
1477  */
1478 /*
1479  * _gst_caps_set_buffer_array:
1480  * @caps: (transfer full): a #GstCaps
1481  * @field: field in caps to set
1482  * @buf: header buffers
1483  *
1484  * Adds given buffers to an array of buffers set as the given @field
1485  * on the given @caps.  List of buffer arguments must be NULL-terminated.
1486  *
1487  * Returns: (transfer full): input caps with a streamheader field added, or NULL
1488  *     if some error occurred
1489  */
1490 static GstCaps *
1491 _gst_caps_set_buffer_array (GstCaps * caps, const gchar * field,
1492     GstBuffer * buf, ...)
1493 {
1494   GstStructure *structure = NULL;
1495   va_list va;
1496   GValue array = { 0 };
1497   GValue value = { 0 };
1498 
1499   g_return_val_if_fail (caps != NULL, NULL);
1500   g_return_val_if_fail (gst_caps_is_fixed (caps), NULL);
1501   g_return_val_if_fail (field != NULL, NULL);
1502 
1503   caps = gst_caps_make_writable (caps);
1504   structure = gst_caps_get_structure (caps, 0);
1505 
1506   g_value_init (&amp;array, GST_TYPE_ARRAY);
1507 
1508   va_start (va, buf);
1509   /* put buffers in a fixed list */
1510   while (buf) {
1511     g_assert (gst_buffer_is_writable (buf));
1512 
1513     /* mark buffer */
1514     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_HEADER);
1515 
1516     g_value_init (&amp;value, GST_TYPE_BUFFER);
1517     buf = gst_buffer_copy (buf);
1518     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_HEADER);
1519     gst_value_set_buffer (&amp;value, buf);
1520     gst_buffer_unref (buf);
1521     gst_value_array_append_value (&amp;array, &amp;value);
1522     g_value_unset (&amp;value);
1523 
1524     buf = va_arg (va, GstBuffer *);
1525   }
1526   va_end (va);
1527 
1528   gst_structure_set_value (structure, field, &amp;array);
1529   g_value_unset (&amp;array);
1530 
1531   return caps;
1532 }
1533 
1534 /**
1535  * gst_codec_utils_opus_create_caps_from_header:
1536  * @header: OpusHead header
1537  * @comments: (allow-none): Comment header or NULL
1538  *
1539  * Creates Opus caps from the given OpusHead @header and comment header
1540  * @comments.
1541  *
1542  * Returns: The #GstCaps.
1543  *
1544  * Since: 1.8
1545  */
1546 GstCaps *
1547 gst_codec_utils_opus_create_caps_from_header (GstBuffer * header,
1548     GstBuffer * comments)
1549 {
1550   GstCaps *caps;
1551   guint32 rate;
1552   guint8 channels;
1553   guint8 channel_mapping_family;
1554   guint8 stream_count;
1555   guint8 coupled_count;
1556   guint8 channel_mapping[256];
1557   GstBuffer *dummy_comments = NULL;
1558 
1559   g_return_val_if_fail (GST_IS_BUFFER (header), NULL);
1560   g_return_val_if_fail (comments == NULL || GST_IS_BUFFER (comments), NULL);
1561 
1562   if (!gst_codec_utils_opus_parse_header (header, &amp;rate, &amp;channels,
1563           &amp;channel_mapping_family, &amp;stream_count, &amp;coupled_count,
1564           channel_mapping, NULL, NULL))
1565     return NULL;
1566 
1567   if (!(caps =
1568           gst_codec_utils_opus_create_caps (rate, channels,
1569               channel_mapping_family, stream_count, coupled_count,
1570               channel_mapping)))
1571     return NULL;
1572 
1573   if (!comments) {
1574     GstTagList *tags = gst_tag_list_new_empty ();
1575     dummy_comments =
1576         gst_tag_list_to_vorbiscomment_buffer (tags, (const guint8 *) &quot;OpusTags&quot;,
1577         8, NULL);
1578     gst_tag_list_unref (tags);
1579   }
1580   _gst_caps_set_buffer_array (caps, &quot;streamheader&quot;, header,
1581       comments ? comments : dummy_comments, NULL);
1582 
1583   if (dummy_comments)
1584     gst_buffer_unref (dummy_comments);
1585 
1586   return caps;
1587 }
1588 
1589 /**
1590  * gst_codec_utils_opus_create_header:
1591  * @rate: the sample rate
1592  * @channels: the number of channels
1593  * @channel_mapping_family: the channel mapping family
1594  * @stream_count: the number of independent streams
1595  * @coupled_count: the number of stereo streams
1596  * @channel_mapping: (allow-none) (array): the mapping between the streams
1597  * @pre_skip: Pre-skip in 48kHz samples or 0
1598  * @output_gain: Output gain or 0
1599  *
1600  * Creates OpusHead header from the given parameters.
1601  *
1602  * Returns: The #GstBuffer containing the OpusHead.
1603  *
1604  * Since: 1.8
1605  */
1606 GstBuffer *
1607 gst_codec_utils_opus_create_header (guint32 rate,
1608     guint8 channels,
1609     guint8 channel_mapping_family,
1610     guint8 stream_count,
1611     guint8 coupled_count,
1612     const guint8 * channel_mapping, guint16 pre_skip, gint16 output_gain)
1613 {
1614   GstBuffer *buffer;
1615   GstByteWriter bw;
1616   gboolean hdl = TRUE;
1617 
1618   if (rate == 0)
1619     rate = 48000;
1620 
1621   if (channel_mapping_family == 0) {
1622     g_return_val_if_fail (channels &lt;= 2, NULL);
1623     if (channels == 0)
1624       channels = 2;
1625 
1626     g_return_val_if_fail (stream_count == 0 || stream_count == 1, NULL);
1627     if (stream_count == 0)
1628       stream_count = 1;
1629 
1630     g_return_val_if_fail (coupled_count == 0 || coupled_count == 1, NULL);
1631     if (coupled_count == 0)
1632       coupled_count = channels == 2 ? 1 : 0;
1633 
1634     channel_mapping = NULL;
1635   } else {
1636     g_return_val_if_fail (channels &gt; 0, NULL);
1637     g_return_val_if_fail (stream_count &gt; 0, NULL);
1638     g_return_val_if_fail (coupled_count &lt;= stream_count, NULL);
1639     g_return_val_if_fail (channel_mapping != NULL, NULL);
1640   }
1641 
1642   gst_byte_writer_init (&amp;bw);
1643   /* See http://wiki.xiph.org/OggOpus */
1644   hdl &amp;= gst_byte_writer_put_data (&amp;bw, (const guint8 *) &quot;OpusHead&quot;, 8);
1645   hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, 0x01); /* version number */
1646   hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, channels);
1647   hdl &amp;= gst_byte_writer_put_uint16_le (&amp;bw, pre_skip);
1648   hdl &amp;= gst_byte_writer_put_uint32_le (&amp;bw, rate);
1649   hdl &amp;= gst_byte_writer_put_uint16_le (&amp;bw, output_gain);
1650   hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, channel_mapping_family);
1651   if (channel_mapping_family &gt; 0) {
1652     hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, stream_count);
1653     hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, coupled_count);
1654     hdl &amp;= gst_byte_writer_put_data (&amp;bw, channel_mapping, channels);
1655   }
1656 
1657   if (!hdl) {
1658     GST_WARNING (&quot;Error creating header&quot;);
1659     gst_byte_writer_reset (&amp;bw);
1660     return NULL;
1661   }
1662 
1663   buffer = gst_byte_writer_reset_and_get_buffer (&amp;bw);
1664   GST_BUFFER_OFFSET (buffer) = 0;
1665   GST_BUFFER_OFFSET_END (buffer) = 0;
1666 
1667   return buffer;
1668 }
1669 
1670 /**
1671  * gst_codec_utils_opus_parse_header:
1672  * @header: the OpusHead #GstBuffer
1673  * @rate: (out): the sample rate
1674  * @channels: (out): the number of channels
1675  * @channel_mapping_family: (out): the channel mapping family
1676  * @stream_count: (out): the number of independent streams
1677  * @coupled_count: (out): the number of stereo streams
1678  * @channel_mapping: (out) (array fixed-size=256): the mapping between the streams
1679  * @pre_skip: (out): Pre-skip in 48kHz samples or 0
1680  * @output_gain: (out): Output gain or 0
1681  *
1682  * Parses the OpusHead header.
1683  *
1684  * Returns: %TRUE if parsing was successful, %FALSE otherwise.
1685  *
1686  * Since: 1.8
1687  */
1688 gboolean
1689 gst_codec_utils_opus_parse_header (GstBuffer * header,
1690     guint32 * rate,
1691     guint8 * channels,
1692     guint8 * channel_mapping_family,
1693     guint8 * stream_count,
1694     guint8 * coupled_count,
1695     guint8 channel_mapping[256], guint16 * pre_skip, gint16 * output_gain)
1696 {
1697   GstByteReader br;
1698   GstMapInfo map;
1699   gboolean ret = TRUE;
1700   guint8 c, f, version;
1701 
1702   g_return_val_if_fail (GST_IS_BUFFER (header), FALSE);
1703   g_return_val_if_fail (gst_buffer_get_size (header) &gt;= 19, FALSE);
1704 
1705   if (!gst_buffer_map (header, &amp;map, GST_MAP_READ))
1706     return FALSE;
1707   gst_byte_reader_init (&amp;br, map.data, map.size);
1708   /* See http://wiki.xiph.org/OggOpus */
1709   if (memcmp (gst_byte_reader_get_data_unchecked (&amp;br, 8), &quot;OpusHead&quot;, 8) != 0) {
1710     ret = FALSE;
1711     goto done;
1712   }
1713   version = gst_byte_reader_get_uint8_unchecked (&amp;br);
1714   if (version == 0x00)
1715     GST_ERROR (&quot;Opus Header version is wrong, should be 0x01 and not 0x00&quot;);
1716   else if (version != 0x01) {
1717     ret = FALSE;
1718     goto done;
1719   }
1720 
1721   c = gst_byte_reader_get_uint8_unchecked (&amp;br);
1722   if (channels)
1723     *channels = c;
1724 
1725   if (pre_skip)
1726     *pre_skip = gst_byte_reader_get_uint16_le_unchecked (&amp;br);
1727   else
1728     gst_byte_reader_skip_unchecked (&amp;br, 2);
1729 
1730   if (rate)
1731     *rate = gst_byte_reader_get_uint32_le_unchecked (&amp;br);
1732   else
1733     gst_byte_reader_skip_unchecked (&amp;br, 4);
1734 
1735   if (output_gain)
1736     *output_gain = gst_byte_reader_get_uint16_le_unchecked (&amp;br);
1737   else
1738     gst_byte_reader_skip_unchecked (&amp;br, 2);
1739 
1740   f = gst_byte_reader_get_uint8_unchecked (&amp;br);
1741   if (channel_mapping_family)
1742     *channel_mapping_family = f;
1743   if (f == 0 &amp;&amp; c &lt;= 2) {
1744     if (stream_count)
1745       *stream_count = 1;
1746     if (coupled_count)
1747       *coupled_count = c == 2 ? 1 : 0;
1748     if (channel_mapping) {
1749       channel_mapping[0] = 0;
1750       channel_mapping[1] = 1;
1751     }
1752 
1753     goto done;
1754   }
1755 
1756   if (gst_byte_reader_get_remaining (&amp;br) &lt; 2 + c) {
1757     ret = FALSE;
1758     goto done;
1759   }
1760 
1761   if (stream_count)
1762     *stream_count = gst_byte_reader_get_uint8_unchecked (&amp;br);
1763   else
1764     gst_byte_reader_skip_unchecked (&amp;br, 1);
1765 
1766   if (coupled_count)
1767     *coupled_count = gst_byte_reader_get_uint8_unchecked (&amp;br);
1768   else
1769     gst_byte_reader_skip_unchecked (&amp;br, 1);
1770 
1771   if (channel_mapping)
1772     memcpy (channel_mapping, gst_byte_reader_get_data_unchecked (&amp;br, c), c);
1773 
1774 done:
1775   gst_buffer_unmap (header, &amp;map);
1776 
1777   return ret;
1778 }
1779 #endif // GSTREAMER_LITE
    </pre>
  </body>
</html>