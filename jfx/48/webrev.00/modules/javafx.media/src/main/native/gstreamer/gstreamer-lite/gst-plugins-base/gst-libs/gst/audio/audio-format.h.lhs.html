<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/audio-format.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* GStreamer
  2  * Copyright (C) &lt;1999&gt; Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
  3  * Library       &lt;2001&gt; Thomas Vander Stichele &lt;thomas@apestaart.org&gt;
  4  *               &lt;2011&gt; Wim Taymans &lt;wim.taymans@gmail.com&gt;
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public
 17  * License along with this library; if not, write to the
 18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #ifndef __GST_AUDIO_AUDIO_H__
 23 #include &lt;gst/audio/audio.h&gt;
 24 #endif
 25 
 26 #ifndef __GST_AUDIO_FORMAT_H__
 27 #define __GST_AUDIO_FORMAT_H__
 28 
 29 G_BEGIN_DECLS
 30 
 31 #if G_BYTE_ORDER == G_BIG_ENDIAN
 32 #define _GST_AUDIO_FORMAT_NE(fmt) GST_AUDIO_FORMAT_ ## fmt ## BE
 33 #define _GST_AUDIO_FORMAT_OE(fmt) GST_AUDIO_FORMAT_ ## fmt ## LE
 34 #elif G_BYTE_ORDER == G_LITTLE_ENDIAN
 35 #define _GST_AUDIO_FORMAT_NE(fmt) GST_AUDIO_FORMAT_ ## fmt ## LE
 36 #define _GST_AUDIO_FORMAT_OE(fmt) GST_AUDIO_FORMAT_ ## fmt ## BE
 37 #endif
 38 
 39 /**
 40  * GstAudioFormat:
 41  * @GST_AUDIO_FORMAT_UNKNOWN: unknown or unset audio format
 42  * @GST_AUDIO_FORMAT_ENCODED: encoded audio format
 43  * @GST_AUDIO_FORMAT_S8: 8 bits in 8 bits, signed
 44  * @GST_AUDIO_FORMAT_U8: 8 bits in 8 bits, unsigned
 45  * @GST_AUDIO_FORMAT_S16LE: 16 bits in 16 bits, signed, little endian
 46  * @GST_AUDIO_FORMAT_S16BE: 16 bits in 16 bits, signed, big endian
 47  * @GST_AUDIO_FORMAT_U16LE: 16 bits in 16 bits, unsigned, little endian
 48  * @GST_AUDIO_FORMAT_U16BE: 16 bits in 16 bits, unsigned, big endian
 49  * @GST_AUDIO_FORMAT_S24_32LE: 24 bits in 32 bits, signed, little endian
 50  * @GST_AUDIO_FORMAT_S24_32BE: 24 bits in 32 bits, signed, big endian
 51  * @GST_AUDIO_FORMAT_U24_32LE: 24 bits in 32 bits, unsigned, little endian
 52  * @GST_AUDIO_FORMAT_U24_32BE: 24 bits in 32 bits, unsigned, big endian
 53  * @GST_AUDIO_FORMAT_S32LE: 32 bits in 32 bits, signed, little endian
 54  * @GST_AUDIO_FORMAT_S32BE: 32 bits in 32 bits, signed, big endian
 55  * @GST_AUDIO_FORMAT_U32LE: 32 bits in 32 bits, unsigned, little endian
 56  * @GST_AUDIO_FORMAT_U32BE: 32 bits in 32 bits, unsigned, big endian
 57  * @GST_AUDIO_FORMAT_S24LE: 24 bits in 24 bits, signed, little endian
 58  * @GST_AUDIO_FORMAT_S24BE: 24 bits in 24 bits, signed, big endian
 59  * @GST_AUDIO_FORMAT_U24LE: 24 bits in 24 bits, unsigned, little endian
 60  * @GST_AUDIO_FORMAT_U24BE: 24 bits in 24 bits, unsigned, big endian
 61  * @GST_AUDIO_FORMAT_S20LE: 20 bits in 24 bits, signed, little endian
 62  * @GST_AUDIO_FORMAT_S20BE: 20 bits in 24 bits, signed, big endian
 63  * @GST_AUDIO_FORMAT_U20LE: 20 bits in 24 bits, unsigned, little endian
 64  * @GST_AUDIO_FORMAT_U20BE: 20 bits in 24 bits, unsigned, big endian
 65  * @GST_AUDIO_FORMAT_S18LE: 18 bits in 24 bits, signed, little endian
 66  * @GST_AUDIO_FORMAT_S18BE: 18 bits in 24 bits, signed, big endian
 67  * @GST_AUDIO_FORMAT_U18LE: 18 bits in 24 bits, unsigned, little endian
 68  * @GST_AUDIO_FORMAT_U18BE: 18 bits in 24 bits, unsigned, big endian
 69  * @GST_AUDIO_FORMAT_F32LE: 32-bit floating point samples, little endian
 70  * @GST_AUDIO_FORMAT_F32BE: 32-bit floating point samples, big endian
 71  * @GST_AUDIO_FORMAT_F64LE: 64-bit floating point samples, little endian
 72  * @GST_AUDIO_FORMAT_F64BE: 64-bit floating point samples, big endian
 73  * @GST_AUDIO_FORMAT_S16: 16 bits in 16 bits, signed, native endianness
 74  * @GST_AUDIO_FORMAT_U16: 16 bits in 16 bits, unsigned, native endianness
 75  * @GST_AUDIO_FORMAT_S24_32: 24 bits in 32 bits, signed, native endianness
 76  * @GST_AUDIO_FORMAT_U24_32: 24 bits in 32 bits, unsigned, native endianness
 77  * @GST_AUDIO_FORMAT_S32: 32 bits in 32 bits, signed, native endianness
 78  * @GST_AUDIO_FORMAT_U32: 32 bits in 32 bits, unsigned, native endianness
 79  * @GST_AUDIO_FORMAT_S24: 24 bits in 24 bits, signed, native endianness
 80  * @GST_AUDIO_FORMAT_U24: 24 bits in 24 bits, unsigned, native endianness
 81  * @GST_AUDIO_FORMAT_S20: 20 bits in 24 bits, signed, native endianness
 82  * @GST_AUDIO_FORMAT_U20: 20 bits in 24 bits, unsigned, native endianness
 83  * @GST_AUDIO_FORMAT_S18: 18 bits in 24 bits, signed, native endianness
 84  * @GST_AUDIO_FORMAT_U18: 18 bits in 24 bits, unsigned, native endianness
 85  * @GST_AUDIO_FORMAT_F32: 32-bit floating point samples, native endianness
 86  * @GST_AUDIO_FORMAT_F64: 64-bit floating point samples, native endianness
 87  *
 88  * Enum value describing the most common audio formats.
 89  */
 90 typedef enum {
 91   GST_AUDIO_FORMAT_UNKNOWN,
 92   GST_AUDIO_FORMAT_ENCODED,
 93   /* 8 bit */
 94   GST_AUDIO_FORMAT_S8,
 95   GST_AUDIO_FORMAT_U8,
 96   /* 16 bit */
 97   GST_AUDIO_FORMAT_S16LE,
 98   GST_AUDIO_FORMAT_S16BE,
 99   GST_AUDIO_FORMAT_U16LE,
100   GST_AUDIO_FORMAT_U16BE,
101   /* 24 bit in low 3 bytes of 32 bits*/
102   GST_AUDIO_FORMAT_S24_32LE,
103   GST_AUDIO_FORMAT_S24_32BE,
104   GST_AUDIO_FORMAT_U24_32LE,
105   GST_AUDIO_FORMAT_U24_32BE,
106   /* 32 bit */
107   GST_AUDIO_FORMAT_S32LE,
108   GST_AUDIO_FORMAT_S32BE,
109   GST_AUDIO_FORMAT_U32LE,
110   GST_AUDIO_FORMAT_U32BE,
111   /* 24 bit in 3 bytes*/
112   GST_AUDIO_FORMAT_S24LE,
113   GST_AUDIO_FORMAT_S24BE,
114   GST_AUDIO_FORMAT_U24LE,
115   GST_AUDIO_FORMAT_U24BE,
116   /* 20 bit in 3 bytes*/
117   GST_AUDIO_FORMAT_S20LE,
118   GST_AUDIO_FORMAT_S20BE,
119   GST_AUDIO_FORMAT_U20LE,
120   GST_AUDIO_FORMAT_U20BE,
121   /* 18 bit in 3 bytes*/
122   GST_AUDIO_FORMAT_S18LE,
123   GST_AUDIO_FORMAT_S18BE,
124   GST_AUDIO_FORMAT_U18LE,
125   GST_AUDIO_FORMAT_U18BE,
126   /* float */
127   GST_AUDIO_FORMAT_F32LE,
128   GST_AUDIO_FORMAT_F32BE,
129   GST_AUDIO_FORMAT_F64LE,
130   GST_AUDIO_FORMAT_F64BE,
131   /* native endianness equivalents */
132   GST_AUDIO_FORMAT_S16 = _GST_AUDIO_FORMAT_NE(S16),
133   GST_AUDIO_FORMAT_U16 = _GST_AUDIO_FORMAT_NE(U16),
134   GST_AUDIO_FORMAT_S24_32 = _GST_AUDIO_FORMAT_NE(S24_32),
135   GST_AUDIO_FORMAT_U24_32 = _GST_AUDIO_FORMAT_NE(U24_32),
136   GST_AUDIO_FORMAT_S32 = _GST_AUDIO_FORMAT_NE(S32),
137   GST_AUDIO_FORMAT_U32 = _GST_AUDIO_FORMAT_NE(U32),
138   GST_AUDIO_FORMAT_S24 = _GST_AUDIO_FORMAT_NE(S24),
139   GST_AUDIO_FORMAT_U24 = _GST_AUDIO_FORMAT_NE(U24),
140   GST_AUDIO_FORMAT_S20 = _GST_AUDIO_FORMAT_NE(S20),
141   GST_AUDIO_FORMAT_U20 = _GST_AUDIO_FORMAT_NE(U20),
142   GST_AUDIO_FORMAT_S18 = _GST_AUDIO_FORMAT_NE(S18),
143   GST_AUDIO_FORMAT_U18 = _GST_AUDIO_FORMAT_NE(U18),
144   GST_AUDIO_FORMAT_F32 = _GST_AUDIO_FORMAT_NE(F32),
145   GST_AUDIO_FORMAT_F64 = _GST_AUDIO_FORMAT_NE(F64)
146 } GstAudioFormat;
147 
148 
149 typedef struct _GstAudioFormatInfo GstAudioFormatInfo;
150 
151 /**
152  * GstAudioFormatFlags:
153  * @GST_AUDIO_FORMAT_FLAG_INTEGER: integer samples
154  * @GST_AUDIO_FORMAT_FLAG_FLOAT: float samples
155  * @GST_AUDIO_FORMAT_FLAG_SIGNED: signed samples
156  * @GST_AUDIO_FORMAT_FLAG_COMPLEX: complex layout
157  * @GST_AUDIO_FORMAT_FLAG_UNPACK: the format can be used in
158  * #GstAudioFormatUnpack and #GstAudioFormatPack functions
159  *
160  * The different audio flags that a format info can have.
161  */
162 typedef enum
163 {
164   GST_AUDIO_FORMAT_FLAG_INTEGER  = (1 &lt;&lt; 0),
165   GST_AUDIO_FORMAT_FLAG_FLOAT    = (1 &lt;&lt; 1),
166   GST_AUDIO_FORMAT_FLAG_SIGNED   = (1 &lt;&lt; 2),
167   GST_AUDIO_FORMAT_FLAG_COMPLEX  = (1 &lt;&lt; 4),
168   GST_AUDIO_FORMAT_FLAG_UNPACK   = (1 &lt;&lt; 5)
169 } GstAudioFormatFlags;
170 
171 /**
172  * GstAudioPackFlags:
173  * @GST_AUDIO_PACK_FLAG_NONE: No flag
174  * @GST_AUDIO_PACK_FLAG_TRUNCATE_RANGE: When the source has a smaller depth
175  *   than the target format, set the least significant bits of the target
176  *   to 0. This is likely sightly faster but less accurate. When this flag
177  *   is not specified, the most significant bits of the source are duplicated
178  *   in the least significant bits of the destination.
179  *
180  * The different flags that can be used when packing and unpacking.
181  */
182 typedef enum
183 {
184   GST_AUDIO_PACK_FLAG_NONE             = 0,
185   GST_AUDIO_PACK_FLAG_TRUNCATE_RANGE   = (1 &lt;&lt; 0)
186 } GstAudioPackFlags;
187 
188 /**
189  * GstAudioFormatUnpack:
190  * @info: a #GstAudioFormatInfo
<a name="1" id="anc1"></a>
191  * @dest: (array) (element-type guint8): a destination array
192  * @data: (array) (element-type guint8): pointer to the audio data
193  * @length: the amount of samples to unpack.
194  *
195  * Unpacks @length samples from the given data of format @info.
196  * The samples will be unpacked into @dest which each channel
197  * interleaved. @dest should at least be big enough to hold @length *
198  * channels * size(unpack_format) bytes.
199  */
200 typedef void (*GstAudioFormatUnpack)         (const GstAudioFormatInfo *info,
201                                               GstAudioPackFlags flags, gpointer dest,
<a name="2" id="anc2"></a><span class="line-modified">202                                               const gpointer data, gint length);</span>
203 /**
204  * GstAudioFormatPack:
205  * @info: a #GstAudioFormatInfo
<a name="3" id="anc3"></a>
206  * @src: (array) (element-type guint8): a source array
207  * @data: (array) (element-type guint8): pointer to the destination
208  *   data
209  * @length: the amount of samples to pack.
210  *
211  * Packs @length samples from @src to the data array in format @info.
212  * The samples from source have each channel interleaved
213  * and will be packed into @data.
214  */
215 typedef void (*GstAudioFormatPack)           (const GstAudioFormatInfo *info,
<a name="4" id="anc4"></a><span class="line-modified">216                                               GstAudioPackFlags flags, const gpointer src,</span>
217                                               gpointer data, gint length);
218 
219 /**
220  * GstAudioFormatInfo:
221  * @format: #GstAudioFormat
222  * @name: string representation of the format
223  * @description: user readable description of the format
224  * @flags: #GstAudioFormatFlags
225  * @endianness: the endianness
226  * @width: amount of bits used for one sample
227  * @depth: amount of valid bits in @width
228  * @silence: @width/8 bytes with 1 silent sample
229  * @unpack_format: the format of the unpacked samples
230  * @unpack_func: function to unpack samples
231  * @pack_func: function to pack samples
232  *
233  * Information for an audio format.
234  */
235 struct _GstAudioFormatInfo {
<a name="5" id="anc5"></a>
236   GstAudioFormat format;
237   const gchar *name;
238   const gchar *description;
239   GstAudioFormatFlags flags;
240   gint endianness;
241   gint width;
242   gint depth;
243   guint8 silence[8];
244 
245   GstAudioFormat unpack_format;
246   GstAudioFormatUnpack unpack_func;
247   GstAudioFormatPack pack_func;
248 
249   /*&lt; private &gt;*/
250   gpointer _gst_reserved[GST_PADDING];
251 };
252 
253 GST_AUDIO_API
254 GType gst_audio_format_info_get_type (void);
255 
256 #define GST_AUDIO_FORMAT_INFO_FORMAT(info)           ((info)-&gt;format)
257 #define GST_AUDIO_FORMAT_INFO_NAME(info)             ((info)-&gt;name)
258 #define GST_AUDIO_FORMAT_INFO_FLAGS(info)            ((info)-&gt;flags)
259 
260 #define GST_AUDIO_FORMAT_INFO_IS_INTEGER(info)       !!((info)-&gt;flags &amp; GST_AUDIO_FORMAT_FLAG_INTEGER)
261 #define GST_AUDIO_FORMAT_INFO_IS_FLOAT(info)         !!((info)-&gt;flags &amp; GST_AUDIO_FORMAT_FLAG_FLOAT)
262 #define GST_AUDIO_FORMAT_INFO_IS_SIGNED(info)        !!((info)-&gt;flags &amp; GST_AUDIO_FORMAT_FLAG_SIGNED)
263 
264 #define GST_AUDIO_FORMAT_INFO_ENDIANNESS(info)       ((info)-&gt;endianness)
265 #define GST_AUDIO_FORMAT_INFO_IS_LITTLE_ENDIAN(info) ((info)-&gt;endianness == G_LITTLE_ENDIAN)
266 #define GST_AUDIO_FORMAT_INFO_IS_BIG_ENDIAN(info)    ((info)-&gt;endianness == G_BIG_ENDIAN)
267 #define GST_AUDIO_FORMAT_INFO_WIDTH(info)            ((info)-&gt;width)
268 #define GST_AUDIO_FORMAT_INFO_DEPTH(info)            ((info)-&gt;depth)
269 
270 
271 GST_AUDIO_API
272 GstAudioFormat gst_audio_format_build_integer    (gboolean sign, gint endianness,
273                                                   gint width, gint depth) G_GNUC_CONST;
274 
275 GST_AUDIO_API
276 GstAudioFormat gst_audio_format_from_string      (const gchar *format) G_GNUC_CONST;
277 
278 GST_AUDIO_API
279 const gchar *  gst_audio_format_to_string        (GstAudioFormat format) G_GNUC_CONST;
280 
281 GST_AUDIO_API
282 const GstAudioFormatInfo *
283                gst_audio_format_get_info         (GstAudioFormat format) G_GNUC_CONST;
284 
285 GST_AUDIO_API
286 void           gst_audio_format_fill_silence     (const GstAudioFormatInfo *info,
287                                                   gpointer dest, gsize length);
288 
289 /**
290  * GST_AUDIO_RATE_RANGE:
291  *
292  * Maximum range of allowed sample rates, for use in template caps strings.
293  */
294 #define GST_AUDIO_RATE_RANGE &quot;(int) [ 1, max ]&quot;
295 /**
296  * GST_AUDIO_CHANNELS_RANGE:
297  *
298  * Maximum range of allowed channels, for use in template caps strings.
299  */
300 #define GST_AUDIO_CHANNELS_RANGE &quot;(int) [ 1, max ]&quot;
301 
302 /**
303  * GST_AUDIO_NE:
304  * @s: format string without endianness marker
305  *
306  * Turns audio format string @s into the format string for native endianness.
307  */
308 /**
309  * GST_AUDIO_OE:
310  * @s: format string without endianness marker
311  *
312  * Turns audio format string @s into the format string for other endianness.
313  */
314 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
315 # define GST_AUDIO_NE(s) G_STRINGIFY(s)&quot;LE&quot;
316 # define GST_AUDIO_OE(s) G_STRINGIFY(s)&quot;BE&quot;
317 #else
318 # define GST_AUDIO_NE(s) G_STRINGIFY(s)&quot;BE&quot;
319 # define GST_AUDIO_OE(s) G_STRINGIFY(s)&quot;LE&quot;
320 #endif
321 
322 /**
323  * GST_AUDIO_FORMATS_ALL:
324  *
325  * List of all audio formats, for use in template caps strings.
326  */
327 #define GST_AUDIO_FORMATS_ALL &quot; { S8, U8, &quot; \
328     &quot;S16LE, S16BE, U16LE, U16BE, &quot; \
329     &quot;S24_32LE, S24_32BE, U24_32LE, U24_32BE, &quot; \
330     &quot;S32LE, S32BE, U32LE, U32BE, &quot; \
331     &quot;S24LE, S24BE, U24LE, U24BE, &quot; \
332     &quot;S20LE, S20BE, U20LE, U20BE, &quot; \
333     &quot;S18LE, S18BE, U18LE, U18BE, &quot; \
334     &quot;F32LE, F32BE, F64LE, F64BE }&quot;
335 
336 /**
337  * GST_AUDIO_CAPS_MAKE:
338  * @format: string format that describes the sample layout, as string
339  *     (e.g. &quot;S16LE&quot;, &quot;S8&quot;, etc.)
340  *
341  * Generic caps string for audio, for use in pad templates.
342  */
343 #define GST_AUDIO_CAPS_MAKE(format)                                    \
344     &quot;audio/x-raw, &quot;                                                    \
345     &quot;format = (string) &quot; format &quot;, &quot;                                   \
346     &quot;rate = &quot; GST_AUDIO_RATE_RANGE &quot;, &quot;                                \
347     &quot;channels = &quot; GST_AUDIO_CHANNELS_RANGE
348 
349 /**
350  * GST_AUDIO_DEF_RATE:
351  *
352  * Standard sampling rate used in consumer audio.
353  */
354 #define GST_AUDIO_DEF_RATE 44100
355 /**
356  * GST_AUDIO_DEF_CHANNELS:
357  *
358  * Standard number of channels used in consumer audio.
359  */
360 #define GST_AUDIO_DEF_CHANNELS 2
361 /**
362  * GST_AUDIO_DEF_FORMAT:
363  *
364  * Standard format used in consumer audio.
365  */
366 #define GST_AUDIO_DEF_FORMAT &quot;S16LE&quot;
367 
368 G_END_DECLS
369 
370 #endif /* __GST_AUDIO_FORMAT_H__ */
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>