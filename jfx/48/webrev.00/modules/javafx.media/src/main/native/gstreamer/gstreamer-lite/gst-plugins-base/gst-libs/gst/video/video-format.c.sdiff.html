<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/video-format.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="video-event.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="video-format.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/video-format.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 125 {
 126   gint uv = GET_UV_420 (y, flags);
 127   guint8 *dy = GET_Y_LINE (y);
 128   guint8 *du = GET_U_LINE (uv);
 129   guint8 *dv = GET_V_LINE (uv);
 130   const guint8 *s = src;
 131 
 132   if (IS_CHROMA_LINE_420 (y, flags)) {
 133     if (IS_ALIGNED (s, 8))
 134       video_orc_pack_I420 (dy, du, dv, s, width / 2);
 135     else {
 136       gint i;
 137 
 138       for (i = 0; i &lt; width / 2; i++) {
 139         dy[i * 2 + 0] = s[i * 8 + 1];
 140         dy[i * 2 + 1] = s[i * 8 + 5];
 141         du[i] = s[i * 8 + 2];
 142         dv[i] = s[i * 8 + 3];
 143       }
 144     }
<span class="line-modified"> 145   if (width &amp; 1) {</span>
<span class="line-modified"> 146     gint i = width - 1;</span>
 147 
 148       dy[i] = s[i * 4 + 1];
 149       du[i &gt;&gt; 1] = s[i * 4 + 2];
 150       dv[i &gt;&gt; 1] = s[i * 4 + 3];
<span class="line-modified"> 151   }</span>
 152   } else
 153     video_orc_pack_Y (dy, s, width);
 154 }
 155 
 156 #define PACK_YUY2 GST_VIDEO_FORMAT_AYUV, unpack_YUY2, 1, pack_YUY2
 157 static void
 158 unpack_YUY2 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 159     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 160     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 161 {
 162   const guint8 *restrict s = GET_LINE (y);
 163   guint8 *restrict d = dest;
 164 
 165   s += (x &amp; ~1) &lt;&lt; 1;
 166   if (x &amp; 1) {
 167     d[0] = 0xff;
 168     d[1] = s[2];
 169     d[2] = s[1];
 170     d[3] = s[3];
 171     s += 4;
</pre>
<hr />
<pre>
 771     gint y, gint width)
 772 {
 773   int i;
 774   guint8 *restrict d = GET_LINE (y);
 775   const guint16 *restrict s = src;
 776 
 777   for (i = 0; i &lt; width - 1; i += 2) {
 778     GST_WRITE_UINT16_LE (d + i * 4 + 0, s[(i + 0) * 4 + 2]);
 779     GST_WRITE_UINT16_LE (d + i * 4 + 2, s[(i + 0) * 4 + 1]);
 780     GST_WRITE_UINT16_LE (d + i * 4 + 4, s[(i + 0) * 4 + 3]);
 781     GST_WRITE_UINT16_LE (d + i * 4 + 6, s[(i + 1) * 4 + 1]);
 782   }
 783   if (i == width - 1) {
 784     GST_WRITE_UINT16_LE (d + i * 4 + 0, s[i * 4 + 2]);
 785     GST_WRITE_UINT16_LE (d + i * 4 + 2, s[i * 4 + 1]);
 786     GST_WRITE_UINT16_LE (d + i * 4 + 4, s[i * 4 + 3]);
 787     GST_WRITE_UINT16_LE (d + i * 4 + 6, s[i * 4 + 1]);
 788   }
 789 }
 790 



































































































































































 791 #define PACK_Y41B GST_VIDEO_FORMAT_AYUV, unpack_Y41B, 1, pack_Y41B
 792 static void
 793 unpack_Y41B (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 794     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 795     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 796 {
 797   const guint8 *restrict sy = GET_Y_LINE (y);
 798   const guint8 *restrict su = GET_U_LINE (y);
 799   const guint8 *restrict sv = GET_V_LINE (y);
 800   guint8 *restrict d = dest;
 801 
 802   sy += x;
 803   su += x &gt;&gt; 2;
 804   sv += x &gt;&gt; 2;
 805 
 806   if (x &amp; 3) {
 807     for (; x &amp; 3; x++) {
 808       d[0] = 0xff;
 809       d[1] = *sy++;
 810       d[2] = *su;
</pre>
<hr />
<pre>
1163   guint16 *restrict d = GET_LINE (y);
1164   const guint16 *restrict s = src;
1165 
1166   for (i = 0; i &lt; width; i++) {
1167     GST_WRITE_UINT16_LE (d + i, s[i * 4 + 1]);
1168   }
1169 }
1170 
1171 #define PACK_RGB16 GST_VIDEO_FORMAT_ARGB, unpack_RGB16, 1, pack_RGB16
1172 static void
1173 unpack_RGB16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1174     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1175     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1176 {
1177   const guint16 *restrict s = GET_LINE (y);
1178 
1179   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1180     video_orc_unpack_RGB16_trunc (dest, s + x, width);
1181   else
1182     video_orc_unpack_RGB16 (dest, s + x, width);
<span class="line-modified">1183     }</span>
1184 
1185 static void
1186 pack_RGB16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1187     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1188     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1189     gint y, gint width)
1190 {
1191   guint16 *restrict d = GET_LINE (y);
1192 
1193 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1194   video_orc_pack_RGB16_le (d, src, width);
1195 #else
1196   video_orc_pack_RGB16_be (d, src, width);
1197 #endif
<span class="line-modified">1198   }</span>
1199 
1200 #define PACK_BGR16 GST_VIDEO_FORMAT_ARGB, unpack_BGR16, 1, pack_BGR16
1201 static void
1202 unpack_BGR16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1203     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1204     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1205 {
1206   const guint16 *restrict s = GET_LINE (y);
1207 
1208   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1209     video_orc_unpack_BGR16_trunc (dest, s + x, width);
1210   else
1211     video_orc_unpack_BGR16 (dest, s + x, width);
<span class="line-modified">1212     }</span>
1213 
1214 static void
1215 pack_BGR16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1216     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1217     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1218     gint y, gint width)
1219 {
1220   guint16 *restrict d = GET_LINE (y);
1221 
1222 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1223   video_orc_pack_BGR16_le (d, src, width);
1224 #else
1225   video_orc_pack_BGR16_be (d, src, width);
1226 #endif
<span class="line-modified">1227   }</span>
1228 
1229 #define PACK_RGB15 GST_VIDEO_FORMAT_ARGB, unpack_RGB15, 1, pack_RGB15
1230 static void
1231 unpack_RGB15 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1232     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1233     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1234 {
1235   const guint16 *restrict s = GET_LINE (y);
1236 
1237 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1238   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1239     video_orc_unpack_RGB15_le_trunc (dest, s + x, width);
1240   else
1241     video_orc_unpack_RGB15_le (dest, s + x, width);
1242 #else
1243   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1244     video_orc_unpack_RGB15_be_trunc (dest, s + x, width);
1245   else
1246     video_orc_unpack_RGB15_be (dest, s + x, width);
1247 #endif
<span class="line-modified">1248     }</span>
1249 
1250 static void
1251 pack_RGB15 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1252     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1253     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1254     gint y, gint width)
1255 {
1256   guint16 *restrict d = GET_LINE (y);
1257 
1258 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1259   video_orc_pack_RGB15_le (d, src, width);
1260 #else
1261   video_orc_pack_RGB15_be (d, src, width);
1262 #endif
<span class="line-modified">1263   }</span>
1264 
1265 #define PACK_BGR15 GST_VIDEO_FORMAT_ARGB, unpack_BGR15, 1, pack_BGR15
1266 static void
1267 unpack_BGR15 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1268     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1269     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1270 {
1271   const guint16 *restrict s = GET_LINE (y);
1272 
1273 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1274   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1275     video_orc_unpack_BGR15_le_trunc (dest, s + x, width);
1276   else
1277     video_orc_unpack_BGR15_le (dest, s + x, width);
1278 #else
1279   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1280     video_orc_unpack_BGR15_be_trunc (dest, s + x, width);
1281   else
1282     video_orc_unpack_BGR15_be (dest, s + x, width);
1283 #endif
<span class="line-modified">1284     }</span>
1285 
1286 static void
1287 pack_BGR15 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1288     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1289     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1290     gint y, gint width)
1291 {
1292   guint16 *restrict d = GET_LINE (y);
1293 
1294 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1295   video_orc_pack_BGR15_le (d, src, width);
1296 #else
1297   video_orc_pack_BGR15_be (d, src, width);
1298 #endif
<span class="line-modified">1299   }</span>
1300 
1301 #define PACK_BGRA GST_VIDEO_FORMAT_ARGB, unpack_BGRA, 1, pack_BGRA
1302 static void
1303 unpack_BGRA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1304     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1305     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1306 {
1307   const guint8 *restrict s = GET_LINE (y);
1308 
1309   s += x * 4;
1310 
1311   video_orc_unpack_BGRA (dest, s, width);
1312 }
1313 
1314 static void
1315 pack_BGRA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1316     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1317     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1318     gint y, gint width)
1319 {
</pre>
<hr />
<pre>
1516     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1517     gint y, gint width)
1518 {
1519   gint uv = GET_UV_420 (y, flags);
1520   guint8 *restrict dy = GET_PLANE_LINE (0, y);
1521   guint8 *restrict duv = GET_PLANE_LINE (1, uv);
1522   const guint8 *restrict s = src;
1523 
1524   if (IS_CHROMA_LINE_420 (y, flags)) {
1525     if (IS_ALIGNED (s, 8))
1526       video_orc_pack_NV12 (dy, duv, s, width / 2);
1527     else {
1528       gint i;
1529       for (i = 0; i &lt; width / 2; i++) {
1530         dy[i * 2 + 0] = s[i * 8 + 1];
1531         dy[i * 2 + 1] = s[i * 8 + 5];
1532         duv[i * 2 + 0] = s[i * 8 + 2];
1533         duv[i * 2 + 1] = s[i * 8 + 3];
1534       }
1535     }
<span class="line-modified">1536   if (width &amp; 1) {</span>
<span class="line-modified">1537     gint i = width - 1;</span>
1538 
1539       dy[i] = s[i * 4 + 1];
1540       duv[i + 0] = s[i * 4 + 2];
1541       duv[i + 1] = s[i * 4 + 3];
<span class="line-modified">1542   }</span>
1543   } else
1544     video_orc_pack_Y (dy, s, width);
1545 }
1546 
1547 #define PACK_NV21 GST_VIDEO_FORMAT_AYUV, unpack_NV21, 1, pack_NV21
1548 static void
1549 unpack_NV21 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1550     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1551     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1552 {
1553   gint uv = GET_UV_420 (y, flags);
1554   const guint8 *restrict sy = GET_PLANE_LINE (0, y);
1555   const guint8 *restrict suv = GET_PLANE_LINE (1, uv);
1556   guint8 *restrict d = dest;
1557 
1558   sy += x;
1559   suv += (x &amp; ~1);
1560 
1561   if (x &amp; 1) {
1562     d[0] = 0xff;
</pre>
<hr />
<pre>
1600     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1601     gint y, gint width)
1602 {
1603   gint uv = GET_UV_420 (y, flags);
1604   guint8 *restrict dy = GET_PLANE_LINE (0, y);
1605   guint8 *restrict duv = GET_PLANE_LINE (1, uv);
1606   const guint8 *restrict s = src;
1607 
1608   if (IS_CHROMA_LINE_420 (y, flags)) {
1609     if (IS_ALIGNED (s, 8))
1610       video_orc_pack_NV21 (dy, duv, s, width / 2);
1611     else {
1612       gint i;
1613       for (i = 0; i &lt; width / 2; i++) {
1614         dy[i * 2 + 0] = s[i * 8 + 1];
1615         dy[i * 2 + 1] = s[i * 8 + 5];
1616         duv[i * 2 + 0] = s[i * 8 + 3];
1617         duv[i * 2 + 1] = s[i * 8 + 2];
1618       }
1619     }
<span class="line-modified">1620   if (width &amp; 1) {</span>
<span class="line-modified">1621     gint i = width - 1;</span>
1622 
1623       dy[i] = s[i * 4 + 1];
1624       duv[i + 0] = s[i * 4 + 3];
1625       duv[i + 1] = s[i * 4 + 2];
<span class="line-modified">1626   }</span>
1627   } else
1628     video_orc_pack_Y (dy, s, width);
1629 }
1630 
1631 #define PACK_NV16 GST_VIDEO_FORMAT_AYUV, unpack_NV16, 1, pack_NV16
1632 static void
1633 unpack_NV16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1634     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1635     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1636 {
1637   const guint8 *restrict sy = GET_PLANE_LINE (0, y);
1638   const guint8 *restrict suv = GET_PLANE_LINE (1, y);
1639   guint8 *restrict d = dest;
1640 
1641   sy += x;
1642   suv += (x &amp; ~1);
1643 
1644   if (x &amp; 1) {
1645     d[0] = 0xff;
1646     d[1] = *sy++;
</pre>
<hr />
<pre>
1901 {
1902   gint uv = GET_UV_420 (y, flags);
1903   const guint8 *restrict sy = GET_Y_LINE (y);
1904   const guint8 *restrict su = GET_U_LINE (uv);
1905   const guint8 *restrict sv = GET_V_LINE (uv);
1906   const guint8 *restrict sa = GET_A_LINE (y);
1907   guint8 *restrict d = dest;
1908 
1909   sy += x;
1910   su += x &gt;&gt; 1;
1911   sv += x &gt;&gt; 1;
1912   sa += x;
1913 
1914   if (x &amp; 1) {
1915     d[0] = *sa++;
1916     d[1] = *sy++;
1917     d[2] = *su++;
1918     d[3] = *sv++;
1919     width--;
1920     d += 4;
<span class="line-modified">1921 }</span>
1922   video_orc_unpack_A420 (d, sy, su, sv, sa, width);
1923 }
1924 
1925 static void
1926 pack_A420 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1927     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1928     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1929     gint y, gint width)
1930 {
1931   gint uv = GET_UV_420 (y, flags);
1932   guint8 *restrict dy = GET_Y_LINE (y);
1933   guint8 *restrict du = GET_U_LINE (uv);
1934   guint8 *restrict dv = GET_V_LINE (uv);
1935   guint8 *restrict da = GET_A_LINE (y);
1936   const guint8 *restrict s = src;
1937 
1938   if (IS_CHROMA_LINE_420 (y, flags)) {
1939     if (IS_ALIGNED (s, 8))
1940       video_orc_pack_A420 (dy, du, dv, da, s, width / 2);
1941     else {
1942       gint i;
1943       for (i = 0; i &lt; width / 2; i++) {
1944         da[i * 2 + 0] = s[i * 8 + 0];
1945         dy[i * 2 + 0] = s[i * 8 + 1];
1946         da[i * 2 + 1] = s[i * 8 + 4];
1947         dy[i * 2 + 1] = s[i * 8 + 5];
1948         du[i] = s[i * 8 + 2];
1949         dv[i] = s[i * 8 + 3];
1950       }
1951     }
1952 
<span class="line-modified">1953   if (width &amp; 1) {</span>
<span class="line-modified">1954     gint i = width - 1;</span>
1955 
1956       da[i] = s[i * 4 + 0];
1957       dy[i] = s[i * 4 + 1];
1958       du[i &gt;&gt; 1] = s[i * 4 + 2];
1959       dv[i &gt;&gt; 1] = s[i * 4 + 3];
<span class="line-modified">1960   }</span>
1961   } else
1962     video_orc_pack_AY (dy, da, s, width);
1963 }
1964 
1965 #define PACK_RGB8P GST_VIDEO_FORMAT_ARGB, unpack_RGB8P, 1, pack_RGB8P
1966 static void
1967 unpack_RGB8P (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1968     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1969     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1970 {
1971   int i;
1972   const guint8 *restrict s = GET_LINE (y);
1973   const guint32 *restrict p = data[1];
1974   guint8 *restrict d = dest;
1975 
1976   s += x;
1977 
1978   for (i = 0; i &lt; width; i++) {
1979     guint32 v = p[s[i]];
1980     d[i * 4 + 0] = (v &gt;&gt; 24) &amp; 0xff;
</pre>
<hr />
<pre>
2945   for (i = 0; i &lt; width; i++) {
2946     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 6;
2947     U = GST_READ_UINT16_LE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
2948     V = GST_READ_UINT16_LE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
2949 
2950     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2951       Y |= (Y &gt;&gt; 10);
2952       U |= (U &gt;&gt; 10);
2953       V |= (V &gt;&gt; 10);
2954     }
2955 
2956     d[i * 4 + 0] = 0xffff;
2957     d[i * 4 + 1] = Y;
2958     d[i * 4 + 2] = U;
2959     d[i * 4 + 3] = V;
2960 
2961     if (x &amp; 1) {
2962       x = 0;
2963       su++;
2964       sv++;

2965   }
2966 }
<span class="line-removed">2967 }</span>
2968 
2969 static void
2970 pack_I420_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2971     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2972     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2973     gint y, gint width)
2974 {
2975   int i;
2976   gint uv = GET_UV_420 (y, flags);
2977   guint16 *restrict dy = GET_Y_LINE (y);
2978   guint16 *restrict du = GET_U_LINE (uv);
2979   guint16 *restrict dv = GET_V_LINE (uv);
2980   guint16 Y0, Y1, U, V;
2981   const guint16 *restrict s = src;
2982 
2983   if (IS_CHROMA_LINE_420 (y, flags)) {
<span class="line-modified">2984   for (i = 0; i &lt; width - 1; i += 2) {</span>
<span class="line-modified">2985     Y0 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-modified">2986     Y1 = s[i * 4 + 5] &gt;&gt; 6;</span>
<span class="line-modified">2987     U = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-modified">2988     V = s[i * 4 + 3] &gt;&gt; 6;</span>
2989 
2990       GST_WRITE_UINT16_LE (dy + i + 0, Y0);
2991       GST_WRITE_UINT16_LE (dy + i + 1, Y1);
2992       GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
2993       GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
<span class="line-modified">2994   }</span>
<span class="line-modified">2995   if (i == width - 1) {</span>
<span class="line-modified">2996     Y0 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-modified">2997     U = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-modified">2998     V = s[i * 4 + 3] &gt;&gt; 6;</span>
2999 
3000       GST_WRITE_UINT16_LE (dy + i, Y0);
3001       GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3002       GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
<span class="line-modified">3003   }</span>
3004   } else {
3005     for (i = 0; i &lt; width; i++) {
3006       Y0 = s[i * 4 + 1] &gt;&gt; 6;
3007       GST_WRITE_UINT16_LE (dy + i, Y0);
<span class="line-modified">3008 }</span>
3009   }
3010 }
3011 
3012 #define PACK_I420_10BE GST_VIDEO_FORMAT_AYUV64, unpack_I420_10BE, 1, pack_I420_10BE
3013 static void
3014 unpack_I420_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3015     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3016     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3017 {
3018   int i;
3019   gint uv = GET_UV_420 (y, flags);
3020   const guint16 *restrict sy = GET_Y_LINE (y);
3021   const guint16 *restrict su = GET_U_LINE (uv);
3022   const guint16 *restrict sv = GET_V_LINE (uv);
3023   guint16 *restrict d = dest, Y, U, V;
3024 
3025   sy += x;
3026   su += x &gt;&gt; 1;
3027   sv += x &gt;&gt; 1;
3028 
3029   for (i = 0; i &lt; width; i++) {
3030     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 6;
3031     U = GST_READ_UINT16_BE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
3032     V = GST_READ_UINT16_BE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
3033 
3034     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3035       Y |= (Y &gt;&gt; 10);
3036       U |= (U &gt;&gt; 10);
3037       V |= (V &gt;&gt; 10);
3038     }
3039 
3040     d[i * 4 + 0] = 0xffff;
3041     d[i * 4 + 1] = Y;
3042     d[i * 4 + 2] = U;
3043     d[i * 4 + 3] = V;
3044 
3045     if (x &amp; 1) {
3046       x = 0;
3047       su++;
3048       sv++;

3049   }
3050 }
<span class="line-removed">3051 }</span>
3052 
3053 static void
3054 pack_I420_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3055     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3056     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3057     gint y, gint width)
3058 {
3059   int i;
3060   gint uv = GET_UV_420 (y, flags);
3061   guint16 *restrict dy = GET_Y_LINE (y);
3062   guint16 *restrict du = GET_U_LINE (uv);
3063   guint16 *restrict dv = GET_V_LINE (uv);
3064   guint16 Y0, Y1, U, V;
3065   const guint16 *restrict s = src;
3066 
3067   if (IS_CHROMA_LINE_420 (y, flags)) {
<span class="line-modified">3068   for (i = 0; i &lt; width - 1; i += 2) {</span>
<span class="line-modified">3069     Y0 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-modified">3070     Y1 = s[i * 4 + 5] &gt;&gt; 6;</span>
<span class="line-modified">3071     U = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-modified">3072     V = s[i * 4 + 3] &gt;&gt; 6;</span>
3073 
3074       GST_WRITE_UINT16_BE (dy + i + 0, Y0);
3075       GST_WRITE_UINT16_BE (dy + i + 1, Y1);
3076       GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3077       GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
<span class="line-modified">3078   }</span>
<span class="line-modified">3079   if (i == width - 1) {</span>
<span class="line-modified">3080     Y0 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-modified">3081     U = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-modified">3082     V = s[i * 4 + 3] &gt;&gt; 6;</span>
3083 
3084       GST_WRITE_UINT16_BE (dy + i, Y0);
3085       GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3086       GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
<span class="line-modified">3087   }</span>
3088   } else {
3089     for (i = 0; i &lt; width; i++) {
3090       Y0 = s[i * 4 + 1] &gt;&gt; 6;
3091       GST_WRITE_UINT16_BE (dy + i, Y0);
<span class="line-modified">3092 }</span>
3093   }
3094 }
3095 
3096 #define PACK_I422_10LE GST_VIDEO_FORMAT_AYUV64, unpack_I422_10LE, 1, pack_I422_10LE
3097 static void
3098 unpack_I422_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3099     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3100     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3101 {
3102   int i;
3103   const guint16 *restrict sy = GET_Y_LINE (y);
3104   const guint16 *restrict su = GET_U_LINE (y);
3105   const guint16 *restrict sv = GET_V_LINE (y);
3106   guint16 *restrict d = dest, Y, U, V;
3107 
3108   sy += x;
3109   su += x &gt;&gt; 1;
3110   sv += x &gt;&gt; 1;
3111 
3112   for (i = 0; i &lt; width; i++) {
3113     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 6;
3114     U = GST_READ_UINT16_LE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
3115     V = GST_READ_UINT16_LE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
3116 
3117     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3118       Y |= (Y &gt;&gt; 10);
3119       U |= (U &gt;&gt; 10);
3120       V |= (V &gt;&gt; 10);
3121     }
3122 
3123     d[i * 4 + 0] = 0xffff;
3124     d[i * 4 + 1] = Y;
3125     d[i * 4 + 2] = U;
3126     d[i * 4 + 3] = V;
3127 
3128     if (x &amp; 1) {
3129       x = 0;
3130       su++;
3131       sv++;

3132   }
3133 }
<span class="line-removed">3134 }</span>
3135 
3136 static void
3137 pack_I422_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3138     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3139     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3140     gint y, gint width)
3141 {
3142   int i;
3143   guint16 *restrict dy = GET_Y_LINE (y);
3144   guint16 *restrict du = GET_U_LINE (y);
3145   guint16 *restrict dv = GET_V_LINE (y);
3146   guint16 Y0, Y1, U, V;
3147   const guint16 *restrict s = src;
3148 
3149   for (i = 0; i &lt; width - 1; i += 2) {
3150     Y0 = s[i * 4 + 1] &gt;&gt; 6;
3151     Y1 = s[i * 4 + 5] &gt;&gt; 6;
3152     U = s[i * 4 + 2] &gt;&gt; 6;
3153     V = s[i * 4 + 3] &gt;&gt; 6;
3154 
</pre>
<hr />
<pre>
3187   for (i = 0; i &lt; width; i++) {
3188     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 6;
3189     U = GST_READ_UINT16_BE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
3190     V = GST_READ_UINT16_BE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
3191 
3192     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3193       Y |= (Y &gt;&gt; 10);
3194       U |= (U &gt;&gt; 10);
3195       V |= (V &gt;&gt; 10);
3196     }
3197 
3198     d[i * 4 + 0] = 0xffff;
3199     d[i * 4 + 1] = Y;
3200     d[i * 4 + 2] = U;
3201     d[i * 4 + 3] = V;
3202 
3203     if (x &amp; 1) {
3204       x = 0;
3205       su++;
3206       sv++;

3207   }
3208 }
<span class="line-removed">3209 }</span>
3210 
3211 static void
3212 pack_I422_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3213     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3214     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3215     gint y, gint width)
3216 {
3217   int i;
3218   guint16 *restrict dy = GET_Y_LINE (y);
3219   guint16 *restrict du = GET_U_LINE (y);
3220   guint16 *restrict dv = GET_V_LINE (y);
3221   guint16 Y0, Y1, U, V;
3222   const guint16 *restrict s = src;
3223 
3224   for (i = 0; i &lt; width - 1; i += 2) {
3225     Y0 = s[i * 4 + 1] &gt;&gt; 6;
3226     Y1 = s[i * 4 + 5] &gt;&gt; 6;
3227     U = s[i * 4 + 2] &gt;&gt; 6;
3228     V = s[i * 4 + 3] &gt;&gt; 6;
3229 
</pre>
<hr />
<pre>
4914         case 4:
4915           UV |= s[soff + 2] &gt;&gt; 6 &lt;&lt; 10;
4916           UV |= s[soff + 3] &gt;&gt; 6 &lt;&lt; 20;
4917           GST_WRITE_UINT32_LE (duv + i, UV);
4918           break;
4919         default:
4920           /* keep value */
4921           break;
4922       }
4923 
4924       soff += 4;
4925     }
4926 
4927     GST_WRITE_UINT32_LE (dy + i, Y);
4928 
4929     if (num_comps &lt; 3)
4930       GST_WRITE_UINT32_LE (duv + i, UV);
4931   }
4932 }
4933 























































































































































































































































4934 
4935 typedef struct
4936 {
4937   guint32 fourcc;
4938   GstVideoFormatInfo info;
4939 } VideoFormat;
4940 
4941 /* depths: bits, n_components, shift, depth */
4942 #define DPTH0            0, 0, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }
4943 #define DPTH8            8, 1, { 0, 0, 0, 0 }, { 8, 0, 0, 0 }
4944 #define DPTH8_32         8, 2, { 0, 0, 0, 0 }, { 8, 32, 0, 0 }
4945 #define DPTH888          8, 3, { 0, 0, 0, 0 }, { 8, 8, 8, 0 }
4946 #define DPTH8888         8, 4, { 0, 0, 0, 0 }, { 8, 8, 8, 8 }
4947 #define DPTH8880         8, 4, { 0, 0, 0, 0 }, { 8, 8, 8, 0 }
4948 #define DPTH10           10, 1, { 0, 0, 0, 0 }, { 10, 0, 0, 0 }
4949 #define DPTH10_10_10     10, 3, { 0, 0, 0, 0 }, { 10, 10, 10, 0 }
4950 #define DPTH10_10_10_10  10, 4, { 0, 0, 0, 0 }, { 10, 10, 10, 10 }
4951 #define DPTH10_10_10_HI  16, 3, { 6, 6, 6, 0 }, { 10, 10, 10, 0 }

4952 #define DPTH12_12_12     12, 3, { 0, 0, 0, 0 }, { 12, 12, 12, 0 }
4953 #define DPTH12_12_12_12  12, 4, { 0, 0, 0, 0 }, { 12, 12, 12, 12 }
4954 #define DPTH16           16, 1, { 0, 0, 0, 0 }, { 16, 0, 0, 0 }
4955 #define DPTH16_16_16     16, 3, { 0, 0, 0, 0 }, { 16, 16, 16, 0 }
4956 #define DPTH16_16_16_16  16, 4, { 0, 0, 0, 0 }, { 16, 16, 16, 16 }
4957 #define DPTH555          16, 3, { 10, 5, 0, 0 }, { 5, 5, 5, 0 }
4958 #define DPTH565          16, 3, { 11, 5, 0, 0 }, { 5, 6, 5, 0 }
4959 
4960 /* pixel strides */
4961 #define PSTR0             { 0, 0, 0, 0 }
4962 #define PSTR1             { 1, 0, 0, 0 }
4963 #define PSTR14            { 1, 4, 0, 0 }
4964 #define PSTR111           { 1, 1, 1, 0 }
4965 #define PSTR1111          { 1, 1, 1, 1 }
4966 #define PSTR122           { 1, 2, 2, 0 }
4967 #define PSTR2             { 2, 0, 0, 0 }
4968 #define PSTR222           { 2, 2, 2, 0 }
4969 #define PSTR2222          { 2, 2, 2, 2 }
4970 #define PSTR244           { 2, 4, 4, 0 }
4971 #define PSTR444           { 4, 4, 4, 0 }
</pre>
<hr />
<pre>
5202   MAKE_YUVA_FORMAT (A422_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5203       PSTR2222, PLANE0123, OFFS0, SUB4224, PACK_A422_10BE),
5204   MAKE_YUVA_LE_FORMAT (A422_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5205       PSTR2222, PLANE0123, OFFS0, SUB4224, PACK_A422_10LE),
5206   MAKE_YUVA_FORMAT (A444_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5207       PSTR2222, PLANE0123, OFFS0, SUB4444, PACK_A444_10BE),
5208   MAKE_YUVA_LE_FORMAT (A444_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5209       PSTR2222, PLANE0123, OFFS0, SUB4444, PACK_A444_10LE),
5210   MAKE_YUV_FORMAT (NV61, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;6&#39;, &#39;1&#39;),
5211       DPTH888, PSTR122, PLANE011, OFFS010, SUB422, PACK_NV61),
5212   MAKE_YUV_FORMAT (P010_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_HI,
5213       PSTR244, PLANE011, OFFS001, SUB420, PACK_P010_10BE),
5214   MAKE_YUV_LE_FORMAT (P010_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_HI,
5215       PSTR244, PLANE011, OFFS001, SUB420, PACK_P010_10LE),
5216   MAKE_YUV_FORMAT (IYU2, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;I&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;2&#39;),
5217       DPTH888, PSTR333, PLANE0, OFFS102, SUB444, PACK_IYU2),
5218   MAKE_YUV_FORMAT (VYUY, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;V&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;Y&#39;),
5219       DPTH888, PSTR244, PLANE0, OFFS102, SUB422, PACK_VYUY),
5220   MAKE_RGBA_FORMAT (GBRA, &quot;raw video&quot;, DPTH8888, PSTR1111, PLANE2013,
5221       OFFS0, SUB4444, PACK_GBRA),
<span class="line-modified">5222   MAKE_RGBA_FORMAT (GBRA_10BE, &quot;raw video&quot;, DPTH10_10_10_10, PSTR222, PLANE2013,</span>
<span class="line-modified">5223       OFFS0, SUB4444, PACK_GBRA_10BE),</span>
<span class="line-modified">5224   MAKE_RGBA_LE_FORMAT (GBRA_10LE, &quot;raw video&quot;, DPTH10_10_10_10, PSTR222,</span>
<span class="line-modified">5225       PLANE2013,</span>
<span class="line-removed">5226       OFFS0, SUB4444, PACK_GBRA_10LE),</span>
5227   MAKE_RGB_FORMAT (GBR_12BE, &quot;raw video&quot;, DPTH12_12_12, PSTR222, PLANE201,
5228       OFFS0, SUB444, PACK_GBR_12BE),
5229   MAKE_RGB_LE_FORMAT (GBR_12LE, &quot;raw video&quot;, DPTH12_12_12, PSTR222, PLANE201,
5230       OFFS0, SUB444, PACK_GBR_12LE),
<span class="line-modified">5231   MAKE_RGBA_FORMAT (GBRA_12BE, &quot;raw video&quot;, DPTH12_12_12_12, PSTR222, PLANE2013,</span>
<span class="line-modified">5232       OFFS0, SUB4444, PACK_GBRA_12BE),</span>
<span class="line-modified">5233   MAKE_RGBA_LE_PACK_FORMAT (GBRA_12LE, &quot;raw video&quot;, DPTH12_12_12_12, PSTR222,</span>
5234       PLANE2013, OFFS0, SUB4444, PACK_GBRA_12LE),
5235   MAKE_YUV_FORMAT (I420_12BE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5236       PSTR222, PLANE012, OFFS0, SUB420, PACK_I420_12BE),
5237   MAKE_YUV_LE_FORMAT (I420_12LE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5238       PSTR222, PLANE012, OFFS0, SUB420, PACK_I420_12LE),
5239   MAKE_YUV_FORMAT (I422_12BE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5240       PSTR222, PLANE012, OFFS0, SUB422, PACK_I422_12BE),
5241   MAKE_YUV_LE_FORMAT (I422_12LE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5242       PSTR222, PLANE012, OFFS0, SUB422, PACK_I422_12LE),
5243   MAKE_YUV_FORMAT (Y444_12BE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5244       PSTR222, PLANE012, OFFS0, SUB444, PACK_Y444_12BE),
5245   MAKE_YUV_LE_FORMAT (Y444_12LE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5246       PSTR222, PLANE012, OFFS0, SUB444, PACK_Y444_12LE),
5247   MAKE_GRAY_C_LE_FORMAT (GRAY10_LE32, &quot;raw video&quot;, DPTH10, PSTR0, PLANE0, OFFS0,
5248       SUB4, PACK_GRAY10_LE32),
5249   MAKE_YUV_C_LE_FORMAT (NV12_10LE32, &quot;raw video&quot;,
5250       GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;1&#39;, &#39;5&#39;), DPTH10_10_10, PSTR0, PLANE011,
5251       OFFS001, SUB420, PACK_NV12_10LE32),
5252   MAKE_YUV_C_LE_FORMAT (NV16_10LE32, &quot;raw video&quot;,
5253       GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;2&#39;, &#39;0&#39;), DPTH10_10_10, PSTR0, PLANE011,
5254       OFFS001, SUB422, PACK_NV16_10LE32),












5255 };
5256 
5257 static GstVideoFormat
5258 gst_video_format_from_rgb32_masks (int red_mask, int green_mask, int blue_mask)
5259 {
5260   if (red_mask == 0xff000000 &amp;&amp; green_mask == 0x00ff0000 &amp;&amp;
5261       blue_mask == 0x0000ff00) {
5262     return GST_VIDEO_FORMAT_RGBx;
5263   }
5264   if (red_mask == 0x0000ff00 &amp;&amp; green_mask == 0x00ff0000 &amp;&amp;
5265       blue_mask == 0xff000000) {
5266     return GST_VIDEO_FORMAT_BGRx;
5267   }
5268   if (red_mask == 0x00ff0000 &amp;&amp; green_mask == 0x0000ff00 &amp;&amp;
5269       blue_mask == 0x000000ff) {
5270     return GST_VIDEO_FORMAT_xRGB;
5271   }
5272   if (red_mask == 0x000000ff &amp;&amp; green_mask == 0x0000ff00 &amp;&amp;
5273       blue_mask == 0x00ff0000) {
5274     return GST_VIDEO_FORMAT_xBGR;
</pre>
<hr />
<pre>
5353  * @bpp: the amount of bits used to store a pixel. This value is bigger than
5354  *   @depth
5355  * @endianness: the endianness of the masks, #G_LITTLE_ENDIAN or #G_BIG_ENDIAN
5356  * @red_mask: the red mask
5357  * @green_mask: the green mask
5358  * @blue_mask: the blue mask
5359  * @alpha_mask: the alpha mask, or 0 if no alpha mask
5360  *
5361  * Find the #GstVideoFormat for the given parameters.
5362  *
5363  * Returns: a #GstVideoFormat or GST_VIDEO_FORMAT_UNKNOWN when the parameters to
5364  * not specify a known format.
5365  */
5366 GstVideoFormat
5367 gst_video_format_from_masks (gint depth, gint bpp, gint endianness,
5368     guint red_mask, guint green_mask, guint blue_mask, guint alpha_mask)
5369 {
5370   GstVideoFormat format;
5371 
5372   /* our caps system handles 24/32bpp RGB as big-endian. */
<span class="line-modified">5373   if ((bpp == 24 || bpp == 32) &amp;&amp; endianness == G_LITTLE_ENDIAN) {</span>

5374     red_mask = GUINT32_TO_BE (red_mask);
5375     green_mask = GUINT32_TO_BE (green_mask);
5376     blue_mask = GUINT32_TO_BE (blue_mask);
5377     alpha_mask = GUINT32_TO_BE (alpha_mask);
5378     endianness = G_BIG_ENDIAN;
5379     if (bpp == 24) {
5380       red_mask &gt;&gt;= 8;
5381       green_mask &gt;&gt;= 8;
5382       blue_mask &gt;&gt;= 8;
5383     }
5384   }
5385 
<span class="line-modified">5386   if (depth == 30 &amp;&amp; bpp == 32) {</span>



5387     format = GST_VIDEO_FORMAT_r210;
5388   } else if (depth == 24 &amp;&amp; bpp == 32) {
5389     format = gst_video_format_from_rgb32_masks (red_mask, green_mask,
5390         blue_mask);
5391   } else if (depth == 32 &amp;&amp; bpp == 32 &amp;&amp; alpha_mask) {
5392     format = gst_video_format_from_rgba32_masks (red_mask, green_mask,
5393         blue_mask, alpha_mask);
5394   } else if (depth == 24 &amp;&amp; bpp == 24) {
5395     format = gst_video_format_from_rgb24_masks (red_mask, green_mask,
5396         blue_mask);
5397   } else if ((depth == 15 || depth == 16) &amp;&amp; bpp == 16 &amp;&amp;
5398       endianness == G_BYTE_ORDER) {
5399     format = gst_video_format_from_rgb16_masks (red_mask, green_mask,
5400         blue_mask);
5401   } else if (depth == 8 &amp;&amp; bpp == 8) {
5402     format = GST_VIDEO_FORMAT_RGB8P;
5403   } else if (depth == 64 &amp;&amp; bpp == 64) {
5404     format = gst_video_format_from_rgba32_masks (red_mask, green_mask,
5405         blue_mask, alpha_mask);
5406     if (format == GST_VIDEO_FORMAT_ARGB) {
</pre>
<hr />
<pre>
5435     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;U&#39;, &#39;Y&#39;, &#39;2&#39;):
5436       return GST_VIDEO_FORMAT_YUY2;
5437     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;V&#39;, &#39;Y&#39;, &#39;U&#39;):
5438       return GST_VIDEO_FORMAT_YVYU;
5439     case GST_MAKE_FOURCC (&#39;U&#39;, &#39;Y&#39;, &#39;V&#39;, &#39;Y&#39;):
5440       return GST_VIDEO_FORMAT_UYVY;
5441     case GST_MAKE_FOURCC (&#39;V&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;Y&#39;):
5442       return GST_VIDEO_FORMAT_VYUY;
5443     case GST_MAKE_FOURCC (&#39;A&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;V&#39;):
5444       return GST_VIDEO_FORMAT_AYUV;
5445     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;1&#39;, &#39;B&#39;):
5446       return GST_VIDEO_FORMAT_Y41B;
5447     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;2&#39;, &#39;B&#39;):
5448       return GST_VIDEO_FORMAT_Y42B;
5449     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;):
5450       return GST_VIDEO_FORMAT_Y444;
5451     case GST_MAKE_FOURCC (&#39;v&#39;, &#39;2&#39;, &#39;1&#39;, &#39;0&#39;):
5452       return GST_VIDEO_FORMAT_v210;
5453     case GST_MAKE_FOURCC (&#39;v&#39;, &#39;2&#39;, &#39;1&#39;, &#39;6&#39;):
5454       return GST_VIDEO_FORMAT_v216;


5455     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;1&#39;, &#39;2&#39;):
5456       return GST_VIDEO_FORMAT_NV12;
5457     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;2&#39;, &#39;1&#39;):
5458       return GST_VIDEO_FORMAT_NV21;
5459     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;1&#39;, &#39;6&#39;):
5460       return GST_VIDEO_FORMAT_NV16;
5461     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;6&#39;, &#39;1&#39;):
5462       return GST_VIDEO_FORMAT_NV61;
5463     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;2&#39;, &#39;4&#39;):
5464       return GST_VIDEO_FORMAT_NV24;
5465     case GST_MAKE_FOURCC (&#39;v&#39;, &#39;3&#39;, &#39;0&#39;, &#39;8&#39;):
5466       return GST_VIDEO_FORMAT_v308;
5467     case GST_MAKE_FOURCC (&#39;I&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;2&#39;):
5468       return GST_VIDEO_FORMAT_IYU2;
5469     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;8&#39;, &#39;0&#39;, &#39;0&#39;):
5470     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;8&#39;, &#39; &#39;, &#39; &#39;):
5471     case GST_MAKE_FOURCC (&#39;G&#39;, &#39;R&#39;, &#39;E&#39;, &#39;Y&#39;):
5472       return GST_VIDEO_FORMAT_GRAY8;
5473     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;1&#39;, &#39;6&#39;, &#39; &#39;):
5474       return GST_VIDEO_FORMAT_GRAY16_LE;
5475     case GST_MAKE_FOURCC (&#39;U&#39;, &#39;Y&#39;, &#39;V&#39;, &#39;P&#39;):
5476       return GST_VIDEO_FORMAT_UYVP;
5477     case GST_MAKE_FOURCC (&#39;A&#39;, &#39;4&#39;, &#39;2&#39;, &#39;0&#39;):
5478       return GST_VIDEO_FORMAT_A420;
5479     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;U&#39;, &#39;V&#39;, &#39;9&#39;):
5480       return GST_VIDEO_FORMAT_YUV9;
5481     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;V&#39;, &#39;U&#39;, &#39;9&#39;):
5482       return GST_VIDEO_FORMAT_YVU9;
5483     case GST_MAKE_FOURCC (&#39;I&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;1&#39;):
5484       return GST_VIDEO_FORMAT_IYU1;
5485     case GST_MAKE_FOURCC (&#39;A&#39;, &#39;Y&#39;, &#39;6&#39;, &#39;4&#39;):
5486       return GST_VIDEO_FORMAT_AYUV64;
5487     case GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;1&#39;, &#39;0&#39;):
5488       return GST_VIDEO_FORMAT_GRAY10_LE32;
5489     case GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;1&#39;, &#39;5&#39;):
5490       return GST_VIDEO_FORMAT_NV12_10LE32;
5491     case GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;2&#39;, &#39;0&#39;):
5492       return GST_VIDEO_FORMAT_NV16_10LE32;









5493     default:
5494       return GST_VIDEO_FORMAT_UNKNOWN;
5495   }
5496 }
5497 
5498 /**
5499  * gst_video_format_from_string:
5500  * @format: a format string
5501  *
5502  * Convert the @format string to its #GstVideoFormat.
5503  *
5504  * Returns: the #GstVideoFormat for @format or GST_VIDEO_FORMAT_UNKNOWN when the
5505  * string is not a known format.
5506  */
5507 GstVideoFormat
5508 gst_video_format_from_string (const gchar * format)
5509 {
5510   guint i;
5511 
5512   g_return_val_if_fail (format != NULL, GST_VIDEO_FORMAT_UNKNOWN);
</pre>
</td>
<td>
<hr />
<pre>
 125 {
 126   gint uv = GET_UV_420 (y, flags);
 127   guint8 *dy = GET_Y_LINE (y);
 128   guint8 *du = GET_U_LINE (uv);
 129   guint8 *dv = GET_V_LINE (uv);
 130   const guint8 *s = src;
 131 
 132   if (IS_CHROMA_LINE_420 (y, flags)) {
 133     if (IS_ALIGNED (s, 8))
 134       video_orc_pack_I420 (dy, du, dv, s, width / 2);
 135     else {
 136       gint i;
 137 
 138       for (i = 0; i &lt; width / 2; i++) {
 139         dy[i * 2 + 0] = s[i * 8 + 1];
 140         dy[i * 2 + 1] = s[i * 8 + 5];
 141         du[i] = s[i * 8 + 2];
 142         dv[i] = s[i * 8 + 3];
 143       }
 144     }
<span class="line-modified"> 145     if (width &amp; 1) {</span>
<span class="line-modified"> 146       gint i = width - 1;</span>
 147 
 148       dy[i] = s[i * 4 + 1];
 149       du[i &gt;&gt; 1] = s[i * 4 + 2];
 150       dv[i &gt;&gt; 1] = s[i * 4 + 3];
<span class="line-modified"> 151     }</span>
 152   } else
 153     video_orc_pack_Y (dy, s, width);
 154 }
 155 
 156 #define PACK_YUY2 GST_VIDEO_FORMAT_AYUV, unpack_YUY2, 1, pack_YUY2
 157 static void
 158 unpack_YUY2 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 159     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 160     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 161 {
 162   const guint8 *restrict s = GET_LINE (y);
 163   guint8 *restrict d = dest;
 164 
 165   s += (x &amp; ~1) &lt;&lt; 1;
 166   if (x &amp; 1) {
 167     d[0] = 0xff;
 168     d[1] = s[2];
 169     d[2] = s[1];
 170     d[3] = s[3];
 171     s += 4;
</pre>
<hr />
<pre>
 771     gint y, gint width)
 772 {
 773   int i;
 774   guint8 *restrict d = GET_LINE (y);
 775   const guint16 *restrict s = src;
 776 
 777   for (i = 0; i &lt; width - 1; i += 2) {
 778     GST_WRITE_UINT16_LE (d + i * 4 + 0, s[(i + 0) * 4 + 2]);
 779     GST_WRITE_UINT16_LE (d + i * 4 + 2, s[(i + 0) * 4 + 1]);
 780     GST_WRITE_UINT16_LE (d + i * 4 + 4, s[(i + 0) * 4 + 3]);
 781     GST_WRITE_UINT16_LE (d + i * 4 + 6, s[(i + 1) * 4 + 1]);
 782   }
 783   if (i == width - 1) {
 784     GST_WRITE_UINT16_LE (d + i * 4 + 0, s[i * 4 + 2]);
 785     GST_WRITE_UINT16_LE (d + i * 4 + 2, s[i * 4 + 1]);
 786     GST_WRITE_UINT16_LE (d + i * 4 + 4, s[i * 4 + 3]);
 787     GST_WRITE_UINT16_LE (d + i * 4 + 6, s[i * 4 + 1]);
 788   }
 789 }
 790 
<span class="line-added"> 791 #define PACK_Y210 GST_VIDEO_FORMAT_AYUV64, unpack_Y210, 1, pack_Y210</span>
<span class="line-added"> 792 static void</span>
<span class="line-added"> 793 unpack_Y210 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added"> 794     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added"> 795     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)</span>
<span class="line-added"> 796 {</span>
<span class="line-added"> 797   int i;</span>
<span class="line-added"> 798   const guint8 *restrict s = GET_LINE (y);</span>
<span class="line-added"> 799   guint16 *restrict d = dest;</span>
<span class="line-added"> 800   guint Y0, Y1, U, V;</span>
<span class="line-added"> 801 </span>
<span class="line-added"> 802   s += GST_ROUND_DOWN_2 (x) * 4;</span>
<span class="line-added"> 803 </span>
<span class="line-added"> 804   if (x &amp; 1) {</span>
<span class="line-added"> 805     Y1 = GST_READ_UINT16_LE (s + 4);</span>
<span class="line-added"> 806     U = GST_READ_UINT16_LE (s + 2);</span>
<span class="line-added"> 807     V = GST_READ_UINT16_LE (s + 6);</span>
<span class="line-added"> 808 </span>
<span class="line-added"> 809     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {</span>
<span class="line-added"> 810       Y1 |= (Y1 &gt;&gt; 10);</span>
<span class="line-added"> 811       U |= (U &gt;&gt; 10);</span>
<span class="line-added"> 812       V |= (V &gt;&gt; 10);</span>
<span class="line-added"> 813     }</span>
<span class="line-added"> 814 </span>
<span class="line-added"> 815     d[0] = 0xffff;</span>
<span class="line-added"> 816     d[1] = Y1;</span>
<span class="line-added"> 817     d[2] = U;</span>
<span class="line-added"> 818     d[3] = V;</span>
<span class="line-added"> 819     s += 8;</span>
<span class="line-added"> 820     d += 4;</span>
<span class="line-added"> 821     width--;</span>
<span class="line-added"> 822   }</span>
<span class="line-added"> 823 </span>
<span class="line-added"> 824   for (i = 0; i &lt; width / 2; i++) {</span>
<span class="line-added"> 825     Y0 = GST_READ_UINT16_LE (s + i * 8 + 0);</span>
<span class="line-added"> 826     U = GST_READ_UINT16_LE (s + i * 8 + 2);</span>
<span class="line-added"> 827     V = GST_READ_UINT16_LE (s + i * 8 + 6);</span>
<span class="line-added"> 828     Y1 = GST_READ_UINT16_LE (s + i * 8 + 4);</span>
<span class="line-added"> 829 </span>
<span class="line-added"> 830     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {</span>
<span class="line-added"> 831       Y0 |= (Y0 &gt;&gt; 10);</span>
<span class="line-added"> 832       U |= (U &gt;&gt; 10);</span>
<span class="line-added"> 833       V |= (V &gt;&gt; 10);</span>
<span class="line-added"> 834     }</span>
<span class="line-added"> 835 </span>
<span class="line-added"> 836     d[i * 8 + 0] = 0xffff;</span>
<span class="line-added"> 837     d[i * 8 + 1] = Y0;</span>
<span class="line-added"> 838     d[i * 8 + 2] = U;</span>
<span class="line-added"> 839     d[i * 8 + 3] = V;</span>
<span class="line-added"> 840 </span>
<span class="line-added"> 841     d[i * 8 + 4] = 0xffff;</span>
<span class="line-added"> 842     d[i * 8 + 5] = Y1;</span>
<span class="line-added"> 843     d[i * 8 + 6] = U;</span>
<span class="line-added"> 844     d[i * 8 + 7] = V;</span>
<span class="line-added"> 845   }</span>
<span class="line-added"> 846 </span>
<span class="line-added"> 847   if (width &amp; 1) {</span>
<span class="line-added"> 848     i = width - 1;</span>
<span class="line-added"> 849 </span>
<span class="line-added"> 850     Y0 = GST_READ_UINT16_LE (s + i * 4 + 0);</span>
<span class="line-added"> 851     U = GST_READ_UINT16_LE (s + i * 4 + 2);</span>
<span class="line-added"> 852     V = GST_READ_UINT16_LE (s + i * 4 + 6);</span>
<span class="line-added"> 853 </span>
<span class="line-added"> 854     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {</span>
<span class="line-added"> 855       Y0 |= (Y0 &gt;&gt; 10);</span>
<span class="line-added"> 856       U |= (U &gt;&gt; 10);</span>
<span class="line-added"> 857       V |= (V &gt;&gt; 10);</span>
<span class="line-added"> 858     }</span>
<span class="line-added"> 859 </span>
<span class="line-added"> 860     d[i * 4 + 0] = 0xffff;</span>
<span class="line-added"> 861     d[i * 4 + 1] = Y0;</span>
<span class="line-added"> 862     d[i * 4 + 2] = U;</span>
<span class="line-added"> 863     d[i * 4 + 3] = V;</span>
<span class="line-added"> 864   }</span>
<span class="line-added"> 865 }</span>
<span class="line-added"> 866 </span>
<span class="line-added"> 867 static void</span>
<span class="line-added"> 868 pack_Y210 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added"> 869     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added"> 870     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,</span>
<span class="line-added"> 871     gint y, gint width)</span>
<span class="line-added"> 872 {</span>
<span class="line-added"> 873   int i;</span>
<span class="line-added"> 874   guint16 Y0, Y1, U, V;</span>
<span class="line-added"> 875   guint8 *restrict d = GET_LINE (y);</span>
<span class="line-added"> 876   const guint16 *restrict s = src;</span>
<span class="line-added"> 877 </span>
<span class="line-added"> 878   for (i = 0; i &lt; width; i += 2) {</span>
<span class="line-added"> 879     Y0 = s[i * 4 + 1] &amp; 0xffc0;</span>
<span class="line-added"> 880     U = s[i * 4 + 2] &amp; 0xffc0;</span>
<span class="line-added"> 881     V = s[i * 4 + 3] &amp; 0xffc0;</span>
<span class="line-added"> 882     if (i == width - 1)</span>
<span class="line-added"> 883       Y1 = s[i * 4 + 1] &amp; 0xffc0;</span>
<span class="line-added"> 884     else</span>
<span class="line-added"> 885       Y1 = s[(i + 1) * 4 + 1] &amp; 0xffc0;</span>
<span class="line-added"> 886 </span>
<span class="line-added"> 887     GST_WRITE_UINT16_LE (d + i * 4 + 0, Y0);</span>
<span class="line-added"> 888     GST_WRITE_UINT16_LE (d + i * 4 + 2, U);</span>
<span class="line-added"> 889     GST_WRITE_UINT16_LE (d + i * 4 + 4, Y1);</span>
<span class="line-added"> 890     GST_WRITE_UINT16_LE (d + i * 4 + 6, V);</span>
<span class="line-added"> 891   }</span>
<span class="line-added"> 892 }</span>
<span class="line-added"> 893 </span>
<span class="line-added"> 894 #define PACK_Y410 GST_VIDEO_FORMAT_AYUV64, unpack_Y410, 1, pack_Y410</span>
<span class="line-added"> 895 static void</span>
<span class="line-added"> 896 unpack_Y410 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added"> 897     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added"> 898     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)</span>
<span class="line-added"> 899 {</span>
<span class="line-added"> 900   int i;</span>
<span class="line-added"> 901   const guint8 *restrict s = GET_LINE (y);</span>
<span class="line-added"> 902   guint16 *restrict d = dest;</span>
<span class="line-added"> 903   guint32 AVYU;</span>
<span class="line-added"> 904   guint16 A, Y, U, V;</span>
<span class="line-added"> 905 </span>
<span class="line-added"> 906   s += x * 4;</span>
<span class="line-added"> 907 </span>
<span class="line-added"> 908   for (i = 0; i &lt; width; i++) {</span>
<span class="line-added"> 909     AVYU = GST_READ_UINT32_LE (s + 4 * i);</span>
<span class="line-added"> 910 </span>
<span class="line-added"> 911     U = ((AVYU &gt;&gt; 0) &amp; 0x3ff) &lt;&lt; 6;</span>
<span class="line-added"> 912     Y = ((AVYU &gt;&gt; 10) &amp; 0x3ff) &lt;&lt; 6;</span>
<span class="line-added"> 913     V = ((AVYU &gt;&gt; 20) &amp; 0x3ff) &lt;&lt; 6;</span>
<span class="line-added"> 914     A = ((AVYU &gt;&gt; 30) &amp; 0x03) &lt;&lt; 14;</span>
<span class="line-added"> 915 </span>
<span class="line-added"> 916     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {</span>
<span class="line-added"> 917       U |= (U &gt;&gt; 10);</span>
<span class="line-added"> 918       Y |= (Y &gt;&gt; 10);</span>
<span class="line-added"> 919       V |= (V &gt;&gt; 10);</span>
<span class="line-added"> 920       A |= (A &gt;&gt; 10);</span>
<span class="line-added"> 921     }</span>
<span class="line-added"> 922 </span>
<span class="line-added"> 923     d[4 * i + 0] = A;</span>
<span class="line-added"> 924     d[4 * i + 1] = Y;</span>
<span class="line-added"> 925     d[4 * i + 2] = U;</span>
<span class="line-added"> 926     d[4 * i + 3] = V;</span>
<span class="line-added"> 927   }</span>
<span class="line-added"> 928 }</span>
<span class="line-added"> 929 </span>
<span class="line-added"> 930 static void</span>
<span class="line-added"> 931 pack_Y410 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added"> 932     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added"> 933     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,</span>
<span class="line-added"> 934     gint y, gint width)</span>
<span class="line-added"> 935 {</span>
<span class="line-added"> 936   int i;</span>
<span class="line-added"> 937   guint32 *restrict d = GET_LINE (y);</span>
<span class="line-added"> 938   const guint16 *restrict s = src;</span>
<span class="line-added"> 939   guint32 AVYU;</span>
<span class="line-added"> 940   guint16 A, Y, U, V;</span>
<span class="line-added"> 941 </span>
<span class="line-added"> 942   for (i = 0; i &lt; width; i++) {</span>
<span class="line-added"> 943     A = s[4 * i] &amp; 0xc000;</span>
<span class="line-added"> 944     Y = s[4 * i + 1] &amp; 0xffc0;</span>
<span class="line-added"> 945     U = s[4 * i + 2] &amp; 0xffc0;</span>
<span class="line-added"> 946     V = s[4 * i + 3] &amp; 0xffc0;</span>
<span class="line-added"> 947 </span>
<span class="line-added"> 948     AVYU = (U &gt;&gt; 6) | (Y &lt;&lt; 4) | (V &lt;&lt; 14) | (A &lt;&lt; 16);</span>
<span class="line-added"> 949 </span>
<span class="line-added"> 950     GST_WRITE_UINT32_LE (d + i, AVYU);</span>
<span class="line-added"> 951   }</span>
<span class="line-added"> 952 }</span>
<span class="line-added"> 953 </span>
 954 #define PACK_Y41B GST_VIDEO_FORMAT_AYUV, unpack_Y41B, 1, pack_Y41B
 955 static void
 956 unpack_Y41B (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 957     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 958     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 959 {
 960   const guint8 *restrict sy = GET_Y_LINE (y);
 961   const guint8 *restrict su = GET_U_LINE (y);
 962   const guint8 *restrict sv = GET_V_LINE (y);
 963   guint8 *restrict d = dest;
 964 
 965   sy += x;
 966   su += x &gt;&gt; 2;
 967   sv += x &gt;&gt; 2;
 968 
 969   if (x &amp; 3) {
 970     for (; x &amp; 3; x++) {
 971       d[0] = 0xff;
 972       d[1] = *sy++;
 973       d[2] = *su;
</pre>
<hr />
<pre>
1326   guint16 *restrict d = GET_LINE (y);
1327   const guint16 *restrict s = src;
1328 
1329   for (i = 0; i &lt; width; i++) {
1330     GST_WRITE_UINT16_LE (d + i, s[i * 4 + 1]);
1331   }
1332 }
1333 
1334 #define PACK_RGB16 GST_VIDEO_FORMAT_ARGB, unpack_RGB16, 1, pack_RGB16
1335 static void
1336 unpack_RGB16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1337     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1338     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1339 {
1340   const guint16 *restrict s = GET_LINE (y);
1341 
1342   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1343     video_orc_unpack_RGB16_trunc (dest, s + x, width);
1344   else
1345     video_orc_unpack_RGB16 (dest, s + x, width);
<span class="line-modified">1346 }</span>
1347 
1348 static void
1349 pack_RGB16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1350     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1351     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1352     gint y, gint width)
1353 {
1354   guint16 *restrict d = GET_LINE (y);
1355 
1356 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1357   video_orc_pack_RGB16_le (d, src, width);
1358 #else
1359   video_orc_pack_RGB16_be (d, src, width);
1360 #endif
<span class="line-modified">1361 }</span>
1362 
1363 #define PACK_BGR16 GST_VIDEO_FORMAT_ARGB, unpack_BGR16, 1, pack_BGR16
1364 static void
1365 unpack_BGR16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1366     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1367     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1368 {
1369   const guint16 *restrict s = GET_LINE (y);
1370 
1371   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1372     video_orc_unpack_BGR16_trunc (dest, s + x, width);
1373   else
1374     video_orc_unpack_BGR16 (dest, s + x, width);
<span class="line-modified">1375 }</span>
1376 
1377 static void
1378 pack_BGR16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1379     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1380     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1381     gint y, gint width)
1382 {
1383   guint16 *restrict d = GET_LINE (y);
1384 
1385 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1386   video_orc_pack_BGR16_le (d, src, width);
1387 #else
1388   video_orc_pack_BGR16_be (d, src, width);
1389 #endif
<span class="line-modified">1390 }</span>
1391 
1392 #define PACK_RGB15 GST_VIDEO_FORMAT_ARGB, unpack_RGB15, 1, pack_RGB15
1393 static void
1394 unpack_RGB15 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1395     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1396     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1397 {
1398   const guint16 *restrict s = GET_LINE (y);
1399 
1400 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1401   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1402     video_orc_unpack_RGB15_le_trunc (dest, s + x, width);
1403   else
1404     video_orc_unpack_RGB15_le (dest, s + x, width);
1405 #else
1406   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1407     video_orc_unpack_RGB15_be_trunc (dest, s + x, width);
1408   else
1409     video_orc_unpack_RGB15_be (dest, s + x, width);
1410 #endif
<span class="line-modified">1411 }</span>
1412 
1413 static void
1414 pack_RGB15 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1415     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1416     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1417     gint y, gint width)
1418 {
1419   guint16 *restrict d = GET_LINE (y);
1420 
1421 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1422   video_orc_pack_RGB15_le (d, src, width);
1423 #else
1424   video_orc_pack_RGB15_be (d, src, width);
1425 #endif
<span class="line-modified">1426 }</span>
1427 
1428 #define PACK_BGR15 GST_VIDEO_FORMAT_ARGB, unpack_BGR15, 1, pack_BGR15
1429 static void
1430 unpack_BGR15 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1431     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1432     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1433 {
1434   const guint16 *restrict s = GET_LINE (y);
1435 
1436 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1437   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1438     video_orc_unpack_BGR15_le_trunc (dest, s + x, width);
1439   else
1440     video_orc_unpack_BGR15_le (dest, s + x, width);
1441 #else
1442   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1443     video_orc_unpack_BGR15_be_trunc (dest, s + x, width);
1444   else
1445     video_orc_unpack_BGR15_be (dest, s + x, width);
1446 #endif
<span class="line-modified">1447 }</span>
1448 
1449 static void
1450 pack_BGR15 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1451     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1452     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1453     gint y, gint width)
1454 {
1455   guint16 *restrict d = GET_LINE (y);
1456 
1457 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1458   video_orc_pack_BGR15_le (d, src, width);
1459 #else
1460   video_orc_pack_BGR15_be (d, src, width);
1461 #endif
<span class="line-modified">1462 }</span>
1463 
1464 #define PACK_BGRA GST_VIDEO_FORMAT_ARGB, unpack_BGRA, 1, pack_BGRA
1465 static void
1466 unpack_BGRA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1467     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1468     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1469 {
1470   const guint8 *restrict s = GET_LINE (y);
1471 
1472   s += x * 4;
1473 
1474   video_orc_unpack_BGRA (dest, s, width);
1475 }
1476 
1477 static void
1478 pack_BGRA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1479     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1480     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1481     gint y, gint width)
1482 {
</pre>
<hr />
<pre>
1679     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1680     gint y, gint width)
1681 {
1682   gint uv = GET_UV_420 (y, flags);
1683   guint8 *restrict dy = GET_PLANE_LINE (0, y);
1684   guint8 *restrict duv = GET_PLANE_LINE (1, uv);
1685   const guint8 *restrict s = src;
1686 
1687   if (IS_CHROMA_LINE_420 (y, flags)) {
1688     if (IS_ALIGNED (s, 8))
1689       video_orc_pack_NV12 (dy, duv, s, width / 2);
1690     else {
1691       gint i;
1692       for (i = 0; i &lt; width / 2; i++) {
1693         dy[i * 2 + 0] = s[i * 8 + 1];
1694         dy[i * 2 + 1] = s[i * 8 + 5];
1695         duv[i * 2 + 0] = s[i * 8 + 2];
1696         duv[i * 2 + 1] = s[i * 8 + 3];
1697       }
1698     }
<span class="line-modified">1699     if (width &amp; 1) {</span>
<span class="line-modified">1700       gint i = width - 1;</span>
1701 
1702       dy[i] = s[i * 4 + 1];
1703       duv[i + 0] = s[i * 4 + 2];
1704       duv[i + 1] = s[i * 4 + 3];
<span class="line-modified">1705     }</span>
1706   } else
1707     video_orc_pack_Y (dy, s, width);
1708 }
1709 
1710 #define PACK_NV21 GST_VIDEO_FORMAT_AYUV, unpack_NV21, 1, pack_NV21
1711 static void
1712 unpack_NV21 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1713     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1714     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1715 {
1716   gint uv = GET_UV_420 (y, flags);
1717   const guint8 *restrict sy = GET_PLANE_LINE (0, y);
1718   const guint8 *restrict suv = GET_PLANE_LINE (1, uv);
1719   guint8 *restrict d = dest;
1720 
1721   sy += x;
1722   suv += (x &amp; ~1);
1723 
1724   if (x &amp; 1) {
1725     d[0] = 0xff;
</pre>
<hr />
<pre>
1763     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1764     gint y, gint width)
1765 {
1766   gint uv = GET_UV_420 (y, flags);
1767   guint8 *restrict dy = GET_PLANE_LINE (0, y);
1768   guint8 *restrict duv = GET_PLANE_LINE (1, uv);
1769   const guint8 *restrict s = src;
1770 
1771   if (IS_CHROMA_LINE_420 (y, flags)) {
1772     if (IS_ALIGNED (s, 8))
1773       video_orc_pack_NV21 (dy, duv, s, width / 2);
1774     else {
1775       gint i;
1776       for (i = 0; i &lt; width / 2; i++) {
1777         dy[i * 2 + 0] = s[i * 8 + 1];
1778         dy[i * 2 + 1] = s[i * 8 + 5];
1779         duv[i * 2 + 0] = s[i * 8 + 3];
1780         duv[i * 2 + 1] = s[i * 8 + 2];
1781       }
1782     }
<span class="line-modified">1783     if (width &amp; 1) {</span>
<span class="line-modified">1784       gint i = width - 1;</span>
1785 
1786       dy[i] = s[i * 4 + 1];
1787       duv[i + 0] = s[i * 4 + 3];
1788       duv[i + 1] = s[i * 4 + 2];
<span class="line-modified">1789     }</span>
1790   } else
1791     video_orc_pack_Y (dy, s, width);
1792 }
1793 
1794 #define PACK_NV16 GST_VIDEO_FORMAT_AYUV, unpack_NV16, 1, pack_NV16
1795 static void
1796 unpack_NV16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1797     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1798     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1799 {
1800   const guint8 *restrict sy = GET_PLANE_LINE (0, y);
1801   const guint8 *restrict suv = GET_PLANE_LINE (1, y);
1802   guint8 *restrict d = dest;
1803 
1804   sy += x;
1805   suv += (x &amp; ~1);
1806 
1807   if (x &amp; 1) {
1808     d[0] = 0xff;
1809     d[1] = *sy++;
</pre>
<hr />
<pre>
2064 {
2065   gint uv = GET_UV_420 (y, flags);
2066   const guint8 *restrict sy = GET_Y_LINE (y);
2067   const guint8 *restrict su = GET_U_LINE (uv);
2068   const guint8 *restrict sv = GET_V_LINE (uv);
2069   const guint8 *restrict sa = GET_A_LINE (y);
2070   guint8 *restrict d = dest;
2071 
2072   sy += x;
2073   su += x &gt;&gt; 1;
2074   sv += x &gt;&gt; 1;
2075   sa += x;
2076 
2077   if (x &amp; 1) {
2078     d[0] = *sa++;
2079     d[1] = *sy++;
2080     d[2] = *su++;
2081     d[3] = *sv++;
2082     width--;
2083     d += 4;
<span class="line-modified">2084   }</span>
2085   video_orc_unpack_A420 (d, sy, su, sv, sa, width);
2086 }
2087 
2088 static void
2089 pack_A420 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2090     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2091     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2092     gint y, gint width)
2093 {
2094   gint uv = GET_UV_420 (y, flags);
2095   guint8 *restrict dy = GET_Y_LINE (y);
2096   guint8 *restrict du = GET_U_LINE (uv);
2097   guint8 *restrict dv = GET_V_LINE (uv);
2098   guint8 *restrict da = GET_A_LINE (y);
2099   const guint8 *restrict s = src;
2100 
2101   if (IS_CHROMA_LINE_420 (y, flags)) {
2102     if (IS_ALIGNED (s, 8))
2103       video_orc_pack_A420 (dy, du, dv, da, s, width / 2);
2104     else {
2105       gint i;
2106       for (i = 0; i &lt; width / 2; i++) {
2107         da[i * 2 + 0] = s[i * 8 + 0];
2108         dy[i * 2 + 0] = s[i * 8 + 1];
2109         da[i * 2 + 1] = s[i * 8 + 4];
2110         dy[i * 2 + 1] = s[i * 8 + 5];
2111         du[i] = s[i * 8 + 2];
2112         dv[i] = s[i * 8 + 3];
2113       }
2114     }
2115 
<span class="line-modified">2116     if (width &amp; 1) {</span>
<span class="line-modified">2117       gint i = width - 1;</span>
2118 
2119       da[i] = s[i * 4 + 0];
2120       dy[i] = s[i * 4 + 1];
2121       du[i &gt;&gt; 1] = s[i * 4 + 2];
2122       dv[i &gt;&gt; 1] = s[i * 4 + 3];
<span class="line-modified">2123     }</span>
2124   } else
2125     video_orc_pack_AY (dy, da, s, width);
2126 }
2127 
2128 #define PACK_RGB8P GST_VIDEO_FORMAT_ARGB, unpack_RGB8P, 1, pack_RGB8P
2129 static void
2130 unpack_RGB8P (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2131     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2132     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2133 {
2134   int i;
2135   const guint8 *restrict s = GET_LINE (y);
2136   const guint32 *restrict p = data[1];
2137   guint8 *restrict d = dest;
2138 
2139   s += x;
2140 
2141   for (i = 0; i &lt; width; i++) {
2142     guint32 v = p[s[i]];
2143     d[i * 4 + 0] = (v &gt;&gt; 24) &amp; 0xff;
</pre>
<hr />
<pre>
3108   for (i = 0; i &lt; width; i++) {
3109     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 6;
3110     U = GST_READ_UINT16_LE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
3111     V = GST_READ_UINT16_LE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
3112 
3113     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3114       Y |= (Y &gt;&gt; 10);
3115       U |= (U &gt;&gt; 10);
3116       V |= (V &gt;&gt; 10);
3117     }
3118 
3119     d[i * 4 + 0] = 0xffff;
3120     d[i * 4 + 1] = Y;
3121     d[i * 4 + 2] = U;
3122     d[i * 4 + 3] = V;
3123 
3124     if (x &amp; 1) {
3125       x = 0;
3126       su++;
3127       sv++;
<span class="line-added">3128     }</span>
3129   }
3130 }

3131 
3132 static void
3133 pack_I420_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3134     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3135     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3136     gint y, gint width)
3137 {
3138   int i;
3139   gint uv = GET_UV_420 (y, flags);
3140   guint16 *restrict dy = GET_Y_LINE (y);
3141   guint16 *restrict du = GET_U_LINE (uv);
3142   guint16 *restrict dv = GET_V_LINE (uv);
3143   guint16 Y0, Y1, U, V;
3144   const guint16 *restrict s = src;
3145 
3146   if (IS_CHROMA_LINE_420 (y, flags)) {
<span class="line-modified">3147     for (i = 0; i &lt; width - 1; i += 2) {</span>
<span class="line-modified">3148       Y0 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-modified">3149       Y1 = s[i * 4 + 5] &gt;&gt; 6;</span>
<span class="line-modified">3150       U = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-modified">3151       V = s[i * 4 + 3] &gt;&gt; 6;</span>
3152 
3153       GST_WRITE_UINT16_LE (dy + i + 0, Y0);
3154       GST_WRITE_UINT16_LE (dy + i + 1, Y1);
3155       GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3156       GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
<span class="line-modified">3157     }</span>
<span class="line-modified">3158     if (i == width - 1) {</span>
<span class="line-modified">3159       Y0 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-modified">3160       U = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-modified">3161       V = s[i * 4 + 3] &gt;&gt; 6;</span>
3162 
3163       GST_WRITE_UINT16_LE (dy + i, Y0);
3164       GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3165       GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
<span class="line-modified">3166     }</span>
3167   } else {
3168     for (i = 0; i &lt; width; i++) {
3169       Y0 = s[i * 4 + 1] &gt;&gt; 6;
3170       GST_WRITE_UINT16_LE (dy + i, Y0);
<span class="line-modified">3171     }</span>
3172   }
3173 }
3174 
3175 #define PACK_I420_10BE GST_VIDEO_FORMAT_AYUV64, unpack_I420_10BE, 1, pack_I420_10BE
3176 static void
3177 unpack_I420_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3178     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3179     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3180 {
3181   int i;
3182   gint uv = GET_UV_420 (y, flags);
3183   const guint16 *restrict sy = GET_Y_LINE (y);
3184   const guint16 *restrict su = GET_U_LINE (uv);
3185   const guint16 *restrict sv = GET_V_LINE (uv);
3186   guint16 *restrict d = dest, Y, U, V;
3187 
3188   sy += x;
3189   su += x &gt;&gt; 1;
3190   sv += x &gt;&gt; 1;
3191 
3192   for (i = 0; i &lt; width; i++) {
3193     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 6;
3194     U = GST_READ_UINT16_BE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
3195     V = GST_READ_UINT16_BE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
3196 
3197     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3198       Y |= (Y &gt;&gt; 10);
3199       U |= (U &gt;&gt; 10);
3200       V |= (V &gt;&gt; 10);
3201     }
3202 
3203     d[i * 4 + 0] = 0xffff;
3204     d[i * 4 + 1] = Y;
3205     d[i * 4 + 2] = U;
3206     d[i * 4 + 3] = V;
3207 
3208     if (x &amp; 1) {
3209       x = 0;
3210       su++;
3211       sv++;
<span class="line-added">3212     }</span>
3213   }
3214 }

3215 
3216 static void
3217 pack_I420_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3218     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3219     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3220     gint y, gint width)
3221 {
3222   int i;
3223   gint uv = GET_UV_420 (y, flags);
3224   guint16 *restrict dy = GET_Y_LINE (y);
3225   guint16 *restrict du = GET_U_LINE (uv);
3226   guint16 *restrict dv = GET_V_LINE (uv);
3227   guint16 Y0, Y1, U, V;
3228   const guint16 *restrict s = src;
3229 
3230   if (IS_CHROMA_LINE_420 (y, flags)) {
<span class="line-modified">3231     for (i = 0; i &lt; width - 1; i += 2) {</span>
<span class="line-modified">3232       Y0 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-modified">3233       Y1 = s[i * 4 + 5] &gt;&gt; 6;</span>
<span class="line-modified">3234       U = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-modified">3235       V = s[i * 4 + 3] &gt;&gt; 6;</span>
3236 
3237       GST_WRITE_UINT16_BE (dy + i + 0, Y0);
3238       GST_WRITE_UINT16_BE (dy + i + 1, Y1);
3239       GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3240       GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
<span class="line-modified">3241     }</span>
<span class="line-modified">3242     if (i == width - 1) {</span>
<span class="line-modified">3243       Y0 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-modified">3244       U = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-modified">3245       V = s[i * 4 + 3] &gt;&gt; 6;</span>
3246 
3247       GST_WRITE_UINT16_BE (dy + i, Y0);
3248       GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3249       GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
<span class="line-modified">3250     }</span>
3251   } else {
3252     for (i = 0; i &lt; width; i++) {
3253       Y0 = s[i * 4 + 1] &gt;&gt; 6;
3254       GST_WRITE_UINT16_BE (dy + i, Y0);
<span class="line-modified">3255     }</span>
3256   }
3257 }
3258 
3259 #define PACK_I422_10LE GST_VIDEO_FORMAT_AYUV64, unpack_I422_10LE, 1, pack_I422_10LE
3260 static void
3261 unpack_I422_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3262     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3263     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3264 {
3265   int i;
3266   const guint16 *restrict sy = GET_Y_LINE (y);
3267   const guint16 *restrict su = GET_U_LINE (y);
3268   const guint16 *restrict sv = GET_V_LINE (y);
3269   guint16 *restrict d = dest, Y, U, V;
3270 
3271   sy += x;
3272   su += x &gt;&gt; 1;
3273   sv += x &gt;&gt; 1;
3274 
3275   for (i = 0; i &lt; width; i++) {
3276     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 6;
3277     U = GST_READ_UINT16_LE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
3278     V = GST_READ_UINT16_LE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
3279 
3280     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3281       Y |= (Y &gt;&gt; 10);
3282       U |= (U &gt;&gt; 10);
3283       V |= (V &gt;&gt; 10);
3284     }
3285 
3286     d[i * 4 + 0] = 0xffff;
3287     d[i * 4 + 1] = Y;
3288     d[i * 4 + 2] = U;
3289     d[i * 4 + 3] = V;
3290 
3291     if (x &amp; 1) {
3292       x = 0;
3293       su++;
3294       sv++;
<span class="line-added">3295     }</span>
3296   }
3297 }

3298 
3299 static void
3300 pack_I422_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3301     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3302     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3303     gint y, gint width)
3304 {
3305   int i;
3306   guint16 *restrict dy = GET_Y_LINE (y);
3307   guint16 *restrict du = GET_U_LINE (y);
3308   guint16 *restrict dv = GET_V_LINE (y);
3309   guint16 Y0, Y1, U, V;
3310   const guint16 *restrict s = src;
3311 
3312   for (i = 0; i &lt; width - 1; i += 2) {
3313     Y0 = s[i * 4 + 1] &gt;&gt; 6;
3314     Y1 = s[i * 4 + 5] &gt;&gt; 6;
3315     U = s[i * 4 + 2] &gt;&gt; 6;
3316     V = s[i * 4 + 3] &gt;&gt; 6;
3317 
</pre>
<hr />
<pre>
3350   for (i = 0; i &lt; width; i++) {
3351     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 6;
3352     U = GST_READ_UINT16_BE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
3353     V = GST_READ_UINT16_BE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
3354 
3355     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3356       Y |= (Y &gt;&gt; 10);
3357       U |= (U &gt;&gt; 10);
3358       V |= (V &gt;&gt; 10);
3359     }
3360 
3361     d[i * 4 + 0] = 0xffff;
3362     d[i * 4 + 1] = Y;
3363     d[i * 4 + 2] = U;
3364     d[i * 4 + 3] = V;
3365 
3366     if (x &amp; 1) {
3367       x = 0;
3368       su++;
3369       sv++;
<span class="line-added">3370     }</span>
3371   }
3372 }

3373 
3374 static void
3375 pack_I422_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3376     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3377     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3378     gint y, gint width)
3379 {
3380   int i;
3381   guint16 *restrict dy = GET_Y_LINE (y);
3382   guint16 *restrict du = GET_U_LINE (y);
3383   guint16 *restrict dv = GET_V_LINE (y);
3384   guint16 Y0, Y1, U, V;
3385   const guint16 *restrict s = src;
3386 
3387   for (i = 0; i &lt; width - 1; i += 2) {
3388     Y0 = s[i * 4 + 1] &gt;&gt; 6;
3389     Y1 = s[i * 4 + 5] &gt;&gt; 6;
3390     U = s[i * 4 + 2] &gt;&gt; 6;
3391     V = s[i * 4 + 3] &gt;&gt; 6;
3392 
</pre>
<hr />
<pre>
5077         case 4:
5078           UV |= s[soff + 2] &gt;&gt; 6 &lt;&lt; 10;
5079           UV |= s[soff + 3] &gt;&gt; 6 &lt;&lt; 20;
5080           GST_WRITE_UINT32_LE (duv + i, UV);
5081           break;
5082         default:
5083           /* keep value */
5084           break;
5085       }
5086 
5087       soff += 4;
5088     }
5089 
5090     GST_WRITE_UINT32_LE (dy + i, Y);
5091 
5092     if (num_comps &lt; 3)
5093       GST_WRITE_UINT32_LE (duv + i, UV);
5094   }
5095 }
5096 
<span class="line-added">5097 #define PACK_NV12_10LE40 GST_VIDEO_FORMAT_AYUV64, unpack_NV12_10LE40, 1, pack_NV12_10LE40</span>
<span class="line-added">5098 static void</span>
<span class="line-added">5099 unpack_NV12_10LE40 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added">5100     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added">5101     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)</span>
<span class="line-added">5102 {</span>
<span class="line-added">5103   gint i;</span>
<span class="line-added">5104   gint uv = GET_UV_420 (y, flags);</span>
<span class="line-added">5105   guint16 *restrict d = dest;</span>
<span class="line-added">5106   const guint8 *restrict sy = GET_PLANE_LINE (0, y);</span>
<span class="line-added">5107   const guint8 *restrict suv = GET_PLANE_LINE (1, uv);</span>
<span class="line-added">5108   guint16 Y0 = 0, Y1 = 0, Yn = 0, Un = 0, Vn = 0;</span>
<span class="line-added">5109   guint32 UV = 0;</span>
<span class="line-added">5110 </span>
<span class="line-added">5111   for (i = 0; i &lt; width; i++) {</span>
<span class="line-added">5112     gboolean update_c = FALSE;</span>
<span class="line-added">5113 </span>
<span class="line-added">5114     switch (i &amp; 3) {</span>
<span class="line-added">5115       case 0:</span>
<span class="line-added">5116         Y0 = GST_READ_UINT16_LE (sy);</span>
<span class="line-added">5117         Yn = Y0 &amp; 0x3ff;</span>
<span class="line-added">5118         sy += 2;</span>
<span class="line-added">5119 </span>
<span class="line-added">5120         UV = GST_READ_UINT32_LE (suv);</span>
<span class="line-added">5121         Un = UV &amp; 0x3ff;</span>
<span class="line-added">5122         Vn = (UV &gt;&gt; 10) &amp; 0x3ff;</span>
<span class="line-added">5123         suv += 4;</span>
<span class="line-added">5124 </span>
<span class="line-added">5125         Yn &lt;&lt;= 6;</span>
<span class="line-added">5126         Un &lt;&lt;= 6;</span>
<span class="line-added">5127         Vn &lt;&lt;= 6;</span>
<span class="line-added">5128         update_c = TRUE;</span>
<span class="line-added">5129         break;</span>
<span class="line-added">5130       case 1:</span>
<span class="line-added">5131         Y1 = GST_READ_UINT16_LE (sy);</span>
<span class="line-added">5132         Yn = (Y0 &gt;&gt; 10) | ((Y1 &amp; 0xf) &lt;&lt; 6);</span>
<span class="line-added">5133         sy += 2;</span>
<span class="line-added">5134 </span>
<span class="line-added">5135         Yn &lt;&lt;= 6;</span>
<span class="line-added">5136         break;</span>
<span class="line-added">5137       case 2:</span>
<span class="line-added">5138         Yn = (Y1 &gt;&gt; 4) &amp; 0x3ff;</span>
<span class="line-added">5139 </span>
<span class="line-added">5140         Un = (UV &gt;&gt; 20) &amp; 0x3ff;</span>
<span class="line-added">5141         Vn = (UV &gt;&gt; 30);</span>
<span class="line-added">5142         UV = GST_READ_UINT8 (suv);</span>
<span class="line-added">5143         Vn |= (UV &lt;&lt; 2);</span>
<span class="line-added">5144         suv++;</span>
<span class="line-added">5145 </span>
<span class="line-added">5146         Yn &lt;&lt;= 6;</span>
<span class="line-added">5147         Un &lt;&lt;= 6;</span>
<span class="line-added">5148         Vn &lt;&lt;= 6;</span>
<span class="line-added">5149         update_c = TRUE;</span>
<span class="line-added">5150         break;</span>
<span class="line-added">5151       case 3:</span>
<span class="line-added">5152         Y0 = GST_READ_UINT8 (sy);</span>
<span class="line-added">5153         Yn = (Y1 &gt;&gt; 14) | (Y0 &lt;&lt; 2);</span>
<span class="line-added">5154         sy++;</span>
<span class="line-added">5155 </span>
<span class="line-added">5156         Yn &lt;&lt;= 6;</span>
<span class="line-added">5157         break;</span>
<span class="line-added">5158     }</span>
<span class="line-added">5159 </span>
<span class="line-added">5160     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {</span>
<span class="line-added">5161       Yn |= Yn &gt;&gt; 10;</span>
<span class="line-added">5162       if (update_c) {</span>
<span class="line-added">5163         Un |= Un &gt;&gt; 10;</span>
<span class="line-added">5164         Vn |= Vn &gt;&gt; 10;</span>
<span class="line-added">5165       }</span>
<span class="line-added">5166     }</span>
<span class="line-added">5167 </span>
<span class="line-added">5168     d[i * 4 + 0] = 0xffff;</span>
<span class="line-added">5169     d[i * 4 + 1] = Yn;</span>
<span class="line-added">5170     d[i * 4 + 2] = Un;</span>
<span class="line-added">5171     d[i * 4 + 3] = Vn;</span>
<span class="line-added">5172   }</span>
<span class="line-added">5173 }</span>
<span class="line-added">5174 </span>
<span class="line-added">5175 static void</span>
<span class="line-added">5176 pack_NV12_10LE40 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added">5177     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added">5178     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,</span>
<span class="line-added">5179     gint y, gint width)</span>
<span class="line-added">5180 {</span>
<span class="line-added">5181   gint i;</span>
<span class="line-added">5182   gint uv = GET_UV_420 (y, flags);</span>
<span class="line-added">5183   guint8 *restrict dy = GET_PLANE_LINE (0, y);</span>
<span class="line-added">5184   guint8 *restrict duv = GET_PLANE_LINE (1, uv);</span>
<span class="line-added">5185   guint16 Y0 = 0, Y1 = 0, Y2 = 0, Y3 = 0, U0, V0 = 0, U1 = 0, V1 = 0;</span>
<span class="line-added">5186   const guint16 *restrict s = src;</span>
<span class="line-added">5187 </span>
<span class="line-added">5188   for (i = 0; i &lt; width; i++) {</span>
<span class="line-added">5189     switch (i &amp; 3) {</span>
<span class="line-added">5190       case 0:</span>
<span class="line-added">5191         Y0 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-added">5192         GST_WRITE_UINT8 (dy, Y0 &amp; 0xff);</span>
<span class="line-added">5193         dy++;</span>
<span class="line-added">5194 </span>
<span class="line-added">5195         if (IS_CHROMA_LINE_420 (y, flags)) {</span>
<span class="line-added">5196           U0 = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-added">5197           V0 = s[i * 4 + 3] &gt;&gt; 6;</span>
<span class="line-added">5198 </span>
<span class="line-added">5199           GST_WRITE_UINT8 (duv, U0 &amp; 0xff);</span>
<span class="line-added">5200           duv++;</span>
<span class="line-added">5201 </span>
<span class="line-added">5202           GST_WRITE_UINT8 (duv, (U0 &gt;&gt; 8) | ((V0 &amp; 0x3f) &lt;&lt; 2));</span>
<span class="line-added">5203           duv++;</span>
<span class="line-added">5204         }</span>
<span class="line-added">5205         break;</span>
<span class="line-added">5206       case 1:</span>
<span class="line-added">5207         Y1 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-added">5208         GST_WRITE_UINT8 (dy, (Y0 &gt;&gt; 8) | ((Y1 &amp; 0x3f) &lt;&lt; 2));</span>
<span class="line-added">5209         dy++;</span>
<span class="line-added">5210         break;</span>
<span class="line-added">5211       case 2:</span>
<span class="line-added">5212         Y2 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-added">5213         GST_WRITE_UINT8 (dy, (Y1 &gt;&gt; 6) | ((Y2 &amp; 0xf) &lt;&lt; 4));</span>
<span class="line-added">5214         dy++;</span>
<span class="line-added">5215 </span>
<span class="line-added">5216         if (IS_CHROMA_LINE_420 (y, flags)) {</span>
<span class="line-added">5217           U1 = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-added">5218           V1 = s[i * 4 + 3] &gt;&gt; 6;</span>
<span class="line-added">5219 </span>
<span class="line-added">5220           GST_WRITE_UINT8 (duv, (V0 &gt;&gt; 6) | ((U1 &amp; 0xf) &lt;&lt; 4));</span>
<span class="line-added">5221           duv++;</span>
<span class="line-added">5222 </span>
<span class="line-added">5223           GST_WRITE_UINT8 (duv, (U1 &gt;&gt; 4) | ((V1 &amp; 0x3) &lt;&lt; 6));</span>
<span class="line-added">5224           duv++;</span>
<span class="line-added">5225 </span>
<span class="line-added">5226           GST_WRITE_UINT8 (duv, V1 &gt;&gt; 2);</span>
<span class="line-added">5227           duv++;</span>
<span class="line-added">5228         }</span>
<span class="line-added">5229         break;</span>
<span class="line-added">5230       case 3:</span>
<span class="line-added">5231         Y3 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-added">5232         GST_WRITE_UINT8 (dy, (Y2 &gt;&gt; 4) | ((Y3 &amp; 0x3) &lt;&lt; 6));</span>
<span class="line-added">5233         dy++;</span>
<span class="line-added">5234         GST_WRITE_UINT8 (dy, (Y3 &gt;&gt; 2));</span>
<span class="line-added">5235         dy++;</span>
<span class="line-added">5236         break;</span>
<span class="line-added">5237     }</span>
<span class="line-added">5238   }</span>
<span class="line-added">5239 </span>
<span class="line-added">5240   switch (width &amp; 3) {</span>
<span class="line-added">5241     case 0:</span>
<span class="line-added">5242       break;</span>
<span class="line-added">5243     case 1:</span>
<span class="line-added">5244       GST_WRITE_UINT8 (dy, Y0 &gt;&gt; 8);</span>
<span class="line-added">5245       if (IS_CHROMA_LINE_420 (y, flags))</span>
<span class="line-added">5246         GST_WRITE_UINT8 (duv, V0 &gt;&gt; 6);</span>
<span class="line-added">5247       break;</span>
<span class="line-added">5248     case 2:</span>
<span class="line-added">5249       GST_WRITE_UINT8 (dy, Y1 &gt;&gt; 6);</span>
<span class="line-added">5250       if (IS_CHROMA_LINE_420 (y, flags))</span>
<span class="line-added">5251         GST_WRITE_UINT8 (duv, V0 &gt;&gt; 6);</span>
<span class="line-added">5252       break;</span>
<span class="line-added">5253     case 3:</span>
<span class="line-added">5254       GST_WRITE_UINT8 (dy, Y2 &gt;&gt; 4);</span>
<span class="line-added">5255       break;</span>
<span class="line-added">5256   }</span>
<span class="line-added">5257 }</span>
<span class="line-added">5258 </span>
<span class="line-added">5259 #define PACK_VUYA GST_VIDEO_FORMAT_AYUV, unpack_VUYA, 1, pack_VUYA</span>
<span class="line-added">5260 static void</span>
<span class="line-added">5261 unpack_VUYA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added">5262     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added">5263     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)</span>
<span class="line-added">5264 {</span>
<span class="line-added">5265   const guint8 *restrict s = GET_LINE (y);</span>
<span class="line-added">5266   guint8 *restrict d = dest;</span>
<span class="line-added">5267 </span>
<span class="line-added">5268   s += x * 4;</span>
<span class="line-added">5269 </span>
<span class="line-added">5270   video_orc_unpack_VUYA (d, s, width);</span>
<span class="line-added">5271 }</span>
<span class="line-added">5272 </span>
<span class="line-added">5273 static void</span>
<span class="line-added">5274 pack_VUYA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added">5275     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added">5276     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,</span>
<span class="line-added">5277     gint y, gint width)</span>
<span class="line-added">5278 {</span>
<span class="line-added">5279   const guint8 *restrict s = src;</span>
<span class="line-added">5280   guint8 *restrict d = GET_LINE (y);</span>
<span class="line-added">5281 </span>
<span class="line-added">5282   video_orc_pack_VUYA (d, s, width);</span>
<span class="line-added">5283 }</span>
<span class="line-added">5284 </span>
<span class="line-added">5285 #define PACK_BGR10A2_LE GST_VIDEO_FORMAT_ARGB64, unpack_bgr10a2_le, 1, pack_bgr10a2_le</span>
<span class="line-added">5286 static void</span>
<span class="line-added">5287 unpack_bgr10a2_le (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added">5288     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added">5289     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)</span>
<span class="line-added">5290 {</span>
<span class="line-added">5291   int i;</span>
<span class="line-added">5292   const guint8 *restrict s = GET_LINE (y);</span>
<span class="line-added">5293   guint16 *restrict d = dest;</span>
<span class="line-added">5294   guint32 ARGB;</span>
<span class="line-added">5295   guint16 A, R, G, B;</span>
<span class="line-added">5296 </span>
<span class="line-added">5297   s += x * 4;</span>
<span class="line-added">5298 </span>
<span class="line-added">5299   for (i = 0; i &lt; width; i++) {</span>
<span class="line-added">5300     ARGB = GST_READ_UINT32_LE (s + 4 * i);</span>
<span class="line-added">5301 </span>
<span class="line-added">5302     B = ((ARGB &gt;&gt; 0) &amp; 0x3ff) &lt;&lt; 6;</span>
<span class="line-added">5303     G = ((ARGB &gt;&gt; 10) &amp; 0x3ff) &lt;&lt; 6;</span>
<span class="line-added">5304     R = ((ARGB &gt;&gt; 20) &amp; 0x3ff) &lt;&lt; 6;</span>
<span class="line-added">5305     A = ((ARGB &gt;&gt; 30) &amp; 0x03) &lt;&lt; 14;</span>
<span class="line-added">5306 </span>
<span class="line-added">5307     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {</span>
<span class="line-added">5308       B |= (B &gt;&gt; 10);</span>
<span class="line-added">5309       G |= (G &gt;&gt; 10);</span>
<span class="line-added">5310       R |= (R &gt;&gt; 10);</span>
<span class="line-added">5311       A |= (A &gt;&gt; 10);</span>
<span class="line-added">5312     }</span>
<span class="line-added">5313 </span>
<span class="line-added">5314     d[4 * i + 0] = A;</span>
<span class="line-added">5315     d[4 * i + 1] = R;</span>
<span class="line-added">5316     d[4 * i + 2] = G;</span>
<span class="line-added">5317     d[4 * i + 3] = B;</span>
<span class="line-added">5318   }</span>
<span class="line-added">5319 }</span>
<span class="line-added">5320 </span>
<span class="line-added">5321 static void</span>
<span class="line-added">5322 pack_bgr10a2_le (const GstVideoFormatInfo * info, GstVideoPackFlags flags,</span>
<span class="line-added">5323     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],</span>
<span class="line-added">5324     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,</span>
<span class="line-added">5325     gint y, gint width)</span>
<span class="line-added">5326 {</span>
<span class="line-added">5327   int i;</span>
<span class="line-added">5328   guint32 *restrict d = GET_LINE (y);</span>
<span class="line-added">5329   const guint16 *restrict s = src;</span>
<span class="line-added">5330   guint32 ARGB;</span>
<span class="line-added">5331   guint16 A, R, G, B;</span>
<span class="line-added">5332 </span>
<span class="line-added">5333   for (i = 0; i &lt; width; i++) {</span>
<span class="line-added">5334     A = s[4 * i] &amp; 0xc000;</span>
<span class="line-added">5335     R = s[4 * i + 1] &amp; 0xffc0;</span>
<span class="line-added">5336     G = s[4 * i + 2] &amp; 0xffc0;</span>
<span class="line-added">5337     B = s[4 * i + 3] &amp; 0xffc0;</span>
<span class="line-added">5338 </span>
<span class="line-added">5339     ARGB = (B &gt;&gt; 6) | (G &lt;&lt; 4) | (R &lt;&lt; 14) | (A &lt;&lt; 16);</span>
<span class="line-added">5340 </span>
<span class="line-added">5341     GST_WRITE_UINT32_LE (d + i, ARGB);</span>
<span class="line-added">5342   }</span>
<span class="line-added">5343 }</span>
5344 
5345 typedef struct
5346 {
5347   guint32 fourcc;
5348   GstVideoFormatInfo info;
5349 } VideoFormat;
5350 
5351 /* depths: bits, n_components, shift, depth */
5352 #define DPTH0            0, 0, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }
5353 #define DPTH8            8, 1, { 0, 0, 0, 0 }, { 8, 0, 0, 0 }
5354 #define DPTH8_32         8, 2, { 0, 0, 0, 0 }, { 8, 32, 0, 0 }
5355 #define DPTH888          8, 3, { 0, 0, 0, 0 }, { 8, 8, 8, 0 }
5356 #define DPTH8888         8, 4, { 0, 0, 0, 0 }, { 8, 8, 8, 8 }
5357 #define DPTH8880         8, 4, { 0, 0, 0, 0 }, { 8, 8, 8, 0 }
5358 #define DPTH10           10, 1, { 0, 0, 0, 0 }, { 10, 0, 0, 0 }
5359 #define DPTH10_10_10     10, 3, { 0, 0, 0, 0 }, { 10, 10, 10, 0 }
5360 #define DPTH10_10_10_10  10, 4, { 0, 0, 0, 0 }, { 10, 10, 10, 10 }
5361 #define DPTH10_10_10_HI  16, 3, { 6, 6, 6, 0 }, { 10, 10, 10, 0 }
<span class="line-added">5362 #define DPTH10_10_10_2   10, 4, { 0, 0, 0, 0 }, { 10, 10, 10, 2}</span>
5363 #define DPTH12_12_12     12, 3, { 0, 0, 0, 0 }, { 12, 12, 12, 0 }
5364 #define DPTH12_12_12_12  12, 4, { 0, 0, 0, 0 }, { 12, 12, 12, 12 }
5365 #define DPTH16           16, 1, { 0, 0, 0, 0 }, { 16, 0, 0, 0 }
5366 #define DPTH16_16_16     16, 3, { 0, 0, 0, 0 }, { 16, 16, 16, 0 }
5367 #define DPTH16_16_16_16  16, 4, { 0, 0, 0, 0 }, { 16, 16, 16, 16 }
5368 #define DPTH555          16, 3, { 10, 5, 0, 0 }, { 5, 5, 5, 0 }
5369 #define DPTH565          16, 3, { 11, 5, 0, 0 }, { 5, 6, 5, 0 }
5370 
5371 /* pixel strides */
5372 #define PSTR0             { 0, 0, 0, 0 }
5373 #define PSTR1             { 1, 0, 0, 0 }
5374 #define PSTR14            { 1, 4, 0, 0 }
5375 #define PSTR111           { 1, 1, 1, 0 }
5376 #define PSTR1111          { 1, 1, 1, 1 }
5377 #define PSTR122           { 1, 2, 2, 0 }
5378 #define PSTR2             { 2, 0, 0, 0 }
5379 #define PSTR222           { 2, 2, 2, 0 }
5380 #define PSTR2222          { 2, 2, 2, 2 }
5381 #define PSTR244           { 2, 4, 4, 0 }
5382 #define PSTR444           { 4, 4, 4, 0 }
</pre>
<hr />
<pre>
5613   MAKE_YUVA_FORMAT (A422_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5614       PSTR2222, PLANE0123, OFFS0, SUB4224, PACK_A422_10BE),
5615   MAKE_YUVA_LE_FORMAT (A422_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5616       PSTR2222, PLANE0123, OFFS0, SUB4224, PACK_A422_10LE),
5617   MAKE_YUVA_FORMAT (A444_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5618       PSTR2222, PLANE0123, OFFS0, SUB4444, PACK_A444_10BE),
5619   MAKE_YUVA_LE_FORMAT (A444_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5620       PSTR2222, PLANE0123, OFFS0, SUB4444, PACK_A444_10LE),
5621   MAKE_YUV_FORMAT (NV61, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;6&#39;, &#39;1&#39;),
5622       DPTH888, PSTR122, PLANE011, OFFS010, SUB422, PACK_NV61),
5623   MAKE_YUV_FORMAT (P010_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_HI,
5624       PSTR244, PLANE011, OFFS001, SUB420, PACK_P010_10BE),
5625   MAKE_YUV_LE_FORMAT (P010_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_HI,
5626       PSTR244, PLANE011, OFFS001, SUB420, PACK_P010_10LE),
5627   MAKE_YUV_FORMAT (IYU2, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;I&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;2&#39;),
5628       DPTH888, PSTR333, PLANE0, OFFS102, SUB444, PACK_IYU2),
5629   MAKE_YUV_FORMAT (VYUY, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;V&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;Y&#39;),
5630       DPTH888, PSTR244, PLANE0, OFFS102, SUB422, PACK_VYUY),
5631   MAKE_RGBA_FORMAT (GBRA, &quot;raw video&quot;, DPTH8888, PSTR1111, PLANE2013,
5632       OFFS0, SUB4444, PACK_GBRA),
<span class="line-modified">5633   MAKE_RGBA_FORMAT (GBRA_10BE, &quot;raw video&quot;, DPTH10_10_10_10, PSTR2222,</span>
<span class="line-modified">5634       PLANE2013, OFFS0, SUB4444, PACK_GBRA_10BE),</span>
<span class="line-modified">5635   MAKE_RGBA_LE_FORMAT (GBRA_10LE, &quot;raw video&quot;, DPTH10_10_10_10, PSTR2222,</span>
<span class="line-modified">5636       PLANE2013, OFFS0, SUB4444, PACK_GBRA_10LE),</span>

5637   MAKE_RGB_FORMAT (GBR_12BE, &quot;raw video&quot;, DPTH12_12_12, PSTR222, PLANE201,
5638       OFFS0, SUB444, PACK_GBR_12BE),
5639   MAKE_RGB_LE_FORMAT (GBR_12LE, &quot;raw video&quot;, DPTH12_12_12, PSTR222, PLANE201,
5640       OFFS0, SUB444, PACK_GBR_12LE),
<span class="line-modified">5641   MAKE_RGBA_FORMAT (GBRA_12BE, &quot;raw video&quot;, DPTH12_12_12_12, PSTR2222,</span>
<span class="line-modified">5642       PLANE2013, OFFS0, SUB4444, PACK_GBRA_12BE),</span>
<span class="line-modified">5643   MAKE_RGBA_LE_PACK_FORMAT (GBRA_12LE, &quot;raw video&quot;, DPTH12_12_12_12, PSTR2222,</span>
5644       PLANE2013, OFFS0, SUB4444, PACK_GBRA_12LE),
5645   MAKE_YUV_FORMAT (I420_12BE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5646       PSTR222, PLANE012, OFFS0, SUB420, PACK_I420_12BE),
5647   MAKE_YUV_LE_FORMAT (I420_12LE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5648       PSTR222, PLANE012, OFFS0, SUB420, PACK_I420_12LE),
5649   MAKE_YUV_FORMAT (I422_12BE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5650       PSTR222, PLANE012, OFFS0, SUB422, PACK_I422_12BE),
5651   MAKE_YUV_LE_FORMAT (I422_12LE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5652       PSTR222, PLANE012, OFFS0, SUB422, PACK_I422_12LE),
5653   MAKE_YUV_FORMAT (Y444_12BE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5654       PSTR222, PLANE012, OFFS0, SUB444, PACK_Y444_12BE),
5655   MAKE_YUV_LE_FORMAT (Y444_12LE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5656       PSTR222, PLANE012, OFFS0, SUB444, PACK_Y444_12LE),
5657   MAKE_GRAY_C_LE_FORMAT (GRAY10_LE32, &quot;raw video&quot;, DPTH10, PSTR0, PLANE0, OFFS0,
5658       SUB4, PACK_GRAY10_LE32),
5659   MAKE_YUV_C_LE_FORMAT (NV12_10LE32, &quot;raw video&quot;,
5660       GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;1&#39;, &#39;5&#39;), DPTH10_10_10, PSTR0, PLANE011,
5661       OFFS001, SUB420, PACK_NV12_10LE32),
5662   MAKE_YUV_C_LE_FORMAT (NV16_10LE32, &quot;raw video&quot;,
5663       GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;2&#39;, &#39;0&#39;), DPTH10_10_10, PSTR0, PLANE011,
5664       OFFS001, SUB422, PACK_NV16_10LE32),
<span class="line-added">5665   MAKE_YUV_C_LE_FORMAT (NV12_10LE40, &quot;raw video&quot;,</span>
<span class="line-added">5666       GST_MAKE_FOURCC (&#39;R&#39;, &#39;K&#39;, &#39;2&#39;, &#39;0&#39;), DPTH10_10_10, PSTR0, PLANE011,</span>
<span class="line-added">5667       OFFS0, SUB420, PACK_NV12_10LE40),</span>
<span class="line-added">5668   MAKE_YUV_FORMAT (Y210, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;2&#39;, &#39;1&#39;, &#39;0&#39;),</span>
<span class="line-added">5669       DPTH10_10_10, PSTR488, PLANE0, OFFS0, SUB422, PACK_Y210),</span>
<span class="line-added">5670   MAKE_YUV_FORMAT (Y410, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;1&#39;, &#39;0&#39;),</span>
<span class="line-added">5671       DPTH10_10_10_2, PSTR0, PLANE0, OFFS0, SUB4444, PACK_Y410),</span>
<span class="line-added">5672   MAKE_YUVA_PACK_FORMAT (VUYA, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;V&#39;, &#39;U&#39;, &#39;Y&#39;,</span>
<span class="line-added">5673           &#39;A&#39;), DPTH8888, PSTR4444, PLANE0, OFFS2103, SUB4444, PACK_VUYA),</span>
<span class="line-added">5674   MAKE_RGBA_LE_PACK_FORMAT (BGR10A2_LE, &quot;raw video&quot;, DPTH10_10_10_2, PSTR4444,</span>
<span class="line-added">5675       PLANE0,</span>
<span class="line-added">5676       OFFS0, SUB4444, PACK_BGR10A2_LE),</span>
5677 };
5678 
5679 static GstVideoFormat
5680 gst_video_format_from_rgb32_masks (int red_mask, int green_mask, int blue_mask)
5681 {
5682   if (red_mask == 0xff000000 &amp;&amp; green_mask == 0x00ff0000 &amp;&amp;
5683       blue_mask == 0x0000ff00) {
5684     return GST_VIDEO_FORMAT_RGBx;
5685   }
5686   if (red_mask == 0x0000ff00 &amp;&amp; green_mask == 0x00ff0000 &amp;&amp;
5687       blue_mask == 0xff000000) {
5688     return GST_VIDEO_FORMAT_BGRx;
5689   }
5690   if (red_mask == 0x00ff0000 &amp;&amp; green_mask == 0x0000ff00 &amp;&amp;
5691       blue_mask == 0x000000ff) {
5692     return GST_VIDEO_FORMAT_xRGB;
5693   }
5694   if (red_mask == 0x000000ff &amp;&amp; green_mask == 0x0000ff00 &amp;&amp;
5695       blue_mask == 0x00ff0000) {
5696     return GST_VIDEO_FORMAT_xBGR;
</pre>
<hr />
<pre>
5775  * @bpp: the amount of bits used to store a pixel. This value is bigger than
5776  *   @depth
5777  * @endianness: the endianness of the masks, #G_LITTLE_ENDIAN or #G_BIG_ENDIAN
5778  * @red_mask: the red mask
5779  * @green_mask: the green mask
5780  * @blue_mask: the blue mask
5781  * @alpha_mask: the alpha mask, or 0 if no alpha mask
5782  *
5783  * Find the #GstVideoFormat for the given parameters.
5784  *
5785  * Returns: a #GstVideoFormat or GST_VIDEO_FORMAT_UNKNOWN when the parameters to
5786  * not specify a known format.
5787  */
5788 GstVideoFormat
5789 gst_video_format_from_masks (gint depth, gint bpp, gint endianness,
5790     guint red_mask, guint green_mask, guint blue_mask, guint alpha_mask)
5791 {
5792   GstVideoFormat format;
5793 
5794   /* our caps system handles 24/32bpp RGB as big-endian. */
<span class="line-modified">5795   if ((bpp == 24 || bpp == 32) &amp;&amp; endianness == G_LITTLE_ENDIAN &amp;&amp;</span>
<span class="line-added">5796       alpha_mask != 0xc0000000) {</span>
5797     red_mask = GUINT32_TO_BE (red_mask);
5798     green_mask = GUINT32_TO_BE (green_mask);
5799     blue_mask = GUINT32_TO_BE (blue_mask);
5800     alpha_mask = GUINT32_TO_BE (alpha_mask);
5801     endianness = G_BIG_ENDIAN;
5802     if (bpp == 24) {
5803       red_mask &gt;&gt;= 8;
5804       green_mask &gt;&gt;= 8;
5805       blue_mask &gt;&gt;= 8;
5806     }
5807   }
5808 
<span class="line-modified">5809   if (depth == 32 &amp;&amp; bpp == 32 &amp;&amp; alpha_mask == 0xc0000000 &amp;&amp;</span>
<span class="line-added">5810       endianness == G_LITTLE_ENDIAN) {</span>
<span class="line-added">5811     format = GST_VIDEO_FORMAT_BGR10A2_LE;</span>
<span class="line-added">5812   } else if (depth == 30 &amp;&amp; bpp == 32) {</span>
5813     format = GST_VIDEO_FORMAT_r210;
5814   } else if (depth == 24 &amp;&amp; bpp == 32) {
5815     format = gst_video_format_from_rgb32_masks (red_mask, green_mask,
5816         blue_mask);
5817   } else if (depth == 32 &amp;&amp; bpp == 32 &amp;&amp; alpha_mask) {
5818     format = gst_video_format_from_rgba32_masks (red_mask, green_mask,
5819         blue_mask, alpha_mask);
5820   } else if (depth == 24 &amp;&amp; bpp == 24) {
5821     format = gst_video_format_from_rgb24_masks (red_mask, green_mask,
5822         blue_mask);
5823   } else if ((depth == 15 || depth == 16) &amp;&amp; bpp == 16 &amp;&amp;
5824       endianness == G_BYTE_ORDER) {
5825     format = gst_video_format_from_rgb16_masks (red_mask, green_mask,
5826         blue_mask);
5827   } else if (depth == 8 &amp;&amp; bpp == 8) {
5828     format = GST_VIDEO_FORMAT_RGB8P;
5829   } else if (depth == 64 &amp;&amp; bpp == 64) {
5830     format = gst_video_format_from_rgba32_masks (red_mask, green_mask,
5831         blue_mask, alpha_mask);
5832     if (format == GST_VIDEO_FORMAT_ARGB) {
</pre>
<hr />
<pre>
5861     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;U&#39;, &#39;Y&#39;, &#39;2&#39;):
5862       return GST_VIDEO_FORMAT_YUY2;
5863     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;V&#39;, &#39;Y&#39;, &#39;U&#39;):
5864       return GST_VIDEO_FORMAT_YVYU;
5865     case GST_MAKE_FOURCC (&#39;U&#39;, &#39;Y&#39;, &#39;V&#39;, &#39;Y&#39;):
5866       return GST_VIDEO_FORMAT_UYVY;
5867     case GST_MAKE_FOURCC (&#39;V&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;Y&#39;):
5868       return GST_VIDEO_FORMAT_VYUY;
5869     case GST_MAKE_FOURCC (&#39;A&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;V&#39;):
5870       return GST_VIDEO_FORMAT_AYUV;
5871     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;1&#39;, &#39;B&#39;):
5872       return GST_VIDEO_FORMAT_Y41B;
5873     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;2&#39;, &#39;B&#39;):
5874       return GST_VIDEO_FORMAT_Y42B;
5875     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;):
5876       return GST_VIDEO_FORMAT_Y444;
5877     case GST_MAKE_FOURCC (&#39;v&#39;, &#39;2&#39;, &#39;1&#39;, &#39;0&#39;):
5878       return GST_VIDEO_FORMAT_v210;
5879     case GST_MAKE_FOURCC (&#39;v&#39;, &#39;2&#39;, &#39;1&#39;, &#39;6&#39;):
5880       return GST_VIDEO_FORMAT_v216;
<span class="line-added">5881     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;2&#39;, &#39;1&#39;, &#39;0&#39;):</span>
<span class="line-added">5882       return GST_VIDEO_FORMAT_Y210;</span>
5883     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;1&#39;, &#39;2&#39;):
5884       return GST_VIDEO_FORMAT_NV12;
5885     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;2&#39;, &#39;1&#39;):
5886       return GST_VIDEO_FORMAT_NV21;
5887     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;1&#39;, &#39;6&#39;):
5888       return GST_VIDEO_FORMAT_NV16;
5889     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;6&#39;, &#39;1&#39;):
5890       return GST_VIDEO_FORMAT_NV61;
5891     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;2&#39;, &#39;4&#39;):
5892       return GST_VIDEO_FORMAT_NV24;
5893     case GST_MAKE_FOURCC (&#39;v&#39;, &#39;3&#39;, &#39;0&#39;, &#39;8&#39;):
5894       return GST_VIDEO_FORMAT_v308;
5895     case GST_MAKE_FOURCC (&#39;I&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;2&#39;):
5896       return GST_VIDEO_FORMAT_IYU2;
5897     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;8&#39;, &#39;0&#39;, &#39;0&#39;):
5898     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;8&#39;, &#39; &#39;, &#39; &#39;):
5899     case GST_MAKE_FOURCC (&#39;G&#39;, &#39;R&#39;, &#39;E&#39;, &#39;Y&#39;):
5900       return GST_VIDEO_FORMAT_GRAY8;
5901     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;1&#39;, &#39;6&#39;, &#39; &#39;):
5902       return GST_VIDEO_FORMAT_GRAY16_LE;
5903     case GST_MAKE_FOURCC (&#39;U&#39;, &#39;Y&#39;, &#39;V&#39;, &#39;P&#39;):
5904       return GST_VIDEO_FORMAT_UYVP;
5905     case GST_MAKE_FOURCC (&#39;A&#39;, &#39;4&#39;, &#39;2&#39;, &#39;0&#39;):
5906       return GST_VIDEO_FORMAT_A420;
5907     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;U&#39;, &#39;V&#39;, &#39;9&#39;):
5908       return GST_VIDEO_FORMAT_YUV9;
5909     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;V&#39;, &#39;U&#39;, &#39;9&#39;):
5910       return GST_VIDEO_FORMAT_YVU9;
5911     case GST_MAKE_FOURCC (&#39;I&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;1&#39;):
5912       return GST_VIDEO_FORMAT_IYU1;
5913     case GST_MAKE_FOURCC (&#39;A&#39;, &#39;Y&#39;, &#39;6&#39;, &#39;4&#39;):
5914       return GST_VIDEO_FORMAT_AYUV64;
5915     case GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;1&#39;, &#39;0&#39;):
5916       return GST_VIDEO_FORMAT_GRAY10_LE32;
5917     case GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;1&#39;, &#39;5&#39;):
5918       return GST_VIDEO_FORMAT_NV12_10LE32;
5919     case GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;2&#39;, &#39;0&#39;):
5920       return GST_VIDEO_FORMAT_NV16_10LE32;
<span class="line-added">5921     case GST_MAKE_FOURCC (&#39;R&#39;, &#39;K&#39;, &#39;2&#39;, &#39;0&#39;):</span>
<span class="line-added">5922       return GST_VIDEO_FORMAT_NV12_10LE40;</span>
<span class="line-added">5923     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;1&#39;, &#39;0&#39;):</span>
<span class="line-added">5924       return GST_VIDEO_FORMAT_Y410;</span>
<span class="line-added">5925     case GST_MAKE_FOURCC (&#39;V&#39;, &#39;U&#39;, &#39;Y&#39;, &#39;A&#39;):</span>
<span class="line-added">5926       return GST_VIDEO_FORMAT_VUYA;</span>
<span class="line-added">5927     case GST_MAKE_FOURCC (&#39;A&#39;, &#39;R&#39;, &#39;3&#39;, &#39;0&#39;):</span>
<span class="line-added">5928       return GST_VIDEO_FORMAT_BGR10A2_LE;</span>
<span class="line-added">5929 </span>
5930     default:
5931       return GST_VIDEO_FORMAT_UNKNOWN;
5932   }
5933 }
5934 
5935 /**
5936  * gst_video_format_from_string:
5937  * @format: a format string
5938  *
5939  * Convert the @format string to its #GstVideoFormat.
5940  *
5941  * Returns: the #GstVideoFormat for @format or GST_VIDEO_FORMAT_UNKNOWN when the
5942  * string is not a known format.
5943  */
5944 GstVideoFormat
5945 gst_video_format_from_string (const gchar * format)
5946 {
5947   guint i;
5948 
5949   g_return_val_if_fail (format != NULL, GST_VIDEO_FORMAT_UNKNOWN);
</pre>
</td>
</tr>
</table>
<center><a href="video-event.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="video-format.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>