<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudioencoder.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 2011 Mark Nauwelaerts &lt;mark.nauwelaerts@collabora.co.uk&gt;.
   3  * Copyright (C) 2011 Nokia Corporation. All rights reserved.
   4  *   Contact: Stefan Kost &lt;stefan.kost@nokia.com&gt;
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 /**
  23  * SECTION:gstaudioencoder
  24  * @title: GstAudioEncoder
  25  * @short_description: Base class for audio encoders
  26  * @see_also: #GstBaseTransform
  27  *
  28  * This base class is for audio encoders turning raw audio samples into
  29  * encoded audio data.
  30  *
  31  * GstAudioEncoder and subclass should cooperate as follows.
  32  *
  33  * ## Configuration
  34  *
  35  *   * Initially, GstAudioEncoder calls @start when the encoder element
  36  *     is activated, which allows subclass to perform any global setup.
  37  *
  38  *   * GstAudioEncoder calls @set_format to inform subclass of the format
  39  *     of input audio data that it is about to receive.  Subclass should
  40  *     setup for encoding and configure various base class parameters
  41  *     appropriately, notably those directing desired input data handling.
  42  *     While unlikely, it might be called more than once, if changing input
  43  *     parameters require reconfiguration.
  44  *
  45  *   * GstAudioEncoder calls @stop at end of all processing.
  46  *
  47  * As of configuration stage, and throughout processing, GstAudioEncoder
  48  * maintains various parameters that provide required context,
  49  * e.g. describing the format of input audio data.
  50  * Conversely, subclass can and should configure these context parameters
  51  * to inform base class of its expectation w.r.t. buffer handling.
  52  *
  53  * ## Data processing
  54  *
  55  *     * Base class gathers input sample data (as directed by the context&#39;s
  56  *       frame_samples and frame_max) and provides this to subclass&#39; @handle_frame.
  57  *     * If codec processing results in encoded data, subclass should call
  58  *       gst_audio_encoder_finish_frame() to have encoded data pushed
  59  *       downstream. Alternatively, it might also call
  60  *       gst_audio_encoder_finish_frame() (with a NULL buffer and some number of
  61  *       dropped samples) to indicate dropped (non-encoded) samples.
  62  *     * Just prior to actually pushing a buffer downstream,
  63  *       it is passed to @pre_push.
  64  *     * During the parsing process GstAudioEncoderClass will handle both
  65  *       srcpad and sinkpad events. Sink events will be passed to subclass
  66  *       if @event callback has been provided.
  67  *
  68  * ## Shutdown phase
  69  *
  70  *   * GstAudioEncoder class calls @stop to inform the subclass that data
  71  *     parsing will be stopped.
  72  *
  73  * Subclass is responsible for providing pad template caps for
  74  * source and sink pads. The pads need to be named &quot;sink&quot; and &quot;src&quot;. It also
  75  * needs to set the fixed caps on srcpad, when the format is ensured.  This
  76  * is typically when base class calls subclass&#39; @set_format function, though
  77  * it might be delayed until calling @gst_audio_encoder_finish_frame.
  78  *
  79  * In summary, above process should have subclass concentrating on
  80  * codec data processing while leaving other matters to base class,
  81  * such as most notably timestamp handling.  While it may exert more control
  82  * in this area (see e.g. @pre_push), it is very much not recommended.
  83  *
  84  * In particular, base class will either favor tracking upstream timestamps
  85  * (at the possible expense of jitter) or aim to arrange for a perfect stream of
  86  * output timestamps, depending on #GstAudioEncoder:perfect-timestamp.
  87  * However, in the latter case, the input may not be so perfect or ideal, which
  88  * is handled as follows.  An input timestamp is compared with the expected
  89  * timestamp as dictated by input sample stream and if the deviation is less
  90  * than #GstAudioEncoder:tolerance, the deviation is discarded.
  91  * Otherwise, it is considered a discontuinity and subsequent output timestamp
  92  * is resynced to the new position after performing configured discontinuity
  93  * processing.  In the non-perfect-timestamp case, an upstream variation
  94  * exceeding tolerance only leads to marking DISCONT on subsequent outgoing
  95  * (while timestamps are adjusted to upstream regardless of variation).
  96  * While DISCONT is also marked in the perfect-timestamp case, this one
  97  * optionally (see #GstAudioEncoder:hard-resync)
  98  * performs some additional steps, such as clipping of (early) input samples
  99  * or draining all currently remaining input data, depending on the direction
 100  * of the discontuinity.
 101  *
 102  * If perfect timestamps are arranged, it is also possible to request baseclass
 103  * (usually set by subclass) to provide additional buffer metadata (in OFFSET
 104  * and OFFSET_END) fields according to granule defined semantics currently
 105  * needed by oggmux.  Specifically, OFFSET is set to granulepos (= sample count
 106  * including buffer) and OFFSET_END to corresponding timestamp (as determined
 107  * by same sample count and sample rate).
 108  *
 109  * Things that subclass need to take care of:
 110  *
 111  *   * Provide pad templates
 112  *   * Set source pad caps when appropriate
 113  *   * Inform base class of buffer processing needs using context&#39;s
 114  *      frame_samples and frame_bytes.
 115  *   * Set user-configurable properties to sane defaults for format and
 116  *      implementing codec at hand, e.g. those controlling timestamp behaviour
 117  *      and discontinuity processing.
 118  *   * Accept data in @handle_frame and provide encoded results to
 119  *      gst_audio_encoder_finish_frame().
 120  *
 121  */
 122 
 123 #ifdef HAVE_CONFIG_H
 124 #  include &quot;config.h&quot;
 125 #endif
 126 
 127 #include &quot;gstaudioencoder.h&quot;
 128 #include &quot;gstaudioutilsprivate.h&quot;
 129 #include &lt;gst/base/gstadapter.h&gt;
 130 #include &lt;gst/audio/audio.h&gt;
 131 #include &lt;gst/pbutils/descriptions.h&gt;
 132 
 133 #include &lt;stdlib.h&gt;
 134 #include &lt;string.h&gt;
 135 
 136 
 137 GST_DEBUG_CATEGORY_STATIC (gst_audio_encoder_debug);
 138 #define GST_CAT_DEFAULT gst_audio_encoder_debug
 139 
<a name="1" id="anc1"></a><span class="line-removed"> 140 #define GST_AUDIO_ENCODER_GET_PRIVATE(obj)  \</span>
<span class="line-removed"> 141     (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_AUDIO_ENCODER, \</span>
<span class="line-removed"> 142         GstAudioEncoderPrivate))</span>
<span class="line-removed"> 143 </span>
 144 enum
 145 {
 146   PROP_0,
 147   PROP_PERFECT_TS,
 148   PROP_GRANULE,
 149   PROP_HARD_RESYNC,
 150   PROP_TOLERANCE
 151 };
 152 
 153 #define DEFAULT_PERFECT_TS   FALSE
 154 #define DEFAULT_GRANULE      FALSE
 155 #define DEFAULT_HARD_RESYNC  FALSE
 156 #define DEFAULT_TOLERANCE    40000000
 157 #define DEFAULT_HARD_MIN     FALSE
 158 #define DEFAULT_DRAINABLE    TRUE
 159 
 160 typedef struct _GstAudioEncoderContext
 161 {
 162   /* input */
 163   /* last negotiated input caps */
 164   GstCaps *input_caps;
 165   /* last negotiated input info */
 166   GstAudioInfo info;
 167 
 168   /* output */
 169   GstCaps *caps;
 170   GstCaps *allocation_caps;
 171   gboolean output_caps_changed;
 172   gint frame_samples_min, frame_samples_max;
 173   gint frame_max;
 174   gint lookahead;
 175   /* MT-protected (with LOCK) */
 176   GstClockTime min_latency;
 177   GstClockTime max_latency;
 178 
 179   GList *headers;
 180   gboolean new_headers;
 181 
 182   GstAllocator *allocator;
 183   GstAllocationParams params;
 184 } GstAudioEncoderContext;
 185 
 186 struct _GstAudioEncoderPrivate
 187 {
 188   /* activation status */
 189   gboolean active;
 190 
 191   /* input base/first ts as basis for output ts;
 192    * kept nearly constant for perfect_ts,
 193    * otherwise resyncs to upstream ts */
 194   GstClockTime base_ts;
 195   /* corresponding base granulepos */
 196   gint64 base_gp;
 197   /* input samples processed and sent downstream so far (w.r.t. base_ts) */
 198   guint64 samples;
 199 
 200   /* currently collected sample data */
 201   GstAdapter *adapter;
 202   /* offset in adapter up to which already supplied to encoder */
 203   gint offset;
 204   /* mark outgoing discont */
 205   gboolean discont;
 206   /* to guess duration of drained data */
 207   GstClockTime last_duration;
 208 
 209   /* subclass provided data in processing round */
 210   gboolean got_data;
 211   /* subclass gave all it could already */
 212   gboolean drained;
 213   /* subclass currently being forcibly drained */
 214   gboolean force;
 215   /* need to handle changed input caps */
 216   gboolean do_caps;
 217 
 218   /* output bps estimatation */
 219   /* global in samples seen */
 220   guint64 samples_in;
 221   /* global bytes sent out */
 222   guint64 bytes_out;
 223 
 224   /* context storage */
 225   GstAudioEncoderContext ctx;
 226 
 227   /* properties */
 228   gint64 tolerance;
 229   gboolean perfect_ts;
 230   gboolean hard_resync;
 231   gboolean granule;
 232   gboolean hard_min;
 233   gboolean drainable;
 234 
 235   /* upstream stream tags (global tags are passed through as-is) */
 236   GstTagList *upstream_tags;
 237 
 238   /* subclass tags */
 239   GstTagList *tags;
 240   GstTagMergeMode tags_merge_mode;
 241 
 242   gboolean tags_changed;
 243 
 244   /* pending serialized sink events, will be sent from finish_frame() */
 245   GList *pending_events;
 246 };
 247 
 248 
 249 static GstElementClass *parent_class = NULL;
<a name="2" id="anc2"></a>
 250 
 251 static void gst_audio_encoder_class_init (GstAudioEncoderClass * klass);
 252 static void gst_audio_encoder_init (GstAudioEncoder * parse,
 253     GstAudioEncoderClass * klass);
 254 
 255 GType
 256 gst_audio_encoder_get_type (void)
 257 {
 258   static GType audio_encoder_type = 0;
 259 
 260   if (!audio_encoder_type) {
 261     static const GTypeInfo audio_encoder_info = {
 262       sizeof (GstAudioEncoderClass),
 263       (GBaseInitFunc) NULL,
 264       (GBaseFinalizeFunc) NULL,
 265       (GClassInitFunc) gst_audio_encoder_class_init,
 266       NULL,
 267       NULL,
 268       sizeof (GstAudioEncoder),
 269       0,
 270       (GInstanceInitFunc) gst_audio_encoder_init,
 271     };
 272 #ifndef GSTREAMER_LITE
 273     const GInterfaceInfo preset_interface_info = {
 274       NULL,                     /* interface_init */
 275       NULL,                     /* interface_finalize */
 276       NULL                      /* interface_data */
 277     };
 278 #endif // GSTREAMER_LITE
 279 
 280     audio_encoder_type = g_type_register_static (GST_TYPE_ELEMENT,
 281         &quot;GstAudioEncoder&quot;, &amp;audio_encoder_info, G_TYPE_FLAG_ABSTRACT);
 282 
<a name="3" id="anc3"></a>



 283 #ifndef GSTREAMER_LITE
 284     g_type_add_interface_static (audio_encoder_type, GST_TYPE_PRESET,
 285         &amp;preset_interface_info);
 286 #endif // GSTREAMER_LITE
 287   }
 288   return audio_encoder_type;
 289 }
 290 
<a name="4" id="anc4"></a>





 291 static void gst_audio_encoder_finalize (GObject * object);
 292 static void gst_audio_encoder_reset (GstAudioEncoder * enc, gboolean full);
 293 
 294 static void gst_audio_encoder_set_property (GObject * object,
 295     guint prop_id, const GValue * value, GParamSpec * pspec);
 296 static void gst_audio_encoder_get_property (GObject * object,
 297     guint prop_id, GValue * value, GParamSpec * pspec);
 298 
 299 static gboolean gst_audio_encoder_sink_activate_mode (GstPad * pad,
 300     GstObject * parent, GstPadMode mode, gboolean active);
 301 
 302 static GstCaps *gst_audio_encoder_getcaps_default (GstAudioEncoder * enc,
 303     GstCaps * filter);
 304 
 305 static gboolean gst_audio_encoder_sink_event_default (GstAudioEncoder * enc,
 306     GstEvent * event);
 307 static gboolean gst_audio_encoder_src_event_default (GstAudioEncoder * enc,
 308     GstEvent * event);
 309 static gboolean gst_audio_encoder_sink_event (GstPad * pad, GstObject * parent,
 310     GstEvent * event);
 311 static gboolean gst_audio_encoder_src_event (GstPad * pad, GstObject * parent,
 312     GstEvent * event);
 313 static gboolean gst_audio_encoder_sink_setcaps (GstAudioEncoder * enc,
 314     GstCaps * caps);
 315 static GstFlowReturn gst_audio_encoder_chain (GstPad * pad, GstObject * parent,
 316     GstBuffer * buffer);
 317 static gboolean gst_audio_encoder_src_query (GstPad * pad, GstObject * parent,
 318     GstQuery * query);
 319 static gboolean gst_audio_encoder_sink_query (GstPad * pad, GstObject * parent,
 320     GstQuery * query);
 321 static GstStateChangeReturn gst_audio_encoder_change_state (GstElement *
 322     element, GstStateChange transition);
 323 
 324 static gboolean gst_audio_encoder_decide_allocation_default (GstAudioEncoder *
 325     enc, GstQuery * query);
 326 static gboolean gst_audio_encoder_propose_allocation_default (GstAudioEncoder *
 327     enc, GstQuery * query);
 328 static gboolean gst_audio_encoder_negotiate_default (GstAudioEncoder * enc);
 329 static gboolean gst_audio_encoder_negotiate_unlocked (GstAudioEncoder * enc);
 330 
 331 static gboolean gst_audio_encoder_transform_meta_default (GstAudioEncoder *
 332     encoder, GstBuffer * outbuf, GstMeta * meta, GstBuffer * inbuf);
 333 
 334 static gboolean gst_audio_encoder_sink_query_default (GstAudioEncoder * encoder,
 335     GstQuery * query);
 336 static gboolean gst_audio_encoder_src_query_default (GstAudioEncoder * encoder,
 337     GstQuery * query);
 338 
 339 static void
 340 gst_audio_encoder_class_init (GstAudioEncoderClass * klass)
 341 {
 342   GObjectClass *gobject_class;
 343   GstElementClass *gstelement_class;
 344 
 345   gobject_class = G_OBJECT_CLASS (klass);
 346   gstelement_class = GST_ELEMENT_CLASS (klass);
 347   parent_class = g_type_class_peek_parent (klass);
 348 
 349   GST_DEBUG_CATEGORY_INIT (gst_audio_encoder_debug, &quot;audioencoder&quot;, 0,
 350       &quot;audio encoder base class&quot;);
 351 
<a name="5" id="anc5"></a><span class="line-modified"> 352   g_type_class_add_private (klass, sizeof (GstAudioEncoderPrivate));</span>

 353 
 354   gobject_class-&gt;set_property = gst_audio_encoder_set_property;
 355   gobject_class-&gt;get_property = gst_audio_encoder_get_property;
 356 
 357   gobject_class-&gt;finalize = GST_DEBUG_FUNCPTR (gst_audio_encoder_finalize);
 358 
 359   /* properties */
 360   g_object_class_install_property (gobject_class, PROP_PERFECT_TS,
 361       g_param_spec_boolean (&quot;perfect-timestamp&quot;, &quot;Perfect Timestamps&quot;,
 362           &quot;Favour perfect timestamps over tracking upstream timestamps&quot;,
 363           DEFAULT_PERFECT_TS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 364   g_object_class_install_property (gobject_class, PROP_GRANULE,
 365       g_param_spec_boolean (&quot;mark-granule&quot;, &quot;Granule Marking&quot;,
 366           &quot;Apply granule semantics to buffer metadata (implies perfect-timestamp)&quot;,
 367           DEFAULT_GRANULE, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 368   g_object_class_install_property (gobject_class, PROP_HARD_RESYNC,
 369       g_param_spec_boolean (&quot;hard-resync&quot;, &quot;Hard Resync&quot;,
 370           &quot;Perform clipping and sample flushing upon discontinuity&quot;,
 371           DEFAULT_HARD_RESYNC, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 372   g_object_class_install_property (gobject_class, PROP_TOLERANCE,
 373       g_param_spec_int64 (&quot;tolerance&quot;, &quot;Tolerance&quot;,
 374           &quot;Consider discontinuity if timestamp jitter/imperfection exceeds tolerance (ns)&quot;,
 375           0, G_MAXINT64, DEFAULT_TOLERANCE,
 376           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 377 
 378   gstelement_class-&gt;change_state =
 379       GST_DEBUG_FUNCPTR (gst_audio_encoder_change_state);
 380 
 381   klass-&gt;getcaps = gst_audio_encoder_getcaps_default;
 382   klass-&gt;sink_event = gst_audio_encoder_sink_event_default;
 383   klass-&gt;src_event = gst_audio_encoder_src_event_default;
 384   klass-&gt;sink_query = gst_audio_encoder_sink_query_default;
 385   klass-&gt;src_query = gst_audio_encoder_src_query_default;
 386   klass-&gt;propose_allocation = gst_audio_encoder_propose_allocation_default;
 387   klass-&gt;decide_allocation = gst_audio_encoder_decide_allocation_default;
 388   klass-&gt;negotiate = gst_audio_encoder_negotiate_default;
 389   klass-&gt;transform_meta = gst_audio_encoder_transform_meta_default;
 390 }
 391 
 392 static void
 393 gst_audio_encoder_init (GstAudioEncoder * enc, GstAudioEncoderClass * bclass)
 394 {
 395   GstPadTemplate *pad_template;
 396 
 397   GST_DEBUG_OBJECT (enc, &quot;gst_audio_encoder_init&quot;);
 398 
<a name="6" id="anc6"></a><span class="line-modified"> 399   enc-&gt;priv = GST_AUDIO_ENCODER_GET_PRIVATE (enc);</span>
 400 
 401   /* only push mode supported */
 402   pad_template =
 403       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;sink&quot;);
 404   g_return_if_fail (pad_template != NULL);
 405   enc-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 406   gst_pad_set_event_function (enc-&gt;sinkpad,
 407       GST_DEBUG_FUNCPTR (gst_audio_encoder_sink_event));
 408   gst_pad_set_query_function (enc-&gt;sinkpad,
 409       GST_DEBUG_FUNCPTR (gst_audio_encoder_sink_query));
 410   gst_pad_set_chain_function (enc-&gt;sinkpad,
 411       GST_DEBUG_FUNCPTR (gst_audio_encoder_chain));
 412   gst_pad_set_activatemode_function (enc-&gt;sinkpad,
 413       GST_DEBUG_FUNCPTR (gst_audio_encoder_sink_activate_mode));
 414   gst_element_add_pad (GST_ELEMENT (enc), enc-&gt;sinkpad);
 415 
 416   GST_DEBUG_OBJECT (enc, &quot;sinkpad created&quot;);
 417 
 418   /* and we don&#39;t mind upstream traveling stuff that much ... */
 419   pad_template =
 420       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;src&quot;);
 421   g_return_if_fail (pad_template != NULL);
 422   enc-&gt;srcpad = gst_pad_new_from_template (pad_template, &quot;src&quot;);
 423   gst_pad_set_event_function (enc-&gt;srcpad,
 424       GST_DEBUG_FUNCPTR (gst_audio_encoder_src_event));
 425   gst_pad_set_query_function (enc-&gt;srcpad,
 426       GST_DEBUG_FUNCPTR (gst_audio_encoder_src_query));
 427   gst_pad_use_fixed_caps (enc-&gt;srcpad);
 428   gst_element_add_pad (GST_ELEMENT (enc), enc-&gt;srcpad);
 429   GST_DEBUG_OBJECT (enc, &quot;src created&quot;);
 430 
 431   enc-&gt;priv-&gt;adapter = gst_adapter_new ();
 432 
 433   g_rec_mutex_init (&amp;enc-&gt;stream_lock);
 434 
 435   /* property default */
 436   enc-&gt;priv-&gt;granule = DEFAULT_GRANULE;
 437   enc-&gt;priv-&gt;perfect_ts = DEFAULT_PERFECT_TS;
 438   enc-&gt;priv-&gt;hard_resync = DEFAULT_HARD_RESYNC;
 439   enc-&gt;priv-&gt;tolerance = DEFAULT_TOLERANCE;
 440   enc-&gt;priv-&gt;hard_min = DEFAULT_HARD_MIN;
 441   enc-&gt;priv-&gt;drainable = DEFAULT_DRAINABLE;
 442 
 443   /* init state */
 444   enc-&gt;priv-&gt;ctx.min_latency = 0;
 445   enc-&gt;priv-&gt;ctx.max_latency = 0;
 446   gst_audio_encoder_reset (enc, TRUE);
 447   GST_DEBUG_OBJECT (enc, &quot;init ok&quot;);
 448 }
 449 
 450 static void
 451 gst_audio_encoder_reset (GstAudioEncoder * enc, gboolean full)
 452 {
 453   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
 454 
 455   GST_LOG_OBJECT (enc, &quot;reset full %d&quot;, full);
 456 
 457   if (full) {
 458     enc-&gt;priv-&gt;active = FALSE;
 459     GST_OBJECT_LOCK (enc);
 460     enc-&gt;priv-&gt;samples_in = 0;
 461     enc-&gt;priv-&gt;bytes_out = 0;
 462     GST_OBJECT_UNLOCK (enc);
 463 
 464     g_list_foreach (enc-&gt;priv-&gt;ctx.headers, (GFunc) gst_buffer_unref, NULL);
 465     g_list_free (enc-&gt;priv-&gt;ctx.headers);
 466     enc-&gt;priv-&gt;ctx.headers = NULL;
 467     enc-&gt;priv-&gt;ctx.new_headers = FALSE;
 468 
 469     if (enc-&gt;priv-&gt;ctx.allocator)
 470       gst_object_unref (enc-&gt;priv-&gt;ctx.allocator);
 471     enc-&gt;priv-&gt;ctx.allocator = NULL;
 472 
 473     GST_OBJECT_LOCK (enc);
 474     gst_caps_replace (&amp;enc-&gt;priv-&gt;ctx.input_caps, NULL);
 475     gst_caps_replace (&amp;enc-&gt;priv-&gt;ctx.caps, NULL);
 476     gst_caps_replace (&amp;enc-&gt;priv-&gt;ctx.allocation_caps, NULL);
 477 
 478     memset (&amp;enc-&gt;priv-&gt;ctx, 0, sizeof (enc-&gt;priv-&gt;ctx));
 479     gst_audio_info_init (&amp;enc-&gt;priv-&gt;ctx.info);
 480     GST_OBJECT_UNLOCK (enc);
 481 
 482     if (enc-&gt;priv-&gt;upstream_tags) {
 483       gst_tag_list_unref (enc-&gt;priv-&gt;upstream_tags);
 484       enc-&gt;priv-&gt;upstream_tags = NULL;
 485     }
 486     if (enc-&gt;priv-&gt;tags)
 487       gst_tag_list_unref (enc-&gt;priv-&gt;tags);
 488     enc-&gt;priv-&gt;tags = NULL;
 489     enc-&gt;priv-&gt;tags_merge_mode = GST_TAG_MERGE_APPEND;
 490     enc-&gt;priv-&gt;tags_changed = FALSE;
 491 
 492     g_list_foreach (enc-&gt;priv-&gt;pending_events, (GFunc) gst_event_unref, NULL);
 493     g_list_free (enc-&gt;priv-&gt;pending_events);
 494     enc-&gt;priv-&gt;pending_events = NULL;
 495   }
 496 
 497   gst_segment_init (&amp;enc-&gt;input_segment, GST_FORMAT_TIME);
 498   gst_segment_init (&amp;enc-&gt;output_segment, GST_FORMAT_TIME);
 499 
 500   gst_adapter_clear (enc-&gt;priv-&gt;adapter);
 501   enc-&gt;priv-&gt;got_data = FALSE;
 502   enc-&gt;priv-&gt;drained = TRUE;
 503   enc-&gt;priv-&gt;offset = 0;
 504   enc-&gt;priv-&gt;base_ts = GST_CLOCK_TIME_NONE;
 505   enc-&gt;priv-&gt;base_gp = -1;
 506   enc-&gt;priv-&gt;samples = 0;
 507   enc-&gt;priv-&gt;discont = FALSE;
 508 
 509   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
 510 }
 511 
 512 static void
 513 gst_audio_encoder_finalize (GObject * object)
 514 {
 515   GstAudioEncoder *enc = GST_AUDIO_ENCODER (object);
 516 
 517   g_object_unref (enc-&gt;priv-&gt;adapter);
 518 
 519   g_rec_mutex_clear (&amp;enc-&gt;stream_lock);
 520 
 521   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 522 }
 523 
 524 static GstStateChangeReturn
 525 gst_audio_encoder_change_state (GstElement * element, GstStateChange transition)
 526 {
 527   GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
 528   GstAudioEncoder *enc = GST_AUDIO_ENCODER (element);
 529   GstAudioEncoderClass *klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
 530 
 531   switch (transition) {
 532     case GST_STATE_CHANGE_NULL_TO_READY:
 533       if (klass-&gt;open) {
 534         if (!klass-&gt;open (enc))
 535           goto open_failed;
 536       }
 537     default:
 538       break;
 539   }
 540 
 541   ret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
 542 
 543   switch (transition) {
 544     case GST_STATE_CHANGE_READY_TO_NULL:
 545       if (klass-&gt;close) {
 546         if (!klass-&gt;close (enc))
 547           goto close_failed;
 548       }
 549     default:
 550       break;
 551   }
 552 
 553   return ret;
 554 
 555 open_failed:
 556   {
 557     GST_ELEMENT_ERROR (enc, LIBRARY, INIT, (NULL), (&quot;Failed to open codec&quot;));
 558     return GST_STATE_CHANGE_FAILURE;
 559   }
 560 close_failed:
 561   {
 562     GST_ELEMENT_ERROR (enc, LIBRARY, INIT, (NULL), (&quot;Failed to close codec&quot;));
 563     return GST_STATE_CHANGE_FAILURE;
 564   }
 565 }
 566 
 567 static gboolean
 568 gst_audio_encoder_push_event (GstAudioEncoder * enc, GstEvent * event)
 569 {
 570   switch (GST_EVENT_TYPE (event)) {
 571     case GST_EVENT_SEGMENT:{
 572       GstSegment seg;
 573 
 574       GST_AUDIO_ENCODER_STREAM_LOCK (enc);
 575       gst_event_copy_segment (event, &amp;seg);
 576 
 577       GST_DEBUG_OBJECT (enc, &quot;starting segment %&quot; GST_SEGMENT_FORMAT, &amp;seg);
 578 
 579       enc-&gt;output_segment = seg;
 580       GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
 581       break;
 582     }
 583     default:
 584       break;
 585   }
 586 
 587   return gst_pad_push_event (enc-&gt;srcpad, event);
 588 }
 589 
 590 static inline void
 591 gst_audio_encoder_push_pending_events (GstAudioEncoder * enc)
 592 {
 593   GstAudioEncoderPrivate *priv = enc-&gt;priv;
 594 
 595   if (priv-&gt;pending_events) {
 596     GList *pending_events, *l;
 597 
 598     pending_events = priv-&gt;pending_events;
 599     priv-&gt;pending_events = NULL;
 600 
 601     GST_DEBUG_OBJECT (enc, &quot;Pushing pending events&quot;);
 602     for (l = pending_events; l; l = l-&gt;next)
 603       gst_audio_encoder_push_event (enc, l-&gt;data);
 604     g_list_free (pending_events);
 605   }
 606 }
 607 
 608 static GstEvent *
 609 gst_audio_encoder_create_merged_tags_event (GstAudioEncoder * enc)
 610 {
 611   GstTagList *merged_tags;
 612 
 613   GST_LOG_OBJECT (enc, &quot;upstream : %&quot; GST_PTR_FORMAT, enc-&gt;priv-&gt;upstream_tags);
 614   GST_LOG_OBJECT (enc, &quot;encoder  : %&quot; GST_PTR_FORMAT, enc-&gt;priv-&gt;tags);
 615   GST_LOG_OBJECT (enc, &quot;mode     : %d&quot;, enc-&gt;priv-&gt;tags_merge_mode);
 616 
 617   merged_tags =
 618       gst_tag_list_merge (enc-&gt;priv-&gt;upstream_tags, enc-&gt;priv-&gt;tags,
 619       enc-&gt;priv-&gt;tags_merge_mode);
 620 
 621   GST_DEBUG_OBJECT (enc, &quot;merged   : %&quot; GST_PTR_FORMAT, merged_tags);
 622 
 623   if (merged_tags == NULL)
 624     return NULL;
 625 
 626   if (gst_tag_list_is_empty (merged_tags)) {
 627     gst_tag_list_unref (merged_tags);
 628     return NULL;
 629   }
 630 
<a name="7" id="anc7"></a><span class="line-modified"> 631     /* add codec info to pending tags */</span>
 632 #if 0
<a name="8" id="anc8"></a><span class="line-modified"> 633     caps = gst_pad_get_current_caps (enc-&gt;srcpad);</span>
 634   gst_pb_utils_add_codec_description_to_tag_list (merged_tags,
<a name="9" id="anc9"></a><span class="line-modified"> 635         GST_TAG_AUDIO_CODEC, caps);</span>
 636 #endif
 637 
 638   return gst_event_new_tag (merged_tags);
 639 }
 640 
 641 static void
 642 gst_audio_encoder_check_and_push_pending_tags (GstAudioEncoder * enc)
 643 {
 644   if (enc-&gt;priv-&gt;tags_changed) {
 645     GstEvent *tags_event;
 646 
 647     tags_event = gst_audio_encoder_create_merged_tags_event (enc);
 648 
 649     if (tags_event != NULL)
 650       gst_audio_encoder_push_event (enc, tags_event);
 651 
 652     enc-&gt;priv-&gt;tags_changed = FALSE;
 653   }
 654 }
 655 
 656 
 657 static gboolean
 658 gst_audio_encoder_transform_meta_default (GstAudioEncoder *
 659     encoder, GstBuffer * outbuf, GstMeta * meta, GstBuffer * inbuf)
 660 {
 661   const GstMetaInfo *info = meta-&gt;info;
 662   const gchar *const *tags;
 663 
 664   tags = gst_meta_api_type_get_tags (info-&gt;api);
 665 
 666   if (!tags || (g_strv_length ((gchar **) tags) == 1
 667           &amp;&amp; gst_meta_api_type_has_tag (info-&gt;api,
 668               g_quark_from_string (GST_META_TAG_AUDIO_STR))))
 669     return TRUE;
 670 
 671   return FALSE;
 672 }
 673 
 674 typedef struct
 675 {
 676   GstAudioEncoder *encoder;
 677   GstBuffer *outbuf;
 678 } CopyMetaData;
 679 
 680 static gboolean
 681 foreach_metadata (GstBuffer * inbuf, GstMeta ** meta, gpointer user_data)
 682 {
 683   CopyMetaData *data = user_data;
 684   GstAudioEncoder *encoder = data-&gt;encoder;
 685   GstAudioEncoderClass *klass = GST_AUDIO_ENCODER_GET_CLASS (encoder);
 686   GstBuffer *outbuf = data-&gt;outbuf;
 687   const GstMetaInfo *info = (*meta)-&gt;info;
 688   gboolean do_copy = FALSE;
 689 
 690   if (gst_meta_api_type_has_tag (info-&gt;api, _gst_meta_tag_memory)) {
 691     /* never call the transform_meta with memory specific metadata */
 692     GST_DEBUG_OBJECT (encoder, &quot;not copying memory specific metadata %s&quot;,
 693         g_type_name (info-&gt;api));
 694     do_copy = FALSE;
 695   } else if (klass-&gt;transform_meta) {
 696     do_copy = klass-&gt;transform_meta (encoder, outbuf, *meta, inbuf);
 697     GST_DEBUG_OBJECT (encoder, &quot;transformed metadata %s: copy: %d&quot;,
 698         g_type_name (info-&gt;api), do_copy);
 699   }
 700 
 701   /* we only copy metadata when the subclass implemented a transform_meta
 702    * function and when it returns %TRUE */
 703   if (do_copy &amp;&amp; info-&gt;transform_func) {
 704     GstMetaTransformCopy copy_data = { FALSE, 0, -1 };
 705     GST_DEBUG_OBJECT (encoder, &quot;copy metadata %s&quot;, g_type_name (info-&gt;api));
 706     /* simply copy then */
 707     info-&gt;transform_func (outbuf, *meta, inbuf,
 708         _gst_meta_transform_copy, &amp;copy_data);
 709   }
 710   return TRUE;
 711 }
 712 
 713 /**
 714  * gst_audio_encoder_finish_frame:
 715  * @enc: a #GstAudioEncoder
 716  * @buffer: encoded data
 717  * @samples: number of samples (per channel) represented by encoded data
 718  *
 719  * Collects encoded data and pushes encoded data downstream.
 720  * Source pad caps must be set when this is called.
 721  *
 722  * If @samples &lt; 0, then best estimate is all samples provided to encoder
 723  * (subclass) so far.  @buf may be NULL, in which case next number of @samples
 724  * are considered discarded, e.g. as a result of discontinuous transmission,
 725  * and a discontinuity is marked.
 726  *
<a name="10" id="anc10"></a><span class="line-modified"> 727  * Note that samples received in gst_audio_encoder_handle_frame()</span>
 728  * may be invalidated by a call to this function.
 729  *
 730  * Returns: a #GstFlowReturn that should be escalated to caller (of caller)
 731  */
 732 GstFlowReturn
 733 gst_audio_encoder_finish_frame (GstAudioEncoder * enc, GstBuffer * buf,
 734     gint samples)
 735 {
 736   GstAudioEncoderClass *klass;
 737   GstAudioEncoderPrivate *priv;
 738   GstAudioEncoderContext *ctx;
 739   GstFlowReturn ret = GST_FLOW_OK;
 740   gboolean needs_reconfigure = FALSE;
 741   GstBuffer *inbuf = NULL;
 742 
 743   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
 744   priv = enc-&gt;priv;
 745   ctx = &amp;enc-&gt;priv-&gt;ctx;
 746 
 747   /* subclass should not hand us no data */
 748   g_return_val_if_fail (buf == NULL || gst_buffer_get_size (buf) &gt; 0,
 749       GST_FLOW_ERROR);
 750 
 751   /* subclass should know what it is producing by now */
 752   if (!ctx-&gt;caps)
 753     goto no_caps;
 754 
 755   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
 756 
 757   GST_LOG_OBJECT (enc,
 758       &quot;accepting %&quot; G_GSIZE_FORMAT &quot; bytes encoded data as %d samples&quot;,
 759       buf ? gst_buffer_get_size (buf) : -1, samples);
 760 
 761   needs_reconfigure = gst_pad_check_reconfigure (enc-&gt;srcpad);
 762   if (G_UNLIKELY (ctx-&gt;output_caps_changed || needs_reconfigure)) {
 763     if (!gst_audio_encoder_negotiate_unlocked (enc)) {
 764       gst_pad_mark_reconfigure (enc-&gt;srcpad);
 765       if (GST_PAD_IS_FLUSHING (enc-&gt;srcpad))
 766         ret = GST_FLOW_FLUSHING;
 767       else
 768         ret = GST_FLOW_NOT_NEGOTIATED;
 769       if (buf)
 770         gst_buffer_unref (buf);
 771       goto exit;
 772     }
 773   }
 774 
 775   /* mark subclass still alive and providing */
 776   if (G_LIKELY (buf))
 777     priv-&gt;got_data = TRUE;
 778 
 779   gst_audio_encoder_push_pending_events (enc);
 780 
 781   /* send after pending events, which likely includes segment event */
 782   gst_audio_encoder_check_and_push_pending_tags (enc);
 783 
 784   /* remove corresponding samples from input */
 785   if (samples &lt; 0)
 786     samples = (enc-&gt;priv-&gt;offset / ctx-&gt;info.bpf);
 787 
 788   if (G_LIKELY (samples)) {
 789     /* track upstream ts if so configured */
 790     if (!enc-&gt;priv-&gt;perfect_ts) {
 791       guint64 ts, distance;
 792 
 793       ts = gst_adapter_prev_pts (priv-&gt;adapter, &amp;distance);
 794       g_assert (distance % ctx-&gt;info.bpf == 0);
 795       distance /= ctx-&gt;info.bpf;
 796       GST_LOG_OBJECT (enc, &quot;%&quot; G_GUINT64_FORMAT &quot; samples past prev_ts %&quot;
 797           GST_TIME_FORMAT, distance, GST_TIME_ARGS (ts));
 798       GST_LOG_OBJECT (enc, &quot;%&quot; G_GUINT64_FORMAT &quot; samples past base_ts %&quot;
 799           GST_TIME_FORMAT, priv-&gt;samples, GST_TIME_ARGS (priv-&gt;base_ts));
 800       /* when draining adapter might be empty and no ts to offer */
 801       if (GST_CLOCK_TIME_IS_VALID (ts) &amp;&amp; ts != priv-&gt;base_ts) {
 802         GstClockTimeDiff diff;
 803         GstClockTime old_ts, next_ts;
 804 
 805         /* passed into another buffer;
 806          * mild check for discontinuity and only mark if so */
 807         next_ts = ts +
 808             gst_util_uint64_scale (distance, GST_SECOND, ctx-&gt;info.rate);
 809         old_ts = priv-&gt;base_ts +
 810             gst_util_uint64_scale (priv-&gt;samples, GST_SECOND, ctx-&gt;info.rate);
 811         diff = GST_CLOCK_DIFF (next_ts, old_ts);
 812         GST_LOG_OBJECT (enc, &quot;ts diff %d ms&quot;, (gint) (diff / GST_MSECOND));
 813         /* only mark discontinuity if beyond tolerance */
 814         if (G_UNLIKELY (diff &lt; -enc-&gt;priv-&gt;tolerance ||
 815                 diff &gt; enc-&gt;priv-&gt;tolerance)) {
 816           GST_DEBUG_OBJECT (enc, &quot;marked discont&quot;);
 817           priv-&gt;discont = TRUE;
 818         }
 819         if (diff &gt; GST_SECOND / ctx-&gt;info.rate / 2 ||
 820             diff &lt; -GST_SECOND / ctx-&gt;info.rate / 2) {
 821           GST_LOG_OBJECT (enc, &quot;new upstream ts %&quot; GST_TIME_FORMAT
 822               &quot; at distance %&quot; G_GUINT64_FORMAT, GST_TIME_ARGS (ts), distance);
 823           /* re-sync to upstream ts */
 824           priv-&gt;base_ts = ts;
 825           priv-&gt;samples = distance;
 826         } else {
 827           GST_LOG_OBJECT (enc, &quot;new upstream ts only introduces jitter&quot;);
 828         }
 829       }
 830     }
 831     /* advance sample view */
 832     if (G_UNLIKELY (samples * ctx-&gt;info.bpf &gt; priv-&gt;offset)) {
 833       guint avail = gst_adapter_available (priv-&gt;adapter);
 834 
 835       if (G_LIKELY (!priv-&gt;force)) {
 836         /* we should have received EOS to enable force */
 837         goto overflow;
 838       } else {
 839         priv-&gt;offset = 0;
 840         if (avail &gt; 0 &amp;&amp; samples * ctx-&gt;info.bpf &gt;= avail) {
 841           inbuf = gst_adapter_take_buffer_fast (priv-&gt;adapter, avail);
 842           gst_adapter_clear (priv-&gt;adapter);
 843         } else if (avail &gt; 0) {
 844           inbuf =
 845               gst_adapter_take_buffer_fast (priv-&gt;adapter,
 846               samples * ctx-&gt;info.bpf);
<a name="11" id="anc11"></a><span class="line-modified"> 847       }</span>
 848       }
 849     } else {
 850       guint avail = gst_adapter_available (priv-&gt;adapter);
 851 
 852       if (avail &gt; 0) {
 853         inbuf =
 854             gst_adapter_take_buffer_fast (priv-&gt;adapter,
 855             samples * ctx-&gt;info.bpf);
 856       }
 857       priv-&gt;offset -= samples * ctx-&gt;info.bpf;
 858       /* avoid subsequent stray prev_ts */
 859       if (G_UNLIKELY (gst_adapter_available (priv-&gt;adapter) == 0))
 860         gst_adapter_clear (priv-&gt;adapter);
 861     }
 862     /* sample count advanced below after buffer handling */
 863   }
 864 
 865   /* collect output */
 866   if (G_LIKELY (buf)) {
 867     gsize size;
 868 
 869     /* Pushing headers first */
 870     if (G_UNLIKELY (priv-&gt;ctx.new_headers)) {
 871       GList *tmp;
 872 
 873       GST_DEBUG_OBJECT (enc, &quot;Sending headers&quot;);
 874 
 875       for (tmp = priv-&gt;ctx.headers; tmp; tmp = tmp-&gt;next) {
 876         GstBuffer *tmpbuf = gst_buffer_ref (tmp-&gt;data);
 877 
 878         tmpbuf = gst_buffer_make_writable (tmpbuf);
 879         size = gst_buffer_get_size (tmpbuf);
 880 
 881         if (G_UNLIKELY (priv-&gt;discont)) {
 882           GST_LOG_OBJECT (enc, &quot;marking discont&quot;);
 883           GST_BUFFER_FLAG_SET (tmpbuf, GST_BUFFER_FLAG_DISCONT);
 884           priv-&gt;discont = FALSE;
 885         }
 886 
 887         /* Ogg codecs like Vorbis use offset/offset-end in a special
 888          * way and both should be 0 for these codecs */
 889         if (priv-&gt;base_gp &gt;= 0) {
 890           GST_BUFFER_OFFSET (tmpbuf) = 0;
 891           GST_BUFFER_OFFSET_END (tmpbuf) = 0;
 892         } else {
 893           GST_BUFFER_OFFSET (tmpbuf) = priv-&gt;bytes_out;
 894           GST_BUFFER_OFFSET_END (tmpbuf) = priv-&gt;bytes_out + size;
 895         }
 896 
 897         GST_OBJECT_LOCK (enc);
 898         priv-&gt;bytes_out += size;
 899         GST_OBJECT_UNLOCK (enc);
 900 
 901         ret = gst_pad_push (enc-&gt;srcpad, tmpbuf);
 902         if (ret != GST_FLOW_OK) {
 903           GST_WARNING_OBJECT (enc, &quot;pushing header returned %s&quot;,
 904               gst_flow_get_name (ret));
 905           goto exit;
<a name="12" id="anc12"></a><span class="line-modified"> 906       }</span>
 907       }
 908       priv-&gt;ctx.new_headers = FALSE;
 909     }
 910 
 911     size = gst_buffer_get_size (buf);
 912 
 913     GST_LOG_OBJECT (enc, &quot;taking %&quot; G_GSIZE_FORMAT &quot; bytes for output&quot;, size);
 914     buf = gst_buffer_make_writable (buf);
 915 
 916     /* decorate */
 917     if (G_LIKELY (GST_CLOCK_TIME_IS_VALID (priv-&gt;base_ts))) {
 918       /* FIXME ? lookahead could lead to weird ts and duration ?
 919        * (particularly if not in perfect mode) */
 920       /* mind sample rounding and produce perfect output */
 921       GST_BUFFER_TIMESTAMP (buf) = priv-&gt;base_ts +
 922           gst_util_uint64_scale (priv-&gt;samples - ctx-&gt;lookahead, GST_SECOND,
 923           ctx-&gt;info.rate);
 924       GST_BUFFER_DTS (buf) = GST_BUFFER_TIMESTAMP (buf);
 925       GST_DEBUG_OBJECT (enc, &quot;out samples %d&quot;, samples);
 926       if (G_LIKELY (samples &gt; 0)) {
 927         priv-&gt;samples += samples;
 928         GST_BUFFER_DURATION (buf) = priv-&gt;base_ts +
 929             gst_util_uint64_scale (priv-&gt;samples - ctx-&gt;lookahead, GST_SECOND,
 930             ctx-&gt;info.rate) - GST_BUFFER_TIMESTAMP (buf);
 931         priv-&gt;last_duration = GST_BUFFER_DURATION (buf);
 932       } else {
 933         /* duration forecast in case of handling remainder;
 934          * the last one is probably like the previous one ... */
 935         GST_BUFFER_DURATION (buf) = priv-&gt;last_duration;
 936       }
 937       if (priv-&gt;base_gp &gt;= 0) {
 938         /* pamper oggmux */
 939         /* FIXME: in longer run, muxer should take care of this ... */
 940         /* offset_end = granulepos for ogg muxer */
 941         GST_BUFFER_OFFSET_END (buf) = priv-&gt;base_gp + priv-&gt;samples -
 942             enc-&gt;priv-&gt;ctx.lookahead;
 943         /* offset = timestamp corresponding to granulepos for ogg muxer */
 944         GST_BUFFER_OFFSET (buf) =
 945             GST_FRAMES_TO_CLOCK_TIME (GST_BUFFER_OFFSET_END (buf),
 946             ctx-&gt;info.rate);
 947       } else {
 948         GST_BUFFER_OFFSET (buf) = priv-&gt;bytes_out;
 949         GST_BUFFER_OFFSET_END (buf) = priv-&gt;bytes_out + size;
 950       }
 951     }
 952 
 953     if (klass-&gt;transform_meta) {
 954       if (G_LIKELY (inbuf)) {
 955         CopyMetaData data;
 956 
 957         data.encoder = enc;
 958         data.outbuf = buf;
 959         gst_buffer_foreach_meta (inbuf, foreach_metadata, &amp;data);
 960       } else {
 961         GST_WARNING_OBJECT (enc,
 962             &quot;Can&#39;t copy metadata because input buffer disappeared&quot;);
 963       }
 964     }
 965 
 966     GST_OBJECT_LOCK (enc);
 967     priv-&gt;bytes_out += size;
 968     GST_OBJECT_UNLOCK (enc);
 969 
 970     if (G_UNLIKELY (priv-&gt;discont)) {
 971       GST_LOG_OBJECT (enc, &quot;marking discont&quot;);
 972       GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);
 973       priv-&gt;discont = FALSE;
 974     }
 975 
 976     if (klass-&gt;pre_push) {
 977       /* last chance for subclass to do some dirty stuff */
 978       ret = klass-&gt;pre_push (enc, &amp;buf);
 979       if (ret != GST_FLOW_OK || !buf) {
 980         GST_DEBUG_OBJECT (enc, &quot;subclass returned %s, buf %p&quot;,
 981             gst_flow_get_name (ret), buf);
 982 
 983         if (buf)
 984           gst_buffer_unref (buf);
 985         goto exit;
 986       }
 987     }
 988 
 989     GST_LOG_OBJECT (enc,
 990         &quot;pushing buffer of size %&quot; G_GSIZE_FORMAT &quot; with ts %&quot; GST_TIME_FORMAT
 991         &quot;, duration %&quot; GST_TIME_FORMAT, size,
 992         GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
 993         GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
 994 
 995     ret = gst_pad_push (enc-&gt;srcpad, buf);
 996     GST_LOG_OBJECT (enc, &quot;buffer pushed: %s&quot;, gst_flow_get_name (ret));
 997   } else {
 998     /* merely advance samples, most work for that already done above */
 999     priv-&gt;samples += samples;
1000   }
1001 
1002 exit:
1003   if (inbuf)
1004     gst_buffer_unref (inbuf);
1005 
1006   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1007 
1008   return ret;
1009 
1010   /* ERRORS */
1011 no_caps:
1012   {
1013     GST_ELEMENT_ERROR (enc, STREAM, ENCODE, (&quot;no caps set&quot;), (NULL));
1014     if (buf)
1015       gst_buffer_unref (buf);
1016     return GST_FLOW_ERROR;
1017   }
1018 overflow:
1019   {
1020     GST_ELEMENT_ERROR (enc, STREAM, ENCODE,
1021         (&quot;received more encoded samples %d than provided %d as inputs&quot;,
1022             samples, priv-&gt;offset / ctx-&gt;info.bpf), (NULL));
1023     if (buf)
1024       gst_buffer_unref (buf);
1025     ret = GST_FLOW_ERROR;
1026     /* no way we can let this pass */
1027     g_assert_not_reached ();
1028     /* really no way */
1029     goto exit;
1030   }
1031 }
1032 
1033  /* adapter tracking idea:
1034   * - start of adapter corresponds with what has already been encoded
1035   * (i.e. really returned by encoder subclass)
1036   * - start + offset is what needs to be fed to subclass next */
1037 static GstFlowReturn
1038 gst_audio_encoder_push_buffers (GstAudioEncoder * enc, gboolean force)
1039 {
1040   GstAudioEncoderClass *klass;
1041   GstAudioEncoderPrivate *priv;
1042   GstAudioEncoderContext *ctx;
1043   gint av, need;
1044   GstBuffer *buf;
1045   GstFlowReturn ret = GST_FLOW_OK;
1046 
1047   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
1048 
1049   g_return_val_if_fail (klass-&gt;handle_frame != NULL, GST_FLOW_ERROR);
1050 
1051   priv = enc-&gt;priv;
1052   ctx = &amp;enc-&gt;priv-&gt;ctx;
1053 
1054   while (ret == GST_FLOW_OK) {
1055 
1056     buf = NULL;
1057     av = gst_adapter_available (priv-&gt;adapter);
1058 
1059     g_assert (priv-&gt;offset &lt;= av);
1060     av -= priv-&gt;offset;
1061 
1062     need =
1063         ctx-&gt;frame_samples_min &gt;
1064         0 ? ctx-&gt;frame_samples_min * ctx-&gt;info.bpf : av;
1065     GST_LOG_OBJECT (enc, &quot;available: %d, needed: %d, force: %d&quot;, av, need,
1066         force);
1067 
1068     if ((need &gt; av) || !av) {
1069       if (G_UNLIKELY (force)) {
1070         priv-&gt;force = TRUE;
1071         need = av;
1072       } else {
1073         break;
1074       }
1075     } else {
1076       priv-&gt;force = FALSE;
1077     }
1078 
1079     if (ctx-&gt;frame_samples_max &gt; 0)
1080       need = MIN (av, ctx-&gt;frame_samples_max * ctx-&gt;info.bpf);
1081 
1082     if (ctx-&gt;frame_samples_min == ctx-&gt;frame_samples_max) {
1083       /* if we have some extra metadata,
1084        * provide for integer multiple of frames to allow for better granularity
1085        * of processing */
1086       if (ctx-&gt;frame_samples_min &gt; 0 &amp;&amp; need) {
1087         if (ctx-&gt;frame_max &gt; 1)
1088           need = need * MIN ((av / need), ctx-&gt;frame_max);
1089         else if (ctx-&gt;frame_max == 0)
1090           need = need * (av / need);
1091       }
1092     }
1093 
1094     priv-&gt;got_data = FALSE;
1095     if (G_LIKELY (need)) {
1096       const guint8 *data;
1097 
1098       data = gst_adapter_map (priv-&gt;adapter, priv-&gt;offset + need);
1099       buf =
1100           gst_buffer_new_wrapped_full (GST_MEMORY_FLAG_READONLY,
1101           (gpointer) data, priv-&gt;offset + need, priv-&gt;offset, need, NULL, NULL);
1102     } else if (!priv-&gt;drainable) {
1103       GST_DEBUG_OBJECT (enc, &quot;non-drainable and no more data&quot;);
1104       goto finish;
1105     }
1106 
1107     GST_LOG_OBJECT (enc, &quot;providing subclass with %d bytes at offset %d&quot;,
1108         need, priv-&gt;offset);
1109 
1110     /* mark this already as consumed,
1111      * which it should be when subclass gives us data in exchange for samples */
1112     priv-&gt;offset += need;
1113     GST_OBJECT_LOCK (enc);
1114     priv-&gt;samples_in += need / ctx-&gt;info.bpf;
1115     GST_OBJECT_UNLOCK (enc);
1116 
1117     /* subclass might not want to be bothered with leftover data,
1118      * so take care of that here if so, otherwise pass along */
1119     if (G_UNLIKELY (priv-&gt;force &amp;&amp; priv-&gt;hard_min &amp;&amp; buf)) {
1120       GST_DEBUG_OBJECT (enc, &quot;bypassing subclass with leftover&quot;);
1121       ret = gst_audio_encoder_finish_frame (enc, NULL, -1);
1122     } else {
1123       ret = klass-&gt;handle_frame (enc, buf);
1124     }
1125 
1126     if (G_LIKELY (buf)) {
1127       gst_buffer_unref (buf);
1128       gst_adapter_unmap (priv-&gt;adapter);
1129     }
1130 
1131   finish:
1132     /* no data to feed, no leftover provided, then bail out */
1133     if (G_UNLIKELY (!buf &amp;&amp; !priv-&gt;got_data)) {
1134       priv-&gt;drained = TRUE;
1135       GST_LOG_OBJECT (enc, &quot;no more data drained from subclass&quot;);
1136       break;
1137     }
1138   }
1139 
1140   return ret;
1141 }
1142 
1143 static GstFlowReturn
1144 gst_audio_encoder_drain (GstAudioEncoder * enc)
1145 {
1146   GST_DEBUG_OBJECT (enc, &quot;draining&quot;);
1147   if (enc-&gt;priv-&gt;drained)
1148     return GST_FLOW_OK;
1149   else {
1150     GST_DEBUG_OBJECT (enc, &quot;... really&quot;);
1151     return gst_audio_encoder_push_buffers (enc, TRUE);
1152   }
1153 }
1154 
1155 static void
1156 gst_audio_encoder_set_base_gp (GstAudioEncoder * enc)
1157 {
1158   GstClockTime ts;
1159 
1160   if (!enc-&gt;priv-&gt;granule)
1161     return;
1162 
1163   /* use running time for granule */
1164   /* incoming data is clipped, so a valid input should yield a valid output */
1165   ts = gst_segment_to_running_time (&amp;enc-&gt;input_segment, GST_FORMAT_TIME,
1166       enc-&gt;priv-&gt;base_ts);
1167   if (GST_CLOCK_TIME_IS_VALID (ts)) {
1168     enc-&gt;priv-&gt;base_gp =
1169         GST_CLOCK_TIME_TO_FRAMES (enc-&gt;priv-&gt;base_ts, enc-&gt;priv-&gt;ctx.info.rate);
1170     GST_DEBUG_OBJECT (enc, &quot;new base gp %&quot; G_GINT64_FORMAT, enc-&gt;priv-&gt;base_gp);
1171   } else {
1172     /* should reasonably have a valid base,
1173      * otherwise start at 0 if we did not already start there earlier */
1174     if (enc-&gt;priv-&gt;base_gp &lt; 0) {
1175       enc-&gt;priv-&gt;base_gp = 0;
1176       GST_DEBUG_OBJECT (enc, &quot;new base gp %&quot; G_GINT64_FORMAT,
1177           enc-&gt;priv-&gt;base_gp);
1178     }
1179   }
1180 }
1181 
1182 static GstFlowReturn
1183 gst_audio_encoder_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
1184 {
1185   GstAudioEncoder *enc;
1186   GstAudioEncoderPrivate *priv;
1187   GstAudioEncoderContext *ctx;
1188   GstFlowReturn ret = GST_FLOW_OK;
1189   gboolean discont;
1190   gsize size;
1191 
1192   enc = GST_AUDIO_ENCODER (parent);
1193 
1194   priv = enc-&gt;priv;
1195   ctx = &amp;enc-&gt;priv-&gt;ctx;
1196 
1197   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1198 
1199   if (G_UNLIKELY (priv-&gt;do_caps)) {
1200     GstCaps *caps = gst_pad_get_current_caps (enc-&gt;sinkpad);
1201     if (!caps)
1202       goto not_negotiated;
1203     if (!gst_audio_encoder_sink_setcaps (enc, caps)) {
1204       gst_caps_unref (caps);
1205       goto not_negotiated;
1206     }
1207     gst_caps_unref (caps);
1208     priv-&gt;do_caps = FALSE;
1209   }
1210 
1211   /* should know what is coming by now */
1212   if (!ctx-&gt;info.bpf)
1213     goto not_negotiated;
1214 
1215   size = gst_buffer_get_size (buffer);
1216 
1217   GST_LOG_OBJECT (enc,
1218       &quot;received buffer of size %&quot; G_GSIZE_FORMAT &quot; with ts %&quot; GST_TIME_FORMAT
1219       &quot;, duration %&quot; GST_TIME_FORMAT, size,
1220       GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buffer)),
1221       GST_TIME_ARGS (GST_BUFFER_DURATION (buffer)));
1222 
1223   /* input shoud be whole number of sample frames */
1224   if (size % ctx-&gt;info.bpf)
1225     goto wrong_buffer;
1226 
1227 #ifndef GST_DISABLE_GST_DEBUG
1228   {
1229     GstClockTime duration;
1230     GstClockTimeDiff diff;
1231 
1232     /* verify buffer duration */
1233     duration = gst_util_uint64_scale (size, GST_SECOND,
1234         ctx-&gt;info.rate * ctx-&gt;info.bpf);
1235     diff = GST_CLOCK_DIFF (duration, GST_BUFFER_DURATION (buffer));
1236     if (GST_BUFFER_DURATION (buffer) != GST_CLOCK_TIME_NONE &amp;&amp;
1237         (diff &gt; GST_SECOND / ctx-&gt;info.rate / 2 ||
1238             diff &lt; -GST_SECOND / ctx-&gt;info.rate / 2)) {
1239       GST_DEBUG_OBJECT (enc, &quot;incoming buffer had incorrect duration %&quot;
1240           GST_TIME_FORMAT &quot;, expected duration %&quot; GST_TIME_FORMAT,
1241           GST_TIME_ARGS (GST_BUFFER_DURATION (buffer)),
1242           GST_TIME_ARGS (duration));
1243     }
1244   }
1245 #endif
1246 
1247   discont = GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT);
1248   if (G_UNLIKELY (discont)) {
1249     GST_LOG_OBJECT (buffer, &quot;marked discont&quot;);
1250     enc-&gt;priv-&gt;discont = discont;
1251   }
1252 
1253   /* clip to segment */
1254   buffer = gst_audio_buffer_clip (buffer, &amp;enc-&gt;input_segment, ctx-&gt;info.rate,
1255       ctx-&gt;info.bpf);
1256   if (G_UNLIKELY (!buffer)) {
1257     GST_DEBUG_OBJECT (buffer, &quot;no data after clipping to segment&quot;);
1258     goto done;
1259   }
1260 
1261   size = gst_buffer_get_size (buffer);
1262 
1263   GST_LOG_OBJECT (enc,
1264       &quot;buffer after segment clipping has size %&quot; G_GSIZE_FORMAT &quot; with ts %&quot;
1265       GST_TIME_FORMAT &quot;, duration %&quot; GST_TIME_FORMAT, size,
1266       GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buffer)),
1267       GST_TIME_ARGS (GST_BUFFER_DURATION (buffer)));
1268 
1269   if (!GST_CLOCK_TIME_IS_VALID (priv-&gt;base_ts)) {
1270     priv-&gt;base_ts = GST_BUFFER_TIMESTAMP (buffer);
1271     GST_DEBUG_OBJECT (enc, &quot;new base ts %&quot; GST_TIME_FORMAT,
1272         GST_TIME_ARGS (priv-&gt;base_ts));
1273     gst_audio_encoder_set_base_gp (enc);
1274   }
1275 
1276   /* check for continuity;
1277    * checked elsewhere in non-perfect case */
1278   if (enc-&gt;priv-&gt;perfect_ts) {
1279     GstClockTimeDiff diff = 0;
1280     GstClockTime next_ts = 0;
1281 
1282     if (GST_BUFFER_TIMESTAMP_IS_VALID (buffer) &amp;&amp;
1283         GST_CLOCK_TIME_IS_VALID (priv-&gt;base_ts)) {
1284       guint64 samples;
1285 
1286       samples = priv-&gt;samples +
1287           gst_adapter_available (priv-&gt;adapter) / ctx-&gt;info.bpf;
1288       next_ts = priv-&gt;base_ts +
1289           gst_util_uint64_scale (samples, GST_SECOND, ctx-&gt;info.rate);
1290       GST_LOG_OBJECT (enc, &quot;buffer is %&quot; G_GUINT64_FORMAT
1291           &quot; samples past base_ts %&quot; GST_TIME_FORMAT
1292           &quot;, expected ts %&quot; GST_TIME_FORMAT, samples,
1293           GST_TIME_ARGS (priv-&gt;base_ts), GST_TIME_ARGS (next_ts));
1294       diff = GST_CLOCK_DIFF (next_ts, GST_BUFFER_TIMESTAMP (buffer));
1295       GST_LOG_OBJECT (enc, &quot;ts diff %d ms&quot;, (gint) (diff / GST_MSECOND));
1296       /* if within tolerance,
1297        * discard buffer ts and carry on producing perfect stream,
1298        * otherwise clip or resync to ts */
1299       if (G_UNLIKELY (diff &lt; -enc-&gt;priv-&gt;tolerance ||
1300               diff &gt; enc-&gt;priv-&gt;tolerance)) {
1301         GST_DEBUG_OBJECT (enc, &quot;marked discont&quot;);
1302         discont = TRUE;
1303       }
1304     }
1305 
1306     /* do some fancy tweaking in hard resync case */
1307     if (discont &amp;&amp; enc-&gt;priv-&gt;hard_resync) {
1308       if (diff &lt; 0) {
1309         guint64 diff_bytes;
1310 
1311         GST_WARNING_OBJECT (enc, &quot;Buffer is older than expected ts %&quot;
1312             GST_TIME_FORMAT &quot;.  Clipping buffer&quot;, GST_TIME_ARGS (next_ts));
1313 
1314         diff_bytes =
1315             GST_CLOCK_TIME_TO_FRAMES (-diff, ctx-&gt;info.rate) * ctx-&gt;info.bpf;
1316         if (diff_bytes &gt;= size) {
1317           gst_buffer_unref (buffer);
1318           goto done;
1319         }
1320         buffer = gst_buffer_make_writable (buffer);
1321         gst_buffer_resize (buffer, diff_bytes, size - diff_bytes);
1322 
1323         GST_BUFFER_TIMESTAMP (buffer) += diff;
1324         /* care even less about duration after this */
1325       } else {
1326         /* drain stuff prior to resync */
1327         gst_audio_encoder_drain (enc);
1328       }
1329     }
1330     if (discont) {
1331       /* now re-sync ts */
1332       GstClockTime shift =
1333           gst_util_uint64_scale (gst_adapter_available (priv-&gt;adapter),
1334           GST_SECOND, ctx-&gt;info.rate * ctx-&gt;info.bpf);
1335 
1336       if (G_UNLIKELY (shift &gt; GST_BUFFER_TIMESTAMP (buffer))) {
1337         /* ERROR */
1338         goto wrong_time;
1339       }
1340       /* arrange for newly added samples to come out with the ts
1341        * of the incoming buffer that adds these */
1342       priv-&gt;base_ts = GST_BUFFER_TIMESTAMP (buffer) - shift;
1343       priv-&gt;samples = 0;
1344       gst_audio_encoder_set_base_gp (enc);
1345       priv-&gt;discont |= discont;
1346     }
1347   }
1348 
1349   gst_adapter_push (enc-&gt;priv-&gt;adapter, buffer);
1350   /* new stuff, so we can push subclass again */
1351   enc-&gt;priv-&gt;drained = FALSE;
1352 
1353   ret = gst_audio_encoder_push_buffers (enc, FALSE);
1354 
1355 done:
1356   GST_LOG_OBJECT (enc, &quot;chain leaving&quot;);
1357 
1358   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1359 
1360   return ret;
1361 
1362   /* ERRORS */
1363 not_negotiated:
1364   {
1365     GST_ELEMENT_ERROR (enc, CORE, NEGOTIATION, (NULL),
1366         (&quot;encoder not initialized&quot;));
1367     gst_buffer_unref (buffer);
1368     ret = GST_FLOW_NOT_NEGOTIATED;
1369     goto done;
1370   }
1371 wrong_buffer:
1372   {
1373     GST_ELEMENT_ERROR (enc, STREAM, ENCODE, (NULL),
1374         (&quot;buffer size %&quot; G_GSIZE_FORMAT &quot; not a multiple of %d&quot;,
1375             gst_buffer_get_size (buffer), ctx-&gt;info.bpf));
1376     gst_buffer_unref (buffer);
1377     ret = GST_FLOW_ERROR;
1378     goto done;
1379   }
1380 wrong_time:
1381   {
1382     GST_ELEMENT_ERROR (enc, STREAM, ENCODE, (NULL),
1383         (&quot;buffer going too far back in time&quot;));
1384     gst_buffer_unref (buffer);
1385     ret = GST_FLOW_ERROR;
1386     goto done;
<a name="13" id="anc13"></a><span class="line-modified">1387 }</span>
1388 }
1389 
1390 static gboolean
1391 gst_audio_encoder_sink_setcaps (GstAudioEncoder * enc, GstCaps * caps)
1392 {
1393   GstAudioEncoderClass *klass;
1394   GstAudioEncoderContext *ctx;
1395   GstAudioInfo state;
1396   gboolean res = TRUE;
1397   guint old_rate;
1398 
1399   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
1400 
1401   /* subclass must do something here ... */
1402   g_return_val_if_fail (klass-&gt;set_format != NULL, FALSE);
1403 
1404   ctx = &amp;enc-&gt;priv-&gt;ctx;
1405 
1406   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1407 
1408   GST_DEBUG_OBJECT (enc, &quot;caps: %&quot; GST_PTR_FORMAT, caps);
1409 
1410   if (!gst_caps_is_fixed (caps))
1411     goto refuse_caps;
1412 
1413   if (enc-&gt;priv-&gt;ctx.input_caps
1414       &amp;&amp; gst_caps_is_equal (enc-&gt;priv-&gt;ctx.input_caps, caps))
1415     goto same_caps;
1416 
1417   if (!gst_audio_info_from_caps (&amp;state, caps))
1418     goto refuse_caps;
1419 
1420   if (enc-&gt;priv-&gt;ctx.input_caps &amp;&amp; gst_audio_info_is_equal (&amp;state, &amp;ctx-&gt;info))
1421     goto same_caps;
1422 
1423   /* adjust ts tracking to new sample rate */
1424   old_rate = GST_AUDIO_INFO_RATE (&amp;ctx-&gt;info);
1425   if (GST_CLOCK_TIME_IS_VALID (enc-&gt;priv-&gt;base_ts) &amp;&amp; old_rate) {
1426     enc-&gt;priv-&gt;base_ts +=
1427         GST_FRAMES_TO_CLOCK_TIME (enc-&gt;priv-&gt;samples, old_rate);
1428     enc-&gt;priv-&gt;samples = 0;
1429   }
1430 
1431   /* drain any pending old data stuff */
1432   gst_audio_encoder_drain (enc);
1433 
1434   /* context defaults */
1435   /* FIXME 2.0: This is quite unexpected behaviour. We should never
1436    * just reset *settings* of a subclass inside the base class */
1437   enc-&gt;priv-&gt;ctx.frame_samples_min = 0;
1438   enc-&gt;priv-&gt;ctx.frame_samples_max = 0;
1439   enc-&gt;priv-&gt;ctx.frame_max = 0;
1440   enc-&gt;priv-&gt;ctx.lookahead = 0;
1441 
1442   if (klass-&gt;set_format)
1443     res = klass-&gt;set_format (enc, &amp;state);
1444 
1445   if (res) {
1446     GST_OBJECT_LOCK (enc);
1447     ctx-&gt;info = state;
1448     gst_caps_replace (&amp;enc-&gt;priv-&gt;ctx.input_caps, caps);
1449     GST_OBJECT_UNLOCK (enc);
1450   } else {
1451     /* invalidate state to ensure no casual carrying on */
1452     GST_DEBUG_OBJECT (enc, &quot;subclass did not accept format&quot;);
1453     gst_audio_info_init (&amp;state);
1454     goto exit;
1455   }
1456 
1457 exit:
1458 
1459   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1460 
1461   return res;
1462 
1463 same_caps:
1464   {
1465     GST_DEBUG_OBJECT (enc, &quot;new audio format identical to configured format&quot;);
1466     goto exit;
1467   }
1468 
1469   /* ERRORS */
1470 refuse_caps:
1471   {
1472     GST_WARNING_OBJECT (enc, &quot;rejected caps %&quot; GST_PTR_FORMAT, caps);
1473     goto exit;
1474   }
1475 }
1476 
1477 
1478 /**
1479  * gst_audio_encoder_proxy_getcaps:
1480  * @enc: a #GstAudioEncoder
1481  * @caps: (allow-none): initial caps
1482  * @filter: (allow-none): filter caps
1483  *
1484  * Returns caps that express @caps (or sink template caps if @caps == NULL)
1485  * restricted to channel/rate combinations supported by downstream elements
1486  * (e.g. muxers).
1487  *
1488  * Returns: (transfer full): a #GstCaps owned by caller
1489  */
1490 GstCaps *
1491 gst_audio_encoder_proxy_getcaps (GstAudioEncoder * enc, GstCaps * caps,
1492     GstCaps * filter)
1493 {
1494   return __gst_audio_element_proxy_getcaps (GST_ELEMENT_CAST (enc),
1495       GST_AUDIO_ENCODER_SINK_PAD (enc), GST_AUDIO_ENCODER_SRC_PAD (enc),
1496       caps, filter);
<a name="14" id="anc14"></a><span class="line-modified">1497   }</span>
1498 
1499 static GstCaps *
1500 gst_audio_encoder_getcaps_default (GstAudioEncoder * enc, GstCaps * filter)
1501 {
1502   GstCaps *caps;
1503 
1504   caps = gst_audio_encoder_proxy_getcaps (enc, NULL, filter);
1505   GST_LOG_OBJECT (enc, &quot;returning caps %&quot; GST_PTR_FORMAT, caps);
1506 
1507   return caps;
1508 }
1509 
1510 static GList *
1511 _flush_events (GstPad * pad, GList * events)
1512 {
1513   GList *tmp;
1514 
1515   for (tmp = events; tmp; tmp = tmp-&gt;next) {
1516     if (GST_EVENT_TYPE (tmp-&gt;data) != GST_EVENT_EOS &amp;&amp;
1517         GST_EVENT_TYPE (tmp-&gt;data) != GST_EVENT_SEGMENT &amp;&amp;
1518         GST_EVENT_IS_STICKY (tmp-&gt;data)) {
1519       gst_pad_store_sticky_event (pad, GST_EVENT_CAST (tmp-&gt;data));
1520     }
1521     gst_event_unref (tmp-&gt;data);
1522   }
1523   g_list_free (events);
1524 
1525   return NULL;
1526 }
1527 
1528 static gboolean
1529 gst_audio_encoder_sink_event_default (GstAudioEncoder * enc, GstEvent * event)
1530 {
1531   GstAudioEncoderClass *klass;
1532   gboolean res;
1533 
1534   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
1535 
1536   switch (GST_EVENT_TYPE (event)) {
1537     case GST_EVENT_SEGMENT:
1538     {
1539       GstSegment seg;
1540 
1541       gst_event_copy_segment (event, &amp;seg);
1542 
1543       if (seg.format == GST_FORMAT_TIME) {
1544         GST_DEBUG_OBJECT (enc, &quot;received TIME SEGMENT %&quot; GST_SEGMENT_FORMAT,
1545             &amp;seg);
1546       } else {
1547         GST_DEBUG_OBJECT (enc, &quot;received SEGMENT %&quot; GST_SEGMENT_FORMAT, &amp;seg);
1548         GST_DEBUG_OBJECT (enc, &quot;unsupported format; ignoring&quot;);
1549         res = TRUE;
1550         break;
1551       }
1552 
1553       GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1554       /* finish current segment */
1555       gst_audio_encoder_drain (enc);
1556       /* reset partially for new segment */
1557       gst_audio_encoder_reset (enc, FALSE);
1558       /* and follow along with segment */
1559       enc-&gt;input_segment = seg;
1560 
1561       enc-&gt;priv-&gt;pending_events =
1562           g_list_append (enc-&gt;priv-&gt;pending_events, event);
1563       GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1564 
1565       res = TRUE;
1566       break;
1567     }
1568 
1569     case GST_EVENT_FLUSH_START:
1570       res = gst_audio_encoder_push_event (enc, event);
1571       break;
1572 
1573     case GST_EVENT_FLUSH_STOP:
1574       GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1575       /* discard any pending stuff */
1576       /* TODO route through drain ?? */
1577       if (!enc-&gt;priv-&gt;drained &amp;&amp; klass-&gt;flush)
1578         klass-&gt;flush (enc);
1579       /* and get (re)set for the sequel */
1580       gst_audio_encoder_reset (enc, FALSE);
1581 
1582       enc-&gt;priv-&gt;pending_events = _flush_events (enc-&gt;srcpad,
1583           enc-&gt;priv-&gt;pending_events);
1584       GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1585 
1586       res = gst_audio_encoder_push_event (enc, event);
1587       break;
1588 
1589     case GST_EVENT_EOS:
1590       GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1591       gst_audio_encoder_drain (enc);
1592 
1593       /* check for pending events and tags */
1594       gst_audio_encoder_push_pending_events (enc);
1595       gst_audio_encoder_check_and_push_pending_tags (enc);
1596 
1597       GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1598 
1599       /* forward immediately because no buffer or serialized event
1600        * will come after EOS and nothing could trigger another
1601        * _finish_frame() call. */
1602       res = gst_audio_encoder_push_event (enc, event);
1603       break;
1604 
1605     case GST_EVENT_CAPS:
1606     {
1607       GstCaps *caps;
1608 
1609       gst_event_parse_caps (event, &amp;caps);
1610       enc-&gt;priv-&gt;do_caps = TRUE;
1611       res = TRUE;
1612       gst_event_unref (event);
1613       break;
1614     }
1615 
1616     case GST_EVENT_STREAM_START:
1617     {
1618       GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1619       /* Flush upstream tags after a STREAM_START */
1620       GST_DEBUG_OBJECT (enc, &quot;received STREAM_START. Clearing taglist&quot;);
1621       if (enc-&gt;priv-&gt;upstream_tags) {
1622         gst_tag_list_unref (enc-&gt;priv-&gt;upstream_tags);
1623         enc-&gt;priv-&gt;upstream_tags = NULL;
1624         enc-&gt;priv-&gt;tags_changed = TRUE;
1625       }
1626       GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1627       res = gst_audio_encoder_push_event (enc, event);
1628       break;
1629     }
1630 
1631     case GST_EVENT_TAG:
1632     {
1633       GstTagList *tags;
1634 
1635       gst_event_parse_tag (event, &amp;tags);
1636 
1637       if (gst_tag_list_get_scope (tags) == GST_TAG_SCOPE_STREAM) {
1638         GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1639         if (enc-&gt;priv-&gt;upstream_tags != tags) {
<a name="15" id="anc15"></a><span class="line-modified">1640         tags = gst_tag_list_copy (tags);</span>
<span class="line-modified">1641 </span>
<span class="line-modified">1642         /* FIXME: make generic based on GST_TAG_FLAG_ENCODED */</span>
<span class="line-modified">1643         gst_tag_list_remove_tag (tags, GST_TAG_CODEC);</span>
<span class="line-modified">1644         gst_tag_list_remove_tag (tags, GST_TAG_AUDIO_CODEC);</span>
<span class="line-modified">1645         gst_tag_list_remove_tag (tags, GST_TAG_VIDEO_CODEC);</span>
<span class="line-modified">1646         gst_tag_list_remove_tag (tags, GST_TAG_SUBTITLE_CODEC);</span>
<span class="line-modified">1647         gst_tag_list_remove_tag (tags, GST_TAG_CONTAINER_FORMAT);</span>
<span class="line-modified">1648         gst_tag_list_remove_tag (tags, GST_TAG_BITRATE);</span>
<span class="line-modified">1649         gst_tag_list_remove_tag (tags, GST_TAG_NOMINAL_BITRATE);</span>
<span class="line-modified">1650         gst_tag_list_remove_tag (tags, GST_TAG_MAXIMUM_BITRATE);</span>
<span class="line-modified">1651         gst_tag_list_remove_tag (tags, GST_TAG_MINIMUM_BITRATE);</span>
<span class="line-modified">1652         gst_tag_list_remove_tag (tags, GST_TAG_ENCODER);</span>
<span class="line-modified">1653         gst_tag_list_remove_tag (tags, GST_TAG_ENCODER_VERSION);</span>
1654 
1655           if (enc-&gt;priv-&gt;upstream_tags)
1656             gst_tag_list_unref (enc-&gt;priv-&gt;upstream_tags);
1657           enc-&gt;priv-&gt;upstream_tags = tags;
1658           GST_INFO_OBJECT (enc, &quot;upstream stream tags: %&quot; GST_PTR_FORMAT, tags);
1659         }
1660         gst_event_unref (event);
1661         event = gst_audio_encoder_create_merged_tags_event (enc);
1662         GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1663 
1664         /* No tags, go out of here instead of fall through */
1665         if (!event) {
<a name="16" id="anc16"></a><span class="line-modified">1666         res = TRUE;</span>
<span class="line-modified">1667         break;</span>
<span class="line-modified">1668       }</span>
1669       }
1670       /* fall through */
1671     }
1672     default:
1673       /* Forward non-serialized events immediately. */
1674       if (!GST_EVENT_IS_SERIALIZED (event)) {
1675         res =
1676             gst_pad_event_default (enc-&gt;sinkpad, GST_OBJECT_CAST (enc), event);
1677       } else {
1678         GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1679         enc-&gt;priv-&gt;pending_events =
1680             g_list_append (enc-&gt;priv-&gt;pending_events, event);
1681         GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1682         res = TRUE;
1683       }
1684       break;
1685   }
1686   return res;
1687 }
1688 
1689 static gboolean
1690 gst_audio_encoder_sink_event (GstPad * pad, GstObject * parent,
1691     GstEvent * event)
1692 {
1693   GstAudioEncoder *enc;
1694   GstAudioEncoderClass *klass;
1695   gboolean ret;
1696 
1697   enc = GST_AUDIO_ENCODER (parent);
1698   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
1699 
1700   GST_DEBUG_OBJECT (enc, &quot;received event %d, %s&quot;, GST_EVENT_TYPE (event),
1701       GST_EVENT_TYPE_NAME (event));
1702 
1703   if (klass-&gt;sink_event)
1704     ret = klass-&gt;sink_event (enc, event);
1705   else {
1706     gst_event_unref (event);
1707     ret = FALSE;
1708   }
1709 
1710   GST_DEBUG_OBJECT (enc, &quot;event result %d&quot;, ret);
1711 
1712   return ret;
1713 }
1714 
1715 static gboolean
1716 gst_audio_encoder_sink_query_default (GstAudioEncoder * enc, GstQuery * query)
1717 {
1718   GstPad *pad = GST_AUDIO_ENCODER_SINK_PAD (enc);
1719   gboolean res = FALSE;
1720 
1721   switch (GST_QUERY_TYPE (query)) {
1722     case GST_QUERY_FORMATS:
1723     {
1724       gst_query_set_formats (query, 3,
1725           GST_FORMAT_TIME, GST_FORMAT_BYTES, GST_FORMAT_DEFAULT);
1726       res = TRUE;
1727       break;
1728     }
1729     case GST_QUERY_CONVERT:
1730     {
1731       GstFormat src_fmt, dest_fmt;
1732       gint64 src_val, dest_val;
1733 
1734       gst_query_parse_convert (query, &amp;src_fmt, &amp;src_val, &amp;dest_fmt, &amp;dest_val);
1735       GST_OBJECT_LOCK (enc);
1736       res = gst_audio_info_convert (&amp;enc-&gt;priv-&gt;ctx.info,
1737           src_fmt, src_val, dest_fmt, &amp;dest_val);
1738       GST_OBJECT_UNLOCK (enc);
1739       if (!res)
1740         goto error;
1741       gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
1742       res = TRUE;
1743       break;
1744     }
1745     case GST_QUERY_CAPS:
1746     {
1747       GstCaps *filter, *caps;
1748       GstAudioEncoderClass *klass;
1749 
1750       gst_query_parse_caps (query, &amp;filter);
1751 
1752       klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
1753       if (klass-&gt;getcaps) {
1754         caps = klass-&gt;getcaps (enc, filter);
1755         gst_query_set_caps_result (query, caps);
1756         gst_caps_unref (caps);
1757         res = TRUE;
1758       }
1759       break;
1760     }
1761     case GST_QUERY_ALLOCATION:
1762     {
1763       GstAudioEncoderClass *klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
1764 
1765       if (klass-&gt;propose_allocation)
1766         res = klass-&gt;propose_allocation (enc, query);
1767       break;
1768     }
1769     default:
1770       res = gst_pad_query_default (pad, GST_OBJECT (enc), query);
1771       break;
1772   }
1773 
1774 error:
1775   return res;
1776 }
1777 
1778 static gboolean
1779 gst_audio_encoder_sink_query (GstPad * pad, GstObject * parent,
1780     GstQuery * query)
1781 {
1782   GstAudioEncoder *encoder;
1783   GstAudioEncoderClass *encoder_class;
1784   gboolean ret = FALSE;
1785 
1786   encoder = GST_AUDIO_ENCODER (parent);
1787   encoder_class = GST_AUDIO_ENCODER_GET_CLASS (encoder);
1788 
1789   GST_DEBUG_OBJECT (encoder, &quot;received query %d, %s&quot;, GST_QUERY_TYPE (query),
1790       GST_QUERY_TYPE_NAME (query));
1791 
1792   if (encoder_class-&gt;sink_query)
1793     ret = encoder_class-&gt;sink_query (encoder, query);
1794 
1795   return ret;
1796 }
1797 
1798 static gboolean
1799 gst_audio_encoder_src_event_default (GstAudioEncoder * enc, GstEvent * event)
1800 {
1801   gboolean res;
1802 
1803   switch (GST_EVENT_TYPE (event)) {
1804     default:
1805       res = gst_pad_event_default (enc-&gt;srcpad, GST_OBJECT_CAST (enc), event);
1806       break;
1807   }
1808   return res;
1809 }
1810 
1811 static gboolean
1812 gst_audio_encoder_src_event (GstPad * pad, GstObject * parent, GstEvent * event)
1813 {
1814   GstAudioEncoder *enc;
1815   GstAudioEncoderClass *klass;
1816   gboolean ret;
1817 
1818   enc = GST_AUDIO_ENCODER (parent);
1819   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
1820 
1821   GST_DEBUG_OBJECT (enc, &quot;received event %d, %s&quot;, GST_EVENT_TYPE (event),
1822       GST_EVENT_TYPE_NAME (event));
1823 
1824   if (klass-&gt;src_event)
1825     ret = klass-&gt;src_event (enc, event);
1826   else {
1827     gst_event_unref (event);
1828     ret = FALSE;
1829   }
1830 
1831   return ret;
1832 }
1833 
1834 static gboolean
1835 gst_audio_encoder_decide_allocation_default (GstAudioEncoder * enc,
1836     GstQuery * query)
1837 {
1838   GstAllocator *allocator = NULL;
1839   GstAllocationParams params;
1840   gboolean update_allocator;
1841 
1842   /* we got configuration from our peer or the decide_allocation method,
1843    * parse them */
1844   if (gst_query_get_n_allocation_params (query) &gt; 0) {
1845     /* try the allocator */
1846     gst_query_parse_nth_allocation_param (query, 0, &amp;allocator, &amp;params);
1847     update_allocator = TRUE;
1848   } else {
1849     allocator = NULL;
1850     gst_allocation_params_init (&amp;params);
1851     update_allocator = FALSE;
1852   }
1853 
1854   if (update_allocator)
1855     gst_query_set_nth_allocation_param (query, 0, allocator, &amp;params);
1856   else
1857     gst_query_add_allocation_param (query, allocator, &amp;params);
1858   if (allocator)
1859     gst_object_unref (allocator);
1860 
1861   return TRUE;
1862 }
1863 
1864 static gboolean
1865 gst_audio_encoder_propose_allocation_default (GstAudioEncoder * enc,
1866     GstQuery * query)
1867 {
1868   return TRUE;
1869 }
1870 
1871 /* FIXME ? are any of these queries (other than latency) an encoder&#39;s business
1872  * also, the conversion stuff might seem to make sense, but seems to not mind
1873  * segment stuff etc at all
1874  * Supposedly that&#39;s backward compatibility ... */
1875 static gboolean
1876 gst_audio_encoder_src_query_default (GstAudioEncoder * enc, GstQuery * query)
1877 {
1878   GstPad *pad = GST_AUDIO_ENCODER_SRC_PAD (enc);
1879   gboolean res = FALSE;
1880 
1881   GST_LOG_OBJECT (enc, &quot;handling query: %&quot; GST_PTR_FORMAT, query);
1882 
1883   switch (GST_QUERY_TYPE (query)) {
1884     case GST_QUERY_POSITION:
1885     {
1886       GstFormat fmt, req_fmt;
1887       gint64 pos, val;
1888 
1889       if ((res = gst_pad_peer_query (enc-&gt;sinkpad, query))) {
1890         GST_LOG_OBJECT (enc, &quot;returning peer response&quot;);
1891         break;
1892       }
1893 
1894       gst_query_parse_position (query, &amp;req_fmt, NULL);
1895 
1896       /* Refuse BYTES format queries. If it made sense to
1897        *        * answer them, upstream would have already */
1898       if (req_fmt == GST_FORMAT_BYTES) {
1899         GST_LOG_OBJECT (enc, &quot;Ignoring BYTES position query&quot;);
1900         break;
1901       }
1902 
1903       fmt = GST_FORMAT_TIME;
1904       if (!(res = gst_pad_peer_query_position (enc-&gt;sinkpad, fmt, &amp;pos)))
1905         break;
1906 
1907       if ((res =
1908               gst_pad_peer_query_convert (enc-&gt;sinkpad, fmt, pos, req_fmt,
1909                   &amp;val))) {
1910         gst_query_set_position (query, req_fmt, val);
1911       }
1912       break;
1913     }
1914     case GST_QUERY_DURATION:
1915     {
1916       GstFormat fmt, req_fmt;
1917       gint64 dur, val;
1918 
1919       if ((res = gst_pad_peer_query (enc-&gt;sinkpad, query))) {
1920         GST_LOG_OBJECT (enc, &quot;returning peer response&quot;);
1921         break;
1922       }
1923 
1924       gst_query_parse_duration (query, &amp;req_fmt, NULL);
1925 
1926       /* Refuse BYTES format queries. If it made sense to
1927        *        * answer them, upstream would have already */
1928       if (req_fmt == GST_FORMAT_BYTES) {
1929         GST_LOG_OBJECT (enc, &quot;Ignoring BYTES position query&quot;);
1930         break;
1931       }
1932 
1933       fmt = GST_FORMAT_TIME;
1934       if (!(res = gst_pad_peer_query_duration (enc-&gt;sinkpad, fmt, &amp;dur)))
1935         break;
1936 
1937       if ((res =
1938               gst_pad_peer_query_convert (enc-&gt;sinkpad, fmt, dur, req_fmt,
1939                   &amp;val))) {
1940         gst_query_set_duration (query, req_fmt, val);
1941       }
1942       break;
1943     }
1944     case GST_QUERY_FORMATS:
1945     {
1946       gst_query_set_formats (query, 2, GST_FORMAT_TIME, GST_FORMAT_BYTES);
1947       res = TRUE;
1948       break;
1949     }
1950     case GST_QUERY_CONVERT:
1951     {
1952       GstFormat src_fmt, dest_fmt;
1953       gint64 src_val, dest_val;
1954 
1955       gst_query_parse_convert (query, &amp;src_fmt, &amp;src_val, &amp;dest_fmt, &amp;dest_val);
1956       GST_OBJECT_LOCK (enc);
1957       res = __gst_audio_encoded_audio_convert (&amp;enc-&gt;priv-&gt;ctx.info,
<a name="17" id="anc17"></a><span class="line-modified">1958                   enc-&gt;priv-&gt;bytes_out, enc-&gt;priv-&gt;samples_in, src_fmt, src_val,</span>
1959           &amp;dest_fmt, &amp;dest_val);
1960       GST_OBJECT_UNLOCK (enc);
1961       if (!res)
1962         break;
1963       gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
1964       break;
1965     }
1966     case GST_QUERY_LATENCY:
1967     {
1968       if ((res = gst_pad_peer_query (enc-&gt;sinkpad, query))) {
1969         gboolean live;
1970         GstClockTime min_latency, max_latency;
1971 
1972         gst_query_parse_latency (query, &amp;live, &amp;min_latency, &amp;max_latency);
1973         GST_DEBUG_OBJECT (enc, &quot;Peer latency: live %d, min %&quot;
1974             GST_TIME_FORMAT &quot; max %&quot; GST_TIME_FORMAT, live,
1975             GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
1976 
1977         GST_OBJECT_LOCK (enc);
1978         /* add our latency */
<a name="18" id="anc18"></a><span class="line-modified">1979           min_latency += enc-&gt;priv-&gt;ctx.min_latency;</span>
1980         if (max_latency == -1 || enc-&gt;priv-&gt;ctx.max_latency == -1)
1981           max_latency = -1;
1982         else
1983           max_latency += enc-&gt;priv-&gt;ctx.max_latency;
1984         GST_OBJECT_UNLOCK (enc);
1985 
1986         gst_query_set_latency (query, live, min_latency, max_latency);
1987       }
1988       break;
1989     }
1990     default:
1991       res = gst_pad_query_default (pad, GST_OBJECT (enc), query);
1992       break;
1993   }
1994 
1995   return res;
1996 }
1997 
1998 static gboolean
1999 gst_audio_encoder_src_query (GstPad * pad, GstObject * parent, GstQuery * query)
2000 {
2001   GstAudioEncoder *encoder;
2002   GstAudioEncoderClass *encoder_class;
2003   gboolean ret = FALSE;
2004 
2005   encoder = GST_AUDIO_ENCODER (parent);
2006   encoder_class = GST_AUDIO_ENCODER_GET_CLASS (encoder);
2007 
2008   GST_DEBUG_OBJECT (encoder, &quot;received query %d, %s&quot;, GST_QUERY_TYPE (query),
2009       GST_QUERY_TYPE_NAME (query));
2010 
2011   if (encoder_class-&gt;src_query)
2012     ret = encoder_class-&gt;src_query (encoder, query);
2013 
2014   return ret;
2015 }
2016 
2017 
2018 static void
2019 gst_audio_encoder_set_property (GObject * object, guint prop_id,
2020     const GValue * value, GParamSpec * pspec)
2021 {
2022   GstAudioEncoder *enc;
2023 
2024   enc = GST_AUDIO_ENCODER (object);
2025 
2026   switch (prop_id) {
2027     case PROP_PERFECT_TS:
2028       if (enc-&gt;priv-&gt;granule &amp;&amp; !g_value_get_boolean (value))
2029         GST_WARNING_OBJECT (enc, &quot;perfect-timestamp can not be set FALSE &quot;
2030             &quot;while granule handling is enabled&quot;);
2031       else
2032         enc-&gt;priv-&gt;perfect_ts = g_value_get_boolean (value);
2033       break;
2034     case PROP_HARD_RESYNC:
2035       enc-&gt;priv-&gt;hard_resync = g_value_get_boolean (value);
2036       break;
2037     case PROP_TOLERANCE:
2038       enc-&gt;priv-&gt;tolerance = g_value_get_int64 (value);
2039       break;
2040     default:
2041       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
2042       break;
2043   }
2044 }
2045 
2046 static void
2047 gst_audio_encoder_get_property (GObject * object, guint prop_id,
2048     GValue * value, GParamSpec * pspec)
2049 {
2050   GstAudioEncoder *enc;
2051 
2052   enc = GST_AUDIO_ENCODER (object);
2053 
2054   switch (prop_id) {
2055     case PROP_PERFECT_TS:
2056       g_value_set_boolean (value, enc-&gt;priv-&gt;perfect_ts);
2057       break;
2058     case PROP_GRANULE:
2059       g_value_set_boolean (value, enc-&gt;priv-&gt;granule);
2060       break;
2061     case PROP_HARD_RESYNC:
2062       g_value_set_boolean (value, enc-&gt;priv-&gt;hard_resync);
2063       break;
2064     case PROP_TOLERANCE:
2065       g_value_set_int64 (value, enc-&gt;priv-&gt;tolerance);
2066       break;
2067     default:
2068       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
2069       break;
2070   }
2071 }
2072 
2073 static gboolean
2074 gst_audio_encoder_activate (GstAudioEncoder * enc, gboolean active)
2075 {
2076   GstAudioEncoderClass *klass;
2077   gboolean result = TRUE;
2078 
2079   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
2080 
2081   g_return_val_if_fail (!enc-&gt;priv-&gt;granule || enc-&gt;priv-&gt;perfect_ts, FALSE);
2082 
2083   GST_DEBUG_OBJECT (enc, &quot;activate %d&quot;, active);
2084 
2085   if (active) {
2086     /* arrange clean state */
2087     gst_audio_encoder_reset (enc, TRUE);
2088 
2089     if (!enc-&gt;priv-&gt;active &amp;&amp; klass-&gt;start)
2090       result = klass-&gt;start (enc);
2091   } else {
2092     /* We must make sure streaming has finished before resetting things
2093      * and calling the ::stop vfunc */
2094     GST_PAD_STREAM_LOCK (enc-&gt;sinkpad);
2095     GST_PAD_STREAM_UNLOCK (enc-&gt;sinkpad);
2096 
2097     if (enc-&gt;priv-&gt;active &amp;&amp; klass-&gt;stop)
2098       result = klass-&gt;stop (enc);
2099 
2100     /* clean up */
2101     gst_audio_encoder_reset (enc, TRUE);
2102   }
2103   GST_DEBUG_OBJECT (enc, &quot;activate return: %d&quot;, result);
2104   return result;
2105 }
2106 
2107 
2108 static gboolean
2109 gst_audio_encoder_sink_activate_mode (GstPad * pad, GstObject * parent,
2110     GstPadMode mode, gboolean active)
2111 {
2112   gboolean result = TRUE;
2113   GstAudioEncoder *enc;
2114 
2115   enc = GST_AUDIO_ENCODER (parent);
2116 
2117   GST_DEBUG_OBJECT (enc, &quot;sink activate push %d&quot;, active);
2118 
2119   result = gst_audio_encoder_activate (enc, active);
2120 
2121   if (result)
2122     enc-&gt;priv-&gt;active = active;
2123 
2124   GST_DEBUG_OBJECT (enc, &quot;sink activate push return: %d&quot;, result);
2125 
2126   return result;
2127 }
2128 
2129 /**
2130  * gst_audio_encoder_get_audio_info:
2131  * @enc: a #GstAudioEncoder
2132  *
2133  * Returns: a #GstAudioInfo describing the input audio format
2134  */
2135 GstAudioInfo *
2136 gst_audio_encoder_get_audio_info (GstAudioEncoder * enc)
2137 {
2138   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), NULL);
2139 
2140   return &amp;enc-&gt;priv-&gt;ctx.info;
2141 }
2142 
2143 /**
2144  * gst_audio_encoder_set_frame_samples_min:
2145  * @enc: a #GstAudioEncoder
2146  * @num: number of samples per frame
2147  *
2148  * Sets number of samples (per channel) subclass needs to be handed,
2149  * at least or will be handed all available if 0.
2150  *
2151  * If an exact number of samples is required, gst_audio_encoder_set_frame_samples_max()
2152  * must be called with the same number.
2153  *
2154  * Note: This value will be reset to 0 every time before
<a name="19" id="anc19"></a><span class="line-modified">2155  * GstAudioEncoder::set_format() is called.</span>
2156  */
2157 void
2158 gst_audio_encoder_set_frame_samples_min (GstAudioEncoder * enc, gint num)
2159 {
2160   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2161 
2162   enc-&gt;priv-&gt;ctx.frame_samples_min = num;
2163   GST_LOG_OBJECT (enc, &quot;set to %d&quot;, num);
2164 }
2165 
2166 /**
2167  * gst_audio_encoder_get_frame_samples_min:
2168  * @enc: a #GstAudioEncoder
2169  *
2170  * Returns: currently minimum requested samples per frame
2171  */
2172 gint
2173 gst_audio_encoder_get_frame_samples_min (GstAudioEncoder * enc)
2174 {
2175   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2176 
2177   return enc-&gt;priv-&gt;ctx.frame_samples_min;
2178 }
2179 
2180 /**
2181  * gst_audio_encoder_set_frame_samples_max:
2182  * @enc: a #GstAudioEncoder
2183  * @num: number of samples per frame
2184  *
2185  * Sets number of samples (per channel) subclass needs to be handed,
2186  * at most or will be handed all available if 0.
2187  *
2188  * If an exact number of samples is required, gst_audio_encoder_set_frame_samples_min()
2189  * must be called with the same number.
2190  *
2191  * Note: This value will be reset to 0 every time before
<a name="20" id="anc20"></a><span class="line-modified">2192  * GstAudioEncoder::set_format() is called.</span>
2193  */
2194 void
2195 gst_audio_encoder_set_frame_samples_max (GstAudioEncoder * enc, gint num)
2196 {
2197   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2198 
2199   enc-&gt;priv-&gt;ctx.frame_samples_max = num;
2200   GST_LOG_OBJECT (enc, &quot;set to %d&quot;, num);
2201 }
2202 
2203 /**
2204  * gst_audio_encoder_get_frame_samples_max:
2205  * @enc: a #GstAudioEncoder
2206  *
2207  * Returns: currently maximum requested samples per frame
2208  */
2209 gint
2210 gst_audio_encoder_get_frame_samples_max (GstAudioEncoder * enc)
2211 {
2212   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2213 
2214   return enc-&gt;priv-&gt;ctx.frame_samples_max;
2215 }
2216 
2217 /**
2218  * gst_audio_encoder_set_frame_max:
2219  * @enc: a #GstAudioEncoder
2220  * @num: number of frames
2221  *
2222  * Sets max number of frames accepted at once (assumed minimally 1).
2223  * Requires @frame_samples_min and @frame_samples_max to be the equal.
2224  *
2225  * Note: This value will be reset to 0 every time before
<a name="21" id="anc21"></a><span class="line-modified">2226  * GstAudioEncoder::set_format() is called.</span>
2227  */
2228 void
2229 gst_audio_encoder_set_frame_max (GstAudioEncoder * enc, gint num)
2230 {
2231   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2232 
2233   enc-&gt;priv-&gt;ctx.frame_max = num;
2234   GST_LOG_OBJECT (enc, &quot;set to %d&quot;, num);
2235 }
2236 
2237 /**
2238  * gst_audio_encoder_get_frame_max:
2239  * @enc: a #GstAudioEncoder
2240  *
2241  * Returns: currently configured maximum handled frames
2242  */
2243 gint
2244 gst_audio_encoder_get_frame_max (GstAudioEncoder * enc)
2245 {
2246   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2247 
2248   return enc-&gt;priv-&gt;ctx.frame_max;
2249 }
2250 
2251 /**
2252  * gst_audio_encoder_set_lookahead:
2253  * @enc: a #GstAudioEncoder
2254  * @num: lookahead
2255  *
2256  * Sets encoder lookahead (in units of input rate samples)
2257  *
2258  * Note: This value will be reset to 0 every time before
<a name="22" id="anc22"></a><span class="line-modified">2259  * GstAudioEncoder::set_format() is called.</span>
2260  */
2261 void
2262 gst_audio_encoder_set_lookahead (GstAudioEncoder * enc, gint num)
2263 {
2264   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2265 
2266   enc-&gt;priv-&gt;ctx.lookahead = num;
2267   GST_LOG_OBJECT (enc, &quot;set to %d&quot;, num);
2268 }
2269 
2270 /**
2271  * gst_audio_encoder_get_lookahead:
2272  * @enc: a #GstAudioEncoder
2273  *
2274  * Returns: currently configured encoder lookahead
2275  */
2276 gint
2277 gst_audio_encoder_get_lookahead (GstAudioEncoder * enc)
2278 {
2279   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2280 
2281   return enc-&gt;priv-&gt;ctx.lookahead;
2282 }
2283 
2284 /**
2285  * gst_audio_encoder_set_latency:
2286  * @enc: a #GstAudioEncoder
2287  * @min: minimum latency
2288  * @max: maximum latency
2289  *
2290  * Sets encoder latency.
2291  */
2292 void
2293 gst_audio_encoder_set_latency (GstAudioEncoder * enc,
2294     GstClockTime min, GstClockTime max)
2295 {
2296   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2297   g_return_if_fail (GST_CLOCK_TIME_IS_VALID (min));
2298   g_return_if_fail (min &lt;= max);
2299 
2300   GST_OBJECT_LOCK (enc);
2301   enc-&gt;priv-&gt;ctx.min_latency = min;
2302   enc-&gt;priv-&gt;ctx.max_latency = max;
2303   GST_OBJECT_UNLOCK (enc);
2304 
2305   GST_LOG_OBJECT (enc, &quot;set to %&quot; GST_TIME_FORMAT &quot;-%&quot; GST_TIME_FORMAT,
2306       GST_TIME_ARGS (min), GST_TIME_ARGS (max));
2307 
2308   /* post latency message on the bus */
2309   gst_element_post_message (GST_ELEMENT (enc),
2310       gst_message_new_latency (GST_OBJECT (enc)));
2311 }
2312 
2313 /**
2314  * gst_audio_encoder_get_latency:
2315  * @enc: a #GstAudioEncoder
2316  * @min: (out) (allow-none): a pointer to storage to hold minimum latency
2317  * @max: (out) (allow-none): a pointer to storage to hold maximum latency
2318  *
2319  * Sets the variables pointed to by @min and @max to the currently configured
2320  * latency.
2321  */
2322 void
2323 gst_audio_encoder_get_latency (GstAudioEncoder * enc,
2324     GstClockTime * min, GstClockTime * max)
2325 {
2326   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2327 
2328   GST_OBJECT_LOCK (enc);
2329   if (min)
2330     *min = enc-&gt;priv-&gt;ctx.min_latency;
2331   if (max)
2332     *max = enc-&gt;priv-&gt;ctx.max_latency;
2333   GST_OBJECT_UNLOCK (enc);
2334 }
2335 
2336 /**
2337  * gst_audio_encoder_set_headers:
2338  * @enc: a #GstAudioEncoder
2339  * @headers: (transfer full) (element-type Gst.Buffer): a list of
2340  *   #GstBuffer containing the codec header
2341  *
2342  * Set the codec headers to be sent downstream whenever requested.
2343  */
2344 void
2345 gst_audio_encoder_set_headers (GstAudioEncoder * enc, GList * headers)
2346 {
2347   GST_DEBUG_OBJECT (enc, &quot;new headers %p&quot;, headers);
2348 
2349   if (enc-&gt;priv-&gt;ctx.headers) {
2350     g_list_foreach (enc-&gt;priv-&gt;ctx.headers, (GFunc) gst_buffer_unref, NULL);
2351     g_list_free (enc-&gt;priv-&gt;ctx.headers);
2352   }
2353   enc-&gt;priv-&gt;ctx.headers = headers;
2354   enc-&gt;priv-&gt;ctx.new_headers = TRUE;
2355 }
2356 
2357 /**
2358  * gst_audio_encoder_set_allocation_caps:
2359  * @enc: a #GstAudioEncoder
2360  * @allocation_caps: (allow-none): a #GstCaps or %NULL
2361  *
2362  * Sets a caps in allocation query which are different from the set
2363  * pad&#39;s caps. Use this function before calling
2364  * gst_audio_encoder_negotiate(). Setting to %NULL the allocation
2365  * query will use the caps from the pad.
2366  *
2367  * Since: 1.10
2368  */
2369 void
2370 gst_audio_encoder_set_allocation_caps (GstAudioEncoder * enc,
2371     GstCaps * allocation_caps)
2372 {
2373   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2374 
2375   gst_caps_replace (&amp;enc-&gt;priv-&gt;ctx.allocation_caps, allocation_caps);
2376 }
2377 
2378 /**
2379  * gst_audio_encoder_set_mark_granule:
2380  * @enc: a #GstAudioEncoder
2381  * @enabled: new state
2382  *
2383  * Enable or disable encoder granule handling.
2384  *
2385  * MT safe.
2386  */
2387 void
2388 gst_audio_encoder_set_mark_granule (GstAudioEncoder * enc, gboolean enabled)
2389 {
2390   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2391 
2392   GST_LOG_OBJECT (enc, &quot;enabled: %d&quot;, enabled);
2393 
2394   GST_OBJECT_LOCK (enc);
2395   enc-&gt;priv-&gt;granule = enabled;
2396   GST_OBJECT_UNLOCK (enc);
2397 }
2398 
2399 /**
2400  * gst_audio_encoder_get_mark_granule:
2401  * @enc: a #GstAudioEncoder
2402  *
2403  * Queries if the encoder will handle granule marking.
2404  *
2405  * Returns: TRUE if granule marking is enabled.
2406  *
2407  * MT safe.
2408  */
2409 gboolean
2410 gst_audio_encoder_get_mark_granule (GstAudioEncoder * enc)
2411 {
2412   gboolean result;
2413 
2414   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), FALSE);
2415 
2416   GST_OBJECT_LOCK (enc);
2417   result = enc-&gt;priv-&gt;granule;
2418   GST_OBJECT_UNLOCK (enc);
2419 
2420   return result;
2421 }
2422 
2423 /**
2424  * gst_audio_encoder_set_perfect_timestamp:
2425  * @enc: a #GstAudioEncoder
2426  * @enabled: new state
2427  *
2428  * Enable or disable encoder perfect output timestamp preference.
2429  *
2430  * MT safe.
2431  */
2432 void
2433 gst_audio_encoder_set_perfect_timestamp (GstAudioEncoder * enc,
2434     gboolean enabled)
2435 {
2436   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2437 
2438   GST_LOG_OBJECT (enc, &quot;enabled: %d&quot;, enabled);
2439 
2440   GST_OBJECT_LOCK (enc);
2441   enc-&gt;priv-&gt;perfect_ts = enabled;
2442   GST_OBJECT_UNLOCK (enc);
2443 }
2444 
2445 /**
2446  * gst_audio_encoder_get_perfect_timestamp:
2447  * @enc: a #GstAudioEncoder
2448  *
2449  * Queries encoder perfect timestamp behaviour.
2450  *
2451  * Returns: TRUE if perfect timestamp setting enabled.
2452  *
2453  * MT safe.
2454  */
2455 gboolean
2456 gst_audio_encoder_get_perfect_timestamp (GstAudioEncoder * enc)
2457 {
2458   gboolean result;
2459 
2460   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), FALSE);
2461 
2462   GST_OBJECT_LOCK (enc);
2463   result = enc-&gt;priv-&gt;perfect_ts;
2464   GST_OBJECT_UNLOCK (enc);
2465 
2466   return result;
2467 }
2468 
2469 /**
2470  * gst_audio_encoder_set_hard_sync:
2471  * @enc: a #GstAudioEncoder
2472  * @enabled: new state
2473  *
2474  * Sets encoder hard resync handling.
2475  *
2476  * MT safe.
2477  */
2478 void
2479 gst_audio_encoder_set_hard_resync (GstAudioEncoder * enc, gboolean enabled)
2480 {
2481   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2482 
2483   GST_LOG_OBJECT (enc, &quot;enabled: %d&quot;, enabled);
2484 
2485   GST_OBJECT_LOCK (enc);
2486   enc-&gt;priv-&gt;hard_resync = enabled;
2487   GST_OBJECT_UNLOCK (enc);
2488 }
2489 
2490 /**
2491  * gst_audio_encoder_get_hard_sync:
2492  * @enc: a #GstAudioEncoder
2493  *
2494  * Queries encoder&#39;s hard resync setting.
2495  *
2496  * Returns: TRUE if hard resync is enabled.
2497  *
2498  * MT safe.
2499  */
2500 gboolean
2501 gst_audio_encoder_get_hard_resync (GstAudioEncoder * enc)
2502 {
2503   gboolean result;
2504 
2505   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), FALSE);
2506 
2507   GST_OBJECT_LOCK (enc);
2508   result = enc-&gt;priv-&gt;hard_resync;
2509   GST_OBJECT_UNLOCK (enc);
2510 
2511   return result;
2512 }
2513 
2514 /**
2515  * gst_audio_encoder_set_tolerance:
2516  * @enc: a #GstAudioEncoder
2517  * @tolerance: new tolerance
2518  *
2519  * Configures encoder audio jitter tolerance threshold.
2520  *
2521  * MT safe.
2522  */
2523 void
2524 gst_audio_encoder_set_tolerance (GstAudioEncoder * enc, GstClockTime tolerance)
2525 {
2526   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2527 
2528   GST_OBJECT_LOCK (enc);
2529   enc-&gt;priv-&gt;tolerance = tolerance;
2530   GST_OBJECT_UNLOCK (enc);
2531 
2532   GST_LOG_OBJECT (enc, &quot;set to %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (tolerance));
2533 }
2534 
2535 /**
2536  * gst_audio_encoder_get_tolerance:
2537  * @enc: a #GstAudioEncoder
2538  *
2539  * Queries current audio jitter tolerance threshold.
2540  *
2541  * Returns: encoder audio jitter tolerance threshold.
2542  *
2543  * MT safe.
2544  */
2545 GstClockTime
2546 gst_audio_encoder_get_tolerance (GstAudioEncoder * enc)
2547 {
2548   GstClockTime result;
2549 
2550   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2551 
2552   GST_OBJECT_LOCK (enc);
2553   result = enc-&gt;priv-&gt;tolerance;
2554   GST_OBJECT_UNLOCK (enc);
2555 
2556   return result;
2557 }
2558 
2559 /**
2560  * gst_audio_encoder_set_hard_min:
2561  * @enc: a #GstAudioEncoder
2562  * @enabled: new state
2563  *
2564  * Configures encoder hard minimum handling.  If enabled, subclass
2565  * will never be handed less samples than it configured, which otherwise
2566  * might occur near end-of-data handling.  Instead, the leftover samples
2567  * will simply be discarded.
2568  *
2569  * MT safe.
2570  */
2571 void
2572 gst_audio_encoder_set_hard_min (GstAudioEncoder * enc, gboolean enabled)
2573 {
2574   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2575 
2576   GST_OBJECT_LOCK (enc);
2577   enc-&gt;priv-&gt;hard_min = enabled;
2578   GST_OBJECT_UNLOCK (enc);
2579 }
2580 
2581 /**
2582  * gst_audio_encoder_get_hard_min:
2583  * @enc: a #GstAudioEncoder
2584  *
2585  * Queries encoder hard minimum handling.
2586  *
2587  * Returns: TRUE if hard minimum handling is enabled.
2588  *
2589  * MT safe.
2590  */
2591 gboolean
2592 gst_audio_encoder_get_hard_min (GstAudioEncoder * enc)
2593 {
2594   gboolean result;
2595 
2596   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2597 
2598   GST_OBJECT_LOCK (enc);
2599   result = enc-&gt;priv-&gt;hard_min;
2600   GST_OBJECT_UNLOCK (enc);
2601 
2602   return result;
2603 }
2604 
2605 /**
2606  * gst_audio_encoder_set_drainable:
2607  * @enc: a #GstAudioEncoder
2608  * @enabled: new state
2609  *
2610  * Configures encoder drain handling.  If drainable, subclass might
2611  * be handed a NULL buffer to have it return any leftover encoded data.
2612  * Otherwise, it is not considered so capable and will only ever be passed
2613  * real data.
2614  *
2615  * MT safe.
2616  */
2617 void
2618 gst_audio_encoder_set_drainable (GstAudioEncoder * enc, gboolean enabled)
2619 {
2620   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2621 
2622   GST_OBJECT_LOCK (enc);
2623   enc-&gt;priv-&gt;drainable = enabled;
2624   GST_OBJECT_UNLOCK (enc);
2625 }
2626 
2627 /**
2628  * gst_audio_encoder_get_drainable:
2629  * @enc: a #GstAudioEncoder
2630  *
2631  * Queries encoder drain handling.
2632  *
2633  * Returns: TRUE if drainable handling is enabled.
2634  *
2635  * MT safe.
2636  */
2637 gboolean
2638 gst_audio_encoder_get_drainable (GstAudioEncoder * enc)
2639 {
2640   gboolean result;
2641 
2642   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2643 
2644   GST_OBJECT_LOCK (enc);
2645   result = enc-&gt;priv-&gt;drainable;
2646   GST_OBJECT_UNLOCK (enc);
2647 
2648   return result;
2649 }
2650 
2651 /**
2652  * gst_audio_encoder_merge_tags:
2653  * @enc: a #GstAudioEncoder
2654  * @tags: (allow-none): a #GstTagList to merge, or NULL to unset
2655  *     previously-set tags
2656  * @mode: the #GstTagMergeMode to use, usually #GST_TAG_MERGE_REPLACE
2657  *
2658  * Sets the audio encoder tags and how they should be merged with any
2659  * upstream stream tags. This will override any tags previously-set
2660  * with gst_audio_encoder_merge_tags().
2661  *
2662  * Note that this is provided for convenience, and the subclass is
2663  * not required to use this and can still do tag handling on its own.
2664  *
2665  * MT safe.
2666  */
2667 void
2668 gst_audio_encoder_merge_tags (GstAudioEncoder * enc,
2669     const GstTagList * tags, GstTagMergeMode mode)
2670 {
2671   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2672   g_return_if_fail (tags == NULL || GST_IS_TAG_LIST (tags));
2673   g_return_if_fail (tags == NULL || mode != GST_TAG_MERGE_UNDEFINED);
2674 
2675   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
2676   if (enc-&gt;priv-&gt;tags != tags) {
2677     if (enc-&gt;priv-&gt;tags) {
2678       gst_tag_list_unref (enc-&gt;priv-&gt;tags);
2679       enc-&gt;priv-&gt;tags = NULL;
2680       enc-&gt;priv-&gt;tags_merge_mode = GST_TAG_MERGE_APPEND;
2681     }
2682     if (tags) {
2683       enc-&gt;priv-&gt;tags = gst_tag_list_ref ((GstTagList *) tags);
2684       enc-&gt;priv-&gt;tags_merge_mode = mode;
2685     }
2686 
2687     GST_DEBUG_OBJECT (enc, &quot;setting encoder tags to %&quot; GST_PTR_FORMAT, tags);
<a name="23" id="anc23"></a><span class="line-modified">2688   enc-&gt;priv-&gt;tags_changed = TRUE;</span>
2689   }
2690   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
2691 }
2692 
2693 static gboolean
2694 gst_audio_encoder_negotiate_default (GstAudioEncoder * enc)
2695 {
2696   GstAudioEncoderClass *klass;
2697   gboolean res = TRUE;
2698   GstQuery *query = NULL;
2699   GstAllocator *allocator;
2700   GstAllocationParams params;
2701   GstCaps *caps, *prevcaps;
2702 
2703   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), FALSE);
2704   g_return_val_if_fail (GST_IS_CAPS (enc-&gt;priv-&gt;ctx.caps), FALSE);
2705 
2706   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
2707 
2708   caps = enc-&gt;priv-&gt;ctx.caps;
2709   if (enc-&gt;priv-&gt;ctx.allocation_caps == NULL)
2710     enc-&gt;priv-&gt;ctx.allocation_caps = gst_caps_ref (caps);
2711 
2712   GST_DEBUG_OBJECT (enc, &quot;Setting srcpad caps %&quot; GST_PTR_FORMAT, caps);
2713 
2714   if (enc-&gt;priv-&gt;pending_events) {
2715     GList **pending_events, *l;
2716 
2717     pending_events = &amp;enc-&gt;priv-&gt;pending_events;
2718 
2719     GST_DEBUG_OBJECT (enc, &quot;Pushing pending events&quot;);
2720     for (l = *pending_events; l;) {
2721       GstEvent *event = GST_EVENT (l-&gt;data);
2722       GList *tmp;
2723 
2724       if (GST_EVENT_TYPE (event) &lt; GST_EVENT_CAPS) {
2725         gst_audio_encoder_push_event (enc, l-&gt;data);
2726         tmp = l;
2727         l = l-&gt;next;
2728         *pending_events = g_list_delete_link (*pending_events, tmp);
2729       } else {
2730         l = l-&gt;next;
2731       }
2732     }
2733   }
2734 
2735   prevcaps = gst_pad_get_current_caps (enc-&gt;srcpad);
2736   if (!prevcaps || !gst_caps_is_equal (prevcaps, caps))
2737     res = gst_pad_set_caps (enc-&gt;srcpad, caps);
2738   if (prevcaps)
2739     gst_caps_unref (prevcaps);
2740 
2741   if (!res)
2742     goto done;
2743   enc-&gt;priv-&gt;ctx.output_caps_changed = FALSE;
2744 
2745   query = gst_query_new_allocation (enc-&gt;priv-&gt;ctx.allocation_caps, TRUE);
2746   if (!gst_pad_peer_query (enc-&gt;srcpad, query)) {
2747     GST_DEBUG_OBJECT (enc, &quot;didn&#39;t get downstream ALLOCATION hints&quot;);
2748   }
2749 
2750   g_assert (klass-&gt;decide_allocation != NULL);
2751   res = klass-&gt;decide_allocation (enc, query);
2752 
2753   GST_DEBUG_OBJECT (enc, &quot;ALLOCATION (%d) params: %&quot; GST_PTR_FORMAT, res,
2754       query);
2755 
2756   if (!res)
2757     goto no_decide_allocation;
2758 
2759   /* we got configuration from our peer or the decide_allocation method,
2760    * parse them */
2761   if (gst_query_get_n_allocation_params (query) &gt; 0) {
2762     gst_query_parse_nth_allocation_param (query, 0, &amp;allocator, &amp;params);
2763   } else {
2764     allocator = NULL;
2765     gst_allocation_params_init (&amp;params);
2766   }
2767 
2768   if (enc-&gt;priv-&gt;ctx.allocator)
2769     gst_object_unref (enc-&gt;priv-&gt;ctx.allocator);
2770   enc-&gt;priv-&gt;ctx.allocator = allocator;
2771   enc-&gt;priv-&gt;ctx.params = params;
2772 
2773 done:
2774   if (query)
2775     gst_query_unref (query);
2776 
2777   return res;
2778 
2779   /* ERRORS */
2780 no_decide_allocation:
2781   {
2782     GST_WARNING_OBJECT (enc, &quot;Subclass failed to decide allocation&quot;);
2783     goto done;
2784   }
2785 }
2786 
2787 static gboolean
2788 gst_audio_encoder_negotiate_unlocked (GstAudioEncoder * enc)
2789 {
2790   GstAudioEncoderClass *klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
2791   gboolean ret = TRUE;
2792 
2793   if (G_LIKELY (klass-&gt;negotiate))
2794     ret = klass-&gt;negotiate (enc);
2795 
2796   return ret;
2797 }
2798 
2799 /**
2800  * gst_audio_encoder_negotiate:
2801  * @enc: a #GstAudioEncoder
2802  *
2803  * Negotiate with downstream elements to currently configured #GstCaps.
2804  * Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it again if
2805  * negotiate fails.
2806  *
2807  * Returns: %TRUE if the negotiation succeeded, else %FALSE.
2808  */
2809 gboolean
2810 gst_audio_encoder_negotiate (GstAudioEncoder * enc)
2811 {
2812   GstAudioEncoderClass *klass;
2813   gboolean ret = TRUE;
2814 
2815   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), FALSE);
2816 
2817   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
2818 
2819   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
2820   gst_pad_check_reconfigure (enc-&gt;srcpad);
2821   if (klass-&gt;negotiate) {
2822     ret = klass-&gt;negotiate (enc);
2823     if (!ret)
2824       gst_pad_mark_reconfigure (enc-&gt;srcpad);
2825   }
2826   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
2827 
2828   return ret;
2829 }
2830 
2831 /**
2832  * gst_audio_encoder_set_output_format:
2833  * @enc: a #GstAudioEncoder
2834  * @caps: (transfer none): #GstCaps
2835  *
2836  * Configure output caps on the srcpad of @enc.
2837  *
2838  * Returns: %TRUE on success.
2839  */
2840 gboolean
2841 gst_audio_encoder_set_output_format (GstAudioEncoder * enc, GstCaps * caps)
2842 {
2843   gboolean res = TRUE;
2844   GstCaps *templ_caps;
2845 
2846   GST_DEBUG_OBJECT (enc, &quot;Setting srcpad caps %&quot; GST_PTR_FORMAT, caps);
2847 
2848   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
2849   if (!gst_caps_is_fixed (caps))
2850     goto refuse_caps;
2851 
2852   /* Only allow caps that are a subset of the template caps */
2853   templ_caps = gst_pad_get_pad_template_caps (enc-&gt;srcpad);
2854   if (!gst_caps_is_subset (caps, templ_caps)) {
2855     gst_caps_unref (templ_caps);
2856     goto refuse_caps;
2857   }
2858   gst_caps_unref (templ_caps);
2859 
2860   gst_caps_replace (&amp;enc-&gt;priv-&gt;ctx.caps, caps);
2861   enc-&gt;priv-&gt;ctx.output_caps_changed = TRUE;
2862 
2863 done:
2864   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
2865 
2866   return res;
2867 
2868   /* ERRORS */
2869 refuse_caps:
2870   {
2871     GST_WARNING_OBJECT (enc, &quot;refused caps %&quot; GST_PTR_FORMAT, caps);
2872     res = FALSE;
2873     goto done;
2874   }
2875 }
2876 
2877 /**
2878  * gst_audio_encoder_allocate_output_buffer:
2879  * @enc: a #GstAudioEncoder
2880  * @size: size of the buffer
2881  *
2882  * Helper function that allocates a buffer to hold an encoded audio frame
2883  * for @enc&#39;s current output format.
2884  *
2885  * Returns: (transfer full): allocated buffer
2886  */
2887 GstBuffer *
2888 gst_audio_encoder_allocate_output_buffer (GstAudioEncoder * enc, gsize size)
2889 {
2890   GstBuffer *buffer = NULL;
2891   gboolean needs_reconfigure = FALSE;
2892 
2893   g_return_val_if_fail (size &gt; 0, NULL);
2894 
2895   GST_DEBUG (&quot;alloc src buffer&quot;);
2896 
2897   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
2898 
2899   needs_reconfigure = gst_pad_check_reconfigure (enc-&gt;srcpad);
2900   if (G_UNLIKELY (enc-&gt;priv-&gt;ctx.output_caps_changed || (enc-&gt;priv-&gt;ctx.caps
2901               &amp;&amp; needs_reconfigure))) {
2902     if (!gst_audio_encoder_negotiate_unlocked (enc)) {
2903       GST_INFO_OBJECT (enc, &quot;Failed to negotiate, fallback allocation&quot;);
2904       gst_pad_mark_reconfigure (enc-&gt;srcpad);
2905       goto fallback;
2906     }
2907   }
2908 
2909   buffer =
2910       gst_buffer_new_allocate (enc-&gt;priv-&gt;ctx.allocator, size,
2911       &amp;enc-&gt;priv-&gt;ctx.params);
2912   if (!buffer) {
2913     GST_INFO_OBJECT (enc, &quot;couldn&#39;t allocate output buffer&quot;);
2914     goto fallback;
2915   }
2916 
2917   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
2918 
2919   return buffer;
2920 
2921 fallback:
2922   buffer = gst_buffer_new_allocate (NULL, size, NULL);
2923   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
2924 
2925   return buffer;
2926 }
2927 
2928 /**
2929  * gst_audio_encoder_get_allocator:
2930  * @enc: a #GstAudioEncoder
2931  * @allocator: (out) (allow-none) (transfer full): the #GstAllocator
2932  * used
2933  * @params: (out) (allow-none) (transfer full): the
<a name="24" id="anc24"></a><span class="line-modified">2934  * #GstAllocatorParams of @allocator</span>
2935  *
2936  * Lets #GstAudioEncoder sub-classes to know the memory @allocator
2937  * used by the base class and its @params.
2938  *
2939  * Unref the @allocator after use it.
2940  */
2941 void
2942 gst_audio_encoder_get_allocator (GstAudioEncoder * enc,
2943     GstAllocator ** allocator, GstAllocationParams * params)
2944 {
2945   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2946 
2947   if (allocator)
2948     *allocator = enc-&gt;priv-&gt;ctx.allocator ?
2949         gst_object_ref (enc-&gt;priv-&gt;ctx.allocator) : NULL;
2950 
2951   if (params)
2952     *params = enc-&gt;priv-&gt;ctx.params;
2953 }
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>