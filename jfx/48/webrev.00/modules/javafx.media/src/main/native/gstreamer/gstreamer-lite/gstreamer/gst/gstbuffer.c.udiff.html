<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstbuffer.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstbin.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstbuffer.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstbuffer.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -111,11 +111,11 @@</span>
   * #GstBuffer is released.
   *
   * Typically, #GstParentBufferMeta is used when the child buffer is directly
   * using the #GstMemory of the parent buffer, and wants to prevent the parent
   * buffer from being returned to a buffer pool until the #GstMemory is available
<span class="udiff-line-modified-removed">-  * for re-use. (Since 1.6)</span>
<span class="udiff-line-modified-added">+  * for re-use. (Since: 1.6)</span>
   *
   */
  #include &quot;gst_private.h&quot;
  
  #ifdef HAVE_UNISTD_H
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -131,27 +131,23 @@</span>
  #include &quot;gstutils.h&quot;
  #include &quot;gstversion.h&quot;
  
  GType _gst_buffer_type = 0;
  
<span class="udiff-line-modified-removed">- typedef struct _GstMetaItem GstMetaItem;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- struct _GstMetaItem</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   GstMetaItem *next;</span>
<span class="udiff-line-removed">-   GstMeta meta;</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- #define ITEM_SIZE(info) ((info)-&gt;size + sizeof (GstMetaItem))</span>
<span class="udiff-line-modified-added">+ /* info-&gt;size will be sizeof(FooMeta) which contains a GstMeta at the beginning</span>
<span class="udiff-line-modified-added">+  * too, and then there is again a GstMeta in GstMetaItem, so subtract one. */</span>
<span class="udiff-line-modified-added">+ #define ITEM_SIZE(info) ((info)-&gt;size + sizeof (GstMetaItem) - sizeof (GstMeta))</span>
  
  #define GST_BUFFER_MEM_MAX         16
  
  #define GST_BUFFER_SLICE_SIZE(b)   (((GstBufferImpl *)(b))-&gt;slice_size)
  #define GST_BUFFER_MEM_LEN(b)      (((GstBufferImpl *)(b))-&gt;len)
  #define GST_BUFFER_MEM_ARRAY(b)    (((GstBufferImpl *)(b))-&gt;mem)
  #define GST_BUFFER_MEM_PTR(b,i)    (((GstBufferImpl *)(b))-&gt;mem[i])
  #define GST_BUFFER_BUFMEM(b)       (((GstBufferImpl *)(b))-&gt;bufmem)
  #define GST_BUFFER_META(b)         (((GstBufferImpl *)(b))-&gt;item)
<span class="udiff-line-added">+ #define GST_BUFFER_TAIL_META(b)    (((GstBufferImpl *)(b))-&gt;tail_item)</span>
  
  typedef struct
  {
    GstBuffer buffer;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -165,12 +161,45 @@</span>
    GstMemory *bufmem;
  
    /* FIXME, make metadata allocation more efficient by using part of the
     * GstBufferImpl */
    GstMetaItem *item;
<span class="udiff-line-added">+   GstMetaItem *tail_item;</span>
  } GstBufferImpl;
  
<span class="udiff-line-added">+ static gint64 meta_seq;         /* 0 *//* ATOMIC */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /* TODO: use GLib&#39;s once https://gitlab.gnome.org/GNOME/glib/issues/1076 lands */</span>
<span class="udiff-line-added">+ #if defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8)</span>
<span class="udiff-line-added">+ static inline gint64</span>
<span class="udiff-line-added">+ gst_atomic_int64_inc (volatile gint64 * atomic)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   return __sync_fetch_and_add (atomic, 1);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #elif defined (G_PLATFORM_WIN32)</span>
<span class="udiff-line-added">+ #include &lt;windows.h&gt;</span>
<span class="udiff-line-added">+ static inline gint64</span>
<span class="udiff-line-added">+ gst_atomic_int64_inc (volatile gint64 * atomic)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   return InterlockedExchangeAdd64 (atomic, 1);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+ #warning No 64-bit atomic int defined for this platform/toolchain!</span>
<span class="udiff-line-added">+ #define NO_64BIT_ATOMIC_INT_FOR_PLATFORM</span>
<span class="udiff-line-added">+ G_LOCK_DEFINE_STATIC (meta_seq);</span>
<span class="udiff-line-added">+ static inline gint64</span>
<span class="udiff-line-added">+ gst_atomic_int64_inc (volatile gint64 * atomic)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   gint64 ret;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   G_LOCK (meta_seq);</span>
<span class="udiff-line-added">+   ret = *atomic++;</span>
<span class="udiff-line-added">+   G_UNLOCK (meta_seq);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return ret;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #endif</span>
  
  static gboolean
  _is_span (GstMemory ** mem, gsize len, gsize * poffset, GstMemory ** parent)
  {
    GstMemory *mcur, *mprv;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -286,15 +315,19 @@</span>
    /* unref old memory */
    for (i = idx; i &lt; end; i++) {
      GstMemory *old = GST_BUFFER_MEM_PTR (buffer, i);
  
      gst_memory_unlock (old, GST_LOCK_FLAG_EXCLUSIVE);
<span class="udiff-line-added">+     gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (old),</span>
<span class="udiff-line-added">+         GST_MINI_OBJECT_CAST (buffer));</span>
      gst_memory_unref (old);
    }
  
    if (mem != NULL) {
      /* replace with single memory */
<span class="udiff-line-added">+     gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (mem),</span>
<span class="udiff-line-added">+         GST_MINI_OBJECT_CAST (buffer));</span>
      gst_memory_lock (mem, GST_LOCK_FLAG_EXCLUSIVE);
      GST_BUFFER_MEM_PTR (buffer, idx) = mem;
      idx++;
      length--;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -433,20 +466,27 @@</span>
      GST_BUFFER_MEM_PTR (buffer, i) = GST_BUFFER_MEM_PTR (buffer, i - 1);
    }
    /* and insert the new buffer */
    GST_BUFFER_MEM_PTR (buffer, idx) = mem;
    GST_BUFFER_MEM_LEN (buffer) = len + 1;
<span class="udiff-line-added">+   gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (mem),</span>
<span class="udiff-line-added">+       GST_MINI_OBJECT_CAST (buffer));</span>
  
    GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
  }
  
  GST_DEFINE_MINI_OBJECT_TYPE (GstBuffer, gst_buffer);
  
  void
  _priv_gst_buffer_initialize (void)
  {
    _gst_buffer_type = gst_buffer_get_type ();
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef NO_64BIT_ATOMIC_INT_FOR_PLATFORM</span>
<span class="udiff-line-added">+   GST_CAT_WARNING (GST_CAT_PERFORMANCE,</span>
<span class="udiff-line-added">+       &quot;No 64-bit atomic int defined for this platform/toolchain!&quot;);</span>
<span class="udiff-line-added">+ #endif</span>
  }
  
  /**
   * gst_buffer_get_max_memory:
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -571,20 +611,20 @@</span>
            /* we need to clip something */
            newmem = gst_memory_share (mem, skip, tocopy);
            if (newmem) {
              gst_memory_lock (newmem, GST_LOCK_FLAG_EXCLUSIVE);
              skip = 0;
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+           }</span>
          }
  
          if (deep || GST_MEMORY_IS_NO_SHARE (mem) || (!newmem &amp;&amp; tocopy &lt; bsize)) {
            /* deep copy or we&#39;re not allowed to share this memory
             * between buffers, always copy then */
            newmem = gst_memory_copy (mem, skip, tocopy);
            if (newmem) {
              gst_memory_lock (newmem, GST_LOCK_FLAG_EXCLUSIVE);
<span class="udiff-line-modified-removed">-           skip = 0;</span>
<span class="udiff-line-modified-added">+             skip = 0;</span>
            }
          } else if (!newmem) {
            newmem = _memory_get_exclusive_reference (mem);
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -638,14 +678,14 @@</span>
          if (!info-&gt;transform_func (dest, meta, src,
                  _gst_meta_transform_copy, &amp;copy_data)) {
            GST_CAT_ERROR (GST_CAT_BUFFER,
                &quot;failed to copy meta %p of API type %s&quot;, meta,
                g_type_name (info-&gt;api));
<span class="udiff-line-added">+         }</span>
        }
      }
    }
<span class="udiff-line-removed">-   }</span>
  
    return TRUE;
  }
  
  static GstBuffer *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -744,10 +784,12 @@</span>
  
    /* free our memory */
    len = GST_BUFFER_MEM_LEN (buffer);
    for (i = 0; i &lt; len; i++) {
      gst_memory_unlock (GST_BUFFER_MEM_PTR (buffer, i), GST_LOCK_FLAG_EXCLUSIVE);
<span class="udiff-line-added">+     gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (GST_BUFFER_MEM_PTR</span>
<span class="udiff-line-added">+             (buffer, i)), GST_MINI_OBJECT_CAST (buffer));</span>
      gst_memory_unref (GST_BUFFER_MEM_PTR (buffer, i));
    }
  
    /* we set msize to 0 when the buffer is part of the memory block */
    if (msize) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -965,10 +1007,37 @@</span>
  gst_buffer_new_wrapped (gpointer data, gsize size)
  {
    return gst_buffer_new_wrapped_full (0, data, size, 0, size, data, g_free);
  }
  
<span class="udiff-line-added">+ /**</span>
<span class="udiff-line-added">+  * gst_buffer_new_wrapped_bytes:</span>
<span class="udiff-line-added">+  * @bytes: (transfer none): a #GBytes to wrap</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Creates a new #GstBuffer that wraps the given @bytes. The data inside</span>
<span class="udiff-line-added">+  * @bytes cannot be %NULL and the resulting buffer will be marked as read only.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * MT safe.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Returns: (transfer full): a new #GstBuffer wrapping @bytes</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Since: 1.16</span>
<span class="udiff-line-added">+  */</span>
<span class="udiff-line-added">+ GstBuffer *</span>
<span class="udiff-line-added">+ gst_buffer_new_wrapped_bytes (GBytes * bytes)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   guint8 *bytes_data;</span>
<span class="udiff-line-added">+   gsize size;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   g_return_val_if_fail (bytes != NULL, NULL);</span>
<span class="udiff-line-added">+   bytes_data = (guint8 *) g_bytes_get_data (bytes, &amp;size);</span>
<span class="udiff-line-added">+   g_return_val_if_fail (bytes_data != NULL, NULL);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return gst_buffer_new_wrapped_full (GST_MEMORY_FLAG_READONLY, bytes_data,</span>
<span class="udiff-line-added">+       size, 0, size, g_bytes_ref (bytes), (GDestroyNotify) g_bytes_unref);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /**
   * gst_buffer_n_memory:
   * @buffer: a #GstBuffer.
   *
   * Get the amount of memory blocks that this buffer has. This amount is never
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1058,14 +1127,18 @@</span>
  
    mapped = gst_memory_make_mapped (mem, info, flags);
  
    if (mapped != mem) {
      /* memory changed, lock new memory */
<span class="udiff-line-added">+     gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (mapped),</span>
<span class="udiff-line-added">+         GST_MINI_OBJECT_CAST (buffer));</span>
      gst_memory_lock (mapped, GST_LOCK_FLAG_EXCLUSIVE);
      GST_BUFFER_MEM_PTR (buffer, idx) = mapped;
      /* unlock old memory */
      gst_memory_unlock (mem, GST_LOCK_FLAG_EXCLUSIVE);
<span class="udiff-line-added">+     gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (mem),</span>
<span class="udiff-line-added">+         GST_MINI_OBJECT_CAST (buffer));</span>
      GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
    }
    gst_memory_unref (mem);
  
    return mapped;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1675,13 +1748,17 @@</span>
            newmem = gst_memory_copy (mem, offset, left);
  
          if (newmem == NULL)
            return FALSE;
  
<span class="udiff-line-added">+         gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (newmem),</span>
<span class="udiff-line-added">+             GST_MINI_OBJECT_CAST (buffer));</span>
          gst_memory_lock (newmem, GST_LOCK_FLAG_EXCLUSIVE);
          GST_BUFFER_MEM_PTR (buffer, i) = newmem;
          gst_memory_unlock (mem, GST_LOCK_FLAG_EXCLUSIVE);
<span class="udiff-line-added">+         gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (mem),</span>
<span class="udiff-line-added">+             GST_MINI_OBJECT_CAST (buffer));</span>
          gst_memory_unref (mem);
  
          GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
        }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2137,10 +2214,12 @@</span>
    len = GST_BUFFER_MEM_LEN (buf2);
    for (i = 0; i &lt; len; i++) {
      GstMemory *mem;
  
      mem = GST_BUFFER_MEM_PTR (buf2, i);
<span class="udiff-line-added">+     gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (mem),</span>
<span class="udiff-line-added">+         GST_MINI_OBJECT_CAST (buf2));</span>
      GST_BUFFER_MEM_PTR (buf2, i) = NULL;
      _memory_add (buf1, -1, mem);
    }
  
    GST_BUFFER_MEM_LEN (buf2) = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2235,11 +2314,11 @@</span>
     * uninitialized memory
     */
    if (!info-&gt;init_func)
      item = g_slice_alloc0 (size);
    else
<span class="udiff-line-modified-removed">-   item = g_slice_alloc (size);</span>
<span class="udiff-line-modified-added">+     item = g_slice_alloc (size);</span>
    result = &amp;item-&gt;meta;
    result-&gt;info = info;
    result-&gt;flags = GST_META_FLAG_NONE;
    GST_CAT_DEBUG (GST_CAT_BUFFER,
        &quot;alloc metadata %p (%s) of size %&quot; G_GSIZE_FORMAT, result,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2248,13 +2327,20 @@</span>
    /* call the init_func when needed */
    if (info-&gt;init_func)
      if (!info-&gt;init_func (result, params, buffer))
        goto init_failed;
  
<span class="udiff-line-modified-removed">-   /* and add to the list of metadata */</span>
<span class="udiff-line-modified-removed">-   item-&gt;next = GST_BUFFER_META (buffer);</span>
<span class="udiff-line-modified-removed">-   GST_BUFFER_META (buffer) = item;</span>
<span class="udiff-line-modified-added">+   item-&gt;seq_num = gst_atomic_int64_inc (&amp;meta_seq);</span>
<span class="udiff-line-modified-added">+   item-&gt;next = NULL;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   if (!GST_BUFFER_META (buffer)) {</span>
<span class="udiff-line-added">+     GST_BUFFER_META (buffer) = item;</span>
<span class="udiff-line-added">+     GST_BUFFER_TAIL_META (buffer) = item;</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     GST_BUFFER_TAIL_META (buffer)-&gt;next = item;</span>
<span class="udiff-line-added">+     GST_BUFFER_TAIL_META (buffer) = item;</span>
<span class="udiff-line-added">+   }</span>
  
    return result;
  
  init_failed:
    {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2290,14 +2376,22 @@</span>
      GstMeta *m = &amp;walk-&gt;meta;
      if (m == meta) {
        const GstMetaInfo *info = meta-&gt;info;
  
        /* remove from list */
<span class="udiff-line-added">+       if (GST_BUFFER_TAIL_META (buffer) == walk) {</span>
<span class="udiff-line-added">+         if (prev != walk)</span>
<span class="udiff-line-added">+           GST_BUFFER_TAIL_META (buffer) = prev;</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+           GST_BUFFER_TAIL_META (buffer) = NULL;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
        if (GST_BUFFER_META (buffer) == walk)
          GST_BUFFER_META (buffer) = walk-&gt;next;
        else
          prev-&gt;next = walk-&gt;next;
<span class="udiff-line-added">+ </span>
        /* call free_func if any */
        if (info-&gt;free_func)
          info-&gt;free_func (m, buffer);
  
        /* and free the slice */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2429,18 +2523,23 @@</span>
  
        g_return_val_if_fail (gst_buffer_is_writable (buffer), FALSE);
        g_return_val_if_fail (!GST_META_FLAG_IS_SET (m, GST_META_FLAG_LOCKED),
            FALSE);
  
<span class="udiff-line-added">+       if (GST_BUFFER_TAIL_META (buffer) == walk) {</span>
<span class="udiff-line-added">+         if (prev != walk)</span>
<span class="udiff-line-added">+           GST_BUFFER_TAIL_META (buffer) = prev;</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+           GST_BUFFER_TAIL_META (buffer) = NULL;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
        /* remove from list */
        if (GST_BUFFER_META (buffer) == walk)
<span class="udiff-line-modified-removed">-         GST_BUFFER_META (buffer) = next;</span>
<span class="udiff-line-modified-added">+         prev = GST_BUFFER_META (buffer) = next;</span>
        else
          prev-&gt;next = next;
  
<span class="udiff-line-removed">-       prev = next;</span>
<span class="udiff-line-removed">- </span>
        /* call free_func if any */
        if (info-&gt;free_func)
          info-&gt;free_func (m, buffer);
  
        /* and free the slice */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2481,12 +2580,12 @@</span>
    if (alloc_size == 0) {
      *dest = NULL;
      *dest_size = 0;
    } else {
      *dest = g_malloc (alloc_size);
<span class="udiff-line-modified-removed">-   *dest_size = gst_buffer_extract (buffer, offset, *dest, size);</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-modified-added">+     *dest_size = gst_buffer_extract (buffer, offset, *dest, size);</span>
<span class="udiff-line-modified-added">+   }</span>
  }
  
  GST_DEBUG_CATEGORY_STATIC (gst_parent_buffer_meta_debug);
  
  /**
</pre>
<center><a href="gstbin.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstbuffer.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>