<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gtimezone.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright � 2010 Codethink Limited
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  *
  17  * Author: Ryan Lortie &lt;desrt@desrt.ca&gt;
  18  */
  19 
  20 /* Prologue {{{1 */
  21 
  22 #include &quot;config.h&quot;
  23 
  24 #include &quot;gtimezone.h&quot;
  25 
  26 #include &lt;string.h&gt;
  27 #include &lt;stdlib.h&gt;
  28 #include &lt;signal.h&gt;
  29 
  30 #include &quot;gmappedfile.h&quot;
  31 #include &quot;gtestutils.h&quot;
  32 #include &quot;gfileutils.h&quot;
  33 #include &quot;gstrfuncs.h&quot;
  34 #include &quot;ghash.h&quot;
  35 #include &quot;gthread.h&quot;
  36 #include &quot;gbytes.h&quot;
  37 #include &quot;gslice.h&quot;
  38 #include &quot;gdatetime.h&quot;
  39 #include &quot;gdate.h&quot;
  40 
  41 #ifdef G_OS_WIN32
  42 #define STRICT
  43 #include &lt;windows.h&gt;
  44 #endif
  45 
  46 /**
  47  * SECTION:timezone
  48  * @title: GTimeZone
  49  * @short_description: a structure representing a time zone
  50  * @see_also: #GDateTime
  51  *
  52  * #GTimeZone is a structure that represents a time zone, at no
  53  * particular point in time.  It is refcounted and immutable.
  54  *
  55  * Each time zone has an identifier (for example, �Europe/London�) which is
  56  * platform dependent. See g_time_zone_new() for information on the identifier
  57  * formats. The identifier of a time zone can be retrieved using
  58  * g_time_zone_get_identifier().
  59  *
  60  * A time zone contains a number of intervals.  Each interval has
  61  * an abbreviation to describe it (for example, �PDT�), an offet to UTC and a
  62  * flag indicating if the daylight savings time is in effect during that
  63  * interval.  A time zone always has at least one interval � interval 0. Note
  64  * that interval abbreviations are not the same as time zone identifiers
  65  * (apart from �UTC�), and cannot be passed to g_time_zone_new().
  66  *
  67  * Every UTC time is contained within exactly one interval, but a given
  68  * local time may be contained within zero, one or two intervals (due to
  69  * incontinuities associated with daylight savings time).
  70  *
  71  * An interval may refer to a specific period of time (eg: the duration
  72  * of daylight savings time during 2010) or it may refer to many periods
  73  * of time that share the same properties (eg: all periods of daylight
  74  * savings time).  It is also possible (usually for political reasons)
  75  * that some properties (like the abbreviation) change between intervals
  76  * without other properties changing.
  77  *
  78  * #GTimeZone is available since GLib 2.26.
  79  */
  80 
  81 /**
  82  * GTimeZone:
  83  *
  84  * #GTimeZone is an opaque structure whose members cannot be accessed
  85  * directly.
  86  *
  87  * Since: 2.26
  88  **/
  89 
  90 /* IANA zoneinfo file format {{{1 */
  91 
  92 /* unaligned */
  93 typedef struct { gchar bytes[8]; } gint64_be;
  94 typedef struct { gchar bytes[4]; } gint32_be;
  95 typedef struct { gchar bytes[4]; } guint32_be;
  96 
  97 static inline gint64 gint64_from_be (const gint64_be be) {
  98   gint64 tmp; memcpy (&amp;tmp, &amp;be, sizeof tmp); return GINT64_FROM_BE (tmp);
  99 }
 100 
 101 static inline gint32 gint32_from_be (const gint32_be be) {
 102   gint32 tmp; memcpy (&amp;tmp, &amp;be, sizeof tmp); return GINT32_FROM_BE (tmp);
 103 }
 104 
 105 static inline guint32 guint32_from_be (const guint32_be be) {
 106   guint32 tmp; memcpy (&amp;tmp, &amp;be, sizeof tmp); return GUINT32_FROM_BE (tmp);
 107 }
 108 
 109 /* The layout of an IANA timezone file header */
 110 struct tzhead
 111 {
 112   gchar      tzh_magic[4];
 113   gchar      tzh_version;
 114   guchar     tzh_reserved[15];
 115 
 116   guint32_be tzh_ttisgmtcnt;
 117   guint32_be tzh_ttisstdcnt;
 118   guint32_be tzh_leapcnt;
 119   guint32_be tzh_timecnt;
 120   guint32_be tzh_typecnt;
 121   guint32_be tzh_charcnt;
 122 };
 123 
 124 struct ttinfo
 125 {
 126   gint32_be tt_gmtoff;
 127   guint8    tt_isdst;
 128   guint8    tt_abbrind;
 129 };
 130 
 131 /* A Transition Date structure for TZ Rules, an intermediate structure
 132    for parsing MSWindows and Environment-variable time zones. It
 133    Generalizes MSWindows&#39;s SYSTEMTIME struct.
 134  */
 135 typedef struct
 136 {
 137   gint     year;
 138   gint     mon;
 139   gint     mday;
 140   gint     wday;
 141   gint     week;
 142   gint     hour;
 143   gint     min;
 144   gint     sec;
 145 } TimeZoneDate;
 146 
 147 /* POSIX Timezone abbreviations are typically 3 or 4 characters, but
 148    Microsoft uses 32-character names. We&#39;ll use one larger to ensure
 149    we have room for the terminating \0.
 150  */
 151 #define NAME_SIZE 33
 152 
 153 /* A MSWindows-style time zone transition rule. Generalizes the
 154    MSWindows TIME_ZONE_INFORMATION struct. Also used to compose time
 155    zones from tzset-style identifiers.
 156  */
 157 typedef struct
 158 {
 159   gint         start_year;
 160   gint32       std_offset;
 161   gint32       dlt_offset;
 162   TimeZoneDate dlt_start;
 163   TimeZoneDate dlt_end;
 164   gchar std_name[NAME_SIZE];
 165   gchar dlt_name[NAME_SIZE];
 166 } TimeZoneRule;
 167 
 168 /* GTimeZone&#39;s internal representation of a Daylight Savings (Summer)
 169    time interval.
 170  */
 171 typedef struct
 172 {
 173   gint32     gmt_offset;
 174   gboolean   is_dst;
 175   gchar     *abbrev;
 176 } TransitionInfo;
 177 
 178 /* GTimeZone&#39;s representation of a transition time to or from Daylight
 179    Savings (Summer) time and Standard time for the zone. */
 180 typedef struct
 181 {
 182   gint64 time;
 183   gint   info_index;
 184 } Transition;
 185 
 186 /* GTimeZone structure */
 187 struct _GTimeZone
 188 {
 189   gchar   *name;
 190   GArray  *t_info;         /* Array of TransitionInfo */
 191   GArray  *transitions;    /* Array of Transition */
 192   gint     ref_count;
 193 };
 194 
 195 G_LOCK_DEFINE_STATIC (time_zones);
 196 static GHashTable/*&lt;string?, GTimeZone&gt;*/ *time_zones;
 197 
 198 #define MIN_TZYEAR 1916 /* Daylight Savings started in WWI */
 199 #define MAX_TZYEAR 2999 /* And it&#39;s not likely ever to go away, but
 200                            there&#39;s no point in getting carried
 201                            away. */
 202 
 203 /**
 204  * g_time_zone_unref:
 205  * @tz: a #GTimeZone
 206  *
 207  * Decreases the reference count on @tz.
 208  *
 209  * Since: 2.26
 210  **/
 211 void
 212 g_time_zone_unref (GTimeZone *tz)
 213 {
 214   int ref_count;
 215 
 216 again:
 217   ref_count = g_atomic_int_get (&amp;tz-&gt;ref_count);
 218 
 219   g_assert (ref_count &gt; 0);
 220 
 221   if (ref_count == 1)
 222     {
 223       if (tz-&gt;name != NULL)
 224         {
 225           G_LOCK(time_zones);
 226 
 227           /* someone else might have grabbed a ref in the meantime */
 228           if G_UNLIKELY (g_atomic_int_get (&amp;tz-&gt;ref_count) != 1)
 229             {
 230               G_UNLOCK(time_zones);
 231               goto again;
 232             }
 233 
 234           g_hash_table_remove (time_zones, tz-&gt;name);
 235           G_UNLOCK(time_zones);
 236         }
 237 
 238       if (tz-&gt;t_info != NULL)
 239         {
 240           gint idx;
 241           for (idx = 0; idx &lt; tz-&gt;t_info-&gt;len; idx++)
 242             {
 243               TransitionInfo *info = &amp;g_array_index (tz-&gt;t_info, TransitionInfo, idx);
 244               g_free (info-&gt;abbrev);
 245             }
 246           g_array_free (tz-&gt;t_info, TRUE);
 247         }
 248       if (tz-&gt;transitions != NULL)
 249         g_array_free (tz-&gt;transitions, TRUE);
 250       g_free (tz-&gt;name);
 251 
 252       g_slice_free (GTimeZone, tz);
 253     }
 254 
 255   else if G_UNLIKELY (!g_atomic_int_compare_and_exchange (&amp;tz-&gt;ref_count,
 256                                                           ref_count,
 257                                                           ref_count - 1))
 258     goto again;
 259 }
 260 
 261 /**
 262  * g_time_zone_ref:
 263  * @tz: a #GTimeZone
 264  *
 265  * Increases the reference count on @tz.
 266  *
 267  * Returns: a new reference to @tz.
 268  *
 269  * Since: 2.26
 270  **/
 271 GTimeZone *
 272 g_time_zone_ref (GTimeZone *tz)
 273 {
 274   g_assert (tz-&gt;ref_count &gt; 0);
 275 
 276   g_atomic_int_inc (&amp;tz-&gt;ref_count);
 277 
 278   return tz;
 279 }
 280 
 281 /* fake zoneinfo creation (for RFC3339/ISO 8601 timezones) {{{1 */
 282 /*
 283  * parses strings of the form h or hh[[:]mm[[[:]ss]]] where:
 284  *  - h[h] is 0 to 23
 285  *  - mm is 00 to 59
 286  *  - ss is 00 to 59
 287  */
 288 static gboolean
 289 parse_time (const gchar *time_,
 290             gint32      *offset)
 291 {
 292   if (*time_ &lt; &#39;0&#39; || &#39;9&#39; &lt; *time_)
 293     return FALSE;
 294 
 295   *offset = 60 * 60 * (*time_++ - &#39;0&#39;);
 296 
 297   if (*time_ == &#39;\0&#39;)
 298     return TRUE;
 299 
 300   if (*time_ != &#39;:&#39;)
 301     {
 302       if (*time_ &lt; &#39;0&#39; || &#39;9&#39; &lt; *time_)
 303         return FALSE;
 304 
 305       *offset *= 10;
 306       *offset += 60 * 60 * (*time_++ - &#39;0&#39;);
 307 
 308       if (*offset &gt; 23 * 60 * 60)
 309         return FALSE;
 310 
 311       if (*time_ == &#39;\0&#39;)
 312         return TRUE;
 313     }
 314 
 315   if (*time_ == &#39;:&#39;)
 316     time_++;
 317 
 318   if (*time_ &lt; &#39;0&#39; || &#39;5&#39; &lt; *time_)
 319     return FALSE;
 320 
 321   *offset += 10 * 60 * (*time_++ - &#39;0&#39;);
 322 
 323   if (*time_ &lt; &#39;0&#39; || &#39;9&#39; &lt; *time_)
 324     return FALSE;
 325 
 326   *offset += 60 * (*time_++ - &#39;0&#39;);
 327 
 328   if (*time_ == &#39;\0&#39;)
 329     return TRUE;
 330 
 331   if (*time_ == &#39;:&#39;)
 332     time_++;
 333 
 334   if (*time_ &lt; &#39;0&#39; || &#39;5&#39; &lt; *time_)
 335     return FALSE;
 336 
 337   *offset += 10 * (*time_++ - &#39;0&#39;);
 338 
 339   if (*time_ &lt; &#39;0&#39; || &#39;9&#39; &lt; *time_)
 340     return FALSE;
 341 
 342   *offset += *time_++ - &#39;0&#39;;
 343 
 344   return *time_ == &#39;\0&#39;;
 345 }
 346 
 347 static gboolean
 348 parse_constant_offset (const gchar *name,
 349                        gint32      *offset)
 350 {
 351   if (g_strcmp0 (name, &quot;UTC&quot;) == 0)
 352     {
 353       *offset = 0;
 354       return TRUE;
 355     }
 356 
 357   if (*name &gt;= &#39;0&#39; &amp;&amp; &#39;9&#39; &gt;= *name)
 358     return parse_time (name, offset);
 359 
 360   switch (*name++)
 361     {
 362     case &#39;Z&#39;:
 363       *offset = 0;
 364       return !*name;
 365 
 366     case &#39;+&#39;:
 367       return parse_time (name, offset);
 368 
 369     case &#39;-&#39;:
 370       if (parse_time (name, offset))
 371         {
 372           *offset = -*offset;
 373           return TRUE;
 374         }
 375 
 376     default:
 377       return FALSE;
 378     }
 379 }
 380 
 381 static void
 382 zone_for_constant_offset (GTimeZone *gtz, const gchar *name)
 383 {
 384   gint32 offset;
 385   TransitionInfo info;
 386 
 387   if (name == NULL || !parse_constant_offset (name, &amp;offset))
 388     return;
 389 
 390   info.gmt_offset = offset;
 391   info.is_dst = FALSE;
 392   info.abbrev =  g_strdup (name);
 393 
 394   gtz-&gt;name = g_strdup (name);
 395   gtz-&gt;t_info = g_array_sized_new (FALSE, TRUE, sizeof (TransitionInfo), 1);
 396   g_array_append_val (gtz-&gt;t_info, info);
 397 
 398   /* Constant offset, no transitions */
 399   gtz-&gt;transitions = NULL;
 400 }
 401 
 402 #ifdef G_OS_UNIX
 403 static GBytes*
 404 zone_info_unix (const gchar  *identifier,
 405                 gchar       **out_identifier)
 406 {
 407   gchar *filename;
 408   GMappedFile *file = NULL;
 409   GBytes *zoneinfo = NULL;
 410   gchar *resolved_identifier = NULL;
 411   const gchar *tzdir;
 412 
 413   tzdir = getenv (&quot;TZDIR&quot;);
 414   if (tzdir == NULL)
 415     tzdir = &quot;/usr/share/zoneinfo&quot;;
 416 
 417   /* identifier can be a relative or absolute path name;
 418      if relative, it is interpreted starting from /usr/share/zoneinfo
 419      while the POSIX standard says it should start with :,
 420      glibc allows both syntaxes, so we should too */
 421   if (identifier != NULL)
 422     {
 423       resolved_identifier = g_strdup (identifier);
 424 
 425       if (*identifier == &#39;:&#39;)
 426         identifier ++;
 427 
 428       if (g_path_is_absolute (identifier))
 429         filename = g_strdup (identifier);
 430       else
 431         filename = g_build_filename (tzdir, identifier, NULL);
 432     }
 433   else
 434     {
 435       gsize prefix_len = 0;
 436       gchar *canonical_path = NULL;
 437       GError *read_link_err = NULL;
 438 
 439     filename = g_strdup (&quot;/etc/localtime&quot;);
 440 
 441       /* Resolve the actual timezone pointed to by /etc/localtime. */
 442       resolved_identifier = g_file_read_link (filename, &amp;read_link_err);
 443       if (resolved_identifier == NULL)
 444         {
 445           gboolean not_a_symlink = g_error_matches (read_link_err,
 446                                                     G_FILE_ERROR,
 447                                                     G_FILE_ERROR_INVAL);
 448           g_clear_error (&amp;read_link_err);
 449 
 450           /* Fallback to the content of /var/db/zoneinfo or /etc/timezone
 451            * if /etc/localtime is not a symlink. /var/db/zoneinfo is
 452            * where &#39;tzsetup&#39; program on FreeBSD and DragonflyBSD stores
 453            * the timezone chosen by the user. /etc/timezone is where user
 454            * choice is expressed on Gentoo OpenRC and others. */
 455           if (not_a_symlink &amp;&amp; (g_file_get_contents (&quot;/var/db/zoneinfo&quot;,
 456                                                      &amp;resolved_identifier,
 457                                                      NULL, NULL) ||
 458                                 g_file_get_contents (&quot;/etc/timezone&quot;,
 459                                                      &amp;resolved_identifier,
 460                                                      NULL, NULL)))
 461             g_strchomp (resolved_identifier);
 462           else
 463             {
 464               /* Error */
 465               g_assert (resolved_identifier == NULL);
 466               goto out;
 467             }
 468         }
 469       else
 470         {
 471           /* Resolve relative path */
 472           canonical_path = g_canonicalize_filename (resolved_identifier, &quot;/etc&quot;);
 473           g_free (resolved_identifier);
 474           resolved_identifier = g_steal_pointer (&amp;canonical_path);
 475         }
 476 
 477       /* Strip the prefix and slashes if possible. */
 478       if (g_str_has_prefix (resolved_identifier, tzdir))
 479         {
 480           prefix_len = strlen (tzdir);
 481           while (*(resolved_identifier + prefix_len) == &#39;/&#39;)
 482             prefix_len++;
 483         }
 484 
 485       if (prefix_len &gt; 0)
 486         memmove (resolved_identifier, resolved_identifier + prefix_len,
 487                  strlen (resolved_identifier) - prefix_len + 1  /* nul terminator */);
 488 
 489       g_free (canonical_path);
 490     }
 491 
 492   file = g_mapped_file_new (filename, FALSE, NULL);
 493   if (file != NULL)
 494     {
 495       zoneinfo = g_bytes_new_with_free_func (g_mapped_file_get_contents (file),
 496                                              g_mapped_file_get_length (file),
 497                                              (GDestroyNotify)g_mapped_file_unref,
 498                                              g_mapped_file_ref (file));
 499       g_mapped_file_unref (file);
 500     }
 501 
 502   g_assert (resolved_identifier != NULL);
 503 
 504 out:
 505   if (out_identifier != NULL)
 506     *out_identifier = g_steal_pointer (&amp;resolved_identifier);
 507 
 508   g_free (resolved_identifier);
 509   g_free (filename);
 510 
 511   return zoneinfo;
 512 }
 513 
 514 static void
 515 init_zone_from_iana_info (GTimeZone *gtz,
 516                           GBytes    *zoneinfo,
 517                           gchar     *identifier  /* (transfer full) */)
 518 {
 519   gsize size;
 520   guint index;
 521   guint32 time_count, type_count;
 522   guint8 *tz_transitions, *tz_type_index, *tz_ttinfo;
 523   guint8 *tz_abbrs;
 524   gsize timesize = sizeof (gint32);
 525   const struct tzhead *header = g_bytes_get_data (zoneinfo, &amp;size);
 526 
 527   g_return_if_fail (size &gt;= sizeof (struct tzhead) &amp;&amp;
 528                     memcmp (header, &quot;TZif&quot;, 4) == 0);
 529 
 530   if (header-&gt;tzh_version == &#39;2&#39;)
 531       {
 532         /* Skip ahead to the newer 64-bit data if it&#39;s available. */
 533         header = (const struct tzhead *)
 534           (((const gchar *) (header + 1)) +
 535            guint32_from_be(header-&gt;tzh_ttisgmtcnt) +
 536            guint32_from_be(header-&gt;tzh_ttisstdcnt) +
 537            8 * guint32_from_be(header-&gt;tzh_leapcnt) +
 538            5 * guint32_from_be(header-&gt;tzh_timecnt) +
 539            6 * guint32_from_be(header-&gt;tzh_typecnt) +
 540            guint32_from_be(header-&gt;tzh_charcnt));
 541         timesize = sizeof (gint64);
 542       }
 543   time_count = guint32_from_be(header-&gt;tzh_timecnt);
 544   type_count = guint32_from_be(header-&gt;tzh_typecnt);
 545 
 546   tz_transitions = ((guint8 *) (header) + sizeof (*header));
 547   tz_type_index = tz_transitions + timesize * time_count;
 548   tz_ttinfo = tz_type_index + time_count;
 549   tz_abbrs = tz_ttinfo + sizeof (struct ttinfo) * type_count;
 550 
 551   gtz-&gt;name = g_steal_pointer (&amp;identifier);
 552   gtz-&gt;t_info = g_array_sized_new (FALSE, TRUE, sizeof (TransitionInfo),
 553                                    type_count);
 554   gtz-&gt;transitions = g_array_sized_new (FALSE, TRUE, sizeof (Transition),
 555                                         time_count);
 556 
 557   for (index = 0; index &lt; type_count; index++)
 558     {
 559       TransitionInfo t_info;
 560       struct ttinfo info = ((struct ttinfo*)tz_ttinfo)[index];
 561       t_info.gmt_offset = gint32_from_be (info.tt_gmtoff);
 562       t_info.is_dst = info.tt_isdst ? TRUE : FALSE;
 563       t_info.abbrev = g_strdup ((gchar *) &amp;tz_abbrs[info.tt_abbrind]);
 564       g_array_append_val (gtz-&gt;t_info, t_info);
 565     }
 566 
 567   for (index = 0; index &lt; time_count; index++)
 568     {
 569       Transition trans;
 570       if (header-&gt;tzh_version == &#39;2&#39;)
 571         trans.time = gint64_from_be (((gint64_be*)tz_transitions)[index]);
 572       else
 573         trans.time = gint32_from_be (((gint32_be*)tz_transitions)[index]);
 574       trans.info_index = tz_type_index[index];
 575       g_assert (trans.info_index &gt;= 0);
 576       g_assert (trans.info_index &lt; gtz-&gt;t_info-&gt;len);
 577       g_array_append_val (gtz-&gt;transitions, trans);
 578     }
 579 }
 580 
 581 #elif defined (G_OS_WIN32)
 582 
 583 static void
 584 copy_windows_systemtime (SYSTEMTIME *s_time, TimeZoneDate *tzdate)
 585 {
 586   tzdate-&gt;sec = s_time-&gt;wSecond;
 587   tzdate-&gt;min = s_time-&gt;wMinute;
 588   tzdate-&gt;hour = s_time-&gt;wHour;
 589   tzdate-&gt;mon = s_time-&gt;wMonth;
 590   tzdate-&gt;year = s_time-&gt;wYear;
 591   tzdate-&gt;wday = s_time-&gt;wDayOfWeek ? s_time-&gt;wDayOfWeek : 7;
 592 
 593   if (s_time-&gt;wYear)
 594     {
 595       tzdate-&gt;mday = s_time-&gt;wDay;
 596       tzdate-&gt;wday = 0;
 597     }
 598   else
 599     tzdate-&gt;week = s_time-&gt;wDay;
 600 }
 601 
 602 /* UTC = local time + bias while local time = UTC + offset */
 603 static void
 604 rule_from_windows_time_zone_info (TimeZoneRule *rule,
 605                                   TIME_ZONE_INFORMATION *tzi)
 606 {
 607   /* Set offset */
 608   if (tzi-&gt;StandardDate.wMonth)
 609     {
 610       rule-&gt;std_offset = -(tzi-&gt;Bias + tzi-&gt;StandardBias) * 60;
 611       rule-&gt;dlt_offset = -(tzi-&gt;Bias + tzi-&gt;DaylightBias) * 60;
 612       copy_windows_systemtime (&amp;(tzi-&gt;DaylightDate), &amp;(rule-&gt;dlt_start));
 613 
 614       copy_windows_systemtime (&amp;(tzi-&gt;StandardDate), &amp;(rule-&gt;dlt_end));
 615 
 616     }
 617 
 618   else
 619     {
 620       rule-&gt;std_offset = -tzi-&gt;Bias * 60;
 621       rule-&gt;dlt_start.mon = 0;
 622     }
 623   strncpy (rule-&gt;std_name, (gchar*)tzi-&gt;StandardName, NAME_SIZE - 1);
 624   strncpy (rule-&gt;dlt_name, (gchar*)tzi-&gt;DaylightName, NAME_SIZE - 1);
 625 }
 626 
 627 static gchar*
 628 windows_default_tzname (void)
 629 {
 630   const gchar *subkey =
 631     &quot;SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation&quot;;
 632   HKEY key;
 633   gchar *key_name = NULL;
 634   if (RegOpenKeyExA (HKEY_LOCAL_MACHINE, subkey, 0,
 635                      KEY_QUERY_VALUE, &amp;key) == ERROR_SUCCESS)
 636     {
 637       DWORD size = 0;
 638       if (RegQueryValueExA (key, &quot;TimeZoneKeyName&quot;, NULL, NULL,
 639                             NULL, &amp;size) == ERROR_SUCCESS)
 640         {
 641           key_name = g_malloc ((gint)size);
 642           if (RegQueryValueExA (key, &quot;TimeZoneKeyName&quot;, NULL, NULL,
 643                                 (LPBYTE)key_name, &amp;size) != ERROR_SUCCESS)
 644             {
 645               g_free (key_name);
 646               key_name = NULL;
 647             }
 648         }
 649       RegCloseKey (key);
 650     }
 651   return key_name;
 652 }
 653 
 654 typedef   struct
 655 {
 656   LONG Bias;
 657   LONG StandardBias;
 658   LONG DaylightBias;
 659   SYSTEMTIME StandardDate;
 660   SYSTEMTIME DaylightDate;
 661 } RegTZI;
 662 
 663 static void
 664 system_time_copy (SYSTEMTIME *orig, SYSTEMTIME *target)
 665 {
 666   g_return_if_fail (orig != NULL);
 667   g_return_if_fail (target != NULL);
 668 
 669   target-&gt;wYear = orig-&gt;wYear;
 670   target-&gt;wMonth = orig-&gt;wMonth;
 671   target-&gt;wDayOfWeek = orig-&gt;wDayOfWeek;
 672   target-&gt;wDay = orig-&gt;wDay;
 673   target-&gt;wHour = orig-&gt;wHour;
 674   target-&gt;wMinute = orig-&gt;wMinute;
 675   target-&gt;wSecond = orig-&gt;wSecond;
 676   target-&gt;wMilliseconds = orig-&gt;wMilliseconds;
 677 }
 678 
 679 static void
 680 register_tzi_to_tzi (RegTZI *reg, TIME_ZONE_INFORMATION *tzi)
 681 {
 682   g_return_if_fail (reg != NULL);
 683   g_return_if_fail (tzi != NULL);
 684   tzi-&gt;Bias = reg-&gt;Bias;
 685   system_time_copy (&amp;(reg-&gt;StandardDate), &amp;(tzi-&gt;StandardDate));
 686   tzi-&gt;StandardBias = reg-&gt;StandardBias;
 687   system_time_copy (&amp;(reg-&gt;DaylightDate), &amp;(tzi-&gt;DaylightDate));
 688   tzi-&gt;DaylightBias = reg-&gt;DaylightBias;
 689 }
 690 
 691 static gint
 692 rules_from_windows_time_zone (const gchar   *identifier,
 693                               gchar        **out_identifier,
 694                               TimeZoneRule **rules)
 695 {
 696   HKEY key;
 697   gchar *subkey, *subkey_dynamic;
 698   gchar *key_name = NULL;
 699   const gchar *reg_key =
 700     &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones\\&quot;;
 701   TIME_ZONE_INFORMATION tzi;
 702   DWORD size;
 703   gint rules_num = 0;
 704   RegTZI regtzi, regtzi_prev;
 705 
 706   g_assert (out_identifier != NULL);
 707   g_assert (rules != NULL);
 708 
 709   *out_identifier = NULL;
 710   *rules = NULL;
 711   key_name = NULL;
 712 
 713   if (!identifier)
 714     key_name = windows_default_tzname ();
 715   else
 716     key_name = g_strdup (identifier);
 717 
 718   if (!key_name)
 719     return 0;
 720 
 721   subkey = g_strconcat (reg_key, key_name, NULL);
 722   subkey_dynamic = g_strconcat (subkey, &quot;\\Dynamic DST&quot;, NULL);
 723 
 724   if (RegOpenKeyExA (HKEY_LOCAL_MACHINE, subkey, 0,
 725                      KEY_QUERY_VALUE, &amp;key) != ERROR_SUCCESS)
 726       return 0;
 727   size = sizeof tzi.StandardName;
 728   if (RegQueryValueExA (key, &quot;Std&quot;, NULL, NULL,
 729                         (LPBYTE)&amp;(tzi.StandardName), &amp;size) != ERROR_SUCCESS)
 730     goto failed;
 731 
 732   size = sizeof tzi.DaylightName;
 733 
 734   if (RegQueryValueExA (key, &quot;Dlt&quot;, NULL, NULL,
 735                         (LPBYTE)&amp;(tzi.DaylightName), &amp;size) != ERROR_SUCCESS)
 736     goto failed;
 737 
 738   RegCloseKey (key);
 739   if (RegOpenKeyExA (HKEY_LOCAL_MACHINE, subkey_dynamic, 0,
 740                      KEY_QUERY_VALUE, &amp;key) == ERROR_SUCCESS)
 741     {
 742       DWORD first, last;
 743       int year, i;
 744       gchar *s;
 745 
 746       size = sizeof first;
 747       if (RegQueryValueExA (key, &quot;FirstEntry&quot;, NULL, NULL,
 748                             (LPBYTE) &amp;first, &amp;size) != ERROR_SUCCESS)
 749         goto failed;
 750 
 751       size = sizeof last;
 752       if (RegQueryValueExA (key, &quot;LastEntry&quot;, NULL, NULL,
 753                             (LPBYTE) &amp;last, &amp;size) != ERROR_SUCCESS)
 754         goto failed;
 755 
 756       rules_num = last - first + 2;
 757       *rules = g_new0 (TimeZoneRule, rules_num);
 758 
 759       for (year = first, i = 0; year &lt;= last; year++)
 760         {
 761           s = g_strdup_printf (&quot;%d&quot;, year);
 762 
 763           size = sizeof regtzi;
 764           if (RegQueryValueExA (key, s, NULL, NULL,
 765                             (LPBYTE) &amp;regtzi, &amp;size) != ERROR_SUCCESS)
 766             {
 767               g_free (*rules);
 768               *rules = NULL;
 769               break;
 770             }
 771 
 772           g_free (s);
 773 
 774           if (year &gt; first &amp;&amp; memcmp (&amp;regtzi_prev, &amp;regtzi, sizeof regtzi) == 0)
 775               continue;
 776           else
 777             memcpy (&amp;regtzi_prev, &amp;regtzi, sizeof regtzi);
 778 
 779           register_tzi_to_tzi (&amp;regtzi, &amp;tzi);
 780           rule_from_windows_time_zone_info (&amp;(*rules)[i], &amp;tzi);
 781           (*rules)[i++].start_year = year;
 782         }
 783 
 784       rules_num = i + 1;
 785 
 786 failed:
 787       RegCloseKey (key);
 788     }
 789   else if (RegOpenKeyExA (HKEY_LOCAL_MACHINE, subkey, 0,
 790                           KEY_QUERY_VALUE, &amp;key) == ERROR_SUCCESS)
 791     {
 792       size = sizeof regtzi;
 793       if (RegQueryValueExA (key, &quot;TZI&quot;, NULL, NULL,
 794                             (LPBYTE) &amp;regtzi, &amp;size) == ERROR_SUCCESS)
 795         {
 796           rules_num = 2;
 797           *rules = g_new0 (TimeZoneRule, 2);
 798           register_tzi_to_tzi (&amp;regtzi, &amp;tzi);
 799           rule_from_windows_time_zone_info (&amp;(*rules)[0], &amp;tzi);
 800         }
 801 
 802       RegCloseKey (key);
 803     }
 804 
 805   g_free (subkey_dynamic);
 806   g_free (subkey);
 807 
 808   if (*rules)
 809     {
 810       (*rules)[0].start_year = MIN_TZYEAR;
 811       if ((*rules)[rules_num - 2].start_year &lt; MAX_TZYEAR)
 812         (*rules)[rules_num - 1].start_year = MAX_TZYEAR;
 813       else
 814         (*rules)[rules_num - 1].start_year = (*rules)[rules_num - 2].start_year + 1;
 815 
 816       *out_identifier = g_steal_pointer (&amp;key_name);
 817 
 818       return rules_num;
 819     }
 820 
 821   g_free (key_name);
 822 
 823     return 0;
 824 }
 825 
 826 #endif
 827 
 828 static void
 829 find_relative_date (TimeZoneDate *buffer)
 830 {
 831   gint wday;
 832   GDate date;
 833   g_date_clear (&amp;date, 1);
 834   wday = buffer-&gt;wday;
 835 
 836   /* Get last day if last is needed, first day otherwise */
 837   if (buffer-&gt;mon == 13 || buffer-&gt;mon == 14) /* Julian Date */
 838     {
 839       g_date_set_dmy (&amp;date, 1, 1, buffer-&gt;year);
 840       if (wday &gt;= 59 &amp;&amp; buffer-&gt;mon == 13 &amp;&amp; g_date_is_leap_year (buffer-&gt;year))
 841         g_date_add_days (&amp;date, wday);
 842       else
 843         g_date_add_days (&amp;date, wday - 1);
 844       buffer-&gt;mon = (int) g_date_get_month (&amp;date);
 845       buffer-&gt;mday = (int) g_date_get_day (&amp;date);
 846       buffer-&gt;wday = 0;
 847     }
 848   else /* M.W.D */
 849     {
 850       guint days;
 851 #ifdef GSTREAMER_LITE
 852       guint days_in_month = g_date_get_days_in_month (buffer-&gt;mon, buffer-&gt;year);
 853 #else // GSTREAMER_LITE
 854       guint days_in_month = g_date_days_in_month (buffer-&gt;mon, buffer-&gt;year);
 855 #endif // GSTREAMER_LITE
 856       GDateWeekday first_wday;
 857 
 858       g_date_set_dmy (&amp;date, 1, buffer-&gt;mon, buffer-&gt;year);
 859       first_wday = g_date_get_weekday (&amp;date);
 860 
 861       if (first_wday &gt; wday)
 862         ++(buffer-&gt;week);
 863       /* week is 1 &lt;= w &lt;= 5, we need 0-based */
 864       days = 7 * (buffer-&gt;week - 1) + wday - first_wday;
 865 
 866       while (days &gt; days_in_month)
 867         days -= 7;
 868 
 869       g_date_add_days (&amp;date, days);
 870 
 871       buffer-&gt;mday = g_date_get_day (&amp;date);
 872     }
 873 }
 874 
 875 /* Offset is previous offset of local time. Returns 0 if month is 0 */
 876 static gint64
 877 boundary_for_year (TimeZoneDate *boundary,
 878                    gint          year,
 879                    gint32        offset)
 880 {
 881   TimeZoneDate buffer;
 882   GDate date;
 883   const guint64 unix_epoch_start = 719163L;
 884   const guint64 seconds_per_day = 86400L;
 885 
 886   if (!boundary-&gt;mon)
 887     return 0;
 888   buffer = *boundary;
 889 
 890   if (boundary-&gt;year == 0)
 891     {
 892       buffer.year = year;
 893 
 894       if (buffer.wday)
 895         find_relative_date (&amp;buffer);
 896     }
 897 
 898   g_assert (buffer.year == year);
 899   g_date_clear (&amp;date, 1);
 900   g_date_set_dmy (&amp;date, buffer.mday, buffer.mon, buffer.year);
 901   return ((g_date_get_julian (&amp;date) - unix_epoch_start) * seconds_per_day +
 902           buffer.hour * 3600 + buffer.min * 60 + buffer.sec - offset);
 903 }
 904 
 905 static void
 906 fill_transition_info_from_rule (TransitionInfo *info,
 907                                 TimeZoneRule   *rule,
 908                                 gboolean        is_dst)
 909 {
 910   gint offset = is_dst ? rule-&gt;dlt_offset : rule-&gt;std_offset;
 911   gchar *name = is_dst ? rule-&gt;dlt_name : rule-&gt;std_name;
 912 
 913   info-&gt;gmt_offset = offset;
 914   info-&gt;is_dst = is_dst;
 915 
 916   if (name)
 917     info-&gt;abbrev = g_strdup (name);
 918 
 919   else
 920     info-&gt;abbrev = g_strdup_printf (&quot;%+03d%02d&quot;,
 921                                       (int) offset / 3600,
 922                                       (int) abs (offset / 60) % 60);
 923 }
 924 
 925 static void
 926 init_zone_from_rules (GTimeZone    *gtz,
 927                       TimeZoneRule *rules,
 928                       gint          rules_num,
 929                       gchar        *identifier  /* (transfer full) */)
 930 {
 931   guint type_count = 0, trans_count = 0, info_index = 0;
 932   guint ri; /* rule index */
 933   gboolean skip_first_std_trans = TRUE;
 934   gint32 last_offset;
 935 
 936   type_count = 0;
 937   trans_count = 0;
 938 
 939   /* Last rule only contains max year */
 940   for (ri = 0; ri &lt; rules_num - 1; ri++)
 941     {
 942       if (rules[ri].dlt_start.mon || rules[ri].dlt_end.mon)
 943         {
 944           guint rulespan = (rules[ri + 1].start_year - rules[ri].start_year);
 945           guint transitions = rules[ri].dlt_start.mon &gt; 0 ? 1 : 0;
 946           transitions += rules[ri].dlt_end.mon &gt; 0 ? 1 : 0;
 947           type_count += rules[ri].dlt_start.mon &gt; 0 ? 2 : 1;
 948           trans_count += transitions * rulespan;
 949         }
 950       else
 951         type_count++;
 952     }
 953 
 954   gtz-&gt;name = g_steal_pointer (&amp;identifier);
 955   gtz-&gt;t_info = g_array_sized_new (FALSE, TRUE, sizeof (TransitionInfo), type_count);
 956   gtz-&gt;transitions = g_array_sized_new (FALSE, TRUE, sizeof (Transition), trans_count);
 957 
 958   last_offset = rules[0].std_offset;
 959 
 960   for (ri = 0; ri &lt; rules_num - 1; ri++)
 961     {
 962       if ((rules[ri].std_offset || rules[ri].dlt_offset) &amp;&amp;
 963           rules[ri].dlt_start.mon == 0 &amp;&amp; rules[ri].dlt_end.mon == 0)
 964         {
 965           TransitionInfo std_info;
 966           /* Standard */
 967           fill_transition_info_from_rule (&amp;std_info, &amp;(rules[ri]), FALSE);
 968           g_array_append_val (gtz-&gt;t_info, std_info);
 969 
 970           if (ri &gt; 0 &amp;&amp;
 971               ((rules[ri - 1].dlt_start.mon &gt; 12 &amp;&amp;
 972                 rules[ri - 1].dlt_start.wday &gt; rules[ri - 1].dlt_end.wday) ||
 973                 rules[ri - 1].dlt_start.mon &gt; rules[ri - 1].dlt_end.mon))
 974             {
 975               /* The previous rule was a southern hemisphere rule that
 976                  starts the year with DST, so we need to add a
 977                  transition to return to standard time */
 978               guint year = rules[ri].start_year;
 979               gint64 std_time =  boundary_for_year (&amp;rules[ri].dlt_end,
 980                                                     year, last_offset);
 981               Transition std_trans = {std_time, info_index};
 982               g_array_append_val (gtz-&gt;transitions, std_trans);
 983 
 984             }
 985           last_offset = rules[ri].std_offset;
 986           ++info_index;
 987           skip_first_std_trans = TRUE;
 988          }
 989       else
 990         {
 991           const guint start_year = rules[ri].start_year;
 992           const guint end_year = rules[ri + 1].start_year;
 993           gboolean dlt_first;
 994           guint year;
 995           TransitionInfo std_info, dlt_info;
 996           if (rules[ri].dlt_start.mon &gt; 12)
 997             dlt_first = rules[ri].dlt_start.wday &gt; rules[ri].dlt_end.wday;
 998           else
 999             dlt_first = rules[ri].dlt_start.mon &gt; rules[ri].dlt_end.mon;
1000           /* Standard rules are always even, because before the first
1001              transition is always standard time, and 0 is even. */
1002           fill_transition_info_from_rule (&amp;std_info, &amp;(rules[ri]), FALSE);
1003           fill_transition_info_from_rule (&amp;dlt_info, &amp;(rules[ri]), TRUE);
1004 
1005           g_array_append_val (gtz-&gt;t_info, std_info);
1006           g_array_append_val (gtz-&gt;t_info, dlt_info);
1007 
1008           /* Transition dates. We hope that a year which ends daylight
1009              time in a southern-hemisphere country (i.e., one that
1010              begins the year in daylight time) will include a rule
1011              which has only a dlt_end. */
1012           for (year = start_year; year &lt; end_year; year++)
1013             {
1014               gint32 dlt_offset = (dlt_first ? last_offset :
1015                                    rules[ri].dlt_offset);
1016               gint32 std_offset = (dlt_first ? rules[ri].std_offset :
1017                                    last_offset);
1018               /* NB: boundary_for_year returns 0 if mon == 0 */
1019               gint64 std_time =  boundary_for_year (&amp;rules[ri].dlt_end,
1020                                                     year, dlt_offset);
1021               gint64 dlt_time = boundary_for_year (&amp;rules[ri].dlt_start,
1022                                                    year, std_offset);
1023               Transition std_trans = {std_time, info_index};
1024               Transition dlt_trans = {dlt_time, info_index + 1};
1025               last_offset = (dlt_first ? rules[ri].dlt_offset :
1026                              rules[ri].std_offset);
1027               if (dlt_first)
1028                 {
1029                   if (skip_first_std_trans)
1030                     skip_first_std_trans = FALSE;
1031                   else if (std_time)
1032                     g_array_append_val (gtz-&gt;transitions, std_trans);
1033                   if (dlt_time)
1034                     g_array_append_val (gtz-&gt;transitions, dlt_trans);
1035                 }
1036               else
1037                 {
1038                   if (dlt_time)
1039                     g_array_append_val (gtz-&gt;transitions, dlt_trans);
1040                   if (std_time)
1041                     g_array_append_val (gtz-&gt;transitions, std_trans);
1042                 }
1043             }
1044 
1045           info_index += 2;
1046         }
1047     }
1048   if (ri &gt; 0 &amp;&amp;
1049       ((rules[ri - 1].dlt_start.mon &gt; 12 &amp;&amp;
1050         rules[ri - 1].dlt_start.wday &gt; rules[ri - 1].dlt_end.wday) ||
1051        rules[ri - 1].dlt_start.mon &gt; rules[ri - 1].dlt_end.mon))
1052     {
1053       /* The previous rule was a southern hemisphere rule that
1054          starts the year with DST, so we need to add a
1055          transition to return to standard time */
1056       TransitionInfo info;
1057       guint year = rules[ri].start_year;
1058       Transition trans;
1059       fill_transition_info_from_rule (&amp;info, &amp;(rules[ri - 1]), FALSE);
1060       g_array_append_val (gtz-&gt;t_info, info);
1061       trans.time = boundary_for_year (&amp;rules[ri - 1].dlt_end,
1062                                       year, last_offset);
1063       trans.info_index = info_index;
1064       g_array_append_val (gtz-&gt;transitions, trans);
1065      }
1066 }
1067 
1068 /*
1069  * parses date[/time] for parsing TZ environment variable
1070  *
1071  * date is either Mm.w.d, Jn or N
1072  * - m is 1 to 12
1073  * - w is 1 to 5
1074  * - d is 0 to 6
1075  * - n is 1 to 365
1076  * - N is 0 to 365
1077  *
1078  * time is either h or hh[[:]mm[[[:]ss]]]
1079  *  - h[h] is 0 to 23
1080  *  - mm is 00 to 59
1081  *  - ss is 00 to 59
1082  */
1083 static gboolean
1084 parse_mwd_boundary (gchar **pos, TimeZoneDate *boundary)
1085 {
1086   gint month, week, day;
1087 
1088   if (**pos == &#39;\0&#39; || **pos &lt; &#39;0&#39; || &#39;9&#39; &lt; **pos)
1089     return FALSE;
1090 
1091   month = *(*pos)++ - &#39;0&#39;;
1092 
1093   if ((month == 1 &amp;&amp; **pos &gt;= &#39;0&#39; &amp;&amp; &#39;2&#39; &gt;= **pos) ||
1094       (month == 0 &amp;&amp; **pos &gt;= &#39;0&#39; &amp;&amp; &#39;9&#39; &gt;= **pos))
1095     {
1096       month *= 10;
1097       month += *(*pos)++ - &#39;0&#39;;
1098     }
1099 
1100   if (*(*pos)++ != &#39;.&#39; || month == 0)
1101     return FALSE;
1102 
1103   if (**pos == &#39;\0&#39; || **pos &lt; &#39;1&#39; || &#39;5&#39; &lt; **pos)
1104     return FALSE;
1105 
1106   week = *(*pos)++ - &#39;0&#39;;
1107 
1108   if (*(*pos)++ != &#39;.&#39;)
1109     return FALSE;
1110 
1111   if (**pos == &#39;\0&#39; || **pos &lt; &#39;0&#39; || &#39;6&#39; &lt; **pos)
1112     return FALSE;
1113 
1114   day = *(*pos)++ - &#39;0&#39;;
1115 
1116   if (!day)
1117     day += 7;
1118 
1119   boundary-&gt;year = 0;
1120   boundary-&gt;mon = month;
1121   boundary-&gt;week = week;
1122   boundary-&gt;wday = day;
1123   return TRUE;
1124 }
1125 
1126 /* Different implementations of tzset interpret the Julian day field
1127    differently. For example, Linux specifies that it should be 1-based
1128    (1 Jan is JD 1) for both Jn and n formats, while zOS and BSD
1129    specify that a Jn JD is 1-based while an n JD is 0-based. Rather
1130    than trying to follow different specs, we will follow GDate&#39;s
1131    practice thatIn order to keep it simple, we will follow Linux&#39;s
1132    practice. */
1133 
1134 static gboolean
1135 parse_julian_boundary (gchar** pos, TimeZoneDate *boundary,
1136                        gboolean ignore_leap)
1137 {
1138   gint day = 0;
1139   GDate date;
1140 
1141   while (**pos &gt;= &#39;0&#39; &amp;&amp; &#39;9&#39; &gt;= **pos)
1142     {
1143       day *= 10;
1144       day += *(*pos)++ - &#39;0&#39;;
1145     }
1146 
1147   if (day &lt; 1 || 365 &lt; day)
1148     return FALSE;
1149 
1150   g_date_clear (&amp;date, 1);
1151   g_date_set_julian (&amp;date, day);
1152   boundary-&gt;year = 0;
1153   boundary-&gt;mon = (int) g_date_get_month (&amp;date);
1154   boundary-&gt;mday = (int) g_date_get_day (&amp;date);
1155   boundary-&gt;wday = 0;
1156 
1157   if (!ignore_leap &amp;&amp; day &gt;= 59)
1158     boundary-&gt;mday++;
1159 
1160   return TRUE;
1161 }
1162 
1163 static gboolean
1164 parse_tz_boundary (const gchar  *identifier,
1165                    TimeZoneDate *boundary)
1166 {
1167   gchar *pos;
1168 
1169   pos = (gchar*)identifier;
1170   /* Month-week-weekday */
1171   if (*pos == &#39;M&#39;)
1172     {
1173       ++pos;
1174       if (!parse_mwd_boundary (&amp;pos, boundary))
1175         return FALSE;
1176     }
1177   /* Julian date which ignores Feb 29 in leap years */
1178   else if (*pos == &#39;J&#39;)
1179     {
1180       ++pos;
1181       if (!parse_julian_boundary (&amp;pos, boundary, FALSE))
1182         return FALSE ;
1183     }
1184   /* Julian date which counts Feb 29 in leap years */
1185   else if (*pos &gt;= &#39;0&#39; &amp;&amp; &#39;9&#39; &gt;= *pos)
1186     {
1187       if (!parse_julian_boundary (&amp;pos, boundary, TRUE))
1188         return FALSE;
1189     }
1190   else
1191     return FALSE;
1192 
1193   /* Time */
1194 
1195   if (*pos == &#39;/&#39;)
1196     {
1197       gint32 offset;
1198 
1199       if (!parse_time (++pos, &amp;offset))
1200         return FALSE;
1201 
1202       boundary-&gt;hour = offset / 3600;
1203       boundary-&gt;min = (offset / 60) % 60;
1204       boundary-&gt;sec = offset % 3600;
1205 
1206       return TRUE;
1207     }
1208 
1209   else
1210     {
1211       boundary-&gt;hour = 2;
1212       boundary-&gt;min = 0;
1213       boundary-&gt;sec = 0;
1214 
1215       return *pos == &#39;\0&#39;;
1216     }
1217 }
1218 
1219 static gint
1220 create_ruleset_from_rule (TimeZoneRule **rules, TimeZoneRule *rule)
1221 {
1222   *rules = g_new0 (TimeZoneRule, 2);
1223 
1224   (*rules)[0].start_year = MIN_TZYEAR;
1225   (*rules)[1].start_year = MAX_TZYEAR;
1226 
1227   (*rules)[0].std_offset = -rule-&gt;std_offset;
1228   (*rules)[0].dlt_offset = -rule-&gt;dlt_offset;
1229   (*rules)[0].dlt_start  = rule-&gt;dlt_start;
1230   (*rules)[0].dlt_end = rule-&gt;dlt_end;
1231   strcpy ((*rules)[0].std_name, rule-&gt;std_name);
1232   strcpy ((*rules)[0].dlt_name, rule-&gt;dlt_name);
1233   return 2;
1234 }
1235 
1236 static gboolean
1237 parse_offset (gchar **pos, gint32 *target)
1238 {
1239   gchar *buffer;
1240   gchar *target_pos = *pos;
1241   gboolean ret;
1242 
1243   while (**pos == &#39;+&#39; || **pos == &#39;-&#39; || **pos == &#39;:&#39; ||
1244          (**pos &gt;= &#39;0&#39; &amp;&amp; &#39;9&#39; &gt;= **pos))
1245     ++(*pos);
1246 
1247   buffer = g_strndup (target_pos, *pos - target_pos);
1248   ret = parse_constant_offset (buffer, target);
1249   g_free (buffer);
1250 
1251   return ret;
1252 }
1253 
1254 static gboolean
1255 parse_identifier_boundary (gchar **pos, TimeZoneDate *target)
1256 {
1257   gchar *buffer;
1258   gchar *target_pos = *pos;
1259   gboolean ret;
1260 
1261   while (**pos != &#39;,&#39; &amp;&amp; **pos != &#39;\0&#39;)
1262     ++(*pos);
1263   buffer = g_strndup (target_pos, *pos - target_pos);
1264   ret = parse_tz_boundary (buffer, target);
1265   g_free (buffer);
1266 
1267   return ret;
1268 }
1269 
1270 static gboolean
1271 set_tz_name (gchar **pos, gchar *buffer, guint size)
1272 {
1273   gchar *name_pos = *pos;
1274   guint len;
1275 
1276   /* Name is ASCII alpha (Is this necessarily true?) */
1277   while (g_ascii_isalpha (**pos))
1278     ++(*pos);
1279 
1280   /* Name should be three or more alphabetic characters */
1281   if (*pos - name_pos &lt; 3)
1282     return FALSE;
1283 
1284   memset (buffer, 0, NAME_SIZE);
1285   /* name_pos isn&#39;t 0-terminated, so we have to limit the length expressly */
1286   len = *pos - name_pos &gt; size - 1 ? size - 1 : *pos - name_pos;
1287   strncpy (buffer, name_pos, len);
1288   return TRUE;
1289 }
1290 
1291 static gboolean
1292 parse_identifier_boundaries (gchar **pos, TimeZoneRule *tzr)
1293 {
1294   if (*(*pos)++ != &#39;,&#39;)
1295     return FALSE;
1296 
1297   /* Start date */
1298   if (!parse_identifier_boundary (pos, &amp;(tzr-&gt;dlt_start)) || *(*pos)++ != &#39;,&#39;)
1299     return FALSE;
1300 
1301   /* End date */
1302   if (!parse_identifier_boundary (pos, &amp;(tzr-&gt;dlt_end)))
1303     return FALSE;
1304   return TRUE;
1305 }
1306 
1307 /*
1308  * Creates an array of TimeZoneRule from a TZ environment variable
1309  * type of identifier.  Should free rules afterwards
1310  */
1311 static gint
1312 rules_from_identifier (const gchar   *identifier,
1313                        gchar        **out_identifier,
1314                        TimeZoneRule **rules)
1315 {
1316   gchar *pos;
1317   TimeZoneRule tzr;
1318 
1319   g_assert (out_identifier != NULL);
1320   g_assert (rules != NULL);
1321 
1322   *out_identifier = NULL;
1323   *rules = NULL;
1324 
1325   if (!identifier)
1326     return 0;
1327 
1328   pos = (gchar*)identifier;
1329   memset (&amp;tzr, 0, sizeof (tzr));
1330   /* Standard offset */
1331   if (!(set_tz_name (&amp;pos, tzr.std_name, NAME_SIZE)) ||
1332       !parse_offset (&amp;pos, &amp;(tzr.std_offset)))
1333     return 0;
1334 
1335   if (*pos == 0)
1336     {
1337       *out_identifier = g_strdup (identifier);
1338       return create_ruleset_from_rule (rules, &amp;tzr);
1339     }
1340 
1341   /* Format 2 */
1342   if (!(set_tz_name (&amp;pos, tzr.dlt_name, NAME_SIZE)))
1343     return 0;
1344   parse_offset (&amp;pos, &amp;(tzr.dlt_offset));
1345   if (tzr.dlt_offset == 0) /* No daylight offset given, assume it&#39;s 1
1346                               hour earlier that standard */
1347     tzr.dlt_offset = tzr.std_offset - 3600;
1348   if (*pos == &#39;\0&#39;)
1349 #ifdef G_OS_WIN32
1350     /* Windows allows us to use the US DST boundaries if they&#39;re not given */
1351     {
1352       int i;
1353       guint rules_num = 0;
1354 
1355       /* Use US rules, Windows&#39; default is Pacific Standard Time */
1356       if ((rules_num = rules_from_windows_time_zone (&quot;Pacific Standard Time&quot;,
1357                                                      out_identifier,
1358                                                      rules)))
1359         {
1360           for (i = 0; i &lt; rules_num - 1; i++)
1361             {
1362               (*rules)[i].std_offset = - tzr.std_offset;
1363               (*rules)[i].dlt_offset = - tzr.dlt_offset;
1364               strcpy ((*rules)[i].std_name, tzr.std_name);
1365               strcpy ((*rules)[i].dlt_name, tzr.dlt_name);
1366             }
1367 
1368           return rules_num;
1369         }
1370       else
1371         return 0;
1372     }
1373 #else
1374   return 0;
1375 #endif
1376   /* Start and end required (format 2) */
1377   if (!parse_identifier_boundaries (&amp;pos, &amp;tzr))
1378     return 0;
1379 
1380   *out_identifier = g_strdup (identifier);
1381   return create_ruleset_from_rule (rules, &amp;tzr);
1382 }
1383 
1384 /* Construction {{{1 */
1385 /**
1386  * g_time_zone_new:
1387  * @identifier: (nullable): a timezone identifier
1388  *
1389  * Creates a #GTimeZone corresponding to @identifier.
1390  *
1391  * @identifier can either be an RFC3339/ISO 8601 time offset or
1392  * something that would pass as a valid value for the `TZ` environment
1393  * variable (including %NULL).
1394  *
1395  * In Windows, @identifier can also be the unlocalized name of a time
1396  * zone for standard time, for example &quot;Pacific Standard Time&quot;.
1397  *
1398  * Valid RFC3339 time offsets are &#39;&quot;Z&quot;&#39; (for UTC) or
1399  * &#39;&quot;+|-hh:mm&quot;&#39;.  ISO 8601 additionally specifies
1400  * &#39;&quot;+|-hhmm&quot;&#39; and &#39;&quot;+|-hh&quot;&#39;.  Offsets are
1401  * time values to be added to Coordinated Universal Time (UTC) to get
1402  * the local time.
1403  *
1404  * In UNIX, the &#39;TZ&#39; environment variable typically corresponds
1405  * to the name of a file in the zoneinfo database, or string in
1406  * &quot;std offset [dst [offset],start[/time],end[/time]]&quot; (POSIX) format.
1407  * There  are  no spaces in the specification. The name of standard
1408  * and daylight savings time zone must be three or more alphabetic
1409  * characters. Offsets are time values to be added to local time to
1410  * get Coordinated Universal Time (UTC) and should be
1411  * &#39;&quot;[+|-]hh[[:]mm[:ss]]&quot;&#39;.  Dates are either
1412  * &#39;&quot;Jn&quot;&#39; (Julian day with n between 1 and 365, leap
1413  * years not counted), &#39;&quot;n&quot;&#39; (zero-based Julian day
1414  * with n between 0 and 365) or &#39;&quot;Mm.w.d&quot;&#39; (day d
1415  * (0 &lt;= d &lt;= 6) of week w (1 &lt;= w &lt;= 5) of month m (1 &lt;= m &lt;= 12), day
1416  * 0 is a Sunday).  Times are in local wall clock time, the default is
1417  * 02:00:00.
1418  *
1419  * In Windows, the &quot;tzn[+|-]hh[:mm[:ss]][dzn]&quot; format is used, but also
1420  * accepts POSIX format.  The Windows format uses US rules for all time
1421  * zones; daylight savings time is 60 minutes behind the standard time
1422  * with date and time of change taken from Pacific Standard Time.
1423  * Offsets are time values to be added to the local time to get
1424  * Coordinated Universal Time (UTC).
1425  *
1426  * g_time_zone_new_local() calls this function with the value of the
1427  * &#39;TZ&#39; environment variable. This function itself is independent of
1428  * the value of &#39;TZ&#39;, but if @identifier is %NULL then &#39;/etc/localtime&#39;
1429  * will be consulted to discover the correct time zone on UNIX and the
1430  * registry will be consulted or GetTimeZoneInformation() will be used
1431  * to get the local time zone on Windows.
1432  *
1433  * If intervals are not available, only time zone rules from `TZ`
1434  * environment variable or other means, then they will be computed
1435  * from year 1900 to 2037.  If the maximum year for the rules is
1436  * available and it is greater than 2037, then it will followed
1437  * instead.
1438  *
1439  * See
1440  * [RFC3339 �5.6](http://tools.ietf.org/html/rfc3339#section-5.6)
1441  * for a precise definition of valid RFC3339 time offsets
1442  * (the `time-offset` expansion) and ISO 8601 for the
1443  * full list of valid time offsets.  See
1444  * [The GNU C Library manual](http://www.gnu.org/s/libc/manual/html_node/TZ-Variable.html)
1445  * for an explanation of the possible
1446  * values of the `TZ` environment variable. See
1447  * [Microsoft Time Zone Index Values](http://msdn.microsoft.com/en-us/library/ms912391%28v=winembedded.11%29.aspx)
1448  * for the list of time zones on Windows.
1449  *
1450  * You should release the return value by calling g_time_zone_unref()
1451  * when you are done with it.
1452  *
1453  * Returns: the requested timezone
1454  *
1455  * Since: 2.26
1456  **/
1457 GTimeZone *
1458 g_time_zone_new (const gchar *identifier)
1459 {
1460   GTimeZone *tz = NULL;
1461   TimeZoneRule *rules;
1462   gint rules_num;
1463   gchar *resolved_identifier = NULL;
1464 
1465   G_LOCK (time_zones);
1466   if (time_zones == NULL)
1467     time_zones = g_hash_table_new (g_str_hash, g_str_equal);
1468 
1469   if (identifier)
1470     {
1471       tz = g_hash_table_lookup (time_zones, identifier);
1472       if (tz)
1473         {
1474           g_atomic_int_inc (&amp;tz-&gt;ref_count);
1475           G_UNLOCK (time_zones);
1476           return tz;
1477         }
1478     }
1479 
1480   tz = g_slice_new0 (GTimeZone);
1481   tz-&gt;ref_count = 0;
1482 
1483   zone_for_constant_offset (tz, identifier);
1484 
1485   if (tz-&gt;t_info == NULL &amp;&amp;
1486       (rules_num = rules_from_identifier (identifier, &amp;resolved_identifier, &amp;rules)))
1487     {
1488       init_zone_from_rules (tz, rules, rules_num, g_steal_pointer (&amp;resolved_identifier));
1489       g_free (rules);
1490     }
1491 
1492   if (tz-&gt;t_info == NULL)
1493     {
1494 #ifdef G_OS_UNIX
1495       GBytes *zoneinfo = zone_info_unix (identifier, &amp;resolved_identifier);
1496       if (zoneinfo != NULL)
1497         {
1498           init_zone_from_iana_info (tz, zoneinfo, g_steal_pointer (&amp;resolved_identifier));
1499           g_bytes_unref (zoneinfo);
1500         }
1501 #elif defined (G_OS_WIN32)
1502       if ((rules_num = rules_from_windows_time_zone (identifier,
1503                                                      &amp;resolved_identifier,
1504                                                      &amp;rules)))
1505         {
1506           init_zone_from_rules (tz, rules, rules_num, g_steal_pointer (&amp;resolved_identifier));
1507           g_free (rules);
1508         }
1509 #endif
1510     }
1511 
1512 #if defined (G_OS_WIN32)
1513   if (tz-&gt;t_info == NULL)
1514     {
1515       if (identifier == NULL)
1516         {
1517           TIME_ZONE_INFORMATION tzi;
1518 
1519           if (GetTimeZoneInformation (&amp;tzi) != TIME_ZONE_ID_INVALID)
1520             {
1521               rules = g_new0 (TimeZoneRule, 2);
1522 
1523               rule_from_windows_time_zone_info (&amp;rules[0], &amp;tzi);
1524 
1525               memset (rules[0].std_name, 0, NAME_SIZE);
1526               memset (rules[0].dlt_name, 0, NAME_SIZE);
1527 
1528               rules[0].start_year = MIN_TZYEAR;
1529               rules[1].start_year = MAX_TZYEAR;
1530 
1531               init_zone_from_rules (tz, rules, 2, windows_default_tzname ());
1532 
1533               g_free (rules);
1534             }
1535         }
1536     }
1537 #endif
1538 
1539   g_free (resolved_identifier);
1540 
1541   /* Always fall back to UTC. */
1542   if (tz-&gt;t_info == NULL)
1543     zone_for_constant_offset (tz, &quot;UTC&quot;);
1544 
1545   g_assert (tz-&gt;name != NULL);
1546   g_assert (tz-&gt;t_info != NULL);
1547 
1548   if (tz-&gt;t_info != NULL)
1549     {
1550       if (identifier)
1551         g_hash_table_insert (time_zones, tz-&gt;name, tz);
1552     }
1553   g_atomic_int_inc (&amp;tz-&gt;ref_count);
1554   G_UNLOCK (time_zones);
1555 
1556   return tz;
1557 }
1558 
1559 /**
1560  * g_time_zone_new_utc:
1561  *
1562  * Creates a #GTimeZone corresponding to UTC.
1563  *
1564  * This is equivalent to calling g_time_zone_new() with a value like
1565  * &quot;Z&quot;, &quot;UTC&quot;, &quot;+00&quot;, etc.
1566  *
1567  * You should release the return value by calling g_time_zone_unref()
1568  * when you are done with it.
1569  *
1570  * Returns: the universal timezone
1571  *
1572  * Since: 2.26
1573  **/
1574 GTimeZone *
1575 g_time_zone_new_utc (void)
1576 {
1577   return g_time_zone_new (&quot;UTC&quot;);
1578 }
1579 
1580 /**
1581  * g_time_zone_new_local:
1582  *
1583  * Creates a #GTimeZone corresponding to local time.  The local time
1584  * zone may change between invocations to this function; for example,
1585  * if the system administrator changes it.
1586  *
1587  * This is equivalent to calling g_time_zone_new() with the value of
1588  * the `TZ` environment variable (including the possibility of %NULL).
1589  *
1590  * You should release the return value by calling g_time_zone_unref()
1591  * when you are done with it.
1592  *
1593  * Returns: the local timezone
1594  *
1595  * Since: 2.26
1596  **/
1597 GTimeZone *
1598 g_time_zone_new_local (void)
1599 {
1600   return g_time_zone_new (getenv (&quot;TZ&quot;));
1601 }
1602 
1603 /**
1604  * g_time_zone_new_offset:
1605  * @seconds: offset to UTC, in seconds
1606  *
1607  * Creates a #GTimeZone corresponding to the given constant offset from UTC,
1608  * in seconds.
1609  *
1610  * This is equivalent to calling g_time_zone_new() with a string in the form
1611  * `[+|-]hh[:mm[:ss]]`.
1612  *
1613  * Returns: (transfer full): a timezone at the given offset from UTC
1614  * Since: 2.58
1615  */
1616 GTimeZone *
1617 g_time_zone_new_offset (gint32 seconds)
1618 {
1619   GTimeZone *tz = NULL;
1620   gchar *identifier = NULL;
1621 
1622   /* Seemingly, we should be using @seconds directly to set the
1623    * #TransitionInfo.gmt_offset to avoid all this string building and parsing.
1624    * However, we always need to set the #GTimeZone.name to a constructed
1625    * string anyway, so we might as well reuse its code. */
1626   identifier = g_strdup_printf (&quot;%c%02u:%02u:%02u&quot;,
1627                                 (seconds &gt;= 0) ? &#39;+&#39; : &#39;-&#39;,
1628                                 (ABS (seconds) / 60) / 60,
1629                                 (ABS (seconds) / 60) % 60,
1630                                 ABS (seconds) % 60);
1631   tz = g_time_zone_new (identifier);
1632   g_free (identifier);
1633 
1634   g_assert (g_time_zone_get_offset (tz, 0) == seconds);
1635 
1636   return tz;
1637 }
1638 
1639 #define TRANSITION(n)         g_array_index (tz-&gt;transitions, Transition, n)
1640 #define TRANSITION_INFO(n)    g_array_index (tz-&gt;t_info, TransitionInfo, n)
1641 
1642 /* Internal helpers {{{1 */
1643 /* NB: Interval 0 is before the first transition, so there&#39;s no
1644  * transition structure to point to which TransitionInfo to
1645  * use. Rule-based zones are set up so that TI 0 is always standard
1646  * time (which is what&#39;s in effect before Daylight time got started
1647  * in the early 20th century), but IANA tzfiles don&#39;t follow that
1648  * convention. The tzfile documentation says to use the first
1649  * standard-time (i.e., non-DST) tinfo, so that&#39;s what we do.
1650  */
1651 inline static const TransitionInfo*
1652 interval_info (GTimeZone *tz,
1653                guint      interval)
1654 {
1655   guint index;
1656   g_return_val_if_fail (tz-&gt;t_info != NULL, NULL);
1657   if (interval &amp;&amp; tz-&gt;transitions &amp;&amp; interval &lt;= tz-&gt;transitions-&gt;len)
1658     index = (TRANSITION(interval - 1)).info_index;
1659   else
1660     {
1661       for (index = 0; index &lt; tz-&gt;t_info-&gt;len; index++)
1662         {
1663           TransitionInfo *tzinfo = &amp;(TRANSITION_INFO(index));
1664           if (!tzinfo-&gt;is_dst)
1665             return tzinfo;
1666         }
1667       index = 0;
1668     }
1669 
1670   return &amp;(TRANSITION_INFO(index));
1671 }
1672 
1673 inline static gint64
1674 interval_start (GTimeZone *tz,
1675                 guint      interval)
1676 {
1677   if (!interval || tz-&gt;transitions == NULL || tz-&gt;transitions-&gt;len == 0)
1678     return G_MININT64;
1679   if (interval &gt; tz-&gt;transitions-&gt;len)
1680     interval = tz-&gt;transitions-&gt;len;
1681   return (TRANSITION(interval - 1)).time;
1682 }
1683 
1684 inline static gint64
1685 interval_end (GTimeZone *tz,
1686               guint      interval)
1687 {
1688   if (tz-&gt;transitions &amp;&amp; interval &lt; tz-&gt;transitions-&gt;len)
1689     {
1690       gint64 lim = (TRANSITION(interval)).time;
1691       return lim - (lim != G_MININT64);
1692     }
1693   return G_MAXINT64;
1694 }
1695 
1696 inline static gint32
1697 interval_offset (GTimeZone *tz,
1698                  guint      interval)
1699 {
1700   g_return_val_if_fail (tz-&gt;t_info != NULL, 0);
1701   return interval_info (tz, interval)-&gt;gmt_offset;
1702 }
1703 
1704 inline static gboolean
1705 interval_isdst (GTimeZone *tz,
1706                 guint      interval)
1707 {
1708   g_return_val_if_fail (tz-&gt;t_info != NULL, 0);
1709   return interval_info (tz, interval)-&gt;is_dst;
1710 }
1711 
1712 
1713 inline static gchar*
1714 interval_abbrev (GTimeZone *tz,
1715                   guint      interval)
1716 {
1717   g_return_val_if_fail (tz-&gt;t_info != NULL, 0);
1718   return interval_info (tz, interval)-&gt;abbrev;
1719 }
1720 
1721 inline static gint64
1722 interval_local_start (GTimeZone *tz,
1723                       guint      interval)
1724 {
1725   if (interval)
1726     return interval_start (tz, interval) + interval_offset (tz, interval);
1727 
1728   return G_MININT64;
1729 }
1730 
1731 inline static gint64
1732 interval_local_end (GTimeZone *tz,
1733                     guint      interval)
1734 {
1735   if (tz-&gt;transitions &amp;&amp; interval &lt; tz-&gt;transitions-&gt;len)
1736     return interval_end (tz, interval) + interval_offset (tz, interval);
1737 
1738   return G_MAXINT64;
1739 }
1740 
1741 static gboolean
1742 interval_valid (GTimeZone *tz,
1743                 guint      interval)
1744 {
1745   if ( tz-&gt;transitions == NULL)
1746     return interval == 0;
1747   return interval &lt;= tz-&gt;transitions-&gt;len;
1748 }
1749 
1750 /* g_time_zone_find_interval() {{{1 */
1751 
1752 /**
1753  * g_time_zone_adjust_time:
1754  * @tz: a #GTimeZone
1755  * @type: the #GTimeType of @time_
1756  * @time_: a pointer to a number of seconds since January 1, 1970
1757  *
1758  * Finds an interval within @tz that corresponds to the given @time_,
1759  * possibly adjusting @time_ if required to fit into an interval.
1760  * The meaning of @time_ depends on @type.
1761  *
1762  * This function is similar to g_time_zone_find_interval(), with the
1763  * difference that it always succeeds (by making the adjustments
1764  * described below).
1765  *
1766  * In any of the cases where g_time_zone_find_interval() succeeds then
1767  * this function returns the same value, without modifying @time_.
1768  *
1769  * This function may, however, modify @time_ in order to deal with
1770  * non-existent times.  If the non-existent local @time_ of 02:30 were
1771  * requested on March 14th 2010 in Toronto then this function would
1772  * adjust @time_ to be 03:00 and return the interval containing the
1773  * adjusted time.
1774  *
1775  * Returns: the interval containing @time_, never -1
1776  *
1777  * Since: 2.26
1778  **/
1779 gint
1780 g_time_zone_adjust_time (GTimeZone *tz,
1781                          GTimeType  type,
1782                          gint64    *time_)
1783 {
1784   gint i;
1785   guint intervals;
1786 
1787   if (tz-&gt;transitions == NULL)
1788     return 0;
1789 
1790   intervals = tz-&gt;transitions-&gt;len;
1791 
1792   /* find the interval containing *time UTC
1793    * TODO: this could be binary searched (or better) */
1794   for (i = 0; i &lt;= intervals; i++)
1795     if (*time_ &lt;= interval_end (tz, i))
1796       break;
1797 
1798   g_assert (interval_start (tz, i) &lt;= *time_ &amp;&amp; *time_ &lt;= interval_end (tz, i));
1799 
1800   if (type != G_TIME_TYPE_UNIVERSAL)
1801     {
1802       if (*time_ &lt; interval_local_start (tz, i))
1803         /* if time came before the start of this interval... */
1804         {
1805           i--;
1806 
1807           /* if it&#39;s not in the previous interval... */
1808           if (*time_ &gt; interval_local_end (tz, i))
1809             {
1810               /* it doesn&#39;t exist.  fast-forward it. */
1811               i++;
1812               *time_ = interval_local_start (tz, i);
1813             }
1814         }
1815 
1816       else if (*time_ &gt; interval_local_end (tz, i))
1817         /* if time came after the end of this interval... */
1818         {
1819           i++;
1820 
1821           /* if it&#39;s not in the next interval... */
1822           if (*time_ &lt; interval_local_start (tz, i))
1823             /* it doesn&#39;t exist.  fast-forward it. */
1824             *time_ = interval_local_start (tz, i);
1825         }
1826 
1827       else if (interval_isdst (tz, i) != type)
1828         /* it&#39;s in this interval, but dst flag doesn&#39;t match.
1829          * check neighbours for a better fit. */
1830         {
1831           if (i &amp;&amp; *time_ &lt;= interval_local_end (tz, i - 1))
1832             i--;
1833 
1834           else if (i &lt; intervals &amp;&amp;
1835                    *time_ &gt;= interval_local_start (tz, i + 1))
1836             i++;
1837         }
1838     }
1839 
1840   return i;
1841 }
1842 
1843 /**
1844  * g_time_zone_find_interval:
1845  * @tz: a #GTimeZone
1846  * @type: the #GTimeType of @time_
1847  * @time_: a number of seconds since January 1, 1970
1848  *
1849  * Finds an the interval within @tz that corresponds to the given @time_.
1850  * The meaning of @time_ depends on @type.
1851  *
1852  * If @type is %G_TIME_TYPE_UNIVERSAL then this function will always
1853  * succeed (since universal time is monotonic and continuous).
1854  *
1855  * Otherwise @time_ is treated as local time.  The distinction between
1856  * %G_TIME_TYPE_STANDARD and %G_TIME_TYPE_DAYLIGHT is ignored except in
1857  * the case that the given @time_ is ambiguous.  In Toronto, for example,
1858  * 01:30 on November 7th 2010 occurred twice (once inside of daylight
1859  * savings time and the next, an hour later, outside of daylight savings
1860  * time).  In this case, the different value of @type would result in a
1861  * different interval being returned.
1862  *
1863  * It is still possible for this function to fail.  In Toronto, for
1864  * example, 02:00 on March 14th 2010 does not exist (due to the leap
1865  * forward to begin daylight savings time).  -1 is returned in that
1866  * case.
1867  *
1868  * Returns: the interval containing @time_, or -1 in case of failure
1869  *
1870  * Since: 2.26
1871  */
1872 gint
1873 g_time_zone_find_interval (GTimeZone *tz,
1874                            GTimeType  type,
1875                            gint64     time_)
1876 {
1877   gint i;
1878   guint intervals;
1879 
1880   if (tz-&gt;transitions == NULL)
1881     return 0;
1882   intervals = tz-&gt;transitions-&gt;len;
1883   for (i = 0; i &lt;= intervals; i++)
1884     if (time_ &lt;= interval_end (tz, i))
1885       break;
1886 
1887   if (type == G_TIME_TYPE_UNIVERSAL)
1888     return i;
1889 
1890   if (time_ &lt; interval_local_start (tz, i))
1891     {
1892       if (time_ &gt; interval_local_end (tz, --i))
1893         return -1;
1894     }
1895 
1896   else if (time_ &gt; interval_local_end (tz, i))
1897     {
1898       if (time_ &lt; interval_local_start (tz, ++i))
1899         return -1;
1900     }
1901 
1902   else if (interval_isdst (tz, i) != type)
1903     {
1904       if (i &amp;&amp; time_ &lt;= interval_local_end (tz, i - 1))
1905         i--;
1906 
1907       else if (i &lt; intervals &amp;&amp; time_ &gt;= interval_local_start (tz, i + 1))
1908         i++;
1909     }
1910 
1911   return i;
1912 }
1913 
1914 /* Public API accessors {{{1 */
1915 
1916 /**
1917  * g_time_zone_get_abbreviation:
1918  * @tz: a #GTimeZone
1919  * @interval: an interval within the timezone
1920  *
1921  * Determines the time zone abbreviation to be used during a particular
1922  * @interval of time in the time zone @tz.
1923  *
1924  * For example, in Toronto this is currently &quot;EST&quot; during the winter
1925  * months and &quot;EDT&quot; during the summer months when daylight savings time
1926  * is in effect.
1927  *
1928  * Returns: the time zone abbreviation, which belongs to @tz
1929  *
1930  * Since: 2.26
1931  **/
1932 const gchar *
1933 g_time_zone_get_abbreviation (GTimeZone *tz,
1934                               gint       interval)
1935 {
1936   g_return_val_if_fail (interval_valid (tz, (guint)interval), NULL);
1937 
1938   return interval_abbrev (tz, (guint)interval);
1939 }
1940 
1941 /**
1942  * g_time_zone_get_offset:
1943  * @tz: a #GTimeZone
1944  * @interval: an interval within the timezone
1945  *
1946  * Determines the offset to UTC in effect during a particular @interval
1947  * of time in the time zone @tz.
1948  *
1949  * The offset is the number of seconds that you add to UTC time to
1950  * arrive at local time for @tz (ie: negative numbers for time zones
1951  * west of GMT, positive numbers for east).
1952  *
1953  * Returns: the number of seconds that should be added to UTC to get the
1954  *          local time in @tz
1955  *
1956  * Since: 2.26
1957  **/
1958 gint32
1959 g_time_zone_get_offset (GTimeZone *tz,
1960                         gint       interval)
1961 {
1962   g_return_val_if_fail (interval_valid (tz, (guint)interval), 0);
1963 
1964   return interval_offset (tz, (guint)interval);
1965 }
1966 
1967 /**
1968  * g_time_zone_is_dst:
1969  * @tz: a #GTimeZone
1970  * @interval: an interval within the timezone
1971  *
1972  * Determines if daylight savings time is in effect during a particular
1973  * @interval of time in the time zone @tz.
1974  *
1975  * Returns: %TRUE if daylight savings time is in effect
1976  *
1977  * Since: 2.26
1978  **/
1979 gboolean
1980 g_time_zone_is_dst (GTimeZone *tz,
1981                     gint       interval)
1982 {
1983   g_return_val_if_fail (interval_valid (tz, interval), FALSE);
1984 
1985   if (tz-&gt;transitions == NULL)
1986     return FALSE;
1987 
1988   return interval_isdst (tz, (guint)interval);
1989 }
1990 
1991 /**
1992  * g_time_zone_get_identifier:
1993  * @tz: a #GTimeZone
1994  *
1995  * Get the identifier of this #GTimeZone, as passed to g_time_zone_new().
1996  * If the identifier passed at construction time was not recognised, `UTC` will
1997  * be returned. If it was %NULL, the identifier of the local timezone at
1998  * construction time will be returned.
1999  *
2000  * The identifier will be returned in the same format as provided at
2001  * construction time: if provided as a time offset, that will be returned by
2002  * this function.
2003  *
2004  * Returns: identifier for this timezone
2005  * Since: 2.58
2006  */
2007 const gchar *
2008 g_time_zone_get_identifier (GTimeZone *tz)
2009 {
2010   g_return_val_if_fail (tz != NULL, NULL);
2011 
2012   return tz-&gt;name;
2013 }
2014 
2015 /* Epilogue {{{1 */
2016 /* vim:set foldmethod=marker: */
    </pre>
  </body>
</html>