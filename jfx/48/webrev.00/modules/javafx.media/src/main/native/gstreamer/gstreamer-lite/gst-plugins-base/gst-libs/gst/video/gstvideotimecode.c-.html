<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/gstvideotimecode.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) &lt;2016&gt; Vivia Nikolaidou &lt;vivia@toolsonair.com&gt;
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Library General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Library General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Library General Public
  15  * License along with this library; if not, write to the
  16  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  17  * Boston, MA 02110-1301, USA.
  18  */
  19 
  20 #include &lt;stdio.h&gt;
  21 #include &quot;gstvideotimecode.h&quot;
  22 
  23 static void
  24 gst_video_time_code_gvalue_to_string (const GValue * tc_val, GValue * str_val);
  25 static void
  26 gst_video_time_code_gvalue_from_string (const GValue * str_val,
  27     GValue * tc_val);
  28 static gboolean gst_video_time_code_deserialize (GValue * dest,
  29     const gchar * tc_str);
  30 static gchar *gst_video_time_code_serialize (const GValue * val);
  31 
  32 static void
  33 _init (GType type)
  34 {
  35   static GstValueTable table =
  36       { 0, (GstValueCompareFunc) gst_video_time_code_compare,
  37     (GstValueSerializeFunc) gst_video_time_code_serialize,
  38     (GstValueDeserializeFunc) gst_video_time_code_deserialize
  39   };
  40 
  41   table.type = type;
  42   gst_value_register (&amp;table);
  43   g_value_register_transform_func (type, G_TYPE_STRING,
  44       (GValueTransform) gst_video_time_code_gvalue_to_string);
  45   g_value_register_transform_func (G_TYPE_STRING, type,
  46       (GValueTransform) gst_video_time_code_gvalue_from_string);
  47 }
  48 
  49 G_DEFINE_BOXED_TYPE_WITH_CODE (GstVideoTimeCode, gst_video_time_code,
  50     (GBoxedCopyFunc) gst_video_time_code_copy,
  51     (GBoxedFreeFunc) gst_video_time_code_free, _init (g_define_type_id));
  52 
  53 /**
  54  * gst_video_time_code_is_valid:
  55  * @tc: #GstVideoTimeCode to check
  56  *
  57  * Returns: whether @tc is a valid timecode (supported frame rate,
  58  * hours/minutes/seconds/frames not overflowing)
  59  *
  60  * Since: 1.10
  61  */
  62 gboolean
  63 gst_video_time_code_is_valid (const GstVideoTimeCode * tc)
  64 {
  65   guint fr;
  66 
  67   g_return_val_if_fail (tc != NULL, FALSE);
  68 
  69   fr = (tc-&gt;config.fps_n + (tc-&gt;config.fps_d &gt;&gt; 1)) / tc-&gt;config.fps_d;
  70 
  71   if (tc-&gt;hours &gt;= 24)
  72     return FALSE;
  73   if (tc-&gt;minutes &gt;= 60)
  74     return FALSE;
  75   if (tc-&gt;seconds &gt;= 60)
  76     return FALSE;
  77   if (tc-&gt;config.fps_d == 0)
  78     return FALSE;
  79   if (tc-&gt;frames &gt;= fr &amp;&amp; (tc-&gt;config.fps_n != 0 || tc-&gt;config.fps_d != 1))
  80     return FALSE;
  81   if (tc-&gt;config.fps_d == 1001) {
  82     if (tc-&gt;config.fps_n != 30000 &amp;&amp; tc-&gt;config.fps_n != 60000 &amp;&amp;
  83         tc-&gt;config.fps_n != 24000)
  84       return FALSE;
  85   } else if (tc-&gt;config.fps_n % tc-&gt;config.fps_d != 0) {
  86     return FALSE;
  87   }
  88   if ((tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME) &amp;&amp;
  89       tc-&gt;minutes % 10 &amp;&amp; tc-&gt;seconds == 0 &amp;&amp; tc-&gt;frames &lt; fr / 15) {
  90     return FALSE;
  91   }
  92 
  93   return TRUE;
  94 }
  95 
  96 /**
  97  * gst_video_time_code_to_string:
  98  * @tc: #GstVideoTimeCode to convert
  99  *
 100  * Returns: the SMPTE ST 2059-1:2015 string representation of @tc. That will
 101  * take the form hh:mm:ss:ff . The last separator (between seconds and frames)
 102  * may vary:
 103  *
 104  * &#39;;&#39; for drop-frame, non-interlaced content and for drop-frame interlaced
 105  * field 2
 106  * &#39;,&#39; for drop-frame interlaced field 1
 107  * &#39;:&#39; for non-drop-frame, non-interlaced content and for non-drop-frame
 108  * interlaced field 2
 109  * &#39;.&#39; for non-drop-frame interlaced field 1
 110  *
 111  * Since: 1.10
 112  */
 113 gchar *
 114 gst_video_time_code_to_string (const GstVideoTimeCode * tc)
 115 {
 116   gchar *ret;
 117   gboolean top_dot_present;
 118   gchar sep;
 119 
 120   /* Top dot is present for non-interlaced content, and for field 2 in
 121    * interlaced content */
 122   top_dot_present =
 123       !((tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_INTERLACED) != 0
 124       &amp;&amp; tc-&gt;field_count == 1);
 125 
 126   if (tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME)
 127     sep = top_dot_present ? &#39;;&#39; : &#39;,&#39;;
 128   else
 129     sep = top_dot_present ? &#39;:&#39; : &#39;.&#39;;
 130 
 131   ret =
 132       g_strdup_printf (&quot;%02d:%02d:%02d%c%02d&quot;, tc-&gt;hours, tc-&gt;minutes,
 133       tc-&gt;seconds, sep, tc-&gt;frames);
 134 
 135   return ret;
 136 }
 137 
 138 /**
 139  * gst_video_time_code_to_date_time:
 140  * @tc: A valid #GstVideoTimeCode to convert
 141  *
 142  * The @tc.config-&gt;latest_daily_jam is required to be non-NULL.
 143  *
 144  * Returns: the #GDateTime representation of @tc.
 145  *
 146  * Since: 1.10
 147  */
 148 GDateTime *
 149 gst_video_time_code_to_date_time (const GstVideoTimeCode * tc)
 150 {
 151   GDateTime *ret;
 152   GDateTime *ret2;
 153   gdouble add_us;
 154 
 155   g_return_val_if_fail (gst_video_time_code_is_valid (tc), NULL);
 156   g_return_val_if_fail (tc-&gt;config.latest_daily_jam != NULL, NULL);
 157 
 158   ret = g_date_time_ref (tc-&gt;config.latest_daily_jam);
 159 
 160   if (ret == NULL) {
 161     gchar *tc_str = gst_video_time_code_to_string (tc);
 162     GST_WARNING
 163         (&quot;Asked to convert time code %s to GDateTime, but its latest daily jam is NULL&quot;,
 164         tc_str);
 165     g_free (tc_str);
 166     g_date_time_unref (ret);
 167     return NULL;
 168   }
 169 
 170   if (tc-&gt;config.fps_n == 0 &amp;&amp; tc-&gt;config.fps_d == 1) {
 171     gchar *tc_str = gst_video_time_code_to_string (tc);
 172     GST_WARNING
 173         (&quot;Asked to convert time code %s to GDateTime, but its framerate is unknown&quot;,
 174         tc_str);
 175     g_free (tc_str);
 176     g_date_time_unref (ret);
 177     return NULL;
 178   }
 179 
 180   gst_util_fraction_to_double (tc-&gt;frames * tc-&gt;config.fps_d, tc-&gt;config.fps_n,
 181       &amp;add_us);
 182   if ((tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_INTERLACED)
 183       &amp;&amp; tc-&gt;field_count == 1) {
 184     gdouble sub_us;
 185 
 186     gst_util_fraction_to_double (tc-&gt;config.fps_d, 2 * tc-&gt;config.fps_n,
 187         &amp;sub_us);
 188     add_us -= sub_us;
 189   }
 190 
 191   ret2 = g_date_time_add_seconds (ret, add_us + tc-&gt;seconds);
 192   g_date_time_unref (ret);
 193   ret = g_date_time_add_minutes (ret2, tc-&gt;minutes);
 194   g_date_time_unref (ret2);
 195   ret2 = g_date_time_add_hours (ret, tc-&gt;hours);
 196   g_date_time_unref (ret);
 197 
 198   return ret2;
 199 }
 200 
 201 /**
 202  * gst_video_time_code_init_from_date_time:
 203  * @tc: a #GstVideoTimeCode
 204  * @fps_n: Numerator of the frame rate
 205  * @fps_d: Denominator of the frame rate
 206  * @dt: #GDateTime to convert
 207  * @flags: #GstVideoTimeCodeFlags
 208  * @field_count: Interlaced video field count
 209  *
 210  * The resulting config-&gt;latest_daily_jam is set to
 211  * midnight, and timecode is set to the given time.
 212  *
 213  * Since: 1.12
 214  */
 215 
 216 void
 217 gst_video_time_code_init_from_date_time (GstVideoTimeCode * tc,
 218     guint fps_n, guint fps_d,
 219     GDateTime * dt, GstVideoTimeCodeFlags flags, guint field_count)
 220 {
 221   GDateTime *jam;
 222   guint64 frames;
 223   gboolean add_a_frame = FALSE;
 224 
 225   jam = g_date_time_new_local (g_date_time_get_year (dt),
 226       g_date_time_get_month (dt), g_date_time_get_day_of_month (dt), 0, 0, 0.0);
 227 
 228   /* Note: This might be inaccurate for 1 frame
 229    * in case we have a drop frame timecode */
 230   frames =
 231       gst_util_uint64_scale_round (g_date_time_get_microsecond (dt) *
 232       G_GINT64_CONSTANT (1000), fps_n, fps_d * GST_SECOND);
 233   if (G_UNLIKELY (((frames == fps_n) &amp;&amp; (fps_d == 1)) ||
 234           ((frames == fps_n / 1000) &amp;&amp; (fps_d == 1001)))) {
 235     /* Avoid invalid timecodes */
 236     frames--;
 237     add_a_frame = TRUE;
 238   }
 239 
 240   gst_video_time_code_init (tc, fps_n, fps_d, jam, flags,
 241       g_date_time_get_hour (dt), g_date_time_get_minute (dt),
 242       g_date_time_get_second (dt), frames, field_count);
 243 
 244   if (tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME) {
 245     guint df = (tc-&gt;config.fps_n + (tc-&gt;config.fps_d &gt;&gt; 1)) /
 246         (15 * tc-&gt;config.fps_d);
 247     if (tc-&gt;minutes % 10 &amp;&amp; tc-&gt;seconds == 0 &amp;&amp; tc-&gt;frames &lt; df) {
 248       tc-&gt;frames = df;
 249     }
 250   }
 251   if (add_a_frame)
 252     gst_video_time_code_increment_frame (tc);
 253 
 254   g_date_time_unref (jam);
 255 
 256   g_return_if_fail (gst_video_time_code_is_valid (tc));
 257 }
 258 
 259 /**
 260  * gst_video_time_code_nsec_since_daily_jam:
 261  * @tc: a valid #GstVideoTimeCode
 262  *
 263  * Returns: how many nsec have passed since the daily jam of @tc .
 264  *
 265  * Since: 1.10
 266  */
 267 guint64
 268 gst_video_time_code_nsec_since_daily_jam (const GstVideoTimeCode * tc)
 269 {
 270   guint64 frames, nsec;
 271 
 272   g_return_val_if_fail (gst_video_time_code_is_valid (tc), -1);
 273 
 274   if (tc-&gt;config.fps_n == 0 &amp;&amp; tc-&gt;config.fps_d == 1) {
 275     gchar *tc_str = gst_video_time_code_to_string (tc);
 276     GST_WARNING
 277         (&quot;Asked to calculate nsec since daily jam of time code %s, but its framerate is unknown&quot;,
 278         tc_str);
 279     g_free (tc_str);
 280     return -1;
 281   }
 282 
 283   frames = gst_video_time_code_frames_since_daily_jam (tc);
 284   nsec =
 285       gst_util_uint64_scale (frames, GST_SECOND * tc-&gt;config.fps_d,
 286       tc-&gt;config.fps_n);
 287 
 288   return nsec;
 289 }
 290 
 291 /**
 292  * gst_video_time_code_frames_since_daily_jam:
 293  * @tc: a valid #GstVideoTimeCode
 294  *
 295  * Returns: how many frames have passed since the daily jam of @tc .
 296  *
 297  * Since: 1.10
 298  */
 299 guint64
 300 gst_video_time_code_frames_since_daily_jam (const GstVideoTimeCode * tc)
 301 {
 302   guint ff_nom;
 303   gdouble ff;
 304 
 305   g_return_val_if_fail (gst_video_time_code_is_valid (tc), -1);
 306 
 307   gst_util_fraction_to_double (tc-&gt;config.fps_n, tc-&gt;config.fps_d, &amp;ff);
 308   if (tc-&gt;config.fps_d == 1001) {
 309     ff_nom = tc-&gt;config.fps_n / 1000;
 310   } else {
 311     ff_nom = ff;
 312   }
 313   if (tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME) {
 314     /* these need to be truncated to integer: side effect, code looks cleaner
 315      * */
 316     guint ff_minutes = 60 * ff;
 317     guint ff_hours = 3600 * ff;
 318     /* for 30000/1001 we drop the first 2 frames per minute, for 60000/1001 we
 319      * drop the first 4 : so we use this number */
 320     guint dropframe_multiplier;
 321 
 322     if (tc-&gt;config.fps_n == 30000) {
 323       dropframe_multiplier = 2;
 324     } else if (tc-&gt;config.fps_n == 60000) {
 325       dropframe_multiplier = 4;
 326     } else {
 327       GST_ERROR (&quot;Unsupported drop frame rate %u/%u&quot;, tc-&gt;config.fps_n,
 328           tc-&gt;config.fps_d);
 329       return -1;
 330     }
 331 
 332     return tc-&gt;frames + (ff_nom * tc-&gt;seconds) +
 333         (ff_minutes * tc-&gt;minutes) +
 334         dropframe_multiplier * ((gint) (tc-&gt;minutes / 10)) +
 335         (ff_hours * tc-&gt;hours);
 336   } else {
 337     return tc-&gt;frames + (ff_nom * (tc-&gt;seconds + (60 * (tc-&gt;minutes +
 338                     (60 * tc-&gt;hours)))));
 339   }
 340 
 341 }
 342 
 343 /**
 344  * gst_video_time_code_increment_frame:
 345  * @tc: a valid #GstVideoTimeCode
 346  *
 347  * Adds one frame to @tc .
 348  *
 349  * Since: 1.10
 350  */
 351 void
 352 gst_video_time_code_increment_frame (GstVideoTimeCode * tc)
 353 {
 354   gst_video_time_code_add_frames (tc, 1);
 355 }
 356 
 357 /**
 358  * gst_video_time_code_add_frames:
 359  * @tc: a valid #GstVideoTimeCode
 360  * @frames: How many frames to add or subtract
 361  *
 362  * Adds or subtracts @frames amount of frames to @tc. tc needs to
 363  * contain valid data, as verified by #gst_video_time_code_is_valid.
 364  *
 365  * Since: 1.10
 366  */
 367 void
 368 gst_video_time_code_add_frames (GstVideoTimeCode * tc, gint64 frames)
 369 {
 370   guint64 framecount;
 371   guint64 h_notmod24;
 372   guint64 h_new, min_new, sec_new, frames_new;
 373   gdouble ff;
 374   guint ff_nom;
 375   /* This allows for better readability than putting G_GUINT64_CONSTANT(60)
 376    * into a long calculation line */
 377   const guint64 sixty = 60;
 378   /* formulas found in SMPTE ST 2059-1:2015 section 9.4.3
 379    * and adapted for 60/1.001 as well as 30/1.001 */
 380 
 381   g_return_if_fail (gst_video_time_code_is_valid (tc));
 382 
 383   gst_util_fraction_to_double (tc-&gt;config.fps_n, tc-&gt;config.fps_d, &amp;ff);
 384   if (tc-&gt;config.fps_d == 1001) {
 385     ff_nom = tc-&gt;config.fps_n / 1000;
 386   } else {
 387     ff_nom = ff;
 388     if (tc-&gt;config.fps_d != 1)
 389       GST_WARNING (&quot;Unsupported frame rate %u/%u, results may be wrong&quot;,
 390           tc-&gt;config.fps_n, tc-&gt;config.fps_d);
 391   }
 392   if (tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME) {
 393     /* these need to be truncated to integer: side effect, code looks cleaner
 394      * */
 395     guint ff_minutes = 60 * ff;
 396     guint ff_hours = 3600 * ff;
 397     /* a bunch of intermediate variables, to avoid monster code with possible
 398      * integer overflows */
 399     guint64 min_new_tmp1, min_new_tmp2, min_new_tmp3, min_new_denom;
 400     /* for 30000/1001 we drop the first 2 frames per minute, for 60000/1001 we
 401      * drop the first 4 : so we use this number */
 402     guint dropframe_multiplier;
 403 
 404     if (tc-&gt;config.fps_n == 30000)
 405       dropframe_multiplier = 2;
 406     else if (tc-&gt;config.fps_n == 60000)
 407       dropframe_multiplier = 4;
 408     else {
 409       GST_ERROR (&quot;Unsupported drop frame rate %u/%u&quot;, tc-&gt;config.fps_n,
 410           tc-&gt;config.fps_d);
 411       return;
 412     }
 413 
 414     framecount =
 415         frames + tc-&gt;frames + (ff_nom * tc-&gt;seconds) +
 416         (ff_minutes * tc-&gt;minutes) +
 417         dropframe_multiplier * ((gint) (tc-&gt;minutes / 10)) +
 418         (ff_hours * tc-&gt;hours);
 419     h_notmod24 = gst_util_uint64_scale_int (framecount, 1, ff_hours);
 420 
 421     min_new_denom = sixty * ff_nom;
 422     min_new_tmp1 = (framecount - (h_notmod24 * ff_hours)) / min_new_denom;
 423     min_new_tmp2 = framecount + dropframe_multiplier * min_new_tmp1;
 424     min_new_tmp1 =
 425         (framecount - (h_notmod24 * ff_hours)) / (sixty * 10 * ff_nom);
 426     min_new_tmp3 =
 427         dropframe_multiplier * min_new_tmp1 + (h_notmod24 * ff_hours);
 428     min_new =
 429         gst_util_uint64_scale_int (min_new_tmp2 - min_new_tmp3, 1,
 430         min_new_denom);
 431 
 432     sec_new =
 433         (guint64) ((framecount - (ff_minutes * min_new) -
 434             dropframe_multiplier * ((gint) (min_new / 10)) -
 435             (ff_hours * h_notmod24)) / ff_nom);
 436 
 437     frames_new =
 438         framecount - (ff_nom * sec_new) - (ff_minutes * min_new) -
 439         (dropframe_multiplier * ((gint) (min_new / 10))) -
 440         (ff_hours * h_notmod24);
 441   } else {
 442     framecount =
 443         frames + tc-&gt;frames + (ff_nom * (tc-&gt;seconds + (sixty * (tc-&gt;minutes +
 444                     (sixty * tc-&gt;hours)))));
 445     h_notmod24 =
 446         gst_util_uint64_scale_int (framecount, 1, ff_nom * sixty * sixty);
 447     min_new =
 448         gst_util_uint64_scale_int ((framecount -
 449             (ff_nom * sixty * sixty * h_notmod24)), 1, (ff_nom * sixty));
 450     sec_new =
 451         gst_util_uint64_scale_int ((framecount - (ff_nom * sixty * (min_new +
 452                     (sixty * h_notmod24)))), 1, ff_nom);
 453     frames_new =
 454         framecount - (ff_nom * (sec_new + sixty * (min_new +
 455                 (sixty * h_notmod24))));
 456     if (frames_new &gt; ff_nom)
 457       frames_new = 0;
 458   }
 459   h_new = h_notmod24 % 24;
 460 
 461   g_assert (min_new &lt; 60);
 462   g_assert (sec_new &lt; 60);
 463   g_assert (frames_new &lt; ff_nom);
 464   tc-&gt;hours = h_new;
 465   tc-&gt;minutes = min_new;
 466   tc-&gt;seconds = sec_new;
 467   tc-&gt;frames = frames_new;
 468 }
 469 
 470 /**
 471  * gst_video_time_code_compare:
 472  * @tc1: a #GstVideoTimeCode
 473  * @tc2: another #GstVideoTimeCode
 474  *
 475  * Compares @tc1 and @tc2 . If both have latest daily jam information, it is
 476  * taken into account. Otherwise, it is assumed that the daily jam of both
 477  * @tc1 and @tc2 was at the same time. Both time codes must be valid.
 478  *
 479  * Returns: 1 if @tc1 is after @tc2, -1 if @tc1 is before @tc2, 0 otherwise.
 480  *
 481  * Since: 1.10
 482  */
 483 gint
 484 gst_video_time_code_compare (const GstVideoTimeCode * tc1,
 485     const GstVideoTimeCode * tc2)
 486 {
 487   g_return_val_if_fail (gst_video_time_code_is_valid (tc1), -1);
 488   g_return_val_if_fail (gst_video_time_code_is_valid (tc2), -1);
 489 
 490   if (tc1-&gt;config.latest_daily_jam == NULL
 491       || tc2-&gt;config.latest_daily_jam == NULL) {
 492     guint64 nsec1, nsec2;
 493 #ifndef GST_DISABLE_GST_DEBUG
 494     gchar *str1, *str2;
 495 
 496     str1 = gst_video_time_code_to_string (tc1);
 497     str2 = gst_video_time_code_to_string (tc2);
 498     GST_INFO
 499         (&quot;Comparing time codes %s and %s, but at least one of them has no &quot;
 500         &quot;latest daily jam information. Assuming they started together&quot;,
 501         str1, str2);
 502     g_free (str1);
 503     g_free (str2);
 504 #endif
 505     if (tc1-&gt;hours &gt; tc2-&gt;hours) {
 506       return 1;
 507     } else if (tc1-&gt;hours &lt; tc2-&gt;hours) {
 508       return -1;
 509     }
 510     if (tc1-&gt;minutes &gt; tc2-&gt;minutes) {
 511       return 1;
 512     } else if (tc1-&gt;minutes &lt; tc2-&gt;minutes) {
 513       return -1;
 514     }
 515     if (tc1-&gt;seconds &gt; tc2-&gt;seconds) {
 516       return 1;
 517     } else if (tc1-&gt;seconds &lt; tc2-&gt;seconds) {
 518       return -1;
 519     }
 520 
 521     nsec1 =
 522         gst_util_uint64_scale (GST_SECOND,
 523         tc1-&gt;frames * tc1-&gt;config.fps_n, tc1-&gt;config.fps_d);
 524     nsec2 =
 525         gst_util_uint64_scale (GST_SECOND,
 526         tc2-&gt;frames * tc2-&gt;config.fps_n, tc2-&gt;config.fps_d);
 527     if (nsec1 &gt; nsec2) {
 528       return 1;
 529     } else if (nsec1 &lt; nsec2) {
 530       return -1;
 531     }
 532     if (tc1-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_INTERLACED) {
 533       if (tc1-&gt;field_count &gt; tc2-&gt;field_count)
 534         return 1;
 535       else if (tc1-&gt;field_count &lt; tc2-&gt;field_count)
 536         return -1;
 537     }
 538     return 0;
 539   } else {
 540     GDateTime *dt1, *dt2;
 541     gint ret;
 542 
 543     dt1 = gst_video_time_code_to_date_time (tc1);
 544     dt2 = gst_video_time_code_to_date_time (tc2);
 545 
 546     ret = g_date_time_compare (dt1, dt2);
 547 
 548     g_date_time_unref (dt1);
 549     g_date_time_unref (dt2);
 550 
 551     return ret;
 552   }
 553 }
 554 
 555 /**
 556  * gst_video_time_code_new:
 557  * @fps_n: Numerator of the frame rate
 558  * @fps_d: Denominator of the frame rate
 559  * @latest_daily_jam: The latest daily jam of the #GstVideoTimeCode
 560  * @flags: #GstVideoTimeCodeFlags
 561  * @hours: the hours field of #GstVideoTimeCode
 562  * @minutes: the minutes field of #GstVideoTimeCode
 563  * @seconds: the seconds field of #GstVideoTimeCode
 564  * @frames: the frames field of #GstVideoTimeCode
 565  * @field_count: Interlaced video field count
 566  *
 567  * @field_count is 0 for progressive, 1 or 2 for interlaced.
 568  * @latest_daiy_jam reference is stolen from caller.
 569  *
 570  * Returns: a new #GstVideoTimeCode with the given values.
 571  * The values are not checked for being in a valid range. To see if your
 572  * timecode actually has valid content, use #gst_video_time_code_is_valid.
 573  *
 574  * Since: 1.10
 575  */
 576 GstVideoTimeCode *
 577 gst_video_time_code_new (guint fps_n, guint fps_d, GDateTime * latest_daily_jam,
 578     GstVideoTimeCodeFlags flags, guint hours, guint minutes, guint seconds,
 579     guint frames, guint field_count)
 580 {
 581   GstVideoTimeCode *tc;
 582 
 583   tc = g_new0 (GstVideoTimeCode, 1);
 584   gst_video_time_code_init (tc, fps_n, fps_d, latest_daily_jam, flags, hours,
 585       minutes, seconds, frames, field_count);
 586   return tc;
 587 }
 588 
 589 /**
 590  * gst_video_time_code_new_empty:
 591  *
 592  * Returns: a new empty #GstVideoTimeCode
 593  *
 594  * Since: 1.10
 595  */
 596 GstVideoTimeCode *
 597 gst_video_time_code_new_empty (void)
 598 {
 599   GstVideoTimeCode *tc;
 600 
 601   tc = g_new0 (GstVideoTimeCode, 1);
 602   gst_video_time_code_clear (tc);
 603   return tc;
 604 }
 605 
 606 static void
 607 gst_video_time_code_gvalue_from_string (const GValue * str_val, GValue * tc_val)
 608 {
 609   const gchar *tc_str = g_value_get_string (str_val);
 610   GstVideoTimeCode *tc;
 611 
 612   tc = gst_video_time_code_new_from_string (tc_str);
 613   g_value_take_boxed (tc_val, tc);
 614 }
 615 
 616 static void
 617 gst_video_time_code_gvalue_to_string (const GValue * tc_val, GValue * str_val)
 618 {
 619   const GstVideoTimeCode *tc = g_value_get_boxed (tc_val);
 620   gchar *tc_str;
 621 
 622   tc_str = gst_video_time_code_to_string (tc);
 623   g_value_take_string (str_val, tc_str);
 624 }
 625 
 626 static gchar *
 627 gst_video_time_code_serialize (const GValue * val)
 628 {
 629   GstVideoTimeCode *tc = g_value_get_boxed (val);
 630   return gst_video_time_code_to_string (tc);
 631 }
 632 
 633 static gboolean
 634 gst_video_time_code_deserialize (GValue * dest, const gchar * tc_str)
 635 {
 636   GstVideoTimeCode *tc = gst_video_time_code_new_from_string (tc_str);
 637 
 638   if (tc == NULL || !gst_video_time_code_is_valid (tc))
 639     return FALSE;
 640 
 641   g_value_take_boxed (dest, tc);
 642   return TRUE;
 643 }
 644 
 645 /**
 646  * gst_video_time_code_new_from_string:
 647  * @tc_str: The string that represents the #GstVideoTimeCode
 648  *
 649  * Returns: a new #GstVideoTimeCode from the given string
 650  *
 651  * Since: 1.12
 652  */
 653 GstVideoTimeCode *
 654 gst_video_time_code_new_from_string (const gchar * tc_str)
 655 {
 656   GstVideoTimeCode *tc;
 657   guint hours, minutes, seconds, frames;
 658 
 659   if (sscanf (tc_str, &quot;%02u:%02u:%02u:%02u&quot;, &amp;hours, &amp;minutes, &amp;seconds,
 660           &amp;frames)
 661       == 4
 662       || sscanf (tc_str, &quot;%02u:%02u:%02u;%02u&quot;, &amp;hours, &amp;minutes, &amp;seconds,
 663           &amp;frames)
 664       == 4
 665       || sscanf (tc_str, &quot;%02u:%02u:%02u.%02u&quot;, &amp;hours, &amp;minutes, &amp;seconds,
 666           &amp;frames)
 667       == 4
 668       || sscanf (tc_str, &quot;%02u:%02u:%02u,%02u&quot;, &amp;hours, &amp;minutes, &amp;seconds,
 669           &amp;frames)
 670       == 4) {
 671     tc = gst_video_time_code_new (0, 1, NULL, GST_VIDEO_TIME_CODE_FLAGS_NONE,
 672         hours, minutes, seconds, frames, 0);
 673 
 674     return tc;
 675   } else {
 676     GST_ERROR (&quot;Warning: Could not parse timecode %s. &quot;
 677         &quot;Please input a timecode in the form 00:00:00:00&quot;, tc_str);
 678     return NULL;
 679   }
 680 }
 681 
 682 /**
 683  * gst_video_time_code_new_from_date_time:
 684  * @fps_n: Numerator of the frame rate
 685  * @fps_d: Denominator of the frame rate
 686  * @dt: #GDateTime to convert
 687  * @flags: #GstVideoTimeCodeFlags
 688  * @field_count: Interlaced video field count
 689  *
 690  * The resulting config-&gt;latest_daily_jam is set to
 691  * midnight, and timecode is set to the given time.
 692  *
 693  * Returns: the #GVideoTimeCode representation of @dt.
 694  *
 695  * Since: 1.12
 696  */
 697 GstVideoTimeCode *
 698 gst_video_time_code_new_from_date_time (guint fps_n, guint fps_d,
 699     GDateTime * dt, GstVideoTimeCodeFlags flags, guint field_count)
 700 {
 701   GstVideoTimeCode *tc;
 702   tc = gst_video_time_code_new_empty ();
 703   gst_video_time_code_init_from_date_time (tc, fps_n, fps_d, dt, flags,
 704       field_count);
 705   return tc;
 706 }
 707 
 708 /**
 709  * gst_video_time_code_init:
 710  * @tc: a #GstVideoTimeCode
 711  * @fps_n: Numerator of the frame rate
 712  * @fps_d: Denominator of the frame rate
 713  * @latest_daily_jam: The latest daily jam of the #GstVideoTimeCode
 714  * @flags: #GstVideoTimeCodeFlags
 715  * @hours: the hours field of #GstVideoTimeCode
 716  * @minutes: the minutes field of #GstVideoTimeCode
 717  * @seconds: the seconds field of #GstVideoTimeCode
 718  * @frames: the frames field of #GstVideoTimeCode
 719  * @field_count: Interlaced video field count
 720  *
 721  * @field_count is 0 for progressive, 1 or 2 for interlaced.
 722  * @latest_daiy_jam reference is stolen from caller.
 723  *
 724  * Initializes @tc with the given values.
 725  * The values are not checked for being in a valid range. To see if your
 726  * timecode actually has valid content, use #gst_video_time_code_is_valid.
 727  *
 728  * Since: 1.10
 729  */
 730 void
 731 gst_video_time_code_init (GstVideoTimeCode * tc, guint fps_n, guint fps_d,
 732     GDateTime * latest_daily_jam, GstVideoTimeCodeFlags flags, guint hours,
 733     guint minutes, guint seconds, guint frames, guint field_count)
 734 {
 735   tc-&gt;hours = hours;
 736   tc-&gt;minutes = minutes;
 737   tc-&gt;seconds = seconds;
 738   tc-&gt;frames = frames;
 739   tc-&gt;field_count = field_count;
 740   tc-&gt;config.fps_n = fps_n;
 741   tc-&gt;config.fps_d = fps_d;
 742   if (latest_daily_jam != NULL)
 743     tc-&gt;config.latest_daily_jam = g_date_time_ref (latest_daily_jam);
 744   else
 745     tc-&gt;config.latest_daily_jam = NULL;
 746   tc-&gt;config.flags = flags;
 747 }
 748 
 749 /**
 750  * gst_video_time_code_clear:
 751  * @tc: a #GstVideoTimeCode
 752  *
 753  * Initializes @tc with empty/zero/NULL values.
 754  *
 755  * Since: 1.10
 756  */
 757 void
 758 gst_video_time_code_clear (GstVideoTimeCode * tc)
 759 {
 760   tc-&gt;hours = 0;
 761   tc-&gt;minutes = 0;
 762   tc-&gt;seconds = 0;
 763   tc-&gt;frames = 0;
 764   tc-&gt;field_count = 0;
 765   tc-&gt;config.fps_n = 0;
 766   tc-&gt;config.fps_d = 1;
 767   if (tc-&gt;config.latest_daily_jam != NULL)
 768     g_date_time_unref (tc-&gt;config.latest_daily_jam);
 769   tc-&gt;config.latest_daily_jam = NULL;
 770   tc-&gt;config.flags = 0;
 771 }
 772 
 773 /**
 774  * gst_video_time_code_copy:
 775  * @tc: a #GstVideoTimeCode
 776  *
 777  * Returns: a new #GstVideoTimeCode with the same values as @tc .
 778  *
 779  * Since: 1.10
 780  */
 781 GstVideoTimeCode *
 782 gst_video_time_code_copy (const GstVideoTimeCode * tc)
 783 {
 784   return gst_video_time_code_new (tc-&gt;config.fps_n, tc-&gt;config.fps_d,
 785       tc-&gt;config.latest_daily_jam, tc-&gt;config.flags, tc-&gt;hours, tc-&gt;minutes,
 786       tc-&gt;seconds, tc-&gt;frames, tc-&gt;field_count);
 787 }
 788 
 789 /**
 790  * gst_video_time_code_free:
 791  * @tc: a #GstVideoTimeCode
 792  *
 793  * Frees @tc .
 794  *
 795  * Since: 1.10
 796  */
 797 void
 798 gst_video_time_code_free (GstVideoTimeCode * tc)
 799 {
 800   if (tc-&gt;config.latest_daily_jam != NULL)
 801     g_date_time_unref (tc-&gt;config.latest_daily_jam);
 802 
 803   g_free (tc);
 804 }
 805 
 806 /**
 807  * gst_video_time_code_add_interval:
 808  * @tc: The #GstVideoTimeCode where the diff should be added. This
 809  * must contain valid timecode values.
 810  * @tc_inter: The #GstVideoTimeCodeInterval to add to @tc.
 811  * The interval must contain valid values, except that for drop-frame
 812  * timecode, it may also contain timecodes which would normally
 813  * be dropped. These are then corrected to the next reasonable timecode.
 814  *
 815  * This makes a component-wise addition of @tc_inter to @tc. For example,
 816  * adding (&quot;01:02:03:04&quot;, &quot;00:01:00:00&quot;) will return &quot;01:03:03:04&quot;.
 817  * When it comes to drop-frame timecodes,
 818  * adding (&quot;00:00:00;00&quot;, &quot;00:01:00:00&quot;) will return &quot;00:01:00;02&quot;
 819  * because of drop-frame oddities. However,
 820  * adding (&quot;00:09:00;02&quot;, &quot;00:01:00:00&quot;) will return &quot;00:10:00;00&quot;
 821  * because this time we can have an exact minute.
 822  *
 823  * Returns: A new #GstVideoTimeCode with @tc_inter added.
 824  *
 825  * Since: 1.12
 826  */
 827 GstVideoTimeCode *
 828 gst_video_time_code_add_interval (const GstVideoTimeCode * tc,
 829     const GstVideoTimeCodeInterval * tc_inter)
 830 {
 831   GstVideoTimeCode *ret;
 832   guint frames_to_add;
 833   guint df;
 834   gboolean needs_correction;
 835 
 836   g_return_val_if_fail (gst_video_time_code_is_valid (tc), NULL);
 837 
 838   ret = gst_video_time_code_new (tc-&gt;config.fps_n, tc-&gt;config.fps_d,
 839       tc-&gt;config.latest_daily_jam, tc-&gt;config.flags, tc_inter-&gt;hours,
 840       tc_inter-&gt;minutes, tc_inter-&gt;seconds, tc_inter-&gt;frames, 0);
 841 
 842   df = (tc-&gt;config.fps_n + (tc-&gt;config.fps_d &gt;&gt; 1)) / (tc-&gt;config.fps_d * 15);
 843 
 844   /* Drop-frame compensation: Create a valid timecode from the
 845    * interval */
 846   needs_correction = (tc-&gt;config.flags &amp; GST_VIDEO_TIME_CODE_FLAGS_DROP_FRAME)
 847       &amp;&amp; ret-&gt;minutes % 10 &amp;&amp; ret-&gt;seconds == 0 &amp;&amp; ret-&gt;frames &lt; df;
 848   if (needs_correction) {
 849     ret-&gt;minutes--;
 850     ret-&gt;seconds = 59;
 851     ret-&gt;frames = df * 14;
 852   }
 853 
 854   if (!gst_video_time_code_is_valid (ret)) {
 855     GST_ERROR (&quot;Unsupported time code interval&quot;);
 856     gst_video_time_code_free (ret);
 857     return NULL;
 858   }
 859 
 860   frames_to_add = gst_video_time_code_frames_since_daily_jam (tc);
 861 
 862   /* Drop-frame compensation: 00:01:00;00 is falsely interpreted as
 863    * 00:00:59;28 */
 864   if (needs_correction) {
 865     /* User wants us to split at invalid timecodes */
 866     if (tc-&gt;minutes % 10 == 0 &amp;&amp; tc-&gt;frames &lt;= df) {
 867       /* Apply compensation every 10th minute: before adding the frames,
 868        * but only if we are before the &quot;invalid frame&quot; mark */
 869       frames_to_add += df;
 870       needs_correction = FALSE;
 871     }
 872   }
 873   gst_video_time_code_add_frames (ret, frames_to_add);
 874   if (needs_correction &amp;&amp; ret-&gt;minutes % 10 == 0 &amp;&amp; tc-&gt;frames &gt; df) {
 875     gst_video_time_code_add_frames (ret, df);
 876   }
 877 
 878   return ret;
 879 }
 880 
 881 G_DEFINE_BOXED_TYPE (GstVideoTimeCodeInterval, gst_video_time_code_interval,
 882     (GBoxedCopyFunc) gst_video_time_code_interval_copy,
 883     (GBoxedFreeFunc) gst_video_time_code_interval_free);
 884 
 885 /**
 886  * gst_video_time_code_interval_new:
 887  * @hours: the hours field of #GstVideoTimeCodeInterval
 888  * @minutes: the minutes field of #GstVideoTimeCodeInterval
 889  * @seconds: the seconds field of #GstVideoTimeCodeInterval
 890  * @frames: the frames field of #GstVideoTimeCodeInterval
 891  *
 892  * Returns: a new #GstVideoTimeCodeInterval with the given values.
 893  *
 894  * Since: 1.12
 895  */
 896 GstVideoTimeCodeInterval *
 897 gst_video_time_code_interval_new (guint hours, guint minutes, guint seconds,
 898     guint frames)
 899 {
 900   GstVideoTimeCodeInterval *tc;
 901 
 902   tc = g_new0 (GstVideoTimeCodeInterval, 1);
 903   gst_video_time_code_interval_init (tc, hours, minutes, seconds, frames);
 904   return tc;
 905 }
 906 
 907 /**
 908  * gst_video_time_code_interval_new_from_string:
 909  * @tc_inter_str: The string that represents the #GstVideoTimeCodeInterval
 910  *
 911  * @tc_inter_str must only have &quot;:&quot; as separators.
 912  *
 913  * Returns: a new #GstVideoTimeCodeInterval from the given string
 914  *
 915  * Since: 1.12
 916  */
 917 GstVideoTimeCodeInterval *
 918 gst_video_time_code_interval_new_from_string (const gchar * tc_inter_str)
 919 {
 920   GstVideoTimeCodeInterval *tc;
 921   guint hours, minutes, seconds, frames;
 922 
 923   if (sscanf (tc_inter_str, &quot;%02u:%02u:%02u:%02u&quot;, &amp;hours, &amp;minutes, &amp;seconds,
 924           &amp;frames)
 925       == 4
 926       || sscanf (tc_inter_str, &quot;%02u:%02u:%02u;%02u&quot;, &amp;hours, &amp;minutes,
 927           &amp;seconds, &amp;frames)
 928       == 4
 929       || sscanf (tc_inter_str, &quot;%02u:%02u:%02u.%02u&quot;, &amp;hours, &amp;minutes,
 930           &amp;seconds, &amp;frames)
 931       == 4
 932       || sscanf (tc_inter_str, &quot;%02u:%02u:%02u,%02u&quot;, &amp;hours, &amp;minutes,
 933           &amp;seconds, &amp;frames)
 934       == 4) {
 935     tc = gst_video_time_code_interval_new (hours, minutes, seconds, frames);
 936 
 937     return tc;
 938   } else {
 939     GST_ERROR (&quot;Warning: Could not parse timecode %s. &quot;
 940         &quot;Please input a timecode in the form 00:00:00:00&quot;, tc_inter_str);
 941     return NULL;
 942   }
 943 
 944 }
 945 
 946 /**
 947  * gst_video_time_code_interval_init:
 948  * @tc: a #GstVideoTimeCodeInterval
 949  * @hours: the hours field of #GstVideoTimeCodeInterval
 950  * @minutes: the minutes field of #GstVideoTimeCodeInterval
 951  * @seconds: the seconds field of #GstVideoTimeCodeInterval
 952  * @frames: the frames field of #GstVideoTimeCodeInterval
 953  *
 954  * Initializes @tc with the given values.
 955  *
 956  * Since: 1.12
 957  */
 958 void
 959 gst_video_time_code_interval_init (GstVideoTimeCodeInterval * tc, guint hours,
 960     guint minutes, guint seconds, guint frames)
 961 {
 962   tc-&gt;hours = hours;
 963   tc-&gt;minutes = minutes;
 964   tc-&gt;seconds = seconds;
 965   tc-&gt;frames = frames;
 966 }
 967 
 968 /**
 969  * gst_video_time_code_interval_clear:
 970  * @tc: a #GstVideoTimeCodeInterval
 971  *
 972  * Initializes @tc with empty/zero/NULL values.
 973  *
 974  * Since: 1.12
 975  */
 976 void
 977 gst_video_time_code_interval_clear (GstVideoTimeCodeInterval * tc)
 978 {
 979   tc-&gt;hours = 0;
 980   tc-&gt;minutes = 0;
 981   tc-&gt;seconds = 0;
 982   tc-&gt;frames = 0;
 983 }
 984 
 985 /**
 986  * gst_video_time_code_interval_copy:
 987  * @tc: a #GstVideoTimeCodeInterval
 988  *
 989  * Returns: a new #GstVideoTimeCodeInterval with the same values as @tc .
 990  *
 991  * Since: 1.12
 992  */
 993 GstVideoTimeCodeInterval *
 994 gst_video_time_code_interval_copy (const GstVideoTimeCodeInterval * tc)
 995 {
 996   return gst_video_time_code_interval_new (tc-&gt;hours, tc-&gt;minutes,
 997       tc-&gt;seconds, tc-&gt;frames);
 998 }
 999 
1000 /**
1001  * gst_video_time_code_interval_free:
1002  * @tc: a #GstVideoTimeCodeInterval
1003  *
1004  * Frees @tc .
1005  *
1006  * Since: 1.12
1007  */
1008 void
1009 gst_video_time_code_interval_free (GstVideoTimeCodeInterval * tc)
1010 {
1011   g_free (tc);
1012 }
    </pre>
  </body>
</html>