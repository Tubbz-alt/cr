<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gdatetime.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* gdatetime.c
   2  *
   3  * Copyright (C) 2009-2010 Christian Hergert &lt;chris@dronelabs.com&gt;
   4  * Copyright (C) 2010 Thiago Santos &lt;thiago.sousa.santos@collabora.co.uk&gt;
   5  * Copyright (C) 2010 Emmanuele Bassi &lt;ebassi@linux.intel.com&gt;
   6  * Copyright (C) 2010 Codethink Limited
   7  * Copyright (C) 2018 Tomasz Miasko
   8  *
   9  * This library is free software; you can redistribute it and/or modify
  10  * it under the terms of the GNU Lesser General Public License as
  11  * published by the Free Software Foundation; either version 2.1 of the
  12  * licence, or (at your option) any later version.
  13  *
  14  * This is distributed in the hope that it will be useful, but WITHOUT
  15  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  16  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
  17  * License for more details.
  18  *
  19  * You should have received a copy of the GNU Lesser General Public License
  20  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  21  *
  22  * Authors: Christian Hergert &lt;chris@dronelabs.com&gt;
  23  *          Thiago Santos &lt;thiago.sousa.santos@collabora.co.uk&gt;
  24  *          Emmanuele Bassi &lt;ebassi@linux.intel.com&gt;
  25  *          Ryan Lortie &lt;desrt@desrt.ca&gt;
  26  *          Robert Ancell &lt;robert.ancell@canonical.com&gt;
  27  */
  28 
  29 /* Algorithms within this file are based on the Calendar FAQ by
  30  * Claus Tondering.  It can be found at
  31  * http://www.tondering.dk/claus/cal/calendar29.txt
  32  *
  33  * Copyright and disclaimer
  34  * ------------------------
  35  *   This document is Copyright (C) 2008 by Claus Tondering.
  36  *   E-mail: claus@tondering.dk. (Please include the word
  37  *   &quot;calendar&quot; in the subject line.)
  38  *   The document may be freely distributed, provided this
  39  *   copyright notice is included and no money is charged for
  40  *   the document.
  41  *
  42  *   This document is provided &quot;as is&quot;. No warranties are made as
  43  *   to its correctness.
  44  */
  45 
  46 /* Prologue {{{1 */
  47 
  48 #include &quot;config.h&quot;
  49 
  50 /* langinfo.h in glibc 2.27 defines ALTMON_* only if _GNU_SOURCE is defined.  */
  51 #ifndef _GNU_SOURCE
  52 #define _GNU_SOURCE 1
  53 #endif
  54 
  55 #include &lt;stdlib.h&gt;
  56 #include &lt;string.h&gt;
  57 
  58 #ifdef HAVE_LANGINFO_TIME
  59 #include &lt;langinfo.h&gt;
  60 #endif
  61 
  62 #include &quot;gdatetime.h&quot;
  63 
  64 #include &quot;gslice.h&quot;
  65 #include &quot;gatomic.h&quot;
  66 #include &quot;gcharset.h&quot;
  67 #include &quot;gconvert.h&quot;
  68 #include &quot;gfileutils.h&quot;
  69 #include &quot;ghash.h&quot;
  70 #include &quot;gmain.h&quot;
  71 #include &quot;gmappedfile.h&quot;
  72 #include &quot;gstrfuncs.h&quot;
  73 #include &quot;gtestutils.h&quot;
  74 #include &quot;gthread.h&quot;
  75 #include &quot;gtimezone.h&quot;
  76 
  77 #include &quot;glibintl.h&quot;
  78 
  79 #ifndef G_OS_WIN32
  80 #include &lt;sys/time.h&gt;
  81 #include &lt;time.h&gt;
  82 #endif /* !G_OS_WIN32 */
  83 
  84 /**
  85  * SECTION:date-time
  86  * @title: GDateTime
  87  * @short_description: a structure representing Date and Time
  88  * @see_also: #GTimeZone
  89  *
  90  * #GDateTime is a structure that combines a Gregorian date and time
  91  * into a single structure.  It provides many conversion and methods to
  92  * manipulate dates and times.  Time precision is provided down to
  93  * microseconds and the time can range (proleptically) from 0001-01-01
  94  * 00:00:00 to 9999-12-31 23:59:59.999999.  #GDateTime follows POSIX
  95  * time in the sense that it is oblivious to leap seconds.
  96  *
  97  * #GDateTime is an immutable object; once it has been created it cannot
  98  * be modified further.  All modifiers will create a new #GDateTime.
  99  * Nearly all such functions can fail due to the date or time going out
 100  * of range, in which case %NULL will be returned.
 101  *
 102  * #GDateTime is reference counted: the reference count is increased by calling
 103  * g_date_time_ref() and decreased by calling g_date_time_unref(). When the
 104  * reference count drops to 0, the resources allocated by the #GDateTime
 105  * structure are released.
 106  *
 107  * Many parts of the API may produce non-obvious results.  As an
 108  * example, adding two months to January 31st will yield March 31st
 109  * whereas adding one month and then one month again will yield either
 110  * March 28th or March 29th.  Also note that adding 24 hours is not
 111  * always the same as adding one day (since days containing daylight
 112  * savings time transitions are either 23 or 25 hours in length).
 113  *
 114  * #GDateTime is available since GLib 2.26.
 115  */
 116 
 117 struct _GDateTime
 118 {
 119   /* Microsecond timekeeping within Day */
 120   guint64 usec;
 121 
 122   /* TimeZone information */
 123   GTimeZone *tz;
 124   gint interval;
 125 
 126   /* 1 is 0001-01-01 in Proleptic Gregorian */
 127   gint32 days;
 128 
 129   volatile gint ref_count;
 130 };
 131 
 132 /* Time conversion {{{1 */
 133 
 134 #define UNIX_EPOCH_START     719163
 135 #define INSTANT_TO_UNIX(instant) \
 136   ((instant)/USEC_PER_SECOND - UNIX_EPOCH_START * SEC_PER_DAY)
 137 #define INSTANT_TO_UNIX_USECS(instant) \
 138   ((instant) - UNIX_EPOCH_START * SEC_PER_DAY * USEC_PER_SECOND)
 139 #define UNIX_TO_INSTANT(unix) \
 140   (((gint64) (unix) + UNIX_EPOCH_START * SEC_PER_DAY) * USEC_PER_SECOND)
 141 #define UNIX_USECS_TO_INSTANT(unix_usecs) \
 142   ((gint64) (unix_usecs) + UNIX_EPOCH_START * SEC_PER_DAY * USEC_PER_SECOND)
 143 #define UNIX_TO_INSTANT_IS_VALID(unix) \
 144   ((gint64) (unix) &lt;= INSTANT_TO_UNIX (G_MAXINT64))
 145 #define UNIX_USECS_TO_INSTANT_IS_VALID(unix_usecs) \
 146   ((gint64) (unix_usecs) &lt;= INSTANT_TO_UNIX_USECS (G_MAXINT64))
 147 
 148 #define DAYS_IN_4YEARS    1461    /* days in 4 years */
 149 #define DAYS_IN_100YEARS  36524   /* days in 100 years */
 150 #define DAYS_IN_400YEARS  146097  /* days in 400 years  */
 151 
 152 #define USEC_PER_SECOND      (G_GINT64_CONSTANT (1000000))
 153 #define USEC_PER_MINUTE      (G_GINT64_CONSTANT (60000000))
 154 #define USEC_PER_HOUR        (G_GINT64_CONSTANT (3600000000))
 155 #define USEC_PER_MILLISECOND (G_GINT64_CONSTANT (1000))
 156 #define USEC_PER_DAY         (G_GINT64_CONSTANT (86400000000))
 157 #define SEC_PER_DAY          (G_GINT64_CONSTANT (86400))
 158 
 159 #define SECS_PER_MINUTE (60)
 160 #define SECS_PER_HOUR   (60 * SECS_PER_MINUTE)
 161 #define SECS_PER_DAY    (24 * SECS_PER_HOUR)
 162 #define SECS_PER_YEAR   (365 * SECS_PER_DAY)
 163 #define SECS_PER_JULIAN (DAYS_PER_PERIOD * SECS_PER_DAY)
 164 
 165 #define GREGORIAN_LEAP(y)    ((((y) % 4) == 0) &amp;&amp; (!((((y) % 100) == 0) &amp;&amp; (((y) % 400) != 0))))
 166 #define JULIAN_YEAR(d)       ((d)-&gt;julian / 365.25)
 167 #define DAYS_PER_PERIOD      (G_GINT64_CONSTANT (2914695))
 168 
 169 static const guint16 days_in_months[2][13] =
 170 {
 171   { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
 172   { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
 173 };
 174 
 175 static const guint16 days_in_year[2][13] =
 176 {
 177   {  0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
 178   {  0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
 179 };
 180 
 181 #ifdef HAVE_LANGINFO_TIME
 182 
 183 #define GET_AMPM(d) ((g_date_time_get_hour (d) &lt; 12) ? \
 184                      nl_langinfo (AM_STR) : \
 185                      nl_langinfo (PM_STR))
 186 #define GET_AMPM_IS_LOCALE TRUE
 187 
 188 #define PREFERRED_DATE_TIME_FMT nl_langinfo (D_T_FMT)
 189 #define PREFERRED_DATE_FMT nl_langinfo (D_FMT)
 190 #define PREFERRED_TIME_FMT nl_langinfo (T_FMT)
 191 #define PREFERRED_12HR_TIME_FMT nl_langinfo (T_FMT_AMPM)
 192 
 193 static const gint weekday_item[2][7] =
 194 {
 195   { ABDAY_2, ABDAY_3, ABDAY_4, ABDAY_5, ABDAY_6, ABDAY_7, ABDAY_1 },
 196   { DAY_2, DAY_3, DAY_4, DAY_5, DAY_6, DAY_7, DAY_1 }
 197 };
 198 
 199 static const gint month_item[2][12] =
 200 {
 201   { ABMON_1, ABMON_2, ABMON_3, ABMON_4, ABMON_5, ABMON_6, ABMON_7, ABMON_8, ABMON_9, ABMON_10, ABMON_11, ABMON_12 },
 202   { MON_1, MON_2, MON_3, MON_4, MON_5, MON_6, MON_7, MON_8, MON_9, MON_10, MON_11, MON_12 },
 203 };
 204 
 205 #define WEEKDAY_ABBR(d) nl_langinfo (weekday_item[0][g_date_time_get_day_of_week (d) - 1])
 206 #define WEEKDAY_ABBR_IS_LOCALE TRUE
 207 #define WEEKDAY_FULL(d) nl_langinfo (weekday_item[1][g_date_time_get_day_of_week (d) - 1])
 208 #define WEEKDAY_FULL_IS_LOCALE TRUE
 209 #define MONTH_ABBR(d) nl_langinfo (month_item[0][g_date_time_get_month (d) - 1])
 210 #define MONTH_ABBR_IS_LOCALE TRUE
 211 #define MONTH_FULL(d) nl_langinfo (month_item[1][g_date_time_get_month (d) - 1])
 212 #define MONTH_FULL_IS_LOCALE TRUE
 213 
 214 #else
 215 
 216 #define GET_AMPM(d)          (get_fallback_ampm (g_date_time_get_hour (d)))
 217 #define GET_AMPM_IS_LOCALE   FALSE
 218 
 219 /* Translators: this is the preferred format for expressing the date and the time */
 220 #define PREFERRED_DATE_TIME_FMT C_(&quot;GDateTime&quot;, &quot;%a %b %e %H:%M:%S %Y&quot;)
 221 
 222 /* Translators: this is the preferred format for expressing the date */
 223 #define PREFERRED_DATE_FMT C_(&quot;GDateTime&quot;, &quot;%m/%d/%y&quot;)
 224 
 225 /* Translators: this is the preferred format for expressing the time */
 226 #define PREFERRED_TIME_FMT C_(&quot;GDateTime&quot;, &quot;%H:%M:%S&quot;)
 227 
 228 /* Translators: this is the preferred format for expressing 12 hour time */
 229 #define PREFERRED_12HR_TIME_FMT C_(&quot;GDateTime&quot;, &quot;%I:%M:%S %p&quot;)
 230 
 231 #define WEEKDAY_ABBR(d)       (get_weekday_name_abbr (g_date_time_get_day_of_week (d)))
 232 #define WEEKDAY_ABBR_IS_LOCALE FALSE
 233 #define WEEKDAY_FULL(d)       (get_weekday_name (g_date_time_get_day_of_week (d)))
 234 #define WEEKDAY_FULL_IS_LOCALE FALSE
 235 /* We don&#39;t yet know if nl_langinfo (MON_n) returns standalone or complete-date
 236  * format forms but if nl_langinfo (ALTMON_n) is not supported then we will
 237  * have to use MONTH_FULL as standalone.  The same if nl_langinfo () does not
 238  * exist at all.  MONTH_ABBR is similar: if nl_langinfo (_NL_ABALTMON_n) is not
 239  * supported then we will use MONTH_ABBR as standalone.
 240  */
 241 #define MONTH_ABBR(d)         (get_month_name_abbr_standalone (g_date_time_get_month (d)))
 242 #define MONTH_ABBR_IS_LOCALE  FALSE
 243 #define MONTH_FULL(d)         (get_month_name_standalone (g_date_time_get_month (d)))
 244 #define MONTH_FULL_IS_LOCALE  FALSE
 245 
 246 static const gchar *
 247 get_month_name_standalone (gint month)
 248 {
 249   switch (month)
 250     {
 251     case 1:
 252       /* Translators: Some languages (Baltic, Slavic, Greek, and some more)
 253        * need different grammatical forms of month names depending on whether
 254        * they are standalone or in a complete date context, with the day
 255        * number.  Some other languages may prefer starting with uppercase when
 256        * they are standalone and with lowercase when they are in a complete
 257        * date context.  Here are full month names in a form appropriate when
 258        * they are used standalone.  If your system is Linux with the glibc
 259        * version 2.27 (released Feb 1, 2018) or newer or if it is from the BSD
 260        * family (which includes OS X) then you can refer to the date command
 261        * line utility and see what the command `date +%OB&#39; produces.  Also in
 262        * the latest Linux the command `locale alt_mon&#39; in your native locale
 263        * produces a complete list of month names almost ready to copy and
 264        * paste here.  Note that in most of the languages (western European,
 265        * non-European) there is no difference between the standalone and
 266        * complete date form.
 267        */
 268       return C_(&quot;full month name&quot;, &quot;January&quot;);
 269     case 2:
 270       return C_(&quot;full month name&quot;, &quot;February&quot;);
 271     case 3:
 272       return C_(&quot;full month name&quot;, &quot;March&quot;);
 273     case 4:
 274       return C_(&quot;full month name&quot;, &quot;April&quot;);
 275     case 5:
 276       return C_(&quot;full month name&quot;, &quot;May&quot;);
 277     case 6:
 278       return C_(&quot;full month name&quot;, &quot;June&quot;);
 279     case 7:
 280       return C_(&quot;full month name&quot;, &quot;July&quot;);
 281     case 8:
 282       return C_(&quot;full month name&quot;, &quot;August&quot;);
 283     case 9:
 284       return C_(&quot;full month name&quot;, &quot;September&quot;);
 285     case 10:
 286       return C_(&quot;full month name&quot;, &quot;October&quot;);
 287     case 11:
 288       return C_(&quot;full month name&quot;, &quot;November&quot;);
 289     case 12:
 290       return C_(&quot;full month name&quot;, &quot;December&quot;);
 291 
 292     default:
 293       g_warning (&quot;Invalid month number %d&quot;, month);
 294     }
 295 
 296   return NULL;
 297 }
 298 
 299 static const gchar *
 300 get_month_name_abbr_standalone (gint month)
 301 {
 302   switch (month)
 303     {
 304     case 1:
 305       /* Translators: Some languages need different grammatical forms of
 306        * month names depending on whether they are standalone or in a complete
 307        * date context, with the day number.  Some may prefer starting with
 308        * uppercase when they are standalone and with lowercase when they are
 309        * in a full date context.  However, as these names are abbreviated
 310        * the grammatical difference is visible probably only in Belarusian
 311        * and Russian.  In other languages there is no difference between
 312        * the standalone and complete date form when they are abbreviated.
 313        * If your system is Linux with the glibc version 2.27 (released
 314        * Feb 1, 2018) or newer then you can refer to the date command line
 315        * utility and see what the command `date +%Ob&#39; produces.  Also in
 316        * the latest Linux the command `locale ab_alt_mon&#39; in your native
 317        * locale produces a complete list of month names almost ready to copy
 318        * and paste here.  Note that this feature is not yet supported by any
 319        * other platform.  Here are abbreviated month names in a form
 320        * appropriate when they are used standalone.
 321        */
 322       return C_(&quot;abbreviated month name&quot;, &quot;Jan&quot;);
 323     case 2:
 324       return C_(&quot;abbreviated month name&quot;, &quot;Feb&quot;);
 325     case 3:
 326       return C_(&quot;abbreviated month name&quot;, &quot;Mar&quot;);
 327     case 4:
 328       return C_(&quot;abbreviated month name&quot;, &quot;Apr&quot;);
 329     case 5:
 330       return C_(&quot;abbreviated month name&quot;, &quot;May&quot;);
 331     case 6:
 332       return C_(&quot;abbreviated month name&quot;, &quot;Jun&quot;);
 333     case 7:
 334       return C_(&quot;abbreviated month name&quot;, &quot;Jul&quot;);
 335     case 8:
 336       return C_(&quot;abbreviated month name&quot;, &quot;Aug&quot;);
 337     case 9:
 338       return C_(&quot;abbreviated month name&quot;, &quot;Sep&quot;);
 339     case 10:
 340       return C_(&quot;abbreviated month name&quot;, &quot;Oct&quot;);
 341     case 11:
 342       return C_(&quot;abbreviated month name&quot;, &quot;Nov&quot;);
 343     case 12:
 344       return C_(&quot;abbreviated month name&quot;, &quot;Dec&quot;);
 345 
 346     default:
 347       g_warning (&quot;Invalid month number %d&quot;, month);
 348     }
 349 
 350   return NULL;
 351 }
 352 
 353 static const gchar *
 354 get_weekday_name (gint day)
 355 {
 356   switch (day)
 357     {
 358     case 1:
 359       return C_(&quot;full weekday name&quot;, &quot;Monday&quot;);
 360     case 2:
 361       return C_(&quot;full weekday name&quot;, &quot;Tuesday&quot;);
 362     case 3:
 363       return C_(&quot;full weekday name&quot;, &quot;Wednesday&quot;);
 364     case 4:
 365       return C_(&quot;full weekday name&quot;, &quot;Thursday&quot;);
 366     case 5:
 367       return C_(&quot;full weekday name&quot;, &quot;Friday&quot;);
 368     case 6:
 369       return C_(&quot;full weekday name&quot;, &quot;Saturday&quot;);
 370     case 7:
 371       return C_(&quot;full weekday name&quot;, &quot;Sunday&quot;);
 372 
 373     default:
 374       g_warning (&quot;Invalid week day number %d&quot;, day);
 375     }
 376 
 377   return NULL;
 378 }
 379 
 380 static const gchar *
 381 get_weekday_name_abbr (gint day)
 382 {
 383   switch (day)
 384     {
 385     case 1:
 386       return C_(&quot;abbreviated weekday name&quot;, &quot;Mon&quot;);
 387     case 2:
 388       return C_(&quot;abbreviated weekday name&quot;, &quot;Tue&quot;);
 389     case 3:
 390       return C_(&quot;abbreviated weekday name&quot;, &quot;Wed&quot;);
 391     case 4:
 392       return C_(&quot;abbreviated weekday name&quot;, &quot;Thu&quot;);
 393     case 5:
 394       return C_(&quot;abbreviated weekday name&quot;, &quot;Fri&quot;);
 395     case 6:
 396       return C_(&quot;abbreviated weekday name&quot;, &quot;Sat&quot;);
 397     case 7:
 398       return C_(&quot;abbreviated weekday name&quot;, &quot;Sun&quot;);
 399 
 400     default:
 401       g_warning (&quot;Invalid week day number %d&quot;, day);
 402     }
 403 
 404   return NULL;
 405 }
 406 
 407 #endif  /* HAVE_LANGINFO_TIME */
 408 
 409 #ifdef HAVE_LANGINFO_ALTMON
 410 
 411 /* If nl_langinfo () supports ALTMON_n then MON_n returns full date format
 412  * forms and ALTMON_n returns standalone forms.
 413  */
 414 
 415 #define MONTH_FULL_WITH_DAY(d) MONTH_FULL(d)
 416 #define MONTH_FULL_WITH_DAY_IS_LOCALE MONTH_FULL_IS_LOCALE
 417 
 418 static const gint alt_month_item[12] =
 419 {
 420   ALTMON_1, ALTMON_2, ALTMON_3, ALTMON_4, ALTMON_5, ALTMON_6,
 421   ALTMON_7, ALTMON_8, ALTMON_9, ALTMON_10, ALTMON_11, ALTMON_12
 422 };
 423 
 424 #define MONTH_FULL_STANDALONE(d) nl_langinfo (alt_month_item[g_date_time_get_month (d) - 1])
 425 #define MONTH_FULL_STANDALONE_IS_LOCALE TRUE
 426 
 427 #else
 428 
 429 /* If nl_langinfo () does not support ALTMON_n then either MON_n returns
 430  * standalone forms or nl_langinfo (MON_n) does not work so we have defined
 431  * it as standalone form.
 432  */
 433 
 434 #define MONTH_FULL_STANDALONE(d) MONTH_FULL(d)
 435 #define MONTH_FULL_STANDALONE_IS_LOCALE MONTH_FULL_IS_LOCALE
 436 #define MONTH_FULL_WITH_DAY(d) (get_month_name_with_day (g_date_time_get_month (d)))
 437 #define MONTH_FULL_WITH_DAY_IS_LOCALE FALSE
 438 
 439 static const gchar *
 440 get_month_name_with_day (gint month)
 441 {
 442   switch (month)
 443     {
 444     case 1:
 445       /* Translators: Some languages need different grammatical forms of
 446        * month names depending on whether they are standalone or in a full
 447        * date context, with the day number.  Some may prefer starting with
 448        * uppercase when they are standalone and with lowercase when they are
 449        * in a full date context.  Here are full month names in a form
 450        * appropriate when they are used in a full date context, with the
 451        * day number.  If your system is Linux with the glibc version 2.27
 452        * (released Feb 1, 2018) or newer or if it is from the BSD family
 453        * (which includes OS X) then you can refer to the date command line
 454        * utility and see what the command `date +%B&#39; produces.  Also in
 455        * the latest Linux the command `locale mon&#39; in your native locale
 456        * produces a complete list of month names almost ready to copy and
 457        * paste here.  In older Linux systems due to a bug the result is
 458        * incorrect in some languages.  Note that in most of the languages
 459        * (western European, non-European) there is no difference between the
 460        * standalone and complete date form.
 461        */
 462       return C_(&quot;full month name with day&quot;, &quot;January&quot;);
 463     case 2:
 464       return C_(&quot;full month name with day&quot;, &quot;February&quot;);
 465     case 3:
 466       return C_(&quot;full month name with day&quot;, &quot;March&quot;);
 467     case 4:
 468       return C_(&quot;full month name with day&quot;, &quot;April&quot;);
 469     case 5:
 470       return C_(&quot;full month name with day&quot;, &quot;May&quot;);
 471     case 6:
 472       return C_(&quot;full month name with day&quot;, &quot;June&quot;);
 473     case 7:
 474       return C_(&quot;full month name with day&quot;, &quot;July&quot;);
 475     case 8:
 476       return C_(&quot;full month name with day&quot;, &quot;August&quot;);
 477     case 9:
 478       return C_(&quot;full month name with day&quot;, &quot;September&quot;);
 479     case 10:
 480       return C_(&quot;full month name with day&quot;, &quot;October&quot;);
 481     case 11:
 482       return C_(&quot;full month name with day&quot;, &quot;November&quot;);
 483     case 12:
 484       return C_(&quot;full month name with day&quot;, &quot;December&quot;);
 485 
 486     default:
 487       g_warning (&quot;Invalid month number %d&quot;, month);
 488     }
 489 
 490   return NULL;
 491 }
 492 
 493 #endif  /* HAVE_LANGINFO_ALTMON */
 494 
 495 #ifdef HAVE_LANGINFO_ABALTMON
 496 
 497 /* If nl_langinfo () supports _NL_ABALTMON_n then ABMON_n returns full
 498  * date format forms and _NL_ABALTMON_n returns standalone forms.
 499  */
 500 
 501 #define MONTH_ABBR_WITH_DAY(d) MONTH_ABBR(d)
 502 #define MONTH_ABBR_WITH_DAY_IS_LOCALE MONTH_ABBR_IS_LOCALE
 503 
 504 static const gint ab_alt_month_item[12] =
 505 {
 506   _NL_ABALTMON_1, _NL_ABALTMON_2, _NL_ABALTMON_3, _NL_ABALTMON_4,
 507   _NL_ABALTMON_5, _NL_ABALTMON_6, _NL_ABALTMON_7, _NL_ABALTMON_8,
 508   _NL_ABALTMON_9, _NL_ABALTMON_10, _NL_ABALTMON_11, _NL_ABALTMON_12
 509 };
 510 
 511 #define MONTH_ABBR_STANDALONE(d) nl_langinfo (ab_alt_month_item[g_date_time_get_month (d) - 1])
 512 #define MONTH_ABBR_STANDALONE_IS_LOCALE TRUE
 513 
 514 #else
 515 
 516 /* If nl_langinfo () does not support _NL_ABALTMON_n then either ABMON_n
 517  * returns standalone forms or nl_langinfo (ABMON_n) does not work so we
 518  * have defined it as standalone form. Now it&#39;s time to swap.
 519  */
 520 
 521 #define MONTH_ABBR_STANDALONE(d) MONTH_ABBR(d)
 522 #define MONTH_ABBR_STANDALONE_IS_LOCALE MONTH_ABBR_IS_LOCALE
 523 #define MONTH_ABBR_WITH_DAY(d) (get_month_name_abbr_with_day (g_date_time_get_month (d)))
 524 #define MONTH_ABBR_WITH_DAY_IS_LOCALE FALSE
 525 
 526 static const gchar *
 527 get_month_name_abbr_with_day (gint month)
 528 {
 529   switch (month)
 530     {
 531     case 1:
 532       /* Translators: Some languages need different grammatical forms of
 533        * month names depending on whether they are standalone or in a full
 534        * date context, with the day number.  Some may prefer starting with
 535        * uppercase when they are standalone and with lowercase when they are
 536        * in a full date context.  Here are abbreviated month names in a form
 537        * appropriate when they are used in a full date context, with the
 538        * day number.  However, as these names are abbreviated the grammatical
 539        * difference is visible probably only in Belarusian and Russian.
 540        * In other languages there is no difference between the standalone
 541        * and complete date form when they are abbreviated.  If your system
 542        * is Linux with the glibc version 2.27 (released Feb 1, 2018) or newer
 543        * then you can refer to the date command line utility and see what the
 544        * command `date +%b&#39; produces.  Also in the latest Linux the command
 545        * `locale abmon&#39; in your native locale produces a complete list of
 546        * month names almost ready to copy and paste here.  In other systems
 547        * due to a bug the result is incorrect in some languages.
 548        */
 549       return C_(&quot;abbreviated month name with day&quot;, &quot;Jan&quot;);
 550     case 2:
 551       return C_(&quot;abbreviated month name with day&quot;, &quot;Feb&quot;);
 552     case 3:
 553       return C_(&quot;abbreviated month name with day&quot;, &quot;Mar&quot;);
 554     case 4:
 555       return C_(&quot;abbreviated month name with day&quot;, &quot;Apr&quot;);
 556     case 5:
 557       return C_(&quot;abbreviated month name with day&quot;, &quot;May&quot;);
 558     case 6:
 559       return C_(&quot;abbreviated month name with day&quot;, &quot;Jun&quot;);
 560     case 7:
 561       return C_(&quot;abbreviated month name with day&quot;, &quot;Jul&quot;);
 562     case 8:
 563       return C_(&quot;abbreviated month name with day&quot;, &quot;Aug&quot;);
 564     case 9:
 565       return C_(&quot;abbreviated month name with day&quot;, &quot;Sep&quot;);
 566     case 10:
 567       return C_(&quot;abbreviated month name with day&quot;, &quot;Oct&quot;);
 568     case 11:
 569       return C_(&quot;abbreviated month name with day&quot;, &quot;Nov&quot;);
 570     case 12:
 571       return C_(&quot;abbreviated month name with day&quot;, &quot;Dec&quot;);
 572 
 573     default:
 574       g_warning (&quot;Invalid month number %d&quot;, month);
 575     }
 576 
 577   return NULL;
 578 }
 579 
 580 #endif  /* HAVE_LANGINFO_ABALTMON */
 581 
 582 /* Format AM/PM indicator if the locale does not have a localized version. */
 583 static const gchar *
 584 get_fallback_ampm (gint hour)
 585 {
 586   if (hour &lt; 12)
 587     /* Translators: &#39;before midday&#39; indicator */
 588     return C_(&quot;GDateTime&quot;, &quot;AM&quot;);
 589   else
 590     /* Translators: &#39;after midday&#39; indicator */
 591     return C_(&quot;GDateTime&quot;, &quot;PM&quot;);
 592 }
 593 
 594 static inline gint
 595 ymd_to_days (gint year,
 596              gint month,
 597              gint day)
 598 {
 599   gint64 days;
 600 
 601   days = (year - 1) * 365 + ((year - 1) / 4) - ((year - 1) / 100)
 602       + ((year - 1) / 400);
 603 
 604   days += days_in_year[0][month - 1];
 605   if (GREGORIAN_LEAP (year) &amp;&amp; month &gt; 2)
 606     day++;
 607 
 608   days += day;
 609 
 610   return days;
 611 }
 612 
 613 static void
 614 g_date_time_get_week_number (GDateTime *datetime,
 615                              gint      *week_number,
 616                              gint      *day_of_week,
 617                              gint      *day_of_year)
 618 {
 619   gint a, b, c, d, e, f, g, n, s, month, day, year;
 620 
 621   g_date_time_get_ymd (datetime, &amp;year, &amp;month, &amp;day);
 622 
 623   if (month &lt;= 2)
 624     {
 625       a = g_date_time_get_year (datetime) - 1;
 626       b = (a / 4) - (a / 100) + (a / 400);
 627       c = ((a - 1) / 4) - ((a - 1) / 100) + ((a - 1) / 400);
 628       s = b - c;
 629       e = 0;
 630       f = day - 1 + (31 * (month - 1));
 631     }
 632   else
 633     {
 634       a = year;
 635       b = (a / 4) - (a / 100) + (a / 400);
 636       c = ((a - 1) / 4) - ((a - 1) / 100) + ((a - 1) / 400);
 637       s = b - c;
 638       e = s + 1;
 639       f = day + (((153 * (month - 3)) + 2) / 5) + 58 + s;
 640     }
 641 
 642   g = (a + b) % 7;
 643   d = (f + g - e) % 7;
 644   n = f + 3 - d;
 645 
 646   if (week_number)
 647     {
 648       if (n &lt; 0)
 649         *week_number = 53 - ((g - s) / 5);
 650       else if (n &gt; 364 + s)
 651         *week_number = 1;
 652       else
 653         *week_number = (n / 7) + 1;
 654     }
 655 
 656   if (day_of_week)
 657     *day_of_week = d + 1;
 658 
 659   if (day_of_year)
 660     *day_of_year = f + 1;
 661 }
 662 
 663 /* Lifecycle {{{1 */
 664 
 665 static GDateTime *
 666 g_date_time_alloc (GTimeZone *tz)
 667 {
 668   GDateTime *datetime;
 669 
 670   datetime = g_slice_new0 (GDateTime);
 671   datetime-&gt;tz = g_time_zone_ref (tz);
 672   datetime-&gt;ref_count = 1;
 673 
 674   return datetime;
 675 }
 676 
 677 /**
 678  * g_date_time_ref:
 679  * @datetime: a #GDateTime
 680  *
 681  * Atomically increments the reference count of @datetime by one.
 682  *
 683  * Returns: the #GDateTime with the reference count increased
 684  *
 685  * Since: 2.26
 686  */
 687 GDateTime *
 688 g_date_time_ref (GDateTime *datetime)
 689 {
 690   g_return_val_if_fail (datetime != NULL, NULL);
 691   g_return_val_if_fail (datetime-&gt;ref_count &gt; 0, NULL);
 692 
 693   g_atomic_int_inc (&amp;datetime-&gt;ref_count);
 694 
 695   return datetime;
 696 }
 697 
 698 /**
 699  * g_date_time_unref:
 700  * @datetime: a #GDateTime
 701  *
 702  * Atomically decrements the reference count of @datetime by one.
 703  *
 704  * When the reference count reaches zero, the resources allocated by
 705  * @datetime are freed
 706  *
 707  * Since: 2.26
 708  */
 709 void
 710 g_date_time_unref (GDateTime *datetime)
 711 {
 712   g_return_if_fail (datetime != NULL);
 713   g_return_if_fail (datetime-&gt;ref_count &gt; 0);
 714 
 715   if (g_atomic_int_dec_and_test (&amp;datetime-&gt;ref_count))
 716     {
 717       g_time_zone_unref (datetime-&gt;tz);
 718       g_slice_free (GDateTime, datetime);
 719     }
 720 }
 721 
 722 /* Internal state transformers {{{1 */
 723 /*&lt; internal &gt;
 724  * g_date_time_to_instant:
 725  * @datetime: a #GDateTime
 726  *
 727  * Convert a @datetime into an instant.
 728  *
 729  * An instant is a number that uniquely describes a particular
 730  * microsecond in time, taking time zone considerations into account.
 731  * (ie: &quot;03:00 -0400&quot; is the same instant as &quot;02:00 -0500&quot;).
 732  *
 733  * An instant is always positive but we use a signed return value to
 734  * avoid troubles with C.
 735  */
 736 static gint64
 737 g_date_time_to_instant (GDateTime *datetime)
 738 {
 739   gint64 offset;
 740 
 741   offset = g_time_zone_get_offset (datetime-&gt;tz, datetime-&gt;interval);
 742   offset *= USEC_PER_SECOND;
 743 
 744   return datetime-&gt;days * USEC_PER_DAY + datetime-&gt;usec - offset;
 745 }
 746 
 747 /*&lt; internal &gt;
 748  * g_date_time_from_instant:
 749  * @tz: a #GTimeZone
 750  * @instant: an instant in time
 751  *
 752  * Creates a #GDateTime from a time zone and an instant.
 753  *
 754  * This might fail if the time ends up being out of range.
 755  */
 756 static GDateTime *
 757 g_date_time_from_instant (GTimeZone *tz,
 758                           gint64     instant)
 759 {
 760   GDateTime *datetime;
 761   gint64 offset;
 762 
 763   if (instant &lt; 0 || instant &gt; G_GINT64_CONSTANT (1000000000000000000))
 764     return NULL;
 765 
 766   datetime = g_date_time_alloc (tz);
 767   datetime-&gt;interval = g_time_zone_find_interval (tz,
 768                                                   G_TIME_TYPE_UNIVERSAL,
 769                                                   INSTANT_TO_UNIX (instant));
 770   offset = g_time_zone_get_offset (datetime-&gt;tz, datetime-&gt;interval);
 771   offset *= USEC_PER_SECOND;
 772 
 773   instant += offset;
 774 
 775   datetime-&gt;days = instant / USEC_PER_DAY;
 776   datetime-&gt;usec = instant % USEC_PER_DAY;
 777 
 778   if (datetime-&gt;days &lt; 1 || 3652059 &lt; datetime-&gt;days)
 779     {
 780       g_date_time_unref (datetime);
 781       datetime = NULL;
 782     }
 783 
 784   return datetime;
 785 }
 786 
 787 
 788 /*&lt; internal &gt;
 789  * g_date_time_deal_with_date_change:
 790  * @datetime: a #GDateTime
 791  *
 792  * This function should be called whenever the date changes by adding
 793  * days, months or years.  It does three things.
 794  *
 795  * First, we ensure that the date falls between 0001-01-01 and
 796  * 9999-12-31 and return %FALSE if it does not.
 797  *
 798  * Next we update the -&gt;interval field.
 799  *
 800  * Finally, we ensure that the resulting date and time pair exists (by
 801  * ensuring that our time zone has an interval containing it) and
 802  * adjusting as required.  For example, if we have the time 02:30:00 on
 803  * March 13 2010 in Toronto and we add 1 day to it, we would end up with
 804  * 2:30am on March 14th, which doesn&#39;t exist.  In that case, we bump the
 805  * time up to 3:00am.
 806  */
 807 static gboolean
 808 g_date_time_deal_with_date_change (GDateTime *datetime)
 809 {
 810   GTimeType was_dst;
 811   gint64 full_time;
 812   gint64 usec;
 813 
 814   if (datetime-&gt;days &lt; 1 || datetime-&gt;days &gt; 3652059)
 815     return FALSE;
 816 
 817   was_dst = g_time_zone_is_dst (datetime-&gt;tz, datetime-&gt;interval);
 818 
 819   full_time = datetime-&gt;days * USEC_PER_DAY + datetime-&gt;usec;
 820 
 821 
 822   usec = full_time % USEC_PER_SECOND;
 823   full_time /= USEC_PER_SECOND;
 824   full_time -= UNIX_EPOCH_START * SEC_PER_DAY;
 825 
 826   datetime-&gt;interval = g_time_zone_adjust_time (datetime-&gt;tz,
 827                                                 was_dst,
 828                                                 &amp;full_time);
 829   full_time += UNIX_EPOCH_START * SEC_PER_DAY;
 830   full_time *= USEC_PER_SECOND;
 831   full_time += usec;
 832 
 833   datetime-&gt;days = full_time / USEC_PER_DAY;
 834   datetime-&gt;usec = full_time % USEC_PER_DAY;
 835 
 836   /* maybe daylight time caused us to shift to a different day,
 837    * but it definitely didn&#39;t push us into a different year */
 838   return TRUE;
 839 }
 840 
 841 static GDateTime *
 842 g_date_time_replace_days (GDateTime *datetime,
 843                           gint       days)
 844 {
 845   GDateTime *new;
 846 
 847   new = g_date_time_alloc (datetime-&gt;tz);
 848   new-&gt;interval = datetime-&gt;interval;
 849   new-&gt;usec = datetime-&gt;usec;
 850   new-&gt;days = days;
 851 
 852   if (!g_date_time_deal_with_date_change (new))
 853     {
 854       g_date_time_unref (new);
 855       new = NULL;
 856     }
 857 
 858   return new;
 859 }
 860 
 861 /* now/unix/timeval Constructors {{{1 */
 862 
 863 G_GNUC_BEGIN_IGNORE_DEPRECATIONS
 864 /*&lt; internal &gt;
 865  * g_date_time_new_from_timeval:
 866  * @tz: a #GTimeZone
 867  * @tv: a #GTimeVal
 868  *
 869  * Creates a #GDateTime corresponding to the given #GTimeVal @tv in the
 870  * given time zone @tz.
 871  *
 872  * The time contained in a #GTimeVal is always stored in the form of
 873  * seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the
 874  * given time zone.
 875  *
 876  * This call can fail (returning %NULL) if @tv represents a time outside
 877  * of the supported range of #GDateTime.
 878  *
 879  * You should release the return value by calling g_date_time_unref()
 880  * when you are done with it.
 881  *
 882  * Returns: a new #GDateTime, or %NULL
 883  *
 884  * Since: 2.26
 885  **/
 886 static GDateTime *
 887 g_date_time_new_from_timeval (GTimeZone      *tz,
 888                               const GTimeVal *tv)
 889 {
 890   if ((gint64) tv-&gt;tv_sec &gt; G_MAXINT64 - 1 ||
 891       !UNIX_TO_INSTANT_IS_VALID ((gint64) tv-&gt;tv_sec + 1))
 892     return NULL;
 893 
 894   return g_date_time_from_instant (tz, tv-&gt;tv_usec +
 895                                    UNIX_TO_INSTANT (tv-&gt;tv_sec));
 896 }
 897 G_GNUC_END_IGNORE_DEPRECATIONS
 898 
 899 /*&lt; internal &gt;
 900  * g_date_time_new_from_unix:
 901  * @tz: a #GTimeZone
 902  * @usecs: the Unix time, in microseconds since the epoch
 903  *
 904  * Creates a #GDateTime corresponding to the given Unix time @t_us in the
 905  * given time zone @tz.
 906  *
 907  * Unix time is the number of seconds that have elapsed since 1970-01-01
 908  * 00:00:00 UTC, regardless of the time zone given.
 909  *
 910  * This call can fail (returning %NULL) if @t represents a time outside
 911  * of the supported range of #GDateTime.
 912  *
 913  * You should release the return value by calling g_date_time_unref()
 914  * when you are done with it.
 915  *
 916  * Returns: a new #GDateTime, or %NULL
 917  *
 918  * Since: 2.26
 919  **/
 920 static GDateTime *
 921 g_date_time_new_from_unix (GTimeZone *tz,
 922                            gint64     usecs)
 923 {
 924   if (!UNIX_USECS_TO_INSTANT_IS_VALID (usecs))
 925     return NULL;
 926 
 927   return g_date_time_from_instant (tz, UNIX_USECS_TO_INSTANT (usecs));
 928 }
 929 
 930 /**
 931  * g_date_time_new_now:
 932  * @tz: a #GTimeZone
 933  *
 934  * Creates a #GDateTime corresponding to this exact instant in the given
 935  * time zone @tz.  The time is as accurate as the system allows, to a
 936  * maximum accuracy of 1 microsecond.
 937  *
 938  * This function will always succeed unless the system clock is set to
 939  * truly insane values (or unless GLib is still being used after the
 940  * year 9999).
 941  *
 942  * You should release the return value by calling g_date_time_unref()
 943  * when you are done with it.
 944  *
 945  * Returns: a new #GDateTime, or %NULL
 946  *
 947  * Since: 2.26
 948  **/
 949 GDateTime *
 950 g_date_time_new_now (GTimeZone *tz)
 951 {
 952   gint64 now_us;
 953 
 954   now_us = g_get_real_time ();
 955 
 956   return g_date_time_new_from_unix (tz, now_us);
 957 }
 958 
 959 /**
 960  * g_date_time_new_now_local:
 961  *
 962  * Creates a #GDateTime corresponding to this exact instant in the local
 963  * time zone.
 964  *
 965  * This is equivalent to calling g_date_time_new_now() with the time
 966  * zone returned by g_time_zone_new_local().
 967  *
 968  * Returns: a new #GDateTime, or %NULL
 969  *
 970  * Since: 2.26
 971  **/
 972 GDateTime *
 973 g_date_time_new_now_local (void)
 974 {
 975   GDateTime *datetime;
 976   GTimeZone *local;
 977 
 978   local = g_time_zone_new_local ();
 979   datetime = g_date_time_new_now (local);
 980   g_time_zone_unref (local);
 981 
 982   return datetime;
 983 }
 984 
 985 /**
 986  * g_date_time_new_now_utc:
 987  *
 988  * Creates a #GDateTime corresponding to this exact instant in UTC.
 989  *
 990  * This is equivalent to calling g_date_time_new_now() with the time
 991  * zone returned by g_time_zone_new_utc().
 992  *
 993  * Returns: a new #GDateTime, or %NULL
 994  *
 995  * Since: 2.26
 996  **/
 997 GDateTime *
 998 g_date_time_new_now_utc (void)
 999 {
1000   GDateTime *datetime;
1001   GTimeZone *utc;
1002 
1003   utc = g_time_zone_new_utc ();
1004   datetime = g_date_time_new_now (utc);
1005   g_time_zone_unref (utc);
1006 
1007   return datetime;
1008 }
1009 
1010 /**
1011  * g_date_time_new_from_unix_local:
1012  * @t: the Unix time
1013  *
1014  * Creates a #GDateTime corresponding to the given Unix time @t in the
1015  * local time zone.
1016  *
1017  * Unix time is the number of seconds that have elapsed since 1970-01-01
1018  * 00:00:00 UTC, regardless of the local time offset.
1019  *
1020  * This call can fail (returning %NULL) if @t represents a time outside
1021  * of the supported range of #GDateTime.
1022  *
1023  * You should release the return value by calling g_date_time_unref()
1024  * when you are done with it.
1025  *
1026  * Returns: a new #GDateTime, or %NULL
1027  *
1028  * Since: 2.26
1029  **/
1030 GDateTime *
1031 g_date_time_new_from_unix_local (gint64 t)
1032 {
1033   GDateTime *datetime;
1034   GTimeZone *local;
1035 
1036   if (t &gt; G_MAXINT64 / USEC_PER_SECOND)
1037     return NULL;
1038 
1039   local = g_time_zone_new_local ();
1040   datetime = g_date_time_new_from_unix (local, t * USEC_PER_SECOND);
1041   g_time_zone_unref (local);
1042 
1043   return datetime;
1044 }
1045 
1046 /**
1047  * g_date_time_new_from_unix_utc:
1048  * @t: the Unix time
1049  *
1050  * Creates a #GDateTime corresponding to the given Unix time @t in UTC.
1051  *
1052  * Unix time is the number of seconds that have elapsed since 1970-01-01
1053  * 00:00:00 UTC.
1054  *
1055  * This call can fail (returning %NULL) if @t represents a time outside
1056  * of the supported range of #GDateTime.
1057  *
1058  * You should release the return value by calling g_date_time_unref()
1059  * when you are done with it.
1060  *
1061  * Returns: a new #GDateTime, or %NULL
1062  *
1063  * Since: 2.26
1064  **/
1065 GDateTime *
1066 g_date_time_new_from_unix_utc (gint64 t)
1067 {
1068   GDateTime *datetime;
1069   GTimeZone *utc;
1070 
1071   if (t &gt; G_MAXINT64 / USEC_PER_SECOND)
1072     return NULL;
1073 
1074   utc = g_time_zone_new_utc ();
1075   datetime = g_date_time_new_from_unix (utc, t * USEC_PER_SECOND);
1076   g_time_zone_unref (utc);
1077 
1078   return datetime;
1079 }
1080 
1081 /**
1082  * g_date_time_new_from_timeval_local:
1083  * @tv: a #GTimeVal
1084  *
1085  * Creates a #GDateTime corresponding to the given #GTimeVal @tv in the
1086  * local time zone.
1087  *
1088  * The time contained in a #GTimeVal is always stored in the form of
1089  * seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the
1090  * local time offset.
1091  *
1092  * This call can fail (returning %NULL) if @tv represents a time outside
1093  * of the supported range of #GDateTime.
1094  *
1095  * You should release the return value by calling g_date_time_unref()
1096  * when you are done with it.
1097  *
1098  * Returns: a new #GDateTime, or %NULL
1099  *
1100  * Since: 2.26
1101  * Deprecated: 2.62: #GTimeVal is not year-2038-safe. Use
1102  *    g_date_time_new_from_unix_local() instead.
1103  **/
1104 G_GNUC_BEGIN_IGNORE_DEPRECATIONS
1105 GDateTime *
1106 g_date_time_new_from_timeval_local (const GTimeVal *tv)
1107 {
1108   GDateTime *datetime;
1109   GTimeZone *local;
1110 
1111   local = g_time_zone_new_local ();
1112   datetime = g_date_time_new_from_timeval (local, tv);
1113   g_time_zone_unref (local);
1114 
1115   return datetime;
1116 }
1117 G_GNUC_END_IGNORE_DEPRECATIONS
1118 
1119 /**
1120  * g_date_time_new_from_timeval_utc:
1121  * @tv: a #GTimeVal
1122  *
1123  * Creates a #GDateTime corresponding to the given #GTimeVal @tv in UTC.
1124  *
1125  * The time contained in a #GTimeVal is always stored in the form of
1126  * seconds elapsed since 1970-01-01 00:00:00 UTC.
1127  *
1128  * This call can fail (returning %NULL) if @tv represents a time outside
1129  * of the supported range of #GDateTime.
1130  *
1131  * You should release the return value by calling g_date_time_unref()
1132  * when you are done with it.
1133  *
1134  * Returns: a new #GDateTime, or %NULL
1135  *
1136  * Since: 2.26
1137  * Deprecated: 2.62: #GTimeVal is not year-2038-safe. Use
1138  *    g_date_time_new_from_unix_utc() instead.
1139  **/
1140 G_GNUC_BEGIN_IGNORE_DEPRECATIONS
1141 GDateTime *
1142 g_date_time_new_from_timeval_utc (const GTimeVal *tv)
1143 {
1144   GDateTime *datetime;
1145   GTimeZone *utc;
1146 
1147   utc = g_time_zone_new_utc ();
1148   datetime = g_date_time_new_from_timeval (utc, tv);
1149   g_time_zone_unref (utc);
1150 
1151   return datetime;
1152 }
1153 G_GNUC_END_IGNORE_DEPRECATIONS
1154 
1155 /* Parse integers in the form d (week days), dd (hours etc), ddd (ordinal days) or dddd (years) */
1156 static gboolean
1157 get_iso8601_int (const gchar *text, gsize length, gint *value)
1158 {
1159   gsize i;
1160   guint v = 0;
1161 
1162   if (length &lt; 1 || length &gt; 4)
1163     return FALSE;
1164 
1165   for (i = 0; i &lt; length; i++)
1166     {
1167       const gchar c = text[i];
1168       if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;)
1169         return FALSE;
1170       v = v * 10 + (c - &#39;0&#39;);
1171     }
1172 
1173   *value = v;
1174   return TRUE;
1175 }
1176 
1177 /* Parse seconds in the form ss or ss.sss (variable length decimal) */
1178 static gboolean
1179 get_iso8601_seconds (const gchar *text, gsize length, gdouble *value)
1180 {
1181   gsize i;
1182   gdouble divisor = 1, v = 0;
1183 
1184   if (length &lt; 2)
1185     return FALSE;
1186 
1187   for (i = 0; i &lt; 2; i++)
1188     {
1189       const gchar c = text[i];
1190       if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;)
1191         return FALSE;
1192       v = v * 10 + (c - &#39;0&#39;);
1193     }
1194 
1195   if (length &gt; 2 &amp;&amp; !(text[i] == &#39;.&#39; || text[i] == &#39;,&#39;))
1196     return FALSE;
1197   i++;
1198   if (i == length)
1199     return FALSE;
1200 
1201   for (; i &lt; length; i++)
1202     {
1203       const gchar c = text[i];
1204       if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;)
1205         return FALSE;
1206       v = v * 10 + (c - &#39;0&#39;);
1207       divisor *= 10;
1208     }
1209 
1210   *value = v / divisor;
1211   return TRUE;
1212 }
1213 
1214 static GDateTime *
1215 g_date_time_new_ordinal (GTimeZone *tz, gint year, gint ordinal_day, gint hour, gint minute, gdouble seconds)
1216 {
1217   GDateTime *dt;
1218 
1219   if (ordinal_day &lt; 1 || ordinal_day &gt; (GREGORIAN_LEAP (year) ? 366 : 365))
1220     return NULL;
1221 
1222   dt = g_date_time_new (tz, year, 1, 1, hour, minute, seconds);
1223   if (dt == NULL)
1224     return NULL;
1225   dt-&gt;days += ordinal_day - 1;
1226 
1227   return dt;
1228 }
1229 
1230 static GDateTime *
1231 g_date_time_new_week (GTimeZone *tz, gint year, gint week, gint week_day, gint hour, gint minute, gdouble seconds)
1232 {
1233   gint64 p;
1234   gint max_week, jan4_week_day, ordinal_day;
1235   GDateTime *dt;
1236 
1237   p = (year * 365 + (year / 4) - (year / 100) + (year / 400)) % 7;
1238   max_week = p == 4 ? 53 : 52;
1239 
1240   if (week &lt; 1 || week &gt; max_week || week_day &lt; 1 || week_day &gt; 7)
1241     return NULL;
1242 
1243   dt = g_date_time_new (tz, year, 1, 4, 0, 0, 0);
1244   if (dt == NULL)
1245     return NULL;
1246   g_date_time_get_week_number (dt, NULL, &amp;jan4_week_day, NULL);
1247   g_date_time_unref (dt);
1248 
1249   ordinal_day = (week * 7) + week_day - (jan4_week_day + 3);
1250   if (ordinal_day &lt; 0)
1251     {
1252       year--;
1253       ordinal_day += GREGORIAN_LEAP (year) ? 366 : 365;
1254     }
1255   else if (ordinal_day &gt; (GREGORIAN_LEAP (year) ? 366 : 365))
1256     {
1257       ordinal_day -= (GREGORIAN_LEAP (year) ? 366 : 365);
1258       year++;
1259     }
1260 
1261   return g_date_time_new_ordinal (tz, year, ordinal_day, hour, minute, seconds);
1262 }
1263 
1264 static GDateTime *
1265 parse_iso8601_date (const gchar *text, gsize length,
1266                     gint hour, gint minute, gdouble seconds, GTimeZone *tz)
1267 {
1268   /* YYYY-MM-DD */
1269   if (length == 10 &amp;&amp; text[4] == &#39;-&#39; &amp;&amp; text[7] == &#39;-&#39;)
1270     {
1271       int year, month, day;
1272       if (!get_iso8601_int (text, 4, &amp;year) ||
1273           !get_iso8601_int (text + 5, 2, &amp;month) ||
1274           !get_iso8601_int (text + 8, 2, &amp;day))
1275         return NULL;
1276       return g_date_time_new (tz, year, month, day, hour, minute, seconds);
1277     }
1278   /* YYYY-DDD */
1279   else if (length == 8 &amp;&amp; text[4] == &#39;-&#39;)
1280     {
1281       gint year, ordinal_day;
1282       if (!get_iso8601_int (text, 4, &amp;year) ||
1283           !get_iso8601_int (text + 5, 3, &amp;ordinal_day))
1284         return NULL;
1285       return g_date_time_new_ordinal (tz, year, ordinal_day, hour, minute, seconds);
1286     }
1287   /* YYYY-Www-D */
1288   else if (length == 10 &amp;&amp; text[4] == &#39;-&#39; &amp;&amp; text[5] == &#39;W&#39; &amp;&amp; text[8] == &#39;-&#39;)
1289     {
1290       gint year, week, week_day;
1291       if (!get_iso8601_int (text, 4, &amp;year) ||
1292           !get_iso8601_int (text + 6, 2, &amp;week) ||
1293           !get_iso8601_int (text + 9, 1, &amp;week_day))
1294         return NULL;
1295       return g_date_time_new_week (tz, year, week, week_day, hour, minute, seconds);
1296     }
1297   /* YYYYWwwD */
1298   else if (length == 8 &amp;&amp; text[4] == &#39;W&#39;)
1299     {
1300       gint year, week, week_day;
1301       if (!get_iso8601_int (text, 4, &amp;year) ||
1302           !get_iso8601_int (text + 5, 2, &amp;week) ||
1303           !get_iso8601_int (text + 7, 1, &amp;week_day))
1304         return NULL;
1305       return g_date_time_new_week (tz, year, week, week_day, hour, minute, seconds);
1306     }
1307   /* YYYYMMDD */
1308   else if (length == 8)
1309     {
1310       int year, month, day;
1311       if (!get_iso8601_int (text, 4, &amp;year) ||
1312           !get_iso8601_int (text + 4, 2, &amp;month) ||
1313           !get_iso8601_int (text + 6, 2, &amp;day))
1314         return NULL;
1315       return g_date_time_new (tz, year, month, day, hour, minute, seconds);
1316     }
1317   /* YYYYDDD */
1318   else if (length == 7)
1319     {
1320       gint year, ordinal_day;
1321       if (!get_iso8601_int (text, 4, &amp;year) ||
1322           !get_iso8601_int (text + 4, 3, &amp;ordinal_day))
1323         return NULL;
1324       return g_date_time_new_ordinal (tz, year, ordinal_day, hour, minute, seconds);
1325     }
1326   else
1327     return FALSE;
1328 }
1329 
1330 static GTimeZone *
1331 parse_iso8601_timezone (const gchar *text, gsize length, gssize *tz_offset)
1332 {
1333   gint i, tz_length, offset_hours, offset_minutes;
1334   gint offset_sign = 1;
1335   GTimeZone *tz;
1336 
1337   /* UTC uses Z suffix  */
1338   if (length &gt; 0 &amp;&amp; text[length - 1] == &#39;Z&#39;)
1339     {
1340       *tz_offset = length - 1;
1341       return g_time_zone_new_utc ();
1342     }
1343 
1344   /* Look for &#39;+&#39; or &#39;-&#39; of offset */
1345   for (i = length - 1; i &gt;= 0; i--)
1346     if (text[i] == &#39;+&#39; || text[i] == &#39;-&#39;)
1347       {
1348         offset_sign = text[i] == &#39;-&#39; ? -1 : 1;
1349         break;
1350       }
1351   if (i &lt; 0)
1352     return NULL;
1353   tz_length = length - i;
1354 
1355   /* +hh:mm or -hh:mm */
1356   if (tz_length == 6 &amp;&amp; text[i+3] == &#39;:&#39;)
1357     {
1358       if (!get_iso8601_int (text + i + 1, 2, &amp;offset_hours) ||
1359           !get_iso8601_int (text + i + 4, 2, &amp;offset_minutes))
1360         return NULL;
1361     }
1362   /* +hhmm or -hhmm */
1363   else if (tz_length == 5)
1364     {
1365       if (!get_iso8601_int (text + i + 1, 2, &amp;offset_hours) ||
1366           !get_iso8601_int (text + i + 3, 2, &amp;offset_minutes))
1367         return NULL;
1368     }
1369   /* +hh or -hh */
1370   else if (tz_length == 3)
1371     {
1372       if (!get_iso8601_int (text + i + 1, 2, &amp;offset_hours))
1373         return NULL;
1374       offset_minutes = 0;
1375     }
1376   else
1377     return NULL;
1378 
1379   *tz_offset = i;
1380   tz = g_time_zone_new (text + i);
1381 
1382   /* Double-check that the GTimeZone matches our interpretation of the timezone.
1383    * This can fail because our interpretation is less strict than (for example)
1384    * parse_time() in gtimezone.c, which restricts the range of the parsed
1385    * integers. */
1386   if (g_time_zone_get_offset (tz, 0) != offset_sign * (offset_hours * 3600 + offset_minutes * 60))
1387     {
1388       g_time_zone_unref (tz);
1389       return NULL;
1390     }
1391 
1392   return tz;
1393 }
1394 
1395 static gboolean
1396 parse_iso8601_time (const gchar *text, gsize length,
1397                     gint *hour, gint *minute, gdouble *seconds, GTimeZone **tz)
1398 {
1399   gssize tz_offset = -1;
1400 
1401   /* Check for timezone suffix */
1402   *tz = parse_iso8601_timezone (text, length, &amp;tz_offset);
1403   if (tz_offset &gt;= 0)
1404     length = tz_offset;
1405 
1406   /* hh:mm:ss(.sss) */
1407   if (length &gt;= 8 &amp;&amp; text[2] == &#39;:&#39; &amp;&amp; text[5] == &#39;:&#39;)
1408     {
1409       return get_iso8601_int (text, 2, hour) &amp;&amp;
1410              get_iso8601_int (text + 3, 2, minute) &amp;&amp;
1411              get_iso8601_seconds (text + 6, length - 6, seconds);
1412     }
1413   /* hhmmss(.sss) */
1414   else if (length &gt;= 6)
1415     {
1416       return get_iso8601_int (text, 2, hour) &amp;&amp;
1417              get_iso8601_int (text + 2, 2, minute) &amp;&amp;
1418              get_iso8601_seconds (text + 4, length - 4, seconds);
1419     }
1420   else
1421     return FALSE;
1422 }
1423 
1424 /**
1425  * g_date_time_new_from_iso8601:
1426  * @text: an ISO 8601 formatted time string.
1427  * @default_tz: (nullable): a #GTimeZone to use if the text doesn&#39;t contain a
1428  *                          timezone, or %NULL.
1429  *
1430  * Creates a #GDateTime corresponding to the given
1431  * [ISO 8601 formatted string](https://en.wikipedia.org/wiki/ISO_8601)
1432  * @text. ISO 8601 strings of the form &lt;date&gt;&lt;sep&gt;&lt;time&gt;&lt;tz&gt; are supported.
1433  *
1434  * &lt;sep&gt; is the separator and can be either &#39;T&#39;, &#39;t&#39; or &#39; &#39;.
1435  *
1436  * &lt;date&gt; is in the form:
1437  *
1438  * - `YYYY-MM-DD` - Year/month/day, e.g. 2016-08-24.
1439  * - `YYYYMMDD` - Same as above without dividers.
1440  * - `YYYY-DDD` - Ordinal day where DDD is from 001 to 366, e.g. 2016-237.
1441  * - `YYYYDDD` - Same as above without dividers.
1442  * - `YYYY-Www-D` - Week day where ww is from 01 to 52 and D from 1-7,
1443  *   e.g. 2016-W34-3.
1444  * - `YYYYWwwD` - Same as above without dividers.
1445  *
1446  * &lt;time&gt; is in the form:
1447  *
1448  * - `hh:mm:ss(.sss)` - Hours, minutes, seconds (subseconds), e.g. 22:10:42.123.
1449  * - `hhmmss(.sss)` - Same as above without dividers.
1450  *
1451  * &lt;tz&gt; is an optional timezone suffix of the form:
1452  *
1453  * - `Z` - UTC.
1454  * - `+hh:mm` or `-hh:mm` - Offset from UTC in hours and minutes, e.g. +12:00.
1455  * - `+hh` or `-hh` - Offset from UTC in hours, e.g. +12.
1456  *
1457  * If the timezone is not provided in @text it must be provided in @default_tz
1458  * (this field is otherwise ignored).
1459  *
1460  * This call can fail (returning %NULL) if @text is not a valid ISO 8601
1461  * formatted string.
1462  *
1463  * You should release the return value by calling g_date_time_unref()
1464  * when you are done with it.
1465  *
1466  * Returns: (transfer full) (nullable): a new #GDateTime, or %NULL
1467  *
1468  * Since: 2.56
1469  */
1470 GDateTime *
1471 g_date_time_new_from_iso8601 (const gchar *text, GTimeZone *default_tz)
1472 {
1473   gint length, date_length = -1;
1474   gint hour = 0, minute = 0;
1475   gdouble seconds = 0.0;
1476   GTimeZone *tz = NULL;
1477   GDateTime *datetime = NULL;
1478 
1479   g_return_val_if_fail (text != NULL, NULL);
1480 
1481   /* Count length of string and find date / time separator (&#39;T&#39;, &#39;t&#39;, or &#39; &#39;) */
1482   for (length = 0; text[length] != &#39;\0&#39;; length++)
1483     {
1484       if (date_length &lt; 0 &amp;&amp; (text[length] == &#39;T&#39; || text[length] == &#39;t&#39; || text[length] == &#39; &#39;))
1485         date_length = length;
1486     }
1487 
1488   if (date_length &lt; 0)
1489     return NULL;
1490 
1491   if (!parse_iso8601_time (text + date_length + 1, length - (date_length + 1),
1492                            &amp;hour, &amp;minute, &amp;seconds, &amp;tz))
1493     goto out;
1494   if (tz == NULL &amp;&amp; default_tz == NULL)
1495     return NULL;
1496 
1497   datetime = parse_iso8601_date (text, date_length, hour, minute, seconds, tz ? tz : default_tz);
1498 
1499 out:
1500     if (tz != NULL)
1501       g_time_zone_unref (tz);
1502     return datetime;
1503 }
1504 
1505 /* full new functions {{{1 */
1506 
1507 /**
1508  * g_date_time_new:
1509  * @tz: a #GTimeZone
1510  * @year: the year component of the date
1511  * @month: the month component of the date
1512  * @day: the day component of the date
1513  * @hour: the hour component of the date
1514  * @minute: the minute component of the date
1515  * @seconds: the number of seconds past the minute
1516  *
1517  * Creates a new #GDateTime corresponding to the given date and time in
1518  * the time zone @tz.
1519  *
1520  * The @year must be between 1 and 9999, @month between 1 and 12 and @day
1521  * between 1 and 28, 29, 30 or 31 depending on the month and the year.
1522  *
1523  * @hour must be between 0 and 23 and @minute must be between 0 and 59.
1524  *
1525  * @seconds must be at least 0.0 and must be strictly less than 60.0.
1526  * It will be rounded down to the nearest microsecond.
1527  *
1528  * If the given time is not representable in the given time zone (for
1529  * example, 02:30 on March 14th 2010 in Toronto, due to daylight savings
1530  * time) then the time will be rounded up to the nearest existing time
1531  * (in this case, 03:00).  If this matters to you then you should verify
1532  * the return value for containing the same as the numbers you gave.
1533  *
1534  * In the case that the given time is ambiguous in the given time zone
1535  * (for example, 01:30 on November 7th 2010 in Toronto, due to daylight
1536  * savings time) then the time falling within standard (ie:
1537  * non-daylight) time is taken.
1538  *
1539  * It not considered a programmer error for the values to this function
1540  * to be out of range, but in the case that they are, the function will
1541  * return %NULL.
1542  *
1543  * You should release the return value by calling g_date_time_unref()
1544  * when you are done with it.
1545  *
1546  * Returns: a new #GDateTime, or %NULL
1547  *
1548  * Since: 2.26
1549  **/
1550 GDateTime *
1551 g_date_time_new (GTimeZone *tz,
1552                  gint       year,
1553                  gint       month,
1554                  gint       day,
1555                  gint       hour,
1556                  gint       minute,
1557                  gdouble    seconds)
1558 {
1559   GDateTime *datetime;
1560   gint64 full_time;
1561   /* keep these variables as volatile. We do not want them ending up in
1562    * registers - them doing so may cause us to hit precision problems on i386.
1563    * See: https://bugzilla.gnome.org/show_bug.cgi?id=792410 */
1564   volatile gint64 usec;
1565   volatile gdouble usecd;
1566 
1567   g_return_val_if_fail (tz != NULL, NULL);
1568 
1569   if (year &lt; 1 || year &gt; 9999 ||
1570       month &lt; 1 || month &gt; 12 ||
1571       day &lt; 1 || day &gt; days_in_months[GREGORIAN_LEAP (year)][month] ||
1572       hour &lt; 0 || hour &gt; 23 ||
1573       minute &lt; 0 || minute &gt; 59 ||
1574       seconds &lt; 0.0 || seconds &gt;= 60.0)
1575     return NULL;
1576 
1577   datetime = g_date_time_alloc (tz);
1578   datetime-&gt;days = ymd_to_days (year, month, day);
1579   datetime-&gt;usec = (hour   * USEC_PER_HOUR)
1580                  + (minute * USEC_PER_MINUTE)
1581                  + (gint64) (seconds * USEC_PER_SECOND);
1582 
1583   full_time = SEC_PER_DAY *
1584                 (ymd_to_days (year, month, day) - UNIX_EPOCH_START) +
1585               SECS_PER_HOUR * hour +
1586               SECS_PER_MINUTE * minute +
1587               (int) seconds;
1588 
1589   datetime-&gt;interval = g_time_zone_adjust_time (datetime-&gt;tz,
1590                                                 G_TIME_TYPE_STANDARD,
1591                                                 &amp;full_time);
1592 
1593   /* This is the correct way to convert a scaled FP value to integer.
1594    * If this surprises you, please observe that (int)(1.000001 * 1e6)
1595    * is 1000000.  This is not a problem with precision, it&#39;s just how
1596    * FP numbers work.
1597    * See https://bugzilla.gnome.org/show_bug.cgi?id=697715. */
1598   usec = seconds * USEC_PER_SECOND;
1599   usecd = (usec + 1) * 1e-6;
1600   if (usecd &lt;= seconds) {
1601     usec++;
1602   }
1603 
1604   full_time += UNIX_EPOCH_START * SEC_PER_DAY;
1605   datetime-&gt;days = full_time / SEC_PER_DAY;
1606   datetime-&gt;usec = (full_time % SEC_PER_DAY) * USEC_PER_SECOND;
1607   datetime-&gt;usec += usec % USEC_PER_SECOND;
1608 
1609   return datetime;
1610 }
1611 
1612 /**
1613  * g_date_time_new_local:
1614  * @year: the year component of the date
1615  * @month: the month component of the date
1616  * @day: the day component of the date
1617  * @hour: the hour component of the date
1618  * @minute: the minute component of the date
1619  * @seconds: the number of seconds past the minute
1620  *
1621  * Creates a new #GDateTime corresponding to the given date and time in
1622  * the local time zone.
1623  *
1624  * This call is equivalent to calling g_date_time_new() with the time
1625  * zone returned by g_time_zone_new_local().
1626  *
1627  * Returns: a #GDateTime, or %NULL
1628  *
1629  * Since: 2.26
1630  **/
1631 GDateTime *
1632 g_date_time_new_local (gint    year,
1633                        gint    month,
1634                        gint    day,
1635                        gint    hour,
1636                        gint    minute,
1637                        gdouble seconds)
1638 {
1639   GDateTime *datetime;
1640   GTimeZone *local;
1641 
1642   local = g_time_zone_new_local ();
1643   datetime = g_date_time_new (local, year, month, day, hour, minute, seconds);
1644   g_time_zone_unref (local);
1645 
1646   return datetime;
1647 }
1648 
1649 /**
1650  * g_date_time_new_utc:
1651  * @year: the year component of the date
1652  * @month: the month component of the date
1653  * @day: the day component of the date
1654  * @hour: the hour component of the date
1655  * @minute: the minute component of the date
1656  * @seconds: the number of seconds past the minute
1657  *
1658  * Creates a new #GDateTime corresponding to the given date and time in
1659  * UTC.
1660  *
1661  * This call is equivalent to calling g_date_time_new() with the time
1662  * zone returned by g_time_zone_new_utc().
1663  *
1664  * Returns: a #GDateTime, or %NULL
1665  *
1666  * Since: 2.26
1667  **/
1668 GDateTime *
1669 g_date_time_new_utc (gint    year,
1670                      gint    month,
1671                      gint    day,
1672                      gint    hour,
1673                      gint    minute,
1674                      gdouble seconds)
1675 {
1676   GDateTime *datetime;
1677   GTimeZone *utc;
1678 
1679   utc = g_time_zone_new_utc ();
1680   datetime = g_date_time_new (utc, year, month, day, hour, minute, seconds);
1681   g_time_zone_unref (utc);
1682 
1683   return datetime;
1684 }
1685 
1686 /* Adders {{{1 */
1687 
1688 /**
1689  * g_date_time_add:
1690  * @datetime: a #GDateTime
1691  * @timespan: a #GTimeSpan
1692  *
1693  * Creates a copy of @datetime and adds the specified timespan to the copy.
1694  *
1695  * Returns: the newly created #GDateTime which should be freed with
1696  *   g_date_time_unref().
1697  *
1698  * Since: 2.26
1699  */
1700 GDateTime*
1701 g_date_time_add (GDateTime *datetime,
1702                  GTimeSpan  timespan)
1703 {
1704   return g_date_time_from_instant (datetime-&gt;tz, timespan +
1705                                    g_date_time_to_instant (datetime));
1706 }
1707 
1708 /**
1709  * g_date_time_add_years:
1710  * @datetime: a #GDateTime
1711  * @years: the number of years
1712  *
1713  * Creates a copy of @datetime and adds the specified number of years to the
1714  * copy. Add negative values to subtract years.
1715  *
1716  * As with g_date_time_add_months(), if the resulting date would be 29th
1717  * February on a non-leap year, the day will be clamped to 28th February.
1718  *
1719  * Returns: the newly created #GDateTime which should be freed with
1720  *   g_date_time_unref().
1721  *
1722  * Since: 2.26
1723  */
1724 GDateTime *
1725 g_date_time_add_years (GDateTime *datetime,
1726                        gint       years)
1727 {
1728   gint year, month, day;
1729 
1730   g_return_val_if_fail (datetime != NULL, NULL);
1731 
1732   if (years &lt; -10000 || years &gt; 10000)
1733     return NULL;
1734 
1735   g_date_time_get_ymd (datetime, &amp;year, &amp;month, &amp;day);
1736   year += years;
1737 
1738   /* only possible issue is if we&#39;ve entered a year with no February 29
1739    */
1740   if (month == 2 &amp;&amp; day == 29 &amp;&amp; !GREGORIAN_LEAP (year))
1741     day = 28;
1742 
1743   return g_date_time_replace_days (datetime, ymd_to_days (year, month, day));
1744 }
1745 
1746 /**
1747  * g_date_time_add_months:
1748  * @datetime: a #GDateTime
1749  * @months: the number of months
1750  *
1751  * Creates a copy of @datetime and adds the specified number of months to the
1752  * copy. Add negative values to subtract months.
1753  *
1754  * The day of the month of the resulting #GDateTime is clamped to the number
1755  * of days in the updated calendar month. For example, if adding 1 month to
1756  * 31st January 2018, the result would be 28th February 2018. In 2020 (a leap
1757  * year), the result would be 29th February.
1758  *
1759  * Returns: the newly created #GDateTime which should be freed with
1760  *   g_date_time_unref().
1761  *
1762  * Since: 2.26
1763  */
1764 GDateTime*
1765 g_date_time_add_months (GDateTime *datetime,
1766                         gint       months)
1767 {
1768   gint year, month, day;
1769 
1770   g_return_val_if_fail (datetime != NULL, NULL);
1771   g_date_time_get_ymd (datetime, &amp;year, &amp;month, &amp;day);
1772 
1773   if (months &lt; -120000 || months &gt; 120000)
1774     return NULL;
1775 
1776   year += months / 12;
1777   month += months % 12;
1778   if (month &lt; 1)
1779     {
1780       month += 12;
1781       year--;
1782     }
1783   else if (month &gt; 12)
1784     {
1785       month -= 12;
1786       year++;
1787     }
1788 
1789   day = MIN (day, days_in_months[GREGORIAN_LEAP (year)][month]);
1790 
1791   return g_date_time_replace_days (datetime, ymd_to_days (year, month, day));
1792 }
1793 
1794 /**
1795  * g_date_time_add_weeks:
1796  * @datetime: a #GDateTime
1797  * @weeks: the number of weeks
1798  *
1799  * Creates a copy of @datetime and adds the specified number of weeks to the
1800  * copy. Add negative values to subtract weeks.
1801  *
1802  * Returns: the newly created #GDateTime which should be freed with
1803  *   g_date_time_unref().
1804  *
1805  * Since: 2.26
1806  */
1807 GDateTime*
1808 g_date_time_add_weeks (GDateTime *datetime,
1809                        gint             weeks)
1810 {
1811   g_return_val_if_fail (datetime != NULL, NULL);
1812 
1813   return g_date_time_add_days (datetime, weeks * 7);
1814 }
1815 
1816 /**
1817  * g_date_time_add_days:
1818  * @datetime: a #GDateTime
1819  * @days: the number of days
1820  *
1821  * Creates a copy of @datetime and adds the specified number of days to the
1822  * copy. Add negative values to subtract days.
1823  *
1824  * Returns: the newly created #GDateTime which should be freed with
1825  *   g_date_time_unref().
1826  *
1827  * Since: 2.26
1828  */
1829 GDateTime*
1830 g_date_time_add_days (GDateTime *datetime,
1831                       gint       days)
1832 {
1833   g_return_val_if_fail (datetime != NULL, NULL);
1834 
1835   if (days &lt; -3660000 || days &gt; 3660000)
1836     return NULL;
1837 
1838   return g_date_time_replace_days (datetime, datetime-&gt;days + days);
1839 }
1840 
1841 /**
1842  * g_date_time_add_hours:
1843  * @datetime: a #GDateTime
1844  * @hours: the number of hours to add
1845  *
1846  * Creates a copy of @datetime and adds the specified number of hours.
1847  * Add negative values to subtract hours.
1848  *
1849  * Returns: the newly created #GDateTime which should be freed with
1850  *   g_date_time_unref().
1851  *
1852  * Since: 2.26
1853  */
1854 GDateTime*
1855 g_date_time_add_hours (GDateTime *datetime,
1856                        gint       hours)
1857 {
1858   return g_date_time_add (datetime, hours * USEC_PER_HOUR);
1859 }
1860 
1861 /**
1862  * g_date_time_add_minutes:
1863  * @datetime: a #GDateTime
1864  * @minutes: the number of minutes to add
1865  *
1866  * Creates a copy of @datetime adding the specified number of minutes.
1867  * Add negative values to subtract minutes.
1868  *
1869  * Returns: the newly created #GDateTime which should be freed with
1870  *   g_date_time_unref().
1871  *
1872  * Since: 2.26
1873  */
1874 GDateTime*
1875 g_date_time_add_minutes (GDateTime *datetime,
1876                          gint             minutes)
1877 {
1878   return g_date_time_add (datetime, minutes * USEC_PER_MINUTE);
1879 }
1880 
1881 
1882 /**
1883  * g_date_time_add_seconds:
1884  * @datetime: a #GDateTime
1885  * @seconds: the number of seconds to add
1886  *
1887  * Creates a copy of @datetime and adds the specified number of seconds.
1888  * Add negative values to subtract seconds.
1889  *
1890  * Returns: the newly created #GDateTime which should be freed with
1891  *   g_date_time_unref().
1892  *
1893  * Since: 2.26
1894  */
1895 GDateTime*
1896 g_date_time_add_seconds (GDateTime *datetime,
1897                          gdouble    seconds)
1898 {
1899   return g_date_time_add (datetime, seconds * USEC_PER_SECOND);
1900 }
1901 
1902 /**
1903  * g_date_time_add_full:
1904  * @datetime: a #GDateTime
1905  * @years: the number of years to add
1906  * @months: the number of months to add
1907  * @days: the number of days to add
1908  * @hours: the number of hours to add
1909  * @minutes: the number of minutes to add
1910  * @seconds: the number of seconds to add
1911  *
1912  * Creates a new #GDateTime adding the specified values to the current date and
1913  * time in @datetime. Add negative values to subtract.
1914  *
1915  * Returns: the newly created #GDateTime that should be freed with
1916  *   g_date_time_unref().
1917  *
1918  * Since: 2.26
1919  */
1920 GDateTime *
1921 g_date_time_add_full (GDateTime *datetime,
1922                       gint       years,
1923                       gint       months,
1924                       gint       days,
1925                       gint       hours,
1926                       gint       minutes,
1927                       gdouble    seconds)
1928 {
1929   gint year, month, day;
1930   gint64 full_time;
1931   GDateTime *new;
1932   gint interval;
1933 
1934   g_return_val_if_fail (datetime != NULL, NULL);
1935   g_date_time_get_ymd (datetime, &amp;year, &amp;month, &amp;day);
1936 
1937   months += years * 12;
1938 
1939   if (months &lt; -120000 || months &gt; 120000)
1940     return NULL;
1941 
1942   if (days &lt; -3660000 || days &gt; 3660000)
1943     return NULL;
1944 
1945   year += months / 12;
1946   month += months % 12;
1947   if (month &lt; 1)
1948     {
1949       month += 12;
1950       year--;
1951     }
1952   else if (month &gt; 12)
1953     {
1954       month -= 12;
1955       year++;
1956     }
1957 
1958   day = MIN (day, days_in_months[GREGORIAN_LEAP (year)][month]);
1959 
1960   /* full_time is now in unix (local) time */
1961   full_time = datetime-&gt;usec / USEC_PER_SECOND + SEC_PER_DAY *
1962     (ymd_to_days (year, month, day) + days - UNIX_EPOCH_START);
1963 
1964   interval = g_time_zone_adjust_time (datetime-&gt;tz,
1965                                       g_time_zone_is_dst (datetime-&gt;tz,
1966                                                           datetime-&gt;interval),
1967                                       &amp;full_time);
1968 
1969   /* move to UTC unix time */
1970   full_time -= g_time_zone_get_offset (datetime-&gt;tz, interval);
1971 
1972   /* convert back to an instant, add back fractional seconds */
1973   full_time += UNIX_EPOCH_START * SEC_PER_DAY;
1974   full_time = full_time * USEC_PER_SECOND +
1975               datetime-&gt;usec % USEC_PER_SECOND;
1976 
1977   /* do the actual addition now */
1978   full_time += (hours * USEC_PER_HOUR) +
1979                (minutes * USEC_PER_MINUTE) +
1980                (gint64) (seconds * USEC_PER_SECOND);
1981 
1982   /* find the new interval */
1983   interval = g_time_zone_find_interval (datetime-&gt;tz,
1984                                         G_TIME_TYPE_UNIVERSAL,
1985                                         INSTANT_TO_UNIX (full_time));
1986 
1987   /* convert back into local time */
1988   full_time += USEC_PER_SECOND *
1989                g_time_zone_get_offset (datetime-&gt;tz, interval);
1990 
1991   /* split into days and usec of a new datetime */
1992   new = g_date_time_alloc (datetime-&gt;tz);
1993   new-&gt;interval = interval;
1994   new-&gt;days = full_time / USEC_PER_DAY;
1995   new-&gt;usec = full_time % USEC_PER_DAY;
1996 
1997   /* XXX validate */
1998 
1999   return new;
2000 }
2001 
2002 /* Compare, difference, hash, equal {{{1 */
2003 /**
2004  * g_date_time_compare:
2005  * @dt1: (not nullable): first #GDateTime to compare
2006  * @dt2: (not nullable): second #GDateTime to compare
2007  *
2008  * A comparison function for #GDateTimes that is suitable
2009  * as a #GCompareFunc. Both #GDateTimes must be non-%NULL.
2010  *
2011  * Returns: -1, 0 or 1 if @dt1 is less than, equal to or greater
2012  *   than @dt2.
2013  *
2014  * Since: 2.26
2015  */
2016 gint
2017 g_date_time_compare (gconstpointer dt1,
2018                      gconstpointer dt2)
2019 {
2020   gint64 difference;
2021 
2022   difference = g_date_time_difference ((GDateTime *) dt1, (GDateTime *) dt2);
2023 
2024   if (difference &lt; 0)
2025     return -1;
2026 
2027   else if (difference &gt; 0)
2028     return 1;
2029 
2030   else
2031     return 0;
2032 }
2033 
2034 /**
2035  * g_date_time_difference:
2036  * @end: a #GDateTime
2037  * @begin: a #GDateTime
2038  *
2039  * Calculates the difference in time between @end and @begin.  The
2040  * #GTimeSpan that is returned is effectively @end - @begin (ie:
2041  * positive if the first parameter is larger).
2042  *
2043  * Returns: the difference between the two #GDateTime, as a time
2044  *   span expressed in microseconds.
2045  *
2046  * Since: 2.26
2047  */
2048 GTimeSpan
2049 g_date_time_difference (GDateTime *end,
2050                         GDateTime *begin)
2051 {
2052   g_return_val_if_fail (begin != NULL, 0);
2053   g_return_val_if_fail (end != NULL, 0);
2054 
2055   return g_date_time_to_instant (end) -
2056          g_date_time_to_instant (begin);
2057 }
2058 
2059 /**
2060  * g_date_time_hash:
2061  * @datetime: (not nullable): a #GDateTime
2062  *
2063  * Hashes @datetime into a #guint, suitable for use within #GHashTable.
2064  *
2065  * Returns: a #guint containing the hash
2066  *
2067  * Since: 2.26
2068  */
2069 guint
2070 g_date_time_hash (gconstpointer datetime)
2071 {
2072   return g_date_time_to_instant ((GDateTime *) datetime);
2073 }
2074 
2075 /**
2076  * g_date_time_equal:
2077  * @dt1: (not nullable): a #GDateTime
2078  * @dt2: (not nullable): a #GDateTime
2079  *
2080  * Checks to see if @dt1 and @dt2 are equal.
2081  *
2082  * Equal here means that they represent the same moment after converting
2083  * them to the same time zone.
2084  *
2085  * Returns: %TRUE if @dt1 and @dt2 are equal
2086  *
2087  * Since: 2.26
2088  */
2089 gboolean
2090 g_date_time_equal (gconstpointer dt1,
2091                    gconstpointer dt2)
2092 {
2093   return g_date_time_difference ((GDateTime *) dt1, (GDateTime *) dt2) == 0;
2094 }
2095 
2096 /* Year, Month, Day Getters {{{1 */
2097 /**
2098  * g_date_time_get_ymd:
2099  * @datetime: a #GDateTime.
2100  * @year: (out) (optional): the return location for the gregorian year, or %NULL.
2101  * @month: (out) (optional): the return location for the month of the year, or %NULL.
2102  * @day: (out) (optional): the return location for the day of the month, or %NULL.
2103  *
2104  * Retrieves the Gregorian day, month, and year of a given #GDateTime.
2105  *
2106  * Since: 2.26
2107  **/
2108 void
2109 g_date_time_get_ymd (GDateTime *datetime,
2110                      gint      *year,
2111                      gint      *month,
2112                      gint      *day)
2113 {
2114   gint the_year;
2115   gint the_month;
2116   gint the_day;
2117   gint remaining_days;
2118   gint y100_cycles;
2119   gint y4_cycles;
2120   gint y1_cycles;
2121   gint preceding;
2122   gboolean leap;
2123 
2124   g_return_if_fail (datetime != NULL);
2125 #ifdef GSTREAMER_LITE
2126   if (datetime == NULL) {
2127     return;
2128   }
2129 #endif // GSTREAMER_LITE
2130 
2131   remaining_days = datetime-&gt;days;
2132 
2133   /*
2134    * We need to convert an offset in days to its year/month/day representation.
2135    * Leap years makes this a little trickier than it should be, so we use
2136    * 400, 100 and 4 years cycles here to get to the correct year.
2137    */
2138 
2139   /* Our days offset starts sets 0001-01-01 as day 1, if it was day 0 our
2140    * math would be simpler, so let&#39;s do it */
2141   remaining_days--;
2142 
2143   the_year = (remaining_days / DAYS_IN_400YEARS) * 400 + 1;
2144   remaining_days = remaining_days % DAYS_IN_400YEARS;
2145 
2146   y100_cycles = remaining_days / DAYS_IN_100YEARS;
2147   remaining_days = remaining_days % DAYS_IN_100YEARS;
2148   the_year += y100_cycles * 100;
2149 
2150   y4_cycles = remaining_days / DAYS_IN_4YEARS;
2151   remaining_days = remaining_days % DAYS_IN_4YEARS;
2152   the_year += y4_cycles * 4;
2153 
2154   y1_cycles = remaining_days / 365;
2155   the_year += y1_cycles;
2156   remaining_days = remaining_days % 365;
2157 
2158   if (y1_cycles == 4 || y100_cycles == 4) {
2159     g_assert (remaining_days == 0);
2160 
2161     /* special case that indicates that the date is actually one year before,
2162      * in the 31th of December */
2163     the_year--;
2164     the_month = 12;
2165     the_day = 31;
2166     goto end;
2167   }
2168 
2169   /* now get the month and the day */
2170   leap = y1_cycles == 3 &amp;&amp; (y4_cycles != 24 || y100_cycles == 3);
2171 
2172   g_assert (leap == GREGORIAN_LEAP(the_year));
2173 
2174   the_month = (remaining_days + 50) &gt;&gt; 5;
2175   preceding = (days_in_year[0][the_month - 1] + (the_month &gt; 2 &amp;&amp; leap));
2176   if (preceding &gt; remaining_days)
2177     {
2178       /* estimate is too large */
2179       the_month -= 1;
2180       preceding -= leap ? days_in_months[1][the_month]
2181                         : days_in_months[0][the_month];
2182     }
2183 
2184   remaining_days -= preceding;
2185   g_assert(0 &lt;= remaining_days);
2186 
2187   the_day = remaining_days + 1;
2188 
2189 end:
2190   if (year)
2191     *year = the_year;
2192   if (month)
2193     *month = the_month;
2194   if (day)
2195     *day = the_day;
2196 }
2197 
2198 /**
2199  * g_date_time_get_year:
2200  * @datetime: A #GDateTime
2201  *
2202  * Retrieves the year represented by @datetime in the Gregorian calendar.
2203  *
2204  * Returns: the year represented by @datetime
2205  *
2206  * Since: 2.26
2207  */
2208 gint
2209 g_date_time_get_year (GDateTime *datetime)
2210 {
2211   gint year;
2212 
2213   g_return_val_if_fail (datetime != NULL, 0);
2214 
2215   g_date_time_get_ymd (datetime, &amp;year, NULL, NULL);
2216 
2217   return year;
2218 }
2219 
2220 /**
2221  * g_date_time_get_month:
2222  * @datetime: a #GDateTime
2223  *
2224  * Retrieves the month of the year represented by @datetime in the Gregorian
2225  * calendar.
2226  *
2227  * Returns: the month represented by @datetime
2228  *
2229  * Since: 2.26
2230  */
2231 gint
2232 g_date_time_get_month (GDateTime *datetime)
2233 {
2234   gint month;
2235 
2236   g_return_val_if_fail (datetime != NULL, 0);
2237 
2238   g_date_time_get_ymd (datetime, NULL, &amp;month, NULL);
2239 
2240   return month;
2241 }
2242 
2243 /**
2244  * g_date_time_get_day_of_month:
2245  * @datetime: a #GDateTime
2246  *
2247  * Retrieves the day of the month represented by @datetime in the gregorian
2248  * calendar.
2249  *
2250  * Returns: the day of the month
2251  *
2252  * Since: 2.26
2253  */
2254 gint
2255 g_date_time_get_day_of_month (GDateTime *datetime)
2256 {
2257   gint           day_of_year,
2258                  i;
2259   const guint16 *days;
2260   guint16        last = 0;
2261 
2262   g_return_val_if_fail (datetime != NULL, 0);
2263 
2264   days = days_in_year[GREGORIAN_LEAP (g_date_time_get_year (datetime)) ? 1 : 0];
2265   g_date_time_get_week_number (datetime, NULL, NULL, &amp;day_of_year);
2266 
2267   for (i = 1; i &lt;= 12; i++)
2268     {
2269       if (days [i] &gt;= day_of_year)
2270         return day_of_year - last;
2271       last = days [i];
2272     }
2273 
2274   g_warn_if_reached ();
2275   return 0;
2276 }
2277 
2278 /* Week of year / day of week getters {{{1 */
2279 /**
2280  * g_date_time_get_week_numbering_year:
2281  * @datetime: a #GDateTime
2282  *
2283  * Returns the ISO 8601 week-numbering year in which the week containing
2284  * @datetime falls.
2285  *
2286  * This function, taken together with g_date_time_get_week_of_year() and
2287  * g_date_time_get_day_of_week() can be used to determine the full ISO
2288  * week date on which @datetime falls.
2289  *
2290  * This is usually equal to the normal Gregorian year (as returned by
2291  * g_date_time_get_year()), except as detailed below:
2292  *
2293  * For Thursday, the week-numbering year is always equal to the usual
2294  * calendar year.  For other days, the number is such that every day
2295  * within a complete week (Monday to Sunday) is contained within the
2296  * same week-numbering year.
2297  *
2298  * For Monday, Tuesday and Wednesday occurring near the end of the year,
2299  * this may mean that the week-numbering year is one greater than the
2300  * calendar year (so that these days have the same week-numbering year
2301  * as the Thursday occurring early in the next year).
2302  *
2303  * For Friday, Saturday and Sunday occurring near the start of the year,
2304  * this may mean that the week-numbering year is one less than the
2305  * calendar year (so that these days have the same week-numbering year
2306  * as the Thursday occurring late in the previous year).
2307  *
2308  * An equivalent description is that the week-numbering year is equal to
2309  * the calendar year containing the majority of the days in the current
2310  * week (Monday to Sunday).
2311  *
2312  * Note that January 1 0001 in the proleptic Gregorian calendar is a
2313  * Monday, so this function never returns 0.
2314  *
2315  * Returns: the ISO 8601 week-numbering year for @datetime
2316  *
2317  * Since: 2.26
2318  **/
2319 gint
2320 g_date_time_get_week_numbering_year (GDateTime *datetime)
2321 {
2322   gint year, month, day, weekday;
2323 
2324   g_date_time_get_ymd (datetime, &amp;year, &amp;month, &amp;day);
2325   weekday = g_date_time_get_day_of_week (datetime);
2326 
2327   /* January 1, 2, 3 might be in the previous year if they occur after
2328    * Thursday.
2329    *
2330    *   Jan 1:  Friday, Saturday, Sunday    =&gt;  day 1:  weekday 5, 6, 7
2331    *   Jan 2:  Saturday, Sunday            =&gt;  day 2:  weekday 6, 7
2332    *   Jan 3:  Sunday                      =&gt;  day 3:  weekday 7
2333    *
2334    * So we have a special case if (day - weekday) &lt;= -4
2335    */
2336   if (month == 1 &amp;&amp; (day - weekday) &lt;= -4)
2337     return year - 1;
2338 
2339   /* December 29, 30, 31 might be in the next year if they occur before
2340    * Thursday.
2341    *
2342    *   Dec 31: Monday, Tuesday, Wednesday  =&gt;  day 31: weekday 1, 2, 3
2343    *   Dec 30: Monday, Tuesday             =&gt;  day 30: weekday 1, 2
2344    *   Dec 29: Monday                      =&gt;  day 29: weekday 1
2345    *
2346    * So we have a special case if (day - weekday) &gt;= 28
2347    */
2348   else if (month == 12 &amp;&amp; (day - weekday) &gt;= 28)
2349     return year + 1;
2350 
2351   else
2352     return year;
2353 }
2354 
2355 /**
2356  * g_date_time_get_week_of_year:
2357  * @datetime: a #GDateTime
2358  *
2359  * Returns the ISO 8601 week number for the week containing @datetime.
2360  * The ISO 8601 week number is the same for every day of the week (from
2361  * Moday through Sunday).  That can produce some unusual results
2362  * (described below).
2363  *
2364  * The first week of the year is week 1.  This is the week that contains
2365  * the first Thursday of the year.  Equivalently, this is the first week
2366  * that has more than 4 of its days falling within the calendar year.
2367  *
2368  * The value 0 is never returned by this function.  Days contained
2369  * within a year but occurring before the first ISO 8601 week of that
2370  * year are considered as being contained in the last week of the
2371  * previous year.  Similarly, the final days of a calendar year may be
2372  * considered as being part of the first ISO 8601 week of the next year
2373  * if 4 or more days of that week are contained within the new year.
2374  *
2375  * Returns: the ISO 8601 week number for @datetime.
2376  *
2377  * Since: 2.26
2378  */
2379 gint
2380 g_date_time_get_week_of_year (GDateTime *datetime)
2381 {
2382   gint weeknum;
2383 
2384   g_return_val_if_fail (datetime != NULL, 0);
2385 
2386   g_date_time_get_week_number (datetime, &amp;weeknum, NULL, NULL);
2387 
2388   return weeknum;
2389 }
2390 
2391 /**
2392  * g_date_time_get_day_of_week:
2393  * @datetime: a #GDateTime
2394  *
2395  * Retrieves the ISO 8601 day of the week on which @datetime falls (1 is
2396  * Monday, 2 is Tuesday... 7 is Sunday).
2397  *
2398  * Returns: the day of the week
2399  *
2400  * Since: 2.26
2401  */
2402 gint
2403 g_date_time_get_day_of_week (GDateTime *datetime)
2404 {
2405   g_return_val_if_fail (datetime != NULL, 0);
2406 
2407   return (datetime-&gt;days - 1) % 7 + 1;
2408 }
2409 
2410 /* Day of year getter {{{1 */
2411 /**
2412  * g_date_time_get_day_of_year:
2413  * @datetime: a #GDateTime
2414  *
2415  * Retrieves the day of the year represented by @datetime in the Gregorian
2416  * calendar.
2417  *
2418  * Returns: the day of the year
2419  *
2420  * Since: 2.26
2421  */
2422 gint
2423 g_date_time_get_day_of_year (GDateTime *datetime)
2424 {
2425   gint doy = 0;
2426 
2427   g_return_val_if_fail (datetime != NULL, 0);
2428 
2429   g_date_time_get_week_number (datetime, NULL, NULL, &amp;doy);
2430   return doy;
2431 }
2432 
2433 /* Time component getters {{{1 */
2434 
2435 /**
2436  * g_date_time_get_hour:
2437  * @datetime: a #GDateTime
2438  *
2439  * Retrieves the hour of the day represented by @datetime
2440  *
2441  * Returns: the hour of the day
2442  *
2443  * Since: 2.26
2444  */
2445 gint
2446 g_date_time_get_hour (GDateTime *datetime)
2447 {
2448   g_return_val_if_fail (datetime != NULL, 0);
2449 
2450   return (datetime-&gt;usec / USEC_PER_HOUR);
2451 }
2452 
2453 /**
2454  * g_date_time_get_minute:
2455  * @datetime: a #GDateTime
2456  *
2457  * Retrieves the minute of the hour represented by @datetime
2458  *
2459  * Returns: the minute of the hour
2460  *
2461  * Since: 2.26
2462  */
2463 gint
2464 g_date_time_get_minute (GDateTime *datetime)
2465 {
2466   g_return_val_if_fail (datetime != NULL, 0);
2467 
2468   return (datetime-&gt;usec % USEC_PER_HOUR) / USEC_PER_MINUTE;
2469 }
2470 
2471 /**
2472  * g_date_time_get_second:
2473  * @datetime: a #GDateTime
2474  *
2475  * Retrieves the second of the minute represented by @datetime
2476  *
2477  * Returns: the second represented by @datetime
2478  *
2479  * Since: 2.26
2480  */
2481 gint
2482 g_date_time_get_second (GDateTime *datetime)
2483 {
2484   g_return_val_if_fail (datetime != NULL, 0);
2485 
2486   return (datetime-&gt;usec % USEC_PER_MINUTE) / USEC_PER_SECOND;
2487 }
2488 
2489 /**
2490  * g_date_time_get_microsecond:
2491  * @datetime: a #GDateTime
2492  *
2493  * Retrieves the microsecond of the date represented by @datetime
2494  *
2495  * Returns: the microsecond of the second
2496  *
2497  * Since: 2.26
2498  */
2499 gint
2500 g_date_time_get_microsecond (GDateTime *datetime)
2501 {
2502   g_return_val_if_fail (datetime != NULL, 0);
2503 
2504   return (datetime-&gt;usec % USEC_PER_SECOND);
2505 }
2506 
2507 /**
2508  * g_date_time_get_seconds:
2509  * @datetime: a #GDateTime
2510  *
2511  * Retrieves the number of seconds since the start of the last minute,
2512  * including the fractional part.
2513  *
2514  * Returns: the number of seconds
2515  *
2516  * Since: 2.26
2517  **/
2518 gdouble
2519 g_date_time_get_seconds (GDateTime *datetime)
2520 {
2521   g_return_val_if_fail (datetime != NULL, 0);
2522 
2523   return (datetime-&gt;usec % USEC_PER_MINUTE) / 1000000.0;
2524 }
2525 
2526 /* Exporters {{{1 */
2527 /**
2528  * g_date_time_to_unix:
2529  * @datetime: a #GDateTime
2530  *
2531  * Gives the Unix time corresponding to @datetime, rounding down to the
2532  * nearest second.
2533  *
2534  * Unix time is the number of seconds that have elapsed since 1970-01-01
2535  * 00:00:00 UTC, regardless of the time zone associated with @datetime.
2536  *
2537  * Returns: the Unix time corresponding to @datetime
2538  *
2539  * Since: 2.26
2540  **/
2541 gint64
2542 g_date_time_to_unix (GDateTime *datetime)
2543 {
2544   return INSTANT_TO_UNIX (g_date_time_to_instant (datetime));
2545 }
2546 
2547 /**
2548  * g_date_time_to_timeval:
2549  * @datetime: a #GDateTime
2550  * @tv: a #GTimeVal to modify
2551  *
2552  * Stores the instant in time that @datetime represents into @tv.
2553  *
2554  * The time contained in a #GTimeVal is always stored in the form of
2555  * seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the time
2556  * zone associated with @datetime.
2557  *
2558  * On systems where &#39;long&#39; is 32bit (ie: all 32bit systems and all
2559  * Windows systems), a #GTimeVal is incapable of storing the entire
2560  * range of values that #GDateTime is capable of expressing.  On those
2561  * systems, this function returns %FALSE to indicate that the time is
2562  * out of range.
2563  *
2564  * On systems where &#39;long&#39; is 64bit, this function never fails.
2565  *
2566  * Returns: %TRUE if successful, else %FALSE
2567  *
2568  * Since: 2.26
2569  * Deprecated: 2.62: #GTimeVal is not year-2038-safe. Use
2570  *    g_date_time_to_unix() instead.
2571  **/
2572 G_GNUC_BEGIN_IGNORE_DEPRECATIONS
2573 gboolean
2574 g_date_time_to_timeval (GDateTime *datetime,
2575                         GTimeVal  *tv)
2576 {
2577   tv-&gt;tv_sec = INSTANT_TO_UNIX (g_date_time_to_instant (datetime));
2578   tv-&gt;tv_usec = datetime-&gt;usec % USEC_PER_SECOND;
2579 
2580   return TRUE;
2581 }
2582 G_GNUC_END_IGNORE_DEPRECATIONS
2583 
2584 /* Timezone queries {{{1 */
2585 /**
2586  * g_date_time_get_utc_offset:
2587  * @datetime: a #GDateTime
2588  *
2589  * Determines the offset to UTC in effect at the time and in the time
2590  * zone of @datetime.
2591  *
2592  * The offset is the number of microseconds that you add to UTC time to
2593  * arrive at local time for the time zone (ie: negative numbers for time
2594  * zones west of GMT, positive numbers for east).
2595  *
2596  * If @datetime represents UTC time, then the offset is always zero.
2597  *
2598  * Returns: the number of microseconds that should be added to UTC to
2599  *          get the local time
2600  *
2601  * Since: 2.26
2602  **/
2603 GTimeSpan
2604 g_date_time_get_utc_offset (GDateTime *datetime)
2605 {
2606   gint offset;
2607 
2608   g_return_val_if_fail (datetime != NULL, 0);
2609 
2610   offset = g_time_zone_get_offset (datetime-&gt;tz, datetime-&gt;interval);
2611 
2612   return (gint64) offset * USEC_PER_SECOND;
2613 }
2614 
2615 /**
2616  * g_date_time_get_timezone:
2617  * @datetime: a #GDateTime
2618  *
2619  * Get the time zone for this @datetime.
2620  *
2621  * Returns: (transfer none): the time zone
2622  * Since: 2.58
2623  */
2624 GTimeZone *
2625 g_date_time_get_timezone (GDateTime *datetime)
2626 {
2627   g_return_val_if_fail (datetime != NULL, NULL);
2628 
2629   g_assert (datetime-&gt;tz != NULL);
2630   return datetime-&gt;tz;
2631 }
2632 
2633 /**
2634  * g_date_time_get_timezone_abbreviation:
2635  * @datetime: a #GDateTime
2636  *
2637  * Determines the time zone abbreviation to be used at the time and in
2638  * the time zone of @datetime.
2639  *
2640  * For example, in Toronto this is currently &quot;EST&quot; during the winter
2641  * months and &quot;EDT&quot; during the summer months when daylight savings
2642  * time is in effect.
2643  *
2644  * Returns: (transfer none): the time zone abbreviation. The returned
2645  *          string is owned by the #GDateTime and it should not be
2646  *          modified or freed
2647  *
2648  * Since: 2.26
2649  **/
2650 const gchar *
2651 g_date_time_get_timezone_abbreviation (GDateTime *datetime)
2652 {
2653   g_return_val_if_fail (datetime != NULL, NULL);
2654 
2655   return g_time_zone_get_abbreviation (datetime-&gt;tz, datetime-&gt;interval);
2656 }
2657 
2658 /**
2659  * g_date_time_is_daylight_savings:
2660  * @datetime: a #GDateTime
2661  *
2662  * Determines if daylight savings time is in effect at the time and in
2663  * the time zone of @datetime.
2664  *
2665  * Returns: %TRUE if daylight savings time is in effect
2666  *
2667  * Since: 2.26
2668  **/
2669 gboolean
2670 g_date_time_is_daylight_savings (GDateTime *datetime)
2671 {
2672   g_return_val_if_fail (datetime != NULL, FALSE);
2673 
2674   return g_time_zone_is_dst (datetime-&gt;tz, datetime-&gt;interval);
2675 }
2676 
2677 /* Timezone convert {{{1 */
2678 /**
2679  * g_date_time_to_timezone:
2680  * @datetime: a #GDateTime
2681  * @tz: the new #GTimeZone
2682  *
2683  * Create a new #GDateTime corresponding to the same instant in time as
2684  * @datetime, but in the time zone @tz.
2685  *
2686  * This call can fail in the case that the time goes out of bounds.  For
2687  * example, converting 0001-01-01 00:00:00 UTC to a time zone west of
2688  * Greenwich will fail (due to the year 0 being out of range).
2689  *
2690  * You should release the return value by calling g_date_time_unref()
2691  * when you are done with it.
2692  *
2693  * Returns: a new #GDateTime, or %NULL
2694  *
2695  * Since: 2.26
2696  **/
2697 GDateTime *
2698 g_date_time_to_timezone (GDateTime *datetime,
2699                          GTimeZone *tz)
2700 {
2701   return g_date_time_from_instant (tz, g_date_time_to_instant (datetime));
2702 }
2703 
2704 /**
2705  * g_date_time_to_local:
2706  * @datetime: a #GDateTime
2707  *
2708  * Creates a new #GDateTime corresponding to the same instant in time as
2709  * @datetime, but in the local time zone.
2710  *
2711  * This call is equivalent to calling g_date_time_to_timezone() with the
2712  * time zone returned by g_time_zone_new_local().
2713  *
2714  * Returns: the newly created #GDateTime
2715  *
2716  * Since: 2.26
2717  **/
2718 GDateTime *
2719 g_date_time_to_local (GDateTime *datetime)
2720 {
2721   GDateTime *new;
2722   GTimeZone *local;
2723 
2724   local = g_time_zone_new_local ();
2725   new = g_date_time_to_timezone (datetime, local);
2726   g_time_zone_unref (local);
2727 
2728   return new;
2729 }
2730 
2731 /**
2732  * g_date_time_to_utc:
2733  * @datetime: a #GDateTime
2734  *
2735  * Creates a new #GDateTime corresponding to the same instant in time as
2736  * @datetime, but in UTC.
2737  *
2738  * This call is equivalent to calling g_date_time_to_timezone() with the
2739  * time zone returned by g_time_zone_new_utc().
2740  *
2741  * Returns: the newly created #GDateTime
2742  *
2743  * Since: 2.26
2744  **/
2745 GDateTime *
2746 g_date_time_to_utc (GDateTime *datetime)
2747 {
2748   GDateTime *new;
2749   GTimeZone *utc;
2750 
2751   utc = g_time_zone_new_utc ();
2752   new = g_date_time_to_timezone (datetime, utc);
2753   g_time_zone_unref (utc);
2754 
2755   return new;
2756 }
2757 
2758 /* Format {{{1 */
2759 
2760 static gboolean
2761 format_z (GString *outstr,
2762           gint     offset,
2763           guint    colons)
2764 {
2765   gint hours;
2766   gint minutes;
2767   gint seconds;
2768   gchar sign = offset &gt;= 0 ? &#39;+&#39; : &#39;-&#39;;
2769 
2770   offset = ABS (offset);
2771   hours = offset / 3600;
2772   minutes = offset / 60 % 60;
2773   seconds = offset % 60;
2774 
2775   switch (colons)
2776     {
2777     case 0:
2778       g_string_append_printf (outstr, &quot;%c%02d%02d&quot;,
2779                               sign,
2780                               hours,
2781                               minutes);
2782       break;
2783 
2784     case 1:
2785       g_string_append_printf (outstr, &quot;%c%02d:%02d&quot;,
2786                               sign,
2787                               hours,
2788                               minutes);
2789       break;
2790 
2791     case 2:
2792       g_string_append_printf (outstr, &quot;%c%02d:%02d:%02d&quot;,
2793                               sign,
2794                               hours,
2795                               minutes,
2796                               seconds);
2797       break;
2798 
2799     case 3:
2800       g_string_append_printf (outstr, &quot;%c%02d&quot;, sign, hours);
2801 
2802       if (minutes != 0 || seconds != 0)
2803         {
2804           g_string_append_printf (outstr, &quot;:%02d&quot;, minutes);
2805 
2806           if (seconds != 0)
2807             g_string_append_printf (outstr, &quot;:%02d&quot;, seconds);
2808         }
2809       break;
2810 
2811     default:
2812       return FALSE;
2813     }
2814 
2815   return TRUE;
2816 }
2817 
2818 #ifdef HAVE_LANGINFO_OUTDIGIT
2819 /* Initializes the array with UTF-8 encoded alternate digits suitable for use
2820  * in current locale. Returns NULL when current locale does not use alternate
2821  * digits or there was an error converting them to UTF-8.
2822  */
2823 static const gchar * const *
2824 initialize_alt_digits (void)
2825 {
2826   guint i;
2827   gsize digit_len;
2828   gchar *digit;
2829   const gchar *locale_digit;
2830 #define N_DIGITS 10
2831 #define MAX_UTF8_ENCODING_LEN 4
2832   static gchar buffer[N_DIGITS * (MAX_UTF8_ENCODING_LEN + 1 /* null separator */)];
2833 #undef N_DIGITS
2834 #undef MAX_UTF8_ENCODING_LEN
2835   gchar *buffer_end = buffer;
2836   static const gchar *alt_digits[10];
2837 
2838   for (i = 0; i != 10; ++i)
2839     {
2840       locale_digit = nl_langinfo (_NL_CTYPE_OUTDIGIT0_MB + i);
2841 
2842       if (g_strcmp0 (locale_digit, &quot;&quot;) == 0)
2843         return NULL;
2844 
2845       digit = g_locale_to_utf8 (locale_digit, -1, NULL, &amp;digit_len, NULL);
2846       if (digit == NULL)
2847         return NULL;
2848 
2849       g_assert (digit_len &lt; (gsize) (buffer + sizeof (buffer) - buffer_end));
2850 
2851       alt_digits[i] = buffer_end;
2852       buffer_end = g_stpcpy (buffer_end, digit);
2853       /* skip trailing null byte */
2854       buffer_end += 1;
2855 
2856       g_free (digit);
2857     }
2858 
2859   return alt_digits;
2860 }
2861 #endif /* HAVE_LANGINFO_OUTDIGIT */
2862 
2863 static void
2864 format_number (GString     *str,
2865                gboolean     use_alt_digits,
2866                const gchar *pad,
2867                gint         width,
2868                guint32      number)
2869 {
2870   const gchar *ascii_digits[10] = {
2871     &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;
2872   };
2873   const gchar * const *digits = ascii_digits;
2874   const gchar *tmp[10];
2875   gint i = 0;
2876 
2877   g_return_if_fail (width &lt;= 10);
2878 
2879 #ifdef HAVE_LANGINFO_OUTDIGIT
2880   if (use_alt_digits)
2881     {
2882       static const gchar * const *alt_digits = NULL;
2883       static gsize initialised;
2884 
2885       if G_UNLIKELY (g_once_init_enter (&amp;initialised))
2886         {
2887           alt_digits = initialize_alt_digits ();
2888 
2889           if (alt_digits == NULL)
2890             alt_digits = ascii_digits;
2891 
2892           g_once_init_leave (&amp;initialised, TRUE);
2893         }
2894 
2895       digits = alt_digits;
2896     }
2897 #endif /* HAVE_LANGINFO_OUTDIGIT */
2898 
2899   do
2900     {
2901       tmp[i++] = digits[number % 10];
2902       number /= 10;
2903     }
2904   while (number);
2905 
2906   while (pad &amp;&amp; i &lt; width)
2907     tmp[i++] = *pad == &#39;0&#39; ? digits[0] : pad;
2908 
2909   /* should really be impossible */
2910   g_assert (i &lt;= 10);
2911 
2912   while (i)
2913     g_string_append (str, tmp[--i]);
2914 }
2915 
2916 static gboolean
2917 format_ampm (GDateTime *datetime,
2918              GString   *outstr,
2919              gboolean   locale_is_utf8,
2920              gboolean   uppercase)
2921 {
2922   const gchar *ampm;
2923   gchar       *tmp = NULL, *ampm_dup;
2924 
2925   ampm = GET_AMPM (datetime);
2926 
2927   if (!ampm || ampm[0] == &#39;\0&#39;)
2928     ampm = get_fallback_ampm (g_date_time_get_hour (datetime));
2929 
2930   if (!locale_is_utf8 &amp;&amp; GET_AMPM_IS_LOCALE)
2931     {
2932       /* This assumes that locale encoding can&#39;t have embedded NULs */
2933       ampm = tmp = g_locale_to_utf8 (ampm, -1, NULL, NULL, NULL);
2934       if (tmp == NULL)
2935         return FALSE;
2936     }
2937   if (uppercase)
2938     ampm_dup = g_utf8_strup (ampm, -1);
2939   else
2940     ampm_dup = g_utf8_strdown (ampm, -1);
2941   g_free (tmp);
2942 
2943   g_string_append (outstr, ampm_dup);
2944   g_free (ampm_dup);
2945 
2946   return TRUE;
2947 }
2948 
2949 static gboolean g_date_time_format_utf8 (GDateTime   *datetime,
2950            const gchar *format,
2951            GString     *outstr,
2952            gboolean     locale_is_utf8);
2953 
2954 /* g_date_time_format() subroutine that takes a locale-encoded format
2955  * string and produces a UTF-8 encoded date/time string.
2956  */
2957 static gboolean
2958 g_date_time_format_locale (GDateTime   *datetime,
2959          const gchar *locale_format,
2960          GString     *outstr,
2961          gboolean     locale_is_utf8)
2962 {
2963   gchar *utf8_format;
2964   gboolean success;
2965 
2966   if (locale_is_utf8)
2967     return g_date_time_format_utf8 (datetime, locale_format, outstr, locale_is_utf8);
2968 
2969   utf8_format = g_locale_to_utf8 (locale_format, -1, NULL, NULL, NULL);
2970   if (utf8_format == NULL)
2971     return FALSE;
2972 
2973   success = g_date_time_format_utf8 (datetime, utf8_format, outstr,
2974                                      locale_is_utf8);
2975   g_free (utf8_format);
2976   return success;
2977 }
2978 
2979 static inline gboolean
2980 string_append (GString     *string,
2981                const gchar *s,
2982                gboolean     s_is_utf8)
2983 {
2984   gchar *utf8;
2985   gsize  utf8_len;
2986 
2987   if (s_is_utf8)
2988     {
2989       g_string_append (string, s);
2990     }
2991   else
2992     {
2993       utf8 = g_locale_to_utf8 (s, -1, NULL, &amp;utf8_len, NULL);
2994       if (utf8 == NULL)
2995         return FALSE;
2996       g_string_append_len (string, utf8, utf8_len);
2997       g_free (utf8);
2998     }
2999 
3000   return TRUE;
3001 }
3002 
3003 /* g_date_time_format() subroutine that takes a UTF-8 encoded format
3004  * string and produces a UTF-8 encoded date/time string.
3005  */
3006 static gboolean
3007 g_date_time_format_utf8 (GDateTime   *datetime,
3008        const gchar *utf8_format,
3009        GString     *outstr,
3010        gboolean     locale_is_utf8)
3011 {
3012   guint     len;
3013   guint     colons;
3014   gunichar  c;
3015   gboolean  alt_digits = FALSE;
3016   gboolean  pad_set = FALSE;
3017   gboolean  name_is_utf8;
3018   const gchar *pad = &quot;&quot;;
3019   const gchar *name;
3020   const gchar *tz;
3021 
3022   while (*utf8_format)
3023     {
3024       len = strcspn (utf8_format, &quot;%&quot;);
3025       if (len)
3026         g_string_append_len (outstr, utf8_format, len);
3027 
3028       utf8_format += len;
3029       if (!*utf8_format)
3030   break;
3031 
3032       g_assert (*utf8_format == &#39;%&#39;);
3033       utf8_format++;
3034       if (!*utf8_format)
3035   break;
3036 
3037       colons = 0;
3038       alt_digits = FALSE;
3039       pad_set = FALSE;
3040 
3041     next_mod:
3042       c = g_utf8_get_char (utf8_format);
3043       utf8_format = g_utf8_next_char (utf8_format);
3044       switch (c)
3045   {
3046   case &#39;a&#39;:
3047     name = WEEKDAY_ABBR (datetime);
3048           if (g_strcmp0 (name, &quot;&quot;) == 0)
3049             return FALSE;
3050 
3051           name_is_utf8 = locale_is_utf8 || !WEEKDAY_ABBR_IS_LOCALE;
3052 
3053           if (!string_append (outstr, name, name_is_utf8))
3054             return FALSE;
3055 
3056     break;
3057   case &#39;A&#39;:
3058     name = WEEKDAY_FULL (datetime);
3059           if (g_strcmp0 (name, &quot;&quot;) == 0)
3060             return FALSE;
3061 
3062           name_is_utf8 = locale_is_utf8 || !WEEKDAY_FULL_IS_LOCALE;
3063 
3064           if (!string_append (outstr, name, name_is_utf8))
3065             return FALSE;
3066 
3067     break;
3068   case &#39;b&#39;:
3069     name = alt_digits ? MONTH_ABBR_STANDALONE (datetime)
3070           : MONTH_ABBR_WITH_DAY (datetime);
3071           if (g_strcmp0 (name, &quot;&quot;) == 0)
3072             return FALSE;
3073 
3074           name_is_utf8 = locale_is_utf8 ||
3075             ((alt_digits &amp;&amp; !MONTH_ABBR_STANDALONE_IS_LOCALE) ||
3076              (!alt_digits &amp;&amp; !MONTH_ABBR_WITH_DAY_IS_LOCALE));
3077 
3078           if (!string_append (outstr, name, name_is_utf8))
3079             return FALSE;
3080 
3081     break;
3082   case &#39;B&#39;:
3083     name = alt_digits ? MONTH_FULL_STANDALONE (datetime)
3084           : MONTH_FULL_WITH_DAY (datetime);
3085           if (g_strcmp0 (name, &quot;&quot;) == 0)
3086             return FALSE;
3087 
3088           name_is_utf8 = locale_is_utf8 ||
3089             ((alt_digits &amp;&amp; !MONTH_FULL_STANDALONE_IS_LOCALE) ||
3090              (!alt_digits &amp;&amp; !MONTH_FULL_WITH_DAY_IS_LOCALE));
3091 
3092           if (!string_append (outstr, name, name_is_utf8))
3093               return FALSE;
3094 
3095     break;
3096   case &#39;c&#39;:
3097     {
3098             if (g_strcmp0 (PREFERRED_DATE_TIME_FMT, &quot;&quot;) == 0)
3099               return FALSE;
3100             if (!g_date_time_format_locale (datetime, PREFERRED_DATE_TIME_FMT,
3101                                             outstr, locale_is_utf8))
3102               return FALSE;
3103     }
3104     break;
3105   case &#39;C&#39;:
3106     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3107        g_date_time_get_year (datetime) / 100);
3108     break;
3109   case &#39;d&#39;:
3110     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3111        g_date_time_get_day_of_month (datetime));
3112     break;
3113   case &#39;e&#39;:
3114     format_number (outstr, alt_digits, pad_set ? pad : &quot; &quot;, 2,
3115        g_date_time_get_day_of_month (datetime));
3116     break;
3117   case &#39;F&#39;:
3118     g_string_append_printf (outstr, &quot;%d-%02d-%02d&quot;,
3119           g_date_time_get_year (datetime),
3120           g_date_time_get_month (datetime),
3121           g_date_time_get_day_of_month (datetime));
3122     break;
3123   case &#39;g&#39;:
3124     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3125        g_date_time_get_week_numbering_year (datetime) % 100);
3126     break;
3127   case &#39;G&#39;:
3128     format_number (outstr, alt_digits, pad_set ? pad : 0, 0,
3129        g_date_time_get_week_numbering_year (datetime));
3130     break;
3131   case &#39;h&#39;:
3132     name = alt_digits ? MONTH_ABBR_STANDALONE (datetime)
3133           : MONTH_ABBR_WITH_DAY (datetime);
3134           if (g_strcmp0 (name, &quot;&quot;) == 0)
3135             return FALSE;
3136 
3137           name_is_utf8 = locale_is_utf8 ||
3138             ((alt_digits &amp;&amp; !MONTH_ABBR_STANDALONE_IS_LOCALE) ||
3139              (!alt_digits &amp;&amp; !MONTH_ABBR_WITH_DAY_IS_LOCALE));
3140 
3141           if (!string_append (outstr, name, name_is_utf8))
3142             return FALSE;
3143 
3144     break;
3145   case &#39;H&#39;:
3146     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3147        g_date_time_get_hour (datetime));
3148     break;
3149   case &#39;I&#39;:
3150     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3151        (g_date_time_get_hour (datetime) + 11) % 12 + 1);
3152     break;
3153   case &#39;j&#39;:
3154     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 3,
3155        g_date_time_get_day_of_year (datetime));
3156     break;
3157   case &#39;k&#39;:
3158     format_number (outstr, alt_digits, pad_set ? pad : &quot; &quot;, 2,
3159        g_date_time_get_hour (datetime));
3160     break;
3161   case &#39;l&#39;:
3162     format_number (outstr, alt_digits, pad_set ? pad : &quot; &quot;, 2,
3163        (g_date_time_get_hour (datetime) + 11) % 12 + 1);
3164     break;
3165   case &#39;n&#39;:
3166     g_string_append_c (outstr, &#39;\n&#39;);
3167     break;
3168   case &#39;m&#39;:
3169     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3170        g_date_time_get_month (datetime));
3171     break;
3172   case &#39;M&#39;:
3173     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3174        g_date_time_get_minute (datetime));
3175     break;
3176   case &#39;O&#39;:
3177     alt_digits = TRUE;
3178     goto next_mod;
3179   case &#39;p&#39;:
3180           if (!format_ampm (datetime, outstr, locale_is_utf8, TRUE))
3181             return FALSE;
3182           break;
3183   case &#39;P&#39;:
3184           if (!format_ampm (datetime, outstr, locale_is_utf8, FALSE))
3185             return FALSE;
3186     break;
3187   case &#39;r&#39;:
3188     {
3189             if (g_strcmp0 (PREFERRED_12HR_TIME_FMT, &quot;&quot;) == 0)
3190               return FALSE;
3191       if (!g_date_time_format_locale (datetime, PREFERRED_12HR_TIME_FMT,
3192               outstr, locale_is_utf8))
3193         return FALSE;
3194     }
3195     break;
3196   case &#39;R&#39;:
3197     g_string_append_printf (outstr, &quot;%02d:%02d&quot;,
3198           g_date_time_get_hour (datetime),
3199           g_date_time_get_minute (datetime));
3200     break;
3201   case &#39;s&#39;:
3202     g_string_append_printf (outstr, &quot;%&quot; G_GINT64_FORMAT, g_date_time_to_unix (datetime));
3203     break;
3204   case &#39;S&#39;:
3205     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3206        g_date_time_get_second (datetime));
3207     break;
3208   case &#39;t&#39;:
3209     g_string_append_c (outstr, &#39;\t&#39;);
3210     break;
3211   case &#39;T&#39;:
3212     g_string_append_printf (outstr, &quot;%02d:%02d:%02d&quot;,
3213           g_date_time_get_hour (datetime),
3214           g_date_time_get_minute (datetime),
3215           g_date_time_get_second (datetime));
3216     break;
3217   case &#39;u&#39;:
3218     format_number (outstr, alt_digits, 0, 0,
3219        g_date_time_get_day_of_week (datetime));
3220     break;
3221   case &#39;V&#39;:
3222     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3223        g_date_time_get_week_of_year (datetime));
3224     break;
3225   case &#39;w&#39;:
3226     format_number (outstr, alt_digits, 0, 0,
3227        g_date_time_get_day_of_week (datetime) % 7);
3228     break;
3229   case &#39;x&#39;:
3230     {
3231             if (g_strcmp0 (PREFERRED_DATE_FMT, &quot;&quot;) == 0)
3232               return FALSE;
3233       if (!g_date_time_format_locale (datetime, PREFERRED_DATE_FMT,
3234               outstr, locale_is_utf8))
3235         return FALSE;
3236     }
3237     break;
3238   case &#39;X&#39;:
3239     {
3240             if (g_strcmp0 (PREFERRED_TIME_FMT, &quot;&quot;) == 0)
3241               return FALSE;
3242       if (!g_date_time_format_locale (datetime, PREFERRED_TIME_FMT,
3243               outstr, locale_is_utf8))
3244         return FALSE;
3245     }
3246     break;
3247   case &#39;y&#39;:
3248     format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3249        g_date_time_get_year (datetime) % 100);
3250     break;
3251   case &#39;Y&#39;:
3252     format_number (outstr, alt_digits, 0, 0,
3253        g_date_time_get_year (datetime));
3254     break;
3255   case &#39;z&#39;:
3256     {
3257       gint64 offset;
3258       offset = g_date_time_get_utc_offset (datetime) / USEC_PER_SECOND;
3259       if (!format_z (outstr, (int) offset, colons))
3260         return FALSE;
3261     }
3262     break;
3263   case &#39;Z&#39;:
3264     tz = g_date_time_get_timezone_abbreviation (datetime);
3265           g_string_append (outstr, tz);
3266     break;
3267   case &#39;%&#39;:
3268     g_string_append_c (outstr, &#39;%&#39;);
3269     break;
3270   case &#39;-&#39;:
3271     pad_set = TRUE;
3272     pad = &quot;&quot;;
3273     goto next_mod;
3274   case &#39;_&#39;:
3275     pad_set = TRUE;
3276     pad = &quot; &quot;;
3277     goto next_mod;
3278   case &#39;0&#39;:
3279     pad_set = TRUE;
3280     pad = &quot;0&quot;;
3281     goto next_mod;
3282   case &#39;:&#39;:
3283     /* Colons are only allowed before &#39;z&#39; */
3284     if (*utf8_format &amp;&amp; *utf8_format != &#39;z&#39; &amp;&amp; *utf8_format != &#39;:&#39;)
3285       return FALSE;
3286     colons++;
3287     goto next_mod;
3288   default:
3289     return FALSE;
3290   }
3291     }
3292 
3293   return TRUE;
3294 }
3295 
3296 /**
3297  * g_date_time_format:
3298  * @datetime: A #GDateTime
3299  * @format: a valid UTF-8 string, containing the format for the
3300  *          #GDateTime
3301  *
3302  * Creates a newly allocated string representing the requested @format.
3303  *
3304  * The format strings understood by this function are a subset of the
3305  * strftime() format language as specified by C99.  The \%D, \%U and \%W
3306  * conversions are not supported, nor is the &#39;E&#39; modifier.  The GNU
3307  * extensions \%k, \%l, \%s and \%P are supported, however, as are the
3308  * &#39;0&#39;, &#39;_&#39; and &#39;-&#39; modifiers.
3309  *
3310  * In contrast to strftime(), this function always produces a UTF-8
3311  * string, regardless of the current locale.  Note that the rendering of
3312  * many formats is locale-dependent and may not match the strftime()
3313  * output exactly.
3314  *
3315  * The following format specifiers are supported:
3316  *
3317  * - \%a: the abbreviated weekday name according to the current locale
3318  * - \%A: the full weekday name according to the current locale
3319  * - \%b: the abbreviated month name according to the current locale
3320  * - \%B: the full month name according to the current locale
3321  * - \%c: the preferred date and time representation for the current locale
3322  * - \%C: the century number (year/100) as a 2-digit integer (00-99)
3323  * - \%d: the day of the month as a decimal number (range 01 to 31)
3324  * - \%e: the day of the month as a decimal number (range  1 to 31)
3325  * - \%F: equivalent to `%Y-%m-%d` (the ISO 8601 date format)
3326  * - \%g: the last two digits of the ISO 8601 week-based year as a
3327  *   decimal number (00-99). This works well with \%V and \%u.
3328  * - \%G: the ISO 8601 week-based year as a decimal number. This works
3329  *   well with \%V and \%u.
3330  * - \%h: equivalent to \%b
3331  * - \%H: the hour as a decimal number using a 24-hour clock (range 00 to 23)
3332  * - \%I: the hour as a decimal number using a 12-hour clock (range 01 to 12)
3333  * - \%j: the day of the year as a decimal number (range 001 to 366)
3334  * - \%k: the hour (24-hour clock) as a decimal number (range 0 to 23);
3335  *   single digits are preceded by a blank
3336  * - \%l: the hour (12-hour clock) as a decimal number (range 1 to 12);
3337  *   single digits are preceded by a blank
3338  * - \%m: the month as a decimal number (range 01 to 12)
3339  * - \%M: the minute as a decimal number (range 00 to 59)
3340  * - \%p: either &quot;AM&quot; or &quot;PM&quot; according to the given time value, or the
3341  *   corresponding  strings for the current locale.  Noon is treated as
3342  *   &quot;PM&quot; and midnight as &quot;AM&quot;.
3343  * - \%P: like \%p but lowercase: &quot;am&quot; or &quot;pm&quot; or a corresponding string for
3344  *   the current locale
3345  * - \%r: the time in a.m. or p.m. notation
3346  * - \%R: the time in 24-hour notation (\%H:\%M)
3347  * - \%s: the number of seconds since the Epoch, that is, since 1970-01-01
3348  *   00:00:00 UTC
3349  * - \%S: the second as a decimal number (range 00 to 60)
3350  * - \%t: a tab character
3351  * - \%T: the time in 24-hour notation with seconds (\%H:\%M:\%S)
3352  * - \%u: the ISO 8601 standard day of the week as a decimal, range 1 to 7,
3353  *    Monday being 1. This works well with \%G and \%V.
3354  * - \%V: the ISO 8601 standard week number of the current year as a decimal
3355  *   number, range 01 to 53, where week 1 is the first week that has at
3356  *   least 4 days in the new year. See g_date_time_get_week_of_year().
3357  *   This works well with \%G and \%u.
3358  * - \%w: the day of the week as a decimal, range 0 to 6, Sunday being 0.
3359  *   This is not the ISO 8601 standard format -- use \%u instead.
3360  * - \%x: the preferred date representation for the current locale without
3361  *   the time
3362  * - \%X: the preferred time representation for the current locale without
3363  *   the date
3364  * - \%y: the year as a decimal number without the century
3365  * - \%Y: the year as a decimal number including the century
3366  * - \%z: the time zone as an offset from UTC (+hhmm)
3367  * - \%:z: the time zone as an offset from UTC (+hh:mm).
3368  *   This is a gnulib strftime() extension. Since: 2.38
3369  * - \%::z: the time zone as an offset from UTC (+hh:mm:ss). This is a
3370  *   gnulib strftime() extension. Since: 2.38
3371  * - \%:::z: the time zone as an offset from UTC, with : to necessary
3372  *   precision (e.g., -04, +05:30). This is a gnulib strftime() extension. Since: 2.38
3373  * - \%Z: the time zone or name or abbreviation
3374  * - \%\%: a literal \% character
3375  *
3376  * Some conversion specifications can be modified by preceding the
3377  * conversion specifier by one or more modifier characters. The
3378  * following modifiers are supported for many of the numeric
3379  * conversions:
3380  *
3381  * - O: Use alternative numeric symbols, if the current locale supports those.
3382  * - _: Pad a numeric result with spaces. This overrides the default padding
3383  *   for the specifier.
3384  * - -: Do not pad a numeric result. This overrides the default padding
3385  *   for the specifier.
3386  * - 0: Pad a numeric result with zeros. This overrides the default padding
3387  *   for the specifier.
3388  *
3389  * Additionally, when O is used with B, b, or h, it produces the alternative
3390  * form of a month name. The alternative form should be used when the month
3391  * name is used without a day number (e.g., standalone). It is required in
3392  * some languages (Baltic, Slavic, Greek, and more) due to their grammatical
3393  * rules. For other languages there is no difference. \%OB is a GNU and BSD
3394  * strftime() extension expected to be added to the future POSIX specification,
3395  * \%Ob and \%Oh are GNU strftime() extensions. Since: 2.56
3396  *
3397  * Returns: a newly allocated string formatted to the requested format
3398  *     or %NULL in the case that there was an error (such as a format specifier
3399  *     not being supported in the current locale). The string
3400  *     should be freed with g_free().
3401  *
3402  * Since: 2.26
3403  */
3404 gchar *
3405 g_date_time_format (GDateTime   *datetime,
3406                     const gchar *format)
3407 {
3408   GString  *outstr;
3409   const gchar *charset;
3410   /* Avoid conversions from locale charset to UTF-8 if charset is compatible
3411    * with UTF-8 already. Check for UTF-8 and synonymous canonical names of
3412    * ASCII. */
3413   gboolean locale_is_utf8_compatible = g_get_charset (&amp;charset) ||
3414     g_strcmp0 (&quot;ASCII&quot;, charset) == 0 ||
3415     g_strcmp0 (&quot;ANSI_X3.4-1968&quot;, charset) == 0;
3416 
3417   g_return_val_if_fail (datetime != NULL, NULL);
3418   g_return_val_if_fail (format != NULL, NULL);
3419   g_return_val_if_fail (g_utf8_validate (format, -1, NULL), NULL);
3420 
3421   outstr = g_string_sized_new (strlen (format) * 2);
3422 
3423   if (!g_date_time_format_utf8 (datetime, format, outstr,
3424                                 locale_is_utf8_compatible))
3425     {
3426       g_string_free (outstr, TRUE);
3427       return NULL;
3428     }
3429 
3430   return g_string_free (outstr, FALSE);
3431 }
3432 
3433 /**
3434  * g_date_time_format_iso8601:
3435  * @datetime: A #GDateTime
3436  *
3437  * Format @datetime in [ISO 8601 format](https://en.wikipedia.org/wiki/ISO_8601),
3438  * including the date, time and time zone, and return that as a UTF-8 encoded
3439  * string.
3440  *
3441  * Returns: a newly allocated string formatted in ISO 8601 format
3442  *     or %NULL in the case that there was an error. The string
3443  *     should be freed with g_free().
3444  * Since: 2.62
3445  */
3446 gchar *
3447 g_date_time_format_iso8601 (GDateTime *datetime)
3448 {
3449   GString *outstr = NULL;
3450   gchar *main_date = NULL;
3451   gint64 offset;
3452 
3453   /* Main date and time. */
3454   main_date = g_date_time_format (datetime, &quot;%Y-%m-%dT%H:%M:%S&quot;);
3455   outstr = g_string_new (main_date);
3456   g_free (main_date);
3457 
3458   /* Timezone. Format it as `%:::z` unless the offset is zero, in which case
3459    * we can simply use `Z`. */
3460   offset = g_date_time_get_utc_offset (datetime);
3461 
3462   if (offset == 0)
3463     {
3464       g_string_append_c (outstr, &#39;Z&#39;);
3465     }
3466   else
3467     {
3468       gchar *time_zone = g_date_time_format (datetime, &quot;%:::z&quot;);
3469       g_string_append (outstr, time_zone);
3470       g_free (time_zone);
3471     }
3472 
3473   return g_string_free (outstr, FALSE);
3474 }
3475 
3476 
3477 /* Epilogue {{{1 */
3478 /* vim:set foldmethod=marker: */
    </pre>
  </body>
</html>