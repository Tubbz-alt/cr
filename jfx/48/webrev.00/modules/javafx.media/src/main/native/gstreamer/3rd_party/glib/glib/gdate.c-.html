<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gdate.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;glibconfig.h&quot;
  31 
  32 #define DEBUG_MSG(x)    /* */
  33 #ifdef G_ENABLE_DEBUG
  34 /* #define DEBUG_MSG(args)  g_message args ; */
  35 #endif
  36 
  37 #include &lt;time.h&gt;
  38 #include &lt;string.h&gt;
  39 #include &lt;stdlib.h&gt;
  40 #include &lt;locale.h&gt;
  41 
  42 #ifdef G_OS_WIN32
  43 #include &lt;windows.h&gt;
  44 #endif
  45 
  46 #include &quot;gdate.h&quot;
  47 
  48 #include &quot;gconvert.h&quot;
  49 #include &quot;gmem.h&quot;
  50 #include &quot;gstrfuncs.h&quot;
  51 #include &quot;gtestutils.h&quot;
  52 #include &quot;gthread.h&quot;
  53 #include &quot;gunicode.h&quot;
  54 
  55 #ifdef G_OS_WIN32
  56 #include &quot;garray.h&quot;
  57 #endif
  58 
  59 /**
  60  * SECTION:date
  61  * @title: Date and Time Functions
  62  * @short_description: calendrical calculations and miscellaneous time stuff
  63  *
  64  * The #GDate data structure represents a day between January 1, Year 1,
  65  * and sometime a few thousand years in the future (right now it will go
  66  * to the year 65535 or so, but g_date_set_parse() only parses up to the
  67  * year 8000 or so - just count on &quot;a few thousand&quot;). #GDate is meant to
  68  * represent everyday dates, not astronomical dates or historical dates
  69  * or ISO timestamps or the like. It extrapolates the current Gregorian
  70  * calendar forward and backward in time; there is no attempt to change
  71  * the calendar to match time periods or locations. #GDate does not store
  72  * time information; it represents a day.
  73  *
  74  * The #GDate implementation has several nice features; it is only a
  75  * 64-bit struct, so storing large numbers of dates is very efficient. It
  76  * can keep both a Julian and day-month-year representation of the date,
  77  * since some calculations are much easier with one representation or the
  78  * other. A Julian representation is simply a count of days since some
  79  * fixed day in the past; for #GDate the fixed day is January 1, 1 AD.
  80  * (&quot;Julian&quot; dates in the #GDate API aren&#39;t really Julian dates in the
  81  * technical sense; technically, Julian dates count from the start of the
  82  * Julian period, Jan 1, 4713 BC).
  83  *
  84  * #GDate is simple to use. First you need a &quot;blank&quot; date; you can get a
  85  * dynamically allocated date from g_date_new(), or you can declare an
  86  * automatic variable or array and initialize it to a sane state by
  87  * calling g_date_clear(). A cleared date is sane; it&#39;s safe to call
  88  * g_date_set_dmy() and the other mutator functions to initialize the
  89  * value of a cleared date. However, a cleared date is initially
  90  * invalid, meaning that it doesn&#39;t represent a day that exists.
  91  * It is undefined to call any of the date calculation routines on an
  92  * invalid date. If you obtain a date from a user or other
  93  * unpredictable source, you should check its validity with the
  94  * g_date_valid() predicate. g_date_valid() is also used to check for
  95  * errors with g_date_set_parse() and other functions that can
  96  * fail. Dates can be invalidated by calling g_date_clear() again.
  97  *
  98  * It is very important to use the API to access the #GDate
  99  * struct. Often only the day-month-year or only the Julian
 100  * representation is valid. Sometimes neither is valid. Use the API.
 101  *
 102  * GLib also features #GDateTime which represents a precise time.
 103  */
 104 
 105 /**
 106  * G_USEC_PER_SEC:
 107  *
 108  * Number of microseconds in one second (1 million).
 109  * This macro is provided for code readability.
 110  */
 111 
 112 /**
 113  * GTimeVal:
 114  * @tv_sec: seconds
 115  * @tv_usec: microseconds
 116  *
 117  * Represents a precise time, with seconds and microseconds.
 118  * Similar to the struct timeval returned by the gettimeofday()
 119  * UNIX system call.
 120  *
 121  * GLib is attempting to unify around the use of 64bit integers to
 122  * represent microsecond-precision time. As such, this type will be
 123  * removed from a future version of GLib. A consequence of using `glong` for
 124  * `tv_sec` is that on 32-bit systems `GTimeVal` is subject to the year 2038
 125  * problem.
 126  */
 127 
 128 /**
 129  * GDate:
 130  * @julian_days: the Julian representation of the date
 131  * @julian: this bit is set if @julian_days is valid
 132  * @dmy: this is set if @day, @month and @year are valid
 133  * @day: the day of the day-month-year representation of the date,
 134  *     as a number between 1 and 31
 135  * @month: the day of the day-month-year representation of the date,
 136  *     as a number between 1 and 12
 137  * @year: the day of the day-month-year representation of the date
 138  *
 139  * Represents a day between January 1, Year 1 and a few thousand years in
 140  * the future. None of its members should be accessed directly.
 141  *
 142  * If the #GDate-struct is obtained from g_date_new(), it will be safe
 143  * to mutate but invalid and thus not safe for calendrical computations.
 144  *
 145  * If it&#39;s declared on the stack, it will contain garbage so must be
 146  * initialized with g_date_clear(). g_date_clear() makes the date invalid
 147  * but sane. An invalid date doesn&#39;t represent a day, it&#39;s &quot;empty.&quot; A date
 148  * becomes valid after you set it to a Julian day or you set a day, month,
 149  * and year.
 150  */
 151 
 152 /**
 153  * GTime:
 154  *
 155  * Simply a replacement for time_t. It has been deprecated
 156  * since it is not equivalent to time_t on 64-bit platforms
 157  * with a 64-bit time_t. Unrelated to #GTimer.
 158  *
 159  * Note that #GTime is defined to always be a 32-bit integer,
 160  * unlike time_t which may be 64-bit on some systems. Therefore,
 161  * #GTime will overflow in the year 2038, and you cannot use the
 162  * address of a #GTime variable as argument to the UNIX time()
 163  * function.
 164  *
 165  * Instead, do the following:
 166  * |[&lt;!-- language=&quot;C&quot; --&gt;
 167  * time_t ttime;
 168  * GTime gtime;
 169  *
 170  * time (&amp;ttime);
 171  * gtime = (GTime)ttime;
 172  * ]|
 173  */
 174 
 175 /**
 176  * GDateDMY:
 177  * @G_DATE_DAY: a day
 178  * @G_DATE_MONTH: a month
 179  * @G_DATE_YEAR: a year
 180  *
 181  * This enumeration isn&#39;t used in the API, but may be useful if you need
 182  * to mark a number as a day, month, or year.
 183  */
 184 
 185 /**
 186  * GDateDay:
 187  *
 188  * Integer representing a day of the month; between 1 and 31.
 189  * #G_DATE_BAD_DAY represents an invalid day of the month.
 190  */
 191 
 192 /**
 193  * GDateMonth:
 194  * @G_DATE_BAD_MONTH: invalid value
 195  * @G_DATE_JANUARY: January
 196  * @G_DATE_FEBRUARY: February
 197  * @G_DATE_MARCH: March
 198  * @G_DATE_APRIL: April
 199  * @G_DATE_MAY: May
 200  * @G_DATE_JUNE: June
 201  * @G_DATE_JULY: July
 202  * @G_DATE_AUGUST: August
 203  * @G_DATE_SEPTEMBER: September
 204  * @G_DATE_OCTOBER: October
 205  * @G_DATE_NOVEMBER: November
 206  * @G_DATE_DECEMBER: December
 207  *
 208  * Enumeration representing a month; values are #G_DATE_JANUARY,
 209  * #G_DATE_FEBRUARY, etc. #G_DATE_BAD_MONTH is the invalid value.
 210  */
 211 
 212 /**
 213  * GDateYear:
 214  *
 215  * Integer representing a year; #G_DATE_BAD_YEAR is the invalid
 216  * value. The year must be 1 or higher; negative (BC) years are not
 217  * allowed. The year is represented with four digits.
 218  */
 219 
 220 /**
 221  * GDateWeekday:
 222  * @G_DATE_BAD_WEEKDAY: invalid value
 223  * @G_DATE_MONDAY: Monday
 224  * @G_DATE_TUESDAY: Tuesday
 225  * @G_DATE_WEDNESDAY: Wednesday
 226  * @G_DATE_THURSDAY: Thursday
 227  * @G_DATE_FRIDAY: Friday
 228  * @G_DATE_SATURDAY: Saturday
 229  * @G_DATE_SUNDAY: Sunday
 230  *
 231  * Enumeration representing a day of the week; #G_DATE_MONDAY,
 232  * #G_DATE_TUESDAY, etc. #G_DATE_BAD_WEEKDAY is an invalid weekday.
 233  */
 234 
 235 /**
 236  * G_DATE_BAD_DAY:
 237  *
 238  * Represents an invalid #GDateDay.
 239  */
 240 
 241 /**
 242  * G_DATE_BAD_JULIAN:
 243  *
 244  * Represents an invalid Julian day number.
 245  */
 246 
 247 /**
 248  * G_DATE_BAD_YEAR:
 249  *
 250  * Represents an invalid year.
 251  */
 252 
 253 /**
 254  * g_date_new:
 255  *
 256  * Allocates a #GDate and initializes
 257  * it to a sane state. The new date will
 258  * be cleared (as if you&#39;d called g_date_clear()) but invalid (it won&#39;t
 259  * represent an existing day). Free the return value with g_date_free().
 260  *
 261  * Returns: a newly-allocated #GDate
 262  */
 263 GDate*
 264 g_date_new (void)
 265 {
 266   GDate *d = g_new0 (GDate, 1); /* happily, 0 is the invalid flag for everything. */
 267 
 268   return d;
 269 }
 270 
 271 /**
 272  * g_date_new_dmy:
 273  * @day: day of the month
 274  * @month: month of the year
 275  * @year: year
 276  *
 277  * Like g_date_new(), but also sets the value of the date. Assuming the
 278  * day-month-year triplet you pass in represents an existing day, the
 279  * returned date will be valid.
 280  *
 281  * Returns: a newly-allocated #GDate initialized with @day, @month, and @year
 282  */
 283 GDate*
 284 g_date_new_dmy (GDateDay   day,
 285                 GDateMonth m,
 286                 GDateYear  y)
 287 {
 288   GDate *d;
 289   g_return_val_if_fail (g_date_valid_dmy (day, m, y), NULL);
 290 
 291   d = g_new (GDate, 1);
 292 
 293   d-&gt;julian = FALSE;
 294   d-&gt;dmy    = TRUE;
 295 
 296   d-&gt;month = m;
 297   d-&gt;day   = day;
 298   d-&gt;year  = y;
 299 
 300   g_assert (g_date_valid (d));
 301 
 302   return d;
 303 }
 304 
 305 /**
 306  * g_date_new_julian:
 307  * @julian_day: days since January 1, Year 1
 308  *
 309  * Like g_date_new(), but also sets the value of the date. Assuming the
 310  * Julian day number you pass in is valid (greater than 0, less than an
 311  * unreasonably large number), the returned date will be valid.
 312  *
 313  * Returns: a newly-allocated #GDate initialized with @julian_day
 314  */
 315 GDate*
 316 g_date_new_julian (guint32 julian_day)
 317 {
 318   GDate *d;
 319   g_return_val_if_fail (g_date_valid_julian (julian_day), NULL);
 320 
 321   d = g_new (GDate, 1);
 322 
 323   d-&gt;julian = TRUE;
 324   d-&gt;dmy    = FALSE;
 325 
 326   d-&gt;julian_days = julian_day;
 327 
 328   g_assert (g_date_valid (d));
 329 
 330   return d;
 331 }
 332 
 333 /**
 334  * g_date_free:
 335  * @date: a #GDate to free
 336  *
 337  * Frees a #GDate returned from g_date_new().
 338  */
 339 void
 340 g_date_free (GDate *date)
 341 {
 342   g_return_if_fail (date != NULL);
 343 
 344   g_free (date);
 345 }
 346 
 347 /**
 348  * g_date_copy:
 349  * @date: a #GDate to copy
 350  *
 351  * Copies a GDate to a newly-allocated GDate. If the input was invalid
 352  * (as determined by g_date_valid()), the invalid state will be copied
 353  * as is into the new object.
 354  *
 355  * Returns: (transfer full): a newly-allocated #GDate initialized from @date
 356  *
 357  * Since: 2.56
 358  */
 359 GDate *
 360 g_date_copy (const GDate *date)
 361 {
 362   GDate *res;
 363   g_return_val_if_fail (date != NULL, NULL);
 364 
 365   if (g_date_valid (date))
 366     res = g_date_new_julian (g_date_get_julian (date));
 367   else
 368     {
 369       res = g_date_new ();
 370       *res = *date;
 371     }
 372 
 373   return res;
 374 }
 375 
 376 /**
 377  * g_date_valid:
 378  * @date: a #GDate to check
 379  *
 380  * Returns %TRUE if the #GDate represents an existing day. The date must not
 381  * contain garbage; it should have been initialized with g_date_clear()
 382  * if it wasn&#39;t allocated by one of the g_date_new() variants.
 383  *
 384  * Returns: Whether the date is valid
 385  */
 386 gboolean
 387 g_date_valid (const GDate *d)
 388 {
 389   g_return_val_if_fail (d != NULL, FALSE);
 390 
 391   return (d-&gt;julian || d-&gt;dmy);
 392 }
 393 
 394 static const guint8 days_in_months[2][13] =
 395 {  /* error, jan feb mar apr may jun jul aug sep oct nov dec */
 396   {  0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
 397   {  0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 } /* leap year */
 398 };
 399 
 400 static const guint16 days_in_year[2][14] =
 401 {  /* 0, jan feb mar apr may  jun  jul  aug  sep  oct  nov  dec */
 402   {  0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
 403   {  0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
 404 };
 405 
 406 /**
 407  * g_date_valid_month:
 408  * @month: month
 409  *
 410  * Returns %TRUE if the month value is valid. The 12 #GDateMonth
 411  * enumeration values are the only valid months.
 412  *
 413  * Returns: %TRUE if the month is valid
 414  */
 415 gboolean
 416 g_date_valid_month (GDateMonth m)
 417 {
 418   return ( (m &gt; G_DATE_BAD_MONTH) &amp;&amp; (m &lt; 13) );
 419 }
 420 
 421 /**
 422  * g_date_valid_year:
 423  * @year: year
 424  *
 425  * Returns %TRUE if the year is valid. Any year greater than 0 is valid,
 426  * though there is a 16-bit limit to what #GDate will understand.
 427  *
 428  * Returns: %TRUE if the year is valid
 429  */
 430 gboolean
 431 g_date_valid_year (GDateYear y)
 432 {
 433   return ( y &gt; G_DATE_BAD_YEAR );
 434 }
 435 
 436 /**
 437  * g_date_valid_day:
 438  * @day: day to check
 439  *
 440  * Returns %TRUE if the day of the month is valid (a day is valid if it&#39;s
 441  * between 1 and 31 inclusive).
 442  *
 443  * Returns: %TRUE if the day is valid
 444  */
 445 
 446 gboolean
 447 g_date_valid_day (GDateDay d)
 448 {
 449   return ( (d &gt; G_DATE_BAD_DAY) &amp;&amp; (d &lt; 32) );
 450 }
 451 
 452 /**
 453  * g_date_valid_weekday:
 454  * @weekday: weekday
 455  *
 456  * Returns %TRUE if the weekday is valid. The seven #GDateWeekday enumeration
 457  * values are the only valid weekdays.
 458  *
 459  * Returns: %TRUE if the weekday is valid
 460  */
 461 gboolean
 462 g_date_valid_weekday (GDateWeekday w)
 463 {
 464   return ( (w &gt; G_DATE_BAD_WEEKDAY) &amp;&amp; (w &lt; 8) );
 465 }
 466 
 467 /**
 468  * g_date_valid_julian:
 469  * @julian_date: Julian day to check
 470  *
 471  * Returns %TRUE if the Julian day is valid. Anything greater than zero
 472  * is basically a valid Julian, though there is a 32-bit limit.
 473  *
 474  * Returns: %TRUE if the Julian day is valid
 475  */
 476 gboolean
 477 g_date_valid_julian (guint32 j)
 478 {
 479   return (j &gt; G_DATE_BAD_JULIAN);
 480 }
 481 
 482 /**
 483  * g_date_valid_dmy:
 484  * @day: day
 485  * @month: month
 486  * @year: year
 487  *
 488  * Returns %TRUE if the day-month-year triplet forms a valid, existing day
 489  * in the range of days #GDate understands (Year 1 or later, no more than
 490  * a few thousand years in the future).
 491  *
 492  * Returns: %TRUE if the date is a valid one
 493  */
 494 gboolean
 495 g_date_valid_dmy (GDateDay   d,
 496                   GDateMonth m,
 497           GDateYear  y)
 498 {
 499   /* No need to check the upper bound of @y, because #GDateYear is 16 bits wide,
 500    * just like #GDate.year. */
 501   return ( (m &gt; G_DATE_BAD_MONTH) &amp;&amp;
 502            (m &lt; 13)               &amp;&amp;
 503            (d &gt; G_DATE_BAD_DAY)   &amp;&amp;
 504            (y &gt; G_DATE_BAD_YEAR)  &amp;&amp;   /* must check before using g_date_is_leap_year */
 505            (d &lt;=  (g_date_is_leap_year (y) ?
 506            days_in_months[1][m] : days_in_months[0][m])) );
 507 }
 508 
 509 
 510 /* &quot;Julian days&quot; just means an absolute number of days, where Day 1 ==
 511  *   Jan 1, Year 1
 512  */
 513 static void
 514 g_date_update_julian (const GDate *const_d)
 515 {
 516   GDate *d = (GDate *) const_d;
 517   GDateYear year;
 518   gint idx;
 519 
 520   g_return_if_fail (d != NULL);
 521   g_return_if_fail (d-&gt;dmy != 0);
 522   g_return_if_fail (!d-&gt;julian);
 523   g_return_if_fail (g_date_valid_dmy (d-&gt;day, d-&gt;month, d-&gt;year));
 524 
 525   /* What we actually do is: multiply years * 365 days in the year,
 526    * add the number of years divided by 4, subtract the number of
 527    * years divided by 100 and add the number of years divided by 400,
 528    * which accounts for leap year stuff. Code from Steffen Beyer&#39;s
 529    * DateCalc.
 530    */
 531 
 532   year = d-&gt;year - 1; /* we know d-&gt;year &gt; 0 since it&#39;s valid */
 533 
 534   d-&gt;julian_days = year * 365U;
 535   d-&gt;julian_days += (year &gt;&gt;= 2); /* divide by 4 and add */
 536   d-&gt;julian_days -= (year /= 25); /* divides original # years by 100 */
 537   d-&gt;julian_days += year &gt;&gt; 2;    /* divides by 4, which divides original by 400 */
 538 
 539   idx = g_date_is_leap_year (d-&gt;year) ? 1 : 0;
 540 
 541   d-&gt;julian_days += days_in_year[idx][d-&gt;month] + d-&gt;day;
 542 
 543   g_return_if_fail (g_date_valid_julian (d-&gt;julian_days));
 544 
 545   d-&gt;julian = TRUE;
 546 }
 547 
 548 static void
 549 g_date_update_dmy (const GDate *const_d)
 550 {
 551   GDate *d = (GDate *) const_d;
 552   GDateYear y;
 553   GDateMonth m;
 554   GDateDay day;
 555 
 556   guint32 A, B, C, D, E, M;
 557 
 558   g_return_if_fail (d != NULL);
 559   g_return_if_fail (d-&gt;julian);
 560   g_return_if_fail (!d-&gt;dmy);
 561   g_return_if_fail (g_date_valid_julian (d-&gt;julian_days));
 562 
 563   /* Formula taken from the Calendar FAQ; the formula was for the
 564    *  Julian Period which starts on 1 January 4713 BC, so we add
 565    *  1,721,425 to the number of days before doing the formula.
 566    *
 567    * I&#39;m sure this can be simplified for our 1 January 1 AD period
 568    * start, but I can&#39;t figure out how to unpack the formula.
 569    */
 570 
 571   A = d-&gt;julian_days + 1721425 + 32045;
 572   B = ( 4 *(A + 36524) )/ 146097 - 1;
 573   C = A - (146097 * B)/4;
 574   D = ( 4 * (C + 365) ) / 1461 - 1;
 575   E = C - ((1461*D) / 4);
 576   M = (5 * (E - 1) + 2)/153;
 577 
 578   m = M + 3 - (12*(M/10));
 579   day = E - (153*M + 2)/5;
 580   y = 100 * B + D - 4800 + (M/10);
 581 
 582 #ifdef G_ENABLE_DEBUG
 583   if (!g_date_valid_dmy (day, m, y))
 584     g_warning (&quot;OOPS julian: %u  computed dmy: %u %u %u&quot;,
 585            d-&gt;julian_days, day, m, y);
 586 #endif
 587 
 588   d-&gt;month = m;
 589   d-&gt;day   = day;
 590   d-&gt;year  = y;
 591 
 592   d-&gt;dmy = TRUE;
 593 }
 594 
 595 /**
 596  * g_date_get_weekday:
 597  * @date: a #GDate
 598  *
 599  * Returns the day of the week for a #GDate. The date must be valid.
 600  *
 601  * Returns: day of the week as a #GDateWeekday.
 602  */
 603 GDateWeekday
 604 g_date_get_weekday (const GDate *d)
 605 {
 606   g_return_val_if_fail (g_date_valid (d), G_DATE_BAD_WEEKDAY);
 607 
 608   if (!d-&gt;julian)
 609     g_date_update_julian (d);
 610 
 611   g_return_val_if_fail (d-&gt;julian, G_DATE_BAD_WEEKDAY);
 612 
 613   return ((d-&gt;julian_days - 1) % 7) + 1;
 614 }
 615 
 616 /**
 617  * g_date_get_month:
 618  * @date: a #GDate to get the month from
 619  *
 620  * Returns the month of the year. The date must be valid.
 621  *
 622  * Returns: month of the year as a #GDateMonth
 623  */
 624 GDateMonth
 625 g_date_get_month (const GDate *d)
 626 {
 627   g_return_val_if_fail (g_date_valid (d), G_DATE_BAD_MONTH);
 628 
 629   if (!d-&gt;dmy)
 630     g_date_update_dmy (d);
 631 
 632   g_return_val_if_fail (d-&gt;dmy, G_DATE_BAD_MONTH);
 633 
 634   return d-&gt;month;
 635 }
 636 
 637 /**
 638  * g_date_get_year:
 639  * @date: a #GDate
 640  *
 641  * Returns the year of a #GDate. The date must be valid.
 642  *
 643  * Returns: year in which the date falls
 644  */
 645 GDateYear
 646 g_date_get_year (const GDate *d)
 647 {
 648   g_return_val_if_fail (g_date_valid (d), G_DATE_BAD_YEAR);
 649 
 650   if (!d-&gt;dmy)
 651     g_date_update_dmy (d);
 652 
 653   g_return_val_if_fail (d-&gt;dmy, G_DATE_BAD_YEAR);
 654 
 655   return d-&gt;year;
 656 }
 657 
 658 /**
 659  * g_date_get_day:
 660  * @date: a #GDate to extract the day of the month from
 661  *
 662  * Returns the day of the month. The date must be valid.
 663  *
 664  * Returns: day of the month
 665  */
 666 GDateDay
 667 g_date_get_day (const GDate *d)
 668 {
 669   g_return_val_if_fail (g_date_valid (d), G_DATE_BAD_DAY);
 670 
 671   if (!d-&gt;dmy)
 672     g_date_update_dmy (d);
 673 
 674   g_return_val_if_fail (d-&gt;dmy, G_DATE_BAD_DAY);
 675 
 676   return d-&gt;day;
 677 }
 678 
 679 /**
 680  * g_date_get_julian:
 681  * @date: a #GDate to extract the Julian day from
 682  *
 683  * Returns the Julian day or &quot;serial number&quot; of the #GDate. The
 684  * Julian day is simply the number of days since January 1, Year 1; i.e.,
 685  * January 1, Year 1 is Julian day 1; January 2, Year 1 is Julian day 2,
 686  * etc. The date must be valid.
 687  *
 688  * Returns: Julian day
 689  */
 690 guint32
 691 g_date_get_julian (const GDate *d)
 692 {
 693   g_return_val_if_fail (g_date_valid (d), G_DATE_BAD_JULIAN);
 694 
 695   if (!d-&gt;julian)
 696     g_date_update_julian (d);
 697 
 698   g_return_val_if_fail (d-&gt;julian, G_DATE_BAD_JULIAN);
 699 
 700   return d-&gt;julian_days;
 701 }
 702 
 703 /**
 704  * g_date_get_day_of_year:
 705  * @date: a #GDate to extract day of year from
 706  *
 707  * Returns the day of the year, where Jan 1 is the first day of the
 708  * year. The date must be valid.
 709  *
 710  * Returns: day of the year
 711  */
 712 guint
 713 g_date_get_day_of_year (const GDate *d)
 714 {
 715   gint idx;
 716 
 717   g_return_val_if_fail (g_date_valid (d), 0);
 718 
 719   if (!d-&gt;dmy)
 720     g_date_update_dmy (d);
 721 
 722   g_return_val_if_fail (d-&gt;dmy, 0);
 723 
 724   idx = g_date_is_leap_year (d-&gt;year) ? 1 : 0;
 725 
 726   return (days_in_year[idx][d-&gt;month] + d-&gt;day);
 727 }
 728 
 729 /**
 730  * g_date_get_monday_week_of_year:
 731  * @date: a #GDate
 732  *
 733  * Returns the week of the year, where weeks are understood to start on
 734  * Monday. If the date is before the first Monday of the year, return 0.
 735  * The date must be valid.
 736  *
 737  * Returns: week of the year
 738  */
 739 guint
 740 g_date_get_monday_week_of_year (const GDate *d)
 741 {
 742   GDateWeekday wd;
 743   guint day;
 744   GDate first;
 745 
 746   g_return_val_if_fail (g_date_valid (d), 0);
 747 
 748   if (!d-&gt;dmy)
 749     g_date_update_dmy (d);
 750 
 751   g_return_val_if_fail (d-&gt;dmy, 0);
 752 
 753   g_date_clear (&amp;first, 1);
 754 
 755   g_date_set_dmy (&amp;first, 1, 1, d-&gt;year);
 756 
 757   wd = g_date_get_weekday (&amp;first) - 1; /* make Monday day 0 */
 758   day = g_date_get_day_of_year (d) - 1;
 759 
 760   return ((day + wd)/7U + (wd == 0 ? 1 : 0));
 761 }
 762 
 763 /**
 764  * g_date_get_sunday_week_of_year:
 765  * @date: a #GDate
 766  *
 767  * Returns the week of the year during which this date falls, if
 768  * weeks are understood to begin on Sunday. The date must be valid.
 769  * Can return 0 if the day is before the first Sunday of the year.
 770  *
 771  * Returns: week number
 772  */
 773 guint
 774 g_date_get_sunday_week_of_year (const GDate *d)
 775 {
 776   GDateWeekday wd;
 777   guint day;
 778   GDate first;
 779 
 780   g_return_val_if_fail (g_date_valid (d), 0);
 781 
 782   if (!d-&gt;dmy)
 783     g_date_update_dmy (d);
 784 
 785   g_return_val_if_fail (d-&gt;dmy, 0);
 786 
 787   g_date_clear (&amp;first, 1);
 788 
 789   g_date_set_dmy (&amp;first, 1, 1, d-&gt;year);
 790 
 791   wd = g_date_get_weekday (&amp;first);
 792   if (wd == 7) wd = 0; /* make Sunday day 0 */
 793   day = g_date_get_day_of_year (d) - 1;
 794 
 795   return ((day + wd)/7U + (wd == 0 ? 1 : 0));
 796 }
 797 
 798 /**
 799  * g_date_get_iso8601_week_of_year:
 800  * @date: a valid #GDate
 801  *
 802  * Returns the week of the year, where weeks are interpreted according
 803  * to ISO 8601.
 804  *
 805  * Returns: ISO 8601 week number of the year.
 806  *
 807  * Since: 2.6
 808  **/
 809 guint
 810 g_date_get_iso8601_week_of_year (const GDate *d)
 811 {
 812   guint j, d4, L, d1, w;
 813 
 814   g_return_val_if_fail (g_date_valid (d), 0);
 815 
 816   if (!d-&gt;julian)
 817     g_date_update_julian (d);
 818 
 819   g_return_val_if_fail (d-&gt;julian, 0);
 820 
 821   /* Formula taken from the Calendar FAQ; the formula was for the
 822    * Julian Period which starts on 1 January 4713 BC, so we add
 823    * 1,721,425 to the number of days before doing the formula.
 824    */
 825   j  = d-&gt;julian_days + 1721425;
 826   d4 = (j + 31741 - (j % 7)) % 146097 % 36524 % 1461;
 827   L  = d4 / 1460;
 828   d1 = ((d4 - L) % 365) + L;
 829   w  = d1 / 7 + 1;
 830 
 831   return w;
 832 }
 833 
 834 /**
 835  * g_date_days_between:
 836  * @date1: the first date
 837  * @date2: the second date
 838  *
 839  * Computes the number of days between two dates.
 840  * If @date2 is prior to @date1, the returned value is negative.
 841  * Both dates must be valid.
 842  *
 843  * Returns: the number of days between @date1 and @date2
 844  */
 845 gint
 846 g_date_days_between (const GDate *d1,
 847              const GDate *d2)
 848 {
 849   g_return_val_if_fail (g_date_valid (d1), 0);
 850   g_return_val_if_fail (g_date_valid (d2), 0);
 851 
 852   return (gint)g_date_get_julian (d2) - (gint)g_date_get_julian (d1);
 853 }
 854 
 855 /**
 856  * g_date_clear:
 857  * @date: pointer to one or more dates to clear
 858  * @n_dates: number of dates to clear
 859  *
 860  * Initializes one or more #GDate structs to a sane but invalid
 861  * state. The cleared dates will not represent an existing date, but will
 862  * not contain garbage. Useful to init a date declared on the stack.
 863  * Validity can be tested with g_date_valid().
 864  */
 865 void
 866 g_date_clear (GDate *d, guint ndates)
 867 {
 868   g_return_if_fail (d != NULL);
 869   g_return_if_fail (ndates != 0);
 870 
 871   memset (d, 0x0, ndates*sizeof (GDate));
 872 }
 873 
 874 G_LOCK_DEFINE_STATIC (g_date_global);
 875 
 876 /* These are for the parser, output to the user should use *
 877  * g_date_strftime () - this creates more never-freed memory to annoy
 878  * all those memory debugger users. :-)
 879  */
 880 
 881 static gchar *long_month_names[13] =
 882 {
 883   NULL,
 884 };
 885 
 886 static gchar *long_month_names_alternative[13] =
 887 {
 888   NULL,
 889 };
 890 
 891 static gchar *short_month_names[13] =
 892 {
 893   NULL,
 894 };
 895 
 896 static gchar *short_month_names_alternative[13] =
 897 {
 898   NULL,
 899 };
 900 
 901 /* This tells us if we need to update the parse info */
 902 static gchar *current_locale = NULL;
 903 
 904 /* order of these in the current locale */
 905 static GDateDMY dmy_order[3] =
 906 {
 907    G_DATE_DAY, G_DATE_MONTH, G_DATE_YEAR
 908 };
 909 
 910 /* Where to chop two-digit years: i.e., for the 1930 default, numbers
 911  * 29 and below are counted as in the year 2000, numbers 30 and above
 912  * are counted as in the year 1900.
 913  */
 914 
 915 static const GDateYear twodigit_start_year = 1930;
 916 
 917 /* It is impossible to enter a year between 1 AD and 99 AD with this
 918  * in effect.
 919  */
 920 static gboolean using_twodigit_years = FALSE;
 921 
 922 /* Adjustment of locale era to AD, non-zero means using locale era
 923  */
 924 static gint locale_era_adjust = 0;
 925 
 926 struct _GDateParseTokens {
 927   gint num_ints;
 928   gint n[3];
 929   guint month;
 930 };
 931 
 932 typedef struct _GDateParseTokens GDateParseTokens;
 933 
 934 static inline gboolean
 935 update_month_match (gsize *longest,
 936                     const gchar *haystack,
 937                     const gchar *needle)
 938 {
 939   gsize length;
 940 
 941   if (needle == NULL)
 942     return FALSE;
 943 
 944   length = strlen (needle);
 945   if (*longest &gt;= length)
 946     return FALSE;
 947 
 948   if (strstr (haystack, needle) == NULL)
 949     return FALSE;
 950 
 951   *longest = length;
 952   return TRUE;
 953 }
 954 
 955 #define NUM_LEN 10
 956 
 957 /* HOLDS: g_date_global_lock */
 958 static void
 959 g_date_fill_parse_tokens (const gchar *str, GDateParseTokens *pt)
 960 {
 961   gchar num[4][NUM_LEN+1];
 962   gint i;
 963   const guchar *s;
 964 
 965   /* We count 4, but store 3; so we can give an error
 966    * if there are 4.
 967    */
 968   num[0][0] = num[1][0] = num[2][0] = num[3][0] = &#39;\0&#39;;
 969 
 970   s = (const guchar *) str;
 971   pt-&gt;num_ints = 0;
 972   while (*s &amp;&amp; pt-&gt;num_ints &lt; 4)
 973     {
 974 
 975       i = 0;
 976       while (*s &amp;&amp; g_ascii_isdigit (*s) &amp;&amp; i &lt; NUM_LEN)
 977         {
 978           num[pt-&gt;num_ints][i] = *s;
 979           ++s;
 980           ++i;
 981         }
 982 
 983       if (i &gt; 0)
 984         {
 985           num[pt-&gt;num_ints][i] = &#39;\0&#39;;
 986           ++(pt-&gt;num_ints);
 987         }
 988 
 989       if (*s == &#39;\0&#39;) break;
 990 
 991       ++s;
 992     }
 993 
 994   pt-&gt;n[0] = pt-&gt;num_ints &gt; 0 ? atoi (num[0]) : 0;
 995   pt-&gt;n[1] = pt-&gt;num_ints &gt; 1 ? atoi (num[1]) : 0;
 996   pt-&gt;n[2] = pt-&gt;num_ints &gt; 2 ? atoi (num[2]) : 0;
 997 
 998   pt-&gt;month = G_DATE_BAD_MONTH;
 999 
1000   if (pt-&gt;num_ints &lt; 3)
1001     {
1002       gsize longest = 0;
1003       gchar *casefold;
1004       gchar *normalized;
1005 
1006       casefold = g_utf8_casefold (str, -1);
1007       normalized = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
1008       g_free (casefold);
1009 
1010       for (i = 1; i &lt; 13; ++i)
1011         {
1012           /* Here month names may be in a genitive case if the language
1013            * grammatical rules require it.
1014            * Examples of how January may look in some languages:
1015            * Catalan: &quot;de gener&quot;, Croatian: &quot;gener&quot;, Polish: &quot;gener&quot;,
1016            * Upper Sorbian: &quot;januara&quot;.
1017            * Note that most of the languages can&#39;t or don&#39;t use the the
1018            * genitive case here so they use nominative everywhere.
1019            * For example, English always uses &quot;January&quot;.
1020            */
1021           if (update_month_match (&amp;longest, normalized, long_month_names[i]))
1022                   pt-&gt;month = i;
1023 
1024           /* Here month names will be in a nominative case.
1025            * Examples of how January may look in some languages:
1026            * Catalan: &quot;gener&quot;, Croatian: &quot;gener&quot;, Polish: &quot;gener&quot;,
1027            * Upper Sorbian: &quot;Januar&quot;.
1028            */
1029           if (update_month_match (&amp;longest, normalized, long_month_names_alternative[i]))
1030                   pt-&gt;month = i;
1031 
1032           /* Differences between abbreviated nominative and abbreviated
1033            * genitive month names are visible in very few languages but
1034            * let&#39;s handle them.
1035            */
1036           if (update_month_match (&amp;longest, normalized, short_month_names[i]))
1037                   pt-&gt;month = i;
1038 
1039           if (update_month_match (&amp;longest, normalized, short_month_names_alternative[i]))
1040                   pt-&gt;month = i;
1041                 }
1042 
1043       g_free (normalized);
1044     }
1045 }
1046 
1047 /* HOLDS: g_date_global_lock */
1048 static void
1049 g_date_prepare_to_parse (const gchar      *str,
1050                          GDateParseTokens *pt)
1051 {
1052   const gchar *locale = setlocale (LC_TIME, NULL);
1053   gboolean recompute_localeinfo = FALSE;
1054   GDate d;
1055 
1056   g_return_if_fail (locale != NULL); /* should not happen */
1057 
1058   g_date_clear (&amp;d, 1);              /* clear for scratch use */
1059 
1060   if ( (current_locale == NULL) || (strcmp (locale, current_locale) != 0) )
1061     recompute_localeinfo = TRUE;  /* Uh, there used to be a reason for the temporary */
1062 
1063   if (recompute_localeinfo)
1064     {
1065       int i = 1;
1066       GDateParseTokens testpt;
1067       gchar buf[128];
1068 
1069       g_free (current_locale); /* still works if current_locale == NULL */
1070 
1071       current_locale = g_strdup (locale);
1072 
1073       short_month_names[0] = &quot;Error&quot;;
1074       long_month_names[0] = &quot;Error&quot;;
1075 
1076       while (i &lt; 13)
1077         {
1078       gchar *casefold;
1079 
1080           g_date_set_dmy (&amp;d, 1, i, 1976);
1081 
1082           g_return_if_fail (g_date_valid (&amp;d));
1083 
1084           g_date_strftime (buf, 127, &quot;%b&quot;, &amp;d);
1085 
1086       casefold = g_utf8_casefold (buf, -1);
1087           g_free (short_month_names[i]);
1088           short_month_names[i] = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
1089       g_free (casefold);
1090 
1091           g_date_strftime (buf, 127, &quot;%B&quot;, &amp;d);
1092       casefold = g_utf8_casefold (buf, -1);
1093           g_free (long_month_names[i]);
1094           long_month_names[i] = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
1095       g_free (casefold);
1096 
1097           g_date_strftime (buf, 127, &quot;%Ob&quot;, &amp;d);
1098           casefold = g_utf8_casefold (buf, -1);
1099           g_free (short_month_names_alternative[i]);
1100           short_month_names_alternative[i] = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
1101           g_free (casefold);
1102 
1103           g_date_strftime (buf, 127, &quot;%OB&quot;, &amp;d);
1104           casefold = g_utf8_casefold (buf, -1);
1105           g_free (long_month_names_alternative[i]);
1106           long_month_names_alternative[i] = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
1107           g_free (casefold);
1108 
1109           ++i;
1110         }
1111 
1112       /* Determine DMY order */
1113 
1114       /* had to pick a random day - don&#39;t change this, some strftimes
1115        * are broken on some days, and this one is good so far. */
1116       g_date_set_dmy (&amp;d, 4, 7, 1976);
1117 
1118       g_date_strftime (buf, 127, &quot;%x&quot;, &amp;d);
1119 
1120       g_date_fill_parse_tokens (buf, &amp;testpt);
1121 
1122       using_twodigit_years = FALSE;
1123       locale_era_adjust = 0;
1124       dmy_order[0] = G_DATE_DAY;
1125       dmy_order[1] = G_DATE_MONTH;
1126       dmy_order[2] = G_DATE_YEAR;
1127 
1128       i = 0;
1129       while (i &lt; testpt.num_ints)
1130         {
1131           switch (testpt.n[i])
1132             {
1133             case 7:
1134               dmy_order[i] = G_DATE_MONTH;
1135               break;
1136             case 4:
1137               dmy_order[i] = G_DATE_DAY;
1138               break;
1139             case 76:
1140               using_twodigit_years = TRUE; /* FALL THRU */
1141             case 1976:
1142               dmy_order[i] = G_DATE_YEAR;
1143               break;
1144             default:
1145               /* assume locale era */
1146               locale_era_adjust = 1976 - testpt.n[i];
1147               dmy_order[i] = G_DATE_YEAR;
1148               break;
1149             }
1150           ++i;
1151         }
1152 
1153 #if defined(G_ENABLE_DEBUG) &amp;&amp; 0
1154       DEBUG_MSG ((&quot;**GDate prepared a new set of locale-specific parse rules.&quot;));
1155       i = 1;
1156       while (i &lt; 13)
1157         {
1158           DEBUG_MSG ((&quot;  %s   %s&quot;, long_month_names[i], short_month_names[i]));
1159           ++i;
1160         }
1161       DEBUG_MSG ((&quot;Alternative month names:&quot;));
1162       i = 1;
1163       while (i &lt; 13)
1164         {
1165           DEBUG_MSG ((&quot;  %s   %s&quot;, long_month_names_alternative[i], short_month_names_alternative[i]));
1166           ++i;
1167         }
1168       if (using_twodigit_years)
1169         {
1170       DEBUG_MSG ((&quot;**Using twodigit years with cutoff year: %u&quot;, twodigit_start_year));
1171         }
1172       {
1173         gchar *strings[3];
1174         i = 0;
1175         while (i &lt; 3)
1176           {
1177             switch (dmy_order[i])
1178               {
1179               case G_DATE_MONTH:
1180                 strings[i] = &quot;Month&quot;;
1181                 break;
1182               case G_DATE_YEAR:
1183                 strings[i] = &quot;Year&quot;;
1184                 break;
1185               case G_DATE_DAY:
1186                 strings[i] = &quot;Day&quot;;
1187                 break;
1188               default:
1189                 strings[i] = NULL;
1190                 break;
1191               }
1192             ++i;
1193           }
1194         DEBUG_MSG ((&quot;**Order: %s, %s, %s&quot;, strings[0], strings[1], strings[2]));
1195         DEBUG_MSG ((&quot;**Sample date in this locale: &#39;%s&#39;&quot;, buf));
1196       }
1197 #endif
1198     }
1199 
1200   g_date_fill_parse_tokens (str, pt);
1201 }
1202 
1203 /**
1204  * g_date_set_parse:
1205  * @date: a #GDate to fill in
1206  * @str: string to parse
1207  *
1208  * Parses a user-inputted string @str, and try to figure out what date it
1209  * represents, taking the [current locale][setlocale] into account. If the
1210  * string is successfully parsed, the date will be valid after the call.
1211  * Otherwise, it will be invalid. You should check using g_date_valid()
1212  * to see whether the parsing succeeded.
1213  *
1214  * This function is not appropriate for file formats and the like; it
1215  * isn&#39;t very precise, and its exact behavior varies with the locale.
1216  * It&#39;s intended to be a heuristic routine that guesses what the user
1217  * means by a given string (and it does work pretty well in that
1218  * capacity).
1219  */
1220 void
1221 g_date_set_parse (GDate       *d,
1222                   const gchar *str)
1223 {
1224   GDateParseTokens pt;
1225   guint m = G_DATE_BAD_MONTH, day = G_DATE_BAD_DAY, y = G_DATE_BAD_YEAR;
1226 
1227   g_return_if_fail (d != NULL);
1228 
1229   /* set invalid */
1230   g_date_clear (d, 1);
1231 
1232   G_LOCK (g_date_global);
1233 
1234   g_date_prepare_to_parse (str, &amp;pt);
1235 
1236   DEBUG_MSG ((&quot;Found %d ints, &#39;%d&#39; &#39;%d&#39; &#39;%d&#39; and written out month %d&quot;,
1237           pt.num_ints, pt.n[0], pt.n[1], pt.n[2], pt.month));
1238 
1239 
1240   if (pt.num_ints == 4)
1241     {
1242       G_UNLOCK (g_date_global);
1243       return; /* presumably a typo; bail out. */
1244     }
1245 
1246   if (pt.num_ints &gt; 1)
1247     {
1248       int i = 0;
1249       int j = 0;
1250 
1251       g_assert (pt.num_ints &lt; 4); /* i.e., it is 2 or 3 */
1252 
1253       while (i &lt; pt.num_ints &amp;&amp; j &lt; 3)
1254         {
1255           switch (dmy_order[j])
1256             {
1257             case G_DATE_MONTH:
1258         {
1259           if (pt.num_ints == 2 &amp;&amp; pt.month != G_DATE_BAD_MONTH)
1260         {
1261           m = pt.month;
1262           ++j;      /* skip months, but don&#39;t skip this number */
1263           continue;
1264         }
1265           else
1266         m = pt.n[i];
1267         }
1268         break;
1269             case G_DATE_DAY:
1270         {
1271           if (pt.num_ints == 2 &amp;&amp; pt.month == G_DATE_BAD_MONTH)
1272         {
1273           day = 1;
1274           ++j;      /* skip days, since we may have month/year */
1275           continue;
1276         }
1277           day = pt.n[i];
1278         }
1279         break;
1280             case G_DATE_YEAR:
1281         {
1282           y  = pt.n[i];
1283 
1284           if (locale_era_adjust != 0)
1285             {
1286           y += locale_era_adjust;
1287             }
1288           else if (using_twodigit_years &amp;&amp; y &lt; 100)
1289         {
1290           guint two     =  twodigit_start_year % 100;
1291           guint century = (twodigit_start_year / 100) * 100;
1292 
1293           if (y &lt; two)
1294             century += 100;
1295 
1296           y += century;
1297         }
1298         }
1299         break;
1300             default:
1301               break;
1302             }
1303 
1304           ++i;
1305           ++j;
1306         }
1307 
1308 
1309       if (pt.num_ints == 3 &amp;&amp; !g_date_valid_dmy (day, m, y))
1310         {
1311           /* Try YYYY MM DD */
1312           y   = pt.n[0];
1313           m   = pt.n[1];
1314           day = pt.n[2];
1315 
1316           if (using_twodigit_years &amp;&amp; y &lt; 100)
1317             y = G_DATE_BAD_YEAR; /* avoids ambiguity */
1318         }
1319       else if (pt.num_ints == 2)
1320     {
1321       if (m == G_DATE_BAD_MONTH &amp;&amp; pt.month != G_DATE_BAD_MONTH)
1322         m = pt.month;
1323     }
1324     }
1325   else if (pt.num_ints == 1)
1326     {
1327       if (pt.month != G_DATE_BAD_MONTH)
1328         {
1329           /* Month name and year? */
1330           m    = pt.month;
1331           day  = 1;
1332           y = pt.n[0];
1333         }
1334       else
1335         {
1336           /* Try yyyymmdd and yymmdd */
1337 
1338           m   = (pt.n[0]/100) % 100;
1339           day = pt.n[0] % 100;
1340           y   = pt.n[0]/10000;
1341 
1342           /* FIXME move this into a separate function */
1343           if (using_twodigit_years &amp;&amp; y &lt; 100)
1344             {
1345               guint two     =  twodigit_start_year % 100;
1346               guint century = (twodigit_start_year / 100) * 100;
1347 
1348               if (y &lt; two)
1349                 century += 100;
1350 
1351               y += century;
1352             }
1353         }
1354     }
1355 
1356   /* See if we got anything valid out of all this. */
1357   /* y &lt; 8000 is to catch 19998 style typos; the library is OK up to 65535 or so */
1358   if (y &lt; 8000 &amp;&amp; g_date_valid_dmy (day, m, y))
1359     {
1360       d-&gt;month = m;
1361       d-&gt;day   = day;
1362       d-&gt;year  = y;
1363       d-&gt;dmy   = TRUE;
1364     }
1365 #ifdef G_ENABLE_DEBUG
1366   else
1367     {
1368       DEBUG_MSG ((&quot;Rejected DMY %u %u %u&quot;, day, m, y));
1369     }
1370 #endif
1371   G_UNLOCK (g_date_global);
1372 }
1373 
1374 /**
1375  * g_date_set_time_t:
1376  * @date: a #GDate
1377  * @timet: time_t value to set
1378  *
1379  * Sets the value of a date to the date corresponding to a time
1380  * specified as a time_t. The time to date conversion is done using
1381  * the user&#39;s current timezone.
1382  *
1383  * To set the value of a date to the current day, you could write:
1384  * |[&lt;!-- language=&quot;C&quot; --&gt;
1385  *  time_t now = time (NULL);
1386  *  if (now == (time_t) -1)
1387  *    // handle the error
1388  *  g_date_set_time_t (date, now);
1389  * ]|
1390  *
1391  * Since: 2.10
1392  */
1393 void
1394 g_date_set_time_t (GDate *date,
1395            time_t timet)
1396 {
1397   struct tm tm;
1398 
1399   g_return_if_fail (date != NULL);
1400 
1401 #ifdef HAVE_LOCALTIME_R
1402   localtime_r (&amp;timet, &amp;tm);
1403 #else
1404   {
1405     struct tm *ptm = localtime (&amp;timet);
1406 
1407     if (ptm == NULL)
1408       {
1409     /* Happens at least in Microsoft&#39;s C library if you pass a
1410      * negative time_t. Use 2000-01-01 as default date.
1411      */
1412 #ifndef G_DISABLE_CHECKS
1413     g_return_if_fail_warning (G_LOG_DOMAIN, &quot;g_date_set_time&quot;, &quot;ptm != NULL&quot;);
1414 #endif
1415 
1416     tm.tm_mon = 0;
1417     tm.tm_mday = 1;
1418     tm.tm_year = 100;
1419       }
1420     else
1421       memcpy ((void *) &amp;tm, (void *) ptm, sizeof(struct tm));
1422   }
1423 #endif
1424 
1425   date-&gt;julian = FALSE;
1426 
1427   date-&gt;month = tm.tm_mon + 1;
1428   date-&gt;day   = tm.tm_mday;
1429   date-&gt;year  = tm.tm_year + 1900;
1430 
1431   g_return_if_fail (g_date_valid_dmy (date-&gt;day, date-&gt;month, date-&gt;year));
1432 
1433   date-&gt;dmy    = TRUE;
1434 }
1435 
1436 
1437 /**
1438  * g_date_set_time:
1439  * @date: a #GDate.
1440  * @time_: #GTime value to set.
1441  *
1442  * Sets the value of a date from a #GTime value.
1443  * The time to date conversion is done using the user&#39;s current timezone.
1444  *
1445  * Deprecated: 2.10: Use g_date_set_time_t() instead.
1446  */
1447 void
1448 g_date_set_time (GDate *date,
1449          GTime  time_)
1450 {
1451   g_date_set_time_t (date, (time_t) time_);
1452 }
1453 
1454 /**
1455  * g_date_set_time_val:
1456  * @date: a #GDate
1457  * @timeval: #GTimeVal value to set
1458  *
1459  * Sets the value of a date from a #GTimeVal value.  Note that the
1460  * @tv_usec member is ignored, because #GDate can&#39;t make use of the
1461  * additional precision.
1462  *
1463  * The time to date conversion is done using the user&#39;s current timezone.
1464  *
1465  * Since: 2.10
1466  */
1467 void
1468 g_date_set_time_val (GDate    *date,
1469              GTimeVal *timeval)
1470 {
1471   g_date_set_time_t (date, (time_t) timeval-&gt;tv_sec);
1472 }
1473 
1474 /**
1475  * g_date_set_month:
1476  * @date: a #GDate
1477  * @month: month to set
1478  *
1479  * Sets the month of the year for a #GDate.  If the resulting
1480  * day-month-year triplet is invalid, the date will be invalid.
1481  */
1482 void
1483 g_date_set_month (GDate     *d,
1484                   GDateMonth m)
1485 {
1486   g_return_if_fail (d != NULL);
1487   g_return_if_fail (g_date_valid_month (m));
1488 
1489   if (d-&gt;julian &amp;&amp; !d-&gt;dmy) g_date_update_dmy(d);
1490   d-&gt;julian = FALSE;
1491 
1492   d-&gt;month = m;
1493 
1494   if (g_date_valid_dmy (d-&gt;day, d-&gt;month, d-&gt;year))
1495     d-&gt;dmy = TRUE;
1496   else
1497     d-&gt;dmy = FALSE;
1498 }
1499 
1500 /**
1501  * g_date_set_day:
1502  * @date: a #GDate
1503  * @day: day to set
1504  *
1505  * Sets the day of the month for a #GDate. If the resulting
1506  * day-month-year triplet is invalid, the date will be invalid.
1507  */
1508 void
1509 g_date_set_day (GDate    *d,
1510                 GDateDay  day)
1511 {
1512   g_return_if_fail (d != NULL);
1513   g_return_if_fail (g_date_valid_day (day));
1514 
1515   if (d-&gt;julian &amp;&amp; !d-&gt;dmy) g_date_update_dmy(d);
1516   d-&gt;julian = FALSE;
1517 
1518   d-&gt;day = day;
1519 
1520   if (g_date_valid_dmy (d-&gt;day, d-&gt;month, d-&gt;year))
1521     d-&gt;dmy = TRUE;
1522   else
1523     d-&gt;dmy = FALSE;
1524 }
1525 
1526 /**
1527  * g_date_set_year:
1528  * @date: a #GDate
1529  * @year: year to set
1530  *
1531  * Sets the year for a #GDate. If the resulting day-month-year
1532  * triplet is invalid, the date will be invalid.
1533  */
1534 void
1535 g_date_set_year (GDate     *d,
1536                  GDateYear  y)
1537 {
1538   g_return_if_fail (d != NULL);
1539   g_return_if_fail (g_date_valid_year (y));
1540 
1541   if (d-&gt;julian &amp;&amp; !d-&gt;dmy) g_date_update_dmy(d);
1542   d-&gt;julian = FALSE;
1543 
1544   d-&gt;year = y;
1545 
1546   if (g_date_valid_dmy (d-&gt;day, d-&gt;month, d-&gt;year))
1547     d-&gt;dmy = TRUE;
1548   else
1549     d-&gt;dmy = FALSE;
1550 }
1551 
1552 /**
1553  * g_date_set_dmy:
1554  * @date: a #GDate
1555  * @day: day
1556  * @month: month
1557  * @y: year
1558  *
1559  * Sets the value of a #GDate from a day, month, and year.
1560  * The day-month-year triplet must be valid; if you aren&#39;t
1561  * sure it is, call g_date_valid_dmy() to check before you
1562  * set it.
1563  */
1564 void
1565 g_date_set_dmy (GDate      *d,
1566                 GDateDay    day,
1567                 GDateMonth  m,
1568                 GDateYear   y)
1569 {
1570   g_return_if_fail (d != NULL);
1571   g_return_if_fail (g_date_valid_dmy (day, m, y));
1572 
1573   d-&gt;julian = FALSE;
1574 
1575   d-&gt;month = m;
1576   d-&gt;day   = day;
1577   d-&gt;year  = y;
1578 
1579   d-&gt;dmy = TRUE;
1580 }
1581 
1582 /**
1583  * g_date_set_julian:
1584  * @date: a #GDate
1585  * @julian_date: Julian day number (days since January 1, Year 1)
1586  *
1587  * Sets the value of a #GDate from a Julian day number.
1588  */
1589 void
1590 g_date_set_julian (GDate   *d,
1591                    guint32  j)
1592 {
1593   g_return_if_fail (d != NULL);
1594   g_return_if_fail (g_date_valid_julian (j));
1595 
1596   d-&gt;julian_days = j;
1597   d-&gt;julian = TRUE;
1598   d-&gt;dmy = FALSE;
1599 }
1600 
1601 /**
1602  * g_date_is_first_of_month:
1603  * @date: a #GDate to check
1604  *
1605  * Returns %TRUE if the date is on the first of a month.
1606  * The date must be valid.
1607  *
1608  * Returns: %TRUE if the date is the first of the month
1609  */
1610 gboolean
1611 g_date_is_first_of_month (const GDate *d)
1612 {
1613   g_return_val_if_fail (g_date_valid (d), FALSE);
1614 
1615   if (!d-&gt;dmy)
1616     g_date_update_dmy (d);
1617 
1618   g_return_val_if_fail (d-&gt;dmy, FALSE);
1619 
1620   if (d-&gt;day == 1) return TRUE;
1621   else return FALSE;
1622 }
1623 
1624 /**
1625  * g_date_is_last_of_month:
1626  * @date: a #GDate to check
1627  *
1628  * Returns %TRUE if the date is the last day of the month.
1629  * The date must be valid.
1630  *
1631  * Returns: %TRUE if the date is the last day of the month
1632  */
1633 gboolean
1634 g_date_is_last_of_month (const GDate *d)
1635 {
1636   gint idx;
1637 
1638   g_return_val_if_fail (g_date_valid (d), FALSE);
1639 
1640   if (!d-&gt;dmy)
1641     g_date_update_dmy (d);
1642 
1643   g_return_val_if_fail (d-&gt;dmy, FALSE);
1644 
1645   idx = g_date_is_leap_year (d-&gt;year) ? 1 : 0;
1646 
1647   if (d-&gt;day == days_in_months[idx][d-&gt;month]) return TRUE;
1648   else return FALSE;
1649 }
1650 
1651 /**
1652  * g_date_add_days:
1653  * @date: a #GDate to increment
1654  * @n_days: number of days to move the date forward
1655  *
1656  * Increments a date some number of days.
1657  * To move forward by weeks, add weeks*7 days.
1658  * The date must be valid.
1659  */
1660 void
1661 g_date_add_days (GDate *d,
1662                  guint  ndays)
1663 {
1664   g_return_if_fail (g_date_valid (d));
1665 
1666   if (!d-&gt;julian)
1667     g_date_update_julian (d);
1668 
1669   g_return_if_fail (d-&gt;julian);
1670   g_return_if_fail (ndays &lt;= G_MAXUINT32 - d-&gt;julian_days);
1671 
1672   d-&gt;julian_days += ndays;
1673   d-&gt;dmy = FALSE;
1674 }
1675 
1676 /**
1677  * g_date_subtract_days:
1678  * @date: a #GDate to decrement
1679  * @n_days: number of days to move
1680  *
1681  * Moves a date some number of days into the past.
1682  * To move by weeks, just move by weeks*7 days.
1683  * The date must be valid.
1684  */
1685 void
1686 g_date_subtract_days (GDate *d,
1687                       guint  ndays)
1688 {
1689   g_return_if_fail (g_date_valid (d));
1690 
1691   if (!d-&gt;julian)
1692     g_date_update_julian (d);
1693 
1694   g_return_if_fail (d-&gt;julian);
1695   g_return_if_fail (d-&gt;julian_days &gt; ndays);
1696 
1697   d-&gt;julian_days -= ndays;
1698   d-&gt;dmy = FALSE;
1699 }
1700 
1701 /**
1702  * g_date_add_months:
1703  * @date: a #GDate to increment
1704  * @n_months: number of months to move forward
1705  *
1706  * Increments a date by some number of months.
1707  * If the day of the month is greater than 28,
1708  * this routine may change the day of the month
1709  * (because the destination month may not have
1710  * the current day in it). The date must be valid.
1711  */
1712 void
1713 g_date_add_months (GDate *d,
1714                    guint  nmonths)
1715 {
1716   guint years, months;
1717   gint idx;
1718 
1719   g_return_if_fail (g_date_valid (d));
1720 
1721   if (!d-&gt;dmy)
1722     g_date_update_dmy (d);
1723 
1724   g_return_if_fail (d-&gt;dmy != 0);
1725   g_return_if_fail (nmonths &lt;= G_MAXUINT - (d-&gt;month - 1));
1726 
1727   nmonths += d-&gt;month - 1;
1728 
1729   years  = nmonths/12;
1730   months = nmonths%12;
1731 
1732   g_return_if_fail (years &lt;= G_MAXUINT16 - d-&gt;year);
1733 
1734   d-&gt;month = months + 1;
1735   d-&gt;year  += years;
1736 
1737   idx = g_date_is_leap_year (d-&gt;year) ? 1 : 0;
1738 
1739   if (d-&gt;day &gt; days_in_months[idx][d-&gt;month])
1740     d-&gt;day = days_in_months[idx][d-&gt;month];
1741 
1742   d-&gt;julian = FALSE;
1743 
1744   g_return_if_fail (g_date_valid (d));
1745 }
1746 
1747 /**
1748  * g_date_subtract_months:
1749  * @date: a #GDate to decrement
1750  * @n_months: number of months to move
1751  *
1752  * Moves a date some number of months into the past.
1753  * If the current day of the month doesn&#39;t exist in
1754  * the destination month, the day of the month
1755  * may change. The date must be valid.
1756  */
1757 void
1758 g_date_subtract_months (GDate *d,
1759                         guint  nmonths)
1760 {
1761   guint years, months;
1762   gint idx;
1763 
1764   g_return_if_fail (g_date_valid (d));
1765 
1766   if (!d-&gt;dmy)
1767     g_date_update_dmy (d);
1768 
1769   g_return_if_fail (d-&gt;dmy != 0);
1770 
1771   years  = nmonths/12;
1772   months = nmonths%12;
1773 
1774   g_return_if_fail (d-&gt;year &gt; years);
1775 
1776   d-&gt;year  -= years;
1777 
1778   if (d-&gt;month &gt; months) d-&gt;month -= months;
1779   else
1780     {
1781       months -= d-&gt;month;
1782       d-&gt;month = 12 - months;
1783       d-&gt;year -= 1;
1784     }
1785 
1786   idx = g_date_is_leap_year (d-&gt;year) ? 1 : 0;
1787 
1788   if (d-&gt;day &gt; days_in_months[idx][d-&gt;month])
1789     d-&gt;day = days_in_months[idx][d-&gt;month];
1790 
1791   d-&gt;julian = FALSE;
1792 
1793   g_return_if_fail (g_date_valid (d));
1794 }
1795 
1796 /**
1797  * g_date_add_years:
1798  * @date: a #GDate to increment
1799  * @n_years: number of years to move forward
1800  *
1801  * Increments a date by some number of years.
1802  * If the date is February 29, and the destination
1803  * year is not a leap year, the date will be changed
1804  * to February 28. The date must be valid.
1805  */
1806 void
1807 g_date_add_years (GDate *d,
1808                   guint  nyears)
1809 {
1810   g_return_if_fail (g_date_valid (d));
1811 
1812   if (!d-&gt;dmy)
1813     g_date_update_dmy (d);
1814 
1815   g_return_if_fail (d-&gt;dmy != 0);
1816   g_return_if_fail (nyears &lt;= G_MAXUINT16 - d-&gt;year);
1817 
1818   d-&gt;year += nyears;
1819 
1820   if (d-&gt;month == 2 &amp;&amp; d-&gt;day == 29)
1821     {
1822       if (!g_date_is_leap_year (d-&gt;year))
1823         d-&gt;day = 28;
1824     }
1825 
1826   d-&gt;julian = FALSE;
1827 }
1828 
1829 /**
1830  * g_date_subtract_years:
1831  * @date: a #GDate to decrement
1832  * @n_years: number of years to move
1833  *
1834  * Moves a date some number of years into the past.
1835  * If the current day doesn&#39;t exist in the destination
1836  * year (i.e. it&#39;s February 29 and you move to a non-leap-year)
1837  * then the day is changed to February 29. The date
1838  * must be valid.
1839  */
1840 void
1841 g_date_subtract_years (GDate *d,
1842                        guint  nyears)
1843 {
1844   g_return_if_fail (g_date_valid (d));
1845 
1846   if (!d-&gt;dmy)
1847     g_date_update_dmy (d);
1848 
1849   g_return_if_fail (d-&gt;dmy != 0);
1850   g_return_if_fail (d-&gt;year &gt; nyears);
1851 
1852   d-&gt;year -= nyears;
1853 
1854   if (d-&gt;month == 2 &amp;&amp; d-&gt;day == 29)
1855     {
1856       if (!g_date_is_leap_year (d-&gt;year))
1857         d-&gt;day = 28;
1858     }
1859 
1860   d-&gt;julian = FALSE;
1861 }
1862 
1863 /**
1864  * g_date_is_leap_year:
1865  * @year: year to check
1866  *
1867  * Returns %TRUE if the year is a leap year.
1868  *
1869  * For the purposes of this function, leap year is every year
1870  * divisible by 4 unless that year is divisible by 100. If it
1871  * is divisible by 100 it would be a leap year only if that year
1872  * is also divisible by 400.
1873  *
1874  * Returns: %TRUE if the year is a leap year
1875  */
1876 gboolean
1877 g_date_is_leap_year (GDateYear year)
1878 {
1879   g_return_val_if_fail (g_date_valid_year (year), FALSE);
1880 
1881   return ( (((year % 4) == 0) &amp;&amp; ((year % 100) != 0)) ||
1882            (year % 400) == 0 );
1883 }
1884 
1885 /**
1886  * g_date_get_days_in_month:
1887  * @month: month
1888  * @year: year
1889  *
1890  * Returns the number of days in a month, taking leap
1891  * years into account.
1892  *
1893  * Returns: number of days in @month during the @year
1894  */
1895 guint8
1896 g_date_get_days_in_month (GDateMonth month,
1897                           GDateYear  year)
1898 {
1899   gint idx;
1900 
1901   g_return_val_if_fail (g_date_valid_year (year), 0);
1902   g_return_val_if_fail (g_date_valid_month (month), 0);
1903 
1904   idx = g_date_is_leap_year (year) ? 1 : 0;
1905 
1906   return days_in_months[idx][month];
1907 }
1908 
1909 /**
1910  * g_date_get_monday_weeks_in_year:
1911  * @year: a year
1912  *
1913  * Returns the number of weeks in the year, where weeks
1914  * are taken to start on Monday. Will be 52 or 53. The
1915  * date must be valid. (Years always have 52 7-day periods,
1916  * plus 1 or 2 extra days depending on whether it&#39;s a leap
1917  * year. This function is basically telling you how many
1918  * Mondays are in the year, i.e. there are 53 Mondays if
1919  * one of the extra days happens to be a Monday.)
1920  *
1921  * Returns: number of Mondays in the year
1922  */
1923 guint8
1924 g_date_get_monday_weeks_in_year (GDateYear year)
1925 {
1926   GDate d;
1927 
1928   g_return_val_if_fail (g_date_valid_year (year), 0);
1929 
1930   g_date_clear (&amp;d, 1);
1931   g_date_set_dmy (&amp;d, 1, 1, year);
1932   if (g_date_get_weekday (&amp;d) == G_DATE_MONDAY) return 53;
1933   g_date_set_dmy (&amp;d, 31, 12, year);
1934   if (g_date_get_weekday (&amp;d) == G_DATE_MONDAY) return 53;
1935   if (g_date_is_leap_year (year))
1936     {
1937       g_date_set_dmy (&amp;d, 2, 1, year);
1938       if (g_date_get_weekday (&amp;d) == G_DATE_MONDAY) return 53;
1939       g_date_set_dmy (&amp;d, 30, 12, year);
1940       if (g_date_get_weekday (&amp;d) == G_DATE_MONDAY) return 53;
1941     }
1942   return 52;
1943 }
1944 
1945 /**
1946  * g_date_get_sunday_weeks_in_year:
1947  * @year: year to count weeks in
1948  *
1949  * Returns the number of weeks in the year, where weeks
1950  * are taken to start on Sunday. Will be 52 or 53. The
1951  * date must be valid. (Years always have 52 7-day periods,
1952  * plus 1 or 2 extra days depending on whether it&#39;s a leap
1953  * year. This function is basically telling you how many
1954  * Sundays are in the year, i.e. there are 53 Sundays if
1955  * one of the extra days happens to be a Sunday.)
1956  *
1957  * Returns: the number of weeks in @year
1958  */
1959 guint8
1960 g_date_get_sunday_weeks_in_year (GDateYear year)
1961 {
1962   GDate d;
1963 
1964   g_return_val_if_fail (g_date_valid_year (year), 0);
1965 
1966   g_date_clear (&amp;d, 1);
1967   g_date_set_dmy (&amp;d, 1, 1, year);
1968   if (g_date_get_weekday (&amp;d) == G_DATE_SUNDAY) return 53;
1969   g_date_set_dmy (&amp;d, 31, 12, year);
1970   if (g_date_get_weekday (&amp;d) == G_DATE_SUNDAY) return 53;
1971   if (g_date_is_leap_year (year))
1972     {
1973       g_date_set_dmy (&amp;d, 2, 1, year);
1974       if (g_date_get_weekday (&amp;d) == G_DATE_SUNDAY) return 53;
1975       g_date_set_dmy (&amp;d, 30, 12, year);
1976       if (g_date_get_weekday (&amp;d) == G_DATE_SUNDAY) return 53;
1977     }
1978   return 52;
1979 }
1980 
1981 /**
1982  * g_date_compare:
1983  * @lhs: first date to compare
1984  * @rhs: second date to compare
1985  *
1986  * qsort()-style comparison function for dates.
1987  * Both dates must be valid.
1988  *
1989  * Returns: 0 for equal, less than zero if @lhs is less than @rhs,
1990  *     greater than zero if @lhs is greater than @rhs
1991  */
1992 gint
1993 g_date_compare (const GDate *lhs,
1994                 const GDate *rhs)
1995 {
1996   g_return_val_if_fail (lhs != NULL, 0);
1997   g_return_val_if_fail (rhs != NULL, 0);
1998   g_return_val_if_fail (g_date_valid (lhs), 0);
1999   g_return_val_if_fail (g_date_valid (rhs), 0);
2000 
2001   /* Remember the self-comparison case! I think it works right now. */
2002 
2003   while (TRUE)
2004     {
2005       if (lhs-&gt;julian &amp;&amp; rhs-&gt;julian)
2006         {
2007           if (lhs-&gt;julian_days &lt; rhs-&gt;julian_days) return -1;
2008           else if (lhs-&gt;julian_days &gt; rhs-&gt;julian_days) return 1;
2009           else                                          return 0;
2010         }
2011       else if (lhs-&gt;dmy &amp;&amp; rhs-&gt;dmy)
2012         {
2013           if (lhs-&gt;year &lt; rhs-&gt;year)               return -1;
2014           else if (lhs-&gt;year &gt; rhs-&gt;year)               return 1;
2015           else
2016             {
2017               if (lhs-&gt;month &lt; rhs-&gt;month)         return -1;
2018               else if (lhs-&gt;month &gt; rhs-&gt;month)         return 1;
2019               else
2020                 {
2021                   if (lhs-&gt;day &lt; rhs-&gt;day)              return -1;
2022                   else if (lhs-&gt;day &gt; rhs-&gt;day)              return 1;
2023                   else                                       return 0;
2024                 }
2025 
2026             }
2027 
2028         }
2029       else
2030         {
2031           if (!lhs-&gt;julian) g_date_update_julian (lhs);
2032           if (!rhs-&gt;julian) g_date_update_julian (rhs);
2033           g_return_val_if_fail (lhs-&gt;julian, 0);
2034           g_return_val_if_fail (rhs-&gt;julian, 0);
2035         }
2036 
2037     }
2038   return 0; /* warnings */
2039 }
2040 
2041 /**
2042  * g_date_to_struct_tm:
2043  * @date: a #GDate to set the struct tm from
2044  * @tm: (not nullable): struct tm to fill
2045  *
2046  * Fills in the date-related bits of a struct tm using the @date value.
2047  * Initializes the non-date parts with something sane but meaningless.
2048  */
2049 void
2050 g_date_to_struct_tm (const GDate *d,
2051                      struct tm   *tm)
2052 {
2053   GDateWeekday day;
2054 
2055   g_return_if_fail (g_date_valid (d));
2056   g_return_if_fail (tm != NULL);
2057 
2058   if (!d-&gt;dmy)
2059     g_date_update_dmy (d);
2060 
2061   g_return_if_fail (d-&gt;dmy != 0);
2062 
2063   /* zero all the irrelevant fields to be sure they&#39;re valid */
2064 
2065   /* On Linux and maybe other systems, there are weird non-POSIX
2066    * fields on the end of struct tm that choke strftime if they
2067    * contain garbage.  So we need to 0 the entire struct, not just the
2068    * fields we know to exist.
2069    */
2070 
2071   memset (tm, 0x0, sizeof (struct tm));
2072 
2073   tm-&gt;tm_mday = d-&gt;day;
2074   tm-&gt;tm_mon  = d-&gt;month - 1; /* 0-11 goes in tm */
2075   tm-&gt;tm_year = ((int)d-&gt;year) - 1900; /* X/Open says tm_year can be negative */
2076 
2077   day = g_date_get_weekday (d);
2078   if (day == 7) day = 0; /* struct tm wants days since Sunday, so Sunday is 0 */
2079 
2080   tm-&gt;tm_wday = (int)day;
2081 
2082   tm-&gt;tm_yday = g_date_get_day_of_year (d) - 1; /* 0 to 365 */
2083   tm-&gt;tm_isdst = -1; /* -1 means &quot;information not available&quot; */
2084 }
2085 
2086 /**
2087  * g_date_clamp:
2088  * @date: a #GDate to clamp
2089  * @min_date: minimum accepted value for @date
2090  * @max_date: maximum accepted value for @date
2091  *
2092  * If @date is prior to @min_date, sets @date equal to @min_date.
2093  * If @date falls after @max_date, sets @date equal to @max_date.
2094  * Otherwise, @date is unchanged.
2095  * Either of @min_date and @max_date may be %NULL.
2096  * All non-%NULL dates must be valid.
2097  */
2098 void
2099 g_date_clamp (GDate       *date,
2100           const GDate *min_date,
2101           const GDate *max_date)
2102 {
2103   g_return_if_fail (g_date_valid (date));
2104 
2105   if (min_date != NULL)
2106     g_return_if_fail (g_date_valid (min_date));
2107 
2108   if (max_date != NULL)
2109     g_return_if_fail (g_date_valid (max_date));
2110 
2111   if (min_date != NULL &amp;&amp; max_date != NULL)
2112     g_return_if_fail (g_date_compare (min_date, max_date) &lt;= 0);
2113 
2114   if (min_date &amp;&amp; g_date_compare (date, min_date) &lt; 0)
2115     *date = *min_date;
2116 
2117   if (max_date &amp;&amp; g_date_compare (max_date, date) &lt; 0)
2118     *date = *max_date;
2119 }
2120 
2121 /**
2122  * g_date_order:
2123  * @date1: the first date
2124  * @date2: the second date
2125  *
2126  * Checks if @date1 is less than or equal to @date2,
2127  * and swap the values if this is not the case.
2128  */
2129 void
2130 g_date_order (GDate *date1,
2131               GDate *date2)
2132 {
2133   g_return_if_fail (g_date_valid (date1));
2134   g_return_if_fail (g_date_valid (date2));
2135 
2136   if (g_date_compare (date1, date2) &gt; 0)
2137     {
2138       GDate tmp = *date1;
2139       *date1 = *date2;
2140       *date2 = tmp;
2141     }
2142 }
2143 
2144 #ifdef G_OS_WIN32
2145 static void
2146 append_month_name (GArray     *result,
2147            LCID        lcid,
2148            SYSTEMTIME *systemtime,
2149            gboolean    abbreviated,
2150            gboolean    alternative)
2151 {
2152   int n;
2153   WORD base;
2154   LPCWSTR lpFormat;
2155 
2156   if (alternative)
2157     {
2158       base = abbreviated ? LOCALE_SABBREVMONTHNAME1 : LOCALE_SMONTHNAME1;
2159       n = GetLocaleInfoW (lcid, base + systemtime-&gt;wMonth - 1, NULL, 0);
2160       g_array_set_size (result, result-&gt;len + n);
2161       GetLocaleInfoW (lcid, base + systemtime-&gt;wMonth - 1,
2162               ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);
2163       g_array_set_size (result, result-&gt;len - 1);
2164     }
2165   else
2166     {
2167       /* According to MSDN, this is the correct method to obtain
2168        * the form of the month name used when formatting a full
2169        * date; it must be a genitive case in some languages.
2170        */
2171       lpFormat = abbreviated ? L&quot;ddMMM&quot; : L&quot;ddMMMM&quot;;
2172       n = GetDateFormatW (lcid, 0, systemtime, lpFormat, NULL, 0);
2173       g_array_set_size (result, result-&gt;len + n);
2174       GetDateFormatW (lcid, 0, systemtime, lpFormat,
2175               ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);
2176       /* We have obtained a day number as two digits and the month name.
2177        * Now let&#39;s get rid of those two digits: overwrite them with the
2178        * month name.
2179        */
2180       memmove (((wchar_t *) result-&gt;data) + result-&gt;len - n,
2181            ((wchar_t *) result-&gt;data) + result-&gt;len - n + 2,
2182            (n - 2) * sizeof (wchar_t));
2183       g_array_set_size (result, result-&gt;len - 3);
2184     }
2185 }
2186 
2187 static gsize
2188 win32_strftime_helper (const GDate     *d,
2189                        const gchar     *format,
2190                        const struct tm *tm,
2191                        gchar           *s,
2192                gsize            slen)
2193 {
2194   SYSTEMTIME systemtime;
2195   TIME_ZONE_INFORMATION tzinfo;
2196   LCID lcid;
2197   int n, k;
2198   GArray *result;
2199   const gchar *p;
2200   gunichar c, modifier;
2201   const wchar_t digits[] = L&quot;0123456789&quot;;
2202   gchar *convbuf;
2203   glong convlen = 0;
2204   gsize retval;
2205 
2206   systemtime.wYear = tm-&gt;tm_year + 1900;
2207   systemtime.wMonth = tm-&gt;tm_mon + 1;
2208   systemtime.wDayOfWeek = tm-&gt;tm_wday;
2209   systemtime.wDay = tm-&gt;tm_mday;
2210   systemtime.wHour = tm-&gt;tm_hour;
2211   systemtime.wMinute = tm-&gt;tm_min;
2212   systemtime.wSecond = tm-&gt;tm_sec;
2213   systemtime.wMilliseconds = 0;
2214 
2215   lcid = GetThreadLocale ();
2216   result = g_array_sized_new (FALSE, FALSE, sizeof (wchar_t), MAX (128, strlen (format) * 2));
2217 
2218   p = format;
2219   while (*p)
2220     {
2221       c = g_utf8_get_char (p);
2222       if (c == &#39;%&#39;)
2223     {
2224       p = g_utf8_next_char (p);
2225       if (!*p)
2226         {
2227           s[0] = &#39;\0&#39;;
2228           g_array_free (result, TRUE);
2229 
2230           return 0;
2231         }
2232 
2233       modifier = &#39;\0&#39;;
2234       c = g_utf8_get_char (p);
2235       if (c == &#39;E&#39; || c == &#39;O&#39;)
2236         {
2237           /* &quot;%OB&quot;, &quot;%Ob&quot;, and &quot;%Oh&quot; are supported, ignore other modified
2238            * conversion specifiers for now.
2239            */
2240           modifier = c;
2241           p = g_utf8_next_char (p);
2242           if (!*p)
2243         {
2244           s[0] = &#39;\0&#39;;
2245           g_array_free (result, TRUE);
2246 
2247           return 0;
2248         }
2249 
2250           c = g_utf8_get_char (p);
2251         }
2252 
2253       switch (c)
2254         {
2255         case &#39;a&#39;:
2256           if (systemtime.wDayOfWeek == 0)
2257         k = 6;
2258           else
2259         k = systemtime.wDayOfWeek - 1;
2260           n = GetLocaleInfoW (lcid, LOCALE_SABBREVDAYNAME1+k, NULL, 0);
2261           g_array_set_size (result, result-&gt;len + n);
2262           GetLocaleInfoW (lcid, LOCALE_SABBREVDAYNAME1+k, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);
2263           g_array_set_size (result, result-&gt;len - 1);
2264           break;
2265         case &#39;A&#39;:
2266           if (systemtime.wDayOfWeek == 0)
2267         k = 6;
2268           else
2269         k = systemtime.wDayOfWeek - 1;
2270           n = GetLocaleInfoW (lcid, LOCALE_SDAYNAME1+k, NULL, 0);
2271           g_array_set_size (result, result-&gt;len + n);
2272           GetLocaleInfoW (lcid, LOCALE_SDAYNAME1+k, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);
2273           g_array_set_size (result, result-&gt;len - 1);
2274           break;
2275         case &#39;b&#39;:
2276         case &#39;h&#39;:
2277           append_month_name (result, lcid, &amp;systemtime, TRUE,
2278                  modifier == &#39;O&#39;);
2279           break;
2280         case &#39;B&#39;:
2281           append_month_name (result, lcid, &amp;systemtime, FALSE,
2282                  modifier == &#39;O&#39;);
2283           break;
2284         case &#39;c&#39;:
2285           n = GetDateFormatW (lcid, 0, &amp;systemtime, NULL, NULL, 0);
2286           if (n &gt; 0)
2287         {
2288           g_array_set_size (result, result-&gt;len + n);
2289           GetDateFormatW (lcid, 0, &amp;systemtime, NULL, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);
2290           g_array_set_size (result, result-&gt;len - 1);
2291         }
2292           g_array_append_vals (result, L&quot; &quot;, 1);
2293           n = GetTimeFormatW (lcid, 0, &amp;systemtime, NULL, NULL, 0);
2294           if (n &gt; 0)
2295         {
2296           g_array_set_size (result, result-&gt;len + n);
2297           GetTimeFormatW (lcid, 0, &amp;systemtime, NULL, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);
2298           g_array_set_size (result, result-&gt;len - 1);
2299         }
2300           break;
2301         case &#39;C&#39;:
2302           g_array_append_vals (result, digits + systemtime.wYear/1000, 1);
2303           g_array_append_vals (result, digits + (systemtime.wYear/1000)%10, 1);
2304           break;
2305         case &#39;d&#39;:
2306           g_array_append_vals (result, digits + systemtime.wDay/10, 1);
2307           g_array_append_vals (result, digits + systemtime.wDay%10, 1);
2308           break;
2309         case &#39;D&#39;:
2310           g_array_append_vals (result, digits + systemtime.wMonth/10, 1);
2311           g_array_append_vals (result, digits + systemtime.wMonth%10, 1);
2312           g_array_append_vals (result, L&quot;/&quot;, 1);
2313           g_array_append_vals (result, digits + systemtime.wDay/10, 1);
2314           g_array_append_vals (result, digits + systemtime.wDay%10, 1);
2315           g_array_append_vals (result, L&quot;/&quot;, 1);
2316           g_array_append_vals (result, digits + (systemtime.wYear/10)%10, 1);
2317           g_array_append_vals (result, digits + systemtime.wYear%10, 1);
2318           break;
2319         case &#39;e&#39;:
2320           if (systemtime.wDay &gt;= 10)
2321         g_array_append_vals (result, digits + systemtime.wDay/10, 1);
2322           else
2323         g_array_append_vals (result, L&quot; &quot;, 1);
2324           g_array_append_vals (result, digits + systemtime.wDay%10, 1);
2325           break;
2326 
2327           /* A GDate has no time fields, so for now we can
2328            * hardcode all time conversions into zeros (or 12 for
2329            * %I). The alternative code snippets in the #else
2330            * branches are here ready to be taken into use when
2331            * needed by a g_strftime() or g_date_and_time_format()
2332            * or whatever.
2333            */
2334         case &#39;H&#39;:
2335 #if 1
2336           g_array_append_vals (result, L&quot;00&quot;, 2);
2337 #else
2338           g_array_append_vals (result, digits + systemtime.wHour/10, 1);
2339           g_array_append_vals (result, digits + systemtime.wHour%10, 1);
2340 #endif
2341           break;
2342         case &#39;I&#39;:
2343 #if 1
2344           g_array_append_vals (result, L&quot;12&quot;, 2);
2345 #else
2346           if (systemtime.wHour == 0)
2347         g_array_append_vals (result, L&quot;12&quot;, 2);
2348           else
2349         {
2350           g_array_append_vals (result, digits + (systemtime.wHour%12)/10, 1);
2351           g_array_append_vals (result, digits + (systemtime.wHour%12)%10, 1);
2352         }
2353 #endif
2354           break;
2355         case  &#39;j&#39;:
2356           g_array_append_vals (result, digits + (tm-&gt;tm_yday+1)/100, 1);
2357           g_array_append_vals (result, digits + ((tm-&gt;tm_yday+1)/10)%10, 1);
2358           g_array_append_vals (result, digits + (tm-&gt;tm_yday+1)%10, 1);
2359           break;
2360         case &#39;m&#39;:
2361           g_array_append_vals (result, digits + systemtime.wMonth/10, 1);
2362           g_array_append_vals (result, digits + systemtime.wMonth%10, 1);
2363           break;
2364         case &#39;M&#39;:
2365 #if 1
2366           g_array_append_vals (result, L&quot;00&quot;, 2);
2367 #else
2368           g_array_append_vals (result, digits + systemtime.wMinute/10, 1);
2369           g_array_append_vals (result, digits + systemtime.wMinute%10, 1);
2370 #endif
2371           break;
2372         case &#39;n&#39;:
2373           g_array_append_vals (result, L&quot;\n&quot;, 1);
2374           break;
2375         case &#39;p&#39;:
2376           n = GetTimeFormatW (lcid, 0, &amp;systemtime, L&quot;tt&quot;, NULL, 0);
2377           if (n &gt; 0)
2378         {
2379           g_array_set_size (result, result-&gt;len + n);
2380           GetTimeFormatW (lcid, 0, &amp;systemtime, L&quot;tt&quot;, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);
2381           g_array_set_size (result, result-&gt;len - 1);
2382         }
2383           break;
2384         case &#39;r&#39;:
2385           /* This is a rather odd format. Hard to say what to do.
2386            * Let&#39;s always use the POSIX %I:%M:%S %p
2387            */
2388 #if 1
2389           g_array_append_vals (result, L&quot;12:00:00&quot;, 8);
2390 #else
2391           if (systemtime.wHour == 0)
2392         g_array_append_vals (result, L&quot;12&quot;, 2);
2393           else
2394         {
2395           g_array_append_vals (result, digits + (systemtime.wHour%12)/10, 1);
2396           g_array_append_vals (result, digits + (systemtime.wHour%12)%10, 1);
2397         }
2398           g_array_append_vals (result, L&quot;:&quot;, 1);
2399           g_array_append_vals (result, digits + systemtime.wMinute/10, 1);
2400           g_array_append_vals (result, digits + systemtime.wMinute%10, 1);
2401           g_array_append_vals (result, L&quot;:&quot;, 1);
2402           g_array_append_vals (result, digits + systemtime.wSecond/10, 1);
2403           g_array_append_vals (result, digits + systemtime.wSecond%10, 1);
2404           g_array_append_vals (result, L&quot; &quot;, 1);
2405 #endif
2406           n = GetTimeFormatW (lcid, 0, &amp;systemtime, L&quot;tt&quot;, NULL, 0);
2407           if (n &gt; 0)
2408         {
2409           g_array_set_size (result, result-&gt;len + n);
2410           GetTimeFormatW (lcid, 0, &amp;systemtime, L&quot;tt&quot;, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);
2411           g_array_set_size (result, result-&gt;len - 1);
2412         }
2413           break;
2414         case &#39;R&#39;:
2415 #if 1
2416           g_array_append_vals (result, L&quot;00:00&quot;, 5);
2417 #else
2418           g_array_append_vals (result, digits + systemtime.wHour/10, 1);
2419           g_array_append_vals (result, digits + systemtime.wHour%10, 1);
2420           g_array_append_vals (result, L&quot;:&quot;, 1);
2421           g_array_append_vals (result, digits + systemtime.wMinute/10, 1);
2422           g_array_append_vals (result, digits + systemtime.wMinute%10, 1);
2423 #endif
2424           break;
2425         case &#39;S&#39;:
2426 #if 1
2427           g_array_append_vals (result, L&quot;00&quot;, 2);
2428 #else
2429           g_array_append_vals (result, digits + systemtime.wSecond/10, 1);
2430           g_array_append_vals (result, digits + systemtime.wSecond%10, 1);
2431 #endif
2432           break;
2433         case &#39;t&#39;:
2434           g_array_append_vals (result, L&quot;\t&quot;, 1);
2435           break;
2436         case &#39;T&#39;:
2437 #if 1
2438           g_array_append_vals (result, L&quot;00:00:00&quot;, 8);
2439 #else
2440           g_array_append_vals (result, digits + systemtime.wHour/10, 1);
2441           g_array_append_vals (result, digits + systemtime.wHour%10, 1);
2442           g_array_append_vals (result, L&quot;:&quot;, 1);
2443           g_array_append_vals (result, digits + systemtime.wMinute/10, 1);
2444           g_array_append_vals (result, digits + systemtime.wMinute%10, 1);
2445           g_array_append_vals (result, L&quot;:&quot;, 1);
2446           g_array_append_vals (result, digits + systemtime.wSecond/10, 1);
2447           g_array_append_vals (result, digits + systemtime.wSecond%10, 1);
2448 #endif
2449           break;
2450         case &#39;u&#39;:
2451           if (systemtime.wDayOfWeek == 0)
2452         g_array_append_vals (result, L&quot;7&quot;, 1);
2453           else
2454         g_array_append_vals (result, digits + systemtime.wDayOfWeek, 1);
2455           break;
2456         case &#39;U&#39;:
2457           n = g_date_get_sunday_week_of_year (d);
2458           g_array_append_vals (result, digits + n/10, 1);
2459           g_array_append_vals (result, digits + n%10, 1);
2460           break;
2461         case &#39;V&#39;:
2462           n = g_date_get_iso8601_week_of_year (d);
2463           g_array_append_vals (result, digits + n/10, 1);
2464           g_array_append_vals (result, digits + n%10, 1);
2465           break;
2466         case &#39;w&#39;:
2467           g_array_append_vals (result, digits + systemtime.wDayOfWeek, 1);
2468           break;
2469         case &#39;W&#39;:
2470           n = g_date_get_monday_week_of_year (d);
2471           g_array_append_vals (result, digits + n/10, 1);
2472           g_array_append_vals (result, digits + n%10, 1);
2473           break;
2474         case &#39;x&#39;:
2475           n = GetDateFormatW (lcid, 0, &amp;systemtime, NULL, NULL, 0);
2476           if (n &gt; 0)
2477         {
2478           g_array_set_size (result, result-&gt;len + n);
2479           GetDateFormatW (lcid, 0, &amp;systemtime, NULL, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);
2480           g_array_set_size (result, result-&gt;len - 1);
2481         }
2482           break;
2483         case &#39;X&#39;:
2484           n = GetTimeFormatW (lcid, 0, &amp;systemtime, NULL, NULL, 0);
2485           if (n &gt; 0)
2486         {
2487           g_array_set_size (result, result-&gt;len + n);
2488           GetTimeFormatW (lcid, 0, &amp;systemtime, NULL, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);
2489           g_array_set_size (result, result-&gt;len - 1);
2490         }
2491           break;
2492         case &#39;y&#39;:
2493           g_array_append_vals (result, digits + (systemtime.wYear/10)%10, 1);
2494           g_array_append_vals (result, digits + systemtime.wYear%10, 1);
2495           break;
2496         case &#39;Y&#39;:
2497           g_array_append_vals (result, digits + systemtime.wYear/1000, 1);
2498           g_array_append_vals (result, digits + (systemtime.wYear/100)%10, 1);
2499           g_array_append_vals (result, digits + (systemtime.wYear/10)%10, 1);
2500           g_array_append_vals (result, digits + systemtime.wYear%10, 1);
2501           break;
2502         case &#39;Z&#39;:
2503           n = GetTimeZoneInformation (&amp;tzinfo);
2504           if (n == TIME_ZONE_ID_UNKNOWN)
2505         ;
2506           else if (n == TIME_ZONE_ID_STANDARD)
2507         g_array_append_vals (result, tzinfo.StandardName, wcslen (tzinfo.StandardName));
2508           else if (n == TIME_ZONE_ID_DAYLIGHT)
2509         g_array_append_vals (result, tzinfo.DaylightName, wcslen (tzinfo.DaylightName));
2510           break;
2511         case &#39;%&#39;:
2512           g_array_append_vals (result, L&quot;%&quot;, 1);
2513           break;
2514         }
2515     }
2516       else if (c &lt;= 0xFFFF)
2517     {
2518       wchar_t wc = c;
2519       g_array_append_vals (result, &amp;wc, 1);
2520     }
2521       else
2522     {
2523       glong nwc;
2524       wchar_t *ws;
2525 
2526       ws = g_ucs4_to_utf16 (&amp;c, 1, NULL, &amp;nwc, NULL);
2527       g_array_append_vals (result, ws, nwc);
2528       g_free (ws);
2529     }
2530       p = g_utf8_next_char (p);
2531     }
2532 
2533   convbuf = g_utf16_to_utf8 ((wchar_t *) result-&gt;data, result-&gt;len, NULL, &amp;convlen, NULL);
2534   g_array_free (result, TRUE);
2535 
2536   if (!convbuf)
2537     {
2538       s[0] = &#39;\0&#39;;
2539       return 0;
2540     }
2541 
2542   if (slen &lt;= convlen)
2543     {
2544       /* Ensure only whole characters are copied into the buffer. */
2545       gchar *end = g_utf8_find_prev_char (convbuf, convbuf + slen);
2546       g_assert (end != NULL);
2547       convlen = end - convbuf;
2548 
2549       /* Return 0 because the buffer isn&#39;t large enough. */
2550       retval = 0;
2551     }
2552   else
2553     retval = convlen;
2554 
2555   memcpy (s, convbuf, convlen);
2556   s[convlen] = &#39;\0&#39;;
2557   g_free (convbuf);
2558 
2559   return retval;
2560 }
2561 
2562 #endif
2563 
2564 /**
2565  * g_date_strftime:
2566  * @s: destination buffer
2567  * @slen: buffer size
2568  * @format: format string
2569  * @date: valid #GDate
2570  *
2571  * Generates a printed representation of the date, in a
2572  * [locale][setlocale]-specific way.
2573  * Works just like the platform&#39;s C library strftime() function,
2574  * but only accepts date-related formats; time-related formats
2575  * give undefined results. Date must be valid. Unlike strftime()
2576  * (which uses the locale encoding), works on a UTF-8 format
2577  * string and stores a UTF-8 result.
2578  *
2579  * This function does not provide any conversion specifiers in
2580  * addition to those implemented by the platform&#39;s C library.
2581  * For example, don&#39;t expect that using g_date_strftime() would
2582  * make the \%F provided by the C99 strftime() work on Windows
2583  * where the C library only complies to C89.
2584  *
2585  * Returns: number of characters written to the buffer, or 0 the buffer was too small
2586  */
2587 #pragma GCC diagnostic push
2588 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
2589 
2590 gsize
2591 g_date_strftime (gchar       *s,
2592                  gsize        slen,
2593                  const gchar *format,
2594                  const GDate *d)
2595 {
2596   struct tm tm;
2597 #ifndef G_OS_WIN32
2598   gsize locale_format_len = 0;
2599   gchar *locale_format;
2600   gsize tmplen;
2601   gchar *tmpbuf;
2602   gsize tmpbufsize;
2603   gsize convlen = 0;
2604   gchar *convbuf;
2605   GError *error = NULL;
2606   gsize retval;
2607 #endif
2608 
2609   g_return_val_if_fail (g_date_valid (d), 0);
2610   g_return_val_if_fail (slen &gt; 0, 0);
2611   g_return_val_if_fail (format != NULL, 0);
2612   g_return_val_if_fail (s != NULL, 0);
2613 
2614   g_date_to_struct_tm (d, &amp;tm);
2615 
2616 #ifdef G_OS_WIN32
2617   if (!g_utf8_validate (format, -1, NULL))
2618     {
2619       s[0] = &#39;\0&#39;;
2620       return 0;
2621     }
2622   return win32_strftime_helper (d, format, &amp;tm, s, slen);
2623 #else
2624 
2625   locale_format = g_locale_from_utf8 (format, -1, NULL, &amp;locale_format_len, &amp;error);
2626 
2627   if (error)
2628     {
2629       g_warning (G_STRLOC &quot;Error converting format to locale encoding: %s&quot;, error-&gt;message);
2630       g_error_free (error);
2631 
2632       s[0] = &#39;\0&#39;;
2633       return 0;
2634     }
2635 
2636   tmpbufsize = MAX (128, locale_format_len * 2);
2637   while (TRUE)
2638     {
2639       tmpbuf = g_malloc (tmpbufsize);
2640 #ifdef GSTREAMER_LITE
2641       if (tmpbuf == NULL)
2642           return 0;
2643 #endif // GSTREAMER_LITE
2644 
2645       /* Set the first byte to something other than &#39;\0&#39;, to be able to
2646        * recognize whether strftime actually failed or just returned &quot;&quot;.
2647        */
2648       tmpbuf[0] = &#39;\1&#39;;
2649       tmplen = strftime (tmpbuf, tmpbufsize, locale_format, &amp;tm);
2650 
2651       if (tmplen == 0 &amp;&amp; tmpbuf[0] != &#39;\0&#39;)
2652         {
2653           g_free (tmpbuf);
2654           tmpbufsize *= 2;
2655 
2656           if (tmpbufsize &gt; 65536)
2657             {
2658               g_warning (G_STRLOC &quot;Maximum buffer size for g_date_strftime exceeded: giving up&quot;);
2659               g_free (locale_format);
2660 
2661               s[0] = &#39;\0&#39;;
2662               return 0;
2663             }
2664         }
2665       else
2666         break;
2667     }
2668   g_free (locale_format);
2669 
2670   convbuf = g_locale_to_utf8 (tmpbuf, tmplen, NULL, &amp;convlen, &amp;error);
2671   g_free (tmpbuf);
2672 
2673   if (error)
2674     {
2675       g_warning (G_STRLOC &quot;Error converting results of strftime to UTF-8: %s&quot;, error-&gt;message);
2676       g_error_free (error);
2677 
2678       s[0] = &#39;\0&#39;;
2679       return 0;
2680     }
2681 
2682   if (slen &lt;= convlen)
2683     {
2684       /* Ensure only whole characters are copied into the buffer.
2685        */
2686       gchar *end = g_utf8_find_prev_char (convbuf, convbuf + slen);
2687       g_assert (end != NULL);
2688       convlen = end - convbuf;
2689 
2690       /* Return 0 because the buffer isn&#39;t large enough.
2691        */
2692       retval = 0;
2693     }
2694   else
2695     retval = convlen;
2696 
2697   memcpy (s, convbuf, convlen);
2698   s[convlen] = &#39;\0&#39;;
2699   g_free (convbuf);
2700 
2701   return retval;
2702 #endif
2703 }
2704 
2705 #pragma GCC diagnostic pop
    </pre>
  </body>
</html>