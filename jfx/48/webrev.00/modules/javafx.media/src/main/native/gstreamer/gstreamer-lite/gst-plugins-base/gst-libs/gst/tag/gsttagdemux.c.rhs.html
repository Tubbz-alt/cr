<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/tag/gsttagdemux.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer Base Class for Tag Demuxing
   2  * Copyright (C) 2005 Jan Schmidt &lt;thaytan@mad.scientist.com&gt;
   3  * Copyright (C) 2006-2007 Tim-Philipp MÃ¼ller &lt;tim centricular net&gt;
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Library General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Library General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Library General Public
  16  * License along with this library; if not, write to the
  17  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  18  * Boston, MA 02110-1301, USA.
  19  */
  20 
  21 /**
  22  * SECTION:gsttagdemux
  23  * @title: GstTagDemux
  24  * @see_also: GstApeDemux, GstID3Demux
  25  * @short_description: Base class for demuxing tags that are in chunks
  26  *                     directly at the beginning or at the end of a file
  27  *
  28  * Provides a base class for demuxing tags at the beginning or end of a
  29  * stream and handles things like typefinding, querying, seeking, and
  30  * different modes of operation (chain-based, pull_range-based, and providing
  31  * downstream elements with random access if upstream supports that). The tag
  32  * is stripped from the output, and all offsets are adjusted for the tag
  33  * sizes, so that to the downstream element the stream will appear as if
  34  * there was no tag at all. Also, once the tag has been parsed, GstTagDemux
  35  * will try to determine the media type of the resulting stream and add a
  36  * source pad with the appropriate caps in order to facilitate auto-plugging.
  37  *
  38  * ## Deriving from GstTagDemux
  39  *
  40  * Subclasses have to do four things:
  41  *
  42  *  * In their base init function, they must add a pad template for the sink
  43  *    pad to the element class, describing the media type they can parse in
  44  *    the caps of the pad template.
  45  *  * In their class init function, they must override
  46  *    GST_TAG_DEMUX_CLASS(demux_klass)-&gt;identify_tag with their own identify
  47  *    function.
  48  *  * In their class init function, they must override
  49  *  GST_TAG_DEMUX_CLASS(demux_klass)-&gt;parse_tag with their own parse
  50  *  function.
  51  *  * In their class init function, they must also set
  52  *    GST_TAG_DEMUX_CLASS(demux_klass)-&gt;min_start_size and/or
  53  *  GST_TAG_DEMUX_CLASS(demux_klass)-&gt;min_end_size to the minimum size required
  54  *  for the identify function to decide whether the stream has a supported tag
  55  *  or not. A class parsing ID3v1 tags, for example, would set min_end_size to
  56  *  128 bytes.
  57  */
  58 
  59 #ifdef HAVE_CONFIG_H
  60 #include &quot;config.h&quot;
  61 #endif
  62 
  63 #include &quot;gsttagdemux.h&quot;
  64 
  65 #include &lt;gst/base/gsttypefindhelper.h&gt;
  66 #include &lt;gst/base/gstadapter.h&gt;
  67 #include &lt;gst/gst-i18n-plugin.h&gt;
  68 #include &lt;string.h&gt;
  69 
  70 typedef enum
  71 {
  72   GST_TAG_DEMUX_READ_START_TAG,
  73   GST_TAG_DEMUX_TYPEFINDING,
  74   GST_TAG_DEMUX_STREAMING
  75 } GstTagDemuxState;
  76 
  77 struct _GstTagDemuxPrivate
  78 {
  79   GstPad *srcpad;
  80   GstPad *sinkpad;
  81 
  82   /* Number of bytes to remove from the
  83    * start of file (tag at beginning) */
  84   guint strip_start;
  85 
  86   /* Number of bytes to remove from the
  87    * end of file (tag at end) */
  88   guint strip_end;
  89 
  90   gint64 upstream_size;
  91 
  92   GstTagDemuxState state;
  93   GstAdapter *adapter;
  94   GstBuffer *collect;
  95   gsize collect_size;
  96   guint tagsize;
  97   GstCaps *src_caps;
  98 
  99   GstTagList *event_tags;
 100   GstTagList *parsed_tags;
 101   gboolean send_tag_event;
 102 
 103   GstSegment segment;
 104   gboolean need_newseg;
 105 
 106   guint64 offset;
 107 
 108   GList *pending_events;
 109 };
 110 
 111 /* Require at least 8kB of data before we attempt typefind.
 112  * Seems a decent value based on test files
 113  * 40kB is massive overkill for the maximum, I think, but it
 114  * doesn&#39;t do any harm (tpm: increased to 64kB after watching
 115  * typefinding fail on a wavpack file that needed 42kB to succeed) */
 116 #define TYPE_FIND_MIN_SIZE 8192
 117 #define TYPE_FIND_MAX_SIZE 65536
 118 
 119 #define DEFAULT_PULL_BLOCKSIZE 4096
 120 
 121 GST_DEBUG_CATEGORY_STATIC (tagdemux_debug);
 122 #define GST_CAT_DEFAULT (tagdemux_debug)
 123 
 124 static GstStaticPadTemplate src_factory = GST_STATIC_PAD_TEMPLATE (&quot;src&quot;,
 125     GST_PAD_SRC,
 126     GST_PAD_ALWAYS,
 127     GST_STATIC_CAPS (&quot;ANY&quot;)
 128     );
 129 
 130 static void gst_tag_demux_element_loop (GstTagDemux * demux);
 131 
 132 static void gst_tag_demux_dispose (GObject * object);
 133 
 134 static GstFlowReturn gst_tag_demux_chain (GstPad * pad, GstObject * parent,
 135     GstBuffer * buf);
 136 static gboolean gst_tag_demux_sink_event (GstPad * pad, GstObject * parent,
 137     GstEvent * event);
 138 
 139 static gboolean gst_tag_demux_sink_activate_mode (GstPad * pad,
 140     GstObject * parent, GstPadMode mode, gboolean active);
 141 static gboolean gst_tag_demux_src_activate_mode (GstPad * pad,
 142     GstObject * parent, GstPadMode mode, gboolean active);
 143 static GstFlowReturn gst_tag_demux_read_range (GstTagDemux * tagdemux,
 144     GstObject * parent, guint64 offset, guint length, GstBuffer ** buffer);
 145 
 146 static GstFlowReturn gst_tag_demux_src_getrange (GstPad * srcpad,
 147     GstObject * parent, guint64 offset, guint length, GstBuffer ** buffer);
 148 
 149 static void gst_tag_demux_set_src_caps (GstTagDemux * tagdemux,
 150     GstCaps * new_caps);
 151 
 152 static gboolean gst_tag_demux_srcpad_event (GstPad * pad, GstObject * parent,
 153     GstEvent * event);
 154 static gboolean gst_tag_demux_sink_activate (GstPad * sinkpad,
 155     GstObject * parent);
 156 static GstStateChangeReturn gst_tag_demux_change_state (GstElement * element,
 157     GstStateChange transition);
 158 static gboolean gst_tag_demux_pad_query (GstPad * pad, GstObject * parent,
 159     GstQuery * query);
 160 static gboolean gst_tag_demux_get_upstream_size (GstTagDemux * tagdemux);
 161 static void gst_tag_demux_send_pending_events (GstTagDemux * tagdemux);
 162 static void gst_tag_demux_send_tag_event (GstTagDemux * tagdemux);
 163 static gboolean gst_tag_demux_send_new_segment (GstTagDemux * tagdemux);
 164 
 165 static void gst_tag_demux_base_init (gpointer g_class);
 166 static void gst_tag_demux_class_init (gpointer g_class, gpointer d);
 167 static void gst_tag_demux_init (GstTagDemux * obj, GstTagDemuxClass * klass);
 168 
 169 static gpointer parent_class;   /* NULL */
<a name="1" id="anc1"></a><span class="line-added"> 170 static gint private_offset = 0;</span>
 171 
 172 /* Cannot use boilerplate macros here because we want the abstract flag */
 173 GType
 174 gst_tag_demux_get_type (void)
 175 {
 176   static GType object_type;     /* 0 */
 177 
 178   if (object_type == 0) {
 179     static const GTypeInfo object_info = {
 180       sizeof (GstTagDemuxClass),
 181       gst_tag_demux_base_init,
 182       NULL,                     /* base_finalize */
 183       gst_tag_demux_class_init,
 184       NULL,                     /* class_finalize */
 185       NULL,                     /* class_data */
 186       sizeof (GstTagDemux),
 187       0,                        /* n_preallocs */
 188       (GInstanceInitFunc) gst_tag_demux_init
 189     };
 190 
 191     object_type = g_type_register_static (GST_TYPE_ELEMENT,
 192         &quot;GstTagDemux&quot;, &amp;object_info, G_TYPE_FLAG_ABSTRACT);
<a name="2" id="anc2"></a><span class="line-added"> 193 </span>
<span class="line-added"> 194     private_offset =</span>
<span class="line-added"> 195         g_type_add_instance_private (object_type, sizeof (GstTagDemuxPrivate));</span>
 196   }
 197 
 198   return object_type;
 199 }
 200 
<a name="3" id="anc3"></a><span class="line-added"> 201 static inline GstTagDemuxPrivate *</span>
<span class="line-added"> 202 gst_tag_demux_get_instance_private (GstTagDemux * self)</span>
<span class="line-added"> 203 {</span>
<span class="line-added"> 204   return (G_STRUCT_MEMBER_P (self, private_offset));</span>
<span class="line-added"> 205 }</span>
<span class="line-added"> 206 </span>
 207 static void
 208 gst_tag_demux_base_init (gpointer klass)
 209 {
 210   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 211 
 212   gst_element_class_add_static_pad_template (element_class, &amp;src_factory);
 213 
 214   GST_DEBUG_CATEGORY_INIT (tagdemux_debug, &quot;tagdemux&quot;, 0,
 215       &quot;tag demux base class&quot;);
 216 }
 217 
 218 static void
 219 gst_tag_demux_class_init (gpointer klass, gpointer d)
 220 {
 221   GstTagDemuxClass *tagdemux_class = GST_TAG_DEMUX_CLASS (klass);
 222   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 223   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 224 
 225   parent_class = g_type_class_peek_parent (klass);
 226 
 227   gobject_class-&gt;dispose = gst_tag_demux_dispose;
 228 
 229   element_class-&gt;change_state = GST_DEBUG_FUNCPTR (gst_tag_demux_change_state);
 230 
<a name="4" id="anc4"></a><span class="line-modified"> 231   if (private_offset != 0)</span>
<span class="line-added"> 232     g_type_class_adjust_private_offset (klass, &amp;private_offset);</span>
 233 
 234   /* subclasses must set at least one of these */
 235   tagdemux_class-&gt;min_start_size = 0;
 236   tagdemux_class-&gt;min_end_size = 0;
 237 }
 238 
 239 static void
 240 gst_tag_demux_reset (GstTagDemux * tagdemux)
 241 {
 242   GstBuffer **buffer_p = &amp;tagdemux-&gt;priv-&gt;collect;
 243   GstCaps **caps_p = &amp;tagdemux-&gt;priv-&gt;src_caps;
 244 
 245   tagdemux-&gt;priv-&gt;strip_start = 0;
 246   tagdemux-&gt;priv-&gt;strip_end = 0;
 247   tagdemux-&gt;priv-&gt;upstream_size = -1;
 248   tagdemux-&gt;priv-&gt;state = GST_TAG_DEMUX_READ_START_TAG;
 249   tagdemux-&gt;priv-&gt;send_tag_event = FALSE;
 250 
 251   gst_buffer_replace (buffer_p, NULL);
 252   tagdemux-&gt;priv-&gt;collect_size = 0;
 253   tagdemux-&gt;priv-&gt;tagsize = 0;
 254   gst_adapter_clear (tagdemux-&gt;priv-&gt;adapter);
 255   gst_caps_replace (caps_p, NULL);
 256 
 257   if (tagdemux-&gt;priv-&gt;event_tags) {
 258     gst_tag_list_unref (tagdemux-&gt;priv-&gt;event_tags);
 259     tagdemux-&gt;priv-&gt;event_tags = NULL;
 260   }
 261   if (tagdemux-&gt;priv-&gt;parsed_tags) {
 262     gst_tag_list_unref (tagdemux-&gt;priv-&gt;parsed_tags);
 263     tagdemux-&gt;priv-&gt;parsed_tags = NULL;
 264   }
 265 
 266   gst_segment_init (&amp;tagdemux-&gt;priv-&gt;segment, GST_FORMAT_UNDEFINED);
 267   tagdemux-&gt;priv-&gt;need_newseg = TRUE;
 268 
 269   g_list_foreach (tagdemux-&gt;priv-&gt;pending_events,
 270       (GFunc) gst_mini_object_unref, NULL);
 271   g_list_free (tagdemux-&gt;priv-&gt;pending_events);
 272   tagdemux-&gt;priv-&gt;pending_events = NULL;
 273 }
 274 
 275 static void
 276 gst_tag_demux_init (GstTagDemux * demux, GstTagDemuxClass * gclass)
 277 {
 278   GstElementClass *element_klass = GST_ELEMENT_CLASS (gclass);
 279   GstPadTemplate *tmpl;
 280 
<a name="5" id="anc5"></a><span class="line-modified"> 281   demux-&gt;priv = gst_tag_demux_get_instance_private (demux);</span>

 282 
 283   /* sink pad */
 284   tmpl = gst_element_class_get_pad_template (element_klass, &quot;sink&quot;);
 285   if (tmpl) {
 286     demux-&gt;priv-&gt;sinkpad = gst_pad_new_from_template (tmpl, &quot;sink&quot;);
 287 
 288     gst_pad_set_activatemode_function (demux-&gt;priv-&gt;sinkpad,
 289         GST_DEBUG_FUNCPTR (gst_tag_demux_sink_activate_mode));
 290     gst_pad_set_activate_function (demux-&gt;priv-&gt;sinkpad,
 291         GST_DEBUG_FUNCPTR (gst_tag_demux_sink_activate));
 292     gst_pad_set_event_function (demux-&gt;priv-&gt;sinkpad,
 293         GST_DEBUG_FUNCPTR (gst_tag_demux_sink_event));
 294     gst_pad_set_chain_function (demux-&gt;priv-&gt;sinkpad,
 295         GST_DEBUG_FUNCPTR (gst_tag_demux_chain));
 296     gst_element_add_pad (GST_ELEMENT (demux), demux-&gt;priv-&gt;sinkpad);
 297   } else {
 298     g_warning (&quot;GstTagDemux subclass %s must provide a sink pad template&quot;,
 299         G_OBJECT_TYPE_NAME (demux));
 300   }
 301 
 302   /* source pad */
 303   tmpl = gst_element_class_get_pad_template (element_klass, &quot;src&quot;);
 304   demux-&gt;priv-&gt;srcpad = gst_pad_new_from_template (tmpl, &quot;src&quot;);
 305   gst_pad_set_query_function (demux-&gt;priv-&gt;srcpad,
 306       GST_DEBUG_FUNCPTR (gst_tag_demux_pad_query));
 307   gst_pad_set_event_function (demux-&gt;priv-&gt;srcpad,
 308       GST_DEBUG_FUNCPTR (gst_tag_demux_srcpad_event));
 309   gst_pad_set_activatemode_function (demux-&gt;priv-&gt;srcpad,
 310       GST_DEBUG_FUNCPTR (gst_tag_demux_src_activate_mode));
 311   gst_pad_set_getrange_function (demux-&gt;priv-&gt;srcpad,
 312       GST_DEBUG_FUNCPTR (gst_tag_demux_src_getrange));
 313   gst_pad_use_fixed_caps (demux-&gt;priv-&gt;srcpad);
 314   gst_element_add_pad (GST_ELEMENT (demux), demux-&gt;priv-&gt;srcpad);
 315 
 316   demux-&gt;priv-&gt;adapter = gst_adapter_new ();
 317   gst_tag_demux_reset (demux);
 318 }
 319 
 320 static void
 321 gst_tag_demux_dispose (GObject * object)
 322 {
 323   GstTagDemux *tagdemux = GST_TAG_DEMUX (object);
 324 
 325   gst_tag_demux_reset (tagdemux);
 326   if (tagdemux-&gt;priv-&gt;adapter) {
 327     g_object_unref (tagdemux-&gt;priv-&gt;adapter);
 328     tagdemux-&gt;priv-&gt;adapter = NULL;
 329   }
 330 
 331   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
 332 }
 333 
 334 // FIXME: convert to set_caps / sending a caps event
 335 static void
 336 gst_tag_demux_set_src_caps (GstTagDemux * tagdemux, GstCaps * new_caps)
 337 {
 338   GstCaps *old_caps = tagdemux-&gt;priv-&gt;src_caps;
 339 
 340   if (old_caps == NULL || !gst_caps_is_equal (new_caps, old_caps)) {
 341     GstEvent *event;
 342 
 343     gst_caps_replace (&amp;tagdemux-&gt;priv-&gt;src_caps, new_caps);
 344 
<a name="6" id="anc6"></a><span class="line-modified"> 345     GST_DEBUG_OBJECT (tagdemux, &quot;Changing src pad caps to %&quot; GST_PTR_FORMAT,</span>
<span class="line-modified"> 346         tagdemux-&gt;priv-&gt;src_caps);</span>
 347 
 348     event =
 349         gst_pad_get_sticky_event (tagdemux-&gt;priv-&gt;sinkpad,
 350         GST_EVENT_STREAM_START, 0);
 351     if (!event) {
 352       gchar *stream_id = gst_pad_create_stream_id (tagdemux-&gt;priv-&gt;srcpad,
 353           GST_ELEMENT_CAST (tagdemux), NULL);
 354       GST_DEBUG_OBJECT (tagdemux, &quot;Creating new STREAM_START event&quot;);
 355       event = gst_event_new_stream_start (stream_id);
 356       g_free (stream_id);
 357       gst_event_set_group_id (event, gst_util_group_id_next ());
 358     }
 359     gst_pad_push_event (tagdemux-&gt;priv-&gt;srcpad, event);
 360 
 361     gst_pad_set_caps (tagdemux-&gt;priv-&gt;srcpad, tagdemux-&gt;priv-&gt;src_caps);
 362   } else {
 363     /* Caps never changed */
 364   }
 365 }
 366 
 367 /* will return FALSE if buffer is beyond end of data; will return TRUE
 368  * if buffer was trimmed successfully or didn&#39;t need trimming, but may
 369  * also return TRUE and set *buf_ref to NULL if the buffer was before
 370  * the start of the data */
 371 static gboolean
 372 gst_tag_demux_trim_buffer (GstTagDemux * tagdemux, GstBuffer ** buf_ref,
 373     gsize * buf_size)
 374 {
 375   GstBuffer *buf = *buf_ref;
 376 
 377   guint trim_start = 0;
 378   guint out_size, bsize;
 379   guint64 out_offset, boffset;
 380   gboolean need_sub = FALSE;
 381 
 382   bsize = out_size = gst_buffer_get_size (buf);
 383   boffset = out_offset = GST_BUFFER_OFFSET (buf);
 384 
 385   /* Adjust offset and length */
 386   if (!GST_BUFFER_OFFSET_IS_VALID (buf)) {
 387     /* Can&#39;t change anything without an offset */
 388     *buf_size = bsize;
 389     return TRUE;
 390   }
 391 
 392   /* If the buffer crosses the tag at the end of file, trim it */
 393   if (tagdemux-&gt;priv-&gt;strip_end &gt; 0) {
 394     if (gst_tag_demux_get_upstream_size (tagdemux)) {
 395       guint64 v1tag_offset =
 396           tagdemux-&gt;priv-&gt;upstream_size - tagdemux-&gt;priv-&gt;strip_end;
 397 
 398       if (out_offset &gt;= v1tag_offset) {
 399         GST_DEBUG_OBJECT (tagdemux, &quot;Buffer is past the end of the data&quot;);
 400         goto no_out_buffer_end;
 401       }
 402 
 403       if (out_offset + out_size &gt; v1tag_offset) {
 404         out_size = v1tag_offset - out_offset;
 405         need_sub = TRUE;
 406       }
 407     }
 408   }
 409 
 410   if (tagdemux-&gt;priv-&gt;strip_start &gt; 0) {
 411     /* If the buffer crosses the tag at the start of file, trim it */
 412     if (out_offset &lt;= tagdemux-&gt;priv-&gt;strip_start) {
 413       if (out_offset + out_size &lt;= tagdemux-&gt;priv-&gt;strip_start) {
 414         GST_DEBUG_OBJECT (tagdemux, &quot;Buffer is before the start of the data&quot;);
 415         goto no_out_buffer_start;
 416       }
 417 
 418       trim_start = tagdemux-&gt;priv-&gt;strip_start - out_offset;
 419       out_size -= trim_start;
 420       out_offset = 0;
 421     } else {
 422       out_offset -= tagdemux-&gt;priv-&gt;strip_start;
 423     }
 424     need_sub = TRUE;
 425   }
 426 
 427   if (need_sub) {
 428     if (out_size != bsize || !gst_buffer_is_writable (buf)) {
 429       GstBuffer *sub;
 430 
 431       GST_DEBUG_OBJECT (tagdemux, &quot;Sub-buffering to trim size %d offset %&quot;
 432           G_GINT64_FORMAT &quot; to %d offset %&quot; G_GINT64_FORMAT,
 433           bsize, boffset, out_size, out_offset);
 434 
 435       sub =
 436           gst_buffer_copy_region (buf, GST_BUFFER_COPY_ALL, trim_start,
 437           out_size);
 438       g_return_val_if_fail (sub != NULL, FALSE);
 439       if (GST_BUFFER_TIMESTAMP_IS_VALID (buf))
 440         GST_BUFFER_TIMESTAMP (sub) = GST_BUFFER_TIMESTAMP (buf);
 441       if (GST_BUFFER_DURATION_IS_VALID (buf))
 442         GST_BUFFER_DURATION (sub) = GST_BUFFER_DURATION (buf);
 443       gst_buffer_unref (buf);
 444       *buf_ref = buf = sub;
 445       *buf_size = out_size;
 446     } else {
 447       GST_DEBUG_OBJECT (tagdemux, &quot;Adjusting buffer from size %d offset %&quot;
 448           G_GINT64_FORMAT &quot; to %d offset %&quot; G_GINT64_FORMAT,
 449           bsize, boffset, out_size, out_offset);
 450     }
 451 
 452     GST_BUFFER_OFFSET (buf) = out_offset;
 453     GST_BUFFER_OFFSET_END (buf) = out_offset + out_size;
 454   }
 455 
 456   return TRUE;
 457 
 458 no_out_buffer_end:
 459   {
 460     gst_buffer_unref (buf);
 461     *buf_ref = NULL;
 462     return FALSE;
 463   }
 464 no_out_buffer_start:
 465   {
 466     gst_buffer_unref (buf);
 467     *buf_ref = NULL;
 468     return TRUE;
 469   }
 470 }
 471 
 472 static void
 473 update_collected (GstTagDemux * demux)
 474 {
 475   guint avail;
 476   GstBuffer *buf;
 477 
 478   avail = gst_adapter_available (demux-&gt;priv-&gt;adapter);
 479   if (avail == 0)
 480     return;
 481 
 482   buf = gst_adapter_take_buffer (demux-&gt;priv-&gt;adapter, avail);
 483 
 484   if (demux-&gt;priv-&gt;collect == NULL) {
 485     demux-&gt;priv-&gt;collect = buf;
 486   } else {
 487     demux-&gt;priv-&gt;collect = gst_buffer_append (demux-&gt;priv-&gt;collect, buf);
 488   }
 489   demux-&gt;priv-&gt;collect_size += avail;
 490 }
 491 
 492 static void
 493 gst_tag_demux_chain_parse_tag (GstTagDemux * demux)
 494 {
 495   GstBuffer *collect;
 496   GstTagDemuxResult parse_ret;
 497   GstTagDemuxClass *klass;
 498   guint tagsize = 0;
 499   guint available;
 500 
 501   available =
 502       demux-&gt;priv-&gt;collect_size + gst_adapter_available (demux-&gt;priv-&gt;adapter);
 503 
 504   klass = GST_TAG_DEMUX_CLASS (G_OBJECT_GET_CLASS (demux));
 505 
 506   if (available &lt; klass-&gt;min_start_size) {
 507     GST_DEBUG_OBJECT (demux, &quot;Only %u bytes available, but %u needed &quot;
 508         &quot;to identify tag&quot;, available, klass-&gt;min_start_size);
 509     return;                     /* wait for more data */
 510   }
 511 
 512   if (available &lt; demux-&gt;priv-&gt;tagsize) {
 513     GST_DEBUG_OBJECT (demux, &quot;Only %u bytes available, but %u needed &quot;
 514         &quot;to parse tag&quot;, available, demux-&gt;priv-&gt;tagsize);
 515     return;                     /* wait for more data */
 516   }
 517 
 518   update_collected (demux);
 519   demux-&gt;priv-&gt;collect = gst_buffer_make_writable (demux-&gt;priv-&gt;collect);
 520   collect = demux-&gt;priv-&gt;collect;
 521 
 522   g_assert (gst_buffer_is_writable (collect));
 523 
 524 
 525   /* If we receive a buffer that&#39;s from the middle of the file,
 526    * we can&#39;t read tags so move to typefinding */
 527   if (GST_BUFFER_OFFSET_IS_VALID (collect) &amp;&amp; GST_BUFFER_OFFSET (collect) != 0) {
 528     GST_DEBUG_OBJECT (demux, &quot;Received buffer from non-zero offset %&quot;
 529         G_GINT64_FORMAT &quot;. Can&#39;t read tags&quot;, GST_BUFFER_OFFSET (collect));
 530     demux-&gt;priv-&gt;state = GST_TAG_DEMUX_TYPEFINDING;
 531     return;
 532   }
 533 
 534   g_assert (klass-&gt;identify_tag != NULL);
 535   g_assert (klass-&gt;parse_tag != NULL);
 536 
 537   if (!klass-&gt;identify_tag (demux, collect, TRUE, &amp;tagsize)) {
 538     GST_DEBUG_OBJECT (demux, &quot;Could not identify start tag&quot;);
 539     demux-&gt;priv-&gt;state = GST_TAG_DEMUX_TYPEFINDING;
 540     return;
 541   }
 542 
 543   demux-&gt;priv-&gt;tagsize = tagsize;
 544 
 545   /* need to set offset of first buffer to 0 or trimming won&#39;t work */
 546   if (!GST_BUFFER_OFFSET_IS_VALID (collect)) {
 547     GST_WARNING_OBJECT (demux, &quot;Fixing up first buffer without offset&quot;);
 548     GST_BUFFER_OFFSET (collect) = 0;
 549   }
 550 
 551   GST_DEBUG_OBJECT (demux, &quot;Identified tag, size = %u bytes&quot;, tagsize);
 552 
 553   do {
 554     GstTagList *tags = NULL;
 555     guint newsize, saved_size;
 556 
 557     demux-&gt;priv-&gt;strip_start = tagsize;
 558 
 559     if (available &lt; tagsize) {
 560       GST_DEBUG_OBJECT (demux, &quot;Only %u bytes available, but %u needed &quot;
 561           &quot;to parse tag&quot;, available, tagsize);
 562       return;                   /* wait for more data */
 563     }
 564 
 565     saved_size = gst_buffer_get_size (collect);
 566     gst_buffer_set_size (collect, tagsize);
 567     newsize = tagsize;
 568 
 569     parse_ret = klass-&gt;parse_tag (demux, collect, TRUE, &amp;newsize, &amp;tags);
 570 
 571     gst_buffer_set_size (collect, saved_size);
 572 
 573     switch (parse_ret) {
 574       case GST_TAG_DEMUX_RESULT_OK:
 575         demux-&gt;priv-&gt;strip_start = newsize;
 576         demux-&gt;priv-&gt;parsed_tags = tags;
 577         GST_DEBUG_OBJECT (demux, &quot;Read start tag of size %u&quot;, newsize);
 578         break;
 579       case GST_TAG_DEMUX_RESULT_BROKEN_TAG:
 580         demux-&gt;priv-&gt;strip_start = newsize;
 581         demux-&gt;priv-&gt;parsed_tags = tags;
 582         GST_WARNING_OBJECT (demux, &quot;Ignoring broken start tag of size %d&quot;,
 583             demux-&gt;priv-&gt;strip_start);
 584         break;
 585       case GST_TAG_DEMUX_RESULT_AGAIN:
 586         GST_DEBUG_OBJECT (demux, &quot;Re-parse, this time with %u bytes&quot;, newsize);
 587         g_assert (newsize != tagsize);
 588         tagsize = newsize;
 589         break;
 590     }
 591   } while (parse_ret == GST_TAG_DEMUX_RESULT_AGAIN);
 592 
 593   GST_LOG_OBJECT (demux, &quot;Parsed tag. Proceeding to typefinding&quot;);
 594   demux-&gt;priv-&gt;state = GST_TAG_DEMUX_TYPEFINDING;
 595   demux-&gt;priv-&gt;send_tag_event = TRUE;
 596 }
 597 
 598 static GstFlowReturn
 599 gst_tag_demux_chain_buffer (GstTagDemux * demux, GstBuffer * buf,
 600     gboolean at_eos)
 601 {
 602   gsize size;
 603 
 604   size = gst_buffer_get_size (buf);
 605 
 606   /* Update our segment position info */
 607   if (demux-&gt;priv-&gt;segment.format == GST_FORMAT_BYTES) {
 608     if (GST_BUFFER_OFFSET_IS_VALID (buf))
 609       demux-&gt;priv-&gt;segment.position = GST_BUFFER_OFFSET (buf);
 610     demux-&gt;priv-&gt;segment.position += size;
 611   } else if (demux-&gt;priv-&gt;segment.format == GST_FORMAT_TIME) {
 612     if (GST_BUFFER_TIMESTAMP_IS_VALID (buf))
 613       demux-&gt;priv-&gt;segment.position = GST_BUFFER_TIMESTAMP (buf);
 614     if (GST_BUFFER_DURATION_IS_VALID (buf))
 615       demux-&gt;priv-&gt;segment.position += GST_BUFFER_DURATION (buf);
 616   }
 617 
 618   gst_adapter_push (demux-&gt;priv-&gt;adapter, buf);
 619   buf = NULL;
 620 
 621   switch (demux-&gt;priv-&gt;state) {
 622     case GST_TAG_DEMUX_READ_START_TAG:
 623       gst_tag_demux_chain_parse_tag (demux);
 624       if (demux-&gt;priv-&gt;state != GST_TAG_DEMUX_TYPEFINDING)
 625         break;
 626       /* Fall-through */
 627     case GST_TAG_DEMUX_TYPEFINDING:{
 628       GstTypeFindProbability probability = 0;
 629       GstBuffer *typefind_buf = NULL;
 630       gsize typefind_size;
 631       GstCaps *caps;
 632 
 633       update_collected (demux);
 634 
 635       if (!at_eos &amp;&amp; demux-&gt;priv-&gt;collect_size &lt;
 636           TYPE_FIND_MIN_SIZE + demux-&gt;priv-&gt;strip_start)
 637         break;                  /* Go get more data first */
 638 
 639       GST_DEBUG_OBJECT (demux, &quot;Typefinding with size %&quot; G_GSIZE_FORMAT,
 640           demux-&gt;priv-&gt;collect_size);
 641 
 642       /* Trim the buffer and adjust offset for typefinding */
 643       typefind_buf = demux-&gt;priv-&gt;collect;
 644       gst_buffer_ref (typefind_buf);
 645       if (!gst_tag_demux_trim_buffer (demux, &amp;typefind_buf, &amp;typefind_size))
 646         return GST_FLOW_EOS;
 647 
 648       if (typefind_buf == NULL)
 649         break;                  /* Still need more data */
 650 
 651       caps = gst_type_find_helper_for_buffer (GST_OBJECT (demux),
 652           typefind_buf, &amp;probability);
 653 
 654       if (caps == NULL) {
 655         if (typefind_size &lt; TYPE_FIND_MAX_SIZE) {
 656           /* Just break for more data */
 657           gst_buffer_unref (typefind_buf);
 658           return GST_FLOW_OK;
 659         }
 660 
 661         /* We failed typefind */
 662         GST_ELEMENT_ERROR (demux, STREAM, TYPE_NOT_FOUND, (NULL),
 663             (&quot;Could not detect type for contents within tag&quot;));
 664         gst_buffer_unref (typefind_buf);
 665         gst_buffer_unref (demux-&gt;priv-&gt;collect);
 666         demux-&gt;priv-&gt;collect = NULL;
 667         demux-&gt;priv-&gt;collect_size = 0;
 668         return GST_FLOW_ERROR;
 669       }
 670       gst_buffer_unref (typefind_buf);
 671 
 672       GST_DEBUG_OBJECT (demux, &quot;Found type %&quot; GST_PTR_FORMAT &quot; with a &quot;
 673           &quot;probability of %u&quot;, caps, probability);
 674 
 675       gst_tag_demux_set_src_caps (demux, caps);
<a name="7" id="anc7"></a><span class="line-modified"> 676       gst_caps_unref (caps);</span>
 677 
 678       /* Move onto streaming and fall-through to push out existing
 679        * data */
 680       demux-&gt;priv-&gt;state = GST_TAG_DEMUX_STREAMING;
 681       /* fall-through */
 682     }
 683     case GST_TAG_DEMUX_STREAMING:{
 684       GstBuffer *outbuf = NULL;
 685       gsize outbuf_size;
 686 
 687       update_collected (demux);
 688 
 689       /* Trim the buffer and adjust offset */
 690       if (demux-&gt;priv-&gt;collect) {
 691         outbuf = demux-&gt;priv-&gt;collect;
 692         demux-&gt;priv-&gt;collect = NULL;
 693         demux-&gt;priv-&gt;collect_size = 0;
 694         if (!gst_tag_demux_trim_buffer (demux, &amp;outbuf, &amp;outbuf_size))
 695           return GST_FLOW_EOS;
 696       }
 697       if (outbuf) {
 698         /* Might need a new segment before the buffer */
 699         if (demux-&gt;priv-&gt;need_newseg) {
 700           if (!gst_tag_demux_send_new_segment (demux)) {
 701             GST_WARNING_OBJECT (demux, &quot;Downstream did not handle newsegment &quot;
 702                 &quot;event as it should&quot;);
 703           }
 704           demux-&gt;priv-&gt;need_newseg = FALSE;
 705         }
 706 
 707         /* send any pending events we cached */
 708         gst_tag_demux_send_pending_events (demux);
 709 
 710         /* Send our own pending tag event */
 711         if (demux-&gt;priv-&gt;send_tag_event) {
 712           gst_tag_demux_send_tag_event (demux);
 713           demux-&gt;priv-&gt;send_tag_event = FALSE;
 714         }
 715 
 716         GST_LOG_OBJECT (demux, &quot;Pushing buffer %&quot; GST_PTR_FORMAT, outbuf);
 717 
 718         return gst_pad_push (demux-&gt;priv-&gt;srcpad, outbuf);
 719       }
 720     }
 721   }
 722   return GST_FLOW_OK;
 723 }
 724 
 725 static GstFlowReturn
 726 gst_tag_demux_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
 727 {
 728   return gst_tag_demux_chain_buffer (GST_TAG_DEMUX (parent), buf, FALSE);
 729 }
 730 
 731 static gboolean
 732 gst_tag_demux_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
 733 {
 734   GstTagDemux *demux;
 735   gboolean ret;
 736 
 737   demux = GST_TAG_DEMUX (parent);
 738 
 739   switch (GST_EVENT_TYPE (event)) {
 740     case GST_EVENT_EOS:
 741       if (!gst_pad_has_current_caps (demux-&gt;priv-&gt;srcpad)) {
 742         GST_INFO_OBJECT (demux, &quot;EOS before we found a type&quot;);
 743 
 744         /* push final buffer with eos indication to force typefinding */
 745         gst_tag_demux_chain_buffer (demux, gst_buffer_new (), TRUE);
 746 
 747         if (!gst_pad_has_current_caps (demux-&gt;priv-&gt;srcpad)) {
<a name="8" id="anc8"></a><span class="line-modified"> 748           GST_ELEMENT_ERROR (demux, STREAM, TYPE_NOT_FOUND, (NULL), (NULL));</span>
<span class="line-modified"> 749         }</span>
 750       }
 751       ret = gst_pad_event_default (pad, parent, event);
 752       break;
 753     case GST_EVENT_SEGMENT:
 754     {
 755       gst_event_copy_segment (event, &amp;demux-&gt;priv-&gt;segment);
 756 
 757       demux-&gt;priv-&gt;need_newseg = TRUE;
 758       gst_event_unref (event);
 759       ret = TRUE;
 760       break;
 761     }
 762     case GST_EVENT_FLUSH_STOP:
 763     case GST_EVENT_FLUSH_START:
 764       ret = gst_pad_event_default (pad, parent, event);
 765       break;
 766     case GST_EVENT_CAPS:
 767       /* we drop the caps event. We do typefind and push a new caps event. */
 768       ret = gst_pad_event_default (pad, parent, event);
 769       break;
 770     default:
 771       if (demux-&gt;priv-&gt;need_newseg &amp;&amp; GST_EVENT_IS_SERIALIZED (event)) {
 772         /* Cache all events if we have a pending segment, so they don&#39;t get
 773          * lost (esp. tag events) */
 774         GST_INFO_OBJECT (demux, &quot;caching event: %&quot; GST_PTR_FORMAT, event);
 775         GST_OBJECT_LOCK (demux);
 776         demux-&gt;priv-&gt;pending_events =
 777             g_list_append (demux-&gt;priv-&gt;pending_events, event);
 778         GST_OBJECT_UNLOCK (demux);
 779         ret = TRUE;
 780       } else {
 781         ret = gst_pad_event_default (pad, parent, event);
 782       }
 783       break;
 784   }
 785 
 786   return ret;
 787 }
 788 
 789 static gboolean
 790 gst_tag_demux_get_upstream_size (GstTagDemux * tagdemux)
 791 {
 792   gint64 len;
 793 
 794   /* Short-cut if we already queried upstream */
 795   if (tagdemux-&gt;priv-&gt;upstream_size &gt; 0)
 796     return TRUE;
 797 
 798   if (!gst_pad_peer_query_duration (tagdemux-&gt;priv-&gt;sinkpad, GST_FORMAT_BYTES,
 799           &amp;len) || len &lt;= 0) {
 800     return FALSE;
 801   }
 802 
 803   tagdemux-&gt;priv-&gt;upstream_size = len;
 804   return TRUE;
 805 }
 806 
 807 static gboolean
 808 gst_tag_demux_seek_pull (GstTagDemux * tagdemux, GstEvent * event)
 809 {
 810   GstSeekFlags flags;
 811   GstSeekType start_type, stop_type;
 812   GstFormat format;
 813   gboolean flush;
 814   gdouble rate;
 815   gint64 start, stop;
 816   GstSegment seeksegment = { 0, };
 817 
 818   gst_event_parse_seek (event, &amp;rate, &amp;format, &amp;flags, &amp;start_type, &amp;start,
 819       &amp;stop_type, &amp;stop);
 820 
 821   /* we can only seek on bytes */
 822   if (format != GST_FORMAT_BYTES) {
 823     GST_DEBUG_OBJECT (tagdemux, &quot;Can only seek on BYTES&quot;);
 824     return FALSE;
 825   }
 826 
 827   if (tagdemux-&gt;priv-&gt;state != GST_TAG_DEMUX_STREAMING) {
 828     GST_DEBUG_OBJECT (tagdemux, &quot;Can only seek if streaming already&quot;);
 829     return FALSE;
 830   }
 831 
 832   switch (start_type) {
 833     case GST_SEEK_TYPE_SET:
 834       if (start == -1)
 835         start = 0;
 836       start += tagdemux-&gt;priv-&gt;strip_start;
 837       break;
 838     case GST_SEEK_TYPE_END:
 839       /* Adjust the seek to be relative to the start of any end tag
 840        * (note: 10 bytes before end is represented by stop=-10) */
 841       if (start &gt; 0)
 842         start = 0;
 843       start -= tagdemux-&gt;priv-&gt;strip_end;
 844       break;
 845     case GST_SEEK_TYPE_NONE:
 846     default:
 847       break;
 848   }
 849   switch (stop_type) {
 850     case GST_SEEK_TYPE_SET:
 851       if (stop != -1) {
 852         /* -1 means the end of the file, pass it upstream intact */
 853         stop += tagdemux-&gt;priv-&gt;strip_start;
 854       }
 855       break;
 856     case GST_SEEK_TYPE_END:
 857       /* Adjust the seek to be relative to the start of any end tag
 858        * (note: 10 bytes before end is represented by stop=-10) */
 859       if (stop &gt; 0)
 860         stop = 0;
 861       stop -= tagdemux-&gt;priv-&gt;strip_end;
 862       break;
 863     case GST_SEEK_TYPE_NONE:
 864     default:
 865       break;
 866   }
 867 
 868   /* copy segment, we need this because we still need the old
 869    * segment when we close the current segment. */
 870   memcpy (&amp;seeksegment, &amp;tagdemux-&gt;priv-&gt;segment, sizeof (GstSegment));
 871 
 872   GST_DEBUG_OBJECT (tagdemux, &quot;configuring seek&quot;);
 873   gst_segment_do_seek (&amp;seeksegment, rate, format, flags,
 874       start_type, start, stop_type, stop, NULL);
 875 
 876   flush = ! !(flags &amp; GST_SEEK_FLAG_FLUSH);
 877 
 878   GST_DEBUG_OBJECT (tagdemux, &quot;New segment %&quot; GST_SEGMENT_FORMAT, &amp;seeksegment);
 879 
 880   if (flush) {
 881     GST_DEBUG_OBJECT (tagdemux, &quot;Starting flush&quot;);
 882     gst_pad_push_event (tagdemux-&gt;priv-&gt;sinkpad, gst_event_new_flush_start ());
 883     gst_pad_push_event (tagdemux-&gt;priv-&gt;srcpad, gst_event_new_flush_start ());
 884   } else {
 885     GST_DEBUG_OBJECT (tagdemux, &quot;Non-flushing seek, pausing task&quot;);
 886     gst_pad_pause_task (tagdemux-&gt;priv-&gt;sinkpad);
 887   }
 888 
 889   /* now grab the stream lock so that streaming cannot continue, for
 890    * non flushing seeks when the element is in PAUSED this could block
 891    * forever. */
 892   GST_DEBUG_OBJECT (tagdemux, &quot;Waiting for streaming to stop&quot;);
 893   GST_PAD_STREAM_LOCK (tagdemux-&gt;priv-&gt;sinkpad);
 894 
 895   if (flush) {
 896     GST_DEBUG_OBJECT (tagdemux, &quot;Stopping flush&quot;);
 897     gst_pad_push_event (tagdemux-&gt;priv-&gt;sinkpad,
 898         gst_event_new_flush_stop (TRUE));
 899     gst_pad_push_event (tagdemux-&gt;priv-&gt;srcpad,
 900         gst_event_new_flush_stop (TRUE));
 901   }
 902 
 903   /* now update the real segment info */
 904   GST_DEBUG_OBJECT (tagdemux, &quot;Committing new seek segment&quot;);
 905   memcpy (&amp;tagdemux-&gt;priv-&gt;segment, &amp;seeksegment, sizeof (GstSegment));
 906   tagdemux-&gt;priv-&gt;offset = tagdemux-&gt;priv-&gt;segment.start;
 907 
 908   /* notify start of new segment */
 909   if (tagdemux-&gt;priv-&gt;segment.flags &amp; GST_SEGMENT_FLAG_SEGMENT) {
 910     GstMessage *msg;
 911 
 912     msg = gst_message_new_segment_start (GST_OBJECT (tagdemux),
 913         GST_FORMAT_BYTES, tagdemux-&gt;priv-&gt;segment.start);
 914     gst_element_post_message (GST_ELEMENT (tagdemux), msg);
 915   }
 916 
 917   tagdemux-&gt;priv-&gt;need_newseg = TRUE;
 918 
 919   /* restart our task since it might have been stopped when we did the
 920    * flush. */
 921   gst_pad_start_task (tagdemux-&gt;priv-&gt;sinkpad,
 922       (GstTaskFunction) gst_tag_demux_element_loop, tagdemux, NULL);
 923 
 924   /* streaming can continue now */
 925   GST_PAD_STREAM_UNLOCK (tagdemux-&gt;priv-&gt;sinkpad);
 926 
 927   return TRUE;
 928 }
 929 
 930 static gboolean
 931 gst_tag_demux_seek_push (GstTagDemux * tagdemux, GstEvent * event)
 932 {
 933   gboolean res = FALSE;
<a name="9" id="anc9"></a><span class="line-modified"> 934   gdouble rate;</span>
<span class="line-modified"> 935   GstFormat format;</span>
 936   GstSeekType start_type, stop_type;
<a name="10" id="anc10"></a><span class="line-modified"> 937   GstSeekFlags flags;</span>
 938   gint64 start, stop;
 939 
<a name="11" id="anc11"></a><span class="line-modified"> 940   gst_event_parse_seek (event, &amp;rate, &amp;format, &amp;flags,</span>
 941       &amp;start_type, &amp;start, &amp;stop_type, &amp;stop);
 942 
<a name="12" id="anc12"></a><span class="line-modified"> 943   if (format == GST_FORMAT_BYTES &amp;&amp;</span>
<span class="line-modified"> 944       tagdemux-&gt;priv-&gt;state == GST_TAG_DEMUX_STREAMING &amp;&amp;</span>
<span class="line-modified"> 945       gst_pad_is_linked (tagdemux-&gt;priv-&gt;sinkpad)) {</span>
<span class="line-modified"> 946     GstEvent *upstream;</span>
 947 
 948     switch (start_type) {
<a name="13" id="anc13"></a><span class="line-modified"> 949       case GST_SEEK_TYPE_SET:</span>
 950         if (start == -1)
 951           start = 0;
 952         start += tagdemux-&gt;priv-&gt;strip_start;
<a name="14" id="anc14"></a><span class="line-modified"> 953         break;</span>
<span class="line-modified"> 954       case GST_SEEK_TYPE_END:</span>
<span class="line-modified"> 955         /* Adjust the seek to be relative to the start of any end tag</span>
<span class="line-modified"> 956          * (note: 10 bytes before end is represented by stop=-10) */</span>
 957         if (start &gt; 0)
 958           start = 0;
 959         start -= tagdemux-&gt;priv-&gt;strip_end;
<a name="15" id="anc15"></a><span class="line-modified"> 960         break;</span>
<span class="line-modified"> 961       case GST_SEEK_TYPE_NONE:</span>
<span class="line-modified"> 962       default:</span>
<span class="line-modified"> 963         break;</span>
<span class="line-modified"> 964     }</span>
<span class="line-modified"> 965     switch (stop_type) {</span>
<span class="line-modified"> 966       case GST_SEEK_TYPE_SET:</span>
<span class="line-modified"> 967         if (stop != -1) {</span>
<span class="line-modified"> 968           /* -1 means the end of the file, pass it upstream intact */</span>
<span class="line-modified"> 969           stop += tagdemux-&gt;priv-&gt;strip_start;</span>












 970         }
<a name="16" id="anc16"></a><span class="line-modified"> 971         break;</span>
<span class="line-added"> 972       case GST_SEEK_TYPE_END:</span>
<span class="line-added"> 973         /* Adjust the seek to be relative to the start of any end tag</span>
<span class="line-added"> 974          * (note: 10 bytes before end is represented by stop=-10) */</span>
<span class="line-added"> 975         if (stop &gt; 0)</span>
<span class="line-added"> 976           stop = 0;</span>
<span class="line-added"> 977         stop -= tagdemux-&gt;priv-&gt;strip_end;</span>
<span class="line-added"> 978         break;</span>
<span class="line-added"> 979       case GST_SEEK_TYPE_NONE:</span>
<span class="line-added"> 980       default:</span>
<span class="line-added"> 981         break;</span>
<span class="line-added"> 982     }</span>
<span class="line-added"> 983     upstream = gst_event_new_seek (rate, format, flags,</span>
 984         start_type, start, stop_type, stop);
<a name="17" id="anc17"></a><span class="line-modified"> 985     res = gst_pad_push_event (tagdemux-&gt;priv-&gt;sinkpad, upstream);</span>
 986   } else if (format == GST_FORMAT_TIME &amp;&amp;
 987       tagdemux-&gt;priv-&gt;state == GST_TAG_DEMUX_STREAMING &amp;&amp;
 988       gst_pad_is_linked (tagdemux-&gt;priv-&gt;sinkpad)) {
 989     res = gst_pad_push_event (tagdemux-&gt;priv-&gt;sinkpad, gst_event_ref (event));
<a name="18" id="anc18"></a><span class="line-modified"> 990   }</span>
 991 
 992   return res;
 993 }
 994 
 995 static gboolean
 996 gst_tag_demux_srcpad_event (GstPad * pad, GstObject * parent, GstEvent * event)
 997 {
 998   GstTagDemux *tagdemux;
 999   gboolean res = FALSE;
1000 
1001   tagdemux = GST_TAG_DEMUX (parent);
1002 
1003   /* Handle SEEK events, with adjusted byte offsets and sizes. */
1004 
1005   switch (GST_EVENT_TYPE (event)) {
1006     case GST_EVENT_SEEK:
1007     {
1008       if (GST_PAD_MODE (tagdemux-&gt;priv-&gt;sinkpad) == GST_PAD_MODE_PUSH)
1009         res = gst_tag_demux_seek_push (tagdemux, event);
1010       else
1011         res = gst_tag_demux_seek_pull (tagdemux, event);
1012       break;
1013     }
1014 #ifdef GSTREAMER_LITE
1015     // We need to pass down any flush events. We should not cache flush events.
1016     // In some cases we may have two seek command executing sequentially and it will result to following event sequence:
1017     // Seek 1
1018     // GST_EVENT_FLUSH_START - Pass down
1019     // GST_EVENT_FLUSH_STOP - Pass down
1020     // GST_EVENT_NEWSEGMENT - Cached and demux-&gt;priv-&gt;need_newseg is TRUE
1021     // Seek 2
1022     // GST_EVENT_FLUSH_START - Cached, because demux-&gt;priv-&gt;need_newseg is TRUE
1023     // GST_EVENT_FLUSH_STOP - Cached, because demux-&gt;priv-&gt;need_newseg is TRUE
1024     // GST_EVENT_NEWSEGMENT - Overwrites cached NEWSEGMENT from seek 1 and demux-&gt;priv-&gt;need_newseg is TRUE
1025     // Data buffer received by tag demux
1026     // Delivering in following sequence GST_EVENT_NEWSEGMENT, GST_EVENT_FLUSH_START, GST_EVENT_FLUSH_STOP and Data Buffer (Issue: Data Buffer without new segment)
1027     case GST_EVENT_FLUSH_START:
1028         res = gst_pad_event_default (pad, parent, event);
1029         break;
1030     case GST_EVENT_FLUSH_STOP:
1031         res = gst_pad_event_default (pad, parent, event);
1032         break;
1033 #endif // GSTREAMER_LITE
1034     default:
1035       res = gst_pad_push_event (tagdemux-&gt;priv-&gt;sinkpad, event);
1036       event = NULL;
1037       break;
1038   }
1039 
1040   if (event)
1041     gst_event_unref (event);
1042 
1043   return res;
1044 }
1045 
1046 /* Read and interpret any end tag when activating in pull_range.
1047  * Returns FALSE if pad activation should fail. */
1048 static GstFlowReturn
1049 gst_tag_demux_pull_end_tag (GstTagDemux * demux, GstTagList ** tags)
1050 {
1051   GstTagDemuxResult parse_ret;
1052   GstTagDemuxClass *klass;
1053   GstFlowReturn flow_ret;
1054   GstTagList *new_tags = NULL;
1055   GstBuffer *buffer = NULL;
1056   gboolean have_tag;
1057   guint64 offset;
1058   guint tagsize;
1059   gsize bsize;
1060 
1061   klass = GST_TAG_DEMUX_CLASS (G_OBJECT_GET_CLASS (demux));
1062 
1063   g_assert (klass-&gt;identify_tag != NULL);
1064   g_assert (klass-&gt;parse_tag != NULL);
1065 
1066   if (klass-&gt;min_end_size == 0) {
1067     GST_DEBUG_OBJECT (demux, &quot;Not looking for tag at the end&quot;);
1068     return GST_FLOW_OK;
1069   }
1070 
1071   if (demux-&gt;priv-&gt;upstream_size &lt; klass-&gt;min_end_size) {
1072     GST_DEBUG_OBJECT (demux, &quot;File too small&quot;);
1073     return GST_FLOW_OK;
1074   }
1075 
1076   /* Pull enough to identify the tag and retrieve its total size */
1077   offset = demux-&gt;priv-&gt;upstream_size - klass-&gt;min_end_size;
1078 
1079   flow_ret = gst_pad_pull_range (demux-&gt;priv-&gt;sinkpad, offset,
1080       klass-&gt;min_end_size, &amp;buffer);
1081 
1082   if (flow_ret != GST_FLOW_OK) {
1083     GST_DEBUG_OBJECT (demux, &quot;Could not read tag header from end of file, &quot;
1084         &quot;ret = %s&quot;, gst_flow_get_name (flow_ret));
1085     goto done;
1086   }
1087 
1088   bsize = gst_buffer_get_size (buffer);
1089 
1090   if (bsize &lt; klass-&gt;min_end_size) {
1091     GST_DEBUG_OBJECT (demux, &quot;Only managed to read %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
1092         &quot;from file (required: %u bytes)&quot;, bsize, klass-&gt;min_end_size);
1093     flow_ret = GST_FLOW_EOS;
1094     goto done;
1095   }
1096 
1097   have_tag = klass-&gt;identify_tag (demux, buffer, FALSE, &amp;tagsize);
1098 
1099   if (!have_tag) {
1100     GST_DEBUG_OBJECT (demux, &quot;Could not find tag at end&quot;);
1101     flow_ret = GST_FLOW_OK;
1102     goto done;
1103   }
1104 
1105   /* Now pull the entire tag */
1106   do {
1107     guint newsize, saved_size;
1108 
1109     GST_DEBUG_OBJECT (demux, &quot;Identified tag at end, size=%u bytes&quot;, tagsize);
1110 
1111     demux-&gt;priv-&gt;strip_end = tagsize;
1112 
1113     g_assert (tagsize &gt;= klass-&gt;min_end_size);
1114 
1115     /* Get buffer that&#39;s exactly the requested size */
1116     if (bsize != tagsize) {
1117       gst_buffer_unref (buffer);
1118       buffer = NULL;
1119 
1120       offset = demux-&gt;priv-&gt;upstream_size - tagsize;
1121 
1122       flow_ret = gst_pad_pull_range (demux-&gt;priv-&gt;sinkpad, offset,
1123           tagsize, &amp;buffer);
1124 
1125       if (flow_ret != GST_FLOW_OK) {
1126         GST_DEBUG_OBJECT (demux, &quot;Could not read data from end of file at &quot;
1127             &quot;offset %&quot; G_GUINT64_FORMAT &quot;. ret = %s&quot;, offset,
1128             gst_flow_get_name (flow_ret));
1129         goto done;
1130       }
1131 
1132       bsize = gst_buffer_get_size (buffer);
1133 
1134       if (bsize &lt; tagsize) {
1135         GST_DEBUG_OBJECT (demux, &quot;Only managed to read %&quot; G_GSIZE_FORMAT
1136             &quot; bytes from file&quot;, bsize);
1137         flow_ret = GST_FLOW_EOS;
1138         goto done;
1139       }
1140     }
1141 
1142     GST_BUFFER_OFFSET (buffer) = offset;
1143 
1144     saved_size = bsize;
1145     gst_buffer_set_size (buffer, tagsize);
1146     newsize = tagsize;
1147 
1148     parse_ret = klass-&gt;parse_tag (demux, buffer, FALSE, &amp;newsize, &amp;new_tags);
1149 
1150     gst_buffer_set_size (buffer, saved_size);
1151 
1152     switch (parse_ret) {
1153       case GST_TAG_DEMUX_RESULT_OK:
1154         flow_ret = GST_FLOW_OK;
1155         demux-&gt;priv-&gt;strip_end = newsize;
1156         GST_DEBUG_OBJECT (demux, &quot;Read tag at end, size %d&quot;,
1157             demux-&gt;priv-&gt;strip_end);
1158         break;
1159       case GST_TAG_DEMUX_RESULT_BROKEN_TAG:
1160         flow_ret = GST_FLOW_OK;
1161         demux-&gt;priv-&gt;strip_end = newsize;
1162         GST_WARNING_OBJECT (demux, &quot;Ignoring broken tag at end, size %d&quot;,
1163             demux-&gt;priv-&gt;strip_end);
1164         break;
1165       case GST_TAG_DEMUX_RESULT_AGAIN:
1166         GST_DEBUG_OBJECT (demux, &quot;Re-parse, this time with %d bytes&quot;, newsize);
1167         g_assert (newsize != tagsize);
1168         tagsize = newsize;
1169         break;
1170     }
1171   } while (parse_ret == GST_TAG_DEMUX_RESULT_AGAIN);
1172 
1173   *tags = new_tags;
1174   new_tags = NULL;
1175 
1176 done:
1177   if (new_tags)
1178     gst_tag_list_unref (new_tags);
1179   if (buffer)
1180     gst_buffer_unref (buffer);
1181   return flow_ret;
1182 }
1183 
1184 /* Read and interpret any tag at the start when activating in
1185  * pull_range. Returns FALSE if pad activation should fail. */
1186 static GstFlowReturn
1187 gst_tag_demux_pull_start_tag (GstTagDemux * demux, GstTagList ** tags)
1188 {
1189   GstTagDemuxResult parse_ret;
1190   GstTagDemuxClass *klass;
1191   GstFlowReturn flow_ret;
1192   GstTagList *new_tags = NULL;
1193   GstBuffer *buffer = NULL;
1194   gboolean have_tag;
1195   guint req, tagsize;
1196   gsize bsize;
1197 
1198   klass = GST_TAG_DEMUX_CLASS (G_OBJECT_GET_CLASS (demux));
1199 
1200   g_assert (klass-&gt;identify_tag != NULL);
1201   g_assert (klass-&gt;parse_tag != NULL);
1202 
1203   if (klass-&gt;min_start_size == 0) {
1204     GST_DEBUG_OBJECT (demux, &quot;Not looking for tag at the beginning&quot;);
1205     return GST_FLOW_OK;
1206   }
1207 
1208   /* Handle tag at start. Try with 4kB to start with */
1209   req = MAX (klass-&gt;min_start_size, 4096);
1210 
1211   /* Pull enough to identify the tag and retrieve its total size */
1212   flow_ret = gst_pad_pull_range (demux-&gt;priv-&gt;sinkpad, 0, req, &amp;buffer);
1213   if (flow_ret != GST_FLOW_OK) {
1214     GST_DEBUG_OBJECT (demux, &quot;Could not read data from start of file ret=%s&quot;,
1215         gst_flow_get_name (flow_ret));
1216     goto done;
1217   }
1218 
1219   bsize = gst_buffer_get_size (buffer);
1220 
1221   if (bsize &lt; klass-&gt;min_start_size) {
1222     GST_DEBUG_OBJECT (demux, &quot;Only managed to read %&quot; G_GSIZE_FORMAT
1223         &quot; bytes from file - no tag in this file&quot;, bsize);
1224     flow_ret = GST_FLOW_EOS;
1225     goto done;
1226   }
1227 
1228   have_tag = klass-&gt;identify_tag (demux, buffer, TRUE, &amp;tagsize);
1229 
1230   if (!have_tag) {
1231     GST_DEBUG_OBJECT (demux, &quot;Could not find start tag&quot;);
1232     flow_ret = GST_FLOW_OK;
1233     goto done;
1234   }
1235 
1236   GST_DEBUG_OBJECT (demux, &quot;Identified start tag, size = %u bytes&quot;, tagsize);
1237 
1238   do {
1239     guint newsize, saved_size;
1240 
1241     demux-&gt;priv-&gt;strip_start = tagsize;
1242 
1243     /* Now pull the entire tag */
1244     g_assert (tagsize &gt;= klass-&gt;min_start_size);
1245 
1246     if (bsize &lt; tagsize) {
1247       gst_buffer_unref (buffer);
1248       buffer = NULL;
1249 
1250       flow_ret = gst_pad_pull_range (demux-&gt;priv-&gt;sinkpad, 0, tagsize, &amp;buffer);
1251       if (flow_ret != GST_FLOW_OK) {
1252         GST_DEBUG_OBJECT (demux, &quot;Could not read data from start of file, &quot;
1253             &quot;ret = %s&quot;, gst_flow_get_name (flow_ret));
1254         goto done;
1255       }
1256 
1257       bsize = gst_buffer_get_size (buffer);
1258 
1259       if (bsize &lt; tagsize) {
1260         GST_DEBUG_OBJECT (demux, &quot;Only managed to read %&quot; G_GSIZE_FORMAT
1261             &quot; bytes from file&quot;, bsize);
1262         GST_ELEMENT_ERROR (demux, STREAM, DECODE,
1263             (_(&quot;Failed to read tag: not enough data&quot;)), (NULL));
1264         flow_ret = GST_FLOW_EOS;
1265         goto done;
1266       }
1267     }
1268 
1269     saved_size = bsize;
1270     gst_buffer_set_size (buffer, tagsize);
1271     newsize = tagsize;
1272     parse_ret = klass-&gt;parse_tag (demux, buffer, TRUE, &amp;newsize, &amp;new_tags);
1273 
1274     gst_buffer_set_size (buffer, saved_size);
1275 
1276     switch (parse_ret) {
1277       case GST_TAG_DEMUX_RESULT_OK:
1278         flow_ret = GST_FLOW_OK;
1279         demux-&gt;priv-&gt;strip_start = newsize;
1280         GST_DEBUG_OBJECT (demux, &quot;Read start tag of size %d&quot;, newsize);
1281         break;
1282       case GST_TAG_DEMUX_RESULT_BROKEN_TAG:
1283         flow_ret = GST_FLOW_OK;
1284         demux-&gt;priv-&gt;strip_start = newsize;
1285         GST_WARNING_OBJECT (demux, &quot;Ignoring broken start tag of size %d&quot;,
1286             demux-&gt;priv-&gt;strip_start);
1287         break;
1288       case GST_TAG_DEMUX_RESULT_AGAIN:
1289         GST_DEBUG_OBJECT (demux, &quot;Re-parse, this time with %d bytes&quot;, newsize);
1290         g_assert (newsize != tagsize);
1291         tagsize = newsize;
1292         break;
1293     }
1294   } while (parse_ret == GST_TAG_DEMUX_RESULT_AGAIN);
1295 
1296   *tags = new_tags;
1297   new_tags = NULL;
1298 
1299 done:
1300   if (new_tags)
1301     gst_tag_list_unref (new_tags);
1302   if (buffer)
1303     gst_buffer_unref (buffer);
1304   return flow_ret;
1305 }
1306 
1307 /* This function operates similarly to gst_type_find_element_loop
1308  * in the typefind element
1309  * 1. try to read tags in pull mode
1310  * 2. typefind the contents
1311  * 3. if we didn&#39;t find any caps, fail.
1312  * 4. set caps on srcpad
1313  */
1314 static GstFlowReturn
1315 gst_tag_demux_element_find (GstTagDemux * demux)
1316 {
1317   GstTagDemuxClass *klass;
1318   GstTypeFindProbability probability = 0;
1319   GstFlowReturn ret = GST_FLOW_OK;
1320   GstTagList *start_tags = NULL;
1321   GstTagList *end_tags = NULL;
1322   gboolean e_tag_ok, s_tag_ok;
1323   GstCaps *caps = NULL;
1324 
1325   /* Look for tags at start and end of file */
1326   GST_DEBUG_OBJECT (demux, &quot;Activated pull mode. Looking for tags&quot;);
1327   if (!gst_tag_demux_get_upstream_size (demux))
1328     goto no_size;
1329 
1330   demux-&gt;priv-&gt;strip_start = 0;
1331   demux-&gt;priv-&gt;strip_end = 0;
1332 
1333   /* 1 - Read tags */
1334   ret = gst_tag_demux_pull_start_tag (demux, &amp;start_tags);
1335   if (ret != GST_FLOW_OK &amp;&amp; ret != GST_FLOW_EOS)
1336     goto read_tag_error;
1337   s_tag_ok = ret == GST_FLOW_OK;
1338   ret = gst_tag_demux_pull_end_tag (demux, &amp;end_tags);
1339   if (ret != GST_FLOW_OK &amp;&amp; ret != GST_FLOW_EOS)
1340     goto read_tag_error;
1341   e_tag_ok = ret == GST_FLOW_OK;
1342   ret = GST_FLOW_OK;
1343 
1344   klass = GST_TAG_DEMUX_CLASS (G_OBJECT_GET_CLASS (demux));
1345 
1346   if (klass-&gt;merge_tags != NULL) {
1347     demux-&gt;priv-&gt;parsed_tags = klass-&gt;merge_tags (demux, start_tags, end_tags);
1348   } else {
1349     /* we merge in REPLACE mode, so put the less important tags first, which
1350      * we&#39;ll just assume is the end tag (subclasses may change this behaviour
1351      * or make it configurable by overriding the merge_tags vfunc) */
1352     demux-&gt;priv-&gt;parsed_tags =
1353         gst_tag_list_merge (end_tags, start_tags, GST_TAG_MERGE_REPLACE);
1354   }
1355 
1356   if (start_tags)
1357     gst_tag_list_unref (start_tags);
1358   if (end_tags)
1359     gst_tag_list_unref (end_tags);
1360 
1361   /* Only happens if both are EOS, i.e. not enough data could be read */
1362   if (!e_tag_ok &amp;&amp; !s_tag_ok)
1363     goto no_tags;
1364 
1365   if (demux-&gt;priv-&gt;parsed_tags != NULL) {
1366     demux-&gt;priv-&gt;send_tag_event = TRUE;
1367   }
1368 
1369   if (demux-&gt;priv-&gt;upstream_size &lt;=
1370       demux-&gt;priv-&gt;strip_start + demux-&gt;priv-&gt;strip_end)
1371     goto no_data;
1372 
1373   /* 2 - Do typefinding on data, but not if downstream is in charge */
1374   if (GST_PAD_MODE (demux-&gt;priv-&gt;srcpad) == GST_PAD_MODE_PULL)
1375     goto skip_typefinding;
1376 
1377   ret = gst_type_find_helper_get_range_full (GST_OBJECT (demux), NULL,
1378       (GstTypeFindHelperGetRangeFunction) gst_tag_demux_read_range,
1379       demux-&gt;priv-&gt;upstream_size
1380       - (demux-&gt;priv-&gt;strip_start + demux-&gt;priv-&gt;strip_end), NULL,
1381       &amp;caps, &amp;probability);
1382   if (ret != GST_FLOW_OK)
1383     goto read_tag_error;
1384 
1385   GST_INFO_OBJECT (demux, &quot;Found type %&quot; GST_PTR_FORMAT &quot; with a &quot;
1386       &quot;probability of %u&quot;, caps, probability);
1387 
1388   /* 3 - If we didn&#39;t find the caps, fail */
1389   if (caps == NULL)
1390     goto no_caps;
1391 
1392   /* tag reading and typefinding were already done, don&#39;t do them again in
1393    * the chain function if we end up in push mode */
1394   demux-&gt;priv-&gt;state = GST_TAG_DEMUX_STREAMING;
1395 
1396   /* 6 Set the srcpad caps now that we know them */
1397   gst_tag_demux_set_src_caps (demux, caps);
<a name="19" id="anc19"></a><span class="line-modified">1398   gst_caps_unref (caps);</span>
1399 
1400 skip_typefinding:
1401 
1402   /* set it again, in case we skipped typefinding */
1403   demux-&gt;priv-&gt;state = GST_TAG_DEMUX_STREAMING;
1404   demux-&gt;priv-&gt;offset += demux-&gt;priv-&gt;strip_start;
1405 
1406   return ret;
1407 
1408   /* ERRORS */
1409 no_size:
1410   {
1411     GST_ELEMENT_ERROR (demux, STREAM, TYPE_NOT_FOUND,
1412         (&quot;Could not get stream size&quot;), (NULL));
1413     return GST_FLOW_ERROR;
1414   }
1415 read_tag_error:
1416   {
1417     if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS)
1418       GST_ELEMENT_FLOW_ERROR (demux, ret);
1419     return ret;
1420   }
1421 no_tags:
1422   {
1423     GST_ELEMENT_ERROR (demux, STREAM, TYPE_NOT_FOUND,
1424         (&quot;Could not get start and/or end tag&quot;), (NULL));
1425     return GST_FLOW_ERROR;
1426   }
1427 no_data:
1428   {
1429     /* There was no data (probably due to a truncated file) */
1430     /* so we don&#39;t know about type either */
1431     GST_ELEMENT_ERROR (demux, STREAM, TYPE_NOT_FOUND, (&quot;No data in file&quot;),
1432         (NULL));
1433     return GST_FLOW_ERROR;
1434   }
1435 no_caps:
1436   {
1437     GST_ELEMENT_ERROR (demux, STREAM, TYPE_NOT_FOUND,
1438         (&quot;Could not detect type of contents&quot;), (NULL));
1439     return GST_FLOW_ERROR;
1440   }
1441 }
1442 
1443 /* This function operates similarly to gst_type_find_element_loop
1444  * in the typefind element
1445  * 1. try to read tags in pull mode
1446  * 2. typefind the contents
1447  * 3. if we didn&#39;t find any caps, fail.
1448  * 4. set caps on srcpad
1449  */
1450 static void
1451 gst_tag_demux_element_loop (GstTagDemux * demux)
1452 {
1453   GstFlowReturn ret;
1454 
1455   switch (demux-&gt;priv-&gt;state) {
1456     case GST_TAG_DEMUX_READ_START_TAG:
1457     case GST_TAG_DEMUX_TYPEFINDING:
1458       ret = gst_tag_demux_element_find (demux);
1459       break;
1460     case GST_TAG_DEMUX_STREAMING:
1461     {
1462       GstBuffer *outbuf = NULL;
1463 
1464       if (demux-&gt;priv-&gt;need_newseg) {
1465         demux-&gt;priv-&gt;need_newseg = FALSE;
1466         /* FIXME: check segment, should be 0-N for downstream */
1467         gst_tag_demux_send_new_segment (demux);
<a name="20" id="anc20"></a><span class="line-modified">1468       }</span>
1469 
1470       /* Send our own pending tag event */
1471       if (demux-&gt;priv-&gt;send_tag_event) {
1472         gst_tag_demux_send_tag_event (demux);
1473         demux-&gt;priv-&gt;send_tag_event = FALSE;
1474       }
1475 
1476       /* Pull data and push it downstream */
1477       ret = gst_pad_pull_range (demux-&gt;priv-&gt;sinkpad, demux-&gt;priv-&gt;offset,
1478           DEFAULT_PULL_BLOCKSIZE, &amp;outbuf);
1479 
1480       if (ret != GST_FLOW_OK)
1481         break;
1482 
1483       GST_BUFFER_OFFSET (outbuf) =
1484           demux-&gt;priv-&gt;offset - demux-&gt;priv-&gt;strip_start;
1485       demux-&gt;priv-&gt;offset += gst_buffer_get_size (outbuf);
1486       GST_BUFFER_OFFSET_END (outbuf) =
1487           demux-&gt;priv-&gt;offset - demux-&gt;priv-&gt;strip_start;
1488 
1489       ret = gst_pad_push (demux-&gt;priv-&gt;srcpad, outbuf);
1490       break;
<a name="21" id="anc21"></a><span class="line-modified">1491     }</span>
1492     default:
1493       ret = GST_FLOW_ERROR;
1494       break;
1495   }
1496   if (ret != GST_FLOW_OK)
1497     goto pause;
1498 
1499   return;
1500 
1501   /* ERRORS */
1502 pause:
1503   {
1504     const gchar *reason = gst_flow_get_name (ret);
1505     gboolean push_eos = FALSE;
1506 
1507     GST_LOG_OBJECT (demux, &quot;pausing task, reason %s&quot;, reason);
1508     gst_pad_pause_task (demux-&gt;priv-&gt;sinkpad);
1509 
1510     if (ret == GST_FLOW_EOS) {
1511       /* perform EOS logic */
1512 
1513       if (demux-&gt;priv-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
1514         gint64 stop;
1515 
1516         /* for segment playback we need to post when (in stream time)
1517          * we stopped, this is either stop (when set) or the duration. */
1518         if ((stop = demux-&gt;priv-&gt;segment.stop) == -1)
1519           stop = demux-&gt;priv-&gt;offset;
1520 
1521         GST_LOG_OBJECT (demux, &quot;Sending segment done, at end of segment&quot;);
1522         gst_element_post_message (GST_ELEMENT_CAST (demux),
1523             gst_message_new_segment_done (GST_OBJECT_CAST (demux),
1524                 GST_FORMAT_BYTES, stop));
1525         gst_pad_push_event (demux-&gt;priv-&gt;srcpad,
1526             gst_event_new_segment_done (GST_FORMAT_BYTES, stop));
1527       } else {
1528         push_eos = TRUE;
<a name="22" id="anc22"></a><span class="line-modified">1529       }</span>
1530     } else if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS) {
1531       /* for fatal errors we post an error message */
1532       GST_ELEMENT_FLOW_ERROR (demux, ret);
1533       push_eos = TRUE;
1534     }
1535     if (push_eos) {
1536       /* send EOS, and prevent hanging if no streams yet */
1537       GST_LOG_OBJECT (demux, &quot;Sending EOS, at end of stream&quot;);
1538       gst_pad_push_event (demux-&gt;priv-&gt;srcpad, gst_event_new_eos ());
1539     }
1540     return;
1541   }
1542 }
1543 
1544 static gboolean
1545 gst_tag_demux_sink_activate_mode (GstPad * pad, GstObject * parent,
1546     GstPadMode mode, gboolean active)
1547 {
1548   GstTagDemux *demux = GST_TAG_DEMUX (parent);
1549   gboolean res;
1550 
1551   switch (mode) {
1552     case GST_PAD_MODE_PULL:
1553       if (active) {
1554         demux-&gt;priv-&gt;need_newseg = TRUE;
1555         demux-&gt;priv-&gt;offset = 0;
1556         res = TRUE;
1557       } else {
1558         res = gst_pad_stop_task (pad);
1559       }
1560       break;
1561     default:
1562       res = TRUE;
1563       break;
1564   }
1565 
1566   if (active)
1567     GST_TAG_DEMUX (parent)-&gt;priv-&gt;state = GST_TAG_DEMUX_READ_START_TAG;
1568 
1569   return res;
1570 }
1571 
1572 static gboolean
1573 gst_tag_demux_sink_activate (GstPad * sinkpad, GstObject * parent)
1574 {
1575   GstTagDemux *demux;
1576   GstQuery *query;
1577   gboolean pull_mode;
1578 
1579   demux = GST_TAG_DEMUX (parent);
1580 
1581   /* 1: */
1582   /* If we can activate pull_range upstream, then read any end and start
1583    * tags, otherwise activate in push mode and the chain function will
1584    * collect buffers, read the start tag and output a buffer to end
1585    * preroll.
1586    */
1587   query = gst_query_new_scheduling ();
1588 
1589   if (!gst_pad_peer_query (sinkpad, query)) {
1590     gst_query_unref (query);
1591     goto activate_push;
1592   }
1593 
1594   pull_mode = gst_query_has_scheduling_mode_with_flags (query,
1595       GST_PAD_MODE_PULL, GST_SCHEDULING_FLAG_SEEKABLE);
1596   gst_query_unref (query);
1597 
1598   if (!pull_mode)
1599     goto activate_push;
1600 
1601   if (!gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PULL, TRUE))
1602     goto activate_push;
1603 
1604   /* only start our task if we ourselves decide to start in pull mode */
1605   return gst_pad_start_task (sinkpad,
1606       (GstTaskFunction) gst_tag_demux_element_loop, demux, NULL);
1607 
1608 activate_push:
1609   {
1610     GST_DEBUG_OBJECT (demux, &quot;No pull mode. Changing to push, but won&#39;t be &quot;
1611         &quot;able to read end tags&quot;);
1612     return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PUSH, TRUE);
1613   }
1614 }
1615 
1616 static gboolean
1617 gst_tag_demux_src_activate_mode (GstPad * pad, GstObject * parent,
1618     GstPadMode mode, gboolean active)
1619 {
1620   gboolean res;
1621   GstTagDemux *demux = GST_TAG_DEMUX (parent);
1622 
1623   switch (mode) {
1624     case GST_PAD_MODE_PULL:
1625       /* make sure our task stops pushing, we can&#39;t call _stop here
1626        * because this activation might happen from the streaming thread. */
1627       gst_pad_pause_task (demux-&gt;priv-&gt;sinkpad);
1628       res = gst_pad_activate_mode (demux-&gt;priv-&gt;sinkpad, mode, active);
1629       break;
1630     default:
1631       res = TRUE;
1632       break;
1633   }
1634   return res;
1635 }
1636 
1637 static inline GstFlowReturn
1638 gst_tag_demux_ensure_tags (GstTagDemux * demux)
1639 {
1640   GstFlowReturn flow = GST_FLOW_OK;
1641 
1642   if (G_UNLIKELY (demux-&gt;priv-&gt;state == GST_TAG_DEMUX_READ_START_TAG &amp;&amp;
1643           GST_PAD_MODE (demux-&gt;priv-&gt;srcpad) == GST_PAD_MODE_PULL)) {
1644 
1645     flow = gst_tag_demux_element_find (demux);
1646     GST_INFO_OBJECT (demux, &quot;pulled tags: %s&quot;, gst_flow_get_name (flow));
1647   }
1648   return flow;
1649 }
1650 
1651 static GstFlowReturn
1652 gst_tag_demux_read_range (GstTagDemux * demux, GstObject * parent,
1653     guint64 offset, guint length, GstBuffer ** buffer)
1654 {
1655   GstFlowReturn ret;
1656   guint64 in_offset;
1657   guint in_length;
1658   gsize size;
1659 
1660   g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
1661 
1662   /* Ensure we already have computed our tags to properly use the offsets
1663    * below */
1664   ret = gst_tag_demux_ensure_tags (demux);
1665   if (ret != GST_FLOW_OK)
1666     return ret;
1667 
1668   /* Adjust offset and length of the request to trim off tag information.
1669    * For the returned buffer, adjust the output offset to match what downstream
1670    * should see */
1671   in_offset = offset + demux-&gt;priv-&gt;strip_start;
1672 
1673   if (!gst_tag_demux_get_upstream_size (demux))
1674     return GST_FLOW_ERROR;
1675 
1676   if (in_offset + length &gt;= demux-&gt;priv-&gt;upstream_size - demux-&gt;priv-&gt;strip_end) {
1677     if (in_offset + demux-&gt;priv-&gt;strip_end &gt;= demux-&gt;priv-&gt;upstream_size)
1678       return GST_FLOW_EOS;
1679     in_length = demux-&gt;priv-&gt;upstream_size - demux-&gt;priv-&gt;strip_end - in_offset;
1680   } else {
1681     in_length = length;
1682   }
1683 
1684   ret = gst_pad_pull_range (demux-&gt;priv-&gt;sinkpad, in_offset, in_length, buffer);
1685 
1686   if (ret == GST_FLOW_OK &amp;&amp; *buffer) {
1687     if (!gst_tag_demux_trim_buffer (demux, buffer, &amp;size))
1688       goto read_beyond_end;
1689 
1690     /* this should only happen in streaming mode */
1691     g_assert (*buffer != NULL);
1692   }
1693 
1694   return ret;
1695 
1696 read_beyond_end:
1697   {
1698     GST_DEBUG_OBJECT (demux, &quot;attempted read beyond end of file&quot;);
1699     if (*buffer != NULL) {
1700       gst_buffer_unref (*buffer);
1701       *buffer = NULL;
1702     }
1703     return GST_FLOW_EOS;
1704   }
1705 }
1706 
1707 static GstFlowReturn
1708 gst_tag_demux_src_getrange (GstPad * srcpad, GstObject * parent,
1709     guint64 offset, guint length, GstBuffer ** buffer)
1710 {
1711   GstTagDemux *demux = GST_TAG_DEMUX (parent);
1712 
1713   /* downstream in pull mode won&#39;t miss a newsegment event,
1714    * but it likely appreciates other (tag) events */
1715   if (demux-&gt;priv-&gt;need_newseg) {
1716     gst_tag_demux_send_pending_events (demux);
1717     demux-&gt;priv-&gt;need_newseg = FALSE;
1718   }
1719 
1720   if (demux-&gt;priv-&gt;send_tag_event) {
1721     gst_tag_demux_send_tag_event (demux);
1722     demux-&gt;priv-&gt;send_tag_event = FALSE;
1723   }
1724 
1725   return gst_tag_demux_read_range (demux, NULL, offset, length, buffer);
1726 }
1727 
1728 static GstStateChangeReturn
1729 gst_tag_demux_change_state (GstElement * element, GstStateChange transition)
1730 {
1731   GstStateChangeReturn ret;
1732   GstTagDemux *demux = GST_TAG_DEMUX (element);
1733 
1734   ret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
1735 
1736   switch (transition) {
1737     case GST_STATE_CHANGE_PAUSED_TO_READY:
1738       /* Ensure that nothing is in any of the streaming thread functions
1739        * anymore. While the above has deactivated all pads, there is nothing
1740        * preventing downstream from activating our srcpad again and calling the
1741        * getrange() function. Although we&#39;re in READY!
1742        */
1743       GST_PAD_STREAM_LOCK (demux-&gt;priv-&gt;srcpad);
1744       gst_tag_demux_reset (demux);
1745       GST_PAD_STREAM_UNLOCK (demux-&gt;priv-&gt;srcpad);
1746       break;
1747     default:
1748       break;
1749   }
1750 
1751   return ret;
1752 }
1753 
1754 static gboolean
1755 gst_tag_demux_pad_query (GstPad * pad, GstObject * parent, GstQuery * query)
1756 {
1757   /* For a position or duration query, adjust the returned
1758    * bytes to strip off the end and start areas */
1759   GstTagDemux *demux = GST_TAG_DEMUX (parent);
1760   GstFormat format;
1761   gint64 result;
1762   gboolean res = TRUE;
1763 
1764   /* FIXME: locking ? */
1765   switch (GST_QUERY_TYPE (query)) {
1766     case GST_QUERY_SCHEDULING:
1767       res = gst_pad_peer_query (demux-&gt;priv-&gt;sinkpad, query);
1768       break;
1769     case GST_QUERY_POSITION:
1770     {
1771       if (!(res = gst_pad_peer_query (demux-&gt;priv-&gt;sinkpad, query)))
1772         goto done;
1773 
1774       gst_query_parse_position (query, &amp;format, &amp;result);
1775       if (format == GST_FORMAT_BYTES) {
1776         result -= demux-&gt;priv-&gt;strip_start;
1777         gst_query_set_position (query, format, result);
1778       }
1779       break;
1780     }
1781     case GST_QUERY_DURATION:
1782     {
1783       if (!(res = gst_pad_peer_query (demux-&gt;priv-&gt;sinkpad, query)))
1784         goto done;
1785 
1786       gst_query_parse_duration (query, &amp;format, &amp;result);
1787       if (format == GST_FORMAT_BYTES) {
1788         /* if downstream activated us in pull mode right away, e.g. in case of
1789          * filesrc ! id3demux ! xyzparse ! .., read tags here, since we don&#39;t
1790          * have a streaming thread of our own to do that. We do it here and
1791          * not in get_range(), so we can return the right size in bytes.. */
1792         gst_tag_demux_ensure_tags (demux);
1793         result -= demux-&gt;priv-&gt;strip_start + demux-&gt;priv-&gt;strip_end;
1794         if (result &lt; 0)
1795           result = 0;
1796         gst_query_set_duration (query, format, result);
1797       }
1798       break;
1799     }
1800     default:
1801       res = gst_pad_query_default (pad, parent, query);
1802       break;
1803   }
1804 done:
1805   return res;
1806 }
1807 
1808 static void
1809 gst_tag_demux_send_pending_events (GstTagDemux * demux)
1810 {
1811   GList *events;
1812 
1813   /* send any pending events we cached */
1814   GST_OBJECT_LOCK (demux);
1815   events = demux-&gt;priv-&gt;pending_events;
1816   demux-&gt;priv-&gt;pending_events = NULL;
1817   GST_OBJECT_UNLOCK (demux);
1818 
1819   while (events != NULL) {
1820     GST_DEBUG_OBJECT (demux-&gt;priv-&gt;srcpad, &quot;sending cached %s event: %&quot;
1821         GST_PTR_FORMAT, GST_EVENT_TYPE_NAME (events-&gt;data), events-&gt;data);
1822     gst_pad_push_event (demux-&gt;priv-&gt;srcpad, GST_EVENT (events-&gt;data));
1823     events = g_list_delete_link (events, events);
1824   }
1825 }
1826 
1827 static void
1828 gst_tag_demux_send_tag_event (GstTagDemux * demux)
1829 {
1830   /* FIXME: what&#39;s the correct merge mode? Docs need to tell... */
1831   GstTagList *merged = gst_tag_list_merge (demux-&gt;priv-&gt;event_tags,
1832       demux-&gt;priv-&gt;parsed_tags, GST_TAG_MERGE_KEEP);
1833 
1834   if (merged) {
1835     GstEvent *event = gst_event_new_tag (merged);
1836 #ifdef GSTREAMER_LITE
1837   if (event == NULL)
1838     return;
1839 #endif // GSTREAMER_LITE
1840 
<a name="23" id="anc23"></a>
1841     GST_DEBUG_OBJECT (demux, &quot;Sending tag event on src pad&quot;);
1842     gst_pad_push_event (demux-&gt;priv-&gt;srcpad, event);
1843   }
1844 }
1845 
1846 static gboolean
1847 gst_tag_demux_send_new_segment (GstTagDemux * tagdemux)
1848 {
1849   GstEvent *event;
1850   gint64 start, stop, time;
1851   GstSegment *seg = &amp;tagdemux-&gt;priv-&gt;segment;
1852   GstSegment newseg;
1853 
1854   if (seg-&gt;format == GST_FORMAT_UNDEFINED) {
1855     GST_LOG_OBJECT (tagdemux,
1856         &quot;No new segment received before first buffer. Using default&quot;);
1857     gst_segment_init (seg, GST_FORMAT_BYTES);
1858     seg-&gt;start = tagdemux-&gt;priv-&gt;strip_start;
1859     seg-&gt;time = tagdemux-&gt;priv-&gt;strip_start;
1860   }
1861 
1862   /* Can&#39;t adjust segments in non-BYTES formats */
1863   if (tagdemux-&gt;priv-&gt;segment.format != GST_FORMAT_BYTES) {
1864     event = gst_event_new_segment (seg);
1865     return gst_pad_push_event (tagdemux-&gt;priv-&gt;srcpad, event);
1866   }
1867 
1868   start = seg-&gt;start;
1869   stop = seg-&gt;stop;
1870   time = seg-&gt;time;
1871 
1872   g_return_val_if_fail (start != -1, FALSE);
1873   g_return_val_if_fail (time != -1, FALSE);
1874 
1875   if (tagdemux-&gt;priv-&gt;strip_end &gt; 0) {
1876     if (gst_tag_demux_get_upstream_size (tagdemux)) {
1877       guint64 v1tag_offset =
1878           tagdemux-&gt;priv-&gt;upstream_size - tagdemux-&gt;priv-&gt;strip_end;
1879 
1880       if (start &gt;= v1tag_offset) {
1881         /* Segment is completely within the end tag, output an open-ended
1882          * segment, even though all the buffers will get trimmed away */
1883         start = v1tag_offset;
1884         stop = -1;
1885       }
1886 
1887       if (stop != -1 &amp;&amp; stop &gt;= v1tag_offset) {
1888         GST_DEBUG_OBJECT (tagdemux,
1889             &quot;Segment crosses the end tag. Trimming end&quot;);
1890         stop = v1tag_offset;
1891       }
1892     }
1893   }
1894 
1895   if (tagdemux-&gt;priv-&gt;strip_start &gt; 0) {
1896     if (start &gt; tagdemux-&gt;priv-&gt;strip_start)
1897       start -= tagdemux-&gt;priv-&gt;strip_start;
1898     else
1899       start = 0;
1900 
1901     if (time &gt; tagdemux-&gt;priv-&gt;strip_start)
1902       time -= tagdemux-&gt;priv-&gt;strip_start;
1903     else
1904       time = 0;
1905 
1906     if (stop != -1) {
1907       if (stop &gt; tagdemux-&gt;priv-&gt;strip_start)
1908         stop -= tagdemux-&gt;priv-&gt;strip_start;
1909       else
1910         stop = 0;
1911     }
1912   }
1913 
1914   GST_DEBUG_OBJECT (tagdemux, &quot;Sending segment %&quot; GST_SEGMENT_FORMAT, seg);
1915 
1916   gst_segment_copy_into (seg, &amp;newseg);
1917   newseg.start = start;
1918   newseg.stop = stop;
1919   newseg.time = time;
1920   event = gst_event_new_segment (&amp;newseg);
1921 
1922   return gst_pad_push_event (tagdemux-&gt;priv-&gt;srcpad, event);
1923 }
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>