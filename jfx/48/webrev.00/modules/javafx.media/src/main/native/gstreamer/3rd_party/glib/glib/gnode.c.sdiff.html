<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gnode.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gmirroringtable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gnode.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gnode.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 163       node-&gt;next = NULL;
 164     }
 165   node-&gt;prev = NULL;
 166 }
 167 
 168 /**
 169  * g_node_copy_deep:
 170  * @node: a #GNode
 171  * @copy_func: the function which is called to copy the data inside each node,
 172  *   or %NULL to use the original data.
 173  * @data: data to pass to @copy_func
 174  *
 175  * Recursively copies a #GNode and its data.
 176  *
 177  * Returns: a new #GNode containing copies of the data in @node.
 178  *
 179  * Since: 2.4
 180  **/
 181 GNode*
 182 g_node_copy_deep (GNode     *node,
<span class="line-modified"> 183           GCopyFunc  copy_func,</span>
<span class="line-modified"> 184           gpointer   data)</span>
 185 {
 186   GNode *new_node = NULL;
 187 
 188   if (copy_func == NULL)
<span class="line-modified"> 189     return g_node_copy (node);</span>
 190 
 191   if (node)
 192     {
 193       GNode *child, *new_child;
 194 
 195       new_node = g_node_new (copy_func (node-&gt;data, data));
 196 
 197       for (child = g_node_last_child (node); child; child = child-&gt;prev)
<span class="line-modified"> 198     {</span>
<span class="line-modified"> 199       new_child = g_node_copy_deep (child, copy_func, data);</span>
<span class="line-modified"> 200       g_node_prepend (new_node, new_child);</span>
<span class="line-modified"> 201     }</span>
 202     }
 203 
 204   return new_node;
 205 }
 206 
 207 /**
 208  * g_node_copy:
 209  * @node: a #GNode
 210  *
 211  * Recursively copies a #GNode (but does not deep-copy the data inside the
 212  * nodes, see g_node_copy_deep() if you need that).
 213  *
 214  * Returns: a new #GNode containing the same data pointers
 215  */
 216 GNode*
 217 g_node_copy (GNode *node)
 218 {
 219   GNode *new_node = NULL;
 220 
 221   if (node)
 222     {
 223       GNode *child;
 224 
 225       new_node = g_node_new (node-&gt;data);
 226 
 227       for (child = g_node_last_child (node); child; child = child-&gt;prev)
<span class="line-modified"> 228     g_node_prepend (new_node, g_node_copy (child));</span>
 229     }
 230 
 231   return new_node;
 232 }
 233 
 234 /**
 235  * g_node_insert:
 236  * @parent: the #GNode to place @node under
 237  * @position: the position to place @node at, with respect to its siblings
 238  *     If position is -1, @node is inserted as the last child of @parent
 239  * @node: the #GNode to insert
 240  *
 241  * Inserts a #GNode beneath the parent at the given position.
 242  *
 243  * Returns: the inserted #GNode
 244  */
 245 GNode*
 246 g_node_insert (GNode *parent,
<span class="line-modified"> 247            gint   position,</span>
<span class="line-modified"> 248            GNode *node)</span>
 249 {
 250   g_return_val_if_fail (parent != NULL, node);
 251   g_return_val_if_fail (node != NULL, node);
 252   g_return_val_if_fail (G_NODE_IS_ROOT (node), node);
 253 
 254   if (position &gt; 0)
 255     return g_node_insert_before (parent,
<span class="line-modified"> 256                  g_node_nth_child (parent, position),</span>
<span class="line-modified"> 257                  node);</span>
 258   else if (position == 0)
 259     return g_node_prepend (parent, node);
 260   else /* if (position &lt; 0) */
 261     return g_node_append (parent, node);
 262 }
 263 
 264 /**
 265  * g_node_insert_before:
 266  * @parent: the #GNode to place @node under
 267  * @sibling: the sibling #GNode to place @node before.
 268  *     If sibling is %NULL, the node is inserted as the last child of @parent.
 269  * @node: the #GNode to insert
 270  *
 271  * Inserts a #GNode beneath the parent before the given sibling.
 272  *
 273  * Returns: the inserted #GNode
 274  */
 275 GNode*
 276 g_node_insert_before (GNode *parent,
<span class="line-modified"> 277               GNode *sibling,</span>
<span class="line-modified"> 278               GNode *node)</span>
 279 {
 280   g_return_val_if_fail (parent != NULL, node);
 281   g_return_val_if_fail (node != NULL, node);
 282   g_return_val_if_fail (G_NODE_IS_ROOT (node), node);
 283   if (sibling)
 284     g_return_val_if_fail (sibling-&gt;parent == parent, node);
 285 
 286   node-&gt;parent = parent;
 287 
 288   if (sibling)
 289     {
 290       if (sibling-&gt;prev)
<span class="line-modified"> 291     {</span>
<span class="line-modified"> 292       node-&gt;prev = sibling-&gt;prev;</span>
<span class="line-modified"> 293       node-&gt;prev-&gt;next = node;</span>
<span class="line-modified"> 294       node-&gt;next = sibling;</span>
<span class="line-modified"> 295       sibling-&gt;prev = node;</span>
<span class="line-modified"> 296     }</span>
 297       else
<span class="line-modified"> 298     {</span>
<span class="line-modified"> 299       node-&gt;parent-&gt;children = node;</span>
<span class="line-modified"> 300       node-&gt;next = sibling;</span>
<span class="line-modified"> 301       sibling-&gt;prev = node;</span>
<span class="line-modified"> 302     }</span>
 303     }
 304   else
 305     {
 306       if (parent-&gt;children)
<span class="line-modified"> 307     {</span>
<span class="line-modified"> 308       sibling = parent-&gt;children;</span>
<span class="line-modified"> 309       while (sibling-&gt;next)</span>
<span class="line-modified"> 310         sibling = sibling-&gt;next;</span>
<span class="line-modified"> 311       node-&gt;prev = sibling;</span>
<span class="line-modified"> 312       sibling-&gt;next = node;</span>
<span class="line-modified"> 313     }</span>
 314       else
<span class="line-modified"> 315     node-&gt;parent-&gt;children = node;</span>
 316     }
 317 
 318   return node;
 319 }
 320 
 321 /**
 322  * g_node_insert_after:
 323  * @parent: the #GNode to place @node under
 324  * @sibling: the sibling #GNode to place @node after.
 325  *     If sibling is %NULL, the node is inserted as the first child of @parent.
 326  * @node: the #GNode to insert
 327  *
 328  * Inserts a #GNode beneath the parent after the given sibling.
 329  *
 330  * Returns: the inserted #GNode
 331  */
 332 GNode*
 333 g_node_insert_after (GNode *parent,
<span class="line-modified"> 334              GNode *sibling,</span>
<span class="line-modified"> 335              GNode *node)</span>
 336 {
 337   g_return_val_if_fail (parent != NULL, node);
 338   g_return_val_if_fail (node != NULL, node);
 339   g_return_val_if_fail (G_NODE_IS_ROOT (node), node);
 340   if (sibling)
 341     g_return_val_if_fail (sibling-&gt;parent == parent, node);
 342 
 343   node-&gt;parent = parent;
 344 
 345   if (sibling)
 346     {
 347       if (sibling-&gt;next)
<span class="line-modified"> 348     {</span>
<span class="line-modified"> 349       sibling-&gt;next-&gt;prev = node;</span>
<span class="line-modified"> 350     }</span>
 351       node-&gt;next = sibling-&gt;next;
 352       node-&gt;prev = sibling;
 353       sibling-&gt;next = node;
 354     }
 355   else
 356     {
 357       if (parent-&gt;children)
<span class="line-modified"> 358     {</span>
<span class="line-modified"> 359       node-&gt;next = parent-&gt;children;</span>
<span class="line-modified"> 360       parent-&gt;children-&gt;prev = node;</span>
<span class="line-modified"> 361     }</span>
 362       parent-&gt;children = node;
 363     }
 364 
 365   return node;
 366 }
 367 
 368 /**
 369  * g_node_prepend:
 370  * @parent: the #GNode to place the new #GNode under
 371  * @node: the #GNode to insert
 372  *
 373  * Inserts a #GNode as the first child of the given parent.
 374  *
 375  * Returns: the inserted #GNode
 376  */
 377 GNode*
 378 g_node_prepend (GNode *parent,
<span class="line-modified"> 379         GNode *node)</span>
 380 {
 381   g_return_val_if_fail (parent != NULL, node);
 382 
 383   return g_node_insert_before (parent, parent-&gt;children, node);
 384 }
 385 
 386 /**
 387  * g_node_get_root:
 388  * @node: a #GNode
 389  *
 390  * Gets the root of a tree.
 391  *
 392  * Returns: the root of the tree
 393  */
 394 GNode*
 395 g_node_get_root (GNode *node)
 396 {
 397   g_return_val_if_fail (node != NULL, NULL);
 398 
 399   while (node-&gt;parent)
 400     node = node-&gt;parent;
 401 
 402   return node;
 403 }
 404 
 405 /**
 406  * g_node_is_ancestor:
 407  * @node: a #GNode
 408  * @descendant: a #GNode
 409  *
 410  * Returns %TRUE if @node is an ancestor of @descendant.
 411  * This is true if node is the parent of @descendant,
 412  * or if node is the grandparent of @descendant etc.
 413  *
 414  * Returns: %TRUE if @node is an ancestor of @descendant
 415  */
 416 gboolean
 417 g_node_is_ancestor (GNode *node,
<span class="line-modified"> 418             GNode *descendant)</span>
 419 {
 420   g_return_val_if_fail (node != NULL, FALSE);
 421   g_return_val_if_fail (descendant != NULL, FALSE);
 422 
 423   while (descendant)
 424     {
 425       if (descendant-&gt;parent == node)
<span class="line-modified"> 426     return TRUE;</span>
 427 
 428       descendant = descendant-&gt;parent;
 429     }
 430 
 431   return FALSE;
 432 }
 433 
 434 /**
 435  * g_node_depth:
 436  * @node: a #GNode
 437  *
 438  * Gets the depth of a #GNode.
 439  *
 440  * If @node is %NULL the depth is 0. The root node has a depth of 1.
 441  * For the children of the root node the depth is 2. And so on.
 442  *
 443  * Returns: the depth of the #GNode
 444  */
 445 guint
 446 g_node_depth (GNode *node)
</pre>
<hr />
<pre>
 494  * 1 is returned. If @root has children, 2 is returned. And so on.
 495  *
 496  * Returns: the maximum height of the tree beneath @root
 497  */
 498 guint
 499 g_node_max_height (GNode *root)
 500 {
 501   GNode *child;
 502   guint max_height = 0;
 503 
 504   if (!root)
 505     return 0;
 506 
 507   child = root-&gt;children;
 508   while (child)
 509     {
 510       guint tmp_height;
 511 
 512       tmp_height = g_node_max_height (child);
 513       if (tmp_height &gt; max_height)
<span class="line-modified"> 514     max_height = tmp_height;</span>
 515       child = child-&gt;next;
 516     }
 517 
 518   return max_height + 1;
 519 }
 520 
 521 static gboolean
<span class="line-modified"> 522 g_node_traverse_pre_order (GNode        *node,</span>
<span class="line-modified"> 523                            GTraverseFlags    flags,</span>
<span class="line-modified"> 524                            GNodeTraverseFunc func,</span>
<span class="line-modified"> 525                gpointer      data)</span>
 526 {
 527   if (node-&gt;children)
 528     {
 529       GNode *child;
 530 
 531       if ((flags &amp; G_TRAVERSE_NON_LEAFS) &amp;&amp;
<span class="line-modified"> 532       func (node, data))</span>
<span class="line-modified"> 533     return TRUE;</span>
 534 
 535       child = node-&gt;children;
 536       while (child)
<span class="line-modified"> 537     {</span>
<span class="line-modified"> 538       GNode *current;</span>
<span class="line-modified"> 539 </span>
<span class="line-modified"> 540       current = child;</span>
<span class="line-modified"> 541       child = current-&gt;next;</span>
<span class="line-modified"> 542       if (g_node_traverse_pre_order (current, flags, func, data))</span>
<span class="line-modified"> 543         return TRUE;</span>
<span class="line-modified"> 544     }</span>
 545     }
 546   else if ((flags &amp; G_TRAVERSE_LEAFS) &amp;&amp;
<span class="line-modified"> 547        func (node, data))</span>
 548     return TRUE;
 549 
 550   return FALSE;
 551 }
 552 
 553 static gboolean
<span class="line-modified"> 554 g_node_depth_traverse_pre_order (GNode        *node,</span>
<span class="line-modified"> 555                  GTraverseFlags    flags,</span>
<span class="line-modified"> 556                  guint         depth,</span>
<span class="line-modified"> 557                                  GNodeTraverseFunc func,</span>
<span class="line-modified"> 558                  gpointer      data)</span>
 559 {
 560   if (node-&gt;children)
 561     {
 562       GNode *child;
 563 
 564       if ((flags &amp; G_TRAVERSE_NON_LEAFS) &amp;&amp;
<span class="line-modified"> 565       func (node, data))</span>
<span class="line-modified"> 566     return TRUE;</span>
 567 
 568       depth--;
 569       if (!depth)
<span class="line-modified"> 570     return FALSE;</span>
 571 
 572       child = node-&gt;children;
 573       while (child)
<span class="line-modified"> 574     {</span>
<span class="line-modified"> 575       GNode *current;</span>
<span class="line-modified"> 576 </span>
<span class="line-modified"> 577       current = child;</span>
<span class="line-modified"> 578       child = current-&gt;next;</span>
<span class="line-modified"> 579       if (g_node_depth_traverse_pre_order (current, flags, depth, func, data))</span>
<span class="line-modified"> 580         return TRUE;</span>
<span class="line-modified"> 581     }</span>
 582     }
 583   else if ((flags &amp; G_TRAVERSE_LEAFS) &amp;&amp;
<span class="line-modified"> 584        func (node, data))</span>
 585     return TRUE;
 586 
 587   return FALSE;
 588 }
 589 
 590 static gboolean
<span class="line-modified"> 591 g_node_traverse_post_order (GNode        *node,</span>
<span class="line-modified"> 592                             GTraverseFlags    flags,</span>
<span class="line-modified"> 593                             GNodeTraverseFunc func,</span>
<span class="line-modified"> 594                 gpointer          data)</span>
 595 {
 596   if (node-&gt;children)
 597     {
 598       GNode *child;
 599 
 600       child = node-&gt;children;
 601       while (child)
<span class="line-modified"> 602     {</span>
<span class="line-modified"> 603       GNode *current;</span>
 604 
<span class="line-modified"> 605       current = child;</span>
<span class="line-modified"> 606       child = current-&gt;next;</span>
<span class="line-modified"> 607       if (g_node_traverse_post_order (current, flags, func, data))</span>
<span class="line-modified"> 608         return TRUE;</span>
<span class="line-modified"> 609     }</span>
 610 
 611       if ((flags &amp; G_TRAVERSE_NON_LEAFS) &amp;&amp;
<span class="line-modified"> 612       func (node, data))</span>
<span class="line-modified"> 613     return TRUE;</span>
 614 
 615     }
 616   else if ((flags &amp; G_TRAVERSE_LEAFS) &amp;&amp;
<span class="line-modified"> 617        func (node, data))</span>
 618     return TRUE;
 619 
 620   return FALSE;
 621 }
 622 
 623 static gboolean
<span class="line-modified"> 624 g_node_depth_traverse_post_order (GNode        *node,</span>
<span class="line-modified"> 625                                   GTraverseFlags    flags,</span>
<span class="line-modified"> 626                   guint         depth,</span>
<span class="line-modified"> 627                                   GNodeTraverseFunc func,</span>
<span class="line-modified"> 628                   gpointer      data)</span>
 629 {
 630   if (node-&gt;children)
 631     {
 632       depth--;
 633       if (depth)
<span class="line-modified"> 634     {</span>
<span class="line-modified"> 635       GNode *child;</span>
 636 
<span class="line-modified"> 637       child = node-&gt;children;</span>
<span class="line-modified"> 638       while (child)</span>
<span class="line-modified"> 639         {</span>
<span class="line-modified"> 640           GNode *current;</span>
<span class="line-removed"> 641 </span>
<span class="line-removed"> 642           current = child;</span>
<span class="line-removed"> 643           child = current-&gt;next;</span>
<span class="line-removed"> 644           if (g_node_depth_traverse_post_order (current, flags, depth, func, data))</span>
<span class="line-removed"> 645         return TRUE;</span>
<span class="line-removed"> 646         }</span>
<span class="line-removed"> 647     }</span>
 648 
<span class="line-modified"> 649       if ((flags &amp; G_TRAVERSE_NON_LEAFS) &amp;&amp;</span>
<span class="line-modified"> 650       func (node, data))</span>

 651     return TRUE;






 652 
 653     }
 654   else if ((flags &amp; G_TRAVERSE_LEAFS) &amp;&amp;
<span class="line-modified"> 655        func (node, data))</span>
 656     return TRUE;
 657 
 658   return FALSE;
 659 }
 660 
 661 static gboolean
<span class="line-modified"> 662 g_node_traverse_in_order (GNode        *node,</span>
<span class="line-modified"> 663                           GTraverseFlags    flags,</span>
<span class="line-modified"> 664                           GNodeTraverseFunc func,</span>
<span class="line-modified"> 665               gpointer      data)</span>
 666 {
 667   if (node-&gt;children)
 668     {
 669       GNode *child;
 670       GNode *current;
 671 
 672       child = node-&gt;children;
 673       current = child;
 674       child = current-&gt;next;
 675 
 676       if (g_node_traverse_in_order (current, flags, func, data))
<span class="line-modified"> 677     return TRUE;</span>
 678 
 679       if ((flags &amp; G_TRAVERSE_NON_LEAFS) &amp;&amp;
<span class="line-modified"> 680       func (node, data))</span>
<span class="line-modified"> 681     return TRUE;</span>
 682 
 683       while (child)
<span class="line-modified"> 684     {</span>
<span class="line-modified"> 685       current = child;</span>
<span class="line-modified"> 686       child = current-&gt;next;</span>
<span class="line-modified"> 687       if (g_node_traverse_in_order (current, flags, func, data))</span>
<span class="line-modified"> 688         return TRUE;</span>
<span class="line-modified"> 689     }</span>
 690     }
 691   else if ((flags &amp; G_TRAVERSE_LEAFS) &amp;&amp;
<span class="line-modified"> 692        func (node, data))</span>
 693     return TRUE;
 694 
 695   return FALSE;
 696 }
 697 
 698 static gboolean
<span class="line-modified"> 699 g_node_depth_traverse_in_order (GNode        *node,</span>
<span class="line-modified"> 700                 GTraverseFlags    flags,</span>
<span class="line-modified"> 701                 guint         depth,</span>
<span class="line-modified"> 702                                 GNodeTraverseFunc func,</span>
<span class="line-modified"> 703                 gpointer      data)</span>
 704 {
 705   if (node-&gt;children)
 706     {
 707       depth--;
 708       if (depth)
<span class="line-modified"> 709     {</span>
<span class="line-modified"> 710       GNode *child;</span>
<span class="line-modified"> 711       GNode *current;</span>
<span class="line-modified"> 712 </span>
<span class="line-modified"> 713       child = node-&gt;children;</span>
<span class="line-modified"> 714       current = child;</span>
<span class="line-modified"> 715       child = current-&gt;next;</span>
<span class="line-modified"> 716 </span>
<span class="line-modified"> 717       if (g_node_depth_traverse_in_order (current, flags, depth, func, data))</span>
<span class="line-modified"> 718         return TRUE;</span>
<span class="line-modified"> 719 </span>
<span class="line-modified"> 720       if ((flags &amp; G_TRAVERSE_NON_LEAFS) &amp;&amp;</span>
<span class="line-modified"> 721           func (node, data))</span>
<span class="line-modified"> 722         return TRUE;</span>
<span class="line-modified"> 723 </span>
<span class="line-modified"> 724       while (child)</span>
<span class="line-modified"> 725         {</span>
<span class="line-modified"> 726           current = child;</span>
<span class="line-modified"> 727           child = current-&gt;next;</span>
<span class="line-modified"> 728           if (g_node_depth_traverse_in_order (current, flags, depth, func, data))</span>
<span class="line-removed"> 729         return TRUE;</span>
<span class="line-removed"> 730         }</span>
<span class="line-removed"> 731     }</span>
<span class="line-removed"> 732       else if ((flags &amp; G_TRAVERSE_NON_LEAFS) &amp;&amp;</span>
<span class="line-removed"> 733            func (node, data))</span>
 734     return TRUE;





 735     }
 736   else if ((flags &amp; G_TRAVERSE_LEAFS) &amp;&amp;
<span class="line-modified"> 737        func (node, data))</span>
 738     return TRUE;
 739 
 740   return FALSE;
 741 }
 742 
 743 static gboolean
<span class="line-modified"> 744 g_node_traverse_level (GNode         *node,</span>
<span class="line-modified"> 745                GTraverseFlags     flags,</span>
<span class="line-modified"> 746                guint          level,</span>
<span class="line-modified"> 747                        GNodeTraverseFunc  func,</span>
<span class="line-modified"> 748                gpointer           data,</span>
<span class="line-modified"> 749                        gboolean          *more_levels)</span>
 750 {
 751   if (level == 0)
 752     {
 753       if (node-&gt;children)
<span class="line-modified"> 754     {</span>
<span class="line-modified"> 755       *more_levels = TRUE;</span>
<span class="line-modified"> 756       return (flags &amp; G_TRAVERSE_NON_LEAFS) &amp;&amp; func (node, data);</span>
<span class="line-modified"> 757     }</span>
 758       else
<span class="line-modified"> 759     {</span>
<span class="line-modified"> 760       return (flags &amp; G_TRAVERSE_LEAFS) &amp;&amp; func (node, data);</span>
<span class="line-modified"> 761     }</span>
 762     }
 763   else
 764     {
 765       node = node-&gt;children;
 766 
 767       while (node)
<span class="line-modified"> 768     {</span>
<span class="line-modified"> 769       if (g_node_traverse_level (node, flags, level - 1, func, data, more_levels))</span>
<span class="line-modified"> 770         return TRUE;</span>
 771 
<span class="line-modified"> 772       node = node-&gt;next;</span>
<span class="line-modified"> 773     }</span>
 774     }
 775 
 776   return FALSE;
 777 }
 778 
 779 static gboolean
 780 g_node_depth_traverse_level (GNode             *node,
<span class="line-modified"> 781                  GTraverseFlags flags,</span>
<span class="line-modified"> 782                  gint       depth,</span>
<span class="line-modified"> 783                              GNodeTraverseFunc  func,</span>
<span class="line-modified"> 784                  gpointer           data)</span>
 785 {
 786   guint level;
 787   gboolean more_levels;
 788 
 789   level = 0;
 790   while (depth &lt; 0 || level != (guint) depth)
 791     {
 792       more_levels = FALSE;
 793       if (g_node_traverse_level (node, flags, level, func, data, &amp;more_levels))
<span class="line-modified"> 794     return TRUE;</span>
 795       if (!more_levels)
<span class="line-modified"> 796     break;</span>
 797       level++;
 798     }
 799   return FALSE;
 800 }
 801 
 802 /**
 803  * g_node_traverse:
 804  * @root: the root #GNode of the tree to traverse
 805  * @order: the order in which nodes are visited - %G_IN_ORDER,
 806  *     %G_PRE_ORDER, %G_POST_ORDER, or %G_LEVEL_ORDER.
 807  * @flags: which types of children are to be visited, one of
 808  *     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
 809  * @max_depth: the maximum depth of the traversal. Nodes below this
 810  *     depth will not be visited. If max_depth is -1 all nodes in
 811  *     the tree are visited. If depth is 1, only the root is visited.
 812  *     If depth is 2, the root and its children are visited. And so on.
 813  * @func: the function to call for each visited #GNode
 814  * @data: user data to pass to the function
 815  *
 816  * Traverses a tree starting at the given root #GNode.
</pre>
<hr />
<pre>
 859  * @G_TRAVERSE_MASK: a mask of all traverse flags.
 860  * @G_TRAVERSE_LEAFS: identical to %G_TRAVERSE_LEAVES.
 861  * @G_TRAVERSE_NON_LEAFS: identical to %G_TRAVERSE_NON_LEAVES.
 862  *
 863  * Specifies which nodes are visited during several of the tree
 864  * functions, including g_node_traverse() and g_node_find().
 865  **/
 866 /**
 867  * GNodeTraverseFunc:
 868  * @node: a #GNode.
 869  * @data: user data passed to g_node_traverse().
 870  *
 871  * Specifies the type of function passed to g_node_traverse(). The
 872  * function is called with each of the nodes visited, together with the
 873  * user data passed to g_node_traverse(). If the function returns
 874  * %TRUE, then the traversal is stopped.
 875  *
 876  * Returns: %TRUE to stop the traversal.
 877  **/
 878 void
<span class="line-modified"> 879 g_node_traverse (GNode        *root,</span>
<span class="line-modified"> 880          GTraverseType     order,</span>
<span class="line-modified"> 881          GTraverseFlags    flags,</span>
<span class="line-modified"> 882          gint          depth,</span>
<span class="line-modified"> 883                  GNodeTraverseFunc func,</span>
<span class="line-modified"> 884          gpointer      data)</span>
 885 {
 886   g_return_if_fail (root != NULL);
 887   g_return_if_fail (func != NULL);
 888   g_return_if_fail (order &lt;= G_LEVEL_ORDER);
 889   g_return_if_fail (flags &lt;= G_TRAVERSE_MASK);
 890   g_return_if_fail (depth == -1 || depth &gt; 0);
 891 
 892   switch (order)
 893     {
 894     case G_PRE_ORDER:
 895       if (depth &lt; 0)
<span class="line-modified"> 896     g_node_traverse_pre_order (root, flags, func, data);</span>
 897       else
<span class="line-modified"> 898     g_node_depth_traverse_pre_order (root, flags, depth, func, data);</span>
 899       break;
 900     case G_POST_ORDER:
 901       if (depth &lt; 0)
<span class="line-modified"> 902     g_node_traverse_post_order (root, flags, func, data);</span>
 903       else
<span class="line-modified"> 904     g_node_depth_traverse_post_order (root, flags, depth, func, data);</span>
 905       break;
 906     case G_IN_ORDER:
 907       if (depth &lt; 0)
<span class="line-modified"> 908     g_node_traverse_in_order (root, flags, func, data);</span>
 909       else
<span class="line-modified"> 910     g_node_depth_traverse_in_order (root, flags, depth, func, data);</span>
 911       break;
 912     case G_LEVEL_ORDER:
 913       g_node_depth_traverse_level (root, flags, depth, func, data);
 914       break;
 915     }
 916 }
 917 
 918 static gboolean
 919 g_node_find_func (GNode    *node,
<span class="line-modified"> 920           gpointer  data)</span>
 921 {
 922   gpointer *d = data;
 923 
 924   if (*d != node-&gt;data)
 925     return FALSE;
 926 
 927   *(++d) = node;
 928 
 929   return TRUE;
 930 }
 931 
 932 /**
 933  * g_node_find:
 934  * @root: the root #GNode of the tree to search
 935  * @order: the order in which nodes are visited - %G_IN_ORDER,
 936  *     %G_PRE_ORDER, %G_POST_ORDER, or %G_LEVEL_ORDER
 937  * @flags: which types of children are to be searched, one of
 938  *     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
 939  * @data: the data to find
 940  *
 941  * Finds a #GNode in a tree.
 942  *
 943  * Returns: the found #GNode, or %NULL if the data is not found
 944  */
 945 GNode*
 946 g_node_find (GNode      *root,
<span class="line-modified"> 947              GTraverseType   order,</span>
<span class="line-modified"> 948              GTraverseFlags  flags,</span>
<span class="line-modified"> 949              gpointer        data)</span>
 950 {
 951   gpointer d[2];
 952 
 953   g_return_val_if_fail (root != NULL, NULL);
 954   g_return_val_if_fail (order &lt;= G_LEVEL_ORDER, NULL);
 955   g_return_val_if_fail (flags &lt;= G_TRAVERSE_MASK, NULL);
 956 
 957   d[0] = data;
 958   d[1] = NULL;
 959 
 960   g_node_traverse (root, order, flags, -1, g_node_find_func, d);
 961 
 962   return d[1];
 963 }
 964 
 965 static void
<span class="line-modified"> 966 g_node_count_func (GNode     *node,</span>
<span class="line-modified"> 967                    GTraverseFlags flags,</span>
<span class="line-modified"> 968            guint     *n)</span>
 969 {
 970   if (node-&gt;children)
 971     {
 972       GNode *child;
 973 
 974       if (flags &amp; G_TRAVERSE_NON_LEAFS)
<span class="line-modified"> 975     (*n)++;</span>
 976 
 977       child = node-&gt;children;
 978       while (child)
<span class="line-modified"> 979     {</span>
<span class="line-modified"> 980       g_node_count_func (child, flags, n);</span>
<span class="line-modified"> 981       child = child-&gt;next;</span>
<span class="line-modified"> 982     }</span>
 983     }
 984   else if (flags &amp; G_TRAVERSE_LEAFS)
 985     (*n)++;
 986 }
 987 
 988 /**
 989  * g_node_n_nodes:
 990  * @root: a #GNode
 991  * @flags: which types of children are to be counted, one of
 992  *     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
 993  *
 994  * Gets the number of nodes in a tree.
 995  *
 996  * Returns: the number of nodes in the tree
 997  */
 998 guint
<span class="line-modified"> 999 g_node_n_nodes (GNode          *root,</span>
<span class="line-modified">1000                 GTraverseFlags  flags)</span>
1001 {
1002   guint n = 0;
1003 
1004   g_return_val_if_fail (root != NULL, 0);
1005   g_return_val_if_fail (flags &lt;= G_TRAVERSE_MASK, 0);
1006 
1007   g_node_count_func (root, flags, &amp;n);
1008 
1009   return n;
1010 }
1011 
1012 /**
1013  * g_node_last_child:
1014  * @node: a #GNode (must not be %NULL)
1015  *
1016  * Gets the last child of a #GNode.
1017  *
1018  * Returns: the last child of @node, or %NULL if @node has no children
1019  */
1020 GNode*
</pre>
<hr />
<pre>
1026   if (node)
1027     while (node-&gt;next)
1028       node = node-&gt;next;
1029 
1030   return node;
1031 }
1032 
1033 /**
1034  * g_node_nth_child:
1035  * @node: a #GNode
1036  * @n: the index of the desired child
1037  *
1038  * Gets a child of a #GNode, using the given index.
1039  * The first child is at index 0. If the index is
1040  * too big, %NULL is returned.
1041  *
1042  * Returns: the child of @node at index @n
1043  */
1044 GNode*
1045 g_node_nth_child (GNode *node,
<span class="line-modified">1046           guint  n)</span>
1047 {
1048   g_return_val_if_fail (node != NULL, NULL);
1049 
1050   node = node-&gt;children;
1051   if (node)
1052     while ((n-- &gt; 0) &amp;&amp; node)
1053       node = node-&gt;next;
1054 
1055   return node;
1056 }
1057 
1058 /**
1059  * g_node_n_children:
1060  * @node: a #GNode
1061  *
1062  * Gets the number of children of a #GNode.
1063  *
1064  * Returns: the number of children of @node
1065  */
1066 guint
</pre>
<hr />
<pre>
1075     {
1076       n++;
1077       node = node-&gt;next;
1078     }
1079 
1080   return n;
1081 }
1082 
1083 /**
1084  * g_node_find_child:
1085  * @node: a #GNode
1086  * @flags: which types of children are to be searched, one of
1087  *     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
1088  * @data: the data to find
1089  *
1090  * Finds the first child of a #GNode with the given data.
1091  *
1092  * Returns: the found child #GNode, or %NULL if the data is not found
1093  */
1094 GNode*
<span class="line-modified">1095 g_node_find_child (GNode      *node,</span>
<span class="line-modified">1096                    GTraverseFlags  flags,</span>
<span class="line-modified">1097            gpointer    data)</span>
1098 {
1099   g_return_val_if_fail (node != NULL, NULL);
1100   g_return_val_if_fail (flags &lt;= G_TRAVERSE_MASK, NULL);
1101 
1102   node = node-&gt;children;
1103   while (node)
1104     {
1105       if (node-&gt;data == data)
<span class="line-modified">1106     {</span>
<span class="line-modified">1107       if (G_NODE_IS_LEAF (node))</span>
<span class="line-modified">1108         {</span>
<span class="line-modified">1109           if (flags &amp; G_TRAVERSE_LEAFS)</span>
<span class="line-modified">1110         return node;</span>
<span class="line-modified">1111         }</span>
<span class="line-modified">1112       else</span>
<span class="line-modified">1113         {</span>
<span class="line-modified">1114           if (flags &amp; G_TRAVERSE_NON_LEAFS)</span>
<span class="line-modified">1115         return node;</span>
<span class="line-modified">1116         }</span>
<span class="line-modified">1117     }</span>
1118       node = node-&gt;next;
1119     }
1120 
1121   return NULL;
1122 }
1123 
1124 /**
1125  * g_node_child_position:
1126  * @node: a #GNode
1127  * @child: a child of @node
1128  *
1129  * Gets the position of a #GNode with respect to its siblings.
1130  * @child must be a child of @node. The first child is numbered 0,
1131  * the second 1, and so on.
1132  *
1133  * Returns: the position of @child with respect to its siblings
1134  */
1135 gint
1136 g_node_child_position (GNode *node,
<span class="line-modified">1137                GNode *child)</span>
1138 {
1139   guint n = 0;
1140 
1141   g_return_val_if_fail (node != NULL, -1);
1142   g_return_val_if_fail (child != NULL, -1);
1143   g_return_val_if_fail (child-&gt;parent == node, -1);
1144 
1145   node = node-&gt;children;
1146   while (node)
1147     {
1148       if (node == child)
<span class="line-modified">1149     return n;</span>
1150       n++;
1151       node = node-&gt;next;
1152     }
1153 
1154   return -1;
1155 }
1156 
1157 /**
1158  * g_node_child_index:
1159  * @node: a #GNode
1160  * @data: the data to find
1161  *
1162  * Gets the position of the first child of a #GNode
1163  * which contains the given data.
1164  *
1165  * Returns: the index of the child of @node which contains
1166  *     @data, or -1 if the data is not found
1167  */
1168 gint
1169 g_node_child_index (GNode    *node,
<span class="line-modified">1170             gpointer  data)</span>
1171 {
1172   guint n = 0;
1173 
1174   g_return_val_if_fail (node != NULL, -1);
1175 
1176   node = node-&gt;children;
1177   while (node)
1178     {
1179       if (node-&gt;data == data)
<span class="line-modified">1180     return n;</span>
1181       n++;
1182       node = node-&gt;next;
1183     }
1184 
1185   return -1;
1186 }
1187 
1188 /**
1189  * g_node_first_sibling:
1190  * @node: a #GNode
1191  *
1192  * Gets the first sibling of a #GNode.
1193  * This could possibly be the node itself.
1194  *
1195  * Returns: the first sibling of @node
1196  */
1197 GNode*
1198 g_node_first_sibling (GNode *node)
1199 {
1200   g_return_val_if_fail (node != NULL, NULL);
</pre>
<hr />
<pre>
1233  * @node: a #GNode
1234  * @flags: which types of children are to be visited, one of
1235  *     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
1236  * @func: the function to call for each visited node
1237  * @data: user data to pass to the function
1238  *
1239  * Calls a function for each of the children of a #GNode. Note that it
1240  * doesn&#39;t descend beneath the child nodes. @func must not do anything
1241  * that would modify the structure of the tree.
1242  */
1243 /**
1244  * GNodeForeachFunc:
1245  * @node: a #GNode.
1246  * @data: user data passed to g_node_children_foreach().
1247  *
1248  * Specifies the type of function passed to g_node_children_foreach().
1249  * The function is called with each child node, together with the user
1250  * data passed to g_node_children_foreach().
1251  **/
1252 void
<span class="line-modified">1253 g_node_children_foreach (GNode        *node,</span>
<span class="line-modified">1254              GTraverseFlags    flags,</span>
<span class="line-modified">1255                          GNodeForeachFunc  func,</span>
<span class="line-modified">1256              gpointer      data)</span>
1257 {
1258   g_return_if_fail (node != NULL);
1259   g_return_if_fail (flags &lt;= G_TRAVERSE_MASK);
1260   g_return_if_fail (func != NULL);
1261 
1262   node = node-&gt;children;
1263   while (node)
1264     {
1265       GNode *current;
1266 
1267       current = node;
1268       node = current-&gt;next;
1269       if (G_NODE_IS_LEAF (current))
<span class="line-modified">1270     {</span>
<span class="line-modified">1271       if (flags &amp; G_TRAVERSE_LEAFS)</span>
<span class="line-modified">1272         func (current, data);</span>
<span class="line-modified">1273     }</span>
1274       else
<span class="line-modified">1275     {</span>
<span class="line-modified">1276       if (flags &amp; G_TRAVERSE_NON_LEAFS)</span>
<span class="line-modified">1277         func (current, data);</span>
<span class="line-modified">1278     }</span>
1279     }
1280 }
</pre>
</td>
<td>
<hr />
<pre>
 163       node-&gt;next = NULL;
 164     }
 165   node-&gt;prev = NULL;
 166 }
 167 
 168 /**
 169  * g_node_copy_deep:
 170  * @node: a #GNode
 171  * @copy_func: the function which is called to copy the data inside each node,
 172  *   or %NULL to use the original data.
 173  * @data: data to pass to @copy_func
 174  *
 175  * Recursively copies a #GNode and its data.
 176  *
 177  * Returns: a new #GNode containing copies of the data in @node.
 178  *
 179  * Since: 2.4
 180  **/
 181 GNode*
 182 g_node_copy_deep (GNode     *node,
<span class="line-modified"> 183       GCopyFunc  copy_func,</span>
<span class="line-modified"> 184       gpointer   data)</span>
 185 {
 186   GNode *new_node = NULL;
 187 
 188   if (copy_func == NULL)
<span class="line-modified"> 189   return g_node_copy (node);</span>
 190 
 191   if (node)
 192     {
 193       GNode *child, *new_child;
 194 
 195       new_node = g_node_new (copy_func (node-&gt;data, data));
 196 
 197       for (child = g_node_last_child (node); child; child = child-&gt;prev)
<span class="line-modified"> 198   {</span>
<span class="line-modified"> 199     new_child = g_node_copy_deep (child, copy_func, data);</span>
<span class="line-modified"> 200     g_node_prepend (new_node, new_child);</span>
<span class="line-modified"> 201   }</span>
 202     }
 203 
 204   return new_node;
 205 }
 206 
 207 /**
 208  * g_node_copy:
 209  * @node: a #GNode
 210  *
 211  * Recursively copies a #GNode (but does not deep-copy the data inside the
 212  * nodes, see g_node_copy_deep() if you need that).
 213  *
 214  * Returns: a new #GNode containing the same data pointers
 215  */
 216 GNode*
 217 g_node_copy (GNode *node)
 218 {
 219   GNode *new_node = NULL;
 220 
 221   if (node)
 222     {
 223       GNode *child;
 224 
 225       new_node = g_node_new (node-&gt;data);
 226 
 227       for (child = g_node_last_child (node); child; child = child-&gt;prev)
<span class="line-modified"> 228   g_node_prepend (new_node, g_node_copy (child));</span>
 229     }
 230 
 231   return new_node;
 232 }
 233 
 234 /**
 235  * g_node_insert:
 236  * @parent: the #GNode to place @node under
 237  * @position: the position to place @node at, with respect to its siblings
 238  *     If position is -1, @node is inserted as the last child of @parent
 239  * @node: the #GNode to insert
 240  *
 241  * Inserts a #GNode beneath the parent at the given position.
 242  *
 243  * Returns: the inserted #GNode
 244  */
 245 GNode*
 246 g_node_insert (GNode *parent,
<span class="line-modified"> 247          gint   position,</span>
<span class="line-modified"> 248          GNode *node)</span>
 249 {
 250   g_return_val_if_fail (parent != NULL, node);
 251   g_return_val_if_fail (node != NULL, node);
 252   g_return_val_if_fail (G_NODE_IS_ROOT (node), node);
 253 
 254   if (position &gt; 0)
 255     return g_node_insert_before (parent,
<span class="line-modified"> 256          g_node_nth_child (parent, position),</span>
<span class="line-modified"> 257          node);</span>
 258   else if (position == 0)
 259     return g_node_prepend (parent, node);
 260   else /* if (position &lt; 0) */
 261     return g_node_append (parent, node);
 262 }
 263 
 264 /**
 265  * g_node_insert_before:
 266  * @parent: the #GNode to place @node under
 267  * @sibling: the sibling #GNode to place @node before.
 268  *     If sibling is %NULL, the node is inserted as the last child of @parent.
 269  * @node: the #GNode to insert
 270  *
 271  * Inserts a #GNode beneath the parent before the given sibling.
 272  *
 273  * Returns: the inserted #GNode
 274  */
 275 GNode*
 276 g_node_insert_before (GNode *parent,
<span class="line-modified"> 277           GNode *sibling,</span>
<span class="line-modified"> 278           GNode *node)</span>
 279 {
 280   g_return_val_if_fail (parent != NULL, node);
 281   g_return_val_if_fail (node != NULL, node);
 282   g_return_val_if_fail (G_NODE_IS_ROOT (node), node);
 283   if (sibling)
 284     g_return_val_if_fail (sibling-&gt;parent == parent, node);
 285 
 286   node-&gt;parent = parent;
 287 
 288   if (sibling)
 289     {
 290       if (sibling-&gt;prev)
<span class="line-modified"> 291   {</span>
<span class="line-modified"> 292     node-&gt;prev = sibling-&gt;prev;</span>
<span class="line-modified"> 293     node-&gt;prev-&gt;next = node;</span>
<span class="line-modified"> 294     node-&gt;next = sibling;</span>
<span class="line-modified"> 295     sibling-&gt;prev = node;</span>
<span class="line-modified"> 296   }</span>
 297       else
<span class="line-modified"> 298   {</span>
<span class="line-modified"> 299     node-&gt;parent-&gt;children = node;</span>
<span class="line-modified"> 300     node-&gt;next = sibling;</span>
<span class="line-modified"> 301     sibling-&gt;prev = node;</span>
<span class="line-modified"> 302   }</span>
 303     }
 304   else
 305     {
 306       if (parent-&gt;children)
<span class="line-modified"> 307   {</span>
<span class="line-modified"> 308     sibling = parent-&gt;children;</span>
<span class="line-modified"> 309     while (sibling-&gt;next)</span>
<span class="line-modified"> 310       sibling = sibling-&gt;next;</span>
<span class="line-modified"> 311     node-&gt;prev = sibling;</span>
<span class="line-modified"> 312     sibling-&gt;next = node;</span>
<span class="line-modified"> 313   }</span>
 314       else
<span class="line-modified"> 315   node-&gt;parent-&gt;children = node;</span>
 316     }
 317 
 318   return node;
 319 }
 320 
 321 /**
 322  * g_node_insert_after:
 323  * @parent: the #GNode to place @node under
 324  * @sibling: the sibling #GNode to place @node after.
 325  *     If sibling is %NULL, the node is inserted as the first child of @parent.
 326  * @node: the #GNode to insert
 327  *
 328  * Inserts a #GNode beneath the parent after the given sibling.
 329  *
 330  * Returns: the inserted #GNode
 331  */
 332 GNode*
 333 g_node_insert_after (GNode *parent,
<span class="line-modified"> 334          GNode *sibling,</span>
<span class="line-modified"> 335          GNode *node)</span>
 336 {
 337   g_return_val_if_fail (parent != NULL, node);
 338   g_return_val_if_fail (node != NULL, node);
 339   g_return_val_if_fail (G_NODE_IS_ROOT (node), node);
 340   if (sibling)
 341     g_return_val_if_fail (sibling-&gt;parent == parent, node);
 342 
 343   node-&gt;parent = parent;
 344 
 345   if (sibling)
 346     {
 347       if (sibling-&gt;next)
<span class="line-modified"> 348   {</span>
<span class="line-modified"> 349     sibling-&gt;next-&gt;prev = node;</span>
<span class="line-modified"> 350   }</span>
 351       node-&gt;next = sibling-&gt;next;
 352       node-&gt;prev = sibling;
 353       sibling-&gt;next = node;
 354     }
 355   else
 356     {
 357       if (parent-&gt;children)
<span class="line-modified"> 358   {</span>
<span class="line-modified"> 359     node-&gt;next = parent-&gt;children;</span>
<span class="line-modified"> 360     parent-&gt;children-&gt;prev = node;</span>
<span class="line-modified"> 361   }</span>
 362       parent-&gt;children = node;
 363     }
 364 
 365   return node;
 366 }
 367 
 368 /**
 369  * g_node_prepend:
 370  * @parent: the #GNode to place the new #GNode under
 371  * @node: the #GNode to insert
 372  *
 373  * Inserts a #GNode as the first child of the given parent.
 374  *
 375  * Returns: the inserted #GNode
 376  */
 377 GNode*
 378 g_node_prepend (GNode *parent,
<span class="line-modified"> 379     GNode *node)</span>
 380 {
 381   g_return_val_if_fail (parent != NULL, node);
 382 
 383   return g_node_insert_before (parent, parent-&gt;children, node);
 384 }
 385 
 386 /**
 387  * g_node_get_root:
 388  * @node: a #GNode
 389  *
 390  * Gets the root of a tree.
 391  *
 392  * Returns: the root of the tree
 393  */
 394 GNode*
 395 g_node_get_root (GNode *node)
 396 {
 397   g_return_val_if_fail (node != NULL, NULL);
 398 
 399   while (node-&gt;parent)
 400     node = node-&gt;parent;
 401 
 402   return node;
 403 }
 404 
 405 /**
 406  * g_node_is_ancestor:
 407  * @node: a #GNode
 408  * @descendant: a #GNode
 409  *
 410  * Returns %TRUE if @node is an ancestor of @descendant.
 411  * This is true if node is the parent of @descendant,
 412  * or if node is the grandparent of @descendant etc.
 413  *
 414  * Returns: %TRUE if @node is an ancestor of @descendant
 415  */
 416 gboolean
 417 g_node_is_ancestor (GNode *node,
<span class="line-modified"> 418         GNode *descendant)</span>
 419 {
 420   g_return_val_if_fail (node != NULL, FALSE);
 421   g_return_val_if_fail (descendant != NULL, FALSE);
 422 
 423   while (descendant)
 424     {
 425       if (descendant-&gt;parent == node)
<span class="line-modified"> 426   return TRUE;</span>
 427 
 428       descendant = descendant-&gt;parent;
 429     }
 430 
 431   return FALSE;
 432 }
 433 
 434 /**
 435  * g_node_depth:
 436  * @node: a #GNode
 437  *
 438  * Gets the depth of a #GNode.
 439  *
 440  * If @node is %NULL the depth is 0. The root node has a depth of 1.
 441  * For the children of the root node the depth is 2. And so on.
 442  *
 443  * Returns: the depth of the #GNode
 444  */
 445 guint
 446 g_node_depth (GNode *node)
</pre>
<hr />
<pre>
 494  * 1 is returned. If @root has children, 2 is returned. And so on.
 495  *
 496  * Returns: the maximum height of the tree beneath @root
 497  */
 498 guint
 499 g_node_max_height (GNode *root)
 500 {
 501   GNode *child;
 502   guint max_height = 0;
 503 
 504   if (!root)
 505     return 0;
 506 
 507   child = root-&gt;children;
 508   while (child)
 509     {
 510       guint tmp_height;
 511 
 512       tmp_height = g_node_max_height (child);
 513       if (tmp_height &gt; max_height)
<span class="line-modified"> 514   max_height = tmp_height;</span>
 515       child = child-&gt;next;
 516     }
 517 
 518   return max_height + 1;
 519 }
 520 
 521 static gboolean
<span class="line-modified"> 522 g_node_traverse_pre_order (GNode      *node,</span>
<span class="line-modified"> 523          GTraverseFlags    flags,</span>
<span class="line-modified"> 524          GNodeTraverseFunc func,</span>
<span class="line-modified"> 525          gpointer      data)</span>
 526 {
 527   if (node-&gt;children)
 528     {
 529       GNode *child;
 530 
 531       if ((flags &amp; G_TRAVERSE_NON_LEAFS) &amp;&amp;
<span class="line-modified"> 532     func (node, data))</span>
<span class="line-modified"> 533   return TRUE;</span>
 534 
 535       child = node-&gt;children;
 536       while (child)
<span class="line-modified"> 537   {</span>
<span class="line-modified"> 538     GNode *current;</span>
<span class="line-modified"> 539 </span>
<span class="line-modified"> 540     current = child;</span>
<span class="line-modified"> 541     child = current-&gt;next;</span>
<span class="line-modified"> 542     if (g_node_traverse_pre_order (current, flags, func, data))</span>
<span class="line-modified"> 543       return TRUE;</span>
<span class="line-modified"> 544   }</span>
 545     }
 546   else if ((flags &amp; G_TRAVERSE_LEAFS) &amp;&amp;
<span class="line-modified"> 547      func (node, data))</span>
 548     return TRUE;
 549 
 550   return FALSE;
 551 }
 552 
 553 static gboolean
<span class="line-modified"> 554 g_node_depth_traverse_pre_order (GNode      *node,</span>
<span class="line-modified"> 555          GTraverseFlags    flags,</span>
<span class="line-modified"> 556          guint       depth,</span>
<span class="line-modified"> 557          GNodeTraverseFunc func,</span>
<span class="line-modified"> 558          gpointer    data)</span>
 559 {
 560   if (node-&gt;children)
 561     {
 562       GNode *child;
 563 
 564       if ((flags &amp; G_TRAVERSE_NON_LEAFS) &amp;&amp;
<span class="line-modified"> 565     func (node, data))</span>
<span class="line-modified"> 566   return TRUE;</span>
 567 
 568       depth--;
 569       if (!depth)
<span class="line-modified"> 570   return FALSE;</span>
 571 
 572       child = node-&gt;children;
 573       while (child)
<span class="line-modified"> 574   {</span>
<span class="line-modified"> 575     GNode *current;</span>
<span class="line-modified"> 576 </span>
<span class="line-modified"> 577     current = child;</span>
<span class="line-modified"> 578     child = current-&gt;next;</span>
<span class="line-modified"> 579     if (g_node_depth_traverse_pre_order (current, flags, depth, func, data))</span>
<span class="line-modified"> 580       return TRUE;</span>
<span class="line-modified"> 581   }</span>
 582     }
 583   else if ((flags &amp; G_TRAVERSE_LEAFS) &amp;&amp;
<span class="line-modified"> 584      func (node, data))</span>
 585     return TRUE;
 586 
 587   return FALSE;
 588 }
 589 
 590 static gboolean
<span class="line-modified"> 591 g_node_traverse_post_order (GNode      *node,</span>
<span class="line-modified"> 592           GTraverseFlags    flags,</span>
<span class="line-modified"> 593           GNodeTraverseFunc func,</span>
<span class="line-modified"> 594           gpointer        data)</span>
 595 {
 596   if (node-&gt;children)
 597     {
 598       GNode *child;
 599 
 600       child = node-&gt;children;
 601       while (child)
<span class="line-modified"> 602   {</span>
<span class="line-modified"> 603     GNode *current;</span>
 604 
<span class="line-modified"> 605     current = child;</span>
<span class="line-modified"> 606     child = current-&gt;next;</span>
<span class="line-modified"> 607     if (g_node_traverse_post_order (current, flags, func, data))</span>
<span class="line-modified"> 608       return TRUE;</span>
<span class="line-modified"> 609   }</span>
 610 
 611       if ((flags &amp; G_TRAVERSE_NON_LEAFS) &amp;&amp;
<span class="line-modified"> 612     func (node, data))</span>
<span class="line-modified"> 613   return TRUE;</span>
 614 
 615     }
 616   else if ((flags &amp; G_TRAVERSE_LEAFS) &amp;&amp;
<span class="line-modified"> 617      func (node, data))</span>
 618     return TRUE;
 619 
 620   return FALSE;
 621 }
 622 
 623 static gboolean
<span class="line-modified"> 624 g_node_depth_traverse_post_order (GNode      *node,</span>
<span class="line-modified"> 625           GTraverseFlags    flags,</span>
<span class="line-modified"> 626           guint       depth,</span>
<span class="line-modified"> 627           GNodeTraverseFunc func,</span>
<span class="line-modified"> 628           gpointer      data)</span>
 629 {
 630   if (node-&gt;children)
 631     {
 632       depth--;
 633       if (depth)
<span class="line-modified"> 634   {</span>
<span class="line-modified"> 635     GNode *child;</span>
 636 
<span class="line-modified"> 637     child = node-&gt;children;</span>
<span class="line-modified"> 638     while (child)</span>
<span class="line-modified"> 639       {</span>
<span class="line-modified"> 640         GNode *current;</span>







 641 
<span class="line-modified"> 642         current = child;</span>
<span class="line-modified"> 643         child = current-&gt;next;</span>
<span class="line-added"> 644         if (g_node_depth_traverse_post_order (current, flags, depth, func, data))</span>
 645     return TRUE;
<span class="line-added"> 646       }</span>
<span class="line-added"> 647   }</span>
<span class="line-added"> 648 </span>
<span class="line-added"> 649       if ((flags &amp; G_TRAVERSE_NON_LEAFS) &amp;&amp;</span>
<span class="line-added"> 650     func (node, data))</span>
<span class="line-added"> 651   return TRUE;</span>
 652 
 653     }
 654   else if ((flags &amp; G_TRAVERSE_LEAFS) &amp;&amp;
<span class="line-modified"> 655      func (node, data))</span>
 656     return TRUE;
 657 
 658   return FALSE;
 659 }
 660 
 661 static gboolean
<span class="line-modified"> 662 g_node_traverse_in_order (GNode      *node,</span>
<span class="line-modified"> 663         GTraverseFlags    flags,</span>
<span class="line-modified"> 664         GNodeTraverseFunc func,</span>
<span class="line-modified"> 665         gpointer      data)</span>
 666 {
 667   if (node-&gt;children)
 668     {
 669       GNode *child;
 670       GNode *current;
 671 
 672       child = node-&gt;children;
 673       current = child;
 674       child = current-&gt;next;
 675 
 676       if (g_node_traverse_in_order (current, flags, func, data))
<span class="line-modified"> 677   return TRUE;</span>
 678 
 679       if ((flags &amp; G_TRAVERSE_NON_LEAFS) &amp;&amp;
<span class="line-modified"> 680     func (node, data))</span>
<span class="line-modified"> 681   return TRUE;</span>
 682 
 683       while (child)
<span class="line-modified"> 684   {</span>
<span class="line-modified"> 685     current = child;</span>
<span class="line-modified"> 686     child = current-&gt;next;</span>
<span class="line-modified"> 687     if (g_node_traverse_in_order (current, flags, func, data))</span>
<span class="line-modified"> 688       return TRUE;</span>
<span class="line-modified"> 689   }</span>
 690     }
 691   else if ((flags &amp; G_TRAVERSE_LEAFS) &amp;&amp;
<span class="line-modified"> 692      func (node, data))</span>
 693     return TRUE;
 694 
 695   return FALSE;
 696 }
 697 
 698 static gboolean
<span class="line-modified"> 699 g_node_depth_traverse_in_order (GNode    *node,</span>
<span class="line-modified"> 700         GTraverseFlags    flags,</span>
<span class="line-modified"> 701         guint     depth,</span>
<span class="line-modified"> 702         GNodeTraverseFunc func,</span>
<span class="line-modified"> 703         gpointer    data)</span>
 704 {
 705   if (node-&gt;children)
 706     {
 707       depth--;
 708       if (depth)
<span class="line-modified"> 709   {</span>
<span class="line-modified"> 710     GNode *child;</span>
<span class="line-modified"> 711     GNode *current;</span>
<span class="line-modified"> 712 </span>
<span class="line-modified"> 713     child = node-&gt;children;</span>
<span class="line-modified"> 714     current = child;</span>
<span class="line-modified"> 715     child = current-&gt;next;</span>
<span class="line-modified"> 716 </span>
<span class="line-modified"> 717     if (g_node_depth_traverse_in_order (current, flags, depth, func, data))</span>
<span class="line-modified"> 718       return TRUE;</span>
<span class="line-modified"> 719 </span>
<span class="line-modified"> 720     if ((flags &amp; G_TRAVERSE_NON_LEAFS) &amp;&amp;</span>
<span class="line-modified"> 721         func (node, data))</span>
<span class="line-modified"> 722       return TRUE;</span>
<span class="line-modified"> 723 </span>
<span class="line-modified"> 724     while (child)</span>
<span class="line-modified"> 725       {</span>
<span class="line-modified"> 726         current = child;</span>
<span class="line-modified"> 727         child = current-&gt;next;</span>
<span class="line-modified"> 728         if (g_node_depth_traverse_in_order (current, flags, depth, func, data))</span>





 729     return TRUE;
<span class="line-added"> 730       }</span>
<span class="line-added"> 731   }</span>
<span class="line-added"> 732       else if ((flags &amp; G_TRAVERSE_NON_LEAFS) &amp;&amp;</span>
<span class="line-added"> 733          func (node, data))</span>
<span class="line-added"> 734   return TRUE;</span>
 735     }
 736   else if ((flags &amp; G_TRAVERSE_LEAFS) &amp;&amp;
<span class="line-modified"> 737      func (node, data))</span>
 738     return TRUE;
 739 
 740   return FALSE;
 741 }
 742 
 743 static gboolean
<span class="line-modified"> 744 g_node_traverse_level (GNode     *node,</span>
<span class="line-modified"> 745            GTraverseFlags   flags,</span>
<span class="line-modified"> 746            guint      level,</span>
<span class="line-modified"> 747            GNodeTraverseFunc  func,</span>
<span class="line-modified"> 748            gpointer           data,</span>
<span class="line-modified"> 749            gboolean          *more_levels)</span>
 750 {
 751   if (level == 0)
 752     {
 753       if (node-&gt;children)
<span class="line-modified"> 754   {</span>
<span class="line-modified"> 755     *more_levels = TRUE;</span>
<span class="line-modified"> 756     return (flags &amp; G_TRAVERSE_NON_LEAFS) &amp;&amp; func (node, data);</span>
<span class="line-modified"> 757   }</span>
 758       else
<span class="line-modified"> 759   {</span>
<span class="line-modified"> 760     return (flags &amp; G_TRAVERSE_LEAFS) &amp;&amp; func (node, data);</span>
<span class="line-modified"> 761   }</span>
 762     }
 763   else
 764     {
 765       node = node-&gt;children;
 766 
 767       while (node)
<span class="line-modified"> 768   {</span>
<span class="line-modified"> 769     if (g_node_traverse_level (node, flags, level - 1, func, data, more_levels))</span>
<span class="line-modified"> 770       return TRUE;</span>
 771 
<span class="line-modified"> 772     node = node-&gt;next;</span>
<span class="line-modified"> 773   }</span>
 774     }
 775 
 776   return FALSE;
 777 }
 778 
 779 static gboolean
 780 g_node_depth_traverse_level (GNode             *node,
<span class="line-modified"> 781            GTraverseFlags flags,</span>
<span class="line-modified"> 782            gint   depth,</span>
<span class="line-modified"> 783            GNodeTraverseFunc  func,</span>
<span class="line-modified"> 784            gpointer         data)</span>
 785 {
 786   guint level;
 787   gboolean more_levels;
 788 
 789   level = 0;
 790   while (depth &lt; 0 || level != (guint) depth)
 791     {
 792       more_levels = FALSE;
 793       if (g_node_traverse_level (node, flags, level, func, data, &amp;more_levels))
<span class="line-modified"> 794   return TRUE;</span>
 795       if (!more_levels)
<span class="line-modified"> 796   break;</span>
 797       level++;
 798     }
 799   return FALSE;
 800 }
 801 
 802 /**
 803  * g_node_traverse:
 804  * @root: the root #GNode of the tree to traverse
 805  * @order: the order in which nodes are visited - %G_IN_ORDER,
 806  *     %G_PRE_ORDER, %G_POST_ORDER, or %G_LEVEL_ORDER.
 807  * @flags: which types of children are to be visited, one of
 808  *     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
 809  * @max_depth: the maximum depth of the traversal. Nodes below this
 810  *     depth will not be visited. If max_depth is -1 all nodes in
 811  *     the tree are visited. If depth is 1, only the root is visited.
 812  *     If depth is 2, the root and its children are visited. And so on.
 813  * @func: the function to call for each visited #GNode
 814  * @data: user data to pass to the function
 815  *
 816  * Traverses a tree starting at the given root #GNode.
</pre>
<hr />
<pre>
 859  * @G_TRAVERSE_MASK: a mask of all traverse flags.
 860  * @G_TRAVERSE_LEAFS: identical to %G_TRAVERSE_LEAVES.
 861  * @G_TRAVERSE_NON_LEAFS: identical to %G_TRAVERSE_NON_LEAVES.
 862  *
 863  * Specifies which nodes are visited during several of the tree
 864  * functions, including g_node_traverse() and g_node_find().
 865  **/
 866 /**
 867  * GNodeTraverseFunc:
 868  * @node: a #GNode.
 869  * @data: user data passed to g_node_traverse().
 870  *
 871  * Specifies the type of function passed to g_node_traverse(). The
 872  * function is called with each of the nodes visited, together with the
 873  * user data passed to g_node_traverse(). If the function returns
 874  * %TRUE, then the traversal is stopped.
 875  *
 876  * Returns: %TRUE to stop the traversal.
 877  **/
 878 void
<span class="line-modified"> 879 g_node_traverse (GNode      *root,</span>
<span class="line-modified"> 880      GTraverseType     order,</span>
<span class="line-modified"> 881      GTraverseFlags    flags,</span>
<span class="line-modified"> 882      gint      depth,</span>
<span class="line-modified"> 883      GNodeTraverseFunc func,</span>
<span class="line-modified"> 884      gpointer    data)</span>
 885 {
 886   g_return_if_fail (root != NULL);
 887   g_return_if_fail (func != NULL);
 888   g_return_if_fail (order &lt;= G_LEVEL_ORDER);
 889   g_return_if_fail (flags &lt;= G_TRAVERSE_MASK);
 890   g_return_if_fail (depth == -1 || depth &gt; 0);
 891 
 892   switch (order)
 893     {
 894     case G_PRE_ORDER:
 895       if (depth &lt; 0)
<span class="line-modified"> 896   g_node_traverse_pre_order (root, flags, func, data);</span>
 897       else
<span class="line-modified"> 898   g_node_depth_traverse_pre_order (root, flags, depth, func, data);</span>
 899       break;
 900     case G_POST_ORDER:
 901       if (depth &lt; 0)
<span class="line-modified"> 902   g_node_traverse_post_order (root, flags, func, data);</span>
 903       else
<span class="line-modified"> 904   g_node_depth_traverse_post_order (root, flags, depth, func, data);</span>
 905       break;
 906     case G_IN_ORDER:
 907       if (depth &lt; 0)
<span class="line-modified"> 908   g_node_traverse_in_order (root, flags, func, data);</span>
 909       else
<span class="line-modified"> 910   g_node_depth_traverse_in_order (root, flags, depth, func, data);</span>
 911       break;
 912     case G_LEVEL_ORDER:
 913       g_node_depth_traverse_level (root, flags, depth, func, data);
 914       break;
 915     }
 916 }
 917 
 918 static gboolean
 919 g_node_find_func (GNode    *node,
<span class="line-modified"> 920       gpointer  data)</span>
 921 {
 922   gpointer *d = data;
 923 
 924   if (*d != node-&gt;data)
 925     return FALSE;
 926 
 927   *(++d) = node;
 928 
 929   return TRUE;
 930 }
 931 
 932 /**
 933  * g_node_find:
 934  * @root: the root #GNode of the tree to search
 935  * @order: the order in which nodes are visited - %G_IN_ORDER,
 936  *     %G_PRE_ORDER, %G_POST_ORDER, or %G_LEVEL_ORDER
 937  * @flags: which types of children are to be searched, one of
 938  *     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
 939  * @data: the data to find
 940  *
 941  * Finds a #GNode in a tree.
 942  *
 943  * Returns: the found #GNode, or %NULL if the data is not found
 944  */
 945 GNode*
 946 g_node_find (GNode      *root,
<span class="line-modified"> 947        GTraverseType   order,</span>
<span class="line-modified"> 948        GTraverseFlags  flags,</span>
<span class="line-modified"> 949        gpointer        data)</span>
 950 {
 951   gpointer d[2];
 952 
 953   g_return_val_if_fail (root != NULL, NULL);
 954   g_return_val_if_fail (order &lt;= G_LEVEL_ORDER, NULL);
 955   g_return_val_if_fail (flags &lt;= G_TRAVERSE_MASK, NULL);
 956 
 957   d[0] = data;
 958   d[1] = NULL;
 959 
 960   g_node_traverse (root, order, flags, -1, g_node_find_func, d);
 961 
 962   return d[1];
 963 }
 964 
 965 static void
<span class="line-modified"> 966 g_node_count_func (GNode   *node,</span>
<span class="line-modified"> 967        GTraverseFlags flags,</span>
<span class="line-modified"> 968        guint   *n)</span>
 969 {
 970   if (node-&gt;children)
 971     {
 972       GNode *child;
 973 
 974       if (flags &amp; G_TRAVERSE_NON_LEAFS)
<span class="line-modified"> 975   (*n)++;</span>
 976 
 977       child = node-&gt;children;
 978       while (child)
<span class="line-modified"> 979   {</span>
<span class="line-modified"> 980     g_node_count_func (child, flags, n);</span>
<span class="line-modified"> 981     child = child-&gt;next;</span>
<span class="line-modified"> 982   }</span>
 983     }
 984   else if (flags &amp; G_TRAVERSE_LEAFS)
 985     (*n)++;
 986 }
 987 
 988 /**
 989  * g_node_n_nodes:
 990  * @root: a #GNode
 991  * @flags: which types of children are to be counted, one of
 992  *     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
 993  *
 994  * Gets the number of nodes in a tree.
 995  *
 996  * Returns: the number of nodes in the tree
 997  */
 998 guint
<span class="line-modified"> 999 g_node_n_nodes (GNode        *root,</span>
<span class="line-modified">1000     GTraverseFlags  flags)</span>
1001 {
1002   guint n = 0;
1003 
1004   g_return_val_if_fail (root != NULL, 0);
1005   g_return_val_if_fail (flags &lt;= G_TRAVERSE_MASK, 0);
1006 
1007   g_node_count_func (root, flags, &amp;n);
1008 
1009   return n;
1010 }
1011 
1012 /**
1013  * g_node_last_child:
1014  * @node: a #GNode (must not be %NULL)
1015  *
1016  * Gets the last child of a #GNode.
1017  *
1018  * Returns: the last child of @node, or %NULL if @node has no children
1019  */
1020 GNode*
</pre>
<hr />
<pre>
1026   if (node)
1027     while (node-&gt;next)
1028       node = node-&gt;next;
1029 
1030   return node;
1031 }
1032 
1033 /**
1034  * g_node_nth_child:
1035  * @node: a #GNode
1036  * @n: the index of the desired child
1037  *
1038  * Gets a child of a #GNode, using the given index.
1039  * The first child is at index 0. If the index is
1040  * too big, %NULL is returned.
1041  *
1042  * Returns: the child of @node at index @n
1043  */
1044 GNode*
1045 g_node_nth_child (GNode *node,
<span class="line-modified">1046       guint  n)</span>
1047 {
1048   g_return_val_if_fail (node != NULL, NULL);
1049 
1050   node = node-&gt;children;
1051   if (node)
1052     while ((n-- &gt; 0) &amp;&amp; node)
1053       node = node-&gt;next;
1054 
1055   return node;
1056 }
1057 
1058 /**
1059  * g_node_n_children:
1060  * @node: a #GNode
1061  *
1062  * Gets the number of children of a #GNode.
1063  *
1064  * Returns: the number of children of @node
1065  */
1066 guint
</pre>
<hr />
<pre>
1075     {
1076       n++;
1077       node = node-&gt;next;
1078     }
1079 
1080   return n;
1081 }
1082 
1083 /**
1084  * g_node_find_child:
1085  * @node: a #GNode
1086  * @flags: which types of children are to be searched, one of
1087  *     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
1088  * @data: the data to find
1089  *
1090  * Finds the first child of a #GNode with the given data.
1091  *
1092  * Returns: the found child #GNode, or %NULL if the data is not found
1093  */
1094 GNode*
<span class="line-modified">1095 g_node_find_child (GNode    *node,</span>
<span class="line-modified">1096        GTraverseFlags  flags,</span>
<span class="line-modified">1097        gpointer    data)</span>
1098 {
1099   g_return_val_if_fail (node != NULL, NULL);
1100   g_return_val_if_fail (flags &lt;= G_TRAVERSE_MASK, NULL);
1101 
1102   node = node-&gt;children;
1103   while (node)
1104     {
1105       if (node-&gt;data == data)
<span class="line-modified">1106   {</span>
<span class="line-modified">1107     if (G_NODE_IS_LEAF (node))</span>
<span class="line-modified">1108       {</span>
<span class="line-modified">1109         if (flags &amp; G_TRAVERSE_LEAFS)</span>
<span class="line-modified">1110     return node;</span>
<span class="line-modified">1111       }</span>
<span class="line-modified">1112     else</span>
<span class="line-modified">1113       {</span>
<span class="line-modified">1114         if (flags &amp; G_TRAVERSE_NON_LEAFS)</span>
<span class="line-modified">1115     return node;</span>
<span class="line-modified">1116       }</span>
<span class="line-modified">1117   }</span>
1118       node = node-&gt;next;
1119     }
1120 
1121   return NULL;
1122 }
1123 
1124 /**
1125  * g_node_child_position:
1126  * @node: a #GNode
1127  * @child: a child of @node
1128  *
1129  * Gets the position of a #GNode with respect to its siblings.
1130  * @child must be a child of @node. The first child is numbered 0,
1131  * the second 1, and so on.
1132  *
1133  * Returns: the position of @child with respect to its siblings
1134  */
1135 gint
1136 g_node_child_position (GNode *node,
<span class="line-modified">1137            GNode *child)</span>
1138 {
1139   guint n = 0;
1140 
1141   g_return_val_if_fail (node != NULL, -1);
1142   g_return_val_if_fail (child != NULL, -1);
1143   g_return_val_if_fail (child-&gt;parent == node, -1);
1144 
1145   node = node-&gt;children;
1146   while (node)
1147     {
1148       if (node == child)
<span class="line-modified">1149   return n;</span>
1150       n++;
1151       node = node-&gt;next;
1152     }
1153 
1154   return -1;
1155 }
1156 
1157 /**
1158  * g_node_child_index:
1159  * @node: a #GNode
1160  * @data: the data to find
1161  *
1162  * Gets the position of the first child of a #GNode
1163  * which contains the given data.
1164  *
1165  * Returns: the index of the child of @node which contains
1166  *     @data, or -1 if the data is not found
1167  */
1168 gint
1169 g_node_child_index (GNode    *node,
<span class="line-modified">1170         gpointer  data)</span>
1171 {
1172   guint n = 0;
1173 
1174   g_return_val_if_fail (node != NULL, -1);
1175 
1176   node = node-&gt;children;
1177   while (node)
1178     {
1179       if (node-&gt;data == data)
<span class="line-modified">1180   return n;</span>
1181       n++;
1182       node = node-&gt;next;
1183     }
1184 
1185   return -1;
1186 }
1187 
1188 /**
1189  * g_node_first_sibling:
1190  * @node: a #GNode
1191  *
1192  * Gets the first sibling of a #GNode.
1193  * This could possibly be the node itself.
1194  *
1195  * Returns: the first sibling of @node
1196  */
1197 GNode*
1198 g_node_first_sibling (GNode *node)
1199 {
1200   g_return_val_if_fail (node != NULL, NULL);
</pre>
<hr />
<pre>
1233  * @node: a #GNode
1234  * @flags: which types of children are to be visited, one of
1235  *     %G_TRAVERSE_ALL, %G_TRAVERSE_LEAVES and %G_TRAVERSE_NON_LEAVES
1236  * @func: the function to call for each visited node
1237  * @data: user data to pass to the function
1238  *
1239  * Calls a function for each of the children of a #GNode. Note that it
1240  * doesn&#39;t descend beneath the child nodes. @func must not do anything
1241  * that would modify the structure of the tree.
1242  */
1243 /**
1244  * GNodeForeachFunc:
1245  * @node: a #GNode.
1246  * @data: user data passed to g_node_children_foreach().
1247  *
1248  * Specifies the type of function passed to g_node_children_foreach().
1249  * The function is called with each child node, together with the user
1250  * data passed to g_node_children_foreach().
1251  **/
1252 void
<span class="line-modified">1253 g_node_children_foreach (GNode      *node,</span>
<span class="line-modified">1254        GTraverseFlags    flags,</span>
<span class="line-modified">1255        GNodeForeachFunc  func,</span>
<span class="line-modified">1256        gpointer    data)</span>
1257 {
1258   g_return_if_fail (node != NULL);
1259   g_return_if_fail (flags &lt;= G_TRAVERSE_MASK);
1260   g_return_if_fail (func != NULL);
1261 
1262   node = node-&gt;children;
1263   while (node)
1264     {
1265       GNode *current;
1266 
1267       current = node;
1268       node = current-&gt;next;
1269       if (G_NODE_IS_LEAF (current))
<span class="line-modified">1270   {</span>
<span class="line-modified">1271     if (flags &amp; G_TRAVERSE_LEAFS)</span>
<span class="line-modified">1272       func (current, data);</span>
<span class="line-modified">1273   }</span>
1274       else
<span class="line-modified">1275   {</span>
<span class="line-modified">1276     if (flags &amp; G_TRAVERSE_NON_LEAFS)</span>
<span class="line-modified">1277       func (current, data);</span>
<span class="line-modified">1278   }</span>
1279     }
1280 }
</pre>
</td>
</tr>
</table>
<center><a href="gmirroringtable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gnode.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>