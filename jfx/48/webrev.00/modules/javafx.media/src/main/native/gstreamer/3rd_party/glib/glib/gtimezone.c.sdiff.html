<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gtimezone.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gtimer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gtimezone.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gtimezone.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright � 2010 Codethink Limited</span>
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  *
  17  * Author: Ryan Lortie &lt;desrt@desrt.ca&gt;
  18  */
  19 
  20 /* Prologue {{{1 */
  21 
  22 #include &quot;config.h&quot;
  23 
  24 #include &quot;gtimezone.h&quot;
  25 
  26 #include &lt;string.h&gt;
  27 #include &lt;stdlib.h&gt;
  28 #include &lt;signal.h&gt;
  29 
  30 #include &quot;gmappedfile.h&quot;
  31 #include &quot;gtestutils.h&quot;
  32 #include &quot;gfileutils.h&quot;
  33 #include &quot;gstrfuncs.h&quot;
  34 #include &quot;ghash.h&quot;
  35 #include &quot;gthread.h&quot;
  36 #include &quot;gbytes.h&quot;
  37 #include &quot;gslice.h&quot;
  38 #include &quot;gdatetime.h&quot;
  39 #include &quot;gdate.h&quot;
  40 
  41 #ifdef G_OS_WIN32

  42 #define STRICT
  43 #include &lt;windows.h&gt;

  44 #endif
  45 
  46 /**
  47  * SECTION:timezone
  48  * @title: GTimeZone
  49  * @short_description: a structure representing a time zone
  50  * @see_also: #GDateTime
  51  *
  52  * #GTimeZone is a structure that represents a time zone, at no
  53  * particular point in time.  It is refcounted and immutable.
  54  *
<span class="line-modified">  55  * Each time zone has an identifier (for example, �Europe/London�) which is</span>
  56  * platform dependent. See g_time_zone_new() for information on the identifier
  57  * formats. The identifier of a time zone can be retrieved using
  58  * g_time_zone_get_identifier().
  59  *
  60  * A time zone contains a number of intervals.  Each interval has
<span class="line-modified">  61  * an abbreviation to describe it (for example, �PDT�), an offet to UTC and a</span>
  62  * flag indicating if the daylight savings time is in effect during that
<span class="line-modified">  63  * interval.  A time zone always has at least one interval � interval 0. Note</span>
  64  * that interval abbreviations are not the same as time zone identifiers
<span class="line-modified">  65  * (apart from �UTC�), and cannot be passed to g_time_zone_new().</span>
  66  *
  67  * Every UTC time is contained within exactly one interval, but a given
  68  * local time may be contained within zero, one or two intervals (due to
  69  * incontinuities associated with daylight savings time).
  70  *
  71  * An interval may refer to a specific period of time (eg: the duration
  72  * of daylight savings time during 2010) or it may refer to many periods
  73  * of time that share the same properties (eg: all periods of daylight
  74  * savings time).  It is also possible (usually for political reasons)
  75  * that some properties (like the abbreviation) change between intervals
  76  * without other properties changing.
  77  *
  78  * #GTimeZone is available since GLib 2.26.
  79  */
  80 
  81 /**
  82  * GTimeZone:
  83  *
  84  * #GTimeZone is an opaque structure whose members cannot be accessed
  85  * directly.
</pre>
<hr />
<pre>
 220 
 221   if (ref_count == 1)
 222     {
 223       if (tz-&gt;name != NULL)
 224         {
 225           G_LOCK(time_zones);
 226 
 227           /* someone else might have grabbed a ref in the meantime */
 228           if G_UNLIKELY (g_atomic_int_get (&amp;tz-&gt;ref_count) != 1)
 229             {
 230               G_UNLOCK(time_zones);
 231               goto again;
 232             }
 233 
 234           g_hash_table_remove (time_zones, tz-&gt;name);
 235           G_UNLOCK(time_zones);
 236         }
 237 
 238       if (tz-&gt;t_info != NULL)
 239         {
<span class="line-modified"> 240           gint idx;</span>
 241           for (idx = 0; idx &lt; tz-&gt;t_info-&gt;len; idx++)
 242             {
 243               TransitionInfo *info = &amp;g_array_index (tz-&gt;t_info, TransitionInfo, idx);
 244               g_free (info-&gt;abbrev);
 245             }
 246           g_array_free (tz-&gt;t_info, TRUE);
 247         }
 248       if (tz-&gt;transitions != NULL)
 249         g_array_free (tz-&gt;transitions, TRUE);
 250       g_free (tz-&gt;name);
 251 
 252       g_slice_free (GTimeZone, tz);
 253     }
 254 
 255   else if G_UNLIKELY (!g_atomic_int_compare_and_exchange (&amp;tz-&gt;ref_count,
 256                                                           ref_count,
 257                                                           ref_count - 1))
 258     goto again;
 259 }
 260 
</pre>
<hr />
<pre>
 355     }
 356 
 357   if (*name &gt;= &#39;0&#39; &amp;&amp; &#39;9&#39; &gt;= *name)
 358     return parse_time (name, offset);
 359 
 360   switch (*name++)
 361     {
 362     case &#39;Z&#39;:
 363       *offset = 0;
 364       return !*name;
 365 
 366     case &#39;+&#39;:
 367       return parse_time (name, offset);
 368 
 369     case &#39;-&#39;:
 370       if (parse_time (name, offset))
 371         {
 372           *offset = -*offset;
 373           return TRUE;
 374         }


 375 
 376     default:
 377       return FALSE;
 378     }
 379 }
 380 
 381 static void
 382 zone_for_constant_offset (GTimeZone *gtz, const gchar *name)
 383 {
 384   gint32 offset;
 385   TransitionInfo info;
 386 
 387   if (name == NULL || !parse_constant_offset (name, &amp;offset))
 388     return;
 389 
 390   info.gmt_offset = offset;
 391   info.is_dst = FALSE;
 392   info.abbrev =  g_strdup (name);
 393 
 394   gtz-&gt;name = g_strdup (name);
</pre>
<hr />
<pre>
 419      while the POSIX standard says it should start with :,
 420      glibc allows both syntaxes, so we should too */
 421   if (identifier != NULL)
 422     {
 423       resolved_identifier = g_strdup (identifier);
 424 
 425       if (*identifier == &#39;:&#39;)
 426         identifier ++;
 427 
 428       if (g_path_is_absolute (identifier))
 429         filename = g_strdup (identifier);
 430       else
 431         filename = g_build_filename (tzdir, identifier, NULL);
 432     }
 433   else
 434     {
 435       gsize prefix_len = 0;
 436       gchar *canonical_path = NULL;
 437       GError *read_link_err = NULL;
 438 
<span class="line-modified"> 439     filename = g_strdup (&quot;/etc/localtime&quot;);</span>
 440 
 441       /* Resolve the actual timezone pointed to by /etc/localtime. */
 442       resolved_identifier = g_file_read_link (filename, &amp;read_link_err);
 443       if (resolved_identifier == NULL)
 444         {
 445           gboolean not_a_symlink = g_error_matches (read_link_err,
 446                                                     G_FILE_ERROR,
 447                                                     G_FILE_ERROR_INVAL);
 448           g_clear_error (&amp;read_link_err);
 449 
 450           /* Fallback to the content of /var/db/zoneinfo or /etc/timezone
 451            * if /etc/localtime is not a symlink. /var/db/zoneinfo is
 452            * where &#39;tzsetup&#39; program on FreeBSD and DragonflyBSD stores
 453            * the timezone chosen by the user. /etc/timezone is where user
 454            * choice is expressed on Gentoo OpenRC and others. */
 455           if (not_a_symlink &amp;&amp; (g_file_get_contents (&quot;/var/db/zoneinfo&quot;,
 456                                                      &amp;resolved_identifier,
 457                                                      NULL, NULL) ||
 458                                 g_file_get_contents (&quot;/etc/timezone&quot;,
 459                                                      &amp;resolved_identifier,
</pre>
<hr />
<pre>
 556 
 557   for (index = 0; index &lt; type_count; index++)
 558     {
 559       TransitionInfo t_info;
 560       struct ttinfo info = ((struct ttinfo*)tz_ttinfo)[index];
 561       t_info.gmt_offset = gint32_from_be (info.tt_gmtoff);
 562       t_info.is_dst = info.tt_isdst ? TRUE : FALSE;
 563       t_info.abbrev = g_strdup ((gchar *) &amp;tz_abbrs[info.tt_abbrind]);
 564       g_array_append_val (gtz-&gt;t_info, t_info);
 565     }
 566 
 567   for (index = 0; index &lt; time_count; index++)
 568     {
 569       Transition trans;
 570       if (header-&gt;tzh_version == &#39;2&#39;)
 571         trans.time = gint64_from_be (((gint64_be*)tz_transitions)[index]);
 572       else
 573         trans.time = gint32_from_be (((gint32_be*)tz_transitions)[index]);
 574       trans.info_index = tz_type_index[index];
 575       g_assert (trans.info_index &gt;= 0);
<span class="line-modified"> 576       g_assert (trans.info_index &lt; gtz-&gt;t_info-&gt;len);</span>
 577       g_array_append_val (gtz-&gt;transitions, trans);
 578     }
 579 }
 580 
 581 #elif defined (G_OS_WIN32)
 582 
 583 static void
 584 copy_windows_systemtime (SYSTEMTIME *s_time, TimeZoneDate *tzdate)
 585 {
 586   tzdate-&gt;sec = s_time-&gt;wSecond;
 587   tzdate-&gt;min = s_time-&gt;wMinute;
 588   tzdate-&gt;hour = s_time-&gt;wHour;
 589   tzdate-&gt;mon = s_time-&gt;wMonth;
 590   tzdate-&gt;year = s_time-&gt;wYear;
 591   tzdate-&gt;wday = s_time-&gt;wDayOfWeek ? s_time-&gt;wDayOfWeek : 7;
 592 
 593   if (s_time-&gt;wYear)
 594     {
 595       tzdate-&gt;mday = s_time-&gt;wDay;
 596       tzdate-&gt;wday = 0;
 597     }
 598   else
 599     tzdate-&gt;week = s_time-&gt;wDay;
 600 }
 601 
 602 /* UTC = local time + bias while local time = UTC + offset */
<span class="line-modified"> 603 static void</span>
 604 rule_from_windows_time_zone_info (TimeZoneRule *rule,
 605                                   TIME_ZONE_INFORMATION *tzi)
 606 {













 607   /* Set offset */
 608   if (tzi-&gt;StandardDate.wMonth)
 609     {
 610       rule-&gt;std_offset = -(tzi-&gt;Bias + tzi-&gt;StandardBias) * 60;
 611       rule-&gt;dlt_offset = -(tzi-&gt;Bias + tzi-&gt;DaylightBias) * 60;
 612       copy_windows_systemtime (&amp;(tzi-&gt;DaylightDate), &amp;(rule-&gt;dlt_start));
 613 
 614       copy_windows_systemtime (&amp;(tzi-&gt;StandardDate), &amp;(rule-&gt;dlt_end));
<span class="line-removed"> 615 </span>
 616     }
 617 
 618   else
 619     {
 620       rule-&gt;std_offset = -tzi-&gt;Bias * 60;
 621       rule-&gt;dlt_start.mon = 0;
 622     }
<span class="line-modified"> 623   strncpy (rule-&gt;std_name, (gchar*)tzi-&gt;StandardName, NAME_SIZE - 1);</span>
<span class="line-modified"> 624   strncpy (rule-&gt;dlt_name, (gchar*)tzi-&gt;DaylightName, NAME_SIZE - 1);</span>





 625 }
 626 
 627 static gchar*
 628 windows_default_tzname (void)
 629 {
<span class="line-modified"> 630   const gchar *subkey =</span>
<span class="line-modified"> 631     &quot;SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation&quot;;</span>
 632   HKEY key;
 633   gchar *key_name = NULL;
<span class="line-modified"> 634   if (RegOpenKeyExA (HKEY_LOCAL_MACHINE, subkey, 0,</span>

 635                      KEY_QUERY_VALUE, &amp;key) == ERROR_SUCCESS)
 636     {
 637       DWORD size = 0;
<span class="line-modified"> 638       if (RegQueryValueExA (key, &quot;TimeZoneKeyName&quot;, NULL, NULL,</span>
 639                             NULL, &amp;size) == ERROR_SUCCESS)
 640         {
<span class="line-modified"> 641           key_name = g_malloc ((gint)size);</span>
<span class="line-modified"> 642           if (RegQueryValueExA (key, &quot;TimeZoneKeyName&quot;, NULL, NULL,</span>
<span class="line-modified"> 643                                 (LPBYTE)key_name, &amp;size) != ERROR_SUCCESS)</span>


 644             {
<span class="line-modified"> 645               g_free (key_name);</span>
 646               key_name = NULL;
 647             }


 648         }
 649       RegCloseKey (key);
 650     }
 651   return key_name;
 652 }
 653 
 654 typedef   struct
 655 {
 656   LONG Bias;
 657   LONG StandardBias;
 658   LONG DaylightBias;
 659   SYSTEMTIME StandardDate;
 660   SYSTEMTIME DaylightDate;
 661 } RegTZI;
 662 
 663 static void
 664 system_time_copy (SYSTEMTIME *orig, SYSTEMTIME *target)
 665 {
 666   g_return_if_fail (orig != NULL);
 667   g_return_if_fail (target != NULL);
</pre>
<hr />
<pre>
 671   target-&gt;wDayOfWeek = orig-&gt;wDayOfWeek;
 672   target-&gt;wDay = orig-&gt;wDay;
 673   target-&gt;wHour = orig-&gt;wHour;
 674   target-&gt;wMinute = orig-&gt;wMinute;
 675   target-&gt;wSecond = orig-&gt;wSecond;
 676   target-&gt;wMilliseconds = orig-&gt;wMilliseconds;
 677 }
 678 
 679 static void
 680 register_tzi_to_tzi (RegTZI *reg, TIME_ZONE_INFORMATION *tzi)
 681 {
 682   g_return_if_fail (reg != NULL);
 683   g_return_if_fail (tzi != NULL);
 684   tzi-&gt;Bias = reg-&gt;Bias;
 685   system_time_copy (&amp;(reg-&gt;StandardDate), &amp;(tzi-&gt;StandardDate));
 686   tzi-&gt;StandardBias = reg-&gt;StandardBias;
 687   system_time_copy (&amp;(reg-&gt;DaylightDate), &amp;(tzi-&gt;DaylightDate));
 688   tzi-&gt;DaylightBias = reg-&gt;DaylightBias;
 689 }
 690 
<span class="line-modified"> 691 static gint</span>
 692 rules_from_windows_time_zone (const gchar   *identifier,
 693                               gchar        **out_identifier,
<span class="line-modified"> 694                               TimeZoneRule **rules)</span>

 695 {
 696   HKEY key;
<span class="line-modified"> 697   gchar *subkey, *subkey_dynamic;</span>

 698   gchar *key_name = NULL;
 699   const gchar *reg_key =
 700     &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones\\&quot;;
 701   TIME_ZONE_INFORMATION tzi;
 702   DWORD size;
<span class="line-modified"> 703   gint rules_num = 0;</span>
 704   RegTZI regtzi, regtzi_prev;


 705 
<span class="line-modified"> 706   g_assert (out_identifier != NULL);</span>



 707   g_assert (rules != NULL);
 708 
<span class="line-modified"> 709   *out_identifier = NULL;</span>


 710   *rules = NULL;
 711   key_name = NULL;
 712 
 713   if (!identifier)
 714     key_name = windows_default_tzname ();
 715   else
 716     key_name = g_strdup (identifier);
 717 
 718   if (!key_name)
 719     return 0;
 720 
 721   subkey = g_strconcat (reg_key, key_name, NULL);




 722   subkey_dynamic = g_strconcat (subkey, &quot;\\Dynamic DST&quot;, NULL);



 723 
<span class="line-modified"> 724   if (RegOpenKeyExA (HKEY_LOCAL_MACHINE, subkey, 0,</span>
 725                      KEY_QUERY_VALUE, &amp;key) != ERROR_SUCCESS)
<span class="line-modified"> 726       return 0;</span>

 727   size = sizeof tzi.StandardName;
<span class="line-modified"> 728   if (RegQueryValueExA (key, &quot;Std&quot;, NULL, NULL,</span>
<span class="line-modified"> 729                         (LPBYTE)&amp;(tzi.StandardName), &amp;size) != ERROR_SUCCESS)</span>
<span class="line-modified"> 730     goto failed;</span>








 731 
 732   size = sizeof tzi.DaylightName;
 733 
<span class="line-modified"> 734   if (RegQueryValueExA (key, &quot;Dlt&quot;, NULL, NULL,</span>
<span class="line-modified"> 735                         (LPBYTE)&amp;(tzi.DaylightName), &amp;size) != ERROR_SUCCESS)</span>
<span class="line-modified"> 736     goto failed;</span>







 737 
 738   RegCloseKey (key);
<span class="line-modified"> 739   if (RegOpenKeyExA (HKEY_LOCAL_MACHINE, subkey_dynamic, 0,</span>
 740                      KEY_QUERY_VALUE, &amp;key) == ERROR_SUCCESS)
 741     {
 742       DWORD first, last;
 743       int year, i;
<span class="line-modified"> 744       gchar *s;</span>
 745 
 746       size = sizeof first;
<span class="line-modified"> 747       if (RegQueryValueExA (key, &quot;FirstEntry&quot;, NULL, NULL,</span>
 748                             (LPBYTE) &amp;first, &amp;size) != ERROR_SUCCESS)
<span class="line-modified"> 749         goto failed;</span>
 750 
 751       size = sizeof last;
<span class="line-modified"> 752       if (RegQueryValueExA (key, &quot;LastEntry&quot;, NULL, NULL,</span>
 753                             (LPBYTE) &amp;last, &amp;size) != ERROR_SUCCESS)
<span class="line-modified"> 754         goto failed;</span>
 755 
 756       rules_num = last - first + 2;
 757       *rules = g_new0 (TimeZoneRule, rules_num);
 758 
<span class="line-modified"> 759       for (year = first, i = 0; year &lt;= last; year++)</span>
 760         {
<span class="line-modified"> 761           s = g_strdup_printf (&quot;%d&quot;, year);</span>









 762 
<span class="line-modified"> 763           size = sizeof regtzi;</span>
<span class="line-removed"> 764           if (RegQueryValueExA (key, s, NULL, NULL,</span>
<span class="line-removed"> 765                             (LPBYTE) &amp;regtzi, &amp;size) != ERROR_SUCCESS)</span>
 766             {
 767               g_free (*rules);
 768               *rules = NULL;
 769               break;
 770             }
 771 
<span class="line-removed"> 772           g_free (s);</span>
<span class="line-removed"> 773 </span>
 774           if (year &gt; first &amp;&amp; memcmp (&amp;regtzi_prev, &amp;regtzi, sizeof regtzi) == 0)
 775               continue;
 776           else
 777             memcpy (&amp;regtzi_prev, &amp;regtzi, sizeof regtzi);
 778 
 779           register_tzi_to_tzi (&amp;regtzi, &amp;tzi);
<span class="line-modified"> 780           rule_from_windows_time_zone_info (&amp;(*rules)[i], &amp;tzi);</span>







 781           (*rules)[i++].start_year = year;
 782         }
 783 
 784       rules_num = i + 1;
 785 
<span class="line-modified"> 786 failed:</span>
 787       RegCloseKey (key);
 788     }
<span class="line-modified"> 789   else if (RegOpenKeyExA (HKEY_LOCAL_MACHINE, subkey, 0,</span>
 790                           KEY_QUERY_VALUE, &amp;key) == ERROR_SUCCESS)
 791     {
 792       size = sizeof regtzi;
<span class="line-modified"> 793       if (RegQueryValueExA (key, &quot;TZI&quot;, NULL, NULL,</span>
 794                             (LPBYTE) &amp;regtzi, &amp;size) == ERROR_SUCCESS)
 795         {
 796           rules_num = 2;
 797           *rules = g_new0 (TimeZoneRule, 2);
 798           register_tzi_to_tzi (&amp;regtzi, &amp;tzi);
<span class="line-modified"> 799           rule_from_windows_time_zone_info (&amp;(*rules)[0], &amp;tzi);</span>





 800         }
 801 
 802       RegCloseKey (key);
 803     }
 804 


 805   g_free (subkey_dynamic);

 806   g_free (subkey);
 807 
 808   if (*rules)
 809     {
 810       (*rules)[0].start_year = MIN_TZYEAR;
 811       if ((*rules)[rules_num - 2].start_year &lt; MAX_TZYEAR)
 812         (*rules)[rules_num - 1].start_year = MAX_TZYEAR;
 813       else
 814         (*rules)[rules_num - 1].start_year = (*rules)[rules_num - 2].start_year + 1;
 815 
<span class="line-modified"> 816       *out_identifier = g_steal_pointer (&amp;key_name);</span>



 817 
 818       return rules_num;
 819     }
 820 
 821   g_free (key_name);
 822 
<span class="line-modified"> 823     return 0;</span>
 824 }
 825 
 826 #endif
 827 
 828 static void
 829 find_relative_date (TimeZoneDate *buffer)
 830 {
<span class="line-modified"> 831   gint wday;</span>
 832   GDate date;
 833   g_date_clear (&amp;date, 1);
 834   wday = buffer-&gt;wday;
 835 
 836   /* Get last day if last is needed, first day otherwise */
 837   if (buffer-&gt;mon == 13 || buffer-&gt;mon == 14) /* Julian Date */
 838     {
 839       g_date_set_dmy (&amp;date, 1, 1, buffer-&gt;year);
 840       if (wday &gt;= 59 &amp;&amp; buffer-&gt;mon == 13 &amp;&amp; g_date_is_leap_year (buffer-&gt;year))
 841         g_date_add_days (&amp;date, wday);
 842       else
 843         g_date_add_days (&amp;date, wday - 1);
 844       buffer-&gt;mon = (int) g_date_get_month (&amp;date);
 845       buffer-&gt;mday = (int) g_date_get_day (&amp;date);
 846       buffer-&gt;wday = 0;
 847     }
 848   else /* M.W.D */
 849     {
 850       guint days;
 851 #ifdef GSTREAMER_LITE
</pre>
<hr />
<pre>
 908                                 gboolean        is_dst)
 909 {
 910   gint offset = is_dst ? rule-&gt;dlt_offset : rule-&gt;std_offset;
 911   gchar *name = is_dst ? rule-&gt;dlt_name : rule-&gt;std_name;
 912 
 913   info-&gt;gmt_offset = offset;
 914   info-&gt;is_dst = is_dst;
 915 
 916   if (name)
 917     info-&gt;abbrev = g_strdup (name);
 918 
 919   else
 920     info-&gt;abbrev = g_strdup_printf (&quot;%+03d%02d&quot;,
 921                                       (int) offset / 3600,
 922                                       (int) abs (offset / 60) % 60);
 923 }
 924 
 925 static void
 926 init_zone_from_rules (GTimeZone    *gtz,
 927                       TimeZoneRule *rules,
<span class="line-modified"> 928                       gint          rules_num,</span>
 929                       gchar        *identifier  /* (transfer full) */)
 930 {
 931   guint type_count = 0, trans_count = 0, info_index = 0;
 932   guint ri; /* rule index */
 933   gboolean skip_first_std_trans = TRUE;
 934   gint32 last_offset;
 935 
 936   type_count = 0;
 937   trans_count = 0;
 938 
 939   /* Last rule only contains max year */
 940   for (ri = 0; ri &lt; rules_num - 1; ri++)
 941     {
 942       if (rules[ri].dlt_start.mon || rules[ri].dlt_end.mon)
 943         {
 944           guint rulespan = (rules[ri + 1].start_year - rules[ri].start_year);
 945           guint transitions = rules[ri].dlt_start.mon &gt; 0 ? 1 : 0;
 946           transitions += rules[ri].dlt_end.mon &gt; 0 ? 1 : 0;
 947           type_count += rules[ri].dlt_start.mon &gt; 0 ? 2 : 1;
 948           trans_count += transitions * rulespan;
</pre>
<hr />
<pre>
1199       if (!parse_time (++pos, &amp;offset))
1200         return FALSE;
1201 
1202       boundary-&gt;hour = offset / 3600;
1203       boundary-&gt;min = (offset / 60) % 60;
1204       boundary-&gt;sec = offset % 3600;
1205 
1206       return TRUE;
1207     }
1208 
1209   else
1210     {
1211       boundary-&gt;hour = 2;
1212       boundary-&gt;min = 0;
1213       boundary-&gt;sec = 0;
1214 
1215       return *pos == &#39;\0&#39;;
1216     }
1217 }
1218 
<span class="line-modified">1219 static gint</span>
1220 create_ruleset_from_rule (TimeZoneRule **rules, TimeZoneRule *rule)
1221 {
1222   *rules = g_new0 (TimeZoneRule, 2);
1223 
1224   (*rules)[0].start_year = MIN_TZYEAR;
1225   (*rules)[1].start_year = MAX_TZYEAR;
1226 
1227   (*rules)[0].std_offset = -rule-&gt;std_offset;
1228   (*rules)[0].dlt_offset = -rule-&gt;dlt_offset;
1229   (*rules)[0].dlt_start  = rule-&gt;dlt_start;
1230   (*rules)[0].dlt_end = rule-&gt;dlt_end;
1231   strcpy ((*rules)[0].std_name, rule-&gt;std_name);
1232   strcpy ((*rules)[0].dlt_name, rule-&gt;dlt_name);
1233   return 2;
1234 }
1235 
1236 static gboolean
1237 parse_offset (gchar **pos, gint32 *target)
1238 {
1239   gchar *buffer;
</pre>
<hr />
<pre>
1291 static gboolean
1292 parse_identifier_boundaries (gchar **pos, TimeZoneRule *tzr)
1293 {
1294   if (*(*pos)++ != &#39;,&#39;)
1295     return FALSE;
1296 
1297   /* Start date */
1298   if (!parse_identifier_boundary (pos, &amp;(tzr-&gt;dlt_start)) || *(*pos)++ != &#39;,&#39;)
1299     return FALSE;
1300 
1301   /* End date */
1302   if (!parse_identifier_boundary (pos, &amp;(tzr-&gt;dlt_end)))
1303     return FALSE;
1304   return TRUE;
1305 }
1306 
1307 /*
1308  * Creates an array of TimeZoneRule from a TZ environment variable
1309  * type of identifier.  Should free rules afterwards
1310  */
<span class="line-modified">1311 static gint</span>
1312 rules_from_identifier (const gchar   *identifier,
1313                        gchar        **out_identifier,
1314                        TimeZoneRule **rules)
1315 {
1316   gchar *pos;
1317   TimeZoneRule tzr;
1318 
1319   g_assert (out_identifier != NULL);
1320   g_assert (rules != NULL);
1321 
1322   *out_identifier = NULL;
1323   *rules = NULL;
1324 
1325   if (!identifier)
1326     return 0;
1327 
1328   pos = (gchar*)identifier;
1329   memset (&amp;tzr, 0, sizeof (tzr));
1330   /* Standard offset */
1331   if (!(set_tz_name (&amp;pos, tzr.std_name, NAME_SIZE)) ||
</pre>
<hr />
<pre>
1337       *out_identifier = g_strdup (identifier);
1338       return create_ruleset_from_rule (rules, &amp;tzr);
1339     }
1340 
1341   /* Format 2 */
1342   if (!(set_tz_name (&amp;pos, tzr.dlt_name, NAME_SIZE)))
1343     return 0;
1344   parse_offset (&amp;pos, &amp;(tzr.dlt_offset));
1345   if (tzr.dlt_offset == 0) /* No daylight offset given, assume it&#39;s 1
1346                               hour earlier that standard */
1347     tzr.dlt_offset = tzr.std_offset - 3600;
1348   if (*pos == &#39;\0&#39;)
1349 #ifdef G_OS_WIN32
1350     /* Windows allows us to use the US DST boundaries if they&#39;re not given */
1351     {
1352       int i;
1353       guint rules_num = 0;
1354 
1355       /* Use US rules, Windows&#39; default is Pacific Standard Time */
1356       if ((rules_num = rules_from_windows_time_zone (&quot;Pacific Standard Time&quot;,
<span class="line-modified">1357                                                      out_identifier,</span>
<span class="line-modified">1358                                                      rules)))</span>

1359         {





1360           for (i = 0; i &lt; rules_num - 1; i++)
1361             {
1362               (*rules)[i].std_offset = - tzr.std_offset;
1363               (*rules)[i].dlt_offset = - tzr.dlt_offset;
1364               strcpy ((*rules)[i].std_name, tzr.std_name);
1365               strcpy ((*rules)[i].dlt_name, tzr.dlt_name);
1366             }
1367 
1368           return rules_num;
1369         }
1370       else
1371         return 0;
1372     }
1373 #else
1374   return 0;
1375 #endif
1376   /* Start and end required (format 2) */
1377   if (!parse_identifier_boundaries (&amp;pos, &amp;tzr))
1378     return 0;
1379 
</pre>
<hr />
<pre>
1420  * accepts POSIX format.  The Windows format uses US rules for all time
1421  * zones; daylight savings time is 60 minutes behind the standard time
1422  * with date and time of change taken from Pacific Standard Time.
1423  * Offsets are time values to be added to the local time to get
1424  * Coordinated Universal Time (UTC).
1425  *
1426  * g_time_zone_new_local() calls this function with the value of the
1427  * &#39;TZ&#39; environment variable. This function itself is independent of
1428  * the value of &#39;TZ&#39;, but if @identifier is %NULL then &#39;/etc/localtime&#39;
1429  * will be consulted to discover the correct time zone on UNIX and the
1430  * registry will be consulted or GetTimeZoneInformation() will be used
1431  * to get the local time zone on Windows.
1432  *
1433  * If intervals are not available, only time zone rules from `TZ`
1434  * environment variable or other means, then they will be computed
1435  * from year 1900 to 2037.  If the maximum year for the rules is
1436  * available and it is greater than 2037, then it will followed
1437  * instead.
1438  *
1439  * See
<span class="line-modified">1440  * [RFC3339 �5.6](http://tools.ietf.org/html/rfc3339#section-5.6)</span>
1441  * for a precise definition of valid RFC3339 time offsets
1442  * (the `time-offset` expansion) and ISO 8601 for the
1443  * full list of valid time offsets.  See
1444  * [The GNU C Library manual](http://www.gnu.org/s/libc/manual/html_node/TZ-Variable.html)
1445  * for an explanation of the possible
1446  * values of the `TZ` environment variable. See
1447  * [Microsoft Time Zone Index Values](http://msdn.microsoft.com/en-us/library/ms912391%28v=winembedded.11%29.aspx)
1448  * for the list of time zones on Windows.
1449  *
1450  * You should release the return value by calling g_time_zone_unref()
1451  * when you are done with it.
1452  *
1453  * Returns: the requested timezone
1454  *
1455  * Since: 2.26
1456  **/
1457 GTimeZone *
1458 g_time_zone_new (const gchar *identifier)
1459 {
1460   GTimeZone *tz = NULL;
</pre>
<hr />
<pre>
1484 
1485   if (tz-&gt;t_info == NULL &amp;&amp;
1486       (rules_num = rules_from_identifier (identifier, &amp;resolved_identifier, &amp;rules)))
1487     {
1488       init_zone_from_rules (tz, rules, rules_num, g_steal_pointer (&amp;resolved_identifier));
1489       g_free (rules);
1490     }
1491 
1492   if (tz-&gt;t_info == NULL)
1493     {
1494 #ifdef G_OS_UNIX
1495       GBytes *zoneinfo = zone_info_unix (identifier, &amp;resolved_identifier);
1496       if (zoneinfo != NULL)
1497         {
1498           init_zone_from_iana_info (tz, zoneinfo, g_steal_pointer (&amp;resolved_identifier));
1499           g_bytes_unref (zoneinfo);
1500         }
1501 #elif defined (G_OS_WIN32)
1502       if ((rules_num = rules_from_windows_time_zone (identifier,
1503                                                      &amp;resolved_identifier,
<span class="line-modified">1504                                                      &amp;rules)))</span>

1505         {
1506           init_zone_from_rules (tz, rules, rules_num, g_steal_pointer (&amp;resolved_identifier));
1507           g_free (rules);
1508         }
1509 #endif
1510     }
1511 
1512 #if defined (G_OS_WIN32)
1513   if (tz-&gt;t_info == NULL)
1514     {
1515       if (identifier == NULL)
1516         {
1517           TIME_ZONE_INFORMATION tzi;
1518 
1519           if (GetTimeZoneInformation (&amp;tzi) != TIME_ZONE_ID_INVALID)
1520             {
1521               rules = g_new0 (TimeZoneRule, 2);
1522 
<span class="line-modified">1523               rule_from_windows_time_zone_info (&amp;rules[0], &amp;tzi);</span>
<span class="line-modified">1524 </span>
<span class="line-modified">1525               memset (rules[0].std_name, 0, NAME_SIZE);</span>
<span class="line-modified">1526               memset (rules[0].dlt_name, 0, NAME_SIZE);</span>
1527 
<span class="line-modified">1528               rules[0].start_year = MIN_TZYEAR;</span>
<span class="line-modified">1529               rules[1].start_year = MAX_TZYEAR;</span>
1530 
<span class="line-modified">1531               init_zone_from_rules (tz, rules, 2, windows_default_tzname ());</span>

1532 
1533               g_free (rules);
1534             }
1535         }
1536     }
1537 #endif
1538 
1539   g_free (resolved_identifier);
1540 
1541   /* Always fall back to UTC. */
1542   if (tz-&gt;t_info == NULL)
1543     zone_for_constant_offset (tz, &quot;UTC&quot;);
1544 
1545   g_assert (tz-&gt;name != NULL);
1546   g_assert (tz-&gt;t_info != NULL);
1547 
1548   if (tz-&gt;t_info != NULL)
1549     {
1550       if (identifier)
1551         g_hash_table_insert (time_zones, tz-&gt;name, tz);
</pre>
<hr />
<pre>
1764  * described below).
1765  *
1766  * In any of the cases where g_time_zone_find_interval() succeeds then
1767  * this function returns the same value, without modifying @time_.
1768  *
1769  * This function may, however, modify @time_ in order to deal with
1770  * non-existent times.  If the non-existent local @time_ of 02:30 were
1771  * requested on March 14th 2010 in Toronto then this function would
1772  * adjust @time_ to be 03:00 and return the interval containing the
1773  * adjusted time.
1774  *
1775  * Returns: the interval containing @time_, never -1
1776  *
1777  * Since: 2.26
1778  **/
1779 gint
1780 g_time_zone_adjust_time (GTimeZone *tz,
1781                          GTimeType  type,
1782                          gint64    *time_)
1783 {
<span class="line-modified">1784   gint i;</span>
<span class="line-modified">1785   guint intervals;</span>
1786 
1787   if (tz-&gt;transitions == NULL)
1788     return 0;
1789 
1790   intervals = tz-&gt;transitions-&gt;len;
1791 
1792   /* find the interval containing *time UTC
1793    * TODO: this could be binary searched (or better) */
1794   for (i = 0; i &lt;= intervals; i++)
1795     if (*time_ &lt;= interval_end (tz, i))
1796       break;
1797 
1798   g_assert (interval_start (tz, i) &lt;= *time_ &amp;&amp; *time_ &lt;= interval_end (tz, i));
1799 
1800   if (type != G_TIME_TYPE_UNIVERSAL)
1801     {
1802       if (*time_ &lt; interval_local_start (tz, i))
1803         /* if time came before the start of this interval... */
1804         {
1805           i--;
</pre>
<hr />
<pre>
1807           /* if it&#39;s not in the previous interval... */
1808           if (*time_ &gt; interval_local_end (tz, i))
1809             {
1810               /* it doesn&#39;t exist.  fast-forward it. */
1811               i++;
1812               *time_ = interval_local_start (tz, i);
1813             }
1814         }
1815 
1816       else if (*time_ &gt; interval_local_end (tz, i))
1817         /* if time came after the end of this interval... */
1818         {
1819           i++;
1820 
1821           /* if it&#39;s not in the next interval... */
1822           if (*time_ &lt; interval_local_start (tz, i))
1823             /* it doesn&#39;t exist.  fast-forward it. */
1824             *time_ = interval_local_start (tz, i);
1825         }
1826 
<span class="line-modified">1827       else if (interval_isdst (tz, i) != type)</span>
<span class="line-removed">1828         /* it&#39;s in this interval, but dst flag doesn&#39;t match.</span>
<span class="line-removed">1829          * check neighbours for a better fit. */</span>
1830         {
<span class="line-modified">1831           if (i &amp;&amp; *time_ &lt;= interval_local_end (tz, i - 1))</span>
<span class="line-modified">1832             i--;</span>
<span class="line-modified">1833 </span>
<span class="line-modified">1834           else if (i &lt; intervals &amp;&amp;</span>
<span class="line-modified">1835                    *time_ &gt;= interval_local_start (tz, i + 1))</span>
<span class="line-modified">1836             i++;</span>







1837         }
1838     }
1839 
1840   return i;
1841 }
1842 
1843 /**
1844  * g_time_zone_find_interval:
1845  * @tz: a #GTimeZone
1846  * @type: the #GTimeType of @time_
1847  * @time_: a number of seconds since January 1, 1970
1848  *
<span class="line-modified">1849  * Finds an the interval within @tz that corresponds to the given @time_.</span>
1850  * The meaning of @time_ depends on @type.
1851  *
1852  * If @type is %G_TIME_TYPE_UNIVERSAL then this function will always
1853  * succeed (since universal time is monotonic and continuous).
1854  *
1855  * Otherwise @time_ is treated as local time.  The distinction between
1856  * %G_TIME_TYPE_STANDARD and %G_TIME_TYPE_DAYLIGHT is ignored except in
1857  * the case that the given @time_ is ambiguous.  In Toronto, for example,
1858  * 01:30 on November 7th 2010 occurred twice (once inside of daylight
1859  * savings time and the next, an hour later, outside of daylight savings
1860  * time).  In this case, the different value of @type would result in a
1861  * different interval being returned.
1862  *
1863  * It is still possible for this function to fail.  In Toronto, for
1864  * example, 02:00 on March 14th 2010 does not exist (due to the leap
1865  * forward to begin daylight savings time).  -1 is returned in that
1866  * case.
1867  *
1868  * Returns: the interval containing @time_, or -1 in case of failure
1869  *
1870  * Since: 2.26
1871  */
1872 gint
1873 g_time_zone_find_interval (GTimeZone *tz,
1874                            GTimeType  type,
1875                            gint64     time_)
1876 {
<span class="line-modified">1877   gint i;</span>
<span class="line-modified">1878   guint intervals;</span>
1879 
1880   if (tz-&gt;transitions == NULL)
1881     return 0;
1882   intervals = tz-&gt;transitions-&gt;len;
1883   for (i = 0; i &lt;= intervals; i++)
1884     if (time_ &lt;= interval_end (tz, i))
1885       break;
1886 
1887   if (type == G_TIME_TYPE_UNIVERSAL)
1888     return i;
1889 
1890   if (time_ &lt; interval_local_start (tz, i))
1891     {
1892       if (time_ &gt; interval_local_end (tz, --i))
1893         return -1;
1894     }
1895 
1896   else if (time_ &gt; interval_local_end (tz, i))
1897     {
1898       if (time_ &lt; interval_local_start (tz, ++i))
1899         return -1;
1900     }
1901 
<span class="line-modified">1902   else if (interval_isdst (tz, i) != type)</span>
1903     {
<span class="line-modified">1904       if (i &amp;&amp; time_ &lt;= interval_local_end (tz, i - 1))</span>
<span class="line-modified">1905         i--;</span>




1906 
<span class="line-modified">1907       else if (i &lt; intervals &amp;&amp; time_ &gt;= interval_local_start (tz, i + 1))</span>
<span class="line-modified">1908         i++;</span>

1909     }
1910 
1911   return i;
1912 }
1913 
1914 /* Public API accessors {{{1 */
1915 
1916 /**
1917  * g_time_zone_get_abbreviation:
1918  * @tz: a #GTimeZone
1919  * @interval: an interval within the timezone
1920  *
1921  * Determines the time zone abbreviation to be used during a particular
1922  * @interval of time in the time zone @tz.
1923  *
1924  * For example, in Toronto this is currently &quot;EST&quot; during the winter
1925  * months and &quot;EDT&quot; during the summer months when daylight savings time
1926  * is in effect.
1927  *
1928  * Returns: the time zone abbreviation, which belongs to @tz
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2010 Codethink Limited</span>
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  *
  17  * Author: Ryan Lortie &lt;desrt@desrt.ca&gt;
  18  */
  19 
  20 /* Prologue {{{1 */
  21 
  22 #include &quot;config.h&quot;
  23 
  24 #include &quot;gtimezone.h&quot;
  25 
  26 #include &lt;string.h&gt;
  27 #include &lt;stdlib.h&gt;
  28 #include &lt;signal.h&gt;
  29 
  30 #include &quot;gmappedfile.h&quot;
  31 #include &quot;gtestutils.h&quot;
  32 #include &quot;gfileutils.h&quot;
  33 #include &quot;gstrfuncs.h&quot;
  34 #include &quot;ghash.h&quot;
  35 #include &quot;gthread.h&quot;
  36 #include &quot;gbytes.h&quot;
  37 #include &quot;gslice.h&quot;
  38 #include &quot;gdatetime.h&quot;
  39 #include &quot;gdate.h&quot;
  40 
  41 #ifdef G_OS_WIN32
<span class="line-added">  42 </span>
  43 #define STRICT
  44 #include &lt;windows.h&gt;
<span class="line-added">  45 #include &lt;wchar.h&gt;</span>
  46 #endif
  47 
  48 /**
  49  * SECTION:timezone
  50  * @title: GTimeZone
  51  * @short_description: a structure representing a time zone
  52  * @see_also: #GDateTime
  53  *
  54  * #GTimeZone is a structure that represents a time zone, at no
  55  * particular point in time.  It is refcounted and immutable.
  56  *
<span class="line-modified">  57  * Each time zone has an identifier (for example, &#39;Europe/London&#39;) which is</span>
  58  * platform dependent. See g_time_zone_new() for information on the identifier
  59  * formats. The identifier of a time zone can be retrieved using
  60  * g_time_zone_get_identifier().
  61  *
  62  * A time zone contains a number of intervals.  Each interval has
<span class="line-modified">  63  * an abbreviation to describe it (for example, &#39;PDT&#39;), an offet to UTC and a</span>
  64  * flag indicating if the daylight savings time is in effect during that
<span class="line-modified">  65  * interval.  A time zone always has at least one interval - interval 0. Note</span>
  66  * that interval abbreviations are not the same as time zone identifiers
<span class="line-modified">  67  * (apart from &#39;UTC&#39;), and cannot be passed to g_time_zone_new().</span>
  68  *
  69  * Every UTC time is contained within exactly one interval, but a given
  70  * local time may be contained within zero, one or two intervals (due to
  71  * incontinuities associated with daylight savings time).
  72  *
  73  * An interval may refer to a specific period of time (eg: the duration
  74  * of daylight savings time during 2010) or it may refer to many periods
  75  * of time that share the same properties (eg: all periods of daylight
  76  * savings time).  It is also possible (usually for political reasons)
  77  * that some properties (like the abbreviation) change between intervals
  78  * without other properties changing.
  79  *
  80  * #GTimeZone is available since GLib 2.26.
  81  */
  82 
  83 /**
  84  * GTimeZone:
  85  *
  86  * #GTimeZone is an opaque structure whose members cannot be accessed
  87  * directly.
</pre>
<hr />
<pre>
 222 
 223   if (ref_count == 1)
 224     {
 225       if (tz-&gt;name != NULL)
 226         {
 227           G_LOCK(time_zones);
 228 
 229           /* someone else might have grabbed a ref in the meantime */
 230           if G_UNLIKELY (g_atomic_int_get (&amp;tz-&gt;ref_count) != 1)
 231             {
 232               G_UNLOCK(time_zones);
 233               goto again;
 234             }
 235 
 236           g_hash_table_remove (time_zones, tz-&gt;name);
 237           G_UNLOCK(time_zones);
 238         }
 239 
 240       if (tz-&gt;t_info != NULL)
 241         {
<span class="line-modified"> 242           guint idx;</span>
 243           for (idx = 0; idx &lt; tz-&gt;t_info-&gt;len; idx++)
 244             {
 245               TransitionInfo *info = &amp;g_array_index (tz-&gt;t_info, TransitionInfo, idx);
 246               g_free (info-&gt;abbrev);
 247             }
 248           g_array_free (tz-&gt;t_info, TRUE);
 249         }
 250       if (tz-&gt;transitions != NULL)
 251         g_array_free (tz-&gt;transitions, TRUE);
 252       g_free (tz-&gt;name);
 253 
 254       g_slice_free (GTimeZone, tz);
 255     }
 256 
 257   else if G_UNLIKELY (!g_atomic_int_compare_and_exchange (&amp;tz-&gt;ref_count,
 258                                                           ref_count,
 259                                                           ref_count - 1))
 260     goto again;
 261 }
 262 
</pre>
<hr />
<pre>
 357     }
 358 
 359   if (*name &gt;= &#39;0&#39; &amp;&amp; &#39;9&#39; &gt;= *name)
 360     return parse_time (name, offset);
 361 
 362   switch (*name++)
 363     {
 364     case &#39;Z&#39;:
 365       *offset = 0;
 366       return !*name;
 367 
 368     case &#39;+&#39;:
 369       return parse_time (name, offset);
 370 
 371     case &#39;-&#39;:
 372       if (parse_time (name, offset))
 373         {
 374           *offset = -*offset;
 375           return TRUE;
 376         }
<span class="line-added"> 377       else</span>
<span class="line-added"> 378         return FALSE;</span>
 379 
 380     default:
 381       return FALSE;
 382     }
 383 }
 384 
 385 static void
 386 zone_for_constant_offset (GTimeZone *gtz, const gchar *name)
 387 {
 388   gint32 offset;
 389   TransitionInfo info;
 390 
 391   if (name == NULL || !parse_constant_offset (name, &amp;offset))
 392     return;
 393 
 394   info.gmt_offset = offset;
 395   info.is_dst = FALSE;
 396   info.abbrev =  g_strdup (name);
 397 
 398   gtz-&gt;name = g_strdup (name);
</pre>
<hr />
<pre>
 423      while the POSIX standard says it should start with :,
 424      glibc allows both syntaxes, so we should too */
 425   if (identifier != NULL)
 426     {
 427       resolved_identifier = g_strdup (identifier);
 428 
 429       if (*identifier == &#39;:&#39;)
 430         identifier ++;
 431 
 432       if (g_path_is_absolute (identifier))
 433         filename = g_strdup (identifier);
 434       else
 435         filename = g_build_filename (tzdir, identifier, NULL);
 436     }
 437   else
 438     {
 439       gsize prefix_len = 0;
 440       gchar *canonical_path = NULL;
 441       GError *read_link_err = NULL;
 442 
<span class="line-modified"> 443       filename = g_strdup (&quot;/etc/localtime&quot;);</span>
 444 
 445       /* Resolve the actual timezone pointed to by /etc/localtime. */
 446       resolved_identifier = g_file_read_link (filename, &amp;read_link_err);
 447       if (resolved_identifier == NULL)
 448         {
 449           gboolean not_a_symlink = g_error_matches (read_link_err,
 450                                                     G_FILE_ERROR,
 451                                                     G_FILE_ERROR_INVAL);
 452           g_clear_error (&amp;read_link_err);
 453 
 454           /* Fallback to the content of /var/db/zoneinfo or /etc/timezone
 455            * if /etc/localtime is not a symlink. /var/db/zoneinfo is
 456            * where &#39;tzsetup&#39; program on FreeBSD and DragonflyBSD stores
 457            * the timezone chosen by the user. /etc/timezone is where user
 458            * choice is expressed on Gentoo OpenRC and others. */
 459           if (not_a_symlink &amp;&amp; (g_file_get_contents (&quot;/var/db/zoneinfo&quot;,
 460                                                      &amp;resolved_identifier,
 461                                                      NULL, NULL) ||
 462                                 g_file_get_contents (&quot;/etc/timezone&quot;,
 463                                                      &amp;resolved_identifier,
</pre>
<hr />
<pre>
 560 
 561   for (index = 0; index &lt; type_count; index++)
 562     {
 563       TransitionInfo t_info;
 564       struct ttinfo info = ((struct ttinfo*)tz_ttinfo)[index];
 565       t_info.gmt_offset = gint32_from_be (info.tt_gmtoff);
 566       t_info.is_dst = info.tt_isdst ? TRUE : FALSE;
 567       t_info.abbrev = g_strdup ((gchar *) &amp;tz_abbrs[info.tt_abbrind]);
 568       g_array_append_val (gtz-&gt;t_info, t_info);
 569     }
 570 
 571   for (index = 0; index &lt; time_count; index++)
 572     {
 573       Transition trans;
 574       if (header-&gt;tzh_version == &#39;2&#39;)
 575         trans.time = gint64_from_be (((gint64_be*)tz_transitions)[index]);
 576       else
 577         trans.time = gint32_from_be (((gint32_be*)tz_transitions)[index]);
 578       trans.info_index = tz_type_index[index];
 579       g_assert (trans.info_index &gt;= 0);
<span class="line-modified"> 580       g_assert ((guint) trans.info_index &lt; gtz-&gt;t_info-&gt;len);</span>
 581       g_array_append_val (gtz-&gt;transitions, trans);
 582     }
 583 }
 584 
 585 #elif defined (G_OS_WIN32)
 586 
 587 static void
 588 copy_windows_systemtime (SYSTEMTIME *s_time, TimeZoneDate *tzdate)
 589 {
 590   tzdate-&gt;sec = s_time-&gt;wSecond;
 591   tzdate-&gt;min = s_time-&gt;wMinute;
 592   tzdate-&gt;hour = s_time-&gt;wHour;
 593   tzdate-&gt;mon = s_time-&gt;wMonth;
 594   tzdate-&gt;year = s_time-&gt;wYear;
 595   tzdate-&gt;wday = s_time-&gt;wDayOfWeek ? s_time-&gt;wDayOfWeek : 7;
 596 
 597   if (s_time-&gt;wYear)
 598     {
 599       tzdate-&gt;mday = s_time-&gt;wDay;
 600       tzdate-&gt;wday = 0;
 601     }
 602   else
 603     tzdate-&gt;week = s_time-&gt;wDay;
 604 }
 605 
 606 /* UTC = local time + bias while local time = UTC + offset */
<span class="line-modified"> 607 static gboolean</span>
 608 rule_from_windows_time_zone_info (TimeZoneRule *rule,
 609                                   TIME_ZONE_INFORMATION *tzi)
 610 {
<span class="line-added"> 611   gchar *std_name, *dlt_name;</span>
<span class="line-added"> 612 </span>
<span class="line-added"> 613   std_name = g_utf16_to_utf8 ((gunichar2 *)tzi-&gt;StandardName, -1, NULL, NULL, NULL);</span>
<span class="line-added"> 614   if (std_name == NULL)</span>
<span class="line-added"> 615     return FALSE;</span>
<span class="line-added"> 616 </span>
<span class="line-added"> 617   dlt_name = g_utf16_to_utf8 ((gunichar2 *)tzi-&gt;DaylightName, -1, NULL, NULL, NULL);</span>
<span class="line-added"> 618   if (dlt_name == NULL)</span>
<span class="line-added"> 619     {</span>
<span class="line-added"> 620       g_free (std_name);</span>
<span class="line-added"> 621       return FALSE;</span>
<span class="line-added"> 622     }</span>
<span class="line-added"> 623 </span>
 624   /* Set offset */
 625   if (tzi-&gt;StandardDate.wMonth)
 626     {
 627       rule-&gt;std_offset = -(tzi-&gt;Bias + tzi-&gt;StandardBias) * 60;
 628       rule-&gt;dlt_offset = -(tzi-&gt;Bias + tzi-&gt;DaylightBias) * 60;
 629       copy_windows_systemtime (&amp;(tzi-&gt;DaylightDate), &amp;(rule-&gt;dlt_start));
 630 
 631       copy_windows_systemtime (&amp;(tzi-&gt;StandardDate), &amp;(rule-&gt;dlt_end));

 632     }
 633 
 634   else
 635     {
 636       rule-&gt;std_offset = -tzi-&gt;Bias * 60;
 637       rule-&gt;dlt_start.mon = 0;
 638     }
<span class="line-modified"> 639   strncpy (rule-&gt;std_name, std_name, NAME_SIZE - 1);</span>
<span class="line-modified"> 640   strncpy (rule-&gt;dlt_name, dlt_name, NAME_SIZE - 1);</span>
<span class="line-added"> 641 </span>
<span class="line-added"> 642   g_free (std_name);</span>
<span class="line-added"> 643   g_free (dlt_name);</span>
<span class="line-added"> 644 </span>
<span class="line-added"> 645   return TRUE;</span>
 646 }
 647 
 648 static gchar*
 649 windows_default_tzname (void)
 650 {
<span class="line-modified"> 651   const gunichar2 *subkey =</span>
<span class="line-modified"> 652     L&quot;SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation&quot;;</span>
 653   HKEY key;
 654   gchar *key_name = NULL;
<span class="line-modified"> 655   gunichar2 *key_name_w = NULL;</span>
<span class="line-added"> 656   if (RegOpenKeyExW (HKEY_LOCAL_MACHINE, subkey, 0,</span>
 657                      KEY_QUERY_VALUE, &amp;key) == ERROR_SUCCESS)
 658     {
 659       DWORD size = 0;
<span class="line-modified"> 660       if (RegQueryValueExW (key, L&quot;TimeZoneKeyName&quot;, NULL, NULL,</span>
 661                             NULL, &amp;size) == ERROR_SUCCESS)
 662         {
<span class="line-modified"> 663           key_name_w = g_malloc ((gint)size);</span>
<span class="line-modified"> 664 </span>
<span class="line-modified"> 665           if (key_name_w == NULL ||</span>
<span class="line-added"> 666               RegQueryValueExW (key, L&quot;TimeZoneKeyName&quot;, NULL, NULL,</span>
<span class="line-added"> 667                                 (LPBYTE)key_name_w, &amp;size) != ERROR_SUCCESS)</span>
 668             {
<span class="line-modified"> 669               g_free (key_name_w);</span>
 670               key_name = NULL;
 671             }
<span class="line-added"> 672           else</span>
<span class="line-added"> 673             key_name = g_utf16_to_utf8 (key_name_w, -1, NULL, NULL, NULL);</span>
 674         }
 675       RegCloseKey (key);
 676     }
 677   return key_name;
 678 }
 679 
 680 typedef   struct
 681 {
 682   LONG Bias;
 683   LONG StandardBias;
 684   LONG DaylightBias;
 685   SYSTEMTIME StandardDate;
 686   SYSTEMTIME DaylightDate;
 687 } RegTZI;
 688 
 689 static void
 690 system_time_copy (SYSTEMTIME *orig, SYSTEMTIME *target)
 691 {
 692   g_return_if_fail (orig != NULL);
 693   g_return_if_fail (target != NULL);
</pre>
<hr />
<pre>
 697   target-&gt;wDayOfWeek = orig-&gt;wDayOfWeek;
 698   target-&gt;wDay = orig-&gt;wDay;
 699   target-&gt;wHour = orig-&gt;wHour;
 700   target-&gt;wMinute = orig-&gt;wMinute;
 701   target-&gt;wSecond = orig-&gt;wSecond;
 702   target-&gt;wMilliseconds = orig-&gt;wMilliseconds;
 703 }
 704 
 705 static void
 706 register_tzi_to_tzi (RegTZI *reg, TIME_ZONE_INFORMATION *tzi)
 707 {
 708   g_return_if_fail (reg != NULL);
 709   g_return_if_fail (tzi != NULL);
 710   tzi-&gt;Bias = reg-&gt;Bias;
 711   system_time_copy (&amp;(reg-&gt;StandardDate), &amp;(tzi-&gt;StandardDate));
 712   tzi-&gt;StandardBias = reg-&gt;StandardBias;
 713   system_time_copy (&amp;(reg-&gt;DaylightDate), &amp;(tzi-&gt;DaylightDate));
 714   tzi-&gt;DaylightBias = reg-&gt;DaylightBias;
 715 }
 716 
<span class="line-modified"> 717 static guint</span>
 718 rules_from_windows_time_zone (const gchar   *identifier,
 719                               gchar        **out_identifier,
<span class="line-modified"> 720                               TimeZoneRule **rules,</span>
<span class="line-added"> 721                               gboolean       copy_identifier)</span>
 722 {
 723   HKEY key;
<span class="line-modified"> 724   gchar *subkey = NULL;</span>
<span class="line-added"> 725   gchar *subkey_dynamic = NULL;</span>
 726   gchar *key_name = NULL;
 727   const gchar *reg_key =
 728     &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones\\&quot;;
 729   TIME_ZONE_INFORMATION tzi;
 730   DWORD size;
<span class="line-modified"> 731   guint rules_num = 0;</span>
 732   RegTZI regtzi, regtzi_prev;
<span class="line-added"> 733   WCHAR winsyspath[MAX_PATH];</span>
<span class="line-added"> 734   gunichar2 *subkey_w, *subkey_dynamic_w;</span>
 735 
<span class="line-modified"> 736   if (GetSystemDirectoryW (winsyspath, MAX_PATH) == 0)</span>
<span class="line-added"> 737     return 0;</span>
<span class="line-added"> 738 </span>
<span class="line-added"> 739   g_assert (copy_identifier == FALSE || out_identifier != NULL);</span>
 740   g_assert (rules != NULL);
 741 
<span class="line-modified"> 742   if (copy_identifier)</span>
<span class="line-added"> 743     *out_identifier = NULL;</span>
<span class="line-added"> 744 </span>
 745   *rules = NULL;
 746   key_name = NULL;
 747 
 748   if (!identifier)
 749     key_name = windows_default_tzname ();
 750   else
 751     key_name = g_strdup (identifier);
 752 
 753   if (!key_name)
 754     return 0;
 755 
 756   subkey = g_strconcat (reg_key, key_name, NULL);
<span class="line-added"> 757   subkey_w = g_utf8_to_utf16 (subkey, -1, NULL, NULL, NULL);</span>
<span class="line-added"> 758   if (subkey_w == NULL)</span>
<span class="line-added"> 759     goto utf16_conv_failed;</span>
<span class="line-added"> 760 </span>
 761   subkey_dynamic = g_strconcat (subkey, &quot;\\Dynamic DST&quot;, NULL);
<span class="line-added"> 762   subkey_dynamic_w = g_utf8_to_utf16 (subkey_dynamic, -1, NULL, NULL, NULL);</span>
<span class="line-added"> 763   if (subkey_dynamic_w == NULL)</span>
<span class="line-added"> 764     goto utf16_conv_failed;</span>
 765 
<span class="line-modified"> 766   if (RegOpenKeyExW (HKEY_LOCAL_MACHINE, subkey_w, 0,</span>
 767                      KEY_QUERY_VALUE, &amp;key) != ERROR_SUCCESS)
<span class="line-modified"> 768       goto utf16_conv_failed;</span>
<span class="line-added"> 769 </span>
 770   size = sizeof tzi.StandardName;
<span class="line-modified"> 771 </span>
<span class="line-modified"> 772   /* use RegLoadMUIStringW() to query MUI_Std from the registry if possible, otherwise</span>
<span class="line-modified"> 773      fallback to querying Std */</span>
<span class="line-added"> 774   if (RegLoadMUIStringW (key, L&quot;MUI_Std&quot;, tzi.StandardName,</span>
<span class="line-added"> 775                          size, &amp;size, 0, winsyspath) != ERROR_SUCCESS)</span>
<span class="line-added"> 776     {</span>
<span class="line-added"> 777       size = sizeof tzi.StandardName;</span>
<span class="line-added"> 778       if (RegQueryValueExW (key, L&quot;Std&quot;, NULL, NULL,</span>
<span class="line-added"> 779                             (LPBYTE)&amp;(tzi.StandardName), &amp;size) != ERROR_SUCCESS)</span>
<span class="line-added"> 780         goto registry_failed;</span>
<span class="line-added"> 781     }</span>
 782 
 783   size = sizeof tzi.DaylightName;
 784 
<span class="line-modified"> 785   /* use RegLoadMUIStringW() to query MUI_Dlt from the registry if possible, otherwise</span>
<span class="line-modified"> 786      fallback to querying Dlt */</span>
<span class="line-modified"> 787   if (RegLoadMUIStringW (key, L&quot;MUI_Dlt&quot;, tzi.DaylightName,</span>
<span class="line-added"> 788                          size, &amp;size, 0, winsyspath) != ERROR_SUCCESS)</span>
<span class="line-added"> 789     {</span>
<span class="line-added"> 790       size = sizeof tzi.DaylightName;</span>
<span class="line-added"> 791       if (RegQueryValueExW (key, L&quot;Dlt&quot;, NULL, NULL,</span>
<span class="line-added"> 792                             (LPBYTE)&amp;(tzi.DaylightName), &amp;size) != ERROR_SUCCESS)</span>
<span class="line-added"> 793         goto registry_failed;</span>
<span class="line-added"> 794     }</span>
 795 
 796   RegCloseKey (key);
<span class="line-modified"> 797   if (RegOpenKeyExW (HKEY_LOCAL_MACHINE, subkey_dynamic_w, 0,</span>
 798                      KEY_QUERY_VALUE, &amp;key) == ERROR_SUCCESS)
 799     {
 800       DWORD first, last;
 801       int year, i;
<span class="line-modified"> 802       wchar_t s[12];</span>
 803 
 804       size = sizeof first;
<span class="line-modified"> 805       if (RegQueryValueExW (key, L&quot;FirstEntry&quot;, NULL, NULL,</span>
 806                             (LPBYTE) &amp;first, &amp;size) != ERROR_SUCCESS)
<span class="line-modified"> 807         goto registry_failed;</span>
 808 
 809       size = sizeof last;
<span class="line-modified"> 810       if (RegQueryValueExW (key, L&quot;LastEntry&quot;, NULL, NULL,</span>
 811                             (LPBYTE) &amp;last, &amp;size) != ERROR_SUCCESS)
<span class="line-modified"> 812         goto registry_failed;</span>
 813 
 814       rules_num = last - first + 2;
 815       *rules = g_new0 (TimeZoneRule, rules_num);
 816 
<span class="line-modified"> 817       for (year = first, i = 0; *rules != NULL &amp;&amp; year &lt;= last; year++)</span>
 818         {
<span class="line-modified"> 819           gboolean failed = FALSE;</span>
<span class="line-added"> 820           swprintf_s (s, 11, L&quot;%d&quot;, year);</span>
<span class="line-added"> 821 </span>
<span class="line-added"> 822           if (!failed)</span>
<span class="line-added"> 823             {</span>
<span class="line-added"> 824               size = sizeof regtzi;</span>
<span class="line-added"> 825               if (RegQueryValueExW (key, s, NULL, NULL,</span>
<span class="line-added"> 826                                     (LPBYTE) &amp;regtzi, &amp;size) != ERROR_SUCCESS)</span>
<span class="line-added"> 827                 failed = TRUE;</span>
<span class="line-added"> 828             }</span>
 829 
<span class="line-modified"> 830           if (failed)</span>


 831             {
 832               g_free (*rules);
 833               *rules = NULL;
 834               break;
 835             }
 836 


 837           if (year &gt; first &amp;&amp; memcmp (&amp;regtzi_prev, &amp;regtzi, sizeof regtzi) == 0)
 838               continue;
 839           else
 840             memcpy (&amp;regtzi_prev, &amp;regtzi, sizeof regtzi);
 841 
 842           register_tzi_to_tzi (&amp;regtzi, &amp;tzi);
<span class="line-modified"> 843 </span>
<span class="line-added"> 844           if (!rule_from_windows_time_zone_info (&amp;(*rules)[i], &amp;tzi))</span>
<span class="line-added"> 845             {</span>
<span class="line-added"> 846               g_free (*rules);</span>
<span class="line-added"> 847               *rules = NULL;</span>
<span class="line-added"> 848               break;</span>
<span class="line-added"> 849             }</span>
<span class="line-added"> 850 </span>
 851           (*rules)[i++].start_year = year;
 852         }
 853 
 854       rules_num = i + 1;
 855 
<span class="line-modified"> 856 registry_failed:</span>
 857       RegCloseKey (key);
 858     }
<span class="line-modified"> 859   else if (RegOpenKeyExW (HKEY_LOCAL_MACHINE, subkey_w, 0,</span>
 860                           KEY_QUERY_VALUE, &amp;key) == ERROR_SUCCESS)
 861     {
 862       size = sizeof regtzi;
<span class="line-modified"> 863       if (RegQueryValueExW (key, L&quot;TZI&quot;, NULL, NULL,</span>
 864                             (LPBYTE) &amp;regtzi, &amp;size) == ERROR_SUCCESS)
 865         {
 866           rules_num = 2;
 867           *rules = g_new0 (TimeZoneRule, 2);
 868           register_tzi_to_tzi (&amp;regtzi, &amp;tzi);
<span class="line-modified"> 869 </span>
<span class="line-added"> 870           if (!rule_from_windows_time_zone_info (&amp;(*rules)[0], &amp;tzi))</span>
<span class="line-added"> 871             {</span>
<span class="line-added"> 872               g_free (*rules);</span>
<span class="line-added"> 873               *rules = NULL;</span>
<span class="line-added"> 874             }</span>
 875         }
 876 
 877       RegCloseKey (key);
 878     }
 879 
<span class="line-added"> 880 utf16_conv_failed:</span>
<span class="line-added"> 881   g_free (subkey_dynamic_w);</span>
 882   g_free (subkey_dynamic);
<span class="line-added"> 883   g_free (subkey_w);</span>
 884   g_free (subkey);
 885 
 886   if (*rules)
 887     {
 888       (*rules)[0].start_year = MIN_TZYEAR;
 889       if ((*rules)[rules_num - 2].start_year &lt; MAX_TZYEAR)
 890         (*rules)[rules_num - 1].start_year = MAX_TZYEAR;
 891       else
 892         (*rules)[rules_num - 1].start_year = (*rules)[rules_num - 2].start_year + 1;
 893 
<span class="line-modified"> 894       if (copy_identifier)</span>
<span class="line-added"> 895         *out_identifier = g_steal_pointer (&amp;key_name);</span>
<span class="line-added"> 896       else</span>
<span class="line-added"> 897         g_free (key_name);</span>
 898 
 899       return rules_num;
 900     }
 901 
 902   g_free (key_name);
 903 
<span class="line-modified"> 904   return 0;</span>
 905 }
 906 
 907 #endif
 908 
 909 static void
 910 find_relative_date (TimeZoneDate *buffer)
 911 {
<span class="line-modified"> 912   guint wday;</span>
 913   GDate date;
 914   g_date_clear (&amp;date, 1);
 915   wday = buffer-&gt;wday;
 916 
 917   /* Get last day if last is needed, first day otherwise */
 918   if (buffer-&gt;mon == 13 || buffer-&gt;mon == 14) /* Julian Date */
 919     {
 920       g_date_set_dmy (&amp;date, 1, 1, buffer-&gt;year);
 921       if (wday &gt;= 59 &amp;&amp; buffer-&gt;mon == 13 &amp;&amp; g_date_is_leap_year (buffer-&gt;year))
 922         g_date_add_days (&amp;date, wday);
 923       else
 924         g_date_add_days (&amp;date, wday - 1);
 925       buffer-&gt;mon = (int) g_date_get_month (&amp;date);
 926       buffer-&gt;mday = (int) g_date_get_day (&amp;date);
 927       buffer-&gt;wday = 0;
 928     }
 929   else /* M.W.D */
 930     {
 931       guint days;
 932 #ifdef GSTREAMER_LITE
</pre>
<hr />
<pre>
 989                                 gboolean        is_dst)
 990 {
 991   gint offset = is_dst ? rule-&gt;dlt_offset : rule-&gt;std_offset;
 992   gchar *name = is_dst ? rule-&gt;dlt_name : rule-&gt;std_name;
 993 
 994   info-&gt;gmt_offset = offset;
 995   info-&gt;is_dst = is_dst;
 996 
 997   if (name)
 998     info-&gt;abbrev = g_strdup (name);
 999 
1000   else
1001     info-&gt;abbrev = g_strdup_printf (&quot;%+03d%02d&quot;,
1002                                       (int) offset / 3600,
1003                                       (int) abs (offset / 60) % 60);
1004 }
1005 
1006 static void
1007 init_zone_from_rules (GTimeZone    *gtz,
1008                       TimeZoneRule *rules,
<span class="line-modified">1009                       guint         rules_num,</span>
1010                       gchar        *identifier  /* (transfer full) */)
1011 {
1012   guint type_count = 0, trans_count = 0, info_index = 0;
1013   guint ri; /* rule index */
1014   gboolean skip_first_std_trans = TRUE;
1015   gint32 last_offset;
1016 
1017   type_count = 0;
1018   trans_count = 0;
1019 
1020   /* Last rule only contains max year */
1021   for (ri = 0; ri &lt; rules_num - 1; ri++)
1022     {
1023       if (rules[ri].dlt_start.mon || rules[ri].dlt_end.mon)
1024         {
1025           guint rulespan = (rules[ri + 1].start_year - rules[ri].start_year);
1026           guint transitions = rules[ri].dlt_start.mon &gt; 0 ? 1 : 0;
1027           transitions += rules[ri].dlt_end.mon &gt; 0 ? 1 : 0;
1028           type_count += rules[ri].dlt_start.mon &gt; 0 ? 2 : 1;
1029           trans_count += transitions * rulespan;
</pre>
<hr />
<pre>
1280       if (!parse_time (++pos, &amp;offset))
1281         return FALSE;
1282 
1283       boundary-&gt;hour = offset / 3600;
1284       boundary-&gt;min = (offset / 60) % 60;
1285       boundary-&gt;sec = offset % 3600;
1286 
1287       return TRUE;
1288     }
1289 
1290   else
1291     {
1292       boundary-&gt;hour = 2;
1293       boundary-&gt;min = 0;
1294       boundary-&gt;sec = 0;
1295 
1296       return *pos == &#39;\0&#39;;
1297     }
1298 }
1299 
<span class="line-modified">1300 static guint</span>
1301 create_ruleset_from_rule (TimeZoneRule **rules, TimeZoneRule *rule)
1302 {
1303   *rules = g_new0 (TimeZoneRule, 2);
1304 
1305   (*rules)[0].start_year = MIN_TZYEAR;
1306   (*rules)[1].start_year = MAX_TZYEAR;
1307 
1308   (*rules)[0].std_offset = -rule-&gt;std_offset;
1309   (*rules)[0].dlt_offset = -rule-&gt;dlt_offset;
1310   (*rules)[0].dlt_start  = rule-&gt;dlt_start;
1311   (*rules)[0].dlt_end = rule-&gt;dlt_end;
1312   strcpy ((*rules)[0].std_name, rule-&gt;std_name);
1313   strcpy ((*rules)[0].dlt_name, rule-&gt;dlt_name);
1314   return 2;
1315 }
1316 
1317 static gboolean
1318 parse_offset (gchar **pos, gint32 *target)
1319 {
1320   gchar *buffer;
</pre>
<hr />
<pre>
1372 static gboolean
1373 parse_identifier_boundaries (gchar **pos, TimeZoneRule *tzr)
1374 {
1375   if (*(*pos)++ != &#39;,&#39;)
1376     return FALSE;
1377 
1378   /* Start date */
1379   if (!parse_identifier_boundary (pos, &amp;(tzr-&gt;dlt_start)) || *(*pos)++ != &#39;,&#39;)
1380     return FALSE;
1381 
1382   /* End date */
1383   if (!parse_identifier_boundary (pos, &amp;(tzr-&gt;dlt_end)))
1384     return FALSE;
1385   return TRUE;
1386 }
1387 
1388 /*
1389  * Creates an array of TimeZoneRule from a TZ environment variable
1390  * type of identifier.  Should free rules afterwards
1391  */
<span class="line-modified">1392 static guint</span>
1393 rules_from_identifier (const gchar   *identifier,
1394                        gchar        **out_identifier,
1395                        TimeZoneRule **rules)
1396 {
1397   gchar *pos;
1398   TimeZoneRule tzr;
1399 
1400   g_assert (out_identifier != NULL);
1401   g_assert (rules != NULL);
1402 
1403   *out_identifier = NULL;
1404   *rules = NULL;
1405 
1406   if (!identifier)
1407     return 0;
1408 
1409   pos = (gchar*)identifier;
1410   memset (&amp;tzr, 0, sizeof (tzr));
1411   /* Standard offset */
1412   if (!(set_tz_name (&amp;pos, tzr.std_name, NAME_SIZE)) ||
</pre>
<hr />
<pre>
1418       *out_identifier = g_strdup (identifier);
1419       return create_ruleset_from_rule (rules, &amp;tzr);
1420     }
1421 
1422   /* Format 2 */
1423   if (!(set_tz_name (&amp;pos, tzr.dlt_name, NAME_SIZE)))
1424     return 0;
1425   parse_offset (&amp;pos, &amp;(tzr.dlt_offset));
1426   if (tzr.dlt_offset == 0) /* No daylight offset given, assume it&#39;s 1
1427                               hour earlier that standard */
1428     tzr.dlt_offset = tzr.std_offset - 3600;
1429   if (*pos == &#39;\0&#39;)
1430 #ifdef G_OS_WIN32
1431     /* Windows allows us to use the US DST boundaries if they&#39;re not given */
1432     {
1433       int i;
1434       guint rules_num = 0;
1435 
1436       /* Use US rules, Windows&#39; default is Pacific Standard Time */
1437       if ((rules_num = rules_from_windows_time_zone (&quot;Pacific Standard Time&quot;,
<span class="line-modified">1438                                                      NULL,</span>
<span class="line-modified">1439                                                      rules,</span>
<span class="line-added">1440                                                      FALSE)))</span>
1441         {
<span class="line-added">1442           /* We don&#39;t want to hardcode our identifier here as</span>
<span class="line-added">1443            * &quot;Pacific Standard Time&quot;, use what was passed in</span>
<span class="line-added">1444            */</span>
<span class="line-added">1445           *out_identifier = g_strdup (identifier);</span>
<span class="line-added">1446 </span>
1447           for (i = 0; i &lt; rules_num - 1; i++)
1448             {
1449               (*rules)[i].std_offset = - tzr.std_offset;
1450               (*rules)[i].dlt_offset = - tzr.dlt_offset;
1451               strcpy ((*rules)[i].std_name, tzr.std_name);
1452               strcpy ((*rules)[i].dlt_name, tzr.dlt_name);
1453             }
1454 
1455           return rules_num;
1456         }
1457       else
1458         return 0;
1459     }
1460 #else
1461   return 0;
1462 #endif
1463   /* Start and end required (format 2) */
1464   if (!parse_identifier_boundaries (&amp;pos, &amp;tzr))
1465     return 0;
1466 
</pre>
<hr />
<pre>
1507  * accepts POSIX format.  The Windows format uses US rules for all time
1508  * zones; daylight savings time is 60 minutes behind the standard time
1509  * with date and time of change taken from Pacific Standard Time.
1510  * Offsets are time values to be added to the local time to get
1511  * Coordinated Universal Time (UTC).
1512  *
1513  * g_time_zone_new_local() calls this function with the value of the
1514  * &#39;TZ&#39; environment variable. This function itself is independent of
1515  * the value of &#39;TZ&#39;, but if @identifier is %NULL then &#39;/etc/localtime&#39;
1516  * will be consulted to discover the correct time zone on UNIX and the
1517  * registry will be consulted or GetTimeZoneInformation() will be used
1518  * to get the local time zone on Windows.
1519  *
1520  * If intervals are not available, only time zone rules from `TZ`
1521  * environment variable or other means, then they will be computed
1522  * from year 1900 to 2037.  If the maximum year for the rules is
1523  * available and it is greater than 2037, then it will followed
1524  * instead.
1525  *
1526  * See
<span class="line-modified">1527  * [RFC3339 5.6](http://tools.ietf.org/html/rfc3339#section-5.6)</span>
1528  * for a precise definition of valid RFC3339 time offsets
1529  * (the `time-offset` expansion) and ISO 8601 for the
1530  * full list of valid time offsets.  See
1531  * [The GNU C Library manual](http://www.gnu.org/s/libc/manual/html_node/TZ-Variable.html)
1532  * for an explanation of the possible
1533  * values of the `TZ` environment variable. See
1534  * [Microsoft Time Zone Index Values](http://msdn.microsoft.com/en-us/library/ms912391%28v=winembedded.11%29.aspx)
1535  * for the list of time zones on Windows.
1536  *
1537  * You should release the return value by calling g_time_zone_unref()
1538  * when you are done with it.
1539  *
1540  * Returns: the requested timezone
1541  *
1542  * Since: 2.26
1543  **/
1544 GTimeZone *
1545 g_time_zone_new (const gchar *identifier)
1546 {
1547   GTimeZone *tz = NULL;
</pre>
<hr />
<pre>
1571 
1572   if (tz-&gt;t_info == NULL &amp;&amp;
1573       (rules_num = rules_from_identifier (identifier, &amp;resolved_identifier, &amp;rules)))
1574     {
1575       init_zone_from_rules (tz, rules, rules_num, g_steal_pointer (&amp;resolved_identifier));
1576       g_free (rules);
1577     }
1578 
1579   if (tz-&gt;t_info == NULL)
1580     {
1581 #ifdef G_OS_UNIX
1582       GBytes *zoneinfo = zone_info_unix (identifier, &amp;resolved_identifier);
1583       if (zoneinfo != NULL)
1584         {
1585           init_zone_from_iana_info (tz, zoneinfo, g_steal_pointer (&amp;resolved_identifier));
1586           g_bytes_unref (zoneinfo);
1587         }
1588 #elif defined (G_OS_WIN32)
1589       if ((rules_num = rules_from_windows_time_zone (identifier,
1590                                                      &amp;resolved_identifier,
<span class="line-modified">1591                                                      &amp;rules,</span>
<span class="line-added">1592                                                      TRUE)))</span>
1593         {
1594           init_zone_from_rules (tz, rules, rules_num, g_steal_pointer (&amp;resolved_identifier));
1595           g_free (rules);
1596         }
1597 #endif
1598     }
1599 
1600 #if defined (G_OS_WIN32)
1601   if (tz-&gt;t_info == NULL)
1602     {
1603       if (identifier == NULL)
1604         {
1605           TIME_ZONE_INFORMATION tzi;
1606 
1607           if (GetTimeZoneInformation (&amp;tzi) != TIME_ZONE_ID_INVALID)
1608             {
1609               rules = g_new0 (TimeZoneRule, 2);
1610 
<span class="line-modified">1611               if (rule_from_windows_time_zone_info (&amp;rules[0], &amp;tzi))</span>
<span class="line-modified">1612                 {</span>
<span class="line-modified">1613                   memset (rules[0].std_name, 0, NAME_SIZE);</span>
<span class="line-modified">1614                   memset (rules[0].dlt_name, 0, NAME_SIZE);</span>
1615 
<span class="line-modified">1616                   rules[0].start_year = MIN_TZYEAR;</span>
<span class="line-modified">1617                   rules[1].start_year = MAX_TZYEAR;</span>
1618 
<span class="line-modified">1619                   init_zone_from_rules (tz, rules, 2, windows_default_tzname ());</span>
<span class="line-added">1620                 }</span>
1621 
1622               g_free (rules);
1623             }
1624         }
1625     }
1626 #endif
1627 
1628   g_free (resolved_identifier);
1629 
1630   /* Always fall back to UTC. */
1631   if (tz-&gt;t_info == NULL)
1632     zone_for_constant_offset (tz, &quot;UTC&quot;);
1633 
1634   g_assert (tz-&gt;name != NULL);
1635   g_assert (tz-&gt;t_info != NULL);
1636 
1637   if (tz-&gt;t_info != NULL)
1638     {
1639       if (identifier)
1640         g_hash_table_insert (time_zones, tz-&gt;name, tz);
</pre>
<hr />
<pre>
1853  * described below).
1854  *
1855  * In any of the cases where g_time_zone_find_interval() succeeds then
1856  * this function returns the same value, without modifying @time_.
1857  *
1858  * This function may, however, modify @time_ in order to deal with
1859  * non-existent times.  If the non-existent local @time_ of 02:30 were
1860  * requested on March 14th 2010 in Toronto then this function would
1861  * adjust @time_ to be 03:00 and return the interval containing the
1862  * adjusted time.
1863  *
1864  * Returns: the interval containing @time_, never -1
1865  *
1866  * Since: 2.26
1867  **/
1868 gint
1869 g_time_zone_adjust_time (GTimeZone *tz,
1870                          GTimeType  type,
1871                          gint64    *time_)
1872 {
<span class="line-modified">1873   guint i, intervals;</span>
<span class="line-modified">1874   gboolean interval_is_dst;</span>
1875 
1876   if (tz-&gt;transitions == NULL)
1877     return 0;
1878 
1879   intervals = tz-&gt;transitions-&gt;len;
1880 
1881   /* find the interval containing *time UTC
1882    * TODO: this could be binary searched (or better) */
1883   for (i = 0; i &lt;= intervals; i++)
1884     if (*time_ &lt;= interval_end (tz, i))
1885       break;
1886 
1887   g_assert (interval_start (tz, i) &lt;= *time_ &amp;&amp; *time_ &lt;= interval_end (tz, i));
1888 
1889   if (type != G_TIME_TYPE_UNIVERSAL)
1890     {
1891       if (*time_ &lt; interval_local_start (tz, i))
1892         /* if time came before the start of this interval... */
1893         {
1894           i--;
</pre>
<hr />
<pre>
1896           /* if it&#39;s not in the previous interval... */
1897           if (*time_ &gt; interval_local_end (tz, i))
1898             {
1899               /* it doesn&#39;t exist.  fast-forward it. */
1900               i++;
1901               *time_ = interval_local_start (tz, i);
1902             }
1903         }
1904 
1905       else if (*time_ &gt; interval_local_end (tz, i))
1906         /* if time came after the end of this interval... */
1907         {
1908           i++;
1909 
1910           /* if it&#39;s not in the next interval... */
1911           if (*time_ &lt; interval_local_start (tz, i))
1912             /* it doesn&#39;t exist.  fast-forward it. */
1913             *time_ = interval_local_start (tz, i);
1914         }
1915 
<span class="line-modified">1916       else</span>


1917         {
<span class="line-modified">1918           interval_is_dst = interval_isdst (tz, i);</span>
<span class="line-modified">1919           if ((interval_is_dst &amp;&amp; type != G_TIME_TYPE_DAYLIGHT) ||</span>
<span class="line-modified">1920               (!interval_is_dst &amp;&amp; type == G_TIME_TYPE_DAYLIGHT))</span>
<span class="line-modified">1921             {</span>
<span class="line-modified">1922               /* it&#39;s in this interval, but dst flag doesn&#39;t match.</span>
<span class="line-modified">1923                * check neighbours for a better fit. */</span>
<span class="line-added">1924               if (i &amp;&amp; *time_ &lt;= interval_local_end (tz, i - 1))</span>
<span class="line-added">1925                 i--;</span>
<span class="line-added">1926 </span>
<span class="line-added">1927               else if (i &lt; intervals &amp;&amp;</span>
<span class="line-added">1928                        *time_ &gt;= interval_local_start (tz, i + 1))</span>
<span class="line-added">1929                 i++;</span>
<span class="line-added">1930             }</span>
1931         }
1932     }
1933 
1934   return i;
1935 }
1936 
1937 /**
1938  * g_time_zone_find_interval:
1939  * @tz: a #GTimeZone
1940  * @type: the #GTimeType of @time_
1941  * @time_: a number of seconds since January 1, 1970
1942  *
<span class="line-modified">1943  * Finds an interval within @tz that corresponds to the given @time_.</span>
1944  * The meaning of @time_ depends on @type.
1945  *
1946  * If @type is %G_TIME_TYPE_UNIVERSAL then this function will always
1947  * succeed (since universal time is monotonic and continuous).
1948  *
1949  * Otherwise @time_ is treated as local time.  The distinction between
1950  * %G_TIME_TYPE_STANDARD and %G_TIME_TYPE_DAYLIGHT is ignored except in
1951  * the case that the given @time_ is ambiguous.  In Toronto, for example,
1952  * 01:30 on November 7th 2010 occurred twice (once inside of daylight
1953  * savings time and the next, an hour later, outside of daylight savings
1954  * time).  In this case, the different value of @type would result in a
1955  * different interval being returned.
1956  *
1957  * It is still possible for this function to fail.  In Toronto, for
1958  * example, 02:00 on March 14th 2010 does not exist (due to the leap
1959  * forward to begin daylight savings time).  -1 is returned in that
1960  * case.
1961  *
1962  * Returns: the interval containing @time_, or -1 in case of failure
1963  *
1964  * Since: 2.26
1965  */
1966 gint
1967 g_time_zone_find_interval (GTimeZone *tz,
1968                            GTimeType  type,
1969                            gint64     time_)
1970 {
<span class="line-modified">1971   guint i, intervals;</span>
<span class="line-modified">1972   gboolean interval_is_dst;</span>
1973 
1974   if (tz-&gt;transitions == NULL)
1975     return 0;
1976   intervals = tz-&gt;transitions-&gt;len;
1977   for (i = 0; i &lt;= intervals; i++)
1978     if (time_ &lt;= interval_end (tz, i))
1979       break;
1980 
1981   if (type == G_TIME_TYPE_UNIVERSAL)
1982     return i;
1983 
1984   if (time_ &lt; interval_local_start (tz, i))
1985     {
1986       if (time_ &gt; interval_local_end (tz, --i))
1987         return -1;
1988     }
1989 
1990   else if (time_ &gt; interval_local_end (tz, i))
1991     {
1992       if (time_ &lt; interval_local_start (tz, ++i))
1993         return -1;
1994     }
1995 
<span class="line-modified">1996   else</span>
1997     {
<span class="line-modified">1998       interval_is_dst = interval_isdst (tz, i);</span>
<span class="line-modified">1999       if  ((interval_is_dst &amp;&amp; type != G_TIME_TYPE_DAYLIGHT) ||</span>
<span class="line-added">2000            (!interval_is_dst &amp;&amp; type == G_TIME_TYPE_DAYLIGHT))</span>
<span class="line-added">2001         {</span>
<span class="line-added">2002           if (i &amp;&amp; time_ &lt;= interval_local_end (tz, i - 1))</span>
<span class="line-added">2003             i--;</span>
2004 
<span class="line-modified">2005           else if (i &lt; intervals &amp;&amp; time_ &gt;= interval_local_start (tz, i + 1))</span>
<span class="line-modified">2006             i++;</span>
<span class="line-added">2007         }</span>
2008     }
2009 
2010   return i;
2011 }
2012 
2013 /* Public API accessors {{{1 */
2014 
2015 /**
2016  * g_time_zone_get_abbreviation:
2017  * @tz: a #GTimeZone
2018  * @interval: an interval within the timezone
2019  *
2020  * Determines the time zone abbreviation to be used during a particular
2021  * @interval of time in the time zone @tz.
2022  *
2023  * For example, in Toronto this is currently &quot;EST&quot; during the winter
2024  * months and &quot;EDT&quot; during the summer months when daylight savings time
2025  * is in effect.
2026  *
2027  * Returns: the time zone abbreviation, which belongs to @tz
</pre>
</td>
</tr>
</table>
<center><a href="gtimer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gtimezone.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>