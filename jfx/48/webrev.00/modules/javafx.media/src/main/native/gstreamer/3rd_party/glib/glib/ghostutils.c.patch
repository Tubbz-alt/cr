diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/ghostutils.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/ghostutils.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/ghostutils.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/ghostutils.c
@@ -103,41 +103,41 @@
       delta /= PUNYCODE_BASE - PUNYCODE_TMIN;
       k += PUNYCODE_BASE;
     }
 
   return k + ((PUNYCODE_BASE - PUNYCODE_TMIN + 1) * delta /
-          (delta + PUNYCODE_SKEW));
+        (delta + PUNYCODE_SKEW));
 }
 
 /* Punycode encoder, RFC 3492 section 6.3. The algorithm is
  * sufficiently bizarre that it's not really worth trying to explain
  * here.
  */
 static gboolean
 punycode_encode (const gchar *input_utf8,
                  gsize        input_utf8_length,
-         GString     *output)
+     GString     *output)
 {
   guint delta, handled_chars, num_basic_chars, bias, j, q, k, t, digit;
   gunichar n, m, *input;
   glong input_length;
   gboolean success = FALSE;
 
   /* Convert from UTF-8 to Unicode code points */
   input = g_utf8_to_ucs4 (input_utf8, input_utf8_length, NULL,
-              &input_length, NULL);
+        &input_length, NULL);
   if (!input)
     return FALSE;
 
   /* Copy basic chars */
   for (j = num_basic_chars = 0; j < input_length; j++)
     {
       if (PUNYCODE_IS_BASIC (input[j]))
-    {
-      g_string_append_c (output, g_ascii_tolower (input[j]));
-      num_basic_chars++;
-    }
+  {
+    g_string_append_c (output, g_ascii_tolower (input[j]));
+    num_basic_chars++;
+  }
     }
   if (num_basic_chars)
     g_string_append_c (output, '-');
 
   handled_chars = num_basic_chars;
@@ -148,52 +148,52 @@
   n = PUNYCODE_INITIAL_N;
   while (handled_chars < input_length)
     {
       /* let m = the minimum {non-basic} code point >= n in the input */
       for (m = G_MAXUINT, j = 0; j < input_length; j++)
-    {
-      if (input[j] >= n && input[j] < m)
-        m = input[j];
-    }
+  {
+    if (input[j] >= n && input[j] < m)
+      m = input[j];
+  }
 
       if (m - n > (G_MAXUINT - delta) / (handled_chars + 1))
-    goto fail;
+  goto fail;
       delta += (m - n) * (handled_chars + 1);
       n = m;
 
       for (j = 0; j < input_length; j++)
+  {
+    if (input[j] < n)
+      {
+        if (++delta == 0)
+    goto fail;
+      }
+    else if (input[j] == n)
+      {
+        q = delta;
+        for (k = PUNYCODE_BASE; ; k += PUNYCODE_BASE)
     {
-      if (input[j] < n)
-        {
-          if (++delta == 0)
-        goto fail;
-        }
-      else if (input[j] == n)
-        {
-          q = delta;
-          for (k = PUNYCODE_BASE; ; k += PUNYCODE_BASE)
-        {
-          if (k <= bias)
-            t = PUNYCODE_TMIN;
-          else if (k >= bias + PUNYCODE_TMAX)
-            t = PUNYCODE_TMAX;
-          else
-            t = k - bias;
-          if (q < t)
-            break;
-          digit = t + (q - t) % (PUNYCODE_BASE - t);
-          g_string_append_c (output, encode_digit (digit));
-          q = (q - t) / (PUNYCODE_BASE - t);
-        }
-
-          g_string_append_c (output, encode_digit (q));
-          bias = adapt (delta, handled_chars + 1, handled_chars == num_basic_chars);
-          delta = 0;
-          handled_chars++;
-        }
+      if (k <= bias)
+        t = PUNYCODE_TMIN;
+      else if (k >= bias + PUNYCODE_TMAX)
+        t = PUNYCODE_TMAX;
+      else
+        t = k - bias;
+      if (q < t)
+        break;
+      digit = t + (q - t) % (PUNYCODE_BASE - t);
+      g_string_append_c (output, encode_digit (digit));
+      q = (q - t) / (PUNYCODE_BASE - t);
     }
 
+        g_string_append_c (output, encode_digit (q));
+        bias = adapt (delta, handled_chars + 1, handled_chars == num_basic_chars);
+        delta = 0;
+        handled_chars++;
+      }
+  }
+
       delta++;
       n++;
     }
 
   success = TRUE;
@@ -219,19 +219,19 @@
 
   for (p = str; len == -1 ? *p : p < str + len; p = g_utf8_next_char (p))
     {
       ch = g_utf8_get_char (p);
       if (idna_is_junk (ch))
-    {
-      if (!cleaned)
-        {
-          cleaned = g_string_new (NULL);
-          g_string_append_len (cleaned, str, p - str);
-        }
-    }
+  {
+    if (!cleaned)
+      {
+        cleaned = g_string_new (NULL);
+        g_string_append_len (cleaned, str, p - str);
+      }
+  }
       else if (cleaned)
-    g_string_append_unichar (cleaned, ch);
+  g_string_append_unichar (cleaned, ch);
     }
 
   if (cleaned)
     return g_string_free (cleaned, FALSE);
   else
@@ -245,11 +245,11 @@
   const gchar *p;
 
   for (p = str; len == -1 ? *p : p < str + len; p = g_utf8_next_char (p))
     {
       if (g_unichar_isupper (g_utf8_get_char (p)))
-    return TRUE;
+  return TRUE;
     }
   return FALSE;
 }
 
 static inline gboolean
@@ -259,11 +259,11 @@
   const gchar *p;
 
   for (p = str; len == -1 ? *p : p < str + len; p++)
     {
       if ((guchar)*p > 0x80)
-    return TRUE;
+  return TRUE;
     }
   return FALSE;
 }
 
 /* RFC 3454, Appendix C. ish. */
@@ -282,17 +282,17 @@
     case G_UNICODE_SPACE_SEPARATOR:
       return TRUE;
 
     case G_UNICODE_OTHER_SYMBOL:
       if (ch == 0xFFFC || ch == 0xFFFD ||
-      (ch >= 0x2FF0 && ch <= 0x2FFB))
-    return TRUE;
+    (ch >= 0x2FF0 && ch <= 0x2FFB))
+  return TRUE;
       return FALSE;
 
     case G_UNICODE_NON_SPACING_MARK:
       if (ch == 0x0340 || ch == 0x0341)
-    return TRUE;
+  return TRUE;
       return FALSE;
 
     default:
       return FALSE;
     }
@@ -368,15 +368,15 @@
 
   /* Check for prohibited characters */
   for (p = name; *p; p = g_utf8_next_char (p))
     {
       if (idna_is_prohibited (g_utf8_get_char (p)))
-    {
-      name = NULL;
+  {
+    name = NULL;
           g_free (tmp);
-      goto done;
-    }
+    goto done;
+  }
     }
 
   /* FIXME: We're supposed to verify certain constraints on bidi
    * characters, but glib does not appear to have that information.
    */
@@ -434,31 +434,31 @@
 
   do
     {
       unicode = FALSE;
       for (p = label; *p && !idna_is_dot (p); p++)
-    {
-      if ((guchar)*p > 0x80)
-        unicode = TRUE;
-    }
+  {
+    if ((guchar)*p > 0x80)
+      unicode = TRUE;
+  }
 
       oldlen = out->len;
       llen = p - label;
       if (unicode)
-    {
+  {
           if (!strncmp (label, IDNA_ACE_PREFIX, IDNA_ACE_PREFIX_LEN))
             goto fail;
 
-      g_string_append (out, IDNA_ACE_PREFIX);
-      if (!punycode_encode (label, llen, out))
-        goto fail;
-    }
+    g_string_append (out, IDNA_ACE_PREFIX);
+    if (!punycode_encode (label, llen, out))
+      goto fail;
+  }
       else
         g_string_append_len (out, label, llen);
 
       if (out->len - oldlen > 63)
-    goto fail;
+  goto fail;
 
       label += llen;
       if (*label)
         label = g_utf8_next_char (label);
       if (*label)
@@ -519,55 +519,55 @@
   while (split > input && *split != '-')
     split--;
   if (split > input)
     {
       output_chars = g_array_sized_new (FALSE, FALSE, sizeof (gunichar),
-                    split - input);
+          split - input);
       input_length -= (split - input) + 1;
       while (input < split)
-    {
-      gunichar ch = (gunichar)*input++;
-      if (!PUNYCODE_IS_BASIC (ch))
-        goto fail;
-      g_array_append_val (output_chars, ch);
-    }
+  {
+    gunichar ch = (gunichar)*input++;
+    if (!PUNYCODE_IS_BASIC (ch))
+      goto fail;
+    g_array_append_val (output_chars, ch);
+  }
       input++;
     }
   else
     output_chars = g_array_new (FALSE, FALSE, sizeof (gunichar));
 
   while (input_length)
     {
       oldi = i;
       w = 1;
       for (k = PUNYCODE_BASE; ; k += PUNYCODE_BASE)
-    {
-      if (!input_length--)
-        goto fail;
-      digit = decode_digit (*input++);
-      if (digit >= PUNYCODE_BASE)
-        goto fail;
-      if (digit > (G_MAXUINT - i) / w)
-        goto fail;
-      i += digit * w;
-      if (k <= bias)
-        t = PUNYCODE_TMIN;
-      else if (k >= bias + PUNYCODE_TMAX)
-        t = PUNYCODE_TMAX;
-      else
-        t = k - bias;
-      if (digit < t)
-        break;
-      if (w > G_MAXUINT / (PUNYCODE_BASE - t))
-        goto fail;
-      w *= (PUNYCODE_BASE - t);
-    }
+  {
+    if (!input_length--)
+      goto fail;
+    digit = decode_digit (*input++);
+    if (digit >= PUNYCODE_BASE)
+      goto fail;
+    if (digit > (G_MAXUINT - i) / w)
+      goto fail;
+    i += digit * w;
+    if (k <= bias)
+      t = PUNYCODE_TMIN;
+    else if (k >= bias + PUNYCODE_TMAX)
+      t = PUNYCODE_TMAX;
+    else
+      t = k - bias;
+    if (digit < t)
+      break;
+    if (w > G_MAXUINT / (PUNYCODE_BASE - t))
+      goto fail;
+    w *= (PUNYCODE_BASE - t);
+  }
 
       bias = adapt (i - oldi, output_chars->len + 1, oldi == 0);
 
       if (i / (output_chars->len + 1) > G_MAXUINT - n)
-    goto fail;
+  goto fail;
       n += i / (output_chars->len + 1);
       i %= (output_chars->len + 1);
 
       g_array_insert_val (output_chars, i++, n);
     }
@@ -609,19 +609,19 @@
 
   do
     {
       llen = idna_end_of_label (hostname) - hostname;
       if (!g_ascii_strncasecmp (hostname, IDNA_ACE_PREFIX, IDNA_ACE_PREFIX_LEN))
-    {
-      hostname += IDNA_ACE_PREFIX_LEN;
-      llen -= IDNA_ACE_PREFIX_LEN;
-      if (!punycode_decode (hostname, llen, out))
-        {
-          g_string_free (out, TRUE);
-          return NULL;
-        }
-    }
+  {
+    hostname += IDNA_ACE_PREFIX_LEN;
+    llen -= IDNA_ACE_PREFIX_LEN;
+    if (!punycode_decode (hostname, llen, out))
+      {
+        g_string_free (out, TRUE);
+        return NULL;
+      }
+  }
       else
         {
           gboolean unicode;
           gchar *canonicalized = nameprep (hostname, llen, &unicode);
 
@@ -667,16 +667,16 @@
 g_hostname_is_ascii_encoded (const gchar *hostname)
 {
   while (1)
     {
       if (!g_ascii_strncasecmp (hostname, IDNA_ACE_PREFIX, IDNA_ACE_PREFIX_LEN))
-    return TRUE;
+  return TRUE;
       hostname = idna_end_of_label (hostname);
       if (*hostname)
         hostname = g_utf8_next_char (hostname);
       if (!*hostname)
-    return FALSE;
+  return FALSE;
     }
 }
 
 /**
  * g_hostname_is_ip_address:
@@ -784,15 +784,15 @@
         end = p + 1;
       else
         {
           for (end = p; g_ascii_isdigit (*end); end++)
             {
-            octet = 10 * octet + (*end - '0');
+              octet = 10 * octet + (*end - '0');
 
               if (octet > 255)
                 break;
-        }
+            }
         }
       if (end == p || end > p + 3 || octet > 255)
         return FALSE;
 
       p = end;
