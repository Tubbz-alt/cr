<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gkeyfile.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="giowin32.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gkeyfile.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gkeyfile.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 521 {
 522   const gchar *name;  /* NULL for above first group (which will be comments) */
 523 
 524   GKeyFileKeyValuePair *comment; /* Special comment that is stuck to the top of a group */
 525 
 526   GList *key_value_pairs;
 527 
 528   /* Used in parallel with key_value_pairs for
 529    * increased lookup performance
 530    */
 531   GHashTable *lookup_map;
 532 };
 533 
 534 struct _GKeyFileKeyValuePair
 535 {
 536   gchar *key;  /* NULL for comments */
 537   gchar *value;
 538 };
 539 
 540 static gint                  find_file_in_data_dirs            (const gchar            *file,
<span class="line-modified"> 541                                 const gchar           **data_dirs,</span>
<span class="line-modified"> 542                                 gchar                 **output_file,</span>
<span class="line-modified"> 543                                 GError                **error);</span>
 544 static gboolean              g_key_file_load_from_fd           (GKeyFile               *key_file,
<span class="line-modified"> 545                                 gint                    fd,</span>
<span class="line-modified"> 546                                 GKeyFileFlags           flags,</span>
<span class="line-modified"> 547                                 GError                **error);</span>
 548 static GList                *g_key_file_lookup_group_node      (GKeyFile               *key_file,
<span class="line-modified"> 549                                                     const gchar            *group_name);</span>
 550 static GKeyFileGroup        *g_key_file_lookup_group           (GKeyFile               *key_file,
<span class="line-modified"> 551                                 const gchar            *group_name);</span>
 552 
 553 static GList                *g_key_file_lookup_key_value_pair_node  (GKeyFile       *key_file,
<span class="line-modified"> 554                                                          GKeyFileGroup  *group,</span>
 555                                                                      const gchar    *key);
 556 static GKeyFileKeyValuePair *g_key_file_lookup_key_value_pair       (GKeyFile       *key_file,
 557                                                                      GKeyFileGroup  *group,
 558                                                                      const gchar    *key);
 559 
 560 static void                  g_key_file_remove_group_node          (GKeyFile      *key_file,
<span class="line-modified"> 561                                     GList         *group_node);</span>
 562 static void                  g_key_file_remove_key_value_pair_node (GKeyFile      *key_file,
 563                                                                     GKeyFileGroup *group,
 564                                                                     GList         *pair_node);
 565 
 566 static void                  g_key_file_add_key_value_pair     (GKeyFile               *key_file,
 567                                                                 GKeyFileGroup          *group,
 568                                                                 GKeyFileKeyValuePair   *pair);
 569 static void                  g_key_file_add_key                (GKeyFile               *key_file,
<span class="line-modified"> 570                                 GKeyFileGroup          *group,</span>
<span class="line-modified"> 571                                 const gchar            *key,</span>
<span class="line-modified"> 572                                 const gchar            *value);</span>
 573 static void                  g_key_file_add_group              (GKeyFile               *key_file,
<span class="line-modified"> 574                                 const gchar            *group_name);</span>
 575 static gboolean              g_key_file_is_group_name          (const gchar *name);
 576 static gboolean              g_key_file_is_key_name            (const gchar *name);
 577 static void                  g_key_file_key_value_pair_free    (GKeyFileKeyValuePair   *pair);
 578 static gboolean              g_key_file_line_is_comment        (const gchar            *line);
 579 static gboolean              g_key_file_line_is_group          (const gchar            *line);
 580 static gboolean              g_key_file_line_is_key_value_pair (const gchar            *line);
 581 static gchar                *g_key_file_parse_value_as_string  (GKeyFile               *key_file,
<span class="line-modified"> 582                                 const gchar            *value,</span>
<span class="line-modified"> 583                                 GSList                **separators,</span>
<span class="line-modified"> 584                                 GError                **error);</span>
 585 static gchar                *g_key_file_parse_string_as_value  (GKeyFile               *key_file,
<span class="line-modified"> 586                                 const gchar            *string,</span>
<span class="line-modified"> 587                                 gboolean                escape_separator);</span>
 588 static gint                  g_key_file_parse_value_as_integer (GKeyFile               *key_file,
<span class="line-modified"> 589                                 const gchar            *value,</span>
<span class="line-modified"> 590                                 GError                **error);</span>
 591 static gchar                *g_key_file_parse_integer_as_value (GKeyFile               *key_file,
<span class="line-modified"> 592                                 gint                    value);</span>
 593 static gdouble               g_key_file_parse_value_as_double  (GKeyFile               *key_file,
 594                                                                 const gchar            *value,
 595                                                                 GError                **error);
 596 static gboolean              g_key_file_parse_value_as_boolean (GKeyFile               *key_file,
<span class="line-modified"> 597                                 const gchar            *value,</span>
<span class="line-modified"> 598                                 GError                **error);</span>
 599 static gchar                *g_key_file_parse_boolean_as_value (GKeyFile               *key_file,
<span class="line-modified"> 600                                 gboolean                value);</span>
 601 static gchar                *g_key_file_parse_value_as_comment (GKeyFile               *key_file,
<span class="line-modified"> 602                                                                 const gchar            *value);</span>

 603 static gchar                *g_key_file_parse_comment_as_value (GKeyFile               *key_file,
 604                                                                 const gchar            *comment);
 605 static void                  g_key_file_parse_key_value_pair   (GKeyFile               *key_file,
<span class="line-modified"> 606                                 const gchar            *line,</span>
<span class="line-modified"> 607                                 gsize                   length,</span>
<span class="line-modified"> 608                                 GError                **error);</span>
 609 static void                  g_key_file_parse_comment          (GKeyFile               *key_file,
<span class="line-modified"> 610                                 const gchar            *line,</span>
<span class="line-modified"> 611                                 gsize                   length,</span>
<span class="line-modified"> 612                                 GError                **error);</span>
 613 static void                  g_key_file_parse_group            (GKeyFile               *key_file,
<span class="line-modified"> 614                                 const gchar            *line,</span>
<span class="line-modified"> 615                                 gsize                   length,</span>
<span class="line-modified"> 616                                 GError                **error);</span>
 617 static gchar                *key_get_locale                    (const gchar            *key);
 618 static void                  g_key_file_parse_data             (GKeyFile               *key_file,
<span class="line-modified"> 619                                 const gchar            *data,</span>
<span class="line-modified"> 620                                 gsize                   length,</span>
<span class="line-modified"> 621                                 GError                **error);</span>
 622 static void                  g_key_file_flush_parse_buffer     (GKeyFile               *key_file,
<span class="line-modified"> 623                                 GError                **error);</span>
 624 
 625 G_DEFINE_QUARK (g-key-file-error-quark, g_key_file_error)
 626 
 627 static void
 628 g_key_file_init (GKeyFile *key_file)
 629 {
 630   key_file-&gt;current_group = g_slice_new0 (GKeyFileGroup);
 631   key_file-&gt;groups = g_list_prepend (NULL, key_file-&gt;current_group);
 632   key_file-&gt;group_hash = g_hash_table_new (g_str_hash, g_str_equal);
 633   key_file-&gt;start_group = NULL;
 634   key_file-&gt;parse_buffer = g_string_sized_new (128);
 635   key_file-&gt;list_separator = &#39;;&#39;;
 636   key_file-&gt;flags = 0;
 637   key_file-&gt;locales = g_strdupv ((gchar **)g_get_language_names ());
 638 }
 639 
 640 static void
 641 g_key_file_clear (GKeyFile *key_file)
 642 {
 643   GList *tmp, *group_node;
</pre>
<hr />
<pre>
 692   key_file = g_slice_new0 (GKeyFile);
 693   key_file-&gt;ref_count = 1;
 694   g_key_file_init (key_file);
 695 
 696   return key_file;
 697 }
 698 
 699 /**
 700  * g_key_file_set_list_separator:
 701  * @key_file: a #GKeyFile
 702  * @separator: the separator
 703  *
 704  * Sets the character which is used to separate
 705  * values in lists. Typically &#39;;&#39; or &#39;,&#39; are used
 706  * as separators. The default list separator is &#39;;&#39;.
 707  *
 708  * Since: 2.6
 709  */
 710 void
 711 g_key_file_set_list_separator (GKeyFile *key_file,
<span class="line-modified"> 712                    gchar     separator)</span>
 713 {
 714   g_return_if_fail (key_file != NULL);
 715 
 716   key_file-&gt;list_separator = separator;
 717 }
 718 
 719 
 720 /* Iterates through all the directories in *dirs trying to
 721  * open file.  When it successfully locates and opens a file it
 722  * returns the file descriptor to the open file.  It also
 723  * outputs the absolute path of the file in output_file.
 724  */
 725 static gint
 726 find_file_in_data_dirs (const gchar   *file,
 727                         const gchar  **dirs,
 728                         gchar        **output_file,
 729                         GError       **error)
 730 {
 731   const gchar **data_dirs, *data_dir;
 732   gchar *path;
</pre>
<hr />
<pre>
 782     }
 783 
 784   if (fd == -1)
 785     {
 786       g_set_error_literal (error, G_KEY_FILE_ERROR,
 787                            G_KEY_FILE_ERROR_NOT_FOUND,
 788                            _(&quot;Valid key file could not be &quot;
 789                              &quot;found in search dirs&quot;));
 790     }
 791 
 792   if (output_file != NULL &amp;&amp; fd != -1)
 793     *output_file = g_strdup (path);
 794 
 795   g_free (path);
 796 
 797   return fd;
 798 }
 799 
 800 static gboolean
 801 g_key_file_load_from_fd (GKeyFile       *key_file,
<span class="line-modified"> 802              gint            fd,</span>
<span class="line-modified"> 803              GKeyFileFlags   flags,</span>
<span class="line-modified"> 804              GError        **error)</span>
 805 {
 806   GError *key_file_error = NULL;
 807   gssize bytes_read;
 808   struct stat stat_buf;
 809   gchar read_buf[4096];
 810   gchar list_separator;
 811 
 812   if (fstat (fd, &amp;stat_buf) &lt; 0)
 813     {
 814       int errsv = errno;
 815       g_set_error_literal (error, G_FILE_ERROR,
 816                            g_file_error_from_errno (errsv),
 817                            g_strerror (errsv));
 818       return FALSE;
 819     }
 820 
 821   if (!S_ISREG (stat_buf.st_mode))
 822     {
 823       g_set_error_literal (error, G_KEY_FILE_ERROR,
 824                            G_KEY_FILE_ERROR_PARSE,
</pre>
<hr />
<pre>
 837       int errsv;
 838 
 839       bytes_read = read (fd, read_buf, 4096);
 840       errsv = errno;
 841 
 842       if (bytes_read == 0)  /* End of File */
 843         break;
 844 
 845       if (bytes_read &lt; 0)
 846         {
 847           if (errsv == EINTR || errsv == EAGAIN)
 848             continue;
 849 
 850           g_set_error_literal (error, G_FILE_ERROR,
 851                                g_file_error_from_errno (errsv),
 852                                g_strerror (errsv));
 853           return FALSE;
 854         }
 855 
 856       g_key_file_parse_data (key_file,
<span class="line-modified"> 857                  read_buf, bytes_read,</span>
<span class="line-modified"> 858                  &amp;key_file_error);</span>
 859     }
 860   while (!key_file_error);
 861 
 862   if (key_file_error)
 863     {
 864       g_propagate_error (error, key_file_error);
 865       return FALSE;
 866     }
 867 
 868   g_key_file_flush_parse_buffer (key_file, &amp;key_file_error);
 869 
 870   if (key_file_error)
 871     {
 872       g_propagate_error (error, key_file_error);
 873       return FALSE;
 874     }
 875 
 876   return TRUE;
 877 }
 878 
</pre>
<hr />
<pre>
 881  * @key_file: an empty #GKeyFile struct
 882  * @file: (type filename): the path of a filename to load, in the GLib filename encoding
 883  * @flags: flags from #GKeyFileFlags
 884  * @error: return location for a #GError, or %NULL
 885  *
 886  * Loads a key file into an empty #GKeyFile structure.
 887  *
 888  * If the OS returns an error when opening or reading the file, a
 889  * %G_FILE_ERROR is returned. If there is a problem parsing the file, a
 890  * %G_KEY_FILE_ERROR is returned.
 891  *
 892  * This function will never return a %G_KEY_FILE_ERROR_NOT_FOUND error. If the
 893  * @file is not found, %G_FILE_ERROR_NOENT is returned.
 894  *
 895  * Returns: %TRUE if a key file could be loaded, %FALSE otherwise
 896  *
 897  * Since: 2.6
 898  **/
 899 gboolean
 900 g_key_file_load_from_file (GKeyFile       *key_file,
<span class="line-modified"> 901                const gchar    *file,</span>
<span class="line-modified"> 902                GKeyFileFlags   flags,</span>
<span class="line-modified"> 903                GError        **error)</span>
 904 {
 905   GError *key_file_error = NULL;
 906   gint fd;
 907   int errsv;
 908 
 909   g_return_val_if_fail (key_file != NULL, FALSE);
 910   g_return_val_if_fail (file != NULL, FALSE);
 911 
 912   fd = g_open (file, O_RDONLY, 0);
 913   errsv = errno;
 914 
 915   if (fd == -1)
 916     {
 917       g_set_error_literal (error, G_FILE_ERROR,
 918                            g_file_error_from_errno (errsv),
 919                            g_strerror (errsv));
 920       return FALSE;
 921     }
 922 
 923   g_key_file_load_from_fd (key_file, fd, flags, &amp;key_file_error);
</pre>
<hr />
<pre>
 932   return TRUE;
 933 }
 934 
 935 /**
 936  * g_key_file_load_from_data:
 937  * @key_file: an empty #GKeyFile struct
 938  * @data: key file loaded in memory
 939  * @length: the length of @data in bytes (or (gsize)-1 if data is nul-terminated)
 940  * @flags: flags from #GKeyFileFlags
 941  * @error: return location for a #GError, or %NULL
 942  *
 943  * Loads a key file from memory into an empty #GKeyFile structure.
 944  * If the object cannot be created then %error is set to a #GKeyFileError.
 945  *
 946  * Returns: %TRUE if a key file could be loaded, %FALSE otherwise
 947  *
 948  * Since: 2.6
 949  **/
 950 gboolean
 951 g_key_file_load_from_data (GKeyFile       *key_file,
<span class="line-modified"> 952                const gchar    *data,</span>
<span class="line-modified"> 953                gsize           length,</span>
<span class="line-modified"> 954                GKeyFileFlags   flags,</span>
<span class="line-modified"> 955                GError        **error)</span>
 956 {
 957   GError *key_file_error = NULL;
 958   gchar list_separator;
 959 
 960   g_return_val_if_fail (key_file != NULL, FALSE);
 961   g_return_val_if_fail (data != NULL || length == 0, FALSE);
 962 
 963   if (length == (gsize)-1)
 964     length = strlen (data);
 965 
 966   list_separator = key_file-&gt;list_separator;
 967   g_key_file_clear (key_file);
 968   g_key_file_init (key_file);
 969   key_file-&gt;list_separator = list_separator;
 970   key_file-&gt;flags = flags;
 971 
 972   g_key_file_parse_data (key_file, data, length, &amp;key_file_error);
 973 
 974   if (key_file_error)
 975     {
</pre>
<hr />
<pre>
1058 
1059   g_return_val_if_fail (key_file != NULL, FALSE);
1060   g_return_val_if_fail (!g_path_is_absolute (file), FALSE);
1061   g_return_val_if_fail (search_dirs != NULL, FALSE);
1062 
1063   found_file = FALSE;
1064   data_dirs = search_dirs;
1065   output_path = NULL;
1066   while (*data_dirs != NULL &amp;&amp; !found_file)
1067     {
1068       g_free (output_path);
1069       output_path = NULL;
1070 
1071       fd = find_file_in_data_dirs (file, data_dirs, &amp;output_path,
1072                                    &amp;key_file_error);
1073 
1074       if (fd == -1)
1075         {
1076           if (key_file_error)
1077             g_propagate_error (error, key_file_error);
<span class="line-modified">1078       break;</span>
1079         }
1080 
1081       found_file = g_key_file_load_from_fd (key_file, fd, flags,
<span class="line-modified">1082                                         &amp;key_file_error);</span>
1083       close (fd);
1084 
1085       if (key_file_error)
1086         {
<span class="line-modified">1087       g_propagate_error (error, key_file_error);</span>
<span class="line-modified">1088       break;</span>
1089         }
1090     }
1091 
1092   if (found_file &amp;&amp; full_path)
1093     *full_path = output_path;
1094   else
1095     g_free (output_path);
1096 
1097   return found_file;
1098 }
1099 
1100 /**
1101  * g_key_file_load_from_data_dirs:
1102  * @key_file: an empty #GKeyFile struct
1103  * @file: (type filename): a relative path to a filename to open and parse
1104  * @full_path: (out) (type filename) (optional): return location for a string containing the full path
1105  *   of the file, or %NULL
1106  * @flags: flags from #GKeyFileFlags
1107  * @error: return location for a #GError, or %NULL
1108  *
1109  * This function looks for a key file named @file in the paths
1110  * returned from g_get_user_data_dir() and g_get_system_data_dirs(),
1111  * loads the file into @key_file and returns the file&#39;s full path in
1112  * @full_path.  If the file could not be loaded then an %error is
1113  * set to either a #GFileError or #GKeyFileError.
1114  *
1115  * Returns: %TRUE if a key file could be loaded, %FALSE othewise
1116  * Since: 2.6
1117  **/
1118 gboolean
1119 g_key_file_load_from_data_dirs (GKeyFile       *key_file,
<span class="line-modified">1120                 const gchar    *file,</span>
<span class="line-modified">1121                 gchar         **full_path,</span>
<span class="line-modified">1122                 GKeyFileFlags   flags,</span>
<span class="line-modified">1123                 GError        **error)</span>
1124 {
1125   gchar **all_data_dirs;
1126   const gchar * user_data_dir;
1127   const gchar * const * system_data_dirs;
1128   gsize i, j;
1129   gboolean found_file;
1130 
1131   g_return_val_if_fail (key_file != NULL, FALSE);
1132   g_return_val_if_fail (!g_path_is_absolute (file), FALSE);
1133 
1134   user_data_dir = g_get_user_data_dir ();
1135   system_data_dirs = g_get_system_data_dirs ();
1136   all_data_dirs = g_new (gchar *, g_strv_length ((gchar **)system_data_dirs) + 2);
1137 
1138   i = 0;
1139   all_data_dirs[i++] = g_strdup (user_data_dir);
1140 
1141   j = 0;
1142   while (system_data_dirs[j] != NULL)
1143     all_data_dirs[i++] = g_strdup (system_data_dirs[j++]);
</pre>
<hr />
<pre>
1207  *
1208  * Since: 2.32
1209  **/
1210 void
1211 g_key_file_unref (GKeyFile *key_file)
1212 {
1213   g_return_if_fail (key_file != NULL);
1214 
1215   if (g_atomic_int_dec_and_test (&amp;key_file-&gt;ref_count))
1216     {
1217       g_key_file_clear (key_file);
1218       g_slice_free (GKeyFile, key_file);
1219     }
1220 }
1221 
1222 /* If G_KEY_FILE_KEEP_TRANSLATIONS is not set, only returns
1223  * true for locales that match those in g_get_language_names().
1224  */
1225 static gboolean
1226 g_key_file_locale_is_interesting (GKeyFile    *key_file,
<span class="line-modified">1227                   const gchar *locale)</span>
1228 {
1229   gsize i;
1230 
1231   if (key_file-&gt;flags &amp; G_KEY_FILE_KEEP_TRANSLATIONS)
1232     return TRUE;
1233 
1234   for (i = 0; key_file-&gt;locales[i] != NULL; i++)
1235     {
1236       if (g_ascii_strcasecmp (key_file-&gt;locales[i], locale) == 0)
<span class="line-modified">1237     return TRUE;</span>
1238     }
1239 
1240   return FALSE;
1241 }
1242 
1243 static void
1244 g_key_file_parse_line (GKeyFile     *key_file,
<span class="line-modified">1245                const gchar  *line,</span>
<span class="line-modified">1246                gsize         length,</span>
<span class="line-modified">1247                GError      **error)</span>
1248 {
1249   GError *parse_error = NULL;
1250   gchar *line_start;
1251 
1252   g_return_if_fail (key_file != NULL);
1253   g_return_if_fail (line != NULL);
1254 
1255   line_start = (gchar *) line;
1256   while (g_ascii_isspace (*line_start))
1257     line_start++;
1258 
1259   if (g_key_file_line_is_comment (line_start))
1260     g_key_file_parse_comment (key_file, line, length, &amp;parse_error);
1261   else if (g_key_file_line_is_group (line_start))
1262     g_key_file_parse_group (key_file, line_start,
<span class="line-modified">1263                 length - (line_start - line),</span>
<span class="line-modified">1264                 &amp;parse_error);</span>
1265   else if (g_key_file_line_is_key_value_pair (line_start))
1266     g_key_file_parse_key_value_pair (key_file, line_start,
<span class="line-modified">1267                      length - (line_start - line),</span>
<span class="line-modified">1268                      &amp;parse_error);</span>
1269   else
1270     {
1271       gchar *line_utf8 = g_utf8_make_valid (line, length);
1272       g_set_error (error, G_KEY_FILE_ERROR,
1273                    G_KEY_FILE_ERROR_PARSE,
1274                    _(&quot;Key file contains line &#39;%s&#39; which is not &quot;
1275                      &quot;a key-value pair, group, or comment&quot;),
1276                    line_utf8);
1277       g_free (line_utf8);
1278 
1279       return;
1280     }
1281 
1282   if (parse_error)
1283     g_propagate_error (error, parse_error);
1284 }
1285 
1286 static void
1287 g_key_file_parse_comment (GKeyFile     *key_file,
<span class="line-modified">1288               const gchar  *line,</span>
<span class="line-modified">1289               gsize         length,</span>
<span class="line-modified">1290               GError      **error)</span>
1291 {
1292   GKeyFileKeyValuePair *pair;
1293 
1294   if (!(key_file-&gt;flags &amp; G_KEY_FILE_KEEP_COMMENTS))
1295     return;
1296 
1297   g_warn_if_fail (key_file-&gt;current_group != NULL);
1298 
1299   pair = g_slice_new (GKeyFileKeyValuePair);
1300 #ifdef GSTREAMER_LITE
1301   if (pair == NULL) {
1302     g_warn_if_fail(pair != NULL);
1303     return;
1304   }
1305 #endif // GSTREAMER_LITE
1306   pair-&gt;key = NULL;
1307   pair-&gt;value = g_strndup (line, length);
1308 
1309   key_file-&gt;current_group-&gt;key_value_pairs =
1310     g_list_prepend (key_file-&gt;current_group-&gt;key_value_pairs, pair);
1311 }
1312 
1313 static void
1314 g_key_file_parse_group (GKeyFile     *key_file,
<span class="line-modified">1315             const gchar  *line,</span>
<span class="line-modified">1316             gsize         length,</span>
<span class="line-modified">1317             GError      **error)</span>
1318 {
1319   gchar *group_name;
1320   const gchar *group_name_start, *group_name_end;
1321 
1322   /* advance past opening &#39;[&#39;
1323    */
1324   group_name_start = line + 1;
1325   group_name_end = line + length - 1;
1326 
1327   while (*group_name_end != &#39;]&#39;)
1328     group_name_end--;
1329 
1330   group_name = g_strndup (group_name_start,
1331                           group_name_end - group_name_start);
1332 
1333   if (!g_key_file_is_group_name (group_name))
1334     {
1335       g_set_error (error, G_KEY_FILE_ERROR,
<span class="line-modified">1336            G_KEY_FILE_ERROR_PARSE,</span>
<span class="line-modified">1337            _(&quot;Invalid group name: %s&quot;), group_name);</span>
1338       g_free (group_name);
1339       return;
1340     }
1341 
1342   g_key_file_add_group (key_file, group_name);
1343   g_free (group_name);
1344 }
1345 
1346 static void
1347 g_key_file_parse_key_value_pair (GKeyFile     *key_file,
<span class="line-modified">1348                  const gchar  *line,</span>
<span class="line-modified">1349                  gsize         length,</span>
<span class="line-modified">1350                  GError      **error)</span>
1351 {
1352   gchar *key, *value, *key_end, *value_start, *locale;
1353   gsize key_len, value_len;
1354 
1355   if (key_file-&gt;current_group == NULL || key_file-&gt;current_group-&gt;name == NULL)
1356     {
1357       g_set_error_literal (error, G_KEY_FILE_ERROR,
1358                            G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
1359                            _(&quot;Key file does not start with a group&quot;));
1360       return;
1361     }
1362 
1363   key_end = value_start = strchr (line, &#39;=&#39;);
1364 
1365   g_warn_if_fail (key_end != NULL);
1366 
1367   key_end--;
1368   value_start++;
1369 
1370   /* Pull the key name from the line (chomping trailing whitespace)
</pre>
<hr />
<pre>
1389 
1390   /* Pull the value from the line (chugging leading whitespace)
1391    */
1392   while (g_ascii_isspace (*value_start))
1393     value_start++;
1394 
1395   value_len = line + length - value_start + 1;
1396 
1397   value = g_strndup (value_start, value_len);
1398 
1399   g_warn_if_fail (key_file-&gt;start_group != NULL);
1400 
1401   if (key_file-&gt;current_group
1402       &amp;&amp; key_file-&gt;current_group-&gt;name
1403       &amp;&amp; strcmp (key_file-&gt;start_group-&gt;name,
1404                  key_file-&gt;current_group-&gt;name) == 0
1405       &amp;&amp; strcmp (key, &quot;Encoding&quot;) == 0)
1406     {
1407       if (g_ascii_strcasecmp (value, &quot;UTF-8&quot;) != 0)
1408         {
<span class="line-modified">1409       gchar *value_utf8 = g_utf8_make_valid (value, value_len);</span>
1410           g_set_error (error, G_KEY_FILE_ERROR,
1411                        G_KEY_FILE_ERROR_UNKNOWN_ENCODING,
1412                        _(&quot;Key file contains unsupported &quot;
<span class="line-modified">1413                          &quot;encoding &#39;%s&#39;&quot;), value_utf8);</span>
<span class="line-modified">1414           g_free (value_utf8);</span>
1415 
1416           g_free (key);
1417           g_free (value);
1418           return;
1419         }
1420     }
1421 
1422   /* Is this key a translation? If so, is it one that we care about?
1423    */
1424   locale = key_get_locale (key);
1425 
1426   if (locale == NULL || g_key_file_locale_is_interesting (key_file, locale))
1427     {
1428       GKeyFileKeyValuePair *pair;
1429 
1430       pair = g_slice_new (GKeyFileKeyValuePair);
1431 #ifdef GSTREAMER_LITE
1432       if (pair == NULL) {
1433         if (locale != NULL) {
1434           g_free (locale);
</pre>
<hr />
<pre>
1451 }
1452 
1453 static gchar *
1454 key_get_locale (const gchar *key)
1455 {
1456   gchar *locale;
1457 
1458   locale = g_strrstr (key, &quot;[&quot;);
1459 
1460   if (locale &amp;&amp; strlen (locale) &lt;= 2)
1461     locale = NULL;
1462 
1463   if (locale)
1464     locale = g_strndup (locale + 1, strlen (locale) - 2);
1465 
1466   return locale;
1467 }
1468 
1469 static void
1470 g_key_file_parse_data (GKeyFile     *key_file,
<span class="line-modified">1471                const gchar  *data,</span>
<span class="line-modified">1472                gsize         length,</span>
<span class="line-modified">1473                GError      **error)</span>
1474 {
1475   GError *parse_error;
1476   gsize i;
1477 
1478   g_return_if_fail (key_file != NULL);
1479   g_return_if_fail (data != NULL || length == 0);
1480 
1481   parse_error = NULL;
1482 
1483   i = 0;
1484   while (i &lt; length)
1485     {
1486       if (data[i] == &#39;\n&#39;)
1487         {
<span class="line-modified">1488       if (key_file-&gt;parse_buffer-&gt;len &gt; 0</span>
<span class="line-modified">1489           &amp;&amp; (key_file-&gt;parse_buffer-&gt;str[key_file-&gt;parse_buffer-&gt;len - 1]</span>
<span class="line-modified">1490           == &#39;\r&#39;))</span>
<span class="line-modified">1491         g_string_erase (key_file-&gt;parse_buffer,</span>
<span class="line-modified">1492                 key_file-&gt;parse_buffer-&gt;len - 1,</span>
<span class="line-modified">1493                 1);</span>
1494 
1495           /* When a newline is encountered flush the parse buffer so that the
1496            * line can be parsed.  Note that completely blank lines won&#39;t show
1497            * up in the parse buffer, so they get parsed directly.
1498            */
1499           if (key_file-&gt;parse_buffer-&gt;len &gt; 0)
1500             g_key_file_flush_parse_buffer (key_file, &amp;parse_error);
1501           else
1502             g_key_file_parse_comment (key_file, &quot;&quot;, 1, &amp;parse_error);
1503 
1504           if (parse_error)
1505             {
1506               g_propagate_error (error, parse_error);
1507               return;
1508             }
1509           i++;
1510         }
1511       else
1512         {
1513           const gchar *start_of_line;
1514           const gchar *end_of_line;
1515           gsize line_length;
1516 
1517           start_of_line = data + i;
1518           end_of_line = memchr (start_of_line, &#39;\n&#39;, length - i);
1519 
1520           if (end_of_line == NULL)
1521             end_of_line = data + length;
1522 
1523           line_length = end_of_line - start_of_line;
1524 
1525           g_string_append_len (key_file-&gt;parse_buffer, start_of_line, line_length);
1526           i += line_length;
1527         }
1528     }
1529 }
1530 
1531 static void
1532 g_key_file_flush_parse_buffer (GKeyFile  *key_file,
<span class="line-modified">1533                    GError   **error)</span>
1534 {
1535   GError *file_error = NULL;
1536 
1537   g_return_if_fail (key_file != NULL);
1538 
1539   file_error = NULL;
1540 
1541   if (key_file-&gt;parse_buffer-&gt;len &gt; 0)
1542     {
1543       g_key_file_parse_line (key_file, key_file-&gt;parse_buffer-&gt;str,
<span class="line-modified">1544                  key_file-&gt;parse_buffer-&gt;len,</span>
<span class="line-modified">1545                  &amp;file_error);</span>
1546       g_string_erase (key_file-&gt;parse_buffer, 0, -1);
1547 
1548       if (file_error)
1549         {
1550           g_propagate_error (error, file_error);
1551           return;
1552         }
1553     }
1554 }
1555 
1556 /**
1557  * g_key_file_to_data:
1558  * @key_file: a #GKeyFile
1559  * @length: (out) (optional): return location for the length of the
1560  *   returned string, or %NULL
1561  * @error: return location for a #GError, or %NULL
1562  *
1563  * This function outputs @key_file as a string.
1564  *
1565  * Note that this function never reports an error,
1566  * so it is safe to pass %NULL as @error.
1567  *
1568  * Returns: a newly allocated string holding
1569  *   the contents of the #GKeyFile
1570  *
1571  * Since: 2.6
1572  **/
1573 gchar *
1574 g_key_file_to_data (GKeyFile  *key_file,
<span class="line-modified">1575             gsize     *length,</span>
<span class="line-modified">1576             GError   **error)</span>
1577 {
1578   GString *data_string;
1579   GList *group_node, *key_file_node;
1580 
1581   g_return_val_if_fail (key_file != NULL, NULL);
1582 
1583   data_string = g_string_new (NULL);
1584 
1585   for (group_node = g_list_last (key_file-&gt;groups);
1586        group_node != NULL;
1587        group_node = group_node-&gt;prev)
1588     {
1589       GKeyFileGroup *group;
1590 
1591       group = (GKeyFileGroup *) group_node-&gt;data;
1592 
1593       /* separate groups by at least an empty line */
1594       if (data_string-&gt;len &gt;= 2 &amp;&amp;
1595           data_string-&gt;str[data_string-&gt;len - 2] != &#39;\n&#39;)
1596         g_string_append_c (data_string, &#39;\n&#39;);
</pre>
<hr />
<pre>
1625 /**
1626  * g_key_file_get_keys:
1627  * @key_file: a #GKeyFile
1628  * @group_name: a group name
1629  * @length: (out) (optional): return location for the number of keys returned, or %NULL
1630  * @error: return location for a #GError, or %NULL
1631  *
1632  * Returns all keys for the group name @group_name.  The array of
1633  * returned keys will be %NULL-terminated, so @length may
1634  * optionally be %NULL. In the event that the @group_name cannot
1635  * be found, %NULL is returned and @error is set to
1636  * #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
1637  *
1638  * Returns: (array zero-terminated=1) (transfer full): a newly-allocated %NULL-terminated array of strings.
1639  *     Use g_strfreev() to free it.
1640  *
1641  * Since: 2.6
1642  **/
1643 gchar **
1644 g_key_file_get_keys (GKeyFile     *key_file,
<span class="line-modified">1645              const gchar  *group_name,</span>
<span class="line-modified">1646              gsize        *length,</span>
<span class="line-modified">1647              GError      **error)</span>
1648 {
1649   GKeyFileGroup *group;
1650   GList *tmp;
1651   gchar **keys;
1652   gsize i, num_keys;
1653 
1654   g_return_val_if_fail (key_file != NULL, NULL);
1655   g_return_val_if_fail (group_name != NULL, NULL);
1656 
1657   group = g_key_file_lookup_group (key_file, group_name);
1658 
1659   if (!group)
1660     {
1661       g_set_error (error, G_KEY_FILE_ERROR,
1662                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
1663                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
1664 #ifdef GSTREAMER_LITE
1665                    group_name ? group_name : &quot;(null)&quot;);
1666 #else // GSTREAMER_LITE
1667                    group_name);
1668 #endif // GSTREAMER_LITE
1669       return NULL;
1670     }
1671 
1672   num_keys = 0;
1673   for (tmp = group-&gt;key_value_pairs; tmp; tmp = tmp-&gt;next)
1674     {
1675       GKeyFileKeyValuePair *pair;
1676 
1677       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
1678 
1679       if (pair-&gt;key)
<span class="line-modified">1680     num_keys++;</span>
1681     }
1682 
1683   keys = g_new (gchar *, num_keys + 1);
1684 
1685   i = num_keys - 1;
1686   for (tmp = group-&gt;key_value_pairs; tmp; tmp = tmp-&gt;next)
1687     {
1688       GKeyFileKeyValuePair *pair;
1689 
1690       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
1691 
1692       if (pair-&gt;key)
<span class="line-modified">1693     {</span>
<span class="line-modified">1694       keys[i] = g_strdup (pair-&gt;key);</span>
<span class="line-modified">1695       i--;</span>
<span class="line-modified">1696     }</span>
1697     }
1698 
1699   keys[num_keys] = NULL;
1700 
1701   if (length)
1702     *length = num_keys;
1703 
1704   return keys;
1705 }
1706 
1707 /**
1708  * g_key_file_get_start_group:
1709  * @key_file: a #GKeyFile
1710  *
1711  * Returns the name of the start group of the file.
1712  *
1713  * Returns: The start group of the key file.
1714  *
1715  * Since: 2.6
1716  **/
</pre>
<hr />
<pre>
1723     return g_strdup (key_file-&gt;start_group-&gt;name);
1724 
1725   return NULL;
1726 }
1727 
1728 /**
1729  * g_key_file_get_groups:
1730  * @key_file: a #GKeyFile
1731  * @length: (out) (optional): return location for the number of returned groups, or %NULL
1732  *
1733  * Returns all groups in the key file loaded with @key_file.
1734  * The array of returned groups will be %NULL-terminated, so
1735  * @length may optionally be %NULL.
1736  *
1737  * Returns: (array zero-terminated=1) (transfer full): a newly-allocated %NULL-terminated array of strings.
1738  *   Use g_strfreev() to free it.
1739  * Since: 2.6
1740  **/
1741 gchar **
1742 g_key_file_get_groups (GKeyFile *key_file,
<span class="line-modified">1743                gsize    *length)</span>
1744 {
1745   GList *group_node;
1746   gchar **groups;
1747   gsize i, num_groups;
1748 
1749   g_return_val_if_fail (key_file != NULL, NULL);
1750 
1751   num_groups = g_list_length (key_file-&gt;groups);
1752 
1753   g_return_val_if_fail (num_groups &gt; 0, NULL);
1754 
1755   group_node = g_list_last (key_file-&gt;groups);
1756 
1757   g_return_val_if_fail (((GKeyFileGroup *) group_node-&gt;data)-&gt;name == NULL, NULL);
1758 
1759   /* Only need num_groups instead of num_groups + 1
1760    * because the first group of the file (last in the
1761    * list) is always the comment group at the top,
1762    * which we skip
1763    */
</pre>
<hr />
<pre>
1802  * @group_name: a group name
1803  * @key: a key
1804  * @error: return location for a #GError, or %NULL
1805  *
1806  * Returns the raw value associated with @key under @group_name.
1807  * Use g_key_file_get_string() to retrieve an unescaped UTF-8 string.
1808  *
1809  * In the event the key cannot be found, %NULL is returned and
1810  * @error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
1811  * event that the @group_name cannot be found, %NULL is returned
1812  * and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
1813  *
1814  *
1815  * Returns: a newly allocated string or %NULL if the specified
1816  *  key cannot be found.
1817  *
1818  * Since: 2.6
1819  **/
1820 gchar *
1821 g_key_file_get_value (GKeyFile     *key_file,
<span class="line-modified">1822               const gchar  *group_name,</span>
<span class="line-modified">1823               const gchar  *key,</span>
<span class="line-modified">1824               GError      **error)</span>
1825 {
1826   GKeyFileGroup *group;
1827   GKeyFileKeyValuePair *pair;
1828   gchar *value = NULL;
1829 
1830   g_return_val_if_fail (key_file != NULL, NULL);
1831   g_return_val_if_fail (group_name != NULL, NULL);
1832   g_return_val_if_fail (key != NULL, NULL);
1833 
1834   group = g_key_file_lookup_group (key_file, group_name);
1835 
1836   if (!group)
1837     {
1838       g_set_error (error, G_KEY_FILE_ERROR,
1839                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
1840                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
1841 #ifdef GSTREAMER_LITE
1842                    group_name ? group_name : &quot;(null)&quot;);
1843 #else // GSTREAMER_LITE
1844                    group_name);
</pre>
<hr />
<pre>
1857 }
1858 
1859 /**
1860  * g_key_file_set_value:
1861  * @key_file: a #GKeyFile
1862  * @group_name: a group name
1863  * @key: a key
1864  * @value: a string
1865  *
1866  * Associates a new value with @key under @group_name.
1867  *
1868  * If @key cannot be found then it is created. If @group_name cannot
1869  * be found then it is created. To set an UTF-8 string which may contain
1870  * characters that need escaping (such as newlines or spaces), use
1871  * g_key_file_set_string().
1872  *
1873  * Since: 2.6
1874  **/
1875 void
1876 g_key_file_set_value (GKeyFile    *key_file,
<span class="line-modified">1877               const gchar *group_name,</span>
<span class="line-modified">1878               const gchar *key,</span>
<span class="line-modified">1879               const gchar *value)</span>
1880 {
1881   GKeyFileGroup *group;
1882   GKeyFileKeyValuePair *pair;
1883 
1884   g_return_if_fail (key_file != NULL);
1885   g_return_if_fail (g_key_file_is_group_name (group_name));
1886   g_return_if_fail (g_key_file_is_key_name (key));
1887   g_return_if_fail (value != NULL);
1888 
1889   group = g_key_file_lookup_group (key_file, group_name);
1890 
1891   if (!group)
1892     {
1893       g_key_file_add_group (key_file, group_name);
1894       group = (GKeyFileGroup *) key_file-&gt;groups-&gt;data;
1895 
1896       g_key_file_add_key (key_file, group, key, value);
1897     }
1898   else
1899     {
</pre>
<hr />
<pre>
1915  * @group_name: a group name
1916  * @key: a key
1917  * @error: return location for a #GError, or %NULL
1918  *
1919  * Returns the string value associated with @key under @group_name.
1920  * Unlike g_key_file_get_value(), this function handles escape sequences
1921  * like \s.
1922  *
1923  * In the event the key cannot be found, %NULL is returned and
1924  * @error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
1925  * event that the @group_name cannot be found, %NULL is returned
1926  * and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
1927  *
1928  * Returns: a newly allocated string or %NULL if the specified
1929  *   key cannot be found.
1930  *
1931  * Since: 2.6
1932  **/
1933 gchar *
1934 g_key_file_get_string (GKeyFile     *key_file,
<span class="line-modified">1935                const gchar  *group_name,</span>
<span class="line-modified">1936                const gchar  *key,</span>
<span class="line-modified">1937                GError      **error)</span>
1938 {
1939   gchar *value, *string_value;
1940   GError *key_file_error;
1941 
1942   g_return_val_if_fail (key_file != NULL, NULL);
1943   g_return_val_if_fail (group_name != NULL, NULL);
1944   g_return_val_if_fail (key != NULL, NULL);
1945 
1946   key_file_error = NULL;
1947 
1948   value = g_key_file_get_value (key_file, group_name, key, &amp;key_file_error);
1949 
1950   if (key_file_error)
1951     {
1952       g_propagate_error (error, key_file_error);
1953       return NULL;
1954     }
1955 
1956   if (!g_utf8_validate (value, -1, NULL))
1957     {
1958       gchar *value_utf8 = g_utf8_make_valid (value, -1);
1959       g_set_error (error, G_KEY_FILE_ERROR,
1960                    G_KEY_FILE_ERROR_UNKNOWN_ENCODING,
1961                    _(&quot;Key file contains key &#39;%s&#39; with value &#39;%s&#39; &quot;
1962                      &quot;which is not UTF-8&quot;), key, value_utf8);
1963       g_free (value_utf8);
1964       g_free (value);
1965 
1966       return NULL;
1967     }
1968 
1969   string_value = g_key_file_parse_value_as_string (key_file, value, NULL,
<span class="line-modified">1970                            &amp;key_file_error);</span>
1971   g_free (value);
1972 
1973   if (key_file_error)
1974     {
1975       if (g_error_matches (key_file_error,
1976                            G_KEY_FILE_ERROR,
1977                            G_KEY_FILE_ERROR_INVALID_VALUE))
1978         {
1979           g_set_error (error, G_KEY_FILE_ERROR,
1980                        G_KEY_FILE_ERROR_INVALID_VALUE,
1981                        _(&quot;Key file contains key &#39;%s&#39; &quot;
1982                          &quot;which has a value that cannot be interpreted.&quot;),
1983                        key);
1984           g_error_free (key_file_error);
1985         }
1986       else
1987         g_propagate_error (error, key_file_error);
1988     }
1989 
1990   return string_value;
1991 }
1992 
1993 /**
1994  * g_key_file_set_string:
1995  * @key_file: a #GKeyFile
1996  * @group_name: a group name
1997  * @key: a key
1998  * @string: a string
1999  *
2000  * Associates a new string value with @key under @group_name.
2001  * If @key cannot be found then it is created.
2002  * If @group_name cannot be found then it is created.
2003  * Unlike g_key_file_set_value(), this function handles characters
2004  * that need escaping, such as newlines.
2005  *
2006  * Since: 2.6
2007  **/
2008 void
2009 g_key_file_set_string (GKeyFile    *key_file,
<span class="line-modified">2010                const gchar *group_name,</span>
<span class="line-modified">2011                const gchar *key,</span>
<span class="line-modified">2012                const gchar *string)</span>
2013 {
2014   gchar *value;
2015 
2016   g_return_if_fail (key_file != NULL);
2017   g_return_if_fail (string != NULL);
2018 
2019   value = g_key_file_parse_string_as_value (key_file, string, FALSE);
2020   g_key_file_set_value (key_file, group_name, key, value);
2021   g_free (value);
2022 }
2023 
2024 /**
2025  * g_key_file_get_string_list:
2026  * @key_file: a #GKeyFile
2027  * @group_name: a group name
2028  * @key: a key
2029  * @length: (out) (optional): return location for the number of returned strings, or %NULL
2030  * @error: return location for a #GError, or %NULL
2031  *
2032  * Returns the values associated with @key under @group_name.
2033  *
2034  * In the event the key cannot be found, %NULL is returned and
2035  * @error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
2036  * event that the @group_name cannot be found, %NULL is returned
2037  * and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
2038  *
2039  * Returns: (array zero-terminated=1 length=length) (element-type utf8) (transfer full):
2040  *  a %NULL-terminated string array or %NULL if the specified
2041  *  key cannot be found. The array should be freed with g_strfreev().
2042  *
2043  * Since: 2.6
2044  **/
2045 gchar **
2046 g_key_file_get_string_list (GKeyFile     *key_file,
<span class="line-modified">2047                 const gchar  *group_name,</span>
<span class="line-modified">2048                 const gchar  *key,</span>
<span class="line-modified">2049                 gsize        *length,</span>
<span class="line-modified">2050                 GError      **error)</span>
2051 {
2052   GError *key_file_error = NULL;
2053   gchar *value, *string_value, **values;
2054   gint i, len;
2055   GSList *p, *pieces = NULL;
2056 
2057   g_return_val_if_fail (key_file != NULL, NULL);
2058   g_return_val_if_fail (group_name != NULL, NULL);
2059   g_return_val_if_fail (key != NULL, NULL);
2060 
2061   if (length)
2062     *length = 0;
2063 
2064   value = g_key_file_get_value (key_file, group_name, key, &amp;key_file_error);
2065 
2066   if (key_file_error)
2067     {
2068       g_propagate_error (error, key_file_error);
2069       return NULL;
2070     }
</pre>
<hr />
<pre>
2119 
2120   return values;
2121 }
2122 
2123 /**
2124  * g_key_file_set_string_list:
2125  * @key_file: a #GKeyFile
2126  * @group_name: a group name
2127  * @key: a key
2128  * @list: (array zero-terminated=1 length=length) (element-type utf8): an array of string values
2129  * @length: number of string values in @list
2130  *
2131  * Associates a list of string values for @key under @group_name.
2132  * If @key cannot be found then it is created.
2133  * If @group_name cannot be found then it is created.
2134  *
2135  * Since: 2.6
2136  **/
2137 void
2138 g_key_file_set_string_list (GKeyFile            *key_file,
<span class="line-modified">2139                 const gchar         *group_name,</span>
<span class="line-modified">2140                 const gchar         *key,</span>
<span class="line-modified">2141                 const gchar * const  list[],</span>
<span class="line-modified">2142                 gsize                length)</span>
2143 {
2144   GString *value_list;
2145   gsize i;
2146 
2147   g_return_if_fail (key_file != NULL);
2148   g_return_if_fail (list != NULL || length == 0);
2149 
2150   value_list = g_string_sized_new (length * 128);
2151 #ifdef GSTREAMER_LITE
2152   if (value_list == NULL) {
2153     return;
2154   }
2155 #endif // GSTREAMER_LITE
2156   for (i = 0; i &lt; length &amp;&amp; list[i] != NULL; i++)
2157     {
2158       gchar *value;
2159 
2160       value = g_key_file_parse_string_as_value (key_file, list[i], TRUE);
2161       g_string_append (value_list, value);
2162       g_string_append_c (value_list, key_file-&gt;list_separator);
</pre>
<hr />
<pre>
2166 
2167   g_key_file_set_value (key_file, group_name, key, value_list-&gt;str);
2168   g_string_free (value_list, TRUE);
2169 }
2170 
2171 /**
2172  * g_key_file_set_locale_string:
2173  * @key_file: a #GKeyFile
2174  * @group_name: a group name
2175  * @key: a key
2176  * @locale: a locale identifier
2177  * @string: a string
2178  *
2179  * Associates a string value for @key and @locale under @group_name.
2180  * If the translation for @key cannot be found then it is created.
2181  *
2182  * Since: 2.6
2183  **/
2184 void
2185 g_key_file_set_locale_string (GKeyFile     *key_file,
<span class="line-modified">2186                   const gchar  *group_name,</span>
<span class="line-modified">2187                   const gchar  *key,</span>
<span class="line-modified">2188                   const gchar  *locale,</span>
<span class="line-modified">2189                   const gchar  *string)</span>
2190 {
2191   gchar *full_key, *value;
2192 
2193   g_return_if_fail (key_file != NULL);
2194   g_return_if_fail (key != NULL);
2195   g_return_if_fail (locale != NULL);
2196   g_return_if_fail (string != NULL);
2197 
2198   value = g_key_file_parse_string_as_value (key_file, string, FALSE);
2199   full_key = g_strdup_printf (&quot;%s[%s]&quot;, key, locale);
2200   g_key_file_set_value (key_file, group_name, full_key, value);
2201   g_free (full_key);
2202   g_free (value);
2203 }
2204 
2205 /**
2206  * g_key_file_get_locale_string:
2207  * @key_file: a #GKeyFile
2208  * @group_name: a group name
2209  * @key: a key
</pre>
<hr />
<pre>
2213  * Returns the value associated with @key under @group_name
2214  * translated in the given @locale if available.  If @locale is
2215  * %NULL then the current locale is assumed.
2216  *
2217  * If @locale is to be non-%NULL, or if the current locale will change over
2218  * the lifetime of the #GKeyFile, it must be loaded with
2219  * %G_KEY_FILE_KEEP_TRANSLATIONS in order to load strings for all locales.
2220  *
2221  * If @key cannot be found then %NULL is returned and @error is set
2222  * to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the value associated
2223  * with @key cannot be interpreted or no suitable translation can
2224  * be found then the untranslated value is returned.
2225  *
2226  * Returns: a newly allocated string or %NULL if the specified
2227  *   key cannot be found.
2228  *
2229  * Since: 2.6
2230  **/
2231 gchar *
2232 g_key_file_get_locale_string (GKeyFile     *key_file,
<span class="line-modified">2233                   const gchar  *group_name,</span>
<span class="line-modified">2234                   const gchar  *key,</span>
<span class="line-modified">2235                   const gchar  *locale,</span>
<span class="line-modified">2236                   GError      **error)</span>
2237 {
2238   gchar *candidate_key, *translated_value;
2239   GError *key_file_error;
2240   gchar **languages;
2241   gboolean free_languages = FALSE;
2242   gint i;
2243 
2244   g_return_val_if_fail (key_file != NULL, NULL);
2245   g_return_val_if_fail (group_name != NULL, NULL);
2246   g_return_val_if_fail (key != NULL, NULL);
2247 
2248   candidate_key = NULL;
2249   translated_value = NULL;
2250   key_file_error = NULL;
2251 
2252   if (locale)
2253     {
2254       languages = g_get_locale_variants (locale);
2255       free_languages = TRUE;
2256     }
2257   else
2258     {
2259       languages = (gchar **) g_get_language_names ();
2260       free_languages = FALSE;
2261     }
2262 
2263   for (i = 0; languages[i]; i++)
2264     {
2265       candidate_key = g_strdup_printf (&quot;%s[%s]&quot;, key, languages[i]);
2266 
2267       translated_value = g_key_file_get_string (key_file,
<span class="line-modified">2268                         group_name,</span>
<span class="line-modified">2269                         candidate_key, NULL);</span>
2270       g_free (candidate_key);
2271 
2272       if (translated_value)
<span class="line-modified">2273     break;</span>
2274 
2275       g_free (translated_value);
2276       translated_value = NULL;
2277    }
2278 
2279   /* Fallback to untranslated key
2280    */
2281   if (!translated_value)
2282     {
2283       translated_value = g_key_file_get_string (key_file, group_name, key,
<span class="line-modified">2284                         &amp;key_file_error);</span>
2285 
2286       if (!translated_value)
2287         g_propagate_error (error, key_file_error);
2288     }
2289 
2290   if (free_languages)
2291     g_strfreev (languages);
2292 
2293   return translated_value;
2294 }
2295 
2296 /**
2297  * g_key_file_get_locale_for_key:
2298  * @key_file: a #GKeyFile
2299  * @group_name: a group name
2300  * @key: a key
2301  * @locale: (nullable): a locale identifier or %NULL
2302  *
2303  * Returns the actual locale which the result of
2304  * g_key_file_get_locale_string() or g_key_file_get_locale_string_list()
</pre>
<hr />
<pre>
2373  *
2374  * If @locale is to be non-%NULL, or if the current locale will change over
2375  * the lifetime of the #GKeyFile, it must be loaded with
2376  * %G_KEY_FILE_KEEP_TRANSLATIONS in order to load strings for all locales.
2377  *
2378  * If @key cannot be found then %NULL is returned and @error is set
2379  * to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the values associated
2380  * with @key cannot be interpreted or no suitable translations
2381  * can be found then the untranslated values are returned. The
2382  * returned array is %NULL-terminated, so @length may optionally
2383  * be %NULL.
2384  *
2385  * Returns: (array zero-terminated=1 length=length) (element-type utf8) (transfer full): a newly allocated %NULL-terminated string array
2386  *   or %NULL if the key isn&#39;t found. The string array should be freed
2387  *   with g_strfreev().
2388  *
2389  * Since: 2.6
2390  **/
2391 gchar **
2392 g_key_file_get_locale_string_list (GKeyFile     *key_file,
<span class="line-modified">2393                    const gchar  *group_name,</span>
<span class="line-modified">2394                    const gchar  *key,</span>
<span class="line-modified">2395                    const gchar  *locale,</span>
<span class="line-modified">2396                    gsize        *length,</span>
<span class="line-modified">2397                    GError      **error)</span>
2398 {
2399   GError *key_file_error;
2400   gchar **values, *value;
2401   char list_separator[2];
2402   gsize len;
2403 
2404   g_return_val_if_fail (key_file != NULL, NULL);
2405   g_return_val_if_fail (group_name != NULL, NULL);
2406   g_return_val_if_fail (key != NULL, NULL);
2407 
2408   key_file_error = NULL;
2409 
2410   value = g_key_file_get_locale_string (key_file, group_name,
<span class="line-modified">2411                     key, locale,</span>
<span class="line-modified">2412                     &amp;key_file_error);</span>
2413 
2414   if (key_file_error)
2415     g_propagate_error (error, key_file_error);
2416 
2417   if (!value)
2418     {
2419       if (length)
2420         *length = 0;
2421       return NULL;
2422     }
2423 
2424   len = strlen (value);
2425   if (value[len - 1] == key_file-&gt;list_separator)
2426     value[len - 1] = &#39;\0&#39;;
2427 
2428   list_separator[0] = key_file-&gt;list_separator;
2429   list_separator[1] = &#39;\0&#39;;
2430   values = g_strsplit (value, list_separator, 0);
2431 
2432   g_free (value);
</pre>
<hr />
<pre>
2437   return values;
2438 }
2439 
2440 /**
2441  * g_key_file_set_locale_string_list:
2442  * @key_file: a #GKeyFile
2443  * @group_name: a group name
2444  * @key: a key
2445  * @locale: a locale identifier
2446  * @list: (array zero-terminated=1 length=length): a %NULL-terminated array of locale string values
2447  * @length: the length of @list
2448  *
2449  * Associates a list of string values for @key and @locale under
2450  * @group_name.  If the translation for @key cannot be found then
2451  * it is created.
2452  *
2453  * Since: 2.6
2454  **/
2455 void
2456 g_key_file_set_locale_string_list (GKeyFile            *key_file,
<span class="line-modified">2457                    const gchar         *group_name,</span>
<span class="line-modified">2458                    const gchar         *key,</span>
<span class="line-modified">2459                    const gchar         *locale,</span>
<span class="line-modified">2460                    const gchar * const  list[],</span>
<span class="line-modified">2461                    gsize                length)</span>
2462 {
2463   GString *value_list;
2464   gchar *full_key;
2465   gsize i;
2466 
2467   g_return_if_fail (key_file != NULL);
2468   g_return_if_fail (key != NULL);
2469   g_return_if_fail (locale != NULL);
2470   g_return_if_fail (length != 0);
2471 
2472   value_list = g_string_sized_new (length * 128);
2473 #ifdef GSTREAMER_LITE
2474   if (value_list == NULL) {
2475     return;
2476   }
2477 #endif // GSTREAMER_LITE
2478   for (i = 0; i &lt; length &amp;&amp; list[i] != NULL; i++)
2479     {
2480       gchar *value;
2481 
</pre>
<hr />
<pre>
2497  * @key_file: a #GKeyFile
2498  * @group_name: a group name
2499  * @key: a key
2500  * @error: return location for a #GError
2501  *
2502  * Returns the value associated with @key under @group_name as a
2503  * boolean.
2504  *
2505  * If @key cannot be found then %FALSE is returned and @error is set
2506  * to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value
2507  * associated with @key cannot be interpreted as a boolean then %FALSE
2508  * is returned and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
2509  *
2510  * Returns: the value associated with the key as a boolean,
2511  *    or %FALSE if the key was not found or could not be parsed.
2512  *
2513  * Since: 2.6
2514  **/
2515 gboolean
2516 g_key_file_get_boolean (GKeyFile     *key_file,
<span class="line-modified">2517             const gchar  *group_name,</span>
<span class="line-modified">2518             const gchar  *key,</span>
<span class="line-modified">2519             GError      **error)</span>
2520 {
2521   GError *key_file_error = NULL;
2522   gchar *value;
2523   gboolean bool_value;
2524 
2525   g_return_val_if_fail (key_file != NULL, FALSE);
2526   g_return_val_if_fail (group_name != NULL, FALSE);
2527   g_return_val_if_fail (key != NULL, FALSE);
2528 
2529   value = g_key_file_get_value (key_file, group_name, key, &amp;key_file_error);
2530 
2531   if (!value)
2532     {
2533       g_propagate_error (error, key_file_error);
2534       return FALSE;
2535     }
2536 
2537   bool_value = g_key_file_parse_value_as_boolean (key_file, value,
<span class="line-modified">2538                           &amp;key_file_error);</span>
2539   g_free (value);
2540 
2541   if (key_file_error)
2542     {
2543       if (g_error_matches (key_file_error,
2544                            G_KEY_FILE_ERROR,
2545                            G_KEY_FILE_ERROR_INVALID_VALUE))
2546         {
2547           g_set_error (error, G_KEY_FILE_ERROR,
2548                        G_KEY_FILE_ERROR_INVALID_VALUE,
2549                        _(&quot;Key file contains key &#39;%s&#39; &quot;
2550                          &quot;which has a value that cannot be interpreted.&quot;),
2551                        key);
2552           g_error_free (key_file_error);
2553         }
2554       else
2555         g_propagate_error (error, key_file_error);
2556     }
2557 
2558   return bool_value;
2559 }
2560 
2561 /**
2562  * g_key_file_set_boolean:
2563  * @key_file: a #GKeyFile
2564  * @group_name: a group name
2565  * @key: a key
2566  * @value: %TRUE or %FALSE
2567  *
2568  * Associates a new boolean value with @key under @group_name.
2569  * If @key cannot be found then it is created.
2570  *
2571  * Since: 2.6
2572  **/
2573 void
2574 g_key_file_set_boolean (GKeyFile    *key_file,
<span class="line-modified">2575             const gchar *group_name,</span>
<span class="line-modified">2576             const gchar *key,</span>
<span class="line-modified">2577             gboolean     value)</span>
2578 {
2579   gchar *result;
2580 
2581   g_return_if_fail (key_file != NULL);
2582 
2583   result = g_key_file_parse_boolean_as_value (key_file, value);
2584   g_key_file_set_value (key_file, group_name, key, result);
2585   g_free (result);
2586 }
2587 
2588 /**
2589  * g_key_file_get_boolean_list:
2590  * @key_file: a #GKeyFile
2591  * @group_name: a group name
2592  * @key: a key
2593  * @length: (out): the number of booleans returned
2594  * @error: return location for a #GError
2595  *
2596  * Returns the values associated with @key under @group_name as
2597  * booleans.
2598  *
2599  * If @key cannot be found then %NULL is returned and @error is set to
2600  * #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
2601  * with @key cannot be interpreted as booleans then %NULL is returned
2602  * and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
2603  *
2604  * Returns: (array length=length) (element-type gboolean) (transfer container):
2605  *    the values associated with the key as a list of booleans, or %NULL if the
2606  *    key was not found or could not be parsed. The returned list of booleans
2607  *    should be freed with g_free() when no longer needed.
2608  *
2609  * Since: 2.6
2610  **/
2611 gboolean *
2612 g_key_file_get_boolean_list (GKeyFile     *key_file,
<span class="line-modified">2613                  const gchar  *group_name,</span>
<span class="line-modified">2614                  const gchar  *key,</span>
<span class="line-modified">2615                  gsize        *length,</span>
<span class="line-modified">2616                  GError      **error)</span>
2617 {
2618   GError *key_file_error;
2619   gchar **values;
2620   gboolean *bool_values;
2621   gsize i, num_bools;
2622 
2623   g_return_val_if_fail (key_file != NULL, NULL);
2624   g_return_val_if_fail (group_name != NULL, NULL);
2625   g_return_val_if_fail (key != NULL, NULL);
2626 
2627   if (length)
2628     *length = 0;
2629 
2630   key_file_error = NULL;
2631 
2632   values = g_key_file_get_string_list (key_file, group_name, key,
<span class="line-modified">2633                        &amp;num_bools, &amp;key_file_error);</span>
2634 
2635   if (key_file_error)
2636     g_propagate_error (error, key_file_error);
2637 
2638   if (!values)
2639     return NULL;
2640 
2641   bool_values = g_new (gboolean, num_bools);
2642 
2643   for (i = 0; i &lt; num_bools; i++)
2644     {
2645       bool_values[i] = g_key_file_parse_value_as_boolean (key_file,
<span class="line-modified">2646                               values[i],</span>
<span class="line-modified">2647                               &amp;key_file_error);</span>
2648 
2649       if (key_file_error)
2650         {
2651           g_propagate_error (error, key_file_error);
2652           g_strfreev (values);
2653           g_free (bool_values);
2654 
2655           return NULL;
2656         }
2657     }
2658   g_strfreev (values);
2659 
2660   if (length)
2661     *length = num_bools;
2662 
2663   return bool_values;
2664 }
2665 
2666 /**
2667  * g_key_file_set_boolean_list:
2668  * @key_file: a #GKeyFile
2669  * @group_name: a group name
2670  * @key: a key
2671  * @list: (array length=length): an array of boolean values
2672  * @length: length of @list
2673  *
2674  * Associates a list of boolean values with @key under @group_name.
2675  * If @key cannot be found then it is created.
2676  * If @group_name is %NULL, the start_group is used.
2677  *
2678  * Since: 2.6
2679  **/
2680 void
2681 g_key_file_set_boolean_list (GKeyFile    *key_file,
<span class="line-modified">2682                  const gchar *group_name,</span>
<span class="line-modified">2683                  const gchar *key,</span>
<span class="line-modified">2684                  gboolean     list[],</span>
<span class="line-modified">2685                  gsize        length)</span>
2686 {
2687   GString *value_list;
2688   gsize i;
2689 
2690   g_return_if_fail (key_file != NULL);
2691   g_return_if_fail (list != NULL);
2692 
2693   value_list = g_string_sized_new (length * 8);
2694 #ifdef GSTREAMER_LITE
2695   if (value_list == NULL) {
2696     return;
2697   }
2698 #endif // GSTREAMER_LITE
2699   for (i = 0; i &lt; length; i++)
2700     {
2701       gchar *value;
2702 
2703       value = g_key_file_parse_boolean_as_value (key_file, list[i]);
2704 
2705       g_string_append (value_list, value);
</pre>
<hr />
<pre>
2718  * @group_name: a group name
2719  * @key: a key
2720  * @error: return location for a #GError
2721  *
2722  * Returns the value associated with @key under @group_name as an
2723  * integer.
2724  *
2725  * If @key cannot be found then 0 is returned and @error is set to
2726  * #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated
2727  * with @key cannot be interpreted as an integer, or is out of range
2728  * for a #gint, then 0 is returned
2729  * and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
2730  *
2731  * Returns: the value associated with the key as an integer, or
2732  *     0 if the key was not found or could not be parsed.
2733  *
2734  * Since: 2.6
2735  **/
2736 gint
2737 g_key_file_get_integer (GKeyFile     *key_file,
<span class="line-modified">2738             const gchar  *group_name,</span>
<span class="line-modified">2739             const gchar  *key,</span>
<span class="line-modified">2740             GError      **error)</span>
2741 {
2742   GError *key_file_error;
2743   gchar *value;
2744   gint int_value;
2745 
2746   g_return_val_if_fail (key_file != NULL, -1);
2747   g_return_val_if_fail (group_name != NULL, -1);
2748   g_return_val_if_fail (key != NULL, -1);
2749 
2750   key_file_error = NULL;
2751 
2752   value = g_key_file_get_value (key_file, group_name, key, &amp;key_file_error);
2753 
2754   if (key_file_error)
2755     {
2756       g_propagate_error (error, key_file_error);
2757       return 0;
2758     }
2759 
2760   int_value = g_key_file_parse_value_as_integer (key_file, value,
<span class="line-modified">2761                          &amp;key_file_error);</span>
2762   g_free (value);
2763 
2764   if (key_file_error)
2765     {
2766       if (g_error_matches (key_file_error,
2767                            G_KEY_FILE_ERROR,
2768                            G_KEY_FILE_ERROR_INVALID_VALUE))
2769         {
2770           g_set_error (error, G_KEY_FILE_ERROR,
2771                        G_KEY_FILE_ERROR_INVALID_VALUE,
2772                        _(&quot;Key file contains key &#39;%s&#39; in group &#39;%s&#39; &quot;
2773                          &quot;which has a value that cannot be interpreted.&quot;),
2774                          key, group_name);
2775           g_error_free (key_file_error);
2776         }
2777       else
2778         g_propagate_error (error, key_file_error);
2779     }
2780 
2781   return int_value;
2782 }
2783 
2784 /**
2785  * g_key_file_set_integer:
2786  * @key_file: a #GKeyFile
2787  * @group_name: a group name
2788  * @key: a key
2789  * @value: an integer value
2790  *
2791  * Associates a new integer value with @key under @group_name.
2792  * If @key cannot be found then it is created.
2793  *
2794  * Since: 2.6
2795  **/
2796 void
2797 g_key_file_set_integer (GKeyFile    *key_file,
<span class="line-modified">2798             const gchar *group_name,</span>
<span class="line-modified">2799             const gchar *key,</span>
<span class="line-modified">2800             gint         value)</span>
2801 {
2802   gchar *result;
2803 
2804   g_return_if_fail (key_file != NULL);
2805 
2806   result = g_key_file_parse_integer_as_value (key_file, value);
2807   g_key_file_set_value (key_file, group_name, key, result);
2808   g_free (result);
2809 }
2810 
2811 /**
2812  * g_key_file_get_int64:
2813  * @key_file: a non-%NULL #GKeyFile
2814  * @group_name: a non-%NULL group name
2815  * @key: a non-%NULL key
2816  * @error: return location for a #GError
2817  *
2818  * Returns the value associated with @key under @group_name as a signed
2819  * 64-bit integer. This is similar to g_key_file_get_integer() but can return
2820  * 64-bit results without truncation.
</pre>
<hr />
<pre>
2971  * @error: return location for a #GError
2972  *
2973  * Returns the values associated with @key under @group_name as
2974  * integers.
2975  *
2976  * If @key cannot be found then %NULL is returned and @error is set to
2977  * #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
2978  * with @key cannot be interpreted as integers, or are out of range for
2979  * #gint, then %NULL is returned
2980  * and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
2981  *
2982  * Returns: (array length=length) (element-type gint) (transfer container):
2983  *     the values associated with the key as a list of integers, or %NULL if
2984  *     the key was not found or could not be parsed. The returned list of
2985  *     integers should be freed with g_free() when no longer needed.
2986  *
2987  * Since: 2.6
2988  **/
2989 gint *
2990 g_key_file_get_integer_list (GKeyFile     *key_file,
<span class="line-modified">2991                  const gchar  *group_name,</span>
<span class="line-modified">2992                  const gchar  *key,</span>
<span class="line-modified">2993                  gsize        *length,</span>
<span class="line-modified">2994                  GError      **error)</span>
2995 {
2996   GError *key_file_error = NULL;
2997   gchar **values;
2998   gint *int_values;
2999   gsize i, num_ints;
3000 
3001   g_return_val_if_fail (key_file != NULL, NULL);
3002   g_return_val_if_fail (group_name != NULL, NULL);
3003   g_return_val_if_fail (key != NULL, NULL);
3004 
3005   if (length)
3006     *length = 0;
3007 
3008   values = g_key_file_get_string_list (key_file, group_name, key,
<span class="line-modified">3009                        &amp;num_ints, &amp;key_file_error);</span>
3010 
3011   if (key_file_error)
3012     g_propagate_error (error, key_file_error);
3013 
3014   if (!values)
3015     return NULL;
3016 
3017   int_values = g_new (gint, num_ints);
3018 
3019   for (i = 0; i &lt; num_ints; i++)
3020     {
3021       int_values[i] = g_key_file_parse_value_as_integer (key_file,
<span class="line-modified">3022                              values[i],</span>
<span class="line-modified">3023                              &amp;key_file_error);</span>
3024 
3025       if (key_file_error)
3026         {
3027           g_propagate_error (error, key_file_error);
3028           g_strfreev (values);
3029           g_free (int_values);
3030 
3031           return NULL;
3032         }
3033     }
3034   g_strfreev (values);
3035 
3036   if (length)
3037     *length = num_ints;
3038 
3039   return int_values;
3040 }
3041 
3042 /**
3043  * g_key_file_set_integer_list:
3044  * @key_file: a #GKeyFile
3045  * @group_name: a group name
3046  * @key: a key
3047  * @list: (array length=length): an array of integer values
3048  * @length: number of integer values in @list
3049  *
3050  * Associates a list of integer values with @key under @group_name.
3051  * If @key cannot be found then it is created.
3052  *
3053  * Since: 2.6
3054  **/
3055 void
3056 g_key_file_set_integer_list (GKeyFile    *key_file,
<span class="line-modified">3057                  const gchar *group_name,</span>
<span class="line-modified">3058                  const gchar *key,</span>
<span class="line-modified">3059                  gint         list[],</span>
<span class="line-modified">3060                  gsize        length)</span>
3061 {
3062   GString *values;
3063   gsize i;
3064 
3065   g_return_if_fail (key_file != NULL);
3066   g_return_if_fail (list != NULL);
3067 
3068   values = g_string_sized_new (length * 16);
3069 #ifdef GSTREAMER_LITE
3070   if (values == NULL) {
3071     return;
3072   }
3073 #endif // GSTREAMER_LITE
3074   for (i = 0; i &lt; length; i++)
3075     {
3076       gchar *value;
3077 
3078       value = g_key_file_parse_integer_as_value (key_file, list[i]);
3079 
3080       g_string_append (values, value);
</pre>
<hr />
<pre>
3143         {
3144           g_set_error (error, G_KEY_FILE_ERROR,
3145                        G_KEY_FILE_ERROR_INVALID_VALUE,
3146                        _(&quot;Key file contains key &#39;%s&#39; in group &#39;%s&#39; &quot;
3147                          &quot;which has a value that cannot be interpreted.&quot;),
3148                        key, group_name);
3149           g_error_free (key_file_error);
3150         }
3151       else
3152         g_propagate_error (error, key_file_error);
3153     }
3154 
3155   return double_value;
3156 }
3157 
3158 /**
3159  * g_key_file_set_double:
3160  * @key_file: a #GKeyFile
3161  * @group_name: a group name
3162  * @key: a key
<span class="line-modified">3163  * @value: an double value</span>
3164  *
3165  * Associates a new double value with @key under @group_name.
3166  * If @key cannot be found then it is created.
3167  *
3168  * Since: 2.12
3169  **/
3170 void
3171 g_key_file_set_double  (GKeyFile    *key_file,
3172                         const gchar *group_name,
3173                         const gchar *key,
3174                         gdouble      value)
3175 {
3176   gchar result[G_ASCII_DTOSTR_BUF_SIZE];
3177 
3178   g_return_if_fail (key_file != NULL);
3179 
3180   g_ascii_dtostr (result, sizeof (result), value);
3181   g_key_file_set_value (key_file, group_name, key, result);
3182 }
3183 
</pre>
<hr />
<pre>
3220   g_return_val_if_fail (group_name != NULL, NULL);
3221   g_return_val_if_fail (key != NULL, NULL);
3222 
3223   if (length)
3224     *length = 0;
3225 
3226   values = g_key_file_get_string_list (key_file, group_name, key,
3227                                        &amp;num_doubles, &amp;key_file_error);
3228 
3229   if (key_file_error)
3230     g_propagate_error (error, key_file_error);
3231 
3232   if (!values)
3233     return NULL;
3234 
3235   double_values = g_new (gdouble, num_doubles);
3236 
3237   for (i = 0; i &lt; num_doubles; i++)
3238     {
3239       double_values[i] = g_key_file_parse_value_as_double (key_file,
<span class="line-modified">3240                                values[i],</span>
<span class="line-modified">3241                                &amp;key_file_error);</span>
3242 
3243       if (key_file_error)
3244         {
3245           g_propagate_error (error, key_file_error);
3246           g_strfreev (values);
3247           g_free (double_values);
3248 
3249           return NULL;
3250         }
3251     }
3252   g_strfreev (values);
3253 
3254   if (length)
3255     *length = num_doubles;
3256 
3257   return double_values;
3258 }
3259 
3260 /**
3261  * g_key_file_set_double_list:
3262  * @key_file: a #GKeyFile
3263  * @group_name: a group name
3264  * @key: a key
3265  * @list: (array length=length): an array of double values
3266  * @length: number of double values in @list
3267  *
3268  * Associates a list of double values with @key under
3269  * @group_name.  If @key cannot be found then it is created.
3270  *
3271  * Since: 2.12
3272  **/
3273 void
3274 g_key_file_set_double_list (GKeyFile    *key_file,
<span class="line-modified">3275                 const gchar *group_name,</span>
<span class="line-modified">3276                 const gchar *key,</span>
<span class="line-modified">3277                 gdouble      list[],</span>
<span class="line-modified">3278                 gsize        length)</span>
3279 {
3280   GString *values;
3281   gsize i;
3282 
3283   g_return_if_fail (key_file != NULL);
3284   g_return_if_fail (list != NULL);
3285 
3286   values = g_string_sized_new (length * 16);
3287 #ifdef GSTREAMER_LITE
3288   if (values == NULL) {
3289     return;
3290   }
3291 #endif // GSTREAMER_LITE
3292   for (i = 0; i &lt; length; i++)
3293     {
3294       gchar result[G_ASCII_DTOSTR_BUF_SIZE];
3295 
3296       g_ascii_dtostr( result, sizeof (result), list[i] );
3297 
3298       g_string_append (values, result);
</pre>
<hr />
<pre>
3555 
3556   pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
3557   if (pair-&gt;key != NULL)
3558     return NULL;
3559 
3560   while (tmp-&gt;next)
3561     {
3562       pair = (GKeyFileKeyValuePair *) tmp-&gt;next-&gt;data;
3563 
3564       if (pair-&gt;key != NULL)
3565         break;
3566 
3567       tmp = tmp-&gt;next;
3568     }
3569 
3570   while (tmp != key_node)
3571     {
3572       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
3573 
3574       if (string == NULL)
<span class="line-modified">3575     string = g_string_sized_new (512);</span>
3576 
<span class="line-modified">3577       comment = g_key_file_parse_value_as_comment (key_file, pair-&gt;value);</span>

3578       g_string_append (string, comment);
3579       g_free (comment);
3580 
3581       tmp = tmp-&gt;prev;
3582     }
3583 
3584   if (string != NULL)
3585     {
3586       comment = string-&gt;str;
3587       g_string_free (string, FALSE);
3588     }
3589   else
3590     comment = NULL;
3591 
3592   return comment;
3593 }
3594 
3595 static gchar *
3596 get_group_comment (GKeyFile       *key_file,
<span class="line-modified">3597            GKeyFileGroup  *group,</span>
<span class="line-modified">3598            GError        **error)</span>
3599 {
3600   GString *string;
3601   GList *tmp;
3602   gchar *comment;
3603 
3604   string = NULL;
3605 
3606   tmp = group-&gt;key_value_pairs;
3607   while (tmp)
3608     {
3609       GKeyFileKeyValuePair *pair;
3610 
3611       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
3612 
3613       if (pair-&gt;key != NULL)
<span class="line-modified">3614     {</span>
<span class="line-modified">3615       tmp = tmp-&gt;prev;</span>
<span class="line-modified">3616       break;</span>
<span class="line-modified">3617     }</span>
3618 
3619       if (tmp-&gt;next == NULL)
<span class="line-modified">3620     break;</span>
3621 
3622       tmp = tmp-&gt;next;
3623     }
3624 
3625   while (tmp != NULL)
3626     {
3627       GKeyFileKeyValuePair *pair;
3628 
3629       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
3630 
3631       if (string == NULL)
3632         string = g_string_sized_new (512);
3633 
<span class="line-modified">3634       comment = g_key_file_parse_value_as_comment (key_file, pair-&gt;value);</span>

3635       g_string_append (string, comment);
3636       g_free (comment);
3637 
3638       tmp = tmp-&gt;prev;
3639     }
3640 
3641   if (string != NULL)
3642     return g_string_free (string, FALSE);
3643 
3644   return NULL;
3645 }
3646 
3647 static gchar *
3648 g_key_file_get_group_comment (GKeyFile     *key_file,
3649                               const gchar  *group_name,
3650                               GError      **error)
3651 {
3652   GList *group_node;
3653   GKeyFileGroup *group;
3654 
</pre>
<hr />
<pre>
3685   g_warn_if_fail (key_file-&gt;groups != NULL);
3686   group_node = g_list_last (key_file-&gt;groups);
3687   group = (GKeyFileGroup *) group_node-&gt;data;
3688   g_warn_if_fail (group-&gt;name == NULL);
3689 
3690   return get_group_comment (key_file, group, error);
3691 }
3692 
3693 /**
3694  * g_key_file_get_comment:
3695  * @key_file: a #GKeyFile
3696  * @group_name: (nullable): a group name, or %NULL
3697  * @key: a key
3698  * @error: return location for a #GError
3699  *
3700  * Retrieves a comment above @key from @group_name.
3701  * If @key is %NULL then @comment will be read from above
3702  * @group_name. If both @key and @group_name are %NULL, then
3703  * @comment will be read from above the first group in the file.
3704  *
<span class="line-modified">3705  * Note that the returned string includes the &#39;#&#39; comment markers.</span>


3706  *
3707  * Returns: a comment that should be freed with g_free()
3708  *
3709  * Since: 2.6
3710  **/
3711 gchar *
3712 g_key_file_get_comment (GKeyFile     *key_file,
3713                         const gchar  *group_name,
3714                         const gchar  *key,
3715                         GError      **error)
3716 {
3717   g_return_val_if_fail (key_file != NULL, NULL);
3718 
3719   if (group_name != NULL &amp;&amp; key != NULL)
3720     return g_key_file_get_key_comment (key_file, group_name, key, error);
3721   else if (group_name != NULL)
3722     return g_key_file_get_group_comment (key_file, group_name, error);
3723   else
3724     return g_key_file_get_top_comment (key_file, error);
3725 }
</pre>
<hr />
<pre>
3753     return g_key_file_set_key_comment (key_file, group_name, key, NULL, error);
3754   else if (group_name != NULL)
3755     return g_key_file_set_group_comment (key_file, group_name, NULL, error);
3756   else
3757     return g_key_file_set_top_comment (key_file, NULL, error);
3758 }
3759 
3760 /**
3761  * g_key_file_has_group:
3762  * @key_file: a #GKeyFile
3763  * @group_name: a group name
3764  *
3765  * Looks whether the key file has the group @group_name.
3766  *
3767  * Returns: %TRUE if @group_name is a part of @key_file, %FALSE
3768  * otherwise.
3769  * Since: 2.6
3770  **/
3771 gboolean
3772 g_key_file_has_group (GKeyFile    *key_file,
<span class="line-modified">3773               const gchar *group_name)</span>
3774 {
3775   g_return_val_if_fail (key_file != NULL, FALSE);
3776   g_return_val_if_fail (group_name != NULL, FALSE);
3777 
3778   return g_key_file_lookup_group (key_file, group_name) != NULL;
3779 }
3780 
3781 /* This code remains from a historical attempt to add a new public API
3782  * which respects the GError rules.
3783  */
3784 static gboolean
3785 g_key_file_has_key_full (GKeyFile     *key_file,
<span class="line-modified">3786              const gchar  *group_name,</span>
<span class="line-modified">3787              const gchar  *key,</span>
<span class="line-modified">3788              gboolean     *has_key,</span>
<span class="line-modified">3789              GError      **error)</span>
3790 {
3791   GKeyFileKeyValuePair *pair;
3792   GKeyFileGroup *group;
3793 
3794   g_return_val_if_fail (key_file != NULL, FALSE);
3795   g_return_val_if_fail (group_name != NULL, FALSE);
3796   g_return_val_if_fail (key != NULL, FALSE);
3797 
3798   group = g_key_file_lookup_group (key_file, group_name);
3799 
3800   if (!group)
3801     {
3802       g_set_error (error, G_KEY_FILE_ERROR,
3803                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
3804                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
3805 #ifdef GSTREAMER_LITE
3806                    group_name ? group_name : &quot;(null)&quot;);
3807 #else // GSTREAMER_LITE
3808                    group_name);
3809 #endif // GSTREAMER_LITE
</pre>
<hr />
<pre>
3825  * @key: a key name
3826  * @error: return location for a #GError
3827  *
3828  * Looks whether the key file has the key @key in the group
3829  * @group_name.
3830  *
3831  * Note that this function does not follow the rules for #GError strictly;
3832  * the return value both carries meaning and signals an error.  To use
3833  * this function, you must pass a #GError pointer in @error, and check
3834  * whether it is not %NULL to see if an error occurred.
3835  *
3836  * Language bindings should use g_key_file_get_value() to test whether
3837  * or not a key exists.
3838  *
3839  * Returns: %TRUE if @key is a part of @group_name, %FALSE otherwise
3840  *
3841  * Since: 2.6
3842  **/
3843 gboolean
3844 g_key_file_has_key (GKeyFile     *key_file,
<span class="line-modified">3845             const gchar  *group_name,</span>
<span class="line-modified">3846             const gchar  *key,</span>
<span class="line-modified">3847             GError      **error)</span>
3848 {
3849   GError *temp_error = NULL;
3850   gboolean has_key;
3851 
3852   if (g_key_file_has_key_full (key_file, group_name, key, &amp;has_key, &amp;temp_error))
3853     {
3854       return has_key;
3855     }
3856   else
3857     {
3858       g_propagate_error (error, temp_error);
3859       return FALSE;
3860     }
3861 }
3862 
3863 static void
3864 g_key_file_add_group (GKeyFile    *key_file,
<span class="line-modified">3865               const gchar *group_name)</span>
3866 {
3867   GKeyFileGroup *group;
3868 
3869   g_return_if_fail (key_file != NULL);
3870   g_return_if_fail (g_key_file_is_group_name (group_name));
3871 
3872   group = g_key_file_lookup_group (key_file, group_name);
3873   if (group != NULL)
3874     {
3875       key_file-&gt;current_group = group;
3876       return;
3877     }
3878 
3879   group = g_slice_new0 (GKeyFileGroup);
3880   group-&gt;name = g_strdup (group_name);
3881   group-&gt;lookup_map = g_hash_table_new (g_str_hash, g_str_equal);
3882   key_file-&gt;groups = g_list_prepend (key_file-&gt;groups, group);
3883   key_file-&gt;current_group = group;
3884 
3885   if (key_file-&gt;start_group == NULL)
</pre>
<hr />
<pre>
3894   if (pair != NULL)
3895     {
3896       g_free (pair-&gt;key);
3897       g_free (pair-&gt;value);
3898       g_slice_free (GKeyFileKeyValuePair, pair);
3899     }
3900 }
3901 
3902 /* Be careful not to call this function on a node with data in the
3903  * lookup map without removing it from the lookup map, first.
3904  *
3905  * Some current cases where this warning is not a concern are
3906  * when:
3907  *   - the node being removed is a comment node
3908  *   - the entire lookup map is getting destroyed soon after
3909  *     anyway.
3910  */
3911 static void
3912 g_key_file_remove_key_value_pair_node (GKeyFile      *key_file,
3913                                        GKeyFileGroup *group,
<span class="line-modified">3914                            GList         *pair_node)</span>
3915 {
3916 
3917   GKeyFileKeyValuePair *pair;
3918 
3919   pair = (GKeyFileKeyValuePair *) pair_node-&gt;data;
3920 
3921   group-&gt;key_value_pairs = g_list_remove_link (group-&gt;key_value_pairs, pair_node);
3922 
3923   g_warn_if_fail (pair-&gt;value != NULL);
3924 
3925   g_key_file_key_value_pair_free (pair);
3926 
3927   g_list_free_1 (pair_node);
3928 }
3929 
3930 static void
3931 g_key_file_remove_group_node (GKeyFile *key_file,
<span class="line-modified">3932                   GList    *group_node)</span>
3933 {
3934   GKeyFileGroup *group;
3935   GList *tmp;
3936 
3937   group = (GKeyFileGroup *) group_node-&gt;data;
3938 
3939   if (group-&gt;name)
3940     g_hash_table_remove (key_file-&gt;group_hash, group-&gt;name);
3941 
3942   /* If the current group gets deleted make the current group the last
3943    * added group.
3944    */
3945   if (key_file-&gt;current_group == group)
3946     {
3947       /* groups should always contain at least the top comment group,
3948        * unless g_key_file_clear has been called
3949        */
3950       if (key_file-&gt;groups)
3951         key_file-&gt;current_group = (GKeyFileGroup *) key_file-&gt;groups-&gt;data;
3952       else
3953         key_file-&gt;current_group = NULL;
3954     }
3955 
3956   /* If the start group gets deleted make the start group the first
3957    * added group.
3958    */
3959   if (key_file-&gt;start_group == group)
3960     {
3961       tmp = g_list_last (key_file-&gt;groups);
3962       while (tmp != NULL)
<span class="line-modified">3963     {</span>
<span class="line-modified">3964       if (tmp != group_node &amp;&amp;</span>
<span class="line-modified">3965           ((GKeyFileGroup *) tmp-&gt;data)-&gt;name != NULL)</span>
<span class="line-modified">3966         break;</span>
3967 
<span class="line-modified">3968       tmp = tmp-&gt;prev;</span>
<span class="line-modified">3969     }</span>
3970 
3971       if (tmp)
3972         key_file-&gt;start_group = (GKeyFileGroup *) tmp-&gt;data;
3973       else
3974         key_file-&gt;start_group = NULL;
3975     }
3976 
3977   key_file-&gt;groups = g_list_remove_link (key_file-&gt;groups, group_node);
3978 
3979   tmp = group-&gt;key_value_pairs;
3980   while (tmp != NULL)
3981     {
3982       GList *pair_node;
3983 
3984       pair_node = tmp;
3985       tmp = tmp-&gt;next;
3986       g_key_file_remove_key_value_pair_node (key_file, group, pair_node);
3987     }
3988 
3989   g_warn_if_fail (group-&gt;key_value_pairs == NULL);
</pre>
<hr />
<pre>
4003   g_free ((gchar *) group-&gt;name);
4004   g_slice_free (GKeyFileGroup, group);
4005   g_list_free_1 (group_node);
4006 }
4007 
4008 /**
4009  * g_key_file_remove_group:
4010  * @key_file: a #GKeyFile
4011  * @group_name: a group name
4012  * @error: return location for a #GError or %NULL
4013  *
4014  * Removes the specified group, @group_name,
4015  * from the key file.
4016  *
4017  * Returns: %TRUE if the group was removed, %FALSE otherwise
4018  *
4019  * Since: 2.6
4020  **/
4021 gboolean
4022 g_key_file_remove_group (GKeyFile     *key_file,
<span class="line-modified">4023              const gchar  *group_name,</span>
<span class="line-modified">4024              GError      **error)</span>
4025 {
4026   GList *group_node;
4027 
4028   g_return_val_if_fail (key_file != NULL, FALSE);
4029   g_return_val_if_fail (group_name != NULL, FALSE);
4030 
4031   group_node = g_key_file_lookup_group_node (key_file, group_name);
4032 
4033   if (!group_node)
4034     {
4035       g_set_error (error, G_KEY_FILE_ERROR,
<span class="line-modified">4036                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,</span>
<span class="line-modified">4037                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),</span>
<span class="line-modified">4038                    group_name);</span>
4039       return FALSE;
4040     }
4041 
4042   g_key_file_remove_group_node (key_file, group_node);
4043 
4044   return TRUE;
4045 }
4046 
4047 static void
4048 g_key_file_add_key_value_pair (GKeyFile             *key_file,
4049                                GKeyFileGroup        *group,
4050                                GKeyFileKeyValuePair *pair)
4051 {
4052   g_hash_table_replace (group-&gt;lookup_map, pair-&gt;key, pair);
4053   group-&gt;key_value_pairs = g_list_prepend (group-&gt;key_value_pairs, pair);
4054 }
4055 
4056 static void
4057 g_key_file_add_key (GKeyFile      *key_file,
<span class="line-modified">4058             GKeyFileGroup *group,</span>
<span class="line-modified">4059             const gchar   *key,</span>
<span class="line-modified">4060             const gchar   *value)</span>
4061 {
4062   GKeyFileKeyValuePair *pair;
4063 
4064   pair = g_slice_new (GKeyFileKeyValuePair);
4065 #ifdef GSTREAMER_LITE
4066   if (pair == NULL) {
4067     return;
4068   }
4069 #endif // GSTREAMER_LITE
4070   pair-&gt;key = g_strdup (key);
4071   pair-&gt;value = g_strdup (value);
4072 
4073   g_key_file_add_key_value_pair (key_file, group, pair);
4074 }
4075 
4076 /**
4077  * g_key_file_remove_key:
4078  * @key_file: a #GKeyFile
4079  * @group_name: a group name
4080  * @key: a key name to remove
4081  * @error: return location for a #GError or %NULL
4082  *
4083  * Removes @key in @group_name from the key file.
4084  *
4085  * Returns: %TRUE if the key was removed, %FALSE otherwise
4086  *
4087  * Since: 2.6
4088  **/
4089 gboolean
4090 g_key_file_remove_key (GKeyFile     *key_file,
<span class="line-modified">4091                const gchar  *group_name,</span>
<span class="line-modified">4092                const gchar  *key,</span>
<span class="line-modified">4093                GError      **error)</span>
4094 {
4095   GKeyFileGroup *group;
4096   GKeyFileKeyValuePair *pair;
4097 
4098   g_return_val_if_fail (key_file != NULL, FALSE);
4099   g_return_val_if_fail (group_name != NULL, FALSE);
4100   g_return_val_if_fail (key != NULL, FALSE);
4101 
4102   pair = NULL;
4103 
4104   group = g_key_file_lookup_group (key_file, group_name);
4105   if (!group)
4106     {
4107       g_set_error (error, G_KEY_FILE_ERROR,
4108                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
4109                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
4110 #ifdef GSTREAMER_LITE
4111                    group_name ? group_name : &quot;(null)&quot;);
4112 #else // GSTREAMER_LITE
4113                    group_name);
</pre>
<hr />
<pre>
4115       return FALSE;
4116     }
4117 
4118   pair = g_key_file_lookup_key_value_pair (key_file, group, key);
4119 
4120   if (!pair)
4121     {
4122       set_not_found_key_error (group-&gt;name, key, error);
4123       return FALSE;
4124     }
4125 
4126   group-&gt;key_value_pairs = g_list_remove (group-&gt;key_value_pairs, pair);
4127   g_hash_table_remove (group-&gt;lookup_map, pair-&gt;key);
4128   g_key_file_key_value_pair_free (pair);
4129 
4130   return TRUE;
4131 }
4132 
4133 static GList *
4134 g_key_file_lookup_group_node (GKeyFile    *key_file,
<span class="line-modified">4135                   const gchar *group_name)</span>
4136 {
4137   GKeyFileGroup *group;
4138   GList *tmp;
4139 
4140   for (tmp = key_file-&gt;groups; tmp != NULL; tmp = tmp-&gt;next)
4141     {
4142       group = (GKeyFileGroup *) tmp-&gt;data;
4143 
4144       if (group &amp;&amp; group-&gt;name &amp;&amp; strcmp (group-&gt;name, group_name) == 0)
4145         break;
4146     }
4147 
4148   return tmp;
4149 }
4150 
4151 static GKeyFileGroup *
4152 g_key_file_lookup_group (GKeyFile    *key_file,
<span class="line-modified">4153              const gchar *group_name)</span>
4154 {
4155   return (GKeyFileGroup *)g_hash_table_lookup (key_file-&gt;group_hash, group_name);
4156 }
4157 
4158 static GList *
4159 g_key_file_lookup_key_value_pair_node (GKeyFile       *key_file,
<span class="line-modified">4160                            GKeyFileGroup  *group,</span>
4161                                        const gchar    *key)
4162 {
4163   GList *key_node;
4164 
4165   for (key_node = group-&gt;key_value_pairs;
4166        key_node != NULL;
4167        key_node = key_node-&gt;next)
4168     {
4169       GKeyFileKeyValuePair *pair;
4170 
4171       pair = (GKeyFileKeyValuePair *) key_node-&gt;data;
4172 
4173       if (pair-&gt;key &amp;&amp; strcmp (pair-&gt;key, key) == 0)
4174         break;
4175     }
4176 
4177   return key_node;
4178 }
4179 
4180 static GKeyFileKeyValuePair *
4181 g_key_file_lookup_key_value_pair (GKeyFile      *key_file,
<span class="line-modified">4182                   GKeyFileGroup *group,</span>
<span class="line-modified">4183                   const gchar   *key)</span>
4184 {
4185   return (GKeyFileKeyValuePair *) g_hash_table_lookup (group-&gt;lookup_map, key);
4186 }
4187 
4188 /* Lines starting with # or consisting entirely of whitespace are merely
4189  * recorded, not parsed. This function assumes all leading whitespace
4190  * has been stripped.
4191  */
4192 static gboolean
4193 g_key_file_line_is_comment (const gchar *line)
4194 {
4195   return (*line == &#39;#&#39; || *line == &#39;\0&#39; || *line == &#39;\n&#39;);
4196 }
4197 
4198 static gboolean
4199 g_key_file_is_group_name (const gchar *name)
4200 {
4201   gchar *p, *q;
4202 
4203   if (name == NULL)
</pre>
<hr />
<pre>
4292 static gboolean
4293 g_key_file_line_is_key_value_pair (const gchar *line)
4294 {
4295   gchar *p;
4296 
4297   p = (gchar *) g_utf8_strchr (line, -1, &#39;=&#39;);
4298 
4299   if (!p)
4300     return FALSE;
4301 
4302   /* Key must be non-empty
4303    */
4304   if (*p == line[0])
4305     return FALSE;
4306 
4307   return TRUE;
4308 }
4309 
4310 static gchar *
4311 g_key_file_parse_value_as_string (GKeyFile     *key_file,
<span class="line-modified">4312                   const gchar  *value,</span>
<span class="line-modified">4313                   GSList      **pieces,</span>
<span class="line-modified">4314                   GError      **error)</span>
4315 {
4316   gchar *string_value, *p, *q0, *q;
4317 
4318   string_value = g_new (gchar, strlen (value) + 1);
4319 
4320   p = (gchar *) value;
4321   q0 = q = string_value;
4322   while (*p)
4323     {
4324       if (*p == &#39;\\&#39;)
4325         {
4326           p++;
4327 
4328           switch (*p)
4329             {
4330             case &#39;s&#39;:
4331               *q = &#39; &#39;;
4332               break;
4333 
4334             case &#39;n&#39;:
4335               *q = &#39;\n&#39;;
4336               break;
4337 
4338             case &#39;t&#39;:
4339               *q = &#39;\t&#39;;
4340               break;
4341 
4342             case &#39;r&#39;:
4343               *q = &#39;\r&#39;;
4344               break;
4345 
4346             case &#39;\\&#39;:
4347               *q = &#39;\\&#39;;
4348               break;
4349 
<span class="line-modified">4350         case &#39;\0&#39;:</span>
<span class="line-modified">4351           g_set_error_literal (error, G_KEY_FILE_ERROR,</span>
4352                                    G_KEY_FILE_ERROR_INVALID_VALUE,
4353                                    _(&quot;Key file contains escape character &quot;
4354                                      &quot;at end of line&quot;));
<span class="line-modified">4355           break;</span>
4356 
4357             default:
<span class="line-modified">4358           if (pieces &amp;&amp; *p == key_file-&gt;list_separator)</span>
<span class="line-modified">4359         *q = key_file-&gt;list_separator;</span>
<span class="line-modified">4360           else</span>
<span class="line-modified">4361         {</span>
<span class="line-modified">4362           *q++ = &#39;\\&#39;;</span>
<span class="line-modified">4363           *q = *p;</span>
4364 
<span class="line-modified">4365           if (*error == NULL)</span>
<span class="line-modified">4366             {</span>
<span class="line-modified">4367               gchar sequence[3];</span>
4368 
<span class="line-modified">4369               sequence[0] = &#39;\\&#39;;</span>
<span class="line-modified">4370               sequence[1] = *p;</span>
<span class="line-modified">4371               sequence[2] = &#39;\0&#39;;</span>
4372 
<span class="line-modified">4373               g_set_error (error, G_KEY_FILE_ERROR,</span>
<span class="line-modified">4374                            G_KEY_FILE_ERROR_INVALID_VALUE,</span>
<span class="line-modified">4375                            _(&quot;Key file contains invalid escape &quot;</span>
<span class="line-modified">4376                            &quot;sequence &#39;%s&#39;&quot;), sequence);</span>
<span class="line-removed">4377             }</span>
4378         }

4379               break;
4380             }
4381         }
4382       else
<span class="line-modified">4383     {</span>
<span class="line-modified">4384       *q = *p;</span>
<span class="line-modified">4385       if (pieces &amp;&amp; (*p == key_file-&gt;list_separator))</span>
<span class="line-modified">4386         {</span>
<span class="line-modified">4387           *pieces = g_slist_prepend (*pieces, g_strndup (q0, q - q0));</span>
<span class="line-modified">4388           q0 = q + 1;</span>
<span class="line-modified">4389         }</span>
<span class="line-modified">4390     }</span>
4391 
4392       if (*p == &#39;\0&#39;)
<span class="line-modified">4393     break;</span>
4394 
4395       q++;
4396       p++;
4397     }
4398 
4399   *q = &#39;\0&#39;;
4400   if (pieces)
4401   {
4402     if (q0 &lt; q)
4403       *pieces = g_slist_prepend (*pieces, g_strndup (q0, q - q0));
4404     *pieces = g_slist_reverse (*pieces);
4405   }
4406 
4407   return string_value;
4408 }
4409 
4410 static gchar *
4411 g_key_file_parse_string_as_value (GKeyFile    *key_file,
<span class="line-modified">4412                   const gchar *string,</span>
<span class="line-modified">4413                   gboolean     escape_separator)</span>
4414 {
4415   gchar *value, *p, *q;
4416   gsize length;
4417   gboolean parsing_leading_space;
4418 
4419   length = strlen (string) + 1;
4420 
4421   /* Worst case would be that every character needs to be escaped.
4422    * In other words every character turns to two characters
4423    */
4424   value = g_new (gchar, 2 * length);
4425 
4426   p = (gchar *) string;
4427   q = value;
4428   parsing_leading_space = TRUE;
4429   while (p &lt; (string + length - 1))
4430     {
4431       gchar escaped_character[3] = { &#39;\\&#39;, 0, 0 };
4432 
4433       switch (*p)
4434         {
4435         case &#39; &#39;:
4436           if (parsing_leading_space)
4437             {
4438               escaped_character[1] = &#39;s&#39;;
4439               strcpy (q, escaped_character);
4440               q += 2;
4441             }
4442           else
4443             {
<span class="line-modified">4444           *q = *p;</span>
<span class="line-modified">4445           q++;</span>
4446             }
4447           break;
4448         case &#39;\t&#39;:
4449           if (parsing_leading_space)
4450             {
4451               escaped_character[1] = &#39;t&#39;;
4452               strcpy (q, escaped_character);
4453               q += 2;
4454             }
4455           else
4456             {
<span class="line-modified">4457           *q = *p;</span>
<span class="line-modified">4458           q++;</span>
4459             }
4460           break;
4461         case &#39;\n&#39;:
4462           escaped_character[1] = &#39;n&#39;;
4463           strcpy (q, escaped_character);
4464           q += 2;
4465           break;
4466         case &#39;\r&#39;:
4467           escaped_character[1] = &#39;r&#39;;
4468           strcpy (q, escaped_character);
4469           q += 2;
4470           break;
4471         case &#39;\\&#39;:
4472           escaped_character[1] = &#39;\\&#39;;
4473           strcpy (q, escaped_character);
4474           q += 2;
4475           parsing_leading_space = FALSE;
4476           break;
4477         default:
<span class="line-modified">4478       if (escape_separator &amp;&amp; *p == key_file-&gt;list_separator)</span>
<span class="line-modified">4479         {</span>
<span class="line-modified">4480           escaped_character[1] = key_file-&gt;list_separator;</span>
<span class="line-modified">4481           strcpy (q, escaped_character);</span>
<span class="line-modified">4482           q += 2;</span>
4483               parsing_leading_space = TRUE;
<span class="line-modified">4484         }</span>
<span class="line-modified">4485       else</span>
<span class="line-modified">4486         {</span>
<span class="line-modified">4487           *q = *p;</span>
<span class="line-modified">4488           q++;</span>
4489               parsing_leading_space = FALSE;
<span class="line-modified">4490         }</span>
4491           break;
4492         }
4493       p++;
4494     }
4495   *q = &#39;\0&#39;;
4496 
4497   return value;
4498 }
4499 
4500 static gint
4501 g_key_file_parse_value_as_integer (GKeyFile     *key_file,
<span class="line-modified">4502                    const gchar  *value,</span>
<span class="line-modified">4503                    GError      **error)</span>
4504 {
4505   gchar *eof_int;
4506   glong long_value;
4507   gint int_value;
4508   int errsv;
4509 
4510   errno = 0;
4511   long_value = strtol (value, &amp;eof_int, 10);
4512   errsv = errno;
4513 
4514   if (*value == &#39;\0&#39; || (*eof_int != &#39;\0&#39; &amp;&amp; !g_ascii_isspace(*eof_int)))
4515     {
4516       gchar *value_utf8 = g_utf8_make_valid (value, -1);
4517       g_set_error (error, G_KEY_FILE_ERROR,
<span class="line-modified">4518                    G_KEY_FILE_ERROR_INVALID_VALUE,</span>
<span class="line-modified">4519                    _(&quot;Value &#39;%s&#39; cannot be interpreted &quot;</span>
<span class="line-modified">4520                    &quot;as a number.&quot;), value_utf8);</span>
4521       g_free (value_utf8);
4522 
4523       return 0;
4524     }
4525 
4526   int_value = long_value;
4527   if (int_value != long_value || errsv == ERANGE)
4528     {
4529       gchar *value_utf8 = g_utf8_make_valid (value, -1);
4530       g_set_error (error,
<span class="line-modified">4531                    G_KEY_FILE_ERROR,</span>
<span class="line-modified">4532                    G_KEY_FILE_ERROR_INVALID_VALUE,</span>
<span class="line-modified">4533                    _(&quot;Integer value &#39;%s&#39; out of range&quot;),</span>
<span class="line-modified">4534                    value_utf8);</span>
4535       g_free (value_utf8);
4536 
4537       return 0;
4538     }
4539 
4540   return int_value;
4541 }
4542 
4543 static gchar *
4544 g_key_file_parse_integer_as_value (GKeyFile *key_file,
<span class="line-modified">4545                    gint      value)</span>
4546 
4547 {
4548   return g_strdup_printf (&quot;%d&quot;, value);
4549 }
4550 
4551 static gdouble
4552 g_key_file_parse_value_as_double  (GKeyFile     *key_file,
4553                                    const gchar  *value,
4554                                    GError      **error)
4555 {
4556   gchar *end_of_valid_d;
4557   gdouble double_value = 0;
4558 
4559   double_value = g_ascii_strtod (value, &amp;end_of_valid_d);
4560 
4561   if (*end_of_valid_d != &#39;\0&#39; || end_of_valid_d == value)
4562     {
4563       gchar *value_utf8 = g_utf8_make_valid (value, -1);
4564       g_set_error (error, G_KEY_FILE_ERROR,
<span class="line-modified">4565                    G_KEY_FILE_ERROR_INVALID_VALUE,</span>
<span class="line-modified">4566                    _(&quot;Value &#39;%s&#39; cannot be interpreted &quot;</span>
<span class="line-modified">4567                    &quot;as a float number.&quot;),</span>
<span class="line-modified">4568                    value_utf8);</span>
4569       g_free (value_utf8);
4570 
4571       double_value = 0;
4572     }
4573 
4574   return double_value;
4575 }
4576 
4577 static gint
4578 strcmp_sized (const gchar *s1, size_t len1, const gchar *s2)
4579 {
4580   size_t len2 = strlen (s2);
4581   return strncmp (s1, s2, MAX (len1, len2));
4582 }
4583 
4584 static gboolean
4585 g_key_file_parse_value_as_boolean (GKeyFile     *key_file,
<span class="line-modified">4586                    const gchar  *value,</span>
<span class="line-modified">4587                    GError      **error)</span>
4588 {
4589   gchar *value_utf8;
4590   gint i, length = 0;
4591 
4592   /* Count the number of non-whitespace characters */
4593   for (i = 0; value[i]; i++)
4594     if (!g_ascii_isspace (value[i]))
4595       length = i + 1;
4596 
4597   if (strcmp_sized (value, length, &quot;true&quot;) == 0 || strcmp_sized (value, length, &quot;1&quot;) == 0)
4598     return TRUE;
4599   else if (strcmp_sized (value, length, &quot;false&quot;) == 0 || strcmp_sized (value, length, &quot;0&quot;) == 0)
4600     return FALSE;
4601 
4602   value_utf8 = g_utf8_make_valid (value, -1);
4603   g_set_error (error, G_KEY_FILE_ERROR,
4604                G_KEY_FILE_ERROR_INVALID_VALUE,
4605                _(&quot;Value &#39;%s&#39; cannot be interpreted &quot;
<span class="line-modified">4606                &quot;as a boolean.&quot;), value_utf8);</span>
4607   g_free (value_utf8);
4608 
4609   return FALSE;
4610 }
4611 
4612 static gchar *
4613 g_key_file_parse_boolean_as_value (GKeyFile *key_file,
<span class="line-modified">4614                    gboolean  value)</span>
4615 {
4616   if (value)
4617     return g_strdup (&quot;true&quot;);
4618   else
4619     return g_strdup (&quot;false&quot;);
4620 }
4621 
4622 static gchar *
4623 g_key_file_parse_value_as_comment (GKeyFile    *key_file,
<span class="line-modified">4624                                    const gchar *value)</span>

4625 {
4626   GString *string;
4627   gchar **lines;
4628   gsize i;
4629 
4630   string = g_string_sized_new (512);
4631 
4632   lines = g_strsplit (value, &quot;\n&quot;, 0);
4633 
4634   for (i = 0; lines[i] != NULL; i++)
4635     {
<span class="line-modified">4636         if (lines[i][0] != &#39;#&#39;)</span>
<span class="line-modified">4637            g_string_append_printf (string, &quot;%s\n&quot;, lines[i]);</span>
<span class="line-modified">4638         else</span>
<span class="line-modified">4639            g_string_append_printf (string, &quot;%s\n&quot;, lines[i] + 1);</span>




4640     }
4641   g_strfreev (lines);
4642 





4643   return g_string_free (string, FALSE);
4644 }
4645 
4646 static gchar *
4647 g_key_file_parse_comment_as_value (GKeyFile      *key_file,
4648                                    const gchar   *comment)
4649 {
4650   GString *string;
4651   gchar **lines;
4652   gsize i;
4653 
4654   string = g_string_sized_new (512);
4655 
4656   lines = g_strsplit (comment, &quot;\n&quot;, 0);
4657 
4658   for (i = 0; lines[i] != NULL; i++)
4659     g_string_append_printf (string, &quot;#%s%s&quot;, lines[i],
4660                             lines[i + 1] == NULL? &quot;&quot; : &quot;\n&quot;);
4661   g_strfreev (lines);
4662 
</pre>
</td>
<td>
<hr />
<pre>
 521 {
 522   const gchar *name;  /* NULL for above first group (which will be comments) */
 523 
 524   GKeyFileKeyValuePair *comment; /* Special comment that is stuck to the top of a group */
 525 
 526   GList *key_value_pairs;
 527 
 528   /* Used in parallel with key_value_pairs for
 529    * increased lookup performance
 530    */
 531   GHashTable *lookup_map;
 532 };
 533 
 534 struct _GKeyFileKeyValuePair
 535 {
 536   gchar *key;  /* NULL for comments */
 537   gchar *value;
 538 };
 539 
 540 static gint                  find_file_in_data_dirs            (const gchar            *file,
<span class="line-modified"> 541                 const gchar           **data_dirs,</span>
<span class="line-modified"> 542                 gchar                 **output_file,</span>
<span class="line-modified"> 543                 GError                **error);</span>
 544 static gboolean              g_key_file_load_from_fd           (GKeyFile               *key_file,
<span class="line-modified"> 545                 gint                    fd,</span>
<span class="line-modified"> 546                 GKeyFileFlags           flags,</span>
<span class="line-modified"> 547                 GError                **error);</span>
 548 static GList                *g_key_file_lookup_group_node      (GKeyFile               *key_file,
<span class="line-modified"> 549                                               const gchar            *group_name);</span>
 550 static GKeyFileGroup        *g_key_file_lookup_group           (GKeyFile               *key_file,
<span class="line-modified"> 551                 const gchar            *group_name);</span>
 552 
 553 static GList                *g_key_file_lookup_key_value_pair_node  (GKeyFile       *key_file,
<span class="line-modified"> 554                                                    GKeyFileGroup  *group,</span>
 555                                                                      const gchar    *key);
 556 static GKeyFileKeyValuePair *g_key_file_lookup_key_value_pair       (GKeyFile       *key_file,
 557                                                                      GKeyFileGroup  *group,
 558                                                                      const gchar    *key);
 559 
 560 static void                  g_key_file_remove_group_node          (GKeyFile      *key_file,
<span class="line-modified"> 561                       GList         *group_node);</span>
 562 static void                  g_key_file_remove_key_value_pair_node (GKeyFile      *key_file,
 563                                                                     GKeyFileGroup *group,
 564                                                                     GList         *pair_node);
 565 
 566 static void                  g_key_file_add_key_value_pair     (GKeyFile               *key_file,
 567                                                                 GKeyFileGroup          *group,
 568                                                                 GKeyFileKeyValuePair   *pair);
 569 static void                  g_key_file_add_key                (GKeyFile               *key_file,
<span class="line-modified"> 570                 GKeyFileGroup          *group,</span>
<span class="line-modified"> 571                 const gchar            *key,</span>
<span class="line-modified"> 572                 const gchar            *value);</span>
 573 static void                  g_key_file_add_group              (GKeyFile               *key_file,
<span class="line-modified"> 574                 const gchar            *group_name);</span>
 575 static gboolean              g_key_file_is_group_name          (const gchar *name);
 576 static gboolean              g_key_file_is_key_name            (const gchar *name);
 577 static void                  g_key_file_key_value_pair_free    (GKeyFileKeyValuePair   *pair);
 578 static gboolean              g_key_file_line_is_comment        (const gchar            *line);
 579 static gboolean              g_key_file_line_is_group          (const gchar            *line);
 580 static gboolean              g_key_file_line_is_key_value_pair (const gchar            *line);
 581 static gchar                *g_key_file_parse_value_as_string  (GKeyFile               *key_file,
<span class="line-modified"> 582                 const gchar            *value,</span>
<span class="line-modified"> 583                 GSList                **separators,</span>
<span class="line-modified"> 584                 GError                **error);</span>
 585 static gchar                *g_key_file_parse_string_as_value  (GKeyFile               *key_file,
<span class="line-modified"> 586                 const gchar            *string,</span>
<span class="line-modified"> 587                 gboolean                escape_separator);</span>
 588 static gint                  g_key_file_parse_value_as_integer (GKeyFile               *key_file,
<span class="line-modified"> 589                 const gchar            *value,</span>
<span class="line-modified"> 590                 GError                **error);</span>
 591 static gchar                *g_key_file_parse_integer_as_value (GKeyFile               *key_file,
<span class="line-modified"> 592                 gint                    value);</span>
 593 static gdouble               g_key_file_parse_value_as_double  (GKeyFile               *key_file,
 594                                                                 const gchar            *value,
 595                                                                 GError                **error);
 596 static gboolean              g_key_file_parse_value_as_boolean (GKeyFile               *key_file,
<span class="line-modified"> 597                 const gchar            *value,</span>
<span class="line-modified"> 598                 GError                **error);</span>
 599 static gchar                *g_key_file_parse_boolean_as_value (GKeyFile               *key_file,
<span class="line-modified"> 600                 gboolean                value);</span>
 601 static gchar                *g_key_file_parse_value_as_comment (GKeyFile               *key_file,
<span class="line-modified"> 602                                                                 const gchar            *value,</span>
<span class="line-added"> 603                                                                 gboolean                is_final_line);</span>
 604 static gchar                *g_key_file_parse_comment_as_value (GKeyFile               *key_file,
 605                                                                 const gchar            *comment);
 606 static void                  g_key_file_parse_key_value_pair   (GKeyFile               *key_file,
<span class="line-modified"> 607                 const gchar            *line,</span>
<span class="line-modified"> 608                 gsize                   length,</span>
<span class="line-modified"> 609                 GError                **error);</span>
 610 static void                  g_key_file_parse_comment          (GKeyFile               *key_file,
<span class="line-modified"> 611                 const gchar            *line,</span>
<span class="line-modified"> 612                 gsize                   length,</span>
<span class="line-modified"> 613                 GError                **error);</span>
 614 static void                  g_key_file_parse_group            (GKeyFile               *key_file,
<span class="line-modified"> 615                 const gchar            *line,</span>
<span class="line-modified"> 616                 gsize                   length,</span>
<span class="line-modified"> 617                 GError                **error);</span>
 618 static gchar                *key_get_locale                    (const gchar            *key);
 619 static void                  g_key_file_parse_data             (GKeyFile               *key_file,
<span class="line-modified"> 620                 const gchar            *data,</span>
<span class="line-modified"> 621                 gsize                   length,</span>
<span class="line-modified"> 622                 GError                **error);</span>
 623 static void                  g_key_file_flush_parse_buffer     (GKeyFile               *key_file,
<span class="line-modified"> 624                 GError                **error);</span>
 625 
 626 G_DEFINE_QUARK (g-key-file-error-quark, g_key_file_error)
 627 
 628 static void
 629 g_key_file_init (GKeyFile *key_file)
 630 {
 631   key_file-&gt;current_group = g_slice_new0 (GKeyFileGroup);
 632   key_file-&gt;groups = g_list_prepend (NULL, key_file-&gt;current_group);
 633   key_file-&gt;group_hash = g_hash_table_new (g_str_hash, g_str_equal);
 634   key_file-&gt;start_group = NULL;
 635   key_file-&gt;parse_buffer = g_string_sized_new (128);
 636   key_file-&gt;list_separator = &#39;;&#39;;
 637   key_file-&gt;flags = 0;
 638   key_file-&gt;locales = g_strdupv ((gchar **)g_get_language_names ());
 639 }
 640 
 641 static void
 642 g_key_file_clear (GKeyFile *key_file)
 643 {
 644   GList *tmp, *group_node;
</pre>
<hr />
<pre>
 693   key_file = g_slice_new0 (GKeyFile);
 694   key_file-&gt;ref_count = 1;
 695   g_key_file_init (key_file);
 696 
 697   return key_file;
 698 }
 699 
 700 /**
 701  * g_key_file_set_list_separator:
 702  * @key_file: a #GKeyFile
 703  * @separator: the separator
 704  *
 705  * Sets the character which is used to separate
 706  * values in lists. Typically &#39;;&#39; or &#39;,&#39; are used
 707  * as separators. The default list separator is &#39;;&#39;.
 708  *
 709  * Since: 2.6
 710  */
 711 void
 712 g_key_file_set_list_separator (GKeyFile *key_file,
<span class="line-modified"> 713              gchar     separator)</span>
 714 {
 715   g_return_if_fail (key_file != NULL);
 716 
 717   key_file-&gt;list_separator = separator;
 718 }
 719 
 720 
 721 /* Iterates through all the directories in *dirs trying to
 722  * open file.  When it successfully locates and opens a file it
 723  * returns the file descriptor to the open file.  It also
 724  * outputs the absolute path of the file in output_file.
 725  */
 726 static gint
 727 find_file_in_data_dirs (const gchar   *file,
 728                         const gchar  **dirs,
 729                         gchar        **output_file,
 730                         GError       **error)
 731 {
 732   const gchar **data_dirs, *data_dir;
 733   gchar *path;
</pre>
<hr />
<pre>
 783     }
 784 
 785   if (fd == -1)
 786     {
 787       g_set_error_literal (error, G_KEY_FILE_ERROR,
 788                            G_KEY_FILE_ERROR_NOT_FOUND,
 789                            _(&quot;Valid key file could not be &quot;
 790                              &quot;found in search dirs&quot;));
 791     }
 792 
 793   if (output_file != NULL &amp;&amp; fd != -1)
 794     *output_file = g_strdup (path);
 795 
 796   g_free (path);
 797 
 798   return fd;
 799 }
 800 
 801 static gboolean
 802 g_key_file_load_from_fd (GKeyFile       *key_file,
<span class="line-modified"> 803        gint            fd,</span>
<span class="line-modified"> 804        GKeyFileFlags   flags,</span>
<span class="line-modified"> 805        GError        **error)</span>
 806 {
 807   GError *key_file_error = NULL;
 808   gssize bytes_read;
 809   struct stat stat_buf;
 810   gchar read_buf[4096];
 811   gchar list_separator;
 812 
 813   if (fstat (fd, &amp;stat_buf) &lt; 0)
 814     {
 815       int errsv = errno;
 816       g_set_error_literal (error, G_FILE_ERROR,
 817                            g_file_error_from_errno (errsv),
 818                            g_strerror (errsv));
 819       return FALSE;
 820     }
 821 
 822   if (!S_ISREG (stat_buf.st_mode))
 823     {
 824       g_set_error_literal (error, G_KEY_FILE_ERROR,
 825                            G_KEY_FILE_ERROR_PARSE,
</pre>
<hr />
<pre>
 838       int errsv;
 839 
 840       bytes_read = read (fd, read_buf, 4096);
 841       errsv = errno;
 842 
 843       if (bytes_read == 0)  /* End of File */
 844         break;
 845 
 846       if (bytes_read &lt; 0)
 847         {
 848           if (errsv == EINTR || errsv == EAGAIN)
 849             continue;
 850 
 851           g_set_error_literal (error, G_FILE_ERROR,
 852                                g_file_error_from_errno (errsv),
 853                                g_strerror (errsv));
 854           return FALSE;
 855         }
 856 
 857       g_key_file_parse_data (key_file,
<span class="line-modified"> 858            read_buf, bytes_read,</span>
<span class="line-modified"> 859            &amp;key_file_error);</span>
 860     }
 861   while (!key_file_error);
 862 
 863   if (key_file_error)
 864     {
 865       g_propagate_error (error, key_file_error);
 866       return FALSE;
 867     }
 868 
 869   g_key_file_flush_parse_buffer (key_file, &amp;key_file_error);
 870 
 871   if (key_file_error)
 872     {
 873       g_propagate_error (error, key_file_error);
 874       return FALSE;
 875     }
 876 
 877   return TRUE;
 878 }
 879 
</pre>
<hr />
<pre>
 882  * @key_file: an empty #GKeyFile struct
 883  * @file: (type filename): the path of a filename to load, in the GLib filename encoding
 884  * @flags: flags from #GKeyFileFlags
 885  * @error: return location for a #GError, or %NULL
 886  *
 887  * Loads a key file into an empty #GKeyFile structure.
 888  *
 889  * If the OS returns an error when opening or reading the file, a
 890  * %G_FILE_ERROR is returned. If there is a problem parsing the file, a
 891  * %G_KEY_FILE_ERROR is returned.
 892  *
 893  * This function will never return a %G_KEY_FILE_ERROR_NOT_FOUND error. If the
 894  * @file is not found, %G_FILE_ERROR_NOENT is returned.
 895  *
 896  * Returns: %TRUE if a key file could be loaded, %FALSE otherwise
 897  *
 898  * Since: 2.6
 899  **/
 900 gboolean
 901 g_key_file_load_from_file (GKeyFile       *key_file,
<span class="line-modified"> 902          const gchar    *file,</span>
<span class="line-modified"> 903          GKeyFileFlags   flags,</span>
<span class="line-modified"> 904          GError        **error)</span>
 905 {
 906   GError *key_file_error = NULL;
 907   gint fd;
 908   int errsv;
 909 
 910   g_return_val_if_fail (key_file != NULL, FALSE);
 911   g_return_val_if_fail (file != NULL, FALSE);
 912 
 913   fd = g_open (file, O_RDONLY, 0);
 914   errsv = errno;
 915 
 916   if (fd == -1)
 917     {
 918       g_set_error_literal (error, G_FILE_ERROR,
 919                            g_file_error_from_errno (errsv),
 920                            g_strerror (errsv));
 921       return FALSE;
 922     }
 923 
 924   g_key_file_load_from_fd (key_file, fd, flags, &amp;key_file_error);
</pre>
<hr />
<pre>
 933   return TRUE;
 934 }
 935 
 936 /**
 937  * g_key_file_load_from_data:
 938  * @key_file: an empty #GKeyFile struct
 939  * @data: key file loaded in memory
 940  * @length: the length of @data in bytes (or (gsize)-1 if data is nul-terminated)
 941  * @flags: flags from #GKeyFileFlags
 942  * @error: return location for a #GError, or %NULL
 943  *
 944  * Loads a key file from memory into an empty #GKeyFile structure.
 945  * If the object cannot be created then %error is set to a #GKeyFileError.
 946  *
 947  * Returns: %TRUE if a key file could be loaded, %FALSE otherwise
 948  *
 949  * Since: 2.6
 950  **/
 951 gboolean
 952 g_key_file_load_from_data (GKeyFile       *key_file,
<span class="line-modified"> 953          const gchar    *data,</span>
<span class="line-modified"> 954          gsize           length,</span>
<span class="line-modified"> 955          GKeyFileFlags   flags,</span>
<span class="line-modified"> 956          GError        **error)</span>
 957 {
 958   GError *key_file_error = NULL;
 959   gchar list_separator;
 960 
 961   g_return_val_if_fail (key_file != NULL, FALSE);
 962   g_return_val_if_fail (data != NULL || length == 0, FALSE);
 963 
 964   if (length == (gsize)-1)
 965     length = strlen (data);
 966 
 967   list_separator = key_file-&gt;list_separator;
 968   g_key_file_clear (key_file);
 969   g_key_file_init (key_file);
 970   key_file-&gt;list_separator = list_separator;
 971   key_file-&gt;flags = flags;
 972 
 973   g_key_file_parse_data (key_file, data, length, &amp;key_file_error);
 974 
 975   if (key_file_error)
 976     {
</pre>
<hr />
<pre>
1059 
1060   g_return_val_if_fail (key_file != NULL, FALSE);
1061   g_return_val_if_fail (!g_path_is_absolute (file), FALSE);
1062   g_return_val_if_fail (search_dirs != NULL, FALSE);
1063 
1064   found_file = FALSE;
1065   data_dirs = search_dirs;
1066   output_path = NULL;
1067   while (*data_dirs != NULL &amp;&amp; !found_file)
1068     {
1069       g_free (output_path);
1070       output_path = NULL;
1071 
1072       fd = find_file_in_data_dirs (file, data_dirs, &amp;output_path,
1073                                    &amp;key_file_error);
1074 
1075       if (fd == -1)
1076         {
1077           if (key_file_error)
1078             g_propagate_error (error, key_file_error);
<span class="line-modified">1079     break;</span>
1080         }
1081 
1082       found_file = g_key_file_load_from_fd (key_file, fd, flags,
<span class="line-modified">1083                                       &amp;key_file_error);</span>
1084       close (fd);
1085 
1086       if (key_file_error)
1087         {
<span class="line-modified">1088     g_propagate_error (error, key_file_error);</span>
<span class="line-modified">1089     break;</span>
1090         }
1091     }
1092 
1093   if (found_file &amp;&amp; full_path)
1094     *full_path = output_path;
1095   else
1096     g_free (output_path);
1097 
1098   return found_file;
1099 }
1100 
1101 /**
1102  * g_key_file_load_from_data_dirs:
1103  * @key_file: an empty #GKeyFile struct
1104  * @file: (type filename): a relative path to a filename to open and parse
1105  * @full_path: (out) (type filename) (optional): return location for a string containing the full path
1106  *   of the file, or %NULL
1107  * @flags: flags from #GKeyFileFlags
1108  * @error: return location for a #GError, or %NULL
1109  *
1110  * This function looks for a key file named @file in the paths
1111  * returned from g_get_user_data_dir() and g_get_system_data_dirs(),
1112  * loads the file into @key_file and returns the file&#39;s full path in
1113  * @full_path.  If the file could not be loaded then an %error is
1114  * set to either a #GFileError or #GKeyFileError.
1115  *
1116  * Returns: %TRUE if a key file could be loaded, %FALSE othewise
1117  * Since: 2.6
1118  **/
1119 gboolean
1120 g_key_file_load_from_data_dirs (GKeyFile       *key_file,
<span class="line-modified">1121         const gchar    *file,</span>
<span class="line-modified">1122         gchar         **full_path,</span>
<span class="line-modified">1123         GKeyFileFlags   flags,</span>
<span class="line-modified">1124         GError        **error)</span>
1125 {
1126   gchar **all_data_dirs;
1127   const gchar * user_data_dir;
1128   const gchar * const * system_data_dirs;
1129   gsize i, j;
1130   gboolean found_file;
1131 
1132   g_return_val_if_fail (key_file != NULL, FALSE);
1133   g_return_val_if_fail (!g_path_is_absolute (file), FALSE);
1134 
1135   user_data_dir = g_get_user_data_dir ();
1136   system_data_dirs = g_get_system_data_dirs ();
1137   all_data_dirs = g_new (gchar *, g_strv_length ((gchar **)system_data_dirs) + 2);
1138 
1139   i = 0;
1140   all_data_dirs[i++] = g_strdup (user_data_dir);
1141 
1142   j = 0;
1143   while (system_data_dirs[j] != NULL)
1144     all_data_dirs[i++] = g_strdup (system_data_dirs[j++]);
</pre>
<hr />
<pre>
1208  *
1209  * Since: 2.32
1210  **/
1211 void
1212 g_key_file_unref (GKeyFile *key_file)
1213 {
1214   g_return_if_fail (key_file != NULL);
1215 
1216   if (g_atomic_int_dec_and_test (&amp;key_file-&gt;ref_count))
1217     {
1218       g_key_file_clear (key_file);
1219       g_slice_free (GKeyFile, key_file);
1220     }
1221 }
1222 
1223 /* If G_KEY_FILE_KEEP_TRANSLATIONS is not set, only returns
1224  * true for locales that match those in g_get_language_names().
1225  */
1226 static gboolean
1227 g_key_file_locale_is_interesting (GKeyFile    *key_file,
<span class="line-modified">1228           const gchar *locale)</span>
1229 {
1230   gsize i;
1231 
1232   if (key_file-&gt;flags &amp; G_KEY_FILE_KEEP_TRANSLATIONS)
1233     return TRUE;
1234 
1235   for (i = 0; key_file-&gt;locales[i] != NULL; i++)
1236     {
1237       if (g_ascii_strcasecmp (key_file-&gt;locales[i], locale) == 0)
<span class="line-modified">1238   return TRUE;</span>
1239     }
1240 
1241   return FALSE;
1242 }
1243 
1244 static void
1245 g_key_file_parse_line (GKeyFile     *key_file,
<span class="line-modified">1246            const gchar  *line,</span>
<span class="line-modified">1247            gsize         length,</span>
<span class="line-modified">1248            GError      **error)</span>
1249 {
1250   GError *parse_error = NULL;
1251   gchar *line_start;
1252 
1253   g_return_if_fail (key_file != NULL);
1254   g_return_if_fail (line != NULL);
1255 
1256   line_start = (gchar *) line;
1257   while (g_ascii_isspace (*line_start))
1258     line_start++;
1259 
1260   if (g_key_file_line_is_comment (line_start))
1261     g_key_file_parse_comment (key_file, line, length, &amp;parse_error);
1262   else if (g_key_file_line_is_group (line_start))
1263     g_key_file_parse_group (key_file, line_start,
<span class="line-modified">1264           length - (line_start - line),</span>
<span class="line-modified">1265           &amp;parse_error);</span>
1266   else if (g_key_file_line_is_key_value_pair (line_start))
1267     g_key_file_parse_key_value_pair (key_file, line_start,
<span class="line-modified">1268              length - (line_start - line),</span>
<span class="line-modified">1269              &amp;parse_error);</span>
1270   else
1271     {
1272       gchar *line_utf8 = g_utf8_make_valid (line, length);
1273       g_set_error (error, G_KEY_FILE_ERROR,
1274                    G_KEY_FILE_ERROR_PARSE,
1275                    _(&quot;Key file contains line &#39;%s&#39; which is not &quot;
1276                      &quot;a key-value pair, group, or comment&quot;),
1277                    line_utf8);
1278       g_free (line_utf8);
1279 
1280       return;
1281     }
1282 
1283   if (parse_error)
1284     g_propagate_error (error, parse_error);
1285 }
1286 
1287 static void
1288 g_key_file_parse_comment (GKeyFile     *key_file,
<span class="line-modified">1289         const gchar  *line,</span>
<span class="line-modified">1290         gsize         length,</span>
<span class="line-modified">1291         GError      **error)</span>
1292 {
1293   GKeyFileKeyValuePair *pair;
1294 
1295   if (!(key_file-&gt;flags &amp; G_KEY_FILE_KEEP_COMMENTS))
1296     return;
1297 
1298   g_warn_if_fail (key_file-&gt;current_group != NULL);
1299 
1300   pair = g_slice_new (GKeyFileKeyValuePair);
1301 #ifdef GSTREAMER_LITE
1302   if (pair == NULL) {
1303     g_warn_if_fail(pair != NULL);
1304     return;
1305   }
1306 #endif // GSTREAMER_LITE
1307   pair-&gt;key = NULL;
1308   pair-&gt;value = g_strndup (line, length);
1309 
1310   key_file-&gt;current_group-&gt;key_value_pairs =
1311     g_list_prepend (key_file-&gt;current_group-&gt;key_value_pairs, pair);
1312 }
1313 
1314 static void
1315 g_key_file_parse_group (GKeyFile     *key_file,
<span class="line-modified">1316       const gchar  *line,</span>
<span class="line-modified">1317       gsize         length,</span>
<span class="line-modified">1318       GError      **error)</span>
1319 {
1320   gchar *group_name;
1321   const gchar *group_name_start, *group_name_end;
1322 
1323   /* advance past opening &#39;[&#39;
1324    */
1325   group_name_start = line + 1;
1326   group_name_end = line + length - 1;
1327 
1328   while (*group_name_end != &#39;]&#39;)
1329     group_name_end--;
1330 
1331   group_name = g_strndup (group_name_start,
1332                           group_name_end - group_name_start);
1333 
1334   if (!g_key_file_is_group_name (group_name))
1335     {
1336       g_set_error (error, G_KEY_FILE_ERROR,
<span class="line-modified">1337        G_KEY_FILE_ERROR_PARSE,</span>
<span class="line-modified">1338        _(&quot;Invalid group name: %s&quot;), group_name);</span>
1339       g_free (group_name);
1340       return;
1341     }
1342 
1343   g_key_file_add_group (key_file, group_name);
1344   g_free (group_name);
1345 }
1346 
1347 static void
1348 g_key_file_parse_key_value_pair (GKeyFile     *key_file,
<span class="line-modified">1349          const gchar  *line,</span>
<span class="line-modified">1350          gsize         length,</span>
<span class="line-modified">1351          GError      **error)</span>
1352 {
1353   gchar *key, *value, *key_end, *value_start, *locale;
1354   gsize key_len, value_len;
1355 
1356   if (key_file-&gt;current_group == NULL || key_file-&gt;current_group-&gt;name == NULL)
1357     {
1358       g_set_error_literal (error, G_KEY_FILE_ERROR,
1359                            G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
1360                            _(&quot;Key file does not start with a group&quot;));
1361       return;
1362     }
1363 
1364   key_end = value_start = strchr (line, &#39;=&#39;);
1365 
1366   g_warn_if_fail (key_end != NULL);
1367 
1368   key_end--;
1369   value_start++;
1370 
1371   /* Pull the key name from the line (chomping trailing whitespace)
</pre>
<hr />
<pre>
1390 
1391   /* Pull the value from the line (chugging leading whitespace)
1392    */
1393   while (g_ascii_isspace (*value_start))
1394     value_start++;
1395 
1396   value_len = line + length - value_start + 1;
1397 
1398   value = g_strndup (value_start, value_len);
1399 
1400   g_warn_if_fail (key_file-&gt;start_group != NULL);
1401 
1402   if (key_file-&gt;current_group
1403       &amp;&amp; key_file-&gt;current_group-&gt;name
1404       &amp;&amp; strcmp (key_file-&gt;start_group-&gt;name,
1405                  key_file-&gt;current_group-&gt;name) == 0
1406       &amp;&amp; strcmp (key, &quot;Encoding&quot;) == 0)
1407     {
1408       if (g_ascii_strcasecmp (value, &quot;UTF-8&quot;) != 0)
1409         {
<span class="line-modified">1410     gchar *value_utf8 = g_utf8_make_valid (value, value_len);</span>
1411           g_set_error (error, G_KEY_FILE_ERROR,
1412                        G_KEY_FILE_ERROR_UNKNOWN_ENCODING,
1413                        _(&quot;Key file contains unsupported &quot;
<span class="line-modified">1414        &quot;encoding &#39;%s&#39;&quot;), value_utf8);</span>
<span class="line-modified">1415     g_free (value_utf8);</span>
1416 
1417           g_free (key);
1418           g_free (value);
1419           return;
1420         }
1421     }
1422 
1423   /* Is this key a translation? If so, is it one that we care about?
1424    */
1425   locale = key_get_locale (key);
1426 
1427   if (locale == NULL || g_key_file_locale_is_interesting (key_file, locale))
1428     {
1429       GKeyFileKeyValuePair *pair;
1430 
1431       pair = g_slice_new (GKeyFileKeyValuePair);
1432 #ifdef GSTREAMER_LITE
1433       if (pair == NULL) {
1434         if (locale != NULL) {
1435           g_free (locale);
</pre>
<hr />
<pre>
1452 }
1453 
1454 static gchar *
1455 key_get_locale (const gchar *key)
1456 {
1457   gchar *locale;
1458 
1459   locale = g_strrstr (key, &quot;[&quot;);
1460 
1461   if (locale &amp;&amp; strlen (locale) &lt;= 2)
1462     locale = NULL;
1463 
1464   if (locale)
1465     locale = g_strndup (locale + 1, strlen (locale) - 2);
1466 
1467   return locale;
1468 }
1469 
1470 static void
1471 g_key_file_parse_data (GKeyFile     *key_file,
<span class="line-modified">1472            const gchar  *data,</span>
<span class="line-modified">1473            gsize         length,</span>
<span class="line-modified">1474            GError      **error)</span>
1475 {
1476   GError *parse_error;
1477   gsize i;
1478 
1479   g_return_if_fail (key_file != NULL);
1480   g_return_if_fail (data != NULL || length == 0);
1481 
1482   parse_error = NULL;
1483 
1484   i = 0;
1485   while (i &lt; length)
1486     {
1487       if (data[i] == &#39;\n&#39;)
1488         {
<span class="line-modified">1489     if (key_file-&gt;parse_buffer-&gt;len &gt; 0</span>
<span class="line-modified">1490         &amp;&amp; (key_file-&gt;parse_buffer-&gt;str[key_file-&gt;parse_buffer-&gt;len - 1]</span>
<span class="line-modified">1491       == &#39;\r&#39;))</span>
<span class="line-modified">1492       g_string_erase (key_file-&gt;parse_buffer,</span>
<span class="line-modified">1493           key_file-&gt;parse_buffer-&gt;len - 1,</span>
<span class="line-modified">1494           1);</span>
1495 
1496           /* When a newline is encountered flush the parse buffer so that the
1497            * line can be parsed.  Note that completely blank lines won&#39;t show
1498            * up in the parse buffer, so they get parsed directly.
1499            */
1500           if (key_file-&gt;parse_buffer-&gt;len &gt; 0)
1501             g_key_file_flush_parse_buffer (key_file, &amp;parse_error);
1502           else
1503             g_key_file_parse_comment (key_file, &quot;&quot;, 1, &amp;parse_error);
1504 
1505           if (parse_error)
1506             {
1507               g_propagate_error (error, parse_error);
1508               return;
1509             }
1510           i++;
1511         }
1512       else
1513         {
1514           const gchar *start_of_line;
1515           const gchar *end_of_line;
1516           gsize line_length;
1517 
1518           start_of_line = data + i;
1519           end_of_line = memchr (start_of_line, &#39;\n&#39;, length - i);
1520 
1521           if (end_of_line == NULL)
1522             end_of_line = data + length;
1523 
1524           line_length = end_of_line - start_of_line;
1525 
1526           g_string_append_len (key_file-&gt;parse_buffer, start_of_line, line_length);
1527           i += line_length;
1528         }
1529     }
1530 }
1531 
1532 static void
1533 g_key_file_flush_parse_buffer (GKeyFile  *key_file,
<span class="line-modified">1534              GError   **error)</span>
1535 {
1536   GError *file_error = NULL;
1537 
1538   g_return_if_fail (key_file != NULL);
1539 
1540   file_error = NULL;
1541 
1542   if (key_file-&gt;parse_buffer-&gt;len &gt; 0)
1543     {
1544       g_key_file_parse_line (key_file, key_file-&gt;parse_buffer-&gt;str,
<span class="line-modified">1545            key_file-&gt;parse_buffer-&gt;len,</span>
<span class="line-modified">1546            &amp;file_error);</span>
1547       g_string_erase (key_file-&gt;parse_buffer, 0, -1);
1548 
1549       if (file_error)
1550         {
1551           g_propagate_error (error, file_error);
1552           return;
1553         }
1554     }
1555 }
1556 
1557 /**
1558  * g_key_file_to_data:
1559  * @key_file: a #GKeyFile
1560  * @length: (out) (optional): return location for the length of the
1561  *   returned string, or %NULL
1562  * @error: return location for a #GError, or %NULL
1563  *
1564  * This function outputs @key_file as a string.
1565  *
1566  * Note that this function never reports an error,
1567  * so it is safe to pass %NULL as @error.
1568  *
1569  * Returns: a newly allocated string holding
1570  *   the contents of the #GKeyFile
1571  *
1572  * Since: 2.6
1573  **/
1574 gchar *
1575 g_key_file_to_data (GKeyFile  *key_file,
<span class="line-modified">1576         gsize     *length,</span>
<span class="line-modified">1577         GError   **error)</span>
1578 {
1579   GString *data_string;
1580   GList *group_node, *key_file_node;
1581 
1582   g_return_val_if_fail (key_file != NULL, NULL);
1583 
1584   data_string = g_string_new (NULL);
1585 
1586   for (group_node = g_list_last (key_file-&gt;groups);
1587        group_node != NULL;
1588        group_node = group_node-&gt;prev)
1589     {
1590       GKeyFileGroup *group;
1591 
1592       group = (GKeyFileGroup *) group_node-&gt;data;
1593 
1594       /* separate groups by at least an empty line */
1595       if (data_string-&gt;len &gt;= 2 &amp;&amp;
1596           data_string-&gt;str[data_string-&gt;len - 2] != &#39;\n&#39;)
1597         g_string_append_c (data_string, &#39;\n&#39;);
</pre>
<hr />
<pre>
1626 /**
1627  * g_key_file_get_keys:
1628  * @key_file: a #GKeyFile
1629  * @group_name: a group name
1630  * @length: (out) (optional): return location for the number of keys returned, or %NULL
1631  * @error: return location for a #GError, or %NULL
1632  *
1633  * Returns all keys for the group name @group_name.  The array of
1634  * returned keys will be %NULL-terminated, so @length may
1635  * optionally be %NULL. In the event that the @group_name cannot
1636  * be found, %NULL is returned and @error is set to
1637  * #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
1638  *
1639  * Returns: (array zero-terminated=1) (transfer full): a newly-allocated %NULL-terminated array of strings.
1640  *     Use g_strfreev() to free it.
1641  *
1642  * Since: 2.6
1643  **/
1644 gchar **
1645 g_key_file_get_keys (GKeyFile     *key_file,
<span class="line-modified">1646          const gchar  *group_name,</span>
<span class="line-modified">1647          gsize        *length,</span>
<span class="line-modified">1648          GError      **error)</span>
1649 {
1650   GKeyFileGroup *group;
1651   GList *tmp;
1652   gchar **keys;
1653   gsize i, num_keys;
1654 
1655   g_return_val_if_fail (key_file != NULL, NULL);
1656   g_return_val_if_fail (group_name != NULL, NULL);
1657 
1658   group = g_key_file_lookup_group (key_file, group_name);
1659 
1660   if (!group)
1661     {
1662       g_set_error (error, G_KEY_FILE_ERROR,
1663                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
1664                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
1665 #ifdef GSTREAMER_LITE
1666                    group_name ? group_name : &quot;(null)&quot;);
1667 #else // GSTREAMER_LITE
1668                    group_name);
1669 #endif // GSTREAMER_LITE
1670       return NULL;
1671     }
1672 
1673   num_keys = 0;
1674   for (tmp = group-&gt;key_value_pairs; tmp; tmp = tmp-&gt;next)
1675     {
1676       GKeyFileKeyValuePair *pair;
1677 
1678       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
1679 
1680       if (pair-&gt;key)
<span class="line-modified">1681   num_keys++;</span>
1682     }
1683 
1684   keys = g_new (gchar *, num_keys + 1);
1685 
1686   i = num_keys - 1;
1687   for (tmp = group-&gt;key_value_pairs; tmp; tmp = tmp-&gt;next)
1688     {
1689       GKeyFileKeyValuePair *pair;
1690 
1691       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
1692 
1693       if (pair-&gt;key)
<span class="line-modified">1694   {</span>
<span class="line-modified">1695     keys[i] = g_strdup (pair-&gt;key);</span>
<span class="line-modified">1696     i--;</span>
<span class="line-modified">1697   }</span>
1698     }
1699 
1700   keys[num_keys] = NULL;
1701 
1702   if (length)
1703     *length = num_keys;
1704 
1705   return keys;
1706 }
1707 
1708 /**
1709  * g_key_file_get_start_group:
1710  * @key_file: a #GKeyFile
1711  *
1712  * Returns the name of the start group of the file.
1713  *
1714  * Returns: The start group of the key file.
1715  *
1716  * Since: 2.6
1717  **/
</pre>
<hr />
<pre>
1724     return g_strdup (key_file-&gt;start_group-&gt;name);
1725 
1726   return NULL;
1727 }
1728 
1729 /**
1730  * g_key_file_get_groups:
1731  * @key_file: a #GKeyFile
1732  * @length: (out) (optional): return location for the number of returned groups, or %NULL
1733  *
1734  * Returns all groups in the key file loaded with @key_file.
1735  * The array of returned groups will be %NULL-terminated, so
1736  * @length may optionally be %NULL.
1737  *
1738  * Returns: (array zero-terminated=1) (transfer full): a newly-allocated %NULL-terminated array of strings.
1739  *   Use g_strfreev() to free it.
1740  * Since: 2.6
1741  **/
1742 gchar **
1743 g_key_file_get_groups (GKeyFile *key_file,
<span class="line-modified">1744            gsize    *length)</span>
1745 {
1746   GList *group_node;
1747   gchar **groups;
1748   gsize i, num_groups;
1749 
1750   g_return_val_if_fail (key_file != NULL, NULL);
1751 
1752   num_groups = g_list_length (key_file-&gt;groups);
1753 
1754   g_return_val_if_fail (num_groups &gt; 0, NULL);
1755 
1756   group_node = g_list_last (key_file-&gt;groups);
1757 
1758   g_return_val_if_fail (((GKeyFileGroup *) group_node-&gt;data)-&gt;name == NULL, NULL);
1759 
1760   /* Only need num_groups instead of num_groups + 1
1761    * because the first group of the file (last in the
1762    * list) is always the comment group at the top,
1763    * which we skip
1764    */
</pre>
<hr />
<pre>
1803  * @group_name: a group name
1804  * @key: a key
1805  * @error: return location for a #GError, or %NULL
1806  *
1807  * Returns the raw value associated with @key under @group_name.
1808  * Use g_key_file_get_string() to retrieve an unescaped UTF-8 string.
1809  *
1810  * In the event the key cannot be found, %NULL is returned and
1811  * @error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
1812  * event that the @group_name cannot be found, %NULL is returned
1813  * and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
1814  *
1815  *
1816  * Returns: a newly allocated string or %NULL if the specified
1817  *  key cannot be found.
1818  *
1819  * Since: 2.6
1820  **/
1821 gchar *
1822 g_key_file_get_value (GKeyFile     *key_file,
<span class="line-modified">1823           const gchar  *group_name,</span>
<span class="line-modified">1824           const gchar  *key,</span>
<span class="line-modified">1825           GError      **error)</span>
1826 {
1827   GKeyFileGroup *group;
1828   GKeyFileKeyValuePair *pair;
1829   gchar *value = NULL;
1830 
1831   g_return_val_if_fail (key_file != NULL, NULL);
1832   g_return_val_if_fail (group_name != NULL, NULL);
1833   g_return_val_if_fail (key != NULL, NULL);
1834 
1835   group = g_key_file_lookup_group (key_file, group_name);
1836 
1837   if (!group)
1838     {
1839       g_set_error (error, G_KEY_FILE_ERROR,
1840                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
1841                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
1842 #ifdef GSTREAMER_LITE
1843                    group_name ? group_name : &quot;(null)&quot;);
1844 #else // GSTREAMER_LITE
1845                    group_name);
</pre>
<hr />
<pre>
1858 }
1859 
1860 /**
1861  * g_key_file_set_value:
1862  * @key_file: a #GKeyFile
1863  * @group_name: a group name
1864  * @key: a key
1865  * @value: a string
1866  *
1867  * Associates a new value with @key under @group_name.
1868  *
1869  * If @key cannot be found then it is created. If @group_name cannot
1870  * be found then it is created. To set an UTF-8 string which may contain
1871  * characters that need escaping (such as newlines or spaces), use
1872  * g_key_file_set_string().
1873  *
1874  * Since: 2.6
1875  **/
1876 void
1877 g_key_file_set_value (GKeyFile    *key_file,
<span class="line-modified">1878           const gchar *group_name,</span>
<span class="line-modified">1879           const gchar *key,</span>
<span class="line-modified">1880           const gchar *value)</span>
1881 {
1882   GKeyFileGroup *group;
1883   GKeyFileKeyValuePair *pair;
1884 
1885   g_return_if_fail (key_file != NULL);
1886   g_return_if_fail (g_key_file_is_group_name (group_name));
1887   g_return_if_fail (g_key_file_is_key_name (key));
1888   g_return_if_fail (value != NULL);
1889 
1890   group = g_key_file_lookup_group (key_file, group_name);
1891 
1892   if (!group)
1893     {
1894       g_key_file_add_group (key_file, group_name);
1895       group = (GKeyFileGroup *) key_file-&gt;groups-&gt;data;
1896 
1897       g_key_file_add_key (key_file, group, key, value);
1898     }
1899   else
1900     {
</pre>
<hr />
<pre>
1916  * @group_name: a group name
1917  * @key: a key
1918  * @error: return location for a #GError, or %NULL
1919  *
1920  * Returns the string value associated with @key under @group_name.
1921  * Unlike g_key_file_get_value(), this function handles escape sequences
1922  * like \s.
1923  *
1924  * In the event the key cannot be found, %NULL is returned and
1925  * @error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
1926  * event that the @group_name cannot be found, %NULL is returned
1927  * and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
1928  *
1929  * Returns: a newly allocated string or %NULL if the specified
1930  *   key cannot be found.
1931  *
1932  * Since: 2.6
1933  **/
1934 gchar *
1935 g_key_file_get_string (GKeyFile     *key_file,
<span class="line-modified">1936            const gchar  *group_name,</span>
<span class="line-modified">1937            const gchar  *key,</span>
<span class="line-modified">1938            GError      **error)</span>
1939 {
1940   gchar *value, *string_value;
1941   GError *key_file_error;
1942 
1943   g_return_val_if_fail (key_file != NULL, NULL);
1944   g_return_val_if_fail (group_name != NULL, NULL);
1945   g_return_val_if_fail (key != NULL, NULL);
1946 
1947   key_file_error = NULL;
1948 
1949   value = g_key_file_get_value (key_file, group_name, key, &amp;key_file_error);
1950 
1951   if (key_file_error)
1952     {
1953       g_propagate_error (error, key_file_error);
1954       return NULL;
1955     }
1956 
1957   if (!g_utf8_validate (value, -1, NULL))
1958     {
1959       gchar *value_utf8 = g_utf8_make_valid (value, -1);
1960       g_set_error (error, G_KEY_FILE_ERROR,
1961                    G_KEY_FILE_ERROR_UNKNOWN_ENCODING,
1962                    _(&quot;Key file contains key &#39;%s&#39; with value &#39;%s&#39; &quot;
1963                      &quot;which is not UTF-8&quot;), key, value_utf8);
1964       g_free (value_utf8);
1965       g_free (value);
1966 
1967       return NULL;
1968     }
1969 
1970   string_value = g_key_file_parse_value_as_string (key_file, value, NULL,
<span class="line-modified">1971                &amp;key_file_error);</span>
1972   g_free (value);
1973 
1974   if (key_file_error)
1975     {
1976       if (g_error_matches (key_file_error,
1977                            G_KEY_FILE_ERROR,
1978                            G_KEY_FILE_ERROR_INVALID_VALUE))
1979         {
1980           g_set_error (error, G_KEY_FILE_ERROR,
1981                        G_KEY_FILE_ERROR_INVALID_VALUE,
1982                        _(&quot;Key file contains key &#39;%s&#39; &quot;
1983                          &quot;which has a value that cannot be interpreted.&quot;),
1984                        key);
1985           g_error_free (key_file_error);
1986         }
1987       else
1988         g_propagate_error (error, key_file_error);
1989     }
1990 
1991   return string_value;
1992 }
1993 
1994 /**
1995  * g_key_file_set_string:
1996  * @key_file: a #GKeyFile
1997  * @group_name: a group name
1998  * @key: a key
1999  * @string: a string
2000  *
2001  * Associates a new string value with @key under @group_name.
2002  * If @key cannot be found then it is created.
2003  * If @group_name cannot be found then it is created.
2004  * Unlike g_key_file_set_value(), this function handles characters
2005  * that need escaping, such as newlines.
2006  *
2007  * Since: 2.6
2008  **/
2009 void
2010 g_key_file_set_string (GKeyFile    *key_file,
<span class="line-modified">2011            const gchar *group_name,</span>
<span class="line-modified">2012            const gchar *key,</span>
<span class="line-modified">2013            const gchar *string)</span>
2014 {
2015   gchar *value;
2016 
2017   g_return_if_fail (key_file != NULL);
2018   g_return_if_fail (string != NULL);
2019 
2020   value = g_key_file_parse_string_as_value (key_file, string, FALSE);
2021   g_key_file_set_value (key_file, group_name, key, value);
2022   g_free (value);
2023 }
2024 
2025 /**
2026  * g_key_file_get_string_list:
2027  * @key_file: a #GKeyFile
2028  * @group_name: a group name
2029  * @key: a key
2030  * @length: (out) (optional): return location for the number of returned strings, or %NULL
2031  * @error: return location for a #GError, or %NULL
2032  *
2033  * Returns the values associated with @key under @group_name.
2034  *
2035  * In the event the key cannot be found, %NULL is returned and
2036  * @error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
2037  * event that the @group_name cannot be found, %NULL is returned
2038  * and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
2039  *
2040  * Returns: (array zero-terminated=1 length=length) (element-type utf8) (transfer full):
2041  *  a %NULL-terminated string array or %NULL if the specified
2042  *  key cannot be found. The array should be freed with g_strfreev().
2043  *
2044  * Since: 2.6
2045  **/
2046 gchar **
2047 g_key_file_get_string_list (GKeyFile     *key_file,
<span class="line-modified">2048           const gchar  *group_name,</span>
<span class="line-modified">2049           const gchar  *key,</span>
<span class="line-modified">2050           gsize        *length,</span>
<span class="line-modified">2051           GError      **error)</span>
2052 {
2053   GError *key_file_error = NULL;
2054   gchar *value, *string_value, **values;
2055   gint i, len;
2056   GSList *p, *pieces = NULL;
2057 
2058   g_return_val_if_fail (key_file != NULL, NULL);
2059   g_return_val_if_fail (group_name != NULL, NULL);
2060   g_return_val_if_fail (key != NULL, NULL);
2061 
2062   if (length)
2063     *length = 0;
2064 
2065   value = g_key_file_get_value (key_file, group_name, key, &amp;key_file_error);
2066 
2067   if (key_file_error)
2068     {
2069       g_propagate_error (error, key_file_error);
2070       return NULL;
2071     }
</pre>
<hr />
<pre>
2120 
2121   return values;
2122 }
2123 
2124 /**
2125  * g_key_file_set_string_list:
2126  * @key_file: a #GKeyFile
2127  * @group_name: a group name
2128  * @key: a key
2129  * @list: (array zero-terminated=1 length=length) (element-type utf8): an array of string values
2130  * @length: number of string values in @list
2131  *
2132  * Associates a list of string values for @key under @group_name.
2133  * If @key cannot be found then it is created.
2134  * If @group_name cannot be found then it is created.
2135  *
2136  * Since: 2.6
2137  **/
2138 void
2139 g_key_file_set_string_list (GKeyFile            *key_file,
<span class="line-modified">2140           const gchar         *group_name,</span>
<span class="line-modified">2141           const gchar         *key,</span>
<span class="line-modified">2142           const gchar * const  list[],</span>
<span class="line-modified">2143           gsize                length)</span>
2144 {
2145   GString *value_list;
2146   gsize i;
2147 
2148   g_return_if_fail (key_file != NULL);
2149   g_return_if_fail (list != NULL || length == 0);
2150 
2151   value_list = g_string_sized_new (length * 128);
2152 #ifdef GSTREAMER_LITE
2153   if (value_list == NULL) {
2154     return;
2155   }
2156 #endif // GSTREAMER_LITE
2157   for (i = 0; i &lt; length &amp;&amp; list[i] != NULL; i++)
2158     {
2159       gchar *value;
2160 
2161       value = g_key_file_parse_string_as_value (key_file, list[i], TRUE);
2162       g_string_append (value_list, value);
2163       g_string_append_c (value_list, key_file-&gt;list_separator);
</pre>
<hr />
<pre>
2167 
2168   g_key_file_set_value (key_file, group_name, key, value_list-&gt;str);
2169   g_string_free (value_list, TRUE);
2170 }
2171 
2172 /**
2173  * g_key_file_set_locale_string:
2174  * @key_file: a #GKeyFile
2175  * @group_name: a group name
2176  * @key: a key
2177  * @locale: a locale identifier
2178  * @string: a string
2179  *
2180  * Associates a string value for @key and @locale under @group_name.
2181  * If the translation for @key cannot be found then it is created.
2182  *
2183  * Since: 2.6
2184  **/
2185 void
2186 g_key_file_set_locale_string (GKeyFile     *key_file,
<span class="line-modified">2187             const gchar  *group_name,</span>
<span class="line-modified">2188             const gchar  *key,</span>
<span class="line-modified">2189             const gchar  *locale,</span>
<span class="line-modified">2190             const gchar  *string)</span>
2191 {
2192   gchar *full_key, *value;
2193 
2194   g_return_if_fail (key_file != NULL);
2195   g_return_if_fail (key != NULL);
2196   g_return_if_fail (locale != NULL);
2197   g_return_if_fail (string != NULL);
2198 
2199   value = g_key_file_parse_string_as_value (key_file, string, FALSE);
2200   full_key = g_strdup_printf (&quot;%s[%s]&quot;, key, locale);
2201   g_key_file_set_value (key_file, group_name, full_key, value);
2202   g_free (full_key);
2203   g_free (value);
2204 }
2205 
2206 /**
2207  * g_key_file_get_locale_string:
2208  * @key_file: a #GKeyFile
2209  * @group_name: a group name
2210  * @key: a key
</pre>
<hr />
<pre>
2214  * Returns the value associated with @key under @group_name
2215  * translated in the given @locale if available.  If @locale is
2216  * %NULL then the current locale is assumed.
2217  *
2218  * If @locale is to be non-%NULL, or if the current locale will change over
2219  * the lifetime of the #GKeyFile, it must be loaded with
2220  * %G_KEY_FILE_KEEP_TRANSLATIONS in order to load strings for all locales.
2221  *
2222  * If @key cannot be found then %NULL is returned and @error is set
2223  * to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the value associated
2224  * with @key cannot be interpreted or no suitable translation can
2225  * be found then the untranslated value is returned.
2226  *
2227  * Returns: a newly allocated string or %NULL if the specified
2228  *   key cannot be found.
2229  *
2230  * Since: 2.6
2231  **/
2232 gchar *
2233 g_key_file_get_locale_string (GKeyFile     *key_file,
<span class="line-modified">2234             const gchar  *group_name,</span>
<span class="line-modified">2235             const gchar  *key,</span>
<span class="line-modified">2236             const gchar  *locale,</span>
<span class="line-modified">2237             GError      **error)</span>
2238 {
2239   gchar *candidate_key, *translated_value;
2240   GError *key_file_error;
2241   gchar **languages;
2242   gboolean free_languages = FALSE;
2243   gint i;
2244 
2245   g_return_val_if_fail (key_file != NULL, NULL);
2246   g_return_val_if_fail (group_name != NULL, NULL);
2247   g_return_val_if_fail (key != NULL, NULL);
2248 
2249   candidate_key = NULL;
2250   translated_value = NULL;
2251   key_file_error = NULL;
2252 
2253   if (locale)
2254     {
2255       languages = g_get_locale_variants (locale);
2256       free_languages = TRUE;
2257     }
2258   else
2259     {
2260       languages = (gchar **) g_get_language_names ();
2261       free_languages = FALSE;
2262     }
2263 
2264   for (i = 0; languages[i]; i++)
2265     {
2266       candidate_key = g_strdup_printf (&quot;%s[%s]&quot;, key, languages[i]);
2267 
2268       translated_value = g_key_file_get_string (key_file,
<span class="line-modified">2269             group_name,</span>
<span class="line-modified">2270             candidate_key, NULL);</span>
2271       g_free (candidate_key);
2272 
2273       if (translated_value)
<span class="line-modified">2274   break;</span>
2275 
2276       g_free (translated_value);
2277       translated_value = NULL;
2278    }
2279 
2280   /* Fallback to untranslated key
2281    */
2282   if (!translated_value)
2283     {
2284       translated_value = g_key_file_get_string (key_file, group_name, key,
<span class="line-modified">2285             &amp;key_file_error);</span>
2286 
2287       if (!translated_value)
2288         g_propagate_error (error, key_file_error);
2289     }
2290 
2291   if (free_languages)
2292     g_strfreev (languages);
2293 
2294   return translated_value;
2295 }
2296 
2297 /**
2298  * g_key_file_get_locale_for_key:
2299  * @key_file: a #GKeyFile
2300  * @group_name: a group name
2301  * @key: a key
2302  * @locale: (nullable): a locale identifier or %NULL
2303  *
2304  * Returns the actual locale which the result of
2305  * g_key_file_get_locale_string() or g_key_file_get_locale_string_list()
</pre>
<hr />
<pre>
2374  *
2375  * If @locale is to be non-%NULL, or if the current locale will change over
2376  * the lifetime of the #GKeyFile, it must be loaded with
2377  * %G_KEY_FILE_KEEP_TRANSLATIONS in order to load strings for all locales.
2378  *
2379  * If @key cannot be found then %NULL is returned and @error is set
2380  * to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the values associated
2381  * with @key cannot be interpreted or no suitable translations
2382  * can be found then the untranslated values are returned. The
2383  * returned array is %NULL-terminated, so @length may optionally
2384  * be %NULL.
2385  *
2386  * Returns: (array zero-terminated=1 length=length) (element-type utf8) (transfer full): a newly allocated %NULL-terminated string array
2387  *   or %NULL if the key isn&#39;t found. The string array should be freed
2388  *   with g_strfreev().
2389  *
2390  * Since: 2.6
2391  **/
2392 gchar **
2393 g_key_file_get_locale_string_list (GKeyFile     *key_file,
<span class="line-modified">2394            const gchar  *group_name,</span>
<span class="line-modified">2395            const gchar  *key,</span>
<span class="line-modified">2396            const gchar  *locale,</span>
<span class="line-modified">2397            gsize        *length,</span>
<span class="line-modified">2398            GError      **error)</span>
2399 {
2400   GError *key_file_error;
2401   gchar **values, *value;
2402   char list_separator[2];
2403   gsize len;
2404 
2405   g_return_val_if_fail (key_file != NULL, NULL);
2406   g_return_val_if_fail (group_name != NULL, NULL);
2407   g_return_val_if_fail (key != NULL, NULL);
2408 
2409   key_file_error = NULL;
2410 
2411   value = g_key_file_get_locale_string (key_file, group_name,
<span class="line-modified">2412           key, locale,</span>
<span class="line-modified">2413           &amp;key_file_error);</span>
2414 
2415   if (key_file_error)
2416     g_propagate_error (error, key_file_error);
2417 
2418   if (!value)
2419     {
2420       if (length)
2421         *length = 0;
2422       return NULL;
2423     }
2424 
2425   len = strlen (value);
2426   if (value[len - 1] == key_file-&gt;list_separator)
2427     value[len - 1] = &#39;\0&#39;;
2428 
2429   list_separator[0] = key_file-&gt;list_separator;
2430   list_separator[1] = &#39;\0&#39;;
2431   values = g_strsplit (value, list_separator, 0);
2432 
2433   g_free (value);
</pre>
<hr />
<pre>
2438   return values;
2439 }
2440 
2441 /**
2442  * g_key_file_set_locale_string_list:
2443  * @key_file: a #GKeyFile
2444  * @group_name: a group name
2445  * @key: a key
2446  * @locale: a locale identifier
2447  * @list: (array zero-terminated=1 length=length): a %NULL-terminated array of locale string values
2448  * @length: the length of @list
2449  *
2450  * Associates a list of string values for @key and @locale under
2451  * @group_name.  If the translation for @key cannot be found then
2452  * it is created.
2453  *
2454  * Since: 2.6
2455  **/
2456 void
2457 g_key_file_set_locale_string_list (GKeyFile            *key_file,
<span class="line-modified">2458            const gchar         *group_name,</span>
<span class="line-modified">2459            const gchar         *key,</span>
<span class="line-modified">2460            const gchar         *locale,</span>
<span class="line-modified">2461            const gchar * const  list[],</span>
<span class="line-modified">2462            gsize                length)</span>
2463 {
2464   GString *value_list;
2465   gchar *full_key;
2466   gsize i;
2467 
2468   g_return_if_fail (key_file != NULL);
2469   g_return_if_fail (key != NULL);
2470   g_return_if_fail (locale != NULL);
2471   g_return_if_fail (length != 0);
2472 
2473   value_list = g_string_sized_new (length * 128);
2474 #ifdef GSTREAMER_LITE
2475   if (value_list == NULL) {
2476     return;
2477   }
2478 #endif // GSTREAMER_LITE
2479   for (i = 0; i &lt; length &amp;&amp; list[i] != NULL; i++)
2480     {
2481       gchar *value;
2482 
</pre>
<hr />
<pre>
2498  * @key_file: a #GKeyFile
2499  * @group_name: a group name
2500  * @key: a key
2501  * @error: return location for a #GError
2502  *
2503  * Returns the value associated with @key under @group_name as a
2504  * boolean.
2505  *
2506  * If @key cannot be found then %FALSE is returned and @error is set
2507  * to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value
2508  * associated with @key cannot be interpreted as a boolean then %FALSE
2509  * is returned and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
2510  *
2511  * Returns: the value associated with the key as a boolean,
2512  *    or %FALSE if the key was not found or could not be parsed.
2513  *
2514  * Since: 2.6
2515  **/
2516 gboolean
2517 g_key_file_get_boolean (GKeyFile     *key_file,
<span class="line-modified">2518       const gchar  *group_name,</span>
<span class="line-modified">2519       const gchar  *key,</span>
<span class="line-modified">2520       GError      **error)</span>
2521 {
2522   GError *key_file_error = NULL;
2523   gchar *value;
2524   gboolean bool_value;
2525 
2526   g_return_val_if_fail (key_file != NULL, FALSE);
2527   g_return_val_if_fail (group_name != NULL, FALSE);
2528   g_return_val_if_fail (key != NULL, FALSE);
2529 
2530   value = g_key_file_get_value (key_file, group_name, key, &amp;key_file_error);
2531 
2532   if (!value)
2533     {
2534       g_propagate_error (error, key_file_error);
2535       return FALSE;
2536     }
2537 
2538   bool_value = g_key_file_parse_value_as_boolean (key_file, value,
<span class="line-modified">2539               &amp;key_file_error);</span>
2540   g_free (value);
2541 
2542   if (key_file_error)
2543     {
2544       if (g_error_matches (key_file_error,
2545                            G_KEY_FILE_ERROR,
2546                            G_KEY_FILE_ERROR_INVALID_VALUE))
2547         {
2548           g_set_error (error, G_KEY_FILE_ERROR,
2549                        G_KEY_FILE_ERROR_INVALID_VALUE,
2550                        _(&quot;Key file contains key &#39;%s&#39; &quot;
2551                          &quot;which has a value that cannot be interpreted.&quot;),
2552                        key);
2553           g_error_free (key_file_error);
2554         }
2555       else
2556         g_propagate_error (error, key_file_error);
2557     }
2558 
2559   return bool_value;
2560 }
2561 
2562 /**
2563  * g_key_file_set_boolean:
2564  * @key_file: a #GKeyFile
2565  * @group_name: a group name
2566  * @key: a key
2567  * @value: %TRUE or %FALSE
2568  *
2569  * Associates a new boolean value with @key under @group_name.
2570  * If @key cannot be found then it is created.
2571  *
2572  * Since: 2.6
2573  **/
2574 void
2575 g_key_file_set_boolean (GKeyFile    *key_file,
<span class="line-modified">2576       const gchar *group_name,</span>
<span class="line-modified">2577       const gchar *key,</span>
<span class="line-modified">2578       gboolean     value)</span>
2579 {
2580   gchar *result;
2581 
2582   g_return_if_fail (key_file != NULL);
2583 
2584   result = g_key_file_parse_boolean_as_value (key_file, value);
2585   g_key_file_set_value (key_file, group_name, key, result);
2586   g_free (result);
2587 }
2588 
2589 /**
2590  * g_key_file_get_boolean_list:
2591  * @key_file: a #GKeyFile
2592  * @group_name: a group name
2593  * @key: a key
2594  * @length: (out): the number of booleans returned
2595  * @error: return location for a #GError
2596  *
2597  * Returns the values associated with @key under @group_name as
2598  * booleans.
2599  *
2600  * If @key cannot be found then %NULL is returned and @error is set to
2601  * #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
2602  * with @key cannot be interpreted as booleans then %NULL is returned
2603  * and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
2604  *
2605  * Returns: (array length=length) (element-type gboolean) (transfer container):
2606  *    the values associated with the key as a list of booleans, or %NULL if the
2607  *    key was not found or could not be parsed. The returned list of booleans
2608  *    should be freed with g_free() when no longer needed.
2609  *
2610  * Since: 2.6
2611  **/
2612 gboolean *
2613 g_key_file_get_boolean_list (GKeyFile     *key_file,
<span class="line-modified">2614            const gchar  *group_name,</span>
<span class="line-modified">2615            const gchar  *key,</span>
<span class="line-modified">2616            gsize        *length,</span>
<span class="line-modified">2617            GError      **error)</span>
2618 {
2619   GError *key_file_error;
2620   gchar **values;
2621   gboolean *bool_values;
2622   gsize i, num_bools;
2623 
2624   g_return_val_if_fail (key_file != NULL, NULL);
2625   g_return_val_if_fail (group_name != NULL, NULL);
2626   g_return_val_if_fail (key != NULL, NULL);
2627 
2628   if (length)
2629     *length = 0;
2630 
2631   key_file_error = NULL;
2632 
2633   values = g_key_file_get_string_list (key_file, group_name, key,
<span class="line-modified">2634                &amp;num_bools, &amp;key_file_error);</span>
2635 
2636   if (key_file_error)
2637     g_propagate_error (error, key_file_error);
2638 
2639   if (!values)
2640     return NULL;
2641 
2642   bool_values = g_new (gboolean, num_bools);
2643 
2644   for (i = 0; i &lt; num_bools; i++)
2645     {
2646       bool_values[i] = g_key_file_parse_value_as_boolean (key_file,
<span class="line-modified">2647                 values[i],</span>
<span class="line-modified">2648                 &amp;key_file_error);</span>
2649 
2650       if (key_file_error)
2651         {
2652           g_propagate_error (error, key_file_error);
2653           g_strfreev (values);
2654           g_free (bool_values);
2655 
2656           return NULL;
2657         }
2658     }
2659   g_strfreev (values);
2660 
2661   if (length)
2662     *length = num_bools;
2663 
2664   return bool_values;
2665 }
2666 
2667 /**
2668  * g_key_file_set_boolean_list:
2669  * @key_file: a #GKeyFile
2670  * @group_name: a group name
2671  * @key: a key
2672  * @list: (array length=length): an array of boolean values
2673  * @length: length of @list
2674  *
2675  * Associates a list of boolean values with @key under @group_name.
2676  * If @key cannot be found then it is created.
2677  * If @group_name is %NULL, the start_group is used.
2678  *
2679  * Since: 2.6
2680  **/
2681 void
2682 g_key_file_set_boolean_list (GKeyFile    *key_file,
<span class="line-modified">2683            const gchar *group_name,</span>
<span class="line-modified">2684            const gchar *key,</span>
<span class="line-modified">2685            gboolean     list[],</span>
<span class="line-modified">2686            gsize        length)</span>
2687 {
2688   GString *value_list;
2689   gsize i;
2690 
2691   g_return_if_fail (key_file != NULL);
2692   g_return_if_fail (list != NULL);
2693 
2694   value_list = g_string_sized_new (length * 8);
2695 #ifdef GSTREAMER_LITE
2696   if (value_list == NULL) {
2697     return;
2698   }
2699 #endif // GSTREAMER_LITE
2700   for (i = 0; i &lt; length; i++)
2701     {
2702       gchar *value;
2703 
2704       value = g_key_file_parse_boolean_as_value (key_file, list[i]);
2705 
2706       g_string_append (value_list, value);
</pre>
<hr />
<pre>
2719  * @group_name: a group name
2720  * @key: a key
2721  * @error: return location for a #GError
2722  *
2723  * Returns the value associated with @key under @group_name as an
2724  * integer.
2725  *
2726  * If @key cannot be found then 0 is returned and @error is set to
2727  * #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated
2728  * with @key cannot be interpreted as an integer, or is out of range
2729  * for a #gint, then 0 is returned
2730  * and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
2731  *
2732  * Returns: the value associated with the key as an integer, or
2733  *     0 if the key was not found or could not be parsed.
2734  *
2735  * Since: 2.6
2736  **/
2737 gint
2738 g_key_file_get_integer (GKeyFile     *key_file,
<span class="line-modified">2739       const gchar  *group_name,</span>
<span class="line-modified">2740       const gchar  *key,</span>
<span class="line-modified">2741       GError      **error)</span>
2742 {
2743   GError *key_file_error;
2744   gchar *value;
2745   gint int_value;
2746 
2747   g_return_val_if_fail (key_file != NULL, -1);
2748   g_return_val_if_fail (group_name != NULL, -1);
2749   g_return_val_if_fail (key != NULL, -1);
2750 
2751   key_file_error = NULL;
2752 
2753   value = g_key_file_get_value (key_file, group_name, key, &amp;key_file_error);
2754 
2755   if (key_file_error)
2756     {
2757       g_propagate_error (error, key_file_error);
2758       return 0;
2759     }
2760 
2761   int_value = g_key_file_parse_value_as_integer (key_file, value,
<span class="line-modified">2762              &amp;key_file_error);</span>
2763   g_free (value);
2764 
2765   if (key_file_error)
2766     {
2767       if (g_error_matches (key_file_error,
2768                            G_KEY_FILE_ERROR,
2769                            G_KEY_FILE_ERROR_INVALID_VALUE))
2770         {
2771           g_set_error (error, G_KEY_FILE_ERROR,
2772                        G_KEY_FILE_ERROR_INVALID_VALUE,
2773                        _(&quot;Key file contains key &#39;%s&#39; in group &#39;%s&#39; &quot;
2774                          &quot;which has a value that cannot be interpreted.&quot;),
2775                          key, group_name);
2776           g_error_free (key_file_error);
2777         }
2778       else
2779         g_propagate_error (error, key_file_error);
2780     }
2781 
2782   return int_value;
2783 }
2784 
2785 /**
2786  * g_key_file_set_integer:
2787  * @key_file: a #GKeyFile
2788  * @group_name: a group name
2789  * @key: a key
2790  * @value: an integer value
2791  *
2792  * Associates a new integer value with @key under @group_name.
2793  * If @key cannot be found then it is created.
2794  *
2795  * Since: 2.6
2796  **/
2797 void
2798 g_key_file_set_integer (GKeyFile    *key_file,
<span class="line-modified">2799       const gchar *group_name,</span>
<span class="line-modified">2800       const gchar *key,</span>
<span class="line-modified">2801       gint         value)</span>
2802 {
2803   gchar *result;
2804 
2805   g_return_if_fail (key_file != NULL);
2806 
2807   result = g_key_file_parse_integer_as_value (key_file, value);
2808   g_key_file_set_value (key_file, group_name, key, result);
2809   g_free (result);
2810 }
2811 
2812 /**
2813  * g_key_file_get_int64:
2814  * @key_file: a non-%NULL #GKeyFile
2815  * @group_name: a non-%NULL group name
2816  * @key: a non-%NULL key
2817  * @error: return location for a #GError
2818  *
2819  * Returns the value associated with @key under @group_name as a signed
2820  * 64-bit integer. This is similar to g_key_file_get_integer() but can return
2821  * 64-bit results without truncation.
</pre>
<hr />
<pre>
2972  * @error: return location for a #GError
2973  *
2974  * Returns the values associated with @key under @group_name as
2975  * integers.
2976  *
2977  * If @key cannot be found then %NULL is returned and @error is set to
2978  * #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
2979  * with @key cannot be interpreted as integers, or are out of range for
2980  * #gint, then %NULL is returned
2981  * and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
2982  *
2983  * Returns: (array length=length) (element-type gint) (transfer container):
2984  *     the values associated with the key as a list of integers, or %NULL if
2985  *     the key was not found or could not be parsed. The returned list of
2986  *     integers should be freed with g_free() when no longer needed.
2987  *
2988  * Since: 2.6
2989  **/
2990 gint *
2991 g_key_file_get_integer_list (GKeyFile     *key_file,
<span class="line-modified">2992            const gchar  *group_name,</span>
<span class="line-modified">2993            const gchar  *key,</span>
<span class="line-modified">2994            gsize        *length,</span>
<span class="line-modified">2995            GError      **error)</span>
2996 {
2997   GError *key_file_error = NULL;
2998   gchar **values;
2999   gint *int_values;
3000   gsize i, num_ints;
3001 
3002   g_return_val_if_fail (key_file != NULL, NULL);
3003   g_return_val_if_fail (group_name != NULL, NULL);
3004   g_return_val_if_fail (key != NULL, NULL);
3005 
3006   if (length)
3007     *length = 0;
3008 
3009   values = g_key_file_get_string_list (key_file, group_name, key,
<span class="line-modified">3010                &amp;num_ints, &amp;key_file_error);</span>
3011 
3012   if (key_file_error)
3013     g_propagate_error (error, key_file_error);
3014 
3015   if (!values)
3016     return NULL;
3017 
3018   int_values = g_new (gint, num_ints);
3019 
3020   for (i = 0; i &lt; num_ints; i++)
3021     {
3022       int_values[i] = g_key_file_parse_value_as_integer (key_file,
<span class="line-modified">3023                values[i],</span>
<span class="line-modified">3024                &amp;key_file_error);</span>
3025 
3026       if (key_file_error)
3027         {
3028           g_propagate_error (error, key_file_error);
3029           g_strfreev (values);
3030           g_free (int_values);
3031 
3032           return NULL;
3033         }
3034     }
3035   g_strfreev (values);
3036 
3037   if (length)
3038     *length = num_ints;
3039 
3040   return int_values;
3041 }
3042 
3043 /**
3044  * g_key_file_set_integer_list:
3045  * @key_file: a #GKeyFile
3046  * @group_name: a group name
3047  * @key: a key
3048  * @list: (array length=length): an array of integer values
3049  * @length: number of integer values in @list
3050  *
3051  * Associates a list of integer values with @key under @group_name.
3052  * If @key cannot be found then it is created.
3053  *
3054  * Since: 2.6
3055  **/
3056 void
3057 g_key_file_set_integer_list (GKeyFile    *key_file,
<span class="line-modified">3058            const gchar *group_name,</span>
<span class="line-modified">3059            const gchar *key,</span>
<span class="line-modified">3060            gint         list[],</span>
<span class="line-modified">3061            gsize        length)</span>
3062 {
3063   GString *values;
3064   gsize i;
3065 
3066   g_return_if_fail (key_file != NULL);
3067   g_return_if_fail (list != NULL);
3068 
3069   values = g_string_sized_new (length * 16);
3070 #ifdef GSTREAMER_LITE
3071   if (values == NULL) {
3072     return;
3073   }
3074 #endif // GSTREAMER_LITE
3075   for (i = 0; i &lt; length; i++)
3076     {
3077       gchar *value;
3078 
3079       value = g_key_file_parse_integer_as_value (key_file, list[i]);
3080 
3081       g_string_append (values, value);
</pre>
<hr />
<pre>
3144         {
3145           g_set_error (error, G_KEY_FILE_ERROR,
3146                        G_KEY_FILE_ERROR_INVALID_VALUE,
3147                        _(&quot;Key file contains key &#39;%s&#39; in group &#39;%s&#39; &quot;
3148                          &quot;which has a value that cannot be interpreted.&quot;),
3149                        key, group_name);
3150           g_error_free (key_file_error);
3151         }
3152       else
3153         g_propagate_error (error, key_file_error);
3154     }
3155 
3156   return double_value;
3157 }
3158 
3159 /**
3160  * g_key_file_set_double:
3161  * @key_file: a #GKeyFile
3162  * @group_name: a group name
3163  * @key: a key
<span class="line-modified">3164  * @value: a double value</span>
3165  *
3166  * Associates a new double value with @key under @group_name.
3167  * If @key cannot be found then it is created.
3168  *
3169  * Since: 2.12
3170  **/
3171 void
3172 g_key_file_set_double  (GKeyFile    *key_file,
3173                         const gchar *group_name,
3174                         const gchar *key,
3175                         gdouble      value)
3176 {
3177   gchar result[G_ASCII_DTOSTR_BUF_SIZE];
3178 
3179   g_return_if_fail (key_file != NULL);
3180 
3181   g_ascii_dtostr (result, sizeof (result), value);
3182   g_key_file_set_value (key_file, group_name, key, result);
3183 }
3184 
</pre>
<hr />
<pre>
3221   g_return_val_if_fail (group_name != NULL, NULL);
3222   g_return_val_if_fail (key != NULL, NULL);
3223 
3224   if (length)
3225     *length = 0;
3226 
3227   values = g_key_file_get_string_list (key_file, group_name, key,
3228                                        &amp;num_doubles, &amp;key_file_error);
3229 
3230   if (key_file_error)
3231     g_propagate_error (error, key_file_error);
3232 
3233   if (!values)
3234     return NULL;
3235 
3236   double_values = g_new (gdouble, num_doubles);
3237 
3238   for (i = 0; i &lt; num_doubles; i++)
3239     {
3240       double_values[i] = g_key_file_parse_value_as_double (key_file,
<span class="line-modified">3241                  values[i],</span>
<span class="line-modified">3242                  &amp;key_file_error);</span>
3243 
3244       if (key_file_error)
3245         {
3246           g_propagate_error (error, key_file_error);
3247           g_strfreev (values);
3248           g_free (double_values);
3249 
3250           return NULL;
3251         }
3252     }
3253   g_strfreev (values);
3254 
3255   if (length)
3256     *length = num_doubles;
3257 
3258   return double_values;
3259 }
3260 
3261 /**
3262  * g_key_file_set_double_list:
3263  * @key_file: a #GKeyFile
3264  * @group_name: a group name
3265  * @key: a key
3266  * @list: (array length=length): an array of double values
3267  * @length: number of double values in @list
3268  *
3269  * Associates a list of double values with @key under
3270  * @group_name.  If @key cannot be found then it is created.
3271  *
3272  * Since: 2.12
3273  **/
3274 void
3275 g_key_file_set_double_list (GKeyFile    *key_file,
<span class="line-modified">3276           const gchar *group_name,</span>
<span class="line-modified">3277           const gchar *key,</span>
<span class="line-modified">3278           gdouble      list[],</span>
<span class="line-modified">3279           gsize        length)</span>
3280 {
3281   GString *values;
3282   gsize i;
3283 
3284   g_return_if_fail (key_file != NULL);
3285   g_return_if_fail (list != NULL);
3286 
3287   values = g_string_sized_new (length * 16);
3288 #ifdef GSTREAMER_LITE
3289   if (values == NULL) {
3290     return;
3291   }
3292 #endif // GSTREAMER_LITE
3293   for (i = 0; i &lt; length; i++)
3294     {
3295       gchar result[G_ASCII_DTOSTR_BUF_SIZE];
3296 
3297       g_ascii_dtostr( result, sizeof (result), list[i] );
3298 
3299       g_string_append (values, result);
</pre>
<hr />
<pre>
3556 
3557   pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
3558   if (pair-&gt;key != NULL)
3559     return NULL;
3560 
3561   while (tmp-&gt;next)
3562     {
3563       pair = (GKeyFileKeyValuePair *) tmp-&gt;next-&gt;data;
3564 
3565       if (pair-&gt;key != NULL)
3566         break;
3567 
3568       tmp = tmp-&gt;next;
3569     }
3570 
3571   while (tmp != key_node)
3572     {
3573       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
3574 
3575       if (string == NULL)
<span class="line-modified">3576   string = g_string_sized_new (512);</span>
3577 
<span class="line-modified">3578       comment = g_key_file_parse_value_as_comment (key_file, pair-&gt;value,</span>
<span class="line-added">3579                                                    (tmp-&gt;prev == key_node));</span>
3580       g_string_append (string, comment);
3581       g_free (comment);
3582 
3583       tmp = tmp-&gt;prev;
3584     }
3585 
3586   if (string != NULL)
3587     {
3588       comment = string-&gt;str;
3589       g_string_free (string, FALSE);
3590     }
3591   else
3592     comment = NULL;
3593 
3594   return comment;
3595 }
3596 
3597 static gchar *
3598 get_group_comment (GKeyFile       *key_file,
<span class="line-modified">3599        GKeyFileGroup  *group,</span>
<span class="line-modified">3600        GError        **error)</span>
3601 {
3602   GString *string;
3603   GList *tmp;
3604   gchar *comment;
3605 
3606   string = NULL;
3607 
3608   tmp = group-&gt;key_value_pairs;
3609   while (tmp)
3610     {
3611       GKeyFileKeyValuePair *pair;
3612 
3613       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
3614 
3615       if (pair-&gt;key != NULL)
<span class="line-modified">3616   {</span>
<span class="line-modified">3617     tmp = tmp-&gt;prev;</span>
<span class="line-modified">3618     break;</span>
<span class="line-modified">3619   }</span>
3620 
3621       if (tmp-&gt;next == NULL)
<span class="line-modified">3622   break;</span>
3623 
3624       tmp = tmp-&gt;next;
3625     }
3626 
3627   while (tmp != NULL)
3628     {
3629       GKeyFileKeyValuePair *pair;
3630 
3631       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
3632 
3633       if (string == NULL)
3634         string = g_string_sized_new (512);
3635 
<span class="line-modified">3636       comment = g_key_file_parse_value_as_comment (key_file, pair-&gt;value,</span>
<span class="line-added">3637                                                    (tmp-&gt;prev == NULL));</span>
3638       g_string_append (string, comment);
3639       g_free (comment);
3640 
3641       tmp = tmp-&gt;prev;
3642     }
3643 
3644   if (string != NULL)
3645     return g_string_free (string, FALSE);
3646 
3647   return NULL;
3648 }
3649 
3650 static gchar *
3651 g_key_file_get_group_comment (GKeyFile     *key_file,
3652                               const gchar  *group_name,
3653                               GError      **error)
3654 {
3655   GList *group_node;
3656   GKeyFileGroup *group;
3657 
</pre>
<hr />
<pre>
3688   g_warn_if_fail (key_file-&gt;groups != NULL);
3689   group_node = g_list_last (key_file-&gt;groups);
3690   group = (GKeyFileGroup *) group_node-&gt;data;
3691   g_warn_if_fail (group-&gt;name == NULL);
3692 
3693   return get_group_comment (key_file, group, error);
3694 }
3695 
3696 /**
3697  * g_key_file_get_comment:
3698  * @key_file: a #GKeyFile
3699  * @group_name: (nullable): a group name, or %NULL
3700  * @key: a key
3701  * @error: return location for a #GError
3702  *
3703  * Retrieves a comment above @key from @group_name.
3704  * If @key is %NULL then @comment will be read from above
3705  * @group_name. If both @key and @group_name are %NULL, then
3706  * @comment will be read from above the first group in the file.
3707  *
<span class="line-modified">3708  * Note that the returned string does not include the &#39;#&#39; comment markers,</span>
<span class="line-added">3709  * but does include any whitespace after them (on each line). It includes</span>
<span class="line-added">3710  * the line breaks between lines, but does not include the final line break.</span>
3711  *
3712  * Returns: a comment that should be freed with g_free()
3713  *
3714  * Since: 2.6
3715  **/
3716 gchar *
3717 g_key_file_get_comment (GKeyFile     *key_file,
3718                         const gchar  *group_name,
3719                         const gchar  *key,
3720                         GError      **error)
3721 {
3722   g_return_val_if_fail (key_file != NULL, NULL);
3723 
3724   if (group_name != NULL &amp;&amp; key != NULL)
3725     return g_key_file_get_key_comment (key_file, group_name, key, error);
3726   else if (group_name != NULL)
3727     return g_key_file_get_group_comment (key_file, group_name, error);
3728   else
3729     return g_key_file_get_top_comment (key_file, error);
3730 }
</pre>
<hr />
<pre>
3758     return g_key_file_set_key_comment (key_file, group_name, key, NULL, error);
3759   else if (group_name != NULL)
3760     return g_key_file_set_group_comment (key_file, group_name, NULL, error);
3761   else
3762     return g_key_file_set_top_comment (key_file, NULL, error);
3763 }
3764 
3765 /**
3766  * g_key_file_has_group:
3767  * @key_file: a #GKeyFile
3768  * @group_name: a group name
3769  *
3770  * Looks whether the key file has the group @group_name.
3771  *
3772  * Returns: %TRUE if @group_name is a part of @key_file, %FALSE
3773  * otherwise.
3774  * Since: 2.6
3775  **/
3776 gboolean
3777 g_key_file_has_group (GKeyFile    *key_file,
<span class="line-modified">3778           const gchar *group_name)</span>
3779 {
3780   g_return_val_if_fail (key_file != NULL, FALSE);
3781   g_return_val_if_fail (group_name != NULL, FALSE);
3782 
3783   return g_key_file_lookup_group (key_file, group_name) != NULL;
3784 }
3785 
3786 /* This code remains from a historical attempt to add a new public API
3787  * which respects the GError rules.
3788  */
3789 static gboolean
3790 g_key_file_has_key_full (GKeyFile     *key_file,
<span class="line-modified">3791        const gchar  *group_name,</span>
<span class="line-modified">3792        const gchar  *key,</span>
<span class="line-modified">3793        gboolean     *has_key,</span>
<span class="line-modified">3794        GError      **error)</span>
3795 {
3796   GKeyFileKeyValuePair *pair;
3797   GKeyFileGroup *group;
3798 
3799   g_return_val_if_fail (key_file != NULL, FALSE);
3800   g_return_val_if_fail (group_name != NULL, FALSE);
3801   g_return_val_if_fail (key != NULL, FALSE);
3802 
3803   group = g_key_file_lookup_group (key_file, group_name);
3804 
3805   if (!group)
3806     {
3807       g_set_error (error, G_KEY_FILE_ERROR,
3808                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
3809                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
3810 #ifdef GSTREAMER_LITE
3811                    group_name ? group_name : &quot;(null)&quot;);
3812 #else // GSTREAMER_LITE
3813                    group_name);
3814 #endif // GSTREAMER_LITE
</pre>
<hr />
<pre>
3830  * @key: a key name
3831  * @error: return location for a #GError
3832  *
3833  * Looks whether the key file has the key @key in the group
3834  * @group_name.
3835  *
3836  * Note that this function does not follow the rules for #GError strictly;
3837  * the return value both carries meaning and signals an error.  To use
3838  * this function, you must pass a #GError pointer in @error, and check
3839  * whether it is not %NULL to see if an error occurred.
3840  *
3841  * Language bindings should use g_key_file_get_value() to test whether
3842  * or not a key exists.
3843  *
3844  * Returns: %TRUE if @key is a part of @group_name, %FALSE otherwise
3845  *
3846  * Since: 2.6
3847  **/
3848 gboolean
3849 g_key_file_has_key (GKeyFile     *key_file,
<span class="line-modified">3850         const gchar  *group_name,</span>
<span class="line-modified">3851         const gchar  *key,</span>
<span class="line-modified">3852         GError      **error)</span>
3853 {
3854   GError *temp_error = NULL;
3855   gboolean has_key;
3856 
3857   if (g_key_file_has_key_full (key_file, group_name, key, &amp;has_key, &amp;temp_error))
3858     {
3859       return has_key;
3860     }
3861   else
3862     {
3863       g_propagate_error (error, temp_error);
3864       return FALSE;
3865     }
3866 }
3867 
3868 static void
3869 g_key_file_add_group (GKeyFile    *key_file,
<span class="line-modified">3870           const gchar *group_name)</span>
3871 {
3872   GKeyFileGroup *group;
3873 
3874   g_return_if_fail (key_file != NULL);
3875   g_return_if_fail (g_key_file_is_group_name (group_name));
3876 
3877   group = g_key_file_lookup_group (key_file, group_name);
3878   if (group != NULL)
3879     {
3880       key_file-&gt;current_group = group;
3881       return;
3882     }
3883 
3884   group = g_slice_new0 (GKeyFileGroup);
3885   group-&gt;name = g_strdup (group_name);
3886   group-&gt;lookup_map = g_hash_table_new (g_str_hash, g_str_equal);
3887   key_file-&gt;groups = g_list_prepend (key_file-&gt;groups, group);
3888   key_file-&gt;current_group = group;
3889 
3890   if (key_file-&gt;start_group == NULL)
</pre>
<hr />
<pre>
3899   if (pair != NULL)
3900     {
3901       g_free (pair-&gt;key);
3902       g_free (pair-&gt;value);
3903       g_slice_free (GKeyFileKeyValuePair, pair);
3904     }
3905 }
3906 
3907 /* Be careful not to call this function on a node with data in the
3908  * lookup map without removing it from the lookup map, first.
3909  *
3910  * Some current cases where this warning is not a concern are
3911  * when:
3912  *   - the node being removed is a comment node
3913  *   - the entire lookup map is getting destroyed soon after
3914  *     anyway.
3915  */
3916 static void
3917 g_key_file_remove_key_value_pair_node (GKeyFile      *key_file,
3918                                        GKeyFileGroup *group,
<span class="line-modified">3919                      GList         *pair_node)</span>
3920 {
3921 
3922   GKeyFileKeyValuePair *pair;
3923 
3924   pair = (GKeyFileKeyValuePair *) pair_node-&gt;data;
3925 
3926   group-&gt;key_value_pairs = g_list_remove_link (group-&gt;key_value_pairs, pair_node);
3927 
3928   g_warn_if_fail (pair-&gt;value != NULL);
3929 
3930   g_key_file_key_value_pair_free (pair);
3931 
3932   g_list_free_1 (pair_node);
3933 }
3934 
3935 static void
3936 g_key_file_remove_group_node (GKeyFile *key_file,
<span class="line-modified">3937             GList    *group_node)</span>
3938 {
3939   GKeyFileGroup *group;
3940   GList *tmp;
3941 
3942   group = (GKeyFileGroup *) group_node-&gt;data;
3943 
3944   if (group-&gt;name)
3945     g_hash_table_remove (key_file-&gt;group_hash, group-&gt;name);
3946 
3947   /* If the current group gets deleted make the current group the last
3948    * added group.
3949    */
3950   if (key_file-&gt;current_group == group)
3951     {
3952       /* groups should always contain at least the top comment group,
3953        * unless g_key_file_clear has been called
3954        */
3955       if (key_file-&gt;groups)
3956         key_file-&gt;current_group = (GKeyFileGroup *) key_file-&gt;groups-&gt;data;
3957       else
3958         key_file-&gt;current_group = NULL;
3959     }
3960 
3961   /* If the start group gets deleted make the start group the first
3962    * added group.
3963    */
3964   if (key_file-&gt;start_group == group)
3965     {
3966       tmp = g_list_last (key_file-&gt;groups);
3967       while (tmp != NULL)
<span class="line-modified">3968   {</span>
<span class="line-modified">3969     if (tmp != group_node &amp;&amp;</span>
<span class="line-modified">3970         ((GKeyFileGroup *) tmp-&gt;data)-&gt;name != NULL)</span>
<span class="line-modified">3971       break;</span>
3972 
<span class="line-modified">3973     tmp = tmp-&gt;prev;</span>
<span class="line-modified">3974   }</span>
3975 
3976       if (tmp)
3977         key_file-&gt;start_group = (GKeyFileGroup *) tmp-&gt;data;
3978       else
3979         key_file-&gt;start_group = NULL;
3980     }
3981 
3982   key_file-&gt;groups = g_list_remove_link (key_file-&gt;groups, group_node);
3983 
3984   tmp = group-&gt;key_value_pairs;
3985   while (tmp != NULL)
3986     {
3987       GList *pair_node;
3988 
3989       pair_node = tmp;
3990       tmp = tmp-&gt;next;
3991       g_key_file_remove_key_value_pair_node (key_file, group, pair_node);
3992     }
3993 
3994   g_warn_if_fail (group-&gt;key_value_pairs == NULL);
</pre>
<hr />
<pre>
4008   g_free ((gchar *) group-&gt;name);
4009   g_slice_free (GKeyFileGroup, group);
4010   g_list_free_1 (group_node);
4011 }
4012 
4013 /**
4014  * g_key_file_remove_group:
4015  * @key_file: a #GKeyFile
4016  * @group_name: a group name
4017  * @error: return location for a #GError or %NULL
4018  *
4019  * Removes the specified group, @group_name,
4020  * from the key file.
4021  *
4022  * Returns: %TRUE if the group was removed, %FALSE otherwise
4023  *
4024  * Since: 2.6
4025  **/
4026 gboolean
4027 g_key_file_remove_group (GKeyFile     *key_file,
<span class="line-modified">4028        const gchar  *group_name,</span>
<span class="line-modified">4029        GError      **error)</span>
4030 {
4031   GList *group_node;
4032 
4033   g_return_val_if_fail (key_file != NULL, FALSE);
4034   g_return_val_if_fail (group_name != NULL, FALSE);
4035 
4036   group_node = g_key_file_lookup_group_node (key_file, group_name);
4037 
4038   if (!group_node)
4039     {
4040       g_set_error (error, G_KEY_FILE_ERROR,
<span class="line-modified">4041        G_KEY_FILE_ERROR_GROUP_NOT_FOUND,</span>
<span class="line-modified">4042        _(&quot;Key file does not have group &#39;%s&#39;&quot;),</span>
<span class="line-modified">4043        group_name);</span>
4044       return FALSE;
4045     }
4046 
4047   g_key_file_remove_group_node (key_file, group_node);
4048 
4049   return TRUE;
4050 }
4051 
4052 static void
4053 g_key_file_add_key_value_pair (GKeyFile             *key_file,
4054                                GKeyFileGroup        *group,
4055                                GKeyFileKeyValuePair *pair)
4056 {
4057   g_hash_table_replace (group-&gt;lookup_map, pair-&gt;key, pair);
4058   group-&gt;key_value_pairs = g_list_prepend (group-&gt;key_value_pairs, pair);
4059 }
4060 
4061 static void
4062 g_key_file_add_key (GKeyFile      *key_file,
<span class="line-modified">4063         GKeyFileGroup *group,</span>
<span class="line-modified">4064         const gchar   *key,</span>
<span class="line-modified">4065         const gchar   *value)</span>
4066 {
4067   GKeyFileKeyValuePair *pair;
4068 
4069   pair = g_slice_new (GKeyFileKeyValuePair);
4070 #ifdef GSTREAMER_LITE
4071   if (pair == NULL) {
4072     return;
4073   }
4074 #endif // GSTREAMER_LITE
4075   pair-&gt;key = g_strdup (key);
4076   pair-&gt;value = g_strdup (value);
4077 
4078   g_key_file_add_key_value_pair (key_file, group, pair);
4079 }
4080 
4081 /**
4082  * g_key_file_remove_key:
4083  * @key_file: a #GKeyFile
4084  * @group_name: a group name
4085  * @key: a key name to remove
4086  * @error: return location for a #GError or %NULL
4087  *
4088  * Removes @key in @group_name from the key file.
4089  *
4090  * Returns: %TRUE if the key was removed, %FALSE otherwise
4091  *
4092  * Since: 2.6
4093  **/
4094 gboolean
4095 g_key_file_remove_key (GKeyFile     *key_file,
<span class="line-modified">4096            const gchar  *group_name,</span>
<span class="line-modified">4097            const gchar  *key,</span>
<span class="line-modified">4098            GError      **error)</span>
4099 {
4100   GKeyFileGroup *group;
4101   GKeyFileKeyValuePair *pair;
4102 
4103   g_return_val_if_fail (key_file != NULL, FALSE);
4104   g_return_val_if_fail (group_name != NULL, FALSE);
4105   g_return_val_if_fail (key != NULL, FALSE);
4106 
4107   pair = NULL;
4108 
4109   group = g_key_file_lookup_group (key_file, group_name);
4110   if (!group)
4111     {
4112       g_set_error (error, G_KEY_FILE_ERROR,
4113                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
4114                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
4115 #ifdef GSTREAMER_LITE
4116                    group_name ? group_name : &quot;(null)&quot;);
4117 #else // GSTREAMER_LITE
4118                    group_name);
</pre>
<hr />
<pre>
4120       return FALSE;
4121     }
4122 
4123   pair = g_key_file_lookup_key_value_pair (key_file, group, key);
4124 
4125   if (!pair)
4126     {
4127       set_not_found_key_error (group-&gt;name, key, error);
4128       return FALSE;
4129     }
4130 
4131   group-&gt;key_value_pairs = g_list_remove (group-&gt;key_value_pairs, pair);
4132   g_hash_table_remove (group-&gt;lookup_map, pair-&gt;key);
4133   g_key_file_key_value_pair_free (pair);
4134 
4135   return TRUE;
4136 }
4137 
4138 static GList *
4139 g_key_file_lookup_group_node (GKeyFile    *key_file,
<span class="line-modified">4140             const gchar *group_name)</span>
4141 {
4142   GKeyFileGroup *group;
4143   GList *tmp;
4144 
4145   for (tmp = key_file-&gt;groups; tmp != NULL; tmp = tmp-&gt;next)
4146     {
4147       group = (GKeyFileGroup *) tmp-&gt;data;
4148 
4149       if (group &amp;&amp; group-&gt;name &amp;&amp; strcmp (group-&gt;name, group_name) == 0)
4150         break;
4151     }
4152 
4153   return tmp;
4154 }
4155 
4156 static GKeyFileGroup *
4157 g_key_file_lookup_group (GKeyFile    *key_file,
<span class="line-modified">4158        const gchar *group_name)</span>
4159 {
4160   return (GKeyFileGroup *)g_hash_table_lookup (key_file-&gt;group_hash, group_name);
4161 }
4162 
4163 static GList *
4164 g_key_file_lookup_key_value_pair_node (GKeyFile       *key_file,
<span class="line-modified">4165                      GKeyFileGroup  *group,</span>
4166                                        const gchar    *key)
4167 {
4168   GList *key_node;
4169 
4170   for (key_node = group-&gt;key_value_pairs;
4171        key_node != NULL;
4172        key_node = key_node-&gt;next)
4173     {
4174       GKeyFileKeyValuePair *pair;
4175 
4176       pair = (GKeyFileKeyValuePair *) key_node-&gt;data;
4177 
4178       if (pair-&gt;key &amp;&amp; strcmp (pair-&gt;key, key) == 0)
4179         break;
4180     }
4181 
4182   return key_node;
4183 }
4184 
4185 static GKeyFileKeyValuePair *
4186 g_key_file_lookup_key_value_pair (GKeyFile      *key_file,
<span class="line-modified">4187           GKeyFileGroup *group,</span>
<span class="line-modified">4188           const gchar   *key)</span>
4189 {
4190   return (GKeyFileKeyValuePair *) g_hash_table_lookup (group-&gt;lookup_map, key);
4191 }
4192 
4193 /* Lines starting with # or consisting entirely of whitespace are merely
4194  * recorded, not parsed. This function assumes all leading whitespace
4195  * has been stripped.
4196  */
4197 static gboolean
4198 g_key_file_line_is_comment (const gchar *line)
4199 {
4200   return (*line == &#39;#&#39; || *line == &#39;\0&#39; || *line == &#39;\n&#39;);
4201 }
4202 
4203 static gboolean
4204 g_key_file_is_group_name (const gchar *name)
4205 {
4206   gchar *p, *q;
4207 
4208   if (name == NULL)
</pre>
<hr />
<pre>
4297 static gboolean
4298 g_key_file_line_is_key_value_pair (const gchar *line)
4299 {
4300   gchar *p;
4301 
4302   p = (gchar *) g_utf8_strchr (line, -1, &#39;=&#39;);
4303 
4304   if (!p)
4305     return FALSE;
4306 
4307   /* Key must be non-empty
4308    */
4309   if (*p == line[0])
4310     return FALSE;
4311 
4312   return TRUE;
4313 }
4314 
4315 static gchar *
4316 g_key_file_parse_value_as_string (GKeyFile     *key_file,
<span class="line-modified">4317           const gchar  *value,</span>
<span class="line-modified">4318           GSList      **pieces,</span>
<span class="line-modified">4319           GError      **error)</span>
4320 {
4321   gchar *string_value, *p, *q0, *q;
4322 
4323   string_value = g_new (gchar, strlen (value) + 1);
4324 
4325   p = (gchar *) value;
4326   q0 = q = string_value;
4327   while (*p)
4328     {
4329       if (*p == &#39;\\&#39;)
4330         {
4331           p++;
4332 
4333           switch (*p)
4334             {
4335             case &#39;s&#39;:
4336               *q = &#39; &#39;;
4337               break;
4338 
4339             case &#39;n&#39;:
4340               *q = &#39;\n&#39;;
4341               break;
4342 
4343             case &#39;t&#39;:
4344               *q = &#39;\t&#39;;
4345               break;
4346 
4347             case &#39;r&#39;:
4348               *q = &#39;\r&#39;;
4349               break;
4350 
4351             case &#39;\\&#39;:
4352               *q = &#39;\\&#39;;
4353               break;
4354 
<span class="line-modified">4355       case &#39;\0&#39;:</span>
<span class="line-modified">4356         g_set_error_literal (error, G_KEY_FILE_ERROR,</span>
4357                                    G_KEY_FILE_ERROR_INVALID_VALUE,
4358                                    _(&quot;Key file contains escape character &quot;
4359                                      &quot;at end of line&quot;));
<span class="line-modified">4360         break;</span>
4361 
4362             default:
<span class="line-modified">4363         if (pieces &amp;&amp; *p == key_file-&gt;list_separator)</span>
<span class="line-modified">4364     *q = key_file-&gt;list_separator;</span>
<span class="line-modified">4365         else</span>
<span class="line-modified">4366     {</span>
<span class="line-modified">4367       *q++ = &#39;\\&#39;;</span>
<span class="line-modified">4368       *q = *p;</span>
4369 
<span class="line-modified">4370       if (*error == NULL)</span>
<span class="line-modified">4371         {</span>
<span class="line-modified">4372           gchar sequence[3];</span>
4373 
<span class="line-modified">4374           sequence[0] = &#39;\\&#39;;</span>
<span class="line-modified">4375           sequence[1] = *p;</span>
<span class="line-modified">4376           sequence[2] = &#39;\0&#39;;</span>
4377 
<span class="line-modified">4378           g_set_error (error, G_KEY_FILE_ERROR,</span>
<span class="line-modified">4379            G_KEY_FILE_ERROR_INVALID_VALUE,</span>
<span class="line-modified">4380            _(&quot;Key file contains invalid escape &quot;</span>
<span class="line-modified">4381              &quot;sequence &#39;%s&#39;&quot;), sequence);</span>

4382         }
<span class="line-added">4383     }</span>
4384               break;
4385             }
4386         }
4387       else
<span class="line-modified">4388   {</span>
<span class="line-modified">4389     *q = *p;</span>
<span class="line-modified">4390     if (pieces &amp;&amp; (*p == key_file-&gt;list_separator))</span>
<span class="line-modified">4391       {</span>
<span class="line-modified">4392         *pieces = g_slist_prepend (*pieces, g_strndup (q0, q - q0));</span>
<span class="line-modified">4393         q0 = q + 1;</span>
<span class="line-modified">4394       }</span>
<span class="line-modified">4395   }</span>
4396 
4397       if (*p == &#39;\0&#39;)
<span class="line-modified">4398   break;</span>
4399 
4400       q++;
4401       p++;
4402     }
4403 
4404   *q = &#39;\0&#39;;
4405   if (pieces)
4406   {
4407     if (q0 &lt; q)
4408       *pieces = g_slist_prepend (*pieces, g_strndup (q0, q - q0));
4409     *pieces = g_slist_reverse (*pieces);
4410   }
4411 
4412   return string_value;
4413 }
4414 
4415 static gchar *
4416 g_key_file_parse_string_as_value (GKeyFile    *key_file,
<span class="line-modified">4417           const gchar *string,</span>
<span class="line-modified">4418           gboolean     escape_separator)</span>
4419 {
4420   gchar *value, *p, *q;
4421   gsize length;
4422   gboolean parsing_leading_space;
4423 
4424   length = strlen (string) + 1;
4425 
4426   /* Worst case would be that every character needs to be escaped.
4427    * In other words every character turns to two characters
4428    */
4429   value = g_new (gchar, 2 * length);
4430 
4431   p = (gchar *) string;
4432   q = value;
4433   parsing_leading_space = TRUE;
4434   while (p &lt; (string + length - 1))
4435     {
4436       gchar escaped_character[3] = { &#39;\\&#39;, 0, 0 };
4437 
4438       switch (*p)
4439         {
4440         case &#39; &#39;:
4441           if (parsing_leading_space)
4442             {
4443               escaped_character[1] = &#39;s&#39;;
4444               strcpy (q, escaped_character);
4445               q += 2;
4446             }
4447           else
4448             {
<span class="line-modified">4449         *q = *p;</span>
<span class="line-modified">4450         q++;</span>
4451             }
4452           break;
4453         case &#39;\t&#39;:
4454           if (parsing_leading_space)
4455             {
4456               escaped_character[1] = &#39;t&#39;;
4457               strcpy (q, escaped_character);
4458               q += 2;
4459             }
4460           else
4461             {
<span class="line-modified">4462         *q = *p;</span>
<span class="line-modified">4463         q++;</span>
4464             }
4465           break;
4466         case &#39;\n&#39;:
4467           escaped_character[1] = &#39;n&#39;;
4468           strcpy (q, escaped_character);
4469           q += 2;
4470           break;
4471         case &#39;\r&#39;:
4472           escaped_character[1] = &#39;r&#39;;
4473           strcpy (q, escaped_character);
4474           q += 2;
4475           break;
4476         case &#39;\\&#39;:
4477           escaped_character[1] = &#39;\\&#39;;
4478           strcpy (q, escaped_character);
4479           q += 2;
4480           parsing_leading_space = FALSE;
4481           break;
4482         default:
<span class="line-modified">4483     if (escape_separator &amp;&amp; *p == key_file-&gt;list_separator)</span>
<span class="line-modified">4484       {</span>
<span class="line-modified">4485         escaped_character[1] = key_file-&gt;list_separator;</span>
<span class="line-modified">4486         strcpy (q, escaped_character);</span>
<span class="line-modified">4487         q += 2;</span>
4488               parsing_leading_space = TRUE;
<span class="line-modified">4489       }</span>
<span class="line-modified">4490     else</span>
<span class="line-modified">4491       {</span>
<span class="line-modified">4492         *q = *p;</span>
<span class="line-modified">4493         q++;</span>
4494               parsing_leading_space = FALSE;
<span class="line-modified">4495       }</span>
4496           break;
4497         }
4498       p++;
4499     }
4500   *q = &#39;\0&#39;;
4501 
4502   return value;
4503 }
4504 
4505 static gint
4506 g_key_file_parse_value_as_integer (GKeyFile     *key_file,
<span class="line-modified">4507            const gchar  *value,</span>
<span class="line-modified">4508            GError      **error)</span>
4509 {
4510   gchar *eof_int;
4511   glong long_value;
4512   gint int_value;
4513   int errsv;
4514 
4515   errno = 0;
4516   long_value = strtol (value, &amp;eof_int, 10);
4517   errsv = errno;
4518 
4519   if (*value == &#39;\0&#39; || (*eof_int != &#39;\0&#39; &amp;&amp; !g_ascii_isspace(*eof_int)))
4520     {
4521       gchar *value_utf8 = g_utf8_make_valid (value, -1);
4522       g_set_error (error, G_KEY_FILE_ERROR,
<span class="line-modified">4523        G_KEY_FILE_ERROR_INVALID_VALUE,</span>
<span class="line-modified">4524        _(&quot;Value &#39;%s&#39; cannot be interpreted &quot;</span>
<span class="line-modified">4525          &quot;as a number.&quot;), value_utf8);</span>
4526       g_free (value_utf8);
4527 
4528       return 0;
4529     }
4530 
4531   int_value = long_value;
4532   if (int_value != long_value || errsv == ERANGE)
4533     {
4534       gchar *value_utf8 = g_utf8_make_valid (value, -1);
4535       g_set_error (error,
<span class="line-modified">4536        G_KEY_FILE_ERROR,</span>
<span class="line-modified">4537        G_KEY_FILE_ERROR_INVALID_VALUE,</span>
<span class="line-modified">4538        _(&quot;Integer value &#39;%s&#39; out of range&quot;),</span>
<span class="line-modified">4539        value_utf8);</span>
4540       g_free (value_utf8);
4541 
4542       return 0;
4543     }
4544 
4545   return int_value;
4546 }
4547 
4548 static gchar *
4549 g_key_file_parse_integer_as_value (GKeyFile *key_file,
<span class="line-modified">4550            gint      value)</span>
4551 
4552 {
4553   return g_strdup_printf (&quot;%d&quot;, value);
4554 }
4555 
4556 static gdouble
4557 g_key_file_parse_value_as_double  (GKeyFile     *key_file,
4558                                    const gchar  *value,
4559                                    GError      **error)
4560 {
4561   gchar *end_of_valid_d;
4562   gdouble double_value = 0;
4563 
4564   double_value = g_ascii_strtod (value, &amp;end_of_valid_d);
4565 
4566   if (*end_of_valid_d != &#39;\0&#39; || end_of_valid_d == value)
4567     {
4568       gchar *value_utf8 = g_utf8_make_valid (value, -1);
4569       g_set_error (error, G_KEY_FILE_ERROR,
<span class="line-modified">4570        G_KEY_FILE_ERROR_INVALID_VALUE,</span>
<span class="line-modified">4571        _(&quot;Value &#39;%s&#39; cannot be interpreted &quot;</span>
<span class="line-modified">4572          &quot;as a float number.&quot;),</span>
<span class="line-modified">4573        value_utf8);</span>
4574       g_free (value_utf8);
4575 
4576       double_value = 0;
4577     }
4578 
4579   return double_value;
4580 }
4581 
4582 static gint
4583 strcmp_sized (const gchar *s1, size_t len1, const gchar *s2)
4584 {
4585   size_t len2 = strlen (s2);
4586   return strncmp (s1, s2, MAX (len1, len2));
4587 }
4588 
4589 static gboolean
4590 g_key_file_parse_value_as_boolean (GKeyFile     *key_file,
<span class="line-modified">4591            const gchar  *value,</span>
<span class="line-modified">4592            GError      **error)</span>
4593 {
4594   gchar *value_utf8;
4595   gint i, length = 0;
4596 
4597   /* Count the number of non-whitespace characters */
4598   for (i = 0; value[i]; i++)
4599     if (!g_ascii_isspace (value[i]))
4600       length = i + 1;
4601 
4602   if (strcmp_sized (value, length, &quot;true&quot;) == 0 || strcmp_sized (value, length, &quot;1&quot;) == 0)
4603     return TRUE;
4604   else if (strcmp_sized (value, length, &quot;false&quot;) == 0 || strcmp_sized (value, length, &quot;0&quot;) == 0)
4605     return FALSE;
4606 
4607   value_utf8 = g_utf8_make_valid (value, -1);
4608   g_set_error (error, G_KEY_FILE_ERROR,
4609                G_KEY_FILE_ERROR_INVALID_VALUE,
4610                _(&quot;Value &#39;%s&#39; cannot be interpreted &quot;
<span class="line-modified">4611      &quot;as a boolean.&quot;), value_utf8);</span>
4612   g_free (value_utf8);
4613 
4614   return FALSE;
4615 }
4616 
4617 static gchar *
4618 g_key_file_parse_boolean_as_value (GKeyFile *key_file,
<span class="line-modified">4619            gboolean  value)</span>
4620 {
4621   if (value)
4622     return g_strdup (&quot;true&quot;);
4623   else
4624     return g_strdup (&quot;false&quot;);
4625 }
4626 
4627 static gchar *
4628 g_key_file_parse_value_as_comment (GKeyFile    *key_file,
<span class="line-modified">4629                                    const gchar *value,</span>
<span class="line-added">4630                                    gboolean     is_final_line)</span>
4631 {
4632   GString *string;
4633   gchar **lines;
4634   gsize i;
4635 
4636   string = g_string_sized_new (512);
4637 
4638   lines = g_strsplit (value, &quot;\n&quot;, 0);
4639 
4640   for (i = 0; lines[i] != NULL; i++)
4641     {
<span class="line-modified">4642       const gchar *line = lines[i];</span>
<span class="line-modified">4643 </span>
<span class="line-modified">4644       if (i != 0)</span>
<span class="line-modified">4645         g_string_append_c (string, &#39;\n&#39;);</span>
<span class="line-added">4646 </span>
<span class="line-added">4647       if (line[0] == &#39;#&#39;)</span>
<span class="line-added">4648         line++;</span>
<span class="line-added">4649       g_string_append (string, line);</span>
4650     }
4651   g_strfreev (lines);
4652 
<span class="line-added">4653   /* This function gets called once per line of a comment, but we don&#39;t want</span>
<span class="line-added">4654    * to add a trailing newline. */</span>
<span class="line-added">4655   if (!is_final_line)</span>
<span class="line-added">4656     g_string_append_c (string, &#39;\n&#39;);</span>
<span class="line-added">4657 </span>
4658   return g_string_free (string, FALSE);
4659 }
4660 
4661 static gchar *
4662 g_key_file_parse_comment_as_value (GKeyFile      *key_file,
4663                                    const gchar   *comment)
4664 {
4665   GString *string;
4666   gchar **lines;
4667   gsize i;
4668 
4669   string = g_string_sized_new (512);
4670 
4671   lines = g_strsplit (comment, &quot;\n&quot;, 0);
4672 
4673   for (i = 0; lines[i] != NULL; i++)
4674     g_string_append_printf (string, &quot;#%s%s&quot;, lines[i],
4675                             lines[i + 1] == NULL? &quot;&quot; : &quot;\n&quot;);
4676   g_strfreev (lines);
4677 
</pre>
</td>
</tr>
</table>
<center><a href="giowin32.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gkeyfile.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>