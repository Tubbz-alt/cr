diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvarianttypeinfo.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvarianttypeinfo.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvarianttypeinfo.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvarianttypeinfo.c
@@ -1,8 +1,8 @@
 /*
- * Copyright � 2008 Ryan Lortie
- * Copyright � 2010 Codethink Limited
+ * Copyright (C) 2008 Ryan Lortie
+ * Copyright (C) 2010 Codethink Limited
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
  * version 2.1 of the License, or (at your option) any later version.
@@ -24,10 +24,11 @@
 
 #include <glib/gtestutils.h>
 #include <glib/gthread.h>
 #include <glib/gslice.h>
 #include <glib/ghash.h>
+#include <glib/grefcount.h>
 
 /* < private >
  * GVariantTypeInfo:
  *
  * This structure contains the necessary information to facilitate the
@@ -74,11 +75,11 @@
 typedef struct
 {
   GVariantTypeInfo info;
 
   gchar *type_string;
-  gint ref_count;
+  gatomicrefcount ref_count;
 } ContainerInfo;
 
 /* For 'array' and 'maybe' types, we store some extra information on the
  * end of the GVariantTypeInfo struct -- the element type (ie: "s" for
  * "as").  The container GVariantTypeInfo structure holds a reference to
@@ -105,14 +106,14 @@
 } TupleInfo;
 
 
 /* Hard-code the base types in a constant array */
 static const GVariantTypeInfo g_variant_type_info_basic_table[24] = {
-#define fixed_aligned(x)  x, x - 1
-#define not_a_type             0,
-#define unaligned         0, 0
-#define aligned(x)        0, x - 1
+#define fixed_aligned(x)  x, x - 1, 0
+#define not_a_type        0,     0, 0
+#define unaligned         0,     0, 0
+#define aligned(x)        0, x - 1, 0
   /* 'b' */ { fixed_aligned(1) },   /* boolean */
   /* 'c' */ { not_a_type },
   /* 'd' */ { fixed_aligned(8) },   /* double */
   /* 'e' */ { not_a_type },
   /* 'f' */ { not_a_type },
@@ -154,10 +155,11 @@
 /* sanity checks to make debugging easier */
 static void
 g_variant_type_info_check (const GVariantTypeInfo *info,
                            char                    container_class)
 {
+#ifndef G_DISABLE_ASSERT
   g_assert (!container_class || info->container_class == container_class);
 
   /* alignment can only be one of these */
   g_assert (info->alignment == 0 || info->alignment == 1 ||
             info->alignment == 3 || info->alignment == 7);
@@ -165,11 +167,11 @@
   if (info->container_class)
     {
       ContainerInfo *container = (ContainerInfo *) info;
 
       /* extra checks for containers */
-      g_assert_cmpint (container->ref_count, >, 0);
+      g_assert (!g_atomic_ref_count_compare (&container->ref_count, 0));
       g_assert (container->type_string != NULL);
     }
   else
     {
       gint index;
@@ -182,10 +184,11 @@
       g_assert (G_N_ELEMENTS (g_variant_type_info_basic_table) == 24);
       g_assert (G_N_ELEMENTS (g_variant_type_info_basic_chars) == 24);
       g_assert (0 <= index && index < 24);
       g_assert (g_variant_type_info_basic_chars[index][0] != ' ');
     }
+#endif  /* !G_DISABLE_ASSERT */
 }
 
 /* < private >
  * g_variant_type_info_get_type_string:
  * @info: a #GVariantTypeInfo
@@ -218,12 +221,12 @@
 }
 
 /* < private >
  * g_variant_type_info_query:
  * @info: a #GVariantTypeInfo
- * @alignment: (nullable): the location to store the alignment, or %NULL
- * @fixed_size: (nullable): the location to store the fixed size, or %NULL
+ * @alignment: (out) (optional): the location to store the alignment, or %NULL
+ * @fixed_size: (out) (optional): the location to store the fixed size, or %NULL
  *
  * Queries @info to determine the alignment requirements and fixed size
  * (if any) of the type.
  *
  * @fixed_size, if non-%NULL is set to the fixed size of the type, or 0
@@ -258,11 +261,11 @@
  * Queries @info to determine the depth of the type.
  *
  * See g_variant_type_string_get_depth_() for more details.
  *
  * Returns: depth of @info
- * Since: 2.60 (backported to 2.58)
+ * Since: 2.60
  */
 gsize
 g_variant_type_info_query_depth (GVariantTypeInfo *info)
 {
   g_variant_type_info_check (info, 0);
@@ -332,12 +335,12 @@
 }
 
 /* < private >
  * g_variant_type_query_element:
  * @info: a #GVariantTypeInfo for an array or maybe type
- * @alignment: (nullable): the location to store the alignment, or %NULL
- * @fixed_size: (nullable): the location to store the fixed size, or %NULL
+ * @alignment: (out) (optional): the location to store the alignment, or %NULL
+ * @fixed_size: (out) (optional): the location to store the fixed size, or %NULL
  *
  * Returns the alignment requires and fixed size (if any) for the
  * element type of the array.  This call is a convenience wrapper around
  * g_variant_type_info_element() and g_variant_type_info_query().
  */
@@ -362,11 +365,11 @@
 
 static void
 tuple_info_free (GVariantTypeInfo *info)
 {
   TupleInfo *tuple_info;
-  gint i;
+  gsize i;
 
   g_assert (info->container_class == GV_TUPLE_INFO_CLASS);
   tuple_info = (TupleInfo *) info;
 
   for (i = 0; i < tuple_info->n_members; i++)
@@ -546,11 +549,11 @@
 /* This function is the heart of the algorithm for calculating 'i', 'a',
  * 'b' and 'c' for each item in the tuple.
  *
  * Imagine we want to find the start of the "i" in the type "(su(qx)ni)".
  * That's a string followed by a uint32, then a tuple containing a
- * uint16 and a int64, then an int16, then our "i".  In order to get to
+ * uint16 and an int64, then an int16, then our "i".  In order to get to
  * our "i" we:
  *
  * Start at the end of the string, align to 4 (for the uint32), add 4.
  * Align to 8, add 16 (for the tuple).  Align to 2, add 2 (for the
  * int16).  Then we're there.  It turns out that, given 3 simple rules,
@@ -640,11 +643,11 @@
 
       /* the structure only has a fixed size if no variable-size
        * offsets are stored and the last item is fixed-sized too (since
        * an offset is never stored for the last item).
        */
-      if (m->i == -1 && m->type_info->fixed_size)
+      if (m->i == (gsize) -1 && m->type_info->fixed_size)
         /* in that case, the fixed size can be found by finding the
          * start of the last item (in the usual way) and adding its
          * fixed size.
          *
          * if a tuple has a fixed size then it is always a multiple of
@@ -660,11 +663,11 @@
     }
   else
     {
       /* the empty tuple: '()'.
        *
-       * has a size of 1 and an no alignment requirement.
+       * has a size of 1 and a no alignment requirement.
        *
        * It has a size of 1 (not 0) for two practical reasons:
        *
        *  1) So we can determine how many of them are in an array
        *     without dividing by zero or without other tricks.
@@ -796,11 +799,11 @@
               container = tuple_info_new (type);
             }
 
           info = (GVariantTypeInfo *) container;
           container->type_string = type_string;
-          container->ref_count = 1;
+          g_atomic_ref_count_init (&container->ref_count);
 
           g_hash_table_insert (g_variant_type_info_table, type_string, info);
           type_string = NULL;
         }
       else
@@ -842,12 +845,11 @@
 
   if (info->container_class)
     {
       ContainerInfo *container = (ContainerInfo *) info;
 
-      g_assert_cmpint (container->ref_count, >, 0);
-      g_atomic_int_inc (&container->ref_count);
+      g_atomic_ref_count_inc (&container->ref_count);
     }
 
   return info;
 }
 
@@ -866,11 +868,11 @@
   if (info->container_class)
     {
       ContainerInfo *container = (ContainerInfo *) info;
 
       g_rec_mutex_lock (&g_variant_type_info_lock);
-      if (g_atomic_int_dec_and_test (&container->ref_count))
+      if (g_atomic_ref_count_dec (&container->ref_count))
         {
           g_hash_table_remove (g_variant_type_info_table,
                                container->type_string);
           if (g_hash_table_size (g_variant_type_info_table) == 0)
             {
