<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstpad.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2000 Wim Taymans &lt;wtay@chello.be&gt;
   4  *
   5  * gstpad.c: Pads for linking elements together
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 /**
  23  * SECTION:gstpad
  24  * @title: GstPad
  25  * @short_description: Object contained by elements that allows links to
  26  *                     other elements
  27  * @see_also: #GstPadTemplate, #GstElement, #GstEvent, #GstQuery, #GstBuffer
  28  *
  29  * A #GstElement is linked to other elements via &quot;pads&quot;, which are extremely
  30  * light-weight generic link points.
  31  *
  32  * Pads have a #GstPadDirection, source pads produce data, sink pads consume
  33  * data.
  34  *
  35  * Pads are typically created from a #GstPadTemplate with
  36  * gst_pad_new_from_template() and are then added to a #GstElement. This usually
  37  * happens when the element is created but it can also happen dynamically based
  38  * on the data that the element is processing or based on the pads that the
  39  * application requests.
  40  *
  41  * Pads without pad templates can be created with gst_pad_new(),
  42  * which takes a direction and a name as an argument.  If the name is %NULL,
  43  * then a guaranteed unique name will be assigned to it.
  44  *
  45  * A #GstElement creating a pad will typically use the various
  46  * gst_pad_set_*_function() calls to register callbacks for events, queries or
  47  * dataflow on the pads.
  48  *
  49  * gst_pad_get_parent() will retrieve the #GstElement that owns the pad.
  50  *
  51  * After two pads are retrieved from an element by gst_element_get_static_pad(),
  52  * the pads can be linked with gst_pad_link(). (For quick links,
  53  * you can also use gst_element_link(), which will make the obvious
  54  * link for you if it&#39;s straightforward.). Pads can be unlinked again with
  55  * gst_pad_unlink(). gst_pad_get_peer() can be used to check what the pad is
  56  * linked to.
  57  *
  58  * Before dataflow is possible on the pads, they need to be activated with
  59  * gst_pad_set_active().
  60  *
  61  * gst_pad_query() and gst_pad_peer_query() can be used to query various
  62  * properties of the pad and the stream.
  63  *
  64  * To send a #GstEvent on a pad, use gst_pad_send_event() and
  65  * gst_pad_push_event(). Some events will be sticky on the pad, meaning that
  66  * after they pass on the pad they can be queried later with
  67  * gst_pad_get_sticky_event() and gst_pad_sticky_events_foreach().
  68  * gst_pad_get_current_caps() and gst_pad_has_current_caps() are convenience
  69  * functions to query the current sticky CAPS event on a pad.
  70  *
  71  * GstElements will use gst_pad_push() and gst_pad_pull_range() to push out
  72  * or pull in a buffer.
  73  *
  74  * The dataflow, events and queries that happen on a pad can be monitored with
  75  * probes that can be installed with gst_pad_add_probe(). gst_pad_is_blocked()
  76  * can be used to check if a block probe is installed on the pad.
  77  * gst_pad_is_blocking() checks if the blocking probe is currently blocking the
  78  * pad. gst_pad_remove_probe() is used to remove a previously installed probe
  79  * and unblock blocking probes if any.
  80  *
  81  * Pad have an offset that can be retrieved with gst_pad_get_offset(). This
  82  * offset will be applied to the running_time of all data passing over the pad.
  83  * gst_pad_set_offset() can be used to change the offset.
  84  *
  85  * Convenience functions exist to start, pause and stop the task on a pad with
  86  * gst_pad_start_task(), gst_pad_pause_task() and gst_pad_stop_task()
  87  * respectively.
  88  */
  89 
  90 #include &quot;gst_private.h&quot;
  91 
  92 #include &quot;gstpad.h&quot;
  93 #include &quot;gstpadtemplate.h&quot;
  94 #include &quot;gstenumtypes.h&quot;
  95 #include &quot;gstutils.h&quot;
  96 #include &quot;gstinfo.h&quot;
  97 #include &quot;gsterror.h&quot;
  98 #include &quot;gsttracerutils.h&quot;
  99 #include &quot;gstvalue.h&quot;
 100 #include &quot;glib-compat-private.h&quot;
 101 
 102 GST_DEBUG_CATEGORY_STATIC (debug_dataflow);
 103 #define GST_CAT_DEFAULT GST_CAT_PADS
 104 
 105 /* Pad signals and args */
 106 enum
 107 {
 108   PAD_LINKED,
 109   PAD_UNLINKED,
 110   /* FILL ME */
 111   LAST_SIGNAL
 112 };
 113 
 114 enum
 115 {
 116   PAD_PROP_0,
 117   PAD_PROP_CAPS,
 118   PAD_PROP_DIRECTION,
 119   PAD_PROP_TEMPLATE,
 120   PAD_PROP_OFFSET
 121       /* FILL ME */
 122 };
 123 
 124 #define _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH (GST_PAD_PROBE_TYPE_ALL_BOTH | GST_PAD_PROBE_TYPE_EVENT_FLUSH)
 125 
 126 /* we have a pending and an active event on the pad. On source pads only the
 127  * active event is used. On sinkpads, events are copied to the pending entry and
 128  * moved to the active event when the eventfunc returned %TRUE. */
 129 typedef struct
 130 {
 131   gboolean received;
 132   GstEvent *event;
 133 } PadEvent;
 134 
 135 struct _GstPadPrivate
 136 {
 137   guint events_cookie;
 138   GArray *events;
 139   guint last_cookie;
 140 
 141   gint using;
 142   guint probe_list_cookie;
 143 
 144   /* counter of how many idle probes are running directly from the add_probe
 145    * call. Used to block any data flowing in the pad while the idle callback
 146    * Doesn&#39;t finish its work */
 147   gint idle_running;
 148 
 149   /* conditional and variable used to ensure pads only get (de)activated
 150    * by a single thread at a time. Protected by the object lock */
 151   GCond activation_cond;
 152   gboolean in_activation;
 153 };
 154 
 155 typedef struct
 156 {
 157   GHook hook;
 158 } GstProbe;
 159 
 160 #define GST_PAD_IS_RUNNING_IDLE_PROBE(p) \
 161     (((GstPad *)(p))-&gt;priv-&gt;idle_running &gt; 0)
 162 
 163 typedef struct
 164 {
 165   GstPad *pad;
 166   GstPadProbeInfo *info;
 167   gboolean dropped;
 168   gboolean pass;
 169   gboolean handled;
 170   gboolean marshalled;
 171 
 172   gulong *called_probes;
 173   guint n_called_probes;
 174   guint called_probes_size;
 175   gboolean retry;
 176 } ProbeMarshall;
 177 
 178 static void gst_pad_dispose (GObject * object);
 179 static void gst_pad_finalize (GObject * object);
 180 static void gst_pad_set_property (GObject * object, guint prop_id,
 181     const GValue * value, GParamSpec * pspec);
 182 static void gst_pad_get_property (GObject * object, guint prop_id,
 183     GValue * value, GParamSpec * pspec);
 184 
 185 static void gst_pad_set_pad_template (GstPad * pad, GstPadTemplate * templ);
 186 static gboolean gst_pad_activate_default (GstPad * pad, GstObject * parent);
 187 static GstFlowReturn gst_pad_chain_list_default (GstPad * pad,
 188     GstObject * parent, GstBufferList * list);
 189 
 190 static GstFlowReturn gst_pad_send_event_unchecked (GstPad * pad,
 191     GstEvent * event, GstPadProbeType type);
 192 static GstFlowReturn gst_pad_push_event_unchecked (GstPad * pad,
 193     GstEvent * event, GstPadProbeType type);
 194 
 195 static gboolean activate_mode_internal (GstPad * pad, GstObject * parent,
 196     GstPadMode mode, gboolean active);
 197 
 198 static guint gst_pad_signals[LAST_SIGNAL] = { 0 };
 199 
 200 static GParamSpec *pspec_caps = NULL;
 201 
 202 /* quarks for probe signals */
 203 static GQuark buffer_quark;
 204 static GQuark buffer_list_quark;
 205 static GQuark event_quark;
 206 
 207 typedef struct
 208 {
 209   const gint ret;
 210   const gchar *name;
 211   GQuark quark;
 212 } GstFlowQuarks;
 213 
 214 static GstFlowQuarks flow_quarks[] = {
 215   {GST_FLOW_CUSTOM_SUCCESS, &quot;custom-success&quot;, 0},
 216   {GST_FLOW_OK, &quot;ok&quot;, 0},
 217   {GST_FLOW_NOT_LINKED, &quot;not-linked&quot;, 0},
 218   {GST_FLOW_FLUSHING, &quot;flushing&quot;, 0},
 219   {GST_FLOW_EOS, &quot;eos&quot;, 0},
 220   {GST_FLOW_NOT_NEGOTIATED, &quot;not-negotiated&quot;, 0},
 221   {GST_FLOW_ERROR, &quot;error&quot;, 0},
 222   {GST_FLOW_NOT_SUPPORTED, &quot;not-supported&quot;, 0},
 223   {GST_FLOW_CUSTOM_ERROR, &quot;custom-error&quot;, 0}
 224 };
 225 
 226 /**
 227  * gst_flow_get_name:
 228  * @ret: a #GstFlowReturn to get the name of.
 229  *
 230  * Gets a string representing the given flow return.
 231  *
 232  * Returns: a static string with the name of the flow return.
 233  */
 234 const gchar *
 235 gst_flow_get_name (GstFlowReturn ret)
 236 {
 237   gint i;
 238 
 239   ret = CLAMP (ret, GST_FLOW_CUSTOM_ERROR, GST_FLOW_CUSTOM_SUCCESS);
 240 
 241   for (i = 0; i &lt; G_N_ELEMENTS (flow_quarks); i++) {
 242     if (ret == flow_quarks[i].ret)
 243       return flow_quarks[i].name;
 244   }
 245   return &quot;unknown&quot;;
 246 }
 247 
 248 /**
 249  * gst_flow_to_quark:
 250  * @ret: a #GstFlowReturn to get the quark of.
 251  *
 252  * Get the unique quark for the given GstFlowReturn.
 253  *
 254  * Returns: the quark associated with the flow return or 0 if an
 255  * invalid return was specified.
 256  */
 257 GQuark
 258 gst_flow_to_quark (GstFlowReturn ret)
 259 {
 260   gint i;
 261 
 262   ret = CLAMP (ret, GST_FLOW_CUSTOM_ERROR, GST_FLOW_CUSTOM_SUCCESS);
 263 
 264   for (i = 0; i &lt; G_N_ELEMENTS (flow_quarks); i++) {
 265     if (ret == flow_quarks[i].ret)
 266       return flow_quarks[i].quark;
 267   }
 268   return 0;
 269 }
 270 
 271 /**
 272  * gst_pad_link_get_name:
 273  * @ret: a #GstPadLinkReturn to get the name of.
 274  *
 275  * Gets a string representing the given pad-link return.
 276  *
 277  * Returns: a static string with the name of the pad-link return.
 278  *
 279  * Since: 1.4
 280  */
 281 const gchar *
 282 gst_pad_link_get_name (GstPadLinkReturn ret)
 283 {
 284   switch (ret) {
 285     case GST_PAD_LINK_OK:
 286       return &quot;ok&quot;;
 287     case GST_PAD_LINK_WRONG_HIERARCHY:
 288       return &quot;wrong hierarchy&quot;;
 289     case GST_PAD_LINK_WAS_LINKED:
 290       return &quot;was linked&quot;;
 291     case GST_PAD_LINK_WRONG_DIRECTION:
 292       return &quot;wrong direction&quot;;
 293     case GST_PAD_LINK_NOFORMAT:
 294       return &quot;no common format&quot;;
 295     case GST_PAD_LINK_NOSCHED:
 296       return &quot;incompatible scheduling&quot;;
 297     case GST_PAD_LINK_REFUSED:
 298       return &quot;refused&quot;;
 299   }
 300   g_return_val_if_reached (&quot;unknown&quot;);
 301 }
 302 
 303 #define _do_init \
 304 { \
 305   gint i; \
 306   \
 307   buffer_quark = g_quark_from_static_string (&quot;buffer&quot;); \
 308   buffer_list_quark = g_quark_from_static_string (&quot;bufferlist&quot;); \
 309   event_quark = g_quark_from_static_string (&quot;event&quot;); \
 310   \
 311   for (i = 0; i &lt; G_N_ELEMENTS (flow_quarks); i++) {      \
 312     flow_quarks[i].quark = g_quark_from_static_string (flow_quarks[i].name); \
 313   } \
 314   \
 315   GST_DEBUG_CATEGORY_INIT (debug_dataflow, &quot;GST_DATAFLOW&quot;, \
 316       GST_DEBUG_BOLD | GST_DEBUG_FG_GREEN, &quot;dataflow inside pads&quot;); \
 317 }
 318 
 319 #define gst_pad_parent_class parent_class
 320 G_DEFINE_TYPE_WITH_CODE (GstPad, gst_pad, GST_TYPE_OBJECT,
 321     G_ADD_PRIVATE (GstPad) _do_init);
 322 
 323 static void
 324 gst_pad_class_init (GstPadClass * klass)
 325 {
 326   GObjectClass *gobject_class;
 327   GstObjectClass *gstobject_class;
 328 
 329   gobject_class = G_OBJECT_CLASS (klass);
 330   gstobject_class = GST_OBJECT_CLASS (klass);
 331 
 332   gobject_class-&gt;dispose = gst_pad_dispose;
 333   gobject_class-&gt;finalize = gst_pad_finalize;
 334   gobject_class-&gt;set_property = gst_pad_set_property;
 335   gobject_class-&gt;get_property = gst_pad_get_property;
 336 
 337   /**
 338    * GstPad::linked:
 339    * @pad: the pad that emitted the signal
 340    * @peer: the peer pad that has been connected
 341    *
 342    * Signals that a pad has been linked to the peer pad.
 343    */
 344   gst_pad_signals[PAD_LINKED] =
 345       g_signal_new (&quot;linked&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 346       G_STRUCT_OFFSET (GstPadClass, linked), NULL, NULL,
 347       g_cclosure_marshal_generic, G_TYPE_NONE, 1, GST_TYPE_PAD);
 348   /**
 349    * GstPad::unlinked:
 350    * @pad: the pad that emitted the signal
 351    * @peer: the peer pad that has been disconnected
 352    *
 353    * Signals that a pad has been unlinked from the peer pad.
 354    */
 355   gst_pad_signals[PAD_UNLINKED] =
 356       g_signal_new (&quot;unlinked&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 357       G_STRUCT_OFFSET (GstPadClass, unlinked), NULL, NULL,
 358       g_cclosure_marshal_generic, G_TYPE_NONE, 1, GST_TYPE_PAD);
 359 
 360   pspec_caps = g_param_spec_boxed (&quot;caps&quot;, &quot;Caps&quot;,
 361       &quot;The capabilities of the pad&quot;, GST_TYPE_CAPS,
 362       G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
 363   g_object_class_install_property (gobject_class, PAD_PROP_CAPS, pspec_caps);
 364 
 365   g_object_class_install_property (gobject_class, PAD_PROP_DIRECTION,
 366       g_param_spec_enum (&quot;direction&quot;, &quot;Direction&quot;, &quot;The direction of the pad&quot;,
 367           GST_TYPE_PAD_DIRECTION, GST_PAD_UNKNOWN,
 368           G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_STRINGS));
 369 
 370   /* FIXME, Make G_PARAM_CONSTRUCT_ONLY when we fix ghostpads. */
 371   g_object_class_install_property (gobject_class, PAD_PROP_TEMPLATE,
 372       g_param_spec_object (&quot;template&quot;, &quot;Template&quot;,
 373           &quot;The GstPadTemplate of this pad&quot;, GST_TYPE_PAD_TEMPLATE,
 374           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 375 
 376   /**
 377    * GstPad:offset:
 378    *
 379    * The offset that will be applied to the running time of the pad.
 380    *
 381    * Since: 1.6
 382    */
 383   g_object_class_install_property (gobject_class, PAD_PROP_OFFSET,
 384       g_param_spec_int64 (&quot;offset&quot;, &quot;Offset&quot;,
 385           &quot;The running time offset of the pad&quot;, 0, G_MAXINT64, 0,
 386           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 387 
 388   gstobject_class-&gt;path_string_separator = &quot;.&quot;;
 389 
 390   /* Register common function pointer descriptions */
 391   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_activate_default);
 392   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_event_default);
 393   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_query_default);
 394   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_iterate_internal_links_default);
 395   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_chain_list_default);
 396 }
 397 
 398 static void
 399 gst_pad_init (GstPad * pad)
 400 {
 401   pad-&gt;priv = gst_pad_get_instance_private (pad);
 402 
 403   GST_PAD_DIRECTION (pad) = GST_PAD_UNKNOWN;
 404 
 405   GST_PAD_ACTIVATEFUNC (pad) = gst_pad_activate_default;
 406   GST_PAD_EVENTFUNC (pad) = gst_pad_event_default;
 407   GST_PAD_QUERYFUNC (pad) = gst_pad_query_default;
 408   GST_PAD_ITERINTLINKFUNC (pad) = gst_pad_iterate_internal_links_default;
 409   GST_PAD_CHAINLISTFUNC (pad) = gst_pad_chain_list_default;
 410 
 411   GST_PAD_SET_FLUSHING (pad);
 412 
 413   g_rec_mutex_init (&amp;pad-&gt;stream_rec_lock);
 414 
 415   g_cond_init (&amp;pad-&gt;block_cond);
 416 
 417   g_hook_list_init (&amp;pad-&gt;probes, sizeof (GstProbe));
 418 
 419   pad-&gt;priv-&gt;events = g_array_sized_new (FALSE, TRUE, sizeof (PadEvent), 16);
 420   pad-&gt;priv-&gt;events_cookie = 0;
 421   pad-&gt;priv-&gt;last_cookie = -1;
 422   g_cond_init (&amp;pad-&gt;priv-&gt;activation_cond);
 423 
 424   pad-&gt;ABI.abi.last_flowret = GST_FLOW_FLUSHING;
 425 }
 426 
 427 /* called when setting the pad inactive. It removes all sticky events from
 428  * the pad. must be called with object lock */
 429 static void
 430 remove_events (GstPad * pad)
 431 {
 432   guint i, len;
 433   GArray *events;
 434   gboolean notify = FALSE;
 435 
 436   events = pad-&gt;priv-&gt;events;
 437 
 438   len = events-&gt;len;
 439   for (i = 0; i &lt; len; i++) {
 440     PadEvent *ev = &amp;g_array_index (events, PadEvent, i);
 441     GstEvent *event = ev-&gt;event;
 442 
 443     ev-&gt;event = NULL;
 444 
 445     if (event &amp;&amp; GST_EVENT_TYPE (event) == GST_EVENT_CAPS)
 446       notify = TRUE;
 447 
 448     gst_event_unref (event);
 449   }
 450 
 451   GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_PENDING_EVENTS);
 452   g_array_set_size (events, 0);
 453   pad-&gt;priv-&gt;events_cookie++;
 454 
 455   if (notify) {
 456     GST_OBJECT_UNLOCK (pad);
 457 
 458     GST_DEBUG_OBJECT (pad, &quot;notify caps&quot;);
 459     g_object_notify_by_pspec ((GObject *) pad, pspec_caps);
 460 
 461     GST_OBJECT_LOCK (pad);
 462   }
 463 }
 464 
 465 /* should be called with object lock */
 466 static PadEvent *
 467 find_event_by_type (GstPad * pad, GstEventType type, guint idx)
 468 {
 469   guint i, len;
 470   GArray *events;
 471   PadEvent *ev;
 472 
 473   events = pad-&gt;priv-&gt;events;
 474   len = events-&gt;len;
 475 
 476   for (i = 0; i &lt; len; i++) {
 477     ev = &amp;g_array_index (events, PadEvent, i);
 478     if (ev-&gt;event == NULL)
 479       continue;
 480 
 481     if (GST_EVENT_TYPE (ev-&gt;event) == type) {
 482       if (idx == 0)
 483         goto found;
 484       idx--;
 485     } else if (GST_EVENT_TYPE (ev-&gt;event) &gt; type) {
 486       break;
 487     }
 488   }
 489   ev = NULL;
 490 found:
 491   return ev;
 492 }
 493 
 494 /* should be called with OBJECT lock */
 495 static PadEvent *
 496 find_event (GstPad * pad, GstEvent * event)
 497 {
 498   guint i, len;
 499   GArray *events;
 500   PadEvent *ev;
 501 
 502   events = pad-&gt;priv-&gt;events;
 503   len = events-&gt;len;
 504 
 505   for (i = 0; i &lt; len; i++) {
 506     ev = &amp;g_array_index (events, PadEvent, i);
 507     if (event == ev-&gt;event)
 508       goto found;
 509     else if (GST_EVENT_TYPE (ev-&gt;event) &gt; GST_EVENT_TYPE (event))
 510       break;
 511   }
 512   ev = NULL;
 513 found:
 514   return ev;
 515 }
 516 
 517 /* should be called with OBJECT lock */
 518 static void
 519 remove_event_by_type (GstPad * pad, GstEventType type)
 520 {
 521   guint i, len;
 522   GArray *events;
 523   PadEvent *ev;
 524 
 525   events = pad-&gt;priv-&gt;events;
 526   len = events-&gt;len;
 527 
 528   i = 0;
 529   while (i &lt; len) {
 530     ev = &amp;g_array_index (events, PadEvent, i);
 531     if (ev-&gt;event == NULL)
 532       goto next;
 533 
 534     if (GST_EVENT_TYPE (ev-&gt;event) &gt; type)
 535       break;
 536     else if (GST_EVENT_TYPE (ev-&gt;event) != type)
 537       goto next;
 538 
 539     gst_event_unref (ev-&gt;event);
 540     g_array_remove_index (events, i);
 541     len--;
 542     pad-&gt;priv-&gt;events_cookie++;
 543     continue;
 544 
 545   next:
 546     i++;
 547   }
 548 }
 549 
 550 /* check all events on srcpad against those on sinkpad. All events that are not
 551  * on sinkpad are marked as received=%FALSE and the PENDING_EVENTS is set on the
 552  * srcpad so that the events will be sent next time */
 553 /* should be called with srcpad and sinkpad LOCKS */
 554 static void
 555 schedule_events (GstPad * srcpad, GstPad * sinkpad)
 556 {
 557   gint i, len;
 558   GArray *events;
 559   PadEvent *ev;
 560   gboolean pending = FALSE;
 561 
 562   events = srcpad-&gt;priv-&gt;events;
 563   len = events-&gt;len;
 564 
 565   for (i = 0; i &lt; len; i++) {
 566     ev = &amp;g_array_index (events, PadEvent, i);
 567     if (ev-&gt;event == NULL)
 568       continue;
 569 
 570     if (sinkpad == NULL || !find_event (sinkpad, ev-&gt;event)) {
 571       ev-&gt;received = FALSE;
 572       pending = TRUE;
 573     }
 574   }
 575   if (pending)
 576     GST_OBJECT_FLAG_SET (srcpad, GST_PAD_FLAG_PENDING_EVENTS);
 577 }
 578 
 579 typedef gboolean (*PadEventFunction) (GstPad * pad, PadEvent * ev,
 580     gpointer user_data);
 581 
 582 /* should be called with pad LOCK */
 583 static void
 584 events_foreach (GstPad * pad, PadEventFunction func, gpointer user_data)
 585 {
 586   guint i, len;
 587   GArray *events;
 588   gboolean ret;
 589   guint cookie;
 590 
 591   events = pad-&gt;priv-&gt;events;
 592 
 593 restart:
 594   cookie = pad-&gt;priv-&gt;events_cookie;
 595   i = 0;
 596   len = events-&gt;len;
 597   while (i &lt; len) {
 598     PadEvent *ev, ev_ret;
 599 
 600     ev = &amp;g_array_index (events, PadEvent, i);
 601     if (G_UNLIKELY (ev-&gt;event == NULL))
 602       goto next;
 603 
 604     /* take additional ref, func might release the lock */
 605     ev_ret.event = gst_event_ref (ev-&gt;event);
 606     ev_ret.received = ev-&gt;received;
 607 
 608     ret = func (pad, &amp;ev_ret, user_data);
 609 
 610     /* recheck the cookie, lock might have been released and the list could have
 611      * changed */
 612     if (G_UNLIKELY (cookie != pad-&gt;priv-&gt;events_cookie)) {
 613       if (G_LIKELY (ev_ret.event))
 614         gst_event_unref (ev_ret.event);
 615       goto restart;
 616     }
 617 
 618     /* store the received state */
 619     ev-&gt;received = ev_ret.received;
 620 
 621     /* if the event changed, we need to do something */
 622     if (G_UNLIKELY (ev-&gt;event != ev_ret.event)) {
 623       if (G_UNLIKELY (ev_ret.event == NULL)) {
 624         /* function unreffed and set the event to NULL, remove it */
 625         gst_event_unref (ev-&gt;event);
 626         g_array_remove_index (events, i);
 627         len--;
 628         cookie = ++pad-&gt;priv-&gt;events_cookie;
 629         continue;
 630       } else {
 631         /* function gave a new event for us */
 632         gst_event_take (&amp;ev-&gt;event, ev_ret.event);
 633       }
 634     } else {
 635       /* just unref, nothing changed */
 636       gst_event_unref (ev_ret.event);
 637     }
 638     if (!ret)
 639       break;
 640   next:
 641     i++;
 642   }
 643 }
 644 
 645 /* should be called with LOCK */
 646 static GstEvent *
 647 _apply_pad_offset (GstPad * pad, GstEvent * event, gboolean upstream,
 648     gint64 pad_offset)
 649 {
 650   gint64 offset;
 651 
 652   GST_DEBUG_OBJECT (pad, &quot;apply pad offset %&quot; GST_STIME_FORMAT,
 653       GST_STIME_ARGS (pad_offset));
 654 
 655   if (GST_EVENT_TYPE (event) == GST_EVENT_SEGMENT) {
 656     GstSegment segment;
 657 
 658     g_assert (!upstream);
 659 
 660     /* copy segment values */
 661     gst_event_copy_segment (event, &amp;segment);
 662     gst_event_unref (event);
 663 
 664     gst_segment_offset_running_time (&amp;segment, segment.format, pad_offset);
 665     event = gst_event_new_segment (&amp;segment);
 666   }
 667 
 668   event = gst_event_make_writable (event);
 669   offset = gst_event_get_running_time_offset (event);
 670   if (upstream)
 671     offset -= pad_offset;
 672   else
 673     offset += pad_offset;
 674   gst_event_set_running_time_offset (event, offset);
 675 
 676   return event;
 677 }
 678 
 679 static inline GstEvent *
 680 apply_pad_offset (GstPad * pad, GstEvent * event, gboolean upstream)
 681 {
 682   if (G_UNLIKELY (pad-&gt;offset != 0))
 683     return _apply_pad_offset (pad, event, upstream, pad-&gt;offset);
 684   return event;
 685 }
 686 
 687 /* should be called with the OBJECT_LOCK */
 688 static GstCaps *
 689 get_pad_caps (GstPad * pad)
 690 {
 691   GstCaps *caps = NULL;
 692   PadEvent *ev;
 693 
 694   ev = find_event_by_type (pad, GST_EVENT_CAPS, 0);
 695   if (ev &amp;&amp; ev-&gt;event)
 696     gst_event_parse_caps (ev-&gt;event, &amp;caps);
 697 
 698   return caps;
 699 }
 700 
 701 static void
 702 gst_pad_dispose (GObject * object)
 703 {
 704   GstPad *pad = GST_PAD_CAST (object);
 705   GstPad *peer;
 706 
 707   GST_CAT_DEBUG_OBJECT (GST_CAT_REFCOUNTING, pad, &quot;%p dispose&quot;, pad);
 708 
 709   /* unlink the peer pad */
 710   if ((peer = gst_pad_get_peer (pad))) {
 711     /* window for MT unsafeness, someone else could unlink here
 712      * and then we call unlink with wrong pads. The unlink
 713      * function would catch this and safely return failed. */
 714     if (GST_PAD_IS_SRC (pad))
 715       gst_pad_unlink (pad, peer);
 716     else
 717       gst_pad_unlink (peer, pad);
 718 
 719     gst_object_unref (peer);
 720   }
 721 
 722   gst_pad_set_pad_template (pad, NULL);
 723 
 724   GST_OBJECT_LOCK (pad);
 725   remove_events (pad);
 726   GST_OBJECT_UNLOCK (pad);
 727 
 728   g_hook_list_clear (&amp;pad-&gt;probes);
 729 
 730   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
 731 }
 732 
 733 static void
 734 gst_pad_finalize (GObject * object)
 735 {
 736   GstPad *pad = GST_PAD_CAST (object);
 737   GstTask *task;
 738 
 739   /* in case the task is still around, clean it up */
 740   if ((task = GST_PAD_TASK (pad))) {
 741     gst_task_join (task);
 742     GST_PAD_TASK (pad) = NULL;
 743     gst_object_unref (task);
 744   }
 745 
 746   if (pad-&gt;activatenotify)
 747     pad-&gt;activatenotify (pad-&gt;activatedata);
 748   if (pad-&gt;activatemodenotify)
 749     pad-&gt;activatemodenotify (pad-&gt;activatemodedata);
 750   if (pad-&gt;linknotify)
 751     pad-&gt;linknotify (pad-&gt;linkdata);
 752   if (pad-&gt;unlinknotify)
 753     pad-&gt;unlinknotify (pad-&gt;unlinkdata);
 754   if (pad-&gt;chainnotify)
 755     pad-&gt;chainnotify (pad-&gt;chaindata);
 756   if (pad-&gt;chainlistnotify)
 757     pad-&gt;chainlistnotify (pad-&gt;chainlistdata);
 758   if (pad-&gt;getrangenotify)
 759     pad-&gt;getrangenotify (pad-&gt;getrangedata);
 760   if (pad-&gt;eventnotify)
 761     pad-&gt;eventnotify (pad-&gt;eventdata);
 762   if (pad-&gt;querynotify)
 763     pad-&gt;querynotify (pad-&gt;querydata);
 764   if (pad-&gt;iterintlinknotify)
 765     pad-&gt;iterintlinknotify (pad-&gt;iterintlinkdata);
 766 
 767   g_rec_mutex_clear (&amp;pad-&gt;stream_rec_lock);
 768   g_cond_clear (&amp;pad-&gt;block_cond);
 769   g_cond_clear (&amp;pad-&gt;priv-&gt;activation_cond);
 770   g_array_free (pad-&gt;priv-&gt;events, TRUE);
 771 
 772   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 773 }
 774 
 775 static void
 776 gst_pad_set_property (GObject * object, guint prop_id,
 777     const GValue * value, GParamSpec * pspec)
 778 {
 779   g_return_if_fail (GST_IS_PAD (object));
 780 
 781   switch (prop_id) {
 782     case PAD_PROP_DIRECTION:
 783       GST_PAD_DIRECTION (object) = (GstPadDirection) g_value_get_enum (value);
 784       break;
 785     case PAD_PROP_TEMPLATE:
 786       gst_pad_set_pad_template (GST_PAD_CAST (object),
 787           (GstPadTemplate *) g_value_get_object (value));
 788       break;
 789     case PAD_PROP_OFFSET:
 790       gst_pad_set_offset (GST_PAD_CAST (object), g_value_get_int64 (value));
 791       break;
 792     default:
 793       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 794       break;
 795   }
 796 }
 797 
 798 static void
 799 gst_pad_get_property (GObject * object, guint prop_id,
 800     GValue * value, GParamSpec * pspec)
 801 {
 802   g_return_if_fail (GST_IS_PAD (object));
 803 
 804   switch (prop_id) {
 805     case PAD_PROP_CAPS:
 806       GST_OBJECT_LOCK (object);
 807       g_value_set_boxed (value, get_pad_caps (GST_PAD_CAST (object)));
 808       GST_OBJECT_UNLOCK (object);
 809       break;
 810     case PAD_PROP_DIRECTION:
 811       g_value_set_enum (value, GST_PAD_DIRECTION (object));
 812       break;
 813     case PAD_PROP_TEMPLATE:
 814       g_value_set_object (value, GST_PAD_PAD_TEMPLATE (object));
 815       break;
 816     case PAD_PROP_OFFSET:
 817       g_value_set_int64 (value, gst_pad_get_offset (GST_PAD_CAST (object)));
 818       break;
 819     default:
 820       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 821       break;
 822   }
 823 }
 824 
 825 /**
 826  * gst_pad_new:
 827  * @name: (allow-none): the name of the new pad.
 828  * @direction: the #GstPadDirection of the pad.
 829  *
 830  * Creates a new pad with the given name in the given direction.
 831  * If name is %NULL, a guaranteed unique name (across all pads)
 832  * will be assigned.
 833  * This function makes a copy of the name so you can safely free the name.
 834  *
 835  * Returns: (transfer floating): a new #GstPad.
 836  *
 837  * MT safe.
 838  */
 839 GstPad *
 840 gst_pad_new (const gchar * name, GstPadDirection direction)
 841 {
 842   return g_object_new (GST_TYPE_PAD,
 843       &quot;name&quot;, name, &quot;direction&quot;, direction, NULL);
 844 }
 845 
 846 /**
 847  * gst_pad_new_from_template:
 848  * @templ: the pad template to use
 849  * @name: (allow-none): the name of the pad
 850  *
 851  * Creates a new pad with the given name from the given template.
 852  * If name is %NULL, a guaranteed unique name (across all pads)
 853  * will be assigned.
 854  * This function makes a copy of the name so you can safely free the name.
 855  *
 856  * Returns: (transfer floating): a new #GstPad.
 857  */
 858 GstPad *
 859 gst_pad_new_from_template (GstPadTemplate * templ, const gchar * name)
 860 {
 861   GType pad_type =
 862       GST_PAD_TEMPLATE_GTYPE (templ) ==
 863       G_TYPE_NONE ? GST_TYPE_PAD : GST_PAD_TEMPLATE_GTYPE (templ);
 864 
 865   g_return_val_if_fail (GST_IS_PAD_TEMPLATE (templ), NULL);
 866 
 867   return g_object_new (pad_type,
 868       &quot;name&quot;, name, &quot;direction&quot;, templ-&gt;direction, &quot;template&quot;, templ, NULL);
 869 }
 870 
 871 /**
 872  * gst_pad_new_from_static_template:
 873  * @templ: the #GstStaticPadTemplate to use
 874  * @name: the name of the pad
 875  *
 876  * Creates a new pad with the given name from the given static template.
 877  * If name is %NULL, a guaranteed unique name (across all pads)
 878  * will be assigned.
 879  * This function makes a copy of the name so you can safely free the name.
 880  *
 881  * Returns: (transfer floating): a new #GstPad.
 882  */
 883 GstPad *
 884 gst_pad_new_from_static_template (GstStaticPadTemplate * templ,
 885     const gchar * name)
 886 {
 887   GstPad *pad;
 888   GstPadTemplate *template;
 889 
 890   template = gst_static_pad_template_get (templ);
 891   pad = gst_pad_new_from_template (template, name);
 892   gst_object_unref (template);
 893   return pad;
 894 }
 895 
 896 #define ACQUIRE_PARENT(pad, parent, label)                      \
 897   G_STMT_START {                                                \
 898     if (G_LIKELY ((parent = GST_OBJECT_PARENT (pad))))          \
 899       gst_object_ref (parent);                                  \
 900     else if (G_LIKELY (GST_PAD_NEEDS_PARENT (pad)))             \
 901       goto label;                                               \
 902   } G_STMT_END
 903 
 904 #define RELEASE_PARENT(parent)                                  \
 905   G_STMT_START {                                                \
 906     if (G_LIKELY (parent))                                      \
 907       gst_object_unref (parent);                                \
 908   } G_STMT_END
 909 
 910 /**
 911  * gst_pad_get_direction:
 912  * @pad: a #GstPad to get the direction of.
 913  *
 914  * Gets the direction of the pad. The direction of the pad is
 915  * decided at construction time so this function does not take
 916  * the LOCK.
 917  *
 918  * Returns: the #GstPadDirection of the pad.
 919  *
 920  * MT safe.
 921  */
 922 GstPadDirection
 923 gst_pad_get_direction (GstPad * pad)
 924 {
 925   GstPadDirection result;
 926 
 927   /* PAD_UNKNOWN is a little silly but we need some sort of
 928    * error return value */
 929   g_return_val_if_fail (GST_IS_PAD (pad), GST_PAD_UNKNOWN);
 930 
 931   result = GST_PAD_DIRECTION (pad);
 932 
 933   return result;
 934 }
 935 
 936 static gboolean
 937 gst_pad_activate_default (GstPad * pad, GstObject * parent)
 938 {
 939   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
 940 
 941   return activate_mode_internal (pad, parent, GST_PAD_MODE_PUSH, TRUE);
 942 }
 943 
 944 /**
 945  * gst_pad_mode_get_name:
 946  * @mode: the pad mode
 947  *
 948  * Return the name of a pad mode, for use in debug messages mostly.
 949  *
 950  * Returns: short mnemonic for pad mode @mode
 951  */
 952 const gchar *
 953 gst_pad_mode_get_name (GstPadMode mode)
 954 {
 955   switch (mode) {
 956     case GST_PAD_MODE_NONE:
 957       return &quot;none&quot;;
 958     case GST_PAD_MODE_PUSH:
 959       return &quot;push&quot;;
 960     case GST_PAD_MODE_PULL:
 961       return &quot;pull&quot;;
 962     default:
 963       break;
 964   }
 965   return &quot;unknown&quot;;
 966 }
 967 
 968 /* Returns TRUE if pad wasn&#39;t already in the new_mode */
 969 static gboolean
 970 pre_activate (GstPad * pad, GstPadMode new_mode)
 971 {
 972   switch (new_mode) {
 973     case GST_PAD_MODE_NONE:
 974       GST_OBJECT_LOCK (pad);
 975       while (G_UNLIKELY (pad-&gt;priv-&gt;in_activation))
 976         g_cond_wait (&amp;pad-&gt;priv-&gt;activation_cond, GST_OBJECT_GET_LOCK (pad));
 977       if (new_mode == GST_PAD_MODE (pad)) {
 978         GST_WARNING_OBJECT (pad,
 979             &quot;Pad is already in the process of being deactivated&quot;);
 980         GST_OBJECT_UNLOCK (pad);
 981         return FALSE;
 982       }
 983       pad-&gt;priv-&gt;in_activation = TRUE;
 984       GST_DEBUG_OBJECT (pad, &quot;setting PAD_MODE NONE, set flushing&quot;);
 985       GST_PAD_SET_FLUSHING (pad);
 986       pad-&gt;ABI.abi.last_flowret = GST_FLOW_FLUSHING;
 987       GST_PAD_MODE (pad) = new_mode;
 988       /* unlock blocked pads so element can resume and stop */
 989       GST_PAD_BLOCK_BROADCAST (pad);
 990       GST_OBJECT_UNLOCK (pad);
 991       break;
 992     case GST_PAD_MODE_PUSH:
 993     case GST_PAD_MODE_PULL:
 994       GST_OBJECT_LOCK (pad);
 995       while (G_UNLIKELY (pad-&gt;priv-&gt;in_activation))
 996         g_cond_wait (&amp;pad-&gt;priv-&gt;activation_cond, GST_OBJECT_GET_LOCK (pad));
 997       if (new_mode == GST_PAD_MODE (pad)) {
 998         GST_WARNING_OBJECT (pad,
 999             &quot;Pad is already in the process of being activated&quot;);
1000         GST_OBJECT_UNLOCK (pad);
1001         return FALSE;
1002       }
1003       pad-&gt;priv-&gt;in_activation = TRUE;
1004       GST_DEBUG_OBJECT (pad, &quot;setting pad into %s mode, unset flushing&quot;,
1005           gst_pad_mode_get_name (new_mode));
1006       GST_PAD_UNSET_FLUSHING (pad);
1007       pad-&gt;ABI.abi.last_flowret = GST_FLOW_OK;
1008       GST_PAD_MODE (pad) = new_mode;
1009       if (GST_PAD_IS_SINK (pad)) {
1010         GstPad *peer;
1011         /* make sure the peer src pad sends us all events */
1012         if ((peer = GST_PAD_PEER (pad))) {
1013           gst_object_ref (peer);
1014           GST_OBJECT_UNLOCK (pad);
1015 
1016           GST_DEBUG_OBJECT (pad, &quot;reschedule events on peer %s:%s&quot;,
1017               GST_DEBUG_PAD_NAME (peer));
1018 
1019           GST_OBJECT_LOCK (peer);
1020           schedule_events (peer, NULL);
1021           GST_OBJECT_UNLOCK (peer);
1022 
1023           gst_object_unref (peer);
1024         } else {
1025           GST_OBJECT_UNLOCK (pad);
1026         }
1027       } else {
1028         GST_OBJECT_UNLOCK (pad);
1029       }
1030       break;
1031   }
1032   return TRUE;
1033 }
1034 
1035 static void
1036 post_activate (GstPad * pad, GstPadMode new_mode)
1037 {
1038   switch (new_mode) {
1039     case GST_PAD_MODE_NONE:
1040       GST_OBJECT_LOCK (pad);
1041       pad-&gt;priv-&gt;in_activation = FALSE;
1042       g_cond_broadcast (&amp;pad-&gt;priv-&gt;activation_cond);
1043       GST_OBJECT_UNLOCK (pad);
1044 
1045       /* ensures that streaming stops */
1046       GST_PAD_STREAM_LOCK (pad);
1047       GST_DEBUG_OBJECT (pad, &quot;stopped streaming&quot;);
1048       GST_OBJECT_LOCK (pad);
1049       remove_events (pad);
1050       GST_OBJECT_UNLOCK (pad);
1051       GST_PAD_STREAM_UNLOCK (pad);
1052       break;
1053     case GST_PAD_MODE_PUSH:
1054     case GST_PAD_MODE_PULL:
1055       GST_OBJECT_LOCK (pad);
1056       pad-&gt;priv-&gt;in_activation = FALSE;
1057       g_cond_broadcast (&amp;pad-&gt;priv-&gt;activation_cond);
1058       GST_OBJECT_UNLOCK (pad);
1059       /* NOP */
1060       break;
1061   }
1062 }
1063 
1064 /**
1065  * gst_pad_set_active:
1066  * @pad: the #GstPad to activate or deactivate.
1067  * @active: whether or not the pad should be active.
1068  *
1069  * Activates or deactivates the given pad.
1070  * Normally called from within core state change functions.
1071  *
1072  * If @active, makes sure the pad is active. If it is already active, either in
1073  * push or pull mode, just return. Otherwise dispatches to the pad&#39;s activate
1074  * function to perform the actual activation.
1075  *
1076  * If not @active, calls gst_pad_activate_mode() with the pad&#39;s current mode
1077  * and a %FALSE argument.
1078  *
1079  * Returns: %TRUE if the operation was successful.
1080  *
1081  * MT safe.
1082  */
1083 gboolean
1084 gst_pad_set_active (GstPad * pad, gboolean active)
1085 {
1086   GstObject *parent;
1087   GstPadMode old;
1088   gboolean ret = FALSE;
1089 
1090   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
1091 
1092   GST_OBJECT_LOCK (pad);
1093   old = GST_PAD_MODE (pad);
1094   ACQUIRE_PARENT (pad, parent, no_parent);
1095   GST_OBJECT_UNLOCK (pad);
1096 
1097   if (active) {
1098     if (old == GST_PAD_MODE_NONE) {
1099       GST_DEBUG_OBJECT (pad, &quot;activating pad from none&quot;);
1100       ret = (GST_PAD_ACTIVATEFUNC (pad)) (pad, parent);
1101       if (ret)
1102         pad-&gt;ABI.abi.last_flowret = GST_FLOW_OK;
1103     } else {
1104       GST_DEBUG_OBJECT (pad, &quot;pad was active in %s mode&quot;,
1105           gst_pad_mode_get_name (old));
1106       ret = TRUE;
1107     }
1108   } else {
1109     if (old == GST_PAD_MODE_NONE) {
1110       GST_DEBUG_OBJECT (pad, &quot;pad was inactive&quot;);
1111       ret = TRUE;
1112     } else {
1113       GST_DEBUG_OBJECT (pad, &quot;deactivating pad from %s mode&quot;,
1114           gst_pad_mode_get_name (old));
1115       ret = activate_mode_internal (pad, parent, old, FALSE);
1116       if (ret)
1117         pad-&gt;ABI.abi.last_flowret = GST_FLOW_FLUSHING;
1118     }
1119   }
1120 
1121   RELEASE_PARENT (parent);
1122 
1123   if (G_UNLIKELY (!ret))
1124     goto failed;
1125 
1126   return ret;
1127 
1128   /* ERRORS */
1129 no_parent:
1130   {
1131     GST_DEBUG_OBJECT (pad, &quot;no parent&quot;);
1132     GST_OBJECT_UNLOCK (pad);
1133     return FALSE;
1134   }
1135 failed:
1136   {
1137     GST_OBJECT_LOCK (pad);
1138     if (!active) {
1139       g_critical (&quot;Failed to deactivate pad %s:%s, very bad&quot;,
1140           GST_DEBUG_PAD_NAME (pad));
1141     } else {
1142       GST_WARNING_OBJECT (pad, &quot;Failed to activate pad&quot;);
1143     }
1144     GST_OBJECT_UNLOCK (pad);
1145     return FALSE;
1146   }
1147 }
1148 
1149 static gboolean
1150 activate_mode_internal (GstPad * pad, GstObject * parent, GstPadMode mode,
1151     gboolean active)
1152 {
1153   gboolean res = FALSE;
1154   GstPadMode old, new;
1155   GstPadDirection dir;
1156   GstPad *peer;
1157 
1158   GST_OBJECT_LOCK (pad);
1159   old = GST_PAD_MODE (pad);
1160   dir = GST_PAD_DIRECTION (pad);
1161   GST_OBJECT_UNLOCK (pad);
1162 
1163   new = active ? mode : GST_PAD_MODE_NONE;
1164 
1165   if (old == new)
1166     goto was_ok;
1167 
1168   if (active &amp;&amp; old != mode &amp;&amp; old != GST_PAD_MODE_NONE) {
1169     /* pad was activate in the wrong direction, deactivate it
1170      * and reactivate it in the requested mode */
1171     GST_DEBUG_OBJECT (pad, &quot;deactivating pad from %s mode&quot;,
1172         gst_pad_mode_get_name (old));
1173 
1174     if (G_UNLIKELY (!activate_mode_internal (pad, parent, old, FALSE)))
1175       goto deactivate_failed;
1176     old = GST_PAD_MODE_NONE;
1177   }
1178 
1179   switch (mode) {
1180     case GST_PAD_MODE_PULL:
1181     {
1182       if (dir == GST_PAD_SINK) {
1183         if ((peer = gst_pad_get_peer (pad))) {
1184           GST_DEBUG_OBJECT (pad, &quot;calling peer&quot;);
1185           if (G_UNLIKELY (!gst_pad_activate_mode (peer, mode, active)))
1186             goto peer_failed;
1187           gst_object_unref (peer);
1188         } else {
1189           /* there is no peer, this is only fatal when we activate. When we
1190            * deactivate, we must assume the application has unlinked the peer and
1191            * will deactivate it eventually. */
1192           if (active)
1193             goto not_linked;
1194           else
1195             GST_DEBUG_OBJECT (pad, &quot;deactivating unlinked pad&quot;);
1196         }
1197       } else {
1198         if (G_UNLIKELY (GST_PAD_GETRANGEFUNC (pad) == NULL))
1199           goto failure;         /* Can&#39;t activate pull on a src without a
1200                                    getrange function */
1201       }
1202       break;
1203     }
1204     default:
1205       break;
1206   }
1207 
1208   /* Mark pad as needing reconfiguration */
1209   if (active)
1210     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);
1211 
1212   /* pre_activate returns TRUE if we weren&#39;t already in the process of
1213    * switching to the &#39;new&#39; mode */
1214   if (pre_activate (pad, new)) {
1215 
1216     if (GST_PAD_ACTIVATEMODEFUNC (pad)) {
1217       if (G_UNLIKELY (!GST_PAD_ACTIVATEMODEFUNC (pad) (pad, parent, mode,
1218                   active)))
1219         goto failure;
1220     } else {
1221       /* can happen for sinks of passthrough elements */
1222     }
1223 
1224     post_activate (pad, new);
1225   }
1226 
1227   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;%s in %s mode&quot;,
1228       active ? &quot;activated&quot; : &quot;deactivated&quot;, gst_pad_mode_get_name (mode));
1229 
1230 exit_success:
1231   res = TRUE;
1232 
1233   /* Clear sticky flags on deactivation */
1234   if (!active) {
1235     GST_OBJECT_LOCK (pad);
1236     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);
1237     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_EOS);
1238     GST_OBJECT_UNLOCK (pad);
1239   }
1240 
1241 exit:
1242   return res;
1243 
1244 was_ok:
1245   {
1246     GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;already %s in %s mode&quot;,
1247         active ? &quot;activated&quot; : &quot;deactivated&quot;, gst_pad_mode_get_name (mode));
1248     goto exit_success;
1249   }
1250 deactivate_failed:
1251   {
1252     GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad,
1253         &quot;failed to %s in switch to %s mode from %s mode&quot;,
1254         (active ? &quot;activate&quot; : &quot;deactivate&quot;), gst_pad_mode_get_name (mode),
1255         gst_pad_mode_get_name (old));
1256     goto exit;
1257   }
1258 peer_failed:
1259   {
1260     GST_OBJECT_LOCK (peer);
1261     GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad,
1262         &quot;activate_mode on peer (%s:%s) failed&quot;, GST_DEBUG_PAD_NAME (peer));
1263     GST_OBJECT_UNLOCK (peer);
1264     gst_object_unref (peer);
1265     goto exit;
1266   }
1267 not_linked:
1268   {
1269     GST_CAT_INFO_OBJECT (GST_CAT_PADS, pad, &quot;can&#39;t activate unlinked sink &quot;
1270         &quot;pad in pull mode&quot;);
1271     goto exit;
1272   }
1273 failure:
1274   {
1275     GST_OBJECT_LOCK (pad);
1276     GST_CAT_INFO_OBJECT (GST_CAT_PADS, pad, &quot;failed to %s in %s mode&quot;,
1277         active ? &quot;activate&quot; : &quot;deactivate&quot;, gst_pad_mode_get_name (mode));
1278     GST_PAD_SET_FLUSHING (pad);
1279     GST_PAD_MODE (pad) = old;
1280     pad-&gt;priv-&gt;in_activation = FALSE;
1281     g_cond_broadcast (&amp;pad-&gt;priv-&gt;activation_cond);
1282     GST_OBJECT_UNLOCK (pad);
1283     goto exit;
1284   }
1285 }
1286 
1287 /**
1288  * gst_pad_activate_mode:
1289  * @pad: the #GstPad to activate or deactivate.
1290  * @mode: the requested activation mode
1291  * @active: whether or not the pad should be active.
1292  *
1293  * Activates or deactivates the given pad in @mode via dispatching to the
1294  * pad&#39;s activatemodefunc. For use from within pad activation functions only.
1295  *
1296  * If you don&#39;t know what this is, you probably don&#39;t want to call it.
1297  *
1298  * Returns: %TRUE if the operation was successful.
1299  *
1300  * MT safe.
1301  */
1302 gboolean
1303 gst_pad_activate_mode (GstPad * pad, GstPadMode mode, gboolean active)
1304 {
1305   GstObject *parent;
1306   gboolean res;
1307   GstPadMode old, new;
1308 
1309   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
1310 
1311   GST_OBJECT_LOCK (pad);
1312 
1313   old = GST_PAD_MODE (pad);
1314   new = active ? mode : GST_PAD_MODE_NONE;
1315   if (old == new)
1316     goto was_ok;
1317 
1318   ACQUIRE_PARENT (pad, parent, no_parent);
1319 
1320   GST_OBJECT_UNLOCK (pad);
1321 
1322   res = activate_mode_internal (pad, parent, mode, active);
1323 
1324   RELEASE_PARENT (parent);
1325 
1326   return res;
1327 
1328 was_ok:
1329   {
1330     GST_OBJECT_UNLOCK (pad);
1331     GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;already %s in %s mode&quot;,
1332         active ? &quot;activated&quot; : &quot;deactivated&quot;, gst_pad_mode_get_name (mode));
1333     return TRUE;
1334   }
1335 no_parent:
1336   {
1337     GST_WARNING_OBJECT (pad, &quot;no parent&quot;);
1338     GST_OBJECT_UNLOCK (pad);
1339     return FALSE;
1340   }
1341 }
1342 
1343 /**
1344  * gst_pad_is_active:
1345  * @pad: the #GstPad to query
1346  *
1347  * Query if a pad is active
1348  *
1349  * Returns: %TRUE if the pad is active.
1350  *
1351  * MT safe.
1352  */
1353 gboolean
1354 gst_pad_is_active (GstPad * pad)
1355 {
1356   gboolean result = FALSE;
1357 
1358   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
1359 
1360   GST_OBJECT_LOCK (pad);
1361   result = GST_PAD_IS_ACTIVE (pad);
1362   GST_OBJECT_UNLOCK (pad);
1363 
1364   return result;
1365 }
1366 
1367 static void
1368 cleanup_hook (GstPad * pad, GHook * hook)
1369 {
1370   GstPadProbeType type;
1371 
1372   GST_DEBUG_OBJECT (pad,
1373       &quot;cleaning up hook %lu with flags %08x&quot;, hook-&gt;hook_id, hook-&gt;flags);
1374 
1375   if (!G_HOOK_IS_VALID (hook))
1376     return;
1377 
1378   type = (hook-&gt;flags) &gt;&gt; G_HOOK_FLAG_USER_SHIFT;
1379 
1380   if (type &amp; GST_PAD_PROBE_TYPE_BLOCKING) {
1381     /* unblock when we remove the last blocking probe */
1382     pad-&gt;num_blocked--;
1383     GST_DEBUG_OBJECT (pad, &quot;remove blocking probe, now %d left&quot;,
1384         pad-&gt;num_blocked);
1385 
1386     /* Might have new probes now that want to be called */
1387     GST_PAD_BLOCK_BROADCAST (pad);
1388 
1389     if (pad-&gt;num_blocked == 0) {
1390       GST_DEBUG_OBJECT (pad, &quot;last blocking probe removed, unblocking&quot;);
1391       GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_BLOCKED);
1392     }
1393   }
1394   g_hook_destroy_link (&amp;pad-&gt;probes, hook);
1395   pad-&gt;num_probes--;
1396 }
1397 
1398 /**
1399  * gst_pad_add_probe:
1400  * @pad: the #GstPad to add the probe to
1401  * @mask: the probe mask
1402  * @callback: #GstPadProbeCallback that will be called with notifications of
1403  *           the pad state
1404  * @user_data: (closure): user data passed to the callback
1405  * @destroy_data: #GDestroyNotify for user_data
1406  *
1407  * Be notified of different states of pads. The provided callback is called for
1408  * every state that matches @mask.
1409  *
1410  * Probes are called in groups: First GST_PAD_PROBE_TYPE_BLOCK probes are
1411  * called, then others, then finally GST_PAD_PROBE_TYPE_IDLE. The only
1412  * exception here are GST_PAD_PROBE_TYPE_IDLE probes that are called
1413  * immediately if the pad is already idle while calling gst_pad_add_probe().
1414  * In each of the groups, probes are called in the order in which they were
1415  * added.
1416  *
1417  * Returns: an id or 0 if no probe is pending. The id can be used to remove the
1418  * probe with gst_pad_remove_probe(). When using GST_PAD_PROBE_TYPE_IDLE it can
1419  * happen that the probe can be run immediately and if the probe returns
1420  * GST_PAD_PROBE_REMOVE this functions returns 0.
1421  *
1422  * MT safe.
1423  */
1424 gulong
1425 gst_pad_add_probe (GstPad * pad, GstPadProbeType mask,
1426     GstPadProbeCallback callback, gpointer user_data,
1427     GDestroyNotify destroy_data)
1428 {
1429   GHook *hook;
1430   gulong res;
1431 
1432   g_return_val_if_fail (GST_IS_PAD (pad), 0);
1433   g_return_val_if_fail (mask != 0, 0);
1434 
1435   GST_OBJECT_LOCK (pad);
1436 
1437   /* make a new probe */
1438   hook = g_hook_alloc (&amp;pad-&gt;probes);
1439 
1440   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;adding probe for mask 0x%08x&quot;,
1441       mask);
1442 
1443   /* when no constraints are given for the types, assume all types are
1444    * acceptable */
1445   if ((mask &amp; _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH) == 0)
1446     mask |= GST_PAD_PROBE_TYPE_ALL_BOTH;
1447   if ((mask &amp; GST_PAD_PROBE_TYPE_SCHEDULING) == 0)
1448     mask |= GST_PAD_PROBE_TYPE_SCHEDULING;
1449 
1450   /* store our flags and other fields */
1451   hook-&gt;flags |= (mask &lt;&lt; G_HOOK_FLAG_USER_SHIFT);
1452   hook-&gt;func = callback;
1453   hook-&gt;data = user_data;
1454   hook-&gt;destroy = destroy_data;
1455 
1456   /* add the probe */
1457   g_hook_append (&amp;pad-&gt;probes, hook);
1458   pad-&gt;num_probes++;
1459   /* incremenent cookie so that the new hook gets called */
1460   pad-&gt;priv-&gt;probe_list_cookie++;
1461 
1462   /* get the id of the hook, we return this and it can be used to remove the
1463    * probe later */
1464   res = hook-&gt;hook_id;
1465 
1466   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;got probe id %lu&quot;, res);
1467 
1468   if (mask &amp; GST_PAD_PROBE_TYPE_BLOCKING) {
1469     /* we have a block probe */
1470     pad-&gt;num_blocked++;
1471     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_BLOCKED);
1472     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;added blocking probe, &quot;
1473         &quot;now %d blocking probes&quot;, pad-&gt;num_blocked);
1474 
1475     /* Might have new probes now that want to be called */
1476     GST_PAD_BLOCK_BROADCAST (pad);
1477   }
1478 
1479   /* call the callback if we need to be called for idle callbacks */
1480   if ((mask &amp; GST_PAD_PROBE_TYPE_IDLE) &amp;&amp; (callback != NULL)) {
1481     if (pad-&gt;priv-&gt;using &gt; 0) {
1482       /* the pad is in use, we can&#39;t signal the idle callback yet. Since we set the
1483        * flag above, the last thread to leave the push will do the callback. New
1484        * threads going into the push will block. */
1485       GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
1486           &quot;pad is in use, delay idle callback&quot;);
1487       GST_OBJECT_UNLOCK (pad);
1488     } else {
1489       GstPadProbeInfo info = { GST_PAD_PROBE_TYPE_IDLE, res, };
1490       GstPadProbeReturn ret;
1491 
1492       /* Keep another ref, the callback could destroy the pad */
1493       gst_object_ref (pad);
1494       pad-&gt;priv-&gt;idle_running++;
1495 
1496       /* the pad is idle now, we can signal the idle callback now */
1497       GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
1498           &quot;pad is idle, trigger idle callback&quot;);
1499       GST_OBJECT_UNLOCK (pad);
1500 
1501       ret = callback (pad, &amp;info, user_data);
1502 
1503       GST_OBJECT_LOCK (pad);
1504       switch (ret) {
1505         case GST_PAD_PROBE_REMOVE:
1506           /* remove the probe */
1507           GST_DEBUG_OBJECT (pad, &quot;asked to remove hook&quot;);
1508           cleanup_hook (pad, hook);
1509           res = 0;
1510           break;
1511         case GST_PAD_PROBE_DROP:
1512           GST_DEBUG_OBJECT (pad, &quot;asked to drop item&quot;);
1513           break;
1514         case GST_PAD_PROBE_PASS:
1515           GST_DEBUG_OBJECT (pad, &quot;asked to pass item&quot;);
1516           break;
1517         case GST_PAD_PROBE_OK:
1518           GST_DEBUG_OBJECT (pad, &quot;probe returned OK&quot;);
1519           break;
1520         case GST_PAD_PROBE_HANDLED:
1521           GST_DEBUG_OBJECT (pad, &quot;probe handled the data&quot;);
1522           break;
1523         default:
1524           GST_DEBUG_OBJECT (pad, &quot;probe returned %d&quot;, ret);
1525           break;
1526       }
1527       pad-&gt;priv-&gt;idle_running--;
1528       if (pad-&gt;priv-&gt;idle_running == 0) {
1529         GST_PAD_BLOCK_BROADCAST (pad);
1530       }
1531       GST_OBJECT_UNLOCK (pad);
1532 
1533       gst_object_unref (pad);
1534     }
1535   } else {
1536     GST_OBJECT_UNLOCK (pad);
1537   }
1538   return res;
1539 }
1540 
1541 /**
1542  * gst_pad_remove_probe:
1543  * @pad: the #GstPad with the probe
1544  * @id: the probe id to remove
1545  *
1546  * Remove the probe with @id from @pad.
1547  *
1548  * MT safe.
1549  */
1550 void
1551 gst_pad_remove_probe (GstPad * pad, gulong id)
1552 {
1553   GHook *hook;
1554 
1555   g_return_if_fail (GST_IS_PAD (pad));
1556 
1557   GST_OBJECT_LOCK (pad);
1558 
1559   hook = g_hook_get (&amp;pad-&gt;probes, id);
1560   if (hook == NULL)
1561     goto not_found;
1562 
1563   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;removing hook %ld&quot;,
1564       hook-&gt;hook_id);
1565   cleanup_hook (pad, hook);
1566   GST_OBJECT_UNLOCK (pad);
1567 
1568   return;
1569 
1570 not_found:
1571   {
1572     GST_OBJECT_UNLOCK (pad);
1573     g_warning (&quot;%s: pad `%p&#39; has no probe with id `%lu&#39;&quot;, G_STRLOC, pad, id);
1574     return;
1575   }
1576 }
1577 
1578 /**
1579  * gst_pad_is_blocked:
1580  * @pad: the #GstPad to query
1581  *
1582  * Checks if the pad is blocked or not. This function returns the
1583  * last requested state of the pad. It is not certain that the pad
1584  * is actually blocking at this point (see gst_pad_is_blocking()).
1585  *
1586  * Returns: %TRUE if the pad is blocked.
1587  *
1588  * MT safe.
1589  */
1590 gboolean
1591 gst_pad_is_blocked (GstPad * pad)
1592 {
1593   gboolean result = FALSE;
1594 
1595   g_return_val_if_fail (GST_IS_PAD (pad), result);
1596 
1597   GST_OBJECT_LOCK (pad);
1598   result = GST_OBJECT_FLAG_IS_SET (pad, GST_PAD_FLAG_BLOCKED);
1599   GST_OBJECT_UNLOCK (pad);
1600 
1601   return result;
1602 }
1603 
1604 /**
1605  * gst_pad_is_blocking:
1606  * @pad: the #GstPad to query
1607  *
1608  * Checks if the pad is blocking or not. This is a guaranteed state
1609  * of whether the pad is actually blocking on a #GstBuffer or a #GstEvent.
1610  *
1611  * Returns: %TRUE if the pad is blocking.
1612  *
1613  * MT safe.
1614  */
1615 gboolean
1616 gst_pad_is_blocking (GstPad * pad)
1617 {
1618   gboolean result = FALSE;
1619 
1620   g_return_val_if_fail (GST_IS_PAD (pad), result);
1621 
1622   GST_OBJECT_LOCK (pad);
1623   /* the blocking flag is only valid if the pad is not flushing */
1624   result = GST_PAD_IS_BLOCKING (pad) &amp;&amp; !GST_PAD_IS_FLUSHING (pad);
1625   GST_OBJECT_UNLOCK (pad);
1626 
1627   return result;
1628 }
1629 
1630 /**
1631  * gst_pad_needs_reconfigure:
1632  * @pad: the #GstPad to check
1633  *
1634  * Check the #GST_PAD_FLAG_NEED_RECONFIGURE flag on @pad and return %TRUE
1635  * if the flag was set.
1636  *
1637  * Returns: %TRUE is the GST_PAD_FLAG_NEED_RECONFIGURE flag is set on @pad.
1638  */
1639 gboolean
1640 gst_pad_needs_reconfigure (GstPad * pad)
1641 {
1642   gboolean reconfigure;
1643 
1644   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
1645 
1646   GST_OBJECT_LOCK (pad);
1647   reconfigure = GST_PAD_NEEDS_RECONFIGURE (pad);
1648   GST_DEBUG_OBJECT (pad, &quot;peeking RECONFIGURE flag %d&quot;, reconfigure);
1649   GST_OBJECT_UNLOCK (pad);
1650 
1651   return reconfigure;
1652 }
1653 
1654 /**
1655  * gst_pad_check_reconfigure:
1656  * @pad: the #GstPad to check
1657  *
1658  * Check and clear the #GST_PAD_FLAG_NEED_RECONFIGURE flag on @pad and return %TRUE
1659  * if the flag was set.
1660  *
1661  * Returns: %TRUE is the GST_PAD_FLAG_NEED_RECONFIGURE flag was set on @pad.
1662  */
1663 gboolean
1664 gst_pad_check_reconfigure (GstPad * pad)
1665 {
1666   gboolean reconfigure;
1667 
1668   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
1669 
1670   GST_OBJECT_LOCK (pad);
1671   reconfigure = GST_PAD_NEEDS_RECONFIGURE (pad);
1672   if (reconfigure) {
1673     GST_DEBUG_OBJECT (pad, &quot;remove RECONFIGURE flag&quot;);
1674     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);
1675   }
1676   GST_OBJECT_UNLOCK (pad);
1677 
1678   return reconfigure;
1679 }
1680 
1681 /**
1682  * gst_pad_mark_reconfigure:
1683  * @pad: the #GstPad to mark
1684  *
1685  * Mark a pad for needing reconfiguration. The next call to
1686  * gst_pad_check_reconfigure() will return %TRUE after this call.
1687  */
1688 void
1689 gst_pad_mark_reconfigure (GstPad * pad)
1690 {
1691   g_return_if_fail (GST_IS_PAD (pad));
1692 
1693   GST_OBJECT_LOCK (pad);
1694   GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);
1695   GST_OBJECT_UNLOCK (pad);
1696 }
1697 
1698 /**
1699  * gst_pad_set_activate_function:
1700  * @p: a #GstPad.
1701  * @f: the #GstPadActivateFunction to set.
1702  *
1703  * Calls gst_pad_set_activate_function_full() with %NULL for the user_data and
1704  * notify.
1705  */
1706 /**
1707  * gst_pad_set_activate_function_full:
1708  * @pad: a #GstPad.
1709  * @activate: the #GstPadActivateFunction to set.
1710  * @user_data: user_data passed to @notify
1711  * @notify: notify called when @activate will not be used anymore.
1712  *
1713  * Sets the given activate function for @pad. The activate function will
1714  * dispatch to gst_pad_activate_mode() to perform the actual activation.
1715  * Only makes sense to set on sink pads.
1716  *
1717  * Call this function if your sink pad can start a pull-based task.
1718  */
1719 void
1720 gst_pad_set_activate_function_full (GstPad * pad,
1721     GstPadActivateFunction activate, gpointer user_data, GDestroyNotify notify)
1722 {
1723   g_return_if_fail (GST_IS_PAD (pad));
1724 
1725   if (pad-&gt;activatenotify)
1726     pad-&gt;activatenotify (pad-&gt;activatedata);
1727   GST_PAD_ACTIVATEFUNC (pad) = activate;
1728   pad-&gt;activatedata = user_data;
1729   pad-&gt;activatenotify = notify;
1730 
1731   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;activatefunc set to %s&quot;,
1732       GST_DEBUG_FUNCPTR_NAME (activate));
1733 }
1734 
1735 /**
1736  * gst_pad_set_activatemode_function:
1737  * @p: a #GstPad.
1738  * @f: the #GstPadActivateModeFunction to set.
1739  *
1740  * Calls gst_pad_set_activatemode_function_full() with %NULL for the user_data and
1741  * notify.
1742  */
1743 /**
1744  * gst_pad_set_activatemode_function_full:
1745  * @pad: a #GstPad.
1746  * @activatemode: the #GstPadActivateModeFunction to set.
1747  * @user_data: user_data passed to @notify
1748  * @notify: notify called when @activatemode will not be used anymore.
1749  *
1750  * Sets the given activate_mode function for the pad. An activate_mode function
1751  * prepares the element for data passing.
1752  */
1753 void
1754 gst_pad_set_activatemode_function_full (GstPad * pad,
1755     GstPadActivateModeFunction activatemode, gpointer user_data,
1756     GDestroyNotify notify)
1757 {
1758   g_return_if_fail (GST_IS_PAD (pad));
1759 
1760   if (pad-&gt;activatemodenotify)
1761     pad-&gt;activatemodenotify (pad-&gt;activatemodedata);
1762   GST_PAD_ACTIVATEMODEFUNC (pad) = activatemode;
1763   pad-&gt;activatemodedata = user_data;
1764   pad-&gt;activatemodenotify = notify;
1765 
1766   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;activatemodefunc set to %s&quot;,
1767       GST_DEBUG_FUNCPTR_NAME (activatemode));
1768 }
1769 
1770 /**
1771  * gst_pad_set_chain_function:
1772  * @p: a sink #GstPad.
1773  * @f: the #GstPadChainFunction to set.
1774  *
1775  * Calls gst_pad_set_chain_function_full() with %NULL for the user_data and
1776  * notify.
1777  */
1778 /**
1779  * gst_pad_set_chain_function_full:
1780  * @pad: a sink #GstPad.
1781  * @chain: the #GstPadChainFunction to set.
1782  * @user_data: user_data passed to @notify
1783  * @notify: notify called when @chain will not be used anymore.
1784  *
1785  * Sets the given chain function for the pad. The chain function is called to
1786  * process a #GstBuffer input buffer. see #GstPadChainFunction for more details.
1787  */
1788 void
1789 gst_pad_set_chain_function_full (GstPad * pad, GstPadChainFunction chain,
1790     gpointer user_data, GDestroyNotify notify)
1791 {
1792   g_return_if_fail (GST_IS_PAD (pad));
1793   g_return_if_fail (GST_PAD_IS_SINK (pad));
1794 
1795   if (pad-&gt;chainnotify)
1796     pad-&gt;chainnotify (pad-&gt;chaindata);
1797   GST_PAD_CHAINFUNC (pad) = chain;
1798   pad-&gt;chaindata = user_data;
1799   pad-&gt;chainnotify = notify;
1800 
1801   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;chainfunc set to %s&quot;,
1802       GST_DEBUG_FUNCPTR_NAME (chain));
1803 }
1804 
1805 /**
1806  * gst_pad_set_chain_list_function:
1807  * @p: a sink #GstPad.
1808  * @f: the #GstPadChainListFunction to set.
1809  *
1810  * Calls gst_pad_set_chain_list_function_full() with %NULL for the user_data and
1811  * notify.
1812  */
1813 /**
1814  * gst_pad_set_chain_list_function_full:
1815  * @pad: a sink #GstPad.
1816  * @chainlist: the #GstPadChainListFunction to set.
1817  * @user_data: user_data passed to @notify
1818  * @notify: notify called when @chainlist will not be used anymore.
1819  *
1820  * Sets the given chain list function for the pad. The chainlist function is
1821  * called to process a #GstBufferList input buffer list. See
1822  * #GstPadChainListFunction for more details.
1823  */
1824 void
1825 gst_pad_set_chain_list_function_full (GstPad * pad,
1826     GstPadChainListFunction chainlist, gpointer user_data,
1827     GDestroyNotify notify)
1828 {
1829   g_return_if_fail (GST_IS_PAD (pad));
1830   g_return_if_fail (GST_PAD_IS_SINK (pad));
1831 
1832   if (pad-&gt;chainlistnotify)
1833     pad-&gt;chainlistnotify (pad-&gt;chainlistdata);
1834   GST_PAD_CHAINLISTFUNC (pad) = chainlist;
1835   pad-&gt;chainlistdata = user_data;
1836   pad-&gt;chainlistnotify = notify;
1837 
1838   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;chainlistfunc set to %s&quot;,
1839       GST_DEBUG_FUNCPTR_NAME (chainlist));
1840 }
1841 
1842 /**
1843  * gst_pad_set_getrange_function:
1844  * @p: a source #GstPad.
1845  * @f: the #GstPadGetRangeFunction to set.
1846  *
1847  * Calls gst_pad_set_getrange_function_full() with %NULL for the user_data and
1848  * notify.
1849  */
1850 /**
1851  * gst_pad_set_getrange_function_full:
1852  * @pad: a source #GstPad.
1853  * @get: the #GstPadGetRangeFunction to set.
1854  * @user_data: user_data passed to @notify
1855  * @notify: notify called when @get will not be used anymore.
1856  *
1857  * Sets the given getrange function for the pad. The getrange function is
1858  * called to produce a new #GstBuffer to start the processing pipeline. see
1859  * #GstPadGetRangeFunction for a description of the getrange function.
1860  */
1861 void
1862 gst_pad_set_getrange_function_full (GstPad * pad, GstPadGetRangeFunction get,
1863     gpointer user_data, GDestroyNotify notify)
1864 {
1865   g_return_if_fail (GST_IS_PAD (pad));
1866   g_return_if_fail (GST_PAD_IS_SRC (pad));
1867 
1868   if (pad-&gt;getrangenotify)
1869     pad-&gt;getrangenotify (pad-&gt;getrangedata);
1870   GST_PAD_GETRANGEFUNC (pad) = get;
1871   pad-&gt;getrangedata = user_data;
1872   pad-&gt;getrangenotify = notify;
1873 
1874   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;getrangefunc set to %s&quot;,
1875       GST_DEBUG_FUNCPTR_NAME (get));
1876 }
1877 
1878 /**
1879  * gst_pad_set_event_function:
1880  * @p: a #GstPad of either direction.
1881  * @f: the #GstPadEventFunction to set.
1882  *
1883  * Calls gst_pad_set_event_function_full() with %NULL for the user_data and
1884  * notify.
1885  */
1886 /**
1887  * gst_pad_set_event_function_full:
1888  * @pad: a #GstPad of either direction.
1889  * @event: the #GstPadEventFunction to set.
1890  * @user_data: user_data passed to @notify
1891  * @notify: notify called when @event will not be used anymore.
1892  *
1893  * Sets the given event handler for the pad.
1894  */
1895 void
1896 gst_pad_set_event_function_full (GstPad * pad, GstPadEventFunction event,
1897     gpointer user_data, GDestroyNotify notify)
1898 {
1899   g_return_if_fail (GST_IS_PAD (pad));
1900 
1901   if (pad-&gt;eventnotify)
1902     pad-&gt;eventnotify (pad-&gt;eventdata);
1903   GST_PAD_EVENTFUNC (pad) = event;
1904   pad-&gt;eventdata = user_data;
1905   pad-&gt;eventnotify = notify;
1906 
1907   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;eventfunc for set to %s&quot;,
1908       GST_DEBUG_FUNCPTR_NAME (event));
1909 }
1910 
1911 static gboolean
1912 event_wrap (GstPad * pad, GstObject * object, GstEvent * event)
1913 {
1914   GstFlowReturn ret;
1915 
1916   ret = GST_PAD_EVENTFULLFUNC (pad) (pad, object, event);
1917   if (ret == GST_FLOW_OK)
1918     return TRUE;
1919   return FALSE;
1920 }
1921 
1922 /**
1923  * gst_pad_set_event_full_function:
1924  * @p: a #GstPad of either direction.
1925  * @f: the #GstPadEventFullFunction to set.
1926  *
1927  * Calls gst_pad_set_event_full_function_full() with %NULL for the user_data and
1928  * notify.
1929  */
1930 /**
1931  * gst_pad_set_event_full_function_full:
1932  * @pad: a #GstPad of either direction.
1933  * @event: the #GstPadEventFullFunction to set.
1934  * @user_data: user_data passed to @notify
1935  * @notify: notify called when @event will not be used anymore.
1936  *
1937  * Sets the given event handler for the pad.
1938  *
1939  * Since: 1.8
1940  */
1941 void
1942 gst_pad_set_event_full_function_full (GstPad * pad,
1943     GstPadEventFullFunction event, gpointer user_data, GDestroyNotify notify)
1944 {
1945   g_return_if_fail (GST_IS_PAD (pad));
1946 
1947   if (pad-&gt;eventnotify)
1948     pad-&gt;eventnotify (pad-&gt;eventdata);
1949   GST_PAD_EVENTFULLFUNC (pad) = event;
1950   GST_PAD_EVENTFUNC (pad) = event_wrap;
1951   pad-&gt;eventdata = user_data;
1952   pad-&gt;eventnotify = notify;
1953 
1954   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;eventfullfunc for set to %s&quot;,
1955       GST_DEBUG_FUNCPTR_NAME (event));
1956 }
1957 
1958 /**
1959  * gst_pad_set_query_function:
1960  * @p: a #GstPad of either direction.
1961  * @f: the #GstPadQueryFunction to set.
1962  *
1963  * Calls gst_pad_set_query_function_full() with %NULL for the user_data and
1964  * notify.
1965  */
1966 /**
1967  * gst_pad_set_query_function_full:
1968  * @pad: a #GstPad of either direction.
1969  * @query: the #GstPadQueryFunction to set.
1970  * @user_data: user_data passed to @notify
1971  * @notify: notify called when @query will not be used anymore.
1972  *
1973  * Set the given query function for the pad.
1974  */
1975 void
1976 gst_pad_set_query_function_full (GstPad * pad, GstPadQueryFunction query,
1977     gpointer user_data, GDestroyNotify notify)
1978 {
1979   g_return_if_fail (GST_IS_PAD (pad));
1980 
1981   if (pad-&gt;querynotify)
1982     pad-&gt;querynotify (pad-&gt;querydata);
1983   GST_PAD_QUERYFUNC (pad) = query;
1984   pad-&gt;querydata = user_data;
1985   pad-&gt;querynotify = notify;
1986 
1987   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;queryfunc set to %s&quot;,
1988       GST_DEBUG_FUNCPTR_NAME (query));
1989 }
1990 
1991 /**
1992  * gst_pad_set_iterate_internal_links_function:
1993  * @p: a #GstPad of either direction.
1994  * @f: the #GstPadIterIntLinkFunction to set.
1995  *
1996  * Calls gst_pad_set_iterate_internal_links_function_full() with %NULL
1997  * for the user_data and notify.
1998  */
1999 /**
2000  * gst_pad_set_iterate_internal_links_function_full:
2001  * @pad: a #GstPad of either direction.
2002  * @iterintlink: the #GstPadIterIntLinkFunction to set.
2003  * @user_data: user_data passed to @notify
2004  * @notify: notify called when @iterintlink will not be used anymore.
2005  *
2006  * Sets the given internal link iterator function for the pad.
2007  */
2008 void
2009 gst_pad_set_iterate_internal_links_function_full (GstPad * pad,
2010     GstPadIterIntLinkFunction iterintlink, gpointer user_data,
2011     GDestroyNotify notify)
2012 {
2013   g_return_if_fail (GST_IS_PAD (pad));
2014 
2015   if (pad-&gt;iterintlinknotify)
2016     pad-&gt;iterintlinknotify (pad-&gt;iterintlinkdata);
2017   GST_PAD_ITERINTLINKFUNC (pad) = iterintlink;
2018   pad-&gt;iterintlinkdata = user_data;
2019   pad-&gt;iterintlinknotify = notify;
2020 
2021   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;internal link iterator set to %s&quot;,
2022       GST_DEBUG_FUNCPTR_NAME (iterintlink));
2023 }
2024 
2025 /**
2026  * gst_pad_set_link_function:
2027  * @p: a #GstPad.
2028  * @f: the #GstPadLinkFunction to set.
2029  *
2030  * Calls gst_pad_set_link_function_full() with %NULL
2031  * for the user_data and notify.
2032  */
2033 /**
2034  * gst_pad_set_link_function_full:
2035  * @pad: a #GstPad.
2036  * @link: the #GstPadLinkFunction to set.
2037  * @user_data: user_data passed to @notify
2038  * @notify: notify called when @link will not be used anymore.
2039  *
2040  * Sets the given link function for the pad. It will be called when
2041  * the pad is linked with another pad.
2042  *
2043  * The return value #GST_PAD_LINK_OK should be used when the connection can be
2044  * made.
2045  *
2046  * The return value #GST_PAD_LINK_REFUSED should be used when the connection
2047  * cannot be made for some reason.
2048  *
2049  * If @link is installed on a source pad, it should call the #GstPadLinkFunction
2050  * of the peer sink pad, if present.
2051  */
2052 void
2053 gst_pad_set_link_function_full (GstPad * pad, GstPadLinkFunction link,
2054     gpointer user_data, GDestroyNotify notify)
2055 {
2056   g_return_if_fail (GST_IS_PAD (pad));
2057 
2058   if (pad-&gt;linknotify)
2059     pad-&gt;linknotify (pad-&gt;linkdata);
2060   GST_PAD_LINKFUNC (pad) = link;
2061   pad-&gt;linkdata = user_data;
2062   pad-&gt;linknotify = notify;
2063 
2064   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;linkfunc set to %s&quot;,
2065       GST_DEBUG_FUNCPTR_NAME (link));
2066 }
2067 
2068 /**
2069  * gst_pad_set_unlink_function:
2070  * @p: a #GstPad.
2071  * @f: the #GstPadUnlinkFunction to set.
2072  *
2073  * Calls gst_pad_set_unlink_function_full() with %NULL
2074  * for the user_data and notify.
2075  */
2076 /**
2077  * gst_pad_set_unlink_function_full:
2078  * @pad: a #GstPad.
2079  * @unlink: the #GstPadUnlinkFunction to set.
2080  * @user_data: user_data passed to @notify
2081  * @notify: notify called when @unlink will not be used anymore.
2082  *
2083  * Sets the given unlink function for the pad. It will be called
2084  * when the pad is unlinked.
2085  *
2086  * Note that the pad&#39;s lock is already held when the unlink
2087  * function is called, so most pad functions cannot be called
2088  * from within the callback.
2089  */
2090 void
2091 gst_pad_set_unlink_function_full (GstPad * pad, GstPadUnlinkFunction unlink,
2092     gpointer user_data, GDestroyNotify notify)
2093 {
2094   g_return_if_fail (GST_IS_PAD (pad));
2095 
2096   if (pad-&gt;unlinknotify)
2097     pad-&gt;unlinknotify (pad-&gt;unlinkdata);
2098   GST_PAD_UNLINKFUNC (pad) = unlink;
2099   pad-&gt;unlinkdata = user_data;
2100   pad-&gt;unlinknotify = notify;
2101 
2102   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;unlinkfunc set to %s&quot;,
2103       GST_DEBUG_FUNCPTR_NAME (unlink));
2104 }
2105 
2106 /**
2107  * gst_pad_unlink:
2108  * @srcpad: the source #GstPad to unlink.
2109  * @sinkpad: the sink #GstPad to unlink.
2110  *
2111  * Unlinks the source pad from the sink pad. Will emit the #GstPad::unlinked
2112  * signal on both pads.
2113  *
2114  * Returns: %TRUE if the pads were unlinked. This function returns %FALSE if
2115  * the pads were not linked together.
2116  *
2117  * MT safe.
2118  */
2119 gboolean
2120 gst_pad_unlink (GstPad * srcpad, GstPad * sinkpad)
2121 {
2122   gboolean result = FALSE;
2123   GstElement *parent = NULL;
2124 
2125   g_return_val_if_fail (GST_IS_PAD (srcpad), FALSE);
2126   g_return_val_if_fail (GST_PAD_IS_SRC (srcpad), FALSE);
2127   g_return_val_if_fail (GST_IS_PAD (sinkpad), FALSE);
2128   g_return_val_if_fail (GST_PAD_IS_SINK (sinkpad), FALSE);
2129 
2130   GST_TRACER_PAD_UNLINK_PRE (srcpad, sinkpad);
2131 
2132   GST_CAT_INFO (GST_CAT_ELEMENT_PADS, &quot;unlinking %s:%s(%p) and %s:%s(%p)&quot;,
2133       GST_DEBUG_PAD_NAME (srcpad), srcpad,
2134       GST_DEBUG_PAD_NAME (sinkpad), sinkpad);
2135 
2136   /* We need to notify the parent before taking any pad locks as the bin in
2137    * question might be waiting for a lock on the pad while holding its lock
2138    * that our message will try to take. */
2139   if ((parent = GST_ELEMENT_CAST (gst_pad_get_parent (srcpad)))) {
2140     if (GST_IS_ELEMENT (parent)) {
2141       gst_element_post_message (parent,
2142           gst_message_new_structure_change (GST_OBJECT_CAST (sinkpad),
2143               GST_STRUCTURE_CHANGE_TYPE_PAD_UNLINK, parent, TRUE));
2144     } else {
2145       gst_object_unref (parent);
2146       parent = NULL;
2147     }
2148   }
2149 
2150   GST_OBJECT_LOCK (srcpad);
2151   GST_OBJECT_LOCK (sinkpad);
2152 
2153   if (G_UNLIKELY (GST_PAD_PEER (srcpad) != sinkpad))
2154     goto not_linked_together;
2155 
2156   if (GST_PAD_UNLINKFUNC (srcpad)) {
2157     GstObject *tmpparent;
2158 
2159     ACQUIRE_PARENT (srcpad, tmpparent, no_src_parent);
2160 
2161     GST_PAD_UNLINKFUNC (srcpad) (srcpad, tmpparent);
2162     RELEASE_PARENT (tmpparent);
2163   }
2164 no_src_parent:
2165   if (GST_PAD_UNLINKFUNC (sinkpad)) {
2166     GstObject *tmpparent;
2167 
2168     ACQUIRE_PARENT (sinkpad, tmpparent, no_sink_parent);
2169 
2170     GST_PAD_UNLINKFUNC (sinkpad) (sinkpad, tmpparent);
2171     RELEASE_PARENT (tmpparent);
2172   }
2173 no_sink_parent:
2174 
2175   /* first clear peers */
2176   GST_PAD_PEER (srcpad) = NULL;
2177   GST_PAD_PEER (sinkpad) = NULL;
2178 
2179   GST_OBJECT_UNLOCK (sinkpad);
2180   GST_OBJECT_UNLOCK (srcpad);
2181 
2182   /* fire off a signal to each of the pads telling them
2183    * that they&#39;ve been unlinked */
2184   g_signal_emit (srcpad, gst_pad_signals[PAD_UNLINKED], 0, sinkpad);
2185   g_signal_emit (sinkpad, gst_pad_signals[PAD_UNLINKED], 0, srcpad);
2186 
2187   GST_CAT_INFO (GST_CAT_ELEMENT_PADS, &quot;unlinked %s:%s and %s:%s&quot;,
2188       GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad));
2189 
2190   result = TRUE;
2191 
2192 done:
2193   if (parent != NULL) {
2194     gst_element_post_message (parent,
2195         gst_message_new_structure_change (GST_OBJECT_CAST (sinkpad),
2196             GST_STRUCTURE_CHANGE_TYPE_PAD_UNLINK, parent, FALSE));
2197     gst_object_unref (parent);
2198   }
2199   GST_TRACER_PAD_UNLINK_POST (srcpad, sinkpad, result);
2200   return result;
2201 
2202   /* ERRORS */
2203 not_linked_together:
2204   {
2205     /* we do not emit a warning in this case because unlinking cannot
2206      * be made MT safe.*/
2207     GST_OBJECT_UNLOCK (sinkpad);
2208     GST_OBJECT_UNLOCK (srcpad);
2209     goto done;
2210   }
2211 }
2212 
2213 /**
2214  * gst_pad_is_linked:
2215  * @pad: pad to check
2216  *
2217  * Checks if a @pad is linked to another pad or not.
2218  *
2219  * Returns: %TRUE if the pad is linked, %FALSE otherwise.
2220  *
2221  * MT safe.
2222  */
2223 gboolean
2224 gst_pad_is_linked (GstPad * pad)
2225 {
2226   gboolean result;
2227 
2228   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
2229 
2230   GST_OBJECT_LOCK (pad);
2231   result = (GST_PAD_PEER (pad) != NULL);
2232   GST_OBJECT_UNLOCK (pad);
2233 
2234   return result;
2235 }
2236 
2237 /* get the caps from both pads and see if the intersection
2238  * is not empty.
2239  *
2240  * This function should be called with the pad LOCK on both
2241  * pads
2242  */
2243 static gboolean
2244 gst_pad_link_check_compatible_unlocked (GstPad * src, GstPad * sink,
2245     GstPadLinkCheck flags)
2246 {
2247   GstCaps *srccaps = NULL;
2248   GstCaps *sinkcaps = NULL;
2249   gboolean compatible = FALSE;
2250 
2251   if (!(flags &amp; (GST_PAD_LINK_CHECK_CAPS | GST_PAD_LINK_CHECK_TEMPLATE_CAPS)))
2252     return TRUE;
2253 
2254   /* Doing the expensive caps checking takes priority over only checking the template caps */
2255   if (flags &amp; GST_PAD_LINK_CHECK_CAPS) {
2256     GST_OBJECT_UNLOCK (sink);
2257     GST_OBJECT_UNLOCK (src);
2258 
2259     srccaps = gst_pad_query_caps (src, NULL);
2260     sinkcaps = gst_pad_query_caps (sink, NULL);
2261 
2262     GST_OBJECT_LOCK (src);
2263     GST_OBJECT_LOCK (sink);
2264   } else {
2265     /* If one of the two pads doesn&#39;t have a template, consider the intersection
2266      * as valid.*/
2267     if (G_UNLIKELY ((GST_PAD_PAD_TEMPLATE (src) == NULL)
2268             || (GST_PAD_PAD_TEMPLATE (sink) == NULL))) {
2269       compatible = TRUE;
2270       goto done;
2271     }
2272     srccaps = gst_caps_ref (GST_PAD_TEMPLATE_CAPS (GST_PAD_PAD_TEMPLATE (src)));
2273     sinkcaps =
2274         gst_caps_ref (GST_PAD_TEMPLATE_CAPS (GST_PAD_PAD_TEMPLATE (sink)));
2275   }
2276 
2277   GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, src, &quot;src caps %&quot; GST_PTR_FORMAT,
2278       srccaps);
2279   GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, sink, &quot;sink caps %&quot; GST_PTR_FORMAT,
2280       sinkcaps);
2281 
2282   /* if we have caps on both pads we can check the intersection. If one
2283    * of the caps is %NULL, we return %TRUE. */
2284   if (G_UNLIKELY (srccaps == NULL || sinkcaps == NULL)) {
2285     if (srccaps)
2286       gst_caps_unref (srccaps);
2287     if (sinkcaps)
2288       gst_caps_unref (sinkcaps);
2289     goto done;
2290   }
2291 
2292   compatible = gst_caps_can_intersect (srccaps, sinkcaps);
2293   gst_caps_unref (srccaps);
2294   gst_caps_unref (sinkcaps);
2295 
2296 done:
2297   GST_CAT_DEBUG (GST_CAT_CAPS, &quot;caps are %scompatible&quot;,
2298       (compatible ? &quot;&quot; : &quot;not &quot;));
2299 
2300   return compatible;
2301 }
2302 
2303 /* check if the grandparents of both pads are the same.
2304  * This check is required so that we don&#39;t try to link
2305  * pads from elements in different bins without ghostpads.
2306  *
2307  * The LOCK should be held on both pads
2308  */
2309 static gboolean
2310 gst_pad_link_check_hierarchy (GstPad * src, GstPad * sink)
2311 {
2312   GstObject *psrc, *psink;
2313 
2314   psrc = GST_OBJECT_PARENT (src);
2315   psink = GST_OBJECT_PARENT (sink);
2316 
2317   /* if one of the pads has no parent, we allow the link */
2318   if (G_UNLIKELY (psrc == NULL || psink == NULL))
2319     goto no_parent;
2320 
2321   /* only care about parents that are elements */
2322   if (G_UNLIKELY (!GST_IS_ELEMENT (psrc) || !GST_IS_ELEMENT (psink)))
2323     goto no_element_parent;
2324 
2325   /* if the parents are the same, we have a loop */
2326   if (G_UNLIKELY (psrc == psink))
2327     goto same_parents;
2328 
2329   /* if they both have a parent, we check the grandparents. We can not lock
2330    * the parent because we hold on the child (pad) and the locking order is
2331    * parent &gt;&gt; child. */
2332   psrc = GST_OBJECT_PARENT (psrc);
2333   psink = GST_OBJECT_PARENT (psink);
2334 
2335   /* if they have grandparents but they are not the same */
2336   if (G_UNLIKELY (psrc != psink))
2337     goto wrong_grandparents;
2338 
2339   return TRUE;
2340 
2341   /* ERRORS */
2342 no_parent:
2343   {
2344     GST_CAT_DEBUG (GST_CAT_CAPS,
2345         &quot;one of the pads has no parent %&quot; GST_PTR_FORMAT &quot; and %&quot;
2346         GST_PTR_FORMAT, psrc, psink);
2347     return TRUE;
2348   }
2349 no_element_parent:
2350   {
2351     GST_CAT_DEBUG (GST_CAT_CAPS,
2352         &quot;one of the pads has no element parent %&quot; GST_PTR_FORMAT &quot; and %&quot;
2353         GST_PTR_FORMAT, psrc, psink);
2354     return TRUE;
2355   }
2356 same_parents:
2357   {
2358     GST_CAT_DEBUG (GST_CAT_CAPS, &quot;pads have same parent %&quot; GST_PTR_FORMAT,
2359         psrc);
2360     return FALSE;
2361   }
2362 wrong_grandparents:
2363   {
2364     GST_CAT_DEBUG (GST_CAT_CAPS,
2365         &quot;pads have different grandparents %&quot; GST_PTR_FORMAT &quot; and %&quot;
2366         GST_PTR_FORMAT, psrc, psink);
2367     return FALSE;
2368   }
2369 }
2370 
2371 /* FIXME leftover from an attempt at refactoring... */
2372 /* call with the two pads unlocked, when this function returns GST_PAD_LINK_OK,
2373  * the two pads will be locked in the srcpad, sinkpad order. */
2374 static GstPadLinkReturn
2375 gst_pad_link_prepare (GstPad * srcpad, GstPad * sinkpad, GstPadLinkCheck flags)
2376 {
2377   GST_CAT_INFO (GST_CAT_PADS, &quot;trying to link %s:%s and %s:%s&quot;,
2378       GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad));
2379 
2380   GST_OBJECT_LOCK (srcpad);
2381 
2382   if (G_UNLIKELY (GST_PAD_PEER (srcpad) != NULL))
2383     goto src_was_linked;
2384 
2385   GST_OBJECT_LOCK (sinkpad);
2386 
2387   if (G_UNLIKELY (GST_PAD_PEER (sinkpad) != NULL))
2388     goto sink_was_linked;
2389 
2390   /* check hierarchy, pads can only be linked if the grandparents
2391    * are the same. */
2392   if ((flags &amp; GST_PAD_LINK_CHECK_HIERARCHY)
2393       &amp;&amp; !gst_pad_link_check_hierarchy (srcpad, sinkpad))
2394     goto wrong_hierarchy;
2395 
2396   /* check pad caps for non-empty intersection */
2397   if (!gst_pad_link_check_compatible_unlocked (srcpad, sinkpad, flags))
2398     goto no_format;
2399 
2400   /* FIXME check pad scheduling for non-empty intersection */
2401 
2402   return GST_PAD_LINK_OK;
2403 
2404 src_was_linked:
2405   {
2406     GST_CAT_INFO (GST_CAT_PADS, &quot;src %s:%s was already linked to %s:%s&quot;,
2407         GST_DEBUG_PAD_NAME (srcpad),
2408         GST_DEBUG_PAD_NAME (GST_PAD_PEER (srcpad)));
2409     /* we do not emit a warning in this case because unlinking cannot
2410      * be made MT safe.*/
2411     GST_OBJECT_UNLOCK (srcpad);
2412     return GST_PAD_LINK_WAS_LINKED;
2413   }
2414 sink_was_linked:
2415   {
2416     GST_CAT_INFO (GST_CAT_PADS, &quot;sink %s:%s was already linked to %s:%s&quot;,
2417         GST_DEBUG_PAD_NAME (sinkpad),
2418         GST_DEBUG_PAD_NAME (GST_PAD_PEER (sinkpad)));
2419     /* we do not emit a warning in this case because unlinking cannot
2420      * be made MT safe.*/
2421     GST_OBJECT_UNLOCK (sinkpad);
2422     GST_OBJECT_UNLOCK (srcpad);
2423     return GST_PAD_LINK_WAS_LINKED;
2424   }
2425 wrong_hierarchy:
2426   {
2427     GST_CAT_INFO (GST_CAT_PADS, &quot;pads have wrong hierarchy&quot;);
2428     GST_OBJECT_UNLOCK (sinkpad);
2429     GST_OBJECT_UNLOCK (srcpad);
2430     return GST_PAD_LINK_WRONG_HIERARCHY;
2431   }
2432 no_format:
2433   {
2434     GST_CAT_INFO (GST_CAT_PADS, &quot;caps are incompatible&quot;);
2435     GST_OBJECT_UNLOCK (sinkpad);
2436     GST_OBJECT_UNLOCK (srcpad);
2437     return GST_PAD_LINK_NOFORMAT;
2438   }
2439 }
2440 
2441 /**
2442  * gst_pad_can_link:
2443  * @srcpad: the source #GstPad.
2444  * @sinkpad: the sink #GstPad.
2445  *
2446  * Checks if the source pad and the sink pad are compatible so they can be
2447  * linked.
2448  *
2449  * Returns: %TRUE if the pads can be linked.
2450  */
2451 gboolean
2452 gst_pad_can_link (GstPad * srcpad, GstPad * sinkpad)
2453 {
2454   GstPadLinkReturn result;
2455 
2456   /* generic checks */
2457   g_return_val_if_fail (GST_IS_PAD (srcpad), FALSE);
2458   g_return_val_if_fail (GST_IS_PAD (sinkpad), FALSE);
2459 
2460   GST_CAT_INFO (GST_CAT_PADS, &quot;check if %s:%s can link with %s:%s&quot;,
2461       GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad));
2462 
2463   /* gst_pad_link_prepare does everything for us, we only release the locks
2464    * on the pads that it gets us. If this function returns !OK the locks are not
2465    * taken anymore. */
2466   result = gst_pad_link_prepare (srcpad, sinkpad, GST_PAD_LINK_CHECK_DEFAULT);
2467   if (result != GST_PAD_LINK_OK)
2468     goto done;
2469 
2470   GST_OBJECT_UNLOCK (srcpad);
2471   GST_OBJECT_UNLOCK (sinkpad);
2472 
2473 done:
2474   return result == GST_PAD_LINK_OK;
2475 }
2476 
2477 /**
2478  * gst_pad_link_full:
2479  * @srcpad: the source #GstPad to link.
2480  * @sinkpad: the sink #GstPad to link.
2481  * @flags: the checks to validate when linking
2482  *
2483  * Links the source pad and the sink pad.
2484  *
2485  * This variant of #gst_pad_link provides a more granular control on the
2486  * checks being done when linking. While providing some considerable speedups
2487  * the caller of this method must be aware that wrong usage of those flags
2488  * can cause severe issues. Refer to the documentation of #GstPadLinkCheck
2489  * for more information.
2490  *
2491  * MT Safe.
2492  *
2493  * Returns: A result code indicating if the connection worked or
2494  *          what went wrong.
2495  */
2496 GstPadLinkReturn
2497 gst_pad_link_full (GstPad * srcpad, GstPad * sinkpad, GstPadLinkCheck flags)
2498 {
2499   GstPadLinkReturn result;
2500   GstElement *parent;
2501   GstPadLinkFunction srcfunc, sinkfunc;
2502 
2503   g_return_val_if_fail (GST_IS_PAD (srcpad), GST_PAD_LINK_REFUSED);
2504   g_return_val_if_fail (GST_PAD_IS_SRC (srcpad), GST_PAD_LINK_WRONG_DIRECTION);
2505   g_return_val_if_fail (GST_IS_PAD (sinkpad), GST_PAD_LINK_REFUSED);
2506   g_return_val_if_fail (GST_PAD_IS_SINK (sinkpad),
2507       GST_PAD_LINK_WRONG_DIRECTION);
2508 
2509   GST_TRACER_PAD_LINK_PRE (srcpad, sinkpad);
2510 
2511   /* Notify the parent early. See gst_pad_unlink for details. */
2512   if (G_LIKELY ((parent = GST_ELEMENT_CAST (gst_pad_get_parent (srcpad))))) {
2513     if (G_LIKELY (GST_IS_ELEMENT (parent))) {
2514       gst_element_post_message (parent,
2515           gst_message_new_structure_change (GST_OBJECT_CAST (sinkpad),
2516               GST_STRUCTURE_CHANGE_TYPE_PAD_LINK, parent, TRUE));
2517     } else {
2518       gst_object_unref (parent);
2519       parent = NULL;
2520     }
2521   }
2522 
2523   /* prepare will also lock the two pads */
2524   result = gst_pad_link_prepare (srcpad, sinkpad, flags);
2525 
2526   if (G_UNLIKELY (result != GST_PAD_LINK_OK)) {
2527     GST_CAT_INFO (GST_CAT_PADS, &quot;link between %s:%s and %s:%s failed: %s&quot;,
2528         GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad),
2529         gst_pad_link_get_name (result));
2530     goto done;
2531   }
2532 
2533   /* must set peers before calling the link function */
2534   GST_PAD_PEER (srcpad) = sinkpad;
2535   GST_PAD_PEER (sinkpad) = srcpad;
2536 
2537   /* check events, when something is different, mark pending */
2538   schedule_events (srcpad, sinkpad);
2539 
2540   /* get the link functions */
2541   srcfunc = GST_PAD_LINKFUNC (srcpad);
2542   sinkfunc = GST_PAD_LINKFUNC (sinkpad);
2543 
2544   if (G_UNLIKELY (srcfunc || sinkfunc)) {
2545     /* custom link functions, execute them */
2546     GST_OBJECT_UNLOCK (sinkpad);
2547     GST_OBJECT_UNLOCK (srcpad);
2548 
2549     if (srcfunc) {
2550       GstObject *tmpparent;
2551 
2552       ACQUIRE_PARENT (srcpad, tmpparent, no_parent);
2553       /* this one will call the peer link function */
2554       result = srcfunc (srcpad, tmpparent, sinkpad);
2555       RELEASE_PARENT (tmpparent);
2556     } else if (sinkfunc) {
2557       GstObject *tmpparent;
2558 
2559       ACQUIRE_PARENT (sinkpad, tmpparent, no_parent);
2560       /* if no source link function, we need to call the sink link
2561        * function ourselves. */
2562       result = sinkfunc (sinkpad, tmpparent, srcpad);
2563       RELEASE_PARENT (tmpparent);
2564     }
2565   no_parent:
2566 
2567     GST_OBJECT_LOCK (srcpad);
2568     GST_OBJECT_LOCK (sinkpad);
2569 
2570     /* we released the lock, check if the same pads are linked still */
2571     if (GST_PAD_PEER (srcpad) != sinkpad || GST_PAD_PEER (sinkpad) != srcpad)
2572       goto concurrent_link;
2573 
2574     if (G_UNLIKELY (result != GST_PAD_LINK_OK))
2575       goto link_failed;
2576   }
2577   GST_OBJECT_UNLOCK (sinkpad);
2578   GST_OBJECT_UNLOCK (srcpad);
2579 
2580   /* fire off a signal to each of the pads telling them
2581    * that they&#39;ve been linked */
2582   g_signal_emit (srcpad, gst_pad_signals[PAD_LINKED], 0, sinkpad);
2583   g_signal_emit (sinkpad, gst_pad_signals[PAD_LINKED], 0, srcpad);
2584 
2585   GST_CAT_INFO (GST_CAT_PADS, &quot;linked %s:%s and %s:%s, successful&quot;,
2586       GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad));
2587 
2588   if (!(flags &amp; GST_PAD_LINK_CHECK_NO_RECONFIGURE))
2589     gst_pad_send_event (srcpad, gst_event_new_reconfigure ());
2590 
2591 done:
2592   if (G_LIKELY (parent)) {
2593     gst_element_post_message (parent,
2594         gst_message_new_structure_change (GST_OBJECT_CAST (sinkpad),
2595             GST_STRUCTURE_CHANGE_TYPE_PAD_LINK, parent, FALSE));
2596     gst_object_unref (parent);
2597   }
2598 
2599   GST_TRACER_PAD_LINK_POST (srcpad, sinkpad, result);
2600   return result;
2601 
2602   /* ERRORS */
2603 concurrent_link:
2604   {
2605     GST_CAT_INFO (GST_CAT_PADS, &quot;concurrent link between %s:%s and %s:%s&quot;,
2606         GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad));
2607     GST_OBJECT_UNLOCK (sinkpad);
2608     GST_OBJECT_UNLOCK (srcpad);
2609 
2610     /* The other link operation succeeded first */
2611     result = GST_PAD_LINK_WAS_LINKED;
2612     goto done;
2613   }
2614 link_failed:
2615   {
2616     GST_CAT_INFO (GST_CAT_PADS, &quot;link between %s:%s and %s:%s failed: %s&quot;,
2617         GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad),
2618         gst_pad_link_get_name (result));
2619 
2620     GST_PAD_PEER (srcpad) = NULL;
2621     GST_PAD_PEER (sinkpad) = NULL;
2622 
2623     GST_OBJECT_UNLOCK (sinkpad);
2624     GST_OBJECT_UNLOCK (srcpad);
2625 
2626     goto done;
2627   }
2628 }
2629 
2630 /**
2631  * gst_pad_link:
2632  * @srcpad: the source #GstPad to link.
2633  * @sinkpad: the sink #GstPad to link.
2634  *
2635  * Links the source pad and the sink pad.
2636  *
2637  * Returns: A result code indicating if the connection worked or
2638  *          what went wrong.
2639  *
2640  * MT Safe.
2641  */
2642 GstPadLinkReturn
2643 gst_pad_link (GstPad * srcpad, GstPad * sinkpad)
2644 {
2645   return gst_pad_link_full (srcpad, sinkpad, GST_PAD_LINK_CHECK_DEFAULT);
2646 }
2647 
2648 static void
2649 gst_pad_set_pad_template (GstPad * pad, GstPadTemplate * templ)
2650 {
2651   GstPadTemplate **template_p;
2652 
2653   /* this function would need checks if it weren&#39;t static */
2654 
2655   GST_OBJECT_LOCK (pad);
2656   template_p = &amp;pad-&gt;padtemplate;
2657   gst_object_replace ((GstObject **) template_p, (GstObject *) templ);
2658   GST_OBJECT_UNLOCK (pad);
2659 
2660   if (templ)
2661     gst_pad_template_pad_created (templ, pad);
2662 }
2663 
2664 /**
2665  * gst_pad_get_pad_template:
2666  * @pad: a #GstPad.
2667  *
2668  * Gets the template for @pad.
2669  *
2670  * Returns: (transfer full) (nullable): the #GstPadTemplate from which
2671  *     this pad was instantiated, or %NULL if this pad has no
2672  *     template. Unref after usage.
2673  */
2674 GstPadTemplate *
2675 gst_pad_get_pad_template (GstPad * pad)
2676 {
2677   GstPadTemplate *templ;
2678 
2679   g_return_val_if_fail (GST_IS_PAD (pad), NULL);
2680 
2681   templ = GST_PAD_PAD_TEMPLATE (pad);
2682 
2683   return (templ ? gst_object_ref (templ) : NULL);
2684 }
2685 
2686 /**
2687  * gst_pad_has_current_caps:
2688  * @pad: a  #GstPad to check
2689  *
2690  * Check if @pad has caps set on it with a #GST_EVENT_CAPS event.
2691  *
2692  * Returns: %TRUE when @pad has caps associated with it.
2693  */
2694 gboolean
2695 gst_pad_has_current_caps (GstPad * pad)
2696 {
2697   gboolean result;
2698   GstCaps *caps;
2699 
2700   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
2701 
2702   GST_OBJECT_LOCK (pad);
2703   caps = get_pad_caps (pad);
2704   GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad,
2705       &quot;check current pad caps %&quot; GST_PTR_FORMAT, caps);
2706   result = (caps != NULL);
2707   GST_OBJECT_UNLOCK (pad);
2708 
2709   return result;
2710 }
2711 
2712 /**
2713  * gst_pad_get_current_caps:
2714  * @pad: a  #GstPad to get the current capabilities of.
2715  *
2716  * Gets the capabilities currently configured on @pad with the last
2717  * #GST_EVENT_CAPS event.
2718  *
2719  * Returns: (transfer full) (nullable): the current caps of the pad with
2720  * incremented ref-count or %NULL when pad has no caps. Unref after usage.
2721  */
2722 GstCaps *
2723 gst_pad_get_current_caps (GstPad * pad)
2724 {
2725   GstCaps *result;
2726 
2727   g_return_val_if_fail (GST_IS_PAD (pad), NULL);
2728 
2729   GST_OBJECT_LOCK (pad);
2730   if ((result = get_pad_caps (pad)))
2731     gst_caps_ref (result);
2732   GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad,
2733       &quot;get current pad caps %&quot; GST_PTR_FORMAT, result);
2734   GST_OBJECT_UNLOCK (pad);
2735 
2736   return result;
2737 }
2738 
2739 /**
2740  * gst_pad_get_pad_template_caps:
2741  * @pad: a #GstPad to get the template capabilities from.
2742  *
2743  * Gets the capabilities for @pad&#39;s template.
2744  *
2745  * Returns: (transfer full): the #GstCaps of this pad template.
2746  * Unref after usage.
2747  */
2748 GstCaps *
2749 gst_pad_get_pad_template_caps (GstPad * pad)
2750 {
2751   g_return_val_if_fail (GST_IS_PAD (pad), NULL);
2752 
2753   if (GST_PAD_PAD_TEMPLATE (pad))
2754     return gst_pad_template_get_caps (GST_PAD_PAD_TEMPLATE (pad));
2755 
2756   return gst_caps_ref (GST_CAPS_ANY);
2757 }
2758 
2759 /**
2760  * gst_pad_get_peer:
2761  * @pad: a #GstPad to get the peer of.
2762  *
2763  * Gets the peer of @pad. This function refs the peer pad so
2764  * you need to unref it after use.
2765  *
2766  * Returns: (transfer full) (nullable): the peer #GstPad. Unref after usage.
2767  *
2768  * MT safe.
2769  */
2770 GstPad *
2771 gst_pad_get_peer (GstPad * pad)
2772 {
2773   GstPad *result;
2774 
2775   g_return_val_if_fail (GST_IS_PAD (pad), NULL);
2776 
2777   GST_OBJECT_LOCK (pad);
2778   result = GST_PAD_PEER (pad);
2779   if (result)
2780     gst_object_ref (result);
2781   GST_OBJECT_UNLOCK (pad);
2782 
2783   return result;
2784 }
2785 
2786 /**
2787  * gst_pad_get_allowed_caps:
2788  * @pad: a #GstPad.
2789  *
2790  * Gets the capabilities of the allowed media types that can flow through
2791  * @pad and its peer.
2792  *
2793  * The allowed capabilities is calculated as the intersection of the results of
2794  * calling gst_pad_query_caps() on @pad and its peer. The caller owns a reference
2795  * on the resulting caps.
2796  *
2797  * Returns: (transfer full) (nullable): the allowed #GstCaps of the
2798  *     pad link. Unref the caps when you no longer need it. This
2799  *     function returns %NULL when @pad has no peer.
2800  *
2801  * MT safe.
2802  */
2803 GstCaps *
2804 gst_pad_get_allowed_caps (GstPad * pad)
2805 {
2806   GstCaps *mycaps;
2807   GstCaps *caps = NULL;
2808   GstQuery *query;
2809 
2810   g_return_val_if_fail (GST_IS_PAD (pad), NULL);
2811 
2812   GST_OBJECT_LOCK (pad);
2813   if (G_UNLIKELY (GST_PAD_PEER (pad) == NULL))
2814     goto no_peer;
2815   GST_OBJECT_UNLOCK (pad);
2816 
2817   GST_CAT_DEBUG_OBJECT (GST_CAT_PROPERTIES, pad, &quot;getting allowed caps&quot;);
2818 
2819   mycaps = gst_pad_query_caps (pad, NULL);
2820 
2821   /* Query peer caps */
2822   query = gst_query_new_caps (mycaps);
2823   if (!gst_pad_peer_query (pad, query)) {
2824     GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad, &quot;Caps query failed&quot;);
2825     goto end;
2826   }
2827 
2828   gst_query_parse_caps_result (query, &amp;caps);
2829   if (caps == NULL) {
2830     g_warn_if_fail (caps != NULL);
2831     goto end;
2832   }
2833   gst_caps_ref (caps);
2834 
2835   GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad, &quot;allowed caps %&quot; GST_PTR_FORMAT,
2836       caps);
2837 
2838 end:
2839   gst_query_unref (query);
2840   gst_caps_unref (mycaps);
2841 
2842   return caps;
2843 
2844 no_peer:
2845   {
2846     GST_CAT_DEBUG_OBJECT (GST_CAT_PROPERTIES, pad, &quot;no peer&quot;);
2847     GST_OBJECT_UNLOCK (pad);
2848 
2849     return NULL;
2850   }
2851 }
2852 
2853 /**
2854  * gst_pad_iterate_internal_links_default:
2855  * @pad: the #GstPad to get the internal links of.
2856  * @parent: (allow-none): the parent of @pad or %NULL
2857  *
2858  * Iterate the list of pads to which the given pad is linked to inside of
2859  * the parent element.
2860  * This is the default handler, and thus returns an iterator of all of the
2861  * pads inside the parent element with opposite direction.
2862  *
2863  * The caller must free this iterator after use with gst_iterator_free().
2864  *
2865  * Returns: (nullable): a #GstIterator of #GstPad, or %NULL if @pad
2866  * has no parent. Unref each returned pad with gst_object_unref().
2867  */
2868 GstIterator *
2869 gst_pad_iterate_internal_links_default (GstPad * pad, GstObject * parent)
2870 {
2871   GstIterator *res;
2872   GList **padlist;
2873   guint32 *cookie;
2874   GMutex *lock;
2875   gpointer owner;
2876   GstElement *eparent;
2877 
2878   g_return_val_if_fail (GST_IS_PAD (pad), NULL);
2879 
2880   if (parent != NULL &amp;&amp; GST_IS_ELEMENT (parent)) {
2881     eparent = GST_ELEMENT_CAST (gst_object_ref (parent));
2882   } else {
2883     GST_OBJECT_LOCK (pad);
2884     eparent = GST_PAD_PARENT (pad);
2885     if (!eparent || !GST_IS_ELEMENT (eparent))
2886       goto no_parent;
2887 
2888     gst_object_ref (eparent);
2889     GST_OBJECT_UNLOCK (pad);
2890   }
2891 
2892   if (pad-&gt;direction == GST_PAD_SRC)
2893     padlist = &amp;eparent-&gt;sinkpads;
2894   else
2895     padlist = &amp;eparent-&gt;srcpads;
2896 
2897   GST_DEBUG_OBJECT (pad, &quot;Making iterator&quot;);
2898 
2899   cookie = &amp;eparent-&gt;pads_cookie;
2900   owner = eparent;
2901   lock = GST_OBJECT_GET_LOCK (eparent);
2902 
2903   res = gst_iterator_new_list (GST_TYPE_PAD,
2904       lock, cookie, padlist, (GObject *) owner, NULL);
2905 
2906   gst_object_unref (owner);
2907 
2908   return res;
2909 
2910   /* ERRORS */
2911 no_parent:
2912   {
2913     GST_OBJECT_UNLOCK (pad);
2914     GST_DEBUG_OBJECT (pad, &quot;no parent element&quot;);
2915     return NULL;
2916   }
2917 }
2918 
2919 /**
2920  * gst_pad_iterate_internal_links:
2921  * @pad: the GstPad to get the internal links of.
2922  *
2923  * Gets an iterator for the pads to which the given pad is linked to inside
2924  * of the parent element.
2925  *
2926  * Each #GstPad element yielded by the iterator will have its refcount increased,
2927  * so unref after use.
2928  *
2929  * Free-function: gst_iterator_free
2930  *
2931  * Returns: (transfer full) (nullable): a new #GstIterator of #GstPad
2932  *     or %NULL when the pad does not have an iterator function
2933  *     configured. Use gst_iterator_free() after usage.
2934  */
2935 GstIterator *
2936 gst_pad_iterate_internal_links (GstPad * pad)
2937 {
2938   GstIterator *res = NULL;
2939   GstObject *parent;
2940 
2941   g_return_val_if_fail (GST_IS_PAD (pad), NULL);
2942 
2943   GST_OBJECT_LOCK (pad);
2944   ACQUIRE_PARENT (pad, parent, no_parent);
2945   GST_OBJECT_UNLOCK (pad);
2946 
2947   if (GST_PAD_ITERINTLINKFUNC (pad))
2948     res = GST_PAD_ITERINTLINKFUNC (pad) (pad, parent);
2949 
2950   RELEASE_PARENT (parent);
2951 
2952   return res;
2953 
2954   /* ERRORS */
2955 no_parent:
2956   {
2957     GST_DEBUG_OBJECT (pad, &quot;no parent&quot;);
2958     GST_OBJECT_UNLOCK (pad);
2959     return NULL;
2960   }
2961 }
2962 
2963 /**
2964  * gst_pad_forward:
2965  * @pad: a #GstPad
2966  * @forward: (scope call): a #GstPadForwardFunction
2967  * @user_data: user data passed to @forward
2968  *
2969  * Calls @forward for all internally linked pads of @pad. This function deals with
2970  * dynamically changing internal pads and will make sure that the @forward
2971  * function is only called once for each pad.
2972  *
2973  * When @forward returns %TRUE, no further pads will be processed.
2974  *
2975  * Returns: %TRUE if one of the dispatcher functions returned %TRUE.
2976  */
2977 gboolean
2978 gst_pad_forward (GstPad * pad, GstPadForwardFunction forward,
2979     gpointer user_data)
2980 {
2981   gboolean result = FALSE;
2982   GstIterator *iter;
2983   gboolean done = FALSE;
2984   GValue item = { 0, };
2985   GList *pushed_pads = NULL;
2986 
2987   iter = gst_pad_iterate_internal_links (pad);
2988 
2989   if (!iter)
2990     goto no_iter;
2991 
2992   while (!done) {
2993     switch (gst_iterator_next (iter, &amp;item)) {
2994       case GST_ITERATOR_OK:
2995       {
2996         GstPad *intpad;
2997 
2998         intpad = g_value_get_object (&amp;item);
2999 
3000         /* if already pushed, skip. FIXME, find something faster to tag pads */
3001         if (intpad == NULL || g_list_find (pushed_pads, intpad)) {
3002           g_value_reset (&amp;item);
3003           break;
3004         }
3005 
3006         GST_LOG_OBJECT (pad, &quot;calling forward function on pad %s:%s&quot;,
3007             GST_DEBUG_PAD_NAME (intpad));
3008         done = result = forward (intpad, user_data);
3009 
3010         pushed_pads = g_list_prepend (pushed_pads, intpad);
3011 
3012         g_value_reset (&amp;item);
3013         break;
3014       }
3015       case GST_ITERATOR_RESYNC:
3016         /* We don&#39;t reset the result here because we don&#39;t push the event
3017          * again on pads that got the event already and because we need
3018          * to consider the result of the previous pushes */
3019         gst_iterator_resync (iter);
3020         break;
3021       case GST_ITERATOR_ERROR:
3022         GST_ERROR_OBJECT (pad, &quot;Could not iterate over internally linked pads&quot;);
3023         done = TRUE;
3024         break;
3025       case GST_ITERATOR_DONE:
3026         done = TRUE;
3027         break;
3028     }
3029   }
3030   g_value_unset (&amp;item);
3031   gst_iterator_free (iter);
3032 
3033   g_list_free (pushed_pads);
3034 
3035 no_iter:
3036   return result;
3037 }
3038 
3039 typedef struct
3040 {
3041   GstEvent *event;
3042   gboolean result;
3043   gboolean dispatched;
3044 } EventData;
3045 
3046 static gboolean
3047 event_forward_func (GstPad * pad, EventData * data)
3048 {
3049   /* for each pad we send to, we should ref the event; it&#39;s up
3050    * to downstream to unref again when handled. */
3051   GST_LOG_OBJECT (pad, &quot;Reffing and pushing event %p (%s) to %s:%s&quot;,
3052       data-&gt;event, GST_EVENT_TYPE_NAME (data-&gt;event), GST_DEBUG_PAD_NAME (pad));
3053 
3054   data-&gt;result |= gst_pad_push_event (pad, gst_event_ref (data-&gt;event));
3055 
3056   data-&gt;dispatched = TRUE;
3057 
3058   /* don&#39;t stop */
3059   return FALSE;
3060 }
3061 
3062 /**
3063  * gst_pad_event_default:
3064  * @pad: a #GstPad to call the default event handler on.
3065  * @parent: (allow-none): the parent of @pad or %NULL
3066  * @event: (transfer full): the #GstEvent to handle.
3067  *
3068  * Invokes the default event handler for the given pad.
3069  *
3070  * The EOS event will pause the task associated with @pad before it is forwarded
3071  * to all internally linked pads,
3072  *
3073  * The event is sent to all pads internally linked to @pad. This function
3074  * takes ownership of @event.
3075  *
3076  * Returns: %TRUE if the event was sent successfully.
3077  */
3078 gboolean
3079 gst_pad_event_default (GstPad * pad, GstObject * parent, GstEvent * event)
3080 {
3081   gboolean result, forward = TRUE;
3082 
3083   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
3084   g_return_val_if_fail (event != NULL, FALSE);
3085 
3086   GST_LOG_OBJECT (pad, &quot;default event handler for event %&quot; GST_PTR_FORMAT,
3087       event);
3088 
3089   switch (GST_EVENT_TYPE (event)) {
3090     case GST_EVENT_CAPS:
3091       forward = GST_PAD_IS_PROXY_CAPS (pad);
3092       result = TRUE;
3093       break;
3094     default:
3095       break;
3096   }
3097 
3098   if (forward) {
3099     EventData data;
3100 
3101     data.event = event;
3102     data.dispatched = FALSE;
3103     data.result = FALSE;
3104 
3105     gst_pad_forward (pad, (GstPadForwardFunction) event_forward_func, &amp;data);
3106 
3107     /* for sinkpads without a parent element or without internal links, nothing
3108      * will be dispatched but we still want to return TRUE. */
3109     if (data.dispatched)
3110       result = data.result;
3111     else
3112       result = TRUE;
3113   }
3114 
3115   gst_event_unref (event);
3116 
3117   return result;
3118 }
3119 
3120 /* Default accept caps implementation just checks against
3121  * the allowed caps for the pad */
3122 static gboolean
3123 gst_pad_query_accept_caps_default (GstPad * pad, GstQuery * query)
3124 {
3125   /* get the caps and see if it intersects to something not empty */
3126   GstCaps *caps, *allowed = NULL;
3127   gboolean result;
3128 
3129   GST_DEBUG_OBJECT (pad, &quot;query accept-caps %&quot; GST_PTR_FORMAT, query);
3130 
3131   /* first forward the query to internally linked pads when we are dealing with
3132    * a PROXY CAPS */
3133   if (GST_PAD_IS_PROXY_CAPS (pad)) {
3134     result = gst_pad_proxy_query_accept_caps (pad, query);
3135     if (result)
3136       allowed = gst_pad_get_pad_template_caps (pad);
3137     else
3138       goto done;
3139   }
3140 
3141   gst_query_parse_accept_caps (query, &amp;caps);
3142   if (!allowed) {
3143     if (GST_PAD_IS_ACCEPT_TEMPLATE (pad)) {
3144       allowed = gst_pad_get_pad_template_caps (pad);
3145     } else {
3146       GST_CAT_DEBUG_OBJECT (GST_CAT_PERFORMANCE, pad,
3147           &quot;fallback ACCEPT_CAPS query, consider implementing a specialized version&quot;);
3148       allowed = gst_pad_query_caps (pad, caps);
3149     }
3150   }
3151 
3152   if (allowed) {
3153     if (GST_PAD_IS_ACCEPT_INTERSECT (pad)) {
3154       GST_DEBUG_OBJECT (pad,
3155           &quot;allowed caps intersect %&quot; GST_PTR_FORMAT &quot;, caps %&quot; GST_PTR_FORMAT,
3156           allowed, caps);
3157       result = gst_caps_can_intersect (caps, allowed);
3158     } else {
3159       GST_DEBUG_OBJECT (pad, &quot;allowed caps subset %&quot; GST_PTR_FORMAT &quot;, caps %&quot;
3160           GST_PTR_FORMAT, allowed, caps);
3161       result = gst_caps_is_subset (caps, allowed);
3162     }
3163     gst_caps_unref (allowed);
3164   } else {
3165     GST_DEBUG_OBJECT (pad, &quot;no compatible caps allowed on the pad&quot;);
3166     result = FALSE;
3167   }
3168   gst_query_set_accept_caps_result (query, result);
3169 
3170 done:
3171   return TRUE;
3172 }
3173 
3174 /* Default caps implementation */
3175 static gboolean
3176 gst_pad_query_caps_default (GstPad * pad, GstQuery * query)
3177 {
3178   GstCaps *result = NULL, *filter;
3179   GstPadTemplate *templ;
3180   gboolean fixed_caps;
3181 
3182   GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad, &quot;query caps %&quot; GST_PTR_FORMAT,
3183       query);
3184 
3185   /* first try to proxy if we must */
3186   if (GST_PAD_IS_PROXY_CAPS (pad)) {
3187     if ((gst_pad_proxy_query_caps (pad, query))) {
3188       goto done;
3189     }
3190   }
3191 
3192   gst_query_parse_caps (query, &amp;filter);
3193 
3194   /* no proxy or it failed, do default handling */
3195   fixed_caps = GST_PAD_IS_FIXED_CAPS (pad);
3196 
3197   GST_OBJECT_LOCK (pad);
3198   if (fixed_caps) {
3199     /* fixed caps, try the negotiated caps first */
3200     GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad, &quot;fixed pad caps: trying pad caps&quot;);
3201     if ((result = get_pad_caps (pad)))
3202       goto filter_done_unlock;
3203   }
3204 
3205   if ((templ = GST_PAD_PAD_TEMPLATE (pad))) {
3206     GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad, &quot;trying pad template caps&quot;);
3207     if ((result = GST_PAD_TEMPLATE_CAPS (templ)))
3208       goto filter_done_unlock;
3209   }
3210 
3211   if (!fixed_caps) {
3212     GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad,
3213         &quot;non-fixed pad caps: trying pad caps&quot;);
3214     /* non fixed caps, try the negotiated caps */
3215     if ((result = get_pad_caps (pad)))
3216       goto filter_done_unlock;
3217   }
3218 
3219   /* this almost never happens */
3220   GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad, &quot;pad has no caps&quot;);
3221   result = GST_CAPS_ANY;
3222 
3223 filter_done_unlock:
3224   GST_OBJECT_UNLOCK (pad);
3225 
3226   /* run the filter on the result */
3227   if (filter) {
3228     GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad,
3229         &quot;using caps %p %&quot; GST_PTR_FORMAT &quot; with filter %p %&quot;
3230         GST_PTR_FORMAT, result, result, filter, filter);
3231     result = gst_caps_intersect_full (filter, result, GST_CAPS_INTERSECT_FIRST);
3232     GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad, &quot;result %p %&quot; GST_PTR_FORMAT,
3233         result, result);
3234   } else {
3235     GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad,
3236         &quot;using caps %p %&quot; GST_PTR_FORMAT, result, result);
3237     result = gst_caps_ref (result);
3238   }
3239   gst_query_set_caps_result (query, result);
3240   gst_caps_unref (result);
3241 
3242 done:
3243   return TRUE;
3244 }
3245 
3246 /* Default latency implementation */
3247 typedef struct
3248 {
3249   gboolean live;
3250   GstClockTime min, max;
3251 } LatencyFoldData;
3252 
3253 static gboolean
3254 query_latency_default_fold (const GValue * item, GValue * ret,
3255     gpointer user_data)
3256 {
3257   GstPad *pad = g_value_get_object (item), *peer;
3258   LatencyFoldData *fold_data = user_data;
3259   GstQuery *query;
3260   gboolean res = FALSE;
3261 
3262   query = gst_query_new_latency ();
3263 
3264   peer = gst_pad_get_peer (pad);
3265   if (peer) {
3266     res = gst_pad_peer_query (pad, query);
3267   } else {
3268     GST_LOG_OBJECT (pad, &quot;No peer pad found, ignoring this pad&quot;);
3269   }
3270 
3271   if (res) {
3272     gboolean live;
3273     GstClockTime min, max;
3274 
3275     gst_query_parse_latency (query, &amp;live, &amp;min, &amp;max);
3276 
3277     GST_LOG_OBJECT (pad, &quot;got latency live:%s min:%&quot; G_GINT64_FORMAT
3278         &quot; max:%&quot; G_GINT64_FORMAT, live ? &quot;true&quot; : &quot;false&quot;, min, max);
3279 
3280     if (live) {
3281       if (min &gt; fold_data-&gt;min)
3282         fold_data-&gt;min = min;
3283 
3284       if (fold_data-&gt;max == GST_CLOCK_TIME_NONE)
3285         fold_data-&gt;max = max;
3286       else if (max &lt; fold_data-&gt;max)
3287         fold_data-&gt;max = max;
3288 
3289       fold_data-&gt;live = TRUE;
3290     }
3291   } else if (peer) {
3292     GST_DEBUG_OBJECT (pad, &quot;latency query failed&quot;);
3293     g_value_set_boolean (ret, FALSE);
3294   }
3295 
3296   gst_query_unref (query);
3297   if (peer)
3298     gst_object_unref (peer);
3299 
3300   return TRUE;
3301 }
3302 
3303 static gboolean
3304 gst_pad_query_latency_default (GstPad * pad, GstQuery * query)
3305 {
3306   GstIterator *it;
3307   GstIteratorResult res;
3308   GValue ret = G_VALUE_INIT;
3309   gboolean query_ret;
3310   LatencyFoldData fold_data;
3311 
3312   it = gst_pad_iterate_internal_links (pad);
3313   if (!it) {
3314     GST_DEBUG_OBJECT (pad, &quot;Can&#39;t iterate internal links&quot;);
3315     return FALSE;
3316   }
3317 
3318   g_value_init (&amp;ret, G_TYPE_BOOLEAN);
3319 
3320 retry:
3321   fold_data.live = FALSE;
3322   fold_data.min = 0;
3323   fold_data.max = GST_CLOCK_TIME_NONE;
3324 
3325   g_value_set_boolean (&amp;ret, TRUE);
3326   res = gst_iterator_fold (it, query_latency_default_fold, &amp;ret, &amp;fold_data);
3327   switch (res) {
3328     case GST_ITERATOR_OK:
3329       g_assert_not_reached ();
3330       break;
3331     case GST_ITERATOR_DONE:
3332       break;
3333     case GST_ITERATOR_ERROR:
3334       g_value_set_boolean (&amp;ret, FALSE);
3335       break;
3336     case GST_ITERATOR_RESYNC:
3337       gst_iterator_resync (it);
3338       goto retry;
3339     default:
3340       g_assert_not_reached ();
3341       break;
3342   }
3343   gst_iterator_free (it);
3344 
3345   query_ret = g_value_get_boolean (&amp;ret);
3346   if (query_ret) {
3347     GST_LOG_OBJECT (pad, &quot;got latency live:%s min:%&quot; G_GINT64_FORMAT
3348         &quot; max:%&quot; G_GINT64_FORMAT, fold_data.live ? &quot;true&quot; : &quot;false&quot;,
3349         fold_data.min, fold_data.max);
3350 
3351     if (fold_data.min &gt; fold_data.max) {
3352       GST_ERROR_OBJECT (pad, &quot;minimum latency bigger than maximum latency&quot;);
3353     }
3354 
3355     gst_query_set_latency (query, fold_data.live, fold_data.min, fold_data.max);
3356   } else {
3357     GST_LOG_OBJECT (pad, &quot;latency query failed&quot;);
3358   }
3359 
3360   return query_ret;
3361 }
3362 
3363 typedef struct
3364 {
3365   GstQuery *query;
3366   gboolean result;
3367   gboolean dispatched;
3368 } QueryData;
3369 
3370 static gboolean
3371 query_forward_func (GstPad * pad, QueryData * data)
3372 {
3373   GST_LOG_OBJECT (pad, &quot;query peer %p (%s) of %s:%s&quot;,
3374       data-&gt;query, GST_QUERY_TYPE_NAME (data-&gt;query), GST_DEBUG_PAD_NAME (pad));
3375 
3376   data-&gt;result |= gst_pad_peer_query (pad, data-&gt;query);
3377 
3378   data-&gt;dispatched = TRUE;
3379 
3380   /* stop on first successful reply */
3381   return data-&gt;result;
3382 }
3383 
3384 /**
3385  * gst_pad_query_default:
3386  * @pad: a #GstPad to call the default query handler on.
3387  * @parent: (allow-none): the parent of @pad or %NULL
3388  * @query: (transfer none): the #GstQuery to handle.
3389  *
3390  * Invokes the default query handler for the given pad.
3391  * The query is sent to all pads internally linked to @pad. Note that
3392  * if there are many possible sink pads that are internally linked to
3393  * @pad, only one will be sent the query.
3394  * Multi-sinkpad elements should implement custom query handlers.
3395  *
3396  * Returns: %TRUE if the query was performed successfully.
3397  */
3398 gboolean
3399 gst_pad_query_default (GstPad * pad, GstObject * parent, GstQuery * query)
3400 {
3401   gboolean forward, ret = FALSE;
3402 
3403   switch (GST_QUERY_TYPE (query)) {
3404     case GST_QUERY_SCHEDULING:
3405       forward = GST_PAD_IS_PROXY_SCHEDULING (pad);
3406       break;
3407     case GST_QUERY_ALLOCATION:
3408       forward = GST_PAD_IS_PROXY_ALLOCATION (pad);
3409       break;
3410     case GST_QUERY_ACCEPT_CAPS:
3411       ret = gst_pad_query_accept_caps_default (pad, query);
3412       forward = FALSE;
3413       break;
3414     case GST_QUERY_CAPS:
3415       ret = gst_pad_query_caps_default (pad, query);
3416       forward = FALSE;
3417       break;
3418     case GST_QUERY_LATENCY:
3419       ret = gst_pad_query_latency_default (pad, query);
3420       forward = FALSE;
3421       break;
3422     case GST_QUERY_BITRATE:
3423       /* FIXME: better default handling */
3424       forward = TRUE;
3425       break;
3426     case GST_QUERY_POSITION:
3427     case GST_QUERY_SEEKING:
3428     case GST_QUERY_FORMATS:
3429     case GST_QUERY_JITTER:
3430     case GST_QUERY_RATE:
3431     case GST_QUERY_CONVERT:
3432     default:
3433       forward = TRUE;
3434       break;
3435   }
3436 
3437   GST_DEBUG_OBJECT (pad, &quot;%sforwarding %p (%s) query&quot;, (forward ? &quot;&quot; : &quot;not &quot;),
3438       query, GST_QUERY_TYPE_NAME (query));
3439 
3440   if (forward) {
3441     QueryData data;
3442 
3443     data.query = query;
3444     data.dispatched = FALSE;
3445     data.result = FALSE;
3446 
3447     gst_pad_forward (pad, (GstPadForwardFunction) query_forward_func, &amp;data);
3448 
3449     if (data.dispatched) {
3450       ret = data.result;
3451     } else {
3452       /* nothing dispatched, assume drained */
3453       if (GST_QUERY_TYPE (query) == GST_QUERY_DRAIN)
3454         ret = TRUE;
3455       else
3456         ret = FALSE;
3457     }
3458   }
3459   return ret;
3460 }
3461 
3462 #define N_STACK_ALLOCATE_PROBES (16)
3463 
3464 static void
3465 probe_hook_marshal (GHook * hook, ProbeMarshall * data)
3466 {
3467   GstPad *pad = data-&gt;pad;
3468   GstPadProbeInfo *info = data-&gt;info;
3469   GstPadProbeType type, flags;
3470   GstPadProbeCallback callback;
3471   GstPadProbeReturn ret;
3472   gpointer original_data;
3473   guint i;
3474 
3475   /* if we have called this callback, do nothing. But only check
3476    * if we&#39;re actually calling probes a second time */
3477   if (data-&gt;retry) {
3478     for (i = 0; i &lt; data-&gt;n_called_probes; i++) {
3479       if (data-&gt;called_probes[i] == hook-&gt;hook_id) {
3480         GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3481             &quot;hook %lu already called&quot;, hook-&gt;hook_id);
3482         return;
3483       }
3484     }
3485   }
3486 
3487   /* reallocate on the heap if we had more than 16 probes */
3488   if (data-&gt;n_called_probes == data-&gt;called_probes_size) {
3489     if (data-&gt;called_probes_size &gt; N_STACK_ALLOCATE_PROBES) {
3490       data-&gt;called_probes_size *= 2;
3491       data-&gt;called_probes =
3492           g_renew (gulong, data-&gt;called_probes, data-&gt;called_probes_size);
3493     } else {
3494       gulong *tmp = data-&gt;called_probes;
3495 
3496       data-&gt;called_probes_size *= 2;
3497       data-&gt;called_probes = g_new (gulong, data-&gt;called_probes_size);
3498       memcpy (data-&gt;called_probes, tmp,
3499           N_STACK_ALLOCATE_PROBES * sizeof (gulong));
3500     }
3501   }
3502   data-&gt;called_probes[data-&gt;n_called_probes++] = hook-&gt;hook_id;
3503 
3504   flags = hook-&gt;flags &gt;&gt; G_HOOK_FLAG_USER_SHIFT;
3505   type = info-&gt;type;
3506   original_data = info-&gt;data;
3507 
3508   /* one of the scheduling types */
3509   if ((flags &amp; GST_PAD_PROBE_TYPE_SCHEDULING &amp; type) == 0)
3510     goto no_match;
3511 
3512   if (G_UNLIKELY (data-&gt;handled)) {
3513     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3514         &quot;probe previously returned HANDLED, not calling again&quot;);
3515     goto no_match;
3516   } else if (G_UNLIKELY (data-&gt;dropped)) {
3517     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3518         &quot;probe previously returned DROPPED, not calling again&quot;);
3519     goto no_match;
3520   }
3521 
3522   if (type &amp; GST_PAD_PROBE_TYPE_PUSH) {
3523     /* one of the data types for non-idle probes */
3524     if ((type &amp; GST_PAD_PROBE_TYPE_IDLE) == 0
3525         &amp;&amp; (flags &amp; _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH &amp; type) == 0)
3526       goto no_match;
3527   } else if (type &amp; GST_PAD_PROBE_TYPE_PULL) {
3528     /* one of the data types for non-idle probes */
3529     if ((type &amp; GST_PAD_PROBE_TYPE_BLOCKING) == 0
3530         &amp;&amp; (flags &amp; _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH &amp; type) == 0)
3531       goto no_match;
3532   } else {
3533     /* Type must have PULL or PUSH probe types */
3534     g_assert_not_reached ();
3535   }
3536 
3537   /* one of the blocking types must match */
3538   if ((type &amp; GST_PAD_PROBE_TYPE_BLOCKING) &amp;&amp;
3539       (flags &amp; GST_PAD_PROBE_TYPE_BLOCKING &amp; type) == 0)
3540     goto no_match;
3541   if ((type &amp; GST_PAD_PROBE_TYPE_BLOCKING) == 0 &amp;&amp;
3542       (flags &amp; GST_PAD_PROBE_TYPE_BLOCKING))
3543     goto no_match;
3544   /* only probes that have GST_PAD_PROBE_TYPE_EVENT_FLUSH set */
3545   if ((type &amp; GST_PAD_PROBE_TYPE_EVENT_FLUSH) &amp;&amp;
3546       (flags &amp; GST_PAD_PROBE_TYPE_EVENT_FLUSH &amp; type) == 0)
3547     goto no_match;
3548 
3549   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3550       &quot;hook %lu with flags 0x%08x matches&quot;, hook-&gt;hook_id, flags);
3551 
3552   data-&gt;marshalled = TRUE;
3553 
3554   callback = (GstPadProbeCallback) hook-&gt;func;
3555   if (callback == NULL)
3556     return;
3557 
3558   info-&gt;id = hook-&gt;hook_id;
3559 
3560   if ((flags &amp; GST_PAD_PROBE_TYPE_IDLE))
3561     pad-&gt;priv-&gt;idle_running++;
3562 
3563   GST_OBJECT_UNLOCK (pad);
3564 
3565   ret = callback (pad, info, hook-&gt;data);
3566 
3567   GST_OBJECT_LOCK (pad);
3568 
3569   if ((flags &amp; GST_PAD_PROBE_TYPE_IDLE))
3570     pad-&gt;priv-&gt;idle_running--;
3571 
3572   if (ret != GST_PAD_PROBE_HANDLED &amp;&amp; original_data != NULL
3573       &amp;&amp; info-&gt;data == NULL) {
3574     GST_DEBUG_OBJECT (pad, &quot;data item in pad probe info was dropped&quot;);
3575     info-&gt;type = GST_PAD_PROBE_TYPE_INVALID;
3576     data-&gt;dropped = TRUE;
3577   }
3578 
3579   switch (ret) {
3580     case GST_PAD_PROBE_REMOVE:
3581       /* remove the probe */
3582       GST_DEBUG_OBJECT (pad, &quot;asked to remove hook&quot;);
3583       cleanup_hook (pad, hook);
3584       break;
3585     case GST_PAD_PROBE_DROP:
3586       /* need to drop the data, make sure other probes don&#39;t get called
3587        * anymore */
3588       GST_DEBUG_OBJECT (pad, &quot;asked to drop item&quot;);
3589       info-&gt;type = GST_PAD_PROBE_TYPE_INVALID;
3590       data-&gt;dropped = TRUE;
3591       break;
3592     case GST_PAD_PROBE_HANDLED:
3593       GST_DEBUG_OBJECT (pad, &quot;probe handled data&quot;);
3594       data-&gt;handled = TRUE;
3595       break;
3596     case GST_PAD_PROBE_PASS:
3597       /* inform the pad block to let things pass */
3598       GST_DEBUG_OBJECT (pad, &quot;asked to pass item&quot;);
3599       data-&gt;pass = TRUE;
3600       break;
3601     case GST_PAD_PROBE_OK:
3602       GST_DEBUG_OBJECT (pad, &quot;probe returned OK&quot;);
3603       break;
3604     default:
3605       GST_DEBUG_OBJECT (pad, &quot;probe returned %d&quot;, ret);
3606       break;
3607   }
3608   return;
3609 
3610 no_match:
3611   {
3612     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3613         &quot;hook %lu with flags 0x%08x does not match %08x&quot;,
3614         hook-&gt;hook_id, flags, info-&gt;type);
3615     return;
3616   }
3617 }
3618 
3619 /* a probe that does not take or return any data */
3620 #define PROBE_NO_DATA(pad,mask,label,defaultval)                \
3621   G_STMT_START {            \
3622     if (G_UNLIKELY (pad-&gt;num_probes)) {       \
3623       GstFlowReturn pval = defaultval;        \
3624       /* pass NULL as the data item */                          \
3625       GstPadProbeInfo info = { mask, 0, NULL, 0, 0 };   \
3626       info.ABI.abi.flow_ret = defaultval;     \
3627       ret = do_probe_callbacks (pad, &amp;info, defaultval);  \
3628       if (G_UNLIKELY (ret != pval &amp;&amp; ret != GST_FLOW_OK)) \
3629         goto label;           \
3630     }               \
3631   } G_STMT_END
3632 
3633 #define PROBE_FULL(pad,mask,data,offs,size,label,handleable,handle_label) \
3634   G_STMT_START {              \
3635     if (G_UNLIKELY (pad-&gt;num_probes)) {         \
3636       /* pass the data item */            \
3637       GstPadProbeInfo info = { mask, 0, data, offs, size };   \
3638       info.ABI.abi.flow_ret = GST_FLOW_OK;        \
3639       ret = do_probe_callbacks (pad, &amp;info, GST_FLOW_OK);   \
3640       /* store the possibly updated data item */      \
3641       data = GST_PAD_PROBE_INFO_DATA (&amp;info);       \
3642       /* if something went wrong, exit */       \
3643       if (G_UNLIKELY (ret != GST_FLOW_OK)) {        \
3644   if (handleable &amp;&amp; ret == GST_FLOW_CUSTOM_SUCCESS_1) {   \
3645     ret = info.ABI.abi.flow_ret;            \
3646     goto handle_label;            \
3647   }               \
3648   goto label;             \
3649       }                 \
3650     }                 \
3651   } G_STMT_END
3652 
3653 #define PROBE_PUSH(pad,mask,data,label)   \
3654   PROBE_FULL(pad, mask, data, -1, -1, label, FALSE, label);
3655 #define PROBE_HANDLE(pad,mask,data,label,handle_label)  \
3656   PROBE_FULL(pad, mask, data, -1, -1, label, TRUE, handle_label);
3657 #define PROBE_PULL(pad,mask,data,offs,size,label)   \
3658   PROBE_FULL(pad, mask, data, offs, size, label, FALSE, label);
3659 
3660 static GstFlowReturn
3661 do_pad_idle_probe_wait (GstPad * pad)
3662 {
3663   while (GST_PAD_IS_RUNNING_IDLE_PROBE (pad)) {
3664     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3665         &quot;waiting idle probe to be removed&quot;);
3666     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_BLOCKING);
3667     GST_PAD_BLOCK_WAIT (pad);
3668     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_BLOCKING);
3669     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;We got unblocked&quot;);
3670 
3671     if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
3672       return GST_FLOW_FLUSHING;
3673   }
3674   return GST_FLOW_OK;
3675 }
3676 
3677 #define PROBE_TYPE_IS_SERIALIZED(i) \
3678     ( \
3679       ( \
3680         (((i)-&gt;type &amp; (GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM | \
3681         GST_PAD_PROBE_TYPE_EVENT_FLUSH)) &amp;&amp; \
3682         GST_EVENT_IS_SERIALIZED ((i)-&gt;data)) \
3683       ) || ( \
3684         (((i)-&gt;type &amp; GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM) &amp;&amp; \
3685         GST_QUERY_IS_SERIALIZED ((i)-&gt;data)) \
3686       ) || ( \
3687         ((i)-&gt;type &amp; (GST_PAD_PROBE_TYPE_BUFFER | \
3688         GST_PAD_PROBE_TYPE_BUFFER_LIST))  \
3689       ) \
3690     )
3691 
3692 static GstFlowReturn
3693 do_probe_callbacks (GstPad * pad, GstPadProbeInfo * info,
3694     GstFlowReturn defaultval)
3695 {
3696   ProbeMarshall data;
3697   guint cookie;
3698   gboolean is_block;
3699   gulong called_probes[N_STACK_ALLOCATE_PROBES];
3700 
3701   data.pad = pad;
3702   data.info = info;
3703   data.pass = FALSE;
3704   data.handled = FALSE;
3705   data.marshalled = FALSE;
3706   data.dropped = FALSE;
3707 
3708   /* We stack-allocate for N_STACK_ALLOCATE_PROBES hooks as a first step. If more are needed,
3709    * we will re-allocate with g_malloc(). This should usually never be needed
3710    */
3711   data.called_probes = called_probes;
3712   data.n_called_probes = 0;
3713   data.called_probes_size = N_STACK_ALLOCATE_PROBES;
3714   data.retry = FALSE;
3715 
3716   is_block =
3717       (info-&gt;type &amp; GST_PAD_PROBE_TYPE_BLOCK) == GST_PAD_PROBE_TYPE_BLOCK;
3718 
3719   if (is_block &amp;&amp; PROBE_TYPE_IS_SERIALIZED (info)) {
3720     if (do_pad_idle_probe_wait (pad) == GST_FLOW_FLUSHING)
3721       goto flushing;
3722   }
3723 
3724 again:
3725   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;do probes&quot;);
3726   cookie = pad-&gt;priv-&gt;probe_list_cookie;
3727 
3728   g_hook_list_marshal (&amp;pad-&gt;probes, TRUE,
3729       (GHookMarshaller) probe_hook_marshal, &amp;data);
3730 
3731   /* if the list changed, call the new callbacks (they will not be in
3732    * called_probes yet) */
3733   if (cookie != pad-&gt;priv-&gt;probe_list_cookie) {
3734     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3735         &quot;probe list changed, restarting&quot;);
3736     data.retry = TRUE;
3737     goto again;
3738   }
3739 
3740   /* the first item that dropped will stop the hooks and then we drop here */
3741   if (data.dropped)
3742     goto dropped;
3743 
3744   /* If one handler took care of it, let the the item pass */
3745   if (data.handled) {
3746     goto handled;
3747   }
3748 
3749   /* if no handler matched and we are blocking, let the item pass */
3750   if (!data.marshalled &amp;&amp; is_block)
3751     goto passed;
3752 
3753   /* At this point, all handlers returned either OK or PASS. If one handler
3754    * returned PASS, let the item pass */
3755   if (data.pass)
3756     goto passed;
3757 
3758   if (is_block) {
3759     while (GST_PAD_IS_BLOCKED (pad)) {
3760       GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3761           &quot;we are blocked %d times&quot;, pad-&gt;num_blocked);
3762 
3763       /* we might have released the lock */
3764       if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
3765         goto flushing;
3766 
3767       /* now we block the streaming thread. It can be unlocked when we
3768        * deactivate the pad (which will also set the FLUSHING flag) or
3769        * when the pad is unblocked. A flushing event will also unblock
3770        * the pad after setting the FLUSHING flag. */
3771       GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3772           &quot;Waiting to be unblocked or set flushing&quot;);
3773       GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_BLOCKING);
3774       GST_PAD_BLOCK_WAIT (pad);
3775       GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_BLOCKING);
3776       GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;We got unblocked&quot;);
3777 
3778       /* if the list changed, call the new callbacks (they will not be in
3779        * called_probes yet) */
3780       if (cookie != pad-&gt;priv-&gt;probe_list_cookie) {
3781         GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3782             &quot;probe list changed, restarting&quot;);
3783         data.retry = TRUE;
3784         goto again;
3785       }
3786 
3787       if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
3788         goto flushing;
3789     }
3790   }
3791 
3792   if (data.called_probes_size &gt; N_STACK_ALLOCATE_PROBES)
3793     g_free (data.called_probes);
3794 
3795   return defaultval;
3796 
3797   /* ERRORS */
3798 flushing:
3799   {
3800     GST_DEBUG_OBJECT (pad, &quot;pad is flushing&quot;);
3801     if (data.called_probes_size &gt; N_STACK_ALLOCATE_PROBES)
3802       g_free (data.called_probes);
3803     return GST_FLOW_FLUSHING;
3804   }
3805 dropped:
3806   {
3807     GST_DEBUG_OBJECT (pad, &quot;data is dropped&quot;);
3808     if (data.called_probes_size &gt; N_STACK_ALLOCATE_PROBES)
3809       g_free (data.called_probes);
3810     return GST_FLOW_CUSTOM_SUCCESS;
3811   }
3812 passed:
3813   {
3814     /* FIXME : Should we return FLOW_OK or the defaultval ?? */
3815     GST_DEBUG_OBJECT (pad, &quot;data is passed&quot;);
3816     if (data.called_probes_size &gt; N_STACK_ALLOCATE_PROBES)
3817       g_free (data.called_probes);
3818     return GST_FLOW_OK;
3819   }
3820 handled:
3821   {
3822     GST_DEBUG_OBJECT (pad, &quot;data was handled&quot;);
3823     if (data.called_probes_size &gt; N_STACK_ALLOCATE_PROBES)
3824       g_free (data.called_probes);
3825     return GST_FLOW_CUSTOM_SUCCESS_1;
3826   }
3827 }
3828 
3829 /* pad offsets */
3830 
3831 /**
3832  * gst_pad_get_offset:
3833  * @pad: a #GstPad
3834  *
3835  * Get the offset applied to the running time of @pad. @pad has to be a source
3836  * pad.
3837  *
3838  * Returns: the offset.
3839  */
3840 gint64
3841 gst_pad_get_offset (GstPad * pad)
3842 {
3843   gint64 result;
3844 
3845   g_return_val_if_fail (GST_IS_PAD (pad), 0);
3846 
3847   GST_OBJECT_LOCK (pad);
3848   result = pad-&gt;offset;
3849   GST_OBJECT_UNLOCK (pad);
3850 
3851   return result;
3852 }
3853 
3854 static gboolean
3855 mark_event_not_received (GstPad * pad, PadEvent * ev, gpointer user_data)
3856 {
3857   ev-&gt;received = FALSE;
3858   return TRUE;
3859 }
3860 
3861 /**
3862  * gst_pad_set_offset:
3863  * @pad: a #GstPad
3864  * @offset: the offset
3865  *
3866  * Set the offset that will be applied to the running time of @pad.
3867  */
3868 void
3869 gst_pad_set_offset (GstPad * pad, gint64 offset)
3870 {
3871   g_return_if_fail (GST_IS_PAD (pad));
3872 
3873   GST_OBJECT_LOCK (pad);
3874   /* if nothing changed, do nothing */
3875   if (pad-&gt;offset == offset)
3876     goto done;
3877 
3878   pad-&gt;offset = offset;
3879   GST_DEBUG_OBJECT (pad, &quot;changed offset to %&quot; GST_STIME_FORMAT,
3880       GST_STIME_ARGS (offset));
3881 
3882   /* resend all sticky events with updated offset on next buffer push */
3883   events_foreach (pad, mark_event_not_received, NULL);
3884   GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
3885 
3886 done:
3887   GST_OBJECT_UNLOCK (pad);
3888 }
3889 
3890 typedef struct
3891 {
3892   GstFlowReturn ret;
3893 
3894   /* If TRUE and ret is not OK this means
3895    * that pushing the EOS event failed
3896    */
3897   gboolean was_eos;
3898 
3899   /* If called for an event this is
3900    * the event that would be pushed
3901    * next. Don&#39;t forward sticky events
3902    * that would come after that */
3903   GstEvent *event;
3904 } PushStickyData;
3905 
3906 /* should be called with pad LOCK */
3907 static gboolean
3908 push_sticky (GstPad * pad, PadEvent * ev, gpointer user_data)
3909 {
3910   PushStickyData *data = user_data;
3911   GstEvent *event = ev-&gt;event;
3912 
3913   if (ev-&gt;received) {
3914     GST_DEBUG_OBJECT (pad, &quot;event %s was already received&quot;,
3915         GST_EVENT_TYPE_NAME (event));
3916     return TRUE;
3917   }
3918 
3919   /* If we&#39;re called because of an sticky event, only forward
3920    * events that would come before this new event and the
3921    * event itself */
3922   if (data-&gt;event &amp;&amp; GST_EVENT_IS_STICKY (data-&gt;event) &amp;&amp;
3923       GST_EVENT_TYPE (data-&gt;event) &lt;= GST_EVENT_SEGMENT &amp;&amp;
3924       GST_EVENT_TYPE (data-&gt;event) &lt; GST_EVENT_TYPE (event)) {
3925     data-&gt;ret = GST_FLOW_CUSTOM_SUCCESS_1;
3926   } else {
3927     data-&gt;ret = gst_pad_push_event_unchecked (pad, gst_event_ref (event),
3928         GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM);
3929     if (data-&gt;ret == GST_FLOW_CUSTOM_SUCCESS_1)
3930       data-&gt;ret = GST_FLOW_OK;
3931   }
3932 
3933   switch (data-&gt;ret) {
3934     case GST_FLOW_OK:
3935       ev-&gt;received = TRUE;
3936       GST_DEBUG_OBJECT (pad, &quot;event %s marked received&quot;,
3937           GST_EVENT_TYPE_NAME (event));
3938       break;
3939     case GST_FLOW_CUSTOM_SUCCESS:
3940       /* we can&#39;t assume the event is received when it was dropped */
3941       GST_DEBUG_OBJECT (pad, &quot;event %s was dropped, mark pending&quot;,
3942           GST_EVENT_TYPE_NAME (event));
3943       GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
3944       data-&gt;ret = GST_FLOW_OK;
3945       break;
3946     case GST_FLOW_CUSTOM_SUCCESS_1:
3947       /* event was ignored and should be sent later */
3948       GST_DEBUG_OBJECT (pad, &quot;event %s was ignored, mark pending&quot;,
3949           GST_EVENT_TYPE_NAME (event));
3950       GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
3951       data-&gt;ret = GST_FLOW_OK;
3952       break;
3953     case GST_FLOW_NOT_LINKED:
3954       /* not linked is not a problem, we are sticky so the event will be
3955        * rescheduled to be sent later on re-link, but only for non-EOS events */
3956       GST_DEBUG_OBJECT (pad, &quot;pad was not linked, mark pending&quot;);
3957       if (GST_EVENT_TYPE (event) != GST_EVENT_EOS) {
3958         data-&gt;ret = GST_FLOW_OK;
3959         ev-&gt;received = TRUE;
3960       }
3961       break;
3962     default:
3963       GST_DEBUG_OBJECT (pad, &quot;result %s, mark pending events&quot;,
3964           gst_flow_get_name (data-&gt;ret));
3965       GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
3966       break;
3967   }
3968 
3969   if (data-&gt;ret != GST_FLOW_OK &amp;&amp; GST_EVENT_TYPE (event) == GST_EVENT_EOS)
3970     data-&gt;was_eos = TRUE;
3971 
3972   return data-&gt;ret == GST_FLOW_OK;
3973 }
3974 
3975 /* check sticky events and push them when needed. should be called
3976  * with pad LOCK */
3977 static inline GstFlowReturn
3978 check_sticky (GstPad * pad, GstEvent * event)
3979 {
3980   PushStickyData data = { GST_FLOW_OK, FALSE, event };
3981 
3982   if (G_UNLIKELY (GST_PAD_HAS_PENDING_EVENTS (pad))) {
3983     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_PENDING_EVENTS);
3984 
3985     GST_DEBUG_OBJECT (pad, &quot;pushing all sticky events&quot;);
3986     events_foreach (pad, push_sticky, &amp;data);
3987 
3988     /* If there&#39;s an EOS event we must push it downstream
3989      * even if sending a previous sticky event failed.
3990      * Otherwise the pipeline might wait forever for EOS.
3991      *
3992      * Only do this if pushing another event than the EOS
3993      * event failed.
3994      */
3995     if (data.ret != GST_FLOW_OK &amp;&amp; !data.was_eos) {
3996       PadEvent *ev = find_event_by_type (pad, GST_EVENT_EOS, 0);
3997 
3998       if (ev &amp;&amp; !ev-&gt;received) {
3999         data.ret = gst_pad_push_event_unchecked (pad, gst_event_ref (ev-&gt;event),
4000             GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM);
4001         /* the event could have been dropped. Because this can only
4002          * happen if the user asked for it, it&#39;s not an error */
4003         if (data.ret == GST_FLOW_CUSTOM_SUCCESS)
4004           data.ret = GST_FLOW_OK;
4005       }
4006     }
4007   }
4008   return data.ret;
4009 }
4010 
4011 
4012 /**
4013  * gst_pad_query:
4014  * @pad: a #GstPad to invoke the default query on.
4015  * @query: (transfer none): the #GstQuery to perform.
4016  *
4017  * Dispatches a query to a pad. The query should have been allocated by the
4018  * caller via one of the type-specific allocation functions. The element that
4019  * the pad belongs to is responsible for filling the query with an appropriate
4020  * response, which should then be parsed with a type-specific query parsing
4021  * function.
4022  *
4023  * Again, the caller is responsible for both the allocation and deallocation of
4024  * the query structure.
4025  *
4026  * Please also note that some queries might need a running pipeline to work.
4027  *
4028  * Returns: %TRUE if the query could be performed.
4029  */
4030 gboolean
4031 gst_pad_query (GstPad * pad, GstQuery * query)
4032 {
4033   GstObject *parent;
4034   gboolean res, serialized;
4035   GstPadQueryFunction func;
4036   GstPadProbeType type;
4037   GstFlowReturn ret;
4038 
4039   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
4040   g_return_val_if_fail (GST_IS_QUERY (query), FALSE);
4041 
4042   if (GST_PAD_IS_SRC (pad)) {
4043     if (G_UNLIKELY (!GST_QUERY_IS_UPSTREAM (query)))
4044       goto wrong_direction;
4045     type = GST_PAD_PROBE_TYPE_QUERY_UPSTREAM;
4046   } else if (GST_PAD_IS_SINK (pad)) {
4047     if (G_UNLIKELY (!GST_QUERY_IS_DOWNSTREAM (query)))
4048       goto wrong_direction;
4049     type = GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM;
4050   } else
4051     goto unknown_direction;
4052 
4053   GST_DEBUG_OBJECT (pad, &quot;doing query %p (%s)&quot;, query,
4054       GST_QUERY_TYPE_NAME (query));
4055   GST_TRACER_PAD_QUERY_PRE (pad, query);
4056 
4057   serialized = GST_QUERY_IS_SERIALIZED (query);
4058   if (G_UNLIKELY (serialized))
4059     GST_PAD_STREAM_LOCK (pad);
4060 
4061   GST_OBJECT_LOCK (pad);
4062   PROBE_PUSH (pad, type | GST_PAD_PROBE_TYPE_PUSH |
4063       GST_PAD_PROBE_TYPE_BLOCK, query, probe_stopped);
4064   PROBE_PUSH (pad, type | GST_PAD_PROBE_TYPE_PUSH, query, probe_stopped);
4065 
4066   ACQUIRE_PARENT (pad, parent, no_parent);
4067   GST_OBJECT_UNLOCK (pad);
4068 
4069   if ((func = GST_PAD_QUERYFUNC (pad)) == NULL)
4070     goto no_func;
4071 
4072   res = func (pad, parent, query);
4073 
4074   RELEASE_PARENT (parent);
4075 
4076   GST_DEBUG_OBJECT (pad, &quot;sent query %p (%s), result %d&quot;, query,
4077       GST_QUERY_TYPE_NAME (query), res);
4078   GST_TRACER_PAD_QUERY_POST (pad, query, res);
4079 
4080   if (res != TRUE)
4081     goto query_failed;
4082 
4083   GST_OBJECT_LOCK (pad);
4084   PROBE_PUSH (pad, type | GST_PAD_PROBE_TYPE_PULL, query, probe_stopped);
4085   GST_OBJECT_UNLOCK (pad);
4086 
4087   if (G_UNLIKELY (serialized))
4088     GST_PAD_STREAM_UNLOCK (pad);
4089 
4090   return res;
4091 
4092   /* ERRORS */
4093 wrong_direction:
4094   {
4095     g_warning (&quot;pad %s:%s query %s in wrong direction&quot;,
4096         GST_DEBUG_PAD_NAME (pad), GST_QUERY_TYPE_NAME (query));
4097     return FALSE;
4098   }
4099 unknown_direction:
4100   {
4101     g_warning (&quot;pad %s:%s has invalid direction&quot;, GST_DEBUG_PAD_NAME (pad));
4102     return FALSE;
4103   }
4104 no_parent:
4105   {
4106     GST_DEBUG_OBJECT (pad, &quot;had no parent&quot;);
4107     GST_OBJECT_UNLOCK (pad);
4108     if (G_UNLIKELY (serialized))
4109       GST_PAD_STREAM_UNLOCK (pad);
4110     return FALSE;
4111   }
4112 no_func:
4113   {
4114     GST_DEBUG_OBJECT (pad, &quot;had no query function&quot;);
4115     RELEASE_PARENT (parent);
4116     if (G_UNLIKELY (serialized))
4117       GST_PAD_STREAM_UNLOCK (pad);
4118     return FALSE;
4119   }
4120 query_failed:
4121   {
4122     GST_DEBUG_OBJECT (pad, &quot;query failed&quot;);
4123     if (G_UNLIKELY (serialized))
4124       GST_PAD_STREAM_UNLOCK (pad);
4125     return FALSE;
4126   }
4127 probe_stopped:
4128   {
4129     GST_DEBUG_OBJECT (pad, &quot;probe stopped: %s&quot;, gst_flow_get_name (ret));
4130     GST_OBJECT_UNLOCK (pad);
4131     if (G_UNLIKELY (serialized))
4132       GST_PAD_STREAM_UNLOCK (pad);
4133 
4134     /* if a probe dropped without handling, we don&#39;t sent it further but assume
4135      * that the probe did not answer the query and return FALSE */
4136     if (ret != GST_FLOW_CUSTOM_SUCCESS_1)
4137       res = FALSE;
4138     else
4139       res = TRUE;
4140 
4141     return res;
4142   }
4143 }
4144 
4145 /**
4146  * gst_pad_peer_query:
4147  * @pad: a #GstPad to invoke the peer query on.
4148  * @query: (transfer none): the #GstQuery to perform.
4149  *
4150  * Performs gst_pad_query() on the peer of @pad.
4151  *
4152  * The caller is responsible for both the allocation and deallocation of
4153  * the query structure.
4154  *
4155  * Returns: %TRUE if the query could be performed. This function returns %FALSE
4156  * if @pad has no peer.
4157  */
4158 gboolean
4159 gst_pad_peer_query (GstPad * pad, GstQuery * query)
4160 {
4161   GstPad *peerpad;
4162   GstPadProbeType type;
4163   gboolean res, serialized;
4164   GstFlowReturn ret;
4165 
4166   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
4167   g_return_val_if_fail (GST_IS_QUERY (query), FALSE);
4168 
4169   if (GST_PAD_IS_SRC (pad)) {
4170     if (G_UNLIKELY (!GST_QUERY_IS_DOWNSTREAM (query)))
4171       goto wrong_direction;
4172     type = GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM;
4173   } else if (GST_PAD_IS_SINK (pad)) {
4174     if (G_UNLIKELY (!GST_QUERY_IS_UPSTREAM (query)))
4175       goto wrong_direction;
4176     type = GST_PAD_PROBE_TYPE_QUERY_UPSTREAM;
4177   } else
4178     goto unknown_direction;
4179 
4180   GST_DEBUG_OBJECT (pad, &quot;peer query %p (%s)&quot;, query,
4181       GST_QUERY_TYPE_NAME (query));
4182 
4183   serialized = GST_QUERY_IS_SERIALIZED (query);
4184 
4185   GST_OBJECT_LOCK (pad);
4186   if (GST_PAD_IS_SRC (pad) &amp;&amp; serialized) {
4187     /* all serialized queries on the srcpad trigger push of
4188      * sticky events */
4189     if (check_sticky (pad, NULL) != GST_FLOW_OK)
4190       goto sticky_failed;
4191   }
4192 
4193   PROBE_PUSH (pad, type | GST_PAD_PROBE_TYPE_PUSH |
4194       GST_PAD_PROBE_TYPE_BLOCK, query, probe_stopped);
4195   PROBE_PUSH (pad, type | GST_PAD_PROBE_TYPE_PUSH, query, probe_stopped);
4196 
4197   peerpad = GST_PAD_PEER (pad);
4198   if (G_UNLIKELY (peerpad == NULL))
4199     goto no_peer;
4200 
4201   gst_object_ref (peerpad);
4202   GST_OBJECT_UNLOCK (pad);
4203 
4204   res = gst_pad_query (peerpad, query);
4205 
4206   gst_object_unref (peerpad);
4207 
4208   if (res != TRUE)
4209     goto query_failed;
4210 
4211   GST_OBJECT_LOCK (pad);
4212   PROBE_PUSH (pad, type | GST_PAD_PROBE_TYPE_PULL, query, probe_stopped);
4213   GST_OBJECT_UNLOCK (pad);
4214 
4215   return res;
4216 
4217   /* ERRORS */
4218 wrong_direction:
4219   {
4220     g_warning (&quot;pad %s:%s query %s in wrong direction&quot;,
4221         GST_DEBUG_PAD_NAME (pad), GST_QUERY_TYPE_NAME (query));
4222     return FALSE;
4223   }
4224 unknown_direction:
4225   {
4226     g_warning (&quot;pad %s:%s has invalid direction&quot;, GST_DEBUG_PAD_NAME (pad));
4227     return FALSE;
4228   }
4229 sticky_failed:
4230   {
4231     GST_WARNING_OBJECT (pad, &quot;could not send sticky events&quot;);
4232     GST_OBJECT_UNLOCK (pad);
4233     return FALSE;
4234   }
4235 no_peer:
4236   {
4237     GST_INFO_OBJECT (pad, &quot;pad has no peer&quot;);
4238     GST_OBJECT_UNLOCK (pad);
4239     return FALSE;
4240   }
4241 query_failed:
4242   {
4243     GST_DEBUG_OBJECT (pad, &quot;query failed&quot;);
4244     return FALSE;
4245   }
4246 probe_stopped:
4247   {
4248     GST_DEBUG_OBJECT (pad, &quot;probe stopped: %s&quot;, gst_flow_get_name (ret));
4249     GST_OBJECT_UNLOCK (pad);
4250 
4251     /* if a probe dropped without handling, we don&#39;t sent it further but
4252      * assume that the probe did not answer the query and return FALSE */
4253     if (ret != GST_FLOW_CUSTOM_SUCCESS_1)
4254       res = FALSE;
4255     else
4256       res = TRUE;
4257 
4258     return res;
4259   }
4260 }
4261 
4262 /**********************************************************************
4263  * Data passing functions
4264  */
4265 
4266 /* this is the chain function that does not perform the additional argument
4267  * checking for that little extra speed.
4268  */
4269 static inline GstFlowReturn
4270 gst_pad_chain_data_unchecked (GstPad * pad, GstPadProbeType type, void *data)
4271 {
4272   GstFlowReturn ret;
4273   GstObject *parent;
4274   gboolean handled = FALSE;
4275 
4276   GST_PAD_STREAM_LOCK (pad);
4277 
4278   GST_OBJECT_LOCK (pad);
4279   if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
4280     goto flushing;
4281 
4282   if (G_UNLIKELY (GST_PAD_IS_EOS (pad)))
4283     goto eos;
4284 
4285   if (G_UNLIKELY (GST_PAD_MODE (pad) != GST_PAD_MODE_PUSH))
4286     goto wrong_mode;
4287 
4288 #ifdef GST_ENABLE_EXTRA_CHECKS
4289   if (G_UNLIKELY (pad-&gt;priv-&gt;last_cookie != pad-&gt;priv-&gt;events_cookie)) {
4290     if (!find_event_by_type (pad, GST_EVENT_STREAM_START, 0)) {
4291       g_warning (G_STRLOC
4292           &quot;:%s:&lt;%s:%s&gt; Got data flow before stream-start event&quot;,
4293           G_STRFUNC, GST_DEBUG_PAD_NAME (pad));
4294     }
4295     if (!find_event_by_type (pad, GST_EVENT_SEGMENT, 0)) {
4296       g_warning (G_STRLOC
4297           &quot;:%s:&lt;%s:%s&gt; Got data flow before segment event&quot;,
4298           G_STRFUNC, GST_DEBUG_PAD_NAME (pad));
4299     }
4300     pad-&gt;priv-&gt;last_cookie = pad-&gt;priv-&gt;events_cookie;
4301   }
4302 #endif
4303 
4304   PROBE_HANDLE (pad, type | GST_PAD_PROBE_TYPE_BLOCK, data, probe_stopped,
4305       probe_handled);
4306 
4307   PROBE_HANDLE (pad, type, data, probe_stopped, probe_handled);
4308 
4309   ACQUIRE_PARENT (pad, parent, no_parent);
4310   GST_OBJECT_UNLOCK (pad);
4311 
4312   /* NOTE: we read the chainfunc unlocked.
4313    * we cannot hold the lock for the pad so we might send
4314    * the data to the wrong function. This is not really a
4315    * problem since functions are assigned at creation time
4316    * and don&#39;t change that often... */
4317   if (G_LIKELY (type &amp; GST_PAD_PROBE_TYPE_BUFFER)) {
4318     GstPadChainFunction chainfunc;
4319 
4320     if (G_UNLIKELY ((chainfunc = GST_PAD_CHAINFUNC (pad)) == NULL))
4321       goto no_function;
4322 
4323     GST_CAT_DEBUG_OBJECT (GST_CAT_SCHEDULING, pad,
4324         &quot;calling chainfunction &amp;%s with buffer %&quot; GST_PTR_FORMAT,
4325         GST_DEBUG_FUNCPTR_NAME (chainfunc), GST_BUFFER (data));
4326 
4327     ret = chainfunc (pad, parent, GST_BUFFER_CAST (data));
4328 
4329     GST_CAT_DEBUG_OBJECT (GST_CAT_SCHEDULING, pad,
4330         &quot;called chainfunction &amp;%s with buffer %p, returned %s&quot;,
4331         GST_DEBUG_FUNCPTR_NAME (chainfunc), data, gst_flow_get_name (ret));
4332   } else {
4333     GstPadChainListFunction chainlistfunc;
4334 
4335     if (G_UNLIKELY ((chainlistfunc = GST_PAD_CHAINLISTFUNC (pad)) == NULL))
4336       goto no_function;
4337 
4338     GST_CAT_DEBUG_OBJECT (GST_CAT_SCHEDULING, pad,
4339         &quot;calling chainlistfunction &amp;%s&quot;,
4340         GST_DEBUG_FUNCPTR_NAME (chainlistfunc));
4341 
4342     ret = chainlistfunc (pad, parent, GST_BUFFER_LIST_CAST (data));
4343 
4344     GST_CAT_DEBUG_OBJECT (GST_CAT_SCHEDULING, pad,
4345         &quot;called chainlistfunction &amp;%s, returned %s&quot;,
4346         GST_DEBUG_FUNCPTR_NAME (chainlistfunc), gst_flow_get_name (ret));
4347   }
4348 
4349   RELEASE_PARENT (parent);
4350 
4351   GST_PAD_STREAM_UNLOCK (pad);
4352 
4353   return ret;
4354 
4355   /* ERRORS */
4356 flushing:
4357   {
4358     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4359         &quot;chaining, but pad was flushing&quot;);
4360     GST_OBJECT_UNLOCK (pad);
4361     GST_PAD_STREAM_UNLOCK (pad);
4362     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4363     return GST_FLOW_FLUSHING;
4364   }
4365 eos:
4366   {
4367     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;chaining, but pad was EOS&quot;);
4368     GST_OBJECT_UNLOCK (pad);
4369     GST_PAD_STREAM_UNLOCK (pad);
4370     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4371     return GST_FLOW_EOS;
4372   }
4373 wrong_mode:
4374   {
4375     g_critical (&quot;chain on pad %s:%s but it was not in push mode&quot;,
4376         GST_DEBUG_PAD_NAME (pad));
4377     GST_OBJECT_UNLOCK (pad);
4378     GST_PAD_STREAM_UNLOCK (pad);
4379     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4380     return GST_FLOW_ERROR;
4381   }
4382 probe_handled:
4383   handled = TRUE;
4384   /* PASSTHROUGH */
4385 probe_stopped:
4386   {
4387     GST_OBJECT_UNLOCK (pad);
4388     GST_PAD_STREAM_UNLOCK (pad);
4389     /* We unref the buffer, except if the probe handled it (CUSTOM_SUCCESS_1) */
4390     if (!handled)
4391       gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4392 
4393     switch (ret) {
4394       case GST_FLOW_CUSTOM_SUCCESS:
4395       case GST_FLOW_CUSTOM_SUCCESS_1:
4396         GST_DEBUG_OBJECT (pad, &quot;dropped or handled buffer&quot;);
4397         ret = GST_FLOW_OK;
4398         break;
4399       default:
4400         GST_DEBUG_OBJECT (pad, &quot;an error occurred %s&quot;, gst_flow_get_name (ret));
4401         break;
4402     }
4403     return ret;
4404   }
4405 no_parent:
4406   {
4407     GST_DEBUG_OBJECT (pad, &quot;No parent when chaining %&quot; GST_PTR_FORMAT, data);
4408     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4409     GST_OBJECT_UNLOCK (pad);
4410     GST_PAD_STREAM_UNLOCK (pad);
4411     return GST_FLOW_FLUSHING;
4412   }
4413 no_function:
4414   {
4415     RELEASE_PARENT (parent);
4416     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4417     g_critical (&quot;chain on pad %s:%s but it has no chainfunction&quot;,
4418         GST_DEBUG_PAD_NAME (pad));
4419     GST_PAD_STREAM_UNLOCK (pad);
4420     return GST_FLOW_NOT_SUPPORTED;
4421   }
4422 }
4423 
4424 /**
4425  * gst_pad_chain:
4426  * @pad: a sink #GstPad, returns GST_FLOW_ERROR if not.
4427  * @buffer: (transfer full): the #GstBuffer to send, return GST_FLOW_ERROR
4428  *     if not.
4429  *
4430  * Chain a buffer to @pad.
4431  *
4432  * The function returns #GST_FLOW_FLUSHING if the pad was flushing.
4433  *
4434  * If the buffer type is not acceptable for @pad (as negotiated with a
4435  * preceding GST_EVENT_CAPS event), this function returns
4436  * #GST_FLOW_NOT_NEGOTIATED.
4437  *
4438  * The function proceeds calling the chain function installed on @pad (see
4439  * gst_pad_set_chain_function()) and the return value of that function is
4440  * returned to the caller. #GST_FLOW_NOT_SUPPORTED is returned if @pad has no
4441  * chain function.
4442  *
4443  * In all cases, success or failure, the caller loses its reference to @buffer
4444  * after calling this function.
4445  *
4446  * Returns: a #GstFlowReturn from the pad.
4447  *
4448  * MT safe.
4449  */
4450 GstFlowReturn
4451 gst_pad_chain (GstPad * pad, GstBuffer * buffer)
4452 {
4453   g_return_val_if_fail (GST_IS_PAD (pad), GST_FLOW_ERROR);
4454   g_return_val_if_fail (GST_PAD_IS_SINK (pad), GST_FLOW_ERROR);
4455   g_return_val_if_fail (GST_IS_BUFFER (buffer), GST_FLOW_ERROR);
4456 
4457   return gst_pad_chain_data_unchecked (pad,
4458       GST_PAD_PROBE_TYPE_BUFFER | GST_PAD_PROBE_TYPE_PUSH, buffer);
4459 }
4460 
4461 static GstFlowReturn
4462 gst_pad_chain_list_default (GstPad * pad, GstObject * parent,
4463     GstBufferList * list)
4464 {
4465   guint i, len;
4466   GstBuffer *buffer;
4467   GstFlowReturn ret;
4468 
4469   GST_INFO_OBJECT (pad, &quot;chaining each buffer in list individually&quot;);
4470 
4471   len = gst_buffer_list_length (list);
4472 
4473   ret = GST_FLOW_OK;
4474   for (i = 0; i &lt; len; i++) {
4475     buffer = gst_buffer_list_get (list, i);
4476     ret =
4477         gst_pad_chain_data_unchecked (pad,
4478         GST_PAD_PROBE_TYPE_BUFFER | GST_PAD_PROBE_TYPE_PUSH,
4479         gst_buffer_ref (buffer));
4480     if (ret != GST_FLOW_OK)
4481       break;
4482   }
4483   gst_buffer_list_unref (list);
4484 
4485   return ret;
4486 }
4487 
4488 /**
4489  * gst_pad_chain_list:
4490  * @pad: a sink #GstPad, returns GST_FLOW_ERROR if not.
4491  * @list: (transfer full): the #GstBufferList to send, return GST_FLOW_ERROR
4492  *     if not.
4493  *
4494  * Chain a bufferlist to @pad.
4495  *
4496  * The function returns #GST_FLOW_FLUSHING if the pad was flushing.
4497  *
4498  * If @pad was not negotiated properly with a CAPS event, this function
4499  * returns #GST_FLOW_NOT_NEGOTIATED.
4500  *
4501  * The function proceeds calling the chainlist function installed on @pad (see
4502  * gst_pad_set_chain_list_function()) and the return value of that function is
4503  * returned to the caller. #GST_FLOW_NOT_SUPPORTED is returned if @pad has no
4504  * chainlist function.
4505  *
4506  * In all cases, success or failure, the caller loses its reference to @list
4507  * after calling this function.
4508  *
4509  * MT safe.
4510  *
4511  * Returns: a #GstFlowReturn from the pad.
4512  */
4513 GstFlowReturn
4514 gst_pad_chain_list (GstPad * pad, GstBufferList * list)
4515 {
4516   g_return_val_if_fail (GST_IS_PAD (pad), GST_FLOW_ERROR);
4517   g_return_val_if_fail (GST_PAD_IS_SINK (pad), GST_FLOW_ERROR);
4518   g_return_val_if_fail (GST_IS_BUFFER_LIST (list), GST_FLOW_ERROR);
4519 
4520   return gst_pad_chain_data_unchecked (pad,
4521       GST_PAD_PROBE_TYPE_BUFFER_LIST | GST_PAD_PROBE_TYPE_PUSH, list);
4522 }
4523 
4524 static GstFlowReturn
4525 gst_pad_push_data (GstPad * pad, GstPadProbeType type, void *data)
4526 {
4527   GstPad *peer;
4528   GstFlowReturn ret;
4529   gboolean handled = FALSE;
4530 
4531   GST_OBJECT_LOCK (pad);
4532   if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
4533     goto flushing;
4534 
4535   if (G_UNLIKELY (GST_PAD_IS_EOS (pad)))
4536     goto eos;
4537 
4538   if (G_UNLIKELY (GST_PAD_MODE (pad) != GST_PAD_MODE_PUSH))
4539     goto wrong_mode;
4540 
4541 #ifdef GST_ENABLE_EXTRA_CHECKS
4542   if (G_UNLIKELY (pad-&gt;priv-&gt;last_cookie != pad-&gt;priv-&gt;events_cookie)) {
4543     if (!find_event_by_type (pad, GST_EVENT_STREAM_START, 0)) {
4544       g_warning (G_STRLOC
4545           &quot;:%s:&lt;%s:%s&gt; Got data flow before stream-start event&quot;,
4546           G_STRFUNC, GST_DEBUG_PAD_NAME (pad));
4547     }
4548     if (!find_event_by_type (pad, GST_EVENT_SEGMENT, 0)) {
4549       g_warning (G_STRLOC
4550           &quot;:%s:&lt;%s:%s&gt; Got data flow before segment event&quot;,
4551           G_STRFUNC, GST_DEBUG_PAD_NAME (pad));
4552     }
4553     pad-&gt;priv-&gt;last_cookie = pad-&gt;priv-&gt;events_cookie;
4554   }
4555 #endif
4556 
4557   if (G_UNLIKELY ((ret = check_sticky (pad, NULL))) != GST_FLOW_OK)
4558     goto events_error;
4559 
4560   /* do block probes */
4561   PROBE_HANDLE (pad, type | GST_PAD_PROBE_TYPE_BLOCK, data, probe_stopped,
4562       probe_handled);
4563 
4564   /* recheck sticky events because the probe might have cause a relink */
4565   if (G_UNLIKELY ((ret = check_sticky (pad, NULL))) != GST_FLOW_OK)
4566     goto events_error;
4567 
4568   /* do post-blocking probes */
4569   PROBE_HANDLE (pad, type, data, probe_stopped, probe_handled);
4570 
4571   /* recheck sticky events because the probe might have cause a relink */
4572   if (G_UNLIKELY ((ret = check_sticky (pad, NULL))) != GST_FLOW_OK)
4573     goto events_error;
4574 
4575   if (G_UNLIKELY ((peer = GST_PAD_PEER (pad)) == NULL))
4576     goto not_linked;
4577 
4578   /* take ref to peer pad before releasing the lock */
4579   gst_object_ref (peer);
4580   pad-&gt;priv-&gt;using++;
4581   GST_OBJECT_UNLOCK (pad);
4582 
4583   ret = gst_pad_chain_data_unchecked (peer, type, data);
4584   data = NULL;
4585 
4586   gst_object_unref (peer);
4587 
4588   GST_OBJECT_LOCK (pad);
4589   pad-&gt;ABI.abi.last_flowret = ret;
4590   pad-&gt;priv-&gt;using--;
4591   if (pad-&gt;priv-&gt;using == 0) {
4592     /* pad is not active anymore, trigger idle callbacks */
4593     PROBE_NO_DATA (pad, GST_PAD_PROBE_TYPE_PUSH | GST_PAD_PROBE_TYPE_IDLE,
4594         probe_stopped, ret);
4595   }
4596   GST_OBJECT_UNLOCK (pad);
4597 
4598   return ret;
4599 
4600   /* ERROR recovery here */
4601   /* ERRORS */
4602 flushing:
4603   {
4604     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4605         &quot;pushing, but pad was flushing&quot;);
4606     pad-&gt;ABI.abi.last_flowret = GST_FLOW_FLUSHING;
4607     GST_OBJECT_UNLOCK (pad);
4608     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4609     return GST_FLOW_FLUSHING;
4610   }
4611 eos:
4612   {
4613     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;pushing, but pad was EOS&quot;);
4614     pad-&gt;ABI.abi.last_flowret = GST_FLOW_EOS;
4615     GST_OBJECT_UNLOCK (pad);
4616     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4617     return GST_FLOW_EOS;
4618   }
4619 wrong_mode:
4620   {
4621     g_critical (&quot;pushing on pad %s:%s but it was not activated in push mode&quot;,
4622         GST_DEBUG_PAD_NAME (pad));
4623     pad-&gt;ABI.abi.last_flowret = GST_FLOW_ERROR;
4624     GST_OBJECT_UNLOCK (pad);
4625     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4626     return GST_FLOW_ERROR;
4627   }
4628 events_error:
4629   {
4630     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4631         &quot;error pushing events, return %s&quot;, gst_flow_get_name (ret));
4632     pad-&gt;ABI.abi.last_flowret = ret;
4633     GST_OBJECT_UNLOCK (pad);
4634     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4635     return ret;
4636   }
4637 probe_handled:
4638   handled = TRUE;
4639   /* PASSTHROUGH */
4640 probe_stopped:
4641   {
4642     GST_OBJECT_UNLOCK (pad);
4643     if (data != NULL &amp;&amp; !handled)
4644       gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4645 
4646     switch (ret) {
4647       case GST_FLOW_CUSTOM_SUCCESS:
4648       case GST_FLOW_CUSTOM_SUCCESS_1:
4649         GST_DEBUG_OBJECT (pad, &quot;dropped or handled buffer&quot;);
4650         ret = GST_FLOW_OK;
4651         break;
4652       default:
4653         GST_DEBUG_OBJECT (pad, &quot;an error occurred %s&quot;, gst_flow_get_name (ret));
4654         break;
4655     }
4656     pad-&gt;ABI.abi.last_flowret = ret;
4657     return ret;
4658   }
4659 not_linked:
4660   {
4661     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4662         &quot;pushing, but it was not linked&quot;);
4663     pad-&gt;ABI.abi.last_flowret = GST_FLOW_NOT_LINKED;
4664     GST_OBJECT_UNLOCK (pad);
4665     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4666     return GST_FLOW_NOT_LINKED;
4667   }
4668 }
4669 
4670 /**
4671  * gst_pad_push:
4672  * @pad: a source #GstPad, returns #GST_FLOW_ERROR if not.
4673  * @buffer: (transfer full): the #GstBuffer to push returns GST_FLOW_ERROR
4674  *     if not.
4675  *
4676  * Pushes a buffer to the peer of @pad.
4677  *
4678  * This function will call installed block probes before triggering any
4679  * installed data probes.
4680  *
4681  * The function proceeds calling gst_pad_chain() on the peer pad and returns
4682  * the value from that function. If @pad has no peer, #GST_FLOW_NOT_LINKED will
4683  * be returned.
4684  *
4685  * In all cases, success or failure, the caller loses its reference to @buffer
4686  * after calling this function.
4687  *
4688  * Returns: a #GstFlowReturn from the peer pad.
4689  *
4690  * MT safe.
4691  */
4692 GstFlowReturn
4693 gst_pad_push (GstPad * pad, GstBuffer * buffer)
4694 {
4695   GstFlowReturn res;
4696 
4697   g_return_val_if_fail (GST_IS_PAD (pad), GST_FLOW_ERROR);
4698   g_return_val_if_fail (GST_PAD_IS_SRC (pad), GST_FLOW_ERROR);
4699   g_return_val_if_fail (GST_IS_BUFFER (buffer), GST_FLOW_ERROR);
4700 
4701   GST_TRACER_PAD_PUSH_PRE (pad, buffer);
4702   res = gst_pad_push_data (pad,
4703       GST_PAD_PROBE_TYPE_BUFFER | GST_PAD_PROBE_TYPE_PUSH, buffer);
4704   GST_TRACER_PAD_PUSH_POST (pad, res);
4705   return res;
4706 }
4707 
4708 /**
4709  * gst_pad_push_list:
4710  * @pad: a source #GstPad, returns #GST_FLOW_ERROR if not.
4711  * @list: (transfer full): the #GstBufferList to push returns GST_FLOW_ERROR
4712  *     if not.
4713  *
4714  * Pushes a buffer list to the peer of @pad.
4715  *
4716  * This function will call installed block probes before triggering any
4717  * installed data probes.
4718  *
4719  * The function proceeds calling the chain function on the peer pad and returns
4720  * the value from that function. If @pad has no peer, #GST_FLOW_NOT_LINKED will
4721  * be returned. If the peer pad does not have any installed chainlist function
4722  * every group buffer of the list will be merged into a normal #GstBuffer and
4723  * chained via gst_pad_chain().
4724  *
4725  * In all cases, success or failure, the caller loses its reference to @list
4726  * after calling this function.
4727  *
4728  * Returns: a #GstFlowReturn from the peer pad.
4729  *
4730  * MT safe.
4731  */
4732 GstFlowReturn
4733 gst_pad_push_list (GstPad * pad, GstBufferList * list)
4734 {
4735   GstFlowReturn res;
4736 
4737   g_return_val_if_fail (GST_IS_PAD (pad), GST_FLOW_ERROR);
4738   g_return_val_if_fail (GST_PAD_IS_SRC (pad), GST_FLOW_ERROR);
4739   g_return_val_if_fail (GST_IS_BUFFER_LIST (list), GST_FLOW_ERROR);
4740 
4741   GST_TRACER_PAD_PUSH_LIST_PRE (pad, list);
4742   res = gst_pad_push_data (pad,
4743       GST_PAD_PROBE_TYPE_BUFFER_LIST | GST_PAD_PROBE_TYPE_PUSH, list);
4744   GST_TRACER_PAD_PUSH_LIST_POST (pad, res);
4745   return res;
4746 }
4747 
4748 static GstFlowReturn
4749 gst_pad_get_range_unchecked (GstPad * pad, guint64 offset, guint size,
4750     GstBuffer ** buffer)
4751 {
4752   GstFlowReturn ret;
4753   GstPadGetRangeFunction getrangefunc;
4754   GstObject *parent;
4755   GstBuffer *res_buf;
4756 
4757   GST_PAD_STREAM_LOCK (pad);
4758 
4759   GST_OBJECT_LOCK (pad);
4760   if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
4761     goto flushing;
4762 
4763   if (G_UNLIKELY (GST_PAD_MODE (pad) != GST_PAD_MODE_PULL))
4764     goto wrong_mode;
4765 
4766   if (G_UNLIKELY ((ret = check_sticky (pad, NULL))) != GST_FLOW_OK)
4767     goto events_error;
4768 
4769   res_buf = *buffer;
4770 
4771   /* when one of the probes returns DROPPED, probe_stopped will be called
4772    * and we skip calling the getrange function, res_buf should then contain a
4773    * valid result buffer */
4774   PROBE_PULL (pad, GST_PAD_PROBE_TYPE_PULL | GST_PAD_PROBE_TYPE_BLOCK,
4775       res_buf, offset, size, probe_stopped);
4776 
4777   /* recheck sticky events because the probe might have cause a relink */
4778   if (G_UNLIKELY ((ret = check_sticky (pad, NULL))) != GST_FLOW_OK)
4779     goto events_error;
4780 
4781   ACQUIRE_PARENT (pad, parent, no_parent);
4782   GST_OBJECT_UNLOCK (pad);
4783 
4784   if (G_UNLIKELY ((getrangefunc = GST_PAD_GETRANGEFUNC (pad)) == NULL))
4785     goto no_function;
4786 
4787   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4788       &quot;calling getrangefunc %s, offset %&quot;
4789       G_GUINT64_FORMAT &quot;, size %u&quot;,
4790       GST_DEBUG_FUNCPTR_NAME (getrangefunc), offset, size);
4791 
4792   ret = getrangefunc (pad, parent, offset, size, &amp;res_buf);
4793 
4794   RELEASE_PARENT (parent);
4795 
4796   GST_OBJECT_LOCK (pad);
4797   if (G_UNLIKELY (ret != GST_FLOW_OK))
4798     goto get_range_failed;
4799 
4800   /* can only fire the signal if we have a valid buffer */
4801 probed_data:
4802   PROBE_PULL (pad, GST_PAD_PROBE_TYPE_PULL | GST_PAD_PROBE_TYPE_BUFFER,
4803       res_buf, offset, size, probe_stopped_unref);
4804   pad-&gt;ABI.abi.last_flowret = ret;
4805   GST_OBJECT_UNLOCK (pad);
4806 
4807   GST_PAD_STREAM_UNLOCK (pad);
4808 
4809   *buffer = res_buf;
4810 
4811   return ret;
4812 
4813   /* ERRORS */
4814 flushing:
4815   {
4816     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4817         &quot;getrange, but pad was flushing&quot;);
4818     pad-&gt;ABI.abi.last_flowret = GST_FLOW_FLUSHING;
4819     GST_OBJECT_UNLOCK (pad);
4820     GST_PAD_STREAM_UNLOCK (pad);
4821     return GST_FLOW_FLUSHING;
4822   }
4823 wrong_mode:
4824   {
4825     g_critical (&quot;getrange on pad %s:%s but it was not activated in pull mode&quot;,
4826         GST_DEBUG_PAD_NAME (pad));
4827     pad-&gt;ABI.abi.last_flowret = GST_FLOW_ERROR;
4828     GST_OBJECT_UNLOCK (pad);
4829     GST_PAD_STREAM_UNLOCK (pad);
4830     return GST_FLOW_ERROR;
4831   }
4832 events_error:
4833   {
4834     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;error pushing events&quot;);
4835     pad-&gt;ABI.abi.last_flowret = ret;
4836     GST_OBJECT_UNLOCK (pad);
4837     GST_PAD_STREAM_UNLOCK (pad);
4838     return ret;
4839   }
4840 no_parent:
4841   {
4842     GST_DEBUG_OBJECT (pad, &quot;no parent&quot;);
4843     pad-&gt;ABI.abi.last_flowret = GST_FLOW_FLUSHING;
4844     GST_OBJECT_UNLOCK (pad);
4845     GST_PAD_STREAM_UNLOCK (pad);
4846     return GST_FLOW_FLUSHING;
4847   }
4848 no_function:
4849   {
4850     g_critical (&quot;getrange on pad %s:%s but it has no getrangefunction&quot;,
4851         GST_DEBUG_PAD_NAME (pad));
4852     RELEASE_PARENT (parent);
4853     GST_PAD_STREAM_UNLOCK (pad);
4854     return GST_FLOW_NOT_SUPPORTED;
4855   }
4856 probe_stopped:
4857   {
4858     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4859         &quot;probe returned %s&quot;, gst_flow_get_name (ret));
4860     if (ret == GST_FLOW_CUSTOM_SUCCESS) {
4861       if (res_buf) {
4862         /* the probe filled the buffer and asks us to not call the getrange
4863          * anymore, we continue with the post probes then. */
4864         GST_DEBUG_OBJECT (pad, &quot;handled buffer&quot;);
4865         ret = GST_FLOW_OK;
4866         goto probed_data;
4867       } else {
4868         /* no buffer, we are EOS */
4869         GST_DEBUG_OBJECT (pad, &quot;no buffer, return EOS&quot;);
4870         ret = GST_FLOW_EOS;
4871       }
4872     }
4873     pad-&gt;ABI.abi.last_flowret = ret;
4874     GST_OBJECT_UNLOCK (pad);
4875     GST_PAD_STREAM_UNLOCK (pad);
4876 
4877     return ret;
4878   }
4879 probe_stopped_unref:
4880   {
4881     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4882         &quot;probe returned %s&quot;, gst_flow_get_name (ret));
4883     /* if we drop here, it signals EOS */
4884     if (ret == GST_FLOW_CUSTOM_SUCCESS)
4885       ret = GST_FLOW_EOS;
4886     pad-&gt;ABI.abi.last_flowret = ret;
4887     GST_OBJECT_UNLOCK (pad);
4888     GST_PAD_STREAM_UNLOCK (pad);
4889     if (*buffer == NULL)
4890       gst_buffer_unref (res_buf);
4891     return ret;
4892   }
4893 get_range_failed:
4894   {
4895     pad-&gt;ABI.abi.last_flowret = ret;
4896     GST_OBJECT_UNLOCK (pad);
4897     GST_PAD_STREAM_UNLOCK (pad);
4898     GST_CAT_LEVEL_LOG (GST_CAT_SCHEDULING,
4899         (ret &gt;= GST_FLOW_EOS) ? GST_LEVEL_INFO : GST_LEVEL_WARNING,
4900         pad, &quot;getrange failed, flow: %s&quot;, gst_flow_get_name (ret));
4901     return ret;
4902   }
4903 }
4904 
4905 /**
4906  * gst_pad_get_range:
4907  * @pad: a src #GstPad, returns #GST_FLOW_ERROR if not.
4908  * @offset: The start offset of the buffer
4909  * @size: The length of the buffer
4910  * @buffer: (out callee-allocates): a pointer to hold the #GstBuffer,
4911  *     returns #GST_FLOW_ERROR if %NULL.
4912  *
4913  * When @pad is flushing this function returns #GST_FLOW_FLUSHING
4914  * immediately and @buffer is %NULL.
4915  *
4916  * Calls the getrange function of @pad, see #GstPadGetRangeFunction for a
4917  * description of a getrange function. If @pad has no getrange function
4918  * installed (see gst_pad_set_getrange_function()) this function returns
4919  * #GST_FLOW_NOT_SUPPORTED.
4920  *
4921  * If @buffer points to a variable holding %NULL, a valid new #GstBuffer will be
4922  * placed in @buffer when this function returns #GST_FLOW_OK. The new buffer
4923  * must be freed with gst_buffer_unref() after usage.
4924  *
4925  * When @buffer points to a variable that points to a valid #GstBuffer, the
4926  * buffer will be filled with the result data when this function returns
4927  * #GST_FLOW_OK. If the provided buffer is larger than @size, only
4928  * @size bytes will be filled in the result buffer and its size will be updated
4929  * accordingly.
4930  *
4931  * Note that less than @size bytes can be returned in @buffer when, for example,
4932  * an EOS condition is near or when @buffer is not large enough to hold @size
4933  * bytes. The caller should check the result buffer size to get the result size.
4934  *
4935  * When this function returns any other result value than #GST_FLOW_OK, @buffer
4936  * will be unchanged.
4937  *
4938  * This is a lowlevel function. Usually gst_pad_pull_range() is used.
4939  *
4940  * Returns: a #GstFlowReturn from the pad.
4941  *
4942  * MT safe.
4943  */
4944 GstFlowReturn
4945 gst_pad_get_range (GstPad * pad, guint64 offset, guint size,
4946     GstBuffer ** buffer)
4947 {
4948   g_return_val_if_fail (GST_IS_PAD (pad), GST_FLOW_ERROR);
4949   g_return_val_if_fail (GST_PAD_IS_SRC (pad), GST_FLOW_ERROR);
4950   g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
4951   g_return_val_if_fail (*buffer == NULL || (GST_IS_BUFFER (*buffer)
4952           &amp;&amp; gst_buffer_get_size (*buffer) &gt;= size), GST_FLOW_ERROR);
4953 
4954   return gst_pad_get_range_unchecked (pad, offset, size, buffer);
4955 }
4956 
4957 /**
4958  * gst_pad_pull_range:
4959  * @pad: a sink #GstPad, returns GST_FLOW_ERROR if not.
4960  * @offset: The start offset of the buffer
4961  * @size: The length of the buffer
4962  * @buffer: (out callee-allocates): a pointer to hold the #GstBuffer, returns
4963  *     GST_FLOW_ERROR if %NULL.
4964  *
4965  * Pulls a @buffer from the peer pad or fills up a provided buffer.
4966  *
4967  * This function will first trigger the pad block signal if it was
4968  * installed.
4969  *
4970  * When @pad is not linked #GST_FLOW_NOT_LINKED is returned else this
4971  * function returns the result of gst_pad_get_range() on the peer pad.
4972  * See gst_pad_get_range() for a list of return values and for the
4973  * semantics of the arguments of this function.
4974  *
4975  * If @buffer points to a variable holding %NULL, a valid new #GstBuffer will be
4976  * placed in @buffer when this function returns #GST_FLOW_OK. The new buffer
4977  * must be freed with gst_buffer_unref() after usage. When this function
4978  * returns any other result value, @buffer will still point to %NULL.
4979  *
4980  * When @buffer points to a variable that points to a valid #GstBuffer, the
4981  * buffer will be filled with the result data when this function returns
4982  * #GST_FLOW_OK. When this function returns any other result value,
4983  * @buffer will be unchanged. If the provided buffer is larger than @size, only
4984  * @size bytes will be filled in the result buffer and its size will be updated
4985  * accordingly.
4986  *
4987  * Note that less than @size bytes can be returned in @buffer when, for example,
4988  * an EOS condition is near or when @buffer is not large enough to hold @size
4989  * bytes. The caller should check the result buffer size to get the result size.
4990  *
4991  * Returns: a #GstFlowReturn from the peer pad.
4992  *
4993  * MT safe.
4994  */
4995 GstFlowReturn
4996 gst_pad_pull_range (GstPad * pad, guint64 offset, guint size,
4997     GstBuffer ** buffer)
4998 {
4999   GstPad *peer;
5000   GstFlowReturn ret;
5001   GstBuffer *res_buf;
5002 
5003   g_return_val_if_fail (GST_IS_PAD (pad), GST_FLOW_ERROR);
5004   g_return_val_if_fail (GST_PAD_IS_SINK (pad), GST_FLOW_ERROR);
5005   g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
5006   g_return_val_if_fail (*buffer == NULL || (GST_IS_BUFFER (*buffer)
5007           &amp;&amp; gst_buffer_get_size (*buffer) &gt;= size), GST_FLOW_ERROR);
5008 
5009   GST_TRACER_PAD_PULL_RANGE_PRE (pad, offset, size);
5010 
5011   GST_OBJECT_LOCK (pad);
5012   if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
5013     goto flushing;
5014 
5015   if (G_UNLIKELY (GST_PAD_MODE (pad) != GST_PAD_MODE_PULL))
5016     goto wrong_mode;
5017 
5018   res_buf = *buffer;
5019 
5020   /* when one of the probes returns DROPPED, probe_stopped will be
5021    * called and we skip calling the peer getrange function. *buffer should then
5022    * contain a valid buffer */
5023   PROBE_PULL (pad, GST_PAD_PROBE_TYPE_PULL | GST_PAD_PROBE_TYPE_BLOCK,
5024       res_buf, offset, size, probe_stopped);
5025 
5026   if (G_UNLIKELY ((peer = GST_PAD_PEER (pad)) == NULL))
5027     goto not_linked;
5028 
5029   gst_object_ref (peer);
5030   pad-&gt;priv-&gt;using++;
5031   GST_OBJECT_UNLOCK (pad);
5032 
5033   ret = gst_pad_get_range_unchecked (peer, offset, size, &amp;res_buf);
5034 
5035   gst_object_unref (peer);
5036 
5037   GST_OBJECT_LOCK (pad);
5038   pad-&gt;priv-&gt;using--;
5039   pad-&gt;ABI.abi.last_flowret = ret;
5040   if (pad-&gt;priv-&gt;using == 0) {
5041     /* pad is not active anymore, trigger idle callbacks */
5042     PROBE_NO_DATA (pad, GST_PAD_PROBE_TYPE_PULL | GST_PAD_PROBE_TYPE_IDLE,
5043         probe_stopped_unref, ret);
5044   }
5045 
5046   if (G_UNLIKELY (ret != GST_FLOW_OK))
5047     goto pull_range_failed;
5048 
5049 probed_data:
5050   PROBE_PULL (pad, GST_PAD_PROBE_TYPE_PULL | GST_PAD_PROBE_TYPE_BUFFER,
5051       res_buf, offset, size, probe_stopped_unref);
5052 
5053   GST_OBJECT_UNLOCK (pad);
5054 
5055   *buffer = res_buf;
5056 
5057   GST_TRACER_PAD_PULL_RANGE_POST (pad, *buffer, ret);
5058   return ret;
5059 
5060   /* ERROR recovery here */
5061 flushing:
5062   {
5063     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
5064         &quot;pullrange, but pad was flushing&quot;);
5065     pad-&gt;ABI.abi.last_flowret = GST_FLOW_FLUSHING;
5066     GST_OBJECT_UNLOCK (pad);
5067     ret = GST_FLOW_FLUSHING;
5068     goto done;
5069   }
5070 wrong_mode:
5071   {
5072     g_critical (&quot;pullrange on pad %s:%s but it was not activated in pull mode&quot;,
5073         GST_DEBUG_PAD_NAME (pad));
5074     pad-&gt;ABI.abi.last_flowret = GST_FLOW_ERROR;
5075     GST_OBJECT_UNLOCK (pad);
5076     ret = GST_FLOW_ERROR;
5077     goto done;
5078   }
5079 probe_stopped:
5080   {
5081     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;pre probe returned %s&quot;,
5082         gst_flow_get_name (ret));
5083     if (ret == GST_FLOW_CUSTOM_SUCCESS) {
5084       if (res_buf) {
5085         /* the probe filled the buffer and asks us to not forward to the peer
5086          * anymore, we continue with the post probes then */
5087         GST_DEBUG_OBJECT (pad, &quot;handled buffer&quot;);
5088         ret = GST_FLOW_OK;
5089         goto probed_data;
5090       } else {
5091         /* no buffer, we are EOS then */
5092         GST_DEBUG_OBJECT (pad, &quot;no buffer, return EOS&quot;);
5093         ret = GST_FLOW_EOS;
5094       }
5095     }
5096     pad-&gt;ABI.abi.last_flowret = ret;
5097     GST_OBJECT_UNLOCK (pad);
5098     goto done;
5099   }
5100 not_linked:
5101   {
5102     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
5103         &quot;pulling range, but it was not linked&quot;);
5104     pad-&gt;ABI.abi.last_flowret = GST_FLOW_NOT_LINKED;
5105     GST_OBJECT_UNLOCK (pad);
5106     ret = GST_FLOW_NOT_LINKED;
5107     goto done;
5108   }
5109 pull_range_failed:
5110   {
5111     pad-&gt;ABI.abi.last_flowret = ret;
5112     GST_OBJECT_UNLOCK (pad);
5113     GST_CAT_LEVEL_LOG (GST_CAT_SCHEDULING,
5114         (ret &gt;= GST_FLOW_EOS) ? GST_LEVEL_INFO : GST_LEVEL_WARNING,
5115         pad, &quot;pullrange failed, flow: %s&quot;, gst_flow_get_name (ret));
5116     goto done;
5117   }
5118 probe_stopped_unref:
5119   {
5120     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
5121         &quot;post probe returned %s&quot;, gst_flow_get_name (ret));
5122 
5123     /* if we drop here, it signals EOS */
5124     if (ret == GST_FLOW_CUSTOM_SUCCESS)
5125       ret = GST_FLOW_EOS;
5126 
5127     pad-&gt;ABI.abi.last_flowret = ret;
5128     GST_OBJECT_UNLOCK (pad);
5129 
5130     if (*buffer == NULL)
5131       gst_buffer_unref (res_buf);
5132     goto done;
5133   }
5134 done:
5135   GST_TRACER_PAD_PULL_RANGE_POST (pad, NULL, ret);
5136   return ret;
5137 }
5138 
5139 /* must be called with pad object lock */
5140 static GstFlowReturn
5141 store_sticky_event (GstPad * pad, GstEvent * event)
5142 {
5143   guint i, len;
5144   GstEventType type;
5145   GArray *events;
5146   gboolean res = FALSE;
5147   const gchar *name = NULL;
5148   gboolean insert = TRUE;
5149 
5150   type = GST_EVENT_TYPE (event);
5151 
5152   /* Store all sticky events except SEGMENT/EOS when we&#39;re flushing,
5153    * otherwise they can be dropped and nothing would ever resend them.
5154    * Only do that for activated pads though, everything else is a bug!
5155    */
5156   if (G_UNLIKELY (GST_PAD_MODE (pad) == GST_PAD_MODE_NONE
5157           || (GST_PAD_IS_FLUSHING (pad) &amp;&amp; (type == GST_EVENT_SEGMENT
5158                   || type == GST_EVENT_EOS))))
5159     goto flushed;
5160 
5161   /* Unset the EOS flag when received STREAM_START event, so pad can
5162    * store sticky event and then push it later */
5163   if (type == GST_EVENT_STREAM_START) {
5164     GST_LOG_OBJECT (pad, &quot;Removing pending EOS and StreamGroupDone events&quot;);
5165     remove_event_by_type (pad, GST_EVENT_EOS);
5166     remove_event_by_type (pad, GST_EVENT_STREAM_GROUP_DONE);
5167     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_EOS);
5168   }
5169 
5170   if (G_UNLIKELY (GST_PAD_IS_EOS (pad)))
5171     goto eos;
5172 
5173   if (type &amp; GST_EVENT_TYPE_STICKY_MULTI)
5174     name = gst_structure_get_name (gst_event_get_structure (event));
5175 
5176   events = pad-&gt;priv-&gt;events;
5177   len = events-&gt;len;
5178 
5179   for (i = 0; i &lt; len; i++) {
5180     PadEvent *ev = &amp;g_array_index (events, PadEvent, i);
5181 
5182     if (ev-&gt;event == NULL)
5183       continue;
5184 
5185     if (type == GST_EVENT_TYPE (ev-&gt;event)) {
5186       /* matching types, check matching name if needed */
5187       if (name &amp;&amp; !gst_event_has_name (ev-&gt;event, name))
5188         continue;
5189 
5190       /* overwrite */
5191       if ((res = gst_event_replace (&amp;ev-&gt;event, event)))
5192         ev-&gt;received = FALSE;
5193 
5194       insert = FALSE;
5195       break;
5196     }
5197 
5198     if (type &lt; GST_EVENT_TYPE (ev-&gt;event) || (type != GST_EVENT_TYPE (ev-&gt;event)
5199             &amp;&amp; GST_EVENT_TYPE (ev-&gt;event) == GST_EVENT_EOS)) {
5200       /* STREAM_START, CAPS and SEGMENT must be delivered in this order. By
5201        * storing the sticky ordered we can check that this is respected. */
5202       if (G_UNLIKELY (GST_EVENT_TYPE (ev-&gt;event) &lt;= GST_EVENT_SEGMENT
5203               || GST_EVENT_TYPE (ev-&gt;event) == GST_EVENT_EOS))
5204         g_warning (G_STRLOC
5205             &quot;:%s:&lt;%s:%s&gt; Sticky event misordering, got &#39;%s&#39; before &#39;%s&#39;&quot;,
5206             G_STRFUNC, GST_DEBUG_PAD_NAME (pad),
5207             gst_event_type_get_name (GST_EVENT_TYPE (ev-&gt;event)),
5208             gst_event_type_get_name (type));
5209       break;
5210     }
5211   }
5212   if (insert) {
5213     PadEvent ev;
5214     ev.event = gst_event_ref (event);
5215     ev.received = FALSE;
5216     g_array_insert_val (events, i, ev);
5217     res = TRUE;
5218   }
5219 
5220   if (res) {
5221     pad-&gt;priv-&gt;events_cookie++;
5222     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
5223 
5224     GST_LOG_OBJECT (pad, &quot;stored sticky event %s&quot;, GST_EVENT_TYPE_NAME (event));
5225 
5226     switch (GST_EVENT_TYPE (event)) {
5227       case GST_EVENT_CAPS:
5228         GST_OBJECT_UNLOCK (pad);
5229 
5230         GST_DEBUG_OBJECT (pad, &quot;notify caps&quot;);
5231         g_object_notify_by_pspec ((GObject *) pad, pspec_caps);
5232 
5233         GST_OBJECT_LOCK (pad);
5234         break;
5235       default:
5236         break;
5237     }
5238   }
5239   if (type == GST_EVENT_EOS) {
5240     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_EOS);
5241     pad-&gt;ABI.abi.last_flowret = GST_FLOW_EOS;
5242   }
5243 
5244   return GST_PAD_IS_FLUSHING (pad) ? GST_FLOW_FLUSHING : GST_FLOW_OK;
5245 
5246   /* ERRORS */
5247 flushed:
5248   {
5249     GST_DEBUG_OBJECT (pad, &quot;pad is flushing&quot;);
5250     return GST_FLOW_FLUSHING;
5251   }
5252 eos:
5253   {
5254     GST_DEBUG_OBJECT (pad, &quot;pad is EOS&quot;);
5255     return GST_FLOW_EOS;
5256   }
5257 }
5258 
5259 /**
5260  * gst_pad_store_sticky_event:
5261  * @pad: a #GstPad
5262  * @event: (transfer none): a #GstEvent
5263  *
5264  * Store the sticky @event on @pad
5265  *
5266  * Returns: #GST_FLOW_OK on success, #GST_FLOW_FLUSHING when the pad
5267  * was flushing or #GST_FLOW_EOS when the pad was EOS.
5268  *
5269  * Since: 1.2
5270  */
5271 GstFlowReturn
5272 gst_pad_store_sticky_event (GstPad * pad, GstEvent * event)
5273 {
5274   GstFlowReturn ret;
5275 
5276   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
5277   g_return_val_if_fail (GST_IS_EVENT (event), FALSE);
5278 
5279   GST_OBJECT_LOCK (pad);
5280   ret = store_sticky_event (pad, event);
5281   GST_OBJECT_UNLOCK (pad);
5282 
5283   return ret;
5284 }
5285 
5286 static gboolean
5287 sticky_changed (GstPad * pad, PadEvent * ev, gpointer user_data)
5288 {
5289   PushStickyData *data = user_data;
5290 
5291   /* Forward all sticky events before our current one that are pending */
5292   if (ev-&gt;event != data-&gt;event
5293       &amp;&amp; GST_EVENT_TYPE (ev-&gt;event) &lt; GST_EVENT_TYPE (data-&gt;event))
5294     return push_sticky (pad, ev, data);
5295 
5296   return TRUE;
5297 }
5298 
5299 /* should be called with pad LOCK */
5300 static GstFlowReturn
5301 gst_pad_push_event_unchecked (GstPad * pad, GstEvent * event,
5302     GstPadProbeType type)
5303 {
5304   GstFlowReturn ret;
5305   GstPad *peerpad;
5306   GstEventType event_type;
5307   gint64 old_pad_offset = pad-&gt;offset;
5308 
5309   /* pass the adjusted event on. We need to do this even if
5310    * there is no peer pad because of the probes. */
5311   event = apply_pad_offset (pad, event, GST_PAD_IS_SINK (pad));
5312 
5313   /* Two checks to be made:
5314    * . (un)set the FLUSHING flag for flushing events,
5315    * . handle pad blocking */
5316   event_type = GST_EVENT_TYPE (event);
5317   switch (event_type) {
5318     case GST_EVENT_FLUSH_START:
5319       GST_PAD_SET_FLUSHING (pad);
5320 
5321       GST_PAD_BLOCK_BROADCAST (pad);
5322       type |= GST_PAD_PROBE_TYPE_EVENT_FLUSH;
5323       break;
5324     case GST_EVENT_FLUSH_STOP:
5325       if (G_UNLIKELY (!GST_PAD_IS_ACTIVE (pad)))
5326         goto inactive;
5327 
5328       GST_PAD_UNSET_FLUSHING (pad);
5329 
5330       /* Remove sticky EOS events */
5331       GST_LOG_OBJECT (pad, &quot;Removing pending EOS events&quot;);
5332       remove_event_by_type (pad, GST_EVENT_EOS);
5333       remove_event_by_type (pad, GST_EVENT_STREAM_GROUP_DONE);
5334       remove_event_by_type (pad, GST_EVENT_SEGMENT);
5335       GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_EOS);
5336       pad-&gt;ABI.abi.last_flowret = GST_FLOW_OK;
5337 
5338       type |= GST_PAD_PROBE_TYPE_EVENT_FLUSH;
5339       break;
5340     default:
5341     {
5342       if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
5343         goto flushed;
5344 
5345       /* No need to check for EOS here as either the caller (gst_pad_push_event())
5346        * checked already or this is called as part of pushing sticky events,
5347        * in which case we still want to forward the EOS event downstream.
5348        */
5349 
5350       switch (GST_EVENT_TYPE (event)) {
5351         case GST_EVENT_RECONFIGURE:
5352           if (GST_PAD_IS_SINK (pad))
5353             GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);
5354           break;
5355         default:
5356           break;
5357       }
5358       PROBE_PUSH (pad, type | GST_PAD_PROBE_TYPE_PUSH |
5359           GST_PAD_PROBE_TYPE_BLOCK, event, probe_stopped);
5360       /* recheck sticky events because the probe might have cause a relink */
5361       if (GST_PAD_HAS_PENDING_EVENTS (pad) &amp;&amp; GST_PAD_IS_SRC (pad)
5362           &amp;&amp; (GST_EVENT_IS_SERIALIZED (event)
5363               || GST_EVENT_IS_STICKY (event))) {
5364         PushStickyData data = { GST_FLOW_OK, FALSE, event };
5365         GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_PENDING_EVENTS);
5366 
5367         /* Push all sticky events before our current one
5368          * that have changed */
5369         events_foreach (pad, sticky_changed, &amp;data);
5370       }
5371       break;
5372     }
5373   }
5374 
5375   /* send probes after modifying the events above */
5376   PROBE_PUSH (pad, type | GST_PAD_PROBE_TYPE_PUSH, event, probe_stopped);
5377 
5378   /* recheck sticky events because the probe might have cause a relink */
5379   if (GST_PAD_HAS_PENDING_EVENTS (pad) &amp;&amp; GST_PAD_IS_SRC (pad)
5380       &amp;&amp; (GST_EVENT_IS_SERIALIZED (event)
5381           || GST_EVENT_IS_STICKY (event))) {
5382     PushStickyData data = { GST_FLOW_OK, FALSE, event };
5383     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_PENDING_EVENTS);
5384 
5385     /* Push all sticky events before our current one
5386      * that have changed */
5387     events_foreach (pad, sticky_changed, &amp;data);
5388   }
5389 
5390   /* the pad offset might&#39;ve been changed by any of the probes above. It
5391    * would&#39;ve been taken into account when repushing any of the sticky events
5392    * above but not for our current event here */
5393   if (G_UNLIKELY (old_pad_offset != pad-&gt;offset)) {
5394     event =
5395         _apply_pad_offset (pad, event, GST_PAD_IS_SINK (pad),
5396         pad-&gt;offset - old_pad_offset);
5397   }
5398 
5399   /* now check the peer pad */
5400   peerpad = GST_PAD_PEER (pad);
5401   if (peerpad == NULL)
5402     goto not_linked;
5403 
5404   gst_object_ref (peerpad);
5405   pad-&gt;priv-&gt;using++;
5406   GST_OBJECT_UNLOCK (pad);
5407 
5408   GST_LOG_OBJECT (pad, &quot;sending event %p (%s) to peerpad %&quot; GST_PTR_FORMAT,
5409       event, gst_event_type_get_name (event_type), peerpad);
5410 
5411   ret = gst_pad_send_event_unchecked (peerpad, event, type);
5412 
5413   /* Note: we gave away ownership of the event at this point but we can still
5414    * print the old pointer */
5415   GST_LOG_OBJECT (pad,
5416       &quot;sent event %p (%s) to peerpad %&quot; GST_PTR_FORMAT &quot;, ret %s&quot;, event,
5417       gst_event_type_get_name (event_type), peerpad, gst_flow_get_name (ret));
5418 
5419   gst_object_unref (peerpad);
5420 
5421   GST_OBJECT_LOCK (pad);
5422   pad-&gt;priv-&gt;using--;
5423   if (pad-&gt;priv-&gt;using == 0) {
5424     /* pad is not active anymore, trigger idle callbacks */
5425     PROBE_NO_DATA (pad, GST_PAD_PROBE_TYPE_PUSH | GST_PAD_PROBE_TYPE_IDLE,
5426         idle_probe_stopped, ret);
5427   }
5428   return ret;
5429 
5430   /* ERROR handling */
5431 flushed:
5432   {
5433     GST_DEBUG_OBJECT (pad, &quot;We&#39;re flushing&quot;);
5434     gst_event_unref (event);
5435     return GST_FLOW_FLUSHING;
5436   }
5437 inactive:
5438   {
5439     GST_DEBUG_OBJECT (pad, &quot;flush-stop on inactive pad&quot;);
5440     gst_event_unref (event);
5441     return GST_FLOW_FLUSHING;
5442   }
5443 probe_stopped:
5444   {
5445     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
5446     if (ret != GST_FLOW_CUSTOM_SUCCESS_1)
5447       gst_event_unref (event);
5448 
5449     switch (ret) {
5450       case GST_FLOW_CUSTOM_SUCCESS_1:
5451         GST_DEBUG_OBJECT (pad, &quot;handled event&quot;);
5452         break;
5453       case GST_FLOW_CUSTOM_SUCCESS:
5454         GST_DEBUG_OBJECT (pad, &quot;dropped event&quot;);
5455         break;
5456       default:
5457         GST_DEBUG_OBJECT (pad, &quot;an error occurred %s&quot;, gst_flow_get_name (ret));
5458         break;
5459     }
5460     return ret;
5461   }
5462 not_linked:
5463   {
5464     GST_DEBUG_OBJECT (pad, &quot;Dropping event %s because pad is not linked&quot;,
5465         gst_event_type_get_name (GST_EVENT_TYPE (event)));
5466     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
5467     gst_event_unref (event);
5468 
5469     /* unlinked pads should not influence latency configuration */
5470     if (event_type == GST_EVENT_LATENCY)
5471       return GST_FLOW_OK;
5472 
5473     return GST_FLOW_NOT_LINKED;
5474   }
5475 idle_probe_stopped:
5476   {
5477     GST_DEBUG_OBJECT (pad, &quot;Idle probe returned %s&quot;, gst_flow_get_name (ret));
5478     return ret;
5479   }
5480 }
5481 
5482 /**
5483  * gst_pad_push_event:
5484  * @pad: a #GstPad to push the event to.
5485  * @event: (transfer full): the #GstEvent to send to the pad.
5486  *
5487  * Sends the event to the peer of the given pad. This function is
5488  * mainly used by elements to send events to their peer
5489  * elements.
5490  *
5491  * This function takes ownership of the provided event so you should
5492  * gst_event_ref() it if you want to reuse the event after this call.
5493  *
5494  * Returns: %TRUE if the event was handled.
5495  *
5496  * MT safe.
5497  */
5498 gboolean
5499 gst_pad_push_event (GstPad * pad, GstEvent * event)
5500 {
5501   gboolean res = FALSE;
5502   GstPadProbeType type;
5503   gboolean sticky, serialized;
5504 
5505   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
5506   g_return_val_if_fail (GST_IS_EVENT (event), FALSE);
5507 
5508   GST_TRACER_PAD_PUSH_EVENT_PRE (pad, event);
5509 
5510   if (GST_PAD_IS_SRC (pad)) {
5511     if (G_UNLIKELY (!GST_EVENT_IS_DOWNSTREAM (event)))
5512       goto wrong_direction;
5513     type = GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM;
5514   } else if (GST_PAD_IS_SINK (pad)) {
5515     if (G_UNLIKELY (!GST_EVENT_IS_UPSTREAM (event)))
5516       goto wrong_direction;
5517     /* events pushed on sinkpad never are sticky */
5518     type = GST_PAD_PROBE_TYPE_EVENT_UPSTREAM;
5519   } else
5520     goto unknown_direction;
5521 
5522   GST_OBJECT_LOCK (pad);
5523   sticky = GST_EVENT_IS_STICKY (event);
5524   serialized = GST_EVENT_IS_SERIALIZED (event);
5525 
5526   if (sticky) {
5527     /* srcpad sticky events are stored immediately, the received flag is set
5528      * to FALSE and will be set to TRUE when we can successfully push the
5529      * event to the peer pad */
5530     switch (store_sticky_event (pad, event)) {
5531       case GST_FLOW_FLUSHING:
5532         goto flushed;
5533       case GST_FLOW_EOS:
5534         goto eos;
5535       default:
5536         break;
5537     }
5538   }
5539   if (GST_PAD_IS_SRC (pad) &amp;&amp; (serialized || sticky)) {
5540     /* all serialized or sticky events on the srcpad trigger push of
5541      * sticky events */
5542     res = (check_sticky (pad, event) == GST_FLOW_OK);
5543   }
5544   if (!sticky) {
5545     GstFlowReturn ret;
5546 
5547     /* other events are pushed right away */
5548     ret = gst_pad_push_event_unchecked (pad, event, type);
5549     /* dropped events by a probe are not an error */
5550     res = (ret == GST_FLOW_OK || ret == GST_FLOW_CUSTOM_SUCCESS
5551         || ret == GST_FLOW_CUSTOM_SUCCESS_1);
5552   } else {
5553     /* Errors in sticky event pushing are no problem and ignored here
5554      * as they will cause more meaningful errors during data flow.
5555      * For EOS events, that are not followed by data flow, we still
5556      * return FALSE here though.
5557      */
5558     if (GST_EVENT_TYPE (event) != GST_EVENT_EOS)
5559       res = TRUE;
5560     gst_event_unref (event);
5561   }
5562   GST_OBJECT_UNLOCK (pad);
5563 
5564   GST_TRACER_PAD_PUSH_EVENT_POST (pad, res);
5565   return res;
5566 
5567   /* ERROR handling */
5568 wrong_direction:
5569   {
5570     g_warning (&quot;pad %s:%s pushing %s event in wrong direction&quot;,
5571         GST_DEBUG_PAD_NAME (pad), GST_EVENT_TYPE_NAME (event));
5572     gst_event_unref (event);
5573     goto done;
5574   }
5575 unknown_direction:
5576   {
5577     g_warning (&quot;pad %s:%s has invalid direction&quot;, GST_DEBUG_PAD_NAME (pad));
5578     gst_event_unref (event);
5579     goto done;
5580   }
5581 flushed:
5582   {
5583     GST_DEBUG_OBJECT (pad, &quot;We&#39;re flushing&quot;);
5584     GST_OBJECT_UNLOCK (pad);
5585     gst_event_unref (event);
5586     goto done;
5587   }
5588 eos:
5589   {
5590     GST_DEBUG_OBJECT (pad, &quot;We&#39;re EOS&quot;);
5591     GST_OBJECT_UNLOCK (pad);
5592     gst_event_unref (event);
5593     goto done;
5594   }
5595 done:
5596   GST_TRACER_PAD_PUSH_EVENT_POST (pad, FALSE);
5597   return FALSE;
5598 }
5599 
5600 /* Check if we can call the event function with the given event */
5601 static GstFlowReturn
5602 pre_eventfunc_check (GstPad * pad, GstEvent * event)
5603 {
5604   GstCaps *caps;
5605 
5606   switch (GST_EVENT_TYPE (event)) {
5607     case GST_EVENT_CAPS:
5608     {
5609       /* backwards compatibility mode for caps */
5610       gst_event_parse_caps (event, &amp;caps);
5611 
5612       if (!gst_pad_query_accept_caps (pad, caps))
5613         goto not_accepted;
5614       break;
5615     }
5616     default:
5617       break;
5618   }
5619   return GST_FLOW_OK;
5620 
5621   /* ERRORS */
5622 not_accepted:
5623   {
5624     GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad,
5625         &quot;caps %&quot; GST_PTR_FORMAT &quot; not accepted&quot;, caps);
5626     return GST_FLOW_NOT_NEGOTIATED;
5627   }
5628 }
5629 
5630 static GstFlowReturn
5631 gst_pad_send_event_unchecked (GstPad * pad, GstEvent * event,
5632     GstPadProbeType type)
5633 {
5634   GstFlowReturn ret;
5635   GstEventType event_type;
5636   gboolean serialized, need_unlock = FALSE, sticky;
5637   GstPadEventFunction eventfunc;
5638   GstPadEventFullFunction eventfullfunc = NULL;
5639   GstObject *parent;
5640   gint64 old_pad_offset;
5641 
5642   GST_OBJECT_LOCK (pad);
5643 
5644   old_pad_offset = pad-&gt;offset;
5645   event = apply_pad_offset (pad, event, GST_PAD_IS_SRC (pad));
5646 
5647   if (GST_PAD_IS_SINK (pad))
5648     serialized = GST_EVENT_IS_SERIALIZED (event);
5649   else
5650     serialized = FALSE;
5651   sticky = GST_EVENT_IS_STICKY (event);
5652   event_type = GST_EVENT_TYPE (event);
5653   switch (event_type) {
5654     case GST_EVENT_FLUSH_START:
5655       GST_CAT_DEBUG_OBJECT (GST_CAT_EVENT, pad,
5656           &quot;have event type %d (FLUSH_START)&quot;, GST_EVENT_TYPE (event));
5657 
5658       /* can&#39;t even accept a flush begin event when flushing */
5659       if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
5660         goto flushing;
5661 
5662       GST_PAD_SET_FLUSHING (pad);
5663       GST_CAT_DEBUG_OBJECT (GST_CAT_EVENT, pad, &quot;set flush flag&quot;);
5664       GST_PAD_BLOCK_BROADCAST (pad);
5665       type |= GST_PAD_PROBE_TYPE_EVENT_FLUSH;
5666       break;
5667     case GST_EVENT_FLUSH_STOP:
5668       /* we can&#39;t accept flush-stop on inactive pads else the flushing flag
5669        * would be cleared and it would look like the pad can accept data.
5670        * Also, some elements restart a streaming thread in flush-stop which we
5671        * can&#39;t allow on inactive pads */
5672       if (G_UNLIKELY (!GST_PAD_IS_ACTIVE (pad)))
5673         goto inactive;
5674 
5675       GST_PAD_UNSET_FLUSHING (pad);
5676       GST_CAT_DEBUG_OBJECT (GST_CAT_EVENT, pad, &quot;cleared flush flag&quot;);
5677       /* Remove pending EOS events */
5678       GST_LOG_OBJECT (pad, &quot;Removing pending EOS and SEGMENT events&quot;);
5679       remove_event_by_type (pad, GST_EVENT_EOS);
5680       remove_event_by_type (pad, GST_EVENT_STREAM_GROUP_DONE);
5681       remove_event_by_type (pad, GST_EVENT_SEGMENT);
5682       GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_EOS);
5683       pad-&gt;ABI.abi.last_flowret = GST_FLOW_OK;
5684 
5685       GST_OBJECT_UNLOCK (pad);
5686       /* grab stream lock */
5687       GST_PAD_STREAM_LOCK (pad);
5688       need_unlock = TRUE;
5689       GST_OBJECT_LOCK (pad);
5690       if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
5691         goto flushing;
5692       break;
5693     case GST_EVENT_RECONFIGURE:
5694       if (GST_PAD_IS_SRC (pad))
5695         GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);
5696     default:
5697       GST_CAT_DEBUG_OBJECT (GST_CAT_EVENT, pad,
5698           &quot;have event type %&quot; GST_PTR_FORMAT, event);
5699 
5700       if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
5701         goto flushing;
5702 
5703       switch (event_type) {
5704         case GST_EVENT_STREAM_START:
5705           /* Remove sticky EOS events */
5706           GST_LOG_OBJECT (pad, &quot;Removing pending EOS events&quot;);
5707           remove_event_by_type (pad, GST_EVENT_EOS);
5708           remove_event_by_type (pad, GST_EVENT_STREAM_GROUP_DONE);
5709           GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_EOS);
5710           break;
5711         default:
5712           break;
5713       }
5714 
5715       if (serialized) {
5716         if (G_UNLIKELY (GST_PAD_IS_EOS (pad)))
5717           goto eos;
5718 
5719         /* lock order: STREAM_LOCK, LOCK, recheck flushing. */
5720         GST_OBJECT_UNLOCK (pad);
5721         GST_PAD_STREAM_LOCK (pad);
5722         need_unlock = TRUE;
5723         GST_OBJECT_LOCK (pad);
5724         if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
5725           goto flushing;
5726 
5727         if (G_UNLIKELY (GST_PAD_IS_EOS (pad)))
5728           goto eos;
5729       }
5730       break;
5731   }
5732 
5733   /* now do the probe */
5734   PROBE_PUSH (pad,
5735       type | GST_PAD_PROBE_TYPE_PUSH |
5736       GST_PAD_PROBE_TYPE_BLOCK, event, probe_stopped);
5737 
5738   PROBE_PUSH (pad, type | GST_PAD_PROBE_TYPE_PUSH, event, probe_stopped);
5739 
5740   /* the pad offset might&#39;ve been changed by any of the probes above. It
5741    * would&#39;ve been taken into account when repushing any of the sticky events
5742    * above but not for our current event here */
5743   if (G_UNLIKELY (old_pad_offset != pad-&gt;offset)) {
5744     event =
5745         _apply_pad_offset (pad, event, GST_PAD_IS_SRC (pad),
5746         pad-&gt;offset - old_pad_offset);
5747   }
5748 
5749   eventfullfunc = GST_PAD_EVENTFULLFUNC (pad);
5750   eventfunc = GST_PAD_EVENTFUNC (pad);
5751   if (G_UNLIKELY (eventfunc == NULL &amp;&amp; eventfullfunc == NULL))
5752     goto no_function;
5753 
5754   ACQUIRE_PARENT (pad, parent, no_parent);
5755   GST_OBJECT_UNLOCK (pad);
5756 
5757   ret = pre_eventfunc_check (pad, event);
5758   if (G_UNLIKELY (ret != GST_FLOW_OK))
5759     goto precheck_failed;
5760 
5761   if (sticky)
5762     gst_event_ref (event);
5763 
5764   if (eventfullfunc) {
5765     ret = eventfullfunc (pad, parent, event);
5766   } else if (eventfunc (pad, parent, event)) {
5767     ret = GST_FLOW_OK;
5768   } else {
5769     /* something went wrong */
5770     switch (event_type) {
5771       case GST_EVENT_CAPS:
5772         ret = GST_FLOW_NOT_NEGOTIATED;
5773         break;
5774       default:
5775         ret = GST_FLOW_ERROR;
5776         break;
5777     }
5778   }
5779   RELEASE_PARENT (parent);
5780 
5781   GST_DEBUG_OBJECT (pad, &quot;sent event, ret %s&quot;, gst_flow_get_name (ret));
5782 
5783   if (sticky) {
5784     if (ret == GST_FLOW_OK) {
5785       GST_OBJECT_LOCK (pad);
5786       /* after the event function accepted the event, we can store the sticky
5787        * event on the pad */
5788       switch (store_sticky_event (pad, event)) {
5789         case GST_FLOW_FLUSHING:
5790           goto flushing;
5791         case GST_FLOW_EOS:
5792           goto eos;
5793         default:
5794           break;
5795       }
5796       GST_OBJECT_UNLOCK (pad);
5797     }
5798     gst_event_unref (event);
5799   }
5800 
5801   if (need_unlock)
5802     GST_PAD_STREAM_UNLOCK (pad);
5803 
5804   return ret;
5805 
5806   /* ERROR handling */
5807 flushing:
5808   {
5809     GST_OBJECT_UNLOCK (pad);
5810     if (need_unlock)
5811       GST_PAD_STREAM_UNLOCK (pad);
5812     GST_CAT_INFO_OBJECT (GST_CAT_EVENT, pad,
5813         &quot;Received event on flushing pad. Discarding&quot;);
5814     gst_event_unref (event);
5815     return GST_FLOW_FLUSHING;
5816   }
5817 inactive:
5818   {
5819     GST_OBJECT_UNLOCK (pad);
5820     if (need_unlock)
5821       GST_PAD_STREAM_UNLOCK (pad);
5822     GST_CAT_INFO_OBJECT (GST_CAT_EVENT, pad,
5823         &quot;Received flush-stop on inactive pad. Discarding&quot;);
5824     gst_event_unref (event);
5825     return GST_FLOW_FLUSHING;
5826   }
5827 eos:
5828   {
5829     GST_OBJECT_UNLOCK (pad);
5830     if (need_unlock)
5831       GST_PAD_STREAM_UNLOCK (pad);
5832     GST_CAT_INFO_OBJECT (GST_CAT_EVENT, pad,
5833         &quot;Received event on EOS pad. Discarding&quot;);
5834     gst_event_unref (event);
5835     return GST_FLOW_EOS;
5836   }
5837 probe_stopped:
5838   {
5839     GST_OBJECT_UNLOCK (pad);
5840     if (need_unlock)
5841       GST_PAD_STREAM_UNLOCK (pad);
5842     /* Only unref if unhandled */
5843     if (ret != GST_FLOW_CUSTOM_SUCCESS_1)
5844       gst_event_unref (event);
5845 
5846     switch (ret) {
5847       case GST_FLOW_CUSTOM_SUCCESS_1:
5848       case GST_FLOW_CUSTOM_SUCCESS:
5849         GST_DEBUG_OBJECT (pad, &quot;dropped or handled event&quot;);
5850         ret = GST_FLOW_OK;
5851         break;
5852       default:
5853         GST_DEBUG_OBJECT (pad, &quot;an error occurred %s&quot;, gst_flow_get_name (ret));
5854         break;
5855     }
5856     return ret;
5857   }
5858 no_function:
5859   {
5860     g_warning (&quot;pad %s:%s has no event handler, file a bug.&quot;,
5861         GST_DEBUG_PAD_NAME (pad));
5862     GST_OBJECT_UNLOCK (pad);
5863     if (need_unlock)
5864       GST_PAD_STREAM_UNLOCK (pad);
5865     gst_event_unref (event);
5866     return GST_FLOW_NOT_SUPPORTED;
5867   }
5868 no_parent:
5869   {
5870     GST_DEBUG_OBJECT (pad, &quot;no parent&quot;);
5871     GST_OBJECT_UNLOCK (pad);
5872     if (need_unlock)
5873       GST_PAD_STREAM_UNLOCK (pad);
5874     gst_event_unref (event);
5875     return GST_FLOW_FLUSHING;
5876   }
5877 precheck_failed:
5878   {
5879     GST_DEBUG_OBJECT (pad, &quot;pre event check failed&quot;);
5880     RELEASE_PARENT (parent);
5881     if (need_unlock)
5882       GST_PAD_STREAM_UNLOCK (pad);
5883     gst_event_unref (event);
5884     return ret;
5885   }
5886 }
5887 
5888 /**
5889  * gst_pad_send_event:
5890  * @pad: a #GstPad to send the event to.
5891  * @event: (transfer full): the #GstEvent to send to the pad.
5892  *
5893  * Sends the event to the pad. This function can be used
5894  * by applications to send events in the pipeline.
5895  *
5896  * If @pad is a source pad, @event should be an upstream event. If @pad is a
5897  * sink pad, @event should be a downstream event. For example, you would not
5898  * send a #GST_EVENT_EOS on a src pad; EOS events only propagate downstream.
5899  * Furthermore, some downstream events have to be serialized with data flow,
5900  * like EOS, while some can travel out-of-band, like #GST_EVENT_FLUSH_START. If
5901  * the event needs to be serialized with data flow, this function will take the
5902  * pad&#39;s stream lock while calling its event function.
5903  *
5904  * To find out whether an event type is upstream, downstream, or downstream and
5905  * serialized, see #GstEventTypeFlags, gst_event_type_get_flags(),
5906  * #GST_EVENT_IS_UPSTREAM, #GST_EVENT_IS_DOWNSTREAM, and
5907  * #GST_EVENT_IS_SERIALIZED. Note that in practice that an application or
5908  * plugin doesn&#39;t need to bother itself with this information; the core handles
5909  * all necessary locks and checks.
5910  *
5911  * This function takes ownership of the provided event so you should
5912  * gst_event_ref() it if you want to reuse the event after this call.
5913  *
5914  * Returns: %TRUE if the event was handled.
5915  */
5916 gboolean
5917 gst_pad_send_event (GstPad * pad, GstEvent * event)
5918 {
5919   gboolean result;
5920   GstPadProbeType type;
5921 
5922   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
5923   g_return_val_if_fail (event != NULL, FALSE);
5924 
5925   if (GST_PAD_IS_SINK (pad)) {
5926     if (G_UNLIKELY (!GST_EVENT_IS_DOWNSTREAM (event)))
5927       goto wrong_direction;
5928     type = GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM;
5929   } else if (GST_PAD_IS_SRC (pad)) {
5930     if (G_UNLIKELY (!GST_EVENT_IS_UPSTREAM (event)))
5931       goto wrong_direction;
5932     type = GST_PAD_PROBE_TYPE_EVENT_UPSTREAM;
5933   } else
5934     goto unknown_direction;
5935 
5936   if (gst_pad_send_event_unchecked (pad, event, type) != GST_FLOW_OK)
5937     result = FALSE;
5938   else
5939     result = TRUE;
5940 
5941   return result;
5942 
5943   /* ERROR handling */
5944 wrong_direction:
5945   {
5946     g_warning (&quot;pad %s:%s sending %s event in wrong direction&quot;,
5947         GST_DEBUG_PAD_NAME (pad), GST_EVENT_TYPE_NAME (event));
5948     gst_event_unref (event);
5949     return FALSE;
5950   }
5951 unknown_direction:
5952   {
5953     g_warning (&quot;pad %s:%s has invalid direction&quot;, GST_DEBUG_PAD_NAME (pad));
5954     gst_event_unref (event);
5955     return FALSE;
5956   }
5957 }
5958 
5959 /**
5960  * gst_pad_set_element_private:
5961  * @pad: the #GstPad to set the private data of.
5962  * @priv: The private data to attach to the pad.
5963  *
5964  * Set the given private data gpointer on the pad.
5965  * This function can only be used by the element that owns the pad.
5966  * No locking is performed in this function.
5967  */
5968 void
5969 gst_pad_set_element_private (GstPad * pad, gpointer priv)
5970 {
5971   pad-&gt;element_private = priv;
5972 }
5973 
5974 /**
5975  * gst_pad_get_element_private:
5976  * @pad: the #GstPad to get the private data of.
5977  *
5978  * Gets the private data of a pad.
5979  * No locking is performed in this function.
5980  *
5981  * Returns: (transfer none) (nullable): a #gpointer to the private data.
5982  */
5983 gpointer
5984 gst_pad_get_element_private (GstPad * pad)
5985 {
5986   return pad-&gt;element_private;
5987 }
5988 
5989 /**
5990  * gst_pad_get_sticky_event:
5991  * @pad: the #GstPad to get the event from.
5992  * @event_type: the #GstEventType that should be retrieved.
5993  * @idx: the index of the event
5994  *
5995  * Returns a new reference of the sticky event of type @event_type
5996  * from the event.
5997  *
5998  * Returns: (transfer full) (nullable): a #GstEvent of type
5999  * @event_type or %NULL when no event of @event_type was on
6000  * @pad. Unref after usage.
6001  */
6002 GstEvent *
6003 gst_pad_get_sticky_event (GstPad * pad, GstEventType event_type, guint idx)
6004 {
6005   GstEvent *event = NULL;
6006   PadEvent *ev;
6007 
6008   g_return_val_if_fail (GST_IS_PAD (pad), NULL);
6009   g_return_val_if_fail ((event_type &amp; GST_EVENT_TYPE_STICKY) != 0, NULL);
6010 
6011   GST_OBJECT_LOCK (pad);
6012   ev = find_event_by_type (pad, event_type, idx);
6013   if (ev &amp;&amp; (event = ev-&gt;event))
6014     gst_event_ref (event);
6015   GST_OBJECT_UNLOCK (pad);
6016 
6017   return event;
6018 }
6019 
6020 typedef struct
6021 {
6022   GstPadStickyEventsForeachFunction func;
6023   gpointer user_data;
6024 } ForeachDispatch;
6025 
6026 static gboolean
6027 foreach_dispatch_function (GstPad * pad, PadEvent * ev, gpointer user_data)
6028 {
6029   ForeachDispatch *data = user_data;
6030   gboolean ret = TRUE;
6031 
6032   if (ev-&gt;event) {
6033     GST_OBJECT_UNLOCK (pad);
6034 
6035     ret = data-&gt;func (pad, &amp;ev-&gt;event, data-&gt;user_data);
6036 
6037     GST_OBJECT_LOCK (pad);
6038   }
6039 
6040   return ret;
6041 }
6042 
6043 /**
6044  * gst_pad_sticky_events_foreach:
6045  * @pad: the #GstPad that should be used for iteration.
6046  * @foreach_func: (scope call): the #GstPadStickyEventsForeachFunction that
6047  *                should be called for every event.
6048  * @user_data: (closure): the optional user data.
6049  *
6050  * Iterates all sticky events on @pad and calls @foreach_func for every
6051  * event. If @foreach_func returns %FALSE the iteration is immediately stopped.
6052  */
6053 void
6054 gst_pad_sticky_events_foreach (GstPad * pad,
6055     GstPadStickyEventsForeachFunction foreach_func, gpointer user_data)
6056 {
6057   ForeachDispatch data;
6058 
6059   g_return_if_fail (GST_IS_PAD (pad));
6060   g_return_if_fail (foreach_func != NULL);
6061 
6062   data.func = foreach_func;
6063   data.user_data = user_data;
6064 
6065   GST_OBJECT_LOCK (pad);
6066   events_foreach (pad, foreach_dispatch_function, &amp;data);
6067   GST_OBJECT_UNLOCK (pad);
6068 }
6069 
6070 static void
6071 do_stream_status (GstPad * pad, GstStreamStatusType type,
6072     GThread * thread, GstTask * task)
6073 {
6074   GstElement *parent;
6075 
6076   GST_DEBUG_OBJECT (pad, &quot;doing stream-status %d&quot;, type);
6077 
6078   if ((parent = GST_ELEMENT_CAST (gst_pad_get_parent (pad)))) {
6079     if (GST_IS_ELEMENT (parent)) {
6080       GstMessage *message;
6081       GValue value = { 0 };
6082 
6083       if (type == GST_STREAM_STATUS_TYPE_ENTER) {
6084         gchar *tname, *ename, *pname;
6085 
6086         /* create a good task name */
6087         ename = gst_element_get_name (parent);
6088         pname = gst_pad_get_name (pad);
6089         tname = g_strdup_printf (&quot;%s:%s&quot;, ename, pname);
6090         g_free (ename);
6091         g_free (pname);
6092 
6093         gst_object_set_name (GST_OBJECT_CAST (task), tname);
6094         g_free (tname);
6095       }
6096 
6097       message = gst_message_new_stream_status (GST_OBJECT_CAST (pad),
6098           type, parent);
6099 
6100       g_value_init (&amp;value, GST_TYPE_TASK);
6101       g_value_set_object (&amp;value, task);
6102       gst_message_set_stream_status_object (message, &amp;value);
6103       g_value_unset (&amp;value);
6104 
6105       GST_DEBUG_OBJECT (pad, &quot;posting stream-status %d&quot;, type);
6106       gst_element_post_message (parent, message);
6107     }
6108     gst_object_unref (parent);
6109   }
6110 }
6111 
6112 static void
6113 pad_enter_thread (GstTask * task, GThread * thread, gpointer user_data)
6114 {
6115   do_stream_status (GST_PAD_CAST (user_data), GST_STREAM_STATUS_TYPE_ENTER,
6116       thread, task);
6117 }
6118 
6119 static void
6120 pad_leave_thread (GstTask * task, GThread * thread, gpointer user_data)
6121 {
6122   do_stream_status (GST_PAD_CAST (user_data), GST_STREAM_STATUS_TYPE_LEAVE,
6123       thread, task);
6124 }
6125 
6126 /**
6127  * gst_pad_start_task:
6128  * @pad: the #GstPad to start the task of
6129  * @func: the task function to call
6130  * @user_data: user data passed to the task function
6131  * @notify: called when @user_data is no longer referenced
6132  *
6133  * Starts a task that repeatedly calls @func with @user_data. This function
6134  * is mostly used in pad activation functions to start the dataflow.
6135  * The #GST_PAD_STREAM_LOCK of @pad will automatically be acquired
6136  * before @func is called.
6137  *
6138  * Returns: a %TRUE if the task could be started.
6139  */
6140 gboolean
6141 gst_pad_start_task (GstPad * pad, GstTaskFunction func, gpointer user_data,
6142     GDestroyNotify notify)
6143 {
6144   GstTask *task;
6145   gboolean res;
6146 
6147   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
6148   g_return_val_if_fail (func != NULL, FALSE);
6149 
6150   GST_DEBUG_OBJECT (pad, &quot;start task&quot;);
6151 
6152   GST_OBJECT_LOCK (pad);
6153   task = GST_PAD_TASK (pad);
6154   if (task == NULL) {
6155     task = gst_task_new (func, user_data, notify);
6156     gst_task_set_lock (task, GST_PAD_GET_STREAM_LOCK (pad));
6157     gst_task_set_enter_callback (task, pad_enter_thread, pad, NULL);
6158     gst_task_set_leave_callback (task, pad_leave_thread, pad, NULL);
6159     GST_INFO_OBJECT (pad, &quot;created task %p&quot;, task);
6160     GST_PAD_TASK (pad) = task;
6161     gst_object_ref (task);
6162     /* release lock to post the message */
6163     GST_OBJECT_UNLOCK (pad);
6164 
6165     do_stream_status (pad, GST_STREAM_STATUS_TYPE_CREATE, NULL, task);
6166 
6167     gst_object_unref (task);
6168 
6169     GST_OBJECT_LOCK (pad);
6170     /* nobody else is supposed to have changed the pad now */
6171     if (GST_PAD_TASK (pad) != task)
6172       goto concurrent_stop;
6173   }
6174   res = gst_task_set_state (task, GST_TASK_STARTED);
6175   GST_OBJECT_UNLOCK (pad);
6176 
6177   return res;
6178 
6179   /* ERRORS */
6180 concurrent_stop:
6181   {
6182     GST_OBJECT_UNLOCK (pad);
6183     return TRUE;
6184   }
6185 }
6186 
6187 /**
6188  * gst_pad_pause_task:
6189  * @pad: the #GstPad to pause the task of
6190  *
6191  * Pause the task of @pad. This function will also wait until the
6192  * function executed by the task is finished if this function is not
6193  * called from the task function.
6194  *
6195  * Returns: a %TRUE if the task could be paused or %FALSE when the pad
6196  * has no task.
6197  */
6198 gboolean
6199 gst_pad_pause_task (GstPad * pad)
6200 {
6201   GstTask *task;
6202   gboolean res;
6203 
6204   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
6205 
6206   GST_DEBUG_OBJECT (pad, &quot;pause task&quot;);
6207 
6208   GST_OBJECT_LOCK (pad);
6209   task = GST_PAD_TASK (pad);
6210   if (task == NULL)
6211     goto no_task;
6212   res = gst_task_set_state (task, GST_TASK_PAUSED);
6213   /* unblock activation waits if any */
6214   pad-&gt;priv-&gt;in_activation = FALSE;
6215   g_cond_broadcast (&amp;pad-&gt;priv-&gt;activation_cond);
6216   GST_OBJECT_UNLOCK (pad);
6217 
6218   /* wait for task function to finish, this lock is recursive so it does nothing
6219    * when the pause is called from the task itself */
6220   GST_PAD_STREAM_LOCK (pad);
6221   GST_PAD_STREAM_UNLOCK (pad);
6222 
6223   return res;
6224 
6225 no_task:
6226   {
6227     GST_DEBUG_OBJECT (pad, &quot;pad has no task&quot;);
6228     GST_OBJECT_UNLOCK (pad);
6229     return FALSE;
6230   }
6231 }
6232 
6233 /**
6234  * gst_pad_get_task_state:
6235  * @pad: the #GstPad to get task state from
6236  *
6237  * Get @pad task state. If no task is currently
6238  * set, #GST_TASK_STOPPED is returned.
6239  *
6240  * Returns: The current state of @pad&#39;s task.
6241  *
6242  * Since: 1.12
6243  */
6244 GstTaskState
6245 gst_pad_get_task_state (GstPad * pad)
6246 {
6247   GstTask *task;
6248   GstTaskState res;
6249 
6250   g_return_val_if_fail (GST_IS_PAD (pad), GST_TASK_STOPPED);
6251 
6252   GST_OBJECT_LOCK (pad);
6253   task = GST_PAD_TASK (pad);
6254   if (task == NULL)
6255     goto no_task;
6256   res = gst_task_get_state (task);
6257   GST_OBJECT_UNLOCK (pad);
6258 
6259   return res;
6260 
6261 no_task:
6262   {
6263     GST_DEBUG_OBJECT (pad, &quot;pad has no task&quot;);
6264     GST_OBJECT_UNLOCK (pad);
6265     return GST_TASK_STOPPED;
6266   }
6267 }
6268 
6269 /**
6270  * gst_pad_stop_task:
6271  * @pad: the #GstPad to stop the task of
6272  *
6273  * Stop the task of @pad. This function will also make sure that the
6274  * function executed by the task will effectively stop if not called
6275  * from the GstTaskFunction.
6276  *
6277  * This function will deadlock if called from the GstTaskFunction of
6278  * the task. Use gst_task_pause() instead.
6279  *
6280  * Regardless of whether the pad has a task, the stream lock is acquired and
6281  * released so as to ensure that streaming through this pad has finished.
6282  *
6283  * Returns: a %TRUE if the task could be stopped or %FALSE on error.
6284  */
6285 gboolean
6286 gst_pad_stop_task (GstPad * pad)
6287 {
6288   GstTask *task;
6289   gboolean res;
6290 
6291   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
6292 
6293   GST_DEBUG_OBJECT (pad, &quot;stop task&quot;);
6294 
6295   GST_OBJECT_LOCK (pad);
6296   task = GST_PAD_TASK (pad);
6297   if (task == NULL)
6298     goto no_task;
6299   GST_PAD_TASK (pad) = NULL;
6300   res = gst_task_set_state (task, GST_TASK_STOPPED);
6301   /* unblock activation waits if any */
6302   pad-&gt;priv-&gt;in_activation = FALSE;
6303   g_cond_broadcast (&amp;pad-&gt;priv-&gt;activation_cond);
6304   GST_OBJECT_UNLOCK (pad);
6305 
6306   GST_PAD_STREAM_LOCK (pad);
6307   GST_PAD_STREAM_UNLOCK (pad);
6308 
6309   if (!gst_task_join (task))
6310     goto join_failed;
6311 
6312   gst_object_unref (task);
6313 
6314   return res;
6315 
6316 no_task:
6317   {
6318     GST_DEBUG_OBJECT (pad, &quot;no task&quot;);
6319     GST_OBJECT_UNLOCK (pad);
6320 
6321     GST_PAD_STREAM_LOCK (pad);
6322     GST_PAD_STREAM_UNLOCK (pad);
6323 
6324     /* this is not an error */
6325     return TRUE;
6326   }
6327 join_failed:
6328   {
6329     /* this is bad, possibly the application tried to join the task from
6330      * the task&#39;s thread. We install the task again so that it will be stopped
6331      * again from the right thread next time hopefully. */
6332     GST_OBJECT_LOCK (pad);
6333     GST_DEBUG_OBJECT (pad, &quot;join failed&quot;);
6334     /* we can only install this task if there was no other task */
6335     if (GST_PAD_TASK (pad) == NULL)
6336       GST_PAD_TASK (pad) = task;
6337     GST_OBJECT_UNLOCK (pad);
6338 
6339     return FALSE;
6340   }
6341 }
6342 
6343 /**
6344  * gst_pad_probe_info_get_event:
6345  * @info: a #GstPadProbeInfo
6346  *
6347  * Returns: (transfer none) (nullable): The #GstEvent from the probe
6348  */
6349 
6350 GstEvent *
6351 gst_pad_probe_info_get_event (GstPadProbeInfo * info)
6352 {
6353   g_return_val_if_fail (info-&gt;type &amp; (GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM |
6354           GST_PAD_PROBE_TYPE_EVENT_UPSTREAM), NULL);
6355 
6356   return GST_PAD_PROBE_INFO_EVENT (info);
6357 }
6358 
6359 
6360 /**
6361  * gst_pad_probe_info_get_query:
6362  * @info: a #GstPadProbeInfo
6363  *
6364  * Returns: (transfer none) (nullable): The #GstQuery from the probe
6365  */
6366 
6367 GstQuery *
6368 gst_pad_probe_info_get_query (GstPadProbeInfo * info)
6369 {
6370   g_return_val_if_fail (info-&gt;type &amp; (GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM |
6371           GST_PAD_PROBE_TYPE_QUERY_UPSTREAM), NULL);
6372 
6373   return GST_PAD_PROBE_INFO_QUERY (info);
6374 }
6375 
6376 /**
6377  * gst_pad_probe_info_get_buffer:
6378  * @info: a #GstPadProbeInfo
6379  *
6380  * Returns: (transfer none) (nullable): The #GstBuffer from the probe
6381  */
6382 
6383 GstBuffer *
6384 gst_pad_probe_info_get_buffer (GstPadProbeInfo * info)
6385 {
6386   g_return_val_if_fail (info-&gt;type &amp; GST_PAD_PROBE_TYPE_BUFFER, NULL);
6387 
6388   return GST_PAD_PROBE_INFO_BUFFER (info);
6389 }
6390 
6391 /**
6392  * gst_pad_probe_info_get_buffer_list:
6393  * @info: a #GstPadProbeInfo
6394  *
6395  * Returns: (transfer none) (nullable): The #GstBufferList from the probe
6396  */
6397 
6398 GstBufferList *
6399 gst_pad_probe_info_get_buffer_list (GstPadProbeInfo * info)
6400 {
6401   g_return_val_if_fail (info-&gt;type &amp; GST_PAD_PROBE_TYPE_BUFFER_LIST, NULL);
6402 
6403   return GST_PAD_PROBE_INFO_BUFFER_LIST (info);
6404 }
6405 
6406 /**
6407  * gst_pad_get_last_flow_return:
6408  * @pad: the #GstPad
6409  *
6410  * Gets the #GstFlowReturn return from the last data passed by this pad.
6411  *
6412  * Since: 1.4
6413  */
6414 GstFlowReturn
6415 gst_pad_get_last_flow_return (GstPad * pad)
6416 {
6417   GstFlowReturn ret;
6418 
6419   GST_OBJECT_LOCK (pad);
6420   ret = GST_PAD_LAST_FLOW_RETURN (pad);
6421   GST_OBJECT_UNLOCK (pad);
6422 
6423   return ret;
6424 }
    </pre>
  </body>
</html>