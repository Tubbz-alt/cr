<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstsegment.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstsample.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstsegment.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstsegment.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 375   segment-&gt;time = start;
 376   segment-&gt;position = position;
 377 
 378   GST_INFO (&quot;segment updated: %&quot; GST_SEGMENT_FORMAT, segment);
 379 
 380   return TRUE;
 381 }
 382 
 383 /**
 384  * gst_segment_to_stream_time_full:
 385  * @segment: a #GstSegment structure.
 386  * @format: the format of the segment.
 387  * @position: the position in the segment
 388  * @stream_time: (out): result stream-time
 389  *
 390  * Translate @position to the total stream time using the currently configured
 391  * segment. Compared to gst_segment_to_stream_time() this function can return
 392  * negative stream-time.
 393  *
 394  * This function is typically used by elements that need to synchronize buffers
<span class="line-modified"> 395  * against the clock or eachother.</span>
 396  *
 397  * @position can be any value and the result of this function for values outside
 398  * of the segment is extrapolated.
 399  *
 400  * When 1 is returned, @position resulted in a positive stream-time returned
 401  * in @stream_time.
 402  *
 403  * When this function returns -1, the returned @stream_time should be negated
 404  * to get the real negative stream time.
 405  *
 406  * Returns: a 1 or -1 on success, 0 on failure.
 407  *
 408  * Since: 1.8
 409  */
 410 gint
 411 gst_segment_to_stream_time_full (const GstSegment * segment, GstFormat format,
 412     guint64 position, guint64 * stream_time)
 413 {
 414   guint64 start, stop, time;
 415   gdouble abs_applied_rate;
</pre>
<hr />
<pre>
 682       gst_segment_position_from_stream_time_full (segment, format, stream_time,
 683       &amp;position);
 684 
 685   /* before the segment boundary */
 686   if (G_UNLIKELY (position &lt; segment-&gt;start)) {
 687     GST_DEBUG (&quot;position(%&quot; G_GUINT64_FORMAT &quot;) &lt; start(%&quot; G_GUINT64_FORMAT
 688         &quot;)&quot;, position, segment-&gt;start);
 689     return -1;
 690   }
 691 
 692   /* after the segment boundary */
 693   if (G_UNLIKELY (segment-&gt;stop != -1 &amp;&amp; position &gt; segment-&gt;stop)) {
 694     GST_DEBUG (&quot;position(%&quot; G_GUINT64_FORMAT &quot;) &gt; stop(%&quot; G_GUINT64_FORMAT
 695         &quot;)&quot;, position, segment-&gt;stop);
 696     return -1;
 697   }
 698 
 699   if (res == 1)
 700     return position;
 701 
<span class="line-modified"> 702     return -1;</span>
 703 }
 704 
 705 /**
 706  * gst_segment_to_running_time_full:
 707  * @segment: a #GstSegment structure.
 708  * @format: the format of the segment.
 709  * @position: the position in the segment
 710  * @running_time: (out) (allow-none): result running-time
 711  *
 712  * Translate @position to the total running time using the currently configured
 713  * segment. Compared to gst_segment_to_running_time() this function can return
 714  * negative running-time.
 715  *
 716  * This function is typically used by elements that need to synchronize buffers
<span class="line-modified"> 717  * against the clock or eachother.</span>
 718  *
 719  * @position can be any value and the result of this function for values outside
 720  * of the segment is extrapolated.
 721  *
 722  * When 1 is returned, @position resulted in a positive running-time returned
 723  * in @running_time.
 724  *
 725  * When this function returns -1, the returned @running_time should be negated
 726  * to get the real negative running time.
 727  *
 728  * Returns: a 1 or -1 on success, 0 on failure.
 729  *
 730  * Since: 1.6
 731  */
 732 gint
 733 gst_segment_to_running_time_full (const GstSegment * segment, GstFormat format,
 734     guint64 position, guint64 * running_time)
 735 {
 736   gint res = 0;
 737   guint64 result;
 738   guint64 start, stop, offset;
 739   gdouble abs_rate;
 740 
 741   if (G_UNLIKELY (position == -1)) {
 742     GST_DEBUG (&quot;invalid position (-1)&quot;);
 743     goto done;
 744   }
 745 
 746   g_return_val_if_fail (segment != NULL, 0);
 747   g_return_val_if_fail (segment-&gt;format == format, 0);
 748 
 749   offset = segment-&gt;offset;
 750 
 751   if (G_LIKELY (segment-&gt;rate &gt; 0.0)) {
 752     start = segment-&gt;start + offset;
 753 
<span class="line-modified"> 754   /* bring to uncorrected position in segment */</span>
 755     if (position &lt; start) {
 756       /* negative value */
 757       result = start - position;
 758       res = -1;
 759     } else {
<span class="line-modified"> 760   result = position - start;</span>
 761       res = 1;
 762     }
 763   } else {
 764     stop = segment-&gt;stop;
 765 



 766     /* cannot continue if no stop position set or invalid offset */
 767     g_return_val_if_fail (stop != -1, 0);
 768     g_return_val_if_fail (stop &gt;= offset, 0);
 769 
 770     stop -= offset;
 771 
 772     /* bring to uncorrected position in segment */
 773     if (position &gt; stop) {
 774       /* negative value */
 775       result = position - stop;
 776       res = -1;
<span class="line-modified"> 777   } else {</span>
 778       result = stop - position;
 779       res = 1;
<span class="line-modified"> 780   }</span>
 781   }
 782 
 783   if (running_time) {
 784     /* scale based on the rate, avoid division by and conversion to
 785      * float when not needed */
 786     abs_rate = ABS (segment-&gt;rate);
 787     if (G_UNLIKELY (abs_rate != 1.0))
 788       result /= abs_rate;
 789 
 790     /* correct for base of the segment */
 791     if (res == 1)
 792       /* positive, add base */
 793       *running_time = result + segment-&gt;base;
 794     else if (segment-&gt;base &gt;= result) {
 795       /* negative and base is bigger, subtract from base and we have a
 796        * positive value again */
 797       *running_time = segment-&gt;base - result;
 798       res = 1;
 799     } else {
 800       /* negative and base is smaller, subtract base and remainder is
 801        * negative */
 802       *running_time = result - segment-&gt;base;
<span class="line-modified"> 803 }</span>
 804   }
 805   return res;
 806 
 807 done:
 808   {
 809     if (running_time)
 810       *running_time = -1;
 811     return 0;
 812   }
 813 }
 814 
 815 /**
 816  * gst_segment_to_running_time:
 817  * @segment: a #GstSegment structure.
 818  * @format: the format of the segment.
 819  * @position: the position in the segment
 820  *
 821  * Translate @position to the total running time using the currently configured
 822  * segment. Position is a value between @segment start and stop time.
 823  *
</pre>
<hr />
<pre>
 836     guint64 position)
 837 {
 838   guint64 result;
 839 
 840 #ifdef GSTREAMER_LITE
 841   if (segment-&gt;format != format)
 842     return -1;
 843 #endif // GSTREAMER_LITE
 844 
 845   g_return_val_if_fail (segment != NULL, -1);
 846   g_return_val_if_fail (segment-&gt;format == format, -1);
 847 
 848   /* before the segment boundary */
 849   if (G_UNLIKELY (position &lt; segment-&gt;start)) {
 850     GST_DEBUG (&quot;position(%&quot; G_GUINT64_FORMAT &quot;) &lt; start(%&quot; G_GUINT64_FORMAT
 851         &quot;)&quot;, position, segment-&gt;start);
 852     return -1;
 853   }
 854   /* after the segment boundary */
 855   if (G_UNLIKELY (segment-&gt;stop != -1 &amp;&amp; position &gt; segment-&gt;stop)) {
<span class="line-modified"> 856       GST_DEBUG (&quot;position(%&quot; G_GUINT64_FORMAT &quot;) &gt; stop(%&quot; G_GUINT64_FORMAT</span>
 857         &quot;)&quot;, position, segment-&gt;stop);
<span class="line-modified"> 858       return -1;</span>
<span class="line-modified"> 859     }</span>
 860 
 861   if (gst_segment_to_running_time_full (segment, format, position,
 862           &amp;result) == 1)
 863     return result;
 864 
<span class="line-modified"> 865       return -1;</span>
<span class="line-modified"> 866     }</span>
 867 
 868 /**
 869  * gst_segment_clip:
 870  * @segment: a #GstSegment structure.
 871  * @format: the format of the segment.
 872  * @start: the start position in the segment
 873  * @stop: the stop position in the segment
 874  * @clip_start: (out) (allow-none): the clipped start position in the segment
 875  * @clip_stop: (out) (allow-none): the clipped stop position in the segment
 876  *
 877  * Clip the given @start and @stop values to the segment boundaries given
 878  * in @segment. @start and @stop are compared and clipped to @segment
 879  * start and stop values.
 880  *
 881  * If the function returns %FALSE, @start and @stop are known to fall
 882  * outside of @segment and @clip_start and @clip_stop are not updated.
 883  *
 884  * When the function returns %TRUE, @clip_start and @clip_stop will be
 885  * updated. If @clip_start or @clip_stop are different from @start or @stop
 886  * respectively, the region fell partially in the segment.
</pre>
<hr />
<pre>
1023     return 0;
1024   }
1025 
1026   g_return_val_if_fail (segment != NULL, 0);
1027   g_return_val_if_fail (segment-&gt;format == format, 0);
1028 
1029   base = segment-&gt;base;
1030 
1031   abs_rate = ABS (segment-&gt;rate);
1032 
1033   start = segment-&gt;start;
1034   stop = segment-&gt;stop;
1035 
1036   if (G_LIKELY (segment-&gt;rate &gt; 0.0)) {
1037     /* start by subtracting the base time */
1038     if (G_LIKELY (running_time &gt;= base)) {
1039       *position = running_time - base;
1040       /* move into the segment at the right rate */
1041       if (G_UNLIKELY (abs_rate != 1.0))
1042         *position = ceil (*position * abs_rate);
<span class="line-modified">1043     /* bring to corrected position in segment */</span>
1044       *position += start + segment-&gt;offset;
1045       res = 1;
<span class="line-modified">1046   } else {</span>
1047       *position = base - running_time;
1048       if (G_UNLIKELY (abs_rate != 1.0))
1049         *position = ceil (*position * abs_rate);
1050       if (start + segment-&gt;offset &gt;= *position) {
1051         /* The TS is before the segment, but the result is &gt;= 0 */
1052         *position = start + segment-&gt;offset - *position;
1053         res = 1;
1054       } else {
1055         /* The TS is before the segment, and the result is &lt; 0
1056          * so negate the return result */
1057         *position = *position - (start + segment-&gt;offset);
1058         res = -1;
<span class="line-modified">1059   }</span>
<span class="line-modified">1060 }</span>
1061   } else {
1062     if (G_LIKELY (running_time &gt;= base)) {
1063       *position = running_time - base;
1064       if (G_UNLIKELY (abs_rate != 1.0))
1065         *position = ceil (*position * abs_rate);
1066       if (G_UNLIKELY (stop &lt; *position + segment-&gt;offset)) {
1067         *position += segment-&gt;offset - stop;
1068         res = -1;
1069       } else {
1070         *position = stop - *position - segment-&gt;offset;
1071         res = 1;
1072       }
1073     } else {
1074       /* This case is tricky. Requested running time precedes the
1075        * segment base, so in a reversed segment where rate &lt; 0, that
1076        * means it&#39;s before the alignment point of (stop - offset).
1077        * Before = always bigger than (stop-offset), which is usually +ve,
1078        * but could be -ve is offset is big enough. -ve position implies
1079        * that the offset has clipped away the entire segment anyway */
1080       *position = base - running_time;
</pre>
</td>
<td>
<hr />
<pre>
 375   segment-&gt;time = start;
 376   segment-&gt;position = position;
 377 
 378   GST_INFO (&quot;segment updated: %&quot; GST_SEGMENT_FORMAT, segment);
 379 
 380   return TRUE;
 381 }
 382 
 383 /**
 384  * gst_segment_to_stream_time_full:
 385  * @segment: a #GstSegment structure.
 386  * @format: the format of the segment.
 387  * @position: the position in the segment
 388  * @stream_time: (out): result stream-time
 389  *
 390  * Translate @position to the total stream time using the currently configured
 391  * segment. Compared to gst_segment_to_stream_time() this function can return
 392  * negative stream-time.
 393  *
 394  * This function is typically used by elements that need to synchronize buffers
<span class="line-modified"> 395  * against the clock or each other.</span>
 396  *
 397  * @position can be any value and the result of this function for values outside
 398  * of the segment is extrapolated.
 399  *
 400  * When 1 is returned, @position resulted in a positive stream-time returned
 401  * in @stream_time.
 402  *
 403  * When this function returns -1, the returned @stream_time should be negated
 404  * to get the real negative stream time.
 405  *
 406  * Returns: a 1 or -1 on success, 0 on failure.
 407  *
 408  * Since: 1.8
 409  */
 410 gint
 411 gst_segment_to_stream_time_full (const GstSegment * segment, GstFormat format,
 412     guint64 position, guint64 * stream_time)
 413 {
 414   guint64 start, stop, time;
 415   gdouble abs_applied_rate;
</pre>
<hr />
<pre>
 682       gst_segment_position_from_stream_time_full (segment, format, stream_time,
 683       &amp;position);
 684 
 685   /* before the segment boundary */
 686   if (G_UNLIKELY (position &lt; segment-&gt;start)) {
 687     GST_DEBUG (&quot;position(%&quot; G_GUINT64_FORMAT &quot;) &lt; start(%&quot; G_GUINT64_FORMAT
 688         &quot;)&quot;, position, segment-&gt;start);
 689     return -1;
 690   }
 691 
 692   /* after the segment boundary */
 693   if (G_UNLIKELY (segment-&gt;stop != -1 &amp;&amp; position &gt; segment-&gt;stop)) {
 694     GST_DEBUG (&quot;position(%&quot; G_GUINT64_FORMAT &quot;) &gt; stop(%&quot; G_GUINT64_FORMAT
 695         &quot;)&quot;, position, segment-&gt;stop);
 696     return -1;
 697   }
 698 
 699   if (res == 1)
 700     return position;
 701 
<span class="line-modified"> 702   return -1;</span>
 703 }
 704 
 705 /**
 706  * gst_segment_to_running_time_full:
 707  * @segment: a #GstSegment structure.
 708  * @format: the format of the segment.
 709  * @position: the position in the segment
 710  * @running_time: (out) (allow-none): result running-time
 711  *
 712  * Translate @position to the total running time using the currently configured
 713  * segment. Compared to gst_segment_to_running_time() this function can return
 714  * negative running-time.
 715  *
 716  * This function is typically used by elements that need to synchronize buffers
<span class="line-modified"> 717  * against the clock or each other.</span>
 718  *
 719  * @position can be any value and the result of this function for values outside
 720  * of the segment is extrapolated.
 721  *
 722  * When 1 is returned, @position resulted in a positive running-time returned
 723  * in @running_time.
 724  *
 725  * When this function returns -1, the returned @running_time should be negated
 726  * to get the real negative running time.
 727  *
 728  * Returns: a 1 or -1 on success, 0 on failure.
 729  *
 730  * Since: 1.6
 731  */
 732 gint
 733 gst_segment_to_running_time_full (const GstSegment * segment, GstFormat format,
 734     guint64 position, guint64 * running_time)
 735 {
 736   gint res = 0;
 737   guint64 result;
 738   guint64 start, stop, offset;
 739   gdouble abs_rate;
 740 
 741   if (G_UNLIKELY (position == -1)) {
 742     GST_DEBUG (&quot;invalid position (-1)&quot;);
 743     goto done;
 744   }
 745 
 746   g_return_val_if_fail (segment != NULL, 0);
 747   g_return_val_if_fail (segment-&gt;format == format, 0);
 748 
 749   offset = segment-&gt;offset;
 750 
 751   if (G_LIKELY (segment-&gt;rate &gt; 0.0)) {
 752     start = segment-&gt;start + offset;
 753 
<span class="line-modified"> 754     /* bring to uncorrected position in segment */</span>
 755     if (position &lt; start) {
 756       /* negative value */
 757       result = start - position;
 758       res = -1;
 759     } else {
<span class="line-modified"> 760       result = position - start;</span>
 761       res = 1;
 762     }
 763   } else {
 764     stop = segment-&gt;stop;
 765 
<span class="line-added"> 766     if (stop == -1 &amp;&amp; segment-&gt;duration != -1)</span>
<span class="line-added"> 767       stop = segment-&gt;start + segment-&gt;duration;</span>
<span class="line-added"> 768 </span>
 769     /* cannot continue if no stop position set or invalid offset */
 770     g_return_val_if_fail (stop != -1, 0);
 771     g_return_val_if_fail (stop &gt;= offset, 0);
 772 
 773     stop -= offset;
 774 
 775     /* bring to uncorrected position in segment */
 776     if (position &gt; stop) {
 777       /* negative value */
 778       result = position - stop;
 779       res = -1;
<span class="line-modified"> 780     } else {</span>
 781       result = stop - position;
 782       res = 1;
<span class="line-modified"> 783     }</span>
 784   }
 785 
 786   if (running_time) {
 787     /* scale based on the rate, avoid division by and conversion to
 788      * float when not needed */
 789     abs_rate = ABS (segment-&gt;rate);
 790     if (G_UNLIKELY (abs_rate != 1.0))
 791       result /= abs_rate;
 792 
 793     /* correct for base of the segment */
 794     if (res == 1)
 795       /* positive, add base */
 796       *running_time = result + segment-&gt;base;
 797     else if (segment-&gt;base &gt;= result) {
 798       /* negative and base is bigger, subtract from base and we have a
 799        * positive value again */
 800       *running_time = segment-&gt;base - result;
 801       res = 1;
 802     } else {
 803       /* negative and base is smaller, subtract base and remainder is
 804        * negative */
 805       *running_time = result - segment-&gt;base;
<span class="line-modified"> 806     }</span>
 807   }
 808   return res;
 809 
 810 done:
 811   {
 812     if (running_time)
 813       *running_time = -1;
 814     return 0;
 815   }
 816 }
 817 
 818 /**
 819  * gst_segment_to_running_time:
 820  * @segment: a #GstSegment structure.
 821  * @format: the format of the segment.
 822  * @position: the position in the segment
 823  *
 824  * Translate @position to the total running time using the currently configured
 825  * segment. Position is a value between @segment start and stop time.
 826  *
</pre>
<hr />
<pre>
 839     guint64 position)
 840 {
 841   guint64 result;
 842 
 843 #ifdef GSTREAMER_LITE
 844   if (segment-&gt;format != format)
 845     return -1;
 846 #endif // GSTREAMER_LITE
 847 
 848   g_return_val_if_fail (segment != NULL, -1);
 849   g_return_val_if_fail (segment-&gt;format == format, -1);
 850 
 851   /* before the segment boundary */
 852   if (G_UNLIKELY (position &lt; segment-&gt;start)) {
 853     GST_DEBUG (&quot;position(%&quot; G_GUINT64_FORMAT &quot;) &lt; start(%&quot; G_GUINT64_FORMAT
 854         &quot;)&quot;, position, segment-&gt;start);
 855     return -1;
 856   }
 857   /* after the segment boundary */
 858   if (G_UNLIKELY (segment-&gt;stop != -1 &amp;&amp; position &gt; segment-&gt;stop)) {
<span class="line-modified"> 859     GST_DEBUG (&quot;position(%&quot; G_GUINT64_FORMAT &quot;) &gt; stop(%&quot; G_GUINT64_FORMAT</span>
 860         &quot;)&quot;, position, segment-&gt;stop);
<span class="line-modified"> 861     return -1;</span>
<span class="line-modified"> 862   }</span>
 863 
 864   if (gst_segment_to_running_time_full (segment, format, position,
 865           &amp;result) == 1)
 866     return result;
 867 
<span class="line-modified"> 868   return -1;</span>
<span class="line-modified"> 869 }</span>
 870 
 871 /**
 872  * gst_segment_clip:
 873  * @segment: a #GstSegment structure.
 874  * @format: the format of the segment.
 875  * @start: the start position in the segment
 876  * @stop: the stop position in the segment
 877  * @clip_start: (out) (allow-none): the clipped start position in the segment
 878  * @clip_stop: (out) (allow-none): the clipped stop position in the segment
 879  *
 880  * Clip the given @start and @stop values to the segment boundaries given
 881  * in @segment. @start and @stop are compared and clipped to @segment
 882  * start and stop values.
 883  *
 884  * If the function returns %FALSE, @start and @stop are known to fall
 885  * outside of @segment and @clip_start and @clip_stop are not updated.
 886  *
 887  * When the function returns %TRUE, @clip_start and @clip_stop will be
 888  * updated. If @clip_start or @clip_stop are different from @start or @stop
 889  * respectively, the region fell partially in the segment.
</pre>
<hr />
<pre>
1026     return 0;
1027   }
1028 
1029   g_return_val_if_fail (segment != NULL, 0);
1030   g_return_val_if_fail (segment-&gt;format == format, 0);
1031 
1032   base = segment-&gt;base;
1033 
1034   abs_rate = ABS (segment-&gt;rate);
1035 
1036   start = segment-&gt;start;
1037   stop = segment-&gt;stop;
1038 
1039   if (G_LIKELY (segment-&gt;rate &gt; 0.0)) {
1040     /* start by subtracting the base time */
1041     if (G_LIKELY (running_time &gt;= base)) {
1042       *position = running_time - base;
1043       /* move into the segment at the right rate */
1044       if (G_UNLIKELY (abs_rate != 1.0))
1045         *position = ceil (*position * abs_rate);
<span class="line-modified">1046       /* bring to corrected position in segment */</span>
1047       *position += start + segment-&gt;offset;
1048       res = 1;
<span class="line-modified">1049     } else {</span>
1050       *position = base - running_time;
1051       if (G_UNLIKELY (abs_rate != 1.0))
1052         *position = ceil (*position * abs_rate);
1053       if (start + segment-&gt;offset &gt;= *position) {
1054         /* The TS is before the segment, but the result is &gt;= 0 */
1055         *position = start + segment-&gt;offset - *position;
1056         res = 1;
1057       } else {
1058         /* The TS is before the segment, and the result is &lt; 0
1059          * so negate the return result */
1060         *position = *position - (start + segment-&gt;offset);
1061         res = -1;
<span class="line-modified">1062       }</span>
<span class="line-modified">1063     }</span>
1064   } else {
1065     if (G_LIKELY (running_time &gt;= base)) {
1066       *position = running_time - base;
1067       if (G_UNLIKELY (abs_rate != 1.0))
1068         *position = ceil (*position * abs_rate);
1069       if (G_UNLIKELY (stop &lt; *position + segment-&gt;offset)) {
1070         *position += segment-&gt;offset - stop;
1071         res = -1;
1072       } else {
1073         *position = stop - *position - segment-&gt;offset;
1074         res = 1;
1075       }
1076     } else {
1077       /* This case is tricky. Requested running time precedes the
1078        * segment base, so in a reversed segment where rate &lt; 0, that
1079        * means it&#39;s before the alignment point of (stop - offset).
1080        * Before = always bigger than (stop-offset), which is usually +ve,
1081        * but could be -ve is offset is big enough. -ve position implies
1082        * that the offset has clipped away the entire segment anyway */
1083       *position = base - running_time;
</pre>
</td>
</tr>
</table>
<center><a href="gstsample.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstsegment.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>