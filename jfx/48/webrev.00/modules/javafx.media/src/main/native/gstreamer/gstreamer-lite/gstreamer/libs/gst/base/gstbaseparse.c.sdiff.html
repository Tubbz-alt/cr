<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstbaseparse.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstadapter.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstbaseparse.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstbaseparse.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  30  * This base class is for parser elements that process data and splits it
  31  * into separate audio/video/whatever frames.
  32  *
  33  * It provides for:
  34  *
  35  *   * provides one sink pad and one source pad
  36  *   * handles state changes
  37  *   * can operate in pull mode or push mode
  38  *   * handles seeking in both modes
  39  *   * handles events (SEGMENT/EOS/FLUSH)
  40  *   * handles queries (POSITION/DURATION/SEEKING/FORMAT/CONVERT)
  41  *   * handles flushing
  42  *
  43  * The purpose of this base class is to provide the basic functionality of
  44  * a parser and share a lot of rather complex code.
  45  *
  46  * # Description of the parsing mechanism:
  47  *
  48  * ## Set-up phase
  49  *
<span class="line-modified">  50  *  * #GstBaseParse calls @start to inform subclass that data processing is</span>
<span class="line-modified">  51  *    about to start now.</span>
  52  *
<span class="line-modified">  53  *  * #GstBaseParse class calls @set_sink_caps to inform the subclass about</span>
<span class="line-modified">  54  *    incoming sinkpad caps. Subclass could already set the srcpad caps</span>
<span class="line-modified">  55  *    accordingly, but this might be delayed until calling</span>
<span class="line-modified">  56  *    gst_base_parse_finish_frame() with a non-queued frame.</span>
  57  *
  58  *  * At least at this point subclass needs to tell the #GstBaseParse class
<span class="line-modified">  59  *    how big data chunks it wants to receive (min_frame_size). It can do</span>
<span class="line-modified">  60  *    this with gst_base_parse_set_min_frame_size().</span>
  61  *
  62  *  * #GstBaseParse class sets up appropriate data passing mode (pull/push)
  63  *    and starts to process the data.
  64  *
  65  * ## Parsing phase
  66  *
  67  *  * #GstBaseParse gathers at least min_frame_size bytes of data either
  68  *    by pulling it from upstream or collecting buffers in an internal
  69  *    #GstAdapter.
  70  *
<span class="line-modified">  71  *  * A buffer of (at least) min_frame_size bytes is passed to subclass with</span>
<span class="line-modified">  72  *    @handle_frame. Subclass checks the contents and can optionally</span>
<span class="line-modified">  73  *    return GST_FLOW_OK along with an amount of data to be skipped to find</span>
<span class="line-modified">  74  *    a valid frame (which will result in a subsequent DISCONT).</span>
<span class="line-modified">  75  *    If, otherwise, the buffer does not hold a complete frame,</span>
<span class="line-modified">  76  *    @handle_frame can merely return and will be called again when additional</span>
<span class="line-modified">  77  *    data is available.  In push mode this amounts to an</span>
<span class="line-modified">  78  *    additional input buffer (thus minimal additional latency), in pull mode</span>
<span class="line-modified">  79  *    this amounts to some arbitrary reasonable buffer size increase.</span>
<span class="line-modified">  80  *    Of course, gst_base_parse_set_min_frame_size() could also be used if a</span>
<span class="line-modified">  81  *    very specific known amount of additional data is required.</span>
<span class="line-modified">  82  *    If, however, the buffer holds a complete valid frame, it can pass</span>
<span class="line-modified">  83  *    the size of this frame to gst_base_parse_finish_frame().</span>
<span class="line-modified">  84  *    If acting as a converter, it can also merely indicate consumed input data</span>
<span class="line-modified">  85  *    while simultaneously providing custom output data.</span>
<span class="line-modified">  86  *    Note that baseclass performs some processing (such as tracking</span>
<span class="line-modified">  87  *    overall consumed data rate versus duration) for each finished frame,</span>
<span class="line-modified">  88  *    but other state is only updated upon each call to @handle_frame</span>



  89  *    (such as tracking upstream input timestamp).
  90  *
  91  *    Subclass is also responsible for setting the buffer metadata
  92  *    (e.g. buffer timestamp and duration, or keyframe if applicable).
  93  *    (although the latter can also be done by #GstBaseParse if it is
  94  *    appropriately configured, see below).  Frame is provided with
  95  *    timestamp derived from upstream (as much as generally possible),
  96  *    duration obtained from configuration (see below), and offset
  97  *    if meaningful (in pull mode).
  98  *
<span class="line-modified">  99  *    Note that @check_valid_frame might receive any small</span>
<span class="line-modified"> 100  *    amount of input data when leftover data is being drained (e.g. at EOS).</span>

 101  *
<span class="line-modified"> 102  *  * As part of finish frame processing,</span>
<span class="line-modified"> 103  *    just prior to actually pushing the buffer in question,</span>
<span class="line-modified"> 104  *    it is passed to @pre_push_frame which gives subclass yet one</span>
<span class="line-modified"> 105  *    last chance to examine buffer metadata, or to send some custom (tag)</span>
 106  *    events, or to perform custom (segment) filtering.
 107  *
 108  *  * During the parsing process #GstBaseParseClass will handle both srcpad
<span class="line-modified"> 109  *    and sinkpad events. They will be passed to subclass if @event or</span>
<span class="line-modified"> 110  *    @src_event callbacks have been provided.</span>

 111  *
 112  * ## Shutdown phase
 113  *
<span class="line-modified"> 114  * * #GstBaseParse class calls @stop to inform the subclass that data</span>
<span class="line-modified"> 115  *   parsing will be stopped.</span>
 116  *
<span class="line-modified"> 117  * Subclass is responsible for providing pad template caps for</span>
<span class="line-modified"> 118  * source and sink pads. The pads need to be named &quot;sink&quot; and &quot;src&quot;. It also</span>
<span class="line-modified"> 119  * needs to set the fixed caps on srcpad, when the format is ensured (e.g.</span>
<span class="line-modified"> 120  * when base class calls subclass&#39; @set_sink_caps function).</span>
 121  *
 122  * This base class uses %GST_FORMAT_DEFAULT as a meaning of frames. So,
 123  * subclass conversion routine needs to know that conversion from
 124  * %GST_FORMAT_TIME to %GST_FORMAT_DEFAULT must return the
 125  * frame number that can be found from the given byte position.
 126  *
 127  * #GstBaseParse uses subclasses conversion methods also for seeking (or
 128  * otherwise uses its own default one, see also below).
 129  *
 130  * Subclass @start and @stop functions will be called to inform the beginning
 131  * and end of data processing.
 132  *
 133  * Things that subclass need to take care of:
 134  *
 135  * * Provide pad templates
 136  * * Fixate the source pad caps when appropriate
 137  * * Inform base class how big data chunks should be retrieved. This is
 138  *   done with gst_base_parse_set_min_frame_size() function.
<span class="line-modified"> 139  * * Examine data chunks passed to subclass with @handle_frame and pass</span>
<span class="line-modified"> 140  *   proper frame(s) to gst_base_parse_finish_frame(), and setting src pad</span>
<span class="line-modified"> 141  *   caps and timestamps on frame.</span>

 142  * * Provide conversion functions
 143  * * Update the duration information with gst_base_parse_set_duration()
 144  * * Optionally passthrough using gst_base_parse_set_passthrough()
 145  * * Configure various baseparse parameters using
 146  *   gst_base_parse_set_average_bitrate(), gst_base_parse_set_syncable()
 147  *   and gst_base_parse_set_frame_rate().
 148  *
 149  * * In particular, if subclass is unable to determine a duration, but
 150  *   parsing (or specs) yields a frames per seconds rate, then this can be
<span class="line-modified"> 151  *   provided to #GstBaseParse to enable it to cater for</span>
<span class="line-modified"> 152  *   buffer time metadata (which will be taken from upstream as much as</span>
 153  *   possible). Internally keeping track of frame durations and respective
 154  *   sizes that have been pushed provides #GstBaseParse with an estimated
<span class="line-modified"> 155  *   bitrate. A default @convert (used if not overridden) will then use these</span>
<span class="line-modified"> 156  *   rates to perform obvious conversions.  These rates are also used to</span>
<span class="line-modified"> 157  *   update (estimated) duration at regular frame intervals.</span>

 158  *
 159  */
 160 
 161 /* TODO:
 162  *  - In push mode provide a queue of adapter-&quot;queued&quot; buffers for upstream
 163  *    buffer metadata
 164  *  - Queue buffers/events until caps are set
 165  */
 166 
 167 #ifdef HAVE_CONFIG_H
 168 #  include &quot;config.h&quot;
 169 #endif
 170 
 171 #include &lt;stdlib.h&gt;
 172 #include &lt;string.h&gt;
 173 
 174 #include &lt;gst/base/gstadapter.h&gt;
 175 
 176 #include &quot;gstbaseparse.h&quot;
 177 
</pre>
<hr />
<pre>
 188 #define GST_BASE_PARSE_FRAME_PRIVATE_FLAG_NOALLOC  (1 &lt;&lt; 0)
 189 
 190 #define MIN_FRAMES_TO_POST_BITRATE 10
 191 #define TARGET_DIFFERENCE          (20 * GST_SECOND)
 192 #define MAX_INDEX_ENTRIES          4096
 193 #define UPDATE_THRESHOLD           2
 194 
 195 #define ABSDIFF(a,b) (((a) &gt; (b)) ? ((a) - (b)) : ((b) - (a)))
 196 
 197 GST_DEBUG_CATEGORY_STATIC (gst_base_parse_debug);
 198 #define GST_CAT_DEFAULT gst_base_parse_debug
 199 
 200 /* Supported formats */
 201 static const GstFormat fmtlist[] = {
 202   GST_FORMAT_DEFAULT,
 203   GST_FORMAT_BYTES,
 204   GST_FORMAT_TIME,
 205   GST_FORMAT_UNDEFINED
 206 };
 207 
<span class="line-removed"> 208 #define GST_BASE_PARSE_GET_PRIVATE(obj)  \</span>
<span class="line-removed"> 209     (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_BASE_PARSE, GstBaseParsePrivate))</span>
<span class="line-removed"> 210 </span>
 211 struct _GstBaseParsePrivate
 212 {
 213   GstPadMode pad_mode;
 214 
 215   GstAdapter *adapter;
 216 
 217   gint64 duration;
 218   GstFormat duration_fmt;
 219   gint64 estimated_duration;
 220   gint64 estimated_drift;
 221 
 222   guint min_frame_size;
 223   gboolean disable_passthrough;
 224   gboolean passthrough;
 225   gboolean pts_interpolate;
 226   gboolean infer_ts;
 227   gboolean syncable;
 228   gboolean has_timing_info;
 229   guint fps_num, fps_den;
 230   gint update_interval;
</pre>
<hr />
<pre>
 324   /* TRUE if we&#39;re still detecting the format, i.e.
 325    * if ::detect() is still called for future buffers */
 326   gboolean detecting;
 327   GList *detect_buffers;
 328   guint detect_buffers_size;
 329 
 330   /* True when no buffers have been received yet */
 331   gboolean first_buffer;
 332 
 333   /* if TRUE, a STREAM_START event needs to be pushed */
 334   gboolean push_stream_start;
 335 
 336   /* When we need to skip more data than we have currently */
 337   guint skip;
 338 
 339   /* Tag handling (stream tags only, global tags are passed through as-is) */
 340   GstTagList *upstream_tags;
 341   GstTagList *parser_tags;
 342   GstTagMergeMode parser_tags_merge_mode;
 343   gboolean tags_changed;



 344 };
 345 
 346 typedef struct _GstBaseParseSeek
 347 {
 348   GstSegment segment;
 349   gboolean accurate;
 350   gint64 offset;
 351   GstClockTime start_ts;
 352 } GstBaseParseSeek;
 353 
 354 #define DEFAULT_DISABLE_PASSTHROUGH        FALSE
 355 
 356 enum
 357 {
 358   PROP_0,
 359   PROP_DISABLE_PASSTHROUGH,
 360   PROP_LAST
 361 };
 362 
 363 #define GST_BASE_PARSE_INDEX_LOCK(parse) \
 364   g_mutex_lock (&amp;parse-&gt;priv-&gt;index_lock);
 365 #define GST_BASE_PARSE_INDEX_UNLOCK(parse) \
 366   g_mutex_unlock (&amp;parse-&gt;priv-&gt;index_lock);
 367 
 368 static GstElementClass *parent_class = NULL;

 369 
 370 static void gst_base_parse_class_init (GstBaseParseClass * klass);
 371 static void gst_base_parse_init (GstBaseParse * parse,
 372     GstBaseParseClass * klass);
 373 
 374 GType
 375 gst_base_parse_get_type (void)
 376 {
 377   static volatile gsize base_parse_type = 0;
 378 
 379   if (g_once_init_enter (&amp;base_parse_type)) {
 380     static const GTypeInfo base_parse_info = {
 381       sizeof (GstBaseParseClass),
 382       (GBaseInitFunc) NULL,
 383       (GBaseFinalizeFunc) NULL,
 384       (GClassInitFunc) gst_base_parse_class_init,
 385       NULL,
 386       NULL,
 387       sizeof (GstBaseParse),
 388       0,
 389       (GInstanceInitFunc) gst_base_parse_init,
 390     };
 391     GType _type;
 392 
 393     _type = g_type_register_static (GST_TYPE_ELEMENT,
 394         &quot;GstBaseParse&quot;, &amp;base_parse_info, G_TYPE_FLAG_ABSTRACT);




 395     g_once_init_leave (&amp;base_parse_type, _type);
 396   }
 397   return (GType) base_parse_type;
 398 }
 399 






 400 static void gst_base_parse_finalize (GObject * object);
 401 
 402 static GstStateChangeReturn gst_base_parse_change_state (GstElement * element,
 403     GstStateChange transition);
 404 static void gst_base_parse_reset (GstBaseParse * parse);
 405 
 406 #if 0
 407 static void gst_base_parse_set_index (GstElement * element, GstIndex * index);
 408 static GstIndex *gst_base_parse_get_index (GstElement * element);
 409 #endif
 410 
 411 static gboolean gst_base_parse_sink_activate (GstPad * sinkpad,
 412     GstObject * parent);
 413 static gboolean gst_base_parse_sink_activate_mode (GstPad * pad,
 414     GstObject * parent, GstPadMode mode, gboolean active);
 415 static gboolean gst_base_parse_handle_seek (GstBaseParse * parse,
 416     GstEvent * event);
 417 static void gst_base_parse_set_upstream_tags (GstBaseParse * parse,
 418     GstTagList * taglist);
 419 
</pre>
<hr />
<pre>
 509   g_object_unref (parse-&gt;priv-&gt;adapter);
 510 
 511   if (parse-&gt;priv-&gt;index) {
 512     gst_object_unref (parse-&gt;priv-&gt;index);
 513     parse-&gt;priv-&gt;index = NULL;
 514   }
 515   g_mutex_clear (&amp;parse-&gt;priv-&gt;index_lock);
 516 
 517   gst_base_parse_clear_queues (parse);
 518 
 519   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 520 }
 521 
 522 static void
 523 gst_base_parse_class_init (GstBaseParseClass * klass)
 524 {
 525   GObjectClass *gobject_class;
 526   GstElementClass *gstelement_class;
 527 
 528   gobject_class = G_OBJECT_CLASS (klass);
<span class="line-modified"> 529   g_type_class_add_private (klass, sizeof (GstBaseParsePrivate));</span>



 530   parent_class = g_type_class_peek_parent (klass);
 531 
 532   gobject_class-&gt;finalize = GST_DEBUG_FUNCPTR (gst_base_parse_finalize);
 533   gobject_class-&gt;set_property = GST_DEBUG_FUNCPTR (gst_base_parse_set_property);
 534   gobject_class-&gt;get_property = GST_DEBUG_FUNCPTR (gst_base_parse_get_property);
 535 
 536   /**
 537    * GstBaseParse:disable-passthrough:
 538    *
 539    * If set to %TRUE, baseparse will unconditionally force parsing of the
 540    * incoming data. This can be required in the rare cases where the incoming
 541    * side-data (caps, pts, dts, ...) is not trusted by the user and wants to
 542    * force validation and parsing of the incoming data.
 543    * If set to %FALSE, decision of whether to parse the data or not is up to
 544    * the implementation (standard behaviour).
 545    */
 546   g_object_class_install_property (gobject_class, PROP_DISABLE_PASSTHROUGH,
 547       g_param_spec_boolean (&quot;disable-passthrough&quot;, &quot;Disable passthrough&quot;,
 548           &quot;Force processing (disables passthrough)&quot;,
 549           DEFAULT_DISABLE_PASSTHROUGH,
</pre>
<hr />
<pre>
 559 #endif
 560 
 561   /* Default handlers */
 562   klass-&gt;sink_event = gst_base_parse_sink_event_default;
 563   klass-&gt;src_event = gst_base_parse_src_event_default;
 564   klass-&gt;sink_query = gst_base_parse_sink_query_default;
 565   klass-&gt;src_query = gst_base_parse_src_query_default;
 566   klass-&gt;convert = gst_base_parse_convert_default;
 567 
 568   GST_DEBUG_CATEGORY_INIT (gst_base_parse_debug, &quot;baseparse&quot;, 0,
 569       &quot;baseparse element&quot;);
 570 }
 571 
 572 static void
 573 gst_base_parse_init (GstBaseParse * parse, GstBaseParseClass * bclass)
 574 {
 575   GstPadTemplate *pad_template;
 576 
 577   GST_DEBUG_OBJECT (parse, &quot;gst_base_parse_init&quot;);
 578 
<span class="line-modified"> 579   parse-&gt;priv = GST_BASE_PARSE_GET_PRIVATE (parse);</span>
 580 
 581   pad_template =
 582       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;sink&quot;);
 583   g_return_if_fail (pad_template != NULL);
 584   parse-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 585   gst_pad_set_event_function (parse-&gt;sinkpad,
 586       GST_DEBUG_FUNCPTR (gst_base_parse_sink_event));
 587   gst_pad_set_query_function (parse-&gt;sinkpad,
 588       GST_DEBUG_FUNCPTR (gst_base_parse_sink_query));
 589   gst_pad_set_chain_function (parse-&gt;sinkpad,
 590       GST_DEBUG_FUNCPTR (gst_base_parse_chain));
 591   gst_pad_set_activate_function (parse-&gt;sinkpad,
 592       GST_DEBUG_FUNCPTR (gst_base_parse_sink_activate));
 593   gst_pad_set_activatemode_function (parse-&gt;sinkpad,
 594       GST_DEBUG_FUNCPTR (gst_base_parse_sink_activate_mode));
 595   GST_PAD_SET_PROXY_ALLOCATION (parse-&gt;sinkpad);
 596   gst_element_add_pad (GST_ELEMENT (parse), parse-&gt;sinkpad);
 597 
 598   GST_DEBUG_OBJECT (parse, &quot;sinkpad created&quot;);
 599 
</pre>
<hr />
<pre>
 609   gst_element_add_pad (GST_ELEMENT (parse), parse-&gt;srcpad);
 610   GST_DEBUG_OBJECT (parse, &quot;src created&quot;);
 611 
 612   g_queue_init (&amp;parse-&gt;priv-&gt;queued_frames);
 613 
 614   parse-&gt;priv-&gt;adapter = gst_adapter_new ();
 615 
 616   parse-&gt;priv-&gt;pad_mode = GST_PAD_MODE_NONE;
 617 
 618   g_mutex_init (&amp;parse-&gt;priv-&gt;index_lock);
 619 
 620   /* init state */
 621   gst_base_parse_reset (parse);
 622   GST_DEBUG_OBJECT (parse, &quot;init ok&quot;);
 623 
 624   GST_OBJECT_FLAG_SET (parse, GST_ELEMENT_FLAG_INDEXABLE);
 625 
 626   parse-&gt;priv-&gt;upstream_tags = NULL;
 627   parse-&gt;priv-&gt;parser_tags = NULL;
 628   parse-&gt;priv-&gt;parser_tags_merge_mode = GST_TAG_MERGE_APPEND;

 629 }
 630 
 631 static void
 632 gst_base_parse_set_property (GObject * object, guint prop_id,
 633     const GValue * value, GParamSpec * pspec)
 634 {
 635   GstBaseParse *parse = GST_BASE_PARSE (object);
 636 
 637   switch (prop_id) {
 638     case PROP_DISABLE_PASSTHROUGH:
 639       parse-&gt;priv-&gt;disable_passthrough = g_value_get_boolean (value);
 640       break;
 641     default:
 642       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 643       break;
 644   }
 645 }
 646 
 647 static void
 648 gst_base_parse_get_property (GObject * object, guint prop_id, GValue * value,
 649     GParamSpec * pspec)
 650 {
 651   GstBaseParse *parse = GST_BASE_PARSE (object);
 652 
 653   switch (prop_id) {
 654     case PROP_DISABLE_PASSTHROUGH:
 655       g_value_set_boolean (value, parse-&gt;priv-&gt;disable_passthrough);
 656       break;
 657     default:
 658       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 659       break;
 660   }
 661 }
 662 









 663 GstBaseParseFrame *
 664 gst_base_parse_frame_copy (GstBaseParseFrame * frame)
 665 {
 666   GstBaseParseFrame *copy;
 667 
 668   copy = g_slice_dup (GstBaseParseFrame, frame);
 669   copy-&gt;buffer = gst_buffer_ref (frame-&gt;buffer);
 670   copy-&gt;_private_flags &amp;= ~GST_BASE_PARSE_FRAME_PRIVATE_FLAG_NOALLOC;
 671 
 672   GST_TRACE (&quot;copied frame %p -&gt; %p&quot;, frame, copy);
 673 
 674   return copy;
 675 }
 676 






 677 void
 678 gst_base_parse_frame_free (GstBaseParseFrame * frame)
 679 {
 680   GST_TRACE (&quot;freeing frame %p&quot;, frame);
 681 
 682   if (frame-&gt;buffer) {
 683     gst_buffer_unref (frame-&gt;buffer);
 684     frame-&gt;buffer = NULL;
 685   }
 686 
 687   if (!(frame-&gt;_private_flags &amp; GST_BASE_PARSE_FRAME_PRIVATE_FLAG_NOALLOC)) {
 688     g_slice_free (GstBaseParseFrame, frame);
 689   } else {
 690     memset (frame, 0, sizeof (*frame));
 691   }
 692 }
 693 
 694 G_DEFINE_BOXED_TYPE (GstBaseParseFrame, gst_base_parse_frame,
<span class="line-modified"> 695         (GBoxedCopyFunc) gst_base_parse_frame_copy,</span>
<span class="line-modified"> 696         (GBoxedFreeFunc) gst_base_parse_frame_free);</span>
 697 
 698 /**
 699  * gst_base_parse_frame_init:
 700  * @frame: #GstBaseParseFrame.
 701  *
 702  * Sets a #GstBaseParseFrame to initial state.  Currently this means
 703  * all public fields are zero-ed and a private flag is set to make
 704  * sure gst_base_parse_frame_free() only frees the contents but not
 705  * the actual frame. Use this function to initialise a #GstBaseParseFrame
 706  * allocated on the stack.
 707  */
 708 void
 709 gst_base_parse_frame_init (GstBaseParseFrame * frame)
 710 {
 711   memset (frame, 0, sizeof (GstBaseParseFrame));
 712   frame-&gt;_private_flags = GST_BASE_PARSE_FRAME_PRIVATE_FLAG_NOALLOC;
 713   GST_TRACE (&quot;inited frame %p&quot;, frame);
 714 }
 715 
 716 /**
</pre>
<hr />
<pre>
 785   parse-&gt;priv-&gt;saw_gaps = FALSE;
 786   parse-&gt;priv-&gt;offset = 0;
 787   parse-&gt;priv-&gt;sync_offset = 0;
 788   parse-&gt;priv-&gt;update_interval = -1;
 789   parse-&gt;priv-&gt;fps_num = parse-&gt;priv-&gt;fps_den = 0;
 790   parse-&gt;priv-&gt;frame_duration = GST_CLOCK_TIME_NONE;
 791   parse-&gt;priv-&gt;lead_in = parse-&gt;priv-&gt;lead_out = 0;
 792   parse-&gt;priv-&gt;lead_in_ts = parse-&gt;priv-&gt;lead_out_ts = 0;
 793   parse-&gt;priv-&gt;bitrate = 0;
 794   parse-&gt;priv-&gt;framecount = 0;
 795   parse-&gt;priv-&gt;bytecount = 0;
 796   parse-&gt;priv-&gt;acc_duration = 0;
 797   parse-&gt;priv-&gt;first_frame_pts = GST_CLOCK_TIME_NONE;
 798   parse-&gt;priv-&gt;first_frame_dts = GST_CLOCK_TIME_NONE;
 799   parse-&gt;priv-&gt;first_frame_offset = -1;
 800   parse-&gt;priv-&gt;estimated_duration = -1;
 801   parse-&gt;priv-&gt;estimated_drift = 0;
 802   parse-&gt;priv-&gt;next_pts = GST_CLOCK_TIME_NONE;
 803   parse-&gt;priv-&gt;next_dts = 0;
 804   parse-&gt;priv-&gt;syncable = TRUE;
<span class="line-removed"> 805   parse-&gt;priv-&gt;disable_passthrough = DEFAULT_DISABLE_PASSTHROUGH;</span>
 806   parse-&gt;priv-&gt;passthrough = FALSE;
 807   parse-&gt;priv-&gt;pts_interpolate = TRUE;
 808   parse-&gt;priv-&gt;infer_ts = TRUE;
 809   parse-&gt;priv-&gt;has_timing_info = FALSE;
 810   parse-&gt;priv-&gt;min_bitrate = G_MAXUINT;
 811   parse-&gt;priv-&gt;max_bitrate = 0;
 812   parse-&gt;priv-&gt;avg_bitrate = 0;
 813   parse-&gt;priv-&gt;posted_avg_bitrate = 0;
 814 
 815   parse-&gt;priv-&gt;index_last_ts = GST_CLOCK_TIME_NONE;
 816   parse-&gt;priv-&gt;index_last_offset = -1;
 817   parse-&gt;priv-&gt;index_last_valid = TRUE;
 818   parse-&gt;priv-&gt;upstream_seekable = FALSE;
 819   parse-&gt;priv-&gt;upstream_size = 0;
 820   parse-&gt;priv-&gt;upstream_has_duration = FALSE;
 821   parse-&gt;priv-&gt;upstream_format = GST_FORMAT_UNDEFINED;
 822   parse-&gt;priv-&gt;idx_interval = 0;
 823   parse-&gt;priv-&gt;idx_byte_interval = 0;
 824   parse-&gt;priv-&gt;exact_position = TRUE;
 825   parse-&gt;priv-&gt;seen_keyframe = FALSE;
</pre>
<hr />
<pre>
 847 
 848   if (parse-&gt;priv-&gt;adapter)
 849     gst_adapter_clear (parse-&gt;priv-&gt;adapter);
 850 
 851   gst_base_parse_set_upstream_tags (parse, NULL);
 852 
 853   if (parse-&gt;priv-&gt;parser_tags) {
 854     gst_tag_list_unref (parse-&gt;priv-&gt;parser_tags);
 855     parse-&gt;priv-&gt;parser_tags = NULL;
 856   }
 857   parse-&gt;priv-&gt;parser_tags_merge_mode = GST_TAG_MERGE_APPEND;
 858 
 859   parse-&gt;priv-&gt;new_frame = TRUE;
 860 
 861   parse-&gt;priv-&gt;first_buffer = TRUE;
 862 
 863   g_list_foreach (parse-&gt;priv-&gt;detect_buffers, (GFunc) gst_buffer_unref, NULL);
 864   g_list_free (parse-&gt;priv-&gt;detect_buffers);
 865   parse-&gt;priv-&gt;detect_buffers = NULL;
 866   parse-&gt;priv-&gt;detect_buffers_size = 0;


 867   GST_OBJECT_UNLOCK (parse);
 868 }
 869 
 870 static gboolean
 871 gst_base_parse_check_bitrate_tag (GstBaseParse * parse, const gchar * tag)
 872 {
 873   gboolean got_tag = FALSE;
 874   guint n = 0;
 875 
 876   if (parse-&gt;priv-&gt;upstream_tags != NULL)
 877     got_tag = gst_tag_list_get_uint (parse-&gt;priv-&gt;upstream_tags, tag, &amp;n);
 878 
 879   if (!got_tag &amp;&amp; parse-&gt;priv-&gt;parser_tags != NULL)
 880     got_tag = gst_tag_list_get_uint (parse-&gt;priv-&gt;parser_tags, tag, &amp;n);
 881 
 882   return got_tag;
 883 }
 884 
 885 /* check if upstream or subclass tags contain bitrates already */
 886 static void
</pre>
<hr />
<pre>
1152       GstCaps *caps;
1153 
1154       gst_event_parse_caps (event, &amp;caps);
1155       GST_DEBUG_OBJECT (parse, &quot;caps: %&quot; GST_PTR_FORMAT, caps);
1156 
1157       if (klass-&gt;set_sink_caps)
1158         ret = klass-&gt;set_sink_caps (parse, caps);
1159       else
1160         ret = TRUE;
1161 
1162       /* will send our own caps downstream */
1163       gst_event_unref (event);
1164       event = NULL;
1165       break;
1166     }
1167     case GST_EVENT_SEGMENT:
1168     {
1169       const GstSegment *in_segment;
1170       GstSegment out_segment;
1171       gint64 offset = 0, next_dts;
<span class="line-removed">1172       guint32 seqnum = gst_event_get_seqnum (event);</span>
1173 

1174       gst_event_parse_segment (event, &amp;in_segment);
1175       gst_segment_init (&amp;out_segment, GST_FORMAT_TIME);
1176       out_segment.rate = in_segment-&gt;rate;
1177       out_segment.applied_rate = in_segment-&gt;applied_rate;
1178 
<span class="line-modified">1179       GST_DEBUG_OBJECT (parse, &quot;segment %&quot; GST_SEGMENT_FORMAT, in_segment);</span>


1180 
1181       parse-&gt;priv-&gt;upstream_format = in_segment-&gt;format;
1182       if (in_segment-&gt;format == GST_FORMAT_BYTES) {
1183         GstBaseParseSeek *seek = NULL;
1184         GSList *node;
1185 
1186         /* stop time is allowed to be open-ended, but not start &amp; pos */
1187         offset = in_segment-&gt;time;
1188 
1189         GST_OBJECT_LOCK (parse);
1190         for (node = parse-&gt;priv-&gt;pending_seeks; node; node = node-&gt;next) {
1191           GstBaseParseSeek *tmp = node-&gt;data;
1192 
1193           if (tmp-&gt;offset == offset) {
1194             seek = tmp;
1195             break;
1196           }
1197         }
1198         parse-&gt;priv-&gt;pending_seeks =
1199             g_slist_remove (parse-&gt;priv-&gt;pending_seeks, seek);
</pre>
<hr />
<pre>
1211           next_dts = seek-&gt;start_ts;
1212           parse-&gt;priv-&gt;exact_position = seek-&gt;accurate;
1213           g_free (seek);
1214         } else {
1215           /* best attempt convert */
1216           /* as these are only estimates, stop is kept open-ended to avoid
1217            * premature cutting */
1218           gst_base_parse_convert (parse, GST_FORMAT_BYTES, in_segment-&gt;start,
1219               GST_FORMAT_TIME, (gint64 *) &amp; next_dts);
1220 
1221           out_segment.start = next_dts;
1222           out_segment.stop = GST_CLOCK_TIME_NONE;
1223           out_segment.time = next_dts;
1224 
1225           parse-&gt;priv-&gt;exact_position = (in_segment-&gt;start == 0);
1226         }
1227 
1228         gst_event_unref (event);
1229 
1230         event = gst_event_new_segment (&amp;out_segment);
<span class="line-modified">1231         gst_event_set_seqnum (event, seqnum);</span>
1232 
1233         GST_DEBUG_OBJECT (parse, &quot;Converted incoming segment to TIME. %&quot;
1234             GST_SEGMENT_FORMAT, in_segment);
1235 
1236       } else if (in_segment-&gt;format != GST_FORMAT_TIME) {
1237         /* Unknown incoming segment format. Output a default open-ended
1238          * TIME segment */
1239         gst_event_unref (event);
1240 
1241         out_segment.start = 0;
1242         out_segment.stop = GST_CLOCK_TIME_NONE;
1243         out_segment.time = 0;
1244 
1245         event = gst_event_new_segment (&amp;out_segment);
<span class="line-modified">1246         gst_event_set_seqnum (event, seqnum);</span>
1247 
1248         next_dts = 0;
1249       } else {
1250         /* not considered BYTE seekable if it is talking to us in TIME,
1251          * whatever else it might claim */
1252         parse-&gt;priv-&gt;upstream_seekable = FALSE;
1253         next_dts = in_segment-&gt;start;
1254         gst_event_copy_segment (event, &amp;out_segment);
1255       }
1256 


1257       memcpy (&amp;parse-&gt;segment, &amp;out_segment, sizeof (GstSegment));
1258 
1259       /*
1260          gst_segment_set_newsegment (&amp;parse-&gt;segment, update, rate,
<span class="line-modified">1261           applied_rate, format, start, stop, start);</span>
1262        */
1263 
1264       ret = TRUE;
1265 
1266       /* save the segment for later, right before we push a new buffer so that
1267        * the caps are fixed and the next linked element can receive
1268        * the segment but finish the current segment */
1269       GST_DEBUG_OBJECT (parse, &quot;draining current segment&quot;);
1270       if (in_segment-&gt;rate &gt; 0.0)
1271         gst_base_parse_drain (parse);
1272       else
1273         gst_base_parse_finish_fragment (parse, FALSE);
1274       gst_adapter_clear (parse-&gt;priv-&gt;adapter);
1275 
1276       parse-&gt;priv-&gt;offset = offset;
1277       parse-&gt;priv-&gt;sync_offset = offset;
1278       parse-&gt;priv-&gt;next_dts = next_dts;
1279       parse-&gt;priv-&gt;next_pts = GST_CLOCK_TIME_NONE;
1280       parse-&gt;priv-&gt;last_pts = GST_CLOCK_TIME_NONE;
1281       parse-&gt;priv-&gt;last_dts = GST_CLOCK_TIME_NONE;
</pre>
<hr />
<pre>
1415       }
1416 
1417       gst_base_parse_push_pending_events (parse);
1418 
1419       if (parse-&gt;segment.rate &gt; 0.0)
1420         gst_base_parse_drain (parse);
1421       else
1422         gst_base_parse_finish_fragment (parse, TRUE);
1423       forward_immediate = TRUE;
1424       parse-&gt;priv-&gt;saw_gaps = TRUE;
1425       break;
1426     }
1427     case GST_EVENT_TAG:
1428     {
1429       GstTagList *tags = NULL;
1430 
1431       gst_event_parse_tag (event, &amp;tags);
1432 
1433       /* We only care about stream tags here, global tags we just forward */
1434       if (gst_tag_list_get_scope (tags) != GST_TAG_SCOPE_STREAM)
<span class="line-modified">1435       break;</span>
1436 
1437       gst_base_parse_set_upstream_tags (parse, tags);
1438       gst_base_parse_queue_tag_event_update (parse);
1439       parse-&gt;priv-&gt;tags_changed = FALSE;
1440       gst_event_unref (event);
1441       event = NULL;
1442       ret = TRUE;
1443       break;
1444     }
1445     case GST_EVENT_STREAM_START:
1446     {
1447       if (parse-&gt;priv-&gt;pad_mode != GST_PAD_MODE_PULL)
1448         forward_immediate = TRUE;
1449 
1450       gst_base_parse_set_upstream_tags (parse, NULL);
1451       parse-&gt;priv-&gt;tags_changed = TRUE;
1452       break;
1453     }
1454     default:
1455       break;
</pre>
<hr />
<pre>
1639       if (gst_base_parse_is_seekable (parse))
1640         res = gst_base_parse_handle_seek (parse, event);
1641       break;
1642     default:
1643       res = gst_pad_event_default (parse-&gt;srcpad, GST_OBJECT_CAST (parse),
1644           event);
1645       break;
1646   }
1647   return res;
1648 }
1649 
1650 
1651 /**
1652  * gst_base_parse_convert_default:
1653  * @parse: #GstBaseParse.
1654  * @src_format: #GstFormat describing the source format.
1655  * @src_value: Source value to be converted.
1656  * @dest_format: #GstFormat defining the converted format.
1657  * @dest_value: (out): Pointer where the conversion result will be put.
1658  *
<span class="line-modified">1659  * Default implementation of &quot;convert&quot; vmethod in #GstBaseParse class.</span>
1660  *
1661  * Returns: %TRUE if conversion was successful.
1662  */
1663 gboolean
1664 gst_base_parse_convert_default (GstBaseParse * parse,
1665     GstFormat src_format,
1666     gint64 src_value, GstFormat dest_format, gint64 * dest_value)
1667 {
1668   gboolean ret = FALSE;
1669   guint64 bytes, duration;
1670 
1671   if (G_UNLIKELY (src_format == dest_format)) {
1672     *dest_value = src_value;
1673     return TRUE;
1674   }
1675 
1676   if (G_UNLIKELY (src_value == -1)) {
1677     *dest_value = -1;
1678     return TRUE;
1679   }
</pre>
<hr />
<pre>
1742   }
1743   return ret;
1744 
1745   /* ERRORS */
1746 no_framecount:
1747   {
1748     GST_DEBUG_OBJECT (parse, &quot;no framecount&quot;);
1749     return FALSE;
1750   }
1751 no_duration_bytes:
1752   {
1753     GST_DEBUG_OBJECT (parse, &quot;no duration %&quot; G_GUINT64_FORMAT &quot;, bytes %&quot;
1754         G_GUINT64_FORMAT, duration, bytes);
1755     return FALSE;
1756   }
1757 no_slaved_conversions:
1758   {
1759     GST_DEBUG_OBJECT (parse,
1760         &quot;Can&#39;t do format conversions when upstream format is not BYTES&quot;);
1761     return FALSE;
<span class="line-modified">1762 }</span>
1763 }
1764 
1765 static void
1766 gst_base_parse_update_duration (GstBaseParse * parse)
1767 {
1768   gint64 ptot, dest_value;
1769 
1770   if (!gst_pad_peer_query_duration (parse-&gt;sinkpad, GST_FORMAT_BYTES, &amp;ptot))
1771     return;
1772 
1773   if (!gst_base_parse_convert (parse, GST_FORMAT_BYTES, ptot,
1774           GST_FORMAT_TIME, &amp;dest_value))
1775     return;
1776 
1777   /* inform if duration changed, but try to avoid spamming */
1778   parse-&gt;priv-&gt;estimated_drift += dest_value - parse-&gt;priv-&gt;estimated_duration;
1779 
1780   parse-&gt;priv-&gt;estimated_duration = dest_value;
1781   GST_LOG_OBJECT (parse,
1782       &quot;updated estimated duration to %&quot; GST_TIME_FORMAT,
1783       GST_TIME_ARGS (dest_value));
1784 
<span class="line-modified">1785         if (parse-&gt;priv-&gt;estimated_drift &gt; GST_SECOND ||</span>
<span class="line-modified">1786             parse-&gt;priv-&gt;estimated_drift &lt; -GST_SECOND) {</span>
<span class="line-modified">1787           gst_element_post_message (GST_ELEMENT (parse),</span>
<span class="line-modified">1788               gst_message_new_duration_changed (GST_OBJECT (parse)));</span>
<span class="line-modified">1789           parse-&gt;priv-&gt;estimated_drift = 0;</span>
<span class="line-modified">1790         }</span>
<span class="line-modified">1791       }</span>
1792 
1793 /* gst_base_parse_update_bitrates:
1794  * @parse: #GstBaseParse.
1795  * @buffer: Current frame as a #GstBuffer
1796  *
1797  * Keeps track of the minimum and maximum bitrates, and also maintains a
1798  * running average bitrate of the stream so far.
1799  */
1800 static void
1801 gst_base_parse_update_bitrates (GstBaseParse * parse, GstBaseParseFrame * frame)
1802 {
1803   guint64 data_len, frame_dur;
1804   gint overhead;
1805   guint frame_bitrate;
1806   guint64 frame_bitrate64;
1807   GstBuffer *buffer = frame-&gt;buffer;
1808 
1809   overhead = frame-&gt;overhead;
1810   if (overhead == -1)
1811     return;
</pre>
<hr />
<pre>
1865   if (G_LIKELY (parse-&gt;priv-&gt;framecount &gt;= MIN_FRAMES_TO_POST_BITRATE)) {
1866     if (frame_bitrate &lt; parse-&gt;priv-&gt;min_bitrate) {
1867       parse-&gt;priv-&gt;min_bitrate = frame_bitrate;
1868       if (parse-&gt;priv-&gt;post_min_bitrate)
1869         parse-&gt;priv-&gt;tags_changed = TRUE;
1870     }
1871 
1872     if (frame_bitrate &gt; parse-&gt;priv-&gt;max_bitrate) {
1873       parse-&gt;priv-&gt;max_bitrate = frame_bitrate;
1874       if (parse-&gt;priv-&gt;post_max_bitrate)
1875         parse-&gt;priv-&gt;tags_changed = TRUE;
1876     }
1877 
1878     /* Only update the tag on a 2% change */
1879     if (parse-&gt;priv-&gt;post_avg_bitrate &amp;&amp; parse-&gt;priv-&gt;avg_bitrate) {
1880       guint64 diffprev = gst_util_uint64_scale (100,
1881           ABSDIFF (parse-&gt;priv-&gt;avg_bitrate, parse-&gt;priv-&gt;posted_avg_bitrate),
1882           parse-&gt;priv-&gt;avg_bitrate);
1883       if (diffprev &gt;= UPDATE_THRESHOLD)
1884         parse-&gt;priv-&gt;tags_changed = TRUE;

1885   }
1886 }
<span class="line-removed">1887 }</span>
1888 
1889 /**
1890  * gst_base_parse_add_index_entry:
1891  * @parse: #GstBaseParse.
1892  * @offset: offset of entry
1893  * @ts: timestamp associated with offset
1894  * @key: whether entry refers to keyframe
1895  * @force: add entry disregarding sanity checks
1896  *
1897  * Adds an entry to the index associating @offset to @ts.  It is recommended
1898  * to only add keyframe entries.  @force allows to bypass checks, such as
1899  * whether the stream is (upstream) seekable, another entry is already &quot;close&quot;
1900  * to the new entry, etc.
1901  *
1902  * Returns: #gboolean indicating whether entry was added
1903  */
1904 gboolean
1905 gst_base_parse_add_index_entry (GstBaseParse * parse, guint64 offset,
1906     GstClockTime ts, gboolean key, gboolean force)
1907 {
</pre>
<hr />
<pre>
2106   GstBaseParseFrame *frame = NULL;
2107 
2108   buffer = gst_buffer_make_writable (buffer);
2109 
2110   GST_LOG_OBJECT (parse,
2111       &quot;preparing frame at offset %&quot; G_GUINT64_FORMAT
2112       &quot; (%#&quot; G_GINT64_MODIFIER &quot;x) of size %&quot; G_GSIZE_FORMAT,
2113       GST_BUFFER_OFFSET (buffer), GST_BUFFER_OFFSET (buffer),
2114       gst_buffer_get_size (buffer));
2115 
2116   GST_BUFFER_OFFSET (buffer) = parse-&gt;priv-&gt;offset;
2117 
2118   gst_base_parse_update_flags (parse);
2119 
2120   frame = gst_base_parse_frame_new (buffer, 0, 0);
2121   gst_buffer_unref (buffer);
2122   gst_base_parse_update_frame (parse, frame);
2123 
2124   /* clear flags for next frame */
2125   parse-&gt;priv-&gt;discont = FALSE;
<span class="line-modified">2126     parse-&gt;priv-&gt;new_frame = FALSE;</span>
2127 
2128   /* use default handler to provide initial (upstream) metadata */
2129   gst_base_parse_parse_frame (parse, frame);
2130 
2131   return frame;
2132 }
2133 
2134 /* Wraps buffer in a frame and dispatches to subclass.
2135  * Also manages data skipping and offset handling (including adapter flushing).
2136  * Takes ownership of @buffer */
2137 static GstFlowReturn
2138 gst_base_parse_handle_buffer (GstBaseParse * parse, GstBuffer * buffer,
2139     gint * skip, gint * flushed)
2140 {
2141   GstBaseParseClass *klass = GST_BASE_PARSE_GET_CLASS (parse);
2142   GstBaseParseFrame *frame;
2143   GstFlowReturn ret;
2144 
2145   g_return_val_if_fail (skip != NULL || flushed != NULL, GST_FLOW_ERROR);
2146 
</pre>
<hr />
<pre>
2186       dts = gst_adapter_prev_dts (parse-&gt;priv-&gt;adapter, NULL);
2187       outbuf = gst_adapter_take_buffer (parse-&gt;priv-&gt;adapter, *skip);
2188 #ifdef GSTREAMER_LITE
2189       if (outbuf != NULL) {
2190 #endif // GSTREAMER_LITE
2191       outbuf = gst_buffer_make_writable (outbuf);
2192       GST_BUFFER_PTS (outbuf) = pts;
2193       GST_BUFFER_DTS (outbuf) = dts;
2194       parse-&gt;priv-&gt;buffers_head =
2195           g_slist_prepend (parse-&gt;priv-&gt;buffers_head, outbuf);
2196       outbuf = NULL;
2197 #ifdef GSTREAMER_LITE
2198       }
2199 #endif // GSTREAMER_LITE
2200     } else {
2201       /* If we&#39;re asked to skip more than is available in the adapter,
2202          we need to remember what we need to skip for next iteration */
2203       gsize av = gst_adapter_available (parse-&gt;priv-&gt;adapter);
2204       GST_DEBUG (&quot;Asked to skip %u (%&quot; G_GSIZE_FORMAT &quot; available)&quot;, *skip, av);
2205       if (av &gt;= *skip) {
<span class="line-modified">2206       gst_adapter_flush (parse-&gt;priv-&gt;adapter, *skip);</span>
2207       } else {
2208         GST_DEBUG
2209             (&quot;This is more than available, flushing %&quot; G_GSIZE_FORMAT
2210             &quot;, storing %u to skip&quot;, av, (guint) (*skip - av));
2211         parse-&gt;priv-&gt;skip = *skip - av;
2212         gst_adapter_flush (parse-&gt;priv-&gt;adapter, av);
2213         *skip = av;
<span class="line-modified">2214     }</span>
2215     }
2216     if (!parse-&gt;priv-&gt;discont)
2217       parse-&gt;priv-&gt;sync_offset = parse-&gt;priv-&gt;offset;
2218     parse-&gt;priv-&gt;offset += *skip;
2219     parse-&gt;priv-&gt;discont = TRUE;
2220     /* check for indefinite skipping */
2221     if (ret == GST_FLOW_OK)
2222       ret = gst_base_parse_check_sync (parse);
2223   }
2224 
2225   parse-&gt;priv-&gt;offset += *flushed;
2226 
2227   if (parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_PULL) {
2228     gst_adapter_clear (parse-&gt;priv-&gt;adapter);
2229   }
2230 
2231   if (*skip == 0 &amp;&amp; *flushed == 0) {
2232     /* Carry over discont if we need more data */
2233     if (GST_BUFFER_IS_DISCONT (frame-&gt;buffer))
2234       parse-&gt;priv-&gt;discont = TRUE;
</pre>
<hr />
<pre>
2439   /* Push pending events, including SEGMENT events */
2440   gst_base_parse_push_pending_events (parse);
2441 
2442   /* segment adjustment magic; only if we are running the whole show */
2443   if (!parse-&gt;priv-&gt;passthrough &amp;&amp; parse-&gt;segment.rate &gt; 0.0 &amp;&amp;
2444       (parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_PULL ||
2445           parse-&gt;priv-&gt;upstream_seekable)) {
2446     /* handle gaps */
2447     if (GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.position) &amp;&amp;
2448         GST_CLOCK_TIME_IS_VALID (last_start)) {
2449       GstClockTimeDiff diff;
2450 
2451       /* only send newsegments with increasing start times,
2452        * otherwise if these go back and forth downstream (sinks) increase
2453        * accumulated time and running_time */
2454       diff = GST_CLOCK_DIFF (parse-&gt;segment.position, last_start);
2455       if (G_UNLIKELY (diff &gt; 2 * GST_SECOND
2456               &amp;&amp; last_start &gt; parse-&gt;segment.start
2457               &amp;&amp; (!GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.stop)
2458                   || last_start &lt; parse-&gt;segment.stop))) {

2459 
2460         GST_DEBUG_OBJECT (parse,
2461             &quot;Gap of %&quot; G_GINT64_FORMAT &quot; ns detected in stream &quot; &quot;(%&quot;
2462             GST_TIME_FORMAT &quot; -&gt; %&quot; GST_TIME_FORMAT &quot;). &quot;
2463             &quot;Sending updated SEGMENT events&quot;, diff,
2464             GST_TIME_ARGS (parse-&gt;segment.position),
2465             GST_TIME_ARGS (last_start));
2466 
2467         /* skip gap FIXME */
<span class="line-modified">2468           gst_pad_push_event (parse-&gt;srcpad,</span>
<span class="line-modified">2469             gst_event_new_segment (&amp;parse-&gt;segment));</span>


2470 
2471         parse-&gt;segment.position = last_start;
<span class="line-removed">2472         }</span>
2473       }
2474     }

2475 
2476   /* update bitrates and optionally post corresponding tags
2477    * (following newsegment) */
2478   gst_base_parse_update_bitrates (parse, frame);
2479 
2480   if (klass-&gt;pre_push_frame) {
2481     ret = klass-&gt;pre_push_frame (parse, frame);
2482   } else {
2483     frame-&gt;flags |= GST_BASE_PARSE_FRAME_FLAG_CLIP;
2484   }
2485 
2486   /* Push pending events, if there are any new ones
2487    * like tags added by pre_push_frame */
2488   if (parse-&gt;priv-&gt;tags_changed) {
2489     gst_base_parse_queue_tag_event_update (parse);
2490     parse-&gt;priv-&gt;tags_changed = FALSE;
2491   }
2492   gst_base_parse_push_pending_events (parse);
2493 
2494   /* take final ownership of frame buffer */
2495   if (frame-&gt;out_buffer) {
2496     buffer = frame-&gt;out_buffer;
2497     frame-&gt;out_buffer = NULL;
2498     gst_buffer_replace (&amp;frame-&gt;buffer, NULL);
2499   } else {
<span class="line-modified">2500   buffer = frame-&gt;buffer;</span>
<span class="line-modified">2501   frame-&gt;buffer = NULL;</span>
2502   }
2503 
2504   /* subclass must play nice */
2505   g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
2506 
2507   size = gst_buffer_get_size (buffer);
2508 
2509   parse-&gt;priv-&gt;seen_keyframe |= parse-&gt;priv-&gt;is_video &amp;&amp;
2510       !GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DELTA_UNIT);
2511 
2512   if (frame-&gt;flags &amp; GST_BASE_PARSE_FRAME_FLAG_CLIP) {
2513     if (GST_BUFFER_TIMESTAMP_IS_VALID (buffer) &amp;&amp;
2514         GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.stop) &amp;&amp;
2515         GST_BUFFER_TIMESTAMP (buffer) &gt;
2516         parse-&gt;segment.stop + parse-&gt;priv-&gt;lead_out_ts) {
2517       GST_LOG_OBJECT (parse, &quot;Dropped frame, after segment&quot;);
2518       ret = GST_FLOW_EOS;
2519     } else if (GST_BUFFER_TIMESTAMP_IS_VALID (buffer) &amp;&amp;
2520         GST_BUFFER_DURATION_IS_VALID (buffer) &amp;&amp;
2521         GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.start) &amp;&amp;
</pre>
<hr />
<pre>
2549 
2550       /* in backwards playback mode, if on passthrough we need to push buffers
2551        * directly without accumulating them into the buffers_queued as baseparse
2552        * will never check for a DISCONT while on passthrough and those buffers
2553        * will never be pushed.
2554        *
2555        * also, as we are on reverse playback, it might be possible that
2556        * passthrough might have just been enabled, so make sure to drain the
2557        * buffers_queued list */
2558       if (G_UNLIKELY (parse-&gt;priv-&gt;buffers_queued != NULL)) {
2559         gst_base_parse_finish_fragment (parse, TRUE);
2560         ret = gst_base_parse_send_buffers (parse);
2561       }
2562 
2563       if (ret == GST_FLOW_OK) {
2564         GST_LOG_OBJECT (parse,
2565             &quot;pushing frame (%&quot; G_GSIZE_FORMAT &quot; bytes) now..&quot;, size);
2566         ret = gst_pad_push (parse-&gt;srcpad, buffer);
2567         GST_LOG_OBJECT (parse, &quot;frame pushed, flow %s&quot;,
2568             gst_flow_get_name (ret));
<span class="line-modified">2569     } else {</span>
2570         GST_LOG_OBJECT (parse,
2571             &quot;frame (%&quot; G_GSIZE_FORMAT &quot; bytes) not pushed: %s&quot;, size,
2572             gst_flow_get_name (ret));
2573         gst_buffer_unref (buffer);
2574       }
2575 
2576     } else {
2577       GST_LOG_OBJECT (parse, &quot;frame (%&quot; G_GSIZE_FORMAT &quot; bytes) queued for now&quot;,
2578           size);
2579       parse-&gt;priv-&gt;buffers_queued =
2580           g_slist_prepend (parse-&gt;priv-&gt;buffers_queued, buffer);
2581       ret = GST_FLOW_OK;
2582     }
2583   } else {
2584     GST_LOG_OBJECT (parse, &quot;frame (%&quot; G_GSIZE_FORMAT &quot; bytes) not pushed: %s&quot;,
2585         size, gst_flow_get_name (ret));
2586     gst_buffer_unref (buffer);
2587     /* if we are not sufficiently in control, let upstream decide on EOS */
2588     if (ret == GST_FLOW_EOS &amp;&amp; !parse-&gt;priv-&gt;disable_passthrough &amp;&amp;
2589         (parse-&gt;priv-&gt;passthrough ||
</pre>
<hr />
<pre>
2839  * - drain the resulting current fragment data (i.e. repeated chain)
2840  * - add time/duration (if needed) to frames queued by chain
2841  * - push queued data
2842  */
2843 static GstFlowReturn
2844 gst_base_parse_finish_fragment (GstBaseParse * parse, gboolean prev_head)
2845 {
2846   GstBuffer *buf;
2847   GstFlowReturn ret = GST_FLOW_OK;
2848   gboolean seen_key = FALSE, seen_delta = FALSE;
2849 
2850   GST_LOG_OBJECT (parse, &quot;finishing fragment&quot;);
2851 
2852   /* restore order */
2853   parse-&gt;priv-&gt;buffers_pending = g_slist_reverse (parse-&gt;priv-&gt;buffers_pending);
2854   while (parse-&gt;priv-&gt;buffers_pending) {
2855     buf = GST_BUFFER_CAST (parse-&gt;priv-&gt;buffers_pending-&gt;data);
2856     if (prev_head) {
2857       GST_LOG_OBJECT (parse, &quot;adding pending buffer (size %&quot; G_GSIZE_FORMAT &quot;)&quot;,
2858           gst_buffer_get_size (buf));
<span class="line-modified">2859     gst_adapter_push (parse-&gt;priv-&gt;adapter, buf);</span>
2860     } else {
2861       GST_LOG_OBJECT (parse, &quot;discarding head buffer&quot;);
2862       gst_buffer_unref (buf);
2863     }
2864     parse-&gt;priv-&gt;buffers_pending =
2865         g_slist_delete_link (parse-&gt;priv-&gt;buffers_pending,
2866         parse-&gt;priv-&gt;buffers_pending);
2867   }
2868 
2869   /* chain looks for frames and queues resulting ones (in stead of pushing) */
2870   /* initial skipped data is added to buffers_pending */
2871   gst_base_parse_drain (parse);
2872 
2873   if (parse-&gt;priv-&gt;buffers_send) {
2874     buf = GST_BUFFER_CAST (parse-&gt;priv-&gt;buffers_send-&gt;data);
2875     seen_key |= !GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
2876   }
2877 
2878   /* add metadata (if needed to queued buffers */
2879   GST_LOG_OBJECT (parse, &quot;last timestamp: %&quot; GST_TIME_FORMAT,
2880       GST_TIME_ARGS (parse-&gt;priv-&gt;last_pts));
2881   while (parse-&gt;priv-&gt;buffers_queued) {
2882     buf = GST_BUFFER_CAST (parse-&gt;priv-&gt;buffers_queued-&gt;data);
2883 
2884     /* no touching if upstream or parsing provided time */
2885     if (GST_BUFFER_PTS_IS_VALID (buf)) {
2886       GST_LOG_OBJECT (parse, &quot;buffer has time %&quot; GST_TIME_FORMAT,
2887           GST_TIME_ARGS (GST_BUFFER_PTS (buf)));
2888     } else if (GST_BUFFER_DURATION_IS_VALID (buf)) {
2889       if (GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;last_pts)) {
2890         if (G_LIKELY (GST_BUFFER_DURATION (buf) &lt;= parse-&gt;priv-&gt;last_pts))
2891           parse-&gt;priv-&gt;last_pts -= GST_BUFFER_DURATION (buf);
<span class="line-modified">2892       else</span>
2893           parse-&gt;priv-&gt;last_pts = 0;
2894         GST_BUFFER_PTS (buf) = parse-&gt;priv-&gt;last_pts;
<span class="line-modified">2895       GST_LOG_OBJECT (parse, &quot;applied time %&quot; GST_TIME_FORMAT,</span>
2896             GST_TIME_ARGS (GST_BUFFER_PTS (buf)));
2897       }
2898       if (GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;last_dts)) {
2899         if (G_LIKELY (GST_BUFFER_DURATION (buf) &lt;= parse-&gt;priv-&gt;last_dts))
2900           parse-&gt;priv-&gt;last_dts -= GST_BUFFER_DURATION (buf);
2901         else
2902           parse-&gt;priv-&gt;last_dts = 0;
2903         GST_BUFFER_DTS (buf) = parse-&gt;priv-&gt;last_dts;
2904         GST_LOG_OBJECT (parse, &quot;applied dts %&quot; GST_TIME_FORMAT,
2905             GST_TIME_ARGS (GST_BUFFER_DTS (buf)));
2906       }
2907     } else {
2908       /* no idea, very bad */
2909       GST_WARNING_OBJECT (parse, &quot;could not determine time for buffer&quot;);
2910     }
2911 
2912     parse-&gt;priv-&gt;last_pts = GST_BUFFER_PTS (buf);
2913     parse-&gt;priv-&gt;last_dts = GST_BUFFER_DTS (buf);
2914 
2915     /* reverse order for ascending sending */
</pre>
<hr />
<pre>
3153 
3154   if (G_LIKELY (buffer)) {
3155     GST_LOG_OBJECT (parse,
3156         &quot;buffer size: %&quot; G_GSIZE_FORMAT &quot;, offset = %&quot; G_GINT64_FORMAT
3157         &quot;, dts %&quot; GST_TIME_FORMAT &quot;, pts %&quot; GST_TIME_FORMAT,
3158         gst_buffer_get_size (buffer), GST_BUFFER_OFFSET (buffer),
3159         GST_TIME_ARGS (GST_BUFFER_DTS (buffer)),
3160         GST_TIME_ARGS (GST_BUFFER_PTS (buffer)));
3161 
3162     if (G_UNLIKELY (!parse-&gt;priv-&gt;disable_passthrough
3163             &amp;&amp; parse-&gt;priv-&gt;passthrough)) {
3164       GstBaseParseFrame frame;
3165 
3166       gst_base_parse_frame_init (&amp;frame);
3167       frame.buffer = gst_buffer_make_writable (buffer);
3168       ret = gst_base_parse_push_frame (parse, &amp;frame);
3169       gst_base_parse_frame_free (&amp;frame);
3170       return ret;
3171     }
3172     if (G_UNLIKELY (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT))) {
<span class="line-modified">3173     /* upstream feeding us in reverse playback;</span>
<span class="line-modified">3174      * finish previous fragment and start new upon DISCONT */</span>
<span class="line-modified">3175     if (parse-&gt;segment.rate &lt; 0.0) {</span>
3176         GST_DEBUG_OBJECT (parse, &quot;buffer starts new reverse playback fragment&quot;);
3177         ret = gst_base_parse_finish_fragment (parse, TRUE);
3178         gst_base_parse_start_fragment (parse);
3179       } else {
3180         /* discont in the stream, drain and mark discont for next output */
3181         gst_base_parse_drain (parse);
3182         parse-&gt;priv-&gt;discont = TRUE;
3183       }
3184     }
3185     gst_adapter_push (parse-&gt;priv-&gt;adapter, buffer);
3186   }
3187 
3188   /* Parse and push as many frames as possible */
3189   /* Stop either when adapter is empty or we are flushing */
3190   while (!parse-&gt;priv-&gt;flushing) {
3191     gint flush = 0;
3192     gboolean updated_prev_pts = FALSE;
3193 
3194     /* note: if subclass indicates MAX fsize,
3195      * this will not likely be available anyway ... */
<span class="line-modified">3196       min_size = MAX (parse-&gt;priv-&gt;min_frame_size, fsize);</span>
<span class="line-modified">3197       av = gst_adapter_available (parse-&gt;priv-&gt;adapter);</span>
<span class="line-removed">3198 </span>
<span class="line-removed">3199       if (G_UNLIKELY (parse-&gt;priv-&gt;drain)) {</span>
<span class="line-removed">3200         min_size = av;</span>
<span class="line-removed">3201         GST_DEBUG_OBJECT (parse, &quot;draining, data left: %d&quot;, min_size);</span>
<span class="line-removed">3202         if (G_UNLIKELY (!min_size)) {</span>
<span class="line-removed">3203           goto done;</span>
<span class="line-removed">3204         }</span>
<span class="line-removed">3205       }</span>
3206 
<span class="line-modified">3207       /* Collect at least min_frame_size bytes */</span>
<span class="line-modified">3208       if (av &lt; min_size) {</span>
<span class="line-modified">3209       GST_DEBUG_OBJECT (parse, &quot;not enough data available (only %d bytes)&quot;, av);</span>

3210         goto done;
3211       }







3212 
3213     /* move along with upstream timestamp (if any),
3214      * but interpolate in between */
3215     pts = gst_adapter_prev_pts (parse-&gt;priv-&gt;adapter, NULL);
3216     dts = gst_adapter_prev_dts (parse-&gt;priv-&gt;adapter, NULL);
3217     if (GST_CLOCK_TIME_IS_VALID (pts) &amp;&amp; (parse-&gt;priv-&gt;prev_pts != pts)) {
3218       parse-&gt;priv-&gt;prev_pts = parse-&gt;priv-&gt;next_pts = pts;
3219       updated_prev_pts = TRUE;
3220     }
3221 
3222     if (GST_CLOCK_TIME_IS_VALID (dts) &amp;&amp; (parse-&gt;priv-&gt;prev_dts != dts)) {
3223       parse-&gt;priv-&gt;prev_dts = parse-&gt;priv-&gt;next_dts = dts;
3224       parse-&gt;priv-&gt;prev_dts_from_pts = FALSE;
3225     }
3226 
3227     /* we can mess with, erm interpolate, timestamps,
3228      * and incoming stuff has PTS but no DTS seen so far,
3229      * then pick up DTS from PTS and hope for the best ... */
3230     if (parse-&gt;priv-&gt;infer_ts &amp;&amp;
3231         parse-&gt;priv-&gt;pts_interpolate &amp;&amp;
3232         !GST_CLOCK_TIME_IS_VALID (dts) &amp;&amp;
3233         (!GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;prev_dts)
3234             || (parse-&gt;priv-&gt;prev_dts_from_pts &amp;&amp; updated_prev_pts))
3235         &amp;&amp; GST_CLOCK_TIME_IS_VALID (pts)) {
3236       parse-&gt;priv-&gt;prev_dts = parse-&gt;priv-&gt;next_dts = pts;
3237       parse-&gt;priv-&gt;prev_dts_from_pts = TRUE;
3238     }
3239 
<span class="line-modified">3240       /* always pass all available data */</span>
3241     tmpbuf = gst_adapter_get_buffer (parse-&gt;priv-&gt;adapter, av);
3242 
3243     /* already inform subclass what timestamps we have planned,
3244      * at least if provided by time-based upstream */
3245     if (parse-&gt;priv-&gt;upstream_format == GST_FORMAT_TIME) {
3246       tmpbuf = gst_buffer_make_writable (tmpbuf);
3247       GST_BUFFER_PTS (tmpbuf) = parse-&gt;priv-&gt;next_pts;
3248       GST_BUFFER_DTS (tmpbuf) = parse-&gt;priv-&gt;next_dts;
3249       GST_BUFFER_DURATION (tmpbuf) = GST_CLOCK_TIME_NONE;
<span class="line-modified">3250       }</span>
3251 
3252     /* keep the adapter mapped, so keep track of what has to be flushed */
3253     ret = gst_base_parse_handle_buffer (parse, tmpbuf, &amp;skip, &amp;flush);
3254     tmpbuf = NULL;
3255 
3256     if (ret != GST_FLOW_OK &amp;&amp; ret != GST_FLOW_NOT_LINKED) {
<span class="line-modified">3257           goto done;</span>
<span class="line-modified">3258         }</span>
3259     if (skip == 0 &amp;&amp; flush == 0) {
3260       GST_LOG_OBJECT (parse, &quot;nothing skipped and no frames finished, &quot;
3261           &quot;breaking to get more data&quot;);
3262       /* ignore this return as it produced no data */
3263       ret = old_ret;
<span class="line-modified">3264         goto done;</span>
<span class="line-removed">3265       }</span>
<span class="line-removed">3266     if (old_ret == GST_FLOW_OK)</span>
<span class="line-removed">3267     old_ret = ret;</span>
3268     }



3269 
3270 done:
3271   GST_LOG_OBJECT (parse, &quot;chain leaving&quot;);
3272   return ret;
3273 }
3274 
3275 /* pull @size bytes at current offset,
3276  * i.e. at least try to and possibly return a shorter buffer if near the end */
3277 static GstFlowReturn
3278 gst_base_parse_pull_range (GstBaseParse * parse, guint size,
3279     GstBuffer ** buffer)
3280 {
3281   GstFlowReturn ret = GST_FLOW_OK;
3282 
3283   g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
3284 
3285   /* Caching here actually makes much less difference than one would expect.
3286    * We do it mainly to avoid pulling buffers of 1 byte all the time */
3287   if (parse-&gt;priv-&gt;cache) {
3288     gint64 cache_offset = GST_BUFFER_OFFSET (parse-&gt;priv-&gt;cache);
</pre>
<hr />
<pre>
3296       if (buffer == NULL)
3297         return GST_FLOW_ERROR;
3298 #endif // GSTREAMER_LITE
3299       GST_BUFFER_OFFSET (*buffer) = parse-&gt;priv-&gt;offset;
3300       return GST_FLOW_OK;
3301     }
3302     /* not enough data in the cache, free cache and get a new one */
3303     gst_buffer_unref (parse-&gt;priv-&gt;cache);
3304     parse-&gt;priv-&gt;cache = NULL;
3305   }
3306 
3307   /* refill the cache */
3308   ret =
3309       gst_pad_pull_range (parse-&gt;sinkpad, parse-&gt;priv-&gt;offset, MAX (size,
3310           64 * 1024), &amp;parse-&gt;priv-&gt;cache);
3311   if (ret != GST_FLOW_OK) {
3312     parse-&gt;priv-&gt;cache = NULL;
3313     return ret;
3314   }
3315 
<span class="line-removed">3316   if (gst_buffer_get_size (parse-&gt;priv-&gt;cache) &gt;= size) {</span>
<span class="line-removed">3317     *buffer =</span>
<span class="line-removed">3318         gst_buffer_copy_region (parse-&gt;priv-&gt;cache, GST_BUFFER_COPY_ALL, 0,</span>
<span class="line-removed">3319         size);</span>
<span class="line-removed">3320 #ifdef GSTREAMER_LITE</span>
<span class="line-removed">3321     if (buffer == NULL)</span>
<span class="line-removed">3322       return GST_FLOW_ERROR;</span>
<span class="line-removed">3323 #endif // GSTREAMER_LITE</span>
<span class="line-removed">3324     GST_BUFFER_OFFSET (*buffer) = parse-&gt;priv-&gt;offset;</span>
<span class="line-removed">3325     return GST_FLOW_OK;</span>
<span class="line-removed">3326   }</span>
<span class="line-removed">3327 </span>
<span class="line-removed">3328   /* Not possible to get enough data, try a last time with</span>
<span class="line-removed">3329    * requesting exactly the size we need */</span>
<span class="line-removed">3330   gst_buffer_unref (parse-&gt;priv-&gt;cache);</span>
<span class="line-removed">3331   parse-&gt;priv-&gt;cache = NULL;</span>
<span class="line-removed">3332 </span>
<span class="line-removed">3333   ret = gst_pad_pull_range (parse-&gt;sinkpad, parse-&gt;priv-&gt;offset, size,</span>
<span class="line-removed">3334       &amp;parse-&gt;priv-&gt;cache);</span>
<span class="line-removed">3335 </span>
<span class="line-removed">3336   if (ret != GST_FLOW_OK) {</span>
<span class="line-removed">3337     GST_DEBUG_OBJECT (parse, &quot;pull_range returned %d&quot;, ret);</span>
<span class="line-removed">3338     *buffer = NULL;</span>
<span class="line-removed">3339     return ret;</span>
<span class="line-removed">3340   }</span>
<span class="line-removed">3341 </span>
3342   if (gst_buffer_get_size (parse-&gt;priv-&gt;cache) &lt; size) {
3343     GST_DEBUG_OBJECT (parse, &quot;Returning short buffer at offset %&quot;
3344         G_GUINT64_FORMAT &quot;: wanted %u bytes, got %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
3345         parse-&gt;priv-&gt;offset, size, gst_buffer_get_size (parse-&gt;priv-&gt;cache));
3346 
3347     *buffer = parse-&gt;priv-&gt;cache;
3348     parse-&gt;priv-&gt;cache = NULL;
3349 
3350     return GST_FLOW_OK;
3351   }
3352 
3353   *buffer =
3354       gst_buffer_copy_region (parse-&gt;priv-&gt;cache, GST_BUFFER_COPY_ALL, 0, size);
3355 #ifdef GSTREAMER_LITE
3356   if (buffer == NULL)
3357     return GST_FLOW_ERROR;
3358 #endif // GSTREAMER_LITE
3359   GST_BUFFER_OFFSET (*buffer) = parse-&gt;priv-&gt;offset;
3360 
3361   return GST_FLOW_OK;
</pre>
<hr />
<pre>
3456     /* if we got a short read, inform subclass we are draining leftover
3457      * and no more is to be expected */
3458     if (gst_buffer_get_size (buffer) &lt; min_size) {
3459       GST_LOG_OBJECT (parse, &quot;... but did not get that; marked draining&quot;);
3460       parse-&gt;priv-&gt;drain = TRUE;
3461     }
3462 
3463     if (parse-&gt;priv-&gt;detecting) {
3464       ret = klass-&gt;detect (parse, buffer);
3465       if (ret == GST_FLOW_NOT_NEGOTIATED) {
3466         /* If draining we error out, otherwise request a buffer
3467          * with 64kb more */
3468         if (parse-&gt;priv-&gt;drain) {
3469           gst_buffer_unref (buffer);
3470           GST_ERROR_OBJECT (parse, &quot;Failed to detect format but draining&quot;);
3471           return GST_FLOW_ERROR;
3472         } else {
3473           fsize += 64 * 1024;
3474           gst_buffer_unref (buffer);
3475           continue;
<span class="line-modified">3476     }</span>
3477       } else if (ret != GST_FLOW_OK) {
<span class="line-modified">3478     gst_buffer_unref (buffer);</span>
3479         GST_ERROR_OBJECT (parse, &quot;detect() returned %s&quot;,
3480             gst_flow_get_name (ret));
3481         return ret;
<span class="line-modified">3482     }</span>
3483 
3484       /* Else handle this buffer normally */
<span class="line-modified">3485   }</span>
3486 
3487     ret = gst_base_parse_handle_buffer (parse, buffer, &amp;skip, &amp;flushed);
3488     if (ret != GST_FLOW_OK)
3489       break;
3490 
3491     /* If a large amount of data was requested to be skipped, _handle_buffer
3492        might have set the priv-&gt;skip flag to an extra amount on top of skip.
3493        In pull mode, we can just pull from the new offset directly. */
3494     parse-&gt;priv-&gt;offset += parse-&gt;priv-&gt;skip;
3495     parse-&gt;priv-&gt;skip = 0;
3496 
3497     /* something flushed means something happened,
3498      * and we should bail out of this loop so as not to occupy
3499      * the task thread indefinitely */
3500     if (flushed) {
3501       GST_LOG_OBJECT (parse, &quot;frame finished, breaking loop&quot;);
3502       break;
3503     }
3504     /* nothing flushed, no skip and draining, so nothing left to do */
3505     if (!skip &amp;&amp; parse-&gt;priv-&gt;drain) {
3506       GST_LOG_OBJECT (parse, &quot;no activity or result when draining; &quot;
3507           &quot;breaking loop and marking EOS&quot;);
3508       ret = GST_FLOW_EOS;
3509       break;
3510     }
3511     /* otherwise, get some more data
3512      * note that is checked this does not happen indefinitely */
3513     if (!skip) {
3514       GST_LOG_OBJECT (parse, &quot;getting some more data&quot;);
3515       fsize += 64 * 1024;
<span class="line-modified">3516   }</span>
3517     parse-&gt;priv-&gt;drain = FALSE;
3518   }
3519 
3520 done:
3521   return ret;
3522 }
3523 
3524 /* Loop that is used in pull mode to retrieve data from upstream */
3525 static void
3526 gst_base_parse_loop (GstPad * pad)
3527 {
3528   GstBaseParse *parse;
3529   GstBaseParseClass *klass;
3530   GstFlowReturn ret = GST_FLOW_OK;
3531 
3532   parse = GST_BASE_PARSE (gst_pad_get_parent (pad));
3533   klass = GST_BASE_PARSE_GET_CLASS (parse);
3534 
3535   GST_LOG_OBJECT (parse, &quot;Entering parse loop&quot;);
3536 
</pre>
<hr />
<pre>
3618             gst_message_new_segment_done (GST_OBJECT_CAST (parse),
3619                 GST_FORMAT_TIME, stop));
3620         gst_pad_push_event (parse-&gt;srcpad,
3621             gst_event_new_segment_done (GST_FORMAT_TIME, stop));
3622       } else {
3623         /* If we STILL have zero frames processed, fire an error */
3624         if (parse-&gt;priv-&gt;framecount == 0) {
3625           GST_ELEMENT_ERROR (parse, STREAM, WRONG_TYPE,
3626               (&quot;No valid frames found before end of stream&quot;), (NULL));
3627         }
3628         push_eos = TRUE;
3629       }
3630     } else if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS) {
3631       /* for fatal errors we post an error message, wrong-state is
3632        * not fatal because it happens due to flushes and only means
3633        * that we should stop now. */
3634       GST_ELEMENT_FLOW_ERROR (parse, ret);
3635       push_eos = TRUE;
3636     }
3637     if (push_eos) {

3638       if (parse-&gt;priv-&gt;estimated_duration &lt;= 0) {
3639         gst_base_parse_update_duration (parse);
3640       }
3641       /* Push pending events, including SEGMENT events */
3642       gst_base_parse_push_pending_events (parse);
3643 
<span class="line-modified">3644       gst_pad_push_event (parse-&gt;srcpad, gst_event_new_eos ());</span>





3645     }
3646     gst_object_unref (parse);
3647   }
3648 }
3649 
3650 static gboolean
3651 gst_base_parse_sink_activate (GstPad * sinkpad, GstObject * parent)
3652 {
3653   GstSchedulingFlags sched_flags;
3654   GstBaseParse *parse;
3655   GstQuery *query;
3656   gboolean pull_mode;
3657 
3658   parse = GST_BASE_PARSE (parent);
3659 
3660   GST_DEBUG_OBJECT (parse, &quot;sink activate&quot;);
3661 
3662   query = gst_query_new_scheduling ();
3663   if (!gst_pad_peer_query (sinkpad, query)) {
3664     gst_query_unref (query);
3665     goto baseparse_push;
3666   }
3667 
3668   gst_query_parse_scheduling (query, &amp;sched_flags, NULL, NULL, NULL);
3669 
3670   pull_mode = gst_query_has_scheduling_mode (query, GST_PAD_MODE_PULL)
3671       &amp;&amp; ((sched_flags &amp; GST_SCHEDULING_FLAG_SEEKABLE) != 0);
3672 
3673   gst_query_unref (query);
3674 
3675   if (!pull_mode)
3676     goto baseparse_push;
3677 
<span class="line-modified">3678     GST_DEBUG_OBJECT (parse, &quot;trying to activate in pull mode&quot;);</span>
3679   if (!gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PULL, TRUE))
3680     goto baseparse_push;
3681 
3682   parse-&gt;priv-&gt;push_stream_start = TRUE;
3683   /* In pull mode, upstream is BYTES */
3684   parse-&gt;priv-&gt;upstream_format = GST_FORMAT_BYTES;
3685 
3686   return gst_pad_start_task (sinkpad, (GstTaskFunction) gst_base_parse_loop,
3687       sinkpad, NULL);
3688   /* fallback */
3689 baseparse_push:
3690   {
3691     GST_DEBUG_OBJECT (parse, &quot;trying to activate in push mode&quot;);
3692     return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PUSH, TRUE);
3693   }
3694 }
3695 
3696 static gboolean
3697 gst_base_parse_activate (GstBaseParse * parse, gboolean active)
3698 {
</pre>
<hr />
<pre>
3726   return result;
3727 }
3728 
3729 static gboolean
3730 gst_base_parse_sink_activate_mode (GstPad * pad, GstObject * parent,
3731     GstPadMode mode, gboolean active)
3732 {
3733   gboolean result;
3734   GstBaseParse *parse;
3735 
3736   parse = GST_BASE_PARSE (parent);
3737 
3738   GST_DEBUG_OBJECT (parse, &quot;sink %sactivate in %s mode&quot;,
3739       (active) ? &quot;&quot; : &quot;de&quot;, gst_pad_mode_get_name (mode));
3740 
3741   if (!gst_base_parse_activate (parse, active))
3742     goto activate_failed;
3743 
3744   switch (mode) {
3745     case GST_PAD_MODE_PULL:
<span class="line-modified">3746     if (active) {</span>


3747         parse-&gt;priv-&gt;pending_events =
<span class="line-modified">3748             g_list_prepend (parse-&gt;priv-&gt;pending_events,</span>
<span class="line-removed">3749             gst_event_new_segment (&amp;parse-&gt;segment));</span>
3750         result = TRUE;
<span class="line-modified">3751     } else {</span>
3752         result = gst_pad_stop_task (pad);
<span class="line-modified">3753     }</span>
3754       break;
3755     default:
3756       result = TRUE;
3757       break;
3758   }
3759   if (result)
3760     parse-&gt;priv-&gt;pad_mode = active ? mode : GST_PAD_MODE_NONE;
3761 
3762   GST_DEBUG_OBJECT (parse, &quot;sink activate return: %d&quot;, result);
3763 
3764   return result;
3765 
3766   /* ERRORS */
3767 activate_failed:
3768   {
3769     GST_DEBUG_OBJECT (parse, &quot;activate failed&quot;);
3770     return FALSE;
3771   }
3772 }
3773 
</pre>
<hr />
<pre>
3824  * @bitrate: average bitrate in bits/second
3825  *
3826  * Optionally sets the average bitrate detected in media (if non-zero),
3827  * e.g. based on metadata, as it will be posted to the application.
3828  *
3829  * By default, announced average bitrate is estimated. The average bitrate
3830  * is used to estimate the total duration of the stream and to estimate
3831  * a seek position, if there&#39;s no index and the format is syncable
3832  * (see gst_base_parse_set_syncable()).
3833  */
3834 void
3835 gst_base_parse_set_average_bitrate (GstBaseParse * parse, guint bitrate)
3836 {
3837   parse-&gt;priv-&gt;bitrate = bitrate;
3838   GST_DEBUG_OBJECT (parse, &quot;bitrate %u&quot;, bitrate);
3839 }
3840 
3841 /**
3842  * gst_base_parse_set_min_frame_size:
3843  * @parse: #GstBaseParse.
<span class="line-modified">3844  * @min_size: Minimum size of the data that this base class should give to</span>
<span class="line-modified">3845  *            subclass.</span>
3846  *
3847  * Subclass can use this function to tell the base class that it needs to
<span class="line-modified">3848  * give at least #min_size buffers.</span>
3849  */
3850 void
3851 gst_base_parse_set_min_frame_size (GstBaseParse * parse, guint min_size)
3852 {
3853   g_return_if_fail (parse != NULL);
3854 
3855   parse-&gt;priv-&gt;min_frame_size = min_size;
3856   GST_LOG_OBJECT (parse, &quot;set frame_min_size: %d&quot;, min_size);
3857 }
3858 
3859 /**
3860  * gst_base_parse_set_frame_rate:
3861  * @parse: the #GstBaseParse to set
3862  * @fps_num: frames per second (numerator).
3863  * @fps_den: frames per second (denominator).
3864  * @lead_in: frames needed before a segment for subsequent decode
3865  * @lead_out: frames needed after a segment
3866  *
3867  * If frames per second is configured, parser can take care of buffer duration
3868  * and timestamping.  When performing segment clipping, or seeking to a specific
</pre>
<hr />
<pre>
3936  *
3937  * Set if frame starts can be identified. This is set by default and
3938  * determines whether seeking based on bitrate averages
3939  * is possible for a format/stream.
3940  */
3941 void
3942 gst_base_parse_set_syncable (GstBaseParse * parse, gboolean syncable)
3943 {
3944   parse-&gt;priv-&gt;syncable = syncable;
3945   GST_INFO_OBJECT (parse, &quot;syncable: %s&quot;, (syncable) ? &quot;yes&quot; : &quot;no&quot;);
3946 }
3947 
3948 /**
3949  * gst_base_parse_set_passthrough:
3950  * @parse: a #GstBaseParse
3951  * @passthrough: %TRUE if parser should run in passthrough mode
3952  *
3953  * Set if the nature of the format or configuration does not allow (much)
3954  * parsing, and the parser should operate in passthrough mode (which only
3955  * applies when operating in push mode). That is, incoming buffers are
<span class="line-modified">3956  * pushed through unmodified, i.e. no @check_valid_frame or @parse_frame</span>
<span class="line-modified">3957  * callbacks will be invoked, but @pre_push_frame will still be invoked,</span>
<span class="line-modified">3958  * so subclass can perform as much or as little is appropriate for</span>
<span class="line-modified">3959  * passthrough semantics in @pre_push_frame.</span>
3960  */
3961 void
3962 gst_base_parse_set_passthrough (GstBaseParse * parse, gboolean passthrough)
3963 {
3964   parse-&gt;priv-&gt;passthrough = passthrough;
3965   GST_INFO_OBJECT (parse, &quot;passthrough: %s&quot;, (passthrough) ? &quot;yes&quot; : &quot;no&quot;);
3966 }
3967 
3968 /**
3969  * gst_base_parse_set_pts_interpolation:
3970  * @parse: a #GstBaseParse
3971  * @pts_interpolate: %TRUE if parser should interpolate PTS timestamps
3972  *
3973  * By default, the base class will guess PTS timestamps using a simple
3974  * interpolation (previous timestamp + duration), which is incorrect for
3975  * data streams with reordering, where PTS can go backward. Sub-classes
3976  * implementing such formats should disable PTS interpolation.
3977  */
3978 void
3979 gst_base_parse_set_pts_interpolation (GstBaseParse * parse,
</pre>
<hr />
<pre>
4061 gst_base_parse_src_query_default (GstBaseParse * parse, GstQuery * query)
4062 {
4063   gboolean res = FALSE;
4064   GstPad *pad;
4065 
4066   pad = GST_BASE_PARSE_SRC_PAD (parse);
4067 
4068   switch (GST_QUERY_TYPE (query)) {
4069     case GST_QUERY_POSITION:
4070     {
4071       gint64 dest_value;
4072       GstFormat format;
4073 
4074       GST_DEBUG_OBJECT (parse, &quot;position query&quot;);
4075       gst_query_parse_position (query, &amp;format, NULL);
4076 
4077       /* try upstream first */
4078       res = gst_pad_query_default (pad, GST_OBJECT_CAST (parse), query);
4079       if (!res) {
4080         /* Fall back on interpreting segment */
<span class="line-modified">4081       GST_OBJECT_LOCK (parse);</span>
4082         /* Only reply BYTES if upstream is in BYTES already, otherwise
4083          * we&#39;re not in charge */
4084         if (format == GST_FORMAT_BYTES
4085             &amp;&amp; parse-&gt;priv-&gt;upstream_format == GST_FORMAT_BYTES) {
<span class="line-modified">4086         dest_value = parse-&gt;priv-&gt;offset;</span>
<span class="line-modified">4087         res = TRUE;</span>
<span class="line-modified">4088       } else if (format == parse-&gt;segment.format &amp;&amp;</span>
4089             GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.position)) {
4090           dest_value = gst_segment_to_stream_time (&amp;parse-&gt;segment,
4091               parse-&gt;segment.format, parse-&gt;segment.position);
<span class="line-modified">4092         res = TRUE;</span>
<span class="line-modified">4093       }</span>
<span class="line-modified">4094       GST_OBJECT_UNLOCK (parse);</span>
4095         if (!res &amp;&amp; parse-&gt;priv-&gt;upstream_format == GST_FORMAT_BYTES) {
4096           /* no precise result, upstream no idea either, then best estimate */
4097           /* priv-&gt;offset is updated in both PUSH/PULL modes, *iff* we&#39;re
4098            * in charge of things */
4099           res = gst_base_parse_convert (parse,
4100               GST_FORMAT_BYTES, parse-&gt;priv-&gt;offset, format, &amp;dest_value);
4101         }
4102         if (res)
4103           gst_query_set_position (query, format, dest_value);
4104       }
4105       break;
4106     }
4107     case GST_QUERY_DURATION:
4108     {
4109       GstFormat format;
4110       GstClockTime duration;
4111 
4112       GST_DEBUG_OBJECT (parse, &quot;duration query&quot;);
4113       gst_query_parse_duration (query, &amp;format, NULL);
4114 
</pre>
<hr />
<pre>
4174           dest_format, &amp;dest_value);
4175       if (res) {
4176         gst_query_set_convert (query, src_format, src_value,
4177             dest_format, dest_value);
4178       }
4179       break;
4180     }
4181     case GST_QUERY_LATENCY:
4182     {
4183       if ((res = gst_pad_peer_query (parse-&gt;sinkpad, query))) {
4184         gboolean live;
4185         GstClockTime min_latency, max_latency;
4186 
4187         gst_query_parse_latency (query, &amp;live, &amp;min_latency, &amp;max_latency);
4188         GST_DEBUG_OBJECT (parse, &quot;Peer latency: live %d, min %&quot;
4189             GST_TIME_FORMAT &quot; max %&quot; GST_TIME_FORMAT, live,
4190             GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
4191 
4192         GST_OBJECT_LOCK (parse);
4193         /* add our latency */
<span class="line-modified">4194           min_latency += parse-&gt;priv-&gt;min_latency;</span>
4195         if (max_latency == -1 || parse-&gt;priv-&gt;max_latency == -1)
4196           max_latency = -1;
4197         else
4198           max_latency += parse-&gt;priv-&gt;max_latency;
4199         GST_OBJECT_UNLOCK (parse);
4200 
4201         gst_query_set_latency (query, live, min_latency, max_latency);
4202       }
4203       break;
4204     }
4205     case GST_QUERY_SEGMENT:
4206     {
4207       GstFormat format;
4208       gint64 start, stop;
4209 
4210       format = parse-&gt;segment.format;
4211 
4212       start =
4213           gst_segment_to_stream_time (&amp;parse-&gt;segment, format,
4214           parse-&gt;segment.start);
</pre>
<hr />
<pre>
4575     GstClockTime startpos;
4576     if (rate &gt;= 0)
4577       startpos = seeksegment.position;
4578     else
4579       startpos = start;
4580 
4581     /* accurate requested, so ... seek a bit before target */
4582     if (startpos &lt; parse-&gt;priv-&gt;lead_in_ts)
4583       startpos = 0;
4584     else
4585       startpos -= parse-&gt;priv-&gt;lead_in_ts;
4586 
4587     if (seeksegment.stop == -1 &amp;&amp; seeksegment.duration != -1)
4588       seeksegment.stop = seeksegment.start + seeksegment.duration;
4589 
4590     seekpos = gst_base_parse_find_offset (parse, startpos, TRUE, &amp;start_ts);
4591     seekstop = gst_base_parse_find_offset (parse, seeksegment.stop, FALSE,
4592         NULL);
4593   } else {
4594     if (rate &gt;= 0)
<span class="line-modified">4595     start_ts = seeksegment.position;</span>
4596     else
4597       start_ts = start;
4598 
4599     if (seeksegment.stop == -1 &amp;&amp; seeksegment.duration != -1)
4600       seeksegment.stop = seeksegment.start + seeksegment.duration;
4601 
4602     if (!gst_base_parse_convert (parse, format, start_ts,
4603             GST_FORMAT_BYTES, &amp;seekpos))
4604       goto convert_failed;
4605     if (!gst_base_parse_convert (parse, format, seeksegment.stop,
4606             GST_FORMAT_BYTES, &amp;seekstop))
4607       goto convert_failed;
4608   }
4609 
4610   GST_DEBUG_OBJECT (parse,
4611       &quot;seek position %&quot; G_GINT64_FORMAT &quot; in bytes: %&quot; G_GINT64_FORMAT,
4612       start_ts, seekpos);
4613   GST_DEBUG_OBJECT (parse,
4614       &quot;seek stop %&quot; G_GINT64_FORMAT &quot; in bytes: %&quot; G_GINT64_FORMAT,
4615       seeksegment.stop, seekstop);
</pre>
<hr />
<pre>
4738     seek-&gt;offset = seekpos;
4739     seek-&gt;start_ts = start_ts;
4740     GST_OBJECT_LOCK (parse);
4741     /* less optimal, but preserves order */
4742     parse-&gt;priv-&gt;pending_seeks =
4743         g_slist_append (parse-&gt;priv-&gt;pending_seeks, seek);
4744     GST_OBJECT_UNLOCK (parse);
4745 
4746     res = gst_pad_push_event (parse-&gt;sinkpad, new_event);
4747 
4748     if (!res) {
4749       GST_OBJECT_LOCK (parse);
4750       parse-&gt;priv-&gt;pending_seeks =
4751           g_slist_remove (parse-&gt;priv-&gt;pending_seeks, seek);
4752       GST_OBJECT_UNLOCK (parse);
4753       g_free (seek);
4754     }
4755   }
4756 
4757 done:
<span class="line-modified">4758     gst_event_unref (event);</span>
4759   return res;
4760 
4761   /* ERRORS */
4762 negative_rate:
4763   {
4764     GST_DEBUG_OBJECT (parse, &quot;negative playback rates delegated upstream.&quot;);
4765     res = FALSE;
4766     goto done;
4767   }
4768 wrong_type:
4769   {
4770     GST_DEBUG_OBJECT (parse, &quot;unsupported seek type.&quot;);
4771     res = FALSE;
4772     goto done;
4773   }
4774 no_convert_to_time:
4775   {
4776     GST_DEBUG_OBJECT (parse, &quot;seek in %s format was requested, but subclass &quot;
4777         &quot;couldn&#39;t convert that into TIME format&quot;, gst_format_get_name (format));
4778     res = FALSE;
</pre>
<hr />
<pre>
4786   }
4787 }
4788 
4789 static void
4790 gst_base_parse_set_upstream_tags (GstBaseParse * parse, GstTagList * taglist)
4791 {
4792   if (taglist == parse-&gt;priv-&gt;upstream_tags)
4793     return;
4794 
4795   if (parse-&gt;priv-&gt;upstream_tags) {
4796     gst_tag_list_unref (parse-&gt;priv-&gt;upstream_tags);
4797     parse-&gt;priv-&gt;upstream_tags = NULL;
4798   }
4799 
4800   GST_INFO_OBJECT (parse, &quot;upstream tags: %&quot; GST_PTR_FORMAT, taglist);
4801 
4802   if (taglist != NULL)
4803     parse-&gt;priv-&gt;upstream_tags = gst_tag_list_ref (taglist);
4804 
4805   gst_base_parse_check_bitrate_tags (parse);
<span class="line-modified">4806   }</span>
4807 
4808 #if 0
4809 static void
4810 gst_base_parse_set_index (GstElement * element, GstIndex * index)
4811 {
4812   GstBaseParse *parse = GST_BASE_PARSE (element);
4813 
4814   GST_BASE_PARSE_INDEX_LOCK (parse);
4815   if (parse-&gt;priv-&gt;index)
4816     gst_object_unref (parse-&gt;priv-&gt;index);
4817   if (index) {
4818     parse-&gt;priv-&gt;index = gst_object_ref (index);
4819     gst_index_get_writer_id (index, GST_OBJECT_CAST (element),
4820         &amp;parse-&gt;priv-&gt;index_id);
4821     parse-&gt;priv-&gt;own_index = FALSE;
4822   } else {
4823     parse-&gt;priv-&gt;index = NULL;
4824   }
4825   GST_BASE_PARSE_INDEX_UNLOCK (parse);
4826 }
</pre>
<hr />
<pre>
4907 gst_base_parse_set_ts_at_offset (GstBaseParse * parse, gsize offset)
4908 {
4909   GstClockTime pts, dts;
4910 
4911   g_return_if_fail (GST_IS_BASE_PARSE (parse));
4912 
4913   pts = gst_adapter_prev_pts_at_offset (parse-&gt;priv-&gt;adapter, offset, NULL);
4914   dts = gst_adapter_prev_dts_at_offset (parse-&gt;priv-&gt;adapter, offset, NULL);
4915 
4916   if (!GST_CLOCK_TIME_IS_VALID (pts) || !GST_CLOCK_TIME_IS_VALID (dts)) {
4917     GST_DEBUG_OBJECT (parse,
4918         &quot;offset adapter timestamps dts=%&quot; GST_TIME_FORMAT &quot; pts=%&quot;
4919         GST_TIME_FORMAT, GST_TIME_ARGS (dts), GST_TIME_ARGS (pts));
4920   }
4921   if (GST_CLOCK_TIME_IS_VALID (pts) &amp;&amp; (parse-&gt;priv-&gt;prev_pts != pts))
4922     parse-&gt;priv-&gt;prev_pts = parse-&gt;priv-&gt;next_pts = pts;
4923 
4924   if (GST_CLOCK_TIME_IS_VALID (dts) &amp;&amp; (parse-&gt;priv-&gt;prev_dts != dts)) {
4925     parse-&gt;priv-&gt;prev_dts = parse-&gt;priv-&gt;next_dts = dts;
4926     parse-&gt;priv-&gt;prev_dts_from_pts = FALSE;
<span class="line-modified">4927 }</span>
4928 }
4929 
4930 /**
4931  * gst_base_parse_merge_tags:
4932  * @parse: a #GstBaseParse
4933  * @tags: (allow-none): a #GstTagList to merge, or NULL to unset
4934  *     previously-set tags
4935  * @mode: the #GstTagMergeMode to use, usually #GST_TAG_MERGE_REPLACE
4936  *
4937  * Sets the parser subclass&#39;s tags and how they should be merged with any
4938  * upstream stream tags. This will override any tags previously-set
4939  * with gst_base_parse_merge_tags().
4940  *
4941  * Note that this is provided for convenience, and the subclass is
4942  * not required to use this and can still do tag handling on its own.
4943  *
4944  * Since: 1.6
4945  */
4946 void
4947 gst_base_parse_merge_tags (GstBaseParse * parse, GstTagList * tags,
</pre>
</td>
<td>
<hr />
<pre>
  30  * This base class is for parser elements that process data and splits it
  31  * into separate audio/video/whatever frames.
  32  *
  33  * It provides for:
  34  *
  35  *   * provides one sink pad and one source pad
  36  *   * handles state changes
  37  *   * can operate in pull mode or push mode
  38  *   * handles seeking in both modes
  39  *   * handles events (SEGMENT/EOS/FLUSH)
  40  *   * handles queries (POSITION/DURATION/SEEKING/FORMAT/CONVERT)
  41  *   * handles flushing
  42  *
  43  * The purpose of this base class is to provide the basic functionality of
  44  * a parser and share a lot of rather complex code.
  45  *
  46  * # Description of the parsing mechanism:
  47  *
  48  * ## Set-up phase
  49  *
<span class="line-modified">  50  *  * #GstBaseParse calls #GstBaseParseClass.start() to inform subclass</span>
<span class="line-modified">  51  *    that data processing is about to start now.</span>
  52  *
<span class="line-modified">  53  *  * #GstBaseParse class calls #GstBaseParseClass.set_sink_caps() to</span>
<span class="line-modified">  54  *    inform the subclass about incoming sinkpad caps. Subclass could</span>
<span class="line-modified">  55  *    already set the srcpad caps accordingly, but this might be delayed</span>
<span class="line-modified">  56  *    until calling gst_base_parse_finish_frame() with a non-queued frame.</span>
  57  *
  58  *  * At least at this point subclass needs to tell the #GstBaseParse class
<span class="line-modified">  59  *    how big data chunks it wants to receive (minimum frame size ). It can</span>
<span class="line-modified">  60  *    do this with gst_base_parse_set_min_frame_size().</span>
  61  *
  62  *  * #GstBaseParse class sets up appropriate data passing mode (pull/push)
  63  *    and starts to process the data.
  64  *
  65  * ## Parsing phase
  66  *
  67  *  * #GstBaseParse gathers at least min_frame_size bytes of data either
  68  *    by pulling it from upstream or collecting buffers in an internal
  69  *    #GstAdapter.
  70  *
<span class="line-modified">  71  *  * A buffer of (at least) min_frame_size bytes is passed to subclass</span>
<span class="line-modified">  72  *    with #GstBaseParseClass.handle_frame(). Subclass checks the contents</span>
<span class="line-modified">  73  *    and can optionally return #GST_FLOW_OK along with an amount of data</span>
<span class="line-modified">  74  *    to be skipped to find a valid frame (which will result in a</span>
<span class="line-modified">  75  *    subsequent DISCONT).  If, otherwise, the buffer does not hold a</span>
<span class="line-modified">  76  *    complete frame, #GstBaseParseClass.handle_frame() can merely return</span>
<span class="line-modified">  77  *    and will be called again when additional data is available.  In push</span>
<span class="line-modified">  78  *    mode this amounts to an additional input buffer (thus minimal</span>
<span class="line-modified">  79  *    additional latency), in pull mode this amounts to some arbitrary</span>
<span class="line-modified">  80  *    reasonable buffer size increase.</span>
<span class="line-modified">  81  *</span>
<span class="line-modified">  82  *    Of course, gst_base_parse_set_min_frame_size() could also be used if</span>
<span class="line-modified">  83  *    a very specific known amount of additional data is required.  If,</span>
<span class="line-modified">  84  *    however, the buffer holds a complete valid frame, it can pass the</span>
<span class="line-modified">  85  *    size of this frame to gst_base_parse_finish_frame().</span>
<span class="line-modified">  86  *</span>
<span class="line-modified">  87  *    If acting as a converter, it can also merely indicate consumed input</span>
<span class="line-modified">  88  *    data while simultaneously providing custom output data.  Note that</span>
<span class="line-added">  89  *    baseclass performs some processing (such as tracking overall consumed</span>
<span class="line-added">  90  *    data rate versus duration) for each finished frame, but other state</span>
<span class="line-added">  91  *    is only updated upon each call to #GstBaseParseClass.handle_frame()</span>
  92  *    (such as tracking upstream input timestamp).
  93  *
  94  *    Subclass is also responsible for setting the buffer metadata
  95  *    (e.g. buffer timestamp and duration, or keyframe if applicable).
  96  *    (although the latter can also be done by #GstBaseParse if it is
  97  *    appropriately configured, see below).  Frame is provided with
  98  *    timestamp derived from upstream (as much as generally possible),
  99  *    duration obtained from configuration (see below), and offset
 100  *    if meaningful (in pull mode).
 101  *
<span class="line-modified"> 102  *    Note that #GstBaseParseClass.handle_frame() might receive any small</span>
<span class="line-modified"> 103  *    amount of input data when leftover data is being drained (e.g. at</span>
<span class="line-added"> 104  *    EOS).</span>
 105  *
<span class="line-modified"> 106  *  * As part of finish frame processing, just prior to actually pushing</span>
<span class="line-modified"> 107  *    the buffer in question, it is passed to</span>
<span class="line-modified"> 108  *    #GstBaseParseClass.pre_push_frame() which gives subclass yet one last</span>
<span class="line-modified"> 109  *    chance to examine buffer metadata, or to send some custom (tag)</span>
 110  *    events, or to perform custom (segment) filtering.
 111  *
 112  *  * During the parsing process #GstBaseParseClass will handle both srcpad
<span class="line-modified"> 113  *    and sinkpad events. They will be passed to subclass if</span>
<span class="line-modified"> 114  *    #GstBaseParseClass.event() or #GstBaseParseClass.src_event()</span>
<span class="line-added"> 115  *    implementations have been provided.</span>
 116  *
 117  * ## Shutdown phase
 118  *
<span class="line-modified"> 119  * * #GstBaseParse class calls #GstBaseParseClass.stop() to inform the</span>
<span class="line-modified"> 120  *   subclass that data parsing will be stopped.</span>
 121  *
<span class="line-modified"> 122  * Subclass is responsible for providing pad template caps for source and</span>
<span class="line-modified"> 123  * sink pads. The pads need to be named &quot;sink&quot; and &quot;src&quot;. It also needs to</span>
<span class="line-modified"> 124  * set the fixed caps on srcpad, when the format is ensured (e.g.  when</span>
<span class="line-modified"> 125  * base class calls subclass&#39; #GstBaseParseClass.set_sink_caps() function).</span>
 126  *
 127  * This base class uses %GST_FORMAT_DEFAULT as a meaning of frames. So,
 128  * subclass conversion routine needs to know that conversion from
 129  * %GST_FORMAT_TIME to %GST_FORMAT_DEFAULT must return the
 130  * frame number that can be found from the given byte position.
 131  *
 132  * #GstBaseParse uses subclasses conversion methods also for seeking (or
 133  * otherwise uses its own default one, see also below).
 134  *
 135  * Subclass @start and @stop functions will be called to inform the beginning
 136  * and end of data processing.
 137  *
 138  * Things that subclass need to take care of:
 139  *
 140  * * Provide pad templates
 141  * * Fixate the source pad caps when appropriate
 142  * * Inform base class how big data chunks should be retrieved. This is
 143  *   done with gst_base_parse_set_min_frame_size() function.
<span class="line-modified"> 144  * * Examine data chunks passed to subclass with</span>
<span class="line-modified"> 145  *   #GstBaseParseClass.handle_frame() and pass proper frame(s) to</span>
<span class="line-modified"> 146  *   gst_base_parse_finish_frame(), and setting src pad caps and timestamps</span>
<span class="line-added"> 147  *   on frame.</span>
 148  * * Provide conversion functions
 149  * * Update the duration information with gst_base_parse_set_duration()
 150  * * Optionally passthrough using gst_base_parse_set_passthrough()
 151  * * Configure various baseparse parameters using
 152  *   gst_base_parse_set_average_bitrate(), gst_base_parse_set_syncable()
 153  *   and gst_base_parse_set_frame_rate().
 154  *
 155  * * In particular, if subclass is unable to determine a duration, but
 156  *   parsing (or specs) yields a frames per seconds rate, then this can be
<span class="line-modified"> 157  *   provided to #GstBaseParse to enable it to cater for buffer time</span>
<span class="line-modified"> 158  *   metadata (which will be taken from upstream as much as</span>
 159  *   possible). Internally keeping track of frame durations and respective
 160  *   sizes that have been pushed provides #GstBaseParse with an estimated
<span class="line-modified"> 161  *   bitrate. A default #GstBaseParseClass.convert() (used if not</span>
<span class="line-modified"> 162  *   overridden) will then use these rates to perform obvious conversions.</span>
<span class="line-modified"> 163  *   These rates are also used to update (estimated) duration at regular</span>
<span class="line-added"> 164  *   frame intervals.</span>
 165  *
 166  */
 167 
 168 /* TODO:
 169  *  - In push mode provide a queue of adapter-&quot;queued&quot; buffers for upstream
 170  *    buffer metadata
 171  *  - Queue buffers/events until caps are set
 172  */
 173 
 174 #ifdef HAVE_CONFIG_H
 175 #  include &quot;config.h&quot;
 176 #endif
 177 
 178 #include &lt;stdlib.h&gt;
 179 #include &lt;string.h&gt;
 180 
 181 #include &lt;gst/base/gstadapter.h&gt;
 182 
 183 #include &quot;gstbaseparse.h&quot;
 184 
</pre>
<hr />
<pre>
 195 #define GST_BASE_PARSE_FRAME_PRIVATE_FLAG_NOALLOC  (1 &lt;&lt; 0)
 196 
 197 #define MIN_FRAMES_TO_POST_BITRATE 10
 198 #define TARGET_DIFFERENCE          (20 * GST_SECOND)
 199 #define MAX_INDEX_ENTRIES          4096
 200 #define UPDATE_THRESHOLD           2
 201 
 202 #define ABSDIFF(a,b) (((a) &gt; (b)) ? ((a) - (b)) : ((b) - (a)))
 203 
 204 GST_DEBUG_CATEGORY_STATIC (gst_base_parse_debug);
 205 #define GST_CAT_DEFAULT gst_base_parse_debug
 206 
 207 /* Supported formats */
 208 static const GstFormat fmtlist[] = {
 209   GST_FORMAT_DEFAULT,
 210   GST_FORMAT_BYTES,
 211   GST_FORMAT_TIME,
 212   GST_FORMAT_UNDEFINED
 213 };
 214 



 215 struct _GstBaseParsePrivate
 216 {
 217   GstPadMode pad_mode;
 218 
 219   GstAdapter *adapter;
 220 
 221   gint64 duration;
 222   GstFormat duration_fmt;
 223   gint64 estimated_duration;
 224   gint64 estimated_drift;
 225 
 226   guint min_frame_size;
 227   gboolean disable_passthrough;
 228   gboolean passthrough;
 229   gboolean pts_interpolate;
 230   gboolean infer_ts;
 231   gboolean syncable;
 232   gboolean has_timing_info;
 233   guint fps_num, fps_den;
 234   gint update_interval;
</pre>
<hr />
<pre>
 328   /* TRUE if we&#39;re still detecting the format, i.e.
 329    * if ::detect() is still called for future buffers */
 330   gboolean detecting;
 331   GList *detect_buffers;
 332   guint detect_buffers_size;
 333 
 334   /* True when no buffers have been received yet */
 335   gboolean first_buffer;
 336 
 337   /* if TRUE, a STREAM_START event needs to be pushed */
 338   gboolean push_stream_start;
 339 
 340   /* When we need to skip more data than we have currently */
 341   guint skip;
 342 
 343   /* Tag handling (stream tags only, global tags are passed through as-is) */
 344   GstTagList *upstream_tags;
 345   GstTagList *parser_tags;
 346   GstTagMergeMode parser_tags_merge_mode;
 347   gboolean tags_changed;
<span class="line-added"> 348 </span>
<span class="line-added"> 349   /* Current segment seqnum */</span>
<span class="line-added"> 350   guint32 segment_seqnum;</span>
 351 };
 352 
 353 typedef struct _GstBaseParseSeek
 354 {
 355   GstSegment segment;
 356   gboolean accurate;
 357   gint64 offset;
 358   GstClockTime start_ts;
 359 } GstBaseParseSeek;
 360 
 361 #define DEFAULT_DISABLE_PASSTHROUGH        FALSE
 362 
 363 enum
 364 {
 365   PROP_0,
 366   PROP_DISABLE_PASSTHROUGH,
 367   PROP_LAST
 368 };
 369 
 370 #define GST_BASE_PARSE_INDEX_LOCK(parse) \
 371   g_mutex_lock (&amp;parse-&gt;priv-&gt;index_lock);
 372 #define GST_BASE_PARSE_INDEX_UNLOCK(parse) \
 373   g_mutex_unlock (&amp;parse-&gt;priv-&gt;index_lock);
 374 
 375 static GstElementClass *parent_class = NULL;
<span class="line-added"> 376 static gint base_parse_private_offset = 0;</span>
 377 
 378 static void gst_base_parse_class_init (GstBaseParseClass * klass);
 379 static void gst_base_parse_init (GstBaseParse * parse,
 380     GstBaseParseClass * klass);
 381 
 382 GType
 383 gst_base_parse_get_type (void)
 384 {
 385   static volatile gsize base_parse_type = 0;
 386 
 387   if (g_once_init_enter (&amp;base_parse_type)) {
 388     static const GTypeInfo base_parse_info = {
 389       sizeof (GstBaseParseClass),
 390       (GBaseInitFunc) NULL,
 391       (GBaseFinalizeFunc) NULL,
 392       (GClassInitFunc) gst_base_parse_class_init,
 393       NULL,
 394       NULL,
 395       sizeof (GstBaseParse),
 396       0,
 397       (GInstanceInitFunc) gst_base_parse_init,
 398     };
 399     GType _type;
 400 
 401     _type = g_type_register_static (GST_TYPE_ELEMENT,
 402         &quot;GstBaseParse&quot;, &amp;base_parse_info, G_TYPE_FLAG_ABSTRACT);
<span class="line-added"> 403 </span>
<span class="line-added"> 404     base_parse_private_offset =</span>
<span class="line-added"> 405         g_type_add_instance_private (_type, sizeof (GstBaseParsePrivate));</span>
<span class="line-added"> 406 </span>
 407     g_once_init_leave (&amp;base_parse_type, _type);
 408   }
 409   return (GType) base_parse_type;
 410 }
 411 
<span class="line-added"> 412 static inline GstBaseParsePrivate *</span>
<span class="line-added"> 413 gst_base_parse_get_instance_private (GstBaseParse * self)</span>
<span class="line-added"> 414 {</span>
<span class="line-added"> 415   return (G_STRUCT_MEMBER_P (self, base_parse_private_offset));</span>
<span class="line-added"> 416 }</span>
<span class="line-added"> 417 </span>
 418 static void gst_base_parse_finalize (GObject * object);
 419 
 420 static GstStateChangeReturn gst_base_parse_change_state (GstElement * element,
 421     GstStateChange transition);
 422 static void gst_base_parse_reset (GstBaseParse * parse);
 423 
 424 #if 0
 425 static void gst_base_parse_set_index (GstElement * element, GstIndex * index);
 426 static GstIndex *gst_base_parse_get_index (GstElement * element);
 427 #endif
 428 
 429 static gboolean gst_base_parse_sink_activate (GstPad * sinkpad,
 430     GstObject * parent);
 431 static gboolean gst_base_parse_sink_activate_mode (GstPad * pad,
 432     GstObject * parent, GstPadMode mode, gboolean active);
 433 static gboolean gst_base_parse_handle_seek (GstBaseParse * parse,
 434     GstEvent * event);
 435 static void gst_base_parse_set_upstream_tags (GstBaseParse * parse,
 436     GstTagList * taglist);
 437 
</pre>
<hr />
<pre>
 527   g_object_unref (parse-&gt;priv-&gt;adapter);
 528 
 529   if (parse-&gt;priv-&gt;index) {
 530     gst_object_unref (parse-&gt;priv-&gt;index);
 531     parse-&gt;priv-&gt;index = NULL;
 532   }
 533   g_mutex_clear (&amp;parse-&gt;priv-&gt;index_lock);
 534 
 535   gst_base_parse_clear_queues (parse);
 536 
 537   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 538 }
 539 
 540 static void
 541 gst_base_parse_class_init (GstBaseParseClass * klass)
 542 {
 543   GObjectClass *gobject_class;
 544   GstElementClass *gstelement_class;
 545 
 546   gobject_class = G_OBJECT_CLASS (klass);
<span class="line-modified"> 547 </span>
<span class="line-added"> 548   if (base_parse_private_offset != 0)</span>
<span class="line-added"> 549     g_type_class_adjust_private_offset (klass, &amp;base_parse_private_offset);</span>
<span class="line-added"> 550 </span>
 551   parent_class = g_type_class_peek_parent (klass);
 552 
 553   gobject_class-&gt;finalize = GST_DEBUG_FUNCPTR (gst_base_parse_finalize);
 554   gobject_class-&gt;set_property = GST_DEBUG_FUNCPTR (gst_base_parse_set_property);
 555   gobject_class-&gt;get_property = GST_DEBUG_FUNCPTR (gst_base_parse_get_property);
 556 
 557   /**
 558    * GstBaseParse:disable-passthrough:
 559    *
 560    * If set to %TRUE, baseparse will unconditionally force parsing of the
 561    * incoming data. This can be required in the rare cases where the incoming
 562    * side-data (caps, pts, dts, ...) is not trusted by the user and wants to
 563    * force validation and parsing of the incoming data.
 564    * If set to %FALSE, decision of whether to parse the data or not is up to
 565    * the implementation (standard behaviour).
 566    */
 567   g_object_class_install_property (gobject_class, PROP_DISABLE_PASSTHROUGH,
 568       g_param_spec_boolean (&quot;disable-passthrough&quot;, &quot;Disable passthrough&quot;,
 569           &quot;Force processing (disables passthrough)&quot;,
 570           DEFAULT_DISABLE_PASSTHROUGH,
</pre>
<hr />
<pre>
 580 #endif
 581 
 582   /* Default handlers */
 583   klass-&gt;sink_event = gst_base_parse_sink_event_default;
 584   klass-&gt;src_event = gst_base_parse_src_event_default;
 585   klass-&gt;sink_query = gst_base_parse_sink_query_default;
 586   klass-&gt;src_query = gst_base_parse_src_query_default;
 587   klass-&gt;convert = gst_base_parse_convert_default;
 588 
 589   GST_DEBUG_CATEGORY_INIT (gst_base_parse_debug, &quot;baseparse&quot;, 0,
 590       &quot;baseparse element&quot;);
 591 }
 592 
 593 static void
 594 gst_base_parse_init (GstBaseParse * parse, GstBaseParseClass * bclass)
 595 {
 596   GstPadTemplate *pad_template;
 597 
 598   GST_DEBUG_OBJECT (parse, &quot;gst_base_parse_init&quot;);
 599 
<span class="line-modified"> 600   parse-&gt;priv = gst_base_parse_get_instance_private (parse);</span>
 601 
 602   pad_template =
 603       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;sink&quot;);
 604   g_return_if_fail (pad_template != NULL);
 605   parse-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 606   gst_pad_set_event_function (parse-&gt;sinkpad,
 607       GST_DEBUG_FUNCPTR (gst_base_parse_sink_event));
 608   gst_pad_set_query_function (parse-&gt;sinkpad,
 609       GST_DEBUG_FUNCPTR (gst_base_parse_sink_query));
 610   gst_pad_set_chain_function (parse-&gt;sinkpad,
 611       GST_DEBUG_FUNCPTR (gst_base_parse_chain));
 612   gst_pad_set_activate_function (parse-&gt;sinkpad,
 613       GST_DEBUG_FUNCPTR (gst_base_parse_sink_activate));
 614   gst_pad_set_activatemode_function (parse-&gt;sinkpad,
 615       GST_DEBUG_FUNCPTR (gst_base_parse_sink_activate_mode));
 616   GST_PAD_SET_PROXY_ALLOCATION (parse-&gt;sinkpad);
 617   gst_element_add_pad (GST_ELEMENT (parse), parse-&gt;sinkpad);
 618 
 619   GST_DEBUG_OBJECT (parse, &quot;sinkpad created&quot;);
 620 
</pre>
<hr />
<pre>
 630   gst_element_add_pad (GST_ELEMENT (parse), parse-&gt;srcpad);
 631   GST_DEBUG_OBJECT (parse, &quot;src created&quot;);
 632 
 633   g_queue_init (&amp;parse-&gt;priv-&gt;queued_frames);
 634 
 635   parse-&gt;priv-&gt;adapter = gst_adapter_new ();
 636 
 637   parse-&gt;priv-&gt;pad_mode = GST_PAD_MODE_NONE;
 638 
 639   g_mutex_init (&amp;parse-&gt;priv-&gt;index_lock);
 640 
 641   /* init state */
 642   gst_base_parse_reset (parse);
 643   GST_DEBUG_OBJECT (parse, &quot;init ok&quot;);
 644 
 645   GST_OBJECT_FLAG_SET (parse, GST_ELEMENT_FLAG_INDEXABLE);
 646 
 647   parse-&gt;priv-&gt;upstream_tags = NULL;
 648   parse-&gt;priv-&gt;parser_tags = NULL;
 649   parse-&gt;priv-&gt;parser_tags_merge_mode = GST_TAG_MERGE_APPEND;
<span class="line-added"> 650   parse-&gt;priv-&gt;disable_passthrough = DEFAULT_DISABLE_PASSTHROUGH;</span>
 651 }
 652 
 653 static void
 654 gst_base_parse_set_property (GObject * object, guint prop_id,
 655     const GValue * value, GParamSpec * pspec)
 656 {
 657   GstBaseParse *parse = GST_BASE_PARSE (object);
 658 
 659   switch (prop_id) {
 660     case PROP_DISABLE_PASSTHROUGH:
 661       parse-&gt;priv-&gt;disable_passthrough = g_value_get_boolean (value);
 662       break;
 663     default:
 664       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 665       break;
 666   }
 667 }
 668 
 669 static void
 670 gst_base_parse_get_property (GObject * object, guint prop_id, GValue * value,
 671     GParamSpec * pspec)
 672 {
 673   GstBaseParse *parse = GST_BASE_PARSE (object);
 674 
 675   switch (prop_id) {
 676     case PROP_DISABLE_PASSTHROUGH:
 677       g_value_set_boolean (value, parse-&gt;priv-&gt;disable_passthrough);
 678       break;
 679     default:
 680       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 681       break;
 682   }
 683 }
 684 
<span class="line-added"> 685 /**</span>
<span class="line-added"> 686  * gst_base_parse_frame_copy:</span>
<span class="line-added"> 687  * @frame: a #GstBaseParseFrame</span>
<span class="line-added"> 688  *</span>
<span class="line-added"> 689  * Copies a #GstBaseParseFrame.</span>
<span class="line-added"> 690  *</span>
<span class="line-added"> 691  * Returns: A copy of @frame</span>
<span class="line-added"> 692  */</span>
<span class="line-added"> 693 </span>
 694 GstBaseParseFrame *
 695 gst_base_parse_frame_copy (GstBaseParseFrame * frame)
 696 {
 697   GstBaseParseFrame *copy;
 698 
 699   copy = g_slice_dup (GstBaseParseFrame, frame);
 700   copy-&gt;buffer = gst_buffer_ref (frame-&gt;buffer);
 701   copy-&gt;_private_flags &amp;= ~GST_BASE_PARSE_FRAME_PRIVATE_FLAG_NOALLOC;
 702 
 703   GST_TRACE (&quot;copied frame %p -&gt; %p&quot;, frame, copy);
 704 
 705   return copy;
 706 }
 707 
<span class="line-added"> 708 /**</span>
<span class="line-added"> 709  * gst_base_parse_frame_free:</span>
<span class="line-added"> 710  * @frame: A #GstBaseParseFrame</span>
<span class="line-added"> 711  *</span>
<span class="line-added"> 712  * Frees the provided @frame.</span>
<span class="line-added"> 713  */</span>
 714 void
 715 gst_base_parse_frame_free (GstBaseParseFrame * frame)
 716 {
 717   GST_TRACE (&quot;freeing frame %p&quot;, frame);
 718 
 719   if (frame-&gt;buffer) {
 720     gst_buffer_unref (frame-&gt;buffer);
 721     frame-&gt;buffer = NULL;
 722   }
 723 
 724   if (!(frame-&gt;_private_flags &amp; GST_BASE_PARSE_FRAME_PRIVATE_FLAG_NOALLOC)) {
 725     g_slice_free (GstBaseParseFrame, frame);
 726   } else {
 727     memset (frame, 0, sizeof (*frame));
 728   }
 729 }
 730 
 731 G_DEFINE_BOXED_TYPE (GstBaseParseFrame, gst_base_parse_frame,
<span class="line-modified"> 732     (GBoxedCopyFunc) gst_base_parse_frame_copy,</span>
<span class="line-modified"> 733     (GBoxedFreeFunc) gst_base_parse_frame_free);</span>
 734 
 735 /**
 736  * gst_base_parse_frame_init:
 737  * @frame: #GstBaseParseFrame.
 738  *
 739  * Sets a #GstBaseParseFrame to initial state.  Currently this means
 740  * all public fields are zero-ed and a private flag is set to make
 741  * sure gst_base_parse_frame_free() only frees the contents but not
 742  * the actual frame. Use this function to initialise a #GstBaseParseFrame
 743  * allocated on the stack.
 744  */
 745 void
 746 gst_base_parse_frame_init (GstBaseParseFrame * frame)
 747 {
 748   memset (frame, 0, sizeof (GstBaseParseFrame));
 749   frame-&gt;_private_flags = GST_BASE_PARSE_FRAME_PRIVATE_FLAG_NOALLOC;
 750   GST_TRACE (&quot;inited frame %p&quot;, frame);
 751 }
 752 
 753 /**
</pre>
<hr />
<pre>
 822   parse-&gt;priv-&gt;saw_gaps = FALSE;
 823   parse-&gt;priv-&gt;offset = 0;
 824   parse-&gt;priv-&gt;sync_offset = 0;
 825   parse-&gt;priv-&gt;update_interval = -1;
 826   parse-&gt;priv-&gt;fps_num = parse-&gt;priv-&gt;fps_den = 0;
 827   parse-&gt;priv-&gt;frame_duration = GST_CLOCK_TIME_NONE;
 828   parse-&gt;priv-&gt;lead_in = parse-&gt;priv-&gt;lead_out = 0;
 829   parse-&gt;priv-&gt;lead_in_ts = parse-&gt;priv-&gt;lead_out_ts = 0;
 830   parse-&gt;priv-&gt;bitrate = 0;
 831   parse-&gt;priv-&gt;framecount = 0;
 832   parse-&gt;priv-&gt;bytecount = 0;
 833   parse-&gt;priv-&gt;acc_duration = 0;
 834   parse-&gt;priv-&gt;first_frame_pts = GST_CLOCK_TIME_NONE;
 835   parse-&gt;priv-&gt;first_frame_dts = GST_CLOCK_TIME_NONE;
 836   parse-&gt;priv-&gt;first_frame_offset = -1;
 837   parse-&gt;priv-&gt;estimated_duration = -1;
 838   parse-&gt;priv-&gt;estimated_drift = 0;
 839   parse-&gt;priv-&gt;next_pts = GST_CLOCK_TIME_NONE;
 840   parse-&gt;priv-&gt;next_dts = 0;
 841   parse-&gt;priv-&gt;syncable = TRUE;

 842   parse-&gt;priv-&gt;passthrough = FALSE;
 843   parse-&gt;priv-&gt;pts_interpolate = TRUE;
 844   parse-&gt;priv-&gt;infer_ts = TRUE;
 845   parse-&gt;priv-&gt;has_timing_info = FALSE;
 846   parse-&gt;priv-&gt;min_bitrate = G_MAXUINT;
 847   parse-&gt;priv-&gt;max_bitrate = 0;
 848   parse-&gt;priv-&gt;avg_bitrate = 0;
 849   parse-&gt;priv-&gt;posted_avg_bitrate = 0;
 850 
 851   parse-&gt;priv-&gt;index_last_ts = GST_CLOCK_TIME_NONE;
 852   parse-&gt;priv-&gt;index_last_offset = -1;
 853   parse-&gt;priv-&gt;index_last_valid = TRUE;
 854   parse-&gt;priv-&gt;upstream_seekable = FALSE;
 855   parse-&gt;priv-&gt;upstream_size = 0;
 856   parse-&gt;priv-&gt;upstream_has_duration = FALSE;
 857   parse-&gt;priv-&gt;upstream_format = GST_FORMAT_UNDEFINED;
 858   parse-&gt;priv-&gt;idx_interval = 0;
 859   parse-&gt;priv-&gt;idx_byte_interval = 0;
 860   parse-&gt;priv-&gt;exact_position = TRUE;
 861   parse-&gt;priv-&gt;seen_keyframe = FALSE;
</pre>
<hr />
<pre>
 883 
 884   if (parse-&gt;priv-&gt;adapter)
 885     gst_adapter_clear (parse-&gt;priv-&gt;adapter);
 886 
 887   gst_base_parse_set_upstream_tags (parse, NULL);
 888 
 889   if (parse-&gt;priv-&gt;parser_tags) {
 890     gst_tag_list_unref (parse-&gt;priv-&gt;parser_tags);
 891     parse-&gt;priv-&gt;parser_tags = NULL;
 892   }
 893   parse-&gt;priv-&gt;parser_tags_merge_mode = GST_TAG_MERGE_APPEND;
 894 
 895   parse-&gt;priv-&gt;new_frame = TRUE;
 896 
 897   parse-&gt;priv-&gt;first_buffer = TRUE;
 898 
 899   g_list_foreach (parse-&gt;priv-&gt;detect_buffers, (GFunc) gst_buffer_unref, NULL);
 900   g_list_free (parse-&gt;priv-&gt;detect_buffers);
 901   parse-&gt;priv-&gt;detect_buffers = NULL;
 902   parse-&gt;priv-&gt;detect_buffers_size = 0;
<span class="line-added"> 903 </span>
<span class="line-added"> 904   parse-&gt;priv-&gt;segment_seqnum = GST_SEQNUM_INVALID;</span>
 905   GST_OBJECT_UNLOCK (parse);
 906 }
 907 
 908 static gboolean
 909 gst_base_parse_check_bitrate_tag (GstBaseParse * parse, const gchar * tag)
 910 {
 911   gboolean got_tag = FALSE;
 912   guint n = 0;
 913 
 914   if (parse-&gt;priv-&gt;upstream_tags != NULL)
 915     got_tag = gst_tag_list_get_uint (parse-&gt;priv-&gt;upstream_tags, tag, &amp;n);
 916 
 917   if (!got_tag &amp;&amp; parse-&gt;priv-&gt;parser_tags != NULL)
 918     got_tag = gst_tag_list_get_uint (parse-&gt;priv-&gt;parser_tags, tag, &amp;n);
 919 
 920   return got_tag;
 921 }
 922 
 923 /* check if upstream or subclass tags contain bitrates already */
 924 static void
</pre>
<hr />
<pre>
1190       GstCaps *caps;
1191 
1192       gst_event_parse_caps (event, &amp;caps);
1193       GST_DEBUG_OBJECT (parse, &quot;caps: %&quot; GST_PTR_FORMAT, caps);
1194 
1195       if (klass-&gt;set_sink_caps)
1196         ret = klass-&gt;set_sink_caps (parse, caps);
1197       else
1198         ret = TRUE;
1199 
1200       /* will send our own caps downstream */
1201       gst_event_unref (event);
1202       event = NULL;
1203       break;
1204     }
1205     case GST_EVENT_SEGMENT:
1206     {
1207       const GstSegment *in_segment;
1208       GstSegment out_segment;
1209       gint64 offset = 0, next_dts;

1210 
<span class="line-added">1211       parse-&gt;priv-&gt;segment_seqnum = gst_event_get_seqnum (event);</span>
1212       gst_event_parse_segment (event, &amp;in_segment);
1213       gst_segment_init (&amp;out_segment, GST_FORMAT_TIME);
1214       out_segment.rate = in_segment-&gt;rate;
1215       out_segment.applied_rate = in_segment-&gt;applied_rate;
1216 
<span class="line-modified">1217       GST_DEBUG_OBJECT (parse, &quot;New segment %&quot; GST_SEGMENT_FORMAT, in_segment);</span>
<span class="line-added">1218       GST_DEBUG_OBJECT (parse, &quot;Current segment %&quot; GST_SEGMENT_FORMAT,</span>
<span class="line-added">1219           &amp;parse-&gt;segment);</span>
1220 
1221       parse-&gt;priv-&gt;upstream_format = in_segment-&gt;format;
1222       if (in_segment-&gt;format == GST_FORMAT_BYTES) {
1223         GstBaseParseSeek *seek = NULL;
1224         GSList *node;
1225 
1226         /* stop time is allowed to be open-ended, but not start &amp; pos */
1227         offset = in_segment-&gt;time;
1228 
1229         GST_OBJECT_LOCK (parse);
1230         for (node = parse-&gt;priv-&gt;pending_seeks; node; node = node-&gt;next) {
1231           GstBaseParseSeek *tmp = node-&gt;data;
1232 
1233           if (tmp-&gt;offset == offset) {
1234             seek = tmp;
1235             break;
1236           }
1237         }
1238         parse-&gt;priv-&gt;pending_seeks =
1239             g_slist_remove (parse-&gt;priv-&gt;pending_seeks, seek);
</pre>
<hr />
<pre>
1251           next_dts = seek-&gt;start_ts;
1252           parse-&gt;priv-&gt;exact_position = seek-&gt;accurate;
1253           g_free (seek);
1254         } else {
1255           /* best attempt convert */
1256           /* as these are only estimates, stop is kept open-ended to avoid
1257            * premature cutting */
1258           gst_base_parse_convert (parse, GST_FORMAT_BYTES, in_segment-&gt;start,
1259               GST_FORMAT_TIME, (gint64 *) &amp; next_dts);
1260 
1261           out_segment.start = next_dts;
1262           out_segment.stop = GST_CLOCK_TIME_NONE;
1263           out_segment.time = next_dts;
1264 
1265           parse-&gt;priv-&gt;exact_position = (in_segment-&gt;start == 0);
1266         }
1267 
1268         gst_event_unref (event);
1269 
1270         event = gst_event_new_segment (&amp;out_segment);
<span class="line-modified">1271         gst_event_set_seqnum (event, parse-&gt;priv-&gt;segment_seqnum);</span>
1272 
1273         GST_DEBUG_OBJECT (parse, &quot;Converted incoming segment to TIME. %&quot;
1274             GST_SEGMENT_FORMAT, in_segment);
1275 
1276       } else if (in_segment-&gt;format != GST_FORMAT_TIME) {
1277         /* Unknown incoming segment format. Output a default open-ended
1278          * TIME segment */
1279         gst_event_unref (event);
1280 
1281         out_segment.start = 0;
1282         out_segment.stop = GST_CLOCK_TIME_NONE;
1283         out_segment.time = 0;
1284 
1285         event = gst_event_new_segment (&amp;out_segment);
<span class="line-modified">1286         gst_event_set_seqnum (event, parse-&gt;priv-&gt;segment_seqnum);</span>
1287 
1288         next_dts = 0;
1289       } else {
1290         /* not considered BYTE seekable if it is talking to us in TIME,
1291          * whatever else it might claim */
1292         parse-&gt;priv-&gt;upstream_seekable = FALSE;
1293         next_dts = in_segment-&gt;start;
1294         gst_event_copy_segment (event, &amp;out_segment);
1295       }
1296 
<span class="line-added">1297       GST_DEBUG_OBJECT (parse, &quot;OUT segment %&quot; GST_SEGMENT_FORMAT,</span>
<span class="line-added">1298           &amp;out_segment);</span>
1299       memcpy (&amp;parse-&gt;segment, &amp;out_segment, sizeof (GstSegment));
1300 
1301       /*
1302          gst_segment_set_newsegment (&amp;parse-&gt;segment, update, rate,
<span class="line-modified">1303          applied_rate, format, start, stop, start);</span>
1304        */
1305 
1306       ret = TRUE;
1307 
1308       /* save the segment for later, right before we push a new buffer so that
1309        * the caps are fixed and the next linked element can receive
1310        * the segment but finish the current segment */
1311       GST_DEBUG_OBJECT (parse, &quot;draining current segment&quot;);
1312       if (in_segment-&gt;rate &gt; 0.0)
1313         gst_base_parse_drain (parse);
1314       else
1315         gst_base_parse_finish_fragment (parse, FALSE);
1316       gst_adapter_clear (parse-&gt;priv-&gt;adapter);
1317 
1318       parse-&gt;priv-&gt;offset = offset;
1319       parse-&gt;priv-&gt;sync_offset = offset;
1320       parse-&gt;priv-&gt;next_dts = next_dts;
1321       parse-&gt;priv-&gt;next_pts = GST_CLOCK_TIME_NONE;
1322       parse-&gt;priv-&gt;last_pts = GST_CLOCK_TIME_NONE;
1323       parse-&gt;priv-&gt;last_dts = GST_CLOCK_TIME_NONE;
</pre>
<hr />
<pre>
1457       }
1458 
1459       gst_base_parse_push_pending_events (parse);
1460 
1461       if (parse-&gt;segment.rate &gt; 0.0)
1462         gst_base_parse_drain (parse);
1463       else
1464         gst_base_parse_finish_fragment (parse, TRUE);
1465       forward_immediate = TRUE;
1466       parse-&gt;priv-&gt;saw_gaps = TRUE;
1467       break;
1468     }
1469     case GST_EVENT_TAG:
1470     {
1471       GstTagList *tags = NULL;
1472 
1473       gst_event_parse_tag (event, &amp;tags);
1474 
1475       /* We only care about stream tags here, global tags we just forward */
1476       if (gst_tag_list_get_scope (tags) != GST_TAG_SCOPE_STREAM)
<span class="line-modified">1477         break;</span>
1478 
1479       gst_base_parse_set_upstream_tags (parse, tags);
1480       gst_base_parse_queue_tag_event_update (parse);
1481       parse-&gt;priv-&gt;tags_changed = FALSE;
1482       gst_event_unref (event);
1483       event = NULL;
1484       ret = TRUE;
1485       break;
1486     }
1487     case GST_EVENT_STREAM_START:
1488     {
1489       if (parse-&gt;priv-&gt;pad_mode != GST_PAD_MODE_PULL)
1490         forward_immediate = TRUE;
1491 
1492       gst_base_parse_set_upstream_tags (parse, NULL);
1493       parse-&gt;priv-&gt;tags_changed = TRUE;
1494       break;
1495     }
1496     default:
1497       break;
</pre>
<hr />
<pre>
1681       if (gst_base_parse_is_seekable (parse))
1682         res = gst_base_parse_handle_seek (parse, event);
1683       break;
1684     default:
1685       res = gst_pad_event_default (parse-&gt;srcpad, GST_OBJECT_CAST (parse),
1686           event);
1687       break;
1688   }
1689   return res;
1690 }
1691 
1692 
1693 /**
1694  * gst_base_parse_convert_default:
1695  * @parse: #GstBaseParse.
1696  * @src_format: #GstFormat describing the source format.
1697  * @src_value: Source value to be converted.
1698  * @dest_format: #GstFormat defining the converted format.
1699  * @dest_value: (out): Pointer where the conversion result will be put.
1700  *
<span class="line-modified">1701  * Default implementation of #GstBaseParseClass.convert().</span>
1702  *
1703  * Returns: %TRUE if conversion was successful.
1704  */
1705 gboolean
1706 gst_base_parse_convert_default (GstBaseParse * parse,
1707     GstFormat src_format,
1708     gint64 src_value, GstFormat dest_format, gint64 * dest_value)
1709 {
1710   gboolean ret = FALSE;
1711   guint64 bytes, duration;
1712 
1713   if (G_UNLIKELY (src_format == dest_format)) {
1714     *dest_value = src_value;
1715     return TRUE;
1716   }
1717 
1718   if (G_UNLIKELY (src_value == -1)) {
1719     *dest_value = -1;
1720     return TRUE;
1721   }
</pre>
<hr />
<pre>
1784   }
1785   return ret;
1786 
1787   /* ERRORS */
1788 no_framecount:
1789   {
1790     GST_DEBUG_OBJECT (parse, &quot;no framecount&quot;);
1791     return FALSE;
1792   }
1793 no_duration_bytes:
1794   {
1795     GST_DEBUG_OBJECT (parse, &quot;no duration %&quot; G_GUINT64_FORMAT &quot;, bytes %&quot;
1796         G_GUINT64_FORMAT, duration, bytes);
1797     return FALSE;
1798   }
1799 no_slaved_conversions:
1800   {
1801     GST_DEBUG_OBJECT (parse,
1802         &quot;Can&#39;t do format conversions when upstream format is not BYTES&quot;);
1803     return FALSE;
<span class="line-modified">1804   }</span>
1805 }
1806 
1807 static void
1808 gst_base_parse_update_duration (GstBaseParse * parse)
1809 {
1810   gint64 ptot, dest_value;
1811 
1812   if (!gst_pad_peer_query_duration (parse-&gt;sinkpad, GST_FORMAT_BYTES, &amp;ptot))
1813     return;
1814 
1815   if (!gst_base_parse_convert (parse, GST_FORMAT_BYTES, ptot,
1816           GST_FORMAT_TIME, &amp;dest_value))
1817     return;
1818 
1819   /* inform if duration changed, but try to avoid spamming */
1820   parse-&gt;priv-&gt;estimated_drift += dest_value - parse-&gt;priv-&gt;estimated_duration;
1821 
1822   parse-&gt;priv-&gt;estimated_duration = dest_value;
1823   GST_LOG_OBJECT (parse,
1824       &quot;updated estimated duration to %&quot; GST_TIME_FORMAT,
1825       GST_TIME_ARGS (dest_value));
1826 
<span class="line-modified">1827   if (parse-&gt;priv-&gt;estimated_drift &gt; GST_SECOND ||</span>
<span class="line-modified">1828       parse-&gt;priv-&gt;estimated_drift &lt; -GST_SECOND) {</span>
<span class="line-modified">1829     gst_element_post_message (GST_ELEMENT (parse),</span>
<span class="line-modified">1830         gst_message_new_duration_changed (GST_OBJECT (parse)));</span>
<span class="line-modified">1831     parse-&gt;priv-&gt;estimated_drift = 0;</span>
<span class="line-modified">1832   }</span>
<span class="line-modified">1833 }</span>
1834 
1835 /* gst_base_parse_update_bitrates:
1836  * @parse: #GstBaseParse.
1837  * @buffer: Current frame as a #GstBuffer
1838  *
1839  * Keeps track of the minimum and maximum bitrates, and also maintains a
1840  * running average bitrate of the stream so far.
1841  */
1842 static void
1843 gst_base_parse_update_bitrates (GstBaseParse * parse, GstBaseParseFrame * frame)
1844 {
1845   guint64 data_len, frame_dur;
1846   gint overhead;
1847   guint frame_bitrate;
1848   guint64 frame_bitrate64;
1849   GstBuffer *buffer = frame-&gt;buffer;
1850 
1851   overhead = frame-&gt;overhead;
1852   if (overhead == -1)
1853     return;
</pre>
<hr />
<pre>
1907   if (G_LIKELY (parse-&gt;priv-&gt;framecount &gt;= MIN_FRAMES_TO_POST_BITRATE)) {
1908     if (frame_bitrate &lt; parse-&gt;priv-&gt;min_bitrate) {
1909       parse-&gt;priv-&gt;min_bitrate = frame_bitrate;
1910       if (parse-&gt;priv-&gt;post_min_bitrate)
1911         parse-&gt;priv-&gt;tags_changed = TRUE;
1912     }
1913 
1914     if (frame_bitrate &gt; parse-&gt;priv-&gt;max_bitrate) {
1915       parse-&gt;priv-&gt;max_bitrate = frame_bitrate;
1916       if (parse-&gt;priv-&gt;post_max_bitrate)
1917         parse-&gt;priv-&gt;tags_changed = TRUE;
1918     }
1919 
1920     /* Only update the tag on a 2% change */
1921     if (parse-&gt;priv-&gt;post_avg_bitrate &amp;&amp; parse-&gt;priv-&gt;avg_bitrate) {
1922       guint64 diffprev = gst_util_uint64_scale (100,
1923           ABSDIFF (parse-&gt;priv-&gt;avg_bitrate, parse-&gt;priv-&gt;posted_avg_bitrate),
1924           parse-&gt;priv-&gt;avg_bitrate);
1925       if (diffprev &gt;= UPDATE_THRESHOLD)
1926         parse-&gt;priv-&gt;tags_changed = TRUE;
<span class="line-added">1927     }</span>
1928   }
1929 }

1930 
1931 /**
1932  * gst_base_parse_add_index_entry:
1933  * @parse: #GstBaseParse.
1934  * @offset: offset of entry
1935  * @ts: timestamp associated with offset
1936  * @key: whether entry refers to keyframe
1937  * @force: add entry disregarding sanity checks
1938  *
1939  * Adds an entry to the index associating @offset to @ts.  It is recommended
1940  * to only add keyframe entries.  @force allows to bypass checks, such as
1941  * whether the stream is (upstream) seekable, another entry is already &quot;close&quot;
1942  * to the new entry, etc.
1943  *
1944  * Returns: #gboolean indicating whether entry was added
1945  */
1946 gboolean
1947 gst_base_parse_add_index_entry (GstBaseParse * parse, guint64 offset,
1948     GstClockTime ts, gboolean key, gboolean force)
1949 {
</pre>
<hr />
<pre>
2148   GstBaseParseFrame *frame = NULL;
2149 
2150   buffer = gst_buffer_make_writable (buffer);
2151 
2152   GST_LOG_OBJECT (parse,
2153       &quot;preparing frame at offset %&quot; G_GUINT64_FORMAT
2154       &quot; (%#&quot; G_GINT64_MODIFIER &quot;x) of size %&quot; G_GSIZE_FORMAT,
2155       GST_BUFFER_OFFSET (buffer), GST_BUFFER_OFFSET (buffer),
2156       gst_buffer_get_size (buffer));
2157 
2158   GST_BUFFER_OFFSET (buffer) = parse-&gt;priv-&gt;offset;
2159 
2160   gst_base_parse_update_flags (parse);
2161 
2162   frame = gst_base_parse_frame_new (buffer, 0, 0);
2163   gst_buffer_unref (buffer);
2164   gst_base_parse_update_frame (parse, frame);
2165 
2166   /* clear flags for next frame */
2167   parse-&gt;priv-&gt;discont = FALSE;
<span class="line-modified">2168   parse-&gt;priv-&gt;new_frame = FALSE;</span>
2169 
2170   /* use default handler to provide initial (upstream) metadata */
2171   gst_base_parse_parse_frame (parse, frame);
2172 
2173   return frame;
2174 }
2175 
2176 /* Wraps buffer in a frame and dispatches to subclass.
2177  * Also manages data skipping and offset handling (including adapter flushing).
2178  * Takes ownership of @buffer */
2179 static GstFlowReturn
2180 gst_base_parse_handle_buffer (GstBaseParse * parse, GstBuffer * buffer,
2181     gint * skip, gint * flushed)
2182 {
2183   GstBaseParseClass *klass = GST_BASE_PARSE_GET_CLASS (parse);
2184   GstBaseParseFrame *frame;
2185   GstFlowReturn ret;
2186 
2187   g_return_val_if_fail (skip != NULL || flushed != NULL, GST_FLOW_ERROR);
2188 
</pre>
<hr />
<pre>
2228       dts = gst_adapter_prev_dts (parse-&gt;priv-&gt;adapter, NULL);
2229       outbuf = gst_adapter_take_buffer (parse-&gt;priv-&gt;adapter, *skip);
2230 #ifdef GSTREAMER_LITE
2231       if (outbuf != NULL) {
2232 #endif // GSTREAMER_LITE
2233       outbuf = gst_buffer_make_writable (outbuf);
2234       GST_BUFFER_PTS (outbuf) = pts;
2235       GST_BUFFER_DTS (outbuf) = dts;
2236       parse-&gt;priv-&gt;buffers_head =
2237           g_slist_prepend (parse-&gt;priv-&gt;buffers_head, outbuf);
2238       outbuf = NULL;
2239 #ifdef GSTREAMER_LITE
2240       }
2241 #endif // GSTREAMER_LITE
2242     } else {
2243       /* If we&#39;re asked to skip more than is available in the adapter,
2244          we need to remember what we need to skip for next iteration */
2245       gsize av = gst_adapter_available (parse-&gt;priv-&gt;adapter);
2246       GST_DEBUG (&quot;Asked to skip %u (%&quot; G_GSIZE_FORMAT &quot; available)&quot;, *skip, av);
2247       if (av &gt;= *skip) {
<span class="line-modified">2248         gst_adapter_flush (parse-&gt;priv-&gt;adapter, *skip);</span>
2249       } else {
2250         GST_DEBUG
2251             (&quot;This is more than available, flushing %&quot; G_GSIZE_FORMAT
2252             &quot;, storing %u to skip&quot;, av, (guint) (*skip - av));
2253         parse-&gt;priv-&gt;skip = *skip - av;
2254         gst_adapter_flush (parse-&gt;priv-&gt;adapter, av);
2255         *skip = av;
<span class="line-modified">2256       }</span>
2257     }
2258     if (!parse-&gt;priv-&gt;discont)
2259       parse-&gt;priv-&gt;sync_offset = parse-&gt;priv-&gt;offset;
2260     parse-&gt;priv-&gt;offset += *skip;
2261     parse-&gt;priv-&gt;discont = TRUE;
2262     /* check for indefinite skipping */
2263     if (ret == GST_FLOW_OK)
2264       ret = gst_base_parse_check_sync (parse);
2265   }
2266 
2267   parse-&gt;priv-&gt;offset += *flushed;
2268 
2269   if (parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_PULL) {
2270     gst_adapter_clear (parse-&gt;priv-&gt;adapter);
2271   }
2272 
2273   if (*skip == 0 &amp;&amp; *flushed == 0) {
2274     /* Carry over discont if we need more data */
2275     if (GST_BUFFER_IS_DISCONT (frame-&gt;buffer))
2276       parse-&gt;priv-&gt;discont = TRUE;
</pre>
<hr />
<pre>
2481   /* Push pending events, including SEGMENT events */
2482   gst_base_parse_push_pending_events (parse);
2483 
2484   /* segment adjustment magic; only if we are running the whole show */
2485   if (!parse-&gt;priv-&gt;passthrough &amp;&amp; parse-&gt;segment.rate &gt; 0.0 &amp;&amp;
2486       (parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_PULL ||
2487           parse-&gt;priv-&gt;upstream_seekable)) {
2488     /* handle gaps */
2489     if (GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.position) &amp;&amp;
2490         GST_CLOCK_TIME_IS_VALID (last_start)) {
2491       GstClockTimeDiff diff;
2492 
2493       /* only send newsegments with increasing start times,
2494        * otherwise if these go back and forth downstream (sinks) increase
2495        * accumulated time and running_time */
2496       diff = GST_CLOCK_DIFF (parse-&gt;segment.position, last_start);
2497       if (G_UNLIKELY (diff &gt; 2 * GST_SECOND
2498               &amp;&amp; last_start &gt; parse-&gt;segment.start
2499               &amp;&amp; (!GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.stop)
2500                   || last_start &lt; parse-&gt;segment.stop))) {
<span class="line-added">2501         GstEvent *topush;</span>
2502 
2503         GST_DEBUG_OBJECT (parse,
2504             &quot;Gap of %&quot; G_GINT64_FORMAT &quot; ns detected in stream &quot; &quot;(%&quot;
2505             GST_TIME_FORMAT &quot; -&gt; %&quot; GST_TIME_FORMAT &quot;). &quot;
2506             &quot;Sending updated SEGMENT events&quot;, diff,
2507             GST_TIME_ARGS (parse-&gt;segment.position),
2508             GST_TIME_ARGS (last_start));
2509 
2510         /* skip gap FIXME */
<span class="line-modified">2511         topush = gst_event_new_segment (&amp;parse-&gt;segment);</span>
<span class="line-modified">2512         if (parse-&gt;priv-&gt;segment_seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added">2513           gst_event_set_seqnum (topush, parse-&gt;priv-&gt;segment_seqnum);</span>
<span class="line-added">2514         gst_pad_push_event (parse-&gt;srcpad, topush);</span>
2515 
2516         parse-&gt;segment.position = last_start;

2517       }
2518     }
<span class="line-added">2519   }</span>
2520 
2521   /* update bitrates and optionally post corresponding tags
2522    * (following newsegment) */
2523   gst_base_parse_update_bitrates (parse, frame);
2524 
2525   if (klass-&gt;pre_push_frame) {
2526     ret = klass-&gt;pre_push_frame (parse, frame);
2527   } else {
2528     frame-&gt;flags |= GST_BASE_PARSE_FRAME_FLAG_CLIP;
2529   }
2530 
2531   /* Push pending events, if there are any new ones
2532    * like tags added by pre_push_frame */
2533   if (parse-&gt;priv-&gt;tags_changed) {
2534     gst_base_parse_queue_tag_event_update (parse);
2535     parse-&gt;priv-&gt;tags_changed = FALSE;
2536   }
2537   gst_base_parse_push_pending_events (parse);
2538 
2539   /* take final ownership of frame buffer */
2540   if (frame-&gt;out_buffer) {
2541     buffer = frame-&gt;out_buffer;
2542     frame-&gt;out_buffer = NULL;
2543     gst_buffer_replace (&amp;frame-&gt;buffer, NULL);
2544   } else {
<span class="line-modified">2545     buffer = frame-&gt;buffer;</span>
<span class="line-modified">2546     frame-&gt;buffer = NULL;</span>
2547   }
2548 
2549   /* subclass must play nice */
2550   g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
2551 
2552   size = gst_buffer_get_size (buffer);
2553 
2554   parse-&gt;priv-&gt;seen_keyframe |= parse-&gt;priv-&gt;is_video &amp;&amp;
2555       !GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DELTA_UNIT);
2556 
2557   if (frame-&gt;flags &amp; GST_BASE_PARSE_FRAME_FLAG_CLIP) {
2558     if (GST_BUFFER_TIMESTAMP_IS_VALID (buffer) &amp;&amp;
2559         GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.stop) &amp;&amp;
2560         GST_BUFFER_TIMESTAMP (buffer) &gt;
2561         parse-&gt;segment.stop + parse-&gt;priv-&gt;lead_out_ts) {
2562       GST_LOG_OBJECT (parse, &quot;Dropped frame, after segment&quot;);
2563       ret = GST_FLOW_EOS;
2564     } else if (GST_BUFFER_TIMESTAMP_IS_VALID (buffer) &amp;&amp;
2565         GST_BUFFER_DURATION_IS_VALID (buffer) &amp;&amp;
2566         GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.start) &amp;&amp;
</pre>
<hr />
<pre>
2594 
2595       /* in backwards playback mode, if on passthrough we need to push buffers
2596        * directly without accumulating them into the buffers_queued as baseparse
2597        * will never check for a DISCONT while on passthrough and those buffers
2598        * will never be pushed.
2599        *
2600        * also, as we are on reverse playback, it might be possible that
2601        * passthrough might have just been enabled, so make sure to drain the
2602        * buffers_queued list */
2603       if (G_UNLIKELY (parse-&gt;priv-&gt;buffers_queued != NULL)) {
2604         gst_base_parse_finish_fragment (parse, TRUE);
2605         ret = gst_base_parse_send_buffers (parse);
2606       }
2607 
2608       if (ret == GST_FLOW_OK) {
2609         GST_LOG_OBJECT (parse,
2610             &quot;pushing frame (%&quot; G_GSIZE_FORMAT &quot; bytes) now..&quot;, size);
2611         ret = gst_pad_push (parse-&gt;srcpad, buffer);
2612         GST_LOG_OBJECT (parse, &quot;frame pushed, flow %s&quot;,
2613             gst_flow_get_name (ret));
<span class="line-modified">2614       } else {</span>
2615         GST_LOG_OBJECT (parse,
2616             &quot;frame (%&quot; G_GSIZE_FORMAT &quot; bytes) not pushed: %s&quot;, size,
2617             gst_flow_get_name (ret));
2618         gst_buffer_unref (buffer);
2619       }
2620 
2621     } else {
2622       GST_LOG_OBJECT (parse, &quot;frame (%&quot; G_GSIZE_FORMAT &quot; bytes) queued for now&quot;,
2623           size);
2624       parse-&gt;priv-&gt;buffers_queued =
2625           g_slist_prepend (parse-&gt;priv-&gt;buffers_queued, buffer);
2626       ret = GST_FLOW_OK;
2627     }
2628   } else {
2629     GST_LOG_OBJECT (parse, &quot;frame (%&quot; G_GSIZE_FORMAT &quot; bytes) not pushed: %s&quot;,
2630         size, gst_flow_get_name (ret));
2631     gst_buffer_unref (buffer);
2632     /* if we are not sufficiently in control, let upstream decide on EOS */
2633     if (ret == GST_FLOW_EOS &amp;&amp; !parse-&gt;priv-&gt;disable_passthrough &amp;&amp;
2634         (parse-&gt;priv-&gt;passthrough ||
</pre>
<hr />
<pre>
2884  * - drain the resulting current fragment data (i.e. repeated chain)
2885  * - add time/duration (if needed) to frames queued by chain
2886  * - push queued data
2887  */
2888 static GstFlowReturn
2889 gst_base_parse_finish_fragment (GstBaseParse * parse, gboolean prev_head)
2890 {
2891   GstBuffer *buf;
2892   GstFlowReturn ret = GST_FLOW_OK;
2893   gboolean seen_key = FALSE, seen_delta = FALSE;
2894 
2895   GST_LOG_OBJECT (parse, &quot;finishing fragment&quot;);
2896 
2897   /* restore order */
2898   parse-&gt;priv-&gt;buffers_pending = g_slist_reverse (parse-&gt;priv-&gt;buffers_pending);
2899   while (parse-&gt;priv-&gt;buffers_pending) {
2900     buf = GST_BUFFER_CAST (parse-&gt;priv-&gt;buffers_pending-&gt;data);
2901     if (prev_head) {
2902       GST_LOG_OBJECT (parse, &quot;adding pending buffer (size %&quot; G_GSIZE_FORMAT &quot;)&quot;,
2903           gst_buffer_get_size (buf));
<span class="line-modified">2904       gst_adapter_push (parse-&gt;priv-&gt;adapter, buf);</span>
2905     } else {
2906       GST_LOG_OBJECT (parse, &quot;discarding head buffer&quot;);
2907       gst_buffer_unref (buf);
2908     }
2909     parse-&gt;priv-&gt;buffers_pending =
2910         g_slist_delete_link (parse-&gt;priv-&gt;buffers_pending,
2911         parse-&gt;priv-&gt;buffers_pending);
2912   }
2913 
2914   /* chain looks for frames and queues resulting ones (in stead of pushing) */
2915   /* initial skipped data is added to buffers_pending */
2916   gst_base_parse_drain (parse);
2917 
2918   if (parse-&gt;priv-&gt;buffers_send) {
2919     buf = GST_BUFFER_CAST (parse-&gt;priv-&gt;buffers_send-&gt;data);
2920     seen_key |= !GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
2921   }
2922 
2923   /* add metadata (if needed to queued buffers */
2924   GST_LOG_OBJECT (parse, &quot;last timestamp: %&quot; GST_TIME_FORMAT,
2925       GST_TIME_ARGS (parse-&gt;priv-&gt;last_pts));
2926   while (parse-&gt;priv-&gt;buffers_queued) {
2927     buf = GST_BUFFER_CAST (parse-&gt;priv-&gt;buffers_queued-&gt;data);
2928 
2929     /* no touching if upstream or parsing provided time */
2930     if (GST_BUFFER_PTS_IS_VALID (buf)) {
2931       GST_LOG_OBJECT (parse, &quot;buffer has time %&quot; GST_TIME_FORMAT,
2932           GST_TIME_ARGS (GST_BUFFER_PTS (buf)));
2933     } else if (GST_BUFFER_DURATION_IS_VALID (buf)) {
2934       if (GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;last_pts)) {
2935         if (G_LIKELY (GST_BUFFER_DURATION (buf) &lt;= parse-&gt;priv-&gt;last_pts))
2936           parse-&gt;priv-&gt;last_pts -= GST_BUFFER_DURATION (buf);
<span class="line-modified">2937         else</span>
2938           parse-&gt;priv-&gt;last_pts = 0;
2939         GST_BUFFER_PTS (buf) = parse-&gt;priv-&gt;last_pts;
<span class="line-modified">2940         GST_LOG_OBJECT (parse, &quot;applied time %&quot; GST_TIME_FORMAT,</span>
2941             GST_TIME_ARGS (GST_BUFFER_PTS (buf)));
2942       }
2943       if (GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;last_dts)) {
2944         if (G_LIKELY (GST_BUFFER_DURATION (buf) &lt;= parse-&gt;priv-&gt;last_dts))
2945           parse-&gt;priv-&gt;last_dts -= GST_BUFFER_DURATION (buf);
2946         else
2947           parse-&gt;priv-&gt;last_dts = 0;
2948         GST_BUFFER_DTS (buf) = parse-&gt;priv-&gt;last_dts;
2949         GST_LOG_OBJECT (parse, &quot;applied dts %&quot; GST_TIME_FORMAT,
2950             GST_TIME_ARGS (GST_BUFFER_DTS (buf)));
2951       }
2952     } else {
2953       /* no idea, very bad */
2954       GST_WARNING_OBJECT (parse, &quot;could not determine time for buffer&quot;);
2955     }
2956 
2957     parse-&gt;priv-&gt;last_pts = GST_BUFFER_PTS (buf);
2958     parse-&gt;priv-&gt;last_dts = GST_BUFFER_DTS (buf);
2959 
2960     /* reverse order for ascending sending */
</pre>
<hr />
<pre>
3198 
3199   if (G_LIKELY (buffer)) {
3200     GST_LOG_OBJECT (parse,
3201         &quot;buffer size: %&quot; G_GSIZE_FORMAT &quot;, offset = %&quot; G_GINT64_FORMAT
3202         &quot;, dts %&quot; GST_TIME_FORMAT &quot;, pts %&quot; GST_TIME_FORMAT,
3203         gst_buffer_get_size (buffer), GST_BUFFER_OFFSET (buffer),
3204         GST_TIME_ARGS (GST_BUFFER_DTS (buffer)),
3205         GST_TIME_ARGS (GST_BUFFER_PTS (buffer)));
3206 
3207     if (G_UNLIKELY (!parse-&gt;priv-&gt;disable_passthrough
3208             &amp;&amp; parse-&gt;priv-&gt;passthrough)) {
3209       GstBaseParseFrame frame;
3210 
3211       gst_base_parse_frame_init (&amp;frame);
3212       frame.buffer = gst_buffer_make_writable (buffer);
3213       ret = gst_base_parse_push_frame (parse, &amp;frame);
3214       gst_base_parse_frame_free (&amp;frame);
3215       return ret;
3216     }
3217     if (G_UNLIKELY (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT))) {
<span class="line-modified">3218       /* upstream feeding us in reverse playback;</span>
<span class="line-modified">3219        * finish previous fragment and start new upon DISCONT */</span>
<span class="line-modified">3220       if (parse-&gt;segment.rate &lt; 0.0) {</span>
3221         GST_DEBUG_OBJECT (parse, &quot;buffer starts new reverse playback fragment&quot;);
3222         ret = gst_base_parse_finish_fragment (parse, TRUE);
3223         gst_base_parse_start_fragment (parse);
3224       } else {
3225         /* discont in the stream, drain and mark discont for next output */
3226         gst_base_parse_drain (parse);
3227         parse-&gt;priv-&gt;discont = TRUE;
3228       }
3229     }
3230     gst_adapter_push (parse-&gt;priv-&gt;adapter, buffer);
3231   }
3232 
3233   /* Parse and push as many frames as possible */
3234   /* Stop either when adapter is empty or we are flushing */
3235   while (!parse-&gt;priv-&gt;flushing) {
3236     gint flush = 0;
3237     gboolean updated_prev_pts = FALSE;
3238 
3239     /* note: if subclass indicates MAX fsize,
3240      * this will not likely be available anyway ... */
<span class="line-modified">3241     min_size = MAX (parse-&gt;priv-&gt;min_frame_size, fsize);</span>
<span class="line-modified">3242     av = gst_adapter_available (parse-&gt;priv-&gt;adapter);</span>








3243 
<span class="line-modified">3244     if (G_UNLIKELY (parse-&gt;priv-&gt;drain)) {</span>
<span class="line-modified">3245       min_size = av;</span>
<span class="line-modified">3246       GST_DEBUG_OBJECT (parse, &quot;draining, data left: %d&quot;, min_size);</span>
<span class="line-added">3247       if (G_UNLIKELY (!min_size)) {</span>
3248         goto done;
3249       }
<span class="line-added">3250     }</span>
<span class="line-added">3251 </span>
<span class="line-added">3252     /* Collect at least min_frame_size bytes */</span>
<span class="line-added">3253     if (av &lt; min_size) {</span>
<span class="line-added">3254       GST_DEBUG_OBJECT (parse, &quot;not enough data available (only %d bytes)&quot;, av);</span>
<span class="line-added">3255       goto done;</span>
<span class="line-added">3256     }</span>
3257 
3258     /* move along with upstream timestamp (if any),
3259      * but interpolate in between */
3260     pts = gst_adapter_prev_pts (parse-&gt;priv-&gt;adapter, NULL);
3261     dts = gst_adapter_prev_dts (parse-&gt;priv-&gt;adapter, NULL);
3262     if (GST_CLOCK_TIME_IS_VALID (pts) &amp;&amp; (parse-&gt;priv-&gt;prev_pts != pts)) {
3263       parse-&gt;priv-&gt;prev_pts = parse-&gt;priv-&gt;next_pts = pts;
3264       updated_prev_pts = TRUE;
3265     }
3266 
3267     if (GST_CLOCK_TIME_IS_VALID (dts) &amp;&amp; (parse-&gt;priv-&gt;prev_dts != dts)) {
3268       parse-&gt;priv-&gt;prev_dts = parse-&gt;priv-&gt;next_dts = dts;
3269       parse-&gt;priv-&gt;prev_dts_from_pts = FALSE;
3270     }
3271 
3272     /* we can mess with, erm interpolate, timestamps,
3273      * and incoming stuff has PTS but no DTS seen so far,
3274      * then pick up DTS from PTS and hope for the best ... */
3275     if (parse-&gt;priv-&gt;infer_ts &amp;&amp;
3276         parse-&gt;priv-&gt;pts_interpolate &amp;&amp;
3277         !GST_CLOCK_TIME_IS_VALID (dts) &amp;&amp;
3278         (!GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;prev_dts)
3279             || (parse-&gt;priv-&gt;prev_dts_from_pts &amp;&amp; updated_prev_pts))
3280         &amp;&amp; GST_CLOCK_TIME_IS_VALID (pts)) {
3281       parse-&gt;priv-&gt;prev_dts = parse-&gt;priv-&gt;next_dts = pts;
3282       parse-&gt;priv-&gt;prev_dts_from_pts = TRUE;
3283     }
3284 
<span class="line-modified">3285     /* always pass all available data */</span>
3286     tmpbuf = gst_adapter_get_buffer (parse-&gt;priv-&gt;adapter, av);
3287 
3288     /* already inform subclass what timestamps we have planned,
3289      * at least if provided by time-based upstream */
3290     if (parse-&gt;priv-&gt;upstream_format == GST_FORMAT_TIME) {
3291       tmpbuf = gst_buffer_make_writable (tmpbuf);
3292       GST_BUFFER_PTS (tmpbuf) = parse-&gt;priv-&gt;next_pts;
3293       GST_BUFFER_DTS (tmpbuf) = parse-&gt;priv-&gt;next_dts;
3294       GST_BUFFER_DURATION (tmpbuf) = GST_CLOCK_TIME_NONE;
<span class="line-modified">3295     }</span>
3296 
3297     /* keep the adapter mapped, so keep track of what has to be flushed */
3298     ret = gst_base_parse_handle_buffer (parse, tmpbuf, &amp;skip, &amp;flush);
3299     tmpbuf = NULL;
3300 
3301     if (ret != GST_FLOW_OK &amp;&amp; ret != GST_FLOW_NOT_LINKED) {
<span class="line-modified">3302       goto done;</span>
<span class="line-modified">3303     }</span>
3304     if (skip == 0 &amp;&amp; flush == 0) {
3305       GST_LOG_OBJECT (parse, &quot;nothing skipped and no frames finished, &quot;
3306           &quot;breaking to get more data&quot;);
3307       /* ignore this return as it produced no data */
3308       ret = old_ret;
<span class="line-modified">3309       goto done;</span>



3310     }
<span class="line-added">3311     if (old_ret == GST_FLOW_OK)</span>
<span class="line-added">3312       old_ret = ret;</span>
<span class="line-added">3313   }</span>
3314 
3315 done:
3316   GST_LOG_OBJECT (parse, &quot;chain leaving&quot;);
3317   return ret;
3318 }
3319 
3320 /* pull @size bytes at current offset,
3321  * i.e. at least try to and possibly return a shorter buffer if near the end */
3322 static GstFlowReturn
3323 gst_base_parse_pull_range (GstBaseParse * parse, guint size,
3324     GstBuffer ** buffer)
3325 {
3326   GstFlowReturn ret = GST_FLOW_OK;
3327 
3328   g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
3329 
3330   /* Caching here actually makes much less difference than one would expect.
3331    * We do it mainly to avoid pulling buffers of 1 byte all the time */
3332   if (parse-&gt;priv-&gt;cache) {
3333     gint64 cache_offset = GST_BUFFER_OFFSET (parse-&gt;priv-&gt;cache);
</pre>
<hr />
<pre>
3341       if (buffer == NULL)
3342         return GST_FLOW_ERROR;
3343 #endif // GSTREAMER_LITE
3344       GST_BUFFER_OFFSET (*buffer) = parse-&gt;priv-&gt;offset;
3345       return GST_FLOW_OK;
3346     }
3347     /* not enough data in the cache, free cache and get a new one */
3348     gst_buffer_unref (parse-&gt;priv-&gt;cache);
3349     parse-&gt;priv-&gt;cache = NULL;
3350   }
3351 
3352   /* refill the cache */
3353   ret =
3354       gst_pad_pull_range (parse-&gt;sinkpad, parse-&gt;priv-&gt;offset, MAX (size,
3355           64 * 1024), &amp;parse-&gt;priv-&gt;cache);
3356   if (ret != GST_FLOW_OK) {
3357     parse-&gt;priv-&gt;cache = NULL;
3358     return ret;
3359   }
3360 


























3361   if (gst_buffer_get_size (parse-&gt;priv-&gt;cache) &lt; size) {
3362     GST_DEBUG_OBJECT (parse, &quot;Returning short buffer at offset %&quot;
3363         G_GUINT64_FORMAT &quot;: wanted %u bytes, got %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
3364         parse-&gt;priv-&gt;offset, size, gst_buffer_get_size (parse-&gt;priv-&gt;cache));
3365 
3366     *buffer = parse-&gt;priv-&gt;cache;
3367     parse-&gt;priv-&gt;cache = NULL;
3368 
3369     return GST_FLOW_OK;
3370   }
3371 
3372   *buffer =
3373       gst_buffer_copy_region (parse-&gt;priv-&gt;cache, GST_BUFFER_COPY_ALL, 0, size);
3374 #ifdef GSTREAMER_LITE
3375   if (buffer == NULL)
3376     return GST_FLOW_ERROR;
3377 #endif // GSTREAMER_LITE
3378   GST_BUFFER_OFFSET (*buffer) = parse-&gt;priv-&gt;offset;
3379 
3380   return GST_FLOW_OK;
</pre>
<hr />
<pre>
3475     /* if we got a short read, inform subclass we are draining leftover
3476      * and no more is to be expected */
3477     if (gst_buffer_get_size (buffer) &lt; min_size) {
3478       GST_LOG_OBJECT (parse, &quot;... but did not get that; marked draining&quot;);
3479       parse-&gt;priv-&gt;drain = TRUE;
3480     }
3481 
3482     if (parse-&gt;priv-&gt;detecting) {
3483       ret = klass-&gt;detect (parse, buffer);
3484       if (ret == GST_FLOW_NOT_NEGOTIATED) {
3485         /* If draining we error out, otherwise request a buffer
3486          * with 64kb more */
3487         if (parse-&gt;priv-&gt;drain) {
3488           gst_buffer_unref (buffer);
3489           GST_ERROR_OBJECT (parse, &quot;Failed to detect format but draining&quot;);
3490           return GST_FLOW_ERROR;
3491         } else {
3492           fsize += 64 * 1024;
3493           gst_buffer_unref (buffer);
3494           continue;
<span class="line-modified">3495         }</span>
3496       } else if (ret != GST_FLOW_OK) {
<span class="line-modified">3497         gst_buffer_unref (buffer);</span>
3498         GST_ERROR_OBJECT (parse, &quot;detect() returned %s&quot;,
3499             gst_flow_get_name (ret));
3500         return ret;
<span class="line-modified">3501       }</span>
3502 
3503       /* Else handle this buffer normally */
<span class="line-modified">3504     }</span>
3505 
3506     ret = gst_base_parse_handle_buffer (parse, buffer, &amp;skip, &amp;flushed);
3507     if (ret != GST_FLOW_OK)
3508       break;
3509 
3510     /* If a large amount of data was requested to be skipped, _handle_buffer
3511        might have set the priv-&gt;skip flag to an extra amount on top of skip.
3512        In pull mode, we can just pull from the new offset directly. */
3513     parse-&gt;priv-&gt;offset += parse-&gt;priv-&gt;skip;
3514     parse-&gt;priv-&gt;skip = 0;
3515 
3516     /* something flushed means something happened,
3517      * and we should bail out of this loop so as not to occupy
3518      * the task thread indefinitely */
3519     if (flushed) {
3520       GST_LOG_OBJECT (parse, &quot;frame finished, breaking loop&quot;);
3521       break;
3522     }
3523     /* nothing flushed, no skip and draining, so nothing left to do */
3524     if (!skip &amp;&amp; parse-&gt;priv-&gt;drain) {
3525       GST_LOG_OBJECT (parse, &quot;no activity or result when draining; &quot;
3526           &quot;breaking loop and marking EOS&quot;);
3527       ret = GST_FLOW_EOS;
3528       break;
3529     }
3530     /* otherwise, get some more data
3531      * note that is checked this does not happen indefinitely */
3532     if (!skip) {
3533       GST_LOG_OBJECT (parse, &quot;getting some more data&quot;);
3534       fsize += 64 * 1024;
<span class="line-modified">3535     }</span>
3536     parse-&gt;priv-&gt;drain = FALSE;
3537   }
3538 
3539 done:
3540   return ret;
3541 }
3542 
3543 /* Loop that is used in pull mode to retrieve data from upstream */
3544 static void
3545 gst_base_parse_loop (GstPad * pad)
3546 {
3547   GstBaseParse *parse;
3548   GstBaseParseClass *klass;
3549   GstFlowReturn ret = GST_FLOW_OK;
3550 
3551   parse = GST_BASE_PARSE (gst_pad_get_parent (pad));
3552   klass = GST_BASE_PARSE_GET_CLASS (parse);
3553 
3554   GST_LOG_OBJECT (parse, &quot;Entering parse loop&quot;);
3555 
</pre>
<hr />
<pre>
3637             gst_message_new_segment_done (GST_OBJECT_CAST (parse),
3638                 GST_FORMAT_TIME, stop));
3639         gst_pad_push_event (parse-&gt;srcpad,
3640             gst_event_new_segment_done (GST_FORMAT_TIME, stop));
3641       } else {
3642         /* If we STILL have zero frames processed, fire an error */
3643         if (parse-&gt;priv-&gt;framecount == 0) {
3644           GST_ELEMENT_ERROR (parse, STREAM, WRONG_TYPE,
3645               (&quot;No valid frames found before end of stream&quot;), (NULL));
3646         }
3647         push_eos = TRUE;
3648       }
3649     } else if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS) {
3650       /* for fatal errors we post an error message, wrong-state is
3651        * not fatal because it happens due to flushes and only means
3652        * that we should stop now. */
3653       GST_ELEMENT_FLOW_ERROR (parse, ret);
3654       push_eos = TRUE;
3655     }
3656     if (push_eos) {
<span class="line-added">3657       GstEvent *topush;</span>
3658       if (parse-&gt;priv-&gt;estimated_duration &lt;= 0) {
3659         gst_base_parse_update_duration (parse);
3660       }
3661       /* Push pending events, including SEGMENT events */
3662       gst_base_parse_push_pending_events (parse);
3663 
<span class="line-modified">3664       topush = gst_event_new_eos ();</span>
<span class="line-added">3665       GST_DEBUG_OBJECT (parse, &quot;segment_seqnum:%&quot; G_GUINT32_FORMAT,</span>
<span class="line-added">3666           parse-&gt;priv-&gt;segment_seqnum);</span>
<span class="line-added">3667       if (parse-&gt;priv-&gt;segment_seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added">3668         gst_event_set_seqnum (topush, parse-&gt;priv-&gt;segment_seqnum);</span>
<span class="line-added">3669       gst_pad_push_event (parse-&gt;srcpad, topush);</span>
3670     }
3671     gst_object_unref (parse);
3672   }
3673 }
3674 
3675 static gboolean
3676 gst_base_parse_sink_activate (GstPad * sinkpad, GstObject * parent)
3677 {
3678   GstSchedulingFlags sched_flags;
3679   GstBaseParse *parse;
3680   GstQuery *query;
3681   gboolean pull_mode;
3682 
3683   parse = GST_BASE_PARSE (parent);
3684 
3685   GST_DEBUG_OBJECT (parse, &quot;sink activate&quot;);
3686 
3687   query = gst_query_new_scheduling ();
3688   if (!gst_pad_peer_query (sinkpad, query)) {
3689     gst_query_unref (query);
3690     goto baseparse_push;
3691   }
3692 
3693   gst_query_parse_scheduling (query, &amp;sched_flags, NULL, NULL, NULL);
3694 
3695   pull_mode = gst_query_has_scheduling_mode (query, GST_PAD_MODE_PULL)
3696       &amp;&amp; ((sched_flags &amp; GST_SCHEDULING_FLAG_SEEKABLE) != 0);
3697 
3698   gst_query_unref (query);
3699 
3700   if (!pull_mode)
3701     goto baseparse_push;
3702 
<span class="line-modified">3703   GST_DEBUG_OBJECT (parse, &quot;trying to activate in pull mode&quot;);</span>
3704   if (!gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PULL, TRUE))
3705     goto baseparse_push;
3706 
3707   parse-&gt;priv-&gt;push_stream_start = TRUE;
3708   /* In pull mode, upstream is BYTES */
3709   parse-&gt;priv-&gt;upstream_format = GST_FORMAT_BYTES;
3710 
3711   return gst_pad_start_task (sinkpad, (GstTaskFunction) gst_base_parse_loop,
3712       sinkpad, NULL);
3713   /* fallback */
3714 baseparse_push:
3715   {
3716     GST_DEBUG_OBJECT (parse, &quot;trying to activate in push mode&quot;);
3717     return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PUSH, TRUE);
3718   }
3719 }
3720 
3721 static gboolean
3722 gst_base_parse_activate (GstBaseParse * parse, gboolean active)
3723 {
</pre>
<hr />
<pre>
3751   return result;
3752 }
3753 
3754 static gboolean
3755 gst_base_parse_sink_activate_mode (GstPad * pad, GstObject * parent,
3756     GstPadMode mode, gboolean active)
3757 {
3758   gboolean result;
3759   GstBaseParse *parse;
3760 
3761   parse = GST_BASE_PARSE (parent);
3762 
3763   GST_DEBUG_OBJECT (parse, &quot;sink %sactivate in %s mode&quot;,
3764       (active) ? &quot;&quot; : &quot;de&quot;, gst_pad_mode_get_name (mode));
3765 
3766   if (!gst_base_parse_activate (parse, active))
3767     goto activate_failed;
3768 
3769   switch (mode) {
3770     case GST_PAD_MODE_PULL:
<span class="line-modified">3771       if (active) {</span>
<span class="line-added">3772         GstEvent *ev = gst_event_new_segment (&amp;parse-&gt;segment);</span>
<span class="line-added">3773         parse-&gt;priv-&gt;segment_seqnum = gst_event_get_seqnum (ev);</span>
3774         parse-&gt;priv-&gt;pending_events =
<span class="line-modified">3775             g_list_prepend (parse-&gt;priv-&gt;pending_events, ev);</span>

3776         result = TRUE;
<span class="line-modified">3777       } else {</span>
3778         result = gst_pad_stop_task (pad);
<span class="line-modified">3779       }</span>
3780       break;
3781     default:
3782       result = TRUE;
3783       break;
3784   }
3785   if (result)
3786     parse-&gt;priv-&gt;pad_mode = active ? mode : GST_PAD_MODE_NONE;
3787 
3788   GST_DEBUG_OBJECT (parse, &quot;sink activate return: %d&quot;, result);
3789 
3790   return result;
3791 
3792   /* ERRORS */
3793 activate_failed:
3794   {
3795     GST_DEBUG_OBJECT (parse, &quot;activate failed&quot;);
3796     return FALSE;
3797   }
3798 }
3799 
</pre>
<hr />
<pre>
3850  * @bitrate: average bitrate in bits/second
3851  *
3852  * Optionally sets the average bitrate detected in media (if non-zero),
3853  * e.g. based on metadata, as it will be posted to the application.
3854  *
3855  * By default, announced average bitrate is estimated. The average bitrate
3856  * is used to estimate the total duration of the stream and to estimate
3857  * a seek position, if there&#39;s no index and the format is syncable
3858  * (see gst_base_parse_set_syncable()).
3859  */
3860 void
3861 gst_base_parse_set_average_bitrate (GstBaseParse * parse, guint bitrate)
3862 {
3863   parse-&gt;priv-&gt;bitrate = bitrate;
3864   GST_DEBUG_OBJECT (parse, &quot;bitrate %u&quot;, bitrate);
3865 }
3866 
3867 /**
3868  * gst_base_parse_set_min_frame_size:
3869  * @parse: #GstBaseParse.
<span class="line-modified">3870  * @min_size: Minimum size in bytes of the data that this base class should</span>
<span class="line-modified">3871  *       give to subclass.</span>
3872  *
3873  * Subclass can use this function to tell the base class that it needs to
<span class="line-modified">3874  * be given buffers of at least @min_size bytes.</span>
3875  */
3876 void
3877 gst_base_parse_set_min_frame_size (GstBaseParse * parse, guint min_size)
3878 {
3879   g_return_if_fail (parse != NULL);
3880 
3881   parse-&gt;priv-&gt;min_frame_size = min_size;
3882   GST_LOG_OBJECT (parse, &quot;set frame_min_size: %d&quot;, min_size);
3883 }
3884 
3885 /**
3886  * gst_base_parse_set_frame_rate:
3887  * @parse: the #GstBaseParse to set
3888  * @fps_num: frames per second (numerator).
3889  * @fps_den: frames per second (denominator).
3890  * @lead_in: frames needed before a segment for subsequent decode
3891  * @lead_out: frames needed after a segment
3892  *
3893  * If frames per second is configured, parser can take care of buffer duration
3894  * and timestamping.  When performing segment clipping, or seeking to a specific
</pre>
<hr />
<pre>
3962  *
3963  * Set if frame starts can be identified. This is set by default and
3964  * determines whether seeking based on bitrate averages
3965  * is possible for a format/stream.
3966  */
3967 void
3968 gst_base_parse_set_syncable (GstBaseParse * parse, gboolean syncable)
3969 {
3970   parse-&gt;priv-&gt;syncable = syncable;
3971   GST_INFO_OBJECT (parse, &quot;syncable: %s&quot;, (syncable) ? &quot;yes&quot; : &quot;no&quot;);
3972 }
3973 
3974 /**
3975  * gst_base_parse_set_passthrough:
3976  * @parse: a #GstBaseParse
3977  * @passthrough: %TRUE if parser should run in passthrough mode
3978  *
3979  * Set if the nature of the format or configuration does not allow (much)
3980  * parsing, and the parser should operate in passthrough mode (which only
3981  * applies when operating in push mode). That is, incoming buffers are
<span class="line-modified">3982  * pushed through unmodified, i.e. no #GstBaseParseClass.handle_frame()</span>
<span class="line-modified">3983  * will be invoked, but #GstBaseParseClass.pre_push_frame() will still be</span>
<span class="line-modified">3984  * invoked, so subclass can perform as much or as little is appropriate for</span>
<span class="line-modified">3985  * passthrough semantics in #GstBaseParseClass.pre_push_frame().</span>
3986  */
3987 void
3988 gst_base_parse_set_passthrough (GstBaseParse * parse, gboolean passthrough)
3989 {
3990   parse-&gt;priv-&gt;passthrough = passthrough;
3991   GST_INFO_OBJECT (parse, &quot;passthrough: %s&quot;, (passthrough) ? &quot;yes&quot; : &quot;no&quot;);
3992 }
3993 
3994 /**
3995  * gst_base_parse_set_pts_interpolation:
3996  * @parse: a #GstBaseParse
3997  * @pts_interpolate: %TRUE if parser should interpolate PTS timestamps
3998  *
3999  * By default, the base class will guess PTS timestamps using a simple
4000  * interpolation (previous timestamp + duration), which is incorrect for
4001  * data streams with reordering, where PTS can go backward. Sub-classes
4002  * implementing such formats should disable PTS interpolation.
4003  */
4004 void
4005 gst_base_parse_set_pts_interpolation (GstBaseParse * parse,
</pre>
<hr />
<pre>
4087 gst_base_parse_src_query_default (GstBaseParse * parse, GstQuery * query)
4088 {
4089   gboolean res = FALSE;
4090   GstPad *pad;
4091 
4092   pad = GST_BASE_PARSE_SRC_PAD (parse);
4093 
4094   switch (GST_QUERY_TYPE (query)) {
4095     case GST_QUERY_POSITION:
4096     {
4097       gint64 dest_value;
4098       GstFormat format;
4099 
4100       GST_DEBUG_OBJECT (parse, &quot;position query&quot;);
4101       gst_query_parse_position (query, &amp;format, NULL);
4102 
4103       /* try upstream first */
4104       res = gst_pad_query_default (pad, GST_OBJECT_CAST (parse), query);
4105       if (!res) {
4106         /* Fall back on interpreting segment */
<span class="line-modified">4107         GST_OBJECT_LOCK (parse);</span>
4108         /* Only reply BYTES if upstream is in BYTES already, otherwise
4109          * we&#39;re not in charge */
4110         if (format == GST_FORMAT_BYTES
4111             &amp;&amp; parse-&gt;priv-&gt;upstream_format == GST_FORMAT_BYTES) {
<span class="line-modified">4112           dest_value = parse-&gt;priv-&gt;offset;</span>
<span class="line-modified">4113           res = TRUE;</span>
<span class="line-modified">4114         } else if (format == parse-&gt;segment.format &amp;&amp;</span>
4115             GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.position)) {
4116           dest_value = gst_segment_to_stream_time (&amp;parse-&gt;segment,
4117               parse-&gt;segment.format, parse-&gt;segment.position);
<span class="line-modified">4118           res = TRUE;</span>
<span class="line-modified">4119         }</span>
<span class="line-modified">4120         GST_OBJECT_UNLOCK (parse);</span>
4121         if (!res &amp;&amp; parse-&gt;priv-&gt;upstream_format == GST_FORMAT_BYTES) {
4122           /* no precise result, upstream no idea either, then best estimate */
4123           /* priv-&gt;offset is updated in both PUSH/PULL modes, *iff* we&#39;re
4124            * in charge of things */
4125           res = gst_base_parse_convert (parse,
4126               GST_FORMAT_BYTES, parse-&gt;priv-&gt;offset, format, &amp;dest_value);
4127         }
4128         if (res)
4129           gst_query_set_position (query, format, dest_value);
4130       }
4131       break;
4132     }
4133     case GST_QUERY_DURATION:
4134     {
4135       GstFormat format;
4136       GstClockTime duration;
4137 
4138       GST_DEBUG_OBJECT (parse, &quot;duration query&quot;);
4139       gst_query_parse_duration (query, &amp;format, NULL);
4140 
</pre>
<hr />
<pre>
4200           dest_format, &amp;dest_value);
4201       if (res) {
4202         gst_query_set_convert (query, src_format, src_value,
4203             dest_format, dest_value);
4204       }
4205       break;
4206     }
4207     case GST_QUERY_LATENCY:
4208     {
4209       if ((res = gst_pad_peer_query (parse-&gt;sinkpad, query))) {
4210         gboolean live;
4211         GstClockTime min_latency, max_latency;
4212 
4213         gst_query_parse_latency (query, &amp;live, &amp;min_latency, &amp;max_latency);
4214         GST_DEBUG_OBJECT (parse, &quot;Peer latency: live %d, min %&quot;
4215             GST_TIME_FORMAT &quot; max %&quot; GST_TIME_FORMAT, live,
4216             GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
4217 
4218         GST_OBJECT_LOCK (parse);
4219         /* add our latency */
<span class="line-modified">4220         min_latency += parse-&gt;priv-&gt;min_latency;</span>
4221         if (max_latency == -1 || parse-&gt;priv-&gt;max_latency == -1)
4222           max_latency = -1;
4223         else
4224           max_latency += parse-&gt;priv-&gt;max_latency;
4225         GST_OBJECT_UNLOCK (parse);
4226 
4227         gst_query_set_latency (query, live, min_latency, max_latency);
4228       }
4229       break;
4230     }
4231     case GST_QUERY_SEGMENT:
4232     {
4233       GstFormat format;
4234       gint64 start, stop;
4235 
4236       format = parse-&gt;segment.format;
4237 
4238       start =
4239           gst_segment_to_stream_time (&amp;parse-&gt;segment, format,
4240           parse-&gt;segment.start);
</pre>
<hr />
<pre>
4601     GstClockTime startpos;
4602     if (rate &gt;= 0)
4603       startpos = seeksegment.position;
4604     else
4605       startpos = start;
4606 
4607     /* accurate requested, so ... seek a bit before target */
4608     if (startpos &lt; parse-&gt;priv-&gt;lead_in_ts)
4609       startpos = 0;
4610     else
4611       startpos -= parse-&gt;priv-&gt;lead_in_ts;
4612 
4613     if (seeksegment.stop == -1 &amp;&amp; seeksegment.duration != -1)
4614       seeksegment.stop = seeksegment.start + seeksegment.duration;
4615 
4616     seekpos = gst_base_parse_find_offset (parse, startpos, TRUE, &amp;start_ts);
4617     seekstop = gst_base_parse_find_offset (parse, seeksegment.stop, FALSE,
4618         NULL);
4619   } else {
4620     if (rate &gt;= 0)
<span class="line-modified">4621       start_ts = seeksegment.position;</span>
4622     else
4623       start_ts = start;
4624 
4625     if (seeksegment.stop == -1 &amp;&amp; seeksegment.duration != -1)
4626       seeksegment.stop = seeksegment.start + seeksegment.duration;
4627 
4628     if (!gst_base_parse_convert (parse, format, start_ts,
4629             GST_FORMAT_BYTES, &amp;seekpos))
4630       goto convert_failed;
4631     if (!gst_base_parse_convert (parse, format, seeksegment.stop,
4632             GST_FORMAT_BYTES, &amp;seekstop))
4633       goto convert_failed;
4634   }
4635 
4636   GST_DEBUG_OBJECT (parse,
4637       &quot;seek position %&quot; G_GINT64_FORMAT &quot; in bytes: %&quot; G_GINT64_FORMAT,
4638       start_ts, seekpos);
4639   GST_DEBUG_OBJECT (parse,
4640       &quot;seek stop %&quot; G_GINT64_FORMAT &quot; in bytes: %&quot; G_GINT64_FORMAT,
4641       seeksegment.stop, seekstop);
</pre>
<hr />
<pre>
4764     seek-&gt;offset = seekpos;
4765     seek-&gt;start_ts = start_ts;
4766     GST_OBJECT_LOCK (parse);
4767     /* less optimal, but preserves order */
4768     parse-&gt;priv-&gt;pending_seeks =
4769         g_slist_append (parse-&gt;priv-&gt;pending_seeks, seek);
4770     GST_OBJECT_UNLOCK (parse);
4771 
4772     res = gst_pad_push_event (parse-&gt;sinkpad, new_event);
4773 
4774     if (!res) {
4775       GST_OBJECT_LOCK (parse);
4776       parse-&gt;priv-&gt;pending_seeks =
4777           g_slist_remove (parse-&gt;priv-&gt;pending_seeks, seek);
4778       GST_OBJECT_UNLOCK (parse);
4779       g_free (seek);
4780     }
4781   }
4782 
4783 done:
<span class="line-modified">4784   gst_event_unref (event);</span>
4785   return res;
4786 
4787   /* ERRORS */
4788 negative_rate:
4789   {
4790     GST_DEBUG_OBJECT (parse, &quot;negative playback rates delegated upstream.&quot;);
4791     res = FALSE;
4792     goto done;
4793   }
4794 wrong_type:
4795   {
4796     GST_DEBUG_OBJECT (parse, &quot;unsupported seek type.&quot;);
4797     res = FALSE;
4798     goto done;
4799   }
4800 no_convert_to_time:
4801   {
4802     GST_DEBUG_OBJECT (parse, &quot;seek in %s format was requested, but subclass &quot;
4803         &quot;couldn&#39;t convert that into TIME format&quot;, gst_format_get_name (format));
4804     res = FALSE;
</pre>
<hr />
<pre>
4812   }
4813 }
4814 
4815 static void
4816 gst_base_parse_set_upstream_tags (GstBaseParse * parse, GstTagList * taglist)
4817 {
4818   if (taglist == parse-&gt;priv-&gt;upstream_tags)
4819     return;
4820 
4821   if (parse-&gt;priv-&gt;upstream_tags) {
4822     gst_tag_list_unref (parse-&gt;priv-&gt;upstream_tags);
4823     parse-&gt;priv-&gt;upstream_tags = NULL;
4824   }
4825 
4826   GST_INFO_OBJECT (parse, &quot;upstream tags: %&quot; GST_PTR_FORMAT, taglist);
4827 
4828   if (taglist != NULL)
4829     parse-&gt;priv-&gt;upstream_tags = gst_tag_list_ref (taglist);
4830 
4831   gst_base_parse_check_bitrate_tags (parse);
<span class="line-modified">4832 }</span>
4833 
4834 #if 0
4835 static void
4836 gst_base_parse_set_index (GstElement * element, GstIndex * index)
4837 {
4838   GstBaseParse *parse = GST_BASE_PARSE (element);
4839 
4840   GST_BASE_PARSE_INDEX_LOCK (parse);
4841   if (parse-&gt;priv-&gt;index)
4842     gst_object_unref (parse-&gt;priv-&gt;index);
4843   if (index) {
4844     parse-&gt;priv-&gt;index = gst_object_ref (index);
4845     gst_index_get_writer_id (index, GST_OBJECT_CAST (element),
4846         &amp;parse-&gt;priv-&gt;index_id);
4847     parse-&gt;priv-&gt;own_index = FALSE;
4848   } else {
4849     parse-&gt;priv-&gt;index = NULL;
4850   }
4851   GST_BASE_PARSE_INDEX_UNLOCK (parse);
4852 }
</pre>
<hr />
<pre>
4933 gst_base_parse_set_ts_at_offset (GstBaseParse * parse, gsize offset)
4934 {
4935   GstClockTime pts, dts;
4936 
4937   g_return_if_fail (GST_IS_BASE_PARSE (parse));
4938 
4939   pts = gst_adapter_prev_pts_at_offset (parse-&gt;priv-&gt;adapter, offset, NULL);
4940   dts = gst_adapter_prev_dts_at_offset (parse-&gt;priv-&gt;adapter, offset, NULL);
4941 
4942   if (!GST_CLOCK_TIME_IS_VALID (pts) || !GST_CLOCK_TIME_IS_VALID (dts)) {
4943     GST_DEBUG_OBJECT (parse,
4944         &quot;offset adapter timestamps dts=%&quot; GST_TIME_FORMAT &quot; pts=%&quot;
4945         GST_TIME_FORMAT, GST_TIME_ARGS (dts), GST_TIME_ARGS (pts));
4946   }
4947   if (GST_CLOCK_TIME_IS_VALID (pts) &amp;&amp; (parse-&gt;priv-&gt;prev_pts != pts))
4948     parse-&gt;priv-&gt;prev_pts = parse-&gt;priv-&gt;next_pts = pts;
4949 
4950   if (GST_CLOCK_TIME_IS_VALID (dts) &amp;&amp; (parse-&gt;priv-&gt;prev_dts != dts)) {
4951     parse-&gt;priv-&gt;prev_dts = parse-&gt;priv-&gt;next_dts = dts;
4952     parse-&gt;priv-&gt;prev_dts_from_pts = FALSE;
<span class="line-modified">4953   }</span>
4954 }
4955 
4956 /**
4957  * gst_base_parse_merge_tags:
4958  * @parse: a #GstBaseParse
4959  * @tags: (allow-none): a #GstTagList to merge, or NULL to unset
4960  *     previously-set tags
4961  * @mode: the #GstTagMergeMode to use, usually #GST_TAG_MERGE_REPLACE
4962  *
4963  * Sets the parser subclass&#39;s tags and how they should be merged with any
4964  * upstream stream tags. This will override any tags previously-set
4965  * with gst_base_parse_merge_tags().
4966  *
4967  * Note that this is provided for convenience, and the subclass is
4968  * not required to use this and can still do tag handling on its own.
4969  *
4970  * Since: 1.6
4971  */
4972 void
4973 gst_base_parse_merge_tags (GstBaseParse * parse, GstTagList * tags,
</pre>
</td>
</tr>
</table>
<center><a href="gstadapter.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstbaseparse.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>