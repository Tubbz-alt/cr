<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gscanner.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * GScanner: Flexible lexical scanner for general purpose.
   5  * Copyright (C) 1997, 1998 Tim Janik
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Lesser General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2.1 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Lesser General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Lesser General Public
  18  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  19  */
  20 
  21 /*
  22  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  23  * file for a list of people on the GLib Team.  See the ChangeLog
  24  * files for a list of changes.  These files are distributed with
  25  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  26  */
  27 
  28 /*
  29  * MT safe
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 
  34 #include &lt;errno.h&gt;
  35 #include &lt;stdlib.h&gt;
  36 #include &lt;stdarg.h&gt;
  37 #include &lt;string.h&gt;
  38 #include &lt;stdio.h&gt;
  39 
  40 #include &quot;gscanner.h&quot;
  41 
  42 #include &quot;gprintfint.h&quot;
  43 #include &quot;gstrfuncs.h&quot;
  44 #include &quot;gstring.h&quot;
  45 #include &quot;gtestutils.h&quot;
  46 
  47 #ifdef G_OS_UNIX
  48 #include &lt;unistd.h&gt;
  49 #endif
  50 #ifdef G_OS_WIN32
  51 #include &lt;io.h&gt;
  52 #endif
  53 
  54 
  55 /**
  56  * SECTION:scanner
  57  * @title: Lexical Scanner
  58  * @short_description: a general purpose lexical scanner
  59  *
  60  * The #GScanner and its associated functions provide a
  61  * general purpose lexical scanner.
  62  */
  63 
  64 /**
  65  * GScannerMsgFunc:
  66  * @scanner: a #GScanner
  67  * @message: the message
  68  * @error: %TRUE if the message signals an error,
  69  *     %FALSE if it signals a warning.
  70  *
  71  * Specifies the type of the message handler function.
  72  */
  73 
  74 /**
  75  * G_CSET_a_2_z:
  76  *
  77  * The set of lowercase ASCII alphabet characters.
  78  * Used for specifying valid identifier characters
  79  * in #GScannerConfig.
  80  */
  81 
  82 /**
  83  * G_CSET_A_2_Z:
  84  *
  85  * The set of uppercase ASCII alphabet characters.
  86  * Used for specifying valid identifier characters
  87  * in #GScannerConfig.
  88  */
  89 
  90 /**
  91  * G_CSET_DIGITS:
  92  *
  93  * The set of ASCII digits.
  94  * Used for specifying valid identifier characters
  95  * in #GScannerConfig.
  96  */
  97 
  98 /**
  99  * G_CSET_LATINC:
 100  *
 101  * The set of uppercase ISO 8859-1 alphabet characters
 102  * which are not ASCII characters.
 103  * Used for specifying valid identifier characters
 104  * in #GScannerConfig.
 105  */
 106 
 107 /**
 108  * G_CSET_LATINS:
 109  *
 110  * The set of lowercase ISO 8859-1 alphabet characters
 111  * which are not ASCII characters.
 112  * Used for specifying valid identifier characters
 113  * in #GScannerConfig.
 114  */
 115 
 116 /**
 117  * GTokenType:
 118  * @G_TOKEN_EOF: the end of the file
 119  * @G_TOKEN_LEFT_PAREN: a &#39;(&#39; character
 120  * @G_TOKEN_LEFT_CURLY: a &#39;{&#39; character
 121  * @G_TOKEN_LEFT_BRACE: a &#39;[&#39; character
 122  * @G_TOKEN_RIGHT_CURLY: a &#39;}&#39; character
 123  * @G_TOKEN_RIGHT_PAREN: a &#39;)&#39; character
 124  * @G_TOKEN_RIGHT_BRACE: a &#39;]&#39; character
 125  * @G_TOKEN_EQUAL_SIGN: a &#39;=&#39; character
 126  * @G_TOKEN_COMMA: a &#39;,&#39; character
 127  * @G_TOKEN_NONE: not a token
 128  * @G_TOKEN_ERROR: an error occurred
 129  * @G_TOKEN_CHAR: a character
 130  * @G_TOKEN_BINARY: a binary integer
 131  * @G_TOKEN_OCTAL: an octal integer
 132  * @G_TOKEN_INT: an integer
 133  * @G_TOKEN_HEX: a hex integer
 134  * @G_TOKEN_FLOAT: a floating point number
 135  * @G_TOKEN_STRING: a string
 136  * @G_TOKEN_SYMBOL: a symbol
 137  * @G_TOKEN_IDENTIFIER: an identifier
 138  * @G_TOKEN_IDENTIFIER_NULL: a null identifier
 139  * @G_TOKEN_COMMENT_SINGLE: one line comment
 140  * @G_TOKEN_COMMENT_MULTI: multi line comment
 141  *
 142  * The possible types of token returned from each
 143  * g_scanner_get_next_token() call.
 144  */
 145 
 146 /**
 147  * GTokenValue:
 148  * @v_symbol: token symbol value
 149  * @v_identifier: token identifier value
 150  * @v_binary: token binary integer value
 151  * @v_octal: octal integer value
 152  * @v_int: integer value
 153  * @v_int64: 64-bit integer value
 154  * @v_float: floating point value
 155  * @v_hex: hex integer value
 156  * @v_string: string value
 157  * @v_comment: comment value
 158  * @v_char: character value
 159  * @v_error: error value
 160  *
 161  * A union holding the value of the token.
 162  */
 163 
 164 /**
 165  * GErrorType:
 166  * @G_ERR_UNKNOWN: unknown error
 167  * @G_ERR_UNEXP_EOF: unexpected end of file
 168  * @G_ERR_UNEXP_EOF_IN_STRING: unterminated string constant
 169  * @G_ERR_UNEXP_EOF_IN_COMMENT: unterminated comment
 170  * @G_ERR_NON_DIGIT_IN_CONST: non-digit character in a number
 171  * @G_ERR_DIGIT_RADIX: digit beyond radix in a number
 172  * @G_ERR_FLOAT_RADIX: non-decimal floating point number
 173  * @G_ERR_FLOAT_MALFORMED: malformed floating point number
 174  *
 175  * The possible errors, used in the @v_error field
 176  * of #GTokenValue, when the token is a %G_TOKEN_ERROR.
 177  */
 178 
 179 /**
 180  * GScanner:
 181  * @user_data: unused
 182  * @max_parse_errors: unused
 183  * @parse_errors: g_scanner_error() increments this field
 184  * @input_name: name of input stream, featured by the default message handler
 185  * @qdata: quarked data
 186  * @config: link into the scanner configuration
 187  * @token: token parsed by the last g_scanner_get_next_token()
 188  * @value: value of the last token from g_scanner_get_next_token()
 189  * @line: line number of the last token from g_scanner_get_next_token()
 190  * @position: char number of the last token from g_scanner_get_next_token()
 191  * @next_token: token parsed by the last g_scanner_peek_next_token()
 192  * @next_value: value of the last token from g_scanner_peek_next_token()
 193  * @next_line: line number of the last token from g_scanner_peek_next_token()
 194  * @next_position: char number of the last token from g_scanner_peek_next_token()
 195  * @msg_handler: handler function for _warn and _error
 196  *
 197  * The data structure representing a lexical scanner.
 198  *
 199  * You should set @input_name after creating the scanner, since
 200  * it is used by the default message handler when displaying
 201  * warnings and errors. If you are scanning a file, the filename
 202  * would be a good choice.
 203  *
 204  * The @user_data and @max_parse_errors fields are not used.
 205  * If you need to associate extra data with the scanner you
 206  * can place them here.
 207  *
 208  * If you want to use your own message handler you can set the
 209  * @msg_handler field. The type of the message handler function
 210  * is declared by #GScannerMsgFunc.
 211  */
 212 
 213 /**
 214  * GScannerConfig:
 215  * @cset_skip_characters: specifies which characters should be skipped
 216  *     by the scanner (the default is the whitespace characters: space,
 217  *     tab, carriage-return and line-feed).
 218  * @cset_identifier_first: specifies the characters which can start
 219  *     identifiers (the default is #G_CSET_a_2_z, &quot;_&quot;, and #G_CSET_A_2_Z).
 220  * @cset_identifier_nth: specifies the characters which can be used
 221  *     in identifiers, after the first character (the default is
 222  *     #G_CSET_a_2_z, &quot;_0123456789&quot;, #G_CSET_A_2_Z, #G_CSET_LATINS,
 223  *     #G_CSET_LATINC).
 224  * @cpair_comment_single: specifies the characters at the start and
 225  *     end of single-line comments. The default is &quot;#\n&quot; which means
 226  *     that single-line comments start with a &#39;#&#39; and continue until
 227  *     a &#39;\n&#39; (end of line).
 228  * @case_sensitive: specifies if symbols are case sensitive (the
 229  *     default is %FALSE).
 230  * @skip_comment_multi: specifies if multi-line comments are skipped
 231  *     and not returned as tokens (the default is %TRUE).
 232  * @skip_comment_single: specifies if single-line comments are skipped
 233  *     and not returned as tokens (the default is %TRUE).
 234  * @scan_comment_multi: specifies if multi-line comments are recognized
 235  *     (the default is %TRUE).
 236  * @scan_identifier: specifies if identifiers are recognized (the
 237  *     default is %TRUE).
 238  * @scan_identifier_1char: specifies if single-character
 239  *     identifiers are recognized (the default is %FALSE).
 240  * @scan_identifier_NULL: specifies if %NULL is reported as
 241  *     %G_TOKEN_IDENTIFIER_NULL (the default is %FALSE).
 242  * @scan_symbols: specifies if symbols are recognized (the default
 243  *     is %TRUE).
 244  * @scan_binary: specifies if binary numbers are recognized (the
 245  *     default is %FALSE).
 246  * @scan_octal: specifies if octal numbers are recognized (the
 247  *     default is %TRUE).
 248  * @scan_float: specifies if floating point numbers are recognized
 249  *     (the default is %TRUE).
 250  * @scan_hex: specifies if hexadecimal numbers are recognized (the
 251  *     default is %TRUE).
 252  * @scan_hex_dollar: specifies if &#39;$&#39; is recognized as a prefix for
 253  *     hexadecimal numbers (the default is %FALSE).
 254  * @scan_string_sq: specifies if strings can be enclosed in single
 255  *     quotes (the default is %TRUE).
 256  * @scan_string_dq: specifies if strings can be enclosed in double
 257  *     quotes (the default is %TRUE).
 258  * @numbers_2_int: specifies if binary, octal and hexadecimal numbers
 259  *     are reported as #G_TOKEN_INT (the default is %TRUE).
 260  * @int_2_float: specifies if all numbers are reported as %G_TOKEN_FLOAT
 261  *     (the default is %FALSE).
 262  * @identifier_2_string: specifies if identifiers are reported as strings
 263  *     (the default is %FALSE).
 264  * @char_2_token: specifies if characters are reported by setting
 265  *     `token = ch` or as %G_TOKEN_CHAR (the default is %TRUE).
 266  * @symbol_2_token: specifies if symbols are reported by setting
 267  *     `token = v_symbol` or as %G_TOKEN_SYMBOL (the default is %FALSE).
 268  * @scope_0_fallback: specifies if a symbol is searched for in the
 269  *     default scope in addition to the current scope (the default is %FALSE).
 270  * @store_int64: use value.v_int64 rather than v_int
 271  *
 272  * Specifies the #GScanner parser configuration. Most settings can
 273  * be changed during the parsing phase and will affect the lexical
 274  * parsing of the next unpeeked token.
 275  */
 276 
 277 /* --- defines --- */
 278 #define to_lower(c)       ( \
 279   (guchar) (              \
 280     ( (((guchar)(c))&gt;=&#39;A&#39; &amp;&amp; ((guchar)(c))&lt;=&#39;Z&#39;) * (&#39;a&#39;-&#39;A&#39;) ) |  \
 281     ( (((guchar)(c))&gt;=192 &amp;&amp; ((guchar)(c))&lt;=214) * (224-192) ) |  \
 282     ( (((guchar)(c))&gt;=216 &amp;&amp; ((guchar)(c))&lt;=222) * (248-216) ) |  \
 283     ((guchar)(c))             \
 284   )               \
 285 )
 286 #define READ_BUFFER_SIZE  (4000)
 287 
 288 
 289 /* --- typedefs --- */
 290 typedef struct  _GScannerKey  GScannerKey;
 291 
 292 struct  _GScannerKey
 293 {
 294   guint    scope_id;
 295   gchar   *symbol;
 296   gpointer   value;
 297 };
 298 
 299 
 300 /* --- variables --- */
 301 static const GScannerConfig g_scanner_config_template =
 302 {
 303   (
 304    &quot; \t\r\n&quot;
 305    )      /* cset_skip_characters */,
 306   (
 307    G_CSET_a_2_z
 308    &quot;_&quot;
 309    G_CSET_A_2_Z
 310    )      /* cset_identifier_first */,
 311   (
 312    G_CSET_a_2_z
 313    &quot;_&quot;
 314    G_CSET_A_2_Z
 315    G_CSET_DIGITS
 316    G_CSET_LATINS
 317    G_CSET_LATINC
 318    )      /* cset_identifier_nth */,
 319   ( &quot;#\n&quot; )   /* cpair_comment_single */,
 320 
 321   FALSE     /* case_sensitive */,
 322 
 323   TRUE      /* skip_comment_multi */,
 324   TRUE      /* skip_comment_single */,
 325   TRUE      /* scan_comment_multi */,
 326   TRUE      /* scan_identifier */,
 327   FALSE     /* scan_identifier_1char */,
 328   FALSE     /* scan_identifier_NULL */,
 329   TRUE      /* scan_symbols */,
 330   FALSE     /* scan_binary */,
 331   TRUE      /* scan_octal */,
 332   TRUE      /* scan_float */,
 333   TRUE      /* scan_hex */,
 334   FALSE     /* scan_hex_dollar */,
 335   TRUE      /* scan_string_sq */,
 336   TRUE      /* scan_string_dq */,
 337   TRUE      /* numbers_2_int */,
 338   FALSE     /* int_2_float */,
 339   FALSE     /* identifier_2_string */,
 340   TRUE      /* char_2_token */,
 341   FALSE     /* symbol_2_token */,
 342   FALSE     /* scope_0_fallback */,
 343   FALSE     /* store_int64 */,
 344   0         /* padding_dummy */
 345 };
 346 
 347 
 348 /* --- prototypes --- */
 349 static inline
 350 GScannerKey*  g_scanner_lookup_internal (GScanner *scanner,
 351              guint   scope_id,
 352              const gchar  *symbol);
 353 static gboolean g_scanner_key_equal   (gconstpointer v1,
 354              gconstpointer v2);
 355 static guint  g_scanner_key_hash    (gconstpointer v);
 356 static void g_scanner_get_token_ll    (GScanner *scanner,
 357              GTokenType *token_p,
 358              GTokenValue  *value_p,
 359              guint  *line_p,
 360              guint  *position_p);
 361 static void g_scanner_get_token_i   (GScanner *scanner,
 362              GTokenType *token_p,
 363              GTokenValue  *value_p,
 364              guint  *line_p,
 365              guint  *position_p);
 366 
 367 static guchar g_scanner_peek_next_char  (GScanner *scanner);
 368 static guchar g_scanner_get_char    (GScanner *scanner,
 369              guint  *line_p,
 370              guint  *position_p);
 371 static void g_scanner_msg_handler   (GScanner *scanner,
 372              gchar  *message,
 373              gboolean  is_error);
 374 
 375 
 376 /* --- functions --- */
 377 static inline gint
 378 g_scanner_char_2_num (guchar  c,
 379           guchar  base)
 380 {
 381   if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;)
 382     c -= &#39;0&#39;;
 383   else if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;)
 384     c -= &#39;A&#39; - 10;
 385   else if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;)
 386     c -= &#39;a&#39; - 10;
 387   else
 388     return -1;
 389 
 390   if (c &lt; base)
 391     return c;
 392 
 393   return -1;
 394 }
 395 
 396 /**
 397  * g_scanner_new:
 398  * @config_templ: the initial scanner settings
 399  *
 400  * Creates a new #GScanner.
 401  *
 402  * The @config_templ structure specifies the initial settings
 403  * of the scanner, which are copied into the #GScanner
 404  * @config field. If you pass %NULL then the default settings
 405  * are used.
 406  *
 407  * Returns: the new #GScanner
 408  */
 409 GScanner *
 410 g_scanner_new (const GScannerConfig *config_templ)
 411 {
 412   GScanner *scanner;
 413 
 414   if (!config_templ)
 415     config_templ = &amp;g_scanner_config_template;
 416 
 417   scanner = g_new0 (GScanner, 1);
 418 
 419   scanner-&gt;user_data = NULL;
 420   scanner-&gt;max_parse_errors = 1;
 421   scanner-&gt;parse_errors = 0;
 422   scanner-&gt;input_name = NULL;
 423   g_datalist_init (&amp;scanner-&gt;qdata);
 424 
 425   scanner-&gt;config = g_new0 (GScannerConfig, 1);
 426 
 427   scanner-&gt;config-&gt;case_sensitive  = config_templ-&gt;case_sensitive;
 428   scanner-&gt;config-&gt;cset_skip_characters  = config_templ-&gt;cset_skip_characters;
 429   if (!scanner-&gt;config-&gt;cset_skip_characters)
 430     scanner-&gt;config-&gt;cset_skip_characters = &quot;&quot;;
 431   scanner-&gt;config-&gt;cset_identifier_first = config_templ-&gt;cset_identifier_first;
 432   scanner-&gt;config-&gt;cset_identifier_nth   = config_templ-&gt;cset_identifier_nth;
 433   scanner-&gt;config-&gt;cpair_comment_single  = config_templ-&gt;cpair_comment_single;
 434   scanner-&gt;config-&gt;skip_comment_multi  = config_templ-&gt;skip_comment_multi;
 435   scanner-&gt;config-&gt;skip_comment_single   = config_templ-&gt;skip_comment_single;
 436   scanner-&gt;config-&gt;scan_comment_multi  = config_templ-&gt;scan_comment_multi;
 437   scanner-&gt;config-&gt;scan_identifier   = config_templ-&gt;scan_identifier;
 438   scanner-&gt;config-&gt;scan_identifier_1char = config_templ-&gt;scan_identifier_1char;
 439   scanner-&gt;config-&gt;scan_identifier_NULL  = config_templ-&gt;scan_identifier_NULL;
 440   scanner-&gt;config-&gt;scan_symbols    = config_templ-&gt;scan_symbols;
 441   scanner-&gt;config-&gt;scan_binary     = config_templ-&gt;scan_binary;
 442   scanner-&gt;config-&gt;scan_octal    = config_templ-&gt;scan_octal;
 443   scanner-&gt;config-&gt;scan_float    = config_templ-&gt;scan_float;
 444   scanner-&gt;config-&gt;scan_hex    = config_templ-&gt;scan_hex;
 445   scanner-&gt;config-&gt;scan_hex_dollar   = config_templ-&gt;scan_hex_dollar;
 446   scanner-&gt;config-&gt;scan_string_sq  = config_templ-&gt;scan_string_sq;
 447   scanner-&gt;config-&gt;scan_string_dq  = config_templ-&gt;scan_string_dq;
 448   scanner-&gt;config-&gt;numbers_2_int   = config_templ-&gt;numbers_2_int;
 449   scanner-&gt;config-&gt;int_2_float     = config_templ-&gt;int_2_float;
 450   scanner-&gt;config-&gt;identifier_2_string   = config_templ-&gt;identifier_2_string;
 451   scanner-&gt;config-&gt;char_2_token    = config_templ-&gt;char_2_token;
 452   scanner-&gt;config-&gt;symbol_2_token  = config_templ-&gt;symbol_2_token;
 453   scanner-&gt;config-&gt;scope_0_fallback  = config_templ-&gt;scope_0_fallback;
 454   scanner-&gt;config-&gt;store_int64     = config_templ-&gt;store_int64;
 455 
 456   scanner-&gt;token = G_TOKEN_NONE;
 457   scanner-&gt;value.v_int64 = 0;
 458   scanner-&gt;line = 1;
 459   scanner-&gt;position = 0;
 460 
 461   scanner-&gt;next_token = G_TOKEN_NONE;
 462   scanner-&gt;next_value.v_int64 = 0;
 463   scanner-&gt;next_line = 1;
 464   scanner-&gt;next_position = 0;
 465 
 466   scanner-&gt;symbol_table = g_hash_table_new (g_scanner_key_hash, g_scanner_key_equal);
 467   scanner-&gt;input_fd = -1;
 468   scanner-&gt;text = NULL;
 469   scanner-&gt;text_end = NULL;
 470   scanner-&gt;buffer = NULL;
 471   scanner-&gt;scope_id = 0;
 472 
 473   scanner-&gt;msg_handler = g_scanner_msg_handler;
 474 
 475   return scanner;
 476 }
 477 
 478 static inline void
 479 g_scanner_free_value (GTokenType     *token_p,
 480           GTokenValue     *value_p)
 481 {
 482   switch (*token_p)
 483     {
 484     case G_TOKEN_STRING:
 485     case G_TOKEN_IDENTIFIER:
 486     case G_TOKEN_IDENTIFIER_NULL:
 487     case G_TOKEN_COMMENT_SINGLE:
 488     case G_TOKEN_COMMENT_MULTI:
 489       g_free (value_p-&gt;v_string);
 490       break;
 491 
 492     default:
 493       break;
 494     }
 495 
 496   *token_p = G_TOKEN_NONE;
 497 }
 498 
 499 static void
 500 g_scanner_destroy_symbol_table_entry (gpointer _key,
 501               gpointer _value,
 502               gpointer _data)
 503 {
 504   GScannerKey *key = _key;
 505 
 506   g_free (key-&gt;symbol);
 507   g_free (key);
 508 }
 509 
 510 /**
 511  * g_scanner_destroy:
 512  * @scanner: a #GScanner
 513  *
 514  * Frees all memory used by the #GScanner.
 515  */
 516 void
 517 g_scanner_destroy (GScanner *scanner)
 518 {
 519   g_return_if_fail (scanner != NULL);
 520 
 521   g_datalist_clear (&amp;scanner-&gt;qdata);
 522   g_hash_table_foreach (scanner-&gt;symbol_table,
 523       g_scanner_destroy_symbol_table_entry, NULL);
 524   g_hash_table_destroy (scanner-&gt;symbol_table);
 525   g_scanner_free_value (&amp;scanner-&gt;token, &amp;scanner-&gt;value);
 526   g_scanner_free_value (&amp;scanner-&gt;next_token, &amp;scanner-&gt;next_value);
 527   g_free (scanner-&gt;config);
 528   g_free (scanner-&gt;buffer);
 529   g_free (scanner);
 530 }
 531 
 532 static void
 533 g_scanner_msg_handler (GScanner   *scanner,
 534            gchar    *message,
 535            gboolean   is_error)
 536 {
 537   g_return_if_fail (scanner != NULL);
 538 
 539   _g_fprintf (stderr, &quot;%s:%d: &quot;,
 540         scanner-&gt;input_name ? scanner-&gt;input_name : &quot;&lt;memory&gt;&quot;,
 541         scanner-&gt;line);
 542   if (is_error)
 543     _g_fprintf (stderr, &quot;error: &quot;);
 544   _g_fprintf (stderr, &quot;%s\n&quot;, message);
 545 }
 546 
 547 /**
 548  * g_scanner_error:
 549  * @scanner: a #GScanner
 550  * @format: the message format. See the printf() documentation
 551  * @...: the parameters to insert into the format string
 552  *
 553  * Outputs an error message, via the #GScanner message handler.
 554  */
 555 void
 556 g_scanner_error (GScanner *scanner,
 557      const gchar  *format,
 558      ...)
 559 {
 560   g_return_if_fail (scanner != NULL);
 561   g_return_if_fail (format != NULL);
 562 
 563   scanner-&gt;parse_errors++;
 564 
 565   if (scanner-&gt;msg_handler)
 566     {
 567       va_list args;
 568       gchar *string;
 569 
 570       va_start (args, format);
 571       string = g_strdup_vprintf (format, args);
 572       va_end (args);
 573 
 574       scanner-&gt;msg_handler (scanner, string, TRUE);
 575 
 576       g_free (string);
 577     }
 578 }
 579 
 580 /**
 581  * g_scanner_warn:
 582  * @scanner: a #GScanner
 583  * @format: the message format. See the printf() documentation
 584  * @...: the parameters to insert into the format string
 585  *
 586  * Outputs a warning message, via the #GScanner message handler.
 587  */
 588 void
 589 g_scanner_warn (GScanner       *scanner,
 590     const gchar    *format,
 591     ...)
 592 {
 593   g_return_if_fail (scanner != NULL);
 594   g_return_if_fail (format != NULL);
 595 
 596   if (scanner-&gt;msg_handler)
 597     {
 598       va_list args;
 599       gchar *string;
 600 
 601       va_start (args, format);
 602       string = g_strdup_vprintf (format, args);
 603       va_end (args);
 604 
 605       scanner-&gt;msg_handler (scanner, string, FALSE);
 606 
 607       g_free (string);
 608     }
 609 }
 610 
 611 static gboolean
 612 g_scanner_key_equal (gconstpointer v1,
 613          gconstpointer v2)
 614 {
 615   const GScannerKey *key1 = v1;
 616   const GScannerKey *key2 = v2;
 617 
 618   return (key1-&gt;scope_id == key2-&gt;scope_id) &amp;&amp; (strcmp (key1-&gt;symbol, key2-&gt;symbol) == 0);
 619 }
 620 
 621 static guint
 622 g_scanner_key_hash (gconstpointer v)
 623 {
 624   const GScannerKey *key = v;
 625   gchar *c;
 626   guint h;
 627 
 628   h = key-&gt;scope_id;
 629   for (c = key-&gt;symbol; *c; c++)
 630     h = (h &lt;&lt; 5) - h + *c;
 631 
 632   return h;
 633 }
 634 
 635 static inline GScannerKey*
 636 g_scanner_lookup_internal (GScanner *scanner,
 637          guint   scope_id,
 638          const gchar  *symbol)
 639 {
 640   GScannerKey *key_p;
 641   GScannerKey key;
 642 
 643   key.scope_id = scope_id;
 644 
 645   if (!scanner-&gt;config-&gt;case_sensitive)
 646     {
 647       gchar *d;
 648       const gchar *c;
 649 
 650       key.symbol = g_new (gchar, strlen (symbol) + 1);
 651       for (d = key.symbol, c = symbol; *c; c++, d++)
 652   *d = to_lower (*c);
 653       *d = 0;
 654       key_p = g_hash_table_lookup (scanner-&gt;symbol_table, &amp;key);
 655       g_free (key.symbol);
 656     }
 657   else
 658     {
 659       key.symbol = (gchar*) symbol;
 660       key_p = g_hash_table_lookup (scanner-&gt;symbol_table, &amp;key);
 661     }
 662 
 663   return key_p;
 664 }
 665 
 666 /**
 667  * g_scanner_add_symbol:
 668  * @scanner: a #GScanner
 669  * @symbol: the symbol to add
 670  * @value: the value of the symbol
 671  *
 672  * Adds a symbol to the default scope.
 673  *
 674  * Deprecated: 2.2: Use g_scanner_scope_add_symbol() instead.
 675  */
 676 
 677 /**
 678  * g_scanner_scope_add_symbol:
 679  * @scanner: a #GScanner
 680  * @scope_id: the scope id
 681  * @symbol: the symbol to add
 682  * @value: the value of the symbol
 683  *
 684  * Adds a symbol to the given scope.
 685  */
 686 void
 687 g_scanner_scope_add_symbol (GScanner  *scanner,
 688           guint  scope_id,
 689           const gchar *symbol,
 690           gpointer   value)
 691 {
 692   GScannerKey *key;
 693 
 694   g_return_if_fail (scanner != NULL);
 695   g_return_if_fail (symbol != NULL);
 696 
 697   key = g_scanner_lookup_internal (scanner, scope_id, symbol);
 698 
 699   if (!key)
 700     {
 701       key = g_new (GScannerKey, 1);
 702       key-&gt;scope_id = scope_id;
 703       key-&gt;symbol = g_strdup (symbol);
 704       key-&gt;value = value;
 705       if (!scanner-&gt;config-&gt;case_sensitive)
 706   {
 707     gchar *c;
 708 
 709     c = key-&gt;symbol;
 710     while (*c != 0)
 711       {
 712         *c = to_lower (*c);
 713         c++;
 714       }
 715   }
 716       g_hash_table_add (scanner-&gt;symbol_table, key);
 717     }
 718   else
 719     key-&gt;value = value;
 720 }
 721 
 722 /**
 723  * g_scanner_remove_symbol:
 724  * @scanner: a #GScanner
 725  * @symbol: the symbol to remove
 726  *
 727  * Removes a symbol from the default scope.
 728  *
 729  * Deprecated: 2.2: Use g_scanner_scope_remove_symbol() instead.
 730  */
 731 
 732 /**
 733  * g_scanner_scope_remove_symbol:
 734  * @scanner: a #GScanner
 735  * @scope_id: the scope id
 736  * @symbol: the symbol to remove
 737  *
 738  * Removes a symbol from a scope.
 739  */
 740 void
 741 g_scanner_scope_remove_symbol (GScanner    *scanner,
 742              guint      scope_id,
 743              const gchar *symbol)
 744 {
 745   GScannerKey *key;
 746 
 747   g_return_if_fail (scanner != NULL);
 748   g_return_if_fail (symbol != NULL);
 749 
 750   key = g_scanner_lookup_internal (scanner, scope_id, symbol);
 751 
 752   if (key)
 753     {
 754       g_hash_table_remove (scanner-&gt;symbol_table, key);
 755       g_free (key-&gt;symbol);
 756       g_free (key);
 757     }
 758 }
 759 
 760 /**
 761  * g_scanner_freeze_symbol_table:
 762  * @scanner: a #GScanner
 763  *
 764  * There is no reason to use this macro, since it does nothing.
 765  *
 766  * Deprecated: 2.2: This macro does nothing.
 767  */
 768 
 769 /**
 770  * g_scanner_thaw_symbol_table:
 771  * @scanner: a #GScanner
 772  *
 773  * There is no reason to use this macro, since it does nothing.
 774  *
 775  * Deprecated: 2.2: This macro does nothing.
 776  */
 777 
 778 /**
 779  * g_scanner_lookup_symbol:
 780  * @scanner: a #GScanner
 781  * @symbol: the symbol to look up
 782  *
 783  * Looks up a symbol in the current scope and return its value.
 784  * If the symbol is not bound in the current scope, %NULL is
 785  * returned.
 786  *
 787  * Returns: the value of @symbol in the current scope, or %NULL
 788  *     if @symbol is not bound in the current scope
 789  */
 790 gpointer
 791 g_scanner_lookup_symbol (GScanner *scanner,
 792        const gchar  *symbol)
 793 {
 794   GScannerKey *key;
 795   guint scope_id;
 796 
 797   g_return_val_if_fail (scanner != NULL, NULL);
 798 
 799   if (!symbol)
 800     return NULL;
 801 
 802   scope_id = scanner-&gt;scope_id;
 803   key = g_scanner_lookup_internal (scanner, scope_id, symbol);
 804   if (!key &amp;&amp; scope_id &amp;&amp; scanner-&gt;config-&gt;scope_0_fallback)
 805     key = g_scanner_lookup_internal (scanner, 0, symbol);
 806 
 807   if (key)
 808     return key-&gt;value;
 809   else
 810     return NULL;
 811 }
 812 
 813 /**
 814  * g_scanner_scope_lookup_symbol:
 815  * @scanner: a #GScanner
 816  * @scope_id: the scope id
 817  * @symbol: the symbol to look up
 818  *
 819  * Looks up a symbol in a scope and return its value. If the
 820  * symbol is not bound in the scope, %NULL is returned.
 821  *
 822  * Returns: the value of @symbol in the given scope, or %NULL
 823  *     if @symbol is not bound in the given scope.
 824  *
 825  */
 826 gpointer
 827 g_scanner_scope_lookup_symbol (GScanner       *scanner,
 828              guint         scope_id,
 829              const gchar    *symbol)
 830 {
 831   GScannerKey *key;
 832 
 833   g_return_val_if_fail (scanner != NULL, NULL);
 834 
 835   if (!symbol)
 836     return NULL;
 837 
 838   key = g_scanner_lookup_internal (scanner, scope_id, symbol);
 839 
 840   if (key)
 841     return key-&gt;value;
 842   else
 843     return NULL;
 844 }
 845 
 846 /**
 847  * g_scanner_set_scope:
 848  * @scanner: a #GScanner
 849  * @scope_id: the new scope id
 850  *
 851  * Sets the current scope.
 852  *
 853  * Returns: the old scope id
 854  */
 855 guint
 856 g_scanner_set_scope (GScanner     *scanner,
 857          guint       scope_id)
 858 {
 859   guint old_scope_id;
 860 
 861   g_return_val_if_fail (scanner != NULL, 0);
 862 
 863   old_scope_id = scanner-&gt;scope_id;
 864   scanner-&gt;scope_id = scope_id;
 865 
 866   return old_scope_id;
 867 }
 868 
 869 static void
 870 g_scanner_foreach_internal (gpointer  _key,
 871           gpointer  _value,
 872           gpointer  _user_data)
 873 {
 874   GScannerKey *key;
 875   gpointer *d;
 876   GHFunc func;
 877   gpointer user_data;
 878   guint *scope_id;
 879 
 880   d = _user_data;
 881   func = (GHFunc) d[0];
 882   user_data = d[1];
 883   scope_id = d[2];
 884   key = _value;
 885 
 886   if (key-&gt;scope_id == *scope_id)
 887     func (key-&gt;symbol, key-&gt;value, user_data);
 888 }
 889 
 890 /**
 891  * g_scanner_foreach_symbol:
 892  * @scanner: a #GScanner
 893  * @func: the function to call with each symbol
 894  * @data: data to pass to the function
 895  *
 896  * Calls a function for each symbol in the default scope.
 897  *
 898  * Deprecated: 2.2: Use g_scanner_scope_foreach_symbol() instead.
 899  */
 900 
 901 /**
 902  * g_scanner_scope_foreach_symbol:
 903  * @scanner: a #GScanner
 904  * @scope_id: the scope id
 905  * @func: the function to call for each symbol/value pair
 906  * @user_data: user data to pass to the function
 907  *
 908  * Calls the given function for each of the symbol/value pairs
 909  * in the given scope of the #GScanner. The function is passed
 910  * the symbol and value of each pair, and the given @user_data
 911  * parameter.
 912  */
 913 void
 914 g_scanner_scope_foreach_symbol (GScanner       *scanner,
 915         guint   scope_id,
 916         GHFunc    func,
 917         gpointer  user_data)
 918 {
 919   gpointer d[3];
 920 
 921   g_return_if_fail (scanner != NULL);
 922 
 923   d[0] = (gpointer) func;
 924   d[1] = user_data;
 925   d[2] = &amp;scope_id;
 926 
 927   g_hash_table_foreach (scanner-&gt;symbol_table, g_scanner_foreach_internal, d);
 928 }
 929 
 930 /**
 931  * g_scanner_peek_next_token:
 932  * @scanner: a #GScanner
 933  *
 934  * Parses the next token, without removing it from the input stream.
 935  * The token data is placed in the @next_token, @next_value, @next_line,
 936  * and @next_position fields of the #GScanner structure.
 937  *
 938  * Note that, while the token is not removed from the input stream
 939  * (i.e. the next call to g_scanner_get_next_token() will return the
 940  * same token), it will not be reevaluated. This can lead to surprising
 941  * results when changing scope or the scanner configuration after peeking
 942  * the next token. Getting the next token after switching the scope or
 943  * configuration will return whatever was peeked before, regardless of
 944  * any symbols that may have been added or removed in the new scope.
 945  *
 946  * Returns: the type of the token
 947  */
 948 GTokenType
 949 g_scanner_peek_next_token (GScanner *scanner)
 950 {
 951   g_return_val_if_fail (scanner != NULL, G_TOKEN_EOF);
 952 
 953   if (scanner-&gt;next_token == G_TOKEN_NONE)
 954     {
 955       scanner-&gt;next_line = scanner-&gt;line;
 956       scanner-&gt;next_position = scanner-&gt;position;
 957       g_scanner_get_token_i (scanner,
 958            &amp;scanner-&gt;next_token,
 959            &amp;scanner-&gt;next_value,
 960            &amp;scanner-&gt;next_line,
 961            &amp;scanner-&gt;next_position);
 962     }
 963 
 964   return scanner-&gt;next_token;
 965 }
 966 
 967 /**
 968  * g_scanner_get_next_token:
 969  * @scanner: a #GScanner
 970  *
 971  * Parses the next token just like g_scanner_peek_next_token()
 972  * and also removes it from the input stream. The token data is
 973  * placed in the @token, @value, @line, and @position fields of
 974  * the #GScanner structure.
 975  *
 976  * Returns: the type of the token
 977  */
 978 GTokenType
 979 g_scanner_get_next_token (GScanner  *scanner)
 980 {
 981   g_return_val_if_fail (scanner != NULL, G_TOKEN_EOF);
 982 
 983   if (scanner-&gt;next_token != G_TOKEN_NONE)
 984     {
 985       g_scanner_free_value (&amp;scanner-&gt;token, &amp;scanner-&gt;value);
 986 
 987       scanner-&gt;token = scanner-&gt;next_token;
 988       scanner-&gt;value = scanner-&gt;next_value;
 989       scanner-&gt;line = scanner-&gt;next_line;
 990       scanner-&gt;position = scanner-&gt;next_position;
 991       scanner-&gt;next_token = G_TOKEN_NONE;
 992     }
 993   else
 994     g_scanner_get_token_i (scanner,
 995          &amp;scanner-&gt;token,
 996          &amp;scanner-&gt;value,
 997          &amp;scanner-&gt;line,
 998          &amp;scanner-&gt;position);
 999 
1000   return scanner-&gt;token;
1001 }
1002 
1003 /**
1004  * g_scanner_cur_token:
1005  * @scanner: a #GScanner
1006  *
1007  * Gets the current token type. This is simply the @token
1008  * field in the #GScanner structure.
1009  *
1010  * Returns: the current token type
1011  */
1012 GTokenType
1013 g_scanner_cur_token (GScanner *scanner)
1014 {
1015   g_return_val_if_fail (scanner != NULL, G_TOKEN_EOF);
1016 
1017   return scanner-&gt;token;
1018 }
1019 
1020 /**
1021  * g_scanner_cur_value:
1022  * @scanner: a #GScanner
1023  *
1024  * Gets the current token value. This is simply the @value
1025  * field in the #GScanner structure.
1026  *
1027  * Returns: the current token value
1028  */
1029 GTokenValue
1030 g_scanner_cur_value (GScanner *scanner)
1031 {
1032   GTokenValue v;
1033 
1034   v.v_int64 = 0;
1035 
1036   g_return_val_if_fail (scanner != NULL, v);
1037 
1038   /* MSC isn&#39;t capable of handling return scanner-&gt;value; ? */
1039 
1040   v = scanner-&gt;value;
1041 
1042   return v;
1043 }
1044 
1045 /**
1046  * g_scanner_cur_line:
1047  * @scanner: a #GScanner
1048  *
1049  * Returns the current line in the input stream (counting
1050  * from 1). This is the line of the last token parsed via
1051  * g_scanner_get_next_token().
1052  *
1053  * Returns: the current line
1054  */
1055 guint
1056 g_scanner_cur_line (GScanner *scanner)
1057 {
1058   g_return_val_if_fail (scanner != NULL, 0);
1059 
1060   return scanner-&gt;line;
1061 }
1062 
1063 /**
1064  * g_scanner_cur_position:
1065  * @scanner: a #GScanner
1066  *
1067  * Returns the current position in the current line (counting
1068  * from 0). This is the position of the last token parsed via
1069  * g_scanner_get_next_token().
1070  *
1071  * Returns: the current position on the line
1072  */
1073 guint
1074 g_scanner_cur_position (GScanner *scanner)
1075 {
1076   g_return_val_if_fail (scanner != NULL, 0);
1077 
1078   return scanner-&gt;position;
1079 }
1080 
1081 /**
1082  * g_scanner_eof:
1083  * @scanner: a #GScanner
1084  *
1085  * Returns %TRUE if the scanner has reached the end of
1086  * the file or text buffer.
1087  *
1088  * Returns: %TRUE if the scanner has reached the end of
1089  *     the file or text buffer
1090  */
1091 gboolean
1092 g_scanner_eof (GScanner *scanner)
1093 {
1094   g_return_val_if_fail (scanner != NULL, TRUE);
1095 
1096   return scanner-&gt;token == G_TOKEN_EOF || scanner-&gt;token == G_TOKEN_ERROR;
1097 }
1098 
1099 /**
1100  * g_scanner_input_file:
1101  * @scanner: a #GScanner
1102  * @input_fd: a file descriptor
1103  *
1104  * Prepares to scan a file.
1105  */
1106 void
1107 g_scanner_input_file (GScanner *scanner,
1108           gint  input_fd)
1109 {
1110   g_return_if_fail (scanner != NULL);
1111   g_return_if_fail (input_fd &gt;= 0);
1112 
1113   if (scanner-&gt;input_fd &gt;= 0)
1114     g_scanner_sync_file_offset (scanner);
1115 
1116   scanner-&gt;token = G_TOKEN_NONE;
1117   scanner-&gt;value.v_int64 = 0;
1118   scanner-&gt;line = 1;
1119   scanner-&gt;position = 0;
1120   scanner-&gt;next_token = G_TOKEN_NONE;
1121 
1122   scanner-&gt;input_fd = input_fd;
1123   scanner-&gt;text = NULL;
1124   scanner-&gt;text_end = NULL;
1125 
1126   if (!scanner-&gt;buffer)
1127     scanner-&gt;buffer = g_new (gchar, READ_BUFFER_SIZE + 1);
1128 }
1129 
1130 /**
1131  * g_scanner_input_text:
1132  * @scanner: a #GScanner
1133  * @text: the text buffer to scan
1134  * @text_len: the length of the text buffer
1135  *
1136  * Prepares to scan a text buffer.
1137  */
1138 void
1139 g_scanner_input_text (GScanner    *scanner,
1140           const gchar *text,
1141           guint    text_len)
1142 {
1143   g_return_if_fail (scanner != NULL);
1144   if (text_len)
1145     g_return_if_fail (text != NULL);
1146   else
1147     text = NULL;
1148 
1149   if (scanner-&gt;input_fd &gt;= 0)
1150     g_scanner_sync_file_offset (scanner);
1151 
1152   scanner-&gt;token = G_TOKEN_NONE;
1153   scanner-&gt;value.v_int64 = 0;
1154   scanner-&gt;line = 1;
1155   scanner-&gt;position = 0;
1156   scanner-&gt;next_token = G_TOKEN_NONE;
1157 
1158   scanner-&gt;input_fd = -1;
1159   scanner-&gt;text = text;
1160   scanner-&gt;text_end = text + text_len;
1161 
1162   if (scanner-&gt;buffer)
1163     {
1164       g_free (scanner-&gt;buffer);
1165       scanner-&gt;buffer = NULL;
1166     }
1167 }
1168 
1169 static guchar
1170 g_scanner_peek_next_char (GScanner *scanner)
1171 {
1172   if (scanner-&gt;text &lt; scanner-&gt;text_end)
1173     {
1174       return *scanner-&gt;text;
1175     }
1176   else if (scanner-&gt;input_fd &gt;= 0)
1177     {
1178       gint count;
1179       gchar *buffer;
1180 
1181       buffer = scanner-&gt;buffer;
1182       do
1183   {
1184     count = read (scanner-&gt;input_fd, buffer, READ_BUFFER_SIZE);
1185   }
1186       while (count == -1 &amp;&amp; (errno == EINTR || errno == EAGAIN));
1187 
1188       if (count &lt; 1)
1189   {
1190     scanner-&gt;input_fd = -1;
1191 
1192     return 0;
1193   }
1194       else
1195   {
1196     scanner-&gt;text = buffer;
1197     scanner-&gt;text_end = buffer + count;
1198 
1199     return *buffer;
1200   }
1201     }
1202   else
1203     return 0;
1204 }
1205 
1206 /**
1207  * g_scanner_sync_file_offset:
1208  * @scanner: a #GScanner
1209  *
1210  * Rewinds the filedescriptor to the current buffer position
1211  * and blows the file read ahead buffer. This is useful for
1212  * third party uses of the scanners filedescriptor, which hooks
1213  * onto the current scanning position.
1214  */
1215 void
1216 g_scanner_sync_file_offset (GScanner *scanner)
1217 {
1218   g_return_if_fail (scanner != NULL);
1219 
1220   /* for file input, rewind the filedescriptor to the current
1221    * buffer position and blow the file read ahead buffer. useful
1222    * for third party uses of our file descriptor, which hooks
1223    * onto the current scanning position.
1224    */
1225 
1226   if (scanner-&gt;input_fd &gt;= 0 &amp;&amp; scanner-&gt;text_end &gt; scanner-&gt;text)
1227     {
1228       gint buffered;
1229 
1230       buffered = scanner-&gt;text_end - scanner-&gt;text;
1231       if (lseek (scanner-&gt;input_fd, - buffered, SEEK_CUR) &gt;= 0)
1232   {
1233     /* we succeeded, blow our buffer&#39;s contents now */
1234     scanner-&gt;text = NULL;
1235     scanner-&gt;text_end = NULL;
1236   }
1237       else
1238   errno = 0;
1239     }
1240 }
1241 
1242 static guchar
1243 g_scanner_get_char (GScanner  *scanner,
1244         guint *line_p,
1245         guint *position_p)
1246 {
1247   guchar fchar;
1248 
1249   if (scanner-&gt;text &lt; scanner-&gt;text_end)
1250     fchar = *(scanner-&gt;text++);
1251   else if (scanner-&gt;input_fd &gt;= 0)
1252     {
1253       gint count;
1254       gchar *buffer;
1255 
1256       buffer = scanner-&gt;buffer;
1257       do
1258   {
1259     count = read (scanner-&gt;input_fd, buffer, READ_BUFFER_SIZE);
1260   }
1261       while (count == -1 &amp;&amp; (errno == EINTR || errno == EAGAIN));
1262 
1263       if (count &lt; 1)
1264   {
1265     scanner-&gt;input_fd = -1;
1266     fchar = 0;
1267   }
1268       else
1269   {
1270     scanner-&gt;text = buffer + 1;
1271     scanner-&gt;text_end = buffer + count;
1272     fchar = *buffer;
1273     if (!fchar)
1274       {
1275         g_scanner_sync_file_offset (scanner);
1276         scanner-&gt;text_end = scanner-&gt;text;
1277         scanner-&gt;input_fd = -1;
1278       }
1279   }
1280     }
1281   else
1282     fchar = 0;
1283 
1284   if (fchar == &#39;\n&#39;)
1285     {
1286       (*position_p) = 0;
1287       (*line_p)++;
1288     }
1289   else if (fchar)
1290     {
1291       (*position_p)++;
1292     }
1293 
1294   return fchar;
1295 }
1296 
1297 /**
1298  * g_scanner_unexp_token:
1299  * @scanner: a #GScanner
1300  * @expected_token: the expected token
1301  * @identifier_spec: a string describing how the scanner&#39;s user
1302  *     refers to identifiers (%NULL defaults to &quot;identifier&quot;).
1303  *     This is used if @expected_token is %G_TOKEN_IDENTIFIER or
1304  *     %G_TOKEN_IDENTIFIER_NULL.
1305  * @symbol_spec: a string describing how the scanner&#39;s user refers
1306  *     to symbols (%NULL defaults to &quot;symbol&quot;). This is used if
1307  *     @expected_token is %G_TOKEN_SYMBOL or any token value greater
1308  *     than %G_TOKEN_LAST.
1309  * @symbol_name: the name of the symbol, if the scanner&#39;s current
1310  *     token is a symbol.
1311  * @message: a message string to output at the end of the
1312  *     warning/error, or %NULL.
1313  * @is_error: if %TRUE it is output as an error. If %FALSE it is
1314  *     output as a warning.
1315  *
1316  * Outputs a message through the scanner&#39;s msg_handler,
1317  * resulting from an unexpected token in the input stream.
1318  * Note that you should not call g_scanner_peek_next_token()
1319  * followed by g_scanner_unexp_token() without an intermediate
1320  * call to g_scanner_get_next_token(), as g_scanner_unexp_token()
1321  * evaluates the scanner&#39;s current token (not the peeked token)
1322  * to construct part of the message.
1323  */
1324 void
1325 g_scanner_unexp_token (GScanner   *scanner,
1326            GTokenType  expected_token,
1327            const gchar  *identifier_spec,
1328            const gchar  *symbol_spec,
1329            const gchar  *symbol_name,
1330            const gchar  *message,
1331            gint    is_error)
1332 {
1333   gchar *token_string;
1334   guint token_string_len;
1335   gchar *expected_string;
1336   guint expected_string_len;
1337   gchar *message_prefix;
1338   gboolean print_unexp;
1339   void (*msg_handler) (GScanner*, const gchar*, ...);
1340 
1341   g_return_if_fail (scanner != NULL);
1342 
1343   if (is_error)
1344     msg_handler = g_scanner_error;
1345   else
1346     msg_handler = g_scanner_warn;
1347 
1348   if (!identifier_spec)
1349     identifier_spec = &quot;identifier&quot;;
1350   if (!symbol_spec)
1351     symbol_spec = &quot;symbol&quot;;
1352 
1353   token_string_len = 56;
1354   token_string = g_new (gchar, token_string_len + 1);
1355   expected_string_len = 64;
1356   expected_string = g_new (gchar, expected_string_len + 1);
1357   print_unexp = TRUE;
1358 
1359   switch (scanner-&gt;token)
1360     {
1361     case G_TOKEN_EOF:
1362       _g_snprintf (token_string, token_string_len, &quot;end of file&quot;);
1363       break;
1364 
1365     default:
1366       if (scanner-&gt;token &gt;= 1 &amp;&amp; scanner-&gt;token &lt;= 255)
1367   {
1368     if ((scanner-&gt;token &gt;= &#39; &#39; &amp;&amp; scanner-&gt;token &lt;= &#39;~&#39;) ||
1369         strchr (scanner-&gt;config-&gt;cset_identifier_first, scanner-&gt;token) ||
1370         strchr (scanner-&gt;config-&gt;cset_identifier_nth, scanner-&gt;token))
1371       _g_snprintf (token_string, token_string_len, &quot;character &#39;%c&#39;&quot;, scanner-&gt;token);
1372     else
1373       _g_snprintf (token_string, token_string_len, &quot;character &#39;\\%o&#39;&quot;, scanner-&gt;token);
1374     break;
1375   }
1376       else if (!scanner-&gt;config-&gt;symbol_2_token)
1377   {
1378     _g_snprintf (token_string, token_string_len, &quot;(unknown) token &lt;%d&gt;&quot;, scanner-&gt;token);
1379     break;
1380   }
1381       /* fall through */
1382     case G_TOKEN_SYMBOL:
1383       if (expected_token == G_TOKEN_SYMBOL ||
1384     (scanner-&gt;config-&gt;symbol_2_token &amp;&amp;
1385      expected_token &gt; G_TOKEN_LAST))
1386   print_unexp = FALSE;
1387       if (symbol_name)
1388   _g_snprintf (token_string,
1389          token_string_len,
1390          &quot;%s%s &#39;%s&#39;&quot;,
1391          print_unexp ? &quot;&quot; : &quot;invalid &quot;,
1392          symbol_spec,
1393          symbol_name);
1394       else
1395   _g_snprintf (token_string,
1396          token_string_len,
1397          &quot;%s%s&quot;,
1398          print_unexp ? &quot;&quot; : &quot;invalid &quot;,
1399          symbol_spec);
1400       break;
1401 
1402     case G_TOKEN_ERROR:
1403       print_unexp = FALSE;
1404       expected_token = G_TOKEN_NONE;
1405       switch (scanner-&gt;value.v_error)
1406   {
1407   case G_ERR_UNEXP_EOF:
1408     _g_snprintf (token_string, token_string_len, &quot;scanner: unexpected end of file&quot;);
1409     break;
1410 
1411   case G_ERR_UNEXP_EOF_IN_STRING:
1412     _g_snprintf (token_string, token_string_len, &quot;scanner: unterminated string constant&quot;);
1413     break;
1414 
1415   case G_ERR_UNEXP_EOF_IN_COMMENT:
1416     _g_snprintf (token_string, token_string_len, &quot;scanner: unterminated comment&quot;);
1417     break;
1418 
1419   case G_ERR_NON_DIGIT_IN_CONST:
1420     _g_snprintf (token_string, token_string_len, &quot;scanner: non digit in constant&quot;);
1421     break;
1422 
1423   case G_ERR_FLOAT_RADIX:
1424     _g_snprintf (token_string, token_string_len, &quot;scanner: invalid radix for floating constant&quot;);
1425     break;
1426 
1427   case G_ERR_FLOAT_MALFORMED:
1428     _g_snprintf (token_string, token_string_len, &quot;scanner: malformed floating constant&quot;);
1429     break;
1430 
1431   case G_ERR_DIGIT_RADIX:
1432     _g_snprintf (token_string, token_string_len, &quot;scanner: digit is beyond radix&quot;);
1433     break;
1434 
1435   case G_ERR_UNKNOWN:
1436   default:
1437     _g_snprintf (token_string, token_string_len, &quot;scanner: unknown error&quot;);
1438     break;
1439   }
1440       break;
1441 
1442     case G_TOKEN_CHAR:
1443       _g_snprintf (token_string, token_string_len, &quot;character &#39;%c&#39;&quot;, scanner-&gt;value.v_char);
1444       break;
1445 
1446     case G_TOKEN_IDENTIFIER:
1447     case G_TOKEN_IDENTIFIER_NULL:
1448       if (expected_token == G_TOKEN_IDENTIFIER ||
1449     expected_token == G_TOKEN_IDENTIFIER_NULL)
1450   print_unexp = FALSE;
1451       _g_snprintf (token_string,
1452       token_string_len,
1453       &quot;%s%s &#39;%s&#39;&quot;,
1454       print_unexp ? &quot;&quot; : &quot;invalid &quot;,
1455       identifier_spec,
1456       scanner-&gt;token == G_TOKEN_IDENTIFIER ? scanner-&gt;value.v_string : &quot;null&quot;);
1457       break;
1458 
1459     case G_TOKEN_BINARY:
1460     case G_TOKEN_OCTAL:
1461     case G_TOKEN_INT:
1462     case G_TOKEN_HEX:
1463       if (scanner-&gt;config-&gt;store_int64)
1464   _g_snprintf (token_string, token_string_len, &quot;number &#39;%&quot; G_GUINT64_FORMAT &quot;&#39;&quot;, scanner-&gt;value.v_int64);
1465       else
1466   _g_snprintf (token_string, token_string_len, &quot;number &#39;%lu&#39;&quot;, scanner-&gt;value.v_int);
1467       break;
1468 
1469     case G_TOKEN_FLOAT:
1470       _g_snprintf (token_string, token_string_len, &quot;number &#39;%.3f&#39;&quot;, scanner-&gt;value.v_float);
1471       break;
1472 
1473     case G_TOKEN_STRING:
1474       if (expected_token == G_TOKEN_STRING)
1475   print_unexp = FALSE;
1476       _g_snprintf (token_string,
1477        token_string_len,
1478        &quot;%s%sstring constant \&quot;%s\&quot;&quot;,
1479        print_unexp ? &quot;&quot; : &quot;invalid &quot;,
1480        scanner-&gt;value.v_string[0] == 0 ? &quot;empty &quot; : &quot;&quot;,
1481        scanner-&gt;value.v_string);
1482       token_string[token_string_len - 2] = &#39;&quot;&#39;;
1483       token_string[token_string_len - 1] = 0;
1484       break;
1485 
1486     case G_TOKEN_COMMENT_SINGLE:
1487     case G_TOKEN_COMMENT_MULTI:
1488       _g_snprintf (token_string, token_string_len, &quot;comment&quot;);
1489       break;
1490 
1491     case G_TOKEN_NONE:
1492       /* somehow the user&#39;s parsing code is screwed, there isn&#39;t much
1493        * we can do about it.
1494        * Note, a common case to trigger this is
1495        * g_scanner_peek_next_token(); g_scanner_unexp_token();
1496        * without an intermediate g_scanner_get_next_token().
1497        */
1498       g_assert_not_reached ();
1499       break;
1500     }
1501 
1502 
1503   switch (expected_token)
1504     {
1505       gboolean need_valid;
1506       gchar *tstring;
1507     case G_TOKEN_EOF:
1508       _g_snprintf (expected_string, expected_string_len, &quot;end of file&quot;);
1509       break;
1510     default:
1511       if (expected_token &gt;= 1 &amp;&amp; expected_token &lt;= 255)
1512   {
1513     if ((expected_token &gt;= &#39; &#39; &amp;&amp; expected_token &lt;= &#39;~&#39;) ||
1514         strchr (scanner-&gt;config-&gt;cset_identifier_first, expected_token) ||
1515         strchr (scanner-&gt;config-&gt;cset_identifier_nth, expected_token))
1516       _g_snprintf (expected_string, expected_string_len, &quot;character &#39;%c&#39;&quot;, expected_token);
1517     else
1518       _g_snprintf (expected_string, expected_string_len, &quot;character &#39;\\%o&#39;&quot;, expected_token);
1519     break;
1520   }
1521       else if (!scanner-&gt;config-&gt;symbol_2_token)
1522   {
1523     _g_snprintf (expected_string, expected_string_len, &quot;(unknown) token &lt;%d&gt;&quot;, expected_token);
1524     break;
1525   }
1526       /* fall through */
1527     case G_TOKEN_SYMBOL:
1528       need_valid = (scanner-&gt;token == G_TOKEN_SYMBOL ||
1529         (scanner-&gt;config-&gt;symbol_2_token &amp;&amp;
1530          scanner-&gt;token &gt; G_TOKEN_LAST));
1531       _g_snprintf (expected_string,
1532        expected_string_len,
1533        &quot;%s%s&quot;,
1534        need_valid ? &quot;valid &quot; : &quot;&quot;,
1535        symbol_spec);
1536       /* FIXME: should we attempt to look up the symbol_name for symbol_2_token? */
1537       break;
1538     case G_TOKEN_CHAR:
1539       _g_snprintf (expected_string, expected_string_len, &quot;%scharacter&quot;,
1540        scanner-&gt;token == G_TOKEN_CHAR ? &quot;valid &quot; : &quot;&quot;);
1541       break;
1542     case G_TOKEN_BINARY:
1543       tstring = &quot;binary&quot;;
1544       _g_snprintf (expected_string, expected_string_len, &quot;%snumber (%s)&quot;,
1545        scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);
1546       break;
1547     case G_TOKEN_OCTAL:
1548       tstring = &quot;octal&quot;;
1549       _g_snprintf (expected_string, expected_string_len, &quot;%snumber (%s)&quot;,
1550        scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);
1551       break;
1552     case G_TOKEN_INT:
1553       tstring = &quot;integer&quot;;
1554       _g_snprintf (expected_string, expected_string_len, &quot;%snumber (%s)&quot;,
1555        scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);
1556       break;
1557     case G_TOKEN_HEX:
1558       tstring = &quot;hexadecimal&quot;;
1559       _g_snprintf (expected_string, expected_string_len, &quot;%snumber (%s)&quot;,
1560        scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);
1561       break;
1562     case G_TOKEN_FLOAT:
1563       tstring = &quot;float&quot;;
1564       _g_snprintf (expected_string, expected_string_len, &quot;%snumber (%s)&quot;,
1565        scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);
1566       break;
1567     case G_TOKEN_STRING:
1568       _g_snprintf (expected_string,
1569        expected_string_len,
1570        &quot;%sstring constant&quot;,
1571        scanner-&gt;token == G_TOKEN_STRING ? &quot;valid &quot; : &quot;&quot;);
1572       break;
1573     case G_TOKEN_IDENTIFIER:
1574     case G_TOKEN_IDENTIFIER_NULL:
1575       need_valid = (scanner-&gt;token == G_TOKEN_IDENTIFIER_NULL ||
1576         scanner-&gt;token == G_TOKEN_IDENTIFIER);
1577       _g_snprintf (expected_string,
1578        expected_string_len,
1579        &quot;%s%s&quot;,
1580        need_valid ? &quot;valid &quot; : &quot;&quot;,
1581        identifier_spec);
1582       break;
1583     case G_TOKEN_COMMENT_SINGLE:
1584       tstring = &quot;single-line&quot;;
1585       _g_snprintf (expected_string, expected_string_len, &quot;%scomment (%s)&quot;,
1586        scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);
1587       break;
1588     case G_TOKEN_COMMENT_MULTI:
1589       tstring = &quot;multi-line&quot;;
1590       _g_snprintf (expected_string, expected_string_len, &quot;%scomment (%s)&quot;,
1591        scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);
1592       break;
1593     case G_TOKEN_NONE:
1594     case G_TOKEN_ERROR:
1595       /* this is handled upon printout */
1596       break;
1597     }
1598 
1599   if (message &amp;&amp; message[0] != 0)
1600     message_prefix = &quot; - &quot;;
1601   else
1602     {
1603       message_prefix = &quot;&quot;;
1604       message = &quot;&quot;;
1605     }
1606   if (expected_token == G_TOKEN_ERROR)
1607     {
1608       msg_handler (scanner,
1609        &quot;failure around %s%s%s&quot;,
1610        token_string,
1611        message_prefix,
1612        message);
1613     }
1614   else if (expected_token == G_TOKEN_NONE)
1615     {
1616       if (print_unexp)
1617   msg_handler (scanner,
1618          &quot;unexpected %s%s%s&quot;,
1619          token_string,
1620          message_prefix,
1621          message);
1622       else
1623   msg_handler (scanner,
1624          &quot;%s%s%s&quot;,
1625          token_string,
1626          message_prefix,
1627          message);
1628     }
1629   else
1630     {
1631       if (print_unexp)
1632   msg_handler (scanner,
1633          &quot;unexpected %s, expected %s%s%s&quot;,
1634          token_string,
1635          expected_string,
1636          message_prefix,
1637          message);
1638       else
1639   msg_handler (scanner,
1640          &quot;%s, expected %s%s%s&quot;,
1641          token_string,
1642          expected_string,
1643          message_prefix,
1644          message);
1645     }
1646 
1647   g_free (token_string);
1648   g_free (expected_string);
1649 }
1650 
1651 static void
1652 g_scanner_get_token_i (GScanner *scanner,
1653            GTokenType *token_p,
1654            GTokenValue  *value_p,
1655            guint    *line_p,
1656            guint    *position_p)
1657 {
1658   do
1659     {
1660       g_scanner_free_value (token_p, value_p);
1661       g_scanner_get_token_ll (scanner, token_p, value_p, line_p, position_p);
1662     }
1663   while (((*token_p &gt; 0 &amp;&amp; *token_p &lt; 256) &amp;&amp;
1664     strchr (scanner-&gt;config-&gt;cset_skip_characters, *token_p)) ||
1665    (*token_p == G_TOKEN_CHAR &amp;&amp;
1666     strchr (scanner-&gt;config-&gt;cset_skip_characters, value_p-&gt;v_char)) ||
1667    (*token_p == G_TOKEN_COMMENT_MULTI &amp;&amp;
1668     scanner-&gt;config-&gt;skip_comment_multi) ||
1669    (*token_p == G_TOKEN_COMMENT_SINGLE &amp;&amp;
1670     scanner-&gt;config-&gt;skip_comment_single));
1671 
1672   switch (*token_p)
1673     {
1674     case G_TOKEN_IDENTIFIER:
1675       if (scanner-&gt;config-&gt;identifier_2_string)
1676   *token_p = G_TOKEN_STRING;
1677       break;
1678 
1679     case G_TOKEN_SYMBOL:
1680       if (scanner-&gt;config-&gt;symbol_2_token)
1681   *token_p = (GTokenType) value_p-&gt;v_symbol;
1682       break;
1683 
1684     case G_TOKEN_BINARY:
1685     case G_TOKEN_OCTAL:
1686     case G_TOKEN_HEX:
1687       if (scanner-&gt;config-&gt;numbers_2_int)
1688   *token_p = G_TOKEN_INT;
1689       break;
1690 
1691     default:
1692       break;
1693     }
1694 
1695   if (*token_p == G_TOKEN_INT &amp;&amp;
1696       scanner-&gt;config-&gt;int_2_float)
1697     {
1698       *token_p = G_TOKEN_FLOAT;
1699       if (scanner-&gt;config-&gt;store_int64)
1700         {
1701           value_p-&gt;v_float = value_p-&gt;v_int64;
1702         }
1703       else
1704   value_p-&gt;v_float = value_p-&gt;v_int;
1705     }
1706 
1707   errno = 0;
1708 }
1709 
1710 static void
1711 g_scanner_get_token_ll  (GScanner *scanner,
1712        GTokenType *token_p,
1713        GTokenValue  *value_p,
1714        guint    *line_p,
1715        guint    *position_p)
1716 {
1717   GScannerConfig *config;
1718   GTokenType     token;
1719   gboolean     in_comment_multi;
1720   gboolean     in_comment_single;
1721   gboolean     in_string_sq;
1722   gboolean     in_string_dq;
1723   GString   *gstring;
1724   GTokenValue    value;
1725   guchar     ch;
1726 
1727   config = scanner-&gt;config;
1728   (*value_p).v_int64 = 0;
1729 
1730   if ((scanner-&gt;text &gt;= scanner-&gt;text_end &amp;&amp; scanner-&gt;input_fd &lt; 0) ||
1731       scanner-&gt;token == G_TOKEN_EOF)
1732     {
1733       *token_p = G_TOKEN_EOF;
1734       return;
1735     }
1736 
1737   in_comment_multi = FALSE;
1738   in_comment_single = FALSE;
1739   in_string_sq = FALSE;
1740   in_string_dq = FALSE;
1741   gstring = NULL;
1742 
1743   do /* while (ch != 0) */
1744     {
1745       gboolean dotted_float = FALSE;
1746 
1747       ch = g_scanner_get_char (scanner, line_p, position_p);
1748 
1749       value.v_int64 = 0;
1750       token = G_TOKEN_NONE;
1751 
1752       /* this is *evil*, but needed ;(
1753        * we first check for identifier first character, because  it
1754        * might interfere with other key chars like slashes or numbers
1755        */
1756       if (config-&gt;scan_identifier &amp;&amp;
1757     ch &amp;&amp; strchr (config-&gt;cset_identifier_first, ch))
1758   goto identifier_precedence;
1759 
1760       switch (ch)
1761   {
1762   case 0:
1763     token = G_TOKEN_EOF;
1764     (*position_p)++;
1765     /* ch = 0; */
1766     break;
1767 
1768   case &#39;/&#39;:
1769     if (!config-&gt;scan_comment_multi ||
1770         g_scanner_peek_next_char (scanner) != &#39;*&#39;)
1771       goto default_case;
1772     g_scanner_get_char (scanner, line_p, position_p);
1773     token = G_TOKEN_COMMENT_MULTI;
1774     in_comment_multi = TRUE;
1775     gstring = g_string_new (NULL);
1776     while ((ch = g_scanner_get_char (scanner, line_p, position_p)) != 0)
1777       {
1778         if (ch == &#39;*&#39; &amp;&amp; g_scanner_peek_next_char (scanner) == &#39;/&#39;)
1779     {
1780       g_scanner_get_char (scanner, line_p, position_p);
1781       in_comment_multi = FALSE;
1782       break;
1783     }
1784         else
1785     gstring = g_string_append_c (gstring, ch);
1786       }
1787     ch = 0;
1788     break;
1789 
1790   case &#39;\&#39;&#39;:
1791     if (!config-&gt;scan_string_sq)
1792       goto default_case;
1793     token = G_TOKEN_STRING;
1794     in_string_sq = TRUE;
1795     gstring = g_string_new (NULL);
1796     while ((ch = g_scanner_get_char (scanner, line_p, position_p)) != 0)
1797       {
1798         if (ch == &#39;\&#39;&#39;)
1799     {
1800       in_string_sq = FALSE;
1801       break;
1802     }
1803         else
1804     gstring = g_string_append_c (gstring, ch);
1805       }
1806     ch = 0;
1807     break;
1808 
1809   case &#39;&quot;&#39;:
1810     if (!config-&gt;scan_string_dq)
1811       goto default_case;
1812     token = G_TOKEN_STRING;
1813     in_string_dq = TRUE;
1814     gstring = g_string_new (NULL);
1815     while ((ch = g_scanner_get_char (scanner, line_p, position_p)) != 0)
1816       {
1817         if (ch == &#39;&quot;&#39;)
1818     {
1819       in_string_dq = FALSE;
1820       break;
1821     }
1822         else
1823     {
1824       if (ch == &#39;\\&#39;)
1825         {
1826           ch = g_scanner_get_char (scanner, line_p, position_p);
1827           switch (ch)
1828       {
1829         guint i;
1830         guint fchar;
1831 
1832       case 0:
1833         break;
1834 
1835       case &#39;\\&#39;:
1836         gstring = g_string_append_c (gstring, &#39;\\&#39;);
1837         break;
1838 
1839       case &#39;n&#39;:
1840         gstring = g_string_append_c (gstring, &#39;\n&#39;);
1841         break;
1842 
1843       case &#39;t&#39;:
1844         gstring = g_string_append_c (gstring, &#39;\t&#39;);
1845         break;
1846 
1847       case &#39;r&#39;:
1848         gstring = g_string_append_c (gstring, &#39;\r&#39;);
1849         break;
1850 
1851       case &#39;b&#39;:
1852         gstring = g_string_append_c (gstring, &#39;\b&#39;);
1853         break;
1854 
1855       case &#39;f&#39;:
1856         gstring = g_string_append_c (gstring, &#39;\f&#39;);
1857         break;
1858 
1859       case &#39;0&#39;:
1860       case &#39;1&#39;:
1861       case &#39;2&#39;:
1862       case &#39;3&#39;:
1863       case &#39;4&#39;:
1864       case &#39;5&#39;:
1865       case &#39;6&#39;:
1866       case &#39;7&#39;:
1867         i = ch - &#39;0&#39;;
1868         fchar = g_scanner_peek_next_char (scanner);
1869         if (fchar &gt;= &#39;0&#39; &amp;&amp; fchar &lt;= &#39;7&#39;)
1870           {
1871             ch = g_scanner_get_char (scanner, line_p, position_p);
1872             i = i * 8 + ch - &#39;0&#39;;
1873             fchar = g_scanner_peek_next_char (scanner);
1874             if (fchar &gt;= &#39;0&#39; &amp;&amp; fchar &lt;= &#39;7&#39;)
1875         {
1876           ch = g_scanner_get_char (scanner, line_p, position_p);
1877           i = i * 8 + ch - &#39;0&#39;;
1878         }
1879           }
1880         gstring = g_string_append_c (gstring, i);
1881         break;
1882 
1883       default:
1884         gstring = g_string_append_c (gstring, ch);
1885         break;
1886       }
1887         }
1888       else
1889         gstring = g_string_append_c (gstring, ch);
1890     }
1891       }
1892     ch = 0;
1893     break;
1894 
1895   case &#39;.&#39;:
1896     if (!config-&gt;scan_float)
1897       goto default_case;
1898     token = G_TOKEN_FLOAT;
1899     dotted_float = TRUE;
1900     ch = g_scanner_get_char (scanner, line_p, position_p);
1901     goto number_parsing;
1902 
1903   case &#39;$&#39;:
1904     if (!config-&gt;scan_hex_dollar)
1905       goto default_case;
1906     token = G_TOKEN_HEX;
1907     ch = g_scanner_get_char (scanner, line_p, position_p);
1908     goto number_parsing;
1909 
1910   case &#39;0&#39;:
1911     if (config-&gt;scan_octal)
1912       token = G_TOKEN_OCTAL;
1913     else
1914       token = G_TOKEN_INT;
1915     ch = g_scanner_peek_next_char (scanner);
1916     if (config-&gt;scan_hex &amp;&amp; (ch == &#39;x&#39; || ch == &#39;X&#39;))
1917       {
1918         token = G_TOKEN_HEX;
1919         g_scanner_get_char (scanner, line_p, position_p);
1920         ch = g_scanner_get_char (scanner, line_p, position_p);
1921         if (ch == 0)
1922     {
1923       token = G_TOKEN_ERROR;
1924       value.v_error = G_ERR_UNEXP_EOF;
1925       (*position_p)++;
1926       break;
1927     }
1928         if (g_scanner_char_2_num (ch, 16) &lt; 0)
1929     {
1930       token = G_TOKEN_ERROR;
1931       value.v_error = G_ERR_DIGIT_RADIX;
1932       ch = 0;
1933       break;
1934     }
1935       }
1936     else if (config-&gt;scan_binary &amp;&amp; (ch == &#39;b&#39; || ch == &#39;B&#39;))
1937       {
1938         token = G_TOKEN_BINARY;
1939         g_scanner_get_char (scanner, line_p, position_p);
1940         ch = g_scanner_get_char (scanner, line_p, position_p);
1941         if (ch == 0)
1942     {
1943       token = G_TOKEN_ERROR;
1944       value.v_error = G_ERR_UNEXP_EOF;
1945       (*position_p)++;
1946       break;
1947     }
1948         if (g_scanner_char_2_num (ch, 10) &lt; 0)
1949     {
1950       token = G_TOKEN_ERROR;
1951       value.v_error = G_ERR_NON_DIGIT_IN_CONST;
1952       ch = 0;
1953       break;
1954     }
1955       }
1956     else
1957       ch = &#39;0&#39;;
1958     /* fall through */
1959   case &#39;1&#39;:
1960   case &#39;2&#39;:
1961   case &#39;3&#39;:
1962   case &#39;4&#39;:
1963   case &#39;5&#39;:
1964   case &#39;6&#39;:
1965   case &#39;7&#39;:
1966   case &#39;8&#39;:
1967   case &#39;9&#39;:
1968   number_parsing:
1969   {
1970           gboolean in_number = TRUE;
1971     gchar *endptr;
1972 
1973     if (token == G_TOKEN_NONE)
1974       token = G_TOKEN_INT;
1975 
1976     gstring = g_string_new (dotted_float ? &quot;0.&quot; : &quot;&quot;);
1977     gstring = g_string_append_c (gstring, ch);
1978 
1979     do /* while (in_number) */
1980       {
1981         gboolean is_E;
1982 
1983         is_E = token == G_TOKEN_FLOAT &amp;&amp; (ch == &#39;e&#39; || ch == &#39;E&#39;);
1984 
1985         ch = g_scanner_peek_next_char (scanner);
1986 
1987         if (g_scanner_char_2_num (ch, 36) &gt;= 0 ||
1988       (config-&gt;scan_float &amp;&amp; ch == &#39;.&#39;) ||
1989       (is_E &amp;&amp; (ch == &#39;+&#39; || ch == &#39;-&#39;)))
1990     {
1991       ch = g_scanner_get_char (scanner, line_p, position_p);
1992 
1993       switch (ch)
1994         {
1995         case &#39;.&#39;:
1996           if (token != G_TOKEN_INT &amp;&amp; token != G_TOKEN_OCTAL)
1997       {
1998         value.v_error = token == G_TOKEN_FLOAT ? G_ERR_FLOAT_MALFORMED : G_ERR_FLOAT_RADIX;
1999         token = G_TOKEN_ERROR;
2000         in_number = FALSE;
2001       }
2002           else
2003       {
2004         token = G_TOKEN_FLOAT;
2005         gstring = g_string_append_c (gstring, ch);
2006       }
2007           break;
2008 
2009         case &#39;0&#39;:
2010         case &#39;1&#39;:
2011         case &#39;2&#39;:
2012         case &#39;3&#39;:
2013         case &#39;4&#39;:
2014         case &#39;5&#39;:
2015         case &#39;6&#39;:
2016         case &#39;7&#39;:
2017         case &#39;8&#39;:
2018         case &#39;9&#39;:
2019           gstring = g_string_append_c (gstring, ch);
2020           break;
2021 
2022         case &#39;-&#39;:
2023         case &#39;+&#39;:
2024           if (token != G_TOKEN_FLOAT)
2025       {
2026         token = G_TOKEN_ERROR;
2027         value.v_error = G_ERR_NON_DIGIT_IN_CONST;
2028         in_number = FALSE;
2029       }
2030           else
2031       gstring = g_string_append_c (gstring, ch);
2032           break;
2033 
2034         case &#39;e&#39;:
2035         case &#39;E&#39;:
2036           if ((token != G_TOKEN_HEX &amp;&amp; !config-&gt;scan_float) ||
2037         (token != G_TOKEN_HEX &amp;&amp;
2038          token != G_TOKEN_OCTAL &amp;&amp;
2039          token != G_TOKEN_FLOAT &amp;&amp;
2040          token != G_TOKEN_INT))
2041       {
2042         token = G_TOKEN_ERROR;
2043         value.v_error = G_ERR_NON_DIGIT_IN_CONST;
2044         in_number = FALSE;
2045       }
2046           else
2047       {
2048         if (token != G_TOKEN_HEX)
2049           token = G_TOKEN_FLOAT;
2050         gstring = g_string_append_c (gstring, ch);
2051       }
2052           break;
2053 
2054         default:
2055           if (token != G_TOKEN_HEX)
2056       {
2057         token = G_TOKEN_ERROR;
2058         value.v_error = G_ERR_NON_DIGIT_IN_CONST;
2059         in_number = FALSE;
2060       }
2061           else
2062       gstring = g_string_append_c (gstring, ch);
2063           break;
2064         }
2065     }
2066         else
2067     in_number = FALSE;
2068       }
2069     while (in_number);
2070 
2071     endptr = NULL;
2072     if (token == G_TOKEN_FLOAT)
2073       value.v_float = g_strtod (gstring-&gt;str, &amp;endptr);
2074     else
2075       {
2076         guint64 ui64 = 0;
2077         switch (token)
2078     {
2079     case G_TOKEN_BINARY:
2080       ui64 = g_ascii_strtoull (gstring-&gt;str, &amp;endptr, 2);
2081       break;
2082     case G_TOKEN_OCTAL:
2083       ui64 = g_ascii_strtoull (gstring-&gt;str, &amp;endptr, 8);
2084       break;
2085     case G_TOKEN_INT:
2086       ui64 = g_ascii_strtoull (gstring-&gt;str, &amp;endptr, 10);
2087       break;
2088     case G_TOKEN_HEX:
2089       ui64 = g_ascii_strtoull (gstring-&gt;str, &amp;endptr, 16);
2090       break;
2091     default: ;
2092     }
2093         if (scanner-&gt;config-&gt;store_int64)
2094     value.v_int64 = ui64;
2095         else
2096     value.v_int = ui64;
2097       }
2098     if (endptr &amp;&amp; *endptr)
2099       {
2100         token = G_TOKEN_ERROR;
2101         if (*endptr == &#39;e&#39; || *endptr == &#39;E&#39;)
2102     value.v_error = G_ERR_NON_DIGIT_IN_CONST;
2103         else
2104     value.v_error = G_ERR_DIGIT_RADIX;
2105       }
2106     g_string_free (gstring, TRUE);
2107     gstring = NULL;
2108     ch = 0;
2109   } /* number_parsing:... */
2110   break;
2111 
2112   default:
2113   default_case:
2114   {
2115     if (config-&gt;cpair_comment_single &amp;&amp;
2116         ch == config-&gt;cpair_comment_single[0])
2117       {
2118         token = G_TOKEN_COMMENT_SINGLE;
2119         in_comment_single = TRUE;
2120         gstring = g_string_new (NULL);
2121         ch = g_scanner_get_char (scanner, line_p, position_p);
2122         while (ch != 0)
2123     {
2124       if (ch == config-&gt;cpair_comment_single[1])
2125         {
2126           in_comment_single = FALSE;
2127           ch = 0;
2128           break;
2129         }
2130 
2131       gstring = g_string_append_c (gstring, ch);
2132       ch = g_scanner_get_char (scanner, line_p, position_p);
2133     }
2134         /* ignore a missing newline at EOF for single line comments */
2135         if (in_comment_single &amp;&amp;
2136       config-&gt;cpair_comment_single[1] == &#39;\n&#39;)
2137     in_comment_single = FALSE;
2138       }
2139     else if (config-&gt;scan_identifier &amp;&amp; ch &amp;&amp;
2140        strchr (config-&gt;cset_identifier_first, ch))
2141       {
2142       identifier_precedence:
2143 
2144         if (config-&gt;cset_identifier_nth &amp;&amp; ch &amp;&amp;
2145       strchr (config-&gt;cset_identifier_nth,
2146         g_scanner_peek_next_char (scanner)))
2147     {
2148       token = G_TOKEN_IDENTIFIER;
2149       gstring = g_string_new (NULL);
2150       gstring = g_string_append_c (gstring, ch);
2151       do
2152         {
2153           ch = g_scanner_get_char (scanner, line_p, position_p);
2154           gstring = g_string_append_c (gstring, ch);
2155           ch = g_scanner_peek_next_char (scanner);
2156         }
2157       while (ch &amp;&amp; strchr (config-&gt;cset_identifier_nth, ch));
2158       ch = 0;
2159     }
2160         else if (config-&gt;scan_identifier_1char)
2161     {
2162       token = G_TOKEN_IDENTIFIER;
2163       value.v_identifier = g_new0 (gchar, 2);
2164       value.v_identifier[0] = ch;
2165       ch = 0;
2166     }
2167       }
2168     if (ch)
2169       {
2170         if (config-&gt;char_2_token)
2171     token = ch;
2172         else
2173     {
2174       token = G_TOKEN_CHAR;
2175       value.v_char = ch;
2176     }
2177         ch = 0;
2178       }
2179   } /* default_case:... */
2180   break;
2181   }
2182       g_assert (ch == 0 &amp;&amp; token != G_TOKEN_NONE); /* paranoid */
2183     }
2184   while (ch != 0);
2185 
2186   if (in_comment_multi || in_comment_single ||
2187       in_string_sq || in_string_dq)
2188     {
2189       token = G_TOKEN_ERROR;
2190       if (gstring)
2191   {
2192     g_string_free (gstring, TRUE);
2193     gstring = NULL;
2194   }
2195       (*position_p)++;
2196       if (in_comment_multi || in_comment_single)
2197   value.v_error = G_ERR_UNEXP_EOF_IN_COMMENT;
2198       else /* (in_string_sq || in_string_dq) */
2199   value.v_error = G_ERR_UNEXP_EOF_IN_STRING;
2200     }
2201 
2202   if (gstring)
2203     {
2204       value.v_string = g_string_free (gstring, FALSE);
2205       gstring = NULL;
2206     }
2207 
2208   if (token == G_TOKEN_IDENTIFIER)
2209     {
2210       if (config-&gt;scan_symbols)
2211   {
2212     GScannerKey *key;
2213     guint scope_id;
2214 
2215     scope_id = scanner-&gt;scope_id;
2216     key = g_scanner_lookup_internal (scanner, scope_id, value.v_identifier);
2217     if (!key &amp;&amp; scope_id &amp;&amp; scanner-&gt;config-&gt;scope_0_fallback)
2218       key = g_scanner_lookup_internal (scanner, 0, value.v_identifier);
2219 
2220     if (key)
2221       {
2222         g_free (value.v_identifier);
2223         token = G_TOKEN_SYMBOL;
2224         value.v_symbol = key-&gt;value;
2225       }
2226   }
2227 
2228       if (token == G_TOKEN_IDENTIFIER &amp;&amp;
2229     config-&gt;scan_identifier_NULL &amp;&amp;
2230     strlen (value.v_identifier) == 4)
2231   {
2232     gchar *null_upper = &quot;NULL&quot;;
2233     gchar *null_lower = &quot;null&quot;;
2234 
2235     if (scanner-&gt;config-&gt;case_sensitive)
2236       {
2237         if (value.v_identifier[0] == null_upper[0] &amp;&amp;
2238       value.v_identifier[1] == null_upper[1] &amp;&amp;
2239       value.v_identifier[2] == null_upper[2] &amp;&amp;
2240       value.v_identifier[3] == null_upper[3])
2241     token = G_TOKEN_IDENTIFIER_NULL;
2242       }
2243     else
2244       {
2245         if ((value.v_identifier[0] == null_upper[0] ||
2246        value.v_identifier[0] == null_lower[0]) &amp;&amp;
2247       (value.v_identifier[1] == null_upper[1] ||
2248        value.v_identifier[1] == null_lower[1]) &amp;&amp;
2249       (value.v_identifier[2] == null_upper[2] ||
2250        value.v_identifier[2] == null_lower[2]) &amp;&amp;
2251       (value.v_identifier[3] == null_upper[3] ||
2252        value.v_identifier[3] == null_lower[3]))
2253     token = G_TOKEN_IDENTIFIER_NULL;
2254       }
2255   }
2256     }
2257 
2258   *token_p = token;
2259   *value_p = value;
2260 }
    </pre>
  </body>
</html>