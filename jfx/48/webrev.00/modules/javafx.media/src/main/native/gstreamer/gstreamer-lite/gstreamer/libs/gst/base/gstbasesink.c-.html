<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstbasesink.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 2005-2007 Wim Taymans &lt;wim.taymans@gmail.com&gt;
   3  *
   4  * gstbasesink.c: Base class for sink elements
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 /**
  23  * SECTION:gstbasesink
  24  * @title: GstBaseSink
  25  * @short_description: Base class for sink elements
  26  * @see_also: #GstBaseTransform, #GstBaseSrc
  27  *
  28  * #GstBaseSink is the base class for sink elements in GStreamer, such as
  29  * xvimagesink or filesink. It is a layer on top of #GstElement that provides a
  30  * simplified interface to plugin writers. #GstBaseSink handles many details
  31  * for you, for example: preroll, clock synchronization, state changes,
  32  * activation in push or pull mode, and queries.
  33  *
  34  * In most cases, when writing sink elements, there is no need to implement
  35  * class methods from #GstElement or to set functions on pads, because the
  36  * #GstBaseSink infrastructure should be sufficient.
  37  *
  38  * #GstBaseSink provides support for exactly one sink pad, which should be
  39  * named &quot;sink&quot;. A sink implementation (subclass of #GstBaseSink) should
  40  * install a pad template in its class_init function, like so:
  41  * |[&lt;!-- language=&quot;C&quot; --&gt;
  42  * static void
  43  * my_element_class_init (GstMyElementClass *klass)
  44  * {
  45  *   GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
  46  *
  47  *   // sinktemplate should be a #GstStaticPadTemplate with direction
  48  *   // %GST_PAD_SINK and name &quot;sink&quot;
  49  *   gst_element_class_add_static_pad_template (gstelement_class, &amp;amp;sinktemplate);
  50  *
  51  *   gst_element_class_set_static_metadata (gstelement_class,
  52  *       &quot;Sink name&quot;,
  53  *       &quot;Sink&quot;,
  54  *       &quot;My Sink element&quot;,
  55  *       &quot;The author &lt;my.sink@my.email&gt;&quot;);
  56  * }
  57  * ]|
  58  *
  59  * #GstBaseSink will handle the prerolling correctly. This means that it will
  60  * return %GST_STATE_CHANGE_ASYNC from a state change to PAUSED until the first
  61  * buffer arrives in this element. The base class will call the
  62  * #GstBaseSinkClass.preroll() vmethod with this preroll buffer and will then
  63  * commit the state change to the next asynchronously pending state.
  64  *
  65  * When the element is set to PLAYING, #GstBaseSink will synchronise on the
  66  * clock using the times returned from #GstBaseSinkClass.get_times(). If this
  67  * function returns %GST_CLOCK_TIME_NONE for the start time, no synchronisation
  68  * will be done. Synchronisation can be disabled entirely by setting the object
  69  * #GstBaseSink:sync property to %FALSE.
  70  *
  71  * After synchronisation the virtual method #GstBaseSinkClass.render() will be
  72  * called. Subclasses should minimally implement this method.
  73  *
  74  * Subclasses that synchronise on the clock in the #GstBaseSinkClass.render()
  75  * method are supported as well. These classes typically receive a buffer in
  76  * the render method and can then potentially block on the clock while
  77  * rendering. A typical example is an audiosink.
  78  * These subclasses can use gst_base_sink_wait_preroll() to perform the
  79  * blocking wait.
  80  *
  81  * Upon receiving the EOS event in the PLAYING state, #GstBaseSink will wait
  82  * for the clock to reach the time indicated by the stop time of the last
  83  * #GstBaseSinkClass.get_times() call before posting an EOS message. When the
  84  * element receives EOS in PAUSED, preroll completes, the event is queued and an
  85  * EOS message is posted when going to PLAYING.
  86  *
  87  * #GstBaseSink will internally use the %GST_EVENT_SEGMENT events to schedule
  88  * synchronisation and clipping of buffers. Buffers that fall completely outside
  89  * of the current segment are dropped. Buffers that fall partially in the
  90  * segment are rendered (and prerolled). Subclasses should do any subbuffer
  91  * clipping themselves when needed.
  92  *
  93  * #GstBaseSink will by default report the current playback position in
  94  * %GST_FORMAT_TIME based on the current clock time and segment information.
  95  * If no clock has been set on the element, the query will be forwarded
  96  * upstream.
  97  *
  98  * The #GstBaseSinkClass.set_caps() function will be called when the subclass
  99  * should configure itself to process a specific media type.
 100  *
 101  * The #GstBaseSinkClass.start() and #GstBaseSinkClass.stop() virtual methods
 102  * will be called when resources should be allocated. Any
 103  * #GstBaseSinkClass.preroll(), #GstBaseSinkClass.render() and
 104  * #GstBaseSinkClass.set_caps() function will be called between the
 105  * #GstBaseSinkClass.start() and #GstBaseSinkClass.stop() calls.
 106  *
 107  * The #GstBaseSinkClass.event() virtual method will be called when an event is
 108  * received by #GstBaseSink. Normally this method should only be overridden by
 109  * very specific elements (such as file sinks) which need to handle the
 110  * newsegment event specially.
 111  *
 112  * The #GstBaseSinkClass.unlock() method is called when the elements should
 113  * unblock any blocking operations they perform in the
 114  * #GstBaseSinkClass.render() method. This is mostly useful when the
 115  * #GstBaseSinkClass.render() method performs a blocking write on a file
 116  * descriptor, for example.
 117  *
 118  * The #GstBaseSink:max-lateness property affects how the sink deals with
 119  * buffers that arrive too late in the sink. A buffer arrives too late in the
 120  * sink when the presentation time (as a combination of the last segment, buffer
 121  * timestamp and element base_time) plus the duration is before the current
 122  * time of the clock.
 123  * If the frame is later than max-lateness, the sink will drop the buffer
 124  * without calling the render method.
 125  * This feature is disabled if sync is disabled, the
 126  * #GstBaseSinkClass.get_times() method does not return a valid start time or
 127  * max-lateness is set to -1 (the default).
 128  * Subclasses can use gst_base_sink_set_max_lateness() to configure the
 129  * max-lateness value.
 130  *
 131  * The #GstBaseSink:qos property will enable the quality-of-service features of
 132  * the basesink which gather statistics about the real-time performance of the
 133  * clock synchronisation. For each buffer received in the sink, statistics are
 134  * gathered and a QOS event is sent upstream with these numbers. This
 135  * information can then be used by upstream elements to reduce their processing
 136  * rate, for example.
 137  *
 138  * The #GstBaseSink:async property can be used to instruct the sink to never
 139  * perform an ASYNC state change. This feature is mostly usable when dealing
 140  * with non-synchronized streams or sparse streams.
 141  */
 142 
 143 #ifdef HAVE_CONFIG_H
 144 #  include &quot;config.h&quot;
 145 #endif
 146 
 147 #include &lt;gst/gst_private.h&gt;
 148 
 149 #include &quot;gstbasesink.h&quot;
 150 #include &lt;gst/gst-i18n-lib.h&gt;
 151 
 152 GST_DEBUG_CATEGORY_STATIC (gst_base_sink_debug);
 153 #define GST_CAT_DEFAULT gst_base_sink_debug
 154 
 155 #define GST_BASE_SINK_GET_PRIVATE(obj)  \
 156    (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_BASE_SINK, GstBaseSinkPrivate))
 157 
 158 #define GST_FLOW_STEP GST_FLOW_CUSTOM_ERROR
 159 
 160 typedef struct
 161 {
 162   gboolean valid;               /* if this info is valid */
 163   guint32 seqnum;               /* the seqnum of the STEP event */
 164   GstFormat format;             /* the format of the amount */
 165   guint64 amount;               /* the total amount of data to skip */
 166   guint64 position;             /* the position in the stepped data */
 167   guint64 duration;             /* the duration in time of the skipped data */
 168   guint64 start;                /* running_time of the start */
 169   gdouble rate;                 /* rate of skipping */
 170   gdouble start_rate;           /* rate before skipping */
 171   guint64 start_start;          /* start position skipping */
 172   guint64 start_stop;           /* stop position skipping */
 173   gboolean flush;               /* if this was a flushing step */
 174   gboolean intermediate;        /* if this is an intermediate step */
 175   gboolean need_preroll;        /* if we need preroll after this step */
 176 } GstStepInfo;
 177 
 178 struct _GstBaseSinkPrivate
 179 {
 180   gint qos_enabled;             /* ATOMIC */
 181   gboolean async_enabled;
 182   GstClockTimeDiff ts_offset;
 183   GstClockTime render_delay;
 184 
 185   /* start, stop of current buffer, stream time, used to report position */
 186   GstClockTime current_sstart;
 187   GstClockTime current_sstop;
 188 
 189   /* start, stop and jitter of current buffer, running time */
 190   GstClockTime current_rstart;
 191   GstClockTime current_rstop;
 192   GstClockTimeDiff current_jitter;
 193   /* the running time of the previous buffer */
 194   GstClockTime prev_rstart;
 195 
 196   /* EOS sync time in running time */
 197   GstClockTime eos_rtime;
 198 
 199   /* last buffer that arrived in time, running time */
 200   GstClockTime last_render_time;
 201   /* when the last buffer left the sink, running time */
 202   GstClockTime last_left;
 203 
 204   /* running averages go here these are done on running time */
 205   GstClockTime avg_pt, avg_in_diff;
 206   gdouble avg_rate;             /* average with infinite window */
 207 
 208   /* number of rendered and dropped frames */
 209   guint64 rendered;
 210   guint64 dropped;
 211 
 212   /* latency stuff */
 213   GstClockTime latency;
 214 
 215   /* if we already commited the state */
 216   gboolean commited;
 217   /* state change to playing ongoing */
 218   gboolean to_playing;
 219 
 220   /* when we received EOS */
 221   gboolean received_eos;
 222 
 223   /* when we are prerolled and able to report latency */
 224   gboolean have_latency;
 225 
 226   /* the last buffer we prerolled or rendered. Useful for making snapshots */
 227   gint enable_last_sample;      /* atomic */
 228   GstBuffer *last_buffer;
 229   GstCaps *last_caps;
 230   GstBufferList *last_buffer_list;
 231 
 232   /* negotiated caps */
 233   GstCaps *caps;
 234 
 235   /* blocksize for pulling */
 236   guint blocksize;
 237 
 238   gboolean discont;
 239 
 240   /* seqnum of the stream */
 241   guint32 seqnum;
 242 
 243   gboolean call_preroll;
 244   gboolean step_unlock;
 245 
 246   /* we have a pending and a current step operation */
 247   GstStepInfo current_step;
 248   GstStepInfo pending_step;
 249 
 250   /* Cached GstClockID */
 251   GstClockID cached_clock_id;
 252 
 253   /* for throttling and QoS */
 254   GstClockTime earliest_in_time;
 255   GstClockTime throttle_time;
 256 
 257   /* for rate control */
 258   guint64 max_bitrate;
 259   GstClockTime rc_time;
 260   GstClockTime rc_next;
 261   gsize rc_accumulated;
 262 
 263   gboolean drop_out_of_segment;
 264 };
 265 
 266 #define DO_RUNNING_AVG(avg,val,size) (((val) + ((size)-1) * (avg)) / (size))
 267 
 268 /* generic running average, this has a neutral window size */
 269 #define UPDATE_RUNNING_AVG(avg,val)   DO_RUNNING_AVG(avg,val,8)
 270 
 271 /* the windows for these running averages are experimentally obtained.
 272  * positive values get averaged more while negative values use a small
 273  * window so we can react faster to badness. */
 274 #define UPDATE_RUNNING_AVG_P(avg,val) DO_RUNNING_AVG(avg,val,16)
 275 #define UPDATE_RUNNING_AVG_N(avg,val) DO_RUNNING_AVG(avg,val,4)
 276 
 277 /* BaseSink properties */
 278 
 279 #define DEFAULT_CAN_ACTIVATE_PULL FALSE /* fixme: enable me */
 280 #define DEFAULT_CAN_ACTIVATE_PUSH TRUE
 281 
 282 #define DEFAULT_SYNC                TRUE
 283 #define DEFAULT_MAX_LATENESS        -1
 284 #define DEFAULT_QOS                 FALSE
 285 #define DEFAULT_ASYNC               TRUE
 286 #define DEFAULT_TS_OFFSET           0
 287 #define DEFAULT_BLOCKSIZE           4096
 288 #define DEFAULT_RENDER_DELAY        0
 289 #define DEFAULT_ENABLE_LAST_SAMPLE  TRUE
 290 #define DEFAULT_THROTTLE_TIME       0
 291 #define DEFAULT_MAX_BITRATE         0
 292 #define DEFAULT_DROP_OUT_OF_SEGMENT TRUE
 293 
 294 enum
 295 {
 296   PROP_0,
 297   PROP_SYNC,
 298   PROP_MAX_LATENESS,
 299   PROP_QOS,
 300   PROP_ASYNC,
 301   PROP_TS_OFFSET,
 302   PROP_ENABLE_LAST_SAMPLE,
 303   PROP_LAST_SAMPLE,
 304   PROP_BLOCKSIZE,
 305   PROP_RENDER_DELAY,
 306   PROP_THROTTLE_TIME,
 307   PROP_MAX_BITRATE,
 308   PROP_LAST
 309 };
 310 
 311 static GstElementClass *parent_class = NULL;
 312 
 313 static void gst_base_sink_class_init (GstBaseSinkClass * klass);
 314 static void gst_base_sink_init (GstBaseSink * trans, gpointer g_class);
 315 static void gst_base_sink_finalize (GObject * object);
 316 
 317 GType
 318 gst_base_sink_get_type (void)
 319 {
 320   static volatile gsize base_sink_type = 0;
 321 
 322   if (g_once_init_enter (&amp;base_sink_type)) {
 323     GType _type;
 324     static const GTypeInfo base_sink_info = {
 325       sizeof (GstBaseSinkClass),
 326       NULL,
 327       NULL,
 328       (GClassInitFunc) gst_base_sink_class_init,
 329       NULL,
 330       NULL,
 331       sizeof (GstBaseSink),
 332       0,
 333       (GInstanceInitFunc) gst_base_sink_init,
 334     };
 335 
 336     _type = g_type_register_static (GST_TYPE_ELEMENT,
 337         &quot;GstBaseSink&quot;, &amp;base_sink_info, G_TYPE_FLAG_ABSTRACT);
 338     g_once_init_leave (&amp;base_sink_type, _type);
 339   }
 340   return base_sink_type;
 341 }
 342 
 343 static void gst_base_sink_set_property (GObject * object, guint prop_id,
 344     const GValue * value, GParamSpec * pspec);
 345 static void gst_base_sink_get_property (GObject * object, guint prop_id,
 346     GValue * value, GParamSpec * pspec);
 347 
 348 static gboolean gst_base_sink_send_event (GstElement * element,
 349     GstEvent * event);
 350 static gboolean default_element_query (GstElement * element, GstQuery * query);
 351 
 352 static GstCaps *gst_base_sink_default_get_caps (GstBaseSink * sink,
 353     GstCaps * caps);
 354 static gboolean gst_base_sink_default_set_caps (GstBaseSink * sink,
 355     GstCaps * caps);
 356 static void gst_base_sink_default_get_times (GstBaseSink * basesink,
 357     GstBuffer * buffer, GstClockTime * start, GstClockTime * end);
 358 static gboolean gst_base_sink_set_flushing (GstBaseSink * basesink,
 359     GstPad * pad, gboolean flushing);
 360 static gboolean gst_base_sink_default_activate_pull (GstBaseSink * basesink,
 361     gboolean active);
 362 static gboolean gst_base_sink_default_do_seek (GstBaseSink * sink,
 363     GstSegment * segment);
 364 static gboolean gst_base_sink_default_prepare_seek_segment (GstBaseSink * sink,
 365     GstEvent * event, GstSegment * segment);
 366 
 367 static GstStateChangeReturn gst_base_sink_change_state (GstElement * element,
 368     GstStateChange transition);
 369 
 370 static gboolean gst_base_sink_sink_query (GstPad * pad, GstObject * parent,
 371     GstQuery * query);
 372 static GstFlowReturn gst_base_sink_chain (GstPad * pad, GstObject * parent,
 373     GstBuffer * buffer);
 374 static GstFlowReturn gst_base_sink_chain_list (GstPad * pad, GstObject * parent,
 375     GstBufferList * list);
 376 
 377 static void gst_base_sink_loop (GstPad * pad);
 378 static gboolean gst_base_sink_pad_activate (GstPad * pad, GstObject * parent);
 379 static gboolean gst_base_sink_pad_activate_mode (GstPad * pad,
 380     GstObject * parent, GstPadMode mode, gboolean active);
 381 static gboolean gst_base_sink_default_event (GstBaseSink * basesink,
 382     GstEvent * event);
 383 static GstFlowReturn gst_base_sink_default_wait_event (GstBaseSink * basesink,
 384     GstEvent * event);
 385 static gboolean gst_base_sink_event (GstPad * pad, GstObject * parent,
 386     GstEvent * event);
 387 
 388 static gboolean gst_base_sink_default_query (GstBaseSink * sink,
 389     GstQuery * query);
 390 
 391 static gboolean gst_base_sink_negotiate_pull (GstBaseSink * basesink);
 392 static GstCaps *gst_base_sink_default_fixate (GstBaseSink * bsink,
 393     GstCaps * caps);
 394 static GstCaps *gst_base_sink_fixate (GstBaseSink * bsink, GstCaps * caps);
 395 
 396 /* check if an object was too late */
 397 static gboolean gst_base_sink_is_too_late (GstBaseSink * basesink,
 398     GstMiniObject * obj, GstClockTime rstart, GstClockTime rstop,
 399     GstClockReturn status, GstClockTimeDiff jitter, gboolean render);
 400 
 401 static void
 402 gst_base_sink_class_init (GstBaseSinkClass * klass)
 403 {
 404   GObjectClass *gobject_class;
 405   GstElementClass *gstelement_class;
 406 
 407   gobject_class = G_OBJECT_CLASS (klass);
 408   gstelement_class = GST_ELEMENT_CLASS (klass);
 409 
 410   GST_DEBUG_CATEGORY_INIT (gst_base_sink_debug, &quot;basesink&quot;, 0,
 411       &quot;basesink element&quot;);
 412 
 413   g_type_class_add_private (klass, sizeof (GstBaseSinkPrivate));
 414 
 415   parent_class = g_type_class_peek_parent (klass);
 416 
 417   gobject_class-&gt;finalize = gst_base_sink_finalize;
 418   gobject_class-&gt;set_property = gst_base_sink_set_property;
 419   gobject_class-&gt;get_property = gst_base_sink_get_property;
 420 
 421   g_object_class_install_property (gobject_class, PROP_SYNC,
 422       g_param_spec_boolean (&quot;sync&quot;, &quot;Sync&quot;, &quot;Sync on the clock&quot;, DEFAULT_SYNC,
 423           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 424 
 425   g_object_class_install_property (gobject_class, PROP_MAX_LATENESS,
 426       g_param_spec_int64 (&quot;max-lateness&quot;, &quot;Max Lateness&quot;,
 427           &quot;Maximum number of nanoseconds that a buffer can be late before it &quot;
 428           &quot;is dropped (-1 unlimited)&quot;, -1, G_MAXINT64, DEFAULT_MAX_LATENESS,
 429           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 430 
 431   g_object_class_install_property (gobject_class, PROP_QOS,
 432       g_param_spec_boolean (&quot;qos&quot;, &quot;Qos&quot;,
 433           &quot;Generate Quality-of-Service events upstream&quot;, DEFAULT_QOS,
 434           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 435   /**
 436    * GstBaseSink:async:
 437    *
 438    * If set to %TRUE, the basesink will perform asynchronous state changes.
 439    * When set to %FALSE, the sink will not signal the parent when it prerolls.
 440    * Use this option when dealing with sparse streams or when synchronisation is
 441    * not required.
 442    */
 443   g_object_class_install_property (gobject_class, PROP_ASYNC,
 444       g_param_spec_boolean (&quot;async&quot;, &quot;Async&quot;,
 445           &quot;Go asynchronously to PAUSED&quot;, DEFAULT_ASYNC,
 446           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 447   /**
 448    * GstBaseSink:ts-offset:
 449    *
 450    * Controls the final synchronisation, a negative value will render the buffer
 451    * earlier while a positive value delays playback. This property can be
 452    * used to fix synchronisation in bad files.
 453    */
 454   g_object_class_install_property (gobject_class, PROP_TS_OFFSET,
 455       g_param_spec_int64 (&quot;ts-offset&quot;, &quot;TS Offset&quot;,
 456           &quot;Timestamp offset in nanoseconds&quot;, G_MININT64, G_MAXINT64,
 457           DEFAULT_TS_OFFSET, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 458 
 459   /**
 460    * GstBaseSink:enable-last-sample:
 461    *
 462    * Enable the last-sample property. If %FALSE, basesink doesn&#39;t keep a
 463    * reference to the last buffer arrived and the last-sample property is always
 464    * set to %NULL. This can be useful if you need buffers to be released as soon
 465    * as possible, eg. if you&#39;re using a buffer pool.
 466    */
 467   g_object_class_install_property (gobject_class, PROP_ENABLE_LAST_SAMPLE,
 468       g_param_spec_boolean (&quot;enable-last-sample&quot;, &quot;Enable Last Buffer&quot;,
 469           &quot;Enable the last-sample property&quot;, DEFAULT_ENABLE_LAST_SAMPLE,
 470           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 471 
 472   /**
 473    * GstBaseSink:last-sample:
 474    *
 475    * The last buffer that arrived in the sink and was used for preroll or for
 476    * rendering. This property can be used to generate thumbnails. This property
 477    * can be %NULL when the sink has not yet received a buffer.
 478    */
 479   g_object_class_install_property (gobject_class, PROP_LAST_SAMPLE,
 480       g_param_spec_boxed (&quot;last-sample&quot;, &quot;Last Sample&quot;,
 481           &quot;The last sample received in the sink&quot;, GST_TYPE_SAMPLE,
 482           G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 483   /**
 484    * GstBaseSink:blocksize:
 485    *
 486    * The amount of bytes to pull when operating in pull mode.
 487    */
 488   /* FIXME 2.0: blocksize property should be int, otherwise min&gt;max.. */
 489   g_object_class_install_property (gobject_class, PROP_BLOCKSIZE,
 490       g_param_spec_uint (&quot;blocksize&quot;, &quot;Block size&quot;,
 491           &quot;Size in bytes to pull per buffer (0 = default)&quot;, 0, G_MAXUINT,
 492           DEFAULT_BLOCKSIZE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 493   /**
 494    * GstBaseSink:render-delay:
 495    *
 496    * The additional delay between synchronisation and actual rendering of the
 497    * media. This property will add additional latency to the device in order to
 498    * make other sinks compensate for the delay.
 499    */
 500   g_object_class_install_property (gobject_class, PROP_RENDER_DELAY,
 501       g_param_spec_uint64 (&quot;render-delay&quot;, &quot;Render Delay&quot;,
 502           &quot;Additional render delay of the sink in nanoseconds&quot;, 0, G_MAXUINT64,
 503           DEFAULT_RENDER_DELAY, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 504   /**
 505    * GstBaseSink:throttle-time:
 506    *
 507    * The time to insert between buffers. This property can be used to control
 508    * the maximum amount of buffers per second to render. Setting this property
 509    * to a value bigger than 0 will make the sink create THROTTLE QoS events.
 510    */
 511   g_object_class_install_property (gobject_class, PROP_THROTTLE_TIME,
 512       g_param_spec_uint64 (&quot;throttle-time&quot;, &quot;Throttle time&quot;,
 513           &quot;The time to keep between rendered buffers (0 = disabled)&quot;, 0,
 514           G_MAXUINT64, DEFAULT_THROTTLE_TIME,
 515           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 516   /**
 517    * GstBaseSink:max-bitrate:
 518    *
 519    * Control the maximum amount of bits that will be rendered per second.
 520    * Setting this property to a value bigger than 0 will make the sink delay
 521    * rendering of the buffers when it would exceed to max-bitrate.
 522    *
 523    * Since: 1.2
 524    */
 525   g_object_class_install_property (gobject_class, PROP_MAX_BITRATE,
 526       g_param_spec_uint64 (&quot;max-bitrate&quot;, &quot;Max Bitrate&quot;,
 527           &quot;The maximum bits per second to render (0 = disabled)&quot;, 0,
 528           G_MAXUINT64, DEFAULT_MAX_BITRATE,
 529           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 530 
 531   gstelement_class-&gt;change_state =
 532       GST_DEBUG_FUNCPTR (gst_base_sink_change_state);
 533   gstelement_class-&gt;send_event = GST_DEBUG_FUNCPTR (gst_base_sink_send_event);
 534   gstelement_class-&gt;query = GST_DEBUG_FUNCPTR (default_element_query);
 535 
 536   klass-&gt;get_caps = GST_DEBUG_FUNCPTR (gst_base_sink_default_get_caps);
 537   klass-&gt;set_caps = GST_DEBUG_FUNCPTR (gst_base_sink_default_set_caps);
 538   klass-&gt;fixate = GST_DEBUG_FUNCPTR (gst_base_sink_default_fixate);
 539   klass-&gt;activate_pull =
 540       GST_DEBUG_FUNCPTR (gst_base_sink_default_activate_pull);
 541   klass-&gt;get_times = GST_DEBUG_FUNCPTR (gst_base_sink_default_get_times);
 542   klass-&gt;query = GST_DEBUG_FUNCPTR (gst_base_sink_default_query);
 543   klass-&gt;event = GST_DEBUG_FUNCPTR (gst_base_sink_default_event);
 544   klass-&gt;wait_event = GST_DEBUG_FUNCPTR (gst_base_sink_default_wait_event);
 545 
 546   /* Registering debug symbols for function pointers */
 547   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_fixate);
 548   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_pad_activate);
 549   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_pad_activate_mode);
 550   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_event);
 551   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_chain);
 552   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_chain_list);
 553   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_sink_query);
 554 }
 555 
 556 static GstCaps *
 557 gst_base_sink_query_caps (GstBaseSink * bsink, GstPad * pad, GstCaps * filter)
 558 {
 559   GstBaseSinkClass *bclass;
 560   GstCaps *caps = NULL;
 561   gboolean fixed;
 562 
 563   bclass = GST_BASE_SINK_GET_CLASS (bsink);
 564   fixed = GST_PAD_IS_FIXED_CAPS (pad);
 565 
 566   if (fixed || bsink-&gt;pad_mode == GST_PAD_MODE_PULL) {
 567     /* if we are operating in pull mode or fixed caps, we only accept the
 568      * currently negotiated caps */
 569     caps = gst_pad_get_current_caps (pad);
 570   }
 571   if (caps == NULL) {
 572     if (bclass-&gt;get_caps)
 573       caps = bclass-&gt;get_caps (bsink, filter);
 574 
 575     if (caps == NULL) {
 576       GstPadTemplate *pad_template;
 577 
 578       pad_template =
 579           gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass),
 580           &quot;sink&quot;);
 581       if (pad_template != NULL) {
 582         caps = gst_pad_template_get_caps (pad_template);
 583 
 584         if (filter) {
 585           GstCaps *intersection;
 586 
 587           intersection =
 588               gst_caps_intersect_full (filter, caps, GST_CAPS_INTERSECT_FIRST);
 589           gst_caps_unref (caps);
 590           caps = intersection;
 591         }
 592       }
 593     }
 594   }
 595 
 596   return caps;
 597 }
 598 
 599 static GstCaps *
 600 gst_base_sink_default_fixate (GstBaseSink * bsink, GstCaps * caps)
 601 {
 602   GST_DEBUG_OBJECT (bsink, &quot;using default caps fixate function&quot;);
 603   return gst_caps_fixate (caps);
 604 }
 605 
 606 static GstCaps *
 607 gst_base_sink_fixate (GstBaseSink * bsink, GstCaps * caps)
 608 {
 609   GstBaseSinkClass *bclass;
 610 
 611   bclass = GST_BASE_SINK_GET_CLASS (bsink);
 612 
 613   if (bclass-&gt;fixate)
 614     caps = bclass-&gt;fixate (bsink, caps);
 615 
 616   return caps;
 617 }
 618 
 619 static void
 620 gst_base_sink_init (GstBaseSink * basesink, gpointer g_class)
 621 {
 622   GstPadTemplate *pad_template;
 623   GstBaseSinkPrivate *priv;
 624 
 625   basesink-&gt;priv = priv = GST_BASE_SINK_GET_PRIVATE (basesink);
 626 
 627   pad_template =
 628       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (g_class), &quot;sink&quot;);
 629   g_return_if_fail (pad_template != NULL);
 630 
 631   basesink-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 632 
 633   gst_pad_set_activate_function (basesink-&gt;sinkpad, gst_base_sink_pad_activate);
 634   gst_pad_set_activatemode_function (basesink-&gt;sinkpad,
 635       gst_base_sink_pad_activate_mode);
 636   gst_pad_set_query_function (basesink-&gt;sinkpad, gst_base_sink_sink_query);
 637   gst_pad_set_event_function (basesink-&gt;sinkpad, gst_base_sink_event);
 638   gst_pad_set_chain_function (basesink-&gt;sinkpad, gst_base_sink_chain);
 639   gst_pad_set_chain_list_function (basesink-&gt;sinkpad, gst_base_sink_chain_list);
 640   gst_element_add_pad (GST_ELEMENT_CAST (basesink), basesink-&gt;sinkpad);
 641 
 642   basesink-&gt;pad_mode = GST_PAD_MODE_NONE;
 643   g_mutex_init (&amp;basesink-&gt;preroll_lock);
 644   g_cond_init (&amp;basesink-&gt;preroll_cond);
 645   priv-&gt;have_latency = FALSE;
 646 
 647   basesink-&gt;can_activate_push = DEFAULT_CAN_ACTIVATE_PUSH;
 648   basesink-&gt;can_activate_pull = DEFAULT_CAN_ACTIVATE_PULL;
 649 
 650   basesink-&gt;sync = DEFAULT_SYNC;
 651   basesink-&gt;max_lateness = DEFAULT_MAX_LATENESS;
 652   g_atomic_int_set (&amp;priv-&gt;qos_enabled, DEFAULT_QOS);
 653   priv-&gt;async_enabled = DEFAULT_ASYNC;
 654   priv-&gt;ts_offset = DEFAULT_TS_OFFSET;
 655   priv-&gt;render_delay = DEFAULT_RENDER_DELAY;
 656   priv-&gt;blocksize = DEFAULT_BLOCKSIZE;
 657   priv-&gt;cached_clock_id = NULL;
 658   g_atomic_int_set (&amp;priv-&gt;enable_last_sample, DEFAULT_ENABLE_LAST_SAMPLE);
 659   priv-&gt;throttle_time = DEFAULT_THROTTLE_TIME;
 660   priv-&gt;max_bitrate = DEFAULT_MAX_BITRATE;
 661 
 662   priv-&gt;drop_out_of_segment = DEFAULT_DROP_OUT_OF_SEGMENT;
 663 
 664   GST_OBJECT_FLAG_SET (basesink, GST_ELEMENT_FLAG_SINK);
 665 }
 666 
 667 static void
 668 gst_base_sink_finalize (GObject * object)
 669 {
 670   GstBaseSink *basesink;
 671 
 672   basesink = GST_BASE_SINK (object);
 673 
 674   g_mutex_clear (&amp;basesink-&gt;preroll_lock);
 675   g_cond_clear (&amp;basesink-&gt;preroll_cond);
 676 
 677   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 678 }
 679 
 680 /**
 681  * gst_base_sink_set_sync:
 682  * @sink: the sink
 683  * @sync: the new sync value.
 684  *
 685  * Configures @sink to synchronize on the clock or not. When
 686  * @sync is %FALSE, incoming samples will be played as fast as
 687  * possible. If @sync is %TRUE, the timestamps of the incoming
 688  * buffers will be used to schedule the exact render time of its
 689  * contents.
 690  */
 691 void
 692 gst_base_sink_set_sync (GstBaseSink * sink, gboolean sync)
 693 {
 694   g_return_if_fail (GST_IS_BASE_SINK (sink));
 695 
 696   GST_OBJECT_LOCK (sink);
 697   sink-&gt;sync = sync;
 698   GST_OBJECT_UNLOCK (sink);
 699 }
 700 
 701 /**
 702  * gst_base_sink_get_sync:
 703  * @sink: the sink
 704  *
 705  * Checks if @sink is currently configured to synchronize against the
 706  * clock.
 707  *
 708  * Returns: %TRUE if the sink is configured to synchronize against the clock.
 709  */
 710 gboolean
 711 gst_base_sink_get_sync (GstBaseSink * sink)
 712 {
 713   gboolean res;
 714 
 715   g_return_val_if_fail (GST_IS_BASE_SINK (sink), FALSE);
 716 
 717   GST_OBJECT_LOCK (sink);
 718   res = sink-&gt;sync;
 719   GST_OBJECT_UNLOCK (sink);
 720 
 721   return res;
 722 }
 723 
 724 /**
 725  * gst_base_sink_set_drop_out_of_segment:
 726  * @sink: the sink
 727  * @drop_out_of_segment: drop buffers outside the segment
 728  *
 729  * Configure @sink to drop buffers which are outside the current segment
 730  *
 731  * Since: 1.12
 732  */
 733 void
 734 gst_base_sink_set_drop_out_of_segment (GstBaseSink * sink,
 735     gboolean drop_out_of_segment)
 736 {
 737   GstBaseSinkPrivate *priv;
 738 
 739   g_return_if_fail (GST_IS_BASE_SINK (sink));
 740 
 741   priv = GST_BASE_SINK_GET_PRIVATE (sink);
 742 
 743   GST_OBJECT_LOCK (sink);
 744   priv-&gt;drop_out_of_segment = drop_out_of_segment;
 745   GST_OBJECT_UNLOCK (sink);
 746 
 747 }
 748 
 749 /**
 750  * gst_base_sink_get_drop_out_of_segment:
 751  * @sink: the sink
 752  *
 753  * Checks if @sink is currently configured to drop buffers which are outside
 754  * the current segment
 755  *
 756  * Returns: %TRUE if the sink is configured to drop buffers outside the
 757  * current segment.
 758  *
 759  * Since: 1.12
 760  */
 761 gboolean
 762 gst_base_sink_get_drop_out_of_segment (GstBaseSink * sink)
 763 {
 764   GstBaseSinkPrivate *priv;
 765   gboolean res;
 766 
 767   g_return_val_if_fail (GST_IS_BASE_SINK (sink), FALSE);
 768 
 769   priv = GST_BASE_SINK_GET_PRIVATE (sink);
 770 
 771   GST_OBJECT_LOCK (sink);
 772   res = priv-&gt;drop_out_of_segment;
 773   GST_OBJECT_UNLOCK (sink);
 774 
 775   return res;
 776 }
 777 
 778 /**
 779  * gst_base_sink_set_max_lateness:
 780  * @sink: the sink
 781  * @max_lateness: the new max lateness value.
 782  *
 783  * Sets the new max lateness value to @max_lateness. This value is
 784  * used to decide if a buffer should be dropped or not based on the
 785  * buffer timestamp and the current clock time. A value of -1 means
 786  * an unlimited time.
 787  */
 788 void
 789 gst_base_sink_set_max_lateness (GstBaseSink * sink, gint64 max_lateness)
 790 {
 791   g_return_if_fail (GST_IS_BASE_SINK (sink));
 792 
 793   GST_OBJECT_LOCK (sink);
 794   sink-&gt;max_lateness = max_lateness;
 795   GST_OBJECT_UNLOCK (sink);
 796 }
 797 
 798 /**
 799  * gst_base_sink_get_max_lateness:
 800  * @sink: the sink
 801  *
 802  * Gets the max lateness value. See gst_base_sink_set_max_lateness() for
 803  * more details.
 804  *
 805  * Returns: The maximum time in nanoseconds that a buffer can be late
 806  * before it is dropped and not rendered. A value of -1 means an
 807  * unlimited time.
 808  */
 809 gint64
 810 gst_base_sink_get_max_lateness (GstBaseSink * sink)
 811 {
 812   gint64 res;
 813 
 814   g_return_val_if_fail (GST_IS_BASE_SINK (sink), -1);
 815 
 816   GST_OBJECT_LOCK (sink);
 817   res = sink-&gt;max_lateness;
 818   GST_OBJECT_UNLOCK (sink);
 819 
 820   return res;
 821 }
 822 
 823 /**
 824  * gst_base_sink_set_qos_enabled:
 825  * @sink: the sink
 826  * @enabled: the new qos value.
 827  *
 828  * Configures @sink to send Quality-of-Service events upstream.
 829  */
 830 void
 831 gst_base_sink_set_qos_enabled (GstBaseSink * sink, gboolean enabled)
 832 {
 833   g_return_if_fail (GST_IS_BASE_SINK (sink));
 834 
 835   g_atomic_int_set (&amp;sink-&gt;priv-&gt;qos_enabled, enabled);
 836 }
 837 
 838 /**
 839  * gst_base_sink_is_qos_enabled:
 840  * @sink: the sink
 841  *
 842  * Checks if @sink is currently configured to send Quality-of-Service events
 843  * upstream.
 844  *
 845  * Returns: %TRUE if the sink is configured to perform Quality-of-Service.
 846  */
 847 gboolean
 848 gst_base_sink_is_qos_enabled (GstBaseSink * sink)
 849 {
 850   gboolean res;
 851 
 852   g_return_val_if_fail (GST_IS_BASE_SINK (sink), FALSE);
 853 
 854   res = g_atomic_int_get (&amp;sink-&gt;priv-&gt;qos_enabled);
 855 
 856   return res;
 857 }
 858 
 859 /**
 860  * gst_base_sink_set_async_enabled:
 861  * @sink: the sink
 862  * @enabled: the new async value.
 863  *
 864  * Configures @sink to perform all state changes asynchronously. When async is
 865  * disabled, the sink will immediately go to PAUSED instead of waiting for a
 866  * preroll buffer. This feature is useful if the sink does not synchronize
 867  * against the clock or when it is dealing with sparse streams.
 868  */
 869 void
 870 gst_base_sink_set_async_enabled (GstBaseSink * sink, gboolean enabled)
 871 {
 872   g_return_if_fail (GST_IS_BASE_SINK (sink));
 873 
 874   GST_BASE_SINK_PREROLL_LOCK (sink);
 875   g_atomic_int_set (&amp;sink-&gt;priv-&gt;async_enabled, enabled);
 876   GST_LOG_OBJECT (sink, &quot;set async enabled to %d&quot;, enabled);
 877   GST_BASE_SINK_PREROLL_UNLOCK (sink);
 878 }
 879 
 880 /**
 881  * gst_base_sink_is_async_enabled:
 882  * @sink: the sink
 883  *
 884  * Checks if @sink is currently configured to perform asynchronous state
 885  * changes to PAUSED.
 886  *
 887  * Returns: %TRUE if the sink is configured to perform asynchronous state
 888  * changes.
 889  */
 890 gboolean
 891 gst_base_sink_is_async_enabled (GstBaseSink * sink)
 892 {
 893   gboolean res;
 894 
 895   g_return_val_if_fail (GST_IS_BASE_SINK (sink), FALSE);
 896 
 897   res = g_atomic_int_get (&amp;sink-&gt;priv-&gt;async_enabled);
 898 
 899   return res;
 900 }
 901 
 902 /**
 903  * gst_base_sink_set_ts_offset:
 904  * @sink: the sink
 905  * @offset: the new offset
 906  *
 907  * Adjust the synchronisation of @sink with @offset. A negative value will
 908  * render buffers earlier than their timestamp. A positive value will delay
 909  * rendering. This function can be used to fix playback of badly timestamped
 910  * buffers.
 911  */
 912 void
 913 gst_base_sink_set_ts_offset (GstBaseSink * sink, GstClockTimeDiff offset)
 914 {
 915   g_return_if_fail (GST_IS_BASE_SINK (sink));
 916 
 917   GST_OBJECT_LOCK (sink);
 918   sink-&gt;priv-&gt;ts_offset = offset;
 919   GST_LOG_OBJECT (sink, &quot;set time offset to %&quot; G_GINT64_FORMAT, offset);
 920   GST_OBJECT_UNLOCK (sink);
 921 }
 922 
 923 /**
 924  * gst_base_sink_get_ts_offset:
 925  * @sink: the sink
 926  *
 927  * Get the synchronisation offset of @sink.
 928  *
 929  * Returns: The synchronisation offset.
 930  */
 931 GstClockTimeDiff
 932 gst_base_sink_get_ts_offset (GstBaseSink * sink)
 933 {
 934   GstClockTimeDiff res;
 935 
 936   g_return_val_if_fail (GST_IS_BASE_SINK (sink), 0);
 937 
 938   GST_OBJECT_LOCK (sink);
 939   res = sink-&gt;priv-&gt;ts_offset;
 940   GST_OBJECT_UNLOCK (sink);
 941 
 942   return res;
 943 }
 944 
 945 /**
 946  * gst_base_sink_get_last_sample:
 947  * @sink: the sink
 948  *
 949  * Get the last sample that arrived in the sink and was used for preroll or for
 950  * rendering. This property can be used to generate thumbnails.
 951  *
 952  * The #GstCaps on the sample can be used to determine the type of the buffer.
 953  *
 954  * Free-function: gst_sample_unref
 955  *
 956  * Returns: (transfer full) (nullable): a #GstSample. gst_sample_unref() after
 957  *     usage.  This function returns %NULL when no buffer has arrived in the
 958  *     sink yet or when the sink is not in PAUSED or PLAYING.
 959  */
 960 GstSample *
 961 gst_base_sink_get_last_sample (GstBaseSink * sink)
 962 {
 963   GstSample *res = NULL;
 964 
 965   g_return_val_if_fail (GST_IS_BASE_SINK (sink), NULL);
 966 
 967   GST_OBJECT_LOCK (sink);
 968   if (sink-&gt;priv-&gt;last_buffer_list) {
 969     GstBuffer *first_buffer = NULL;
 970 
 971     /* Set the first buffer in the list to last sample&#39;s buffer */
 972     first_buffer = gst_buffer_list_get (sink-&gt;priv-&gt;last_buffer_list, 0);
 973     res =
 974         gst_sample_new (first_buffer, sink-&gt;priv-&gt;last_caps, &amp;sink-&gt;segment,
 975         NULL);
 976     gst_sample_set_buffer_list (res, sink-&gt;priv-&gt;last_buffer_list);
 977   } else if (sink-&gt;priv-&gt;last_buffer) {
 978     res = gst_sample_new (sink-&gt;priv-&gt;last_buffer,
 979         sink-&gt;priv-&gt;last_caps, &amp;sink-&gt;segment, NULL);
 980   }
 981   GST_OBJECT_UNLOCK (sink);
 982 
 983   return res;
 984 }
 985 
 986 /* with OBJECT_LOCK */
 987 static void
 988 gst_base_sink_set_last_buffer_unlocked (GstBaseSink * sink, GstBuffer * buffer)
 989 {
 990   GstBuffer *old;
 991 
 992   old = sink-&gt;priv-&gt;last_buffer;
 993   if (G_LIKELY (old != buffer)) {
 994     GST_DEBUG_OBJECT (sink, &quot;setting last buffer to %p&quot;, buffer);
 995     if (G_LIKELY (buffer))
 996       gst_buffer_ref (buffer);
 997     sink-&gt;priv-&gt;last_buffer = buffer;
 998     if (buffer)
 999       /* copy over the caps */
1000       gst_caps_replace (&amp;sink-&gt;priv-&gt;last_caps, sink-&gt;priv-&gt;caps);
1001     else
1002       gst_caps_replace (&amp;sink-&gt;priv-&gt;last_caps, NULL);
1003   } else {
1004     old = NULL;
1005   }
1006   /* avoid unreffing with the lock because cleanup code might want to take the
1007    * lock too */
1008   if (G_LIKELY (old)) {
1009     GST_OBJECT_UNLOCK (sink);
1010     gst_buffer_unref (old);
1011     GST_OBJECT_LOCK (sink);
1012   }
1013 }
1014 
1015 /* with OBJECT_LOCK */
1016 static void
1017 gst_base_sink_set_last_buffer_list_unlocked (GstBaseSink * sink,
1018     GstBufferList * buffer_list)
1019 {
1020   GstBufferList *old;
1021 
1022   old = sink-&gt;priv-&gt;last_buffer_list;
1023   if (G_LIKELY (old != buffer_list)) {
1024     GST_DEBUG_OBJECT (sink, &quot;setting last buffer list to %p&quot;, buffer_list);
1025     if (G_LIKELY (buffer_list))
1026       gst_mini_object_ref (GST_MINI_OBJECT_CAST (buffer_list));
1027     sink-&gt;priv-&gt;last_buffer_list = buffer_list;
1028   } else {
1029     old = NULL;
1030   }
1031 
1032   /* avoid unreffing with the lock because cleanup code might want to take the
1033    * lock too */
1034   if (G_LIKELY (old)) {
1035     GST_OBJECT_UNLOCK (sink);
1036     gst_mini_object_unref (GST_MINI_OBJECT_CAST (old));
1037     GST_OBJECT_LOCK (sink);
1038   }
1039 }
1040 
1041 static void
1042 gst_base_sink_set_last_buffer (GstBaseSink * sink, GstBuffer * buffer)
1043 {
1044   if (!g_atomic_int_get (&amp;sink-&gt;priv-&gt;enable_last_sample))
1045     return;
1046 
1047   GST_OBJECT_LOCK (sink);
1048   gst_base_sink_set_last_buffer_unlocked (sink, buffer);
1049   GST_OBJECT_UNLOCK (sink);
1050 }
1051 
1052 static void
1053 gst_base_sink_set_last_buffer_list (GstBaseSink * sink,
1054     GstBufferList * buffer_list)
1055 {
1056   if (!g_atomic_int_get (&amp;sink-&gt;priv-&gt;enable_last_sample))
1057     return;
1058 
1059   GST_OBJECT_LOCK (sink);
1060   gst_base_sink_set_last_buffer_list_unlocked (sink, buffer_list);
1061   GST_OBJECT_UNLOCK (sink);
1062 }
1063 
1064 /**
1065  * gst_base_sink_set_last_sample_enabled:
1066  * @sink: the sink
1067  * @enabled: the new enable-last-sample value.
1068  *
1069  * Configures @sink to store the last received sample in the last-sample
1070  * property.
1071  */
1072 void
1073 gst_base_sink_set_last_sample_enabled (GstBaseSink * sink, gboolean enabled)
1074 {
1075   g_return_if_fail (GST_IS_BASE_SINK (sink));
1076 
1077   /* Only take lock if we change the value */
1078   if (g_atomic_int_compare_and_exchange (&amp;sink-&gt;priv-&gt;enable_last_sample,
1079           !enabled, enabled) &amp;&amp; !enabled) {
1080     GST_OBJECT_LOCK (sink);
1081     gst_base_sink_set_last_buffer_unlocked (sink, NULL);
1082     gst_base_sink_set_last_buffer_list_unlocked (sink, NULL);
1083     GST_OBJECT_UNLOCK (sink);
1084   }
1085 }
1086 
1087 /**
1088  * gst_base_sink_is_last_sample_enabled:
1089  * @sink: the sink
1090  *
1091  * Checks if @sink is currently configured to store the last received sample in
1092  * the last-sample property.
1093  *
1094  * Returns: %TRUE if the sink is configured to store the last received sample.
1095  */
1096 gboolean
1097 gst_base_sink_is_last_sample_enabled (GstBaseSink * sink)
1098 {
1099   g_return_val_if_fail (GST_IS_BASE_SINK (sink), FALSE);
1100 
1101   return g_atomic_int_get (&amp;sink-&gt;priv-&gt;enable_last_sample);
1102 }
1103 
1104 /**
1105  * gst_base_sink_get_latency:
1106  * @sink: the sink
1107  *
1108  * Get the currently configured latency.
1109  *
1110  * Returns: The configured latency.
1111  */
1112 GstClockTime
1113 gst_base_sink_get_latency (GstBaseSink * sink)
1114 {
1115   GstClockTime res;
1116 
1117   GST_OBJECT_LOCK (sink);
1118   res = sink-&gt;priv-&gt;latency;
1119   GST_OBJECT_UNLOCK (sink);
1120 
1121   return res;
1122 }
1123 
1124 /**
1125  * gst_base_sink_query_latency:
1126  * @sink: the sink
1127  * @live: (out) (allow-none): if the sink is live
1128  * @upstream_live: (out) (allow-none): if an upstream element is live
1129  * @min_latency: (out) (allow-none): the min latency of the upstream elements
1130  * @max_latency: (out) (allow-none): the max latency of the upstream elements
1131  *
1132  * Query the sink for the latency parameters. The latency will be queried from
1133  * the upstream elements. @live will be %TRUE if @sink is configured to
1134  * synchronize against the clock. @upstream_live will be %TRUE if an upstream
1135  * element is live.
1136  *
1137  * If both @live and @upstream_live are %TRUE, the sink will want to compensate
1138  * for the latency introduced by the upstream elements by setting the
1139  * @min_latency to a strictly positive value.
1140  *
1141  * This function is mostly used by subclasses.
1142  *
1143  * Returns: %TRUE if the query succeeded.
1144  */
1145 gboolean
1146 gst_base_sink_query_latency (GstBaseSink * sink, gboolean * live,
1147     gboolean * upstream_live, GstClockTime * min_latency,
1148     GstClockTime * max_latency)
1149 {
1150   gboolean l, us_live, res, have_latency;
1151   GstClockTime min, max, render_delay;
1152   GstQuery *query;
1153   GstClockTime us_min, us_max;
1154 
1155   /* we are live when we sync to the clock */
1156   GST_OBJECT_LOCK (sink);
1157   l = sink-&gt;sync;
1158   have_latency = sink-&gt;priv-&gt;have_latency;
1159   render_delay = sink-&gt;priv-&gt;render_delay;
1160   GST_OBJECT_UNLOCK (sink);
1161 
1162   /* assume no latency */
1163   min = 0;
1164   max = -1;
1165   us_live = FALSE;
1166 
1167   if (have_latency) {
1168     GST_DEBUG_OBJECT (sink, &quot;we are ready for LATENCY query&quot;);
1169     /* we are ready for a latency query this is when we preroll or when we are
1170      * not async. */
1171     query = gst_query_new_latency ();
1172 
1173     /* ask the peer for the latency */
1174     if ((res = gst_pad_peer_query (sink-&gt;sinkpad, query))) {
1175       /* get upstream min and max latency */
1176       gst_query_parse_latency (query, &amp;us_live, &amp;us_min, &amp;us_max);
1177 
1178       if (us_live) {
1179         /* upstream live, use its latency, subclasses should use these
1180          * values to create the complete latency. */
1181         min = us_min;
1182         max = us_max;
1183       }
1184       if (l) {
1185         /* we need to add the render delay if we are live */
1186         min += render_delay;
1187         if (max != -1)
1188           max += render_delay;
1189       }
1190     }
1191     gst_query_unref (query);
1192   } else {
1193     GST_DEBUG_OBJECT (sink, &quot;we are not yet ready for LATENCY query&quot;);
1194     res = FALSE;
1195   }
1196 
1197   /* not live, we tried to do the query, if it failed we return TRUE anyway */
1198   if (!res) {
1199     if (!l) {
1200       res = TRUE;
1201       GST_DEBUG_OBJECT (sink, &quot;latency query failed but we are not live&quot;);
1202     } else {
1203       GST_DEBUG_OBJECT (sink, &quot;latency query failed and we are live&quot;);
1204     }
1205   }
1206 
1207   if (res) {
1208     GST_DEBUG_OBJECT (sink, &quot;latency query: live: %d, have_latency %d,&quot;
1209         &quot; upstream: %d, min %&quot; GST_TIME_FORMAT &quot;, max %&quot; GST_TIME_FORMAT, l,
1210         have_latency, us_live, GST_TIME_ARGS (min), GST_TIME_ARGS (max));
1211 
1212     if (live)
1213       *live = l;
1214     if (upstream_live)
1215       *upstream_live = us_live;
1216     if (min_latency)
1217       *min_latency = min;
1218     if (max_latency)
1219       *max_latency = max;
1220   }
1221   return res;
1222 }
1223 
1224 /**
1225  * gst_base_sink_set_render_delay:
1226  * @sink: a #GstBaseSink
1227  * @delay: the new delay
1228  *
1229  * Set the render delay in @sink to @delay. The render delay is the time
1230  * between actual rendering of a buffer and its synchronisation time. Some
1231  * devices might delay media rendering which can be compensated for with this
1232  * function.
1233  *
1234  * After calling this function, this sink will report additional latency and
1235  * other sinks will adjust their latency to delay the rendering of their media.
1236  *
1237  * This function is usually called by subclasses.
1238  */
1239 void
1240 gst_base_sink_set_render_delay (GstBaseSink * sink, GstClockTime delay)
1241 {
1242   GstClockTime old_render_delay;
1243 
1244   g_return_if_fail (GST_IS_BASE_SINK (sink));
1245 
1246   GST_OBJECT_LOCK (sink);
1247   old_render_delay = sink-&gt;priv-&gt;render_delay;
1248   sink-&gt;priv-&gt;render_delay = delay;
1249   GST_LOG_OBJECT (sink, &quot;set render delay to %&quot; GST_TIME_FORMAT,
1250       GST_TIME_ARGS (delay));
1251   GST_OBJECT_UNLOCK (sink);
1252 
1253   if (delay != old_render_delay) {
1254     GST_DEBUG_OBJECT (sink, &quot;posting latency changed&quot;);
1255     gst_element_post_message (GST_ELEMENT_CAST (sink),
1256         gst_message_new_latency (GST_OBJECT_CAST (sink)));
1257   }
1258 }
1259 
1260 /**
1261  * gst_base_sink_get_render_delay:
1262  * @sink: a #GstBaseSink
1263  *
1264  * Get the render delay of @sink. see gst_base_sink_set_render_delay() for more
1265  * information about the render delay.
1266  *
1267  * Returns: the render delay of @sink.
1268  */
1269 GstClockTime
1270 gst_base_sink_get_render_delay (GstBaseSink * sink)
1271 {
1272   GstClockTimeDiff res;
1273 
1274   g_return_val_if_fail (GST_IS_BASE_SINK (sink), 0);
1275 
1276   GST_OBJECT_LOCK (sink);
1277   res = sink-&gt;priv-&gt;render_delay;
1278   GST_OBJECT_UNLOCK (sink);
1279 
1280   return res;
1281 }
1282 
1283 /**
1284  * gst_base_sink_set_blocksize:
1285  * @sink: a #GstBaseSink
1286  * @blocksize: the blocksize in bytes
1287  *
1288  * Set the number of bytes that the sink will pull when it is operating in pull
1289  * mode.
1290  */
1291 /* FIXME 2.0: blocksize property should be int, otherwise min&gt;max.. */
1292 void
1293 gst_base_sink_set_blocksize (GstBaseSink * sink, guint blocksize)
1294 {
1295   g_return_if_fail (GST_IS_BASE_SINK (sink));
1296 
1297   GST_OBJECT_LOCK (sink);
1298   sink-&gt;priv-&gt;blocksize = blocksize;
1299   GST_LOG_OBJECT (sink, &quot;set blocksize to %u&quot;, blocksize);
1300   GST_OBJECT_UNLOCK (sink);
1301 }
1302 
1303 /**
1304  * gst_base_sink_get_blocksize:
1305  * @sink: a #GstBaseSink
1306  *
1307  * Get the number of bytes that the sink will pull when it is operating in pull
1308  * mode.
1309  *
1310  * Returns: the number of bytes @sink will pull in pull mode.
1311  */
1312 /* FIXME 2.0: blocksize property should be int, otherwise min&gt;max.. */
1313 guint
1314 gst_base_sink_get_blocksize (GstBaseSink * sink)
1315 {
1316   guint res;
1317 
1318   g_return_val_if_fail (GST_IS_BASE_SINK (sink), 0);
1319 
1320   GST_OBJECT_LOCK (sink);
1321   res = sink-&gt;priv-&gt;blocksize;
1322   GST_OBJECT_UNLOCK (sink);
1323 
1324   return res;
1325 }
1326 
1327 /**
1328  * gst_base_sink_set_throttle_time:
1329  * @sink: a #GstBaseSink
1330  * @throttle: the throttle time in nanoseconds
1331  *
1332  * Set the time that will be inserted between rendered buffers. This
1333  * can be used to control the maximum buffers per second that the sink
1334  * will render.
1335  */
1336 void
1337 gst_base_sink_set_throttle_time (GstBaseSink * sink, guint64 throttle)
1338 {
1339   g_return_if_fail (GST_IS_BASE_SINK (sink));
1340 
1341   GST_OBJECT_LOCK (sink);
1342   sink-&gt;priv-&gt;throttle_time = throttle;
1343   GST_LOG_OBJECT (sink, &quot;set throttle_time to %&quot; G_GUINT64_FORMAT, throttle);
1344   GST_OBJECT_UNLOCK (sink);
1345 }
1346 
1347 /**
1348  * gst_base_sink_get_throttle_time:
1349  * @sink: a #GstBaseSink
1350  *
1351  * Get the time that will be inserted between frames to control the
1352  * maximum buffers per second.
1353  *
1354  * Returns: the number of nanoseconds @sink will put between frames.
1355  */
1356 guint64
1357 gst_base_sink_get_throttle_time (GstBaseSink * sink)
1358 {
1359   guint64 res;
1360 
1361   g_return_val_if_fail (GST_IS_BASE_SINK (sink), 0);
1362 
1363   GST_OBJECT_LOCK (sink);
1364   res = sink-&gt;priv-&gt;throttle_time;
1365   GST_OBJECT_UNLOCK (sink);
1366 
1367   return res;
1368 }
1369 
1370 /**
1371  * gst_base_sink_set_max_bitrate:
1372  * @sink: a #GstBaseSink
1373  * @max_bitrate: the max_bitrate in bits per second
1374  *
1375  * Set the maximum amount of bits per second that the sink will render.
1376  *
1377  * Since: 1.2
1378  */
1379 void
1380 gst_base_sink_set_max_bitrate (GstBaseSink * sink, guint64 max_bitrate)
1381 {
1382   g_return_if_fail (GST_IS_BASE_SINK (sink));
1383 
1384   GST_OBJECT_LOCK (sink);
1385   sink-&gt;priv-&gt;max_bitrate = max_bitrate;
1386   GST_LOG_OBJECT (sink, &quot;set max_bitrate to %&quot; G_GUINT64_FORMAT, max_bitrate);
1387   GST_OBJECT_UNLOCK (sink);
1388 }
1389 
1390 /**
1391  * gst_base_sink_get_max_bitrate:
1392  * @sink: a #GstBaseSink
1393  *
1394  * Get the maximum amount of bits per second that the sink will render.
1395  *
1396  * Returns: the maximum number of bits per second @sink will render.
1397  *
1398  * Since: 1.2
1399  */
1400 guint64
1401 gst_base_sink_get_max_bitrate (GstBaseSink * sink)
1402 {
1403   guint64 res;
1404 
1405   g_return_val_if_fail (GST_IS_BASE_SINK (sink), 0);
1406 
1407   GST_OBJECT_LOCK (sink);
1408   res = sink-&gt;priv-&gt;max_bitrate;
1409   GST_OBJECT_UNLOCK (sink);
1410 
1411   return res;
1412 }
1413 
1414 static void
1415 gst_base_sink_set_property (GObject * object, guint prop_id,
1416     const GValue * value, GParamSpec * pspec)
1417 {
1418   GstBaseSink *sink = GST_BASE_SINK (object);
1419 
1420   switch (prop_id) {
1421     case PROP_SYNC:
1422       gst_base_sink_set_sync (sink, g_value_get_boolean (value));
1423       break;
1424     case PROP_MAX_LATENESS:
1425       gst_base_sink_set_max_lateness (sink, g_value_get_int64 (value));
1426       break;
1427     case PROP_QOS:
1428       gst_base_sink_set_qos_enabled (sink, g_value_get_boolean (value));
1429       break;
1430     case PROP_ASYNC:
1431       gst_base_sink_set_async_enabled (sink, g_value_get_boolean (value));
1432       break;
1433     case PROP_TS_OFFSET:
1434       gst_base_sink_set_ts_offset (sink, g_value_get_int64 (value));
1435       break;
1436     case PROP_BLOCKSIZE:
1437       gst_base_sink_set_blocksize (sink, g_value_get_uint (value));
1438       break;
1439     case PROP_RENDER_DELAY:
1440       gst_base_sink_set_render_delay (sink, g_value_get_uint64 (value));
1441       break;
1442     case PROP_ENABLE_LAST_SAMPLE:
1443       gst_base_sink_set_last_sample_enabled (sink, g_value_get_boolean (value));
1444       break;
1445     case PROP_THROTTLE_TIME:
1446       gst_base_sink_set_throttle_time (sink, g_value_get_uint64 (value));
1447       break;
1448     case PROP_MAX_BITRATE:
1449       gst_base_sink_set_max_bitrate (sink, g_value_get_uint64 (value));
1450       break;
1451     default:
1452       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
1453       break;
1454   }
1455 }
1456 
1457 static void
1458 gst_base_sink_get_property (GObject * object, guint prop_id, GValue * value,
1459     GParamSpec * pspec)
1460 {
1461   GstBaseSink *sink = GST_BASE_SINK (object);
1462 
1463   switch (prop_id) {
1464     case PROP_SYNC:
1465       g_value_set_boolean (value, gst_base_sink_get_sync (sink));
1466       break;
1467     case PROP_MAX_LATENESS:
1468       g_value_set_int64 (value, gst_base_sink_get_max_lateness (sink));
1469       break;
1470     case PROP_QOS:
1471       g_value_set_boolean (value, gst_base_sink_is_qos_enabled (sink));
1472       break;
1473     case PROP_ASYNC:
1474       g_value_set_boolean (value, gst_base_sink_is_async_enabled (sink));
1475       break;
1476     case PROP_TS_OFFSET:
1477       g_value_set_int64 (value, gst_base_sink_get_ts_offset (sink));
1478       break;
1479     case PROP_LAST_SAMPLE:
1480       gst_value_take_sample (value, gst_base_sink_get_last_sample (sink));
1481       break;
1482     case PROP_ENABLE_LAST_SAMPLE:
1483       g_value_set_boolean (value, gst_base_sink_is_last_sample_enabled (sink));
1484       break;
1485     case PROP_BLOCKSIZE:
1486       g_value_set_uint (value, gst_base_sink_get_blocksize (sink));
1487       break;
1488     case PROP_RENDER_DELAY:
1489       g_value_set_uint64 (value, gst_base_sink_get_render_delay (sink));
1490       break;
1491     case PROP_THROTTLE_TIME:
1492       g_value_set_uint64 (value, gst_base_sink_get_throttle_time (sink));
1493       break;
1494     case PROP_MAX_BITRATE:
1495       g_value_set_uint64 (value, gst_base_sink_get_max_bitrate (sink));
1496       break;
1497     default:
1498       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
1499       break;
1500   }
1501 }
1502 
1503 
1504 static GstCaps *
1505 gst_base_sink_default_get_caps (GstBaseSink * sink, GstCaps * filter)
1506 {
1507   return NULL;
1508 }
1509 
1510 static gboolean
1511 gst_base_sink_default_set_caps (GstBaseSink * sink, GstCaps * caps)
1512 {
1513   return TRUE;
1514 }
1515 
1516 /* with PREROLL_LOCK, STREAM_LOCK */
1517 static gboolean
1518 gst_base_sink_commit_state (GstBaseSink * basesink)
1519 {
1520   /* commit state and proceed to next pending state */
1521   GstState current, next, pending, post_pending;
1522   gboolean post_paused = FALSE;
1523   gboolean post_async_done = FALSE;
1524   gboolean post_playing = FALSE;
1525 
1526   /* we are certainly not playing async anymore now */
1527   basesink-&gt;playing_async = FALSE;
1528 
1529   GST_OBJECT_LOCK (basesink);
1530   current = GST_STATE (basesink);
1531   next = GST_STATE_NEXT (basesink);
1532   pending = GST_STATE_PENDING (basesink);
1533   post_pending = pending;
1534 
1535   switch (pending) {
1536     case GST_STATE_PLAYING:
1537     {
1538       GST_DEBUG_OBJECT (basesink, &quot;commiting state to PLAYING&quot;);
1539 
1540       basesink-&gt;need_preroll = FALSE;
1541       post_async_done = TRUE;
1542       basesink-&gt;priv-&gt;commited = TRUE;
1543       post_playing = TRUE;
1544       /* post PAUSED too when we were READY */
1545       if (current == GST_STATE_READY) {
1546         post_paused = TRUE;
1547       }
1548       break;
1549     }
1550     case GST_STATE_PAUSED:
1551       GST_DEBUG_OBJECT (basesink, &quot;commiting state to PAUSED&quot;);
1552       post_paused = TRUE;
1553       post_async_done = TRUE;
1554       basesink-&gt;priv-&gt;commited = TRUE;
1555       post_pending = GST_STATE_VOID_PENDING;
1556       break;
1557     case GST_STATE_READY:
1558     case GST_STATE_NULL:
1559       goto stopping;
1560     case GST_STATE_VOID_PENDING:
1561       goto nothing_pending;
1562     default:
1563       break;
1564   }
1565 
1566   /* we can report latency queries now */
1567   basesink-&gt;priv-&gt;have_latency = TRUE;
1568 
1569   GST_STATE (basesink) = pending;
1570   GST_STATE_NEXT (basesink) = GST_STATE_VOID_PENDING;
1571   GST_STATE_PENDING (basesink) = GST_STATE_VOID_PENDING;
1572   GST_STATE_RETURN (basesink) = GST_STATE_CHANGE_SUCCESS;
1573   GST_OBJECT_UNLOCK (basesink);
1574 
1575   if (post_paused) {
1576     GST_DEBUG_OBJECT (basesink, &quot;posting PAUSED state change message&quot;);
1577     gst_element_post_message (GST_ELEMENT_CAST (basesink),
1578         gst_message_new_state_changed (GST_OBJECT_CAST (basesink),
1579             current, next, post_pending));
1580   }
1581   if (post_async_done) {
1582     GST_DEBUG_OBJECT (basesink, &quot;posting async-done message&quot;);
1583     gst_element_post_message (GST_ELEMENT_CAST (basesink),
1584         gst_message_new_async_done (GST_OBJECT_CAST (basesink),
1585             GST_CLOCK_TIME_NONE));
1586   }
1587   if (post_playing) {
1588     if (post_paused) {
1589       GstElementClass *klass;
1590 
1591       klass = GST_ELEMENT_GET_CLASS (basesink);
1592       basesink-&gt;have_preroll = TRUE;
1593       /* after releasing this lock, the state change function
1594        * can execute concurrently with this thread. There is nothing we do to
1595        * prevent this for now. subclasses should be prepared to handle it. */
1596       GST_BASE_SINK_PREROLL_UNLOCK (basesink);
1597 
1598       if (klass-&gt;change_state)
1599         klass-&gt;change_state (GST_ELEMENT_CAST (basesink),
1600             GST_STATE_CHANGE_PAUSED_TO_PLAYING);
1601 
1602       GST_BASE_SINK_PREROLL_LOCK (basesink);
1603       /* state change function could have been executed and we could be
1604        * flushing now */
1605       if (G_UNLIKELY (basesink-&gt;flushing))
1606         goto stopping_unlocked;
1607     }
1608     GST_DEBUG_OBJECT (basesink, &quot;posting PLAYING state change message&quot;);
1609     /* FIXME, we released the PREROLL lock above, it&#39;s possible that this
1610      * message is not correct anymore when the element went back to PAUSED */
1611     gst_element_post_message (GST_ELEMENT_CAST (basesink),
1612         gst_message_new_state_changed (GST_OBJECT_CAST (basesink),
1613             next, pending, GST_STATE_VOID_PENDING));
1614   }
1615 
1616   GST_STATE_BROADCAST (basesink);
1617 
1618   return TRUE;
1619 
1620 nothing_pending:
1621   {
1622     /* Depending on the state, set our vars. We get in this situation when the
1623      * state change function got a change to update the state vars before the
1624      * streaming thread did. This is fine but we need to make sure that we
1625      * update the need_preroll var since it was %TRUE when we got here and might
1626      * become %FALSE if we got to PLAYING. */
1627     GST_DEBUG_OBJECT (basesink, &quot;nothing to commit, now in %s&quot;,
1628         gst_element_state_get_name (current));
1629     switch (current) {
1630       case GST_STATE_PLAYING:
1631         basesink-&gt;need_preroll = FALSE;
1632         break;
1633       case GST_STATE_PAUSED:
1634         basesink-&gt;need_preroll = TRUE;
1635         break;
1636       default:
1637         basesink-&gt;need_preroll = FALSE;
1638         basesink-&gt;flushing = TRUE;
1639         break;
1640     }
1641     /* we can report latency queries now */
1642     basesink-&gt;priv-&gt;have_latency = TRUE;
1643     GST_OBJECT_UNLOCK (basesink);
1644     return TRUE;
1645   }
1646 stopping_unlocked:
1647   {
1648     GST_OBJECT_LOCK (basesink);
1649     goto stopping;
1650   }
1651 stopping:
1652   {
1653     /* app is going to READY */
1654     GST_DEBUG_OBJECT (basesink, &quot;stopping&quot;);
1655     basesink-&gt;need_preroll = FALSE;
1656     basesink-&gt;flushing = TRUE;
1657     GST_OBJECT_UNLOCK (basesink);
1658     return FALSE;
1659   }
1660 }
1661 
1662 static void
1663 start_stepping (GstBaseSink * sink, GstSegment * segment,
1664     GstStepInfo * pending, GstStepInfo * current)
1665 {
1666   gint64 end;
1667   GstMessage *message;
1668 
1669   GST_DEBUG_OBJECT (sink, &quot;update pending step&quot;);
1670 
1671   GST_OBJECT_LOCK (sink);
1672   memcpy (current, pending, sizeof (GstStepInfo));
1673   pending-&gt;valid = FALSE;
1674   GST_OBJECT_UNLOCK (sink);
1675 
1676   /* post message first */
1677   message =
1678       gst_message_new_step_start (GST_OBJECT (sink), TRUE, current-&gt;format,
1679       current-&gt;amount, current-&gt;rate, current-&gt;flush, current-&gt;intermediate);
1680   gst_message_set_seqnum (message, current-&gt;seqnum);
1681   gst_element_post_message (GST_ELEMENT (sink), message);
1682 
1683   /* get the running time of where we paused and remember it */
1684   current-&gt;start = gst_element_get_start_time (GST_ELEMENT_CAST (sink));
1685   gst_segment_set_running_time (segment, GST_FORMAT_TIME, current-&gt;start);
1686 
1687   /* set the new rate for the remainder of the segment */
1688   current-&gt;start_rate = segment-&gt;rate;
1689   segment-&gt;rate *= current-&gt;rate;
1690 
1691   /* save values */
1692   if (segment-&gt;rate &gt; 0.0)
1693     current-&gt;start_stop = segment-&gt;stop;
1694   else
1695     current-&gt;start_start = segment-&gt;start;
1696 
1697   if (current-&gt;format == GST_FORMAT_TIME) {
1698     /* calculate the running-time when the step operation should stop */
1699     if (current-&gt;amount != -1)
1700       end = current-&gt;start + current-&gt;amount;
1701     else
1702       end = -1;
1703 
1704     if (!current-&gt;flush) {
1705       gint64 position;
1706 
1707       /* update the segment clipping regions for non-flushing seeks */
1708       if (segment-&gt;rate &gt; 0.0) {
1709         if (end != -1)
1710           position =
1711               gst_segment_position_from_running_time (segment, GST_FORMAT_TIME,
1712               end);
1713         else
1714           position = segment-&gt;stop;
1715 
1716         segment-&gt;stop = position;
1717         segment-&gt;position = position;
1718       } else {
1719         if (end != -1)
1720           position =
1721               gst_segment_position_from_running_time (segment, GST_FORMAT_TIME,
1722               end);
1723         else
1724           position = segment-&gt;start;
1725 
1726         segment-&gt;time = position;
1727         segment-&gt;start = position;
1728         segment-&gt;position = position;
1729       }
1730     }
1731   }
1732 
1733   GST_DEBUG_OBJECT (sink, &quot;segment now %&quot; GST_SEGMENT_FORMAT, segment);
1734   GST_DEBUG_OBJECT (sink, &quot;step started at running_time %&quot; GST_TIME_FORMAT,
1735       GST_TIME_ARGS (current-&gt;start));
1736 
1737   GST_DEBUG_OBJECT (sink, &quot;step amount: %&quot; G_GUINT64_FORMAT &quot;, format: %s, &quot;
1738       &quot;rate: %f&quot;, current-&gt;amount, gst_format_get_name (current-&gt;format),
1739       current-&gt;rate);
1740 }
1741 
1742 static void
1743 stop_stepping (GstBaseSink * sink, GstSegment * segment,
1744     GstStepInfo * current, gint64 rstart, gint64 rstop, gboolean eos)
1745 {
1746   gint64 stop, position;
1747   GstMessage *message;
1748 
1749   GST_DEBUG_OBJECT (sink, &quot;step complete&quot;);
1750 
1751   if (segment-&gt;rate &gt; 0.0)
1752     stop = rstart;
1753   else
1754     stop = rstop;
1755 
1756   GST_DEBUG_OBJECT (sink,
1757       &quot;step stop at running_time %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (stop));
1758 
1759   if (stop == -1)
1760     current-&gt;duration = current-&gt;position;
1761   else
1762     current-&gt;duration = stop - current-&gt;start;
1763 
1764   GST_DEBUG_OBJECT (sink, &quot;step elapsed running_time %&quot; GST_TIME_FORMAT,
1765       GST_TIME_ARGS (current-&gt;duration));
1766 
1767   position = current-&gt;start + current-&gt;duration;
1768 
1769   /* now move the segment to the new running time */
1770   gst_segment_set_running_time (segment, GST_FORMAT_TIME, position);
1771 
1772   if (current-&gt;flush) {
1773     /* and remove the time we flushed, start time did not change */
1774     segment-&gt;base = current-&gt;start;
1775   } else {
1776     /* start time is now the stepped position */
1777     gst_element_set_start_time (GST_ELEMENT_CAST (sink), position);
1778   }
1779 
1780   /* restore the previous rate */
1781   segment-&gt;rate = current-&gt;start_rate;
1782 
1783   if (segment-&gt;rate &gt; 0.0)
1784     segment-&gt;stop = current-&gt;start_stop;
1785   else
1786     segment-&gt;start = current-&gt;start_start;
1787 
1788   /* post the step done when we know the stepped duration in TIME */
1789   message =
1790       gst_message_new_step_done (GST_OBJECT_CAST (sink), current-&gt;format,
1791       current-&gt;amount, current-&gt;rate, current-&gt;flush, current-&gt;intermediate,
1792       current-&gt;duration, eos);
1793   gst_message_set_seqnum (message, current-&gt;seqnum);
1794   gst_element_post_message (GST_ELEMENT_CAST (sink), message);
1795 
1796   if (!current-&gt;intermediate)
1797     sink-&gt;need_preroll = current-&gt;need_preroll;
1798 
1799   /* and the current step info finished and becomes invalid */
1800   current-&gt;valid = FALSE;
1801 }
1802 
1803 static gboolean
1804 handle_stepping (GstBaseSink * sink, GstSegment * segment,
1805     GstStepInfo * current, guint64 * cstart, guint64 * cstop, guint64 * rstart,
1806     guint64 * rstop)
1807 {
1808   gboolean step_end = FALSE;
1809 
1810   /* stepping never stops */
1811   if (current-&gt;amount == -1)
1812     return FALSE;
1813 
1814   /* see if we need to skip this buffer because of stepping */
1815   switch (current-&gt;format) {
1816     case GST_FORMAT_TIME:
1817     {
1818       guint64 end;
1819       guint64 first, last;
1820       gdouble abs_rate;
1821 
1822       if (segment-&gt;rate &gt; 0.0) {
1823         if (segment-&gt;stop == *cstop)
1824           *rstop = *rstart + current-&gt;amount;
1825 
1826         first = *rstart;
1827         last = *rstop;
1828       } else {
1829         if (segment-&gt;start == *cstart)
1830           *rstart = *rstop + current-&gt;amount;
1831 
1832         first = *rstop;
1833         last = *rstart;
1834       }
1835 
1836       end = current-&gt;start + current-&gt;amount;
1837       current-&gt;position = first - current-&gt;start;
1838 
1839       abs_rate = ABS (segment-&gt;rate);
1840       if (G_UNLIKELY (abs_rate != 1.0))
1841         current-&gt;position /= abs_rate;
1842 
1843       GST_DEBUG_OBJECT (sink,
1844           &quot;buffer: %&quot; GST_TIME_FORMAT &quot;-%&quot; GST_TIME_FORMAT,
1845           GST_TIME_ARGS (first), GST_TIME_ARGS (last));
1846       GST_DEBUG_OBJECT (sink,
1847           &quot;got time step %&quot; GST_TIME_FORMAT &quot;-%&quot; GST_TIME_FORMAT &quot;/%&quot;
1848           GST_TIME_FORMAT, GST_TIME_ARGS (current-&gt;position),
1849           GST_TIME_ARGS (last - current-&gt;start),
1850           GST_TIME_ARGS (current-&gt;amount));
1851 
1852       if ((current-&gt;flush &amp;&amp; current-&gt;position &gt;= current-&gt;amount)
1853           || last &gt;= end) {
1854         GST_DEBUG_OBJECT (sink, &quot;step ended, we need clipping&quot;);
1855         step_end = TRUE;
1856         if (segment-&gt;rate &gt; 0.0) {
1857           *rstart = end;
1858           *cstart =
1859               gst_segment_position_from_running_time (segment, GST_FORMAT_TIME,
1860               end);
1861         } else {
1862           *rstop = end;
1863           *cstop =
1864               gst_segment_position_from_running_time (segment, GST_FORMAT_TIME,
1865               end);
1866         }
1867       }
1868       GST_DEBUG_OBJECT (sink,
1869           &quot;cstart %&quot; GST_TIME_FORMAT &quot;, rstart %&quot; GST_TIME_FORMAT,
1870           GST_TIME_ARGS (*cstart), GST_TIME_ARGS (*rstart));
1871       GST_DEBUG_OBJECT (sink,
1872           &quot;cstop %&quot; GST_TIME_FORMAT &quot;, rstop %&quot; GST_TIME_FORMAT,
1873           GST_TIME_ARGS (*cstop), GST_TIME_ARGS (*rstop));
1874       break;
1875     }
1876     case GST_FORMAT_BUFFERS:
1877       GST_DEBUG_OBJECT (sink,
1878           &quot;got default step %&quot; G_GUINT64_FORMAT &quot;/%&quot; G_GUINT64_FORMAT,
1879           current-&gt;position, current-&gt;amount);
1880 
1881       if (current-&gt;position &lt; current-&gt;amount) {
1882         current-&gt;position++;
1883       } else {
1884         step_end = TRUE;
1885       }
1886       break;
1887     case GST_FORMAT_DEFAULT:
1888     default:
1889       GST_DEBUG_OBJECT (sink,
1890           &quot;got unknown step %&quot; G_GUINT64_FORMAT &quot;/%&quot; G_GUINT64_FORMAT,
1891           current-&gt;position, current-&gt;amount);
1892       break;
1893   }
1894   return step_end;
1895 }
1896 
1897 /* with STREAM_LOCK, PREROLL_LOCK
1898  *
1899  * Returns %TRUE if the object needs synchronisation and takes therefore
1900  * part in prerolling.
1901  *
1902  * rsstart/rsstop contain the start/stop in stream time.
1903  * rrstart/rrstop contain the start/stop in running time.
1904  */
1905 static gboolean
1906 gst_base_sink_get_sync_times (GstBaseSink * basesink, GstMiniObject * obj,
1907     GstClockTime * rsstart, GstClockTime * rsstop,
1908     GstClockTime * rrstart, GstClockTime * rrstop, GstClockTime * rrnext,
1909     gboolean * do_sync, gboolean * stepped, GstStepInfo * step,
1910     gboolean * step_end)
1911 {
1912   GstBaseSinkClass *bclass;
1913   GstClockTime start, stop;     /* raw start/stop timestamps */
1914   guint64 cstart, cstop;        /* clipped raw timestamps */
1915   guint64 rstart, rstop, rnext; /* clipped timestamps converted to running time */
1916   GstClockTime sstart, sstop;   /* clipped timestamps converted to stream time */
1917   GstFormat format;
1918   GstBaseSinkPrivate *priv;
1919   GstSegment *segment;
1920   gboolean eos;
1921 
1922   priv = basesink-&gt;priv;
1923   segment = &amp;basesink-&gt;segment;
1924 
1925   bclass = GST_BASE_SINK_GET_CLASS (basesink);
1926 
1927 again:
1928   /* start with nothing */
1929   start = stop = GST_CLOCK_TIME_NONE;
1930   eos = FALSE;
1931 
1932   if (G_UNLIKELY (GST_IS_EVENT (obj))) {
1933     GstEvent *event = GST_EVENT_CAST (obj);
1934 
1935     switch (GST_EVENT_TYPE (event)) {
1936         /* EOS event needs syncing */
1937       case GST_EVENT_EOS:
1938       {
1939         if (segment-&gt;rate &gt;= 0.0) {
1940           sstart = sstop = priv-&gt;current_sstop;
1941           if (!GST_CLOCK_TIME_IS_VALID (sstart)) {
1942             /* we have not seen a buffer yet, use the segment values */
1943             sstart = sstop = gst_segment_to_stream_time (segment,
1944                 segment-&gt;format, segment-&gt;stop);
1945           }
1946         } else {
1947           sstart = sstop = priv-&gt;current_sstart;
1948           if (!GST_CLOCK_TIME_IS_VALID (sstart)) {
1949             /* we have not seen a buffer yet, use the segment values */
1950             sstart = sstop = gst_segment_to_stream_time (segment,
1951                 segment-&gt;format, segment-&gt;start);
1952           }
1953         }
1954 
1955         rstart = rstop = rnext = priv-&gt;eos_rtime;
1956         *do_sync = GST_CLOCK_TIME_IS_VALID (rstart);
1957         GST_DEBUG_OBJECT (basesink, &quot;sync times for EOS %&quot; GST_TIME_FORMAT,
1958             GST_TIME_ARGS (rstart));
1959         /* if we are stepping, we end now */
1960         *step_end = step-&gt;valid;
1961         eos = TRUE;
1962         goto eos_done;
1963       }
1964       case GST_EVENT_GAP:
1965       {
1966         GstClockTime timestamp, duration;
1967         gst_event_parse_gap (event, &amp;timestamp, &amp;duration);
1968 
1969         GST_DEBUG_OBJECT (basesink, &quot;Got Gap time %&quot; GST_TIME_FORMAT
1970             &quot; duration %&quot; GST_TIME_FORMAT,
1971             GST_TIME_ARGS (timestamp), GST_TIME_ARGS (duration));
1972 
1973         if (GST_CLOCK_TIME_IS_VALID (timestamp)) {
1974           start = timestamp;
1975           if (GST_CLOCK_TIME_IS_VALID (duration))
1976             stop = start + duration;
1977         }
1978         *do_sync = TRUE;
1979         break;
1980       }
1981       default:
1982         /* other events do not need syncing */
1983         return FALSE;
1984     }
1985   } else {
1986     /* else do buffer sync code */
1987     GstBuffer *buffer = GST_BUFFER_CAST (obj);
1988 
1989     /* just get the times to see if we need syncing, if the retuned start is -1
1990      * we don&#39;t sync. */
1991     if (bclass-&gt;get_times)
1992       bclass-&gt;get_times (basesink, buffer, &amp;start, &amp;stop);
1993 
1994     if (!GST_CLOCK_TIME_IS_VALID (start)) {
1995       /* we don&#39;t need to sync but we still want to get the timestamps for
1996        * tracking the position */
1997       gst_base_sink_default_get_times (basesink, buffer, &amp;start, &amp;stop);
1998       *do_sync = FALSE;
1999     } else {
2000       *do_sync = TRUE;
2001     }
2002   }
2003 
2004   GST_DEBUG_OBJECT (basesink, &quot;got times start: %&quot; GST_TIME_FORMAT
2005       &quot;, stop: %&quot; GST_TIME_FORMAT &quot;, do_sync %d&quot;, GST_TIME_ARGS (start),
2006       GST_TIME_ARGS (stop), *do_sync);
2007 
2008   /* collect segment and format for code clarity */
2009   format = segment-&gt;format;
2010 
2011   /* clip */
2012   if (G_UNLIKELY (!gst_segment_clip (segment, format,
2013               start, stop, &amp;cstart, &amp;cstop))) {
2014     if (step-&gt;valid) {
2015       GST_DEBUG_OBJECT (basesink, &quot;step out of segment&quot;);
2016       /* when we are stepping, pretend we&#39;re at the end of the segment */
2017       if (segment-&gt;rate &gt; 0.0) {
2018         cstart = segment-&gt;stop;
2019         cstop = segment-&gt;stop;
2020       } else {
2021         cstart = segment-&gt;start;
2022         cstop = segment-&gt;start;
2023       }
2024       goto do_times;
2025     }
2026     goto out_of_segment;
2027   }
2028 
2029   if (G_UNLIKELY (start != cstart || stop != cstop)) {
2030     GST_DEBUG_OBJECT (basesink, &quot;clipped to: start %&quot; GST_TIME_FORMAT
2031         &quot;, stop: %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (cstart),
2032         GST_TIME_ARGS (cstop));
2033   }
2034 
2035   /* set last stop position */
2036   if (G_LIKELY (stop != GST_CLOCK_TIME_NONE &amp;&amp; cstop != GST_CLOCK_TIME_NONE))
2037     segment-&gt;position = cstop;
2038   else
2039     segment-&gt;position = cstart;
2040 
2041 do_times:
2042   rstart = gst_segment_to_running_time (segment, format, cstart);
2043   rstop = gst_segment_to_running_time (segment, format, cstop);
2044 
2045   if (GST_CLOCK_TIME_IS_VALID (stop))
2046     rnext = rstop;
2047   else
2048     rnext = rstart;
2049 
2050   if (G_UNLIKELY (step-&gt;valid)) {
2051     if (!(*step_end = handle_stepping (basesink, segment, step, &amp;cstart, &amp;cstop,
2052                 &amp;rstart, &amp;rstop))) {
2053       /* step is still busy, we discard data when we are flushing */
2054       *stepped = step-&gt;flush;
2055       GST_DEBUG_OBJECT (basesink, &quot;stepping busy&quot;);
2056     }
2057   }
2058   /* this can produce wrong values if we accumulated non-TIME segments. If this happens,
2059    * upstream is behaving very badly */
2060   sstart = gst_segment_to_stream_time (segment, format, cstart);
2061   sstop = gst_segment_to_stream_time (segment, format, cstop);
2062 
2063 eos_done:
2064   /* eos_done label only called when doing EOS, we also stop stepping then */
2065   if (*step_end &amp;&amp; step-&gt;flush) {
2066     GST_DEBUG_OBJECT (basesink, &quot;flushing step ended&quot;);
2067     stop_stepping (basesink, segment, step, rstart, rstop, eos);
2068     *step_end = FALSE;
2069     /* re-determine running start times for adjusted segment
2070      * (which has a flushed amount of running/accumulated time removed) */
2071     if (!GST_IS_EVENT (obj)) {
2072       GST_DEBUG_OBJECT (basesink, &quot;refresh sync times&quot;);
2073       goto again;
2074     }
2075   }
2076 
2077   /* save times */
2078   *rsstart = sstart;
2079   *rsstop = sstop;
2080   *rrstart = rstart;
2081   *rrstop = rstop;
2082   *rrnext = rnext;
2083 
2084   /* buffers and EOS always need syncing and preroll */
2085   return TRUE;
2086 
2087   /* special cases */
2088 out_of_segment:
2089   {
2090     /* we usually clip in the chain function already but stepping could cause
2091      * the segment to be updated later. we return %FALSE so that we don&#39;t try
2092      * to sync on it. */
2093     GST_LOG_OBJECT (basesink, &quot;buffer skipped, not in segment&quot;);
2094     return FALSE;
2095   }
2096 }
2097 
2098 /* with STREAM_LOCK, PREROLL_LOCK, LOCK
2099  * adjust a timestamp with the latency and timestamp offset. This function does
2100  * not adjust for the render delay. */
2101 static GstClockTime
2102 gst_base_sink_adjust_time (GstBaseSink * basesink, GstClockTime time)
2103 {
2104   GstClockTimeDiff ts_offset;
2105 
2106   /* don&#39;t do anything funny with invalid timestamps */
2107   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (time)))
2108     return time;
2109 
2110   time += basesink-&gt;priv-&gt;latency;
2111 
2112   /* apply offset, be careful for underflows */
2113   ts_offset = basesink-&gt;priv-&gt;ts_offset;
2114   if (ts_offset &lt; 0) {
2115     ts_offset = -ts_offset;
2116     if (ts_offset &lt; time)
2117       time -= ts_offset;
2118     else
2119       time = 0;
2120   } else
2121     time += ts_offset;
2122 
2123   /* subtract the render delay again, which was included in the latency */
2124   if (time &gt; basesink-&gt;priv-&gt;render_delay)
2125     time -= basesink-&gt;priv-&gt;render_delay;
2126   else
2127     time = 0;
2128 
2129   return time;
2130 }
2131 
2132 /**
2133  * gst_base_sink_wait_clock:
2134  * @sink: the sink
2135  * @time: the running_time to be reached
2136  * @jitter: (out) (allow-none): the jitter to be filled with time diff, or %NULL
2137  *
2138  * This function will block until @time is reached. It is usually called by
2139  * subclasses that use their own internal synchronisation.
2140  *
2141  * If @time is not valid, no synchronisation is done and %GST_CLOCK_BADTIME is
2142  * returned. Likewise, if synchronisation is disabled in the element or there
2143  * is no clock, no synchronisation is done and %GST_CLOCK_BADTIME is returned.
2144  *
2145  * This function should only be called with the PREROLL_LOCK held, like when
2146  * receiving an EOS event in the #GstBaseSinkClass.event() vmethod or when
2147  * receiving a buffer in
2148  * the #GstBaseSinkClass.render() vmethod.
2149  *
2150  * The @time argument should be the running_time of when this method should
2151  * return and is not adjusted with any latency or offset configured in the
2152  * sink.
2153  *
2154  * Returns: #GstClockReturn
2155  */
2156 GstClockReturn
2157 gst_base_sink_wait_clock (GstBaseSink * sink, GstClockTime time,
2158     GstClockTimeDiff * jitter)
2159 {
2160   GstClockReturn ret;
2161   GstClock *clock;
2162   GstClockTime base_time;
2163 
2164   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (time)))
2165     goto invalid_time;
2166 
2167   GST_OBJECT_LOCK (sink);
2168   if (G_UNLIKELY (!sink-&gt;sync))
2169     goto no_sync;
2170 
2171   if (G_UNLIKELY ((clock = GST_ELEMENT_CLOCK (sink)) == NULL))
2172     goto no_clock;
2173 
2174   base_time = GST_ELEMENT_CAST (sink)-&gt;base_time;
2175   GST_LOG_OBJECT (sink,
2176       &quot;time %&quot; GST_TIME_FORMAT &quot;, base_time %&quot; GST_TIME_FORMAT,
2177       GST_TIME_ARGS (time), GST_TIME_ARGS (base_time));
2178 
2179   /* add base_time to running_time to get the time against the clock */
2180   time += base_time;
2181 
2182   /* Re-use existing clockid if available */
2183   /* FIXME: Casting to GstClockEntry only works because the types
2184    * are the same */
2185   if (G_LIKELY (sink-&gt;priv-&gt;cached_clock_id != NULL
2186           &amp;&amp; GST_CLOCK_ENTRY_CLOCK ((GstClockEntry *) sink-&gt;
2187               priv-&gt;cached_clock_id) == clock)) {
2188     if (!gst_clock_single_shot_id_reinit (clock, sink-&gt;priv-&gt;cached_clock_id,
2189             time)) {
2190       gst_clock_id_unref (sink-&gt;priv-&gt;cached_clock_id);
2191       sink-&gt;priv-&gt;cached_clock_id = gst_clock_new_single_shot_id (clock, time);
2192     }
2193   } else {
2194     if (sink-&gt;priv-&gt;cached_clock_id != NULL)
2195       gst_clock_id_unref (sink-&gt;priv-&gt;cached_clock_id);
2196     sink-&gt;priv-&gt;cached_clock_id = gst_clock_new_single_shot_id (clock, time);
2197   }
2198   GST_OBJECT_UNLOCK (sink);
2199 
2200   /* A blocking wait is performed on the clock. We save the ClockID
2201    * so we can unlock the entry at any time. While we are blocking, we
2202    * release the PREROLL_LOCK so that other threads can interrupt the
2203    * entry. */
2204   sink-&gt;clock_id = sink-&gt;priv-&gt;cached_clock_id;
2205   /* release the preroll lock while waiting */
2206   GST_BASE_SINK_PREROLL_UNLOCK (sink);
2207 
2208   ret = gst_clock_id_wait (sink-&gt;priv-&gt;cached_clock_id, jitter);
2209 
2210   GST_BASE_SINK_PREROLL_LOCK (sink);
2211   sink-&gt;clock_id = NULL;
2212 
2213   return ret;
2214 
2215   /* no syncing needed */
2216 invalid_time:
2217   {
2218     GST_DEBUG_OBJECT (sink, &quot;time not valid, no sync needed&quot;);
2219     return GST_CLOCK_BADTIME;
2220   }
2221 no_sync:
2222   {
2223     GST_DEBUG_OBJECT (sink, &quot;sync disabled&quot;);
2224     GST_OBJECT_UNLOCK (sink);
2225     return GST_CLOCK_BADTIME;
2226   }
2227 no_clock:
2228   {
2229     GST_DEBUG_OBJECT (sink, &quot;no clock, can&#39;t sync&quot;);
2230     GST_OBJECT_UNLOCK (sink);
2231     return GST_CLOCK_BADTIME;
2232   }
2233 }
2234 
2235 /**
2236  * gst_base_sink_wait_preroll:
2237  * @sink: the sink
2238  *
2239  * If the #GstBaseSinkClass.render() method performs its own synchronisation
2240  * against the clock it must unblock when going from PLAYING to the PAUSED state
2241  * and call this method before continuing to render the remaining data.
2242  *
2243  * If the #GstBaseSinkClass.render() method can block on something else than
2244  * the clock, it must also be ready to unblock immediately on
2245  * the #GstBaseSinkClass.unlock() method and cause the
2246  * #GstBaseSinkClass.render() method to immediately call this function.
2247  * In this case, the subclass must be prepared to continue rendering where it
2248  * left off if this function returns %GST_FLOW_OK.
2249  *
2250  * This function will block until a state change to PLAYING happens (in which
2251  * case this function returns %GST_FLOW_OK) or the processing must be stopped due
2252  * to a state change to READY or a FLUSH event (in which case this function
2253  * returns %GST_FLOW_FLUSHING).
2254  *
2255  * This function should only be called with the PREROLL_LOCK held, like in the
2256  * render function.
2257  *
2258  * Returns: %GST_FLOW_OK if the preroll completed and processing can
2259  * continue. Any other return value should be returned from the render vmethod.
2260  */
2261 GstFlowReturn
2262 gst_base_sink_wait_preroll (GstBaseSink * sink)
2263 {
2264   sink-&gt;have_preroll = TRUE;
2265   GST_DEBUG_OBJECT (sink, &quot;waiting in preroll for flush or PLAYING&quot;);
2266   /* block until the state changes, or we get a flush, or something */
2267   GST_BASE_SINK_PREROLL_WAIT (sink);
2268   sink-&gt;have_preroll = FALSE;
2269   if (G_UNLIKELY (sink-&gt;flushing))
2270     goto stopping;
2271   if (G_UNLIKELY (sink-&gt;priv-&gt;step_unlock))
2272     goto step_unlocked;
2273   GST_DEBUG_OBJECT (sink, &quot;continue after preroll&quot;);
2274 
2275   return GST_FLOW_OK;
2276 
2277   /* ERRORS */
2278 stopping:
2279   {
2280     GST_DEBUG_OBJECT (sink, &quot;preroll interrupted because of flush&quot;);
2281     return GST_FLOW_FLUSHING;
2282   }
2283 step_unlocked:
2284   {
2285     sink-&gt;priv-&gt;step_unlock = FALSE;
2286     GST_DEBUG_OBJECT (sink, &quot;preroll interrupted because of step&quot;);
2287     return GST_FLOW_STEP;
2288   }
2289 }
2290 
2291 /**
2292  * gst_base_sink_do_preroll:
2293  * @sink: the sink
2294  * @obj: (transfer none): the mini object that caused the preroll
2295  *
2296  * If the @sink spawns its own thread for pulling buffers from upstream it
2297  * should call this method after it has pulled a buffer. If the element needed
2298  * to preroll, this function will perform the preroll and will then block
2299  * until the element state is changed.
2300  *
2301  * This function should be called with the PREROLL_LOCK held.
2302  *
2303  * Returns: %GST_FLOW_OK if the preroll completed and processing can
2304  * continue. Any other return value should be returned from the render vmethod.
2305  */
2306 GstFlowReturn
2307 gst_base_sink_do_preroll (GstBaseSink * sink, GstMiniObject * obj)
2308 {
2309   GstFlowReturn ret;
2310 
2311   while (G_UNLIKELY (sink-&gt;need_preroll)) {
2312     GST_DEBUG_OBJECT (sink, &quot;prerolling object %p&quot;, obj);
2313 
2314     /* if it&#39;s a buffer, we need to call the preroll method */
2315     if (sink-&gt;priv-&gt;call_preroll) {
2316       GstBaseSinkClass *bclass;
2317       GstBuffer *buf;
2318 
2319       if (GST_IS_BUFFER_LIST (obj)) {
2320         buf = gst_buffer_list_get (GST_BUFFER_LIST_CAST (obj), 0);
2321         gst_base_sink_set_last_buffer (sink, buf);
2322         gst_base_sink_set_last_buffer_list (sink, GST_BUFFER_LIST_CAST (obj));
2323         g_assert (NULL != buf);
2324       } else if (GST_IS_BUFFER (obj)) {
2325         buf = GST_BUFFER_CAST (obj);
2326         /* For buffer lists do not set last buffer for now */
2327         gst_base_sink_set_last_buffer (sink, buf);
2328         gst_base_sink_set_last_buffer_list (sink, NULL);
2329       } else {
2330         buf = NULL;
2331       }
2332 
2333       if (buf) {
2334         GST_DEBUG_OBJECT (sink, &quot;preroll buffer %&quot; GST_TIME_FORMAT,
2335             GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)));
2336 
2337         bclass = GST_BASE_SINK_GET_CLASS (sink);
2338 
2339         if (bclass-&gt;prepare)
2340           if ((ret = bclass-&gt;prepare (sink, buf)) != GST_FLOW_OK)
2341             goto prepare_canceled;
2342 
2343         if (bclass-&gt;preroll)
2344           if ((ret = bclass-&gt;preroll (sink, buf)) != GST_FLOW_OK)
2345             goto preroll_canceled;
2346 
2347         sink-&gt;priv-&gt;call_preroll = FALSE;
2348       }
2349     }
2350 
2351     /* commit state */
2352     if (G_LIKELY (sink-&gt;playing_async)) {
2353       if (G_UNLIKELY (!gst_base_sink_commit_state (sink)))
2354         goto stopping;
2355     }
2356 
2357     /* need to recheck here because the commit state could have
2358      * made us not need the preroll anymore */
2359     if (G_LIKELY (sink-&gt;need_preroll)) {
2360       /* block until the state changes, or we get a flush, or something */
2361       ret = gst_base_sink_wait_preroll (sink);
2362       if ((ret != GST_FLOW_OK) &amp;&amp; (ret != GST_FLOW_STEP))
2363         goto preroll_failed;
2364     }
2365   }
2366   return GST_FLOW_OK;
2367 
2368   /* ERRORS */
2369 prepare_canceled:
2370   {
2371     GST_DEBUG_OBJECT (sink, &quot;prepare failed, abort state&quot;);
2372     gst_element_abort_state (GST_ELEMENT_CAST (sink));
2373     return ret;
2374   }
2375 preroll_canceled:
2376   {
2377     GST_DEBUG_OBJECT (sink, &quot;preroll failed, abort state&quot;);
2378     gst_element_abort_state (GST_ELEMENT_CAST (sink));
2379     return ret;
2380   }
2381 stopping:
2382   {
2383     GST_DEBUG_OBJECT (sink, &quot;stopping while commiting state&quot;);
2384     return GST_FLOW_FLUSHING;
2385   }
2386 preroll_failed:
2387   {
2388     GST_DEBUG_OBJECT (sink, &quot;preroll failed: %s&quot;, gst_flow_get_name (ret));
2389     return ret;
2390   }
2391 }
2392 
2393 /**
2394  * gst_base_sink_wait:
2395  * @sink: the sink
2396  * @time: the running_time to be reached
2397  * @jitter: (out) (allow-none): the jitter to be filled with time diff, or %NULL
2398  *
2399  * This function will wait for preroll to complete and will then block until @time
2400  * is reached. It is usually called by subclasses that use their own internal
2401  * synchronisation but want to let some synchronization (like EOS) be handled
2402  * by the base class.
2403  *
2404  * This function should only be called with the PREROLL_LOCK held (like when
2405  * receiving an EOS event in the ::event vmethod or when handling buffers in
2406  * ::render).
2407  *
2408  * The @time argument should be the running_time of when the timeout should happen
2409  * and will be adjusted with any latency and offset configured in the sink.
2410  *
2411  * Returns: #GstFlowReturn
2412  */
2413 GstFlowReturn
2414 gst_base_sink_wait (GstBaseSink * sink, GstClockTime time,
2415     GstClockTimeDiff * jitter)
2416 {
2417   GstClockReturn status;
2418   GstFlowReturn ret;
2419 
2420   do {
2421     GstClockTime stime;
2422 
2423     GST_DEBUG_OBJECT (sink, &quot;checking preroll&quot;);
2424 
2425     /* first wait for the playing state before we can continue */
2426     while (G_UNLIKELY (sink-&gt;need_preroll)) {
2427       ret = gst_base_sink_wait_preroll (sink);
2428       if ((ret != GST_FLOW_OK) &amp;&amp; (ret != GST_FLOW_STEP))
2429         goto flushing;
2430     }
2431 
2432     /* preroll done, we can sync since we are in PLAYING now. */
2433     GST_DEBUG_OBJECT (sink, &quot;possibly waiting for clock to reach %&quot;
2434         GST_TIME_FORMAT, GST_TIME_ARGS (time));
2435 
2436     /* compensate for latency, ts_offset and render delay */
2437     stime = gst_base_sink_adjust_time (sink, time);
2438 
2439     /* wait for the clock, this can be interrupted because we got shut down or
2440      * we PAUSED. */
2441     status = gst_base_sink_wait_clock (sink, stime, jitter);
2442 
2443     GST_DEBUG_OBJECT (sink, &quot;clock returned %d&quot;, status);
2444 
2445     /* invalid time, no clock or sync disabled, just continue then */
2446     if (status == GST_CLOCK_BADTIME)
2447       break;
2448 
2449     /* waiting could have been interrupted and we can be flushing now */
2450     if (G_UNLIKELY (sink-&gt;flushing))
2451       goto flushing;
2452 
2453     /* retry if we got unscheduled, which means we did not reach the timeout
2454      * yet. if some other error occures, we continue. */
2455   } while (status == GST_CLOCK_UNSCHEDULED);
2456 
2457   GST_DEBUG_OBJECT (sink, &quot;end of stream&quot;);
2458 
2459   return GST_FLOW_OK;
2460 
2461   /* ERRORS */
2462 flushing:
2463   {
2464     GST_DEBUG_OBJECT (sink, &quot;we are flushing&quot;);
2465     return GST_FLOW_FLUSHING;
2466   }
2467 }
2468 
2469 /* with STREAM_LOCK, PREROLL_LOCK
2470  *
2471  * Make sure we are in PLAYING and synchronize an object to the clock.
2472  *
2473  * If we need preroll, we are not in PLAYING. We try to commit the state
2474  * if needed and then block if we still are not PLAYING.
2475  *
2476  * We start waiting on the clock in PLAYING. If we got interrupted, we
2477  * immediately try to re-preroll.
2478  *
2479  * Some objects do not need synchronisation (most events) and so this function
2480  * immediately returns GST_FLOW_OK.
2481  *
2482  * for objects that arrive later than max-lateness to be synchronized to the
2483  * clock have the @late boolean set to %TRUE.
2484  *
2485  * This function keeps a running average of the jitter (the diff between the
2486  * clock time and the requested sync time). The jitter is negative for
2487  * objects that arrive in time and positive for late buffers.
2488  *
2489  * does not take ownership of obj.
2490  */
2491 static GstFlowReturn
2492 gst_base_sink_do_sync (GstBaseSink * basesink,
2493     GstMiniObject * obj, gboolean * late, gboolean * step_end)
2494 {
2495   GstClockTimeDiff jitter = 0;
2496   gboolean syncable;
2497   GstClockReturn status = GST_CLOCK_OK;
2498   GstClockTime rstart, rstop, rnext, sstart, sstop, stime;
2499   gboolean do_sync;
2500   GstBaseSinkPrivate *priv;
2501   GstFlowReturn ret;
2502   GstStepInfo *current, *pending;
2503   gboolean stepped;
2504 
2505   priv = basesink-&gt;priv;
2506 
2507 do_step:
2508   sstart = sstop = rstart = rstop = rnext = GST_CLOCK_TIME_NONE;
2509   do_sync = TRUE;
2510   stepped = FALSE;
2511 
2512   priv-&gt;current_rstart = GST_CLOCK_TIME_NONE;
2513 
2514   /* get stepping info */
2515   current = &amp;priv-&gt;current_step;
2516   pending = &amp;priv-&gt;pending_step;
2517 
2518   /* get timing information for this object against the render segment */
2519   syncable = gst_base_sink_get_sync_times (basesink, obj,
2520       &amp;sstart, &amp;sstop, &amp;rstart, &amp;rstop, &amp;rnext, &amp;do_sync, &amp;stepped, current,
2521       step_end);
2522 
2523   if (G_UNLIKELY (stepped))
2524     goto step_skipped;
2525 
2526   /* a syncable object needs to participate in preroll and
2527    * clocking. All buffers and EOS are syncable. */
2528   if (G_UNLIKELY (!syncable))
2529     goto not_syncable;
2530 
2531   /* store timing info for current object */
2532   priv-&gt;current_rstart = rstart;
2533   priv-&gt;current_rstop = (GST_CLOCK_TIME_IS_VALID (rstop) ? rstop : rstart);
2534 
2535   /* save sync time for eos when the previous object needed sync */
2536   priv-&gt;eos_rtime = (do_sync ? rnext : GST_CLOCK_TIME_NONE);
2537 
2538   /* calculate inter frame spacing */
2539   if (G_UNLIKELY (GST_CLOCK_TIME_IS_VALID (priv-&gt;prev_rstart) &amp;&amp;
2540           priv-&gt;prev_rstart &lt; rstart)) {
2541     GstClockTime in_diff;
2542 
2543     in_diff = rstart - priv-&gt;prev_rstart;
2544 
2545     if (priv-&gt;avg_in_diff == -1)
2546       priv-&gt;avg_in_diff = in_diff;
2547     else
2548       priv-&gt;avg_in_diff = UPDATE_RUNNING_AVG (priv-&gt;avg_in_diff, in_diff);
2549 
2550     GST_LOG_OBJECT (basesink, &quot;avg frame diff %&quot; GST_TIME_FORMAT,
2551         GST_TIME_ARGS (priv-&gt;avg_in_diff));
2552 
2553   }
2554   priv-&gt;prev_rstart = rstart;
2555 
2556   if (G_UNLIKELY (GST_CLOCK_TIME_IS_VALID (priv-&gt;earliest_in_time) &amp;&amp;
2557           rstart &lt; priv-&gt;earliest_in_time))
2558     goto qos_dropped;
2559 
2560 again:
2561   /* first do preroll, this makes sure we commit our state
2562    * to PAUSED and can continue to PLAYING. We cannot perform
2563    * any clock sync in PAUSED because there is no clock. */
2564   ret = gst_base_sink_do_preroll (basesink, obj);
2565   if (G_UNLIKELY (ret != GST_FLOW_OK))
2566     goto preroll_failed;
2567 
2568   /* update the segment with a pending step if the current one is invalid and we
2569    * have a new pending one. We only accept new step updates after a preroll */
2570   if (G_UNLIKELY (pending-&gt;valid &amp;&amp; !current-&gt;valid)) {
2571     start_stepping (basesink, &amp;basesink-&gt;segment, pending, current);
2572     goto do_step;
2573   }
2574 
2575   /* After rendering we store the position of the last buffer so that we can use
2576    * it to report the position. We need to take the lock here. */
2577   GST_OBJECT_LOCK (basesink);
2578   priv-&gt;current_sstart = sstart;
2579   priv-&gt;current_sstop = (GST_CLOCK_TIME_IS_VALID (sstop) ? sstop : sstart);
2580   GST_OBJECT_UNLOCK (basesink);
2581 
2582   if (!do_sync)
2583     goto done;
2584 
2585   /* adjust for latency */
2586   stime = gst_base_sink_adjust_time (basesink, rstart);
2587 
2588   /* adjust for rate control */
2589   if (priv-&gt;rc_next == -1 || (stime != -1 &amp;&amp; stime &gt;= priv-&gt;rc_next)) {
2590     GST_DEBUG_OBJECT (basesink, &quot;reset rc_time to time %&quot; GST_TIME_FORMAT,
2591         GST_TIME_ARGS (stime));
2592     priv-&gt;rc_time = stime;
2593     priv-&gt;rc_accumulated = 0;
2594   } else {
2595     GST_DEBUG_OBJECT (basesink, &quot;rate control next %&quot; GST_TIME_FORMAT,
2596         GST_TIME_ARGS (priv-&gt;rc_next));
2597     stime = priv-&gt;rc_next;
2598   }
2599 
2600   /* preroll done, we can sync since we are in PLAYING now. */
2601   GST_DEBUG_OBJECT (basesink, &quot;possibly waiting for clock to reach %&quot;
2602       GST_TIME_FORMAT &quot;, adjusted %&quot; GST_TIME_FORMAT,
2603       GST_TIME_ARGS (rstart), GST_TIME_ARGS (stime));
2604 
2605   /* This function will return immediately if start == -1, no clock
2606    * or sync is disabled with GST_CLOCK_BADTIME. */
2607   status = gst_base_sink_wait_clock (basesink, stime, &amp;jitter);
2608 
2609   GST_DEBUG_OBJECT (basesink, &quot;clock returned %d, jitter %c%&quot; GST_TIME_FORMAT,
2610       status, (jitter &lt; 0 ? &#39;-&#39; : &#39; &#39;), GST_TIME_ARGS (ABS (jitter)));
2611 
2612   /* invalid time, no clock or sync disabled, just render */
2613   if (status == GST_CLOCK_BADTIME)
2614     goto done;
2615 
2616   /* waiting could have been interrupted and we can be flushing now */
2617   if (G_UNLIKELY (basesink-&gt;flushing))
2618     goto flushing;
2619 
2620   /* check for unlocked by a state change, we are not flushing so
2621    * we can try to preroll on the current buffer. */
2622   if (G_UNLIKELY (status == GST_CLOCK_UNSCHEDULED)) {
2623     GST_DEBUG_OBJECT (basesink, &quot;unscheduled, waiting some more&quot;);
2624     priv-&gt;call_preroll = TRUE;
2625     goto again;
2626   }
2627 
2628   /* successful syncing done, record observation */
2629   priv-&gt;current_jitter = jitter;
2630 
2631   /* check if the object should be dropped */
2632   *late = gst_base_sink_is_too_late (basesink, obj, rstart, rstop,
2633       status, jitter, TRUE);
2634 
2635 done:
2636   return GST_FLOW_OK;
2637 
2638   /* ERRORS */
2639 step_skipped:
2640   {
2641     GST_DEBUG_OBJECT (basesink, &quot;skipped stepped object %p&quot;, obj);
2642     *late = TRUE;
2643     return GST_FLOW_OK;
2644   }
2645 not_syncable:
2646   {
2647     GST_DEBUG_OBJECT (basesink, &quot;non syncable object %p&quot;, obj);
2648     return GST_FLOW_OK;
2649   }
2650 qos_dropped:
2651   {
2652     GST_DEBUG_OBJECT (basesink, &quot;dropped because of QoS %p&quot;, obj);
2653     *late = TRUE;
2654     return GST_FLOW_OK;
2655   }
2656 flushing:
2657   {
2658     GST_DEBUG_OBJECT (basesink, &quot;we are flushing&quot;);
2659     return GST_FLOW_FLUSHING;
2660   }
2661 preroll_failed:
2662   {
2663     GST_DEBUG_OBJECT (basesink, &quot;preroll failed&quot;);
2664     *step_end = FALSE;
2665     return ret;
2666   }
2667 }
2668 
2669 static gboolean
2670 gst_base_sink_send_qos (GstBaseSink * basesink, GstQOSType type,
2671     gdouble proportion, GstClockTime time, GstClockTimeDiff diff)
2672 {
2673   GstEvent *event;
2674   gboolean res;
2675 
2676   /* generate Quality-of-Service event */
2677   GST_CAT_DEBUG_OBJECT (GST_CAT_QOS, basesink,
2678       &quot;qos: type %d, proportion: %lf, diff %&quot; G_GINT64_FORMAT &quot;, timestamp %&quot;
2679       GST_TIME_FORMAT, type, proportion, diff, GST_TIME_ARGS (time));
2680 
2681   event = gst_event_new_qos (type, proportion, diff, time);
2682 
2683   /* send upstream */
2684   res = gst_pad_push_event (basesink-&gt;sinkpad, event);
2685 
2686   return res;
2687 }
2688 
2689 static void
2690 gst_base_sink_perform_qos (GstBaseSink * sink, gboolean dropped)
2691 {
2692   GstBaseSinkPrivate *priv;
2693   GstClockTime start, stop;
2694   GstClockTimeDiff jitter;
2695   GstClockTime pt, entered, left;
2696   GstClockTime duration;
2697   gdouble rate;
2698 
2699   priv = sink-&gt;priv;
2700 
2701   start = priv-&gt;current_rstart;
2702 
2703   if (priv-&gt;current_step.valid)
2704     return;
2705 
2706   /* if Quality-of-Service disabled, do nothing */
2707   if (!g_atomic_int_get (&amp;priv-&gt;qos_enabled) ||
2708       !GST_CLOCK_TIME_IS_VALID (start))
2709     return;
2710 
2711   stop = priv-&gt;current_rstop;
2712   jitter = priv-&gt;current_jitter;
2713 
2714   if (jitter &lt; 0) {
2715     /* this is the time the buffer entered the sink */
2716     if (start &lt; -jitter)
2717       entered = 0;
2718     else
2719       entered = start + jitter;
2720     left = start;
2721   } else {
2722     /* this is the time the buffer entered the sink */
2723     entered = start + jitter;
2724     /* this is the time the buffer left the sink */
2725     left = start + jitter;
2726   }
2727 
2728   /* calculate duration of the buffer, only use buffer durations if not in
2729    * trick mode or key-unit mode. Otherwise the buffer durations will be
2730    * meaningless as frames are being dropped in-between without updating the
2731    * durations. */
2732   duration = priv-&gt;avg_in_diff;
2733 
2734   /* if we have the time when the last buffer left us, calculate
2735    * processing time */
2736   if (GST_CLOCK_TIME_IS_VALID (priv-&gt;last_left)) {
2737     if (entered &gt; priv-&gt;last_left) {
2738       pt = entered - priv-&gt;last_left;
2739     } else {
2740       pt = 0;
2741     }
2742   } else {
2743     pt = priv-&gt;avg_pt;
2744   }
2745 
2746   GST_CAT_DEBUG_OBJECT (GST_CAT_QOS, sink, &quot;start: %&quot; GST_TIME_FORMAT
2747       &quot;, stop %&quot; GST_TIME_FORMAT &quot;, entered %&quot; GST_TIME_FORMAT &quot;, left %&quot;
2748       GST_TIME_FORMAT &quot;, pt: %&quot; GST_TIME_FORMAT &quot;, duration %&quot; GST_TIME_FORMAT
2749       &quot;,jitter %&quot; G_GINT64_FORMAT, GST_TIME_ARGS (start), GST_TIME_ARGS (stop),
2750       GST_TIME_ARGS (entered), GST_TIME_ARGS (left), GST_TIME_ARGS (pt),
2751       GST_TIME_ARGS (duration), jitter);
2752 
2753   GST_CAT_DEBUG_OBJECT (GST_CAT_QOS, sink,
2754       &quot;avg_pt: %&quot; GST_TIME_FORMAT &quot;, avg_rate: %g&quot;,
2755       GST_TIME_ARGS (priv-&gt;avg_pt), priv-&gt;avg_rate);
2756 
2757   /* collect running averages. for first observations, we copy the
2758    * values */
2759   if (!GST_CLOCK_TIME_IS_VALID (priv-&gt;avg_pt))
2760     priv-&gt;avg_pt = pt;
2761   else
2762     priv-&gt;avg_pt = UPDATE_RUNNING_AVG (priv-&gt;avg_pt, pt);
2763 
2764   if (duration != -1 &amp;&amp; duration != 0) {
2765     rate =
2766         gst_guint64_to_gdouble (priv-&gt;avg_pt) /
2767         gst_guint64_to_gdouble (duration);
2768   } else {
2769     rate = 1.0;
2770   }
2771 
2772   if (GST_CLOCK_TIME_IS_VALID (priv-&gt;last_left)) {
2773     if (dropped || priv-&gt;avg_rate &lt; 0.0) {
2774       priv-&gt;avg_rate = rate;
2775     } else {
2776       if (rate &gt; 1.0)
2777         priv-&gt;avg_rate = UPDATE_RUNNING_AVG_N (priv-&gt;avg_rate, rate);
2778       else
2779         priv-&gt;avg_rate = UPDATE_RUNNING_AVG_P (priv-&gt;avg_rate, rate);
2780     }
2781   }
2782 
2783   GST_CAT_DEBUG_OBJECT (GST_CAT_QOS, sink,
2784       &quot;updated: avg_pt: %&quot; GST_TIME_FORMAT
2785       &quot;, avg_rate: %g&quot;, GST_TIME_ARGS (priv-&gt;avg_pt), priv-&gt;avg_rate);
2786 
2787 
2788   if (priv-&gt;avg_rate &gt;= 0.0) {
2789     GstQOSType type;
2790     GstClockTimeDiff diff;
2791 
2792     /* if we have a valid rate, start sending QoS messages */
2793     if (priv-&gt;current_jitter &lt; 0) {
2794       /* make sure we never go below 0 when adding the jitter to the
2795        * timestamp. */
2796       if (priv-&gt;current_rstart &lt; -priv-&gt;current_jitter)
2797         priv-&gt;current_jitter = -priv-&gt;current_rstart;
2798     }
2799 
2800     if (priv-&gt;throttle_time &gt; 0) {
2801       diff = priv-&gt;throttle_time;
2802       type = GST_QOS_TYPE_THROTTLE;
2803     } else {
2804       diff = priv-&gt;current_jitter;
2805       if (diff &lt;= 0)
2806         type = GST_QOS_TYPE_OVERFLOW;
2807       else
2808         type = GST_QOS_TYPE_UNDERFLOW;
2809     }
2810 
2811     gst_base_sink_send_qos (sink, type, priv-&gt;avg_rate, priv-&gt;current_rstart,
2812         diff);
2813   }
2814 
2815   /* record when this buffer will leave us */
2816   priv-&gt;last_left = left;
2817 }
2818 
2819 /* reset all qos measuring */
2820 static void
2821 gst_base_sink_reset_qos (GstBaseSink * sink)
2822 {
2823   GstBaseSinkPrivate *priv;
2824 
2825   priv = sink-&gt;priv;
2826 
2827   priv-&gt;last_render_time = GST_CLOCK_TIME_NONE;
2828   priv-&gt;prev_rstart = GST_CLOCK_TIME_NONE;
2829   priv-&gt;earliest_in_time = GST_CLOCK_TIME_NONE;
2830   priv-&gt;last_left = GST_CLOCK_TIME_NONE;
2831   priv-&gt;avg_pt = GST_CLOCK_TIME_NONE;
2832   priv-&gt;avg_rate = -1.0;
2833   priv-&gt;avg_in_diff = GST_CLOCK_TIME_NONE;
2834   priv-&gt;rendered = 0;
2835   priv-&gt;dropped = 0;
2836 
2837 }
2838 
2839 /* Checks if the object was scheduled too late.
2840  *
2841  * rstart/rstop contain the running_time start and stop values
2842  * of the object.
2843  *
2844  * status and jitter contain the return values from the clock wait.
2845  *
2846  * returns %TRUE if the buffer was too late.
2847  */
2848 static gboolean
2849 gst_base_sink_is_too_late (GstBaseSink * basesink, GstMiniObject * obj,
2850     GstClockTime rstart, GstClockTime rstop,
2851     GstClockReturn status, GstClockTimeDiff jitter, gboolean render)
2852 {
2853   gboolean late;
2854   guint64 max_lateness;
2855   GstBaseSinkPrivate *priv;
2856 
2857   priv = basesink-&gt;priv;
2858 
2859   late = FALSE;
2860 
2861   /* only for objects that were too late */
2862   if (G_LIKELY (status != GST_CLOCK_EARLY))
2863     goto in_time;
2864 
2865   max_lateness = basesink-&gt;max_lateness;
2866 
2867   /* check if frame dropping is enabled */
2868   if (max_lateness == -1)
2869     goto no_drop;
2870 
2871   /* only check for buffers */
2872   if (G_UNLIKELY (!GST_IS_BUFFER (obj)))
2873     goto not_buffer;
2874 
2875   /* can&#39;t do check if we don&#39;t have a timestamp */
2876   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (rstart)))
2877     goto no_timestamp;
2878 
2879   /* we can add a valid stop time */
2880   if (GST_CLOCK_TIME_IS_VALID (rstop))
2881     max_lateness += rstop;
2882   else {
2883     max_lateness += rstart;
2884     /* no stop time, use avg frame diff */
2885     if (priv-&gt;avg_in_diff != -1)
2886       max_lateness += priv-&gt;avg_in_diff;
2887   }
2888 
2889   /* if the jitter bigger than duration and lateness we are too late */
2890   if ((late = rstart + jitter &gt; max_lateness)) {
2891     GST_CAT_DEBUG_OBJECT (GST_CAT_PERFORMANCE, basesink,
2892         &quot;buffer is too late %&quot; GST_TIME_FORMAT
2893         &quot; &gt; %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (rstart + jitter),
2894         GST_TIME_ARGS (max_lateness));
2895     /* !!emergency!!, if we did not receive anything valid for more than a
2896      * second, render it anyway so the user sees something */
2897     if (GST_CLOCK_TIME_IS_VALID (priv-&gt;last_render_time) &amp;&amp;
2898         rstart - priv-&gt;last_render_time &gt; GST_SECOND) {
2899       late = FALSE;
2900       GST_ELEMENT_WARNING (basesink, CORE, CLOCK,
2901           (_(&quot;A lot of buffers are being dropped.&quot;)),
2902           (&quot;There may be a timestamping problem, or this computer is too slow.&quot;));
2903       GST_CAT_DEBUG_OBJECT (GST_CAT_PERFORMANCE, basesink,
2904           &quot;**emergency** last buffer at %&quot; GST_TIME_FORMAT &quot; &gt; GST_SECOND&quot;,
2905           GST_TIME_ARGS (priv-&gt;last_render_time));
2906     }
2907   }
2908 
2909 done:
2910   if (render &amp;&amp; (!late || !GST_CLOCK_TIME_IS_VALID (priv-&gt;last_render_time))) {
2911     priv-&gt;last_render_time = rstart;
2912     /* the next allowed input timestamp */
2913     if (priv-&gt;throttle_time &gt; 0)
2914       priv-&gt;earliest_in_time = rstart + priv-&gt;throttle_time;
2915   }
2916   return late;
2917 
2918   /* all is fine */
2919 in_time:
2920   {
2921     GST_DEBUG_OBJECT (basesink, &quot;object was scheduled in time&quot;);
2922     goto done;
2923   }
2924 no_drop:
2925   {
2926     GST_DEBUG_OBJECT (basesink, &quot;frame dropping disabled&quot;);
2927     goto done;
2928   }
2929 not_buffer:
2930   {
2931     GST_DEBUG_OBJECT (basesink, &quot;object is not a buffer&quot;);
2932     return FALSE;
2933   }
2934 no_timestamp:
2935   {
2936     GST_DEBUG_OBJECT (basesink, &quot;buffer has no timestamp&quot;);
2937     return FALSE;
2938   }
2939 }
2940 
2941 static void
2942 gst_base_sink_update_start_time (GstBaseSink * basesink)
2943 {
2944   GstClock *clock;
2945 
2946   GST_OBJECT_LOCK (basesink);
2947   if (GST_STATE (basesink) == GST_STATE_PLAYING
2948       &amp;&amp; (clock = GST_ELEMENT_CLOCK (basesink))) {
2949     GstClockTime now;
2950 
2951     gst_object_ref (clock);
2952     GST_OBJECT_UNLOCK (basesink);
2953 
2954     /* calculate the time when we stopped */
2955     now = gst_clock_get_time (clock);
2956     gst_object_unref (clock);
2957 
2958     GST_OBJECT_LOCK (basesink);
2959     /* store the current running time */
2960     if (GST_ELEMENT_START_TIME (basesink) != GST_CLOCK_TIME_NONE) {
2961       if (now != GST_CLOCK_TIME_NONE)
2962         GST_ELEMENT_START_TIME (basesink) =
2963             now - GST_ELEMENT_CAST (basesink)-&gt;base_time;
2964       else
2965         GST_WARNING_OBJECT (basesink,
2966             &quot;Clock %s returned invalid time, can&#39;t calculate &quot;
2967             &quot;running_time when going to the PAUSED state&quot;,
2968             GST_OBJECT_NAME (clock));
2969     }
2970     GST_DEBUG_OBJECT (basesink,
2971         &quot;start_time=%&quot; GST_TIME_FORMAT &quot;, now=%&quot; GST_TIME_FORMAT
2972         &quot;, base_time %&quot; GST_TIME_FORMAT,
2973         GST_TIME_ARGS (GST_ELEMENT_START_TIME (basesink)),
2974         GST_TIME_ARGS (now),
2975         GST_TIME_ARGS (GST_ELEMENT_CAST (basesink)-&gt;base_time));
2976   }
2977   GST_OBJECT_UNLOCK (basesink);
2978 }
2979 
2980 static void
2981 gst_base_sink_flush_start (GstBaseSink * basesink, GstPad * pad)
2982 {
2983   /* make sure we are not blocked on the clock also clear any pending
2984    * eos state. */
2985   gst_base_sink_set_flushing (basesink, pad, TRUE);
2986 
2987   /* we grab the stream lock but that is not needed since setting the
2988    * sink to flushing would make sure no state commit is being done
2989    * anymore */
2990   GST_PAD_STREAM_LOCK (pad);
2991   gst_base_sink_reset_qos (basesink);
2992   /* and we need to commit our state again on the next
2993    * prerolled buffer */
2994   basesink-&gt;playing_async = TRUE;
2995   if (basesink-&gt;priv-&gt;async_enabled) {
2996     gst_base_sink_update_start_time (basesink);
2997     gst_element_lost_state (GST_ELEMENT_CAST (basesink));
2998   } else {
2999     /* start time reset in above case as well;
3000      * arranges for a.o. proper position reporting when flushing in PAUSED */
3001     gst_element_set_start_time (GST_ELEMENT_CAST (basesink), 0);
3002     basesink-&gt;priv-&gt;have_latency = TRUE;
3003   }
3004   gst_base_sink_set_last_buffer (basesink, NULL);
3005   gst_base_sink_set_last_buffer_list (basesink, NULL);
3006   GST_PAD_STREAM_UNLOCK (pad);
3007 }
3008 
3009 static void
3010 gst_base_sink_flush_stop (GstBaseSink * basesink, GstPad * pad,
3011     gboolean reset_time)
3012 {
3013   /* unset flushing so we can accept new data, this also flushes out any EOS
3014    * event. */
3015   gst_base_sink_set_flushing (basesink, pad, FALSE);
3016 
3017   /* for position reporting */
3018   GST_OBJECT_LOCK (basesink);
3019   basesink-&gt;priv-&gt;current_sstart = GST_CLOCK_TIME_NONE;
3020   basesink-&gt;priv-&gt;current_sstop = GST_CLOCK_TIME_NONE;
3021   basesink-&gt;priv-&gt;eos_rtime = GST_CLOCK_TIME_NONE;
3022   basesink-&gt;priv-&gt;call_preroll = TRUE;
3023   basesink-&gt;priv-&gt;current_step.valid = FALSE;
3024   basesink-&gt;priv-&gt;pending_step.valid = FALSE;
3025   if (basesink-&gt;pad_mode == GST_PAD_MODE_PUSH) {
3026     /* we need new segment info after the flush. */
3027     basesink-&gt;have_newsegment = FALSE;
3028     if (reset_time) {
3029       gst_segment_init (&amp;basesink-&gt;segment, GST_FORMAT_UNDEFINED);
3030       GST_ELEMENT_START_TIME (basesink) = 0;
3031     }
3032   }
3033   GST_OBJECT_UNLOCK (basesink);
3034 
3035   if (reset_time) {
3036     GST_DEBUG_OBJECT (basesink, &quot;posting reset-time message&quot;);
3037     gst_element_post_message (GST_ELEMENT_CAST (basesink),
3038         gst_message_new_reset_time (GST_OBJECT_CAST (basesink), 0));
3039   }
3040 }
3041 
3042 static GstFlowReturn
3043 gst_base_sink_default_wait_event (GstBaseSink * basesink, GstEvent * event)
3044 {
3045   GstFlowReturn ret;
3046   gboolean late, step_end = FALSE;
3047 
3048   ret = gst_base_sink_do_sync (basesink, GST_MINI_OBJECT_CAST (event),
3049       &amp;late, &amp;step_end);
3050 
3051   return ret;
3052 }
3053 
3054 static GstFlowReturn
3055 gst_base_sink_wait_event (GstBaseSink * basesink, GstEvent * event)
3056 {
3057   GstFlowReturn ret;
3058   GstBaseSinkClass *bclass;
3059 
3060   bclass = GST_BASE_SINK_GET_CLASS (basesink);
3061 
3062   if (G_LIKELY (bclass-&gt;wait_event))
3063     ret = bclass-&gt;wait_event (basesink, event);
3064   else
3065     ret = GST_FLOW_NOT_SUPPORTED;
3066 
3067   return ret;
3068 }
3069 
3070 static gboolean
3071 gst_base_sink_default_event (GstBaseSink * basesink, GstEvent * event)
3072 {
3073   gboolean result = TRUE;
3074   GstBaseSinkClass *bclass;
3075 
3076   bclass = GST_BASE_SINK_GET_CLASS (basesink);
3077 
3078   switch (GST_EVENT_TYPE (event)) {
3079     case GST_EVENT_FLUSH_START:
3080     {
3081       GST_DEBUG_OBJECT (basesink, &quot;flush-start %p&quot;, event);
3082       gst_base_sink_flush_start (basesink, basesink-&gt;sinkpad);
3083       break;
3084     }
3085     case GST_EVENT_FLUSH_STOP:
3086     {
3087       gboolean reset_time;
3088 
3089       gst_event_parse_flush_stop (event, &amp;reset_time);
3090       GST_DEBUG_OBJECT (basesink, &quot;flush-stop %p, reset_time: %d&quot;, event,
3091           reset_time);
3092       gst_base_sink_flush_stop (basesink, basesink-&gt;sinkpad, reset_time);
3093       break;
3094     }
3095     case GST_EVENT_EOS:
3096     {
3097       GstMessage *message;
3098       guint32 seqnum;
3099 
3100       /* we set the received EOS flag here so that we can use it when testing if
3101        * we are prerolled and to refuse more buffers. */
3102       basesink-&gt;priv-&gt;received_eos = TRUE;
3103 
3104       /* wait for EOS */
3105       if (G_UNLIKELY (gst_base_sink_wait_event (basesink,
3106                   event) != GST_FLOW_OK)) {
3107         result = FALSE;
3108         goto done;
3109       }
3110 
3111       /* the EOS event is completely handled so we mark
3112        * ourselves as being in the EOS state. eos is also
3113        * protected by the object lock so we can read it when
3114        * answering the POSITION query. */
3115       GST_OBJECT_LOCK (basesink);
3116       basesink-&gt;eos = TRUE;
3117       GST_OBJECT_UNLOCK (basesink);
3118 
3119       /* ok, now we can post the message */
3120       GST_DEBUG_OBJECT (basesink, &quot;Now posting EOS&quot;);
3121 
3122       seqnum = basesink-&gt;priv-&gt;seqnum = gst_event_get_seqnum (event);
3123       GST_DEBUG_OBJECT (basesink, &quot;Got seqnum #%&quot; G_GUINT32_FORMAT, seqnum);
3124 
3125       message = gst_message_new_eos (GST_OBJECT_CAST (basesink));
3126       gst_message_set_seqnum (message, seqnum);
3127       gst_element_post_message (GST_ELEMENT_CAST (basesink), message);
3128       break;
3129     }
3130     case GST_EVENT_STREAM_START:
3131     {
3132       GstMessage *message;
3133       guint32 seqnum;
3134       guint group_id;
3135 
3136       seqnum = gst_event_get_seqnum (event);
3137       GST_DEBUG_OBJECT (basesink, &quot;Now posting STREAM_START (seqnum:%d)&quot;,
3138           seqnum);
3139       message = gst_message_new_stream_start (GST_OBJECT_CAST (basesink));
3140       if (gst_event_parse_group_id (event, &amp;group_id)) {
3141         gst_message_set_group_id (message, group_id);
3142       } else {
3143         GST_FIXME_OBJECT (basesink, &quot;stream-start event without group-id. &quot;
3144             &quot;Consider implementing group-id handling in the upstream &quot;
3145             &quot;elements&quot;);
3146       }
3147       gst_message_set_seqnum (message, seqnum);
3148       gst_element_post_message (GST_ELEMENT_CAST (basesink), message);
3149       break;
3150     }
3151     case GST_EVENT_CAPS:
3152     {
3153       GstCaps *caps, *current_caps;
3154 
3155       GST_DEBUG_OBJECT (basesink, &quot;caps %p&quot;, event);
3156 
3157       gst_event_parse_caps (event, &amp;caps);
3158       current_caps = gst_pad_get_current_caps (GST_BASE_SINK_PAD (basesink));
3159 
3160       if (current_caps &amp;&amp; gst_caps_is_equal (current_caps, caps)) {
3161         GST_DEBUG_OBJECT (basesink,
3162             &quot;New caps equal to old ones: %&quot; GST_PTR_FORMAT, caps);
3163       } else {
3164         if (bclass-&gt;set_caps)
3165           result = bclass-&gt;set_caps (basesink, caps);
3166 
3167         if (result) {
3168           GST_OBJECT_LOCK (basesink);
3169           gst_caps_replace (&amp;basesink-&gt;priv-&gt;caps, caps);
3170           GST_OBJECT_UNLOCK (basesink);
3171         }
3172       }
3173       if (current_caps)
3174         gst_caps_unref (current_caps);
3175       break;
3176     }
3177     case GST_EVENT_SEGMENT:
3178       /* configure the segment */
3179       /* The segment is protected with both the STREAM_LOCK and the OBJECT_LOCK.
3180        * We protect with the OBJECT_LOCK so that we can use the values to
3181        * safely answer a POSITION query. */
3182       GST_OBJECT_LOCK (basesink);
3183       /* the newsegment event is needed to bring the buffer timestamps to the
3184        * stream time and to drop samples outside of the playback segment. */
3185       gst_event_copy_segment (event, &amp;basesink-&gt;segment);
3186       GST_DEBUG_OBJECT (basesink, &quot;configured segment %&quot; GST_SEGMENT_FORMAT,
3187           &amp;basesink-&gt;segment);
3188       basesink-&gt;have_newsegment = TRUE;
3189       gst_base_sink_reset_qos (basesink);
3190       GST_OBJECT_UNLOCK (basesink);
3191       break;
3192     case GST_EVENT_GAP:
3193     {
3194       if (G_UNLIKELY (gst_base_sink_wait_event (basesink,
3195                   event) != GST_FLOW_OK))
3196         result = FALSE;
3197       break;
3198     }
3199     case GST_EVENT_TAG:
3200     {
3201       GstTagList *taglist;
3202 
3203       gst_event_parse_tag (event, &amp;taglist);
3204 
3205       gst_element_post_message (GST_ELEMENT_CAST (basesink),
3206           gst_message_new_tag (GST_OBJECT_CAST (basesink),
3207               gst_tag_list_copy (taglist)));
3208       break;
3209     }
3210     case GST_EVENT_TOC:
3211     {
3212       GstToc *toc;
3213       gboolean updated;
3214 
3215       gst_event_parse_toc (event, &amp;toc, &amp;updated);
3216 
3217       gst_element_post_message (GST_ELEMENT_CAST (basesink),
3218           gst_message_new_toc (GST_OBJECT_CAST (basesink), toc, updated));
3219 
3220       gst_toc_unref (toc);
3221       break;
3222     }
3223     case GST_EVENT_SINK_MESSAGE:
3224     {
3225       GstMessage *msg = NULL;
3226 
3227       gst_event_parse_sink_message (event, &amp;msg);
3228       if (msg)
3229         gst_element_post_message (GST_ELEMENT_CAST (basesink), msg);
3230       break;
3231     }
3232     default:
3233       break;
3234   }
3235 done:
3236   gst_event_unref (event);
3237 
3238   return result;
3239 }
3240 
3241 static gboolean
3242 gst_base_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
3243 {
3244   GstBaseSink *basesink;
3245   gboolean result = TRUE;
3246   GstBaseSinkClass *bclass;
3247 
3248   basesink = GST_BASE_SINK_CAST (parent);
3249   bclass = GST_BASE_SINK_GET_CLASS (basesink);
3250 
3251   GST_DEBUG_OBJECT (basesink, &quot;received event %p %&quot; GST_PTR_FORMAT, event,
3252       event);
3253 
3254   switch (GST_EVENT_TYPE (event)) {
3255     case GST_EVENT_FLUSH_STOP:
3256       /* special case for this serialized event because we don&#39;t want to grab
3257        * the PREROLL lock or check if we were flushing */
3258       if (bclass-&gt;event)
3259         result = bclass-&gt;event (basesink, event);
3260       break;
3261     default:
3262       if (GST_EVENT_IS_SERIALIZED (event)) {
3263         GST_BASE_SINK_PREROLL_LOCK (basesink);
3264         if (G_UNLIKELY (basesink-&gt;flushing))
3265           goto flushing;
3266 
3267         if (G_UNLIKELY (basesink-&gt;priv-&gt;received_eos))
3268           goto after_eos;
3269 
3270         if (bclass-&gt;event)
3271           result = bclass-&gt;event (basesink, event);
3272 
3273         GST_BASE_SINK_PREROLL_UNLOCK (basesink);
3274       } else {
3275         if (bclass-&gt;event)
3276           result = bclass-&gt;event (basesink, event);
3277       }
3278       break;
3279   }
3280 done:
3281   return result;
3282 
3283   /* ERRORS */
3284 flushing:
3285   {
3286     GST_DEBUG_OBJECT (basesink, &quot;we are flushing&quot;);
3287     GST_BASE_SINK_PREROLL_UNLOCK (basesink);
3288     gst_event_unref (event);
3289     result = FALSE;
3290     goto done;
3291   }
3292 
3293 after_eos:
3294   {
3295     GST_DEBUG_OBJECT (basesink, &quot;Event received after EOS, dropping&quot;);
3296     GST_BASE_SINK_PREROLL_UNLOCK (basesink);
3297     gst_event_unref (event);
3298     result = FALSE;
3299     goto done;
3300   }
3301 }
3302 
3303 /* default implementation to calculate the start and end
3304  * timestamps on a buffer, subclasses can override
3305  */
3306 static void
3307 gst_base_sink_default_get_times (GstBaseSink * basesink, GstBuffer * buffer,
3308     GstClockTime * start, GstClockTime * end)
3309 {
3310   GstClockTime timestamp, duration;
3311 
3312   /* first sync on DTS, else use PTS */
3313   timestamp = GST_BUFFER_DTS (buffer);
3314   if (!GST_CLOCK_TIME_IS_VALID (timestamp))
3315     timestamp = GST_BUFFER_PTS (buffer);
3316 
3317   if (GST_CLOCK_TIME_IS_VALID (timestamp)) {
3318     /* get duration to calculate end time */
3319     duration = GST_BUFFER_DURATION (buffer);
3320     if (GST_CLOCK_TIME_IS_VALID (duration)) {
3321       *end = timestamp + duration;
3322     }
3323     *start = timestamp;
3324   }
3325 }
3326 
3327 /* must be called with PREROLL_LOCK */
3328 static gboolean
3329 gst_base_sink_needs_preroll (GstBaseSink * basesink)
3330 {
3331   gboolean is_prerolled, res;
3332 
3333   /* we have 2 cases where the PREROLL_LOCK is released:
3334    *  1) we are blocking in the PREROLL_LOCK and thus are prerolled.
3335    *  2) we are syncing on the clock
3336    */
3337   is_prerolled = basesink-&gt;have_preroll || basesink-&gt;priv-&gt;received_eos;
3338   res = !is_prerolled;
3339 
3340   GST_DEBUG_OBJECT (basesink, &quot;have_preroll: %d, EOS: %d =&gt; needs preroll: %d&quot;,
3341       basesink-&gt;have_preroll, basesink-&gt;priv-&gt;received_eos, res);
3342 
3343   return res;
3344 }
3345 
3346 /* with STREAM_LOCK, PREROLL_LOCK
3347  *
3348  * Takes a buffer and compare the timestamps with the last segment.
3349  * If the buffer falls outside of the segment boundaries, drop it.
3350  * Else send the buffer for preroll and rendering.
3351  *
3352  * This function takes ownership of the buffer.
3353  */
3354 static GstFlowReturn
3355 gst_base_sink_chain_unlocked (GstBaseSink * basesink, GstPad * pad,
3356     gpointer obj, gboolean is_list)
3357 {
3358   GstBaseSinkClass *bclass;
3359   GstBaseSinkPrivate *priv = basesink-&gt;priv;
3360   GstFlowReturn ret = GST_FLOW_OK;
3361   GstClockTime start = GST_CLOCK_TIME_NONE, end = GST_CLOCK_TIME_NONE;
3362   GstSegment *segment;
3363   GstBuffer *sync_buf;
3364   gboolean late, step_end, prepared = FALSE;
3365 
3366   if (G_UNLIKELY (basesink-&gt;flushing))
3367     goto flushing;
3368 
3369   if (G_UNLIKELY (priv-&gt;received_eos))
3370     goto was_eos;
3371 
3372   if (is_list) {
3373     GstBufferList *buffer_list = GST_BUFFER_LIST_CAST (obj);
3374 
3375     if (gst_buffer_list_length (buffer_list) == 0)
3376       goto empty_list;
3377 
3378     sync_buf = gst_buffer_list_get (buffer_list, 0);
3379     g_assert (NULL != sync_buf);
3380   } else {
3381     sync_buf = GST_BUFFER_CAST (obj);
3382   }
3383 
3384   /* for code clarity */
3385   segment = &amp;basesink-&gt;segment;
3386 
3387   if (G_UNLIKELY (!basesink-&gt;have_newsegment)) {
3388     gboolean sync;
3389 
3390     sync = gst_base_sink_get_sync (basesink);
3391     if (sync) {
3392       GST_ELEMENT_WARNING (basesink, STREAM, FAILED,
3393           (_(&quot;Internal data flow problem.&quot;)),
3394           (&quot;Received buffer without a new-segment. Assuming timestamps start from 0.&quot;));
3395     }
3396 
3397     /* this means this sink will assume timestamps start from 0 */
3398     GST_OBJECT_LOCK (basesink);
3399     segment-&gt;start = 0;
3400     segment-&gt;stop = -1;
3401     basesink-&gt;segment.start = 0;
3402     basesink-&gt;segment.stop = -1;
3403     basesink-&gt;have_newsegment = TRUE;
3404     GST_OBJECT_UNLOCK (basesink);
3405   }
3406 
3407   bclass = GST_BASE_SINK_GET_CLASS (basesink);
3408 
3409   /* check if the buffer needs to be dropped, we first ask the subclass for the
3410    * start and end */
3411   if (bclass-&gt;get_times)
3412     bclass-&gt;get_times (basesink, sync_buf, &amp;start, &amp;end);
3413 
3414   if (!GST_CLOCK_TIME_IS_VALID (start)) {
3415     /* if the subclass does not want sync, we use our own values so that we at
3416      * least clip the buffer to the segment */
3417     gst_base_sink_default_get_times (basesink, sync_buf, &amp;start, &amp;end);
3418   }
3419 
3420   GST_DEBUG_OBJECT (basesink, &quot;got times start: %&quot; GST_TIME_FORMAT
3421       &quot;, end: %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (start), GST_TIME_ARGS (end));
3422 
3423   /* a dropped buffer does not participate in anything. Buffer can only be
3424    * dropped if their PTS falls completly outside the segment, while we sync
3425    * preferably on DTS */
3426   if (GST_CLOCK_TIME_IS_VALID (start) &amp;&amp; (segment-&gt;format == GST_FORMAT_TIME)) {
3427     GstClockTime pts = GST_BUFFER_PTS (sync_buf);
3428     GstClockTime pts_end = GST_CLOCK_TIME_NONE;
3429 
3430     if (!GST_CLOCK_TIME_IS_VALID (pts))
3431       pts = start;
3432 
3433     if (GST_CLOCK_TIME_IS_VALID (end))
3434       pts_end = pts + (end - start);
3435 
3436     if (G_UNLIKELY (!gst_segment_clip (segment,
3437                 GST_FORMAT_TIME, pts, pts_end, NULL, NULL)
3438             &amp;&amp; priv-&gt;drop_out_of_segment))
3439       goto out_of_segment;
3440   }
3441 
3442   if (bclass-&gt;prepare || bclass-&gt;prepare_list) {
3443     gboolean do_sync = TRUE, stepped = FALSE, syncable = TRUE;
3444     GstClockTime sstart, sstop, rstart, rstop, rnext;
3445     GstStepInfo *current;
3446 
3447     late = FALSE;
3448     step_end = FALSE;
3449 
3450     current = &amp;priv-&gt;current_step;
3451     syncable =
3452         gst_base_sink_get_sync_times (basesink, obj, &amp;sstart, &amp;sstop, &amp;rstart,
3453         &amp;rstop, &amp;rnext, &amp;do_sync, &amp;stepped, current, &amp;step_end);
3454 
3455     if (G_UNLIKELY (stepped))
3456       goto dropped;
3457 
3458     if (syncable &amp;&amp; do_sync &amp;&amp; gst_base_sink_get_sync (basesink)) {
3459       GstClock *clock;
3460 
3461       GST_OBJECT_LOCK (basesink);
3462       clock = GST_ELEMENT_CLOCK (basesink);
3463       if (clock &amp;&amp; GST_STATE (basesink) == GST_STATE_PLAYING) {
3464         GstClockTime base_time;
3465         GstClockTime stime;
3466         GstClockTime now;
3467 
3468         base_time = GST_ELEMENT_CAST (basesink)-&gt;base_time;
3469         stime = base_time + gst_base_sink_adjust_time (basesink, rstart);
3470         now = gst_clock_get_time (clock);
3471         GST_OBJECT_UNLOCK (basesink);
3472 
3473         late =
3474             gst_base_sink_is_too_late (basesink, obj, rstart, rstop,
3475             GST_CLOCK_EARLY, GST_CLOCK_DIFF (stime, now), FALSE);
3476       } else {
3477         GST_OBJECT_UNLOCK (basesink);
3478       }
3479     }
3480 
3481     /* We are about to prepare the first frame, make sure we have prerolled
3482      * already. This prevent nesting prepare/render calls. */
3483     ret = gst_base_sink_do_preroll (basesink, obj);
3484     if (G_UNLIKELY (ret != GST_FLOW_OK))
3485       goto preroll_failed;
3486 
3487     if (G_UNLIKELY (late))
3488       goto dropped;
3489 
3490     if (!is_list) {
3491       if (bclass-&gt;prepare) {
3492         ret = bclass-&gt;prepare (basesink, GST_BUFFER_CAST (obj));
3493         if (G_UNLIKELY (ret != GST_FLOW_OK))
3494           goto prepare_failed;
3495       }
3496     } else {
3497       if (bclass-&gt;prepare_list) {
3498         ret = bclass-&gt;prepare_list (basesink, GST_BUFFER_LIST_CAST (obj));
3499         if (G_UNLIKELY (ret != GST_FLOW_OK))
3500           goto prepare_failed;
3501       }
3502     }
3503 
3504     prepared = TRUE;
3505   }
3506 
3507 again:
3508   late = FALSE;
3509   step_end = FALSE;
3510 
3511   /* synchronize this object, non syncable objects return OK
3512    * immediately. */
3513   ret = gst_base_sink_do_sync (basesink, GST_MINI_OBJECT_CAST (sync_buf),
3514       &amp;late, &amp;step_end);
3515   if (G_UNLIKELY (ret != GST_FLOW_OK))
3516     goto sync_failed;
3517 
3518   /* Don&#39;t skip if prepare() was called on time */
3519   late = late &amp;&amp; !prepared;
3520 
3521   /* drop late buffers unconditionally, let&#39;s hope it&#39;s unlikely */
3522   if (G_UNLIKELY (late))
3523     goto dropped;
3524 
3525   if (priv-&gt;max_bitrate) {
3526     gsize size;
3527 
3528     if (is_list)
3529       size = gst_buffer_list_calculate_size (GST_BUFFER_LIST_CAST (obj));
3530     else
3531       size = gst_buffer_get_size (GST_BUFFER_CAST (obj));
3532 
3533     priv-&gt;rc_accumulated += size;
3534     priv-&gt;rc_next = priv-&gt;rc_time + gst_util_uint64_scale (priv-&gt;rc_accumulated,
3535         8 * GST_SECOND, priv-&gt;max_bitrate);
3536   }
3537 
3538   GST_DEBUG_OBJECT (basesink, &quot;rendering object %p&quot;, obj);
3539 
3540   if (!is_list) {
3541     /* For buffer lists do not set last buffer for now. */
3542     gst_base_sink_set_last_buffer (basesink, GST_BUFFER_CAST (obj));
3543     gst_base_sink_set_last_buffer_list (basesink, NULL);
3544 
3545     if (bclass-&gt;render)
3546       ret = bclass-&gt;render (basesink, GST_BUFFER_CAST (obj));
3547   } else {
3548     GstBufferList *buffer_list = GST_BUFFER_LIST_CAST (obj);
3549 
3550     if (bclass-&gt;render_list)
3551       ret = bclass-&gt;render_list (basesink, buffer_list);
3552 
3553     /* Set the first buffer and buffer list to be included in last sample */
3554     gst_base_sink_set_last_buffer (basesink, sync_buf);
3555     gst_base_sink_set_last_buffer_list (basesink, buffer_list);
3556   }
3557 
3558   if (ret == GST_FLOW_STEP)
3559     goto again;
3560 
3561   if (G_UNLIKELY (basesink-&gt;flushing))
3562     goto flushing;
3563 
3564   priv-&gt;rendered++;
3565 
3566 done:
3567   if (step_end) {
3568     /* the step ended, check if we need to activate a new step */
3569     GST_DEBUG_OBJECT (basesink, &quot;step ended&quot;);
3570     stop_stepping (basesink, &amp;basesink-&gt;segment, &amp;priv-&gt;current_step,
3571         priv-&gt;current_rstart, priv-&gt;current_rstop, basesink-&gt;eos);
3572     goto again;
3573   }
3574 
3575   gst_base_sink_perform_qos (basesink, late);
3576 
3577   GST_DEBUG_OBJECT (basesink, &quot;object unref after render %p&quot;, obj);
3578   gst_mini_object_unref (GST_MINI_OBJECT_CAST (obj));
3579 
3580   return ret;
3581 
3582   /* ERRORS */
3583 flushing:
3584   {
3585     GST_DEBUG_OBJECT (basesink, &quot;sink is flushing&quot;);
3586     gst_mini_object_unref (GST_MINI_OBJECT_CAST (obj));
3587     return GST_FLOW_FLUSHING;
3588   }
3589 was_eos:
3590   {
3591     GST_DEBUG_OBJECT (basesink, &quot;we are EOS, dropping object, return EOS&quot;);
3592     gst_mini_object_unref (GST_MINI_OBJECT_CAST (obj));
3593     return GST_FLOW_EOS;
3594   }
3595 empty_list:
3596   {
3597     GST_DEBUG_OBJECT (basesink, &quot;buffer list with no buffers&quot;);
3598     gst_mini_object_unref (GST_MINI_OBJECT_CAST (obj));
3599     return GST_FLOW_OK;
3600   }
3601 out_of_segment:
3602   {
3603     GST_DEBUG_OBJECT (basesink, &quot;dropping buffer, out of clipping segment&quot;);
3604     gst_mini_object_unref (GST_MINI_OBJECT_CAST (obj));
3605     return GST_FLOW_OK;
3606   }
3607 prepare_failed:
3608   {
3609     GST_DEBUG_OBJECT (basesink, &quot;prepare buffer failed %s&quot;,
3610         gst_flow_get_name (ret));
3611     gst_mini_object_unref (GST_MINI_OBJECT_CAST (obj));
3612     return ret;
3613   }
3614 sync_failed:
3615   {
3616     GST_DEBUG_OBJECT (basesink, &quot;do_sync returned %s&quot;, gst_flow_get_name (ret));
3617     goto done;
3618   }
3619 dropped:
3620   {
3621     priv-&gt;dropped++;
3622     GST_DEBUG_OBJECT (basesink, &quot;buffer late, dropping&quot;);
3623 
3624     if (g_atomic_int_get (&amp;priv-&gt;qos_enabled)) {
3625       GstMessage *qos_msg;
3626       GstClockTime timestamp, duration;
3627 
3628       timestamp = GST_BUFFER_TIMESTAMP (GST_BUFFER_CAST (sync_buf));
3629       duration = GST_BUFFER_DURATION (GST_BUFFER_CAST (sync_buf));
3630 
3631       GST_CAT_DEBUG_OBJECT (GST_CAT_QOS, basesink,
3632           &quot;qos: dropped buffer rt %&quot; GST_TIME_FORMAT &quot;, st %&quot; GST_TIME_FORMAT
3633           &quot;, ts %&quot; GST_TIME_FORMAT &quot;, dur %&quot; GST_TIME_FORMAT,
3634           GST_TIME_ARGS (priv-&gt;current_rstart),
3635           GST_TIME_ARGS (priv-&gt;current_sstart), GST_TIME_ARGS (timestamp),
3636           GST_TIME_ARGS (duration));
3637       GST_CAT_DEBUG_OBJECT (GST_CAT_QOS, basesink,
3638           &quot;qos: rendered %&quot; G_GUINT64_FORMAT &quot;, dropped %&quot; G_GUINT64_FORMAT,
3639           priv-&gt;rendered, priv-&gt;dropped);
3640 
3641       qos_msg =
3642           gst_message_new_qos (GST_OBJECT_CAST (basesink), basesink-&gt;sync,
3643           priv-&gt;current_rstart, priv-&gt;current_sstart, timestamp, duration);
3644       gst_message_set_qos_values (qos_msg, priv-&gt;current_jitter, priv-&gt;avg_rate,
3645           1000000);
3646       gst_message_set_qos_stats (qos_msg, GST_FORMAT_BUFFERS, priv-&gt;rendered,
3647           priv-&gt;dropped);
3648       gst_element_post_message (GST_ELEMENT_CAST (basesink), qos_msg);
3649     }
3650     goto done;
3651   }
3652 preroll_failed:
3653   {
3654     GST_DEBUG_OBJECT (basesink, &quot;preroll failed: %s&quot;, gst_flow_get_name (ret));
3655     gst_mini_object_unref (GST_MINI_OBJECT_CAST (obj));
3656     return ret;
3657   }
3658 }
3659 
3660 /* with STREAM_LOCK
3661  */
3662 static GstFlowReturn
3663 gst_base_sink_chain_main (GstBaseSink * basesink, GstPad * pad, gpointer obj,
3664     gboolean is_list)
3665 {
3666   GstFlowReturn result;
3667 
3668   if (G_UNLIKELY (basesink-&gt;pad_mode != GST_PAD_MODE_PUSH))
3669     goto wrong_mode;
3670 
3671   GST_BASE_SINK_PREROLL_LOCK (basesink);
3672   result = gst_base_sink_chain_unlocked (basesink, pad, obj, is_list);
3673   GST_BASE_SINK_PREROLL_UNLOCK (basesink);
3674 
3675 done:
3676   return result;
3677 
3678   /* ERRORS */
3679 wrong_mode:
3680   {
3681     GST_OBJECT_LOCK (pad);
3682     GST_WARNING_OBJECT (basesink,
3683         &quot;Push on pad %s:%s, but it was not activated in push mode&quot;,
3684         GST_DEBUG_PAD_NAME (pad));
3685     GST_OBJECT_UNLOCK (pad);
3686     gst_mini_object_unref (GST_MINI_OBJECT_CAST (obj));
3687     /* we don&#39;t post an error message this will signal to the peer
3688      * pushing that EOS is reached. */
3689     result = GST_FLOW_EOS;
3690     goto done;
3691   }
3692 }
3693 
3694 static GstFlowReturn
3695 gst_base_sink_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
3696 {
3697   GstBaseSink *basesink;
3698 
3699   basesink = GST_BASE_SINK (parent);
3700 
3701   return gst_base_sink_chain_main (basesink, pad, buf, FALSE);
3702 }
3703 
3704 static GstFlowReturn
3705 gst_base_sink_chain_list (GstPad * pad, GstObject * parent,
3706     GstBufferList * list)
3707 {
3708   GstBaseSink *basesink;
3709   GstBaseSinkClass *bclass;
3710   GstFlowReturn result;
3711 
3712   basesink = GST_BASE_SINK (parent);
3713   bclass = GST_BASE_SINK_GET_CLASS (basesink);
3714 
3715   if (G_LIKELY (bclass-&gt;render_list)) {
3716     result = gst_base_sink_chain_main (basesink, pad, list, TRUE);
3717   } else {
3718     guint i, len;
3719     GstBuffer *buffer;
3720 
3721     GST_LOG_OBJECT (pad, &quot;chaining each buffer in list&quot;);
3722 
3723     len = gst_buffer_list_length (list);
3724 
3725     result = GST_FLOW_OK;
3726     for (i = 0; i &lt; len; i++) {
3727       buffer = gst_buffer_list_get (list, i);
3728       result = gst_base_sink_chain_main (basesink, pad,
3729           gst_buffer_ref (buffer), FALSE);
3730       if (result != GST_FLOW_OK)
3731         break;
3732     }
3733     gst_buffer_list_unref (list);
3734   }
3735   return result;
3736 }
3737 
3738 
3739 static gboolean
3740 gst_base_sink_default_do_seek (GstBaseSink * sink, GstSegment * segment)
3741 {
3742   gboolean res = TRUE;
3743 
3744   /* update our offset if the start/stop position was updated */
3745   if (segment-&gt;format == GST_FORMAT_BYTES) {
3746     segment-&gt;time = segment-&gt;start;
3747   } else if (segment-&gt;start == 0) {
3748     /* seek to start, we can implement a default for this. */
3749     segment-&gt;time = 0;
3750   } else {
3751     res = FALSE;
3752     GST_INFO_OBJECT (sink, &quot;Can&#39;t do a default seek&quot;);
3753   }
3754 
3755   return res;
3756 }
3757 
3758 #define SEEK_TYPE_IS_RELATIVE(t) (((t) != GST_SEEK_TYPE_NONE) &amp;&amp; ((t) != GST_SEEK_TYPE_SET))
3759 
3760 static gboolean
3761 gst_base_sink_default_prepare_seek_segment (GstBaseSink * sink,
3762     GstEvent * event, GstSegment * segment)
3763 {
3764   /* By default, we try one of 2 things:
3765    *   - For absolute seek positions, convert the requested position to our
3766    *     configured processing format and place it in the output segment \
3767    *   - For relative seek positions, convert our current (input) values to the
3768    *     seek format, adjust by the relative seek offset and then convert back to
3769    *     the processing format
3770    */
3771   GstSeekType start_type, stop_type;
3772   gint64 start, stop;
3773   GstSeekFlags flags;
3774   GstFormat seek_format;
3775   gdouble rate;
3776   gboolean update;
3777   gboolean res = TRUE;
3778 
3779   gst_event_parse_seek (event, &amp;rate, &amp;seek_format, &amp;flags,
3780       &amp;start_type, &amp;start, &amp;stop_type, &amp;stop);
3781 
3782   if (seek_format == segment-&gt;format) {
3783     gst_segment_do_seek (segment, rate, seek_format, flags,
3784         start_type, start, stop_type, stop, &amp;update);
3785     return TRUE;
3786   }
3787 
3788   if (start_type != GST_SEEK_TYPE_NONE) {
3789     /* FIXME: Handle seek_end by converting the input segment vals */
3790     res =
3791         gst_pad_query_convert (sink-&gt;sinkpad, seek_format, start,
3792         segment-&gt;format, &amp;start);
3793     start_type = GST_SEEK_TYPE_SET;
3794   }
3795 
3796   if (res &amp;&amp; stop_type != GST_SEEK_TYPE_NONE) {
3797     /* FIXME: Handle seek_end by converting the input segment vals */
3798     res =
3799         gst_pad_query_convert (sink-&gt;sinkpad, seek_format, stop,
3800         segment-&gt;format, &amp;stop);
3801     stop_type = GST_SEEK_TYPE_SET;
3802   }
3803 
3804   /* And finally, configure our output segment in the desired format */
3805   gst_segment_do_seek (segment, rate, segment-&gt;format, flags, start_type, start,
3806       stop_type, stop, &amp;update);
3807 
3808   if (!res)
3809     goto no_format;
3810 
3811   return res;
3812 
3813 no_format:
3814   {
3815     GST_DEBUG_OBJECT (sink, &quot;undefined format given, seek aborted.&quot;);
3816     return FALSE;
3817   }
3818 }
3819 
3820 /* perform a seek, only executed in pull mode */
3821 static gboolean
3822 gst_base_sink_perform_seek (GstBaseSink * sink, GstPad * pad, GstEvent * event)
3823 {
3824   gboolean flush;
3825   gdouble rate;
3826   GstFormat seek_format, dest_format;
3827   GstSeekFlags flags;
3828   GstSeekType start_type, stop_type;
3829   gboolean seekseg_configured = FALSE;
3830   gint64 start, stop;
3831   gboolean update, res = TRUE;
3832   GstSegment seeksegment;
3833 
3834   dest_format = sink-&gt;segment.format;
3835 
3836   if (event) {
3837     GST_DEBUG_OBJECT (sink, &quot;performing seek with event %p&quot;, event);
3838     gst_event_parse_seek (event, &amp;rate, &amp;seek_format, &amp;flags,
3839         &amp;start_type, &amp;start, &amp;stop_type, &amp;stop);
3840 
3841     flush = flags &amp; GST_SEEK_FLAG_FLUSH;
3842   } else {
3843     GST_DEBUG_OBJECT (sink, &quot;performing seek without event&quot;);
3844     flush = FALSE;
3845   }
3846 
3847   if (flush) {
3848     GST_DEBUG_OBJECT (sink, &quot;flushing upstream&quot;);
3849     gst_pad_push_event (pad, gst_event_new_flush_start ());
3850     gst_base_sink_flush_start (sink, pad);
3851   } else {
3852     GST_DEBUG_OBJECT (sink, &quot;pausing pulling thread&quot;);
3853   }
3854 
3855   GST_PAD_STREAM_LOCK (pad);
3856 
3857   /* If we configured the seeksegment above, don&#39;t overwrite it now. Otherwise
3858    * copy the current segment info into the temp segment that we can actually
3859    * attempt the seek with. We only update the real segment if the seek succeeds. */
3860   if (!seekseg_configured) {
3861     memcpy (&amp;seeksegment, &amp;sink-&gt;segment, sizeof (GstSegment));
3862 
3863     /* now configure the final seek segment */
3864     if (event) {
3865       if (sink-&gt;segment.format != seek_format) {
3866         /* OK, here&#39;s where we give the subclass a chance to convert the relative
3867          * seek into an absolute one in the processing format. We set up any
3868          * absolute seek above, before taking the stream lock. */
3869         if (!gst_base_sink_default_prepare_seek_segment (sink, event,
3870                 &amp;seeksegment)) {
3871           GST_DEBUG_OBJECT (sink,
3872               &quot;Preparing the seek failed after flushing. &quot; &quot;Aborting seek&quot;);
3873           res = FALSE;
3874         }
3875       } else {
3876         /* The seek format matches our processing format, no need to ask the
3877          * the subclass to configure the segment. */
3878         gst_segment_do_seek (&amp;seeksegment, rate, seek_format, flags,
3879             start_type, start, stop_type, stop, &amp;update);
3880       }
3881     }
3882     /* Else, no seek event passed, so we&#39;re just (re)starting the
3883        current segment. */
3884   }
3885 
3886   if (res) {
3887     GST_DEBUG_OBJECT (sink, &quot;segment configured from %&quot; G_GINT64_FORMAT
3888         &quot; to %&quot; G_GINT64_FORMAT &quot;, position %&quot; G_GINT64_FORMAT,
3889         seeksegment.start, seeksegment.stop, seeksegment.position);
3890 
3891     /* do the seek, segment.position contains the new position. */
3892     res = gst_base_sink_default_do_seek (sink, &amp;seeksegment);
3893   }
3894 
3895   if (flush) {
3896     GST_DEBUG_OBJECT (sink, &quot;stop flushing upstream&quot;);
3897     gst_pad_push_event (pad, gst_event_new_flush_stop (TRUE));
3898     gst_base_sink_flush_stop (sink, pad, TRUE);
3899   } else if (res &amp;&amp; sink-&gt;running) {
3900     /* we are running the current segment and doing a non-flushing seek,
3901      * close the segment first based on the position. */
3902     GST_DEBUG_OBJECT (sink, &quot;closing running segment %&quot; G_GINT64_FORMAT
3903         &quot; to %&quot; G_GINT64_FORMAT, sink-&gt;segment.start, sink-&gt;segment.position);
3904   }
3905 
3906   /* The subclass must have converted the segment to the processing format
3907    * by now */
3908   if (res &amp;&amp; seeksegment.format != dest_format) {
3909     GST_DEBUG_OBJECT (sink, &quot;Subclass failed to prepare a seek segment &quot;
3910         &quot;in the correct format. Aborting seek.&quot;);
3911     res = FALSE;
3912   }
3913 
3914   GST_INFO_OBJECT (sink, &quot;seeking done %d: %&quot; GST_SEGMENT_FORMAT, res,
3915       &amp;seeksegment);
3916 
3917   /* if successful seek, we update our real segment and push
3918    * out the new segment. */
3919   if (res) {
3920     gst_segment_copy_into (&amp;seeksegment, &amp;sink-&gt;segment);
3921 
3922     if (sink-&gt;segment.flags &amp; GST_SEGMENT_FLAG_SEGMENT) {
3923       gst_element_post_message (GST_ELEMENT (sink),
3924           gst_message_new_segment_start (GST_OBJECT (sink),
3925               sink-&gt;segment.format, sink-&gt;segment.position));
3926     }
3927   }
3928 
3929   sink-&gt;priv-&gt;discont = TRUE;
3930   sink-&gt;running = TRUE;
3931 
3932   GST_PAD_STREAM_UNLOCK (pad);
3933 
3934   return res;
3935 }
3936 
3937 static void
3938 set_step_info (GstBaseSink * sink, GstStepInfo * current, GstStepInfo * pending,
3939     guint seqnum, GstFormat format, guint64 amount, gdouble rate,
3940     gboolean flush, gboolean intermediate)
3941 {
3942   GST_OBJECT_LOCK (sink);
3943   pending-&gt;seqnum = seqnum;
3944   pending-&gt;format = format;
3945   pending-&gt;amount = amount;
3946   pending-&gt;position = 0;
3947   pending-&gt;rate = rate;
3948   pending-&gt;flush = flush;
3949   pending-&gt;intermediate = intermediate;
3950   pending-&gt;valid = TRUE;
3951   /* flush invalidates the current stepping segment */
3952   if (flush)
3953     current-&gt;valid = FALSE;
3954   GST_OBJECT_UNLOCK (sink);
3955 }
3956 
3957 static gboolean
3958 gst_base_sink_perform_step (GstBaseSink * sink, GstPad * pad, GstEvent * event)
3959 {
3960   GstBaseSinkPrivate *priv;
3961   GstBaseSinkClass *bclass;
3962   gboolean flush, intermediate;
3963   gdouble rate;
3964   GstFormat format;
3965   guint64 amount;
3966   guint seqnum;
3967   GstStepInfo *pending, *current;
3968   GstMessage *message;
3969 
3970   bclass = GST_BASE_SINK_GET_CLASS (sink);
3971   priv = sink-&gt;priv;
3972 
3973   GST_DEBUG_OBJECT (sink, &quot;performing step with event %p&quot;, event);
3974 
3975   gst_event_parse_step (event, &amp;format, &amp;amount, &amp;rate, &amp;flush, &amp;intermediate);
3976   seqnum = gst_event_get_seqnum (event);
3977 
3978   pending = &amp;priv-&gt;pending_step;
3979   current = &amp;priv-&gt;current_step;
3980 
3981   /* post message first */
3982   message = gst_message_new_step_start (GST_OBJECT (sink), FALSE, format,
3983       amount, rate, flush, intermediate);
3984   gst_message_set_seqnum (message, seqnum);
3985   gst_element_post_message (GST_ELEMENT (sink), message);
3986 
3987   if (flush) {
3988     /* we need to call ::unlock before locking PREROLL_LOCK
3989      * since we lock it before going into ::render */
3990     if (bclass-&gt;unlock)
3991       bclass-&gt;unlock (sink);
3992 
3993     GST_BASE_SINK_PREROLL_LOCK (sink);
3994     /* now that we have the PREROLL lock, clear our unlock request */
3995     if (bclass-&gt;unlock_stop)
3996       bclass-&gt;unlock_stop (sink);
3997 
3998     /* update the stepinfo and make it valid */
3999     set_step_info (sink, current, pending, seqnum, format, amount, rate, flush,
4000         intermediate);
4001 
4002     if (sink-&gt;priv-&gt;async_enabled) {
4003       /* and we need to commit our state again on the next
4004        * prerolled buffer */
4005       sink-&gt;playing_async = TRUE;
4006       priv-&gt;pending_step.need_preroll = TRUE;
4007       sink-&gt;need_preroll = FALSE;
4008       gst_base_sink_update_start_time (sink);
4009       gst_element_lost_state (GST_ELEMENT_CAST (sink));
4010     } else {
4011       sink-&gt;priv-&gt;have_latency = TRUE;
4012       sink-&gt;need_preroll = FALSE;
4013     }
4014     priv-&gt;current_sstart = GST_CLOCK_TIME_NONE;
4015     priv-&gt;current_sstop = GST_CLOCK_TIME_NONE;
4016     priv-&gt;eos_rtime = GST_CLOCK_TIME_NONE;
4017     priv-&gt;call_preroll = TRUE;
4018     gst_base_sink_set_last_buffer (sink, NULL);
4019     gst_base_sink_set_last_buffer_list (sink, NULL);
4020     gst_base_sink_reset_qos (sink);
4021 
4022     if (sink-&gt;clock_id) {
4023       gst_clock_id_unschedule (sink-&gt;clock_id);
4024     }
4025 
4026     if (sink-&gt;have_preroll) {
4027       GST_DEBUG_OBJECT (sink, &quot;signal waiter&quot;);
4028       priv-&gt;step_unlock = TRUE;
4029       GST_BASE_SINK_PREROLL_SIGNAL (sink);
4030     }
4031     GST_BASE_SINK_PREROLL_UNLOCK (sink);
4032   } else {
4033     /* update the stepinfo and make it valid */
4034     set_step_info (sink, current, pending, seqnum, format, amount, rate, flush,
4035         intermediate);
4036   }
4037 
4038   return TRUE;
4039 }
4040 
4041 /* with STREAM_LOCK
4042  */
4043 static void
4044 gst_base_sink_loop (GstPad * pad)
4045 {
4046   GstObject *parent;
4047   GstBaseSink *basesink;
4048   GstBuffer *buf = NULL;
4049   GstFlowReturn result;
4050   guint blocksize;
4051   guint64 offset;
4052 
4053   parent = GST_OBJECT_PARENT (pad);
4054   basesink = GST_BASE_SINK (parent);
4055 
4056   g_assert (basesink-&gt;pad_mode == GST_PAD_MODE_PULL);
4057 
4058   if ((blocksize = basesink-&gt;priv-&gt;blocksize) == 0)
4059     blocksize = -1;
4060 
4061   offset = basesink-&gt;segment.position;
4062 
4063   GST_DEBUG_OBJECT (basesink, &quot;pulling %&quot; G_GUINT64_FORMAT &quot;, %u&quot;,
4064       offset, blocksize);
4065 
4066   result = gst_pad_pull_range (pad, offset, blocksize, &amp;buf);
4067   if (G_UNLIKELY (result != GST_FLOW_OK))
4068     goto paused;
4069 
4070   if (G_UNLIKELY (buf == NULL))
4071     goto no_buffer;
4072 
4073   offset += gst_buffer_get_size (buf);
4074 
4075   basesink-&gt;segment.position = offset;
4076 
4077   GST_BASE_SINK_PREROLL_LOCK (basesink);
4078   result = gst_base_sink_chain_unlocked (basesink, pad, buf, FALSE);
4079   GST_BASE_SINK_PREROLL_UNLOCK (basesink);
4080   if (G_UNLIKELY (result != GST_FLOW_OK))
4081     goto paused;
4082 
4083   return;
4084 
4085   /* ERRORS */
4086 paused:
4087   {
4088     GST_LOG_OBJECT (basesink, &quot;pausing task, reason %s&quot;,
4089         gst_flow_get_name (result));
4090     gst_pad_pause_task (pad);
4091     if (result == GST_FLOW_EOS) {
4092       /* perform EOS logic */
4093       if (basesink-&gt;segment.flags &amp; GST_SEGMENT_FLAG_SEGMENT) {
4094         gst_element_post_message (GST_ELEMENT_CAST (basesink),
4095             gst_message_new_segment_done (GST_OBJECT_CAST (basesink),
4096                 basesink-&gt;segment.format, basesink-&gt;segment.position));
4097         gst_base_sink_event (pad, parent,
4098             gst_event_new_segment_done (basesink-&gt;segment.format,
4099                 basesink-&gt;segment.position));
4100       } else {
4101         gst_base_sink_event (pad, parent, gst_event_new_eos ());
4102       }
4103     } else if (result == GST_FLOW_NOT_LINKED || result &lt;= GST_FLOW_EOS) {
4104       /* for fatal errors we post an error message, post the error
4105        * first so the app knows about the error first.
4106        * wrong-state is not a fatal error because it happens due to
4107        * flushing and posting an error message in that case is the
4108        * wrong thing to do, e.g. when basesrc is doing a flushing
4109        * seek. */
4110       GST_ELEMENT_FLOW_ERROR (basesink, result);
4111       gst_base_sink_event (pad, parent, gst_event_new_eos ());
4112     }
4113     return;
4114   }
4115 no_buffer:
4116   {
4117     GST_LOG_OBJECT (basesink, &quot;no buffer, pausing&quot;);
4118     GST_ELEMENT_ERROR (basesink, STREAM, FAILED,
4119         (_(&quot;Internal data flow error.&quot;)), (&quot;element returned NULL buffer&quot;));
4120     result = GST_FLOW_ERROR;
4121     goto paused;
4122   }
4123 }
4124 
4125 static gboolean
4126 gst_base_sink_set_flushing (GstBaseSink * basesink, GstPad * pad,
4127     gboolean flushing)
4128 {
4129   GstBaseSinkClass *bclass;
4130 
4131   bclass = GST_BASE_SINK_GET_CLASS (basesink);
4132 
4133   if (flushing) {
4134     /* unlock any subclasses, we need to do this before grabbing the
4135      * PREROLL_LOCK since we hold this lock before going into ::render. */
4136     if (bclass-&gt;unlock)
4137       bclass-&gt;unlock (basesink);
4138   }
4139 
4140   GST_BASE_SINK_PREROLL_LOCK (basesink);
4141   basesink-&gt;flushing = flushing;
4142   if (flushing) {
4143     /* step 1, now that we have the PREROLL lock, clear our unlock request */
4144     if (bclass-&gt;unlock_stop)
4145       bclass-&gt;unlock_stop (basesink);
4146 
4147     /* set need_preroll before we unblock the clock. If the clock is unblocked
4148      * before timing out, we can reuse the buffer for preroll. */
4149     basesink-&gt;need_preroll = TRUE;
4150 
4151     /* step 2, unblock clock sync (if any) or any other blocking thing */
4152     if (basesink-&gt;clock_id) {
4153       gst_clock_id_unschedule (basesink-&gt;clock_id);
4154     }
4155 
4156     /* flush out the data thread if it&#39;s locked in finish_preroll, this will
4157      * also flush out the EOS state */
4158     GST_DEBUG_OBJECT (basesink,
4159         &quot;flushing out data thread, need preroll to TRUE&quot;);
4160 
4161     /* we can&#39;t have EOS anymore now */
4162     basesink-&gt;eos = FALSE;
4163     basesink-&gt;priv-&gt;received_eos = FALSE;
4164     basesink-&gt;have_preroll = FALSE;
4165     basesink-&gt;priv-&gt;step_unlock = FALSE;
4166     /* can&#39;t report latency anymore until we preroll again */
4167     if (basesink-&gt;priv-&gt;async_enabled) {
4168       GST_OBJECT_LOCK (basesink);
4169       basesink-&gt;priv-&gt;have_latency = FALSE;
4170       GST_OBJECT_UNLOCK (basesink);
4171     }
4172     /* and signal any waiters now */
4173     GST_BASE_SINK_PREROLL_SIGNAL (basesink);
4174   }
4175   GST_BASE_SINK_PREROLL_UNLOCK (basesink);
4176 
4177   return TRUE;
4178 }
4179 
4180 static gboolean
4181 gst_base_sink_default_activate_pull (GstBaseSink * basesink, gboolean active)
4182 {
4183   gboolean result;
4184 
4185   if (active) {
4186     /* start task */
4187     result = gst_pad_start_task (basesink-&gt;sinkpad,
4188         (GstTaskFunction) gst_base_sink_loop, basesink-&gt;sinkpad, NULL);
4189   } else {
4190     /* step 2, make sure streaming finishes */
4191     result = gst_pad_stop_task (basesink-&gt;sinkpad);
4192   }
4193 
4194   return result;
4195 }
4196 
4197 static gboolean
4198 gst_base_sink_pad_activate (GstPad * pad, GstObject * parent)
4199 {
4200   gboolean result = FALSE;
4201   GstBaseSink *basesink;
4202   GstQuery *query;
4203   gboolean pull_mode;
4204 
4205   basesink = GST_BASE_SINK (parent);
4206 
4207   GST_DEBUG_OBJECT (basesink, &quot;Trying pull mode first&quot;);
4208 
4209   gst_base_sink_set_flushing (basesink, pad, FALSE);
4210 
4211   /* we need to have the pull mode enabled */
4212   if (!basesink-&gt;can_activate_pull) {
4213     GST_DEBUG_OBJECT (basesink, &quot;pull mode disabled&quot;);
4214     goto fallback;
4215   }
4216 
4217   /* check if downstreams supports pull mode at all */
4218   query = gst_query_new_scheduling ();
4219 
4220   if (!gst_pad_peer_query (pad, query)) {
4221     gst_query_unref (query);
4222     GST_DEBUG_OBJECT (basesink, &quot;peer query faild, no pull mode&quot;);
4223     goto fallback;
4224   }
4225 
4226   /* parse result of the query */
4227   pull_mode = gst_query_has_scheduling_mode (query, GST_PAD_MODE_PULL);
4228   gst_query_unref (query);
4229 
4230   if (!pull_mode) {
4231     GST_DEBUG_OBJECT (basesink, &quot;pull mode not supported&quot;);
4232     goto fallback;
4233   }
4234 
4235   /* set the pad mode before starting the task so that it&#39;s in the
4236    * correct state for the new thread. also the sink set_caps and get_caps
4237    * function checks this */
4238   basesink-&gt;pad_mode = GST_PAD_MODE_PULL;
4239 
4240   /* we first try to negotiate a format so that when we try to activate
4241    * downstream, it knows about our format */
4242   if (!gst_base_sink_negotiate_pull (basesink)) {
4243     GST_DEBUG_OBJECT (basesink, &quot;failed to negotiate in pull mode&quot;);
4244     goto fallback;
4245   }
4246 
4247   /* ok activate now */
4248   if (!gst_pad_activate_mode (pad, GST_PAD_MODE_PULL, TRUE)) {
4249     /* clear any pending caps */
4250     GST_OBJECT_LOCK (basesink);
4251     gst_caps_replace (&amp;basesink-&gt;priv-&gt;caps, NULL);
4252     GST_OBJECT_UNLOCK (basesink);
4253     GST_DEBUG_OBJECT (basesink, &quot;failed to activate in pull mode&quot;);
4254     goto fallback;
4255   }
4256 
4257   GST_DEBUG_OBJECT (basesink, &quot;Success activating pull mode&quot;);
4258   result = TRUE;
4259   goto done;
4260 
4261   /* push mode fallback */
4262 fallback:
4263   GST_DEBUG_OBJECT (basesink, &quot;Falling back to push mode&quot;);
4264   if ((result = gst_pad_activate_mode (pad, GST_PAD_MODE_PUSH, TRUE))) {
4265     GST_DEBUG_OBJECT (basesink, &quot;Success activating push mode&quot;);
4266   }
4267 
4268 done:
4269   if (!result) {
4270     GST_WARNING_OBJECT (basesink, &quot;Could not activate pad in either mode&quot;);
4271     gst_base_sink_set_flushing (basesink, pad, TRUE);
4272   }
4273 
4274   return result;
4275 }
4276 
4277 static gboolean
4278 gst_base_sink_pad_activate_push (GstPad * pad, GstObject * parent,
4279     gboolean active)
4280 {
4281   gboolean result;
4282   GstBaseSink *basesink;
4283 
4284   basesink = GST_BASE_SINK (parent);
4285 
4286   if (active) {
4287     if (!basesink-&gt;can_activate_push) {
4288       result = FALSE;
4289       basesink-&gt;pad_mode = GST_PAD_MODE_NONE;
4290     } else {
4291       result = TRUE;
4292       basesink-&gt;pad_mode = GST_PAD_MODE_PUSH;
4293     }
4294   } else {
4295     if (G_UNLIKELY (basesink-&gt;pad_mode != GST_PAD_MODE_PUSH)) {
4296       g_warning (&quot;Internal GStreamer activation error!!!&quot;);
4297       result = FALSE;
4298     } else {
4299       gst_base_sink_set_flushing (basesink, pad, TRUE);
4300       result = TRUE;
4301       basesink-&gt;pad_mode = GST_PAD_MODE_NONE;
4302     }
4303   }
4304 
4305   return result;
4306 }
4307 
4308 static gboolean
4309 gst_base_sink_negotiate_pull (GstBaseSink * basesink)
4310 {
4311   GstCaps *caps;
4312   gboolean result;
4313 
4314   result = FALSE;
4315 
4316   /* this returns the intersection between our caps and the peer caps. If there
4317    * is no peer, it returns %NULL and we can&#39;t operate in pull mode so we can
4318    * fail the negotiation. */
4319   caps = gst_pad_get_allowed_caps (GST_BASE_SINK_PAD (basesink));
4320   if (caps == NULL || gst_caps_is_empty (caps))
4321     goto no_caps_possible;
4322 
4323   GST_DEBUG_OBJECT (basesink, &quot;allowed caps: %&quot; GST_PTR_FORMAT, caps);
4324 
4325   if (gst_caps_is_any (caps)) {
4326     GST_DEBUG_OBJECT (basesink, &quot;caps were ANY after fixating, &quot;
4327         &quot;allowing pull()&quot;);
4328     /* neither side has template caps in this case, so they are prepared for
4329        pull() without setcaps() */
4330     result = TRUE;
4331   } else {
4332     /* try to fixate */
4333     caps = gst_base_sink_fixate (basesink, caps);
4334     GST_DEBUG_OBJECT (basesink, &quot;fixated to: %&quot; GST_PTR_FORMAT, caps);
4335 
4336     if (gst_caps_is_fixed (caps)) {
4337       if (!gst_pad_set_caps (GST_BASE_SINK_PAD (basesink), caps))
4338         goto could_not_set_caps;
4339 
4340       result = TRUE;
4341     }
4342   }
4343 
4344   gst_caps_unref (caps);
4345 
4346   return result;
4347 
4348 no_caps_possible:
4349   {
4350     GST_INFO_OBJECT (basesink, &quot;Pipeline could not agree on caps&quot;);
4351     GST_DEBUG_OBJECT (basesink, &quot;get_allowed_caps() returned EMPTY&quot;);
4352     if (caps)
4353       gst_caps_unref (caps);
4354     return FALSE;
4355   }
4356 could_not_set_caps:
4357   {
4358     GST_INFO_OBJECT (basesink, &quot;Could not set caps: %&quot; GST_PTR_FORMAT, caps);
4359     gst_caps_unref (caps);
4360     return FALSE;
4361   }
4362 }
4363 
4364 /* this won&#39;t get called until we implement an activate function */
4365 static gboolean
4366 gst_base_sink_pad_activate_pull (GstPad * pad, GstObject * parent,
4367     gboolean active)
4368 {
4369   gboolean result = FALSE;
4370   GstBaseSink *basesink;
4371   GstBaseSinkClass *bclass;
4372 
4373   basesink = GST_BASE_SINK (parent);
4374   bclass = GST_BASE_SINK_GET_CLASS (basesink);
4375 
4376   if (active) {
4377     gint64 duration;
4378 
4379     /* we mark we have a newsegment here because pull based
4380      * mode works just fine without having a newsegment before the
4381      * first buffer */
4382     gst_segment_init (&amp;basesink-&gt;segment, GST_FORMAT_BYTES);
4383     GST_OBJECT_LOCK (basesink);
4384     basesink-&gt;have_newsegment = TRUE;
4385     GST_OBJECT_UNLOCK (basesink);
4386 
4387     /* get the peer duration in bytes */
4388     result = gst_pad_peer_query_duration (pad, GST_FORMAT_BYTES, &amp;duration);
4389     if (result) {
4390       GST_DEBUG_OBJECT (basesink,
4391           &quot;setting duration in bytes to %&quot; G_GINT64_FORMAT, duration);
4392       basesink-&gt;segment.duration = duration;
4393     } else {
4394       GST_DEBUG_OBJECT (basesink, &quot;unknown duration&quot;);
4395     }
4396 
4397     if (bclass-&gt;activate_pull)
4398       result = bclass-&gt;activate_pull (basesink, TRUE);
4399     else
4400       result = FALSE;
4401 
4402     if (!result)
4403       goto activate_failed;
4404 
4405   } else {
4406     if (G_UNLIKELY (basesink-&gt;pad_mode != GST_PAD_MODE_PULL)) {
4407       g_warning (&quot;Internal GStreamer activation error!!!&quot;);
4408       result = FALSE;
4409     } else {
4410       result = gst_base_sink_set_flushing (basesink, pad, TRUE);
4411       if (bclass-&gt;activate_pull)
4412         result &amp;= bclass-&gt;activate_pull (basesink, FALSE);
4413       basesink-&gt;pad_mode = GST_PAD_MODE_NONE;
4414     }
4415   }
4416 
4417   return result;
4418 
4419   /* ERRORS */
4420 activate_failed:
4421   {
4422     /* reset, as starting the thread failed */
4423     basesink-&gt;pad_mode = GST_PAD_MODE_NONE;
4424 
4425     GST_ERROR_OBJECT (basesink, &quot;subclass failed to activate in pull mode&quot;);
4426     return FALSE;
4427   }
4428 }
4429 
4430 static gboolean
4431 gst_base_sink_pad_activate_mode (GstPad * pad, GstObject * parent,
4432     GstPadMode mode, gboolean active)
4433 {
4434   gboolean res;
4435 
4436   switch (mode) {
4437     case GST_PAD_MODE_PULL:
4438       res = gst_base_sink_pad_activate_pull (pad, parent, active);
4439       break;
4440     case GST_PAD_MODE_PUSH:
4441       res = gst_base_sink_pad_activate_push (pad, parent, active);
4442       break;
4443     default:
4444       GST_LOG_OBJECT (pad, &quot;unknown activation mode %d&quot;, mode);
4445       res = FALSE;
4446       break;
4447   }
4448   return res;
4449 }
4450 
4451 /* send an event to our sinkpad peer. */
4452 static gboolean
4453 gst_base_sink_send_event (GstElement * element, GstEvent * event)
4454 {
4455   GstPad *pad;
4456   GstBaseSink *basesink = GST_BASE_SINK (element);
4457   gboolean forward, result = TRUE;
4458   GstPadMode mode;
4459 
4460   GST_OBJECT_LOCK (element);
4461   /* get the pad and the scheduling mode */
4462   pad = gst_object_ref (basesink-&gt;sinkpad);
4463   mode = basesink-&gt;pad_mode;
4464   GST_OBJECT_UNLOCK (element);
4465 
4466   /* only push UPSTREAM events upstream */
4467   forward = GST_EVENT_IS_UPSTREAM (event);
4468 
4469   GST_DEBUG_OBJECT (basesink, &quot;handling event %p %&quot; GST_PTR_FORMAT, event,
4470       event);
4471 
4472   switch (GST_EVENT_TYPE (event)) {
4473     case GST_EVENT_LATENCY:
4474     {
4475       GstClockTime latency;
4476 
4477       gst_event_parse_latency (event, &amp;latency);
4478 
4479       /* store the latency. We use this to adjust the running_time before syncing
4480        * it to the clock. */
4481       GST_OBJECT_LOCK (element);
4482       basesink-&gt;priv-&gt;latency = latency;
4483       if (!basesink-&gt;priv-&gt;have_latency)
4484         forward = FALSE;
4485       GST_OBJECT_UNLOCK (element);
4486       GST_DEBUG_OBJECT (basesink, &quot;latency set to %&quot; GST_TIME_FORMAT,
4487           GST_TIME_ARGS (latency));
4488 
4489       /* We forward this event so that all elements know about the global pipeline
4490        * latency. This is interesting for an element when it wants to figure out
4491        * when a particular piece of data will be rendered. */
4492       break;
4493     }
4494     case GST_EVENT_SEEK:
4495       /* in pull mode we will execute the seek */
4496       if (mode == GST_PAD_MODE_PULL)
4497         result = gst_base_sink_perform_seek (basesink, pad, event);
4498       break;
4499     case GST_EVENT_STEP:
4500       result = gst_base_sink_perform_step (basesink, pad, event);
4501       forward = FALSE;
4502       break;
4503     default:
4504       break;
4505   }
4506 
4507   if (forward) {
4508     GST_DEBUG_OBJECT (basesink, &quot;sending event %p %&quot; GST_PTR_FORMAT, event,
4509         event);
4510     result = gst_pad_push_event (pad, event);
4511   } else {
4512     /* not forwarded, unref the event */
4513     gst_event_unref (event);
4514   }
4515 
4516   gst_object_unref (pad);
4517 
4518   GST_DEBUG_OBJECT (basesink, &quot;handled event: %d&quot;, result);
4519 
4520   return result;
4521 }
4522 
4523 static gboolean
4524 gst_base_sink_get_position (GstBaseSink * basesink, GstFormat format,
4525     gint64 * cur, gboolean * upstream)
4526 {
4527   GstClock *clock = NULL;
4528   gboolean res = FALSE;
4529   GstFormat oformat;
4530   GstSegment *segment;
4531   GstClockTime now, latency;
4532   GstClockTimeDiff base_time;
4533   gint64 time, base, offset, duration;
4534   gdouble rate;
4535   gint64 last;
4536   gboolean last_seen, with_clock, in_paused;
4537 
4538   GST_OBJECT_LOCK (basesink);
4539   /* we can only get the segment when we are not NULL or READY */
4540   if (!basesink-&gt;have_newsegment)
4541     goto wrong_state;
4542 
4543   in_paused = FALSE;
4544   /* when not in PLAYING or when we&#39;re busy with a state change, we
4545    * cannot read from the clock so we report time based on the
4546    * last seen timestamp. */
4547   if (GST_STATE (basesink) != GST_STATE_PLAYING ||
4548       GST_STATE_PENDING (basesink) != GST_STATE_VOID_PENDING) {
4549     in_paused = TRUE;
4550   }
4551 
4552   segment = &amp;basesink-&gt;segment;
4553 
4554   /* get the format in the segment */
4555   oformat = segment-&gt;format;
4556 
4557   /* report with last seen position when EOS */
4558   last_seen = basesink-&gt;eos;
4559 
4560   /* assume we will use the clock for getting the current position */
4561   with_clock = TRUE;
4562   if (!basesink-&gt;sync)
4563     with_clock = FALSE;
4564 
4565   /* and we need a clock */
4566   if (G_UNLIKELY ((clock = GST_ELEMENT_CLOCK (basesink)) == NULL))
4567     with_clock = FALSE;
4568   else
4569     gst_object_ref (clock);
4570 
4571   /* mainloop might be querying position when going to playing async,
4572    * while (audio) rendering might be quickly advancing stream position,
4573    * so use clock asap rather than last reported position */
4574   if (in_paused &amp;&amp; with_clock &amp;&amp; g_atomic_int_get (&amp;basesink-&gt;priv-&gt;to_playing)) {
4575     GST_DEBUG_OBJECT (basesink, &quot;going to PLAYING, so not PAUSED&quot;);
4576     in_paused = FALSE;
4577   }
4578 
4579   /* collect all data we need holding the lock */
4580   if (GST_CLOCK_TIME_IS_VALID (segment-&gt;time))
4581     time = segment-&gt;time;
4582   else
4583     time = 0;
4584 
4585   if (GST_CLOCK_TIME_IS_VALID (segment-&gt;offset))
4586     offset = segment-&gt;offset;
4587   else
4588     offset = 0;
4589 
4590   if (GST_CLOCK_TIME_IS_VALID (segment-&gt;stop))
4591     duration = segment-&gt;stop - segment-&gt;start;
4592   else
4593     duration = 0;
4594 
4595   base = segment-&gt;base;
4596   rate = segment-&gt;rate * segment-&gt;applied_rate;
4597   latency = basesink-&gt;priv-&gt;latency;
4598 
4599   if (in_paused) {
4600     /* in paused, use start_time */
4601     base_time = GST_ELEMENT_START_TIME (basesink);
4602     GST_DEBUG_OBJECT (basesink, &quot;in paused, using start time %&quot; GST_TIME_FORMAT,
4603         GST_TIME_ARGS (base_time));
4604   } else if (with_clock) {
4605     /* else use clock when needed */
4606     base_time = GST_ELEMENT_CAST (basesink)-&gt;base_time;
4607     GST_DEBUG_OBJECT (basesink, &quot;using clock and base time %&quot; GST_TIME_FORMAT,
4608         GST_TIME_ARGS (base_time));
4609   } else {
4610     /* else, no sync or clock -&gt; no base time */
4611     GST_DEBUG_OBJECT (basesink, &quot;no sync or no clock&quot;);
4612     base_time = -1;
4613   }
4614 
4615   /* no base_time, we can&#39;t calculate running_time, use last seem timestamp to report
4616    * time */
4617   if (base_time == -1)
4618     last_seen = TRUE;
4619 
4620   if (oformat == GST_FORMAT_TIME) {
4621     gint64 start, stop;
4622 
4623     start = basesink-&gt;priv-&gt;current_sstart;
4624     stop = basesink-&gt;priv-&gt;current_sstop;
4625 
4626     if (last_seen) {
4627       /* when we don&#39;t use the clock, we use the last position as a lower bound */
4628       if (stop == -1 || segment-&gt;rate &gt; 0.0)
4629         last = start;
4630       else
4631         last = stop;
4632 
4633       GST_DEBUG_OBJECT (basesink, &quot;in PAUSED using last %&quot; GST_TIME_FORMAT,
4634           GST_TIME_ARGS (last));
4635     } else {
4636       /* in playing and paused, use last stop time as upper bound */
4637       if (start == -1 || segment-&gt;rate &gt; 0.0)
4638         last = stop;
4639       else
4640         last = start;
4641 
4642       GST_DEBUG_OBJECT (basesink, &quot;in PLAYING using last %&quot; GST_TIME_FORMAT,
4643           GST_TIME_ARGS (last));
4644     }
4645   } else {
4646     /* convert position to stream time */
4647     last = gst_segment_to_stream_time (segment, oformat, segment-&gt;position);
4648 
4649     GST_DEBUG_OBJECT (basesink, &quot;in using last %&quot; G_GINT64_FORMAT, last);
4650   }
4651 
4652   /* need to release the object lock before we can get the time,
4653    * a clock might take the LOCK of the provider, which could be
4654    * a basesink subclass. */
4655   GST_OBJECT_UNLOCK (basesink);
4656 
4657   if (last_seen) {
4658     /* in EOS or when no valid stream_time, report the value of last seen
4659      * timestamp */
4660     if (last == -1) {
4661       /* no timestamp, we need to ask upstream */
4662       GST_DEBUG_OBJECT (basesink, &quot;no last seen timestamp, asking upstream&quot;);
4663       res = FALSE;
4664       *upstream = TRUE;
4665       goto done;
4666     }
4667     GST_DEBUG_OBJECT (basesink, &quot;using last seen timestamp %&quot; GST_TIME_FORMAT,
4668         GST_TIME_ARGS (last));
4669     *cur = last;
4670   } else {
4671     if (oformat != GST_FORMAT_TIME) {
4672       /* convert base, time and duration to time */
4673       if (!gst_pad_query_convert (basesink-&gt;sinkpad, oformat, base,
4674               GST_FORMAT_TIME, &amp;base))
4675         goto convert_failed;
4676       if (!gst_pad_query_convert (basesink-&gt;sinkpad, oformat, duration,
4677               GST_FORMAT_TIME, &amp;duration))
4678         goto convert_failed;
4679       if (!gst_pad_query_convert (basesink-&gt;sinkpad, oformat, time,
4680               GST_FORMAT_TIME, &amp;time))
4681         goto convert_failed;
4682       if (!gst_pad_query_convert (basesink-&gt;sinkpad, oformat, last,
4683               GST_FORMAT_TIME, &amp;last))
4684         goto convert_failed;
4685 
4686       /* assume time format from now on */
4687       oformat = GST_FORMAT_TIME;
4688     }
4689 
4690     if (!in_paused &amp;&amp; with_clock) {
4691       now = gst_clock_get_time (clock);
4692     } else {
4693       now = base_time;
4694       base_time = 0;
4695     }
4696 
4697     /* subtract base time and base time from the clock time.
4698      * Make sure we don&#39;t go negative. This is the current time in
4699      * the segment which we need to scale with the combined
4700      * rate and applied rate. */
4701     base_time += base;
4702     base_time += latency;
4703     if (GST_CLOCK_DIFF (base_time, now) &lt; 0)
4704       base_time = now;
4705 
4706     /* for negative rates we need to count back from the segment
4707      * duration. */
4708     if (rate &lt; 0.0)
4709       time += duration;
4710 
4711     *cur = time + offset + gst_guint64_to_gdouble (now - base_time) * rate;
4712 
4713     /* never report more than last seen position */
4714     if (last != -1) {
4715       if (rate &gt; 0.0)
4716         *cur = MIN (last, *cur);
4717       else
4718         *cur = MAX (last, *cur);
4719     }
4720 
4721     GST_DEBUG_OBJECT (basesink,
4722         &quot;now %&quot; GST_TIME_FORMAT &quot; - base_time %&quot; GST_TIME_FORMAT &quot; - base %&quot;
4723         GST_TIME_FORMAT &quot; + time %&quot; GST_TIME_FORMAT &quot;  last %&quot; GST_TIME_FORMAT,
4724         GST_TIME_ARGS (now), GST_TIME_ARGS (base_time), GST_TIME_ARGS (base),
4725         GST_TIME_ARGS (time), GST_TIME_ARGS (last));
4726   }
4727 
4728   if (oformat != format) {
4729     /* convert to final format */
4730     if (!gst_pad_query_convert (basesink-&gt;sinkpad, oformat, *cur, format, cur))
4731       goto convert_failed;
4732   }
4733 
4734   res = TRUE;
4735 
4736 done:
4737   GST_DEBUG_OBJECT (basesink, &quot;res: %d, POSITION: %&quot; GST_TIME_FORMAT,
4738       res, GST_TIME_ARGS (*cur));
4739 
4740   if (clock)
4741     gst_object_unref (clock);
4742 
4743   return res;
4744 
4745   /* special cases */
4746 wrong_state:
4747   {
4748     /* in NULL or READY we always return FALSE and -1 */
4749     GST_DEBUG_OBJECT (basesink, &quot;position in wrong state, return -1&quot;);
4750     res = FALSE;
4751     *cur = -1;
4752     GST_OBJECT_UNLOCK (basesink);
4753     goto done;
4754   }
4755 convert_failed:
4756   {
4757     GST_DEBUG_OBJECT (basesink, &quot;convert failed, try upstream&quot;);
4758     *upstream = TRUE;
4759     res = FALSE;
4760     goto done;
4761   }
4762 }
4763 
4764 static gboolean
4765 gst_base_sink_get_duration (GstBaseSink * basesink, GstFormat format,
4766     gint64 * dur, gboolean * upstream)
4767 {
4768   gboolean res = FALSE;
4769 
4770   if (basesink-&gt;pad_mode == GST_PAD_MODE_PULL) {
4771     gint64 uduration;
4772 
4773     /* get the duration in bytes, in pull mode that&#39;s all we are sure to
4774      * know. We have to explicitly get this value from upstream instead of
4775      * using our cached value because it might change. Duration caching
4776      * should be done at a higher level. */
4777     res =
4778         gst_pad_peer_query_duration (basesink-&gt;sinkpad, GST_FORMAT_BYTES,
4779         &amp;uduration);
4780     if (res) {
4781       basesink-&gt;segment.duration = uduration;
4782       if (format != GST_FORMAT_BYTES) {
4783         /* convert to the requested format */
4784         res =
4785             gst_pad_query_convert (basesink-&gt;sinkpad, GST_FORMAT_BYTES,
4786             uduration, format, dur);
4787       } else {
4788         *dur = uduration;
4789       }
4790     }
4791     *upstream = FALSE;
4792   } else {
4793     *upstream = TRUE;
4794   }
4795 
4796   return res;
4797 }
4798 
4799 static gboolean
4800 default_element_query (GstElement * element, GstQuery * query)
4801 {
4802   gboolean res = FALSE;
4803 
4804   GstBaseSink *basesink = GST_BASE_SINK (element);
4805 
4806   switch (GST_QUERY_TYPE (query)) {
4807     case GST_QUERY_POSITION:
4808     {
4809       gint64 cur = 0;
4810       GstFormat format;
4811       gboolean upstream = FALSE;
4812 
4813       gst_query_parse_position (query, &amp;format, NULL);
4814 
4815       GST_DEBUG_OBJECT (basesink, &quot;position query in format %s&quot;,
4816           gst_format_get_name (format));
4817 
4818       /* first try to get the position based on the clock */
4819       if ((res =
4820               gst_base_sink_get_position (basesink, format, &amp;cur, &amp;upstream))) {
4821         gst_query_set_position (query, format, cur);
4822       } else if (upstream) {
4823         /* fallback to peer query */
4824         res = gst_pad_peer_query (basesink-&gt;sinkpad, query);
4825       }
4826       if (!res) {
4827         /* we can handle a few things if upstream failed */
4828         if (format == GST_FORMAT_PERCENT) {
4829           gint64 dur = 0;
4830 
4831           res = gst_base_sink_get_position (basesink, GST_FORMAT_TIME, &amp;cur,
4832               &amp;upstream);
4833           if (!res &amp;&amp; upstream) {
4834             res =
4835                 gst_pad_peer_query_position (basesink-&gt;sinkpad, GST_FORMAT_TIME,
4836                 &amp;cur);
4837           }
4838           if (res) {
4839             res = gst_base_sink_get_duration (basesink, GST_FORMAT_TIME, &amp;dur,
4840                 &amp;upstream);
4841             if (!res &amp;&amp; upstream) {
4842               res =
4843                   gst_pad_peer_query_duration (basesink-&gt;sinkpad,
4844                   GST_FORMAT_TIME, &amp;dur);
4845             }
4846           }
4847           if (res) {
4848             gint64 pos;
4849 
4850             pos = gst_util_uint64_scale (100 * GST_FORMAT_PERCENT_SCALE, cur,
4851                 dur);
4852             gst_query_set_position (query, GST_FORMAT_PERCENT, pos);
4853           }
4854         }
4855       }
4856       break;
4857     }
4858     case GST_QUERY_DURATION:
4859     {
4860       gint64 dur = 0;
4861       GstFormat format;
4862       gboolean upstream = FALSE;
4863 
4864       gst_query_parse_duration (query, &amp;format, NULL);
4865 
4866       GST_DEBUG_OBJECT (basesink, &quot;duration query in format %s&quot;,
4867           gst_format_get_name (format));
4868 
4869       if ((res =
4870               gst_base_sink_get_duration (basesink, format, &amp;dur, &amp;upstream))) {
4871         gst_query_set_duration (query, format, dur);
4872       } else if (upstream) {
4873         /* fallback to peer query */
4874         res = gst_pad_peer_query (basesink-&gt;sinkpad, query);
4875       }
4876       if (!res) {
4877         /* we can handle a few things if upstream failed */
4878         if (format == GST_FORMAT_PERCENT) {
4879           gst_query_set_duration (query, GST_FORMAT_PERCENT,
4880               GST_FORMAT_PERCENT_MAX);
4881           res = TRUE;
4882         }
4883       }
4884       break;
4885     }
4886     case GST_QUERY_LATENCY:
4887     {
4888       gboolean live, us_live;
4889       GstClockTime min, max;
4890 
4891       if ((res = gst_base_sink_query_latency (basesink, &amp;live, &amp;us_live, &amp;min,
4892                   &amp;max))) {
4893         gst_query_set_latency (query, live, min, max);
4894       }
4895       break;
4896     }
4897     case GST_QUERY_JITTER:
4898       break;
4899     case GST_QUERY_RATE:
4900       /* gst_query_set_rate (query, basesink-&gt;segment_rate); */
4901       res = TRUE;
4902       break;
4903     case GST_QUERY_SEGMENT:
4904     {
4905       if (basesink-&gt;pad_mode == GST_PAD_MODE_PULL) {
4906         GstFormat format;
4907         gint64 start, stop;
4908 
4909         format = basesink-&gt;segment.format;
4910 
4911         start =
4912             gst_segment_to_stream_time (&amp;basesink-&gt;segment, format,
4913             basesink-&gt;segment.start);
4914         if ((stop = basesink-&gt;segment.stop) == -1)
4915           stop = basesink-&gt;segment.duration;
4916         else
4917           stop = gst_segment_to_stream_time (&amp;basesink-&gt;segment, format, stop);
4918 
4919         gst_query_set_segment (query, basesink-&gt;segment.rate, format, start,
4920             stop);
4921         res = TRUE;
4922       } else {
4923         res = gst_pad_peer_query (basesink-&gt;sinkpad, query);
4924       }
4925       break;
4926     }
4927     case GST_QUERY_SEEKING:
4928     case GST_QUERY_CONVERT:
4929     case GST_QUERY_FORMATS:
4930     default:
4931       res = gst_pad_peer_query (basesink-&gt;sinkpad, query);
4932       break;
4933   }
4934   GST_DEBUG_OBJECT (basesink, &quot;query %s returns %d&quot;,
4935       GST_QUERY_TYPE_NAME (query), res);
4936   return res;
4937 }
4938 
4939 static void
4940 gst_base_sink_drain (GstBaseSink * basesink)
4941 {
4942   GstBuffer *old;
4943   GstBufferList *old_list;
4944 
4945   GST_OBJECT_LOCK (basesink);
4946   if ((old = basesink-&gt;priv-&gt;last_buffer))
4947     basesink-&gt;priv-&gt;last_buffer = gst_buffer_copy_deep (old);
4948 
4949   if ((old_list = basesink-&gt;priv-&gt;last_buffer_list))
4950     basesink-&gt;priv-&gt;last_buffer_list = gst_buffer_list_copy_deep (old_list);
4951   GST_OBJECT_UNLOCK (basesink);
4952 
4953   if (old)
4954     gst_buffer_unref (old);
4955   if (old_list)
4956     gst_mini_object_unref (GST_MINI_OBJECT_CAST (old_list));
4957 }
4958 
4959 static gboolean
4960 gst_base_sink_default_query (GstBaseSink * basesink, GstQuery * query)
4961 {
4962   gboolean res;
4963   GstBaseSinkClass *bclass;
4964 
4965   bclass = GST_BASE_SINK_GET_CLASS (basesink);
4966 
4967   switch (GST_QUERY_TYPE (query)) {
4968     case GST_QUERY_ALLOCATION:
4969     {
4970       gst_base_sink_drain (basesink);
4971       if (bclass-&gt;propose_allocation)
4972         res = bclass-&gt;propose_allocation (basesink, query);
4973       else
4974         res = FALSE;
4975       break;
4976     }
4977     case GST_QUERY_CAPS:
4978     {
4979       GstCaps *caps, *filter;
4980 
4981       gst_query_parse_caps (query, &amp;filter);
4982       caps = gst_base_sink_query_caps (basesink, basesink-&gt;sinkpad, filter);
4983       gst_query_set_caps_result (query, caps);
4984       gst_caps_unref (caps);
4985       res = TRUE;
4986       break;
4987     }
4988     case GST_QUERY_ACCEPT_CAPS:
4989     {
4990       GstCaps *caps, *allowed;
4991       gboolean subset;
4992 
4993       /* slightly faster than the default implementation */
4994       gst_query_parse_accept_caps (query, &amp;caps);
4995       allowed = gst_base_sink_query_caps (basesink, basesink-&gt;sinkpad, NULL);
4996       subset = gst_caps_is_subset (caps, allowed);
4997       GST_DEBUG_OBJECT (basesink, &quot;Checking if requested caps %&quot; GST_PTR_FORMAT
4998           &quot; are a subset of pad caps %&quot; GST_PTR_FORMAT &quot; result %d&quot;, caps,
4999           allowed, subset);
5000       gst_caps_unref (allowed);
5001       gst_query_set_accept_caps_result (query, subset);
5002       res = TRUE;
5003       break;
5004     }
5005     case GST_QUERY_DRAIN:
5006     {
5007       gst_base_sink_drain (basesink);
5008       res = TRUE;
5009       break;
5010     }
5011     case GST_QUERY_POSITION:
5012     {
5013       res = default_element_query (GST_ELEMENT (basesink), query);
5014       break;
5015     }
5016     default:
5017       res =
5018           gst_pad_query_default (basesink-&gt;sinkpad, GST_OBJECT_CAST (basesink),
5019           query);
5020       break;
5021   }
5022   return res;
5023 }
5024 
5025 static gboolean
5026 gst_base_sink_sink_query (GstPad * pad, GstObject * parent, GstQuery * query)
5027 {
5028   GstBaseSink *basesink;
5029   GstBaseSinkClass *bclass;
5030   gboolean res;
5031 
5032   basesink = GST_BASE_SINK_CAST (parent);
5033   bclass = GST_BASE_SINK_GET_CLASS (basesink);
5034 
5035   if (bclass-&gt;query)
5036     res = bclass-&gt;query (basesink, query);
5037   else
5038     res = FALSE;
5039 
5040   return res;
5041 }
5042 
5043 static GstStateChangeReturn
5044 gst_base_sink_change_state (GstElement * element, GstStateChange transition)
5045 {
5046   GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
5047   GstBaseSink *basesink = GST_BASE_SINK (element);
5048   GstBaseSinkClass *bclass;
5049   GstBaseSinkPrivate *priv;
5050 
5051   priv = basesink-&gt;priv;
5052 
5053   bclass = GST_BASE_SINK_GET_CLASS (basesink);
5054 
5055   switch (transition) {
5056     case GST_STATE_CHANGE_NULL_TO_READY:
5057       if (bclass-&gt;start)
5058         if (!bclass-&gt;start (basesink))
5059           goto start_failed;
5060       break;
5061     case GST_STATE_CHANGE_READY_TO_PAUSED:
5062       /* need to complete preroll before this state change completes, there
5063        * is no data flow in READY so we can safely assume we need to preroll. */
5064       GST_BASE_SINK_PREROLL_LOCK (basesink);
5065       GST_DEBUG_OBJECT (basesink, &quot;READY to PAUSED&quot;);
5066       basesink-&gt;have_newsegment = FALSE;
5067       gst_segment_init (&amp;basesink-&gt;segment, GST_FORMAT_UNDEFINED);
5068       basesink-&gt;offset = 0;
5069       basesink-&gt;have_preroll = FALSE;
5070       priv-&gt;step_unlock = FALSE;
5071       basesink-&gt;need_preroll = TRUE;
5072       basesink-&gt;playing_async = TRUE;
5073       priv-&gt;current_sstart = GST_CLOCK_TIME_NONE;
5074       priv-&gt;current_sstop = GST_CLOCK_TIME_NONE;
5075       priv-&gt;eos_rtime = GST_CLOCK_TIME_NONE;
5076       priv-&gt;latency = 0;
5077       basesink-&gt;eos = FALSE;
5078       priv-&gt;received_eos = FALSE;
5079       gst_base_sink_reset_qos (basesink);
5080       priv-&gt;rc_next = -1;
5081       priv-&gt;commited = FALSE;
5082       priv-&gt;call_preroll = TRUE;
5083       priv-&gt;current_step.valid = FALSE;
5084       priv-&gt;pending_step.valid = FALSE;
5085       if (priv-&gt;async_enabled) {
5086         GST_DEBUG_OBJECT (basesink, &quot;doing async state change&quot;);
5087         /* when async enabled, post async-start message and return ASYNC from
5088          * the state change function */
5089         ret = GST_STATE_CHANGE_ASYNC;
5090         gst_element_post_message (GST_ELEMENT_CAST (basesink),
5091             gst_message_new_async_start (GST_OBJECT_CAST (basesink)));
5092       } else {
5093         priv-&gt;have_latency = TRUE;
5094       }
5095       GST_BASE_SINK_PREROLL_UNLOCK (basesink);
5096       break;
5097     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
5098       GST_BASE_SINK_PREROLL_LOCK (basesink);
5099       g_atomic_int_set (&amp;basesink-&gt;priv-&gt;to_playing, TRUE);
5100       if (!gst_base_sink_needs_preroll (basesink)) {
5101         GST_DEBUG_OBJECT (basesink, &quot;PAUSED to PLAYING, don&#39;t need preroll&quot;);
5102         /* no preroll needed anymore now. */
5103         basesink-&gt;playing_async = FALSE;
5104         basesink-&gt;need_preroll = FALSE;
5105         if (basesink-&gt;eos) {
5106           GstMessage *message;
5107 
5108           /* need to post EOS message here */
5109           GST_DEBUG_OBJECT (basesink, &quot;Now posting EOS&quot;);
5110           message = gst_message_new_eos (GST_OBJECT_CAST (basesink));
5111           gst_message_set_seqnum (message, basesink-&gt;priv-&gt;seqnum);
5112           gst_element_post_message (GST_ELEMENT_CAST (basesink), message);
5113         } else {
5114           GST_DEBUG_OBJECT (basesink, &quot;signal preroll&quot;);
5115           GST_BASE_SINK_PREROLL_SIGNAL (basesink);
5116         }
5117       } else {
5118         GST_DEBUG_OBJECT (basesink, &quot;PAUSED to PLAYING, we are not prerolled&quot;);
5119         basesink-&gt;need_preroll = TRUE;
5120         basesink-&gt;playing_async = TRUE;
5121         priv-&gt;call_preroll = TRUE;
5122         priv-&gt;commited = FALSE;
5123         if (priv-&gt;async_enabled) {
5124           GST_DEBUG_OBJECT (basesink, &quot;doing async state change&quot;);
5125           ret = GST_STATE_CHANGE_ASYNC;
5126           gst_element_post_message (GST_ELEMENT_CAST (basesink),
5127               gst_message_new_async_start (GST_OBJECT_CAST (basesink)));
5128         }
5129       }
5130       GST_BASE_SINK_PREROLL_UNLOCK (basesink);
5131       break;
5132     default:
5133       break;
5134   }
5135 
5136   {
5137     GstStateChangeReturn bret;
5138 
5139     bret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
5140     if (G_UNLIKELY (bret == GST_STATE_CHANGE_FAILURE))
5141       goto activate_failed;
5142   }
5143 
5144   switch (transition) {
5145     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
5146       /* completed transition, so need not be marked any longer
5147        * And it should be unmarked, since e.g. losing our position upon flush
5148        * does not really change state to PAUSED ... */
5149       g_atomic_int_set (&amp;basesink-&gt;priv-&gt;to_playing, FALSE);
5150       break;
5151     case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
5152       g_atomic_int_set (&amp;basesink-&gt;priv-&gt;to_playing, FALSE);
5153       GST_DEBUG_OBJECT (basesink, &quot;PLAYING to PAUSED&quot;);
5154       /* FIXME, make sure we cannot enter _render first */
5155 
5156       /* we need to call ::unlock before locking PREROLL_LOCK
5157        * since we lock it before going into ::render */
5158       if (bclass-&gt;unlock)
5159         bclass-&gt;unlock (basesink);
5160 
5161       GST_BASE_SINK_PREROLL_LOCK (basesink);
5162       GST_DEBUG_OBJECT (basesink, &quot;got preroll lock&quot;);
5163       /* now that we have the PREROLL lock, clear our unlock request */
5164       if (bclass-&gt;unlock_stop)
5165         bclass-&gt;unlock_stop (basesink);
5166 
5167       if (basesink-&gt;clock_id) {
5168         GST_DEBUG_OBJECT (basesink, &quot;unschedule clock&quot;);
5169         gst_clock_id_unschedule (basesink-&gt;clock_id);
5170       }
5171 
5172       /* if we don&#39;t have a preroll buffer we need to wait for a preroll and
5173        * return ASYNC. */
5174       if (!gst_base_sink_needs_preroll (basesink)) {
5175         GST_DEBUG_OBJECT (basesink, &quot;PLAYING to PAUSED, we are prerolled&quot;);
5176         basesink-&gt;playing_async = FALSE;
5177         basesink-&gt;need_preroll = FALSE;
5178       } else {
5179         if (GST_STATE_TARGET (GST_ELEMENT (basesink)) &lt;= GST_STATE_READY) {
5180           GST_DEBUG_OBJECT (basesink, &quot;element is &lt;= READY&quot;);
5181           ret = GST_STATE_CHANGE_SUCCESS;
5182         } else {
5183           GST_DEBUG_OBJECT (basesink,
5184               &quot;PLAYING to PAUSED, we are not prerolled&quot;);
5185           basesink-&gt;playing_async = TRUE;
5186           basesink-&gt;need_preroll = TRUE;
5187           priv-&gt;commited = FALSE;
5188           priv-&gt;call_preroll = TRUE;
5189           if (priv-&gt;async_enabled) {
5190             GST_DEBUG_OBJECT (basesink, &quot;doing async state change&quot;);
5191             ret = GST_STATE_CHANGE_ASYNC;
5192             gst_element_post_message (GST_ELEMENT_CAST (basesink),
5193                 gst_message_new_async_start (GST_OBJECT_CAST (basesink)));
5194           }
5195         }
5196       }
5197       GST_DEBUG_OBJECT (basesink, &quot;rendered: %&quot; G_GUINT64_FORMAT
5198           &quot;, dropped: %&quot; G_GUINT64_FORMAT, priv-&gt;rendered, priv-&gt;dropped);
5199 
5200       gst_base_sink_reset_qos (basesink);
5201       GST_BASE_SINK_PREROLL_UNLOCK (basesink);
5202       break;
5203     case GST_STATE_CHANGE_PAUSED_TO_READY:
5204       GST_BASE_SINK_PREROLL_LOCK (basesink);
5205       /* start by resetting our position state with the object lock so that the
5206        * position query gets the right idea. We do this before we post the
5207        * messages so that the message handlers pick this up. */
5208       GST_OBJECT_LOCK (basesink);
5209       basesink-&gt;have_newsegment = FALSE;
5210       priv-&gt;current_sstart = GST_CLOCK_TIME_NONE;
5211       priv-&gt;current_sstop = GST_CLOCK_TIME_NONE;
5212       priv-&gt;have_latency = FALSE;
5213       if (priv-&gt;cached_clock_id) {
5214         gst_clock_id_unref (priv-&gt;cached_clock_id);
5215         priv-&gt;cached_clock_id = NULL;
5216       }
5217       gst_caps_replace (&amp;basesink-&gt;priv-&gt;caps, NULL);
5218       GST_OBJECT_UNLOCK (basesink);
5219 
5220       gst_base_sink_set_last_buffer (basesink, NULL);
5221       gst_base_sink_set_last_buffer_list (basesink, NULL);
5222       priv-&gt;call_preroll = FALSE;
5223 
5224       if (!priv-&gt;commited) {
5225         if (priv-&gt;async_enabled) {
5226           GST_DEBUG_OBJECT (basesink, &quot;PAUSED to READY, posting async-done&quot;);
5227 
5228           gst_element_post_message (GST_ELEMENT_CAST (basesink),
5229               gst_message_new_state_changed (GST_OBJECT_CAST (basesink),
5230                   GST_STATE_PLAYING, GST_STATE_PAUSED, GST_STATE_READY));
5231 
5232           gst_element_post_message (GST_ELEMENT_CAST (basesink),
5233               gst_message_new_async_done (GST_OBJECT_CAST (basesink),
5234                   GST_CLOCK_TIME_NONE));
5235         }
5236         priv-&gt;commited = TRUE;
5237       } else {
5238         GST_DEBUG_OBJECT (basesink, &quot;PAUSED to READY, don&#39;t need_preroll&quot;);
5239       }
5240       GST_BASE_SINK_PREROLL_UNLOCK (basesink);
5241       break;
5242     case GST_STATE_CHANGE_READY_TO_NULL:
5243       if (bclass-&gt;stop) {
5244         if (!bclass-&gt;stop (basesink)) {
5245           GST_WARNING_OBJECT (basesink, &quot;failed to stop&quot;);
5246         }
5247       }
5248       gst_base_sink_set_last_buffer (basesink, NULL);
5249       gst_base_sink_set_last_buffer_list (basesink, NULL);
5250       priv-&gt;call_preroll = FALSE;
5251       break;
5252     default:
5253       break;
5254   }
5255 
5256   return ret;
5257 
5258   /* ERRORS */
5259 start_failed:
5260   {
5261     GST_DEBUG_OBJECT (basesink, &quot;failed to start&quot;);
5262     /* subclass is supposed to post a message but we post one as a fallback
5263      * just in case */
5264     GST_ELEMENT_ERROR (basesink, CORE, STATE_CHANGE, (NULL),
5265         (&quot;Failed to start&quot;));
5266     return GST_STATE_CHANGE_FAILURE;
5267   }
5268 activate_failed:
5269   {
5270     GST_DEBUG_OBJECT (basesink,
5271         &quot;element failed to change states -- activation problem?&quot;);
5272     return GST_STATE_CHANGE_FAILURE;
5273   }
5274 }
    </pre>
  </body>
</html>