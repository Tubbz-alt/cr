<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/pbutils/gstdiscoverer.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 2009 Edward Hervey &lt;edward.hervey@collabora.co.uk&gt;
   3  *               2009 Nokia Corporation
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Library General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Library General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Library General Public
  16  * License along with this library; if not, write to the
  17  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  18  * Boston, MA 02110-1301, USA.
  19  */
  20 
  21 /**
  22  * SECTION:gstdiscoverer
  23  * @title: GstDiscoverer
  24  * @short_description: Utility for discovering information on URIs.
  25  *
  26  * The #GstDiscoverer is a utility object which allows to get as much
  27  * information as possible from one or many URIs.
  28  *
  29  * It provides two APIs, allowing usage in blocking or non-blocking mode.
  30  *
  31  * The blocking mode just requires calling gst_discoverer_discover_uri()
  32  * with the URI one wishes to discover.
  33  *
  34  * The non-blocking mode requires a running #GMainLoop iterating a
  35  * #GMainContext, where one connects to the various signals, appends the
  36  * URIs to be processed (through gst_discoverer_discover_uri_async()) and then
  37  * asks for the discovery to begin (through gst_discoverer_start()).
  38  * By default this will use the GLib default main context unless you have
  39  * set a custom context using g_main_context_push_thread_default().
  40  *
  41  * All the information is returned in a #GstDiscovererInfo structure.
  42  */
  43 
  44 #ifdef HAVE_CONFIG_H
  45 #include &quot;config.h&quot;
  46 #endif
  47 
  48 #include &lt;gst/video/video.h&gt;
  49 #include &lt;gst/audio/audio.h&gt;
  50 
  51 #include &lt;string.h&gt;
  52 
  53 #include &quot;pbutils.h&quot;
  54 #include &quot;pbutils-private.h&quot;
  55 
<a name="1" id="anc1"></a>


  56 GST_DEBUG_CATEGORY_STATIC (discoverer_debug);
  57 #define GST_CAT_DEFAULT discoverer_debug
<a name="2" id="anc2"></a>
  58 
  59 static GQuark _CAPS_QUARK;
  60 static GQuark _TAGS_QUARK;
  61 static GQuark _ELEMENT_SRCPAD_QUARK;
  62 static GQuark _TOC_QUARK;
  63 static GQuark _STREAM_ID_QUARK;
  64 static GQuark _MISSING_PLUGIN_QUARK;
  65 static GQuark _STREAM_TOPOLOGY_QUARK;
  66 static GQuark _TOPOLOGY_PAD_QUARK;
  67 
  68 
  69 typedef struct
  70 {
  71   GstDiscoverer *dc;
  72   GstPad *pad;
  73   GstElement *queue;
  74   GstElement *sink;
  75   GstTagList *tags;
  76   GstToc *toc;
  77   gchar *stream_id;
  78   gulong probe_id;
  79 } PrivateStream;
  80 
  81 struct _GstDiscovererPrivate
  82 {
  83   gboolean async;
  84 
  85   /* allowed time to discover each uri in nanoseconds */
  86   GstClockTime timeout;
  87 
  88   /* list of pending URI to process (current excluded) */
  89   GList *pending_uris;
  90 
  91   GMutex lock;
  92   /* TRUE if cleaning up discoverer */
  93   gboolean cleanup;
  94 
  95   /* TRUE if processing a URI */
  96   gboolean processing;
  97 
  98   /* TRUE if discoverer has been started */
  99   gboolean running;
 100 
 101   /* current items */
 102   GstDiscovererInfo *current_info;
 103   GError *current_error;
 104   GstStructure *current_topology;
 105 
 106   /* List of private streams */
 107   GList *streams;
 108 
 109   /* List of these sinks and their handler IDs (to remove the probe) */
 110   guint pending_subtitle_pads;
 111 
 112   /* Whether we received no_more_pads */
 113   gboolean no_more_pads;
 114 
 115   GstState target_state;
 116   GstState current_state;
 117 
 118   /* Global elements */
 119   GstBin *pipeline;
 120   GstElement *uridecodebin;
 121   GstBus *bus;
 122 
 123   GType decodebin_type;
 124 
 125   /* Custom main context variables */
 126   GMainContext *ctx;
<a name="3" id="anc3"></a><span class="line-modified"> 127   guint sourceid;</span>
<span class="line-modified"> 128   guint timeoutid;</span>
 129 
 130   /* reusable queries */
 131   GstQuery *seeking_query;
 132 
 133   /* Handler ids for various callbacks */
 134   gulong pad_added_id;
 135   gulong pad_remove_id;
 136   gulong no_more_pads_id;
 137   gulong source_chg_id;
 138   gulong element_added_id;
 139   gulong bus_cb_id;
<a name="4" id="anc4"></a>

 140 };
 141 
 142 #define DISCO_LOCK(dc) g_mutex_lock (&amp;dc-&gt;priv-&gt;lock);
 143 #define DISCO_UNLOCK(dc) g_mutex_unlock (&amp;dc-&gt;priv-&gt;lock);
 144 
 145 static void
 146 _do_init (void)
 147 {
 148   GST_DEBUG_CATEGORY_INIT (discoverer_debug, &quot;discoverer&quot;, 0, &quot;Discoverer&quot;);
 149 
 150   _CAPS_QUARK = g_quark_from_static_string (&quot;caps&quot;);
 151   _ELEMENT_SRCPAD_QUARK = g_quark_from_static_string (&quot;element-srcpad&quot;);
 152   _TAGS_QUARK = g_quark_from_static_string (&quot;tags&quot;);
 153   _TOC_QUARK = g_quark_from_static_string (&quot;toc&quot;);
 154   _STREAM_ID_QUARK = g_quark_from_static_string (&quot;stream-id&quot;);
 155   _MISSING_PLUGIN_QUARK = g_quark_from_static_string (&quot;missing-plugin&quot;);
 156   _STREAM_TOPOLOGY_QUARK = g_quark_from_static_string (&quot;stream-topology&quot;);
 157   _TOPOLOGY_PAD_QUARK = g_quark_from_static_string (&quot;pad&quot;);
 158 };
 159 
 160 G_DEFINE_TYPE_EXTENDED (GstDiscoverer, gst_discoverer, G_TYPE_OBJECT, 0,
<a name="5" id="anc5"></a><span class="line-modified"> 161     _do_init ());</span>
 162 
 163 enum
 164 {
 165   SIGNAL_FINISHED,
 166   SIGNAL_STARTING,
 167   SIGNAL_DISCOVERED,
 168   SIGNAL_SOURCE_SETUP,
 169   LAST_SIGNAL
 170 };
 171 
 172 #define DEFAULT_PROP_TIMEOUT 15 * GST_SECOND
<a name="6" id="anc6"></a>
 173 
 174 enum
 175 {
 176   PROP_0,
<a name="7" id="anc7"></a><span class="line-modified"> 177   PROP_TIMEOUT</span>

 178 };
 179 
 180 static guint gst_discoverer_signals[LAST_SIGNAL] = { 0 };
 181 
 182 static void gst_discoverer_set_timeout (GstDiscoverer * dc,
 183     GstClockTime timeout);
 184 static gboolean async_timeout_cb (GstDiscoverer * dc);
 185 
 186 static void discoverer_bus_cb (GstBus * bus, GstMessage * msg,
 187     GstDiscoverer * dc);
 188 static void uridecodebin_pad_added_cb (GstElement * uridecodebin, GstPad * pad,
 189     GstDiscoverer * dc);
 190 static void uridecodebin_pad_removed_cb (GstElement * uridecodebin,
 191     GstPad * pad, GstDiscoverer * dc);
 192 static void uridecodebin_no_more_pads_cb (GstElement * uridecodebin,
 193     GstDiscoverer * dc);
 194 static void uridecodebin_source_changed_cb (GstElement * uridecodebin,
 195     GParamSpec * pspec, GstDiscoverer * dc);
 196 
 197 static void gst_discoverer_dispose (GObject * dc);
 198 static void gst_discoverer_finalize (GObject * dc);
 199 static void gst_discoverer_set_property (GObject * object, guint prop_id,
 200     const GValue * value, GParamSpec * pspec);
 201 static void gst_discoverer_get_property (GObject * object, guint prop_id,
 202     GValue * value, GParamSpec * pspec);
<a name="8" id="anc8"></a>






 203 
 204 static void
 205 gst_discoverer_class_init (GstDiscovererClass * klass)
 206 {
 207   GObjectClass *gobject_class = (GObjectClass *) klass;
 208 
 209   gobject_class-&gt;dispose = gst_discoverer_dispose;
 210   gobject_class-&gt;finalize = gst_discoverer_finalize;
 211 
 212   gobject_class-&gt;set_property = gst_discoverer_set_property;
 213   gobject_class-&gt;get_property = gst_discoverer_get_property;
 214 
<a name="9" id="anc9"></a><span class="line-removed"> 215   g_type_class_add_private (klass, sizeof (GstDiscovererPrivate));</span>
 216 
 217   /* properties */
 218   /**
 219    * GstDiscoverer:timeout:
 220    *
 221    * The duration (in nanoseconds) after which the discovery of an individual
 222    * URI will timeout.
 223    *
 224    * If the discovery of a URI times out, the %GST_DISCOVERER_TIMEOUT will be
 225    * set on the result flags.
 226    */
 227   g_object_class_install_property (gobject_class, PROP_TIMEOUT,
 228       g_param_spec_uint64 (&quot;timeout&quot;, &quot;timeout&quot;, &quot;Timeout&quot;,
 229           GST_SECOND, 3600 * GST_SECOND, DEFAULT_PROP_TIMEOUT,
 230           G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS));
 231 
<a name="10" id="anc10"></a>

















 232   /* signals */
 233   /**
 234    * GstDiscoverer::finished:
 235    * @discoverer: the #GstDiscoverer
 236    *
 237    * Will be emitted in async mode when all pending URIs have been processed.
 238    */
 239   gst_discoverer_signals[SIGNAL_FINISHED] =
 240       g_signal_new (&quot;finished&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 241       G_STRUCT_OFFSET (GstDiscovererClass, finished),
 242       NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0, G_TYPE_NONE);
 243 
 244   /**
 245    * GstDiscoverer::starting:
 246    * @discoverer: the #GstDiscoverer
 247    *
 248    * Will be emitted when the discover starts analyzing the pending URIs
 249    */
 250   gst_discoverer_signals[SIGNAL_STARTING] =
 251       g_signal_new (&quot;starting&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 252       G_STRUCT_OFFSET (GstDiscovererClass, starting),
 253       NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0, G_TYPE_NONE);
 254 
 255   /**
 256    * GstDiscoverer::discovered:
 257    * @discoverer: the #GstDiscoverer
 258    * @info: the results #GstDiscovererInfo
 259    * @error: (allow-none) (type GLib.Error): #GError, which will be non-NULL
 260    *                                         if an error occurred during
 261    *                                         discovery. You must not free
 262    *                                         this #GError, it will be freed by
 263    *                                         the discoverer.
 264    *
 265    * Will be emitted in async mode when all information on a URI could be
 266    * discovered, or an error occurred.
 267    *
 268    * When an error occurs, @info might still contain some partial information,
 269    * depending on the circumstances of the error.
 270    */
 271   gst_discoverer_signals[SIGNAL_DISCOVERED] =
 272       g_signal_new (&quot;discovered&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 273       G_STRUCT_OFFSET (GstDiscovererClass, discovered),
 274       NULL, NULL, g_cclosure_marshal_generic,
 275       G_TYPE_NONE, 2, GST_TYPE_DISCOVERER_INFO,
 276       G_TYPE_ERROR | G_SIGNAL_TYPE_STATIC_SCOPE);
 277 
 278   /**
 279    * GstDiscoverer::source-setup:
 280    * @discoverer: the #GstDiscoverer
 281    * @source: source element
 282    *
 283    * This signal is emitted after the source element has been created for, so
 284    * the URI being discovered, so it can be configured by setting additional
 285    * properties (e.g. set a proxy server for an http source, or set the device
 286    * and read speed for an audio cd source).
 287    *
 288    * This signal is usually emitted from the context of a GStreamer streaming
 289    * thread.
 290    */
 291   gst_discoverer_signals[SIGNAL_SOURCE_SETUP] =
 292       g_signal_new (&quot;source-setup&quot;, G_TYPE_FROM_CLASS (klass),
 293       G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstDiscovererClass, source_setup),
 294       NULL, NULL, g_cclosure_marshal_generic, G_TYPE_NONE, 1, GST_TYPE_ELEMENT);
 295 }
 296 
 297 static void
 298 uridecodebin_element_added_cb (GstElement * uridecodebin,
 299     GstElement * child, GstDiscoverer * dc)
 300 {
 301   GST_DEBUG (&quot;New element added to uridecodebin : %s&quot;,
 302       GST_ELEMENT_NAME (child));
 303 
 304   if (G_OBJECT_TYPE (child) == dc-&gt;priv-&gt;decodebin_type) {
 305     g_object_set (child, &quot;post-stream-topology&quot;, TRUE, NULL);
 306   }
 307 }
 308 
 309 static void
 310 gst_discoverer_init (GstDiscoverer * dc)
 311 {
 312   GstElement *tmp;
 313   GstFormat format = GST_FORMAT_TIME;
 314 
<a name="11" id="anc11"></a><span class="line-modified"> 315   dc-&gt;priv = G_TYPE_INSTANCE_GET_PRIVATE (dc, GST_TYPE_DISCOVERER,</span>
<span class="line-removed"> 316       GstDiscovererPrivate);</span>
 317 
 318   dc-&gt;priv-&gt;timeout = DEFAULT_PROP_TIMEOUT;
<a name="12" id="anc12"></a>
 319   dc-&gt;priv-&gt;async = FALSE;
 320 
 321   g_mutex_init (&amp;dc-&gt;priv-&gt;lock);
 322 
 323   dc-&gt;priv-&gt;pending_subtitle_pads = 0;
 324 
 325   dc-&gt;priv-&gt;current_state = GST_STATE_NULL;
 326   dc-&gt;priv-&gt;target_state = GST_STATE_NULL;
 327   dc-&gt;priv-&gt;no_more_pads = FALSE;
 328 
 329   GST_LOG (&quot;Creating pipeline&quot;);
 330   dc-&gt;priv-&gt;pipeline = (GstBin *) gst_pipeline_new (&quot;Discoverer&quot;);
 331   GST_LOG_OBJECT (dc, &quot;Creating uridecodebin&quot;);
 332   dc-&gt;priv-&gt;uridecodebin =
 333       gst_element_factory_make (&quot;uridecodebin&quot;, &quot;discoverer-uri&quot;);
 334   if (G_UNLIKELY (dc-&gt;priv-&gt;uridecodebin == NULL)) {
 335     GST_ERROR (&quot;Can&#39;t create uridecodebin&quot;);
 336     return;
 337   }
 338   GST_LOG_OBJECT (dc, &quot;Adding uridecodebin to pipeline&quot;);
 339   gst_bin_add (dc-&gt;priv-&gt;pipeline, dc-&gt;priv-&gt;uridecodebin);
 340 
 341   dc-&gt;priv-&gt;pad_added_id =
 342       g_signal_connect_object (dc-&gt;priv-&gt;uridecodebin, &quot;pad-added&quot;,
 343       G_CALLBACK (uridecodebin_pad_added_cb), dc, 0);
 344   dc-&gt;priv-&gt;pad_remove_id =
 345       g_signal_connect_object (dc-&gt;priv-&gt;uridecodebin, &quot;pad-removed&quot;,
 346       G_CALLBACK (uridecodebin_pad_removed_cb), dc, 0);
 347   dc-&gt;priv-&gt;no_more_pads_id =
 348       g_signal_connect_object (dc-&gt;priv-&gt;uridecodebin, &quot;no-more-pads&quot;,
 349       G_CALLBACK (uridecodebin_no_more_pads_cb), dc, 0);
 350   dc-&gt;priv-&gt;source_chg_id =
 351       g_signal_connect_object (dc-&gt;priv-&gt;uridecodebin, &quot;notify::source&quot;,
 352       G_CALLBACK (uridecodebin_source_changed_cb), dc, 0);
 353 
 354   GST_LOG_OBJECT (dc, &quot;Getting pipeline bus&quot;);
 355   dc-&gt;priv-&gt;bus = gst_pipeline_get_bus ((GstPipeline *) dc-&gt;priv-&gt;pipeline);
 356 
 357   dc-&gt;priv-&gt;bus_cb_id =
 358       g_signal_connect_object (dc-&gt;priv-&gt;bus, &quot;message&quot;,
 359       G_CALLBACK (discoverer_bus_cb), dc, 0);
 360 
 361   GST_DEBUG_OBJECT (dc, &quot;Done initializing Discoverer&quot;);
 362 
 363   /* This is ugly. We get the GType of decodebin so we can quickly detect
 364    * when a decodebin is added to uridecodebin so we can set the
 365    * post-stream-topology setting to TRUE */
 366   dc-&gt;priv-&gt;element_added_id =
 367       g_signal_connect_object (dc-&gt;priv-&gt;uridecodebin, &quot;element-added&quot;,
 368       G_CALLBACK (uridecodebin_element_added_cb), dc, 0);
 369   tmp = gst_element_factory_make (&quot;decodebin&quot;, NULL);
 370   dc-&gt;priv-&gt;decodebin_type = G_OBJECT_TYPE (tmp);
 371   gst_object_unref (tmp);
 372 
 373   /* create queries */
 374   dc-&gt;priv-&gt;seeking_query = gst_query_new_seeking (format);
 375 }
 376 
 377 static void
 378 discoverer_reset (GstDiscoverer * dc)
 379 {
 380   GST_DEBUG_OBJECT (dc, &quot;Resetting&quot;);
 381 
 382   if (dc-&gt;priv-&gt;pending_uris) {
 383     g_list_foreach (dc-&gt;priv-&gt;pending_uris, (GFunc) g_free, NULL);
 384     g_list_free (dc-&gt;priv-&gt;pending_uris);
 385     dc-&gt;priv-&gt;pending_uris = NULL;
 386   }
 387 
 388   if (dc-&gt;priv-&gt;pipeline)
 389     gst_element_set_state ((GstElement *) dc-&gt;priv-&gt;pipeline, GST_STATE_NULL);
 390 }
 391 
 392 #define DISCONNECT_SIGNAL(o,i) G_STMT_START{           \
 393   if ((i) &amp;&amp; g_signal_handler_is_connected ((o), (i))) \
 394     g_signal_handler_disconnect ((o), (i));            \
 395   (i) = 0;                                             \
 396 }G_STMT_END
 397 
 398 static void
 399 gst_discoverer_dispose (GObject * obj)
 400 {
 401   GstDiscoverer *dc = (GstDiscoverer *) obj;
 402 
 403   GST_DEBUG_OBJECT (dc, &quot;Disposing&quot;);
 404 
 405   discoverer_reset (dc);
 406 
 407   if (G_LIKELY (dc-&gt;priv-&gt;pipeline)) {
 408     /* Workaround for bug #118536 */
 409     DISCONNECT_SIGNAL (dc-&gt;priv-&gt;uridecodebin, dc-&gt;priv-&gt;pad_added_id);
 410     DISCONNECT_SIGNAL (dc-&gt;priv-&gt;uridecodebin, dc-&gt;priv-&gt;pad_remove_id);
 411     DISCONNECT_SIGNAL (dc-&gt;priv-&gt;uridecodebin, dc-&gt;priv-&gt;no_more_pads_id);
 412     DISCONNECT_SIGNAL (dc-&gt;priv-&gt;uridecodebin, dc-&gt;priv-&gt;source_chg_id);
 413     DISCONNECT_SIGNAL (dc-&gt;priv-&gt;uridecodebin, dc-&gt;priv-&gt;element_added_id);
 414     DISCONNECT_SIGNAL (dc-&gt;priv-&gt;bus, dc-&gt;priv-&gt;bus_cb_id);
 415 
 416     /* pipeline was set to NULL in _reset */
 417     gst_object_unref (dc-&gt;priv-&gt;pipeline);
 418     if (dc-&gt;priv-&gt;bus)
 419       gst_object_unref (dc-&gt;priv-&gt;bus);
 420 
 421     dc-&gt;priv-&gt;pipeline = NULL;
 422     dc-&gt;priv-&gt;uridecodebin = NULL;
 423     dc-&gt;priv-&gt;bus = NULL;
 424   }
 425 
 426   gst_discoverer_stop (dc);
 427 
 428   if (dc-&gt;priv-&gt;seeking_query) {
 429     gst_query_unref (dc-&gt;priv-&gt;seeking_query);
 430     dc-&gt;priv-&gt;seeking_query = NULL;
 431   }
 432 
 433   G_OBJECT_CLASS (gst_discoverer_parent_class)-&gt;dispose (obj);
 434 }
 435 
 436 static void
 437 gst_discoverer_finalize (GObject * obj)
 438 {
 439   GstDiscoverer *dc = (GstDiscoverer *) obj;
 440 
 441   g_mutex_clear (&amp;dc-&gt;priv-&gt;lock);
 442 
 443   G_OBJECT_CLASS (gst_discoverer_parent_class)-&gt;finalize (obj);
 444 }
 445 
 446 static void
 447 gst_discoverer_set_property (GObject * object, guint prop_id,
 448     const GValue * value, GParamSpec * pspec)
 449 {
 450   GstDiscoverer *dc = (GstDiscoverer *) object;
 451 
 452   switch (prop_id) {
 453     case PROP_TIMEOUT:
 454       gst_discoverer_set_timeout (dc, g_value_get_uint64 (value));
 455       break;
<a name="13" id="anc13"></a>




 456     default:
 457       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 458       break;
 459   }
 460 }
 461 
 462 static void
 463 gst_discoverer_get_property (GObject * object, guint prop_id,
 464     GValue * value, GParamSpec * pspec)
 465 {
 466   GstDiscoverer *dc = (GstDiscoverer *) object;
 467 
 468   switch (prop_id) {
 469     case PROP_TIMEOUT:
 470       DISCO_LOCK (dc);
 471       g_value_set_uint64 (value, dc-&gt;priv-&gt;timeout);
 472       DISCO_UNLOCK (dc);
 473       break;
<a name="14" id="anc14"></a>




 474     default:
 475       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 476       break;
 477   }
 478 }
 479 
 480 static void
 481 gst_discoverer_set_timeout (GstDiscoverer * dc, GstClockTime timeout)
 482 {
 483   GST_DEBUG_OBJECT (dc, &quot;timeout : %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (timeout));
 484 
 485   /* FIXME : update current pending timeout if we&#39;re running */
 486   DISCO_LOCK (dc);
 487   dc-&gt;priv-&gt;timeout = timeout;
 488   DISCO_UNLOCK (dc);
 489 }
 490 
 491 static GstPadProbeReturn
 492 _event_probe (GstPad * pad, GstPadProbeInfo * info, PrivateStream * ps)
 493 {
 494   GstEvent *event = GST_PAD_PROBE_INFO_EVENT (info);
 495 
 496   switch (GST_EVENT_TYPE (event)) {
 497     case GST_EVENT_TAG:{
 498       GstTagList *tl = NULL, *tmp;
 499 
 500       gst_event_parse_tag (event, &amp;tl);
 501       GST_DEBUG_OBJECT (pad, &quot;tags %&quot; GST_PTR_FORMAT, tl);
 502       DISCO_LOCK (ps-&gt;dc);
 503       /* If preroll is complete, drop these tags - the collected information is
 504        * possibly already being processed and adding more tags would be racy */
 505       if (G_LIKELY (ps-&gt;dc-&gt;priv-&gt;processing)) {
 506         GST_DEBUG_OBJECT (pad, &quot;private stream %p old tags %&quot; GST_PTR_FORMAT,
 507             ps, ps-&gt;tags);
 508         tmp = gst_tag_list_merge (ps-&gt;tags, tl, GST_TAG_MERGE_APPEND);
 509         if (ps-&gt;tags)
 510           gst_tag_list_unref (ps-&gt;tags);
 511         ps-&gt;tags = tmp;
 512         GST_DEBUG_OBJECT (pad, &quot;private stream %p new tags %&quot; GST_PTR_FORMAT,
 513             ps, tmp);
 514       } else
 515         GST_DEBUG_OBJECT (pad, &quot;Dropping tags since preroll is done&quot;);
 516       DISCO_UNLOCK (ps-&gt;dc);
 517       break;
 518     }
 519     case GST_EVENT_TOC:{
 520       GstToc *tmp;
 521 
 522       gst_event_parse_toc (event, &amp;tmp, NULL);
 523       GST_DEBUG_OBJECT (pad, &quot;toc %&quot; GST_PTR_FORMAT, tmp);
 524       DISCO_LOCK (ps-&gt;dc);
 525       ps-&gt;toc = tmp;
 526       if (G_LIKELY (ps-&gt;dc-&gt;priv-&gt;processing)) {
 527         GST_DEBUG_OBJECT (pad, &quot;private stream %p toc %&quot; GST_PTR_FORMAT, ps,
 528             tmp);
 529       } else
 530         GST_DEBUG_OBJECT (pad, &quot;Dropping toc since preroll is done&quot;);
 531       DISCO_UNLOCK (ps-&gt;dc);
 532       break;
 533     }
 534     case GST_EVENT_STREAM_START:{
 535       const gchar *stream_id;
 536 
 537       gst_event_parse_stream_start (event, &amp;stream_id);
 538 
 539       g_free (ps-&gt;stream_id);
 540       ps-&gt;stream_id = stream_id ? g_strdup (stream_id) : NULL;
 541       break;
 542     }
 543     default:
 544       break;
 545   }
 546 
 547   return GST_PAD_PROBE_OK;
 548 }
 549 
<a name="15" id="anc15"></a><span class="line-modified"> 550 static GstStaticCaps subtitle_caps = GST_STATIC_CAPS (&quot;text/x-raw; &quot;</span>
<span class="line-modified"> 551     &quot;subpicture/x-pgs; subpicture/x-dvb; subpicture/x-dvd; &quot;</span>
<span class="line-modified"> 552     &quot;application/x-subtitle-unknown; application/x-ssa; application/x-ass; &quot;</span>
<span class="line-removed"> 553     &quot;subtitle/x-kate; application/x-kate; subpicture/x-xsub&quot;);</span>
 554 
 555 static gboolean
 556 is_subtitle_caps (const GstCaps * caps)
 557 {
 558   GstCaps *subs_caps;
<a name="16" id="anc16"></a>

 559   gboolean ret;
 560 
<a name="17" id="anc17"></a>











 561   subs_caps = gst_static_caps_get (&amp;subtitle_caps);
 562   ret = gst_caps_can_intersect (caps, subs_caps);
 563   gst_caps_unref (subs_caps);
 564 
 565   return ret;
 566 }
 567 
 568 static GstPadProbeReturn
 569 got_subtitle_data (GstPad * pad, GstPadProbeInfo * info, GstDiscoverer * dc)
 570 {
 571   GstMessage *msg;
 572 
 573   if (!(GST_IS_BUFFER (info-&gt;data) || (GST_IS_EVENT (info-&gt;data)
 574               &amp;&amp; (GST_EVENT_TYPE ((GstEvent *) info-&gt;data) == GST_EVENT_GAP
 575                   || GST_EVENT_TYPE ((GstEvent *) info-&gt;data) ==
 576                   GST_EVENT_EOS))))
 577     return GST_PAD_PROBE_OK;
 578 
 579 
 580   DISCO_LOCK (dc);
 581 
 582   dc-&gt;priv-&gt;pending_subtitle_pads--;
 583 
 584   msg = gst_message_new_application (NULL,
 585       gst_structure_new_empty (&quot;DiscovererDone&quot;));
 586   gst_element_post_message ((GstElement *) dc-&gt;priv-&gt;pipeline, msg);
 587 
 588   DISCO_UNLOCK (dc);
 589 
 590   return GST_PAD_PROBE_REMOVE;
 591 
 592 }
 593 
 594 static void
 595 uridecodebin_source_changed_cb (GstElement * uridecodebin,
 596     GParamSpec * pspec, GstDiscoverer * dc)
 597 {
 598   GstElement *src;
 599   /* get a handle to the source */
 600   g_object_get (uridecodebin, pspec-&gt;name, &amp;src, NULL);
 601 
 602   GST_DEBUG_OBJECT (dc, &quot;got a new source %p&quot;, src);
 603 
 604   g_signal_emit (dc, gst_discoverer_signals[SIGNAL_SOURCE_SETUP], 0, src);
 605   gst_object_unref (src);
 606 }
 607 
 608 static void
 609 uridecodebin_pad_added_cb (GstElement * uridecodebin, GstPad * pad,
 610     GstDiscoverer * dc)
 611 {
 612   PrivateStream *ps;
 613   GstPad *sinkpad = NULL;
 614   GstCaps *caps;
 615   gchar *padname;
 616   gchar *tmpname;
 617 
 618   GST_DEBUG_OBJECT (dc, &quot;pad %s:%s&quot;, GST_DEBUG_PAD_NAME (pad));
 619 
 620   DISCO_LOCK (dc);
 621   if (dc-&gt;priv-&gt;cleanup) {
 622     GST_WARNING_OBJECT (dc, &quot;Cleanup, not adding pad&quot;);
 623     DISCO_UNLOCK (dc);
 624     return;
 625   }
 626   if (dc-&gt;priv-&gt;current_error) {
 627     GST_WARNING_OBJECT (dc, &quot;Ongoing error, not adding more pads&quot;);
 628     DISCO_UNLOCK (dc);
 629     return;
 630   }
 631   ps = g_slice_new0 (PrivateStream);
 632 
 633   ps-&gt;dc = dc;
 634   ps-&gt;pad = pad;
 635   padname = gst_pad_get_name (pad);
 636   tmpname = g_strdup_printf (&quot;discoverer-queue-%s&quot;, padname);
 637   ps-&gt;queue = gst_element_factory_make (&quot;queue&quot;, tmpname);
 638   g_free (tmpname);
 639   tmpname = g_strdup_printf (&quot;discoverer-sink-%s&quot;, padname);
 640   ps-&gt;sink = gst_element_factory_make (&quot;fakesink&quot;, tmpname);
 641   g_free (tmpname);
 642   g_free (padname);
 643 
 644   if (G_UNLIKELY (ps-&gt;queue == NULL || ps-&gt;sink == NULL))
 645     goto error;
 646 
 647   g_object_set (ps-&gt;sink, &quot;silent&quot;, TRUE, NULL);
 648   g_object_set (ps-&gt;queue, &quot;max-size-buffers&quot;, 1, &quot;silent&quot;, TRUE, NULL);
 649 
 650   caps = gst_pad_query_caps (pad, NULL);
 651 
 652   sinkpad = gst_element_get_static_pad (ps-&gt;queue, &quot;sink&quot;);
 653   if (sinkpad == NULL)
 654     goto error;
 655 
 656   if (is_subtitle_caps (caps)) {
 657     /* Subtitle streams are sparse and may not provide any information - don&#39;t
 658      * wait for data to preroll */
 659     ps-&gt;probe_id =
 660         gst_pad_add_probe (sinkpad, GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM,
 661         (GstPadProbeCallback) got_subtitle_data, dc, NULL);
 662     g_object_set (ps-&gt;sink, &quot;async&quot;, FALSE, NULL);
 663     dc-&gt;priv-&gt;pending_subtitle_pads++;
 664   }
 665 
 666   gst_caps_unref (caps);
 667 
 668   gst_bin_add_many (dc-&gt;priv-&gt;pipeline, ps-&gt;queue, ps-&gt;sink, NULL);
 669 
 670   if (!gst_element_link_pads_full (ps-&gt;queue, &quot;src&quot;, ps-&gt;sink, &quot;sink&quot;,
 671           GST_PAD_LINK_CHECK_NOTHING))
 672     goto error;
 673   if (!gst_element_sync_state_with_parent (ps-&gt;sink))
 674     goto error;
 675   if (!gst_element_sync_state_with_parent (ps-&gt;queue))
 676     goto error;
 677 
 678   if (gst_pad_link_full (pad, sinkpad,
 679           GST_PAD_LINK_CHECK_NOTHING) != GST_PAD_LINK_OK)
 680     goto error;
 681   gst_object_unref (sinkpad);
 682 
 683   /* Add an event probe */
 684   gst_pad_add_probe (pad, GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM,
 685       (GstPadProbeCallback) _event_probe, ps, NULL);
 686 
 687   dc-&gt;priv-&gt;streams = g_list_append (dc-&gt;priv-&gt;streams, ps);
 688   DISCO_UNLOCK (dc);
 689 
 690   GST_DEBUG_OBJECT (dc, &quot;Done handling pad&quot;);
 691 
 692   return;
 693 
 694 error:
 695   GST_ERROR_OBJECT (dc, &quot;Error while handling pad&quot;);
 696   if (sinkpad)
 697     gst_object_unref (sinkpad);
 698   if (ps-&gt;queue)
 699     gst_object_unref (ps-&gt;queue);
 700   if (ps-&gt;sink)
 701     gst_object_unref (ps-&gt;sink);
 702   g_slice_free (PrivateStream, ps);
 703   DISCO_UNLOCK (dc);
 704   return;
 705 }
 706 
 707 static void
 708 uridecodebin_no_more_pads_cb (GstElement * uridecodebin, GstDiscoverer * dc)
 709 {
 710   GstMessage *msg = gst_message_new_application (NULL,
 711       gst_structure_new_empty (&quot;DiscovererDone&quot;));
 712 
 713   DISCO_LOCK (dc);
 714   dc-&gt;priv-&gt;no_more_pads = TRUE;
 715   gst_element_post_message ((GstElement *) dc-&gt;priv-&gt;pipeline, msg);
 716   DISCO_UNLOCK (dc);
 717 }
 718 
 719 static void
 720 uridecodebin_pad_removed_cb (GstElement * uridecodebin, GstPad * pad,
 721     GstDiscoverer * dc)
 722 {
 723   GList *tmp;
 724   PrivateStream *ps;
 725   GstPad *sinkpad;
 726 
 727   GST_DEBUG_OBJECT (dc, &quot;pad %s:%s&quot;, GST_DEBUG_PAD_NAME (pad));
 728 
 729   /* Find the PrivateStream */
 730   DISCO_LOCK (dc);
 731   for (tmp = dc-&gt;priv-&gt;streams; tmp; tmp = tmp-&gt;next) {
 732     ps = (PrivateStream *) tmp-&gt;data;
 733     if (ps-&gt;pad == pad)
 734       break;
 735   }
 736 
 737   if (tmp == NULL) {
 738     DISCO_UNLOCK (dc);
 739     GST_DEBUG (&quot;The removed pad wasn&#39;t controlled by us !&quot;);
 740     return;
 741   }
 742 
 743   if (ps-&gt;probe_id)
 744     gst_pad_remove_probe (pad, ps-&gt;probe_id);
 745 
 746   dc-&gt;priv-&gt;streams = g_list_delete_link (dc-&gt;priv-&gt;streams, tmp);
 747 
 748   gst_element_set_state (ps-&gt;sink, GST_STATE_NULL);
 749   gst_element_set_state (ps-&gt;queue, GST_STATE_NULL);
 750   gst_element_unlink (ps-&gt;queue, ps-&gt;sink);
 751 
 752   sinkpad = gst_element_get_static_pad (ps-&gt;queue, &quot;sink&quot;);
 753   gst_pad_unlink (pad, sinkpad);
 754   gst_object_unref (sinkpad);
 755 
 756   /* references removed here */
 757   gst_bin_remove_many (dc-&gt;priv-&gt;pipeline, ps-&gt;sink, ps-&gt;queue, NULL);
 758 
 759   DISCO_UNLOCK (dc);
 760   if (ps-&gt;tags) {
 761     gst_tag_list_unref (ps-&gt;tags);
 762   }
 763   if (ps-&gt;toc) {
 764     gst_toc_unref (ps-&gt;toc);
 765   }
 766   g_free (ps-&gt;stream_id);
 767 
 768   g_slice_free (PrivateStream, ps);
 769 
 770   GST_DEBUG (&quot;Done handling pad&quot;);
 771 }
 772 
 773 static GstStructure *
 774 collect_stream_information (GstDiscoverer * dc, PrivateStream * ps, guint idx)
 775 {
 776   GstCaps *caps;
 777   GstStructure *st;
 778   gchar *stname;
 779 
 780   stname = g_strdup_printf (&quot;stream-%02d&quot;, idx);
 781   st = gst_structure_new_empty (stname);
 782   g_free (stname);
 783 
 784   /* Get caps */
 785   caps = gst_pad_get_current_caps (ps-&gt;pad);
 786   if (!caps) {
 787     GST_WARNING (&quot;Couldn&#39;t get negotiated caps from %s:%s&quot;,
 788         GST_DEBUG_PAD_NAME (ps-&gt;pad));
 789     caps = gst_pad_query_caps (ps-&gt;pad, NULL);
 790   }
 791   if (caps) {
 792     GST_DEBUG (&quot;stream-%02d, got caps %&quot; GST_PTR_FORMAT, idx, caps);
 793     gst_structure_id_set (st, _CAPS_QUARK, GST_TYPE_CAPS, caps, NULL);
 794     gst_caps_unref (caps);
 795   }
 796   if (ps-&gt;tags)
 797     gst_structure_id_set (st, _TAGS_QUARK, GST_TYPE_TAG_LIST, ps-&gt;tags, NULL);
 798   if (ps-&gt;toc)
 799     gst_structure_id_set (st, _TOC_QUARK, GST_TYPE_TOC, ps-&gt;toc, NULL);
 800   if (ps-&gt;stream_id)
 801     gst_structure_id_set (st, _STREAM_ID_QUARK, G_TYPE_STRING, ps-&gt;stream_id,
 802         NULL);
 803 
 804   return st;
 805 }
 806 
 807 /* takes ownership of new_tags, may replace *taglist with a new one */
 808 static void
 809 gst_discoverer_merge_and_replace_tags (GstTagList ** taglist,
 810     GstTagList * new_tags)
 811 {
 812   if (new_tags == NULL)
 813     return;
 814 
 815   if (*taglist == NULL) {
 816     *taglist = new_tags;
 817     return;
 818   }
 819 
 820   gst_tag_list_insert (*taglist, new_tags, GST_TAG_MERGE_REPLACE);
 821   gst_tag_list_unref (new_tags);
 822 }
 823 
 824 static void
 825 collect_common_information (GstDiscovererStreamInfo * info,
 826     const GstStructure * st)
 827 {
 828   if (gst_structure_id_has_field (st, _TOC_QUARK)) {
 829     gst_structure_id_get (st, _TOC_QUARK, GST_TYPE_TOC, &amp;info-&gt;toc, NULL);
 830   }
 831 
 832   if (gst_structure_id_has_field (st, _STREAM_ID_QUARK)) {
 833     gst_structure_id_get (st, _STREAM_ID_QUARK, G_TYPE_STRING, &amp;info-&gt;stream_id,
 834         NULL);
 835   }
 836 }
 837 
 838 static GstDiscovererStreamInfo *
 839 make_info (GstDiscovererStreamInfo * parent, GType type, GstCaps * caps)
 840 {
 841   GstDiscovererStreamInfo *info;
 842 
 843   if (parent)
 844     info = gst_discoverer_stream_info_ref (parent);
 845   else {
 846     info = g_object_new (type, NULL);
 847     if (caps)
 848       info-&gt;caps = gst_caps_ref (caps);
 849   }
 850   return info;
 851 }
 852 
 853 /* Parses a set of caps and tags in st and populates a GstDiscovererStreamInfo
 854  * structure (parent, if !NULL, otherwise it allocates one)
 855  */
 856 static GstDiscovererStreamInfo *
 857 collect_information (GstDiscoverer * dc, const GstStructure * st,
 858     GstDiscovererStreamInfo * parent)
 859 {
 860   GstPad *srcpad;
 861   GstCaps *caps = NULL;
 862   GstStructure *caps_st;
 863   GstTagList *tags_st;
 864   const gchar *name;
 865   gint tmp, tmp2;
 866   guint utmp;
 867 
 868   if (!st || (!gst_structure_id_has_field (st, _CAPS_QUARK)
 869           &amp;&amp; !gst_structure_id_has_field (st, _ELEMENT_SRCPAD_QUARK))) {
 870     GST_WARNING (&quot;Couldn&#39;t find caps !&quot;);
 871     return make_info (parent, GST_TYPE_DISCOVERER_STREAM_INFO, NULL);
 872   }
 873 
 874   if (gst_structure_id_get (st, _ELEMENT_SRCPAD_QUARK, GST_TYPE_PAD, &amp;srcpad,
 875           NULL)) {
 876     caps = gst_pad_get_current_caps (srcpad);
 877     gst_object_unref (srcpad);
 878   }
 879   if (!caps) {
 880     gst_structure_id_get (st, _CAPS_QUARK, GST_TYPE_CAPS, &amp;caps, NULL);
 881   }
 882 
 883   if (!caps || gst_caps_is_empty (caps) || gst_caps_is_any (caps)) {
 884     GST_WARNING (&quot;Couldn&#39;t find caps !&quot;);
 885     if (caps)
 886       gst_caps_unref (caps);
 887     return make_info (parent, GST_TYPE_DISCOVERER_STREAM_INFO, NULL);
 888   }
 889 
 890   caps_st = gst_caps_get_structure (caps, 0);
 891   name = gst_structure_get_name (caps_st);
 892 
 893   if (g_str_has_prefix (name, &quot;audio/&quot;)) {
 894     GstDiscovererAudioInfo *info;
 895     const gchar *format_str;
 896     guint64 channel_mask;
 897 
 898     info = (GstDiscovererAudioInfo *) make_info (parent,
 899         GST_TYPE_DISCOVERER_AUDIO_INFO, caps);
 900 
 901     if (gst_structure_get_int (caps_st, &quot;rate&quot;, &amp;tmp))
 902       info-&gt;sample_rate = (guint) tmp;
 903 
 904     if (gst_structure_get_int (caps_st, &quot;channels&quot;, &amp;tmp))
 905       info-&gt;channels = (guint) tmp;
 906 
 907     if (gst_structure_get (caps_st, &quot;channel-mask&quot;, GST_TYPE_BITMASK,
 908             &amp;channel_mask, NULL)) {
 909       info-&gt;channel_mask = channel_mask;
 910     } else if (info-&gt;channels) {
 911       info-&gt;channel_mask = gst_audio_channel_get_fallback_mask (info-&gt;channels);
 912     }
 913 
 914     /* FIXME: we only want to extract depth if raw audio is what&#39;s in the
 915      * container (i.e. not if there is a decoder involved) */
 916     format_str = gst_structure_get_string (caps_st, &quot;format&quot;);
 917     if (format_str != NULL) {
 918       const GstAudioFormatInfo *finfo;
 919       GstAudioFormat format;
 920 
 921       format = gst_audio_format_from_string (format_str);
 922       finfo = gst_audio_format_get_info (format);
 923       if (finfo)
 924         info-&gt;depth = GST_AUDIO_FORMAT_INFO_DEPTH (finfo);
 925     }
 926 
 927     if (gst_structure_id_has_field (st, _TAGS_QUARK)) {
 928       gst_structure_id_get (st, _TAGS_QUARK, GST_TYPE_TAG_LIST, &amp;tags_st, NULL);
 929       if (gst_tag_list_get_uint (tags_st, GST_TAG_BITRATE, &amp;utmp) ||
 930           gst_tag_list_get_uint (tags_st, GST_TAG_NOMINAL_BITRATE, &amp;utmp))
 931         info-&gt;bitrate = utmp;
 932 
 933       if (gst_tag_list_get_uint (tags_st, GST_TAG_MAXIMUM_BITRATE, &amp;utmp))
 934         info-&gt;max_bitrate = utmp;
 935 
 936       /* FIXME: Is it worth it to remove the tags we&#39;ve parsed? */
 937       gst_discoverer_merge_and_replace_tags (&amp;info-&gt;parent.tags, tags_st);
 938     }
 939 
 940     collect_common_information (&amp;info-&gt;parent, st);
 941 
 942     if (!info-&gt;language &amp;&amp; ((GstDiscovererStreamInfo *) info)-&gt;tags) {
 943       gchar *language;
 944       if (gst_tag_list_get_string (((GstDiscovererStreamInfo *) info)-&gt;tags,
 945               GST_TAG_LANGUAGE_CODE, &amp;language)) {
 946         info-&gt;language = language;
 947       }
 948     }
 949 
 950     gst_caps_unref (caps);
 951     return (GstDiscovererStreamInfo *) info;
 952 
 953   } else if (g_str_has_prefix (name, &quot;video/&quot;) ||
 954       g_str_has_prefix (name, &quot;image/&quot;)) {
 955     GstDiscovererVideoInfo *info;
 956     const gchar *caps_str;
 957 
 958     info = (GstDiscovererVideoInfo *) make_info (parent,
 959         GST_TYPE_DISCOVERER_VIDEO_INFO, caps);
 960 
 961     if (gst_structure_get_int (caps_st, &quot;width&quot;, &amp;tmp))
 962       info-&gt;width = (guint) tmp;
 963     if (gst_structure_get_int (caps_st, &quot;height&quot;, &amp;tmp))
 964       info-&gt;height = (guint) tmp;
 965 
 966     if (gst_structure_get_fraction (caps_st, &quot;framerate&quot;, &amp;tmp, &amp;tmp2)) {
 967       info-&gt;framerate_num = (guint) tmp;
 968       info-&gt;framerate_denom = (guint) tmp2;
 969     } else {
 970       info-&gt;framerate_num = 0;
 971       info-&gt;framerate_denom = 1;
 972     }
 973 
 974     if (gst_structure_get_fraction (caps_st, &quot;pixel-aspect-ratio&quot;, &amp;tmp, &amp;tmp2)) {
 975       info-&gt;par_num = (guint) tmp;
 976       info-&gt;par_denom = (guint) tmp2;
 977     } else {
 978       info-&gt;par_num = 1;
 979       info-&gt;par_denom = 1;
 980     }
 981 
 982     /* FIXME: we only want to extract depth if raw video is what&#39;s in the
 983      * container (i.e. not if there is a decoder involved) */
 984     caps_str = gst_structure_get_string (caps_st, &quot;format&quot;);
 985     if (caps_str != NULL) {
 986       const GstVideoFormatInfo *finfo;
 987       GstVideoFormat format;
 988 
 989       format = gst_video_format_from_string (caps_str);
 990       finfo = gst_video_format_get_info (format);
 991       if (finfo)
 992         info-&gt;depth = finfo-&gt;bits * finfo-&gt;n_components;
 993     }
 994 
 995     caps_str = gst_structure_get_string (caps_st, &quot;interlace-mode&quot;);
 996     if (!caps_str || strcmp (caps_str, &quot;progressive&quot;) == 0)
 997       info-&gt;interlaced = FALSE;
 998     else
 999       info-&gt;interlaced = TRUE;
1000 
1001     if (gst_structure_id_has_field (st, _TAGS_QUARK)) {
1002       gst_structure_id_get (st, _TAGS_QUARK, GST_TYPE_TAG_LIST, &amp;tags_st, NULL);
1003       if (gst_tag_list_get_uint (tags_st, GST_TAG_BITRATE, &amp;utmp) ||
1004           gst_tag_list_get_uint (tags_st, GST_TAG_NOMINAL_BITRATE, &amp;utmp))
1005         info-&gt;bitrate = utmp;
1006 
1007       if (gst_tag_list_get_uint (tags_st, GST_TAG_MAXIMUM_BITRATE, &amp;utmp))
1008         info-&gt;max_bitrate = utmp;
1009 
1010       /* FIXME: Is it worth it to remove the tags we&#39;ve parsed? */
1011       gst_discoverer_merge_and_replace_tags (&amp;info-&gt;parent.tags, tags_st);
1012     }
1013 
1014     collect_common_information (&amp;info-&gt;parent, st);
1015 
1016     gst_caps_unref (caps);
1017     return (GstDiscovererStreamInfo *) info;
1018 
1019   } else if (is_subtitle_caps (caps)) {
1020     GstDiscovererSubtitleInfo *info;
1021 
1022     info = (GstDiscovererSubtitleInfo *) make_info (parent,
1023         GST_TYPE_DISCOVERER_SUBTITLE_INFO, caps);
1024 
1025     if (gst_structure_id_has_field (st, _TAGS_QUARK)) {
1026       const gchar *language;
1027 
1028       gst_structure_id_get (st, _TAGS_QUARK, GST_TYPE_TAG_LIST, &amp;tags_st, NULL);
1029 
1030       language = gst_structure_get_string (caps_st, GST_TAG_LANGUAGE_CODE);
1031       if (language)
1032         info-&gt;language = g_strdup (language);
1033 
1034       /* FIXME: Is it worth it to remove the tags we&#39;ve parsed? */
1035       gst_discoverer_merge_and_replace_tags (&amp;info-&gt;parent.tags, tags_st);
1036     }
1037 
1038     collect_common_information (&amp;info-&gt;parent, st);
1039 
1040     if (!info-&gt;language &amp;&amp; ((GstDiscovererStreamInfo *) info)-&gt;tags) {
1041       gchar *language;
1042       if (gst_tag_list_get_string (((GstDiscovererStreamInfo *) info)-&gt;tags,
1043               GST_TAG_LANGUAGE_CODE, &amp;language)) {
1044         info-&gt;language = language;
1045       }
1046     }
1047 
1048     gst_caps_unref (caps);
1049     return (GstDiscovererStreamInfo *) info;
1050 
1051   } else {
1052     /* None of the above - populate what information we can */
1053     GstDiscovererStreamInfo *info;
1054 
1055     info = make_info (parent, GST_TYPE_DISCOVERER_STREAM_INFO, caps);
1056 
1057     if (gst_structure_id_get (st, _TAGS_QUARK, GST_TYPE_TAG_LIST, &amp;tags_st,
1058             NULL)) {
1059       gst_discoverer_merge_and_replace_tags (&amp;info-&gt;tags, tags_st);
1060     }
1061 
1062     collect_common_information (info, st);
1063 
1064     gst_caps_unref (caps);
1065     return info;
1066   }
1067 
1068 }
1069 
1070 static GstStructure *
1071 find_stream_for_node (GstDiscoverer * dc, const GstStructure * topology)
1072 {
1073   GstPad *pad;
1074   GstPad *target_pad = NULL;
1075   GstStructure *st = NULL;
1076   PrivateStream *ps;
1077   guint i;
1078   GList *tmp;
1079 
1080   if (!dc-&gt;priv-&gt;streams) {
1081     return NULL;
1082   }
1083 
1084   if (!gst_structure_id_has_field (topology, _TOPOLOGY_PAD_QUARK)) {
1085     GST_DEBUG (&quot;Could not find pad for node %&quot; GST_PTR_FORMAT, topology);
1086     return NULL;
1087   }
1088 
1089   gst_structure_id_get (topology, _TOPOLOGY_PAD_QUARK,
1090       GST_TYPE_PAD, &amp;pad, NULL);
1091 
1092   for (i = 0, tmp = dc-&gt;priv-&gt;streams; tmp; tmp = tmp-&gt;next, i++) {
1093     ps = (PrivateStream *) tmp-&gt;data;
1094 
1095     target_pad = gst_ghost_pad_get_target (GST_GHOST_PAD (ps-&gt;pad));
1096     if (target_pad == NULL)
1097       continue;
1098     gst_object_unref (target_pad);
1099 
1100     if (target_pad == pad)
1101       break;
1102   }
1103 
1104   if (tmp)
1105     st = collect_stream_information (dc, ps, i);
1106 
1107   gst_object_unref (pad);
1108 
1109   return st;
1110 }
1111 
1112 /* this can fail due to {framed,parsed}={TRUE,FALSE} differences, thus we filter
1113  * the parent */
1114 static gboolean
1115 child_is_same_stream (const GstCaps * _parent, const GstCaps * child)
1116 {
1117   GstCaps *parent;
1118   gboolean res;
1119 
1120   if (_parent == child)
1121     return TRUE;
1122   if (!_parent)
1123     return FALSE;
1124   if (!child)
1125     return FALSE;
1126 
1127   parent = copy_and_clean_caps (_parent);
1128   res = gst_caps_can_intersect (parent, child);
1129   gst_caps_unref (parent);
1130   return res;
1131 }
1132 
1133 
1134 static gboolean
1135 child_is_raw_stream (const GstCaps * parent, const GstCaps * child)
1136 {
1137   const GstStructure *st1, *st2;
1138   const gchar *name1, *name2;
1139 
1140   if (parent == child)
1141     return TRUE;
1142   if (!parent)
1143     return FALSE;
1144   if (!child)
1145     return FALSE;
1146 
1147   st1 = gst_caps_get_structure (parent, 0);
1148   name1 = gst_structure_get_name (st1);
1149   st2 = gst_caps_get_structure (child, 0);
1150   name2 = gst_structure_get_name (st2);
1151 
1152   if ((g_str_has_prefix (name1, &quot;audio/&quot;) &amp;&amp;
1153           g_str_has_prefix (name2, &quot;audio/x-raw&quot;)) ||
1154       ((g_str_has_prefix (name1, &quot;video/&quot;) ||
1155               g_str_has_prefix (name1, &quot;image/&quot;)) &amp;&amp;
1156           g_str_has_prefix (name2, &quot;video/x-raw&quot;))) {
1157     /* child is the &quot;raw&quot; sub-stream corresponding to parent */
1158     return TRUE;
1159   }
1160 
1161   if (is_subtitle_caps (parent))
1162     return TRUE;
1163 
1164   return FALSE;
1165 }
1166 
1167 /* If a parent is non-NULL, collected stream information will be appended to it
1168  * (and where the information exists, it will be overriden)
1169  */
1170 static GstDiscovererStreamInfo *
1171 parse_stream_topology (GstDiscoverer * dc, const GstStructure * topology,
1172     GstDiscovererStreamInfo * parent)
1173 {
1174   GstDiscovererStreamInfo *res = NULL;
1175   GstCaps *caps = NULL;
1176   const GValue *nval = NULL;
1177 
1178   GST_DEBUG (&quot;parsing: %&quot; GST_PTR_FORMAT, topology);
1179 
1180   nval = gst_structure_get_value (topology, &quot;next&quot;);
1181 
1182   if (nval == NULL || GST_VALUE_HOLDS_STRUCTURE (nval)) {
1183     GstStructure *st = find_stream_for_node (dc, topology);
1184     gboolean add_to_list = TRUE;
1185 
1186     if (st) {
1187       res = collect_information (dc, st, parent);
1188       gst_structure_free (st);
1189     } else {
1190       /* Didn&#39;t find a stream structure, so let&#39;s just use the caps we have */
1191       res = collect_information (dc, topology, parent);
1192     }
1193 
1194     if (nval == NULL) {
1195       /* FIXME : aggregate with information from main streams */
1196       GST_DEBUG (&quot;Coudn&#39;t find &#39;next&#39; ! might be the last entry&quot;);
1197     } else {
1198       GstPad *srcpad;
1199 
1200       st = (GstStructure *) gst_value_get_structure (nval);
1201 
1202       GST_DEBUG (&quot;next is a structure %&quot; GST_PTR_FORMAT, st);
1203 
1204       if (!parent)
1205         parent = res;
1206 
1207       if (gst_structure_id_get (st, _ELEMENT_SRCPAD_QUARK, GST_TYPE_PAD,
1208               &amp;srcpad, NULL)) {
1209         caps = gst_pad_get_current_caps (srcpad);
1210         gst_object_unref (srcpad);
1211       }
1212       if (!caps) {
1213         gst_structure_id_get (st, _CAPS_QUARK, GST_TYPE_CAPS, &amp;caps, NULL);
1214       }
1215 
1216       if (caps) {
1217         if (child_is_same_stream (parent-&gt;caps, caps)) {
1218           /* We sometimes get an extra sub-stream from the parser. If this is
1219            * the case, we just replace the parent caps with this stream&#39;s caps
1220            * since they might contain more information */
1221           gst_caps_replace (&amp;parent-&gt;caps, caps);
1222 
1223           parse_stream_topology (dc, st, parent);
1224           add_to_list = FALSE;
1225         } else if (child_is_raw_stream (parent-&gt;caps, caps)) {
1226           /* This is the &quot;raw&quot; stream corresponding to the parent. This
1227            * contains more information than the parent, tags etc. */
1228           parse_stream_topology (dc, st, parent);
1229           add_to_list = FALSE;
1230         } else {
1231           GstDiscovererStreamInfo *next = parse_stream_topology (dc, st, NULL);
1232           res-&gt;next = next;
1233           next-&gt;previous = res;
1234         }
1235         gst_caps_unref (caps);
1236       }
1237     }
1238 
1239     if (add_to_list) {
1240       dc-&gt;priv-&gt;current_info-&gt;stream_list =
1241           g_list_append (dc-&gt;priv-&gt;current_info-&gt;stream_list, res);
1242     } else {
1243       gst_discoverer_stream_info_unref (res);
1244     }
1245 
1246   } else if (GST_VALUE_HOLDS_LIST (nval)) {
1247     guint i, len;
1248     GstDiscovererContainerInfo *cont;
1249     GstTagList *tags;
1250     GstPad *srcpad;
1251 
1252     if (gst_structure_id_get (topology, _ELEMENT_SRCPAD_QUARK, GST_TYPE_PAD,
1253             &amp;srcpad, NULL)) {
1254       caps = gst_pad_get_current_caps (srcpad);
1255       gst_object_unref (srcpad);
1256     }
1257     if (!caps) {
1258       gst_structure_id_get (topology, _CAPS_QUARK, GST_TYPE_CAPS, &amp;caps, NULL);
1259     }
1260 
1261     if (!caps)
1262       GST_WARNING (&quot;Couldn&#39;t find caps !&quot;);
1263 
1264     len = gst_value_list_get_size (nval);
1265     GST_DEBUG (&quot;next is a list of %d entries&quot;, len);
1266 
1267     cont = (GstDiscovererContainerInfo *)
1268         g_object_new (GST_TYPE_DISCOVERER_CONTAINER_INFO, NULL);
1269     cont-&gt;parent.caps = caps;
1270     res = (GstDiscovererStreamInfo *) cont;
1271 
1272     if (gst_structure_id_has_field (topology, _TAGS_QUARK)) {
1273       GstTagList *tmp;
1274 
1275       gst_structure_id_get (topology, _TAGS_QUARK,
1276           GST_TYPE_TAG_LIST, &amp;tags, NULL);
1277 
1278       GST_DEBUG (&quot;Merge tags %&quot; GST_PTR_FORMAT, tags);
1279 
1280       tmp =
1281           gst_tag_list_merge (cont-&gt;parent.tags, (GstTagList *) tags,
1282           GST_TAG_MERGE_APPEND);
1283       gst_tag_list_unref (tags);
1284       if (cont-&gt;parent.tags)
1285         gst_tag_list_unref (cont-&gt;parent.tags);
1286       cont-&gt;parent.tags = tmp;
1287       GST_DEBUG (&quot;Container info tags %&quot; GST_PTR_FORMAT, tmp);
1288     }
1289 
1290     for (i = 0; i &lt; len; i++) {
1291       const GValue *subv = gst_value_list_get_value (nval, i);
1292       const GstStructure *subst = gst_value_get_structure (subv);
1293       GstDiscovererStreamInfo *substream;
1294 
1295       GST_DEBUG (&quot;%d %&quot; GST_PTR_FORMAT, i, subst);
1296 
1297       substream = parse_stream_topology (dc, subst, NULL);
1298 
1299       substream-&gt;previous = res;
1300       cont-&gt;streams =
1301           g_list_append (cont-&gt;streams,
1302           gst_discoverer_stream_info_ref (substream));
1303     }
1304   }
1305 
1306   return res;
1307 }
1308 
<a name="18" id="anc18"></a>














































1309 /* Called when pipeline is pre-rolled */
1310 static void
1311 discoverer_collect (GstDiscoverer * dc)
1312 {
1313   GST_DEBUG (&quot;Collecting information&quot;);
1314 
1315   /* Stop the timeout handler if present */
<a name="19" id="anc19"></a><span class="line-modified">1316   if (dc-&gt;priv-&gt;timeoutid) {</span>
<span class="line-modified">1317     g_source_remove (dc-&gt;priv-&gt;timeoutid);</span>
<span class="line-modified">1318     dc-&gt;priv-&gt;timeoutid = 0;</span>








1319   }
1320 
1321   if (dc-&gt;priv-&gt;streams) {
1322     /* FIXME : Make this querying optional */
1323     if (TRUE) {
1324       GstElement *pipeline = (GstElement *) dc-&gt;priv-&gt;pipeline;
1325       gint64 dur;
1326 
1327       GST_DEBUG (&quot;Attempting to query duration&quot;);
1328 
1329       if (gst_element_query_duration (pipeline, GST_FORMAT_TIME, &amp;dur)) {
1330         GST_DEBUG (&quot;Got duration %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (dur));
1331         dc-&gt;priv-&gt;current_info-&gt;duration = (guint64) dur;
1332       } else if (dc-&gt;priv-&gt;current_info-&gt;result != GST_DISCOVERER_ERROR) {
1333         GstStateChangeReturn sret;
1334         /* Note: We don&#39;t switch to PLAYING if we previously saw an ERROR since
1335          * the state of various element isn&#39;t guaranteed anymore */
1336 
1337         /* Some parsers may not even return a rough estimate right away, e.g.
1338          * because they&#39;ve only processed a single frame so far, so if we
1339          * didn&#39;t get a duration the first time, spin a bit and try again.
1340          * Ugly, but still better than making parsers or other elements return
1341          * completely bogus values. We need some API extensions to solve this
1342          * better. */
1343         GST_INFO (&quot;No duration yet, try a bit harder..&quot;);
1344         /* Make sure we don&#39;t add/remove elements while switching to PLAYING itself */
1345         DISCO_LOCK (dc);
1346         sret = gst_element_set_state (pipeline, GST_STATE_PLAYING);
1347         DISCO_UNLOCK (dc);
1348         if (sret != GST_STATE_CHANGE_FAILURE) {
1349           int i;
1350 
1351           for (i = 0; i &lt; 2; ++i) {
1352             g_usleep (G_USEC_PER_SEC / 20);
1353             if (gst_element_query_duration (pipeline, GST_FORMAT_TIME, &amp;dur)
1354                 &amp;&amp; dur &gt; 0) {
1355               GST_DEBUG (&quot;Got duration %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (dur));
1356               dc-&gt;priv-&gt;current_info-&gt;duration = (guint64) dur;
1357               break;
1358             }
1359           }
1360           gst_element_set_state (pipeline, GST_STATE_PAUSED);
1361         }
1362       }
1363 
1364       if (dc-&gt;priv-&gt;seeking_query) {
1365         if (gst_element_query (pipeline, dc-&gt;priv-&gt;seeking_query)) {
1366           GstFormat format;
1367           gboolean seekable;
1368 
1369           gst_query_parse_seeking (dc-&gt;priv-&gt;seeking_query, &amp;format,
1370               &amp;seekable, NULL, NULL);
1371           if (format == GST_FORMAT_TIME) {
1372             GST_DEBUG (&quot;Got seekable %d&quot;, seekable);
1373             dc-&gt;priv-&gt;current_info-&gt;seekable = seekable;
1374           }
1375         }
1376       }
1377     }
1378 
1379     if (dc-&gt;priv-&gt;target_state == GST_STATE_PAUSED)
1380       dc-&gt;priv-&gt;current_info-&gt;live = FALSE;
1381     else
1382       dc-&gt;priv-&gt;current_info-&gt;live = TRUE;
1383 
1384     if (dc-&gt;priv-&gt;current_topology)
1385       dc-&gt;priv-&gt;current_info-&gt;stream_info = parse_stream_topology (dc,
1386           dc-&gt;priv-&gt;current_topology, NULL);
1387 
1388     /*
1389      * Images need some special handling. They do not have a duration, have
1390      * caps named image/&lt;foo&gt; (th exception being MJPEG video which is also
1391      * type image/jpeg), and should consist of precisely one stream (actually
1392      * initially there are 2, the image and raw stream, but we squash these
1393      * while parsing the stream topology). At some point, if we find that these
1394      * conditions are not sufficient, we can count the number of decoders and
1395      * parsers in the chain, and if there&#39;s more than one decoder, or any
1396      * parser at all, we should not mark this as an image.
1397      */
1398     if (dc-&gt;priv-&gt;current_info-&gt;duration == 0 &amp;&amp;
1399         dc-&gt;priv-&gt;current_info-&gt;stream_info != NULL &amp;&amp;
1400         dc-&gt;priv-&gt;current_info-&gt;stream_info-&gt;next == NULL) {
1401       GstDiscovererStreamInfo *stream_info;
1402       GstStructure *st;
1403 
1404       stream_info = dc-&gt;priv-&gt;current_info-&gt;stream_info;
1405       st = gst_caps_get_structure (stream_info-&gt;caps, 0);
1406 
1407       if (g_str_has_prefix (gst_structure_get_name (st), &quot;image/&quot;))
1408         ((GstDiscovererVideoInfo *) stream_info)-&gt;is_image = TRUE;
1409     }
1410   }
1411 
<a name="20" id="anc20"></a><span class="line-modified">1412   if (dc-&gt;priv-&gt;async) {</span>
<span class="line-modified">1413     GST_DEBUG (&quot;Emitting &#39;discoverered&#39;&quot;);</span>
<span class="line-modified">1414     g_signal_emit (dc, gst_discoverer_signals[SIGNAL_DISCOVERED], 0,</span>
<span class="line-modified">1415         dc-&gt;priv-&gt;current_info, dc-&gt;priv-&gt;current_error);</span>
<span class="line-modified">1416     /* Clients get a copy of current_info since it is a boxed type */</span>
<span class="line-modified">1417     gst_discoverer_info_unref (dc-&gt;priv-&gt;current_info);</span>
<span class="line-modified">1418     dc-&gt;priv-&gt;current_info = NULL;</span>
1419   }
<a name="21" id="anc21"></a>


1420 }
1421 
1422 static void
1423 get_async_cb (gpointer cb_data, GSource * source, GSourceFunc * func,
1424     gpointer * data)
1425 {
1426   *func = (GSourceFunc) async_timeout_cb;
1427   *data = cb_data;
1428 }
1429 
1430 /* Wrapper since GSourceCallbackFuncs don&#39;t expect a return value from ref() */
1431 static void
1432 _void_g_object_ref (gpointer object)
1433 {
1434   g_object_ref (G_OBJECT (object));
1435 }
1436 
1437 static void
1438 handle_current_async (GstDiscoverer * dc)
1439 {
1440   GSource *source;
1441   static GSourceCallbackFuncs cb_funcs = {
1442     _void_g_object_ref,
1443     g_object_unref,
1444     get_async_cb,
1445   };
1446 
1447   /* Attach a timeout to the main context */
1448   source = g_timeout_source_new (dc-&gt;priv-&gt;timeout / GST_MSECOND);
1449   g_source_set_callback_indirect (source, g_object_ref (dc), &amp;cb_funcs);
<a name="22" id="anc22"></a><span class="line-modified">1450   dc-&gt;priv-&gt;timeoutid = g_source_attach (source, dc-&gt;priv-&gt;ctx);</span>
<span class="line-modified">1451   g_source_unref (source);</span>
1452 }
1453 
1454 
1455 /* Returns TRUE if processing should stop */
1456 static gboolean
1457 handle_message (GstDiscoverer * dc, GstMessage * msg)
1458 {
1459   gboolean done = FALSE;
1460   const gchar *dump_name = NULL;
1461 
1462   GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg), &quot;got a %s message&quot;,
1463       GST_MESSAGE_TYPE_NAME (msg));
1464 
1465   switch (GST_MESSAGE_TYPE (msg)) {
1466     case GST_MESSAGE_ERROR:{
1467       GError *gerr;
1468       gchar *debug;
1469 
1470       gst_message_parse_error (msg, &amp;gerr, &amp;debug);
1471       GST_WARNING_OBJECT (GST_MESSAGE_SRC (msg),
1472           &quot;Got an error [debug:%s], [message:%s]&quot;, debug, gerr-&gt;message);
1473       dc-&gt;priv-&gt;current_error = gerr;
1474       g_free (debug);
1475 
1476       /* We need to stop */
1477       done = TRUE;
1478       dump_name = &quot;gst-discoverer-error&quot;;
1479 
1480       /* Don&#39;t override missing plugin result code for missing plugin errors */
1481       if (dc-&gt;priv-&gt;current_info-&gt;result != GST_DISCOVERER_MISSING_PLUGINS ||
1482           (!g_error_matches (gerr, GST_CORE_ERROR,
1483                   GST_CORE_ERROR_MISSING_PLUGIN) &amp;&amp;
1484               !g_error_matches (gerr, GST_STREAM_ERROR,
1485                   GST_STREAM_ERROR_CODEC_NOT_FOUND))) {
1486         GST_DEBUG (&quot;Setting result to ERROR&quot;);
1487         dc-&gt;priv-&gt;current_info-&gt;result = GST_DISCOVERER_ERROR;
1488       }
1489     }
1490       break;
1491 
1492     case GST_MESSAGE_WARNING:{
1493       GError *err;
1494       gchar *debug = NULL;
1495 
1496       gst_message_parse_warning (msg, &amp;err, &amp;debug);
1497       GST_WARNING_OBJECT (GST_MESSAGE_SRC (msg),
1498           &quot;Got a warning [debug:%s], [message:%s]&quot;, debug, err-&gt;message);
1499       g_clear_error (&amp;err);
1500       g_free (debug);
1501       dump_name = &quot;gst-discoverer-warning&quot;;
1502       break;
1503     }
1504 
1505     case GST_MESSAGE_EOS:
1506       GST_DEBUG (&quot;Got EOS !&quot;);
1507       done = TRUE;
1508       dump_name = &quot;gst-discoverer-eos&quot;;
1509       break;
1510 
1511     case GST_MESSAGE_APPLICATION:{
1512       const gchar *name =
1513           gst_structure_get_name (gst_message_get_structure (msg));
1514 
1515       if (g_strcmp0 (name, &quot;DiscovererDone&quot;))
1516         break;
1517 
1518       /* Maybe we already reached the target state, and all we&#39;re waiting for
1519        * is either the subtitle tags or no_more_pads
1520        */
1521       DISCO_LOCK (dc);
1522       if (dc-&gt;priv-&gt;pending_subtitle_pads == 0)
1523         done = dc-&gt;priv-&gt;no_more_pads
1524             &amp;&amp; dc-&gt;priv-&gt;target_state == dc-&gt;priv-&gt;current_state;
1525       DISCO_UNLOCK (dc);
1526 
1527       if (done)
1528         dump_name = &quot;gst-discoverer-application-message&quot;;
1529     }
1530       break;
1531 
1532     case GST_MESSAGE_STATE_CHANGED:{
1533       GstState old, new, pending;
1534 
1535       gst_message_parse_state_changed (msg, &amp;old, &amp;new, &amp;pending);
1536       if (GST_MESSAGE_SRC (msg) == (GstObject *) dc-&gt;priv-&gt;pipeline) {
1537         DISCO_LOCK (dc);
1538         dc-&gt;priv-&gt;current_state = new;
1539 
1540         if (dc-&gt;priv-&gt;pending_subtitle_pads == 0)
1541           done = dc-&gt;priv-&gt;no_more_pads
1542               &amp;&amp; dc-&gt;priv-&gt;target_state == dc-&gt;priv-&gt;current_state;
1543         /* Else we should get unblocked in GST_MESSAGE_APPLICATION */
1544 
1545         DISCO_UNLOCK (dc);
1546       }
1547 
1548       if (done)
1549         dump_name = &quot;gst-discoverer-target-state&quot;;
1550     }
1551       break;
1552 
1553     case GST_MESSAGE_ELEMENT:
1554     {
1555       GQuark sttype;
1556       const GstStructure *structure;
1557 
1558       structure = gst_message_get_structure (msg);
1559       sttype = gst_structure_get_name_id (structure);
1560       GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg),
1561           &quot;structure %&quot; GST_PTR_FORMAT, structure);
1562       if (sttype == _MISSING_PLUGIN_QUARK) {
1563         GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg),
1564             &quot;Setting result to MISSING_PLUGINS&quot;);
1565         dc-&gt;priv-&gt;current_info-&gt;result = GST_DISCOVERER_MISSING_PLUGINS;
1566         /* FIXME 2.0 Remove completely the -&gt;misc
1567          * Keep the old behaviour for now.
1568          */
1569         if (dc-&gt;priv-&gt;current_info-&gt;misc)
1570           gst_structure_free (dc-&gt;priv-&gt;current_info-&gt;misc);
1571         dc-&gt;priv-&gt;current_info-&gt;misc = gst_structure_copy (structure);
1572         g_ptr_array_add (dc-&gt;priv-&gt;current_info-&gt;missing_elements_details,
1573             gst_missing_plugin_message_get_installer_detail (msg));
1574       } else if (sttype == _STREAM_TOPOLOGY_QUARK) {
1575         if (dc-&gt;priv-&gt;current_topology)
1576           gst_structure_free (dc-&gt;priv-&gt;current_topology);
1577         dc-&gt;priv-&gt;current_topology = gst_structure_copy (structure);
1578       }
1579     }
1580       break;
1581 
1582     case GST_MESSAGE_TAG:
1583     {
1584       GstTagList *tl, *tmp;
1585 
1586       gst_message_parse_tag (msg, &amp;tl);
1587       GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg), &quot;Got tags %&quot; GST_PTR_FORMAT, tl);
1588       /* Merge with current tags */
1589       tmp =
1590           gst_tag_list_merge (dc-&gt;priv-&gt;current_info-&gt;tags, tl,
1591           GST_TAG_MERGE_APPEND);
1592       gst_tag_list_unref (tl);
1593       if (dc-&gt;priv-&gt;current_info-&gt;tags)
1594         gst_tag_list_unref (dc-&gt;priv-&gt;current_info-&gt;tags);
1595       dc-&gt;priv-&gt;current_info-&gt;tags = tmp;
1596       GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg), &quot;Current info %p, tags %&quot;
1597           GST_PTR_FORMAT, dc-&gt;priv-&gt;current_info, tmp);
1598     }
1599       break;
1600 
1601     case GST_MESSAGE_TOC:
1602     {
1603       GstToc *tmp;
1604 
1605       gst_message_parse_toc (msg, &amp;tmp, NULL);
1606       GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg), &quot;Got toc %&quot; GST_PTR_FORMAT, tmp);
1607       if (dc-&gt;priv-&gt;current_info-&gt;toc)
1608         gst_toc_unref (dc-&gt;priv-&gt;current_info-&gt;toc);
1609       dc-&gt;priv-&gt;current_info-&gt;toc = tmp;        /* transfer ownership */
1610       GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg), &quot;Current info %p, toc %&quot;
1611           GST_PTR_FORMAT, dc-&gt;priv-&gt;current_info, tmp);
1612     }
1613       break;
1614 
1615     default:
1616       break;
1617   }
1618 
1619   if (dump_name != NULL) {
1620     /* dump graph when done or for warnings */
1621     GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS (GST_BIN (dc-&gt;priv-&gt;pipeline),
1622         GST_DEBUG_GRAPH_SHOW_ALL, dump_name);
1623   }
1624   return done;
1625 }
1626 
1627 static void
1628 handle_current_sync (GstDiscoverer * dc)
1629 {
1630   GTimer *timer;
1631   gdouble deadline = ((gdouble) dc-&gt;priv-&gt;timeout) / GST_SECOND;
1632   GstMessage *msg;
1633   gboolean done = FALSE;
1634 
1635   timer = g_timer_new ();
1636   g_timer_start (timer);
1637 
1638   do {
1639     /* poll bus with timeout */
1640     /* FIXME : make the timeout more fine-tuned */
1641     if ((msg = gst_bus_timed_pop (dc-&gt;priv-&gt;bus, GST_SECOND / 2))) {
1642       done = handle_message (dc, msg);
1643       gst_message_unref (msg);
1644     }
1645   } while (!done &amp;&amp; (g_timer_elapsed (timer, NULL) &lt; deadline));
1646 
1647   /* return result */
1648   if (!done) {
1649     GST_DEBUG (&quot;we timed out! Setting result to TIMEOUT&quot;);
1650     dc-&gt;priv-&gt;current_info-&gt;result = GST_DISCOVERER_TIMEOUT;
1651   }
1652 
1653   DISCO_LOCK (dc);
1654   dc-&gt;priv-&gt;processing = FALSE;
1655   DISCO_UNLOCK (dc);
1656 
1657 
1658   GST_DEBUG (&quot;Done&quot;);
1659 
1660   g_timer_stop (timer);
1661   g_timer_destroy (timer);
1662 }
1663 
<a name="23" id="anc23"></a><span class="line-modified">1664 static void</span>











































































1665 _setup_locked (GstDiscoverer * dc)
1666 {
1667   GstStateChangeReturn ret;
<a name="24" id="anc24"></a>






















1668 
1669   GST_DEBUG (&quot;Setting up&quot;);
1670 
1671   /* Pop URI off the pending URI list */
1672   dc-&gt;priv-&gt;current_info =
1673       (GstDiscovererInfo *) g_object_new (GST_TYPE_DISCOVERER_INFO, NULL);
<a name="25" id="anc25"></a><span class="line-modified">1674   dc-&gt;priv-&gt;current_info-&gt;uri = (gchar *) dc-&gt;priv-&gt;pending_uris-&gt;data;</span>
<span class="line-modified">1675   dc-&gt;priv-&gt;pending_uris =</span>
<span class="line-removed">1676       g_list_delete_link (dc-&gt;priv-&gt;pending_uris, dc-&gt;priv-&gt;pending_uris);</span>
1677 
1678   /* set uri on uridecodebin */
1679   g_object_set (dc-&gt;priv-&gt;uridecodebin, &quot;uri&quot;, dc-&gt;priv-&gt;current_info-&gt;uri,
1680       NULL);
1681 
1682   GST_DEBUG (&quot;Current is now %s&quot;, dc-&gt;priv-&gt;current_info-&gt;uri);
1683 
1684   dc-&gt;priv-&gt;processing = TRUE;
1685 
1686   dc-&gt;priv-&gt;target_state = GST_STATE_PAUSED;
1687 
1688   /* set pipeline to PAUSED */
1689   DISCO_UNLOCK (dc);
1690   GST_DEBUG (&quot;Setting pipeline to PAUSED&quot;);
1691   ret =
1692       gst_element_set_state ((GstElement *) dc-&gt;priv-&gt;pipeline,
1693       dc-&gt;priv-&gt;target_state);
1694 
1695   if (ret == GST_STATE_CHANGE_NO_PREROLL) {
1696     GST_DEBUG (&quot;Source is live, switching to PLAYING&quot;);
1697     dc-&gt;priv-&gt;target_state = GST_STATE_PLAYING;
1698     ret =
1699         gst_element_set_state ((GstElement *) dc-&gt;priv-&gt;pipeline,
1700         dc-&gt;priv-&gt;target_state);
1701   }
1702   DISCO_LOCK (dc);
1703 
1704 
1705   GST_DEBUG_OBJECT (dc, &quot;Pipeline going to PAUSED : %s&quot;,
1706       gst_element_state_change_return_get_name (ret));
<a name="26" id="anc26"></a>

1707 }
1708 
1709 static void
1710 discoverer_cleanup (GstDiscoverer * dc)
1711 {
1712   GST_DEBUG (&quot;Cleaning up&quot;);
1713 
1714   DISCO_LOCK (dc);
1715   dc-&gt;priv-&gt;cleanup = TRUE;
1716   DISCO_UNLOCK (dc);
1717 
1718   gst_bus_set_flushing (dc-&gt;priv-&gt;bus, TRUE);
1719 
1720   DISCO_LOCK (dc);
1721   if (dc-&gt;priv-&gt;current_error) {
1722     g_error_free (dc-&gt;priv-&gt;current_error);
1723     DISCO_UNLOCK (dc);
1724     gst_element_set_state ((GstElement *) dc-&gt;priv-&gt;pipeline, GST_STATE_NULL);
1725   } else {
1726     DISCO_UNLOCK (dc);
1727   }
1728 
1729   gst_element_set_state ((GstElement *) dc-&gt;priv-&gt;pipeline, GST_STATE_READY);
1730   gst_bus_set_flushing (dc-&gt;priv-&gt;bus, FALSE);
1731 
1732   DISCO_LOCK (dc);
1733   dc-&gt;priv-&gt;current_error = NULL;
1734   if (dc-&gt;priv-&gt;current_topology) {
1735     gst_structure_free (dc-&gt;priv-&gt;current_topology);
1736     dc-&gt;priv-&gt;current_topology = NULL;
1737   }
1738 
1739   dc-&gt;priv-&gt;current_info = NULL;
1740 
1741   dc-&gt;priv-&gt;pending_subtitle_pads = 0;
1742 
1743   dc-&gt;priv-&gt;current_state = GST_STATE_NULL;
1744   dc-&gt;priv-&gt;target_state = GST_STATE_NULL;
1745   dc-&gt;priv-&gt;no_more_pads = FALSE;
1746   dc-&gt;priv-&gt;cleanup = FALSE;
1747 
1748 
1749   /* Try popping the next uri */
1750   if (dc-&gt;priv-&gt;async) {
<a name="27" id="anc27"></a><span class="line-modified">1751     if (dc-&gt;priv-&gt;pending_uris != NULL) {</span>
<span class="line-removed">1752       _setup_locked (dc);</span>
<span class="line-removed">1753       DISCO_UNLOCK (dc);</span>
<span class="line-removed">1754       /* Start timeout */</span>
<span class="line-removed">1755       handle_current_async (dc);</span>
<span class="line-removed">1756     } else {</span>
<span class="line-removed">1757       /* We&#39;re done ! */</span>
<span class="line-removed">1758       DISCO_UNLOCK (dc);</span>
<span class="line-removed">1759       g_signal_emit (dc, gst_discoverer_signals[SIGNAL_FINISHED], 0);</span>
<span class="line-removed">1760     }</span>
1761   } else
1762     DISCO_UNLOCK (dc);
1763 
1764   GST_DEBUG (&quot;out&quot;);
1765 }
1766 
1767 static void
1768 discoverer_bus_cb (GstBus * bus, GstMessage * msg, GstDiscoverer * dc)
1769 {
1770   if (dc-&gt;priv-&gt;processing) {
1771     if (handle_message (dc, msg)) {
1772       GST_DEBUG (&quot;Stopping asynchronously&quot;);
1773       /* Serialise with _event_probe() */
1774       DISCO_LOCK (dc);
1775       dc-&gt;priv-&gt;processing = FALSE;
1776       DISCO_UNLOCK (dc);
1777       discoverer_collect (dc);
1778       discoverer_cleanup (dc);
1779     }
1780   }
1781 }
1782 
1783 static gboolean
1784 async_timeout_cb (GstDiscoverer * dc)
1785 {
1786   if (!g_source_is_destroyed (g_main_current_source ())) {
<a name="28" id="anc28"></a><span class="line-removed">1787     dc-&gt;priv-&gt;timeoutid = 0;</span>
1788     GST_DEBUG (&quot;Setting result to TIMEOUT&quot;);
1789     dc-&gt;priv-&gt;current_info-&gt;result = GST_DISCOVERER_TIMEOUT;
1790     dc-&gt;priv-&gt;processing = FALSE;
1791     discoverer_collect (dc);
1792     discoverer_cleanup (dc);
1793   }
1794   return FALSE;
1795 }
1796 
1797 /* If there is a pending URI, it will pop it from the list of pending
1798  * URIs and start the discovery on it.
1799  *
1800  * Returns GST_DISCOVERER_OK if the next URI was popped and is processing,
1801  * else a error flag.
1802  */
1803 static GstDiscovererResult
1804 start_discovering (GstDiscoverer * dc)
1805 {
<a name="29" id="anc29"></a>
1806   GstDiscovererResult res = GST_DISCOVERER_OK;
1807 
1808   GST_DEBUG (&quot;Starting&quot;);
1809 
1810   DISCO_LOCK (dc);
1811   if (dc-&gt;priv-&gt;pending_uris == NULL) {
1812     GST_WARNING (&quot;No URI to process&quot;);
1813     res = GST_DISCOVERER_URI_INVALID;
1814     DISCO_UNLOCK (dc);
1815     goto beach;
1816   }
1817 
1818   if (dc-&gt;priv-&gt;current_info != NULL) {
1819     GST_WARNING (&quot;Already processing a file&quot;);
1820     res = GST_DISCOVERER_BUSY;
1821     DISCO_UNLOCK (dc);
1822     goto beach;
1823   }
1824 
1825   g_signal_emit (dc, gst_discoverer_signals[SIGNAL_STARTING], 0);
1826 
<a name="30" id="anc30"></a><span class="line-modified">1827   _setup_locked (dc);</span>
1828 
1829   DISCO_UNLOCK (dc);
1830 
<a name="31" id="anc31"></a><span class="line-modified">1831   if (dc-&gt;priv-&gt;async)</span>








1832     handle_current_async (dc);
<a name="32" id="anc32"></a><span class="line-modified">1833   else</span>
<span class="line-modified">1834     handle_current_sync (dc);</span>


1835 
1836 beach:
1837   return res;
1838 }
1839 
1840 /* Serializing code */
1841 
1842 static GVariant *
1843 _serialize_common_stream_info (GstDiscovererStreamInfo * sinfo,
1844     GstDiscovererSerializeFlags flags)
1845 {
1846   GVariant *common;
<a name="33" id="anc33"></a>
1847   gchar *caps_str = NULL, *tags_str = NULL, *misc_str = NULL;
1848 
1849   if (sinfo-&gt;caps &amp;&amp; (flags &amp; GST_DISCOVERER_SERIALIZE_CAPS))
1850     caps_str = gst_caps_to_string (sinfo-&gt;caps);
1851 
1852   if (sinfo-&gt;tags &amp;&amp; (flags &amp; GST_DISCOVERER_SERIALIZE_TAGS))
1853     tags_str = gst_tag_list_to_string (sinfo-&gt;tags);
1854 
1855   if (sinfo-&gt;misc &amp;&amp; (flags &amp; GST_DISCOVERER_SERIALIZE_MISC))
1856     misc_str = gst_structure_to_string (sinfo-&gt;misc);
1857 
<a name="34" id="anc34"></a>





1858   common =
<a name="35" id="anc35"></a><span class="line-modified">1859       g_variant_new (&quot;(msmsmsms)&quot;, sinfo-&gt;stream_id, caps_str, tags_str,</span>
<span class="line-modified">1860       misc_str);</span>
1861 
1862   g_free (caps_str);
1863   g_free (tags_str);
1864   g_free (misc_str);
1865 
1866   return common;
1867 }
1868 
1869 static GVariant *
1870 _serialize_info (GstDiscovererInfo * info, GstDiscovererSerializeFlags flags)
1871 {
1872   gchar *tags_str = NULL;
1873   GVariant *ret;
1874 
1875   if (info-&gt;tags &amp;&amp; (flags &amp; GST_DISCOVERER_SERIALIZE_TAGS))
1876     tags_str = gst_tag_list_to_string (info-&gt;tags);
1877 
1878   ret =
1879       g_variant_new (&quot;(mstbmsb)&quot;, info-&gt;uri, info-&gt;duration, info-&gt;seekable,
1880       tags_str, info-&gt;live);
1881 
1882   g_free (tags_str);
1883 
1884   return ret;
1885 }
1886 
1887 static GVariant *
1888 _serialize_audio_stream_info (GstDiscovererAudioInfo * ainfo)
1889 {
1890   return g_variant_new (&quot;(uuuuumst)&quot;,
1891       ainfo-&gt;channels,
1892       ainfo-&gt;sample_rate,
1893       ainfo-&gt;bitrate, ainfo-&gt;max_bitrate, ainfo-&gt;depth, ainfo-&gt;language,
1894       ainfo-&gt;channel_mask);
1895 }
1896 
1897 static GVariant *
1898 _serialize_video_stream_info (GstDiscovererVideoInfo * vinfo)
1899 {
1900   return g_variant_new (&quot;(uuuuuuubuub)&quot;,
1901       vinfo-&gt;width,
1902       vinfo-&gt;height,
1903       vinfo-&gt;depth,
1904       vinfo-&gt;framerate_num,
1905       vinfo-&gt;framerate_denom,
1906       vinfo-&gt;par_num,
1907       vinfo-&gt;par_denom,
1908       vinfo-&gt;interlaced, vinfo-&gt;bitrate, vinfo-&gt;max_bitrate, vinfo-&gt;is_image);
1909 }
1910 
1911 static GVariant *
1912 _serialize_subtitle_stream_info (GstDiscovererSubtitleInfo * sinfo)
1913 {
1914   return g_variant_new (&quot;ms&quot;, sinfo-&gt;language);
1915 }
1916 
1917 static GVariant *
1918 gst_discoverer_info_to_variant_recurse (GstDiscovererStreamInfo * sinfo,
1919     GstDiscovererSerializeFlags flags)
1920 {
1921   GVariant *stream_variant = NULL;
1922   GVariant *common_stream_variant =
1923       _serialize_common_stream_info (sinfo, flags);
1924 
1925   if (GST_IS_DISCOVERER_CONTAINER_INFO (sinfo)) {
1926     GList *tmp;
1927     GList *streams =
1928         gst_discoverer_container_info_get_streams (GST_DISCOVERER_CONTAINER_INFO
1929         (sinfo));
1930 
1931     if (g_list_length (streams) &gt; 0) {
1932       GVariantBuilder children;
1933       GVariant *child_variant;
1934       g_variant_builder_init (&amp;children, G_VARIANT_TYPE_ARRAY);
1935 
1936       for (tmp = streams; tmp; tmp = tmp-&gt;next) {
1937         child_variant =
1938             gst_discoverer_info_to_variant_recurse (tmp-&gt;data, flags);
1939         g_variant_builder_add (&amp;children, &quot;v&quot;, child_variant);
1940       }
1941       stream_variant =
1942           g_variant_new (&quot;(yvav)&quot;, &#39;c&#39;, common_stream_variant, &amp;children);
1943     } else {
1944       stream_variant =
1945           g_variant_new (&quot;(yvav)&quot;, &#39;c&#39;, common_stream_variant, NULL);
1946     }
1947 
1948     gst_discoverer_stream_info_list_free (streams);
1949   } else if (GST_IS_DISCOVERER_AUDIO_INFO (sinfo)) {
1950     GVariant *audio_stream_info =
1951         _serialize_audio_stream_info (GST_DISCOVERER_AUDIO_INFO (sinfo));
1952     stream_variant =
1953         g_variant_new (&quot;(yvv)&quot;, &#39;a&#39;, common_stream_variant, audio_stream_info);
1954   } else if (GST_IS_DISCOVERER_VIDEO_INFO (sinfo)) {
1955     GVariant *video_stream_info =
1956         _serialize_video_stream_info (GST_DISCOVERER_VIDEO_INFO (sinfo));
1957     stream_variant =
1958         g_variant_new (&quot;(yvv)&quot;, &#39;v&#39;, common_stream_variant, video_stream_info);
1959   } else if (GST_IS_DISCOVERER_SUBTITLE_INFO (sinfo)) {
1960     GVariant *subtitle_stream_info =
1961         _serialize_subtitle_stream_info (GST_DISCOVERER_SUBTITLE_INFO (sinfo));
1962     stream_variant =
1963         g_variant_new (&quot;(yvv)&quot;, &#39;s&#39;, common_stream_variant,
1964         subtitle_stream_info);
<a name="36" id="anc36"></a>









1965   }
1966 
1967   return stream_variant;
1968 }
1969 
1970 /* Parsing code */
1971 
1972 #define GET_FROM_TUPLE(v, t, n, val) G_STMT_START{         \
1973   GVariant *child = g_variant_get_child_value (v, n); \
1974   *val = g_variant_get_##t(child); \
1975   g_variant_unref (child); \
1976 }G_STMT_END
1977 
1978 static const gchar *
1979 _maybe_get_string_from_tuple (GVariant * tuple, guint index)
1980 {
1981   const gchar *ret = NULL;
1982   GVariant *maybe;
1983   GET_FROM_TUPLE (tuple, maybe, index, &amp;maybe);
1984   if (maybe) {
1985     ret = g_variant_get_string (maybe, NULL);
1986     g_variant_unref (maybe);
1987   }
1988 
1989   return ret;
1990 }
1991 
1992 static void
1993 _parse_info (GstDiscovererInfo * info, GVariant * info_variant)
1994 {
1995   const gchar *str;
1996 
1997   str = _maybe_get_string_from_tuple (info_variant, 0);
1998   if (str)
1999     info-&gt;uri = g_strdup (str);
2000 
2001   GET_FROM_TUPLE (info_variant, uint64, 1, &amp;info-&gt;duration);
2002   GET_FROM_TUPLE (info_variant, boolean, 2, &amp;info-&gt;seekable);
2003 
2004   str = _maybe_get_string_from_tuple (info_variant, 3);
2005   if (str)
2006     info-&gt;tags = gst_tag_list_new_from_string (str);
2007 
2008   GET_FROM_TUPLE (info_variant, boolean, 4, &amp;info-&gt;live);
2009 }
2010 
2011 static void
<a name="37" id="anc37"></a><span class="line-modified">2012 _parse_common_stream_info (GstDiscovererStreamInfo * sinfo, GVariant * common)</span>

2013 {
2014   const gchar *str;
2015 
2016   str = _maybe_get_string_from_tuple (common, 0);
2017   if (str)
2018     sinfo-&gt;stream_id = g_strdup (str);
2019 
2020   str = _maybe_get_string_from_tuple (common, 1);
2021   if (str)
2022     sinfo-&gt;caps = gst_caps_from_string (str);
2023 
2024   str = _maybe_get_string_from_tuple (common, 2);
2025   if (str)
2026     sinfo-&gt;tags = gst_tag_list_new_from_string (str);
2027 
2028   str = _maybe_get_string_from_tuple (common, 3);
2029   if (str)
2030     sinfo-&gt;misc = gst_structure_new_from_string (str);
2031 
<a name="38" id="anc38"></a>








2032   g_variant_unref (common);
2033 }
2034 
2035 static void
2036 _parse_audio_stream_info (GstDiscovererAudioInfo * ainfo, GVariant * specific)
2037 {
2038   const gchar *str;
2039 
2040   GET_FROM_TUPLE (specific, uint32, 0, &amp;ainfo-&gt;channels);
2041   GET_FROM_TUPLE (specific, uint32, 1, &amp;ainfo-&gt;sample_rate);
2042   GET_FROM_TUPLE (specific, uint32, 2, &amp;ainfo-&gt;bitrate);
2043   GET_FROM_TUPLE (specific, uint32, 3, &amp;ainfo-&gt;max_bitrate);
2044   GET_FROM_TUPLE (specific, uint32, 4, &amp;ainfo-&gt;depth);
2045 
2046   str = _maybe_get_string_from_tuple (specific, 5);
2047 
2048   if (str)
2049     ainfo-&gt;language = g_strdup (str);
2050 
2051   GET_FROM_TUPLE (specific, uint64, 6, &amp;ainfo-&gt;channel_mask);
2052 
2053   g_variant_unref (specific);
2054 }
2055 
2056 static void
2057 _parse_video_stream_info (GstDiscovererVideoInfo * vinfo, GVariant * specific)
2058 {
2059   GET_FROM_TUPLE (specific, uint32, 0, &amp;vinfo-&gt;width);
2060   GET_FROM_TUPLE (specific, uint32, 1, &amp;vinfo-&gt;height);
2061   GET_FROM_TUPLE (specific, uint32, 2, &amp;vinfo-&gt;depth);
2062   GET_FROM_TUPLE (specific, uint32, 3, &amp;vinfo-&gt;framerate_num);
2063   GET_FROM_TUPLE (specific, uint32, 4, &amp;vinfo-&gt;framerate_denom);
2064   GET_FROM_TUPLE (specific, uint32, 5, &amp;vinfo-&gt;par_num);
2065   GET_FROM_TUPLE (specific, uint32, 6, &amp;vinfo-&gt;par_denom);
2066   GET_FROM_TUPLE (specific, boolean, 7, &amp;vinfo-&gt;interlaced);
2067   GET_FROM_TUPLE (specific, uint32, 8, &amp;vinfo-&gt;bitrate);
2068   GET_FROM_TUPLE (specific, uint32, 9, &amp;vinfo-&gt;max_bitrate);
2069   GET_FROM_TUPLE (specific, boolean, 10, &amp;vinfo-&gt;is_image);
2070 
2071   g_variant_unref (specific);
2072 }
2073 
2074 static void
2075 _parse_subtitle_stream_info (GstDiscovererSubtitleInfo * sinfo,
2076     GVariant * specific)
2077 {
2078   GVariant *maybe;
2079 
2080   maybe = g_variant_get_maybe (specific);
2081   if (maybe) {
2082     sinfo-&gt;language = g_strdup (g_variant_get_string (maybe, NULL));
2083     g_variant_unref (maybe);
2084   }
2085 
2086   g_variant_unref (specific);
2087 }
2088 
2089 static GstDiscovererStreamInfo *
2090 _parse_discovery (GVariant * variant, GstDiscovererInfo * info)
2091 {
2092   gchar type;
2093   GVariant *common = g_variant_get_child_value (variant, 1);
2094   GVariant *specific = g_variant_get_child_value (variant, 2);
2095   GstDiscovererStreamInfo *sinfo = NULL;
2096 
2097   GET_FROM_TUPLE (variant, byte, 0, &amp;type);
2098   switch (type) {
2099     case &#39;c&#39;:
2100       sinfo = g_object_new (GST_TYPE_DISCOVERER_CONTAINER_INFO, NULL);
2101       break;
2102     case &#39;a&#39;:
2103       sinfo = g_object_new (GST_TYPE_DISCOVERER_AUDIO_INFO, NULL);
2104       _parse_audio_stream_info (GST_DISCOVERER_AUDIO_INFO (sinfo),
2105           g_variant_get_child_value (specific, 0));
2106       break;
2107     case &#39;v&#39;:
2108       sinfo = g_object_new (GST_TYPE_DISCOVERER_VIDEO_INFO, NULL);
2109       _parse_video_stream_info (GST_DISCOVERER_VIDEO_INFO (sinfo),
2110           g_variant_get_child_value (specific, 0));
2111       break;
2112     case &#39;s&#39;:
2113       sinfo = g_object_new (GST_TYPE_DISCOVERER_SUBTITLE_INFO, NULL);
2114       _parse_subtitle_stream_info (GST_DISCOVERER_SUBTITLE_INFO (sinfo),
2115           g_variant_get_child_value (specific, 0));
2116       break;
<a name="39" id="anc39"></a>


2117     default:
2118       GST_WARNING (&quot;Unexpected discoverer info type %d&quot;, type);
2119       goto out;
2120   }
2121 
<a name="40" id="anc40"></a><span class="line-modified">2122   _parse_common_stream_info (sinfo, g_variant_get_child_value (common, 0));</span>

2123 
<a name="41" id="anc41"></a><span class="line-modified">2124   info-&gt;stream_list = g_list_append (info-&gt;stream_list, sinfo);</span>

2125 
2126   if (!info-&gt;stream_info) {
2127     info-&gt;stream_info = sinfo;
2128   }
2129 
2130   if (GST_IS_DISCOVERER_CONTAINER_INFO (sinfo)) {
2131     GVariantIter iter;
2132     GVariant *child;
2133 
2134     GstDiscovererContainerInfo *cinfo = GST_DISCOVERER_CONTAINER_INFO (sinfo);
2135     g_variant_iter_init (&amp;iter, specific);
2136     while ((child = g_variant_iter_next_value (&amp;iter))) {
2137       GstDiscovererStreamInfo *child_info;
2138       child_info = _parse_discovery (g_variant_get_variant (child), info);
2139       if (child_info != NULL) {
2140         cinfo-&gt;streams =
2141             g_list_append (cinfo-&gt;streams,
2142             gst_discoverer_stream_info_ref (child_info));
2143       }
2144       g_variant_unref (child);
2145     }
2146   }
2147 
2148 out:
2149 
2150   g_variant_unref (common);
2151   g_variant_unref (specific);
2152   g_variant_unref (variant);
2153   return sinfo;
2154 }
2155 
2156 /**
2157  * gst_discoverer_start:
2158  * @discoverer: A #GstDiscoverer
2159  *
2160  * Allow asynchronous discovering of URIs to take place.
2161  * A #GMainLoop must be available for #GstDiscoverer to properly work in
2162  * asynchronous mode.
2163  */
2164 void
2165 gst_discoverer_start (GstDiscoverer * discoverer)
2166 {
2167   GSource *source;
2168   GMainContext *ctx = NULL;
2169 
2170   g_return_if_fail (GST_IS_DISCOVERER (discoverer));
2171 
2172   GST_DEBUG_OBJECT (discoverer, &quot;Starting...&quot;);
2173 
2174   if (discoverer-&gt;priv-&gt;async) {
2175     GST_DEBUG_OBJECT (discoverer, &quot;We were already started&quot;);
2176     return;
2177   }
2178 
2179   discoverer-&gt;priv-&gt;async = TRUE;
2180   discoverer-&gt;priv-&gt;running = TRUE;
2181 
2182   ctx = g_main_context_get_thread_default ();
2183 
2184   /* Connect to bus signals */
2185   if (ctx == NULL)
2186     ctx = g_main_context_default ();
2187 
2188   source = gst_bus_create_watch (discoverer-&gt;priv-&gt;bus);
2189   g_source_set_callback (source, (GSourceFunc) gst_bus_async_signal_func,
2190       NULL, NULL);
<a name="42" id="anc42"></a><span class="line-modified">2191   discoverer-&gt;priv-&gt;sourceid = g_source_attach (source, ctx);</span>
<span class="line-modified">2192   g_source_unref (source);</span>
2193   discoverer-&gt;priv-&gt;ctx = g_main_context_ref (ctx);
2194 
2195   start_discovering (discoverer);
2196   GST_DEBUG_OBJECT (discoverer, &quot;Started&quot;);
2197 }
2198 
2199 /**
2200  * gst_discoverer_stop:
2201  * @discoverer: A #GstDiscoverer
2202  *
2203  * Stop the discovery of any pending URIs and clears the list of
2204  * pending URIS (if any).
2205  */
2206 void
2207 gst_discoverer_stop (GstDiscoverer * discoverer)
2208 {
2209   g_return_if_fail (GST_IS_DISCOVERER (discoverer));
2210 
2211   GST_DEBUG_OBJECT (discoverer, &quot;Stopping...&quot;);
2212 
2213   if (!discoverer-&gt;priv-&gt;async) {
2214     GST_DEBUG_OBJECT (discoverer,
2215         &quot;We were already stopped, or running synchronously&quot;);
2216     return;
2217   }
2218 
2219   DISCO_LOCK (discoverer);
2220   if (discoverer-&gt;priv-&gt;processing) {
2221     /* We prevent any further processing by setting the bus to
2222      * flushing and setting the pipeline to READY.
2223      * _reset() will take care of the rest of the cleanup */
2224     if (discoverer-&gt;priv-&gt;bus)
2225       gst_bus_set_flushing (discoverer-&gt;priv-&gt;bus, TRUE);
2226     if (discoverer-&gt;priv-&gt;pipeline)
2227       gst_element_set_state ((GstElement *) discoverer-&gt;priv-&gt;pipeline,
2228           GST_STATE_READY);
2229   }
2230   discoverer-&gt;priv-&gt;running = FALSE;
2231   DISCO_UNLOCK (discoverer);
2232 
2233   /* Remove timeout handler */
<a name="43" id="anc43"></a><span class="line-modified">2234   if (discoverer-&gt;priv-&gt;timeoutid) {</span>
<span class="line-modified">2235     g_source_remove (discoverer-&gt;priv-&gt;timeoutid);</span>
<span class="line-modified">2236     discoverer-&gt;priv-&gt;timeoutid = 0;</span>

2237   }
2238   /* Remove signal watch */
<a name="44" id="anc44"></a><span class="line-modified">2239   if (discoverer-&gt;priv-&gt;sourceid) {</span>
<span class="line-modified">2240     g_source_remove (discoverer-&gt;priv-&gt;sourceid);</span>
<span class="line-modified">2241     discoverer-&gt;priv-&gt;sourceid = 0;</span>

2242   }
2243   /* Unref main context */
2244   if (discoverer-&gt;priv-&gt;ctx) {
2245     g_main_context_unref (discoverer-&gt;priv-&gt;ctx);
2246     discoverer-&gt;priv-&gt;ctx = NULL;
2247   }
2248   discoverer_reset (discoverer);
2249 
2250   discoverer-&gt;priv-&gt;async = FALSE;
2251 
2252   GST_DEBUG_OBJECT (discoverer, &quot;Stopped&quot;);
2253 }
2254 
2255 /**
2256  * gst_discoverer_discover_uri_async:
2257  * @discoverer: A #GstDiscoverer
2258  * @uri: the URI to add.
2259  *
2260  * Appends the given @uri to the list of URIs to discoverer. The actual
2261  * discovery of the @uri will only take place if gst_discoverer_start() has
2262  * been called.
2263  *
2264  * A copy of @uri will be made internally, so the caller can safely g_free()
2265  * afterwards.
2266  *
2267  * Returns: %TRUE if the @uri was successfully appended to the list of pending
2268  * uris, else %FALSE
2269  */
2270 gboolean
2271 gst_discoverer_discover_uri_async (GstDiscoverer * discoverer,
2272     const gchar * uri)
2273 {
2274   gboolean can_run;
2275 
2276   g_return_val_if_fail (GST_IS_DISCOVERER (discoverer), FALSE);
2277 
2278   GST_DEBUG_OBJECT (discoverer, &quot;uri : %s&quot;, uri);
2279 
2280   DISCO_LOCK (discoverer);
2281   can_run = (discoverer-&gt;priv-&gt;pending_uris == NULL);
2282   discoverer-&gt;priv-&gt;pending_uris =
2283       g_list_append (discoverer-&gt;priv-&gt;pending_uris, g_strdup (uri));
2284   DISCO_UNLOCK (discoverer);
2285 
2286   if (can_run)
2287     start_discovering (discoverer);
2288 
2289   return TRUE;
2290 }
2291 
2292 
2293 /* Synchronous mode */
2294 /**
2295  * gst_discoverer_discover_uri:
2296  * @discoverer: A #GstDiscoverer
2297  * @uri: The URI to run on.
2298  * @err: (out) (allow-none): If an error occurred, this field will be filled in.
2299  *
2300  * Synchronously discovers the given @uri.
2301  *
2302  * A copy of @uri will be made internally, so the caller can safely g_free()
2303  * afterwards.
2304  *
2305  * Returns: (transfer full): the result of the scanning. Can be %NULL if an
2306  * error occurred.
2307  */
2308 GstDiscovererInfo *
2309 gst_discoverer_discover_uri (GstDiscoverer * discoverer, const gchar * uri,
2310     GError ** err)
2311 {
2312   GstDiscovererResult res = 0;
2313   GstDiscovererInfo *info;
2314 
2315   g_return_val_if_fail (GST_IS_DISCOVERER (discoverer), NULL);
2316   g_return_val_if_fail (uri, NULL);
2317 
2318   GST_DEBUG_OBJECT (discoverer, &quot;uri:%s&quot;, uri);
2319 
2320   DISCO_LOCK (discoverer);
2321   if (G_UNLIKELY (discoverer-&gt;priv-&gt;current_info)) {
2322     DISCO_UNLOCK (discoverer);
2323     GST_WARNING_OBJECT (discoverer, &quot;Already handling a uri&quot;);
2324     if (err)
2325       *err = g_error_new (GST_CORE_ERROR, GST_CORE_ERROR_FAILED,
2326           &quot;Already handling a uri&quot;);
2327     return NULL;
2328   }
2329 
2330   discoverer-&gt;priv-&gt;pending_uris =
2331       g_list_append (discoverer-&gt;priv-&gt;pending_uris, g_strdup (uri));
2332   DISCO_UNLOCK (discoverer);
2333 
2334   res = start_discovering (discoverer);
2335   discoverer_collect (discoverer);
2336 
2337   /* Get results */
2338   if (err) {
2339     if (discoverer-&gt;priv-&gt;current_error)
2340       *err = g_error_copy (discoverer-&gt;priv-&gt;current_error);
2341     else
2342       *err = NULL;
2343   }
2344   if (res != GST_DISCOVERER_OK) {
2345     GST_DEBUG (&quot;Setting result to %d (was %d)&quot;, res,
2346         discoverer-&gt;priv-&gt;current_info-&gt;result);
2347     discoverer-&gt;priv-&gt;current_info-&gt;result = res;
2348   }
2349   info = discoverer-&gt;priv-&gt;current_info;
2350 
2351   discoverer_cleanup (discoverer);
2352 
2353   return info;
2354 }
2355 
2356 /**
2357  * gst_discoverer_new:
2358  * @timeout: timeout per file, in nanoseconds. Allowed are values between
2359  *     one second (#GST_SECOND) and one hour (3600 * #GST_SECOND)
2360  * @err: a pointer to a #GError. can be %NULL
2361  *
2362  * Creates a new #GstDiscoverer with the provided timeout.
2363  *
2364  * Returns: (transfer full): The new #GstDiscoverer.
2365  * If an error occurred when creating the discoverer, @err will be set
2366  * accordingly and %NULL will be returned. If @err is set, the caller must
2367  * free it when no longer needed using g_error_free().
2368  */
2369 GstDiscoverer *
2370 gst_discoverer_new (GstClockTime timeout, GError ** err)
2371 {
2372   GstDiscoverer *res;
2373 
2374   res = g_object_new (GST_TYPE_DISCOVERER, &quot;timeout&quot;, timeout, NULL);
2375   if (res-&gt;priv-&gt;uridecodebin == NULL) {
2376     if (err)
2377       *err = g_error_new (GST_CORE_ERROR, GST_CORE_ERROR_MISSING_PLUGIN,
2378           &quot;Couldn&#39;t create &#39;uridecodebin&#39; element&quot;);
2379     gst_object_unref (res);
2380     res = NULL;
2381   }
2382   return res;
2383 }
2384 
2385 /**
2386  * gst_discoverer_info_to_variant:
2387  * @info: A #GstDiscovererInfo
2388  * @flags: A combination of #GstDiscovererSerializeFlags to specify
2389  * what needs to be serialized.
2390  *
2391  * Serializes @info to a #GVariant that can be parsed again
2392  * through gst_discoverer_info_from_variant().
2393  *
2394  * Note that any #GstToc (s) that might have been discovered will not be serialized
2395  * for now.
2396  *
2397  * Returns: (transfer full): A newly-allocated #GVariant representing @info.
2398  *
2399  * Since: 1.6
2400  */
2401 GVariant *
2402 gst_discoverer_info_to_variant (GstDiscovererInfo * info,
2403     GstDiscovererSerializeFlags flags)
2404 {
2405   /* FIXME: implement TOC support */
2406   GVariant *stream_variant;
<a name="45" id="anc45"></a><span class="line-modified">2407   GVariant *variant;</span>
2408   GstDiscovererStreamInfo *sinfo;
2409   GVariant *wrapper;
2410 
2411   g_return_val_if_fail (GST_IS_DISCOVERER_INFO (info), NULL);
2412   g_return_val_if_fail (gst_discoverer_info_get_result (info) ==
2413       GST_DISCOVERER_OK, NULL);
2414 
2415   sinfo = gst_discoverer_info_get_stream_info (info);
2416   stream_variant = gst_discoverer_info_to_variant_recurse (sinfo, flags);
<a name="46" id="anc46"></a><span class="line-modified">2417   variant =</span>
<span class="line-modified">2418       g_variant_new (&quot;(vv)&quot;, _serialize_info (info, flags), stream_variant);</span>

2419 
2420   /* Returning a wrapper implies some small overhead, but simplifies
2421    * deserializing from bytes */
2422   wrapper = g_variant_new_variant (variant);
2423 
2424   gst_discoverer_stream_info_unref (sinfo);
2425   return wrapper;
2426 }
2427 
2428 /**
2429  * gst_discoverer_info_from_variant:
2430  * @variant: A #GVariant to deserialize into a #GstDiscovererInfo.
2431  *
2432  * Parses a #GVariant as produced by gst_discoverer_info_to_variant()
2433  * back to a #GstDiscovererInfo.
2434  *
2435  * Returns: (transfer full): A newly-allocated #GstDiscovererInfo.
2436  *
2437  * Since: 1.6
2438  */
2439 GstDiscovererInfo *
2440 gst_discoverer_info_from_variant (GVariant * variant)
2441 {
2442   GstDiscovererInfo *info = g_object_new (GST_TYPE_DISCOVERER_INFO, NULL);
2443   GVariant *info_variant = g_variant_get_variant (variant);
2444   GVariant *info_specific_variant;
2445   GVariant *wrapped;
2446 
2447   GET_FROM_TUPLE (info_variant, variant, 0, &amp;info_specific_variant);
2448   GET_FROM_TUPLE (info_variant, variant, 1, &amp;wrapped);
2449 
2450   _parse_info (info, info_specific_variant);
2451   _parse_discovery (wrapped, info);
2452   g_variant_unref (info_specific_variant);
2453   g_variant_unref (info_variant);
2454 
2455   return info;
2456 }
<a name="47" id="anc47"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="47" type="hidden" />
</body>
</html>