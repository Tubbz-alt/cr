<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmessages.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gmem.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gmessages.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmessages.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 44,11 ***</span>
   * They are not intended for normal control flow, only to give a
   * perhaps-helpful warning before giving up.
   *
   * Structured logging output is supported using g_log_structured(). This differs
   * from the traditional g_log() API in that log messages are handled as a
<span class="line-modified">!  * collection of key�value pairs representing individual pieces of information,</span>
   * rather than as a single string containing all the information in an arbitrary
   * format.
   *
   * The convenience macros g_info(), g_message(), g_debug(), g_warning() and g_error()
   * will use the traditional g_log() API unless you define the symbol
<span class="line-new-header">--- 44,11 ---</span>
   * They are not intended for normal control flow, only to give a
   * perhaps-helpful warning before giving up.
   *
   * Structured logging output is supported using g_log_structured(). This differs
   * from the traditional g_log() API in that log messages are handled as a
<span class="line-modified">!  * collection of key-value pairs representing individual pieces of information,</span>
   * rather than as a single string containing all the information in an arbitrary
   * format.
   *
   * The convenience macros g_info(), g_message(), g_debug(), g_warning() and g_error()
   * will use the traditional g_log() API unless you define the symbol
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,16 ***</span>
   * If %G_LOG_USE_STRUCTURED is defined, g_test_expect_message() will become
   * ineffective for the wrapper macros g_warning() and friends (see
   * [Testing for Messages][testing-for-messages]).
   *
   * The support for structured logging was motivated by the following needs (some
<span class="line-modified">!  * of which were supported previously; others weren�t):</span>
   *  * Support for multiple logging levels.
   *  * Structured log support with the ability to add `MESSAGE_ID`s (see
   *    g_log_structured()).
   *  * Moving the responsibility for filtering log messages from the program to
<span class="line-modified">!  *    the log viewer � instead of libraries and programs installing log handlers</span>
   *    (with g_log_set_handler()) which filter messages before output, all log
   *    messages are outputted, and the log viewer program (such as `journalctl`)
   *    must filter them. This is based on the idea that bugs are sometimes hard
   *    to reproduce, so it is better to log everything possible and then use
   *    tools to analyse the logs than it is to not be able to reproduce a bug to
<span class="line-new-header">--- 58,16 ---</span>
   * If %G_LOG_USE_STRUCTURED is defined, g_test_expect_message() will become
   * ineffective for the wrapper macros g_warning() and friends (see
   * [Testing for Messages][testing-for-messages]).
   *
   * The support for structured logging was motivated by the following needs (some
<span class="line-modified">!  * of which were supported previously; others weren&#39;t):</span>
   *  * Support for multiple logging levels.
   *  * Structured log support with the ability to add `MESSAGE_ID`s (see
   *    g_log_structured()).
   *  * Moving the responsibility for filtering log messages from the program to
<span class="line-modified">!  *    the log viewer - instead of libraries and programs installing log handlers</span>
   *    (with g_log_set_handler()) which filter messages before output, all log
   *    messages are outputted, and the log viewer program (such as `journalctl`)
   *    must filter them. This is based on the idea that bugs are sometimes hard
   *    to reproduce, so it is better to log everything possible and then use
   *    tools to analyse the logs than it is to not be able to reproduce a bug to
</pre>
<hr />
<pre>
<span class="line-old-header">*** 78,11 ***</span>
   *    all libraries and program code; rather than multiple log handlers with
   *    poorly defined interactions between them. This allows a program to easily
   *    change its logging policy by changing the writer function, for example to
   *    log to an additional location or to change what logging output fallbacks
   *    are used. The log writer functions provided by GLib are exposed publicly
<span class="line-modified">!  *    so they can be used from programs� log writers. This allows log writer</span>
   *    policy and implementation to be kept separate.
   *  * If a library wants to add standard information to all of its log messages
   *    (such as library state) or to redact private data (such as passwords or
   *    network credentials), it should use a wrapper function around its
   *    g_log_structured() calls or implement that in the single log writer
<span class="line-new-header">--- 78,11 ---</span>
   *    all libraries and program code; rather than multiple log handlers with
   *    poorly defined interactions between them. This allows a program to easily
   *    change its logging policy by changing the writer function, for example to
   *    log to an additional location or to change what logging output fallbacks
   *    are used. The log writer functions provided by GLib are exposed publicly
<span class="line-modified">!  *    so they can be used from programs&#39; log writers. This allows log writer</span>
   *    policy and implementation to be kept separate.
   *  * If a library wants to add standard information to all of its log messages
   *    (such as library state) or to redact private data (such as passwords or
   *    network credentials), it should use a wrapper function around its
   *    g_log_structured() calls or implement that in the single log writer
</pre>
<hr />
<pre>
<span class="line-old-header">*** 107,11 ***</span>
   * ## Log Domains ## {#log-domains}
   *
   * Log domains may be used to broadly split up the origins of log messages.
   * Typically, there are one or a few log domains per application or library.
   * %G_LOG_DOMAIN should be used to define the default log domain for the current
<span class="line-modified">!  * compilation unit � it is typically defined at the top of a source file, or in</span>
   * the preprocessor flags for a group of source files.
   *
   * Log domains must be unique, and it is recommended that they are the
   * application or library name, optionally followed by a hyphen and a sub-domain
   * name. For example, `bloatpad` or `bloatpad-io`.
<span class="line-new-header">--- 107,11 ---</span>
   * ## Log Domains ## {#log-domains}
   *
   * Log domains may be used to broadly split up the origins of log messages.
   * Typically, there are one or a few log domains per application or library.
   * %G_LOG_DOMAIN should be used to define the default log domain for the current
<span class="line-modified">!  * compilation unit - it is typically defined at the top of a source file, or in</span>
   * the preprocessor flags for a group of source files.
   *
   * Log domains must be unique, and it is recommended that they are the
   * application or library name, optionally followed by a hyphen and a sub-domain
   * name. For example, `bloatpad` or `bloatpad-io`.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,12 ***</span>
   * they should be limited to asserting that the library aborts and prints a
   * suitable error message before aborting. This should be done with
   * g_test_trap_assert_stderr().
   *
   * If it is really necessary to test the structured log messages emitted by a
<span class="line-modified">!  * particular piece of code � and the code cannot be restructured to be more</span>
<span class="line-modified">!  * suitable to more conventional unit testing � you should write a custom log</span>
   * writer function (see g_log_set_writer_func()) which appends all log messages
   * to a queue. When you want to check the log messages, examine and clear the
   * queue, ignoring irrelevant log messages (for example, from log domains other
   * than the one under test).
   */
<span class="line-new-header">--- 155,12 ---</span>
   * they should be limited to asserting that the library aborts and prints a
   * suitable error message before aborting. This should be done with
   * g_test_trap_assert_stderr().
   *
   * If it is really necessary to test the structured log messages emitted by a
<span class="line-modified">!  * particular piece of code - and the code cannot be restructured to be more</span>
<span class="line-modified">!  * suitable to more conventional unit testing - you should write a custom log</span>
   * writer function (see g_log_set_writer_func()) which appends all log messages
   * to a queue. When you want to check the log messages, examine and clear the
   * queue, ignoring irrelevant log messages (for example, from log domains other
   * than the one under test).
   */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 201,11 ***</span>
  #ifdef G_OS_UNIX
  #include &lt;unistd.h&gt;
  #endif
  
  #ifdef G_OS_WIN32
<span class="line-modified">! #include &lt;process.h&gt;        /* For getpid() */</span>
  #include &lt;io.h&gt;
  #  include &lt;windows.h&gt;
  
  #ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING
  #define ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004
<span class="line-new-header">--- 201,11 ---</span>
  #ifdef G_OS_UNIX
  #include &lt;unistd.h&gt;
  #endif
  
  #ifdef G_OS_WIN32
<span class="line-modified">! #include &lt;process.h&gt;    /* For getpid() */</span>
  #include &lt;io.h&gt;
  #  include &lt;windows.h&gt;
  
  #ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING
  #define ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004
</pre>
<hr />
<pre>
<span class="line-old-header">*** 491,23 ***</span>
  /* --- structures --- */
  typedef struct _GLogDomain  GLogDomain;
  typedef struct _GLogHandler GLogHandler;
  struct _GLogDomain
  {
<span class="line-modified">!   gchar     *log_domain;</span>
    GLogLevelFlags fatal_mask;
<span class="line-modified">!   GLogHandler   *handlers;</span>
<span class="line-modified">!   GLogDomain    *next;</span>
  };
  struct _GLogHandler
  {
<span class="line-modified">!   guint      id;</span>
    GLogLevelFlags log_level;
    GLogFunc   log_func;
    gpointer   data;
    GDestroyNotify destroy;
<span class="line-modified">!   GLogHandler   *next;</span>
  };
  
  
  /* --- variables --- */
  static GMutex         g_messages_lock;
<span class="line-new-header">--- 491,23 ---</span>
  /* --- structures --- */
  typedef struct _GLogDomain  GLogDomain;
  typedef struct _GLogHandler GLogHandler;
  struct _GLogDomain
  {
<span class="line-modified">!   gchar   *log_domain;</span>
    GLogLevelFlags fatal_mask;
<span class="line-modified">!   GLogHandler *handlers;</span>
<span class="line-modified">!   GLogDomain  *next;</span>
  };
  struct _GLogHandler
  {
<span class="line-modified">!   guint    id;</span>
    GLogLevelFlags log_level;
    GLogFunc   log_func;
    gpointer   data;
    GDestroyNotify destroy;
<span class="line-modified">!   GLogHandler *next;</span>
  };
  
  
  /* --- variables --- */
  static GMutex         g_messages_lock;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 567,12 ***</span>
  static gchar *fatal_msg_ptr = fatal_msg_buf;
  
  #undef write
  static inline int
  dowrite (int          fd,
<span class="line-modified">!      const void  *buf,</span>
<span class="line-modified">!      unsigned int len)</span>
  {
    if (win32_keep_fatal_message)
      {
        memcpy (fatal_msg_ptr, buf, len);
        fatal_msg_ptr += len;
<span class="line-new-header">--- 567,12 ---</span>
  static gchar *fatal_msg_ptr = fatal_msg_buf;
  
  #undef write
  static inline int
  dowrite (int          fd,
<span class="line-modified">!    const void  *buf,</span>
<span class="line-modified">!    unsigned int len)</span>
  {
    if (win32_keep_fatal_message)
      {
        memcpy (fatal_msg_ptr, buf, len);
        fatal_msg_ptr += len;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 588,11 ***</span>
  
  #endif
  
  static void
  write_string (FILE        *stream,
<span class="line-modified">!           const gchar *string)</span>
  {
    fputs (string, stream);
  }
  
  static void
<span class="line-new-header">--- 588,11 ---</span>
  
  #endif
  
  static void
  write_string (FILE        *stream,
<span class="line-modified">!         const gchar *string)</span>
  {
    fputs (string, stream);
  }
  
  static void
</pre>
<hr />
<pre>
<span class="line-old-header">*** 614,11 ***</span>
  
    domain = g_log_domains;
    while (domain)
      {
        if (strcmp (domain-&gt;log_domain, log_domain) == 0)
<span class="line-modified">!     return domain;</span>
        domain = domain-&gt;next;
      }
    return NULL;
  }
  
<span class="line-new-header">--- 614,11 ---</span>
  
    domain = g_log_domains;
    while (domain)
      {
        if (strcmp (domain-&gt;log_domain, log_domain) == 0)
<span class="line-modified">!   return domain;</span>
        domain = domain-&gt;next;
      }
    return NULL;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 648,46 ***</span>
  
        last = NULL;
  
        work = g_log_domains;
        while (work)
<span class="line-modified">!     {</span>
<span class="line-modified">!       if (work == domain)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           if (last)</span>
<span class="line-modified">!         last-&gt;next = domain-&gt;next;</span>
<span class="line-modified">!           else</span>
<span class="line-modified">!         g_log_domains = domain-&gt;next;</span>
<span class="line-modified">!           g_free (domain-&gt;log_domain);</span>
<span class="line-modified">!           g_free (domain);</span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       last = work;</span>
<span class="line-modified">!       work = last-&gt;next;</span>
<span class="line-modified">!     }</span>
      }
  }
  
  static GLogFunc
  g_log_domain_get_handler_L (GLogDomain  *domain,
<span class="line-modified">!                             GLogLevelFlags log_level,</span>
<span class="line-modified">!                 gpointer    *data)</span>
  {
    if (domain &amp;&amp; log_level)
      {
        GLogHandler *handler;
  
        handler = domain-&gt;handlers;
        while (handler)
<span class="line-modified">!     {</span>
<span class="line-modified">!       if ((handler-&gt;log_level &amp; log_level) == log_level)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           *data = handler-&gt;data;</span>
<span class="line-modified">!           return handler-&gt;log_func;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       handler = handler-&gt;next;</span>
<span class="line-modified">!     }</span>
      }
  
    *data = default_log_data;
    return default_log_func;
  }
<span class="line-new-header">--- 648,46 ---</span>
  
        last = NULL;
  
        work = g_log_domains;
        while (work)
<span class="line-modified">!   {</span>
<span class="line-modified">!     if (work == domain)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         if (last)</span>
<span class="line-modified">!     last-&gt;next = domain-&gt;next;</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!     g_log_domains = domain-&gt;next;</span>
<span class="line-modified">!         g_free (domain-&gt;log_domain);</span>
<span class="line-modified">!         g_free (domain);</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     last = work;</span>
<span class="line-modified">!     work = last-&gt;next;</span>
<span class="line-modified">!   }</span>
      }
  }
  
  static GLogFunc
  g_log_domain_get_handler_L (GLogDomain  *domain,
<span class="line-modified">!           GLogLevelFlags log_level,</span>
<span class="line-modified">!           gpointer  *data)</span>
  {
    if (domain &amp;&amp; log_level)
      {
        GLogHandler *handler;
  
        handler = domain-&gt;handlers;
        while (handler)
<span class="line-modified">!   {</span>
<span class="line-modified">!     if ((handler-&gt;log_level &amp; log_level) == log_level)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         *data = handler-&gt;data;</span>
<span class="line-modified">!         return handler-&gt;log_func;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     handler = handler-&gt;next;</span>
<span class="line-modified">!   }</span>
      }
  
    *data = default_log_data;
    return default_log_func;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 759,11 ***</span>
   *
   * Returns: the old fatal mask for the log domain
   */
  GLogLevelFlags
  g_log_set_fatal_mask (const gchar   *log_domain,
<span class="line-modified">!               GLogLevelFlags fatal_mask)</span>
  {
    GLogLevelFlags old_flags;
    GLogDomain *domain;
  
    if (!log_domain)
<span class="line-new-header">--- 759,11 ---</span>
   *
   * Returns: the old fatal mask for the log domain
   */
  GLogLevelFlags
  g_log_set_fatal_mask (const gchar   *log_domain,
<span class="line-modified">!           GLogLevelFlags fatal_mask)</span>
  {
    GLogLevelFlags old_flags;
    GLogDomain *domain;
  
    if (!log_domain)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 918,11 ***</span>
   *
   * Since: 2.6
   */
  GLogFunc
  g_log_set_default_handler (GLogFunc log_func,
<span class="line-modified">!                gpointer user_data)</span>
  {
    GLogFunc old_log_func;
  
    g_mutex_lock (&amp;g_messages_lock);
    old_log_func = default_log_func;
<span class="line-new-header">--- 918,11 ---</span>
   *
   * Since: 2.6
   */
  GLogFunc
  g_log_set_default_handler (GLogFunc log_func,
<span class="line-modified">!          gpointer user_data)</span>
  {
    GLogFunc old_log_func;
  
    g_mutex_lock (&amp;g_messages_lock);
    old_log_func = default_log_func;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 983,11 ***</span>
   * This has no effect if structured logging is enabled; see
   * [Using Structured Logging][using-structured-logging].
   */
  void
  g_log_remove_handler (const gchar *log_domain,
<span class="line-modified">!               guint    handler_id)</span>
  {
    GLogDomain *domain;
  
    g_return_if_fail (handler_id &gt; 0);
  
<span class="line-new-header">--- 983,11 ---</span>
   * This has no effect if structured logging is enabled; see
   * [Using Structured Logging][using-structured-logging].
   */
  void
  g_log_remove_handler (const gchar *log_domain,
<span class="line-modified">!           guint    handler_id)</span>
  {
    GLogDomain *domain;
  
    g_return_if_fail (handler_id &gt; 0);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1001,79 ***</span>
        GLogHandler *work, *last;
  
        last = NULL;
        work = domain-&gt;handlers;
        while (work)
<span class="line-modified">!     {</span>
<span class="line-modified">!       if (work-&gt;id == handler_id)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           if (last)</span>
<span class="line-modified">!         last-&gt;next = work-&gt;next;</span>
<span class="line-modified">!           else</span>
<span class="line-modified">!         domain-&gt;handlers = work-&gt;next;</span>
<span class="line-modified">!           g_log_domain_check_free_L (domain);</span>
<span class="line-modified">!           g_mutex_unlock (&amp;g_messages_lock);</span>
                if (work-&gt;destroy)
                  work-&gt;destroy (work-&gt;data);
<span class="line-modified">!           g_free (work);</span>
<span class="line-modified">!           return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       last = work;</span>
<span class="line-modified">!       work = last-&gt;next;</span>
<span class="line-modified">!     }</span>
      }
    g_mutex_unlock (&amp;g_messages_lock);
    g_warning (&quot;%s: could not find handler with id &#39;%d&#39; for domain \&quot;%s\&quot;&quot;,
<span class="line-modified">!          G_STRLOC, handler_id, log_domain);</span>
  }
  
  #define CHAR_IS_SAFE(wc) (!((wc &lt; 0x20 &amp;&amp; wc != &#39;\t&#39; &amp;&amp; wc != &#39;\n&#39; &amp;&amp; wc != &#39;\r&#39;) || \
<span class="line-modified">!                 (wc == 0x7f) || \</span>
<span class="line-modified">!                 (wc &gt;= 0x80 &amp;&amp; wc &lt; 0xa0)))</span>
  
  static gchar*
  strdup_convert (const gchar *string,
<span class="line-modified">!         const gchar *charset)</span>
  {
    if (!g_utf8_validate (string, -1, NULL))
      {
        GString *gstring = g_string_new (&quot;[Invalid UTF-8] &quot;);
        guchar *p;
  
        for (p = (guchar *)string; *p; p++)
<span class="line-modified">!     {</span>
<span class="line-modified">!       if (CHAR_IS_SAFE(*p) &amp;&amp;</span>
<span class="line-modified">!           !(*p == &#39;\r&#39; &amp;&amp; *(p + 1) != &#39;\n&#39;) &amp;&amp;</span>
<span class="line-modified">!           *p &lt; 0x80)</span>
<span class="line-modified">!         g_string_append_c (gstring, *p);</span>
<span class="line-modified">!       else</span>
<span class="line-modified">!         g_string_append_printf (gstring, &quot;\\x%02x&quot;, (guint)(guchar)*p);</span>
<span class="line-modified">!     }</span>
  
        return g_string_free (gstring, FALSE);
      }
    else
      {
        GError *err = NULL;
  
        gchar *result = g_convert_with_fallback (string, -1, charset, &quot;UTF-8&quot;, &quot;?&quot;, NULL, NULL, &amp;err);
        if (result)
<span class="line-modified">!     return result;</span>
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       /* Not thread-safe, but doesn&#39;t matter if we print the warning twice</span>
<span class="line-modified">!        */</span>
<span class="line-modified">!       static gboolean warned = FALSE;</span>
<span class="line-modified">!       if (!warned)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           warned = TRUE;</span>
<span class="line-modified">!           _g_fprintf (stderr, &quot;GLib: Cannot convert message: %s\n&quot;, err-&gt;message);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       g_error_free (err);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       return g_strdup (string);</span>
<span class="line-modified">!     }</span>
      }
  }
  
  /* For a radix of 8 we need at most 3 output bytes for 1 input
   * byte. Additionally we might need up to 2 output bytes for the
<span class="line-new-header">--- 1001,79 ---</span>
        GLogHandler *work, *last;
  
        last = NULL;
        work = domain-&gt;handlers;
        while (work)
<span class="line-modified">!   {</span>
<span class="line-modified">!     if (work-&gt;id == handler_id)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         if (last)</span>
<span class="line-modified">!     last-&gt;next = work-&gt;next;</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!     domain-&gt;handlers = work-&gt;next;</span>
<span class="line-modified">!         g_log_domain_check_free_L (domain);</span>
<span class="line-modified">!         g_mutex_unlock (&amp;g_messages_lock);</span>
                if (work-&gt;destroy)
                  work-&gt;destroy (work-&gt;data);
<span class="line-modified">!         g_free (work);</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     last = work;</span>
<span class="line-modified">!     work = last-&gt;next;</span>
<span class="line-modified">!   }</span>
      }
    g_mutex_unlock (&amp;g_messages_lock);
    g_warning (&quot;%s: could not find handler with id &#39;%d&#39; for domain \&quot;%s\&quot;&quot;,
<span class="line-modified">!        G_STRLOC, handler_id, log_domain);</span>
  }
  
  #define CHAR_IS_SAFE(wc) (!((wc &lt; 0x20 &amp;&amp; wc != &#39;\t&#39; &amp;&amp; wc != &#39;\n&#39; &amp;&amp; wc != &#39;\r&#39;) || \
<span class="line-modified">!           (wc == 0x7f) || \</span>
<span class="line-modified">!           (wc &gt;= 0x80 &amp;&amp; wc &lt; 0xa0)))</span>
  
  static gchar*
  strdup_convert (const gchar *string,
<span class="line-modified">!     const gchar *charset)</span>
  {
    if (!g_utf8_validate (string, -1, NULL))
      {
        GString *gstring = g_string_new (&quot;[Invalid UTF-8] &quot;);
        guchar *p;
  
        for (p = (guchar *)string; *p; p++)
<span class="line-modified">!   {</span>
<span class="line-modified">!     if (CHAR_IS_SAFE(*p) &amp;&amp;</span>
<span class="line-modified">!         !(*p == &#39;\r&#39; &amp;&amp; *(p + 1) != &#39;\n&#39;) &amp;&amp;</span>
<span class="line-modified">!         *p &lt; 0x80)</span>
<span class="line-modified">!       g_string_append_c (gstring, *p);</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       g_string_append_printf (gstring, &quot;\\x%02x&quot;, (guint)(guchar)*p);</span>
<span class="line-modified">!   }</span>
  
        return g_string_free (gstring, FALSE);
      }
    else
      {
        GError *err = NULL;
  
        gchar *result = g_convert_with_fallback (string, -1, charset, &quot;UTF-8&quot;, &quot;?&quot;, NULL, NULL, &amp;err);
        if (result)
<span class="line-modified">!   return result;</span>
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     /* Not thread-safe, but doesn&#39;t matter if we print the warning twice</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     static gboolean warned = FALSE;</span>
<span class="line-modified">!     if (!warned)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         warned = TRUE;</span>
<span class="line-modified">!         _g_fprintf (stderr, &quot;GLib: Cannot convert message: %s\n&quot;, err-&gt;message);</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     g_error_free (err);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     return g_strdup (string);</span>
<span class="line-modified">!   }</span>
      }
  }
  
  /* For a radix of 8 we need at most 3 output bytes for 1 input
   * byte. Additionally we might need up to 2 output bytes for the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1081,12 ***</span>
   */
  #define FORMAT_UNSIGNED_BUFSIZE ((GLIB_SIZEOF_LONG * 3) + 3)
  
  static void
  format_unsigned (gchar  *buf,
<span class="line-modified">!          gulong  num,</span>
<span class="line-modified">!          guint   radix)</span>
  {
    gulong tmp;
    gchar c;
    gint i, n;
  
<span class="line-new-header">--- 1081,12 ---</span>
   */
  #define FORMAT_UNSIGNED_BUFSIZE ((GLIB_SIZEOF_LONG * 3) + 3)
  
  static void
  format_unsigned (gchar  *buf,
<span class="line-modified">!      gulong  num,</span>
<span class="line-modified">!      guint   radix)</span>
  {
    gulong tmp;
    gchar c;
    gint i, n;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1135,23 ***</span>
    while (num)
      {
        i--;
        c = (num % radix);
        if (c &lt; 10)
<span class="line-modified">!     buf[i] = c + &#39;0&#39;;</span>
        else
<span class="line-modified">!     buf[i] = c + &#39;a&#39; - 10;</span>
        num /= radix;
      }
  
    buf[n] = &#39;\000&#39;;
  }
  
  /* string size big enough to hold level prefix */
  #define STRING_BUFFER_SIZE  (FORMAT_UNSIGNED_BUFSIZE + 32)
  
<span class="line-modified">! #define ALERT_LEVELS        (G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING)</span>
  
  /* these are emitted by the default log handler */
  #define DEFAULT_LEVELS (G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING | G_LOG_LEVEL_MESSAGE)
  /* these are filtered by G_MESSAGES_DEBUG by the default log handler */
  #define INFO_LEVELS (G_LOG_LEVEL_INFO | G_LOG_LEVEL_DEBUG)
<span class="line-new-header">--- 1135,23 ---</span>
    while (num)
      {
        i--;
        c = (num % radix);
        if (c &lt; 10)
<span class="line-modified">!   buf[i] = c + &#39;0&#39;;</span>
        else
<span class="line-modified">!   buf[i] = c + &#39;a&#39; - 10;</span>
        num /= radix;
      }
  
    buf[n] = &#39;\000&#39;;
  }
  
  /* string size big enough to hold level prefix */
  #define STRING_BUFFER_SIZE  (FORMAT_UNSIGNED_BUFSIZE + 32)
  
<span class="line-modified">! #define ALERT_LEVELS    (G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING)</span>
  
  /* these are emitted by the default log handler */
  #define DEFAULT_LEVELS (G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING | G_LOG_LEVEL_MESSAGE)
  /* these are filtered by G_MESSAGES_DEBUG by the default log handler */
  #define INFO_LEVELS (G_LOG_LEVEL_INFO | G_LOG_LEVEL_DEBUG)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1195,16 ***</span>
      case G_LOG_LEVEL_DEBUG:
        strcat (level_prefix, &quot;DEBUG&quot;);
        break;
      default:
        if (log_level)
<span class="line-modified">!     {</span>
<span class="line-modified">!       strcat (level_prefix, &quot;LOG-&quot;);</span>
<span class="line-modified">!       format_unsigned (level_prefix + 4, log_level &amp; G_LOG_LEVEL_MASK, 16);</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     strcat (level_prefix, &quot;LOG&quot;);</span>
        break;
      }
  
    strcat (level_prefix, color_reset (use_color));
  
<span class="line-new-header">--- 1195,16 ---</span>
      case G_LOG_LEVEL_DEBUG:
        strcat (level_prefix, &quot;DEBUG&quot;);
        break;
      default:
        if (log_level)
<span class="line-modified">!   {</span>
<span class="line-modified">!     strcat (level_prefix, &quot;LOG-&quot;);</span>
<span class="line-modified">!     format_unsigned (level_prefix + 4, log_level &amp; G_LOG_LEVEL_MASK, 16);</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   strcat (level_prefix, &quot;LOG&quot;);</span>
        break;
      }
  
    strcat (level_prefix, color_reset (use_color));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1249,13 ***</span>
   * If [structured logging is enabled][using-structured-logging] this will
   * output via the structured log writer function (see g_log_set_writer_func()).
   */
  void
  g_logv (const gchar   *log_domain,
<span class="line-modified">!         GLogLevelFlags log_level,</span>
<span class="line-modified">!         const gchar   *format,</span>
<span class="line-modified">!     va_list        args)</span>
  {
    gboolean was_fatal = (log_level &amp; G_LOG_FLAG_FATAL) != 0;
    gboolean was_recursion = (log_level &amp; G_LOG_FLAG_RECURSION) != 0;
    gchar buffer[1025], *msg, *msg_alloc = NULL;
    gint i;
<span class="line-new-header">--- 1249,13 ---</span>
   * If [structured logging is enabled][using-structured-logging] this will
   * output via the structured log writer function (see g_log_set_writer_func()).
   */
  void
  g_logv (const gchar   *log_domain,
<span class="line-modified">!   GLogLevelFlags log_level,</span>
<span class="line-modified">!   const gchar   *format,</span>
<span class="line-modified">!   va_list        args)</span>
  {
    gboolean was_fatal = (log_level &amp; G_LOG_FLAG_FATAL) != 0;
    gboolean was_recursion = (log_level &amp; G_LOG_FLAG_RECURSION) != 0;
    gchar buffer[1025], *msg, *msg_alloc = NULL;
    gint i;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1313,41 ***</span>
      {
        GLogLevelFlags test_level;
  
        test_level = 1 &lt;&lt; i;
        if (log_level &amp; test_level)
<span class="line-modified">!     {</span>
<span class="line-modified">!       GLogDomain *domain;</span>
<span class="line-modified">!       GLogFunc log_func;</span>
<span class="line-modified">!       GLogLevelFlags domain_fatal_mask;</span>
<span class="line-modified">!       gpointer data = NULL;</span>
            gboolean masquerade_fatal = FALSE;
            guint depth;
  
<span class="line-modified">!       if (was_fatal)</span>
<span class="line-modified">!         test_level |= G_LOG_FLAG_FATAL;</span>
<span class="line-modified">!       if (was_recursion)</span>
<span class="line-modified">!         test_level |= G_LOG_FLAG_RECURSION;</span>
  
<span class="line-modified">!       /* check recursion and lookup handler */</span>
<span class="line-modified">!       g_mutex_lock (&amp;g_messages_lock);</span>
            depth = GPOINTER_TO_UINT (g_private_get (&amp;g_log_depth));
<span class="line-modified">!       domain = g_log_find_domain_L (log_domain ? log_domain : &quot;&quot;);</span>
<span class="line-modified">!       if (depth)</span>
<span class="line-modified">!         test_level |= G_LOG_FLAG_RECURSION;</span>
<span class="line-modified">!       depth++;</span>
<span class="line-modified">!       domain_fatal_mask = domain ? domain-&gt;fatal_mask : G_LOG_FATAL_MASK;</span>
<span class="line-modified">!       if ((domain_fatal_mask | g_log_always_fatal) &amp; test_level)</span>
<span class="line-modified">!         test_level |= G_LOG_FLAG_FATAL;</span>
<span class="line-modified">!       if (test_level &amp; G_LOG_FLAG_RECURSION)</span>
<span class="line-modified">!         log_func = _g_log_fallback_handler;</span>
<span class="line-modified">!       else</span>
<span class="line-modified">!         log_func = g_log_domain_get_handler_L (domain, test_level, &amp;data);</span>
<span class="line-modified">!       domain = NULL;</span>
<span class="line-modified">!       g_mutex_unlock (&amp;g_messages_lock);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       g_private_set (&amp;g_log_depth, GUINT_TO_POINTER (depth));</span>
  
            log_func (log_domain, test_level, msg, data);
  
            if ((test_level &amp; G_LOG_FLAG_FATAL)
                &amp;&amp; !(test_level &amp; G_LOG_LEVEL_ERROR))
<span class="line-new-header">--- 1313,41 ---</span>
      {
        GLogLevelFlags test_level;
  
        test_level = 1 &lt;&lt; i;
        if (log_level &amp; test_level)
<span class="line-modified">!   {</span>
<span class="line-modified">!     GLogDomain *domain;</span>
<span class="line-modified">!     GLogFunc log_func;</span>
<span class="line-modified">!     GLogLevelFlags domain_fatal_mask;</span>
<span class="line-modified">!     gpointer data = NULL;</span>
            gboolean masquerade_fatal = FALSE;
            guint depth;
  
<span class="line-modified">!     if (was_fatal)</span>
<span class="line-modified">!       test_level |= G_LOG_FLAG_FATAL;</span>
<span class="line-modified">!     if (was_recursion)</span>
<span class="line-modified">!       test_level |= G_LOG_FLAG_RECURSION;</span>
  
<span class="line-modified">!     /* check recursion and lookup handler */</span>
<span class="line-modified">!     g_mutex_lock (&amp;g_messages_lock);</span>
            depth = GPOINTER_TO_UINT (g_private_get (&amp;g_log_depth));
<span class="line-modified">!     domain = g_log_find_domain_L (log_domain ? log_domain : &quot;&quot;);</span>
<span class="line-modified">!     if (depth)</span>
<span class="line-modified">!       test_level |= G_LOG_FLAG_RECURSION;</span>
<span class="line-modified">!     depth++;</span>
<span class="line-modified">!     domain_fatal_mask = domain ? domain-&gt;fatal_mask : G_LOG_FATAL_MASK;</span>
<span class="line-modified">!     if ((domain_fatal_mask | g_log_always_fatal) &amp; test_level)</span>
<span class="line-modified">!       test_level |= G_LOG_FLAG_FATAL;</span>
<span class="line-modified">!     if (test_level &amp; G_LOG_FLAG_RECURSION)</span>
<span class="line-modified">!       log_func = _g_log_fallback_handler;</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       log_func = g_log_domain_get_handler_L (domain, test_level, &amp;data);</span>
<span class="line-modified">!     domain = NULL;</span>
<span class="line-modified">!     g_mutex_unlock (&amp;g_messages_lock);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     g_private_set (&amp;g_log_depth, GUINT_TO_POINTER (depth));</span>
  
            log_func (log_domain, test_level, msg, data);
  
            if ((test_level &amp; G_LOG_FLAG_FATAL)
                &amp;&amp; !(test_level &amp; G_LOG_LEVEL_ERROR))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1356,26 ***</span>
                  &amp;&amp; !fatal_log_func (log_domain, test_level, msg, fatal_log_data);
              }
  
            if ((test_level &amp; G_LOG_FLAG_FATAL) &amp;&amp; !masquerade_fatal)
              {
<span class="line-modified">! #ifdef G_OS_WIN32</span>
                if (win32_keep_fatal_message)
                  {
                    gchar *locale_msg = g_locale_from_utf8 (fatal_msg_buf, -1, NULL, NULL, NULL);
  
                    MessageBox (NULL, locale_msg, NULL,
                                MB_ICONERROR|MB_SETFOREGROUND);
                  }
<span class="line-modified">! #endif /* !G_OS_WIN32 */</span>
  
<span class="line-modified">!           _g_log_abort (!(test_level &amp; G_LOG_FLAG_RECURSION));</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!       depth--;</span>
<span class="line-modified">!       g_private_set (&amp;g_log_depth, GUINT_TO_POINTER (depth));</span>
<span class="line-modified">!     }</span>
      }
  
    g_free (msg_alloc);
  }
  
<span class="line-new-header">--- 1356,28 ---</span>
                  &amp;&amp; !fatal_log_func (log_domain, test_level, msg, fatal_log_data);
              }
  
            if ((test_level &amp; G_LOG_FLAG_FATAL) &amp;&amp; !masquerade_fatal)
              {
<span class="line-modified">!               /* MessageBox is allowed on UWP apps only when building against</span>
<span class="line-added">+                * the debug CRT, which will set -D_DEBUG */</span>
<span class="line-added">+ #if defined(G_OS_WIN32) &amp;&amp; (defined(_DEBUG) || !defined(G_WINAPI_ONLY_APP))</span>
                if (win32_keep_fatal_message)
                  {
                    gchar *locale_msg = g_locale_from_utf8 (fatal_msg_buf, -1, NULL, NULL, NULL);
  
                    MessageBox (NULL, locale_msg, NULL,
                                MB_ICONERROR|MB_SETFOREGROUND);
                  }
<span class="line-modified">! #endif</span>
  
<span class="line-modified">!               _g_log_abort (!(test_level &amp; G_LOG_FLAG_RECURSION));</span>
<span class="line-modified">!       }</span>
  
<span class="line-modified">!     depth--;</span>
<span class="line-modified">!     g_private_set (&amp;g_log_depth, GUINT_TO_POINTER (depth));</span>
<span class="line-modified">!   }</span>
      }
  
    g_free (msg_alloc);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2163,35 ***</span>
  {
  #if defined(__linux__) &amp;&amp; !defined(__BIONIC__)
    /* FIXME: Use the new journal API for detecting whether we&#39;re writing to the
     * journal. See: https://github.com/systemd/systemd/issues/2473
     */
<span class="line-modified">!   static gsize initialized;</span>
<span class="line-modified">!   static gboolean fd_is_journal = FALSE;</span>
  
    if (output_fd &lt; 0)
      return FALSE;
  
<span class="line-modified">!   if (g_once_init_enter (&amp;initialized))</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       union {</span>
<span class="line-modified">!         struct sockaddr_storage storage;</span>
<span class="line-modified">!         struct sockaddr sa;</span>
<span class="line-removed">-         struct sockaddr_un un;</span>
<span class="line-removed">-       } addr;</span>
<span class="line-removed">-       socklen_t addr_len = sizeof(addr);</span>
<span class="line-removed">-       int err = getpeername (output_fd, &amp;addr.sa, &amp;addr_len);</span>
<span class="line-removed">-       if (err == 0 &amp;&amp; addr.storage.ss_family == AF_UNIX)</span>
<span class="line-removed">-         fd_is_journal = g_str_has_prefix (addr.un.sun_path, &quot;/run/systemd/journal/&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       g_once_init_leave (&amp;initialized, TRUE);</span>
<span class="line-removed">-     }</span>
  
<span class="line-removed">-   return fd_is_journal;</span>
<span class="line-removed">- #else</span>
    return FALSE;
<span class="line-removed">- #endif</span>
  }
  
  static void escape_string (GString *string);
  
  /**
<span class="line-new-header">--- 2165,28 ---</span>
  {
  #if defined(__linux__) &amp;&amp; !defined(__BIONIC__)
    /* FIXME: Use the new journal API for detecting whether we&#39;re writing to the
     * journal. See: https://github.com/systemd/systemd/issues/2473
     */
<span class="line-modified">!   union {</span>
<span class="line-modified">!     struct sockaddr_storage storage;</span>
<span class="line-added">+     struct sockaddr sa;</span>
<span class="line-added">+     struct sockaddr_un un;</span>
<span class="line-added">+   } addr;</span>
<span class="line-added">+   socklen_t addr_len;</span>
<span class="line-added">+   int err;</span>
  
    if (output_fd &lt; 0)
      return FALSE;
  
<span class="line-modified">!   addr_len = sizeof(addr);</span>
<span class="line-modified">!   err = getpeername (output_fd, &amp;addr.sa, &amp;addr_len);</span>
<span class="line-modified">!   if (err == 0 &amp;&amp; addr.storage.ss_family == AF_UNIX)</span>
<span class="line-modified">!     return g_str_has_prefix (addr.un.sun_path, &quot;/run/systemd/journal/&quot;);</span>
<span class="line-modified">! #endif</span>
  
    return FALSE;
  }
  
  static void escape_string (GString *string);
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2296,11 ***</span>
        const gchar *charset;
  
        msg = g_string_new (message);
        escape_string (msg);
  
<span class="line-modified">!       if (g_get_charset (&amp;charset))</span>
          {
            /* charset is UTF-8 already */
            g_string_append (gstring, msg-&gt;str);
          }
        else
<span class="line-new-header">--- 2291,11 ---</span>
        const gchar *charset;
  
        msg = g_string_new (message);
        escape_string (msg);
  
<span class="line-modified">!       if (g_get_console_charset (&amp;charset))</span>
          {
            /* charset is UTF-8 already */
            g_string_append (gstring, msg-&gt;str);
          }
        else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2618,10 ***</span>
<span class="line-new-header">--- 2613,13 ---</span>
  g_log_writer_default (GLogLevelFlags   log_level,
                        const GLogField *fields,
                        gsize            n_fields,
                        gpointer         user_data)
  {
<span class="line-added">+   static gsize initialized = 0;</span>
<span class="line-added">+   static gboolean stderr_is_journal = FALSE;</span>
<span class="line-added">+ </span>
    g_return_val_if_fail (fields != NULL, G_LOG_WRITER_UNHANDLED);
    g_return_val_if_fail (n_fields &gt; 0, G_LOG_WRITER_UNHANDLED);
  
    /* Disable debug message output unless specified in G_MESSAGES_DEBUG. */
    if (!(log_level &amp; DEFAULT_LEVELS) &amp;&amp; !(log_level &gt;&gt; G_LOG_LEVEL_USER_SHIFT))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2654,11 ***</span>
     */
    if ((log_level &amp; g_log_always_fatal) &amp;&amp; !log_is_old_api (fields, n_fields))
      log_level |= G_LOG_FLAG_FATAL;
  
    /* Try logging to the systemd journal as first choice. */
<span class="line-modified">!   if (g_log_writer_is_journald (fileno (stderr)) &amp;&amp;</span>
        g_log_writer_journald (log_level, fields, n_fields, user_data) ==
        G_LOG_WRITER_HANDLED)
      goto handled;
  
    /* FIXME: Add support for the Windows log. */
<span class="line-new-header">--- 2652,17 ---</span>
     */
    if ((log_level &amp; g_log_always_fatal) &amp;&amp; !log_is_old_api (fields, n_fields))
      log_level |= G_LOG_FLAG_FATAL;
  
    /* Try logging to the systemd journal as first choice. */
<span class="line-modified">!   if (g_once_init_enter (&amp;initialized))</span>
<span class="line-added">+     {</span>
<span class="line-added">+       stderr_is_journal = g_log_writer_is_journald (fileno (stderr));</span>
<span class="line-added">+       g_once_init_leave (&amp;initialized, TRUE);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (stderr_is_journal &amp;&amp;</span>
        g_log_writer_journald (log_level, fields, n_fields, user_data) ==
        G_LOG_WRITER_HANDLED)
      goto handled;
  
    /* FIXME: Add support for the Windows log. */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2671,11 ***</span>
  
  handled:
    /* Abort if the message was fatal. */
    if (log_level &amp; G_LOG_FLAG_FATAL)
      {
<span class="line-modified">! #ifdef G_OS_WIN32</span>
        if (!g_test_initialized ())
          {
            gchar *locale_msg = NULL;
  
            locale_msg = g_locale_from_utf8 (fatal_msg_buf, -1, NULL, NULL, NULL);
<span class="line-new-header">--- 2675,13 ---</span>
  
  handled:
    /* Abort if the message was fatal. */
    if (log_level &amp; G_LOG_FLAG_FATAL)
      {
<span class="line-modified">!       /* MessageBox is allowed on UWP apps only when building against</span>
<span class="line-added">+        * the debug CRT, which will set -D_DEBUG */</span>
<span class="line-added">+ #if defined(G_OS_WIN32) &amp;&amp; (defined(_DEBUG) || !defined(G_WINAPI_ONLY_APP))</span>
        if (!g_test_initialized ())
          {
            gchar *locale_msg = NULL;
  
            locale_msg = g_locale_from_utf8 (fatal_msg_buf, -1, NULL, NULL, NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2748,33 ***</span>
    return G_LOG_WRITER_HANDLED;
  }
  
  /**
   * g_return_if_fail_warning: (skip)
<span class="line-modified">!  * @log_domain: (nullable):</span>
<span class="line-modified">!  * @pretty_function:</span>
<span class="line-modified">!  * @expression: (nullable):</span>
   */
  void
  g_return_if_fail_warning (const char *log_domain,
<span class="line-modified">!               const char *pretty_function,</span>
<span class="line-modified">!               const char *expression)</span>
  {
    g_log (log_domain,
<span class="line-modified">!      G_LOG_LEVEL_CRITICAL,</span>
<span class="line-modified">!      &quot;%s: assertion &#39;%s&#39; failed&quot;,</span>
<span class="line-modified">!      pretty_function,</span>
<span class="line-modified">!      expression);</span>
  }
  
  /**
   * g_warn_message: (skip)
<span class="line-modified">!  * @domain: (nullable):</span>
<span class="line-modified">!  * @file:</span>
<span class="line-modified">!  * @line:</span>
<span class="line-modified">!  * @func:</span>
<span class="line-modified">!  * @warnexpr: (nullable):</span>
   */
  void
  g_warn_message (const char     *domain,
                  const char     *file,
                  int             line,
<span class="line-new-header">--- 2754,39 ---</span>
    return G_LOG_WRITER_HANDLED;
  }
  
  /**
   * g_return_if_fail_warning: (skip)
<span class="line-modified">!  * @log_domain: (nullable): log domain</span>
<span class="line-modified">!  * @pretty_function: function containing the assertion</span>
<span class="line-modified">!  * @expression: (nullable): expression which failed</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Internal function used to print messages from the public g_return_if_fail()</span>
<span class="line-added">+  * and g_return_val_if_fail() macros.</span>
   */
  void
  g_return_if_fail_warning (const char *log_domain,
<span class="line-modified">!         const char *pretty_function,</span>
<span class="line-modified">!         const char *expression)</span>
  {
    g_log (log_domain,
<span class="line-modified">!    G_LOG_LEVEL_CRITICAL,</span>
<span class="line-modified">!    &quot;%s: assertion &#39;%s&#39; failed&quot;,</span>
<span class="line-modified">!    pretty_function,</span>
<span class="line-modified">!    expression);</span>
  }
  
  /**
   * g_warn_message: (skip)
<span class="line-modified">!  * @domain: (nullable): log domain</span>
<span class="line-modified">!  * @file: file containing the warning</span>
<span class="line-modified">!  * @line: line number of the warning</span>
<span class="line-modified">!  * @func: function containing the warning</span>
<span class="line-modified">!  * @warnexpr: (nullable): expression which failed</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Internal function used to print messages from the public g_warn_if_reached()</span>
<span class="line-added">+  * and g_warn_if_fail() macros.</span>
   */
  void
  g_warn_message (const char     *domain,
                  const char     *file,
                  int             line,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2795,30 ***</span>
    g_free (s);
  }
  
  void
  g_assert_warning (const char *log_domain,
<span class="line-modified">!           const char *file,</span>
<span class="line-modified">!           const int   line,</span>
<span class="line-modified">!           const char *pretty_function,</span>
<span class="line-modified">!           const char *expression)</span>
  {
    if (expression)
      g_log (log_domain,
<span class="line-modified">!        G_LOG_LEVEL_ERROR,</span>
<span class="line-modified">!        &quot;file %s: line %d (%s): assertion failed: (%s)&quot;,</span>
<span class="line-modified">!        file,</span>
<span class="line-modified">!        line,</span>
<span class="line-modified">!        pretty_function,</span>
<span class="line-modified">!        expression);</span>
    else
      g_log (log_domain,
<span class="line-modified">!        G_LOG_LEVEL_ERROR,</span>
<span class="line-modified">!        &quot;file %s: line %d (%s): should not be reached&quot;,</span>
<span class="line-modified">!        file,</span>
<span class="line-modified">!        line,</span>
<span class="line-modified">!        pretty_function);</span>
    _g_log_abort (FALSE);
    g_abort ();
  }
  
  /**
<span class="line-new-header">--- 2807,30 ---</span>
    g_free (s);
  }
  
  void
  g_assert_warning (const char *log_domain,
<span class="line-modified">!       const char *file,</span>
<span class="line-modified">!       const int   line,</span>
<span class="line-modified">!       const char *pretty_function,</span>
<span class="line-modified">!       const char *expression)</span>
  {
    if (expression)
      g_log (log_domain,
<span class="line-modified">!      G_LOG_LEVEL_ERROR,</span>
<span class="line-modified">!      &quot;file %s: line %d (%s): assertion failed: (%s)&quot;,</span>
<span class="line-modified">!      file,</span>
<span class="line-modified">!      line,</span>
<span class="line-modified">!      pretty_function,</span>
<span class="line-modified">!      expression);</span>
    else
      g_log (log_domain,
<span class="line-modified">!      G_LOG_LEVEL_ERROR,</span>
<span class="line-modified">!      &quot;file %s: line %d (%s): should not be reached&quot;,</span>
<span class="line-modified">!      file,</span>
<span class="line-modified">!      line,</span>
<span class="line-modified">!      pretty_function);</span>
    _g_log_abort (FALSE);
    g_abort ();
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2922,13 ***</span>
   * Since: 2.34
   */
  
  void
  _g_log_fallback_handler (const gchar   *log_domain,
<span class="line-modified">!              GLogLevelFlags log_level,</span>
<span class="line-modified">!              const gchar   *message,</span>
<span class="line-modified">!              gpointer       unused_data)</span>
  {
    gchar level_prefix[STRING_BUFFER_SIZE];
  #ifndef G_OS_WIN32
    gchar pid_string[FORMAT_UNSIGNED_BUFSIZE];
  #endif
<span class="line-new-header">--- 2934,13 ---</span>
   * Since: 2.34
   */
  
  void
  _g_log_fallback_handler (const gchar   *log_domain,
<span class="line-modified">!        GLogLevelFlags log_level,</span>
<span class="line-modified">!        const gchar   *message,</span>
<span class="line-modified">!        gpointer       unused_data)</span>
  {
    gchar level_prefix[STRING_BUFFER_SIZE];
  #ifndef G_OS_WIN32
    gchar pid_string[FORMAT_UNSIGNED_BUFSIZE];
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2980,55 ***</span>
      {
        gboolean safe;
  
        wc = g_utf8_get_char_validated (p, -1);
        if (wc == (gunichar)-1 || wc == (gunichar)-2)
<span class="line-modified">!     {</span>
<span class="line-modified">!       gchar *tmp;</span>
<span class="line-modified">!       guint pos;</span>
  
<span class="line-modified">!       pos = p - string-&gt;str;</span>
  
<span class="line-modified">!       /* Emit invalid UTF-8 as hex escapes</span>
             */
<span class="line-modified">!       tmp = g_strdup_printf (&quot;\\x%02x&quot;, (guint)(guchar)*p);</span>
<span class="line-modified">!       g_string_erase (string, pos, 1);</span>
<span class="line-modified">!       g_string_insert (string, pos, tmp);</span>
  
<span class="line-modified">!       p = string-&gt;str + (pos + 4); /* Skip over escape sequence */</span>
  
<span class="line-modified">!       g_free (tmp);</span>
<span class="line-modified">!       continue;</span>
<span class="line-modified">!     }</span>
        if (wc == &#39;\r&#39;)
<span class="line-modified">!     {</span>
<span class="line-modified">!       safe = *(p + 1) == &#39;\n&#39;;</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       safe = CHAR_IS_SAFE (wc);</span>
<span class="line-modified">!     }</span>
  
        if (!safe)
<span class="line-modified">!     {</span>
<span class="line-modified">!       gchar *tmp;</span>
<span class="line-modified">!       guint pos;</span>
  
<span class="line-modified">!       pos = p - string-&gt;str;</span>
  
<span class="line-modified">!       /* Largest char we escape is 0x0a, so we don&#39;t have to worry</span>
<span class="line-modified">!        * about 8-digit \Uxxxxyyyy</span>
<span class="line-modified">!        */</span>
<span class="line-modified">!       tmp = g_strdup_printf (&quot;\\u%04x&quot;, wc);</span>
<span class="line-modified">!       g_string_erase (string, pos, g_utf8_next_char (p) - p);</span>
<span class="line-modified">!       g_string_insert (string, pos, tmp);</span>
<span class="line-modified">!       g_free (tmp);</span>
  
<span class="line-modified">!       p = string-&gt;str + (pos + 6); /* Skip over escape sequence */</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     p = g_utf8_next_char (p);</span>
      }
  }
  
  /**
   * g_log_default_handler:
<span class="line-new-header">--- 2992,55 ---</span>
      {
        gboolean safe;
  
        wc = g_utf8_get_char_validated (p, -1);
        if (wc == (gunichar)-1 || wc == (gunichar)-2)
<span class="line-modified">!   {</span>
<span class="line-modified">!     gchar *tmp;</span>
<span class="line-modified">!     guint pos;</span>
  
<span class="line-modified">!     pos = p - string-&gt;str;</span>
  
<span class="line-modified">!     /* Emit invalid UTF-8 as hex escapes</span>
             */
<span class="line-modified">!     tmp = g_strdup_printf (&quot;\\x%02x&quot;, (guint)(guchar)*p);</span>
<span class="line-modified">!     g_string_erase (string, pos, 1);</span>
<span class="line-modified">!     g_string_insert (string, pos, tmp);</span>
  
<span class="line-modified">!     p = string-&gt;str + (pos + 4); /* Skip over escape sequence */</span>
  
<span class="line-modified">!     g_free (tmp);</span>
<span class="line-modified">!     continue;</span>
<span class="line-modified">!   }</span>
        if (wc == &#39;\r&#39;)
<span class="line-modified">!   {</span>
<span class="line-modified">!     safe = *(p + 1) == &#39;\n&#39;;</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     safe = CHAR_IS_SAFE (wc);</span>
<span class="line-modified">!   }</span>
  
        if (!safe)
<span class="line-modified">!   {</span>
<span class="line-modified">!     gchar *tmp;</span>
<span class="line-modified">!     guint pos;</span>
  
<span class="line-modified">!     pos = p - string-&gt;str;</span>
  
<span class="line-modified">!     /* Largest char we escape is 0x0a, so we don&#39;t have to worry</span>
<span class="line-modified">!      * about 8-digit \Uxxxxyyyy</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     tmp = g_strdup_printf (&quot;\\u%04x&quot;, wc);</span>
<span class="line-modified">!     g_string_erase (string, pos, g_utf8_next_char (p) - p);</span>
<span class="line-modified">!     g_string_insert (string, pos, tmp);</span>
<span class="line-modified">!     g_free (tmp);</span>
  
<span class="line-modified">!     p = string-&gt;str + (pos + 6); /* Skip over escape sequence */</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   p = g_utf8_next_char (p);</span>
      }
  }
  
  /**
   * g_log_default_handler:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3064,13 ***</span>
   * This has no effect if structured logging is enabled; see
   * [Using Structured Logging][using-structured-logging].
   */
  void
  g_log_default_handler (const gchar   *log_domain,
<span class="line-modified">!                        GLogLevelFlags log_level,</span>
<span class="line-modified">!                        const gchar   *message,</span>
<span class="line-modified">!                gpointer       unused_data)</span>
  {
    GLogField fields[4];
    int n_fields = 0;
  
    /* we can be called externally with recursion for whatever reason */
<span class="line-new-header">--- 3076,13 ---</span>
   * This has no effect if structured logging is enabled; see
   * [Using Structured Logging][using-structured-logging].
   */
  void
  g_log_default_handler (const gchar   *log_domain,
<span class="line-modified">!            GLogLevelFlags log_level,</span>
<span class="line-modified">!            const gchar   *message,</span>
<span class="line-modified">!            gpointer       unused_data)</span>
  {
    GLogField fields[4];
    int n_fields = 0;
  
    /* we can be called externally with recursion for whatever reason */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3107,11 ***</span>
     * have already handled them. The fatal handling in the structured logging
     * API is more coarse-grained than in the old g_log() API, so we don&#39;t want
     * to use it here.
     */
    g_log_structured_array (log_level &amp; ~G_LOG_FLAG_FATAL, fields, n_fields);
<span class="line-modified">!     }</span>
  
  /**
   * g_set_print_handler:
   * @func: the new print handler
   *
<span class="line-new-header">--- 3119,11 ---</span>
     * have already handled them. The fatal handling in the structured logging
     * API is more coarse-grained than in the old g_log() API, so we don&#39;t want
     * to use it here.
     */
    g_log_structured_array (log_level &amp; ~G_LOG_FLAG_FATAL, fields, n_fields);
<span class="line-modified">! }</span>
  
  /**
   * g_set_print_handler:
   * @func: the new print handler
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3176,11 ***</span>
      local_glib_print_func (string);
    else
      {
        const gchar *charset;
  
<span class="line-modified">!       if (g_get_charset (&amp;charset))</span>
          fputs (string, stdout); /* charset is UTF-8 already */
        else
          {
            gchar *lstring = strdup_convert (string, charset);
  
<span class="line-new-header">--- 3188,11 ---</span>
      local_glib_print_func (string);
    else
      {
        const gchar *charset;
  
<span class="line-modified">!       if (g_get_console_charset (&amp;charset))</span>
          fputs (string, stdout); /* charset is UTF-8 already */
        else
          {
            gchar *lstring = strdup_convert (string, charset);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3255,11 ***</span>
      local_glib_printerr_func (string);
    else
      {
        const gchar *charset;
  
<span class="line-modified">!       if (g_get_charset (&amp;charset))</span>
          fputs (string, stderr); /* charset is UTF-8 already */
        else
          {
            gchar *lstring = strdup_convert (string, charset);
  
<span class="line-new-header">--- 3267,11 ---</span>
      local_glib_printerr_func (string);
    else
      {
        const gchar *charset;
  
<span class="line-modified">!       if (g_get_console_charset (&amp;charset))</span>
          fputs (string, stderr); /* charset is UTF-8 already */
        else
          {
            gchar *lstring = strdup_convert (string, charset);
  
</pre>
<center><a href="gmem.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gmessages.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>