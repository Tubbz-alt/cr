<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstadapter.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 2004 Benjamin Otte &lt;otte@gnome.org&gt;
   3  *               2005 Wim Taymans &lt;wim@fluendo.com&gt;
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Library General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Library General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Library General Public
  16  * License along with this library; if not, write to the
  17  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  18  * Boston, MA 02110-1301, USA.
  19  */
  20 
  21 /**
  22  * SECTION:gstadapter
  23  * @title: GstAdapter
  24  * @short_description: adapts incoming data on a sink pad into chunks of N bytes
  25  *
  26  * This class is for elements that receive buffers in an undesired size.
  27  * While for example raw video contains one image per buffer, the same is not
  28  * true for a lot of other formats, especially those that come directly from
  29  * a file. So if you have undefined buffer sizes and require a specific size,
  30  * this object is for you.
  31  *
  32  * An adapter is created with gst_adapter_new(). It can be freed again with
  33  * g_object_unref().
  34  *
  35  * The theory of operation is like this: All buffers received are put
  36  * into the adapter using gst_adapter_push() and the data is then read back
  37  * in chunks of the desired size using gst_adapter_map()/gst_adapter_unmap()
  38  * and/or gst_adapter_copy(). After the data has been processed, it is freed
  39  * using gst_adapter_unmap().
  40  *
  41  * Other methods such as gst_adapter_take() and gst_adapter_take_buffer()
  42  * combine gst_adapter_map() and gst_adapter_unmap() in one method and are
  43  * potentially more convenient for some use cases.
  44  *
  45  * For example, a sink pad&#39;s chain function that needs to pass data to a library
  46  * in 512-byte chunks could be implemented like this:
  47  * |[&lt;!-- language=&quot;C&quot; --&gt;
  48  * static GstFlowReturn
  49  * sink_pad_chain (GstPad *pad, GstObject *parent, GstBuffer *buffer)
  50  * {
  51  *   MyElement *this;
  52  *   GstAdapter *adapter;
  53  *   GstFlowReturn ret = GST_FLOW_OK;
  54  *
  55  *   this = MY_ELEMENT (parent);
  56  *
  57  *   adapter = this-&gt;adapter;
  58  *
  59  *   // put buffer into adapter
  60  *   gst_adapter_push (adapter, buffer);
  61  *
  62  *   // while we can read out 512 bytes, process them
  63  *   while (gst_adapter_available (adapter) &gt;= 512 &amp;&amp; ret == GST_FLOW_OK) {
  64  *     const guint8 *data = gst_adapter_map (adapter, 512);
  65  *     // use flowreturn as an error value
  66  *     ret = my_library_foo (data);
  67  *     gst_adapter_unmap (adapter);
  68  *     gst_adapter_flush (adapter, 512);
  69  *   }
  70  *   return ret;
  71  * }
  72  * ]|
  73  *
  74  * For another example, a simple element inside GStreamer that uses #GstAdapter
  75  * is the libvisual element.
  76  *
  77  * An element using #GstAdapter in its sink pad chain function should ensure that
  78  * when the FLUSH_STOP event is received, that any queued data is cleared using
  79  * gst_adapter_clear(). Data should also be cleared or processed on EOS and
  80  * when changing state from %GST_STATE_PAUSED to %GST_STATE_READY.
  81  *
  82  * Also check the GST_BUFFER_FLAG_DISCONT flag on the buffer. Some elements might
  83  * need to clear the adapter after a discontinuity.
  84  *
  85  * The adapter will keep track of the timestamps of the buffers
  86  * that were pushed. The last seen timestamp before the current position
  87  * can be queried with gst_adapter_prev_pts(). This function can
  88  * optionally return the number of bytes between the start of the buffer that
  89  * carried the timestamp and the current adapter position. The distance is
  90  * useful when dealing with, for example, raw audio samples because it allows
  91  * you to calculate the timestamp of the current adapter position by using the
  92  * last seen timestamp and the amount of bytes since.  Additionally, the
  93  * gst_adapter_prev_pts_at_offset() can be used to determine the last
  94  * seen timestamp at a particular offset in the adapter.
  95  *
  96  * The adapter will also keep track of the offset of the buffers
  97  * (#GST_BUFFER_OFFSET) that were pushed. The last seen offset before the
  98  * current position can be queried with gst_adapter_prev_offset(). This function
  99  * can optionally return the number of bytes between the start of the buffer
 100  * that carried the offset and the current adapter position.
 101  *
 102  * Additionally the adapter also keeps track of the PTS, DTS and buffer offset
 103  * at the last discontinuity, which can be retrieved with
 104  * gst_adapter_pts_at_discont(), gst_adapter_dts_at_discont() and
 105  * gst_adapter_offset_at_discont(). The number of bytes that were consumed
 106  * since then can be queried with gst_adapter_distance_from_discont().
 107  *
 108  * A last thing to note is that while #GstAdapter is pretty optimized,
 109  * merging buffers still might be an operation that requires a malloc() and
 110  * memcpy() operation, and these operations are not the fastest. Because of
 111  * this, some functions like gst_adapter_available_fast() are provided to help
 112  * speed up such cases should you want to. To avoid repeated memory allocations,
 113  * gst_adapter_copy() can be used to copy data into a (statically allocated)
 114  * user provided buffer.
 115  *
 116  * #GstAdapter is not MT safe. All operations on an adapter must be serialized by
 117  * the caller. This is not normally a problem, however, as the normal use case
 118  * of #GstAdapter is inside one pad&#39;s chain function, in which case access is
 119  * serialized via the pad&#39;s STREAM_LOCK.
 120  *
 121  * Note that gst_adapter_push() takes ownership of the buffer passed. Use
 122  * gst_buffer_ref() before pushing it into the adapter if you still want to
 123  * access the buffer later. The adapter will never modify the data in the
 124  * buffer pushed in it.
 125  */
 126 
 127 #include &lt;gst/gst_private.h&gt;
 128 #include &quot;gstadapter.h&quot;
 129 #include &lt;string.h&gt;
<a name="1" id="anc1"></a><span class="line-added"> 130 #include &lt;gst/base/gstqueuearray.h&gt;</span>
 131 
 132 /* default size for the assembled data buffer */
 133 #define DEFAULT_SIZE 4096
 134 
 135 static void gst_adapter_flush_unchecked (GstAdapter * adapter, gsize flush);
 136 
 137 GST_DEBUG_CATEGORY_STATIC (gst_adapter_debug);
 138 #define GST_CAT_DEFAULT gst_adapter_debug
 139 
 140 struct _GstAdapter
 141 {
 142   GObject object;
 143 
 144   /*&lt; private &gt; */
<a name="2" id="anc2"></a><span class="line-modified"> 145   GstQueueArray *bufqueue;</span>

 146   gsize size;
 147   gsize skip;
 148   guint count;
 149 
 150   /* we keep state of assembled pieces */
 151   gpointer assembled_data;
 152   gsize assembled_size;
 153   gsize assembled_len;
 154 
 155   GstClockTime pts;
 156   guint64 pts_distance;
 157   GstClockTime dts;
 158   guint64 dts_distance;
 159   guint64 offset;
 160   guint64 offset_distance;
 161 
 162   gsize scan_offset;
<a name="3" id="anc3"></a><span class="line-modified"> 163   /* G_MAXUINT when unset */</span>
<span class="line-added"> 164   guint scan_entry_idx;</span>
 165 
 166   GstClockTime pts_at_discont;
 167   GstClockTime dts_at_discont;
 168   guint64 offset_at_discont;
 169 
 170   guint64 distance_from_discont;
 171 
 172   GstMapInfo info;
 173 };
 174 
 175 struct _GstAdapterClass
 176 {
 177   GObjectClass parent_class;
 178 };
 179 
 180 #define _do_init \
 181   GST_DEBUG_CATEGORY_INIT (gst_adapter_debug, &quot;adapter&quot;, 0, &quot;object to splice and merge buffers to desired size&quot;)
 182 #define gst_adapter_parent_class parent_class
 183 G_DEFINE_TYPE_WITH_CODE (GstAdapter, gst_adapter, G_TYPE_OBJECT, _do_init);
 184 
 185 static void gst_adapter_dispose (GObject * object);
 186 static void gst_adapter_finalize (GObject * object);
 187 
 188 static void
 189 gst_adapter_class_init (GstAdapterClass * klass)
 190 {
 191   GObjectClass *object = G_OBJECT_CLASS (klass);
 192 
 193   object-&gt;dispose = gst_adapter_dispose;
 194   object-&gt;finalize = gst_adapter_finalize;
 195 }
 196 
 197 static void
 198 gst_adapter_init (GstAdapter * adapter)
 199 {
 200   adapter-&gt;assembled_data = g_malloc (DEFAULT_SIZE);
 201   adapter-&gt;assembled_size = DEFAULT_SIZE;
 202   adapter-&gt;pts = GST_CLOCK_TIME_NONE;
 203   adapter-&gt;pts_distance = 0;
 204   adapter-&gt;dts = GST_CLOCK_TIME_NONE;
 205   adapter-&gt;dts_distance = 0;
 206   adapter-&gt;offset = GST_BUFFER_OFFSET_NONE;
 207   adapter-&gt;offset_distance = 0;
 208   adapter-&gt;pts_at_discont = GST_CLOCK_TIME_NONE;
 209   adapter-&gt;dts_at_discont = GST_CLOCK_TIME_NONE;
 210   adapter-&gt;offset_at_discont = GST_BUFFER_OFFSET_NONE;
 211   adapter-&gt;distance_from_discont = 0;
<a name="4" id="anc4"></a><span class="line-added"> 212   adapter-&gt;bufqueue = gst_queue_array_new (10);</span>
 213 }
 214 
 215 static void
 216 gst_adapter_dispose (GObject * object)
 217 {
 218   GstAdapter *adapter = GST_ADAPTER (object);
 219 
 220   gst_adapter_clear (adapter);
 221 
 222   GST_CALL_PARENT (G_OBJECT_CLASS, dispose, (object));
 223 }
 224 
 225 static void
 226 gst_adapter_finalize (GObject * object)
 227 {
 228   GstAdapter *adapter = GST_ADAPTER (object);
 229 
 230   g_free (adapter-&gt;assembled_data);
 231 
<a name="5" id="anc5"></a><span class="line-added"> 232   gst_queue_array_free (adapter-&gt;bufqueue);</span>
<span class="line-added"> 233 </span>
 234   GST_CALL_PARENT (G_OBJECT_CLASS, finalize, (object));
 235 }
 236 
 237 /**
 238  * gst_adapter_new:
 239  *
 240  * Creates a new #GstAdapter. Free with g_object_unref().
 241  *
 242  * Returns: (transfer full): a new #GstAdapter
 243  */
 244 GstAdapter *
 245 gst_adapter_new (void)
 246 {
 247   return g_object_new (GST_TYPE_ADAPTER, NULL);
 248 }
 249 
 250 /**
 251  * gst_adapter_clear:
 252  * @adapter: a #GstAdapter
 253  *
 254  * Removes all buffers from @adapter.
 255  */
 256 void
 257 gst_adapter_clear (GstAdapter * adapter)
 258 {
<a name="6" id="anc6"></a><span class="line-added"> 259   GstMiniObject *obj;</span>
 260   g_return_if_fail (GST_IS_ADAPTER (adapter));
 261 
 262   if (adapter-&gt;info.memory)
 263     gst_adapter_unmap (adapter);
 264 
<a name="7" id="anc7"></a><span class="line-modified"> 265   while ((obj = gst_queue_array_pop_head (adapter-&gt;bufqueue)))</span>
<span class="line-modified"> 266     gst_mini_object_unref (obj);</span>
<span class="line-modified"> 267 </span>

 268   adapter-&gt;count = 0;
 269   adapter-&gt;size = 0;
 270   adapter-&gt;skip = 0;
 271   adapter-&gt;assembled_len = 0;
 272   adapter-&gt;pts = GST_CLOCK_TIME_NONE;
 273   adapter-&gt;pts_distance = 0;
 274   adapter-&gt;dts = GST_CLOCK_TIME_NONE;
 275   adapter-&gt;dts_distance = 0;
 276   adapter-&gt;offset = GST_BUFFER_OFFSET_NONE;
 277   adapter-&gt;offset_distance = 0;
 278   adapter-&gt;pts_at_discont = GST_CLOCK_TIME_NONE;
 279   adapter-&gt;dts_at_discont = GST_CLOCK_TIME_NONE;
 280   adapter-&gt;offset_at_discont = GST_BUFFER_OFFSET_NONE;
 281   adapter-&gt;distance_from_discont = 0;
 282   adapter-&gt;scan_offset = 0;
<a name="8" id="anc8"></a><span class="line-modified"> 283   adapter-&gt;scan_entry_idx = G_MAXUINT;</span>
 284 }
 285 
 286 static inline void
 287 update_timestamps_and_offset (GstAdapter * adapter, GstBuffer * buf)
 288 {
 289   GstClockTime pts, dts;
 290   guint64 offset;
 291 
 292   pts = GST_BUFFER_PTS (buf);
 293   if (GST_CLOCK_TIME_IS_VALID (pts)) {
 294     GST_LOG_OBJECT (adapter, &quot;new pts %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (pts));
 295     adapter-&gt;pts = pts;
 296     adapter-&gt;pts_distance = 0;
 297   }
 298   dts = GST_BUFFER_DTS (buf);
 299   if (GST_CLOCK_TIME_IS_VALID (dts)) {
 300     GST_LOG_OBJECT (adapter, &quot;new dts %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (dts));
 301     adapter-&gt;dts = dts;
 302     adapter-&gt;dts_distance = 0;
 303   }
 304   offset = GST_BUFFER_OFFSET (buf);
 305   if (offset != GST_BUFFER_OFFSET_NONE) {
 306     GST_LOG_OBJECT (adapter, &quot;new offset %&quot; G_GUINT64_FORMAT, offset);
 307     adapter-&gt;offset = offset;
 308     adapter-&gt;offset_distance = 0;
 309   }
 310 
 311   if (GST_BUFFER_IS_DISCONT (buf)) {
 312     /* Take values as-is (might be NONE) */
 313     adapter-&gt;pts_at_discont = pts;
 314     adapter-&gt;dts_at_discont = dts;
 315     adapter-&gt;offset_at_discont = offset;
 316     adapter-&gt;distance_from_discont = 0;
 317   }
 318 }
 319 
 320 /* copy data into @dest, skipping @skip bytes from the head buffers */
 321 static void
 322 copy_into_unchecked (GstAdapter * adapter, guint8 * dest, gsize skip,
 323     gsize size)
 324 {
<a name="9" id="anc9"></a>
 325   GstBuffer *buf;
 326   gsize bsize, csize;
<a name="10" id="anc10"></a><span class="line-added"> 327   guint idx = 0;</span>
 328 
 329   /* first step, do skipping */
 330   /* we might well be copying where we were scanning */
<a name="11" id="anc11"></a><span class="line-modified"> 331   if (adapter-&gt;scan_entry_idx != G_MAXUINT &amp;&amp; (adapter-&gt;scan_offset &lt;= skip)) {</span>
<span class="line-modified"> 332     idx = adapter-&gt;scan_entry_idx;</span>
 333     skip -= adapter-&gt;scan_offset;
 334   } else {
<a name="12" id="anc12"></a><span class="line-modified"> 335     idx = 0;</span>
 336   }
<a name="13" id="anc13"></a><span class="line-modified"> 337   buf = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>
 338   bsize = gst_buffer_get_size (buf);
 339   while (G_UNLIKELY (skip &gt;= bsize)) {
 340     skip -= bsize;
<a name="14" id="anc14"></a><span class="line-modified"> 341     buf = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>

 342     bsize = gst_buffer_get_size (buf);
 343   }
 344   /* copy partial buffer */
 345   csize = MIN (bsize - skip, size);
 346   GST_DEBUG (&quot;bsize %&quot; G_GSIZE_FORMAT &quot;, skip %&quot; G_GSIZE_FORMAT &quot;, csize %&quot;
 347       G_GSIZE_FORMAT, bsize, skip, csize);
 348   GST_CAT_LOG_OBJECT (GST_CAT_PERFORMANCE, adapter, &quot;extract %&quot; G_GSIZE_FORMAT
 349       &quot; bytes&quot;, csize);
 350   gst_buffer_extract (buf, skip, dest, csize);
 351   size -= csize;
 352   dest += csize;
 353 
 354   /* second step, copy remainder */
 355   while (size &gt; 0) {
<a name="15" id="anc15"></a><span class="line-modified"> 356     buf = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>

 357     bsize = gst_buffer_get_size (buf);
 358     if (G_LIKELY (bsize &gt; 0)) {
 359       csize = MIN (bsize, size);
 360       GST_CAT_LOG_OBJECT (GST_CAT_PERFORMANCE, adapter,
 361           &quot;extract %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, csize);
 362       gst_buffer_extract (buf, 0, dest, csize);
 363       size -= csize;
 364       dest += csize;
 365     }
 366   }
 367 }
 368 
 369 /**
 370  * gst_adapter_push:
 371  * @adapter: a #GstAdapter
 372  * @buf: (transfer full): a #GstBuffer to add to queue in the adapter
 373  *
 374  * Adds the data from @buf to the data stored inside @adapter and takes
 375  * ownership of the buffer.
 376  */
 377 void
 378 gst_adapter_push (GstAdapter * adapter, GstBuffer * buf)
 379 {
 380   gsize size;
 381 
 382   g_return_if_fail (GST_IS_ADAPTER (adapter));
 383   g_return_if_fail (GST_IS_BUFFER (buf));
 384 
 385   size = gst_buffer_get_size (buf);
 386   adapter-&gt;size += size;
 387 
 388   /* Note: merging buffers at this point is premature. */
<a name="16" id="anc16"></a><span class="line-modified"> 389   if (gst_queue_array_is_empty (adapter-&gt;bufqueue)) {</span>
 390     GST_LOG_OBJECT (adapter, &quot;pushing %p first %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
 391         buf, size);
<a name="17" id="anc17"></a><span class="line-modified"> 392     gst_queue_array_push_tail (adapter-&gt;bufqueue, buf);</span>
 393     update_timestamps_and_offset (adapter, buf);
 394   } else {
 395     /* Otherwise append to the end, and advance our end pointer */
 396     GST_LOG_OBJECT (adapter, &quot;pushing %p %&quot; G_GSIZE_FORMAT &quot; bytes at end, &quot;
 397         &quot;size now %&quot; G_GSIZE_FORMAT, buf, size, adapter-&gt;size);
<a name="18" id="anc18"></a><span class="line-modified"> 398     gst_queue_array_push_tail (adapter-&gt;bufqueue, buf);</span>

 399   }
 400   ++adapter-&gt;count;
 401 }
 402 
 403 #if 0
 404 /* Internal method only. Tries to merge buffers at the head of the queue
 405  * to form a single larger buffer of size &#39;size&#39;.
 406  *
 407  * Returns %TRUE if it managed to merge anything.
 408  */
 409 static gboolean
 410 gst_adapter_try_to_merge_up (GstAdapter * adapter, gsize size)
 411 {
 412   GstBuffer *cur, *head;
 413   GSList *g;
 414   gboolean ret = FALSE;
 415   gsize hsize;
 416 
 417   g = adapter-&gt;buflist;
 418   if (g == NULL)
 419     return FALSE;
 420 
 421   head = g-&gt;data;
 422 
 423   hsize = gst_buffer_get_size (head);
 424 
 425   /* Remove skipped part from the buffer (otherwise the buffer might grow indefinitely) */
 426   head = gst_buffer_make_writable (head);
 427   gst_buffer_resize (head, adapter-&gt;skip, hsize - adapter-&gt;skip);
 428   hsize -= adapter-&gt;skip;
 429   adapter-&gt;skip = 0;
 430   g-&gt;data = head;
 431 
 432   g = g_slist_next (g);
 433 
 434   while (g != NULL &amp;&amp; hsize &lt; size) {
 435     cur = g-&gt;data;
 436     /* Merge the head buffer and the next in line */
 437     GST_LOG_OBJECT (adapter, &quot;Merging buffers of size %&quot; G_GSIZE_FORMAT &quot; &amp; %&quot;
 438         G_GSIZE_FORMAT &quot; in search of target %&quot; G_GSIZE_FORMAT,
 439         hsize, gst_buffer_get_size (cur), size);
 440 
 441     head = gst_buffer_append (head, cur);
 442     hsize = gst_buffer_get_size (head);
 443     ret = TRUE;
 444 
 445     /* Delete the front list item, and store our new buffer in the 2nd list
 446      * item */
 447     adapter-&gt;buflist = g_slist_delete_link (adapter-&gt;buflist, adapter-&gt;buflist);
 448     g-&gt;data = head;
 449 
 450     /* invalidate scan position */
 451     adapter-&gt;scan_offset = 0;
 452     adapter-&gt;scan_entry = NULL;
 453 
 454     g = g_slist_next (g);
 455   }
 456 
 457   return ret;
 458 }
 459 #endif
 460 
 461 /**
 462  * gst_adapter_map:
 463  * @adapter: a #GstAdapter
 464  * @size: the number of bytes to map/peek
 465  *
 466  * Gets the first @size bytes stored in the @adapter. The returned pointer is
 467  * valid until the next function is called on the adapter.
 468  *
 469  * Note that setting the returned pointer as the data of a #GstBuffer is
 470  * incorrect for general-purpose plugins. The reason is that if a downstream
 471  * element stores the buffer so that it has access to it outside of the bounds
 472  * of its chain function, the buffer will have an invalid data pointer after
 473  * your element flushes the bytes. In that case you should use
 474  * gst_adapter_take(), which returns a freshly-allocated buffer that you can set
 475  * as #GstBuffer memory or the potentially more performant
 476  * gst_adapter_take_buffer().
 477  *
 478  * Returns %NULL if @size bytes are not available.
 479  *
 480  * Returns: (transfer none) (array length=size) (element-type guint8) (nullable):
 481  *     a pointer to the first @size bytes of data, or %NULL
 482  */
 483 gconstpointer
 484 gst_adapter_map (GstAdapter * adapter, gsize size)
 485 {
 486   GstBuffer *cur;
 487   gsize skip, csize;
 488   gsize toreuse, tocopy;
 489   guint8 *data;
 490 
 491   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
 492   g_return_val_if_fail (size &gt; 0, NULL);
 493 
 494   if (adapter-&gt;info.memory)
 495     gst_adapter_unmap (adapter);
 496 
 497   /* we don&#39;t have enough data, return NULL. This is unlikely
 498    * as one usually does an _available() first instead of peeking a
 499    * random size. */
 500   if (G_UNLIKELY (size &gt; adapter-&gt;size))
 501     return NULL;
 502 
 503   /* we have enough assembled data, return it */
 504   if (adapter-&gt;assembled_len &gt;= size)
 505     return adapter-&gt;assembled_data;
 506 
 507 #if 0
 508   do {
 509 #endif
<a name="19" id="anc19"></a><span class="line-modified"> 510     cur = gst_queue_array_peek_head (adapter-&gt;bufqueue);</span>
 511     skip = adapter-&gt;skip;
 512 
 513     csize = gst_buffer_get_size (cur);
 514     if (csize &gt;= size + skip) {
 515       if (!gst_buffer_map (cur, &amp;adapter-&gt;info, GST_MAP_READ))
 516         return FALSE;
 517 
 518       return (guint8 *) adapter-&gt;info.data + skip;
 519     }
 520     /* We may be able to efficiently merge buffers in our pool to
 521      * gather a big enough chunk to return it from the head buffer directly */
 522 #if 0
 523   } while (gst_adapter_try_to_merge_up (adapter, size));
 524 #endif
 525 
 526   /* see how much data we can reuse from the assembled memory and how much
 527    * we need to copy */
 528   toreuse = adapter-&gt;assembled_len;
 529   tocopy = size - toreuse;
 530 
 531   /* Gonna need to copy stuff out */
 532   if (G_UNLIKELY (adapter-&gt;assembled_size &lt; size)) {
 533     adapter-&gt;assembled_size = (size / DEFAULT_SIZE + 1) * DEFAULT_SIZE;
 534     GST_DEBUG_OBJECT (adapter, &quot;resizing internal buffer to %&quot; G_GSIZE_FORMAT,
 535         adapter-&gt;assembled_size);
 536     if (toreuse == 0) {
 537       GST_CAT_DEBUG (GST_CAT_PERFORMANCE, &quot;alloc new buffer&quot;);
 538       /* no g_realloc to avoid a memcpy that is not desired here since we are
 539        * not going to reuse any data here */
 540       g_free (adapter-&gt;assembled_data);
 541       adapter-&gt;assembled_data = g_malloc (adapter-&gt;assembled_size);
 542     } else {
 543       /* we are going to reuse all data, realloc then */
 544       GST_CAT_DEBUG (GST_CAT_PERFORMANCE, &quot;reusing %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
 545           toreuse);
 546       adapter-&gt;assembled_data =
 547           g_realloc (adapter-&gt;assembled_data, adapter-&gt;assembled_size);
 548     }
 549   }
 550   GST_CAT_DEBUG (GST_CAT_PERFORMANCE, &quot;copy remaining %&quot; G_GSIZE_FORMAT
 551       &quot; bytes from adapter&quot;, tocopy);
 552   data = adapter-&gt;assembled_data;
 553   copy_into_unchecked (adapter, data + toreuse, skip + toreuse, tocopy);
 554   adapter-&gt;assembled_len = size;
 555 
 556   return adapter-&gt;assembled_data;
 557 }
 558 
 559 /**
 560  * gst_adapter_unmap:
 561  * @adapter: a #GstAdapter
 562  *
 563  * Releases the memory obtained with the last gst_adapter_map().
 564  */
 565 void
 566 gst_adapter_unmap (GstAdapter * adapter)
 567 {
 568   g_return_if_fail (GST_IS_ADAPTER (adapter));
 569 
 570   if (adapter-&gt;info.memory) {
<a name="20" id="anc20"></a><span class="line-modified"> 571     GstBuffer *cur = gst_queue_array_peek_head (adapter-&gt;bufqueue);</span>
 572     GST_LOG_OBJECT (adapter, &quot;unmap memory buffer %p&quot;, cur);
 573     gst_buffer_unmap (cur, &amp;adapter-&gt;info);
 574     adapter-&gt;info.memory = NULL;
 575   }
 576 }
 577 
 578 /**
 579  * gst_adapter_copy: (skip)
 580  * @adapter: a #GstAdapter
 581  * @dest: (out caller-allocates) (array length=size) (element-type guint8):
 582  *     the memory to copy into
 583  * @offset: the bytes offset in the adapter to start from
 584  * @size: the number of bytes to copy
 585  *
 586  * Copies @size bytes of data starting at @offset out of the buffers
 587  * contained in #GstAdapter into an array @dest provided by the caller.
 588  *
 589  * The array @dest should be large enough to contain @size bytes.
 590  * The user should check that the adapter has (@offset + @size) bytes
 591  * available before calling this function.
 592  */
 593 void
 594 gst_adapter_copy (GstAdapter * adapter, gpointer dest, gsize offset, gsize size)
 595 {
 596   g_return_if_fail (GST_IS_ADAPTER (adapter));
 597   g_return_if_fail (size &gt; 0);
 598   g_return_if_fail (offset + size &lt;= adapter-&gt;size);
 599 
 600   copy_into_unchecked (adapter, dest, offset + adapter-&gt;skip, size);
 601 }
 602 
 603 /**
 604  * gst_adapter_copy_bytes: (rename-to gst_adapter_copy)
 605  * @adapter: a #GstAdapter
 606  * @offset: the bytes offset in the adapter to start from
 607  * @size: the number of bytes to copy
 608  *
 609  * Similar to gst_adapter_copy, but more suitable for language bindings. @size
 610  * bytes of data starting at @offset will be copied out of the buffers contained
 611  * in @adapter and into a new #GBytes structure which is returned. Depending on
 612  * the value of the @size argument an empty #GBytes structure may be returned.
 613  *
 614  * Returns: (transfer full): A new #GBytes structure containing the copied data.
 615  *
 616  * Since: 1.4
 617  */
 618 GBytes *
 619 gst_adapter_copy_bytes (GstAdapter * adapter, gsize offset, gsize size)
 620 {
 621   gpointer data;
 622   data = g_malloc (size);
 623   gst_adapter_copy (adapter, data, offset, size);
 624   return g_bytes_new_take (data, size);
 625 }
 626 
 627 /*Flushes the first @flush bytes in the @adapter*/
 628 static void
 629 gst_adapter_flush_unchecked (GstAdapter * adapter, gsize flush)
 630 {
 631   GstBuffer *cur;
 632   gsize size;
<a name="21" id="anc21"></a>
 633 
 634   GST_LOG_OBJECT (adapter, &quot;flushing %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, flush);
 635 
 636   if (adapter-&gt;info.memory)
 637     gst_adapter_unmap (adapter);
 638 
 639   /* clear state */
 640   adapter-&gt;size -= flush;
 641   adapter-&gt;assembled_len = 0;
 642 
 643   /* take skip into account */
 644   flush += adapter-&gt;skip;
 645   /* distance is always at least the amount of skipped bytes */
 646   adapter-&gt;pts_distance -= adapter-&gt;skip;
 647   adapter-&gt;dts_distance -= adapter-&gt;skip;
 648   adapter-&gt;offset_distance -= adapter-&gt;skip;
 649   adapter-&gt;distance_from_discont -= adapter-&gt;skip;
 650 
<a name="22" id="anc22"></a><span class="line-modified"> 651   cur = gst_queue_array_peek_head (adapter-&gt;bufqueue);</span>

 652   size = gst_buffer_get_size (cur);
 653   while (flush &gt;= size) {
 654     /* can skip whole buffer */
 655     GST_LOG_OBJECT (adapter, &quot;flushing out head buffer&quot;);
 656     adapter-&gt;pts_distance += size;
 657     adapter-&gt;dts_distance += size;
 658     adapter-&gt;offset_distance += size;
 659     adapter-&gt;distance_from_discont += size;
 660     flush -= size;
 661 
<a name="23" id="anc23"></a>

 662     --adapter-&gt;count;
 663 
<a name="24" id="anc24"></a><span class="line-modified"> 664     cur = NULL;</span>
<span class="line-added"> 665     gst_buffer_unref (gst_queue_array_pop_head (adapter-&gt;bufqueue));</span>
<span class="line-added"> 666 </span>
<span class="line-added"> 667     if (gst_queue_array_is_empty (adapter-&gt;bufqueue)) {</span>
 668       GST_LOG_OBJECT (adapter, &quot;adapter empty now&quot;);
<a name="25" id="anc25"></a>
 669       break;
 670     }
 671     /* there is a new head buffer, update the timestamps */
<a name="26" id="anc26"></a><span class="line-modified"> 672     cur = gst_queue_array_peek_head (adapter-&gt;bufqueue);</span>
 673     update_timestamps_and_offset (adapter, cur);
 674     size = gst_buffer_get_size (cur);
 675   }
<a name="27" id="anc27"></a>
 676   /* account for the remaining bytes */
 677   adapter-&gt;skip = flush;
 678   adapter-&gt;pts_distance += flush;
 679   adapter-&gt;dts_distance += flush;
 680   adapter-&gt;offset_distance += flush;
 681   adapter-&gt;distance_from_discont += flush;
 682   /* invalidate scan position */
 683   adapter-&gt;scan_offset = 0;
<a name="28" id="anc28"></a><span class="line-modified"> 684   adapter-&gt;scan_entry_idx = G_MAXUINT;</span>
 685 }
 686 
 687 /**
 688  * gst_adapter_flush:
 689  * @adapter: a #GstAdapter
 690  * @flush: the number of bytes to flush
 691  *
 692  * Flushes the first @flush bytes in the @adapter. The caller must ensure that
 693  * at least this many bytes are available.
 694  *
 695  * See also: gst_adapter_map(), gst_adapter_unmap()
 696  */
 697 void
 698 gst_adapter_flush (GstAdapter * adapter, gsize flush)
 699 {
 700   g_return_if_fail (GST_IS_ADAPTER (adapter));
 701   g_return_if_fail (flush &lt;= adapter-&gt;size);
 702 
 703   /* flushing out 0 bytes will do nothing */
 704   if (G_UNLIKELY (flush == 0))
 705     return;
 706 
 707   gst_adapter_flush_unchecked (adapter, flush);
 708 }
 709 
 710 /* internal function, nbytes should be flushed if needed after calling this function */
 711 static guint8 *
 712 gst_adapter_get_internal (GstAdapter * adapter, gsize nbytes)
 713 {
 714   guint8 *data;
 715   gsize toreuse, tocopy;
 716 
 717   /* see how much data we can reuse from the assembled memory and how much
 718    * we need to copy */
 719   toreuse = MIN (nbytes, adapter-&gt;assembled_len);
 720   tocopy = nbytes - toreuse;
 721 
 722   /* find memory to return */
 723   if (adapter-&gt;assembled_size &gt;= nbytes &amp;&amp; toreuse &gt; 0) {
 724     /* we reuse already allocated memory but only when we&#39;re going to reuse
 725      * something from it because else we are worse than the malloc and copy
 726      * case below */
 727     GST_LOG_OBJECT (adapter, &quot;reusing %&quot; G_GSIZE_FORMAT &quot; bytes of assembled&quot;
 728         &quot; data&quot;, toreuse);
 729     /* we have enough free space in the assembled array */
 730     data = adapter-&gt;assembled_data;
 731     /* flush after this function should set the assembled_size to 0 */
 732     adapter-&gt;assembled_data = g_malloc (adapter-&gt;assembled_size);
 733   } else {
 734     GST_LOG_OBJECT (adapter, &quot;allocating %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, nbytes);
 735     /* not enough bytes in the assembled array, just allocate new space */
 736     data = g_malloc (nbytes);
 737     /* reuse what we can from the already assembled data */
 738     if (toreuse) {
 739       GST_LOG_OBJECT (adapter, &quot;reusing %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, toreuse);
 740       GST_CAT_LOG_OBJECT (GST_CAT_PERFORMANCE, adapter,
 741           &quot;memcpy %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, toreuse);
 742       memcpy (data, adapter-&gt;assembled_data, toreuse);
 743     }
 744   }
 745   if (tocopy) {
 746     /* copy the remaining data */
 747     copy_into_unchecked (adapter, toreuse + data, toreuse + adapter-&gt;skip,
 748         tocopy);
 749   }
 750   return data;
 751 }
 752 
 753 /**
 754  * gst_adapter_take:
 755  * @adapter: a #GstAdapter
 756  * @nbytes: the number of bytes to take
 757  *
 758  * Returns a freshly allocated buffer containing the first @nbytes bytes of the
 759  * @adapter. The returned bytes will be flushed from the adapter.
 760  *
 761  * Caller owns returned value. g_free after usage.
 762  *
 763  * Free-function: g_free
 764  *
 765  * Returns: (transfer full) (array length=nbytes) (element-type guint8) (nullable):
 766  *     oven-fresh hot data, or %NULL if @nbytes bytes are not available
 767  */
 768 gpointer
 769 gst_adapter_take (GstAdapter * adapter, gsize nbytes)
 770 {
 771   gpointer data;
 772 
 773   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
 774   g_return_val_if_fail (nbytes &gt; 0, NULL);
 775 
 776   /* we don&#39;t have enough data, return NULL. This is unlikely
 777    * as one usually does an _available() first instead of peeking a
 778    * random size. */
 779   if (G_UNLIKELY (nbytes &gt; adapter-&gt;size))
 780     return NULL;
 781 
 782   data = gst_adapter_get_internal (adapter, nbytes);
 783 
 784   gst_adapter_flush_unchecked (adapter, nbytes);
 785 
 786   return data;
 787 }
 788 
 789 /**
 790  * gst_adapter_get_buffer_fast:
 791  * @adapter:  a #GstAdapter
 792  * @nbytes: the number of bytes to get
 793  *
 794  * Returns a #GstBuffer containing the first @nbytes of the @adapter, but
 795  * does not flush them from the adapter. See gst_adapter_take_buffer_fast()
 796  * for details.
 797  *
 798  * Caller owns a reference to the returned buffer. gst_buffer_unref() after
 799  * usage.
 800  *
 801  * Free-function: gst_buffer_unref
 802  *
 803  * Returns: (transfer full) (nullable): a #GstBuffer containing the first
 804  *     @nbytes of the adapter, or %NULL if @nbytes bytes are not available.
 805  *     gst_buffer_unref() when no longer needed.
 806  *
 807  * Since: 1.6
 808  */
 809 GstBuffer *
 810 gst_adapter_get_buffer_fast (GstAdapter * adapter, gsize nbytes)
 811 {
 812   GstBuffer *buffer = NULL;
 813   GstBuffer *cur;
<a name="29" id="anc29"></a>
 814   gsize skip;
 815   gsize left = nbytes;
<a name="30" id="anc30"></a><span class="line-added"> 816   guint idx, len;</span>
 817 
 818   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
 819   g_return_val_if_fail (nbytes &gt; 0, NULL);
 820 
 821   GST_LOG_OBJECT (adapter, &quot;getting buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
 822       nbytes);
 823 
 824   /* we don&#39;t have enough data, return NULL. This is unlikely
 825    * as one usually does an _available() first instead of grabbing a
 826    * random size. */
 827   if (G_UNLIKELY (nbytes &gt; adapter-&gt;size))
 828     return NULL;
 829 
 830   skip = adapter-&gt;skip;
<a name="31" id="anc31"></a><span class="line-modified"> 831   cur = gst_queue_array_peek_head (adapter-&gt;bufqueue);</span>
 832 
 833   if (skip == 0 &amp;&amp; gst_buffer_get_size (cur) == nbytes) {
 834     GST_LOG_OBJECT (adapter, &quot;providing buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
 835         &quot; as head buffer&quot;, nbytes);
 836     buffer = gst_buffer_ref (cur);
 837     goto done;
 838   }
 839 
<a name="32" id="anc32"></a><span class="line-modified"> 840   len = gst_queue_array_get_length (adapter-&gt;bufqueue);</span>
<span class="line-added"> 841 </span>
<span class="line-added"> 842   for (idx = 0; idx &lt; len &amp;&amp; left &gt; 0; idx++) {</span>
 843     gsize size, cur_size;
 844 
<a name="33" id="anc33"></a><span class="line-modified"> 845     cur = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx);</span>
 846     cur_size = gst_buffer_get_size (cur);
 847     size = MIN (cur_size - skip, left);
 848 
 849     GST_LOG_OBJECT (adapter, &quot;appending %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
 850         &quot; via region copy&quot;, size);
 851     if (buffer)
 852       gst_buffer_copy_into (buffer, cur,
 853           GST_BUFFER_COPY_MEMORY | GST_BUFFER_COPY_META, skip, size);
 854     else
 855       buffer = gst_buffer_copy_region (cur, GST_BUFFER_COPY_ALL, skip, size);
 856     skip = 0;
 857     left -= size;
 858   }
 859 
 860 done:
 861 
 862   return buffer;
 863 }
 864 
 865 /**
 866  * gst_adapter_take_buffer_fast:
 867  * @adapter:  a #GstAdapter
 868  * @nbytes: the number of bytes to take
 869  *
 870  * Returns a #GstBuffer containing the first @nbytes of the @adapter.
 871  * The returned bytes will be flushed from the adapter.  This function
 872  * is potentially more performant than gst_adapter_take_buffer() since
 873  * it can reuse the memory in pushed buffers by subbuffering or
 874  * merging. Unlike gst_adapter_take_buffer(), the returned buffer may
 875  * be composed of multiple non-contiguous #GstMemory objects, no
 876  * copies are made.
 877  *
 878  * Note that no assumptions should be made as to whether certain buffer
 879  * flags such as the DISCONT flag are set on the returned buffer, or not.
 880  * The caller needs to explicitly set or unset flags that should be set or
 881  * unset.
 882  *
 883  * This will also copy over all GstMeta of the input buffers except
 884  * for meta with the %GST_META_FLAG_POOLED flag or with the &quot;memory&quot; tag.
 885  *
 886  * This function can return buffer up to the return value of
 887  * gst_adapter_available() without making copies if possible.
 888  *
 889  * Caller owns a reference to the returned buffer. gst_buffer_unref() after
 890  * usage.
 891  *
 892  * Free-function: gst_buffer_unref
 893  *
 894  * Returns: (transfer full) (nullable): a #GstBuffer containing the first
 895  *     @nbytes of the adapter, or %NULL if @nbytes bytes are not available.
 896  *     gst_buffer_unref() when no longer needed.
 897  *
 898  * Since: 1.2
 899  */
 900 GstBuffer *
 901 gst_adapter_take_buffer_fast (GstAdapter * adapter, gsize nbytes)
 902 {
 903   GstBuffer *buffer;
 904 
 905   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
 906   g_return_val_if_fail (nbytes &gt; 0, NULL);
 907 
 908   buffer = gst_adapter_get_buffer_fast (adapter, nbytes);
 909   if (buffer)
 910     gst_adapter_flush_unchecked (adapter, nbytes);
 911 
 912   return buffer;
 913 }
 914 
 915 static gboolean
 916 foreach_metadata (GstBuffer * inbuf, GstMeta ** meta, gpointer user_data)
 917 {
 918   GstBuffer *outbuf = user_data;
 919   const GstMetaInfo *info = (*meta)-&gt;info;
 920   gboolean do_copy = FALSE;
 921 
 922   if (gst_meta_api_type_has_tag (info-&gt;api, _gst_meta_tag_memory)) {
 923     /* never call the transform_meta with memory specific metadata */
 924     GST_DEBUG (&quot;not copying memory specific metadata %s&quot;,
 925         g_type_name (info-&gt;api));
 926     do_copy = FALSE;
 927   } else {
 928     do_copy = TRUE;
 929     GST_DEBUG (&quot;copying metadata %s&quot;, g_type_name (info-&gt;api));
 930   }
 931 
 932   if (do_copy &amp;&amp; info-&gt;transform_func) {
 933     GstMetaTransformCopy copy_data = { FALSE, 0, -1 };
 934     GST_DEBUG (&quot;copy metadata %s&quot;, g_type_name (info-&gt;api));
 935     /* simply copy then */
 936     info-&gt;transform_func (outbuf, *meta, inbuf,
 937         _gst_meta_transform_copy, &amp;copy_data);
 938   }
 939   return TRUE;
 940 }
 941 
 942 /**
 943  * gst_adapter_get_buffer:
 944  * @adapter: a #GstAdapter
 945  * @nbytes: the number of bytes to get
 946  *
 947  * Returns a #GstBuffer containing the first @nbytes of the @adapter, but
 948  * does not flush them from the adapter. See gst_adapter_take_buffer()
 949  * for details.
 950  *
 951  * Caller owns a reference to the returned buffer. gst_buffer_unref() after
 952  * usage.
 953  *
 954  * Free-function: gst_buffer_unref
 955  *
 956  * Returns: (transfer full) (nullable): a #GstBuffer containing the first
 957  *     @nbytes of the adapter, or %NULL if @nbytes bytes are not available.
 958  *     gst_buffer_unref() when no longer needed.
 959  *
 960  * Since: 1.6
 961  */
 962 GstBuffer *
 963 gst_adapter_get_buffer (GstAdapter * adapter, gsize nbytes)
 964 {
 965   GstBuffer *buffer;
 966   GstBuffer *cur;
 967   gsize hsize, skip;
 968   guint8 *data;
 969 
 970   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
 971   g_return_val_if_fail (nbytes &gt; 0, NULL);
 972 
 973   GST_LOG_OBJECT (adapter, &quot;getting buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
 974       nbytes);
 975 
 976   /* we don&#39;t have enough data, return NULL. This is unlikely
 977    * as one usually does an _available() first instead of grabbing a
 978    * random size. */
 979   if (G_UNLIKELY (nbytes &gt; adapter-&gt;size))
 980     return NULL;
 981 
<a name="34" id="anc34"></a><span class="line-modified"> 982   cur = gst_queue_array_peek_head (adapter-&gt;bufqueue);</span>
 983   skip = adapter-&gt;skip;
 984   hsize = gst_buffer_get_size (cur);
 985 
 986   /* our head buffer has enough data left, return it */
 987   if (skip == 0 &amp;&amp; hsize == nbytes) {
 988     GST_LOG_OBJECT (adapter, &quot;providing buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
 989         &quot; as head buffer&quot;, nbytes);
 990     buffer = gst_buffer_ref (cur);
 991     goto done;
 992   } else if (hsize &gt;= nbytes + skip) {
 993     GST_LOG_OBJECT (adapter, &quot;providing buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
 994         &quot; via region copy&quot;, nbytes);
 995     buffer = gst_buffer_copy_region (cur, GST_BUFFER_COPY_ALL, skip, nbytes);
 996     goto done;
 997   }
 998 #if 0
 999   if (gst_adapter_try_to_merge_up (adapter, nbytes)) {
1000     /* Merged something, let&#39;s try again for sub-buffering */
1001     cur = adapter-&gt;buflist-&gt;data;
1002     skip = adapter-&gt;skip;
1003     if (gst_buffer_get_size (cur) &gt;= nbytes + skip) {
1004       GST_LOG_OBJECT (adapter, &quot;providing buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
1005           &quot; via sub-buffer&quot;, nbytes);
1006       buffer = gst_buffer_copy_region (cur, GST_BUFFER_COPY_ALL, skip, nbytes);
1007       goto done;
1008     }
1009   }
1010 #endif
1011 
1012   data = gst_adapter_get_internal (adapter, nbytes);
1013 
1014   buffer = gst_buffer_new_wrapped (data, nbytes);
1015 
1016   {
<a name="35" id="anc35"></a><span class="line-modified">1017     guint idx, len;</span>
1018     GstBuffer *cur;
1019     gsize read_offset = 0;
1020 
<a name="36" id="anc36"></a><span class="line-modified">1021     idx = 0;</span>
<span class="line-modified">1022     len = gst_queue_array_get_length (adapter-&gt;bufqueue);</span>
<span class="line-modified">1023 </span>
<span class="line-added">1024     while (idx &lt; len &amp;&amp; read_offset &lt; nbytes + adapter-&gt;skip) {</span>
<span class="line-added">1025       cur = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx);</span>
1026 
1027       gst_buffer_foreach_meta (cur, foreach_metadata, buffer);
1028       read_offset += gst_buffer_get_size (cur);
1029 
<a name="37" id="anc37"></a><span class="line-modified">1030       idx++;</span>
1031     }
1032   }
1033 
1034 done:
1035 
1036   return buffer;
1037 }
1038 
1039 /**
1040  * gst_adapter_take_buffer:
1041  * @adapter: a #GstAdapter
1042  * @nbytes: the number of bytes to take
1043  *
1044  * Returns a #GstBuffer containing the first @nbytes bytes of the
1045  * @adapter. The returned bytes will be flushed from the adapter.
1046  * This function is potentially more performant than
1047  * gst_adapter_take() since it can reuse the memory in pushed buffers
1048  * by subbuffering or merging. This function will always return a
1049  * buffer with a single memory region.
1050  *
1051  * Note that no assumptions should be made as to whether certain buffer
1052  * flags such as the DISCONT flag are set on the returned buffer, or not.
1053  * The caller needs to explicitly set or unset flags that should be set or
1054  * unset.
1055  *
1056  * Since 1.6 this will also copy over all GstMeta of the input buffers except
1057  * for meta with the %GST_META_FLAG_POOLED flag or with the &quot;memory&quot; tag.
1058  *
1059  * Caller owns a reference to the returned buffer. gst_buffer_unref() after
1060  * usage.
1061  *
1062  * Free-function: gst_buffer_unref
1063  *
1064  * Returns: (transfer full) (nullable): a #GstBuffer containing the first
1065  *     @nbytes of the adapter, or %NULL if @nbytes bytes are not available.
1066  *     gst_buffer_unref() when no longer needed.
1067  */
1068 GstBuffer *
1069 gst_adapter_take_buffer (GstAdapter * adapter, gsize nbytes)
1070 {
1071   GstBuffer *buffer;
1072 
1073   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
1074   g_return_val_if_fail (nbytes &gt; 0, NULL);
1075 
1076   buffer = gst_adapter_get_buffer (adapter, nbytes);
1077   if (buffer)
1078     gst_adapter_flush_unchecked (adapter, nbytes);
1079 
1080   return buffer;
1081 }
1082 
1083 /**
1084  * gst_adapter_take_list:
1085  * @adapter: a #GstAdapter
1086  * @nbytes: the number of bytes to take
1087  *
1088  * Returns a #GList of buffers containing the first @nbytes bytes of the
1089  * @adapter. The returned bytes will be flushed from the adapter.
1090  * When the caller can deal with individual buffers, this function is more
1091  * performant because no memory should be copied.
1092  *
1093  * Caller owns returned list and contained buffers. gst_buffer_unref() each
1094  * buffer in the list before freeing the list after usage.
1095  *
1096  * Returns: (element-type Gst.Buffer) (transfer full) (nullable): a #GList of
1097  *     buffers containing the first @nbytes of the adapter, or %NULL if @nbytes
1098  *     bytes are not available
1099  */
1100 GList *
1101 gst_adapter_take_list (GstAdapter * adapter, gsize nbytes)
1102 {
1103   GQueue queue = G_QUEUE_INIT;
1104   GstBuffer *cur;
1105   gsize hsize, skip, cur_size;
1106 
1107   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
1108   g_return_val_if_fail (nbytes &lt;= adapter-&gt;size, NULL);
1109 
1110   GST_LOG_OBJECT (adapter, &quot;taking %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, nbytes);
1111 
1112   while (nbytes &gt; 0) {
<a name="38" id="anc38"></a><span class="line-modified">1113     cur = gst_queue_array_peek_head (adapter-&gt;bufqueue);</span>
1114     skip = adapter-&gt;skip;
1115     cur_size = gst_buffer_get_size (cur);
1116     hsize = MIN (nbytes, cur_size - skip);
1117 
1118     cur = gst_adapter_take_buffer (adapter, hsize);
1119 
1120     g_queue_push_tail (&amp;queue, cur);
1121 
1122     nbytes -= hsize;
1123   }
1124   return queue.head;
1125 }
1126 
1127 /**
1128  * gst_adapter_get_list:
1129  * @adapter: a #GstAdapter
1130  * @nbytes: the number of bytes to get
1131  *
1132  * Returns a #GList of buffers containing the first @nbytes bytes of the
1133  * @adapter, but does not flush them from the adapter. See
1134  * gst_adapter_take_list() for details.
1135  *
1136  * Caller owns returned list and contained buffers. gst_buffer_unref() each
1137  * buffer in the list before freeing the list after usage.
1138  *
1139  * Returns: (element-type Gst.Buffer) (transfer full) (nullable): a #GList of
1140  *     buffers containing the first @nbytes of the adapter, or %NULL if @nbytes
1141  *     bytes are not available
1142  *
1143  * Since: 1.6
1144  */
1145 GList *
1146 gst_adapter_get_list (GstAdapter * adapter, gsize nbytes)
1147 {
1148   GQueue queue = G_QUEUE_INIT;
1149   GstBuffer *cur, *buffer;
1150   gsize hsize, skip, cur_size;
<a name="39" id="anc39"></a><span class="line-modified">1151   guint idx;</span>
1152 
1153   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
1154   g_return_val_if_fail (nbytes &lt;= adapter-&gt;size, NULL);
1155 
1156   GST_LOG_OBJECT (adapter, &quot;getting %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, nbytes);
1157 
<a name="40" id="anc40"></a><span class="line-modified">1158   idx = 0;</span>
1159   skip = adapter-&gt;skip;
1160 
1161   while (nbytes &gt; 0) {
<a name="41" id="anc41"></a><span class="line-modified">1162     cur = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>
1163     cur_size = gst_buffer_get_size (cur);
1164     hsize = MIN (nbytes, cur_size - skip);
1165 
1166     if (skip == 0 &amp;&amp; cur_size == hsize) {
1167       GST_LOG_OBJECT (adapter,
1168           &quot;inserting a buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, hsize);
1169       buffer = gst_buffer_ref (cur);
1170     } else {
1171       GST_LOG_OBJECT (adapter, &quot;inserting a buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
1172           &quot; via region copy&quot;, hsize);
1173       buffer = gst_buffer_copy_region (cur, GST_BUFFER_COPY_ALL, skip, hsize);
1174     }
1175 
1176     g_queue_push_tail (&amp;queue, buffer);
1177 
1178     nbytes -= hsize;
1179     skip = 0;
<a name="42" id="anc42"></a>
1180   }
1181 
1182   return queue.head;
1183 }
1184 
1185 /**
1186  * gst_adapter_take_buffer_list:
1187  * @adapter: a #GstAdapter
1188  * @nbytes: the number of bytes to take
1189  *
1190  * Returns a #GstBufferList of buffers containing the first @nbytes bytes of
1191  * the @adapter. The returned bytes will be flushed from the adapter.
1192  * When the caller can deal with individual buffers, this function is more
1193  * performant because no memory should be copied.
1194  *
1195  * Caller owns the returned list. Call gst_buffer_list_unref() to free
1196  * the list after usage.
1197  *
1198  * Returns: (transfer full) (nullable): a #GstBufferList of buffers containing
1199  *     the first @nbytes of the adapter, or %NULL if @nbytes bytes are not
1200  *     available
1201  *
1202  * Since: 1.6
1203  */
1204 GstBufferList *
1205 gst_adapter_take_buffer_list (GstAdapter * adapter, gsize nbytes)
1206 {
1207   GstBufferList *buffer_list;
1208   GstBuffer *cur;
1209   gsize hsize, skip, cur_size;
1210   guint n_bufs;
1211 
1212   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
1213 
1214   if (nbytes &gt; adapter-&gt;size)
1215     return NULL;
1216 
1217   GST_LOG_OBJECT (adapter, &quot;taking %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, nbytes);
1218 
1219   /* try to create buffer list with sufficient size, so no resize is done later */
1220   if (adapter-&gt;count &lt; 64)
1221     n_bufs = adapter-&gt;count;
1222   else
1223     n_bufs = (adapter-&gt;count * nbytes * 1.2 / adapter-&gt;size) + 1;
1224 
1225   buffer_list = gst_buffer_list_new_sized (n_bufs);
1226 
1227   while (nbytes &gt; 0) {
<a name="43" id="anc43"></a><span class="line-modified">1228     cur = gst_queue_array_peek_head (adapter-&gt;bufqueue);</span>
1229     skip = adapter-&gt;skip;
1230     cur_size = gst_buffer_get_size (cur);
1231     hsize = MIN (nbytes, cur_size - skip);
1232 
1233     gst_buffer_list_add (buffer_list, gst_adapter_take_buffer (adapter, hsize));
1234     nbytes -= hsize;
1235   }
1236   return buffer_list;
1237 }
1238 
1239 /**
1240  * gst_adapter_get_buffer_list:
1241  * @adapter: a #GstAdapter
1242  * @nbytes: the number of bytes to get
1243  *
1244  * Returns a #GstBufferList of buffers containing the first @nbytes bytes of
1245  * the @adapter but does not flush them from the adapter. See
1246  * gst_adapter_take_buffer_list() for details.
1247  *
1248  * Caller owns the returned list. Call gst_buffer_list_unref() to free
1249  * the list after usage.
1250  *
1251  * Returns: (transfer full) (nullable): a #GstBufferList of buffers containing
1252  *     the first @nbytes of the adapter, or %NULL if @nbytes bytes are not
1253  *     available
1254  *
1255  * Since: 1.6
1256  */
1257 GstBufferList *
1258 gst_adapter_get_buffer_list (GstAdapter * adapter, gsize nbytes)
1259 {
1260   GstBufferList *buffer_list;
1261   GstBuffer *cur, *buffer;
1262   gsize hsize, skip, cur_size;
1263   guint n_bufs;
<a name="44" id="anc44"></a><span class="line-modified">1264   guint idx;</span>
1265 
1266   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
1267 
1268   if (nbytes &gt; adapter-&gt;size)
1269     return NULL;
1270 
1271   GST_LOG_OBJECT (adapter, &quot;getting %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, nbytes);
1272 
1273   /* try to create buffer list with sufficient size, so no resize is done later */
1274   if (adapter-&gt;count &lt; 64)
1275     n_bufs = adapter-&gt;count;
1276   else
1277     n_bufs = (adapter-&gt;count * nbytes * 1.2 / adapter-&gt;size) + 1;
1278 
1279   buffer_list = gst_buffer_list_new_sized (n_bufs);
1280 
<a name="45" id="anc45"></a><span class="line-modified">1281   idx = 0;</span>
1282   skip = adapter-&gt;skip;
1283 
1284   while (nbytes &gt; 0) {
<a name="46" id="anc46"></a><span class="line-modified">1285     cur = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>
1286     cur_size = gst_buffer_get_size (cur);
1287     hsize = MIN (nbytes, cur_size - skip);
1288 
1289     if (skip == 0 &amp;&amp; cur_size == hsize) {
1290       GST_LOG_OBJECT (adapter,
1291           &quot;inserting a buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, hsize);
1292       buffer = gst_buffer_ref (cur);
1293     } else {
1294       GST_LOG_OBJECT (adapter, &quot;inserting a buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
1295           &quot; via region copy&quot;, hsize);
1296       buffer = gst_buffer_copy_region (cur, GST_BUFFER_COPY_ALL, skip, hsize);
1297     }
1298 
1299     gst_buffer_list_add (buffer_list, buffer);
1300 
1301     nbytes -= hsize;
1302     skip = 0;
<a name="47" id="anc47"></a>
1303   }
1304 
1305   return buffer_list;
1306 }
1307 
1308 /**
1309  * gst_adapter_available:
1310  * @adapter: a #GstAdapter
1311  *
1312  * Gets the maximum amount of bytes available, that is it returns the maximum
1313  * value that can be supplied to gst_adapter_map() without that function
1314  * returning %NULL.
1315  *
1316  * Returns: number of bytes available in @adapter
1317  */
1318 gsize
1319 gst_adapter_available (GstAdapter * adapter)
1320 {
1321   g_return_val_if_fail (GST_IS_ADAPTER (adapter), 0);
1322 
1323   return adapter-&gt;size;
1324 }
1325 
1326 /**
1327  * gst_adapter_available_fast:
1328  * @adapter: a #GstAdapter
1329  *
1330  * Gets the maximum number of bytes that are immediately available without
1331  * requiring any expensive operations (like copying the data into a
1332  * temporary buffer).
1333  *
1334  * Returns: number of bytes that are available in @adapter without expensive
1335  * operations
1336  */
1337 gsize
1338 gst_adapter_available_fast (GstAdapter * adapter)
1339 {
1340   GstBuffer *cur;
1341   gsize size;
<a name="48" id="anc48"></a><span class="line-modified">1342   guint idx;</span>
1343 
1344   g_return_val_if_fail (GST_IS_ADAPTER (adapter), 0);
1345 
1346   /* no data */
1347   if (adapter-&gt;size == 0)
1348     return 0;
1349 
1350   /* some stuff we already assembled */
1351   if (adapter-&gt;assembled_len)
1352     return adapter-&gt;assembled_len;
1353 
1354   /* take the first non-zero buffer */
<a name="49" id="anc49"></a><span class="line-modified">1355   idx = 0;</span>
1356   while (TRUE) {
<a name="50" id="anc50"></a><span class="line-modified">1357     cur = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>
1358     size = gst_buffer_get_size (cur);
1359     if (size != 0)
1360       break;
<a name="51" id="anc51"></a>
1361   }
1362 
1363   /* we can quickly get the (remaining) data of the first buffer */
1364   return size - adapter-&gt;skip;
1365 }
1366 
1367 /**
1368  * gst_adapter_get_distance_from_discont:
1369  * @adapter: a #GstAdapter
1370  *
1371  * Get the distance in bytes since the last buffer with the
1372  * %GST_BUFFER_FLAG_DISCONT flag.
1373  *
1374  * The distance will be reset to 0 for all buffers with
1375  * %GST_BUFFER_FLAG_DISCONT on them, and then calculated for all other
1376  * following buffers based on their size.
1377  *
1378  * Since: 1.10
1379  *
1380  * Returns: The offset. Can be %GST_BUFFER_OFFSET_NONE.
1381  */
1382 guint64
1383 gst_adapter_distance_from_discont (GstAdapter * adapter)
1384 {
1385   return adapter-&gt;distance_from_discont;
1386 }
1387 
1388 /**
1389  * gst_adapter_offset_at_discont:
1390  * @adapter: a #GstAdapter
1391  *
1392  * Get the offset that was on the last buffer with the GST_BUFFER_FLAG_DISCONT
1393  * flag, or GST_BUFFER_OFFSET_NONE.
1394  *
1395  * Since: 1.10
1396  *
1397  * Returns: The offset at the last discont or GST_BUFFER_OFFSET_NONE.
1398  */
1399 guint64
1400 gst_adapter_offset_at_discont (GstAdapter * adapter)
1401 {
1402   g_return_val_if_fail (GST_IS_ADAPTER (adapter), GST_BUFFER_OFFSET_NONE);
1403 
1404   return adapter-&gt;offset_at_discont;
1405 }
1406 
1407 /**
1408  * gst_adapter_pts_at_discont:
1409  * @adapter: a #GstAdapter
1410  *
1411  * Get the PTS that was on the last buffer with the GST_BUFFER_FLAG_DISCONT
1412  * flag, or GST_CLOCK_TIME_NONE.
1413  *
1414  * Since: 1.10
1415  *
1416  * Returns: The PTS at the last discont or GST_CLOCK_TIME_NONE.
1417  */
1418 GstClockTime
1419 gst_adapter_pts_at_discont (GstAdapter * adapter)
1420 {
1421   g_return_val_if_fail (GST_IS_ADAPTER (adapter), GST_CLOCK_TIME_NONE);
1422 
1423   return adapter-&gt;pts_at_discont;
1424 }
1425 
1426 /**
1427  * gst_adapter_dts_at_discont:
1428  * @adapter: a #GstAdapter
1429  *
1430  * Get the DTS that was on the last buffer with the GST_BUFFER_FLAG_DISCONT
1431  * flag, or GST_CLOCK_TIME_NONE.
1432  *
1433  * Since: 1.10
1434  *
1435  * Returns: The DTS at the last discont or GST_CLOCK_TIME_NONE.
1436  */
1437 GstClockTime
1438 gst_adapter_dts_at_discont (GstAdapter * adapter)
1439 {
1440   g_return_val_if_fail (GST_IS_ADAPTER (adapter), GST_CLOCK_TIME_NONE);
1441 
1442   return adapter-&gt;dts_at_discont;
1443 }
1444 
1445 /**
1446  * gst_adapter_prev_offset:
1447  * @adapter: a #GstAdapter
1448  * @distance: (out) (allow-none): pointer to a location for distance, or %NULL
1449  *
1450  * Get the offset that was before the current byte in the adapter. When
1451  * @distance is given, the amount of bytes between the offset and the current
1452  * position is returned.
1453  *
1454  * The offset is reset to GST_BUFFER_OFFSET_NONE and the distance is set to 0
1455  * when the adapter is first created or when it is cleared. This also means that
1456  * before the first byte with an offset is removed from the adapter, the offset
1457  * and distance returned are GST_BUFFER_OFFSET_NONE and 0 respectively.
1458  *
1459  * Since: 1.10
1460  *
1461  * Returns: The previous seen offset.
1462  */
1463 guint64
1464 gst_adapter_prev_offset (GstAdapter * adapter, guint64 * distance)
1465 {
1466   g_return_val_if_fail (GST_IS_ADAPTER (adapter), GST_BUFFER_OFFSET_NONE);
1467 
1468   if (distance)
1469     *distance = adapter-&gt;offset_distance;
1470 
1471   return adapter-&gt;offset;
1472 }
1473 
1474 /**
1475  * gst_adapter_prev_pts:
1476  * @adapter: a #GstAdapter
1477  * @distance: (out) (allow-none): pointer to location for distance, or %NULL
1478  *
1479  * Get the pts that was before the current byte in the adapter. When
1480  * @distance is given, the amount of bytes between the pts and the current
1481  * position is returned.
1482  *
1483  * The pts is reset to GST_CLOCK_TIME_NONE and the distance is set to 0 when
1484  * the adapter is first created or when it is cleared. This also means that before
1485  * the first byte with a pts is removed from the adapter, the pts
1486  * and distance returned are GST_CLOCK_TIME_NONE and 0 respectively.
1487  *
1488  * Returns: The previously seen pts.
1489  */
1490 GstClockTime
1491 gst_adapter_prev_pts (GstAdapter * adapter, guint64 * distance)
1492 {
1493   g_return_val_if_fail (GST_IS_ADAPTER (adapter), GST_CLOCK_TIME_NONE);
1494 
1495   if (distance)
1496     *distance = adapter-&gt;pts_distance;
1497 
1498   return adapter-&gt;pts;
1499 }
1500 
1501 /**
1502  * gst_adapter_prev_dts:
1503  * @adapter: a #GstAdapter
1504  * @distance: (out) (allow-none): pointer to location for distance, or %NULL
1505  *
1506  * Get the dts that was before the current byte in the adapter. When
1507  * @distance is given, the amount of bytes between the dts and the current
1508  * position is returned.
1509  *
1510  * The dts is reset to GST_CLOCK_TIME_NONE and the distance is set to 0 when
1511  * the adapter is first created or when it is cleared. This also means that before
1512  * the first byte with a dts is removed from the adapter, the dts
1513  * and distance returned are GST_CLOCK_TIME_NONE and 0 respectively.
1514  *
1515  * Returns: The previously seen dts.
1516  */
1517 GstClockTime
1518 gst_adapter_prev_dts (GstAdapter * adapter, guint64 * distance)
1519 {
1520   g_return_val_if_fail (GST_IS_ADAPTER (adapter), GST_CLOCK_TIME_NONE);
1521 
1522   if (distance)
1523     *distance = adapter-&gt;dts_distance;
1524 
1525   return adapter-&gt;dts;
1526 }
1527 
1528 /**
1529  * gst_adapter_prev_pts_at_offset:
1530  * @adapter: a #GstAdapter
1531  * @offset: the offset in the adapter at which to get timestamp
1532  * @distance: (out) (allow-none): pointer to location for distance, or %NULL
1533  *
1534  * Get the pts that was before the byte at offset @offset in the adapter. When
1535  * @distance is given, the amount of bytes between the pts and the current
1536  * position is returned.
1537  *
1538  * The pts is reset to GST_CLOCK_TIME_NONE and the distance is set to 0 when
1539  * the adapter is first created or when it is cleared. This also means that before
1540  * the first byte with a pts is removed from the adapter, the pts
1541  * and distance returned are GST_CLOCK_TIME_NONE and 0 respectively.
1542  *
1543  * Since: 1.2
1544  * Returns: The previously seen pts at given offset.
1545  */
1546 GstClockTime
1547 gst_adapter_prev_pts_at_offset (GstAdapter * adapter, gsize offset,
1548     guint64 * distance)
1549 {
1550   GstBuffer *cur;
<a name="52" id="anc52"></a>
1551   gsize read_offset = 0;
1552   gsize pts_offset = 0;
1553   GstClockTime pts = adapter-&gt;pts;
<a name="53" id="anc53"></a><span class="line-added">1554   guint idx, len;</span>
1555 
1556   g_return_val_if_fail (GST_IS_ADAPTER (adapter), GST_CLOCK_TIME_NONE);
1557 
<a name="54" id="anc54"></a><span class="line-modified">1558   idx = 0;</span>
<span class="line-added">1559   len = gst_queue_array_get_length (adapter-&gt;bufqueue);</span>
1560 
<a name="55" id="anc55"></a><span class="line-modified">1561   while (idx &lt; len &amp;&amp; read_offset &lt; offset + adapter-&gt;skip) {</span>
<span class="line-modified">1562     cur = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>
1563 
1564     if (GST_CLOCK_TIME_IS_VALID (GST_BUFFER_PTS (cur))) {
1565       pts = GST_BUFFER_PTS (cur);
1566       pts_offset = read_offset;
1567     }
1568 
1569     read_offset += gst_buffer_get_size (cur);
<a name="56" id="anc56"></a>
1570   }
1571 
1572   if (distance)
1573     *distance = adapter-&gt;pts_distance + offset - pts_offset;
1574 
1575   return pts;
1576 }
1577 
1578 /**
1579  * gst_adapter_prev_dts_at_offset:
1580  * @adapter: a #GstAdapter
1581  * @offset: the offset in the adapter at which to get timestamp
1582  * @distance: (out) (allow-none): pointer to location for distance, or %NULL
1583  *
1584  * Get the dts that was before the byte at offset @offset in the adapter. When
1585  * @distance is given, the amount of bytes between the dts and the current
1586  * position is returned.
1587  *
1588  * The dts is reset to GST_CLOCK_TIME_NONE and the distance is set to 0 when
1589  * the adapter is first created or when it is cleared. This also means that before
1590  * the first byte with a dts is removed from the adapter, the dts
1591  * and distance returned are GST_CLOCK_TIME_NONE and 0 respectively.
1592  *
1593  * Since: 1.2
1594  * Returns: The previously seen dts at given offset.
1595  */
1596 GstClockTime
1597 gst_adapter_prev_dts_at_offset (GstAdapter * adapter, gsize offset,
1598     guint64 * distance)
1599 {
1600   GstBuffer *cur;
<a name="57" id="anc57"></a>
1601   gsize read_offset = 0;
1602   gsize dts_offset = 0;
1603   GstClockTime dts = adapter-&gt;dts;
<a name="58" id="anc58"></a><span class="line-added">1604   guint idx, len;</span>
1605 
1606   g_return_val_if_fail (GST_IS_ADAPTER (adapter), GST_CLOCK_TIME_NONE);
1607 
<a name="59" id="anc59"></a><span class="line-modified">1608   idx = 0;</span>
<span class="line-added">1609   len = gst_queue_array_get_length (adapter-&gt;bufqueue);</span>
1610 
<a name="60" id="anc60"></a><span class="line-modified">1611   while (idx &lt; len &amp;&amp; read_offset &lt; offset + adapter-&gt;skip) {</span>
<span class="line-modified">1612     cur = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>
1613 
1614     if (GST_CLOCK_TIME_IS_VALID (GST_BUFFER_DTS (cur))) {
1615       dts = GST_BUFFER_DTS (cur);
1616       dts_offset = read_offset;
1617     }
1618 
1619     read_offset += gst_buffer_get_size (cur);
<a name="61" id="anc61"></a>
1620   }
1621 
1622   if (distance)
1623     *distance = adapter-&gt;dts_distance + offset - dts_offset;
1624 
1625   return dts;
1626 }
1627 
1628 /**
1629  * gst_adapter_masked_scan_uint32_peek:
1630  * @adapter: a #GstAdapter
1631  * @mask: mask to apply to data before matching against @pattern
1632  * @pattern: pattern to match (after mask is applied)
1633  * @offset: offset into the adapter data from which to start scanning, returns
1634  *          the last scanned position.
1635  * @size: number of bytes to scan from offset
1636  * @value: (out) (allow-none): pointer to uint32 to return matching data
1637  *
1638  * Scan for pattern @pattern with applied mask @mask in the adapter data,
1639  * starting from offset @offset.  If a match is found, the value that matched
1640  * is returned through @value, otherwise @value is left untouched.
1641  *
1642  * The bytes in @pattern and @mask are interpreted left-to-right, regardless
1643  * of endianness.  All four bytes of the pattern must be present in the
1644  * adapter for it to match, even if the first or last bytes are masked out.
1645  *
1646  * It is an error to call this function without making sure that there is
1647  * enough data (offset+size bytes) in the adapter.
1648  *
1649  * Returns: offset of the first match, or -1 if no match was found.
1650  */
1651 gssize
1652 gst_adapter_masked_scan_uint32_peek (GstAdapter * adapter, guint32 mask,
1653     guint32 pattern, gsize offset, gsize size, guint32 * value)
1654 {
<a name="62" id="anc62"></a>
1655   gsize skip, bsize, i;
1656   guint32 state;
1657   GstMapInfo info;
1658   guint8 *bdata;
1659   GstBuffer *buf;
<a name="63" id="anc63"></a><span class="line-added">1660   guint idx;</span>
1661 
1662   g_return_val_if_fail (size &gt; 0, -1);
1663   g_return_val_if_fail (offset + size &lt;= adapter-&gt;size, -1);
1664   g_return_val_if_fail (((~mask) &amp; pattern) == 0, -1);
1665 
1666   /* we can&#39;t find the pattern with less than 4 bytes */
1667   if (G_UNLIKELY (size &lt; 4))
1668     return -1;
1669 
1670   skip = offset + adapter-&gt;skip;
1671 
1672   /* first step, do skipping and position on the first buffer */
1673   /* optimistically assume scanning continues sequentially */
<a name="64" id="anc64"></a><span class="line-modified">1674   if (adapter-&gt;scan_entry_idx != G_MAXUINT &amp;&amp; (adapter-&gt;scan_offset &lt;= skip)) {</span>
<span class="line-modified">1675     idx = adapter-&gt;scan_entry_idx;</span>
1676     skip -= adapter-&gt;scan_offset;
1677   } else {
<a name="65" id="anc65"></a><span class="line-modified">1678     idx = 0;</span>
1679     adapter-&gt;scan_offset = 0;
<a name="66" id="anc66"></a><span class="line-modified">1680     adapter-&gt;scan_entry_idx = G_MAXUINT;</span>
1681   }
<a name="67" id="anc67"></a><span class="line-modified">1682   buf = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>
1683   bsize = gst_buffer_get_size (buf);
1684   while (G_UNLIKELY (skip &gt;= bsize)) {
1685     skip -= bsize;
<a name="68" id="anc68"></a>
1686     adapter-&gt;scan_offset += bsize;
<a name="69" id="anc69"></a><span class="line-modified">1687     adapter-&gt;scan_entry_idx = idx;</span>
<span class="line-modified">1688     buf = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>
1689     bsize = gst_buffer_get_size (buf);
1690   }
1691   /* get the data now */
1692   if (!gst_buffer_map (buf, &amp;info, GST_MAP_READ))
1693     return -1;
1694 
1695   bdata = (guint8 *) info.data + skip;
1696   bsize = info.size - skip;
1697   skip = 0;
1698 
1699   /* set the state to something that does not match */
1700   state = ~pattern;
1701 
1702   /* now find data */
1703   do {
1704     bsize = MIN (bsize, size);
1705     for (i = 0; i &lt; bsize; i++) {
1706       state = ((state &lt;&lt; 8) | bdata[i]);
1707       if (G_UNLIKELY ((state &amp; mask) == pattern)) {
1708         /* we have a match but we need to have skipped at
1709          * least 4 bytes to fill the state. */
1710         if (G_LIKELY (skip + i &gt;= 3)) {
1711           if (G_LIKELY (value))
1712             *value = state;
1713           gst_buffer_unmap (buf, &amp;info);
1714           return offset + skip + i - 3;
1715         }
1716       }
1717     }
1718     size -= bsize;
1719     if (size == 0)
1720       break;
1721 
1722     /* nothing found yet, go to next buffer */
1723     skip += bsize;
<a name="70" id="anc70"></a>
1724     adapter-&gt;scan_offset += info.size;
<a name="71" id="anc71"></a><span class="line-modified">1725     adapter-&gt;scan_entry_idx = idx;</span>
1726     gst_buffer_unmap (buf, &amp;info);
<a name="72" id="anc72"></a><span class="line-modified">1727     buf = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>
1728 
1729     if (!gst_buffer_map (buf, &amp;info, GST_MAP_READ))
1730       return -1;
1731 
1732     bsize = info.size;
1733     bdata = info.data;
1734   } while (TRUE);
1735 
1736   gst_buffer_unmap (buf, &amp;info);
1737 
1738   /* nothing found */
1739   return -1;
1740 }
1741 
1742 /**
1743  * gst_adapter_masked_scan_uint32:
1744  * @adapter: a #GstAdapter
1745  * @mask: mask to apply to data before matching against @pattern
1746  * @pattern: pattern to match (after mask is applied)
1747  * @offset: offset into the adapter data from which to start scanning, returns
1748  *          the last scanned position.
1749  * @size: number of bytes to scan from offset
1750  *
1751  * Scan for pattern @pattern with applied mask @mask in the adapter data,
1752  * starting from offset @offset.
1753  *
1754  * The bytes in @pattern and @mask are interpreted left-to-right, regardless
1755  * of endianness.  All four bytes of the pattern must be present in the
1756  * adapter for it to match, even if the first or last bytes are masked out.
1757  *
1758  * It is an error to call this function without making sure that there is
1759  * enough data (offset+size bytes) in the adapter.
1760  *
1761  * This function calls gst_adapter_masked_scan_uint32_peek() passing %NULL
1762  * for value.
1763  *
1764  * Returns: offset of the first match, or -1 if no match was found.
1765  *
1766  * Example:
1767  * |[
1768  * // Assume the adapter contains 0x00 0x01 0x02 ... 0xfe 0xff
1769  *
1770  * gst_adapter_masked_scan_uint32 (adapter, 0xffffffff, 0x00010203, 0, 256);
1771  * // -&gt; returns 0
1772  * gst_adapter_masked_scan_uint32 (adapter, 0xffffffff, 0x00010203, 1, 255);
1773  * // -&gt; returns -1
1774  * gst_adapter_masked_scan_uint32 (adapter, 0xffffffff, 0x01020304, 1, 255);
1775  * // -&gt; returns 1
1776  * gst_adapter_masked_scan_uint32 (adapter, 0xffff, 0x0001, 0, 256);
1777  * // -&gt; returns -1
1778  * gst_adapter_masked_scan_uint32 (adapter, 0xffff, 0x0203, 0, 256);
1779  * // -&gt; returns 0
1780  * gst_adapter_masked_scan_uint32 (adapter, 0xffff0000, 0x02030000, 0, 256);
1781  * // -&gt; returns 2
1782  * gst_adapter_masked_scan_uint32 (adapter, 0xffff0000, 0x02030000, 0, 4);
1783  * // -&gt; returns -1
1784  * ]|
1785  */
1786 gssize
1787 gst_adapter_masked_scan_uint32 (GstAdapter * adapter, guint32 mask,
1788     guint32 pattern, gsize offset, gsize size)
1789 {
1790   return gst_adapter_masked_scan_uint32_peek (adapter, mask, pattern, offset,
1791       size, NULL);
1792 }
<a name="73" id="anc73"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="73" type="hidden" />
</body>
</html>