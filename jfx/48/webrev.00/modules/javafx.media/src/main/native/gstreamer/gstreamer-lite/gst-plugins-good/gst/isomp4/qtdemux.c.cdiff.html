<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/isomp4/qtdemux.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="properties.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="qtdemux.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/isomp4/qtdemux.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 96,14 ***</span>
  #define QTDEMUX_SECONDS_FROM_1904_TO_1970 (((1970 - 1904) * (guint64) 365 + \
      QTDEMUX_LEAP_YEARS_FROM_1904_TO_1970) * QTDEMUX_SECONDS_PER_DAY)
  
  #define QTDEMUX_TREE_NODE_FOURCC(n) (QT_FOURCC(((guint8 *) (n)-&gt;data) + 4))
  
<span class="line-modified">! #define STREAM_IS_EOS(s) (s-&gt;time_position == GST_CLOCK_TIME_NONE)</span>
  
  #define ABSDIFF(x, y) ( (x) &gt; (y) ? ((x) - (y)) : ((y) - (x)) )
  
  GST_DEBUG_CATEGORY (qtdemux_debug);
  #define GST_CAT_DEFAULT qtdemux_debug
  
  typedef struct _QtDemuxSegment QtDemuxSegment;
  typedef struct _QtDemuxSample QtDemuxSample;
<span class="line-new-header">--- 96,21 ---</span>
  #define QTDEMUX_SECONDS_FROM_1904_TO_1970 (((1970 - 1904) * (guint64) 365 + \
      QTDEMUX_LEAP_YEARS_FROM_1904_TO_1970) * QTDEMUX_SECONDS_PER_DAY)
  
  #define QTDEMUX_TREE_NODE_FOURCC(n) (QT_FOURCC(((guint8 *) (n)-&gt;data) + 4))
  
<span class="line-modified">! #define STREAM_IS_EOS(s) ((s)-&gt;time_position == GST_CLOCK_TIME_NONE)</span>
  
  #define ABSDIFF(x, y) ( (x) &gt; (y) ? ((x) - (y)) : ((y) - (x)) )
  
<span class="line-added">+ #define QTDEMUX_STREAM(s) ((QtDemuxStream *)(s))</span>
<span class="line-added">+ #define QTDEMUX_N_STREAMS(demux) ((demux)-&gt;active_streams-&gt;len)</span>
<span class="line-added">+ #define QTDEMUX_NTH_STREAM(demux,idx) \</span>
<span class="line-added">+    QTDEMUX_STREAM(g_ptr_array_index((demux)-&gt;active_streams,idx))</span>
<span class="line-added">+ #define QTDEMUX_NTH_OLD_STREAM(demux,idx) \</span>
<span class="line-added">+    QTDEMUX_STREAM(g_ptr_array_index((demux)-&gt;old_streams,idx))</span>
<span class="line-added">+ </span>
  GST_DEBUG_CATEGORY (qtdemux_debug);
  #define GST_CAT_DEFAULT qtdemux_debug
  
  typedef struct _QtDemuxSegment QtDemuxSegment;
  typedef struct _QtDemuxSample QtDemuxSample;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 136,10 ***</span>
<span class="line-new-header">--- 143,22 ---</span>
  /* timestamp + duration - dts is the duration */
  #define QTSAMPLE_DUR_DTS(stream, sample, dts) (QTSTREAMTIME_TO_GSTTIME ((stream), (sample)-&gt;timestamp + (sample)-&gt;duration) - (dts))
  
  #define QTSAMPLE_KEYFRAME(stream,sample) ((stream)-&gt;all_keyframe || (sample)-&gt;keyframe)
  
<span class="line-added">+ #define QTDEMUX_EXPOSE_GET_LOCK(demux) (&amp;((demux)-&gt;expose_lock))</span>
<span class="line-added">+ #define QTDEMUX_EXPOSE_LOCK(demux) G_STMT_START { \</span>
<span class="line-added">+     GST_TRACE(&quot;Locking from thread %p&quot;, g_thread_self()); \</span>
<span class="line-added">+     g_mutex_lock (QTDEMUX_EXPOSE_GET_LOCK (demux)); \</span>
<span class="line-added">+     GST_TRACE(&quot;Locked from thread %p&quot;, g_thread_self()); \</span>
<span class="line-added">+  } G_STMT_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define QTDEMUX_EXPOSE_UNLOCK(demux) G_STMT_START { \</span>
<span class="line-added">+     GST_TRACE(&quot;Unlocking from thread %p&quot;, g_thread_self()); \</span>
<span class="line-added">+     g_mutex_unlock (QTDEMUX_EXPOSE_GET_LOCK (demux)); \</span>
<span class="line-added">+  } G_STMT_END</span>
<span class="line-added">+ </span>
  /*
   * Quicktime has tracks and segments. A track is a continuous piece of
   * multimedia content. The track is not always played from start to finish but
   * instead, pieces of the track are &#39;cut out&#39; and played in sequence. This is
   * what the segments do.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 260,10 ***</span>
<span class="line-new-header">--- 279,13 ---</span>
  
  struct _QtDemuxStream
  {
    GstPad *pad;
  
<span class="line-added">+   GstQTDemux *demux;</span>
<span class="line-added">+   gchar *stream_id;</span>
<span class="line-added">+ </span>
    QtDemuxStreamStsdEntry *stsd_entries;
    guint stsd_entries_length;
    guint cur_stsd_entry_index;
  
    /* stream type */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 297,12 ***</span>
  
    /* our samples */
    guint32 n_samples;
    QtDemuxSample *samples;
    gboolean all_keyframe;        /* TRUE when all samples are keyframes (no stss) */
<span class="line-removed">-   guint32 first_duration;       /* duration in timescale of first sample, used for figuring out</span>
<span class="line-removed">-                                    the framerate */</span>
    guint32 n_samples_moof;       /* sample count in a moof */
    guint64 duration_moof;        /* duration in timescale of a moof, used for figure out
                                   * the framerate of fragmented format stream */
    guint64 duration_last_moof;
  
<span class="line-new-header">--- 319,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 335,10 ***</span>
<span class="line-new-header">--- 355,12 ---</span>
     * data */
    gboolean need_clip;
  
    /* buffer needs some custom processing, e.g. subtitles */
    gboolean need_process;
<span class="line-added">+   /* buffer needs potentially be split, e.g. CEA608 subtitles */</span>
<span class="line-added">+   gboolean need_split;</span>
  
    /* current position */
    guint32 segment_index;
    guint32 sample_index;
    GstClockTime time_position;   /* in gst time */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 435,10 ***</span>
<span class="line-new-header">--- 457,12 ---</span>
    gboolean protected;
    guint32 protection_scheme_type;
    guint32 protection_scheme_version;
    gpointer protection_scheme_info;      /* specific to the protection scheme */
    GQueue protection_scheme_event_queue;
<span class="line-added">+ </span>
<span class="line-added">+   gint ref_count;               /* atomic */</span>
  };
  
  /* Contains properties and cryptographic info for a set of samples from a
   * track protected using Common Encryption (cenc) */
  struct _QtDemuxCencSampleSetInfo
</pre>
<hr />
<pre>
<span class="line-old-header">*** 473,10 ***</span>
<span class="line-new-header">--- 497,12 ---</span>
  static GNode *qtdemux_tree_get_sibling_by_type_full (GNode * node,
      guint32 fourcc, GstByteReader * parser);
  
  static GstFlowReturn qtdemux_add_fragmented_samples (GstQTDemux * qtdemux);
  
<span class="line-added">+ static void gst_qtdemux_check_send_pending_segment (GstQTDemux * demux);</span>
<span class="line-added">+ </span>
  static GstStaticPadTemplate gst_qtdemux_sink_template =
      GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,
      GST_PAD_SINK,
      GST_PAD_ALWAYS,
      GST_STATIC_CAPS (&quot;video/quicktime; video/mj2; audio/x-m4a; &quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 517,27 ***</span>
<span class="line-new-header">--- 543,33 ---</span>
  static void gst_qtdemux_set_index (GstElement * element, GstIndex * index);
  static GstIndex *gst_qtdemux_get_index (GstElement * element);
  #endif
  static GstStateChangeReturn gst_qtdemux_change_state (GstElement * element,
      GstStateChange transition);
<span class="line-added">+ static void gst_qtdemux_set_context (GstElement * element,</span>
<span class="line-added">+     GstContext * context);</span>
  static gboolean qtdemux_sink_activate (GstPad * sinkpad, GstObject * parent);
  static gboolean qtdemux_sink_activate_mode (GstPad * sinkpad,
      GstObject * parent, GstPadMode mode, gboolean active);
  
  static void gst_qtdemux_loop (GstPad * pad);
  static GstFlowReturn gst_qtdemux_chain (GstPad * sinkpad, GstObject * parent,
      GstBuffer * inbuf);
  static gboolean gst_qtdemux_handle_sink_event (GstPad * pad, GstObject * parent,
      GstEvent * event);
<span class="line-added">+ static gboolean gst_qtdemux_handle_sink_query (GstPad * pad, GstObject * parent,</span>
<span class="line-added">+     GstQuery * query);</span>
  static gboolean gst_qtdemux_setcaps (GstQTDemux * qtdemux, GstCaps * caps);
  static gboolean gst_qtdemux_configure_stream (GstQTDemux * qtdemux,
      QtDemuxStream * stream);
  static void gst_qtdemux_stream_check_and_change_stsd_index (GstQTDemux * demux,
      QtDemuxStream * stream);
  static GstFlowReturn gst_qtdemux_process_adapter (GstQTDemux * demux,
      gboolean force);
  
<span class="line-added">+ static void gst_qtdemux_check_seekability (GstQTDemux * demux);</span>
<span class="line-added">+ </span>
  static gboolean qtdemux_parse_moov (GstQTDemux * qtdemux,
      const guint8 * buffer, guint length);
  static gboolean qtdemux_parse_node (GstQTDemux * qtdemux, GNode * node,
      const guint8 * buffer, guint length);
  static gboolean qtdemux_parse_tree (GstQTDemux * qtdemux);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 567,18 ***</span>
      const guint8 * stsd_entry_data, gchar ** codec_name);
  
  static gboolean qtdemux_parse_samples (GstQTDemux * qtdemux,
      QtDemuxStream * stream, guint32 n);
  static GstFlowReturn qtdemux_expose_streams (GstQTDemux * qtdemux);
<span class="line-modified">! static void gst_qtdemux_stream_free (GstQTDemux * qtdemux,</span>
<span class="line-modified">!     QtDemuxStream * stream);</span>
<span class="line-modified">! static void gst_qtdemux_stream_clear (GstQTDemux * qtdemux,</span>
<span class="line-removed">-     QtDemuxStream * stream);</span>
<span class="line-removed">- static void gst_qtdemux_remove_stream (GstQTDemux * qtdemux, int index);</span>
  static GstFlowReturn qtdemux_prepare_streams (GstQTDemux * qtdemux);
<span class="line-modified">! static void qtdemux_do_allocation (GstQTDemux * qtdemux,</span>
<span class="line-modified">!     QtDemuxStream * stream);</span>
  static gboolean gst_qtdemux_activate_segment (GstQTDemux * qtdemux,
      QtDemuxStream * stream, guint32 seg_idx, GstClockTime offset);
  static gboolean gst_qtdemux_stream_update_segment (GstQTDemux * qtdemux,
      QtDemuxStream * stream, gint seg_idx, GstClockTime offset,
      GstClockTime * _start, GstClockTime * _stop);
<span class="line-new-header">--- 599,16 ---</span>
      const guint8 * stsd_entry_data, gchar ** codec_name);
  
  static gboolean qtdemux_parse_samples (GstQTDemux * qtdemux,
      QtDemuxStream * stream, guint32 n);
  static GstFlowReturn qtdemux_expose_streams (GstQTDemux * qtdemux);
<span class="line-modified">! static QtDemuxStream *gst_qtdemux_stream_ref (QtDemuxStream * stream);</span>
<span class="line-modified">! static void gst_qtdemux_stream_unref (QtDemuxStream * stream);</span>
<span class="line-modified">! static void gst_qtdemux_stream_clear (QtDemuxStream * stream);</span>
  static GstFlowReturn qtdemux_prepare_streams (GstQTDemux * qtdemux);
<span class="line-modified">! static void qtdemux_do_allocation (QtDemuxStream * stream,</span>
<span class="line-modified">!     GstQTDemux * qtdemux);</span>
  static gboolean gst_qtdemux_activate_segment (GstQTDemux * qtdemux,
      QtDemuxStream * stream, guint32 seg_idx, GstClockTime offset);
  static gboolean gst_qtdemux_stream_update_segment (GstQTDemux * qtdemux,
      QtDemuxStream * stream, gint seg_idx, GstClockTime offset,
      GstClockTime * _start, GstClockTime * _stop);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 593,10 ***</span>
<span class="line-new-header">--- 623,11 ---</span>
  static GstStructure *qtdemux_get_cenc_sample_properties (GstQTDemux * qtdemux,
      QtDemuxStream * stream, guint sample_index);
  static void gst_qtdemux_append_protection_system_id (GstQTDemux * qtdemux,
      const gchar * id);
  static void qtdemux_gst_structure_free (GstStructure * gststructure);
<span class="line-added">+ static void gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard);</span>
  
  static void
  gst_qtdemux_class_init (GstQTDemuxClass * klass)
  {
    GObjectClass *gobject_class;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 612,10 ***</span>
<span class="line-new-header">--- 643,11 ---</span>
    gstelement_class-&gt;change_state = GST_DEBUG_FUNCPTR (gst_qtdemux_change_state);
  #if 0
    gstelement_class-&gt;set_index = GST_DEBUG_FUNCPTR (gst_qtdemux_set_index);
    gstelement_class-&gt;get_index = GST_DEBUG_FUNCPTR (gst_qtdemux_get_index);
  #endif
<span class="line-added">+   gstelement_class-&gt;set_context = GST_DEBUG_FUNCPTR (gst_qtdemux_set_context);</span>
  
    gst_tag_register_musicbrainz_tags ();
  
    gst_element_class_add_static_pad_template (gstelement_class,
        &amp;gst_qtdemux_sink_template);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 642,45 ***</span>
    gst_pad_set_activate_function (qtdemux-&gt;sinkpad, qtdemux_sink_activate);
    gst_pad_set_activatemode_function (qtdemux-&gt;sinkpad,
        qtdemux_sink_activate_mode);
    gst_pad_set_chain_function (qtdemux-&gt;sinkpad, gst_qtdemux_chain);
    gst_pad_set_event_function (qtdemux-&gt;sinkpad, gst_qtdemux_handle_sink_event);
    gst_element_add_pad (GST_ELEMENT_CAST (qtdemux), qtdemux-&gt;sinkpad);
  
<span class="line-removed">-   qtdemux-&gt;state = QTDEMUX_STATE_INITIAL;</span>
<span class="line-removed">-   qtdemux-&gt;pullbased = FALSE;</span>
<span class="line-removed">-   qtdemux-&gt;posted_redirect = FALSE;</span>
<span class="line-removed">-   qtdemux-&gt;neededbytes = 16;</span>
<span class="line-removed">-   qtdemux-&gt;todrop = 0;</span>
    qtdemux-&gt;adapter = gst_adapter_new ();
<span class="line-removed">-   qtdemux-&gt;offset = 0;</span>
<span class="line-removed">-   qtdemux-&gt;first_mdat = -1;</span>
<span class="line-removed">-   qtdemux-&gt;got_moov = FALSE;</span>
<span class="line-removed">-   qtdemux-&gt;mdatoffset = -1;</span>
<span class="line-removed">-   qtdemux-&gt;mdatbuffer = NULL;</span>
<span class="line-removed">-   qtdemux-&gt;restoredata_buffer = NULL;</span>
<span class="line-removed">-   qtdemux-&gt;restoredata_offset = -1;</span>
<span class="line-removed">-   qtdemux-&gt;fragment_start = -1;</span>
<span class="line-removed">-   qtdemux-&gt;fragment_start_offset = -1;</span>
<span class="line-removed">-   qtdemux-&gt;media_caps = NULL;</span>
<span class="line-removed">-   qtdemux-&gt;exposed = FALSE;</span>
<span class="line-removed">-   qtdemux-&gt;mss_mode = FALSE;</span>
<span class="line-removed">-   qtdemux-&gt;pending_newsegment = NULL;</span>
<span class="line-removed">-   qtdemux-&gt;upstream_format_is_time = FALSE;</span>
<span class="line-removed">-   qtdemux-&gt;have_group_id = FALSE;</span>
<span class="line-removed">-   qtdemux-&gt;group_id = G_MAXUINT;</span>
<span class="line-removed">-   qtdemux-&gt;cenc_aux_info_offset = 0;</span>
<span class="line-removed">-   qtdemux-&gt;cenc_aux_info_sizes = NULL;</span>
<span class="line-removed">-   qtdemux-&gt;cenc_aux_sample_count = 0;</span>
<span class="line-removed">-   qtdemux-&gt;protection_system_ids = NULL;</span>
    g_queue_init (&amp;qtdemux-&gt;protection_event_queue);
<span class="line-removed">-   gst_segment_init (&amp;qtdemux-&gt;segment, GST_FORMAT_TIME);</span>
<span class="line-removed">-   qtdemux-&gt;tag_list = gst_tag_list_new_empty ();</span>
<span class="line-removed">-   gst_tag_list_set_scope (qtdemux-&gt;tag_list, GST_TAG_SCOPE_GLOBAL);</span>
    qtdemux-&gt;flowcombiner = gst_flow_combiner_new ();
  
    GST_OBJECT_FLAG_SET (qtdemux, GST_ELEMENT_FLAG_INDEXABLE);
  }
  
  static void
  gst_qtdemux_dispose (GObject * object)
  {
<span class="line-new-header">--- 674,26 ---</span>
    gst_pad_set_activate_function (qtdemux-&gt;sinkpad, qtdemux_sink_activate);
    gst_pad_set_activatemode_function (qtdemux-&gt;sinkpad,
        qtdemux_sink_activate_mode);
    gst_pad_set_chain_function (qtdemux-&gt;sinkpad, gst_qtdemux_chain);
    gst_pad_set_event_function (qtdemux-&gt;sinkpad, gst_qtdemux_handle_sink_event);
<span class="line-added">+   gst_pad_set_query_function (qtdemux-&gt;sinkpad, gst_qtdemux_handle_sink_query);</span>
    gst_element_add_pad (GST_ELEMENT_CAST (qtdemux), qtdemux-&gt;sinkpad);
  
    qtdemux-&gt;adapter = gst_adapter_new ();
    g_queue_init (&amp;qtdemux-&gt;protection_event_queue);
    qtdemux-&gt;flowcombiner = gst_flow_combiner_new ();
<span class="line-added">+   g_mutex_init (&amp;qtdemux-&gt;expose_lock);</span>
<span class="line-added">+ </span>
<span class="line-added">+   qtdemux-&gt;active_streams = g_ptr_array_new_with_free_func</span>
<span class="line-added">+       ((GDestroyNotify) gst_qtdemux_stream_unref);</span>
<span class="line-added">+   qtdemux-&gt;old_streams = g_ptr_array_new_with_free_func</span>
<span class="line-added">+       ((GDestroyNotify) gst_qtdemux_stream_unref);</span>
  
    GST_OBJECT_FLAG_SET (qtdemux, GST_ELEMENT_FLAG_INDEXABLE);
<span class="line-added">+ </span>
<span class="line-added">+   gst_qtdemux_reset (qtdemux, TRUE);</span>
  }
  
  static void
  gst_qtdemux_dispose (GObject * object)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 696,10 ***</span>
<span class="line-new-header">--- 709,14 ---</span>
        NULL);
    g_queue_clear (&amp;qtdemux-&gt;protection_event_queue);
  
    g_free (qtdemux-&gt;cenc_aux_info_sizes);
    qtdemux-&gt;cenc_aux_info_sizes = NULL;
<span class="line-added">+   g_mutex_clear (&amp;qtdemux-&gt;expose_lock);</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_ptr_array_free (qtdemux-&gt;active_streams, TRUE);</span>
<span class="line-added">+   g_ptr_array_free (qtdemux-&gt;old_streams, TRUE);</span>
  
    G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
  }
  
  static void
</pre>
<hr />
<pre>
<span class="line-old-header">*** 864,11 ***</span>
        qtdemux-&gt;duration != G_MAXINT64 &amp;&amp; qtdemux-&gt;timescale != 0) {
      *duration = QTTIME_TO_GSTTIME (qtdemux, qtdemux-&gt;duration);
      res = TRUE;
    } else {
      *duration = GST_CLOCK_TIME_NONE;
<span class="line-modified">!     }</span>
  
    return res;
  }
  
  static gboolean
<span class="line-new-header">--- 881,11 ---</span>
        qtdemux-&gt;duration != G_MAXINT64 &amp;&amp; qtdemux-&gt;timescale != 0) {
      *duration = QTTIME_TO_GSTTIME (qtdemux, qtdemux-&gt;duration);
      res = TRUE;
    } else {
      *duration = GST_CLOCK_TIME_NONE;
<span class="line-modified">!   }</span>
  
    return res;
  }
  
  static gboolean
</pre>
<hr />
<pre>
<span class="line-old-header">*** 901,15 ***</span>
          /* First try to query upstream */
          res = gst_pad_query_default (pad, parent, query);
          if (!res) {
            GstClockTime duration;
            if (gst_qtdemux_get_duration (qtdemux, &amp;duration) &amp;&amp; duration &gt; 0) {
<span class="line-modified">!           gst_query_set_duration (query, GST_FORMAT_TIME, duration);</span>
<span class="line-modified">!           res = TRUE;</span>
          }
        }
<span class="line-removed">-       }</span>
        break;
      }
      case GST_QUERY_CONVERT:{
        GstFormat src_fmt, dest_fmt;
        gint64 src_value, dest_value = 0;
<span class="line-new-header">--- 918,15 ---</span>
          /* First try to query upstream */
          res = gst_pad_query_default (pad, parent, query);
          if (!res) {
            GstClockTime duration;
            if (gst_qtdemux_get_duration (qtdemux, &amp;duration) &amp;&amp; duration &gt; 0) {
<span class="line-modified">!             gst_query_set_duration (query, GST_FORMAT_TIME, duration);</span>
<span class="line-modified">!             res = TRUE;</span>
<span class="line-added">+           }</span>
          }
        }
        break;
      }
      case GST_QUERY_CONVERT:{
        GstFormat src_fmt, dest_fmt;
        gint64 src_value, dest_value = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 933,31 ***</span>
  
        /* try upstream first */
        res = gst_pad_query_default (pad, parent, query);
  
        if (!res) {
<span class="line-modified">!       gst_query_parse_seeking (query, &amp;fmt, NULL, NULL, NULL);</span>
<span class="line-modified">!       if (fmt == GST_FORMAT_TIME) {</span>
            GstClockTime duration;
  
<span class="line-modified">!         gst_qtdemux_get_duration (qtdemux, &amp;duration);</span>
<span class="line-modified">!         seekable = TRUE;</span>
<span class="line-modified">!         if (!qtdemux-&gt;pullbased) {</span>
<span class="line-modified">!           GstQuery *q;</span>
<span class="line-modified">! </span>
<span class="line-modified">!           /* we might be able with help from upstream */</span>
<span class="line-modified">!           seekable = FALSE;</span>
<span class="line-modified">!           q = gst_query_new_seeking (GST_FORMAT_BYTES);</span>
<span class="line-modified">!           if (gst_pad_peer_query (qtdemux-&gt;sinkpad, q)) {</span>
<span class="line-modified">!             gst_query_parse_seeking (q, &amp;fmt, &amp;seekable, NULL, NULL);</span>
<span class="line-modified">!             GST_LOG_OBJECT (qtdemux, &quot;upstream BYTE seekable %d&quot;, seekable);</span>
            }
<span class="line-modified">!           gst_query_unref (q);</span>
          }
<span class="line-removed">-         gst_query_set_seeking (query, GST_FORMAT_TIME, seekable, 0, duration);</span>
<span class="line-removed">-         res = TRUE;</span>
<span class="line-removed">-       }</span>
        }
        break;
      }
      case GST_QUERY_SEGMENT:
      {
<span class="line-new-header">--- 950,31 ---</span>
  
        /* try upstream first */
        res = gst_pad_query_default (pad, parent, query);
  
        if (!res) {
<span class="line-modified">!         gst_query_parse_seeking (query, &amp;fmt, NULL, NULL, NULL);</span>
<span class="line-modified">!         if (fmt == GST_FORMAT_TIME) {</span>
            GstClockTime duration;
  
<span class="line-modified">!           gst_qtdemux_get_duration (qtdemux, &amp;duration);</span>
<span class="line-modified">!           seekable = TRUE;</span>
<span class="line-modified">!           if (!qtdemux-&gt;pullbased) {</span>
<span class="line-modified">!             GstQuery *q;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             /* we might be able with help from upstream */</span>
<span class="line-modified">!             seekable = FALSE;</span>
<span class="line-modified">!             q = gst_query_new_seeking (GST_FORMAT_BYTES);</span>
<span class="line-modified">!             if (gst_pad_peer_query (qtdemux-&gt;sinkpad, q)) {</span>
<span class="line-modified">!               gst_query_parse_seeking (q, &amp;fmt, &amp;seekable, NULL, NULL);</span>
<span class="line-modified">!               GST_LOG_OBJECT (qtdemux, &quot;upstream BYTE seekable %d&quot;, seekable);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             gst_query_unref (q);</span>
            }
<span class="line-modified">!           gst_query_set_seeking (query, GST_FORMAT_TIME, seekable, 0, duration);</span>
<span class="line-added">+           res = TRUE;</span>
          }
        }
        break;
      }
      case GST_QUERY_SEGMENT:
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1017,21 ***</span>
  
  /* push event on all source pads; takes ownership of the event */
  static void
  gst_qtdemux_push_event (GstQTDemux * qtdemux, GstEvent * event)
  {
<span class="line-removed">-   guint n;</span>
    gboolean has_valid_stream = FALSE;
    GstEventType etype = GST_EVENT_TYPE (event);
  
    GST_DEBUG_OBJECT (qtdemux, &quot;pushing %s event on all source pads&quot;,
        GST_EVENT_TYPE_NAME (event));
  
<span class="line-modified">!   for (n = 0; n &lt; qtdemux-&gt;n_streams; n++) {</span>
      GstPad *pad;
<span class="line-modified">!     QtDemuxStream *stream = qtdemux-&gt;streams[n];</span>
<span class="line-modified">!     GST_DEBUG_OBJECT (qtdemux, &quot;pushing on pad %i&quot;, n);</span>
  
      if ((pad = stream-&gt;pad)) {
        has_valid_stream = TRUE;
  
        if (etype == GST_EVENT_EOS) {
<span class="line-new-header">--- 1034,21 ---</span>
  
  /* push event on all source pads; takes ownership of the event */
  static void
  gst_qtdemux_push_event (GstQTDemux * qtdemux, GstEvent * event)
  {
    gboolean has_valid_stream = FALSE;
    GstEventType etype = GST_EVENT_TYPE (event);
<span class="line-added">+   guint i;</span>
  
    GST_DEBUG_OBJECT (qtdemux, &quot;pushing %s event on all source pads&quot;,
        GST_EVENT_TYPE_NAME (event));
  
<span class="line-modified">!   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
      GstPad *pad;
<span class="line-modified">!     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-modified">!     GST_DEBUG_OBJECT (qtdemux, &quot;pushing on track-id %u&quot;, stream-&gt;track_id);</span>
  
      if ((pad = stream-&gt;pad)) {
        has_valid_stream = TRUE;
  
        if (etype == GST_EVENT_EOS) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1051,40 ***</span>
    if (!has_valid_stream &amp;&amp; etype == GST_EVENT_EOS) {
      gst_qtdemux_post_no_playable_stream_error (qtdemux);
    }
  }
  
<span class="line-removed">- /* push a pending newsegment event, if any from the streaming thread */</span>
<span class="line-removed">- static void</span>
<span class="line-removed">- gst_qtdemux_push_pending_newsegment (GstQTDemux * qtdemux)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   if (qtdemux-&gt;pending_newsegment) {</span>
<span class="line-removed">-     gst_qtdemux_push_event (qtdemux, qtdemux-&gt;pending_newsegment);</span>
<span class="line-removed">-     qtdemux-&gt;pending_newsegment = NULL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  typedef struct
  {
    guint64 media_time;
  } FindData;
  
  static gint
  find_func (QtDemuxSample * s1, gint64 * media_time, gpointer user_data)
  {
<span class="line-modified">!   if ((gint64) s1-&gt;timestamp + s1-&gt;pts_offset &gt; *media_time)</span>
      return 1;
<span class="line-modified">!   if ((gint64) s1-&gt;timestamp + s1-&gt;pts_offset == *media_time)</span>
      return 0;
  
    return -1;
  }
  
  /* find the index of the sample that includes the data for @media_time using a
   * binary search.  Only to be called in optimized cases of linear search below.
   *
<span class="line-modified">!  * Returns the index of the sample.</span>
   */
  static guint32
  gst_qtdemux_find_index (GstQTDemux * qtdemux, QtDemuxStream * str,
      guint64 media_time)
  {
<span class="line-new-header">--- 1068,30 ---</span>
    if (!has_valid_stream &amp;&amp; etype == GST_EVENT_EOS) {
      gst_qtdemux_post_no_playable_stream_error (qtdemux);
    }
  }
  
  typedef struct
  {
    guint64 media_time;
  } FindData;
  
  static gint
  find_func (QtDemuxSample * s1, gint64 * media_time, gpointer user_data)
  {
<span class="line-modified">!   if ((gint64) s1-&gt;timestamp &gt; *media_time)</span>
      return 1;
<span class="line-modified">!   if ((gint64) s1-&gt;timestamp == *media_time)</span>
      return 0;
  
    return -1;
  }
  
  /* find the index of the sample that includes the data for @media_time using a
   * binary search.  Only to be called in optimized cases of linear search below.
   *
<span class="line-modified">!  * Returns the index of the sample with the corresponding *DTS*.</span>
   */
  static guint32
  gst_qtdemux_find_index (GstQTDemux * qtdemux, QtDemuxStream * str,
      guint64 media_time)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1170,24 ***</span>
    if (mov_time == sample-&gt;timestamp + sample-&gt;pts_offset)
      return index;
  
    /* use faster search if requested time in already parsed range */
    sample = str-&gt;samples + str-&gt;stbl_index;
<span class="line-modified">!   if (str-&gt;stbl_index &gt;= 0 &amp;&amp;</span>
<span class="line-modified">!       mov_time &lt;= (sample-&gt;timestamp + sample-&gt;pts_offset))</span>
<span class="line-modified">!     return gst_qtdemux_find_index (qtdemux, str, media_time);</span>
  
<span class="line-modified">!   while (index &lt; str-&gt;n_samples - 1) {</span>
<span class="line-modified">!     if (!qtdemux_parse_samples (qtdemux, str, index + 1))</span>
<span class="line-modified">!       goto parse_failed;</span>
  
<span class="line-modified">!     sample = str-&gt;samples + index + 1;</span>
<span class="line-modified">!     if (mov_time &lt; (sample-&gt;timestamp + sample-&gt;pts_offset))</span>
<span class="line-modified">!       break;</span>
  
<span class="line-modified">!     index++;</span>
    }
    return index;
  
    /* ERRORS */
  parse_failed:
    {
<span class="line-new-header">--- 1177,35 ---</span>
    if (mov_time == sample-&gt;timestamp + sample-&gt;pts_offset)
      return index;
  
    /* use faster search if requested time in already parsed range */
    sample = str-&gt;samples + str-&gt;stbl_index;
<span class="line-modified">!   if (str-&gt;stbl_index &gt;= 0 &amp;&amp; mov_time &lt;= sample-&gt;timestamp) {</span>
<span class="line-modified">!     index = gst_qtdemux_find_index (qtdemux, str, media_time);</span>
<span class="line-modified">!     sample = str-&gt;samples + index;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     while (index &lt; str-&gt;n_samples - 1) {</span>
<span class="line-added">+       if (!qtdemux_parse_samples (qtdemux, str, index + 1))</span>
<span class="line-added">+         goto parse_failed;</span>
  
<span class="line-modified">!       sample = str-&gt;samples + index + 1;</span>
<span class="line-modified">!       if (mov_time &lt; sample-&gt;timestamp) {</span>
<span class="line-modified">!         sample = str-&gt;samples + index;</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       }</span>
  
<span class="line-modified">!       index++;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   /* sample-&gt;timestamp is now &lt;= media_time, need to find the corresponding</span>
<span class="line-added">+    * PTS now by looking backwards */</span>
<span class="line-added">+   while (index &gt; 0 &amp;&amp; sample-&gt;timestamp + sample-&gt;pts_offset &gt; mov_time) {</span>
<span class="line-added">+     index--;</span>
<span class="line-added">+     sample = str-&gt;samples + index;</span>
    }
<span class="line-added">+ </span>
    return index;
  
    /* ERRORS */
  parse_failed:
    {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1230,11 ***</span>
        break;
  
      if (next)
        new_index++;
      else
<span class="line-modified">!     new_index--;</span>
    }
  
    if (new_index == str-&gt;n_samples) {
      GST_DEBUG_OBJECT (qtdemux, &quot;no next keyframe&quot;);
      new_index = -1;
<span class="line-new-header">--- 1248,11 ---</span>
        break;
  
      if (next)
        new_index++;
      else
<span class="line-modified">!       new_index--;</span>
    }
  
    if (new_index == str-&gt;n_samples) {
      GST_DEBUG_OBJECT (qtdemux, &quot;no next keyframe&quot;);
      new_index = -1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1249,11 ***</span>
    /* ERRORS */
  parse_failed:
    {
      GST_LOG_OBJECT (qtdemux, &quot;Parsing of index %u failed!&quot;, new_index);
      return -1;
<span class="line-modified">! }</span>
  }
  
  /* find the segment for @time_position for @stream
   *
   * Returns the index of the segment containing @time_position.
<span class="line-new-header">--- 1267,11 ---</span>
    /* ERRORS */
  parse_failed:
    {
      GST_LOG_OBJECT (qtdemux, &quot;Parsing of index %u failed!&quot;, new_index);
      return -1;
<span class="line-modified">!   }</span>
  }
  
  /* find the segment for @time_position for @stream
   *
   * Returns the index of the segment containing @time_position.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1285,14 ***</span>
          seg_idx = i;
          break;
        }
      } else {
        /* Last segment always matches */
<span class="line-modified">!         seg_idx = i;</span>
<span class="line-modified">!         break;</span>
<span class="line-removed">-       }</span>
      }
    return seg_idx;
  }
  
  /* move the stream @str to the sample position @index.
   *
<span class="line-new-header">--- 1303,14 ---</span>
          seg_idx = i;
          break;
        }
      } else {
        /* Last segment always matches */
<span class="line-modified">!       seg_idx = i;</span>
<span class="line-modified">!       break;</span>
      }
<span class="line-added">+   }</span>
    return seg_idx;
  }
  
  /* move the stream @str to the sample position @index.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1322,27 ***</span>
  gst_qtdemux_adjust_seek (GstQTDemux * qtdemux, gint64 desired_time,
      gboolean use_sparse, gboolean next, gint64 * key_time, gint64 * key_offset)
  {
    guint64 min_offset;
    gint64 min_byte_offset = -1;
<span class="line-modified">!   gint n;</span>
  
    min_offset = desired_time;
  
    /* for each stream, find the index of the sample in the segment
     * and move back to the previous keyframe. */
<span class="line-modified">!   for (n = 0; n &lt; qtdemux-&gt;n_streams; n++) {</span>
      QtDemuxStream *str;
      guint32 index, kindex;
      guint32 seg_idx;
      GstClockTime media_start;
      GstClockTime media_time;
      GstClockTime seg_time;
      QtDemuxSegment *seg;
      gboolean empty_segment = FALSE;
  
<span class="line-modified">!     str = qtdemux-&gt;streams[n];</span>
  
      if (CUR_STREAM (str)-&gt;sparse &amp;&amp; !use_sparse)
        continue;
  
      seg_idx = gst_qtdemux_find_segment (qtdemux, str, desired_time);
<span class="line-new-header">--- 1340,27 ---</span>
  gst_qtdemux_adjust_seek (GstQTDemux * qtdemux, gint64 desired_time,
      gboolean use_sparse, gboolean next, gint64 * key_time, gint64 * key_offset)
  {
    guint64 min_offset;
    gint64 min_byte_offset = -1;
<span class="line-modified">!   guint i;</span>
  
    min_offset = desired_time;
  
    /* for each stream, find the index of the sample in the segment
     * and move back to the previous keyframe. */
<span class="line-modified">!   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
      QtDemuxStream *str;
      guint32 index, kindex;
      guint32 seg_idx;
      GstClockTime media_start;
      GstClockTime media_time;
      GstClockTime seg_time;
      QtDemuxSegment *seg;
      gboolean empty_segment = FALSE;
  
<span class="line-modified">!     str = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
  
      if (CUR_STREAM (str)-&gt;sparse &amp;&amp; !use_sparse)
        continue;
  
      seg_idx = gst_qtdemux_find_segment (qtdemux, str, desired_time);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1383,44 ***</span>
      if (next &amp;&amp; QTSAMPLE_PTS_NO_CSLG (str, &amp;str-&gt;samples[index]) &lt; media_start
          &amp;&amp; index &lt; str-&gt;stbl_index)
        index++;
  
      if (!empty_segment) {
<span class="line-modified">!     /* find previous keyframe */</span>
        kindex = gst_qtdemux_find_keyframe (qtdemux, str, index, next);
  
        /* we will settle for one before if none found after */
        if (next &amp;&amp; kindex == -1)
          kindex = gst_qtdemux_find_keyframe (qtdemux, str, index, FALSE);
  
<span class="line-modified">!     /* if the keyframe is at a different position, we need to update the</span>
<span class="line-modified">!      * requested seek time */</span>
<span class="line-modified">!     if (index != kindex) {</span>
<span class="line-modified">!       index = kindex;</span>
  
<span class="line-modified">!       /* get timestamp of keyframe */</span>
          media_time = QTSAMPLE_PTS_NO_CSLG (str, &amp;str-&gt;samples[kindex]);
          GST_DEBUG_OBJECT (qtdemux,
              &quot;keyframe at %u with time %&quot; GST_TIME_FORMAT &quot; at offset %&quot;
              G_GUINT64_FORMAT, kindex, GST_TIME_ARGS (media_time),
              str-&gt;samples[kindex].offset);
  
<span class="line-modified">!       /* keyframes in the segment get a chance to change the</span>
<span class="line-modified">!        * desired_offset. keyframes out of the segment are</span>
<span class="line-modified">!        * ignored. */</span>
<span class="line-modified">!       if (media_time &gt;= seg-&gt;media_start) {</span>
            GstClockTime seg_time;
  
<span class="line-modified">!         /* this keyframe is inside the segment, convert back to</span>
<span class="line-modified">!          * segment time */</span>
<span class="line-modified">!         seg_time = (media_time - seg-&gt;media_start) + seg-&gt;time;</span>
            if ((!next &amp;&amp; (seg_time &lt; min_offset)) ||
                (next &amp;&amp; (seg_time &gt; min_offset)))
<span class="line-modified">!           min_offset = seg_time;</span>
        }
      }
<span class="line-removed">-     }</span>
  
      if (min_byte_offset &lt; 0 || str-&gt;samples[index].offset &lt; min_byte_offset)
        min_byte_offset = str-&gt;samples[index].offset;
    }
  
<span class="line-new-header">--- 1401,44 ---</span>
      if (next &amp;&amp; QTSAMPLE_PTS_NO_CSLG (str, &amp;str-&gt;samples[index]) &lt; media_start
          &amp;&amp; index &lt; str-&gt;stbl_index)
        index++;
  
      if (!empty_segment) {
<span class="line-modified">!       /* find previous keyframe */</span>
        kindex = gst_qtdemux_find_keyframe (qtdemux, str, index, next);
  
        /* we will settle for one before if none found after */
        if (next &amp;&amp; kindex == -1)
          kindex = gst_qtdemux_find_keyframe (qtdemux, str, index, FALSE);
  
<span class="line-modified">!       /* if the keyframe is at a different position, we need to update the</span>
<span class="line-modified">!        * requested seek time */</span>
<span class="line-modified">!       if (index != kindex) {</span>
<span class="line-modified">!         index = kindex;</span>
  
<span class="line-modified">!         /* get timestamp of keyframe */</span>
          media_time = QTSAMPLE_PTS_NO_CSLG (str, &amp;str-&gt;samples[kindex]);
          GST_DEBUG_OBJECT (qtdemux,
              &quot;keyframe at %u with time %&quot; GST_TIME_FORMAT &quot; at offset %&quot;
              G_GUINT64_FORMAT, kindex, GST_TIME_ARGS (media_time),
              str-&gt;samples[kindex].offset);
  
<span class="line-modified">!         /* keyframes in the segment get a chance to change the</span>
<span class="line-modified">!          * desired_offset. keyframes out of the segment are</span>
<span class="line-modified">!          * ignored. */</span>
<span class="line-modified">!         if (media_time &gt;= seg-&gt;media_start) {</span>
            GstClockTime seg_time;
  
<span class="line-modified">!           /* this keyframe is inside the segment, convert back to</span>
<span class="line-modified">!            * segment time */</span>
<span class="line-modified">!           seg_time = (media_time - seg-&gt;media_start) + seg-&gt;time;</span>
            if ((!next &amp;&amp; (seg_time &lt; min_offset)) ||
                (next &amp;&amp; (seg_time &gt; min_offset)))
<span class="line-modified">!             min_offset = seg_time;</span>
<span class="line-added">+         }</span>
        }
      }
  
      if (min_byte_offset &lt; 0 || str-&gt;samples[index].offset &lt; min_byte_offset)
        min_byte_offset = str-&gt;samples[index].offset;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1507,12 ***</span>
  
    GST_DEBUG_OBJECT (qtdemux, &quot;Pushing BYTE seek rate %g, &quot;
        &quot;start %&quot; G_GINT64_FORMAT &quot;, stop %&quot; G_GINT64_FORMAT, rate, byte_cur,
        stop);
  
<span class="line-modified">!     GST_OBJECT_LOCK (qtdemux);</span>
<span class="line-modified">!     qtdemux-&gt;seek_offset = byte_cur;</span>
    if (!(flags &amp; GST_SEEK_FLAG_KEY_UNIT)) {
      qtdemux-&gt;push_seek_start = cur;
    } else {
      qtdemux-&gt;push_seek_start = key_cur;
    }
<span class="line-new-header">--- 1525,12 ---</span>
  
    GST_DEBUG_OBJECT (qtdemux, &quot;Pushing BYTE seek rate %g, &quot;
        &quot;start %&quot; G_GINT64_FORMAT &quot;, stop %&quot; G_GINT64_FORMAT, rate, byte_cur,
        stop);
  
<span class="line-modified">!   GST_OBJECT_LOCK (qtdemux);</span>
<span class="line-modified">!   qtdemux-&gt;seek_offset = byte_cur;</span>
    if (!(flags &amp; GST_SEEK_FLAG_KEY_UNIT)) {
      qtdemux-&gt;push_seek_start = cur;
    } else {
      qtdemux-&gt;push_seek_start = key_cur;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1522,10 ***</span>
<span class="line-new-header">--- 1540,11 ---</span>
    } else {
      qtdemux-&gt;push_seek_stop = original_stop;
    }
    GST_OBJECT_UNLOCK (qtdemux);
  
<span class="line-added">+   qtdemux-&gt;segment_seqnum = seqnum;</span>
    /* BYTE seek event */
  #ifdef GSTREAMER_LITE
    new_event = gst_event_new_seek(rate, GST_FORMAT_BYTES, flags, cur_type, byte_cur,
        stop_type, stop);
    gst_event_set_seqnum(new_event, seqnum);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1580,11 ***</span>
  static gboolean
  gst_qtdemux_perform_seek (GstQTDemux * qtdemux, GstSegment * segment,
      guint32 seqnum, GstSeekFlags flags)
  {
    gint64 desired_offset;
<span class="line-modified">!   gint n;</span>
  
    desired_offset = segment-&gt;position;
  
    GST_DEBUG_OBJECT (qtdemux, &quot;seeking to %&quot; GST_TIME_FORMAT,
        GST_TIME_ARGS (desired_offset));
<span class="line-new-header">--- 1599,11 ---</span>
  static gboolean
  gst_qtdemux_perform_seek (GstQTDemux * qtdemux, GstSegment * segment,
      guint32 seqnum, GstSeekFlags flags)
  {
    gint64 desired_offset;
<span class="line-modified">!   guint i;</span>
  
    desired_offset = segment-&gt;position;
  
    GST_DEBUG_OBJECT (qtdemux, &quot;seeking to %&quot; GST_TIME_FORMAT,
        GST_TIME_ARGS (desired_offset));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1610,12 ***</span>
    }
  
    /* and set all streams to the final position */
    gst_flow_combiner_reset (qtdemux-&gt;flowcombiner);
    qtdemux-&gt;segment_seqnum = seqnum;
<span class="line-modified">!   for (n = 0; n &lt; qtdemux-&gt;n_streams; n++) {</span>
<span class="line-modified">!     QtDemuxStream *stream = qtdemux-&gt;streams[n];</span>
  
      stream-&gt;time_position = desired_offset;
      stream-&gt;accumulated_base = 0;
      stream-&gt;sample_index = -1;
      stream-&gt;offset_in_sample = 0;
<span class="line-new-header">--- 1629,12 ---</span>
    }
  
    /* and set all streams to the final position */
    gst_flow_combiner_reset (qtdemux-&gt;flowcombiner);
    qtdemux-&gt;segment_seqnum = seqnum;
<span class="line-modified">!   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified">!     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
  
      stream-&gt;time_position = desired_offset;
      stream-&gt;accumulated_base = 0;
      stream-&gt;sample_index = -1;
      stream-&gt;offset_in_sample = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1628,13 ***</span>
    segment-&gt;position = desired_offset;
    segment-&gt;time = desired_offset;
    if (segment-&gt;rate &gt;= 0) {
      segment-&gt;start = desired_offset;
  
<span class="line-modified">!   /* we stop at the end */</span>
<span class="line-modified">!   if (segment-&gt;stop == -1)</span>
<span class="line-modified">!     segment-&gt;stop = segment-&gt;duration;</span>
    } else {
      segment-&gt;stop = desired_offset;
    }
  
    if (qtdemux-&gt;fragmented)
<span class="line-new-header">--- 1647,13 ---</span>
    segment-&gt;position = desired_offset;
    segment-&gt;time = desired_offset;
    if (segment-&gt;rate &gt;= 0) {
      segment-&gt;start = desired_offset;
  
<span class="line-modified">!     /* we stop at the end */</span>
<span class="line-modified">!     if (segment-&gt;stop == -1)</span>
<span class="line-modified">!       segment-&gt;stop = segment-&gt;duration;</span>
    } else {
      segment-&gt;stop = desired_offset;
    }
  
    if (qtdemux-&gt;fragmented)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1709,11 ***</span>
        ret = FALSE;
        GST_ERROR_OBJECT (qtdemux, &quot;inconsistent seek values, doing nothing&quot;);
      } else {
        /* now do the seek */
        ret = gst_qtdemux_perform_seek (qtdemux, &amp;seeksegment, seqnum, flags);
<span class="line-modified">!   }</span>
    } else {
      /* now do the seek */
      ret = gst_qtdemux_perform_seek (qtdemux, &amp;seeksegment, seqnum, flags);
    }
  
<span class="line-new-header">--- 1728,11 ---</span>
        ret = FALSE;
        GST_ERROR_OBJECT (qtdemux, &quot;inconsistent seek values, doing nothing&quot;);
      } else {
        /* now do the seek */
        ret = gst_qtdemux_perform_seek (qtdemux, &amp;seeksegment, seqnum, flags);
<span class="line-modified">!     }</span>
    } else {
      /* now do the seek */
      ret = gst_qtdemux_perform_seek (qtdemux, &amp;seeksegment, seqnum, flags);
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1723,11 ***</span>
      if (seqnum != GST_SEQNUM_INVALID)
        gst_event_set_seqnum (flush_event, seqnum);
  
      gst_pad_push_event (qtdemux-&gt;sinkpad, gst_event_ref (flush_event));
      gst_qtdemux_push_event (qtdemux, flush_event);
<span class="line-modified">!     }</span>
  
    /* commit the new segment */
    memcpy (&amp;qtdemux-&gt;segment, &amp;seeksegment, sizeof (GstSegment));
  
    if (qtdemux-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
<span class="line-new-header">--- 1742,11 ---</span>
      if (seqnum != GST_SEQNUM_INVALID)
        gst_event_set_seqnum (flush_event, seqnum);
  
      gst_pad_push_event (qtdemux-&gt;sinkpad, gst_event_ref (flush_event));
      gst_qtdemux_push_event (qtdemux, flush_event);
<span class="line-modified">!   }</span>
  
    /* commit the new segment */
    memcpy (&amp;qtdemux-&gt;segment, &amp;seeksegment, sizeof (GstSegment));
  
    if (qtdemux-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1760,25 ***</span>
    guint i;
  
    GST_DEBUG_OBJECT (qtdemux, &quot;collecting all metadata for all streams&quot;);
  
    /* Build complete index */
<span class="line-modified">!   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
<span class="line-modified">!     QtDemuxStream *stream = qtdemux-&gt;streams[i];</span>
  
<span class="line-modified">!     if (!qtdemux_parse_samples (qtdemux, stream, stream-&gt;n_samples - 1))</span>
<span class="line-modified">!       goto parse_error;</span>
    }
<span class="line-removed">-   return TRUE;</span>
  
<span class="line-modified">!   /* ERRORS */</span>
<span class="line-removed">- parse_error:</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     GST_LOG_OBJECT (qtdemux,</span>
<span class="line-removed">-         &quot;Building complete index of stream %u for seeking failed!&quot;, i);</span>
<span class="line-removed">-     return FALSE;</span>
<span class="line-removed">-   }</span>
  }
  
  static gboolean
  gst_qtdemux_handle_src_event (GstPad * pad, GstObject * parent,
      GstEvent * event)
<span class="line-new-header">--- 1779,22 ---</span>
    guint i;
  
    GST_DEBUG_OBJECT (qtdemux, &quot;collecting all metadata for all streams&quot;);
  
    /* Build complete index */
<span class="line-modified">!   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified">!     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
  
<span class="line-modified">!     if (!qtdemux_parse_samples (qtdemux, stream, stream-&gt;n_samples - 1)) {</span>
<span class="line-modified">!       GST_LOG_OBJECT (qtdemux,</span>
<span class="line-added">+           &quot;Building complete index of track-id %u for seeking failed!&quot;,</span>
<span class="line-added">+           stream-&gt;track_id);</span>
<span class="line-added">+       return FALSE;</span>
<span class="line-added">+     }</span>
    }
  
<span class="line-modified">!   return TRUE;</span>
  }
  
  static gboolean
  gst_qtdemux_handle_src_event (GstPad * pad, GstObject * parent,
      GstEvent * event)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1792,10 ***</span>
<span class="line-new-header">--- 1808,12 ---</span>
  #ifndef GST_DISABLE_GST_DEBUG
        GstClockTime ts = gst_util_get_timestamp ();
  #endif
        guint32 seqnum = gst_event_get_seqnum (event);
  
<span class="line-added">+       qtdemux-&gt;received_seek = TRUE;</span>
<span class="line-added">+ </span>
        if (seqnum == qtdemux-&gt;segment_seqnum) {
          GST_LOG_OBJECT (pad,
              &quot;Drop duplicated SEEK event seqnum %&quot; G_GUINT32_FORMAT, seqnum);
          gst_event_unref (event);
          return TRUE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1822,11 ***</span>
        if (qtdemux-&gt;pullbased) {
          res = gst_qtdemux_do_seek (qtdemux, pad, event);
        } else if (gst_pad_push_event (qtdemux-&gt;sinkpad, gst_event_ref (event))) {
          GST_DEBUG_OBJECT (qtdemux, &quot;Upstream successfully seeked&quot;);
          res = TRUE;
<span class="line-modified">!       } else if (qtdemux-&gt;state == QTDEMUX_STATE_MOVIE &amp;&amp; qtdemux-&gt;n_streams</span>
            &amp;&amp; !qtdemux-&gt;fragmented) {
          res = gst_qtdemux_do_push_seek (qtdemux, pad, event);
        } else {
          GST_DEBUG_OBJECT (qtdemux,
              &quot;ignoring seek in push mode in current state&quot;);
<span class="line-new-header">--- 1840,12 ---</span>
        if (qtdemux-&gt;pullbased) {
          res = gst_qtdemux_do_seek (qtdemux, pad, event);
        } else if (gst_pad_push_event (qtdemux-&gt;sinkpad, gst_event_ref (event))) {
          GST_DEBUG_OBJECT (qtdemux, &quot;Upstream successfully seeked&quot;);
          res = TRUE;
<span class="line-modified">!       } else if (qtdemux-&gt;state == QTDEMUX_STATE_MOVIE</span>
<span class="line-added">+           &amp;&amp; QTDEMUX_N_STREAMS (qtdemux)</span>
            &amp;&amp; !qtdemux-&gt;fragmented) {
          res = gst_qtdemux_do_push_seek (qtdemux, pad, event);
        } else {
          GST_DEBUG_OBJECT (qtdemux,
              &quot;ignoring seek in push mode in current state&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1868,24 ***</span>
   * @_stream and @_index. */
  static void
  gst_qtdemux_find_sample (GstQTDemux * qtdemux, gint64 byte_pos, gboolean fw,
      gboolean set, QtDemuxStream ** _stream, gint * _index, gint64 * _time)
  {
<span class="line-modified">!   gint i, n, index;</span>
    gint64 time, min_time;
    QtDemuxStream *stream;
  
    min_time = -1;
    stream = NULL;
    index = -1;
  
<span class="line-modified">!   for (n = 0; n &lt; qtdemux-&gt;n_streams; ++n) {</span>
      QtDemuxStream *str;
      gint inc;
      gboolean set_sample;
  
<span class="line-modified">!     str = qtdemux-&gt;streams[n];</span>
      set_sample = !set;
  
      if (fw) {
        i = 0;
        inc = 1;
<span class="line-new-header">--- 1887,25 ---</span>
   * @_stream and @_index. */
  static void
  gst_qtdemux_find_sample (GstQTDemux * qtdemux, gint64 byte_pos, gboolean fw,
      gboolean set, QtDemuxStream ** _stream, gint * _index, gint64 * _time)
  {
<span class="line-modified">!   gint i, index;</span>
    gint64 time, min_time;
    QtDemuxStream *stream;
<span class="line-added">+   gint iter;</span>
  
    min_time = -1;
    stream = NULL;
    index = -1;
  
<span class="line-modified">!   for (iter = 0; iter &lt; QTDEMUX_N_STREAMS (qtdemux); iter++) {</span>
      QtDemuxStream *str;
      gint inc;
      gboolean set_sample;
  
<span class="line-modified">!     str = QTDEMUX_NTH_STREAM (qtdemux, iter);</span>
      set_sample = !set;
  
      if (fw) {
        i = 0;
        inc = 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1902,15 ***</span>
          continue;
  
        if (!fw &amp;&amp; (str-&gt;samples[i].offset + str-&gt;samples[i].size &gt; byte_pos))
          continue;
  
<span class="line-modified">!         /* move stream to first available sample */</span>
<span class="line-modified">!         if (set) {</span>
<span class="line-modified">!           gst_qtdemux_move_stream (qtdemux, str, i);</span>
<span class="line-modified">!           set_sample = TRUE;</span>
<span class="line-modified">!         }</span>
  
        /* avoid index from sparse streams since they might be far away */
        if (!CUR_STREAM (str)-&gt;sparse) {
          /* determine min/max time */
          time = QTSAMPLE_PTS (str, &amp;str-&gt;samples[i]);
<span class="line-new-header">--- 1922,15 ---</span>
          continue;
  
        if (!fw &amp;&amp; (str-&gt;samples[i].offset + str-&gt;samples[i].size &gt; byte_pos))
          continue;
  
<span class="line-modified">!       /* move stream to first available sample */</span>
<span class="line-modified">!       if (set) {</span>
<span class="line-modified">!         gst_qtdemux_move_stream (qtdemux, str, i);</span>
<span class="line-modified">!         set_sample = TRUE;</span>
<span class="line-modified">!       }</span>
  
        /* avoid index from sparse streams since they might be far away */
        if (!CUR_STREAM (str)-&gt;sparse) {
          /* determine min/max time */
          time = QTSAMPLE_PTS (str, &amp;str-&gt;samples[i]);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1925,12 ***</span>
              (!fw &amp;&amp; (str-&gt;samples[i].offset &gt; stream-&gt;samples[index].offset))) {
            stream = str;
            index = i;
          }
        }
<span class="line-modified">!         break;</span>
<span class="line-modified">!       }</span>
  
      /* no sample for this stream, mark eos */
      if (!set_sample)
        gst_qtdemux_move_stream (qtdemux, str, str-&gt;n_samples);
    }
<span class="line-new-header">--- 1945,12 ---</span>
              (!fw &amp;&amp; (str-&gt;samples[i].offset &gt; stream-&gt;samples[index].offset))) {
            stream = str;
            index = i;
          }
        }
<span class="line-modified">!       break;</span>
<span class="line-modified">!     }</span>
  
      /* no sample for this stream, mark eos */
      if (!set_sample)
        gst_qtdemux_move_stream (qtdemux, str, str-&gt;n_samples);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1941,16 ***</span>
      *_stream = stream;
    if (_index)
      *_index = index;
  }
  
  static QtDemuxStream *
<span class="line-modified">! _create_stream (void)</span>
  {
    QtDemuxStream *stream;
  
    stream = g_new0 (QtDemuxStream, 1);
    /* new streams always need a discont */
    stream-&gt;discont = TRUE;
    /* we enable clipping for raw audio/video streams */
    stream-&gt;need_clip = FALSE;
    stream-&gt;need_process = FALSE;
<span class="line-new-header">--- 1961,64 ---</span>
      *_stream = stream;
    if (_index)
      *_index = index;
  }
  
<span class="line-added">+ /* Copied from mpegtsbase code */</span>
<span class="line-added">+ /* FIXME: replace this function when we add new util function for stream-id creation */</span>
<span class="line-added">+ static gchar *</span>
<span class="line-added">+ _get_upstream_id (GstQTDemux * demux)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   gchar *upstream_id = gst_pad_get_stream_id (demux-&gt;sinkpad);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!upstream_id) {</span>
<span class="line-added">+     /* Try to create one from the upstream URI, else use a randome number */</span>
<span class="line-added">+     GstQuery *query;</span>
<span class="line-added">+     gchar *uri = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* Try to generate one from the URI query and</span>
<span class="line-added">+      * if it fails take a random number instead */</span>
<span class="line-added">+     query = gst_query_new_uri ();</span>
<span class="line-added">+     if (gst_element_query (GST_ELEMENT_CAST (demux), query)) {</span>
<span class="line-added">+       gst_query_parse_uri (query, &amp;uri);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (uri) {</span>
<span class="line-added">+       GChecksum *cs;</span>
<span class="line-added">+ </span>
<span class="line-added">+       /* And then generate an SHA256 sum of the URI */</span>
<span class="line-added">+       cs = g_checksum_new (G_CHECKSUM_SHA256);</span>
<span class="line-added">+       g_checksum_update (cs, (const guchar *) uri, strlen (uri));</span>
<span class="line-added">+       g_free (uri);</span>
<span class="line-added">+       upstream_id = g_strdup (g_checksum_get_string (cs));</span>
<span class="line-added">+       g_checksum_free (cs);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       /* Just get some random number if the URI query fails */</span>
<span class="line-added">+       GST_FIXME_OBJECT (demux, &quot;Creating random stream-id, consider &quot;</span>
<span class="line-added">+           &quot;implementing a deterministic way of creating a stream-id&quot;);</span>
<span class="line-added">+       upstream_id =</span>
<span class="line-added">+           g_strdup_printf (&quot;%08x%08x%08x%08x&quot;, g_random_int (), g_random_int (),</span>
<span class="line-added">+           g_random_int (), g_random_int ());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     gst_query_unref (query);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return upstream_id;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static QtDemuxStream *
<span class="line-modified">! _create_stream (GstQTDemux * demux, guint32 track_id)</span>
  {
    QtDemuxStream *stream;
<span class="line-added">+   gchar *upstream_id;</span>
  
    stream = g_new0 (QtDemuxStream, 1);
<span class="line-added">+   stream-&gt;demux = demux;</span>
<span class="line-added">+   stream-&gt;track_id = track_id;</span>
<span class="line-added">+   upstream_id = _get_upstream_id (demux);</span>
<span class="line-added">+   stream-&gt;stream_id = g_strdup_printf (&quot;%s/%03u&quot;, upstream_id, track_id);</span>
<span class="line-added">+   g_free (upstream_id);</span>
    /* new streams always need a discont */
    stream-&gt;discont = TRUE;
    /* we enable clipping for raw audio/video streams */
    stream-&gt;need_clip = FALSE;
    stream-&gt;need_process = FALSE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1970,10 ***</span>
<span class="line-new-header">--- 2038,13 ---</span>
    stream-&gt;duration_last_moof = 0;
    stream-&gt;alignment = 1;
    stream-&gt;stream_tags = gst_tag_list_new_empty ();
    gst_tag_list_set_scope (stream-&gt;stream_tags, GST_TAG_SCOPE_STREAM);
    g_queue_init (&amp;stream-&gt;protection_scheme_event_queue);
<span class="line-added">+   stream-&gt;ref_count = 1;</span>
<span class="line-added">+   /* consistent default for push based mode */</span>
<span class="line-added">+   gst_segment_init (&amp;stream-&gt;segment, GST_FORMAT_TIME);</span>
    return stream;
  }
  
  static gboolean
  gst_qtdemux_setcaps (GstQTDemux * demux, GstCaps * caps)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1992,11 ***</span>
      const GValue *value;
  
      demux-&gt;fragmented = TRUE;
      demux-&gt;mss_mode = TRUE;
  
<span class="line-modified">!     if (demux-&gt;n_streams &gt; 1) {</span>
        /* can&#39;t do this, we can only renegotiate for another mss format */
        return FALSE;
      }
  
      value = gst_structure_get_value (structure, &quot;media-caps&quot;);
<span class="line-new-header">--- 2063,11 ---</span>
      const GValue *value;
  
      demux-&gt;fragmented = TRUE;
      demux-&gt;mss_mode = TRUE;
  
<span class="line-modified">!     if (QTDEMUX_N_STREAMS (demux) &gt; 1) {</span>
        /* can&#39;t do this, we can only renegotiate for another mss format */
        return FALSE;
      }
  
      value = gst_structure_get_value (structure, &quot;media-caps&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2004,20 ***</span>
      if (value) {
        const GValue *timescale_v;
  
        /* TODO update when stream changes during playback */
  
<span class="line-modified">!       if (demux-&gt;n_streams == 0) {</span>
<span class="line-modified">!         stream = _create_stream ();</span>
<span class="line-modified">!         demux-&gt;streams[demux-&gt;n_streams] = stream;</span>
<span class="line-removed">-         demux-&gt;n_streams = 1;</span>
          /* mss has no stsd/stsd entry, use id 0 as default */
          stream-&gt;stsd_entries_length = 1;
          stream-&gt;stsd_sample_description_id = stream-&gt;cur_stsd_entry_index = 0;
          stream-&gt;stsd_entries = g_new0 (QtDemuxStreamStsdEntry, 1);
        } else {
<span class="line-modified">!         stream = demux-&gt;streams[0];</span>
        }
  
        timescale_v = gst_structure_get_value (structure, &quot;timescale&quot;);
        if (timescale_v) {
          stream-&gt;timescale = g_value_get_uint64 (timescale_v);
<span class="line-new-header">--- 2075,19 ---</span>
      if (value) {
        const GValue *timescale_v;
  
        /* TODO update when stream changes during playback */
  
<span class="line-modified">!       if (QTDEMUX_N_STREAMS (demux) == 0) {</span>
<span class="line-modified">!         stream = _create_stream (demux, 1);</span>
<span class="line-modified">!         g_ptr_array_add (demux-&gt;active_streams, stream);</span>
          /* mss has no stsd/stsd entry, use id 0 as default */
          stream-&gt;stsd_entries_length = 1;
          stream-&gt;stsd_sample_description_id = stream-&gt;cur_stsd_entry_index = 0;
          stream-&gt;stsd_entries = g_new0 (QtDemuxStreamStsdEntry, 1);
        } else {
<span class="line-modified">!         stream = QTDEMUX_NTH_STREAM (demux, 0);</span>
        }
  
        timescale_v = gst_structure_get_value (structure, &quot;timescale&quot;);
        if (timescale_v) {
          stream-&gt;timescale = g_value_get_uint64 (timescale_v);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2062,11 ***</span>
  }
  
  static void
  gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard)
  {
<span class="line-modified">!   gint n;</span>
  
    GST_DEBUG_OBJECT (qtdemux, &quot;Resetting demux&quot;);
    gst_pad_stop_task (qtdemux-&gt;sinkpad);
  
    if (hard || qtdemux-&gt;upstream_format_is_time) {
<span class="line-new-header">--- 2132,11 ---</span>
  }
  
  static void
  gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard)
  {
<span class="line-modified">!   gint i;</span>
  
    GST_DEBUG_OBJECT (qtdemux, &quot;Resetting demux&quot;);
    gst_pad_stop_task (qtdemux-&gt;sinkpad);
  
    if (hard || qtdemux-&gt;upstream_format_is_time) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2091,11 ***</span>
        gst_buffer_unref (qtdemux-&gt;comp_brands);
      qtdemux-&gt;comp_brands = NULL;
      qtdemux-&gt;last_moov_offset = -1;
      if (qtdemux-&gt;moov_node_compressed) {
        g_node_destroy (qtdemux-&gt;moov_node_compressed);
<span class="line-modified">!     if (qtdemux-&gt;moov_node)</span>
          g_free (qtdemux-&gt;moov_node-&gt;data);
      }
      qtdemux-&gt;moov_node_compressed = NULL;
      if (qtdemux-&gt;moov_node)
        g_node_destroy (qtdemux-&gt;moov_node);
<span class="line-new-header">--- 2161,11 ---</span>
        gst_buffer_unref (qtdemux-&gt;comp_brands);
      qtdemux-&gt;comp_brands = NULL;
      qtdemux-&gt;last_moov_offset = -1;
      if (qtdemux-&gt;moov_node_compressed) {
        g_node_destroy (qtdemux-&gt;moov_node_compressed);
<span class="line-modified">!       if (qtdemux-&gt;moov_node)</span>
          g_free (qtdemux-&gt;moov_node-&gt;data);
      }
      qtdemux-&gt;moov_node_compressed = NULL;
      if (qtdemux-&gt;moov_node)
        g_node_destroy (qtdemux-&gt;moov_node);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2108,13 ***</span>
      if (qtdemux-&gt;element_index)
        gst_object_unref (qtdemux-&gt;element_index);
      qtdemux-&gt;element_index = NULL;
  #endif
      qtdemux-&gt;major_brand = 0;
<span class="line-removed">-     if (qtdemux-&gt;pending_newsegment)</span>
<span class="line-removed">-       gst_event_unref (qtdemux-&gt;pending_newsegment);</span>
<span class="line-removed">-     qtdemux-&gt;pending_newsegment = NULL;</span>
      qtdemux-&gt;upstream_format_is_time = FALSE;
      qtdemux-&gt;upstream_seekable = FALSE;
      qtdemux-&gt;upstream_size = 0;
  
      qtdemux-&gt;fragment_start = -1;
<span class="line-new-header">--- 2178,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2126,54 ***</span>
      qtdemux-&gt;group_id = G_MAXUINT;
  
      g_queue_foreach (&amp;qtdemux-&gt;protection_event_queue, (GFunc) gst_event_unref,
          NULL);
      g_queue_clear (&amp;qtdemux-&gt;protection_event_queue);
    }
    qtdemux-&gt;offset = 0;
    gst_adapter_clear (qtdemux-&gt;adapter);
    gst_segment_init (&amp;qtdemux-&gt;segment, GST_FORMAT_TIME);
<span class="line-modified">!   qtdemux-&gt;segment_seqnum = GST_SEQNUM_INVALID;</span>
  
    if (hard) {
<span class="line-modified">!     for (n = 0; n &lt; qtdemux-&gt;n_streams; n++) {</span>
<span class="line-modified">!       gst_qtdemux_stream_free (qtdemux, qtdemux-&gt;streams[n]);</span>
<span class="line-modified">!       qtdemux-&gt;streams[n] = NULL;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     qtdemux-&gt;n_streams = 0;</span>
      qtdemux-&gt;n_video_streams = 0;
      qtdemux-&gt;n_audio_streams = 0;
      qtdemux-&gt;n_sub_streams = 0;
      qtdemux-&gt;exposed = FALSE;
      qtdemux-&gt;fragmented = FALSE;
      qtdemux-&gt;mss_mode = FALSE;
      gst_caps_replace (&amp;qtdemux-&gt;media_caps, NULL);
      qtdemux-&gt;timescale = 0;
      qtdemux-&gt;got_moov = FALSE;
      if (qtdemux-&gt;protection_system_ids) {
        g_ptr_array_free (qtdemux-&gt;protection_system_ids, TRUE);
        qtdemux-&gt;protection_system_ids = NULL;
      }
    } else if (qtdemux-&gt;mss_mode) {
      gst_flow_combiner_reset (qtdemux-&gt;flowcombiner);
<span class="line-modified">!     for (n = 0; n &lt; qtdemux-&gt;n_streams; n++)</span>
<span class="line-modified">!       gst_qtdemux_stream_clear (qtdemux, qtdemux-&gt;streams[n]);</span>
    } else {
      gst_flow_combiner_reset (qtdemux-&gt;flowcombiner);
<span class="line-modified">!     for (n = 0; n &lt; qtdemux-&gt;n_streams; n++) {</span>
<span class="line-modified">!       qtdemux-&gt;streams[n]-&gt;sent_eos = FALSE;</span>
<span class="line-modified">!       qtdemux-&gt;streams[n]-&gt;time_position = 0;</span>
<span class="line-modified">!       qtdemux-&gt;streams[n]-&gt;accumulated_base = 0;</span>
      }
<span class="line-removed">-     if (!qtdemux-&gt;pending_newsegment) {</span>
<span class="line-removed">-       qtdemux-&gt;pending_newsegment = gst_event_new_segment (&amp;qtdemux-&gt;segment);</span>
<span class="line-removed">-       if (qtdemux-&gt;segment_seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-removed">-         gst_event_set_seqnum (qtdemux-&gt;pending_newsegment,</span>
<span class="line-removed">-             qtdemux-&gt;segment_seqnum);</span>
    }
  }
<span class="line-removed">- }</span>
  
  
  /* Maps the @segment to the qt edts internal segments and pushes
   * the correspnding segment event.
   *
<span class="line-new-header">--- 2193,61 ---</span>
      qtdemux-&gt;group_id = G_MAXUINT;
  
      g_queue_foreach (&amp;qtdemux-&gt;protection_event_queue, (GFunc) gst_event_unref,
          NULL);
      g_queue_clear (&amp;qtdemux-&gt;protection_event_queue);
<span class="line-added">+ </span>
<span class="line-added">+     qtdemux-&gt;received_seek = FALSE;</span>
<span class="line-added">+     qtdemux-&gt;first_moof_already_parsed = FALSE;</span>
    }
    qtdemux-&gt;offset = 0;
    gst_adapter_clear (qtdemux-&gt;adapter);
    gst_segment_init (&amp;qtdemux-&gt;segment, GST_FORMAT_TIME);
<span class="line-modified">!   qtdemux-&gt;need_segment = TRUE;</span>
  
    if (hard) {
<span class="line-modified">!     qtdemux-&gt;segment_seqnum = GST_SEQNUM_INVALID;</span>
<span class="line-modified">!     g_ptr_array_set_size (qtdemux-&gt;active_streams, 0);</span>
<span class="line-modified">!     g_ptr_array_set_size (qtdemux-&gt;old_streams, 0);</span>
      qtdemux-&gt;n_video_streams = 0;
      qtdemux-&gt;n_audio_streams = 0;
      qtdemux-&gt;n_sub_streams = 0;
      qtdemux-&gt;exposed = FALSE;
      qtdemux-&gt;fragmented = FALSE;
      qtdemux-&gt;mss_mode = FALSE;
      gst_caps_replace (&amp;qtdemux-&gt;media_caps, NULL);
      qtdemux-&gt;timescale = 0;
      qtdemux-&gt;got_moov = FALSE;
<span class="line-added">+     qtdemux-&gt;cenc_aux_info_offset = 0;</span>
<span class="line-added">+     qtdemux-&gt;cenc_aux_info_sizes = NULL;</span>
<span class="line-added">+     qtdemux-&gt;cenc_aux_sample_count = 0;</span>
      if (qtdemux-&gt;protection_system_ids) {
        g_ptr_array_free (qtdemux-&gt;protection_system_ids, TRUE);
        qtdemux-&gt;protection_system_ids = NULL;
      }
<span class="line-added">+     qtdemux-&gt;streams_aware = GST_OBJECT_PARENT (qtdemux)</span>
<span class="line-added">+         &amp;&amp; GST_OBJECT_FLAG_IS_SET (GST_OBJECT_PARENT (qtdemux),</span>
<span class="line-added">+         GST_BIN_FLAG_STREAMS_AWARE);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (qtdemux-&gt;preferred_protection_system_id) {</span>
<span class="line-added">+       g_free (qtdemux-&gt;preferred_protection_system_id);</span>
<span class="line-added">+       qtdemux-&gt;preferred_protection_system_id = NULL;</span>
<span class="line-added">+     }</span>
    } else if (qtdemux-&gt;mss_mode) {
      gst_flow_combiner_reset (qtdemux-&gt;flowcombiner);
<span class="line-modified">!     g_ptr_array_foreach (qtdemux-&gt;active_streams,</span>
<span class="line-modified">!         (GFunc) gst_qtdemux_stream_clear, NULL);</span>
    } else {
      gst_flow_combiner_reset (qtdemux-&gt;flowcombiner);
<span class="line-modified">!     for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified">!       QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-modified">!       stream-&gt;sent_eos = FALSE;</span>
<span class="line-modified">!       stream-&gt;time_position = 0;</span>
<span class="line-added">+       stream-&gt;accumulated_base = 0;</span>
      }
    }
  }
  
  
  /* Maps the @segment to the qt edts internal segments and pushes
   * the correspnding segment event.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2182,37 ***</span>
   *
   * To be used in push-mode only */
  static void
  gst_qtdemux_map_and_push_segments (GstQTDemux * qtdemux, GstSegment * segment)
  {
<span class="line-modified">!   gint n, i;</span>
  
<span class="line-modified">!   for (n = 0; n &lt; qtdemux-&gt;n_streams; n++) {</span>
<span class="line-modified">!     QtDemuxStream *stream = qtdemux-&gt;streams[n];</span>
  
      stream-&gt;time_position = segment-&gt;start;
  
      /* in push mode we should be guaranteed that we will have empty segments
       * at the beginning and then one segment after, other scenarios are not
       * supported and are discarded when parsing the edts */
      for (i = 0; i &lt; stream-&gt;n_segments; i++) {
        if (stream-&gt;segments[i].stop_time &gt; segment-&gt;start) {
          gst_qtdemux_activate_segment (qtdemux, stream, i,
              stream-&gt;time_position);
          if (QTSEGMENT_IS_EMPTY (&amp;stream-&gt;segments[i])) {
<span class="line-removed">-           /* push the empty segment and move to the next one */</span>
            gst_qtdemux_send_gap_for_segment (qtdemux, stream, i,
                stream-&gt;time_position);
            continue;
          }
  
          g_assert (i == stream-&gt;n_segments - 1);
        }
      }
    }
  }
  
  static gboolean
  gst_qtdemux_handle_sink_event (GstPad * sinkpad, GstObject * parent,
      GstEvent * event)
  {
    GstQTDemux *demux = GST_QTDEMUX (parent);
<span class="line-new-header">--- 2256,68 ---</span>
   *
   * To be used in push-mode only */
  static void
  gst_qtdemux_map_and_push_segments (GstQTDemux * qtdemux, GstSegment * segment)
  {
<span class="line-modified">!   gint i, iter;</span>
  
<span class="line-modified">!   for (iter = 0; iter &lt; QTDEMUX_N_STREAMS (qtdemux); iter++) {</span>
<span class="line-modified">!     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, iter);</span>
  
      stream-&gt;time_position = segment-&gt;start;
  
      /* in push mode we should be guaranteed that we will have empty segments
       * at the beginning and then one segment after, other scenarios are not
       * supported and are discarded when parsing the edts */
      for (i = 0; i &lt; stream-&gt;n_segments; i++) {
        if (stream-&gt;segments[i].stop_time &gt; segment-&gt;start) {
<span class="line-added">+         /* push the empty segment and move to the next one */</span>
          gst_qtdemux_activate_segment (qtdemux, stream, i,
              stream-&gt;time_position);
          if (QTSEGMENT_IS_EMPTY (&amp;stream-&gt;segments[i])) {
            gst_qtdemux_send_gap_for_segment (qtdemux, stream, i,
                stream-&gt;time_position);
<span class="line-added">+ </span>
<span class="line-added">+           /* accumulate previous segments */</span>
<span class="line-added">+           if (GST_CLOCK_TIME_IS_VALID (stream-&gt;segment.stop))</span>
<span class="line-added">+             stream-&gt;accumulated_base +=</span>
<span class="line-added">+                 (stream-&gt;segment.stop -</span>
<span class="line-added">+                 stream-&gt;segment.start) / ABS (stream-&gt;segment.rate);</span>
            continue;
          }
  
          g_assert (i == stream-&gt;n_segments - 1);
        }
      }
    }
  }
  
<span class="line-added">+ static void</span>
<span class="line-added">+ gst_qtdemux_stream_concat (GstQTDemux * qtdemux, GPtrArray * dest,</span>
<span class="line-added">+     GPtrArray * src)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   guint i;</span>
<span class="line-added">+   guint len;</span>
<span class="line-added">+ </span>
<span class="line-added">+   len = src-&gt;len;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (len == 0)</span>
<span class="line-added">+     return;</span>
<span class="line-added">+ </span>
<span class="line-added">+   for (i = 0; i &lt; len; i++) {</span>
<span class="line-added">+     QtDemuxStream *stream = g_ptr_array_index (src, i);</span>
<span class="line-added">+ </span>
<span class="line-added">+ #ifndef GST_DISABLE_GST_DEBUG</span>
<span class="line-added">+     GST_DEBUG_OBJECT (qtdemux, &quot;Move stream %p (stream-id %s) to %p&quot;,</span>
<span class="line-added">+         stream, GST_STR_NULL (stream-&gt;stream_id), dest);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     g_ptr_array_add (dest, gst_qtdemux_stream_ref (stream));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_ptr_array_set_size (src, 0);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static gboolean
  gst_qtdemux_handle_sink_event (GstPad * sinkpad, GstObject * parent,
      GstEvent * event)
  {
    GstQTDemux *demux = GST_QTDEMUX (parent);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2231,26 ***</span>
        /* some debug output */
        gst_event_copy_segment (event, &amp;segment);
        GST_DEBUG_OBJECT (demux, &quot;received newsegment %&quot; GST_SEGMENT_FORMAT,
            &amp;segment);
  
<span class="line-removed">-       /* erase any previously set segment */</span>
<span class="line-removed">-       gst_event_replace (&amp;demux-&gt;pending_newsegment, NULL);</span>
<span class="line-removed">- </span>
        if (segment.format == GST_FORMAT_TIME) {
<span class="line-removed">-         GST_DEBUG_OBJECT (demux, &quot;new pending_newsegment&quot;);</span>
<span class="line-removed">-         gst_event_replace (&amp;demux-&gt;pending_newsegment, event);</span>
          demux-&gt;upstream_format_is_time = TRUE;
        } else {
          GST_DEBUG_OBJECT (demux, &quot;Not storing upstream newsegment, &quot;
              &quot;not in time format&quot;);
  
<span class="line-modified">!       /* chain will send initial newsegment after pads have been added */</span>
<span class="line-modified">!       if (demux-&gt;state != QTDEMUX_STATE_MOVIE || !demux-&gt;n_streams) {</span>
<span class="line-modified">!         GST_DEBUG_OBJECT (demux, &quot;still starting, eating event&quot;);</span>
<span class="line-modified">!         goto exit;</span>
<span class="line-modified">!       }</span>
        }
  
        /* check if this matches a time seek we received previously
         * FIXME for backwards compatibility reasons we use the
         * seek_offset here to compare. In the future we might want to
<span class="line-new-header">--- 2336,22 ---</span>
        /* some debug output */
        gst_event_copy_segment (event, &amp;segment);
        GST_DEBUG_OBJECT (demux, &quot;received newsegment %&quot; GST_SEGMENT_FORMAT,
            &amp;segment);
  
        if (segment.format == GST_FORMAT_TIME) {
          demux-&gt;upstream_format_is_time = TRUE;
<span class="line-added">+         demux-&gt;segment_seqnum = gst_event_get_seqnum (event);</span>
        } else {
          GST_DEBUG_OBJECT (demux, &quot;Not storing upstream newsegment, &quot;
              &quot;not in time format&quot;);
  
<span class="line-modified">!         /* chain will send initial newsegment after pads have been added */</span>
<span class="line-modified">!         if (demux-&gt;state != QTDEMUX_STATE_MOVIE || !QTDEMUX_N_STREAMS (demux)) {</span>
<span class="line-modified">!           GST_DEBUG_OBJECT (demux, &quot;still starting, eating event&quot;);</span>
<span class="line-modified">!           goto exit;</span>
<span class="line-modified">!         }</span>
        }
  
        /* check if this matches a time seek we received previously
         * FIXME for backwards compatibility reasons we use the
         * seek_offset here to compare. In the future we might want to
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2268,11 ***</span>
          segment.start = demux-&gt;push_seek_start;
          segment.stop = demux-&gt;push_seek_stop;
          GST_DEBUG_OBJECT (demux, &quot;Replaced segment with stored seek &quot;
              &quot;segment %&quot; GST_TIME_FORMAT &quot; - %&quot; GST_TIME_FORMAT,
              GST_TIME_ARGS (segment.start), GST_TIME_ARGS (segment.stop));
<span class="line-modified">!           GST_OBJECT_UNLOCK (demux);</span>
        }
  
        /* we only expect a BYTE segment, e.g. following a seek */
        if (segment.format == GST_FORMAT_BYTES) {
          if (GST_CLOCK_TIME_IS_VALID (segment.start)) {
<span class="line-new-header">--- 2369,11 ---</span>
          segment.start = demux-&gt;push_seek_start;
          segment.stop = demux-&gt;push_seek_stop;
          GST_DEBUG_OBJECT (demux, &quot;Replaced segment with stored seek &quot;
              &quot;segment %&quot; GST_TIME_FORMAT &quot; - %&quot; GST_TIME_FORMAT,
              GST_TIME_ARGS (segment.start), GST_TIME_ARGS (segment.stop));
<span class="line-modified">!         GST_OBJECT_UNLOCK (demux);</span>
        }
  
        /* we only expect a BYTE segment, e.g. following a seek */
        if (segment.format == GST_FORMAT_BYTES) {
          if (GST_CLOCK_TIME_IS_VALID (segment.start)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2280,11 ***</span>
  
            gst_qtdemux_find_sample (demux, segment.start, TRUE, FALSE, NULL,
                NULL, (gint64 *) &amp; segment.start);
            if ((gint64) segment.start &lt; 0)
              segment.start = 0;
<span class="line-modified">!           }</span>
          if (GST_CLOCK_TIME_IS_VALID (segment.stop)) {
            gst_qtdemux_find_sample (demux, segment.stop, FALSE, FALSE, NULL,
                NULL, (gint64 *) &amp; segment.stop);
            /* keyframe seeking should already arrange for start &gt;= stop,
             * but make sure in other rare cases */
<span class="line-new-header">--- 2381,11 ---</span>
  
            gst_qtdemux_find_sample (demux, segment.start, TRUE, FALSE, NULL,
                NULL, (gint64 *) &amp; segment.start);
            if ((gint64) segment.start &lt; 0)
              segment.start = 0;
<span class="line-modified">!         }</span>
          if (GST_CLOCK_TIME_IS_VALID (segment.stop)) {
            gst_qtdemux_find_sample (demux, segment.stop, FALSE, FALSE, NULL,
                NULL, (gint64 *) &amp; segment.stop);
            /* keyframe seeking should already arrange for start &gt;= stop,
             * but make sure in other rare cases */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2299,33 ***</span>
          goto exit;
        }
  
        /* We shouldn&#39;t modify upstream driven TIME FORMAT segment */
        if (!demux-&gt;upstream_format_is_time) {
<span class="line-modified">!       /* accept upstream&#39;s notion of segment and distribute along */</span>
<span class="line-modified">!       segment.format = GST_FORMAT_TIME;</span>
<span class="line-modified">!       segment.position = segment.time = segment.start;</span>
<span class="line-modified">!       segment.duration = demux-&gt;segment.duration;</span>
<span class="line-modified">!       segment.base = gst_segment_to_running_time (&amp;demux-&gt;segment,</span>
<span class="line-modified">!           GST_FORMAT_TIME, demux-&gt;segment.position);</span>
        }
  
        gst_segment_copy_into (&amp;segment, &amp;demux-&gt;segment);
        GST_DEBUG_OBJECT (demux, &quot;Pushing newseg %&quot; GST_SEGMENT_FORMAT, &amp;segment);
  
        /* map segment to internal qt segments and push on each stream */
<span class="line-modified">!       if (demux-&gt;n_streams) {</span>
<span class="line-modified">!         if (demux-&gt;fragmented) {</span>
<span class="line-modified">!           GstEvent *segment_event = gst_event_new_segment (&amp;segment);</span>
<span class="line-removed">- </span>
<span class="line-removed">-           gst_event_replace (&amp;demux-&gt;pending_newsegment, NULL);</span>
<span class="line-removed">-           gst_event_set_seqnum (segment_event, demux-&gt;segment_seqnum);</span>
<span class="line-removed">-       gst_qtdemux_push_event (demux, segment_event);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           gst_event_replace (&amp;demux-&gt;pending_newsegment, NULL);</span>
<span class="line-removed">-           gst_qtdemux_map_and_push_segments (demux, &amp;segment);</span>
<span class="line-removed">-         }</span>
        }
  
        /* clear leftover in current segment, if any */
        gst_adapter_clear (demux-&gt;adapter);
  
<span class="line-new-header">--- 2400,25 ---</span>
          goto exit;
        }
  
        /* We shouldn&#39;t modify upstream driven TIME FORMAT segment */
        if (!demux-&gt;upstream_format_is_time) {
<span class="line-modified">!         /* accept upstream&#39;s notion of segment and distribute along */</span>
<span class="line-modified">!         segment.format = GST_FORMAT_TIME;</span>
<span class="line-modified">!         segment.position = segment.time = segment.start;</span>
<span class="line-modified">!         segment.duration = demux-&gt;segment.duration;</span>
<span class="line-modified">!         segment.base = gst_segment_to_running_time (&amp;demux-&gt;segment,</span>
<span class="line-modified">!             GST_FORMAT_TIME, demux-&gt;segment.position);</span>
        }
  
        gst_segment_copy_into (&amp;segment, &amp;demux-&gt;segment);
        GST_DEBUG_OBJECT (demux, &quot;Pushing newseg %&quot; GST_SEGMENT_FORMAT, &amp;segment);
  
        /* map segment to internal qt segments and push on each stream */
<span class="line-modified">!       if (QTDEMUX_N_STREAMS (demux)) {</span>
<span class="line-modified">!         demux-&gt;need_segment = TRUE;</span>
<span class="line-modified">!         gst_qtdemux_check_send_pending_segment (demux);</span>
        }
  
        /* clear leftover in current segment, if any */
        gst_adapter_clear (demux-&gt;adapter);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2337,18 ***</span>
          demux-&gt;neededbytes = 16;
          demux-&gt;todrop = 0;
        } else {
          gst_qtdemux_find_sample (demux, offset, TRUE, TRUE, &amp;stream, &amp;idx,
              NULL);
<span class="line-modified">!       if (stream) {</span>
<span class="line-modified">!         demux-&gt;todrop = stream-&gt;samples[idx].offset - offset;</span>
<span class="line-modified">!         demux-&gt;neededbytes = demux-&gt;todrop + stream-&gt;samples[idx].size;</span>
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         /* set up for EOS */</span>
<span class="line-modified">!         demux-&gt;neededbytes = -1;</span>
<span class="line-modified">!         demux-&gt;todrop = 0;</span>
<span class="line-modified">!       }</span>
        }
      exit:
        gst_event_unref (event);
        res = TRUE;
        goto drop;
<span class="line-new-header">--- 2430,18 ---</span>
          demux-&gt;neededbytes = 16;
          demux-&gt;todrop = 0;
        } else {
          gst_qtdemux_find_sample (demux, offset, TRUE, TRUE, &amp;stream, &amp;idx,
              NULL);
<span class="line-modified">!         if (stream) {</span>
<span class="line-modified">!           demux-&gt;todrop = stream-&gt;samples[idx].offset - offset;</span>
<span class="line-modified">!           demux-&gt;neededbytes = demux-&gt;todrop + stream-&gt;samples[idx].size;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!           /* set up for EOS */</span>
<span class="line-modified">!           demux-&gt;neededbytes = -1;</span>
<span class="line-modified">!           demux-&gt;todrop = 0;</span>
<span class="line-modified">!         }</span>
        }
      exit:
        gst_event_unref (event);
        res = TRUE;
        goto drop;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2357,11 ***</span>
      {
        if (gst_event_get_seqnum (event) == demux-&gt;offset_seek_seqnum) {
          gst_event_unref (event);
          goto drop;
        }
<span class="line-modified">!       break;</span>
      }
      case GST_EVENT_FLUSH_STOP:
      {
        guint64 dur;
  
<span class="line-new-header">--- 2450,14 ---</span>
      {
        if (gst_event_get_seqnum (event) == demux-&gt;offset_seek_seqnum) {
          gst_event_unref (event);
          goto drop;
        }
<span class="line-modified">!       QTDEMUX_EXPOSE_LOCK (demux);</span>
<span class="line-added">+       res = gst_pad_event_default (demux-&gt;sinkpad, parent, event);</span>
<span class="line-added">+       QTDEMUX_EXPOSE_UNLOCK (demux);</span>
<span class="line-added">+       goto drop;</span>
      }
      case GST_EVENT_FLUSH_STOP:
      {
        guint64 dur;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2379,12 ***</span>
        /* If we are in push mode, and get an EOS before we&#39;ve seen any streams,
         * then error out - we have nowhere to send the EOS */
        if (!demux-&gt;pullbased) {
          gint i;
          gboolean has_valid_stream = FALSE;
<span class="line-modified">!         for (i = 0; i &lt; demux-&gt;n_streams; i++) {</span>
<span class="line-modified">!           if (demux-&gt;streams[i]-&gt;pad != NULL) {</span>
              has_valid_stream = TRUE;
              break;
            }
          }
          if (!has_valid_stream)
<span class="line-new-header">--- 2475,12 ---</span>
        /* If we are in push mode, and get an EOS before we&#39;ve seen any streams,
         * then error out - we have nowhere to send the EOS */
        if (!demux-&gt;pullbased) {
          gint i;
          gboolean has_valid_stream = FALSE;
<span class="line-modified">!         for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified">!           if (QTDEMUX_NTH_STREAM (demux, i)-&gt;pad != NULL) {</span>
              has_valid_stream = TRUE;
              break;
            }
          }
          if (!has_valid_stream)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2392,11 ***</span>
          else {
            GST_DEBUG_OBJECT (demux, &quot;Data still available after EOS: %u&quot;,
                (guint) gst_adapter_available (demux-&gt;adapter));
            if (gst_qtdemux_process_adapter (demux, TRUE) != GST_FLOW_OK) {
              res = FALSE;
<span class="line-modified">!       }</span>
          }
        }
        break;
      case GST_EVENT_CAPS:{
        GstCaps *caps = NULL;
<span class="line-new-header">--- 2488,11 ---</span>
          else {
            GST_DEBUG_OBJECT (demux, &quot;Data still available after EOS: %u&quot;,
                (guint) gst_adapter_available (demux-&gt;adapter));
            if (gst_qtdemux_process_adapter (demux, TRUE) != GST_FLOW_OK) {
              res = FALSE;
<span class="line-modified">!           }</span>
          }
        }
        break;
      case GST_EVENT_CAPS:{
        GstCaps *caps = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2420,20 ***</span>
<span class="line-new-header">--- 2516,76 ---</span>
        /* send it to all pads that already exist */
        gst_qtdemux_push_event (demux, event);
        res = TRUE;
        goto drop;
      }
<span class="line-added">+     case GST_EVENT_STREAM_START:</span>
<span class="line-added">+     {</span>
<span class="line-added">+       res = TRUE;</span>
<span class="line-added">+       gst_event_unref (event);</span>
<span class="line-added">+ </span>
<span class="line-added">+       /* Drain all the buffers */</span>
<span class="line-added">+       gst_qtdemux_process_adapter (demux, TRUE);</span>
<span class="line-added">+       gst_qtdemux_reset (demux, FALSE);</span>
<span class="line-added">+       /* We expect new moov box after new stream-start event */</span>
<span class="line-added">+       if (demux-&gt;exposed) {</span>
<span class="line-added">+         gst_qtdemux_stream_concat (demux,</span>
<span class="line-added">+             demux-&gt;old_streams, demux-&gt;active_streams);</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+       goto drop;</span>
<span class="line-added">+     }</span>
      default:
        break;
    }
  
    res = gst_pad_event_default (demux-&gt;sinkpad, parent, event) &amp; res;
  
  drop:
    return res;
  }
  
<span class="line-added">+ static gboolean</span>
<span class="line-added">+ gst_qtdemux_handle_sink_query (GstPad * pad, GstObject * parent,</span>
<span class="line-added">+     GstQuery * query)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   GstQTDemux *demux = GST_QTDEMUX (parent);</span>
<span class="line-added">+   gboolean res = FALSE;</span>
<span class="line-added">+ </span>
<span class="line-added">+   switch (GST_QUERY_TYPE (query)) {</span>
<span class="line-added">+     case GST_QUERY_BITRATE:</span>
<span class="line-added">+     {</span>
<span class="line-added">+       GstClockTime duration;</span>
<span class="line-added">+ </span>
<span class="line-added">+       /* populate demux-&gt;upstream_size if not done yet */</span>
<span class="line-added">+       gst_qtdemux_check_seekability (demux);</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (demux-&gt;upstream_size != -1</span>
<span class="line-added">+           &amp;&amp; gst_qtdemux_get_duration (demux, &amp;duration)) {</span>
<span class="line-added">+         guint bitrate =</span>
<span class="line-added">+             gst_util_uint64_scale (8 * demux-&gt;upstream_size, GST_SECOND,</span>
<span class="line-added">+             duration);</span>
<span class="line-added">+ </span>
<span class="line-added">+         GST_LOG_OBJECT (demux, &quot;bitrate query byte length: %&quot; G_GUINT64_FORMAT</span>
<span class="line-added">+             &quot; duration %&quot; GST_TIME_FORMAT &quot; resulting a bitrate of %u&quot;,</span>
<span class="line-added">+             demux-&gt;upstream_size, GST_TIME_ARGS (duration), bitrate);</span>
<span class="line-added">+ </span>
<span class="line-added">+         /* TODO: better results based on ranges/index tables */</span>
<span class="line-added">+         gst_query_set_bitrate (query, bitrate);</span>
<span class="line-added">+         res = TRUE;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     default:</span>
<span class="line-added">+       res = gst_pad_query_default (pad, (GstObject *) demux, query);</span>
<span class="line-added">+       break;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return res;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  #if 0
  static void
  gst_qtdemux_set_index (GstElement * element, GstIndex * index)
  {
    GstQTDemux *demux = GST_QTDEMUX (element);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2489,22 ***</span>
    g_free ((gpointer) stream-&gt;ctts.data);
    stream-&gt;ctts.data = NULL;
  }
  
  static void
<span class="line-modified">! gst_qtdemux_stream_flush_segments_data (GstQTDemux * qtdemux,</span>
<span class="line-removed">-     QtDemuxStream * stream)</span>
  {
    g_free (stream-&gt;segments);
    stream-&gt;segments = NULL;
    stream-&gt;segment_index = -1;
    stream-&gt;accumulated_base = 0;
  }
  
  static void
<span class="line-modified">! gst_qtdemux_stream_flush_samples_data (GstQTDemux * qtdemux,</span>
<span class="line-removed">-     QtDemuxStream * stream)</span>
  {
    g_free (stream-&gt;samples);
    stream-&gt;samples = NULL;
    gst_qtdemux_stbl_free (stream);
  
<span class="line-new-header">--- 2641,20 ---</span>
    g_free ((gpointer) stream-&gt;ctts.data);
    stream-&gt;ctts.data = NULL;
  }
  
  static void
<span class="line-modified">! gst_qtdemux_stream_flush_segments_data (QtDemuxStream * stream)</span>
  {
    g_free (stream-&gt;segments);
    stream-&gt;segments = NULL;
    stream-&gt;segment_index = -1;
    stream-&gt;accumulated_base = 0;
  }
  
  static void
<span class="line-modified">! gst_qtdemux_stream_flush_samples_data (QtDemuxStream * stream)</span>
  {
    g_free (stream-&gt;samples);
    stream-&gt;samples = NULL;
    gst_qtdemux_stbl_free (stream);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2522,11 ***</span>
    stream-&gt;duration_moof = 0;
    stream-&gt;duration_last_moof = 0;
  }
  
  static void
<span class="line-modified">! gst_qtdemux_stream_clear (GstQTDemux * qtdemux, QtDemuxStream * stream)</span>
  {
    gint i;
    if (stream-&gt;allocator)
      gst_object_unref (stream-&gt;allocator);
    while (stream-&gt;buffers) {
<span class="line-new-header">--- 2672,11 ---</span>
    stream-&gt;duration_moof = 0;
    stream-&gt;duration_last_moof = 0;
  }
  
  static void
<span class="line-modified">! gst_qtdemux_stream_clear (QtDemuxStream * stream)</span>
  {
    gint i;
    if (stream-&gt;allocator)
      gst_object_unref (stream-&gt;allocator);
    while (stream-&gt;buffers) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2536,15 ***</span>
    for (i = 0; i &lt; stream-&gt;stsd_entries_length; i++) {
      QtDemuxStreamStsdEntry *entry = &amp;stream-&gt;stsd_entries[i];
      if (entry-&gt;rgb8_palette) {
        gst_memory_unref (entry-&gt;rgb8_palette);
        entry-&gt;rgb8_palette = NULL;
<span class="line-modified">!   }</span>
      entry-&gt;sparse = FALSE;
    }
  
<span class="line-modified">!   gst_tag_list_unref (stream-&gt;stream_tags);</span>
    stream-&gt;stream_tags = gst_tag_list_new_empty ();
    gst_tag_list_set_scope (stream-&gt;stream_tags, GST_TAG_SCOPE_STREAM);
    g_free (stream-&gt;redirect_uri);
    stream-&gt;redirect_uri = NULL;
    stream-&gt;sent_eos = FALSE;
<span class="line-new-header">--- 2686,17 ---</span>
    for (i = 0; i &lt; stream-&gt;stsd_entries_length; i++) {
      QtDemuxStreamStsdEntry *entry = &amp;stream-&gt;stsd_entries[i];
      if (entry-&gt;rgb8_palette) {
        gst_memory_unref (entry-&gt;rgb8_palette);
        entry-&gt;rgb8_palette = NULL;
<span class="line-modified">!     }</span>
      entry-&gt;sparse = FALSE;
    }
  
<span class="line-modified">!   if (stream-&gt;stream_tags)</span>
<span class="line-added">+     gst_tag_list_unref (stream-&gt;stream_tags);</span>
<span class="line-added">+ </span>
    stream-&gt;stream_tags = gst_tag_list_new_empty ();
    gst_tag_list_set_scope (stream-&gt;stream_tags, GST_TAG_SCOPE_STREAM);
    g_free (stream-&gt;redirect_uri);
    stream-&gt;redirect_uri = NULL;
    stream-&gt;sent_eos = FALSE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2555,28 ***</span>
            (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;
        if (info-&gt;default_properties)
          gst_structure_free (info-&gt;default_properties);
        if (info-&gt;crypto_info)
          g_ptr_array_free (info-&gt;crypto_info, TRUE);
<span class="line-modified">! }</span>
      g_free (stream-&gt;protection_scheme_info);
      stream-&gt;protection_scheme_info = NULL;
    }
    stream-&gt;protection_scheme_type = 0;
    stream-&gt;protection_scheme_version = 0;
    g_queue_foreach (&amp;stream-&gt;protection_scheme_event_queue,
        (GFunc) gst_event_unref, NULL);
    g_queue_clear (&amp;stream-&gt;protection_scheme_event_queue);
<span class="line-modified">!   gst_qtdemux_stream_flush_segments_data (qtdemux, stream);</span>
<span class="line-modified">!   gst_qtdemux_stream_flush_samples_data (qtdemux, stream);</span>
  }
  
  static void
<span class="line-modified">! gst_qtdemux_stream_reset (GstQTDemux * qtdemux, QtDemuxStream * stream)</span>
  {
    gint i;
<span class="line-modified">!   gst_qtdemux_stream_clear (qtdemux, stream);</span>
    for (i = 0; i &lt; stream-&gt;stsd_entries_length; i++) {
      QtDemuxStreamStsdEntry *entry = &amp;stream-&gt;stsd_entries[i];
      if (entry-&gt;caps) {
        gst_caps_unref (entry-&gt;caps);
        entry-&gt;caps = NULL;
<span class="line-new-header">--- 2707,28 ---</span>
            (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;
        if (info-&gt;default_properties)
          gst_structure_free (info-&gt;default_properties);
        if (info-&gt;crypto_info)
          g_ptr_array_free (info-&gt;crypto_info, TRUE);
<span class="line-modified">!     }</span>
      g_free (stream-&gt;protection_scheme_info);
      stream-&gt;protection_scheme_info = NULL;
    }
    stream-&gt;protection_scheme_type = 0;
    stream-&gt;protection_scheme_version = 0;
    g_queue_foreach (&amp;stream-&gt;protection_scheme_event_queue,
        (GFunc) gst_event_unref, NULL);
    g_queue_clear (&amp;stream-&gt;protection_scheme_event_queue);
<span class="line-modified">!   gst_qtdemux_stream_flush_segments_data (stream);</span>
<span class="line-modified">!   gst_qtdemux_stream_flush_samples_data (stream);</span>
  }
  
  static void
<span class="line-modified">! gst_qtdemux_stream_reset (QtDemuxStream * stream)</span>
  {
    gint i;
<span class="line-modified">!   gst_qtdemux_stream_clear (stream);</span>
    for (i = 0; i &lt; stream-&gt;stsd_entries_length; i++) {
      QtDemuxStreamStsdEntry *entry = &amp;stream-&gt;stsd_entries[i];
      if (entry-&gt;caps) {
        gst_caps_unref (entry-&gt;caps);
        entry-&gt;caps = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2585,42 ***</span>
    g_free (stream-&gt;stsd_entries);
    stream-&gt;stsd_entries = NULL;
    stream-&gt;stsd_entries_length = 0;
  }
  
<span class="line-modified">! </span>
<span class="line-modified">! static void</span>
<span class="line-removed">- gst_qtdemux_stream_free (GstQTDemux * qtdemux, QtDemuxStream * stream)</span>
  {
<span class="line-modified">!   gst_qtdemux_stream_reset (qtdemux, stream);</span>
<span class="line-modified">!   gst_tag_list_unref (stream-&gt;stream_tags);</span>
<span class="line-modified">!   if (stream-&gt;pad) {</span>
<span class="line-removed">-     gst_element_remove_pad (GST_ELEMENT_CAST (qtdemux), stream-&gt;pad);</span>
<span class="line-removed">-     gst_flow_combiner_remove_pad (qtdemux-&gt;flowcombiner, stream-&gt;pad);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   g_free (stream);</span>
  }
  
  static void
<span class="line-modified">! gst_qtdemux_remove_stream (GstQTDemux * qtdemux, int i)</span>
  {
<span class="line-modified">!   g_assert (i &gt;= 0 &amp;&amp; i &lt; qtdemux-&gt;n_streams &amp;&amp; qtdemux-&gt;streams[i] != NULL);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   gst_qtdemux_stream_free (qtdemux, qtdemux-&gt;streams[i]);</span>
<span class="line-modified">!   qtdemux-&gt;streams[i] = qtdemux-&gt;streams[qtdemux-&gt;n_streams - 1];</span>
<span class="line-modified">!   qtdemux-&gt;streams[qtdemux-&gt;n_streams - 1] = NULL;</span>
<span class="line-modified">!   qtdemux-&gt;n_streams--;</span>
  }
  
  static GstStateChangeReturn
  gst_qtdemux_change_state (GstElement * element, GstStateChange transition)
  {
    GstQTDemux *qtdemux = GST_QTDEMUX (element);
    GstStateChangeReturn result = GST_STATE_CHANGE_FAILURE;
  
    switch (transition) {
<span class="line-modified">!     case GST_STATE_CHANGE_PAUSED_TO_READY:</span>
        break;
      default:
        break;
    }
  
<span class="line-new-header">--- 2737,43 ---</span>
    g_free (stream-&gt;stsd_entries);
    stream-&gt;stsd_entries = NULL;
    stream-&gt;stsd_entries_length = 0;
  }
  
<span class="line-modified">! static QtDemuxStream *</span>
<span class="line-modified">! gst_qtdemux_stream_ref (QtDemuxStream * stream)</span>
  {
<span class="line-modified">!   g_atomic_int_add (&amp;stream-&gt;ref_count, 1);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   return stream;</span>
  }
  
  static void
<span class="line-modified">! gst_qtdemux_stream_unref (QtDemuxStream * stream)</span>
  {
<span class="line-modified">!   if (g_atomic_int_dec_and_test (&amp;stream-&gt;ref_count)) {</span>
<span class="line-modified">!     gst_qtdemux_stream_reset (stream);</span>
<span class="line-modified">!     gst_tag_list_unref (stream-&gt;stream_tags);</span>
<span class="line-modified">!     if (stream-&gt;pad) {</span>
<span class="line-modified">!       GstQTDemux *demux = stream-&gt;demux;</span>
<span class="line-modified">!       gst_element_remove_pad (GST_ELEMENT_CAST (demux), stream-&gt;pad);</span>
<span class="line-added">+       gst_flow_combiner_remove_pad (demux-&gt;flowcombiner, stream-&gt;pad);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     g_free (stream-&gt;stream_id);</span>
<span class="line-added">+     g_free (stream);</span>
<span class="line-added">+   }</span>
  }
  
  static GstStateChangeReturn
  gst_qtdemux_change_state (GstElement * element, GstStateChange transition)
  {
    GstQTDemux *qtdemux = GST_QTDEMUX (element);
    GstStateChangeReturn result = GST_STATE_CHANGE_FAILURE;
  
    switch (transition) {
<span class="line-modified">!     case GST_STATE_CHANGE_READY_TO_PAUSED:</span>
<span class="line-added">+       gst_qtdemux_reset (qtdemux, TRUE);</span>
        break;
      default:
        break;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2636,10 ***</span>
<span class="line-new-header">--- 2789,32 ---</span>
    }
  
    return result;
  }
  
<span class="line-added">+ static void</span>
<span class="line-added">+ gst_qtdemux_set_context (GstElement * element, GstContext * context)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   GstQTDemux *qtdemux = GST_QTDEMUX (element);</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_return_if_fail (GST_IS_CONTEXT (context));</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (gst_context_has_context_type (context,</span>
<span class="line-added">+           &quot;drm-preferred-decryption-system-id&quot;)) {</span>
<span class="line-added">+     const GstStructure *s;</span>
<span class="line-added">+ </span>
<span class="line-added">+     s = gst_context_get_structure (context);</span>
<span class="line-added">+     g_free (qtdemux-&gt;preferred_protection_system_id);</span>
<span class="line-added">+     qtdemux-&gt;preferred_protection_system_id =</span>
<span class="line-added">+         g_strdup (gst_structure_get_string (s, &quot;decryption-system-id&quot;));</span>
<span class="line-added">+     GST_DEBUG_OBJECT (element, &quot;set preferred decryption system to %s&quot;,</span>
<span class="line-added">+         qtdemux-&gt;preferred_protection_system_id);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   GST_ELEMENT_CLASS (parent_class)-&gt;set_context (element, context);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static void
  qtdemux_parse_ftyp (GstQTDemux * qtdemux, const guint8 * buffer, gint length)
  {
    /* counts as header data */
    qtdemux-&gt;header_size += length;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2671,36 ***</span>
        gst_tag_list_remove_tag (xmptaglist, GST_TAG_CONTAINER_FORMAT);
      }
  
      GST_DEBUG_OBJECT (qtdemux, &quot;Found XMP tags %&quot; GST_PTR_FORMAT, xmptaglist);
  
<span class="line-modified">!       /* prioritize native tags using _KEEP mode */</span>
      gst_tag_list_insert (taglist, xmptaglist, GST_TAG_MERGE_KEEP);
      gst_tag_list_unref (xmptaglist);
    }
  }
  
  static void
  qtdemux_parse_piff (GstQTDemux * qtdemux, const guint8 * buffer, gint length,
      guint offset)
  {
    GstByteReader br;
    guint8 version;
    guint32 flags = 0;
    guint i;
<span class="line-modified">!   guint8 iv_size = 8;</span>
    QtDemuxStream *stream;
    GstStructure *structure;
    QtDemuxCencSampleSetInfo *ss_info = NULL;
    const gchar *system_id;
    gboolean uses_sub_sample_encryption = FALSE;
    guint32 sample_count;
  
<span class="line-modified">!   if (qtdemux-&gt;n_streams == 0)</span>
      return;
  
<span class="line-modified">!   stream = qtdemux-&gt;streams[0];</span>
  
    structure = gst_caps_get_structure (CUR_STREAM (stream)-&gt;caps, 0);
    if (!gst_structure_has_name (structure, &quot;application/x-cenc&quot;)) {
      GST_WARNING_OBJECT (qtdemux,
          &quot;Attempting PIFF box parsing on an unencrypted stream.&quot;);
<span class="line-new-header">--- 2846,92 ---</span>
        gst_tag_list_remove_tag (xmptaglist, GST_TAG_CONTAINER_FORMAT);
      }
  
      GST_DEBUG_OBJECT (qtdemux, &quot;Found XMP tags %&quot; GST_PTR_FORMAT, xmptaglist);
  
<span class="line-modified">!     /* prioritize native tags using _KEEP mode */</span>
      gst_tag_list_insert (taglist, xmptaglist, GST_TAG_MERGE_KEEP);
      gst_tag_list_unref (xmptaglist);
    }
  }
  
<span class="line-added">+ static void</span>
<span class="line-added">+ qtdemux_update_default_sample_encryption_settings (GstQTDemux * qtdemux,</span>
<span class="line-added">+     QtDemuxCencSampleSetInfo * info, guint32 is_encrypted, guint8 iv_size,</span>
<span class="line-added">+     const guint8 * kid)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   GstBuffer *kid_buf = gst_buffer_new_allocate (NULL, 16, NULL);</span>
<span class="line-added">+   gst_buffer_fill (kid_buf, 0, kid, 16);</span>
<span class="line-added">+   if (info-&gt;default_properties)</span>
<span class="line-added">+     gst_structure_free (info-&gt;default_properties);</span>
<span class="line-added">+   info-&gt;default_properties =</span>
<span class="line-added">+       gst_structure_new (&quot;application/x-cenc&quot;,</span>
<span class="line-added">+       &quot;iv_size&quot;, G_TYPE_UINT, iv_size,</span>
<span class="line-added">+       &quot;encrypted&quot;, G_TYPE_BOOLEAN, (is_encrypted == 1),</span>
<span class="line-added">+       &quot;kid&quot;, GST_TYPE_BUFFER, kid_buf, NULL);</span>
<span class="line-added">+   GST_DEBUG_OBJECT (qtdemux, &quot;default sample properties: &quot;</span>
<span class="line-added">+       &quot;is_encrypted=%u, iv_size=%u&quot;, is_encrypted, iv_size);</span>
<span class="line-added">+   gst_buffer_unref (kid_buf);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static gboolean</span>
<span class="line-added">+ qtdemux_update_default_piff_encryption_settings (GstQTDemux * qtdemux,</span>
<span class="line-added">+     QtDemuxCencSampleSetInfo * info, GstByteReader * br)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   guint32 algorithm_id = 0;</span>
<span class="line-added">+   const guint8 *kid;</span>
<span class="line-added">+   gboolean is_encrypted = TRUE;</span>
<span class="line-added">+   guint8 iv_size = 8;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!gst_byte_reader_get_uint24_le (br, &amp;algorithm_id)) {</span>
<span class="line-added">+     GST_ERROR_OBJECT (qtdemux, &quot;Error getting box&#39;s algorithm ID field&quot;);</span>
<span class="line-added">+     return FALSE;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   algorithm_id &gt;&gt;= 8;</span>
<span class="line-added">+   if (algorithm_id == 0) {</span>
<span class="line-added">+     is_encrypted = FALSE;</span>
<span class="line-added">+   } else if (algorithm_id == 1) {</span>
<span class="line-added">+     GST_DEBUG_OBJECT (qtdemux, &quot;AES 128-bits CTR encrypted stream&quot;);</span>
<span class="line-added">+   } else if (algorithm_id == 2) {</span>
<span class="line-added">+     GST_DEBUG_OBJECT (qtdemux, &quot;AES 128-bits CBC encrypted stream&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!gst_byte_reader_get_uint8 (br, &amp;iv_size))</span>
<span class="line-added">+     return FALSE;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!gst_byte_reader_get_data (br, 16, &amp;kid))</span>
<span class="line-added">+     return FALSE;</span>
<span class="line-added">+ </span>
<span class="line-added">+   qtdemux_update_default_sample_encryption_settings (qtdemux, info,</span>
<span class="line-added">+       is_encrypted, iv_size, kid);</span>
<span class="line-added">+   gst_structure_set (info-&gt;default_properties, &quot;piff_algorithm_id&quot;,</span>
<span class="line-added">+       G_TYPE_UINT, algorithm_id, NULL);</span>
<span class="line-added">+   return TRUE;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  static void
  qtdemux_parse_piff (GstQTDemux * qtdemux, const guint8 * buffer, gint length,
      guint offset)
  {
    GstByteReader br;
    guint8 version;
    guint32 flags = 0;
    guint i;
<span class="line-modified">!   guint iv_size = 8;</span>
    QtDemuxStream *stream;
    GstStructure *structure;
    QtDemuxCencSampleSetInfo *ss_info = NULL;
    const gchar *system_id;
    gboolean uses_sub_sample_encryption = FALSE;
    guint32 sample_count;
  
<span class="line-modified">!   if (QTDEMUX_N_STREAMS (qtdemux) == 0)</span>
      return;
  
<span class="line-modified">!   stream = QTDEMUX_NTH_STREAM (qtdemux, 0);</span>
  
    structure = gst_caps_get_structure (CUR_STREAM (stream)-&gt;caps, 0);
    if (!gst_structure_has_name (structure, &quot;application/x-cenc&quot;)) {
      GST_WARNING_OBJECT (qtdemux,
          &quot;Attempting PIFF box parsing on an unencrypted stream.&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2716,17 ***</span>
  
    if (!stream-&gt;protection_scheme_info)
      stream-&gt;protection_scheme_info = g_new0 (QtDemuxCencSampleSetInfo, 1);
  
    ss_info = (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;
  
<span class="line-modified">!   if (ss_info-&gt;default_properties)</span>
<span class="line-removed">-     gst_structure_free (ss_info-&gt;default_properties);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ss_info-&gt;default_properties =</span>
<span class="line-removed">-       gst_structure_new (&quot;application/x-cenc&quot;,</span>
<span class="line-removed">-       &quot;iv_size&quot;, G_TYPE_UINT, iv_size, &quot;encrypted&quot;, G_TYPE_BOOLEAN, TRUE, NULL);</span>
  
    if (ss_info-&gt;crypto_info) {
      GST_LOG_OBJECT (qtdemux, &quot;unreffing existing crypto_info&quot;);
      g_ptr_array_free (ss_info-&gt;crypto_info, TRUE);
      ss_info-&gt;crypto_info = NULL;
<span class="line-new-header">--- 2947,17 ---</span>
  
    if (!stream-&gt;protection_scheme_info)
      stream-&gt;protection_scheme_info = g_new0 (QtDemuxCencSampleSetInfo, 1);
  
    ss_info = (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;
<span class="line-added">+   if (!ss_info-&gt;default_properties) {</span>
<span class="line-added">+     ss_info-&gt;default_properties =</span>
<span class="line-added">+         gst_structure_new (&quot;application/x-cenc&quot;,</span>
<span class="line-added">+         &quot;iv_size&quot;, G_TYPE_UINT, iv_size, &quot;encrypted&quot;, G_TYPE_BOOLEAN, TRUE,</span>
<span class="line-added">+         NULL);</span>
  
<span class="line-modified">!   }</span>
  
    if (ss_info-&gt;crypto_info) {
      GST_LOG_OBJECT (qtdemux, &quot;unreffing existing crypto_info&quot;);
      g_ptr_array_free (ss_info-&gt;crypto_info, TRUE);
      ss_info-&gt;crypto_info = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2744,53 ***</span>
      GST_ERROR_OBJECT (qtdemux, &quot;Error getting box&#39;s flags field&quot;);
      return;
    }
  
    if ((flags &amp; 0x000001)) {
<span class="line-modified">!     guint32 algorithm_id = 0;</span>
<span class="line-modified">!     const guint8 *kid;</span>
<span class="line-removed">-     GstBuffer *kid_buf;</span>
<span class="line-removed">-     gboolean is_encrypted = TRUE;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!gst_byte_reader_get_uint24_le (&amp;br, &amp;algorithm_id)) {</span>
<span class="line-removed">-       GST_ERROR_OBJECT (qtdemux, &quot;Error getting box&#39;s algorithm ID field&quot;);</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     algorithm_id &gt;&gt;= 8;</span>
<span class="line-removed">-     if (algorithm_id == 0) {</span>
<span class="line-removed">-       is_encrypted = FALSE;</span>
<span class="line-removed">-     } else if (algorithm_id == 1) {</span>
<span class="line-removed">-       /* FIXME: maybe store this in properties? */</span>
<span class="line-removed">-       GST_DEBUG_OBJECT (qtdemux, &quot;AES 128-bits CTR encrypted stream&quot;);</span>
<span class="line-removed">-     } else if (algorithm_id == 2) {</span>
<span class="line-removed">-       /* FIXME: maybe store this in properties? */</span>
<span class="line-removed">-       GST_DEBUG_OBJECT (qtdemux, &quot;AES 128-bits CBC encrypted stream&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!gst_byte_reader_get_uint8 (&amp;br, &amp;iv_size))</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!gst_byte_reader_get_data (&amp;br, 16, &amp;kid))</span>
        return;
<span class="line-removed">- </span>
<span class="line-removed">-     kid_buf = gst_buffer_new_allocate (NULL, 16, NULL);</span>
<span class="line-removed">-     gst_buffer_fill (kid_buf, 0, kid, 16);</span>
<span class="line-removed">-     if (ss_info-&gt;default_properties)</span>
<span class="line-removed">-       gst_structure_free (ss_info-&gt;default_properties);</span>
<span class="line-removed">-     ss_info-&gt;default_properties =</span>
<span class="line-removed">-         gst_structure_new (&quot;application/x-cenc&quot;,</span>
<span class="line-removed">-         &quot;iv_size&quot;, G_TYPE_UINT, iv_size,</span>
<span class="line-removed">-         &quot;encrypted&quot;, G_TYPE_BOOLEAN, is_encrypted,</span>
<span class="line-removed">-         &quot;kid&quot;, GST_TYPE_BUFFER, kid_buf, NULL);</span>
<span class="line-removed">-     GST_DEBUG_OBJECT (qtdemux, &quot;default sample properties: &quot;</span>
<span class="line-removed">-         &quot;is_encrypted=%u, iv_size=%u&quot;, is_encrypted, iv_size);</span>
<span class="line-removed">-     gst_buffer_unref (kid_buf);</span>
    } else if ((flags &amp; 0x000002)) {
      uses_sub_sample_encryption = TRUE;
    }
  
    if (!gst_byte_reader_get_uint32_be (&amp;br, &amp;sample_count)) {
      GST_ERROR_OBJECT (qtdemux, &quot;Error getting box&#39;s sample count field&quot;);
      return;
    }
  
<span class="line-new-header">--- 2975,23 ---</span>
      GST_ERROR_OBJECT (qtdemux, &quot;Error getting box&#39;s flags field&quot;);
      return;
    }
  
    if ((flags &amp; 0x000001)) {
<span class="line-modified">!     if (!qtdemux_update_default_piff_encryption_settings (qtdemux, ss_info,</span>
<span class="line-modified">!             &amp;br))</span>
        return;
    } else if ((flags &amp; 0x000002)) {
      uses_sub_sample_encryption = TRUE;
    }
  
<span class="line-added">+   if (!gst_structure_get_uint (ss_info-&gt;default_properties, &quot;iv_size&quot;,</span>
<span class="line-added">+           &amp;iv_size)) {</span>
<span class="line-added">+     GST_ERROR_OBJECT (qtdemux, &quot;Error getting encryption IV size field&quot;);</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    if (!gst_byte_reader_get_uint32_be (&amp;br, &amp;sample_count)) {
      GST_ERROR_OBJECT (qtdemux, &quot;Error getting box&#39;s sample count field&quot;);
      return;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2820,10 ***</span>
<span class="line-new-header">--- 3021,11 ---</span>
      gst_structure_set (properties, &quot;iv&quot;, GST_TYPE_BUFFER, buf, NULL);
      gst_buffer_unref (buf);
  
      if (uses_sub_sample_encryption) {
        guint16 n_subsamples;
<span class="line-added">+       const GValue *kid_buf_value;</span>
  
        if (!gst_byte_reader_get_uint16_be (&amp;br, &amp;n_subsamples)
            || n_subsamples == 0) {
          GST_ERROR_OBJECT (qtdemux,
              &quot;failed to get subsample count for sample %u&quot;, i);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2838,13 ***</span>
<span class="line-new-header">--- 3040,18 ---</span>
          gst_structure_free (properties);
          qtdemux-&gt;cenc_aux_sample_count = i;
          return;
        }
        buf = gst_buffer_new_wrapped (data, n_subsamples * 6);
<span class="line-added">+ </span>
<span class="line-added">+       kid_buf_value =</span>
<span class="line-added">+           gst_structure_get_value (ss_info-&gt;default_properties, &quot;kid&quot;);</span>
<span class="line-added">+ </span>
        gst_structure_set (properties,
            &quot;subsample_count&quot;, G_TYPE_UINT, n_subsamples,
            &quot;subsamples&quot;, GST_TYPE_BUFFER, buf, NULL);
<span class="line-added">+       gst_structure_set_value (properties, &quot;kid&quot;, kid_buf_value);</span>
        gst_buffer_unref (buf);
      } else {
        gst_structure_set (properties, &quot;subsample_count&quot;, G_TYPE_UINT, 0, NULL);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3100,42 ***</span>
        GST_DEBUG_OBJECT (qtdemux, &quot;Updated segment.duration and segment.stop&quot;);
        qtdemux-&gt;segment.duration = fixeddur;
        qtdemux-&gt;segment.stop = fixeddur;
      }
    }
<span class="line-removed">-   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
<span class="line-removed">-     QtDemuxStream *stream = qtdemux-&gt;streams[i];</span>
<span class="line-removed">-     if (stream) {</span>
<span class="line-removed">-       movdur = GSTTIME_TO_QTSTREAMTIME (stream, duration);</span>
<span class="line-removed">-       if (movdur &gt; stream-&gt;duration) {</span>
<span class="line-removed">-         GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-removed">-             &quot;Updating stream #%d duration to %&quot; GST_TIME_FORMAT, i,</span>
<span class="line-removed">-             GST_TIME_ARGS (duration));</span>
<span class="line-removed">-         stream-&gt;duration = movdur;</span>
<span class="line-removed">-         /* internal duration tracking state has been updated above, so */</span>
<span class="line-removed">-         /* preserve an open-ended dummy segment rather than repeatedly updating</span>
<span class="line-removed">-          * it and spamming downstream accordingly with segment events */</span>
<span class="line-removed">-         if (stream-&gt;dummy_segment &amp;&amp;</span>
<span class="line-removed">-             GST_CLOCK_TIME_IS_VALID (stream-&gt;segments[0].duration)) {</span>
<span class="line-removed">-           /* Update all dummy values to new duration */</span>
<span class="line-removed">-           stream-&gt;segments[0].stop_time = duration;</span>
<span class="line-removed">-           stream-&gt;segments[0].duration = duration;</span>
<span class="line-removed">-           stream-&gt;segments[0].media_stop = duration;</span>
<span class="line-removed">- </span>
<span class="line-removed">-           /* let downstream know we possibly have a new stop time */</span>
<span class="line-removed">-           if (stream-&gt;segment_index != -1) {</span>
<span class="line-removed">-             GstClockTime pos;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (qtdemux-&gt;segment.rate &gt;= 0) {</span>
<span class="line-removed">-               pos = stream-&gt;segment.start;</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-               pos = stream-&gt;segment.stop;</span>
<span class="line-removed">-             }</span>
  
<span class="line-modified">!             gst_qtdemux_stream_update_segment (qtdemux, stream,</span>
<span class="line-modified">!                 stream-&gt;segment_index, pos, NULL, NULL);</span>
            }
          }
        }
      }
    }
  }
<span class="line-new-header">--- 3307,42 ---</span>
        GST_DEBUG_OBJECT (qtdemux, &quot;Updated segment.duration and segment.stop&quot;);
        qtdemux-&gt;segment.duration = fixeddur;
        qtdemux-&gt;segment.stop = fixeddur;
      }
    }
  
<span class="line-modified">!   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified">!     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added">+ </span>
<span class="line-added">+     movdur = GSTTIME_TO_QTSTREAMTIME (stream, duration);</span>
<span class="line-added">+     if (movdur &gt; stream-&gt;duration) {</span>
<span class="line-added">+       GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-added">+           &quot;Updating stream #%d duration to %&quot; GST_TIME_FORMAT, i,</span>
<span class="line-added">+           GST_TIME_ARGS (duration));</span>
<span class="line-added">+       stream-&gt;duration = movdur;</span>
<span class="line-added">+       /* internal duration tracking state has been updated above, so */</span>
<span class="line-added">+       /* preserve an open-ended dummy segment rather than repeatedly updating</span>
<span class="line-added">+        * it and spamming downstream accordingly with segment events */</span>
<span class="line-added">+       if (stream-&gt;dummy_segment &amp;&amp;</span>
<span class="line-added">+           GST_CLOCK_TIME_IS_VALID (stream-&gt;segments[0].duration)) {</span>
<span class="line-added">+         /* Update all dummy values to new duration */</span>
<span class="line-added">+         stream-&gt;segments[0].stop_time = duration;</span>
<span class="line-added">+         stream-&gt;segments[0].duration = duration;</span>
<span class="line-added">+         stream-&gt;segments[0].media_stop = duration;</span>
<span class="line-added">+ </span>
<span class="line-added">+         /* let downstream know we possibly have a new stop time */</span>
<span class="line-added">+         if (stream-&gt;segment_index != -1) {</span>
<span class="line-added">+           GstClockTime pos;</span>
<span class="line-added">+ </span>
<span class="line-added">+           if (qtdemux-&gt;segment.rate &gt;= 0) {</span>
<span class="line-added">+             pos = stream-&gt;segment.start;</span>
<span class="line-added">+           } else {</span>
<span class="line-added">+             pos = stream-&gt;segment.stop;</span>
            }
<span class="line-added">+ </span>
<span class="line-added">+           gst_qtdemux_stream_update_segment (qtdemux, stream,</span>
<span class="line-added">+               stream-&gt;segment_index, pos, NULL, NULL);</span>
          }
        }
      }
    }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3156,11 ***</span>
    guint entry_size, dur_offset, size_offset, flags_offset = 0, ct_offset = 0;
    QtDemuxSample *sample;
    gboolean ismv = FALSE;
    gint64 initial_offset;
  
<span class="line-modified">!   GST_LOG_OBJECT (qtdemux, &quot;parsing trun stream %d; &quot;</span>
        &quot;default dur %d, size %d, flags 0x%x, base offset %&quot; G_GINT64_FORMAT &quot;, &quot;
        &quot;decode ts %&quot; G_GINT64_FORMAT, stream-&gt;track_id, d_sample_duration,
        d_sample_size, d_sample_flags, *base_offset, decode_ts);
  
    if (stream-&gt;pending_seek &amp;&amp; moof_offset &lt; stream-&gt;pending_seek-&gt;moof_offset) {
<span class="line-new-header">--- 3363,11 ---</span>
    guint entry_size, dur_offset, size_offset, flags_offset = 0, ct_offset = 0;
    QtDemuxSample *sample;
    gboolean ismv = FALSE;
    gint64 initial_offset;
  
<span class="line-modified">!   GST_LOG_OBJECT (qtdemux, &quot;parsing trun track-id %d; &quot;</span>
        &quot;default dur %d, size %d, flags 0x%x, base offset %&quot; G_GINT64_FORMAT &quot;, &quot;
        &quot;decode ts %&quot; G_GINT64_FORMAT, stream-&gt;track_id, d_sample_duration,
        d_sample_size, d_sample_flags, *base_offset, decode_ts);
  
    if (stream-&gt;pending_seek &amp;&amp; moof_offset &lt; stream-&gt;pending_seek-&gt;moof_offset) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3264,11 ***</span>
  
    /* create a new array of samples if it&#39;s the first sample parsed */
    if (stream-&gt;n_samples == 0) {
      g_assert (stream-&gt;samples == NULL);
      stream-&gt;samples = g_try_new0 (QtDemuxSample, samples_count);
<span class="line-modified">!   /* or try to reallocate it with space enough to insert the new samples */</span>
    } else
      stream-&gt;samples = g_try_renew (QtDemuxSample, stream-&gt;samples,
          stream-&gt;n_samples + samples_count);
    if (stream-&gt;samples == NULL)
      goto out_of_memory;
<span class="line-new-header">--- 3471,11 ---</span>
  
    /* create a new array of samples if it&#39;s the first sample parsed */
    if (stream-&gt;n_samples == 0) {
      g_assert (stream-&gt;samples == NULL);
      stream-&gt;samples = g_try_new0 (QtDemuxSample, samples_count);
<span class="line-modified">!     /* or try to reallocate it with space enough to insert the new samples */</span>
    } else
      stream-&gt;samples = g_try_renew (QtDemuxSample, stream-&gt;samples,
          stream-&gt;n_samples + samples_count);
    if (stream-&gt;samples == NULL)
      goto out_of_memory;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3289,21 ***</span>
          /* FIXME: this is not fully correct, the timestamp refers to the random
           * access sample refered to in the tfra entry, which may not necessarily
           * be the first sample in the tfrag/trun (but hopefully/usually is) */
          timestamp = GSTTIME_TO_QTSTREAMTIME (stream, stream-&gt;pending_seek-&gt;ts);
        } else {
<span class="line-modified">!     timestamp = 0;</span>
        }
  
        gst_ts = QTSTREAMTIME_TO_GSTTIME (stream, timestamp);
        GST_INFO_OBJECT (stream-&gt;pad, &quot;first sample ts %&quot; GST_TIME_FORMAT,
            GST_TIME_ARGS (gst_ts));
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     /* subsequent fragments extend stream */</span>
<span class="line-modified">!     timestamp =</span>
<span class="line-modified">!         stream-&gt;samples[stream-&gt;n_samples - 1].timestamp +</span>
<span class="line-modified">!         stream-&gt;samples[stream-&gt;n_samples - 1].duration;</span>
  
        /* If this is a GST_FORMAT_BYTES stream and there&#39;s a significant
         * difference (1 sec.) between decode_ts and timestamp, prefer the
         * former */
        if (has_tfdt &amp;&amp; !qtdemux-&gt;upstream_format_is_time
<span class="line-new-header">--- 3496,21 ---</span>
          /* FIXME: this is not fully correct, the timestamp refers to the random
           * access sample refered to in the tfra entry, which may not necessarily
           * be the first sample in the tfrag/trun (but hopefully/usually is) */
          timestamp = GSTTIME_TO_QTSTREAMTIME (stream, stream-&gt;pending_seek-&gt;ts);
        } else {
<span class="line-modified">!         timestamp = 0;</span>
        }
  
        gst_ts = QTSTREAMTIME_TO_GSTTIME (stream, timestamp);
        GST_INFO_OBJECT (stream-&gt;pad, &quot;first sample ts %&quot; GST_TIME_FORMAT,
            GST_TIME_ARGS (gst_ts));
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       /* subsequent fragments extend stream */</span>
<span class="line-modified">!       timestamp =</span>
<span class="line-modified">!           stream-&gt;samples[stream-&gt;n_samples - 1].timestamp +</span>
<span class="line-modified">!           stream-&gt;samples[stream-&gt;n_samples - 1].duration;</span>
  
        /* If this is a GST_FORMAT_BYTES stream and there&#39;s a significant
         * difference (1 sec.) between decode_ts and timestamp, prefer the
         * former */
        if (has_tfdt &amp;&amp; !qtdemux-&gt;upstream_format_is_time
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3318,16 ***</span>
              GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream, timestamp)),
              GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream,
                      MAX (stream-&gt;duration_last_moof / 2,
                          GSTTIME_TO_QTSTREAMTIME (stream, GST_SECOND)))));
          timestamp = decode_ts;
<span class="line-modified">!   }</span>
  
        gst_ts = QTSTREAMTIME_TO_GSTTIME (stream, timestamp);
        GST_INFO_OBJECT (qtdemux, &quot;first sample ts %&quot; GST_TIME_FORMAT
            &quot; (extends previous samples)&quot;, GST_TIME_ARGS (gst_ts));
<span class="line-modified">!   }</span>
    }
  
    initial_offset = *running_offset;
  
    sample = stream-&gt;samples + stream-&gt;n_samples;
<span class="line-new-header">--- 3525,16 ---</span>
              GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream, timestamp)),
              GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream,
                      MAX (stream-&gt;duration_last_moof / 2,
                          GSTTIME_TO_QTSTREAMTIME (stream, GST_SECOND)))));
          timestamp = decode_ts;
<span class="line-modified">!       }</span>
  
        gst_ts = QTSTREAMTIME_TO_GSTTIME (stream, timestamp);
        GST_INFO_OBJECT (qtdemux, &quot;first sample ts %&quot; GST_TIME_FORMAT
            &quot; (extends previous samples)&quot;, GST_TIME_ARGS (gst_ts));
<span class="line-modified">!     }</span>
    }
  
    initial_offset = *running_offset;
  
    sample = stream-&gt;samples + stream-&gt;n_samples;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3429,26 ***</span>
    if (G_UNLIKELY (!id)) {
      GST_DEBUG_OBJECT (qtdemux, &quot;invalid track id 0&quot;);
      return NULL;
    }
  
<span class="line-modified">!   /* try to get it fast and simple */</span>
<span class="line-modified">!   if (G_LIKELY (id &lt;= qtdemux-&gt;n_streams)) {</span>
<span class="line-removed">-     stream = qtdemux-&gt;streams[id - 1];</span>
<span class="line-removed">-     if (G_LIKELY (stream-&gt;track_id == id))</span>
<span class="line-removed">-       return stream;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   /* linear search otherwise */</span>
<span class="line-removed">-   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
<span class="line-removed">-     stream = qtdemux-&gt;streams[i];</span>
      if (stream-&gt;track_id == id)
        return stream;
    }
    if (qtdemux-&gt;mss_mode) {
      /* mss should have only 1 stream anyway */
<span class="line-modified">!     return qtdemux-&gt;streams[0];</span>
    }
  
    return NULL;
  }
  
<span class="line-new-header">--- 3636,18 ---</span>
    if (G_UNLIKELY (!id)) {
      GST_DEBUG_OBJECT (qtdemux, &quot;invalid track id 0&quot;);
      return NULL;
    }
  
<span class="line-modified">!   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified">!     stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
      if (stream-&gt;track_id == id)
        return stream;
    }
    if (qtdemux-&gt;mss_mode) {
      /* mss should have only 1 stream anyway */
<span class="line-modified">!     return QTDEMUX_NTH_STREAM (qtdemux, 0);</span>
    }
  
    return NULL;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3878,12 ***</span>
    parent_box_type = QT_FOURCC ((const guint8 *) node-&gt;parent-&gt;data + 4);
  
    /* Push an event containing the pssh box onto the queues of all streams. */
    event = gst_event_new_protection (sysid_string, pssh,
        (parent_box_type == FOURCC_moov) ? &quot;isobmff/moov&quot; : &quot;isobmff/moof&quot;);
<span class="line-modified">!   for (i = 0; i &lt; qtdemux-&gt;n_streams; ++i) {</span>
<span class="line-modified">!     g_queue_push_tail (&amp;qtdemux-&gt;streams[i]-&gt;protection_scheme_event_queue,</span>
          gst_event_ref (event));
    }
    g_free (sysid_string);
    gst_event_unref (event);
    gst_buffer_unref (pssh);
<span class="line-new-header">--- 4077,16 ---</span>
    parent_box_type = QT_FOURCC ((const guint8 *) node-&gt;parent-&gt;data + 4);
  
    /* Push an event containing the pssh box onto the queues of all streams. */
    event = gst_event_new_protection (sysid_string, pssh,
        (parent_box_type == FOURCC_moov) ? &quot;isobmff/moov&quot; : &quot;isobmff/moof&quot;);
<span class="line-modified">!   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified">!     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added">+     GST_TRACE_OBJECT (qtdemux,</span>
<span class="line-added">+         &quot;adding protection event for stream %s and system %s&quot;,</span>
<span class="line-added">+         stream-&gt;stream_id, sysid_string);</span>
<span class="line-added">+     g_queue_push_tail (&amp;stream-&gt;protection_scheme_event_queue,</span>
          gst_event_ref (event));
    }
    g_free (sysid_string);
    gst_event_unref (event);
    gst_buffer_unref (pssh);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3900,10 ***</span>
<span class="line-new-header">--- 4103,11 ---</span>
    GNode *saiz_node, *saio_node, *pssh_node;
    GstByteReader saiz_data, saio_data;
    guint32 ds_size = 0, ds_duration = 0, ds_flags = 0;
    gint64 base_offset, running_offset;
    guint32 frag_num;
<span class="line-added">+   GstClockTime min_dts = GST_CLOCK_TIME_NONE;</span>
  
    /* NOTE @stream ignored */
  
    moof_node = g_node_new ((guint8 *) buffer);
    qtdemux_parse_node (qtdemux, moof_node, buffer, length);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4020,12 ***</span>
        goto next;
      }
      if (G_UNLIKELY (base_offset &lt; -1))
        goto lost_offset;
  
<span class="line-modified">!     if (qtdemux-&gt;upstream_format_is_time)</span>
<span class="line-modified">!       gst_qtdemux_stream_flush_samples_data (qtdemux, stream);</span>
  
      /* initialise moof sample data */
      stream-&gt;n_samples_moof = 0;
      stream-&gt;duration_last_moof = stream-&gt;duration_moof;
      stream-&gt;duration_moof = 0;
<span class="line-new-header">--- 4224,23 ---</span>
        goto next;
      }
      if (G_UNLIKELY (base_offset &lt; -1))
        goto lost_offset;
  
<span class="line-modified">!     min_dts = MIN (min_dts, QTSTREAMTIME_TO_GSTTIME (stream, decode_time));</span>
<span class="line-modified">! </span>
<span class="line-added">+     if (!qtdemux-&gt;pullbased) {</span>
<span class="line-added">+       /* Sample tables can grow enough to be problematic if the system memory</span>
<span class="line-added">+        * is very low (e.g. embedded devices) and the videos very long</span>
<span class="line-added">+        * (~8 MiB/hour for 25-30 fps video + typical AAC audio frames).</span>
<span class="line-added">+        * Fortunately, we can easily discard them for each new fragment when</span>
<span class="line-added">+        * we know qtdemux will not receive seeks outside of the current fragment.</span>
<span class="line-added">+        * adaptivedemux honors this assumption.</span>
<span class="line-added">+        * This optimization is also useful for applications that use qtdemux as</span>
<span class="line-added">+        * a push-based simple demuxer, like Media Source Extensions. */</span>
<span class="line-added">+       gst_qtdemux_stream_flush_samples_data (stream);</span>
<span class="line-added">+     }</span>
  
      /* initialise moof sample data */
      stream-&gt;n_samples_moof = 0;
      stream-&gt;duration_last_moof = stream-&gt;duration_moof;
      stream-&gt;duration_moof = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4070,10 ***</span>
<span class="line-new-header">--- 4285,42 ---</span>
      GST_LOG_OBJECT (qtdemux, &quot;Parsing pssh box.&quot;);
      qtdemux_parse_pssh (qtdemux, pssh_node);
      pssh_node = qtdemux_tree_get_sibling_by_type (pssh_node, FOURCC_pssh);
    }
  
<span class="line-added">+   if (!qtdemux-&gt;upstream_format_is_time &amp;&amp; !qtdemux-&gt;first_moof_already_parsed</span>
<span class="line-added">+       &amp;&amp; !qtdemux-&gt;received_seek &amp;&amp; GST_CLOCK_TIME_IS_VALID (min_dts)</span>
<span class="line-added">+       &amp;&amp; min_dts != 0) {</span>
<span class="line-added">+     /* Unless the user has explictly requested another seek, perform an</span>
<span class="line-added">+      * internal seek to the time specified in the tfdt.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * This way if the user opens a file where the first tfdt is 1 hour</span>
<span class="line-added">+      * into the presentation, they will not have to wait 1 hour for run</span>
<span class="line-added">+      * time to catch up and actual playback to start. */</span>
<span class="line-added">+     gint i;</span>
<span class="line-added">+ </span>
<span class="line-added">+     GST_DEBUG_OBJECT (qtdemux, &quot;First fragment has a non-zero tfdt, &quot;</span>
<span class="line-added">+         &quot;performing an internal seek to %&quot; GST_TIME_FORMAT,</span>
<span class="line-added">+         GST_TIME_ARGS (min_dts));</span>
<span class="line-added">+ </span>
<span class="line-added">+     qtdemux-&gt;segment.start = min_dts;</span>
<span class="line-added">+     qtdemux-&gt;segment.time = qtdemux-&gt;segment.position = min_dts;</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-added">+       QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added">+       stream-&gt;time_position = min_dts;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* Before this code was run a segment was already sent when the moov was</span>
<span class="line-added">+      * parsed... which is OK -- some apps (mostly tests) expect a segment to</span>
<span class="line-added">+      * be emitted after a moov, and we can emit a second segment anyway for</span>
<span class="line-added">+      * special cases like this. */</span>
<span class="line-added">+     qtdemux-&gt;need_segment = TRUE;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   qtdemux-&gt;first_moof_already_parsed = TRUE;</span>
<span class="line-added">+ </span>
    g_node_destroy (moof_node);
    return TRUE;
  
  missing_tfhd:
    {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4277,16 ***</span>
    }
    if (mfra) {
      if (mfra_map.memory != NULL)
        gst_buffer_unmap (mfra, &amp;mfra_map);
      gst_buffer_unref (mfra);
<span class="line-modified">! }</span>
    return ret;
  
  /* ERRORS */
  size_query_failed:
<span class="line-modified">! {</span>
      GST_WARNING_OBJECT (qtdemux, &quot;could not query upstream size&quot;);
      goto exit;
    }
  invalid_mfro_size:
    {
<span class="line-new-header">--- 4524,16 ---</span>
    }
    if (mfra) {
      if (mfra_map.memory != NULL)
        gst_buffer_unmap (mfra, &amp;mfra_map);
      gst_buffer_unref (mfra);
<span class="line-modified">!   }</span>
    return ret;
  
  /* ERRORS */
  size_query_failed:
<span class="line-modified">!   {</span>
      GST_WARNING_OBJECT (qtdemux, &quot;could not query upstream size&quot;);
      goto exit;
    }
  invalid_mfro_size:
    {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4299,22 ***</span>
      goto exit;
    }
  broken_file:
    {
      GST_WARNING_OBJECT (qtdemux, &quot;bogus mfra offset or size, broken file&quot;);
<span class="line-modified">!       goto exit;</span>
<span class="line-removed">-     }</span>
    }
  
  static guint64
  add_offset (guint64 offset, guint64 advance)
  {
    /* Avoid 64-bit overflow by clamping */
    if (offset &gt; G_MAXUINT64 - advance)
      return G_MAXUINT64;
    return offset + advance;
<span class="line-modified">!   }</span>
  
  static GstFlowReturn
  gst_qtdemux_loop_state_header (GstQTDemux * qtdemux)
  {
    guint64 length = 0;
<span class="line-new-header">--- 4546,22 ---</span>
      goto exit;
    }
  broken_file:
    {
      GST_WARNING_OBJECT (qtdemux, &quot;bogus mfra offset or size, broken file&quot;);
<span class="line-modified">!     goto exit;</span>
    }
<span class="line-added">+ }</span>
  
  static guint64
  add_offset (guint64 offset, guint64 advance)
  {
    /* Avoid 64-bit overflow by clamping */
    if (offset &gt; G_MAXUINT64 - advance)
      return G_MAXUINT64;
    return offset + advance;
<span class="line-modified">! }</span>
  
  static GstFlowReturn
  gst_qtdemux_loop_state_header (GstQTDemux * qtdemux)
  {
    guint64 length = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4516,11 ***</span>
<span class="line-new-header">--- 4763,13 ---</span>
  
  beach:
    if (ret == GST_FLOW_EOS &amp;&amp; (qtdemux-&gt;got_moov || qtdemux-&gt;media_caps)) {
      /* digested all data, show what we have */
      qtdemux_prepare_streams (qtdemux);
<span class="line-added">+     QTDEMUX_EXPOSE_LOCK (qtdemux);</span>
      ret = qtdemux_expose_streams (qtdemux);
<span class="line-added">+     QTDEMUX_EXPOSE_UNLOCK (qtdemux);</span>
  
      qtdemux-&gt;state = QTDEMUX_STATE_MOVIE;
      GST_DEBUG_OBJECT (qtdemux, &quot;switching state to STATE_MOVIE (%d)&quot;,
          qtdemux-&gt;state);
      return ret;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4533,24 ***</span>
   * of indexed stream. Only called in case of Reverse Playback
   */
  static GstFlowReturn
  gst_qtdemux_seek_to_previous_keyframe (GstQTDemux * qtdemux)
  {
<span class="line-removed">-   guint8 n = 0;</span>
    guint32 seg_idx = 0, k_index = 0;
    guint32 ref_seg_idx, ref_k_index;
    GstClockTime k_pos = 0, last_stop = 0;
    QtDemuxSegment *seg = NULL;
    QtDemuxStream *ref_str = NULL;
    guint64 seg_media_start_mov;  /* segment media start time in mov format */
    guint64 target_ts;
  
    /* Now we choose an arbitrary stream, get the previous keyframe timestamp
     * and finally align all the other streams on that timestamp with their
     * respective keyframes */
<span class="line-modified">!   for (n = 0; n &lt; qtdemux-&gt;n_streams; n++) {</span>
<span class="line-modified">!     QtDemuxStream *str = qtdemux-&gt;streams[n];</span>
  
      /* No candidate yet, take the first stream */
      if (!ref_str) {
        ref_str = str;
        continue;
<span class="line-new-header">--- 4782,24 ---</span>
   * of indexed stream. Only called in case of Reverse Playback
   */
  static GstFlowReturn
  gst_qtdemux_seek_to_previous_keyframe (GstQTDemux * qtdemux)
  {
    guint32 seg_idx = 0, k_index = 0;
    guint32 ref_seg_idx, ref_k_index;
    GstClockTime k_pos = 0, last_stop = 0;
    QtDemuxSegment *seg = NULL;
    QtDemuxStream *ref_str = NULL;
    guint64 seg_media_start_mov;  /* segment media start time in mov format */
    guint64 target_ts;
<span class="line-added">+   gint i;</span>
  
    /* Now we choose an arbitrary stream, get the previous keyframe timestamp
     * and finally align all the other streams on that timestamp with their
     * respective keyframes */
<span class="line-modified">!   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified">!     QtDemuxStream *str = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
  
      /* No candidate yet, take the first stream */
      if (!ref_str) {
        ref_str = str;
        continue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4594,11 ***</span>
    seg = &amp;ref_str-&gt;segments[ref_str-&gt;segment_index];
    /* Use segment start in original timescale for comparisons */
    seg_media_start_mov = seg-&gt;trak_media_start;
  
    GST_LOG_OBJECT (qtdemux, &quot;keyframe index %u ts %&quot; G_GUINT64_FORMAT
<span class="line-modified">!       &quot; seg start %&quot; G_GUINT64_FORMAT &quot; %&quot; GST_TIME_FORMAT &quot;\n&quot;,</span>
        k_index, target_ts, seg_media_start_mov,
        GST_TIME_ARGS (seg-&gt;media_start));
  
    /* Crawl back through segments to find the one containing this I frame */
    while (target_ts &lt; seg_media_start_mov) {
<span class="line-new-header">--- 4843,11 ---</span>
    seg = &amp;ref_str-&gt;segments[ref_str-&gt;segment_index];
    /* Use segment start in original timescale for comparisons */
    seg_media_start_mov = seg-&gt;trak_media_start;
  
    GST_LOG_OBJECT (qtdemux, &quot;keyframe index %u ts %&quot; G_GUINT64_FORMAT
<span class="line-modified">!       &quot; seg start %&quot; G_GUINT64_FORMAT &quot; %&quot; GST_TIME_FORMAT,</span>
        k_index, target_ts, seg_media_start_mov,
        GST_TIME_ARGS (seg-&gt;media_start));
  
    /* Crawl back through segments to find the one containing this I frame */
    while (target_ts &lt; seg_media_start_mov) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4641,29 ***</span>
  
    ref_seg_idx = ref_str-&gt;segment_index;
    ref_k_index = k_index;
  
    /* Align them all on this */
<span class="line-modified">!   for (n = 0; n &lt; qtdemux-&gt;n_streams; n++) {</span>
      guint32 index = 0;
      GstClockTime seg_time = 0;
<span class="line-modified">!     QtDemuxStream *str = qtdemux-&gt;streams[n];</span>
  
      /* aligning reference stream again might lead to backing up to yet another
       * keyframe (due to timestamp rounding issues),
       * potentially putting more load on downstream; so let&#39;s try to avoid */
      if (str == ref_str) {
        seg_idx = ref_seg_idx;
        seg = &amp;str-&gt;segments[seg_idx];
        k_index = ref_k_index;
<span class="line-modified">!       GST_DEBUG_OBJECT (qtdemux, &quot;reference stream %d segment %d, &quot;</span>
<span class="line-modified">!           &quot;sample at index %d&quot;, n, ref_str-&gt;segment_index, k_index);</span>
      } else {
        seg_idx = gst_qtdemux_find_segment (qtdemux, str, k_pos);
        GST_DEBUG_OBJECT (qtdemux,
<span class="line-modified">!           &quot;stream %d align segment %d for keyframe pos %&quot; GST_TIME_FORMAT, n,</span>
<span class="line-modified">!           seg_idx, GST_TIME_ARGS (k_pos));</span>
  
        /* get segment and time in the segment */
        seg = &amp;str-&gt;segments[seg_idx];
        seg_time = k_pos - seg-&gt;time;
  
<span class="line-new-header">--- 4890,29 ---</span>
  
    ref_seg_idx = ref_str-&gt;segment_index;
    ref_k_index = k_index;
  
    /* Align them all on this */
<span class="line-modified">!   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
      guint32 index = 0;
      GstClockTime seg_time = 0;
<span class="line-modified">!     QtDemuxStream *str = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
  
      /* aligning reference stream again might lead to backing up to yet another
       * keyframe (due to timestamp rounding issues),
       * potentially putting more load on downstream; so let&#39;s try to avoid */
      if (str == ref_str) {
        seg_idx = ref_seg_idx;
        seg = &amp;str-&gt;segments[seg_idx];
        k_index = ref_k_index;
<span class="line-modified">!       GST_DEBUG_OBJECT (qtdemux, &quot;reference track-id %u segment %d, &quot;</span>
<span class="line-modified">!           &quot;sample at index %d&quot;, str-&gt;track_id, ref_str-&gt;segment_index, k_index);</span>
      } else {
        seg_idx = gst_qtdemux_find_segment (qtdemux, str, k_pos);
        GST_DEBUG_OBJECT (qtdemux,
<span class="line-modified">!           &quot;track-id %u align segment %d for keyframe pos %&quot; GST_TIME_FORMAT,</span>
<span class="line-modified">!           str-&gt;track_id, seg_idx, GST_TIME_ARGS (k_pos));</span>
  
        /* get segment and time in the segment */
        seg = &amp;str-&gt;segments[seg_idx];
        seg_time = k_pos - seg-&gt;time;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4673,11 ***</span>
          seg_time += seg-&gt;media_start;
  
        /* get the index of the sample with media time */
        index = gst_qtdemux_find_index_linear (qtdemux, str, seg_time);
        GST_DEBUG_OBJECT (qtdemux,
<span class="line-modified">!           &quot;stream %d sample for %&quot; GST_TIME_FORMAT &quot; at %u&quot;, n,</span>
            GST_TIME_ARGS (seg_time), index);
  
        /* find previous keyframe */
        k_index = gst_qtdemux_find_keyframe (qtdemux, str, index, FALSE);
      }
<span class="line-new-header">--- 4922,11 ---</span>
          seg_time += seg-&gt;media_start;
  
        /* get the index of the sample with media time */
        index = gst_qtdemux_find_index_linear (qtdemux, str, seg_time);
        GST_DEBUG_OBJECT (qtdemux,
<span class="line-modified">!           &quot;track-id %u sample for %&quot; GST_TIME_FORMAT &quot; at %u&quot;, str-&gt;track_id,</span>
            GST_TIME_ARGS (seg_time), index);
  
        /* find previous keyframe */
        k_index = gst_qtdemux_find_keyframe (qtdemux, str, index, FALSE);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4691,12 ***</span>
      if (seg-&gt;media_start != GST_CLOCK_TIME_NONE)
        str-&gt;time_position -= seg-&gt;media_start;
  
      /* Now seek back in time */
      gst_qtdemux_move_stream (qtdemux, str, k_index);
<span class="line-modified">!     GST_DEBUG_OBJECT (qtdemux, &quot;stream %d keyframe at %u, time position %&quot;</span>
<span class="line-modified">!         GST_TIME_FORMAT &quot; playing from sample %u to %u&quot;, n, k_index,</span>
          GST_TIME_ARGS (str-&gt;time_position), str-&gt;from_sample, str-&gt;to_sample);
    }
  
    return GST_FLOW_OK;
  
<span class="line-new-header">--- 4940,12 ---</span>
      if (seg-&gt;media_start != GST_CLOCK_TIME_NONE)
        str-&gt;time_position -= seg-&gt;media_start;
  
      /* Now seek back in time */
      gst_qtdemux_move_stream (qtdemux, str, k_index);
<span class="line-modified">!     GST_DEBUG_OBJECT (qtdemux, &quot;track-id %u keyframe at %u, time position %&quot;</span>
<span class="line-modified">!         GST_TIME_FORMAT &quot; playing from sample %u to %u&quot;, str-&gt;track_id, k_index,</span>
          GST_TIME_ARGS (str-&gt;time_position), str-&gt;from_sample, str-&gt;to_sample);
    }
  
    return GST_FLOW_OK;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4902,25 ***</span>
      return TRUE;
  
    /* and move to the keyframe before the indicated media time of the
     * segment */
    if (G_LIKELY (!QTSEGMENT_IS_EMPTY (segment))) {
<span class="line-modified">!   if (qtdemux-&gt;segment.rate &gt;= 0) {</span>
<span class="line-modified">!     index = gst_qtdemux_find_index_linear (qtdemux, stream, start);</span>
<span class="line-modified">!     stream-&gt;to_sample = G_MAXUINT32;</span>
        GST_DEBUG_OBJECT (stream-&gt;pad,
            &quot;moving data pointer to %&quot; GST_TIME_FORMAT &quot;, index: %u, pts %&quot;
            GST_TIME_FORMAT, GST_TIME_ARGS (start), index,
            GST_TIME_ARGS (QTSAMPLE_PTS (stream, &amp;stream-&gt;samples[index])));
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     index = gst_qtdemux_find_index_linear (qtdemux, stream, stop);</span>
<span class="line-modified">!     stream-&gt;to_sample = index;</span>
        GST_DEBUG_OBJECT (stream-&gt;pad,
            &quot;moving data pointer to %&quot; GST_TIME_FORMAT &quot;, index: %u, pts %&quot;
            GST_TIME_FORMAT, GST_TIME_ARGS (stop), index,
            GST_TIME_ARGS (QTSAMPLE_PTS (stream, &amp;stream-&gt;samples[index])));
<span class="line-modified">!   }</span>
    } else {
      GST_DEBUG_OBJECT (stream-&gt;pad, &quot;No need to look for keyframe, &quot;
          &quot;this is an empty segment&quot;);
      return TRUE;
    }
<span class="line-new-header">--- 5151,25 ---</span>
      return TRUE;
  
    /* and move to the keyframe before the indicated media time of the
     * segment */
    if (G_LIKELY (!QTSEGMENT_IS_EMPTY (segment))) {
<span class="line-modified">!     if (qtdemux-&gt;segment.rate &gt;= 0) {</span>
<span class="line-modified">!       index = gst_qtdemux_find_index_linear (qtdemux, stream, start);</span>
<span class="line-modified">!       stream-&gt;to_sample = G_MAXUINT32;</span>
        GST_DEBUG_OBJECT (stream-&gt;pad,
            &quot;moving data pointer to %&quot; GST_TIME_FORMAT &quot;, index: %u, pts %&quot;
            GST_TIME_FORMAT, GST_TIME_ARGS (start), index,
            GST_TIME_ARGS (QTSAMPLE_PTS (stream, &amp;stream-&gt;samples[index])));
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       index = gst_qtdemux_find_index_linear (qtdemux, stream, stop);</span>
<span class="line-modified">!       stream-&gt;to_sample = index;</span>
        GST_DEBUG_OBJECT (stream-&gt;pad,
            &quot;moving data pointer to %&quot; GST_TIME_FORMAT &quot;, index: %u, pts %&quot;
            GST_TIME_FORMAT, GST_TIME_ARGS (stop), index,
            GST_TIME_ARGS (QTSAMPLE_PTS (stream, &amp;stream-&gt;samples[index])));
<span class="line-modified">!     }</span>
    } else {
      GST_DEBUG_OBJECT (stream-&gt;pad, &quot;No need to look for keyframe, &quot;
          &quot;this is an empty segment&quot;);
      return TRUE;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5005,12 ***</span>
  
    /* different segment, activate it, sample_index will be set. */
    if (G_UNLIKELY (stream-&gt;segment_index != seg_idx))
      gst_qtdemux_activate_segment (qtdemux, stream, seg_idx, time_position);
  
<span class="line-modified">!   if (G_UNLIKELY (QTSEGMENT_IS_EMPTY (&amp;stream-&gt;segments[stream-&gt;</span>
<span class="line-modified">!                   segment_index]))) {</span>
      QtDemuxSegment *seg = &amp;stream-&gt;segments[stream-&gt;segment_index];
  
      GST_LOG_OBJECT (qtdemux, &quot;Empty segment activated,&quot;
          &quot; prepare empty sample&quot;);
  
<span class="line-new-header">--- 5254,12 ---</span>
  
    /* different segment, activate it, sample_index will be set. */
    if (G_UNLIKELY (stream-&gt;segment_index != seg_idx))
      gst_qtdemux_activate_segment (qtdemux, stream, seg_idx, time_position);
  
<span class="line-modified">!   if (G_UNLIKELY (QTSEGMENT_IS_EMPTY (&amp;stream-&gt;</span>
<span class="line-modified">!               segments[stream-&gt;segment_index]))) {</span>
      QtDemuxSegment *seg = &amp;stream-&gt;segments[stream-&gt;segment_index];
  
      GST_LOG_OBJECT (qtdemux, &quot;Empty segment activated,&quot;
          &quot; prepare empty sample&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5029,11 ***</span>
    GST_LOG_OBJECT (qtdemux, &quot;segment active, index = %u of %u&quot;,
        stream-&gt;sample_index, stream-&gt;n_samples);
  
    if (G_UNLIKELY (stream-&gt;sample_index &gt;= stream-&gt;n_samples)) {
      if (!qtdemux-&gt;fragmented)
<span class="line-modified">!     goto eos;</span>
  
      GST_INFO_OBJECT (qtdemux, &quot;out of samples, trying to add more&quot;);
      do {
        GstFlowReturn flow;
  
<span class="line-new-header">--- 5278,11 ---</span>
    GST_LOG_OBJECT (qtdemux, &quot;segment active, index = %u of %u&quot;,
        stream-&gt;sample_index, stream-&gt;n_samples);
  
    if (G_UNLIKELY (stream-&gt;sample_index &gt;= stream-&gt;n_samples)) {
      if (!qtdemux-&gt;fragmented)
<span class="line-modified">!       goto eos;</span>
  
      GST_INFO_OBJECT (qtdemux, &quot;out of samples, trying to add more&quot;);
      do {
        GstFlowReturn flow;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5160,18 ***</span>
  static void
  gst_qtdemux_sync_streams (GstQTDemux * demux)
  {
    gint i;
  
<span class="line-modified">!   if (demux-&gt;n_streams &lt;= 1)</span>
      return;
  
<span class="line-modified">!   for (i = 0; i &lt; demux-&gt;n_streams; i++) {</span>
      QtDemuxStream *stream;
      GstClockTime end_time;
  
<span class="line-modified">!     stream = demux-&gt;streams[i];</span>
  
      if (!stream-&gt;pad)
        continue;
  
      /* TODO advance time on subtitle streams here, if any some day */
<span class="line-new-header">--- 5409,18 ---</span>
  static void
  gst_qtdemux_sync_streams (GstQTDemux * demux)
  {
    gint i;
  
<span class="line-modified">!   if (QTDEMUX_N_STREAMS (demux) &lt;= 1)</span>
      return;
  
<span class="line-modified">!   for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
      QtDemuxStream *stream;
      GstClockTime end_time;
  
<span class="line-modified">!     stream = QTDEMUX_NTH_STREAM (demux, i);</span>
  
      if (!stream-&gt;pad)
        continue;
  
      /* TODO advance time on subtitle streams here, if any some day */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5230,11 ***</span>
  
    if (stream-&gt;pad)
      ret = gst_flow_combiner_update_pad_flow (demux-&gt;flowcombiner, stream-&gt;pad,
          ret);
    else
<span class="line-modified">!   ret = gst_flow_combiner_update_flow (demux-&gt;flowcombiner, ret);</span>
  
    GST_LOG_OBJECT (demux, &quot;combined flow return: %s&quot;, gst_flow_get_name (ret));
    return ret;
  }
  
<span class="line-new-header">--- 5479,11 ---</span>
  
    if (stream-&gt;pad)
      ret = gst_flow_combiner_update_pad_flow (demux-&gt;flowcombiner, stream-&gt;pad,
          ret);
    else
<span class="line-modified">!     ret = gst_flow_combiner_update_flow (demux-&gt;flowcombiner, ret);</span>
  
    GST_LOG_OBJECT (demux, &quot;combined flow return: %s&quot;, gst_flow_get_name (ret));
    return ret;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5277,11 ***</span>
    /* we can only clip if we have a valid pts */
    pts = GST_BUFFER_PTS (buf);
    if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (pts)))
      goto no_pts;
  
<span class="line-modified">!     duration = GST_BUFFER_DURATION (buf);</span>
  
    if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (duration))) {
      duration =
          gst_util_uint64_scale_int (size / frame_size, num_rate, denom_rate);
    }
<span class="line-new-header">--- 5526,11 ---</span>
    /* we can only clip if we have a valid pts */
    pts = GST_BUFFER_PTS (buf);
    if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (pts)))
      goto no_pts;
  
<span class="line-modified">!   duration = GST_BUFFER_DURATION (buf);</span>
  
    if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (duration))) {
      duration =
          gst_util_uint64_scale_int (size / frame_size, num_rate, denom_rate);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5396,10 ***</span>
<span class="line-new-header">--- 5645,137 ---</span>
  
    gst_buffer_unmap (buffer, &amp;map);
    return buffer;
  }
  
<span class="line-added">+ static guint8 *</span>
<span class="line-added">+ convert_to_s334_1a (const guint8 * ccpair, guint8 ccpair_size, guint field,</span>
<span class="line-added">+     gsize * res)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   guint8 *storage;</span>
<span class="line-added">+   gsize i;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* We are converting from pairs to triplets */</span>
<span class="line-added">+   *res = ccpair_size / 2 * 3;</span>
<span class="line-added">+   storage = g_malloc (*res);</span>
<span class="line-added">+   for (i = 0; i * 2 &lt; ccpair_size; i += 1) {</span>
<span class="line-added">+     /* FIXME: Use line offset 0 as we simply can&#39;t know here */</span>
<span class="line-added">+     if (field == 1)</span>
<span class="line-added">+       storage[i * 3] = 0x80 | 0x00;</span>
<span class="line-added">+     else</span>
<span class="line-added">+       storage[i * 3] = 0x00 | 0x00;</span>
<span class="line-added">+     storage[i * 3 + 1] = ccpair[i * 2];</span>
<span class="line-added">+     storage[i * 3 + 2] = ccpair[i * 2 + 1];</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return storage;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static guint8 *</span>
<span class="line-added">+ extract_cc_from_data (QtDemuxStream * stream, const guint8 * data, gsize size,</span>
<span class="line-added">+     gsize * cclen)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   guint8 *res = NULL;</span>
<span class="line-added">+   guint32 atom_length, fourcc;</span>
<span class="line-added">+   QtDemuxStreamStsdEntry *stsd_entry;</span>
<span class="line-added">+ </span>
<span class="line-added">+   GST_MEMDUMP (&quot;caption atom&quot;, data, size);</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* There might be multiple atoms */</span>
<span class="line-added">+ </span>
<span class="line-added">+   *cclen = 0;</span>
<span class="line-added">+   if (size &lt; 8)</span>
<span class="line-added">+     goto invalid_cdat;</span>
<span class="line-added">+   atom_length = QT_UINT32 (data);</span>
<span class="line-added">+   fourcc = QT_FOURCC (data + 4);</span>
<span class="line-added">+   if (G_UNLIKELY (atom_length &gt; size || atom_length == 8))</span>
<span class="line-added">+     goto invalid_cdat;</span>
<span class="line-added">+ </span>
<span class="line-added">+   GST_DEBUG_OBJECT (stream-&gt;pad, &quot;here&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Check if we have somethig compatible */</span>
<span class="line-added">+   stsd_entry = CUR_STREAM (stream);</span>
<span class="line-added">+   switch (stsd_entry-&gt;fourcc) {</span>
<span class="line-added">+     case FOURCC_c608:{</span>
<span class="line-added">+       guint8 *cdat = NULL, *cdt2 = NULL;</span>
<span class="line-added">+       gsize cdat_size = 0, cdt2_size = 0;</span>
<span class="line-added">+       /* Should be cdat or cdt2 */</span>
<span class="line-added">+       if (fourcc != FOURCC_cdat &amp;&amp; fourcc != FOURCC_cdt2) {</span>
<span class="line-added">+         GST_WARNING_OBJECT (stream-&gt;pad,</span>
<span class="line-added">+             &quot;Unknown data atom (%&quot; GST_FOURCC_FORMAT &quot;) for CEA608&quot;,</span>
<span class="line-added">+             GST_FOURCC_ARGS (fourcc));</span>
<span class="line-added">+         goto invalid_cdat;</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+       /* Convert to S334-1 Annex A byte triplet */</span>
<span class="line-added">+       if (fourcc == FOURCC_cdat)</span>
<span class="line-added">+         cdat = convert_to_s334_1a (data + 8, atom_length - 8, 1, &amp;cdat_size);</span>
<span class="line-added">+       else</span>
<span class="line-added">+         cdt2 = convert_to_s334_1a (data + 8, atom_length - 8, 2, &amp;cdt2_size);</span>
<span class="line-added">+       GST_DEBUG_OBJECT (stream-&gt;pad, &quot;size:%&quot; G_GSIZE_FORMAT &quot; atom_length:%u&quot;,</span>
<span class="line-added">+           size, atom_length);</span>
<span class="line-added">+ </span>
<span class="line-added">+       /* Check for another atom ? */</span>
<span class="line-added">+       if (size &gt; atom_length + 8) {</span>
<span class="line-added">+         guint32 new_atom_length = QT_UINT32 (data + atom_length);</span>
<span class="line-added">+         if (size &gt;= atom_length + new_atom_length) {</span>
<span class="line-added">+           fourcc = QT_FOURCC (data + atom_length + 4);</span>
<span class="line-added">+           if (fourcc == FOURCC_cdat) {</span>
<span class="line-added">+             if (cdat == NULL)</span>
<span class="line-added">+               cdat =</span>
<span class="line-added">+                   convert_to_s334_1a (data + atom_length + 8,</span>
<span class="line-added">+                   new_atom_length - 8, 1, &amp;cdat_size);</span>
<span class="line-added">+             else</span>
<span class="line-added">+               GST_WARNING_OBJECT (stream-&gt;pad,</span>
<span class="line-added">+                   &quot;Got multiple [cdat] atoms in a c608 sample. This is unsupported for now. Please file a bug&quot;);</span>
<span class="line-added">+           } else {</span>
<span class="line-added">+             if (cdt2 == NULL)</span>
<span class="line-added">+               cdt2 =</span>
<span class="line-added">+                   convert_to_s334_1a (data + atom_length + 8,</span>
<span class="line-added">+                   new_atom_length - 8, 2, &amp;cdt2_size);</span>
<span class="line-added">+             else</span>
<span class="line-added">+               GST_WARNING_OBJECT (stream-&gt;pad,</span>
<span class="line-added">+                   &quot;Got multiple [cdt2] atoms in a c608 sample. This is unsupported for now. Please file a bug&quot;);</span>
<span class="line-added">+           }</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+       *cclen = cdat_size + cdt2_size;</span>
<span class="line-added">+       res = g_malloc (*cclen);</span>
<span class="line-added">+       if (cdat_size)</span>
<span class="line-added">+         memcpy (res, cdat, cdat_size);</span>
<span class="line-added">+       if (cdt2_size)</span>
<span class="line-added">+         memcpy (res + cdat_size, cdt2, cdt2_size);</span>
<span class="line-added">+       g_free (cdat);</span>
<span class="line-added">+       g_free (cdt2);</span>
<span class="line-added">+     }</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     case FOURCC_c708:</span>
<span class="line-added">+       if (fourcc != FOURCC_ccdp) {</span>
<span class="line-added">+         GST_WARNING_OBJECT (stream-&gt;pad,</span>
<span class="line-added">+             &quot;Unknown data atom (%&quot; GST_FOURCC_FORMAT &quot;) for CEA708&quot;,</span>
<span class="line-added">+             GST_FOURCC_ARGS (fourcc));</span>
<span class="line-added">+         goto invalid_cdat;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       *cclen = atom_length - 8;</span>
<span class="line-added">+       res = g_memdup (data + 8, *cclen);</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+       /* Keep this here in case other closed caption formats are added */</span>
<span class="line-added">+       g_assert_not_reached ();</span>
<span class="line-added">+       break;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   GST_MEMDUMP (&quot;Output&quot;, res, *cclen);</span>
<span class="line-added">+   return res;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Errors */</span>
<span class="line-added">+ invalid_cdat:</span>
<span class="line-added">+   GST_WARNING (&quot;[cdat] atom is too small or invalid&quot;);</span>
<span class="line-added">+   return NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  /* the input buffer metadata must be writable,
   * but time/duration etc not yet set and need not be preserved */
  static GstBuffer *
  gst_qtdemux_process_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,
      GstBuffer * buf)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5416,11 ***</span>
      stream-&gt;pending_event = NULL;
    }
  
    if (G_UNLIKELY (stream-&gt;subtype != FOURCC_text
            &amp;&amp; stream-&gt;subtype != FOURCC_sbtl &amp;&amp;
<span class="line-modified">!           stream-&gt;subtype != FOURCC_subp)) {</span>
      return buf;
    }
  
    gst_buffer_map (buf, &amp;map, GST_MAP_READ);
  
<span class="line-new-header">--- 5792,11 ---</span>
      stream-&gt;pending_event = NULL;
    }
  
    if (G_UNLIKELY (stream-&gt;subtype != FOURCC_text
            &amp;&amp; stream-&gt;subtype != FOURCC_sbtl &amp;&amp;
<span class="line-modified">!           stream-&gt;subtype != FOURCC_subp &amp;&amp; stream-&gt;subtype != FOURCC_clcp)) {</span>
      return buf;
    }
  
    gst_buffer_map (buf, &amp;map, GST_MAP_READ);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5434,10 ***</span>
<span class="line-new-header">--- 5810,27 ---</span>
      /* That&#39;s all the processing needed for subpictures */
      gst_buffer_unmap (buf, &amp;map);
      return buf;
    }
  
<span class="line-added">+   if (stream-&gt;subtype == FOURCC_clcp) {</span>
<span class="line-added">+     guint8 *cc;</span>
<span class="line-added">+     gsize cclen = 0;</span>
<span class="line-added">+     /* For closed caption, we need to extract the information from the</span>
<span class="line-added">+      * [cdat],[cdt2] or [ccdp] atom */</span>
<span class="line-added">+     cc = extract_cc_from_data (stream, map.data, map.size, &amp;cclen);</span>
<span class="line-added">+     gst_buffer_unmap (buf, &amp;map);</span>
<span class="line-added">+     gst_buffer_unref (buf);</span>
<span class="line-added">+     if (cc) {</span>
<span class="line-added">+       buf = _gst_buffer_new_wrapped (cc, cclen, g_free);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       /* Conversion failed or there&#39;s nothing */</span>
<span class="line-added">+       buf = NULL;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return buf;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    nsize = GST_READ_UINT16_BE (map.data);
    nsize = MIN (nsize, map.size - 2);
  
    GST_LOG_OBJECT (qtdemux, &quot;3GPP timed text subtitle: %d/%&quot; G_GSIZE_FORMAT &quot;&quot;,
        nsize, map.size);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5458,10 ***</span>
<span class="line-new-header">--- 5851,214 ---</span>
    /* FIXME ? convert optional subsequent style info to markup */
  
    return buf;
  }
  
<span class="line-added">+ static GstFlowReturn</span>
<span class="line-added">+ gst_qtdemux_push_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,</span>
<span class="line-added">+     GstBuffer * buf)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   GstFlowReturn ret = GST_FLOW_OK;</span>
<span class="line-added">+   GstClockTime pts, duration;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (stream-&gt;need_clip)</span>
<span class="line-added">+     buf = gst_qtdemux_clip_buffer (qtdemux, stream, buf);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (G_UNLIKELY (buf == NULL))</span>
<span class="line-added">+     goto exit;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (G_UNLIKELY (stream-&gt;discont)) {</span>
<span class="line-added">+     GST_LOG_OBJECT (qtdemux, &quot;marking discont buffer&quot;);</span>
<span class="line-added">+     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);</span>
<span class="line-added">+     stream-&gt;discont = FALSE;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DISCONT);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   GST_LOG_OBJECT (qtdemux,</span>
<span class="line-added">+       &quot;Pushing buffer with dts %&quot; GST_TIME_FORMAT &quot;, pts %&quot; GST_TIME_FORMAT</span>
<span class="line-added">+       &quot;, duration %&quot; GST_TIME_FORMAT &quot; on pad %s&quot;,</span>
<span class="line-added">+       GST_TIME_ARGS (GST_BUFFER_DTS (buf)),</span>
<span class="line-added">+       GST_TIME_ARGS (GST_BUFFER_PTS (buf)),</span>
<span class="line-added">+       GST_TIME_ARGS (GST_BUFFER_DURATION (buf)), GST_PAD_NAME (stream-&gt;pad));</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (stream-&gt;protected &amp;&amp; stream-&gt;protection_scheme_type == FOURCC_cenc) {</span>
<span class="line-added">+     GstStructure *crypto_info;</span>
<span class="line-added">+     QtDemuxCencSampleSetInfo *info =</span>
<span class="line-added">+         (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;</span>
<span class="line-added">+     gint index;</span>
<span class="line-added">+     GstEvent *event;</span>
<span class="line-added">+ </span>
<span class="line-added">+     while ((event = g_queue_pop_head (&amp;stream-&gt;protection_scheme_event_queue))) {</span>
<span class="line-added">+       GST_TRACE_OBJECT (stream-&gt;pad, &quot;pushing protection event: %&quot;</span>
<span class="line-added">+           GST_PTR_FORMAT, event);</span>
<span class="line-added">+       gst_pad_push_event (stream-&gt;pad, event);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (info-&gt;crypto_info == NULL) {</span>
<span class="line-added">+       GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-added">+           &quot;cenc metadata hasn&#39;t been parsed yet, pushing buffer as if it wasn&#39;t encrypted&quot;);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       /* The end of the crypto_info array matches our n_samples position,</span>
<span class="line-added">+        * so count backward from there */</span>
<span class="line-added">+       index = stream-&gt;sample_index - stream-&gt;n_samples + info-&gt;crypto_info-&gt;len;</span>
<span class="line-added">+       if (G_LIKELY (index &gt;= 0 &amp;&amp; index &lt; info-&gt;crypto_info-&gt;len)) {</span>
<span class="line-added">+         /* steal structure from array */</span>
<span class="line-added">+         crypto_info = g_ptr_array_index (info-&gt;crypto_info, index);</span>
<span class="line-added">+         g_ptr_array_index (info-&gt;crypto_info, index) = NULL;</span>
<span class="line-added">+         GST_LOG_OBJECT (qtdemux, &quot;attaching cenc metadata [%u/%u]&quot;, index,</span>
<span class="line-added">+             info-&gt;crypto_info-&gt;len);</span>
<span class="line-added">+         if (!crypto_info || !gst_buffer_add_protection_meta (buf, crypto_info))</span>
<span class="line-added">+           GST_ERROR_OBJECT (qtdemux,</span>
<span class="line-added">+               &quot;failed to attach cenc metadata to buffer&quot;);</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         GST_INFO_OBJECT (qtdemux, &quot;No crypto info with index %d and sample %d&quot;,</span>
<span class="line-added">+             index, stream-&gt;sample_index);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (stream-&gt;alignment &gt; 1)</span>
<span class="line-added">+     buf = gst_qtdemux_align_buffer (qtdemux, buf, stream-&gt;alignment);</span>
<span class="line-added">+ </span>
<span class="line-added">+   pts = GST_BUFFER_PTS (buf);</span>
<span class="line-added">+   duration = GST_BUFFER_DURATION (buf);</span>
<span class="line-added">+ </span>
<span class="line-added">+   ret = gst_pad_push (stream-&gt;pad, buf);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (GST_CLOCK_TIME_IS_VALID (pts) &amp;&amp; GST_CLOCK_TIME_IS_VALID (duration)) {</span>
<span class="line-added">+     /* mark position in stream, we&#39;ll need this to know when to send GAP event */</span>
<span class="line-added">+     stream-&gt;segment.position = pts + duration;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ exit:</span>
<span class="line-added">+ </span>
<span class="line-added">+   return ret;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static GstFlowReturn</span>
<span class="line-added">+ gst_qtdemux_split_and_push_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,</span>
<span class="line-added">+     GstBuffer * buf)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   GstFlowReturn ret = GST_FLOW_OK;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (stream-&gt;subtype == FOURCC_clcp</span>
<span class="line-added">+       &amp;&amp; CUR_STREAM (stream)-&gt;fourcc == FOURCC_c608 &amp;&amp; stream-&gt;need_split) {</span>
<span class="line-added">+     GstMapInfo map;</span>
<span class="line-added">+     guint n_output_buffers, n_field1 = 0, n_field2 = 0;</span>
<span class="line-added">+     guint n_triplets, i;</span>
<span class="line-added">+     guint field1_off = 0, field2_off = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* We have to split CEA608 buffers so that each outgoing buffer contains</span>
<span class="line-added">+      * one byte pair per field according to the framerate of the video track.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * If there is only a single byte pair per field we don&#39;t have to do</span>
<span class="line-added">+      * anything</span>
<span class="line-added">+      */</span>
<span class="line-added">+ </span>
<span class="line-added">+     gst_buffer_map (buf, &amp;map, GST_MAP_READ);</span>
<span class="line-added">+ </span>
<span class="line-added">+     n_triplets = map.size / 3;</span>
<span class="line-added">+     for (i = 0; i &lt; n_triplets; i++) {</span>
<span class="line-added">+       if (map.data[3 * i] &amp; 0x80)</span>
<span class="line-added">+         n_field1++;</span>
<span class="line-added">+       else</span>
<span class="line-added">+         n_field2++;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     g_assert (n_field1 || n_field2);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* If there&#39;s more than 1 frame we have to split, otherwise we can just</span>
<span class="line-added">+      * pass through */</span>
<span class="line-added">+     if (n_field1 &gt; 1 || n_field2 &gt; 1) {</span>
<span class="line-added">+       n_output_buffers =</span>
<span class="line-added">+           gst_util_uint64_scale (GST_BUFFER_DURATION (buf),</span>
<span class="line-added">+           CUR_STREAM (stream)-&gt;fps_n, GST_SECOND * CUR_STREAM (stream)-&gt;fps_d);</span>
<span class="line-added">+ </span>
<span class="line-added">+       for (i = 0; i &lt; n_output_buffers; i++) {</span>
<span class="line-added">+         GstBuffer *outbuf =</span>
<span class="line-added">+             gst_buffer_new_and_alloc ((n_field1 ? 3 : 0) + (n_field2 ? 3 : 0));</span>
<span class="line-added">+         GstMapInfo outmap;</span>
<span class="line-added">+         guint8 *outptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+         gst_buffer_map (outbuf, &amp;outmap, GST_MAP_WRITE);</span>
<span class="line-added">+         outptr = outmap.data;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (n_field1) {</span>
<span class="line-added">+           gboolean found = FALSE;</span>
<span class="line-added">+ </span>
<span class="line-added">+           while (map.data + field1_off &lt; map.data + map.size) {</span>
<span class="line-added">+             if (map.data[field1_off] &amp; 0x80) {</span>
<span class="line-added">+               memcpy (outptr, &amp;map.data[field1_off], 3);</span>
<span class="line-added">+               field1_off += 3;</span>
<span class="line-added">+               found = TRUE;</span>
<span class="line-added">+               break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             field1_off += 3;</span>
<span class="line-added">+           }</span>
<span class="line-added">+ </span>
<span class="line-added">+           if (!found) {</span>
<span class="line-added">+             const guint8 empty[] = { 0x80, 0x80, 0x80 };</span>
<span class="line-added">+ </span>
<span class="line-added">+             memcpy (outptr, empty, 3);</span>
<span class="line-added">+           }</span>
<span class="line-added">+ </span>
<span class="line-added">+           outptr += 3;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (n_field2) {</span>
<span class="line-added">+           gboolean found = FALSE;</span>
<span class="line-added">+ </span>
<span class="line-added">+           while (map.data + field2_off &lt; map.data + map.size) {</span>
<span class="line-added">+             if ((map.data[field2_off] &amp; 0x80) == 0) {</span>
<span class="line-added">+               memcpy (outptr, &amp;map.data[field2_off], 3);</span>
<span class="line-added">+               field2_off += 3;</span>
<span class="line-added">+               found = TRUE;</span>
<span class="line-added">+               break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             field2_off += 3;</span>
<span class="line-added">+           }</span>
<span class="line-added">+ </span>
<span class="line-added">+           if (!found) {</span>
<span class="line-added">+             const guint8 empty[] = { 0x00, 0x80, 0x80 };</span>
<span class="line-added">+ </span>
<span class="line-added">+             memcpy (outptr, empty, 3);</span>
<span class="line-added">+           }</span>
<span class="line-added">+ </span>
<span class="line-added">+           outptr += 3;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         gst_buffer_unmap (outbuf, &amp;outmap);</span>
<span class="line-added">+ </span>
<span class="line-added">+         GST_BUFFER_PTS (outbuf) =</span>
<span class="line-added">+             GST_BUFFER_PTS (buf) + gst_util_uint64_scale (i,</span>
<span class="line-added">+             GST_SECOND * CUR_STREAM (stream)-&gt;fps_d,</span>
<span class="line-added">+             CUR_STREAM (stream)-&gt;fps_n);</span>
<span class="line-added">+         GST_BUFFER_DURATION (outbuf) =</span>
<span class="line-added">+             gst_util_uint64_scale (GST_SECOND, CUR_STREAM (stream)-&gt;fps_d,</span>
<span class="line-added">+             CUR_STREAM (stream)-&gt;fps_n);</span>
<span class="line-added">+         GST_BUFFER_OFFSET (outbuf) = -1;</span>
<span class="line-added">+         GST_BUFFER_OFFSET_END (outbuf) = -1;</span>
<span class="line-added">+ </span>
<span class="line-added">+         ret = gst_qtdemux_push_buffer (qtdemux, stream, outbuf);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (ret != GST_FLOW_OK &amp;&amp; ret != GST_FLOW_NOT_LINKED)</span>
<span class="line-added">+           break;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       gst_buffer_unmap (buf, &amp;map);</span>
<span class="line-added">+       gst_buffer_unref (buf);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       gst_buffer_unmap (buf, &amp;map);</span>
<span class="line-added">+       ret = gst_qtdemux_push_buffer (qtdemux, stream, buf);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     ret = gst_qtdemux_push_buffer (qtdemux, stream, buf);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return ret;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  /* Sets a buffer&#39;s attributes properly and pushes it downstream.
   * Also checks for additional actions and custom processing that may
   * need to be done first.
   */
  static GstFlowReturn
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5540,10 ***</span>
<span class="line-new-header">--- 6137,17 ---</span>
    GST_BUFFER_PTS (buf) = pts;
    GST_BUFFER_DURATION (buf) = duration;
    GST_BUFFER_OFFSET (buf) = -1;
    GST_BUFFER_OFFSET_END (buf) = -1;
  
<span class="line-added">+   if (!keyframe) {</span>
<span class="line-added">+     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);</span>
<span class="line-added">+     stream-&gt;on_keyframe = FALSE;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     stream-&gt;on_keyframe = TRUE;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    if (G_UNLIKELY (CUR_STREAM (stream)-&gt;rgb8_palette))
      gst_buffer_append_memory (buf,
          gst_memory_ref (CUR_STREAM (stream)-&gt;rgb8_palette));
  
    if (G_UNLIKELY (CUR_STREAM (stream)-&gt;padding)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5567,81 ***</span>
            GST_FORMAT_BYTES, byte_position, NULL);
      }
    }
  #endif
  
<span class="line-modified">!   if (stream-&gt;need_clip)</span>
<span class="line-removed">-     buf = gst_qtdemux_clip_buffer (qtdemux, stream, buf);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (G_UNLIKELY (buf == NULL))</span>
<span class="line-removed">-     goto exit;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (G_UNLIKELY (stream-&gt;discont)) {</span>
<span class="line-removed">-     GST_LOG_OBJECT (qtdemux, &quot;marking discont buffer&quot;);</span>
<span class="line-removed">-     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);</span>
<span class="line-removed">-     stream-&gt;discont = FALSE;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DISCONT);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (!keyframe) {</span>
<span class="line-removed">-     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);</span>
<span class="line-removed">-     stream-&gt;on_keyframe = FALSE;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     stream-&gt;on_keyframe = TRUE;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-   GST_LOG_OBJECT (qtdemux,</span>
<span class="line-removed">-       &quot;Pushing buffer with dts %&quot; GST_TIME_FORMAT &quot;, pts %&quot; GST_TIME_FORMAT</span>
<span class="line-removed">-       &quot;, duration %&quot; GST_TIME_FORMAT &quot; on pad %s&quot;, GST_TIME_ARGS (dts),</span>
<span class="line-removed">-       GST_TIME_ARGS (pts), GST_TIME_ARGS (duration),</span>
<span class="line-removed">-       GST_PAD_NAME (stream-&gt;pad));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (stream-&gt;protected &amp;&amp; stream-&gt;protection_scheme_type == FOURCC_cenc) {</span>
<span class="line-removed">-     GstStructure *crypto_info;</span>
<span class="line-removed">-     QtDemuxCencSampleSetInfo *info =</span>
<span class="line-removed">-         (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;</span>
<span class="line-removed">-     gint index;</span>
<span class="line-removed">-     GstEvent *event;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     while ((event = g_queue_pop_head (&amp;stream-&gt;protection_scheme_event_queue))) {</span>
<span class="line-removed">-       gst_pad_push_event (stream-&gt;pad, event);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (info-&gt;crypto_info == NULL) {</span>
<span class="line-removed">-       GST_DEBUG_OBJECT (qtdemux, &quot;cenc metadata hasn&#39;t been parsed yet&quot;);</span>
<span class="line-removed">-       gst_buffer_unref (buf);</span>
<span class="line-removed">-       goto exit;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* The end of the crypto_info array matches our n_samples position,</span>
<span class="line-removed">-      * so count backward from there */</span>
<span class="line-removed">-     index = stream-&gt;sample_index - stream-&gt;n_samples + info-&gt;crypto_info-&gt;len;</span>
<span class="line-removed">-     if (G_LIKELY (index &gt;= 0 &amp;&amp; index &lt; info-&gt;crypto_info-&gt;len)) {</span>
<span class="line-removed">-       /* steal structure from array */</span>
<span class="line-removed">-       crypto_info = g_ptr_array_index (info-&gt;crypto_info, index);</span>
<span class="line-removed">-       g_ptr_array_index (info-&gt;crypto_info, index) = NULL;</span>
<span class="line-removed">-       GST_LOG_OBJECT (qtdemux, &quot;attaching cenc metadata [%u/%u]&quot;, index,</span>
<span class="line-removed">-           info-&gt;crypto_info-&gt;len);</span>
<span class="line-removed">-       if (!crypto_info || !gst_buffer_add_protection_meta (buf, crypto_info))</span>
<span class="line-removed">-         GST_ERROR_OBJECT (qtdemux, &quot;failed to attach cenc metadata to buffer&quot;);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       GST_INFO_OBJECT (qtdemux, &quot;No crypto info with index %d and sample %d&quot;,</span>
<span class="line-removed">-           index, stream-&gt;sample_index);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (stream-&gt;alignment &gt; 1)</span>
<span class="line-removed">-     buf = gst_qtdemux_align_buffer (qtdemux, buf, stream-&gt;alignment);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   ret = gst_pad_push (stream-&gt;pad, buf);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (GST_CLOCK_TIME_IS_VALID (pts) &amp;&amp; GST_CLOCK_TIME_IS_VALID (duration)) {</span>
<span class="line-removed">-     /* mark position in stream, we&#39;ll need this to know when to send GAP event */</span>
<span class="line-removed">-     stream-&gt;segment.position = pts + duration;</span>
<span class="line-removed">-   }</span>
  
  exit:
    return ret;
  }
  
<span class="line-new-header">--- 6171,11 ---</span>
            GST_FORMAT_BYTES, byte_position, NULL);
      }
    }
  #endif
  
<span class="line-modified">!   ret = gst_qtdemux_split_and_push_buffer (qtdemux, stream, buf);</span>
  
  exit:
    return ret;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5672,24 ***</span>
  
  static gboolean
  gst_qtdemux_do_fragmented_seek (GstQTDemux * qtdemux)
  {
    const QtDemuxRandomAccessEntry *best_entry = NULL;
<span class="line-modified">!   guint i;</span>
  
    GST_OBJECT_LOCK (qtdemux);
  
<span class="line-modified">!   g_assert (qtdemux-&gt;n_streams &gt; 0);</span>
  
    /* first see if we can determine where to go to using mfra,
     * before we start clearing things */
<span class="line-modified">!   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
      const QtDemuxRandomAccessEntry *entry;
      QtDemuxStream *stream;
      gboolean is_audio_or_video;
  
<span class="line-modified">!     stream = qtdemux-&gt;streams[i];</span>
  
      if (stream-&gt;ra_entries == NULL)
        continue;
  
      if (stream-&gt;subtype == FOURCC_vide || stream-&gt;subtype == FOURCC_soun)
<span class="line-new-header">--- 6206,24 ---</span>
  
  static gboolean
  gst_qtdemux_do_fragmented_seek (GstQTDemux * qtdemux)
  {
    const QtDemuxRandomAccessEntry *best_entry = NULL;
<span class="line-modified">!   gint i;</span>
  
    GST_OBJECT_LOCK (qtdemux);
  
<span class="line-modified">!   g_assert (QTDEMUX_N_STREAMS (qtdemux) &gt; 0);</span>
  
    /* first see if we can determine where to go to using mfra,
     * before we start clearing things */
<span class="line-modified">!   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
      const QtDemuxRandomAccessEntry *entry;
      QtDemuxStream *stream;
      gboolean is_audio_or_video;
  
<span class="line-modified">!     stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
  
      if (stream-&gt;ra_entries == NULL)
        continue;
  
      if (stream-&gt;subtype == FOURCC_vide || stream-&gt;subtype == FOURCC_soun)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5719,14 ***</span>
      GST_OBJECT_UNLOCK (qtdemux);
      return FALSE;
    }
  
    /* ok, now we can prepare for processing as of located moof */
<span class="line-modified">!   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
      QtDemuxStream *stream;
  
<span class="line-modified">!     stream = qtdemux-&gt;streams[i];</span>
  
      g_free (stream-&gt;samples);
      stream-&gt;samples = NULL;
      stream-&gt;n_samples = 0;
      stream-&gt;stbl_index = -1;    /* no samples have yet been parsed */
<span class="line-new-header">--- 6253,14 ---</span>
      GST_OBJECT_UNLOCK (qtdemux);
      return FALSE;
    }
  
    /* ok, now we can prepare for processing as of located moof */
<span class="line-modified">!   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
      QtDemuxStream *stream;
  
<span class="line-modified">!     stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
  
      g_free (stream-&gt;samples);
      stream-&gt;samples = NULL;
      stream-&gt;n_samples = 0;
      stream-&gt;stbl_index = -1;    /* no samples have yet been parsed */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5745,11 ***</span>
      }
    }
  
    GST_INFO_OBJECT (qtdemux, &quot;seek to %&quot; GST_TIME_FORMAT &quot;, best fragment &quot;
        &quot;moof offset: %&quot; G_GUINT64_FORMAT &quot;, ts %&quot; GST_TIME_FORMAT,
<span class="line-modified">!       GST_TIME_ARGS (qtdemux-&gt;streams[0]-&gt;time_position),</span>
        best_entry-&gt;moof_offset, GST_TIME_ARGS (best_entry-&gt;ts));
  
    qtdemux-&gt;moof_offset = best_entry-&gt;moof_offset;
  
    qtdemux_add_fragmented_samples (qtdemux);
<span class="line-new-header">--- 6279,11 ---</span>
      }
    }
  
    GST_INFO_OBJECT (qtdemux, &quot;seek to %&quot; GST_TIME_FORMAT &quot;, best fragment &quot;
        &quot;moof offset: %&quot; G_GUINT64_FORMAT &quot;, ts %&quot; GST_TIME_FORMAT,
<span class="line-modified">!       GST_TIME_ARGS (QTDEMUX_NTH_STREAM (qtdemux, 0)-&gt;time_position),</span>
        best_entry-&gt;moof_offset, GST_TIME_ARGS (best_entry-&gt;ts));
  
    qtdemux-&gt;moof_offset = best_entry-&gt;moof_offset;
  
    qtdemux_add_fragmented_samples (qtdemux);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5761,25 ***</span>
  static GstFlowReturn
  gst_qtdemux_loop_state_movie (GstQTDemux * qtdemux)
  {
    GstFlowReturn ret = GST_FLOW_OK;
    GstBuffer *buf = NULL;
<span class="line-modified">!   QtDemuxStream *stream;</span>
    GstClockTime min_time;
    guint64 offset = 0;
    GstClockTime dts = GST_CLOCK_TIME_NONE;
    GstClockTime pts = GST_CLOCK_TIME_NONE;
    GstClockTime duration = 0;
    gboolean keyframe = FALSE;
    guint sample_size = 0;
    gboolean empty = 0;
    guint size;
<span class="line-removed">-   gint index;</span>
    gint i;
  
<span class="line-removed">-   gst_qtdemux_push_pending_newsegment (qtdemux);</span>
<span class="line-removed">- </span>
    if (qtdemux-&gt;fragmented_seek_pending) {
      GST_INFO_OBJECT (qtdemux, &quot;pending fragmented seek&quot;);
      if (gst_qtdemux_do_fragmented_seek (qtdemux)) {
        GST_INFO_OBJECT (qtdemux, &quot;fragmented seek done!&quot;);
        qtdemux-&gt;fragmented_seek_pending = FALSE;
<span class="line-new-header">--- 6295,22 ---</span>
  static GstFlowReturn
  gst_qtdemux_loop_state_movie (GstQTDemux * qtdemux)
  {
    GstFlowReturn ret = GST_FLOW_OK;
    GstBuffer *buf = NULL;
<span class="line-modified">!   QtDemuxStream *stream, *target_stream = NULL;</span>
    GstClockTime min_time;
    guint64 offset = 0;
    GstClockTime dts = GST_CLOCK_TIME_NONE;
    GstClockTime pts = GST_CLOCK_TIME_NONE;
    GstClockTime duration = 0;
    gboolean keyframe = FALSE;
    guint sample_size = 0;
    gboolean empty = 0;
    guint size;
    gint i;
  
    if (qtdemux-&gt;fragmented_seek_pending) {
      GST_INFO_OBJECT (qtdemux, &quot;pending fragmented seek&quot;);
      if (gst_qtdemux_do_fragmented_seek (qtdemux)) {
        GST_INFO_OBJECT (qtdemux, &quot;fragmented seek done!&quot;);
        qtdemux-&gt;fragmented_seek_pending = FALSE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5789,43 ***</span>
    }
  
    /* Figure out the next stream sample to output, min_time is expressed in
     * global time and runs over the edit list segments. */
    min_time = G_MAXUINT64;
<span class="line-modified">!   index = -1;</span>
<span class="line-removed">-   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
      GstClockTime position;
  
<span class="line-modified">!     stream = qtdemux-&gt;streams[i];</span>
      position = stream-&gt;time_position;
  
      /* position of -1 is EOS */
      if (position != GST_CLOCK_TIME_NONE &amp;&amp; position &lt; min_time) {
        min_time = position;
<span class="line-modified">!       index = i;</span>
      }
    }
    /* all are EOS */
<span class="line-modified">!   if (G_UNLIKELY (index == -1)) {</span>
      GST_DEBUG_OBJECT (qtdemux, &quot;all streams are EOS&quot;);
      goto eos;
    }
  
    /* check for segment end */
    if (G_UNLIKELY (qtdemux-&gt;segment.stop != -1
            &amp;&amp; ((qtdemux-&gt;segment.rate &gt;= 0 &amp;&amp; qtdemux-&gt;segment.stop &lt;= min_time)
                || (qtdemux-&gt;segment.rate &lt; 0
                    &amp;&amp; qtdemux-&gt;segment.start &gt; min_time))
<span class="line-modified">!           &amp;&amp; qtdemux-&gt;streams[index]-&gt;on_keyframe)) {</span>
      GST_DEBUG_OBJECT (qtdemux, &quot;we reached the end of our segment.&quot;);
<span class="line-modified">!     qtdemux-&gt;streams[index]-&gt;time_position = GST_CLOCK_TIME_NONE;</span>
      goto eos_stream;
    }
  
    /* gap events for subtitle streams */
<span class="line-modified">!   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
<span class="line-modified">!     stream = qtdemux-&gt;streams[i];</span>
      if (stream-&gt;pad &amp;&amp; (stream-&gt;subtype == FOURCC_subp
              || stream-&gt;subtype == FOURCC_text
              || stream-&gt;subtype == FOURCC_sbtl)) {
        /* send one second gap events until the stream catches up */
        /* gaps can only be sent after segment is activated (segment.stop is no longer -1) */
<span class="line-new-header">--- 6320,42 ---</span>
    }
  
    /* Figure out the next stream sample to output, min_time is expressed in
     * global time and runs over the edit list segments. */
    min_time = G_MAXUINT64;
<span class="line-modified">!   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
      GstClockTime position;
  
<span class="line-modified">!     stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
      position = stream-&gt;time_position;
  
      /* position of -1 is EOS */
      if (position != GST_CLOCK_TIME_NONE &amp;&amp; position &lt; min_time) {
        min_time = position;
<span class="line-modified">!       target_stream = stream;</span>
      }
    }
    /* all are EOS */
<span class="line-modified">!   if (G_UNLIKELY (target_stream == NULL)) {</span>
      GST_DEBUG_OBJECT (qtdemux, &quot;all streams are EOS&quot;);
      goto eos;
    }
  
    /* check for segment end */
    if (G_UNLIKELY (qtdemux-&gt;segment.stop != -1
            &amp;&amp; ((qtdemux-&gt;segment.rate &gt;= 0 &amp;&amp; qtdemux-&gt;segment.stop &lt;= min_time)
                || (qtdemux-&gt;segment.rate &lt; 0
                    &amp;&amp; qtdemux-&gt;segment.start &gt; min_time))
<span class="line-modified">!           &amp;&amp; target_stream-&gt;on_keyframe)) {</span>
      GST_DEBUG_OBJECT (qtdemux, &quot;we reached the end of our segment.&quot;);
<span class="line-modified">!     target_stream-&gt;time_position = GST_CLOCK_TIME_NONE;</span>
      goto eos_stream;
    }
  
    /* gap events for subtitle streams */
<span class="line-modified">!   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified">!     stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
      if (stream-&gt;pad &amp;&amp; (stream-&gt;subtype == FOURCC_subp
              || stream-&gt;subtype == FOURCC_text
              || stream-&gt;subtype == FOURCC_sbtl)) {
        /* send one second gap events until the stream catches up */
        /* gaps can only be sent after segment is activated (segment.stop is no longer -1) */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5838,42 ***</span>
          stream-&gt;segment.position += GST_SECOND;
        }
      }
    }
  
<span class="line-modified">!   stream = qtdemux-&gt;streams[index];</span>
    /* fetch info for the current sample of this stream */
    if (G_UNLIKELY (!gst_qtdemux_prepare_current_sample (qtdemux, stream, &amp;empty,
                &amp;offset, &amp;sample_size, &amp;dts, &amp;pts, &amp;duration, &amp;keyframe)))
      goto eos_stream;
  
    gst_qtdemux_stream_check_and_change_stsd_index (qtdemux, stream);
    if (stream-&gt;new_caps) {
      gst_qtdemux_configure_stream (qtdemux, stream);
<span class="line-modified">!     qtdemux_do_allocation (qtdemux, stream);</span>
    }
  
    /* If we&#39;re doing a keyframe-only trickmode, only push keyframes on video streams */
<span class="line-modified">!   if (G_UNLIKELY (qtdemux-&gt;</span>
<span class="line-modified">!           segment.flags &amp; GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS)) {</span>
      if (stream-&gt;subtype == FOURCC_vide &amp;&amp; !keyframe) {
<span class="line-modified">!       GST_LOG_OBJECT (qtdemux, &quot;Skipping non-keyframe on stream %d&quot;, index);</span>
        goto next;
      }
    }
  
    GST_DEBUG_OBJECT (qtdemux,
<span class="line-modified">!       &quot;pushing from stream %d, empty %d offset %&quot; G_GUINT64_FORMAT</span>
        &quot;, size %d, dts=%&quot; GST_TIME_FORMAT &quot;, pts=%&quot; GST_TIME_FORMAT
<span class="line-modified">!       &quot;, duration %&quot; GST_TIME_FORMAT, index, empty, offset, sample_size,</span>
<span class="line-modified">!       GST_TIME_ARGS (dts), GST_TIME_ARGS (pts), GST_TIME_ARGS (duration));</span>
  
    if (G_UNLIKELY (empty)) {
      /* empty segment, push a gap if there&#39;s a second or more
       * difference and move to the next one */
      if ((pts + duration - stream-&gt;segment.position) &gt;= GST_SECOND)
<span class="line-modified">!     gst_pad_push_event (stream-&gt;pad, gst_event_new_gap (pts, duration));</span>
      stream-&gt;segment.position = pts + duration;
      goto next;
    }
  
    /* hmm, empty sample, skip and move to next sample */
<span class="line-new-header">--- 6368,44 ---</span>
          stream-&gt;segment.position += GST_SECOND;
        }
      }
    }
  
<span class="line-modified">!   stream = target_stream;</span>
    /* fetch info for the current sample of this stream */
    if (G_UNLIKELY (!gst_qtdemux_prepare_current_sample (qtdemux, stream, &amp;empty,
                &amp;offset, &amp;sample_size, &amp;dts, &amp;pts, &amp;duration, &amp;keyframe)))
      goto eos_stream;
  
    gst_qtdemux_stream_check_and_change_stsd_index (qtdemux, stream);
    if (stream-&gt;new_caps) {
      gst_qtdemux_configure_stream (qtdemux, stream);
<span class="line-modified">!     qtdemux_do_allocation (stream, qtdemux);</span>
    }
  
    /* If we&#39;re doing a keyframe-only trickmode, only push keyframes on video streams */
<span class="line-modified">!   if (G_UNLIKELY (qtdemux-&gt;segment.</span>
<span class="line-modified">!           flags &amp; GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS)) {</span>
      if (stream-&gt;subtype == FOURCC_vide &amp;&amp; !keyframe) {
<span class="line-modified">!       GST_LOG_OBJECT (qtdemux, &quot;Skipping non-keyframe on track-id %u&quot;,</span>
<span class="line-added">+           stream-&gt;track_id);</span>
        goto next;
      }
    }
  
    GST_DEBUG_OBJECT (qtdemux,
<span class="line-modified">!       &quot;pushing from track-id %u, empty %d offset %&quot; G_GUINT64_FORMAT</span>
        &quot;, size %d, dts=%&quot; GST_TIME_FORMAT &quot;, pts=%&quot; GST_TIME_FORMAT
<span class="line-modified">!       &quot;, duration %&quot; GST_TIME_FORMAT, stream-&gt;track_id, empty, offset,</span>
<span class="line-modified">!       sample_size, GST_TIME_ARGS (dts), GST_TIME_ARGS (pts),</span>
<span class="line-added">+       GST_TIME_ARGS (duration));</span>
  
    if (G_UNLIKELY (empty)) {
      /* empty segment, push a gap if there&#39;s a second or more
       * difference and move to the next one */
      if ((pts + duration - stream-&gt;segment.position) &gt;= GST_SECOND)
<span class="line-modified">!       gst_pad_push_event (stream-&gt;pad, gst_event_new_gap (pts, duration));</span>
      stream-&gt;segment.position = pts + duration;
      goto next;
    }
  
    /* hmm, empty sample, skip and move to next sample */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6059,11 ***</span>
      gst_pad_pause_task (pad);
  
      /* fatal errors need special actions */
      /* check EOS */
      if (ret == GST_FLOW_EOS) {
<span class="line-modified">!       if (qtdemux-&gt;n_streams == 0) {</span>
          /* we have no streams, post an error */
          gst_qtdemux_post_no_playable_stream_error (qtdemux);
        }
        if (qtdemux-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
          gint64 stop;
<span class="line-new-header">--- 6591,11 ---</span>
      gst_pad_pause_task (pad);
  
      /* fatal errors need special actions */
      /* check EOS */
      if (ret == GST_FLOW_EOS) {
<span class="line-modified">!       if (QTDEMUX_N_STREAMS (qtdemux) == 0) {</span>
          /* we have no streams, post an error */
          gst_qtdemux_post_no_playable_stream_error (qtdemux);
        }
        if (qtdemux-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
          gint64 stop;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6096,11 ***</span>
            event = gst_event_new_segment_done (GST_FORMAT_TIME,
                qtdemux-&gt;segment.start);
            if (qtdemux-&gt;segment_seqnum != GST_SEQNUM_INVALID) {
              gst_message_set_seqnum (message, qtdemux-&gt;segment_seqnum);
              gst_event_set_seqnum (event, qtdemux-&gt;segment_seqnum);
<span class="line-modified">!         }</span>
            gst_element_post_message (GST_ELEMENT_CAST (qtdemux), message);
            gst_qtdemux_push_event (qtdemux, event);
          }
        } else {
          GstEvent *event;
<span class="line-new-header">--- 6628,11 ---</span>
            event = gst_event_new_segment_done (GST_FORMAT_TIME,
                qtdemux-&gt;segment.start);
            if (qtdemux-&gt;segment_seqnum != GST_SEQNUM_INVALID) {
              gst_message_set_seqnum (message, qtdemux-&gt;segment_seqnum);
              gst_event_set_seqnum (event, qtdemux-&gt;segment_seqnum);
<span class="line-modified">!           }</span>
            gst_element_post_message (GST_ELEMENT_CAST (qtdemux), message);
            gst_qtdemux_push_event (qtdemux, event);
          }
        } else {
          GstEvent *event;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6126,24 ***</span>
   */
  static gboolean
  has_next_entry (GstQTDemux * demux)
  {
    QtDemuxStream *stream;
<span class="line-modified">!   int i;</span>
  
    GST_DEBUG_OBJECT (demux, &quot;Checking if there are samples not played yet&quot;);
  
<span class="line-modified">!   for (i = 0; i &lt; demux-&gt;n_streams; i++) {</span>
<span class="line-modified">!     stream = demux-&gt;streams[i];</span>
  
      if (stream-&gt;sample_index == -1) {
        stream-&gt;sample_index = 0;
        stream-&gt;offset_in_sample = 0;
      }
  
      if (stream-&gt;sample_index &gt;= stream-&gt;n_samples) {
<span class="line-modified">!       GST_LOG_OBJECT (demux, &quot;stream %d samples exhausted&quot;, i);</span>
        continue;
      }
      GST_DEBUG_OBJECT (demux, &quot;Found a sample&quot;);
      return TRUE;
    }
<span class="line-new-header">--- 6658,24 ---</span>
   */
  static gboolean
  has_next_entry (GstQTDemux * demux)
  {
    QtDemuxStream *stream;
<span class="line-modified">!   gint i;</span>
  
    GST_DEBUG_OBJECT (demux, &quot;Checking if there are samples not played yet&quot;);
  
<span class="line-modified">!   for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified">!     stream = QTDEMUX_NTH_STREAM (demux, i);</span>
  
      if (stream-&gt;sample_index == -1) {
        stream-&gt;sample_index = 0;
        stream-&gt;offset_in_sample = 0;
      }
  
      if (stream-&gt;sample_index &gt;= stream-&gt;n_samples) {
<span class="line-modified">!       GST_LOG_OBJECT (demux, &quot;track-id %u samples exhausted&quot;, stream-&gt;track_id);</span>
        continue;
      }
      GST_DEBUG_OBJECT (demux, &quot;Found a sample&quot;);
      return TRUE;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6159,29 ***</span>
   * If -1, there are none (which means EOS or empty file).
   */
  static guint64
  next_entry_size (GstQTDemux * demux)
  {
<span class="line-modified">!   QtDemuxStream *stream;</span>
<span class="line-removed">-   int i;</span>
<span class="line-removed">-   int smallidx = -1;</span>
    guint64 smalloffs = (guint64) - 1;
    QtDemuxSample *sample;
  
    GST_LOG_OBJECT (demux, &quot;Finding entry at offset %&quot; G_GUINT64_FORMAT,
        demux-&gt;offset);
  
<span class="line-modified">!   for (i = 0; i &lt; demux-&gt;n_streams; i++) {</span>
<span class="line-modified">!     stream = demux-&gt;streams[i];</span>
  
      if (stream-&gt;sample_index == -1) {
        stream-&gt;sample_index = 0;
        stream-&gt;offset_in_sample = 0;
      }
  
      if (stream-&gt;sample_index &gt;= stream-&gt;n_samples) {
<span class="line-modified">!       GST_LOG_OBJECT (demux, &quot;stream %d samples exhausted&quot;, i);</span>
        continue;
      }
  
      if (!qtdemux_parse_samples (demux, stream, stream-&gt;sample_index)) {
        GST_LOG_OBJECT (demux, &quot;Parsing of index %u from stbl atom failed!&quot;,
<span class="line-new-header">--- 6691,28 ---</span>
   * If -1, there are none (which means EOS or empty file).
   */
  static guint64
  next_entry_size (GstQTDemux * demux)
  {
<span class="line-modified">!   QtDemuxStream *stream, *target_stream = NULL;</span>
    guint64 smalloffs = (guint64) - 1;
    QtDemuxSample *sample;
<span class="line-added">+   gint i;</span>
  
    GST_LOG_OBJECT (demux, &quot;Finding entry at offset %&quot; G_GUINT64_FORMAT,
        demux-&gt;offset);
  
<span class="line-modified">!   for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified">!     stream = QTDEMUX_NTH_STREAM (demux, i);</span>
  
      if (stream-&gt;sample_index == -1) {
        stream-&gt;sample_index = 0;
        stream-&gt;offset_in_sample = 0;
      }
  
      if (stream-&gt;sample_index &gt;= stream-&gt;n_samples) {
<span class="line-modified">!       GST_LOG_OBJECT (demux, &quot;track-id %u samples exhausted&quot;, stream-&gt;track_id);</span>
        continue;
      }
  
      if (!qtdemux_parse_samples (demux, stream, stream-&gt;sample_index)) {
        GST_LOG_OBJECT (demux, &quot;Parsing of index %u from stbl atom failed!&quot;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6190,29 ***</span>
      }
  
      sample = &amp;stream-&gt;samples[stream-&gt;sample_index];
  
      GST_LOG_OBJECT (demux,
<span class="line-modified">!         &quot;Checking Stream %d (sample_index:%d / offset:%&quot; G_GUINT64_FORMAT</span>
<span class="line-modified">!         &quot; / size:%&quot; G_GUINT32_FORMAT &quot;)&quot;, i, stream-&gt;sample_index,</span>
<span class="line-modified">!         sample-&gt;offset, sample-&gt;size);</span>
  
      if (((smalloffs == -1)
              || (sample-&gt;offset &lt; smalloffs)) &amp;&amp; (sample-&gt;size)) {
<span class="line-removed">-       smallidx = i;</span>
        smalloffs = sample-&gt;offset;
      }
    }
  
<span class="line-modified">!   GST_LOG_OBJECT (demux,</span>
<span class="line-removed">-       &quot;stream %d offset %&quot; G_GUINT64_FORMAT &quot; demux-&gt;offset :%&quot;</span>
<span class="line-removed">-       G_GUINT64_FORMAT, smallidx, smalloffs, demux-&gt;offset);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (smallidx == -1)</span>
      return -1;
  
<span class="line-modified">!   stream = demux-&gt;streams[smallidx];</span>
    sample = &amp;stream-&gt;samples[stream-&gt;sample_index];
  
    if (sample-&gt;offset &gt;= demux-&gt;offset) {
      demux-&gt;todrop = sample-&gt;offset - demux-&gt;offset;
      return sample-&gt;size + demux-&gt;todrop;
<span class="line-new-header">--- 6721,29 ---</span>
      }
  
      sample = &amp;stream-&gt;samples[stream-&gt;sample_index];
  
      GST_LOG_OBJECT (demux,
<span class="line-modified">!         &quot;Checking track-id %u (sample_index:%d / offset:%&quot; G_GUINT64_FORMAT</span>
<span class="line-modified">!         &quot; / size:%&quot; G_GUINT32_FORMAT &quot;)&quot;, stream-&gt;track_id,</span>
<span class="line-modified">!         stream-&gt;sample_index, sample-&gt;offset, sample-&gt;size);</span>
  
      if (((smalloffs == -1)
              || (sample-&gt;offset &lt; smalloffs)) &amp;&amp; (sample-&gt;size)) {
        smalloffs = sample-&gt;offset;
<span class="line-added">+       target_stream = stream;</span>
      }
    }
  
<span class="line-modified">!   if (!target_stream)</span>
      return -1;
  
<span class="line-modified">!   GST_LOG_OBJECT (demux,</span>
<span class="line-added">+       &quot;track-id %u offset %&quot; G_GUINT64_FORMAT &quot; demux-&gt;offset :%&quot;</span>
<span class="line-added">+       G_GUINT64_FORMAT, target_stream-&gt;track_id, smalloffs, demux-&gt;offset);</span>
<span class="line-added">+ </span>
<span class="line-added">+   stream = target_stream;</span>
    sample = &amp;stream-&gt;samples[stream-&gt;sample_index];
  
    if (sample-&gt;offset &gt;= demux-&gt;offset) {
      demux-&gt;todrop = sample-&gt;offset - demux-&gt;offset;
      return sample-&gt;size + demux-&gt;todrop;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6308,71 ***</span>
    demux-&gt;neededbytes -= bytes;
    demux-&gt;offset += bytes;
    demux-&gt;todrop -= bytes;
  }
  
  static void
  gst_qtdemux_check_send_pending_segment (GstQTDemux * demux)
  {
<span class="line-modified">!   if (G_UNLIKELY (demux-&gt;pending_newsegment)) {</span>
      gint i;
  
<span class="line-modified">!     gst_qtdemux_push_pending_newsegment (demux);</span>
      /* clear to send tags on all streams */
<span class="line-modified">!     for (i = 0; i &lt; demux-&gt;n_streams; i++) {</span>
<span class="line-modified">!       QtDemuxStream *stream;</span>
<span class="line-removed">-       stream = demux-&gt;streams[i];</span>
        gst_qtdemux_push_tags (demux, stream);
        if (CUR_STREAM (stream)-&gt;sparse) {
          GST_INFO_OBJECT (demux, &quot;Sending gap event on stream %d&quot;, i);
          gst_pad_push_event (stream-&gt;pad,
              gst_event_new_gap (stream-&gt;segment.position, GST_CLOCK_TIME_NONE));
        }
      }
    }
  }
  
  static void
  gst_qtdemux_send_gap_for_segment (GstQTDemux * demux,
      QtDemuxStream * stream, gint segment_index, GstClockTime pos)
  {
    GstClockTime ts, dur;
<span class="line-removed">-   GstEvent *gap;</span>
  
    ts = pos;
    dur =
        stream-&gt;segments[segment_index].duration - (pos -
        stream-&gt;segments[segment_index].time);
<span class="line-removed">-   gap = gst_event_new_gap (ts, dur);</span>
    stream-&gt;time_position += dur;
  
<span class="line-modified">!   GST_DEBUG_OBJECT (stream-&gt;pad, &quot;Pushing gap for empty &quot;</span>
<span class="line-modified">!       &quot;segment: %&quot; GST_PTR_FORMAT, gap);</span>
<span class="line-modified">!   gst_pad_push_event (stream-&gt;pad, gap);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! static void</span>
<span class="line-removed">- gst_qtdemux_stream_send_initial_gap_segments (GstQTDemux * demux,</span>
<span class="line-removed">-     QtDemuxStream * stream)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   gint i;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   /* Push any initial gap segments before proceeding to the</span>
<span class="line-removed">-    * &#39;real&#39; data */</span>
<span class="line-removed">-   for (i = 0; i &lt; stream-&gt;n_segments; i++) {</span>
<span class="line-removed">-     gst_qtdemux_activate_segment (demux, stream, i, stream-&gt;time_position);</span>
  
<span class="line-modified">!     if (QTSEGMENT_IS_EMPTY (&amp;stream-&gt;segments[i])) {</span>
<span class="line-modified">!       gst_qtdemux_send_gap_for_segment (demux, stream, i,</span>
<span class="line-modified">!           stream-&gt;time_position);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       /* Only support empty segment at the beginning followed by</span>
<span class="line-removed">-        * one non-empty segment, this was checked when parsing the</span>
<span class="line-removed">-        * edts atom, arriving here is unexpected */</span>
<span class="line-removed">-       g_assert (i + 1 == stream-&gt;n_segments);</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     }</span>
    }
  }
  
  static GstFlowReturn
  gst_qtdemux_chain (GstPad * sinkpad, GstObject * parent, GstBuffer * inbuf)
<span class="line-new-header">--- 6839,65 ---</span>
    demux-&gt;neededbytes -= bytes;
    demux-&gt;offset += bytes;
    demux-&gt;todrop -= bytes;
  }
  
<span class="line-added">+ /* PUSH-MODE only: Send a segment, if not done already. */</span>
  static void
  gst_qtdemux_check_send_pending_segment (GstQTDemux * demux)
  {
<span class="line-modified">!   if (G_UNLIKELY (demux-&gt;need_segment)) {</span>
      gint i;
  
<span class="line-modified">!     if (!demux-&gt;upstream_format_is_time) {</span>
<span class="line-added">+       gst_qtdemux_map_and_push_segments (demux, &amp;demux-&gt;segment);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       GstEvent *segment_event;</span>
<span class="line-added">+       segment_event = gst_event_new_segment (&amp;demux-&gt;segment);</span>
<span class="line-added">+       if (demux-&gt;segment_seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added">+         gst_event_set_seqnum (segment_event, demux-&gt;segment_seqnum);</span>
<span class="line-added">+       gst_qtdemux_push_event (demux, segment_event);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     demux-&gt;need_segment = FALSE;</span>
<span class="line-added">+ </span>
      /* clear to send tags on all streams */
<span class="line-modified">!     for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified">!       QtDemuxStream *stream = QTDEMUX_NTH_STREAM (demux, i);</span>
        gst_qtdemux_push_tags (demux, stream);
        if (CUR_STREAM (stream)-&gt;sparse) {
          GST_INFO_OBJECT (demux, &quot;Sending gap event on stream %d&quot;, i);
          gst_pad_push_event (stream-&gt;pad,
              gst_event_new_gap (stream-&gt;segment.position, GST_CLOCK_TIME_NONE));
        }
      }
    }
  }
  
<span class="line-added">+ /* Used for push mode only. */</span>
  static void
  gst_qtdemux_send_gap_for_segment (GstQTDemux * demux,
      QtDemuxStream * stream, gint segment_index, GstClockTime pos)
  {
    GstClockTime ts, dur;
  
    ts = pos;
    dur =
        stream-&gt;segments[segment_index].duration - (pos -
        stream-&gt;segments[segment_index].time);
    stream-&gt;time_position += dur;
  
<span class="line-modified">!   /* Only gaps with a duration of at least one second are propagated.</span>
<span class="line-modified">!    * Same workaround as in pull mode.</span>
<span class="line-modified">!    * (See 2e45926a96ec5298c6ef29bf912e5e6a06dc3e0e) */</span>
<span class="line-modified">!   if (dur &gt;= GST_SECOND) {</span>
<span class="line-modified">!     GstEvent *gap;</span>
<span class="line-modified">!     gap = gst_event_new_gap (ts, dur);</span>
  
<span class="line-modified">!     GST_DEBUG_OBJECT (stream-&gt;pad, &quot;Pushing gap for empty &quot;</span>
<span class="line-modified">!         &quot;segment: %&quot; GST_PTR_FORMAT, gap);</span>
<span class="line-modified">!     gst_pad_push_event (stream-&gt;pad, gap);</span>
    }
  }
  
  static GstFlowReturn
  gst_qtdemux_chain (GstPad * sinkpad, GstObject * parent, GstBuffer * inbuf)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6392,45 ***</span>
      gboolean is_gap_input = FALSE;
      gint i;
  
      GST_DEBUG_OBJECT (demux, &quot;Got DISCONT, marking all streams as DISCONT&quot;);
  
<span class="line-modified">!     for (i = 0; i &lt; demux-&gt;n_streams; i++) {</span>
<span class="line-modified">!       demux-&gt;streams[i]-&gt;discont = TRUE;</span>
      }
  
      /* Check if we can land back on our feet in the case where upstream is
       * handling the seeking/pushing of samples with gaps in between (like
       * in the case of trick-mode DASH for example) */
      if (demux-&gt;upstream_format_is_time
          &amp;&amp; GST_BUFFER_OFFSET (inbuf) != GST_BUFFER_OFFSET_NONE) {
<span class="line-modified">!       gint i;</span>
<span class="line-removed">-       for (i = 0; i &lt; demux-&gt;n_streams; i++) {</span>
          guint32 res;
          GST_LOG_OBJECT (demux,
<span class="line-modified">!             &quot;Stream #%d , checking if offset %&quot; G_GUINT64_FORMAT</span>
<span class="line-modified">!             &quot; is a sample start&quot;, i, GST_BUFFER_OFFSET (inbuf));</span>
          res =
              gst_qtdemux_find_index_for_given_media_offset_linear (demux,
<span class="line-modified">!             demux-&gt;streams[i], GST_BUFFER_OFFSET (inbuf));</span>
          if (res != -1) {
<span class="line-modified">!           QtDemuxSample *sample = &amp;demux-&gt;streams[i]-&gt;samples[res];</span>
            GST_LOG_OBJECT (demux,
<span class="line-modified">!               &quot;Checking if sample %d from stream %d is valid (offset:%&quot;</span>
<span class="line-modified">!               G_GUINT64_FORMAT &quot; size:%&quot; G_GUINT32_FORMAT &quot;)&quot;, res, i,</span>
<span class="line-modified">!               sample-&gt;offset, sample-&gt;size);</span>
            if (sample-&gt;offset == GST_BUFFER_OFFSET (inbuf)) {
              GST_LOG_OBJECT (demux,
                  &quot;new buffer corresponds to a valid sample : %&quot; G_GUINT32_FORMAT,
                  res);
              is_gap_input = TRUE;
              /* We can go back to standard playback mode */
              demux-&gt;state = QTDEMUX_STATE_MOVIE;
              /* Remember which sample this stream is at */
<span class="line-modified">!             demux-&gt;streams[i]-&gt;sample_index = res;</span>
              /* Finally update all push-based values to the expected values */
<span class="line-modified">!             demux-&gt;neededbytes = demux-&gt;streams[i]-&gt;samples[res].size;</span>
              demux-&gt;offset = GST_BUFFER_OFFSET (inbuf);
              demux-&gt;mdatleft =
                  demux-&gt;mdatsize - demux-&gt;offset + demux-&gt;mdatoffset;
              demux-&gt;todrop = 0;
            }
<span class="line-new-header">--- 6917,45 ---</span>
      gboolean is_gap_input = FALSE;
      gint i;
  
      GST_DEBUG_OBJECT (demux, &quot;Got DISCONT, marking all streams as DISCONT&quot;);
  
<span class="line-modified">!     for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified">!       QTDEMUX_NTH_STREAM (demux, i)-&gt;discont = TRUE;</span>
      }
  
      /* Check if we can land back on our feet in the case where upstream is
       * handling the seeking/pushing of samples with gaps in between (like
       * in the case of trick-mode DASH for example) */
      if (demux-&gt;upstream_format_is_time
          &amp;&amp; GST_BUFFER_OFFSET (inbuf) != GST_BUFFER_OFFSET_NONE) {
<span class="line-modified">!       for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
          guint32 res;
<span class="line-added">+         QtDemuxStream *stream = QTDEMUX_NTH_STREAM (demux, i);</span>
          GST_LOG_OBJECT (demux,
<span class="line-modified">!             &quot;track-id #%u , checking if offset %&quot; G_GUINT64_FORMAT</span>
<span class="line-modified">!             &quot; is a sample start&quot;, stream-&gt;track_id, GST_BUFFER_OFFSET (inbuf));</span>
          res =
              gst_qtdemux_find_index_for_given_media_offset_linear (demux,
<span class="line-modified">!             stream, GST_BUFFER_OFFSET (inbuf));</span>
          if (res != -1) {
<span class="line-modified">!           QtDemuxSample *sample = &amp;stream-&gt;samples[res];</span>
            GST_LOG_OBJECT (demux,
<span class="line-modified">!               &quot;Checking if sample %d from track-id %u is valid (offset:%&quot;</span>
<span class="line-modified">!               G_GUINT64_FORMAT &quot; size:%&quot; G_GUINT32_FORMAT &quot;)&quot;, res,</span>
<span class="line-modified">!               stream-&gt;track_id, sample-&gt;offset, sample-&gt;size);</span>
            if (sample-&gt;offset == GST_BUFFER_OFFSET (inbuf)) {
              GST_LOG_OBJECT (demux,
                  &quot;new buffer corresponds to a valid sample : %&quot; G_GUINT32_FORMAT,
                  res);
              is_gap_input = TRUE;
              /* We can go back to standard playback mode */
              demux-&gt;state = QTDEMUX_STATE_MOVIE;
              /* Remember which sample this stream is at */
<span class="line-modified">!             stream-&gt;sample_index = res;</span>
              /* Finally update all push-based values to the expected values */
<span class="line-modified">!             demux-&gt;neededbytes = stream-&gt;samples[res].size;</span>
              demux-&gt;offset = GST_BUFFER_OFFSET (inbuf);
              demux-&gt;mdatleft =
                  demux-&gt;mdatsize - demux-&gt;offset + demux-&gt;mdatoffset;
              demux-&gt;todrop = 0;
            }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6451,12 ***</span>
       * durations but this won&#39;t work for reverse playback of fragments as
       * the timestamps of a subsequent fragment should be smaller than the
       * previously received one. */
      if (!is_gap_input &amp;&amp; demux-&gt;fragmented &amp;&amp; demux-&gt;segment.rate &lt; 0) {
        gst_qtdemux_process_adapter (demux, TRUE);
<span class="line-modified">!       for (i = 0; i &lt; demux-&gt;n_streams; i++)</span>
<span class="line-modified">!         gst_qtdemux_stream_flush_samples_data (demux, demux-&gt;streams[i]);</span>
      }
    }
  
    gst_adapter_push (demux-&gt;adapter, inbuf);
  
<span class="line-new-header">--- 6976,12 ---</span>
       * durations but this won&#39;t work for reverse playback of fragments as
       * the timestamps of a subsequent fragment should be smaller than the
       * previously received one. */
      if (!is_gap_input &amp;&amp; demux-&gt;fragmented &amp;&amp; demux-&gt;segment.rate &lt; 0) {
        gst_qtdemux_process_adapter (demux, TRUE);
<span class="line-modified">!       g_ptr_array_foreach (demux-&gt;active_streams,</span>
<span class="line-modified">!           (GFunc) gst_qtdemux_stream_flush_samples_data, NULL);</span>
      }
    }
  
    gst_adapter_push (demux-&gt;adapter, inbuf);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6486,11 ***</span>
  
        discont_offset = gst_adapter_offset_at_discont (demux-&gt;adapter);
        distance_from_discont =
            gst_adapter_distance_from_discont (demux-&gt;adapter);
  
<span class="line-modified">!     GST_DEBUG_OBJECT (demux,</span>
            &quot;state:%s , demux-&gt;neededbytes:%d, demux-&gt;offset:%&quot; G_GUINT64_FORMAT
            &quot; adapter offset :%&quot; G_GUINT64_FORMAT &quot; (+ %&quot; G_GUINT64_FORMAT
            &quot; bytes)&quot;, qt_demux_state_string (demux-&gt;state), demux-&gt;neededbytes,
            demux-&gt;offset, discont_offset, distance_from_discont);
      }
<span class="line-new-header">--- 7011,11 ---</span>
  
        discont_offset = gst_adapter_offset_at_discont (demux-&gt;adapter);
        distance_from_discont =
            gst_adapter_distance_from_discont (demux-&gt;adapter);
  
<span class="line-modified">!       GST_DEBUG_OBJECT (demux,</span>
            &quot;state:%s , demux-&gt;neededbytes:%d, demux-&gt;offset:%&quot; G_GUINT64_FORMAT
            &quot; adapter offset :%&quot; G_GUINT64_FORMAT &quot; (+ %&quot; G_GUINT64_FORMAT
            &quot; bytes)&quot;, qt_demux_state_string (demux-&gt;state), demux-&gt;neededbytes,
            demux-&gt;offset, discont_offset, distance_from_discont);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6521,11 ***</span>
            ret = GST_FLOW_ERROR;
            break;
          }
          if (fourcc == FOURCC_mdat) {
            gint next_entry = next_entry_size (demux);
<span class="line-modified">!           if (demux-&gt;n_streams &gt; 0 &amp;&amp; (next_entry != -1 || !demux-&gt;fragmented)) {</span>
              /* we have the headers, start playback */
              demux-&gt;state = QTDEMUX_STATE_MOVIE;
              demux-&gt;neededbytes = next_entry;
              demux-&gt;mdatleft = size;
              demux-&gt;mdatsize = demux-&gt;mdatleft;
<span class="line-new-header">--- 7046,12 ---</span>
            ret = GST_FLOW_ERROR;
            break;
          }
          if (fourcc == FOURCC_mdat) {
            gint next_entry = next_entry_size (demux);
<span class="line-modified">!           if (QTDEMUX_N_STREAMS (demux) &gt; 0 &amp;&amp; (next_entry != -1</span>
<span class="line-added">+                   || !demux-&gt;fragmented)) {</span>
              /* we have the headers, start playback */
              demux-&gt;state = QTDEMUX_STATE_MOVIE;
              demux-&gt;neededbytes = next_entry;
              demux-&gt;mdatleft = size;
              demux-&gt;mdatsize = demux-&gt;mdatleft;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6542,11 ***</span>
              /* try to jump over the atom with a seek */
              /* only bother if it seems worth doing so,
               * and avoids possible upstream/server problems */
              if (demux-&gt;upstream_seekable &amp;&amp;
                  demux-&gt;upstream_size &gt; 4 * (1 &lt;&lt; 20)) {
<span class="line-modified">!             res = qtdemux_seek_offset (demux, target);</span>
              } else {
                GST_DEBUG_OBJECT (demux, &quot;skipping seek&quot;);
                res = FALSE;
              }
  
<span class="line-new-header">--- 7068,11 ---</span>
              /* try to jump over the atom with a seek */
              /* only bother if it seems worth doing so,
               * and avoids possible upstream/server problems */
              if (demux-&gt;upstream_seekable &amp;&amp;
                  demux-&gt;upstream_size &gt; 4 * (1 &lt;&lt; 20)) {
<span class="line-modified">!               res = qtdemux_seek_offset (demux, target);</span>
              } else {
                GST_DEBUG_OBJECT (demux, &quot;skipping seek&quot;);
                res = FALSE;
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6609,91 ***</span>
  
          /* parse the header */
          extract_initial_length_and_fourcc (data, demux-&gt;neededbytes, NULL,
              &amp;fourcc);
          if (fourcc == FOURCC_moov) {
<span class="line-removed">-           gint n;</span>
<span class="line-removed">- </span>
            /* in usual fragmented setup we could try to scan for more
             * and end up at the the moov (after mdat) again */
<span class="line-modified">!           if (demux-&gt;got_moov &amp;&amp; demux-&gt;n_streams &gt; 0 &amp;&amp;</span>
                (!demux-&gt;fragmented
                    || demux-&gt;last_moov_offset == demux-&gt;offset)) {
              GST_DEBUG_OBJECT (demux,
                  &quot;Skipping moov atom as we have (this) one already&quot;);
            } else {
<span class="line-modified">!           GST_DEBUG_OBJECT (demux, &quot;Parsing [moov]&quot;);</span>
  
              if (demux-&gt;got_moov &amp;&amp; demux-&gt;fragmented) {
                GST_DEBUG_OBJECT (demux,
                    &quot;Got a second moov, clean up data from old one&quot;);
                if (demux-&gt;moov_node_compressed) {
                  g_node_destroy (demux-&gt;moov_node_compressed);
<span class="line-modified">!               if (demux-&gt;moov_node)</span>
                    g_free (demux-&gt;moov_node-&gt;data);
                }
                demux-&gt;moov_node_compressed = NULL;
                if (demux-&gt;moov_node)
                  g_node_destroy (demux-&gt;moov_node);
                demux-&gt;moov_node = NULL;
<span class="line-removed">-             } else {</span>
<span class="line-removed">-           /* prepare newsegment to send when streaming actually starts */</span>
<span class="line-removed">-               if (!demux-&gt;pending_newsegment) {</span>
<span class="line-removed">-             demux-&gt;pending_newsegment =</span>
<span class="line-removed">-                     gst_event_new_segment (&amp;demux-&gt;segment);</span>
<span class="line-removed">-                 if (demux-&gt;segment_seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-removed">-                   gst_event_set_seqnum (demux-&gt;pending_newsegment,</span>
<span class="line-removed">-                       demux-&gt;segment_seqnum);</span>
<span class="line-removed">-           }</span>
              }
  
              demux-&gt;last_moov_offset = demux-&gt;offset;
  
<span class="line-modified">!           qtdemux_parse_moov (demux, data, demux-&gt;neededbytes);</span>
<span class="line-modified">!           qtdemux_node_dump (demux, demux-&gt;moov_node);</span>
  #ifdef GSTREAMER_LITE
            if (!qtdemux_parse_tree (demux))
            {
                g_node_destroy (demux-&gt;moov_node);
                demux-&gt;moov_node = NULL;
                ret = GST_FLOW_ERROR;
                goto done;
            }
  #else
<span class="line-modified">!           qtdemux_parse_tree (demux);</span>
  #endif //GSTREAMER_LITE
<span class="line-modified">!           qtdemux_prepare_streams (demux);</span>
<span class="line-modified">!           if (!demux-&gt;got_moov)</span>
              qtdemux_expose_streams (demux);
<span class="line-modified">!             else {</span>
<span class="line-removed">- </span>
<span class="line-removed">-               for (n = 0; n &lt; demux-&gt;n_streams; n++) {</span>
<span class="line-removed">-                 QtDemuxStream *stream = demux-&gt;streams[n];</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 gst_qtdemux_configure_stream (demux, stream);</span>
<span class="line-removed">-               }</span>
<span class="line-removed">-             }</span>
  
              demux-&gt;got_moov = TRUE;
<span class="line-removed">-             gst_qtdemux_check_send_pending_segment (demux);</span>
  
<span class="line-modified">!             /* fragmented streams headers shouldn&#39;t contain edts atoms */</span>
<span class="line-removed">-             if (!demux-&gt;fragmented) {</span>
<span class="line-removed">-               for (n = 0; n &lt; demux-&gt;n_streams; n++) {</span>
<span class="line-removed">-                 gst_qtdemux_stream_send_initial_gap_segments (demux,</span>
<span class="line-removed">-                     demux-&gt;streams[n]);</span>
<span class="line-removed">-               }</span>
<span class="line-removed">-             }</span>
  
              if (demux-&gt;moov_node_compressed) {
                g_node_destroy (demux-&gt;moov_node_compressed);
                g_free (demux-&gt;moov_node-&gt;data);
              }
              demux-&gt;moov_node_compressed = NULL;
<span class="line-modified">!           g_node_destroy (demux-&gt;moov_node);</span>
<span class="line-modified">!           demux-&gt;moov_node = NULL;</span>
<span class="line-modified">!           GST_DEBUG_OBJECT (demux, &quot;Finished parsing the header&quot;);</span>
            }
          } else if (fourcc == FOURCC_moof) {
            if ((demux-&gt;got_moov || demux-&gt;media_caps) &amp;&amp; demux-&gt;fragmented) {
              guint64 dist = 0;
              GstClockTime prev_pts;
<span class="line-new-header">--- 7135,70 ---</span>
  
          /* parse the header */
          extract_initial_length_and_fourcc (data, demux-&gt;neededbytes, NULL,
              &amp;fourcc);
          if (fourcc == FOURCC_moov) {
            /* in usual fragmented setup we could try to scan for more
             * and end up at the the moov (after mdat) again */
<span class="line-modified">!           if (demux-&gt;got_moov &amp;&amp; QTDEMUX_N_STREAMS (demux) &gt; 0 &amp;&amp;</span>
                (!demux-&gt;fragmented
                    || demux-&gt;last_moov_offset == demux-&gt;offset)) {
              GST_DEBUG_OBJECT (demux,
                  &quot;Skipping moov atom as we have (this) one already&quot;);
            } else {
<span class="line-modified">!             GST_DEBUG_OBJECT (demux, &quot;Parsing [moov]&quot;);</span>
  
              if (demux-&gt;got_moov &amp;&amp; demux-&gt;fragmented) {
                GST_DEBUG_OBJECT (demux,
                    &quot;Got a second moov, clean up data from old one&quot;);
                if (demux-&gt;moov_node_compressed) {
                  g_node_destroy (demux-&gt;moov_node_compressed);
<span class="line-modified">!                 if (demux-&gt;moov_node)</span>
                    g_free (demux-&gt;moov_node-&gt;data);
                }
                demux-&gt;moov_node_compressed = NULL;
                if (demux-&gt;moov_node)
                  g_node_destroy (demux-&gt;moov_node);
                demux-&gt;moov_node = NULL;
              }
  
              demux-&gt;last_moov_offset = demux-&gt;offset;
  
<span class="line-modified">!             /* Update streams with new moov */</span>
<span class="line-modified">!             gst_qtdemux_stream_concat (demux,</span>
<span class="line-added">+                 demux-&gt;old_streams, demux-&gt;active_streams);</span>
<span class="line-added">+ </span>
<span class="line-added">+             qtdemux_parse_moov (demux, data, demux-&gt;neededbytes);</span>
<span class="line-added">+             qtdemux_node_dump (demux, demux-&gt;moov_node);</span>
  #ifdef GSTREAMER_LITE
            if (!qtdemux_parse_tree (demux))
            {
                g_node_destroy (demux-&gt;moov_node);
                demux-&gt;moov_node = NULL;
                ret = GST_FLOW_ERROR;
                goto done;
            }
  #else
<span class="line-modified">!             qtdemux_parse_tree (demux);</span>
  #endif //GSTREAMER_LITE
<span class="line-modified">!             qtdemux_prepare_streams (demux);</span>
<span class="line-modified">!             QTDEMUX_EXPOSE_LOCK (demux);</span>
              qtdemux_expose_streams (demux);
<span class="line-modified">!             QTDEMUX_EXPOSE_UNLOCK (demux);</span>
  
              demux-&gt;got_moov = TRUE;
  
<span class="line-modified">!             gst_qtdemux_check_send_pending_segment (demux);</span>
  
              if (demux-&gt;moov_node_compressed) {
                g_node_destroy (demux-&gt;moov_node_compressed);
                g_free (demux-&gt;moov_node-&gt;data);
              }
              demux-&gt;moov_node_compressed = NULL;
<span class="line-modified">!             g_node_destroy (demux-&gt;moov_node);</span>
<span class="line-modified">!             demux-&gt;moov_node = NULL;</span>
<span class="line-modified">!             GST_DEBUG_OBJECT (demux, &quot;Finished parsing the header&quot;);</span>
            }
          } else if (fourcc == FOURCC_moof) {
            if ((demux-&gt;got_moov || demux-&gt;media_caps) &amp;&amp; demux-&gt;fragmented) {
              guint64 dist = 0;
              GstClockTime prev_pts;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6763,22 ***</span>
                      demux-&gt;moof_offset, NULL)) {
                gst_adapter_unmap (demux-&gt;adapter);
                ret = GST_FLOW_ERROR;
                goto done;
              }
              /* in MSS we need to expose the pads after the first moof as we won&#39;t get a moov */
              if (demux-&gt;mss_mode &amp;&amp; !demux-&gt;exposed) {
<span class="line-modified">!               if (!demux-&gt;pending_newsegment) {</span>
<span class="line-removed">-                 GST_DEBUG_OBJECT (demux, &quot;new pending_newsegment&quot;);</span>
<span class="line-removed">-                 demux-&gt;pending_newsegment =</span>
<span class="line-removed">-                     gst_event_new_segment (&amp;demux-&gt;segment);</span>
<span class="line-removed">-                 if (demux-&gt;segment_seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-removed">-                   gst_event_set_seqnum (demux-&gt;pending_newsegment,</span>
<span class="line-removed">-                       demux-&gt;segment_seqnum);</span>
<span class="line-removed">-               }</span>
                qtdemux_expose_streams (demux);
              }
            } else {
              GST_DEBUG_OBJECT (demux, &quot;Discarding [moof]&quot;);
            }
          } else if (fourcc == FOURCC_ftyp) {
            GST_DEBUG_OBJECT (demux, &quot;Parsing [ftyp]&quot;);
<span class="line-new-header">--- 7268,19 ---</span>
                      demux-&gt;moof_offset, NULL)) {
                gst_adapter_unmap (demux-&gt;adapter);
                ret = GST_FLOW_ERROR;
                goto done;
              }
<span class="line-added">+ </span>
              /* in MSS we need to expose the pads after the first moof as we won&#39;t get a moov */
              if (demux-&gt;mss_mode &amp;&amp; !demux-&gt;exposed) {
<span class="line-modified">!               QTDEMUX_EXPOSE_LOCK (demux);</span>
                qtdemux_expose_streams (demux);
<span class="line-added">+               QTDEMUX_EXPOSE_UNLOCK (demux);</span>
              }
<span class="line-added">+ </span>
<span class="line-added">+             gst_qtdemux_check_send_pending_segment (demux);</span>
            } else {
              GST_DEBUG_OBJECT (demux, &quot;Discarding [moof]&quot;);
            }
          } else if (fourcc == FOURCC_ftyp) {
            GST_DEBUG_OBJECT (demux, &quot;Parsing [ftyp]&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6800,26 ***</span>
                GST_DEBUG_OBJECT (demux,
                    &quot;Skipping fourcc while parsing header : %&quot; GST_FOURCC_FORMAT,
                    GST_FOURCC_ARGS (fourcc));
                break;
              default:
<span class="line-modified">!           GST_WARNING_OBJECT (demux,</span>
<span class="line-modified">!               &quot;Unknown fourcc while parsing header : %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">!               GST_FOURCC_ARGS (fourcc));</span>
<span class="line-modified">!           /* Let&#39;s jump that one and go back to initial state */</span>
                break;
<span class="line-modified">!         }</span>
          }
          gst_adapter_unmap (demux-&gt;adapter);
          data = NULL;
  
<span class="line-modified">!         if (demux-&gt;mdatbuffer &amp;&amp; demux-&gt;n_streams) {</span>
            gsize remaining_data_size = 0;
  
            /* the mdat was before the header */
            GST_DEBUG_OBJECT (demux, &quot;We have n_streams:%d and mdatbuffer:%p&quot;,
<span class="line-modified">!               demux-&gt;n_streams, demux-&gt;mdatbuffer);</span>
            /* restore our adapter/offset view of things with upstream;
             * put preceding buffered data ahead of current moov data.
             * This should also handle evil mdat, moov, mdat cases and alike */
            gst_adapter_flush (demux-&gt;adapter, demux-&gt;neededbytes);
  
<span class="line-new-header">--- 7302,26 ---</span>
                GST_DEBUG_OBJECT (demux,
                    &quot;Skipping fourcc while parsing header : %&quot; GST_FOURCC_FORMAT,
                    GST_FOURCC_ARGS (fourcc));
                break;
              default:
<span class="line-modified">!               GST_WARNING_OBJECT (demux,</span>
<span class="line-modified">!                   &quot;Unknown fourcc while parsing header : %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">!                   GST_FOURCC_ARGS (fourcc));</span>
<span class="line-modified">!               /* Let&#39;s jump that one and go back to initial state */</span>
                break;
<span class="line-modified">!           }</span>
          }
          gst_adapter_unmap (demux-&gt;adapter);
          data = NULL;
  
<span class="line-modified">!         if (demux-&gt;mdatbuffer &amp;&amp; QTDEMUX_N_STREAMS (demux)) {</span>
            gsize remaining_data_size = 0;
  
            /* the mdat was before the header */
            GST_DEBUG_OBJECT (demux, &quot;We have n_streams:%d and mdatbuffer:%p&quot;,
<span class="line-modified">!               QTDEMUX_N_STREAMS (demux), demux-&gt;mdatbuffer);</span>
            /* restore our adapter/offset view of things with upstream;
             * put preceding buffered data ahead of current moov data.
             * This should also handle evil mdat, moov, mdat cases and alike */
            gst_adapter_flush (demux-&gt;adapter, demux-&gt;neededbytes);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6890,13 ***</span>
          break;
        }
        case QTDEMUX_STATE_MOVIE:{
          QtDemuxStream *stream = NULL;
          QtDemuxSample *sample;
<span class="line-removed">-         int i = -1;</span>
          GstClockTime dts, pts, duration;
          gboolean keyframe;
  
          GST_DEBUG_OBJECT (demux,
              &quot;BEGIN // in MOVIE for offset %&quot; G_GUINT64_FORMAT, demux-&gt;offset);
  
          if (demux-&gt;fragmented) {
<span class="line-new-header">--- 7392,13 ---</span>
          break;
        }
        case QTDEMUX_STATE_MOVIE:{
          QtDemuxStream *stream = NULL;
          QtDemuxSample *sample;
          GstClockTime dts, pts, duration;
          gboolean keyframe;
<span class="line-added">+         gint i;</span>
  
          GST_DEBUG_OBJECT (demux,
              &quot;BEGIN // in MOVIE for offset %&quot; G_GUINT64_FORMAT, demux-&gt;offset);
  
          if (demux-&gt;fragmented) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6942,19 ***</span>
              const guint8 *data;
  
              GST_DEBUG_OBJECT (demux, &quot;parsing cenc auxiliary info&quot;);
              data = gst_adapter_map (demux-&gt;adapter, demux-&gt;todrop);
              gst_byte_reader_init (&amp;br, data + 8, demux-&gt;todrop);
<span class="line-modified">!             if (!qtdemux_parse_cenc_aux_info (demux, demux-&gt;streams[0], &amp;br,</span>
                      demux-&gt;cenc_aux_info_sizes, demux-&gt;cenc_aux_sample_count)) {
                GST_ERROR_OBJECT (demux, &quot;failed to parse cenc auxiliary info&quot;);
                ret = GST_FLOW_ERROR;
                gst_adapter_unmap (demux-&gt;adapter);
                g_free (demux-&gt;cenc_aux_info_sizes);
                demux-&gt;cenc_aux_info_sizes = NULL;
                goto done;
<span class="line-modified">!         }</span>
              demux-&gt;cenc_aux_info_offset = 0;
              g_free (demux-&gt;cenc_aux_info_sizes);
              demux-&gt;cenc_aux_info_sizes = NULL;
              gst_adapter_unmap (demux-&gt;adapter);
            }
<span class="line-new-header">--- 7444,20 ---</span>
              const guint8 *data;
  
              GST_DEBUG_OBJECT (demux, &quot;parsing cenc auxiliary info&quot;);
              data = gst_adapter_map (demux-&gt;adapter, demux-&gt;todrop);
              gst_byte_reader_init (&amp;br, data + 8, demux-&gt;todrop);
<span class="line-modified">!             if (!qtdemux_parse_cenc_aux_info (demux,</span>
<span class="line-added">+                     QTDEMUX_NTH_STREAM (demux, 0), &amp;br,</span>
                      demux-&gt;cenc_aux_info_sizes, demux-&gt;cenc_aux_sample_count)) {
                GST_ERROR_OBJECT (demux, &quot;failed to parse cenc auxiliary info&quot;);
                ret = GST_FLOW_ERROR;
                gst_adapter_unmap (demux-&gt;adapter);
                g_free (demux-&gt;cenc_aux_info_sizes);
                demux-&gt;cenc_aux_info_sizes = NULL;
                goto done;
<span class="line-modified">!             }</span>
              demux-&gt;cenc_aux_info_offset = 0;
              g_free (demux-&gt;cenc_aux_info_sizes);
              demux-&gt;cenc_aux_info_sizes = NULL;
              gst_adapter_unmap (demux-&gt;adapter);
            }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6965,25 ***</span>
          /* initial newsegment sent here after having added pads,
           * possible others in sink_event */
          gst_qtdemux_check_send_pending_segment (demux);
  
          /* Figure out which stream this packet belongs to */
<span class="line-modified">!         for (i = 0; i &lt; demux-&gt;n_streams; i++) {</span>
<span class="line-modified">!           stream = demux-&gt;streams[i];</span>
<span class="line-modified">!           if (stream-&gt;sample_index &gt;= stream-&gt;n_samples)</span>
              continue;
            GST_LOG_OBJECT (demux,
<span class="line-modified">!               &quot;Checking stream %d (sample_index:%d / offset:%&quot; G_GUINT64_FORMAT</span>
<span class="line-modified">!               &quot; / size:%d)&quot;, i, stream-&gt;sample_index,</span>
                stream-&gt;samples[stream-&gt;sample_index].offset,
                stream-&gt;samples[stream-&gt;sample_index].size);
  
            if (stream-&gt;samples[stream-&gt;sample_index].offset == demux-&gt;offset)
              break;
          }
  
<span class="line-modified">!         if (G_UNLIKELY (stream == NULL || i == demux-&gt;n_streams))</span>
            goto unknown_stream;
  
          gst_qtdemux_stream_check_and_change_stsd_index (demux, stream);
  
          if (stream-&gt;new_caps) {
<span class="line-new-header">--- 7468,29 ---</span>
          /* initial newsegment sent here after having added pads,
           * possible others in sink_event */
          gst_qtdemux_check_send_pending_segment (demux);
  
          /* Figure out which stream this packet belongs to */
<span class="line-modified">!         for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified">!           stream = QTDEMUX_NTH_STREAM (demux, i);</span>
<span class="line-modified">!           if (stream-&gt;sample_index &gt;= stream-&gt;n_samples) {</span>
<span class="line-added">+             /* reset to be checked below G_UNLIKELY (stream == NULL) */</span>
<span class="line-added">+             stream = NULL;</span>
              continue;
<span class="line-added">+           }</span>
            GST_LOG_OBJECT (demux,
<span class="line-modified">!               &quot;Checking track-id %u (sample_index:%d / offset:%&quot;</span>
<span class="line-modified">!               G_GUINT64_FORMAT &quot; / size:%d)&quot;, stream-&gt;track_id,</span>
<span class="line-added">+               stream-&gt;sample_index,</span>
                stream-&gt;samples[stream-&gt;sample_index].offset,
                stream-&gt;samples[stream-&gt;sample_index].size);
  
            if (stream-&gt;samples[stream-&gt;sample_index].offset == demux-&gt;offset)
              break;
          }
  
<span class="line-modified">!         if (G_UNLIKELY (stream == NULL))</span>
            goto unknown_stream;
  
          gst_qtdemux_stream_check_and_change_stsd_index (demux, stream);
  
          if (stream-&gt;new_caps) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6992,32 ***</span>
  
          /* Put data in a buffer, set timestamps, caps, ... */
          sample = &amp;stream-&gt;samples[stream-&gt;sample_index];
  
          if (G_LIKELY (!(STREAM_IS_EOS (stream)))) {
<span class="line-modified">!         GST_DEBUG_OBJECT (demux, &quot;stream : %&quot; GST_FOURCC_FORMAT,</span>
                GST_FOURCC_ARGS (CUR_STREAM (stream)-&gt;fourcc));
  
            dts = QTSAMPLE_DTS (stream, sample);
            pts = QTSAMPLE_PTS (stream, sample);
            duration = QTSAMPLE_DUR_DTS (stream, sample, dts);
<span class="line-modified">!         keyframe = QTSAMPLE_KEYFRAME (stream, sample);</span>
  
            /* check for segment end */
            if (G_UNLIKELY (demux-&gt;segment.stop != -1
<span class="line-modified">!                   &amp;&amp; demux-&gt;segment.stop &lt;= pts &amp;&amp; stream-&gt;on_keyframe)) {</span>
              GST_DEBUG_OBJECT (demux, &quot;we reached the end of our segment.&quot;);
              stream-&gt;time_position = GST_CLOCK_TIME_NONE;        /* this means EOS */
  
              /* skip this data, stream is EOS */
              gst_adapter_flush (demux-&gt;adapter, demux-&gt;neededbytes);
              demux-&gt;offset += demux-&gt;neededbytes;
  
              /* check if all streams are eos */
              ret = GST_FLOW_EOS;
<span class="line-modified">!             for (i = 0; i &lt; demux-&gt;n_streams; i++) {</span>
<span class="line-modified">!               if (!STREAM_IS_EOS (demux-&gt;streams[i])) {</span>
                  ret = GST_FLOW_OK;
                  break;
                }
              }
            } else {
<span class="line-new-header">--- 7499,33 ---</span>
  
          /* Put data in a buffer, set timestamps, caps, ... */
          sample = &amp;stream-&gt;samples[stream-&gt;sample_index];
  
          if (G_LIKELY (!(STREAM_IS_EOS (stream)))) {
<span class="line-modified">!           GST_DEBUG_OBJECT (demux, &quot;stream : %&quot; GST_FOURCC_FORMAT,</span>
                GST_FOURCC_ARGS (CUR_STREAM (stream)-&gt;fourcc));
  
            dts = QTSAMPLE_DTS (stream, sample);
            pts = QTSAMPLE_PTS (stream, sample);
            duration = QTSAMPLE_DUR_DTS (stream, sample, dts);
<span class="line-modified">!           keyframe = QTSAMPLE_KEYFRAME (stream, sample);</span>
  
            /* check for segment end */
            if (G_UNLIKELY (demux-&gt;segment.stop != -1
<span class="line-modified">!                   &amp;&amp; demux-&gt;segment.stop &lt;= pts &amp;&amp; stream-&gt;on_keyframe)</span>
<span class="line-added">+               &amp;&amp; !(demux-&gt;upstream_format_is_time &amp;&amp; demux-&gt;segment.rate &lt; 0)) {</span>
              GST_DEBUG_OBJECT (demux, &quot;we reached the end of our segment.&quot;);
              stream-&gt;time_position = GST_CLOCK_TIME_NONE;        /* this means EOS */
  
              /* skip this data, stream is EOS */
              gst_adapter_flush (demux-&gt;adapter, demux-&gt;neededbytes);
              demux-&gt;offset += demux-&gt;neededbytes;
  
              /* check if all streams are eos */
              ret = GST_FLOW_EOS;
<span class="line-modified">!             for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified">!               if (!STREAM_IS_EOS (QTDEMUX_NTH_STREAM (demux, i))) {</span>
                  ret = GST_FLOW_OK;
                  break;
                }
              }
            } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7027,15 ***</span>
                  gst_adapter_take_buffer (demux-&gt;adapter, demux-&gt;neededbytes);
  
              /* FIXME: should either be an assert or a plain check */
              g_return_val_if_fail (outbuf != NULL, GST_FLOW_ERROR);
  
<span class="line-modified">!         ret = gst_qtdemux_decorate_and_push_buffer (demux, stream, outbuf,</span>
                  dts, pts, duration, keyframe, dts, demux-&gt;offset);
            }
  
<span class="line-modified">!         /* combine flows */</span>
            ret = gst_qtdemux_combine_flows (demux, stream, ret);
          } else {
            /* skip this data, stream is EOS */
            gst_adapter_flush (demux-&gt;adapter, demux-&gt;neededbytes);
          }
<span class="line-new-header">--- 7535,15 ---</span>
                  gst_adapter_take_buffer (demux-&gt;adapter, demux-&gt;neededbytes);
  
              /* FIXME: should either be an assert or a plain check */
              g_return_val_if_fail (outbuf != NULL, GST_FLOW_ERROR);
  
<span class="line-modified">!             ret = gst_qtdemux_decorate_and_push_buffer (demux, stream, outbuf,</span>
                  dts, pts, duration, keyframe, dts, demux-&gt;offset);
            }
  
<span class="line-modified">!           /* combine flows */</span>
            ret = gst_qtdemux_combine_flows (demux, stream, ret);
          } else {
            /* skip this data, stream is EOS */
            gst_adapter_flush (demux-&gt;adapter, demux-&gt;neededbytes);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7159,11 ***</span>
    gboolean res;
    GstQTDemux *demux = GST_QTDEMUX (parent);
  
    switch (mode) {
      case GST_PAD_MODE_PUSH:
<span class="line-modified">!   demux-&gt;pullbased = FALSE;</span>
        res = TRUE;
        break;
      case GST_PAD_MODE_PULL:
        if (active) {
          demux-&gt;pullbased = TRUE;
<span class="line-new-header">--- 7667,11 ---</span>
    gboolean res;
    GstQTDemux *demux = GST_QTDEMUX (parent);
  
    switch (mode) {
      case GST_PAD_MODE_PUSH:
<span class="line-modified">!       demux-&gt;pullbased = FALSE;</span>
        res = TRUE;
        break;
      case GST_PAD_MODE_PULL:
        if (active) {
          demux-&gt;pullbased = TRUE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7209,11 ***</span>
      if (ret == Z_STREAM_END) {
        break;
      } else if (ret != Z_OK) {
        GST_WARNING (&quot;inflate() returned %d&quot;, ret);
        break;
<span class="line-modified">!   }</span>
  
      *length += 4096;
      buffer = (guint8 *) g_realloc (buffer, *length);
      z.next_out = (Bytef *) (buffer + z.total_out);
      z.avail_out += 4096;
<span class="line-new-header">--- 7717,11 ---</span>
      if (ret == Z_STREAM_END) {
        break;
      } else if (ret != Z_OK) {
        GST_WARNING (&quot;inflate() returned %d&quot;, ret);
        break;
<span class="line-modified">!     }</span>
  
      *length += 4096;
      buffer = (guint8 *) g_realloc (buffer, *length);
      z.next_out = (Bytef *) (buffer + z.total_out);
      z.avail_out += 4096;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7282,15 ***</span>
          buf =
              (guint8 *) qtdemux_inflate ((guint8 *) cmvd-&gt;data + 12,
              compressed_length, &amp;uncompressed_length);
  
          if (buf) {
<span class="line-modified">!         qtdemux-&gt;moov_node_compressed = qtdemux-&gt;moov_node;</span>
<span class="line-modified">!         qtdemux-&gt;moov_node = g_node_new (buf);</span>
  
<span class="line-modified">!         qtdemux_parse_node (qtdemux, qtdemux-&gt;moov_node, buf,</span>
<span class="line-modified">!             uncompressed_length);</span>
          }
          break;
        }
  #endif /* HAVE_ZLIB */
        default:
<span class="line-new-header">--- 7790,15 ---</span>
          buf =
              (guint8 *) qtdemux_inflate ((guint8 *) cmvd-&gt;data + 12,
              compressed_length, &amp;uncompressed_length);
  
          if (buf) {
<span class="line-modified">!           qtdemux-&gt;moov_node_compressed = qtdemux-&gt;moov_node;</span>
<span class="line-modified">!           qtdemux-&gt;moov_node = g_node_new (buf);</span>
  
<span class="line-modified">!           qtdemux_parse_node (qtdemux, qtdemux-&gt;moov_node, buf,</span>
<span class="line-modified">!               uncompressed_length);</span>
          }
          break;
        }
  #endif /* HAVE_ZLIB */
        default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7593,11 ***</span>
             * starts with a &#39;hdlr&#39; atom */
            qtdemux_parse_container (qtdemux, node, buffer + 8, end);
          } else if (QT_UINT32 (buffer + 8) == 0x00000000) {
            /* Variant 2: What ISO BMFF specifies. &#39;meta&#39; is a _full_ atom
             * with version/flags both set to zero */
<span class="line-modified">!         qtdemux_parse_container (qtdemux, node, buffer + 12, end);</span>
          } else
            GST_WARNING_OBJECT (qtdemux, &quot;Unknown &#39;meta&#39; atom format&quot;);
          break;
        }
        case FOURCC_mp4s:
<span class="line-new-header">--- 8101,11 ---</span>
             * starts with a &#39;hdlr&#39; atom */
            qtdemux_parse_container (qtdemux, node, buffer + 8, end);
          } else if (QT_UINT32 (buffer + 8) == 0x00000000) {
            /* Variant 2: What ISO BMFF specifies. &#39;meta&#39; is a _full_ atom
             * with version/flags both set to zero */
<span class="line-modified">!           qtdemux_parse_container (qtdemux, node, buffer + 12, end);</span>
          } else
            GST_WARNING_OBJECT (qtdemux, &quot;Unknown &#39;meta&#39; atom format&quot;);
          break;
        }
        case FOURCC_mp4s:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7770,11 ***</span>
  {
    return qtdemux_tree_get_sibling_by_type_full (node, fourcc, NULL);
  }
  
  static void
<span class="line-modified">! qtdemux_do_allocation (GstQTDemux * qtdemux, QtDemuxStream * stream)</span>
  {
  /* FIXME: This can only reliably work if demuxers have a
   * separate streaming thread per srcpad. This should be
   * done in a demuxer base class, which integrates parts
   * of multiqueue
<span class="line-new-header">--- 8278,11 ---</span>
  {
    return qtdemux_tree_get_sibling_by_type_full (node, fourcc, NULL);
  }
  
  static void
<span class="line-modified">! qtdemux_do_allocation (QtDemuxStream * stream, GstQTDemux * qtdemux)</span>
  {
  /* FIXME: This can only reliably work if demuxers have a
   * separate streaming thread per srcpad. This should be
   * done in a demuxer base class, which integrates parts
   * of multiqueue
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7806,42 ***</span>
    }
    gst_query_unref (query);
  #endif
  }
  
  static gboolean
  gst_qtdemux_configure_protected_caps (GstQTDemux * qtdemux,
      QtDemuxStream * stream)
  {
    GstStructure *s;
<span class="line-modified">!   const gchar *selected_system;</span>
  
    g_return_val_if_fail (qtdemux != NULL, FALSE);
    g_return_val_if_fail (stream != NULL, FALSE);
    g_return_val_if_fail (gst_caps_get_size (CUR_STREAM (stream)-&gt;caps) == 1,
        FALSE);
  
    if (stream-&gt;protection_scheme_type != FOURCC_cenc) {
<span class="line-modified">!     GST_ERROR_OBJECT (qtdemux, &quot;unsupported protection scheme&quot;);</span>
      return FALSE;
    }
    if (qtdemux-&gt;protection_system_ids == NULL) {
      GST_ERROR_OBJECT (qtdemux, &quot;stream is protected using cenc, but no &quot;
          &quot;cenc protection system information has been found&quot;);
      return FALSE;
    }
<span class="line-modified">!   g_ptr_array_add (qtdemux-&gt;protection_system_ids, NULL);</span>
<span class="line-modified">!   selected_system = gst_protection_select_system ((const gchar **)</span>
<span class="line-modified">!       qtdemux-&gt;protection_system_ids-&gt;pdata);</span>
<span class="line-modified">!   g_ptr_array_remove_index (qtdemux-&gt;protection_system_ids,</span>
<span class="line-modified">!       qtdemux-&gt;protection_system_ids-&gt;len - 1);</span>
    if (!selected_system) {
      GST_ERROR_OBJECT (qtdemux, &quot;stream is protected, but no &quot;
          &quot;suitable decryptor element has been found&quot;);
      return FALSE;
    }
  
    s = gst_caps_get_structure (CUR_STREAM (stream)-&gt;caps, 0);
    if (!gst_structure_has_name (s, &quot;application/x-cenc&quot;)) {
      gst_structure_set (s,
          &quot;original-media-type&quot;, G_TYPE_STRING, gst_structure_get_name (s),
          GST_PROTECTION_SYSTEM_ID_CAPS_FIELD, G_TYPE_STRING, selected_system,
<span class="line-new-header">--- 8314,204 ---</span>
    }
    gst_query_unref (query);
  #endif
  }
  
<span class="line-added">+ static gboolean</span>
<span class="line-added">+ pad_query (const GValue * item, GValue * value, gpointer user_data)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   GstPad *pad = g_value_get_object (item);</span>
<span class="line-added">+   GstQuery *query = user_data;</span>
<span class="line-added">+   gboolean res;</span>
<span class="line-added">+ </span>
<span class="line-added">+   res = gst_pad_peer_query (pad, query);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (res) {</span>
<span class="line-added">+     g_value_set_boolean (value, TRUE);</span>
<span class="line-added">+     return FALSE;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   GST_INFO_OBJECT (pad, &quot;pad peer query failed&quot;);</span>
<span class="line-added">+   return TRUE;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static gboolean</span>
<span class="line-added">+ gst_qtdemux_run_query (GstElement * element, GstQuery * query,</span>
<span class="line-added">+     GstPadDirection direction)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   GstIterator *it;</span>
<span class="line-added">+   GstIteratorFoldFunction func = pad_query;</span>
<span class="line-added">+   GValue res = { 0, };</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_value_init (&amp;res, G_TYPE_BOOLEAN);</span>
<span class="line-added">+   g_value_set_boolean (&amp;res, FALSE);</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Ask neighbor */</span>
<span class="line-added">+   if (direction == GST_PAD_SRC)</span>
<span class="line-added">+     it = gst_element_iterate_src_pads (element);</span>
<span class="line-added">+   else</span>
<span class="line-added">+     it = gst_element_iterate_sink_pads (element);</span>
<span class="line-added">+ </span>
<span class="line-added">+   while (gst_iterator_fold (it, func, &amp;res, query) == GST_ITERATOR_RESYNC)</span>
<span class="line-added">+     gst_iterator_resync (it);</span>
<span class="line-added">+ </span>
<span class="line-added">+   gst_iterator_free (it);</span>
<span class="line-added">+ </span>
<span class="line-added">+   return g_value_get_boolean (&amp;res);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void</span>
<span class="line-added">+ gst_qtdemux_request_protection_context (GstQTDemux * qtdemux,</span>
<span class="line-added">+     QtDemuxStream * stream)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   GstQuery *query;</span>
<span class="line-added">+   GstContext *ctxt;</span>
<span class="line-added">+   GstElement *element = GST_ELEMENT (qtdemux);</span>
<span class="line-added">+   GstStructure *st;</span>
<span class="line-added">+   gchar **filtered_sys_ids;</span>
<span class="line-added">+   GValue event_list = G_VALUE_INIT;</span>
<span class="line-added">+   GList *walk;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* 1. Check if we already have the context. */</span>
<span class="line-added">+   if (qtdemux-&gt;preferred_protection_system_id != NULL) {</span>
<span class="line-added">+     GST_LOG_OBJECT (element,</span>
<span class="line-added">+         &quot;already have the protection context, no need to request it again&quot;);</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_ptr_array_add (qtdemux-&gt;protection_system_ids, NULL);</span>
<span class="line-added">+   filtered_sys_ids = gst_protection_filter_systems_by_available_decryptors (</span>
<span class="line-added">+       (const gchar **) qtdemux-&gt;protection_system_ids-&gt;pdata);</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_ptr_array_remove_index (qtdemux-&gt;protection_system_ids,</span>
<span class="line-added">+       qtdemux-&gt;protection_system_ids-&gt;len - 1);</span>
<span class="line-added">+   GST_TRACE_OBJECT (qtdemux, &quot;detected %u protection systems, we have &quot;</span>
<span class="line-added">+       &quot;decryptors for %u of them, running context request&quot;,</span>
<span class="line-added">+       qtdemux-&gt;protection_system_ids-&gt;len,</span>
<span class="line-added">+       filtered_sys_ids ? g_strv_length (filtered_sys_ids) : 0);</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+   if (stream-&gt;protection_scheme_event_queue.length) {</span>
<span class="line-added">+     GST_TRACE_OBJECT (qtdemux, &quot;using stream event queue, length %u&quot;,</span>
<span class="line-added">+         stream-&gt;protection_scheme_event_queue.length);</span>
<span class="line-added">+     walk = stream-&gt;protection_scheme_event_queue.tail;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     GST_TRACE_OBJECT (qtdemux, &quot;using demuxer event queue, length %u&quot;,</span>
<span class="line-added">+         qtdemux-&gt;protection_event_queue.length);</span>
<span class="line-added">+     walk = qtdemux-&gt;protection_event_queue.tail;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_value_init (&amp;event_list, GST_TYPE_LIST);</span>
<span class="line-added">+   for (; walk; walk = g_list_previous (walk)) {</span>
<span class="line-added">+     GValue *event_value = g_new0 (GValue, 1);</span>
<span class="line-added">+     g_value_init (event_value, GST_TYPE_EVENT);</span>
<span class="line-added">+     g_value_set_boxed (event_value, walk-&gt;data);</span>
<span class="line-added">+     gst_value_list_append_and_take_value (&amp;event_list, event_value);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   /*  2a) Query downstream with GST_QUERY_CONTEXT for the context and</span>
<span class="line-added">+    *      check if downstream already has a context of the specific type</span>
<span class="line-added">+    *  2b) Query upstream as above.</span>
<span class="line-added">+    */</span>
<span class="line-added">+   query = gst_query_new_context (&quot;drm-preferred-decryption-system-id&quot;);</span>
<span class="line-added">+   st = gst_query_writable_structure (query);</span>
<span class="line-added">+   gst_structure_set (st, &quot;track-id&quot;, G_TYPE_UINT, stream-&gt;track_id,</span>
<span class="line-added">+       &quot;available-stream-encryption-systems&quot;, G_TYPE_STRV, filtered_sys_ids,</span>
<span class="line-added">+       NULL);</span>
<span class="line-added">+   gst_structure_set_value (st, &quot;stream-encryption-events&quot;, &amp;event_list);</span>
<span class="line-added">+   if (gst_qtdemux_run_query (element, query, GST_PAD_SRC)) {</span>
<span class="line-added">+     gst_query_parse_context (query, &amp;ctxt);</span>
<span class="line-added">+     GST_INFO_OBJECT (element, &quot;found context (%p) in downstream query&quot;, ctxt);</span>
<span class="line-added">+     gst_element_set_context (element, ctxt);</span>
<span class="line-added">+   } else if (gst_qtdemux_run_query (element, query, GST_PAD_SINK)) {</span>
<span class="line-added">+     gst_query_parse_context (query, &amp;ctxt);</span>
<span class="line-added">+     GST_INFO_OBJECT (element, &quot;found context (%p) in upstream query&quot;, ctxt);</span>
<span class="line-added">+     gst_element_set_context (element, ctxt);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     /* 3) Post a GST_MESSAGE_NEED_CONTEXT message on the bus with</span>
<span class="line-added">+      *    the required context type and afterwards check if a</span>
<span class="line-added">+      *    usable context was set now as in 1). The message could</span>
<span class="line-added">+      *    be handled by the parent bins of the element and the</span>
<span class="line-added">+      *    application.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     GstMessage *msg;</span>
<span class="line-added">+ </span>
<span class="line-added">+     GST_INFO_OBJECT (element, &quot;posting need context message&quot;);</span>
<span class="line-added">+     msg = gst_message_new_need_context (GST_OBJECT_CAST (element),</span>
<span class="line-added">+         &quot;drm-preferred-decryption-system-id&quot;);</span>
<span class="line-added">+     st = (GstStructure *) gst_message_get_structure (msg);</span>
<span class="line-added">+     gst_structure_set (st, &quot;track-id&quot;, G_TYPE_UINT, stream-&gt;track_id,</span>
<span class="line-added">+         &quot;available-stream-encryption-systems&quot;, G_TYPE_STRV, filtered_sys_ids,</span>
<span class="line-added">+         NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+     gst_structure_set_value (st, &quot;stream-encryption-events&quot;, &amp;event_list);</span>
<span class="line-added">+     gst_element_post_message (element, msg);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_strfreev (filtered_sys_ids);</span>
<span class="line-added">+   g_value_unset (&amp;event_list);</span>
<span class="line-added">+   gst_query_unref (query);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static gboolean
  gst_qtdemux_configure_protected_caps (GstQTDemux * qtdemux,
      QtDemuxStream * stream)
  {
    GstStructure *s;
<span class="line-modified">!   const gchar *selected_system = NULL;</span>
  
    g_return_val_if_fail (qtdemux != NULL, FALSE);
    g_return_val_if_fail (stream != NULL, FALSE);
    g_return_val_if_fail (gst_caps_get_size (CUR_STREAM (stream)-&gt;caps) == 1,
        FALSE);
  
    if (stream-&gt;protection_scheme_type != FOURCC_cenc) {
<span class="line-modified">!     GST_ERROR_OBJECT (qtdemux,</span>
<span class="line-added">+         &quot;unsupported protection scheme: %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-added">+         GST_FOURCC_ARGS (stream-&gt;protection_scheme_type));</span>
      return FALSE;
    }
    if (qtdemux-&gt;protection_system_ids == NULL) {
      GST_ERROR_OBJECT (qtdemux, &quot;stream is protected using cenc, but no &quot;
          &quot;cenc protection system information has been found&quot;);
      return FALSE;
    }
<span class="line-modified">! </span>
<span class="line-modified">!   gst_qtdemux_request_protection_context (qtdemux, stream);</span>
<span class="line-modified">!   if (qtdemux-&gt;preferred_protection_system_id != NULL) {</span>
<span class="line-modified">!     const gchar *preferred_system_array[] =</span>
<span class="line-modified">!         { qtdemux-&gt;preferred_protection_system_id, NULL };</span>
<span class="line-added">+ </span>
<span class="line-added">+     selected_system = gst_protection_select_system (preferred_system_array);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (selected_system) {</span>
<span class="line-added">+       GST_TRACE_OBJECT (qtdemux, &quot;selected preferred system %s&quot;,</span>
<span class="line-added">+           qtdemux-&gt;preferred_protection_system_id);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       GST_WARNING_OBJECT (qtdemux, &quot;could not select preferred system %s &quot;</span>
<span class="line-added">+           &quot;because there is no available decryptor&quot;,</span>
<span class="line-added">+           qtdemux-&gt;preferred_protection_system_id);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!selected_system) {</span>
<span class="line-added">+     g_ptr_array_add (qtdemux-&gt;protection_system_ids, NULL);</span>
<span class="line-added">+     selected_system = gst_protection_select_system ((const gchar **)</span>
<span class="line-added">+         qtdemux-&gt;protection_system_ids-&gt;pdata);</span>
<span class="line-added">+     g_ptr_array_remove_index (qtdemux-&gt;protection_system_ids,</span>
<span class="line-added">+         qtdemux-&gt;protection_system_ids-&gt;len - 1);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    if (!selected_system) {
      GST_ERROR_OBJECT (qtdemux, &quot;stream is protected, but no &quot;
          &quot;suitable decryptor element has been found&quot;);
      return FALSE;
    }
  
<span class="line-added">+   GST_DEBUG_OBJECT (qtdemux, &quot;selected protection system is %s&quot;,</span>
<span class="line-added">+       selected_system);</span>
<span class="line-added">+ </span>
    s = gst_caps_get_structure (CUR_STREAM (stream)-&gt;caps, 0);
    if (!gst_structure_has_name (s, &quot;application/x-cenc&quot;)) {
      gst_structure_set (s,
          &quot;original-media-type&quot;, G_TYPE_STRING, gst_structure_get_name (s),
          GST_PROTECTION_SYSTEM_ID_CAPS_FIELD, G_TYPE_STRING, selected_system,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7850,74 ***</span>
    }
    return TRUE;
  }
  
  static gboolean
<span class="line-modified">! gst_qtdemux_configure_stream (GstQTDemux * qtdemux, QtDemuxStream * stream)</span>
  {
<span class="line-modified">!   if (stream-&gt;subtype == FOURCC_vide) {</span>
<span class="line-modified">!     /* fps is calculated base on the duration of the average framerate since</span>
<span class="line-modified">!      * qt does not have a fixed framerate. */</span>
<span class="line-modified">!     gboolean fps_available = TRUE;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if ((stream-&gt;n_samples == 1 &amp;&amp; stream-&gt;first_duration == 0)</span>
<span class="line-modified">!         || (qtdemux-&gt;fragmented &amp;&amp; stream-&gt;n_samples_moof == 1)) {</span>
<span class="line-modified">!       /* still frame */</span>
<span class="line-modified">!       CUR_STREAM (stream)-&gt;fps_n = 0;</span>
        CUR_STREAM (stream)-&gt;fps_d = 1;
      } else {
<span class="line-modified">!       if (stream-&gt;duration == 0 || stream-&gt;n_samples &lt; 2) {</span>
<span class="line-modified">!         CUR_STREAM (stream)-&gt;fps_n = stream-&gt;timescale;</span>
<span class="line-modified">!         CUR_STREAM (stream)-&gt;fps_d = 1;</span>
<span class="line-modified">!         fps_available = FALSE;</span>
        } else {
<span class="line-modified">!         GstClockTime avg_duration;</span>
<span class="line-modified">!         guint64 duration;</span>
<span class="line-modified">!         guint32 n_samples;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /* duration and n_samples can be updated for fragmented format</span>
<span class="line-removed">-          * so, framerate of fragmented format is calculated using data in a moof */</span>
<span class="line-removed">-         if (qtdemux-&gt;fragmented &amp;&amp; stream-&gt;n_samples_moof &gt; 0</span>
<span class="line-removed">-             &amp;&amp; stream-&gt;duration_moof &gt; 0) {</span>
<span class="line-removed">-           n_samples = stream-&gt;n_samples_moof;</span>
<span class="line-removed">-           duration = stream-&gt;duration_moof;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           n_samples = stream-&gt;n_samples;</span>
<span class="line-removed">-           duration = stream-&gt;duration;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         /* Calculate a framerate, ignoring the first sample which is sometimes truncated */</span>
<span class="line-modified">!         /* stream-&gt;duration is guint64, timescale, n_samples are guint32 */</span>
<span class="line-modified">!         avg_duration =</span>
<span class="line-modified">!             gst_util_uint64_scale_round (duration -</span>
<span class="line-modified">!             stream-&gt;first_duration, GST_SECOND,</span>
<span class="line-modified">!             (guint64) (stream-&gt;timescale) * (n_samples - 1));</span>
  
<span class="line-modified">!         GST_LOG_OBJECT (qtdemux,</span>
<span class="line-modified">!             &quot;Calculating avg sample duration based on stream (or moof) duration %&quot;</span>
<span class="line-modified">!             G_GUINT64_FORMAT</span>
<span class="line-modified">!             &quot; minus first sample %u, leaving %d samples gives %&quot;</span>
<span class="line-modified">!             GST_TIME_FORMAT, duration, stream-&gt;first_duration,</span>
<span class="line-modified">!             n_samples - 1, GST_TIME_ARGS (avg_duration));</span>
  
<span class="line-modified">!         gst_video_guess_framerate (avg_duration, &amp;CUR_STREAM (stream)-&gt;fps_n,</span>
<span class="line-modified">!             &amp;CUR_STREAM (stream)-&gt;fps_d);</span>
  
<span class="line-modified">!         GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-modified">!             &quot;Calculating framerate, timescale %u gave fps_n %d fps_d %d&quot;,</span>
<span class="line-modified">!             stream-&gt;timescale, CUR_STREAM (stream)-&gt;fps_n,</span>
<span class="line-modified">!             CUR_STREAM (stream)-&gt;fps_d);</span>
<span class="line-removed">-     }</span>
      }
  
      if (CUR_STREAM (stream)-&gt;caps) {
        CUR_STREAM (stream)-&gt;caps =
            gst_caps_make_writable (CUR_STREAM (stream)-&gt;caps);
  
<span class="line-modified">!       gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,</span>
<span class="line-modified">!           &quot;width&quot;, G_TYPE_INT, CUR_STREAM (stream)-&gt;width,</span>
<span class="line-modified">!           &quot;height&quot;, G_TYPE_INT, CUR_STREAM (stream)-&gt;height, NULL);</span>
  
        /* set framerate if calculated framerate is reliable */
        if (fps_available) {
          gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,
              &quot;framerate&quot;, GST_TYPE_FRACTION, CUR_STREAM (stream)-&gt;fps_n,
<span class="line-new-header">--- 8520,88 ---</span>
    }
    return TRUE;
  }
  
  static gboolean
<span class="line-modified">! gst_qtdemux_guess_framerate (GstQTDemux * qtdemux, QtDemuxStream * stream)</span>
  {
<span class="line-modified">!   /* fps is calculated base on the duration of the average framerate since</span>
<span class="line-modified">!    * qt does not have a fixed framerate. */</span>
<span class="line-modified">!   gboolean fps_available = TRUE;</span>
<span class="line-modified">!   guint32 first_duration = 0;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (stream-&gt;n_samples &gt; 0)</span>
<span class="line-modified">!     first_duration = stream-&gt;samples[0].duration;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if ((stream-&gt;n_samples == 1 &amp;&amp; first_duration == 0)</span>
<span class="line-added">+       || (qtdemux-&gt;fragmented &amp;&amp; stream-&gt;n_samples_moof == 1)) {</span>
<span class="line-added">+     /* still frame */</span>
<span class="line-added">+     CUR_STREAM (stream)-&gt;fps_n = 0;</span>
<span class="line-added">+     CUR_STREAM (stream)-&gt;fps_d = 1;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     if (stream-&gt;duration == 0 || stream-&gt;n_samples &lt; 2) {</span>
<span class="line-added">+       CUR_STREAM (stream)-&gt;fps_n = stream-&gt;timescale;</span>
        CUR_STREAM (stream)-&gt;fps_d = 1;
<span class="line-added">+       fps_available = FALSE;</span>
      } else {
<span class="line-modified">!       GstClockTime avg_duration;</span>
<span class="line-modified">!       guint64 duration;</span>
<span class="line-modified">!       guint32 n_samples;</span>
<span class="line-modified">! </span>
<span class="line-added">+       /* duration and n_samples can be updated for fragmented format</span>
<span class="line-added">+        * so, framerate of fragmented format is calculated using data in a moof */</span>
<span class="line-added">+       if (qtdemux-&gt;fragmented &amp;&amp; stream-&gt;n_samples_moof &gt; 0</span>
<span class="line-added">+           &amp;&amp; stream-&gt;duration_moof &gt; 0) {</span>
<span class="line-added">+         n_samples = stream-&gt;n_samples_moof;</span>
<span class="line-added">+         duration = stream-&gt;duration_moof;</span>
        } else {
<span class="line-modified">!         n_samples = stream-&gt;n_samples;</span>
<span class="line-modified">!         duration = stream-&gt;duration;</span>
<span class="line-modified">!       }</span>
  
<span class="line-modified">!       /* Calculate a framerate, ignoring the first sample which is sometimes truncated */</span>
<span class="line-modified">!       /* stream-&gt;duration is guint64, timescale, n_samples are guint32 */</span>
<span class="line-modified">!       avg_duration =</span>
<span class="line-modified">!           gst_util_uint64_scale_round (duration -</span>
<span class="line-modified">!           first_duration, GST_SECOND,</span>
<span class="line-modified">!           (guint64) (stream-&gt;timescale) * (n_samples - 1));</span>
  
<span class="line-modified">!       GST_LOG_OBJECT (qtdemux,</span>
<span class="line-modified">!           &quot;Calculating avg sample duration based on stream (or moof) duration %&quot;</span>
<span class="line-modified">!           G_GUINT64_FORMAT</span>
<span class="line-modified">!           &quot; minus first sample %u, leaving %d samples gives %&quot;</span>
<span class="line-modified">!           GST_TIME_FORMAT, duration, first_duration,</span>
<span class="line-modified">!           n_samples - 1, GST_TIME_ARGS (avg_duration));</span>
  
<span class="line-modified">!       fps_available =</span>
<span class="line-modified">!           gst_video_guess_framerate (avg_duration,</span>
<span class="line-added">+           &amp;CUR_STREAM (stream)-&gt;fps_n, &amp;CUR_STREAM (stream)-&gt;fps_d);</span>
  
<span class="line-modified">!       GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-modified">!           &quot;Calculating framerate, timescale %u gave fps_n %d fps_d %d&quot;,</span>
<span class="line-modified">!           stream-&gt;timescale, CUR_STREAM (stream)-&gt;fps_n,</span>
<span class="line-modified">!           CUR_STREAM (stream)-&gt;fps_d);</span>
      }
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return fps_available;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static gboolean</span>
<span class="line-added">+ gst_qtdemux_configure_stream (GstQTDemux * qtdemux, QtDemuxStream * stream)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   if (stream-&gt;subtype == FOURCC_vide) {</span>
<span class="line-added">+     gboolean fps_available = gst_qtdemux_guess_framerate (qtdemux, stream);</span>
  
      if (CUR_STREAM (stream)-&gt;caps) {
        CUR_STREAM (stream)-&gt;caps =
            gst_caps_make_writable (CUR_STREAM (stream)-&gt;caps);
  
<span class="line-modified">!       if (CUR_STREAM (stream)-&gt;width &amp;&amp; CUR_STREAM (stream)-&gt;height)</span>
<span class="line-modified">!         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,</span>
<span class="line-modified">!             &quot;width&quot;, G_TYPE_INT, CUR_STREAM (stream)-&gt;width,</span>
<span class="line-added">+             &quot;height&quot;, G_TYPE_INT, CUR_STREAM (stream)-&gt;height, NULL);</span>
  
        /* set framerate if calculated framerate is reliable */
        if (fps_available) {
          gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,
              &quot;framerate&quot;, GST_TYPE_FRACTION, CUR_STREAM (stream)-&gt;fps_n,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7965,12 ***</span>
              gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;field-order&quot;,
                  G_TYPE_STRING, &quot;top-field-first&quot;, NULL);
            } else if (CUR_STREAM (stream)-&gt;field_order == 14) {
              gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;field-order&quot;,
                  G_TYPE_STRING, &quot;bottom-field-first&quot;, NULL);
<span class="line-modified">!       }</span>
<span class="line-modified">!     }</span>
        }
  
        /* Create incomplete colorimetry here if needed */
        if (CUR_STREAM (stream)-&gt;colorimetry.range ||
            CUR_STREAM (stream)-&gt;colorimetry.matrix ||
<span class="line-new-header">--- 8649,12 ---</span>
              gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;field-order&quot;,
                  G_TYPE_STRING, &quot;top-field-first&quot;, NULL);
            } else if (CUR_STREAM (stream)-&gt;field_order == 14) {
              gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;field-order&quot;,
                  G_TYPE_STRING, &quot;bottom-field-first&quot;, NULL);
<span class="line-modified">!           }</span>
<span class="line-modified">!         }</span>
        }
  
        /* Create incomplete colorimetry here if needed */
        if (CUR_STREAM (stream)-&gt;colorimetry.range ||
            CUR_STREAM (stream)-&gt;colorimetry.matrix ||
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8024,10 ***</span>
<span class="line-new-header">--- 8708,60 ---</span>
              &quot;channel-mask&quot;, GST_TYPE_BITMASK, G_GUINT64_CONSTANT (0), NULL);
        }
      }
    }
  
<span class="line-added">+   else if (stream-&gt;subtype == FOURCC_clcp &amp;&amp; CUR_STREAM (stream)-&gt;caps) {</span>
<span class="line-added">+     const GstStructure *s;</span>
<span class="line-added">+     QtDemuxStream *fps_stream = NULL;</span>
<span class="line-added">+     gboolean fps_available = FALSE;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* CEA608 closed caption tracks are a bit special in that each sample</span>
<span class="line-added">+      * can contain CCs for multiple frames, and CCs can be omitted and have to</span>
<span class="line-added">+      * be inferred from the duration of the sample then.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * As such we take the framerate from the (first) video track here for</span>
<span class="line-added">+      * CEA608 as there must be one CC byte pair for every video frame</span>
<span class="line-added">+      * according to the spec.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * For CEA708 all is fine and there is one sample per frame.</span>
<span class="line-added">+      */</span>
<span class="line-added">+ </span>
<span class="line-added">+     s = gst_caps_get_structure (CUR_STREAM (stream)-&gt;caps, 0);</span>
<span class="line-added">+     if (gst_structure_has_name (s, &quot;closedcaption/x-cea-608&quot;)) {</span>
<span class="line-added">+       gint i;</span>
<span class="line-added">+ </span>
<span class="line-added">+       for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-added">+         QtDemuxStream *tmp = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (tmp-&gt;subtype == FOURCC_vide) {</span>
<span class="line-added">+           fps_stream = tmp;</span>
<span class="line-added">+           break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (fps_stream) {</span>
<span class="line-added">+         fps_available = gst_qtdemux_guess_framerate (qtdemux, fps_stream);</span>
<span class="line-added">+         CUR_STREAM (stream)-&gt;fps_n = CUR_STREAM (fps_stream)-&gt;fps_n;</span>
<span class="line-added">+         CUR_STREAM (stream)-&gt;fps_d = CUR_STREAM (fps_stream)-&gt;fps_d;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       fps_available = gst_qtdemux_guess_framerate (qtdemux, stream);</span>
<span class="line-added">+       fps_stream = stream;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     CUR_STREAM (stream)-&gt;caps =</span>
<span class="line-added">+         gst_caps_make_writable (CUR_STREAM (stream)-&gt;caps);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* set framerate if calculated framerate is reliable */</span>
<span class="line-added">+     if (fps_available) {</span>
<span class="line-added">+       gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,</span>
<span class="line-added">+           &quot;framerate&quot;, GST_TYPE_FRACTION, CUR_STREAM (stream)-&gt;fps_n,</span>
<span class="line-added">+           CUR_STREAM (stream)-&gt;fps_d, NULL);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    if (stream-&gt;pad) {
      GstCaps *prev_caps = NULL;
  
      GST_PAD_ELEMENT_PRIVATE (stream-&gt;pad) = stream;
      gst_pad_set_event_function (stream-&gt;pad, gst_qtdemux_handle_src_event);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8045,34 ***</span>
      }
  
      GST_DEBUG_OBJECT (qtdemux, &quot;setting caps %&quot; GST_PTR_FORMAT,
          CUR_STREAM (stream)-&gt;caps);
      if (stream-&gt;new_stream) {
<span class="line-removed">-       gchar *stream_id;</span>
        GstEvent *event;
        GstStreamFlags stream_flags = GST_STREAM_FLAG_NONE;
  
        event =
            gst_pad_get_sticky_event (qtdemux-&gt;sinkpad, GST_EVENT_STREAM_START,
            0);
        if (event) {
          gst_event_parse_stream_flags (event, &amp;stream_flags);
          if (gst_event_parse_group_id (event, &amp;qtdemux-&gt;group_id))
            qtdemux-&gt;have_group_id = TRUE;
<span class="line-modified">!           else</span>
            qtdemux-&gt;have_group_id = FALSE;
          gst_event_unref (event);
        } else if (!qtdemux-&gt;have_group_id) {
          qtdemux-&gt;have_group_id = TRUE;
          qtdemux-&gt;group_id = gst_util_group_id_next ();
        }
  
        stream-&gt;new_stream = FALSE;
<span class="line-modified">!       stream_id =</span>
<span class="line-removed">-           gst_pad_create_stream_id_printf (stream-&gt;pad,</span>
<span class="line-removed">-           GST_ELEMENT_CAST (qtdemux), &quot;%03u&quot;, stream-&gt;track_id);</span>
<span class="line-removed">-       event = gst_event_new_stream_start (stream_id);</span>
        if (qtdemux-&gt;have_group_id)
          gst_event_set_group_id (event, qtdemux-&gt;group_id);
        if (stream-&gt;disabled)
          stream_flags |= GST_STREAM_FLAG_UNSELECT;
        if (CUR_STREAM (stream)-&gt;sparse) {
<span class="line-new-header">--- 8779,30 ---</span>
      }
  
      GST_DEBUG_OBJECT (qtdemux, &quot;setting caps %&quot; GST_PTR_FORMAT,
          CUR_STREAM (stream)-&gt;caps);
      if (stream-&gt;new_stream) {
        GstEvent *event;
        GstStreamFlags stream_flags = GST_STREAM_FLAG_NONE;
  
        event =
            gst_pad_get_sticky_event (qtdemux-&gt;sinkpad, GST_EVENT_STREAM_START,
            0);
        if (event) {
          gst_event_parse_stream_flags (event, &amp;stream_flags);
          if (gst_event_parse_group_id (event, &amp;qtdemux-&gt;group_id))
            qtdemux-&gt;have_group_id = TRUE;
<span class="line-modified">!         else</span>
            qtdemux-&gt;have_group_id = FALSE;
          gst_event_unref (event);
        } else if (!qtdemux-&gt;have_group_id) {
          qtdemux-&gt;have_group_id = TRUE;
          qtdemux-&gt;group_id = gst_util_group_id_next ();
        }
  
        stream-&gt;new_stream = FALSE;
<span class="line-modified">!       event = gst_event_new_stream_start (stream-&gt;stream_id);</span>
        if (qtdemux-&gt;have_group_id)
          gst_event_set_group_id (event, qtdemux-&gt;group_id);
        if (stream-&gt;disabled)
          stream_flags |= GST_STREAM_FLAG_UNSELECT;
        if (CUR_STREAM (stream)-&gt;sparse) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8080,11 ***</span>
        } else {
          stream_flags &amp;= ~GST_STREAM_FLAG_SPARSE;
        }
        gst_event_set_stream_flags (event, stream_flags);
        gst_pad_push_event (stream-&gt;pad, event);
<span class="line-removed">-       g_free (stream_id);</span>
      }
  
      prev_caps = gst_pad_get_current_caps (stream-&gt;pad);
  
      if (CUR_STREAM (stream)-&gt;caps) {
<span class="line-new-header">--- 8810,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8131,12 ***</span>
  static gboolean
  gst_qtdemux_add_stream (GstQTDemux * qtdemux,
      QtDemuxStream * stream, GstTagList * list)
  {
    gboolean ret = TRUE;
<span class="line-removed">-   /* consistent default for push based mode */</span>
<span class="line-removed">-   gst_segment_init (&amp;stream-&gt;segment, GST_FORMAT_TIME);</span>
  
    if (stream-&gt;subtype == FOURCC_vide) {
      gchar *name = g_strdup_printf (&quot;video_%u&quot;, qtdemux-&gt;n_video_streams);
  
      stream-&gt;pad =
<span class="line-new-header">--- 8860,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8165,11 ***</span>
      }
      qtdemux-&gt;n_audio_streams++;
    } else if (stream-&gt;subtype == FOURCC_strm) {
      GST_DEBUG_OBJECT (qtdemux, &quot;stream type, not creating pad&quot;);
    } else if (stream-&gt;subtype == FOURCC_subp || stream-&gt;subtype == FOURCC_text
<span class="line-modified">!       || stream-&gt;subtype == FOURCC_sbtl || stream-&gt;subtype == FOURCC_subt) {</span>
      gchar *name = g_strdup_printf (&quot;subtitle_%u&quot;, qtdemux-&gt;n_sub_streams);
  
      stream-&gt;pad =
          gst_pad_new_from_static_template (&amp;gst_qtdemux_subsrc_template, name);
      g_free (name);
<span class="line-new-header">--- 8892,12 ---</span>
      }
      qtdemux-&gt;n_audio_streams++;
    } else if (stream-&gt;subtype == FOURCC_strm) {
      GST_DEBUG_OBJECT (qtdemux, &quot;stream type, not creating pad&quot;);
    } else if (stream-&gt;subtype == FOURCC_subp || stream-&gt;subtype == FOURCC_text
<span class="line-modified">!       || stream-&gt;subtype == FOURCC_sbtl || stream-&gt;subtype == FOURCC_subt</span>
<span class="line-added">+       || stream-&gt;subtype == FOURCC_clcp) {</span>
      gchar *name = g_strdup_printf (&quot;subtitle_%u&quot;, qtdemux-&gt;n_sub_streams);
  
      stream-&gt;pad =
          gst_pad_new_from_static_template (&amp;gst_qtdemux_subsrc_template, name);
      g_free (name);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8391,11 ***</span>
    if (!qt_atom_parser_has_chunks (&amp;stream-&gt;stts, stream-&gt;n_sample_times, 8)) {
      stream-&gt;n_sample_times = gst_byte_reader_get_remaining (&amp;stream-&gt;stts) / 8;
      GST_LOG_OBJECT (qtdemux, &quot;overriding to %u timestamp blocks&quot;,
          stream-&gt;n_sample_times);
      if (!stream-&gt;n_sample_times)
<span class="line-modified">!     goto corrupt_file;</span>
    }
  
    /* sync sample atom */
    stream-&gt;stps_present = FALSE;
    if ((stream-&gt;stss_present =
<span class="line-new-header">--- 9119,11 ---</span>
    if (!qt_atom_parser_has_chunks (&amp;stream-&gt;stts, stream-&gt;n_sample_times, 8)) {
      stream-&gt;n_sample_times = gst_byte_reader_get_remaining (&amp;stream-&gt;stts) / 8;
      GST_LOG_OBJECT (qtdemux, &quot;overriding to %u timestamp blocks&quot;,
          stream-&gt;n_sample_times);
      if (!stream-&gt;n_sample_times)
<span class="line-modified">!       goto corrupt_file;</span>
    }
  
    /* sync sample atom */
    stream-&gt;stps_present = FALSE;
    if ((stream-&gt;stss_present =
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8559,11 ***</span>
      if (qtdemux_tree_get_child_by_type_full (stbl, FOURCC_cslg, &amp;cslg)) {
        if (!gst_byte_reader_skip (&amp;cslg, 1 + 3)
            || !gst_byte_reader_get_uint32_be (&amp;cslg, &amp;stream-&gt;cslg_shift)) {
          g_free ((gpointer) cslg.data);
          goto corrupt_file;
<span class="line-modified">!   }</span>
      } else {
        gint32 cslg_least = 0;
        guint num_entries, pos;
        gint i;
  
<span class="line-new-header">--- 9287,11 ---</span>
      if (qtdemux_tree_get_child_by_type_full (stbl, FOURCC_cslg, &amp;cslg)) {
        if (!gst_byte_reader_skip (&amp;cslg, 1 + 3)
            || !gst_byte_reader_get_uint32_be (&amp;cslg, &amp;stream-&gt;cslg_shift)) {
          g_free ((gpointer) cslg.data);
          goto corrupt_file;
<span class="line-modified">!       }</span>
      } else {
        gint32 cslg_least = 0;
        guint num_entries, pos;
        gint i;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8575,10 ***</span>
<span class="line-new-header">--- 9303,22 ---</span>
        for (i = 0; i &lt; num_entries; i++) {
          gint32 offset;
  
          gst_byte_reader_skip_unchecked (&amp;stream-&gt;ctts, 4);
          offset = gst_byte_reader_get_int32_be_unchecked (&amp;stream-&gt;ctts);
<span class="line-added">+         /* HACK: if sample_offset is larger than 2 * duration, ignore the box.</span>
<span class="line-added">+          * slightly inaccurate PTS could be more usable than corrupted one */</span>
<span class="line-added">+         if (G_UNLIKELY ((ABS (offset) / 2) &gt; stream-&gt;duration)) {</span>
<span class="line-added">+           GST_WARNING_OBJECT (qtdemux,</span>
<span class="line-added">+               &quot;Ignore corrupted ctts, sample_offset %&quot; G_GINT32_FORMAT</span>
<span class="line-added">+               &quot; larger than duration %&quot; G_GUINT64_FORMAT,</span>
<span class="line-added">+               offset, stream-&gt;duration);</span>
<span class="line-added">+ </span>
<span class="line-added">+           stream-&gt;cslg_shift = 0;</span>
<span class="line-added">+           stream-&gt;ctts_present = FALSE;</span>
<span class="line-added">+           return TRUE;</span>
<span class="line-added">+         }</span>
  
          if (offset &lt; cslg_least)
            cslg_least = offset;
        }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8811,11 ***</span>
              /* save state */
              stream-&gt;stsc_sample_index = k + 1;
              stream-&gt;chunk_offset = chunk_offset;
              stream-&gt;stsc_chunk_index = j;
              goto done2;
<span class="line-modified">!     }</span>
          }
          stream-&gt;stsc_sample_index = 0;
        }
        stream-&gt;stsc_chunk_index = j;
      }
<span class="line-new-header">--- 9551,11 ---</span>
              /* save state */
              stream-&gt;stsc_sample_index = k + 1;
              stream-&gt;chunk_offset = chunk_offset;
              stream-&gt;stsc_chunk_index = j;
              goto done2;
<span class="line-modified">!           }</span>
          }
          stream-&gt;stsc_sample_index = 0;
        }
        stream-&gt;stsc_chunk_index = j;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9008,14 ***</span>
    if (n + 1 == stream-&gt;n_samples) {
      gst_qtdemux_stbl_free (stream);
      GST_DEBUG_OBJECT (qtdemux, &quot;parsed all available samples;&quot;);
      if (qtdemux-&gt;pullbased) {
        GST_DEBUG_OBJECT (qtdemux, &quot;checking for more samples&quot;);
<span class="line-modified">!     while (n + 1 == stream-&gt;n_samples)</span>
<span class="line-modified">!       if (qtdemux_add_fragmented_samples (qtdemux) != GST_FLOW_OK)</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!   }</span>
    }
    GST_OBJECT_UNLOCK (qtdemux);
  
    return TRUE;
  
<span class="line-new-header">--- 9748,14 ---</span>
    if (n + 1 == stream-&gt;n_samples) {
      gst_qtdemux_stbl_free (stream);
      GST_DEBUG_OBJECT (qtdemux, &quot;parsed all available samples;&quot;);
      if (qtdemux-&gt;pullbased) {
        GST_DEBUG_OBJECT (qtdemux, &quot;checking for more samples&quot;);
<span class="line-modified">!       while (n + 1 == stream-&gt;n_samples)</span>
<span class="line-modified">!         if (qtdemux_add_fragmented_samples (qtdemux) != GST_FLOW_OK)</span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!     }</span>
    }
    GST_OBJECT_UNLOCK (qtdemux);
  
    return TRUE;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9067,11 ***</span>
    stream-&gt;n_segments = 0;
    stream-&gt;segments = NULL;
    if ((edts = qtdemux_tree_get_child_by_type (trak, FOURCC_edts))) {
      GNode *elst;
      gint n_segments;
<span class="line-modified">!     gint i, count, entry_size;</span>
      guint64 time;
      GstClockTime stime;
      const guint8 *buffer;
      guint8 version;
      guint32 size;
<span class="line-new-header">--- 9807,11 ---</span>
    stream-&gt;n_segments = 0;
    stream-&gt;segments = NULL;
    if ((edts = qtdemux_tree_get_child_by_type (trak, FOURCC_edts))) {
      GNode *elst;
      gint n_segments;
<span class="line-modified">!     gint segment_number, entry_size;</span>
      guint64 time;
      GstClockTime stime;
      const guint8 *buffer;
      guint8 version;
      guint32 size;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9102,62 ***</span>
      stream-&gt;segments = g_new (QtDemuxSegment, MAX (n_segments, 1));
  
      /* segments always start from 0 */
      time = 0;
      stime = 0;
<span class="line-removed">-     count = 0;</span>
      buffer += 16;
<span class="line-modified">!     for (i = 0; i &lt; n_segments; i++) {</span>
        guint64 duration;
        guint64 media_time;
<span class="line-modified">!       gboolean time_valid = TRUE;</span>
        QtDemuxSegment *segment;
        guint32 rate_int;
        GstClockTime media_start = GST_CLOCK_TIME_NONE;
  
<span class="line-modified">!      if (version == 1) {</span>
          media_time = QT_UINT64 (buffer + 8);
          duration = QT_UINT64 (buffer);
          if (media_time == G_MAXUINT64)
<span class="line-modified">!           time_valid = FALSE;</span>
        } else {
          media_time = QT_UINT32 (buffer + 4);
          duration = QT_UINT32 (buffer);
          if (media_time == G_MAXUINT32)
<span class="line-modified">!           time_valid = FALSE;</span>
        }
  
<span class="line-modified">!       if (time_valid)</span>
          media_start = QTSTREAMTIME_TO_GSTTIME (stream, media_time);
  
<span class="line-modified">!       segment = &amp;stream-&gt;segments[count++];</span>
  
        /* time and duration expressed in global timescale */
        segment-&gt;time = stime;
<span class="line-modified">!       /* add non scaled values so we don&#39;t cause roundoff errors */</span>
<span class="line-modified">!       if (duration || media_start == GST_CLOCK_TIME_NONE) {</span>
<span class="line-modified">!       time += duration;</span>
          stime = QTTIME_TO_GSTTIME (qtdemux, time);
          segment-&gt;duration = stime - segment-&gt;time;
        } else {
          /* zero duration does not imply media_start == media_stop
<span class="line-modified">!          * but, only specify media_start.*/</span>
<span class="line-modified">!         stime = QTTIME_TO_GSTTIME (qtdemux, qtdemux-&gt;duration);</span>
<span class="line-modified">!         if (GST_CLOCK_TIME_IS_VALID (stime) &amp;&amp; time_valid</span>
<span class="line-modified">!             &amp;&amp; stime &gt;= media_start) {</span>
<span class="line-removed">-           segment-&gt;duration = stime - media_start;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           segment-&gt;duration = GST_CLOCK_TIME_NONE;</span>
<span class="line-removed">-         }</span>
        }
        segment-&gt;stop_time = stime;
  
        segment-&gt;trak_media_start = media_time;
        /* media_time expressed in stream timescale */
<span class="line-modified">!       if (time_valid) {</span>
          segment-&gt;media_start = media_start;
<span class="line-modified">!         segment-&gt;media_stop = segment-&gt;media_start + segment-&gt;duration;</span>
          media_segments_count++;
        } else {
          segment-&gt;media_start = GST_CLOCK_TIME_NONE;
          segment-&gt;media_stop = GST_CLOCK_TIME_NONE;
        }
<span class="line-new-header">--- 9842,61 ---</span>
      stream-&gt;segments = g_new (QtDemuxSegment, MAX (n_segments, 1));
  
      /* segments always start from 0 */
      time = 0;
      stime = 0;
      buffer += 16;
<span class="line-modified">!     for (segment_number = 0; segment_number &lt; n_segments; segment_number++) {</span>
        guint64 duration;
        guint64 media_time;
<span class="line-modified">!       gboolean empty_edit = FALSE;</span>
        QtDemuxSegment *segment;
        guint32 rate_int;
        GstClockTime media_start = GST_CLOCK_TIME_NONE;
  
<span class="line-modified">!       if (version == 1) {</span>
          media_time = QT_UINT64 (buffer + 8);
          duration = QT_UINT64 (buffer);
          if (media_time == G_MAXUINT64)
<span class="line-modified">!           empty_edit = TRUE;</span>
        } else {
          media_time = QT_UINT32 (buffer + 4);
          duration = QT_UINT32 (buffer);
          if (media_time == G_MAXUINT32)
<span class="line-modified">!           empty_edit = TRUE;</span>
        }
  
<span class="line-modified">!       if (!empty_edit)</span>
          media_start = QTSTREAMTIME_TO_GSTTIME (stream, media_time);
  
<span class="line-modified">!       segment = &amp;stream-&gt;segments[segment_number];</span>
  
        /* time and duration expressed in global timescale */
        segment-&gt;time = stime;
<span class="line-modified">!       if (duration != 0 || empty_edit) {</span>
<span class="line-modified">!         /* edge case: empty edits with duration=zero are treated here.</span>
<span class="line-modified">!          * (files should not have these anyway). */</span>
<span class="line-added">+ </span>
<span class="line-added">+         /* add non scaled values so we don&#39;t cause roundoff errors */</span>
<span class="line-added">+         time += duration;</span>
          stime = QTTIME_TO_GSTTIME (qtdemux, time);
          segment-&gt;duration = stime - segment-&gt;time;
        } else {
          /* zero duration does not imply media_start == media_stop
<span class="line-modified">!          * but, only specify media_start. The edit ends with the track. */</span>
<span class="line-modified">!         stime = segment-&gt;duration = GST_CLOCK_TIME_NONE;</span>
<span class="line-modified">!         /* Don&#39;t allow more edits after this one. */</span>
<span class="line-modified">!         n_segments = segment_number + 1;</span>
        }
        segment-&gt;stop_time = stime;
  
        segment-&gt;trak_media_start = media_time;
        /* media_time expressed in stream timescale */
<span class="line-modified">!       if (!empty_edit) {</span>
          segment-&gt;media_start = media_start;
<span class="line-modified">!         segment-&gt;media_stop = GST_CLOCK_TIME_IS_VALID (segment-&gt;duration)</span>
<span class="line-added">+             ? segment-&gt;media_start + segment-&gt;duration : GST_CLOCK_TIME_NONE;</span>
          media_segments_count++;
        } else {
          segment-&gt;media_start = GST_CLOCK_TIME_NONE;
          segment-&gt;media_stop = GST_CLOCK_TIME_NONE;
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9175,29 ***</span>
  
        GST_DEBUG_OBJECT (qtdemux, &quot;created segment %d time %&quot; GST_TIME_FORMAT
            &quot;, duration %&quot; GST_TIME_FORMAT &quot;, media_start %&quot; GST_TIME_FORMAT
            &quot; (%&quot; G_GUINT64_FORMAT &quot;) , media_stop %&quot; GST_TIME_FORMAT
            &quot; stop_time %&quot; GST_TIME_FORMAT &quot; rate %g, (%d) timescale %u&quot;,
<span class="line-modified">!           i, GST_TIME_ARGS (segment-&gt;time),</span>
            GST_TIME_ARGS (segment-&gt;duration),
            GST_TIME_ARGS (segment-&gt;media_start), media_time,
            GST_TIME_ARGS (segment-&gt;media_stop),
            GST_TIME_ARGS (segment-&gt;stop_time), segment-&gt;rate, rate_int,
            stream-&gt;timescale);
<span class="line-modified">!       if (segment-&gt;stop_time &gt; qtdemux-&gt;segment.stop) {</span>
          GST_WARNING_OBJECT (qtdemux, &quot;Segment %d &quot;
              &quot; extends to %&quot; GST_TIME_FORMAT
<span class="line-modified">!             &quot; past the end of the file duration %&quot; GST_TIME_FORMAT</span>
<span class="line-modified">!             &quot; it will be truncated&quot;, i, GST_TIME_ARGS (segment-&gt;stop_time),</span>
              GST_TIME_ARGS (qtdemux-&gt;segment.stop));
<span class="line-modified">!         qtdemux-&gt;segment.stop = segment-&gt;stop_time;</span>
<span class="line-modified">!     }</span>
  
        buffer += entry_size;
      }
<span class="line-modified">!     GST_DEBUG_OBJECT (qtdemux, &quot;found %d segments&quot;, count);</span>
<span class="line-modified">!     stream-&gt;n_segments = count;</span>
      if (media_segments_count != 1)
        allow_pushbased_edts = FALSE;
    }
  done:
  
<span class="line-new-header">--- 9914,31 ---</span>
  
        GST_DEBUG_OBJECT (qtdemux, &quot;created segment %d time %&quot; GST_TIME_FORMAT
            &quot;, duration %&quot; GST_TIME_FORMAT &quot;, media_start %&quot; GST_TIME_FORMAT
            &quot; (%&quot; G_GUINT64_FORMAT &quot;) , media_stop %&quot; GST_TIME_FORMAT
            &quot; stop_time %&quot; GST_TIME_FORMAT &quot; rate %g, (%d) timescale %u&quot;,
<span class="line-modified">!           segment_number, GST_TIME_ARGS (segment-&gt;time),</span>
            GST_TIME_ARGS (segment-&gt;duration),
            GST_TIME_ARGS (segment-&gt;media_start), media_time,
            GST_TIME_ARGS (segment-&gt;media_stop),
            GST_TIME_ARGS (segment-&gt;stop_time), segment-&gt;rate, rate_int,
            stream-&gt;timescale);
<span class="line-modified">!       if (segment-&gt;stop_time &gt; qtdemux-&gt;segment.stop &amp;&amp;</span>
<span class="line-added">+           !qtdemux-&gt;upstream_format_is_time) {</span>
          GST_WARNING_OBJECT (qtdemux, &quot;Segment %d &quot;
              &quot; extends to %&quot; GST_TIME_FORMAT
<span class="line-modified">!             &quot; past the end of the declared movie duration %&quot; GST_TIME_FORMAT</span>
<span class="line-modified">!             &quot; movie segment will be extended&quot;, segment_number,</span>
<span class="line-added">+             GST_TIME_ARGS (segment-&gt;stop_time),</span>
              GST_TIME_ARGS (qtdemux-&gt;segment.stop));
<span class="line-modified">!         qtdemux-&gt;segment.stop = qtdemux-&gt;segment.duration = segment-&gt;stop_time;</span>
<span class="line-modified">!       }</span>
  
        buffer += entry_size;
      }
<span class="line-modified">!     GST_DEBUG_OBJECT (qtdemux, &quot;found %d segments&quot;, n_segments);</span>
<span class="line-modified">!     stream-&gt;n_segments = n_segments;</span>
      if (media_segments_count != 1)
        allow_pushbased_edts = FALSE;
    }
  done:
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9586,10 ***</span>
<span class="line-new-header">--- 10327,13 ---</span>
  {
    GNode *sinf;
    GNode *frma;
    GNode *schm;
    GNode *schi;
<span class="line-added">+   QtDemuxCencSampleSetInfo *info;</span>
<span class="line-added">+   GNode *tenc;</span>
<span class="line-added">+   const guint8 *tenc_data;</span>
  
    g_return_val_if_fail (qtdemux != NULL, FALSE);
    g_return_val_if_fail (stream != NULL, FALSE);
    g_return_val_if_fail (container != NULL, FALSE);
    g_return_val_if_fail (original_fmt != NULL, FALSE);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9632,51 ***</span>
    schi = qtdemux_tree_get_child_by_type (sinf, FOURCC_schi);
    if (!schi) {
      GST_DEBUG_OBJECT (qtdemux, &quot;sinf box does not contain schi box&quot;);
      return FALSE;
    }
    if (stream-&gt;protection_scheme_type == FOURCC_cenc) {
<span class="line-modified">!     QtDemuxCencSampleSetInfo *info;</span>
<span class="line-removed">-     GNode *tenc;</span>
<span class="line-removed">-     const guint8 *tenc_data;</span>
<span class="line-removed">-     guint32 isEncrypted;</span>
      guint8 iv_size;
      const guint8 *default_kid;
<span class="line-removed">-     GstBuffer *kid_buf;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (G_UNLIKELY (!stream-&gt;protection_scheme_info))</span>
<span class="line-removed">-       stream-&gt;protection_scheme_info =</span>
<span class="line-removed">-           g_malloc0 (sizeof (QtDemuxCencSampleSetInfo));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     info = (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;</span>
  
      tenc = qtdemux_tree_get_child_by_type (schi, FOURCC_tenc);
      if (!tenc) {
        GST_ERROR_OBJECT (qtdemux, &quot;schi box does not contain tenc box, &quot;
            &quot;which is mandatory for Common Encryption&quot;);
        return FALSE;
      }
      tenc_data = (const guint8 *) tenc-&gt;data + 12;
<span class="line-modified">!     isEncrypted = QT_UINT24 (tenc_data);</span>
      iv_size = QT_UINT8 (tenc_data + 3);
      default_kid = (tenc_data + 4);
<span class="line-modified">!     kid_buf = gst_buffer_new_allocate (NULL, 16, NULL);</span>
<span class="line-modified">!     gst_buffer_fill (kid_buf, 0, default_kid, 16);</span>
<span class="line-modified">!     if (info-&gt;default_properties)</span>
<span class="line-modified">!       gst_structure_free (info-&gt;default_properties);</span>
<span class="line-modified">!     info-&gt;default_properties =</span>
<span class="line-modified">!         gst_structure_new (&quot;application/x-cenc&quot;,</span>
<span class="line-modified">!         &quot;iv_size&quot;, G_TYPE_UINT, iv_size,</span>
<span class="line-modified">!         &quot;encrypted&quot;, G_TYPE_BOOLEAN, (isEncrypted == 1),</span>
<span class="line-modified">!         &quot;kid&quot;, GST_TYPE_BUFFER, kid_buf, NULL);</span>
<span class="line-modified">!     GST_DEBUG_OBJECT (qtdemux, &quot;default sample properties: &quot;</span>
<span class="line-modified">!         &quot;is_encrypted=%u, iv_size=%u&quot;, isEncrypted, iv_size);</span>
<span class="line-modified">!     gst_buffer_unref (kid_buf);</span>
    }
    return TRUE;
  }
  
  /* parse the traks.
   * With each track we associate a new QtDemuxStream that contains all the info
   * about the trak.
   * traks that do not decode to something (like strm traks) will not have a pad.
   */
<span class="line-new-header">--- 10376,82 ---</span>
    schi = qtdemux_tree_get_child_by_type (sinf, FOURCC_schi);
    if (!schi) {
      GST_DEBUG_OBJECT (qtdemux, &quot;sinf box does not contain schi box&quot;);
      return FALSE;
    }
<span class="line-added">+   if (stream-&gt;protection_scheme_type != FOURCC_cenc &amp;&amp;</span>
<span class="line-added">+       stream-&gt;protection_scheme_type != FOURCC_piff) {</span>
<span class="line-added">+     GST_ERROR_OBJECT (qtdemux,</span>
<span class="line-added">+         &quot;Invalid protection_scheme_type: %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-added">+         GST_FOURCC_ARGS (stream-&gt;protection_scheme_type));</span>
<span class="line-added">+     return FALSE;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (G_UNLIKELY (!stream-&gt;protection_scheme_info))</span>
<span class="line-added">+     stream-&gt;protection_scheme_info =</span>
<span class="line-added">+         g_malloc0 (sizeof (QtDemuxCencSampleSetInfo));</span>
<span class="line-added">+ </span>
<span class="line-added">+   info = (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;</span>
<span class="line-added">+ </span>
    if (stream-&gt;protection_scheme_type == FOURCC_cenc) {
<span class="line-modified">!     guint32 is_encrypted;</span>
      guint8 iv_size;
      const guint8 *default_kid;
  
      tenc = qtdemux_tree_get_child_by_type (schi, FOURCC_tenc);
      if (!tenc) {
        GST_ERROR_OBJECT (qtdemux, &quot;schi box does not contain tenc box, &quot;
            &quot;which is mandatory for Common Encryption&quot;);
        return FALSE;
      }
      tenc_data = (const guint8 *) tenc-&gt;data + 12;
<span class="line-modified">!     is_encrypted = QT_UINT24 (tenc_data);</span>
      iv_size = QT_UINT8 (tenc_data + 3);
      default_kid = (tenc_data + 4);
<span class="line-modified">!     qtdemux_update_default_sample_encryption_settings (qtdemux, info,</span>
<span class="line-modified">!         is_encrypted, iv_size, default_kid);</span>
<span class="line-modified">!   } else if (stream-&gt;protection_scheme_type == FOURCC_piff) {</span>
<span class="line-modified">!     GstByteReader br;</span>
<span class="line-modified">!     static const guint8 piff_track_encryption_uuid[] = {</span>
<span class="line-modified">!       0x89, 0x74, 0xdb, 0xce, 0x7b, 0xe7, 0x4c, 0x51,</span>
<span class="line-modified">!       0x84, 0xf9, 0x71, 0x48, 0xf9, 0x88, 0x25, 0x54</span>
<span class="line-modified">!     };</span>
<span class="line-modified">! </span>
<span class="line-modified">!     tenc = qtdemux_tree_get_child_by_type (schi, FOURCC_uuid);</span>
<span class="line-modified">!     if (!tenc) {</span>
<span class="line-modified">!       GST_ERROR_OBJECT (qtdemux, &quot;schi box does not contain tenc box, &quot;</span>
<span class="line-added">+           &quot;which is mandatory for Common Encryption&quot;);</span>
<span class="line-added">+       return FALSE;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     tenc_data = (const guint8 *) tenc-&gt;data + 8;</span>
<span class="line-added">+     if (memcmp (tenc_data, piff_track_encryption_uuid, 16) != 0) {</span>
<span class="line-added">+       gchar *box_uuid = qtdemux_uuid_bytes_to_string (tenc_data);</span>
<span class="line-added">+       GST_ERROR_OBJECT (qtdemux,</span>
<span class="line-added">+           &quot;Unsupported track encryption box with uuid: %s&quot;, box_uuid);</span>
<span class="line-added">+       g_free (box_uuid);</span>
<span class="line-added">+       return FALSE;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     tenc_data = (const guint8 *) tenc-&gt;data + 16 + 12;</span>
<span class="line-added">+     gst_byte_reader_init (&amp;br, tenc_data, 20);</span>
<span class="line-added">+     if (!qtdemux_update_default_piff_encryption_settings (qtdemux, info, &amp;br)) {</span>
<span class="line-added">+       GST_ERROR_OBJECT (qtdemux, &quot;PIFF track box parsing error&quot;);</span>
<span class="line-added">+       return FALSE;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     stream-&gt;protection_scheme_type = FOURCC_cenc;</span>
    }
<span class="line-added">+ </span>
    return TRUE;
  }
  
<span class="line-added">+ static gint</span>
<span class="line-added">+ qtdemux_track_id_compare_func (QtDemuxStream ** stream1,</span>
<span class="line-added">+     QtDemuxStream ** stream2)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   return (gint) (*stream1)-&gt;track_id - (gint) (*stream2)-&gt;track_id;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  /* parse the traks.
   * With each track we associate a new QtDemuxStream that contains all the info
   * about the trak.
   * traks that do not decode to something (like strm traks) will not have a pad.
   */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9697,11 ***</span>
    GNode *tref;
    GNode *udta;
    GNode *svmi;
  
    QtDemuxStream *stream = NULL;
<span class="line-removed">-   gboolean new_stream = FALSE;</span>
    const guint8 *stsd_data;
    const guint8 *stsd_entry_data;
    guint remaining_stsd_len;
    guint stsd_entry_count;
    guint stsd_index;
<span class="line-new-header">--- 10472,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9725,26 ***</span>
    value_size = tkhd_version == 1 ? 8 : 4;
    if (!gst_byte_reader_skip (&amp;tkhd, value_size * 2) ||
        !gst_byte_reader_get_uint32_be (&amp;tkhd, &amp;track_id))
      goto corrupt_file;
  
<span class="line-modified">!   if (!qtdemux-&gt;got_moov) {</span>
<span class="line-modified">!     if (qtdemux_find_stream (qtdemux, track_id))</span>
<span class="line-modified">!       goto existing_stream;</span>
<span class="line-modified">!     stream = _create_stream ();</span>
<span class="line-modified">!     stream-&gt;track_id = track_id;</span>
<span class="line-modified">!     new_stream = TRUE;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     stream = qtdemux_find_stream (qtdemux, track_id);</span>
<span class="line-removed">-     if (!stream) {</span>
<span class="line-removed">-       GST_WARNING_OBJECT (qtdemux, &quot;Stream not found, going to ignore it&quot;);</span>
<span class="line-removed">-       goto skip_track;</span>
<span class="line-removed">-     }</span>
  
<span class="line-removed">-     /* reset reused stream */</span>
<span class="line-removed">-     gst_qtdemux_stream_reset (qtdemux, stream);</span>
<span class="line-removed">-   }</span>
    /* need defaults for fragments */
    qtdemux_parse_trex (qtdemux, stream, &amp;dummy, &amp;dummy, &amp;dummy);
  
    if ((tkhd_flags &amp; 1) == 0)
      stream-&gt;disabled = TRUE;
<span class="line-new-header">--- 10499,17 ---</span>
    value_size = tkhd_version == 1 ? 8 : 4;
    if (!gst_byte_reader_skip (&amp;tkhd, value_size * 2) ||
        !gst_byte_reader_get_uint32_be (&amp;tkhd, &amp;track_id))
      goto corrupt_file;
  
<span class="line-modified">!   /* Check if current moov has duplicated track_id */</span>
<span class="line-modified">!   if (qtdemux_find_stream (qtdemux, track_id))</span>
<span class="line-modified">!     goto existing_stream;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   stream = _create_stream (qtdemux, track_id);</span>
<span class="line-modified">!   stream-&gt;stream_tags = gst_tag_list_make_writable (stream-&gt;stream_tags);</span>
  
    /* need defaults for fragments */
    qtdemux_parse_trex (qtdemux, stream, &amp;dummy, &amp;dummy, &amp;dummy);
  
    if ((tkhd_flags &amp; 1) == 0)
      stream-&gt;disabled = TRUE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9769,15 ***</span>
  
    len = QT_UINT32 ((guint8 *) mdhd-&gt;data);
    version = QT_UINT32 ((guint8 *) mdhd-&gt;data + 8);
    GST_LOG_OBJECT (qtdemux, &quot;track version/flags: %08x&quot;, version);
    if (version == 0x01000000) {
<span class="line-modified">!     if (len &lt; 38)</span>
        goto corrupt_file;
      stream-&gt;timescale = QT_UINT32 ((guint8 *) mdhd-&gt;data + 28);
      stream-&gt;duration = QT_UINT64 ((guint8 *) mdhd-&gt;data + 32);
<span class="line-modified">!     lang_code = QT_UINT16 ((guint8 *) mdhd-&gt;data + 36);</span>
    } else {
      if (len &lt; 30)
        goto corrupt_file;
      stream-&gt;timescale = QT_UINT32 ((guint8 *) mdhd-&gt;data + 20);
      stream-&gt;duration = QT_UINT32 ((guint8 *) mdhd-&gt;data + 24);
<span class="line-new-header">--- 10534,15 ---</span>
  
    len = QT_UINT32 ((guint8 *) mdhd-&gt;data);
    version = QT_UINT32 ((guint8 *) mdhd-&gt;data + 8);
    GST_LOG_OBJECT (qtdemux, &quot;track version/flags: %08x&quot;, version);
    if (version == 0x01000000) {
<span class="line-modified">!     if (len &lt; 42)</span>
        goto corrupt_file;
      stream-&gt;timescale = QT_UINT32 ((guint8 *) mdhd-&gt;data + 28);
      stream-&gt;duration = QT_UINT64 ((guint8 *) mdhd-&gt;data + 32);
<span class="line-modified">!     lang_code = QT_UINT16 ((guint8 *) mdhd-&gt;data + 40);</span>
    } else {
      if (len &lt; 30)
        goto corrupt_file;
      stream-&gt;timescale = QT_UINT32 ((guint8 *) mdhd-&gt;data + 20);
      stream-&gt;duration = QT_UINT32 ((guint8 *) mdhd-&gt;data + 24);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9838,12 ***</span>
            &quot;Track shorter than 20%% (%&quot; G_GUINT64_FORMAT &quot;/%&quot; G_GUINT32_FORMAT
            &quot; vs. %&quot; G_GUINT64_FORMAT &quot;/%&quot; G_GUINT32_FORMAT &quot;) of the stream &quot;
            &quot;found, assuming preview image or something; skipping track&quot;,
            stream-&gt;duration, stream-&gt;timescale, qtdemux-&gt;duration,
            qtdemux-&gt;timescale);
<span class="line-modified">!       if (new_stream)</span>
<span class="line-removed">-         gst_qtdemux_stream_free (qtdemux, stream);</span>
        return TRUE;
      }
    }
  
    if (!(hdlr = qtdemux_tree_get_child_by_type (mdia, FOURCC_hdlr)))
<span class="line-new-header">--- 10603,11 ---</span>
            &quot;Track shorter than 20%% (%&quot; G_GUINT64_FORMAT &quot;/%&quot; G_GUINT32_FORMAT
            &quot; vs. %&quot; G_GUINT64_FORMAT &quot;/%&quot; G_GUINT32_FORMAT &quot;) of the stream &quot;
            &quot;found, assuming preview image or something; skipping track&quot;,
            stream-&gt;duration, stream-&gt;timescale, qtdemux-&gt;duration,
            qtdemux-&gt;timescale);
<span class="line-modified">!       gst_qtdemux_stream_unref (stream);</span>
        return TRUE;
      }
    }
  
    if (!(hdlr = qtdemux_tree_get_child_by_type (mdia, FOURCC_hdlr)))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9936,15 ***</span>
    /* stsd should at least have one entry */
    stsd_len = QT_UINT32 (stsd_data);
    if (stsd_len &lt; 24) {
      /* .. but skip stream with empty stsd produced by some Vivotek cameras */
      if (stream-&gt;subtype == FOURCC_vivo) {
<span class="line-modified">!       if (new_stream)</span>
<span class="line-removed">-         gst_qtdemux_stream_free (qtdemux, stream);</span>
        return TRUE;
      } else {
<span class="line-modified">!     goto corrupt_file;</span>
      }
    }
  
    stream-&gt;stsd_entries_length = stsd_entry_count = QT_UINT32 (stsd_data + 12);
    stream-&gt;stsd_entries = g_new0 (QtDemuxStreamStsdEntry, stsd_entry_count);
<span class="line-new-header">--- 10700,14 ---</span>
    /* stsd should at least have one entry */
    stsd_len = QT_UINT32 (stsd_data);
    if (stsd_len &lt; 24) {
      /* .. but skip stream with empty stsd produced by some Vivotek cameras */
      if (stream-&gt;subtype == FOURCC_vivo) {
<span class="line-modified">!       gst_qtdemux_stream_unref (stream);</span>
        return TRUE;
      } else {
<span class="line-modified">!       goto corrupt_file;</span>
      }
    }
  
    stream-&gt;stsd_entries_length = stsd_entry_count = QT_UINT32 (stsd_data + 12);
    stream-&gt;stsd_entries = g_new0 (QtDemuxStreamStsdEntry, stsd_entry_count);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9964,48 ***</span>
    for (stsd_index = 0; stsd_index &lt; stsd_entry_count; stsd_index++) {
      guint32 fourcc;
      gchar *codec = NULL;
      QtDemuxStreamStsdEntry *entry = &amp;stream-&gt;stsd_entries[stsd_index];
  
<span class="line-modified">!   /* and that entry should fit within stsd */</span>
      len = QT_UINT32 (stsd_entry_data);
      if (len &gt; remaining_stsd_len)
<span class="line-modified">!     goto corrupt_file;</span>
  
      entry-&gt;fourcc = fourcc = QT_FOURCC (stsd_entry_data + 4);
<span class="line-modified">!   GST_LOG_OBJECT (qtdemux, &quot;stsd type:          %&quot; GST_FOURCC_FORMAT,</span>
          GST_FOURCC_ARGS (entry-&gt;fourcc));
<span class="line-modified">!   GST_LOG_OBJECT (qtdemux, &quot;stsd type len:      %d&quot;, len);</span>
  
      if ((fourcc == FOURCC_drms) || (fourcc == FOURCC_drmi))
<span class="line-modified">!     goto error_encrypted;</span>
  
      if (fourcc == FOURCC_encv || fourcc == FOURCC_enca) {
        /* FIXME this looks wrong, there might be multiple children
         * with the same type */
        GNode *enc = qtdemux_tree_get_child_by_type (stsd, fourcc);
        stream-&gt;protected = TRUE;
        if (!qtdemux_parse_protection_scheme_info (qtdemux, stream, enc, &amp;fourcc))
          GST_ERROR_OBJECT (qtdemux, &quot;Failed to parse protection scheme info&quot;);
      }
  
<span class="line-modified">!   if (stream-&gt;subtype == FOURCC_vide) {</span>
        GNode *colr;
        GNode *fiel;
        GNode *pasp;
<span class="line-modified">!     gboolean gray;</span>
<span class="line-modified">!     gint depth, palette_size, palette_count;</span>
<span class="line-modified">!     guint32 *palette_data = NULL;</span>
  
        entry-&gt;sampled = TRUE;
  
<span class="line-modified">!     stream-&gt;display_width = w &gt;&gt; 16;</span>
<span class="line-modified">!     stream-&gt;display_height = h &gt;&gt; 16;</span>
  
<span class="line-modified">!     offset = 16;</span>
        if (len &lt; 86)             /* TODO verify */
<span class="line-modified">!       goto corrupt_file;</span>
  
        entry-&gt;width = QT_UINT16 (stsd_entry_data + offset + 16);
        entry-&gt;height = QT_UINT16 (stsd_entry_data + offset + 18);
        entry-&gt;fps_n = 0;         /* this is filled in later */
        entry-&gt;fps_d = 0;         /* this is filled in later */
<span class="line-new-header">--- 10727,48 ---</span>
    for (stsd_index = 0; stsd_index &lt; stsd_entry_count; stsd_index++) {
      guint32 fourcc;
      gchar *codec = NULL;
      QtDemuxStreamStsdEntry *entry = &amp;stream-&gt;stsd_entries[stsd_index];
  
<span class="line-modified">!     /* and that entry should fit within stsd */</span>
      len = QT_UINT32 (stsd_entry_data);
      if (len &gt; remaining_stsd_len)
<span class="line-modified">!       goto corrupt_file;</span>
  
      entry-&gt;fourcc = fourcc = QT_FOURCC (stsd_entry_data + 4);
<span class="line-modified">!     GST_LOG_OBJECT (qtdemux, &quot;stsd type:          %&quot; GST_FOURCC_FORMAT,</span>
          GST_FOURCC_ARGS (entry-&gt;fourcc));
<span class="line-modified">!     GST_LOG_OBJECT (qtdemux, &quot;stsd type len:      %d&quot;, len);</span>
  
      if ((fourcc == FOURCC_drms) || (fourcc == FOURCC_drmi))
<span class="line-modified">!       goto error_encrypted;</span>
  
      if (fourcc == FOURCC_encv || fourcc == FOURCC_enca) {
        /* FIXME this looks wrong, there might be multiple children
         * with the same type */
        GNode *enc = qtdemux_tree_get_child_by_type (stsd, fourcc);
        stream-&gt;protected = TRUE;
        if (!qtdemux_parse_protection_scheme_info (qtdemux, stream, enc, &amp;fourcc))
          GST_ERROR_OBJECT (qtdemux, &quot;Failed to parse protection scheme info&quot;);
      }
  
<span class="line-modified">!     if (stream-&gt;subtype == FOURCC_vide) {</span>
        GNode *colr;
        GNode *fiel;
        GNode *pasp;
<span class="line-modified">!       gboolean gray;</span>
<span class="line-modified">!       gint depth, palette_size, palette_count;</span>
<span class="line-modified">!       guint32 *palette_data = NULL;</span>
  
        entry-&gt;sampled = TRUE;
  
<span class="line-modified">!       stream-&gt;display_width = w &gt;&gt; 16;</span>
<span class="line-modified">!       stream-&gt;display_height = h &gt;&gt; 16;</span>
  
<span class="line-modified">!       offset = 16;</span>
        if (len &lt; 86)             /* TODO verify */
<span class="line-modified">!         goto corrupt_file;</span>
  
        entry-&gt;width = QT_UINT16 (stsd_entry_data + offset + 16);
        entry-&gt;height = QT_UINT16 (stsd_entry_data + offset + 18);
        entry-&gt;fps_n = 0;         /* this is filled in later */
        entry-&gt;fps_d = 0;         /* this is filled in later */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10019,180 ***</span>
            (len &lt; 90
                || QT_FOURCC (stsd_entry_data + offset + 70) != FOURCC_ctab)) {
          entry-&gt;color_table_id = -1;
        }
  
<span class="line-modified">!     GST_LOG_OBJECT (qtdemux, &quot;width %d, height %d, bps %d, color table id %d&quot;,</span>
            entry-&gt;width, entry-&gt;height, entry-&gt;bits_per_sample,
            entry-&gt;color_table_id);
  
        depth = entry-&gt;bits_per_sample;
  
<span class="line-modified">!     /* more than 32 bits means grayscale */</span>
<span class="line-modified">!     gray = (depth &gt; 32);</span>
<span class="line-modified">!     /* low 32 bits specify the depth  */</span>
<span class="line-modified">!     depth &amp;= 0x1F;</span>
  
<span class="line-modified">!     /* different number of palette entries is determined by depth. */</span>
<span class="line-modified">!     palette_count = 0;</span>
<span class="line-modified">!     if ((depth == 1) || (depth == 2) || (depth == 4) || (depth == 8))</span>
<span class="line-modified">!       palette_count = (1 &lt;&lt; depth);</span>
<span class="line-modified">!     palette_size = palette_count * 4;</span>
  
        if (entry-&gt;color_table_id) {
<span class="line-modified">!       switch (palette_count) {</span>
<span class="line-modified">!         case 0:</span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!         case 2:</span>
<span class="line-modified">!           palette_data = g_memdup (ff_qt_default_palette_2, palette_size);</span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!         case 4:</span>
<span class="line-modified">!           palette_data = g_memdup (ff_qt_default_palette_4, palette_size);</span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!         case 16:</span>
<span class="line-modified">!           if (gray)</span>
                palette_data =
                    g_memdup (ff_qt_grayscale_palette_16, palette_size);
<span class="line-modified">!           else</span>
<span class="line-modified">!             palette_data = g_memdup (ff_qt_default_palette_16, palette_size);</span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!         case 256:</span>
<span class="line-modified">!           if (gray)</span>
                palette_data =
                    g_memdup (ff_qt_grayscale_palette_256, palette_size);
<span class="line-modified">!           else</span>
<span class="line-modified">!             palette_data = g_memdup (ff_qt_default_palette_256, palette_size);</span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!         default:</span>
<span class="line-modified">!           GST_ELEMENT_WARNING (qtdemux, STREAM, DEMUX,</span>
<span class="line-modified">!               (_(&quot;The video in this file might not play correctly.&quot;)),</span>
<span class="line-modified">!               (&quot;unsupported palette depth %d&quot;, depth));</span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       gint i, j, start, end;</span>
  
<span class="line-modified">!       if (len &lt; 94)</span>
<span class="line-modified">!         goto corrupt_file;</span>
  
<span class="line-modified">!       /* read table */</span>
          start = QT_UINT32 (stsd_entry_data + offset + 70);
          palette_count = QT_UINT16 (stsd_entry_data + offset + 74);
          end = QT_UINT16 (stsd_entry_data + offset + 76);
  
<span class="line-modified">!       GST_LOG_OBJECT (qtdemux, &quot;start %d, end %d, palette_count %d&quot;,</span>
<span class="line-modified">!           start, end, palette_count);</span>
  
<span class="line-modified">!       if (end &gt; 255)</span>
<span class="line-modified">!         end = 255;</span>
<span class="line-modified">!       if (start &gt; end)</span>
<span class="line-modified">!         start = end;</span>
  
<span class="line-modified">!       if (len &lt; 94 + (end - start) * 8)</span>
<span class="line-modified">!         goto corrupt_file;</span>
  
<span class="line-modified">!       /* palette is always the same size */</span>
<span class="line-modified">!       palette_data = g_malloc0 (256 * 4);</span>
<span class="line-modified">!       palette_size = 256 * 4;</span>
  
<span class="line-modified">!       for (j = 0, i = start; i &lt;= end; j++, i++) {</span>
<span class="line-modified">!         guint32 a, r, g, b;</span>
  
            a = QT_UINT16 (stsd_entry_data + offset + 78 + (j * 8));
            r = QT_UINT16 (stsd_entry_data + offset + 80 + (j * 8));
            g = QT_UINT16 (stsd_entry_data + offset + 82 + (j * 8));
            b = QT_UINT16 (stsd_entry_data + offset + 84 + (j * 8));
  
<span class="line-modified">!         palette_data[i] = ((a &amp; 0xff00) &lt;&lt; 16) | ((r &amp; 0xff00) &lt;&lt; 8) |</span>
<span class="line-modified">!             (g &amp; 0xff00) | (b &gt;&gt; 8);</span>
        }
<span class="line-removed">-     }</span>
  
        if (entry-&gt;caps)
          gst_caps_unref (entry-&gt;caps);
  
        entry-&gt;caps =
            qtdemux_video_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,
            &amp;codec);
        if (G_UNLIKELY (!entry-&gt;caps)) {
<span class="line-modified">!       g_free (palette_data);</span>
<span class="line-modified">!       goto unknown_stream;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     if (codec) {</span>
          gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">!           GST_TAG_VIDEO_CODEC, codec, NULL);</span>
<span class="line-modified">!       g_free (codec);</span>
<span class="line-modified">!       codec = NULL;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     if (palette_data) {</span>
<span class="line-modified">!       GstStructure *s;</span>
  
          if (entry-&gt;rgb8_palette)
            gst_memory_unref (entry-&gt;rgb8_palette);
          entry-&gt;rgb8_palette = gst_memory_new_wrapped (GST_MEMORY_FLAG_READONLY,
<span class="line-modified">!           palette_data, palette_size, 0, palette_size, palette_data, g_free);</span>
  
          s = gst_caps_get_structure (entry-&gt;caps, 0);
  
<span class="line-modified">!       /* non-raw video has a palette_data property. raw video has the palette as</span>
<span class="line-modified">!        * an extra plane that we append to the output buffers before we push</span>
<span class="line-modified">!        * them*/</span>
<span class="line-modified">!       if (!gst_structure_has_name (s, &quot;video/x-raw&quot;)) {</span>
<span class="line-modified">!         GstBuffer *palette;</span>
  
<span class="line-modified">!         palette = gst_buffer_new ();</span>
            gst_buffer_append_memory (palette, entry-&gt;rgb8_palette);
            entry-&gt;rgb8_palette = NULL;
  
            gst_caps_set_simple (entry-&gt;caps, &quot;palette_data&quot;,
<span class="line-modified">!             GST_TYPE_BUFFER, palette, NULL);</span>
<span class="line-modified">!         gst_buffer_unref (palette);</span>
        }
<span class="line-removed">-     } else if (palette_count != 0) {</span>
<span class="line-removed">-       GST_ELEMENT_WARNING (qtdemux, STREAM, NOT_IMPLEMENTED,</span>
<span class="line-removed">-           (NULL), (&quot;Unsupported palette depth %d&quot;, depth));</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     GST_LOG_OBJECT (qtdemux, &quot;frame count:   %u&quot;,</span>
            QT_UINT16 (stsd_entry_data + offset + 32));
  
<span class="line-modified">!     esds = NULL;</span>
<span class="line-modified">!     pasp = NULL;</span>
        colr = NULL;
        fiel = NULL;
<span class="line-modified">!     /* pick &#39;the&#39; stsd child */</span>
        mp4v = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">!       if (!stream-&gt;protected) {</span>
<span class="line-modified">!         if (QTDEMUX_TREE_NODE_FOURCC (mp4v) != fourcc) {</span>
            mp4v = NULL;
<span class="line-modified">!         }</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         if (QTDEMUX_TREE_NODE_FOURCC (mp4v) != FOURCC_encv) {</span>
            mp4v = NULL;
<span class="line-removed">-         }</span>
        }
  
<span class="line-modified">!     if (mp4v) {</span>
<span class="line-modified">!       esds = qtdemux_tree_get_child_by_type (mp4v, FOURCC_esds);</span>
<span class="line-modified">!       pasp = qtdemux_tree_get_child_by_type (mp4v, FOURCC_pasp);</span>
          colr = qtdemux_tree_get_child_by_type (mp4v, FOURCC_colr);
          fiel = qtdemux_tree_get_child_by_type (mp4v, FOURCC_fiel);
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     if (pasp) {</span>
<span class="line-modified">!       const guint8 *pasp_data = (const guint8 *) pasp-&gt;data;</span>
          gint len = QT_UINT32 (pasp_data);
  
          if (len == 16) {
            CUR_STREAM (stream)-&gt;par_w = QT_UINT32 (pasp_data + 8);
            CUR_STREAM (stream)-&gt;par_h = QT_UINT32 (pasp_data + 12);
<span class="line-modified">!     } else {</span>
            CUR_STREAM (stream)-&gt;par_w = 0;
            CUR_STREAM (stream)-&gt;par_h = 0;
<span class="line-modified">!     }</span>
        } else {
          CUR_STREAM (stream)-&gt;par_w = 0;
          CUR_STREAM (stream)-&gt;par_h = 0;
        }
  
<span class="line-new-header">--- 10782,183 ---</span>
            (len &lt; 90
                || QT_FOURCC (stsd_entry_data + offset + 70) != FOURCC_ctab)) {
          entry-&gt;color_table_id = -1;
        }
  
<span class="line-modified">!       GST_LOG_OBJECT (qtdemux, &quot;width %d, height %d, bps %d, color table id %d&quot;,</span>
            entry-&gt;width, entry-&gt;height, entry-&gt;bits_per_sample,
            entry-&gt;color_table_id);
  
        depth = entry-&gt;bits_per_sample;
  
<span class="line-modified">!       /* more than 32 bits means grayscale */</span>
<span class="line-modified">!       gray = (depth &gt; 32);</span>
<span class="line-modified">!       /* low 32 bits specify the depth  */</span>
<span class="line-modified">!       depth &amp;= 0x1F;</span>
  
<span class="line-modified">!       /* different number of palette entries is determined by depth. */</span>
<span class="line-modified">!       palette_count = 0;</span>
<span class="line-modified">!       if ((depth == 1) || (depth == 2) || (depth == 4) || (depth == 8))</span>
<span class="line-modified">!         palette_count = (1 &lt;&lt; depth);</span>
<span class="line-modified">!       palette_size = palette_count * 4;</span>
  
        if (entry-&gt;color_table_id) {
<span class="line-modified">!         switch (palette_count) {</span>
<span class="line-modified">!           case 0:</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!           case 2:</span>
<span class="line-modified">!             palette_data = g_memdup (ff_qt_default_palette_2, palette_size);</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!           case 4:</span>
<span class="line-modified">!             palette_data = g_memdup (ff_qt_default_palette_4, palette_size);</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!           case 16:</span>
<span class="line-modified">!             if (gray)</span>
                palette_data =
                    g_memdup (ff_qt_grayscale_palette_16, palette_size);
<span class="line-modified">!             else</span>
<span class="line-modified">!               palette_data = g_memdup (ff_qt_default_palette_16, palette_size);</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!           case 256:</span>
<span class="line-modified">!             if (gray)</span>
                palette_data =
                    g_memdup (ff_qt_grayscale_palette_256, palette_size);
<span class="line-modified">!             else</span>
<span class="line-modified">!               palette_data = g_memdup (ff_qt_default_palette_256, palette_size);</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!           default:</span>
<span class="line-modified">!             GST_ELEMENT_WARNING (qtdemux, STREAM, DEMUX,</span>
<span class="line-modified">!                 (_(&quot;The video in this file might not play correctly.&quot;)),</span>
<span class="line-modified">!                 (&quot;unsupported palette depth %d&quot;, depth));</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         gint i, j, start, end;</span>
  
<span class="line-modified">!         if (len &lt; 94)</span>
<span class="line-modified">!           goto corrupt_file;</span>
  
<span class="line-modified">!         /* read table */</span>
          start = QT_UINT32 (stsd_entry_data + offset + 70);
          palette_count = QT_UINT16 (stsd_entry_data + offset + 74);
          end = QT_UINT16 (stsd_entry_data + offset + 76);
  
<span class="line-modified">!         GST_LOG_OBJECT (qtdemux, &quot;start %d, end %d, palette_count %d&quot;,</span>
<span class="line-modified">!             start, end, palette_count);</span>
  
<span class="line-modified">!         if (end &gt; 255)</span>
<span class="line-modified">!           end = 255;</span>
<span class="line-modified">!         if (start &gt; end)</span>
<span class="line-modified">!           start = end;</span>
  
<span class="line-modified">!         if (len &lt; 94 + (end - start) * 8)</span>
<span class="line-modified">!           goto corrupt_file;</span>
  
<span class="line-modified">!         /* palette is always the same size */</span>
<span class="line-modified">!         palette_data = g_malloc0 (256 * 4);</span>
<span class="line-modified">!         palette_size = 256 * 4;</span>
  
<span class="line-modified">!         for (j = 0, i = start; i &lt;= end; j++, i++) {</span>
<span class="line-modified">!           guint32 a, r, g, b;</span>
  
            a = QT_UINT16 (stsd_entry_data + offset + 78 + (j * 8));
            r = QT_UINT16 (stsd_entry_data + offset + 80 + (j * 8));
            g = QT_UINT16 (stsd_entry_data + offset + 82 + (j * 8));
            b = QT_UINT16 (stsd_entry_data + offset + 84 + (j * 8));
  
<span class="line-modified">!           palette_data[i] = ((a &amp; 0xff00) &lt;&lt; 16) | ((r &amp; 0xff00) &lt;&lt; 8) |</span>
<span class="line-modified">!               (g &amp; 0xff00) | (b &gt;&gt; 8);</span>
<span class="line-added">+         }</span>
        }
  
        if (entry-&gt;caps)
          gst_caps_unref (entry-&gt;caps);
  
        entry-&gt;caps =
            qtdemux_video_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,
            &amp;codec);
        if (G_UNLIKELY (!entry-&gt;caps)) {
<span class="line-modified">!         g_free (palette_data);</span>
<span class="line-modified">!         goto unknown_stream;</span>
<span class="line-modified">!       }</span>
  
<span class="line-modified">!       if (codec) {</span>
          gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">!             GST_TAG_VIDEO_CODEC, codec, NULL);</span>
<span class="line-modified">!         g_free (codec);</span>
<span class="line-modified">!         codec = NULL;</span>
<span class="line-modified">!       }</span>
  
<span class="line-modified">!       if (palette_data) {</span>
<span class="line-modified">!         GstStructure *s;</span>
  
          if (entry-&gt;rgb8_palette)
            gst_memory_unref (entry-&gt;rgb8_palette);
          entry-&gt;rgb8_palette = gst_memory_new_wrapped (GST_MEMORY_FLAG_READONLY,
<span class="line-modified">!             palette_data, palette_size, 0, palette_size, palette_data, g_free);</span>
  
          s = gst_caps_get_structure (entry-&gt;caps, 0);
  
<span class="line-modified">!         /* non-raw video has a palette_data property. raw video has the palette as</span>
<span class="line-modified">!          * an extra plane that we append to the output buffers before we push</span>
<span class="line-modified">!          * them*/</span>
<span class="line-modified">!         if (!gst_structure_has_name (s, &quot;video/x-raw&quot;)) {</span>
<span class="line-modified">!           GstBuffer *palette;</span>
  
<span class="line-modified">!           palette = gst_buffer_new ();</span>
            gst_buffer_append_memory (palette, entry-&gt;rgb8_palette);
            entry-&gt;rgb8_palette = NULL;
  
            gst_caps_set_simple (entry-&gt;caps, &quot;palette_data&quot;,
<span class="line-modified">!               GST_TYPE_BUFFER, palette, NULL);</span>
<span class="line-modified">!           gst_buffer_unref (palette);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       } else if (palette_count != 0) {</span>
<span class="line-added">+         GST_ELEMENT_WARNING (qtdemux, STREAM, NOT_IMPLEMENTED,</span>
<span class="line-added">+             (NULL), (&quot;Unsupported palette depth %d&quot;, depth));</span>
        }
  
<span class="line-modified">!       GST_LOG_OBJECT (qtdemux, &quot;frame count:   %u&quot;,</span>
            QT_UINT16 (stsd_entry_data + offset + 32));
  
<span class="line-modified">!       esds = NULL;</span>
<span class="line-modified">!       pasp = NULL;</span>
        colr = NULL;
        fiel = NULL;
<span class="line-modified">!       /* pick &#39;the&#39; stsd child */</span>
        mp4v = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">!       // We should skip parsing the stsd for non-protected streams if</span>
<span class="line-modified">!       // the entry doesn&#39;t match the fourcc, since they don&#39;t change</span>
<span class="line-added">+       // format. However, for protected streams we can have partial</span>
<span class="line-added">+       // encryption, where parts of the stream are encrypted and parts</span>
<span class="line-added">+       // not. For both parts of such streams, we should ensure the</span>
<span class="line-added">+       // esds overrides are parsed for both from the stsd.</span>
<span class="line-added">+       if (QTDEMUX_TREE_NODE_FOURCC (mp4v) != fourcc) {</span>
<span class="line-added">+         if (stream-&gt;protected &amp;&amp; QTDEMUX_TREE_NODE_FOURCC (mp4v) != FOURCC_encv)</span>
            mp4v = NULL;
<span class="line-modified">!         else if (!stream-&gt;protected)</span>
            mp4v = NULL;
        }
  
<span class="line-modified">!       if (mp4v) {</span>
<span class="line-modified">!         esds = qtdemux_tree_get_child_by_type (mp4v, FOURCC_esds);</span>
<span class="line-modified">!         pasp = qtdemux_tree_get_child_by_type (mp4v, FOURCC_pasp);</span>
          colr = qtdemux_tree_get_child_by_type (mp4v, FOURCC_colr);
          fiel = qtdemux_tree_get_child_by_type (mp4v, FOURCC_fiel);
<span class="line-modified">!       }</span>
  
<span class="line-modified">!       if (pasp) {</span>
<span class="line-modified">!         const guint8 *pasp_data = (const guint8 *) pasp-&gt;data;</span>
          gint len = QT_UINT32 (pasp_data);
  
          if (len == 16) {
            CUR_STREAM (stream)-&gt;par_w = QT_UINT32 (pasp_data + 8);
            CUR_STREAM (stream)-&gt;par_h = QT_UINT32 (pasp_data + 12);
<span class="line-modified">!         } else {</span>
            CUR_STREAM (stream)-&gt;par_w = 0;
            CUR_STREAM (stream)-&gt;par_h = 0;
<span class="line-modified">!         }</span>
        } else {
          CUR_STREAM (stream)-&gt;par_w = 0;
          CUR_STREAM (stream)-&gt;par_h = 0;
        }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10283,430 ***</span>
          } else {
            GST_WARNING_OBJECT (qtdemux, &quot;Invalid colr atom size&quot;);
          }
        }
  
<span class="line-modified">!     if (esds) {</span>
  #ifdef GSTREAMER_LITE
          if (!gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
                                        stream-&gt;stream_tags))
              goto corrupt_file;
  #else
          gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
              stream-&gt;stream_tags);
  #endif // GSTREAMER_LITE
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       switch (fourcc) {</span>
<span class="line-modified">!         case FOURCC_H264:</span>
<span class="line-modified">!         case FOURCC_avc1:</span>
<span class="line-modified">!         case FOURCC_avc3:</span>
<span class="line-modified">!         {</span>
              gint len = QT_UINT32 (stsd_entry_data) - 0x56;
              const guint8 *avc_data = stsd_entry_data + 0x56;
  
<span class="line-modified">!           /* find avcC */</span>
<span class="line-modified">!           while (len &gt;= 0x8) {</span>
<span class="line-modified">!             gint size;</span>
  
<span class="line-modified">!             if (QT_UINT32 (avc_data) &lt;= len)</span>
<span class="line-modified">!               size = QT_UINT32 (avc_data) - 0x8;</span>
<span class="line-modified">!             else</span>
<span class="line-modified">!               size = len - 0x8;</span>
  
<span class="line-modified">!             if (size &lt; 1)</span>
<span class="line-modified">!               /* No real data, so break out */</span>
<span class="line-modified">!               break;</span>
  
<span class="line-modified">!             switch (QT_FOURCC (avc_data + 0x4)) {</span>
<span class="line-modified">!               case FOURCC_avcC:</span>
<span class="line-modified">!               {</span>
<span class="line-modified">!                 /* parse, if found */</span>
<span class="line-modified">!                 GstBuffer *buf;</span>
  
<span class="line-modified">!                 GST_DEBUG_OBJECT (qtdemux, &quot;found avcC codec_data in stsd&quot;);</span>
  
<span class="line-modified">!                 /* First 4 bytes are the length of the atom, the next 4 bytes</span>
<span class="line-modified">!                  * are the fourcc, the next 1 byte is the version, and the</span>
<span class="line-modified">!                  * subsequent bytes are profile_tier_level structure like data. */</span>
                    gst_codec_utils_h264_caps_set_level_and_profile (entry-&gt;caps,
<span class="line-modified">!                     avc_data + 8 + 1, size - 1);</span>
<span class="line-modified">!                 buf = gst_buffer_new_and_alloc (size);</span>
<span class="line-modified">!                 gst_buffer_fill (buf, 0, avc_data + 0x8, size);</span>
                    gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                     &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">!                 gst_buffer_unref (buf);</span>
  
<span class="line-modified">!                 break;</span>
<span class="line-modified">!               }</span>
<span class="line-modified">!               case FOURCC_strf:</span>
<span class="line-modified">!               {</span>
<span class="line-modified">!                 GstBuffer *buf;</span>
  
<span class="line-modified">!                 GST_DEBUG_OBJECT (qtdemux, &quot;found strf codec_data in stsd&quot;);</span>
  
<span class="line-modified">!                 /* First 4 bytes are the length of the atom, the next 4 bytes</span>
<span class="line-modified">!                  * are the fourcc, next 40 bytes are BITMAPINFOHEADER,</span>
<span class="line-modified">!                  * next 1 byte is the version, and the</span>
<span class="line-modified">!                  * subsequent bytes are sequence parameter set like data. */</span>
  
                    size -= 40;   /* we&#39;ll be skipping BITMAPINFOHEADER */
<span class="line-modified">!                 if (size &gt; 1) {</span>
                      gst_codec_utils_h264_caps_set_level_and_profile
                          (entry-&gt;caps, avc_data + 8 + 40 + 1, size - 1);
  
<span class="line-modified">!                   buf = gst_buffer_new_and_alloc (size);</span>
<span class="line-modified">!                   gst_buffer_fill (buf, 0, avc_data + 8 + 40, size);</span>
                      gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                       &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">!                   gst_buffer_unref (buf);</span>
                  }
<span class="line-modified">!                 break;</span>
<span class="line-modified">!               }</span>
<span class="line-modified">!               case FOURCC_btrt:</span>
<span class="line-removed">-               {</span>
<span class="line-removed">-                 guint avg_bitrate, max_bitrate;</span>
  
<span class="line-modified">!                 /* bufferSizeDB, maxBitrate and avgBitrate - 4 bytes each */</span>
<span class="line-modified">!                 if (size &lt; 12)</span>
<span class="line-modified">!                   break;</span>
  
<span class="line-modified">!                 max_bitrate = QT_UINT32 (avc_data + 0xc);</span>
<span class="line-modified">!                 avg_bitrate = QT_UINT32 (avc_data + 0x10);</span>
  
<span class="line-modified">!                 if (!max_bitrate &amp;&amp; !avg_bitrate)</span>
<span class="line-modified">!                   break;</span>
  
<span class="line-modified">!                 /* Some muxers seem to swap the average and maximum bitrates</span>
<span class="line-modified">!                  * (I&#39;m looking at you, YouTube), so we swap for sanity. */</span>
<span class="line-modified">!                 if (max_bitrate &gt; 0 &amp;&amp; max_bitrate &lt; avg_bitrate) {</span>
<span class="line-modified">!                   guint temp = avg_bitrate;</span>
  
<span class="line-modified">!                   avg_bitrate = max_bitrate;</span>
<span class="line-modified">!                   max_bitrate = temp;</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 if (max_bitrate &gt; 0 &amp;&amp; max_bitrate &lt; G_MAXUINT32) {</span>
                      gst_tag_list_add (stream-&gt;stream_tags,
                          GST_TAG_MERGE_REPLACE, GST_TAG_MAXIMUM_BITRATE,
                          max_bitrate, NULL);
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 if (avg_bitrate &gt; 0 &amp;&amp; avg_bitrate &lt; G_MAXUINT32) {</span>
                      gst_tag_list_add (stream-&gt;stream_tags,
                          GST_TAG_MERGE_REPLACE, GST_TAG_BITRATE, avg_bitrate,
                          NULL);
                  }
  
<span class="line-modified">!                 break;</span>
                }
  
<span class="line-modified">!               default:</span>
<span class="line-modified">!                 break;</span>
              }
  
<span class="line-modified">!             len -= size + 8;</span>
<span class="line-removed">-             avc_data += size + 8;</span>
            }
<span class="line-modified">! </span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case FOURCC_H265:</span>
<span class="line-removed">-         case FOURCC_hvc1:</span>
<span class="line-removed">-         case FOURCC_hev1:</span>
<span class="line-removed">-         {</span>
              gint len = QT_UINT32 (stsd_entry_data) - 0x56;
              const guint8 *hevc_data = stsd_entry_data + 0x56;
  
<span class="line-modified">!           /* find hevc */</span>
<span class="line-modified">!           while (len &gt;= 0x8) {</span>
<span class="line-modified">!             gint size;</span>
  
<span class="line-modified">!             if (QT_UINT32 (hevc_data) &lt;= len)</span>
<span class="line-modified">!               size = QT_UINT32 (hevc_data) - 0x8;</span>
<span class="line-modified">!             else</span>
<span class="line-modified">!               size = len - 0x8;</span>
  
<span class="line-modified">!             if (size &lt; 1)</span>
<span class="line-modified">!               /* No real data, so break out */</span>
<span class="line-modified">!               break;</span>
  
<span class="line-modified">!             switch (QT_FOURCC (hevc_data + 0x4)) {</span>
<span class="line-modified">!               case FOURCC_hvcC:</span>
<span class="line-modified">!               {</span>
<span class="line-modified">!                 /* parse, if found */</span>
<span class="line-modified">!                 GstBuffer *buf;</span>
  
                    GST_DEBUG_OBJECT (qtdemux, &quot;found hvcC codec_data in stsd&quot;);
  
<span class="line-modified">!                 /* First 4 bytes are the length of the atom, the next 4 bytes</span>
<span class="line-modified">!                  * are the fourcc, the next 1 byte is the version, and the</span>
<span class="line-modified">!                  * subsequent bytes are sequence parameter set like data. */</span>
<span class="line-modified">!                 gst_codec_utils_h265_caps_set_level_tier_and_profile</span>
                        (entry-&gt;caps, hevc_data + 8 + 1, size - 1);
  
<span class="line-modified">!                 buf = gst_buffer_new_and_alloc (size);</span>
<span class="line-modified">!                 gst_buffer_fill (buf, 0, hevc_data + 0x8, size);</span>
                    gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                     &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">!                 gst_buffer_unref (buf);</span>
<span class="line-modified">!                 break;</span>
                }
<span class="line-modified">!               default:</span>
<span class="line-modified">!                 break;</span>
              }
<span class="line-modified">!             len -= size + 8;</span>
<span class="line-removed">-             hevc_data += size + 8;</span>
            }
<span class="line-modified">!           break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case FOURCC_mp4v:</span>
<span class="line-modified">!         case FOURCC_MP4V:</span>
<span class="line-removed">-         case FOURCC_fmp4:</span>
<span class="line-removed">-         case FOURCC_FMP4:</span>
            case FOURCC_xvid:
            case FOURCC_XVID:
<span class="line-modified">!         {</span>
<span class="line-modified">!           GNode *glbl;</span>
  
<span class="line-modified">!           GST_DEBUG_OBJECT (qtdemux, &quot;found %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">!               GST_FOURCC_ARGS (fourcc));</span>
  
<span class="line-modified">!           /* codec data might be in glbl extension atom */</span>
<span class="line-modified">!           glbl = mp4v ?</span>
<span class="line-modified">!               qtdemux_tree_get_child_by_type (mp4v, FOURCC_glbl) : NULL;</span>
<span class="line-modified">!           if (glbl) {</span>
<span class="line-modified">!             guint8 *data;</span>
<span class="line-modified">!             GstBuffer *buf;</span>
<span class="line-modified">!             gint len;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             GST_DEBUG_OBJECT (qtdemux, &quot;found glbl data in stsd&quot;);</span>
<span class="line-modified">!             data = glbl-&gt;data;</span>
<span class="line-modified">!             len = QT_UINT32 (data);</span>
<span class="line-modified">!             if (len &gt; 0x8) {</span>
<span class="line-modified">!               len -= 0x8;</span>
<span class="line-modified">!               buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">!               gst_buffer_fill (buf, 0, data + 8, len);</span>
                  gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                   &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">!               gst_buffer_unref (buf);</span>
              }
            }
<span class="line-modified">!           break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case FOURCC_mjp2:</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           /* see annex I of the jpeg2000 spec */</span>
<span class="line-modified">!           GNode *jp2h, *ihdr, *colr, *mjp2, *field, *prefix, *cmap, *cdef;</span>
<span class="line-modified">!           const guint8 *data;</span>
<span class="line-modified">!           const gchar *colorspace = NULL;</span>
<span class="line-modified">!           gint ncomp = 0;</span>
<span class="line-modified">!           guint32 ncomp_map = 0;</span>
<span class="line-modified">!           gint32 *comp_map = NULL;</span>
<span class="line-modified">!           guint32 nchan_def = 0;</span>
<span class="line-modified">!           gint32 *chan_def = NULL;</span>
<span class="line-modified">! </span>
<span class="line-removed">-           GST_DEBUG_OBJECT (qtdemux, &quot;found mjp2&quot;);</span>
<span class="line-removed">-           /* some required atoms */</span>
              mjp2 = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">!           if (!mjp2)</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!           jp2h = qtdemux_tree_get_child_by_type (mjp2, FOURCC_jp2h);</span>
<span class="line-modified">!           if (!jp2h)</span>
<span class="line-modified">!             break;</span>
  
<span class="line-modified">!           /* number of components; redundant with info in codestream, but useful</span>
<span class="line-modified">!              to a muxer */</span>
<span class="line-modified">!           ihdr = qtdemux_tree_get_child_by_type (jp2h, FOURCC_ihdr);</span>
<span class="line-modified">!           if (!ihdr || QT_UINT32 (ihdr-&gt;data) != 22)</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!           ncomp = QT_UINT16 (((guint8 *) ihdr-&gt;data) + 16);</span>
  
<span class="line-modified">!           colr = qtdemux_tree_get_child_by_type (jp2h, FOURCC_colr);</span>
<span class="line-modified">!           if (!colr)</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!           GST_DEBUG_OBJECT (qtdemux, &quot;found colr&quot;);</span>
<span class="line-modified">!           /* extract colour space info */</span>
<span class="line-modified">!           if (QT_UINT8 ((guint8 *) colr-&gt;data + 8) == 1) {</span>
<span class="line-modified">!             switch (QT_UINT32 ((guint8 *) colr-&gt;data + 11)) {</span>
<span class="line-modified">!               case 16:</span>
<span class="line-modified">!                 colorspace = &quot;sRGB&quot;;</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!               case 17:</span>
<span class="line-modified">!                 colorspace = &quot;GRAY&quot;;</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!               case 18:</span>
<span class="line-modified">!                 colorspace = &quot;sYUV&quot;;</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!               default:</span>
<span class="line-modified">!                 colorspace = NULL;</span>
<span class="line-modified">!                 break;</span>
              }
<span class="line-modified">!           }</span>
<span class="line-modified">!           if (!colorspace)</span>
<span class="line-modified">!             /* colr is required, and only values 16, 17, and 18 are specified,</span>
<span class="line-modified">!                so error if we have no colorspace */</span>
<span class="line-removed">-             break;</span>
  
<span class="line-modified">!           /* extract component mapping */</span>
<span class="line-modified">!           cmap = qtdemux_tree_get_child_by_type (jp2h, FOURCC_cmap);</span>
<span class="line-modified">!           if (cmap) {</span>
<span class="line-modified">!             guint32 cmap_len = 0;</span>
<span class="line-modified">!             int i;</span>
<span class="line-modified">!             cmap_len = QT_UINT32 (cmap-&gt;data);</span>
<span class="line-modified">!             if (cmap_len &gt;= 8) {</span>
<span class="line-modified">!               /* normal box, subtract off header */</span>
<span class="line-modified">!               cmap_len -= 8;</span>
<span class="line-modified">!               /* cmap: { u16 cmp; u8 mtyp; u8 pcol; }* */</span>
<span class="line-modified">!               if (cmap_len % 4 == 0) {</span>
<span class="line-modified">!                 ncomp_map = (cmap_len / 4);</span>
<span class="line-modified">!                 comp_map = g_new0 (gint32, ncomp_map);</span>
<span class="line-modified">!                 for (i = 0; i &lt; ncomp_map; i++) {</span>
<span class="line-modified">!                   guint16 cmp;</span>
<span class="line-modified">!                   guint8 mtyp, pcol;</span>
<span class="line-modified">!                   cmp = QT_UINT16 (((guint8 *) cmap-&gt;data) + 8 + i * 4);</span>
<span class="line-modified">!                   mtyp = QT_UINT8 (((guint8 *) cmap-&gt;data) + 8 + i * 4 + 2);</span>
<span class="line-modified">!                   pcol = QT_UINT8 (((guint8 *) cmap-&gt;data) + 8 + i * 4 + 3);</span>
<span class="line-modified">!                   comp_map[i] = (mtyp &lt;&lt; 24) | (pcol &lt;&lt; 16) | cmp;</span>
                  }
                }
              }
<span class="line-modified">!           }</span>
<span class="line-modified">!           /* extract channel definitions */</span>
<span class="line-modified">!           cdef = qtdemux_tree_get_child_by_type (jp2h, FOURCC_cdef);</span>
<span class="line-modified">!           if (cdef) {</span>
<span class="line-modified">!             guint32 cdef_len = 0;</span>
<span class="line-modified">!             int i;</span>
<span class="line-modified">!             cdef_len = QT_UINT32 (cdef-&gt;data);</span>
<span class="line-modified">!             if (cdef_len &gt;= 10) {</span>
<span class="line-modified">!               /* normal box, subtract off header and len */</span>
<span class="line-modified">!               cdef_len -= 10;</span>
<span class="line-modified">!               /* cdef: u16 n; { u16 cn; u16 typ; u16 asoc; }* */</span>
<span class="line-modified">!               if (cdef_len % 6 == 0) {</span>
<span class="line-modified">!                 nchan_def = (cdef_len / 6);</span>
<span class="line-modified">!                 chan_def = g_new0 (gint32, nchan_def);</span>
<span class="line-modified">!                 for (i = 0; i &lt; nchan_def; i++)</span>
<span class="line-modified">!                   chan_def[i] = -1;</span>
<span class="line-modified">!                 for (i = 0; i &lt; nchan_def; i++) {</span>
<span class="line-modified">!                   guint16 cn, typ, asoc;</span>
<span class="line-modified">!                   cn = QT_UINT16 (((guint8 *) cdef-&gt;data) + 10 + i * 6);</span>
<span class="line-modified">!                   typ = QT_UINT16 (((guint8 *) cdef-&gt;data) + 10 + i * 6 + 2);</span>
<span class="line-modified">!                   asoc = QT_UINT16 (((guint8 *) cdef-&gt;data) + 10 + i * 6 + 4);</span>
<span class="line-modified">!                   if (cn &lt; nchan_def) {</span>
<span class="line-modified">!                     switch (typ) {</span>
<span class="line-modified">!                       case 0:</span>
<span class="line-modified">!                         chan_def[cn] = asoc;</span>
<span class="line-modified">!                         break;</span>
<span class="line-removed">-                       case 1:</span>
                            chan_def[cn] = 0;     /* alpha */
<span class="line-modified">!                         break;</span>
<span class="line-modified">!                       default:</span>
<span class="line-modified">!                         chan_def[cn] = -typ;</span>
                      }
                    }
                  }
                }
              }
<span class="line-removed">-           }</span>
  
              gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!               &quot;num-components&quot;, G_TYPE_INT, ncomp, NULL);</span>
              gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!               &quot;colorspace&quot;, G_TYPE_STRING, colorspace, NULL);</span>
<span class="line-modified">! </span>
<span class="line-modified">!           if (comp_map) {</span>
<span class="line-modified">!             GValue arr = { 0, };</span>
<span class="line-modified">!             GValue elt = { 0, };</span>
<span class="line-modified">!             int i;</span>
<span class="line-modified">!             g_value_init (&amp;arr, GST_TYPE_ARRAY);</span>
<span class="line-modified">!             g_value_init (&amp;elt, G_TYPE_INT);</span>
<span class="line-modified">!             for (i = 0; i &lt; ncomp_map; i++) {</span>
<span class="line-modified">!               g_value_set_int (&amp;elt, comp_map[i]);</span>
<span class="line-modified">!               gst_value_array_append_value (&amp;arr, &amp;elt);</span>
<span class="line-modified">!             }</span>
                gst_structure_set_value (gst_caps_get_structure (entry-&gt;caps, 0),
<span class="line-modified">!                 &quot;component-map&quot;, &amp;arr);</span>
<span class="line-modified">!             g_value_unset (&amp;elt);</span>
<span class="line-modified">!             g_value_unset (&amp;arr);</span>
<span class="line-modified">!             g_free (comp_map);</span>
<span class="line-removed">-           }</span>
<span class="line-removed">- </span>
<span class="line-removed">-           if (chan_def) {</span>
<span class="line-removed">-             GValue arr = { 0, };</span>
<span class="line-removed">-             GValue elt = { 0, };</span>
<span class="line-removed">-             int i;</span>
<span class="line-removed">-             g_value_init (&amp;arr, GST_TYPE_ARRAY);</span>
<span class="line-removed">-             g_value_init (&amp;elt, G_TYPE_INT);</span>
<span class="line-removed">-             for (i = 0; i &lt; nchan_def; i++) {</span>
<span class="line-removed">-               g_value_set_int (&amp;elt, chan_def[i]);</span>
<span class="line-removed">-               gst_value_array_append_value (&amp;arr, &amp;elt);</span>
              }
                gst_structure_set_value (gst_caps_get_structure (entry-&gt;caps, 0),
<span class="line-modified">!                 &quot;channel-definitions&quot;, &amp;arr);</span>
<span class="line-modified">!             g_value_unset (&amp;elt);</span>
<span class="line-modified">!             g_value_unset (&amp;arr);</span>
<span class="line-modified">!             g_free (chan_def);</span>
<span class="line-modified">!           }</span>
  
<span class="line-modified">!           /* some optional atoms */</span>
<span class="line-modified">!           field = qtdemux_tree_get_child_by_type (mjp2, FOURCC_fiel);</span>
<span class="line-modified">!           prefix = qtdemux_tree_get_child_by_type (mjp2, FOURCC_jp2x);</span>
  
<span class="line-modified">!           /* indicate possible fields in caps */</span>
<span class="line-modified">!           if (field) {</span>
<span class="line-modified">!             data = (guint8 *) field-&gt;data + 8;</span>
<span class="line-modified">!             if (*data != 1)</span>
                  gst_caps_set_simple (entry-&gt;caps, &quot;fields&quot;, G_TYPE_INT,
<span class="line-modified">!                   (gint) * data, NULL);</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!           /* add codec_data if provided */</span>
<span class="line-modified">!           if (prefix) {</span>
<span class="line-modified">!             GstBuffer *buf;</span>
<span class="line-modified">!             gint len;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             GST_DEBUG_OBJECT (qtdemux, &quot;found prefix data in stsd&quot;);</span>
<span class="line-modified">!             data = prefix-&gt;data;</span>
<span class="line-modified">!             len = QT_UINT32 (data);</span>
<span class="line-modified">!             if (len &gt; 0x8) {</span>
<span class="line-modified">!               len -= 0x8;</span>
<span class="line-modified">!               buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">!               gst_buffer_fill (buf, 0, data + 8, len);</span>
                  gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                   &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">!               gst_buffer_unref (buf);</span>
              }
            }
<span class="line-modified">!           break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case FOURCC_SVQ3:</span>
<span class="line-modified">!         case FOURCC_VP31:</span>
<span class="line-modified">!         {</span>
<span class="line-removed">-           GstBuffer *buf;</span>
<span class="line-removed">-           GstBuffer *seqh = NULL;</span>
              const guint8 *gamma_data = NULL;
              gint len = QT_UINT32 (stsd_data);   /* FIXME review - why put the whole stsd in codec data? */
  
              qtdemux_parse_svq3_stsd_data (qtdemux, stsd_entry_data, &amp;gamma_data,
                  &amp;seqh);
<span class="line-modified">!           if (gamma_data) {</span>
                gst_caps_set_simple (entry-&gt;caps, &quot;applied-gamma&quot;, G_TYPE_DOUBLE,
<span class="line-modified">!                 QT_FP32 (gamma_data), NULL);</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!           if (seqh) {</span>
<span class="line-modified">!             /* sorry for the bad name, but we don&#39;t know what this is, other</span>
<span class="line-modified">!              * than its own fourcc */</span>
                gst_caps_set_simple (entry-&gt;caps, &quot;seqh&quot;, GST_TYPE_BUFFER, seqh,
<span class="line-modified">!                 NULL);</span>
                gst_buffer_unref (seqh);
<span class="line-modified">!           }</span>
  
<span class="line-modified">!           GST_DEBUG_OBJECT (qtdemux, &quot;found codec_data in stsd&quot;);</span>
<span class="line-modified">!           buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">!           gst_buffer_fill (buf, 0, stsd_data, len);</span>
              gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!               &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">!           gst_buffer_unref (buf);</span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!         }</span>
            case FOURCC_jpeg:
            {
              /* https://developer.apple.com/standards/qtff-2001.pdf,
               * page 92, &quot;Video Sample Description&quot;, under table 3.1 */
              GstByteReader br;
<span class="line-new-header">--- 11049,430 ---</span>
          } else {
            GST_WARNING_OBJECT (qtdemux, &quot;Invalid colr atom size&quot;);
          }
        }
  
<span class="line-modified">!       if (esds) {</span>
  #ifdef GSTREAMER_LITE
          if (!gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
                                        stream-&gt;stream_tags))
              goto corrupt_file;
  #else
          gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
              stream-&gt;stream_tags);
  #endif // GSTREAMER_LITE
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         switch (fourcc) {</span>
<span class="line-modified">!           case FOURCC_H264:</span>
<span class="line-modified">!           case FOURCC_avc1:</span>
<span class="line-modified">!           case FOURCC_avc3:</span>
<span class="line-modified">!           {</span>
              gint len = QT_UINT32 (stsd_entry_data) - 0x56;
              const guint8 *avc_data = stsd_entry_data + 0x56;
  
<span class="line-modified">!             /* find avcC */</span>
<span class="line-modified">!             while (len &gt;= 0x8) {</span>
<span class="line-modified">!               gint size;</span>
  
<span class="line-modified">!               if (QT_UINT32 (avc_data) &lt;= len)</span>
<span class="line-modified">!                 size = QT_UINT32 (avc_data) - 0x8;</span>
<span class="line-modified">!               else</span>
<span class="line-modified">!                 size = len - 0x8;</span>
  
<span class="line-modified">!               if (size &lt; 1)</span>
<span class="line-modified">!                 /* No real data, so break out */</span>
<span class="line-modified">!                 break;</span>
  
<span class="line-modified">!               switch (QT_FOURCC (avc_data + 0x4)) {</span>
<span class="line-modified">!                 case FOURCC_avcC:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                   /* parse, if found */</span>
<span class="line-modified">!                   GstBuffer *buf;</span>
  
<span class="line-modified">!                   GST_DEBUG_OBJECT (qtdemux, &quot;found avcC codec_data in stsd&quot;);</span>
  
<span class="line-modified">!                   /* First 4 bytes are the length of the atom, the next 4 bytes</span>
<span class="line-modified">!                    * are the fourcc, the next 1 byte is the version, and the</span>
<span class="line-modified">!                    * subsequent bytes are profile_tier_level structure like data. */</span>
                    gst_codec_utils_h264_caps_set_level_and_profile (entry-&gt;caps,
<span class="line-modified">!                       avc_data + 8 + 1, size - 1);</span>
<span class="line-modified">!                   buf = gst_buffer_new_and_alloc (size);</span>
<span class="line-modified">!                   gst_buffer_fill (buf, 0, avc_data + 0x8, size);</span>
                    gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                       &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">!                   gst_buffer_unref (buf);</span>
  
<span class="line-modified">!                   break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 case FOURCC_strf:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                   GstBuffer *buf;</span>
  
<span class="line-modified">!                   GST_DEBUG_OBJECT (qtdemux, &quot;found strf codec_data in stsd&quot;);</span>
  
<span class="line-modified">!                   /* First 4 bytes are the length of the atom, the next 4 bytes</span>
<span class="line-modified">!                    * are the fourcc, next 40 bytes are BITMAPINFOHEADER,</span>
<span class="line-modified">!                    * next 1 byte is the version, and the</span>
<span class="line-modified">!                    * subsequent bytes are sequence parameter set like data. */</span>
  
                    size -= 40;   /* we&#39;ll be skipping BITMAPINFOHEADER */
<span class="line-modified">!                   if (size &gt; 1) {</span>
                      gst_codec_utils_h264_caps_set_level_and_profile
                          (entry-&gt;caps, avc_data + 8 + 40 + 1, size - 1);
  
<span class="line-modified">!                     buf = gst_buffer_new_and_alloc (size);</span>
<span class="line-modified">!                     gst_buffer_fill (buf, 0, avc_data + 8 + 40, size);</span>
                      gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                         &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">!                     gst_buffer_unref (buf);</span>
<span class="line-added">+                   }</span>
<span class="line-added">+                   break;</span>
                  }
<span class="line-modified">!                 case FOURCC_btrt:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                   guint avg_bitrate, max_bitrate;</span>
  
<span class="line-modified">!                   /* bufferSizeDB, maxBitrate and avgBitrate - 4 bytes each */</span>
<span class="line-modified">!                   if (size &lt; 12)</span>
<span class="line-modified">!                     break;</span>
  
<span class="line-modified">!                   max_bitrate = QT_UINT32 (avc_data + 0xc);</span>
<span class="line-modified">!                   avg_bitrate = QT_UINT32 (avc_data + 0x10);</span>
  
<span class="line-modified">!                   if (!max_bitrate &amp;&amp; !avg_bitrate)</span>
<span class="line-modified">!                     break;</span>
  
<span class="line-modified">!                   /* Some muxers seem to swap the average and maximum bitrates</span>
<span class="line-modified">!                    * (I&#39;m looking at you, YouTube), so we swap for sanity. */</span>
<span class="line-modified">!                   if (max_bitrate &gt; 0 &amp;&amp; max_bitrate &lt; avg_bitrate) {</span>
<span class="line-modified">!                     guint temp = avg_bitrate;</span>
  
<span class="line-modified">!                     avg_bitrate = max_bitrate;</span>
<span class="line-modified">!                     max_bitrate = temp;</span>
<span class="line-modified">!                   }</span>
  
<span class="line-modified">!                   if (max_bitrate &gt; 0 &amp;&amp; max_bitrate &lt; G_MAXUINT32) {</span>
                      gst_tag_list_add (stream-&gt;stream_tags,
                          GST_TAG_MERGE_REPLACE, GST_TAG_MAXIMUM_BITRATE,
                          max_bitrate, NULL);
<span class="line-modified">!                   }</span>
<span class="line-modified">!                   if (avg_bitrate &gt; 0 &amp;&amp; avg_bitrate &lt; G_MAXUINT32) {</span>
                      gst_tag_list_add (stream-&gt;stream_tags,
                          GST_TAG_MERGE_REPLACE, GST_TAG_BITRATE, avg_bitrate,
                          NULL);
<span class="line-added">+                   }</span>
<span class="line-added">+ </span>
<span class="line-added">+                   break;</span>
                  }
  
<span class="line-modified">!                 default:</span>
<span class="line-added">+                   break;</span>
                }
  
<span class="line-modified">!               len -= size + 8;</span>
<span class="line-modified">!               avc_data += size + 8;</span>
              }
  
<span class="line-modified">!             break;</span>
            }
<span class="line-modified">!           case FOURCC_H265:</span>
<span class="line-modified">!           case FOURCC_hvc1:</span>
<span class="line-modified">!           case FOURCC_hev1:</span>
<span class="line-modified">!           {</span>
              gint len = QT_UINT32 (stsd_entry_data) - 0x56;
              const guint8 *hevc_data = stsd_entry_data + 0x56;
  
<span class="line-modified">!             /* find hevc */</span>
<span class="line-modified">!             while (len &gt;= 0x8) {</span>
<span class="line-modified">!               gint size;</span>
  
<span class="line-modified">!               if (QT_UINT32 (hevc_data) &lt;= len)</span>
<span class="line-modified">!                 size = QT_UINT32 (hevc_data) - 0x8;</span>
<span class="line-modified">!               else</span>
<span class="line-modified">!                 size = len - 0x8;</span>
  
<span class="line-modified">!               if (size &lt; 1)</span>
<span class="line-modified">!                 /* No real data, so break out */</span>
<span class="line-modified">!                 break;</span>
  
<span class="line-modified">!               switch (QT_FOURCC (hevc_data + 0x4)) {</span>
<span class="line-modified">!                 case FOURCC_hvcC:</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                   /* parse, if found */</span>
<span class="line-modified">!                   GstBuffer *buf;</span>
  
                    GST_DEBUG_OBJECT (qtdemux, &quot;found hvcC codec_data in stsd&quot;);
  
<span class="line-modified">!                   /* First 4 bytes are the length of the atom, the next 4 bytes</span>
<span class="line-modified">!                    * are the fourcc, the next 1 byte is the version, and the</span>
<span class="line-modified">!                    * subsequent bytes are sequence parameter set like data. */</span>
<span class="line-modified">!                   gst_codec_utils_h265_caps_set_level_tier_and_profile</span>
                        (entry-&gt;caps, hevc_data + 8 + 1, size - 1);
  
<span class="line-modified">!                   buf = gst_buffer_new_and_alloc (size);</span>
<span class="line-modified">!                   gst_buffer_fill (buf, 0, hevc_data + 0x8, size);</span>
                    gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                       &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">!                   gst_buffer_unref (buf);</span>
<span class="line-modified">!                   break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 default:</span>
<span class="line-added">+                   break;</span>
                }
<span class="line-modified">!               len -= size + 8;</span>
<span class="line-modified">!               hevc_data += size + 8;</span>
              }
<span class="line-modified">!             break;</span>
            }
<span class="line-modified">!           case FOURCC_mp4v:</span>
<span class="line-modified">!           case FOURCC_MP4V:</span>
<span class="line-modified">!           case FOURCC_fmp4:</span>
<span class="line-modified">!           case FOURCC_FMP4:</span>
            case FOURCC_xvid:
            case FOURCC_XVID:
<span class="line-modified">!           {</span>
<span class="line-modified">!             GNode *glbl;</span>
  
<span class="line-modified">!             GST_DEBUG_OBJECT (qtdemux, &quot;found %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">!                 GST_FOURCC_ARGS (fourcc));</span>
  
<span class="line-modified">!             /* codec data might be in glbl extension atom */</span>
<span class="line-modified">!             glbl = mp4v ?</span>
<span class="line-modified">!                 qtdemux_tree_get_child_by_type (mp4v, FOURCC_glbl) : NULL;</span>
<span class="line-modified">!             if (glbl) {</span>
<span class="line-modified">!               guint8 *data;</span>
<span class="line-modified">!               GstBuffer *buf;</span>
<span class="line-modified">!               gint len;</span>
<span class="line-modified">! </span>
<span class="line-modified">!               GST_DEBUG_OBJECT (qtdemux, &quot;found glbl data in stsd&quot;);</span>
<span class="line-modified">!               data = glbl-&gt;data;</span>
<span class="line-modified">!               len = QT_UINT32 (data);</span>
<span class="line-modified">!               if (len &gt; 0x8) {</span>
<span class="line-modified">!                 len -= 0x8;</span>
<span class="line-modified">!                 buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">!                 gst_buffer_fill (buf, 0, data + 8, len);</span>
                  gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                     &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">!                 gst_buffer_unref (buf);</span>
<span class="line-added">+               }</span>
              }
<span class="line-added">+             break;</span>
            }
<span class="line-modified">!           case FOURCC_mjp2:</span>
<span class="line-modified">!           {</span>
<span class="line-modified">!             /* see annex I of the jpeg2000 spec */</span>
<span class="line-modified">!             GNode *jp2h, *ihdr, *colr, *mjp2, *field, *prefix, *cmap, *cdef;</span>
<span class="line-modified">!             const guint8 *data;</span>
<span class="line-modified">!             const gchar *colorspace = NULL;</span>
<span class="line-modified">!             gint ncomp = 0;</span>
<span class="line-modified">!             guint32 ncomp_map = 0;</span>
<span class="line-modified">!             gint32 *comp_map = NULL;</span>
<span class="line-modified">!             guint32 nchan_def = 0;</span>
<span class="line-modified">!             gint32 *chan_def = NULL;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             GST_DEBUG_OBJECT (qtdemux, &quot;found mjp2&quot;);</span>
<span class="line-modified">!             /* some required atoms */</span>
              mjp2 = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">!             if (!mjp2)</span>
<span class="line-modified">!               break;</span>
<span class="line-modified">!             jp2h = qtdemux_tree_get_child_by_type (mjp2, FOURCC_jp2h);</span>
<span class="line-modified">!             if (!jp2h)</span>
<span class="line-modified">!               break;</span>
  
<span class="line-modified">!             /* number of components; redundant with info in codestream, but useful</span>
<span class="line-modified">!                to a muxer */</span>
<span class="line-modified">!             ihdr = qtdemux_tree_get_child_by_type (jp2h, FOURCC_ihdr);</span>
<span class="line-modified">!             if (!ihdr || QT_UINT32 (ihdr-&gt;data) != 22)</span>
<span class="line-modified">!               break;</span>
<span class="line-modified">!             ncomp = QT_UINT16 (((guint8 *) ihdr-&gt;data) + 16);</span>
  
<span class="line-modified">!             colr = qtdemux_tree_get_child_by_type (jp2h, FOURCC_colr);</span>
<span class="line-modified">!             if (!colr)</span>
<span class="line-modified">!               break;</span>
<span class="line-modified">!             GST_DEBUG_OBJECT (qtdemux, &quot;found colr&quot;);</span>
<span class="line-modified">!             /* extract colour space info */</span>
<span class="line-modified">!             if (QT_UINT8 ((guint8 *) colr-&gt;data + 8) == 1) {</span>
<span class="line-modified">!               switch (QT_UINT32 ((guint8 *) colr-&gt;data + 11)) {</span>
<span class="line-modified">!                 case 16:</span>
<span class="line-modified">!                   colorspace = &quot;sRGB&quot;;</span>
<span class="line-modified">!                   break;</span>
<span class="line-modified">!                 case 17:</span>
<span class="line-modified">!                   colorspace = &quot;GRAY&quot;;</span>
<span class="line-modified">!                   break;</span>
<span class="line-modified">!                 case 18:</span>
<span class="line-modified">!                   colorspace = &quot;sYUV&quot;;</span>
<span class="line-modified">!                   break;</span>
<span class="line-modified">!                 default:</span>
<span class="line-modified">!                   colorspace = NULL;</span>
<span class="line-modified">!                   break;</span>
<span class="line-added">+               }</span>
              }
<span class="line-modified">!             if (!colorspace)</span>
<span class="line-modified">!               /* colr is required, and only values 16, 17, and 18 are specified,</span>
<span class="line-modified">!                  so error if we have no colorspace */</span>
<span class="line-modified">!               break;</span>
  
<span class="line-modified">!             /* extract component mapping */</span>
<span class="line-modified">!             cmap = qtdemux_tree_get_child_by_type (jp2h, FOURCC_cmap);</span>
<span class="line-modified">!             if (cmap) {</span>
<span class="line-modified">!               guint32 cmap_len = 0;</span>
<span class="line-modified">!               int i;</span>
<span class="line-modified">!               cmap_len = QT_UINT32 (cmap-&gt;data);</span>
<span class="line-modified">!               if (cmap_len &gt;= 8) {</span>
<span class="line-modified">!                 /* normal box, subtract off header */</span>
<span class="line-modified">!                 cmap_len -= 8;</span>
<span class="line-modified">!                 /* cmap: { u16 cmp; u8 mtyp; u8 pcol; }* */</span>
<span class="line-modified">!                 if (cmap_len % 4 == 0) {</span>
<span class="line-modified">!                   ncomp_map = (cmap_len / 4);</span>
<span class="line-modified">!                   comp_map = g_new0 (gint32, ncomp_map);</span>
<span class="line-modified">!                   for (i = 0; i &lt; ncomp_map; i++) {</span>
<span class="line-modified">!                     guint16 cmp;</span>
<span class="line-modified">!                     guint8 mtyp, pcol;</span>
<span class="line-modified">!                     cmp = QT_UINT16 (((guint8 *) cmap-&gt;data) + 8 + i * 4);</span>
<span class="line-modified">!                     mtyp = QT_UINT8 (((guint8 *) cmap-&gt;data) + 8 + i * 4 + 2);</span>
<span class="line-modified">!                     pcol = QT_UINT8 (((guint8 *) cmap-&gt;data) + 8 + i * 4 + 3);</span>
<span class="line-modified">!                     comp_map[i] = (mtyp &lt;&lt; 24) | (pcol &lt;&lt; 16) | cmp;</span>
<span class="line-added">+                   }</span>
                  }
                }
              }
<span class="line-modified">!             /* extract channel definitions */</span>
<span class="line-modified">!             cdef = qtdemux_tree_get_child_by_type (jp2h, FOURCC_cdef);</span>
<span class="line-modified">!             if (cdef) {</span>
<span class="line-modified">!               guint32 cdef_len = 0;</span>
<span class="line-modified">!               int i;</span>
<span class="line-modified">!               cdef_len = QT_UINT32 (cdef-&gt;data);</span>
<span class="line-modified">!               if (cdef_len &gt;= 10) {</span>
<span class="line-modified">!                 /* normal box, subtract off header and len */</span>
<span class="line-modified">!                 cdef_len -= 10;</span>
<span class="line-modified">!                 /* cdef: u16 n; { u16 cn; u16 typ; u16 asoc; }* */</span>
<span class="line-modified">!                 if (cdef_len % 6 == 0) {</span>
<span class="line-modified">!                   nchan_def = (cdef_len / 6);</span>
<span class="line-modified">!                   chan_def = g_new0 (gint32, nchan_def);</span>
<span class="line-modified">!                   for (i = 0; i &lt; nchan_def; i++)</span>
<span class="line-modified">!                     chan_def[i] = -1;</span>
<span class="line-modified">!                   for (i = 0; i &lt; nchan_def; i++) {</span>
<span class="line-modified">!                     guint16 cn, typ, asoc;</span>
<span class="line-modified">!                     cn = QT_UINT16 (((guint8 *) cdef-&gt;data) + 10 + i * 6);</span>
<span class="line-modified">!                     typ = QT_UINT16 (((guint8 *) cdef-&gt;data) + 10 + i * 6 + 2);</span>
<span class="line-modified">!                     asoc = QT_UINT16 (((guint8 *) cdef-&gt;data) + 10 + i * 6 + 4);</span>
<span class="line-modified">!                     if (cn &lt; nchan_def) {</span>
<span class="line-modified">!                       switch (typ) {</span>
<span class="line-modified">!                         case 0:</span>
<span class="line-modified">!                           chan_def[cn] = asoc;</span>
<span class="line-modified">!                           break;</span>
<span class="line-modified">!                         case 1:</span>
                            chan_def[cn] = 0;     /* alpha */
<span class="line-modified">!                           break;</span>
<span class="line-modified">!                         default:</span>
<span class="line-modified">!                           chan_def[cn] = -typ;</span>
<span class="line-added">+                       }</span>
                      }
                    }
                  }
                }
              }
  
              gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                 &quot;num-components&quot;, G_TYPE_INT, ncomp, NULL);</span>
              gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                 &quot;colorspace&quot;, G_TYPE_STRING, colorspace, NULL);</span>
<span class="line-modified">! </span>
<span class="line-modified">!             if (comp_map) {</span>
<span class="line-modified">!               GValue arr = { 0, };</span>
<span class="line-modified">!               GValue elt = { 0, };</span>
<span class="line-modified">!               int i;</span>
<span class="line-modified">!               g_value_init (&amp;arr, GST_TYPE_ARRAY);</span>
<span class="line-modified">!               g_value_init (&amp;elt, G_TYPE_INT);</span>
<span class="line-modified">!               for (i = 0; i &lt; ncomp_map; i++) {</span>
<span class="line-modified">!                 g_value_set_int (&amp;elt, comp_map[i]);</span>
<span class="line-modified">!                 gst_value_array_append_value (&amp;arr, &amp;elt);</span>
<span class="line-modified">!               }</span>
                gst_structure_set_value (gst_caps_get_structure (entry-&gt;caps, 0),
<span class="line-modified">!                   &quot;component-map&quot;, &amp;arr);</span>
<span class="line-modified">!               g_value_unset (&amp;elt);</span>
<span class="line-modified">!               g_value_unset (&amp;arr);</span>
<span class="line-modified">!               g_free (comp_map);</span>
              }
<span class="line-added">+ </span>
<span class="line-added">+             if (chan_def) {</span>
<span class="line-added">+               GValue arr = { 0, };</span>
<span class="line-added">+               GValue elt = { 0, };</span>
<span class="line-added">+               int i;</span>
<span class="line-added">+               g_value_init (&amp;arr, GST_TYPE_ARRAY);</span>
<span class="line-added">+               g_value_init (&amp;elt, G_TYPE_INT);</span>
<span class="line-added">+               for (i = 0; i &lt; nchan_def; i++) {</span>
<span class="line-added">+                 g_value_set_int (&amp;elt, chan_def[i]);</span>
<span class="line-added">+                 gst_value_array_append_value (&amp;arr, &amp;elt);</span>
<span class="line-added">+               }</span>
                gst_structure_set_value (gst_caps_get_structure (entry-&gt;caps, 0),
<span class="line-modified">!                   &quot;channel-definitions&quot;, &amp;arr);</span>
<span class="line-modified">!               g_value_unset (&amp;elt);</span>
<span class="line-modified">!               g_value_unset (&amp;arr);</span>
<span class="line-modified">!               g_free (chan_def);</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             /* some optional atoms */</span>
<span class="line-modified">!             field = qtdemux_tree_get_child_by_type (mjp2, FOURCC_fiel);</span>
<span class="line-modified">!             prefix = qtdemux_tree_get_child_by_type (mjp2, FOURCC_jp2x);</span>
  
<span class="line-modified">!             /* indicate possible fields in caps */</span>
<span class="line-modified">!             if (field) {</span>
<span class="line-modified">!               data = (guint8 *) field-&gt;data + 8;</span>
<span class="line-modified">!               if (*data != 1)</span>
                  gst_caps_set_simple (entry-&gt;caps, &quot;fields&quot;, G_TYPE_INT,
<span class="line-modified">!                     (gint) * data, NULL);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             /* add codec_data if provided */</span>
<span class="line-modified">!             if (prefix) {</span>
<span class="line-modified">!               GstBuffer *buf;</span>
<span class="line-modified">!               gint len;</span>
<span class="line-modified">! </span>
<span class="line-modified">!               GST_DEBUG_OBJECT (qtdemux, &quot;found prefix data in stsd&quot;);</span>
<span class="line-modified">!               data = prefix-&gt;data;</span>
<span class="line-modified">!               len = QT_UINT32 (data);</span>
<span class="line-modified">!               if (len &gt; 0x8) {</span>
<span class="line-modified">!                 len -= 0x8;</span>
<span class="line-modified">!                 buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">!                 gst_buffer_fill (buf, 0, data + 8, len);</span>
                  gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                     &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">!                 gst_buffer_unref (buf);</span>
<span class="line-added">+               }</span>
              }
<span class="line-added">+             break;</span>
            }
<span class="line-modified">!           case FOURCC_SVQ3:</span>
<span class="line-modified">!           case FOURCC_VP31:</span>
<span class="line-modified">!           {</span>
<span class="line-modified">!             GstBuffer *buf;</span>
<span class="line-modified">!             GstBuffer *seqh = NULL;</span>
              const guint8 *gamma_data = NULL;
              gint len = QT_UINT32 (stsd_data);   /* FIXME review - why put the whole stsd in codec data? */
  
              qtdemux_parse_svq3_stsd_data (qtdemux, stsd_entry_data, &amp;gamma_data,
                  &amp;seqh);
<span class="line-modified">!             if (gamma_data) {</span>
                gst_caps_set_simple (entry-&gt;caps, &quot;applied-gamma&quot;, G_TYPE_DOUBLE,
<span class="line-modified">!                   QT_FP32 (gamma_data), NULL);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             if (seqh) {</span>
<span class="line-modified">!               /* sorry for the bad name, but we don&#39;t know what this is, other</span>
<span class="line-modified">!                * than its own fourcc */</span>
                gst_caps_set_simple (entry-&gt;caps, &quot;seqh&quot;, GST_TYPE_BUFFER, seqh,
<span class="line-modified">!                   NULL);</span>
                gst_buffer_unref (seqh);
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             GST_DEBUG_OBJECT (qtdemux, &quot;found codec_data in stsd&quot;);</span>
<span class="line-modified">!             buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">!             gst_buffer_fill (buf, 0, stsd_data, len);</span>
              gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                 &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">!             gst_buffer_unref (buf);</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!           }</span>
            case FOURCC_jpeg:
            {
              /* https://developer.apple.com/standards/qtff-2001.pdf,
               * page 92, &quot;Video Sample Description&quot;, under table 3.1 */
              GstByteReader br;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10778,61 ***</span>
                    &quot;Length of jpeg chunk is too small, not trying to get interlacedness&quot;);
              }
  
              break;
            }
<span class="line-modified">!         case FOURCC_rle_:</span>
<span class="line-modified">!         case FOURCC_WRLE:</span>
<span class="line-modified">!         {</span>
              gst_caps_set_simple (entry-&gt;caps,
                  &quot;depth&quot;, G_TYPE_INT, QT_UINT16 (stsd_entry_data + offset + 66),
                  NULL);
<span class="line-modified">!           break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case FOURCC_XiTh:</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           GNode *xith, *xdxt;</span>
  
<span class="line-modified">!           GST_DEBUG_OBJECT (qtdemux, &quot;found XiTh&quot;);</span>
              xith = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">!           if (!xith)</span>
<span class="line-modified">!             break;</span>
  
<span class="line-modified">!           xdxt = qtdemux_tree_get_child_by_type (xith, FOURCC_XdxT);</span>
<span class="line-modified">!           if (!xdxt)</span>
<span class="line-modified">!             break;</span>
  
<span class="line-modified">!           GST_DEBUG_OBJECT (qtdemux, &quot;found XdxT node&quot;);</span>
<span class="line-modified">!           /* collect the headers and store them in a stream list so that we can</span>
<span class="line-modified">!            * send them out first */</span>
<span class="line-modified">!           qtdemux_parse_theora_extension (qtdemux, stream, xdxt);</span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case FOURCC_ovc1:</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           GNode *ovc1;</span>
<span class="line-modified">!           guint8 *ovc1_data;</span>
<span class="line-modified">!           guint ovc1_len;</span>
<span class="line-modified">!           GstBuffer *buf;</span>
  
<span class="line-modified">!           GST_DEBUG_OBJECT (qtdemux, &quot;parse ovc1 header&quot;);</span>
              ovc1 = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">!           if (!ovc1)</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!           ovc1_data = ovc1-&gt;data;</span>
<span class="line-modified">!           ovc1_len = QT_UINT32 (ovc1_data);</span>
<span class="line-modified">!           if (ovc1_len &lt;= 198) {</span>
<span class="line-modified">!             GST_WARNING_OBJECT (qtdemux, &quot;Too small ovc1 header, skipping&quot;);</span>
              break;
            }
<span class="line-removed">-           buf = gst_buffer_new_and_alloc (ovc1_len - 198);</span>
<span class="line-removed">-           gst_buffer_fill (buf, 0, ovc1_data + 198, ovc1_len - 198);</span>
<span class="line-removed">-             gst_caps_set_simple (entry-&gt;caps,</span>
<span class="line-removed">-               &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-removed">-           gst_buffer_unref (buf);</span>
<span class="line-removed">-           break;</span>
<span class="line-removed">-         }</span>
            case FOURCC_vc_1:
            {
              gint len = QT_UINT32 (stsd_entry_data) - 0x56;
              const guint8 *vc1_data = stsd_entry_data + 0x56;
  
<span class="line-new-header">--- 11544,61 ---</span>
                    &quot;Length of jpeg chunk is too small, not trying to get interlacedness&quot;);
              }
  
              break;
            }
<span class="line-modified">!           case FOURCC_rle_:</span>
<span class="line-modified">!           case FOURCC_WRLE:</span>
<span class="line-modified">!           {</span>
              gst_caps_set_simple (entry-&gt;caps,
                  &quot;depth&quot;, G_TYPE_INT, QT_UINT16 (stsd_entry_data + offset + 66),
                  NULL);
<span class="line-modified">!             break;</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!           case FOURCC_XiTh:</span>
<span class="line-modified">!           {</span>
<span class="line-modified">!             GNode *xith, *xdxt;</span>
  
<span class="line-modified">!             GST_DEBUG_OBJECT (qtdemux, &quot;found XiTh&quot;);</span>
              xith = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">!             if (!xith)</span>
<span class="line-modified">!               break;</span>
  
<span class="line-modified">!             xdxt = qtdemux_tree_get_child_by_type (xith, FOURCC_XdxT);</span>
<span class="line-modified">!             if (!xdxt)</span>
<span class="line-modified">!               break;</span>
  
<span class="line-modified">!             GST_DEBUG_OBJECT (qtdemux, &quot;found XdxT node&quot;);</span>
<span class="line-modified">!             /* collect the headers and store them in a stream list so that we can</span>
<span class="line-modified">!              * send them out first */</span>
<span class="line-modified">!             qtdemux_parse_theora_extension (qtdemux, stream, xdxt);</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!           case FOURCC_ovc1:</span>
<span class="line-modified">!           {</span>
<span class="line-modified">!             GNode *ovc1;</span>
<span class="line-modified">!             guint8 *ovc1_data;</span>
<span class="line-modified">!             guint ovc1_len;</span>
<span class="line-modified">!             GstBuffer *buf;</span>
  
<span class="line-modified">!             GST_DEBUG_OBJECT (qtdemux, &quot;parse ovc1 header&quot;);</span>
              ovc1 = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">!             if (!ovc1)</span>
<span class="line-modified">!               break;</span>
<span class="line-modified">!             ovc1_data = ovc1-&gt;data;</span>
<span class="line-modified">!             ovc1_len = QT_UINT32 (ovc1_data);</span>
<span class="line-modified">!             if (ovc1_len &lt;= 198) {</span>
<span class="line-modified">!               GST_WARNING_OBJECT (qtdemux, &quot;Too small ovc1 header, skipping&quot;);</span>
<span class="line-added">+               break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             buf = gst_buffer_new_and_alloc (ovc1_len - 198);</span>
<span class="line-added">+             gst_buffer_fill (buf, 0, ovc1_data + 198, ovc1_len - 198);</span>
<span class="line-added">+             gst_caps_set_simple (entry-&gt;caps,</span>
<span class="line-added">+                 &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-added">+             gst_buffer_unref (buf);</span>
              break;
            }
            case FOURCC_vc_1:
            {
              gint len = QT_UINT32 (stsd_entry_data) - 0x56;
              const guint8 *vc1_data = stsd_entry_data + 0x56;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10860,274 ***</span>
                    gst_caps_set_simple (entry-&gt;caps,
                        &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);
                    gst_buffer_unref (buf);
                    break;
                  }
<span class="line-modified">!         default:</span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!       }</span>
                len -= size + 8;
                vc1_data += size + 8;
<span class="line-modified">!     }</span>
              break;
            }
            default:
              break;
          }
        }
  
<span class="line-modified">!     GST_INFO_OBJECT (qtdemux,</span>
<span class="line-modified">!         &quot;type %&quot; GST_FOURCC_FORMAT &quot; caps %&quot; GST_PTR_FORMAT,</span>
            GST_FOURCC_ARGS (fourcc), entry-&gt;caps);
  
<span class="line-modified">!   } else if (stream-&gt;subtype == FOURCC_soun) {</span>
        GNode *wave;
<span class="line-modified">!     int version, samplesize;</span>
<span class="line-modified">!     guint16 compression_id;</span>
<span class="line-modified">!     gboolean amrwb = FALSE;</span>
  
        offset = 16;
<span class="line-modified">!     /* sample description entry (16) + sound sample description v0 (20) */</span>
<span class="line-modified">!     if (len &lt; 36)</span>
<span class="line-modified">!       goto corrupt_file;</span>
  
        version = QT_UINT32 (stsd_entry_data + offset);
        entry-&gt;n_channels = QT_UINT16 (stsd_entry_data + offset + 8);
        samplesize = QT_UINT16 (stsd_entry_data + offset + 10);
        compression_id = QT_UINT16 (stsd_entry_data + offset + 12);
        entry-&gt;rate = QT_FP32 (stsd_entry_data + offset + 16);
  
<span class="line-modified">!     GST_LOG_OBJECT (qtdemux, &quot;version/rev:      %08x&quot;, version);</span>
<span class="line-modified">!     GST_LOG_OBJECT (qtdemux, &quot;vendor:           %08x&quot;,</span>
            QT_UINT32 (stsd_entry_data + offset + 4));
        GST_LOG_OBJECT (qtdemux, &quot;n_channels:       %d&quot;, entry-&gt;n_channels);
<span class="line-modified">!     GST_LOG_OBJECT (qtdemux, &quot;sample_size:      %d&quot;, samplesize);</span>
<span class="line-modified">!     GST_LOG_OBJECT (qtdemux, &quot;compression_id:   %d&quot;, compression_id);</span>
<span class="line-modified">!     GST_LOG_OBJECT (qtdemux, &quot;packet size:      %d&quot;,</span>
            QT_UINT16 (stsd_entry_data + offset + 14));
        GST_LOG_OBJECT (qtdemux, &quot;sample rate:      %g&quot;, entry-&gt;rate);
  
<span class="line-modified">!     if (compression_id == 0xfffe)</span>
          entry-&gt;sampled = TRUE;
  
<span class="line-modified">!     /* first assume uncompressed audio */</span>
        entry-&gt;bytes_per_sample = samplesize / 8;
        entry-&gt;samples_per_frame = entry-&gt;n_channels;
        entry-&gt;bytes_per_frame = entry-&gt;n_channels * entry-&gt;bytes_per_sample;
        entry-&gt;samples_per_packet = entry-&gt;samples_per_frame;
        entry-&gt;bytes_per_packet = entry-&gt;bytes_per_sample;
  
        offset = 36;
<span class="line-modified">!     switch (fourcc) {</span>
<span class="line-modified">!         /* Yes, these have to be hard-coded */</span>
<span class="line-modified">!       case FOURCC_MAC6:</span>
<span class="line-modified">!       {</span>
            entry-&gt;samples_per_packet = 6;
            entry-&gt;bytes_per_packet = 1;
            entry-&gt;bytes_per_frame = 1 * entry-&gt;n_channels;
            entry-&gt;bytes_per_sample = 1;
            entry-&gt;samples_per_frame = 6 * entry-&gt;n_channels;
<span class="line-modified">!         break;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       case FOURCC_MAC3:</span>
<span class="line-modified">!       {</span>
            entry-&gt;samples_per_packet = 3;
            entry-&gt;bytes_per_packet = 1;
            entry-&gt;bytes_per_frame = 1 * entry-&gt;n_channels;
            entry-&gt;bytes_per_sample = 1;
            entry-&gt;samples_per_frame = 3 * entry-&gt;n_channels;
<span class="line-modified">!         break;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       case FOURCC_ima4:</span>
<span class="line-modified">!       {</span>
            entry-&gt;samples_per_packet = 64;
            entry-&gt;bytes_per_packet = 34;
            entry-&gt;bytes_per_frame = 34 * entry-&gt;n_channels;
            entry-&gt;bytes_per_sample = 2;
            entry-&gt;samples_per_frame = 64 * entry-&gt;n_channels;
<span class="line-modified">!         break;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       case FOURCC_ulaw:</span>
<span class="line-modified">!       case FOURCC_alaw:</span>
<span class="line-modified">!       {</span>
            entry-&gt;samples_per_packet = 1;
            entry-&gt;bytes_per_packet = 1;
            entry-&gt;bytes_per_frame = 1 * entry-&gt;n_channels;
            entry-&gt;bytes_per_sample = 1;
            entry-&gt;samples_per_frame = 1 * entry-&gt;n_channels;
<span class="line-modified">!         break;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       case FOURCC_agsm:</span>
<span class="line-modified">!       {</span>
            entry-&gt;samples_per_packet = 160;
            entry-&gt;bytes_per_packet = 33;
            entry-&gt;bytes_per_frame = 33 * entry-&gt;n_channels;
            entry-&gt;bytes_per_sample = 2;
            entry-&gt;samples_per_frame = 160 * entry-&gt;n_channels;
<span class="line-modified">!         break;</span>
        }
<span class="line-removed">-       default:</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     if (version == 0x00010000) {</span>
<span class="line-modified">!       /* sample description entry (16) + sound sample description v1 (20+16) */</span>
<span class="line-modified">!       if (len &lt; 52)</span>
<span class="line-modified">!         goto corrupt_file;</span>
  
<span class="line-modified">!       switch (fourcc) {</span>
<span class="line-modified">!         case FOURCC_twos:</span>
<span class="line-modified">!         case FOURCC_sowt:</span>
<span class="line-modified">!         case FOURCC_raw_:</span>
            case FOURCC_lpcm:
<span class="line-modified">!           break;</span>
<span class="line-modified">!         default:</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           /* only parse extra decoding config for non-pcm audio */</span>
              entry-&gt;samples_per_packet = QT_UINT32 (stsd_entry_data + offset);
              entry-&gt;bytes_per_packet = QT_UINT32 (stsd_entry_data + offset + 4);
              entry-&gt;bytes_per_frame = QT_UINT32 (stsd_entry_data + offset + 8);
              entry-&gt;bytes_per_sample = QT_UINT32 (stsd_entry_data + offset + 12);
  
<span class="line-modified">!           GST_LOG_OBJECT (qtdemux, &quot;samples/packet:   %d&quot;,</span>
                  entry-&gt;samples_per_packet);
<span class="line-modified">!           GST_LOG_OBJECT (qtdemux, &quot;bytes/packet:     %d&quot;,</span>
                  entry-&gt;bytes_per_packet);
<span class="line-modified">!           GST_LOG_OBJECT (qtdemux, &quot;bytes/frame:      %d&quot;,</span>
                  entry-&gt;bytes_per_frame);
<span class="line-modified">!           GST_LOG_OBJECT (qtdemux, &quot;bytes/sample:     %d&quot;,</span>
                  entry-&gt;bytes_per_sample);
  
              if (!entry-&gt;sampled &amp;&amp; entry-&gt;bytes_per_packet) {
                entry-&gt;samples_per_frame = (entry-&gt;bytes_per_frame /
                    entry-&gt;bytes_per_packet) * entry-&gt;samples_per_packet;
<span class="line-modified">!             GST_LOG_OBJECT (qtdemux, &quot;samples/frame:    %d&quot;,</span>
                    entry-&gt;samples_per_frame);
            }
<span class="line-removed">-           break;</span>
          }
<span class="line-modified">!       }</span>
<span class="line-modified">!     } else if (version == 0x00020000) {</span>
<span class="line-modified">!       union</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         gdouble fp;</span>
<span class="line-modified">!         guint64 val;</span>
<span class="line-removed">-       } qtfp;</span>
  
<span class="line-modified">!       /* sample description entry (16) + sound sample description v2 (56) */</span>
<span class="line-modified">!       if (len &lt; 72)</span>
<span class="line-modified">!         goto corrupt_file;</span>
  
          qtfp.val = QT_UINT64 (stsd_entry_data + offset + 4);
          entry-&gt;rate = qtfp.fp;
          entry-&gt;n_channels = QT_UINT32 (stsd_entry_data + offset + 12);
  
<span class="line-modified">!       GST_LOG_OBJECT (qtdemux, &quot;Sound sample description Version 2&quot;);</span>
          GST_LOG_OBJECT (qtdemux, &quot;sample rate:        %g&quot;, entry-&gt;rate);
          GST_LOG_OBJECT (qtdemux, &quot;n_channels:         %d&quot;, entry-&gt;n_channels);
<span class="line-modified">!       GST_LOG_OBJECT (qtdemux, &quot;bits/channel:       %d&quot;,</span>
              QT_UINT32 (stsd_entry_data + offset + 20));
<span class="line-modified">!       GST_LOG_OBJECT (qtdemux, &quot;format flags:       %X&quot;,</span>
              QT_UINT32 (stsd_entry_data + offset + 24));
<span class="line-modified">!       GST_LOG_OBJECT (qtdemux, &quot;bytes/packet:       %d&quot;,</span>
              QT_UINT32 (stsd_entry_data + offset + 28));
<span class="line-modified">!       GST_LOG_OBJECT (qtdemux, &quot;LPCM frames/packet: %d&quot;,</span>
              QT_UINT32 (stsd_entry_data + offset + 32));
<span class="line-modified">!     } else if (version != 0x00000) {</span>
          GST_WARNING_OBJECT (qtdemux, &quot;unknown audio STSD version %08x&quot;,
              version);
<span class="line-modified">!     }</span>
  
        if (entry-&gt;caps)
          gst_caps_unref (entry-&gt;caps);
  
        entry-&gt;caps = qtdemux_audio_caps (qtdemux, stream, entry, fourcc,
            stsd_entry_data + 32, len - 16, &amp;codec);
  
<span class="line-modified">!     switch (fourcc) {</span>
<span class="line-modified">!       case FOURCC_in24:</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         GNode *enda;</span>
<span class="line-modified">!         GNode *in24;</span>
  
<span class="line-modified">!         in24 = qtdemux_tree_get_child_by_type (stsd, FOURCC_in24);</span>
  
<span class="line-modified">!         enda = qtdemux_tree_get_child_by_type (in24, FOURCC_enda);</span>
<span class="line-modified">!         if (!enda) {</span>
<span class="line-modified">!           wave = qtdemux_tree_get_child_by_type (in24, FOURCC_wave);</span>
<span class="line-modified">!           if (wave)</span>
<span class="line-modified">!             enda = qtdemux_tree_get_child_by_type (wave, FOURCC_enda);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (enda) {</span>
<span class="line-modified">!           int enda_value = QT_UINT16 ((guint8 *) enda-&gt;data + 8);</span>
              gst_caps_set_simple (entry-&gt;caps,
                  &quot;format&quot;, G_TYPE_STRING, (enda_value) ? &quot;S24LE&quot; : &quot;S24BE&quot;,
                  NULL);
          }
<span class="line-modified">!         break;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       case FOURCC_owma:</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         const guint8 *owma_data;</span>
<span class="line-removed">-         const gchar *codec_name = NULL;</span>
<span class="line-removed">-         guint owma_len;</span>
<span class="line-removed">-         GstBuffer *buf;</span>
<span class="line-removed">-         gint version = 1;</span>
<span class="line-removed">-         /* from http://msdn.microsoft.com/en-us/library/dd757720(VS.85).aspx */</span>
<span class="line-removed">-         /* FIXME this should also be gst_riff_strf_auds,</span>
<span class="line-removed">-          * but the latter one is actually missing bits-per-sample :( */</span>
<span class="line-removed">-         typedef struct</span>
          {
<span class="line-modified">!           gint16 wFormatTag;</span>
<span class="line-modified">!           gint16 nChannels;</span>
<span class="line-modified">!           gint32 nSamplesPerSec;</span>
<span class="line-modified">!           gint32 nAvgBytesPerSec;</span>
<span class="line-modified">!           gint16 nBlockAlign;</span>
<span class="line-modified">!           gint16 wBitsPerSample;</span>
<span class="line-modified">!           gint16 cbSize;</span>
<span class="line-modified">!         } WAVEFORMATEX;</span>
<span class="line-modified">!         WAVEFORMATEX *wfex;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         GST_DEBUG_OBJECT (qtdemux, &quot;parse owma&quot;);</span>
            owma_data = stsd_entry_data;
<span class="line-modified">!         owma_len = QT_UINT32 (owma_data);</span>
<span class="line-modified">!         if (owma_len &lt;= 54) {</span>
<span class="line-modified">!           GST_WARNING_OBJECT (qtdemux, &quot;Too small owma header, skipping&quot;);</span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         wfex = (WAVEFORMATEX *) (owma_data + 36);</span>
<span class="line-modified">!         buf = gst_buffer_new_and_alloc (owma_len - 54);</span>
<span class="line-modified">!         gst_buffer_fill (buf, 0, owma_data + 54, owma_len - 54);</span>
<span class="line-modified">!         if (wfex-&gt;wFormatTag == 0x0161) {</span>
<span class="line-modified">!           codec_name = &quot;Windows Media Audio&quot;;</span>
<span class="line-modified">!           version = 2;</span>
<span class="line-modified">!         } else if (wfex-&gt;wFormatTag == 0x0162) {</span>
<span class="line-modified">!           codec_name = &quot;Windows Media Audio 9 Pro&quot;;</span>
<span class="line-modified">!           version = 3;</span>
<span class="line-modified">!         } else if (wfex-&gt;wFormatTag == 0x0163) {</span>
<span class="line-modified">!           codec_name = &quot;Windows Media Audio 9 Lossless&quot;;</span>
<span class="line-modified">!           /* is that correct? gstffmpegcodecmap.c is missing it, but</span>
<span class="line-modified">!            * fluendo codec seems to support it */</span>
<span class="line-modified">!           version = 4;</span>
<span class="line-modified">!         }</span>
  
            gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!             &quot;codec_data&quot;, GST_TYPE_BUFFER, buf,</span>
<span class="line-modified">!             &quot;wmaversion&quot;, G_TYPE_INT, version,</span>
                &quot;block_align&quot;, G_TYPE_INT,
                GST_READ_UINT16_LE (&amp;wfex-&gt;nBlockAlign), &quot;bitrate&quot;, G_TYPE_INT,
                GST_READ_UINT32_LE (&amp;wfex-&gt;nAvgBytesPerSec), &quot;width&quot;, G_TYPE_INT,
                GST_READ_UINT16_LE (&amp;wfex-&gt;wBitsPerSample), &quot;depth&quot;, G_TYPE_INT,
                GST_READ_UINT16_LE (&amp;wfex-&gt;wBitsPerSample), NULL);
<span class="line-modified">!         gst_buffer_unref (buf);</span>
  
<span class="line-modified">!         if (codec_name) {</span>
<span class="line-modified">!           g_free (codec);</span>
<span class="line-modified">!           codec = g_strdup (codec_name);</span>
          }
<span class="line-removed">-         break;</span>
<span class="line-removed">-       }</span>
          case FOURCC_wma_:
          {
            gint len = QT_UINT32 (stsd_entry_data) - offset;
            const guint8 *wfex_data = stsd_entry_data + offset;
            const gchar *codec_name = NULL;
<span class="line-new-header">--- 11626,349 ---</span>
                    gst_caps_set_simple (entry-&gt;caps,
                        &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);
                    gst_buffer_unref (buf);
                    break;
                  }
<span class="line-modified">!                 default:</span>
<span class="line-modified">!                   break;</span>
<span class="line-modified">!               }</span>
                len -= size + 8;
                vc1_data += size + 8;
<span class="line-modified">!             }</span>
<span class="line-added">+             break;</span>
<span class="line-added">+           }</span>
<span class="line-added">+           case FOURCC_av01:</span>
<span class="line-added">+           {</span>
<span class="line-added">+             gint len = QT_UINT32 (stsd_entry_data) - 0x56;</span>
<span class="line-added">+             const guint8 *av1_data = stsd_entry_data + 0x56;</span>
<span class="line-added">+ </span>
<span class="line-added">+             /* find av1C */</span>
<span class="line-added">+             while (len &gt;= 0x8) {</span>
<span class="line-added">+               gint size;</span>
<span class="line-added">+ </span>
<span class="line-added">+               if (QT_UINT32 (av1_data) &lt;= len)</span>
<span class="line-added">+                 size = QT_UINT32 (av1_data) - 0x8;</span>
<span class="line-added">+               else</span>
<span class="line-added">+                 size = len - 0x8;</span>
<span class="line-added">+ </span>
<span class="line-added">+               if (size &lt; 1)</span>
<span class="line-added">+                 /* No real data, so break out */</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+ </span>
<span class="line-added">+               switch (QT_FOURCC (av1_data + 0x4)) {</span>
<span class="line-added">+                 case FOURCC_av1C:</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                   /* parse, if found */</span>
<span class="line-added">+                   GstBuffer *buf;</span>
<span class="line-added">+                   guint8 pres_delay_field;</span>
<span class="line-added">+ </span>
<span class="line-added">+                   GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-added">+                       &quot;found av1C codec_data in stsd of size %d&quot;, size);</span>
<span class="line-added">+ </span>
<span class="line-added">+                   /* not enough data, just ignore and hope for the best */</span>
<span class="line-added">+                   if (size &lt; 5)</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+ </span>
<span class="line-added">+                   /* Content is:</span>
<span class="line-added">+                    * 4 bytes: atom length</span>
<span class="line-added">+                    * 4 bytes: fourcc</span>
<span class="line-added">+                    * 1 byte: version</span>
<span class="line-added">+                    * 3 bytes: flags</span>
<span class="line-added">+                    * 3 bits: reserved</span>
<span class="line-added">+                    * 1 bits:  initial_presentation_delay_present</span>
<span class="line-added">+                    * 4 bits: initial_presentation_delay (if present else reserved</span>
<span class="line-added">+                    * rest: OBUs.</span>
<span class="line-added">+                    */</span>
<span class="line-added">+ </span>
<span class="line-added">+                   if (av1_data[9] != 0) {</span>
<span class="line-added">+                     GST_WARNING (&quot;Unknown version %d of av1C box&quot;, av1_data[9]);</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                   }</span>
<span class="line-added">+ </span>
<span class="line-added">+                   /* We skip initial_presentation_delay* for now */</span>
<span class="line-added">+                   pres_delay_field = *(av1_data + 12);</span>
<span class="line-added">+                   if (pres_delay_field &amp; (1 &lt;&lt; 5)) {</span>
<span class="line-added">+                     gst_caps_set_simple (entry-&gt;caps,</span>
<span class="line-added">+                         &quot;presentation-delay&quot;, G_TYPE_INT,</span>
<span class="line-added">+                         (gint) (pres_delay_field &amp; 0x0F) + 1, NULL);</span>
<span class="line-added">+                   }</span>
<span class="line-added">+                   if (size &gt; 5) {</span>
<span class="line-added">+                     buf = gst_buffer_new_and_alloc (size - 5);</span>
<span class="line-added">+                     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_HEADER);</span>
<span class="line-added">+                     gst_buffer_fill (buf, 0, av1_data + 13, size - 5);</span>
<span class="line-added">+                     gst_caps_set_simple (entry-&gt;caps,</span>
<span class="line-added">+                         &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-added">+                     gst_buffer_unref (buf);</span>
<span class="line-added">+                   }</span>
<span class="line-added">+                   break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 default:</span>
<span class="line-added">+                   break;</span>
<span class="line-added">+               }</span>
<span class="line-added">+ </span>
<span class="line-added">+               len -= size + 8;</span>
<span class="line-added">+               av1_data += size + 8;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              break;
            }
            default:
              break;
          }
        }
  
<span class="line-modified">!       GST_INFO_OBJECT (qtdemux,</span>
<span class="line-modified">!           &quot;type %&quot; GST_FOURCC_FORMAT &quot; caps %&quot; GST_PTR_FORMAT,</span>
            GST_FOURCC_ARGS (fourcc), entry-&gt;caps);
  
<span class="line-modified">!     } else if (stream-&gt;subtype == FOURCC_soun) {</span>
        GNode *wave;
<span class="line-modified">!       int version, samplesize;</span>
<span class="line-modified">!       guint16 compression_id;</span>
<span class="line-modified">!       gboolean amrwb = FALSE;</span>
  
        offset = 16;
<span class="line-modified">!       /* sample description entry (16) + sound sample description v0 (20) */</span>
<span class="line-modified">!       if (len &lt; 36)</span>
<span class="line-modified">!         goto corrupt_file;</span>
  
        version = QT_UINT32 (stsd_entry_data + offset);
        entry-&gt;n_channels = QT_UINT16 (stsd_entry_data + offset + 8);
        samplesize = QT_UINT16 (stsd_entry_data + offset + 10);
        compression_id = QT_UINT16 (stsd_entry_data + offset + 12);
        entry-&gt;rate = QT_FP32 (stsd_entry_data + offset + 16);
  
<span class="line-modified">!       GST_LOG_OBJECT (qtdemux, &quot;version/rev:      %08x&quot;, version);</span>
<span class="line-modified">!       GST_LOG_OBJECT (qtdemux, &quot;vendor:           %08x&quot;,</span>
            QT_UINT32 (stsd_entry_data + offset + 4));
        GST_LOG_OBJECT (qtdemux, &quot;n_channels:       %d&quot;, entry-&gt;n_channels);
<span class="line-modified">!       GST_LOG_OBJECT (qtdemux, &quot;sample_size:      %d&quot;, samplesize);</span>
<span class="line-modified">!       GST_LOG_OBJECT (qtdemux, &quot;compression_id:   %d&quot;, compression_id);</span>
<span class="line-modified">!       GST_LOG_OBJECT (qtdemux, &quot;packet size:      %d&quot;,</span>
            QT_UINT16 (stsd_entry_data + offset + 14));
        GST_LOG_OBJECT (qtdemux, &quot;sample rate:      %g&quot;, entry-&gt;rate);
  
<span class="line-modified">!       if (compression_id == 0xfffe)</span>
          entry-&gt;sampled = TRUE;
  
<span class="line-modified">!       /* first assume uncompressed audio */</span>
        entry-&gt;bytes_per_sample = samplesize / 8;
        entry-&gt;samples_per_frame = entry-&gt;n_channels;
        entry-&gt;bytes_per_frame = entry-&gt;n_channels * entry-&gt;bytes_per_sample;
        entry-&gt;samples_per_packet = entry-&gt;samples_per_frame;
        entry-&gt;bytes_per_packet = entry-&gt;bytes_per_sample;
  
        offset = 36;
<span class="line-modified">!       switch (fourcc) {</span>
<span class="line-modified">!           /* Yes, these have to be hard-coded */</span>
<span class="line-modified">!         case FOURCC_MAC6:</span>
<span class="line-modified">!         {</span>
            entry-&gt;samples_per_packet = 6;
            entry-&gt;bytes_per_packet = 1;
            entry-&gt;bytes_per_frame = 1 * entry-&gt;n_channels;
            entry-&gt;bytes_per_sample = 1;
            entry-&gt;samples_per_frame = 6 * entry-&gt;n_channels;
<span class="line-modified">!           break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case FOURCC_MAC3:</span>
<span class="line-modified">!         {</span>
            entry-&gt;samples_per_packet = 3;
            entry-&gt;bytes_per_packet = 1;
            entry-&gt;bytes_per_frame = 1 * entry-&gt;n_channels;
            entry-&gt;bytes_per_sample = 1;
            entry-&gt;samples_per_frame = 3 * entry-&gt;n_channels;
<span class="line-modified">!           break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case FOURCC_ima4:</span>
<span class="line-modified">!         {</span>
            entry-&gt;samples_per_packet = 64;
            entry-&gt;bytes_per_packet = 34;
            entry-&gt;bytes_per_frame = 34 * entry-&gt;n_channels;
            entry-&gt;bytes_per_sample = 2;
            entry-&gt;samples_per_frame = 64 * entry-&gt;n_channels;
<span class="line-modified">!           break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case FOURCC_ulaw:</span>
<span class="line-modified">!         case FOURCC_alaw:</span>
<span class="line-modified">!         {</span>
            entry-&gt;samples_per_packet = 1;
            entry-&gt;bytes_per_packet = 1;
            entry-&gt;bytes_per_frame = 1 * entry-&gt;n_channels;
            entry-&gt;bytes_per_sample = 1;
            entry-&gt;samples_per_frame = 1 * entry-&gt;n_channels;
<span class="line-modified">!           break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case FOURCC_agsm:</span>
<span class="line-modified">!         {</span>
            entry-&gt;samples_per_packet = 160;
            entry-&gt;bytes_per_packet = 33;
            entry-&gt;bytes_per_frame = 33 * entry-&gt;n_channels;
            entry-&gt;bytes_per_sample = 2;
            entry-&gt;samples_per_frame = 160 * entry-&gt;n_channels;
<span class="line-modified">!           break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         default:</span>
<span class="line-added">+           break;</span>
        }
  
<span class="line-modified">!       if (version == 0x00010000) {</span>
<span class="line-modified">!         /* sample description entry (16) + sound sample description v1 (20+16) */</span>
<span class="line-modified">!         if (len &lt; 52)</span>
<span class="line-modified">!           goto corrupt_file;</span>
  
<span class="line-modified">!         switch (fourcc) {</span>
<span class="line-modified">!           case FOURCC_twos:</span>
<span class="line-modified">!           case FOURCC_sowt:</span>
<span class="line-modified">!           case FOURCC_raw_:</span>
            case FOURCC_lpcm:
<span class="line-modified">!             break;</span>
<span class="line-modified">!           default:</span>
<span class="line-modified">!           {</span>
<span class="line-modified">!             /* only parse extra decoding config for non-pcm audio */</span>
              entry-&gt;samples_per_packet = QT_UINT32 (stsd_entry_data + offset);
              entry-&gt;bytes_per_packet = QT_UINT32 (stsd_entry_data + offset + 4);
              entry-&gt;bytes_per_frame = QT_UINT32 (stsd_entry_data + offset + 8);
              entry-&gt;bytes_per_sample = QT_UINT32 (stsd_entry_data + offset + 12);
  
<span class="line-modified">!             GST_LOG_OBJECT (qtdemux, &quot;samples/packet:   %d&quot;,</span>
                  entry-&gt;samples_per_packet);
<span class="line-modified">!             GST_LOG_OBJECT (qtdemux, &quot;bytes/packet:     %d&quot;,</span>
                  entry-&gt;bytes_per_packet);
<span class="line-modified">!             GST_LOG_OBJECT (qtdemux, &quot;bytes/frame:      %d&quot;,</span>
                  entry-&gt;bytes_per_frame);
<span class="line-modified">!             GST_LOG_OBJECT (qtdemux, &quot;bytes/sample:     %d&quot;,</span>
                  entry-&gt;bytes_per_sample);
  
              if (!entry-&gt;sampled &amp;&amp; entry-&gt;bytes_per_packet) {
                entry-&gt;samples_per_frame = (entry-&gt;bytes_per_frame /
                    entry-&gt;bytes_per_packet) * entry-&gt;samples_per_packet;
<span class="line-modified">!               GST_LOG_OBJECT (qtdemux, &quot;samples/frame:    %d&quot;,</span>
                    entry-&gt;samples_per_frame);
<span class="line-added">+             }</span>
<span class="line-added">+             break;</span>
            }
          }
<span class="line-modified">!       } else if (version == 0x00020000) {</span>
<span class="line-modified">!         union</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           gdouble fp;</span>
<span class="line-modified">!           guint64 val;</span>
<span class="line-modified">!         } qtfp;</span>
  
<span class="line-modified">!         /* sample description entry (16) + sound sample description v2 (56) */</span>
<span class="line-modified">!         if (len &lt; 72)</span>
<span class="line-modified">!           goto corrupt_file;</span>
  
          qtfp.val = QT_UINT64 (stsd_entry_data + offset + 4);
          entry-&gt;rate = qtfp.fp;
          entry-&gt;n_channels = QT_UINT32 (stsd_entry_data + offset + 12);
  
<span class="line-modified">!         GST_LOG_OBJECT (qtdemux, &quot;Sound sample description Version 2&quot;);</span>
          GST_LOG_OBJECT (qtdemux, &quot;sample rate:        %g&quot;, entry-&gt;rate);
          GST_LOG_OBJECT (qtdemux, &quot;n_channels:         %d&quot;, entry-&gt;n_channels);
<span class="line-modified">!         GST_LOG_OBJECT (qtdemux, &quot;bits/channel:       %d&quot;,</span>
              QT_UINT32 (stsd_entry_data + offset + 20));
<span class="line-modified">!         GST_LOG_OBJECT (qtdemux, &quot;format flags:       %X&quot;,</span>
              QT_UINT32 (stsd_entry_data + offset + 24));
<span class="line-modified">!         GST_LOG_OBJECT (qtdemux, &quot;bytes/packet:       %d&quot;,</span>
              QT_UINT32 (stsd_entry_data + offset + 28));
<span class="line-modified">!         GST_LOG_OBJECT (qtdemux, &quot;LPCM frames/packet: %d&quot;,</span>
              QT_UINT32 (stsd_entry_data + offset + 32));
<span class="line-modified">!       } else if (version != 0x00000) {</span>
          GST_WARNING_OBJECT (qtdemux, &quot;unknown audio STSD version %08x&quot;,
              version);
<span class="line-modified">!       }</span>
  
        if (entry-&gt;caps)
          gst_caps_unref (entry-&gt;caps);
  
        entry-&gt;caps = qtdemux_audio_caps (qtdemux, stream, entry, fourcc,
            stsd_entry_data + 32, len - 16, &amp;codec);
  
<span class="line-modified">!       switch (fourcc) {</span>
<span class="line-modified">!         case FOURCC_in24:</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           GNode *enda;</span>
<span class="line-modified">!           GNode *in24;</span>
  
<span class="line-modified">!           in24 = qtdemux_tree_get_child_by_type (stsd, FOURCC_in24);</span>
  
<span class="line-modified">!           enda = qtdemux_tree_get_child_by_type (in24, FOURCC_enda);</span>
<span class="line-modified">!           if (!enda) {</span>
<span class="line-modified">!             wave = qtdemux_tree_get_child_by_type (in24, FOURCC_wave);</span>
<span class="line-modified">!             if (wave)</span>
<span class="line-modified">!               enda = qtdemux_tree_get_child_by_type (wave, FOURCC_enda);</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!           if (enda) {</span>
<span class="line-modified">!             int enda_value = QT_UINT16 ((guint8 *) enda-&gt;data + 8);</span>
              gst_caps_set_simple (entry-&gt;caps,
                  &quot;format&quot;, G_TYPE_STRING, (enda_value) ? &quot;S24LE&quot; : &quot;S24BE&quot;,
                  NULL);
<span class="line-added">+           }</span>
<span class="line-added">+           break;</span>
          }
<span class="line-modified">!         case FOURCC_owma:</span>
          {
<span class="line-modified">!           const guint8 *owma_data;</span>
<span class="line-modified">!           const gchar *codec_name = NULL;</span>
<span class="line-modified">!           guint owma_len;</span>
<span class="line-modified">!           GstBuffer *buf;</span>
<span class="line-modified">!           gint version = 1;</span>
<span class="line-modified">!           /* from http://msdn.microsoft.com/en-us/library/dd757720(VS.85).aspx */</span>
<span class="line-modified">!           /* FIXME this should also be gst_riff_strf_auds,</span>
<span class="line-modified">!            * but the latter one is actually missing bits-per-sample :( */</span>
<span class="line-modified">!           typedef struct</span>
<span class="line-modified">!           {</span>
<span class="line-modified">!             gint16 wFormatTag;</span>
<span class="line-added">+             gint16 nChannels;</span>
<span class="line-added">+             gint32 nSamplesPerSec;</span>
<span class="line-added">+             gint32 nAvgBytesPerSec;</span>
<span class="line-added">+             gint16 nBlockAlign;</span>
<span class="line-added">+             gint16 wBitsPerSample;</span>
<span class="line-added">+             gint16 cbSize;</span>
<span class="line-added">+           } WAVEFORMATEX;</span>
<span class="line-added">+           WAVEFORMATEX *wfex;</span>
<span class="line-added">+ </span>
<span class="line-added">+           GST_DEBUG_OBJECT (qtdemux, &quot;parse owma&quot;);</span>
            owma_data = stsd_entry_data;
<span class="line-modified">!           owma_len = QT_UINT32 (owma_data);</span>
<span class="line-modified">!           if (owma_len &lt;= 54) {</span>
<span class="line-modified">!             GST_WARNING_OBJECT (qtdemux, &quot;Too small owma header, skipping&quot;);</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!           wfex = (WAVEFORMATEX *) (owma_data + 36);</span>
<span class="line-modified">!           buf = gst_buffer_new_and_alloc (owma_len - 54);</span>
<span class="line-modified">!           gst_buffer_fill (buf, 0, owma_data + 54, owma_len - 54);</span>
<span class="line-modified">!           if (wfex-&gt;wFormatTag == 0x0161) {</span>
<span class="line-modified">!             codec_name = &quot;Windows Media Audio&quot;;</span>
<span class="line-modified">!             version = 2;</span>
<span class="line-modified">!           } else if (wfex-&gt;wFormatTag == 0x0162) {</span>
<span class="line-modified">!             codec_name = &quot;Windows Media Audio 9 Pro&quot;;</span>
<span class="line-modified">!             version = 3;</span>
<span class="line-modified">!           } else if (wfex-&gt;wFormatTag == 0x0163) {</span>
<span class="line-modified">!             codec_name = &quot;Windows Media Audio 9 Lossless&quot;;</span>
<span class="line-modified">!             /* is that correct? gstffmpegcodecmap.c is missing it, but</span>
<span class="line-modified">!              * fluendo codec seems to support it */</span>
<span class="line-modified">!             version = 4;</span>
<span class="line-modified">!           }</span>
  
            gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!               &quot;codec_data&quot;, GST_TYPE_BUFFER, buf,</span>
<span class="line-modified">!               &quot;wmaversion&quot;, G_TYPE_INT, version,</span>
                &quot;block_align&quot;, G_TYPE_INT,
                GST_READ_UINT16_LE (&amp;wfex-&gt;nBlockAlign), &quot;bitrate&quot;, G_TYPE_INT,
                GST_READ_UINT32_LE (&amp;wfex-&gt;nAvgBytesPerSec), &quot;width&quot;, G_TYPE_INT,
                GST_READ_UINT16_LE (&amp;wfex-&gt;wBitsPerSample), &quot;depth&quot;, G_TYPE_INT,
                GST_READ_UINT16_LE (&amp;wfex-&gt;wBitsPerSample), NULL);
<span class="line-modified">!           gst_buffer_unref (buf);</span>
  
<span class="line-modified">!           if (codec_name) {</span>
<span class="line-modified">!             g_free (codec);</span>
<span class="line-modified">!             codec = g_strdup (codec_name);</span>
<span class="line-added">+           }</span>
<span class="line-added">+           break;</span>
          }
          case FOURCC_wma_:
          {
            gint len = QT_UINT32 (stsd_entry_data) - offset;
            const guint8 *wfex_data = stsd_entry_data + offset;
            const gchar *codec_name = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11223,13 ***</span>
                    g_free (codec);
                    codec = g_strdup (codec_name);
                  }
                  break;
                }
<span class="line-modified">!       default:</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     }</span>
              len -= size + 8;
              wfex_data += size + 8;
            }
            break;
          }
<span class="line-new-header">--- 12064,13 ---</span>
                    g_free (codec);
                    codec = g_strdup (codec_name);
                  }
                  break;
                }
<span class="line-modified">!               default:</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             }</span>
              len -= size + 8;
              wfex_data += size + 8;
            }
            break;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11267,188 ***</span>
  #endif // GSTREAMER_LITE
          default:
            break;
        }
  
<span class="line-modified">!     if (codec) {</span>
<span class="line-modified">!       GstStructure *s;</span>
<span class="line-modified">!       gint bitrate = 0;</span>
  
          gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">!           GST_TAG_AUDIO_CODEC, codec, NULL);</span>
<span class="line-modified">!       g_free (codec);</span>
<span class="line-modified">!       codec = NULL;</span>
  
<span class="line-modified">!       /* some bitrate info may have ended up in caps */</span>
          s = gst_caps_get_structure (entry-&gt;caps, 0);
<span class="line-modified">!       gst_structure_get_int (s, &quot;bitrate&quot;, &amp;bitrate);</span>
<span class="line-modified">!       if (bitrate &gt; 0)</span>
            gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
                GST_TAG_BITRATE, bitrate, NULL);
<span class="line-modified">!     }</span>
  
        mp4a = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">!       if (!stream-&gt;protected) {</span>
<span class="line-modified">!       } else {</span>
<span class="line-removed">-         if (QTDEMUX_TREE_NODE_FOURCC (mp4v) != FOURCC_encv) {</span>
<span class="line-removed">-           mp4v = NULL;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (stream-&gt;protected &amp;&amp; fourcc == FOURCC_mp4a) {</span>
<span class="line-removed">-         if (QTDEMUX_TREE_NODE_FOURCC (mp4a) != FOURCC_enca) {</span>
            mp4a = NULL;
<span class="line-modified">!         }</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         if (QTDEMUX_TREE_NODE_FOURCC (mp4a) != FOURCC_mp4a) {</span>
            mp4a = NULL;
<span class="line-removed">-         }</span>
        }
  
<span class="line-modified">!     wave = NULL;</span>
<span class="line-modified">!     esds = NULL;</span>
<span class="line-modified">!     if (mp4a) {</span>
<span class="line-modified">!       wave = qtdemux_tree_get_child_by_type (mp4a, FOURCC_wave);</span>
<span class="line-modified">!       if (wave)</span>
<span class="line-modified">!         esds = qtdemux_tree_get_child_by_type (wave, FOURCC_esds);</span>
<span class="line-modified">!       if (!esds)</span>
<span class="line-modified">!         esds = qtdemux_tree_get_child_by_type (mp4a, FOURCC_esds);</span>
<span class="line-modified">!     }</span>
  
  
<span class="line-modified">!     /* If the fourcc&#39;s bottom 16 bits gives &#39;sm&#39;, then the top</span>
<span class="line-modified">!        16 bits is a byte-swapped wave-style codec identifier,</span>
<span class="line-modified">!        and we can find a WAVE header internally to a &#39;wave&#39; atom here.</span>
<span class="line-modified">!        This can more clearly be thought of as &#39;ms&#39; as the top 16 bits, and a</span>
<span class="line-modified">!        codec id as the bottom 16 bits - but byte-swapped to store in QT (which</span>
<span class="line-modified">!        is big-endian).</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     if ((fourcc &amp; 0xffff) == ((&#39;s&#39; &lt;&lt; 8) | &#39;m&#39;)) {</span>
<span class="line-modified">!       if (len &lt; offset + 20) {</span>
<span class="line-modified">!         GST_WARNING_OBJECT (qtdemux, &quot;No wave atom in MS-style audio&quot;);</span>
<span class="line-modified">!       } else {</span>
            guint32 datalen = QT_UINT32 (stsd_entry_data + offset + 16);
            const guint8 *data = stsd_entry_data + offset + 16;
<span class="line-modified">!         GNode *wavenode;</span>
<span class="line-modified">!         GNode *waveheadernode;</span>
  
<span class="line-modified">!         wavenode = g_node_new ((guint8 *) data);</span>
<span class="line-modified">!         if (qtdemux_parse_node (qtdemux, wavenode, data, datalen)) {</span>
<span class="line-modified">!           const guint8 *waveheader;</span>
<span class="line-modified">!           guint32 headerlen;</span>
  
<span class="line-modified">!           waveheadernode = qtdemux_tree_get_child_by_type (wavenode, fourcc);</span>
<span class="line-modified">!           if (waveheadernode) {</span>
<span class="line-modified">!             waveheader = (const guint8 *) waveheadernode-&gt;data;</span>
<span class="line-modified">!             headerlen = QT_UINT32 (waveheader);</span>
  
<span class="line-modified">!             if (headerlen &gt; 8) {</span>
<span class="line-modified">!               gst_riff_strf_auds *header = NULL;</span>
<span class="line-modified">!               GstBuffer *headerbuf;</span>
<span class="line-modified">!               GstBuffer *extra;</span>
  
<span class="line-modified">!               waveheader += 8;</span>
<span class="line-modified">!               headerlen -= 8;</span>
  
<span class="line-modified">!               headerbuf = gst_buffer_new_and_alloc (headerlen);</span>
<span class="line-modified">!               gst_buffer_fill (headerbuf, 0, waveheader, headerlen);</span>
  
<span class="line-modified">!               if (gst_riff_parse_strf_auds (GST_ELEMENT_CAST (qtdemux),</span>
<span class="line-modified">!                       headerbuf, &amp;header, &amp;extra)) {</span>
                    gst_caps_unref (entry-&gt;caps);
<span class="line-modified">!                 /* FIXME: Need to do something with the channel reorder map */</span>
                    entry-&gt;caps =
                        gst_riff_create_audio_caps (header-&gt;format, NULL, header,
                        extra, NULL, NULL, NULL);
  
<span class="line-modified">!                 if (extra)</span>
<span class="line-modified">!                   gst_buffer_unref (extra);</span>
<span class="line-modified">!                 g_free (header);</span>
                }
<span class="line-modified">!             }</span>
<span class="line-modified">!           } else</span>
<span class="line-modified">!             GST_DEBUG (&quot;Didn&#39;t find waveheadernode for this codec&quot;);</span>
          }
<span class="line-modified">!         g_node_destroy (wavenode);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     } else if (esds) {</span>
  #ifdef GSTREAMER_LITE
          if (!gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
                                        stream-&gt;stream_tags))
              goto corrupt_file;
  #else
          gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
              stream-&gt;stream_tags);
  #endif // GSTREAMER_LITE
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       switch (fourcc) {</span>
  #if 0
<span class="line-modified">!           /* FIXME: what is in the chunk? */</span>
<span class="line-modified">!         case FOURCC_QDMC:</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           gint len = QT_UINT32 (stsd_data);</span>
  
<span class="line-modified">!           /* seems to be always = 116 = 0x74 */</span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!         }</span>
  #endif
<span class="line-modified">!         case FOURCC_QDM2:</span>
<span class="line-modified">!         {</span>
              gint len = QT_UINT32 (stsd_entry_data);
  
              if (len &gt; 0x3C) {
                GstBuffer *buf = gst_buffer_new_and_alloc (len - 0x3C);
  
                gst_buffer_fill (buf, 0, stsd_entry_data + 0x3C, len - 0x3C);
                gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                 &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">!             gst_buffer_unref (buf);</span>
<span class="line-modified">!           }</span>
              gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!               &quot;samplesize&quot;, G_TYPE_INT, samplesize, NULL);</span>
<span class="line-modified">!           break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         case FOURCC_alac:</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           GNode *alac, *wave = NULL;</span>
<span class="line-removed">- </span>
<span class="line-removed">-           /* apparently, m4a has this atom appended directly in the stsd entry,</span>
<span class="line-removed">-            * while mov has it in a wave atom */</span>
<span class="line-removed">-           alac = qtdemux_tree_get_child_by_type (stsd, FOURCC_alac);</span>
<span class="line-removed">-           if (alac) {</span>
<span class="line-removed">-             /* alac now refers to stsd entry atom */</span>
<span class="line-removed">-             wave = qtdemux_tree_get_child_by_type (alac, FOURCC_wave);</span>
<span class="line-removed">-             if (wave)</span>
<span class="line-removed">-               alac = qtdemux_tree_get_child_by_type (wave, FOURCC_alac);</span>
<span class="line-removed">-             else</span>
<span class="line-removed">-               alac = qtdemux_tree_get_child_by_type (alac, FOURCC_alac);</span>
            }
<span class="line-modified">!           if (alac) {</span>
<span class="line-modified">!             const guint8 *alac_data = alac-&gt;data;</span>
<span class="line-modified">!             gint len = QT_UINT32 (alac-&gt;data);</span>
<span class="line-modified">!             GstBuffer *buf;</span>
  
<span class="line-modified">!             if (len &lt; 36) {</span>
<span class="line-modified">!               GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-modified">!                   &quot;discarding alac atom with unexpected len %d&quot;, len);</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!               /* codec-data contains alac atom size and prefix,</span>
<span class="line-modified">!                * ffmpeg likes it that way, not quite gst-ish though ...*/</span>
<span class="line-modified">!               buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">!               gst_buffer_fill (buf, 0, alac-&gt;data, len);</span>
                  gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                   &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">!               gst_buffer_unref (buf);</span>
  
                  entry-&gt;bytes_per_frame = QT_UINT32 (alac_data + 12);
                  entry-&gt;n_channels = QT_UINT8 (alac_data + 21);
                  entry-&gt;rate = QT_UINT32 (alac_data + 32);
              }
<span class="line-removed">-           }</span>
              gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!               &quot;samplesize&quot;, G_TYPE_INT, samplesize, NULL);</span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!         }</span>
            case FOURCC_fLaC:
            {
              /* The codingname of the sample entry is &#39;fLaC&#39; */
              GNode *flac = qtdemux_tree_get_child_by_type (stsd, FOURCC_fLaC);
  
<span class="line-new-header">--- 12108,179 ---</span>
  #endif // GSTREAMER_LITE
          default:
            break;
        }
  
<span class="line-modified">!       if (codec) {</span>
<span class="line-modified">!         GstStructure *s;</span>
<span class="line-modified">!         gint bitrate = 0;</span>
  
          gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">!             GST_TAG_AUDIO_CODEC, codec, NULL);</span>
<span class="line-modified">!         g_free (codec);</span>
<span class="line-modified">!         codec = NULL;</span>
  
<span class="line-modified">!         /* some bitrate info may have ended up in caps */</span>
          s = gst_caps_get_structure (entry-&gt;caps, 0);
<span class="line-modified">!         gst_structure_get_int (s, &quot;bitrate&quot;, &amp;bitrate);</span>
<span class="line-modified">!         if (bitrate &gt; 0)</span>
            gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
                GST_TAG_BITRATE, bitrate, NULL);
<span class="line-modified">!       }</span>
  
        mp4a = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<span class="line-modified">!       if (QTDEMUX_TREE_NODE_FOURCC (mp4a) != fourcc) {</span>
<span class="line-modified">!         if (stream-&gt;protected &amp;&amp; QTDEMUX_TREE_NODE_FOURCC (mp4a) != FOURCC_enca)</span>
            mp4a = NULL;
<span class="line-modified">!         else if (!stream-&gt;protected)</span>
            mp4a = NULL;
        }
  
<span class="line-modified">!       wave = NULL;</span>
<span class="line-modified">!       esds = NULL;</span>
<span class="line-modified">!       if (mp4a) {</span>
<span class="line-modified">!         wave = qtdemux_tree_get_child_by_type (mp4a, FOURCC_wave);</span>
<span class="line-modified">!         if (wave)</span>
<span class="line-modified">!           esds = qtdemux_tree_get_child_by_type (wave, FOURCC_esds);</span>
<span class="line-modified">!         if (!esds)</span>
<span class="line-modified">!           esds = qtdemux_tree_get_child_by_type (mp4a, FOURCC_esds);</span>
<span class="line-modified">!       }</span>
  
  
<span class="line-modified">!       /* If the fourcc&#39;s bottom 16 bits gives &#39;sm&#39;, then the top</span>
<span class="line-modified">!          16 bits is a byte-swapped wave-style codec identifier,</span>
<span class="line-modified">!          and we can find a WAVE header internally to a &#39;wave&#39; atom here.</span>
<span class="line-modified">!          This can more clearly be thought of as &#39;ms&#39; as the top 16 bits, and a</span>
<span class="line-modified">!          codec id as the bottom 16 bits - but byte-swapped to store in QT (which</span>
<span class="line-modified">!          is big-endian).</span>
<span class="line-modified">!        */</span>
<span class="line-modified">!       if ((fourcc &amp; 0xffff) == ((&#39;s&#39; &lt;&lt; 8) | &#39;m&#39;)) {</span>
<span class="line-modified">!         if (len &lt; offset + 20) {</span>
<span class="line-modified">!           GST_WARNING_OBJECT (qtdemux, &quot;No wave atom in MS-style audio&quot;);</span>
<span class="line-modified">!         } else {</span>
            guint32 datalen = QT_UINT32 (stsd_entry_data + offset + 16);
            const guint8 *data = stsd_entry_data + offset + 16;
<span class="line-modified">!           GNode *wavenode;</span>
<span class="line-modified">!           GNode *waveheadernode;</span>
  
<span class="line-modified">!           wavenode = g_node_new ((guint8 *) data);</span>
<span class="line-modified">!           if (qtdemux_parse_node (qtdemux, wavenode, data, datalen)) {</span>
<span class="line-modified">!             const guint8 *waveheader;</span>
<span class="line-modified">!             guint32 headerlen;</span>
  
<span class="line-modified">!             waveheadernode = qtdemux_tree_get_child_by_type (wavenode, fourcc);</span>
<span class="line-modified">!             if (waveheadernode) {</span>
<span class="line-modified">!               waveheader = (const guint8 *) waveheadernode-&gt;data;</span>
<span class="line-modified">!               headerlen = QT_UINT32 (waveheader);</span>
  
<span class="line-modified">!               if (headerlen &gt; 8) {</span>
<span class="line-modified">!                 gst_riff_strf_auds *header = NULL;</span>
<span class="line-modified">!                 GstBuffer *headerbuf;</span>
<span class="line-modified">!                 GstBuffer *extra;</span>
  
<span class="line-modified">!                 waveheader += 8;</span>
<span class="line-modified">!                 headerlen -= 8;</span>
  
<span class="line-modified">!                 headerbuf = gst_buffer_new_and_alloc (headerlen);</span>
<span class="line-modified">!                 gst_buffer_fill (headerbuf, 0, waveheader, headerlen);</span>
  
<span class="line-modified">!                 if (gst_riff_parse_strf_auds (GST_ELEMENT_CAST (qtdemux),</span>
<span class="line-modified">!                         headerbuf, &amp;header, &amp;extra)) {</span>
                    gst_caps_unref (entry-&gt;caps);
<span class="line-modified">!                   /* FIXME: Need to do something with the channel reorder map */</span>
                    entry-&gt;caps =
                        gst_riff_create_audio_caps (header-&gt;format, NULL, header,
                        extra, NULL, NULL, NULL);
  
<span class="line-modified">!                   if (extra)</span>
<span class="line-modified">!                     gst_buffer_unref (extra);</span>
<span class="line-modified">!                   g_free (header);</span>
<span class="line-added">+                 }</span>
                }
<span class="line-modified">!             } else</span>
<span class="line-modified">!               GST_DEBUG (&quot;Didn&#39;t find waveheadernode for this codec&quot;);</span>
<span class="line-modified">!           }</span>
<span class="line-added">+           g_node_destroy (wavenode);</span>
          }
<span class="line-modified">!       } else if (esds) {</span>
  #ifdef GSTREAMER_LITE
          if (!gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
                                        stream-&gt;stream_tags))
              goto corrupt_file;
  #else
          gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
              stream-&gt;stream_tags);
  #endif // GSTREAMER_LITE
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         switch (fourcc) {</span>
  #if 0
<span class="line-modified">!             /* FIXME: what is in the chunk? */</span>
<span class="line-modified">!           case FOURCC_QDMC:</span>
<span class="line-modified">!           {</span>
<span class="line-modified">!             gint len = QT_UINT32 (stsd_data);</span>
  
<span class="line-modified">!             /* seems to be always = 116 = 0x74 */</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!           }</span>
  #endif
<span class="line-modified">!           case FOURCC_QDM2:</span>
<span class="line-modified">!           {</span>
              gint len = QT_UINT32 (stsd_entry_data);
  
              if (len &gt; 0x3C) {
                GstBuffer *buf = gst_buffer_new_and_alloc (len - 0x3C);
  
                gst_buffer_fill (buf, 0, stsd_entry_data + 0x3C, len - 0x3C);
                gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                   &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">!               gst_buffer_unref (buf);</span>
<span class="line-modified">!             }</span>
              gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                 &quot;samplesize&quot;, G_TYPE_INT, samplesize, NULL);</span>
<span class="line-modified">!             break;</span>
            }
<span class="line-modified">!           case FOURCC_alac:</span>
<span class="line-modified">!           {</span>
<span class="line-modified">!             GNode *alac, *wave = NULL;</span>
<span class="line-modified">! </span>
<span class="line-added">+             /* apparently, m4a has this atom appended directly in the stsd entry,</span>
<span class="line-added">+              * while mov has it in a wave atom */</span>
<span class="line-added">+             alac = qtdemux_tree_get_child_by_type (stsd, FOURCC_alac);</span>
<span class="line-added">+             if (alac) {</span>
<span class="line-added">+               /* alac now refers to stsd entry atom */</span>
<span class="line-added">+               wave = qtdemux_tree_get_child_by_type (alac, FOURCC_wave);</span>
<span class="line-added">+               if (wave)</span>
<span class="line-added">+                 alac = qtdemux_tree_get_child_by_type (wave, FOURCC_alac);</span>
<span class="line-added">+               else</span>
<span class="line-added">+                 alac = qtdemux_tree_get_child_by_type (alac, FOURCC_alac);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (alac) {</span>
<span class="line-added">+               const guint8 *alac_data = alac-&gt;data;</span>
<span class="line-added">+               gint len = QT_UINT32 (alac-&gt;data);</span>
<span class="line-added">+               GstBuffer *buf;</span>
  
<span class="line-modified">!               if (len &lt; 36) {</span>
<span class="line-modified">!                 GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-modified">!                     &quot;discarding alac atom with unexpected len %d&quot;, len);</span>
<span class="line-modified">!               } else {</span>
<span class="line-modified">!                 /* codec-data contains alac atom size and prefix,</span>
<span class="line-modified">!                  * ffmpeg likes it that way, not quite gst-ish though ...*/</span>
<span class="line-modified">!                 buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">!                 gst_buffer_fill (buf, 0, alac-&gt;data, len);</span>
                  gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                     &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">!                 gst_buffer_unref (buf);</span>
  
                  entry-&gt;bytes_per_frame = QT_UINT32 (alac_data + 12);
                  entry-&gt;n_channels = QT_UINT8 (alac_data + 21);
                  entry-&gt;rate = QT_UINT32 (alac_data + 32);
<span class="line-added">+               }</span>
              }
              gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                 &quot;samplesize&quot;, G_TYPE_INT, samplesize, NULL);</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!           }</span>
            case FOURCC_fLaC:
            {
              /* The codingname of the sample entry is &#39;fLaC&#39; */
              GNode *flac = qtdemux_tree_get_child_by_type (stsd, FOURCC_fLaC);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11547,37 ***</span>
                  }
                }
              }
              break;
            }
<span class="line-modified">!         case FOURCC_sawb:</span>
<span class="line-modified">!           /* Fallthrough! */</span>
<span class="line-modified">!           amrwb = TRUE;</span>
<span class="line-modified">!         case FOURCC_samr:</span>
<span class="line-modified">!         {</span>
              gint len = QT_UINT32 (stsd_entry_data);
  
              if (len &gt; 0x24) {
                GstBuffer *buf = gst_buffer_new_and_alloc (len - 0x24);
<span class="line-modified">!             guint bitrate;</span>
  
                gst_buffer_fill (buf, 0, stsd_entry_data + 0x24, len - 0x24);
  
<span class="line-modified">!             /* If we have enough data, let&#39;s try to get the &#39;damr&#39; atom. See</span>
<span class="line-modified">!              * the 3GPP container spec (26.244) for more details. */</span>
<span class="line-modified">!             if ((len - 0x34) &gt; 8 &amp;&amp;</span>
<span class="line-modified">!                 (bitrate = qtdemux_parse_amr_bitrate (buf, amrwb))) {</span>
                  gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">!                   GST_TAG_MAXIMUM_BITRATE, bitrate, NULL);</span>
<span class="line-modified">!             }</span>
  
                gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                 &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">!             gst_buffer_unref (buf);</span>
            }
<span class="line-removed">-           break;</span>
<span class="line-removed">-         }</span>
            case FOURCC_mp4a:
            {
              /* mp4a atom withtout ESDS; Attempt to build codec data from atom */
              gint len = QT_UINT32 (stsd_entry_data);
  
<span class="line-new-header">--- 12379,37 ---</span>
                  }
                }
              }
              break;
            }
<span class="line-modified">!           case FOURCC_sawb:</span>
<span class="line-modified">!             /* Fallthrough! */</span>
<span class="line-modified">!             amrwb = TRUE;</span>
<span class="line-modified">!           case FOURCC_samr:</span>
<span class="line-modified">!           {</span>
              gint len = QT_UINT32 (stsd_entry_data);
  
              if (len &gt; 0x24) {
                GstBuffer *buf = gst_buffer_new_and_alloc (len - 0x24);
<span class="line-modified">!               guint bitrate;</span>
  
                gst_buffer_fill (buf, 0, stsd_entry_data + 0x24, len - 0x24);
  
<span class="line-modified">!               /* If we have enough data, let&#39;s try to get the &#39;damr&#39; atom. See</span>
<span class="line-modified">!                * the 3GPP container spec (26.244) for more details. */</span>
<span class="line-modified">!               if ((len - 0x34) &gt; 8 &amp;&amp;</span>
<span class="line-modified">!                   (bitrate = qtdemux_parse_amr_bitrate (buf, amrwb))) {</span>
                  gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">!                     GST_TAG_MAXIMUM_BITRATE, bitrate, NULL);</span>
<span class="line-modified">!               }</span>
  
                gst_caps_set_simple (entry-&gt;caps,
<span class="line-modified">!                   &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">!               gst_buffer_unref (buf);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             break;</span>
            }
            case FOURCC_mp4a:
            {
              /* mp4a atom withtout ESDS; Attempt to build codec data from atom */
              gint len = QT_UINT32 (stsd_entry_data);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11610,107 ***</span>
              break;
            }
            case FOURCC_lpcm:
              /* Fully handled elsewhere */
              break;
<span class="line-modified">!         default:</span>
<span class="line-modified">!           GST_INFO_OBJECT (qtdemux,</span>
<span class="line-modified">!               &quot;unhandled type %&quot; GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));</span>
<span class="line-modified">!           break;</span>
        }
<span class="line-modified">!     }</span>
<span class="line-modified">!     GST_INFO_OBJECT (qtdemux,</span>
<span class="line-removed">-         &quot;type %&quot; GST_FOURCC_FORMAT &quot; caps %&quot; GST_PTR_FORMAT,</span>
            GST_FOURCC_ARGS (fourcc), entry-&gt;caps);
  
<span class="line-modified">!   } else if (stream-&gt;subtype == FOURCC_strm) {</span>
<span class="line-modified">!     if (fourcc == FOURCC_rtsp) {</span>
<span class="line-modified">!       stream-&gt;redirect_uri = qtdemux_get_rtsp_uri_from_hndl (qtdemux, minf);</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       GST_INFO_OBJECT (qtdemux, &quot;unhandled stream type %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">!           GST_FOURCC_ARGS (fourcc));</span>
<span class="line-modified">!       goto unknown_stream;</span>
<span class="line-modified">!     }</span>
        entry-&gt;sampled = TRUE;
<span class="line-modified">!   } else if (stream-&gt;subtype == FOURCC_subp || stream-&gt;subtype == FOURCC_text</span>
<span class="line-modified">!         || stream-&gt;subtype == FOURCC_sbtl || stream-&gt;subtype == FOURCC_subt) {</span>
  
        entry-&gt;sampled = TRUE;
        entry-&gt;sparse = TRUE;
  
        entry-&gt;caps =
            qtdemux_sub_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,
            &amp;codec);
<span class="line-modified">!     if (codec) {</span>
          gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">!           GST_TAG_SUBTITLE_CODEC, codec, NULL);</span>
<span class="line-modified">!       g_free (codec);</span>
<span class="line-modified">!       codec = NULL;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     /* hunt for sort-of codec data */</span>
<span class="line-modified">!     switch (fourcc) {</span>
<span class="line-modified">!       case FOURCC_mp4s:</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         GNode *mp4s = NULL;</span>
<span class="line-modified">!         GNode *esds = NULL;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /* look for palette in a stsd-&gt;mp4s-&gt;esds sub-atom */</span>
<span class="line-modified">!         mp4s = qtdemux_tree_get_child_by_type (stsd, FOURCC_mp4s);</span>
<span class="line-modified">!         if (mp4s)</span>
<span class="line-modified">!           esds = qtdemux_tree_get_child_by_type (mp4s, FOURCC_esds);</span>
<span class="line-modified">!         if (esds == NULL) {</span>
<span class="line-modified">!           /* Invalid STSD */</span>
<span class="line-modified">!           GST_LOG_OBJECT (qtdemux, &quot;Skipping invalid stsd: no esds child&quot;);</span>
<span class="line-modified">!           break;</span>
            }
  
            gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
                stream-&gt;stream_tags);
<span class="line-modified">!         break;</span>
        }
<span class="line-modified">!       default:</span>
<span class="line-modified">!         GST_INFO_OBJECT (qtdemux,</span>
<span class="line-removed">-             &quot;unhandled type %&quot; GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     GST_INFO_OBJECT (qtdemux,</span>
<span class="line-removed">-         &quot;type %&quot; GST_FOURCC_FORMAT &quot; caps %&quot; GST_PTR_FORMAT,</span>
            GST_FOURCC_ARGS (fourcc), entry-&gt;caps);
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     /* everything in 1 sample */</span>
        entry-&gt;sampled = TRUE;
  
        entry-&gt;caps =
            qtdemux_generic_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,
            &amp;codec);
  
        if (entry-&gt;caps == NULL)
<span class="line-modified">!     goto unknown_stream;</span>
  
<span class="line-modified">!     if (codec) {</span>
          gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">!           GST_TAG_SUBTITLE_CODEC, codec, NULL);</span>
<span class="line-modified">!       g_free (codec);</span>
<span class="line-modified">!       codec = NULL;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   /* promote to sampled format */</span>
      if (entry-&gt;fourcc == FOURCC_samr) {
<span class="line-modified">!     /* force mono 8000 Hz for AMR */</span>
        entry-&gt;sampled = TRUE;
        entry-&gt;n_channels = 1;
        entry-&gt;rate = 8000;
      } else if (entry-&gt;fourcc == FOURCC_sawb) {
<span class="line-modified">!     /* force mono 16000 Hz for AMR-WB */</span>
        entry-&gt;sampled = TRUE;
        entry-&gt;n_channels = 1;
        entry-&gt;rate = 16000;
      } else if (entry-&gt;fourcc == FOURCC_mp4a) {
        entry-&gt;sampled = TRUE;
<span class="line-modified">!   }</span>
  
  
      stsd_entry_data += len;
      remaining_stsd_len -= len;
  
<span class="line-new-header">--- 12442,108 ---</span>
              break;
            }
            case FOURCC_lpcm:
              /* Fully handled elsewhere */
              break;
<span class="line-modified">!           default:</span>
<span class="line-modified">!             GST_INFO_OBJECT (qtdemux,</span>
<span class="line-modified">!                 &quot;unhandled type %&quot; GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));</span>
<span class="line-modified">!             break;</span>
<span class="line-added">+         }</span>
        }
<span class="line-modified">!       GST_INFO_OBJECT (qtdemux,</span>
<span class="line-modified">!           &quot;type %&quot; GST_FOURCC_FORMAT &quot; caps %&quot; GST_PTR_FORMAT,</span>
            GST_FOURCC_ARGS (fourcc), entry-&gt;caps);
  
<span class="line-modified">!     } else if (stream-&gt;subtype == FOURCC_strm) {</span>
<span class="line-modified">!       if (fourcc == FOURCC_rtsp) {</span>
<span class="line-modified">!         stream-&gt;redirect_uri = qtdemux_get_rtsp_uri_from_hndl (qtdemux, minf);</span>
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         GST_INFO_OBJECT (qtdemux, &quot;unhandled stream type %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">!             GST_FOURCC_ARGS (fourcc));</span>
<span class="line-modified">!         goto unknown_stream;</span>
<span class="line-modified">!       }</span>
        entry-&gt;sampled = TRUE;
<span class="line-modified">!     } else if (stream-&gt;subtype == FOURCC_subp || stream-&gt;subtype == FOURCC_text</span>
<span class="line-modified">!         || stream-&gt;subtype == FOURCC_sbtl || stream-&gt;subtype == FOURCC_subt</span>
<span class="line-added">+         || stream-&gt;subtype == FOURCC_clcp) {</span>
  
        entry-&gt;sampled = TRUE;
        entry-&gt;sparse = TRUE;
  
        entry-&gt;caps =
            qtdemux_sub_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,
            &amp;codec);
<span class="line-modified">!       if (codec) {</span>
          gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">!             GST_TAG_SUBTITLE_CODEC, codec, NULL);</span>
<span class="line-modified">!         g_free (codec);</span>
<span class="line-modified">!         codec = NULL;</span>
<span class="line-modified">!       }</span>
  
<span class="line-modified">!       /* hunt for sort-of codec data */</span>
<span class="line-modified">!       switch (fourcc) {</span>
<span class="line-modified">!         case FOURCC_mp4s:</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           GNode *mp4s = NULL;</span>
<span class="line-modified">!           GNode *esds = NULL;</span>
<span class="line-modified">! </span>
<span class="line-modified">!           /* look for palette in a stsd-&gt;mp4s-&gt;esds sub-atom */</span>
<span class="line-modified">!           mp4s = qtdemux_tree_get_child_by_type (stsd, FOURCC_mp4s);</span>
<span class="line-modified">!           if (mp4s)</span>
<span class="line-modified">!             esds = qtdemux_tree_get_child_by_type (mp4s, FOURCC_esds);</span>
<span class="line-modified">!           if (esds == NULL) {</span>
<span class="line-modified">!             /* Invalid STSD */</span>
<span class="line-modified">!             GST_LOG_OBJECT (qtdemux, &quot;Skipping invalid stsd: no esds child&quot;);</span>
<span class="line-modified">!             break;</span>
            }
  
            gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
                stream-&gt;stream_tags);
<span class="line-modified">!           break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         default:</span>
<span class="line-added">+           GST_INFO_OBJECT (qtdemux,</span>
<span class="line-added">+               &quot;unhandled type %&quot; GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));</span>
<span class="line-added">+           break;</span>
        }
<span class="line-modified">!       GST_INFO_OBJECT (qtdemux,</span>
<span class="line-modified">!           &quot;type %&quot; GST_FOURCC_FORMAT &quot; caps %&quot; GST_PTR_FORMAT,</span>
            GST_FOURCC_ARGS (fourcc), entry-&gt;caps);
<span class="line-modified">!     } else {</span>
<span class="line-modified">!       /* everything in 1 sample */</span>
        entry-&gt;sampled = TRUE;
  
        entry-&gt;caps =
            qtdemux_generic_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,
            &amp;codec);
  
        if (entry-&gt;caps == NULL)
<span class="line-modified">!         goto unknown_stream;</span>
  
<span class="line-modified">!       if (codec) {</span>
          gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<span class="line-modified">!             GST_TAG_SUBTITLE_CODEC, codec, NULL);</span>
<span class="line-modified">!         g_free (codec);</span>
<span class="line-modified">!         codec = NULL;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     /* promote to sampled format */</span>
      if (entry-&gt;fourcc == FOURCC_samr) {
<span class="line-modified">!       /* force mono 8000 Hz for AMR */</span>
        entry-&gt;sampled = TRUE;
        entry-&gt;n_channels = 1;
        entry-&gt;rate = 8000;
      } else if (entry-&gt;fourcc == FOURCC_sawb) {
<span class="line-modified">!       /* force mono 16000 Hz for AMR-WB */</span>
        entry-&gt;sampled = TRUE;
        entry-&gt;n_channels = 1;
        entry-&gt;rate = 16000;
      } else if (entry-&gt;fourcc == FOURCC_mp4a) {
        entry-&gt;sampled = TRUE;
<span class="line-modified">!     }</span>
  
  
      stsd_entry_data += len;
      remaining_stsd_len -= len;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11758,76 ***</span>
    /* Check for UDTA tags */
    if ((udta = qtdemux_tree_get_child_by_type (trak, FOURCC_udta))) {
      qtdemux_parse_udta (qtdemux, stream-&gt;stream_tags, udta);
    }
  
<span class="line-modified">!   /* now we are ready to add the stream */</span>
<span class="line-modified">!   if (qtdemux-&gt;n_streams &gt;= GST_QTDEMUX_MAX_STREAMS)</span>
<span class="line-modified">!     goto too_many_streams;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (!qtdemux-&gt;got_moov) {</span>
<span class="line-modified">!     qtdemux-&gt;streams[qtdemux-&gt;n_streams] = stream;</span>
<span class="line-modified">!     qtdemux-&gt;n_streams++;</span>
<span class="line-removed">-     GST_DEBUG_OBJECT (qtdemux, &quot;n_streams is now %d&quot;, qtdemux-&gt;n_streams);</span>
<span class="line-removed">-   }</span>
  
    return TRUE;
  
  /* ERRORS */
<span class="line-removed">- skip_track:</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     GST_INFO_OBJECT (qtdemux, &quot;skip disabled track&quot;);</span>
<span class="line-removed">-     if (new_stream)</span>
<span class="line-removed">-       gst_qtdemux_stream_free (qtdemux, stream);</span>
<span class="line-removed">-     return TRUE;</span>
<span class="line-removed">-   }</span>
  corrupt_file:
    {
      GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
          (_(&quot;This file is corrupt and cannot be played.&quot;)), (NULL));
<span class="line-modified">!     if (new_stream)</span>
<span class="line-modified">!       gst_qtdemux_stream_free (qtdemux, stream);</span>
      return FALSE;
    }
  error_encrypted:
    {
      GST_ELEMENT_ERROR (qtdemux, STREAM, DECRYPT, (NULL), (NULL));
<span class="line-modified">!     if (new_stream)</span>
<span class="line-removed">-       gst_qtdemux_stream_free (qtdemux, stream);</span>
      return FALSE;
    }
  samples_failed:
  segments_failed:
    {
      /* we posted an error already */
      /* free stbl sub-atoms */
      gst_qtdemux_stbl_free (stream);
<span class="line-modified">!     if (new_stream)</span>
<span class="line-removed">-       gst_qtdemux_stream_free (qtdemux, stream);</span>
      return FALSE;
    }
  existing_stream:
    {
      GST_INFO_OBJECT (qtdemux, &quot;stream with track id %i already exists&quot;,
          track_id);
<span class="line-removed">-     if (new_stream)</span>
<span class="line-removed">-       gst_qtdemux_stream_free (qtdemux, stream);</span>
      return TRUE;
    }
  unknown_stream:
    {
      GST_INFO_OBJECT (qtdemux, &quot;unknown subtype %&quot; GST_FOURCC_FORMAT,
          GST_FOURCC_ARGS (stream-&gt;subtype));
<span class="line-modified">!     if (new_stream)</span>
<span class="line-removed">-       gst_qtdemux_stream_free (qtdemux, stream);</span>
<span class="line-removed">-     return TRUE;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- too_many_streams:</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     GST_ELEMENT_WARNING (qtdemux, STREAM, DEMUX,</span>
<span class="line-removed">-         (_(&quot;This file contains too many streams. Only playing first %d&quot;),</span>
<span class="line-removed">-             GST_QTDEMUX_MAX_STREAMS), (NULL));</span>
      return TRUE;
    }
  }
  
  /* If we can estimate the overall bitrate, and don&#39;t have information about the
<span class="line-new-header">--- 12591,55 ---</span>
    /* Check for UDTA tags */
    if ((udta = qtdemux_tree_get_child_by_type (trak, FOURCC_udta))) {
      qtdemux_parse_udta (qtdemux, stream-&gt;stream_tags, udta);
    }
  
<span class="line-modified">!   /* Insert and sort new stream in track-id order.</span>
<span class="line-modified">!    * This will help in comparing old/new streams during stream update check */</span>
<span class="line-modified">!   g_ptr_array_add (qtdemux-&gt;active_streams, stream);</span>
<span class="line-modified">!   g_ptr_array_sort (qtdemux-&gt;active_streams,</span>
<span class="line-modified">!       (GCompareFunc) qtdemux_track_id_compare_func);</span>
<span class="line-modified">!   GST_DEBUG_OBJECT (qtdemux, &quot;n_streams is now %d&quot;,</span>
<span class="line-modified">!       QTDEMUX_N_STREAMS (qtdemux));</span>
  
    return TRUE;
  
  /* ERRORS */
  corrupt_file:
    {
      GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
          (_(&quot;This file is corrupt and cannot be played.&quot;)), (NULL));
<span class="line-modified">!     if (stream)</span>
<span class="line-modified">!       gst_qtdemux_stream_unref (stream);</span>
      return FALSE;
    }
  error_encrypted:
    {
      GST_ELEMENT_ERROR (qtdemux, STREAM, DECRYPT, (NULL), (NULL));
<span class="line-modified">!     gst_qtdemux_stream_unref (stream);</span>
      return FALSE;
    }
  samples_failed:
  segments_failed:
    {
      /* we posted an error already */
      /* free stbl sub-atoms */
      gst_qtdemux_stbl_free (stream);
<span class="line-modified">!     gst_qtdemux_stream_unref (stream);</span>
      return FALSE;
    }
  existing_stream:
    {
      GST_INFO_OBJECT (qtdemux, &quot;stream with track id %i already exists&quot;,
          track_id);
      return TRUE;
    }
  unknown_stream:
    {
      GST_INFO_OBJECT (qtdemux, &quot;unknown subtype %&quot; GST_FOURCC_FORMAT,
          GST_FOURCC_ARGS (stream-&gt;subtype));
<span class="line-modified">!     gst_qtdemux_stream_unref (stream);</span>
      return TRUE;
    }
  }
  
  /* If we can estimate the overall bitrate, and don&#39;t have information about the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11839,12 ***</span>
  gst_qtdemux_guess_bitrate (GstQTDemux * qtdemux)
  {
    QtDemuxStream *stream = NULL;
    gint64 size, sys_bitrate, sum_bitrate = 0;
    GstClockTime duration;
<span class="line-removed">-   gint i;</span>
    guint bitrate;
  
    if (qtdemux-&gt;fragmented)
      return;
  
    GST_DEBUG_OBJECT (qtdemux, &quot;Looking for streams with unknown bitrate&quot;);
<span class="line-new-header">--- 12651,12 ---</span>
  gst_qtdemux_guess_bitrate (GstQTDemux * qtdemux)
  {
    QtDemuxStream *stream = NULL;
    gint64 size, sys_bitrate, sum_bitrate = 0;
    GstClockTime duration;
    guint bitrate;
<span class="line-added">+   gint i;</span>
  
    if (qtdemux-&gt;fragmented)
      return;
  
    GST_DEBUG_OBJECT (qtdemux, &quot;Looking for streams with unknown bitrate&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11868,38 ***</span>
    if (!gst_qtdemux_get_duration (qtdemux, &amp;duration)) {
      GST_DEBUG_OBJECT (qtdemux, &quot;Stream duration not known - bailing&quot;);
      return;
    }
  
<span class="line-modified">!   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
<span class="line-modified">!     switch (qtdemux-&gt;streams[i]-&gt;subtype) {</span>
        case FOURCC_soun:
        case FOURCC_vide:
          GST_DEBUG_OBJECT (qtdemux, &quot;checking bitrate for %&quot; GST_PTR_FORMAT,
<span class="line-modified">!             CUR_STREAM (qtdemux-&gt;streams[i])-&gt;caps);</span>
          /* retrieve bitrate, prefer avg then max */
          bitrate = 0;
<span class="line-modified">!         if (qtdemux-&gt;streams[i]-&gt;stream_tags) {</span>
<span class="line-modified">!           if (gst_tag_list_get_uint (qtdemux-&gt;streams[i]-&gt;stream_tags,</span>
                    GST_TAG_MAXIMUM_BITRATE, &amp;bitrate))
<span class="line-modified">!           GST_DEBUG_OBJECT (qtdemux, &quot;max-bitrate: %u&quot;, bitrate);</span>
<span class="line-modified">!           if (gst_tag_list_get_uint (qtdemux-&gt;streams[i]-&gt;stream_tags,</span>
                    GST_TAG_NOMINAL_BITRATE, &amp;bitrate))
<span class="line-modified">!           GST_DEBUG_OBJECT (qtdemux, &quot;nominal-bitrate: %u&quot;, bitrate);</span>
<span class="line-modified">!           if (gst_tag_list_get_uint (qtdemux-&gt;streams[i]-&gt;stream_tags,</span>
                    GST_TAG_BITRATE, &amp;bitrate))
<span class="line-modified">!           GST_DEBUG_OBJECT (qtdemux, &quot;bitrate: %u&quot;, bitrate);</span>
          }
          if (bitrate)
            sum_bitrate += bitrate;
          else {
            if (stream) {
              GST_DEBUG_OBJECT (qtdemux,
                  &quot;&gt;1 stream with unknown bitrate - bailing&quot;);
              return;
            } else
<span class="line-modified">!             stream = qtdemux-&gt;streams[i];</span>
          }
  
        default:
          /* For other subtypes, we assume no significant impact on bitrate */
          break;
<span class="line-new-header">--- 12680,39 ---</span>
    if (!gst_qtdemux_get_duration (qtdemux, &amp;duration)) {
      GST_DEBUG_OBJECT (qtdemux, &quot;Stream duration not known - bailing&quot;);
      return;
    }
  
<span class="line-modified">!   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified">!     QtDemuxStream *str = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added">+     switch (str-&gt;subtype) {</span>
        case FOURCC_soun:
        case FOURCC_vide:
          GST_DEBUG_OBJECT (qtdemux, &quot;checking bitrate for %&quot; GST_PTR_FORMAT,
<span class="line-modified">!             CUR_STREAM (str)-&gt;caps);</span>
          /* retrieve bitrate, prefer avg then max */
          bitrate = 0;
<span class="line-modified">!         if (str-&gt;stream_tags) {</span>
<span class="line-modified">!           if (gst_tag_list_get_uint (str-&gt;stream_tags,</span>
                    GST_TAG_MAXIMUM_BITRATE, &amp;bitrate))
<span class="line-modified">!             GST_DEBUG_OBJECT (qtdemux, &quot;max-bitrate: %u&quot;, bitrate);</span>
<span class="line-modified">!           if (gst_tag_list_get_uint (str-&gt;stream_tags,</span>
                    GST_TAG_NOMINAL_BITRATE, &amp;bitrate))
<span class="line-modified">!             GST_DEBUG_OBJECT (qtdemux, &quot;nominal-bitrate: %u&quot;, bitrate);</span>
<span class="line-modified">!           if (gst_tag_list_get_uint (str-&gt;stream_tags,</span>
                    GST_TAG_BITRATE, &amp;bitrate))
<span class="line-modified">!             GST_DEBUG_OBJECT (qtdemux, &quot;bitrate: %u&quot;, bitrate);</span>
          }
          if (bitrate)
            sum_bitrate += bitrate;
          else {
            if (stream) {
              GST_DEBUG_OBJECT (qtdemux,
                  &quot;&gt;1 stream with unknown bitrate - bailing&quot;);
              return;
            } else
<span class="line-modified">!             stream = str;</span>
          }
  
        default:
          /* For other subtypes, we assume no significant impact on bitrate */
          break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11935,21 ***</span>
  }
  
  static GstFlowReturn
  qtdemux_prepare_streams (GstQTDemux * qtdemux)
  {
<span class="line-removed">-   gint i;</span>
    GstFlowReturn ret = GST_FLOW_OK;
  
    GST_DEBUG_OBJECT (qtdemux, &quot;prepare streams&quot;);
  
<span class="line-modified">!   for (i = 0; ret == GST_FLOW_OK &amp;&amp; i &lt; qtdemux-&gt;n_streams; i++) {</span>
<span class="line-modified">!     QtDemuxStream *stream = qtdemux-&gt;streams[i];</span>
      guint32 sample_num = 0;
  
<span class="line-modified">!     GST_DEBUG_OBJECT (qtdemux, &quot;stream %d, id %d, fourcc %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">!         i, stream-&gt;track_id, GST_FOURCC_ARGS (CUR_STREAM (stream)-&gt;fourcc));</span>
  
      if (qtdemux-&gt;fragmented) {
        /* need all moov samples first */
        GST_OBJECT_LOCK (qtdemux);
        while (stream-&gt;n_samples == 0)
<span class="line-new-header">--- 12748,21 ---</span>
  }
  
  static GstFlowReturn
  qtdemux_prepare_streams (GstQTDemux * qtdemux)
  {
    GstFlowReturn ret = GST_FLOW_OK;
<span class="line-added">+   gint i;</span>
  
    GST_DEBUG_OBJECT (qtdemux, &quot;prepare streams&quot;);
  
<span class="line-modified">!   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified">!     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
      guint32 sample_num = 0;
  
<span class="line-modified">!     GST_DEBUG_OBJECT (qtdemux, &quot;track-id %u, fourcc %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">!         stream-&gt;track_id, GST_FOURCC_ARGS (CUR_STREAM (stream)-&gt;fourcc));</span>
  
      if (qtdemux-&gt;fragmented) {
        /* need all moov samples first */
        GST_OBJECT_LOCK (qtdemux);
        while (stream-&gt;n_samples == 0)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11968,105 ***</span>
      /* in pull mode, we should have parsed some sample info by now;
       * and quite some code will not handle no samples.
       * in push mode, we&#39;ll just have to deal with it */
      if (G_UNLIKELY (qtdemux-&gt;pullbased &amp;&amp; !stream-&gt;n_samples)) {
        GST_DEBUG_OBJECT (qtdemux, &quot;no samples for stream; discarding&quot;);
<span class="line-modified">!       gst_qtdemux_remove_stream (qtdemux, i);</span>
        i--;
        continue;
      }
  
      /* parse the initial sample for use in setting the frame rate cap */
      while (sample_num == 0 &amp;&amp; sample_num &lt; stream-&gt;n_samples) {
        if (!qtdemux_parse_samples (qtdemux, stream, sample_num))
          break;
        ++sample_num;
      }
<span class="line-modified">!     if (stream-&gt;n_samples &gt; 0 &amp;&amp; stream-&gt;stbl_index &gt;= 0) {</span>
<span class="line-removed">-       stream-&gt;first_duration = stream-&gt;samples[0].duration;</span>
<span class="line-removed">-       GST_LOG_OBJECT (qtdemux, &quot;stream %d first duration %u&quot;,</span>
<span class="line-removed">-           stream-&gt;track_id, stream-&gt;first_duration);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
  
    return ret;
  }
  
  static GstFlowReturn
  qtdemux_expose_streams (GstQTDemux * qtdemux)
  {
    gint i;
<span class="line-removed">-   GSList *oldpads = NULL;</span>
<span class="line-removed">-   GSList *iter;</span>
  
    GST_DEBUG_OBJECT (qtdemux, &quot;exposing streams&quot;);
  
<span class="line-modified">!   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
<span class="line-modified">!     QtDemuxStream *stream = qtdemux-&gt;streams[i];</span>
<span class="line-modified">!     GstPad *oldpad = stream-&gt;pad;</span>
<span class="line-modified">!     GstTagList *list;</span>
  
<span class="line-modified">!     GST_DEBUG_OBJECT (qtdemux, &quot;stream %d, id %d, fourcc %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">!         i, stream-&gt;track_id, GST_FOURCC_ARGS (CUR_STREAM (stream)-&gt;fourcc));</span>
  
<span class="line-modified">!     if ((stream-&gt;subtype == FOURCC_text || stream-&gt;subtype == FOURCC_sbtl) &amp;&amp;</span>
<span class="line-modified">!         stream-&gt;track_id == qtdemux-&gt;chapters_track_id) {</span>
<span class="line-removed">-       /* TODO - parse chapters track and expose it as GstToc; For now just ignore it</span>
<span class="line-removed">-          so that it doesn&#39;t look like a subtitle track */</span>
<span class="line-removed">-       gst_qtdemux_remove_stream (qtdemux, i);</span>
<span class="line-removed">-       i--;</span>
<span class="line-removed">-       continue;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     /* now we have all info and can expose */</span>
<span class="line-modified">!     list = stream-&gt;stream_tags;</span>
<span class="line-removed">-     stream-&gt;stream_tags = NULL;</span>
<span class="line-removed">-     if (oldpad)</span>
<span class="line-removed">-       oldpads = g_slist_prepend (oldpads, oldpad);</span>
<span class="line-removed">-     if (!gst_qtdemux_add_stream (qtdemux, stream, list))</span>
        return GST_FLOW_ERROR;
    }
  
    gst_qtdemux_guess_bitrate (qtdemux);
  
    gst_element_no_more_pads (GST_ELEMENT_CAST (qtdemux));
  
<span class="line-modified">!   for (iter = oldpads; iter; iter = g_slist_next (iter)) {</span>
<span class="line-modified">!     GstPad *oldpad = iter-&gt;data;</span>
<span class="line-modified">!     GstEvent *event;</span>
  
<span class="line-modified">!     event = gst_event_new_eos ();</span>
<span class="line-modified">!     if (qtdemux-&gt;segment_seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-modified">!       gst_event_set_seqnum (event, qtdemux-&gt;segment_seqnum);</span>
  
<span class="line-modified">!     gst_pad_push_event (oldpad, event);</span>
<span class="line-modified">!     gst_pad_set_active (oldpad, FALSE);</span>
<span class="line-removed">-     gst_element_remove_pad (GST_ELEMENT (qtdemux), oldpad);</span>
<span class="line-removed">-     gst_flow_combiner_remove_pad (qtdemux-&gt;flowcombiner, oldpad);</span>
<span class="line-removed">-     gst_object_unref (oldpad);</span>
    }
  
    /* check if we should post a redirect in case there is a single trak
     * and it is a redirecting trak */
<span class="line-modified">!   if (qtdemux-&gt;n_streams == 1 &amp;&amp; qtdemux-&gt;streams[0]-&gt;redirect_uri != NULL) {</span>
      GstMessage *m;
  
      GST_INFO_OBJECT (qtdemux, &quot;Issuing a redirect due to a single track with &quot;
          &quot;an external content&quot;);
      m = gst_message_new_element (GST_OBJECT_CAST (qtdemux),
          gst_structure_new (&quot;redirect&quot;,
<span class="line-modified">!             &quot;new-location&quot;, G_TYPE_STRING, qtdemux-&gt;streams[0]-&gt;redirect_uri,</span>
<span class="line-modified">!             NULL));</span>
      gst_element_post_message (GST_ELEMENT_CAST (qtdemux), m);
      qtdemux-&gt;posted_redirect = TRUE;
    }
  
<span class="line-modified">!   for (i = 0; i &lt; qtdemux-&gt;n_streams; i++) {</span>
<span class="line-modified">!     QtDemuxStream *stream = qtdemux-&gt;streams[i];</span>
  
<span class="line-modified">!     qtdemux_do_allocation (qtdemux, stream);</span>
<span class="line-removed">-   }</span>
  
    qtdemux-&gt;exposed = TRUE;
    return GST_FLOW_OK;
  }
  
<span class="line-new-header">--- 12781,235 ---</span>
      /* in pull mode, we should have parsed some sample info by now;
       * and quite some code will not handle no samples.
       * in push mode, we&#39;ll just have to deal with it */
      if (G_UNLIKELY (qtdemux-&gt;pullbased &amp;&amp; !stream-&gt;n_samples)) {
        GST_DEBUG_OBJECT (qtdemux, &quot;no samples for stream; discarding&quot;);
<span class="line-modified">!       g_ptr_array_remove_index (qtdemux-&gt;active_streams, i);</span>
<span class="line-added">+       i--;</span>
<span class="line-added">+       continue;</span>
<span class="line-added">+     } else if (stream-&gt;track_id == qtdemux-&gt;chapters_track_id &amp;&amp;</span>
<span class="line-added">+         (stream-&gt;subtype == FOURCC_text || stream-&gt;subtype == FOURCC_sbtl)) {</span>
<span class="line-added">+       /* TODO - parse chapters track and expose it as GstToc; For now just ignore it</span>
<span class="line-added">+          so that it doesn&#39;t look like a subtitle track */</span>
<span class="line-added">+       g_ptr_array_remove_index (qtdemux-&gt;active_streams, i);</span>
        i--;
        continue;
      }
  
      /* parse the initial sample for use in setting the frame rate cap */
      while (sample_num == 0 &amp;&amp; sample_num &lt; stream-&gt;n_samples) {
        if (!qtdemux_parse_samples (qtdemux, stream, sample_num))
          break;
        ++sample_num;
      }
<span class="line-modified">!   }</span>
  
    return ret;
  }
  
<span class="line-added">+ static gboolean</span>
<span class="line-added">+ _stream_equal_func (const QtDemuxStream * stream, const gchar * stream_id)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   return g_strcmp0 (stream-&gt;stream_id, stream_id) == 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static gboolean</span>
<span class="line-added">+ qtdemux_is_streams_update (GstQTDemux * qtdemux)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   gint i;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Different length, updated */</span>
<span class="line-added">+   if (QTDEMUX_N_STREAMS (qtdemux) != qtdemux-&gt;old_streams-&gt;len)</span>
<span class="line-added">+     return TRUE;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* streams in list are sorted in track-id order */</span>
<span class="line-added">+   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-added">+     /* Different stream-id, updated */</span>
<span class="line-added">+     if (g_strcmp0 (QTDEMUX_NTH_STREAM (qtdemux, i)-&gt;stream_id,</span>
<span class="line-added">+             QTDEMUX_NTH_OLD_STREAM (qtdemux, i)-&gt;stream_id))</span>
<span class="line-added">+       return TRUE;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return FALSE;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static gboolean</span>
<span class="line-added">+ qtdemux_reuse_and_configure_stream (GstQTDemux * qtdemux,</span>
<span class="line-added">+     QtDemuxStream * oldstream, QtDemuxStream * newstream)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   /* Connect old stream&#39;s srcpad to new stream */</span>
<span class="line-added">+   newstream-&gt;pad = oldstream-&gt;pad;</span>
<span class="line-added">+   oldstream-&gt;pad = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* unset new_stream to prevent stream-start event */</span>
<span class="line-added">+   newstream-&gt;new_stream = FALSE;</span>
<span class="line-added">+ </span>
<span class="line-added">+   return gst_qtdemux_configure_stream (qtdemux, newstream);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* g_ptr_array_find_with_equal_func is available since 2.54,</span>
<span class="line-added">+  * replacement until we can depend unconditionally on the real one in GLib */</span>
<span class="line-added">+ #if !GLIB_CHECK_VERSION(2,54,0)</span>
<span class="line-added">+ #define g_ptr_array_find_with_equal_func qtdemux_ptr_array_find_with_equal_func</span>
<span class="line-added">+ static gboolean</span>
<span class="line-added">+ qtdemux_ptr_array_find_with_equal_func (GPtrArray * haystack,</span>
<span class="line-added">+     gconstpointer needle, GEqualFunc equal_func, guint * index_)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   guint i;</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_return_val_if_fail (haystack != NULL, FALSE);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (equal_func == NULL)</span>
<span class="line-added">+     equal_func = g_direct_equal;</span>
<span class="line-added">+ </span>
<span class="line-added">+   for (i = 0; i &lt; haystack-&gt;len; i++) {</span>
<span class="line-added">+     if (equal_func (g_ptr_array_index (haystack, i), needle)) {</span>
<span class="line-added">+       if (index_ != NULL)</span>
<span class="line-added">+         *index_ = i;</span>
<span class="line-added">+       return TRUE;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return FALSE;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ static gboolean</span>
<span class="line-added">+ qtdemux_update_streams (GstQTDemux * qtdemux)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   gint i;</span>
<span class="line-added">+   g_assert (qtdemux-&gt;streams_aware);</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* At below, figure out which stream in active_streams has identical stream-id</span>
<span class="line-added">+    * with that of in old_streams. If there is matching stream-id,</span>
<span class="line-added">+    * corresponding newstream will not be exposed again,</span>
<span class="line-added">+    * but demux will reuse srcpad of matched old stream</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * active_streams : newly created streams from the latest moov</span>
<span class="line-added">+    * old_streams : existing streams (belong to previous moov)</span>
<span class="line-added">+    */</span>
<span class="line-added">+ </span>
<span class="line-added">+   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-added">+     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added">+     QtDemuxStream *oldstream = NULL;</span>
<span class="line-added">+     guint target;</span>
<span class="line-added">+ </span>
<span class="line-added">+     GST_DEBUG_OBJECT (qtdemux, &quot;track-id %u, fourcc %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-added">+         stream-&gt;track_id, GST_FOURCC_ARGS (CUR_STREAM (stream)-&gt;fourcc));</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (g_ptr_array_find_with_equal_func (qtdemux-&gt;old_streams,</span>
<span class="line-added">+             stream-&gt;stream_id, (GEqualFunc) _stream_equal_func, &amp;target)) {</span>
<span class="line-added">+       oldstream = QTDEMUX_NTH_OLD_STREAM (qtdemux, target);</span>
<span class="line-added">+ </span>
<span class="line-added">+       /* null pad stream cannot be reused */</span>
<span class="line-added">+       if (oldstream-&gt;pad == NULL)</span>
<span class="line-added">+         oldstream = NULL;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (oldstream) {</span>
<span class="line-added">+       GST_DEBUG_OBJECT (qtdemux, &quot;Reuse track-id %d&quot;, oldstream-&gt;track_id);</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (!qtdemux_reuse_and_configure_stream (qtdemux, oldstream, stream))</span>
<span class="line-added">+         return FALSE;</span>
<span class="line-added">+ </span>
<span class="line-added">+       /* we don&#39;t need to preserve order of old streams */</span>
<span class="line-added">+       g_ptr_array_remove_fast (qtdemux-&gt;old_streams, oldstream);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       GstTagList *list;</span>
<span class="line-added">+ </span>
<span class="line-added">+       /* now we have all info and can expose */</span>
<span class="line-added">+       list = stream-&gt;stream_tags;</span>
<span class="line-added">+       stream-&gt;stream_tags = NULL;</span>
<span class="line-added">+       if (!gst_qtdemux_add_stream (qtdemux, stream, list))</span>
<span class="line-added">+         return FALSE;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return TRUE;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* Must be called with expose lock */</span>
  static GstFlowReturn
  qtdemux_expose_streams (GstQTDemux * qtdemux)
  {
    gint i;
  
    GST_DEBUG_OBJECT (qtdemux, &quot;exposing streams&quot;);
  
<span class="line-modified">!   if (!qtdemux_is_streams_update (qtdemux)) {</span>
<span class="line-modified">!     GST_DEBUG_OBJECT (qtdemux, &quot;Reuse all streams&quot;);</span>
<span class="line-modified">!     for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified">!       QtDemuxStream *new_stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added">+       QtDemuxStream *old_stream = QTDEMUX_NTH_OLD_STREAM (qtdemux, i);</span>
<span class="line-added">+       if (!qtdemux_reuse_and_configure_stream (qtdemux, old_stream, new_stream))</span>
<span class="line-added">+         return GST_FLOW_ERROR;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     g_ptr_array_set_size (qtdemux-&gt;old_streams, 0);</span>
<span class="line-modified">!     qtdemux-&gt;need_segment = TRUE;</span>
  
<span class="line-modified">!     return GST_FLOW_OK;</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   if (qtdemux-&gt;streams_aware) {</span>
<span class="line-modified">!     if (!qtdemux_update_streams (qtdemux))</span>
        return GST_FLOW_ERROR;
<span class="line-added">+   } else {</span>
<span class="line-added">+     for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-added">+       QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added">+       GstTagList *list;</span>
<span class="line-added">+ </span>
<span class="line-added">+       /* now we have all info and can expose */</span>
<span class="line-added">+       list = stream-&gt;stream_tags;</span>
<span class="line-added">+       stream-&gt;stream_tags = NULL;</span>
<span class="line-added">+       if (!gst_qtdemux_add_stream (qtdemux, stream, list))</span>
<span class="line-added">+         return GST_FLOW_ERROR;</span>
<span class="line-added">+ </span>
<span class="line-added">+     }</span>
    }
  
    gst_qtdemux_guess_bitrate (qtdemux);
  
    gst_element_no_more_pads (GST_ELEMENT_CAST (qtdemux));
  
<span class="line-modified">!   /* If we have still old_streams, it&#39;s no more used stream */</span>
<span class="line-modified">!   for (i = 0; i &lt; qtdemux-&gt;old_streams-&gt;len; i++) {</span>
<span class="line-modified">!     QtDemuxStream *stream = QTDEMUX_NTH_OLD_STREAM (qtdemux, i);</span>
  
<span class="line-modified">!     if (stream-&gt;pad) {</span>
<span class="line-modified">!       GstEvent *event;</span>
<span class="line-modified">! </span>
<span class="line-added">+       event = gst_event_new_eos ();</span>
<span class="line-added">+       if (qtdemux-&gt;segment_seqnum)</span>
<span class="line-added">+         gst_event_set_seqnum (event, qtdemux-&gt;segment_seqnum);</span>
  
<span class="line-modified">!       gst_pad_push_event (stream-&gt;pad, event);</span>
<span class="line-modified">!     }</span>
    }
  
<span class="line-added">+   g_ptr_array_set_size (qtdemux-&gt;old_streams, 0);</span>
<span class="line-added">+ </span>
    /* check if we should post a redirect in case there is a single trak
     * and it is a redirecting trak */
<span class="line-modified">!   if (QTDEMUX_N_STREAMS (qtdemux) == 1 &amp;&amp;</span>
<span class="line-added">+       QTDEMUX_NTH_STREAM (qtdemux, 0)-&gt;redirect_uri != NULL) {</span>
      GstMessage *m;
  
      GST_INFO_OBJECT (qtdemux, &quot;Issuing a redirect due to a single track with &quot;
          &quot;an external content&quot;);
      m = gst_message_new_element (GST_OBJECT_CAST (qtdemux),
          gst_structure_new (&quot;redirect&quot;,
<span class="line-modified">!             &quot;new-location&quot;, G_TYPE_STRING,</span>
<span class="line-modified">!             QTDEMUX_NTH_STREAM (qtdemux, 0)-&gt;redirect_uri, NULL));</span>
      gst_element_post_message (GST_ELEMENT_CAST (qtdemux), m);
      qtdemux-&gt;posted_redirect = TRUE;
    }
  
<span class="line-modified">!   g_ptr_array_foreach (qtdemux-&gt;active_streams,</span>
<span class="line-modified">!       (GFunc) qtdemux_do_allocation, qtdemux);</span>
  
<span class="line-modified">!   qtdemux-&gt;need_segment = TRUE;</span>
  
    qtdemux-&gt;exposed = TRUE;
    return GST_FLOW_OK;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12345,12 ***</span>
              &quot; %s(%d): %s&quot;, charset, g_quark_to_string (err-&gt;domain), err-&gt;code,
              err-&gt;message);
          g_error_free (err);
        }
      } else {
<span class="line-modified">!     s = gst_tag_freeform_string_to_utf8 ((char *) node-&gt;data + offset,</span>
<span class="line-modified">!         len - offset, env_vars);</span>
      }
      if (s) {
        GST_DEBUG_OBJECT (qtdemux, &quot;adding tag %s&quot;, GST_STR_NULL (s));
        gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, s, NULL);
        g_free (s);
<span class="line-new-header">--- 13288,12 ---</span>
              &quot; %s(%d): %s&quot;, charset, g_quark_to_string (err-&gt;domain), err-&gt;code,
              err-&gt;message);
          g_error_free (err);
        }
      } else {
<span class="line-modified">!       s = gst_tag_freeform_string_to_utf8 ((char *) node-&gt;data + offset,</span>
<span class="line-modified">!           len - offset, env_vars);</span>
      }
      if (s) {
        GST_DEBUG_OBJECT (qtdemux, &quot;adding tag %s&quot;, GST_STR_NULL (s));
        gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, s, NULL);
        g_free (s);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12563,10 ***</span>
<span class="line-new-header">--- 13506,11 ---</span>
  static void
  qtdemux_tag_add_date (GstQTDemux * qtdemux, GstTagList * taglist,
      const char *tag, const char *dummy, GNode * node)
  {
    GNode *data;
<span class="line-added">+   GstDateTime *datetime = NULL;</span>
    char *s;
    int len;
    int type;
  
    data = qtdemux_tree_get_child_by_type (node, FOURCC_data);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12577,10 ***</span>
<span class="line-new-header">--- 13521,17 ---</span>
        guint y, m = 1, d = 1;
        gint ret;
  
        s = g_strndup ((char *) data-&gt;data + 16, len - 16);
        GST_DEBUG_OBJECT (qtdemux, &quot;adding date &#39;%s&#39;&quot;, s);
<span class="line-added">+       datetime = gst_date_time_new_from_iso8601_string (s);</span>
<span class="line-added">+       if (datetime != NULL) {</span>
<span class="line-added">+         gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, GST_TAG_DATE_TIME,</span>
<span class="line-added">+             datetime, NULL);</span>
<span class="line-added">+         gst_date_time_unref (datetime);</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
        ret = sscanf (s, &quot;%u-%u-%u&quot;, &amp;y, &amp;m, &amp;d);
        if (ret &gt;= 1 &amp;&amp; y &gt; 1500 &amp;&amp; y &lt; 3000) {
          GDate *date;
  
          date = g_date_new_dmy (d, m, y);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 12780,11 ***</span>
  
      g_free (namestr_dbg);
      g_free (meanstr_dbg);
    }
  #endif
<span class="line-modified">!     return;</span>
  }
  
  static void
  qtdemux_tag_add_id32 (GstQTDemux * demux, GstTagList * taglist, const char *tag,
      const char *tag_bis, GNode * node)
<span class="line-new-header">--- 13731,11 ---</span>
  
      g_free (namestr_dbg);
      g_free (meanstr_dbg);
    }
  #endif
<span class="line-modified">!   return;</span>
  }
  
  static void
  qtdemux_tag_add_id32 (GstQTDemux * demux, GstTagList * taglist, const char *tag,
      const char *tag_bis, GNode * node)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13157,45 ***</span>
          guint8 *ref_data;
          guint ref_len;
  
          ref_len = QT_UINT32 ((guint8 *) rdrf-&gt;data);
          if (ref_len &gt; 20) {
<span class="line-modified">!         ref_type = QT_FOURCC ((guint8 *) rdrf-&gt;data + 12);</span>
<span class="line-modified">!         ref_data = (guint8 *) rdrf-&gt;data + 20;</span>
<span class="line-modified">!         if (ref_type == FOURCC_alis) {</span>
<span class="line-modified">!           guint record_len, record_version, fn_len;</span>
  
              if (ref_len &gt; 70) {
<span class="line-modified">!           /* MacOSX alias record, google for alias-layout.txt */</span>
<span class="line-modified">!           record_len = QT_UINT16 (ref_data + 4);</span>
<span class="line-modified">!           record_version = QT_UINT16 (ref_data + 4 + 2);</span>
<span class="line-modified">!           fn_len = QT_UINT8 (ref_data + 50);</span>
<span class="line-modified">!           if (record_len &gt; 50 &amp;&amp; record_version == 2 &amp;&amp; fn_len &gt; 0) {</span>
<span class="line-modified">!             ref.location = g_strndup ((gchar *) ref_data + 51, fn_len);</span>
<span class="line-modified">!           }</span>
              } else {
                GST_WARNING_OBJECT (qtdemux, &quot;Invalid rdrf/alis size (%u &lt; 70)&quot;,
                    ref_len);
              }
<span class="line-modified">!         } else if (ref_type == FOURCC_url_) {</span>
              ref.location = g_strndup ((gchar *) ref_data, ref_len - 8);
<span class="line-modified">!         } else {</span>
<span class="line-modified">!           GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-modified">!               &quot;unknown rdrf reference type %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">!               GST_FOURCC_ARGS (ref_type));</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (ref.location != NULL) {</span>
<span class="line-modified">!           GST_INFO_OBJECT (qtdemux, &quot;New location: %s&quot;, ref.location);</span>
              redirects =
                  g_list_prepend (redirects, g_memdup (&amp;ref, sizeof (ref)));
<span class="line-modified">!         } else {</span>
<span class="line-modified">!           GST_WARNING_OBJECT (qtdemux,</span>
<span class="line-modified">!               &quot;Failed to extract redirect location from rdrf atom&quot;);</span>
<span class="line-modified">!         }</span>
          } else {
            GST_WARNING_OBJECT (qtdemux, &quot;Invalid rdrf size (%u &lt; 20)&quot;, ref_len);
<span class="line-modified">!       }</span>
        }
  
        /* look for others */
        rmda = qtdemux_tree_get_sibling_by_type (rmda, FOURCC_rmda);
      }
<span class="line-new-header">--- 14108,45 ---</span>
          guint8 *ref_data;
          guint ref_len;
  
          ref_len = QT_UINT32 ((guint8 *) rdrf-&gt;data);
          if (ref_len &gt; 20) {
<span class="line-modified">!           ref_type = QT_FOURCC ((guint8 *) rdrf-&gt;data + 12);</span>
<span class="line-modified">!           ref_data = (guint8 *) rdrf-&gt;data + 20;</span>
<span class="line-modified">!           if (ref_type == FOURCC_alis) {</span>
<span class="line-modified">!             guint record_len, record_version, fn_len;</span>
  
              if (ref_len &gt; 70) {
<span class="line-modified">!               /* MacOSX alias record, google for alias-layout.txt */</span>
<span class="line-modified">!               record_len = QT_UINT16 (ref_data + 4);</span>
<span class="line-modified">!               record_version = QT_UINT16 (ref_data + 4 + 2);</span>
<span class="line-modified">!               fn_len = QT_UINT8 (ref_data + 50);</span>
<span class="line-modified">!               if (record_len &gt; 50 &amp;&amp; record_version == 2 &amp;&amp; fn_len &gt; 0) {</span>
<span class="line-modified">!                 ref.location = g_strndup ((gchar *) ref_data + 51, fn_len);</span>
<span class="line-modified">!               }</span>
              } else {
                GST_WARNING_OBJECT (qtdemux, &quot;Invalid rdrf/alis size (%u &lt; 70)&quot;,
                    ref_len);
              }
<span class="line-modified">!           } else if (ref_type == FOURCC_url_) {</span>
              ref.location = g_strndup ((gchar *) ref_data, ref_len - 8);
<span class="line-modified">!           } else {</span>
<span class="line-modified">!             GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-modified">!                 &quot;unknown rdrf reference type %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">!                 GST_FOURCC_ARGS (ref_type));</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!           if (ref.location != NULL) {</span>
<span class="line-modified">!             GST_INFO_OBJECT (qtdemux, &quot;New location: %s&quot;, ref.location);</span>
              redirects =
                  g_list_prepend (redirects, g_memdup (&amp;ref, sizeof (ref)));
<span class="line-modified">!           } else {</span>
<span class="line-modified">!             GST_WARNING_OBJECT (qtdemux,</span>
<span class="line-modified">!                 &quot;Failed to extract redirect location from rdrf atom&quot;);</span>
<span class="line-modified">!           }</span>
          } else {
            GST_WARNING_OBJECT (qtdemux, &quot;Invalid rdrf size (%u &lt; 20)&quot;, ref_len);
<span class="line-modified">!         }</span>
        }
  
        /* look for others */
        rmda = qtdemux_tree_get_sibling_by_type (rmda, FOURCC_rmda);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13246,18 ***</span>
  {
    GNode *mvhd;
    GNode *trak;
    GNode *udta;
    GNode *mvex;
<span class="line-removed">-   GstClockTime duration;</span>
    GNode *pssh;
    guint64 creation_time;
    GstDateTime *datetime = NULL;
    gint version;
  
    /* make sure we have a usable taglist */
<span class="line-modified">!     qtdemux-&gt;tag_list = gst_tag_list_make_writable (qtdemux-&gt;tag_list);</span>
  
    mvhd = qtdemux_tree_get_child_by_type (qtdemux-&gt;moov_node, FOURCC_mvhd);
    if (mvhd == NULL) {
      GST_LOG_OBJECT (qtdemux, &quot;No mvhd node found, looking for redirects.&quot;);
      return qtdemux_parse_redirects (qtdemux);
<span class="line-new-header">--- 14197,17 ---</span>
  {
    GNode *mvhd;
    GNode *trak;
    GNode *udta;
    GNode *mvex;
    GNode *pssh;
    guint64 creation_time;
    GstDateTime *datetime = NULL;
    gint version;
  
    /* make sure we have a usable taglist */
<span class="line-modified">!   qtdemux-&gt;tag_list = gst_tag_list_make_writable (qtdemux-&gt;tag_list);</span>
  
    mvhd = qtdemux_tree_get_child_by_type (qtdemux-&gt;moov_node, FOURCC_mvhd);
    if (mvhd == NULL) {
      GST_LOG_OBJECT (qtdemux, &quot;No mvhd node found, looking for redirects.&quot;);
      return qtdemux_parse_redirects (qtdemux);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13286,24 ***</span>
        creation_time -= QTDEMUX_SECONDS_FROM_1904_TO_1970;
        /* some data cleansing sanity */
        g_get_current_time (&amp;now);
        if (now.tv_sec + 24 * 3600 &lt; creation_time) {
          GST_DEBUG_OBJECT (qtdemux, &quot;discarding bogus future creation time&quot;);
<span class="line-modified">!     } else {</span>
          datetime = gst_date_time_new_from_unix_epoch_utc (creation_time);
<span class="line-modified">!     }</span>
      } else {
        GDateTime *base_dt = g_date_time_new_utc (1904, 1, 1, 0, 0, 0);
        GDateTime *dt, *dt_local;
  
        dt = g_date_time_add_seconds (base_dt, creation_time);
        dt_local = g_date_time_to_local (dt);
        datetime = gst_date_time_new_from_g_date_time (dt_local);
  
        g_date_time_unref (base_dt);
        g_date_time_unref (dt);
<span class="line-modified">!   }</span>
    }
    if (datetime) {
      /* Use KEEP as explicit tags should have a higher priority than mvhd tag */
      gst_tag_list_add (qtdemux-&gt;tag_list, GST_TAG_MERGE_KEEP, GST_TAG_DATE_TIME,
          datetime, NULL);
<span class="line-new-header">--- 14236,24 ---</span>
        creation_time -= QTDEMUX_SECONDS_FROM_1904_TO_1970;
        /* some data cleansing sanity */
        g_get_current_time (&amp;now);
        if (now.tv_sec + 24 * 3600 &lt; creation_time) {
          GST_DEBUG_OBJECT (qtdemux, &quot;discarding bogus future creation time&quot;);
<span class="line-modified">!       } else {</span>
          datetime = gst_date_time_new_from_unix_epoch_utc (creation_time);
<span class="line-modified">!       }</span>
      } else {
        GDateTime *base_dt = g_date_time_new_utc (1904, 1, 1, 0, 0, 0);
        GDateTime *dt, *dt_local;
  
        dt = g_date_time_add_seconds (base_dt, creation_time);
        dt_local = g_date_time_to_local (dt);
        datetime = gst_date_time_new_from_g_date_time (dt_local);
  
        g_date_time_unref (base_dt);
        g_date_time_unref (dt);
<span class="line-modified">!     }</span>
    }
    if (datetime) {
      /* Use KEEP as explicit tags should have a higher priority than mvhd tag */
      gst_tag_list_add (qtdemux-&gt;tag_list, GST_TAG_MERGE_KEEP, GST_TAG_DATE_TIME,
          datetime, NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13326,13 ***</span>
      mehd = qtdemux_tree_get_child_by_type_full (mvex, FOURCC_mehd, &amp;mehd_data);
      if (mehd)
        qtdemux_parse_mehd (qtdemux, &amp;mehd_data);
    }
  
<span class="line-modified">!   /* set duration in the segment info */</span>
<span class="line-modified">!   gst_qtdemux_get_duration (qtdemux, &amp;duration);</span>
<span class="line-modified">!   if (duration) {</span>
      qtdemux-&gt;segment.duration = duration;
      /* also do not exceed duration; stop is set that way post seek anyway,
       * and segment activation falls back to duration,
       * whereas loop only checks stop, so let&#39;s align this here as well */
      qtdemux-&gt;segment.stop = duration;
<span class="line-new-header">--- 14276,17 ---</span>
      mehd = qtdemux_tree_get_child_by_type_full (mvex, FOURCC_mehd, &amp;mehd_data);
      if (mehd)
        qtdemux_parse_mehd (qtdemux, &amp;mehd_data);
    }
  
<span class="line-modified">!   /* Update the movie segment duration, unless it was directly given to us</span>
<span class="line-modified">!    * by upstream. Otherwise let it as is, as we don&#39;t want to mangle the</span>
<span class="line-modified">!    * duration provided by upstream that may come e.g. from a MPD file. */</span>
<span class="line-added">+   if (!qtdemux-&gt;upstream_format_is_time) {</span>
<span class="line-added">+     GstClockTime duration;</span>
<span class="line-added">+     /* set duration in the segment info */</span>
<span class="line-added">+     gst_qtdemux_get_duration (qtdemux, &amp;duration);</span>
      qtdemux-&gt;segment.duration = duration;
      /* also do not exceed duration; stop is set that way post seek anyway,
       * and segment activation falls back to duration,
       * whereas loop only checks stop, so let&#39;s align this here as well */
      qtdemux-&gt;segment.stop = duration;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13403,10 ***</span>
<span class="line-new-header">--- 14357,85 ---</span>
    }
    *end_out = ptr;
    return len;
  }
  
<span class="line-added">+ static GList *</span>
<span class="line-added">+ parse_xiph_stream_headers (GstQTDemux * qtdemux, gpointer codec_data,</span>
<span class="line-added">+     gsize codec_data_size)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   GList *list = NULL;</span>
<span class="line-added">+   guint8 *p = codec_data;</span>
<span class="line-added">+   gint i, offset, num_packets;</span>
<span class="line-added">+   guint *length, last;</span>
<span class="line-added">+ </span>
<span class="line-added">+   GST_MEMDUMP_OBJECT (qtdemux, &quot;xiph codec data&quot;, codec_data, codec_data_size);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (codec_data == NULL || codec_data_size == 0)</span>
<span class="line-added">+     goto error;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* start of the stream and vorbis audio or theora video, need to</span>
<span class="line-added">+    * send the codec_priv data as first three packets */</span>
<span class="line-added">+   num_packets = p[0] + 1;</span>
<span class="line-added">+   GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-added">+       &quot;%u stream headers, total length=%&quot; G_GSIZE_FORMAT &quot; bytes&quot;,</span>
<span class="line-added">+       (guint) num_packets, codec_data_size);</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Let&#39;s put some limits, Don&#39;t think there even is a xiph codec</span>
<span class="line-added">+    * with more than 3-4 headers */</span>
<span class="line-added">+   if (G_UNLIKELY (num_packets &gt; 16)) {</span>
<span class="line-added">+     GST_WARNING_OBJECT (qtdemux,</span>
<span class="line-added">+         &quot;Unlikely number of xiph headers, most likely not valid&quot;);</span>
<span class="line-added">+     goto error;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   length = g_alloca (num_packets * sizeof (guint));</span>
<span class="line-added">+   last = 0;</span>
<span class="line-added">+   offset = 1;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* first packets, read length values */</span>
<span class="line-added">+   for (i = 0; i &lt; num_packets - 1; i++) {</span>
<span class="line-added">+     length[i] = 0;</span>
<span class="line-added">+     while (offset &lt; codec_data_size) {</span>
<span class="line-added">+       length[i] += p[offset];</span>
<span class="line-added">+       if (p[offset++] != 0xff)</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     last += length[i];</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (offset + last &gt; codec_data_size)</span>
<span class="line-added">+     goto error;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* last packet is the remaining size */</span>
<span class="line-added">+   length[i] = codec_data_size - offset - last;</span>
<span class="line-added">+ </span>
<span class="line-added">+   for (i = 0; i &lt; num_packets; i++) {</span>
<span class="line-added">+     GstBuffer *hdr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     GST_DEBUG_OBJECT (qtdemux, &quot;buffer %d: %u bytes&quot;, i, (guint) length[i]);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (offset + length[i] &gt; codec_data_size)</span>
<span class="line-added">+       goto error;</span>
<span class="line-added">+ </span>
<span class="line-added">+     hdr = gst_buffer_new_wrapped (g_memdup (p + offset, length[i]), length[i]);</span>
<span class="line-added">+     list = g_list_append (list, hdr);</span>
<span class="line-added">+ </span>
<span class="line-added">+     offset += length[i];</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return list;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* ERRORS */</span>
<span class="line-added">+ error:</span>
<span class="line-added">+   {</span>
<span class="line-added">+     if (list != NULL)</span>
<span class="line-added">+       g_list_free_full (list, (GDestroyNotify) gst_buffer_unref);</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  /* this can change the codec originally present in @list */
  #ifdef GSTREAMER_LITE
  static gboolean
  #else
  static void
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13419,10 ***</span>
<span class="line-new-header">--- 14448,11 ---</span>
    guint8 *end = ptr + len;
    int tag;
    guint8 *data_ptr = NULL;
    int data_len = 0;
    guint8 object_type_id = 0;
<span class="line-added">+   guint8 stream_type = 0;</span>
    const char *codec_name = NULL;
    GstCaps *caps = NULL;
  
    GST_MEMDUMP_OBJECT (qtdemux, &quot;esds&quot;, ptr, len);
    ptr += 8;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13439,22 ***</span>
      if (len &lt; 0 || ptr + len &gt; end)
        break;
  
      switch (tag) {
        case ES_DESCRIPTOR_TAG:
<span class="line-modified">!         GST_DEBUG_OBJECT (qtdemux, &quot;ID %04x&quot;, QT_UINT16 (ptr));</span>
<span class="line-modified">!         GST_DEBUG_OBJECT (qtdemux, &quot;priority %04x&quot;, QT_UINT8 (ptr + 2));</span>
          ptr += 3;
          break;
        case DECODER_CONFIG_DESC_TAG:{
          guint max_bitrate, avg_bitrate;
  
          object_type_id = QT_UINT8 (ptr);
          max_bitrate = QT_UINT32 (ptr + 5);
          avg_bitrate = QT_UINT32 (ptr + 9);
          GST_DEBUG_OBJECT (qtdemux, &quot;object_type_id %02x&quot;, object_type_id);
<span class="line-modified">!         GST_DEBUG_OBJECT (qtdemux, &quot;stream_type %02x&quot;, QT_UINT8 (ptr + 1));</span>
          GST_DEBUG_OBJECT (qtdemux, &quot;buffer_size_db %02x&quot;, QT_UINT24 (ptr + 2));
          GST_DEBUG_OBJECT (qtdemux, &quot;max bitrate %u&quot;, max_bitrate);
          GST_DEBUG_OBJECT (qtdemux, &quot;avg bitrate %u&quot;, avg_bitrate);
          if (max_bitrate &gt; 0 &amp;&amp; max_bitrate &lt; G_MAXUINT32) {
            gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
<span class="line-new-header">--- 14469,23 ---</span>
      if (len &lt; 0 || ptr + len &gt; end)
        break;
  
      switch (tag) {
        case ES_DESCRIPTOR_TAG:
<span class="line-modified">!         GST_DEBUG_OBJECT (qtdemux, &quot;ID 0x%04x&quot;, QT_UINT16 (ptr));</span>
<span class="line-modified">!         GST_DEBUG_OBJECT (qtdemux, &quot;priority 0x%04x&quot;, QT_UINT8 (ptr + 2));</span>
          ptr += 3;
          break;
        case DECODER_CONFIG_DESC_TAG:{
          guint max_bitrate, avg_bitrate;
  
          object_type_id = QT_UINT8 (ptr);
<span class="line-added">+         stream_type = QT_UINT8 (ptr + 1) &gt;&gt; 2;</span>
          max_bitrate = QT_UINT32 (ptr + 5);
          avg_bitrate = QT_UINT32 (ptr + 9);
          GST_DEBUG_OBJECT (qtdemux, &quot;object_type_id %02x&quot;, object_type_id);
<span class="line-modified">!         GST_DEBUG_OBJECT (qtdemux, &quot;stream_type %02x&quot;, stream_type);</span>
          GST_DEBUG_OBJECT (qtdemux, &quot;buffer_size_db %02x&quot;, QT_UINT24 (ptr + 2));
          GST_DEBUG_OBJECT (qtdemux, &quot;max bitrate %u&quot;, max_bitrate);
          GST_DEBUG_OBJECT (qtdemux, &quot;avg bitrate %u&quot;, avg_bitrate);
          if (max_bitrate &gt; 0 &amp;&amp; max_bitrate &lt; G_MAXUINT32) {
            gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13600,11 ***</span>
              profile = 2;
              break;
            default:
              profile = 3;
              break;
<span class="line-modified">!       }</span>
  
          codec_data[0] = ((profile + 1) &lt;&lt; 3) | ((rate_idx &amp; 0xE) &gt;&gt; 1);
          codec_data[1] =
              ((rate_idx &amp; 0x1) &lt;&lt; 7) | (CUR_STREAM (stream)-&gt;n_channels &lt;&lt; 3);
  
<span class="line-new-header">--- 14631,11 ---</span>
              profile = 2;
              break;
            default:
              profile = 3;
              break;
<span class="line-modified">!         }</span>
  
          codec_data[0] = ((profile + 1) &lt;&lt; 3) | ((rate_idx &amp; 0xE) &gt;&gt; 1);
          codec_data[1] =
              ((rate_idx &amp; 0x1) &lt;&lt; 7) | (CUR_STREAM (stream)-&gt;n_channels &lt;&lt; 3);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13670,10 ***</span>
<span class="line-new-header">--- 14701,39 ---</span>
      case 0xA9:                 /* AC3 */
        codec_name = &quot;DTS audio&quot;;
        caps = gst_caps_new_simple (&quot;audio/x-dts&quot;,
            &quot;framed&quot;, G_TYPE_BOOLEAN, TRUE, NULL);
        break;
<span class="line-added">+     case 0xDD:</span>
<span class="line-added">+       if (stream_type == 0x05 &amp;&amp; data_ptr) {</span>
<span class="line-added">+         GList *headers =</span>
<span class="line-added">+             parse_xiph_stream_headers (qtdemux, data_ptr, data_len);</span>
<span class="line-added">+         if (headers) {</span>
<span class="line-added">+           GList *tmp;</span>
<span class="line-added">+           GValue arr_val = G_VALUE_INIT;</span>
<span class="line-added">+           GValue buf_val = G_VALUE_INIT;</span>
<span class="line-added">+           GstStructure *s;</span>
<span class="line-added">+ </span>
<span class="line-added">+           /* Let&#39;s assume it&#39;s vorbis if it&#39;s an audio stream of type 0xdd and we have codec data that extracts properly */</span>
<span class="line-added">+           codec_name = &quot;Vorbis&quot;;</span>
<span class="line-added">+           caps = gst_caps_new_empty_simple (&quot;audio/x-vorbis&quot;);</span>
<span class="line-added">+           g_value_init (&amp;arr_val, GST_TYPE_ARRAY);</span>
<span class="line-added">+           g_value_init (&amp;buf_val, GST_TYPE_BUFFER);</span>
<span class="line-added">+           for (tmp = headers; tmp; tmp = tmp-&gt;next) {</span>
<span class="line-added">+             g_value_set_boxed (&amp;buf_val, (GstBuffer *) tmp-&gt;data);</span>
<span class="line-added">+             gst_value_array_append_value (&amp;arr_val, &amp;buf_val);</span>
<span class="line-added">+           }</span>
<span class="line-added">+           s = gst_caps_get_structure (caps, 0);</span>
<span class="line-added">+           gst_structure_take_value (s, &quot;streamheader&quot;, &amp;arr_val);</span>
<span class="line-added">+           g_value_unset (&amp;buf_val);</span>
<span class="line-added">+           g_list_free (headers);</span>
<span class="line-added">+ </span>
<span class="line-added">+           data_ptr = NULL;</span>
<span class="line-added">+           data_len = 0;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
      case 0xE1:                 /* QCELP */
        /* QCELP, the codec_data is a riff tag (little endian) with
         * more info (http://ftp.3gpp2.org/TSGC/Working/2003/2003-05-SanDiego/TSG-C-2003-05-San%20Diego/WG1/SWG12/C12-20030512-006%20=%20C12-20030217-015_Draft_Baseline%20Text%20of%20FFMS_R2.doc). */
        caps = gst_caps_new_empty_simple (&quot;audio/qcelp&quot;);
        codec_name = &quot;QCELP&quot;;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 13729,17 ***</span>
                        gst_caps_set_simple (entry-&gt;caps, &quot;esds_data&quot;, GST_TYPE_BUFFER,
                                     esds_buffer, NULL);
                    }
  
                    gst_buffer_unref (esds_buffer);
<span class="line-modified">!               }</span>
            }
                break;
            default:
                break;
        }
<span class="line-modified">! #endif</span>
  
    }
  
  #ifdef GSTREAMER_LITE
      return TRUE;
<span class="line-new-header">--- 14789,17 ---</span>
                        gst_caps_set_simple (entry-&gt;caps, &quot;esds_data&quot;, GST_TYPE_BUFFER,
                                     esds_buffer, NULL);
                    }
  
                    gst_buffer_unref (esds_buffer);
<span class="line-modified">!                }</span>
            }
                break;
            default:
                break;
        }
<span class="line-modified">! #endif // GSTREAMER_LITE</span>
  
    }
  
  #ifdef GSTREAMER_LITE
      return TRUE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14173,10 ***</span>
<span class="line-new-header">--- 15233,14 ---</span>
      case FOURCC_ovc1:
        _codec (&quot;VC-1&quot;);
        caps = gst_caps_new_simple (&quot;video/x-wmv&quot;,
            &quot;wmvversion&quot;, G_TYPE_INT, 3, &quot;format&quot;, G_TYPE_STRING, &quot;WVC1&quot;, NULL);
        break;
<span class="line-added">+     case FOURCC_av01:</span>
<span class="line-added">+       _codec (&quot;AV1&quot;);</span>
<span class="line-added">+       caps = gst_caps_new_empty_simple (&quot;video/x-av1&quot;);</span>
<span class="line-added">+       break;</span>
      case GST_MAKE_FOURCC (&#39;k&#39;, &#39;p&#39;, &#39;c&#39;, &#39;d&#39;):
      default:
      {
        caps = _get_unknown_codec_name (&quot;video&quot;, fourcc);
        break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14190,11 ***</span>
      gst_video_info_set_format (&amp;info, format, entry-&gt;width, entry-&gt;height);
  
      caps = gst_video_info_to_caps (&amp;info);
      *codec_name = gst_pb_utils_get_codec_description (caps);
  
<span class="line-modified">!   /* enable clipping for raw video streams */</span>
      stream-&gt;need_clip = TRUE;
      stream-&gt;alignment = 32;
    }
  
    return caps;
<span class="line-new-header">--- 15254,11 ---</span>
      gst_video_info_set_format (&amp;info, format, entry-&gt;width, entry-&gt;height);
  
      caps = gst_video_info_to_caps (&amp;info);
      *codec_name = gst_pb_utils_get_codec_description (caps);
  
<span class="line-modified">!     /* enable clipping for raw video streams */</span>
      stream-&gt;need_clip = TRUE;
      stream-&gt;alignment = 32;
    }
  
    return caps;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14244,11 ***</span>
  
        if (!endian)
          endian = G_LITTLE_ENDIAN;
  
        if (!format)
<span class="line-modified">!       format = gst_audio_format_build_integer (TRUE, endian, depth, depth);</span>
  
        str = g_strdup_printf (&quot;Raw %d-bit PCM audio&quot;, depth);
        _codec (str);
        g_free (str);
  
<span class="line-new-header">--- 15308,11 ---</span>
  
        if (!endian)
          endian = G_LITTLE_ENDIAN;
  
        if (!format)
<span class="line-modified">!         format = gst_audio_format_build_integer (TRUE, endian, depth, depth);</span>
  
        str = g_strdup_printf (&quot;Raw %d-bit PCM audio&quot;, depth);
        _codec (str);
        g_free (str);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 14567,10 ***</span>
<span class="line-new-header">--- 15631,26 ---</span>
        break;
      case FOURCC_stpp:
        _codec (&quot;XML subtitles&quot;);
        caps = gst_caps_new_empty_simple (&quot;application/ttml+xml&quot;);
        break;
<span class="line-added">+     case FOURCC_c608:</span>
<span class="line-added">+       _codec (&quot;CEA 608 Closed Caption&quot;);</span>
<span class="line-added">+       caps =</span>
<span class="line-added">+           gst_caps_new_simple (&quot;closedcaption/x-cea-608&quot;, &quot;format&quot;,</span>
<span class="line-added">+           G_TYPE_STRING, &quot;s334-1a&quot;, NULL);</span>
<span class="line-added">+       stream-&gt;need_process = TRUE;</span>
<span class="line-added">+       stream-&gt;need_split = TRUE;</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     case FOURCC_c708:</span>
<span class="line-added">+       _codec (&quot;CEA 708 Closed Caption&quot;);</span>
<span class="line-added">+       caps =</span>
<span class="line-added">+           gst_caps_new_simple (&quot;closedcaption/x-cea-708&quot;, &quot;format&quot;,</span>
<span class="line-added">+           G_TYPE_STRING, &quot;cdp&quot;, NULL);</span>
<span class="line-added">+       stream-&gt;need_process = TRUE;</span>
<span class="line-added">+       break;</span>
<span class="line-added">+ </span>
      default:
      {
        caps = _get_unknown_codec_name (&quot;text&quot;, fourcc);
        break;
      }
</pre>
<center><a href="properties.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="qtdemux.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>