<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gsourceclosure.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gsignal.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gsourceclosure.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gsourceclosure.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20 #include &quot;gsourceclosure.h&quot;
 21 #include &quot;gboxed.h&quot;
 22 #include &quot;genums.h&quot;
 23 #include &quot;gmarshal.h&quot;
 24 #include &quot;gvalue.h&quot;
 25 #include &quot;gvaluetypes.h&quot;
 26 #ifdef G_OS_UNIX
 27 #include &quot;glib-unix.h&quot;
 28 #endif
 29 
 30 G_DEFINE_BOXED_TYPE (GIOChannel, g_io_channel, g_io_channel_ref, g_io_channel_unref)
 31 
 32 GType
 33 g_io_condition_get_type (void)
 34 {
 35   static volatile GType etype = 0;
 36 
 37   if (g_once_init_enter (&amp;etype))
 38     {
 39       static const GFlagsValue values[] = {
<span class="line-modified"> 40     { G_IO_IN,   &quot;G_IO_IN&quot;,   &quot;in&quot; },</span>
<span class="line-modified"> 41     { G_IO_OUT,  &quot;G_IO_OUT&quot;,  &quot;out&quot; },</span>
<span class="line-modified"> 42     { G_IO_PRI,  &quot;G_IO_PRI&quot;,  &quot;pri&quot; },</span>
<span class="line-modified"> 43     { G_IO_ERR,  &quot;G_IO_ERR&quot;,  &quot;err&quot; },</span>
<span class="line-modified"> 44     { G_IO_HUP,  &quot;G_IO_HUP&quot;,  &quot;hup&quot; },</span>
<span class="line-modified"> 45     { G_IO_NVAL, &quot;G_IO_NVAL&quot;, &quot;nval&quot; },</span>
<span class="line-modified"> 46     { 0, NULL, NULL }</span>
 47       };
 48       GType type_id = g_flags_register_static (&quot;GIOCondition&quot;, values);
 49       g_once_init_leave (&amp;etype, type_id);
 50     }
 51   return etype;
 52 }
 53 
 54 /* We need to hand-write this marshaler, since it doesn&#39;t have an
 55  * instance object.
 56  */
 57 static void
 58 source_closure_marshal_BOOLEAN__VOID (GClosure     *closure,
<span class="line-modified"> 59                       GValue       *return_value,</span>
<span class="line-modified"> 60                       guint         n_param_values,</span>
<span class="line-modified"> 61                       const GValue *param_values,</span>
<span class="line-modified"> 62                       gpointer      invocation_hint,</span>
<span class="line-modified"> 63                       gpointer      marshal_data)</span>
 64 {
 65   GSourceFunc callback;
 66   GCClosure *cc = (GCClosure*) closure;
 67   gboolean v_return;
 68 
 69   g_return_if_fail (return_value != NULL);
 70   g_return_if_fail (n_param_values == 0);
 71 
 72   callback = (GSourceFunc) (marshal_data ? marshal_data : cc-&gt;callback);
 73 
 74   v_return = callback (closure-&gt;data);
 75 
 76   g_value_set_boolean (return_value, v_return);
 77 }
 78 
 79 static gboolean
 80 io_watch_closure_callback (GIOChannel   *channel,
<span class="line-modified"> 81                GIOCondition  condition,</span>
<span class="line-modified"> 82                gpointer      data)</span>
 83 {
 84   GClosure *closure = data;
 85 
 86   GValue params[2] = { G_VALUE_INIT, G_VALUE_INIT };
 87   GValue result_value = G_VALUE_INIT;
 88   gboolean result;
 89 
 90   g_value_init (&amp;result_value, G_TYPE_BOOLEAN);
 91   g_value_init (&amp;params[0], G_TYPE_IO_CHANNEL);
 92   g_value_set_boxed (&amp;params[0], channel);
 93 
 94   g_value_init (&amp;params[1], G_TYPE_IO_CONDITION);
 95   g_value_set_flags (&amp;params[1], condition);
 96 
 97   g_closure_invoke (closure, &amp;result_value, 2, params, NULL);
 98 
 99   result = g_value_get_boolean (&amp;result_value);
100   g_value_unset (&amp;result_value);
101   g_value_unset (&amp;params[0]);
102   g_value_unset (&amp;params[1]);
</pre>
<hr />
<pre>
172 
173 static gboolean
174 source_closure_callback (gpointer data)
175 {
176   GClosure *closure = data;
177   GValue result_value = G_VALUE_INIT;
178   gboolean result;
179 
180   g_value_init (&amp;result_value, G_TYPE_BOOLEAN);
181 
182   g_closure_invoke (closure, &amp;result_value, 0, NULL, NULL);
183 
184   result = g_value_get_boolean (&amp;result_value);
185   g_value_unset (&amp;result_value);
186 
187   return result;
188 }
189 
190 static void
191 closure_callback_get (gpointer     cb_data,
<span class="line-modified">192               GSource     *source,</span>
<span class="line-modified">193               GSourceFunc *func,</span>
<span class="line-modified">194               gpointer    *data)</span>
195 {
196   GSourceFunc closure_callback = source-&gt;source_funcs-&gt;closure_callback;
197 
198   if (!closure_callback)
199     {
200       if (source-&gt;source_funcs == &amp;g_io_watch_funcs)
201         closure_callback = (GSourceFunc)io_watch_closure_callback;
202       else if (source-&gt;source_funcs == &amp;g_child_watch_funcs)
203         closure_callback = (GSourceFunc)g_child_watch_closure_callback;
204 #ifdef G_OS_UNIX
205       else if (source-&gt;source_funcs == &amp;g_unix_fd_source_funcs)
206         closure_callback = (GSourceFunc)g_unix_fd_source_closure_callback;
207 #endif
208       else if (source-&gt;source_funcs == &amp;g_timeout_funcs ||
209 #ifdef G_OS_UNIX
210                source-&gt;source_funcs == &amp;g_unix_signal_funcs ||
211 #endif
212                source-&gt;source_funcs == &amp;g_idle_funcs)
213         closure_callback = source_closure_callback;
214     }
</pre>
<hr />
<pre>
226 static void
227 closure_invalidated (gpointer  user_data,
228                      GClosure *closure)
229 {
230   g_source_destroy (user_data);
231 }
232 
233 /**
234  * g_source_set_closure:
235  * @source: the source
236  * @closure: a #GClosure
237  *
238  * Set the callback for a source as a #GClosure.
239  *
240  * If the source is not one of the standard GLib types, the @closure_callback
241  * and @closure_marshal fields of the #GSourceFuncs structure must have been
242  * filled in with pointers to appropriate functions.
243  */
244 void
245 g_source_set_closure (GSource  *source,
<span class="line-modified">246               GClosure *closure)</span>
247 {
248   g_return_if_fail (source != NULL);
249   g_return_if_fail (closure != NULL);
250 
251   if (!source-&gt;source_funcs-&gt;closure_callback &amp;&amp;
252 #ifdef G_OS_UNIX
253       source-&gt;source_funcs != &amp;g_unix_fd_source_funcs &amp;&amp;
254       source-&gt;source_funcs != &amp;g_unix_signal_funcs &amp;&amp;
255 #endif
256       source-&gt;source_funcs != &amp;g_child_watch_funcs &amp;&amp;
257       source-&gt;source_funcs != &amp;g_io_watch_funcs &amp;&amp;
258       source-&gt;source_funcs != &amp;g_timeout_funcs &amp;&amp;
259       source-&gt;source_funcs != &amp;g_idle_funcs)
260     {
261       g_critical (G_STRLOC &quot;: closure cannot be set on GSource without GSourceFuncs::closure_callback&quot;);
262       return;
263     }
264 
265   g_closure_ref (closure);
266   g_closure_sink (closure);
267   g_source_set_callback_indirect (source, closure, &amp;closure_callback_funcs);
268 
269   g_closure_add_invalidate_notifier (closure, source, closure_invalidated);
270 
271   if (G_CLOSURE_NEEDS_MARSHAL (closure))
272     {
273       GClosureMarshal marshal = (GClosureMarshal)source-&gt;source_funcs-&gt;closure_marshal;
274       if (marshal)
<span class="line-modified">275     g_closure_set_marshal (closure, marshal);</span>
276       else if (source-&gt;source_funcs == &amp;g_idle_funcs ||
277 #ifdef G_OS_UNIX
278                source-&gt;source_funcs == &amp;g_unix_signal_funcs ||
279 #endif
280                source-&gt;source_funcs == &amp;g_timeout_funcs)
<span class="line-modified">281     g_closure_set_marshal (closure, source_closure_marshal_BOOLEAN__VOID);</span>
282       else
283         g_closure_set_marshal (closure, g_cclosure_marshal_generic);
284     }
285 }
286 
287 static void
288 dummy_closure_marshal (GClosure     *closure,
<span class="line-modified">289                GValue       *return_value,</span>
<span class="line-modified">290                guint         n_param_values,</span>
<span class="line-modified">291                const GValue *param_values,</span>
<span class="line-modified">292                gpointer      invocation_hint,</span>
<span class="line-modified">293                gpointer      marshal_data)</span>
294 {
295   if (G_VALUE_HOLDS_BOOLEAN (return_value))
296     g_value_set_boolean (return_value, TRUE);
297 }
298 
299 /**
300  * g_source_set_dummy_callback:
301  * @source: the source
302  *
303  * Sets a dummy callback for @source. The callback will do nothing, and
304  * if the source expects a #gboolean return value, it will return %TRUE.
305  * (If the source expects any other type of return value, it will return
306  * a 0/%NULL value; whatever g_value_init() initializes a #GValue to for
307  * that type.)
308  *
309  * If the source is not one of the standard GLib types, the
310  * @closure_callback and @closure_marshal fields of the #GSourceFuncs
311  * structure must have been filled in with pointers to appropriate
312  * functions.
313  */
</pre>
</td>
<td>
<hr />
<pre>
 20 #include &quot;gsourceclosure.h&quot;
 21 #include &quot;gboxed.h&quot;
 22 #include &quot;genums.h&quot;
 23 #include &quot;gmarshal.h&quot;
 24 #include &quot;gvalue.h&quot;
 25 #include &quot;gvaluetypes.h&quot;
 26 #ifdef G_OS_UNIX
 27 #include &quot;glib-unix.h&quot;
 28 #endif
 29 
 30 G_DEFINE_BOXED_TYPE (GIOChannel, g_io_channel, g_io_channel_ref, g_io_channel_unref)
 31 
 32 GType
 33 g_io_condition_get_type (void)
 34 {
 35   static volatile GType etype = 0;
 36 
 37   if (g_once_init_enter (&amp;etype))
 38     {
 39       static const GFlagsValue values[] = {
<span class="line-modified"> 40   { G_IO_IN,   &quot;G_IO_IN&quot;,   &quot;in&quot; },</span>
<span class="line-modified"> 41   { G_IO_OUT,  &quot;G_IO_OUT&quot;,  &quot;out&quot; },</span>
<span class="line-modified"> 42   { G_IO_PRI,  &quot;G_IO_PRI&quot;,  &quot;pri&quot; },</span>
<span class="line-modified"> 43   { G_IO_ERR,  &quot;G_IO_ERR&quot;,  &quot;err&quot; },</span>
<span class="line-modified"> 44   { G_IO_HUP,  &quot;G_IO_HUP&quot;,  &quot;hup&quot; },</span>
<span class="line-modified"> 45   { G_IO_NVAL, &quot;G_IO_NVAL&quot;, &quot;nval&quot; },</span>
<span class="line-modified"> 46   { 0, NULL, NULL }</span>
 47       };
 48       GType type_id = g_flags_register_static (&quot;GIOCondition&quot;, values);
 49       g_once_init_leave (&amp;etype, type_id);
 50     }
 51   return etype;
 52 }
 53 
 54 /* We need to hand-write this marshaler, since it doesn&#39;t have an
 55  * instance object.
 56  */
 57 static void
 58 source_closure_marshal_BOOLEAN__VOID (GClosure     *closure,
<span class="line-modified"> 59               GValue       *return_value,</span>
<span class="line-modified"> 60               guint         n_param_values,</span>
<span class="line-modified"> 61               const GValue *param_values,</span>
<span class="line-modified"> 62               gpointer      invocation_hint,</span>
<span class="line-modified"> 63               gpointer      marshal_data)</span>
 64 {
 65   GSourceFunc callback;
 66   GCClosure *cc = (GCClosure*) closure;
 67   gboolean v_return;
 68 
 69   g_return_if_fail (return_value != NULL);
 70   g_return_if_fail (n_param_values == 0);
 71 
 72   callback = (GSourceFunc) (marshal_data ? marshal_data : cc-&gt;callback);
 73 
 74   v_return = callback (closure-&gt;data);
 75 
 76   g_value_set_boolean (return_value, v_return);
 77 }
 78 
 79 static gboolean
 80 io_watch_closure_callback (GIOChannel   *channel,
<span class="line-modified"> 81          GIOCondition  condition,</span>
<span class="line-modified"> 82          gpointer      data)</span>
 83 {
 84   GClosure *closure = data;
 85 
 86   GValue params[2] = { G_VALUE_INIT, G_VALUE_INIT };
 87   GValue result_value = G_VALUE_INIT;
 88   gboolean result;
 89 
 90   g_value_init (&amp;result_value, G_TYPE_BOOLEAN);
 91   g_value_init (&amp;params[0], G_TYPE_IO_CHANNEL);
 92   g_value_set_boxed (&amp;params[0], channel);
 93 
 94   g_value_init (&amp;params[1], G_TYPE_IO_CONDITION);
 95   g_value_set_flags (&amp;params[1], condition);
 96 
 97   g_closure_invoke (closure, &amp;result_value, 2, params, NULL);
 98 
 99   result = g_value_get_boolean (&amp;result_value);
100   g_value_unset (&amp;result_value);
101   g_value_unset (&amp;params[0]);
102   g_value_unset (&amp;params[1]);
</pre>
<hr />
<pre>
172 
173 static gboolean
174 source_closure_callback (gpointer data)
175 {
176   GClosure *closure = data;
177   GValue result_value = G_VALUE_INIT;
178   gboolean result;
179 
180   g_value_init (&amp;result_value, G_TYPE_BOOLEAN);
181 
182   g_closure_invoke (closure, &amp;result_value, 0, NULL, NULL);
183 
184   result = g_value_get_boolean (&amp;result_value);
185   g_value_unset (&amp;result_value);
186 
187   return result;
188 }
189 
190 static void
191 closure_callback_get (gpointer     cb_data,
<span class="line-modified">192           GSource     *source,</span>
<span class="line-modified">193           GSourceFunc *func,</span>
<span class="line-modified">194           gpointer    *data)</span>
195 {
196   GSourceFunc closure_callback = source-&gt;source_funcs-&gt;closure_callback;
197 
198   if (!closure_callback)
199     {
200       if (source-&gt;source_funcs == &amp;g_io_watch_funcs)
201         closure_callback = (GSourceFunc)io_watch_closure_callback;
202       else if (source-&gt;source_funcs == &amp;g_child_watch_funcs)
203         closure_callback = (GSourceFunc)g_child_watch_closure_callback;
204 #ifdef G_OS_UNIX
205       else if (source-&gt;source_funcs == &amp;g_unix_fd_source_funcs)
206         closure_callback = (GSourceFunc)g_unix_fd_source_closure_callback;
207 #endif
208       else if (source-&gt;source_funcs == &amp;g_timeout_funcs ||
209 #ifdef G_OS_UNIX
210                source-&gt;source_funcs == &amp;g_unix_signal_funcs ||
211 #endif
212                source-&gt;source_funcs == &amp;g_idle_funcs)
213         closure_callback = source_closure_callback;
214     }
</pre>
<hr />
<pre>
226 static void
227 closure_invalidated (gpointer  user_data,
228                      GClosure *closure)
229 {
230   g_source_destroy (user_data);
231 }
232 
233 /**
234  * g_source_set_closure:
235  * @source: the source
236  * @closure: a #GClosure
237  *
238  * Set the callback for a source as a #GClosure.
239  *
240  * If the source is not one of the standard GLib types, the @closure_callback
241  * and @closure_marshal fields of the #GSourceFuncs structure must have been
242  * filled in with pointers to appropriate functions.
243  */
244 void
245 g_source_set_closure (GSource  *source,
<span class="line-modified">246           GClosure *closure)</span>
247 {
248   g_return_if_fail (source != NULL);
249   g_return_if_fail (closure != NULL);
250 
251   if (!source-&gt;source_funcs-&gt;closure_callback &amp;&amp;
252 #ifdef G_OS_UNIX
253       source-&gt;source_funcs != &amp;g_unix_fd_source_funcs &amp;&amp;
254       source-&gt;source_funcs != &amp;g_unix_signal_funcs &amp;&amp;
255 #endif
256       source-&gt;source_funcs != &amp;g_child_watch_funcs &amp;&amp;
257       source-&gt;source_funcs != &amp;g_io_watch_funcs &amp;&amp;
258       source-&gt;source_funcs != &amp;g_timeout_funcs &amp;&amp;
259       source-&gt;source_funcs != &amp;g_idle_funcs)
260     {
261       g_critical (G_STRLOC &quot;: closure cannot be set on GSource without GSourceFuncs::closure_callback&quot;);
262       return;
263     }
264 
265   g_closure_ref (closure);
266   g_closure_sink (closure);
267   g_source_set_callback_indirect (source, closure, &amp;closure_callback_funcs);
268 
269   g_closure_add_invalidate_notifier (closure, source, closure_invalidated);
270 
271   if (G_CLOSURE_NEEDS_MARSHAL (closure))
272     {
273       GClosureMarshal marshal = (GClosureMarshal)source-&gt;source_funcs-&gt;closure_marshal;
274       if (marshal)
<span class="line-modified">275   g_closure_set_marshal (closure, marshal);</span>
276       else if (source-&gt;source_funcs == &amp;g_idle_funcs ||
277 #ifdef G_OS_UNIX
278                source-&gt;source_funcs == &amp;g_unix_signal_funcs ||
279 #endif
280                source-&gt;source_funcs == &amp;g_timeout_funcs)
<span class="line-modified">281   g_closure_set_marshal (closure, source_closure_marshal_BOOLEAN__VOID);</span>
282       else
283         g_closure_set_marshal (closure, g_cclosure_marshal_generic);
284     }
285 }
286 
287 static void
288 dummy_closure_marshal (GClosure     *closure,
<span class="line-modified">289            GValue       *return_value,</span>
<span class="line-modified">290            guint         n_param_values,</span>
<span class="line-modified">291            const GValue *param_values,</span>
<span class="line-modified">292            gpointer      invocation_hint,</span>
<span class="line-modified">293            gpointer      marshal_data)</span>
294 {
295   if (G_VALUE_HOLDS_BOOLEAN (return_value))
296     g_value_set_boolean (return_value, TRUE);
297 }
298 
299 /**
300  * g_source_set_dummy_callback:
301  * @source: the source
302  *
303  * Sets a dummy callback for @source. The callback will do nothing, and
304  * if the source expects a #gboolean return value, it will return %TRUE.
305  * (If the source expects any other type of return value, it will return
306  * a 0/%NULL value; whatever g_value_init() initializes a #GValue to for
307  * that type.)
308  *
309  * If the source is not one of the standard GLib types, the
310  * @closure_callback and @closure_marshal fields of the #GSourceFuncs
311  * structure must have been filled in with pointers to appropriate
312  * functions.
313  */
</pre>
</td>
</tr>
</table>
<center><a href="gsignal.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gsourceclosure.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>