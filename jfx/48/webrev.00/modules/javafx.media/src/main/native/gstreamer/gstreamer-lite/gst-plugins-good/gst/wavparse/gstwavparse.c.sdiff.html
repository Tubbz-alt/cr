<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/wavparse/gstwavparse.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../spectrum/gstspectrum.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="gstwavparse.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/wavparse/gstwavparse.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  92 static gboolean gst_wavparse_sink_event (GstPad * pad, GstObject * parent,
  93     GstEvent * event);
  94 static void gst_wavparse_loop (GstPad * pad);
  95 static gboolean gst_wavparse_srcpad_event (GstPad * pad, GstObject * parent,
  96     GstEvent * event);
  97 
  98 static void gst_wavparse_set_property (GObject * object, guint prop_id,
  99     const GValue * value, GParamSpec * pspec);
 100 static void gst_wavparse_get_property (GObject * object, guint prop_id,
 101     GValue * value, GParamSpec * pspec);
 102 
 103 #define DEFAULT_IGNORE_LENGTH FALSE
 104 
 105 enum
 106 {
 107   PROP_0,
 108   PROP_IGNORE_LENGTH,
 109 };
 110 
 111 static GstStaticPadTemplate sink_template_factory =
<span class="line-modified"> 112 GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,</span>
 113     GST_PAD_SINK,
 114     GST_PAD_ALWAYS,
<span class="line-modified"> 115     GST_STATIC_CAPS (&quot;audio/x-wav&quot;)</span>
 116     );
 117 
 118 #define DEBUG_INIT \
 119   GST_DEBUG_CATEGORY_INIT (wavparse_debug, &quot;wavparse&quot;, 0, &quot;WAV parser&quot;);
 120 
 121 #define gst_wavparse_parent_class parent_class
 122 G_DEFINE_TYPE_WITH_CODE (GstWavParse, gst_wavparse, GST_TYPE_ELEMENT,
 123     DEBUG_INIT);
 124 
 125 typedef struct
 126 {
 127   /* Offset Size    Description   Value
 128    * 0x00   4       ID            unique identification value
 129    * 0x04   4       Position      play order position
 130    * 0x08   4       Data Chunk ID RIFF ID of corresponding data chunk
 131    * 0x0c   4       Chunk Start   Byte Offset of Data Chunk *
 132    * 0x10   4       Block Start   Byte Offset to sample of First Channel
 133    * 0x14   4       Sample Offset Byte Offset to sample byte of First Channel
 134    */
 135   guint32 id;
</pre>
<hr />
<pre>
 302       GST_DEBUG_FUNCPTR (gst_wavparse_chain));
 303   gst_pad_set_event_function (wavparse-&gt;sinkpad,
 304       GST_DEBUG_FUNCPTR (gst_wavparse_sink_event));
 305 
 306 #ifdef GSTREAMER_LITE
 307     gst_pad_set_query_function (wavparse-&gt;sinkpad,
 308             GST_DEBUG_FUNCPTR (gst_wavparse_sink_query));
 309 #endif // GSTREAMER_LITE
 310 
 311   gst_element_add_pad (GST_ELEMENT_CAST (wavparse), wavparse-&gt;sinkpad);
 312 
 313   /* src */
 314   wavparse-&gt;srcpad =
 315       gst_pad_new_from_template (gst_element_class_get_pad_template
 316       (GST_ELEMENT_GET_CLASS (wavparse), &quot;src&quot;), &quot;src&quot;);
 317   gst_pad_use_fixed_caps (wavparse-&gt;srcpad);
 318   gst_pad_set_query_function (wavparse-&gt;srcpad,
 319       GST_DEBUG_FUNCPTR (gst_wavparse_pad_query));
 320   gst_pad_set_event_function (wavparse-&gt;srcpad,
 321       GST_DEBUG_FUNCPTR (gst_wavparse_srcpad_event));
<span class="line-modified"> 322     gst_element_add_pad (GST_ELEMENT_CAST (wavparse), wavparse-&gt;srcpad);</span>
 323 }
 324 
 325 static gboolean
 326 gst_wavparse_parse_file_header (GstElement * element, GstBuffer * buf)
 327 {
 328   guint32 doctype;
 329 
 330   if (!gst_riff_parse_file_header (element, buf, &amp;doctype))
 331     return FALSE;
 332 
 333   if (doctype != GST_RIFF_RIFF_WAVE)
 334     goto not_wav;
 335 
 336   return TRUE;
 337 
 338   /* ERRORS */
 339 not_wav:
 340   {
 341     GST_ELEMENT_ERROR (element, STREAM, WRONG_TYPE, (NULL),
 342         (&quot;File is not a WAVE file: 0x%&quot; G_GINT32_MODIFIER &quot;x&quot;, doctype));
</pre>
<hr />
<pre>
 391 /* This function is used to perform seeks on the element.
 392  *
 393  * It also works when event is NULL, in which case it will just
 394  * start from the last configured segment. This technique is
 395  * used when activating the element and to perform the seek in
 396  * READY.
 397  */
 398 static gboolean
 399 gst_wavparse_perform_seek (GstWavParse * wav, GstEvent * event)
 400 {
 401   gboolean res;
 402   gdouble rate;
 403   GstFormat format, bformat;
 404   GstSeekFlags flags;
 405   GstSeekType cur_type = GST_SEEK_TYPE_NONE, stop_type;
 406   gint64 cur, stop, upstream_size;
 407   gboolean flush;
 408   gboolean update;
 409   GstSegment seeksegment = { 0, };
 410   gint64 last_stop;
<span class="line-modified"> 411   guint32 seqnum = 0;</span>
 412 
 413   if (event) {
 414     GST_DEBUG_OBJECT (wav, &quot;doing seek with event&quot;);
 415 
 416     gst_event_parse_seek (event, &amp;rate, &amp;format, &amp;flags,
 417         &amp;cur_type, &amp;cur, &amp;stop_type, &amp;stop);
 418     seqnum = gst_event_get_seqnum (event);
 419 
 420     /* no negative rates yet */
 421     if (rate &lt; 0.0)
 422       goto negative_rate;
 423 
 424     if (format != wav-&gt;segment.format) {
 425       GST_INFO_OBJECT (wav, &quot;converting seek-event from %s to %s&quot;,
 426           gst_format_get_name (format),
 427           gst_format_get_name (wav-&gt;segment.format));
 428       res = TRUE;
 429       if (cur_type != GST_SEEK_TYPE_NONE)
 430         res =
 431             gst_pad_query_convert (wav-&gt;srcpad, format, cur,
</pre>
<hr />
<pre>
 464         if (!gst_wavparse_time_to_bytepos (wav, cur, &amp;cur))
 465           goto no_position;
 466         if (!gst_wavparse_time_to_bytepos (wav, stop, &amp;stop))
 467           goto no_position;
 468       }
 469       /* mind sample boundary and header */
 470       if (cur &gt;= 0) {
 471         cur -= (cur % wav-&gt;bytes_per_sample);
 472         cur += wav-&gt;datastart;
 473       }
 474       if (stop &gt;= 0) {
 475         stop -= (stop % wav-&gt;bytes_per_sample);
 476         stop += wav-&gt;datastart;
 477       }
 478       GST_DEBUG_OBJECT (wav, &quot;Pushing BYTE seek rate %g, &quot;
 479           &quot;start %&quot; G_GINT64_FORMAT &quot;, stop %&quot; G_GINT64_FORMAT, rate, cur,
 480           stop);
 481       /* BYTE seek event */
 482       event = gst_event_new_seek (rate, GST_FORMAT_BYTES, flags, cur_type, cur,
 483           stop_type, stop);
<span class="line-modified"> 484       gst_event_set_seqnum (event, seqnum);</span>

 485       res = gst_pad_push_event (wav-&gt;sinkpad, event);
 486     }
 487     return res;
 488   }
 489 
 490   /* get flush flag */
 491   flush = flags &amp; GST_SEEK_FLAG_FLUSH;
 492 
 493   /* now we need to make sure the streaming thread is stopped. We do this by
 494    * either sending a FLUSH_START event downstream which will cause the
 495    * streaming thread to stop with a WRONG_STATE.
 496    * For a non-flushing seek we simply pause the task, which will happen as soon
 497    * as it completes one iteration (and thus might block when the sink is
 498    * blocking in preroll). */
 499   if (flush) {
 500     GstEvent *fevent;
<span class="line-modified"> 501       GST_DEBUG_OBJECT (wav, &quot;sending flush start&quot;);</span>
 502 
 503     fevent = gst_event_new_flush_start ();
<span class="line-modified"> 504     gst_event_set_seqnum (fevent, seqnum);</span>

 505     gst_pad_push_event (wav-&gt;sinkpad, gst_event_ref (fevent));
 506     gst_pad_push_event (wav-&gt;srcpad, fevent);
 507   } else {
 508     gst_pad_pause_task (wav-&gt;sinkpad);
 509   }
 510 
 511   /* we should now be able to grab the streaming thread because we stopped it
 512    * with the above flush/pause code */
 513   GST_PAD_STREAM_LOCK (wav-&gt;sinkpad);
 514 
 515   /* save current position */
 516   last_stop = wav-&gt;segment.position;
 517 
 518   GST_DEBUG_OBJECT (wav, &quot;stopped streaming at %&quot; G_GINT64_FORMAT, last_stop);
 519 
 520   /* copy segment, we need this because we still need the old
 521    * segment when we close the current segment. */
 522   memcpy (&amp;seeksegment, &amp;wav-&gt;segment, sizeof (GstSegment));
 523 
 524   /* configure the seek parameters in the seeksegment. We will then have the
</pre>
<hr />
<pre>
 567 
 568   /* make sure filesize is not exceeded due to rounding errors or so,
 569    * same precaution as in _stream_headers */
 570   bformat = GST_FORMAT_BYTES;
 571   if (gst_pad_peer_query_duration (wav-&gt;sinkpad, bformat, &amp;upstream_size))
 572     wav-&gt;end_offset = MIN (wav-&gt;end_offset, upstream_size);
 573 
 574   if (wav-&gt;datasize &gt; 0 &amp;&amp; wav-&gt;end_offset &gt; wav-&gt;datastart + wav-&gt;datasize)
 575     wav-&gt;end_offset = wav-&gt;datastart + wav-&gt;datasize;
 576 
 577   /* this is the range of bytes we will use for playback */
 578   wav-&gt;offset = MIN (wav-&gt;offset, wav-&gt;end_offset);
 579   wav-&gt;dataleft = wav-&gt;end_offset - wav-&gt;offset;
 580 
 581   GST_DEBUG_OBJECT (wav,
 582       &quot;seek: rate %lf, offset %&quot; G_GUINT64_FORMAT &quot;, end %&quot; G_GUINT64_FORMAT
 583       &quot;, segment %&quot; GST_TIME_FORMAT &quot; -- %&quot; GST_TIME_FORMAT, rate, wav-&gt;offset,
 584       wav-&gt;end_offset, GST_TIME_ARGS (seeksegment.start), GST_TIME_ARGS (stop));
 585 
 586   /* prepare for streaming again */
<span class="line-modified"> 587     if (flush) {</span>
 588     GstEvent *fevent;
 589 
<span class="line-modified"> 590       /* if we sent a FLUSH_START, we now send a FLUSH_STOP */</span>
<span class="line-modified"> 591       GST_DEBUG_OBJECT (wav, &quot;sending flush stop&quot;);</span>
 592 
 593     fevent = gst_event_new_flush_stop (TRUE);
<span class="line-modified"> 594     gst_event_set_seqnum (fevent, seqnum);</span>

 595     gst_pad_push_event (wav-&gt;sinkpad, gst_event_ref (fevent));
 596     gst_pad_push_event (wav-&gt;srcpad, fevent);
<span class="line-modified"> 597     }</span>
 598 
 599   /* now we did the seek and can activate the new segment values */
 600   memcpy (&amp;wav-&gt;segment, &amp;seeksegment, sizeof (GstSegment));
 601 
 602   /* if we&#39;re doing a segment seek, post a SEGMENT_START message */
 603   if (wav-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
 604     gst_element_post_message (GST_ELEMENT_CAST (wav),
 605         gst_message_new_segment_start (GST_OBJECT_CAST (wav),
 606             wav-&gt;segment.format, wav-&gt;segment.position));
 607   }
 608 
 609   /* now create the newsegment */
 610   GST_DEBUG_OBJECT (wav, &quot;Creating newsegment from %&quot; G_GINT64_FORMAT
 611       &quot; to %&quot; G_GINT64_FORMAT, wav-&gt;segment.position, stop);
 612 
 613   /* store the newsegment event so it can be sent from the streaming thread. */
 614   if (wav-&gt;start_segment)
 615     gst_event_unref (wav-&gt;start_segment);
 616   wav-&gt;start_segment = gst_event_new_segment (&amp;wav-&gt;segment);
<span class="line-modified"> 617   gst_event_set_seqnum (wav-&gt;start_segment, seqnum);</span>

 618 
 619   /* mark discont if we are going to stream from another position. */
 620   if (last_stop != wav-&gt;segment.position) {
 621     GST_DEBUG_OBJECT (wav, &quot;mark DISCONT, we did a seek to another position&quot;);
 622     wav-&gt;discont = TRUE;
 623   }
 624 
 625   /* and start the streaming task again */
 626   if (!wav-&gt;streaming) {
 627     gst_pad_start_task (wav-&gt;sinkpad, (GstTaskFunction) gst_wavparse_loop,
 628         wav-&gt;sinkpad, NULL);
 629   }
 630 
 631   GST_PAD_STREAM_UNLOCK (wav-&gt;sinkpad);
 632 
 633   return TRUE;
 634 
 635   /* ERRORS */
 636 negative_rate:
 637   {
</pre>
<hr />
<pre>
1391           if (size &lt; data_size) {
1392             if (!gst_waveparse_ignore_chunk (wav, buf, tag, size)) {
1393               /* need more data */
1394               goto exit;
1395             }
1396             GST_DEBUG_OBJECT (wav, &quot;need %u, available %u; ignoring chunk&quot;,
1397                 data_size, size);
1398             break;
1399           }
1400           /* number of samples (for compressed formats) */
1401           if (wav-&gt;streaming) {
1402             const guint8 *data = NULL;
1403 
1404             if (!gst_wavparse_peek_chunk (wav, &amp;tag, &amp;size)) {
1405               goto exit;
1406             }
1407             gst_adapter_flush (wav-&gt;adapter, 8);
1408             data = gst_adapter_map (wav-&gt;adapter, data_size);
1409 #ifdef GSTREAMER_LITE
1410             if (data == NULL) {
<span class="line-modified">1411                 goto header_read_error;</span>
1412             }
1413 #endif // GSTREAMER_LITE
1414             wav-&gt;fact = GST_READ_UINT32_LE (data);
1415             gst_adapter_unmap (wav-&gt;adapter);
1416             gst_adapter_flush (wav-&gt;adapter, GST_ROUND_UP_2 (size));
1417           } else {
1418             gst_buffer_unref (buf);
1419             buf = NULL;
1420             if ((res =
1421                     gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset + 8,
1422                         data_size, &amp;buf)) != GST_FLOW_OK)
1423 #ifdef GSTREAMER_LITE
1424             if (res == GST_FLOW_FLUSHING)
1425               goto exit;
1426             else
1427 #endif // GSTREAMER_LITE
1428               goto header_read_error;
1429             gst_buffer_extract (buf, 0, &amp;wav-&gt;fact, 4);
1430             wav-&gt;fact = GUINT32_FROM_LE (wav-&gt;fact);
1431             gst_buffer_unref (buf);
</pre>
<hr />
<pre>
1744       wav-&gt;segment.duration = wav-&gt;datasize;
1745   }
1746 
1747   /* now we have all the info to perform a pending seek if any, if no
1748    * event, this will still do the right thing and it will also send
1749    * the right newsegment event downstream. */
1750   gst_wavparse_perform_seek (wav, wav-&gt;seek_event);
1751   /* remove pending event */
1752   gst_event_replace (&amp;wav-&gt;seek_event, NULL);
1753 
1754   /* we just started, we are discont */
1755   wav-&gt;discont = TRUE;
1756 
1757   wav-&gt;state = GST_WAVPARSE_DATA;
1758 
1759   /* determine reasonable max buffer size,
1760    * that is, buffers not too small either size or time wise
1761    * so we do not end up with too many of them */
1762   /* var abuse */
1763   if (gst_wavparse_time_to_bytepos (wav, 40 * GST_MSECOND, &amp;upstream_size))
<span class="line-modified">1764   wav-&gt;max_buf_size = upstream_size;</span>
1765   else
1766     wav-&gt;max_buf_size = 0;
1767   wav-&gt;max_buf_size = MAX (wav-&gt;max_buf_size, MAX_BUFFER_SIZE);
1768   if (wav-&gt;blockalign &gt; 0)
1769     wav-&gt;max_buf_size -= (wav-&gt;max_buf_size % wav-&gt;blockalign);
1770 
1771   GST_DEBUG_OBJECT (wav, &quot;max buffer size %u&quot;, wav-&gt;max_buf_size);
1772 
1773   return GST_FLOW_OK;
1774 
1775   /* ERROR */
1776 exit:
1777   {
<span class="line-modified">1778       g_free (codec_name);</span>
<span class="line-modified">1779       g_free (header);</span>
1780     if (caps)
1781       gst_caps_unref (caps);
1782     return res;
1783   }
1784 fail:
1785   {
1786     res = GST_FLOW_ERROR;
1787     goto exit;
1788   }
1789 parse_header_error:
1790   {
1791     GST_ELEMENT_ERROR (wav, STREAM, DEMUX, (NULL),
1792         (&quot;Couldn&#39;t parse audio header&quot;));
1793     goto fail;
1794   }
1795 no_channels:
1796   {
1797     GST_ELEMENT_ERROR (wav, STREAM, FAILED, (NULL),
1798         (&quot;Stream claims to contain no channels - invalid data&quot;));
1799     goto fail;
</pre>
<hr />
<pre>
1944       gst_tag_list_remove_tag (tags, GST_TAG_CONTAINER_FORMAT);
1945       gst_event_unref (ev);
1946       break;
1947     }
1948     tags = NULL;
1949     gst_event_unref (ev);
1950   }
1951   return tags;
1952 }
1953 
1954 static void
1955 gst_wavparse_add_src_pad (GstWavParse * wav, GstBuffer * buf)
1956 {
1957   GstStructure *s;
1958   GstTagList *tags, *utags;
1959 
1960   GST_DEBUG_OBJECT (wav, &quot;adding src pad&quot;);
1961 
1962   g_assert (wav-&gt;caps != NULL);
1963 
<span class="line-modified">1964     s = gst_caps_get_structure (wav-&gt;caps, 0);</span>
1965   if (s &amp;&amp; gst_structure_has_name (s, &quot;audio/x-raw&quot;) &amp;&amp; buf != NULL) {
<span class="line-modified">1966       GstTypeFindProbability prob;</span>
<span class="line-modified">1967       GstCaps *tf_caps;</span>
<span class="line-modified">1968 </span>
<span class="line-modified">1969       tf_caps = gst_type_find_helper_for_buffer (GST_OBJECT (wav), buf, &amp;prob);</span>
<span class="line-modified">1970       if (tf_caps != NULL) {</span>
<span class="line-modified">1971         GST_LOG (&quot;typefind caps = %&quot; GST_PTR_FORMAT &quot;, P=%d&quot;, tf_caps, prob);</span>
<span class="line-modified">1972         if (gst_wavparse_have_dts_caps (tf_caps, prob)) {</span>
<span class="line-modified">1973           GST_INFO_OBJECT (wav, &quot;Found DTS marker in file marked as raw PCM&quot;);</span>
<span class="line-modified">1974           gst_caps_unref (wav-&gt;caps);</span>
<span class="line-modified">1975           wav-&gt;caps = tf_caps;</span>
<span class="line-modified">1976 </span>
<span class="line-modified">1977           gst_tag_list_add (wav-&gt;tags, GST_TAG_MERGE_REPLACE,</span>
<span class="line-modified">1978               GST_TAG_AUDIO_CODEC, &quot;dts&quot;, NULL);</span>
<span class="line-modified">1979         } else {</span>
<span class="line-modified">1980           GST_DEBUG_OBJECT (wav, &quot;found caps %&quot; GST_PTR_FORMAT &quot; for stream &quot;</span>
<span class="line-modified">1981               &quot;marked as raw PCM audio, but ignoring for now&quot;, tf_caps);</span>
<span class="line-modified">1982           gst_caps_unref (tf_caps);</span>
<span class="line-removed">1983         }</span>
1984       }
1985     }

1986 
1987   gst_pad_set_caps (wav-&gt;srcpad, wav-&gt;caps);
1988 
1989   if (wav-&gt;start_segment) {
1990     GST_DEBUG_OBJECT (wav, &quot;Send start segment event on newpad&quot;);
1991     gst_pad_push_event (wav-&gt;srcpad, wav-&gt;start_segment);
1992     wav-&gt;start_segment = NULL;
1993   }
1994 
1995   /* upstream tags, e.g. from id3/ape tag before the wav file; assume for now
1996    * that there&#39;ll be only one scope/type of tag list from upstream, if any */
1997   utags = gst_wavparse_get_upstream_tags (wav, GST_TAG_SCOPE_GLOBAL);
1998   if (utags == NULL)
1999     utags = gst_wavparse_get_upstream_tags (wav, GST_TAG_SCOPE_STREAM);
2000 
2001   /* if there&#39;s a tag upstream it&#39;s probably been added to override the
2002    * tags from inside the wav header, so keep upstream tags if in doubt */
2003   tags = gst_tag_list_merge (utags, wav-&gt;tags, GST_TAG_MERGE_KEEP);
2004 
2005   if (wav-&gt;tags != NULL) {
</pre>
<hr />
<pre>
2031 
2032   if ((wav-&gt;dataleft == 0 || wav-&gt;dataleft &lt; wav-&gt;blockalign)) {
2033     /* In case chunk size is not declared in the begining get size from the
2034      * file size directly */
2035     if (wav-&gt;chunk_size == 0) {
2036       gint64 upstream_size = 0;
2037 
2038       /* Get the size of the file   */
2039       if (!gst_pad_peer_query_duration (wav-&gt;sinkpad, GST_FORMAT_BYTES,
2040               &amp;upstream_size))
2041         goto found_eos;
2042 
2043       if (upstream_size &lt; wav-&gt;offset + wav-&gt;datastart)
2044         goto found_eos;
2045 
2046       /* If file has updated since the beggining continue reading the file */
2047       wav-&gt;dataleft = upstream_size - wav-&gt;offset - wav-&gt;datastart;
2048       wav-&gt;end_offset = upstream_size;
2049 
2050       /* Get the next n bytes and output them, if we can */
<span class="line-modified">2051   if (wav-&gt;dataleft == 0 || wav-&gt;dataleft &lt; wav-&gt;blockalign)</span>
<span class="line-modified">2052     goto found_eos;</span>
2053     } else {
2054       goto found_eos;
2055     }
2056   }
2057 
2058   /* scale the amount of data by the segment rate so we get equal
2059    * amounts of data regardless of the playback rate */
2060   desired =
2061       MIN (gst_guint64_to_gdouble (wav-&gt;dataleft),
2062       wav-&gt;max_buf_size * ABS (wav-&gt;segment.rate));
2063 
2064   if (desired &gt;= wav-&gt;blockalign &amp;&amp; wav-&gt;blockalign &gt; 0)
2065     desired -= (desired % wav-&gt;blockalign);
2066 
2067 #ifdef GSTREAMER_LITE
2068   if (desired == 0) {
2069     GST_ELEMENT_ERROR (wav, STREAM, DEMUX, (NULL),
2070               (&quot;Invalid stream&quot;));
2071     return GST_FLOW_ERROR;
2072   }
</pre>
<hr />
<pre>
2304 
2305     GST_DEBUG_OBJECT (wav, &quot;pausing task, reason %s&quot;, reason);
2306     gst_pad_pause_task (pad);
2307 
2308     if (ret == GST_FLOW_EOS) {
2309       /* handle end-of-stream/segment */
2310       /* so align our position with the end of it, if there is one
2311        * this ensures a subsequent will arrive at correct base/acc time */
2312       if (wav-&gt;segment.format == GST_FORMAT_TIME) {
2313         if (wav-&gt;segment.rate &gt; 0.0 &amp;&amp;
2314             GST_CLOCK_TIME_IS_VALID (wav-&gt;segment.stop))
2315           wav-&gt;segment.position = wav-&gt;segment.stop;
2316         else if (wav-&gt;segment.rate &lt; 0.0)
2317           wav-&gt;segment.position = wav-&gt;segment.start;
2318       }
2319       if (wav-&gt;state == GST_WAVPARSE_START || !wav-&gt;caps) {
2320         GST_ELEMENT_ERROR (wav, STREAM, WRONG_TYPE, (NULL),
2321             (&quot;No valid input found before end of stream&quot;));
2322         gst_pad_push_event (wav-&gt;srcpad, gst_event_new_eos ());
2323       } else {
<span class="line-modified">2324       /* add pad before we perform EOS */</span>
<span class="line-modified">2325       if (G_UNLIKELY (wav-&gt;first)) {</span>
<span class="line-modified">2326         wav-&gt;first = FALSE;</span>
<span class="line-modified">2327         gst_wavparse_add_src_pad (wav, NULL);</span>
<span class="line-modified">2328       }</span>
2329 
<span class="line-modified">2330       /* perform EOS logic */</span>
<span class="line-modified">2331       if (wav-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {</span>
<span class="line-modified">2332         GstClockTime stop;</span>
2333 
<span class="line-modified">2334         if ((stop = wav-&gt;segment.stop) == -1)</span>
<span class="line-modified">2335           stop = wav-&gt;segment.duration;</span>
2336 
<span class="line-modified">2337         gst_element_post_message (GST_ELEMENT_CAST (wav),</span>
<span class="line-modified">2338             gst_message_new_segment_done (GST_OBJECT_CAST (wav),</span>
<span class="line-modified">2339                 wav-&gt;segment.format, stop));</span>
2340           gst_pad_push_event (wav-&gt;srcpad,
2341               gst_event_new_segment_done (wav-&gt;segment.format, stop));
<span class="line-modified">2342       } else {</span>
2343           gst_pad_push_event (wav-&gt;srcpad, gst_event_new_eos ());
<span class="line-modified">2344       }</span>
2345       }
2346     } else if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS) {
2347       /* for fatal errors we post an error message, post the error
2348        * first so the app knows about the error first. */
2349       GST_ELEMENT_FLOW_ERROR (wav, ret);
<span class="line-modified">2350         gst_pad_push_event (wav-&gt;srcpad, gst_event_new_eos ());</span>
2351     }
2352     return;
2353   }
2354 }
2355 
2356 static GstFlowReturn
2357 gst_wavparse_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
2358 {
2359   GstFlowReturn ret;
2360   GstWavParse *wav = GST_WAVPARSE (parent);
2361 
2362   GST_LOG_OBJECT (wav, &quot;adapter_push %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
2363       gst_buffer_get_size (buf));
2364 
2365   gst_adapter_push (wav-&gt;adapter, buf);
2366 
2367   switch (wav-&gt;state) {
2368     case GST_WAVPARSE_START:
2369       GST_INFO_OBJECT (wav, &quot;GST_WAVPARSE_START&quot;);
2370       if ((ret = gst_wavparse_parse_stream_init (wav)) != GST_FLOW_OK)
</pre>
<hr />
<pre>
2533 #endif // GSTREAMER_LITE
2534       } else {
2535         /* infinity; upstream will EOS when done */
2536         wav-&gt;dataleft = G_MAXUINT64;
2537       }
2538     exit:
2539       gst_event_unref (event);
2540       break;
2541     }
2542 #ifdef GSTREAMER_LITE
2543     case FX_EVENT_RANGE_READY: // This event appears only in pull mode during outrange seeking.
2544         ret = gst_pad_start_task (pad, (GstTaskFunction) gst_wavparse_loop, pad, NULL);
2545         gst_event_unref(event);
2546         break;
2547 #endif // GSTREAMER_LITE
2548     case GST_EVENT_EOS:
2549       if (wav-&gt;state == GST_WAVPARSE_START || !wav-&gt;caps) {
2550         GST_ELEMENT_ERROR (wav, STREAM, WRONG_TYPE, (NULL),
2551             (&quot;No valid input found before end of stream&quot;));
2552       } else {
<span class="line-modified">2553       /* add pad if needed so EOS is seen downstream */</span>
<span class="line-modified">2554       if (G_UNLIKELY (wav-&gt;first)) {</span>
<span class="line-modified">2555         wav-&gt;first = FALSE;</span>
<span class="line-modified">2556         gst_wavparse_add_src_pad (wav, NULL);</span>
<span class="line-modified">2557       } else {</span>
<span class="line-modified">2558         /* stream leftover data in current segment */</span>
<span class="line-modified">2559         gst_wavparse_flush_data (wav);</span>
<span class="line-modified">2560       }</span>
2561       }
2562 
2563       /* fall-through */
2564     case GST_EVENT_FLUSH_STOP:
2565     {
2566       GstClockTime dur;
2567 
2568       if (wav-&gt;adapter)
<span class="line-modified">2569       gst_adapter_clear (wav-&gt;adapter);</span>
2570       wav-&gt;discont = TRUE;
2571       dur = wav-&gt;segment.duration;
2572       gst_segment_init (&amp;wav-&gt;segment, wav-&gt;segment.format);
2573       wav-&gt;segment.duration = dur;
2574       /* fall-through */
2575     }
2576     default:
2577       ret = gst_pad_event_default (wav-&gt;sinkpad, parent, event);
2578       break;
2579   }
2580 
2581   return ret;
2582 }
2583 
2584 #if 0
2585 /* convert and query stuff */
2586 static const GstFormat *
2587 gst_wavparse_get_formats (GstPad * pad)
2588 {
2589   static const GstFormat formats[] = {
</pre>
<hr />
<pre>
2802 
2803           q = gst_query_new_seeking (GST_FORMAT_BYTES);
2804           if ((res = gst_pad_peer_query (wav-&gt;sinkpad, q))) {
2805             gst_query_parse_seeking (q, &amp;fmt, &amp;seekable, NULL, NULL);
2806             GST_LOG_OBJECT (wav, &quot;upstream BYTE seekable %d&quot;, seekable);
2807           }
2808           gst_query_unref (q);
2809         } else {
2810           GST_LOG_OBJECT (wav, &quot;looping =&gt; seekable&quot;);
2811           seekable = TRUE;
2812           res = TRUE;
2813         }
2814       } else if (fmt == GST_FORMAT_TIME) {
2815         res = TRUE;
2816       }
2817       if (res) {
2818         gst_query_set_seeking (query, fmt, seekable, 0, wav-&gt;segment.duration);
2819       }
2820       break;
2821     }



















2822     default:
2823       res = gst_pad_query_default (pad, parent, query);
2824       break;
2825   }
2826   return res;
2827 }
2828 
2829 #ifdef GSTREAMER_LITE
2830 static gboolean
2831 gst_wavparse_sink_query (GstPad* pad, GstObject *parent, GstQuery* query)
2832 {
2833     gboolean result = TRUE;
2834     switch (GST_QUERY_TYPE(query))
2835     {
2836         case GST_QUERY_CUSTOM:
2837         {
2838             const GstStructure *s = gst_query_get_structure(query);
2839             if (gst_structure_has_name(s, GETRANGE_QUERY_NAME))
2840                 gst_structure_set(s, GETRANGE_QUERY_SUPPORTS_FIELDNANE,
2841                                      GETRANGE_QUERY_SUPPORTS_FIELDTYPE,
</pre>
<hr />
<pre>
2926     gst_adapter_clear (wav-&gt;adapter);
2927     g_object_unref (wav-&gt;adapter);
2928     wav-&gt;adapter = NULL;
2929   }
2930 
2931   query = gst_query_new_scheduling ();
2932 
2933   if (!gst_pad_peer_query (sinkpad, query)) {
2934     gst_query_unref (query);
2935     goto activate_push;
2936   }
2937 
2938   pull_mode = gst_query_has_scheduling_mode_with_flags (query,
2939       GST_PAD_MODE_PULL, GST_SCHEDULING_FLAG_SEEKABLE);
2940   gst_query_unref (query);
2941 
2942   if (!pull_mode)
2943     goto activate_push;
2944 
2945   GST_DEBUG_OBJECT (sinkpad, &quot;activating pull&quot;);
<span class="line-modified">2946     wav-&gt;streaming = FALSE;</span>
2947   return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PULL, TRUE);
2948 
2949 activate_push:
2950   {
2951     GST_DEBUG_OBJECT (sinkpad, &quot;activating push&quot;);
2952     wav-&gt;streaming = TRUE;
2953     wav-&gt;adapter = gst_adapter_new ();
2954     return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PUSH, TRUE);
2955   }
2956 }
2957 
2958 
2959 static gboolean
2960 gst_wavparse_sink_activate_mode (GstPad * sinkpad, GstObject * parent,
2961     GstPadMode mode, gboolean active)
2962 {
2963   gboolean res;
2964 
2965   switch (mode) {
2966     case GST_PAD_MODE_PUSH:
2967       res = TRUE;
2968       break;
2969     case GST_PAD_MODE_PULL:
<span class="line-modified">2970   if (active) {</span>
<span class="line-modified">2971     /* if we have a scheduler we can start the task */</span>
2972         res = gst_pad_start_task (sinkpad, (GstTaskFunction) gst_wavparse_loop,
2973             sinkpad, NULL);
<span class="line-modified">2974   } else {</span>
2975         res = gst_pad_stop_task (sinkpad);
<span class="line-modified">2976   }</span>
2977       break;
2978     default:
2979       res = FALSE;
2980       break;
2981   }
2982   return res;
2983 }
2984 
2985 static GstStateChangeReturn
2986 gst_wavparse_change_state (GstElement * element, GstStateChange transition)
2987 {
2988   GstStateChangeReturn ret;
2989   GstWavParse *wav = GST_WAVPARSE (element);
2990 
2991   switch (transition) {
2992     case GST_STATE_CHANGE_NULL_TO_READY:
2993       break;
2994     case GST_STATE_CHANGE_READY_TO_PAUSED:
2995       gst_wavparse_reset (wav);
2996       break;
</pre>
</td>
<td>
<hr />
<pre>
  92 static gboolean gst_wavparse_sink_event (GstPad * pad, GstObject * parent,
  93     GstEvent * event);
  94 static void gst_wavparse_loop (GstPad * pad);
  95 static gboolean gst_wavparse_srcpad_event (GstPad * pad, GstObject * parent,
  96     GstEvent * event);
  97 
  98 static void gst_wavparse_set_property (GObject * object, guint prop_id,
  99     const GValue * value, GParamSpec * pspec);
 100 static void gst_wavparse_get_property (GObject * object, guint prop_id,
 101     GValue * value, GParamSpec * pspec);
 102 
 103 #define DEFAULT_IGNORE_LENGTH FALSE
 104 
 105 enum
 106 {
 107   PROP_0,
 108   PROP_IGNORE_LENGTH,
 109 };
 110 
 111 static GstStaticPadTemplate sink_template_factory =
<span class="line-modified"> 112     GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,</span>
 113     GST_PAD_SINK,
 114     GST_PAD_ALWAYS,
<span class="line-modified"> 115     GST_STATIC_CAPS (&quot;audio/x-wav;audio/x-rf64&quot;)</span>
 116     );
 117 
 118 #define DEBUG_INIT \
 119   GST_DEBUG_CATEGORY_INIT (wavparse_debug, &quot;wavparse&quot;, 0, &quot;WAV parser&quot;);
 120 
 121 #define gst_wavparse_parent_class parent_class
 122 G_DEFINE_TYPE_WITH_CODE (GstWavParse, gst_wavparse, GST_TYPE_ELEMENT,
 123     DEBUG_INIT);
 124 
 125 typedef struct
 126 {
 127   /* Offset Size    Description   Value
 128    * 0x00   4       ID            unique identification value
 129    * 0x04   4       Position      play order position
 130    * 0x08   4       Data Chunk ID RIFF ID of corresponding data chunk
 131    * 0x0c   4       Chunk Start   Byte Offset of Data Chunk *
 132    * 0x10   4       Block Start   Byte Offset to sample of First Channel
 133    * 0x14   4       Sample Offset Byte Offset to sample byte of First Channel
 134    */
 135   guint32 id;
</pre>
<hr />
<pre>
 302       GST_DEBUG_FUNCPTR (gst_wavparse_chain));
 303   gst_pad_set_event_function (wavparse-&gt;sinkpad,
 304       GST_DEBUG_FUNCPTR (gst_wavparse_sink_event));
 305 
 306 #ifdef GSTREAMER_LITE
 307     gst_pad_set_query_function (wavparse-&gt;sinkpad,
 308             GST_DEBUG_FUNCPTR (gst_wavparse_sink_query));
 309 #endif // GSTREAMER_LITE
 310 
 311   gst_element_add_pad (GST_ELEMENT_CAST (wavparse), wavparse-&gt;sinkpad);
 312 
 313   /* src */
 314   wavparse-&gt;srcpad =
 315       gst_pad_new_from_template (gst_element_class_get_pad_template
 316       (GST_ELEMENT_GET_CLASS (wavparse), &quot;src&quot;), &quot;src&quot;);
 317   gst_pad_use_fixed_caps (wavparse-&gt;srcpad);
 318   gst_pad_set_query_function (wavparse-&gt;srcpad,
 319       GST_DEBUG_FUNCPTR (gst_wavparse_pad_query));
 320   gst_pad_set_event_function (wavparse-&gt;srcpad,
 321       GST_DEBUG_FUNCPTR (gst_wavparse_srcpad_event));
<span class="line-modified"> 322   gst_element_add_pad (GST_ELEMENT_CAST (wavparse), wavparse-&gt;srcpad);</span>
 323 }
 324 
 325 static gboolean
 326 gst_wavparse_parse_file_header (GstElement * element, GstBuffer * buf)
 327 {
 328   guint32 doctype;
 329 
 330   if (!gst_riff_parse_file_header (element, buf, &amp;doctype))
 331     return FALSE;
 332 
 333   if (doctype != GST_RIFF_RIFF_WAVE)
 334     goto not_wav;
 335 
 336   return TRUE;
 337 
 338   /* ERRORS */
 339 not_wav:
 340   {
 341     GST_ELEMENT_ERROR (element, STREAM, WRONG_TYPE, (NULL),
 342         (&quot;File is not a WAVE file: 0x%&quot; G_GINT32_MODIFIER &quot;x&quot;, doctype));
</pre>
<hr />
<pre>
 391 /* This function is used to perform seeks on the element.
 392  *
 393  * It also works when event is NULL, in which case it will just
 394  * start from the last configured segment. This technique is
 395  * used when activating the element and to perform the seek in
 396  * READY.
 397  */
 398 static gboolean
 399 gst_wavparse_perform_seek (GstWavParse * wav, GstEvent * event)
 400 {
 401   gboolean res;
 402   gdouble rate;
 403   GstFormat format, bformat;
 404   GstSeekFlags flags;
 405   GstSeekType cur_type = GST_SEEK_TYPE_NONE, stop_type;
 406   gint64 cur, stop, upstream_size;
 407   gboolean flush;
 408   gboolean update;
 409   GstSegment seeksegment = { 0, };
 410   gint64 last_stop;
<span class="line-modified"> 411   guint32 seqnum = GST_SEQNUM_INVALID;</span>
 412 
 413   if (event) {
 414     GST_DEBUG_OBJECT (wav, &quot;doing seek with event&quot;);
 415 
 416     gst_event_parse_seek (event, &amp;rate, &amp;format, &amp;flags,
 417         &amp;cur_type, &amp;cur, &amp;stop_type, &amp;stop);
 418     seqnum = gst_event_get_seqnum (event);
 419 
 420     /* no negative rates yet */
 421     if (rate &lt; 0.0)
 422       goto negative_rate;
 423 
 424     if (format != wav-&gt;segment.format) {
 425       GST_INFO_OBJECT (wav, &quot;converting seek-event from %s to %s&quot;,
 426           gst_format_get_name (format),
 427           gst_format_get_name (wav-&gt;segment.format));
 428       res = TRUE;
 429       if (cur_type != GST_SEEK_TYPE_NONE)
 430         res =
 431             gst_pad_query_convert (wav-&gt;srcpad, format, cur,
</pre>
<hr />
<pre>
 464         if (!gst_wavparse_time_to_bytepos (wav, cur, &amp;cur))
 465           goto no_position;
 466         if (!gst_wavparse_time_to_bytepos (wav, stop, &amp;stop))
 467           goto no_position;
 468       }
 469       /* mind sample boundary and header */
 470       if (cur &gt;= 0) {
 471         cur -= (cur % wav-&gt;bytes_per_sample);
 472         cur += wav-&gt;datastart;
 473       }
 474       if (stop &gt;= 0) {
 475         stop -= (stop % wav-&gt;bytes_per_sample);
 476         stop += wav-&gt;datastart;
 477       }
 478       GST_DEBUG_OBJECT (wav, &quot;Pushing BYTE seek rate %g, &quot;
 479           &quot;start %&quot; G_GINT64_FORMAT &quot;, stop %&quot; G_GINT64_FORMAT, rate, cur,
 480           stop);
 481       /* BYTE seek event */
 482       event = gst_event_new_seek (rate, GST_FORMAT_BYTES, flags, cur_type, cur,
 483           stop_type, stop);
<span class="line-modified"> 484       if (seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added"> 485         gst_event_set_seqnum (event, seqnum);</span>
 486       res = gst_pad_push_event (wav-&gt;sinkpad, event);
 487     }
 488     return res;
 489   }
 490 
 491   /* get flush flag */
 492   flush = flags &amp; GST_SEEK_FLAG_FLUSH;
 493 
 494   /* now we need to make sure the streaming thread is stopped. We do this by
 495    * either sending a FLUSH_START event downstream which will cause the
 496    * streaming thread to stop with a WRONG_STATE.
 497    * For a non-flushing seek we simply pause the task, which will happen as soon
 498    * as it completes one iteration (and thus might block when the sink is
 499    * blocking in preroll). */
 500   if (flush) {
 501     GstEvent *fevent;
<span class="line-modified"> 502     GST_DEBUG_OBJECT (wav, &quot;sending flush start&quot;);</span>
 503 
 504     fevent = gst_event_new_flush_start ();
<span class="line-modified"> 505     if (seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added"> 506       gst_event_set_seqnum (fevent, seqnum);</span>
 507     gst_pad_push_event (wav-&gt;sinkpad, gst_event_ref (fevent));
 508     gst_pad_push_event (wav-&gt;srcpad, fevent);
 509   } else {
 510     gst_pad_pause_task (wav-&gt;sinkpad);
 511   }
 512 
 513   /* we should now be able to grab the streaming thread because we stopped it
 514    * with the above flush/pause code */
 515   GST_PAD_STREAM_LOCK (wav-&gt;sinkpad);
 516 
 517   /* save current position */
 518   last_stop = wav-&gt;segment.position;
 519 
 520   GST_DEBUG_OBJECT (wav, &quot;stopped streaming at %&quot; G_GINT64_FORMAT, last_stop);
 521 
 522   /* copy segment, we need this because we still need the old
 523    * segment when we close the current segment. */
 524   memcpy (&amp;seeksegment, &amp;wav-&gt;segment, sizeof (GstSegment));
 525 
 526   /* configure the seek parameters in the seeksegment. We will then have the
</pre>
<hr />
<pre>
 569 
 570   /* make sure filesize is not exceeded due to rounding errors or so,
 571    * same precaution as in _stream_headers */
 572   bformat = GST_FORMAT_BYTES;
 573   if (gst_pad_peer_query_duration (wav-&gt;sinkpad, bformat, &amp;upstream_size))
 574     wav-&gt;end_offset = MIN (wav-&gt;end_offset, upstream_size);
 575 
 576   if (wav-&gt;datasize &gt; 0 &amp;&amp; wav-&gt;end_offset &gt; wav-&gt;datastart + wav-&gt;datasize)
 577     wav-&gt;end_offset = wav-&gt;datastart + wav-&gt;datasize;
 578 
 579   /* this is the range of bytes we will use for playback */
 580   wav-&gt;offset = MIN (wav-&gt;offset, wav-&gt;end_offset);
 581   wav-&gt;dataleft = wav-&gt;end_offset - wav-&gt;offset;
 582 
 583   GST_DEBUG_OBJECT (wav,
 584       &quot;seek: rate %lf, offset %&quot; G_GUINT64_FORMAT &quot;, end %&quot; G_GUINT64_FORMAT
 585       &quot;, segment %&quot; GST_TIME_FORMAT &quot; -- %&quot; GST_TIME_FORMAT, rate, wav-&gt;offset,
 586       wav-&gt;end_offset, GST_TIME_ARGS (seeksegment.start), GST_TIME_ARGS (stop));
 587 
 588   /* prepare for streaming again */
<span class="line-modified"> 589   if (flush) {</span>
 590     GstEvent *fevent;
 591 
<span class="line-modified"> 592     /* if we sent a FLUSH_START, we now send a FLUSH_STOP */</span>
<span class="line-modified"> 593     GST_DEBUG_OBJECT (wav, &quot;sending flush stop&quot;);</span>
 594 
 595     fevent = gst_event_new_flush_stop (TRUE);
<span class="line-modified"> 596     if (seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added"> 597       gst_event_set_seqnum (fevent, seqnum);</span>
 598     gst_pad_push_event (wav-&gt;sinkpad, gst_event_ref (fevent));
 599     gst_pad_push_event (wav-&gt;srcpad, fevent);
<span class="line-modified"> 600   }</span>
 601 
 602   /* now we did the seek and can activate the new segment values */
 603   memcpy (&amp;wav-&gt;segment, &amp;seeksegment, sizeof (GstSegment));
 604 
 605   /* if we&#39;re doing a segment seek, post a SEGMENT_START message */
 606   if (wav-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
 607     gst_element_post_message (GST_ELEMENT_CAST (wav),
 608         gst_message_new_segment_start (GST_OBJECT_CAST (wav),
 609             wav-&gt;segment.format, wav-&gt;segment.position));
 610   }
 611 
 612   /* now create the newsegment */
 613   GST_DEBUG_OBJECT (wav, &quot;Creating newsegment from %&quot; G_GINT64_FORMAT
 614       &quot; to %&quot; G_GINT64_FORMAT, wav-&gt;segment.position, stop);
 615 
 616   /* store the newsegment event so it can be sent from the streaming thread. */
 617   if (wav-&gt;start_segment)
 618     gst_event_unref (wav-&gt;start_segment);
 619   wav-&gt;start_segment = gst_event_new_segment (&amp;wav-&gt;segment);
<span class="line-modified"> 620   if (seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added"> 621     gst_event_set_seqnum (wav-&gt;start_segment, seqnum);</span>
 622 
 623   /* mark discont if we are going to stream from another position. */
 624   if (last_stop != wav-&gt;segment.position) {
 625     GST_DEBUG_OBJECT (wav, &quot;mark DISCONT, we did a seek to another position&quot;);
 626     wav-&gt;discont = TRUE;
 627   }
 628 
 629   /* and start the streaming task again */
 630   if (!wav-&gt;streaming) {
 631     gst_pad_start_task (wav-&gt;sinkpad, (GstTaskFunction) gst_wavparse_loop,
 632         wav-&gt;sinkpad, NULL);
 633   }
 634 
 635   GST_PAD_STREAM_UNLOCK (wav-&gt;sinkpad);
 636 
 637   return TRUE;
 638 
 639   /* ERRORS */
 640 negative_rate:
 641   {
</pre>
<hr />
<pre>
1395           if (size &lt; data_size) {
1396             if (!gst_waveparse_ignore_chunk (wav, buf, tag, size)) {
1397               /* need more data */
1398               goto exit;
1399             }
1400             GST_DEBUG_OBJECT (wav, &quot;need %u, available %u; ignoring chunk&quot;,
1401                 data_size, size);
1402             break;
1403           }
1404           /* number of samples (for compressed formats) */
1405           if (wav-&gt;streaming) {
1406             const guint8 *data = NULL;
1407 
1408             if (!gst_wavparse_peek_chunk (wav, &amp;tag, &amp;size)) {
1409               goto exit;
1410             }
1411             gst_adapter_flush (wav-&gt;adapter, 8);
1412             data = gst_adapter_map (wav-&gt;adapter, data_size);
1413 #ifdef GSTREAMER_LITE
1414             if (data == NULL) {
<span class="line-modified">1415               goto header_read_error;</span>
1416             }
1417 #endif // GSTREAMER_LITE
1418             wav-&gt;fact = GST_READ_UINT32_LE (data);
1419             gst_adapter_unmap (wav-&gt;adapter);
1420             gst_adapter_flush (wav-&gt;adapter, GST_ROUND_UP_2 (size));
1421           } else {
1422             gst_buffer_unref (buf);
1423             buf = NULL;
1424             if ((res =
1425                     gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset + 8,
1426                         data_size, &amp;buf)) != GST_FLOW_OK)
1427 #ifdef GSTREAMER_LITE
1428             if (res == GST_FLOW_FLUSHING)
1429               goto exit;
1430             else
1431 #endif // GSTREAMER_LITE
1432               goto header_read_error;
1433             gst_buffer_extract (buf, 0, &amp;wav-&gt;fact, 4);
1434             wav-&gt;fact = GUINT32_FROM_LE (wav-&gt;fact);
1435             gst_buffer_unref (buf);
</pre>
<hr />
<pre>
1748       wav-&gt;segment.duration = wav-&gt;datasize;
1749   }
1750 
1751   /* now we have all the info to perform a pending seek if any, if no
1752    * event, this will still do the right thing and it will also send
1753    * the right newsegment event downstream. */
1754   gst_wavparse_perform_seek (wav, wav-&gt;seek_event);
1755   /* remove pending event */
1756   gst_event_replace (&amp;wav-&gt;seek_event, NULL);
1757 
1758   /* we just started, we are discont */
1759   wav-&gt;discont = TRUE;
1760 
1761   wav-&gt;state = GST_WAVPARSE_DATA;
1762 
1763   /* determine reasonable max buffer size,
1764    * that is, buffers not too small either size or time wise
1765    * so we do not end up with too many of them */
1766   /* var abuse */
1767   if (gst_wavparse_time_to_bytepos (wav, 40 * GST_MSECOND, &amp;upstream_size))
<span class="line-modified">1768     wav-&gt;max_buf_size = upstream_size;</span>
1769   else
1770     wav-&gt;max_buf_size = 0;
1771   wav-&gt;max_buf_size = MAX (wav-&gt;max_buf_size, MAX_BUFFER_SIZE);
1772   if (wav-&gt;blockalign &gt; 0)
1773     wav-&gt;max_buf_size -= (wav-&gt;max_buf_size % wav-&gt;blockalign);
1774 
1775   GST_DEBUG_OBJECT (wav, &quot;max buffer size %u&quot;, wav-&gt;max_buf_size);
1776 
1777   return GST_FLOW_OK;
1778 
1779   /* ERROR */
1780 exit:
1781   {
<span class="line-modified">1782     g_free (codec_name);</span>
<span class="line-modified">1783     g_free (header);</span>
1784     if (caps)
1785       gst_caps_unref (caps);
1786     return res;
1787   }
1788 fail:
1789   {
1790     res = GST_FLOW_ERROR;
1791     goto exit;
1792   }
1793 parse_header_error:
1794   {
1795     GST_ELEMENT_ERROR (wav, STREAM, DEMUX, (NULL),
1796         (&quot;Couldn&#39;t parse audio header&quot;));
1797     goto fail;
1798   }
1799 no_channels:
1800   {
1801     GST_ELEMENT_ERROR (wav, STREAM, FAILED, (NULL),
1802         (&quot;Stream claims to contain no channels - invalid data&quot;));
1803     goto fail;
</pre>
<hr />
<pre>
1948       gst_tag_list_remove_tag (tags, GST_TAG_CONTAINER_FORMAT);
1949       gst_event_unref (ev);
1950       break;
1951     }
1952     tags = NULL;
1953     gst_event_unref (ev);
1954   }
1955   return tags;
1956 }
1957 
1958 static void
1959 gst_wavparse_add_src_pad (GstWavParse * wav, GstBuffer * buf)
1960 {
1961   GstStructure *s;
1962   GstTagList *tags, *utags;
1963 
1964   GST_DEBUG_OBJECT (wav, &quot;adding src pad&quot;);
1965 
1966   g_assert (wav-&gt;caps != NULL);
1967 
<span class="line-modified">1968   s = gst_caps_get_structure (wav-&gt;caps, 0);</span>
1969   if (s &amp;&amp; gst_structure_has_name (s, &quot;audio/x-raw&quot;) &amp;&amp; buf != NULL) {
<span class="line-modified">1970     GstTypeFindProbability prob;</span>
<span class="line-modified">1971     GstCaps *tf_caps;</span>
<span class="line-modified">1972 </span>
<span class="line-modified">1973     tf_caps = gst_type_find_helper_for_buffer (GST_OBJECT (wav), buf, &amp;prob);</span>
<span class="line-modified">1974     if (tf_caps != NULL) {</span>
<span class="line-modified">1975       GST_LOG (&quot;typefind caps = %&quot; GST_PTR_FORMAT &quot;, P=%d&quot;, tf_caps, prob);</span>
<span class="line-modified">1976       if (gst_wavparse_have_dts_caps (tf_caps, prob)) {</span>
<span class="line-modified">1977         GST_INFO_OBJECT (wav, &quot;Found DTS marker in file marked as raw PCM&quot;);</span>
<span class="line-modified">1978         gst_caps_unref (wav-&gt;caps);</span>
<span class="line-modified">1979         wav-&gt;caps = tf_caps;</span>
<span class="line-modified">1980 </span>
<span class="line-modified">1981         gst_tag_list_add (wav-&gt;tags, GST_TAG_MERGE_REPLACE,</span>
<span class="line-modified">1982             GST_TAG_AUDIO_CODEC, &quot;dts&quot;, NULL);</span>
<span class="line-modified">1983       } else {</span>
<span class="line-modified">1984         GST_DEBUG_OBJECT (wav, &quot;found caps %&quot; GST_PTR_FORMAT &quot; for stream &quot;</span>
<span class="line-modified">1985             &quot;marked as raw PCM audio, but ignoring for now&quot;, tf_caps);</span>
<span class="line-modified">1986         gst_caps_unref (tf_caps);</span>

1987       }
1988     }
<span class="line-added">1989   }</span>
1990 
1991   gst_pad_set_caps (wav-&gt;srcpad, wav-&gt;caps);
1992 
1993   if (wav-&gt;start_segment) {
1994     GST_DEBUG_OBJECT (wav, &quot;Send start segment event on newpad&quot;);
1995     gst_pad_push_event (wav-&gt;srcpad, wav-&gt;start_segment);
1996     wav-&gt;start_segment = NULL;
1997   }
1998 
1999   /* upstream tags, e.g. from id3/ape tag before the wav file; assume for now
2000    * that there&#39;ll be only one scope/type of tag list from upstream, if any */
2001   utags = gst_wavparse_get_upstream_tags (wav, GST_TAG_SCOPE_GLOBAL);
2002   if (utags == NULL)
2003     utags = gst_wavparse_get_upstream_tags (wav, GST_TAG_SCOPE_STREAM);
2004 
2005   /* if there&#39;s a tag upstream it&#39;s probably been added to override the
2006    * tags from inside the wav header, so keep upstream tags if in doubt */
2007   tags = gst_tag_list_merge (utags, wav-&gt;tags, GST_TAG_MERGE_KEEP);
2008 
2009   if (wav-&gt;tags != NULL) {
</pre>
<hr />
<pre>
2035 
2036   if ((wav-&gt;dataleft == 0 || wav-&gt;dataleft &lt; wav-&gt;blockalign)) {
2037     /* In case chunk size is not declared in the begining get size from the
2038      * file size directly */
2039     if (wav-&gt;chunk_size == 0) {
2040       gint64 upstream_size = 0;
2041 
2042       /* Get the size of the file   */
2043       if (!gst_pad_peer_query_duration (wav-&gt;sinkpad, GST_FORMAT_BYTES,
2044               &amp;upstream_size))
2045         goto found_eos;
2046 
2047       if (upstream_size &lt; wav-&gt;offset + wav-&gt;datastart)
2048         goto found_eos;
2049 
2050       /* If file has updated since the beggining continue reading the file */
2051       wav-&gt;dataleft = upstream_size - wav-&gt;offset - wav-&gt;datastart;
2052       wav-&gt;end_offset = upstream_size;
2053 
2054       /* Get the next n bytes and output them, if we can */
<span class="line-modified">2055       if (wav-&gt;dataleft == 0 || wav-&gt;dataleft &lt; wav-&gt;blockalign)</span>
<span class="line-modified">2056         goto found_eos;</span>
2057     } else {
2058       goto found_eos;
2059     }
2060   }
2061 
2062   /* scale the amount of data by the segment rate so we get equal
2063    * amounts of data regardless of the playback rate */
2064   desired =
2065       MIN (gst_guint64_to_gdouble (wav-&gt;dataleft),
2066       wav-&gt;max_buf_size * ABS (wav-&gt;segment.rate));
2067 
2068   if (desired &gt;= wav-&gt;blockalign &amp;&amp; wav-&gt;blockalign &gt; 0)
2069     desired -= (desired % wav-&gt;blockalign);
2070 
2071 #ifdef GSTREAMER_LITE
2072   if (desired == 0) {
2073     GST_ELEMENT_ERROR (wav, STREAM, DEMUX, (NULL),
2074               (&quot;Invalid stream&quot;));
2075     return GST_FLOW_ERROR;
2076   }
</pre>
<hr />
<pre>
2308 
2309     GST_DEBUG_OBJECT (wav, &quot;pausing task, reason %s&quot;, reason);
2310     gst_pad_pause_task (pad);
2311 
2312     if (ret == GST_FLOW_EOS) {
2313       /* handle end-of-stream/segment */
2314       /* so align our position with the end of it, if there is one
2315        * this ensures a subsequent will arrive at correct base/acc time */
2316       if (wav-&gt;segment.format == GST_FORMAT_TIME) {
2317         if (wav-&gt;segment.rate &gt; 0.0 &amp;&amp;
2318             GST_CLOCK_TIME_IS_VALID (wav-&gt;segment.stop))
2319           wav-&gt;segment.position = wav-&gt;segment.stop;
2320         else if (wav-&gt;segment.rate &lt; 0.0)
2321           wav-&gt;segment.position = wav-&gt;segment.start;
2322       }
2323       if (wav-&gt;state == GST_WAVPARSE_START || !wav-&gt;caps) {
2324         GST_ELEMENT_ERROR (wav, STREAM, WRONG_TYPE, (NULL),
2325             (&quot;No valid input found before end of stream&quot;));
2326         gst_pad_push_event (wav-&gt;srcpad, gst_event_new_eos ());
2327       } else {
<span class="line-modified">2328         /* add pad before we perform EOS */</span>
<span class="line-modified">2329         if (G_UNLIKELY (wav-&gt;first)) {</span>
<span class="line-modified">2330           wav-&gt;first = FALSE;</span>
<span class="line-modified">2331           gst_wavparse_add_src_pad (wav, NULL);</span>
<span class="line-modified">2332         }</span>
2333 
<span class="line-modified">2334         /* perform EOS logic */</span>
<span class="line-modified">2335         if (wav-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {</span>
<span class="line-modified">2336           GstClockTime stop;</span>
2337 
<span class="line-modified">2338           if ((stop = wav-&gt;segment.stop) == -1)</span>
<span class="line-modified">2339             stop = wav-&gt;segment.duration;</span>
2340 
<span class="line-modified">2341           gst_element_post_message (GST_ELEMENT_CAST (wav),</span>
<span class="line-modified">2342               gst_message_new_segment_done (GST_OBJECT_CAST (wav),</span>
<span class="line-modified">2343                   wav-&gt;segment.format, stop));</span>
2344           gst_pad_push_event (wav-&gt;srcpad,
2345               gst_event_new_segment_done (wav-&gt;segment.format, stop));
<span class="line-modified">2346         } else {</span>
2347           gst_pad_push_event (wav-&gt;srcpad, gst_event_new_eos ());
<span class="line-modified">2348         }</span>
2349       }
2350     } else if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS) {
2351       /* for fatal errors we post an error message, post the error
2352        * first so the app knows about the error first. */
2353       GST_ELEMENT_FLOW_ERROR (wav, ret);
<span class="line-modified">2354       gst_pad_push_event (wav-&gt;srcpad, gst_event_new_eos ());</span>
2355     }
2356     return;
2357   }
2358 }
2359 
2360 static GstFlowReturn
2361 gst_wavparse_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
2362 {
2363   GstFlowReturn ret;
2364   GstWavParse *wav = GST_WAVPARSE (parent);
2365 
2366   GST_LOG_OBJECT (wav, &quot;adapter_push %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
2367       gst_buffer_get_size (buf));
2368 
2369   gst_adapter_push (wav-&gt;adapter, buf);
2370 
2371   switch (wav-&gt;state) {
2372     case GST_WAVPARSE_START:
2373       GST_INFO_OBJECT (wav, &quot;GST_WAVPARSE_START&quot;);
2374       if ((ret = gst_wavparse_parse_stream_init (wav)) != GST_FLOW_OK)
</pre>
<hr />
<pre>
2537 #endif // GSTREAMER_LITE
2538       } else {
2539         /* infinity; upstream will EOS when done */
2540         wav-&gt;dataleft = G_MAXUINT64;
2541       }
2542     exit:
2543       gst_event_unref (event);
2544       break;
2545     }
2546 #ifdef GSTREAMER_LITE
2547     case FX_EVENT_RANGE_READY: // This event appears only in pull mode during outrange seeking.
2548         ret = gst_pad_start_task (pad, (GstTaskFunction) gst_wavparse_loop, pad, NULL);
2549         gst_event_unref(event);
2550         break;
2551 #endif // GSTREAMER_LITE
2552     case GST_EVENT_EOS:
2553       if (wav-&gt;state == GST_WAVPARSE_START || !wav-&gt;caps) {
2554         GST_ELEMENT_ERROR (wav, STREAM, WRONG_TYPE, (NULL),
2555             (&quot;No valid input found before end of stream&quot;));
2556       } else {
<span class="line-modified">2557         /* add pad if needed so EOS is seen downstream */</span>
<span class="line-modified">2558         if (G_UNLIKELY (wav-&gt;first)) {</span>
<span class="line-modified">2559           wav-&gt;first = FALSE;</span>
<span class="line-modified">2560           gst_wavparse_add_src_pad (wav, NULL);</span>
<span class="line-modified">2561         } else {</span>
<span class="line-modified">2562           /* stream leftover data in current segment */</span>
<span class="line-modified">2563           gst_wavparse_flush_data (wav);</span>
<span class="line-modified">2564         }</span>
2565       }
2566 
2567       /* fall-through */
2568     case GST_EVENT_FLUSH_STOP:
2569     {
2570       GstClockTime dur;
2571 
2572       if (wav-&gt;adapter)
<span class="line-modified">2573         gst_adapter_clear (wav-&gt;adapter);</span>
2574       wav-&gt;discont = TRUE;
2575       dur = wav-&gt;segment.duration;
2576       gst_segment_init (&amp;wav-&gt;segment, wav-&gt;segment.format);
2577       wav-&gt;segment.duration = dur;
2578       /* fall-through */
2579     }
2580     default:
2581       ret = gst_pad_event_default (wav-&gt;sinkpad, parent, event);
2582       break;
2583   }
2584 
2585   return ret;
2586 }
2587 
2588 #if 0
2589 /* convert and query stuff */
2590 static const GstFormat *
2591 gst_wavparse_get_formats (GstPad * pad)
2592 {
2593   static const GstFormat formats[] = {
</pre>
<hr />
<pre>
2806 
2807           q = gst_query_new_seeking (GST_FORMAT_BYTES);
2808           if ((res = gst_pad_peer_query (wav-&gt;sinkpad, q))) {
2809             gst_query_parse_seeking (q, &amp;fmt, &amp;seekable, NULL, NULL);
2810             GST_LOG_OBJECT (wav, &quot;upstream BYTE seekable %d&quot;, seekable);
2811           }
2812           gst_query_unref (q);
2813         } else {
2814           GST_LOG_OBJECT (wav, &quot;looping =&gt; seekable&quot;);
2815           seekable = TRUE;
2816           res = TRUE;
2817         }
2818       } else if (fmt == GST_FORMAT_TIME) {
2819         res = TRUE;
2820       }
2821       if (res) {
2822         gst_query_set_seeking (query, fmt, seekable, 0, wav-&gt;segment.duration);
2823       }
2824       break;
2825     }
<span class="line-added">2826     case GST_QUERY_SEGMENT:</span>
<span class="line-added">2827     {</span>
<span class="line-added">2828       GstFormat format;</span>
<span class="line-added">2829       gint64 start, stop;</span>
<span class="line-added">2830 </span>
<span class="line-added">2831       format = wav-&gt;segment.format;</span>
<span class="line-added">2832 </span>
<span class="line-added">2833       start =</span>
<span class="line-added">2834           gst_segment_to_stream_time (&amp;wav-&gt;segment, format,</span>
<span class="line-added">2835           wav-&gt;segment.start);</span>
<span class="line-added">2836       if ((stop = wav-&gt;segment.stop) == -1)</span>
<span class="line-added">2837         stop = wav-&gt;segment.duration;</span>
<span class="line-added">2838       else</span>
<span class="line-added">2839         stop = gst_segment_to_stream_time (&amp;wav-&gt;segment, format, stop);</span>
<span class="line-added">2840 </span>
<span class="line-added">2841       gst_query_set_segment (query, wav-&gt;segment.rate, format, start, stop);</span>
<span class="line-added">2842       res = TRUE;</span>
<span class="line-added">2843       break;</span>
<span class="line-added">2844     }</span>
2845     default:
2846       res = gst_pad_query_default (pad, parent, query);
2847       break;
2848   }
2849   return res;
2850 }
2851 
2852 #ifdef GSTREAMER_LITE
2853 static gboolean
2854 gst_wavparse_sink_query (GstPad* pad, GstObject *parent, GstQuery* query)
2855 {
2856     gboolean result = TRUE;
2857     switch (GST_QUERY_TYPE(query))
2858     {
2859         case GST_QUERY_CUSTOM:
2860         {
2861             const GstStructure *s = gst_query_get_structure(query);
2862             if (gst_structure_has_name(s, GETRANGE_QUERY_NAME))
2863                 gst_structure_set(s, GETRANGE_QUERY_SUPPORTS_FIELDNANE,
2864                                      GETRANGE_QUERY_SUPPORTS_FIELDTYPE,
</pre>
<hr />
<pre>
2949     gst_adapter_clear (wav-&gt;adapter);
2950     g_object_unref (wav-&gt;adapter);
2951     wav-&gt;adapter = NULL;
2952   }
2953 
2954   query = gst_query_new_scheduling ();
2955 
2956   if (!gst_pad_peer_query (sinkpad, query)) {
2957     gst_query_unref (query);
2958     goto activate_push;
2959   }
2960 
2961   pull_mode = gst_query_has_scheduling_mode_with_flags (query,
2962       GST_PAD_MODE_PULL, GST_SCHEDULING_FLAG_SEEKABLE);
2963   gst_query_unref (query);
2964 
2965   if (!pull_mode)
2966     goto activate_push;
2967 
2968   GST_DEBUG_OBJECT (sinkpad, &quot;activating pull&quot;);
<span class="line-modified">2969   wav-&gt;streaming = FALSE;</span>
2970   return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PULL, TRUE);
2971 
2972 activate_push:
2973   {
2974     GST_DEBUG_OBJECT (sinkpad, &quot;activating push&quot;);
2975     wav-&gt;streaming = TRUE;
2976     wav-&gt;adapter = gst_adapter_new ();
2977     return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PUSH, TRUE);
2978   }
2979 }
2980 
2981 
2982 static gboolean
2983 gst_wavparse_sink_activate_mode (GstPad * sinkpad, GstObject * parent,
2984     GstPadMode mode, gboolean active)
2985 {
2986   gboolean res;
2987 
2988   switch (mode) {
2989     case GST_PAD_MODE_PUSH:
2990       res = TRUE;
2991       break;
2992     case GST_PAD_MODE_PULL:
<span class="line-modified">2993       if (active) {</span>
<span class="line-modified">2994         /* if we have a scheduler we can start the task */</span>
2995         res = gst_pad_start_task (sinkpad, (GstTaskFunction) gst_wavparse_loop,
2996             sinkpad, NULL);
<span class="line-modified">2997       } else {</span>
2998         res = gst_pad_stop_task (sinkpad);
<span class="line-modified">2999       }</span>
3000       break;
3001     default:
3002       res = FALSE;
3003       break;
3004   }
3005   return res;
3006 }
3007 
3008 static GstStateChangeReturn
3009 gst_wavparse_change_state (GstElement * element, GstStateChange transition)
3010 {
3011   GstStateChangeReturn ret;
3012   GstWavParse *wav = GST_WAVPARSE (element);
3013 
3014   switch (transition) {
3015     case GST_STATE_CHANGE_NULL_TO_READY:
3016       break;
3017     case GST_STATE_CHANGE_READY_TO_PAUSED:
3018       gst_wavparse_reset (wav);
3019       break;
</pre>
</td>
</tr>
</table>
<center><a href="../spectrum/gstspectrum.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="gstwavparse.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>