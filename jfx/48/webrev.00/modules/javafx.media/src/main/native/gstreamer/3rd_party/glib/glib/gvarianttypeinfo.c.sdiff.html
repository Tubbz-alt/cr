<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvarianttypeinfo.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gvarianttype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gvarianttypeinfo.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvarianttypeinfo.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright � 2008 Ryan Lortie</span>
<span class="line-modified">  3  * Copyright � 2010 Codethink Limited</span>
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Lesser General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2.1 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Lesser General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Lesser General Public
 16  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 17  *
 18  * Author: Ryan Lortie &lt;desrt@desrt.ca&gt;
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 
 23 #include &quot;gvarianttypeinfo.h&quot;
 24 
 25 #include &lt;glib/gtestutils.h&gt;
 26 #include &lt;glib/gthread.h&gt;
 27 #include &lt;glib/gslice.h&gt;
 28 #include &lt;glib/ghash.h&gt;

 29 
 30 /* &lt; private &gt;
 31  * GVariantTypeInfo:
 32  *
 33  * This structure contains the necessary information to facilitate the
 34  * serialisation and fast deserialisation of a given type of GVariant
 35  * value.  A GVariant instance holds a pointer to one of these
 36  * structures to provide for efficient operation.
 37  *
 38  * The GVariantTypeInfo structures for all of the base types, plus the
 39  * &quot;variant&quot; type are stored in a read-only static array.
 40  *
 41  * For container types, a hash table and reference counting is used to
 42  * ensure that only one of these structures exists for any given type.
 43  * In general, a container GVariantTypeInfo will exist for a given type
 44  * only if one or more GVariant instances of that type exist or if
 45  * another GVariantTypeInfo has that type as a subtype.  For example, if
 46  * a process contains a single GVariant instance with type &quot;(asv)&quot;, then
 47  * container GVariantTypeInfo structures will exist for &quot;(asv)&quot; and
 48  * for &quot;as&quot; (note that &quot;s&quot; and &quot;v&quot; always exist in the static array).
</pre>
<hr />
<pre>
 59  * 0 otherwise (since no type has a fixed size of 0).
 60  *
 61  * &#39;alignment&#39; is set to one less than the alignment requirement for
 62  * this type.  This makes many operations much more convenient.
 63  */
 64 struct _GVariantTypeInfo
 65 {
 66   gsize fixed_size;
 67   guchar alignment;
 68   guchar container_class;
 69 };
 70 
 71 /* Container types are reference counted.  They also need to have their
 72  * type string stored explicitly since it is not merely a single letter.
 73  */
 74 typedef struct
 75 {
 76   GVariantTypeInfo info;
 77 
 78   gchar *type_string;
<span class="line-modified"> 79   gint ref_count;</span>
 80 } ContainerInfo;
 81 
 82 /* For &#39;array&#39; and &#39;maybe&#39; types, we store some extra information on the
 83  * end of the GVariantTypeInfo struct -- the element type (ie: &quot;s&quot; for
 84  * &quot;as&quot;).  The container GVariantTypeInfo structure holds a reference to
 85  * the element typeinfo.
 86  */
 87 typedef struct
 88 {
 89   ContainerInfo container;
 90 
 91   GVariantTypeInfo *element;
 92 } ArrayInfo;
 93 
 94 /* For &#39;tuple&#39; and &#39;dict entry&#39; types, we store extra information for
 95  * each member -- its type and how to find it inside the serialised data
 96  * in O(1) time using 4 variables -- &#39;i&#39;, &#39;a&#39;, &#39;b&#39;, and &#39;c&#39;.  See the
 97  * comment on GVariantMemberInfo in gvarianttypeinfo.h.
 98  */
 99 typedef struct
100 {
101   ContainerInfo container;
102 
103   GVariantMemberInfo *members;
104   gsize n_members;
105 } TupleInfo;
106 
107 
108 /* Hard-code the base types in a constant array */
109 static const GVariantTypeInfo g_variant_type_info_basic_table[24] = {
<span class="line-modified">110 #define fixed_aligned(x)  x, x - 1</span>
<span class="line-modified">111 #define not_a_type             0,</span>
<span class="line-modified">112 #define unaligned         0, 0</span>
<span class="line-modified">113 #define aligned(x)        0, x - 1</span>
114   /* &#39;b&#39; */ { fixed_aligned(1) },   /* boolean */
115   /* &#39;c&#39; */ { not_a_type },
116   /* &#39;d&#39; */ { fixed_aligned(8) },   /* double */
117   /* &#39;e&#39; */ { not_a_type },
118   /* &#39;f&#39; */ { not_a_type },
119   /* &#39;g&#39; */ { unaligned        },   /* signature string */
120   /* &#39;h&#39; */ { fixed_aligned(4) },   /* file handle (int32) */
121   /* &#39;i&#39; */ { fixed_aligned(4) },   /* int32 */
122   /* &#39;j&#39; */ { not_a_type },
123   /* &#39;k&#39; */ { not_a_type },
124   /* &#39;l&#39; */ { not_a_type },
125   /* &#39;m&#39; */ { not_a_type },
126   /* &#39;n&#39; */ { fixed_aligned(2) },   /* int16 */
127   /* &#39;o&#39; */ { unaligned        },   /* object path string */
128   /* &#39;p&#39; */ { not_a_type },
129   /* &#39;q&#39; */ { fixed_aligned(2) },   /* uint16 */
130   /* &#39;r&#39; */ { not_a_type },
131   /* &#39;s&#39; */ { unaligned        },   /* string */
132   /* &#39;t&#39; */ { fixed_aligned(8) },   /* uint64 */
133   /* &#39;u&#39; */ { fixed_aligned(4) },   /* uint32 */
</pre>
<hr />
<pre>
139 #undef not_a_type
140 #undef unaligned
141 #undef aligned
142 };
143 
144 /* We need to have type strings to return for the base types.  We store
145  * those in another array.  Since all base type strings are single
146  * characters this is easy.  By not storing pointers to strings into the
147  * GVariantTypeInfo itself, we save a bunch of relocations.
148  */
149 static const char g_variant_type_info_basic_chars[24][2] = {
150   &quot;b&quot;, &quot; &quot;, &quot;d&quot;, &quot; &quot;, &quot; &quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;,
151   &quot;n&quot;, &quot;o&quot;, &quot; &quot;, &quot;q&quot;, &quot; &quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot; &quot;, &quot;x&quot;, &quot;y&quot;
152 };
153 
154 /* sanity checks to make debugging easier */
155 static void
156 g_variant_type_info_check (const GVariantTypeInfo *info,
157                            char                    container_class)
158 {

159   g_assert (!container_class || info-&gt;container_class == container_class);
160 
161   /* alignment can only be one of these */
162   g_assert (info-&gt;alignment == 0 || info-&gt;alignment == 1 ||
163             info-&gt;alignment == 3 || info-&gt;alignment == 7);
164 
165   if (info-&gt;container_class)
166     {
167       ContainerInfo *container = (ContainerInfo *) info;
168 
169       /* extra checks for containers */
<span class="line-modified">170       g_assert_cmpint (container-&gt;ref_count, &gt;, 0);</span>
171       g_assert (container-&gt;type_string != NULL);
172     }
173   else
174     {
175       gint index;
176 
177       /* if not a container, then ensure that it is a valid member of
178        * the basic types table
179        */
180       index = info - g_variant_type_info_basic_table;
181 
182       g_assert (G_N_ELEMENTS (g_variant_type_info_basic_table) == 24);
183       g_assert (G_N_ELEMENTS (g_variant_type_info_basic_chars) == 24);
184       g_assert (0 &lt;= index &amp;&amp; index &lt; 24);
185       g_assert (g_variant_type_info_basic_chars[index][0] != &#39; &#39;);
186     }

187 }
188 
189 /* &lt; private &gt;
190  * g_variant_type_info_get_type_string:
191  * @info: a #GVariantTypeInfo
192  *
193  * Gets the type string for @info.  The string is nul-terminated.
194  */
195 const gchar *
196 g_variant_type_info_get_type_string (GVariantTypeInfo *info)
197 {
198   g_variant_type_info_check (info, 0);
199 
200   if (info-&gt;container_class)
201     {
202       ContainerInfo *container = (ContainerInfo *) info;
203 
204       /* containers have their type string stored inside them */
205       return container-&gt;type_string;
206     }
207   else
208     {
209       gint index;
210 
211       /* look up the type string in the base type array.  the call to
212        * g_variant_type_info_check() above already ensured validity.
213        */
214       index = info - g_variant_type_info_basic_table;
215 
216       return g_variant_type_info_basic_chars[index];
217     }
218 }
219 
220 /* &lt; private &gt;
221  * g_variant_type_info_query:
222  * @info: a #GVariantTypeInfo
<span class="line-modified">223  * @alignment: (nullable): the location to store the alignment, or %NULL</span>
<span class="line-modified">224  * @fixed_size: (nullable): the location to store the fixed size, or %NULL</span>
225  *
226  * Queries @info to determine the alignment requirements and fixed size
227  * (if any) of the type.
228  *
229  * @fixed_size, if non-%NULL is set to the fixed size of the type, or 0
230  * to indicate that the type is a variable-sized type.  No type has a
231  * fixed size of 0.
232  *
233  * @alignment, if non-%NULL, is set to one less than the required
234  * alignment of the type.  For example, for a 32bit integer, @alignment
235  * would be set to 3.  This allows you to round an integer up to the
236  * proper alignment by performing the following efficient calculation:
237  *
238  *   offset += ((-offset) &amp; alignment);
239  */
240 void
241 g_variant_type_info_query (GVariantTypeInfo *info,
242                            guint            *alignment,
243                            gsize            *fixed_size)
244 {
245   g_variant_type_info_check (info, 0);
246 
247   if (alignment)
248     *alignment = info-&gt;alignment;
249 
250   if (fixed_size)
251     *fixed_size = info-&gt;fixed_size;
252 }
253 
254 /* &lt; private &gt;
255  * g_variant_type_info_query_depth:
256  * @info: a #GVariantTypeInfo
257  *
258  * Queries @info to determine the depth of the type.
259  *
260  * See g_variant_type_string_get_depth_() for more details.
261  *
262  * Returns: depth of @info
<span class="line-modified">263  * Since: 2.60 (backported to 2.58)</span>
264  */
265 gsize
266 g_variant_type_info_query_depth (GVariantTypeInfo *info)
267 {
268   g_variant_type_info_check (info, 0);
269 
270   if (info-&gt;container_class)
271     {
272       ContainerInfo *container = (ContainerInfo *) info;
273       return g_variant_type_string_get_depth_ (container-&gt;type_string);
274     }
275 
276   return 1;
277 }
278 
279 /* == array == */
280 #define GV_ARRAY_INFO_CLASS &#39;a&#39;
281 static ArrayInfo *
282 GV_ARRAY_INFO (GVariantTypeInfo *info)
283 {
</pre>
<hr />
<pre>
317 
318   return (ContainerInfo *) info;
319 }
320 
321 /* &lt; private &gt;
322  * g_variant_type_info_element:
323  * @info: a #GVariantTypeInfo for an array or maybe type
324  *
325  * Returns the element type for the array or maybe type.  A reference is
326  * not added, so the caller must add their own.
327  */
328 GVariantTypeInfo *
329 g_variant_type_info_element (GVariantTypeInfo *info)
330 {
331   return GV_ARRAY_INFO (info)-&gt;element;
332 }
333 
334 /* &lt; private &gt;
335  * g_variant_type_query_element:
336  * @info: a #GVariantTypeInfo for an array or maybe type
<span class="line-modified">337  * @alignment: (nullable): the location to store the alignment, or %NULL</span>
<span class="line-modified">338  * @fixed_size: (nullable): the location to store the fixed size, or %NULL</span>
339  *
340  * Returns the alignment requires and fixed size (if any) for the
341  * element type of the array.  This call is a convenience wrapper around
342  * g_variant_type_info_element() and g_variant_type_info_query().
343  */
344 void
345 g_variant_type_info_query_element (GVariantTypeInfo *info,
346                                    guint            *alignment,
347                                    gsize            *fixed_size)
348 {
349   g_variant_type_info_query (GV_ARRAY_INFO (info)-&gt;element,
350                              alignment, fixed_size);
351 }
352 
353 /* == tuple == */
354 #define GV_TUPLE_INFO_CLASS &#39;r&#39;
355 static TupleInfo *
356 GV_TUPLE_INFO (GVariantTypeInfo *info)
357 {
358   g_variant_type_info_check (info, GV_TUPLE_INFO_CLASS);
359 
360   return (TupleInfo *) info;
361 }
362 
363 static void
364 tuple_info_free (GVariantTypeInfo *info)
365 {
366   TupleInfo *tuple_info;
<span class="line-modified">367   gint i;</span>
368 
369   g_assert (info-&gt;container_class == GV_TUPLE_INFO_CLASS);
370   tuple_info = (TupleInfo *) info;
371 
372   for (i = 0; i &lt; tuple_info-&gt;n_members; i++)
373     g_variant_type_info_unref (tuple_info-&gt;members[i].type_info);
374 
375   g_slice_free1 (sizeof (GVariantMemberInfo) * tuple_info-&gt;n_members,
376                  tuple_info-&gt;members);
377   g_slice_free (TupleInfo, tuple_info);
378 }
379 
380 static void
381 tuple_allocate_members (const GVariantType  *type,
382                         GVariantMemberInfo **members,
383                         gsize               *n_members)
384 {
385   const GVariantType *item_type;
386   gsize i = 0;
387 
</pre>
<hr />
<pre>
531    */
532 
533   item-&gt;i = i;
534   item-&gt;a = a + b;
535   item-&gt;b = ~b;
536   item-&gt;c = c;
537 }
538 
539 static gsize
540 tuple_align (gsize offset,
541              guint alignment)
542 {
543   return offset + ((-offset) &amp; alignment);
544 }
545 
546 /* This function is the heart of the algorithm for calculating &#39;i&#39;, &#39;a&#39;,
547  * &#39;b&#39; and &#39;c&#39; for each item in the tuple.
548  *
549  * Imagine we want to find the start of the &quot;i&quot; in the type &quot;(su(qx)ni)&quot;.
550  * That&#39;s a string followed by a uint32, then a tuple containing a
<span class="line-modified">551  * uint16 and a int64, then an int16, then our &quot;i&quot;.  In order to get to</span>
552  * our &quot;i&quot; we:
553  *
554  * Start at the end of the string, align to 4 (for the uint32), add 4.
555  * Align to 8, add 16 (for the tuple).  Align to 2, add 2 (for the
556  * int16).  Then we&#39;re there.  It turns out that, given 3 simple rules,
557  * we can flatten this iteration into one addition, one alignment, then
558  * one more addition.
559  *
560  * The loop below plays through each item in the tuple, querying its
561  * alignment and fixed_size into &#39;d&#39; and &#39;e&#39;, respectively.  At all
562  * times the variables &#39;a&#39;, &#39;b&#39;, and &#39;c&#39; are maintained such that in
563  * order to get to the current point, you add &#39;a&#39;, align to &#39;b&#39; then add
564  * &#39;c&#39;.  &#39;b&#39; is kept in &quot;one less than&quot; form.  For each item, the proper
565  * alignment is applied to find the values of &#39;a&#39;, &#39;b&#39; and &#39;c&#39; to get to
566  * the start of that item.  Those values are recorded into the table.
567  * The fixed size of the item (if applicable) is then added on.
568  *
569  * These 3 rules are how &#39;a&#39;, &#39;b&#39; and &#39;c&#39; are modified for alignment and
570  * addition of fixed size.  They have been proven correct but are
571  * presented here, without proof:
</pre>
<hr />
<pre>
625   if (info-&gt;n_members &gt; 0)
626     {
627       GVariantMemberInfo *m;
628 
629       /* the alignment requirement of the tuple is the alignment
630        * requirement of its largest item.
631        */
632       base-&gt;alignment = 0;
633       for (m = info-&gt;members; m &lt; &amp;info-&gt;members[info-&gt;n_members]; m++)
634         /* can find the max of a list of &quot;one less than&quot; powers of two
635          * by &#39;or&#39;ing them
636          */
637         base-&gt;alignment |= m-&gt;type_info-&gt;alignment;
638 
639       m--; /* take &#39;m&#39; back to the last item */
640 
641       /* the structure only has a fixed size if no variable-size
642        * offsets are stored and the last item is fixed-sized too (since
643        * an offset is never stored for the last item).
644        */
<span class="line-modified">645       if (m-&gt;i == -1 &amp;&amp; m-&gt;type_info-&gt;fixed_size)</span>
646         /* in that case, the fixed size can be found by finding the
647          * start of the last item (in the usual way) and adding its
648          * fixed size.
649          *
650          * if a tuple has a fixed size then it is always a multiple of
651          * the alignment requirement (to make packing into arrays
652          * easier) so we round up to that here.
653          */
654         base-&gt;fixed_size =
655           tuple_align (((m-&gt;a &amp; m-&gt;b) | m-&gt;c) + m-&gt;type_info-&gt;fixed_size,
656                        base-&gt;alignment);
657       else
658         /* else, the tuple is not fixed size */
659         base-&gt;fixed_size = 0;
660     }
661   else
662     {
663       /* the empty tuple: &#39;()&#39;.
664        *
<span class="line-modified">665        * has a size of 1 and an no alignment requirement.</span>
666        *
667        * It has a size of 1 (not 0) for two practical reasons:
668        *
669        *  1) So we can determine how many of them are in an array
670        *     without dividing by zero or without other tricks.
671        *
672        *  2) Even if we had some trick to know the number of items in
673        *     the array (as GVariant did at one time) this would open a
674        *     potential denial of service attack: an attacker could send
675        *     you an extremely small array (in terms of number of bytes)
676        *     containing trillions of zero-sized items.  If you iterated
677        *     over this array you would effectively infinite-loop your
678        *     program.  By forcing a size of at least one, we bound the
679        *     amount of computation done in response to a message to a
680        *     reasonable function of the size of that message.
681        */
682       base-&gt;alignment = 0;
683       base-&gt;fixed_size = 1;
684     }
685 }
</pre>
<hr />
<pre>
781         g_variant_type_info_table = g_hash_table_new (g_str_hash,
782                                                       g_str_equal);
783       info = g_hash_table_lookup (g_variant_type_info_table, type_string);
784 
785       if (info == NULL)
786         {
787           ContainerInfo *container;
788 
789           if (type_char == G_VARIANT_TYPE_INFO_CHAR_MAYBE ||
790               type_char == G_VARIANT_TYPE_INFO_CHAR_ARRAY)
791             {
792               container = array_info_new (type);
793             }
794           else /* tuple or dict entry */
795             {
796               container = tuple_info_new (type);
797             }
798 
799           info = (GVariantTypeInfo *) container;
800           container-&gt;type_string = type_string;
<span class="line-modified">801           container-&gt;ref_count = 1;</span>
802 
803           g_hash_table_insert (g_variant_type_info_table, type_string, info);
804           type_string = NULL;
805         }
806       else
807         g_variant_type_info_ref (info);
808 
809       g_rec_mutex_unlock (&amp;g_variant_type_info_lock);
810       g_variant_type_info_check (info, 0);
811       g_free (type_string);
812 
813       return info;
814     }
815   else
816     {
817       const GVariantTypeInfo *info;
818       int index;
819 
820       index = type_char - &#39;b&#39;;
821       g_assert (G_N_ELEMENTS (g_variant_type_info_basic_table) == 24);
</pre>
<hr />
<pre>
827 
828       return (GVariantTypeInfo *) info;
829     }
830 }
831 
832 /* &lt; private &gt;
833  * g_variant_type_info_ref:
834  * @info: a #GVariantTypeInfo
835  *
836  * Adds a reference to @info.
837  */
838 GVariantTypeInfo *
839 g_variant_type_info_ref (GVariantTypeInfo *info)
840 {
841   g_variant_type_info_check (info, 0);
842 
843   if (info-&gt;container_class)
844     {
845       ContainerInfo *container = (ContainerInfo *) info;
846 
<span class="line-modified">847       g_assert_cmpint (container-&gt;ref_count, &gt;, 0);</span>
<span class="line-removed">848       g_atomic_int_inc (&amp;container-&gt;ref_count);</span>
849     }
850 
851   return info;
852 }
853 
854 /* &lt; private &gt;
855  * g_variant_type_info_unref:
856  * @info: a #GVariantTypeInfo
857  *
858  * Releases a reference held on @info.  This may result in @info being
859  * freed.
860  */
861 void
862 g_variant_type_info_unref (GVariantTypeInfo *info)
863 {
864   g_variant_type_info_check (info, 0);
865 
866   if (info-&gt;container_class)
867     {
868       ContainerInfo *container = (ContainerInfo *) info;
869 
870       g_rec_mutex_lock (&amp;g_variant_type_info_lock);
<span class="line-modified">871       if (g_atomic_int_dec_and_test (&amp;container-&gt;ref_count))</span>
872         {
873           g_hash_table_remove (g_variant_type_info_table,
874                                container-&gt;type_string);
875           if (g_hash_table_size (g_variant_type_info_table) == 0)
876             {
877               g_hash_table_unref (g_variant_type_info_table);
878               g_variant_type_info_table = NULL;
879             }
880           g_rec_mutex_unlock (&amp;g_variant_type_info_lock);
881 
882           g_free (container-&gt;type_string);
883 
884           if (info-&gt;container_class == GV_ARRAY_INFO_CLASS)
885             array_info_free (info);
886 
887           else if (info-&gt;container_class == GV_TUPLE_INFO_CLASS)
888             tuple_info_free (info);
889 
890           else
891             g_assert_not_reached ();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2008 Ryan Lortie</span>
<span class="line-modified">  3  * Copyright (C) 2010 Codethink Limited</span>
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Lesser General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2.1 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Lesser General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Lesser General Public
 16  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 17  *
 18  * Author: Ryan Lortie &lt;desrt@desrt.ca&gt;
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 
 23 #include &quot;gvarianttypeinfo.h&quot;
 24 
 25 #include &lt;glib/gtestutils.h&gt;
 26 #include &lt;glib/gthread.h&gt;
 27 #include &lt;glib/gslice.h&gt;
 28 #include &lt;glib/ghash.h&gt;
<span class="line-added"> 29 #include &lt;glib/grefcount.h&gt;</span>
 30 
 31 /* &lt; private &gt;
 32  * GVariantTypeInfo:
 33  *
 34  * This structure contains the necessary information to facilitate the
 35  * serialisation and fast deserialisation of a given type of GVariant
 36  * value.  A GVariant instance holds a pointer to one of these
 37  * structures to provide for efficient operation.
 38  *
 39  * The GVariantTypeInfo structures for all of the base types, plus the
 40  * &quot;variant&quot; type are stored in a read-only static array.
 41  *
 42  * For container types, a hash table and reference counting is used to
 43  * ensure that only one of these structures exists for any given type.
 44  * In general, a container GVariantTypeInfo will exist for a given type
 45  * only if one or more GVariant instances of that type exist or if
 46  * another GVariantTypeInfo has that type as a subtype.  For example, if
 47  * a process contains a single GVariant instance with type &quot;(asv)&quot;, then
 48  * container GVariantTypeInfo structures will exist for &quot;(asv)&quot; and
 49  * for &quot;as&quot; (note that &quot;s&quot; and &quot;v&quot; always exist in the static array).
</pre>
<hr />
<pre>
 60  * 0 otherwise (since no type has a fixed size of 0).
 61  *
 62  * &#39;alignment&#39; is set to one less than the alignment requirement for
 63  * this type.  This makes many operations much more convenient.
 64  */
 65 struct _GVariantTypeInfo
 66 {
 67   gsize fixed_size;
 68   guchar alignment;
 69   guchar container_class;
 70 };
 71 
 72 /* Container types are reference counted.  They also need to have their
 73  * type string stored explicitly since it is not merely a single letter.
 74  */
 75 typedef struct
 76 {
 77   GVariantTypeInfo info;
 78 
 79   gchar *type_string;
<span class="line-modified"> 80   gatomicrefcount ref_count;</span>
 81 } ContainerInfo;
 82 
 83 /* For &#39;array&#39; and &#39;maybe&#39; types, we store some extra information on the
 84  * end of the GVariantTypeInfo struct -- the element type (ie: &quot;s&quot; for
 85  * &quot;as&quot;).  The container GVariantTypeInfo structure holds a reference to
 86  * the element typeinfo.
 87  */
 88 typedef struct
 89 {
 90   ContainerInfo container;
 91 
 92   GVariantTypeInfo *element;
 93 } ArrayInfo;
 94 
 95 /* For &#39;tuple&#39; and &#39;dict entry&#39; types, we store extra information for
 96  * each member -- its type and how to find it inside the serialised data
 97  * in O(1) time using 4 variables -- &#39;i&#39;, &#39;a&#39;, &#39;b&#39;, and &#39;c&#39;.  See the
 98  * comment on GVariantMemberInfo in gvarianttypeinfo.h.
 99  */
100 typedef struct
101 {
102   ContainerInfo container;
103 
104   GVariantMemberInfo *members;
105   gsize n_members;
106 } TupleInfo;
107 
108 
109 /* Hard-code the base types in a constant array */
110 static const GVariantTypeInfo g_variant_type_info_basic_table[24] = {
<span class="line-modified">111 #define fixed_aligned(x)  x, x - 1, 0</span>
<span class="line-modified">112 #define not_a_type        0,     0, 0</span>
<span class="line-modified">113 #define unaligned         0,     0, 0</span>
<span class="line-modified">114 #define aligned(x)        0, x - 1, 0</span>
115   /* &#39;b&#39; */ { fixed_aligned(1) },   /* boolean */
116   /* &#39;c&#39; */ { not_a_type },
117   /* &#39;d&#39; */ { fixed_aligned(8) },   /* double */
118   /* &#39;e&#39; */ { not_a_type },
119   /* &#39;f&#39; */ { not_a_type },
120   /* &#39;g&#39; */ { unaligned        },   /* signature string */
121   /* &#39;h&#39; */ { fixed_aligned(4) },   /* file handle (int32) */
122   /* &#39;i&#39; */ { fixed_aligned(4) },   /* int32 */
123   /* &#39;j&#39; */ { not_a_type },
124   /* &#39;k&#39; */ { not_a_type },
125   /* &#39;l&#39; */ { not_a_type },
126   /* &#39;m&#39; */ { not_a_type },
127   /* &#39;n&#39; */ { fixed_aligned(2) },   /* int16 */
128   /* &#39;o&#39; */ { unaligned        },   /* object path string */
129   /* &#39;p&#39; */ { not_a_type },
130   /* &#39;q&#39; */ { fixed_aligned(2) },   /* uint16 */
131   /* &#39;r&#39; */ { not_a_type },
132   /* &#39;s&#39; */ { unaligned        },   /* string */
133   /* &#39;t&#39; */ { fixed_aligned(8) },   /* uint64 */
134   /* &#39;u&#39; */ { fixed_aligned(4) },   /* uint32 */
</pre>
<hr />
<pre>
140 #undef not_a_type
141 #undef unaligned
142 #undef aligned
143 };
144 
145 /* We need to have type strings to return for the base types.  We store
146  * those in another array.  Since all base type strings are single
147  * characters this is easy.  By not storing pointers to strings into the
148  * GVariantTypeInfo itself, we save a bunch of relocations.
149  */
150 static const char g_variant_type_info_basic_chars[24][2] = {
151   &quot;b&quot;, &quot; &quot;, &quot;d&quot;, &quot; &quot;, &quot; &quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;,
152   &quot;n&quot;, &quot;o&quot;, &quot; &quot;, &quot;q&quot;, &quot; &quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot; &quot;, &quot;x&quot;, &quot;y&quot;
153 };
154 
155 /* sanity checks to make debugging easier */
156 static void
157 g_variant_type_info_check (const GVariantTypeInfo *info,
158                            char                    container_class)
159 {
<span class="line-added">160 #ifndef G_DISABLE_ASSERT</span>
161   g_assert (!container_class || info-&gt;container_class == container_class);
162 
163   /* alignment can only be one of these */
164   g_assert (info-&gt;alignment == 0 || info-&gt;alignment == 1 ||
165             info-&gt;alignment == 3 || info-&gt;alignment == 7);
166 
167   if (info-&gt;container_class)
168     {
169       ContainerInfo *container = (ContainerInfo *) info;
170 
171       /* extra checks for containers */
<span class="line-modified">172       g_assert (!g_atomic_ref_count_compare (&amp;container-&gt;ref_count, 0));</span>
173       g_assert (container-&gt;type_string != NULL);
174     }
175   else
176     {
177       gint index;
178 
179       /* if not a container, then ensure that it is a valid member of
180        * the basic types table
181        */
182       index = info - g_variant_type_info_basic_table;
183 
184       g_assert (G_N_ELEMENTS (g_variant_type_info_basic_table) == 24);
185       g_assert (G_N_ELEMENTS (g_variant_type_info_basic_chars) == 24);
186       g_assert (0 &lt;= index &amp;&amp; index &lt; 24);
187       g_assert (g_variant_type_info_basic_chars[index][0] != &#39; &#39;);
188     }
<span class="line-added">189 #endif  /* !G_DISABLE_ASSERT */</span>
190 }
191 
192 /* &lt; private &gt;
193  * g_variant_type_info_get_type_string:
194  * @info: a #GVariantTypeInfo
195  *
196  * Gets the type string for @info.  The string is nul-terminated.
197  */
198 const gchar *
199 g_variant_type_info_get_type_string (GVariantTypeInfo *info)
200 {
201   g_variant_type_info_check (info, 0);
202 
203   if (info-&gt;container_class)
204     {
205       ContainerInfo *container = (ContainerInfo *) info;
206 
207       /* containers have their type string stored inside them */
208       return container-&gt;type_string;
209     }
210   else
211     {
212       gint index;
213 
214       /* look up the type string in the base type array.  the call to
215        * g_variant_type_info_check() above already ensured validity.
216        */
217       index = info - g_variant_type_info_basic_table;
218 
219       return g_variant_type_info_basic_chars[index];
220     }
221 }
222 
223 /* &lt; private &gt;
224  * g_variant_type_info_query:
225  * @info: a #GVariantTypeInfo
<span class="line-modified">226  * @alignment: (out) (optional): the location to store the alignment, or %NULL</span>
<span class="line-modified">227  * @fixed_size: (out) (optional): the location to store the fixed size, or %NULL</span>
228  *
229  * Queries @info to determine the alignment requirements and fixed size
230  * (if any) of the type.
231  *
232  * @fixed_size, if non-%NULL is set to the fixed size of the type, or 0
233  * to indicate that the type is a variable-sized type.  No type has a
234  * fixed size of 0.
235  *
236  * @alignment, if non-%NULL, is set to one less than the required
237  * alignment of the type.  For example, for a 32bit integer, @alignment
238  * would be set to 3.  This allows you to round an integer up to the
239  * proper alignment by performing the following efficient calculation:
240  *
241  *   offset += ((-offset) &amp; alignment);
242  */
243 void
244 g_variant_type_info_query (GVariantTypeInfo *info,
245                            guint            *alignment,
246                            gsize            *fixed_size)
247 {
248   g_variant_type_info_check (info, 0);
249 
250   if (alignment)
251     *alignment = info-&gt;alignment;
252 
253   if (fixed_size)
254     *fixed_size = info-&gt;fixed_size;
255 }
256 
257 /* &lt; private &gt;
258  * g_variant_type_info_query_depth:
259  * @info: a #GVariantTypeInfo
260  *
261  * Queries @info to determine the depth of the type.
262  *
263  * See g_variant_type_string_get_depth_() for more details.
264  *
265  * Returns: depth of @info
<span class="line-modified">266  * Since: 2.60</span>
267  */
268 gsize
269 g_variant_type_info_query_depth (GVariantTypeInfo *info)
270 {
271   g_variant_type_info_check (info, 0);
272 
273   if (info-&gt;container_class)
274     {
275       ContainerInfo *container = (ContainerInfo *) info;
276       return g_variant_type_string_get_depth_ (container-&gt;type_string);
277     }
278 
279   return 1;
280 }
281 
282 /* == array == */
283 #define GV_ARRAY_INFO_CLASS &#39;a&#39;
284 static ArrayInfo *
285 GV_ARRAY_INFO (GVariantTypeInfo *info)
286 {
</pre>
<hr />
<pre>
320 
321   return (ContainerInfo *) info;
322 }
323 
324 /* &lt; private &gt;
325  * g_variant_type_info_element:
326  * @info: a #GVariantTypeInfo for an array or maybe type
327  *
328  * Returns the element type for the array or maybe type.  A reference is
329  * not added, so the caller must add their own.
330  */
331 GVariantTypeInfo *
332 g_variant_type_info_element (GVariantTypeInfo *info)
333 {
334   return GV_ARRAY_INFO (info)-&gt;element;
335 }
336 
337 /* &lt; private &gt;
338  * g_variant_type_query_element:
339  * @info: a #GVariantTypeInfo for an array or maybe type
<span class="line-modified">340  * @alignment: (out) (optional): the location to store the alignment, or %NULL</span>
<span class="line-modified">341  * @fixed_size: (out) (optional): the location to store the fixed size, or %NULL</span>
342  *
343  * Returns the alignment requires and fixed size (if any) for the
344  * element type of the array.  This call is a convenience wrapper around
345  * g_variant_type_info_element() and g_variant_type_info_query().
346  */
347 void
348 g_variant_type_info_query_element (GVariantTypeInfo *info,
349                                    guint            *alignment,
350                                    gsize            *fixed_size)
351 {
352   g_variant_type_info_query (GV_ARRAY_INFO (info)-&gt;element,
353                              alignment, fixed_size);
354 }
355 
356 /* == tuple == */
357 #define GV_TUPLE_INFO_CLASS &#39;r&#39;
358 static TupleInfo *
359 GV_TUPLE_INFO (GVariantTypeInfo *info)
360 {
361   g_variant_type_info_check (info, GV_TUPLE_INFO_CLASS);
362 
363   return (TupleInfo *) info;
364 }
365 
366 static void
367 tuple_info_free (GVariantTypeInfo *info)
368 {
369   TupleInfo *tuple_info;
<span class="line-modified">370   gsize i;</span>
371 
372   g_assert (info-&gt;container_class == GV_TUPLE_INFO_CLASS);
373   tuple_info = (TupleInfo *) info;
374 
375   for (i = 0; i &lt; tuple_info-&gt;n_members; i++)
376     g_variant_type_info_unref (tuple_info-&gt;members[i].type_info);
377 
378   g_slice_free1 (sizeof (GVariantMemberInfo) * tuple_info-&gt;n_members,
379                  tuple_info-&gt;members);
380   g_slice_free (TupleInfo, tuple_info);
381 }
382 
383 static void
384 tuple_allocate_members (const GVariantType  *type,
385                         GVariantMemberInfo **members,
386                         gsize               *n_members)
387 {
388   const GVariantType *item_type;
389   gsize i = 0;
390 
</pre>
<hr />
<pre>
534    */
535 
536   item-&gt;i = i;
537   item-&gt;a = a + b;
538   item-&gt;b = ~b;
539   item-&gt;c = c;
540 }
541 
542 static gsize
543 tuple_align (gsize offset,
544              guint alignment)
545 {
546   return offset + ((-offset) &amp; alignment);
547 }
548 
549 /* This function is the heart of the algorithm for calculating &#39;i&#39;, &#39;a&#39;,
550  * &#39;b&#39; and &#39;c&#39; for each item in the tuple.
551  *
552  * Imagine we want to find the start of the &quot;i&quot; in the type &quot;(su(qx)ni)&quot;.
553  * That&#39;s a string followed by a uint32, then a tuple containing a
<span class="line-modified">554  * uint16 and an int64, then an int16, then our &quot;i&quot;.  In order to get to</span>
555  * our &quot;i&quot; we:
556  *
557  * Start at the end of the string, align to 4 (for the uint32), add 4.
558  * Align to 8, add 16 (for the tuple).  Align to 2, add 2 (for the
559  * int16).  Then we&#39;re there.  It turns out that, given 3 simple rules,
560  * we can flatten this iteration into one addition, one alignment, then
561  * one more addition.
562  *
563  * The loop below plays through each item in the tuple, querying its
564  * alignment and fixed_size into &#39;d&#39; and &#39;e&#39;, respectively.  At all
565  * times the variables &#39;a&#39;, &#39;b&#39;, and &#39;c&#39; are maintained such that in
566  * order to get to the current point, you add &#39;a&#39;, align to &#39;b&#39; then add
567  * &#39;c&#39;.  &#39;b&#39; is kept in &quot;one less than&quot; form.  For each item, the proper
568  * alignment is applied to find the values of &#39;a&#39;, &#39;b&#39; and &#39;c&#39; to get to
569  * the start of that item.  Those values are recorded into the table.
570  * The fixed size of the item (if applicable) is then added on.
571  *
572  * These 3 rules are how &#39;a&#39;, &#39;b&#39; and &#39;c&#39; are modified for alignment and
573  * addition of fixed size.  They have been proven correct but are
574  * presented here, without proof:
</pre>
<hr />
<pre>
628   if (info-&gt;n_members &gt; 0)
629     {
630       GVariantMemberInfo *m;
631 
632       /* the alignment requirement of the tuple is the alignment
633        * requirement of its largest item.
634        */
635       base-&gt;alignment = 0;
636       for (m = info-&gt;members; m &lt; &amp;info-&gt;members[info-&gt;n_members]; m++)
637         /* can find the max of a list of &quot;one less than&quot; powers of two
638          * by &#39;or&#39;ing them
639          */
640         base-&gt;alignment |= m-&gt;type_info-&gt;alignment;
641 
642       m--; /* take &#39;m&#39; back to the last item */
643 
644       /* the structure only has a fixed size if no variable-size
645        * offsets are stored and the last item is fixed-sized too (since
646        * an offset is never stored for the last item).
647        */
<span class="line-modified">648       if (m-&gt;i == (gsize) -1 &amp;&amp; m-&gt;type_info-&gt;fixed_size)</span>
649         /* in that case, the fixed size can be found by finding the
650          * start of the last item (in the usual way) and adding its
651          * fixed size.
652          *
653          * if a tuple has a fixed size then it is always a multiple of
654          * the alignment requirement (to make packing into arrays
655          * easier) so we round up to that here.
656          */
657         base-&gt;fixed_size =
658           tuple_align (((m-&gt;a &amp; m-&gt;b) | m-&gt;c) + m-&gt;type_info-&gt;fixed_size,
659                        base-&gt;alignment);
660       else
661         /* else, the tuple is not fixed size */
662         base-&gt;fixed_size = 0;
663     }
664   else
665     {
666       /* the empty tuple: &#39;()&#39;.
667        *
<span class="line-modified">668        * has a size of 1 and a no alignment requirement.</span>
669        *
670        * It has a size of 1 (not 0) for two practical reasons:
671        *
672        *  1) So we can determine how many of them are in an array
673        *     without dividing by zero or without other tricks.
674        *
675        *  2) Even if we had some trick to know the number of items in
676        *     the array (as GVariant did at one time) this would open a
677        *     potential denial of service attack: an attacker could send
678        *     you an extremely small array (in terms of number of bytes)
679        *     containing trillions of zero-sized items.  If you iterated
680        *     over this array you would effectively infinite-loop your
681        *     program.  By forcing a size of at least one, we bound the
682        *     amount of computation done in response to a message to a
683        *     reasonable function of the size of that message.
684        */
685       base-&gt;alignment = 0;
686       base-&gt;fixed_size = 1;
687     }
688 }
</pre>
<hr />
<pre>
784         g_variant_type_info_table = g_hash_table_new (g_str_hash,
785                                                       g_str_equal);
786       info = g_hash_table_lookup (g_variant_type_info_table, type_string);
787 
788       if (info == NULL)
789         {
790           ContainerInfo *container;
791 
792           if (type_char == G_VARIANT_TYPE_INFO_CHAR_MAYBE ||
793               type_char == G_VARIANT_TYPE_INFO_CHAR_ARRAY)
794             {
795               container = array_info_new (type);
796             }
797           else /* tuple or dict entry */
798             {
799               container = tuple_info_new (type);
800             }
801 
802           info = (GVariantTypeInfo *) container;
803           container-&gt;type_string = type_string;
<span class="line-modified">804           g_atomic_ref_count_init (&amp;container-&gt;ref_count);</span>
805 
806           g_hash_table_insert (g_variant_type_info_table, type_string, info);
807           type_string = NULL;
808         }
809       else
810         g_variant_type_info_ref (info);
811 
812       g_rec_mutex_unlock (&amp;g_variant_type_info_lock);
813       g_variant_type_info_check (info, 0);
814       g_free (type_string);
815 
816       return info;
817     }
818   else
819     {
820       const GVariantTypeInfo *info;
821       int index;
822 
823       index = type_char - &#39;b&#39;;
824       g_assert (G_N_ELEMENTS (g_variant_type_info_basic_table) == 24);
</pre>
<hr />
<pre>
830 
831       return (GVariantTypeInfo *) info;
832     }
833 }
834 
835 /* &lt; private &gt;
836  * g_variant_type_info_ref:
837  * @info: a #GVariantTypeInfo
838  *
839  * Adds a reference to @info.
840  */
841 GVariantTypeInfo *
842 g_variant_type_info_ref (GVariantTypeInfo *info)
843 {
844   g_variant_type_info_check (info, 0);
845 
846   if (info-&gt;container_class)
847     {
848       ContainerInfo *container = (ContainerInfo *) info;
849 
<span class="line-modified">850       g_atomic_ref_count_inc (&amp;container-&gt;ref_count);</span>

851     }
852 
853   return info;
854 }
855 
856 /* &lt; private &gt;
857  * g_variant_type_info_unref:
858  * @info: a #GVariantTypeInfo
859  *
860  * Releases a reference held on @info.  This may result in @info being
861  * freed.
862  */
863 void
864 g_variant_type_info_unref (GVariantTypeInfo *info)
865 {
866   g_variant_type_info_check (info, 0);
867 
868   if (info-&gt;container_class)
869     {
870       ContainerInfo *container = (ContainerInfo *) info;
871 
872       g_rec_mutex_lock (&amp;g_variant_type_info_lock);
<span class="line-modified">873       if (g_atomic_ref_count_dec (&amp;container-&gt;ref_count))</span>
874         {
875           g_hash_table_remove (g_variant_type_info_table,
876                                container-&gt;type_string);
877           if (g_hash_table_size (g_variant_type_info_table) == 0)
878             {
879               g_hash_table_unref (g_variant_type_info_table);
880               g_variant_type_info_table = NULL;
881             }
882           g_rec_mutex_unlock (&amp;g_variant_type_info_lock);
883 
884           g_free (container-&gt;type_string);
885 
886           if (info-&gt;container_class == GV_ARRAY_INFO_CLASS)
887             array_info_free (info);
888 
889           else if (info-&gt;container_class == GV_TUPLE_INFO_CLASS)
890             tuple_info_free (info);
891 
892           else
893             g_assert_not_reached ();
</pre>
</td>
</tr>
</table>
<center><a href="gvarianttype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gvarianttypeinfo.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>