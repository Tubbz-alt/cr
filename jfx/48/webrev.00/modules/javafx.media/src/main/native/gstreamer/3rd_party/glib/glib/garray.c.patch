diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/garray.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/garray.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/garray.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/garray.c
@@ -321,19 +321,19 @@
  * g_array_free:
  * @array: a #GArray
  * @free_segment: if %TRUE the actual element data is freed as well
  *
  * Frees the memory allocated for the #GArray. If @free_segment is
- * %TRUE it frees the memory block holding the elements as well and
- * also each element if @array has a @element_free_func set. Pass
+ * %TRUE it frees the memory block holding the elements as well. Pass
  * %FALSE if you want to free the #GArray wrapper but preserve the
- * underlying array for use elsewhere. If the reference count of @array
- * is greater than one, the #GArray wrapper is preserved but the size
- * of @array will be set to zero.
+ * underlying array for use elsewhere. If the reference count of
+ * @array is greater than one, the #GArray wrapper is preserved but
+ * the size of  @array will be set to zero.
  *
- * If array elements contain dynamically-allocated memory, they should
- * be freed separately.
+ * If array contents point to dynamically-allocated memory, they should
+ * be freed separately if @free_seg is %TRUE and no @clear_func
+ * function has been set for @array.
  *
  * This function is not thread-safe. If using a #GArray from multiple
  * threads, use only the atomic g_array_ref() and g_array_unref()
  * functions.
  *
@@ -510,11 +510,11 @@
  * @data: (nullable): a pointer to the elements to insert
  * @len: the number of elements to insert
  *
  * Inserts @len elements into a #GArray at the given index.
  *
- * If @index_ is greater than the arrayâ€™s current length, the array is expanded.
+ * If @index_ is greater than the array's current length, the array is expanded.
  * The elements between the old end of the array and the newly inserted elements
  * will be initialised to zero if the array was configured to clear elements;
  * otherwise their values will be undefined.
  *
  * @data may be %NULL if (and only if) @len is zero. If @len is zero, this
@@ -788,22 +788,113 @@
                      array->elt_size,
                      compare_func,
                      user_data);
 }
 
+/**
+ * g_array_binary_search:
+ * @array: a #GArray.
+ * @target: a pointer to the item to look up.
+ * @compare_func: A #GCompareFunc used to locate @target.
+ * @out_match_index: (optional) (out caller-allocates): return location
+ *    for the index of the element, if found.
+ *
+ * Checks whether @target exists in @array by performing a binary
+ * search based on the given comparison function @compare_func which
+ * get pointers to items as arguments. If the element is found, %TRUE
+ * is returned and the element's index is returned in @out_match_index
+ * (if non-%NULL). Otherwise, %FALSE is returned and @out_match_index
+ * is undefined. If @target exists multiple times in @array, the index
+ * of the first instance is returned. This search is using a binary
+ * search, so the @array must absolutely be sorted to return a correct
+ * result (if not, the function may produce false-negative).
+ *
+ * This example defines a comparison function and search an element in a #GArray:
+ * |[<!-- language="C" -->
+ * static gint*
+ * cmpint (gconstpointer a, gconstpointer b)
+ * {
+ *   const gint *_a = a;
+ *   const gint *_b = b;
+ *
+ *   return *_a - *_b;
+ * }
+ * ...
+ * gint i = 424242;
+ * guint matched_index;
+ * gboolean result = g_array_binary_search (garray, &i, cmpint, &matched_index);
+ * ...
+ * ]|
+ *
+ * Returns: %TRUE if @target is one of the elements of @array, %FALSE otherwise.
+ *
+ * Since: 2.62
+ */
+gboolean
+g_array_binary_search (GArray        *array,
+                       gconstpointer  target,
+                       GCompareFunc   compare_func,
+                       guint         *out_match_index)
+{
+  gboolean result = FALSE;
+  GRealArray *_array = (GRealArray *) array;
+  guint left, middle, right;
+  gint val;
+
+  g_return_val_if_fail (_array != NULL, FALSE);
+  g_return_val_if_fail (compare_func != NULL, FALSE);
+
+  if (G_LIKELY(_array->len))
+    {
+      left = 0;
+      right = _array->len - 1;
+
+      while (left <= right)
+        {
+          middle = left + (right - left) / 2;
+
+          val = compare_func (_array->data + (_array->elt_size * middle), target);
+          if (val == 0)
+            {
+              result = TRUE;
+              break;
+            }
+          else if (val < 0)
+            left = middle + 1;
+          else if (/* val > 0 && */ middle > 0)
+            right = middle - 1;
+          else
+            break;  /* element not found */
+        }
+    }
+
+  if (result && out_match_index != NULL)
+    *out_match_index = middle;
+
+  return result;
+}
+
 /* Returns the smallest power of 2 greater than n, or n if
  * such power does not fit in a guint
  */
 static guint
 g_nearest_pow (guint num)
 {
-  guint n = 1;
+  guint n = num - 1;
+
+  g_assert (num > 0);
 
-  while (n < num && n > 0)
-    n <<= 1;
+  n |= n >> 1;
+  n |= n >> 2;
+  n |= n >> 4;
+  n |= n >> 8;
+  n |= n >> 16;
+#if SIZEOF_INT == 8
+  n |= n >> 32;
+#endif
 
-  return n ? n : num;
+  return n + 1;
 }
 
 static void
 g_array_maybe_expand (GRealArray *array,
                       guint       len)
@@ -813,11 +904,11 @@
   /* Detect potential overflow */
   if G_UNLIKELY ((G_MAXUINT - array->len) < len)
     g_error ("adding %u to array would overflow", len);
 
   want_alloc = g_array_elt_len (array, array->len + len +
-                                      array->zero_terminated);
+                                array->zero_terminated);
 
   if (want_alloc > array->alloc)
     {
       want_alloc = g_nearest_pow (want_alloc);
       want_alloc = MAX (want_alloc, MIN_ARRAY_SIZE);
@@ -910,11 +1001,11 @@
  *
  * Returns: the pointer at the given index
  */
 
 static void g_ptr_array_maybe_expand (GRealPtrArray *array,
-                                      gint           len);
+                                      guint          len);
 
 /**
  * g_ptr_array_new:
  *
  * Creates a new #GPtrArray with a reference count of 1.
@@ -925,10 +1016,63 @@
 g_ptr_array_new (void)
 {
   return g_ptr_array_sized_new (0);
 }
 
+/**
+ * g_ptr_array_copy:
+ * @array: #GPtrArray to duplicate
+ * @func: (nullable): a copy function used to copy every element in the array
+ * @user_data: user data passed to the copy function @func, or %NULL
+ *
+ * Makes a full (deep) copy of a #GPtrArray.
+ *
+ * @func, as a #GCopyFunc, takes two arguments, the data to be copied
+ * and a @user_data pointer. On common processor architectures, it's safe to
+ * pass %NULL as @user_data if the copy function takes only one argument. You
+ * may get compiler warnings from this though if compiling with GCC's
+ * `-Wcast-function-type` warning.
+ *
+ * If @func is %NULL, then only the pointers (and not what they are
+ * pointing to) are copied to the new #GPtrArray.
+ *
+ * The copy of @array will have the same #GDestroyNotify for its elements as
+ * @array.
+ *
+ * Returns: (transfer full): a deep copy of the initial #GPtrArray.
+ *
+ * Since: 2.62
+ **/
+GPtrArray *
+g_ptr_array_copy (GPtrArray *array,
+                  GCopyFunc  func,
+                  gpointer   user_data)
+{
+  gsize i;
+  GPtrArray *new_array;
+
+  g_return_val_if_fail (array != NULL, NULL);
+
+  new_array = g_ptr_array_sized_new (array->len);
+  g_ptr_array_set_free_func (new_array, ((GRealPtrArray *) array)->element_free_func);
+
+  if (func != NULL)
+    {
+      for (i = 0; i < array->len; i++)
+        new_array->pdata[i] = func (array->pdata[i], user_data);
+    }
+  else
+    {
+      memcpy (new_array->pdata, array->pdata,
+              array->len * sizeof (*array->pdata));
+    }
+
+  new_array->len = array->len;
+
+  return new_array;
+}
+
 /**
  * g_ptr_array_sized_new:
  * @reserved_size: number of pointers preallocated
  *
  * Creates a new #GPtrArray with @reserved_size pointers preallocated
@@ -961,10 +1105,38 @@
     g_ptr_array_maybe_expand (array, reserved_size);
 
   return (GPtrArray*) array;
 }
 
+/**
+ * g_array_copy:
+ * @array: A #GArray.
+ *
+ * Create a shallow copy of a #GArray. If the array elements consist of
+ * pointers to data, the pointers are copied but the actual data is not.
+ *
+ * Returns: (transfer container): A copy of @array.
+ *
+ * Since: 2.62
+ **/
+GArray *
+g_array_copy (GArray *array)
+{
+  GRealArray *rarray = (GRealArray *) array;
+  GRealArray *new_rarray;
+
+  g_return_val_if_fail (rarray != NULL, NULL);
+
+  new_rarray =
+    (GRealArray *) g_array_sized_new (rarray->zero_terminated, rarray->clear,
+                                      rarray->elt_size, rarray->len);
+  new_rarray->len = rarray->len;
+  memcpy (new_rarray->data, rarray->data, rarray->alloc);
+
+  return (GArray *) new_rarray;
+}
+
 /**
  * g_ptr_array_new_with_free_func:
  * @element_free_func: (nullable): A function to free elements with
  *     destroy @array or %NULL
  *
@@ -1178,11 +1350,11 @@
   return segment;
 }
 
 static void
 g_ptr_array_maybe_expand (GRealPtrArray *array,
-                          gint           len)
+                          guint          len)
 {
   /* Detect potential overflow */
   if G_UNLIKELY ((G_MAXUINT - array->len) < len)
     g_error ("adding %u to array would overflow", len);
 
@@ -1504,10 +1676,93 @@
   g_ptr_array_maybe_expand (rarray, 1);
 
   rarray->pdata[rarray->len++] = data;
 }
 
+/**
+ * g_ptr_array_extend:
+ * @array_to_extend: a #GPtrArray.
+ * @array: (transfer none): a #GPtrArray to add to the end of @array_to_extend.
+ * @func: (nullable): a copy function used to copy every element in the array
+ * @user_data: user data passed to the copy function @func, or %NULL
+ *
+ * Adds all pointers of @array to the end of the array @array_to_extend.
+ * The array will grow in size automatically if needed. @array_to_extend is
+ * modified in-place.
+ *
+ * @func, as a #GCopyFunc, takes two arguments, the data to be copied
+ * and a @user_data pointer. On common processor architectures, it's safe to
+ * pass %NULL as @user_data if the copy function takes only one argument. You
+ * may get compiler warnings from this though if compiling with GCC's
+ * `-Wcast-function-type` warning.
+ *
+ * If @func is %NULL, then only the pointers (and not what they are
+ * pointing to) are copied to the new #GPtrArray.
+ *
+ * Since: 2.62
+ **/
+void
+g_ptr_array_extend (GPtrArray  *array_to_extend,
+                    GPtrArray  *array,
+                    GCopyFunc   func,
+                    gpointer    user_data)
+{
+  GRealPtrArray *rarray_to_extend = (GRealPtrArray *) array_to_extend;
+  gsize i;
+
+  g_return_if_fail (array_to_extend != NULL);
+  g_return_if_fail (array != NULL);
+
+  g_ptr_array_maybe_expand (rarray_to_extend, array->len);
+
+  if (func != NULL)
+    {
+      for (i = 0; i < array->len; i++)
+        rarray_to_extend->pdata[i + rarray_to_extend->len] =
+          func (array->pdata[i], user_data);
+    }
+  else
+    {
+      memcpy (rarray_to_extend->pdata + rarray_to_extend->len, array->pdata,
+              array->len * sizeof (*array->pdata));
+    }
+
+  rarray_to_extend->len += array->len;
+}
+
+/**
+ * g_ptr_array_extend_and_steal:
+ * @array_to_extend: (transfer none): a #GPtrArray.
+ * @array: (transfer container): a #GPtrArray to add to the end of
+ *     @array_to_extend.
+ *
+ * Adds all the pointers in @array to the end of @array_to_extend, transferring
+ * ownership of each element from @array to @array_to_extend and modifying
+ * @array_to_extend in-place. @array is then freed.
+ *
+ * As with g_ptr_array_free(), @array will be destroyed if its reference count
+ * is 1. If its reference count is higher, it will be decremented and the
+ * length of @array set to zero.
+ *
+ * Since: 2.62
+ **/
+void
+g_ptr_array_extend_and_steal (GPtrArray  *array_to_extend,
+                              GPtrArray  *array)
+{
+  gpointer *pdata;
+
+  g_ptr_array_extend (array_to_extend, array, NULL, NULL);
+
+  /* Get rid of @array without triggering the GDestroyNotify attached
+   * to the elements moved from @array to @array_to_extend. */
+  pdata = g_steal_pointer (&array->pdata);
+  array->len = 0;
+  g_ptr_array_unref (array);
+  g_free (pdata);
+}
+
 /**
  * g_ptr_array_insert:
  * @array: a #GPtrArray
  * @index_: the index to place the new element at, or -1 to append
  * @data: the pointer to add.
@@ -1531,11 +1786,11 @@
   g_ptr_array_maybe_expand (rarray, 1);
 
   if (index_ < 0)
     index_ = rarray->len;
 
-  if (index_ < rarray->len)
+  if ((guint) index_ < rarray->len)
     memmove (&(rarray->pdata[index_ + 1]),
              &(rarray->pdata[index_]),
              (rarray->len - index_) * sizeof (gpointer));
 
   rarray->len++;
