<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gpattern.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="goption.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gpattern.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gpattern.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 63   G_MATCH_ALL_TAIL,  /* &quot;*A?AA&quot; */
 64   G_MATCH_HEAD,      /* &quot;AAAA*&quot; */
 65   G_MATCH_TAIL,      /* &quot;*AAAA&quot; */
 66   G_MATCH_EXACT,     /* &quot;AAAAA&quot; */
 67   G_MATCH_LAST
 68 } GMatchType;
 69 
 70 struct _GPatternSpec
 71 {
 72   GMatchType match_type;
 73   guint      pattern_length;
 74   guint      min_length;
 75   guint      max_length;
 76   gchar     *pattern;
 77 };
 78 
 79 
 80 /* --- functions --- */
 81 static inline gboolean
 82 g_pattern_ph_match (const gchar *match_pattern,
<span class="line-modified"> 83             const gchar *match_string,</span>
<span class="line-modified"> 84             gboolean    *wildcard_reached_p)</span>
 85 {
 86   const gchar *pattern, *string;
 87   gchar ch;
 88 
 89   pattern = match_pattern;
 90   string = match_string;
 91 
 92   ch = *pattern;
 93   pattern++;
 94   while (ch)
 95     {
 96       switch (ch)














 97     {
<span class="line-removed"> 98     case &#39;?&#39;:</span>
 99       if (!*string)
100         return FALSE;
101       string = g_utf8_next_char (string);
<span class="line-modified">102       break;</span>
<span class="line-modified">103 </span>
<span class="line-modified">104     case &#39;*&#39;:</span>
<span class="line-modified">105       *wildcard_reached_p = TRUE;</span>
<span class="line-modified">106       do</span>
<span class="line-modified">107         {</span>
<span class="line-modified">108           ch = *pattern;</span>
<span class="line-removed">109           pattern++;</span>
<span class="line-removed">110           if (ch == &#39;?&#39;)</span>
<span class="line-removed">111         {</span>
<span class="line-removed">112           if (!*string)</span>
<span class="line-removed">113             return FALSE;</span>
<span class="line-removed">114           string = g_utf8_next_char (string);</span>
<span class="line-removed">115         }</span>
<span class="line-removed">116         }</span>
<span class="line-removed">117       while (ch == &#39;*&#39; || ch == &#39;?&#39;);</span>
<span class="line-removed">118       if (!ch)</span>
<span class="line-removed">119         return TRUE;</span>
<span class="line-removed">120       do</span>
<span class="line-removed">121         {</span>
122               gboolean next_wildcard_reached = FALSE;
<span class="line-modified">123           while (ch != *string)</span>
<span class="line-modified">124         {</span>
<span class="line-modified">125           if (!*string)</span>
<span class="line-modified">126             return FALSE;</span>
<span class="line-modified">127           string = g_utf8_next_char (string);</span>
<span class="line-modified">128         }</span>
<span class="line-modified">129           string++;</span>
<span class="line-modified">130           if (g_pattern_ph_match (pattern, string, &amp;next_wildcard_reached))</span>
<span class="line-modified">131         return TRUE;</span>
132               if (next_wildcard_reached)
133                 /* the forthcoming pattern substring up to the next wildcard has
134                  * been matched, but a mismatch occoured for the rest of the
135                  * pattern, following the next wildcard.
136                  * there&#39;s no need to advance the current match position any
137                  * further if the rest pattern will not match.
138                  */
<span class="line-modified">139         return FALSE;</span>
<span class="line-modified">140         }</span>
<span class="line-modified">141       while (*string);</span>
<span class="line-modified">142       break;</span>
143 
<span class="line-modified">144     default:</span>
<span class="line-modified">145       if (ch == *string)</span>
<span class="line-modified">146         string++;</span>
<span class="line-modified">147       else</span>
<span class="line-modified">148         return FALSE;</span>
<span class="line-modified">149       break;</span>
<span class="line-modified">150     }</span>
151 
152       ch = *pattern;
153       pattern++;
154     }
155 
156   return *string == 0;
157 }
158 
159 /**
160  * g_pattern_match:
161  * @pspec: a #GPatternSpec
162  * @string_length: the length of @string (in bytes, i.e. strlen(),
163  *     not g_utf8_strlen())
164  * @string: the UTF-8 encoded string to match
165  * @string_reversed: (nullable): the reverse of @string or %NULL
166  *
167  * Matches a string against a compiled pattern. Passing the correct
168  * length of the string given is mandatory. The reversed string can be
169  * omitted by passing %NULL, this is more efficient if the reversed
170  * version of the string to be matched is not at hand, as
171  * g_pattern_match() will only construct it if the compiled pattern
172  * requires reverse matches.
173  *
174  * Note that, if the user code will (possibly) match a string against a
175  * multitude of patterns containing wildcards, chances are high that
176  * some patterns will require a reversed string. In this case, it&#39;s
177  * more efficient to provide the reversed string to avoid multiple
178  * constructions thereof in the various calls to g_pattern_match().
179  *
180  * Note also that the reverse of a UTF-8 encoded string can in general
181  * not be obtained by g_strreverse(). This works only if the string
182  * does not contain any multibyte characters. GLib offers the
183  * g_utf8_strreverse() function to reverse UTF-8 encoded strings.
184  *
185  * Returns: %TRUE if @string matches @pspec
186  **/
187 gboolean
188 g_pattern_match (GPatternSpec *pspec,
<span class="line-modified">189          guint         string_length,</span>
<span class="line-modified">190          const gchar  *string,</span>
<span class="line-modified">191          const gchar  *string_reversed)</span>
192 {
193   g_return_val_if_fail (pspec != NULL, FALSE);
194   g_return_val_if_fail (string != NULL, FALSE);
195 
196   if (string_length &lt; pspec-&gt;min_length ||
197       string_length &gt; pspec-&gt;max_length)
198     return FALSE;
199 
200   switch (pspec-&gt;match_type)
201     {
202       gboolean dummy;
203     case G_MATCH_ALL:
204       return g_pattern_ph_match (pspec-&gt;pattern, string, &amp;dummy);
205     case G_MATCH_ALL_TAIL:
206       if (string_reversed)
<span class="line-modified">207     return g_pattern_ph_match (pspec-&gt;pattern, string_reversed, &amp;dummy);</span>
208       else
<span class="line-modified">209     {</span>
210           gboolean result;
211           gchar *tmp;
<span class="line-modified">212       tmp = g_utf8_strreverse (string, string_length);</span>
<span class="line-modified">213       result = g_pattern_ph_match (pspec-&gt;pattern, tmp, &amp;dummy);</span>
<span class="line-modified">214       g_free (tmp);</span>
<span class="line-modified">215       return result;</span>
<span class="line-modified">216     }</span>
217     case G_MATCH_HEAD:
218       if (pspec-&gt;pattern_length == string_length)
<span class="line-modified">219     return strcmp (pspec-&gt;pattern, string) == 0;</span>
220       else if (pspec-&gt;pattern_length)
<span class="line-modified">221     return strncmp (pspec-&gt;pattern, string, pspec-&gt;pattern_length) == 0;</span>
222       else
<span class="line-modified">223     return TRUE;</span>
224     case G_MATCH_TAIL:
225       if (pspec-&gt;pattern_length)
226         return strcmp (pspec-&gt;pattern, string + (string_length - pspec-&gt;pattern_length)) == 0;
227       else
<span class="line-modified">228     return TRUE;</span>
229     case G_MATCH_EXACT:
230       if (pspec-&gt;pattern_length != string_length)
231         return FALSE;
232       else
233         return strcmp (pspec-&gt;pattern, string) == 0;
234     default:
235       g_return_val_if_fail (pspec-&gt;match_type &lt; G_MATCH_LAST, FALSE);
236       return FALSE;
237     }
238 }
239 
240 /**
241  * g_pattern_spec_new:
242  * @pattern: a zero-terminated UTF-8 encoded string
243  *
244  * Compiles a pattern to a #GPatternSpec.
245  *
246  * Returns: a newly-allocated #GPatternSpec
247  **/
248 GPatternSpec*
</pre>
<hr />
<pre>
252   gboolean seen_joker = FALSE, seen_wildcard = FALSE, more_wildcards = FALSE;
253   gint hw_pos = -1, tw_pos = -1, hj_pos = -1, tj_pos = -1;
254   gboolean follows_wildcard = FALSE;
255   guint pending_jokers = 0;
256   const gchar *s;
257   gchar *d;
258   guint i;
259 
260   g_return_val_if_fail (pattern != NULL, NULL);
261 
262   /* canonicalize pattern and collect necessary stats */
263   pspec = g_new (GPatternSpec, 1);
264   pspec-&gt;pattern_length = strlen (pattern);
265   pspec-&gt;min_length = 0;
266   pspec-&gt;max_length = 0;
267   pspec-&gt;pattern = g_new (gchar, pspec-&gt;pattern_length + 1);
268   d = pspec-&gt;pattern;
269   for (i = 0, s = pattern; *s != 0; s++)
270     {
271       switch (*s)
<span class="line-modified">272     {</span>
<span class="line-modified">273     case &#39;*&#39;:</span>
<span class="line-modified">274       if (follows_wildcard) /* compress multiple wildcards */</span>
<span class="line-modified">275         {</span>
<span class="line-modified">276           pspec-&gt;pattern_length--;</span>
<span class="line-modified">277           continue;</span>
<span class="line-removed">278         }</span>
<span class="line-removed">279       follows_wildcard = TRUE;</span>
<span class="line-removed">280       if (hw_pos &lt; 0)</span>
<span class="line-removed">281         hw_pos = i;</span>
<span class="line-removed">282       tw_pos = i;</span>
<span class="line-removed">283       break;</span>
<span class="line-removed">284     case &#39;?&#39;:</span>
<span class="line-removed">285       pending_jokers++;</span>
<span class="line-removed">286       pspec-&gt;min_length++;</span>
<span class="line-removed">287       pspec-&gt;max_length += 4; /* maximum UTF-8 character length */</span>
<span class="line-removed">288       continue;</span>
<span class="line-removed">289     default:</span>
<span class="line-removed">290       for (; pending_jokers; pending_jokers--, i++) {</span>
<span class="line-removed">291         *d++ = &#39;?&#39;;</span>
<span class="line-removed">292         if (hj_pos &lt; 0)</span>
<span class="line-removed">293          hj_pos = i;</span>
<span class="line-removed">294         tj_pos = i;</span>
295       }
<span class="line-modified">296       follows_wildcard = FALSE;</span>
<span class="line-modified">297       pspec-&gt;min_length++;</span>
<span class="line-modified">298       pspec-&gt;max_length++;</span>
<span class="line-modified">299       break;</span>












300     }





301       *d++ = *s;
302       i++;
303     }
304   for (; pending_jokers; pending_jokers--) {
305     *d++ = &#39;?&#39;;
306     if (hj_pos &lt; 0)
307       hj_pos = i;
308     tj_pos = i;
309   }
310   *d++ = 0;
311   seen_joker = hj_pos &gt;= 0;
312   seen_wildcard = hw_pos &gt;= 0;
313   more_wildcards = seen_wildcard &amp;&amp; hw_pos != tw_pos;
314   if (seen_wildcard)
315     pspec-&gt;max_length = G_MAXUINT;
316 
317   /* special case sole head/tail wildcard or exact matches */
318   if (!seen_joker &amp;&amp; !more_wildcards)
319     {
320       if (pspec-&gt;pattern[0] == &#39;*&#39;)
<span class="line-modified">321     {</span>
<span class="line-modified">322       pspec-&gt;match_type = G_MATCH_TAIL;</span>
323           memmove (pspec-&gt;pattern, pspec-&gt;pattern + 1, --pspec-&gt;pattern_length);
<span class="line-modified">324       pspec-&gt;pattern[pspec-&gt;pattern_length] = 0;</span>
<span class="line-modified">325       return pspec;</span>
<span class="line-modified">326     }</span>
327       if (pspec-&gt;pattern_length &gt; 0 &amp;&amp;
<span class="line-modified">328       pspec-&gt;pattern[pspec-&gt;pattern_length - 1] == &#39;*&#39;)</span>
<span class="line-modified">329     {</span>
<span class="line-modified">330       pspec-&gt;match_type = G_MATCH_HEAD;</span>
<span class="line-modified">331       pspec-&gt;pattern[--pspec-&gt;pattern_length] = 0;</span>
<span class="line-modified">332       return pspec;</span>
<span class="line-modified">333     }</span>
334       if (!seen_wildcard)
<span class="line-modified">335     {</span>
<span class="line-modified">336       pspec-&gt;match_type = G_MATCH_EXACT;</span>
<span class="line-modified">337       return pspec;</span>
<span class="line-modified">338     }</span>
339     }
340 
341   /* now just need to distinguish between head or tail match start */
342   tw_pos = pspec-&gt;pattern_length - 1 - tw_pos;  /* last pos to tail distance */
343   tj_pos = pspec-&gt;pattern_length - 1 - tj_pos;  /* last pos to tail distance */
344   if (seen_wildcard)
345     pspec-&gt;match_type = tw_pos &gt; hw_pos ? G_MATCH_ALL_TAIL : G_MATCH_ALL;
346   else /* seen_joker */
347     pspec-&gt;match_type = tj_pos &gt; hj_pos ? G_MATCH_ALL_TAIL : G_MATCH_ALL;
348   if (pspec-&gt;match_type == G_MATCH_ALL_TAIL) {
349     gchar *tmp = pspec-&gt;pattern;
350     pspec-&gt;pattern = g_utf8_strreverse (pspec-&gt;pattern, pspec-&gt;pattern_length);
351     g_free (tmp);
352   }
353   return pspec;
354 }
355 
356 /**
357  * g_pattern_spec_free:
358  * @pspec: a #GPatternSpec
</pre>
<hr />
<pre>
363 g_pattern_spec_free (GPatternSpec *pspec)
364 {
365   g_return_if_fail (pspec != NULL);
366 
367   g_free (pspec-&gt;pattern);
368   g_free (pspec);
369 }
370 
371 /**
372  * g_pattern_spec_equal:
373  * @pspec1: a #GPatternSpec
374  * @pspec2: another #GPatternSpec
375  *
376  * Compares two compiled pattern specs and returns whether they will
377  * match the same set of strings.
378  *
379  * Returns: Whether the compiled patterns are equal
380  **/
381 gboolean
382 g_pattern_spec_equal (GPatternSpec *pspec1,
<span class="line-modified">383               GPatternSpec *pspec2)</span>
384 {
385   g_return_val_if_fail (pspec1 != NULL, FALSE);
386   g_return_val_if_fail (pspec2 != NULL, FALSE);
387 
388   return (pspec1-&gt;pattern_length == pspec2-&gt;pattern_length &amp;&amp;
<span class="line-modified">389       pspec1-&gt;match_type == pspec2-&gt;match_type &amp;&amp;</span>
<span class="line-modified">390       strcmp (pspec1-&gt;pattern, pspec2-&gt;pattern) == 0);</span>
391 }
392 
393 /**
394  * g_pattern_match_string:
395  * @pspec: a #GPatternSpec
396  * @string: the UTF-8 encoded string to match
397  *
398  * Matches a string against a compiled pattern. If the string is to be
399  * matched against more than one pattern, consider using
400  * g_pattern_match() instead while supplying the reversed string.
401  *
402  * Returns: %TRUE if @string matches @pspec
403  **/
404 gboolean
405 g_pattern_match_string (GPatternSpec *pspec,
<span class="line-modified">406             const gchar  *string)</span>
407 {
408   g_return_val_if_fail (pspec != NULL, FALSE);
409   g_return_val_if_fail (string != NULL, FALSE);
410 
411   return g_pattern_match (pspec, strlen (string), string, NULL);
412 }
413 
414 /**
415  * g_pattern_match_simple:
416  * @pattern: the UTF-8 encoded pattern
417  * @string: the UTF-8 encoded string to match
418  *
419  * Matches a string against a pattern given as a string. If this
420  * function is to be called in a loop, it&#39;s more efficient to compile
421  * the pattern once with g_pattern_spec_new() and call
422  * g_pattern_match_string() repeatedly.
423  *
424  * Returns: %TRUE if @string matches @pspec
425  **/
426 gboolean
427 g_pattern_match_simple (const gchar *pattern,
<span class="line-modified">428             const gchar *string)</span>
429 {
430   GPatternSpec *pspec;
431   gboolean ergo;
432 
433   g_return_val_if_fail (pattern != NULL, FALSE);
434   g_return_val_if_fail (string != NULL, FALSE);
435 
436   pspec = g_pattern_spec_new (pattern);
437   ergo = g_pattern_match (pspec, strlen (string), string, NULL);
438   g_pattern_spec_free (pspec);
439 
440   return ergo;
441 }
</pre>
</td>
<td>
<hr />
<pre>
 63   G_MATCH_ALL_TAIL,  /* &quot;*A?AA&quot; */
 64   G_MATCH_HEAD,      /* &quot;AAAA*&quot; */
 65   G_MATCH_TAIL,      /* &quot;*AAAA&quot; */
 66   G_MATCH_EXACT,     /* &quot;AAAAA&quot; */
 67   G_MATCH_LAST
 68 } GMatchType;
 69 
 70 struct _GPatternSpec
 71 {
 72   GMatchType match_type;
 73   guint      pattern_length;
 74   guint      min_length;
 75   guint      max_length;
 76   gchar     *pattern;
 77 };
 78 
 79 
 80 /* --- functions --- */
 81 static inline gboolean
 82 g_pattern_ph_match (const gchar *match_pattern,
<span class="line-modified"> 83         const gchar *match_string,</span>
<span class="line-modified"> 84         gboolean    *wildcard_reached_p)</span>
 85 {
 86   const gchar *pattern, *string;
 87   gchar ch;
 88 
 89   pattern = match_pattern;
 90   string = match_string;
 91 
 92   ch = *pattern;
 93   pattern++;
 94   while (ch)
 95     {
 96       switch (ch)
<span class="line-added"> 97   {</span>
<span class="line-added"> 98   case &#39;?&#39;:</span>
<span class="line-added"> 99     if (!*string)</span>
<span class="line-added">100       return FALSE;</span>
<span class="line-added">101     string = g_utf8_next_char (string);</span>
<span class="line-added">102     break;</span>
<span class="line-added">103 </span>
<span class="line-added">104   case &#39;*&#39;:</span>
<span class="line-added">105     *wildcard_reached_p = TRUE;</span>
<span class="line-added">106     do</span>
<span class="line-added">107       {</span>
<span class="line-added">108         ch = *pattern;</span>
<span class="line-added">109         pattern++;</span>
<span class="line-added">110         if (ch == &#39;?&#39;)</span>
111     {

112       if (!*string)
113         return FALSE;
114       string = g_utf8_next_char (string);
<span class="line-modified">115     }</span>
<span class="line-modified">116       }</span>
<span class="line-modified">117     while (ch == &#39;*&#39; || ch == &#39;?&#39;);</span>
<span class="line-modified">118     if (!ch)</span>
<span class="line-modified">119       return TRUE;</span>
<span class="line-modified">120     do</span>
<span class="line-modified">121       {</span>













122               gboolean next_wildcard_reached = FALSE;
<span class="line-modified">123         while (ch != *string)</span>
<span class="line-modified">124     {</span>
<span class="line-modified">125       if (!*string)</span>
<span class="line-modified">126         return FALSE;</span>
<span class="line-modified">127       string = g_utf8_next_char (string);</span>
<span class="line-modified">128     }</span>
<span class="line-modified">129         string++;</span>
<span class="line-modified">130         if (g_pattern_ph_match (pattern, string, &amp;next_wildcard_reached))</span>
<span class="line-modified">131     return TRUE;</span>
132               if (next_wildcard_reached)
133                 /* the forthcoming pattern substring up to the next wildcard has
134                  * been matched, but a mismatch occoured for the rest of the
135                  * pattern, following the next wildcard.
136                  * there&#39;s no need to advance the current match position any
137                  * further if the rest pattern will not match.
138                  */
<span class="line-modified">139     return FALSE;</span>
<span class="line-modified">140       }</span>
<span class="line-modified">141     while (*string);</span>
<span class="line-modified">142     break;</span>
143 
<span class="line-modified">144   default:</span>
<span class="line-modified">145     if (ch == *string)</span>
<span class="line-modified">146       string++;</span>
<span class="line-modified">147     else</span>
<span class="line-modified">148       return FALSE;</span>
<span class="line-modified">149     break;</span>
<span class="line-modified">150   }</span>
151 
152       ch = *pattern;
153       pattern++;
154     }
155 
156   return *string == 0;
157 }
158 
159 /**
160  * g_pattern_match:
161  * @pspec: a #GPatternSpec
162  * @string_length: the length of @string (in bytes, i.e. strlen(),
163  *     not g_utf8_strlen())
164  * @string: the UTF-8 encoded string to match
165  * @string_reversed: (nullable): the reverse of @string or %NULL
166  *
167  * Matches a string against a compiled pattern. Passing the correct
168  * length of the string given is mandatory. The reversed string can be
169  * omitted by passing %NULL, this is more efficient if the reversed
170  * version of the string to be matched is not at hand, as
171  * g_pattern_match() will only construct it if the compiled pattern
172  * requires reverse matches.
173  *
174  * Note that, if the user code will (possibly) match a string against a
175  * multitude of patterns containing wildcards, chances are high that
176  * some patterns will require a reversed string. In this case, it&#39;s
177  * more efficient to provide the reversed string to avoid multiple
178  * constructions thereof in the various calls to g_pattern_match().
179  *
180  * Note also that the reverse of a UTF-8 encoded string can in general
181  * not be obtained by g_strreverse(). This works only if the string
182  * does not contain any multibyte characters. GLib offers the
183  * g_utf8_strreverse() function to reverse UTF-8 encoded strings.
184  *
185  * Returns: %TRUE if @string matches @pspec
186  **/
187 gboolean
188 g_pattern_match (GPatternSpec *pspec,
<span class="line-modified">189      guint         string_length,</span>
<span class="line-modified">190      const gchar  *string,</span>
<span class="line-modified">191      const gchar  *string_reversed)</span>
192 {
193   g_return_val_if_fail (pspec != NULL, FALSE);
194   g_return_val_if_fail (string != NULL, FALSE);
195 
196   if (string_length &lt; pspec-&gt;min_length ||
197       string_length &gt; pspec-&gt;max_length)
198     return FALSE;
199 
200   switch (pspec-&gt;match_type)
201     {
202       gboolean dummy;
203     case G_MATCH_ALL:
204       return g_pattern_ph_match (pspec-&gt;pattern, string, &amp;dummy);
205     case G_MATCH_ALL_TAIL:
206       if (string_reversed)
<span class="line-modified">207   return g_pattern_ph_match (pspec-&gt;pattern, string_reversed, &amp;dummy);</span>
208       else
<span class="line-modified">209   {</span>
210           gboolean result;
211           gchar *tmp;
<span class="line-modified">212     tmp = g_utf8_strreverse (string, string_length);</span>
<span class="line-modified">213     result = g_pattern_ph_match (pspec-&gt;pattern, tmp, &amp;dummy);</span>
<span class="line-modified">214     g_free (tmp);</span>
<span class="line-modified">215     return result;</span>
<span class="line-modified">216   }</span>
217     case G_MATCH_HEAD:
218       if (pspec-&gt;pattern_length == string_length)
<span class="line-modified">219   return strcmp (pspec-&gt;pattern, string) == 0;</span>
220       else if (pspec-&gt;pattern_length)
<span class="line-modified">221   return strncmp (pspec-&gt;pattern, string, pspec-&gt;pattern_length) == 0;</span>
222       else
<span class="line-modified">223   return TRUE;</span>
224     case G_MATCH_TAIL:
225       if (pspec-&gt;pattern_length)
226         return strcmp (pspec-&gt;pattern, string + (string_length - pspec-&gt;pattern_length)) == 0;
227       else
<span class="line-modified">228   return TRUE;</span>
229     case G_MATCH_EXACT:
230       if (pspec-&gt;pattern_length != string_length)
231         return FALSE;
232       else
233         return strcmp (pspec-&gt;pattern, string) == 0;
234     default:
235       g_return_val_if_fail (pspec-&gt;match_type &lt; G_MATCH_LAST, FALSE);
236       return FALSE;
237     }
238 }
239 
240 /**
241  * g_pattern_spec_new:
242  * @pattern: a zero-terminated UTF-8 encoded string
243  *
244  * Compiles a pattern to a #GPatternSpec.
245  *
246  * Returns: a newly-allocated #GPatternSpec
247  **/
248 GPatternSpec*
</pre>
<hr />
<pre>
252   gboolean seen_joker = FALSE, seen_wildcard = FALSE, more_wildcards = FALSE;
253   gint hw_pos = -1, tw_pos = -1, hj_pos = -1, tj_pos = -1;
254   gboolean follows_wildcard = FALSE;
255   guint pending_jokers = 0;
256   const gchar *s;
257   gchar *d;
258   guint i;
259 
260   g_return_val_if_fail (pattern != NULL, NULL);
261 
262   /* canonicalize pattern and collect necessary stats */
263   pspec = g_new (GPatternSpec, 1);
264   pspec-&gt;pattern_length = strlen (pattern);
265   pspec-&gt;min_length = 0;
266   pspec-&gt;max_length = 0;
267   pspec-&gt;pattern = g_new (gchar, pspec-&gt;pattern_length + 1);
268   d = pspec-&gt;pattern;
269   for (i = 0, s = pattern; *s != 0; s++)
270     {
271       switch (*s)
<span class="line-modified">272   {</span>
<span class="line-modified">273   case &#39;*&#39;:</span>
<span class="line-modified">274     if (follows_wildcard) /* compress multiple wildcards */</span>
<span class="line-modified">275       {</span>
<span class="line-modified">276         pspec-&gt;pattern_length--;</span>
<span class="line-modified">277         continue;</span>

















278       }
<span class="line-modified">279     follows_wildcard = TRUE;</span>
<span class="line-modified">280     if (hw_pos &lt; 0)</span>
<span class="line-modified">281       hw_pos = i;</span>
<span class="line-modified">282     tw_pos = i;</span>
<span class="line-added">283     break;</span>
<span class="line-added">284   case &#39;?&#39;:</span>
<span class="line-added">285     pending_jokers++;</span>
<span class="line-added">286     pspec-&gt;min_length++;</span>
<span class="line-added">287     pspec-&gt;max_length += 4; /* maximum UTF-8 character length */</span>
<span class="line-added">288     continue;</span>
<span class="line-added">289   default:</span>
<span class="line-added">290     for (; pending_jokers; pending_jokers--, i++) {</span>
<span class="line-added">291       *d++ = &#39;?&#39;;</span>
<span class="line-added">292         if (hj_pos &lt; 0)</span>
<span class="line-added">293        hj_pos = i;</span>
<span class="line-added">294       tj_pos = i;</span>
295     }
<span class="line-added">296     follows_wildcard = FALSE;</span>
<span class="line-added">297     pspec-&gt;min_length++;</span>
<span class="line-added">298     pspec-&gt;max_length++;</span>
<span class="line-added">299     break;</span>
<span class="line-added">300   }</span>
301       *d++ = *s;
302       i++;
303     }
304   for (; pending_jokers; pending_jokers--) {
305     *d++ = &#39;?&#39;;
306     if (hj_pos &lt; 0)
307       hj_pos = i;
308     tj_pos = i;
309   }
310   *d++ = 0;
311   seen_joker = hj_pos &gt;= 0;
312   seen_wildcard = hw_pos &gt;= 0;
313   more_wildcards = seen_wildcard &amp;&amp; hw_pos != tw_pos;
314   if (seen_wildcard)
315     pspec-&gt;max_length = G_MAXUINT;
316 
317   /* special case sole head/tail wildcard or exact matches */
318   if (!seen_joker &amp;&amp; !more_wildcards)
319     {
320       if (pspec-&gt;pattern[0] == &#39;*&#39;)
<span class="line-modified">321   {</span>
<span class="line-modified">322     pspec-&gt;match_type = G_MATCH_TAIL;</span>
323           memmove (pspec-&gt;pattern, pspec-&gt;pattern + 1, --pspec-&gt;pattern_length);
<span class="line-modified">324     pspec-&gt;pattern[pspec-&gt;pattern_length] = 0;</span>
<span class="line-modified">325     return pspec;</span>
<span class="line-modified">326   }</span>
327       if (pspec-&gt;pattern_length &gt; 0 &amp;&amp;
<span class="line-modified">328     pspec-&gt;pattern[pspec-&gt;pattern_length - 1] == &#39;*&#39;)</span>
<span class="line-modified">329   {</span>
<span class="line-modified">330     pspec-&gt;match_type = G_MATCH_HEAD;</span>
<span class="line-modified">331     pspec-&gt;pattern[--pspec-&gt;pattern_length] = 0;</span>
<span class="line-modified">332     return pspec;</span>
<span class="line-modified">333   }</span>
334       if (!seen_wildcard)
<span class="line-modified">335   {</span>
<span class="line-modified">336     pspec-&gt;match_type = G_MATCH_EXACT;</span>
<span class="line-modified">337     return pspec;</span>
<span class="line-modified">338   }</span>
339     }
340 
341   /* now just need to distinguish between head or tail match start */
342   tw_pos = pspec-&gt;pattern_length - 1 - tw_pos;  /* last pos to tail distance */
343   tj_pos = pspec-&gt;pattern_length - 1 - tj_pos;  /* last pos to tail distance */
344   if (seen_wildcard)
345     pspec-&gt;match_type = tw_pos &gt; hw_pos ? G_MATCH_ALL_TAIL : G_MATCH_ALL;
346   else /* seen_joker */
347     pspec-&gt;match_type = tj_pos &gt; hj_pos ? G_MATCH_ALL_TAIL : G_MATCH_ALL;
348   if (pspec-&gt;match_type == G_MATCH_ALL_TAIL) {
349     gchar *tmp = pspec-&gt;pattern;
350     pspec-&gt;pattern = g_utf8_strreverse (pspec-&gt;pattern, pspec-&gt;pattern_length);
351     g_free (tmp);
352   }
353   return pspec;
354 }
355 
356 /**
357  * g_pattern_spec_free:
358  * @pspec: a #GPatternSpec
</pre>
<hr />
<pre>
363 g_pattern_spec_free (GPatternSpec *pspec)
364 {
365   g_return_if_fail (pspec != NULL);
366 
367   g_free (pspec-&gt;pattern);
368   g_free (pspec);
369 }
370 
371 /**
372  * g_pattern_spec_equal:
373  * @pspec1: a #GPatternSpec
374  * @pspec2: another #GPatternSpec
375  *
376  * Compares two compiled pattern specs and returns whether they will
377  * match the same set of strings.
378  *
379  * Returns: Whether the compiled patterns are equal
380  **/
381 gboolean
382 g_pattern_spec_equal (GPatternSpec *pspec1,
<span class="line-modified">383           GPatternSpec *pspec2)</span>
384 {
385   g_return_val_if_fail (pspec1 != NULL, FALSE);
386   g_return_val_if_fail (pspec2 != NULL, FALSE);
387 
388   return (pspec1-&gt;pattern_length == pspec2-&gt;pattern_length &amp;&amp;
<span class="line-modified">389     pspec1-&gt;match_type == pspec2-&gt;match_type &amp;&amp;</span>
<span class="line-modified">390     strcmp (pspec1-&gt;pattern, pspec2-&gt;pattern) == 0);</span>
391 }
392 
393 /**
394  * g_pattern_match_string:
395  * @pspec: a #GPatternSpec
396  * @string: the UTF-8 encoded string to match
397  *
398  * Matches a string against a compiled pattern. If the string is to be
399  * matched against more than one pattern, consider using
400  * g_pattern_match() instead while supplying the reversed string.
401  *
402  * Returns: %TRUE if @string matches @pspec
403  **/
404 gboolean
405 g_pattern_match_string (GPatternSpec *pspec,
<span class="line-modified">406       const gchar  *string)</span>
407 {
408   g_return_val_if_fail (pspec != NULL, FALSE);
409   g_return_val_if_fail (string != NULL, FALSE);
410 
411   return g_pattern_match (pspec, strlen (string), string, NULL);
412 }
413 
414 /**
415  * g_pattern_match_simple:
416  * @pattern: the UTF-8 encoded pattern
417  * @string: the UTF-8 encoded string to match
418  *
419  * Matches a string against a pattern given as a string. If this
420  * function is to be called in a loop, it&#39;s more efficient to compile
421  * the pattern once with g_pattern_spec_new() and call
422  * g_pattern_match_string() repeatedly.
423  *
424  * Returns: %TRUE if @string matches @pspec
425  **/
426 gboolean
427 g_pattern_match_simple (const gchar *pattern,
<span class="line-modified">428       const gchar *string)</span>
429 {
430   GPatternSpec *pspec;
431   gboolean ergo;
432 
433   g_return_val_if_fail (pattern != NULL, FALSE);
434   g_return_val_if_fail (string != NULL, FALSE);
435 
436   pspec = g_pattern_spec_new (pattern);
437   ergo = g_pattern_match (pspec, strlen (string), string, NULL);
438   g_pattern_spec_free (pspec);
439 
440   return ergo;
441 }
</pre>
</td>
</tr>
</table>
<center><a href="goption.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gpattern.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>