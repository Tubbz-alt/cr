<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstcollectpads.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 2005 Wim Taymans &lt;wim@fluendo.com&gt;
   3  * Copyright (C) 2008 Mark Nauwelaerts &lt;mnauw@users.sourceforge.net&gt;
   4  * Copyright (C) 2010 Sebastian Dr√∂ge &lt;sebastian.droege@collabora.co.uk&gt;
   5  *
   6  * gstcollectpads.c:
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public
  19  * License along with this library; if not, write to the
  20  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 /**
  24  * SECTION:gstcollectpads
  25  * @title: GstCollectPads
  26  * @short_description: manages a set of pads that operate in collect mode
  27  * @see_also:
  28  *
  29  * Manages a set of pads that operate in collect mode. This means that control
  30  * is given to the manager of this object when all pads have data.
  31  *
  32  *   * Collectpads are created with gst_collect_pads_new(). A callback should then
  33  *     be installed with gst_collect_pads_set_function ().
  34  *
  35  *   * Pads are added to the collection with gst_collect_pads_add_pad()/
  36  *     gst_collect_pads_remove_pad(). The pad has to be a sinkpad. When added,
  37  *     the chain, event and query functions of the pad are overridden. The
  38  *     element_private of the pad is used to store private information for the
  39  *     collectpads.
  40  *
  41  *   * For each pad, data is queued in the _chain function or by
  42  *     performing a pull_range.
  43  *
  44  *   * When data is queued on all pads in waiting mode, the callback function is called.
  45  *
  46  *   * Data can be dequeued from the pad with the gst_collect_pads_pop() method.
  47  *     One can peek at the data with the gst_collect_pads_peek() function.
  48  *     These functions will return %NULL if the pad received an EOS event. When all
  49  *     pads return %NULL from a gst_collect_pads_peek(), the element can emit an EOS
  50  *     event itself.
  51  *
  52  *   * Data can also be dequeued in byte units using the gst_collect_pads_available(),
  53  *     gst_collect_pads_read_buffer() and gst_collect_pads_flush() calls.
  54  *
  55  *   * Elements should call gst_collect_pads_start() and gst_collect_pads_stop() in
  56  *     their state change functions to start and stop the processing of the collectpads.
  57  *     The gst_collect_pads_stop() call should be called before calling the parent
  58  *     element state change function in the PAUSED_TO_READY state change to ensure
  59  *     no pad is blocked and the element can finish streaming.
  60  *
  61  *   * gst_collect_pads_set_waiting() sets a pad to waiting or non-waiting mode.
  62  *     CollectPads element is not waiting for data to be collected on non-waiting pads.
  63  *     Thus these pads may but need not have data when the callback is called.
  64  *     All pads are in waiting mode by default.
  65  *
  66  */
  67 
  68 #ifdef HAVE_CONFIG_H
  69 #  include &quot;config.h&quot;
  70 #endif
  71 
  72 #include &lt;gst/gst_private.h&gt;
  73 
  74 #include &quot;gstcollectpads.h&quot;
  75 
  76 #include &quot;../../../gst/glib-compat-private.h&quot;
  77 
  78 GST_DEBUG_CATEGORY_STATIC (collect_pads_debug);
  79 #define GST_CAT_DEFAULT collect_pads_debug
  80 
  81 #define parent_class gst_collect_pads_parent_class
  82 G_DEFINE_TYPE (GstCollectPads, gst_collect_pads, GST_TYPE_OBJECT);
  83 
  84 struct _GstCollectDataPrivate
  85 {
  86   /* refcounting for struct, and destroy callback */
  87   GstCollectDataDestroyNotify destroy_notify;
  88   gint refcount;
  89 };
  90 
  91 struct _GstCollectPadsPrivate
  92 {
  93   /* with LOCK and/or STREAM_LOCK */
  94   gboolean started;
  95 
  96   /* with STREAM_LOCK */
  97   guint32 cookie;               /* pad_list cookie */
  98   guint numpads;                /* number of pads in @data */
  99   guint queuedpads;             /* number of pads with a buffer */
 100   guint eospads;                /* number of pads that are EOS */
 101   GstClockTime earliest_time;   /* Current earliest time */
 102   GstCollectData *earliest_data;        /* Pad data for current earliest time */
 103 
 104   /* with LOCK */
 105   GSList *pad_list;             /* list of GstCollectData* */
 106   guint32 pad_cookie;           /* updated cookie */
 107 
 108   GstCollectPadsFunction func;  /* function and user_data for callback */
 109   gpointer user_data;
 110   GstCollectPadsBufferFunction buffer_func;     /* function and user_data for buffer callback */
 111   gpointer buffer_user_data;
 112   GstCollectPadsCompareFunction compare_func;
 113   gpointer compare_user_data;
 114   GstCollectPadsEventFunction event_func;       /* function and data for event callback */
 115   gpointer event_user_data;
 116   GstCollectPadsQueryFunction query_func;
 117   gpointer query_user_data;
 118   GstCollectPadsClipFunction clip_func;
 119   gpointer clip_user_data;
 120   GstCollectPadsFlushFunction flush_func;
 121   gpointer flush_user_data;
 122 
 123   /* no other lock needed */
 124   GMutex evt_lock;              /* these make up sort of poor man&#39;s event signaling */
 125   GCond evt_cond;
 126   guint32 evt_cookie;
 127 
 128   gboolean seeking;
 129   gboolean pending_flush_start;
 130   gboolean pending_flush_stop;
 131 };
 132 
 133 static void gst_collect_pads_clear (GstCollectPads * pads,
 134     GstCollectData * data);
 135 static GstFlowReturn gst_collect_pads_chain (GstPad * pad, GstObject * parent,
 136     GstBuffer * buffer);
 137 static gboolean gst_collect_pads_event (GstPad * pad, GstObject * parent,
 138     GstEvent * event);
 139 static gboolean gst_collect_pads_query (GstPad * pad, GstObject * parent,
 140     GstQuery * query);
 141 static void gst_collect_pads_finalize (GObject * object);
 142 static GstFlowReturn gst_collect_pads_default_collected (GstCollectPads *
 143     pads, gpointer user_data);
 144 static gint gst_collect_pads_default_compare_func (GstCollectPads * pads,
 145     GstCollectData * data1, GstClockTime timestamp1, GstCollectData * data2,
 146     GstClockTime timestamp2, gpointer user_data);
 147 static gboolean gst_collect_pads_recalculate_full (GstCollectPads * pads);
 148 static void ref_data (GstCollectData * data);
 149 static void unref_data (GstCollectData * data);
 150 
 151 static gboolean gst_collect_pads_event_default_internal (GstCollectPads *
 152     pads, GstCollectData * data, GstEvent * event, gpointer user_data);
 153 static gboolean gst_collect_pads_query_default_internal (GstCollectPads *
 154     pads, GstCollectData * data, GstQuery * query, gpointer user_data);
 155 
 156 
 157 /* Some properties are protected by LOCK, others by STREAM_LOCK
 158  * However, manipulating either of these partitions may require
 159  * to signal/wake a _WAIT, so use a separate (sort of) event to prevent races
 160  * Alternative implementations are possible, e.g. some low-level re-implementing
 161  * of the 2 above locks to drop both of them atomically when going into _WAIT.
 162  */
 163 #define GST_COLLECT_PADS_GET_EVT_COND(pads) (&amp;((GstCollectPads *)pads)-&gt;priv-&gt;evt_cond)
 164 #define GST_COLLECT_PADS_GET_EVT_LOCK(pads) (&amp;((GstCollectPads *)pads)-&gt;priv-&gt;evt_lock)
 165 #define GST_COLLECT_PADS_EVT_WAIT(pads, cookie) G_STMT_START {    \
 166   g_mutex_lock (GST_COLLECT_PADS_GET_EVT_LOCK (pads));            \
 167   /* should work unless a lot of event&#39;ing and thread starvation */\
 168   while (cookie == ((GstCollectPads *) pads)-&gt;priv-&gt;evt_cookie)         \
 169     g_cond_wait (GST_COLLECT_PADS_GET_EVT_COND (pads),            \
 170         GST_COLLECT_PADS_GET_EVT_LOCK (pads));                    \
 171   cookie = ((GstCollectPads *) pads)-&gt;priv-&gt;evt_cookie;                 \
 172   g_mutex_unlock (GST_COLLECT_PADS_GET_EVT_LOCK (pads));          \
 173 } G_STMT_END
 174 #define GST_COLLECT_PADS_EVT_WAIT_TIMED(pads, cookie, timeout) G_STMT_START { \
 175   GTimeVal __tv; \
 176   \
 177   g_get_current_time (&amp;tv); \
 178   g_time_val_add (&amp;tv, timeout); \
 179   \
 180   g_mutex_lock (GST_COLLECT_PADS_GET_EVT_LOCK (pads));            \
 181   /* should work unless a lot of event&#39;ing and thread starvation */\
 182   while (cookie == ((GstCollectPads *) pads)-&gt;priv-&gt;evt_cookie)         \
 183     g_cond_timed_wait (GST_COLLECT_PADS_GET_EVT_COND (pads),            \
 184         GST_COLLECT_PADS_GET_EVT_LOCK (pads), &amp;tv);                    \
 185   cookie = ((GstCollectPads *) pads)-&gt;priv-&gt;evt_cookie;                 \
 186   g_mutex_unlock (GST_COLLECT_PADS_GET_EVT_LOCK (pads));          \
 187 } G_STMT_END
 188 #define GST_COLLECT_PADS_EVT_BROADCAST(pads) G_STMT_START {       \
 189   g_mutex_lock (GST_COLLECT_PADS_GET_EVT_LOCK (pads));            \
 190   /* never mind wrap-around */                                     \
 191   ++(((GstCollectPads *) pads)-&gt;priv-&gt;evt_cookie);                      \
 192   g_cond_broadcast (GST_COLLECT_PADS_GET_EVT_COND (pads));        \
 193   g_mutex_unlock (GST_COLLECT_PADS_GET_EVT_LOCK (pads));          \
 194 } G_STMT_END
 195 #define GST_COLLECT_PADS_EVT_INIT(cookie) G_STMT_START {          \
 196   g_mutex_lock (GST_COLLECT_PADS_GET_EVT_LOCK (pads));            \
 197   cookie = ((GstCollectPads *) pads)-&gt;priv-&gt;evt_cookie;                 \
 198   g_mutex_unlock (GST_COLLECT_PADS_GET_EVT_LOCK (pads));          \
 199 } G_STMT_END
 200 
 201 static void
 202 gst_collect_pads_class_init (GstCollectPadsClass * klass)
 203 {
 204   GObjectClass *gobject_class = (GObjectClass *) klass;
 205 
 206   g_type_class_add_private (klass, sizeof (GstCollectPadsPrivate));
 207 
 208   GST_DEBUG_CATEGORY_INIT (collect_pads_debug, &quot;collectpads&quot;, 0,
 209       &quot;GstCollectPads&quot;);
 210 
 211   gobject_class-&gt;finalize = GST_DEBUG_FUNCPTR (gst_collect_pads_finalize);
 212 }
 213 
 214 static void
 215 gst_collect_pads_init (GstCollectPads * pads)
 216 {
 217   pads-&gt;priv =
 218       G_TYPE_INSTANCE_GET_PRIVATE (pads, GST_TYPE_COLLECT_PADS,
 219       GstCollectPadsPrivate);
 220 
 221   pads-&gt;data = NULL;
 222   pads-&gt;priv-&gt;cookie = 0;
 223   pads-&gt;priv-&gt;numpads = 0;
 224   pads-&gt;priv-&gt;queuedpads = 0;
 225   pads-&gt;priv-&gt;eospads = 0;
 226   pads-&gt;priv-&gt;started = FALSE;
 227 
 228   g_rec_mutex_init (&amp;pads-&gt;stream_lock);
 229 
 230   pads-&gt;priv-&gt;func = gst_collect_pads_default_collected;
 231   pads-&gt;priv-&gt;user_data = NULL;
 232   pads-&gt;priv-&gt;event_func = NULL;
 233   pads-&gt;priv-&gt;event_user_data = NULL;
 234 
 235   /* members for default muxing */
 236   pads-&gt;priv-&gt;buffer_func = NULL;
 237   pads-&gt;priv-&gt;buffer_user_data = NULL;
 238   pads-&gt;priv-&gt;compare_func = gst_collect_pads_default_compare_func;
 239   pads-&gt;priv-&gt;compare_user_data = NULL;
 240   pads-&gt;priv-&gt;earliest_data = NULL;
 241   pads-&gt;priv-&gt;earliest_time = GST_CLOCK_TIME_NONE;
 242 
 243   pads-&gt;priv-&gt;event_func = gst_collect_pads_event_default_internal;
 244   pads-&gt;priv-&gt;query_func = gst_collect_pads_query_default_internal;
 245 
 246   /* members to manage the pad list */
 247   pads-&gt;priv-&gt;pad_cookie = 0;
 248   pads-&gt;priv-&gt;pad_list = NULL;
 249 
 250   /* members for event */
 251   g_mutex_init (&amp;pads-&gt;priv-&gt;evt_lock);
 252   g_cond_init (&amp;pads-&gt;priv-&gt;evt_cond);
 253   pads-&gt;priv-&gt;evt_cookie = 0;
 254 
 255   pads-&gt;priv-&gt;seeking = FALSE;
 256   pads-&gt;priv-&gt;pending_flush_start = FALSE;
 257   pads-&gt;priv-&gt;pending_flush_stop = FALSE;
 258 }
 259 
 260 static void
 261 gst_collect_pads_finalize (GObject * object)
 262 {
 263   GstCollectPads *pads = GST_COLLECT_PADS (object);
 264 
 265   GST_DEBUG_OBJECT (object, &quot;finalize&quot;);
 266 
 267   g_rec_mutex_clear (&amp;pads-&gt;stream_lock);
 268 
 269   g_cond_clear (&amp;pads-&gt;priv-&gt;evt_cond);
 270   g_mutex_clear (&amp;pads-&gt;priv-&gt;evt_lock);
 271 
 272   /* Remove pads and free pads list */
 273   g_slist_foreach (pads-&gt;priv-&gt;pad_list, (GFunc) unref_data, NULL);
 274   g_slist_foreach (pads-&gt;data, (GFunc) unref_data, NULL);
 275   g_slist_free (pads-&gt;data);
 276   g_slist_free (pads-&gt;priv-&gt;pad_list);
 277 
 278   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 279 }
 280 
 281 /**
 282  * gst_collect_pads_new:
 283  *
 284  * Create a new instance of #GstCollectPads.
 285  *
 286  * MT safe.
 287  *
 288  * Returns: (transfer full): a new #GstCollectPads, or %NULL in case of an error.
 289  */
 290 GstCollectPads *
 291 gst_collect_pads_new (void)
 292 {
 293   GstCollectPads *newcoll;
 294 
 295   newcoll = g_object_new (GST_TYPE_COLLECT_PADS, NULL);
 296 
 297   /* clear floating flag */
 298   gst_object_ref_sink (newcoll);
 299 
 300   return newcoll;
 301 }
 302 
 303 /* Must be called with GstObject lock! */
 304 static void
 305 gst_collect_pads_set_buffer_function_locked (GstCollectPads * pads,
 306     GstCollectPadsBufferFunction func, gpointer user_data)
 307 {
 308   pads-&gt;priv-&gt;buffer_func = func;
 309   pads-&gt;priv-&gt;buffer_user_data = user_data;
 310 }
 311 
 312 /**
 313  * gst_collect_pads_set_buffer_function:
 314  * @pads: the collectpads to use
 315  * @func: (scope call): the function to set
 316  * @user_data: (closure): user data passed to the function
 317  *
 318  * Set the callback function and user data that will be called with
 319  * the oldest buffer when all pads have been collected, or %NULL on EOS.
 320  * If a buffer is passed, the callback owns a reference and must unref
 321  * it.
 322  *
 323  * MT safe.
 324  */
 325 void
 326 gst_collect_pads_set_buffer_function (GstCollectPads * pads,
 327     GstCollectPadsBufferFunction func, gpointer user_data)
 328 {
 329   g_return_if_fail (pads != NULL);
 330   g_return_if_fail (GST_IS_COLLECT_PADS (pads));
 331 
 332   GST_OBJECT_LOCK (pads);
 333   gst_collect_pads_set_buffer_function_locked (pads, func, user_data);
 334   GST_OBJECT_UNLOCK (pads);
 335 }
 336 
 337 /**
 338  * gst_collect_pads_set_compare_function:
 339  * @pads: the pads to use
 340  * @func: (scope call): the function to set
 341  * @user_data: (closure): user data passed to the function
 342  *
 343  * Set the timestamp comparison function.
 344  *
 345  * MT safe.
 346  */
 347 /* NOTE allowing to change comparison seems not advisable;
 348 no known use-case, and collaboration with default algorithm is unpredictable.
 349 If custom compairing/operation is needed, just use a collect function of
 350 your own */
 351 void
 352 gst_collect_pads_set_compare_function (GstCollectPads * pads,
 353     GstCollectPadsCompareFunction func, gpointer user_data)
 354 {
 355   g_return_if_fail (pads != NULL);
 356   g_return_if_fail (GST_IS_COLLECT_PADS (pads));
 357 
 358   GST_OBJECT_LOCK (pads);
 359   pads-&gt;priv-&gt;compare_func = func;
 360   pads-&gt;priv-&gt;compare_user_data = user_data;
 361   GST_OBJECT_UNLOCK (pads);
 362 }
 363 
 364 /**
 365  * gst_collect_pads_set_function:
 366  * @pads: the collectpads to use
 367  * @func: (scope call): the function to set
 368  * @user_data: user data passed to the function
 369  *
 370  * CollectPads provides a default collection algorithm that will determine
 371  * the oldest buffer available on all of its pads, and then delegate
 372  * to a configured callback.
 373  * However, if circumstances are more complicated and/or more control
 374  * is desired, this sets a callback that will be invoked instead when
 375  * all the pads added to the collection have buffers queued.
 376  * Evidently, this callback is not compatible with
 377  * gst_collect_pads_set_buffer_function() callback.
 378  * If this callback is set, the former will be unset.
 379  *
 380  * MT safe.
 381  */
 382 void
 383 gst_collect_pads_set_function (GstCollectPads * pads,
 384     GstCollectPadsFunction func, gpointer user_data)
 385 {
 386   g_return_if_fail (pads != NULL);
 387   g_return_if_fail (GST_IS_COLLECT_PADS (pads));
 388 
 389   GST_OBJECT_LOCK (pads);
 390   pads-&gt;priv-&gt;func = func;
 391   pads-&gt;priv-&gt;user_data = user_data;
 392   gst_collect_pads_set_buffer_function_locked (pads, NULL, NULL);
 393   GST_OBJECT_UNLOCK (pads);
 394 }
 395 
 396 static void
 397 ref_data (GstCollectData * data)
 398 {
 399   g_assert (data != NULL);
 400 
 401   g_atomic_int_inc (&amp;(data-&gt;priv-&gt;refcount));
 402 }
 403 
 404 static void
 405 unref_data (GstCollectData * data)
 406 {
 407   g_assert (data != NULL);
 408   g_assert (data-&gt;priv-&gt;refcount &gt; 0);
 409 
 410   if (!g_atomic_int_dec_and_test (&amp;(data-&gt;priv-&gt;refcount)))
 411     return;
 412 
 413   if (data-&gt;priv-&gt;destroy_notify)
 414     data-&gt;priv-&gt;destroy_notify (data);
 415 
 416   g_object_unref (data-&gt;pad);
 417   if (data-&gt;buffer) {
 418     gst_buffer_unref (data-&gt;buffer);
 419   }
 420   g_free (data-&gt;priv);
 421   g_free (data);
 422 }
 423 
 424 /**
 425  * gst_collect_pads_set_event_function:
 426  * @pads: the collectpads to use
 427  * @func: (scope call): the function to set
 428  * @user_data: user data passed to the function
 429  *
 430  * Set the event callback function and user data that will be called when
 431  * collectpads has received an event originating from one of the collected
 432  * pads.  If the event being processed is a serialized one, this callback is
 433  * called with @pads STREAM_LOCK held, otherwise not.  As this lock should be
 434  * held when calling a number of CollectPads functions, it should be acquired
 435  * if so (unusually) needed.
 436  *
 437  * MT safe.
 438  */
 439 void
 440 gst_collect_pads_set_event_function (GstCollectPads * pads,
 441     GstCollectPadsEventFunction func, gpointer user_data)
 442 {
 443   g_return_if_fail (pads != NULL);
 444   g_return_if_fail (GST_IS_COLLECT_PADS (pads));
 445 
 446   GST_OBJECT_LOCK (pads);
 447   pads-&gt;priv-&gt;event_func = func;
 448   pads-&gt;priv-&gt;event_user_data = user_data;
 449   GST_OBJECT_UNLOCK (pads);
 450 }
 451 
 452 /**
 453  * gst_collect_pads_set_query_function:
 454  * @pads: the collectpads to use
 455  * @func: (scope call): the function to set
 456  * @user_data: user data passed to the function
 457  *
 458  * Set the query callback function and user data that will be called after
 459  * collectpads has received a query originating from one of the collected
 460  * pads.  If the query being processed is a serialized one, this callback is
 461  * called with @pads STREAM_LOCK held, otherwise not.  As this lock should be
 462  * held when calling a number of CollectPads functions, it should be acquired
 463  * if so (unusually) needed.
 464  *
 465  * MT safe.
 466  */
 467 void
 468 gst_collect_pads_set_query_function (GstCollectPads * pads,
 469     GstCollectPadsQueryFunction func, gpointer user_data)
 470 {
 471   g_return_if_fail (pads != NULL);
 472   g_return_if_fail (GST_IS_COLLECT_PADS (pads));
 473 
 474   GST_OBJECT_LOCK (pads);
 475   pads-&gt;priv-&gt;query_func = func;
 476   pads-&gt;priv-&gt;query_user_data = user_data;
 477   GST_OBJECT_UNLOCK (pads);
 478 }
 479 
 480 /**
 481 * gst_collect_pads_clip_running_time:
 482 * @pads: the collectpads to use
 483 * @cdata: collect data of corresponding pad
 484 * @buf: buffer being clipped
 485 * @outbuf: (allow-none) (out): output buffer with running time, or NULL if clipped
 486 * @user_data: user data (unused)
 487 *
 488 * Convenience clipping function that converts incoming buffer&#39;s timestamp
 489 * to running time, or clips the buffer if outside configured segment.
 490 *
 491 * Since 1.6, this clipping function also sets the DTS parameter of the
 492 * GstCollectData structure. This version of the running time DTS can be
 493 * negative. G_MININT64 is used to indicate invalid value.
 494 */
 495 GstFlowReturn
 496 gst_collect_pads_clip_running_time (GstCollectPads * pads,
 497     GstCollectData * cdata, GstBuffer * buf, GstBuffer ** outbuf,
 498     gpointer user_data)
 499 {
 500   *outbuf = buf;
 501 
 502   /* invalid left alone and passed */
 503   if (G_LIKELY (GST_CLOCK_TIME_IS_VALID (GST_BUFFER_DTS_OR_PTS (buf)))) {
 504     GstClockTime time;
 505     GstClockTime buf_dts, abs_dts;
 506     gint dts_sign;
 507 
 508     time = GST_BUFFER_PTS (buf);
 509 
 510     if (GST_CLOCK_TIME_IS_VALID (time)) {
 511       time =
 512           gst_segment_to_running_time (&amp;cdata-&gt;segment, GST_FORMAT_TIME, time);
 513       if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (time))) {
 514         GST_DEBUG_OBJECT (cdata-&gt;pad, &quot;clipping buffer on pad outside segment %&quot;
 515             GST_TIME_FORMAT, GST_TIME_ARGS (GST_BUFFER_PTS (buf)));
 516         gst_buffer_unref (buf);
 517         *outbuf = NULL;
 518         return GST_FLOW_OK;
 519       }
 520     }
 521 
 522     GST_LOG_OBJECT (cdata-&gt;pad, &quot;buffer pts %&quot; GST_TIME_FORMAT &quot; -&gt; %&quot;
 523         GST_TIME_FORMAT &quot; running time&quot;,
 524         GST_TIME_ARGS (GST_BUFFER_PTS (buf)), GST_TIME_ARGS (time));
 525     *outbuf = gst_buffer_make_writable (buf);
 526     GST_BUFFER_PTS (*outbuf) = time;
 527 
 528     dts_sign = gst_segment_to_running_time_full (&amp;cdata-&gt;segment,
 529         GST_FORMAT_TIME, GST_BUFFER_DTS (*outbuf), &amp;abs_dts);
 530     buf_dts = GST_BUFFER_DTS (*outbuf);
 531     if (dts_sign &gt; 0) {
 532       GST_BUFFER_DTS (*outbuf) = abs_dts;
 533       GST_COLLECT_PADS_DTS (cdata) = abs_dts;
 534     } else if (dts_sign &lt; 0) {
 535       GST_BUFFER_DTS (*outbuf) = GST_CLOCK_TIME_NONE;
 536       GST_COLLECT_PADS_DTS (cdata) = -((gint64) abs_dts);
 537     } else {
 538       GST_BUFFER_DTS (*outbuf) = GST_CLOCK_TIME_NONE;
 539       GST_COLLECT_PADS_DTS (cdata) = GST_CLOCK_STIME_NONE;
 540     }
 541 
 542     GST_LOG_OBJECT (cdata-&gt;pad, &quot;buffer dts %&quot; GST_TIME_FORMAT &quot; -&gt; %&quot;
 543         GST_STIME_FORMAT &quot; running time&quot;, GST_TIME_ARGS (buf_dts),
 544         GST_STIME_ARGS (GST_COLLECT_PADS_DTS (cdata)));
 545   }
 546 
 547   return GST_FLOW_OK;
 548 }
 549 
 550 /**
 551  * gst_collect_pads_set_clip_function:
 552  * @pads: the collectpads to use
 553  * @clipfunc: (scope call): clip function to install
 554  * @user_data: user data to pass to @clip_func
 555  *
 556  * Install a clipping function that is called right after a buffer is received
 557  * on a pad managed by @pads. See #GstCollectPadsClipFunction for more info.
 558  */
 559 void
 560 gst_collect_pads_set_clip_function (GstCollectPads * pads,
 561     GstCollectPadsClipFunction clipfunc, gpointer user_data)
 562 {
 563   g_return_if_fail (pads != NULL);
 564   g_return_if_fail (GST_IS_COLLECT_PADS (pads));
 565 
 566   pads-&gt;priv-&gt;clip_func = clipfunc;
 567   pads-&gt;priv-&gt;clip_user_data = user_data;
 568 }
 569 
 570 /**
 571  * gst_collect_pads_set_flush_function:
 572  * @pads: the collectpads to use
 573  * @func: (scope call): flush function to install
 574  * @user_data: user data to pass to @func
 575  *
 576  * Install a flush function that is called when the internal
 577  * state of all pads should be flushed as part of flushing seek
 578  * handling. See #GstCollectPadsFlushFunction for more info.
 579  *
 580  * Since: 1.4
 581  */
 582 void
 583 gst_collect_pads_set_flush_function (GstCollectPads * pads,
 584     GstCollectPadsFlushFunction func, gpointer user_data)
 585 {
 586   g_return_if_fail (pads != NULL);
 587   g_return_if_fail (GST_IS_COLLECT_PADS (pads));
 588 
 589   pads-&gt;priv-&gt;flush_func = func;
 590   pads-&gt;priv-&gt;flush_user_data = user_data;
 591 }
 592 
 593 /**
 594  * gst_collect_pads_add_pad:
 595  * @pads: the collectpads to use
 596  * @pad: (transfer none): the pad to add
 597  * @size: the size of the returned #GstCollectData structure
 598  * @destroy_notify: (scope async): function to be called before the returned
 599  *   #GstCollectData structure is freed
 600  * @lock: whether to lock this pad in usual waiting state
 601  *
 602  * Add a pad to the collection of collect pads. The pad has to be
 603  * a sinkpad. The refcount of the pad is incremented. Use
 604  * gst_collect_pads_remove_pad() to remove the pad from the collection
 605  * again.
 606  *
 607  * You specify a size for the returned #GstCollectData structure
 608  * so that you can use it to store additional information.
 609  *
 610  * You can also specify a #GstCollectDataDestroyNotify that will be called
 611  * just before the #GstCollectData structure is freed. It is passed the
 612  * pointer to the structure and should free any custom memory and resources
 613  * allocated for it.
 614  *
 615  * Keeping a pad locked in waiting state is only relevant when using
 616  * the default collection algorithm (providing the oldest buffer).
 617  * It ensures a buffer must be available on this pad for a collection
 618  * to take place.  This is of typical use to a muxer element where
 619  * non-subtitle streams should always be in waiting state,
 620  * e.g. to assure that caps information is available on all these streams
 621  * when initial headers have to be written.
 622  *
 623  * The pad will be automatically activated in push mode when @pads is
 624  * started.
 625  *
 626  * MT safe.
 627  *
 628  * Returns: (nullable) (transfer none): a new #GstCollectData to identify the
 629  *   new pad. Or %NULL if wrong parameters are supplied.
 630  */
 631 GstCollectData *
 632 gst_collect_pads_add_pad (GstCollectPads * pads, GstPad * pad, guint size,
 633     GstCollectDataDestroyNotify destroy_notify, gboolean lock)
 634 {
 635   GstCollectData *data;
 636 
 637   g_return_val_if_fail (pads != NULL, NULL);
 638   g_return_val_if_fail (GST_IS_COLLECT_PADS (pads), NULL);
 639   g_return_val_if_fail (pad != NULL, NULL);
 640   g_return_val_if_fail (GST_PAD_IS_SINK (pad), NULL);
 641   g_return_val_if_fail (size &gt;= sizeof (GstCollectData), NULL);
 642 
 643   GST_DEBUG_OBJECT (pads, &quot;adding pad %s:%s&quot;, GST_DEBUG_PAD_NAME (pad));
 644 
 645   data = g_malloc0 (size);
 646   data-&gt;priv = g_new0 (GstCollectDataPrivate, 1);
 647   data-&gt;collect = pads;
 648   data-&gt;pad = gst_object_ref (pad);
 649   data-&gt;buffer = NULL;
 650   data-&gt;pos = 0;
 651   gst_segment_init (&amp;data-&gt;segment, GST_FORMAT_UNDEFINED);
 652   data-&gt;state = GST_COLLECT_PADS_STATE_WAITING;
 653   data-&gt;state |= lock ? GST_COLLECT_PADS_STATE_LOCKED : 0;
 654   data-&gt;priv-&gt;refcount = 1;
 655   data-&gt;priv-&gt;destroy_notify = destroy_notify;
 656   data-&gt;ABI.abi.dts = G_MININT64;
 657 
 658   GST_OBJECT_LOCK (pads);
 659   GST_OBJECT_LOCK (pad);
 660   gst_pad_set_element_private (pad, data);
 661   GST_OBJECT_UNLOCK (pad);
 662   pads-&gt;priv-&gt;pad_list = g_slist_append (pads-&gt;priv-&gt;pad_list, data);
 663   gst_pad_set_chain_function (pad, GST_DEBUG_FUNCPTR (gst_collect_pads_chain));
 664   gst_pad_set_event_function (pad, GST_DEBUG_FUNCPTR (gst_collect_pads_event));
 665   gst_pad_set_query_function (pad, GST_DEBUG_FUNCPTR (gst_collect_pads_query));
 666   /* backward compat, also add to data if stopped, so that the element already
 667    * has this in the public data list before going PAUSED (typically)
 668    * this can only be done when we are stopped because we don&#39;t take the
 669    * STREAM_LOCK to protect the pads-&gt;data list. */
 670   if (!pads-&gt;priv-&gt;started) {
 671     pads-&gt;data = g_slist_append (pads-&gt;data, data);
 672     ref_data (data);
 673   }
 674   /* activate the pad when needed */
 675   if (pads-&gt;priv-&gt;started)
 676     gst_pad_set_active (pad, TRUE);
 677   pads-&gt;priv-&gt;pad_cookie++;
 678   GST_OBJECT_UNLOCK (pads);
 679 
 680   return data;
 681 }
 682 
 683 static gint
 684 find_pad (GstCollectData * data, GstPad * pad)
 685 {
 686   if (data-&gt;pad == pad)
 687     return 0;
 688   return 1;
 689 }
 690 
 691 /**
 692  * gst_collect_pads_remove_pad:
 693  * @pads: the collectpads to use
 694  * @pad: (transfer none): the pad to remove
 695  *
 696  * Remove a pad from the collection of collect pads. This function will also
 697  * free the #GstCollectData and all the resources that were allocated with
 698  * gst_collect_pads_add_pad().
 699  *
 700  * The pad will be deactivated automatically when @pads is stopped.
 701  *
 702  * MT safe.
 703  *
 704  * Returns: %TRUE if the pad could be removed.
 705  */
 706 gboolean
 707 gst_collect_pads_remove_pad (GstCollectPads * pads, GstPad * pad)
 708 {
 709   GstCollectData *data;
 710   GSList *list;
 711 
 712   g_return_val_if_fail (pads != NULL, FALSE);
 713   g_return_val_if_fail (GST_IS_COLLECT_PADS (pads), FALSE);
 714   g_return_val_if_fail (pad != NULL, FALSE);
 715   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
 716 
 717   GST_DEBUG_OBJECT (pads, &quot;removing pad %s:%s&quot;, GST_DEBUG_PAD_NAME (pad));
 718 
 719   GST_OBJECT_LOCK (pads);
 720   list =
 721       g_slist_find_custom (pads-&gt;priv-&gt;pad_list, pad, (GCompareFunc) find_pad);
 722   if (!list)
 723     goto unknown_pad;
 724 
 725   data = (GstCollectData *) list-&gt;data;
 726 
 727   GST_DEBUG_OBJECT (pads, &quot;found pad %s:%s at %p&quot;, GST_DEBUG_PAD_NAME (pad),
 728       data);
 729 
 730   /* clear the stuff we configured */
 731   gst_pad_set_chain_function (pad, NULL);
 732   gst_pad_set_event_function (pad, NULL);
 733   GST_OBJECT_LOCK (pad);
 734   gst_pad_set_element_private (pad, NULL);
 735   GST_OBJECT_UNLOCK (pad);
 736 
 737   /* backward compat, also remove from data if stopped, note that this function
 738    * can only be called when we are stopped because we don&#39;t take the
 739    * STREAM_LOCK to protect the pads-&gt;data list. */
 740   if (!pads-&gt;priv-&gt;started) {
 741     GSList *dlist;
 742 
 743     dlist = g_slist_find_custom (pads-&gt;data, pad, (GCompareFunc) find_pad);
 744     if (dlist) {
 745       GstCollectData *pdata = dlist-&gt;data;
 746 
 747       pads-&gt;data = g_slist_delete_link (pads-&gt;data, dlist);
 748       unref_data (pdata);
 749     }
 750   }
 751   /* remove from the pad list */
 752   pads-&gt;priv-&gt;pad_list = g_slist_delete_link (pads-&gt;priv-&gt;pad_list, list);
 753   pads-&gt;priv-&gt;pad_cookie++;
 754 
 755   /* signal waiters because something changed */
 756   GST_COLLECT_PADS_EVT_BROADCAST (pads);
 757 
 758   /* deactivate the pad when needed */
 759   if (!pads-&gt;priv-&gt;started)
 760     gst_pad_set_active (pad, FALSE);
 761 
 762   /* clean and free the collect data */
 763   unref_data (data);
 764 
 765   GST_OBJECT_UNLOCK (pads);
 766 
 767   return TRUE;
 768 
 769 unknown_pad:
 770   {
 771     GST_WARNING_OBJECT (pads, &quot;cannot remove unknown pad %s:%s&quot;,
 772         GST_DEBUG_PAD_NAME (pad));
 773     GST_OBJECT_UNLOCK (pads);
 774     return FALSE;
 775   }
 776 }
 777 
 778 /*
 779  * Must be called with STREAM_LOCK and OBJECT_LOCK.
 780  */
 781 static void
 782 gst_collect_pads_set_flushing_unlocked (GstCollectPads * pads,
 783     gboolean flushing)
 784 {
 785   GSList *walk = NULL;
 786 
 787   GST_DEBUG (&quot;sink-pads flushing=%d&quot;, flushing);
 788 
 789   /* Update the pads flushing flag */
 790   for (walk = pads-&gt;priv-&gt;pad_list; walk; walk = g_slist_next (walk)) {
 791     GstCollectData *cdata = walk-&gt;data;
 792 
 793     if (GST_IS_PAD (cdata-&gt;pad)) {
 794       GST_OBJECT_LOCK (cdata-&gt;pad);
 795       if (flushing)
 796         GST_PAD_SET_FLUSHING (cdata-&gt;pad);
 797       else
 798         GST_PAD_UNSET_FLUSHING (cdata-&gt;pad);
 799       if (flushing)
 800         GST_COLLECT_PADS_STATE_SET (cdata, GST_COLLECT_PADS_STATE_FLUSHING);
 801       else
 802         GST_COLLECT_PADS_STATE_UNSET (cdata, GST_COLLECT_PADS_STATE_FLUSHING);
 803       gst_collect_pads_clear (pads, cdata);
 804       GST_OBJECT_UNLOCK (cdata-&gt;pad);
 805     }
 806   }
 807 
 808   /* inform _chain of changes */
 809   GST_COLLECT_PADS_EVT_BROADCAST (pads);
 810 }
 811 
 812 /**
 813  * gst_collect_pads_set_flushing:
 814  * @pads: the collectpads to use
 815  * @flushing: desired state of the pads
 816  *
 817  * Change the flushing state of all the pads in the collection. No pad
 818  * is able to accept anymore data when @flushing is %TRUE. Calling this
 819  * function with @flushing %FALSE makes @pads accept data again.
 820  * Caller must ensure that downstream streaming (thread) is not blocked,
 821  * e.g. by sending a FLUSH_START downstream.
 822  *
 823  * MT safe.
 824  */
 825 void
 826 gst_collect_pads_set_flushing (GstCollectPads * pads, gboolean flushing)
 827 {
 828   g_return_if_fail (pads != NULL);
 829   g_return_if_fail (GST_IS_COLLECT_PADS (pads));
 830 
 831   /* NOTE since this eventually calls _pop, some (STREAM_)LOCK is needed here */
 832   GST_COLLECT_PADS_STREAM_LOCK (pads);
 833   GST_OBJECT_LOCK (pads);
 834   gst_collect_pads_set_flushing_unlocked (pads, flushing);
 835   GST_OBJECT_UNLOCK (pads);
 836   GST_COLLECT_PADS_STREAM_UNLOCK (pads);
 837 }
 838 
 839 /**
 840  * gst_collect_pads_start:
 841  * @pads: the collectpads to use
 842  *
 843  * Starts the processing of data in the collect_pads.
 844  *
 845  * MT safe.
 846  */
 847 void
 848 gst_collect_pads_start (GstCollectPads * pads)
 849 {
 850   GSList *collected;
 851 
 852   g_return_if_fail (pads != NULL);
 853   g_return_if_fail (GST_IS_COLLECT_PADS (pads));
 854 
 855   GST_DEBUG_OBJECT (pads, &quot;starting collect pads&quot;);
 856 
 857   /* make sure stop and collect cannot be called anymore */
 858   GST_COLLECT_PADS_STREAM_LOCK (pads);
 859 
 860   /* make pads streamable */
 861   GST_OBJECT_LOCK (pads);
 862 
 863   /* loop over the master pad list and reset the segment */
 864   collected = pads-&gt;priv-&gt;pad_list;
 865   for (; collected; collected = g_slist_next (collected)) {
 866     GstCollectData *data;
 867 
 868     data = collected-&gt;data;
 869     gst_segment_init (&amp;data-&gt;segment, GST_FORMAT_UNDEFINED);
 870   }
 871 
 872   gst_collect_pads_set_flushing_unlocked (pads, FALSE);
 873 
 874   /* Start collect pads */
 875   pads-&gt;priv-&gt;started = TRUE;
 876   GST_OBJECT_UNLOCK (pads);
 877   GST_COLLECT_PADS_STREAM_UNLOCK (pads);
 878 }
 879 
 880 /**
 881  * gst_collect_pads_stop:
 882  * @pads: the collectpads to use
 883  *
 884  * Stops the processing of data in the collect_pads. this function
 885  * will also unblock any blocking operations.
 886  *
 887  * MT safe.
 888  */
 889 void
 890 gst_collect_pads_stop (GstCollectPads * pads)
 891 {
 892   GSList *collected;
 893 
 894   g_return_if_fail (pads != NULL);
 895   g_return_if_fail (GST_IS_COLLECT_PADS (pads));
 896 
 897   GST_DEBUG_OBJECT (pads, &quot;stopping collect pads&quot;);
 898 
 899   /* make sure collect and start cannot be called anymore */
 900   GST_COLLECT_PADS_STREAM_LOCK (pads);
 901 
 902   /* make pads not accept data anymore */
 903   GST_OBJECT_LOCK (pads);
 904   gst_collect_pads_set_flushing_unlocked (pads, TRUE);
 905 
 906   /* Stop collect pads */
 907   pads-&gt;priv-&gt;started = FALSE;
 908   pads-&gt;priv-&gt;eospads = 0;
 909   pads-&gt;priv-&gt;queuedpads = 0;
 910 
 911   /* loop over the master pad list and flush buffers */
 912   collected = pads-&gt;priv-&gt;pad_list;
 913   for (; collected; collected = g_slist_next (collected)) {
 914     GstCollectData *data;
 915     GstBuffer **buffer_p;
 916 
 917     data = collected-&gt;data;
 918     if (data-&gt;buffer) {
 919       buffer_p = &amp;data-&gt;buffer;
 920       gst_buffer_replace (buffer_p, NULL);
 921       data-&gt;pos = 0;
 922     }
 923     GST_COLLECT_PADS_STATE_UNSET (data, GST_COLLECT_PADS_STATE_EOS);
 924   }
 925 
 926   if (pads-&gt;priv-&gt;earliest_data)
 927     unref_data (pads-&gt;priv-&gt;earliest_data);
 928   pads-&gt;priv-&gt;earliest_data = NULL;
 929   pads-&gt;priv-&gt;earliest_time = GST_CLOCK_TIME_NONE;
 930 
 931   GST_OBJECT_UNLOCK (pads);
 932   /* Wake them up so they can end the chain functions. */
 933   GST_COLLECT_PADS_EVT_BROADCAST (pads);
 934 
 935   GST_COLLECT_PADS_STREAM_UNLOCK (pads);
 936 }
 937 
 938 /**
 939  * gst_collect_pads_peek:
 940  * @pads: the collectpads to peek
 941  * @data: the data to use
 942  *
 943  * Peek at the buffer currently queued in @data. This function
 944  * should be called with the @pads STREAM_LOCK held, such as in the callback
 945  * handler.
 946  *
 947  * MT safe.
 948  *
 949  * Returns: (transfer full) (nullable): The buffer in @data or %NULL if no
 950  * buffer is queued. should unref the buffer after usage.
 951  */
 952 GstBuffer *
 953 gst_collect_pads_peek (GstCollectPads * pads, GstCollectData * data)
 954 {
 955   GstBuffer *result;
 956 
 957   g_return_val_if_fail (pads != NULL, NULL);
 958   g_return_val_if_fail (GST_IS_COLLECT_PADS (pads), NULL);
 959   g_return_val_if_fail (data != NULL, NULL);
 960 
 961   if ((result = data-&gt;buffer))
 962     gst_buffer_ref (result);
 963 
 964   GST_DEBUG_OBJECT (pads, &quot;Peeking at pad %s:%s: buffer=%&quot; GST_PTR_FORMAT,
 965       GST_DEBUG_PAD_NAME (data-&gt;pad), result);
 966 
 967   return result;
 968 }
 969 
 970 /**
 971  * gst_collect_pads_pop:
 972  * @pads: the collectpads to pop
 973  * @data: the data to use
 974  *
 975  * Pop the buffer currently queued in @data. This function
 976  * should be called with the @pads STREAM_LOCK held, such as in the callback
 977  * handler.
 978  *
 979  * MT safe.
 980  *
 981  * Returns: (transfer full) (nullable): The buffer in @data or %NULL if no
 982  * buffer was queued. You should unref the buffer after usage.
 983  */
 984 GstBuffer *
 985 gst_collect_pads_pop (GstCollectPads * pads, GstCollectData * data)
 986 {
 987   GstBuffer *result;
 988 
 989   g_return_val_if_fail (pads != NULL, NULL);
 990   g_return_val_if_fail (GST_IS_COLLECT_PADS (pads), NULL);
 991   g_return_val_if_fail (data != NULL, NULL);
 992 
 993   if ((result = data-&gt;buffer)) {
 994     data-&gt;buffer = NULL;
 995     data-&gt;pos = 0;
 996     /* one less pad with queued data now */
 997     if (GST_COLLECT_PADS_STATE_IS_SET (data, GST_COLLECT_PADS_STATE_WAITING))
 998       pads-&gt;priv-&gt;queuedpads--;
 999   }
1000 
1001   GST_COLLECT_PADS_EVT_BROADCAST (pads);
1002 
1003   GST_DEBUG_OBJECT (pads, &quot;Pop buffer on pad %s:%s: buffer=%&quot; GST_PTR_FORMAT,
1004       GST_DEBUG_PAD_NAME (data-&gt;pad), result);
1005 
1006   return result;
1007 }
1008 
1009 /* pop and unref the currently queued buffer, should be called with STREAM_LOCK
1010  * held */
1011 static void
1012 gst_collect_pads_clear (GstCollectPads * pads, GstCollectData * data)
1013 {
1014   GstBuffer *buf;
1015 
1016   if ((buf = gst_collect_pads_pop (pads, data)))
1017     gst_buffer_unref (buf);
1018 }
1019 
1020 /**
1021  * gst_collect_pads_available:
1022  * @pads: the collectpads to query
1023  *
1024  * Query how much bytes can be read from each queued buffer. This means
1025  * that the result of this call is the maximum number of bytes that can
1026  * be read from each of the pads.
1027  *
1028  * This function should be called with @pads STREAM_LOCK held, such as
1029  * in the callback.
1030  *
1031  * MT safe.
1032  *
1033  * Returns: The maximum number of bytes queued on all pads. This function
1034  * returns 0 if a pad has no queued buffer.
1035  */
1036 /* we might pre-calculate this in some struct field,
1037  * but would then have to maintain this in _chain and particularly _pop, etc,
1038  * even if element is never interested in this information */
1039 guint
1040 gst_collect_pads_available (GstCollectPads * pads)
1041 {
1042   GSList *collected;
1043   guint result = G_MAXUINT;
1044 
1045   g_return_val_if_fail (pads != NULL, 0);
1046   g_return_val_if_fail (GST_IS_COLLECT_PADS (pads), 0);
1047 
1048   collected = pads-&gt;data;
1049   for (; collected; collected = g_slist_next (collected)) {
1050     GstCollectData *pdata;
1051     GstBuffer *buffer;
1052     gint size;
1053 
1054     pdata = (GstCollectData *) collected-&gt;data;
1055 
1056     /* ignore pad with EOS */
1057     if (G_UNLIKELY (GST_COLLECT_PADS_STATE_IS_SET (pdata,
1058                 GST_COLLECT_PADS_STATE_EOS))) {
1059       GST_DEBUG_OBJECT (pads, &quot;pad %p is EOS&quot;, pdata);
1060       continue;
1061     }
1062 
1063     /* an empty buffer without EOS is weird when we get here.. */
1064     if (G_UNLIKELY ((buffer = pdata-&gt;buffer) == NULL)) {
1065       GST_WARNING_OBJECT (pads, &quot;pad %p has no buffer&quot;, pdata);
1066       goto not_filled;
1067     }
1068 
1069     /* this is the size left of the buffer */
1070     size = gst_buffer_get_size (buffer) - pdata-&gt;pos;
1071     GST_DEBUG_OBJECT (pads, &quot;pad %p has %d bytes left&quot;, pdata, size);
1072 
1073     /* need to return the min of all available data */
1074     if (size &lt; result)
1075       result = size;
1076   }
1077   /* nothing changed, all must be EOS then, return 0 */
1078   if (G_UNLIKELY (result == G_MAXUINT))
1079     result = 0;
1080 
1081   return result;
1082 
1083 not_filled:
1084   {
1085     return 0;
1086   }
1087 }
1088 
1089 /**
1090  * gst_collect_pads_flush:
1091  * @pads: the collectpads to query
1092  * @data: the data to use
1093  * @size: the number of bytes to flush
1094  *
1095  * Flush @size bytes from the pad @data.
1096  *
1097  * This function should be called with @pads STREAM_LOCK held, such as
1098  * in the callback.
1099  *
1100  * MT safe.
1101  *
1102  * Returns: The number of bytes flushed This can be less than @size and
1103  * is 0 if the pad was end-of-stream.
1104  */
1105 guint
1106 gst_collect_pads_flush (GstCollectPads * pads, GstCollectData * data,
1107     guint size)
1108 {
1109   guint flushsize;
1110   gsize bsize;
1111   GstBuffer *buffer;
1112 
1113   g_return_val_if_fail (pads != NULL, 0);
1114   g_return_val_if_fail (GST_IS_COLLECT_PADS (pads), 0);
1115   g_return_val_if_fail (data != NULL, 0);
1116 
1117   /* no buffer, must be EOS */
1118   if ((buffer = data-&gt;buffer) == NULL)
1119     return 0;
1120 
1121   bsize = gst_buffer_get_size (buffer);
1122 
1123   /* this is what we can flush at max */
1124   flushsize = MIN (size, bsize - data-&gt;pos);
1125 
1126   data-&gt;pos += size;
1127 
1128   if (data-&gt;pos &gt;= bsize)
1129     /* _clear will also reset data-&gt;pos to 0 */
1130     gst_collect_pads_clear (pads, data);
1131 
1132   return flushsize;
1133 }
1134 
1135 /**
1136  * gst_collect_pads_read_buffer:
1137  * @pads: the collectpads to query
1138  * @data: the data to use
1139  * @size: the number of bytes to read
1140  *
1141  * Get a subbuffer of @size bytes from the given pad @data.
1142  *
1143  * This function should be called with @pads STREAM_LOCK held, such as in the
1144  * callback.
1145  *
1146  * MT safe.
1147  *
1148  * Returns: (transfer full) (nullable): A sub buffer. The size of the buffer can
1149  * be less that requested. A return of %NULL signals that the pad is
1150  * end-of-stream. Unref the buffer after use.
1151  */
1152 GstBuffer *
1153 gst_collect_pads_read_buffer (GstCollectPads * pads, GstCollectData * data,
1154     guint size)
1155 {
1156   guint readsize, buf_size;
1157   GstBuffer *buffer;
1158 
1159   g_return_val_if_fail (pads != NULL, NULL);
1160   g_return_val_if_fail (GST_IS_COLLECT_PADS (pads), NULL);
1161   g_return_val_if_fail (data != NULL, NULL);
1162 
1163   /* no buffer, must be EOS */
1164   if ((buffer = data-&gt;buffer) == NULL)
1165     return NULL;
1166 
1167   buf_size = gst_buffer_get_size (buffer);
1168   readsize = MIN (size, buf_size - data-&gt;pos);
1169 
1170   return gst_buffer_copy_region (buffer, GST_BUFFER_COPY_ALL, data-&gt;pos,
1171       readsize);
1172 }
1173 
1174 /**
1175  * gst_collect_pads_take_buffer:
1176  * @pads: the collectpads to query
1177  * @data: the data to use
1178  * @size: the number of bytes to read
1179  *
1180  * Get a subbuffer of @size bytes from the given pad @data. Flushes the amount
1181  * of read bytes.
1182  *
1183  * This function should be called with @pads STREAM_LOCK held, such as in the
1184  * callback.
1185  *
1186  * MT safe.
1187  *
1188  * Returns: (transfer full) (nullable): A sub buffer. The size of the buffer can
1189  * be less that requested. A return of %NULL signals that the pad is
1190  * end-of-stream. Unref the buffer after use.
1191  */
1192 GstBuffer *
1193 gst_collect_pads_take_buffer (GstCollectPads * pads, GstCollectData * data,
1194     guint size)
1195 {
1196   GstBuffer *buffer = gst_collect_pads_read_buffer (pads, data, size);
1197 
1198   if (buffer) {
1199     gst_collect_pads_flush (pads, data, gst_buffer_get_size (buffer));
1200   }
1201   return buffer;
1202 }
1203 
1204 /**
1205  * gst_collect_pads_set_waiting:
1206  * @pads: the collectpads
1207  * @data: the data to use
1208  * @waiting: boolean indicating whether this pad should operate
1209  *           in waiting or non-waiting mode
1210  *
1211  * Sets a pad to waiting or non-waiting mode, if at least this pad
1212  * has not been created with locked waiting state,
1213  * in which case nothing happens.
1214  *
1215  * This function should be called with @pads STREAM_LOCK held, such as
1216  * in the callback.
1217  *
1218  * MT safe.
1219  */
1220 void
1221 gst_collect_pads_set_waiting (GstCollectPads * pads, GstCollectData * data,
1222     gboolean waiting)
1223 {
1224   g_return_if_fail (pads != NULL);
1225   g_return_if_fail (GST_IS_COLLECT_PADS (pads));
1226   g_return_if_fail (data != NULL);
1227 
1228   GST_DEBUG_OBJECT (pads, &quot;Setting pad %s to waiting %d, locked %d&quot;,
1229       GST_PAD_NAME (data-&gt;pad), waiting,
1230       GST_COLLECT_PADS_STATE_IS_SET (data, GST_COLLECT_PADS_STATE_LOCKED));
1231 
1232   /* Do something only on a change and if not locked */
1233   if (!GST_COLLECT_PADS_STATE_IS_SET (data, GST_COLLECT_PADS_STATE_LOCKED) &amp;&amp;
1234       (GST_COLLECT_PADS_STATE_IS_SET (data, GST_COLLECT_PADS_STATE_WAITING) !=
1235           ! !waiting)) {
1236     /* Set waiting state for this pad */
1237     if (waiting)
1238       GST_COLLECT_PADS_STATE_SET (data, GST_COLLECT_PADS_STATE_WAITING);
1239     else
1240       GST_COLLECT_PADS_STATE_UNSET (data, GST_COLLECT_PADS_STATE_WAITING);
1241     /* Update number of queued pads if needed */
1242     if (!data-&gt;buffer &amp;&amp;
1243         !GST_COLLECT_PADS_STATE_IS_SET (data, GST_COLLECT_PADS_STATE_EOS)) {
1244       if (waiting)
1245         pads-&gt;priv-&gt;queuedpads--;
1246       else
1247         pads-&gt;priv-&gt;queuedpads++;
1248     }
1249 
1250     /* signal waiters because something changed */
1251     GST_COLLECT_PADS_EVT_BROADCAST (pads);
1252   }
1253 }
1254 
1255 /* see if pads were added or removed and update our stats. Any pad
1256  * added after releasing the LOCK will get collected in the next
1257  * round.
1258  *
1259  * We can do a quick check by checking the cookies, that get changed
1260  * whenever the pad list is updated.
1261  *
1262  * Must be called with STREAM_LOCK.
1263  */
1264 static void
1265 gst_collect_pads_check_pads (GstCollectPads * pads)
1266 {
1267   /* the master list and cookie are protected with LOCK */
1268   GST_OBJECT_LOCK (pads);
1269   if (G_UNLIKELY (pads-&gt;priv-&gt;pad_cookie != pads-&gt;priv-&gt;cookie)) {
1270     GSList *collected;
1271 
1272     /* clear list and stats */
1273     g_slist_foreach (pads-&gt;data, (GFunc) unref_data, NULL);
1274     g_slist_free (pads-&gt;data);
1275     pads-&gt;data = NULL;
1276     pads-&gt;priv-&gt;numpads = 0;
1277     pads-&gt;priv-&gt;queuedpads = 0;
1278     pads-&gt;priv-&gt;eospads = 0;
1279     if (pads-&gt;priv-&gt;earliest_data)
1280       unref_data (pads-&gt;priv-&gt;earliest_data);
1281     pads-&gt;priv-&gt;earliest_data = NULL;
1282     pads-&gt;priv-&gt;earliest_time = GST_CLOCK_TIME_NONE;
1283 
1284     /* loop over the master pad list */
1285     collected = pads-&gt;priv-&gt;pad_list;
1286     for (; collected; collected = g_slist_next (collected)) {
1287       GstCollectData *data;
1288 
1289       /* update the stats */
1290       pads-&gt;priv-&gt;numpads++;
1291       data = collected-&gt;data;
1292       if (GST_COLLECT_PADS_STATE_IS_SET (data, GST_COLLECT_PADS_STATE_EOS))
1293         pads-&gt;priv-&gt;eospads++;
1294       else if (data-&gt;buffer || !GST_COLLECT_PADS_STATE_IS_SET (data,
1295               GST_COLLECT_PADS_STATE_WAITING))
1296         pads-&gt;priv-&gt;queuedpads++;
1297 
1298       /* add to the list of pads to collect */
1299       ref_data (data);
1300       /* preserve order of adding/requesting pads */
1301       pads-&gt;data = g_slist_append (pads-&gt;data, data);
1302     }
1303     /* and update the cookie */
1304     pads-&gt;priv-&gt;cookie = pads-&gt;priv-&gt;pad_cookie;
1305   }
1306   GST_OBJECT_UNLOCK (pads);
1307 }
1308 
1309 /* checks if all the pads are collected and call the collectfunction
1310  *
1311  * Should be called with STREAM_LOCK.
1312  *
1313  * Returns: The #GstFlowReturn of collection.
1314  */
1315 static GstFlowReturn
1316 gst_collect_pads_check_collected (GstCollectPads * pads)
1317 {
1318   GstFlowReturn flow_ret = GST_FLOW_OK;
1319   GstCollectPadsFunction func;
1320   gpointer user_data;
1321 
1322   g_return_val_if_fail (GST_IS_COLLECT_PADS (pads), GST_FLOW_ERROR);
1323 
1324   GST_OBJECT_LOCK (pads);
1325   func = pads-&gt;priv-&gt;func;
1326   user_data = pads-&gt;priv-&gt;user_data;
1327   GST_OBJECT_UNLOCK (pads);
1328 
1329   g_return_val_if_fail (pads-&gt;priv-&gt;func != NULL, GST_FLOW_NOT_SUPPORTED);
1330 
1331   /* check for new pads, update stats etc.. */
1332   gst_collect_pads_check_pads (pads);
1333 
1334   if (G_UNLIKELY (pads-&gt;priv-&gt;eospads == pads-&gt;priv-&gt;numpads)) {
1335     /* If all our pads are EOS just collect once to let the element
1336      * do its final EOS handling. */
1337     GST_DEBUG_OBJECT (pads, &quot;All active pads (%d) are EOS, calling %s&quot;,
1338         pads-&gt;priv-&gt;numpads, GST_DEBUG_FUNCPTR_NAME (func));
1339 
1340     if (G_UNLIKELY (g_atomic_int_compare_and_exchange (&amp;pads-&gt;priv-&gt;seeking,
1341                 TRUE, FALSE))) {
1342       GST_INFO_OBJECT (pads, &quot;finished seeking&quot;);
1343     }
1344     do {
1345       flow_ret = func (pads, user_data);
1346     } while (flow_ret == GST_FLOW_OK);
1347   } else {
1348     gboolean collected = FALSE;
1349 
1350     /* We call the collected function as long as our condition matches. */
1351     while (((pads-&gt;priv-&gt;queuedpads + pads-&gt;priv-&gt;eospads) &gt;=
1352             pads-&gt;priv-&gt;numpads)) {
1353       GST_DEBUG_OBJECT (pads,
1354           &quot;All active pads (%d + %d &gt;= %d) have data, &quot; &quot;calling %s&quot;,
1355           pads-&gt;priv-&gt;queuedpads, pads-&gt;priv-&gt;eospads, pads-&gt;priv-&gt;numpads,
1356           GST_DEBUG_FUNCPTR_NAME (func));
1357 
1358       if (G_UNLIKELY (g_atomic_int_compare_and_exchange (&amp;pads-&gt;priv-&gt;seeking,
1359                   TRUE, FALSE))) {
1360         GST_INFO_OBJECT (pads, &quot;finished seeking&quot;);
1361       }
1362       flow_ret = func (pads, user_data);
1363       collected = TRUE;
1364 
1365       /* break on error */
1366       if (flow_ret != GST_FLOW_OK)
1367         break;
1368       /* Don&#39;t keep looping after telling the element EOS or flushing */
1369       if (pads-&gt;priv-&gt;queuedpads == 0)
1370         break;
1371     }
1372     if (!collected)
1373       GST_DEBUG_OBJECT (pads, &quot;Not all active pads (%d) have data, continuing&quot;,
1374           pads-&gt;priv-&gt;numpads);
1375   }
1376   return flow_ret;
1377 }
1378 
1379 
1380 /* General overview:
1381  * - only pad with a buffer can determine earliest_data (and earliest_time)
1382  * - only segment info determines (non-)waiting state
1383  * - ? perhaps use _stream_time for comparison
1384  *   (which muxers might have use as well ?)
1385  */
1386 
1387 /*
1388  * Function to recalculate the waiting state of all pads.
1389  *
1390  * Must be called with STREAM_LOCK.
1391  *
1392  * Returns %TRUE if a pad was set to waiting
1393  * (from non-waiting state).
1394  */
1395 static gboolean
1396 gst_collect_pads_recalculate_waiting (GstCollectPads * pads)
1397 {
1398   GSList *collected;
1399   gboolean result = FALSE;
1400 
1401   /* If earliest time is not known, there is nothing to do. */
1402   if (pads-&gt;priv-&gt;earliest_data == NULL)
1403     return FALSE;
1404 
1405   for (collected = pads-&gt;data; collected; collected = g_slist_next (collected)) {
1406     GstCollectData *data = (GstCollectData *) collected-&gt;data;
1407     int cmp_res;
1408     GstClockTime comp_time;
1409 
1410     /* check if pad has a segment */
1411     if (data-&gt;segment.format == GST_FORMAT_UNDEFINED) {
1412       GST_WARNING_OBJECT (pads,
1413           &quot;GstCollectPads has no time segment, assuming 0 based.&quot;);
1414       gst_segment_init (&amp;data-&gt;segment, GST_FORMAT_TIME);
1415       GST_COLLECT_PADS_STATE_SET (data, GST_COLLECT_PADS_STATE_NEW_SEGMENT);
1416     }
1417 
1418     /* check segment format */
1419     if (data-&gt;segment.format != GST_FORMAT_TIME) {
1420       GST_ERROR_OBJECT (pads, &quot;GstCollectPads can handle only time segments.&quot;);
1421       continue;
1422     }
1423 
1424     /* check if the waiting state should be changed */
1425     comp_time = data-&gt;segment.position;
1426     cmp_res = pads-&gt;priv-&gt;compare_func (pads, data, comp_time,
1427         pads-&gt;priv-&gt;earliest_data, pads-&gt;priv-&gt;earliest_time,
1428         pads-&gt;priv-&gt;compare_user_data);
1429     if (cmp_res &gt; 0)
1430       /* stop waiting */
1431       gst_collect_pads_set_waiting (pads, data, FALSE);
1432     else {
1433       if (!GST_COLLECT_PADS_STATE_IS_SET (data, GST_COLLECT_PADS_STATE_WAITING)) {
1434         /* start waiting */
1435         gst_collect_pads_set_waiting (pads, data, TRUE);
1436         result = TRUE;
1437       }
1438     }
1439   }
1440 
1441   return result;
1442 }
1443 
1444 /**
1445  * gst_collect_pads_find_best_pad:
1446  * @pads: the collectpads to use
1447  * @data: returns the collectdata for earliest data
1448  * @time: returns the earliest available buffertime
1449  *
1450  * Find the oldest/best pad, i.e. pad holding the oldest buffer and
1451  * and return the corresponding #GstCollectData and buffertime.
1452  *
1453  * This function should be called with STREAM_LOCK held,
1454  * such as in the callback.
1455  */
1456 static void
1457 gst_collect_pads_find_best_pad (GstCollectPads * pads,
1458     GstCollectData ** data, GstClockTime * time)
1459 {
1460   GSList *collected;
1461   GstCollectData *best = NULL;
1462   GstClockTime best_time = GST_CLOCK_TIME_NONE;
1463 
1464   g_return_if_fail (data != NULL);
1465   g_return_if_fail (time != NULL);
1466 
1467   for (collected = pads-&gt;data; collected; collected = g_slist_next (collected)) {
1468     GstBuffer *buffer;
1469     GstCollectData *data = (GstCollectData *) collected-&gt;data;
1470     GstClockTime timestamp;
1471 
1472     buffer = gst_collect_pads_peek (pads, data);
1473     /* if we have a buffer check if it is better then the current best one */
1474     if (buffer != NULL) {
1475       timestamp = GST_BUFFER_DTS_OR_PTS (buffer);
1476       gst_buffer_unref (buffer);
1477       if (best == NULL || pads-&gt;priv-&gt;compare_func (pads, data, timestamp,
1478               best, best_time, pads-&gt;priv-&gt;compare_user_data) &lt; 0) {
1479         best = data;
1480         best_time = timestamp;
1481       }
1482     }
1483   }
1484 
1485   /* set earliest time */
1486   *data = best;
1487   *time = best_time;
1488 
1489   GST_DEBUG_OBJECT (pads, &quot;best pad %s, best time %&quot; GST_TIME_FORMAT,
1490       best ? GST_PAD_NAME (((GstCollectData *) best)-&gt;pad) : &quot;(nil)&quot;,
1491       GST_TIME_ARGS (best_time));
1492 }
1493 
1494 /*
1495  * Function to recalculate earliest_data and earliest_timestamp. This also calls
1496  * gst_collect_pads_recalculate_waiting
1497  *
1498  * Must be called with STREAM_LOCK.
1499  */
1500 static gboolean
1501 gst_collect_pads_recalculate_full (GstCollectPads * pads)
1502 {
1503   if (pads-&gt;priv-&gt;earliest_data)
1504     unref_data (pads-&gt;priv-&gt;earliest_data);
1505   gst_collect_pads_find_best_pad (pads, &amp;pads-&gt;priv-&gt;earliest_data,
1506       &amp;pads-&gt;priv-&gt;earliest_time);
1507   if (pads-&gt;priv-&gt;earliest_data)
1508     ref_data (pads-&gt;priv-&gt;earliest_data);
1509   return gst_collect_pads_recalculate_waiting (pads);
1510 }
1511 
1512 /*
1513  * Default collect callback triggered when #GstCollectPads gathered all data.
1514  *
1515  * Called with STREAM_LOCK.
1516  */
1517 static GstFlowReturn
1518 gst_collect_pads_default_collected (GstCollectPads * pads, gpointer user_data)
1519 {
1520   GstCollectData *best = NULL;
1521   GstBuffer *buffer;
1522   GstFlowReturn ret = GST_FLOW_OK;
1523   GstCollectPadsBufferFunction func;
1524   gpointer buffer_user_data;
1525 
1526   g_return_val_if_fail (GST_IS_COLLECT_PADS (pads), GST_FLOW_ERROR);
1527 
1528   GST_OBJECT_LOCK (pads);
1529   func = pads-&gt;priv-&gt;buffer_func;
1530   buffer_user_data = pads-&gt;priv-&gt;buffer_user_data;
1531   GST_OBJECT_UNLOCK (pads);
1532 
1533   g_return_val_if_fail (func != NULL, GST_FLOW_NOT_SUPPORTED);
1534 
1535   /* Find the oldest pad at all cost */
1536   if (gst_collect_pads_recalculate_full (pads)) {
1537     /* waiting was switched on,
1538      * so give another thread a chance to deliver a possibly
1539      * older buffer; don&#39;t charge on yet with the current oldest */
1540     ret = GST_FLOW_OK;
1541     goto done;
1542   }
1543 
1544   best = pads-&gt;priv-&gt;earliest_data;
1545 
1546   /* No data collected means EOS. */
1547   if (G_UNLIKELY (best == NULL)) {
1548     ret = func (pads, best, NULL, buffer_user_data);
1549     if (ret == GST_FLOW_OK)
1550       ret = GST_FLOW_EOS;
1551     goto done;
1552   }
1553 
1554   /* make sure that the pad we take a buffer from is waiting;
1555    * otherwise popping a buffer will seem not to have happened
1556    * and collectpads can get into a busy loop */
1557   gst_collect_pads_set_waiting (pads, best, TRUE);
1558 
1559   /* Send buffer */
1560   buffer = gst_collect_pads_pop (pads, best);
1561   ret = func (pads, best, buffer, buffer_user_data);
1562 
1563   /* maybe non-waiting was forced to waiting above due to
1564    * newsegment events coming too sparsely,
1565    * so re-check to restore state to avoid hanging/waiting */
1566   gst_collect_pads_recalculate_full (pads);
1567 
1568 done:
1569   return ret;
1570 }
1571 
1572 /*
1573  * Default timestamp compare function.
1574  */
1575 static gint
1576 gst_collect_pads_default_compare_func (GstCollectPads * pads,
1577     GstCollectData * data1, GstClockTime timestamp1,
1578     GstCollectData * data2, GstClockTime timestamp2, gpointer user_data)
1579 {
1580 
1581   GST_LOG_OBJECT (pads, &quot;comparing %&quot; GST_TIME_FORMAT
1582       &quot; and %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (timestamp1),
1583       GST_TIME_ARGS (timestamp2));
1584   /* non-valid timestamps go first as they are probably headers or so */
1585   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (timestamp1)))
1586     return GST_CLOCK_TIME_IS_VALID (timestamp2) ? -1 : 0;
1587 
1588   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (timestamp2)))
1589     return 1;
1590 
1591   /* compare timestamp */
1592   if (timestamp1 &lt; timestamp2)
1593     return -1;
1594 
1595   if (timestamp1 &gt; timestamp2)
1596     return 1;
1597 
1598   return 0;
1599 }
1600 
1601 /* called with STREAM_LOCK */
1602 static void
1603 gst_collect_pads_handle_position_update (GstCollectPads * pads,
1604     GstCollectData * data, GstClockTime new_pos)
1605 {
1606   gint cmp_res;
1607 
1608   /* If oldest time is not known, or current pad got newsegment;
1609    * recalculate the state */
1610   if (!pads-&gt;priv-&gt;earliest_data || pads-&gt;priv-&gt;earliest_data == data) {
1611     gst_collect_pads_recalculate_full (pads);
1612     goto exit;
1613   }
1614 
1615   /* Check if the waiting state of the pad should change. */
1616   cmp_res =
1617       pads-&gt;priv-&gt;compare_func (pads, data, new_pos,
1618       pads-&gt;priv-&gt;earliest_data, pads-&gt;priv-&gt;earliest_time,
1619       pads-&gt;priv-&gt;compare_user_data);
1620 
1621   if (cmp_res &gt; 0)
1622     /* Stop waiting */
1623     gst_collect_pads_set_waiting (pads, data, FALSE);
1624 
1625 exit:
1626   return;
1627 
1628 }
1629 
1630 static GstClockTime
1631 gst_collect_pads_clip_time (GstCollectPads * pads, GstCollectData * data,
1632     GstClockTime time)
1633 {
1634   GstClockTime otime = time;
1635   GstBuffer *in, *out = NULL;
1636 
1637   if (pads-&gt;priv-&gt;clip_func) {
1638     in = gst_buffer_new ();
1639     GST_BUFFER_PTS (in) = time;
1640     GST_BUFFER_DTS (in) = GST_CLOCK_TIME_NONE;
1641     pads-&gt;priv-&gt;clip_func (pads, data, in, &amp;out, pads-&gt;priv-&gt;clip_user_data);
1642     if (out) {
1643       otime = GST_BUFFER_PTS (out);
1644       gst_buffer_unref (out);
1645     } else {
1646       /* FIXME should distinguish between ahead or after segment,
1647        * let&#39;s assume after segment and use some large time ... */
1648       otime = G_MAXINT64 / 2;
1649     }
1650   }
1651 
1652   return otime;
1653 }
1654 
1655 /**
1656  * gst_collect_pads_event_default:
1657  * @pads: the collectpads to use
1658  * @data: collect data of corresponding pad
1659  * @event: event being processed
1660  * @discard: process but do not send event downstream
1661  *
1662  * Default #GstCollectPads event handling that elements should always
1663  * chain up to to ensure proper operation.  Element might however indicate
1664  * event should not be forwarded downstream.
1665  */
1666 gboolean
1667 gst_collect_pads_event_default (GstCollectPads * pads, GstCollectData * data,
1668     GstEvent * event, gboolean discard)
1669 {
1670   gboolean res = TRUE;
1671   GstCollectPadsBufferFunction buffer_func;
1672   GstObject *parent;
1673   GstPad *pad;
1674 
1675   GST_OBJECT_LOCK (pads);
1676   buffer_func = pads-&gt;priv-&gt;buffer_func;
1677   GST_OBJECT_UNLOCK (pads);
1678 
1679   pad = data-&gt;pad;
1680   parent = GST_OBJECT_PARENT (pad);
1681 
1682   GST_DEBUG_OBJECT (pad, &quot;Got &#39;%s&#39; event&quot;, GST_EVENT_TYPE_NAME (event));
1683 
1684   switch (GST_EVENT_TYPE (event)) {
1685     case GST_EVENT_FLUSH_START:
1686     {
1687       if (g_atomic_int_get (&amp;pads-&gt;priv-&gt;seeking)) {
1688         /* drop all but the first FLUSH_STARTs when seeking */
1689         if (!g_atomic_int_compare_and_exchange (&amp;pads-&gt;
1690                 priv-&gt;pending_flush_start, TRUE, FALSE))
1691           goto eat;
1692 
1693         /* unblock collect pads */
1694         gst_pad_event_default (pad, parent, event);
1695         event = NULL;
1696 
1697         GST_COLLECT_PADS_STREAM_LOCK (pads);
1698         /* Start flushing. We never call gst_collect_pads_set_flushing (FALSE), we
1699          * instead wait until each pad gets its FLUSH_STOP and let that reset the pad to
1700          * non-flushing (which happens in gst_collect_pads_event_default).
1701          */
1702         gst_collect_pads_set_flushing (pads, TRUE);
1703 
1704         if (pads-&gt;priv-&gt;flush_func)
1705           pads-&gt;priv-&gt;flush_func (pads, pads-&gt;priv-&gt;flush_user_data);
1706 
1707         g_atomic_int_set (&amp;pads-&gt;priv-&gt;pending_flush_stop, TRUE);
1708         GST_COLLECT_PADS_STREAM_UNLOCK (pads);
1709 
1710         goto eat;
1711       } else {
1712         /* forward event to unblock check_collected */
1713         GST_DEBUG_OBJECT (pad, &quot;forwarding flush start&quot;);
1714         if (!(res = gst_pad_event_default (pad, parent, event))) {
1715           GST_WARNING_OBJECT (pad, &quot;forwarding flush start failed&quot;);
1716         }
1717         event = NULL;
1718 
1719         /* now unblock the chain function.
1720          * no cond per pad, so they all unblock,
1721          * non-flushing block again */
1722         GST_COLLECT_PADS_STREAM_LOCK (pads);
1723         GST_COLLECT_PADS_STATE_SET (data, GST_COLLECT_PADS_STATE_FLUSHING);
1724         gst_collect_pads_clear (pads, data);
1725 
1726         /* cater for possible default muxing functionality */
1727         if (buffer_func) {
1728           /* restore to initial state */
1729           gst_collect_pads_set_waiting (pads, data, TRUE);
1730           /* if the current pad is affected, reset state, recalculate later */
1731           if (pads-&gt;priv-&gt;earliest_data == data) {
1732             unref_data (data);
1733             pads-&gt;priv-&gt;earliest_data = NULL;
1734             pads-&gt;priv-&gt;earliest_time = GST_CLOCK_TIME_NONE;
1735           }
1736         }
1737 
1738         GST_COLLECT_PADS_STREAM_UNLOCK (pads);
1739 
1740         goto eat;
1741       }
1742     }
1743     case GST_EVENT_FLUSH_STOP:
1744     {
1745       /* flush the 1 buffer queue */
1746       GST_COLLECT_PADS_STREAM_LOCK (pads);
1747       GST_COLLECT_PADS_STATE_UNSET (data, GST_COLLECT_PADS_STATE_FLUSHING);
1748       gst_collect_pads_clear (pads, data);
1749       /* we need new segment info after the flush */
1750       gst_segment_init (&amp;data-&gt;segment, GST_FORMAT_UNDEFINED);
1751       GST_COLLECT_PADS_STATE_UNSET (data, GST_COLLECT_PADS_STATE_NEW_SEGMENT);
1752       /* if the pad was EOS, remove the EOS flag and
1753        * decrement the number of eospads */
1754       if (G_UNLIKELY (GST_COLLECT_PADS_STATE_IS_SET (data,
1755                   GST_COLLECT_PADS_STATE_EOS))) {
1756         if (!GST_COLLECT_PADS_STATE_IS_SET (data,
1757                 GST_COLLECT_PADS_STATE_WAITING))
1758           pads-&gt;priv-&gt;queuedpads++;
1759         if (!g_atomic_int_get (&amp;pads-&gt;priv-&gt;seeking)) {
1760           pads-&gt;priv-&gt;eospads--;
1761         }
1762         GST_COLLECT_PADS_STATE_UNSET (data, GST_COLLECT_PADS_STATE_EOS);
1763       }
1764       GST_COLLECT_PADS_STREAM_UNLOCK (pads);
1765 
1766       if (g_atomic_int_get (&amp;pads-&gt;priv-&gt;seeking)) {
1767         if (g_atomic_int_compare_and_exchange (&amp;pads-&gt;priv-&gt;pending_flush_stop,
1768                 TRUE, FALSE))
1769           goto forward;
1770         else
1771           goto eat;
1772       } else {
1773         goto forward;
1774       }
1775     }
1776     case GST_EVENT_EOS:
1777     {
1778       GST_COLLECT_PADS_STREAM_LOCK (pads);
1779       /* if the pad was not EOS, make it EOS and so we
1780        * have one more eospad */
1781       if (G_LIKELY (!GST_COLLECT_PADS_STATE_IS_SET (data,
1782                   GST_COLLECT_PADS_STATE_EOS))) {
1783         GST_COLLECT_PADS_STATE_SET (data, GST_COLLECT_PADS_STATE_EOS);
1784         if (!GST_COLLECT_PADS_STATE_IS_SET (data,
1785                 GST_COLLECT_PADS_STATE_WAITING))
1786           pads-&gt;priv-&gt;queuedpads--;
1787         pads-&gt;priv-&gt;eospads++;
1788       }
1789       /* check if we need collecting anything, we ignore the result. */
1790       gst_collect_pads_check_collected (pads);
1791       GST_COLLECT_PADS_STREAM_UNLOCK (pads);
1792 
1793       goto eat;
1794     }
1795     case GST_EVENT_SEGMENT:
1796     {
1797       GstSegment seg;
1798 
1799       GST_COLLECT_PADS_STREAM_LOCK (pads);
1800 
1801       gst_event_copy_segment (event, &amp;seg);
1802 
1803       GST_DEBUG_OBJECT (data-&gt;pad, &quot;got segment %&quot; GST_SEGMENT_FORMAT, &amp;seg);
1804 
1805       /* default collection can not handle other segment formats than time */
1806       if (buffer_func &amp;&amp; seg.format != GST_FORMAT_TIME) {
1807         GST_WARNING_OBJECT (pads, &quot;GstCollectPads default collecting &quot;
1808             &quot;can only handle time segments. Non time segment ignored.&quot;);
1809         goto newsegment_done;
1810       }
1811 
1812       /* need to update segment first */
1813       data-&gt;segment = seg;
1814       GST_COLLECT_PADS_STATE_SET (data, GST_COLLECT_PADS_STATE_NEW_SEGMENT);
1815 
1816       /* now we can use for e.g. running time */
1817       seg.position =
1818           gst_collect_pads_clip_time (pads, data, seg.start + seg.offset);
1819       /* update again */
1820       data-&gt;segment = seg;
1821 
1822       /* default muxing functionality */
1823       if (!buffer_func)
1824         goto newsegment_done;
1825 
1826       gst_collect_pads_handle_position_update (pads, data, seg.position);
1827 
1828     newsegment_done:
1829       GST_COLLECT_PADS_STREAM_UNLOCK (pads);
1830       /* we must not forward this event since multiple segments will be
1831        * accumulated and this is certainly not what we want. */
1832       goto eat;
1833     }
1834     case GST_EVENT_GAP:
1835     {
1836       GstClockTime start, duration;
1837 
1838       GST_COLLECT_PADS_STREAM_LOCK (pads);
1839 
1840       gst_event_parse_gap (event, &amp;start, &amp;duration);
1841       /* FIXME, handle reverse playback case */
1842       if (GST_CLOCK_TIME_IS_VALID (duration))
1843         start += duration;
1844       /* we do not expect another buffer until after gap,
1845        * so that is our position now */
1846       data-&gt;segment.position = gst_collect_pads_clip_time (pads, data, start);
1847 
1848       gst_collect_pads_handle_position_update (pads, data,
1849           data-&gt;segment.position);
1850 
1851       GST_COLLECT_PADS_STREAM_UNLOCK (pads);
1852       goto eat;
1853     }
1854     case GST_EVENT_STREAM_START:
1855       /* drop stream start events, element must create its own start event,
1856        * we can&#39;t just forward the first random stream start event we get */
1857       goto eat;
1858     case GST_EVENT_CAPS:
1859       goto eat;
1860     default:
1861       /* forward other events */
1862       goto forward;
1863   }
1864 
1865 eat:
1866   GST_DEBUG_OBJECT (pads, &quot;dropping event: %&quot; GST_PTR_FORMAT, event);
1867   if (event)
1868     gst_event_unref (event);
1869   return res;
1870 
1871 forward:
1872   if (discard)
1873     goto eat;
1874   else {
1875     GST_DEBUG_OBJECT (pads, &quot;forward event: %&quot; GST_PTR_FORMAT, event);
1876     return gst_pad_event_default (pad, parent, event);
1877   }
1878 }
1879 
1880 typedef struct
1881 {
1882   GstEvent *event;
1883   gboolean result;
1884 } EventData;
1885 
1886 static gboolean
1887 event_forward_func (GstPad * pad, EventData * data)
1888 {
1889   gboolean ret = TRUE;
1890   GstPad *peer = gst_pad_get_peer (pad);
1891 
1892   if (peer) {
1893     ret = gst_pad_send_event (peer, gst_event_ref (data-&gt;event));
1894     gst_object_unref (peer);
1895   }
1896 
1897   data-&gt;result &amp;= ret;
1898   /* Always send to all pads */
1899   return FALSE;
1900 }
1901 
1902 static gboolean
1903 forward_event_to_all_sinkpads (GstPad * srcpad, GstEvent * event)
1904 {
1905   EventData data;
1906 
1907   data.event = event;
1908   data.result = TRUE;
1909 
1910   gst_pad_forward (srcpad, (GstPadForwardFunction) event_forward_func, &amp;data);
1911 
1912   gst_event_unref (event);
1913 
1914   return data.result;
1915 }
1916 
1917 /**
1918  * gst_collect_pads_src_event_default:
1919  * @pads: the #GstCollectPads to use
1920  * @pad: src #GstPad that received the event
1921  * @event: event being processed
1922  *
1923  * Default #GstCollectPads event handling for the src pad of elements.
1924  * Elements can chain up to this to let flushing seek event handling
1925  * be done by #GstCollectPads.
1926  *
1927  * Since: 1.4
1928  */
1929 gboolean
1930 gst_collect_pads_src_event_default (GstCollectPads * pads, GstPad * pad,
1931     GstEvent * event)
1932 {
1933   GstObject *parent;
1934   gboolean res = TRUE;
1935 
1936   parent = GST_OBJECT_PARENT (pad);
1937 
1938   switch (GST_EVENT_TYPE (event)) {
1939     case GST_EVENT_SEEK:{
1940       GstSeekFlags flags;
1941 
1942       pads-&gt;priv-&gt;eospads = 0;
1943 
1944       GST_INFO_OBJECT (pads, &quot;starting seek&quot;);
1945 
1946       gst_event_parse_seek (event, NULL, NULL, &amp;flags, NULL, NULL, NULL, NULL);
1947       if (flags &amp; GST_SEEK_FLAG_FLUSH) {
1948         g_atomic_int_set (&amp;pads-&gt;priv-&gt;seeking, TRUE);
1949         g_atomic_int_set (&amp;pads-&gt;priv-&gt;pending_flush_start, TRUE);
1950         /* forward the seek upstream */
1951         res = forward_event_to_all_sinkpads (pad, event);
1952         event = NULL;
1953         if (!res) {
1954           g_atomic_int_set (&amp;pads-&gt;priv-&gt;seeking, FALSE);
1955           g_atomic_int_set (&amp;pads-&gt;priv-&gt;pending_flush_start, FALSE);
1956         }
1957       }
1958 
1959       GST_INFO_OBJECT (pads, &quot;seek done, result: %d&quot;, res);
1960 
1961       break;
1962     }
1963     default:
1964       break;
1965   }
1966 
1967   if (event)
1968     res = gst_pad_event_default (pad, parent, event);
1969 
1970   return res;
1971 }
1972 
1973 static gboolean
1974 gst_collect_pads_event_default_internal (GstCollectPads * pads,
1975     GstCollectData * data, GstEvent * event, gpointer user_data)
1976 {
1977   return gst_collect_pads_event_default (pads, data, event, FALSE);
1978 }
1979 
1980 static gboolean
1981 gst_collect_pads_event (GstPad * pad, GstObject * parent, GstEvent * event)
1982 {
1983   gboolean res = FALSE, need_unlock = FALSE;
1984   GstCollectData *data;
1985   GstCollectPads *pads;
1986   GstCollectPadsEventFunction event_func;
1987   gpointer event_user_data;
1988 
1989   /* some magic to get the managing collect_pads */
1990   GST_OBJECT_LOCK (pad);
1991   data = (GstCollectData *) gst_pad_get_element_private (pad);
1992   if (G_UNLIKELY (data == NULL))
1993     goto pad_removed;
1994   ref_data (data);
1995   GST_OBJECT_UNLOCK (pad);
1996 
1997   res = FALSE;
1998 
1999   pads = data-&gt;collect;
2000 
2001   GST_DEBUG_OBJECT (data-&gt;pad, &quot;Got %s event on sink pad&quot;,
2002       GST_EVENT_TYPE_NAME (event));
2003 
2004   GST_OBJECT_LOCK (pads);
2005   event_func = pads-&gt;priv-&gt;event_func;
2006   event_user_data = pads-&gt;priv-&gt;event_user_data;
2007   GST_OBJECT_UNLOCK (pads);
2008 
2009   if (GST_EVENT_IS_SERIALIZED (event)) {
2010     GST_COLLECT_PADS_STREAM_LOCK (pads);
2011     need_unlock = TRUE;
2012   }
2013 
2014   if (G_LIKELY (event_func)) {
2015     res = event_func (pads, data, event, event_user_data);
2016   }
2017 
2018   if (need_unlock)
2019     GST_COLLECT_PADS_STREAM_UNLOCK (pads);
2020 
2021   unref_data (data);
2022   return res;
2023 
2024   /* ERRORS */
2025 pad_removed:
2026   {
2027     GST_DEBUG (&quot;%s got removed from collectpads&quot;, GST_OBJECT_NAME (pad));
2028     GST_OBJECT_UNLOCK (pad);
2029     return FALSE;
2030   }
2031 }
2032 
2033 /**
2034  * gst_collect_pads_query_default:
2035  * @pads: the collectpads to use
2036  * @data: collect data of corresponding pad
2037  * @query: query being processed
2038  * @discard: process but do not send event downstream
2039  *
2040  * Default #GstCollectPads query handling that elements should always
2041  * chain up to to ensure proper operation.  Element might however indicate
2042  * query should not be forwarded downstream.
2043  */
2044 gboolean
2045 gst_collect_pads_query_default (GstCollectPads * pads, GstCollectData * data,
2046     GstQuery * query, gboolean discard)
2047 {
2048   gboolean res = TRUE;
2049   GstObject *parent;
2050   GstPad *pad;
2051 
2052   pad = data-&gt;pad;
2053   parent = GST_OBJECT_PARENT (pad);
2054 
2055   switch (GST_QUERY_TYPE (query)) {
2056     case GST_QUERY_SEEKING:
2057     {
2058       GstFormat format;
2059 
2060       /* don&#39;t pass it along as some (file)sink might claim it does
2061        * whereas with a collectpads in between that will not likely work */
2062       gst_query_parse_seeking (query, &amp;format, NULL, NULL, NULL);
2063       gst_query_set_seeking (query, format, FALSE, 0, -1);
2064       res = TRUE;
2065       discard = TRUE;
2066       break;
2067     }
2068     default:
2069       break;
2070   }
2071 
2072   if (!discard)
2073     return gst_pad_query_default (pad, parent, query);
2074   else
2075     return res;
2076 }
2077 
2078 static gboolean
2079 gst_collect_pads_query_default_internal (GstCollectPads * pads,
2080     GstCollectData * data, GstQuery * query, gpointer user_data)
2081 {
2082   return gst_collect_pads_query_default (pads, data, query, FALSE);
2083 }
2084 
2085 static gboolean
2086 gst_collect_pads_query (GstPad * pad, GstObject * parent, GstQuery * query)
2087 {
2088   gboolean res = FALSE, need_unlock = FALSE;
2089   GstCollectData *data;
2090   GstCollectPads *pads;
2091   GstCollectPadsQueryFunction query_func;
2092   gpointer query_user_data;
2093 
2094   GST_DEBUG_OBJECT (pad, &quot;Got %s query on sink pad&quot;,
2095       GST_QUERY_TYPE_NAME (query));
2096 
2097   /* some magic to get the managing collect_pads */
2098   GST_OBJECT_LOCK (pad);
2099   data = (GstCollectData *) gst_pad_get_element_private (pad);
2100   if (G_UNLIKELY (data == NULL))
2101     goto pad_removed;
2102   ref_data (data);
2103   GST_OBJECT_UNLOCK (pad);
2104 
2105   pads = data-&gt;collect;
2106 
2107   GST_OBJECT_LOCK (pads);
2108   query_func = pads-&gt;priv-&gt;query_func;
2109   query_user_data = pads-&gt;priv-&gt;query_user_data;
2110   GST_OBJECT_UNLOCK (pads);
2111 
2112   if (GST_QUERY_IS_SERIALIZED (query)) {
2113     GST_COLLECT_PADS_STREAM_LOCK (pads);
2114     need_unlock = TRUE;
2115   }
2116 
2117   if (G_LIKELY (query_func)) {
2118     res = query_func (pads, data, query, query_user_data);
2119   }
2120 
2121   if (need_unlock)
2122     GST_COLLECT_PADS_STREAM_UNLOCK (pads);
2123 
2124   unref_data (data);
2125   return res;
2126 
2127   /* ERRORS */
2128 pad_removed:
2129   {
2130     GST_DEBUG (&quot;%s got removed from collectpads&quot;, GST_OBJECT_NAME (pad));
2131     GST_OBJECT_UNLOCK (pad);
2132     return FALSE;
2133   }
2134 }
2135 
2136 
2137 /* For each buffer we receive we check if our collected condition is reached
2138  * and if so we call the collected function. When this is done we check if
2139  * data has been unqueued. If data is still queued we wait holding the stream
2140  * lock to make sure no EOS event can happen while we are ready to be
2141  * collected
2142  */
2143 static GstFlowReturn
2144 gst_collect_pads_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
2145 {
2146   GstCollectData *data;
2147   GstCollectPads *pads;
2148   GstFlowReturn ret;
2149   GstBuffer **buffer_p;
2150   guint32 cookie;
2151 
2152   GST_DEBUG (&quot;Got buffer for pad %s:%s&quot;, GST_DEBUG_PAD_NAME (pad));
2153 
2154   /* some magic to get the managing collect_pads */
2155   GST_OBJECT_LOCK (pad);
2156   data = (GstCollectData *) gst_pad_get_element_private (pad);
2157   if (G_UNLIKELY (data == NULL))
2158     goto no_data;
2159   ref_data (data);
2160   GST_OBJECT_UNLOCK (pad);
2161 
2162   pads = data-&gt;collect;
2163 
2164   GST_COLLECT_PADS_STREAM_LOCK (pads);
2165   /* if not started, bail out */
2166   if (G_UNLIKELY (!pads-&gt;priv-&gt;started))
2167     goto not_started;
2168   /* check if this pad is flushing */
2169   if (G_UNLIKELY (GST_COLLECT_PADS_STATE_IS_SET (data,
2170               GST_COLLECT_PADS_STATE_FLUSHING)))
2171     goto flushing;
2172   /* pad was EOS, we can refuse this data */
2173   if (G_UNLIKELY (GST_COLLECT_PADS_STATE_IS_SET (data,
2174               GST_COLLECT_PADS_STATE_EOS)))
2175     goto eos;
2176 
2177   /* see if we need to clip */
2178   if (pads-&gt;priv-&gt;clip_func) {
2179     GstBuffer *outbuf = NULL;
2180     ret =
2181         pads-&gt;priv-&gt;clip_func (pads, data, buffer, &amp;outbuf,
2182         pads-&gt;priv-&gt;clip_user_data);
2183     buffer = outbuf;
2184 
2185     if (G_UNLIKELY (outbuf == NULL))
2186       goto clipped;
2187 
2188     if (G_UNLIKELY (ret == GST_FLOW_EOS))
2189       goto eos;
2190     else if (G_UNLIKELY (ret != GST_FLOW_OK))
2191       goto error;
2192   }
2193 
2194   GST_DEBUG_OBJECT (pads, &quot;Queuing buffer %p for pad %s:%s&quot;, buffer,
2195       GST_DEBUG_PAD_NAME (pad));
2196 
2197   /* One more pad has data queued */
2198   if (GST_COLLECT_PADS_STATE_IS_SET (data, GST_COLLECT_PADS_STATE_WAITING))
2199     pads-&gt;priv-&gt;queuedpads++;
2200   buffer_p = &amp;data-&gt;buffer;
2201   gst_buffer_replace (buffer_p, buffer);
2202 
2203   /* update segment last position if in TIME */
2204   if (G_LIKELY (data-&gt;segment.format == GST_FORMAT_TIME)) {
2205     GstClockTime timestamp;
2206 
2207     timestamp = GST_BUFFER_DTS_OR_PTS (buffer);
2208 
2209     if (GST_CLOCK_TIME_IS_VALID (timestamp))
2210       data-&gt;segment.position = timestamp;
2211   }
2212 
2213   /* While we have data queued on this pad try to collect stuff */
2214   do {
2215     /* Check if our collected condition is matched and call the collected
2216      * function if it is */
2217     ret = gst_collect_pads_check_collected (pads);
2218     /* when an error occurs, we want to report this back to the caller ASAP
2219      * without having to block if the buffer was not popped */
2220     if (G_UNLIKELY (ret != GST_FLOW_OK))
2221       goto error;
2222 
2223     /* data was consumed, we can exit and accept new data */
2224     if (data-&gt;buffer == NULL)
2225       break;
2226 
2227     /* Having the _INIT here means we don&#39;t care about any broadcast up to here
2228      * (most of which occur with STREAM_LOCK held, so could not have happened
2229      * anyway).  We do care about e.g. a remove initiated broadcast as of this
2230      * point.  Putting it here also makes this thread ignores any evt it raised
2231      * itself (as is a usual WAIT semantic).
2232      */
2233     GST_COLLECT_PADS_EVT_INIT (cookie);
2234 
2235     /* pad could be removed and re-added */
2236     unref_data (data);
2237     GST_OBJECT_LOCK (pad);
2238     if (G_UNLIKELY ((data = gst_pad_get_element_private (pad)) == NULL))
2239       goto pad_removed;
2240     ref_data (data);
2241     GST_OBJECT_UNLOCK (pad);
2242 
2243     GST_DEBUG_OBJECT (pads, &quot;Pad %s:%s has a buffer queued, waiting&quot;,
2244         GST_DEBUG_PAD_NAME (pad));
2245 
2246     /* wait to be collected, this must happen from another thread triggered
2247      * by the _chain function of another pad. We release the lock so we
2248      * can get stopped or flushed as well. We can however not get EOS
2249      * because we still hold the STREAM_LOCK.
2250      */
2251     GST_COLLECT_PADS_STREAM_UNLOCK (pads);
2252     GST_COLLECT_PADS_EVT_WAIT (pads, cookie);
2253     GST_COLLECT_PADS_STREAM_LOCK (pads);
2254 
2255     GST_DEBUG_OBJECT (pads, &quot;Pad %s:%s resuming&quot;, GST_DEBUG_PAD_NAME (pad));
2256 
2257     /* after a signal, we could be stopped */
2258     if (G_UNLIKELY (!pads-&gt;priv-&gt;started))
2259       goto not_started;
2260     /* check if this pad is flushing */
2261     if (G_UNLIKELY (GST_COLLECT_PADS_STATE_IS_SET (data,
2262                 GST_COLLECT_PADS_STATE_FLUSHING)))
2263       goto flushing;
2264   }
2265   while (data-&gt;buffer != NULL);
2266 
2267 unlock_done:
2268   GST_COLLECT_PADS_STREAM_UNLOCK (pads);
2269   /* data is definitely NULL if pad_removed goto was run. */
2270   if (data)
2271     unref_data (data);
2272   if (buffer)
2273     gst_buffer_unref (buffer);
2274   return ret;
2275 
2276 pad_removed:
2277   {
2278     GST_WARNING (&quot;%s got removed from collectpads&quot;, GST_OBJECT_NAME (pad));
2279     GST_OBJECT_UNLOCK (pad);
2280     ret = GST_FLOW_NOT_LINKED;
2281     goto unlock_done;
2282   }
2283   /* ERRORS */
2284 no_data:
2285   {
2286     GST_DEBUG (&quot;%s got removed from collectpads&quot;, GST_OBJECT_NAME (pad));
2287     GST_OBJECT_UNLOCK (pad);
2288     gst_buffer_unref (buffer);
2289     return GST_FLOW_NOT_LINKED;
2290   }
2291 not_started:
2292   {
2293     GST_DEBUG (&quot;not started&quot;);
2294     gst_collect_pads_clear (pads, data);
2295     ret = GST_FLOW_FLUSHING;
2296     goto unlock_done;
2297   }
2298 flushing:
2299   {
2300     GST_DEBUG (&quot;pad %s:%s is flushing&quot;, GST_DEBUG_PAD_NAME (pad));
2301     gst_collect_pads_clear (pads, data);
2302     ret = GST_FLOW_FLUSHING;
2303     goto unlock_done;
2304   }
2305 eos:
2306   {
2307     /* we should not post an error for this, just inform upstream that
2308      * we don&#39;t expect anything anymore */
2309     GST_DEBUG (&quot;pad %s:%s is eos&quot;, GST_DEBUG_PAD_NAME (pad));
2310     ret = GST_FLOW_EOS;
2311     goto unlock_done;
2312   }
2313 clipped:
2314   {
2315     GST_DEBUG (&quot;clipped buffer on pad %s:%s&quot;, GST_DEBUG_PAD_NAME (pad));
2316     ret = GST_FLOW_OK;
2317     goto unlock_done;
2318   }
2319 error:
2320   {
2321     /* we print the error, the element should post a reasonable error
2322      * message for fatal errors */
2323     GST_DEBUG (&quot;collect failed, reason %d (%s)&quot;, ret, gst_flow_get_name (ret));
2324     gst_collect_pads_clear (pads, data);
2325     goto unlock_done;
2326   }
2327 }
    </pre>
  </body>
</html>