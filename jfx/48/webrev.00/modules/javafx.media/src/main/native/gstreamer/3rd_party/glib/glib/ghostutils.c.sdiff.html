<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/ghostutils.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ghook.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="giochannel.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/ghostutils.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 88 
 89 /* Punycode bias adaptation algorithm, RFC 3492 section 6.1 */
 90 static guint
 91 adapt (guint    delta,
 92        guint    numpoints,
 93        gboolean firsttime)
 94 {
 95   guint k;
 96 
 97   delta = firsttime ? delta / PUNYCODE_DAMP : delta / 2;
 98   delta += delta / numpoints;
 99 
100   k = 0;
101   while (delta &gt; ((PUNYCODE_BASE - PUNYCODE_TMIN) * PUNYCODE_TMAX) / 2)
102     {
103       delta /= PUNYCODE_BASE - PUNYCODE_TMIN;
104       k += PUNYCODE_BASE;
105     }
106 
107   return k + ((PUNYCODE_BASE - PUNYCODE_TMIN + 1) * delta /
<span class="line-modified">108           (delta + PUNYCODE_SKEW));</span>
109 }
110 
111 /* Punycode encoder, RFC 3492 section 6.3. The algorithm is
112  * sufficiently bizarre that it&#39;s not really worth trying to explain
113  * here.
114  */
115 static gboolean
116 punycode_encode (const gchar *input_utf8,
117                  gsize        input_utf8_length,
<span class="line-modified">118          GString     *output)</span>
119 {
120   guint delta, handled_chars, num_basic_chars, bias, j, q, k, t, digit;
121   gunichar n, m, *input;
122   glong input_length;
123   gboolean success = FALSE;
124 
125   /* Convert from UTF-8 to Unicode code points */
126   input = g_utf8_to_ucs4 (input_utf8, input_utf8_length, NULL,
<span class="line-modified">127               &amp;input_length, NULL);</span>
128   if (!input)
129     return FALSE;
130 
131   /* Copy basic chars */
132   for (j = num_basic_chars = 0; j &lt; input_length; j++)
133     {
134       if (PUNYCODE_IS_BASIC (input[j]))
<span class="line-modified">135     {</span>
<span class="line-modified">136       g_string_append_c (output, g_ascii_tolower (input[j]));</span>
<span class="line-modified">137       num_basic_chars++;</span>
<span class="line-modified">138     }</span>
139     }
140   if (num_basic_chars)
141     g_string_append_c (output, &#39;-&#39;);
142 
143   handled_chars = num_basic_chars;
144 
145   /* Encode non-basic chars */
146   delta = 0;
147   bias = PUNYCODE_INITIAL_BIAS;
148   n = PUNYCODE_INITIAL_N;
149   while (handled_chars &lt; input_length)
150     {
151       /* let m = the minimum {non-basic} code point &gt;= n in the input */
152       for (m = G_MAXUINT, j = 0; j &lt; input_length; j++)
<span class="line-modified">153     {</span>
<span class="line-modified">154       if (input[j] &gt;= n &amp;&amp; input[j] &lt; m)</span>
<span class="line-modified">155         m = input[j];</span>
<span class="line-modified">156     }</span>
157 
158       if (m - n &gt; (G_MAXUINT - delta) / (handled_chars + 1))
<span class="line-modified">159     goto fail;</span>
160       delta += (m - n) * (handled_chars + 1);
161       n = m;
162 
163       for (j = 0; j &lt; input_length; j++)










164     {
<span class="line-modified">165       if (input[j] &lt; n)</span>
<span class="line-modified">166         {</span>
<span class="line-modified">167           if (++delta == 0)</span>
<span class="line-modified">168         goto fail;</span>
<span class="line-modified">169         }</span>
<span class="line-modified">170       else if (input[j] == n)</span>
<span class="line-modified">171         {</span>
<span class="line-modified">172           q = delta;</span>
<span class="line-modified">173           for (k = PUNYCODE_BASE; ; k += PUNYCODE_BASE)</span>
<span class="line-modified">174         {</span>
<span class="line-modified">175           if (k &lt;= bias)</span>
<span class="line-removed">176             t = PUNYCODE_TMIN;</span>
<span class="line-removed">177           else if (k &gt;= bias + PUNYCODE_TMAX)</span>
<span class="line-removed">178             t = PUNYCODE_TMAX;</span>
<span class="line-removed">179           else</span>
<span class="line-removed">180             t = k - bias;</span>
<span class="line-removed">181           if (q &lt; t)</span>
<span class="line-removed">182             break;</span>
<span class="line-removed">183           digit = t + (q - t) % (PUNYCODE_BASE - t);</span>
<span class="line-removed">184           g_string_append_c (output, encode_digit (digit));</span>
<span class="line-removed">185           q = (q - t) / (PUNYCODE_BASE - t);</span>
<span class="line-removed">186         }</span>
<span class="line-removed">187 </span>
<span class="line-removed">188           g_string_append_c (output, encode_digit (q));</span>
<span class="line-removed">189           bias = adapt (delta, handled_chars + 1, handled_chars == num_basic_chars);</span>
<span class="line-removed">190           delta = 0;</span>
<span class="line-removed">191           handled_chars++;</span>
<span class="line-removed">192         }</span>
193     }
194 







195       delta++;
196       n++;
197     }
198 
199   success = TRUE;
200 
201  fail:
202   g_free (input);
203   return success;
204 }
205 
206 /* From RFC 3454, Table B.1 */
207 #define idna_is_junk(ch) ((ch) == 0x00AD || (ch) == 0x1806 || (ch) == 0x200B || (ch) == 0x2060 || (ch) == 0xFEFF || (ch) == 0x034F || (ch) == 0x180B || (ch) == 0x180C || (ch) == 0x180D || (ch) == 0x200C || (ch) == 0x200D || ((ch) &gt;= 0xFE00 &amp;&amp; (ch) &lt;= 0xFE0F))
208 
209 /* Scan @str for &quot;junk&quot; and return a cleaned-up string if any junk
210  * is found. Else return %NULL.
211  */
212 static gchar *
213 remove_junk (const gchar *str,
214              gint         len)
215 {
216   GString *cleaned = NULL;
217   const gchar *p;
218   gunichar ch;
219 
220   for (p = str; len == -1 ? *p : p &lt; str + len; p = g_utf8_next_char (p))
221     {
222       ch = g_utf8_get_char (p);
223       if (idna_is_junk (ch))
<span class="line-modified">224     {</span>
<span class="line-modified">225       if (!cleaned)</span>
<span class="line-modified">226         {</span>
<span class="line-modified">227           cleaned = g_string_new (NULL);</span>
<span class="line-modified">228           g_string_append_len (cleaned, str, p - str);</span>
<span class="line-modified">229         }</span>
<span class="line-modified">230     }</span>
231       else if (cleaned)
<span class="line-modified">232     g_string_append_unichar (cleaned, ch);</span>
233     }
234 
235   if (cleaned)
236     return g_string_free (cleaned, FALSE);
237   else
238     return NULL;
239 }
240 
241 static inline gboolean
242 contains_uppercase_letters (const gchar *str,
243                             gint         len)
244 {
245   const gchar *p;
246 
247   for (p = str; len == -1 ? *p : p &lt; str + len; p = g_utf8_next_char (p))
248     {
249       if (g_unichar_isupper (g_utf8_get_char (p)))
<span class="line-modified">250     return TRUE;</span>
251     }
252   return FALSE;
253 }
254 
255 static inline gboolean
256 contains_non_ascii (const gchar *str,
257                     gint         len)
258 {
259   const gchar *p;
260 
261   for (p = str; len == -1 ? *p : p &lt; str + len; p++)
262     {
263       if ((guchar)*p &gt; 0x80)
<span class="line-modified">264     return TRUE;</span>
265     }
266   return FALSE;
267 }
268 
269 /* RFC 3454, Appendix C. ish. */
270 static inline gboolean
271 idna_is_prohibited (gunichar ch)
272 {
273   switch (g_unichar_type (ch))
274     {
275     case G_UNICODE_CONTROL:
276     case G_UNICODE_FORMAT:
277     case G_UNICODE_UNASSIGNED:
278     case G_UNICODE_PRIVATE_USE:
279     case G_UNICODE_SURROGATE:
280     case G_UNICODE_LINE_SEPARATOR:
281     case G_UNICODE_PARAGRAPH_SEPARATOR:
282     case G_UNICODE_SPACE_SEPARATOR:
283       return TRUE;
284 
285     case G_UNICODE_OTHER_SYMBOL:
286       if (ch == 0xFFFC || ch == 0xFFFD ||
<span class="line-modified">287       (ch &gt;= 0x2FF0 &amp;&amp; ch &lt;= 0x2FFB))</span>
<span class="line-modified">288     return TRUE;</span>
289       return FALSE;
290 
291     case G_UNICODE_NON_SPACING_MARK:
292       if (ch == 0x0340 || ch == 0x0341)
<span class="line-modified">293     return TRUE;</span>
294       return FALSE;
295 
296     default:
297       return FALSE;
298     }
299 }
300 
301 /* RFC 3491 IDN cleanup algorithm. */
302 static gchar *
303 nameprep (const gchar *hostname,
304           gint         len,
305           gboolean    *is_unicode)
306 {
307   gchar *name, *tmp = NULL, *p;
308 
309   /* It would be nice if we could do this without repeatedly
310    * allocating strings and converting back and forth between
311    * gunichars and UTF-8... The code does at least avoid doing most of
312    * the sub-operations when they would just be equivalent to a
313    * g_strdup().
</pre>
<hr />
<pre>
353     return NULL;
354 
355   /* KC normalization may have created more capital letters (eg,
356    * angstrom -&gt; capital A with ring). So we have to lowercasify a
357    * second time. (This is more-or-less how the nameprep algorithm
358    * does it. If tolower(nfkc(tolower(X))) is guaranteed to be the
359    * same as tolower(nfkc(X)), then we could skip the first tolower,
360    * but I&#39;m not sure it is.)
361    */
362   if (contains_uppercase_letters (name, -1))
363     {
364       name = g_utf8_strdown (name, -1);
365       g_free (tmp);
366       tmp = name;
367     }
368 
369   /* Check for prohibited characters */
370   for (p = name; *p; p = g_utf8_next_char (p))
371     {
372       if (idna_is_prohibited (g_utf8_get_char (p)))
<span class="line-modified">373     {</span>
<span class="line-modified">374       name = NULL;</span>
375           g_free (tmp);
<span class="line-modified">376       goto done;</span>
<span class="line-modified">377     }</span>
378     }
379 
380   /* FIXME: We&#39;re supposed to verify certain constraints on bidi
381    * characters, but glib does not appear to have that information.
382    */
383 
384  done:
385   return name;
386 }
387 
388 /* RFC 3490, section 3.1 says &#39;.&#39;, 0x3002, 0xFF0E, and 0xFF61 count as
389  * label-separating dots. @str must be &#39;\0&#39;-terminated.
390  */
391 #define idna_is_dot(str) ( \
392   ((guchar)(str)[0] == &#39;.&#39;) ||                                                 \
393   ((guchar)(str)[0] == 0xE3 &amp;&amp; (guchar)(str)[1] == 0x80 &amp;&amp; (guchar)(str)[2] == 0x82) || \
394   ((guchar)(str)[0] == 0xEF &amp;&amp; (guchar)(str)[1] == 0xBC &amp;&amp; (guchar)(str)[2] == 0x8E) || \
395   ((guchar)(str)[0] == 0xEF &amp;&amp; (guchar)(str)[1] == 0xBD &amp;&amp; (guchar)(str)[2] == 0xA1) )
396 
397 static const gchar *
</pre>
<hr />
<pre>
419  * Since: 2.22
420  **/
421 gchar *
422 g_hostname_to_ascii (const gchar *hostname)
423 {
424   gchar *name, *label, *p;
425   GString *out;
426   gssize llen, oldlen;
427   gboolean unicode;
428 
429   label = name = nameprep (hostname, -1, &amp;unicode);
430   if (!name || !unicode)
431     return name;
432 
433   out = g_string_new (NULL);
434 
435   do
436     {
437       unicode = FALSE;
438       for (p = label; *p &amp;&amp; !idna_is_dot (p); p++)
<span class="line-modified">439     {</span>
<span class="line-modified">440       if ((guchar)*p &gt; 0x80)</span>
<span class="line-modified">441         unicode = TRUE;</span>
<span class="line-modified">442     }</span>
443 
444       oldlen = out-&gt;len;
445       llen = p - label;
446       if (unicode)
<span class="line-modified">447     {</span>
448           if (!strncmp (label, IDNA_ACE_PREFIX, IDNA_ACE_PREFIX_LEN))
449             goto fail;
450 
<span class="line-modified">451       g_string_append (out, IDNA_ACE_PREFIX);</span>
<span class="line-modified">452       if (!punycode_encode (label, llen, out))</span>
<span class="line-modified">453         goto fail;</span>
<span class="line-modified">454     }</span>
455       else
456         g_string_append_len (out, label, llen);
457 
458       if (out-&gt;len - oldlen &gt; 63)
<span class="line-modified">459     goto fail;</span>
460 
461       label += llen;
462       if (*label)
463         label = g_utf8_next_char (label);
464       if (*label)
465         g_string_append_c (out, &#39;.&#39;);
466     }
467   while (*label);
468 
469   g_free (name);
470   return g_string_free (out, FALSE);
471 
472  fail:
473   g_free (name);
474   g_string_free (out, TRUE);
475   return NULL;
476 }
477 
478 /**
479  * g_hostname_is_non_ascii:
</pre>
<hr />
<pre>
504 punycode_decode (const gchar *input,
505                  gsize        input_length,
506                  GString     *output)
507 {
508   GArray *output_chars;
509   gunichar n;
510   guint i, bias;
511   guint oldi, w, k, digit, t;
512   const gchar *split;
513 
514   n = PUNYCODE_INITIAL_N;
515   i = 0;
516   bias = PUNYCODE_INITIAL_BIAS;
517 
518   split = input + input_length - 1;
519   while (split &gt; input &amp;&amp; *split != &#39;-&#39;)
520     split--;
521   if (split &gt; input)
522     {
523       output_chars = g_array_sized_new (FALSE, FALSE, sizeof (gunichar),
<span class="line-modified">524                     split - input);</span>
525       input_length -= (split - input) + 1;
526       while (input &lt; split)
<span class="line-modified">527     {</span>
<span class="line-modified">528       gunichar ch = (gunichar)*input++;</span>
<span class="line-modified">529       if (!PUNYCODE_IS_BASIC (ch))</span>
<span class="line-modified">530         goto fail;</span>
<span class="line-modified">531       g_array_append_val (output_chars, ch);</span>
<span class="line-modified">532     }</span>
533       input++;
534     }
535   else
536     output_chars = g_array_new (FALSE, FALSE, sizeof (gunichar));
537 
538   while (input_length)
539     {
540       oldi = i;
541       w = 1;
542       for (k = PUNYCODE_BASE; ; k += PUNYCODE_BASE)
<span class="line-modified">543     {</span>
<span class="line-modified">544       if (!input_length--)</span>
<span class="line-modified">545         goto fail;</span>
<span class="line-modified">546       digit = decode_digit (*input++);</span>
<span class="line-modified">547       if (digit &gt;= PUNYCODE_BASE)</span>
<span class="line-modified">548         goto fail;</span>
<span class="line-modified">549       if (digit &gt; (G_MAXUINT - i) / w)</span>
<span class="line-modified">550         goto fail;</span>
<span class="line-modified">551       i += digit * w;</span>
<span class="line-modified">552       if (k &lt;= bias)</span>
<span class="line-modified">553         t = PUNYCODE_TMIN;</span>
<span class="line-modified">554       else if (k &gt;= bias + PUNYCODE_TMAX)</span>
<span class="line-modified">555         t = PUNYCODE_TMAX;</span>
<span class="line-modified">556       else</span>
<span class="line-modified">557         t = k - bias;</span>
<span class="line-modified">558       if (digit &lt; t)</span>
<span class="line-modified">559         break;</span>
<span class="line-modified">560       if (w &gt; G_MAXUINT / (PUNYCODE_BASE - t))</span>
<span class="line-modified">561         goto fail;</span>
<span class="line-modified">562       w *= (PUNYCODE_BASE - t);</span>
<span class="line-modified">563     }</span>
564 
565       bias = adapt (i - oldi, output_chars-&gt;len + 1, oldi == 0);
566 
567       if (i / (output_chars-&gt;len + 1) &gt; G_MAXUINT - n)
<span class="line-modified">568     goto fail;</span>
569       n += i / (output_chars-&gt;len + 1);
570       i %= (output_chars-&gt;len + 1);
571 
572       g_array_insert_val (output_chars, i++, n);
573     }
574 
575   for (i = 0; i &lt; output_chars-&gt;len; i++)
576     g_string_append_unichar (output, g_array_index (output_chars, gunichar, i));
577   g_array_free (output_chars, TRUE);
578   return TRUE;
579 
580  fail:
581   g_array_free (output_chars, TRUE);
582   return FALSE;
583 }
584 
585 /**
586  * g_hostname_to_unicode:
587  * @hostname: a valid UTF-8 or ASCII hostname
588  *
</pre>
<hr />
<pre>
594  * Of course if @hostname is not an internationalized hostname, then
595  * the canonical presentation form will be entirely ASCII.
596  *
597  * Returns: a UTF-8 hostname, which must be freed, or %NULL if
598  * @hostname is in some way invalid.
599  *
600  * Since: 2.22
601  **/
602 gchar *
603 g_hostname_to_unicode (const gchar *hostname)
604 {
605   GString *out;
606   gssize llen;
607 
608   out = g_string_new (NULL);
609 
610   do
611     {
612       llen = idna_end_of_label (hostname) - hostname;
613       if (!g_ascii_strncasecmp (hostname, IDNA_ACE_PREFIX, IDNA_ACE_PREFIX_LEN))
<span class="line-modified">614     {</span>
<span class="line-modified">615       hostname += IDNA_ACE_PREFIX_LEN;</span>
<span class="line-modified">616       llen -= IDNA_ACE_PREFIX_LEN;</span>
<span class="line-modified">617       if (!punycode_decode (hostname, llen, out))</span>
<span class="line-modified">618         {</span>
<span class="line-modified">619           g_string_free (out, TRUE);</span>
<span class="line-modified">620           return NULL;</span>
<span class="line-modified">621         }</span>
<span class="line-modified">622     }</span>
623       else
624         {
625           gboolean unicode;
626           gchar *canonicalized = nameprep (hostname, llen, &amp;unicode);
627 
628           if (!canonicalized)
629             {
630               g_string_free (out, TRUE);
631               return NULL;
632             }
633           g_string_append (out, canonicalized);
634           g_free (canonicalized);
635         }
636 
637       hostname += llen;
638       if (*hostname)
639         hostname = g_utf8_next_char (hostname);
640       if (*hostname)
641         g_string_append_c (out, &#39;.&#39;);
642     }
</pre>
<hr />
<pre>
652  * Tests if @hostname contains segments with an ASCII-compatible
653  * encoding of an Internationalized Domain Name. If this returns
654  * %TRUE, you should decode the hostname with g_hostname_to_unicode()
655  * before displaying it to the user.
656  *
657  * Note that a hostname might contain a mix of encoded and unencoded
658  * segments, and so it is possible for g_hostname_is_non_ascii() and
659  * g_hostname_is_ascii_encoded() to both return %TRUE for a name.
660  *
661  * Returns: %TRUE if @hostname contains any ASCII-encoded
662  * segments.
663  *
664  * Since: 2.22
665  **/
666 gboolean
667 g_hostname_is_ascii_encoded (const gchar *hostname)
668 {
669   while (1)
670     {
671       if (!g_ascii_strncasecmp (hostname, IDNA_ACE_PREFIX, IDNA_ACE_PREFIX_LEN))
<span class="line-modified">672     return TRUE;</span>
673       hostname = idna_end_of_label (hostname);
674       if (*hostname)
675         hostname = g_utf8_next_char (hostname);
676       if (!*hostname)
<span class="line-modified">677     return FALSE;</span>
678     }
679 }
680 
681 /**
682  * g_hostname_is_ip_address:
683  * @hostname: a hostname (or IP address in string form)
684  *
685  * Tests if @hostname is the string form of an IPv4 or IPv6 address.
686  * (Eg, &quot;192.168.0.1&quot;.)
687  *
688  * Returns: %TRUE if @hostname is an IP address
689  *
690  * Since: 2.22
691  **/
692 gboolean
693 g_hostname_is_ip_address (const gchar *hostname)
694 {
695   gchar *p, *end;
696   gint nsegments, octet;
697 
</pre>
<hr />
<pre>
769   for (nsegments = 0; nsegments &lt; 4; nsegments++)
770     {
771       if (nsegments != 0)
772         {
773           if (*p != &#39;.&#39;)
774             return FALSE;
775           p++;
776         }
777 
778       /* Check the segment; a little tricker than the IPv6 case since
779        * we can&#39;t allow extra leading 0s, and we can&#39;t assume that all
780        * strings of valid length are within range.
781        */
782       octet = 0;
783       if (*p == &#39;0&#39;)
784         end = p + 1;
785       else
786         {
787           for (end = p; g_ascii_isdigit (*end); end++)
788             {
<span class="line-modified">789             octet = 10 * octet + (*end - &#39;0&#39;);</span>
790 
791               if (octet &gt; 255)
792                 break;
<span class="line-modified">793         }</span>
794         }
795       if (end == p || end &gt; p + 3 || octet &gt; 255)
796         return FALSE;
797 
798       p = end;
799     }
800 
801   /* If there&#39;s nothing left to parse, then it&#39;s ok. */
802   return !*p;
803 }
</pre>
</td>
<td>
<hr />
<pre>
 88 
 89 /* Punycode bias adaptation algorithm, RFC 3492 section 6.1 */
 90 static guint
 91 adapt (guint    delta,
 92        guint    numpoints,
 93        gboolean firsttime)
 94 {
 95   guint k;
 96 
 97   delta = firsttime ? delta / PUNYCODE_DAMP : delta / 2;
 98   delta += delta / numpoints;
 99 
100   k = 0;
101   while (delta &gt; ((PUNYCODE_BASE - PUNYCODE_TMIN) * PUNYCODE_TMAX) / 2)
102     {
103       delta /= PUNYCODE_BASE - PUNYCODE_TMIN;
104       k += PUNYCODE_BASE;
105     }
106 
107   return k + ((PUNYCODE_BASE - PUNYCODE_TMIN + 1) * delta /
<span class="line-modified">108         (delta + PUNYCODE_SKEW));</span>
109 }
110 
111 /* Punycode encoder, RFC 3492 section 6.3. The algorithm is
112  * sufficiently bizarre that it&#39;s not really worth trying to explain
113  * here.
114  */
115 static gboolean
116 punycode_encode (const gchar *input_utf8,
117                  gsize        input_utf8_length,
<span class="line-modified">118      GString     *output)</span>
119 {
120   guint delta, handled_chars, num_basic_chars, bias, j, q, k, t, digit;
121   gunichar n, m, *input;
122   glong input_length;
123   gboolean success = FALSE;
124 
125   /* Convert from UTF-8 to Unicode code points */
126   input = g_utf8_to_ucs4 (input_utf8, input_utf8_length, NULL,
<span class="line-modified">127         &amp;input_length, NULL);</span>
128   if (!input)
129     return FALSE;
130 
131   /* Copy basic chars */
132   for (j = num_basic_chars = 0; j &lt; input_length; j++)
133     {
134       if (PUNYCODE_IS_BASIC (input[j]))
<span class="line-modified">135   {</span>
<span class="line-modified">136     g_string_append_c (output, g_ascii_tolower (input[j]));</span>
<span class="line-modified">137     num_basic_chars++;</span>
<span class="line-modified">138   }</span>
139     }
140   if (num_basic_chars)
141     g_string_append_c (output, &#39;-&#39;);
142 
143   handled_chars = num_basic_chars;
144 
145   /* Encode non-basic chars */
146   delta = 0;
147   bias = PUNYCODE_INITIAL_BIAS;
148   n = PUNYCODE_INITIAL_N;
149   while (handled_chars &lt; input_length)
150     {
151       /* let m = the minimum {non-basic} code point &gt;= n in the input */
152       for (m = G_MAXUINT, j = 0; j &lt; input_length; j++)
<span class="line-modified">153   {</span>
<span class="line-modified">154     if (input[j] &gt;= n &amp;&amp; input[j] &lt; m)</span>
<span class="line-modified">155       m = input[j];</span>
<span class="line-modified">156   }</span>
157 
158       if (m - n &gt; (G_MAXUINT - delta) / (handled_chars + 1))
<span class="line-modified">159   goto fail;</span>
160       delta += (m - n) * (handled_chars + 1);
161       n = m;
162 
163       for (j = 0; j &lt; input_length; j++)
<span class="line-added">164   {</span>
<span class="line-added">165     if (input[j] &lt; n)</span>
<span class="line-added">166       {</span>
<span class="line-added">167         if (++delta == 0)</span>
<span class="line-added">168     goto fail;</span>
<span class="line-added">169       }</span>
<span class="line-added">170     else if (input[j] == n)</span>
<span class="line-added">171       {</span>
<span class="line-added">172         q = delta;</span>
<span class="line-added">173         for (k = PUNYCODE_BASE; ; k += PUNYCODE_BASE)</span>
174     {
<span class="line-modified">175       if (k &lt;= bias)</span>
<span class="line-modified">176         t = PUNYCODE_TMIN;</span>
<span class="line-modified">177       else if (k &gt;= bias + PUNYCODE_TMAX)</span>
<span class="line-modified">178         t = PUNYCODE_TMAX;</span>
<span class="line-modified">179       else</span>
<span class="line-modified">180         t = k - bias;</span>
<span class="line-modified">181       if (q &lt; t)</span>
<span class="line-modified">182         break;</span>
<span class="line-modified">183       digit = t + (q - t) % (PUNYCODE_BASE - t);</span>
<span class="line-modified">184       g_string_append_c (output, encode_digit (digit));</span>
<span class="line-modified">185       q = (q - t) / (PUNYCODE_BASE - t);</span>

















186     }
187 
<span class="line-added">188         g_string_append_c (output, encode_digit (q));</span>
<span class="line-added">189         bias = adapt (delta, handled_chars + 1, handled_chars == num_basic_chars);</span>
<span class="line-added">190         delta = 0;</span>
<span class="line-added">191         handled_chars++;</span>
<span class="line-added">192       }</span>
<span class="line-added">193   }</span>
<span class="line-added">194 </span>
195       delta++;
196       n++;
197     }
198 
199   success = TRUE;
200 
201  fail:
202   g_free (input);
203   return success;
204 }
205 
206 /* From RFC 3454, Table B.1 */
207 #define idna_is_junk(ch) ((ch) == 0x00AD || (ch) == 0x1806 || (ch) == 0x200B || (ch) == 0x2060 || (ch) == 0xFEFF || (ch) == 0x034F || (ch) == 0x180B || (ch) == 0x180C || (ch) == 0x180D || (ch) == 0x200C || (ch) == 0x200D || ((ch) &gt;= 0xFE00 &amp;&amp; (ch) &lt;= 0xFE0F))
208 
209 /* Scan @str for &quot;junk&quot; and return a cleaned-up string if any junk
210  * is found. Else return %NULL.
211  */
212 static gchar *
213 remove_junk (const gchar *str,
214              gint         len)
215 {
216   GString *cleaned = NULL;
217   const gchar *p;
218   gunichar ch;
219 
220   for (p = str; len == -1 ? *p : p &lt; str + len; p = g_utf8_next_char (p))
221     {
222       ch = g_utf8_get_char (p);
223       if (idna_is_junk (ch))
<span class="line-modified">224   {</span>
<span class="line-modified">225     if (!cleaned)</span>
<span class="line-modified">226       {</span>
<span class="line-modified">227         cleaned = g_string_new (NULL);</span>
<span class="line-modified">228         g_string_append_len (cleaned, str, p - str);</span>
<span class="line-modified">229       }</span>
<span class="line-modified">230   }</span>
231       else if (cleaned)
<span class="line-modified">232   g_string_append_unichar (cleaned, ch);</span>
233     }
234 
235   if (cleaned)
236     return g_string_free (cleaned, FALSE);
237   else
238     return NULL;
239 }
240 
241 static inline gboolean
242 contains_uppercase_letters (const gchar *str,
243                             gint         len)
244 {
245   const gchar *p;
246 
247   for (p = str; len == -1 ? *p : p &lt; str + len; p = g_utf8_next_char (p))
248     {
249       if (g_unichar_isupper (g_utf8_get_char (p)))
<span class="line-modified">250   return TRUE;</span>
251     }
252   return FALSE;
253 }
254 
255 static inline gboolean
256 contains_non_ascii (const gchar *str,
257                     gint         len)
258 {
259   const gchar *p;
260 
261   for (p = str; len == -1 ? *p : p &lt; str + len; p++)
262     {
263       if ((guchar)*p &gt; 0x80)
<span class="line-modified">264   return TRUE;</span>
265     }
266   return FALSE;
267 }
268 
269 /* RFC 3454, Appendix C. ish. */
270 static inline gboolean
271 idna_is_prohibited (gunichar ch)
272 {
273   switch (g_unichar_type (ch))
274     {
275     case G_UNICODE_CONTROL:
276     case G_UNICODE_FORMAT:
277     case G_UNICODE_UNASSIGNED:
278     case G_UNICODE_PRIVATE_USE:
279     case G_UNICODE_SURROGATE:
280     case G_UNICODE_LINE_SEPARATOR:
281     case G_UNICODE_PARAGRAPH_SEPARATOR:
282     case G_UNICODE_SPACE_SEPARATOR:
283       return TRUE;
284 
285     case G_UNICODE_OTHER_SYMBOL:
286       if (ch == 0xFFFC || ch == 0xFFFD ||
<span class="line-modified">287     (ch &gt;= 0x2FF0 &amp;&amp; ch &lt;= 0x2FFB))</span>
<span class="line-modified">288   return TRUE;</span>
289       return FALSE;
290 
291     case G_UNICODE_NON_SPACING_MARK:
292       if (ch == 0x0340 || ch == 0x0341)
<span class="line-modified">293   return TRUE;</span>
294       return FALSE;
295 
296     default:
297       return FALSE;
298     }
299 }
300 
301 /* RFC 3491 IDN cleanup algorithm. */
302 static gchar *
303 nameprep (const gchar *hostname,
304           gint         len,
305           gboolean    *is_unicode)
306 {
307   gchar *name, *tmp = NULL, *p;
308 
309   /* It would be nice if we could do this without repeatedly
310    * allocating strings and converting back and forth between
311    * gunichars and UTF-8... The code does at least avoid doing most of
312    * the sub-operations when they would just be equivalent to a
313    * g_strdup().
</pre>
<hr />
<pre>
353     return NULL;
354 
355   /* KC normalization may have created more capital letters (eg,
356    * angstrom -&gt; capital A with ring). So we have to lowercasify a
357    * second time. (This is more-or-less how the nameprep algorithm
358    * does it. If tolower(nfkc(tolower(X))) is guaranteed to be the
359    * same as tolower(nfkc(X)), then we could skip the first tolower,
360    * but I&#39;m not sure it is.)
361    */
362   if (contains_uppercase_letters (name, -1))
363     {
364       name = g_utf8_strdown (name, -1);
365       g_free (tmp);
366       tmp = name;
367     }
368 
369   /* Check for prohibited characters */
370   for (p = name; *p; p = g_utf8_next_char (p))
371     {
372       if (idna_is_prohibited (g_utf8_get_char (p)))
<span class="line-modified">373   {</span>
<span class="line-modified">374     name = NULL;</span>
375           g_free (tmp);
<span class="line-modified">376     goto done;</span>
<span class="line-modified">377   }</span>
378     }
379 
380   /* FIXME: We&#39;re supposed to verify certain constraints on bidi
381    * characters, but glib does not appear to have that information.
382    */
383 
384  done:
385   return name;
386 }
387 
388 /* RFC 3490, section 3.1 says &#39;.&#39;, 0x3002, 0xFF0E, and 0xFF61 count as
389  * label-separating dots. @str must be &#39;\0&#39;-terminated.
390  */
391 #define idna_is_dot(str) ( \
392   ((guchar)(str)[0] == &#39;.&#39;) ||                                                 \
393   ((guchar)(str)[0] == 0xE3 &amp;&amp; (guchar)(str)[1] == 0x80 &amp;&amp; (guchar)(str)[2] == 0x82) || \
394   ((guchar)(str)[0] == 0xEF &amp;&amp; (guchar)(str)[1] == 0xBC &amp;&amp; (guchar)(str)[2] == 0x8E) || \
395   ((guchar)(str)[0] == 0xEF &amp;&amp; (guchar)(str)[1] == 0xBD &amp;&amp; (guchar)(str)[2] == 0xA1) )
396 
397 static const gchar *
</pre>
<hr />
<pre>
419  * Since: 2.22
420  **/
421 gchar *
422 g_hostname_to_ascii (const gchar *hostname)
423 {
424   gchar *name, *label, *p;
425   GString *out;
426   gssize llen, oldlen;
427   gboolean unicode;
428 
429   label = name = nameprep (hostname, -1, &amp;unicode);
430   if (!name || !unicode)
431     return name;
432 
433   out = g_string_new (NULL);
434 
435   do
436     {
437       unicode = FALSE;
438       for (p = label; *p &amp;&amp; !idna_is_dot (p); p++)
<span class="line-modified">439   {</span>
<span class="line-modified">440     if ((guchar)*p &gt; 0x80)</span>
<span class="line-modified">441       unicode = TRUE;</span>
<span class="line-modified">442   }</span>
443 
444       oldlen = out-&gt;len;
445       llen = p - label;
446       if (unicode)
<span class="line-modified">447   {</span>
448           if (!strncmp (label, IDNA_ACE_PREFIX, IDNA_ACE_PREFIX_LEN))
449             goto fail;
450 
<span class="line-modified">451     g_string_append (out, IDNA_ACE_PREFIX);</span>
<span class="line-modified">452     if (!punycode_encode (label, llen, out))</span>
<span class="line-modified">453       goto fail;</span>
<span class="line-modified">454   }</span>
455       else
456         g_string_append_len (out, label, llen);
457 
458       if (out-&gt;len - oldlen &gt; 63)
<span class="line-modified">459   goto fail;</span>
460 
461       label += llen;
462       if (*label)
463         label = g_utf8_next_char (label);
464       if (*label)
465         g_string_append_c (out, &#39;.&#39;);
466     }
467   while (*label);
468 
469   g_free (name);
470   return g_string_free (out, FALSE);
471 
472  fail:
473   g_free (name);
474   g_string_free (out, TRUE);
475   return NULL;
476 }
477 
478 /**
479  * g_hostname_is_non_ascii:
</pre>
<hr />
<pre>
504 punycode_decode (const gchar *input,
505                  gsize        input_length,
506                  GString     *output)
507 {
508   GArray *output_chars;
509   gunichar n;
510   guint i, bias;
511   guint oldi, w, k, digit, t;
512   const gchar *split;
513 
514   n = PUNYCODE_INITIAL_N;
515   i = 0;
516   bias = PUNYCODE_INITIAL_BIAS;
517 
518   split = input + input_length - 1;
519   while (split &gt; input &amp;&amp; *split != &#39;-&#39;)
520     split--;
521   if (split &gt; input)
522     {
523       output_chars = g_array_sized_new (FALSE, FALSE, sizeof (gunichar),
<span class="line-modified">524           split - input);</span>
525       input_length -= (split - input) + 1;
526       while (input &lt; split)
<span class="line-modified">527   {</span>
<span class="line-modified">528     gunichar ch = (gunichar)*input++;</span>
<span class="line-modified">529     if (!PUNYCODE_IS_BASIC (ch))</span>
<span class="line-modified">530       goto fail;</span>
<span class="line-modified">531     g_array_append_val (output_chars, ch);</span>
<span class="line-modified">532   }</span>
533       input++;
534     }
535   else
536     output_chars = g_array_new (FALSE, FALSE, sizeof (gunichar));
537 
538   while (input_length)
539     {
540       oldi = i;
541       w = 1;
542       for (k = PUNYCODE_BASE; ; k += PUNYCODE_BASE)
<span class="line-modified">543   {</span>
<span class="line-modified">544     if (!input_length--)</span>
<span class="line-modified">545       goto fail;</span>
<span class="line-modified">546     digit = decode_digit (*input++);</span>
<span class="line-modified">547     if (digit &gt;= PUNYCODE_BASE)</span>
<span class="line-modified">548       goto fail;</span>
<span class="line-modified">549     if (digit &gt; (G_MAXUINT - i) / w)</span>
<span class="line-modified">550       goto fail;</span>
<span class="line-modified">551     i += digit * w;</span>
<span class="line-modified">552     if (k &lt;= bias)</span>
<span class="line-modified">553       t = PUNYCODE_TMIN;</span>
<span class="line-modified">554     else if (k &gt;= bias + PUNYCODE_TMAX)</span>
<span class="line-modified">555       t = PUNYCODE_TMAX;</span>
<span class="line-modified">556     else</span>
<span class="line-modified">557       t = k - bias;</span>
<span class="line-modified">558     if (digit &lt; t)</span>
<span class="line-modified">559       break;</span>
<span class="line-modified">560     if (w &gt; G_MAXUINT / (PUNYCODE_BASE - t))</span>
<span class="line-modified">561       goto fail;</span>
<span class="line-modified">562     w *= (PUNYCODE_BASE - t);</span>
<span class="line-modified">563   }</span>
564 
565       bias = adapt (i - oldi, output_chars-&gt;len + 1, oldi == 0);
566 
567       if (i / (output_chars-&gt;len + 1) &gt; G_MAXUINT - n)
<span class="line-modified">568   goto fail;</span>
569       n += i / (output_chars-&gt;len + 1);
570       i %= (output_chars-&gt;len + 1);
571 
572       g_array_insert_val (output_chars, i++, n);
573     }
574 
575   for (i = 0; i &lt; output_chars-&gt;len; i++)
576     g_string_append_unichar (output, g_array_index (output_chars, gunichar, i));
577   g_array_free (output_chars, TRUE);
578   return TRUE;
579 
580  fail:
581   g_array_free (output_chars, TRUE);
582   return FALSE;
583 }
584 
585 /**
586  * g_hostname_to_unicode:
587  * @hostname: a valid UTF-8 or ASCII hostname
588  *
</pre>
<hr />
<pre>
594  * Of course if @hostname is not an internationalized hostname, then
595  * the canonical presentation form will be entirely ASCII.
596  *
597  * Returns: a UTF-8 hostname, which must be freed, or %NULL if
598  * @hostname is in some way invalid.
599  *
600  * Since: 2.22
601  **/
602 gchar *
603 g_hostname_to_unicode (const gchar *hostname)
604 {
605   GString *out;
606   gssize llen;
607 
608   out = g_string_new (NULL);
609 
610   do
611     {
612       llen = idna_end_of_label (hostname) - hostname;
613       if (!g_ascii_strncasecmp (hostname, IDNA_ACE_PREFIX, IDNA_ACE_PREFIX_LEN))
<span class="line-modified">614   {</span>
<span class="line-modified">615     hostname += IDNA_ACE_PREFIX_LEN;</span>
<span class="line-modified">616     llen -= IDNA_ACE_PREFIX_LEN;</span>
<span class="line-modified">617     if (!punycode_decode (hostname, llen, out))</span>
<span class="line-modified">618       {</span>
<span class="line-modified">619         g_string_free (out, TRUE);</span>
<span class="line-modified">620         return NULL;</span>
<span class="line-modified">621       }</span>
<span class="line-modified">622   }</span>
623       else
624         {
625           gboolean unicode;
626           gchar *canonicalized = nameprep (hostname, llen, &amp;unicode);
627 
628           if (!canonicalized)
629             {
630               g_string_free (out, TRUE);
631               return NULL;
632             }
633           g_string_append (out, canonicalized);
634           g_free (canonicalized);
635         }
636 
637       hostname += llen;
638       if (*hostname)
639         hostname = g_utf8_next_char (hostname);
640       if (*hostname)
641         g_string_append_c (out, &#39;.&#39;);
642     }
</pre>
<hr />
<pre>
652  * Tests if @hostname contains segments with an ASCII-compatible
653  * encoding of an Internationalized Domain Name. If this returns
654  * %TRUE, you should decode the hostname with g_hostname_to_unicode()
655  * before displaying it to the user.
656  *
657  * Note that a hostname might contain a mix of encoded and unencoded
658  * segments, and so it is possible for g_hostname_is_non_ascii() and
659  * g_hostname_is_ascii_encoded() to both return %TRUE for a name.
660  *
661  * Returns: %TRUE if @hostname contains any ASCII-encoded
662  * segments.
663  *
664  * Since: 2.22
665  **/
666 gboolean
667 g_hostname_is_ascii_encoded (const gchar *hostname)
668 {
669   while (1)
670     {
671       if (!g_ascii_strncasecmp (hostname, IDNA_ACE_PREFIX, IDNA_ACE_PREFIX_LEN))
<span class="line-modified">672   return TRUE;</span>
673       hostname = idna_end_of_label (hostname);
674       if (*hostname)
675         hostname = g_utf8_next_char (hostname);
676       if (!*hostname)
<span class="line-modified">677   return FALSE;</span>
678     }
679 }
680 
681 /**
682  * g_hostname_is_ip_address:
683  * @hostname: a hostname (or IP address in string form)
684  *
685  * Tests if @hostname is the string form of an IPv4 or IPv6 address.
686  * (Eg, &quot;192.168.0.1&quot;.)
687  *
688  * Returns: %TRUE if @hostname is an IP address
689  *
690  * Since: 2.22
691  **/
692 gboolean
693 g_hostname_is_ip_address (const gchar *hostname)
694 {
695   gchar *p, *end;
696   gint nsegments, octet;
697 
</pre>
<hr />
<pre>
769   for (nsegments = 0; nsegments &lt; 4; nsegments++)
770     {
771       if (nsegments != 0)
772         {
773           if (*p != &#39;.&#39;)
774             return FALSE;
775           p++;
776         }
777 
778       /* Check the segment; a little tricker than the IPv6 case since
779        * we can&#39;t allow extra leading 0s, and we can&#39;t assume that all
780        * strings of valid length are within range.
781        */
782       octet = 0;
783       if (*p == &#39;0&#39;)
784         end = p + 1;
785       else
786         {
787           for (end = p; g_ascii_isdigit (*end); end++)
788             {
<span class="line-modified">789               octet = 10 * octet + (*end - &#39;0&#39;);</span>
790 
791               if (octet &gt; 255)
792                 break;
<span class="line-modified">793             }</span>
794         }
795       if (end == p || end &gt; p + 3 || octet &gt; 255)
796         return FALSE;
797 
798       p = end;
799     }
800 
801   /* If there&#39;s nothing left to parse, then it&#39;s ok. */
802   return !*p;
803 }
</pre>
</td>
</tr>
</table>
<center><a href="ghook.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="giochannel.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>