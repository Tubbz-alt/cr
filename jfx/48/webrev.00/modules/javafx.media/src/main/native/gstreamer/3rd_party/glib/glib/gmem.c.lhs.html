<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmem.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* GLIB - Library of useful routines for C programming
  2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Lesser General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2.1 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Lesser General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Lesser General Public
 15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 16  */
 17 
 18 /*
 19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
 20  * file for a list of people on the GLib Team.  See the ChangeLog
 21  * files for a list of changes.  These files are distributed with
 22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
 23  */
 24 
 25 /*
 26  * MT safe
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 
 31 #include &quot;gmem.h&quot;
 32 
 33 #include &lt;stdlib.h&gt;
 34 #include &lt;string.h&gt;
 35 #include &lt;signal.h&gt;
 36 
 37 #include &quot;gslice.h&quot;
 38 #include &quot;gbacktrace.h&quot;
 39 #include &quot;gtestutils.h&quot;
 40 #include &quot;gthread.h&quot;
 41 #include &quot;glib_trace.h&quot;
 42 
 43 /* notes on macros:
 44  * having G_DISABLE_CHECKS defined disables use of glib_mem_profiler_table and
 45  * g_mem_profile().
 46  * If g_mem_gc_friendly is TRUE, freed memory should be 0-wiped.
 47  */
 48 
 49 /* --- variables --- */
 50 static GMemVTable glib_mem_vtable = {
 51   malloc,
 52   realloc,
 53   free,
 54   calloc,
 55   malloc,
 56   realloc,
 57 };
 58 
 59 /**
 60  * SECTION:memory
 61  * @Short_Description: general memory-handling
 62  * @Title: Memory Allocation
 63  *
 64  * These functions provide support for allocating and freeing memory.
 65  *
 66  * If any call to allocate memory using functions g_new(), g_new0(), g_renew(),
 67  * g_malloc(), g_malloc0(), g_malloc0_n(), g_realloc(), and g_realloc_n()
 68  * fails, the application is terminated. This also means that there is no
 69  * need to check if the call succeeded. On the other hand, g_try_...() family
 70  * of functions returns %NULL on failure that can be used as a check
 71  * for unsuccessful memory allocation. The application is not terminated
 72  * in this case.
 73  *
 74  * It&#39;s important to match g_malloc() (and wrappers such as g_new()) with
 75  * g_free(), g_slice_alloc() (and wrappers such as g_slice_new()) with
 76  * g_slice_free(), plain malloc() with free(), and (if you&#39;re using C++)
 77  * new with delete and new[] with delete[]. Otherwise bad things can happen,
 78  * since these allocators may use different memory pools (and new/delete call
 79  * constructors and destructors).
 80  */
 81 
 82 /* --- functions --- */
 83 /**
 84  * g_malloc:
 85  * @n_bytes: the number of bytes to allocate
 86  *
 87  * Allocates @n_bytes bytes of memory.
 88  * If @n_bytes is 0 it returns %NULL.
 89  *
 90  * Returns: a pointer to the allocated memory
 91  */
 92 gpointer
 93 g_malloc (gsize n_bytes)
 94 {
 95   if (G_LIKELY (n_bytes))
 96     {
 97       gpointer mem;
 98 
 99       mem = malloc (n_bytes);
100       TRACE (GLIB_MEM_ALLOC((void*) mem, (unsigned int) n_bytes, 0, 0));
101       if (mem)
<a name="1" id="anc1"></a><span class="line-modified">102     return mem;</span>
103 
104       g_error (&quot;%s: failed to allocate %&quot;G_GSIZE_FORMAT&quot; bytes&quot;,
105                G_STRLOC, n_bytes);
106     }
107 
108   TRACE(GLIB_MEM_ALLOC((void*) NULL, (int) n_bytes, 0, 0));
109 
110   return NULL;
111 }
112 
113 /**
114  * g_malloc0:
115  * @n_bytes: the number of bytes to allocate
116  *
117  * Allocates @n_bytes bytes of memory, initialized to 0&#39;s.
118  * If @n_bytes is 0 it returns %NULL.
119  *
120  * Returns: a pointer to the allocated memory
121  */
122 gpointer
123 g_malloc0 (gsize n_bytes)
124 {
125   if (G_LIKELY (n_bytes))
126     {
127       gpointer mem;
128 
129       mem = calloc (1, n_bytes);
130       TRACE (GLIB_MEM_ALLOC((void*) mem, (unsigned int) n_bytes, 1, 0));
131       if (mem)
<a name="2" id="anc2"></a><span class="line-modified">132     return mem;</span>
133 
134       g_error (&quot;%s: failed to allocate %&quot;G_GSIZE_FORMAT&quot; bytes&quot;,
135                G_STRLOC, n_bytes);
136     }
137 
138   TRACE(GLIB_MEM_ALLOC((void*) NULL, (int) n_bytes, 1, 0));
139 
140   return NULL;
141 }
142 
143 /**
144  * g_realloc:
145  * @mem: (nullable): the memory to reallocate
146  * @n_bytes: new size of the memory in bytes
147  *
148  * Reallocates the memory pointed to by @mem, so that it now has space for
149  * @n_bytes bytes of memory. It returns the new address of the memory, which may
150  * have been moved. @mem may be %NULL, in which case it&#39;s considered to
151  * have zero-length. @n_bytes may be 0, in which case %NULL will be returned
152  * and @mem will be freed unless it is %NULL.
153  *
154  * Returns: the new address of the allocated memory
155  */
156 gpointer
157 g_realloc (gpointer mem,
<a name="3" id="anc3"></a><span class="line-modified">158        gsize    n_bytes)</span>
159 {
160   gpointer newmem;
161 
162   if (G_LIKELY (n_bytes))
163     {
164       newmem = realloc (mem, n_bytes);
165       TRACE (GLIB_MEM_REALLOC((void*) newmem, (void*)mem, (unsigned int) n_bytes, 0));
166       if (newmem)
<a name="4" id="anc4"></a><span class="line-modified">167     return newmem;</span>
168 
169       g_error (&quot;%s: failed to allocate %&quot;G_GSIZE_FORMAT&quot; bytes&quot;,
170                G_STRLOC, n_bytes);
171     }
172 
<a name="5" id="anc5"></a><span class="line-modified">173   if (mem)</span>
<span class="line-removed">174     free (mem);</span>
175 
176   TRACE (GLIB_MEM_REALLOC((void*) NULL, (void*)mem, 0, 0));
177 
178   return NULL;
179 }
180 
181 /**
182  * g_free:
183  * @mem: (nullable): the memory to free
184  *
185  * Frees the memory pointed to by @mem.
186  *
187  * If @mem is %NULL it simply returns, so there is no need to check @mem
188  * against %NULL before calling this function.
189  */
190 void
191 g_free (gpointer mem)
192 {
<a name="6" id="anc6"></a><span class="line-modified">193   if (G_LIKELY (mem))</span>
<span class="line-removed">194     free (mem);</span>
195   TRACE(GLIB_MEM_FREE((void*) mem));
196 }
197 
198 /**
199  * g_clear_pointer: (skip)
200  * @pp: (not nullable): a pointer to a variable, struct member etc. holding a
201  *    pointer
202  * @destroy: a function to which a gpointer can be passed, to destroy *@pp
203  *
204  * Clears a reference to a variable.
205  *
206  * @pp must not be %NULL.
207  *
208  * If the reference is %NULL then this function does nothing.
209  * Otherwise, the variable is destroyed using @destroy and the
210  * pointer is set to %NULL.
211  *
212  * A macro is also included that allows this function to be used without
213  * pointer casts. This will mask any warnings about incompatible function types
214  * or calling conventions, so you must ensure that your @destroy function is
215  * compatible with being called as `GDestroyNotify` using the standard calling
216  * convention for the platform that GLib was compiled for; otherwise the program
217  * will experience undefined behaviour.
218  *
219  * Since: 2.34
220  **/
221 #undef g_clear_pointer
222 void
223 g_clear_pointer (gpointer      *pp,
224                  GDestroyNotify destroy)
225 {
226   gpointer _p;
227 
228   _p = *pp;
229   if (_p)
230     {
231       *pp = NULL;
232       destroy (_p);
233     }
234 }
235 
236 /**
237  * g_try_malloc:
238  * @n_bytes: number of bytes to allocate.
239  *
240  * Attempts to allocate @n_bytes, and returns %NULL on failure.
241  * Contrast with g_malloc(), which aborts the program on failure.
242  *
243  * Returns: the allocated memory, or %NULL.
244  */
245 gpointer
246 g_try_malloc (gsize n_bytes)
247 {
248   gpointer mem;
249 
250   if (G_LIKELY (n_bytes))
251     mem = malloc (n_bytes);
252   else
253     mem = NULL;
254 
255   TRACE (GLIB_MEM_ALLOC((void*) mem, (unsigned int) n_bytes, 0, 1));
256 
257   return mem;
258 }
259 
260 /**
261  * g_try_malloc0:
262  * @n_bytes: number of bytes to allocate
263  *
264  * Attempts to allocate @n_bytes, initialized to 0&#39;s, and returns %NULL on
265  * failure. Contrast with g_malloc0(), which aborts the program on failure.
266  *
267  * Since: 2.8
268  * Returns: the allocated memory, or %NULL
269  */
270 gpointer
271 g_try_malloc0 (gsize n_bytes)
272 {
273   gpointer mem;
274 
275   if (G_LIKELY (n_bytes))
276     mem = calloc (1, n_bytes);
277   else
278     mem = NULL;
279 
280   return mem;
281 }
282 
283 /**
284  * g_try_realloc:
285  * @mem: (nullable): previously-allocated memory, or %NULL.
286  * @n_bytes: number of bytes to allocate.
287  *
288  * Attempts to realloc @mem to a new size, @n_bytes, and returns %NULL
289  * on failure. Contrast with g_realloc(), which aborts the program
290  * on failure.
291  *
292  * If @mem is %NULL, behaves the same as g_try_malloc().
293  *
294  * Returns: the allocated memory, or %NULL.
295  */
296 gpointer
297 g_try_realloc (gpointer mem,
<a name="7" id="anc7"></a><span class="line-modified">298            gsize    n_bytes)</span>
299 {
300   gpointer newmem;
301 
302   if (G_LIKELY (n_bytes))
303     newmem = realloc (mem, n_bytes);
304   else
305     {
306       newmem = NULL;
<a name="8" id="anc8"></a><span class="line-modified">307       if (mem)</span>
<span class="line-removed">308     free (mem);</span>
309     }
310 
311   TRACE (GLIB_MEM_REALLOC((void*) newmem, (void*)mem, (unsigned int) n_bytes, 1));
312 
313   return newmem;
314 }
315 
316 
317 #define SIZE_OVERFLOWS(a,b) (G_UNLIKELY ((b) &gt; 0 &amp;&amp; (a) &gt; G_MAXSIZE / (b)))
318 
319 /**
320  * g_malloc_n:
321  * @n_blocks: the number of blocks to allocate
322  * @n_block_bytes: the size of each block in bytes
323  *
324  * This function is similar to g_malloc(), allocating (@n_blocks * @n_block_bytes) bytes,
325  * but care is taken to detect possible overflow during multiplication.
326  *
327  * Since: 2.24
328  * Returns: a pointer to the allocated memory
329  */
330 gpointer
331 g_malloc_n (gsize n_blocks,
<a name="9" id="anc9"></a><span class="line-modified">332         gsize n_block_bytes)</span>
333 {
334   if (SIZE_OVERFLOWS (n_blocks, n_block_bytes))
335     {
336       g_error (&quot;%s: overflow allocating %&quot;G_GSIZE_FORMAT&quot;*%&quot;G_GSIZE_FORMAT&quot; bytes&quot;,
337                G_STRLOC, n_blocks, n_block_bytes);
338     }
339 
340   return g_malloc (n_blocks * n_block_bytes);
341 }
342 
343 /**
344  * g_malloc0_n:
345  * @n_blocks: the number of blocks to allocate
346  * @n_block_bytes: the size of each block in bytes
347  *
348  * This function is similar to g_malloc0(), allocating (@n_blocks * @n_block_bytes) bytes,
349  * but care is taken to detect possible overflow during multiplication.
350  *
351  * Since: 2.24
352  * Returns: a pointer to the allocated memory
353  */
354 gpointer
355 g_malloc0_n (gsize n_blocks,
<a name="10" id="anc10"></a><span class="line-modified">356          gsize n_block_bytes)</span>
357 {
358   if (SIZE_OVERFLOWS (n_blocks, n_block_bytes))
359     {
360       g_error (&quot;%s: overflow allocating %&quot;G_GSIZE_FORMAT&quot;*%&quot;G_GSIZE_FORMAT&quot; bytes&quot;,
361                G_STRLOC, n_blocks, n_block_bytes);
362     }
363 
364   return g_malloc0 (n_blocks * n_block_bytes);
365 }
366 
367 /**
368  * g_realloc_n:
369  * @mem: (nullable): the memory to reallocate
370  * @n_blocks: the number of blocks to allocate
371  * @n_block_bytes: the size of each block in bytes
372  *
373  * This function is similar to g_realloc(), allocating (@n_blocks * @n_block_bytes) bytes,
374  * but care is taken to detect possible overflow during multiplication.
375  *
376  * Since: 2.24
377  * Returns: the new address of the allocated memory
378  */
379 gpointer
380 g_realloc_n (gpointer mem,
<a name="11" id="anc11"></a><span class="line-modified">381          gsize    n_blocks,</span>
<span class="line-modified">382          gsize    n_block_bytes)</span>
383 {
384   if (SIZE_OVERFLOWS (n_blocks, n_block_bytes))
385     {
386       g_error (&quot;%s: overflow allocating %&quot;G_GSIZE_FORMAT&quot;*%&quot;G_GSIZE_FORMAT&quot; bytes&quot;,
387                G_STRLOC, n_blocks, n_block_bytes);
388     }
389 
390   return g_realloc (mem, n_blocks * n_block_bytes);
391 }
392 
393 /**
394  * g_try_malloc_n:
395  * @n_blocks: the number of blocks to allocate
396  * @n_block_bytes: the size of each block in bytes
397  *
398  * This function is similar to g_try_malloc(), allocating (@n_blocks * @n_block_bytes) bytes,
399  * but care is taken to detect possible overflow during multiplication.
400  *
401  * Since: 2.24
402  * Returns: the allocated memory, or %NULL.
403  */
404 gpointer
405 g_try_malloc_n (gsize n_blocks,
<a name="12" id="anc12"></a><span class="line-modified">406         gsize n_block_bytes)</span>
407 {
408   if (SIZE_OVERFLOWS (n_blocks, n_block_bytes))
409     return NULL;
410 
411   return g_try_malloc (n_blocks * n_block_bytes);
412 }
413 
414 /**
415  * g_try_malloc0_n:
416  * @n_blocks: the number of blocks to allocate
417  * @n_block_bytes: the size of each block in bytes
418  *
419  * This function is similar to g_try_malloc0(), allocating (@n_blocks * @n_block_bytes) bytes,
420  * but care is taken to detect possible overflow during multiplication.
421  *
422  * Since: 2.24
423  * Returns: the allocated memory, or %NULL
424  */
425 gpointer
426 g_try_malloc0_n (gsize n_blocks,
<a name="13" id="anc13"></a><span class="line-modified">427          gsize n_block_bytes)</span>
428 {
429   if (SIZE_OVERFLOWS (n_blocks, n_block_bytes))
430     return NULL;
431 
432   return g_try_malloc0 (n_blocks * n_block_bytes);
433 }
434 
435 /**
436  * g_try_realloc_n:
437  * @mem: (nullable): previously-allocated memory, or %NULL.
438  * @n_blocks: the number of blocks to allocate
439  * @n_block_bytes: the size of each block in bytes
440  *
441  * This function is similar to g_try_realloc(), allocating (@n_blocks * @n_block_bytes) bytes,
442  * but care is taken to detect possible overflow during multiplication.
443  *
444  * Since: 2.24
445  * Returns: the allocated memory, or %NULL.
446  */
447 gpointer
448 g_try_realloc_n (gpointer mem,
<a name="14" id="anc14"></a><span class="line-modified">449          gsize    n_blocks,</span>
<span class="line-modified">450          gsize    n_block_bytes)</span>
451 {
452   if (SIZE_OVERFLOWS (n_blocks, n_block_bytes))
453     return NULL;
454 
455   return g_try_realloc (mem, n_blocks * n_block_bytes);
456 }
457 
458 /**
459  * g_mem_is_system_malloc:
460  *
461  * Checks whether the allocator used by g_malloc() is the system&#39;s
462  * malloc implementation. If it returns %TRUE memory allocated with
463  * malloc() can be used interchangeable with memory allocated using g_malloc().
464  * This function is useful for avoiding an extra copy of allocated memory returned
465  * by a non-GLib-based API.
466  *
467  * Returns: if %TRUE, malloc() and g_malloc() can be mixed.
468  *
469  * Deprecated: 2.46: GLib always uses the system malloc, so this function always
470  * returns %TRUE.
471  **/
472 gboolean
473 g_mem_is_system_malloc (void)
474 {
475   return TRUE;
476 }
477 
478 /**
479  * g_mem_set_vtable:
480  * @vtable: table of memory allocation routines.
481  *
482  * This function used to let you override the memory allocation function.
483  * However, its use was incompatible with the use of global constructors
484  * in GLib and GIO, because those use the GLib allocators before main is
485  * reached. Therefore this function is now deprecated and is just a stub.
486  *
487  * Deprecated: 2.46: This function now does nothing. Use other memory
488  * profiling tools instead
489  */
490 void
491 g_mem_set_vtable (GMemVTable *vtable)
492 {
493   g_warning (G_STRLOC &quot;: custom memory allocation vtable not supported&quot;);
<a name="15" id="anc15"></a><span class="line-modified">494     }</span>
495 
496 
497 /**
498  * glib_mem_profiler_table:
499  *
500  * Used to be a #GMemVTable containing profiling variants of the memory
501  * allocation functions, but this variable shouldn&#39;t be modified anymore.
502  *
503  * Deprecated: 2.46: Use other memory profiling tools instead
504  */
505 GMemVTable *glib_mem_profiler_table = &amp;glib_mem_vtable;
506 
507 /**
508  * g_mem_profile:
509  *
510  * GLib used to support some tools for memory profiling, but this
511  * no longer works. There are many other useful tools for memory
512  * profiling these days which can be used instead.
513  *
514  * Deprecated: 2.46: Use other memory profiling tools instead
515  */
516 void
517 g_mem_profile (void)
518 {
519   g_warning (G_STRLOC &quot;: memory profiling not supported&quot;);
<a name="16" id="anc16"></a><span class="line-modified">520     }</span>
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>