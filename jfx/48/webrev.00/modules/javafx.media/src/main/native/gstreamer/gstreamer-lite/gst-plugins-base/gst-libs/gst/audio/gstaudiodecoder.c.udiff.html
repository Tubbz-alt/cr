<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudiodecoder.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstaudiobasesrc.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstaudiodecoder.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudiodecoder.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -91,11 +91,14 @@</span>
   * and upstream exceeds #GstAudioDecoder:tolerance, then resync to upstream
   * occurs (which would happen always if the tolerance mechanism is disabled).
   *
   * In non-live pipelines, baseclass can also (configurably) arrange for
   * output buffer aggregation which may help to redue large(r) numbers of
<span class="udiff-line-modified-removed">-  * small(er) buffers being pushed and processed downstream.</span>
<span class="udiff-line-modified-added">+  * small(er) buffers being pushed and processed downstream. Note that this</span>
<span class="udiff-line-added">+  * feature is only available if the buffer layout is interleaved. For planar</span>
<span class="udiff-line-added">+  * buffers, the decoder implementation is fully responsible for the output</span>
<span class="udiff-line-added">+  * buffer size.</span>
   *
   * On the other hand, it should be noted that baseclass only provides limited
   * seeking support (upon explicit subclass request), as full-fledged support
   * should rather be left to upstream demuxer, parser or alike.  This simple
   * approach caters for seeking and duration reporting using estimated input
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -127,14 +130,10 @@</span>
  #include &lt;string.h&gt;
  
  GST_DEBUG_CATEGORY (audiodecoder_debug);
  #define GST_CAT_DEFAULT audiodecoder_debug
  
<span class="udiff-line-removed">- #define GST_AUDIO_DECODER_GET_PRIVATE(obj)  \</span>
<span class="udiff-line-removed">-     (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_AUDIO_DECODER, \</span>
<span class="udiff-line-removed">-         GstAudioDecoderPrivate))</span>
<span class="udiff-line-removed">- </span>
  enum
  {
    LAST_SIGNAL
  };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -157,10 +156,11 @@</span>
    /* last negotiated input caps */
    GstCaps *input_caps;
  
    /* (output) audio format */
    GstAudioInfo info;
<span class="udiff-line-added">+   GstCaps *caps;</span>
    gboolean output_format_changed;
  
    /* parsing state */
    gboolean eos;
    gboolean sync;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -215,10 +215,12 @@</span>
    /* input_segment are output_segment identical */
    gboolean in_out_segment_sync;
    /* expecting the buffer with DISCONT flag */
    gboolean expecting_discont_buf;
  
<span class="udiff-line-added">+   /* number of samples pushed out via _finish_subframe(), resets on _finish_frame() */</span>
<span class="udiff-line-added">+   guint subframe_samples;</span>
  
    /* input bps estimatation */
    /* global in bytes seen */
    guint64 bytes_in;
    /* global samples sent out */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -309,11 +311,16 @@</span>
      GstQuery * query);
  
  static gboolean gst_audio_decoder_transform_meta_default (GstAudioDecoder *
      decoder, GstBuffer * outbuf, GstMeta * meta, GstBuffer * inbuf);
  
<span class="udiff-line-added">+ static GstFlowReturn</span>
<span class="udiff-line-added">+ gst_audio_decoder_finish_frame_or_subframe (GstAudioDecoder * dec,</span>
<span class="udiff-line-added">+     GstBuffer * buf, gint frames);</span>
<span class="udiff-line-added">+ </span>
  static GstElementClass *parent_class = NULL;
<span class="udiff-line-added">+ static gint private_offset = 0;</span>
  
  static void gst_audio_decoder_class_init (GstAudioDecoderClass * klass);
  static void gst_audio_decoder_init (GstAudioDecoder * dec,
      GstAudioDecoderClass * klass);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -336,15 +343,24 @@</span>
        (GInstanceInitFunc) gst_audio_decoder_init,
      };
  
      _type = g_type_register_static (GST_TYPE_ELEMENT,
          &quot;GstAudioDecoder&quot;, &amp;audio_decoder_info, G_TYPE_FLAG_ABSTRACT);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private_offset =</span>
<span class="udiff-line-added">+         g_type_add_instance_private (_type, sizeof (GstAudioDecoderPrivate));</span>
<span class="udiff-line-added">+ </span>
      g_once_init_leave (&amp;audio_decoder_type, _type);
    }
    return audio_decoder_type;
  }
  
<span class="udiff-line-added">+ static inline GstAudioDecoderPrivate *</span>
<span class="udiff-line-added">+ gst_audio_decoder_get_instance_private (GstAudioDecoder * self)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   return (G_STRUCT_MEMBER_P (self, private_offset));</span>
<span class="udiff-line-added">+ }</span>
  
  static void
  gst_audio_decoder_class_init (GstAudioDecoderClass * klass)
  {
    GObjectClass *gobject_class;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -355,11 +371,12 @@</span>
    element_class = GST_ELEMENT_CLASS (klass);
    audiodecoder_class = GST_AUDIO_DECODER_CLASS (klass);
  
    parent_class = g_type_class_peek_parent (klass);
  
<span class="udiff-line-modified-removed">-   g_type_class_add_private (klass, sizeof (GstAudioDecoderPrivate));</span>
<span class="udiff-line-modified-added">+   if (private_offset != 0)</span>
<span class="udiff-line-added">+     g_type_class_adjust_private_offset (klass, &amp;private_offset);</span>
  
    GST_DEBUG_CATEGORY_INIT (audiodecoder_debug, &quot;audiodecoder&quot;, 0,
        &quot;audio decoder base class&quot;);
  
    gobject_class-&gt;set_property = gst_audio_decoder_set_property;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -410,11 +427,11 @@</span>
  {
    GstPadTemplate *pad_template;
  
    GST_DEBUG_OBJECT (dec, &quot;gst_audio_decoder_init&quot;);
  
<span class="udiff-line-modified-removed">-   dec-&gt;priv = GST_AUDIO_DECODER_GET_PRIVATE (dec);</span>
<span class="udiff-line-modified-added">+   dec-&gt;priv = gst_audio_decoder_get_instance_private (dec);</span>
  
    /* Setup sink pad */
    pad_template =
        gst_element_class_get_pad_template (GST_ELEMENT_CLASS (klass), &quot;sink&quot;);
    g_return_if_fail (pad_template != NULL);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -501,10 +518,11 @@</span>
      if (dec-&gt;priv-&gt;ctx.allocator)
        gst_object_unref (dec-&gt;priv-&gt;ctx.allocator);
  
      GST_OBJECT_LOCK (dec);
      gst_caps_replace (&amp;dec-&gt;priv-&gt;ctx.input_caps, NULL);
<span class="udiff-line-added">+     gst_caps_replace (&amp;dec-&gt;priv-&gt;ctx.caps, NULL);</span>
      gst_caps_replace (&amp;dec-&gt;priv-&gt;ctx.allocation_caps, NULL);
  
      memset (&amp;dec-&gt;priv-&gt;ctx, 0, sizeof (dec-&gt;priv-&gt;ctx));
  
      gst_audio_info_init (&amp;dec-&gt;priv-&gt;ctx.info);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -613,14 +631,15 @@</span>
    GstAllocator *allocator;
    GstAllocationParams params;
  
    g_return_val_if_fail (GST_IS_AUDIO_DECODER (dec), FALSE);
    g_return_val_if_fail (GST_AUDIO_INFO_IS_VALID (&amp;dec-&gt;priv-&gt;ctx.info), FALSE);
<span class="udiff-line-added">+   g_return_val_if_fail (GST_IS_CAPS (dec-&gt;priv-&gt;ctx.caps), FALSE);</span>
  
    klass = GST_AUDIO_DECODER_GET_CLASS (dec);
  
<span class="udiff-line-modified-removed">-   caps = gst_audio_info_to_caps (&amp;dec-&gt;priv-&gt;ctx.info);</span>
<span class="udiff-line-modified-added">+   caps = dec-&gt;priv-&gt;ctx.caps;</span>
    if (dec-&gt;priv-&gt;ctx.allocation_caps == NULL)
      dec-&gt;priv-&gt;ctx.allocation_caps = gst_caps_ref (caps);
  
    GST_DEBUG_OBJECT (dec, &quot;setting src caps %&quot; GST_PTR_FORMAT, caps);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -685,11 +704,10 @@</span>
  
  done:
  
    if (query)
      gst_query_unref (query);
<span class="udiff-line-removed">-   gst_caps_unref (caps);</span>
  
    return res;
  
    /* ERRORS */
  no_decide_allocation:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -755,25 +773,62 @@</span>
  gboolean
  gst_audio_decoder_set_output_format (GstAudioDecoder * dec,
      const GstAudioInfo * info)
  {
    gboolean res = TRUE;
<span class="udiff-line-removed">-   guint old_rate;</span>
    GstCaps *caps = NULL;
<span class="udiff-line-removed">-   GstCaps *templ_caps;</span>
  
    g_return_val_if_fail (GST_IS_AUDIO_DECODER (dec), FALSE);
    g_return_val_if_fail (GST_AUDIO_INFO_IS_VALID (info), FALSE);
  
<span class="udiff-line-removed">-   GST_DEBUG_OBJECT (dec, &quot;Setting output format&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   GST_AUDIO_DECODER_STREAM_LOCK (dec);</span>
<span class="udiff-line-removed">- </span>
    /* If the audio info can&#39;t be converted to caps,
     * it was invalid */
    caps = gst_audio_info_to_caps (info);
<span class="udiff-line-modified-removed">-   if (!caps)</span>
<span class="udiff-line-modified-added">+   if (!caps) {</span>
<span class="udiff-line-added">+     GST_WARNING_OBJECT (dec, &quot;invalid output format&quot;);</span>
<span class="udiff-line-added">+     return FALSE;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   res = gst_audio_decoder_set_output_caps (dec, caps);</span>
<span class="udiff-line-added">+   gst_caps_unref (caps);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return res;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /**</span>
<span class="udiff-line-added">+  * gst_audio_decoder_set_output_caps:</span>
<span class="udiff-line-added">+  * @dec: a #GstAudioDecoder</span>
<span class="udiff-line-added">+  * @caps: (transfer none): (fixed) #GstCaps</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Configure output caps on the srcpad of @dec. Similar to</span>
<span class="udiff-line-added">+  * gst_audio_decoder_set_output_format(), but allows subclasses to specify</span>
<span class="udiff-line-added">+  * output caps that can&#39;t be expressed via #GstAudioInfo e.g. caps that have</span>
<span class="udiff-line-added">+  * caps features.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Returns: %TRUE on success.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Since: 1.16</span>
<span class="udiff-line-added">+  **/</span>
<span class="udiff-line-added">+ gboolean</span>
<span class="udiff-line-added">+ gst_audio_decoder_set_output_caps (GstAudioDecoder * dec, GstCaps * caps)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   gboolean res = TRUE;</span>
<span class="udiff-line-added">+   guint old_rate;</span>
<span class="udiff-line-added">+   GstCaps *templ_caps;</span>
<span class="udiff-line-added">+   GstAudioInfo info;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   g_return_val_if_fail (GST_IS_AUDIO_DECODER (dec), FALSE);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   GST_DEBUG_OBJECT (dec, &quot;Setting srcpad caps %&quot; GST_PTR_FORMAT, caps);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   GST_AUDIO_DECODER_STREAM_LOCK (dec);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!gst_caps_is_fixed (caps))</span>
<span class="udiff-line-added">+     goto refuse_caps;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   /* check if caps can be parsed */</span>
<span class="udiff-line-added">+   if (!gst_audio_info_from_caps (&amp;info, caps))</span>
      goto refuse_caps;
  
    /* Only allow caps that are a subset of the template caps */
    templ_caps = gst_pad_get_pad_template_caps (dec-&gt;srcpad);
    if (!gst_caps_is_subset (caps, templ_caps)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -792,20 +847,19 @@</span>
      dec-&gt;priv-&gt;samples = 0;
    }
  
    /* copy the GstAudioInfo */
    GST_OBJECT_LOCK (dec);
<span class="udiff-line-modified-removed">-   dec-&gt;priv-&gt;ctx.info = *info;</span>
<span class="udiff-line-modified-added">+   dec-&gt;priv-&gt;ctx.info = info;</span>
    GST_OBJECT_UNLOCK (dec);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   gst_caps_replace (&amp;dec-&gt;priv-&gt;ctx.caps, caps);</span>
    dec-&gt;priv-&gt;ctx.output_format_changed = TRUE;
  
  done:
    GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
  
<span class="udiff-line-removed">-   if (caps)</span>
<span class="udiff-line-removed">-     gst_caps_unref (caps);</span>
<span class="udiff-line-removed">- </span>
    return res;
  
    /* ERRORS */
  refuse_caps:
    {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -910,16 +964,16 @@</span>
    if (G_UNLIKELY (!buf)) {
      GST_DEBUG_OBJECT (dec, &quot;no data after clipping to segment&quot;);
      /* only check and return EOS if upstream still
       * in the same segment and interested as such */
      if (dec-&gt;priv-&gt;in_out_segment_sync) {
<span class="udiff-line-modified-removed">-     if (dec-&gt;output_segment.rate &gt;= 0) {</span>
<span class="udiff-line-modified-removed">-       if (ts &gt;= dec-&gt;output_segment.stop)</span>
<span class="udiff-line-modified-added">+       if (dec-&gt;output_segment.rate &gt;= 0) {</span>
<span class="udiff-line-modified-added">+         if (ts &gt;= dec-&gt;output_segment.stop)</span>
<span class="udiff-line-added">+           ret = GST_FLOW_EOS;</span>
<span class="udiff-line-added">+       } else if (ts &lt; dec-&gt;output_segment.start) {</span>
          ret = GST_FLOW_EOS;
<span class="udiff-line-modified-removed">-     } else if (ts &lt; dec-&gt;output_segment.start) {</span>
<span class="udiff-line-removed">-       ret = GST_FLOW_EOS;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+       }</span>
      }
      goto exit;
    }
  
    /* decorate */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -983,11 +1037,12 @@</span>
          GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
    }
  
  again:
    inbuf = NULL;
<span class="udiff-line-modified-removed">-   if (priv-&gt;agg &amp;&amp; dec-&gt;priv-&gt;latency &gt; 0) {</span>
<span class="udiff-line-modified-added">+   if (priv-&gt;agg &amp;&amp; dec-&gt;priv-&gt;latency &gt; 0 &amp;&amp;</span>
<span class="udiff-line-added">+       priv-&gt;ctx.info.layout == GST_AUDIO_LAYOUT_INTERLEAVED) {</span>
      gint av;
      gboolean assemble = FALSE;
      const GstClockTimeDiff tol = 10 * GST_MSECOND;
      GstClockTimeDiff diff = -100 * GST_MSECOND;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1174,10 +1229,44 @@</span>
          _gst_meta_transform_copy, &amp;copy_data);
    }
    return TRUE;
  }
  
<span class="udiff-line-added">+ /**</span>
<span class="udiff-line-added">+  * gst_audio_decoder_finish_subframe:</span>
<span class="udiff-line-added">+  * @dec: a #GstAudioDecoder</span>
<span class="udiff-line-added">+  * @buf: decoded data</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Collects decoded data and pushes it downstream. This function may be called</span>
<span class="udiff-line-added">+  * multiple times for a given input frame.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * @buf may be NULL in which case it is assumed that the current input frame is</span>
<span class="udiff-line-added">+  * finished. This is equivalent to calling gst_audio_decoder_finish_subframe()</span>
<span class="udiff-line-added">+  * with a NULL buffer and frames=1 after having pushed out all decoded audio</span>
<span class="udiff-line-added">+  * subframes using this function.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * When called with valid data in @buf the source pad caps must have been set</span>
<span class="udiff-line-added">+  * already.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Note that a frame received in #GstAudioDecoderClass.handle_frame() may be</span>
<span class="udiff-line-added">+  * invalidated by a call to this function.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Returns: a #GstFlowReturn that should be escalated to caller (of caller)</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Since: 1.16</span>
<span class="udiff-line-added">+  */</span>
<span class="udiff-line-added">+ GstFlowReturn</span>
<span class="udiff-line-added">+ gst_audio_decoder_finish_subframe (GstAudioDecoder * dec, GstBuffer * buf)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   g_return_val_if_fail (GST_IS_AUDIO_DECODER (dec), GST_FLOW_ERROR);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (buf == NULL)</span>
<span class="udiff-line-added">+     return gst_audio_decoder_finish_frame_or_subframe (dec, NULL, 1);</span>
<span class="udiff-line-added">+   else</span>
<span class="udiff-line-added">+     return gst_audio_decoder_finish_frame_or_subframe (dec, buf, 0);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /**
   * gst_audio_decoder_finish_frame:
   * @dec: a #GstAudioDecoder
   * @buf: decoded data
   * @frames: number of decoded frames represented by decoded data
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1188,66 +1277,92 @@</span>
   * are discarded and considered to have produced no output
   * (e.g. lead-in or setup frames).
   * Otherwise, source pad caps must be set when it is called with valid
   * data in @buf.
   *
<span class="udiff-line-modified-removed">-  * Note that a frame received in gst_audio_decoder_handle_frame() may be</span>
<span class="udiff-line-modified-added">+  * Note that a frame received in #GstAudioDecoderClass.handle_frame() may be</span>
   * invalidated by a call to this function.
   *
   * Returns: a #GstFlowReturn that should be escalated to caller (of caller)
   */
  GstFlowReturn
  gst_audio_decoder_finish_frame (GstAudioDecoder * dec, GstBuffer * buf,
      gint frames)
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   g_return_val_if_fail (GST_IS_AUDIO_DECODER (dec), GST_FLOW_ERROR);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   /* no dummy calls please */</span>
<span class="udiff-line-added">+   g_return_val_if_fail (frames != 0, GST_FLOW_ERROR);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return gst_audio_decoder_finish_frame_or_subframe (dec, buf, frames);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /* frames == 0 indicates that this is a sub-frame and further sub-frames may</span>
<span class="udiff-line-added">+  * follow for the current input frame. */</span>
<span class="udiff-line-added">+ static GstFlowReturn</span>
<span class="udiff-line-added">+ gst_audio_decoder_finish_frame_or_subframe (GstAudioDecoder * dec,</span>
<span class="udiff-line-added">+     GstBuffer * buf, gint frames)</span>
  {
    GstAudioDecoderPrivate *priv;
    GstAudioDecoderContext *ctx;
    GstAudioDecoderClass *klass = GST_AUDIO_DECODER_GET_CLASS (dec);
<span class="udiff-line-modified-removed">-   gint samples = 0;</span>
<span class="udiff-line-modified-added">+   GstAudioMeta *meta;</span>
    GstClockTime ts, next_ts;
<span class="udiff-line-modified-removed">-   gsize size;</span>
<span class="udiff-line-modified-added">+   gsize size, samples = 0;</span>
    GstFlowReturn ret = GST_FLOW_OK;
    GQueue inbufs = G_QUEUE_INIT;
<span class="udiff-line-added">+   gboolean is_subframe = (frames == 0);</span>
<span class="udiff-line-added">+   gboolean do_check_resync;</span>
  
    /* subclass should not hand us no data */
    g_return_val_if_fail (buf == NULL || gst_buffer_get_size (buf) &gt; 0,
        GST_FLOW_ERROR);
<span class="udiff-line-modified-removed">-   /* no dummy calls please */</span>
<span class="udiff-line-modified-removed">-   g_return_val_if_fail (frames != 0, GST_FLOW_ERROR);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   /* if it&#39;s a subframe (frames == 0) we must have a valid buffer */</span>
<span class="udiff-line-added">+   g_assert (!is_subframe || buf != NULL);</span>
  
    priv = dec-&gt;priv;
    ctx = &amp;dec-&gt;priv-&gt;ctx;
<span class="udiff-line-added">+   meta = buf ? gst_buffer_get_audio_meta (buf) : NULL;</span>
    size = buf ? gst_buffer_get_size (buf) : 0;
<span class="udiff-line-added">+   samples = buf ? (meta ? meta-&gt;samples : size / ctx-&gt;info.bpf) : 0;</span>
  
    /* must know the output format by now */
    g_return_val_if_fail (buf == NULL || GST_AUDIO_INFO_IS_VALID (&amp;ctx-&gt;info),
        GST_FLOW_ERROR);
  
    GST_LOG_OBJECT (dec,
        &quot;accepting %&quot; G_GSIZE_FORMAT &quot; bytes == %&quot; G_GSIZE_FORMAT
<span class="udiff-line-modified-removed">-       &quot; samples for %d frames&quot;, buf ? size : -1,</span>
<span class="udiff-line-removed">-       buf ? size / ctx-&gt;info.bpf : -1, frames);</span>
<span class="udiff-line-modified-added">+       &quot; samples for %d frames&quot;, buf ? size : 0, samples, frames);</span>
  
    GST_AUDIO_DECODER_STREAM_LOCK (dec);
  
<span class="udiff-line-modified-removed">-   if (buf) {</span>
<span class="udiff-line-modified-added">+   if (buf != NULL &amp;&amp; priv-&gt;subframe_samples == 0) {</span>
      ret = check_pending_reconfigure (dec);
      if (ret == GST_FLOW_FLUSHING || ret == GST_FLOW_NOT_NEGOTIATED) {
        gst_buffer_unref (buf);
        goto exit;
      }
  
      if (priv-&gt;pending_events)
        send_pending_events (dec);
    }
  
<span class="udiff-line-modified-removed">-   /* output shoud be whole number of sample frames */</span>
<span class="udiff-line-modified-added">+   /* sanity checking */</span>
    if (G_LIKELY (buf &amp;&amp; ctx-&gt;info.bpf)) {
<span class="udiff-line-modified-removed">-     if (size % ctx-&gt;info.bpf)</span>
<span class="udiff-line-modified-removed">-       goto wrong_buffer;</span>
<span class="udiff-line-modified-removed">-     /* per channel least */</span>
<span class="udiff-line-modified-removed">-     samples = size / ctx-&gt;info.bpf;</span>
<span class="udiff-line-modified-added">+     if (!meta || meta-&gt;info.layout == GST_AUDIO_LAYOUT_INTERLEAVED) {</span>
<span class="udiff-line-modified-added">+       /* output shoud be whole number of sample frames */</span>
<span class="udiff-line-modified-added">+       if (size % ctx-&gt;info.bpf)</span>
<span class="udiff-line-modified-added">+         goto wrong_buffer;</span>
<span class="udiff-line-added">+       /* output should have no additional padding */</span>
<span class="udiff-line-added">+       if (samples != size / ctx-&gt;info.bpf)</span>
<span class="udiff-line-added">+         goto wrong_samples;</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       /* can&#39;t have more samples than what the buffer fits */</span>
<span class="udiff-line-added">+       if (samples &gt; size / ctx-&gt;info.bpf)</span>
<span class="udiff-line-added">+         goto wrong_samples;</span>
<span class="udiff-line-added">+     }</span>
    }
  
    /* frame and ts book-keeping */
    if (G_UNLIKELY (frames &lt; 0)) {
      if (G_UNLIKELY (-frames - 1 &gt; priv-&gt;frames.length)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1273,10 +1388,14 @@</span>
      ts = GST_CLOCK_TIME_NONE;
  
    GST_DEBUG_OBJECT (dec, &quot;leading frame ts %&quot; GST_TIME_FORMAT,
        GST_TIME_ARGS (ts));
  
<span class="udiff-line-added">+   if (is_subframe &amp;&amp; priv-&gt;frames.length == 0)</span>
<span class="udiff-line-added">+     goto subframe_without_pending_input_frame;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   /* this will be skipped in the is_subframe case because frames will be 0 */</span>
    while (priv-&gt;frames.length &amp;&amp; frames) {
      g_queue_push_tail (&amp;inbufs, g_queue_pop_head (&amp;priv-&gt;frames));
      dec-&gt;priv-&gt;ctx.delay = dec-&gt;priv-&gt;frames.length;
      frames--;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1294,12 +1413,15 @@</span>
    if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (priv-&gt;base_ts)) &amp;&amp;
        dec-&gt;output_segment.rate &gt; 0.0) {
      priv-&gt;base_ts = dec-&gt;output_segment.start;
    }
  
<span class="udiff-line-modified-removed">-   /* slightly convoluted approach caters for perfect ts if subclass desires */</span>
<span class="udiff-line-modified-removed">-   if (GST_CLOCK_TIME_IS_VALID (ts)) {</span>
<span class="udiff-line-modified-added">+   /* only check for resync at the beginning of an input/output frame */</span>
<span class="udiff-line-modified-added">+   do_check_resync = !is_subframe || priv-&gt;subframe_samples == 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   /* slightly convoluted approach caters for perfect ts if subclass desires. */</span>
<span class="udiff-line-added">+   if (do_check_resync &amp;&amp; GST_CLOCK_TIME_IS_VALID (ts)) {</span>
      if (dec-&gt;priv-&gt;tolerance &gt; 0) {
        GstClockTimeDiff diff;
  
        g_assert (GST_CLOCK_TIME_IS_VALID (priv-&gt;base_ts));
        next_ts = priv-&gt;base_ts +
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1360,10 +1482,20 @@</span>
  
          data.decoder = dec;
          data.outbuf = buf;
          gst_buffer_foreach_meta (l-&gt;data, foreach_metadata, &amp;data);
        }
<span class="udiff-line-added">+     } else if (is_subframe) {</span>
<span class="udiff-line-added">+       CopyMetaData data;</span>
<span class="udiff-line-added">+       GstBuffer *in_buf;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       /* For subframes we assume a 1:N relationship for now, so we just take</span>
<span class="udiff-line-added">+        * metas from the first pending input buf */</span>
<span class="udiff-line-added">+       in_buf = g_queue_peek_head (&amp;priv-&gt;frames);</span>
<span class="udiff-line-added">+       data.decoder = dec;</span>
<span class="udiff-line-added">+       data.outbuf = buf;</span>
<span class="udiff-line-added">+       gst_buffer_foreach_meta (in_buf, foreach_metadata, &amp;data);</span>
      } else {
        GST_WARNING_OBJECT (dec,
            &quot;Can&#39;t copy metadata because input buffers disappeared&quot;);
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1381,24 +1513,50 @@</span>
  
  exit:
    g_queue_foreach (&amp;inbufs, (GFunc) gst_buffer_unref, NULL);
    g_queue_clear (&amp;inbufs);
  
<span class="udiff-line-added">+   if (is_subframe)</span>
<span class="udiff-line-added">+     dec-&gt;priv-&gt;subframe_samples += samples;</span>
<span class="udiff-line-added">+   else</span>
<span class="udiff-line-added">+     dec-&gt;priv-&gt;subframe_samples = 0;</span>
<span class="udiff-line-added">+ </span>
    GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
  
    return ret;
  
    /* ERRORS */
  wrong_buffer:
    {
<span class="udiff-line-added">+     /* arguably more of a programming error? */</span>
      GST_ELEMENT_ERROR (dec, STREAM, DECODE, (NULL),
          (&quot;buffer size %&quot; G_GSIZE_FORMAT &quot; not a multiple of %d&quot;, size,
              ctx-&gt;info.bpf));
      gst_buffer_unref (buf);
      ret = GST_FLOW_ERROR;
      goto exit;
    }
<span class="udiff-line-added">+ wrong_samples:</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     /* arguably more of a programming error? */</span>
<span class="udiff-line-added">+     GST_ELEMENT_ERROR (dec, STREAM, DECODE, (NULL),</span>
<span class="udiff-line-added">+         (&quot;GstAudioMeta samples (%&quot; G_GSIZE_FORMAT &quot;) are inconsistent with &quot;</span>
<span class="udiff-line-added">+             &quot;the buffer size and layout (size/bpf = %&quot; G_GSIZE_FORMAT &quot;)&quot;,</span>
<span class="udiff-line-added">+             meta-&gt;samples, size / ctx-&gt;info.bpf));</span>
<span class="udiff-line-added">+     gst_buffer_unref (buf);</span>
<span class="udiff-line-added">+     ret = GST_FLOW_ERROR;</span>
<span class="udiff-line-added">+     goto exit;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ subframe_without_pending_input_frame:</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     /* arguably more of a programming error? */</span>
<span class="udiff-line-added">+     GST_ELEMENT_ERROR (dec, STREAM, DECODE, (NULL),</span>
<span class="udiff-line-added">+         (&quot;Received decoded subframe, but no pending frame&quot;));</span>
<span class="udiff-line-added">+     gst_buffer_unref (buf);</span>
<span class="udiff-line-added">+     ret = GST_FLOW_ERROR;</span>
<span class="udiff-line-added">+     goto exit;</span>
<span class="udiff-line-added">+   }</span>
  }
  
  static GstFlowReturn
  gst_audio_decoder_handle_frame (GstAudioDecoder * dec,
      GstAudioDecoderClass * klass, GstBuffer * buffer)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1570,41 +1728,41 @@</span>
  
    /* Apply any pending events before draining, as that
     * may update the pending segment info */
    apply_pending_events (dec);
  
<span class="udiff-line-modified-removed">-     /* dispatch reverse pending buffers */</span>
<span class="udiff-line-modified-removed">-     /* chain eventually calls upon drain as well, but by that time</span>
<span class="udiff-line-modified-removed">-      * gather list should be clear, so ok ... */</span>
<span class="udiff-line-modified-removed">-     if (dec-&gt;output_segment.rate &lt; 0.0 &amp;&amp; dec-&gt;priv-&gt;gather)</span>
<span class="udiff-line-modified-removed">-       gst_audio_decoder_chain_reverse (dec, NULL);</span>
<span class="udiff-line-modified-removed">-     /* have subclass give all it can */</span>
<span class="udiff-line-modified-removed">-     ret = gst_audio_decoder_push_buffers (dec, TRUE);</span>
<span class="udiff-line-modified-added">+   /* dispatch reverse pending buffers */</span>
<span class="udiff-line-modified-added">+   /* chain eventually calls upon drain as well, but by that time</span>
<span class="udiff-line-modified-added">+    * gather list should be clear, so ok ... */</span>
<span class="udiff-line-modified-added">+   if (dec-&gt;output_segment.rate &lt; 0.0 &amp;&amp; dec-&gt;priv-&gt;gather)</span>
<span class="udiff-line-modified-added">+     gst_audio_decoder_chain_reverse (dec, NULL);</span>
<span class="udiff-line-modified-added">+   /* have subclass give all it can */</span>
<span class="udiff-line-modified-added">+   ret = gst_audio_decoder_push_buffers (dec, TRUE);</span>
    if (ret != GST_FLOW_OK) {
      GST_WARNING_OBJECT (dec, &quot;audio decoder push buffers failed&quot;);
      goto drain_failed;
    }
<span class="udiff-line-modified-removed">-     /* ensure all output sent */</span>
<span class="udiff-line-modified-removed">-     ret = gst_audio_decoder_output (dec, NULL);</span>
<span class="udiff-line-modified-added">+   /* ensure all output sent */</span>
<span class="udiff-line-modified-added">+   ret = gst_audio_decoder_output (dec, NULL);</span>
    if (ret != GST_FLOW_OK)
      GST_WARNING_OBJECT (dec, &quot;audio decoder output failed&quot;);
  
  drain_failed:
<span class="udiff-line-modified-removed">-     /* everything should be away now */</span>
<span class="udiff-line-modified-removed">-     if (dec-&gt;priv-&gt;frames.length) {</span>
<span class="udiff-line-modified-removed">-       /* not fatal/impossible though if subclass/codec eats stuff */</span>
<span class="udiff-line-modified-removed">-       GST_WARNING_OBJECT (dec, &quot;still %d frames left after draining&quot;,</span>
<span class="udiff-line-modified-removed">-           dec-&gt;priv-&gt;frames.length);</span>
<span class="udiff-line-modified-removed">-       g_queue_foreach (&amp;dec-&gt;priv-&gt;frames, (GFunc) gst_buffer_unref, NULL);</span>
<span class="udiff-line-modified-removed">-       g_queue_clear (&amp;dec-&gt;priv-&gt;frames);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /* discard (unparsed) leftover */</span>
<span class="udiff-line-removed">-     gst_adapter_clear (dec-&gt;priv-&gt;adapter);</span>
<span class="udiff-line-removed">-     return ret;</span>
<span class="udiff-line-modified-added">+   /* everything should be away now */</span>
<span class="udiff-line-modified-added">+   if (dec-&gt;priv-&gt;frames.length) {</span>
<span class="udiff-line-modified-added">+     /* not fatal/impossible though if subclass/codec eats stuff */</span>
<span class="udiff-line-modified-added">+     GST_WARNING_OBJECT (dec, &quot;still %d frames left after draining&quot;,</span>
<span class="udiff-line-modified-added">+         dec-&gt;priv-&gt;frames.length);</span>
<span class="udiff-line-modified-added">+     g_queue_foreach (&amp;dec-&gt;priv-&gt;frames, (GFunc) gst_buffer_unref, NULL);</span>
<span class="udiff-line-modified-added">+     g_queue_clear (&amp;dec-&gt;priv-&gt;frames);</span>
    }
  
<span class="udiff-line-added">+   /* discard (unparsed) leftover */</span>
<span class="udiff-line-added">+   gst_adapter_clear (dec-&gt;priv-&gt;adapter);</span>
<span class="udiff-line-added">+   return ret;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  /* hard == FLUSH, otherwise discont */
  static GstFlowReturn
  gst_audio_decoder_flush (GstAudioDecoder * dec, gboolean hard)
  {
    GstAudioDecoderClass *klass;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2002,18 +2160,18 @@</span>
    }
  
    for (i = 0; i &lt; caps_size; i++) {
      structure = gst_caps_get_structure (caps, i);
      if (gst_structure_has_field (structure, &quot;channels&quot;))
<span class="udiff-line-modified-removed">-     gst_structure_fixate_field_nearest_int (structure,</span>
<span class="udiff-line-modified-removed">-         &quot;channels&quot;, GST_AUDIO_DEF_CHANNELS);</span>
<span class="udiff-line-modified-added">+       gst_structure_fixate_field_nearest_int (structure,</span>
<span class="udiff-line-modified-added">+           &quot;channels&quot;, GST_AUDIO_DEF_CHANNELS);</span>
      else
        gst_structure_set (structure, &quot;channels&quot;, G_TYPE_INT,
            GST_AUDIO_DEF_CHANNELS, NULL);
      if (gst_structure_has_field (structure, &quot;rate&quot;))
<span class="udiff-line-modified-removed">-     gst_structure_fixate_field_nearest_int (structure,</span>
<span class="udiff-line-modified-removed">-         &quot;rate&quot;, GST_AUDIO_DEF_RATE);</span>
<span class="udiff-line-modified-added">+       gst_structure_fixate_field_nearest_int (structure,</span>
<span class="udiff-line-modified-added">+           &quot;rate&quot;, GST_AUDIO_DEF_RATE);</span>
      else
        gst_structure_set (structure, &quot;rate&quot;, G_TYPE_INT, GST_AUDIO_DEF_RATE,
            NULL);
    }
    caps = gst_caps_fixate (caps);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2035,15 +2193,15 @@</span>
    if (!caps || !gst_audio_info_from_caps (&amp;info, caps))
      goto caps_error;
  
    GST_OBJECT_LOCK (dec);
    dec-&gt;priv-&gt;ctx.info = info;
<span class="udiff-line-added">+   dec-&gt;priv-&gt;ctx.caps = caps;</span>
    GST_OBJECT_UNLOCK (dec);
  
    GST_INFO_OBJECT (dec,
        &quot;Chose default caps %&quot; GST_PTR_FORMAT &quot; for initial gap&quot;, caps);
<span class="udiff-line-removed">-   gst_caps_unref (caps);</span>
  
    return TRUE;
  
  caps_error:
    {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2065,10 +2223,11 @@</span>
    if (!GST_AUDIO_INFO_IS_VALID (&amp;dec-&gt;priv-&gt;ctx.info)) {
      if (!gst_audio_decoder_negotiate_default_caps (dec)) {
        GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
        GST_ELEMENT_ERROR (dec, STREAM, FORMAT, (NULL),
            (&quot;Decoder output not negotiated before GAP event.&quot;));
<span class="udiff-line-added">+       gst_event_unref (event);</span>
        return FALSE;
      }
      needs_reconfigure = TRUE;
    }
    needs_reconfigure = gst_pad_check_reconfigure (dec-&gt;srcpad)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2113,14 +2272,15 @@</span>
      if (flowret == GST_FLOW_OK) {
        send_pending_events (dec);
        ret = gst_audio_decoder_push_event (dec, event);
      } else {
        ret = FALSE;
<span class="udiff-line-added">+       gst_event_unref (event);</span>
      }
    }
    return ret;
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+ }</span>
  
  static GList *
  _flush_events (GstPad * pad, GList * events)
  {
    GList *tmp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2204,16 +2364,16 @@</span>
          }
        }
  
        /* prepare for next segment */
        /* Use the segment start as a base timestamp
<span class="udiff-line-modified-removed">-          * in case upstream does not come up with anything better</span>
<span class="udiff-line-modified-removed">-          * (e.g. upstream BYTE) */</span>
<span class="udiff-line-modified-removed">-         if (format != GST_FORMAT_TIME) {</span>
<span class="udiff-line-modified-removed">-           dec-&gt;priv-&gt;base_ts = seg.start;</span>
<span class="udiff-line-modified-removed">-           dec-&gt;priv-&gt;samples = 0;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+        * in case upstream does not come up with anything better</span>
<span class="udiff-line-modified-added">+        * (e.g. upstream BYTE) */</span>
<span class="udiff-line-modified-added">+       if (format != GST_FORMAT_TIME) {</span>
<span class="udiff-line-modified-added">+         dec-&gt;priv-&gt;base_ts = seg.start;</span>
<span class="udiff-line-modified-added">+         dec-&gt;priv-&gt;samples = 0;</span>
<span class="udiff-line-modified-added">+       }</span>
  
        /* and follow along with segment */
        dec-&gt;priv-&gt;in_out_segment_sync = FALSE;
        dec-&gt;input_segment = seg;
        dec-&gt;priv-&gt;pending_events =
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2298,13 +2458,13 @@</span>
          dec-&gt;priv-&gt;taglist_changed = FALSE;
          GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
  
          /* No tags, go out of here instead of fall through */
          if (!event) {
<span class="udiff-line-modified-removed">-         ret = TRUE;</span>
<span class="udiff-line-modified-removed">-         break;</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-added">+           ret = TRUE;</span>
<span class="udiff-line-modified-added">+           break;</span>
<span class="udiff-line-modified-added">+         }</span>
        }
  
        /* fall through */
      }
      default:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2568,11 +2728,11 @@</span>
      caps = gst_audio_decoder_proxy_getcaps (decoder, NULL, filter);
  
    GST_LOG_OBJECT (decoder, &quot;Returning caps %&quot; GST_PTR_FORMAT, caps);
  
    return caps;
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-added">+ }</span>
  
  static gboolean
  gst_audio_decoder_sink_query_default (GstAudioDecoder * dec, GstQuery * query)
  {
    GstPad *pad = GST_AUDIO_DECODER_SINK_PAD (dec);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2593,11 +2753,11 @@</span>
        gint64 src_val, dest_val;
  
        gst_query_parse_convert (query, &amp;src_fmt, &amp;src_val, &amp;dest_fmt, &amp;dest_val);
        GST_OBJECT_LOCK (dec);
        res = __gst_audio_encoded_audio_convert (&amp;dec-&gt;priv-&gt;ctx.info,
<span class="udiff-line-modified-removed">-                   dec-&gt;priv-&gt;bytes_in, dec-&gt;priv-&gt;samples_out,</span>
<span class="udiff-line-modified-added">+           dec-&gt;priv-&gt;bytes_in, dec-&gt;priv-&gt;samples_out,</span>
            src_fmt, src_val, &amp;dest_fmt, &amp;dest_val);
        GST_OBJECT_UNLOCK (dec);
        if (!res)
          goto error;
        gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2805,11 +2965,11 @@</span>
              GST_TIME_FORMAT &quot; max %&quot; GST_TIME_FORMAT, live,
              GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
  
          GST_OBJECT_LOCK (dec);
          /* add our latency */
<span class="udiff-line-modified-removed">-           min_latency += dec-&gt;priv-&gt;ctx.min_latency;</span>
<span class="udiff-line-modified-added">+         min_latency += dec-&gt;priv-&gt;ctx.min_latency;</span>
          if (max_latency == -1 || dec-&gt;priv-&gt;ctx.max_latency == -1)
            max_latency = -1;
          else
            max_latency += dec-&gt;priv-&gt;ctx.max_latency;
          GST_OBJECT_UNLOCK (dec);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3499,11 +3659,11 @@</span>
        dec-&gt;priv-&gt;taglist = gst_tag_list_ref ((GstTagList *) tags);
        dec-&gt;priv-&gt;decoder_tags_merge_mode = mode;
      }
  
      GST_DEBUG_OBJECT (dec, &quot;setting decoder tags to %&quot; GST_PTR_FORMAT, tags);
<span class="udiff-line-modified-removed">-   dec-&gt;priv-&gt;taglist_changed = TRUE;</span>
<span class="udiff-line-modified-added">+     dec-&gt;priv-&gt;taglist_changed = TRUE;</span>
    }
    GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3561,11 +3721,11 @@</span>
   * gst_audio_decoder_get_allocator:
   * @dec: a #GstAudioDecoder
   * @allocator: (out) (allow-none) (transfer full): the #GstAllocator
   * used
   * @params: (out) (allow-none) (transfer full): the
<span class="udiff-line-modified-removed">-  * #GstAllocatorParams of @allocator</span>
<span class="udiff-line-modified-added">+  * #GstAllocationParams of @allocator</span>
   *
   * Lets #GstAudioDecoder sub-classes to know the memory @allocator
   * used by the base class and its @params.
   *
   * Unref the @allocator after use it.
</pre>
<center><a href="gstaudiobasesrc.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstaudiodecoder.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>