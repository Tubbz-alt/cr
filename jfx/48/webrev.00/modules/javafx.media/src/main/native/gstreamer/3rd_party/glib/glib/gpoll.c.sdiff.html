<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gpoll.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gpattern.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gpoll.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gpoll.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 55 #endif /* HAVE_SYS_TIME_H */
 56 #ifdef HAVE_POLL
 57 #  include &lt;poll.h&gt;
 58 
 59 /* The poll() emulation on OS/X doesn&#39;t handle fds=NULL, nfds=0,
 60  * so we prefer our own poll emulation.
 61  */
 62 #if defined(_POLL_EMUL_H_) || defined(BROKEN_POLL)
 63 #undef HAVE_POLL
 64 #endif
 65 
 66 #endif /* GLIB_HAVE_SYS_POLL_H */
 67 #ifdef G_OS_UNIX
 68 #include &lt;unistd.h&gt;
 69 #endif /* G_OS_UNIX */
 70 #include &lt;errno.h&gt;
 71 
 72 #ifdef G_OS_WIN32
 73 #define STRICT
 74 #include &lt;windows.h&gt;

 75 #endif /* G_OS_WIN32 */
 76 
 77 #include &quot;gpoll.h&quot;
 78 
 79 #ifdef G_OS_WIN32
 80 #include &quot;gprintf.h&quot;
 81 #endif
 82 
 83 #ifdef G_MAIN_POLL_DEBUG
 84 extern gboolean _g_main_poll_debug;
 85 #endif
 86 
 87 #ifdef HAVE_POLL
 88 
 89 /**
 90  * g_poll:
 91  * @fds: file descriptors to poll
 92  * @nfds: the number of file descriptors in @fds
 93  * @timeout: amount of time to wait, in milliseconds, or -1 to wait forever
 94  *
</pre>
<hr />
<pre>
101  * Each element of @fds is a #GPollFD describing a single file
102  * descriptor to poll. The @fd field indicates the file descriptor,
103  * and the @events field indicates the events to poll for. On return,
104  * the @revents fields will be filled with the events that actually
105  * occurred.
106  *
107  * On POSIX systems, the file descriptors in @fds can be any sort of
108  * file descriptor, but the situation is much more complicated on
109  * Windows. If you need to use g_poll() in code that has to run on
110  * Windows, the easiest solution is to construct all of your
111  * #GPollFDs with g_io_channel_win32_make_pollfd().
112  *
113  * Returns: the number of entries in @fds whose @revents fields
114  * were filled in, or 0 if the operation timed out, or -1 on error or
115  * if the call was interrupted.
116  *
117  * Since: 2.20
118  **/
119 gint
120 g_poll (GPollFD *fds,
<span class="line-modified">121     guint    nfds,</span>
<span class="line-modified">122     gint     timeout)</span>
123 {
124   return poll ((struct pollfd *)fds, nfds, timeout);
125 }
126 
<span class="line-modified">127 #else   /* !HAVE_POLL */</span>
128 
129 #ifdef G_OS_WIN32
130 
131 static int
132 poll_rest (GPollFD *msg_fd,

133            HANDLE  *handles,
134            GPollFD *handle_to_fd[],
135            gint     nhandles,
<span class="line-modified">136            gint     timeout)</span>
137 {
138   DWORD ready;
139   GPollFD *f;
140   int recursed_result;
141 
142   if (msg_fd != NULL)
143     {
144       /* Wait for either messages or handles
145        * -&gt; Use MsgWaitForMultipleObjectsEx
146        */
147       if (_g_main_poll_debug)
<span class="line-modified">148     g_print (&quot;  MsgWaitForMultipleObjectsEx(%d, %d)\n&quot;, nhandles, timeout);</span>
149 
<span class="line-modified">150       ready = MsgWaitForMultipleObjectsEx (nhandles, handles, timeout,</span>
<span class="line-modified">151                        QS_ALLINPUT, MWMO_ALERTABLE);</span>
152 
153       if (ready == WAIT_FAILED)
<span class="line-modified">154     {</span>
<span class="line-modified">155       gchar *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-modified">156       g_warning (&quot;MsgWaitForMultipleObjectsEx failed: %s&quot;, emsg);</span>
<span class="line-modified">157       g_free (emsg);</span>
<span class="line-modified">158     }</span>
159     }
160   else if (nhandles == 0)
161     {
162       /* No handles to wait for, just the timeout */
<span class="line-modified">163       if (timeout == INFINITE)</span>
<span class="line-modified">164     ready = WAIT_FAILED;</span>
165       else
<span class="line-modified">166     {</span>
167           /* Wait for the current process to die, more efficient than SleepEx(). */
<span class="line-modified">168           WaitForSingleObjectEx (GetCurrentProcess (), timeout, TRUE);</span>
<span class="line-modified">169       ready = WAIT_TIMEOUT;</span>
<span class="line-modified">170     }</span>
171     }
172   else
173     {
174       /* Wait for just handles
175        * -&gt; Use WaitForMultipleObjectsEx
176        */
177       if (_g_main_poll_debug)
<span class="line-modified">178     g_print (&quot;  WaitForMultipleObjectsEx(%d, %d)\n&quot;, nhandles, timeout);</span>
179 
<span class="line-modified">180       ready = WaitForMultipleObjectsEx (nhandles, handles, FALSE, timeout, TRUE);</span>
181       if (ready == WAIT_FAILED)
<span class="line-modified">182     {</span>
<span class="line-modified">183       gchar *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-modified">184       g_warning (&quot;WaitForMultipleObjectsEx failed: %s&quot;, emsg);</span>
<span class="line-modified">185       g_free (emsg);</span>
<span class="line-modified">186     }</span>
187     }
188 
189   if (_g_main_poll_debug)
190     g_print (&quot;  wait returns %ld%s\n&quot;,
<span class="line-modified">191          ready,</span>
<span class="line-modified">192          (ready == WAIT_FAILED ? &quot; (WAIT_FAILED)&quot; :</span>
<span class="line-modified">193           (ready == WAIT_TIMEOUT ? &quot; (WAIT_TIMEOUT)&quot; :</span>
<span class="line-modified">194            (msg_fd != NULL &amp;&amp; ready == WAIT_OBJECT_0 + nhandles ? &quot; (msg)&quot; : &quot;&quot;))));</span>
195 
196   if (ready == WAIT_FAILED)
197     return -1;
198   else if (ready == WAIT_TIMEOUT ||
<span class="line-modified">199        ready == WAIT_IO_COMPLETION)</span>
200     return 0;
201   else if (msg_fd != NULL &amp;&amp; ready == WAIT_OBJECT_0 + nhandles)
202     {
203       msg_fd-&gt;revents |= G_IO_IN;
204 
205       /* If we have a timeout, or no handles to poll, be satisfied
206        * with just noticing we have messages waiting.
207        */
<span class="line-modified">208       if (timeout != 0 || nhandles == 0)</span>
<span class="line-modified">209     return 1;</span>
210 
211       /* If no timeout and handles to poll, recurse to poll them,
212        * too.
213        */
<span class="line-modified">214       recursed_result = poll_rest (NULL, handles, handle_to_fd, nhandles, 0);</span>
215       return (recursed_result == -1) ? -1 : 1 + recursed_result;
216     }
217   else if (ready &gt;= WAIT_OBJECT_0 &amp;&amp; ready &lt; WAIT_OBJECT_0 + nhandles)
218     {


219       f = handle_to_fd[ready - WAIT_OBJECT_0];
<span class="line-modified">220           f-&gt;revents = f-&gt;events;</span>
<span class="line-modified">221           if (_g_main_poll_debug)</span>
222         g_print (&quot;  got event %p\n&quot;, (HANDLE) f-&gt;fd);
223 



224       /* If no timeout and polling several handles, recurse to poll
225        * the rest of them.
226        */
<span class="line-modified">227       if (timeout == 0 &amp;&amp; nhandles &gt; 1)</span>
<span class="line-modified">228     {</span>
<span class="line-modified">229       /* Poll the handles with index &gt; ready */</span>
<span class="line-modified">230           HANDLE  *shorter_handles;</span>
231           GPollFD **shorter_handle_to_fd;
<span class="line-modified">232           gint     shorter_nhandles;</span>
233 
234           shorter_handles = &amp;handles[ready - WAIT_OBJECT_0 + 1];
235           shorter_handle_to_fd = &amp;handle_to_fd[ready - WAIT_OBJECT_0 + 1];
236           shorter_nhandles = nhandles - (ready - WAIT_OBJECT_0 + 1);
237 
<span class="line-modified">238       recursed_result = poll_rest (NULL, shorter_handles, shorter_handle_to_fd, shorter_nhandles, 0);</span>
<span class="line-modified">239       return (recursed_result == -1) ? -1 : 1 + recursed_result;</span>
<span class="line-modified">240     }</span>
<span class="line-modified">241       return 1;</span>
242     }
243 
244   return 0;
245 }
246 
<span class="line-modified">247 gint</span>
<span class="line-removed">248 g_poll (GPollFD *fds,</span>
<span class="line-removed">249     guint    nfds,</span>
<span class="line-removed">250     gint     timeout)</span>
251 {
252   HANDLE handles[MAXIMUM_WAIT_OBJECTS];
253   GPollFD *handle_to_fd[MAXIMUM_WAIT_OBJECTS];
<span class="line-modified">254   GPollFD *msg_fd = NULL;</span>
<span class="line-modified">255   GPollFD *f;</span>
<span class="line-modified">256   gint nhandles = 0;</span>






257   int retval;
258 
<span class="line-removed">259   if (_g_main_poll_debug)</span>
<span class="line-removed">260     g_print (&quot;g_poll: waiting for&quot;);</span>
<span class="line-removed">261 </span>
<span class="line-removed">262   for (f = fds; f &lt; &amp;fds[nfds]; ++f)</span>
<span class="line-removed">263     {</span>
<span class="line-removed">264     if (f-&gt;fd == G_WIN32_MSG_HANDLE &amp;&amp; (f-&gt;events &amp; G_IO_IN))</span>
<span class="line-removed">265       {</span>
<span class="line-removed">266           if (_g_main_poll_debug &amp;&amp; msg_fd == NULL)</span>
<span class="line-removed">267       g_print (&quot; MSG&quot;);</span>
<span class="line-removed">268           msg_fd = f;</span>
<span class="line-removed">269       }</span>
<span class="line-removed">270     else if (f-&gt;fd &gt; 0)</span>
<span class="line-removed">271       {</span>
<span class="line-removed">272         if (nhandles == MAXIMUM_WAIT_OBJECTS)</span>
<span class="line-removed">273           {</span>
<span class="line-removed">274             g_warning (&quot;Too many handles to wait for!&quot;);</span>
<span class="line-removed">275             break;</span>
<span class="line-removed">276           }</span>
<span class="line-removed">277         else</span>
<span class="line-removed">278           {</span>
<span class="line-removed">279         if (_g_main_poll_debug)</span>
<span class="line-removed">280           g_print (&quot; %p&quot;, (HANDLE) f-&gt;fd);</span>
<span class="line-removed">281               handle_to_fd[nhandles] = f;</span>
<span class="line-removed">282         handles[nhandles++] = (HANDLE) f-&gt;fd;</span>
<span class="line-removed">283           }</span>
<span class="line-removed">284       }</span>
<span class="line-removed">285       f-&gt;revents = 0;</span>
<span class="line-removed">286       }</span>
<span class="line-removed">287 </span>
<span class="line-removed">288   if (_g_main_poll_debug)</span>
<span class="line-removed">289     g_print (&quot;\n&quot;);</span>
<span class="line-removed">290 </span>
<span class="line-removed">291   if (timeout == -1)</span>
<span class="line-removed">292     timeout = INFINITE;</span>
<span class="line-removed">293 </span>
294   /* Polling for several things? */
<span class="line-modified">295   if (nhandles &gt; 1 || (nhandles &gt; 0 &amp;&amp; msg_fd != NULL))</span>
296     {
297       /* First check if one or several of them are immediately
298        * available
299        */
<span class="line-modified">300       retval = poll_rest (msg_fd, handles, handle_to_fd, nhandles, 0);</span>
301 
302       /* If not, and we have a significant timeout, poll again with
303        * timeout then. Note that this will return indication for only
304        * one event, or only for messages.
305        */
<span class="line-modified">306       if (retval == 0 &amp;&amp; (timeout == INFINITE || timeout &gt; 0))</span>
<span class="line-modified">307     retval = poll_rest (msg_fd, handles, handle_to_fd, nhandles, timeout);</span>
308     }
309   else
310     {
311       /* Just polling for one thing, so no need to check first if
312        * available immediately
313        */
<span class="line-modified">314       retval = poll_rest (msg_fd, handles, handle_to_fd, nhandles, timeout);</span>






























































































































































































315     }
316 
317   if (retval == -1)
318     for (f = fds; f &lt; &amp;fds[nfds]; ++f)
319       f-&gt;revents = 0;
320 



321   return retval;
322 }
323 
324 #else  /* !G_OS_WIN32 */
325 
326 /* The following implementation of poll() comes from the GNU C Library.
327  * Copyright (C) 1994, 1996, 1997 Free Software Foundation, Inc.
328  */
329 
330 #include &lt;string.h&gt; /* for bzero on BSD systems */
331 
332 #ifdef HAVE_SYS_SELECT_H
333 #include &lt;sys/select.h&gt;
334 #endif /* HAVE_SYS_SELECT_H */
335 
336 gint
337 g_poll (GPollFD *fds,
<span class="line-modified">338     guint    nfds,</span>
<span class="line-modified">339     gint     timeout)</span>
340 {
341   struct timeval tv;
342   fd_set rset, wset, xset;
343   GPollFD *f;
344   int ready;
345   int maxfd = 0;
346 
347   FD_ZERO (&amp;rset);
348   FD_ZERO (&amp;wset);
349   FD_ZERO (&amp;xset);
350 
351   for (f = fds; f &lt; &amp;fds[nfds]; ++f)
352     if (f-&gt;fd &gt;= 0)
353       {
<span class="line-modified">354     if (f-&gt;events &amp; G_IO_IN)</span>
<span class="line-modified">355       FD_SET (f-&gt;fd, &amp;rset);</span>
<span class="line-modified">356     if (f-&gt;events &amp; G_IO_OUT)</span>
<span class="line-modified">357       FD_SET (f-&gt;fd, &amp;wset);</span>
<span class="line-modified">358     if (f-&gt;events &amp; G_IO_PRI)</span>
<span class="line-modified">359       FD_SET (f-&gt;fd, &amp;xset);</span>
<span class="line-modified">360     if (f-&gt;fd &gt; maxfd &amp;&amp; (f-&gt;events &amp; (G_IO_IN|G_IO_OUT|G_IO_PRI)))</span>
<span class="line-modified">361       maxfd = f-&gt;fd;</span>
362       }
363 
364   tv.tv_sec = timeout / 1000;
365   tv.tv_usec = (timeout % 1000) * 1000;
366 
367   ready = select (maxfd + 1, &amp;rset, &amp;wset, &amp;xset,
<span class="line-modified">368           timeout == -1 ? NULL : &amp;tv);</span>
369   if (ready &gt; 0)
370     for (f = fds; f &lt; &amp;fds[nfds]; ++f)
371       {
<span class="line-modified">372     f-&gt;revents = 0;</span>
<span class="line-modified">373     if (f-&gt;fd &gt;= 0)</span>
<span class="line-modified">374       {</span>
<span class="line-modified">375         if (FD_ISSET (f-&gt;fd, &amp;rset))</span>
<span class="line-modified">376           f-&gt;revents |= G_IO_IN;</span>
<span class="line-modified">377         if (FD_ISSET (f-&gt;fd, &amp;wset))</span>
<span class="line-modified">378           f-&gt;revents |= G_IO_OUT;</span>
<span class="line-modified">379         if (FD_ISSET (f-&gt;fd, &amp;xset))</span>
<span class="line-modified">380           f-&gt;revents |= G_IO_PRI;</span>
<span class="line-modified">381       }</span>
382       }
383 
384   return ready;
385 }
386 
387 #endif /* !G_OS_WIN32 */
388 
389 #endif  /* !HAVE_POLL */
</pre>
</td>
<td>
<hr />
<pre>
 55 #endif /* HAVE_SYS_TIME_H */
 56 #ifdef HAVE_POLL
 57 #  include &lt;poll.h&gt;
 58 
 59 /* The poll() emulation on OS/X doesn&#39;t handle fds=NULL, nfds=0,
 60  * so we prefer our own poll emulation.
 61  */
 62 #if defined(_POLL_EMUL_H_) || defined(BROKEN_POLL)
 63 #undef HAVE_POLL
 64 #endif
 65 
 66 #endif /* GLIB_HAVE_SYS_POLL_H */
 67 #ifdef G_OS_UNIX
 68 #include &lt;unistd.h&gt;
 69 #endif /* G_OS_UNIX */
 70 #include &lt;errno.h&gt;
 71 
 72 #ifdef G_OS_WIN32
 73 #define STRICT
 74 #include &lt;windows.h&gt;
<span class="line-added"> 75 #include &lt;process.h&gt;</span>
 76 #endif /* G_OS_WIN32 */
 77 
 78 #include &quot;gpoll.h&quot;
 79 
 80 #ifdef G_OS_WIN32
 81 #include &quot;gprintf.h&quot;
 82 #endif
 83 
 84 #ifdef G_MAIN_POLL_DEBUG
 85 extern gboolean _g_main_poll_debug;
 86 #endif
 87 
 88 #ifdef HAVE_POLL
 89 
 90 /**
 91  * g_poll:
 92  * @fds: file descriptors to poll
 93  * @nfds: the number of file descriptors in @fds
 94  * @timeout: amount of time to wait, in milliseconds, or -1 to wait forever
 95  *
</pre>
<hr />
<pre>
102  * Each element of @fds is a #GPollFD describing a single file
103  * descriptor to poll. The @fd field indicates the file descriptor,
104  * and the @events field indicates the events to poll for. On return,
105  * the @revents fields will be filled with the events that actually
106  * occurred.
107  *
108  * On POSIX systems, the file descriptors in @fds can be any sort of
109  * file descriptor, but the situation is much more complicated on
110  * Windows. If you need to use g_poll() in code that has to run on
111  * Windows, the easiest solution is to construct all of your
112  * #GPollFDs with g_io_channel_win32_make_pollfd().
113  *
114  * Returns: the number of entries in @fds whose @revents fields
115  * were filled in, or 0 if the operation timed out, or -1 on error or
116  * if the call was interrupted.
117  *
118  * Since: 2.20
119  **/
120 gint
121 g_poll (GPollFD *fds,
<span class="line-modified">122   guint    nfds,</span>
<span class="line-modified">123   gint     timeout)</span>
124 {
125   return poll ((struct pollfd *)fds, nfds, timeout);
126 }
127 
<span class="line-modified">128 #else /* !HAVE_POLL */</span>
129 
130 #ifdef G_OS_WIN32
131 
132 static int
133 poll_rest (GPollFD *msg_fd,
<span class="line-added">134            GPollFD *stop_fd,</span>
135            HANDLE  *handles,
136            GPollFD *handle_to_fd[],
137            gint     nhandles,
<span class="line-modified">138            gint     timeout_ms)</span>
139 {
140   DWORD ready;
141   GPollFD *f;
142   int recursed_result;
143 
144   if (msg_fd != NULL)
145     {
146       /* Wait for either messages or handles
147        * -&gt; Use MsgWaitForMultipleObjectsEx
148        */
149       if (_g_main_poll_debug)
<span class="line-modified">150   g_print (&quot;  MsgWaitForMultipleObjectsEx(%d, %d)\n&quot;, nhandles, timeout_ms);</span>
151 
<span class="line-modified">152       ready = MsgWaitForMultipleObjectsEx (nhandles, handles, timeout_ms,</span>
<span class="line-modified">153              QS_ALLINPUT, MWMO_ALERTABLE);</span>
154 
155       if (ready == WAIT_FAILED)
<span class="line-modified">156   {</span>
<span class="line-modified">157     gchar *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-modified">158     g_warning (&quot;MsgWaitForMultipleObjectsEx failed: %s&quot;, emsg);</span>
<span class="line-modified">159     g_free (emsg);</span>
<span class="line-modified">160   }</span>
161     }
162   else if (nhandles == 0)
163     {
164       /* No handles to wait for, just the timeout */
<span class="line-modified">165       if (timeout_ms == INFINITE)</span>
<span class="line-modified">166   ready = WAIT_FAILED;</span>
167       else
<span class="line-modified">168         {</span>
169           /* Wait for the current process to die, more efficient than SleepEx(). */
<span class="line-modified">170           WaitForSingleObjectEx (GetCurrentProcess (), timeout_ms, TRUE);</span>
<span class="line-modified">171           ready = WAIT_TIMEOUT;</span>
<span class="line-modified">172         }</span>
173     }
174   else
175     {
176       /* Wait for just handles
177        * -&gt; Use WaitForMultipleObjectsEx
178        */
179       if (_g_main_poll_debug)
<span class="line-modified">180   g_print (&quot;  WaitForMultipleObjectsEx(%d, %d)\n&quot;, nhandles, timeout_ms);</span>
181 
<span class="line-modified">182       ready = WaitForMultipleObjectsEx (nhandles, handles, FALSE, timeout_ms, TRUE);</span>
183       if (ready == WAIT_FAILED)
<span class="line-modified">184   {</span>
<span class="line-modified">185     gchar *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-modified">186     g_warning (&quot;WaitForMultipleObjectsEx failed: %s&quot;, emsg);</span>
<span class="line-modified">187     g_free (emsg);</span>
<span class="line-modified">188   }</span>
189     }
190 
191   if (_g_main_poll_debug)
192     g_print (&quot;  wait returns %ld%s\n&quot;,
<span class="line-modified">193        ready,</span>
<span class="line-modified">194        (ready == WAIT_FAILED ? &quot; (WAIT_FAILED)&quot; :</span>
<span class="line-modified">195         (ready == WAIT_TIMEOUT ? &quot; (WAIT_TIMEOUT)&quot; :</span>
<span class="line-modified">196          (msg_fd != NULL &amp;&amp; ready == WAIT_OBJECT_0 + nhandles ? &quot; (msg)&quot; : &quot;&quot;))));</span>
197 
198   if (ready == WAIT_FAILED)
199     return -1;
200   else if (ready == WAIT_TIMEOUT ||
<span class="line-modified">201      ready == WAIT_IO_COMPLETION)</span>
202     return 0;
203   else if (msg_fd != NULL &amp;&amp; ready == WAIT_OBJECT_0 + nhandles)
204     {
205       msg_fd-&gt;revents |= G_IO_IN;
206 
207       /* If we have a timeout, or no handles to poll, be satisfied
208        * with just noticing we have messages waiting.
209        */
<span class="line-modified">210       if (timeout_ms != 0 || nhandles == 0)</span>
<span class="line-modified">211   return 1;</span>
212 
213       /* If no timeout and handles to poll, recurse to poll them,
214        * too.
215        */
<span class="line-modified">216       recursed_result = poll_rest (NULL, stop_fd, handles, handle_to_fd, nhandles, 0);</span>
217       return (recursed_result == -1) ? -1 : 1 + recursed_result;
218     }
219   else if (ready &gt;= WAIT_OBJECT_0 &amp;&amp; ready &lt; WAIT_OBJECT_0 + nhandles)
220     {
<span class="line-added">221       int retval;</span>
<span class="line-added">222 </span>
223       f = handle_to_fd[ready - WAIT_OBJECT_0];
<span class="line-modified">224       f-&gt;revents = f-&gt;events;</span>
<span class="line-modified">225       if (_g_main_poll_debug)</span>
226         g_print (&quot;  got event %p\n&quot;, (HANDLE) f-&gt;fd);
227 
<span class="line-added">228       /* Do not count the stop_fd */</span>
<span class="line-added">229       retval = (f != stop_fd) ? 1 : 0;</span>
<span class="line-added">230 </span>
231       /* If no timeout and polling several handles, recurse to poll
232        * the rest of them.
233        */
<span class="line-modified">234       if (timeout_ms == 0 &amp;&amp; nhandles &gt; 1)</span>
<span class="line-modified">235         {</span>
<span class="line-modified">236           /* Poll the handles with index &gt; ready */</span>
<span class="line-modified">237           HANDLE *shorter_handles;</span>
238           GPollFD **shorter_handle_to_fd;
<span class="line-modified">239           gint shorter_nhandles;</span>
240 
241           shorter_handles = &amp;handles[ready - WAIT_OBJECT_0 + 1];
242           shorter_handle_to_fd = &amp;handle_to_fd[ready - WAIT_OBJECT_0 + 1];
243           shorter_nhandles = nhandles - (ready - WAIT_OBJECT_0 + 1);
244 
<span class="line-modified">245           recursed_result = poll_rest (NULL, stop_fd, shorter_handles, shorter_handle_to_fd, shorter_nhandles, 0);</span>
<span class="line-modified">246           return (recursed_result == -1) ? -1 : retval + recursed_result;</span>
<span class="line-modified">247         }</span>
<span class="line-modified">248       return retval;</span>
249     }
250 
251   return 0;
252 }
253 
<span class="line-modified">254 typedef struct</span>



255 {
256   HANDLE handles[MAXIMUM_WAIT_OBJECTS];
257   GPollFD *handle_to_fd[MAXIMUM_WAIT_OBJECTS];
<span class="line-modified">258   GPollFD *msg_fd;</span>
<span class="line-modified">259   GPollFD *stop_fd;</span>
<span class="line-modified">260   gint nhandles;</span>
<span class="line-added">261   gint timeout_ms;</span>
<span class="line-added">262 } GWin32PollThreadData;</span>
<span class="line-added">263 </span>
<span class="line-added">264 static gint</span>
<span class="line-added">265 poll_single_thread (GWin32PollThreadData *data)</span>
<span class="line-added">266 {</span>
267   int retval;
268 



































269   /* Polling for several things? */
<span class="line-modified">270   if (data-&gt;nhandles &gt; 1 || (data-&gt;nhandles &gt; 0 &amp;&amp; data-&gt;msg_fd != NULL))</span>
271     {
272       /* First check if one or several of them are immediately
273        * available
274        */
<span class="line-modified">275       retval = poll_rest (data-&gt;msg_fd, data-&gt;stop_fd, data-&gt;handles, data-&gt;handle_to_fd, data-&gt;nhandles, 0);</span>
276 
277       /* If not, and we have a significant timeout, poll again with
278        * timeout then. Note that this will return indication for only
279        * one event, or only for messages.
280        */
<span class="line-modified">281       if (retval == 0 &amp;&amp; (data-&gt;timeout_ms == INFINITE || data-&gt;timeout_ms &gt; 0))</span>
<span class="line-modified">282         retval = poll_rest (data-&gt;msg_fd, data-&gt;stop_fd, data-&gt;handles, data-&gt;handle_to_fd, data-&gt;nhandles, data-&gt;timeout_ms);</span>
283     }
284   else
285     {
286       /* Just polling for one thing, so no need to check first if
287        * available immediately
288        */
<span class="line-modified">289       retval = poll_rest (data-&gt;msg_fd, data-&gt;stop_fd, data-&gt;handles, data-&gt;handle_to_fd, data-&gt;nhandles, data-&gt;timeout_ms);</span>
<span class="line-added">290     }</span>
<span class="line-added">291 </span>
<span class="line-added">292   return retval;</span>
<span class="line-added">293 }</span>
<span class="line-added">294 </span>
<span class="line-added">295 static void</span>
<span class="line-added">296 fill_poll_thread_data (GPollFD              *fds,</span>
<span class="line-added">297                        guint                 nfds,</span>
<span class="line-added">298                        gint                  timeout_ms,</span>
<span class="line-added">299                        GPollFD              *stop_fd,</span>
<span class="line-added">300                        GWin32PollThreadData *data)</span>
<span class="line-added">301 {</span>
<span class="line-added">302   GPollFD *f;</span>
<span class="line-added">303 </span>
<span class="line-added">304   data-&gt;timeout_ms = timeout_ms;</span>
<span class="line-added">305 </span>
<span class="line-added">306   if (stop_fd != NULL)</span>
<span class="line-added">307     {</span>
<span class="line-added">308       if (_g_main_poll_debug)</span>
<span class="line-added">309         g_print (&quot; Stop FD: %p&quot;, (HANDLE) stop_fd-&gt;fd);</span>
<span class="line-added">310 </span>
<span class="line-added">311       g_assert (data-&gt;nhandles &lt; MAXIMUM_WAIT_OBJECTS);</span>
<span class="line-added">312 </span>
<span class="line-added">313       data-&gt;stop_fd = stop_fd;</span>
<span class="line-added">314       data-&gt;handle_to_fd[data-&gt;nhandles] = stop_fd;</span>
<span class="line-added">315       data-&gt;handles[data-&gt;nhandles++] = (HANDLE) stop_fd-&gt;fd;</span>
<span class="line-added">316     }</span>
<span class="line-added">317 </span>
<span class="line-added">318   for (f = fds; f &lt; &amp;fds[nfds]; ++f)</span>
<span class="line-added">319     {</span>
<span class="line-added">320       if ((data-&gt;nhandles == MAXIMUM_WAIT_OBJECTS) ||</span>
<span class="line-added">321           (data-&gt;msg_fd != NULL &amp;&amp; (data-&gt;nhandles == MAXIMUM_WAIT_OBJECTS - 1)))</span>
<span class="line-added">322         {</span>
<span class="line-added">323           g_warning (&quot;Too many handles to wait for!&quot;);</span>
<span class="line-added">324           break;</span>
<span class="line-added">325         }</span>
<span class="line-added">326 </span>
<span class="line-added">327       if (f-&gt;fd == G_WIN32_MSG_HANDLE &amp;&amp; (f-&gt;events &amp; G_IO_IN))</span>
<span class="line-added">328         {</span>
<span class="line-added">329           if (_g_main_poll_debug &amp;&amp; data-&gt;msg_fd == NULL)</span>
<span class="line-added">330             g_print (&quot; MSG&quot;);</span>
<span class="line-added">331           data-&gt;msg_fd = f;</span>
<span class="line-added">332         }</span>
<span class="line-added">333       else if (f-&gt;fd &gt; 0)</span>
<span class="line-added">334         {</span>
<span class="line-added">335           if (_g_main_poll_debug)</span>
<span class="line-added">336             g_print (&quot; %p&quot;, (HANDLE) f-&gt;fd);</span>
<span class="line-added">337           data-&gt;handle_to_fd[data-&gt;nhandles] = f;</span>
<span class="line-added">338           data-&gt;handles[data-&gt;nhandles++] = (HANDLE) f-&gt;fd;</span>
<span class="line-added">339         }</span>
<span class="line-added">340 </span>
<span class="line-added">341       f-&gt;revents = 0;</span>
<span class="line-added">342     }</span>
<span class="line-added">343 }</span>
<span class="line-added">344 </span>
<span class="line-added">345 static guint __stdcall</span>
<span class="line-added">346 poll_thread_run (gpointer user_data)</span>
<span class="line-added">347 {</span>
<span class="line-added">348   GWin32PollThreadData *data = user_data;</span>
<span class="line-added">349 </span>
<span class="line-added">350   /* Docs say that it is safer to call _endthreadex by our own:</span>
<span class="line-added">351    * https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/endthread-endthreadex</span>
<span class="line-added">352    */</span>
<span class="line-added">353   _endthreadex (poll_single_thread (data));</span>
<span class="line-added">354 </span>
<span class="line-added">355   g_assert_not_reached ();</span>
<span class="line-added">356 </span>
<span class="line-added">357   return 0;</span>
<span class="line-added">358 }</span>
<span class="line-added">359 </span>
<span class="line-added">360 /* One slot for a possible msg object or the stop event */</span>
<span class="line-added">361 #define MAXIMUM_WAIT_OBJECTS_PER_THREAD (MAXIMUM_WAIT_OBJECTS - 1)</span>
<span class="line-added">362 </span>
<span class="line-added">363 gint</span>
<span class="line-added">364 g_poll (GPollFD *fds,</span>
<span class="line-added">365   guint    nfds,</span>
<span class="line-added">366   gint     timeout)</span>
<span class="line-added">367 {</span>
<span class="line-added">368   guint nthreads, threads_remain;</span>
<span class="line-added">369   HANDLE thread_handles[MAXIMUM_WAIT_OBJECTS];</span>
<span class="line-added">370   GWin32PollThreadData *threads_data;</span>
<span class="line-added">371   GPollFD stop_event = { 0, };</span>
<span class="line-added">372   GPollFD *f;</span>
<span class="line-added">373   guint i, fds_idx = 0;</span>
<span class="line-added">374   DWORD ready;</span>
<span class="line-added">375   DWORD thread_retval;</span>
<span class="line-added">376   int retval;</span>
<span class="line-added">377   GPollFD *msg_fd = NULL;</span>
<span class="line-added">378 </span>
<span class="line-added">379   if (timeout == -1)</span>
<span class="line-added">380     timeout = INFINITE;</span>
<span class="line-added">381 </span>
<span class="line-added">382   /* Simple case without extra threads */</span>
<span class="line-added">383   if (nfds &lt;= MAXIMUM_WAIT_OBJECTS)</span>
<span class="line-added">384     {</span>
<span class="line-added">385       GWin32PollThreadData data = { 0, };</span>
<span class="line-added">386 </span>
<span class="line-added">387       if (_g_main_poll_debug)</span>
<span class="line-added">388         g_print (&quot;g_poll: waiting for&quot;);</span>
<span class="line-added">389 </span>
<span class="line-added">390       fill_poll_thread_data (fds, nfds, timeout, NULL, &amp;data);</span>
<span class="line-added">391 </span>
<span class="line-added">392       if (_g_main_poll_debug)</span>
<span class="line-added">393         g_print (&quot;\n&quot;);</span>
<span class="line-added">394 </span>
<span class="line-added">395       retval = poll_single_thread (&amp;data);</span>
<span class="line-added">396       if (retval == -1)</span>
<span class="line-added">397         for (f = fds; f &lt; &amp;fds[nfds]; ++f)</span>
<span class="line-added">398           f-&gt;revents = 0;</span>
<span class="line-added">399 </span>
<span class="line-added">400       return retval;</span>
<span class="line-added">401     }</span>
<span class="line-added">402 </span>
<span class="line-added">403   if (_g_main_poll_debug)</span>
<span class="line-added">404     g_print (&quot;g_poll: polling with threads\n&quot;);</span>
<span class="line-added">405 </span>
<span class="line-added">406   nthreads = nfds / MAXIMUM_WAIT_OBJECTS_PER_THREAD;</span>
<span class="line-added">407   threads_remain = nfds % MAXIMUM_WAIT_OBJECTS_PER_THREAD;</span>
<span class="line-added">408   if (threads_remain &gt; 0)</span>
<span class="line-added">409     nthreads++;</span>
<span class="line-added">410 </span>
<span class="line-added">411   if (nthreads &gt; MAXIMUM_WAIT_OBJECTS_PER_THREAD)</span>
<span class="line-added">412     {</span>
<span class="line-added">413       g_warning (&quot;Too many handles to wait for in threads!&quot;);</span>
<span class="line-added">414       nthreads = MAXIMUM_WAIT_OBJECTS_PER_THREAD;</span>
<span class="line-added">415     }</span>
<span class="line-added">416 </span>
<span class="line-added">417 #if GLIB_SIZEOF_VOID_P == 8</span>
<span class="line-added">418   stop_event.fd = (gint64)CreateEventW (NULL, TRUE, FALSE, NULL);</span>
<span class="line-added">419 #else</span>
<span class="line-added">420   stop_event.fd = (gint)CreateEventW (NULL, TRUE, FALSE, NULL);</span>
<span class="line-added">421 #endif</span>
<span class="line-added">422   stop_event.events = G_IO_IN;</span>
<span class="line-added">423 </span>
<span class="line-added">424   threads_data = g_new0 (GWin32PollThreadData, nthreads);</span>
<span class="line-added">425   for (i = 0; i &lt; nthreads; i++)</span>
<span class="line-added">426     {</span>
<span class="line-added">427       guint thread_fds;</span>
<span class="line-added">428       guint ignore;</span>
<span class="line-added">429 </span>
<span class="line-added">430       if (i == (nthreads - 1) &amp;&amp; threads_remain &gt; 0)</span>
<span class="line-added">431         thread_fds = threads_remain;</span>
<span class="line-added">432       else</span>
<span class="line-added">433         thread_fds = MAXIMUM_WAIT_OBJECTS_PER_THREAD;</span>
<span class="line-added">434 </span>
<span class="line-added">435       fill_poll_thread_data (fds + fds_idx, thread_fds, timeout, &amp;stop_event, &amp;threads_data[i]);</span>
<span class="line-added">436       fds_idx += thread_fds;</span>
<span class="line-added">437 </span>
<span class="line-added">438       /* We must poll for messages from the same thread, so poll it along with the threads */</span>
<span class="line-added">439       if (threads_data[i].msg_fd != NULL)</span>
<span class="line-added">440         {</span>
<span class="line-added">441           msg_fd = threads_data[i].msg_fd;</span>
<span class="line-added">442           threads_data[i].msg_fd = NULL;</span>
<span class="line-added">443         }</span>
<span class="line-added">444 </span>
<span class="line-added">445       thread_handles[i] = (HANDLE) _beginthreadex (NULL, 0, poll_thread_run, &amp;threads_data[i], 0, &amp;ignore);</span>
<span class="line-added">446     }</span>
<span class="line-added">447 </span>
<span class="line-added">448   /* Wait for at least one thread to return */</span>
<span class="line-added">449   if (msg_fd != NULL)</span>
<span class="line-added">450     ready = MsgWaitForMultipleObjectsEx (nthreads, thread_handles, timeout,</span>
<span class="line-added">451                                          QS_ALLINPUT, MWMO_ALERTABLE);</span>
<span class="line-added">452   else</span>
<span class="line-added">453     ready = WaitForMultipleObjects (nthreads, thread_handles, timeout &gt; 0, timeout);</span>
<span class="line-added">454 </span>
<span class="line-added">455   /* Signal the stop in case any of the threads did not stop yet */</span>
<span class="line-added">456   if (!SetEvent ((HANDLE)stop_event.fd))</span>
<span class="line-added">457     {</span>
<span class="line-added">458       gchar *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-added">459       g_warning (&quot;gpoll: failed to signal the stop event: %s&quot;, emsg);</span>
<span class="line-added">460       g_free (emsg);</span>
<span class="line-added">461     }</span>
<span class="line-added">462 </span>
<span class="line-added">463   /* Wait for the rest of the threads to finish */</span>
<span class="line-added">464   WaitForMultipleObjects (nthreads, thread_handles, TRUE, INFINITE);</span>
<span class="line-added">465 </span>
<span class="line-added">466   /* The return value of all the threads give us all the fds that changed state */</span>
<span class="line-added">467   retval = 0;</span>
<span class="line-added">468   if (msg_fd != NULL &amp;&amp; ready == WAIT_OBJECT_0 + nthreads)</span>
<span class="line-added">469     {</span>
<span class="line-added">470       msg_fd-&gt;revents |= G_IO_IN;</span>
<span class="line-added">471       retval = 1;</span>
<span class="line-added">472     }</span>
<span class="line-added">473 </span>
<span class="line-added">474   for (i = 0; i &lt; nthreads; i++)</span>
<span class="line-added">475     {</span>
<span class="line-added">476       if (GetExitCodeThread (thread_handles[i], &amp;thread_retval))</span>
<span class="line-added">477         retval = retval == -1 ? -1 : thread_retval == -1 ? -1 : retval + thread_retval;</span>
<span class="line-added">478 </span>
<span class="line-added">479       CloseHandle (thread_handles[i]);</span>
480     }
481 
482   if (retval == -1)
483     for (f = fds; f &lt; &amp;fds[nfds]; ++f)
484       f-&gt;revents = 0;
485 
<span class="line-added">486   g_free (threads_data);</span>
<span class="line-added">487   CloseHandle ((HANDLE)stop_event.fd);</span>
<span class="line-added">488 </span>
489   return retval;
490 }
491 
492 #else  /* !G_OS_WIN32 */
493 
494 /* The following implementation of poll() comes from the GNU C Library.
495  * Copyright (C) 1994, 1996, 1997 Free Software Foundation, Inc.
496  */
497 
498 #include &lt;string.h&gt; /* for bzero on BSD systems */
499 
500 #ifdef HAVE_SYS_SELECT_H
501 #include &lt;sys/select.h&gt;
502 #endif /* HAVE_SYS_SELECT_H */
503 
504 gint
505 g_poll (GPollFD *fds,
<span class="line-modified">506   guint    nfds,</span>
<span class="line-modified">507   gint     timeout)</span>
508 {
509   struct timeval tv;
510   fd_set rset, wset, xset;
511   GPollFD *f;
512   int ready;
513   int maxfd = 0;
514 
515   FD_ZERO (&amp;rset);
516   FD_ZERO (&amp;wset);
517   FD_ZERO (&amp;xset);
518 
519   for (f = fds; f &lt; &amp;fds[nfds]; ++f)
520     if (f-&gt;fd &gt;= 0)
521       {
<span class="line-modified">522   if (f-&gt;events &amp; G_IO_IN)</span>
<span class="line-modified">523     FD_SET (f-&gt;fd, &amp;rset);</span>
<span class="line-modified">524   if (f-&gt;events &amp; G_IO_OUT)</span>
<span class="line-modified">525     FD_SET (f-&gt;fd, &amp;wset);</span>
<span class="line-modified">526   if (f-&gt;events &amp; G_IO_PRI)</span>
<span class="line-modified">527     FD_SET (f-&gt;fd, &amp;xset);</span>
<span class="line-modified">528   if (f-&gt;fd &gt; maxfd &amp;&amp; (f-&gt;events &amp; (G_IO_IN|G_IO_OUT|G_IO_PRI)))</span>
<span class="line-modified">529     maxfd = f-&gt;fd;</span>
530       }
531 
532   tv.tv_sec = timeout / 1000;
533   tv.tv_usec = (timeout % 1000) * 1000;
534 
535   ready = select (maxfd + 1, &amp;rset, &amp;wset, &amp;xset,
<span class="line-modified">536       timeout == -1 ? NULL : &amp;tv);</span>
537   if (ready &gt; 0)
538     for (f = fds; f &lt; &amp;fds[nfds]; ++f)
539       {
<span class="line-modified">540   f-&gt;revents = 0;</span>
<span class="line-modified">541   if (f-&gt;fd &gt;= 0)</span>
<span class="line-modified">542     {</span>
<span class="line-modified">543       if (FD_ISSET (f-&gt;fd, &amp;rset))</span>
<span class="line-modified">544         f-&gt;revents |= G_IO_IN;</span>
<span class="line-modified">545       if (FD_ISSET (f-&gt;fd, &amp;wset))</span>
<span class="line-modified">546         f-&gt;revents |= G_IO_OUT;</span>
<span class="line-modified">547       if (FD_ISSET (f-&gt;fd, &amp;xset))</span>
<span class="line-modified">548         f-&gt;revents |= G_IO_PRI;</span>
<span class="line-modified">549     }</span>
550       }
551 
552   return ready;
553 }
554 
555 #endif /* !G_OS_WIN32 */
556 
557 #endif  /* !HAVE_POLL */
</pre>
</td>
</tr>
</table>
<center><a href="gpattern.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gpoll.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>