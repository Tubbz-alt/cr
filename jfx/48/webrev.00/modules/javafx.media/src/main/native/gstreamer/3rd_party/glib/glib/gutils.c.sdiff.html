<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gutils.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gutf8.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gutils.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gutils.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe for the unix part, FIXME: make the win32 part MT safe as well.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #include &quot;gutils.h&quot;

  32 
  33 #include &lt;stdarg.h&gt;
  34 #include &lt;stdlib.h&gt;
  35 #include &lt;stdio.h&gt;
  36 #include &lt;locale.h&gt;
  37 #include &lt;string.h&gt;
<span class="line-modified">  38 #include &lt;ctype.h&gt;      /* For tolower() */</span>
  39 #include &lt;errno.h&gt;
  40 #include &lt;sys/types.h&gt;
  41 #include &lt;sys/stat.h&gt;
  42 #ifdef G_OS_UNIX
  43 #include &lt;pwd.h&gt;
  44 #include &lt;unistd.h&gt;
  45 #endif
  46 #include &lt;sys/types.h&gt;
  47 #ifdef HAVE_SYS_PARAM_H
  48 #include &lt;sys/param.h&gt;
  49 #endif
  50 #ifdef HAVE_CRT_EXTERNS_H
  51 #include &lt;crt_externs.h&gt; /* for _NSGetEnviron */
  52 #endif
  53 #ifdef HAVE_SYS_AUXV_H
  54 #include &lt;sys/auxv.h&gt;
  55 #endif
  56 
  57 #include &quot;glib-init.h&quot;
  58 #include &quot;glib-private.h&quot;
</pre>
<hr />
<pre>
  71 #ifdef G_PLATFORM_WIN32
  72 #include &quot;gconvert.h&quot;
  73 #include &quot;gwin32.h&quot;
  74 #endif
  75 
  76 
  77 /**
  78  * SECTION:misc_utils
  79  * @title: Miscellaneous Utility Functions
  80  * @short_description: a selection of portable utility functions
  81  *
  82  * These are portable utility functions.
  83  */
  84 
  85 #ifdef G_PLATFORM_WIN32
  86 #  include &lt;windows.h&gt;
  87 #  ifndef GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
  88 #    define GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT 2
  89 #    define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS 4
  90 #  endif
<span class="line-modified">  91 #  include &lt;lmcons.h&gt;       /* For UNLEN */</span>
  92 #endif /* G_PLATFORM_WIN32 */
  93 
  94 #ifdef G_OS_WIN32
  95 #  include &lt;direct.h&gt;
  96 #  include &lt;shlobj.h&gt;
<span class="line-removed">  97    /* older SDK (e.g. msvc 5.0) does not have these*/</span>
<span class="line-removed">  98 #  ifndef CSIDL_MYMUSIC</span>
<span class="line-removed">  99 #    define CSIDL_MYMUSIC 13</span>
<span class="line-removed"> 100 #  endif</span>
<span class="line-removed"> 101 #  ifndef CSIDL_MYVIDEO</span>
<span class="line-removed"> 102 #    define CSIDL_MYVIDEO 14</span>
<span class="line-removed"> 103 #  endif</span>
<span class="line-removed"> 104 #  ifndef CSIDL_INTERNET_CACHE</span>
<span class="line-removed"> 105 #    define CSIDL_INTERNET_CACHE 32</span>
<span class="line-removed"> 106 #  endif</span>
<span class="line-removed"> 107 #  ifndef CSIDL_COMMON_APPDATA</span>
<span class="line-removed"> 108 #    define CSIDL_COMMON_APPDATA 35</span>
<span class="line-removed"> 109 #  endif</span>
<span class="line-removed"> 110 #  ifndef CSIDL_MYPICTURES</span>
<span class="line-removed"> 111 #    define CSIDL_MYPICTURES 0x27</span>
<span class="line-removed"> 112 #  endif</span>
<span class="line-removed"> 113 #  ifndef CSIDL_COMMON_DOCUMENTS</span>
<span class="line-removed"> 114 #    define CSIDL_COMMON_DOCUMENTS 46</span>
<span class="line-removed"> 115 #  endif</span>
<span class="line-removed"> 116 #  ifndef CSIDL_PROFILE</span>
<span class="line-removed"> 117 #    define CSIDL_PROFILE 40</span>
<span class="line-removed"> 118 #  endif</span>
 119 #  include &lt;process.h&gt;
 120 #endif
 121 
<span class="line-removed"> 122 #ifdef HAVE_CARBON</span>
<span class="line-removed"> 123 #include &lt;CoreServices/CoreServices.h&gt;</span>
<span class="line-removed"> 124 #endif</span>
<span class="line-removed"> 125 </span>
 126 #ifdef HAVE_CODESET
 127 #include &lt;langinfo.h&gt;
 128 #endif
 129 
 130 #ifdef G_PLATFORM_WIN32
 131 
 132 gchar *
 133 _glib_get_dll_directory (void)
 134 {
 135   gchar *retval;
 136   gchar *p;
 137   wchar_t wc_fn[MAX_PATH];
 138 
 139 #ifdef DLL_EXPORT
 140   if (glib_dll == NULL)
 141     return NULL;
 142 #endif
 143 
 144   /* This code is different from that in
 145    * g_win32_get_package_installation_directory_of_module() in that
</pre>
<hr />
<pre>
 206  *
 207  * On POSIX systems, calling g_atexit() (or atexit()) in a dynamically
 208  * loaded module which is unloaded before the program terminates might
 209  * well cause a crash at program exit.
 210  *
 211  * Some POSIX systems implement atexit() like Windows, and have each
 212  * dynamically loaded module maintain an own atexit chain that is
 213  * called when the module is unloaded.
 214  *
 215  * On other POSIX systems, before a dynamically loaded module is
 216  * unloaded, the registered atexit functions (if any) residing in that
 217  * module are called, regardless where the code that registered them
 218  * resided. This is presumably the most robust approach.
 219  *
 220  * As can be seen from the above, for portability it&#39;s best to avoid
 221  * calling g_atexit() (or atexit()) except in the main executable of a
 222  * program.
 223  *
 224  * Deprecated:2.32: It is best to avoid g_atexit().
 225  */

 226 void
 227 g_atexit (GVoidFunc func)
 228 {
 229   gint result;
 230   int errsv;
 231 
 232   result = atexit ((void (*)(void)) func);
 233   errsv = errno;
 234   if (result)
 235     {
 236       g_error (&quot;Could not register atexit() function: %s&quot;,
 237                g_strerror (errsv));
 238     }
 239 }

 240 
 241 #endif // GSTREAMER_LITE
 242 
 243 /* Based on execvp() from GNU Libc.
 244  * Some of this code is cut-and-pasted into gspawn.c
 245  */
 246 
 247 static gchar*
 248 my_strchrnul (const gchar *str,
<span class="line-modified"> 249           gchar        c)</span>
 250 {
 251   gchar *p = (gchar*)str;
 252   while (*p &amp;&amp; (*p != c))
 253     ++p;
 254 
 255   return p;
 256 }
 257 
 258 #ifdef G_OS_WIN32
 259 
 260 static gchar *inner_find_program_in_path (const gchar *program);
 261 
 262 gchar*
 263 g_find_program_in_path (const gchar *program)
 264 {
 265   const gchar *last_dot = strrchr (program, &#39;.&#39;);
 266 
 267   if (last_dot == NULL ||
 268       strchr (last_dot, &#39;\\&#39;) != NULL ||
 269       strchr (last_dot, &#39;/&#39;) != NULL)
 270     {
 271       const gint program_length = strlen (program);
 272       gchar *pathext = g_build_path (&quot;;&quot;,
<span class="line-modified"> 273                      &quot;.exe;.cmd;.bat;.com&quot;,</span>
<span class="line-modified"> 274                      g_getenv (&quot;PATHEXT&quot;),</span>
<span class="line-modified"> 275                      NULL);</span>
 276       gchar *p;
 277       gchar *decorated_program;
 278       gchar *retval;
 279 
 280       p = pathext;
 281       do
<span class="line-modified"> 282     {</span>
<span class="line-modified"> 283       gchar *q = my_strchrnul (p, &#39;;&#39;);</span>
 284 
<span class="line-modified"> 285       decorated_program = g_malloc (program_length + (q-p) + 1);</span>
<span class="line-modified"> 286       memcpy (decorated_program, program, program_length);</span>
<span class="line-modified"> 287       memcpy (decorated_program+program_length, p, q-p);</span>
<span class="line-modified"> 288       decorated_program [program_length + (q-p)] = &#39;\0&#39;;</span>
 289 
<span class="line-modified"> 290       retval = inner_find_program_in_path (decorated_program);</span>
<span class="line-modified"> 291       g_free (decorated_program);</span>
 292 
<span class="line-modified"> 293       if (retval != NULL)</span>
<span class="line-modified"> 294         {</span>
<span class="line-modified"> 295           g_free (pathext);</span>
<span class="line-modified"> 296           return retval;</span>
<span class="line-modified"> 297         }</span>
<span class="line-modified"> 298       p = q;</span>
<span class="line-modified"> 299     } while (*p++ != &#39;\0&#39;);</span>
 300       g_free (pathext);
 301       return NULL;
 302     }
 303   else
 304     return inner_find_program_in_path (program);
 305 }
 306 
 307 #endif
 308 
 309 /**
 310  * g_find_program_in_path:
 311  * @program: (type filename): a program name in the GLib file name encoding
 312  *
 313  * Locates the first executable named @program in the user&#39;s path, in the
 314  * same way that execvp() would locate it. Returns an allocated string
 315  * with the absolute path name, or %NULL if the program is not found in
 316  * the path. If @program is already an absolute path, returns a copy of
 317  * @program if @program exists and is executable, and %NULL otherwise.
 318  *
 319  * On Windows, if @program does not have a file type suffix, tries
</pre>
<hr />
<pre>
 348   int n;
 349   wchar_t wfilename[MAXPATHLEN], wsysdir[MAXPATHLEN],
 350     wwindir[MAXPATHLEN];
 351 #endif
 352   gsize len;
 353   gsize pathlen;
 354 
 355   g_return_val_if_fail (program != NULL, NULL);
 356 
 357   /* If it is an absolute path, or a relative path including subdirectories,
 358    * don&#39;t look in PATH.
 359    */
 360   if (g_path_is_absolute (program)
 361       || strchr (program, G_DIR_SEPARATOR) != NULL
 362 #ifdef G_OS_WIN32
 363       || strchr (program, &#39;/&#39;) != NULL
 364 #endif
 365       )
 366     {
 367       if (g_file_test (program, G_FILE_TEST_IS_EXECUTABLE) &amp;&amp;
<span class="line-modified"> 368       !g_file_test (program, G_FILE_TEST_IS_DIR))</span>
 369         return g_strdup (program);
 370       else
 371         return NULL;
 372     }
 373 
 374   path = g_getenv (&quot;PATH&quot;);
 375 #if defined(G_OS_UNIX)
 376   if (path == NULL)
 377     {
 378       /* There is no &#39;PATH&#39; in the environment.  The default
 379        * search path in GNU libc is the current directory followed by
 380        * the path &#39;confstr&#39; returns for &#39;_CS_PATH&#39;.
 381        */
 382 
 383       /* In GLib we put . last, for security, and don&#39;t use the
 384        * unportable confstr(); UNIX98 does not actually specify
 385        * what to search if PATH is unset. POSIX may, dunno.
 386        */
 387 
 388       path = &quot;/bin:/usr/bin:.&quot;;
</pre>
<hr />
<pre>
 455   /* And add the slash before the filename  */
 456   *name = G_DIR_SEPARATOR;
 457 
 458   p = path;
 459   do
 460     {
 461       char *startp;
 462 
 463       path = p;
 464       p = my_strchrnul (path, G_SEARCHPATH_SEPARATOR);
 465 
 466       if (p == path)
 467         /* Two adjacent colons, or a colon at the beginning or the end
 468          * of &#39;PATH&#39; means to search the current directory.
 469          */
 470         startp = name + 1;
 471       else
 472         startp = memcpy (name - (p - path), path, p - path);
 473 
 474       if (g_file_test (startp, G_FILE_TEST_IS_EXECUTABLE) &amp;&amp;
<span class="line-modified"> 475       !g_file_test (startp, G_FILE_TEST_IS_DIR))</span>
 476         {
 477           gchar *ret;
 478           ret = g_strdup (startp);
 479           g_free (freeme);
 480 #ifdef G_OS_WIN32
<span class="line-modified"> 481       g_free ((gchar *) path_copy);</span>
 482 #endif
 483           return ret;
 484         }
 485     }
 486   while (*p++ != &#39;\0&#39;);
 487 
 488   g_free (freeme);
 489 #ifdef G_OS_WIN32
 490   g_free ((gchar *) path_copy);
 491 #endif
 492 
 493   return NULL;
 494 }
 495 
 496 /* The functions below are defined this way for compatibility reasons.
 497  * See the note in gutils.h.
 498  */
 499 
 500 /**
 501  * g_bit_nth_lsf:
</pre>
<hr />
<pre>
 546  * Gets the number of bits used to hold @number,
 547  * e.g. if @number is 4, 3 bits are needed.
 548  *
 549  * Returns: the number of bits used to hold @number
 550  */
 551 guint
 552 (g_bit_storage) (gulong number)
 553 {
 554   return g_bit_storage_impl (number);
 555 }
 556 
 557 G_LOCK_DEFINE_STATIC (g_utils_global);
 558 
 559 typedef struct
 560 {
 561   gchar *user_name;
 562   gchar *real_name;
 563   gchar *home_dir;
 564 } UserDatabaseEntry;
 565 

 566 static  gchar   *g_user_data_dir = NULL;
 567 static  gchar  **g_system_data_dirs = NULL;
 568 static  gchar   *g_user_cache_dir = NULL;
 569 static  gchar   *g_user_config_dir = NULL;

 570 static  gchar  **g_system_config_dirs = NULL;
<span class="line-removed"> 571 </span>
 572 static  gchar  **g_user_special_dirs = NULL;
 573 
 574 /* fifteen minutes of fame for everybody */
 575 #define G_USER_DIRS_EXPIRE      15 * 60
 576 
 577 #ifdef G_OS_WIN32
 578 
 579 static gchar *
 580 get_special_folder (int csidl)
 581 {
 582   wchar_t path[MAX_PATH+1];
 583   HRESULT hr;
 584   LPITEMIDLIST pidl = NULL;
 585   BOOL b;
 586   gchar *retval = NULL;
 587 
 588   hr = SHGetSpecialFolderLocation (NULL, csidl, &amp;pidl);
 589   if (hr == S_OK)
 590     {
 591       b = SHGetPathFromIDListW (pidl, path);
 592       if (b)
<span class="line-modified"> 593     retval = g_utf16_to_utf8 (path, -1, NULL, NULL, NULL);</span>
 594       CoTaskMemFree (pidl);
 595     }
 596   return retval;
 597 }
 598 
 599 static char *
 600 get_windows_directory_root (void)
 601 {
 602   wchar_t wwindowsdir[MAX_PATH];
 603 
 604   if (GetWindowsDirectoryW (wwindowsdir, G_N_ELEMENTS (wwindowsdir)))
 605     {
 606       /* Usually X:\Windows, but in terminal server environments
 607        * might be an UNC path, AFAIK.
 608        */
 609       char *windowsdir = g_utf16_to_utf8 (wwindowsdir, -1, NULL, NULL, NULL);
 610       char *p;
 611 
 612       if (windowsdir == NULL)
<span class="line-modified"> 613     return g_strdup (&quot;C:\\&quot;);</span>
 614 
 615       p = (char *) g_path_skip_root (windowsdir);
 616       if (G_IS_DIR_SEPARATOR (p[-1]) &amp;&amp; p[-2] != &#39;:&#39;)
<span class="line-modified"> 617     p--;</span>
 618       *p = &#39;\0&#39;;
 619       return windowsdir;
 620     }
 621   else
 622     return g_strdup (&quot;C:\\&quot;);
 623 }
 624 
 625 #endif
 626 
 627 /* HOLDS: g_utils_global_lock */
 628 static UserDatabaseEntry *
 629 g_get_user_database_entry (void)
 630 {
 631   static UserDatabaseEntry *entry;
 632 
 633   if (g_once_init_enter (&amp;entry))
 634     {
 635       static UserDatabaseEntry e;
 636 
 637 #ifdef G_OS_UNIX
</pre>
<hr />
<pre>
 781  * g_get_real_name:
 782  *
 783  * Gets the real name of the user. This usually comes from the user&#39;s
 784  * entry in the `passwd` file. The encoding of the returned string is
 785  * system-defined. (On Windows, it is, however, always UTF-8.) If the
 786  * real user name cannot be determined, the string &quot;Unknown&quot; is
 787  * returned.
 788  *
 789  * Returns: (type filename): the user&#39;s real name.
 790  */
 791 const gchar *
 792 g_get_real_name (void)
 793 {
 794   UserDatabaseEntry *entry;
 795 
 796   entry = g_get_user_database_entry ();
 797 
 798   return entry-&gt;real_name;
 799 }
 800 









































































 801 /**
 802  * g_get_home_dir:
 803  *
 804  * Gets the current user&#39;s home directory.
 805  *
 806  * As with most UNIX tools, this function will return the value of the
 807  * `HOME` environment variable if it is set to an existing absolute path
 808  * name, falling back to the `passwd` file in the case that it is unset.
 809  *
 810  * If the path given in `HOME` is non-absolute, does not exist, or is
 811  * not a directory, the result is undefined.
 812  *
 813  * Before version 2.36 this function would ignore the `HOME` environment
 814  * variable, taking the value from the `passwd` database instead. This was
 815  * changed to increase the compatibility of GLib with other programs (and
 816  * the XDG basedir specification) and to increase testability of programs
 817  * based on GLib (by making it easier to run them from test frameworks).
 818  *
 819  * If your program has a strong requirement for either the new or the
 820  * old behaviour (and if you don&#39;t wish to increase your GLib
 821  * dependency to ensure that the new behaviour is in effect) then you
 822  * should either directly check the `HOME` environment variable yourself
 823  * or unset it before calling any functions in GLib.
 824  *
 825  * Returns: (type filename): the current user&#39;s home directory
 826  */
 827 const gchar *
 828 g_get_home_dir (void)
 829 {
<span class="line-modified"> 830   static gchar *home_dir;</span>
<span class="line-removed"> 831 </span>
<span class="line-removed"> 832   if (g_once_init_enter (&amp;home_dir))</span>
<span class="line-removed"> 833     {</span>
<span class="line-removed"> 834       gchar *tmp;</span>
 835 
<span class="line-modified"> 836       /* We first check HOME and use it if it is set */</span>
<span class="line-removed"> 837       tmp = g_strdup (g_getenv (&quot;HOME&quot;));</span>
<span class="line-removed"> 838 </span>
<span class="line-removed"> 839 #ifdef G_OS_WIN32</span>
<span class="line-removed"> 840       /* Only believe HOME if it is an absolute path and exists.</span>
<span class="line-removed"> 841        *</span>
<span class="line-removed"> 842        * We only do this check on Windows for a couple of reasons.</span>
<span class="line-removed"> 843        * Historically, we only did it there because we used to ignore $HOME</span>
<span class="line-removed"> 844        * on UNIX.  There are concerns about enabling it now on UNIX because</span>
<span class="line-removed"> 845        * of things like autofs.  In short, if the user has a bogus value in</span>
<span class="line-removed"> 846        * $HOME then they get what they pay for...</span>
<span class="line-removed"> 847        */</span>
<span class="line-removed"> 848       if (tmp)</span>
<span class="line-removed"> 849         {</span>
<span class="line-removed"> 850           if (!(g_path_is_absolute (tmp) &amp;&amp;</span>
<span class="line-removed"> 851                 g_file_test (tmp, G_FILE_TEST_IS_DIR)))</span>
<span class="line-removed"> 852             {</span>
<span class="line-removed"> 853               g_free (tmp);</span>
<span class="line-removed"> 854               tmp = NULL;</span>
<span class="line-removed"> 855             }</span>
<span class="line-removed"> 856         }</span>
<span class="line-removed"> 857 </span>
<span class="line-removed"> 858       /* In case HOME is Unix-style (it happens), convert it to</span>
<span class="line-removed"> 859        * Windows style.</span>
<span class="line-removed"> 860        */</span>
<span class="line-removed"> 861       if (tmp)</span>
<span class="line-removed"> 862         {</span>
<span class="line-removed"> 863           gchar *p;</span>
<span class="line-removed"> 864           while ((p = strchr (tmp, &#39;/&#39;)) != NULL)</span>
<span class="line-removed"> 865             *p = &#39;\\&#39;;</span>
<span class="line-removed"> 866         }</span>
<span class="line-removed"> 867 </span>
<span class="line-removed"> 868       if (!tmp)</span>
<span class="line-removed"> 869         {</span>
<span class="line-removed"> 870           /* USERPROFILE is probably the closest equivalent to $HOME? */</span>
<span class="line-removed"> 871           if (g_getenv (&quot;USERPROFILE&quot;) != NULL)</span>
<span class="line-removed"> 872             tmp = g_strdup (g_getenv (&quot;USERPROFILE&quot;));</span>
<span class="line-removed"> 873         }</span>
<span class="line-removed"> 874 </span>
<span class="line-removed"> 875       if (!tmp)</span>
<span class="line-removed"> 876         tmp = get_special_folder (CSIDL_PROFILE);</span>
<span class="line-removed"> 877 </span>
<span class="line-removed"> 878       if (!tmp)</span>
<span class="line-removed"> 879         tmp = get_windows_directory_root ();</span>
<span class="line-removed"> 880 #endif /* G_OS_WIN32 */</span>
<span class="line-removed"> 881 </span>
<span class="line-removed"> 882       if (!tmp)</span>
<span class="line-removed"> 883         {</span>
<span class="line-removed"> 884           /* If we didn&#39;t get it from any of those methods, we will have</span>
<span class="line-removed"> 885            * to read the user database entry.</span>
<span class="line-removed"> 886            */</span>
<span class="line-removed"> 887           UserDatabaseEntry *entry;</span>
<span class="line-removed"> 888 </span>
<span class="line-removed"> 889           entry = g_get_user_database_entry ();</span>
<span class="line-removed"> 890 </span>
<span class="line-removed"> 891           /* Strictly speaking, we should copy this, but we know that</span>
<span class="line-removed"> 892            * neither will ever be freed, so don&#39;t bother...</span>
<span class="line-removed"> 893            */</span>
<span class="line-removed"> 894           tmp = entry-&gt;home_dir;</span>
<span class="line-removed"> 895         }</span>
 896 
<span class="line-modified"> 897       /* If we have been denied access to /etc/passwd (for example, by an</span>
<span class="line-modified"> 898        * overly-zealous LSM), make up a junk value. The return value at this</span>
<span class="line-modified"> 899        * point is explicitly documented as �?undefined’. Memory management is as</span>
<span class="line-removed"> 900        * immediately above: strictly this should be copied, but we know not</span>
<span class="line-removed"> 901        * copying it is OK. */</span>
<span class="line-removed"> 902       if (tmp == NULL)</span>
<span class="line-removed"> 903         {</span>
<span class="line-removed"> 904           g_warning (&quot;Could not find home directory: $HOME is not set, and &quot;</span>
<span class="line-removed"> 905                      &quot;user database could not be read.&quot;);</span>
<span class="line-removed"> 906           tmp = &quot;/&quot;;</span>
<span class="line-removed"> 907         }</span>
 908 
<span class="line-modified"> 909       g_once_init_leave (&amp;home_dir, tmp);</span>
<span class="line-removed"> 910     }</span>
 911 
 912   return home_dir;
 913 }
 914 
 915 /**
 916  * g_get_tmp_dir:
 917  *
 918  * Gets the directory to use for temporary files.
 919  *
 920  * On UNIX, this is taken from the `TMPDIR` environment variable.
 921  * If the variable is not set, `P_tmpdir` is
 922  * used, as defined by the system C library. Failing that, a
 923  * hard-coded default of &quot;/tmp&quot; is returned.
 924  *
 925  * On Windows, the `TEMP` environment variable is used, with the
 926  * root directory of the Windows installation (eg: &quot;C:\&quot;) used
 927  * as a default.
 928  *
 929  * The encoding of the returned string is system-defined. On Windows,
 930  * it is always UTF-8. The return value is never %NULL or the empty
</pre>
<hr />
<pre>
 993  * name can be determined, a default fixed string &quot;localhost&quot; is
 994  * returned.
 995  *
 996  * The encoding of the returned string is UTF-8.
 997  *
 998  * Returns: the host name of the machine.
 999  *
1000  * Since: 2.8
1001  */
1002 const gchar *
1003 g_get_host_name (void)
1004 {
1005   static gchar *hostname;
1006 
1007   if (g_once_init_enter (&amp;hostname))
1008     {
1009       gboolean failed;
1010       gchar *utmp;
1011 
1012 #ifndef G_OS_WIN32
<span class="line-modified">1013       gchar *tmp = g_malloc (sizeof (gchar) * 100);</span>
<span class="line-modified">1014       failed = (gethostname (tmp, sizeof (gchar) * 100) == -1);</span>





























1015       if (failed)
1016         g_clear_pointer (&amp;tmp, g_free);
1017       utmp = tmp;
1018 #else
1019       wchar_t tmp[MAX_COMPUTERNAME_LENGTH + 1];
1020       DWORD size = sizeof (tmp) / sizeof (tmp[0]);
1021       failed = (!GetComputerNameW (tmp, &amp;size));
1022       if (!failed)
1023         utmp = g_utf16_to_utf8 (tmp, size, NULL, NULL, NULL);
1024       if (utmp == NULL)
1025         failed = TRUE;
1026 #endif
1027 
1028       g_once_init_leave (&amp;hostname, failed ? g_strdup (&quot;localhost&quot;) : utmp);
1029     }
1030 
1031   return hostname;
1032 }
1033 
1034 G_LOCK_DEFINE_STATIC (g_prgname);
1035 static gchar *g_prgname = NULL;
1036 
1037 /**
1038  * g_get_prgname:
1039  *
1040  * Gets the name of the program. This name should not be localized,
1041  * in contrast to g_get_application_name().
1042  *
1043  * If you are using #GApplication the program name is set in
1044  * g_application_run(). In case of GDK or GTK+ it is set in
1045  * gdk_init(), which is called by gtk_init() and the
1046  * #GtkApplication::startup handler. The program name is found by
1047  * taking the last component of @argv[0].
1048  *
<span class="line-modified">1049  * Returns: the name of the program. The returned string belongs</span>

1050  *     to GLib and must not be modified or freed.
1051  */
1052 const gchar*
1053 g_get_prgname (void)
1054 {
1055   gchar* retval;
1056 
1057   G_LOCK (g_prgname);
<span class="line-removed">1058 #ifdef G_OS_WIN32</span>
<span class="line-removed">1059   if (g_prgname == NULL)</span>
<span class="line-removed">1060     {</span>
<span class="line-removed">1061       static gboolean beenhere = FALSE;</span>
<span class="line-removed">1062 </span>
<span class="line-removed">1063       if (!beenhere)</span>
<span class="line-removed">1064     {</span>
<span class="line-removed">1065       gchar *utf8_buf = NULL;</span>
<span class="line-removed">1066       wchar_t buf[MAX_PATH+1];</span>
<span class="line-removed">1067 </span>
<span class="line-removed">1068       beenhere = TRUE;</span>
<span class="line-removed">1069       if (GetModuleFileNameW (GetModuleHandle (NULL),</span>
<span class="line-removed">1070                   buf, G_N_ELEMENTS (buf)) &gt; 0)</span>
<span class="line-removed">1071         utf8_buf = g_utf16_to_utf8 (buf, -1, NULL, NULL, NULL);</span>
<span class="line-removed">1072 </span>
<span class="line-removed">1073       if (utf8_buf)</span>
<span class="line-removed">1074         {</span>
<span class="line-removed">1075           g_prgname = g_path_get_basename (utf8_buf);</span>
<span class="line-removed">1076           g_free (utf8_buf);</span>
<span class="line-removed">1077         }</span>
<span class="line-removed">1078     }</span>
<span class="line-removed">1079     }</span>
<span class="line-removed">1080 #endif</span>
1081   retval = g_prgname;
1082   G_UNLOCK (g_prgname);
1083 
1084   return retval;
1085 }
1086 
1087 /**
1088  * g_set_prgname:
1089  * @prgname: the name of the program.
1090  *
1091  * Sets the name of the program. This name should not be localized,
1092  * in contrast to g_set_application_name().
1093  *
1094  * If you are using #GApplication the program name is set in
1095  * g_application_run(). In case of GDK or GTK+ it is set in
1096  * gdk_init(), which is called by gtk_init() and the
1097  * #GtkApplication::startup handler. The program name is found by
1098  * taking the last component of @argv[0].
1099  *
1100  * Note that for thread-safety reasons this function can only be called once.
</pre>
<hr />
<pre>
1158  * or when displaying an application&#39;s name in the task list.
1159  *
1160  * Since: 2.2
1161  **/
1162 void
1163 g_set_application_name (const gchar *application_name)
1164 {
1165   gboolean already_set = FALSE;
1166 
1167   G_LOCK (g_application_name);
1168   if (g_application_name)
1169     already_set = TRUE;
1170   else
1171     g_application_name = g_strdup (application_name);
1172   G_UNLOCK (g_application_name);
1173 
1174   if (already_set)
1175     g_warning (&quot;g_set_application_name() called multiple times&quot;);
1176 }
1177 

































































































































1178 /**
1179  * g_get_user_data_dir:
1180  *
1181  * Returns a base directory in which to access application data such
1182  * as icons that is customized for a particular user.
1183  *
1184  * On UNIX platforms this is determined using the mechanisms described
1185  * in the
1186  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1187  * In this case the directory retrieved will be `XDG_DATA_HOME`.
1188  *
1189  * On Windows it follows XDG Base Directory Specification if `XDG_DATA_HOME`
1190  * is defined. If `XDG_DATA_HOME` is undefined, the folder to use for local (as
1191  * opposed to roaming) application data is used instead. See the
1192  * [documentation for `CSIDL_LOCAL_APPDATA`](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx#csidl_local_appdata).
1193  * Note that in this case on Windows it will be the same
1194  * as what g_get_user_config_dir() returns.
1195  *
1196  * Returns: (type filename): a string owned by GLib that must not be modified
1197  *               or freed.
1198  * Since: 2.6
1199  **/
1200 const gchar *
1201 g_get_user_data_dir (void)
1202 {
<span class="line-modified">1203   gchar *data_dir = NULL;</span>
1204 
1205   G_LOCK (g_utils_global);
1206 
<span class="line-modified">1207   if (!g_user_data_dir)</span>
<span class="line-modified">1208     {</span>
<span class="line-modified">1209       const gchar *data_dir_env = g_getenv (&quot;XDG_DATA_HOME&quot;);</span>
<span class="line-removed">1210 </span>
<span class="line-removed">1211       if (data_dir_env &amp;&amp; data_dir_env[0])</span>
<span class="line-removed">1212         data_dir = g_strdup (data_dir_env);</span>
<span class="line-removed">1213 #ifdef G_OS_WIN32</span>
<span class="line-removed">1214       else</span>
<span class="line-removed">1215       data_dir = get_special_folder (CSIDL_LOCAL_APPDATA);</span>
<span class="line-removed">1216 #endif</span>
<span class="line-removed">1217       if (!data_dir || !data_dir[0])</span>
<span class="line-removed">1218     {</span>
<span class="line-removed">1219           const gchar *home_dir = g_get_home_dir ();</span>
<span class="line-removed">1220 </span>
<span class="line-removed">1221           if (home_dir)</span>
<span class="line-removed">1222             data_dir = g_build_filename (home_dir, &quot;.local&quot;, &quot;share&quot;, NULL);</span>
<span class="line-removed">1223       else</span>
<span class="line-removed">1224             data_dir = g_build_filename (g_get_tmp_dir (), g_get_user_name (), &quot;.local&quot;, &quot;share&quot;, NULL);</span>
<span class="line-removed">1225     }</span>
<span class="line-removed">1226 </span>
<span class="line-removed">1227       g_user_data_dir = data_dir;</span>
<span class="line-removed">1228     }</span>
<span class="line-removed">1229   else</span>
<span class="line-removed">1230     data_dir = g_user_data_dir;</span>
1231 
1232   G_UNLOCK (g_utils_global);
1233 
<span class="line-modified">1234   return data_dir;</span>
1235 }
1236 
<span class="line-modified">1237 static void</span>
<span class="line-modified">1238 g_init_user_config_dir (void)</span>
1239 {
1240   gchar *config_dir = NULL;

1241 
<span class="line-modified">1242   if (!g_user_config_dir)</span>
<span class="line-removed">1243     {</span>
<span class="line-removed">1244       const gchar *config_dir_env = g_getenv (&quot;XDG_CONFIG_HOME&quot;);</span>
<span class="line-removed">1245 </span>
<span class="line-removed">1246       if (config_dir_env &amp;&amp; config_dir_env[0])</span>
1247     config_dir = g_strdup (config_dir_env);
1248 #ifdef G_OS_WIN32
<span class="line-modified">1249       else</span>
<span class="line-modified">1250       config_dir = get_special_folder (CSIDL_LOCAL_APPDATA);</span>
1251 #endif
<span class="line-modified">1252       if (!config_dir || !config_dir[0])</span>
1253     {
<span class="line-modified">1254           const gchar *home_dir = g_get_home_dir ();</span>
<span class="line-modified">1255 </span>
<span class="line-modified">1256           if (home_dir)</span>
<span class="line-removed">1257             config_dir = g_build_filename (home_dir, &quot;.config&quot;, NULL);</span>
<span class="line-removed">1258       else</span>
<span class="line-removed">1259             config_dir = g_build_filename (g_get_tmp_dir (), g_get_user_name (), &quot;.config&quot;, NULL);</span>
1260     }
1261 
<span class="line-modified">1262       g_user_config_dir = config_dir;</span>
<span class="line-removed">1263     }</span>
1264 }
1265 
1266 /**
1267  * g_get_user_config_dir:
1268  *
1269  * Returns a base directory in which to store user-specific application
1270  * configuration information such as user preferences and settings.
1271  *
1272  * On UNIX platforms this is determined using the mechanisms described
1273  * in the
1274  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1275  * In this case the directory retrieved will be `XDG_CONFIG_HOME`.
1276  *
1277  * On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_HOME` is defined.
1278  * If `XDG_CONFIG_HOME` is undefined, the folder to use for local (as opposed
1279  * to roaming) application data is used instead. See the
1280  * [documentation for `CSIDL_LOCAL_APPDATA`](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx#csidl_local_appdata).
1281  * Note that in this case on Windows it will be  the same
1282  * as what g_get_user_data_dir() returns.
1283  *
1284  * Returns: (type filename): a string owned by GLib that must not be modified
1285  *               or freed.
1286  * Since: 2.6
1287  **/
1288 const gchar *
1289 g_get_user_config_dir (void)
1290 {


1291   G_LOCK (g_utils_global);
1292 
<span class="line-modified">1293   g_init_user_config_dir ();</span>


1294 
1295   G_UNLOCK (g_utils_global);
1296 
<span class="line-modified">1297   return g_user_config_dir;</span>






















1298 }
1299 
1300 /**
1301  * g_get_user_cache_dir:
1302  *
1303  * Returns a base directory in which to store non-essential, cached
1304  * data specific to particular user.
1305  *
1306  * On UNIX platforms this is determined using the mechanisms described
1307  * in the
1308  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1309  * In this case the directory retrieved will be `XDG_CACHE_HOME`.
1310  *
1311  * On Windows it follows XDG Base Directory Specification if `XDG_CACHE_HOME` is defined.
1312  * If `XDG_CACHE_HOME` is undefined, the directory that serves as a common
1313  * repository for temporary Internet files is used instead. A typical path is
1314  * `C:\Documents and Settings\username\Local Settings\Temporary Internet Files`.
1315  * See the [documentation for `CSIDL_INTERNET_CACHE`](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx#csidl_internet_cache).
1316  *
1317  * Returns: (type filename): a string owned by GLib that must not be modified
1318  *               or freed.
1319  * Since: 2.6
1320  **/
1321 const gchar *
1322 g_get_user_cache_dir (void)
1323 {
<span class="line-modified">1324   gchar *cache_dir = NULL;</span>
1325 
1326   G_LOCK (g_utils_global);
1327 
<span class="line-modified">1328   if (!g_user_cache_dir)</span>
<span class="line-modified">1329     {</span>
<span class="line-modified">1330       const gchar *cache_dir_env = g_getenv (&quot;XDG_CACHE_HOME&quot;);</span>
1331 
<span class="line-modified">1332       if (cache_dir_env &amp;&amp; cache_dir_env[0])</span>
<span class="line-removed">1333         cache_dir = g_strdup (cache_dir_env);</span>
<span class="line-removed">1334 #ifdef G_OS_WIN32</span>
<span class="line-removed">1335       else</span>
<span class="line-removed">1336         cache_dir = get_special_folder (CSIDL_INTERNET_CACHE);</span>
<span class="line-removed">1337 #endif</span>
<span class="line-removed">1338       if (!cache_dir || !cache_dir[0])</span>
<span class="line-removed">1339     {</span>
<span class="line-removed">1340           const gchar *home_dir = g_get_home_dir ();</span>
1341 
<span class="line-modified">1342           if (home_dir)</span>
<span class="line-modified">1343             cache_dir = g_build_filename (home_dir, &quot;.cache&quot;, NULL);</span>
<span class="line-modified">1344       else</span>
<span class="line-modified">1345             cache_dir = g_build_filename (g_get_tmp_dir (), g_get_user_name (), &quot;.cache&quot;, NULL);</span>
<span class="line-modified">1346     }</span>
<span class="line-modified">1347       g_user_cache_dir = cache_dir;</span>
<span class="line-modified">1348     }</span>




1349   else
<span class="line-modified">1350     cache_dir = g_user_cache_dir;</span>

1351 
<span class="line-modified">1352   G_UNLOCK (g_utils_global);</span>











1353 
<span class="line-modified">1354   return cache_dir;</span>
1355 }
1356 
1357 /**
1358  * g_get_user_runtime_dir:
1359  *
1360  * Returns a directory that is unique to the current user on the local
1361  * system.
1362  *
1363  * This is determined using the mechanisms described
1364  * in the
1365  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1366  * This is the directory
1367  * specified in the `XDG_RUNTIME_DIR` environment variable.
1368  * In the case that this variable is not set, we return the value of
1369  * g_get_user_cache_dir(), after verifying that it exists.
1370  *
1371  * Returns: (type filename): a string owned by GLib that must not be
1372  *     modified or freed.
1373  *
1374  * Since: 2.28
1375  **/
1376 const gchar *
1377 g_get_user_runtime_dir (void)
1378 {
<span class="line-modified">1379   static const gchar *runtime_dir;</span>
<span class="line-removed">1380 </span>
<span class="line-removed">1381   if (g_once_init_enter (&amp;runtime_dir))</span>
<span class="line-removed">1382     {</span>
<span class="line-removed">1383       const gchar *dir;</span>
<span class="line-removed">1384 </span>
<span class="line-removed">1385       dir = g_strdup (getenv (&quot;XDG_RUNTIME_DIR&quot;));</span>
1386 
<span class="line-modified">1387       if (dir == NULL)</span>
<span class="line-removed">1388         {</span>
<span class="line-removed">1389           /* No need to strdup this one since it is valid forever. */</span>
<span class="line-removed">1390           dir = g_get_user_cache_dir ();</span>
<span class="line-removed">1391 </span>
<span class="line-removed">1392           /* The user should be able to rely on the directory existing</span>
<span class="line-removed">1393            * when the function returns.  Probably it already does, but</span>
<span class="line-removed">1394            * let&#39;s make sure.  Just do mkdir() directly since it will be</span>
<span class="line-removed">1395            * no more expensive than a stat() in the case that the</span>
<span class="line-removed">1396            * directory already exists and is a lot easier.</span>
<span class="line-removed">1397            *</span>
<span class="line-removed">1398            * $XDG_CACHE_HOME is probably ~/.cache/ so as long as $HOME</span>
<span class="line-removed">1399            * exists this will work.  If the user changed $XDG_CACHE_HOME</span>
<span class="line-removed">1400            * then they can make sure that it exists...</span>
<span class="line-removed">1401    */</span>
<span class="line-removed">1402           (void) g_mkdir (dir, 0700);</span>
<span class="line-removed">1403         }</span>
1404 
<span class="line-modified">1405       g_assert (dir != NULL);</span>


1406 
<span class="line-modified">1407       g_once_init_leave (&amp;runtime_dir, dir);</span>
<span class="line-removed">1408 }</span>
1409 
<span class="line-modified">1410   return runtime_dir;</span>
1411 }
1412 
<span class="line-modified">1413 #ifdef HAVE_CARBON</span>
1414 
<span class="line-modified">1415 static gchar *</span>
<span class="line-modified">1416 find_folder (OSType type)</span>
<span class="line-removed">1417 {</span>
<span class="line-removed">1418   gchar *filename = NULL;</span>
<span class="line-removed">1419   FSRef  found;</span>
<span class="line-removed">1420 </span>
<span class="line-removed">1421   if (FSFindFolder (kUserDomain, type, kDontCreateFolder, &amp;found) == noErr)</span>
<span class="line-removed">1422     {</span>
<span class="line-removed">1423       CFURLRef url = CFURLCreateFromFSRef (kCFAllocatorSystemDefault, &amp;found);</span>
<span class="line-removed">1424 </span>
<span class="line-removed">1425       if (url)</span>
<span class="line-removed">1426     {</span>
<span class="line-removed">1427       CFStringRef path = CFURLCopyFileSystemPath (url, kCFURLPOSIXPathStyle);</span>
<span class="line-removed">1428 </span>
<span class="line-removed">1429       if (path)</span>
<span class="line-removed">1430         {</span>
<span class="line-removed">1431           filename = g_strdup (CFStringGetCStringPtr (path, kCFStringEncodingUTF8));</span>
<span class="line-removed">1432 </span>
<span class="line-removed">1433           if (! filename)</span>
<span class="line-removed">1434         {</span>
<span class="line-removed">1435           filename = g_new0 (gchar, CFStringGetLength (path) * 3 + 1);</span>
<span class="line-removed">1436 </span>
<span class="line-removed">1437           CFStringGetCString (path, filename,</span>
<span class="line-removed">1438                       CFStringGetLength (path) * 3 + 1,</span>
<span class="line-removed">1439                       kCFStringEncodingUTF8);</span>
<span class="line-removed">1440         }</span>
<span class="line-removed">1441 </span>
<span class="line-removed">1442           CFRelease (path);</span>
<span class="line-removed">1443         }</span>
<span class="line-removed">1444 </span>
<span class="line-removed">1445       CFRelease (url);</span>
<span class="line-removed">1446     }</span>
<span class="line-removed">1447     }</span>
<span class="line-removed">1448 </span>
<span class="line-removed">1449   return filename;</span>
<span class="line-removed">1450 }</span>
1451 
1452 static void
1453 load_user_special_dirs (void)
1454 {
<span class="line-modified">1455   g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = find_folder (kDesktopFolderType);</span>
<span class="line-removed">1456   g_user_special_dirs[G_USER_DIRECTORY_DOCUMENTS] = find_folder (kDocumentsFolderType);</span>
<span class="line-removed">1457   g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = find_folder (kDesktopFolderType); /* XXX correct ? */</span>
<span class="line-removed">1458   g_user_special_dirs[G_USER_DIRECTORY_MUSIC] = find_folder (kMusicDocumentsFolderType);</span>
<span class="line-removed">1459   g_user_special_dirs[G_USER_DIRECTORY_PICTURES] = find_folder (kPictureDocumentsFolderType);</span>
<span class="line-removed">1460   g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = NULL;</span>
<span class="line-removed">1461   g_user_special_dirs[G_USER_DIRECTORY_TEMPLATES] = NULL;</span>
<span class="line-removed">1462   g_user_special_dirs[G_USER_DIRECTORY_VIDEOS] = find_folder (kMovieDocumentsFolderType);</span>
1463 }
1464 
1465 #elif defined(G_OS_WIN32)
1466 
1467 static void
1468 load_user_special_dirs (void)
1469 {
1470   typedef HRESULT (WINAPI *t_SHGetKnownFolderPath) (const GUID *rfid,
<span class="line-modified">1471                             DWORD dwFlags,</span>
<span class="line-modified">1472                             HANDLE hToken,</span>
<span class="line-modified">1473                             PWSTR *ppszPath);</span>
1474   t_SHGetKnownFolderPath p_SHGetKnownFolderPath;
1475 
1476   static const GUID FOLDERID_Downloads =
1477     { 0x374de290, 0x123f, 0x4565, { 0x91, 0x64, 0x39, 0xc4, 0x92, 0x5e, 0x46, 0x7b } };
1478   static const GUID FOLDERID_Public =
1479     { 0xDFDF76A2, 0xC82A, 0x4D63, { 0x90, 0x6A, 0x56, 0x44, 0xAC, 0x45, 0x73, 0x85 } };
1480 
1481   wchar_t *wcp;
1482 
1483   p_SHGetKnownFolderPath = (t_SHGetKnownFolderPath) GetProcAddress (GetModuleHandle (&quot;shell32.dll&quot;),
<span class="line-modified">1484                                     &quot;SHGetKnownFolderPath&quot;);</span>
1485 
1486   g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
1487   g_user_special_dirs[G_USER_DIRECTORY_DOCUMENTS] = get_special_folder (CSIDL_PERSONAL);
1488 
1489   if (p_SHGetKnownFolderPath == NULL)
1490     {
1491       g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
1492     }
1493   else
1494     {
1495       wcp = NULL;
1496       (*p_SHGetKnownFolderPath) (&amp;FOLDERID_Downloads, 0, NULL, &amp;wcp);
1497       if (wcp)
1498         {
1499           g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = g_utf16_to_utf8 (wcp, -1, NULL, NULL, NULL);
1500           if (g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] == NULL)
1501               g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
1502           CoTaskMemFree (wcp);
1503         }
1504       else
</pre>
<hr />
<pre>
1544  * including without limitation the rights to use, copy, modify, merge,
1545  * publish, distribute, sublicense, and/or sell copies of the Software,
1546  * and to permit persons to whom the Software is furnished to do so,
1547  * subject to the following conditions:
1548  *
1549  * The above copyright notice and this permission notice shall be
1550  * included in all copies or substantial portions of the Software.
1551  *
1552  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
1553  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
1554  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
1555  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
1556  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
1557  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
1558  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
1559  * SOFTWARE.
1560  */
1561 static void
1562 load_user_special_dirs (void)
1563 {

1564   gchar *config_file;
1565   gchar *data;
1566   gchar **lines;
1567   gint n_lines, i;
1568 
<span class="line-modified">1569   g_init_user_config_dir ();</span>
<span class="line-modified">1570   config_file = g_build_filename (g_user_config_dir,</span>
1571                                   &quot;user-dirs.dirs&quot;,
1572                                   NULL);

1573 
1574   if (!g_file_get_contents (config_file, &amp;data, NULL, NULL))
1575     {
1576       g_free (config_file);
1577       return;
1578     }
1579 
1580   lines = g_strsplit (data, &quot;\n&quot;, -1);
1581   n_lines = g_strv_length (lines);
1582   g_free (data);
1583 
1584   for (i = 0; i &lt; n_lines; i++)
1585     {
1586       gchar *buffer = lines[i];
1587       gchar *d, *p;
1588       gint len;
1589       gboolean is_relative = FALSE;
1590       GUserDirectory directory;
1591 
1592       /* Remove newline at end */
1593       len = strlen (buffer);
1594       if (len &gt; 0 &amp;&amp; buffer[len - 1] == &#39;\n&#39;)
<span class="line-modified">1595     buffer[len - 1] = 0;</span>
1596 
1597       p = buffer;
1598       while (*p == &#39; &#39; || *p == &#39;\t&#39;)
<span class="line-modified">1599     p++;</span>
1600 
1601       if (strncmp (p, &quot;XDG_DESKTOP_DIR&quot;, strlen (&quot;XDG_DESKTOP_DIR&quot;)) == 0)
1602         {
1603           directory = G_USER_DIRECTORY_DESKTOP;
1604           p += strlen (&quot;XDG_DESKTOP_DIR&quot;);
1605         }
1606       else if (strncmp (p, &quot;XDG_DOCUMENTS_DIR&quot;, strlen (&quot;XDG_DOCUMENTS_DIR&quot;)) == 0)
1607         {
1608           directory = G_USER_DIRECTORY_DOCUMENTS;
1609           p += strlen (&quot;XDG_DOCUMENTS_DIR&quot;);
1610         }
1611       else if (strncmp (p, &quot;XDG_DOWNLOAD_DIR&quot;, strlen (&quot;XDG_DOWNLOAD_DIR&quot;)) == 0)
1612         {
1613           directory = G_USER_DIRECTORY_DOWNLOAD;
1614           p += strlen (&quot;XDG_DOWNLOAD_DIR&quot;);
1615         }
1616       else if (strncmp (p, &quot;XDG_MUSIC_DIR&quot;, strlen (&quot;XDG_MUSIC_DIR&quot;)) == 0)
1617         {
1618           directory = G_USER_DIRECTORY_MUSIC;
1619           p += strlen (&quot;XDG_MUSIC_DIR&quot;);
</pre>
<hr />
<pre>
1622         {
1623           directory = G_USER_DIRECTORY_PICTURES;
1624           p += strlen (&quot;XDG_PICTURES_DIR&quot;);
1625         }
1626       else if (strncmp (p, &quot;XDG_PUBLICSHARE_DIR&quot;, strlen (&quot;XDG_PUBLICSHARE_DIR&quot;)) == 0)
1627         {
1628           directory = G_USER_DIRECTORY_PUBLIC_SHARE;
1629           p += strlen (&quot;XDG_PUBLICSHARE_DIR&quot;);
1630         }
1631       else if (strncmp (p, &quot;XDG_TEMPLATES_DIR&quot;, strlen (&quot;XDG_TEMPLATES_DIR&quot;)) == 0)
1632         {
1633           directory = G_USER_DIRECTORY_TEMPLATES;
1634           p += strlen (&quot;XDG_TEMPLATES_DIR&quot;);
1635         }
1636       else if (strncmp (p, &quot;XDG_VIDEOS_DIR&quot;, strlen (&quot;XDG_VIDEOS_DIR&quot;)) == 0)
1637         {
1638           directory = G_USER_DIRECTORY_VIDEOS;
1639           p += strlen (&quot;XDG_VIDEOS_DIR&quot;);
1640         }
1641       else
<span class="line-modified">1642     continue;</span>
1643 
1644       while (*p == &#39; &#39; || *p == &#39;\t&#39;)
<span class="line-modified">1645     p++;</span>
1646 
1647       if (*p != &#39;=&#39;)
<span class="line-modified">1648     continue;</span>
1649       p++;
1650 
1651       while (*p == &#39; &#39; || *p == &#39;\t&#39;)
<span class="line-modified">1652     p++;</span>
1653 
1654       if (*p != &#39;&quot;&#39;)
<span class="line-modified">1655     continue;</span>
1656       p++;
1657 
1658       if (strncmp (p, &quot;$HOME&quot;, 5) == 0)
<span class="line-modified">1659     {</span>
<span class="line-modified">1660       p += 5;</span>
<span class="line-modified">1661       is_relative = TRUE;</span>
<span class="line-modified">1662     }</span>
1663       else if (*p != &#39;/&#39;)
<span class="line-modified">1664     continue;</span>
1665 
1666       d = strrchr (p, &#39;&quot;&#39;);
1667       if (!d)
1668         continue;
1669       *d = 0;
1670 
1671       d = p;
1672 
1673       /* remove trailing slashes */
1674       len = strlen (d);
1675       if (d[len - 1] == &#39;/&#39;)
1676         d[len - 1] = 0;
1677 
1678       if (is_relative)
1679         {
<span class="line-modified">1680           g_user_special_dirs[directory] = g_build_filename (g_get_home_dir (), d, NULL);</span>


1681         }
1682       else
<span class="line-modified">1683     g_user_special_dirs[directory] = g_strdup (d);</span>
1684     }
1685 
1686   g_strfreev (lines);
1687   g_free (config_file);
1688 }
1689 
1690 #endif /* platform-specific load_user_special_dirs implementations */
1691 
1692 
1693 /**
1694  * g_reload_user_special_dirs_cache:
1695  *
1696  * Resets the cache used for g_get_user_special_dir(), so
1697  * that the latest on-disk version is used. Call this only
1698  * if you just changed the data on disk yourself.
1699  *
<span class="line-modified">1700  * Due to threadsafety issues this may cause leaking of strings</span>
1701  * that were previously returned from g_get_user_special_dir()
1702  * that can&#39;t be freed. We ensure to only leak the data for
1703  * the directories that actually changed value though.
1704  *
1705  * Since: 2.22
1706  */
1707 void
1708 g_reload_user_special_dirs_cache (void)
1709 {
1710   int i;
1711 
1712   G_LOCK (g_utils_global);
1713 
1714   if (g_user_special_dirs != NULL)
1715     {
1716       /* save a copy of the pointer, to check if some memory can be preserved */
1717       char **old_g_user_special_dirs = g_user_special_dirs;
1718       char *old_val;
1719 
1720       /* recreate and reload our cache */
</pre>
<hr />
<pre>
1753  * Returns the full path of a special directory using its logical id.
1754  *
1755  * On UNIX this is done using the XDG special user directories.
1756  * For compatibility with existing practise, %G_USER_DIRECTORY_DESKTOP
1757  * falls back to `$HOME/Desktop` when XDG special user directories have
1758  * not been set up.
1759  *
1760  * Depending on the platform, the user might be able to change the path
1761  * of the special directory without requiring the session to restart; GLib
1762  * will not reflect any change once the special directories are loaded.
1763  *
1764  * Returns: (type filename): the path to the specified special directory, or
1765  *   %NULL if the logical id was not found. The returned string is owned by
1766  *   GLib and should not be modified or freed.
1767  *
1768  * Since: 2.14
1769  */
1770 const gchar *
1771 g_get_user_special_dir (GUserDirectory directory)
1772 {


1773   g_return_val_if_fail (directory &gt;= G_USER_DIRECTORY_DESKTOP &amp;&amp;
1774                         directory &lt; G_USER_N_DIRECTORIES, NULL);
1775 
1776   G_LOCK (g_utils_global);
1777 
1778   if (G_UNLIKELY (g_user_special_dirs == NULL))
1779     {
1780       g_user_special_dirs = g_new0 (gchar *, G_USER_N_DIRECTORIES);
1781 
1782       load_user_special_dirs ();
1783 
1784       /* Special-case desktop for historical compatibility */
1785       if (g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] == NULL)
<span class="line-modified">1786         g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = g_build_filename (g_get_home_dir (), &quot;Desktop&quot;, NULL);</span>




1787     }

1788 
1789   G_UNLOCK (g_utils_global);
1790 
<span class="line-modified">1791   return g_user_special_dirs[directory];</span>
1792 }
1793 
1794 #ifdef G_OS_WIN32
1795 
1796 #undef g_get_system_data_dirs
1797 
1798 static HMODULE
1799 get_module_for_address (gconstpointer address)
1800 {
1801   /* Holds the g_utils_global lock */
1802 
1803   static gboolean beenhere = FALSE;
1804   typedef BOOL (WINAPI *t_GetModuleHandleExA) (DWORD, LPCTSTR, HMODULE *);
1805   static t_GetModuleHandleExA p_GetModuleHandleExA = NULL;
1806   HMODULE hmodule = NULL;
1807 
1808   if (!address)
1809     return NULL;
1810 
1811   if (!beenhere)
1812     {
1813       p_GetModuleHandleExA =
<span class="line-modified">1814     (t_GetModuleHandleExA) GetProcAddress (GetModuleHandle (&quot;kernel32.dll&quot;),</span>
<span class="line-modified">1815                            &quot;GetModuleHandleExA&quot;);</span>
1816       beenhere = TRUE;
1817     }
1818 
1819   if (p_GetModuleHandleExA == NULL ||
1820       !(*p_GetModuleHandleExA) (GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT |
<span class="line-modified">1821                 GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,</span>
<span class="line-modified">1822                 address, &amp;hmodule))</span>
1823     {
1824       MEMORY_BASIC_INFORMATION mbi;
1825       VirtualQuery (address, &amp;mbi, sizeof (mbi));
1826       hmodule = (HMODULE) mbi.AllocationBase;
1827     }
1828 
1829   return hmodule;
1830 }
1831 
1832 static gchar *
1833 get_module_share_dir (gconstpointer address)
1834 {
1835   HMODULE hmodule;
1836   gchar *filename;
1837   gchar *retval;
1838 
1839   hmodule = get_module_for_address (address);
1840   if (hmodule == NULL)
1841     return NULL;
1842 
</pre>
<hr />
<pre>
1846 
1847   return retval;
1848 }
1849 
1850 static const gchar * const *
1851 g_win32_get_system_data_dirs_for_module_real (void (*address_of_function)(void))
1852 {
1853   GArray *data_dirs;
1854   HMODULE hmodule;
1855   static GHashTable *per_module_data_dirs = NULL;
1856   gchar **retval;
1857   gchar *p;
1858   gchar *exe_root;
1859 
1860   hmodule = NULL;
1861   if (address_of_function)
1862     {
1863       G_LOCK (g_utils_global);
1864       hmodule = get_module_for_address (address_of_function);
1865       if (hmodule != NULL)
<span class="line-modified">1866     {</span>
<span class="line-modified">1867       if (per_module_data_dirs == NULL)</span>
<span class="line-modified">1868         per_module_data_dirs = g_hash_table_new (NULL, NULL);</span>
<span class="line-modified">1869       else</span>
<span class="line-modified">1870         {</span>
<span class="line-modified">1871           retval = g_hash_table_lookup (per_module_data_dirs, hmodule);</span>
1872 
<span class="line-modified">1873           if (retval != NULL)</span>
<span class="line-modified">1874         {</span>
<span class="line-modified">1875           G_UNLOCK (g_utils_global);</span>
<span class="line-modified">1876           return (const gchar * const *) retval;</span>
<span class="line-removed">1877         }</span>
<span class="line-removed">1878         }</span>
1879     }


1880     }
1881 
1882   data_dirs = g_array_new (TRUE, TRUE, sizeof (char *));
1883 
1884   /* Documents and Settings\All Users\Application Data */
1885   p = get_special_folder (CSIDL_COMMON_APPDATA);
1886   if (p)
1887     g_array_append_val (data_dirs, p);
1888 
1889   /* Documents and Settings\All Users\Documents */
1890   p = get_special_folder (CSIDL_COMMON_DOCUMENTS);
1891   if (p)
1892     g_array_append_val (data_dirs, p);
1893 
1894   /* Using the above subfolders of Documents and Settings perhaps
1895    * makes sense from a Windows perspective.
1896    *
1897    * But looking at the actual use cases of this function in GTK+
1898    * and GNOME software, what we really want is the &quot;share&quot;
1899    * subdirectory of the installation directory for the package
</pre>
<hr />
<pre>
1905    *
1906    * Additionally, also use the &quot;share&quot; subfolder of the installation
1907    * locations of GLib and the .exe file being run.
1908    *
1909    * To guard against none of the above being what is really wanted,
1910    * callers of this function should have Win32-specific code to look
1911    * up their installation folder themselves, and handle a subfolder
1912    * &quot;share&quot; of it in the same way as the folders returned from this
1913    * function.
1914    */
1915 
1916   p = get_module_share_dir (address_of_function);
1917   if (p)
1918     g_array_append_val (data_dirs, p);
1919 
1920   if (glib_dll != NULL)
1921     {
1922       gchar *glib_root = g_win32_get_package_installation_directory_of_module (glib_dll);
1923       p = g_build_filename (glib_root, &quot;share&quot;, NULL);
1924       if (p)
<span class="line-modified">1925     g_array_append_val (data_dirs, p);</span>
1926       g_free (glib_root);
1927     }
1928 
1929   exe_root = g_win32_get_package_installation_directory_of_module (NULL);
1930   p = g_build_filename (exe_root, &quot;share&quot;, NULL);
1931   if (p)
1932     g_array_append_val (data_dirs, p);
1933   g_free (exe_root);
1934 
1935   retval = (gchar **) g_array_free (data_dirs, FALSE);
1936 
1937   if (address_of_function)
1938     {
1939       if (hmodule != NULL)
<span class="line-modified">1940     g_hash_table_insert (per_module_data_dirs, hmodule, retval);</span>
1941       G_UNLOCK (g_utils_global);
1942     }
1943 
1944   return (const gchar * const *) retval;
1945 }
1946 
1947 const gchar * const *
1948 g_win32_get_system_data_dirs_for_module (void (*address_of_function)(void))
1949 {
1950   gboolean should_call_g_get_system_data_dirs;
1951 
1952   should_call_g_get_system_data_dirs = TRUE;
<span class="line-modified">1953   /* These checks are the same as the ones that g_get_system_data_dirs() does.</span>
1954    * Please keep them in sync.
1955    */
1956   G_LOCK (g_utils_global);
1957 
1958   if (!g_system_data_dirs)
1959     {
1960       const gchar *data_dirs = g_getenv (&quot;XDG_DATA_DIRS&quot;);
1961 
1962       if (!data_dirs || !data_dirs[0])
1963         should_call_g_get_system_data_dirs = FALSE;
1964     }
1965 
1966   G_UNLOCK (g_utils_global);
1967 
1968   /* There is a subtle difference between g_win32_get_system_data_dirs_for_module (NULL),
1969    * which is what GLib code can normally call,
1970    * and g_win32_get_system_data_dirs_for_module (&amp;_g_win32_get_system_data_dirs),
1971    * which is what the inline function used by non-GLib code calls.
1972    * The former gets prefix relative to currently-running executable,
1973    * the latter - relative to the module that calls _g_win32_get_system_data_dirs()
</pre>
<hr />
<pre>
1977    * call g_get_system_data_dirs() from there - because we need to get the address
1978    * local to the non-GLib caller-module.
1979    */
1980 
1981   /*
1982    * g_get_system_data_dirs() will fall back to calling
1983    * g_win32_get_system_data_dirs_for_module_real(NULL) if XDG_DATA_DIRS is NULL
1984    * or an empty string. The checks above ensure that we do not call it in such
1985    * cases and use the address_of_function that we&#39;ve been given by the inline function.
1986    * The reason we&#39;re calling g_get_system_data_dirs /at all/ is to give
1987    * XDG_DATA_DIRS precedence (if it is set).
1988    */
1989   if (should_call_g_get_system_data_dirs)
1990     return g_get_system_data_dirs ();
1991 
1992   return g_win32_get_system_data_dirs_for_module_real (address_of_function);
1993 }
1994 
1995 #endif
1996 
























1997 /**
1998  * g_get_system_data_dirs:
1999  *
2000  * Returns an ordered list of base directories in which to access
2001  * system-wide application data.
2002  *
2003  * On UNIX platforms this is determined using the mechanisms described
2004  * in the
2005  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec)
2006  * In this case the list of directories retrieved will be `XDG_DATA_DIRS`.
2007  *
2008  * On Windows it follows XDG Base Directory Specification if `XDG_DATA_DIRS` is defined.
2009  * If `XDG_DATA_DIRS` is undefined,
2010  * the first elements in the list are the Application Data
2011  * and Documents folders for All Users. (These can be determined only
2012  * on Windows 2000 or later and are not present in the list on other
2013  * Windows versions.) See documentation for CSIDL_COMMON_APPDATA and
2014  * CSIDL_COMMON_DOCUMENTS.
2015  *
2016  * Then follows the &quot;share&quot; subfolder in the installation folder for
</pre>
<hr />
<pre>
2021  * folder for GLib, and in the installation folder for the package the
2022  * application&#39;s .exe file belongs to.
2023  *
2024  * The installation folders above are determined by looking up the
2025  * folder where the module (DLL or EXE) in question is located. If the
2026  * folder&#39;s name is &quot;bin&quot;, its parent is used, otherwise the folder
2027  * itself.
2028  *
2029  * Note that on Windows the returned list can vary depending on where
2030  * this function is called.
2031  *
2032  * Returns: (array zero-terminated=1) (element-type filename) (transfer none):
2033  *     a %NULL-terminated array of strings owned by GLib that must not be
2034  *     modified or freed.
2035  *
2036  * Since: 2.6
2037  **/
2038 const gchar * const *
2039 g_get_system_data_dirs (void)
2040 {
<span class="line-modified">2041   gchar **data_dir_vector;</span>
2042 
<span class="line-removed">2043   /* These checks are the same as the ones that g_win32_get_system_data_dirs_for_module()</span>
<span class="line-removed">2044    * does. Please keep them in sync.</span>
<span class="line-removed">2045    */</span>
2046   G_LOCK (g_utils_global);
2047 
<span class="line-modified">2048   if (!g_system_data_dirs)</span>
<span class="line-modified">2049     {</span>
<span class="line-modified">2050       gchar *data_dirs = (gchar *) g_getenv (&quot;XDG_DATA_DIRS&quot;);</span>
2051 
<span class="line-modified">2052 #ifndef G_OS_WIN32</span>
<span class="line-removed">2053       if (!data_dirs || !data_dirs[0])</span>
<span class="line-removed">2054           data_dirs = &quot;/usr/local/share/:/usr/share/&quot;;</span>
2055 
<span class="line-modified">2056       data_dir_vector = g_strsplit (data_dirs, G_SEARCHPATH_SEPARATOR_S, 0);</span>
<span class="line-modified">2057 #else</span>
<span class="line-removed">2058       if (!data_dirs || !data_dirs[0])</span>
<span class="line-removed">2059         data_dir_vector = g_strdupv ((gchar **) g_win32_get_system_data_dirs_for_module_real (NULL));</span>
<span class="line-removed">2060       else</span>
<span class="line-removed">2061         data_dir_vector = g_strsplit (data_dirs, G_SEARCHPATH_SEPARATOR_S, 0);</span>
<span class="line-removed">2062 #endif</span>
2063 
<span class="line-modified">2064       g_system_data_dirs = data_dir_vector;</span>








2065     }
2066   else
<span class="line-modified">2067     data_dir_vector = g_system_data_dirs;</span>

2068 
<span class="line-modified">2069   G_UNLOCK (g_utils_global);</span>




2070 
<span class="line-modified">2071   return (const gchar * const *) data_dir_vector;</span>









2072 }
2073 
2074 /**
2075  * g_get_system_config_dirs:
2076  *
2077  * Returns an ordered list of base directories in which to access
2078  * system-wide configuration information.
2079  *
2080  * On UNIX platforms this is determined using the mechanisms described
2081  * in the
2082  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
2083  * In this case the list of directories retrieved will be `XDG_CONFIG_DIRS`.
2084  *
2085  * On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_DIRS` is defined.
2086  * If `XDG_CONFIG_DIRS` is undefined, the directory that contains application
2087  * data for all users is used instead. A typical path is
2088  * `C:\Documents and Settings\All Users\Application Data`.
2089  * This folder is used for application data
2090  * that is not user specific. For example, an application can store
2091  * a spell-check dictionary, a database of clip art, or a log file in the
2092  * CSIDL_COMMON_APPDATA folder. This information will not roam and is available
2093  * to anyone using the computer.
2094  *
2095  * Returns: (array zero-terminated=1) (element-type filename) (transfer none):
2096  *     a %NULL-terminated array of strings owned by GLib that must not be
2097  *     modified or freed.
2098  *
2099  * Since: 2.6
2100  **/
2101 const gchar * const *
2102 g_get_system_config_dirs (void)
2103 {
<span class="line-modified">2104   gchar **conf_dir_vector;</span>
2105 
2106   G_LOCK (g_utils_global);
2107 
<span class="line-modified">2108   if (!g_system_config_dirs)</span>
<span class="line-modified">2109     {</span>
<span class="line-modified">2110       const gchar *conf_dirs = g_getenv (&quot;XDG_CONFIG_DIRS&quot;);</span>
<span class="line-removed">2111 #ifdef G_OS_WIN32</span>
<span class="line-removed">2112       if (conf_dirs)</span>
<span class="line-removed">2113     {</span>
<span class="line-removed">2114       conf_dir_vector = g_strsplit (conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);</span>
<span class="line-removed">2115     }</span>
<span class="line-removed">2116       else</span>
<span class="line-removed">2117     {</span>
<span class="line-removed">2118       gchar *special_conf_dirs = get_special_folder (CSIDL_COMMON_APPDATA);</span>
<span class="line-removed">2119 </span>
<span class="line-removed">2120       if (special_conf_dirs)</span>
<span class="line-removed">2121         conf_dir_vector = g_strsplit (special_conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);</span>
<span class="line-removed">2122       else</span>
<span class="line-removed">2123       /* Return empty list */</span>
<span class="line-removed">2124       conf_dir_vector = g_strsplit (&quot;&quot;, G_SEARCHPATH_SEPARATOR_S, 0);</span>
2125 
<span class="line-removed">2126       g_free (special_conf_dirs);</span>
<span class="line-removed">2127     }</span>
<span class="line-removed">2128 #else</span>
<span class="line-removed">2129       if (!conf_dirs || !conf_dirs[0])</span>
<span class="line-removed">2130           conf_dirs = &quot;/etc/xdg&quot;;</span>
<span class="line-removed">2131 </span>
<span class="line-removed">2132       conf_dir_vector = g_strsplit (conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);</span>
<span class="line-removed">2133 #endif</span>
<span class="line-removed">2134 </span>
<span class="line-removed">2135       g_system_config_dirs = conf_dir_vector;</span>
<span class="line-removed">2136     }</span>
<span class="line-removed">2137   else</span>
<span class="line-removed">2138     conf_dir_vector = g_system_config_dirs;</span>
2139   G_UNLOCK (g_utils_global);
2140 
<span class="line-modified">2141   return (const gchar * const *) conf_dir_vector;</span>
2142 }
2143 
2144 /**
2145  * g_nullify_pointer:
2146  * @nullify_location: (not nullable): the memory address of the pointer.
2147  *
2148  * Set the pointer at the specified location to %NULL.
2149  **/
2150 void
2151 g_nullify_pointer (gpointer *nullify_location)
2152 {
2153   g_return_if_fail (nullify_location != NULL);
2154 
2155   *nullify_location = NULL;
2156 }
2157 
2158 #define KILOBYTE_FACTOR (G_GOFFSET_CONSTANT (1000))
2159 #define MEGABYTE_FACTOR (KILOBYTE_FACTOR * KILOBYTE_FACTOR)
2160 #define GIGABYTE_FACTOR (MEGABYTE_FACTOR * KILOBYTE_FACTOR)
2161 #define TERABYTE_FACTOR (GIGABYTE_FACTOR * KILOBYTE_FACTOR)
2162 #define PETABYTE_FACTOR (TERABYTE_FACTOR * KILOBYTE_FACTOR)
2163 #define EXABYTE_FACTOR  (PETABYTE_FACTOR * KILOBYTE_FACTOR)
2164 
2165 #define KIBIBYTE_FACTOR (G_GOFFSET_CONSTANT (1024))
2166 #define MEBIBYTE_FACTOR (KIBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2167 #define GIBIBYTE_FACTOR (MEBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2168 #define TEBIBYTE_FACTOR (GIBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2169 #define PEBIBYTE_FACTOR (TEBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2170 #define EXBIBYTE_FACTOR (PEBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2171 
2172 /**
2173  * g_format_size:
2174  * @size: a size in bytes
2175  *
2176  * Formats a size (for example the size of a file) into a human readable
2177  * string.  Sizes are rounded to the nearest size prefix (kB, MB, GB)
2178  * and are displayed rounded to the nearest tenth. E.g. the file size
<span class="line-modified">2179  * 3292528 bytes will be converted into the string &quot;3.2 MB&quot;.</span>


2180  *
2181  * The prefix units base is 1000 (i.e. 1 kB is 1000 bytes).
2182  *
2183  * This string should be freed with g_free() when not needed any longer.
2184  *
2185  * See g_format_size_full() for more options about how the size might be
2186  * formatted.
2187  *
2188  * Returns: a newly-allocated formatted string containing a human readable
2189  *     file size
2190  *
2191  * Since: 2.30
2192  */
2193 gchar *
2194 g_format_size (guint64 size)
2195 {
2196   return g_format_size_full (size, G_FORMAT_SIZE_DEFAULT);
2197 }
2198 
2199 /**
</pre>
<hr />
<pre>
2226  * @size: a size in bytes
2227  * @flags: #GFormatSizeFlags to modify the output
2228  *
2229  * Formats a size.
2230  *
2231  * This function is similar to g_format_size() but allows for flags
2232  * that modify the output. See #GFormatSizeFlags.
2233  *
2234  * Returns: a newly-allocated formatted string containing a human
2235  *     readable file size
2236  *
2237  * Since: 2.30
2238  */
2239 gchar *
2240 g_format_size_full (guint64          size,
2241                     GFormatSizeFlags flags)
2242 {
2243   struct Format
2244   {
2245     guint64 factor;
<span class="line-modified">2246     char string[9];</span>
2247   };
2248 
2249   typedef enum
2250   {
2251     FORMAT_BYTES,
2252     FORMAT_BYTES_IEC,
2253     FORMAT_BITS,
2254     FORMAT_BITS_IEC
2255   } FormatIndex;
2256 
2257   const struct Format formats[4][6] = {
2258     {

2259       { KILOBYTE_FACTOR, N_(&quot;%.1f kB&quot;) },

2260       { MEGABYTE_FACTOR, N_(&quot;%.1f MB&quot;) },

2261       { GIGABYTE_FACTOR, N_(&quot;%.1f GB&quot;) },

2262       { TERABYTE_FACTOR, N_(&quot;%.1f TB&quot;) },

2263       { PETABYTE_FACTOR, N_(&quot;%.1f PB&quot;) },

2264       { EXABYTE_FACTOR,  N_(&quot;%.1f EB&quot;) }
2265     },
<span class="line-modified">2266         {</span>

2267       { KIBIBYTE_FACTOR, N_(&quot;%.1f KiB&quot;) },

2268       { MEBIBYTE_FACTOR, N_(&quot;%.1f MiB&quot;) },

2269       { GIBIBYTE_FACTOR, N_(&quot;%.1f GiB&quot;) },

2270       { TEBIBYTE_FACTOR, N_(&quot;%.1f TiB&quot;) },

2271       { PEBIBYTE_FACTOR, N_(&quot;%.1f PiB&quot;) },

2272       { EXBIBYTE_FACTOR, N_(&quot;%.1f EiB&quot;) }
2273     },
2274     {

2275       { KILOBYTE_FACTOR, N_(&quot;%.1f kb&quot;) },

2276       { MEGABYTE_FACTOR, N_(&quot;%.1f Mb&quot;) },

2277       { GIGABYTE_FACTOR, N_(&quot;%.1f Gb&quot;) },

2278       { TERABYTE_FACTOR, N_(&quot;%.1f Tb&quot;) },

2279       { PETABYTE_FACTOR, N_(&quot;%.1f Pb&quot;) },

2280       { EXABYTE_FACTOR,  N_(&quot;%.1f Eb&quot;) }
2281     },
2282     {

2283       { KIBIBYTE_FACTOR, N_(&quot;%.1f Kib&quot;) },

2284       { MEBIBYTE_FACTOR, N_(&quot;%.1f Mib&quot;) },

2285       { GIBIBYTE_FACTOR, N_(&quot;%.1f Gib&quot;) },

2286       { TEBIBYTE_FACTOR, N_(&quot;%.1f Tib&quot;) },

2287       { PEBIBYTE_FACTOR, N_(&quot;%.1f Pib&quot;) },

2288       { EXBIBYTE_FACTOR, N_(&quot;%.1f Eib&quot;) }
<span class="line-modified">2289         }</span>
2290   };
2291 
2292   GString *string;
2293   FormatIndex index;
2294 
2295   string = g_string_new (NULL);
2296 
2297   switch (flags &amp; ~G_FORMAT_SIZE_LONG_FORMAT)
2298     {
2299     case G_FORMAT_SIZE_DEFAULT:
2300       index = FORMAT_BYTES;
2301       break;
2302     case (G_FORMAT_SIZE_DEFAULT | G_FORMAT_SIZE_IEC_UNITS):
2303       index = FORMAT_BYTES_IEC;
2304       break;
2305     case G_FORMAT_SIZE_BITS:
2306       index = FORMAT_BITS;
2307       break;
2308     case (G_FORMAT_SIZE_BITS | G_FORMAT_SIZE_IEC_UNITS):
2309       index = FORMAT_BITS_IEC;
2310       break;
2311     default:
2312       g_assert_not_reached ();
2313     }
2314 
2315 
2316   if (size &lt; formats[index][0].factor)
2317     {
2318       const char * format;
2319 
2320       if (index == FORMAT_BYTES || index == FORMAT_BYTES_IEC)
2321         {
2322           format = g_dngettext (GETTEXT_PACKAGE, &quot;%u byte&quot;, &quot;%u bytes&quot;, (guint) size);
<span class="line-modified">2323     }</span>
<span class="line-modified">2324   else</span>
<span class="line-modified">2325     {</span>
2326           format = g_dngettext (GETTEXT_PACKAGE, &quot;%u bit&quot;, &quot;%u bits&quot;, (guint) size);
2327         }
2328 
2329       g_string_printf (string, format, (guint) size);
2330 
2331       flags &amp;= ~G_FORMAT_SIZE_LONG_FORMAT;
2332     }
2333   else
2334     {
2335       const gsize n = G_N_ELEMENTS (formats[index]);
2336       gsize i;
2337 
2338       /*
2339        * Point the last format (the highest unit) by default
2340        * and then then scan all formats, starting with the 2nd one
2341        * because the 1st is already managed by with the plural form
2342        */
2343       const struct Format * f = &amp;formats[index][n - 1];
2344 
2345       for (i = 1; i &lt; n; i++)
</pre>
<hr />
<pre>
2372        * If the number is below that, then fine.  If it is above it,
2373        * then we take the modulus of the number by one thousand (in
2374        * order to keep the lowest digits) and add one thousand to that
2375        * (in order to ensure that 1001 is not treated the same as 1).
2376        */
2377       guint plural_form = size &lt; 1000 ? size : size % 1000 + 1000;
2378 
2379       /* Second problem: we need to translate the string &quot;%u byte/bit&quot; and
2380        * &quot;%u bytes/bits&quot; for pluralisation, but the correct number format to
2381        * use for a gsize is different depending on which architecture
2382        * we&#39;re on.
2383        *
2384        * Solution: format the number separately and use &quot;%s bytes/bits&quot; on
2385        * all platforms.
2386        */
2387       const gchar *translated_format;
2388       gchar *formatted_number;
2389 
2390       if (index == FORMAT_BYTES || index == FORMAT_BYTES_IEC)
2391         {
<span class="line-modified">2392       /* Translators: the %s in &quot;%s bytes&quot; will always be replaced by a number. */</span>
2393           translated_format = g_dngettext (GETTEXT_PACKAGE, &quot;%s byte&quot;, &quot;%s bytes&quot;, plural_form);
2394         }
2395       else
2396         {
2397           /* Translators: the %s in &quot;%s bits&quot; will always be replaced by a number. */
2398           translated_format = g_dngettext (GETTEXT_PACKAGE, &quot;%s bit&quot;, &quot;%s bits&quot;, plural_form);
2399         }
<span class="line-removed">2400       /* XXX: Windows doesn&#39;t support the &quot;&#39;&quot; format modifier, so we</span>
<span class="line-removed">2401        * must not use it there.  Instead, just display the number</span>
<span class="line-removed">2402        * without separation.  Bug #655336 is open until a solution is</span>
<span class="line-removed">2403        * found.</span>
<span class="line-removed">2404        */</span>
<span class="line-removed">2405 #ifndef G_OS_WIN32</span>
2406       formatted_number = g_strdup_printf (&quot;%&#39;&quot;G_GUINT64_FORMAT, size);
<span class="line-removed">2407 #else</span>
<span class="line-removed">2408       formatted_number = g_strdup_printf (&quot;%&quot;G_GUINT64_FORMAT, size);</span>
<span class="line-removed">2409 #endif</span>
2410 
2411       g_string_append (string, &quot; (&quot;);
2412       g_string_append_printf (string, translated_format, formatted_number);
2413       g_free (formatted_number);
2414       g_string_append (string, &quot;)&quot;);
2415     }
2416 
2417   return g_string_free (string, FALSE);
2418 }
2419 
2420 #ifdef GSTREAMER_LITE
2421 #ifndef G_OS_WIN32
2422 #pragma GCC diagnostic pop
2423 #endif // G_OS_WIN32
2424 #else // GSTREAMER_LITE
2425 #pragma GCC diagnostic pop
2426 #endif // GSTREAMER_LITE
2427 
2428 /**
2429  * g_format_size_for_display:
</pre>
<hr />
<pre>
2507 gchar *
2508 g_find_program_in_path_utf8 (const gchar *program)
2509 {
2510   return g_find_program_in_path (program);
2511 }
2512 
2513 const gchar *g_get_user_name_utf8 (void) { return g_get_user_name (); }
2514 const gchar *g_get_real_name_utf8 (void) { return g_get_real_name (); }
2515 const gchar *g_get_home_dir_utf8 (void) { return g_get_home_dir (); }
2516 const gchar *g_get_tmp_dir_utf8 (void) { return g_get_tmp_dir (); }
2517 
2518 #endif
2519 
2520 /* Private API:
2521  *
2522  * Returns %TRUE if the current process was executed as setuid
2523  */
2524 gboolean
2525 g_check_setuid (void)
2526 {
<span class="line-modified">2527 #if defined(HAVE_SYS_AUXV_H)</span>
2528   unsigned long value;
2529   int errsv;
2530 
2531   errno = 0;
2532   value = getauxval (AT_SECURE);
2533   errsv = errno;
2534   if (errsv)
2535     g_error (&quot;getauxval () failed: %s&quot;, g_strerror (errsv));
2536   return value;
2537 #elif defined(HAVE_ISSETUGID) &amp;&amp; !defined(__BIONIC__)
2538   /* BSD: http://www.freebsd.org/cgi/man.cgi?query=issetugid&amp;sektion=2 */
2539 
2540   /* Android had it in older versions but the new 64 bit ABI does not
2541    * have it anymore, and some versions of the 32 bit ABI neither.
2542    * https://code.google.com/p/android-developer-preview/issues/detail?id=168
2543    */
2544   return issetugid ();
2545 #elif defined(G_OS_UNIX)
2546   uid_t ruid, euid, suid; /* Real, effective and saved user ID&#39;s */
2547   gid_t rgid, egid, sgid; /* Real, effective and saved group ID&#39;s */
</pre>
</td>
<td>
<hr />
<pre>
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe for the unix part, FIXME: make the win32 part MT safe as well.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #include &quot;gutils.h&quot;
<span class="line-added">  32 #include &quot;gutilsprivate.h&quot;</span>
  33 
  34 #include &lt;stdarg.h&gt;
  35 #include &lt;stdlib.h&gt;
  36 #include &lt;stdio.h&gt;
  37 #include &lt;locale.h&gt;
  38 #include &lt;string.h&gt;
<span class="line-modified">  39 #include &lt;ctype.h&gt;    /* For tolower() */</span>
  40 #include &lt;errno.h&gt;
  41 #include &lt;sys/types.h&gt;
  42 #include &lt;sys/stat.h&gt;
  43 #ifdef G_OS_UNIX
  44 #include &lt;pwd.h&gt;
  45 #include &lt;unistd.h&gt;
  46 #endif
  47 #include &lt;sys/types.h&gt;
  48 #ifdef HAVE_SYS_PARAM_H
  49 #include &lt;sys/param.h&gt;
  50 #endif
  51 #ifdef HAVE_CRT_EXTERNS_H
  52 #include &lt;crt_externs.h&gt; /* for _NSGetEnviron */
  53 #endif
  54 #ifdef HAVE_SYS_AUXV_H
  55 #include &lt;sys/auxv.h&gt;
  56 #endif
  57 
  58 #include &quot;glib-init.h&quot;
  59 #include &quot;glib-private.h&quot;
</pre>
<hr />
<pre>
  72 #ifdef G_PLATFORM_WIN32
  73 #include &quot;gconvert.h&quot;
  74 #include &quot;gwin32.h&quot;
  75 #endif
  76 
  77 
  78 /**
  79  * SECTION:misc_utils
  80  * @title: Miscellaneous Utility Functions
  81  * @short_description: a selection of portable utility functions
  82  *
  83  * These are portable utility functions.
  84  */
  85 
  86 #ifdef G_PLATFORM_WIN32
  87 #  include &lt;windows.h&gt;
  88 #  ifndef GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
  89 #    define GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT 2
  90 #    define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS 4
  91 #  endif
<span class="line-modified">  92 #  include &lt;lmcons.h&gt;   /* For UNLEN */</span>
  93 #endif /* G_PLATFORM_WIN32 */
  94 
  95 #ifdef G_OS_WIN32
  96 #  include &lt;direct.h&gt;
  97 #  include &lt;shlobj.h&gt;






















  98 #  include &lt;process.h&gt;
  99 #endif
 100 




 101 #ifdef HAVE_CODESET
 102 #include &lt;langinfo.h&gt;
 103 #endif
 104 
 105 #ifdef G_PLATFORM_WIN32
 106 
 107 gchar *
 108 _glib_get_dll_directory (void)
 109 {
 110   gchar *retval;
 111   gchar *p;
 112   wchar_t wc_fn[MAX_PATH];
 113 
 114 #ifdef DLL_EXPORT
 115   if (glib_dll == NULL)
 116     return NULL;
 117 #endif
 118 
 119   /* This code is different from that in
 120    * g_win32_get_package_installation_directory_of_module() in that
</pre>
<hr />
<pre>
 181  *
 182  * On POSIX systems, calling g_atexit() (or atexit()) in a dynamically
 183  * loaded module which is unloaded before the program terminates might
 184  * well cause a crash at program exit.
 185  *
 186  * Some POSIX systems implement atexit() like Windows, and have each
 187  * dynamically loaded module maintain an own atexit chain that is
 188  * called when the module is unloaded.
 189  *
 190  * On other POSIX systems, before a dynamically loaded module is
 191  * unloaded, the registered atexit functions (if any) residing in that
 192  * module are called, regardless where the code that registered them
 193  * resided. This is presumably the most robust approach.
 194  *
 195  * As can be seen from the above, for portability it&#39;s best to avoid
 196  * calling g_atexit() (or atexit()) except in the main executable of a
 197  * program.
 198  *
 199  * Deprecated:2.32: It is best to avoid g_atexit().
 200  */
<span class="line-added"> 201 G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
 202 void
 203 g_atexit (GVoidFunc func)
 204 {
 205   gint result;
 206   int errsv;
 207 
 208   result = atexit ((void (*)(void)) func);
 209   errsv = errno;
 210   if (result)
 211     {
 212       g_error (&quot;Could not register atexit() function: %s&quot;,
 213                g_strerror (errsv));
 214     }
 215 }
<span class="line-added"> 216 G_GNUC_END_IGNORE_DEPRECATIONS</span>
 217 
 218 #endif // GSTREAMER_LITE
 219 
 220 /* Based on execvp() from GNU Libc.
 221  * Some of this code is cut-and-pasted into gspawn.c
 222  */
 223 
 224 static gchar*
 225 my_strchrnul (const gchar *str,
<span class="line-modified"> 226         gchar        c)</span>
 227 {
 228   gchar *p = (gchar*)str;
 229   while (*p &amp;&amp; (*p != c))
 230     ++p;
 231 
 232   return p;
 233 }
 234 
 235 #ifdef G_OS_WIN32
 236 
 237 static gchar *inner_find_program_in_path (const gchar *program);
 238 
 239 gchar*
 240 g_find_program_in_path (const gchar *program)
 241 {
 242   const gchar *last_dot = strrchr (program, &#39;.&#39;);
 243 
 244   if (last_dot == NULL ||
 245       strchr (last_dot, &#39;\\&#39;) != NULL ||
 246       strchr (last_dot, &#39;/&#39;) != NULL)
 247     {
 248       const gint program_length = strlen (program);
 249       gchar *pathext = g_build_path (&quot;;&quot;,
<span class="line-modified"> 250              &quot;.exe;.cmd;.bat;.com&quot;,</span>
<span class="line-modified"> 251              g_getenv (&quot;PATHEXT&quot;),</span>
<span class="line-modified"> 252              NULL);</span>
 253       gchar *p;
 254       gchar *decorated_program;
 255       gchar *retval;
 256 
 257       p = pathext;
 258       do
<span class="line-modified"> 259   {</span>
<span class="line-modified"> 260     gchar *q = my_strchrnul (p, &#39;;&#39;);</span>
 261 
<span class="line-modified"> 262     decorated_program = g_malloc (program_length + (q-p) + 1);</span>
<span class="line-modified"> 263     memcpy (decorated_program, program, program_length);</span>
<span class="line-modified"> 264     memcpy (decorated_program+program_length, p, q-p);</span>
<span class="line-modified"> 265     decorated_program [program_length + (q-p)] = &#39;\0&#39;;</span>
 266 
<span class="line-modified"> 267     retval = inner_find_program_in_path (decorated_program);</span>
<span class="line-modified"> 268     g_free (decorated_program);</span>
 269 
<span class="line-modified"> 270     if (retval != NULL)</span>
<span class="line-modified"> 271       {</span>
<span class="line-modified"> 272         g_free (pathext);</span>
<span class="line-modified"> 273         return retval;</span>
<span class="line-modified"> 274       }</span>
<span class="line-modified"> 275     p = q;</span>
<span class="line-modified"> 276   } while (*p++ != &#39;\0&#39;);</span>
 277       g_free (pathext);
 278       return NULL;
 279     }
 280   else
 281     return inner_find_program_in_path (program);
 282 }
 283 
 284 #endif
 285 
 286 /**
 287  * g_find_program_in_path:
 288  * @program: (type filename): a program name in the GLib file name encoding
 289  *
 290  * Locates the first executable named @program in the user&#39;s path, in the
 291  * same way that execvp() would locate it. Returns an allocated string
 292  * with the absolute path name, or %NULL if the program is not found in
 293  * the path. If @program is already an absolute path, returns a copy of
 294  * @program if @program exists and is executable, and %NULL otherwise.
 295  *
 296  * On Windows, if @program does not have a file type suffix, tries
</pre>
<hr />
<pre>
 325   int n;
 326   wchar_t wfilename[MAXPATHLEN], wsysdir[MAXPATHLEN],
 327     wwindir[MAXPATHLEN];
 328 #endif
 329   gsize len;
 330   gsize pathlen;
 331 
 332   g_return_val_if_fail (program != NULL, NULL);
 333 
 334   /* If it is an absolute path, or a relative path including subdirectories,
 335    * don&#39;t look in PATH.
 336    */
 337   if (g_path_is_absolute (program)
 338       || strchr (program, G_DIR_SEPARATOR) != NULL
 339 #ifdef G_OS_WIN32
 340       || strchr (program, &#39;/&#39;) != NULL
 341 #endif
 342       )
 343     {
 344       if (g_file_test (program, G_FILE_TEST_IS_EXECUTABLE) &amp;&amp;
<span class="line-modified"> 345     !g_file_test (program, G_FILE_TEST_IS_DIR))</span>
 346         return g_strdup (program);
 347       else
 348         return NULL;
 349     }
 350 
 351   path = g_getenv (&quot;PATH&quot;);
 352 #if defined(G_OS_UNIX)
 353   if (path == NULL)
 354     {
 355       /* There is no &#39;PATH&#39; in the environment.  The default
 356        * search path in GNU libc is the current directory followed by
 357        * the path &#39;confstr&#39; returns for &#39;_CS_PATH&#39;.
 358        */
 359 
 360       /* In GLib we put . last, for security, and don&#39;t use the
 361        * unportable confstr(); UNIX98 does not actually specify
 362        * what to search if PATH is unset. POSIX may, dunno.
 363        */
 364 
 365       path = &quot;/bin:/usr/bin:.&quot;;
</pre>
<hr />
<pre>
 432   /* And add the slash before the filename  */
 433   *name = G_DIR_SEPARATOR;
 434 
 435   p = path;
 436   do
 437     {
 438       char *startp;
 439 
 440       path = p;
 441       p = my_strchrnul (path, G_SEARCHPATH_SEPARATOR);
 442 
 443       if (p == path)
 444         /* Two adjacent colons, or a colon at the beginning or the end
 445          * of &#39;PATH&#39; means to search the current directory.
 446          */
 447         startp = name + 1;
 448       else
 449         startp = memcpy (name - (p - path), path, p - path);
 450 
 451       if (g_file_test (startp, G_FILE_TEST_IS_EXECUTABLE) &amp;&amp;
<span class="line-modified"> 452     !g_file_test (startp, G_FILE_TEST_IS_DIR))</span>
 453         {
 454           gchar *ret;
 455           ret = g_strdup (startp);
 456           g_free (freeme);
 457 #ifdef G_OS_WIN32
<span class="line-modified"> 458     g_free ((gchar *) path_copy);</span>
 459 #endif
 460           return ret;
 461         }
 462     }
 463   while (*p++ != &#39;\0&#39;);
 464 
 465   g_free (freeme);
 466 #ifdef G_OS_WIN32
 467   g_free ((gchar *) path_copy);
 468 #endif
 469 
 470   return NULL;
 471 }
 472 
 473 /* The functions below are defined this way for compatibility reasons.
 474  * See the note in gutils.h.
 475  */
 476 
 477 /**
 478  * g_bit_nth_lsf:
</pre>
<hr />
<pre>
 523  * Gets the number of bits used to hold @number,
 524  * e.g. if @number is 4, 3 bits are needed.
 525  *
 526  * Returns: the number of bits used to hold @number
 527  */
 528 guint
 529 (g_bit_storage) (gulong number)
 530 {
 531   return g_bit_storage_impl (number);
 532 }
 533 
 534 G_LOCK_DEFINE_STATIC (g_utils_global);
 535 
 536 typedef struct
 537 {
 538   gchar *user_name;
 539   gchar *real_name;
 540   gchar *home_dir;
 541 } UserDatabaseEntry;
 542 
<span class="line-added"> 543 /* These must all be read/written with @g_utils_global held. */</span>
 544 static  gchar   *g_user_data_dir = NULL;
 545 static  gchar  **g_system_data_dirs = NULL;
 546 static  gchar   *g_user_cache_dir = NULL;
 547 static  gchar   *g_user_config_dir = NULL;
<span class="line-added"> 548 static  gchar   *g_user_runtime_dir = NULL;</span>
 549 static  gchar  **g_system_config_dirs = NULL;

 550 static  gchar  **g_user_special_dirs = NULL;
 551 
 552 /* fifteen minutes of fame for everybody */
 553 #define G_USER_DIRS_EXPIRE      15 * 60
 554 
 555 #ifdef G_OS_WIN32
 556 
 557 static gchar *
 558 get_special_folder (int csidl)
 559 {
 560   wchar_t path[MAX_PATH+1];
 561   HRESULT hr;
 562   LPITEMIDLIST pidl = NULL;
 563   BOOL b;
 564   gchar *retval = NULL;
 565 
 566   hr = SHGetSpecialFolderLocation (NULL, csidl, &amp;pidl);
 567   if (hr == S_OK)
 568     {
 569       b = SHGetPathFromIDListW (pidl, path);
 570       if (b)
<span class="line-modified"> 571   retval = g_utf16_to_utf8 (path, -1, NULL, NULL, NULL);</span>
 572       CoTaskMemFree (pidl);
 573     }
 574   return retval;
 575 }
 576 
 577 static char *
 578 get_windows_directory_root (void)
 579 {
 580   wchar_t wwindowsdir[MAX_PATH];
 581 
 582   if (GetWindowsDirectoryW (wwindowsdir, G_N_ELEMENTS (wwindowsdir)))
 583     {
 584       /* Usually X:\Windows, but in terminal server environments
 585        * might be an UNC path, AFAIK.
 586        */
 587       char *windowsdir = g_utf16_to_utf8 (wwindowsdir, -1, NULL, NULL, NULL);
 588       char *p;
 589 
 590       if (windowsdir == NULL)
<span class="line-modified"> 591   return g_strdup (&quot;C:\\&quot;);</span>
 592 
 593       p = (char *) g_path_skip_root (windowsdir);
 594       if (G_IS_DIR_SEPARATOR (p[-1]) &amp;&amp; p[-2] != &#39;:&#39;)
<span class="line-modified"> 595   p--;</span>
 596       *p = &#39;\0&#39;;
 597       return windowsdir;
 598     }
 599   else
 600     return g_strdup (&quot;C:\\&quot;);
 601 }
 602 
 603 #endif
 604 
 605 /* HOLDS: g_utils_global_lock */
 606 static UserDatabaseEntry *
 607 g_get_user_database_entry (void)
 608 {
 609   static UserDatabaseEntry *entry;
 610 
 611   if (g_once_init_enter (&amp;entry))
 612     {
 613       static UserDatabaseEntry e;
 614 
 615 #ifdef G_OS_UNIX
</pre>
<hr />
<pre>
 759  * g_get_real_name:
 760  *
 761  * Gets the real name of the user. This usually comes from the user&#39;s
 762  * entry in the `passwd` file. The encoding of the returned string is
 763  * system-defined. (On Windows, it is, however, always UTF-8.) If the
 764  * real user name cannot be determined, the string &quot;Unknown&quot; is
 765  * returned.
 766  *
 767  * Returns: (type filename): the user&#39;s real name.
 768  */
 769 const gchar *
 770 g_get_real_name (void)
 771 {
 772   UserDatabaseEntry *entry;
 773 
 774   entry = g_get_user_database_entry ();
 775 
 776   return entry-&gt;real_name;
 777 }
 778 
<span class="line-added"> 779 /* Protected by @g_utils_global_lock. */</span>
<span class="line-added"> 780 static gchar *g_home_dir = NULL;  /* (owned) (nullable before initialised) */</span>
<span class="line-added"> 781 </span>
<span class="line-added"> 782 static gchar *</span>
<span class="line-added"> 783 g_build_home_dir (void)</span>
<span class="line-added"> 784 {</span>
<span class="line-added"> 785   gchar *home_dir;</span>
<span class="line-added"> 786 </span>
<span class="line-added"> 787   /* We first check HOME and use it if it is set */</span>
<span class="line-added"> 788   home_dir = g_strdup (g_getenv (&quot;HOME&quot;));</span>
<span class="line-added"> 789 </span>
<span class="line-added"> 790 #ifdef G_OS_WIN32</span>
<span class="line-added"> 791   /* Only believe HOME if it is an absolute path and exists.</span>
<span class="line-added"> 792    *</span>
<span class="line-added"> 793    * We only do this check on Windows for a couple of reasons.</span>
<span class="line-added"> 794    * Historically, we only did it there because we used to ignore $HOME</span>
<span class="line-added"> 795    * on UNIX.  There are concerns about enabling it now on UNIX because</span>
<span class="line-added"> 796    * of things like autofs.  In short, if the user has a bogus value in</span>
<span class="line-added"> 797    * $HOME then they get what they pay for...</span>
<span class="line-added"> 798    */</span>
<span class="line-added"> 799   if (home_dir != NULL)</span>
<span class="line-added"> 800     {</span>
<span class="line-added"> 801       if (!(g_path_is_absolute (home_dir) &amp;&amp;</span>
<span class="line-added"> 802             g_file_test (home_dir, G_FILE_TEST_IS_DIR)))</span>
<span class="line-added"> 803         g_clear_pointer (&amp;home_dir, g_free);</span>
<span class="line-added"> 804     }</span>
<span class="line-added"> 805 </span>
<span class="line-added"> 806   /* In case HOME is Unix-style (it happens), convert it to</span>
<span class="line-added"> 807    * Windows style.</span>
<span class="line-added"> 808    */</span>
<span class="line-added"> 809   if (home_dir != NULL)</span>
<span class="line-added"> 810     {</span>
<span class="line-added"> 811       gchar *p;</span>
<span class="line-added"> 812       while ((p = strchr (home_dir, &#39;/&#39;)) != NULL)</span>
<span class="line-added"> 813         *p = &#39;\\&#39;;</span>
<span class="line-added"> 814     }</span>
<span class="line-added"> 815 </span>
<span class="line-added"> 816   if (home_dir == NULL)</span>
<span class="line-added"> 817     {</span>
<span class="line-added"> 818       /* USERPROFILE is probably the closest equivalent to $HOME? */</span>
<span class="line-added"> 819       if (g_getenv (&quot;USERPROFILE&quot;) != NULL)</span>
<span class="line-added"> 820         home_dir = g_strdup (g_getenv (&quot;USERPROFILE&quot;));</span>
<span class="line-added"> 821     }</span>
<span class="line-added"> 822 </span>
<span class="line-added"> 823   if (home_dir == NULL)</span>
<span class="line-added"> 824     home_dir = get_special_folder (CSIDL_PROFILE);</span>
<span class="line-added"> 825 </span>
<span class="line-added"> 826   if (home_dir == NULL)</span>
<span class="line-added"> 827     home_dir = get_windows_directory_root ();</span>
<span class="line-added"> 828 #endif /* G_OS_WIN32 */</span>
<span class="line-added"> 829 </span>
<span class="line-added"> 830   if (home_dir == NULL)</span>
<span class="line-added"> 831     {</span>
<span class="line-added"> 832       /* If we didn&#39;t get it from any of those methods, we will have</span>
<span class="line-added"> 833        * to read the user database entry.</span>
<span class="line-added"> 834        */</span>
<span class="line-added"> 835       UserDatabaseEntry *entry = g_get_user_database_entry ();</span>
<span class="line-added"> 836       home_dir = g_strdup (entry-&gt;home_dir);</span>
<span class="line-added"> 837     }</span>
<span class="line-added"> 838 </span>
<span class="line-added"> 839   /* If we have been denied access to /etc/passwd (for example, by an</span>
<span class="line-added"> 840    * overly-zealous LSM), make up a junk value. The return value at this</span>
<span class="line-added"> 841    * point is explicitly documented as &#39;undefined&#39;. */</span>
<span class="line-added"> 842   if (home_dir == NULL)</span>
<span class="line-added"> 843     {</span>
<span class="line-added"> 844       g_warning (&quot;Could not find home directory: $HOME is not set, and &quot;</span>
<span class="line-added"> 845                  &quot;user database could not be read.&quot;);</span>
<span class="line-added"> 846       home_dir = g_strdup (&quot;/&quot;);</span>
<span class="line-added"> 847     }</span>
<span class="line-added"> 848 </span>
<span class="line-added"> 849   return g_steal_pointer (&amp;home_dir);</span>
<span class="line-added"> 850 }</span>
<span class="line-added"> 851 </span>
 852 /**
 853  * g_get_home_dir:
 854  *
 855  * Gets the current user&#39;s home directory.
 856  *
 857  * As with most UNIX tools, this function will return the value of the
 858  * `HOME` environment variable if it is set to an existing absolute path
 859  * name, falling back to the `passwd` file in the case that it is unset.
 860  *
 861  * If the path given in `HOME` is non-absolute, does not exist, or is
 862  * not a directory, the result is undefined.
 863  *
 864  * Before version 2.36 this function would ignore the `HOME` environment
 865  * variable, taking the value from the `passwd` database instead. This was
 866  * changed to increase the compatibility of GLib with other programs (and
 867  * the XDG basedir specification) and to increase testability of programs
 868  * based on GLib (by making it easier to run them from test frameworks).
 869  *
 870  * If your program has a strong requirement for either the new or the
 871  * old behaviour (and if you don&#39;t wish to increase your GLib
 872  * dependency to ensure that the new behaviour is in effect) then you
 873  * should either directly check the `HOME` environment variable yourself
 874  * or unset it before calling any functions in GLib.
 875  *
 876  * Returns: (type filename): the current user&#39;s home directory
 877  */
 878 const gchar *
 879 g_get_home_dir (void)
 880 {
<span class="line-modified"> 881   const gchar *home_dir;</span>




 882 
<span class="line-modified"> 883   G_LOCK (g_utils_global);</span>



























































 884 
<span class="line-modified"> 885   if (g_home_dir == NULL)</span>
<span class="line-modified"> 886     g_home_dir = g_build_home_dir ();</span>
<span class="line-modified"> 887   home_dir = g_home_dir;</span>








 888 
<span class="line-modified"> 889   G_UNLOCK (g_utils_global);</span>

 890 
 891   return home_dir;
 892 }
 893 
 894 /**
 895  * g_get_tmp_dir:
 896  *
 897  * Gets the directory to use for temporary files.
 898  *
 899  * On UNIX, this is taken from the `TMPDIR` environment variable.
 900  * If the variable is not set, `P_tmpdir` is
 901  * used, as defined by the system C library. Failing that, a
 902  * hard-coded default of &quot;/tmp&quot; is returned.
 903  *
 904  * On Windows, the `TEMP` environment variable is used, with the
 905  * root directory of the Windows installation (eg: &quot;C:\&quot;) used
 906  * as a default.
 907  *
 908  * The encoding of the returned string is system-defined. On Windows,
 909  * it is always UTF-8. The return value is never %NULL or the empty
</pre>
<hr />
<pre>
 972  * name can be determined, a default fixed string &quot;localhost&quot; is
 973  * returned.
 974  *
 975  * The encoding of the returned string is UTF-8.
 976  *
 977  * Returns: the host name of the machine.
 978  *
 979  * Since: 2.8
 980  */
 981 const gchar *
 982 g_get_host_name (void)
 983 {
 984   static gchar *hostname;
 985 
 986   if (g_once_init_enter (&amp;hostname))
 987     {
 988       gboolean failed;
 989       gchar *utmp;
 990 
 991 #ifndef G_OS_WIN32
<span class="line-modified"> 992       glong max;</span>
<span class="line-modified"> 993       gsize size;</span>
<span class="line-added"> 994       /* The number 256 * 256 is taken from the value of _POSIX_HOST_NAME_MAX,</span>
<span class="line-added"> 995        * which is 255. Since we use _POSIX_HOST_NAME_MAX + 1 (= 256) in the</span>
<span class="line-added"> 996        * fallback case, we pick 256 * 256 as the size of the larger buffer here.</span>
<span class="line-added"> 997        * It should be large enough. It doesn&#39;t looks reasonable to name a host</span>
<span class="line-added"> 998        * with a string that is longer than 64 KiB.</span>
<span class="line-added"> 999        */</span>
<span class="line-added">1000       const gsize size_large = (gsize) 256 * 256;</span>
<span class="line-added">1001       gchar *tmp;</span>
<span class="line-added">1002 </span>
<span class="line-added">1003       max = sysconf (_SC_HOST_NAME_MAX);</span>
<span class="line-added">1004       if (max &gt; 0 &amp;&amp; max &lt;= G_MAXSIZE - 1)</span>
<span class="line-added">1005         size = (gsize) max + 1;</span>
<span class="line-added">1006       else</span>
<span class="line-added">1007 #ifdef HOST_NAME_MAX</span>
<span class="line-added">1008         size = HOST_NAME_MAX + 1;</span>
<span class="line-added">1009 #else</span>
<span class="line-added">1010         size = _POSIX_HOST_NAME_MAX + 1;</span>
<span class="line-added">1011 #endif</span>
<span class="line-added">1012 </span>
<span class="line-added">1013       tmp = g_malloc (size);</span>
<span class="line-added">1014       failed = (gethostname (tmp, size) == -1);</span>
<span class="line-added">1015       if (failed &amp;&amp; size &lt; size_large)</span>
<span class="line-added">1016         {</span>
<span class="line-added">1017           /* Try again with a larger buffer if &#39;size&#39; may be too small. */</span>
<span class="line-added">1018           g_free (tmp);</span>
<span class="line-added">1019           tmp = g_malloc (size_large);</span>
<span class="line-added">1020           failed = (gethostname (tmp, size_large) == -1);</span>
<span class="line-added">1021         }</span>
<span class="line-added">1022 </span>
1023       if (failed)
1024         g_clear_pointer (&amp;tmp, g_free);
1025       utmp = tmp;
1026 #else
1027       wchar_t tmp[MAX_COMPUTERNAME_LENGTH + 1];
1028       DWORD size = sizeof (tmp) / sizeof (tmp[0]);
1029       failed = (!GetComputerNameW (tmp, &amp;size));
1030       if (!failed)
1031         utmp = g_utf16_to_utf8 (tmp, size, NULL, NULL, NULL);
1032       if (utmp == NULL)
1033         failed = TRUE;
1034 #endif
1035 
1036       g_once_init_leave (&amp;hostname, failed ? g_strdup (&quot;localhost&quot;) : utmp);
1037     }
1038 
1039   return hostname;
1040 }
1041 
1042 G_LOCK_DEFINE_STATIC (g_prgname);
1043 static gchar *g_prgname = NULL;
1044 
1045 /**
1046  * g_get_prgname:
1047  *
1048  * Gets the name of the program. This name should not be localized,
1049  * in contrast to g_get_application_name().
1050  *
1051  * If you are using #GApplication the program name is set in
1052  * g_application_run(). In case of GDK or GTK+ it is set in
1053  * gdk_init(), which is called by gtk_init() and the
1054  * #GtkApplication::startup handler. The program name is found by
1055  * taking the last component of @argv[0].
1056  *
<span class="line-modified">1057  * Returns: (nullable): the name of the program, or %NULL if it has not been</span>
<span class="line-added">1058  *     set yet. The returned string belongs</span>
1059  *     to GLib and must not be modified or freed.
1060  */
1061 const gchar*
1062 g_get_prgname (void)
1063 {
1064   gchar* retval;
1065 
1066   G_LOCK (g_prgname);























1067   retval = g_prgname;
1068   G_UNLOCK (g_prgname);
1069 
1070   return retval;
1071 }
1072 
1073 /**
1074  * g_set_prgname:
1075  * @prgname: the name of the program.
1076  *
1077  * Sets the name of the program. This name should not be localized,
1078  * in contrast to g_set_application_name().
1079  *
1080  * If you are using #GApplication the program name is set in
1081  * g_application_run(). In case of GDK or GTK+ it is set in
1082  * gdk_init(), which is called by gtk_init() and the
1083  * #GtkApplication::startup handler. The program name is found by
1084  * taking the last component of @argv[0].
1085  *
1086  * Note that for thread-safety reasons this function can only be called once.
</pre>
<hr />
<pre>
1144  * or when displaying an application&#39;s name in the task list.
1145  *
1146  * Since: 2.2
1147  **/
1148 void
1149 g_set_application_name (const gchar *application_name)
1150 {
1151   gboolean already_set = FALSE;
1152 
1153   G_LOCK (g_application_name);
1154   if (g_application_name)
1155     already_set = TRUE;
1156   else
1157     g_application_name = g_strdup (application_name);
1158   G_UNLOCK (g_application_name);
1159 
1160   if (already_set)
1161     g_warning (&quot;g_set_application_name() called multiple times&quot;);
1162 }
1163 
<span class="line-added">1164 /* Set @global_str to a copy of @new_value if it&#39;s currently unset or has a</span>
<span class="line-added">1165  * different value. If its current value matches @new_value, do nothing. If</span>
<span class="line-added">1166  * replaced, we have to leak the old value as client code could still have</span>
<span class="line-added">1167  * pointers to it. */</span>
<span class="line-added">1168 static void</span>
<span class="line-added">1169 set_str_if_different (gchar       **global_str,</span>
<span class="line-added">1170                       const gchar  *type,</span>
<span class="line-added">1171                       const gchar  *new_value)</span>
<span class="line-added">1172 {</span>
<span class="line-added">1173   if (*global_str == NULL ||</span>
<span class="line-added">1174       !g_str_equal (new_value, *global_str))</span>
<span class="line-added">1175     {</span>
<span class="line-added">1176       g_debug (&quot;g_set_user_dirs: Setting %s to %s&quot;, type, new_value);</span>
<span class="line-added">1177 </span>
<span class="line-added">1178       /* We have to leak the old value, as user code could be retaining pointers</span>
<span class="line-added">1179        * to it. */</span>
<span class="line-added">1180       *global_str = g_strdup (new_value);</span>
<span class="line-added">1181     }</span>
<span class="line-added">1182 }</span>
<span class="line-added">1183 </span>
<span class="line-added">1184 static void</span>
<span class="line-added">1185 set_strv_if_different (gchar                ***global_strv,</span>
<span class="line-added">1186                        const gchar            *type,</span>
<span class="line-added">1187                        const gchar  * const   *new_value)</span>
<span class="line-added">1188 {</span>
<span class="line-added">1189   if (*global_strv == NULL ||</span>
<span class="line-added">1190       !g_strv_equal (new_value, (const gchar * const *) *global_strv))</span>
<span class="line-added">1191     {</span>
<span class="line-added">1192       gchar *new_value_str = g_strjoinv (&quot;:&quot;, (gchar **) new_value);</span>
<span class="line-added">1193       g_debug (&quot;g_set_user_dirs: Setting %s to %s&quot;, type, new_value_str);</span>
<span class="line-added">1194       g_free (new_value_str);</span>
<span class="line-added">1195 </span>
<span class="line-added">1196       /* We have to leak the old value, as user code could be retaining pointers</span>
<span class="line-added">1197        * to it. */</span>
<span class="line-added">1198       *global_strv = g_strdupv ((gchar **) new_value);</span>
<span class="line-added">1199     }</span>
<span class="line-added">1200 }</span>
<span class="line-added">1201 </span>
<span class="line-added">1202 /*</span>
<span class="line-added">1203  * g_set_user_dirs:</span>
<span class="line-added">1204  * @first_dir_type: Type of the first directory to set</span>
<span class="line-added">1205  * @...: Value to set the first directory to, followed by additional type/value</span>
<span class="line-added">1206  *    pairs, followed by %NULL</span>
<span class="line-added">1207  *</span>
<span class="line-added">1208  * Set one or more &#39;user&#39; directories to custom values. This is intended to be</span>
<span class="line-added">1209  * used by test code (particularly with the %G_TEST_OPTION_ISOLATE_DIRS option)</span>
<span class="line-added">1210  * to override the values returned by the following functions, so that test</span>
<span class="line-added">1211  * code can be run without touching an installed system and user data:</span>
<span class="line-added">1212  *</span>
<span class="line-added">1213  *  - g_get_home_dir() - use type `HOME`, pass a string</span>
<span class="line-added">1214  *  - g_get_user_cache_dir() - use type `XDG_CACHE_HOME`, pass a string</span>
<span class="line-added">1215  *  - g_get_system_config_dirs() - use type `XDG_CONFIG_DIRS`, pass a</span>
<span class="line-added">1216  *    %NULL-terminated string array</span>
<span class="line-added">1217  *  - g_get_user_config_dir() - use type `XDG_CONFIG_HOME`, pass a string</span>
<span class="line-added">1218  *  - g_get_system_data_dirs() - use type `XDG_DATA_DIRS`, pass a</span>
<span class="line-added">1219  *    %NULL-terminated string array</span>
<span class="line-added">1220  *  - g_get_user_data_dir() - use type `XDG_DATA_HOME`, pass a string</span>
<span class="line-added">1221  *  - g_get_user_runtime_dir() - use type `XDG_RUNTIME_DIR`, pass a string</span>
<span class="line-added">1222  *</span>
<span class="line-added">1223  * The list must be terminated with a %NULL type. All of the values must be</span>
<span class="line-added">1224  * non-%NULL - passing %NULL as a value won&#39;t reset a directory. If a reference</span>
<span class="line-added">1225  * to a directory from the calling environment needs to be kept, copy it before</span>
<span class="line-added">1226  * the first call to g_set_user_dirs(). g_set_user_dirs() can be called multiple</span>
<span class="line-added">1227  * times.</span>
<span class="line-added">1228  *</span>
<span class="line-added">1229  * Since: 2.60</span>
<span class="line-added">1230  */</span>
<span class="line-added">1231 /*&lt; private &gt; */</span>
<span class="line-added">1232 void</span>
<span class="line-added">1233 g_set_user_dirs (const gchar *first_dir_type,</span>
<span class="line-added">1234                  ...)</span>
<span class="line-added">1235 {</span>
<span class="line-added">1236   va_list args;</span>
<span class="line-added">1237   const gchar *dir_type;</span>
<span class="line-added">1238 </span>
<span class="line-added">1239   G_LOCK (g_utils_global);</span>
<span class="line-added">1240 </span>
<span class="line-added">1241   va_start (args, first_dir_type);</span>
<span class="line-added">1242 </span>
<span class="line-added">1243   for (dir_type = first_dir_type; dir_type != NULL; dir_type = va_arg (args, const gchar *))</span>
<span class="line-added">1244     {</span>
<span class="line-added">1245       gconstpointer dir_value = va_arg (args, gconstpointer);</span>
<span class="line-added">1246       g_assert (dir_value != NULL);</span>
<span class="line-added">1247 </span>
<span class="line-added">1248       if (g_str_equal (dir_type, &quot;HOME&quot;))</span>
<span class="line-added">1249         set_str_if_different (&amp;g_home_dir, dir_type, dir_value);</span>
<span class="line-added">1250       else if (g_str_equal (dir_type, &quot;XDG_CACHE_HOME&quot;))</span>
<span class="line-added">1251         set_str_if_different (&amp;g_user_cache_dir, dir_type, dir_value);</span>
<span class="line-added">1252       else if (g_str_equal (dir_type, &quot;XDG_CONFIG_DIRS&quot;))</span>
<span class="line-added">1253         set_strv_if_different (&amp;g_system_config_dirs, dir_type, dir_value);</span>
<span class="line-added">1254       else if (g_str_equal (dir_type, &quot;XDG_CONFIG_HOME&quot;))</span>
<span class="line-added">1255         set_str_if_different (&amp;g_user_config_dir, dir_type, dir_value);</span>
<span class="line-added">1256       else if (g_str_equal (dir_type, &quot;XDG_DATA_DIRS&quot;))</span>
<span class="line-added">1257         set_strv_if_different (&amp;g_system_data_dirs, dir_type, dir_value);</span>
<span class="line-added">1258       else if (g_str_equal (dir_type, &quot;XDG_DATA_HOME&quot;))</span>
<span class="line-added">1259         set_str_if_different (&amp;g_user_data_dir, dir_type, dir_value);</span>
<span class="line-added">1260       else if (g_str_equal (dir_type, &quot;XDG_RUNTIME_DIR&quot;))</span>
<span class="line-added">1261         set_str_if_different (&amp;g_user_runtime_dir, dir_type, dir_value);</span>
<span class="line-added">1262       else</span>
<span class="line-added">1263         g_assert_not_reached ();</span>
<span class="line-added">1264     }</span>
<span class="line-added">1265 </span>
<span class="line-added">1266   va_end (args);</span>
<span class="line-added">1267 </span>
<span class="line-added">1268   G_UNLOCK (g_utils_global);</span>
<span class="line-added">1269 }</span>
<span class="line-added">1270 </span>
<span class="line-added">1271 static gchar *</span>
<span class="line-added">1272 g_build_user_data_dir (void)</span>
<span class="line-added">1273 {</span>
<span class="line-added">1274   gchar *data_dir = NULL;</span>
<span class="line-added">1275   const gchar *data_dir_env = g_getenv (&quot;XDG_DATA_HOME&quot;);</span>
<span class="line-added">1276 </span>
<span class="line-added">1277   if (data_dir_env &amp;&amp; data_dir_env[0])</span>
<span class="line-added">1278     data_dir = g_strdup (data_dir_env);</span>
<span class="line-added">1279 #ifdef G_OS_WIN32</span>
<span class="line-added">1280   else</span>
<span class="line-added">1281     data_dir = get_special_folder (CSIDL_LOCAL_APPDATA);</span>
<span class="line-added">1282 #endif</span>
<span class="line-added">1283   if (!data_dir || !data_dir[0])</span>
<span class="line-added">1284     {</span>
<span class="line-added">1285       gchar *home_dir = g_build_home_dir ();</span>
<span class="line-added">1286       data_dir = g_build_filename (home_dir, &quot;.local&quot;, &quot;share&quot;, NULL);</span>
<span class="line-added">1287       g_free (home_dir);</span>
<span class="line-added">1288     }</span>
<span class="line-added">1289 </span>
<span class="line-added">1290   return g_steal_pointer (&amp;data_dir);</span>
<span class="line-added">1291 }</span>
<span class="line-added">1292 </span>
1293 /**
1294  * g_get_user_data_dir:
1295  *
1296  * Returns a base directory in which to access application data such
1297  * as icons that is customized for a particular user.
1298  *
1299  * On UNIX platforms this is determined using the mechanisms described
1300  * in the
1301  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1302  * In this case the directory retrieved will be `XDG_DATA_HOME`.
1303  *
1304  * On Windows it follows XDG Base Directory Specification if `XDG_DATA_HOME`
1305  * is defined. If `XDG_DATA_HOME` is undefined, the folder to use for local (as
1306  * opposed to roaming) application data is used instead. See the
1307  * [documentation for `CSIDL_LOCAL_APPDATA`](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx#csidl_local_appdata).
1308  * Note that in this case on Windows it will be the same
1309  * as what g_get_user_config_dir() returns.
1310  *
1311  * Returns: (type filename): a string owned by GLib that must not be modified
1312  *               or freed.
1313  * Since: 2.6
1314  **/
1315 const gchar *
1316 g_get_user_data_dir (void)
1317 {
<span class="line-modified">1318   const gchar *user_data_dir;</span>
1319 
1320   G_LOCK (g_utils_global);
1321 
<span class="line-modified">1322   if (g_user_data_dir == NULL)</span>
<span class="line-modified">1323     g_user_data_dir = g_build_user_data_dir ();</span>
<span class="line-modified">1324   user_data_dir = g_user_data_dir;</span>





















1325 
1326   G_UNLOCK (g_utils_global);
1327 
<span class="line-modified">1328   return user_data_dir;</span>
1329 }
1330 
<span class="line-modified">1331 static gchar *</span>
<span class="line-modified">1332 g_build_user_config_dir (void)</span>
1333 {
1334   gchar *config_dir = NULL;
<span class="line-added">1335   const gchar *config_dir_env = g_getenv (&quot;XDG_CONFIG_HOME&quot;);</span>
1336 
<span class="line-modified">1337   if (config_dir_env &amp;&amp; config_dir_env[0])</span>




1338     config_dir = g_strdup (config_dir_env);
1339 #ifdef G_OS_WIN32
<span class="line-modified">1340   else</span>
<span class="line-modified">1341     config_dir = get_special_folder (CSIDL_LOCAL_APPDATA);</span>
1342 #endif
<span class="line-modified">1343   if (!config_dir || !config_dir[0])</span>
1344     {
<span class="line-modified">1345       gchar *home_dir = g_build_home_dir ();</span>
<span class="line-modified">1346       config_dir = g_build_filename (home_dir, &quot;.config&quot;, NULL);</span>
<span class="line-modified">1347       g_free (home_dir);</span>



1348     }
1349 
<span class="line-modified">1350   return g_steal_pointer (&amp;config_dir);</span>

1351 }
1352 
1353 /**
1354  * g_get_user_config_dir:
1355  *
1356  * Returns a base directory in which to store user-specific application
1357  * configuration information such as user preferences and settings.
1358  *
1359  * On UNIX platforms this is determined using the mechanisms described
1360  * in the
1361  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1362  * In this case the directory retrieved will be `XDG_CONFIG_HOME`.
1363  *
1364  * On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_HOME` is defined.
1365  * If `XDG_CONFIG_HOME` is undefined, the folder to use for local (as opposed
1366  * to roaming) application data is used instead. See the
1367  * [documentation for `CSIDL_LOCAL_APPDATA`](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx#csidl_local_appdata).
1368  * Note that in this case on Windows it will be  the same
1369  * as what g_get_user_data_dir() returns.
1370  *
1371  * Returns: (type filename): a string owned by GLib that must not be modified
1372  *               or freed.
1373  * Since: 2.6
1374  **/
1375 const gchar *
1376 g_get_user_config_dir (void)
1377 {
<span class="line-added">1378   const gchar *user_config_dir;</span>
<span class="line-added">1379 </span>
1380   G_LOCK (g_utils_global);
1381 
<span class="line-modified">1382   if (g_user_config_dir == NULL)</span>
<span class="line-added">1383     g_user_config_dir = g_build_user_config_dir ();</span>
<span class="line-added">1384   user_config_dir = g_user_config_dir;</span>
1385 
1386   G_UNLOCK (g_utils_global);
1387 
<span class="line-modified">1388   return user_config_dir;</span>
<span class="line-added">1389 }</span>
<span class="line-added">1390 </span>
<span class="line-added">1391 static gchar *</span>
<span class="line-added">1392 g_build_user_cache_dir (void)</span>
<span class="line-added">1393 {</span>
<span class="line-added">1394   gchar *cache_dir = NULL;</span>
<span class="line-added">1395   const gchar *cache_dir_env = g_getenv (&quot;XDG_CACHE_HOME&quot;);</span>
<span class="line-added">1396 </span>
<span class="line-added">1397   if (cache_dir_env &amp;&amp; cache_dir_env[0])</span>
<span class="line-added">1398     cache_dir = g_strdup (cache_dir_env);</span>
<span class="line-added">1399 #ifdef G_OS_WIN32</span>
<span class="line-added">1400   else</span>
<span class="line-added">1401     cache_dir = get_special_folder (CSIDL_INTERNET_CACHE);</span>
<span class="line-added">1402 #endif</span>
<span class="line-added">1403   if (!cache_dir || !cache_dir[0])</span>
<span class="line-added">1404     {</span>
<span class="line-added">1405       gchar *home_dir = g_build_home_dir ();</span>
<span class="line-added">1406       cache_dir = g_build_filename (home_dir, &quot;.cache&quot;, NULL);</span>
<span class="line-added">1407       g_free (home_dir);</span>
<span class="line-added">1408     }</span>
<span class="line-added">1409 </span>
<span class="line-added">1410   return g_steal_pointer (&amp;cache_dir);</span>
1411 }
1412 
1413 /**
1414  * g_get_user_cache_dir:
1415  *
1416  * Returns a base directory in which to store non-essential, cached
1417  * data specific to particular user.
1418  *
1419  * On UNIX platforms this is determined using the mechanisms described
1420  * in the
1421  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1422  * In this case the directory retrieved will be `XDG_CACHE_HOME`.
1423  *
1424  * On Windows it follows XDG Base Directory Specification if `XDG_CACHE_HOME` is defined.
1425  * If `XDG_CACHE_HOME` is undefined, the directory that serves as a common
1426  * repository for temporary Internet files is used instead. A typical path is
1427  * `C:\Documents and Settings\username\Local Settings\Temporary Internet Files`.
1428  * See the [documentation for `CSIDL_INTERNET_CACHE`](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx#csidl_internet_cache).
1429  *
1430  * Returns: (type filename): a string owned by GLib that must not be modified
1431  *               or freed.
1432  * Since: 2.6
1433  **/
1434 const gchar *
1435 g_get_user_cache_dir (void)
1436 {
<span class="line-modified">1437   const gchar *user_cache_dir;</span>
1438 
1439   G_LOCK (g_utils_global);
1440 
<span class="line-modified">1441   if (g_user_cache_dir == NULL)</span>
<span class="line-modified">1442     g_user_cache_dir = g_build_user_cache_dir ();</span>
<span class="line-modified">1443   user_cache_dir = g_user_cache_dir;</span>
1444 
<span class="line-modified">1445   G_UNLOCK (g_utils_global);</span>








1446 
<span class="line-modified">1447   return user_cache_dir;</span>
<span class="line-modified">1448 }</span>
<span class="line-modified">1449 </span>
<span class="line-modified">1450 static gchar *</span>
<span class="line-modified">1451 g_build_user_runtime_dir (void)</span>
<span class="line-modified">1452 {</span>
<span class="line-modified">1453   gchar *runtime_dir = NULL;</span>
<span class="line-added">1454   const gchar *runtime_dir_env = g_getenv (&quot;XDG_RUNTIME_DIR&quot;);</span>
<span class="line-added">1455 </span>
<span class="line-added">1456   if (runtime_dir_env &amp;&amp; runtime_dir_env[0])</span>
<span class="line-added">1457     runtime_dir = g_strdup (runtime_dir_env);</span>
1458   else
<span class="line-modified">1459     {</span>
<span class="line-added">1460       runtime_dir = g_build_user_cache_dir ();</span>
1461 
<span class="line-modified">1462       /* The user should be able to rely on the directory existing</span>
<span class="line-added">1463        * when the function returns.  Probably it already does, but</span>
<span class="line-added">1464        * let&#39;s make sure.  Just do mkdir() directly since it will be</span>
<span class="line-added">1465        * no more expensive than a stat() in the case that the</span>
<span class="line-added">1466        * directory already exists and is a lot easier.</span>
<span class="line-added">1467        *</span>
<span class="line-added">1468        * $XDG_CACHE_HOME is probably ~/.cache/ so as long as $HOME</span>
<span class="line-added">1469        * exists this will work.  If the user changed $XDG_CACHE_HOME</span>
<span class="line-added">1470        * then they can make sure that it exists...</span>
<span class="line-added">1471        */</span>
<span class="line-added">1472       (void) g_mkdir (runtime_dir, 0700);</span>
<span class="line-added">1473     }</span>
1474 
<span class="line-modified">1475   return g_steal_pointer (&amp;runtime_dir);</span>
1476 }
1477 
1478 /**
1479  * g_get_user_runtime_dir:
1480  *
1481  * Returns a directory that is unique to the current user on the local
1482  * system.
1483  *
1484  * This is determined using the mechanisms described
1485  * in the
1486  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
1487  * This is the directory
1488  * specified in the `XDG_RUNTIME_DIR` environment variable.
1489  * In the case that this variable is not set, we return the value of
1490  * g_get_user_cache_dir(), after verifying that it exists.
1491  *
1492  * Returns: (type filename): a string owned by GLib that must not be
1493  *     modified or freed.
1494  *
1495  * Since: 2.28
1496  **/
1497 const gchar *
1498 g_get_user_runtime_dir (void)
1499 {
<span class="line-modified">1500   const gchar *user_runtime_dir;</span>






1501 
<span class="line-modified">1502   G_LOCK (g_utils_global);</span>
















1503 
<span class="line-modified">1504   if (g_user_runtime_dir == NULL)</span>
<span class="line-added">1505     g_user_runtime_dir = g_build_user_runtime_dir ();</span>
<span class="line-added">1506   user_runtime_dir = g_user_runtime_dir;</span>
1507 
<span class="line-modified">1508   G_UNLOCK (g_utils_global);</span>

1509 
<span class="line-modified">1510   return user_runtime_dir;</span>
1511 }
1512 
<span class="line-modified">1513 #ifdef HAVE_COCOA</span>
1514 
<span class="line-modified">1515 /* Implemented in gutils-macos.m */</span>
<span class="line-modified">1516 void load_user_special_dirs_macos (gchar **table);</span>


































1517 
1518 static void
1519 load_user_special_dirs (void)
1520 {
<span class="line-modified">1521   load_user_special_dirs_macos (g_user_special_dirs);</span>







1522 }
1523 
1524 #elif defined(G_OS_WIN32)
1525 
1526 static void
1527 load_user_special_dirs (void)
1528 {
1529   typedef HRESULT (WINAPI *t_SHGetKnownFolderPath) (const GUID *rfid,
<span class="line-modified">1530                 DWORD dwFlags,</span>
<span class="line-modified">1531                 HANDLE hToken,</span>
<span class="line-modified">1532                 PWSTR *ppszPath);</span>
1533   t_SHGetKnownFolderPath p_SHGetKnownFolderPath;
1534 
1535   static const GUID FOLDERID_Downloads =
1536     { 0x374de290, 0x123f, 0x4565, { 0x91, 0x64, 0x39, 0xc4, 0x92, 0x5e, 0x46, 0x7b } };
1537   static const GUID FOLDERID_Public =
1538     { 0xDFDF76A2, 0xC82A, 0x4D63, { 0x90, 0x6A, 0x56, 0x44, 0xAC, 0x45, 0x73, 0x85 } };
1539 
1540   wchar_t *wcp;
1541 
1542   p_SHGetKnownFolderPath = (t_SHGetKnownFolderPath) GetProcAddress (GetModuleHandle (&quot;shell32.dll&quot;),
<span class="line-modified">1543                     &quot;SHGetKnownFolderPath&quot;);</span>
1544 
1545   g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
1546   g_user_special_dirs[G_USER_DIRECTORY_DOCUMENTS] = get_special_folder (CSIDL_PERSONAL);
1547 
1548   if (p_SHGetKnownFolderPath == NULL)
1549     {
1550       g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
1551     }
1552   else
1553     {
1554       wcp = NULL;
1555       (*p_SHGetKnownFolderPath) (&amp;FOLDERID_Downloads, 0, NULL, &amp;wcp);
1556       if (wcp)
1557         {
1558           g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = g_utf16_to_utf8 (wcp, -1, NULL, NULL, NULL);
1559           if (g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] == NULL)
1560               g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
1561           CoTaskMemFree (wcp);
1562         }
1563       else
</pre>
<hr />
<pre>
1603  * including without limitation the rights to use, copy, modify, merge,
1604  * publish, distribute, sublicense, and/or sell copies of the Software,
1605  * and to permit persons to whom the Software is furnished to do so,
1606  * subject to the following conditions:
1607  *
1608  * The above copyright notice and this permission notice shall be
1609  * included in all copies or substantial portions of the Software.
1610  *
1611  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
1612  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
1613  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
1614  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
1615  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
1616  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
1617  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
1618  * SOFTWARE.
1619  */
1620 static void
1621 load_user_special_dirs (void)
1622 {
<span class="line-added">1623   gchar *config_dir = NULL;</span>
1624   gchar *config_file;
1625   gchar *data;
1626   gchar **lines;
1627   gint n_lines, i;
1628 
<span class="line-modified">1629   config_dir = g_build_user_config_dir ();</span>
<span class="line-modified">1630   config_file = g_build_filename (config_dir,</span>
1631                                   &quot;user-dirs.dirs&quot;,
1632                                   NULL);
<span class="line-added">1633   g_free (config_dir);</span>
1634 
1635   if (!g_file_get_contents (config_file, &amp;data, NULL, NULL))
1636     {
1637       g_free (config_file);
1638       return;
1639     }
1640 
1641   lines = g_strsplit (data, &quot;\n&quot;, -1);
1642   n_lines = g_strv_length (lines);
1643   g_free (data);
1644 
1645   for (i = 0; i &lt; n_lines; i++)
1646     {
1647       gchar *buffer = lines[i];
1648       gchar *d, *p;
1649       gint len;
1650       gboolean is_relative = FALSE;
1651       GUserDirectory directory;
1652 
1653       /* Remove newline at end */
1654       len = strlen (buffer);
1655       if (len &gt; 0 &amp;&amp; buffer[len - 1] == &#39;\n&#39;)
<span class="line-modified">1656   buffer[len - 1] = 0;</span>
1657 
1658       p = buffer;
1659       while (*p == &#39; &#39; || *p == &#39;\t&#39;)
<span class="line-modified">1660   p++;</span>
1661 
1662       if (strncmp (p, &quot;XDG_DESKTOP_DIR&quot;, strlen (&quot;XDG_DESKTOP_DIR&quot;)) == 0)
1663         {
1664           directory = G_USER_DIRECTORY_DESKTOP;
1665           p += strlen (&quot;XDG_DESKTOP_DIR&quot;);
1666         }
1667       else if (strncmp (p, &quot;XDG_DOCUMENTS_DIR&quot;, strlen (&quot;XDG_DOCUMENTS_DIR&quot;)) == 0)
1668         {
1669           directory = G_USER_DIRECTORY_DOCUMENTS;
1670           p += strlen (&quot;XDG_DOCUMENTS_DIR&quot;);
1671         }
1672       else if (strncmp (p, &quot;XDG_DOWNLOAD_DIR&quot;, strlen (&quot;XDG_DOWNLOAD_DIR&quot;)) == 0)
1673         {
1674           directory = G_USER_DIRECTORY_DOWNLOAD;
1675           p += strlen (&quot;XDG_DOWNLOAD_DIR&quot;);
1676         }
1677       else if (strncmp (p, &quot;XDG_MUSIC_DIR&quot;, strlen (&quot;XDG_MUSIC_DIR&quot;)) == 0)
1678         {
1679           directory = G_USER_DIRECTORY_MUSIC;
1680           p += strlen (&quot;XDG_MUSIC_DIR&quot;);
</pre>
<hr />
<pre>
1683         {
1684           directory = G_USER_DIRECTORY_PICTURES;
1685           p += strlen (&quot;XDG_PICTURES_DIR&quot;);
1686         }
1687       else if (strncmp (p, &quot;XDG_PUBLICSHARE_DIR&quot;, strlen (&quot;XDG_PUBLICSHARE_DIR&quot;)) == 0)
1688         {
1689           directory = G_USER_DIRECTORY_PUBLIC_SHARE;
1690           p += strlen (&quot;XDG_PUBLICSHARE_DIR&quot;);
1691         }
1692       else if (strncmp (p, &quot;XDG_TEMPLATES_DIR&quot;, strlen (&quot;XDG_TEMPLATES_DIR&quot;)) == 0)
1693         {
1694           directory = G_USER_DIRECTORY_TEMPLATES;
1695           p += strlen (&quot;XDG_TEMPLATES_DIR&quot;);
1696         }
1697       else if (strncmp (p, &quot;XDG_VIDEOS_DIR&quot;, strlen (&quot;XDG_VIDEOS_DIR&quot;)) == 0)
1698         {
1699           directory = G_USER_DIRECTORY_VIDEOS;
1700           p += strlen (&quot;XDG_VIDEOS_DIR&quot;);
1701         }
1702       else
<span class="line-modified">1703   continue;</span>
1704 
1705       while (*p == &#39; &#39; || *p == &#39;\t&#39;)
<span class="line-modified">1706   p++;</span>
1707 
1708       if (*p != &#39;=&#39;)
<span class="line-modified">1709   continue;</span>
1710       p++;
1711 
1712       while (*p == &#39; &#39; || *p == &#39;\t&#39;)
<span class="line-modified">1713   p++;</span>
1714 
1715       if (*p != &#39;&quot;&#39;)
<span class="line-modified">1716   continue;</span>
1717       p++;
1718 
1719       if (strncmp (p, &quot;$HOME&quot;, 5) == 0)
<span class="line-modified">1720   {</span>
<span class="line-modified">1721     p += 5;</span>
<span class="line-modified">1722     is_relative = TRUE;</span>
<span class="line-modified">1723   }</span>
1724       else if (*p != &#39;/&#39;)
<span class="line-modified">1725   continue;</span>
1726 
1727       d = strrchr (p, &#39;&quot;&#39;);
1728       if (!d)
1729         continue;
1730       *d = 0;
1731 
1732       d = p;
1733 
1734       /* remove trailing slashes */
1735       len = strlen (d);
1736       if (d[len - 1] == &#39;/&#39;)
1737         d[len - 1] = 0;
1738 
1739       if (is_relative)
1740         {
<span class="line-modified">1741           gchar *home_dir = g_build_home_dir ();</span>
<span class="line-added">1742           g_user_special_dirs[directory] = g_build_filename (home_dir, d, NULL);</span>
<span class="line-added">1743           g_free (home_dir);</span>
1744         }
1745       else
<span class="line-modified">1746   g_user_special_dirs[directory] = g_strdup (d);</span>
1747     }
1748 
1749   g_strfreev (lines);
1750   g_free (config_file);
1751 }
1752 
1753 #endif /* platform-specific load_user_special_dirs implementations */
1754 
1755 
1756 /**
1757  * g_reload_user_special_dirs_cache:
1758  *
1759  * Resets the cache used for g_get_user_special_dir(), so
1760  * that the latest on-disk version is used. Call this only
1761  * if you just changed the data on disk yourself.
1762  *
<span class="line-modified">1763  * Due to thread safety issues this may cause leaking of strings</span>
1764  * that were previously returned from g_get_user_special_dir()
1765  * that can&#39;t be freed. We ensure to only leak the data for
1766  * the directories that actually changed value though.
1767  *
1768  * Since: 2.22
1769  */
1770 void
1771 g_reload_user_special_dirs_cache (void)
1772 {
1773   int i;
1774 
1775   G_LOCK (g_utils_global);
1776 
1777   if (g_user_special_dirs != NULL)
1778     {
1779       /* save a copy of the pointer, to check if some memory can be preserved */
1780       char **old_g_user_special_dirs = g_user_special_dirs;
1781       char *old_val;
1782 
1783       /* recreate and reload our cache */
</pre>
<hr />
<pre>
1816  * Returns the full path of a special directory using its logical id.
1817  *
1818  * On UNIX this is done using the XDG special user directories.
1819  * For compatibility with existing practise, %G_USER_DIRECTORY_DESKTOP
1820  * falls back to `$HOME/Desktop` when XDG special user directories have
1821  * not been set up.
1822  *
1823  * Depending on the platform, the user might be able to change the path
1824  * of the special directory without requiring the session to restart; GLib
1825  * will not reflect any change once the special directories are loaded.
1826  *
1827  * Returns: (type filename): the path to the specified special directory, or
1828  *   %NULL if the logical id was not found. The returned string is owned by
1829  *   GLib and should not be modified or freed.
1830  *
1831  * Since: 2.14
1832  */
1833 const gchar *
1834 g_get_user_special_dir (GUserDirectory directory)
1835 {
<span class="line-added">1836   const gchar *user_special_dir;</span>
<span class="line-added">1837 </span>
1838   g_return_val_if_fail (directory &gt;= G_USER_DIRECTORY_DESKTOP &amp;&amp;
1839                         directory &lt; G_USER_N_DIRECTORIES, NULL);
1840 
1841   G_LOCK (g_utils_global);
1842 
1843   if (G_UNLIKELY (g_user_special_dirs == NULL))
1844     {
1845       g_user_special_dirs = g_new0 (gchar *, G_USER_N_DIRECTORIES);
1846 
1847       load_user_special_dirs ();
1848 
1849       /* Special-case desktop for historical compatibility */
1850       if (g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] == NULL)
<span class="line-modified">1851         {</span>
<span class="line-added">1852           gchar *home_dir = g_build_home_dir ();</span>
<span class="line-added">1853           g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = g_build_filename (home_dir, &quot;Desktop&quot;, NULL);</span>
<span class="line-added">1854           g_free (home_dir);</span>
<span class="line-added">1855         }</span>
1856     }
<span class="line-added">1857   user_special_dir = g_user_special_dirs[directory];</span>
1858 
1859   G_UNLOCK (g_utils_global);
1860 
<span class="line-modified">1861   return user_special_dir;</span>
1862 }
1863 
1864 #ifdef G_OS_WIN32
1865 
1866 #undef g_get_system_data_dirs
1867 
1868 static HMODULE
1869 get_module_for_address (gconstpointer address)
1870 {
1871   /* Holds the g_utils_global lock */
1872 
1873   static gboolean beenhere = FALSE;
1874   typedef BOOL (WINAPI *t_GetModuleHandleExA) (DWORD, LPCTSTR, HMODULE *);
1875   static t_GetModuleHandleExA p_GetModuleHandleExA = NULL;
1876   HMODULE hmodule = NULL;
1877 
1878   if (!address)
1879     return NULL;
1880 
1881   if (!beenhere)
1882     {
1883       p_GetModuleHandleExA =
<span class="line-modified">1884   (t_GetModuleHandleExA) GetProcAddress (GetModuleHandle (&quot;kernel32.dll&quot;),</span>
<span class="line-modified">1885                  &quot;GetModuleHandleExA&quot;);</span>
1886       beenhere = TRUE;
1887     }
1888 
1889   if (p_GetModuleHandleExA == NULL ||
1890       !(*p_GetModuleHandleExA) (GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT |
<span class="line-modified">1891         GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,</span>
<span class="line-modified">1892         address, &amp;hmodule))</span>
1893     {
1894       MEMORY_BASIC_INFORMATION mbi;
1895       VirtualQuery (address, &amp;mbi, sizeof (mbi));
1896       hmodule = (HMODULE) mbi.AllocationBase;
1897     }
1898 
1899   return hmodule;
1900 }
1901 
1902 static gchar *
1903 get_module_share_dir (gconstpointer address)
1904 {
1905   HMODULE hmodule;
1906   gchar *filename;
1907   gchar *retval;
1908 
1909   hmodule = get_module_for_address (address);
1910   if (hmodule == NULL)
1911     return NULL;
1912 
</pre>
<hr />
<pre>
1916 
1917   return retval;
1918 }
1919 
1920 static const gchar * const *
1921 g_win32_get_system_data_dirs_for_module_real (void (*address_of_function)(void))
1922 {
1923   GArray *data_dirs;
1924   HMODULE hmodule;
1925   static GHashTable *per_module_data_dirs = NULL;
1926   gchar **retval;
1927   gchar *p;
1928   gchar *exe_root;
1929 
1930   hmodule = NULL;
1931   if (address_of_function)
1932     {
1933       G_LOCK (g_utils_global);
1934       hmodule = get_module_for_address (address_of_function);
1935       if (hmodule != NULL)
<span class="line-modified">1936   {</span>
<span class="line-modified">1937     if (per_module_data_dirs == NULL)</span>
<span class="line-modified">1938       per_module_data_dirs = g_hash_table_new (NULL, NULL);</span>
<span class="line-modified">1939     else</span>
<span class="line-modified">1940       {</span>
<span class="line-modified">1941         retval = g_hash_table_lookup (per_module_data_dirs, hmodule);</span>
1942 
<span class="line-modified">1943         if (retval != NULL)</span>
<span class="line-modified">1944     {</span>
<span class="line-modified">1945       G_UNLOCK (g_utils_global);</span>
<span class="line-modified">1946       return (const gchar * const *) retval;</span>


1947     }
<span class="line-added">1948       }</span>
<span class="line-added">1949   }</span>
1950     }
1951 
1952   data_dirs = g_array_new (TRUE, TRUE, sizeof (char *));
1953 
1954   /* Documents and Settings\All Users\Application Data */
1955   p = get_special_folder (CSIDL_COMMON_APPDATA);
1956   if (p)
1957     g_array_append_val (data_dirs, p);
1958 
1959   /* Documents and Settings\All Users\Documents */
1960   p = get_special_folder (CSIDL_COMMON_DOCUMENTS);
1961   if (p)
1962     g_array_append_val (data_dirs, p);
1963 
1964   /* Using the above subfolders of Documents and Settings perhaps
1965    * makes sense from a Windows perspective.
1966    *
1967    * But looking at the actual use cases of this function in GTK+
1968    * and GNOME software, what we really want is the &quot;share&quot;
1969    * subdirectory of the installation directory for the package
</pre>
<hr />
<pre>
1975    *
1976    * Additionally, also use the &quot;share&quot; subfolder of the installation
1977    * locations of GLib and the .exe file being run.
1978    *
1979    * To guard against none of the above being what is really wanted,
1980    * callers of this function should have Win32-specific code to look
1981    * up their installation folder themselves, and handle a subfolder
1982    * &quot;share&quot; of it in the same way as the folders returned from this
1983    * function.
1984    */
1985 
1986   p = get_module_share_dir (address_of_function);
1987   if (p)
1988     g_array_append_val (data_dirs, p);
1989 
1990   if (glib_dll != NULL)
1991     {
1992       gchar *glib_root = g_win32_get_package_installation_directory_of_module (glib_dll);
1993       p = g_build_filename (glib_root, &quot;share&quot;, NULL);
1994       if (p)
<span class="line-modified">1995   g_array_append_val (data_dirs, p);</span>
1996       g_free (glib_root);
1997     }
1998 
1999   exe_root = g_win32_get_package_installation_directory_of_module (NULL);
2000   p = g_build_filename (exe_root, &quot;share&quot;, NULL);
2001   if (p)
2002     g_array_append_val (data_dirs, p);
2003   g_free (exe_root);
2004 
2005   retval = (gchar **) g_array_free (data_dirs, FALSE);
2006 
2007   if (address_of_function)
2008     {
2009       if (hmodule != NULL)
<span class="line-modified">2010   g_hash_table_insert (per_module_data_dirs, hmodule, retval);</span>
2011       G_UNLOCK (g_utils_global);
2012     }
2013 
2014   return (const gchar * const *) retval;
2015 }
2016 
2017 const gchar * const *
2018 g_win32_get_system_data_dirs_for_module (void (*address_of_function)(void))
2019 {
2020   gboolean should_call_g_get_system_data_dirs;
2021 
2022   should_call_g_get_system_data_dirs = TRUE;
<span class="line-modified">2023   /* These checks are the same as the ones that g_build_system_data_dirs() does.</span>
2024    * Please keep them in sync.
2025    */
2026   G_LOCK (g_utils_global);
2027 
2028   if (!g_system_data_dirs)
2029     {
2030       const gchar *data_dirs = g_getenv (&quot;XDG_DATA_DIRS&quot;);
2031 
2032       if (!data_dirs || !data_dirs[0])
2033         should_call_g_get_system_data_dirs = FALSE;
2034     }
2035 
2036   G_UNLOCK (g_utils_global);
2037 
2038   /* There is a subtle difference between g_win32_get_system_data_dirs_for_module (NULL),
2039    * which is what GLib code can normally call,
2040    * and g_win32_get_system_data_dirs_for_module (&amp;_g_win32_get_system_data_dirs),
2041    * which is what the inline function used by non-GLib code calls.
2042    * The former gets prefix relative to currently-running executable,
2043    * the latter - relative to the module that calls _g_win32_get_system_data_dirs()
</pre>
<hr />
<pre>
2047    * call g_get_system_data_dirs() from there - because we need to get the address
2048    * local to the non-GLib caller-module.
2049    */
2050 
2051   /*
2052    * g_get_system_data_dirs() will fall back to calling
2053    * g_win32_get_system_data_dirs_for_module_real(NULL) if XDG_DATA_DIRS is NULL
2054    * or an empty string. The checks above ensure that we do not call it in such
2055    * cases and use the address_of_function that we&#39;ve been given by the inline function.
2056    * The reason we&#39;re calling g_get_system_data_dirs /at all/ is to give
2057    * XDG_DATA_DIRS precedence (if it is set).
2058    */
2059   if (should_call_g_get_system_data_dirs)
2060     return g_get_system_data_dirs ();
2061 
2062   return g_win32_get_system_data_dirs_for_module_real (address_of_function);
2063 }
2064 
2065 #endif
2066 
<span class="line-added">2067 static gchar **</span>
<span class="line-added">2068 g_build_system_data_dirs (void)</span>
<span class="line-added">2069 {</span>
<span class="line-added">2070   gchar **data_dir_vector = NULL;</span>
<span class="line-added">2071   gchar *data_dirs = (gchar *) g_getenv (&quot;XDG_DATA_DIRS&quot;);</span>
<span class="line-added">2072 </span>
<span class="line-added">2073   /* These checks are the same as the ones that g_win32_get_system_data_dirs_for_module()</span>
<span class="line-added">2074    * does. Please keep them in sync.</span>
<span class="line-added">2075    */</span>
<span class="line-added">2076 #ifndef G_OS_WIN32</span>
<span class="line-added">2077   if (!data_dirs || !data_dirs[0])</span>
<span class="line-added">2078     data_dirs = &quot;/usr/local/share/:/usr/share/&quot;;</span>
<span class="line-added">2079 </span>
<span class="line-added">2080   data_dir_vector = g_strsplit (data_dirs, G_SEARCHPATH_SEPARATOR_S, 0);</span>
<span class="line-added">2081 #else</span>
<span class="line-added">2082   if (!data_dirs || !data_dirs[0])</span>
<span class="line-added">2083     data_dir_vector = g_strdupv ((gchar **) g_win32_get_system_data_dirs_for_module_real (NULL));</span>
<span class="line-added">2084   else</span>
<span class="line-added">2085     data_dir_vector = g_strsplit (data_dirs, G_SEARCHPATH_SEPARATOR_S, 0);</span>
<span class="line-added">2086 #endif</span>
<span class="line-added">2087 </span>
<span class="line-added">2088   return g_steal_pointer (&amp;data_dir_vector);</span>
<span class="line-added">2089 }</span>
<span class="line-added">2090 </span>
2091 /**
2092  * g_get_system_data_dirs:
2093  *
2094  * Returns an ordered list of base directories in which to access
2095  * system-wide application data.
2096  *
2097  * On UNIX platforms this is determined using the mechanisms described
2098  * in the
2099  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec)
2100  * In this case the list of directories retrieved will be `XDG_DATA_DIRS`.
2101  *
2102  * On Windows it follows XDG Base Directory Specification if `XDG_DATA_DIRS` is defined.
2103  * If `XDG_DATA_DIRS` is undefined,
2104  * the first elements in the list are the Application Data
2105  * and Documents folders for All Users. (These can be determined only
2106  * on Windows 2000 or later and are not present in the list on other
2107  * Windows versions.) See documentation for CSIDL_COMMON_APPDATA and
2108  * CSIDL_COMMON_DOCUMENTS.
2109  *
2110  * Then follows the &quot;share&quot; subfolder in the installation folder for
</pre>
<hr />
<pre>
2115  * folder for GLib, and in the installation folder for the package the
2116  * application&#39;s .exe file belongs to.
2117  *
2118  * The installation folders above are determined by looking up the
2119  * folder where the module (DLL or EXE) in question is located. If the
2120  * folder&#39;s name is &quot;bin&quot;, its parent is used, otherwise the folder
2121  * itself.
2122  *
2123  * Note that on Windows the returned list can vary depending on where
2124  * this function is called.
2125  *
2126  * Returns: (array zero-terminated=1) (element-type filename) (transfer none):
2127  *     a %NULL-terminated array of strings owned by GLib that must not be
2128  *     modified or freed.
2129  *
2130  * Since: 2.6
2131  **/
2132 const gchar * const *
2133 g_get_system_data_dirs (void)
2134 {
<span class="line-modified">2135   const gchar * const *system_data_dirs;</span>
2136 



2137   G_LOCK (g_utils_global);
2138 
<span class="line-modified">2139   if (g_system_data_dirs == NULL)</span>
<span class="line-modified">2140     g_system_data_dirs = g_build_system_data_dirs ();</span>
<span class="line-modified">2141   system_data_dirs = (const gchar * const *) g_system_data_dirs;</span>
2142 
<span class="line-modified">2143   G_UNLOCK (g_utils_global);</span>


2144 
<span class="line-modified">2145   return system_data_dirs;</span>
<span class="line-modified">2146 }</span>





2147 
<span class="line-modified">2148 static gchar **</span>
<span class="line-added">2149 g_build_system_config_dirs (void)</span>
<span class="line-added">2150 {</span>
<span class="line-added">2151   gchar **conf_dir_vector = NULL;</span>
<span class="line-added">2152   const gchar *conf_dirs = g_getenv (&quot;XDG_CONFIG_DIRS&quot;);</span>
<span class="line-added">2153 #ifdef G_OS_WIN32</span>
<span class="line-added">2154   if (conf_dirs)</span>
<span class="line-added">2155     {</span>
<span class="line-added">2156       conf_dir_vector = g_strsplit (conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);</span>
2157     }
2158   else
<span class="line-modified">2159     {</span>
<span class="line-added">2160       gchar *special_conf_dirs = get_special_folder (CSIDL_COMMON_APPDATA);</span>
2161 
<span class="line-modified">2162       if (special_conf_dirs)</span>
<span class="line-added">2163         conf_dir_vector = g_strsplit (special_conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);</span>
<span class="line-added">2164       else</span>
<span class="line-added">2165         /* Return empty list */</span>
<span class="line-added">2166         conf_dir_vector = g_strsplit (&quot;&quot;, G_SEARCHPATH_SEPARATOR_S, 0);</span>
2167 
<span class="line-modified">2168       g_free (special_conf_dirs);</span>
<span class="line-added">2169     }</span>
<span class="line-added">2170 #else</span>
<span class="line-added">2171   if (!conf_dirs || !conf_dirs[0])</span>
<span class="line-added">2172     conf_dirs = &quot;/etc/xdg&quot;;</span>
<span class="line-added">2173 </span>
<span class="line-added">2174   conf_dir_vector = g_strsplit (conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);</span>
<span class="line-added">2175 #endif</span>
<span class="line-added">2176 </span>
<span class="line-added">2177   return g_steal_pointer (&amp;conf_dir_vector);</span>
2178 }
2179 
2180 /**
2181  * g_get_system_config_dirs:
2182  *
2183  * Returns an ordered list of base directories in which to access
2184  * system-wide configuration information.
2185  *
2186  * On UNIX platforms this is determined using the mechanisms described
2187  * in the
2188  * [XDG Base Directory Specification](http://www.freedesktop.org/Standards/basedir-spec).
2189  * In this case the list of directories retrieved will be `XDG_CONFIG_DIRS`.
2190  *
2191  * On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_DIRS` is defined.
2192  * If `XDG_CONFIG_DIRS` is undefined, the directory that contains application
2193  * data for all users is used instead. A typical path is
2194  * `C:\Documents and Settings\All Users\Application Data`.
2195  * This folder is used for application data
2196  * that is not user specific. For example, an application can store
2197  * a spell-check dictionary, a database of clip art, or a log file in the
2198  * CSIDL_COMMON_APPDATA folder. This information will not roam and is available
2199  * to anyone using the computer.
2200  *
2201  * Returns: (array zero-terminated=1) (element-type filename) (transfer none):
2202  *     a %NULL-terminated array of strings owned by GLib that must not be
2203  *     modified or freed.
2204  *
2205  * Since: 2.6
2206  **/
2207 const gchar * const *
2208 g_get_system_config_dirs (void)
2209 {
<span class="line-modified">2210   const gchar * const *system_config_dirs;</span>
2211 
2212   G_LOCK (g_utils_global);
2213 
<span class="line-modified">2214   if (g_system_config_dirs == NULL)</span>
<span class="line-modified">2215     g_system_config_dirs = g_build_system_config_dirs ();</span>
<span class="line-modified">2216   system_config_dirs = (const gchar * const *) g_system_config_dirs;</span>














2217 













2218   G_UNLOCK (g_utils_global);
2219 
<span class="line-modified">2220   return system_config_dirs;</span>
2221 }
2222 
2223 /**
2224  * g_nullify_pointer:
2225  * @nullify_location: (not nullable): the memory address of the pointer.
2226  *
2227  * Set the pointer at the specified location to %NULL.
2228  **/
2229 void
2230 g_nullify_pointer (gpointer *nullify_location)
2231 {
2232   g_return_if_fail (nullify_location != NULL);
2233 
2234   *nullify_location = NULL;
2235 }
2236 
2237 #define KILOBYTE_FACTOR (G_GOFFSET_CONSTANT (1000))
2238 #define MEGABYTE_FACTOR (KILOBYTE_FACTOR * KILOBYTE_FACTOR)
2239 #define GIGABYTE_FACTOR (MEGABYTE_FACTOR * KILOBYTE_FACTOR)
2240 #define TERABYTE_FACTOR (GIGABYTE_FACTOR * KILOBYTE_FACTOR)
2241 #define PETABYTE_FACTOR (TERABYTE_FACTOR * KILOBYTE_FACTOR)
2242 #define EXABYTE_FACTOR  (PETABYTE_FACTOR * KILOBYTE_FACTOR)
2243 
2244 #define KIBIBYTE_FACTOR (G_GOFFSET_CONSTANT (1024))
2245 #define MEBIBYTE_FACTOR (KIBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2246 #define GIBIBYTE_FACTOR (MEBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2247 #define TEBIBYTE_FACTOR (GIBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2248 #define PEBIBYTE_FACTOR (TEBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2249 #define EXBIBYTE_FACTOR (PEBIBYTE_FACTOR * KIBIBYTE_FACTOR)
2250 
2251 /**
2252  * g_format_size:
2253  * @size: a size in bytes
2254  *
2255  * Formats a size (for example the size of a file) into a human readable
2256  * string.  Sizes are rounded to the nearest size prefix (kB, MB, GB)
2257  * and are displayed rounded to the nearest tenth. E.g. the file size
<span class="line-modified">2258  * 3292528 bytes will be converted into the string &quot;3.2 MB&quot;. The returned string</span>
<span class="line-added">2259  * is UTF-8, and may use a non-breaking space to separate the number and units,</span>
<span class="line-added">2260  * to ensure they aren&#39;t separated when line wrapped.</span>
2261  *
2262  * The prefix units base is 1000 (i.e. 1 kB is 1000 bytes).
2263  *
2264  * This string should be freed with g_free() when not needed any longer.
2265  *
2266  * See g_format_size_full() for more options about how the size might be
2267  * formatted.
2268  *
2269  * Returns: a newly-allocated formatted string containing a human readable
2270  *     file size
2271  *
2272  * Since: 2.30
2273  */
2274 gchar *
2275 g_format_size (guint64 size)
2276 {
2277   return g_format_size_full (size, G_FORMAT_SIZE_DEFAULT);
2278 }
2279 
2280 /**
</pre>
<hr />
<pre>
2307  * @size: a size in bytes
2308  * @flags: #GFormatSizeFlags to modify the output
2309  *
2310  * Formats a size.
2311  *
2312  * This function is similar to g_format_size() but allows for flags
2313  * that modify the output. See #GFormatSizeFlags.
2314  *
2315  * Returns: a newly-allocated formatted string containing a human
2316  *     readable file size
2317  *
2318  * Since: 2.30
2319  */
2320 gchar *
2321 g_format_size_full (guint64          size,
2322                     GFormatSizeFlags flags)
2323 {
2324   struct Format
2325   {
2326     guint64 factor;
<span class="line-modified">2327     char string[10];</span>
2328   };
2329 
2330   typedef enum
2331   {
2332     FORMAT_BYTES,
2333     FORMAT_BYTES_IEC,
2334     FORMAT_BITS,
2335     FORMAT_BITS_IEC
2336   } FormatIndex;
2337 
2338   const struct Format formats[4][6] = {
2339     {
<span class="line-added">2340       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2341       { KILOBYTE_FACTOR, N_(&quot;%.1f kB&quot;) },
<span class="line-added">2342       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2343       { MEGABYTE_FACTOR, N_(&quot;%.1f MB&quot;) },
<span class="line-added">2344       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2345       { GIGABYTE_FACTOR, N_(&quot;%.1f GB&quot;) },
<span class="line-added">2346       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2347       { TERABYTE_FACTOR, N_(&quot;%.1f TB&quot;) },
<span class="line-added">2348       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2349       { PETABYTE_FACTOR, N_(&quot;%.1f PB&quot;) },
<span class="line-added">2350       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2351       { EXABYTE_FACTOR,  N_(&quot;%.1f EB&quot;) }
2352     },
<span class="line-modified">2353     {</span>
<span class="line-added">2354       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2355       { KIBIBYTE_FACTOR, N_(&quot;%.1f KiB&quot;) },
<span class="line-added">2356       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2357       { MEBIBYTE_FACTOR, N_(&quot;%.1f MiB&quot;) },
<span class="line-added">2358       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2359       { GIBIBYTE_FACTOR, N_(&quot;%.1f GiB&quot;) },
<span class="line-added">2360       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2361       { TEBIBYTE_FACTOR, N_(&quot;%.1f TiB&quot;) },
<span class="line-added">2362       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2363       { PEBIBYTE_FACTOR, N_(&quot;%.1f PiB&quot;) },
<span class="line-added">2364       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2365       { EXBIBYTE_FACTOR, N_(&quot;%.1f EiB&quot;) }
2366     },
2367     {
<span class="line-added">2368       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2369       { KILOBYTE_FACTOR, N_(&quot;%.1f kb&quot;) },
<span class="line-added">2370       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2371       { MEGABYTE_FACTOR, N_(&quot;%.1f Mb&quot;) },
<span class="line-added">2372       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2373       { GIGABYTE_FACTOR, N_(&quot;%.1f Gb&quot;) },
<span class="line-added">2374       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2375       { TERABYTE_FACTOR, N_(&quot;%.1f Tb&quot;) },
<span class="line-added">2376       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2377       { PETABYTE_FACTOR, N_(&quot;%.1f Pb&quot;) },
<span class="line-added">2378       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2379       { EXABYTE_FACTOR,  N_(&quot;%.1f Eb&quot;) }
2380     },
2381     {
<span class="line-added">2382       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2383       { KIBIBYTE_FACTOR, N_(&quot;%.1f Kib&quot;) },
<span class="line-added">2384       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2385       { MEBIBYTE_FACTOR, N_(&quot;%.1f Mib&quot;) },
<span class="line-added">2386       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2387       { GIBIBYTE_FACTOR, N_(&quot;%.1f Gib&quot;) },
<span class="line-added">2388       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2389       { TEBIBYTE_FACTOR, N_(&quot;%.1f Tib&quot;) },
<span class="line-added">2390       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2391       { PEBIBYTE_FACTOR, N_(&quot;%.1f Pib&quot;) },
<span class="line-added">2392       /* Translators: Keep the no-break space between %.1f and the unit symbol */</span>
2393       { EXBIBYTE_FACTOR, N_(&quot;%.1f Eib&quot;) }
<span class="line-modified">2394     }</span>
2395   };
2396 
2397   GString *string;
2398   FormatIndex index;
2399 
2400   string = g_string_new (NULL);
2401 
2402   switch (flags &amp; ~G_FORMAT_SIZE_LONG_FORMAT)
2403     {
2404     case G_FORMAT_SIZE_DEFAULT:
2405       index = FORMAT_BYTES;
2406       break;
2407     case (G_FORMAT_SIZE_DEFAULT | G_FORMAT_SIZE_IEC_UNITS):
2408       index = FORMAT_BYTES_IEC;
2409       break;
2410     case G_FORMAT_SIZE_BITS:
2411       index = FORMAT_BITS;
2412       break;
2413     case (G_FORMAT_SIZE_BITS | G_FORMAT_SIZE_IEC_UNITS):
2414       index = FORMAT_BITS_IEC;
2415       break;
2416     default:
2417       g_assert_not_reached ();
2418     }
2419 
2420 
2421   if (size &lt; formats[index][0].factor)
2422     {
2423       const char * format;
2424 
2425       if (index == FORMAT_BYTES || index == FORMAT_BYTES_IEC)
2426         {
2427           format = g_dngettext (GETTEXT_PACKAGE, &quot;%u byte&quot;, &quot;%u bytes&quot;, (guint) size);
<span class="line-modified">2428         }</span>
<span class="line-modified">2429       else</span>
<span class="line-modified">2430         {</span>
2431           format = g_dngettext (GETTEXT_PACKAGE, &quot;%u bit&quot;, &quot;%u bits&quot;, (guint) size);
2432         }
2433 
2434       g_string_printf (string, format, (guint) size);
2435 
2436       flags &amp;= ~G_FORMAT_SIZE_LONG_FORMAT;
2437     }
2438   else
2439     {
2440       const gsize n = G_N_ELEMENTS (formats[index]);
2441       gsize i;
2442 
2443       /*
2444        * Point the last format (the highest unit) by default
2445        * and then then scan all formats, starting with the 2nd one
2446        * because the 1st is already managed by with the plural form
2447        */
2448       const struct Format * f = &amp;formats[index][n - 1];
2449 
2450       for (i = 1; i &lt; n; i++)
</pre>
<hr />
<pre>
2477        * If the number is below that, then fine.  If it is above it,
2478        * then we take the modulus of the number by one thousand (in
2479        * order to keep the lowest digits) and add one thousand to that
2480        * (in order to ensure that 1001 is not treated the same as 1).
2481        */
2482       guint plural_form = size &lt; 1000 ? size : size % 1000 + 1000;
2483 
2484       /* Second problem: we need to translate the string &quot;%u byte/bit&quot; and
2485        * &quot;%u bytes/bits&quot; for pluralisation, but the correct number format to
2486        * use for a gsize is different depending on which architecture
2487        * we&#39;re on.
2488        *
2489        * Solution: format the number separately and use &quot;%s bytes/bits&quot; on
2490        * all platforms.
2491        */
2492       const gchar *translated_format;
2493       gchar *formatted_number;
2494 
2495       if (index == FORMAT_BYTES || index == FORMAT_BYTES_IEC)
2496         {
<span class="line-modified">2497           /* Translators: the %s in &quot;%s bytes&quot; will always be replaced by a number. */</span>
2498           translated_format = g_dngettext (GETTEXT_PACKAGE, &quot;%s byte&quot;, &quot;%s bytes&quot;, plural_form);
2499         }
2500       else
2501         {
2502           /* Translators: the %s in &quot;%s bits&quot; will always be replaced by a number. */
2503           translated_format = g_dngettext (GETTEXT_PACKAGE, &quot;%s bit&quot;, &quot;%s bits&quot;, plural_form);
2504         }






2505       formatted_number = g_strdup_printf (&quot;%&#39;&quot;G_GUINT64_FORMAT, size);



2506 
2507       g_string_append (string, &quot; (&quot;);
2508       g_string_append_printf (string, translated_format, formatted_number);
2509       g_free (formatted_number);
2510       g_string_append (string, &quot;)&quot;);
2511     }
2512 
2513   return g_string_free (string, FALSE);
2514 }
2515 
2516 #ifdef GSTREAMER_LITE
2517 #ifndef G_OS_WIN32
2518 #pragma GCC diagnostic pop
2519 #endif // G_OS_WIN32
2520 #else // GSTREAMER_LITE
2521 #pragma GCC diagnostic pop
2522 #endif // GSTREAMER_LITE
2523 
2524 /**
2525  * g_format_size_for_display:
</pre>
<hr />
<pre>
2603 gchar *
2604 g_find_program_in_path_utf8 (const gchar *program)
2605 {
2606   return g_find_program_in_path (program);
2607 }
2608 
2609 const gchar *g_get_user_name_utf8 (void) { return g_get_user_name (); }
2610 const gchar *g_get_real_name_utf8 (void) { return g_get_real_name (); }
2611 const gchar *g_get_home_dir_utf8 (void) { return g_get_home_dir (); }
2612 const gchar *g_get_tmp_dir_utf8 (void) { return g_get_tmp_dir (); }
2613 
2614 #endif
2615 
2616 /* Private API:
2617  *
2618  * Returns %TRUE if the current process was executed as setuid
2619  */
2620 gboolean
2621 g_check_setuid (void)
2622 {
<span class="line-modified">2623 #if defined(HAVE_SYS_AUXV_H) &amp;&amp; defined(HAVE_GETAUXVAL) &amp;&amp; defined(AT_SECURE)</span>
2624   unsigned long value;
2625   int errsv;
2626 
2627   errno = 0;
2628   value = getauxval (AT_SECURE);
2629   errsv = errno;
2630   if (errsv)
2631     g_error (&quot;getauxval () failed: %s&quot;, g_strerror (errsv));
2632   return value;
2633 #elif defined(HAVE_ISSETUGID) &amp;&amp; !defined(__BIONIC__)
2634   /* BSD: http://www.freebsd.org/cgi/man.cgi?query=issetugid&amp;sektion=2 */
2635 
2636   /* Android had it in older versions but the new 64 bit ABI does not
2637    * have it anymore, and some versions of the 32 bit ABI neither.
2638    * https://code.google.com/p/android-developer-preview/issues/detail?id=168
2639    */
2640   return issetugid ();
2641 #elif defined(G_OS_UNIX)
2642   uid_t ruid, euid, suid; /* Real, effective and saved user ID&#39;s */
2643   gid_t rgid, egid, sgid; /* Real, effective and saved group ID&#39;s */
</pre>
</td>
</tr>
</table>
<center><a href="gutf8.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gutils.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>