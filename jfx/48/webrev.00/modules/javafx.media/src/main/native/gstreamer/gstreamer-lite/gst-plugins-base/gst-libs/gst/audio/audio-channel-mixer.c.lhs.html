<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/audio-channel-mixer.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* GStreamer
  2  * Copyright (C) 2004 Ronald Bultje &lt;rbultje@ronald.bitfreak.net&gt;
  3  * Copyright (C) 2008 Sebastian Dr√∂ge &lt;slomo@circular-chaos.org&gt;
  4  *
  5  * audio-channel-mixer.c: setup of channel conversion matrices
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public
 18  * License along with this library; if not, write to the
 19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #ifdef HAVE_CONFIG_H
 24 #include &quot;config.h&quot;
 25 #endif
 26 
 27 #include &lt;math.h&gt;
 28 #include &lt;string.h&gt;
 29 
 30 #include &quot;audio-channel-mixer.h&quot;
 31 
 32 #ifndef GST_DISABLE_GST_DEBUG
 33 #define GST_CAT_DEFAULT ensure_debug_category()
 34 static GstDebugCategory *
 35 ensure_debug_category (void)
 36 {
 37   static gsize cat_gonce = 0;
 38 
 39   if (g_once_init_enter (&amp;cat_gonce)) {
 40     gsize cat_done;
 41 
 42     cat_done = (gsize) _gst_debug_category_new (&quot;audio-channel-mixer&quot;, 0,
 43         &quot;audio-channel-mixer object&quot;);
 44 
 45     g_once_init_leave (&amp;cat_gonce, cat_done);
 46   }
 47 
 48   return (GstDebugCategory *) cat_gonce;
 49 }
 50 #else
 51 #define ensure_debug_category() /* NOOP */
 52 #endif /* GST_DISABLE_GST_DEBUG */
 53 
 54 
 55 #define PRECISION_INT 10
 56 
<a name="1" id="anc1"></a><span class="line-modified"> 57 typedef void (*MixerFunc) (GstAudioChannelMixer * mix, const gpointer src,</span>
<span class="line-modified"> 58     gpointer dst, gint samples);</span>
 59 
 60 struct _GstAudioChannelMixer
 61 {
 62   gint in_channels;
 63   gint out_channels;
 64 
 65   /* channel conversion matrix, m[in_channels][out_channels].
 66    * If identity matrix, passthrough applies. */
 67   gfloat **matrix;
 68 
 69   /* channel conversion matrix with int values, m[in_channels][out_channels].
 70    * this is matrix * (2^10) as integers */
 71   gint **matrix_int;
 72 
 73   MixerFunc func;
 74 };
 75 
 76 /**
 77  * gst_audio_channel_mixer_free:
 78  * @mix: a #GstAudioChannelMixer
 79  *
 80  * Free memory allocated by @mix.
 81  */
 82 void
 83 gst_audio_channel_mixer_free (GstAudioChannelMixer * mix)
 84 {
 85   gint i;
 86 
 87   /* free */
 88   for (i = 0; i &lt; mix-&gt;in_channels; i++)
 89     g_free (mix-&gt;matrix[i]);
 90   g_free (mix-&gt;matrix);
 91   mix-&gt;matrix = NULL;
 92 
 93   for (i = 0; i &lt; mix-&gt;in_channels; i++)
 94     g_free (mix-&gt;matrix_int[i]);
 95   g_free (mix-&gt;matrix_int);
 96   mix-&gt;matrix_int = NULL;
 97 
 98   g_slice_free (GstAudioChannelMixer, mix);
 99 }
100 
101 /*
102  * Detect and fill in identical channels. E.g.
103  * forward the left/right front channels in a
104  * 5.1 to 2.0 conversion.
105  */
106 
107 static void
108 gst_audio_channel_mixer_fill_identical (gfloat ** matrix,
109     gint in_channels, GstAudioChannelPosition * in_position, gint out_channels,
110     GstAudioChannelPosition * out_position, GstAudioChannelMixerFlags flags)
111 {
112   gint ci, co;
113 
114   /* Apart from the compatible channel assignments, we can also have
115    * same channel assignments. This is much simpler, we simply copy
116    * the value from source to dest! */
117   for (co = 0; co &lt; out_channels; co++) {
118     /* find a channel in input with same position */
119     for (ci = 0; ci &lt; in_channels; ci++) {
120       /* If the input was unpositioned, we&#39;re simply building
121        * an identity matrix */
122       if (flags &amp; GST_AUDIO_CHANNEL_MIXER_FLAGS_UNPOSITIONED_IN) {
123         matrix[ci][co] = ci == co ? 1.0 : 0.0;
124       } else if (in_position[ci] == out_position[co]) {
125         matrix[ci][co] = 1.0;
126       }
127     }
128   }
129 }
130 
131 /*
132  * Detect and fill in compatible channels. E.g.
133  * forward left/right front to mono (or the other
134  * way around) when going from 2.0 to 1.0.
135  */
136 
137 static void
138 gst_audio_channel_mixer_fill_compatible (gfloat ** matrix, gint in_channels,
139     GstAudioChannelPosition * in_position, gint out_channels,
140     GstAudioChannelPosition * out_position)
141 {
142   /* Conversions from one-channel to compatible two-channel configs */
143   struct
144   {
145     GstAudioChannelPosition pos1[2];
146     GstAudioChannelPosition pos2[1];
147   } conv[] = {
148     /* front: mono &lt;-&gt; stereo */
149     { {
150     GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,
151             GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT}, {
152     GST_AUDIO_CHANNEL_POSITION_MONO}},
153         /* front center: 2 &lt;-&gt; 1 */
154     { {
155     GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,
156             GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER}, {
157     GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER}},
158         /* rear: 2 &lt;-&gt; 1 */
159     { {
160     GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,
161             GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT}, {
162     GST_AUDIO_CHANNEL_POSITION_REAR_CENTER}}, { {
163     GST_AUDIO_CHANNEL_POSITION_INVALID}}
164   };
165   gint c;
166 
167   /* conversions from compatible (but not the same) channel schemes */
168   for (c = 0; conv[c].pos1[0] != GST_AUDIO_CHANNEL_POSITION_INVALID; c++) {
169     gint pos1_0 = -1, pos1_1 = -1, pos1_2 = -1;
170     gint pos2_0 = -1, pos2_1 = -1, pos2_2 = -1;
171     gint n;
172 
173     for (n = 0; n &lt; in_channels; n++) {
174       if (in_position[n] == conv[c].pos1[0])
175         pos1_0 = n;
176       else if (in_position[n] == conv[c].pos1[1])
177         pos1_1 = n;
178       else if (in_position[n] == conv[c].pos2[0])
179         pos1_2 = n;
180     }
181     for (n = 0; n &lt; out_channels; n++) {
182       if (out_position[n] == conv[c].pos1[0])
183         pos2_0 = n;
184       else if (out_position[n] == conv[c].pos1[1])
185         pos2_1 = n;
186       else if (out_position[n] == conv[c].pos2[0])
187         pos2_2 = n;
188     }
189 
190     /* The general idea here is to fill in channels from the same position
191      * as good as possible. This means mixing left&lt;-&gt;center and right&lt;-&gt;center.
192      */
193 
194     /* left -&gt; center */
195     if (pos1_0 != -1 &amp;&amp; pos1_2 == -1 &amp;&amp; pos2_0 == -1 &amp;&amp; pos2_2 != -1)
196       matrix[pos1_0][pos2_2] = 1.0;
197     else if (pos1_0 != -1 &amp;&amp; pos1_2 != -1 &amp;&amp; pos2_0 == -1 &amp;&amp; pos2_2 != -1)
198       matrix[pos1_0][pos2_2] = 0.5;
199     else if (pos1_0 != -1 &amp;&amp; pos1_2 == -1 &amp;&amp; pos2_0 != -1 &amp;&amp; pos2_2 != -1)
200       matrix[pos1_0][pos2_2] = 1.0;
201 
202     /* right -&gt; center */
203     if (pos1_1 != -1 &amp;&amp; pos1_2 == -1 &amp;&amp; pos2_1 == -1 &amp;&amp; pos2_2 != -1)
204       matrix[pos1_1][pos2_2] = 1.0;
205     else if (pos1_1 != -1 &amp;&amp; pos1_2 != -1 &amp;&amp; pos2_1 == -1 &amp;&amp; pos2_2 != -1)
206       matrix[pos1_1][pos2_2] = 0.5;
207     else if (pos1_1 != -1 &amp;&amp; pos1_2 == -1 &amp;&amp; pos2_1 != -1 &amp;&amp; pos2_2 != -1)
208       matrix[pos1_1][pos2_2] = 1.0;
209 
210     /* center -&gt; left */
211     if (pos1_2 != -1 &amp;&amp; pos1_0 == -1 &amp;&amp; pos2_2 == -1 &amp;&amp; pos2_0 != -1)
212       matrix[pos1_2][pos2_0] = 1.0;
213     else if (pos1_2 != -1 &amp;&amp; pos1_0 != -1 &amp;&amp; pos2_2 == -1 &amp;&amp; pos2_0 != -1)
214       matrix[pos1_2][pos2_0] = 0.5;
215     else if (pos1_2 != -1 &amp;&amp; pos1_0 == -1 &amp;&amp; pos2_2 != -1 &amp;&amp; pos2_0 != -1)
216       matrix[pos1_2][pos2_0] = 1.0;
217 
218     /* center -&gt; right */
219     if (pos1_2 != -1 &amp;&amp; pos1_1 == -1 &amp;&amp; pos2_2 == -1 &amp;&amp; pos2_1 != -1)
220       matrix[pos1_2][pos2_1] = 1.0;
221     else if (pos1_2 != -1 &amp;&amp; pos1_1 != -1 &amp;&amp; pos2_2 == -1 &amp;&amp; pos2_1 != -1)
222       matrix[pos1_2][pos2_1] = 0.5;
223     else if (pos1_2 != -1 &amp;&amp; pos1_1 == -1 &amp;&amp; pos2_2 != -1 &amp;&amp; pos2_1 != -1)
224       matrix[pos1_2][pos2_1] = 1.0;
225   }
226 }
227 
228 /*
229  * Detect and fill in channels not handled by the
230  * above two, e.g. center to left/right front in
231  * 5.1 to 2.0 (or the other way around).
232  *
233  * Unfortunately, limited to static conversions
234  * for now.
235  */
236 
237 static void
238 gst_audio_channel_mixer_detect_pos (gint channels,
239     GstAudioChannelPosition position[64], gint * f, gboolean * has_f, gint * c,
240     gboolean * has_c, gint * r, gboolean * has_r, gint * s, gboolean * has_s,
241     gint * b, gboolean * has_b)
242 {
243   gint n;
244 
245   for (n = 0; n &lt; channels; n++) {
246     switch (position[n]) {
247       case GST_AUDIO_CHANNEL_POSITION_MONO:
248         f[1] = n;
249         *has_f = TRUE;
250         break;
251       case GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT:
252         f[0] = n;
253         *has_f = TRUE;
254         break;
255       case GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT:
256         f[2] = n;
257         *has_f = TRUE;
258         break;
259       case GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER:
260         c[1] = n;
261         *has_c = TRUE;
262         break;
263       case GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER:
264         c[0] = n;
265         *has_c = TRUE;
266         break;
267       case GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER:
268         c[2] = n;
269         *has_c = TRUE;
270         break;
271       case GST_AUDIO_CHANNEL_POSITION_REAR_CENTER:
272         r[1] = n;
273         *has_r = TRUE;
274         break;
275       case GST_AUDIO_CHANNEL_POSITION_REAR_LEFT:
276         r[0] = n;
277         *has_r = TRUE;
278         break;
279       case GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT:
280         r[2] = n;
281         *has_r = TRUE;
282         break;
283       case GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT:
284         s[0] = n;
285         *has_s = TRUE;
286         break;
287       case GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT:
288         s[2] = n;
289         *has_s = TRUE;
290         break;
291       case GST_AUDIO_CHANNEL_POSITION_LFE1:
292         *has_b = TRUE;
293         b[1] = n;
294         break;
295       default:
296         break;
297     }
298   }
299 }
300 
301 static void
302 gst_audio_channel_mixer_fill_one_other (gfloat ** matrix,
303     gint * from_idx, gint * to_idx, gfloat ratio)
304 {
305 
306   /* src &amp; dst have center =&gt; passthrough */
307   if (from_idx[1] != -1 &amp;&amp; to_idx[1] != -1) {
308     matrix[from_idx[1]][to_idx[1]] = ratio;
309   }
310 
311   /* src &amp; dst have left =&gt; passthrough */
312   if (from_idx[0] != -1 &amp;&amp; to_idx[0] != -1) {
313     matrix[from_idx[0]][to_idx[0]] = ratio;
314   }
315 
316   /* src &amp; dst have right =&gt; passthrough */
317   if (from_idx[2] != -1 &amp;&amp; to_idx[2] != -1) {
318     matrix[from_idx[2]][to_idx[2]] = ratio;
319   }
320 
321   /* src has left &amp; dst has center =&gt; put into center */
322   if (from_idx[0] != -1 &amp;&amp; to_idx[1] != -1 &amp;&amp; from_idx[1] != -1) {
323     matrix[from_idx[0]][to_idx[1]] = 0.5 * ratio;
324   } else if (from_idx[0] != -1 &amp;&amp; to_idx[1] != -1 &amp;&amp; from_idx[1] == -1) {
325     matrix[from_idx[0]][to_idx[1]] = ratio;
326   }
327 
328   /* src has right &amp; dst has center =&gt; put into center */
329   if (from_idx[2] != -1 &amp;&amp; to_idx[1] != -1 &amp;&amp; from_idx[1] != -1) {
330     matrix[from_idx[2]][to_idx[1]] = 0.5 * ratio;
331   } else if (from_idx[2] != -1 &amp;&amp; to_idx[1] != -1 &amp;&amp; from_idx[1] == -1) {
332     matrix[from_idx[2]][to_idx[1]] = ratio;
333   }
334 
335   /* src has center &amp; dst has left =&gt; passthrough */
336   if (from_idx[1] != -1 &amp;&amp; to_idx[0] != -1 &amp;&amp; from_idx[0] != -1) {
337     matrix[from_idx[1]][to_idx[0]] = 0.5 * ratio;
338   } else if (from_idx[1] != -1 &amp;&amp; to_idx[0] != -1 &amp;&amp; from_idx[0] == -1) {
339     matrix[from_idx[1]][to_idx[0]] = ratio;
340   }
341 
342   /* src has center &amp; dst has right =&gt; passthrough */
343   if (from_idx[1] != -1 &amp;&amp; to_idx[2] != -1 &amp;&amp; from_idx[2] != -1) {
344     matrix[from_idx[1]][to_idx[2]] = 0.5 * ratio;
345   } else if (from_idx[1] != -1 &amp;&amp; to_idx[2] != -1 &amp;&amp; from_idx[2] == -1) {
346     matrix[from_idx[1]][to_idx[2]] = ratio;
347   }
348 }
349 
350 #define RATIO_CENTER_FRONT (1.0 / sqrt (2.0))
351 #define RATIO_CENTER_SIDE (1.0 / 2.0)
352 #define RATIO_CENTER_REAR (1.0 / sqrt (8.0))
353 
354 #define RATIO_FRONT_CENTER (1.0 / sqrt (2.0))
355 #define RATIO_FRONT_SIDE (1.0 / sqrt (2.0))
356 #define RATIO_FRONT_REAR (1.0 / 2.0)
357 
358 #define RATIO_SIDE_CENTER (1.0 / 2.0)
359 #define RATIO_SIDE_FRONT (1.0 / sqrt (2.0))
360 #define RATIO_SIDE_REAR (1.0 / sqrt (2.0))
361 
362 #define RATIO_CENTER_BASS (1.0 / sqrt (2.0))
363 #define RATIO_FRONT_BASS (1.0)
364 #define RATIO_SIDE_BASS (1.0 / sqrt (2.0))
365 #define RATIO_REAR_BASS (1.0 / sqrt (2.0))
366 
367 static void
368 gst_audio_channel_mixer_fill_others (gfloat ** matrix, gint in_channels,
369     GstAudioChannelPosition * in_position, gint out_channels,
370     GstAudioChannelPosition * out_position)
371 {
372   gboolean in_has_front = FALSE, out_has_front = FALSE,
373       in_has_center = FALSE, out_has_center = FALSE,
374       in_has_rear = FALSE, out_has_rear = FALSE,
375       in_has_side = FALSE, out_has_side = FALSE,
376       in_has_bass = FALSE, out_has_bass = FALSE;
377   /* LEFT, RIGHT, MONO */
378   gint in_f[3] = { -1, -1, -1 };
379   gint out_f[3] = { -1, -1, -1 };
380   /* LOC, ROC, CENTER */
381   gint in_c[3] = { -1, -1, -1 };
382   gint out_c[3] = { -1, -1, -1 };
383   /* RLEFT, RRIGHT, RCENTER */
384   gint in_r[3] = { -1, -1, -1 };
385   gint out_r[3] = { -1, -1, -1 };
386   /* SLEFT, INVALID, SRIGHT */
387   gint in_s[3] = { -1, -1, -1 };
388   gint out_s[3] = { -1, -1, -1 };
389   /* INVALID, LFE, INVALID */
390   gint in_b[3] = { -1, -1, -1 };
391   gint out_b[3] = { -1, -1, -1 };
392 
393   /* First see where (if at all) the various channels from/to
394    * which we want to convert are located in our matrix/array. */
395   gst_audio_channel_mixer_detect_pos (in_channels, in_position,
396       in_f, &amp;in_has_front,
397       in_c, &amp;in_has_center, in_r, &amp;in_has_rear,
398       in_s, &amp;in_has_side, in_b, &amp;in_has_bass);
399   gst_audio_channel_mixer_detect_pos (out_channels, out_position,
400       out_f, &amp;out_has_front,
401       out_c, &amp;out_has_center, out_r, &amp;out_has_rear,
402       out_s, &amp;out_has_side, out_b, &amp;out_has_bass);
403 
404   /* The general idea here is:
405    * - if the source has a channel that the destination doesn&#39;t have mix
406    *   it into the nearest available destination channel
407    * - if the destination has a channel that the source doesn&#39;t have mix
408    *   the nearest source channel into the destination channel
409    *
410    * The ratio for the mixing becomes lower as the distance between the
411    * channels gets larger
412    */
413 
414   /* center &lt;-&gt; front/side/rear */
415   if (!in_has_center &amp;&amp; in_has_front &amp;&amp; out_has_center) {
416     gst_audio_channel_mixer_fill_one_other (matrix, in_f, out_c,
417         RATIO_CENTER_FRONT);
418   } else if (!in_has_center &amp;&amp; !in_has_front &amp;&amp; in_has_side &amp;&amp; out_has_center) {
419     gst_audio_channel_mixer_fill_one_other (matrix, in_s, out_c,
420         RATIO_CENTER_SIDE);
421   } else if (!in_has_center &amp;&amp; !in_has_front &amp;&amp; !in_has_side &amp;&amp; in_has_rear
422       &amp;&amp; out_has_center) {
423     gst_audio_channel_mixer_fill_one_other (matrix, in_r, out_c,
424         RATIO_CENTER_REAR);
425   } else if (in_has_center &amp;&amp; !out_has_center &amp;&amp; out_has_front) {
426     gst_audio_channel_mixer_fill_one_other (matrix, in_c, out_f,
427         RATIO_CENTER_FRONT);
428   } else if (in_has_center &amp;&amp; !out_has_center &amp;&amp; !out_has_front &amp;&amp; out_has_side) {
429     gst_audio_channel_mixer_fill_one_other (matrix, in_c, out_s,
430         RATIO_CENTER_SIDE);
431   } else if (in_has_center &amp;&amp; !out_has_center &amp;&amp; !out_has_front &amp;&amp; !out_has_side
432       &amp;&amp; out_has_rear) {
433     gst_audio_channel_mixer_fill_one_other (matrix, in_c, out_r,
434         RATIO_CENTER_REAR);
435   }
436 
437   /* front &lt;-&gt; center/side/rear */
438   if (!in_has_front &amp;&amp; in_has_center &amp;&amp; !in_has_side &amp;&amp; out_has_front) {
439     gst_audio_channel_mixer_fill_one_other (matrix, in_c, out_f,
440         RATIO_CENTER_FRONT);
441   } else if (!in_has_front &amp;&amp; !in_has_center &amp;&amp; in_has_side &amp;&amp; out_has_front) {
442     gst_audio_channel_mixer_fill_one_other (matrix, in_s, out_f,
443         RATIO_FRONT_SIDE);
444   } else if (!in_has_front &amp;&amp; in_has_center &amp;&amp; in_has_side &amp;&amp; out_has_front) {
445     gst_audio_channel_mixer_fill_one_other (matrix, in_c, out_f,
446         0.5 * RATIO_CENTER_FRONT);
447     gst_audio_channel_mixer_fill_one_other (matrix, in_s, out_f,
448         0.5 * RATIO_FRONT_SIDE);
449   } else if (!in_has_front &amp;&amp; !in_has_center &amp;&amp; !in_has_side &amp;&amp; in_has_rear
450       &amp;&amp; out_has_front) {
451     gst_audio_channel_mixer_fill_one_other (matrix, in_r, out_f,
452         RATIO_FRONT_REAR);
453   } else if (in_has_front &amp;&amp; out_has_center &amp;&amp; !out_has_side &amp;&amp; !out_has_front) {
454     gst_audio_channel_mixer_fill_one_other (matrix,
455         in_f, out_c, RATIO_CENTER_FRONT);
456   } else if (in_has_front &amp;&amp; !out_has_center &amp;&amp; out_has_side &amp;&amp; !out_has_front) {
457     gst_audio_channel_mixer_fill_one_other (matrix, in_f, out_s,
458         RATIO_FRONT_SIDE);
459   } else if (in_has_front &amp;&amp; out_has_center &amp;&amp; out_has_side &amp;&amp; !out_has_front) {
460     gst_audio_channel_mixer_fill_one_other (matrix, in_f, out_c,
461         0.5 * RATIO_CENTER_FRONT);
462     gst_audio_channel_mixer_fill_one_other (matrix, in_f, out_s,
463         0.5 * RATIO_FRONT_SIDE);
464   } else if (in_has_front &amp;&amp; !out_has_center &amp;&amp; !out_has_side &amp;&amp; !out_has_front
465       &amp;&amp; out_has_rear) {
466     gst_audio_channel_mixer_fill_one_other (matrix, in_f, out_r,
467         RATIO_FRONT_REAR);
468   }
469 
470   /* side &lt;-&gt; center/front/rear */
471   if (!in_has_side &amp;&amp; in_has_front &amp;&amp; !in_has_rear &amp;&amp; out_has_side) {
472     gst_audio_channel_mixer_fill_one_other (matrix, in_f, out_s,
473         RATIO_FRONT_SIDE);
474   } else if (!in_has_side &amp;&amp; !in_has_front &amp;&amp; in_has_rear &amp;&amp; out_has_side) {
475     gst_audio_channel_mixer_fill_one_other (matrix, in_r, out_s,
476         RATIO_SIDE_REAR);
477   } else if (!in_has_side &amp;&amp; in_has_front &amp;&amp; in_has_rear &amp;&amp; out_has_side) {
478     gst_audio_channel_mixer_fill_one_other (matrix, in_f, out_s,
479         0.5 * RATIO_FRONT_SIDE);
480     gst_audio_channel_mixer_fill_one_other (matrix, in_r, out_s,
481         0.5 * RATIO_SIDE_REAR);
482   } else if (!in_has_side &amp;&amp; !in_has_front &amp;&amp; !in_has_rear &amp;&amp; in_has_center
483       &amp;&amp; out_has_side) {
484     gst_audio_channel_mixer_fill_one_other (matrix, in_c, out_s,
485         RATIO_CENTER_SIDE);
486   } else if (in_has_side &amp;&amp; out_has_front &amp;&amp; !out_has_rear &amp;&amp; !out_has_side) {
487     gst_audio_channel_mixer_fill_one_other (matrix, in_s, out_f,
488         RATIO_FRONT_SIDE);
489   } else if (in_has_side &amp;&amp; !out_has_front &amp;&amp; out_has_rear &amp;&amp; !out_has_side) {
490     gst_audio_channel_mixer_fill_one_other (matrix, in_s, out_r,
491         RATIO_SIDE_REAR);
492   } else if (in_has_side &amp;&amp; out_has_front &amp;&amp; out_has_rear &amp;&amp; !out_has_side) {
493     gst_audio_channel_mixer_fill_one_other (matrix, in_s, out_f,
494         0.5 * RATIO_FRONT_SIDE);
495     gst_audio_channel_mixer_fill_one_other (matrix, in_s, out_r,
496         0.5 * RATIO_SIDE_REAR);
497   } else if (in_has_side &amp;&amp; !out_has_front &amp;&amp; !out_has_rear &amp;&amp; out_has_center
498       &amp;&amp; !out_has_side) {
499     gst_audio_channel_mixer_fill_one_other (matrix, in_s, out_c,
500         RATIO_CENTER_SIDE);
501   }
502 
503   /* rear &lt;-&gt; center/front/side */
504   if (!in_has_rear &amp;&amp; in_has_side &amp;&amp; out_has_rear) {
505     gst_audio_channel_mixer_fill_one_other (matrix, in_s, out_r,
506         RATIO_SIDE_REAR);
507   } else if (!in_has_rear &amp;&amp; !in_has_side &amp;&amp; in_has_front &amp;&amp; out_has_rear) {
508     gst_audio_channel_mixer_fill_one_other (matrix, in_f, out_r,
509         RATIO_FRONT_REAR);
510   } else if (!in_has_rear &amp;&amp; !in_has_side &amp;&amp; !in_has_front &amp;&amp; in_has_center
511       &amp;&amp; out_has_rear) {
512     gst_audio_channel_mixer_fill_one_other (matrix, in_c, out_r,
513         RATIO_CENTER_REAR);
514   } else if (in_has_rear &amp;&amp; !out_has_rear &amp;&amp; out_has_side) {
515     gst_audio_channel_mixer_fill_one_other (matrix, in_r, out_s,
516         RATIO_SIDE_REAR);
517   } else if (in_has_rear &amp;&amp; !out_has_rear &amp;&amp; !out_has_side &amp;&amp; out_has_front) {
518     gst_audio_channel_mixer_fill_one_other (matrix, in_r, out_f,
519         RATIO_FRONT_REAR);
520   } else if (in_has_rear &amp;&amp; !out_has_rear &amp;&amp; !out_has_side &amp;&amp; !out_has_front
521       &amp;&amp; out_has_center) {
522     gst_audio_channel_mixer_fill_one_other (matrix, in_r, out_c,
523         RATIO_CENTER_REAR);
524   }
525 
526   /* bass &lt;-&gt; any */
527   if (in_has_bass &amp;&amp; !out_has_bass) {
528     if (out_has_center) {
529       gst_audio_channel_mixer_fill_one_other (matrix, in_b, out_c,
530           RATIO_CENTER_BASS);
531     }
532     if (out_has_front) {
533       gst_audio_channel_mixer_fill_one_other (matrix, in_b, out_f,
534           RATIO_FRONT_BASS);
535     }
536     if (out_has_side) {
537       gst_audio_channel_mixer_fill_one_other (matrix, in_b, out_s,
538           RATIO_SIDE_BASS);
539     }
540     if (out_has_rear) {
541       gst_audio_channel_mixer_fill_one_other (matrix, in_b, out_r,
542           RATIO_REAR_BASS);
543     }
544   } else if (!in_has_bass &amp;&amp; out_has_bass) {
545     if (in_has_center) {
546       gst_audio_channel_mixer_fill_one_other (matrix, in_c, out_b,
547           RATIO_CENTER_BASS);
548     }
549     if (in_has_front) {
550       gst_audio_channel_mixer_fill_one_other (matrix, in_f, out_b,
551           RATIO_FRONT_BASS);
552     }
553     if (in_has_side) {
554       gst_audio_channel_mixer_fill_one_other (matrix, in_s, out_b,
555           RATIO_REAR_BASS);
556     }
557     if (in_has_rear) {
558       gst_audio_channel_mixer_fill_one_other (matrix, in_r, out_b,
559           RATIO_REAR_BASS);
560     }
561   }
562 }
563 
564 /*
565  * Normalize output values.
566  */
567 
568 static void
569 gst_audio_channel_mixer_fill_normalize (gfloat ** matrix, gint in_channels,
570     gint out_channels)
571 {
572   gfloat sum, top = 0;
573   gint i, j;
574 
575   for (j = 0; j &lt; out_channels; j++) {
576     /* calculate sum */
577     sum = 0.0;
578     for (i = 0; i &lt; in_channels; i++) {
579       sum += fabs (matrix[i][j]);
580     }
581     if (sum &gt; top) {
582       top = sum;
583     }
584   }
585 
586   /* normalize to mix */
587   if (top == 0.0)
588     return;
589 
590   for (j = 0; j &lt; out_channels; j++) {
591     for (i = 0; i &lt; in_channels; i++) {
592       matrix[i][j] /= top;
593     }
594   }
595 }
596 
597 static gboolean
598 gst_audio_channel_mixer_fill_special (gfloat ** matrix, gint in_channels,
599     GstAudioChannelPosition * in_position, gint out_channels,
600     GstAudioChannelPosition * out_position)
601 {
602   /* Special, standard conversions here */
603 
604   /* Mono&lt;-&gt;Stereo, just a fast-path */
605   if (in_channels == 2 &amp;&amp; out_channels == 1 &amp;&amp;
606       ((in_position[0] == GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT &amp;&amp;
607               in_position[1] == GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT) ||
608           (in_position[0] == GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT &amp;&amp;
609               in_position[1] == GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT)) &amp;&amp;
610       out_position[0] == GST_AUDIO_CHANNEL_POSITION_MONO) {
611     matrix[0][0] = 0.5;
612     matrix[1][0] = 0.5;
613     return TRUE;
614   } else if (in_channels == 1 &amp;&amp; out_channels == 2 &amp;&amp;
615       ((out_position[0] == GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT &amp;&amp;
616               out_position[1] == GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT) ||
617           (out_position[0] == GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT &amp;&amp;
618               out_position[1] == GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT)) &amp;&amp;
619       in_position[0] == GST_AUDIO_CHANNEL_POSITION_MONO) {
620     matrix[0][0] = 1.0;
621     matrix[0][1] = 1.0;
622     return TRUE;
623   }
624 
625   /* TODO: 5.1 &lt;-&gt; Stereo and other standard conversions */
626 
627   return FALSE;
628 }
629 
630 /*
631  * Automagically generate conversion matrix.
632  */
633 
634 static void
635 gst_audio_channel_mixer_fill_matrix (gfloat ** matrix,
636     GstAudioChannelMixerFlags flags, gint in_channels,
637     GstAudioChannelPosition * in_position, gint out_channels,
638     GstAudioChannelPosition * out_position)
639 {
640   if (gst_audio_channel_mixer_fill_special (matrix, in_channels, in_position,
641           out_channels, out_position))
642     return;
643 
644   gst_audio_channel_mixer_fill_identical (matrix, in_channels, in_position,
645       out_channels, out_position, flags);
646 
647   if (!(flags &amp; GST_AUDIO_CHANNEL_MIXER_FLAGS_UNPOSITIONED_IN)) {
648     gst_audio_channel_mixer_fill_compatible (matrix, in_channels, in_position,
649         out_channels, out_position);
650     gst_audio_channel_mixer_fill_others (matrix, in_channels, in_position,
651         out_channels, out_position);
652     gst_audio_channel_mixer_fill_normalize (matrix, in_channels, out_channels);
653   }
654 }
655 
656 /* only call mix after mix-&gt;matrix is fully set up and normalized */
657 static void
658 gst_audio_channel_mixer_setup_matrix_int (GstAudioChannelMixer * mix)
659 {
660   gint i, j;
661   gfloat tmp;
662   gfloat factor = (1 &lt;&lt; PRECISION_INT);
663 
664   mix-&gt;matrix_int = g_new0 (gint *, mix-&gt;in_channels);
665 
666   for (i = 0; i &lt; mix-&gt;in_channels; i++) {
667     mix-&gt;matrix_int[i] = g_new (gint, mix-&gt;out_channels);
668 
669     for (j = 0; j &lt; mix-&gt;out_channels; j++) {
670       tmp = mix-&gt;matrix[i][j] * factor;
671       mix-&gt;matrix_int[i][j] = (gint) tmp;
672     }
673   }
674 }
675 
676 static gfloat **
677 gst_audio_channel_mixer_setup_matrix (GstAudioChannelMixerFlags flags,
678     gint in_channels, GstAudioChannelPosition * in_position,
679     gint out_channels, GstAudioChannelPosition * out_position)
680 {
681   gint i, j;
682   gfloat **matrix = g_new0 (gfloat *, in_channels);
683 
684   for (i = 0; i &lt; in_channels; i++) {
685     matrix[i] = g_new (gfloat, out_channels);
686     for (j = 0; j &lt; out_channels; j++)
687       matrix[i][j] = 0.;
688   }
689 
690   /* setup the matrix&#39; internal values */
691   gst_audio_channel_mixer_fill_matrix (matrix, flags, in_channels, in_position,
692       out_channels, out_position);
693 
694   return matrix;
695 }
696 
<a name="2" id="anc2"></a><span class="line-modified">697 static void</span>
<span class="line-modified">698 gst_audio_channel_mixer_mix_int16 (GstAudioChannelMixer * mix,</span>
<span class="line-modified">699     const gint16 * in_data, gint16 * out_data, gint samples)</span>
<span class="line-modified">700 {</span>
<span class="line-modified">701   gint in, out, n;</span>
<span class="line-modified">702   gint32 res;</span>
<span class="line-modified">703   gint inchannels, outchannels;</span>
<span class="line-modified">704 </span>
<span class="line-modified">705   inchannels = mix-&gt;in_channels;</span>
<span class="line-modified">706   outchannels = mix-&gt;out_channels;</span>
<span class="line-modified">707 </span>
<span class="line-modified">708   for (n = 0; n &lt; samples; n++) {</span>
<span class="line-modified">709     for (out = 0; out &lt; outchannels; out++) {</span>
<span class="line-modified">710       /* convert */</span>
<span class="line-modified">711       res = 0;</span>
<span class="line-modified">712       for (in = 0; in &lt; inchannels; in++)</span>
<span class="line-modified">713         res += in_data[n * inchannels + in] * mix-&gt;matrix_int[in][out];</span>
<span class="line-modified">714 </span>
<span class="line-modified">715       /* remove factor from int matrix */</span>
<span class="line-modified">716       res = (res + (1 &lt;&lt; (PRECISION_INT - 1))) &gt;&gt; PRECISION_INT;</span>
<span class="line-modified">717       out_data[n * outchannels + out] = CLAMP (res, G_MININT16, G_MAXINT16);</span>
<span class="line-modified">718     }</span>
<span class="line-modified">719   }</span>






720 }
721 
<a name="3" id="anc3"></a><span class="line-modified">722 static void</span>
<span class="line-modified">723 gst_audio_channel_mixer_mix_int32 (GstAudioChannelMixer * mix,</span>
<span class="line-modified">724     const gint32 * in_data, gint32 * out_data, gint samples)</span>
<span class="line-modified">725 {</span>
<span class="line-modified">726   gint in, out, n;</span>
<span class="line-modified">727   gint64 res;</span>
<span class="line-modified">728   gint inchannels, outchannels;</span>
<span class="line-modified">729 </span>
<span class="line-modified">730   inchannels = mix-&gt;in_channels;</span>
<span class="line-modified">731   outchannels = mix-&gt;out_channels;</span>
<span class="line-modified">732 </span>
<span class="line-modified">733   for (n = 0; n &lt; samples; n++) {</span>
<span class="line-modified">734     for (out = 0; out &lt; outchannels; out++) {</span>
<span class="line-modified">735       /* convert */</span>
<span class="line-modified">736       res = 0;</span>
<span class="line-modified">737       for (in = 0; in &lt; inchannels; in++)</span>
<span class="line-modified">738         res += in_data[n * inchannels + in] * (gint64) mix-&gt;matrix_int[in][out];</span>
<span class="line-modified">739 </span>
<span class="line-modified">740       /* remove factor from int matrix */</span>
<span class="line-modified">741       res = (res + (1 &lt;&lt; (PRECISION_INT - 1))) &gt;&gt; PRECISION_INT;</span>
<span class="line-modified">742       out_data[n * outchannels + out] = CLAMP (res, G_MININT32, G_MAXINT32);</span>
<span class="line-modified">743     }</span>
<span class="line-modified">744   }</span>





745 }
746 
<a name="4" id="anc4"></a><span class="line-modified">747 static void</span>
<span class="line-modified">748 gst_audio_channel_mixer_mix_float (GstAudioChannelMixer * mix,</span>
<span class="line-modified">749     const gfloat * in_data, gfloat * out_data, gint samples)</span>
<span class="line-modified">750 {</span>
<span class="line-modified">751   gint in, out, n;</span>
<span class="line-modified">752   gfloat res;</span>
<span class="line-modified">753   gint inchannels, outchannels;</span>
<span class="line-modified">754 </span>
<span class="line-modified">755   inchannels = mix-&gt;in_channels;</span>
<span class="line-modified">756   outchannels = mix-&gt;out_channels;</span>
<span class="line-modified">757 </span>
<span class="line-modified">758   for (n = 0; n &lt; samples; n++) {</span>
<span class="line-modified">759     for (out = 0; out &lt; outchannels; out++) {</span>
<span class="line-modified">760       /* convert */</span>
<span class="line-modified">761       res = 0.0;</span>
<span class="line-modified">762       for (in = 0; in &lt; inchannels; in++)</span>
<span class="line-modified">763         res += in_data[n * inchannels + in] * mix-&gt;matrix[in][out];</span>
<span class="line-modified">764 </span>
<span class="line-modified">765       out_data[n * outchannels + out] = res;</span>
<span class="line-modified">766     }</span>
<span class="line-modified">767   }</span>




768 }
769 
<a name="5" id="anc5"></a><span class="line-modified">770 static void</span>
<span class="line-modified">771 gst_audio_channel_mixer_mix_double (GstAudioChannelMixer * mix,</span>
<span class="line-modified">772     const gdouble * in_data, gdouble * out_data, gint samples)</span>
<span class="line-modified">773 {</span>
<span class="line-modified">774   gint in, out, n;</span>
<span class="line-modified">775   gdouble res;</span>
<span class="line-modified">776   gint inchannels, outchannels;</span>
<span class="line-modified">777 </span>
<span class="line-modified">778   inchannels = mix-&gt;in_channels;</span>
<span class="line-modified">779   outchannels = mix-&gt;out_channels;</span>
<span class="line-modified">780 </span>
<span class="line-modified">781   for (n = 0; n &lt; samples; n++) {</span>
<span class="line-modified">782     for (out = 0; out &lt; outchannels; out++) {</span>
<span class="line-modified">783       /* convert */</span>
<span class="line-modified">784       res = 0.0;</span>
<span class="line-modified">785       for (in = 0; in &lt; inchannels; in++)</span>
<span class="line-modified">786         res += in_data[n * inchannels + in] * mix-&gt;matrix[in][out];</span>
<span class="line-modified">787 </span>
<span class="line-modified">788       out_data[n * outchannels + out] = res;</span>
<span class="line-modified">789     }</span>
<span class="line-modified">790   }</span>
<span class="line-modified">791 }</span>

792 
793 /**
794  * gst_audio_channel_mixer_new_with_matrix: (skip):
795  * @flags: #GstAudioChannelMixerFlags
796  * @in_channels: number of input channels
797  * @out_channels: number of output channels
798  * @matrix: (transfer full) (nullable): channel conversion matrix, m[@in_channels][@out_channels].
799  *   If identity matrix, passthrough applies. If %NULL, a (potentially truncated)
800  *   identity matrix is generated.
801  *
802  * Create a new channel mixer object for the given parameters.
803  *
804  * Returns: a new #GstAudioChannelMixer object, or %NULL if @format isn&#39;t supported,
805  *   @matrix is invalid, or @matrix is %NULL and @in_channels != @out_channels.
806  *   Free with gst_audio_channel_mixer_free() after usage.
807  *
808  * Since: 1.14
809  */
810 GstAudioChannelMixer *
811 gst_audio_channel_mixer_new_with_matrix (GstAudioChannelMixerFlags flags,
812     GstAudioFormat format,
813     gint in_channels, gint out_channels, gfloat ** matrix)
814 {
815   GstAudioChannelMixer *mix;
816 
817   g_return_val_if_fail (format == GST_AUDIO_FORMAT_S16
818       || format == GST_AUDIO_FORMAT_S32
819       || format == GST_AUDIO_FORMAT_F32
820       || format == GST_AUDIO_FORMAT_F64, NULL);
821   g_return_val_if_fail (in_channels &gt; 0 &amp;&amp; in_channels &lt; 64, NULL);
822   g_return_val_if_fail (out_channels &gt; 0 &amp;&amp; out_channels &lt; 64, NULL);
823 
824   mix = g_slice_new0 (GstAudioChannelMixer);
825   mix-&gt;in_channels = in_channels;
826   mix-&gt;out_channels = out_channels;
827 
828   if (!matrix) {
829     /* Generate (potentially truncated) identity matrix */
830     gint i, j;
831 
832     mix-&gt;matrix = g_new0 (gfloat *, in_channels);
833 
834     for (i = 0; i &lt; in_channels; i++) {
835       mix-&gt;matrix[i] = g_new (gfloat, out_channels);
836       for (j = 0; j &lt; out_channels; j++) {
837         mix-&gt;matrix[i][j] = i == j ? 1.0 : 0.0;
838       }
839     }
840   } else {
841     mix-&gt;matrix = matrix;
842   }
843 
844   gst_audio_channel_mixer_setup_matrix_int (mix);
845 
846 #ifndef GST_DISABLE_GST_DEBUG
847   /* debug */
848   {
849     GString *s;
850     gint i, j;
851 
852     s = g_string_new (&quot;Matrix for&quot;);
853     g_string_append_printf (s, &quot; %d -&gt; %d: &quot;,
854         mix-&gt;in_channels, mix-&gt;out_channels);
855     g_string_append (s, &quot;{&quot;);
856     for (i = 0; i &lt; mix-&gt;in_channels; i++) {
857       if (i != 0)
858         g_string_append (s, &quot;,&quot;);
859       g_string_append (s, &quot; {&quot;);
860       for (j = 0; j &lt; mix-&gt;out_channels; j++) {
861         if (j != 0)
862           g_string_append (s, &quot;,&quot;);
863         g_string_append_printf (s, &quot; %f&quot;, mix-&gt;matrix[i][j]);
864       }
865       g_string_append (s, &quot; }&quot;);
866     }
867     g_string_append (s, &quot; }&quot;);
868     GST_DEBUG (&quot;%s&quot;, s-&gt;str);
869     g_string_free (s, TRUE);
870   }
871 #endif
872 
873   switch (format) {
874     case GST_AUDIO_FORMAT_S16:
<a name="6" id="anc6"></a><span class="line-modified">875       mix-&gt;func = (MixerFunc) gst_audio_channel_mixer_mix_int16;</span>
















876       break;
877     case GST_AUDIO_FORMAT_S32:
<a name="7" id="anc7"></a><span class="line-modified">878       mix-&gt;func = (MixerFunc) gst_audio_channel_mixer_mix_int32;</span>
















879       break;
880     case GST_AUDIO_FORMAT_F32:
<a name="8" id="anc8"></a><span class="line-modified">881       mix-&gt;func = (MixerFunc) gst_audio_channel_mixer_mix_float;</span>
















882       break;
883     case GST_AUDIO_FORMAT_F64:
<a name="9" id="anc9"></a><span class="line-modified">884       mix-&gt;func = (MixerFunc) gst_audio_channel_mixer_mix_double;</span>
















885       break;
886     default:
887       g_assert_not_reached ();
888       break;
889   }
890   return mix;
891 }
892 
893 /**
894  * gst_audio_channel_mixer_new: (skip):
895  * @flags: #GstAudioChannelMixerFlags
896  * @in_channels: number of input channels
897  * @in_position: positions of input channels
898  * @out_channels: number of output channels
899  * @out_position: positions of output channels
900  *
901  * Create a new channel mixer object for the given parameters.
902  *
903  * Returns: a new #GstAudioChannelMixer object, or %NULL if @format isn&#39;t supported.
904  *   Free with gst_audio_channel_mixer_free() after usage.
905  */
906 GstAudioChannelMixer *
907 gst_audio_channel_mixer_new (GstAudioChannelMixerFlags flags,
908     GstAudioFormat format,
909     gint in_channels,
910     GstAudioChannelPosition * in_position,
911     gint out_channels, GstAudioChannelPosition * out_position)
912 {
913   gfloat **matrix;
914 
915   g_return_val_if_fail (format == GST_AUDIO_FORMAT_S16
916       || format == GST_AUDIO_FORMAT_S32
917       || format == GST_AUDIO_FORMAT_F32
918       || format == GST_AUDIO_FORMAT_F64, NULL);
919   g_return_val_if_fail (in_channels &gt; 0 &amp;&amp; in_channels &lt; 64, NULL);
920   g_return_val_if_fail (out_channels &gt; 0 &amp;&amp; out_channels &lt; 64, NULL);
921 
922   matrix =
923       gst_audio_channel_mixer_setup_matrix (flags, in_channels, in_position,
924       out_channels, out_position);
925   return gst_audio_channel_mixer_new_with_matrix (flags, format, in_channels,
926       out_channels, matrix);
927 }
928 
929 /**
930  * gst_audio_channel_mixer_is_passthrough:
931  * @mix: a #GstAudioChannelMixer
932  *
933  * Check if @mix is in passthrough.
934  *
935  * Only N x N mix identity matrices are considered passthrough,
936  * this is determined by comparing the contents of the matrix
937  * with 0.0 and 1.0.
938  *
939  * As this is floating point comparisons, if the values have been
940  * generated, they should be rounded up or down by explicit
941  * assignment of 0.0 or 1.0 to values within a user-defined
942  * epsilon, this code doesn&#39;t make assumptions as to what may
943  * constitute an appropriate epsilon.
944  *
945  * Returns: %TRUE is @mix is passthrough.
946  */
947 gboolean
948 gst_audio_channel_mixer_is_passthrough (GstAudioChannelMixer * mix)
949 {
950   gint i, j;
951   gboolean res;
952 
953   /* only NxN matrices can be identities */
954   if (mix-&gt;in_channels != mix-&gt;out_channels)
955     return FALSE;
956 
957   res = TRUE;
958 
959   for (i = 0; i &lt; mix-&gt;in_channels; i++) {
960     for (j = 0; j &lt; mix-&gt;out_channels; j++) {
961       if ((i == j &amp;&amp; mix-&gt;matrix[i][j] != 1.0f) ||
962           (i != j &amp;&amp; mix-&gt;matrix[i][j] != 0.0f)) {
963         res = FALSE;
964         break;
965       }
966     }
967   }
968 
969   return res;
970 }
971 
972 /**
973  * gst_audio_channel_mixer_samples:
974  * @mix: a #GstAudioChannelMixer
975  * @in: input samples
976  * @out: output samples
977  * @samples: number of samples
978  *
979  * In case the samples are interleaved, @in and @out must point to an
980  * array with a single element pointing to a block of interleaved samples.
981  *
982  * If non-interleaved samples are used, @in and @out must point to an
983  * array with pointers to memory blocks, one for each channel.
984  *
985  * Perform channel mixing on @in_data and write the result to @out_data.
986  * @in_data and @out_data need to be in @format and @layout.
987  */
988 void
989 gst_audio_channel_mixer_samples (GstAudioChannelMixer * mix,
990     const gpointer in[], gpointer out[], gint samples)
991 {
992   g_return_if_fail (mix != NULL);
993   g_return_if_fail (mix-&gt;matrix != NULL);
994 
<a name="10" id="anc10"></a><span class="line-modified">995   mix-&gt;func (mix, in[0], out[0], samples);</span>
996 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>