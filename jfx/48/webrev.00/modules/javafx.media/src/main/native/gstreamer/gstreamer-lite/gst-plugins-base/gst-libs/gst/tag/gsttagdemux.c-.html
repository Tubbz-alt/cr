<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/tag/gsttagdemux.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer Base Class for Tag Demuxing
   2  * Copyright (C) 2005 Jan Schmidt &lt;thaytan@mad.scientist.com&gt;
   3  * Copyright (C) 2006-2007 Tim-Philipp MÃ¼ller &lt;tim centricular net&gt;
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Library General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Library General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Library General Public
  16  * License along with this library; if not, write to the
  17  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  18  * Boston, MA 02110-1301, USA.
  19  */
  20 
  21 /**
  22  * SECTION:gsttagdemux
  23  * @title: GstTagDemux
  24  * @see_also: GstApeDemux, GstID3Demux
  25  * @short_description: Base class for demuxing tags that are in chunks
  26  *                     directly at the beginning or at the end of a file
  27  *
  28  * Provides a base class for demuxing tags at the beginning or end of a
  29  * stream and handles things like typefinding, querying, seeking, and
  30  * different modes of operation (chain-based, pull_range-based, and providing
  31  * downstream elements with random access if upstream supports that). The tag
  32  * is stripped from the output, and all offsets are adjusted for the tag
  33  * sizes, so that to the downstream element the stream will appear as if
  34  * there was no tag at all. Also, once the tag has been parsed, GstTagDemux
  35  * will try to determine the media type of the resulting stream and add a
  36  * source pad with the appropriate caps in order to facilitate auto-plugging.
  37  *
  38  * ## Deriving from GstTagDemux
  39  *
  40  * Subclasses have to do four things:
  41  *
  42  *  * In their base init function, they must add a pad template for the sink
  43  *    pad to the element class, describing the media type they can parse in
  44  *    the caps of the pad template.
  45  *  * In their class init function, they must override
  46  *    GST_TAG_DEMUX_CLASS(demux_klass)-&gt;identify_tag with their own identify
  47  *    function.
  48  *  * In their class init function, they must override
  49  *  GST_TAG_DEMUX_CLASS(demux_klass)-&gt;parse_tag with their own parse
  50  *  function.
  51  *  * In their class init function, they must also set
  52  *    GST_TAG_DEMUX_CLASS(demux_klass)-&gt;min_start_size and/or
  53  *  GST_TAG_DEMUX_CLASS(demux_klass)-&gt;min_end_size to the minimum size required
  54  *  for the identify function to decide whether the stream has a supported tag
  55  *  or not. A class parsing ID3v1 tags, for example, would set min_end_size to
  56  *  128 bytes.
  57  */
  58 
  59 #ifdef HAVE_CONFIG_H
  60 #include &quot;config.h&quot;
  61 #endif
  62 
  63 #include &quot;gsttagdemux.h&quot;
  64 
  65 #include &lt;gst/base/gsttypefindhelper.h&gt;
  66 #include &lt;gst/base/gstadapter.h&gt;
  67 #include &lt;gst/gst-i18n-plugin.h&gt;
  68 #include &lt;string.h&gt;
  69 
  70 typedef enum
  71 {
  72   GST_TAG_DEMUX_READ_START_TAG,
  73   GST_TAG_DEMUX_TYPEFINDING,
  74   GST_TAG_DEMUX_STREAMING
  75 } GstTagDemuxState;
  76 
  77 struct _GstTagDemuxPrivate
  78 {
  79   GstPad *srcpad;
  80   GstPad *sinkpad;
  81 
  82   /* Number of bytes to remove from the
  83    * start of file (tag at beginning) */
  84   guint strip_start;
  85 
  86   /* Number of bytes to remove from the
  87    * end of file (tag at end) */
  88   guint strip_end;
  89 
  90   gint64 upstream_size;
  91 
  92   GstTagDemuxState state;
  93   GstAdapter *adapter;
  94   GstBuffer *collect;
  95   gsize collect_size;
  96   guint tagsize;
  97   GstCaps *src_caps;
  98 
  99   GstTagList *event_tags;
 100   GstTagList *parsed_tags;
 101   gboolean send_tag_event;
 102 
 103   GstSegment segment;
 104   gboolean need_newseg;
 105 
 106   guint64 offset;
 107 
 108   GList *pending_events;
 109 };
 110 
 111 /* Require at least 8kB of data before we attempt typefind.
 112  * Seems a decent value based on test files
 113  * 40kB is massive overkill for the maximum, I think, but it
 114  * doesn&#39;t do any harm (tpm: increased to 64kB after watching
 115  * typefinding fail on a wavpack file that needed 42kB to succeed) */
 116 #define TYPE_FIND_MIN_SIZE 8192
 117 #define TYPE_FIND_MAX_SIZE 65536
 118 
 119 #define DEFAULT_PULL_BLOCKSIZE 4096
 120 
 121 GST_DEBUG_CATEGORY_STATIC (tagdemux_debug);
 122 #define GST_CAT_DEFAULT (tagdemux_debug)
 123 
 124 static GstStaticPadTemplate src_factory = GST_STATIC_PAD_TEMPLATE (&quot;src&quot;,
 125     GST_PAD_SRC,
 126     GST_PAD_ALWAYS,
 127     GST_STATIC_CAPS (&quot;ANY&quot;)
 128     );
 129 
 130 static void gst_tag_demux_element_loop (GstTagDemux * demux);
 131 
 132 static void gst_tag_demux_dispose (GObject * object);
 133 
 134 static GstFlowReturn gst_tag_demux_chain (GstPad * pad, GstObject * parent,
 135     GstBuffer * buf);
 136 static gboolean gst_tag_demux_sink_event (GstPad * pad, GstObject * parent,
 137     GstEvent * event);
 138 
 139 static gboolean gst_tag_demux_sink_activate_mode (GstPad * pad,
 140     GstObject * parent, GstPadMode mode, gboolean active);
 141 static gboolean gst_tag_demux_src_activate_mode (GstPad * pad,
 142     GstObject * parent, GstPadMode mode, gboolean active);
 143 static GstFlowReturn gst_tag_demux_read_range (GstTagDemux * tagdemux,
 144     GstObject * parent, guint64 offset, guint length, GstBuffer ** buffer);
 145 
 146 static GstFlowReturn gst_tag_demux_src_getrange (GstPad * srcpad,
 147     GstObject * parent, guint64 offset, guint length, GstBuffer ** buffer);
 148 
 149 static void gst_tag_demux_set_src_caps (GstTagDemux * tagdemux,
 150     GstCaps * new_caps);
 151 
 152 static gboolean gst_tag_demux_srcpad_event (GstPad * pad, GstObject * parent,
 153     GstEvent * event);
 154 static gboolean gst_tag_demux_sink_activate (GstPad * sinkpad,
 155     GstObject * parent);
 156 static GstStateChangeReturn gst_tag_demux_change_state (GstElement * element,
 157     GstStateChange transition);
 158 static gboolean gst_tag_demux_pad_query (GstPad * pad, GstObject * parent,
 159     GstQuery * query);
 160 static gboolean gst_tag_demux_get_upstream_size (GstTagDemux * tagdemux);
 161 static void gst_tag_demux_send_pending_events (GstTagDemux * tagdemux);
 162 static void gst_tag_demux_send_tag_event (GstTagDemux * tagdemux);
 163 static gboolean gst_tag_demux_send_new_segment (GstTagDemux * tagdemux);
 164 
 165 static void gst_tag_demux_base_init (gpointer g_class);
 166 static void gst_tag_demux_class_init (gpointer g_class, gpointer d);
 167 static void gst_tag_demux_init (GstTagDemux * obj, GstTagDemuxClass * klass);
 168 
 169 static gpointer parent_class;   /* NULL */
 170 
 171 /* Cannot use boilerplate macros here because we want the abstract flag */
 172 GType
 173 gst_tag_demux_get_type (void)
 174 {
 175   static GType object_type;     /* 0 */
 176 
 177   if (object_type == 0) {
 178     static const GTypeInfo object_info = {
 179       sizeof (GstTagDemuxClass),
 180       gst_tag_demux_base_init,
 181       NULL,                     /* base_finalize */
 182       gst_tag_demux_class_init,
 183       NULL,                     /* class_finalize */
 184       NULL,                     /* class_data */
 185       sizeof (GstTagDemux),
 186       0,                        /* n_preallocs */
 187       (GInstanceInitFunc) gst_tag_demux_init
 188     };
 189 
 190     object_type = g_type_register_static (GST_TYPE_ELEMENT,
 191         &quot;GstTagDemux&quot;, &amp;object_info, G_TYPE_FLAG_ABSTRACT);
 192   }
 193 
 194   return object_type;
 195 }
 196 
 197 static void
 198 gst_tag_demux_base_init (gpointer klass)
 199 {
 200   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 201 
 202   gst_element_class_add_static_pad_template (element_class, &amp;src_factory);
 203 
 204   GST_DEBUG_CATEGORY_INIT (tagdemux_debug, &quot;tagdemux&quot;, 0,
 205       &quot;tag demux base class&quot;);
 206 }
 207 
 208 static void
 209 gst_tag_demux_class_init (gpointer klass, gpointer d)
 210 {
 211   GstTagDemuxClass *tagdemux_class = GST_TAG_DEMUX_CLASS (klass);
 212   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 213   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 214 
 215   parent_class = g_type_class_peek_parent (klass);
 216 
 217   gobject_class-&gt;dispose = gst_tag_demux_dispose;
 218 
 219   element_class-&gt;change_state = GST_DEBUG_FUNCPTR (gst_tag_demux_change_state);
 220 
 221   g_type_class_add_private (klass, sizeof (GstTagDemuxPrivate));
 222 
 223   /* subclasses must set at least one of these */
 224   tagdemux_class-&gt;min_start_size = 0;
 225   tagdemux_class-&gt;min_end_size = 0;
 226 }
 227 
 228 static void
 229 gst_tag_demux_reset (GstTagDemux * tagdemux)
 230 {
 231   GstBuffer **buffer_p = &amp;tagdemux-&gt;priv-&gt;collect;
 232   GstCaps **caps_p = &amp;tagdemux-&gt;priv-&gt;src_caps;
 233 
 234   tagdemux-&gt;priv-&gt;strip_start = 0;
 235   tagdemux-&gt;priv-&gt;strip_end = 0;
 236   tagdemux-&gt;priv-&gt;upstream_size = -1;
 237   tagdemux-&gt;priv-&gt;state = GST_TAG_DEMUX_READ_START_TAG;
 238   tagdemux-&gt;priv-&gt;send_tag_event = FALSE;
 239 
 240   gst_buffer_replace (buffer_p, NULL);
 241   tagdemux-&gt;priv-&gt;collect_size = 0;
 242   tagdemux-&gt;priv-&gt;tagsize = 0;
 243   gst_adapter_clear (tagdemux-&gt;priv-&gt;adapter);
 244   gst_caps_replace (caps_p, NULL);
 245 
 246   if (tagdemux-&gt;priv-&gt;event_tags) {
 247     gst_tag_list_unref (tagdemux-&gt;priv-&gt;event_tags);
 248     tagdemux-&gt;priv-&gt;event_tags = NULL;
 249   }
 250   if (tagdemux-&gt;priv-&gt;parsed_tags) {
 251     gst_tag_list_unref (tagdemux-&gt;priv-&gt;parsed_tags);
 252     tagdemux-&gt;priv-&gt;parsed_tags = NULL;
 253   }
 254 
 255   gst_segment_init (&amp;tagdemux-&gt;priv-&gt;segment, GST_FORMAT_UNDEFINED);
 256   tagdemux-&gt;priv-&gt;need_newseg = TRUE;
 257 
 258   g_list_foreach (tagdemux-&gt;priv-&gt;pending_events,
 259       (GFunc) gst_mini_object_unref, NULL);
 260   g_list_free (tagdemux-&gt;priv-&gt;pending_events);
 261   tagdemux-&gt;priv-&gt;pending_events = NULL;
 262 }
 263 
 264 static void
 265 gst_tag_demux_init (GstTagDemux * demux, GstTagDemuxClass * gclass)
 266 {
 267   GstElementClass *element_klass = GST_ELEMENT_CLASS (gclass);
 268   GstPadTemplate *tmpl;
 269 
 270   demux-&gt;priv = g_type_instance_get_private ((GTypeInstance *) demux,
 271       GST_TYPE_TAG_DEMUX);
 272 
 273   /* sink pad */
 274   tmpl = gst_element_class_get_pad_template (element_klass, &quot;sink&quot;);
 275   if (tmpl) {
 276     demux-&gt;priv-&gt;sinkpad = gst_pad_new_from_template (tmpl, &quot;sink&quot;);
 277 
 278     gst_pad_set_activatemode_function (demux-&gt;priv-&gt;sinkpad,
 279         GST_DEBUG_FUNCPTR (gst_tag_demux_sink_activate_mode));
 280     gst_pad_set_activate_function (demux-&gt;priv-&gt;sinkpad,
 281         GST_DEBUG_FUNCPTR (gst_tag_demux_sink_activate));
 282     gst_pad_set_event_function (demux-&gt;priv-&gt;sinkpad,
 283         GST_DEBUG_FUNCPTR (gst_tag_demux_sink_event));
 284     gst_pad_set_chain_function (demux-&gt;priv-&gt;sinkpad,
 285         GST_DEBUG_FUNCPTR (gst_tag_demux_chain));
 286     gst_element_add_pad (GST_ELEMENT (demux), demux-&gt;priv-&gt;sinkpad);
 287   } else {
 288     g_warning (&quot;GstTagDemux subclass %s must provide a sink pad template&quot;,
 289         G_OBJECT_TYPE_NAME (demux));
 290   }
 291 
 292   /* source pad */
 293   tmpl = gst_element_class_get_pad_template (element_klass, &quot;src&quot;);
 294   demux-&gt;priv-&gt;srcpad = gst_pad_new_from_template (tmpl, &quot;src&quot;);
 295   gst_pad_set_query_function (demux-&gt;priv-&gt;srcpad,
 296       GST_DEBUG_FUNCPTR (gst_tag_demux_pad_query));
 297   gst_pad_set_event_function (demux-&gt;priv-&gt;srcpad,
 298       GST_DEBUG_FUNCPTR (gst_tag_demux_srcpad_event));
 299   gst_pad_set_activatemode_function (demux-&gt;priv-&gt;srcpad,
 300       GST_DEBUG_FUNCPTR (gst_tag_demux_src_activate_mode));
 301   gst_pad_set_getrange_function (demux-&gt;priv-&gt;srcpad,
 302       GST_DEBUG_FUNCPTR (gst_tag_demux_src_getrange));
 303   gst_pad_use_fixed_caps (demux-&gt;priv-&gt;srcpad);
 304   gst_element_add_pad (GST_ELEMENT (demux), demux-&gt;priv-&gt;srcpad);
 305 
 306   demux-&gt;priv-&gt;adapter = gst_adapter_new ();
 307   gst_tag_demux_reset (demux);
 308 }
 309 
 310 static void
 311 gst_tag_demux_dispose (GObject * object)
 312 {
 313   GstTagDemux *tagdemux = GST_TAG_DEMUX (object);
 314 
 315   gst_tag_demux_reset (tagdemux);
 316   if (tagdemux-&gt;priv-&gt;adapter) {
 317     g_object_unref (tagdemux-&gt;priv-&gt;adapter);
 318     tagdemux-&gt;priv-&gt;adapter = NULL;
 319   }
 320 
 321   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
 322 }
 323 
 324 // FIXME: convert to set_caps / sending a caps event
 325 static void
 326 gst_tag_demux_set_src_caps (GstTagDemux * tagdemux, GstCaps * new_caps)
 327 {
 328   GstCaps *old_caps = tagdemux-&gt;priv-&gt;src_caps;
 329 
 330   if (old_caps == NULL || !gst_caps_is_equal (new_caps, old_caps)) {
 331     GstEvent *event;
 332 
 333     gst_caps_replace (&amp;tagdemux-&gt;priv-&gt;src_caps, new_caps);
 334 
 335       GST_DEBUG_OBJECT (tagdemux, &quot;Changing src pad caps to %&quot; GST_PTR_FORMAT,
 336           tagdemux-&gt;priv-&gt;src_caps);
 337 
 338     event =
 339         gst_pad_get_sticky_event (tagdemux-&gt;priv-&gt;sinkpad,
 340         GST_EVENT_STREAM_START, 0);
 341     if (!event) {
 342       gchar *stream_id = gst_pad_create_stream_id (tagdemux-&gt;priv-&gt;srcpad,
 343           GST_ELEMENT_CAST (tagdemux), NULL);
 344       GST_DEBUG_OBJECT (tagdemux, &quot;Creating new STREAM_START event&quot;);
 345       event = gst_event_new_stream_start (stream_id);
 346       g_free (stream_id);
 347       gst_event_set_group_id (event, gst_util_group_id_next ());
 348     }
 349     gst_pad_push_event (tagdemux-&gt;priv-&gt;srcpad, event);
 350 
 351     gst_pad_set_caps (tagdemux-&gt;priv-&gt;srcpad, tagdemux-&gt;priv-&gt;src_caps);
 352   } else {
 353     /* Caps never changed */
 354   }
 355 }
 356 
 357 /* will return FALSE if buffer is beyond end of data; will return TRUE
 358  * if buffer was trimmed successfully or didn&#39;t need trimming, but may
 359  * also return TRUE and set *buf_ref to NULL if the buffer was before
 360  * the start of the data */
 361 static gboolean
 362 gst_tag_demux_trim_buffer (GstTagDemux * tagdemux, GstBuffer ** buf_ref,
 363     gsize * buf_size)
 364 {
 365   GstBuffer *buf = *buf_ref;
 366 
 367   guint trim_start = 0;
 368   guint out_size, bsize;
 369   guint64 out_offset, boffset;
 370   gboolean need_sub = FALSE;
 371 
 372   bsize = out_size = gst_buffer_get_size (buf);
 373   boffset = out_offset = GST_BUFFER_OFFSET (buf);
 374 
 375   /* Adjust offset and length */
 376   if (!GST_BUFFER_OFFSET_IS_VALID (buf)) {
 377     /* Can&#39;t change anything without an offset */
 378     *buf_size = bsize;
 379     return TRUE;
 380   }
 381 
 382   /* If the buffer crosses the tag at the end of file, trim it */
 383   if (tagdemux-&gt;priv-&gt;strip_end &gt; 0) {
 384     if (gst_tag_demux_get_upstream_size (tagdemux)) {
 385       guint64 v1tag_offset =
 386           tagdemux-&gt;priv-&gt;upstream_size - tagdemux-&gt;priv-&gt;strip_end;
 387 
 388       if (out_offset &gt;= v1tag_offset) {
 389         GST_DEBUG_OBJECT (tagdemux, &quot;Buffer is past the end of the data&quot;);
 390         goto no_out_buffer_end;
 391       }
 392 
 393       if (out_offset + out_size &gt; v1tag_offset) {
 394         out_size = v1tag_offset - out_offset;
 395         need_sub = TRUE;
 396       }
 397     }
 398   }
 399 
 400   if (tagdemux-&gt;priv-&gt;strip_start &gt; 0) {
 401     /* If the buffer crosses the tag at the start of file, trim it */
 402     if (out_offset &lt;= tagdemux-&gt;priv-&gt;strip_start) {
 403       if (out_offset + out_size &lt;= tagdemux-&gt;priv-&gt;strip_start) {
 404         GST_DEBUG_OBJECT (tagdemux, &quot;Buffer is before the start of the data&quot;);
 405         goto no_out_buffer_start;
 406       }
 407 
 408       trim_start = tagdemux-&gt;priv-&gt;strip_start - out_offset;
 409       out_size -= trim_start;
 410       out_offset = 0;
 411     } else {
 412       out_offset -= tagdemux-&gt;priv-&gt;strip_start;
 413     }
 414     need_sub = TRUE;
 415   }
 416 
 417   if (need_sub) {
 418     if (out_size != bsize || !gst_buffer_is_writable (buf)) {
 419       GstBuffer *sub;
 420 
 421       GST_DEBUG_OBJECT (tagdemux, &quot;Sub-buffering to trim size %d offset %&quot;
 422           G_GINT64_FORMAT &quot; to %d offset %&quot; G_GINT64_FORMAT,
 423           bsize, boffset, out_size, out_offset);
 424 
 425       sub =
 426           gst_buffer_copy_region (buf, GST_BUFFER_COPY_ALL, trim_start,
 427           out_size);
 428       g_return_val_if_fail (sub != NULL, FALSE);
 429       if (GST_BUFFER_TIMESTAMP_IS_VALID (buf))
 430         GST_BUFFER_TIMESTAMP (sub) = GST_BUFFER_TIMESTAMP (buf);
 431       if (GST_BUFFER_DURATION_IS_VALID (buf))
 432         GST_BUFFER_DURATION (sub) = GST_BUFFER_DURATION (buf);
 433       gst_buffer_unref (buf);
 434       *buf_ref = buf = sub;
 435       *buf_size = out_size;
 436     } else {
 437       GST_DEBUG_OBJECT (tagdemux, &quot;Adjusting buffer from size %d offset %&quot;
 438           G_GINT64_FORMAT &quot; to %d offset %&quot; G_GINT64_FORMAT,
 439           bsize, boffset, out_size, out_offset);
 440     }
 441 
 442     GST_BUFFER_OFFSET (buf) = out_offset;
 443     GST_BUFFER_OFFSET_END (buf) = out_offset + out_size;
 444   }
 445 
 446   return TRUE;
 447 
 448 no_out_buffer_end:
 449   {
 450     gst_buffer_unref (buf);
 451     *buf_ref = NULL;
 452     return FALSE;
 453   }
 454 no_out_buffer_start:
 455   {
 456     gst_buffer_unref (buf);
 457     *buf_ref = NULL;
 458     return TRUE;
 459   }
 460 }
 461 
 462 static void
 463 update_collected (GstTagDemux * demux)
 464 {
 465   guint avail;
 466   GstBuffer *buf;
 467 
 468   avail = gst_adapter_available (demux-&gt;priv-&gt;adapter);
 469   if (avail == 0)
 470     return;
 471 
 472   buf = gst_adapter_take_buffer (demux-&gt;priv-&gt;adapter, avail);
 473 
 474   if (demux-&gt;priv-&gt;collect == NULL) {
 475     demux-&gt;priv-&gt;collect = buf;
 476   } else {
 477     demux-&gt;priv-&gt;collect = gst_buffer_append (demux-&gt;priv-&gt;collect, buf);
 478   }
 479   demux-&gt;priv-&gt;collect_size += avail;
 480 }
 481 
 482 static void
 483 gst_tag_demux_chain_parse_tag (GstTagDemux * demux)
 484 {
 485   GstBuffer *collect;
 486   GstTagDemuxResult parse_ret;
 487   GstTagDemuxClass *klass;
 488   guint tagsize = 0;
 489   guint available;
 490 
 491   available =
 492       demux-&gt;priv-&gt;collect_size + gst_adapter_available (demux-&gt;priv-&gt;adapter);
 493 
 494   klass = GST_TAG_DEMUX_CLASS (G_OBJECT_GET_CLASS (demux));
 495 
 496   if (available &lt; klass-&gt;min_start_size) {
 497     GST_DEBUG_OBJECT (demux, &quot;Only %u bytes available, but %u needed &quot;
 498         &quot;to identify tag&quot;, available, klass-&gt;min_start_size);
 499     return;                     /* wait for more data */
 500   }
 501 
 502   if (available &lt; demux-&gt;priv-&gt;tagsize) {
 503     GST_DEBUG_OBJECT (demux, &quot;Only %u bytes available, but %u needed &quot;
 504         &quot;to parse tag&quot;, available, demux-&gt;priv-&gt;tagsize);
 505     return;                     /* wait for more data */
 506   }
 507 
 508   update_collected (demux);
 509   demux-&gt;priv-&gt;collect = gst_buffer_make_writable (demux-&gt;priv-&gt;collect);
 510   collect = demux-&gt;priv-&gt;collect;
 511 
 512   g_assert (gst_buffer_is_writable (collect));
 513 
 514 
 515   /* If we receive a buffer that&#39;s from the middle of the file,
 516    * we can&#39;t read tags so move to typefinding */
 517   if (GST_BUFFER_OFFSET_IS_VALID (collect) &amp;&amp; GST_BUFFER_OFFSET (collect) != 0) {
 518     GST_DEBUG_OBJECT (demux, &quot;Received buffer from non-zero offset %&quot;
 519         G_GINT64_FORMAT &quot;. Can&#39;t read tags&quot;, GST_BUFFER_OFFSET (collect));
 520     demux-&gt;priv-&gt;state = GST_TAG_DEMUX_TYPEFINDING;
 521     return;
 522   }
 523 
 524   g_assert (klass-&gt;identify_tag != NULL);
 525   g_assert (klass-&gt;parse_tag != NULL);
 526 
 527   if (!klass-&gt;identify_tag (demux, collect, TRUE, &amp;tagsize)) {
 528     GST_DEBUG_OBJECT (demux, &quot;Could not identify start tag&quot;);
 529     demux-&gt;priv-&gt;state = GST_TAG_DEMUX_TYPEFINDING;
 530     return;
 531   }
 532 
 533   demux-&gt;priv-&gt;tagsize = tagsize;
 534 
 535   /* need to set offset of first buffer to 0 or trimming won&#39;t work */
 536   if (!GST_BUFFER_OFFSET_IS_VALID (collect)) {
 537     GST_WARNING_OBJECT (demux, &quot;Fixing up first buffer without offset&quot;);
 538     GST_BUFFER_OFFSET (collect) = 0;
 539   }
 540 
 541   GST_DEBUG_OBJECT (demux, &quot;Identified tag, size = %u bytes&quot;, tagsize);
 542 
 543   do {
 544     GstTagList *tags = NULL;
 545     guint newsize, saved_size;
 546 
 547     demux-&gt;priv-&gt;strip_start = tagsize;
 548 
 549     if (available &lt; tagsize) {
 550       GST_DEBUG_OBJECT (demux, &quot;Only %u bytes available, but %u needed &quot;
 551           &quot;to parse tag&quot;, available, tagsize);
 552       return;                   /* wait for more data */
 553     }
 554 
 555     saved_size = gst_buffer_get_size (collect);
 556     gst_buffer_set_size (collect, tagsize);
 557     newsize = tagsize;
 558 
 559     parse_ret = klass-&gt;parse_tag (demux, collect, TRUE, &amp;newsize, &amp;tags);
 560 
 561     gst_buffer_set_size (collect, saved_size);
 562 
 563     switch (parse_ret) {
 564       case GST_TAG_DEMUX_RESULT_OK:
 565         demux-&gt;priv-&gt;strip_start = newsize;
 566         demux-&gt;priv-&gt;parsed_tags = tags;
 567         GST_DEBUG_OBJECT (demux, &quot;Read start tag of size %u&quot;, newsize);
 568         break;
 569       case GST_TAG_DEMUX_RESULT_BROKEN_TAG:
 570         demux-&gt;priv-&gt;strip_start = newsize;
 571         demux-&gt;priv-&gt;parsed_tags = tags;
 572         GST_WARNING_OBJECT (demux, &quot;Ignoring broken start tag of size %d&quot;,
 573             demux-&gt;priv-&gt;strip_start);
 574         break;
 575       case GST_TAG_DEMUX_RESULT_AGAIN:
 576         GST_DEBUG_OBJECT (demux, &quot;Re-parse, this time with %u bytes&quot;, newsize);
 577         g_assert (newsize != tagsize);
 578         tagsize = newsize;
 579         break;
 580     }
 581   } while (parse_ret == GST_TAG_DEMUX_RESULT_AGAIN);
 582 
 583   GST_LOG_OBJECT (demux, &quot;Parsed tag. Proceeding to typefinding&quot;);
 584   demux-&gt;priv-&gt;state = GST_TAG_DEMUX_TYPEFINDING;
 585   demux-&gt;priv-&gt;send_tag_event = TRUE;
 586 }
 587 
 588 static GstFlowReturn
 589 gst_tag_demux_chain_buffer (GstTagDemux * demux, GstBuffer * buf,
 590     gboolean at_eos)
 591 {
 592   gsize size;
 593 
 594   size = gst_buffer_get_size (buf);
 595 
 596   /* Update our segment position info */
 597   if (demux-&gt;priv-&gt;segment.format == GST_FORMAT_BYTES) {
 598     if (GST_BUFFER_OFFSET_IS_VALID (buf))
 599       demux-&gt;priv-&gt;segment.position = GST_BUFFER_OFFSET (buf);
 600     demux-&gt;priv-&gt;segment.position += size;
 601   } else if (demux-&gt;priv-&gt;segment.format == GST_FORMAT_TIME) {
 602     if (GST_BUFFER_TIMESTAMP_IS_VALID (buf))
 603       demux-&gt;priv-&gt;segment.position = GST_BUFFER_TIMESTAMP (buf);
 604     if (GST_BUFFER_DURATION_IS_VALID (buf))
 605       demux-&gt;priv-&gt;segment.position += GST_BUFFER_DURATION (buf);
 606   }
 607 
 608   gst_adapter_push (demux-&gt;priv-&gt;adapter, buf);
 609   buf = NULL;
 610 
 611   switch (demux-&gt;priv-&gt;state) {
 612     case GST_TAG_DEMUX_READ_START_TAG:
 613       gst_tag_demux_chain_parse_tag (demux);
 614       if (demux-&gt;priv-&gt;state != GST_TAG_DEMUX_TYPEFINDING)
 615         break;
 616       /* Fall-through */
 617     case GST_TAG_DEMUX_TYPEFINDING:{
 618       GstTypeFindProbability probability = 0;
 619       GstBuffer *typefind_buf = NULL;
 620       gsize typefind_size;
 621       GstCaps *caps;
 622 
 623       update_collected (demux);
 624 
 625       if (!at_eos &amp;&amp; demux-&gt;priv-&gt;collect_size &lt;
 626           TYPE_FIND_MIN_SIZE + demux-&gt;priv-&gt;strip_start)
 627         break;                  /* Go get more data first */
 628 
 629       GST_DEBUG_OBJECT (demux, &quot;Typefinding with size %&quot; G_GSIZE_FORMAT,
 630           demux-&gt;priv-&gt;collect_size);
 631 
 632       /* Trim the buffer and adjust offset for typefinding */
 633       typefind_buf = demux-&gt;priv-&gt;collect;
 634       gst_buffer_ref (typefind_buf);
 635       if (!gst_tag_demux_trim_buffer (demux, &amp;typefind_buf, &amp;typefind_size))
 636         return GST_FLOW_EOS;
 637 
 638       if (typefind_buf == NULL)
 639         break;                  /* Still need more data */
 640 
 641       caps = gst_type_find_helper_for_buffer (GST_OBJECT (demux),
 642           typefind_buf, &amp;probability);
 643 
 644       if (caps == NULL) {
 645         if (typefind_size &lt; TYPE_FIND_MAX_SIZE) {
 646           /* Just break for more data */
 647           gst_buffer_unref (typefind_buf);
 648           return GST_FLOW_OK;
 649         }
 650 
 651         /* We failed typefind */
 652         GST_ELEMENT_ERROR (demux, STREAM, TYPE_NOT_FOUND, (NULL),
 653             (&quot;Could not detect type for contents within tag&quot;));
 654         gst_buffer_unref (typefind_buf);
 655         gst_buffer_unref (demux-&gt;priv-&gt;collect);
 656         demux-&gt;priv-&gt;collect = NULL;
 657         demux-&gt;priv-&gt;collect_size = 0;
 658         return GST_FLOW_ERROR;
 659       }
 660       gst_buffer_unref (typefind_buf);
 661 
 662       GST_DEBUG_OBJECT (demux, &quot;Found type %&quot; GST_PTR_FORMAT &quot; with a &quot;
 663           &quot;probability of %u&quot;, caps, probability);
 664 
 665       gst_tag_demux_set_src_caps (demux, caps);
 666         gst_caps_unref (caps);
 667 
 668       /* Move onto streaming and fall-through to push out existing
 669        * data */
 670       demux-&gt;priv-&gt;state = GST_TAG_DEMUX_STREAMING;
 671       /* fall-through */
 672     }
 673     case GST_TAG_DEMUX_STREAMING:{
 674       GstBuffer *outbuf = NULL;
 675       gsize outbuf_size;
 676 
 677       update_collected (demux);
 678 
 679       /* Trim the buffer and adjust offset */
 680       if (demux-&gt;priv-&gt;collect) {
 681         outbuf = demux-&gt;priv-&gt;collect;
 682         demux-&gt;priv-&gt;collect = NULL;
 683         demux-&gt;priv-&gt;collect_size = 0;
 684         if (!gst_tag_demux_trim_buffer (demux, &amp;outbuf, &amp;outbuf_size))
 685           return GST_FLOW_EOS;
 686       }
 687       if (outbuf) {
 688         /* Might need a new segment before the buffer */
 689         if (demux-&gt;priv-&gt;need_newseg) {
 690           if (!gst_tag_demux_send_new_segment (demux)) {
 691             GST_WARNING_OBJECT (demux, &quot;Downstream did not handle newsegment &quot;
 692                 &quot;event as it should&quot;);
 693           }
 694           demux-&gt;priv-&gt;need_newseg = FALSE;
 695         }
 696 
 697         /* send any pending events we cached */
 698         gst_tag_demux_send_pending_events (demux);
 699 
 700         /* Send our own pending tag event */
 701         if (demux-&gt;priv-&gt;send_tag_event) {
 702           gst_tag_demux_send_tag_event (demux);
 703           demux-&gt;priv-&gt;send_tag_event = FALSE;
 704         }
 705 
 706         GST_LOG_OBJECT (demux, &quot;Pushing buffer %&quot; GST_PTR_FORMAT, outbuf);
 707 
 708         return gst_pad_push (demux-&gt;priv-&gt;srcpad, outbuf);
 709       }
 710     }
 711   }
 712   return GST_FLOW_OK;
 713 }
 714 
 715 static GstFlowReturn
 716 gst_tag_demux_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
 717 {
 718   return gst_tag_demux_chain_buffer (GST_TAG_DEMUX (parent), buf, FALSE);
 719 }
 720 
 721 static gboolean
 722 gst_tag_demux_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
 723 {
 724   GstTagDemux *demux;
 725   gboolean ret;
 726 
 727   demux = GST_TAG_DEMUX (parent);
 728 
 729   switch (GST_EVENT_TYPE (event)) {
 730     case GST_EVENT_EOS:
 731       if (!gst_pad_has_current_caps (demux-&gt;priv-&gt;srcpad)) {
 732         GST_INFO_OBJECT (demux, &quot;EOS before we found a type&quot;);
 733 
 734         /* push final buffer with eos indication to force typefinding */
 735         gst_tag_demux_chain_buffer (demux, gst_buffer_new (), TRUE);
 736 
 737         if (!gst_pad_has_current_caps (demux-&gt;priv-&gt;srcpad)) {
 738         GST_ELEMENT_ERROR (demux, STREAM, TYPE_NOT_FOUND, (NULL), (NULL));
 739       }
 740       }
 741       ret = gst_pad_event_default (pad, parent, event);
 742       break;
 743     case GST_EVENT_SEGMENT:
 744     {
 745       gst_event_copy_segment (event, &amp;demux-&gt;priv-&gt;segment);
 746 
 747       demux-&gt;priv-&gt;need_newseg = TRUE;
 748       gst_event_unref (event);
 749       ret = TRUE;
 750       break;
 751     }
 752     case GST_EVENT_FLUSH_STOP:
 753     case GST_EVENT_FLUSH_START:
 754       ret = gst_pad_event_default (pad, parent, event);
 755       break;
 756     case GST_EVENT_CAPS:
 757       /* we drop the caps event. We do typefind and push a new caps event. */
 758       ret = gst_pad_event_default (pad, parent, event);
 759       break;
 760     default:
 761       if (demux-&gt;priv-&gt;need_newseg &amp;&amp; GST_EVENT_IS_SERIALIZED (event)) {
 762         /* Cache all events if we have a pending segment, so they don&#39;t get
 763          * lost (esp. tag events) */
 764         GST_INFO_OBJECT (demux, &quot;caching event: %&quot; GST_PTR_FORMAT, event);
 765         GST_OBJECT_LOCK (demux);
 766         demux-&gt;priv-&gt;pending_events =
 767             g_list_append (demux-&gt;priv-&gt;pending_events, event);
 768         GST_OBJECT_UNLOCK (demux);
 769         ret = TRUE;
 770       } else {
 771         ret = gst_pad_event_default (pad, parent, event);
 772       }
 773       break;
 774   }
 775 
 776   return ret;
 777 }
 778 
 779 static gboolean
 780 gst_tag_demux_get_upstream_size (GstTagDemux * tagdemux)
 781 {
 782   gint64 len;
 783 
 784   /* Short-cut if we already queried upstream */
 785   if (tagdemux-&gt;priv-&gt;upstream_size &gt; 0)
 786     return TRUE;
 787 
 788   if (!gst_pad_peer_query_duration (tagdemux-&gt;priv-&gt;sinkpad, GST_FORMAT_BYTES,
 789           &amp;len) || len &lt;= 0) {
 790     return FALSE;
 791   }
 792 
 793   tagdemux-&gt;priv-&gt;upstream_size = len;
 794   return TRUE;
 795 }
 796 
 797 static gboolean
 798 gst_tag_demux_seek_pull (GstTagDemux * tagdemux, GstEvent * event)
 799 {
 800   GstSeekFlags flags;
 801   GstSeekType start_type, stop_type;
 802   GstFormat format;
 803   gboolean flush;
 804   gdouble rate;
 805   gint64 start, stop;
 806   GstSegment seeksegment = { 0, };
 807 
 808   gst_event_parse_seek (event, &amp;rate, &amp;format, &amp;flags, &amp;start_type, &amp;start,
 809       &amp;stop_type, &amp;stop);
 810 
 811   /* we can only seek on bytes */
 812   if (format != GST_FORMAT_BYTES) {
 813     GST_DEBUG_OBJECT (tagdemux, &quot;Can only seek on BYTES&quot;);
 814     return FALSE;
 815   }
 816 
 817   if (tagdemux-&gt;priv-&gt;state != GST_TAG_DEMUX_STREAMING) {
 818     GST_DEBUG_OBJECT (tagdemux, &quot;Can only seek if streaming already&quot;);
 819     return FALSE;
 820   }
 821 
 822   switch (start_type) {
 823     case GST_SEEK_TYPE_SET:
 824       if (start == -1)
 825         start = 0;
 826       start += tagdemux-&gt;priv-&gt;strip_start;
 827       break;
 828     case GST_SEEK_TYPE_END:
 829       /* Adjust the seek to be relative to the start of any end tag
 830        * (note: 10 bytes before end is represented by stop=-10) */
 831       if (start &gt; 0)
 832         start = 0;
 833       start -= tagdemux-&gt;priv-&gt;strip_end;
 834       break;
 835     case GST_SEEK_TYPE_NONE:
 836     default:
 837       break;
 838   }
 839   switch (stop_type) {
 840     case GST_SEEK_TYPE_SET:
 841       if (stop != -1) {
 842         /* -1 means the end of the file, pass it upstream intact */
 843         stop += tagdemux-&gt;priv-&gt;strip_start;
 844       }
 845       break;
 846     case GST_SEEK_TYPE_END:
 847       /* Adjust the seek to be relative to the start of any end tag
 848        * (note: 10 bytes before end is represented by stop=-10) */
 849       if (stop &gt; 0)
 850         stop = 0;
 851       stop -= tagdemux-&gt;priv-&gt;strip_end;
 852       break;
 853     case GST_SEEK_TYPE_NONE:
 854     default:
 855       break;
 856   }
 857 
 858   /* copy segment, we need this because we still need the old
 859    * segment when we close the current segment. */
 860   memcpy (&amp;seeksegment, &amp;tagdemux-&gt;priv-&gt;segment, sizeof (GstSegment));
 861 
 862   GST_DEBUG_OBJECT (tagdemux, &quot;configuring seek&quot;);
 863   gst_segment_do_seek (&amp;seeksegment, rate, format, flags,
 864       start_type, start, stop_type, stop, NULL);
 865 
 866   flush = ! !(flags &amp; GST_SEEK_FLAG_FLUSH);
 867 
 868   GST_DEBUG_OBJECT (tagdemux, &quot;New segment %&quot; GST_SEGMENT_FORMAT, &amp;seeksegment);
 869 
 870   if (flush) {
 871     GST_DEBUG_OBJECT (tagdemux, &quot;Starting flush&quot;);
 872     gst_pad_push_event (tagdemux-&gt;priv-&gt;sinkpad, gst_event_new_flush_start ());
 873     gst_pad_push_event (tagdemux-&gt;priv-&gt;srcpad, gst_event_new_flush_start ());
 874   } else {
 875     GST_DEBUG_OBJECT (tagdemux, &quot;Non-flushing seek, pausing task&quot;);
 876     gst_pad_pause_task (tagdemux-&gt;priv-&gt;sinkpad);
 877   }
 878 
 879   /* now grab the stream lock so that streaming cannot continue, for
 880    * non flushing seeks when the element is in PAUSED this could block
 881    * forever. */
 882   GST_DEBUG_OBJECT (tagdemux, &quot;Waiting for streaming to stop&quot;);
 883   GST_PAD_STREAM_LOCK (tagdemux-&gt;priv-&gt;sinkpad);
 884 
 885   if (flush) {
 886     GST_DEBUG_OBJECT (tagdemux, &quot;Stopping flush&quot;);
 887     gst_pad_push_event (tagdemux-&gt;priv-&gt;sinkpad,
 888         gst_event_new_flush_stop (TRUE));
 889     gst_pad_push_event (tagdemux-&gt;priv-&gt;srcpad,
 890         gst_event_new_flush_stop (TRUE));
 891   }
 892 
 893   /* now update the real segment info */
 894   GST_DEBUG_OBJECT (tagdemux, &quot;Committing new seek segment&quot;);
 895   memcpy (&amp;tagdemux-&gt;priv-&gt;segment, &amp;seeksegment, sizeof (GstSegment));
 896   tagdemux-&gt;priv-&gt;offset = tagdemux-&gt;priv-&gt;segment.start;
 897 
 898   /* notify start of new segment */
 899   if (tagdemux-&gt;priv-&gt;segment.flags &amp; GST_SEGMENT_FLAG_SEGMENT) {
 900     GstMessage *msg;
 901 
 902     msg = gst_message_new_segment_start (GST_OBJECT (tagdemux),
 903         GST_FORMAT_BYTES, tagdemux-&gt;priv-&gt;segment.start);
 904     gst_element_post_message (GST_ELEMENT (tagdemux), msg);
 905   }
 906 
 907   tagdemux-&gt;priv-&gt;need_newseg = TRUE;
 908 
 909   /* restart our task since it might have been stopped when we did the
 910    * flush. */
 911   gst_pad_start_task (tagdemux-&gt;priv-&gt;sinkpad,
 912       (GstTaskFunction) gst_tag_demux_element_loop, tagdemux, NULL);
 913 
 914   /* streaming can continue now */
 915   GST_PAD_STREAM_UNLOCK (tagdemux-&gt;priv-&gt;sinkpad);
 916 
 917   return TRUE;
 918 }
 919 
 920 static gboolean
 921 gst_tag_demux_seek_push (GstTagDemux * tagdemux, GstEvent * event)
 922 {
 923   gboolean res = FALSE;
 924       gdouble rate;
 925       GstFormat format;
 926   GstSeekType start_type, stop_type;
 927       GstSeekFlags flags;
 928   gint64 start, stop;
 929 
 930       gst_event_parse_seek (event, &amp;rate, &amp;format, &amp;flags,
 931       &amp;start_type, &amp;start, &amp;stop_type, &amp;stop);
 932 
 933       if (format == GST_FORMAT_BYTES &amp;&amp;
 934           tagdemux-&gt;priv-&gt;state == GST_TAG_DEMUX_STREAMING &amp;&amp;
 935           gst_pad_is_linked (tagdemux-&gt;priv-&gt;sinkpad)) {
 936         GstEvent *upstream;
 937 
 938     switch (start_type) {
 939           case GST_SEEK_TYPE_SET:
 940         if (start == -1)
 941           start = 0;
 942         start += tagdemux-&gt;priv-&gt;strip_start;
 943             break;
 944           case GST_SEEK_TYPE_END:
 945             /* Adjust the seek to be relative to the start of any end tag
 946              * (note: 10 bytes before end is represented by stop=-10) */
 947         if (start &gt; 0)
 948           start = 0;
 949         start -= tagdemux-&gt;priv-&gt;strip_end;
 950             break;
 951           case GST_SEEK_TYPE_NONE:
 952           default:
 953             break;
 954         }
 955         switch (stop_type) {
 956           case GST_SEEK_TYPE_SET:
 957             if (stop != -1) {
 958               /* -1 means the end of the file, pass it upstream intact */
 959               stop += tagdemux-&gt;priv-&gt;strip_start;
 960             }
 961             break;
 962           case GST_SEEK_TYPE_END:
 963             /* Adjust the seek to be relative to the start of any end tag
 964              * (note: 10 bytes before end is represented by stop=-10) */
 965             if (stop &gt; 0)
 966               stop = 0;
 967             stop -= tagdemux-&gt;priv-&gt;strip_end;
 968             break;
 969           case GST_SEEK_TYPE_NONE:
 970           default:
 971             break;
 972         }
 973         upstream = gst_event_new_seek (rate, format, flags,
 974         start_type, start, stop_type, stop);
 975         res = gst_pad_push_event (tagdemux-&gt;priv-&gt;sinkpad, upstream);
 976   } else if (format == GST_FORMAT_TIME &amp;&amp;
 977       tagdemux-&gt;priv-&gt;state == GST_TAG_DEMUX_STREAMING &amp;&amp;
 978       gst_pad_is_linked (tagdemux-&gt;priv-&gt;sinkpad)) {
 979     res = gst_pad_push_event (tagdemux-&gt;priv-&gt;sinkpad, gst_event_ref (event));
 980       }
 981 
 982   return res;
 983 }
 984 
 985 static gboolean
 986 gst_tag_demux_srcpad_event (GstPad * pad, GstObject * parent, GstEvent * event)
 987 {
 988   GstTagDemux *tagdemux;
 989   gboolean res = FALSE;
 990 
 991   tagdemux = GST_TAG_DEMUX (parent);
 992 
 993   /* Handle SEEK events, with adjusted byte offsets and sizes. */
 994 
 995   switch (GST_EVENT_TYPE (event)) {
 996     case GST_EVENT_SEEK:
 997     {
 998       if (GST_PAD_MODE (tagdemux-&gt;priv-&gt;sinkpad) == GST_PAD_MODE_PUSH)
 999         res = gst_tag_demux_seek_push (tagdemux, event);
1000       else
1001         res = gst_tag_demux_seek_pull (tagdemux, event);
1002       break;
1003     }
1004 #ifdef GSTREAMER_LITE
1005     // We need to pass down any flush events. We should not cache flush events.
1006     // In some cases we may have two seek command executing sequentially and it will result to following event sequence:
1007     // Seek 1
1008     // GST_EVENT_FLUSH_START - Pass down
1009     // GST_EVENT_FLUSH_STOP - Pass down
1010     // GST_EVENT_NEWSEGMENT - Cached and demux-&gt;priv-&gt;need_newseg is TRUE
1011     // Seek 2
1012     // GST_EVENT_FLUSH_START - Cached, because demux-&gt;priv-&gt;need_newseg is TRUE
1013     // GST_EVENT_FLUSH_STOP - Cached, because demux-&gt;priv-&gt;need_newseg is TRUE
1014     // GST_EVENT_NEWSEGMENT - Overwrites cached NEWSEGMENT from seek 1 and demux-&gt;priv-&gt;need_newseg is TRUE
1015     // Data buffer received by tag demux
1016     // Delivering in following sequence GST_EVENT_NEWSEGMENT, GST_EVENT_FLUSH_START, GST_EVENT_FLUSH_STOP and Data Buffer (Issue: Data Buffer without new segment)
1017     case GST_EVENT_FLUSH_START:
1018         res = gst_pad_event_default (pad, parent, event);
1019         break;
1020     case GST_EVENT_FLUSH_STOP:
1021         res = gst_pad_event_default (pad, parent, event);
1022         break;
1023 #endif // GSTREAMER_LITE
1024     default:
1025       res = gst_pad_push_event (tagdemux-&gt;priv-&gt;sinkpad, event);
1026       event = NULL;
1027       break;
1028   }
1029 
1030   if (event)
1031     gst_event_unref (event);
1032 
1033   return res;
1034 }
1035 
1036 /* Read and interpret any end tag when activating in pull_range.
1037  * Returns FALSE if pad activation should fail. */
1038 static GstFlowReturn
1039 gst_tag_demux_pull_end_tag (GstTagDemux * demux, GstTagList ** tags)
1040 {
1041   GstTagDemuxResult parse_ret;
1042   GstTagDemuxClass *klass;
1043   GstFlowReturn flow_ret;
1044   GstTagList *new_tags = NULL;
1045   GstBuffer *buffer = NULL;
1046   gboolean have_tag;
1047   guint64 offset;
1048   guint tagsize;
1049   gsize bsize;
1050 
1051   klass = GST_TAG_DEMUX_CLASS (G_OBJECT_GET_CLASS (demux));
1052 
1053   g_assert (klass-&gt;identify_tag != NULL);
1054   g_assert (klass-&gt;parse_tag != NULL);
1055 
1056   if (klass-&gt;min_end_size == 0) {
1057     GST_DEBUG_OBJECT (demux, &quot;Not looking for tag at the end&quot;);
1058     return GST_FLOW_OK;
1059   }
1060 
1061   if (demux-&gt;priv-&gt;upstream_size &lt; klass-&gt;min_end_size) {
1062     GST_DEBUG_OBJECT (demux, &quot;File too small&quot;);
1063     return GST_FLOW_OK;
1064   }
1065 
1066   /* Pull enough to identify the tag and retrieve its total size */
1067   offset = demux-&gt;priv-&gt;upstream_size - klass-&gt;min_end_size;
1068 
1069   flow_ret = gst_pad_pull_range (demux-&gt;priv-&gt;sinkpad, offset,
1070       klass-&gt;min_end_size, &amp;buffer);
1071 
1072   if (flow_ret != GST_FLOW_OK) {
1073     GST_DEBUG_OBJECT (demux, &quot;Could not read tag header from end of file, &quot;
1074         &quot;ret = %s&quot;, gst_flow_get_name (flow_ret));
1075     goto done;
1076   }
1077 
1078   bsize = gst_buffer_get_size (buffer);
1079 
1080   if (bsize &lt; klass-&gt;min_end_size) {
1081     GST_DEBUG_OBJECT (demux, &quot;Only managed to read %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
1082         &quot;from file (required: %u bytes)&quot;, bsize, klass-&gt;min_end_size);
1083     flow_ret = GST_FLOW_EOS;
1084     goto done;
1085   }
1086 
1087   have_tag = klass-&gt;identify_tag (demux, buffer, FALSE, &amp;tagsize);
1088 
1089   if (!have_tag) {
1090     GST_DEBUG_OBJECT (demux, &quot;Could not find tag at end&quot;);
1091     flow_ret = GST_FLOW_OK;
1092     goto done;
1093   }
1094 
1095   /* Now pull the entire tag */
1096   do {
1097     guint newsize, saved_size;
1098 
1099     GST_DEBUG_OBJECT (demux, &quot;Identified tag at end, size=%u bytes&quot;, tagsize);
1100 
1101     demux-&gt;priv-&gt;strip_end = tagsize;
1102 
1103     g_assert (tagsize &gt;= klass-&gt;min_end_size);
1104 
1105     /* Get buffer that&#39;s exactly the requested size */
1106     if (bsize != tagsize) {
1107       gst_buffer_unref (buffer);
1108       buffer = NULL;
1109 
1110       offset = demux-&gt;priv-&gt;upstream_size - tagsize;
1111 
1112       flow_ret = gst_pad_pull_range (demux-&gt;priv-&gt;sinkpad, offset,
1113           tagsize, &amp;buffer);
1114 
1115       if (flow_ret != GST_FLOW_OK) {
1116         GST_DEBUG_OBJECT (demux, &quot;Could not read data from end of file at &quot;
1117             &quot;offset %&quot; G_GUINT64_FORMAT &quot;. ret = %s&quot;, offset,
1118             gst_flow_get_name (flow_ret));
1119         goto done;
1120       }
1121 
1122       bsize = gst_buffer_get_size (buffer);
1123 
1124       if (bsize &lt; tagsize) {
1125         GST_DEBUG_OBJECT (demux, &quot;Only managed to read %&quot; G_GSIZE_FORMAT
1126             &quot; bytes from file&quot;, bsize);
1127         flow_ret = GST_FLOW_EOS;
1128         goto done;
1129       }
1130     }
1131 
1132     GST_BUFFER_OFFSET (buffer) = offset;
1133 
1134     saved_size = bsize;
1135     gst_buffer_set_size (buffer, tagsize);
1136     newsize = tagsize;
1137 
1138     parse_ret = klass-&gt;parse_tag (demux, buffer, FALSE, &amp;newsize, &amp;new_tags);
1139 
1140     gst_buffer_set_size (buffer, saved_size);
1141 
1142     switch (parse_ret) {
1143       case GST_TAG_DEMUX_RESULT_OK:
1144         flow_ret = GST_FLOW_OK;
1145         demux-&gt;priv-&gt;strip_end = newsize;
1146         GST_DEBUG_OBJECT (demux, &quot;Read tag at end, size %d&quot;,
1147             demux-&gt;priv-&gt;strip_end);
1148         break;
1149       case GST_TAG_DEMUX_RESULT_BROKEN_TAG:
1150         flow_ret = GST_FLOW_OK;
1151         demux-&gt;priv-&gt;strip_end = newsize;
1152         GST_WARNING_OBJECT (demux, &quot;Ignoring broken tag at end, size %d&quot;,
1153             demux-&gt;priv-&gt;strip_end);
1154         break;
1155       case GST_TAG_DEMUX_RESULT_AGAIN:
1156         GST_DEBUG_OBJECT (demux, &quot;Re-parse, this time with %d bytes&quot;, newsize);
1157         g_assert (newsize != tagsize);
1158         tagsize = newsize;
1159         break;
1160     }
1161   } while (parse_ret == GST_TAG_DEMUX_RESULT_AGAIN);
1162 
1163   *tags = new_tags;
1164   new_tags = NULL;
1165 
1166 done:
1167   if (new_tags)
1168     gst_tag_list_unref (new_tags);
1169   if (buffer)
1170     gst_buffer_unref (buffer);
1171   return flow_ret;
1172 }
1173 
1174 /* Read and interpret any tag at the start when activating in
1175  * pull_range. Returns FALSE if pad activation should fail. */
1176 static GstFlowReturn
1177 gst_tag_demux_pull_start_tag (GstTagDemux * demux, GstTagList ** tags)
1178 {
1179   GstTagDemuxResult parse_ret;
1180   GstTagDemuxClass *klass;
1181   GstFlowReturn flow_ret;
1182   GstTagList *new_tags = NULL;
1183   GstBuffer *buffer = NULL;
1184   gboolean have_tag;
1185   guint req, tagsize;
1186   gsize bsize;
1187 
1188   klass = GST_TAG_DEMUX_CLASS (G_OBJECT_GET_CLASS (demux));
1189 
1190   g_assert (klass-&gt;identify_tag != NULL);
1191   g_assert (klass-&gt;parse_tag != NULL);
1192 
1193   if (klass-&gt;min_start_size == 0) {
1194     GST_DEBUG_OBJECT (demux, &quot;Not looking for tag at the beginning&quot;);
1195     return GST_FLOW_OK;
1196   }
1197 
1198   /* Handle tag at start. Try with 4kB to start with */
1199   req = MAX (klass-&gt;min_start_size, 4096);
1200 
1201   /* Pull enough to identify the tag and retrieve its total size */
1202   flow_ret = gst_pad_pull_range (demux-&gt;priv-&gt;sinkpad, 0, req, &amp;buffer);
1203   if (flow_ret != GST_FLOW_OK) {
1204     GST_DEBUG_OBJECT (demux, &quot;Could not read data from start of file ret=%s&quot;,
1205         gst_flow_get_name (flow_ret));
1206     goto done;
1207   }
1208 
1209   bsize = gst_buffer_get_size (buffer);
1210 
1211   if (bsize &lt; klass-&gt;min_start_size) {
1212     GST_DEBUG_OBJECT (demux, &quot;Only managed to read %&quot; G_GSIZE_FORMAT
1213         &quot; bytes from file - no tag in this file&quot;, bsize);
1214     flow_ret = GST_FLOW_EOS;
1215     goto done;
1216   }
1217 
1218   have_tag = klass-&gt;identify_tag (demux, buffer, TRUE, &amp;tagsize);
1219 
1220   if (!have_tag) {
1221     GST_DEBUG_OBJECT (demux, &quot;Could not find start tag&quot;);
1222     flow_ret = GST_FLOW_OK;
1223     goto done;
1224   }
1225 
1226   GST_DEBUG_OBJECT (demux, &quot;Identified start tag, size = %u bytes&quot;, tagsize);
1227 
1228   do {
1229     guint newsize, saved_size;
1230 
1231     demux-&gt;priv-&gt;strip_start = tagsize;
1232 
1233     /* Now pull the entire tag */
1234     g_assert (tagsize &gt;= klass-&gt;min_start_size);
1235 
1236     if (bsize &lt; tagsize) {
1237       gst_buffer_unref (buffer);
1238       buffer = NULL;
1239 
1240       flow_ret = gst_pad_pull_range (demux-&gt;priv-&gt;sinkpad, 0, tagsize, &amp;buffer);
1241       if (flow_ret != GST_FLOW_OK) {
1242         GST_DEBUG_OBJECT (demux, &quot;Could not read data from start of file, &quot;
1243             &quot;ret = %s&quot;, gst_flow_get_name (flow_ret));
1244         goto done;
1245       }
1246 
1247       bsize = gst_buffer_get_size (buffer);
1248 
1249       if (bsize &lt; tagsize) {
1250         GST_DEBUG_OBJECT (demux, &quot;Only managed to read %&quot; G_GSIZE_FORMAT
1251             &quot; bytes from file&quot;, bsize);
1252         GST_ELEMENT_ERROR (demux, STREAM, DECODE,
1253             (_(&quot;Failed to read tag: not enough data&quot;)), (NULL));
1254         flow_ret = GST_FLOW_EOS;
1255         goto done;
1256       }
1257     }
1258 
1259     saved_size = bsize;
1260     gst_buffer_set_size (buffer, tagsize);
1261     newsize = tagsize;
1262     parse_ret = klass-&gt;parse_tag (demux, buffer, TRUE, &amp;newsize, &amp;new_tags);
1263 
1264     gst_buffer_set_size (buffer, saved_size);
1265 
1266     switch (parse_ret) {
1267       case GST_TAG_DEMUX_RESULT_OK:
1268         flow_ret = GST_FLOW_OK;
1269         demux-&gt;priv-&gt;strip_start = newsize;
1270         GST_DEBUG_OBJECT (demux, &quot;Read start tag of size %d&quot;, newsize);
1271         break;
1272       case GST_TAG_DEMUX_RESULT_BROKEN_TAG:
1273         flow_ret = GST_FLOW_OK;
1274         demux-&gt;priv-&gt;strip_start = newsize;
1275         GST_WARNING_OBJECT (demux, &quot;Ignoring broken start tag of size %d&quot;,
1276             demux-&gt;priv-&gt;strip_start);
1277         break;
1278       case GST_TAG_DEMUX_RESULT_AGAIN:
1279         GST_DEBUG_OBJECT (demux, &quot;Re-parse, this time with %d bytes&quot;, newsize);
1280         g_assert (newsize != tagsize);
1281         tagsize = newsize;
1282         break;
1283     }
1284   } while (parse_ret == GST_TAG_DEMUX_RESULT_AGAIN);
1285 
1286   *tags = new_tags;
1287   new_tags = NULL;
1288 
1289 done:
1290   if (new_tags)
1291     gst_tag_list_unref (new_tags);
1292   if (buffer)
1293     gst_buffer_unref (buffer);
1294   return flow_ret;
1295 }
1296 
1297 /* This function operates similarly to gst_type_find_element_loop
1298  * in the typefind element
1299  * 1. try to read tags in pull mode
1300  * 2. typefind the contents
1301  * 3. if we didn&#39;t find any caps, fail.
1302  * 4. set caps on srcpad
1303  */
1304 static GstFlowReturn
1305 gst_tag_demux_element_find (GstTagDemux * demux)
1306 {
1307   GstTagDemuxClass *klass;
1308   GstTypeFindProbability probability = 0;
1309   GstFlowReturn ret = GST_FLOW_OK;
1310   GstTagList *start_tags = NULL;
1311   GstTagList *end_tags = NULL;
1312   gboolean e_tag_ok, s_tag_ok;
1313   GstCaps *caps = NULL;
1314 
1315   /* Look for tags at start and end of file */
1316   GST_DEBUG_OBJECT (demux, &quot;Activated pull mode. Looking for tags&quot;);
1317   if (!gst_tag_demux_get_upstream_size (demux))
1318     goto no_size;
1319 
1320   demux-&gt;priv-&gt;strip_start = 0;
1321   demux-&gt;priv-&gt;strip_end = 0;
1322 
1323   /* 1 - Read tags */
1324   ret = gst_tag_demux_pull_start_tag (demux, &amp;start_tags);
1325   if (ret != GST_FLOW_OK &amp;&amp; ret != GST_FLOW_EOS)
1326     goto read_tag_error;
1327   s_tag_ok = ret == GST_FLOW_OK;
1328   ret = gst_tag_demux_pull_end_tag (demux, &amp;end_tags);
1329   if (ret != GST_FLOW_OK &amp;&amp; ret != GST_FLOW_EOS)
1330     goto read_tag_error;
1331   e_tag_ok = ret == GST_FLOW_OK;
1332   ret = GST_FLOW_OK;
1333 
1334   klass = GST_TAG_DEMUX_CLASS (G_OBJECT_GET_CLASS (demux));
1335 
1336   if (klass-&gt;merge_tags != NULL) {
1337     demux-&gt;priv-&gt;parsed_tags = klass-&gt;merge_tags (demux, start_tags, end_tags);
1338   } else {
1339     /* we merge in REPLACE mode, so put the less important tags first, which
1340      * we&#39;ll just assume is the end tag (subclasses may change this behaviour
1341      * or make it configurable by overriding the merge_tags vfunc) */
1342     demux-&gt;priv-&gt;parsed_tags =
1343         gst_tag_list_merge (end_tags, start_tags, GST_TAG_MERGE_REPLACE);
1344   }
1345 
1346   if (start_tags)
1347     gst_tag_list_unref (start_tags);
1348   if (end_tags)
1349     gst_tag_list_unref (end_tags);
1350 
1351   /* Only happens if both are EOS, i.e. not enough data could be read */
1352   if (!e_tag_ok &amp;&amp; !s_tag_ok)
1353     goto no_tags;
1354 
1355   if (demux-&gt;priv-&gt;parsed_tags != NULL) {
1356     demux-&gt;priv-&gt;send_tag_event = TRUE;
1357   }
1358 
1359   if (demux-&gt;priv-&gt;upstream_size &lt;=
1360       demux-&gt;priv-&gt;strip_start + demux-&gt;priv-&gt;strip_end)
1361     goto no_data;
1362 
1363   /* 2 - Do typefinding on data, but not if downstream is in charge */
1364   if (GST_PAD_MODE (demux-&gt;priv-&gt;srcpad) == GST_PAD_MODE_PULL)
1365     goto skip_typefinding;
1366 
1367   ret = gst_type_find_helper_get_range_full (GST_OBJECT (demux), NULL,
1368       (GstTypeFindHelperGetRangeFunction) gst_tag_demux_read_range,
1369       demux-&gt;priv-&gt;upstream_size
1370       - (demux-&gt;priv-&gt;strip_start + demux-&gt;priv-&gt;strip_end), NULL,
1371       &amp;caps, &amp;probability);
1372   if (ret != GST_FLOW_OK)
1373     goto read_tag_error;
1374 
1375   GST_INFO_OBJECT (demux, &quot;Found type %&quot; GST_PTR_FORMAT &quot; with a &quot;
1376       &quot;probability of %u&quot;, caps, probability);
1377 
1378   /* 3 - If we didn&#39;t find the caps, fail */
1379   if (caps == NULL)
1380     goto no_caps;
1381 
1382   /* tag reading and typefinding were already done, don&#39;t do them again in
1383    * the chain function if we end up in push mode */
1384   demux-&gt;priv-&gt;state = GST_TAG_DEMUX_STREAMING;
1385 
1386   /* 6 Set the srcpad caps now that we know them */
1387   gst_tag_demux_set_src_caps (demux, caps);
1388       gst_caps_unref (caps);
1389 
1390 skip_typefinding:
1391 
1392   /* set it again, in case we skipped typefinding */
1393   demux-&gt;priv-&gt;state = GST_TAG_DEMUX_STREAMING;
1394   demux-&gt;priv-&gt;offset += demux-&gt;priv-&gt;strip_start;
1395 
1396   return ret;
1397 
1398   /* ERRORS */
1399 no_size:
1400   {
1401     GST_ELEMENT_ERROR (demux, STREAM, TYPE_NOT_FOUND,
1402         (&quot;Could not get stream size&quot;), (NULL));
1403     return GST_FLOW_ERROR;
1404   }
1405 read_tag_error:
1406   {
1407     if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS)
1408       GST_ELEMENT_FLOW_ERROR (demux, ret);
1409     return ret;
1410   }
1411 no_tags:
1412   {
1413     GST_ELEMENT_ERROR (demux, STREAM, TYPE_NOT_FOUND,
1414         (&quot;Could not get start and/or end tag&quot;), (NULL));
1415     return GST_FLOW_ERROR;
1416   }
1417 no_data:
1418   {
1419     /* There was no data (probably due to a truncated file) */
1420     /* so we don&#39;t know about type either */
1421     GST_ELEMENT_ERROR (demux, STREAM, TYPE_NOT_FOUND, (&quot;No data in file&quot;),
1422         (NULL));
1423     return GST_FLOW_ERROR;
1424   }
1425 no_caps:
1426   {
1427     GST_ELEMENT_ERROR (demux, STREAM, TYPE_NOT_FOUND,
1428         (&quot;Could not detect type of contents&quot;), (NULL));
1429     return GST_FLOW_ERROR;
1430   }
1431 }
1432 
1433 /* This function operates similarly to gst_type_find_element_loop
1434  * in the typefind element
1435  * 1. try to read tags in pull mode
1436  * 2. typefind the contents
1437  * 3. if we didn&#39;t find any caps, fail.
1438  * 4. set caps on srcpad
1439  */
1440 static void
1441 gst_tag_demux_element_loop (GstTagDemux * demux)
1442 {
1443   GstFlowReturn ret;
1444 
1445   switch (demux-&gt;priv-&gt;state) {
1446     case GST_TAG_DEMUX_READ_START_TAG:
1447     case GST_TAG_DEMUX_TYPEFINDING:
1448       ret = gst_tag_demux_element_find (demux);
1449       break;
1450     case GST_TAG_DEMUX_STREAMING:
1451     {
1452       GstBuffer *outbuf = NULL;
1453 
1454       if (demux-&gt;priv-&gt;need_newseg) {
1455         demux-&gt;priv-&gt;need_newseg = FALSE;
1456         /* FIXME: check segment, should be 0-N for downstream */
1457         gst_tag_demux_send_new_segment (demux);
1458   }
1459 
1460       /* Send our own pending tag event */
1461       if (demux-&gt;priv-&gt;send_tag_event) {
1462         gst_tag_demux_send_tag_event (demux);
1463         demux-&gt;priv-&gt;send_tag_event = FALSE;
1464       }
1465 
1466       /* Pull data and push it downstream */
1467       ret = gst_pad_pull_range (demux-&gt;priv-&gt;sinkpad, demux-&gt;priv-&gt;offset,
1468           DEFAULT_PULL_BLOCKSIZE, &amp;outbuf);
1469 
1470       if (ret != GST_FLOW_OK)
1471         break;
1472 
1473       GST_BUFFER_OFFSET (outbuf) =
1474           demux-&gt;priv-&gt;offset - demux-&gt;priv-&gt;strip_start;
1475       demux-&gt;priv-&gt;offset += gst_buffer_get_size (outbuf);
1476       GST_BUFFER_OFFSET_END (outbuf) =
1477           demux-&gt;priv-&gt;offset - demux-&gt;priv-&gt;strip_start;
1478 
1479       ret = gst_pad_push (demux-&gt;priv-&gt;srcpad, outbuf);
1480       break;
1481   }
1482     default:
1483       ret = GST_FLOW_ERROR;
1484       break;
1485   }
1486   if (ret != GST_FLOW_OK)
1487     goto pause;
1488 
1489   return;
1490 
1491   /* ERRORS */
1492 pause:
1493   {
1494     const gchar *reason = gst_flow_get_name (ret);
1495     gboolean push_eos = FALSE;
1496 
1497     GST_LOG_OBJECT (demux, &quot;pausing task, reason %s&quot;, reason);
1498     gst_pad_pause_task (demux-&gt;priv-&gt;sinkpad);
1499 
1500     if (ret == GST_FLOW_EOS) {
1501       /* perform EOS logic */
1502 
1503       if (demux-&gt;priv-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
1504         gint64 stop;
1505 
1506         /* for segment playback we need to post when (in stream time)
1507          * we stopped, this is either stop (when set) or the duration. */
1508         if ((stop = demux-&gt;priv-&gt;segment.stop) == -1)
1509           stop = demux-&gt;priv-&gt;offset;
1510 
1511         GST_LOG_OBJECT (demux, &quot;Sending segment done, at end of segment&quot;);
1512         gst_element_post_message (GST_ELEMENT_CAST (demux),
1513             gst_message_new_segment_done (GST_OBJECT_CAST (demux),
1514                 GST_FORMAT_BYTES, stop));
1515         gst_pad_push_event (demux-&gt;priv-&gt;srcpad,
1516             gst_event_new_segment_done (GST_FORMAT_BYTES, stop));
1517       } else {
1518         push_eos = TRUE;
1519   }
1520     } else if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS) {
1521       /* for fatal errors we post an error message */
1522       GST_ELEMENT_FLOW_ERROR (demux, ret);
1523       push_eos = TRUE;
1524     }
1525     if (push_eos) {
1526       /* send EOS, and prevent hanging if no streams yet */
1527       GST_LOG_OBJECT (demux, &quot;Sending EOS, at end of stream&quot;);
1528       gst_pad_push_event (demux-&gt;priv-&gt;srcpad, gst_event_new_eos ());
1529     }
1530     return;
1531   }
1532 }
1533 
1534 static gboolean
1535 gst_tag_demux_sink_activate_mode (GstPad * pad, GstObject * parent,
1536     GstPadMode mode, gboolean active)
1537 {
1538   GstTagDemux *demux = GST_TAG_DEMUX (parent);
1539   gboolean res;
1540 
1541   switch (mode) {
1542     case GST_PAD_MODE_PULL:
1543       if (active) {
1544         demux-&gt;priv-&gt;need_newseg = TRUE;
1545         demux-&gt;priv-&gt;offset = 0;
1546         res = TRUE;
1547       } else {
1548         res = gst_pad_stop_task (pad);
1549       }
1550       break;
1551     default:
1552       res = TRUE;
1553       break;
1554   }
1555 
1556   if (active)
1557     GST_TAG_DEMUX (parent)-&gt;priv-&gt;state = GST_TAG_DEMUX_READ_START_TAG;
1558 
1559   return res;
1560 }
1561 
1562 static gboolean
1563 gst_tag_demux_sink_activate (GstPad * sinkpad, GstObject * parent)
1564 {
1565   GstTagDemux *demux;
1566   GstQuery *query;
1567   gboolean pull_mode;
1568 
1569   demux = GST_TAG_DEMUX (parent);
1570 
1571   /* 1: */
1572   /* If we can activate pull_range upstream, then read any end and start
1573    * tags, otherwise activate in push mode and the chain function will
1574    * collect buffers, read the start tag and output a buffer to end
1575    * preroll.
1576    */
1577   query = gst_query_new_scheduling ();
1578 
1579   if (!gst_pad_peer_query (sinkpad, query)) {
1580     gst_query_unref (query);
1581     goto activate_push;
1582   }
1583 
1584   pull_mode = gst_query_has_scheduling_mode_with_flags (query,
1585       GST_PAD_MODE_PULL, GST_SCHEDULING_FLAG_SEEKABLE);
1586   gst_query_unref (query);
1587 
1588   if (!pull_mode)
1589     goto activate_push;
1590 
1591   if (!gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PULL, TRUE))
1592     goto activate_push;
1593 
1594   /* only start our task if we ourselves decide to start in pull mode */
1595   return gst_pad_start_task (sinkpad,
1596       (GstTaskFunction) gst_tag_demux_element_loop, demux, NULL);
1597 
1598 activate_push:
1599   {
1600     GST_DEBUG_OBJECT (demux, &quot;No pull mode. Changing to push, but won&#39;t be &quot;
1601         &quot;able to read end tags&quot;);
1602     return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PUSH, TRUE);
1603   }
1604 }
1605 
1606 static gboolean
1607 gst_tag_demux_src_activate_mode (GstPad * pad, GstObject * parent,
1608     GstPadMode mode, gboolean active)
1609 {
1610   gboolean res;
1611   GstTagDemux *demux = GST_TAG_DEMUX (parent);
1612 
1613   switch (mode) {
1614     case GST_PAD_MODE_PULL:
1615       /* make sure our task stops pushing, we can&#39;t call _stop here
1616        * because this activation might happen from the streaming thread. */
1617       gst_pad_pause_task (demux-&gt;priv-&gt;sinkpad);
1618       res = gst_pad_activate_mode (demux-&gt;priv-&gt;sinkpad, mode, active);
1619       break;
1620     default:
1621       res = TRUE;
1622       break;
1623   }
1624   return res;
1625 }
1626 
1627 static inline GstFlowReturn
1628 gst_tag_demux_ensure_tags (GstTagDemux * demux)
1629 {
1630   GstFlowReturn flow = GST_FLOW_OK;
1631 
1632   if (G_UNLIKELY (demux-&gt;priv-&gt;state == GST_TAG_DEMUX_READ_START_TAG &amp;&amp;
1633           GST_PAD_MODE (demux-&gt;priv-&gt;srcpad) == GST_PAD_MODE_PULL)) {
1634 
1635     flow = gst_tag_demux_element_find (demux);
1636     GST_INFO_OBJECT (demux, &quot;pulled tags: %s&quot;, gst_flow_get_name (flow));
1637   }
1638   return flow;
1639 }
1640 
1641 static GstFlowReturn
1642 gst_tag_demux_read_range (GstTagDemux * demux, GstObject * parent,
1643     guint64 offset, guint length, GstBuffer ** buffer)
1644 {
1645   GstFlowReturn ret;
1646   guint64 in_offset;
1647   guint in_length;
1648   gsize size;
1649 
1650   g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
1651 
1652   /* Ensure we already have computed our tags to properly use the offsets
1653    * below */
1654   ret = gst_tag_demux_ensure_tags (demux);
1655   if (ret != GST_FLOW_OK)
1656     return ret;
1657 
1658   /* Adjust offset and length of the request to trim off tag information.
1659    * For the returned buffer, adjust the output offset to match what downstream
1660    * should see */
1661   in_offset = offset + demux-&gt;priv-&gt;strip_start;
1662 
1663   if (!gst_tag_demux_get_upstream_size (demux))
1664     return GST_FLOW_ERROR;
1665 
1666   if (in_offset + length &gt;= demux-&gt;priv-&gt;upstream_size - demux-&gt;priv-&gt;strip_end) {
1667     if (in_offset + demux-&gt;priv-&gt;strip_end &gt;= demux-&gt;priv-&gt;upstream_size)
1668       return GST_FLOW_EOS;
1669     in_length = demux-&gt;priv-&gt;upstream_size - demux-&gt;priv-&gt;strip_end - in_offset;
1670   } else {
1671     in_length = length;
1672   }
1673 
1674   ret = gst_pad_pull_range (demux-&gt;priv-&gt;sinkpad, in_offset, in_length, buffer);
1675 
1676   if (ret == GST_FLOW_OK &amp;&amp; *buffer) {
1677     if (!gst_tag_demux_trim_buffer (demux, buffer, &amp;size))
1678       goto read_beyond_end;
1679 
1680     /* this should only happen in streaming mode */
1681     g_assert (*buffer != NULL);
1682   }
1683 
1684   return ret;
1685 
1686 read_beyond_end:
1687   {
1688     GST_DEBUG_OBJECT (demux, &quot;attempted read beyond end of file&quot;);
1689     if (*buffer != NULL) {
1690       gst_buffer_unref (*buffer);
1691       *buffer = NULL;
1692     }
1693     return GST_FLOW_EOS;
1694   }
1695 }
1696 
1697 static GstFlowReturn
1698 gst_tag_demux_src_getrange (GstPad * srcpad, GstObject * parent,
1699     guint64 offset, guint length, GstBuffer ** buffer)
1700 {
1701   GstTagDemux *demux = GST_TAG_DEMUX (parent);
1702 
1703   /* downstream in pull mode won&#39;t miss a newsegment event,
1704    * but it likely appreciates other (tag) events */
1705   if (demux-&gt;priv-&gt;need_newseg) {
1706     gst_tag_demux_send_pending_events (demux);
1707     demux-&gt;priv-&gt;need_newseg = FALSE;
1708   }
1709 
1710   if (demux-&gt;priv-&gt;send_tag_event) {
1711     gst_tag_demux_send_tag_event (demux);
1712     demux-&gt;priv-&gt;send_tag_event = FALSE;
1713   }
1714 
1715   return gst_tag_demux_read_range (demux, NULL, offset, length, buffer);
1716 }
1717 
1718 static GstStateChangeReturn
1719 gst_tag_demux_change_state (GstElement * element, GstStateChange transition)
1720 {
1721   GstStateChangeReturn ret;
1722   GstTagDemux *demux = GST_TAG_DEMUX (element);
1723 
1724   ret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
1725 
1726   switch (transition) {
1727     case GST_STATE_CHANGE_PAUSED_TO_READY:
1728       /* Ensure that nothing is in any of the streaming thread functions
1729        * anymore. While the above has deactivated all pads, there is nothing
1730        * preventing downstream from activating our srcpad again and calling the
1731        * getrange() function. Although we&#39;re in READY!
1732        */
1733       GST_PAD_STREAM_LOCK (demux-&gt;priv-&gt;srcpad);
1734       gst_tag_demux_reset (demux);
1735       GST_PAD_STREAM_UNLOCK (demux-&gt;priv-&gt;srcpad);
1736       break;
1737     default:
1738       break;
1739   }
1740 
1741   return ret;
1742 }
1743 
1744 static gboolean
1745 gst_tag_demux_pad_query (GstPad * pad, GstObject * parent, GstQuery * query)
1746 {
1747   /* For a position or duration query, adjust the returned
1748    * bytes to strip off the end and start areas */
1749   GstTagDemux *demux = GST_TAG_DEMUX (parent);
1750   GstFormat format;
1751   gint64 result;
1752   gboolean res = TRUE;
1753 
1754   /* FIXME: locking ? */
1755   switch (GST_QUERY_TYPE (query)) {
1756     case GST_QUERY_SCHEDULING:
1757       res = gst_pad_peer_query (demux-&gt;priv-&gt;sinkpad, query);
1758       break;
1759     case GST_QUERY_POSITION:
1760     {
1761       if (!(res = gst_pad_peer_query (demux-&gt;priv-&gt;sinkpad, query)))
1762         goto done;
1763 
1764       gst_query_parse_position (query, &amp;format, &amp;result);
1765       if (format == GST_FORMAT_BYTES) {
1766         result -= demux-&gt;priv-&gt;strip_start;
1767         gst_query_set_position (query, format, result);
1768       }
1769       break;
1770     }
1771     case GST_QUERY_DURATION:
1772     {
1773       if (!(res = gst_pad_peer_query (demux-&gt;priv-&gt;sinkpad, query)))
1774         goto done;
1775 
1776       gst_query_parse_duration (query, &amp;format, &amp;result);
1777       if (format == GST_FORMAT_BYTES) {
1778         /* if downstream activated us in pull mode right away, e.g. in case of
1779          * filesrc ! id3demux ! xyzparse ! .., read tags here, since we don&#39;t
1780          * have a streaming thread of our own to do that. We do it here and
1781          * not in get_range(), so we can return the right size in bytes.. */
1782         gst_tag_demux_ensure_tags (demux);
1783         result -= demux-&gt;priv-&gt;strip_start + demux-&gt;priv-&gt;strip_end;
1784         if (result &lt; 0)
1785           result = 0;
1786         gst_query_set_duration (query, format, result);
1787       }
1788       break;
1789     }
1790     default:
1791       res = gst_pad_query_default (pad, parent, query);
1792       break;
1793   }
1794 done:
1795   return res;
1796 }
1797 
1798 static void
1799 gst_tag_demux_send_pending_events (GstTagDemux * demux)
1800 {
1801   GList *events;
1802 
1803   /* send any pending events we cached */
1804   GST_OBJECT_LOCK (demux);
1805   events = demux-&gt;priv-&gt;pending_events;
1806   demux-&gt;priv-&gt;pending_events = NULL;
1807   GST_OBJECT_UNLOCK (demux);
1808 
1809   while (events != NULL) {
1810     GST_DEBUG_OBJECT (demux-&gt;priv-&gt;srcpad, &quot;sending cached %s event: %&quot;
1811         GST_PTR_FORMAT, GST_EVENT_TYPE_NAME (events-&gt;data), events-&gt;data);
1812     gst_pad_push_event (demux-&gt;priv-&gt;srcpad, GST_EVENT (events-&gt;data));
1813     events = g_list_delete_link (events, events);
1814   }
1815 }
1816 
1817 static void
1818 gst_tag_demux_send_tag_event (GstTagDemux * demux)
1819 {
1820   /* FIXME: what&#39;s the correct merge mode? Docs need to tell... */
1821   GstTagList *merged = gst_tag_list_merge (demux-&gt;priv-&gt;event_tags,
1822       demux-&gt;priv-&gt;parsed_tags, GST_TAG_MERGE_KEEP);
1823 
1824   if (merged) {
1825     GstEvent *event = gst_event_new_tag (merged);
1826 #ifdef GSTREAMER_LITE
1827   if (event == NULL)
1828     return;
1829 #endif // GSTREAMER_LITE
1830 
1831     GST_EVENT_TIMESTAMP (event) = 0;
1832     GST_DEBUG_OBJECT (demux, &quot;Sending tag event on src pad&quot;);
1833     gst_pad_push_event (demux-&gt;priv-&gt;srcpad, event);
1834   }
1835 }
1836 
1837 static gboolean
1838 gst_tag_demux_send_new_segment (GstTagDemux * tagdemux)
1839 {
1840   GstEvent *event;
1841   gint64 start, stop, time;
1842   GstSegment *seg = &amp;tagdemux-&gt;priv-&gt;segment;
1843   GstSegment newseg;
1844 
1845   if (seg-&gt;format == GST_FORMAT_UNDEFINED) {
1846     GST_LOG_OBJECT (tagdemux,
1847         &quot;No new segment received before first buffer. Using default&quot;);
1848     gst_segment_init (seg, GST_FORMAT_BYTES);
1849     seg-&gt;start = tagdemux-&gt;priv-&gt;strip_start;
1850     seg-&gt;time = tagdemux-&gt;priv-&gt;strip_start;
1851   }
1852 
1853   /* Can&#39;t adjust segments in non-BYTES formats */
1854   if (tagdemux-&gt;priv-&gt;segment.format != GST_FORMAT_BYTES) {
1855     event = gst_event_new_segment (seg);
1856     return gst_pad_push_event (tagdemux-&gt;priv-&gt;srcpad, event);
1857   }
1858 
1859   start = seg-&gt;start;
1860   stop = seg-&gt;stop;
1861   time = seg-&gt;time;
1862 
1863   g_return_val_if_fail (start != -1, FALSE);
1864   g_return_val_if_fail (time != -1, FALSE);
1865 
1866   if (tagdemux-&gt;priv-&gt;strip_end &gt; 0) {
1867     if (gst_tag_demux_get_upstream_size (tagdemux)) {
1868       guint64 v1tag_offset =
1869           tagdemux-&gt;priv-&gt;upstream_size - tagdemux-&gt;priv-&gt;strip_end;
1870 
1871       if (start &gt;= v1tag_offset) {
1872         /* Segment is completely within the end tag, output an open-ended
1873          * segment, even though all the buffers will get trimmed away */
1874         start = v1tag_offset;
1875         stop = -1;
1876       }
1877 
1878       if (stop != -1 &amp;&amp; stop &gt;= v1tag_offset) {
1879         GST_DEBUG_OBJECT (tagdemux,
1880             &quot;Segment crosses the end tag. Trimming end&quot;);
1881         stop = v1tag_offset;
1882       }
1883     }
1884   }
1885 
1886   if (tagdemux-&gt;priv-&gt;strip_start &gt; 0) {
1887     if (start &gt; tagdemux-&gt;priv-&gt;strip_start)
1888       start -= tagdemux-&gt;priv-&gt;strip_start;
1889     else
1890       start = 0;
1891 
1892     if (time &gt; tagdemux-&gt;priv-&gt;strip_start)
1893       time -= tagdemux-&gt;priv-&gt;strip_start;
1894     else
1895       time = 0;
1896 
1897     if (stop != -1) {
1898       if (stop &gt; tagdemux-&gt;priv-&gt;strip_start)
1899         stop -= tagdemux-&gt;priv-&gt;strip_start;
1900       else
1901         stop = 0;
1902     }
1903   }
1904 
1905   GST_DEBUG_OBJECT (tagdemux, &quot;Sending segment %&quot; GST_SEGMENT_FORMAT, seg);
1906 
1907   gst_segment_copy_into (seg, &amp;newseg);
1908   newseg.start = start;
1909   newseg.stop = stop;
1910   newseg.time = time;
1911   event = gst_event_new_segment (&amp;newseg);
1912 
1913   return gst_pad_push_event (tagdemux-&gt;priv-&gt;srcpad, event);
1914 }
    </pre>
  </body>
</html>