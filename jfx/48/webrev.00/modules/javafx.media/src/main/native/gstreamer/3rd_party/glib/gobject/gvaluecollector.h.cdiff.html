<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gvaluecollector.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gvaluearray.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gvaluetransform.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gvaluecollector.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 36,17 ***</span>
  /* we may want to add aggregate types here some day, if requested
   * by users. the basic C types are covered already, everything
   * smaller than an int is promoted to an integer and floats are
   * always promoted to doubles for varargs call constructions.
   */
<span class="line-modified">! enum    /*&lt; skip &gt;*/</span>
  {
<span class="line-modified">!   G_VALUE_COLLECT_INT       = &#39;i&#39;,</span>
<span class="line-modified">!   G_VALUE_COLLECT_LONG      = &#39;l&#39;,</span>
    G_VALUE_COLLECT_INT64         = &#39;q&#39;,
<span class="line-modified">!   G_VALUE_COLLECT_DOUBLE    = &#39;d&#39;,</span>
<span class="line-modified">!   G_VALUE_COLLECT_POINTER   = &#39;p&#39;</span>
  };
  
  
  /* vararg union holding actual values collected
   */
<span class="line-new-header">--- 36,17 ---</span>
  /* we may want to add aggregate types here some day, if requested
   * by users. the basic C types are covered already, everything
   * smaller than an int is promoted to an integer and floats are
   * always promoted to doubles for varargs call constructions.
   */
<span class="line-modified">! enum  /*&lt; skip &gt;*/</span>
  {
<span class="line-modified">!   G_VALUE_COLLECT_INT   = &#39;i&#39;,</span>
<span class="line-modified">!   G_VALUE_COLLECT_LONG    = &#39;l&#39;,</span>
    G_VALUE_COLLECT_INT64         = &#39;q&#39;,
<span class="line-modified">!   G_VALUE_COLLECT_DOUBLE  = &#39;d&#39;,</span>
<span class="line-modified">!   G_VALUE_COLLECT_POINTER = &#39;p&#39;</span>
  };
  
  
  /* vararg union holding actual values collected
   */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 84,49 ***</span>
   * va_list variables cannot be passed by reference.
   *
   * Since: 2.24
   */
  #ifndef GSTREAMER_LITE
<span class="line-modified">! #define G_VALUE_COLLECT_INIT(value, _value_type, var_args, flags, __error)      \</span>
<span class="line-modified">! G_STMT_START {                                      \</span>
<span class="line-modified">!   GValue *g_vci_val = (value);                              \</span>
<span class="line-modified">!   guint g_vci_flags = (flags);                              \</span>
<span class="line-modified">!   GTypeValueTable *g_vci_vtab = g_type_value_table_peek (_value_type);          \</span>
<span class="line-modified">!   const gchar *g_vci_collect_format = g_vci_vtab-&gt;collect_format;                   \</span>
<span class="line-modified">!   GTypeCValue g_vci_cvalues[G_VALUE_COLLECT_FORMAT_MAX_LENGTH] = { { 0, }, };       \</span>
<span class="line-modified">!   guint g_vci_n_values = 0;                                 \</span>
                                                                                          \
<span class="line-modified">!   g_vci_val-&gt;g_type = _value_type;      /* value_meminit() from gvalue.c */     \</span>
<span class="line-modified">!   while (*g_vci_collect_format)                             \</span>
<span class="line-modified">!     {                                           \</span>
<span class="line-modified">!       GTypeCValue *g_vci_cvalue = g_vci_cvalues + g_vci_n_values++;                 \</span>
                                                                                          \
<span class="line-modified">!       switch (*g_vci_collect_format++)                          \</span>
<span class="line-modified">!     {                                       \</span>
<span class="line-modified">!     case G_VALUE_COLLECT_INT:                           \</span>
<span class="line-modified">!       g_vci_cvalue-&gt;v_int = va_arg ((var_args), gint);                  \</span>
<span class="line-modified">!       break;                                    \</span>
<span class="line-modified">!     case G_VALUE_COLLECT_LONG:                          \</span>
<span class="line-modified">!       g_vci_cvalue-&gt;v_long = va_arg ((var_args), glong);                    \</span>
<span class="line-modified">!       break;                                    \</span>
<span class="line-modified">!     case G_VALUE_COLLECT_INT64:                         \</span>
<span class="line-modified">!       g_vci_cvalue-&gt;v_int64 = va_arg ((var_args), gint64);              \</span>
<span class="line-modified">!       break;                                    \</span>
<span class="line-modified">!     case G_VALUE_COLLECT_DOUBLE:                            \</span>
<span class="line-modified">!       g_vci_cvalue-&gt;v_double = va_arg ((var_args), gdouble);                \</span>
<span class="line-modified">!       break;                                    \</span>
<span class="line-modified">!     case G_VALUE_COLLECT_POINTER:                           \</span>
<span class="line-modified">!       g_vci_cvalue-&gt;v_pointer = va_arg ((var_args), gpointer);              \</span>
<span class="line-modified">!       break;                                    \</span>
<span class="line-modified">!     default:                                    \</span>
<span class="line-modified">!       g_assert_not_reached ();                          \</span>
<span class="line-modified">!     }                                       \</span>
<span class="line-modified">!     }                                           \</span>
<span class="line-modified">!   *(__error) = g_vci_vtab-&gt;collect_value (g_vci_val,                        \</span>
<span class="line-modified">!                        g_vci_n_values,                  \</span>
<span class="line-modified">!                        g_vci_cvalues,                   \</span>
<span class="line-modified">!                        g_vci_flags);                        \</span>
  } G_STMT_END
  #else // GSTREAMER_LITE
  #define G_VALUE_COLLECT_INIT(value, _value_type, var_args, flags, __error)      \
  G_STMT_START {                                      \
    GValue *_val = (value);                               \
<span class="line-new-header">--- 84,49 ---</span>
   * va_list variables cannot be passed by reference.
   *
   * Since: 2.24
   */
  #ifndef GSTREAMER_LITE
<span class="line-modified">! #define G_VALUE_COLLECT_INIT(value, _value_type, var_args, flags, __error)    \</span>
<span class="line-modified">! G_STMT_START {                    \</span>
<span class="line-modified">!   GValue *g_vci_val = (value);                \</span>
<span class="line-modified">!   guint g_vci_flags = (flags);                \</span>
<span class="line-modified">!   GTypeValueTable *g_vci_vtab = g_type_value_table_peek (_value_type);      \</span>
<span class="line-modified">!   const gchar *g_vci_collect_format = g_vci_vtab-&gt;collect_format;         \</span>
<span class="line-modified">!   GTypeCValue g_vci_cvalues[G_VALUE_COLLECT_FORMAT_MAX_LENGTH] = { { 0, }, };   \</span>
<span class="line-modified">!   guint g_vci_n_values = 0;                 \</span>
                                                                                          \
<span class="line-modified">!   g_vci_val-&gt;g_type = _value_type;    /* value_meminit() from gvalue.c */   \</span>
<span class="line-modified">!   while (*g_vci_collect_format)               \</span>
<span class="line-modified">!     {                     \</span>
<span class="line-modified">!       GTypeCValue *g_vci_cvalue = g_vci_cvalues + g_vci_n_values++;         \</span>
                                                                                          \
<span class="line-modified">!       switch (*g_vci_collect_format++)              \</span>
<span class="line-modified">!   {                   \</span>
<span class="line-modified">!   case G_VALUE_COLLECT_INT:             \</span>
<span class="line-modified">!     g_vci_cvalue-&gt;v_int = va_arg ((var_args), gint);          \</span>
<span class="line-modified">!     break;                  \</span>
<span class="line-modified">!   case G_VALUE_COLLECT_LONG:              \</span>
<span class="line-modified">!     g_vci_cvalue-&gt;v_long = va_arg ((var_args), glong);          \</span>
<span class="line-modified">!     break;                  \</span>
<span class="line-modified">!   case G_VALUE_COLLECT_INT64:             \</span>
<span class="line-modified">!     g_vci_cvalue-&gt;v_int64 = va_arg ((var_args), gint64);        \</span>
<span class="line-modified">!     break;                  \</span>
<span class="line-modified">!   case G_VALUE_COLLECT_DOUBLE:              \</span>
<span class="line-modified">!     g_vci_cvalue-&gt;v_double = va_arg ((var_args), gdouble);        \</span>
<span class="line-modified">!     break;                  \</span>
<span class="line-modified">!   case G_VALUE_COLLECT_POINTER:             \</span>
<span class="line-modified">!     g_vci_cvalue-&gt;v_pointer = va_arg ((var_args), gpointer);        \</span>
<span class="line-modified">!     break;                  \</span>
<span class="line-modified">!   default:                  \</span>
<span class="line-modified">!     g_assert_not_reached ();              \</span>
<span class="line-modified">!   }                   \</span>
<span class="line-modified">!     }                     \</span>
<span class="line-modified">!   *(__error) = g_vci_vtab-&gt;collect_value (g_vci_val,            \</span>
<span class="line-modified">!                g_vci_n_values,          \</span>
<span class="line-modified">!                g_vci_cvalues,         \</span>
<span class="line-modified">!                g_vci_flags);            \</span>
  } G_STMT_END
  #else // GSTREAMER_LITE
  #define G_VALUE_COLLECT_INIT(value, _value_type, var_args, flags, __error)      \
  G_STMT_START {                                      \
    GValue *_val = (value);                               \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 192,57 ***</span>
   *
   * Note: If you are creating the @value argument just before calling this macro,
   * you should use the #G_VALUE_COLLECT_INIT variant and pass the unitialized
   * #GValue. That variant is faster than #G_VALUE_COLLECT.
   */
<span class="line-modified">! #define G_VALUE_COLLECT(value, var_args, flags, __error) G_STMT_START {         \</span>
<span class="line-modified">!   GValue *g_vc_value = (value);                             \</span>
<span class="line-modified">!   GType g_vc_value_type = G_VALUE_TYPE (g_vc_value);                        \</span>
<span class="line-modified">!   GTypeValueTable *g_vc_vtable = g_type_value_table_peek (g_vc_value_type);         \</span>
<span class="line-modified">!                                             \</span>
<span class="line-modified">!   if (g_vc_vtable-&gt;value_free)                              \</span>
<span class="line-modified">!     g_vc_vtable-&gt;value_free (g_vc_value);                           \</span>
<span class="line-modified">!   memset (g_vc_value-&gt;data, 0, sizeof (g_vc_value-&gt;data));                  \</span>
<span class="line-modified">!                                             \</span>
<span class="line-modified">!   G_VALUE_COLLECT_INIT(value, g_vc_value_type, var_args, flags, __error);           \</span>
  } G_STMT_END
  
  /**
   * G_VALUE_COLLECT_SKIP:
   * @_value_type: the #GType of the value to skip
   * @var_args: the va_list variable; it may be evaluated multiple times
   *
   * Skip an argument of type @_value_type from @var_args.
   */
<span class="line-modified">! #define G_VALUE_COLLECT_SKIP(_value_type, var_args)                 \</span>
<span class="line-modified">! G_STMT_START {                                      \</span>
<span class="line-modified">!   GTypeValueTable *g_vcs_vtable = g_type_value_table_peek (_value_type);            \</span>
<span class="line-modified">!   const gchar *g_vcs_collect_format = g_vcs_vtable-&gt;collect_format;             \</span>
                                                                                          \
<span class="line-modified">!   while (*g_vcs_collect_format)                             \</span>
<span class="line-modified">!     {                                           \</span>
<span class="line-modified">!       switch (*g_vcs_collect_format++)                          \</span>
<span class="line-modified">!     {                                       \</span>
<span class="line-modified">!     case G_VALUE_COLLECT_INT:                           \</span>
<span class="line-modified">!       va_arg ((var_args), gint);                            \</span>
<span class="line-modified">!       break;                                    \</span>
<span class="line-modified">!     case G_VALUE_COLLECT_LONG:                          \</span>
<span class="line-modified">!       va_arg ((var_args), glong);                           \</span>
<span class="line-modified">!       break;                                    \</span>
<span class="line-modified">!     case G_VALUE_COLLECT_INT64:                         \</span>
<span class="line-modified">!       va_arg ((var_args), gint64);                          \</span>
<span class="line-modified">!       break;                                    \</span>
<span class="line-modified">!     case G_VALUE_COLLECT_DOUBLE:                            \</span>
<span class="line-modified">!       va_arg ((var_args), gdouble);                         \</span>
<span class="line-modified">!       break;                                    \</span>
<span class="line-modified">!     case G_VALUE_COLLECT_POINTER:                           \</span>
<span class="line-modified">!       va_arg ((var_args), gpointer);                        \</span>
<span class="line-modified">!       break;                                    \</span>
<span class="line-modified">!     default:                                    \</span>
<span class="line-modified">!       g_assert_not_reached ();                          \</span>
<span class="line-modified">!     }                                       \</span>
<span class="line-modified">!     }                                           \</span>
  } G_STMT_END
  
  /**
   * G_VALUE_LCOPY:
   * @value: a #GValue to store into the @var_args; this must be initialized
<span class="line-new-header">--- 192,57 ---</span>
   *
   * Note: If you are creating the @value argument just before calling this macro,
   * you should use the #G_VALUE_COLLECT_INIT variant and pass the unitialized
   * #GValue. That variant is faster than #G_VALUE_COLLECT.
   */
<span class="line-modified">! #define G_VALUE_COLLECT(value, var_args, flags, __error) G_STMT_START {     \</span>
<span class="line-modified">!   GValue *g_vc_value = (value);               \</span>
<span class="line-modified">!   GType g_vc_value_type = G_VALUE_TYPE (g_vc_value);            \</span>
<span class="line-modified">!   GTypeValueTable *g_vc_vtable = g_type_value_table_peek (g_vc_value_type);     \</span>
<span class="line-modified">!                       \</span>
<span class="line-modified">!   if (g_vc_vtable-&gt;value_free)                \</span>
<span class="line-modified">!     g_vc_vtable-&gt;value_free (g_vc_value);             \</span>
<span class="line-modified">!   memset (g_vc_value-&gt;data, 0, sizeof (g_vc_value-&gt;data));          \</span>
<span class="line-modified">!                       \</span>
<span class="line-modified">!   G_VALUE_COLLECT_INIT(value, g_vc_value_type, var_args, flags, __error);     \</span>
  } G_STMT_END
  
  /**
   * G_VALUE_COLLECT_SKIP:
   * @_value_type: the #GType of the value to skip
   * @var_args: the va_list variable; it may be evaluated multiple times
   *
   * Skip an argument of type @_value_type from @var_args.
   */
<span class="line-modified">! #define G_VALUE_COLLECT_SKIP(_value_type, var_args)         \</span>
<span class="line-modified">! G_STMT_START {                    \</span>
<span class="line-modified">!   GTypeValueTable *g_vcs_vtable = g_type_value_table_peek (_value_type);      \</span>
<span class="line-modified">!   const gchar *g_vcs_collect_format = g_vcs_vtable-&gt;collect_format;       \</span>
                                                                                          \
<span class="line-modified">!   while (*g_vcs_collect_format)               \</span>
<span class="line-modified">!     {                     \</span>
<span class="line-modified">!       switch (*g_vcs_collect_format++)              \</span>
<span class="line-modified">!   {                   \</span>
<span class="line-modified">!   case G_VALUE_COLLECT_INT:             \</span>
<span class="line-modified">!     va_arg ((var_args), gint);              \</span>
<span class="line-modified">!     break;                  \</span>
<span class="line-modified">!   case G_VALUE_COLLECT_LONG:              \</span>
<span class="line-modified">!     va_arg ((var_args), glong);             \</span>
<span class="line-modified">!     break;                  \</span>
<span class="line-modified">!   case G_VALUE_COLLECT_INT64:             \</span>
<span class="line-modified">!     va_arg ((var_args), gint64);              \</span>
<span class="line-modified">!     break;                  \</span>
<span class="line-modified">!   case G_VALUE_COLLECT_DOUBLE:              \</span>
<span class="line-modified">!     va_arg ((var_args), gdouble);             \</span>
<span class="line-modified">!     break;                  \</span>
<span class="line-modified">!   case G_VALUE_COLLECT_POINTER:             \</span>
<span class="line-modified">!     va_arg ((var_args), gpointer);            \</span>
<span class="line-modified">!     break;                  \</span>
<span class="line-modified">!   default:                  \</span>
<span class="line-modified">!     g_assert_not_reached ();              \</span>
<span class="line-modified">!   }                   \</span>
<span class="line-modified">!     }                     \</span>
  } G_STMT_END
  
  /**
   * G_VALUE_LCOPY:
   * @value: a #GValue to store into the @var_args; this must be initialized
</pre>
<hr />
<pre>
<span class="line-old-header">*** 255,49 ***</span>
   *
   * Stores a value&#39;s value into one or more argument locations from a va_list.
   * This is the inverse of G_VALUE_COLLECT().
   */
  #ifndef GSTREAMER_LITE
<span class="line-modified">! #define G_VALUE_LCOPY(value, var_args, flags, __error)                  \</span>
<span class="line-modified">! G_STMT_START {                                      \</span>
<span class="line-modified">!   const GValue *g_vl_value = (value);                           \</span>
<span class="line-modified">!   guint g_vl_flags = (flags);                               \</span>
<span class="line-modified">!   GType g_vl_value_type = G_VALUE_TYPE (g_vl_value);                        \</span>
<span class="line-modified">!   GTypeValueTable *g_vl_vtable = g_type_value_table_peek (g_vl_value_type);         \</span>
<span class="line-modified">!   const gchar *g_vl_lcopy_format = g_vl_vtable-&gt;lcopy_format;                   \</span>
<span class="line-modified">!   GTypeCValue g_vl_cvalues[G_VALUE_COLLECT_FORMAT_MAX_LENGTH] = { { 0, }, };        \</span>
<span class="line-modified">!   guint g_vl_n_values = 0;                                  \</span>
                                                                                          \
<span class="line-modified">!   while (*g_vl_lcopy_format)                                \</span>
<span class="line-modified">!     {                                           \</span>
<span class="line-modified">!       GTypeCValue *g_vl_cvalue = g_vl_cvalues + g_vl_n_values++;                    \</span>
                                                                                          \
<span class="line-modified">!       switch (*g_vl_lcopy_format++)                             \</span>
<span class="line-modified">!     {                                       \</span>
<span class="line-modified">!     case G_VALUE_COLLECT_INT:                           \</span>
<span class="line-modified">!       g_vl_cvalue-&gt;v_int = va_arg ((var_args), gint);                   \</span>
<span class="line-modified">!       break;                                    \</span>
<span class="line-modified">!     case G_VALUE_COLLECT_LONG:                          \</span>
<span class="line-modified">!       g_vl_cvalue-&gt;v_long = va_arg ((var_args), glong);                 \</span>
<span class="line-modified">!       break;                                    \</span>
<span class="line-modified">!     case G_VALUE_COLLECT_INT64:                         \</span>
<span class="line-modified">!       g_vl_cvalue-&gt;v_int64 = va_arg ((var_args), gint64);               \</span>
<span class="line-modified">!       break;                                    \</span>
<span class="line-modified">!     case G_VALUE_COLLECT_DOUBLE:                            \</span>
<span class="line-modified">!       g_vl_cvalue-&gt;v_double = va_arg ((var_args), gdouble);             \</span>
<span class="line-modified">!       break;                                    \</span>
<span class="line-modified">!     case G_VALUE_COLLECT_POINTER:                           \</span>
<span class="line-modified">!       g_vl_cvalue-&gt;v_pointer = va_arg ((var_args), gpointer);               \</span>
<span class="line-modified">!       break;                                    \</span>
<span class="line-modified">!     default:                                    \</span>
<span class="line-modified">!       g_assert_not_reached ();                          \</span>
<span class="line-modified">!     }                                       \</span>
<span class="line-modified">!     }                                           \</span>
<span class="line-modified">!   *(__error) = g_vl_vtable-&gt;lcopy_value (g_vl_value,                        \</span>
<span class="line-modified">!                      g_vl_n_values,                     \</span>
<span class="line-modified">!                      g_vl_cvalues,                      \</span>
<span class="line-modified">!                      g_vl_flags);                       \</span>
  } G_STMT_END
  #else // GSTREAMER_LITE
  #define G_VALUE_LCOPY(value, var_args, flags, __error)                  \
  G_STMT_START {                                      \
    const GValue *_value = (value);                           \
<span class="line-new-header">--- 255,49 ---</span>
   *
   * Stores a value&#39;s value into one or more argument locations from a va_list.
   * This is the inverse of G_VALUE_COLLECT().
   */
  #ifndef GSTREAMER_LITE
<span class="line-modified">! #define G_VALUE_LCOPY(value, var_args, flags, __error)          \</span>
<span class="line-modified">! G_STMT_START {                    \</span>
<span class="line-modified">!   const GValue *g_vl_value = (value);             \</span>
<span class="line-modified">!   guint g_vl_flags = (flags);               \</span>
<span class="line-modified">!   GType g_vl_value_type = G_VALUE_TYPE (g_vl_value);            \</span>
<span class="line-modified">!   GTypeValueTable *g_vl_vtable = g_type_value_table_peek (g_vl_value_type);     \</span>
<span class="line-modified">!   const gchar *g_vl_lcopy_format = g_vl_vtable-&gt;lcopy_format;         \</span>
<span class="line-modified">!   GTypeCValue g_vl_cvalues[G_VALUE_COLLECT_FORMAT_MAX_LENGTH] = { { 0, }, };    \</span>
<span class="line-modified">!   guint g_vl_n_values = 0;                  \</span>
                                                                                          \
<span class="line-modified">!   while (*g_vl_lcopy_format)                \</span>
<span class="line-modified">!     {                     \</span>
<span class="line-modified">!       GTypeCValue *g_vl_cvalue = g_vl_cvalues + g_vl_n_values++;          \</span>
                                                                                          \
<span class="line-modified">!       switch (*g_vl_lcopy_format++)               \</span>
<span class="line-modified">!   {                   \</span>
<span class="line-modified">!   case G_VALUE_COLLECT_INT:             \</span>
<span class="line-modified">!     g_vl_cvalue-&gt;v_int = va_arg ((var_args), gint);         \</span>
<span class="line-modified">!     break;                  \</span>
<span class="line-modified">!   case G_VALUE_COLLECT_LONG:              \</span>
<span class="line-modified">!     g_vl_cvalue-&gt;v_long = va_arg ((var_args), glong);         \</span>
<span class="line-modified">!     break;                  \</span>
<span class="line-modified">!   case G_VALUE_COLLECT_INT64:             \</span>
<span class="line-modified">!     g_vl_cvalue-&gt;v_int64 = va_arg ((var_args), gint64);       \</span>
<span class="line-modified">!     break;                  \</span>
<span class="line-modified">!   case G_VALUE_COLLECT_DOUBLE:              \</span>
<span class="line-modified">!     g_vl_cvalue-&gt;v_double = va_arg ((var_args), gdouble);       \</span>
<span class="line-modified">!     break;                  \</span>
<span class="line-modified">!   case G_VALUE_COLLECT_POINTER:             \</span>
<span class="line-modified">!     g_vl_cvalue-&gt;v_pointer = va_arg ((var_args), gpointer);       \</span>
<span class="line-modified">!     break;                  \</span>
<span class="line-modified">!   default:                  \</span>
<span class="line-modified">!     g_assert_not_reached ();              \</span>
<span class="line-modified">!   }                   \</span>
<span class="line-modified">!     }                     \</span>
<span class="line-modified">!   *(__error) = g_vl_vtable-&gt;lcopy_value (g_vl_value,            \</span>
<span class="line-modified">!              g_vl_n_values,           \</span>
<span class="line-modified">!              g_vl_cvalues,            \</span>
<span class="line-modified">!              g_vl_flags);           \</span>
  } G_STMT_END
  #else // GSTREAMER_LITE
  #define G_VALUE_LCOPY(value, var_args, flags, __error)                  \
  G_STMT_START {                                      \
    const GValue *_value = (value);                           \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 353,10 ***</span>
   * G_VALUE_COLLECT_FORMAT_MAX_LENGTH:
   *
   * The maximal number of #GTypeCValues which can be collected for a
   * single #GValue.
   */
<span class="line-modified">! #define G_VALUE_COLLECT_FORMAT_MAX_LENGTH   (8)</span>
  
  G_END_DECLS
  
  #endif /* __G_VALUE_COLLECTOR_H__ */
<span class="line-new-header">--- 353,10 ---</span>
   * G_VALUE_COLLECT_FORMAT_MAX_LENGTH:
   *
   * The maximal number of #GTypeCValues which can be collected for a
   * single #GValue.
   */
<span class="line-modified">! #define G_VALUE_COLLECT_FORMAT_MAX_LENGTH (8)</span>
  
  G_END_DECLS
  
  #endif /* __G_VALUE_COLLECTOR_H__ */
</pre>
<center><a href="gvaluearray.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gvaluetransform.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>