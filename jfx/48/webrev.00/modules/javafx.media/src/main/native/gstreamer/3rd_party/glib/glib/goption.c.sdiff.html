<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/goption.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gnulib/xsize.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="goption.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/goption.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 177  * ]|
 178  */
 179 
 180 #include &quot;config.h&quot;
 181 
 182 #include &lt;string.h&gt;
 183 #include &lt;stdlib.h&gt;
 184 #include &lt;stdio.h&gt;
 185 #include &lt;errno.h&gt;
 186 
 187 #if defined __OpenBSD__
 188 #include &lt;unistd.h&gt;
 189 #include &lt;sys/sysctl.h&gt;
 190 #endif
 191 
 192 #include &quot;goption.h&quot;
 193 
 194 #include &quot;gprintf.h&quot;
 195 #include &quot;glibintl.h&quot;
 196 




 197 #define TRANSLATE(group, str) (((group)-&gt;translate_func ? (* (group)-&gt;translate_func) ((str), (group)-&gt;translate_data) : (str)))
 198 
 199 #define NO_ARG(entry) ((entry)-&gt;arg == G_OPTION_ARG_NONE ||       \
 200                        ((entry)-&gt;arg == G_OPTION_ARG_CALLBACK &amp;&amp;  \
 201                         ((entry)-&gt;flags &amp; G_OPTION_FLAG_NO_ARG)))
 202 
 203 #define OPTIONAL_ARG(entry) ((entry)-&gt;arg == G_OPTION_ARG_CALLBACK &amp;&amp;  \
 204                        (entry)-&gt;flags &amp; G_OPTION_FLAG_OPTIONAL_ARG)
 205 
 206 typedef struct
 207 {
 208   GOptionArg arg_type;
 209   gpointer arg_data;
 210   union
 211   {
 212     gboolean bool;
 213     gint integer;
 214     gchar *str;
 215     gchar **array;
 216     gdouble dbl;
</pre>
<hr />
<pre>
 260    */
 261   GList           *pending_nulls;
 262 };
 263 
 264 struct _GOptionGroup
 265 {
 266   gchar           *name;
 267   gchar           *description;
 268   gchar           *help_description;
 269 
 270   gint             ref_count;
 271 
 272   GDestroyNotify   destroy_notify;
 273   gpointer         user_data;
 274 
 275   GTranslateFunc   translate_func;
 276   GDestroyNotify   translate_notify;
 277   gpointer         translate_data;
 278 
 279   GOptionEntry    *entries;
<span class="line-modified"> 280   gint             n_entries;</span>
 281 
 282   GOptionParseFunc pre_parse_func;
 283   GOptionParseFunc post_parse_func;
 284   GOptionErrorFunc error_func;
 285 };
 286 
 287 static void free_changes_list (GOptionContext *context,
 288                                gboolean        revert);
 289 static void free_pending_nulls (GOptionContext *context,
 290                                 gboolean        perform_nulls);
 291 
 292 
 293 static int
 294 _g_unichar_get_width (gunichar c)
 295 {
 296   if (G_UNLIKELY (g_unichar_iszerowidth (c)))
 297     return 0;
 298 
 299   /* we ignore the fact that we should call g_unichar_iswide_cjk() under
 300    * some locales (legacy East Asian ones) */
</pre>
<hr />
<pre>
 634 }
 635 
 636 /**
 637  * g_option_context_add_main_entries:
 638  * @context: a #GOptionContext
 639  * @entries: a %NULL-terminated array of #GOptionEntrys
 640  * @translation_domain: (nullable): a translation domain to use for translating
 641  *    the `--help` output for the options in @entries
 642  *    with gettext(), or %NULL
 643  *
 644  * A convenience function which creates a main group if it doesn&#39;t
 645  * exist, adds the @entries to it and sets the translation domain.
 646  *
 647  * Since: 2.6
 648  **/
 649 void
 650 g_option_context_add_main_entries (GOptionContext      *context,
 651                                    const GOptionEntry  *entries,
 652                                    const gchar         *translation_domain)
 653 {

 654   g_return_if_fail (entries != NULL);
 655 
 656   if (!context-&gt;main_group)
 657     context-&gt;main_group = g_option_group_new (NULL, NULL, NULL, NULL, NULL);
 658 
 659   g_option_group_add_entries (context-&gt;main_group, entries);
 660   g_option_group_set_translation_domain (context-&gt;main_group, translation_domain);
 661 }
 662 
 663 static gint
 664 calculate_max_length (GOptionGroup *group,
 665                       GHashTable   *aliases)
 666 {
 667   GOptionEntry *entry;
<span class="line-modified"> 668   gint i, len, max_length;</span>
 669   const gchar *long_name;
 670 
 671   max_length = 0;
 672 
 673   for (i = 0; i &lt; group-&gt;n_entries; i++)
 674     {
 675       entry = &amp;group-&gt;entries[i];
 676 
 677       if (entry-&gt;flags &amp; G_OPTION_FLAG_HIDDEN)
 678         continue;
 679 
 680       long_name = g_hash_table_lookup (aliases, &amp;entry-&gt;long_name);
 681       if (!long_name)
 682         long_name = entry-&gt;long_name;
 683       len = _g_utf8_strwidth (long_name);
 684 
 685       if (entry-&gt;short_name)
 686         len += 4;
 687 
 688       if (!NO_ARG (entry) &amp;&amp; entry-&gt;arg_description)
</pre>
<hr />
<pre>
 811  *
 812  * Returns a formatted, translated help text for the given context.
 813  * To obtain the text produced by `--help`, call
 814  * `g_option_context_get_help (context, TRUE, NULL)`.
 815  * To obtain the text produced by `--help-all`, call
 816  * `g_option_context_get_help (context, FALSE, NULL)`.
 817  * To obtain the help text for an option group, call
 818  * `g_option_context_get_help (context, FALSE, group)`.
 819  *
 820  * Returns: A newly allocated string containing the help text
 821  *
 822  * Since: 2.14
 823  */
 824 gchar *
 825 g_option_context_get_help (GOptionContext *context,
 826                            gboolean        main_help,
 827                            GOptionGroup   *group)
 828 {
 829   GList *list;
 830   gint max_length = 0, len;
<span class="line-modified"> 831   gint i;</span>
 832   GOptionEntry *entry;
 833   GHashTable *shadow_map;
 834   GHashTable *aliases;
 835   gboolean seen[256];
 836   const gchar *rest_description;
 837   GString *string;
 838   guchar token;
 839 


 840   string = g_string_sized_new (1024);
 841 
 842   rest_description = NULL;
 843   if (context-&gt;main_group)
 844     {
 845 
 846       for (i = 0; i &lt; context-&gt;main_group-&gt;n_entries; i++)
 847         {
 848           entry = &amp;context-&gt;main_group-&gt;entries[i];
 849           if (entry-&gt;long_name[0] == 0)
 850             {
 851               rest_description = TRANSLATE (context-&gt;main_group, entry-&gt;arg_description);
 852               break;
 853             }
 854         }
 855     }
 856 
 857   g_string_append_printf (string, &quot;%s\n  %s&quot;, _(&quot;Usage:&quot;), g_get_prgname ());
 858   if (context-&gt;help_enabled ||
 859       (context-&gt;main_group &amp;&amp; context-&gt;main_group-&gt;n_entries &gt; 0) ||
</pre>
<hr />
<pre>
1027               g_string_append (string, &quot;\n&quot;);
1028               for (i = 0; i &lt; g-&gt;n_entries; i++)
1029                 if (!(g-&gt;entries[i].flags &amp; G_OPTION_FLAG_IN_MAIN))
1030                   print_entry (g, max_length, &amp;g-&gt;entries[i], string, aliases);
1031 
1032               g_string_append (string, &quot;\n&quot;);
1033             }
1034 
1035           list = list-&gt;next;
1036         }
1037     }
1038 
1039   /* Print application options if --help or --help-all has been specified */
1040   if ((main_help || !group) &amp;&amp;
1041       (group_has_visible_entries (context, context-&gt;main_group, TRUE) ||
1042        group_list_has_visible_entries (context, context-&gt;groups, TRUE)))
1043     {
1044       list = context-&gt;groups;
1045 
1046       if (context-&gt;help_enabled || list)
<span class="line-modified">1047       g_string_append (string,  _(&quot;Application Options:&quot;));</span>
1048       else
1049         g_string_append (string, _(&quot;Options:&quot;));
1050       g_string_append (string, &quot;\n&quot;);
1051       if (context-&gt;main_group)
1052         for (i = 0; i &lt; context-&gt;main_group-&gt;n_entries; i++)
1053           print_entry (context-&gt;main_group, max_length,
1054                        &amp;context-&gt;main_group-&gt;entries[i], string, aliases);
1055 
1056       while (list != NULL)
1057         {
1058           GOptionGroup *g = list-&gt;data;
1059 
1060           /* Print main entries from other groups */
1061           for (i = 0; i &lt; g-&gt;n_entries; i++)
1062             if (g-&gt;entries[i].flags &amp; G_OPTION_FLAG_IN_MAIN)
1063               print_entry (g, max_length, &amp;g-&gt;entries[i], string, aliases);
1064 
1065           list = list-&gt;next;
1066         }
1067 
</pre>
<hr />
<pre>
1268         gchar *data;
1269 
1270 #ifdef G_OS_WIN32
1271         if (!context-&gt;strv_mode)
1272           data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1273         else
1274           data = g_strdup (value);
1275 #else
1276         data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1277 #endif
1278 
1279         if (!data)
1280           return FALSE;
1281 
1282         change = get_change (context, G_OPTION_ARG_STRING,
1283                              entry-&gt;arg_data);
1284 
1285         if (!change-&gt;allocated.str)
1286           change-&gt;prev.str = *(gchar **)entry-&gt;arg_data;
1287         else
<span class="line-modified">1288         g_free (change-&gt;allocated.str);</span>
1289 
1290         change-&gt;allocated.str = data;
1291 
1292         *(gchar **)entry-&gt;arg_data = data;
1293         break;
1294       }
1295     case G_OPTION_ARG_STRING_ARRAY:
1296       {
1297         gchar *data;
1298 
1299 #ifdef G_OS_WIN32
1300         if (!context-&gt;strv_mode)
1301           data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1302         else
1303           data = g_strdup (value);
1304 #else
1305         data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1306 #endif
1307 
1308         if (!data)
</pre>
<hr />
<pre>
1335       {
1336         gchar *data;
1337 
1338 #ifdef G_OS_WIN32
1339         if (!context-&gt;strv_mode)
1340           data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1341         else
1342           data = g_strdup (value);
1343 
1344         if (!data)
1345           return FALSE;
1346 #else
1347         data = g_strdup (value);
1348 #endif
1349         change = get_change (context, G_OPTION_ARG_FILENAME,
1350                              entry-&gt;arg_data);
1351 
1352         if (!change-&gt;allocated.str)
1353           change-&gt;prev.str = *(gchar **)entry-&gt;arg_data;
1354         else
<span class="line-modified">1355         g_free (change-&gt;allocated.str);</span>
1356 
1357         change-&gt;allocated.str = data;
1358 
1359         *(gchar **)entry-&gt;arg_data = data;
1360         break;
1361       }
1362 
1363     case G_OPTION_ARG_FILENAME_ARRAY:
1364       {
1365         gchar *data;
1366 
1367 #ifdef G_OS_WIN32
1368         if (!context-&gt;strv_mode)
1369           data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1370         else
1371           data = g_strdup (value);
1372 
1373         if (!data)
1374           return FALSE;
1375 #else
</pre>
<hr />
<pre>
1488         break;
1489       }
1490     default:
1491       g_assert_not_reached ();
1492     }
1493 
1494   return TRUE;
1495 }
1496 
1497 static gboolean
1498 parse_short_option (GOptionContext *context,
1499                     GOptionGroup   *group,
1500                     gint            idx,
1501                     gint           *new_idx,
1502                     gchar           arg,
1503                     gint           *argc,
1504                     gchar        ***argv,
1505                     GError        **error,
1506                     gboolean       *parsed)
1507 {
<span class="line-modified">1508   gint j;</span>
1509 
1510   for (j = 0; j &lt; group-&gt;n_entries; j++)
1511     {
1512       if (arg == group-&gt;entries[j].short_name)
1513         {
1514           gchar *option_name;
1515           gchar *value = NULL;
1516 
1517           option_name = g_strdup_printf (&quot;-%c&quot;, group-&gt;entries[j].short_name);
1518 
1519           if (NO_ARG (&amp;group-&gt;entries[j]))
1520             value = NULL;
1521           else
1522             {
1523               if (*new_idx &gt; idx)
1524                 {
1525                   g_set_error (error,
1526                                G_OPTION_ERROR, G_OPTION_ERROR_FAILED,
1527                                _(&quot;Error parsing option %s&quot;), option_name);
1528                   g_free (option_name);
</pre>
<hr />
<pre>
1570 
1571           g_free (option_name);
1572           *parsed = TRUE;
1573         }
1574     }
1575 
1576   return TRUE;
1577 }
1578 
1579 static gboolean
1580 parse_long_option (GOptionContext *context,
1581                    GOptionGroup   *group,
1582                    gint           *idx,
1583                    gchar          *arg,
1584                    gboolean        aliased,
1585                    gint           *argc,
1586                    gchar        ***argv,
1587                    GError        **error,
1588                    gboolean       *parsed)
1589 {
<span class="line-modified">1590   gint j;</span>
1591 
1592   for (j = 0; j &lt; group-&gt;n_entries; j++)
1593     {
1594       if (*idx &gt;= *argc)
1595         return TRUE;
1596 
1597       if (aliased &amp;&amp; (group-&gt;entries[j].flags &amp; G_OPTION_FLAG_NOALIAS))
1598         continue;
1599 
1600       if (NO_ARG (&amp;group-&gt;entries[j]) &amp;&amp;
1601           strcmp (arg, group-&gt;entries[j].long_name) == 0)
1602         {
1603           gchar *option_name;
1604           gboolean retval;
1605 
1606           option_name = g_strconcat (&quot;--&quot;, group-&gt;entries[j].long_name, NULL);
1607           retval = parse_arg (context, group, &amp;group-&gt;entries[j],
1608                               NULL, option_name, error);
1609           g_free (option_name);
1610 
</pre>
<hr />
<pre>
1681                 }
1682 
1683               g_free (option_name);
1684               *parsed = TRUE;
1685             }
1686         }
1687     }
1688 
1689   return TRUE;
1690 }
1691 
1692 static gboolean
1693 parse_remaining_arg (GOptionContext *context,
1694                      GOptionGroup   *group,
1695                      gint           *idx,
1696                      gint           *argc,
1697                      gchar        ***argv,
1698                      GError        **error,
1699                      gboolean       *parsed)
1700 {
<span class="line-modified">1701   gint j;</span>
1702 
1703   for (j = 0; j &lt; group-&gt;n_entries; j++)
1704     {
1705       if (*idx &gt;= *argc)
1706         return TRUE;
1707 
1708       if (group-&gt;entries[j].long_name[0])
1709         continue;
1710 
1711       g_return_val_if_fail (group-&gt;entries[j].arg == G_OPTION_ARG_CALLBACK ||
1712                             group-&gt;entries[j].arg == G_OPTION_ARG_STRING_ARRAY ||
1713                             group-&gt;entries[j].arg == G_OPTION_ARG_FILENAME_ARRAY, FALSE);
1714 
1715       add_pending_null (context, &amp;((*argv)[*idx]), NULL);
1716 
1717       if (!parse_arg (context, group, &amp;group-&gt;entries[j], (*argv)[*idx], &quot;&quot;, error))
1718         return FALSE;
1719 
1720       *parsed = TRUE;
1721       return TRUE;
</pre>
<hr />
<pre>
1798               *n-&gt;ptr = NULL;
1799             }
1800         }
1801 
1802       g_free (n-&gt;value);
1803       g_free (n);
1804     }
1805 
1806   g_list_free (context-&gt;pending_nulls);
1807   context-&gt;pending_nulls = NULL;
1808 }
1809 
1810 /* Use a platform-specific mechanism to look up the first argument to
1811  * the current process.
1812  * Note if you implement this for other platforms, also add it to
1813  * tests/option-argv0.c
1814  */
1815 static char *
1816 platform_get_argv0 (void)
1817 {
<span class="line-modified">1818 #if defined __linux</span>
1819   char *cmdline;
1820   char *base_arg0;
1821   gsize len;
1822 
1823   if (!g_file_get_contents (&quot;/proc/self/cmdline&quot;,
<span class="line-modified">1824                 &amp;cmdline,</span>
<span class="line-modified">1825                 &amp;len,</span>
<span class="line-modified">1826                 NULL))</span>
1827     return NULL;

1828   /* Sanity check for a NUL terminator. */
<span class="line-modified">1829   if (!memchr (cmdline, 0, len))</span>
<span class="line-modified">1830     return NULL;</span>
1831   /* We could just return cmdline, but I think it&#39;s better
1832    * to hold on to a smaller malloc block; the arguments
1833    * could be large.
1834    */
1835   base_arg0 = g_path_get_basename (cmdline);
1836   g_free (cmdline);
1837   return base_arg0;
1838 #elif defined __OpenBSD__
1839   char **cmdline;
1840   char *base_arg0;
1841   gsize len;
1842 
1843   int mib[] = { CTL_KERN, KERN_PROC_ARGS, getpid(), KERN_PROC_ARGV };
1844 
1845   if (sysctl (mib, G_N_ELEMENTS (mib), NULL, &amp;len, NULL, 0) == -1)
1846       return NULL;
1847 
1848   cmdline = g_malloc0 (len);
1849 
1850   if (sysctl (mib, G_N_ELEMENTS (mib), cmdline, &amp;len, NULL, 0) == -1)
1851     {
1852       g_free (cmdline);
1853       return NULL;
1854     }
1855 
1856   /* We could just return cmdline, but I think it&#39;s better
1857    * to hold on to a smaller malloc block; the arguments
1858    * could be large.
1859    */
1860   base_arg0 = g_path_get_basename (*cmdline);
1861   g_free (cmdline);
1862   return base_arg0;













































1863 #endif
1864 
1865   return NULL;
1866 }
1867 
1868 /**
1869  * g_option_context_parse:
1870  * @context: a #GOptionContext
1871  * @argc: (inout) (optional): a pointer to the number of command line arguments
1872  * @argv: (inout) (array length=argc) (optional): a pointer to the array of command line arguments
1873  * @error: a return location for errors
1874  *
1875  * Parses the command line arguments, recognizing options
1876  * which have been added to @context. A side-effect of
1877  * calling this function is that g_set_prgname() will be
1878  * called.
1879  *
1880  * If the parsing is successful, any parsed arguments are
1881  * removed from the array and @argc and @argv are updated
1882  * accordingly. A &#39;--&#39; option is stripped from @argv
</pre>
<hr />
<pre>
1891  * call `exit (0)`.
1892  *
1893  * Note that function depends on the [current locale][setlocale] for
1894  * automatic character set conversion of string and filename
1895  * arguments.
1896  *
1897  * Returns: %TRUE if the parsing was successful,
1898  *               %FALSE if an error occurred
1899  *
1900  * Since: 2.6
1901  **/
1902 gboolean
1903 g_option_context_parse (GOptionContext   *context,
1904                         gint             *argc,
1905                         gchar          ***argv,
1906                         GError          **error)
1907 {
1908   gint i, j, k;
1909   GList *list;
1910 


1911   /* Set program name */
1912   if (!g_get_prgname())
1913     {
1914       gchar *prgname;
1915 
1916       if (argc &amp;&amp; argv &amp;&amp; *argc)
<span class="line-modified">1917     prgname = g_path_get_basename ((*argv)[0]);</span>
1918       else
<span class="line-modified">1919     prgname = platform_get_argv0 ();</span>
1920 
1921       if (prgname)
<span class="line-modified">1922     g_set_prgname (prgname);</span>
1923       else
<span class="line-modified">1924     g_set_prgname (&quot;&lt;unknown&gt;&quot;);</span>
1925 
1926       g_free (prgname);
1927     }
1928 
1929   /* Call pre-parse hooks */
1930   list = context-&gt;groups;
1931   while (list)
1932     {
1933       GOptionGroup *group = list-&gt;data;
1934 
1935       if (group-&gt;pre_parse_func)
1936         {
1937           if (!(* group-&gt;pre_parse_func) (context, group,
1938                                           group-&gt;user_data, error))
1939             goto fail;
1940         }
1941 
1942       list = list-&gt;next;
1943     }
1944 
</pre>
<hr />
<pre>
2307   return group;
2308 }
2309 
2310 /**
2311  * g_option_group_unref:
2312  * @group: a #GOptionGroup
2313  *
2314  * Decrements the reference count of @group by one.
2315  * If the reference count drops to 0, the @group will be freed.
2316  * and all memory allocated by the @group is released.
2317  *
2318  * Since: 2.44
2319  */
2320 void
2321 g_option_group_unref (GOptionGroup *group)
2322 {
2323   g_return_if_fail (group != NULL);
2324 
2325   if (--group-&gt;ref_count == 0)
2326     {
<span class="line-modified">2327   g_free (group-&gt;name);</span>
<span class="line-modified">2328   g_free (group-&gt;description);</span>
<span class="line-modified">2329   g_free (group-&gt;help_description);</span>
2330 
<span class="line-modified">2331   g_free (group-&gt;entries);</span>
2332 
<span class="line-modified">2333   if (group-&gt;destroy_notify)</span>
<span class="line-modified">2334     (* group-&gt;destroy_notify) (group-&gt;user_data);</span>
2335 
<span class="line-modified">2336   if (group-&gt;translate_notify)</span>
<span class="line-modified">2337     (* group-&gt;translate_notify) (group-&gt;translate_data);</span>
2338 
<span class="line-modified">2339   g_free (group);</span>
<span class="line-modified">2340 }</span>
2341 }
2342 
2343 /**
2344  * g_option_group_add_entries:
2345  * @group: a #GOptionGroup
2346  * @entries: a %NULL-terminated array of #GOptionEntrys
2347  *
2348  * Adds the options specified in @entries to @group.
2349  *
2350  * Since: 2.6
2351  **/
2352 void
2353 g_option_group_add_entries (GOptionGroup       *group,
2354                             const GOptionEntry *entries)
2355 {
<span class="line-modified">2356   gint i, n_entries;</span>
2357 

2358   g_return_if_fail (entries != NULL);
2359 
2360   for (n_entries = 0; entries[n_entries].long_name != NULL; n_entries++) ;
2361 
2362   group-&gt;entries = g_renew (GOptionEntry, group-&gt;entries, group-&gt;n_entries + n_entries);
2363 
2364   /* group-&gt;entries could be NULL in the trivial case where we add no
2365    * entries to no entries */
2366   if (n_entries != 0)
<span class="line-modified">2367   memcpy (group-&gt;entries + group-&gt;n_entries, entries, sizeof (GOptionEntry) * n_entries);</span>
2368 
2369   for (i = group-&gt;n_entries; i &lt; group-&gt;n_entries + n_entries; i++)
2370     {
2371       gchar c = group-&gt;entries[i].short_name;
2372 
2373       if (c == &#39;-&#39; || (c != 0 &amp;&amp; !g_ascii_isprint (c)))
2374         {
2375           g_warning (G_STRLOC &quot;: ignoring invalid short option &#39;%c&#39; (%d) in entry %s:%s&quot;,
2376               c, c, group-&gt;name, group-&gt;entries[i].long_name);
2377           group-&gt;entries[i].short_name = &#39;\0&#39;;
2378         }
2379 
2380       if (group-&gt;entries[i].arg != G_OPTION_ARG_NONE &amp;&amp;
2381           (group-&gt;entries[i].flags &amp; G_OPTION_FLAG_REVERSE) != 0)
2382         {
2383           g_warning (G_STRLOC &quot;: ignoring reverse flag on option of arg-type %d in entry %s:%s&quot;,
2384               group-&gt;entries[i].arg, group-&gt;name, group-&gt;entries[i].long_name);
2385 
2386           group-&gt;entries[i].flags &amp;= ~G_OPTION_FLAG_REVERSE;
2387         }
</pre>
<hr />
<pre>
2642  * g_option_context_get_description:
2643  * @context: a #GOptionContext
2644  *
2645  * Returns the description. See g_option_context_set_description().
2646  *
2647  * Returns: the description
2648  *
2649  * Since: 2.12
2650  */
2651 const gchar *
2652 g_option_context_get_description (GOptionContext *context)
2653 {
2654   g_return_val_if_fail (context != NULL, NULL);
2655 
2656   return context-&gt;description;
2657 }
2658 
2659 /**
2660  * g_option_context_parse_strv:
2661  * @context: a #GOptionContext
<span class="line-modified">2662  * @arguments: (inout) (array null-terminated=1): a pointer to the</span>
<span class="line-modified">2663  *    command line arguments (which must be in UTF-8 on Windows)</span>


2664  * @error: a return location for errors
2665  *
2666  * Parses the command line arguments.
2667  *
2668  * This function is similar to g_option_context_parse() except that it
2669  * respects the normal memory rules when dealing with a strv instead of
2670  * assuming that the passed-in array is the argv of the main function.
2671  *
2672  * In particular, strings that are removed from the arguments list will
2673  * be freed using g_free().
2674  *
2675  * On Windows, the strings are expected to be in UTF-8.  This is in
2676  * contrast to g_option_context_parse() which expects them to be in the
2677  * system codepage, which is how they are passed as @argv to main().
2678  * See g_win32_get_command_line() for a solution.
2679  *
2680  * This function is useful if you are trying to use #GOptionContext with
2681  * #GApplication.
2682  *
2683  * Returns: %TRUE if the parsing was successful,
2684  *          %FALSE if an error occurred
2685  *
2686  * Since: 2.40
2687  **/
2688 gboolean
2689 g_option_context_parse_strv (GOptionContext   *context,
2690                              gchar          ***arguments,
2691                              GError          **error)
2692 {
2693   gboolean success;
2694   gint argc;
2695 


2696   context-&gt;strv_mode = TRUE;
<span class="line-modified">2697   argc = g_strv_length (*arguments);</span>
2698   success = g_option_context_parse (context, &amp;argc, arguments, error);
2699   context-&gt;strv_mode = FALSE;
2700 
2701   return success;
2702 }
</pre>
</td>
<td>
<hr />
<pre>
 177  * ]|
 178  */
 179 
 180 #include &quot;config.h&quot;
 181 
 182 #include &lt;string.h&gt;
 183 #include &lt;stdlib.h&gt;
 184 #include &lt;stdio.h&gt;
 185 #include &lt;errno.h&gt;
 186 
 187 #if defined __OpenBSD__
 188 #include &lt;unistd.h&gt;
 189 #include &lt;sys/sysctl.h&gt;
 190 #endif
 191 
 192 #include &quot;goption.h&quot;
 193 
 194 #include &quot;gprintf.h&quot;
 195 #include &quot;glibintl.h&quot;
 196 
<span class="line-added"> 197 #if defined G_OS_WIN32</span>
<span class="line-added"> 198 #include &lt;windows.h&gt;</span>
<span class="line-added"> 199 #endif</span>
<span class="line-added"> 200 </span>
 201 #define TRANSLATE(group, str) (((group)-&gt;translate_func ? (* (group)-&gt;translate_func) ((str), (group)-&gt;translate_data) : (str)))
 202 
 203 #define NO_ARG(entry) ((entry)-&gt;arg == G_OPTION_ARG_NONE ||       \
 204                        ((entry)-&gt;arg == G_OPTION_ARG_CALLBACK &amp;&amp;  \
 205                         ((entry)-&gt;flags &amp; G_OPTION_FLAG_NO_ARG)))
 206 
 207 #define OPTIONAL_ARG(entry) ((entry)-&gt;arg == G_OPTION_ARG_CALLBACK &amp;&amp;  \
 208                        (entry)-&gt;flags &amp; G_OPTION_FLAG_OPTIONAL_ARG)
 209 
 210 typedef struct
 211 {
 212   GOptionArg arg_type;
 213   gpointer arg_data;
 214   union
 215   {
 216     gboolean bool;
 217     gint integer;
 218     gchar *str;
 219     gchar **array;
 220     gdouble dbl;
</pre>
<hr />
<pre>
 264    */
 265   GList           *pending_nulls;
 266 };
 267 
 268 struct _GOptionGroup
 269 {
 270   gchar           *name;
 271   gchar           *description;
 272   gchar           *help_description;
 273 
 274   gint             ref_count;
 275 
 276   GDestroyNotify   destroy_notify;
 277   gpointer         user_data;
 278 
 279   GTranslateFunc   translate_func;
 280   GDestroyNotify   translate_notify;
 281   gpointer         translate_data;
 282 
 283   GOptionEntry    *entries;
<span class="line-modified"> 284   gsize            n_entries;</span>
 285 
 286   GOptionParseFunc pre_parse_func;
 287   GOptionParseFunc post_parse_func;
 288   GOptionErrorFunc error_func;
 289 };
 290 
 291 static void free_changes_list (GOptionContext *context,
 292                                gboolean        revert);
 293 static void free_pending_nulls (GOptionContext *context,
 294                                 gboolean        perform_nulls);
 295 
 296 
 297 static int
 298 _g_unichar_get_width (gunichar c)
 299 {
 300   if (G_UNLIKELY (g_unichar_iszerowidth (c)))
 301     return 0;
 302 
 303   /* we ignore the fact that we should call g_unichar_iswide_cjk() under
 304    * some locales (legacy East Asian ones) */
</pre>
<hr />
<pre>
 638 }
 639 
 640 /**
 641  * g_option_context_add_main_entries:
 642  * @context: a #GOptionContext
 643  * @entries: a %NULL-terminated array of #GOptionEntrys
 644  * @translation_domain: (nullable): a translation domain to use for translating
 645  *    the `--help` output for the options in @entries
 646  *    with gettext(), or %NULL
 647  *
 648  * A convenience function which creates a main group if it doesn&#39;t
 649  * exist, adds the @entries to it and sets the translation domain.
 650  *
 651  * Since: 2.6
 652  **/
 653 void
 654 g_option_context_add_main_entries (GOptionContext      *context,
 655                                    const GOptionEntry  *entries,
 656                                    const gchar         *translation_domain)
 657 {
<span class="line-added"> 658   g_return_if_fail (context != NULL);</span>
 659   g_return_if_fail (entries != NULL);
 660 
 661   if (!context-&gt;main_group)
 662     context-&gt;main_group = g_option_group_new (NULL, NULL, NULL, NULL, NULL);
 663 
 664   g_option_group_add_entries (context-&gt;main_group, entries);
 665   g_option_group_set_translation_domain (context-&gt;main_group, translation_domain);
 666 }
 667 
 668 static gint
 669 calculate_max_length (GOptionGroup *group,
 670                       GHashTable   *aliases)
 671 {
 672   GOptionEntry *entry;
<span class="line-modified"> 673   gsize i, len, max_length;</span>
 674   const gchar *long_name;
 675 
 676   max_length = 0;
 677 
 678   for (i = 0; i &lt; group-&gt;n_entries; i++)
 679     {
 680       entry = &amp;group-&gt;entries[i];
 681 
 682       if (entry-&gt;flags &amp; G_OPTION_FLAG_HIDDEN)
 683         continue;
 684 
 685       long_name = g_hash_table_lookup (aliases, &amp;entry-&gt;long_name);
 686       if (!long_name)
 687         long_name = entry-&gt;long_name;
 688       len = _g_utf8_strwidth (long_name);
 689 
 690       if (entry-&gt;short_name)
 691         len += 4;
 692 
 693       if (!NO_ARG (entry) &amp;&amp; entry-&gt;arg_description)
</pre>
<hr />
<pre>
 816  *
 817  * Returns a formatted, translated help text for the given context.
 818  * To obtain the text produced by `--help`, call
 819  * `g_option_context_get_help (context, TRUE, NULL)`.
 820  * To obtain the text produced by `--help-all`, call
 821  * `g_option_context_get_help (context, FALSE, NULL)`.
 822  * To obtain the help text for an option group, call
 823  * `g_option_context_get_help (context, FALSE, group)`.
 824  *
 825  * Returns: A newly allocated string containing the help text
 826  *
 827  * Since: 2.14
 828  */
 829 gchar *
 830 g_option_context_get_help (GOptionContext *context,
 831                            gboolean        main_help,
 832                            GOptionGroup   *group)
 833 {
 834   GList *list;
 835   gint max_length = 0, len;
<span class="line-modified"> 836   gsize i;</span>
 837   GOptionEntry *entry;
 838   GHashTable *shadow_map;
 839   GHashTable *aliases;
 840   gboolean seen[256];
 841   const gchar *rest_description;
 842   GString *string;
 843   guchar token;
 844 
<span class="line-added"> 845   g_return_val_if_fail (context != NULL, NULL);</span>
<span class="line-added"> 846 </span>
 847   string = g_string_sized_new (1024);
 848 
 849   rest_description = NULL;
 850   if (context-&gt;main_group)
 851     {
 852 
 853       for (i = 0; i &lt; context-&gt;main_group-&gt;n_entries; i++)
 854         {
 855           entry = &amp;context-&gt;main_group-&gt;entries[i];
 856           if (entry-&gt;long_name[0] == 0)
 857             {
 858               rest_description = TRANSLATE (context-&gt;main_group, entry-&gt;arg_description);
 859               break;
 860             }
 861         }
 862     }
 863 
 864   g_string_append_printf (string, &quot;%s\n  %s&quot;, _(&quot;Usage:&quot;), g_get_prgname ());
 865   if (context-&gt;help_enabled ||
 866       (context-&gt;main_group &amp;&amp; context-&gt;main_group-&gt;n_entries &gt; 0) ||
</pre>
<hr />
<pre>
1034               g_string_append (string, &quot;\n&quot;);
1035               for (i = 0; i &lt; g-&gt;n_entries; i++)
1036                 if (!(g-&gt;entries[i].flags &amp; G_OPTION_FLAG_IN_MAIN))
1037                   print_entry (g, max_length, &amp;g-&gt;entries[i], string, aliases);
1038 
1039               g_string_append (string, &quot;\n&quot;);
1040             }
1041 
1042           list = list-&gt;next;
1043         }
1044     }
1045 
1046   /* Print application options if --help or --help-all has been specified */
1047   if ((main_help || !group) &amp;&amp;
1048       (group_has_visible_entries (context, context-&gt;main_group, TRUE) ||
1049        group_list_has_visible_entries (context, context-&gt;groups, TRUE)))
1050     {
1051       list = context-&gt;groups;
1052 
1053       if (context-&gt;help_enabled || list)
<span class="line-modified">1054         g_string_append (string,  _(&quot;Application Options:&quot;));</span>
1055       else
1056         g_string_append (string, _(&quot;Options:&quot;));
1057       g_string_append (string, &quot;\n&quot;);
1058       if (context-&gt;main_group)
1059         for (i = 0; i &lt; context-&gt;main_group-&gt;n_entries; i++)
1060           print_entry (context-&gt;main_group, max_length,
1061                        &amp;context-&gt;main_group-&gt;entries[i], string, aliases);
1062 
1063       while (list != NULL)
1064         {
1065           GOptionGroup *g = list-&gt;data;
1066 
1067           /* Print main entries from other groups */
1068           for (i = 0; i &lt; g-&gt;n_entries; i++)
1069             if (g-&gt;entries[i].flags &amp; G_OPTION_FLAG_IN_MAIN)
1070               print_entry (g, max_length, &amp;g-&gt;entries[i], string, aliases);
1071 
1072           list = list-&gt;next;
1073         }
1074 
</pre>
<hr />
<pre>
1275         gchar *data;
1276 
1277 #ifdef G_OS_WIN32
1278         if (!context-&gt;strv_mode)
1279           data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1280         else
1281           data = g_strdup (value);
1282 #else
1283         data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1284 #endif
1285 
1286         if (!data)
1287           return FALSE;
1288 
1289         change = get_change (context, G_OPTION_ARG_STRING,
1290                              entry-&gt;arg_data);
1291 
1292         if (!change-&gt;allocated.str)
1293           change-&gt;prev.str = *(gchar **)entry-&gt;arg_data;
1294         else
<span class="line-modified">1295           g_free (change-&gt;allocated.str);</span>
1296 
1297         change-&gt;allocated.str = data;
1298 
1299         *(gchar **)entry-&gt;arg_data = data;
1300         break;
1301       }
1302     case G_OPTION_ARG_STRING_ARRAY:
1303       {
1304         gchar *data;
1305 
1306 #ifdef G_OS_WIN32
1307         if (!context-&gt;strv_mode)
1308           data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1309         else
1310           data = g_strdup (value);
1311 #else
1312         data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1313 #endif
1314 
1315         if (!data)
</pre>
<hr />
<pre>
1342       {
1343         gchar *data;
1344 
1345 #ifdef G_OS_WIN32
1346         if (!context-&gt;strv_mode)
1347           data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1348         else
1349           data = g_strdup (value);
1350 
1351         if (!data)
1352           return FALSE;
1353 #else
1354         data = g_strdup (value);
1355 #endif
1356         change = get_change (context, G_OPTION_ARG_FILENAME,
1357                              entry-&gt;arg_data);
1358 
1359         if (!change-&gt;allocated.str)
1360           change-&gt;prev.str = *(gchar **)entry-&gt;arg_data;
1361         else
<span class="line-modified">1362           g_free (change-&gt;allocated.str);</span>
1363 
1364         change-&gt;allocated.str = data;
1365 
1366         *(gchar **)entry-&gt;arg_data = data;
1367         break;
1368       }
1369 
1370     case G_OPTION_ARG_FILENAME_ARRAY:
1371       {
1372         gchar *data;
1373 
1374 #ifdef G_OS_WIN32
1375         if (!context-&gt;strv_mode)
1376           data = g_locale_to_utf8 (value, -1, NULL, NULL, error);
1377         else
1378           data = g_strdup (value);
1379 
1380         if (!data)
1381           return FALSE;
1382 #else
</pre>
<hr />
<pre>
1495         break;
1496       }
1497     default:
1498       g_assert_not_reached ();
1499     }
1500 
1501   return TRUE;
1502 }
1503 
1504 static gboolean
1505 parse_short_option (GOptionContext *context,
1506                     GOptionGroup   *group,
1507                     gint            idx,
1508                     gint           *new_idx,
1509                     gchar           arg,
1510                     gint           *argc,
1511                     gchar        ***argv,
1512                     GError        **error,
1513                     gboolean       *parsed)
1514 {
<span class="line-modified">1515   gsize j;</span>
1516 
1517   for (j = 0; j &lt; group-&gt;n_entries; j++)
1518     {
1519       if (arg == group-&gt;entries[j].short_name)
1520         {
1521           gchar *option_name;
1522           gchar *value = NULL;
1523 
1524           option_name = g_strdup_printf (&quot;-%c&quot;, group-&gt;entries[j].short_name);
1525 
1526           if (NO_ARG (&amp;group-&gt;entries[j]))
1527             value = NULL;
1528           else
1529             {
1530               if (*new_idx &gt; idx)
1531                 {
1532                   g_set_error (error,
1533                                G_OPTION_ERROR, G_OPTION_ERROR_FAILED,
1534                                _(&quot;Error parsing option %s&quot;), option_name);
1535                   g_free (option_name);
</pre>
<hr />
<pre>
1577 
1578           g_free (option_name);
1579           *parsed = TRUE;
1580         }
1581     }
1582 
1583   return TRUE;
1584 }
1585 
1586 static gboolean
1587 parse_long_option (GOptionContext *context,
1588                    GOptionGroup   *group,
1589                    gint           *idx,
1590                    gchar          *arg,
1591                    gboolean        aliased,
1592                    gint           *argc,
1593                    gchar        ***argv,
1594                    GError        **error,
1595                    gboolean       *parsed)
1596 {
<span class="line-modified">1597   gsize j;</span>
1598 
1599   for (j = 0; j &lt; group-&gt;n_entries; j++)
1600     {
1601       if (*idx &gt;= *argc)
1602         return TRUE;
1603 
1604       if (aliased &amp;&amp; (group-&gt;entries[j].flags &amp; G_OPTION_FLAG_NOALIAS))
1605         continue;
1606 
1607       if (NO_ARG (&amp;group-&gt;entries[j]) &amp;&amp;
1608           strcmp (arg, group-&gt;entries[j].long_name) == 0)
1609         {
1610           gchar *option_name;
1611           gboolean retval;
1612 
1613           option_name = g_strconcat (&quot;--&quot;, group-&gt;entries[j].long_name, NULL);
1614           retval = parse_arg (context, group, &amp;group-&gt;entries[j],
1615                               NULL, option_name, error);
1616           g_free (option_name);
1617 
</pre>
<hr />
<pre>
1688                 }
1689 
1690               g_free (option_name);
1691               *parsed = TRUE;
1692             }
1693         }
1694     }
1695 
1696   return TRUE;
1697 }
1698 
1699 static gboolean
1700 parse_remaining_arg (GOptionContext *context,
1701                      GOptionGroup   *group,
1702                      gint           *idx,
1703                      gint           *argc,
1704                      gchar        ***argv,
1705                      GError        **error,
1706                      gboolean       *parsed)
1707 {
<span class="line-modified">1708   gsize j;</span>
1709 
1710   for (j = 0; j &lt; group-&gt;n_entries; j++)
1711     {
1712       if (*idx &gt;= *argc)
1713         return TRUE;
1714 
1715       if (group-&gt;entries[j].long_name[0])
1716         continue;
1717 
1718       g_return_val_if_fail (group-&gt;entries[j].arg == G_OPTION_ARG_CALLBACK ||
1719                             group-&gt;entries[j].arg == G_OPTION_ARG_STRING_ARRAY ||
1720                             group-&gt;entries[j].arg == G_OPTION_ARG_FILENAME_ARRAY, FALSE);
1721 
1722       add_pending_null (context, &amp;((*argv)[*idx]), NULL);
1723 
1724       if (!parse_arg (context, group, &amp;group-&gt;entries[j], (*argv)[*idx], &quot;&quot;, error))
1725         return FALSE;
1726 
1727       *parsed = TRUE;
1728       return TRUE;
</pre>
<hr />
<pre>
1805               *n-&gt;ptr = NULL;
1806             }
1807         }
1808 
1809       g_free (n-&gt;value);
1810       g_free (n);
1811     }
1812 
1813   g_list_free (context-&gt;pending_nulls);
1814   context-&gt;pending_nulls = NULL;
1815 }
1816 
1817 /* Use a platform-specific mechanism to look up the first argument to
1818  * the current process.
1819  * Note if you implement this for other platforms, also add it to
1820  * tests/option-argv0.c
1821  */
1822 static char *
1823 platform_get_argv0 (void)
1824 {
<span class="line-modified">1825 #ifdef HAVE_PROC_SELF_CMDLINE</span>
1826   char *cmdline;
1827   char *base_arg0;
1828   gsize len;
1829 
1830   if (!g_file_get_contents (&quot;/proc/self/cmdline&quot;,
<span class="line-modified">1831           &amp;cmdline,</span>
<span class="line-modified">1832           &amp;len,</span>
<span class="line-modified">1833           NULL))</span>
1834     return NULL;
<span class="line-added">1835 </span>
1836   /* Sanity check for a NUL terminator. */
<span class="line-modified">1837   g_assert (memchr (cmdline, 0, len));</span>
<span class="line-modified">1838 </span>
1839   /* We could just return cmdline, but I think it&#39;s better
1840    * to hold on to a smaller malloc block; the arguments
1841    * could be large.
1842    */
1843   base_arg0 = g_path_get_basename (cmdline);
1844   g_free (cmdline);
1845   return base_arg0;
1846 #elif defined __OpenBSD__
1847   char **cmdline;
1848   char *base_arg0;
1849   gsize len;
1850 
1851   int mib[] = { CTL_KERN, KERN_PROC_ARGS, getpid(), KERN_PROC_ARGV };
1852 
1853   if (sysctl (mib, G_N_ELEMENTS (mib), NULL, &amp;len, NULL, 0) == -1)
1854       return NULL;
1855 
1856   cmdline = g_malloc0 (len);
1857 
1858   if (sysctl (mib, G_N_ELEMENTS (mib), cmdline, &amp;len, NULL, 0) == -1)
1859     {
1860       g_free (cmdline);
1861       return NULL;
1862     }
1863 
1864   /* We could just return cmdline, but I think it&#39;s better
1865    * to hold on to a smaller malloc block; the arguments
1866    * could be large.
1867    */
1868   base_arg0 = g_path_get_basename (*cmdline);
1869   g_free (cmdline);
1870   return base_arg0;
<span class="line-added">1871 #elif defined G_OS_WIN32</span>
<span class="line-added">1872   const wchar_t *cmdline;</span>
<span class="line-added">1873   wchar_t **wargv;</span>
<span class="line-added">1874   int wargc;</span>
<span class="line-added">1875   gchar *utf8_buf = NULL;</span>
<span class="line-added">1876   char *base_arg0 = NULL;</span>
<span class="line-added">1877 </span>
<span class="line-added">1878   /* Pretend it&#39;s const, since we&#39;re not allowed to free it */</span>
<span class="line-added">1879   cmdline = (const wchar_t *) GetCommandLineW ();</span>
<span class="line-added">1880   if (G_UNLIKELY (cmdline == NULL))</span>
<span class="line-added">1881     return NULL;</span>
<span class="line-added">1882 </span>
<span class="line-added">1883   /* Skip leading whitespace. CommandLineToArgvW() is documented</span>
<span class="line-added">1884    * to behave weirdly with that. The character codes below</span>
<span class="line-added">1885    * correspond to the *only* unicode characters that are</span>
<span class="line-added">1886    * considered to be spaces by CommandLineToArgvW(). The rest</span>
<span class="line-added">1887    * (such as 0xa0 - NO-BREAK SPACE) are treated as</span>
<span class="line-added">1888    * normal characters.</span>
<span class="line-added">1889    */</span>
<span class="line-added">1890   while (cmdline[0] == 0x09 ||</span>
<span class="line-added">1891          cmdline[0] == 0x0a ||</span>
<span class="line-added">1892          cmdline[0] == 0x0c ||</span>
<span class="line-added">1893          cmdline[0] == 0x0d ||</span>
<span class="line-added">1894          cmdline[0] == 0x20)</span>
<span class="line-added">1895     cmdline++;</span>
<span class="line-added">1896 </span>
<span class="line-added">1897   wargv = CommandLineToArgvW (cmdline, &amp;wargc);</span>
<span class="line-added">1898   if (G_UNLIKELY (wargv == NULL))</span>
<span class="line-added">1899     return NULL;</span>
<span class="line-added">1900 </span>
<span class="line-added">1901   if (wargc &gt; 0)</span>
<span class="line-added">1902     utf8_buf = g_utf16_to_utf8 (wargv[0], -1, NULL, NULL, NULL);</span>
<span class="line-added">1903 </span>
<span class="line-added">1904   LocalFree (wargv);</span>
<span class="line-added">1905 </span>
<span class="line-added">1906   if (G_UNLIKELY (utf8_buf == NULL))</span>
<span class="line-added">1907     return NULL;</span>
<span class="line-added">1908 </span>
<span class="line-added">1909   /* We could just return cmdline, but I think it&#39;s better</span>
<span class="line-added">1910    * to hold on to a smaller malloc block; the arguments</span>
<span class="line-added">1911    * could be large.</span>
<span class="line-added">1912    */</span>
<span class="line-added">1913   base_arg0 = g_path_get_basename (utf8_buf);</span>
<span class="line-added">1914   g_free (utf8_buf);</span>
<span class="line-added">1915   return base_arg0;</span>
1916 #endif
1917 
1918   return NULL;
1919 }
1920 
1921 /**
1922  * g_option_context_parse:
1923  * @context: a #GOptionContext
1924  * @argc: (inout) (optional): a pointer to the number of command line arguments
1925  * @argv: (inout) (array length=argc) (optional): a pointer to the array of command line arguments
1926  * @error: a return location for errors
1927  *
1928  * Parses the command line arguments, recognizing options
1929  * which have been added to @context. A side-effect of
1930  * calling this function is that g_set_prgname() will be
1931  * called.
1932  *
1933  * If the parsing is successful, any parsed arguments are
1934  * removed from the array and @argc and @argv are updated
1935  * accordingly. A &#39;--&#39; option is stripped from @argv
</pre>
<hr />
<pre>
1944  * call `exit (0)`.
1945  *
1946  * Note that function depends on the [current locale][setlocale] for
1947  * automatic character set conversion of string and filename
1948  * arguments.
1949  *
1950  * Returns: %TRUE if the parsing was successful,
1951  *               %FALSE if an error occurred
1952  *
1953  * Since: 2.6
1954  **/
1955 gboolean
1956 g_option_context_parse (GOptionContext   *context,
1957                         gint             *argc,
1958                         gchar          ***argv,
1959                         GError          **error)
1960 {
1961   gint i, j, k;
1962   GList *list;
1963 
<span class="line-added">1964   g_return_val_if_fail (context != NULL, FALSE);</span>
<span class="line-added">1965 </span>
1966   /* Set program name */
1967   if (!g_get_prgname())
1968     {
1969       gchar *prgname;
1970 
1971       if (argc &amp;&amp; argv &amp;&amp; *argc)
<span class="line-modified">1972   prgname = g_path_get_basename ((*argv)[0]);</span>
1973       else
<span class="line-modified">1974   prgname = platform_get_argv0 ();</span>
1975 
1976       if (prgname)
<span class="line-modified">1977   g_set_prgname (prgname);</span>
1978       else
<span class="line-modified">1979   g_set_prgname (&quot;&lt;unknown&gt;&quot;);</span>
1980 
1981       g_free (prgname);
1982     }
1983 
1984   /* Call pre-parse hooks */
1985   list = context-&gt;groups;
1986   while (list)
1987     {
1988       GOptionGroup *group = list-&gt;data;
1989 
1990       if (group-&gt;pre_parse_func)
1991         {
1992           if (!(* group-&gt;pre_parse_func) (context, group,
1993                                           group-&gt;user_data, error))
1994             goto fail;
1995         }
1996 
1997       list = list-&gt;next;
1998     }
1999 
</pre>
<hr />
<pre>
2362   return group;
2363 }
2364 
2365 /**
2366  * g_option_group_unref:
2367  * @group: a #GOptionGroup
2368  *
2369  * Decrements the reference count of @group by one.
2370  * If the reference count drops to 0, the @group will be freed.
2371  * and all memory allocated by the @group is released.
2372  *
2373  * Since: 2.44
2374  */
2375 void
2376 g_option_group_unref (GOptionGroup *group)
2377 {
2378   g_return_if_fail (group != NULL);
2379 
2380   if (--group-&gt;ref_count == 0)
2381     {
<span class="line-modified">2382       g_free (group-&gt;name);</span>
<span class="line-modified">2383       g_free (group-&gt;description);</span>
<span class="line-modified">2384       g_free (group-&gt;help_description);</span>
2385 
<span class="line-modified">2386       g_free (group-&gt;entries);</span>
2387 
<span class="line-modified">2388       if (group-&gt;destroy_notify)</span>
<span class="line-modified">2389         (* group-&gt;destroy_notify) (group-&gt;user_data);</span>
2390 
<span class="line-modified">2391       if (group-&gt;translate_notify)</span>
<span class="line-modified">2392         (* group-&gt;translate_notify) (group-&gt;translate_data);</span>
2393 
<span class="line-modified">2394       g_free (group);</span>
<span class="line-modified">2395     }</span>
2396 }
2397 
2398 /**
2399  * g_option_group_add_entries:
2400  * @group: a #GOptionGroup
2401  * @entries: a %NULL-terminated array of #GOptionEntrys
2402  *
2403  * Adds the options specified in @entries to @group.
2404  *
2405  * Since: 2.6
2406  **/
2407 void
2408 g_option_group_add_entries (GOptionGroup       *group,
2409                             const GOptionEntry *entries)
2410 {
<span class="line-modified">2411   gsize i, n_entries;</span>
2412 
<span class="line-added">2413   g_return_if_fail (group != NULL);</span>
2414   g_return_if_fail (entries != NULL);
2415 
2416   for (n_entries = 0; entries[n_entries].long_name != NULL; n_entries++) ;
2417 
2418   group-&gt;entries = g_renew (GOptionEntry, group-&gt;entries, group-&gt;n_entries + n_entries);
2419 
2420   /* group-&gt;entries could be NULL in the trivial case where we add no
2421    * entries to no entries */
2422   if (n_entries != 0)
<span class="line-modified">2423     memcpy (group-&gt;entries + group-&gt;n_entries, entries, sizeof (GOptionEntry) * n_entries);</span>
2424 
2425   for (i = group-&gt;n_entries; i &lt; group-&gt;n_entries + n_entries; i++)
2426     {
2427       gchar c = group-&gt;entries[i].short_name;
2428 
2429       if (c == &#39;-&#39; || (c != 0 &amp;&amp; !g_ascii_isprint (c)))
2430         {
2431           g_warning (G_STRLOC &quot;: ignoring invalid short option &#39;%c&#39; (%d) in entry %s:%s&quot;,
2432               c, c, group-&gt;name, group-&gt;entries[i].long_name);
2433           group-&gt;entries[i].short_name = &#39;\0&#39;;
2434         }
2435 
2436       if (group-&gt;entries[i].arg != G_OPTION_ARG_NONE &amp;&amp;
2437           (group-&gt;entries[i].flags &amp; G_OPTION_FLAG_REVERSE) != 0)
2438         {
2439           g_warning (G_STRLOC &quot;: ignoring reverse flag on option of arg-type %d in entry %s:%s&quot;,
2440               group-&gt;entries[i].arg, group-&gt;name, group-&gt;entries[i].long_name);
2441 
2442           group-&gt;entries[i].flags &amp;= ~G_OPTION_FLAG_REVERSE;
2443         }
</pre>
<hr />
<pre>
2698  * g_option_context_get_description:
2699  * @context: a #GOptionContext
2700  *
2701  * Returns the description. See g_option_context_set_description().
2702  *
2703  * Returns: the description
2704  *
2705  * Since: 2.12
2706  */
2707 const gchar *
2708 g_option_context_get_description (GOptionContext *context)
2709 {
2710   g_return_val_if_fail (context != NULL, NULL);
2711 
2712   return context-&gt;description;
2713 }
2714 
2715 /**
2716  * g_option_context_parse_strv:
2717  * @context: a #GOptionContext
<span class="line-modified">2718  * @arguments: (inout) (array null-terminated=1) (optional): a pointer</span>
<span class="line-modified">2719  *    to the command line arguments (which must be in UTF-8 on Windows).</span>
<span class="line-added">2720  *    Starting with GLib 2.62, @arguments can be %NULL, which matches</span>
<span class="line-added">2721  *    g_option_context_parse().</span>
2722  * @error: a return location for errors
2723  *
2724  * Parses the command line arguments.
2725  *
2726  * This function is similar to g_option_context_parse() except that it
2727  * respects the normal memory rules when dealing with a strv instead of
2728  * assuming that the passed-in array is the argv of the main function.
2729  *
2730  * In particular, strings that are removed from the arguments list will
2731  * be freed using g_free().
2732  *
2733  * On Windows, the strings are expected to be in UTF-8.  This is in
2734  * contrast to g_option_context_parse() which expects them to be in the
2735  * system codepage, which is how they are passed as @argv to main().
2736  * See g_win32_get_command_line() for a solution.
2737  *
2738  * This function is useful if you are trying to use #GOptionContext with
2739  * #GApplication.
2740  *
2741  * Returns: %TRUE if the parsing was successful,
2742  *          %FALSE if an error occurred
2743  *
2744  * Since: 2.40
2745  **/
2746 gboolean
2747 g_option_context_parse_strv (GOptionContext   *context,
2748                              gchar          ***arguments,
2749                              GError          **error)
2750 {
2751   gboolean success;
2752   gint argc;
2753 
<span class="line-added">2754   g_return_val_if_fail (context != NULL, FALSE);</span>
<span class="line-added">2755 </span>
2756   context-&gt;strv_mode = TRUE;
<span class="line-modified">2757   argc = arguments &amp;&amp; *arguments ? g_strv_length (*arguments) : 0;</span>
2758   success = g_option_context_parse (context, &amp;argc, arguments, error);
2759   context-&gt;strv_mode = FALSE;
2760 
2761   return success;
2762 }
</pre>
</td>
</tr>
</table>
<center><a href="gnulib/xsize.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="goption.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>