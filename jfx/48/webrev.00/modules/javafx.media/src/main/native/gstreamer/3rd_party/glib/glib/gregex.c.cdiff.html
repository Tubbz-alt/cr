<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gregex.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="grefcount.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gregex.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gregex.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1464,11 ***</span>
  
    if (compile_options_out != 0)
      *compile_options_out = compile_options;
  
    return re;
<span class="line-modified">!         }</span>
  
  /**
   * g_regex_get_pattern:
   * @regex: a #GRegex structure
   *
<span class="line-new-header">--- 1464,11 ---</span>
  
    if (compile_options_out != 0)
      *compile_options_out = compile_options;
  
    return re;
<span class="line-modified">! }</span>
  
  /**
   * g_regex_get_pattern:
   * @regex: a #GRegex structure
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2052,11 ***</span>
   * g_regex_new() and then use g_regex_split().
   *
   * As a special case, the result of splitting the empty string &quot;&quot;
   * is an empty vector, not a vector containing a single string.
   * The reason for this special case is that being able to represent
<span class="line-modified">!  * a empty vector is typically more useful than consistent handling</span>
   * of empty elements. If you do need to represent empty elements,
   * you&#39;ll need to check for the empty string before calling this
   * function.
   *
   * A pattern that can match empty strings splits @string into
<span class="line-new-header">--- 2052,11 ---</span>
   * g_regex_new() and then use g_regex_split().
   *
   * As a special case, the result of splitting the empty string &quot;&quot;
   * is an empty vector, not a vector containing a single string.
   * The reason for this special case is that being able to represent
<span class="line-modified">!  * an empty vector is typically more useful than consistent handling</span>
   * of empty elements. If you do need to represent empty elements,
   * you&#39;ll need to check for the empty string before calling this
   * function.
   *
   * A pattern that can match empty strings splits @string into
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2099,11 ***</span>
   * anywhere in the string, then the whole string is returned as the first
   * token.
   *
   * As a special case, the result of splitting the empty string &quot;&quot; is an
   * empty vector, not a vector containing a single string. The reason for
<span class="line-modified">!  * this special case is that being able to represent a empty vector is</span>
   * typically more useful than consistent handling of empty elements. If
   * you do need to represent empty elements, you&#39;ll need to check for the
   * empty string before calling this function.
   *
   * A pattern that can match empty strings splits @string into separate
<span class="line-new-header">--- 2099,11 ---</span>
   * anywhere in the string, then the whole string is returned as the first
   * token.
   *
   * As a special case, the result of splitting the empty string &quot;&quot; is an
   * empty vector, not a vector containing a single string. The reason for
<span class="line-modified">!  * this special case is that being able to represent an empty vector is</span>
   * typically more useful than consistent handling of empty elements. If
   * you do need to represent empty elements, you&#39;ll need to check for the
   * empty string before calling this function.
   *
   * A pattern that can match empty strings splits @string into separate
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2142,11 ***</span>
   * anywhere in the string, then the whole string is returned as the first
   * token.
   *
   * As a special case, the result of splitting the empty string &quot;&quot; is an
   * empty vector, not a vector containing a single string. The reason for
<span class="line-modified">!  * this special case is that being able to represent a empty vector is</span>
   * typically more useful than consistent handling of empty elements. If
   * you do need to represent empty elements, you&#39;ll need to check for the
   * empty string before calling this function.
   *
   * A pattern that can match empty strings splits @string into separate
<span class="line-new-header">--- 2142,11 ---</span>
   * anywhere in the string, then the whole string is returned as the first
   * token.
   *
   * As a special case, the result of splitting the empty string &quot;&quot; is an
   * empty vector, not a vector containing a single string. The reason for
<span class="line-modified">!  * this special case is that being able to represent an empty vector is</span>
   * typically more useful than consistent handling of empty elements. If
   * you do need to represent empty elements, you&#39;ll need to check for the
   * empty string before calling this function.
   *
   * A pattern that can match empty strings splits @string into separate
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2535,10 ***</span>
<span class="line-new-header">--- 2535,11 ---</span>
        if (g_ascii_digit_value (*g_utf8_next_char (p)) &gt;= 0)
          {
            base = 8;
            p = g_utf8_next_char (p);
          }
<span class="line-added">+       G_GNUC_FALLTHROUGH;</span>
      case &#39;1&#39;:
      case &#39;2&#39;:
      case &#39;3&#39;:
      case &#39;4&#39;:
      case &#39;5&#39;:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2592,11 ***</span>
   error:
    /* G_GSSIZE_FORMAT doesn&#39;t work with gettext, so we use %lu */
    tmp_error = g_error_new (G_REGEX_ERROR,
                             G_REGEX_ERROR_REPLACE,
                             _(&quot;Error while parsing replacement &quot;
<span class="line-modified">!                              &quot;text \&quot;%s\&quot; at char %lu: %s&quot;),</span>
                             replacement,
                             (gulong)(p - replacement),
                             error_detail);
    g_propagate_error (error, tmp_error);
  
<span class="line-new-header">--- 2593,11 ---</span>
   error:
    /* G_GSSIZE_FORMAT doesn&#39;t work with gettext, so we use %lu */
    tmp_error = g_error_new (G_REGEX_ERROR,
                             G_REGEX_ERROR_REPLACE,
                             _(&quot;Error while parsing replacement &quot;
<span class="line-modified">!                              &quot;text &#39;%s&#39; at char %lu: %s&quot;),</span>
                             replacement,
                             (gulong)(p - replacement),
                             error_detail);
    g_propagate_error (error, tmp_error);
  
</pre>
<center><a href="grefcount.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gregex.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>