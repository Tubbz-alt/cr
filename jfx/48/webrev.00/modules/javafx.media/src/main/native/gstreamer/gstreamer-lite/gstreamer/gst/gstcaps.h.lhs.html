<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstcaps.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* GStreamer
  2  * Copyright (C) 2003 David A. Schleef &lt;ds@schleef.org&gt;
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public
 15  * License along with this library; if not, write to the
 16  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  */
 19 
 20 #ifndef __GST_CAPS_H__
 21 #define __GST_CAPS_H__
 22 
 23 #include &lt;gst/gstconfig.h&gt;
 24 #include &lt;gst/gstminiobject.h&gt;
 25 #include &lt;gst/gststructure.h&gt;
 26 #include &lt;gst/gstcapsfeatures.h&gt;
 27 #include &lt;gst/glib-compat.h&gt;
 28 
 29 G_BEGIN_DECLS
 30 
 31 #ifndef GSTREAMER_LITE
 32 GST_API GType _gst_caps_type;
 33 #else // GSTREAMER_LITE
 34 GST_EXPORT GType _gst_caps_type;
 35 #endif // GSTREAMER_LITE
 36 
 37 #define GST_TYPE_CAPS             (_gst_caps_type)
 38 #define GST_IS_CAPS(obj)          (GST_IS_MINI_OBJECT_TYPE((obj), GST_TYPE_CAPS))
 39 #define GST_CAPS_CAST(obj)        ((GstCaps*)(obj))
 40 #define GST_CAPS(obj)             (GST_CAPS_CAST(obj))
 41 
 42 #ifndef GSTREAMER_LITE
 43 #define GST_TYPE_STATIC_CAPS      (gst_static_caps_get_type())
 44 #endif // GSTREAMER_LITE
 45 
 46 /**
 47  * GstCapsFlags:
 48  * @GST_CAPS_FLAG_ANY: Caps has no specific content, but can contain
 49  *    anything.
 50  *
 51  * Extra flags for a caps.
 52  */
 53 typedef enum {
 54   GST_CAPS_FLAG_ANY = (GST_MINI_OBJECT_FLAG_LAST &lt;&lt; 0)
 55 } GstCapsFlags;
 56 
 57 /**
 58  * GstCapsIntersectMode:
 59  * @GST_CAPS_INTERSECT_ZIG_ZAG  : Zig-zags over both caps.
 60  * @GST_CAPS_INTERSECT_FIRST    : Keeps the first caps order.
 61  *
 62  * Modes of caps intersection
 63  *
 64  * @GST_CAPS_INTERSECT_ZIG_ZAG tries to preserve overall order of both caps
 65  * by iterating on the caps&#39; structures as the following matrix shows:
 66  * |[
 67  *          caps1
 68  *       +-------------
 69  *       | 1  2  4  7
 70  * caps2 | 3  5  8 10
 71  *       | 6  9 11 12
 72  * ]|
 73  * Used when there is no explicit precedence of one caps over the other. e.g.
 74  * tee&#39;s sink pad getcaps function, it will probe its src pad peers&#39; for their
 75  * caps and intersect them with this mode.
 76  *
 77  * @GST_CAPS_INTERSECT_FIRST is useful when an element wants to preserve
 78  * another element&#39;s caps priority order when intersecting with its own caps.
 79  * Example: If caps1 is [A, B, C] and caps2 is [E, B, D, A], the result
 80  * would be [A, B], maintaining the first caps priority on the intersection.
 81  */
 82 typedef enum {
 83   GST_CAPS_INTERSECT_ZIG_ZAG            =  0,
 84   GST_CAPS_INTERSECT_FIRST              =  1
 85 } GstCapsIntersectMode;
 86 
 87 /**
 88  * GST_CAPS_ANY:
 89  *
 90  * Means that the element/pad can output &#39;anything&#39;. Useful for elements
 91  * that output unknown media, such as filesrc. This macro returns a singleton and
 92  * should not be unreffed.
 93  */
 94 #define GST_CAPS_ANY              _gst_caps_any
 95 /**
 96  * GST_CAPS_NONE:
 97  *
 98  * The opposite of %GST_CAPS_ANY: it means that the pad/element outputs an
 99  * undefined media type that can not be detected. This macro returns a singleton
100  * and should not be unreffed.
101  */
102 #define GST_CAPS_NONE             _gst_caps_none
103 
104 /**
105  * GST_STATIC_CAPS_ANY:
106  *
107  * Creates a new #GstCaps static caps that matches anything.
108  * This can be used in pad templates.
109  */
110 #define GST_STATIC_CAPS_ANY       GST_STATIC_CAPS(&quot;ANY&quot;)
111 /**
112  * GST_STATIC_CAPS_NONE:
113  *
114  * Creates a new #GstCaps static caps that matches nothing.
115  * This can be used in pad templates.
116  */
117 #define GST_STATIC_CAPS_NONE      GST_STATIC_CAPS(&quot;NONE&quot;)
118 
119 /**
120  * GST_CAPS_IS_SIMPLE:
121  * @caps: the #GstCaps instance to check
122  *
123  * Convenience macro that checks if the number of structures in the given caps
124  * is exactly one.
125  */
126 #define GST_CAPS_IS_SIMPLE(caps) (gst_caps_get_size(caps) == 1)
127 
128 /**
129  * GST_STATIC_CAPS:
130  * @string: the string describing the caps
131  *
132  * Creates a new #GstCaps static caps from an input string.
133  * This can be used in pad templates.
134  */
135 #define GST_STATIC_CAPS(string) \
136 { \
137   /* caps */ NULL, \
138   /* string */ string, \
139   GST_PADDING_INIT \
140 }
141 
142 typedef struct _GstCaps GstCaps;
143 typedef struct _GstStaticCaps GstStaticCaps;
144 
145 #ifndef GSTREAMER_LITE
146 GST_API GstCaps * _gst_caps_any;
147 #else // GSTREAMER_LITE
148 GST_EXPORT GstCaps * _gst_caps_any;
149 #endif // GSTREAMER_LITE
150 
151 #ifndef GSTREAMER_LITE
152 GST_API GstCaps * _gst_caps_none;
153 #else // GSTREAMER_LITE
154 GST_EXPORT GstCaps * _gst_caps_none;
155 #endif // GSTREAMER_LITE
156 
157 /**
158  * GST_CAPS_FLAGS:
159  * @caps: a #GstCaps.
160  *
161  * A flags word containing #GstCapsFlags flags set on this caps.
162  */
163 #define GST_CAPS_FLAGS(caps)                    GST_MINI_OBJECT_FLAGS(caps)
164 
165 /* refcount */
166 /**
167  * GST_CAPS_REFCOUNT:
168  * @caps: a #GstCaps
169  *
170  * Get access to the reference count field of the caps
171  */
172 #define GST_CAPS_REFCOUNT(caps)                 GST_MINI_OBJECT_REFCOUNT(caps)
173 /**
174  * GST_CAPS_REFCOUNT_VALUE:
175  * @caps: a #GstCaps
176  *
177  * Get the reference count value of the caps.
178  */
179 #define GST_CAPS_REFCOUNT_VALUE(caps)           GST_MINI_OBJECT_REFCOUNT_VALUE(caps)
180 
181 /**
182  * GST_CAPS_FLAG_IS_SET:
183  * @caps: a #GstCaps.
184  * @flag: the #GstCapsFlags to check.
185  *
186  * Gives the status of a specific flag on a caps.
187  */
188 #define GST_CAPS_FLAG_IS_SET(caps,flag)        GST_MINI_OBJECT_FLAG_IS_SET (caps, flag)
189 /**
190  * GST_CAPS_FLAG_SET:
191  * @caps: a #GstCaps.
192  * @flag: the #GstCapsFlags to set.
193  *
194  * Sets a caps flag on a caps.
195  */
196 #define GST_CAPS_FLAG_SET(caps,flag)           GST_MINI_OBJECT_FLAG_SET (caps, flag)
197 /**
198  * GST_CAPS_FLAG_UNSET:
199  * @caps: a #GstCaps.
200  * @flag: the #GstCapsFlags to clear.
201  *
202  * Clears a caps flag.
203  */
204 #define GST_CAPS_FLAG_UNSET(caps,flag)         GST_MINI_OBJECT_FLAG_UNSET (caps, flag)
205 
206 /* refcounting */
207 /**
208  * gst_caps_ref:
209  * @caps: the #GstCaps to reference
210  *
211  * Add a reference to a #GstCaps object.
212  *
213  * From this point on, until the caller calls gst_caps_unref() or
214  * gst_caps_make_writable(), it is guaranteed that the caps object will not
215  * change. This means its structures won&#39;t change, etc. To use a #GstCaps
216  * object, you must always have a refcount on it -- either the one made
217  * implicitly by e.g. gst_caps_new_simple(), or via taking one explicitly with
218  * this function.
219  *
220  * Returns: the same #GstCaps object.
221  */
222 static inline GstCaps *
223 gst_caps_ref (GstCaps * caps)
224 {
225   return (GstCaps *) gst_mini_object_ref (GST_MINI_OBJECT_CAST (caps));
226 }
227 
228 /**
229  * gst_caps_unref:
230  * @caps: a #GstCaps.
231  *
232  * Unref a #GstCaps and and free all its structures and the
233  * structures&#39; values when the refcount reaches 0.
234  */
235 static inline void
236 gst_caps_unref (GstCaps * caps)
237 {
238   gst_mini_object_unref (GST_MINI_OBJECT_CAST (caps));
239 }
240 
<a name="1" id="anc1"></a><span class="line-removed">241 /* copy caps */</span>
242 /**
<a name="2" id="anc2"></a><span class="line-modified">243  * gst_caps_copy:</span>
<span class="line-modified">244  * @caps: a #GstCaps.</span>
245  *
<a name="3" id="anc3"></a><span class="line-modified">246  * Creates a new #GstCaps as a copy of the old @caps. The new caps will have a</span>
<span class="line-removed">247  * refcount of 1, owned by the caller. The structures are copied as well.</span>
248  *
<a name="4" id="anc4"></a><span class="line-modified">249  * Note that this function is the semantic equivalent of a gst_caps_ref()</span>
<span class="line-removed">250  * followed by a gst_caps_make_writable(). If you only want to hold on to a</span>
<span class="line-removed">251  * reference to the data, you should use gst_caps_ref().</span>
252  *
<a name="5" id="anc5"></a><span class="line-modified">253  * When you are finished with the caps, call gst_caps_unref() on it.</span>

254  *
<a name="6" id="anc6"></a><span class="line-modified">255  * Returns: the new #GstCaps</span>
256  */
<a name="7" id="anc7"></a><span class="line-modified">257 static inline GstCaps *</span>
<span class="line-modified">258 gst_caps_copy (const GstCaps * caps)</span>
259 {
<a name="8" id="anc8"></a><span class="line-modified">260   return GST_CAPS (gst_mini_object_copy (GST_MINI_OBJECT_CAST (caps)));</span>
261 }
262 
<a name="9" id="anc9"></a>





263 /**
264  * gst_caps_is_writable:
265  * @caps: a #GstCaps
266  *
267  * Tests if you can safely modify @caps. It is only safe to modify caps when
268  * there is only one owner of the caps - ie, the object is writable.
269  */
270 #define         gst_caps_is_writable(caps)     gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (caps))
271 
272 /**
273  * gst_caps_make_writable:
274  * @caps: (transfer full): a #GstCaps
275  *
276  * Returns a writable copy of @caps.
277  *
278  * If there is only one reference count on @caps, the caller must be the owner,
279  * and so this function will return the caps object unchanged. If on the other
280  * hand there is more than one reference on the object, a new caps object will
281  * be returned. The caller&#39;s reference on @caps will be removed, and instead the
282  * caller will own a reference to the returned object.
283  *
284  * In short, this function unrefs the caps in the argument and refs the caps
285  * that it returns. Don&#39;t access the argument after calling this function. See
286  * also: gst_caps_ref().
287  *
288  * Returns: (transfer full): a writable caps which may or may not be the
289  *     same as @caps
290  */
291 #define         gst_caps_make_writable(caps)   GST_CAPS_CAST (gst_mini_object_make_writable (GST_MINI_OBJECT_CAST (caps)))
292 
293 /**
294  * gst_caps_replace:
295  * @old_caps: (inout) (transfer full) (nullable): pointer to a pointer
296  *     to a #GstCaps to be replaced.
297  * @new_caps: (transfer none) (allow-none): pointer to a #GstCaps that will
298  *     replace the caps pointed to by @old_caps.
299  *
300  * Modifies a pointer to a #GstCaps to point to a different #GstCaps. The
301  * modification is done atomically (so this is useful for ensuring thread safety
302  * in some cases), and the reference counts are updated appropriately (the old
303  * caps is unreffed, the new is reffed).
304  *
305  * Either @new_caps or the #GstCaps pointed to by @old_caps may be %NULL.
306  *
307  * Returns: %TRUE if @new_caps was different from @old_caps
308  */
309 static inline gboolean
310 gst_caps_replace (GstCaps **old_caps, GstCaps *new_caps)
311 {
312     return gst_mini_object_replace ((GstMiniObject **) old_caps, (GstMiniObject *) new_caps);
313 }
314 
315 /**
316  * gst_caps_take:
317  * @old_caps: (inout) (transfer full): pointer to a pointer to a #GstCaps to be
318  *     replaced.
319  * @new_caps: (transfer full) (allow-none): pointer to a #GstCaps that will
320  *     replace the caps pointed to by @old_caps.
321  *
322  * Modifies a pointer to a #GstCaps to point to a different #GstCaps. This
323  * function is similar to gst_caps_replace() except that it takes ownership
324  * of @new_caps.
325  *
326  * Returns: %TRUE if @new_caps was different from @old_caps
327  */
328 static inline gboolean
329 gst_caps_take (GstCaps **old_caps, GstCaps *new_caps)
330 {
331     return gst_mini_object_take ((GstMiniObject **) old_caps, (GstMiniObject *) new_caps);
332 }
333 
334 /**
335  * GstCaps:
336  * @mini_object: the parent type
337  *
338  * Object describing media types.
339  */
340 struct _GstCaps {
341   GstMiniObject mini_object;
342 };
343 
344 /**
345  * GstStaticCaps:
346  * @caps: the cached #GstCaps
347  * @string: a string describing a caps
348  *
349  * Datastructure to initialize #GstCaps from a string description usually
350  * used in conjunction with GST_STATIC_CAPS() and gst_static_caps_get() to
351  * instantiate a #GstCaps.
352  */
353 struct _GstStaticCaps {
354   /*&lt; public &gt;*/
355   GstCaps *caps;
356   const char *string;
357 
358   /*&lt; private &gt;*/
359   gpointer _gst_reserved[GST_PADDING];
360 };
361 
362 /**
363  * GstCapsForeachFunc:
364  * @features: the #GstCapsFeatures
365  * @structure: the #GstStructure
366  * @user_data: user data
367  *
368  * A function that will be called in gst_caps_foreach(). The function may
369  * not modify @features or @structure.
370  *
371  * Returns: %TRUE if the foreach operation should continue, %FALSE if
372  * the foreach operation should stop with %FALSE.
373  *
374  * Since: 1.6
375  */
376 typedef gboolean (*GstCapsForeachFunc) (GstCapsFeatures *features,
377                                         GstStructure    *structure,
378                                         gpointer         user_data);
379 
380 /**
381  * GstCapsMapFunc:
382  * @features: the #GstCapsFeatures
383  * @structure: the #GstStructure
384  * @user_data: user data
385  *
386  * A function that will be called in gst_caps_map_in_place(). The function
387  * may modify @features and @structure.
388  *
389  * Returns: %TRUE if the map operation should continue, %FALSE if
390  * the map operation should stop with %FALSE.
391  */
392 typedef gboolean (*GstCapsMapFunc)     (GstCapsFeatures *features,
393                                         GstStructure    *structure,
394                                         gpointer         user_data);
395 
396 /**
397  * GstCapsFilterMapFunc:
398  * @features: the #GstCapsFeatures
399  * @structure: the #GstStructure
400  * @user_data: user data
401  *
402  * A function that will be called in gst_caps_filter_and_map_in_place().
403  * The function may modify @features and @structure, and both will be
404  * removed from the caps if %FALSE is returned.
405  *
406  * Returns: %TRUE if the features and structure should be preserved,
407  * %FALSE if it should be removed.
408  */
409 typedef gboolean (*GstCapsFilterMapFunc) (GstCapsFeatures *features,
410                                           GstStructure    *structure,
411                                           gpointer user_data);
412 
413 
414 GST_API
415 GType             gst_caps_get_type                (void);
416 
417 GST_API
418 GstCaps *         gst_caps_new_empty               (void);
419 
420 GST_API
421 GstCaps *         gst_caps_new_any                 (void);
422 
423 GST_API
424 GstCaps *         gst_caps_new_empty_simple        (const char    *media_type) G_GNUC_WARN_UNUSED_RESULT;
425 
426 GST_API
427 GstCaps *         gst_caps_new_simple              (const char    *media_type,
428                                                     const char    *fieldname,
429                                                     ...) G_GNUC_NULL_TERMINATED G_GNUC_WARN_UNUSED_RESULT;
430 GST_API
431 GstCaps *         gst_caps_new_full                (GstStructure  *struct1,
432                                                     ...) G_GNUC_NULL_TERMINATED G_GNUC_WARN_UNUSED_RESULT;
433 GST_API
434 GstCaps *         gst_caps_new_full_valist         (GstStructure  *structure,
435                                                     va_list        var_args) G_GNUC_WARN_UNUSED_RESULT;
436 #ifndef GSTREAMER_LITE
437 GST_API
438 GType             gst_static_caps_get_type         (void);
439 #endif // GSTREAMER_LITE
440 GstCaps *         gst_static_caps_get              (GstStaticCaps *static_caps);
441 
442 GST_API
443 void              gst_static_caps_cleanup          (GstStaticCaps *static_caps);
444 
445 /* manipulation */
446 
447 GST_API
448 void              gst_caps_append                  (GstCaps       *caps1,
449                                                     GstCaps       *caps2);
450 GST_API
451 void              gst_caps_append_structure        (GstCaps       *caps,
452                                                     GstStructure  *structure);
453 GST_API
454 void              gst_caps_append_structure_full   (GstCaps       *caps,
455                                                     GstStructure  *structure,
456                                                     GstCapsFeatures *features);
457 GST_API
458 void              gst_caps_remove_structure        (GstCaps       *caps, guint idx);
459 
460 GST_API
461 GstCaps *         gst_caps_merge                   (GstCaps       *caps1,
462                                                     GstCaps       *caps2) G_GNUC_WARN_UNUSED_RESULT;
463 GST_API
464 GstCaps *         gst_caps_merge_structure         (GstCaps       *caps,
465                                                     GstStructure  *structure) G_GNUC_WARN_UNUSED_RESULT;
466 GST_API
467 GstCaps *         gst_caps_merge_structure_full    (GstCaps       *caps,
468                                                     GstStructure  *structure,
469                                                     GstCapsFeatures *features) G_GNUC_WARN_UNUSED_RESULT;
470 
471 GST_API
472 guint             gst_caps_get_size                (const GstCaps *caps);
473 
474 GST_API
475 GstStructure *    gst_caps_get_structure           (const GstCaps *caps,
476                                                     guint          index);
477 GST_API
478 GstStructure *    gst_caps_steal_structure         (GstCaps       *caps,
479                                                     guint          index) G_GNUC_WARN_UNUSED_RESULT;
480 GST_API
481 void              gst_caps_set_features            (GstCaps *caps,
482                                                     guint          index,
483                                                     GstCapsFeatures * features);
484 GST_API
<a name="10" id="anc10"></a>



485 GstCapsFeatures * gst_caps_get_features            (const GstCaps *caps,
486                                                     guint          index);
487 GST_API
488 GstCaps *         gst_caps_copy_nth                (const GstCaps *caps, guint nth) G_GNUC_WARN_UNUSED_RESULT;
489 
490 GST_API
491 GstCaps *         gst_caps_truncate                (GstCaps       *caps) G_GNUC_WARN_UNUSED_RESULT;
492 
493 GST_API
494 void              gst_caps_set_value               (GstCaps       *caps,
495                                                     const char    *field,
496                                                     const GValue  *value);
497 GST_API
498 void              gst_caps_set_simple              (GstCaps       *caps,
499                                                     const char    *field, ...) G_GNUC_NULL_TERMINATED;
500 GST_API
501 void              gst_caps_set_simple_valist       (GstCaps       *caps,
502                                                     const char    *field,
503                                                     va_list        varargs);
504 GST_API
505 gboolean          gst_caps_foreach                 (const GstCaps       *caps,
506                                                     GstCapsForeachFunc   func,
507                                                     gpointer             user_data);
508 GST_API
509 gboolean          gst_caps_map_in_place            (GstCaps        *caps,
510                                                     GstCapsMapFunc  func,
511                                                     gpointer        user_data);
512 GST_API
513 void              gst_caps_filter_and_map_in_place (GstCaps              *caps,
514                                                     GstCapsFilterMapFunc  func,
515                                                     gpointer              user_data);
516 
517 /* tests */
518 
519 GST_API
520 gboolean          gst_caps_is_any                  (const GstCaps *caps);
521 
522 GST_API
523 gboolean          gst_caps_is_empty                (const GstCaps *caps);
524 
525 GST_API
526 gboolean          gst_caps_is_fixed                (const GstCaps *caps);
527 
528 GST_API
529 gboolean          gst_caps_is_always_compatible    (const GstCaps *caps1,
530                                                     const GstCaps *caps2);
531 GST_API
<a name="11" id="anc11"></a><span class="line-modified">532 gboolean          gst_caps_is_subset           (const GstCaps *subset,</span>
<span class="line-modified">533                             const GstCaps *superset);</span>
534 GST_API
535 gboolean          gst_caps_is_subset_structure     (const GstCaps *caps,
536                                                     const GstStructure *structure);
537 GST_API
538 gboolean          gst_caps_is_subset_structure_full (const GstCaps *caps,
539                                                      const GstStructure *structure,
540                                                      const GstCapsFeatures *features);
541 GST_API
<a name="12" id="anc12"></a><span class="line-modified">542 gboolean          gst_caps_is_equal        (const GstCaps *caps1,</span>
<span class="line-modified">543                             const GstCaps *caps2);</span>
544 GST_API
545 gboolean          gst_caps_is_equal_fixed          (const GstCaps *caps1,
<a name="13" id="anc13"></a><span class="line-modified">546                             const GstCaps *caps2);</span>
547 GST_API
548 gboolean          gst_caps_can_intersect           (const GstCaps * caps1,
<a name="14" id="anc14"></a><span class="line-modified">549                             const GstCaps * caps2);</span>
550 GST_API
<a name="15" id="anc15"></a><span class="line-modified">551 gboolean          gst_caps_is_strictly_equal       (const GstCaps *caps1,</span>
<span class="line-modified">552                             const GstCaps *caps2);</span>
553 
554 
555 /* operations */
556 
557 GST_API
558 GstCaps *         gst_caps_intersect               (GstCaps *caps1,
<a name="16" id="anc16"></a><span class="line-modified">559                             GstCaps *caps2) G_GNUC_WARN_UNUSED_RESULT;</span>
560 GST_API
561 GstCaps *         gst_caps_intersect_full          (GstCaps *caps1,
<a name="17" id="anc17"></a><span class="line-modified">562                             GstCaps *caps2,</span>
563                                                     GstCapsIntersectMode mode) G_GNUC_WARN_UNUSED_RESULT;
564 GST_API
<a name="18" id="anc18"></a><span class="line-modified">565 GstCaps *         gst_caps_subtract        (GstCaps *minuend,</span>
<span class="line-modified">566                             GstCaps *subtrahend) G_GNUC_WARN_UNUSED_RESULT;</span>
567 GST_API
568 GstCaps *         gst_caps_normalize               (GstCaps *caps) G_GNUC_WARN_UNUSED_RESULT;
569 
570 GST_API
571 GstCaps *         gst_caps_simplify                (GstCaps *caps) G_GNUC_WARN_UNUSED_RESULT;
572 
573 GST_API
574 GstCaps *         gst_caps_fixate                  (GstCaps *caps) G_GNUC_WARN_UNUSED_RESULT;
575 
576 /* utility */
577 
578 GST_API
579 gchar *           gst_caps_to_string               (const GstCaps *caps) G_GNUC_MALLOC;
580 
581 GST_API
582 GstCaps *         gst_caps_from_string             (const gchar   *string) G_GNUC_WARN_UNUSED_RESULT;
583 
584 #ifdef G_DEFINE_AUTOPTR_CLEANUP_FUNC
585 G_DEFINE_AUTOPTR_CLEANUP_FUNC(GstCaps, gst_caps_unref)
586 #endif
587 
588 G_END_DECLS
589 
590 #endif /* __GST_CAPS_H__ */
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>