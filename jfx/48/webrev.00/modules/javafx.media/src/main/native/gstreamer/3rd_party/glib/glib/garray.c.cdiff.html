<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/garray.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="galloca.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="garray.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/garray.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 321,19 ***</span>
   * g_array_free:
   * @array: a #GArray
   * @free_segment: if %TRUE the actual element data is freed as well
   *
   * Frees the memory allocated for the #GArray. If @free_segment is
<span class="line-modified">!  * %TRUE it frees the memory block holding the elements as well and</span>
<span class="line-removed">-  * also each element if @array has a @element_free_func set. Pass</span>
   * %FALSE if you want to free the #GArray wrapper but preserve the
<span class="line-modified">!  * underlying array for use elsewhere. If the reference count of @array</span>
<span class="line-modified">!  * is greater than one, the #GArray wrapper is preserved but the size</span>
<span class="line-modified">!  * of @array will be set to zero.</span>
   *
<span class="line-modified">!  * If array elements contain dynamically-allocated memory, they should</span>
<span class="line-modified">!  * be freed separately.</span>
   *
   * This function is not thread-safe. If using a #GArray from multiple
   * threads, use only the atomic g_array_ref() and g_array_unref()
   * functions.
   *
<span class="line-new-header">--- 321,19 ---</span>
   * g_array_free:
   * @array: a #GArray
   * @free_segment: if %TRUE the actual element data is freed as well
   *
   * Frees the memory allocated for the #GArray. If @free_segment is
<span class="line-modified">!  * %TRUE it frees the memory block holding the elements as well. Pass</span>
   * %FALSE if you want to free the #GArray wrapper but preserve the
<span class="line-modified">!  * underlying array for use elsewhere. If the reference count of</span>
<span class="line-modified">!  * @array is greater than one, the #GArray wrapper is preserved but</span>
<span class="line-modified">!  * the size of  @array will be set to zero.</span>
   *
<span class="line-modified">!  * If array contents point to dynamically-allocated memory, they should</span>
<span class="line-modified">!  * be freed separately if @free_seg is %TRUE and no @clear_func</span>
<span class="line-added">+  * function has been set for @array.</span>
   *
   * This function is not thread-safe. If using a #GArray from multiple
   * threads, use only the atomic g_array_ref() and g_array_unref()
   * functions.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 510,11 ***</span>
   * @data: (nullable): a pointer to the elements to insert
   * @len: the number of elements to insert
   *
   * Inserts @len elements into a #GArray at the given index.
   *
<span class="line-modified">!  * If @index_ is greater than the arrayâ€™s current length, the array is expanded.</span>
   * The elements between the old end of the array and the newly inserted elements
   * will be initialised to zero if the array was configured to clear elements;
   * otherwise their values will be undefined.
   *
   * @data may be %NULL if (and only if) @len is zero. If @len is zero, this
<span class="line-new-header">--- 510,11 ---</span>
   * @data: (nullable): a pointer to the elements to insert
   * @len: the number of elements to insert
   *
   * Inserts @len elements into a #GArray at the given index.
   *
<span class="line-modified">!  * If @index_ is greater than the array&#39;s current length, the array is expanded.</span>
   * The elements between the old end of the array and the newly inserted elements
   * will be initialised to zero if the array was configured to clear elements;
   * otherwise their values will be undefined.
   *
   * @data may be %NULL if (and only if) @len is zero. If @len is zero, this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 788,22 ***</span>
                       array-&gt;elt_size,
                       compare_func,
                       user_data);
  }
  
  /* Returns the smallest power of 2 greater than n, or n if
   * such power does not fit in a guint
   */
  static guint
  g_nearest_pow (guint num)
  {
<span class="line-modified">!   guint n = 1;</span>
  
<span class="line-modified">!   while (n &lt; num &amp;&amp; n &gt; 0)</span>
<span class="line-modified">!     n &lt;&lt;= 1;</span>
  
<span class="line-modified">!   return n ? n : num;</span>
  }
  
  static void
  g_array_maybe_expand (GRealArray *array,
                        guint       len)
<span class="line-new-header">--- 788,113 ---</span>
                       array-&gt;elt_size,
                       compare_func,
                       user_data);
  }
  
<span class="line-added">+ /**</span>
<span class="line-added">+  * g_array_binary_search:</span>
<span class="line-added">+  * @array: a #GArray.</span>
<span class="line-added">+  * @target: a pointer to the item to look up.</span>
<span class="line-added">+  * @compare_func: A #GCompareFunc used to locate @target.</span>
<span class="line-added">+  * @out_match_index: (optional) (out caller-allocates): return location</span>
<span class="line-added">+  *    for the index of the element, if found.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Checks whether @target exists in @array by performing a binary</span>
<span class="line-added">+  * search based on the given comparison function @compare_func which</span>
<span class="line-added">+  * get pointers to items as arguments. If the element is found, %TRUE</span>
<span class="line-added">+  * is returned and the element&#39;s index is returned in @out_match_index</span>
<span class="line-added">+  * (if non-%NULL). Otherwise, %FALSE is returned and @out_match_index</span>
<span class="line-added">+  * is undefined. If @target exists multiple times in @array, the index</span>
<span class="line-added">+  * of the first instance is returned. This search is using a binary</span>
<span class="line-added">+  * search, so the @array must absolutely be sorted to return a correct</span>
<span class="line-added">+  * result (if not, the function may produce false-negative).</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * This example defines a comparison function and search an element in a #GArray:</span>
<span class="line-added">+  * |[&lt;!-- language=&quot;C&quot; --&gt;</span>
<span class="line-added">+  * static gint*</span>
<span class="line-added">+  * cmpint (gconstpointer a, gconstpointer b)</span>
<span class="line-added">+  * {</span>
<span class="line-added">+  *   const gint *_a = a;</span>
<span class="line-added">+  *   const gint *_b = b;</span>
<span class="line-added">+  *</span>
<span class="line-added">+  *   return *_a - *_b;</span>
<span class="line-added">+  * }</span>
<span class="line-added">+  * ...</span>
<span class="line-added">+  * gint i = 424242;</span>
<span class="line-added">+  * guint matched_index;</span>
<span class="line-added">+  * gboolean result = g_array_binary_search (garray, &amp;i, cmpint, &amp;matched_index);</span>
<span class="line-added">+  * ...</span>
<span class="line-added">+  * ]|</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Returns: %TRUE if @target is one of the elements of @array, %FALSE otherwise.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Since: 2.62</span>
<span class="line-added">+  */</span>
<span class="line-added">+ gboolean</span>
<span class="line-added">+ g_array_binary_search (GArray        *array,</span>
<span class="line-added">+                        gconstpointer  target,</span>
<span class="line-added">+                        GCompareFunc   compare_func,</span>
<span class="line-added">+                        guint         *out_match_index)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   gboolean result = FALSE;</span>
<span class="line-added">+   GRealArray *_array = (GRealArray *) array;</span>
<span class="line-added">+   guint left, middle, right;</span>
<span class="line-added">+   gint val;</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_return_val_if_fail (_array != NULL, FALSE);</span>
<span class="line-added">+   g_return_val_if_fail (compare_func != NULL, FALSE);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (G_LIKELY(_array-&gt;len))</span>
<span class="line-added">+     {</span>
<span class="line-added">+       left = 0;</span>
<span class="line-added">+       right = _array-&gt;len - 1;</span>
<span class="line-added">+ </span>
<span class="line-added">+       while (left &lt;= right)</span>
<span class="line-added">+         {</span>
<span class="line-added">+           middle = left + (right - left) / 2;</span>
<span class="line-added">+ </span>
<span class="line-added">+           val = compare_func (_array-&gt;data + (_array-&gt;elt_size * middle), target);</span>
<span class="line-added">+           if (val == 0)</span>
<span class="line-added">+             {</span>
<span class="line-added">+               result = TRUE;</span>
<span class="line-added">+               break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+           else if (val &lt; 0)</span>
<span class="line-added">+             left = middle + 1;</span>
<span class="line-added">+           else if (/* val &gt; 0 &amp;&amp; */ middle &gt; 0)</span>
<span class="line-added">+             right = middle - 1;</span>
<span class="line-added">+           else</span>
<span class="line-added">+             break;  /* element not found */</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (result &amp;&amp; out_match_index != NULL)</span>
<span class="line-added">+     *out_match_index = middle;</span>
<span class="line-added">+ </span>
<span class="line-added">+   return result;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  /* Returns the smallest power of 2 greater than n, or n if
   * such power does not fit in a guint
   */
  static guint
  g_nearest_pow (guint num)
  {
<span class="line-modified">!   guint n = num - 1;</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_assert (num &gt; 0);</span>
  
<span class="line-modified">!   n |= n &gt;&gt; 1;</span>
<span class="line-modified">!   n |= n &gt;&gt; 2;</span>
<span class="line-added">+   n |= n &gt;&gt; 4;</span>
<span class="line-added">+   n |= n &gt;&gt; 8;</span>
<span class="line-added">+   n |= n &gt;&gt; 16;</span>
<span class="line-added">+ #if SIZEOF_INT == 8</span>
<span class="line-added">+   n |= n &gt;&gt; 32;</span>
<span class="line-added">+ #endif</span>
  
<span class="line-modified">!   return n + 1;</span>
  }
  
  static void
  g_array_maybe_expand (GRealArray *array,
                        guint       len)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 813,11 ***</span>
    /* Detect potential overflow */
    if G_UNLIKELY ((G_MAXUINT - array-&gt;len) &lt; len)
      g_error (&quot;adding %u to array would overflow&quot;, len);
  
    want_alloc = g_array_elt_len (array, array-&gt;len + len +
<span class="line-modified">!                                       array-&gt;zero_terminated);</span>
  
    if (want_alloc &gt; array-&gt;alloc)
      {
        want_alloc = g_nearest_pow (want_alloc);
        want_alloc = MAX (want_alloc, MIN_ARRAY_SIZE);
<span class="line-new-header">--- 904,11 ---</span>
    /* Detect potential overflow */
    if G_UNLIKELY ((G_MAXUINT - array-&gt;len) &lt; len)
      g_error (&quot;adding %u to array would overflow&quot;, len);
  
    want_alloc = g_array_elt_len (array, array-&gt;len + len +
<span class="line-modified">!                                 array-&gt;zero_terminated);</span>
  
    if (want_alloc &gt; array-&gt;alloc)
      {
        want_alloc = g_nearest_pow (want_alloc);
        want_alloc = MAX (want_alloc, MIN_ARRAY_SIZE);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 910,11 ***</span>
   *
   * Returns: the pointer at the given index
   */
  
  static void g_ptr_array_maybe_expand (GRealPtrArray *array,
<span class="line-modified">!                                       gint           len);</span>
  
  /**
   * g_ptr_array_new:
   *
   * Creates a new #GPtrArray with a reference count of 1.
<span class="line-new-header">--- 1001,11 ---</span>
   *
   * Returns: the pointer at the given index
   */
  
  static void g_ptr_array_maybe_expand (GRealPtrArray *array,
<span class="line-modified">!                                       guint          len);</span>
  
  /**
   * g_ptr_array_new:
   *
   * Creates a new #GPtrArray with a reference count of 1.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 925,10 ***</span>
<span class="line-new-header">--- 1016,63 ---</span>
  g_ptr_array_new (void)
  {
    return g_ptr_array_sized_new (0);
  }
  
<span class="line-added">+ /**</span>
<span class="line-added">+  * g_ptr_array_copy:</span>
<span class="line-added">+  * @array: #GPtrArray to duplicate</span>
<span class="line-added">+  * @func: (nullable): a copy function used to copy every element in the array</span>
<span class="line-added">+  * @user_data: user data passed to the copy function @func, or %NULL</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Makes a full (deep) copy of a #GPtrArray.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * @func, as a #GCopyFunc, takes two arguments, the data to be copied</span>
<span class="line-added">+  * and a @user_data pointer. On common processor architectures, it&#39;s safe to</span>
<span class="line-added">+  * pass %NULL as @user_data if the copy function takes only one argument. You</span>
<span class="line-added">+  * may get compiler warnings from this though if compiling with GCC&#39;s</span>
<span class="line-added">+  * `-Wcast-function-type` warning.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * If @func is %NULL, then only the pointers (and not what they are</span>
<span class="line-added">+  * pointing to) are copied to the new #GPtrArray.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * The copy of @array will have the same #GDestroyNotify for its elements as</span>
<span class="line-added">+  * @array.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Returns: (transfer full): a deep copy of the initial #GPtrArray.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Since: 2.62</span>
<span class="line-added">+  **/</span>
<span class="line-added">+ GPtrArray *</span>
<span class="line-added">+ g_ptr_array_copy (GPtrArray *array,</span>
<span class="line-added">+                   GCopyFunc  func,</span>
<span class="line-added">+                   gpointer   user_data)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   gsize i;</span>
<span class="line-added">+   GPtrArray *new_array;</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_return_val_if_fail (array != NULL, NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+   new_array = g_ptr_array_sized_new (array-&gt;len);</span>
<span class="line-added">+   g_ptr_array_set_free_func (new_array, ((GRealPtrArray *) array)-&gt;element_free_func);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (func != NULL)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       for (i = 0; i &lt; array-&gt;len; i++)</span>
<span class="line-added">+         new_array-&gt;pdata[i] = func (array-&gt;pdata[i], user_data);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   else</span>
<span class="line-added">+     {</span>
<span class="line-added">+       memcpy (new_array-&gt;pdata, array-&gt;pdata,</span>
<span class="line-added">+               array-&gt;len * sizeof (*array-&gt;pdata));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   new_array-&gt;len = array-&gt;len;</span>
<span class="line-added">+ </span>
<span class="line-added">+   return new_array;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  /**
   * g_ptr_array_sized_new:
   * @reserved_size: number of pointers preallocated
   *
   * Creates a new #GPtrArray with @reserved_size pointers preallocated
</pre>
<hr />
<pre>
<span class="line-old-header">*** 961,10 ***</span>
<span class="line-new-header">--- 1105,38 ---</span>
      g_ptr_array_maybe_expand (array, reserved_size);
  
    return (GPtrArray*) array;
  }
  
<span class="line-added">+ /**</span>
<span class="line-added">+  * g_array_copy:</span>
<span class="line-added">+  * @array: A #GArray.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Create a shallow copy of a #GArray. If the array elements consist of</span>
<span class="line-added">+  * pointers to data, the pointers are copied but the actual data is not.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Returns: (transfer container): A copy of @array.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Since: 2.62</span>
<span class="line-added">+  **/</span>
<span class="line-added">+ GArray *</span>
<span class="line-added">+ g_array_copy (GArray *array)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   GRealArray *rarray = (GRealArray *) array;</span>
<span class="line-added">+   GRealArray *new_rarray;</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_return_val_if_fail (rarray != NULL, NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+   new_rarray =</span>
<span class="line-added">+     (GRealArray *) g_array_sized_new (rarray-&gt;zero_terminated, rarray-&gt;clear,</span>
<span class="line-added">+                                       rarray-&gt;elt_size, rarray-&gt;len);</span>
<span class="line-added">+   new_rarray-&gt;len = rarray-&gt;len;</span>
<span class="line-added">+   memcpy (new_rarray-&gt;data, rarray-&gt;data, rarray-&gt;alloc);</span>
<span class="line-added">+ </span>
<span class="line-added">+   return (GArray *) new_rarray;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  /**
   * g_ptr_array_new_with_free_func:
   * @element_free_func: (nullable): A function to free elements with
   *     destroy @array or %NULL
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1178,11 ***</span>
    return segment;
  }
  
  static void
  g_ptr_array_maybe_expand (GRealPtrArray *array,
<span class="line-modified">!                           gint           len)</span>
  {
    /* Detect potential overflow */
    if G_UNLIKELY ((G_MAXUINT - array-&gt;len) &lt; len)
      g_error (&quot;adding %u to array would overflow&quot;, len);
  
<span class="line-new-header">--- 1350,11 ---</span>
    return segment;
  }
  
  static void
  g_ptr_array_maybe_expand (GRealPtrArray *array,
<span class="line-modified">!                           guint          len)</span>
  {
    /* Detect potential overflow */
    if G_UNLIKELY ((G_MAXUINT - array-&gt;len) &lt; len)
      g_error (&quot;adding %u to array would overflow&quot;, len);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1504,10 ***</span>
<span class="line-new-header">--- 1676,93 ---</span>
    g_ptr_array_maybe_expand (rarray, 1);
  
    rarray-&gt;pdata[rarray-&gt;len++] = data;
  }
  
<span class="line-added">+ /**</span>
<span class="line-added">+  * g_ptr_array_extend:</span>
<span class="line-added">+  * @array_to_extend: a #GPtrArray.</span>
<span class="line-added">+  * @array: (transfer none): a #GPtrArray to add to the end of @array_to_extend.</span>
<span class="line-added">+  * @func: (nullable): a copy function used to copy every element in the array</span>
<span class="line-added">+  * @user_data: user data passed to the copy function @func, or %NULL</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Adds all pointers of @array to the end of the array @array_to_extend.</span>
<span class="line-added">+  * The array will grow in size automatically if needed. @array_to_extend is</span>
<span class="line-added">+  * modified in-place.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * @func, as a #GCopyFunc, takes two arguments, the data to be copied</span>
<span class="line-added">+  * and a @user_data pointer. On common processor architectures, it&#39;s safe to</span>
<span class="line-added">+  * pass %NULL as @user_data if the copy function takes only one argument. You</span>
<span class="line-added">+  * may get compiler warnings from this though if compiling with GCC&#39;s</span>
<span class="line-added">+  * `-Wcast-function-type` warning.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * If @func is %NULL, then only the pointers (and not what they are</span>
<span class="line-added">+  * pointing to) are copied to the new #GPtrArray.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Since: 2.62</span>
<span class="line-added">+  **/</span>
<span class="line-added">+ void</span>
<span class="line-added">+ g_ptr_array_extend (GPtrArray  *array_to_extend,</span>
<span class="line-added">+                     GPtrArray  *array,</span>
<span class="line-added">+                     GCopyFunc   func,</span>
<span class="line-added">+                     gpointer    user_data)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   GRealPtrArray *rarray_to_extend = (GRealPtrArray *) array_to_extend;</span>
<span class="line-added">+   gsize i;</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_return_if_fail (array_to_extend != NULL);</span>
<span class="line-added">+   g_return_if_fail (array != NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_ptr_array_maybe_expand (rarray_to_extend, array-&gt;len);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (func != NULL)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       for (i = 0; i &lt; array-&gt;len; i++)</span>
<span class="line-added">+         rarray_to_extend-&gt;pdata[i + rarray_to_extend-&gt;len] =</span>
<span class="line-added">+           func (array-&gt;pdata[i], user_data);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   else</span>
<span class="line-added">+     {</span>
<span class="line-added">+       memcpy (rarray_to_extend-&gt;pdata + rarray_to_extend-&gt;len, array-&gt;pdata,</span>
<span class="line-added">+               array-&gt;len * sizeof (*array-&gt;pdata));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   rarray_to_extend-&gt;len += array-&gt;len;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * g_ptr_array_extend_and_steal:</span>
<span class="line-added">+  * @array_to_extend: (transfer none): a #GPtrArray.</span>
<span class="line-added">+  * @array: (transfer container): a #GPtrArray to add to the end of</span>
<span class="line-added">+  *     @array_to_extend.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Adds all the pointers in @array to the end of @array_to_extend, transferring</span>
<span class="line-added">+  * ownership of each element from @array to @array_to_extend and modifying</span>
<span class="line-added">+  * @array_to_extend in-place. @array is then freed.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * As with g_ptr_array_free(), @array will be destroyed if its reference count</span>
<span class="line-added">+  * is 1. If its reference count is higher, it will be decremented and the</span>
<span class="line-added">+  * length of @array set to zero.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Since: 2.62</span>
<span class="line-added">+  **/</span>
<span class="line-added">+ void</span>
<span class="line-added">+ g_ptr_array_extend_and_steal (GPtrArray  *array_to_extend,</span>
<span class="line-added">+                               GPtrArray  *array)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   gpointer *pdata;</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_ptr_array_extend (array_to_extend, array, NULL, NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Get rid of @array without triggering the GDestroyNotify attached</span>
<span class="line-added">+    * to the elements moved from @array to @array_to_extend. */</span>
<span class="line-added">+   pdata = g_steal_pointer (&amp;array-&gt;pdata);</span>
<span class="line-added">+   array-&gt;len = 0;</span>
<span class="line-added">+   g_ptr_array_unref (array);</span>
<span class="line-added">+   g_free (pdata);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  /**
   * g_ptr_array_insert:
   * @array: a #GPtrArray
   * @index_: the index to place the new element at, or -1 to append
   * @data: the pointer to add.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1531,11 ***</span>
    g_ptr_array_maybe_expand (rarray, 1);
  
    if (index_ &lt; 0)
      index_ = rarray-&gt;len;
  
<span class="line-modified">!   if (index_ &lt; rarray-&gt;len)</span>
      memmove (&amp;(rarray-&gt;pdata[index_ + 1]),
               &amp;(rarray-&gt;pdata[index_]),
               (rarray-&gt;len - index_) * sizeof (gpointer));
  
    rarray-&gt;len++;
<span class="line-new-header">--- 1786,11 ---</span>
    g_ptr_array_maybe_expand (rarray, 1);
  
    if (index_ &lt; 0)
      index_ = rarray-&gt;len;
  
<span class="line-modified">!   if ((guint) index_ &lt; rarray-&gt;len)</span>
      memmove (&amp;(rarray-&gt;pdata[index_ + 1]),
               &amp;(rarray-&gt;pdata[index_]),
               (rarray-&gt;len - index_) * sizeof (gpointer));
  
    rarray-&gt;len++;
</pre>
<center><a href="galloca.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="garray.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>