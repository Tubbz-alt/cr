<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/video-overlay-composition.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="video-orc.orc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="video-overlay-composition.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/video-overlay-composition.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  25  * @short_description: Video Buffer Overlay Compositions (Subtitles, Logos)
  26  *
  27  * Functions to create and handle overlay compositions on video buffers.
  28  *
  29  * An overlay composition describes one or more overlay rectangles to be
  30  * blended on top of a video buffer.
  31  *
  32  * This API serves two main purposes:
  33  *
  34  * * it can be used to attach overlay information (subtitles or logos)
  35  *   to non-raw video buffers such as GL/VAAPI/VDPAU surfaces. The actual
  36  *   blending of the overlay can then be done by e.g. the video sink that
  37  *   processes these non-raw buffers.
  38  *
  39  * * it can also be used to blend overlay rectangles on top of raw video
  40  *   buffers, thus consolidating blending functionality for raw video in
  41  *   one place.
  42  *
  43  * Together, this allows existing overlay elements to easily handle raw
  44  * and non-raw video as input in without major changes (once the overlays
<span class="line-modified">  45  * have been put into a #GstOverlayComposition object anyway) - for raw</span>
  46  * video the overlay can just use the blending function to blend the data
  47  * on top of the video, and for surface buffers it can just attach them to
  48  * the buffer and let the sink render the overlays.
  49  *
  50  */
  51 
  52 /* TODO:
  53  *  - provide accessors for seq_num and other fields (as needed)
  54  *  - allow overlay to set/get original pango markup string on/from rectangle
  55  */
  56 
  57 #ifdef HAVE_CONFIG_H
  58 #include &quot;config.h&quot;
  59 #endif
  60 
  61 #include &quot;video-overlay-composition.h&quot;
  62 #include &quot;video-blend.h&quot;
  63 #include &quot;gstvideometa.h&quot;
  64 #include &lt;string.h&gt;
  65 
</pre>
<hr />
<pre>
 295 
 296   return ometa;
 297 }
 298 
 299 /* ------------------------------ composition ------------------------------ */
 300 
 301 #define RECTANGLE_ARRAY_STEP 4  /* premature optimization */
 302 
 303 GST_DEFINE_MINI_OBJECT_TYPE (GstVideoOverlayComposition,
 304     gst_video_overlay_composition);
 305 
 306 static void
 307 gst_video_overlay_composition_free (GstMiniObject * mini_obj)
 308 {
 309   GstVideoOverlayComposition *comp = (GstVideoOverlayComposition *) mini_obj;
 310   guint num;
 311 
 312   num = comp-&gt;num_rectangles;
 313 
 314   while (num &gt; 0) {


 315     gst_video_overlay_rectangle_unref (comp-&gt;rectangles[num - 1]);
 316     --num;
 317   }
 318 
 319   g_free (comp-&gt;rectangles);
 320   comp-&gt;rectangles = NULL;
 321   comp-&gt;num_rectangles = 0;
 322 
 323   g_slice_free (GstVideoOverlayComposition, comp);
 324 }
 325 
 326 /**
 327  * gst_video_overlay_composition_new:
 328  * @rectangle: (transfer none): a #GstVideoOverlayRectangle to add to the
 329  *     composition
 330  *
 331  * Creates a new video overlay composition object to hold one or more
 332  * overlay rectangles.
 333  *
 334  * Returns: (transfer full): a new #GstVideoOverlayComposition. Unref with
</pre>
<hr />
<pre>
 337 GstVideoOverlayComposition *
 338 gst_video_overlay_composition_new (GstVideoOverlayRectangle * rectangle)
 339 {
 340   GstVideoOverlayComposition *comp;
 341 
 342 
 343   /* FIXME: should we allow empty compositions? Could also be expressed as
 344    * buffer without a composition on it. Maybe there are cases where doing
 345    * an empty new + _add() in a loop is easier? */
 346   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle), NULL);
 347 
 348   comp = g_slice_new0 (GstVideoOverlayComposition);
 349 
 350   gst_mini_object_init (GST_MINI_OBJECT_CAST (comp), 0,
 351       GST_TYPE_VIDEO_OVERLAY_COMPOSITION,
 352       (GstMiniObjectCopyFunction) gst_video_overlay_composition_copy,
 353       NULL, (GstMiniObjectFreeFunction) gst_video_overlay_composition_free);
 354 
 355   comp-&gt;rectangles = g_new0 (GstVideoOverlayRectangle *, RECTANGLE_ARRAY_STEP);
 356   comp-&gt;rectangles[0] = gst_video_overlay_rectangle_ref (rectangle);


 357   comp-&gt;num_rectangles = 1;
 358 
 359   comp-&gt;seq_num = gst_video_overlay_get_seqnum ();
 360 
 361   /* since the rectangle was created earlier, its seqnum is smaller than ours */
 362   comp-&gt;min_seq_num_used = rectangle-&gt;seq_num;
 363 
 364   GST_LOG (&quot;new composition %p: seq_num %u with rectangle %p&quot;, comp,
 365       comp-&gt;seq_num, rectangle);
 366 
 367   return comp;
 368 }
 369 
 370 /**
 371  * gst_video_overlay_composition_add_rectangle:
 372  * @comp: a #GstVideoOverlayComposition
 373  * @rectangle: (transfer none): a #GstVideoOverlayRectangle to add to the
 374  *     composition
 375  *
 376  * Adds an overlay rectangle to an existing overlay composition object. This
 377  * must be done right after creating the overlay composition.
 378  */
 379 void
 380 gst_video_overlay_composition_add_rectangle (GstVideoOverlayComposition * comp,
 381     GstVideoOverlayRectangle * rectangle)
 382 {
 383   g_return_if_fail (GST_IS_VIDEO_OVERLAY_COMPOSITION (comp));
 384   g_return_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle));
<span class="line-modified"> 385   g_return_if_fail (GST_MINI_OBJECT_REFCOUNT_VALUE (comp) == 1);</span>
 386 
 387   if (comp-&gt;num_rectangles % RECTANGLE_ARRAY_STEP == 0) {
 388     comp-&gt;rectangles =
 389         g_renew (GstVideoOverlayRectangle *, comp-&gt;rectangles,
 390         comp-&gt;num_rectangles + RECTANGLE_ARRAY_STEP);
 391   }
 392 
 393   comp-&gt;rectangles[comp-&gt;num_rectangles] =
 394       gst_video_overlay_rectangle_ref (rectangle);


 395   comp-&gt;num_rectangles += 1;
 396 
 397   comp-&gt;min_seq_num_used = MIN (comp-&gt;min_seq_num_used, rectangle-&gt;seq_num);
 398 
 399   GST_LOG (&quot;composition %p: added rectangle %p&quot;, comp, rectangle);
 400 }
 401 
 402 /**
 403  * gst_video_overlay_composition_n_rectangles:
 404  * @comp: a #GstVideoOverlayComposition
 405  *
 406  * Returns the number of #GstVideoOverlayRectangle&lt;!-- --&gt;s contained in @comp.
 407  *
 408  * Returns: the number of rectangles
 409  */
 410 guint
 411 gst_video_overlay_composition_n_rectangles (GstVideoOverlayComposition * comp)
 412 {
 413   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_COMPOSITION (comp), 0);
 414 
</pre>
<hr />
<pre>
 564 /**
 565  * gst_video_overlay_composition_make_writable:
 566  * @comp: (transfer full): a #GstVideoOverlayComposition to copy
 567  *
 568  * Takes ownership of @comp and returns a version of @comp that is writable
 569  * (i.e. can be modified). Will either return @comp right away, or create a
 570  * new writable copy of @comp and unref @comp itself. All the contained
 571  * rectangles will also be copied, but the actual overlay pixel data buffers
 572  * contained in the rectangles are not copied.
 573  *
 574  * Returns: (transfer full): a writable #GstVideoOverlayComposition
 575  *     equivalent to @comp.
 576  */
 577 GstVideoOverlayComposition *
 578 gst_video_overlay_composition_make_writable (GstVideoOverlayComposition * comp)
 579 {
 580   GstVideoOverlayComposition *writable_comp;
 581 
 582   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_COMPOSITION (comp), NULL);
 583 
<span class="line-modified"> 584   if (GST_MINI_OBJECT_REFCOUNT_VALUE (comp) == 1) {</span>
 585     guint n;
 586 
 587     for (n = 0; n &lt; comp-&gt;num_rectangles; ++n) {
<span class="line-modified"> 588       if (GST_MINI_OBJECT_REFCOUNT_VALUE (comp-&gt;rectangles[n]) != 1)</span>

 589         goto copy;
 590     }
 591     return comp;
 592   }
 593 
 594 copy:
 595 
 596   writable_comp = gst_video_overlay_composition_copy (comp);
 597   gst_video_overlay_composition_unref (comp);
 598 
 599   return writable_comp;
 600 }
 601 
 602 /**
 603  * gst_video_overlay_composition_get_seqnum:
 604  * @comp: a #GstVideoOverlayComposition
 605  *
 606  * Returns the sequence number of this composition. Sequence numbers are
 607  * monotonically increasing and unique for overlay compositions and rectangles
 608  * (meaning there will never be a rectangle with the same sequence number as
</pre>
<hr />
<pre>
 611  * Returns: the sequence number of @comp
 612  */
 613 guint
 614 gst_video_overlay_composition_get_seqnum (GstVideoOverlayComposition * comp)
 615 {
 616   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_COMPOSITION (comp), 0);
 617 
 618   return comp-&gt;seq_num;
 619 }
 620 
 621 /* ------------------------------ rectangles ------------------------------ -*/
 622 
 623 GST_DEFINE_MINI_OBJECT_TYPE (GstVideoOverlayRectangle,
 624     gst_video_overlay_rectangle);
 625 
 626 static void
 627 gst_video_overlay_rectangle_free (GstMiniObject * mini_obj)
 628 {
 629   GstVideoOverlayRectangle *rect = (GstVideoOverlayRectangle *) mini_obj;
 630 


 631   gst_buffer_replace (&amp;rect-&gt;pixels, NULL);
 632 
 633   while (rect-&gt;scaled_rectangles != NULL) {
 634     GstVideoOverlayRectangle *scaled_rect = rect-&gt;scaled_rectangles-&gt;data;
 635 
 636     gst_video_overlay_rectangle_unref (scaled_rect);
 637 
 638     rect-&gt;scaled_rectangles =
 639         g_list_delete_link (rect-&gt;scaled_rectangles, rect-&gt;scaled_rectangles);
 640   }
 641 
 642   g_free (rect-&gt;initial_alpha);
 643   g_mutex_clear (&amp;rect-&gt;lock);
 644 
 645   g_slice_free (GstVideoOverlayRectangle, rect);
 646 }
 647 
 648 static inline gboolean
 649 gst_video_overlay_rectangle_check_flags (GstVideoOverlayFormatFlags flags)
 650 {
</pre>
<hr />
<pre>
 712 
 713   format = vmeta-&gt;format;
 714   width = vmeta-&gt;width;
 715   height = vmeta-&gt;height;
 716 
 717   /* technically ((height-1)*stride)+width might be okay too */
 718   g_return_val_if_fail (gst_buffer_get_size (pixels) &gt;= height * width * 4,
 719       NULL);
 720   g_return_val_if_fail (height &gt; 0 &amp;&amp; width &gt; 0, NULL);
 721 
 722   rect = g_slice_new0 (GstVideoOverlayRectangle);
 723 
 724   gst_mini_object_init (GST_MINI_OBJECT_CAST (rect), 0,
 725       GST_TYPE_VIDEO_OVERLAY_RECTANGLE,
 726       (GstMiniObjectCopyFunction) gst_video_overlay_rectangle_copy,
 727       NULL, (GstMiniObjectFreeFunction) gst_video_overlay_rectangle_free);
 728 
 729   g_mutex_init (&amp;rect-&gt;lock);
 730 
 731   rect-&gt;pixels = gst_buffer_ref (pixels);


 732   rect-&gt;scaled_rectangles = NULL;
 733 
 734   gst_video_info_init (&amp;rect-&gt;info);
 735   if (!gst_video_info_set_format (&amp;rect-&gt;info, format, width, height)) {
 736     gst_mini_object_unref (GST_MINI_OBJECT_CAST (rect));
 737     return NULL;
 738   }
 739   if (flags &amp; GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA)
 740     rect-&gt;info.flags |= GST_VIDEO_FLAG_PREMULTIPLIED_ALPHA;
 741 
 742   rect-&gt;x = render_x;
 743   rect-&gt;y = render_y;
 744   rect-&gt;render_width = render_width;
 745   rect-&gt;render_height = render_height;
 746 
 747   rect-&gt;global_alpha = 1.0;
 748   rect-&gt;applied_global_alpha = 1.0;
 749   rect-&gt;initial_alpha = NULL;
 750 
 751   rect-&gt;flags = flags;
</pre>
<hr />
<pre>
 799  * @render_y: render Y position of rectangle on video
 800  * @render_width: render width of rectangle
 801  * @render_height: render height of rectangle
 802  *
 803  * Sets the render position and dimensions of the rectangle on the video.
 804  * This function is mainly for elements that modify the size of the video
 805  * in some way (e.g. through scaling or cropping) and need to adjust the
 806  * details of any overlays to match the operation that changed the size.
 807  *
 808  * @rectangle must be writable, meaning its refcount must be 1. You can
 809  * make the rectangles inside a #GstVideoOverlayComposition writable using
 810  * gst_video_overlay_composition_make_writable() or
 811  * gst_video_overlay_composition_copy().
 812  */
 813 void
 814 gst_video_overlay_rectangle_set_render_rectangle (GstVideoOverlayRectangle *
 815     rectangle, gint render_x, gint render_y, guint render_width,
 816     guint render_height)
 817 {
 818   g_return_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle));
<span class="line-modified"> 819   g_return_if_fail (GST_MINI_OBJECT_REFCOUNT_VALUE (rectangle) == 1);</span>

 820 
 821   rectangle-&gt;x = render_x;
 822   rectangle-&gt;y = render_y;
 823   rectangle-&gt;render_width = render_width;
 824   rectangle-&gt;render_height = render_height;
 825 }
 826 
 827 /* FIXME: orc-ify */
 828 static void
 829 gst_video_overlay_rectangle_premultiply_0 (GstVideoFrame * frame)
 830 {
 831   int i, j;
<span class="line-modified"> 832   for (j = 0; j &lt; GST_VIDEO_FRAME_HEIGHT (frame); ++j) {</span>





 833     guint8 *line;
 834 
<span class="line-modified"> 835     line = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);</span>
<span class="line-modified"> 836     line += GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0) * j;</span>
<span class="line-modified"> 837     for (i = 0; i &lt; GST_VIDEO_FRAME_WIDTH (frame); ++i) {</span>
 838       int a = line[0];
 839       line[1] = line[1] * a / 255;
 840       line[2] = line[2] * a / 255;
 841       line[3] = line[3] * a / 255;
 842       line += 4;
 843     }
 844   }
 845 }
 846 
 847 static void
 848 gst_video_overlay_rectangle_premultiply_3 (GstVideoFrame * frame)
 849 {
 850   int i, j;
<span class="line-modified"> 851   for (j = 0; j &lt; GST_VIDEO_FRAME_HEIGHT (frame); ++j) {</span>





 852     guint8 *line;
 853 
<span class="line-modified"> 854     line = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);</span>
<span class="line-modified"> 855     line += GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0) * j;</span>
<span class="line-modified"> 856     for (i = 0; i &lt; GST_VIDEO_FRAME_WIDTH (frame); ++i) {</span>
 857       int a = line[3];
 858       line[0] = line[0] * a / 255;
 859       line[1] = line[1] * a / 255;
 860       line[2] = line[2] * a / 255;
 861       line += 4;
 862     }
 863   }
 864 }
 865 
 866 static void
 867 gst_video_overlay_rectangle_premultiply (GstVideoFrame * frame)
 868 {
 869   gint alpha_offset;
 870 
 871   alpha_offset = GST_VIDEO_FRAME_COMP_POFFSET (frame, 3);
 872   switch (alpha_offset) {
 873     case 0:
 874       gst_video_overlay_rectangle_premultiply_0 (frame);
 875       break;
 876     case 3:
 877       gst_video_overlay_rectangle_premultiply_3 (frame);
 878       break;
 879     default:
 880       g_assert_not_reached ();
 881       break;
 882   }
 883 }
 884 
 885 /* FIXME: orc-ify */
 886 static void
 887 gst_video_overlay_rectangle_unpremultiply_0 (GstVideoFrame * frame)
 888 {
 889   int i, j;
<span class="line-modified"> 890   for (j = 0; j &lt; GST_VIDEO_FRAME_HEIGHT (frame); ++j) {</span>





 891     guint8 *line;
 892 
<span class="line-modified"> 893     line = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);</span>
<span class="line-modified"> 894     line += GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0) * j;</span>
<span class="line-modified"> 895     for (i = 0; i &lt; GST_VIDEO_FRAME_WIDTH (frame); ++i) {</span>
 896       int a = line[0];
 897       if (a) {
 898         line[1] = MIN ((line[1] * 255 + a / 2) / a, 255);
 899         line[2] = MIN ((line[2] * 255 + a / 2) / a, 255);
 900         line[3] = MIN ((line[3] * 255 + a / 2) / a, 255);
 901       }
 902       line += 4;
 903     }
 904   }
 905 }
 906 
 907 static void
 908 gst_video_overlay_rectangle_unpremultiply_3 (GstVideoFrame * frame)
 909 {
 910   int i, j;
<span class="line-modified"> 911   for (j = 0; j &lt; GST_VIDEO_FRAME_HEIGHT (frame); ++j) {</span>





 912     guint8 *line;
 913 
<span class="line-modified"> 914     line = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);</span>
<span class="line-modified"> 915     line += GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0) * j;</span>
<span class="line-modified"> 916     for (i = 0; i &lt; GST_VIDEO_FRAME_WIDTH (frame); ++i) {</span>
 917       int a = line[3];
 918       if (a) {
 919         line[0] = MIN ((line[0] * 255 + a / 2) / a, 255);
 920         line[1] = MIN ((line[1] * 255 + a / 2) / a, 255);
 921         line[2] = MIN ((line[2] * 255 + a / 2) / a, 255);
 922       }
 923       line += 4;
 924     }
 925   }
 926 }
 927 
 928 static void
 929 gst_video_overlay_rectangle_unpremultiply (GstVideoFrame * frame)
 930 {
 931   gint alpha_offset;
 932 
 933   alpha_offset = GST_VIDEO_FRAME_COMP_POFFSET (frame, 3);
 934   switch (alpha_offset) {
 935     case 0:
 936       gst_video_overlay_rectangle_unpremultiply_0 (frame);
</pre>
<hr />
<pre>
 983 {
 984   guint8 *src, *dst;
 985   GstVideoFrame frame;
 986   gint i, j, w, h, stride;
 987   gint argb_a, argb_r, argb_g, argb_b;
 988   gint alpha_offset;
 989 
 990   g_assert (!(rect-&gt;applied_global_alpha != 1.0
 991           &amp;&amp; rect-&gt;initial_alpha == NULL));
 992 
 993   alpha_offset = GST_VIDEO_INFO_COMP_POFFSET (&amp;rect-&gt;info, 3);
 994   g_return_if_fail (alpha_offset == 0 || alpha_offset == 3);
 995 
 996   if (global_alpha == rect-&gt;applied_global_alpha)
 997     return;
 998 
 999   if (rect-&gt;initial_alpha == NULL)
1000     gst_video_overlay_rectangle_extract_alpha (rect);
1001 
1002   src = rect-&gt;initial_alpha;
<span class="line-modified">1003   rect-&gt;pixels = gst_buffer_make_writable (rect-&gt;pixels);</span>






1004 
1005   gst_video_frame_map (&amp;frame, &amp;rect-&gt;info, rect-&gt;pixels, GST_MAP_READ);
1006   dst = GST_VIDEO_FRAME_PLANE_DATA (&amp;frame, 0);
1007   w = GST_VIDEO_INFO_WIDTH (&amp;rect-&gt;info);
1008   h = GST_VIDEO_INFO_HEIGHT (&amp;rect-&gt;info);
1009   stride = GST_VIDEO_INFO_PLANE_STRIDE (&amp;rect-&gt;info, 0);
1010 
1011   argb_a = GST_VIDEO_INFO_COMP_POFFSET (&amp;rect-&gt;info, 3);
1012   argb_r = (argb_a + 1) % 4;
1013   argb_g = (argb_a + 2) % 4;
1014   argb_b = (argb_a + 3) % 4;
1015 
1016   for (i = 0; i &lt; h; i++) {
1017     for (j = 0; j &lt; w; j++) {
1018       guint8 na = (guint8) (*src * global_alpha);
1019 
1020       if (! !(rect-&gt;flags &amp; GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA)) {
1021         dst[argb_r] =
1022             (guint8) ((double) (dst[argb_r] * 255) / (double) dst[argb_a]) *
1023             na / 255;
</pre>
<hr />
<pre>
1511 
1512 /**
1513  * gst_video_overlay_rectangle_set_global_alpha:
1514  * @rectangle: a #GstVideoOverlayRectangle
1515  * @global_alpha: Global alpha value (0 to 1.0)
1516  *
1517  * Sets the global alpha value associated with a #GstVideoOverlayRectangle. Per-
1518  * pixel alpha values are multiplied with this value. Valid
1519  * values: 0 &lt;= global_alpha &lt;= 1; 1 to deactivate.
1520  *
1521  * @rectangle must be writable, meaning its refcount must be 1. You can
1522  * make the rectangles inside a #GstVideoOverlayComposition writable using
1523  * gst_video_overlay_composition_make_writable() or
1524  * gst_video_overlay_composition_copy().
1525  */
1526 void
1527 gst_video_overlay_rectangle_set_global_alpha (GstVideoOverlayRectangle *
1528     rectangle, gfloat global_alpha)
1529 {
1530   g_return_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle));


1531   g_return_if_fail (global_alpha &gt;= 0 &amp;&amp; global_alpha &lt;= 1);
1532 
1533   if (rectangle-&gt;global_alpha != global_alpha) {
1534     rectangle-&gt;global_alpha = global_alpha;
1535     if (global_alpha != 1)
1536       rectangle-&gt;flags |= GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA;
1537     else
1538       rectangle-&gt;flags &amp;= ~GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA;
1539     /* update seq_num automatically to signal the consumer, that data has changed
1540      * note, that this might mislead renderers, that can handle global-alpha
1541      * themselves, because what they want to know is whether the actual pixel data
1542      * has changed. */
1543     rectangle-&gt;seq_num = gst_video_overlay_get_seqnum ();
1544   }
1545 }
1546 
1547 /**
1548  * gst_video_overlay_rectangle_copy:
1549  * @rectangle: (transfer none): a #GstVideoOverlayRectangle to copy
1550  *
</pre>
</td>
<td>
<hr />
<pre>
  25  * @short_description: Video Buffer Overlay Compositions (Subtitles, Logos)
  26  *
  27  * Functions to create and handle overlay compositions on video buffers.
  28  *
  29  * An overlay composition describes one or more overlay rectangles to be
  30  * blended on top of a video buffer.
  31  *
  32  * This API serves two main purposes:
  33  *
  34  * * it can be used to attach overlay information (subtitles or logos)
  35  *   to non-raw video buffers such as GL/VAAPI/VDPAU surfaces. The actual
  36  *   blending of the overlay can then be done by e.g. the video sink that
  37  *   processes these non-raw buffers.
  38  *
  39  * * it can also be used to blend overlay rectangles on top of raw video
  40  *   buffers, thus consolidating blending functionality for raw video in
  41  *   one place.
  42  *
  43  * Together, this allows existing overlay elements to easily handle raw
  44  * and non-raw video as input in without major changes (once the overlays
<span class="line-modified">  45  * have been put into a #GstVideoOverlayComposition object anyway) - for raw</span>
  46  * video the overlay can just use the blending function to blend the data
  47  * on top of the video, and for surface buffers it can just attach them to
  48  * the buffer and let the sink render the overlays.
  49  *
  50  */
  51 
  52 /* TODO:
  53  *  - provide accessors for seq_num and other fields (as needed)
  54  *  - allow overlay to set/get original pango markup string on/from rectangle
  55  */
  56 
  57 #ifdef HAVE_CONFIG_H
  58 #include &quot;config.h&quot;
  59 #endif
  60 
  61 #include &quot;video-overlay-composition.h&quot;
  62 #include &quot;video-blend.h&quot;
  63 #include &quot;gstvideometa.h&quot;
  64 #include &lt;string.h&gt;
  65 
</pre>
<hr />
<pre>
 295 
 296   return ometa;
 297 }
 298 
 299 /* ------------------------------ composition ------------------------------ */
 300 
 301 #define RECTANGLE_ARRAY_STEP 4  /* premature optimization */
 302 
 303 GST_DEFINE_MINI_OBJECT_TYPE (GstVideoOverlayComposition,
 304     gst_video_overlay_composition);
 305 
 306 static void
 307 gst_video_overlay_composition_free (GstMiniObject * mini_obj)
 308 {
 309   GstVideoOverlayComposition *comp = (GstVideoOverlayComposition *) mini_obj;
 310   guint num;
 311 
 312   num = comp-&gt;num_rectangles;
 313 
 314   while (num &gt; 0) {
<span class="line-added"> 315     gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (comp-&gt;rectangles[num -</span>
<span class="line-added"> 316                 1]), GST_MINI_OBJECT_CAST (comp));</span>
 317     gst_video_overlay_rectangle_unref (comp-&gt;rectangles[num - 1]);
 318     --num;
 319   }
 320 
 321   g_free (comp-&gt;rectangles);
 322   comp-&gt;rectangles = NULL;
 323   comp-&gt;num_rectangles = 0;
 324 
 325   g_slice_free (GstVideoOverlayComposition, comp);
 326 }
 327 
 328 /**
 329  * gst_video_overlay_composition_new:
 330  * @rectangle: (transfer none): a #GstVideoOverlayRectangle to add to the
 331  *     composition
 332  *
 333  * Creates a new video overlay composition object to hold one or more
 334  * overlay rectangles.
 335  *
 336  * Returns: (transfer full): a new #GstVideoOverlayComposition. Unref with
</pre>
<hr />
<pre>
 339 GstVideoOverlayComposition *
 340 gst_video_overlay_composition_new (GstVideoOverlayRectangle * rectangle)
 341 {
 342   GstVideoOverlayComposition *comp;
 343 
 344 
 345   /* FIXME: should we allow empty compositions? Could also be expressed as
 346    * buffer without a composition on it. Maybe there are cases where doing
 347    * an empty new + _add() in a loop is easier? */
 348   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle), NULL);
 349 
 350   comp = g_slice_new0 (GstVideoOverlayComposition);
 351 
 352   gst_mini_object_init (GST_MINI_OBJECT_CAST (comp), 0,
 353       GST_TYPE_VIDEO_OVERLAY_COMPOSITION,
 354       (GstMiniObjectCopyFunction) gst_video_overlay_composition_copy,
 355       NULL, (GstMiniObjectFreeFunction) gst_video_overlay_composition_free);
 356 
 357   comp-&gt;rectangles = g_new0 (GstVideoOverlayRectangle *, RECTANGLE_ARRAY_STEP);
 358   comp-&gt;rectangles[0] = gst_video_overlay_rectangle_ref (rectangle);
<span class="line-added"> 359   gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (rectangle),</span>
<span class="line-added"> 360       GST_MINI_OBJECT_CAST (comp));</span>
 361   comp-&gt;num_rectangles = 1;
 362 
 363   comp-&gt;seq_num = gst_video_overlay_get_seqnum ();
 364 
 365   /* since the rectangle was created earlier, its seqnum is smaller than ours */
 366   comp-&gt;min_seq_num_used = rectangle-&gt;seq_num;
 367 
 368   GST_LOG (&quot;new composition %p: seq_num %u with rectangle %p&quot;, comp,
 369       comp-&gt;seq_num, rectangle);
 370 
 371   return comp;
 372 }
 373 
 374 /**
 375  * gst_video_overlay_composition_add_rectangle:
 376  * @comp: a #GstVideoOverlayComposition
 377  * @rectangle: (transfer none): a #GstVideoOverlayRectangle to add to the
 378  *     composition
 379  *
 380  * Adds an overlay rectangle to an existing overlay composition object. This
 381  * must be done right after creating the overlay composition.
 382  */
 383 void
 384 gst_video_overlay_composition_add_rectangle (GstVideoOverlayComposition * comp,
 385     GstVideoOverlayRectangle * rectangle)
 386 {
 387   g_return_if_fail (GST_IS_VIDEO_OVERLAY_COMPOSITION (comp));
 388   g_return_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle));
<span class="line-modified"> 389   g_return_if_fail (gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (comp)));</span>
 390 
 391   if (comp-&gt;num_rectangles % RECTANGLE_ARRAY_STEP == 0) {
 392     comp-&gt;rectangles =
 393         g_renew (GstVideoOverlayRectangle *, comp-&gt;rectangles,
 394         comp-&gt;num_rectangles + RECTANGLE_ARRAY_STEP);
 395   }
 396 
 397   comp-&gt;rectangles[comp-&gt;num_rectangles] =
 398       gst_video_overlay_rectangle_ref (rectangle);
<span class="line-added"> 399   gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (rectangle),</span>
<span class="line-added"> 400       GST_MINI_OBJECT_CAST (comp));</span>
 401   comp-&gt;num_rectangles += 1;
 402 
 403   comp-&gt;min_seq_num_used = MIN (comp-&gt;min_seq_num_used, rectangle-&gt;seq_num);
 404 
 405   GST_LOG (&quot;composition %p: added rectangle %p&quot;, comp, rectangle);
 406 }
 407 
 408 /**
 409  * gst_video_overlay_composition_n_rectangles:
 410  * @comp: a #GstVideoOverlayComposition
 411  *
 412  * Returns the number of #GstVideoOverlayRectangle&lt;!-- --&gt;s contained in @comp.
 413  *
 414  * Returns: the number of rectangles
 415  */
 416 guint
 417 gst_video_overlay_composition_n_rectangles (GstVideoOverlayComposition * comp)
 418 {
 419   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_COMPOSITION (comp), 0);
 420 
</pre>
<hr />
<pre>
 570 /**
 571  * gst_video_overlay_composition_make_writable:
 572  * @comp: (transfer full): a #GstVideoOverlayComposition to copy
 573  *
 574  * Takes ownership of @comp and returns a version of @comp that is writable
 575  * (i.e. can be modified). Will either return @comp right away, or create a
 576  * new writable copy of @comp and unref @comp itself. All the contained
 577  * rectangles will also be copied, but the actual overlay pixel data buffers
 578  * contained in the rectangles are not copied.
 579  *
 580  * Returns: (transfer full): a writable #GstVideoOverlayComposition
 581  *     equivalent to @comp.
 582  */
 583 GstVideoOverlayComposition *
 584 gst_video_overlay_composition_make_writable (GstVideoOverlayComposition * comp)
 585 {
 586   GstVideoOverlayComposition *writable_comp;
 587 
 588   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_COMPOSITION (comp), NULL);
 589 
<span class="line-modified"> 590   if (gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (comp))) {</span>
 591     guint n;
 592 
 593     for (n = 0; n &lt; comp-&gt;num_rectangles; ++n) {
<span class="line-modified"> 594       if (!gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (comp-&gt;rectangles</span>
<span class="line-added"> 595                   [n])))</span>
 596         goto copy;
 597     }
 598     return comp;
 599   }
 600 
 601 copy:
 602 
 603   writable_comp = gst_video_overlay_composition_copy (comp);
 604   gst_video_overlay_composition_unref (comp);
 605 
 606   return writable_comp;
 607 }
 608 
 609 /**
 610  * gst_video_overlay_composition_get_seqnum:
 611  * @comp: a #GstVideoOverlayComposition
 612  *
 613  * Returns the sequence number of this composition. Sequence numbers are
 614  * monotonically increasing and unique for overlay compositions and rectangles
 615  * (meaning there will never be a rectangle with the same sequence number as
</pre>
<hr />
<pre>
 618  * Returns: the sequence number of @comp
 619  */
 620 guint
 621 gst_video_overlay_composition_get_seqnum (GstVideoOverlayComposition * comp)
 622 {
 623   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_COMPOSITION (comp), 0);
 624 
 625   return comp-&gt;seq_num;
 626 }
 627 
 628 /* ------------------------------ rectangles ------------------------------ -*/
 629 
 630 GST_DEFINE_MINI_OBJECT_TYPE (GstVideoOverlayRectangle,
 631     gst_video_overlay_rectangle);
 632 
 633 static void
 634 gst_video_overlay_rectangle_free (GstMiniObject * mini_obj)
 635 {
 636   GstVideoOverlayRectangle *rect = (GstVideoOverlayRectangle *) mini_obj;
 637 
<span class="line-added"> 638   gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (rect-&gt;pixels),</span>
<span class="line-added"> 639       GST_MINI_OBJECT_CAST (rect));</span>
 640   gst_buffer_replace (&amp;rect-&gt;pixels, NULL);
 641 
 642   while (rect-&gt;scaled_rectangles != NULL) {
 643     GstVideoOverlayRectangle *scaled_rect = rect-&gt;scaled_rectangles-&gt;data;
 644 
 645     gst_video_overlay_rectangle_unref (scaled_rect);
 646 
 647     rect-&gt;scaled_rectangles =
 648         g_list_delete_link (rect-&gt;scaled_rectangles, rect-&gt;scaled_rectangles);
 649   }
 650 
 651   g_free (rect-&gt;initial_alpha);
 652   g_mutex_clear (&amp;rect-&gt;lock);
 653 
 654   g_slice_free (GstVideoOverlayRectangle, rect);
 655 }
 656 
 657 static inline gboolean
 658 gst_video_overlay_rectangle_check_flags (GstVideoOverlayFormatFlags flags)
 659 {
</pre>
<hr />
<pre>
 721 
 722   format = vmeta-&gt;format;
 723   width = vmeta-&gt;width;
 724   height = vmeta-&gt;height;
 725 
 726   /* technically ((height-1)*stride)+width might be okay too */
 727   g_return_val_if_fail (gst_buffer_get_size (pixels) &gt;= height * width * 4,
 728       NULL);
 729   g_return_val_if_fail (height &gt; 0 &amp;&amp; width &gt; 0, NULL);
 730 
 731   rect = g_slice_new0 (GstVideoOverlayRectangle);
 732 
 733   gst_mini_object_init (GST_MINI_OBJECT_CAST (rect), 0,
 734       GST_TYPE_VIDEO_OVERLAY_RECTANGLE,
 735       (GstMiniObjectCopyFunction) gst_video_overlay_rectangle_copy,
 736       NULL, (GstMiniObjectFreeFunction) gst_video_overlay_rectangle_free);
 737 
 738   g_mutex_init (&amp;rect-&gt;lock);
 739 
 740   rect-&gt;pixels = gst_buffer_ref (pixels);
<span class="line-added"> 741   gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (pixels),</span>
<span class="line-added"> 742       GST_MINI_OBJECT_CAST (rect));</span>
 743   rect-&gt;scaled_rectangles = NULL;
 744 
 745   gst_video_info_init (&amp;rect-&gt;info);
 746   if (!gst_video_info_set_format (&amp;rect-&gt;info, format, width, height)) {
 747     gst_mini_object_unref (GST_MINI_OBJECT_CAST (rect));
 748     return NULL;
 749   }
 750   if (flags &amp; GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA)
 751     rect-&gt;info.flags |= GST_VIDEO_FLAG_PREMULTIPLIED_ALPHA;
 752 
 753   rect-&gt;x = render_x;
 754   rect-&gt;y = render_y;
 755   rect-&gt;render_width = render_width;
 756   rect-&gt;render_height = render_height;
 757 
 758   rect-&gt;global_alpha = 1.0;
 759   rect-&gt;applied_global_alpha = 1.0;
 760   rect-&gt;initial_alpha = NULL;
 761 
 762   rect-&gt;flags = flags;
</pre>
<hr />
<pre>
 810  * @render_y: render Y position of rectangle on video
 811  * @render_width: render width of rectangle
 812  * @render_height: render height of rectangle
 813  *
 814  * Sets the render position and dimensions of the rectangle on the video.
 815  * This function is mainly for elements that modify the size of the video
 816  * in some way (e.g. through scaling or cropping) and need to adjust the
 817  * details of any overlays to match the operation that changed the size.
 818  *
 819  * @rectangle must be writable, meaning its refcount must be 1. You can
 820  * make the rectangles inside a #GstVideoOverlayComposition writable using
 821  * gst_video_overlay_composition_make_writable() or
 822  * gst_video_overlay_composition_copy().
 823  */
 824 void
 825 gst_video_overlay_rectangle_set_render_rectangle (GstVideoOverlayRectangle *
 826     rectangle, gint render_x, gint render_y, guint render_width,
 827     guint render_height)
 828 {
 829   g_return_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle));
<span class="line-modified"> 830   g_return_if_fail (gst_mini_object_is_writable (GST_MINI_OBJECT_CAST</span>
<span class="line-added"> 831           (rectangle)));</span>
 832 
 833   rectangle-&gt;x = render_x;
 834   rectangle-&gt;y = render_y;
 835   rectangle-&gt;render_width = render_width;
 836   rectangle-&gt;render_height = render_height;
 837 }
 838 
 839 /* FIXME: orc-ify */
 840 static void
 841 gst_video_overlay_rectangle_premultiply_0 (GstVideoFrame * frame)
 842 {
 843   int i, j;
<span class="line-modified"> 844   int width = GST_VIDEO_FRAME_WIDTH (frame);</span>
<span class="line-added"> 845   int height = GST_VIDEO_FRAME_HEIGHT (frame);</span>
<span class="line-added"> 846   int stride = GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0);</span>
<span class="line-added"> 847   guint8 *data = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);</span>
<span class="line-added"> 848 </span>
<span class="line-added"> 849   for (j = 0; j &lt; height; ++j) {</span>
 850     guint8 *line;
 851 
<span class="line-modified"> 852     line = data;</span>
<span class="line-modified"> 853     line += stride * j;</span>
<span class="line-modified"> 854     for (i = 0; i &lt; width; ++i) {</span>
 855       int a = line[0];
 856       line[1] = line[1] * a / 255;
 857       line[2] = line[2] * a / 255;
 858       line[3] = line[3] * a / 255;
 859       line += 4;
 860     }
 861   }
 862 }
 863 
 864 static void
 865 gst_video_overlay_rectangle_premultiply_3 (GstVideoFrame * frame)
 866 {
 867   int i, j;
<span class="line-modified"> 868   int width = GST_VIDEO_FRAME_WIDTH (frame);</span>
<span class="line-added"> 869   int height = GST_VIDEO_FRAME_HEIGHT (frame);</span>
<span class="line-added"> 870   int stride = GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0);</span>
<span class="line-added"> 871   guint8 *data = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);</span>
<span class="line-added"> 872 </span>
<span class="line-added"> 873   for (j = 0; j &lt; height; ++j) {</span>
 874     guint8 *line;
 875 
<span class="line-modified"> 876     line = data;</span>
<span class="line-modified"> 877     line += stride * j;</span>
<span class="line-modified"> 878     for (i = 0; i &lt; width; ++i) {</span>
 879       int a = line[3];
 880       line[0] = line[0] * a / 255;
 881       line[1] = line[1] * a / 255;
 882       line[2] = line[2] * a / 255;
 883       line += 4;
 884     }
 885   }
 886 }
 887 
 888 static void
 889 gst_video_overlay_rectangle_premultiply (GstVideoFrame * frame)
 890 {
 891   gint alpha_offset;
 892 
 893   alpha_offset = GST_VIDEO_FRAME_COMP_POFFSET (frame, 3);
 894   switch (alpha_offset) {
 895     case 0:
 896       gst_video_overlay_rectangle_premultiply_0 (frame);
 897       break;
 898     case 3:
 899       gst_video_overlay_rectangle_premultiply_3 (frame);
 900       break;
 901     default:
 902       g_assert_not_reached ();
 903       break;
 904   }
 905 }
 906 
 907 /* FIXME: orc-ify */
 908 static void
 909 gst_video_overlay_rectangle_unpremultiply_0 (GstVideoFrame * frame)
 910 {
 911   int i, j;
<span class="line-modified"> 912   int width = GST_VIDEO_FRAME_WIDTH (frame);</span>
<span class="line-added"> 913   int height = GST_VIDEO_FRAME_HEIGHT (frame);</span>
<span class="line-added"> 914   int stride = GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0);</span>
<span class="line-added"> 915   guint8 *data = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);</span>
<span class="line-added"> 916 </span>
<span class="line-added"> 917   for (j = 0; j &lt; height; ++j) {</span>
 918     guint8 *line;
 919 
<span class="line-modified"> 920     line = data;</span>
<span class="line-modified"> 921     line += stride * j;</span>
<span class="line-modified"> 922     for (i = 0; i &lt; width; ++i) {</span>
 923       int a = line[0];
 924       if (a) {
 925         line[1] = MIN ((line[1] * 255 + a / 2) / a, 255);
 926         line[2] = MIN ((line[2] * 255 + a / 2) / a, 255);
 927         line[3] = MIN ((line[3] * 255 + a / 2) / a, 255);
 928       }
 929       line += 4;
 930     }
 931   }
 932 }
 933 
 934 static void
 935 gst_video_overlay_rectangle_unpremultiply_3 (GstVideoFrame * frame)
 936 {
 937   int i, j;
<span class="line-modified"> 938   int width = GST_VIDEO_FRAME_WIDTH (frame);</span>
<span class="line-added"> 939   int height = GST_VIDEO_FRAME_HEIGHT (frame);</span>
<span class="line-added"> 940   int stride = GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0);</span>
<span class="line-added"> 941   guint8 *data = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);</span>
<span class="line-added"> 942 </span>
<span class="line-added"> 943   for (j = 0; j &lt; height; ++j) {</span>
 944     guint8 *line;
 945 
<span class="line-modified"> 946     line = data;</span>
<span class="line-modified"> 947     line += stride * j;</span>
<span class="line-modified"> 948     for (i = 0; i &lt; width; ++i) {</span>
 949       int a = line[3];
 950       if (a) {
 951         line[0] = MIN ((line[0] * 255 + a / 2) / a, 255);
 952         line[1] = MIN ((line[1] * 255 + a / 2) / a, 255);
 953         line[2] = MIN ((line[2] * 255 + a / 2) / a, 255);
 954       }
 955       line += 4;
 956     }
 957   }
 958 }
 959 
 960 static void
 961 gst_video_overlay_rectangle_unpremultiply (GstVideoFrame * frame)
 962 {
 963   gint alpha_offset;
 964 
 965   alpha_offset = GST_VIDEO_FRAME_COMP_POFFSET (frame, 3);
 966   switch (alpha_offset) {
 967     case 0:
 968       gst_video_overlay_rectangle_unpremultiply_0 (frame);
</pre>
<hr />
<pre>
1015 {
1016   guint8 *src, *dst;
1017   GstVideoFrame frame;
1018   gint i, j, w, h, stride;
1019   gint argb_a, argb_r, argb_g, argb_b;
1020   gint alpha_offset;
1021 
1022   g_assert (!(rect-&gt;applied_global_alpha != 1.0
1023           &amp;&amp; rect-&gt;initial_alpha == NULL));
1024 
1025   alpha_offset = GST_VIDEO_INFO_COMP_POFFSET (&amp;rect-&gt;info, 3);
1026   g_return_if_fail (alpha_offset == 0 || alpha_offset == 3);
1027 
1028   if (global_alpha == rect-&gt;applied_global_alpha)
1029     return;
1030 
1031   if (rect-&gt;initial_alpha == NULL)
1032     gst_video_overlay_rectangle_extract_alpha (rect);
1033 
1034   src = rect-&gt;initial_alpha;
<span class="line-modified">1035   if (!gst_buffer_is_writable (rect-&gt;pixels)) {</span>
<span class="line-added">1036     gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (rect-&gt;pixels),</span>
<span class="line-added">1037         GST_MINI_OBJECT_CAST (rect));</span>
<span class="line-added">1038     rect-&gt;pixels = gst_buffer_copy (rect-&gt;pixels);</span>
<span class="line-added">1039     gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (rect-&gt;pixels),</span>
<span class="line-added">1040         GST_MINI_OBJECT_CAST (rect));</span>
<span class="line-added">1041   }</span>
1042 
1043   gst_video_frame_map (&amp;frame, &amp;rect-&gt;info, rect-&gt;pixels, GST_MAP_READ);
1044   dst = GST_VIDEO_FRAME_PLANE_DATA (&amp;frame, 0);
1045   w = GST_VIDEO_INFO_WIDTH (&amp;rect-&gt;info);
1046   h = GST_VIDEO_INFO_HEIGHT (&amp;rect-&gt;info);
1047   stride = GST_VIDEO_INFO_PLANE_STRIDE (&amp;rect-&gt;info, 0);
1048 
1049   argb_a = GST_VIDEO_INFO_COMP_POFFSET (&amp;rect-&gt;info, 3);
1050   argb_r = (argb_a + 1) % 4;
1051   argb_g = (argb_a + 2) % 4;
1052   argb_b = (argb_a + 3) % 4;
1053 
1054   for (i = 0; i &lt; h; i++) {
1055     for (j = 0; j &lt; w; j++) {
1056       guint8 na = (guint8) (*src * global_alpha);
1057 
1058       if (! !(rect-&gt;flags &amp; GST_VIDEO_OVERLAY_FORMAT_FLAG_PREMULTIPLIED_ALPHA)) {
1059         dst[argb_r] =
1060             (guint8) ((double) (dst[argb_r] * 255) / (double) dst[argb_a]) *
1061             na / 255;
</pre>
<hr />
<pre>
1549 
1550 /**
1551  * gst_video_overlay_rectangle_set_global_alpha:
1552  * @rectangle: a #GstVideoOverlayRectangle
1553  * @global_alpha: Global alpha value (0 to 1.0)
1554  *
1555  * Sets the global alpha value associated with a #GstVideoOverlayRectangle. Per-
1556  * pixel alpha values are multiplied with this value. Valid
1557  * values: 0 &lt;= global_alpha &lt;= 1; 1 to deactivate.
1558  *
1559  * @rectangle must be writable, meaning its refcount must be 1. You can
1560  * make the rectangles inside a #GstVideoOverlayComposition writable using
1561  * gst_video_overlay_composition_make_writable() or
1562  * gst_video_overlay_composition_copy().
1563  */
1564 void
1565 gst_video_overlay_rectangle_set_global_alpha (GstVideoOverlayRectangle *
1566     rectangle, gfloat global_alpha)
1567 {
1568   g_return_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle));
<span class="line-added">1569   g_return_if_fail (gst_mini_object_is_writable (GST_MINI_OBJECT_CAST</span>
<span class="line-added">1570           (rectangle)));</span>
1571   g_return_if_fail (global_alpha &gt;= 0 &amp;&amp; global_alpha &lt;= 1);
1572 
1573   if (rectangle-&gt;global_alpha != global_alpha) {
1574     rectangle-&gt;global_alpha = global_alpha;
1575     if (global_alpha != 1)
1576       rectangle-&gt;flags |= GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA;
1577     else
1578       rectangle-&gt;flags &amp;= ~GST_VIDEO_OVERLAY_FORMAT_FLAG_GLOBAL_ALPHA;
1579     /* update seq_num automatically to signal the consumer, that data has changed
1580      * note, that this might mislead renderers, that can handle global-alpha
1581      * themselves, because what they want to know is whether the actual pixel data
1582      * has changed. */
1583     rectangle-&gt;seq_num = gst_video_overlay_get_seqnum ();
1584   }
1585 }
1586 
1587 /**
1588  * gst_video_overlay_rectangle_copy:
1589  * @rectangle: (transfer none): a #GstVideoOverlayRectangle to copy
1590  *
</pre>
</td>
</tr>
</table>
<center><a href="video-orc.orc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="video-overlay-composition.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>