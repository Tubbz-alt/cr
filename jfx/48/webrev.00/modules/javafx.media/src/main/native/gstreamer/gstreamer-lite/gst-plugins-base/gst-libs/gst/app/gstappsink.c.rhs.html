<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/app/gstappsink.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 2007 David Schleef &lt;ds@schleef.org&gt;
   3  *           (C) 2008 Wim Taymans &lt;wim.taymans@gmail.com&gt;
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Library General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Library General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Library General Public
  16  * License along with this library; if not, write to the
  17  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  18  * Boston, MA 02110-1301, USA.
  19  */
  20 /**
  21  * SECTION:gstappsink
  22  * @title: GstAppSink
  23  * @short_description: Easy way for applications to extract samples from a
  24  *     pipeline
  25  * @see_also: #GstSample, #GstBaseSink, appsrc
  26  *
  27  * Appsink is a sink plugin that supports many different methods for making
  28  * the application get a handle on the GStreamer data in a pipeline. Unlike
  29  * most GStreamer elements, Appsink provides external API functions.
  30  *
  31  * appsink can be used by linking to the gstappsink.h header file to access the
  32  * methods or by using the appsink action signals and properties.
  33  *
  34  * The normal way of retrieving samples from appsink is by using the
  35  * gst_app_sink_pull_sample() and gst_app_sink_pull_preroll() methods.
  36  * These methods block until a sample becomes available in the sink or when the
  37  * sink is shut down or reaches EOS. There are also timed variants of these
  38  * methods, gst_app_sink_try_pull_sample() and gst_app_sink_try_pull_preroll(),
  39  * which accept a timeout parameter to limit the amount of time to wait.
  40  *
  41  * Appsink will internally use a queue to collect buffers from the streaming
  42  * thread. If the application is not pulling samples fast enough, this queue
  43  * will consume a lot of memory over time. The &quot;max-buffers&quot; property can be
  44  * used to limit the queue size. The &quot;drop&quot; property controls whether the
  45  * streaming thread blocks or if older buffers are dropped when the maximum
  46  * queue size is reached. Note that blocking the streaming thread can negatively
  47  * affect real-time performance and should be avoided.
  48  *
  49  * If a blocking behaviour is not desirable, setting the &quot;emit-signals&quot; property
  50  * to %TRUE will make appsink emit the &quot;new-sample&quot; and &quot;new-preroll&quot; signals
  51  * when a sample can be pulled without blocking.
  52  *
  53  * The &quot;caps&quot; property on appsink can be used to control the formats that
  54  * appsink can receive. This property can contain non-fixed caps, the format of
  55  * the pulled samples can be obtained by getting the sample caps.
  56  *
  57  * If one of the pull-preroll or pull-sample methods return %NULL, the appsink
  58  * is stopped or in the EOS state. You can check for the EOS state with the
  59  * &quot;eos&quot; property or with the gst_app_sink_is_eos() method.
  60  *
  61  * The eos signal can also be used to be informed when the EOS state is reached
  62  * to avoid polling.
  63  */
  64 
  65 #ifdef HAVE_CONFIG_H
  66 #include &quot;config.h&quot;
  67 #endif
  68 
  69 #include &lt;gst/gst.h&gt;
  70 #include &lt;gst/base/base.h&gt;
  71 
  72 #include &lt;string.h&gt;
  73 
  74 #include &quot;gstappsink.h&quot;
  75 
  76 typedef enum
  77 {
  78   NOONE_WAITING = 0,
  79   STREAM_WAITING = 1 &lt;&lt; 0,      /* streaming thread is waiting for application thread */
  80   APP_WAITING = 1 &lt;&lt; 1,         /* application thread is waiting for streaming thread */
  81 } GstAppSinkWaitStatus;
  82 
  83 struct _GstAppSinkPrivate
  84 {
  85   GstCaps *caps;
  86   gboolean emit_signals;
  87   guint num_buffers;
  88   guint max_buffers;
  89   gboolean drop;
  90   gboolean wait_on_eos;
  91   GstAppSinkWaitStatus wait_status;
  92 
  93   GCond cond;
  94   GMutex mutex;
  95   GstQueueArray *queue;
  96   GstBuffer *preroll_buffer;
  97   GstCaps *preroll_caps;
  98   GstCaps *last_caps;
  99   GstSegment preroll_segment;
 100   GstSegment last_segment;
 101   gboolean flushing;
 102   gboolean unlock;
 103   gboolean started;
 104   gboolean is_eos;
 105   gboolean buffer_lists_supported;
 106 
 107   GstAppSinkCallbacks callbacks;
 108   gpointer user_data;
 109   GDestroyNotify notify;
<a name="1" id="anc1"></a><span class="line-added"> 110 </span>
<span class="line-added"> 111   GstSample *sample;</span>
 112 };
 113 
 114 GST_DEBUG_CATEGORY_STATIC (app_sink_debug);
 115 #define GST_CAT_DEFAULT app_sink_debug
 116 
 117 enum
 118 {
 119   /* signals */
 120   SIGNAL_EOS,
 121   SIGNAL_NEW_PREROLL,
 122   SIGNAL_NEW_SAMPLE,
 123 
 124   /* actions */
 125   SIGNAL_PULL_PREROLL,
 126   SIGNAL_PULL_SAMPLE,
 127   SIGNAL_TRY_PULL_PREROLL,
 128   SIGNAL_TRY_PULL_SAMPLE,
 129 
 130   LAST_SIGNAL
 131 };
 132 
<a name="2" id="anc2"></a><span class="line-modified"> 133 #define DEFAULT_PROP_EOS    TRUE</span>
<span class="line-modified"> 134 #define DEFAULT_PROP_EMIT_SIGNALS FALSE</span>
<span class="line-modified"> 135 #define DEFAULT_PROP_MAX_BUFFERS  0</span>
<span class="line-modified"> 136 #define DEFAULT_PROP_DROP   FALSE</span>
<span class="line-modified"> 137 #define DEFAULT_PROP_WAIT_ON_EOS  TRUE</span>
<span class="line-modified"> 138 #define DEFAULT_PROP_BUFFER_LIST  FALSE</span>
 139 
 140 enum
 141 {
 142   PROP_0,
 143   PROP_CAPS,
 144   PROP_EOS,
 145   PROP_EMIT_SIGNALS,
 146   PROP_MAX_BUFFERS,
 147   PROP_DROP,
 148   PROP_WAIT_ON_EOS,
 149   PROP_BUFFER_LIST,
 150   PROP_LAST
 151 };
 152 
 153 static GstStaticPadTemplate gst_app_sink_template =
 154 GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,
 155     GST_PAD_SINK,
 156     GST_PAD_ALWAYS,
 157     GST_STATIC_CAPS_ANY);
 158 
 159 static void gst_app_sink_uri_handler_init (gpointer g_iface,
 160     gpointer iface_data);
 161 
 162 static void gst_app_sink_dispose (GObject * object);
 163 static void gst_app_sink_finalize (GObject * object);
 164 
 165 static void gst_app_sink_set_property (GObject * object, guint prop_id,
 166     const GValue * value, GParamSpec * pspec);
 167 static void gst_app_sink_get_property (GObject * object, guint prop_id,
 168     GValue * value, GParamSpec * pspec);
 169 
 170 static gboolean gst_app_sink_unlock_start (GstBaseSink * bsink);
 171 static gboolean gst_app_sink_unlock_stop (GstBaseSink * bsink);
 172 static gboolean gst_app_sink_start (GstBaseSink * psink);
 173 static gboolean gst_app_sink_stop (GstBaseSink * psink);
 174 static gboolean gst_app_sink_event (GstBaseSink * sink, GstEvent * event);
 175 static gboolean gst_app_sink_query (GstBaseSink * bsink, GstQuery * query);
 176 static GstFlowReturn gst_app_sink_preroll (GstBaseSink * psink,
 177     GstBuffer * buffer);
 178 static GstFlowReturn gst_app_sink_render_common (GstBaseSink * psink,
 179     GstMiniObject * data, gboolean is_list);
 180 static GstFlowReturn gst_app_sink_render (GstBaseSink * psink,
 181     GstBuffer * buffer);
 182 static GstFlowReturn gst_app_sink_render_list (GstBaseSink * psink,
 183     GstBufferList * list);
 184 static gboolean gst_app_sink_setcaps (GstBaseSink * sink, GstCaps * caps);
 185 static GstCaps *gst_app_sink_getcaps (GstBaseSink * psink, GstCaps * filter);
 186 
 187 static guint gst_app_sink_signals[LAST_SIGNAL] = { 0 };
 188 
 189 #define gst_app_sink_parent_class parent_class
 190 G_DEFINE_TYPE_WITH_CODE (GstAppSink, gst_app_sink, GST_TYPE_BASE_SINK,
<a name="3" id="anc3"></a><span class="line-added"> 191     G_ADD_PRIVATE (GstAppSink)</span>
 192     G_IMPLEMENT_INTERFACE (GST_TYPE_URI_HANDLER,
 193         gst_app_sink_uri_handler_init));
 194 
 195 static void
 196 gst_app_sink_class_init (GstAppSinkClass * klass)
 197 {
 198   GObjectClass *gobject_class = (GObjectClass *) klass;
 199   GstElementClass *element_class = (GstElementClass *) klass;
 200   GstBaseSinkClass *basesink_class = (GstBaseSinkClass *) klass;
 201 
 202   GST_DEBUG_CATEGORY_INIT (app_sink_debug, &quot;appsink&quot;, 0, &quot;appsink element&quot;);
 203 
 204   gobject_class-&gt;dispose = gst_app_sink_dispose;
 205   gobject_class-&gt;finalize = gst_app_sink_finalize;
 206 
 207   gobject_class-&gt;set_property = gst_app_sink_set_property;
 208   gobject_class-&gt;get_property = gst_app_sink_get_property;
 209 
 210   g_object_class_install_property (gobject_class, PROP_CAPS,
 211       g_param_spec_boxed (&quot;caps&quot;, &quot;Caps&quot;,
 212           &quot;The allowed caps for the sink pad&quot;, GST_TYPE_CAPS,
 213           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 214 
 215   g_object_class_install_property (gobject_class, PROP_EOS,
 216       g_param_spec_boolean (&quot;eos&quot;, &quot;EOS&quot;,
 217           &quot;Check if the sink is EOS or not started&quot;, DEFAULT_PROP_EOS,
 218           G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 219 
 220   g_object_class_install_property (gobject_class, PROP_EMIT_SIGNALS,
 221       g_param_spec_boolean (&quot;emit-signals&quot;, &quot;Emit signals&quot;,
 222           &quot;Emit new-preroll and new-sample signals&quot;,
 223           DEFAULT_PROP_EMIT_SIGNALS,
 224           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 225 
 226   g_object_class_install_property (gobject_class, PROP_MAX_BUFFERS,
 227       g_param_spec_uint (&quot;max-buffers&quot;, &quot;Max Buffers&quot;,
 228           &quot;The maximum number of buffers to queue internally (0 = unlimited)&quot;,
 229           0, G_MAXUINT, DEFAULT_PROP_MAX_BUFFERS,
 230           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 231 
 232   g_object_class_install_property (gobject_class, PROP_DROP,
 233       g_param_spec_boolean (&quot;drop&quot;, &quot;Drop&quot;,
 234           &quot;Drop old buffers when the buffer queue is filled&quot;, DEFAULT_PROP_DROP,
 235           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 236 
 237   g_object_class_install_property (gobject_class, PROP_BUFFER_LIST,
 238       g_param_spec_boolean (&quot;buffer-list&quot;, &quot;Buffer List&quot;,
 239           &quot;Use buffer lists&quot;, DEFAULT_PROP_BUFFER_LIST,
 240           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 241   /**
 242    * GstAppSink::wait-on-eos:
 243    *
 244    * Wait for all buffers to be processed after receiving an EOS.
 245    *
 246    * In cases where it is uncertain if an @appsink will have a consumer for its buffers
 247    * when it receives an EOS, set to %FALSE to ensure that the @appsink will not hang.
 248    *
 249    * Since: 1.8
 250    */
 251   g_object_class_install_property (gobject_class, PROP_WAIT_ON_EOS,
 252       g_param_spec_boolean (&quot;wait-on-eos&quot;, &quot;Wait on EOS&quot;,
 253           &quot;Wait for all buffers to be processed after receiving an EOS&quot;,
 254           DEFAULT_PROP_WAIT_ON_EOS,
 255           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 256 
 257   /**
 258    * GstAppSink::eos:
 259    * @appsink: the appsink element that emitted the signal
 260    *
 261    * Signal that the end-of-stream has been reached. This signal is emitted from
 262    * the streaming thread.
 263    */
 264   gst_app_sink_signals[SIGNAL_EOS] =
 265       g_signal_new (&quot;eos&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 266       G_STRUCT_OFFSET (GstAppSinkClass, eos),
 267       NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0, G_TYPE_NONE);
 268   /**
 269    * GstAppSink::new-preroll:
 270    * @appsink: the appsink element that emitted the signal
 271    *
 272    * Signal that a new preroll sample is available.
 273    *
 274    * This signal is emitted from the streaming thread and only when the
 275    * &quot;emit-signals&quot; property is %TRUE.
 276    *
 277    * The new preroll sample can be retrieved with the &quot;pull-preroll&quot; action
 278    * signal or gst_app_sink_pull_preroll() either from this signal callback
 279    * or from any other thread.
 280    *
 281    * Note that this signal is only emitted when the &quot;emit-signals&quot; property is
 282    * set to %TRUE, which it is not by default for performance reasons.
 283    */
 284   gst_app_sink_signals[SIGNAL_NEW_PREROLL] =
 285       g_signal_new (&quot;new-preroll&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 286       G_STRUCT_OFFSET (GstAppSinkClass, new_preroll),
 287       NULL, NULL, NULL, GST_TYPE_FLOW_RETURN, 0, G_TYPE_NONE);
 288   /**
 289    * GstAppSink::new-sample:
<a name="4" id="anc4"></a><span class="line-modified"> 290    * @appsink: the appsink element that emitted the signal</span>
 291    *
 292    * Signal that a new sample is available.
 293    *
 294    * This signal is emitted from the streaming thread and only when the
 295    * &quot;emit-signals&quot; property is %TRUE.
 296    *
 297    * The new sample can be retrieved with the &quot;pull-sample&quot; action
 298    * signal or gst_app_sink_pull_sample() either from this signal callback
 299    * or from any other thread.
 300    *
 301    * Note that this signal is only emitted when the &quot;emit-signals&quot; property is
 302    * set to %TRUE, which it is not by default for performance reasons.
 303    */
 304   gst_app_sink_signals[SIGNAL_NEW_SAMPLE] =
 305       g_signal_new (&quot;new-sample&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 306       G_STRUCT_OFFSET (GstAppSinkClass, new_sample),
 307       NULL, NULL, NULL, GST_TYPE_FLOW_RETURN, 0, G_TYPE_NONE);
 308 
 309   /**
 310    * GstAppSink::pull-preroll:
 311    * @appsink: the appsink element to emit this signal on
 312    *
 313    * Get the last preroll sample in @appsink. This was the sample that caused the
 314    * appsink to preroll in the PAUSED state.
 315    *
 316    * This function is typically used when dealing with a pipeline in the PAUSED
 317    * state. Calling this function after doing a seek will give the sample right
 318    * after the seek position.
 319    *
 320    * Calling this function will clear the internal reference to the preroll
 321    * buffer.
 322    *
 323    * Note that the preroll sample will also be returned as the first sample
 324    * when calling gst_app_sink_pull_sample() or the &quot;pull-sample&quot; action signal.
 325    *
 326    * If an EOS event was received before any buffers, this function returns
 327    * %NULL. Use gst_app_sink_is_eos () to check for the EOS condition.
 328    *
 329    * This function blocks until a preroll sample or EOS is received or the appsink
 330    * element is set to the READY/NULL state.
 331    *
 332    * Returns: a #GstSample or NULL when the appsink is stopped or EOS.
 333    */
 334   gst_app_sink_signals[SIGNAL_PULL_PREROLL] =
 335       g_signal_new (&quot;pull-preroll&quot;, G_TYPE_FROM_CLASS (klass),
 336       G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION, G_STRUCT_OFFSET (GstAppSinkClass,
 337           pull_preroll), NULL, NULL, NULL, GST_TYPE_SAMPLE, 0, G_TYPE_NONE);
 338   /**
 339    * GstAppSink::pull-sample:
 340    * @appsink: the appsink element to emit this signal on
 341    *
 342    * This function blocks until a sample or EOS becomes available or the appsink
 343    * element is set to the READY/NULL state.
 344    *
 345    * This function will only return samples when the appsink is in the PLAYING
 346    * state. All rendered samples will be put in a queue so that the application
 347    * can pull samples at its own rate.
 348    *
 349    * Note that when the application does not pull samples fast enough, the
 350    * queued samples could consume a lot of memory, especially when dealing with
 351    * raw video frames. It&#39;s possible to control the behaviour of the queue with
 352    * the &quot;drop&quot; and &quot;max-buffers&quot; properties.
 353    *
 354    * If an EOS event was received before any buffers, this function returns
 355    * %NULL. Use gst_app_sink_is_eos () to check for the EOS condition.
 356    *
 357    * Returns: a #GstSample or NULL when the appsink is stopped or EOS.
 358    */
 359   gst_app_sink_signals[SIGNAL_PULL_SAMPLE] =
 360       g_signal_new (&quot;pull-sample&quot;, G_TYPE_FROM_CLASS (klass),
 361       G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION, G_STRUCT_OFFSET (GstAppSinkClass,
 362           pull_sample), NULL, NULL, NULL, GST_TYPE_SAMPLE, 0, G_TYPE_NONE);
 363   /**
 364    * GstAppSink::try-pull-preroll:
 365    * @appsink: the appsink element to emit this signal on
 366    * @timeout: the maximum amount of time to wait for the preroll sample
 367    *
 368    * Get the last preroll sample in @appsink. This was the sample that caused the
 369    * appsink to preroll in the PAUSED state.
 370    *
 371    * This function is typically used when dealing with a pipeline in the PAUSED
 372    * state. Calling this function after doing a seek will give the sample right
 373    * after the seek position.
 374    *
 375    * Calling this function will clear the internal reference to the preroll
 376    * buffer.
 377    *
 378    * Note that the preroll sample will also be returned as the first sample
 379    * when calling gst_app_sink_pull_sample() or the &quot;pull-sample&quot; action signal.
 380    *
 381    * If an EOS event was received before any buffers or the timeout expires,
 382    * this function returns %NULL. Use gst_app_sink_is_eos () to check for the EOS
 383    * condition.
 384    *
 385    * This function blocks until a preroll sample or EOS is received, the appsink
 386    * element is set to the READY/NULL state, or the timeout expires.
 387    *
 388    * Returns: a #GstSample or NULL when the appsink is stopped or EOS or the timeout expires.
 389    *
 390    * Since: 1.10
 391    */
 392   gst_app_sink_signals[SIGNAL_TRY_PULL_PREROLL] =
 393       g_signal_new (&quot;try-pull-preroll&quot;, G_TYPE_FROM_CLASS (klass),
 394       G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
 395       G_STRUCT_OFFSET (GstAppSinkClass, try_pull_preroll), NULL, NULL, NULL,
 396       GST_TYPE_SAMPLE, 1, GST_TYPE_CLOCK_TIME);
 397   /**
 398    * GstAppSink::try-pull-sample:
 399    * @appsink: the appsink element to emit this signal on
 400    * @timeout: the maximum amount of time to wait for a sample
 401    *
 402    * This function blocks until a sample or EOS becomes available or the appsink
 403    * element is set to the READY/NULL state or the timeout expires.
 404    *
 405    * This function will only return samples when the appsink is in the PLAYING
 406    * state. All rendered samples will be put in a queue so that the application
 407    * can pull samples at its own rate.
 408    *
 409    * Note that when the application does not pull samples fast enough, the
 410    * queued samples could consume a lot of memory, especially when dealing with
 411    * raw video frames. It&#39;s possible to control the behaviour of the queue with
 412    * the &quot;drop&quot; and &quot;max-buffers&quot; properties.
 413    *
 414    * If an EOS event was received before any buffers or the timeout expires,
 415    * this function returns %NULL. Use gst_app_sink_is_eos () to check
 416    * for the EOS condition.
 417    *
 418    * Returns: a #GstSample or NULL when the appsink is stopped or EOS or the timeout expires.
 419    *
 420    * Since: 1.10
 421    */
 422   gst_app_sink_signals[SIGNAL_TRY_PULL_SAMPLE] =
 423       g_signal_new (&quot;try-pull-sample&quot;, G_TYPE_FROM_CLASS (klass),
 424       G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
 425       G_STRUCT_OFFSET (GstAppSinkClass, try_pull_sample), NULL, NULL, NULL,
 426       GST_TYPE_SAMPLE, 1, GST_TYPE_CLOCK_TIME);
 427 
 428   gst_element_class_set_static_metadata (element_class, &quot;AppSink&quot;,
 429       &quot;Generic/Sink&quot;, &quot;Allow the application to get access to raw buffer&quot;,
 430       &quot;David Schleef &lt;ds@schleef.org&gt;, Wim Taymans &lt;wim.taymans@gmail.com&gt;&quot;);
 431 
 432   gst_element_class_add_static_pad_template (element_class,
 433       &amp;gst_app_sink_template);
 434 
 435   basesink_class-&gt;unlock = gst_app_sink_unlock_start;
 436   basesink_class-&gt;unlock_stop = gst_app_sink_unlock_stop;
 437   basesink_class-&gt;start = gst_app_sink_start;
 438   basesink_class-&gt;stop = gst_app_sink_stop;
 439   basesink_class-&gt;event = gst_app_sink_event;
 440   basesink_class-&gt;preroll = gst_app_sink_preroll;
 441   basesink_class-&gt;render = gst_app_sink_render;
 442   basesink_class-&gt;render_list = gst_app_sink_render_list;
 443   basesink_class-&gt;get_caps = gst_app_sink_getcaps;
 444   basesink_class-&gt;set_caps = gst_app_sink_setcaps;
 445   basesink_class-&gt;query = gst_app_sink_query;
 446 
 447   klass-&gt;pull_preroll = gst_app_sink_pull_preroll;
 448   klass-&gt;pull_sample = gst_app_sink_pull_sample;
 449   klass-&gt;try_pull_preroll = gst_app_sink_try_pull_preroll;
 450   klass-&gt;try_pull_sample = gst_app_sink_try_pull_sample;
<a name="5" id="anc5"></a>

 451 }
 452 
 453 static void
 454 gst_app_sink_init (GstAppSink * appsink)
 455 {
 456   GstAppSinkPrivate *priv;
 457 
<a name="6" id="anc6"></a><span class="line-modified"> 458   priv = appsink-&gt;priv = gst_app_sink_get_instance_private (appsink);</span>


 459 
 460   g_mutex_init (&amp;priv-&gt;mutex);
 461   g_cond_init (&amp;priv-&gt;cond);
 462   priv-&gt;queue = gst_queue_array_new (16);
<a name="7" id="anc7"></a><span class="line-added"> 463   priv-&gt;sample = gst_sample_new (NULL, NULL, NULL, NULL);</span>
 464 
 465   priv-&gt;emit_signals = DEFAULT_PROP_EMIT_SIGNALS;
 466   priv-&gt;max_buffers = DEFAULT_PROP_MAX_BUFFERS;
 467   priv-&gt;drop = DEFAULT_PROP_DROP;
 468   priv-&gt;wait_on_eos = DEFAULT_PROP_WAIT_ON_EOS;
 469   priv-&gt;buffer_lists_supported = DEFAULT_PROP_BUFFER_LIST;
 470   priv-&gt;wait_status = NOONE_WAITING;
 471 }
 472 
 473 static void
 474 gst_app_sink_dispose (GObject * obj)
 475 {
 476   GstAppSink *appsink = GST_APP_SINK_CAST (obj);
 477   GstAppSinkPrivate *priv = appsink-&gt;priv;
 478   GstMiniObject *queue_obj;
 479 
 480   GST_OBJECT_LOCK (appsink);
 481   if (priv-&gt;caps) {
 482     gst_caps_unref (priv-&gt;caps);
 483     priv-&gt;caps = NULL;
 484   }
 485   if (priv-&gt;notify) {
 486     priv-&gt;notify (priv-&gt;user_data);
 487   }
 488   priv-&gt;user_data = NULL;
 489   priv-&gt;notify = NULL;
 490 
 491   GST_OBJECT_UNLOCK (appsink);
 492 
 493   g_mutex_lock (&amp;priv-&gt;mutex);
 494   while ((queue_obj = gst_queue_array_pop_head (priv-&gt;queue)))
 495     gst_mini_object_unref (queue_obj);
 496   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, NULL);
 497   gst_caps_replace (&amp;priv-&gt;preroll_caps, NULL);
 498   gst_caps_replace (&amp;priv-&gt;last_caps, NULL);
<a name="8" id="anc8"></a><span class="line-added"> 499   if (priv-&gt;sample) {</span>
<span class="line-added"> 500     gst_sample_unref (priv-&gt;sample);</span>
<span class="line-added"> 501     priv-&gt;sample = NULL;</span>
<span class="line-added"> 502   }</span>
 503   g_mutex_unlock (&amp;priv-&gt;mutex);
 504 
 505   G_OBJECT_CLASS (parent_class)-&gt;dispose (obj);
 506 }
 507 
 508 static void
 509 gst_app_sink_finalize (GObject * obj)
 510 {
 511   GstAppSink *appsink = GST_APP_SINK_CAST (obj);
 512   GstAppSinkPrivate *priv = appsink-&gt;priv;
 513 
 514   g_mutex_clear (&amp;priv-&gt;mutex);
 515   g_cond_clear (&amp;priv-&gt;cond);
 516   gst_queue_array_free (priv-&gt;queue);
 517 
 518   G_OBJECT_CLASS (parent_class)-&gt;finalize (obj);
 519 }
 520 
 521 static void
 522 gst_app_sink_set_property (GObject * object, guint prop_id,
 523     const GValue * value, GParamSpec * pspec)
 524 {
 525   GstAppSink *appsink = GST_APP_SINK_CAST (object);
 526 
 527   switch (prop_id) {
 528     case PROP_CAPS:
 529       gst_app_sink_set_caps (appsink, gst_value_get_caps (value));
 530       break;
 531     case PROP_EMIT_SIGNALS:
 532       gst_app_sink_set_emit_signals (appsink, g_value_get_boolean (value));
 533       break;
 534     case PROP_MAX_BUFFERS:
 535       gst_app_sink_set_max_buffers (appsink, g_value_get_uint (value));
 536       break;
 537     case PROP_DROP:
 538       gst_app_sink_set_drop (appsink, g_value_get_boolean (value));
 539       break;
 540     case PROP_BUFFER_LIST:
 541       gst_app_sink_set_buffer_list_support (appsink,
 542           g_value_get_boolean (value));
 543       break;
 544     case PROP_WAIT_ON_EOS:
 545       gst_app_sink_set_wait_on_eos (appsink, g_value_get_boolean (value));
 546       break;
 547     default:
 548       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 549       break;
 550   }
 551 }
 552 
 553 static void
 554 gst_app_sink_get_property (GObject * object, guint prop_id, GValue * value,
 555     GParamSpec * pspec)
 556 {
 557   GstAppSink *appsink = GST_APP_SINK_CAST (object);
 558 
 559   switch (prop_id) {
 560     case PROP_CAPS:
 561     {
 562       GstCaps *caps;
 563 
 564       caps = gst_app_sink_get_caps (appsink);
 565       gst_value_set_caps (value, caps);
 566       if (caps)
 567         gst_caps_unref (caps);
 568       break;
 569     }
 570     case PROP_EOS:
 571       g_value_set_boolean (value, gst_app_sink_is_eos (appsink));
 572       break;
 573     case PROP_EMIT_SIGNALS:
 574       g_value_set_boolean (value, gst_app_sink_get_emit_signals (appsink));
 575       break;
 576     case PROP_MAX_BUFFERS:
 577       g_value_set_uint (value, gst_app_sink_get_max_buffers (appsink));
 578       break;
 579     case PROP_DROP:
 580       g_value_set_boolean (value, gst_app_sink_get_drop (appsink));
 581       break;
 582     case PROP_BUFFER_LIST:
 583       g_value_set_boolean (value,
 584           gst_app_sink_get_buffer_list_support (appsink));
 585       break;
 586     case PROP_WAIT_ON_EOS:
 587       g_value_set_boolean (value, gst_app_sink_get_wait_on_eos (appsink));
 588       break;
 589     default:
 590       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 591       break;
 592   }
 593 }
 594 
 595 static gboolean
 596 gst_app_sink_unlock_start (GstBaseSink * bsink)
 597 {
 598   GstAppSink *appsink = GST_APP_SINK_CAST (bsink);
 599   GstAppSinkPrivate *priv = appsink-&gt;priv;
 600 
 601   g_mutex_lock (&amp;priv-&gt;mutex);
 602   GST_DEBUG_OBJECT (appsink, &quot;unlock start&quot;);
 603   priv-&gt;unlock = TRUE;
 604   g_cond_signal (&amp;priv-&gt;cond);
 605   g_mutex_unlock (&amp;priv-&gt;mutex);
 606 
 607   return TRUE;
 608 }
 609 
 610 static gboolean
 611 gst_app_sink_unlock_stop (GstBaseSink * bsink)
 612 {
 613   GstAppSink *appsink = GST_APP_SINK_CAST (bsink);
 614   GstAppSinkPrivate *priv = appsink-&gt;priv;
 615 
 616   g_mutex_lock (&amp;priv-&gt;mutex);
 617   GST_DEBUG_OBJECT (appsink, &quot;unlock stop&quot;);
 618   priv-&gt;unlock = FALSE;
 619   g_cond_signal (&amp;priv-&gt;cond);
 620   g_mutex_unlock (&amp;priv-&gt;mutex);
 621 
 622   return TRUE;
 623 }
 624 
 625 static void
 626 gst_app_sink_flush_unlocked (GstAppSink * appsink)
 627 {
 628   GstMiniObject *obj;
 629   GstAppSinkPrivate *priv = appsink-&gt;priv;
 630 
 631   GST_DEBUG_OBJECT (appsink, &quot;flush stop appsink&quot;);
 632   priv-&gt;is_eos = FALSE;
 633   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, NULL);
 634 #ifdef GSTREAMER_LITE
 635   // Update last_caps if we have event pending.
 636   // We can get in situation when preroll_caps and last_caps does not match
 637   // and it will break HLS playback after seek. This happens when we received
 638   // caps event (preroll_caps is updated and event stored in queue (see gst_app_sink_setcaps()))
 639   // and then flush (during seek). After, seek is done first preroll buffer will be
 640   // send with preroll_caps and all sequential buffers will be send with last_caps.
 641   while ((obj = gst_queue_array_pop_head (priv-&gt;queue))) {
 642     if (GST_IS_EVENT (obj)) {
 643       if (GST_EVENT_TYPE (obj) == GST_EVENT_CAPS) {
 644         GstCaps *caps = NULL;
 645         GstEvent *event = GST_EVENT_CAST (obj);
 646         gst_event_parse_caps (event, &amp;caps);
 647         gst_caps_replace (&amp;priv-&gt;last_caps, caps);
 648       }
 649     }
 650     gst_mini_object_unref (obj);
 651   }
 652 #else // GSTREAMER_LITE
 653   while ((obj = gst_queue_array_pop_head (priv-&gt;queue)))
 654     gst_mini_object_unref (obj);
 655 #endif // GSTREAMER_LITE
 656   priv-&gt;num_buffers = 0;
 657   g_cond_signal (&amp;priv-&gt;cond);
 658 }
 659 
 660 static gboolean
 661 gst_app_sink_start (GstBaseSink * psink)
 662 {
 663   GstAppSink *appsink = GST_APP_SINK_CAST (psink);
 664   GstAppSinkPrivate *priv = appsink-&gt;priv;
 665 
 666   g_mutex_lock (&amp;priv-&gt;mutex);
 667   GST_DEBUG_OBJECT (appsink, &quot;starting&quot;);
 668   priv-&gt;wait_status = NOONE_WAITING;
 669   priv-&gt;flushing = FALSE;
 670   priv-&gt;started = TRUE;
 671   gst_segment_init (&amp;priv-&gt;preroll_segment, GST_FORMAT_TIME);
 672   gst_segment_init (&amp;priv-&gt;last_segment, GST_FORMAT_TIME);
<a name="9" id="anc9"></a><span class="line-added"> 673   priv-&gt;sample = gst_sample_make_writable (priv-&gt;sample);</span>
<span class="line-added"> 674   gst_sample_set_buffer (priv-&gt;sample, NULL);</span>
<span class="line-added"> 675   gst_sample_set_buffer_list (priv-&gt;sample, NULL);</span>
<span class="line-added"> 676   gst_sample_set_caps (priv-&gt;sample, NULL);</span>
<span class="line-added"> 677   gst_sample_set_segment (priv-&gt;sample, NULL);</span>
 678   g_mutex_unlock (&amp;priv-&gt;mutex);
 679 
 680   return TRUE;
 681 }
 682 
 683 static gboolean
 684 gst_app_sink_stop (GstBaseSink * psink)
 685 {
 686   GstAppSink *appsink = GST_APP_SINK_CAST (psink);
 687   GstAppSinkPrivate *priv = appsink-&gt;priv;
 688 
 689   g_mutex_lock (&amp;priv-&gt;mutex);
 690   GST_DEBUG_OBJECT (appsink, &quot;stopping&quot;);
 691   priv-&gt;flushing = TRUE;
 692   priv-&gt;started = FALSE;
 693   priv-&gt;wait_status = NOONE_WAITING;
 694   gst_app_sink_flush_unlocked (appsink);
 695   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, NULL);
 696   gst_caps_replace (&amp;priv-&gt;preroll_caps, NULL);
 697   gst_caps_replace (&amp;priv-&gt;last_caps, NULL);
 698   gst_segment_init (&amp;priv-&gt;preroll_segment, GST_FORMAT_UNDEFINED);
 699   gst_segment_init (&amp;priv-&gt;last_segment, GST_FORMAT_UNDEFINED);
 700   g_mutex_unlock (&amp;priv-&gt;mutex);
 701 
 702   return TRUE;
 703 }
 704 
 705 static gboolean
 706 gst_app_sink_setcaps (GstBaseSink * sink, GstCaps * caps)
 707 {
 708   GstAppSink *appsink = GST_APP_SINK_CAST (sink);
 709   GstAppSinkPrivate *priv = appsink-&gt;priv;
 710 
 711   g_mutex_lock (&amp;priv-&gt;mutex);
 712   GST_DEBUG_OBJECT (appsink, &quot;receiving CAPS&quot;);
 713   gst_queue_array_push_tail (priv-&gt;queue, gst_event_new_caps (caps));
 714   if (!priv-&gt;preroll_buffer)
<a name="10" id="anc10"></a><span class="line-modified"> 715     gst_caps_replace (&amp;priv-&gt;preroll_caps, caps);</span>
 716   g_mutex_unlock (&amp;priv-&gt;mutex);
 717 
 718   return TRUE;
 719 }
 720 
 721 static gboolean
 722 gst_app_sink_event (GstBaseSink * sink, GstEvent * event)
 723 {
 724   GstAppSink *appsink = GST_APP_SINK_CAST (sink);
 725   GstAppSinkPrivate *priv = appsink-&gt;priv;
 726 
 727   switch (event-&gt;type) {
 728     case GST_EVENT_SEGMENT:
 729       g_mutex_lock (&amp;priv-&gt;mutex);
 730       GST_DEBUG_OBJECT (appsink, &quot;receiving SEGMENT&quot;);
 731       gst_queue_array_push_tail (priv-&gt;queue, gst_event_ref (event));
 732       if (!priv-&gt;preroll_buffer)
 733         gst_event_copy_segment (event, &amp;priv-&gt;preroll_segment);
 734       g_mutex_unlock (&amp;priv-&gt;mutex);
 735       break;
 736     case GST_EVENT_EOS:{
 737       gboolean emit = TRUE;
 738 
 739       g_mutex_lock (&amp;priv-&gt;mutex);
 740       GST_DEBUG_OBJECT (appsink, &quot;receiving EOS&quot;);
 741       priv-&gt;is_eos = TRUE;
 742       g_cond_signal (&amp;priv-&gt;cond);
 743       g_mutex_unlock (&amp;priv-&gt;mutex);
 744 
 745       g_mutex_lock (&amp;priv-&gt;mutex);
 746       /* wait until all buffers are consumed or we&#39;re flushing.
 747        * Otherwise we might signal EOS before all buffers are
 748        * consumed, which is a bit confusing for the application
 749        */
 750       while (priv-&gt;num_buffers &gt; 0 &amp;&amp; !priv-&gt;flushing &amp;&amp; priv-&gt;wait_on_eos) {
 751         if (priv-&gt;unlock) {
 752           /* we are asked to unlock, call the wait_preroll method */
 753           g_mutex_unlock (&amp;priv-&gt;mutex);
 754           if (gst_base_sink_wait_preroll (sink) != GST_FLOW_OK) {
 755             /* Directly go out of here */
 756             gst_event_unref (event);
 757             return FALSE;
 758           }
 759 
 760           /* we are allowed to continue now */
 761           g_mutex_lock (&amp;priv-&gt;mutex);
 762           continue;
 763         }
 764 
 765         priv-&gt;wait_status |= STREAM_WAITING;
 766         g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);
 767         priv-&gt;wait_status &amp;= ~STREAM_WAITING;
 768       }
 769       if (priv-&gt;flushing)
 770         emit = FALSE;
 771       g_mutex_unlock (&amp;priv-&gt;mutex);
 772 
 773       if (emit) {
<a name="11" id="anc11"></a><span class="line-modified"> 774         /* emit EOS now */</span>
<span class="line-modified"> 775         if (priv-&gt;callbacks.eos)</span>
<span class="line-modified"> 776           priv-&gt;callbacks.eos (appsink, priv-&gt;user_data);</span>
<span class="line-modified"> 777         else</span>
<span class="line-modified"> 778           g_signal_emit (appsink, gst_app_sink_signals[SIGNAL_EOS], 0);</span>
 779       }
 780 
 781       break;
 782     }
 783     case GST_EVENT_FLUSH_START:
 784       /* we don&#39;t have to do anything here, the base class will call unlock
 785        * which will make sure we exit the _render method */
 786       GST_DEBUG_OBJECT (appsink, &quot;received FLUSH_START&quot;);
 787       break;
 788     case GST_EVENT_FLUSH_STOP:
 789       g_mutex_lock (&amp;priv-&gt;mutex);
 790       GST_DEBUG_OBJECT (appsink, &quot;received FLUSH_STOP&quot;);
 791       gst_app_sink_flush_unlocked (appsink);
 792       g_mutex_unlock (&amp;priv-&gt;mutex);
 793       break;
 794     default:
 795       break;
 796   }
 797   return GST_BASE_SINK_CLASS (parent_class)-&gt;event (sink, event);
 798 }
 799 
 800 static GstFlowReturn
 801 gst_app_sink_preroll (GstBaseSink * psink, GstBuffer * buffer)
 802 {
 803   GstFlowReturn res;
 804   GstAppSink *appsink = GST_APP_SINK_CAST (psink);
 805   GstAppSinkPrivate *priv = appsink-&gt;priv;
 806   gboolean emit;
 807 
 808   g_mutex_lock (&amp;priv-&gt;mutex);
 809   if (priv-&gt;flushing)
 810     goto flushing;
 811 
 812   GST_DEBUG_OBJECT (appsink, &quot;setting preroll buffer %p&quot;, buffer);
 813   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, buffer);
 814 
 815   if ((priv-&gt;wait_status &amp; APP_WAITING))
<a name="12" id="anc12"></a><span class="line-modified"> 816     g_cond_signal (&amp;priv-&gt;cond);</span>
 817 
 818   emit = priv-&gt;emit_signals;
 819   g_mutex_unlock (&amp;priv-&gt;mutex);
 820 
 821   if (priv-&gt;callbacks.new_preroll) {
 822     res = priv-&gt;callbacks.new_preroll (appsink, priv-&gt;user_data);
 823   } else {
 824     res = GST_FLOW_OK;
 825     if (emit)
 826       g_signal_emit (appsink, gst_app_sink_signals[SIGNAL_NEW_PREROLL], 0,
 827           &amp;res);
 828   }
 829 
 830   return res;
 831 
 832 flushing:
 833   {
 834     GST_DEBUG_OBJECT (appsink, &quot;we are flushing&quot;);
 835     g_mutex_unlock (&amp;priv-&gt;mutex);
 836     return GST_FLOW_FLUSHING;
 837   }
 838 }
 839 
 840 static GstMiniObject *
 841 dequeue_buffer (GstAppSink * appsink)
 842 {
 843   GstAppSinkPrivate *priv = appsink-&gt;priv;
 844   GstMiniObject *obj;
 845 
 846   do {
 847     obj = gst_queue_array_pop_head (priv-&gt;queue);
 848 
 849     if (GST_IS_BUFFER (obj) || GST_IS_BUFFER_LIST (obj)) {
 850       GST_DEBUG_OBJECT (appsink, &quot;dequeued buffer/list %p&quot;, obj);
 851       priv-&gt;num_buffers--;
 852       break;
 853     } else if (GST_IS_EVENT (obj)) {
 854       GstEvent *event = GST_EVENT_CAST (obj);
 855 
 856       switch (GST_EVENT_TYPE (obj)) {
 857         case GST_EVENT_CAPS:
 858         {
 859           GstCaps *caps;
 860 
 861           gst_event_parse_caps (event, &amp;caps);
 862           GST_DEBUG_OBJECT (appsink, &quot;activating caps %&quot; GST_PTR_FORMAT, caps);
 863           gst_caps_replace (&amp;priv-&gt;last_caps, caps);
<a name="13" id="anc13"></a><span class="line-added"> 864           priv-&gt;sample = gst_sample_make_writable (priv-&gt;sample);</span>
<span class="line-added"> 865           gst_sample_set_caps (priv-&gt;sample, priv-&gt;last_caps);</span>
 866           break;
 867         }
 868         case GST_EVENT_SEGMENT:
 869           gst_event_copy_segment (event, &amp;priv-&gt;last_segment);
<a name="14" id="anc14"></a><span class="line-added"> 870           priv-&gt;sample = gst_sample_make_writable (priv-&gt;sample);</span>
<span class="line-added"> 871           gst_sample_set_segment (priv-&gt;sample, &amp;priv-&gt;last_segment);</span>
 872           GST_DEBUG_OBJECT (appsink, &quot;activated segment %&quot; GST_SEGMENT_FORMAT,
 873               &amp;priv-&gt;last_segment);
 874           break;
 875         default:
 876           break;
 877       }
 878       gst_mini_object_unref (obj);
 879     }
 880   } while (TRUE);
 881 
 882   return obj;
 883 }
 884 
 885 static GstFlowReturn
 886 gst_app_sink_render_common (GstBaseSink * psink, GstMiniObject * data,
 887     gboolean is_list)
 888 {
 889   GstFlowReturn ret;
 890   GstAppSink *appsink = GST_APP_SINK_CAST (psink);
 891   GstAppSinkPrivate *priv = appsink-&gt;priv;
 892   gboolean emit;
 893 
 894 restart:
 895   g_mutex_lock (&amp;priv-&gt;mutex);
 896   if (priv-&gt;flushing)
 897     goto flushing;
 898 
 899   /* queue holding caps event might have been FLUSHed,
 900    * but caps state still present in pad caps */
 901   if (G_UNLIKELY (!priv-&gt;last_caps &amp;&amp;
 902           gst_pad_has_current_caps (GST_BASE_SINK_PAD (psink)))) {
 903     priv-&gt;last_caps = gst_pad_get_current_caps (GST_BASE_SINK_PAD (psink));
<a name="15" id="anc15"></a><span class="line-added"> 904     gst_sample_set_caps (priv-&gt;sample, priv-&gt;last_caps);</span>
 905     GST_DEBUG_OBJECT (appsink, &quot;activating pad caps %&quot; GST_PTR_FORMAT,
 906         priv-&gt;last_caps);
 907   }
 908 
 909   GST_DEBUG_OBJECT (appsink, &quot;pushing render buffer/list %p on queue (%d)&quot;,
 910       data, priv-&gt;num_buffers);
 911 
 912   while (priv-&gt;max_buffers &gt; 0 &amp;&amp; priv-&gt;num_buffers &gt;= priv-&gt;max_buffers) {
 913     if (priv-&gt;drop) {
 914       GstMiniObject *old;
 915 
 916       /* we need to drop the oldest buffer/list and try again */
 917       if ((old = dequeue_buffer (appsink))) {
 918         GST_DEBUG_OBJECT (appsink, &quot;dropping old buffer/list %p&quot;, old);
 919         gst_mini_object_unref (old);
 920       }
 921     } else {
 922       GST_DEBUG_OBJECT (appsink, &quot;waiting for free space, length %d &gt;= %d&quot;,
 923           priv-&gt;num_buffers, priv-&gt;max_buffers);
 924 
 925       if (priv-&gt;unlock) {
 926         /* we are asked to unlock, call the wait_preroll method */
 927         g_mutex_unlock (&amp;priv-&gt;mutex);
 928         if ((ret = gst_base_sink_wait_preroll (psink)) != GST_FLOW_OK)
 929           goto stopping;
 930 
 931         /* we are allowed to continue now */
 932         goto restart;
 933       }
 934 
 935       /* wait for a buffer to be removed or flush */
 936       priv-&gt;wait_status |= STREAM_WAITING;
 937       g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);
 938       priv-&gt;wait_status &amp;= ~STREAM_WAITING;
 939 
 940       if (priv-&gt;flushing)
 941         goto flushing;
 942     }
 943   }
 944   /* we need to ref the buffer/list when pushing it in the queue */
 945   gst_queue_array_push_tail (priv-&gt;queue, gst_mini_object_ref (data));
 946   priv-&gt;num_buffers++;
 947 
 948   if ((priv-&gt;wait_status &amp; APP_WAITING))
<a name="16" id="anc16"></a><span class="line-modified"> 949     g_cond_signal (&amp;priv-&gt;cond);</span>
 950 
 951   emit = priv-&gt;emit_signals;
 952   g_mutex_unlock (&amp;priv-&gt;mutex);
 953 
 954   if (priv-&gt;callbacks.new_sample) {
 955     ret = priv-&gt;callbacks.new_sample (appsink, priv-&gt;user_data);
 956   } else {
 957     ret = GST_FLOW_OK;
 958     if (emit)
 959       g_signal_emit (appsink, gst_app_sink_signals[SIGNAL_NEW_SAMPLE], 0, &amp;ret);
 960   }
 961   return ret;
 962 
 963 flushing:
 964   {
 965     GST_DEBUG_OBJECT (appsink, &quot;we are flushing&quot;);
 966     g_mutex_unlock (&amp;priv-&gt;mutex);
 967     return GST_FLOW_FLUSHING;
 968   }
 969 stopping:
 970   {
 971     GST_DEBUG_OBJECT (appsink, &quot;we are stopping&quot;);
 972     return ret;
 973   }
 974 }
 975 
 976 static GstFlowReturn
 977 gst_app_sink_render (GstBaseSink * psink, GstBuffer * buffer)
 978 {
 979   return gst_app_sink_render_common (psink, GST_MINI_OBJECT_CAST (buffer),
 980       FALSE);
 981 }
 982 
 983 static GstFlowReturn
 984 gst_app_sink_render_list (GstBaseSink * sink, GstBufferList * list)
 985 {
 986   GstFlowReturn flow;
 987   GstAppSink *appsink;
 988   GstBuffer *buffer;
 989   guint i, len;
 990 
 991   appsink = GST_APP_SINK_CAST (sink);
 992 
 993   if (appsink-&gt;priv-&gt;buffer_lists_supported)
 994     return gst_app_sink_render_common (sink, GST_MINI_OBJECT_CAST (list), TRUE);
 995 
 996   /* The application doesn&#39;t support buffer lists, extract individual buffers
 997    * then and push them one-by-one */
 998   GST_INFO_OBJECT (sink, &quot;chaining each group in list as a merged buffer&quot;);
 999 
1000   len = gst_buffer_list_length (list);
1001 
1002   flow = GST_FLOW_OK;
1003   for (i = 0; i &lt; len; i++) {
1004     buffer = gst_buffer_list_get (list, i);
1005     flow = gst_app_sink_render (sink, buffer);
1006     if (flow != GST_FLOW_OK)
1007       break;
1008   }
1009 
1010   return flow;
1011 }
1012 
1013 static GstCaps *
1014 gst_app_sink_getcaps (GstBaseSink * psink, GstCaps * filter)
1015 {
1016   GstCaps *caps;
1017   GstAppSink *appsink = GST_APP_SINK_CAST (psink);
1018   GstAppSinkPrivate *priv = appsink-&gt;priv;
1019 
1020   GST_OBJECT_LOCK (appsink);
1021   if ((caps = priv-&gt;caps)) {
1022     if (filter)
1023       caps = gst_caps_intersect_full (filter, caps, GST_CAPS_INTERSECT_FIRST);
1024     else
1025       gst_caps_ref (caps);
1026   }
1027   GST_DEBUG_OBJECT (appsink, &quot;got caps %&quot; GST_PTR_FORMAT, caps);
1028   GST_OBJECT_UNLOCK (appsink);
1029 
1030   return caps;
1031 }
1032 
1033 static gboolean
1034 gst_app_sink_query (GstBaseSink * bsink, GstQuery * query)
1035 {
1036   GstAppSink *appsink = GST_APP_SINK_CAST (bsink);
1037   GstAppSinkPrivate *priv = appsink-&gt;priv;
1038   gboolean ret;
1039 
1040   switch (GST_QUERY_TYPE (query)) {
1041     case GST_QUERY_DRAIN:
1042     {
1043       g_mutex_lock (&amp;priv-&gt;mutex);
1044       GST_DEBUG_OBJECT (appsink, &quot;waiting buffers to be consumed&quot;);
1045       while (priv-&gt;num_buffers &gt; 0 || priv-&gt;preroll_buffer) {
1046         if (priv-&gt;unlock) {
1047           /* we are asked to unlock, call the wait_preroll method */
1048           g_mutex_unlock (&amp;priv-&gt;mutex);
1049           if (gst_base_sink_wait_preroll (bsink) != GST_FLOW_OK) {
1050             /* Directly go out of here */
1051             return FALSE;
1052           }
1053 
1054           /* we are allowed to continue now */
1055           g_mutex_lock (&amp;priv-&gt;mutex);
1056           continue;
1057         }
1058 
1059         priv-&gt;wait_status |= STREAM_WAITING;
1060         g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);
1061         priv-&gt;wait_status &amp;= ~STREAM_WAITING;
1062 
1063         if (priv-&gt;flushing)
1064           break;
1065       }
1066       g_mutex_unlock (&amp;priv-&gt;mutex);
1067       ret = GST_BASE_SINK_CLASS (parent_class)-&gt;query (bsink, query);
1068       break;
1069     }
1070     case GST_QUERY_SEEKING:{
1071       GstFormat fmt;
1072 
1073       /* we don&#39;t supporting seeking */
1074       gst_query_parse_seeking (query, &amp;fmt, NULL, NULL, NULL);
1075       gst_query_set_seeking (query, fmt, FALSE, 0, -1);
1076       ret = TRUE;
1077       break;
1078     }
1079 
1080     default:
1081       ret = GST_BASE_SINK_CLASS (parent_class)-&gt;query (bsink, query);
1082       break;
1083   }
1084 
1085   return ret;
1086 }
1087 
1088 /* external API */
1089 
1090 /**
1091  * gst_app_sink_set_caps:
1092  * @appsink: a #GstAppSink
1093  * @caps: caps to set
1094  *
1095  * Set the capabilities on the appsink element.  This function takes
1096  * a copy of the caps structure. After calling this method, the sink will only
1097  * accept caps that match @caps. If @caps is non-fixed, or incomplete,
1098  * you must check the caps on the samples to get the actual used caps.
1099  */
1100 void
1101 gst_app_sink_set_caps (GstAppSink * appsink, const GstCaps * caps)
1102 {
1103   GstCaps *old;
1104   GstAppSinkPrivate *priv;
1105 
1106   g_return_if_fail (GST_IS_APP_SINK (appsink));
1107 
1108   priv = appsink-&gt;priv;
1109 
1110   GST_OBJECT_LOCK (appsink);
1111   GST_DEBUG_OBJECT (appsink, &quot;setting caps to %&quot; GST_PTR_FORMAT, caps);
1112   if ((old = priv-&gt;caps) != caps) {
1113     if (caps)
1114       priv-&gt;caps = gst_caps_copy (caps);
1115     else
1116       priv-&gt;caps = NULL;
1117     if (old)
1118       gst_caps_unref (old);
1119   }
1120   GST_OBJECT_UNLOCK (appsink);
1121 }
1122 
1123 /**
1124  * gst_app_sink_get_caps:
1125  * @appsink: a #GstAppSink
1126  *
1127  * Get the configured caps on @appsink.
1128  *
1129  * Returns: the #GstCaps accepted by the sink. gst_caps_unref() after usage.
1130  */
1131 GstCaps *
1132 gst_app_sink_get_caps (GstAppSink * appsink)
1133 {
1134   GstCaps *caps;
1135   GstAppSinkPrivate *priv;
1136 
1137   g_return_val_if_fail (GST_IS_APP_SINK (appsink), NULL);
1138 
1139   priv = appsink-&gt;priv;
1140 
1141   GST_OBJECT_LOCK (appsink);
1142   if ((caps = priv-&gt;caps))
1143     gst_caps_ref (caps);
1144   GST_DEBUG_OBJECT (appsink, &quot;getting caps of %&quot; GST_PTR_FORMAT, caps);
1145   GST_OBJECT_UNLOCK (appsink);
1146 
1147   return caps;
1148 }
1149 
1150 /**
1151  * gst_app_sink_is_eos:
1152  * @appsink: a #GstAppSink
1153  *
1154  * Check if @appsink is EOS, which is when no more samples can be pulled because
1155  * an EOS event was received.
1156  *
1157  * This function also returns %TRUE when the appsink is not in the PAUSED or
1158  * PLAYING state.
1159  *
1160  * Returns: %TRUE if no more samples can be pulled and the appsink is EOS.
1161  */
1162 gboolean
1163 gst_app_sink_is_eos (GstAppSink * appsink)
1164 {
1165   gboolean ret;
1166   GstAppSinkPrivate *priv;
1167 
1168   g_return_val_if_fail (GST_IS_APP_SINK (appsink), FALSE);
1169 
1170   priv = appsink-&gt;priv;
1171 
1172   g_mutex_lock (&amp;priv-&gt;mutex);
1173   if (!priv-&gt;started)
1174     goto not_started;
1175 
1176   if (priv-&gt;is_eos &amp;&amp; priv-&gt;num_buffers == 0) {
1177     GST_DEBUG_OBJECT (appsink, &quot;we are EOS and the queue is empty&quot;);
1178     ret = TRUE;
1179   } else {
1180     GST_DEBUG_OBJECT (appsink, &quot;we are not yet EOS&quot;);
1181     ret = FALSE;
1182   }
1183   g_mutex_unlock (&amp;priv-&gt;mutex);
1184 
1185   return ret;
1186 
1187 not_started:
1188   {
1189     GST_DEBUG_OBJECT (appsink, &quot;we are stopped, return TRUE&quot;);
1190     g_mutex_unlock (&amp;priv-&gt;mutex);
1191     return TRUE;
1192   }
1193 }
1194 
1195 /**
1196  * gst_app_sink_set_emit_signals:
1197  * @appsink: a #GstAppSink
1198  * @emit: the new state
1199  *
1200  * Make appsink emit the &quot;new-preroll&quot; and &quot;new-sample&quot; signals. This option is
1201  * by default disabled because signal emission is expensive and unneeded when
1202  * the application prefers to operate in pull mode.
1203  */
1204 void
1205 gst_app_sink_set_emit_signals (GstAppSink * appsink, gboolean emit)
1206 {
1207   GstAppSinkPrivate *priv;
1208 
1209   g_return_if_fail (GST_IS_APP_SINK (appsink));
1210 
1211   priv = appsink-&gt;priv;
1212 
1213   g_mutex_lock (&amp;priv-&gt;mutex);
1214   priv-&gt;emit_signals = emit;
1215   g_mutex_unlock (&amp;priv-&gt;mutex);
1216 }
1217 
1218 /**
1219  * gst_app_sink_get_emit_signals:
1220  * @appsink: a #GstAppSink
1221  *
1222  * Check if appsink will emit the &quot;new-preroll&quot; and &quot;new-sample&quot; signals.
1223  *
1224  * Returns: %TRUE if @appsink is emiting the &quot;new-preroll&quot; and &quot;new-sample&quot;
1225  * signals.
1226  */
1227 gboolean
1228 gst_app_sink_get_emit_signals (GstAppSink * appsink)
1229 {
1230   gboolean result;
1231   GstAppSinkPrivate *priv;
1232 
1233   g_return_val_if_fail (GST_IS_APP_SINK (appsink), FALSE);
1234 
1235   priv = appsink-&gt;priv;
1236 
1237   g_mutex_lock (&amp;priv-&gt;mutex);
1238   result = priv-&gt;emit_signals;
1239   g_mutex_unlock (&amp;priv-&gt;mutex);
1240 
1241   return result;
1242 }
1243 
1244 /**
1245  * gst_app_sink_set_max_buffers:
1246  * @appsink: a #GstAppSink
1247  * @max: the maximum number of buffers to queue
1248  *
1249  * Set the maximum amount of buffers that can be queued in @appsink. After this
1250  * amount of buffers are queued in appsink, any more buffers will block upstream
1251  * elements until a sample is pulled from @appsink.
1252  */
1253 void
1254 gst_app_sink_set_max_buffers (GstAppSink * appsink, guint max)
1255 {
1256   GstAppSinkPrivate *priv;
1257 
1258   g_return_if_fail (GST_IS_APP_SINK (appsink));
1259 
1260   priv = appsink-&gt;priv;
1261 
1262   g_mutex_lock (&amp;priv-&gt;mutex);
1263   if (max != priv-&gt;max_buffers) {
1264     priv-&gt;max_buffers = max;
1265     /* signal the change */
1266     g_cond_signal (&amp;priv-&gt;cond);
1267   }
1268   g_mutex_unlock (&amp;priv-&gt;mutex);
1269 }
1270 
1271 /**
1272  * gst_app_sink_get_max_buffers:
1273  * @appsink: a #GstAppSink
1274  *
1275  * Get the maximum amount of buffers that can be queued in @appsink.
1276  *
1277  * Returns: The maximum amount of buffers that can be queued.
1278  */
1279 guint
1280 gst_app_sink_get_max_buffers (GstAppSink * appsink)
1281 {
1282   guint result;
1283   GstAppSinkPrivate *priv;
1284 
1285   g_return_val_if_fail (GST_IS_APP_SINK (appsink), 0);
1286 
1287   priv = appsink-&gt;priv;
1288 
1289   g_mutex_lock (&amp;priv-&gt;mutex);
1290   result = priv-&gt;max_buffers;
1291   g_mutex_unlock (&amp;priv-&gt;mutex);
1292 
1293   return result;
1294 }
1295 
1296 /**
1297  * gst_app_sink_set_drop:
1298  * @appsink: a #GstAppSink
1299  * @drop: the new state
1300  *
1301  * Instruct @appsink to drop old buffers when the maximum amount of queued
1302  * buffers is reached.
1303  */
1304 void
1305 gst_app_sink_set_drop (GstAppSink * appsink, gboolean drop)
1306 {
1307   GstAppSinkPrivate *priv;
1308 
1309   g_return_if_fail (GST_IS_APP_SINK (appsink));
1310 
1311   priv = appsink-&gt;priv;
1312 
1313   g_mutex_lock (&amp;priv-&gt;mutex);
1314   if (priv-&gt;drop != drop) {
1315     priv-&gt;drop = drop;
1316     /* signal the change */
1317     g_cond_signal (&amp;priv-&gt;cond);
1318   }
1319   g_mutex_unlock (&amp;priv-&gt;mutex);
1320 }
1321 
1322 /**
1323  * gst_app_sink_get_drop:
1324  * @appsink: a #GstAppSink
1325  *
1326  * Check if @appsink will drop old buffers when the maximum amount of queued
1327  * buffers is reached.
1328  *
1329  * Returns: %TRUE if @appsink is dropping old buffers when the queue is
1330  * filled.
1331  */
1332 gboolean
1333 gst_app_sink_get_drop (GstAppSink * appsink)
1334 {
1335   gboolean result;
1336   GstAppSinkPrivate *priv;
1337 
1338   g_return_val_if_fail (GST_IS_APP_SINK (appsink), FALSE);
1339 
1340   priv = appsink-&gt;priv;
1341 
1342   g_mutex_lock (&amp;priv-&gt;mutex);
1343   result = priv-&gt;drop;
1344   g_mutex_unlock (&amp;priv-&gt;mutex);
1345 
1346   return result;
1347 }
1348 
1349 /**
1350  * gst_app_sink_set_buffer_list_support:
1351  * @appsink: a #GstAppSink
1352  * @enable_lists: enable or disable buffer list support
1353  *
1354  * Instruct @appsink to enable or disable buffer list support.
1355  *
1356  * For backwards-compatibility reasons applications need to opt in
1357  * to indicate that they will be able to handle buffer lists.
1358  *
1359  * Since: 1.12
1360  */
1361 void
1362 gst_app_sink_set_buffer_list_support (GstAppSink * appsink,
1363     gboolean enable_lists)
1364 {
1365   GstAppSinkPrivate *priv;
1366 
1367   g_return_if_fail (GST_IS_APP_SINK (appsink));
1368 
1369   priv = appsink-&gt;priv;
1370 
1371   g_mutex_lock (&amp;priv-&gt;mutex);
1372   if (priv-&gt;buffer_lists_supported != enable_lists) {
1373     priv-&gt;buffer_lists_supported = enable_lists;
1374   }
1375   g_mutex_unlock (&amp;priv-&gt;mutex);
1376 }
1377 
1378 /**
1379  * gst_app_sink_get_buffer_list_support:
1380  * @appsink: a #GstAppSink
1381  *
1382  * Check if @appsink supports buffer lists.
1383  *
1384  * Returns: %TRUE if @appsink supports buffer lists.
1385  *
1386  * Since: 1.12
1387  */
1388 gboolean
1389 gst_app_sink_get_buffer_list_support (GstAppSink * appsink)
1390 {
1391   gboolean result;
1392   GstAppSinkPrivate *priv;
1393 
1394   g_return_val_if_fail (GST_IS_APP_SINK (appsink), FALSE);
1395 
1396   priv = appsink-&gt;priv;
1397 
1398   g_mutex_lock (&amp;priv-&gt;mutex);
1399   result = priv-&gt;buffer_lists_supported;
1400   g_mutex_unlock (&amp;priv-&gt;mutex);
1401 
1402   return result;
1403 }
1404 
1405 /**
1406  * gst_app_sink_set_wait_on_eos:
1407  * @appsink: a #GstAppSink
1408  * @wait: the new state
1409  *
1410  * Instruct @appsink to wait for all buffers to be consumed when an EOS is received.
1411  *
1412  */
1413 void
1414 gst_app_sink_set_wait_on_eos (GstAppSink * appsink, gboolean wait)
1415 {
1416   GstAppSinkPrivate *priv;
1417 
1418   g_return_if_fail (GST_IS_APP_SINK (appsink));
1419 
1420   priv = appsink-&gt;priv;
1421 
1422   g_mutex_lock (&amp;priv-&gt;mutex);
1423   if (priv-&gt;wait_on_eos != wait) {
1424     priv-&gt;wait_on_eos = wait;
1425     /* signal the change */
1426     g_cond_signal (&amp;priv-&gt;cond);
1427   }
1428   g_mutex_unlock (&amp;priv-&gt;mutex);
1429 }
1430 
1431 /**
1432  * gst_app_sink_get_wait_on_eos:
1433  * @appsink: a #GstAppSink
1434  *
1435  * Check if @appsink will wait for all buffers to be consumed when an EOS is
1436  * received.
1437  *
1438  * Returns: %TRUE if @appsink will wait for all buffers to be consumed when an
1439  * EOS is received.
1440  */
1441 gboolean
1442 gst_app_sink_get_wait_on_eos (GstAppSink * appsink)
1443 {
1444   gboolean result;
1445   GstAppSinkPrivate *priv;
1446 
1447   g_return_val_if_fail (GST_IS_APP_SINK (appsink), FALSE);
1448 
1449   priv = appsink-&gt;priv;
1450 
1451   g_mutex_lock (&amp;priv-&gt;mutex);
1452   result = priv-&gt;wait_on_eos;
1453   g_mutex_unlock (&amp;priv-&gt;mutex);
1454 
1455   return result;
1456 }
1457 
1458 /**
1459  * gst_app_sink_pull_preroll:
1460  * @appsink: a #GstAppSink
1461  *
1462  * Get the last preroll sample in @appsink. This was the sample that caused the
1463  * appsink to preroll in the PAUSED state.
1464  *
1465  * This function is typically used when dealing with a pipeline in the PAUSED
1466  * state. Calling this function after doing a seek will give the sample right
1467  * after the seek position.
1468  *
1469  * Calling this function will clear the internal reference to the preroll
1470  * buffer.
1471  *
1472  * Note that the preroll sample will also be returned as the first sample
1473  * when calling gst_app_sink_pull_sample().
1474  *
1475  * If an EOS event was received before any buffers, this function returns
1476  * %NULL. Use gst_app_sink_is_eos () to check for the EOS condition.
1477  *
1478  * This function blocks until a preroll sample or EOS is received or the appsink
1479  * element is set to the READY/NULL state.
1480  *
1481  * Returns: (transfer full): a #GstSample or NULL when the appsink is stopped or EOS.
1482  *          Call gst_sample_unref() after usage.
1483  */
1484 GstSample *
1485 gst_app_sink_pull_preroll (GstAppSink * appsink)
1486 {
1487   return gst_app_sink_try_pull_preroll (appsink, GST_CLOCK_TIME_NONE);
1488 }
1489 
1490 /**
1491  * gst_app_sink_pull_sample:
1492  * @appsink: a #GstAppSink
1493  *
1494  * This function blocks until a sample or EOS becomes available or the appsink
1495  * element is set to the READY/NULL state.
1496  *
1497  * This function will only return samples when the appsink is in the PLAYING
1498  * state. All rendered buffers will be put in a queue so that the application
1499  * can pull samples at its own rate. Note that when the application does not
1500  * pull samples fast enough, the queued buffers could consume a lot of memory,
1501  * especially when dealing with raw video frames.
1502  *
1503  * If an EOS event was received before any buffers, this function returns
1504  * %NULL. Use gst_app_sink_is_eos () to check for the EOS condition.
1505  *
1506  * Returns: (transfer full): a #GstSample or NULL when the appsink is stopped or EOS.
1507  *          Call gst_sample_unref() after usage.
1508  */
1509 GstSample *
1510 gst_app_sink_pull_sample (GstAppSink * appsink)
1511 {
1512   return gst_app_sink_try_pull_sample (appsink, GST_CLOCK_TIME_NONE);
1513 }
1514 
1515 /**
1516  * gst_app_sink_try_pull_preroll:
1517  * @appsink: a #GstAppSink
1518  * @timeout: the maximum amount of time to wait for the preroll sample
1519  *
1520  * Get the last preroll sample in @appsink. This was the sample that caused the
1521  * appsink to preroll in the PAUSED state.
1522  *
1523  * This function is typically used when dealing with a pipeline in the PAUSED
1524  * state. Calling this function after doing a seek will give the sample right
1525  * after the seek position.
1526  *
1527  * Calling this function will clear the internal reference to the preroll
1528  * buffer.
1529  *
1530  * Note that the preroll sample will also be returned as the first sample
1531  * when calling gst_app_sink_pull_sample().
1532  *
1533  * If an EOS event was received before any buffers or the timeout expires,
1534  * this function returns %NULL. Use gst_app_sink_is_eos () to check for the EOS
1535  * condition.
1536  *
1537  * This function blocks until a preroll sample or EOS is received, the appsink
1538  * element is set to the READY/NULL state, or the timeout expires.
1539  *
1540  * Returns: (transfer full): a #GstSample or NULL when the appsink is stopped or EOS or the timeout expires.
1541  *          Call gst_sample_unref() after usage.
1542  *
1543  * Since: 1.10
1544  */
1545 GstSample *
1546 gst_app_sink_try_pull_preroll (GstAppSink * appsink, GstClockTime timeout)
1547 {
1548   GstAppSinkPrivate *priv;
1549   GstSample *sample = NULL;
1550   gboolean timeout_valid;
1551   gint64 end_time;
1552 
1553   g_return_val_if_fail (GST_IS_APP_SINK (appsink), NULL);
1554 
1555   priv = appsink-&gt;priv;
1556 
1557   timeout_valid = GST_CLOCK_TIME_IS_VALID (timeout);
1558 
1559   if (timeout_valid)
1560     end_time =
1561         g_get_monotonic_time () + timeout / (GST_SECOND / G_TIME_SPAN_SECOND);
1562 
1563   g_mutex_lock (&amp;priv-&gt;mutex);
1564 
1565   while (TRUE) {
1566     GST_DEBUG_OBJECT (appsink, &quot;trying to grab a buffer&quot;);
1567     if (!priv-&gt;started)
1568       goto not_started;
1569 
1570     if (priv-&gt;preroll_buffer != NULL)
1571       break;
1572 
1573     if (priv-&gt;is_eos)
1574       goto eos;
1575 
1576     /* nothing to return, wait */
1577     GST_DEBUG_OBJECT (appsink, &quot;waiting for the preroll buffer&quot;);
1578     priv-&gt;wait_status |= APP_WAITING;
1579     if (timeout_valid) {
1580       if (!g_cond_wait_until (&amp;priv-&gt;cond, &amp;priv-&gt;mutex, end_time))
1581         goto expired;
1582     } else {
<a name="17" id="anc17"></a><span class="line-modified">1583       g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);</span>
<span class="line-modified">1584     }</span>
1585     priv-&gt;wait_status &amp;= ~APP_WAITING;
1586   }
1587   sample =
1588       gst_sample_new (priv-&gt;preroll_buffer, priv-&gt;preroll_caps,
1589       &amp;priv-&gt;preroll_segment, NULL);
1590   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, NULL);
1591   GST_DEBUG_OBJECT (appsink, &quot;we have the preroll sample %p&quot;, sample);
1592   g_mutex_unlock (&amp;priv-&gt;mutex);
1593 
1594   return sample;
1595 
1596   /* special conditions */
1597 expired:
1598   {
1599     GST_DEBUG_OBJECT (appsink, &quot;timeout expired, return NULL&quot;);
1600     priv-&gt;wait_status &amp;= ~APP_WAITING;
1601     g_mutex_unlock (&amp;priv-&gt;mutex);
1602     return NULL;
1603   }
1604 eos:
1605   {
1606     GST_DEBUG_OBJECT (appsink, &quot;we are EOS, return NULL&quot;);
1607     g_mutex_unlock (&amp;priv-&gt;mutex);
1608     return NULL;
1609   }
1610 not_started:
1611   {
1612     GST_DEBUG_OBJECT (appsink, &quot;we are stopped, return NULL&quot;);
1613     g_mutex_unlock (&amp;priv-&gt;mutex);
1614     return NULL;
1615   }
1616 }
1617 
1618 /**
1619  * gst_app_sink_try_pull_sample:
1620  * @appsink: a #GstAppSink
1621  * @timeout: the maximum amount of time to wait for a sample
1622  *
1623  * This function blocks until a sample or EOS becomes available or the appsink
1624  * element is set to the READY/NULL state or the timeout expires.
1625  *
1626  * This function will only return samples when the appsink is in the PLAYING
1627  * state. All rendered buffers will be put in a queue so that the application
1628  * can pull samples at its own rate. Note that when the application does not
1629  * pull samples fast enough, the queued buffers could consume a lot of memory,
1630  * especially when dealing with raw video frames.
1631  *
1632  * If an EOS event was received before any buffers or the timeout expires,
1633  * this function returns %NULL. Use gst_app_sink_is_eos () to check for the EOS
1634  * condition.
1635  *
1636  * Returns: (transfer full): a #GstSample or NULL when the appsink is stopped or EOS or the timeout expires.
1637  * Call gst_sample_unref() after usage.
1638  *
1639  * Since: 1.10
1640  */
1641 GstSample *
1642 gst_app_sink_try_pull_sample (GstAppSink * appsink, GstClockTime timeout)
1643 {
1644   GstAppSinkPrivate *priv;
1645   GstSample *sample = NULL;
1646   GstMiniObject *obj;
1647   gboolean timeout_valid;
1648   gint64 end_time;
1649 
1650   g_return_val_if_fail (GST_IS_APP_SINK (appsink), NULL);
1651 
1652   timeout_valid = GST_CLOCK_TIME_IS_VALID (timeout);
1653 
1654   if (timeout_valid)
1655     end_time =
1656         g_get_monotonic_time () + timeout / (GST_SECOND / G_TIME_SPAN_SECOND);
1657 
1658   priv = appsink-&gt;priv;
1659 
1660   g_mutex_lock (&amp;priv-&gt;mutex);
1661   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, NULL);
1662 
1663   while (TRUE) {
1664     GST_DEBUG_OBJECT (appsink, &quot;trying to grab a buffer&quot;);
1665     if (!priv-&gt;started)
1666       goto not_started;
1667 
1668     if (priv-&gt;num_buffers &gt; 0)
1669       break;
1670 
1671     if (priv-&gt;is_eos)
1672       goto eos;
1673 
1674     /* nothing to return, wait */
1675     GST_DEBUG_OBJECT (appsink, &quot;waiting for a buffer&quot;);
1676     priv-&gt;wait_status |= APP_WAITING;
1677     if (timeout_valid) {
1678       if (!g_cond_wait_until (&amp;priv-&gt;cond, &amp;priv-&gt;mutex, end_time))
1679         goto expired;
1680     } else {
<a name="18" id="anc18"></a><span class="line-modified">1681       g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);</span>
<span class="line-modified">1682     }</span>
1683     priv-&gt;wait_status &amp;= ~APP_WAITING;
1684   }
1685 
1686   obj = dequeue_buffer (appsink);
1687   if (GST_IS_BUFFER (obj)) {
1688     GST_DEBUG_OBJECT (appsink, &quot;we have a buffer %p&quot;, obj);
<a name="19" id="anc19"></a><span class="line-modified">1689     priv-&gt;sample = gst_sample_make_writable (priv-&gt;sample);</span>
<span class="line-modified">1690     gst_sample_set_buffer_list (priv-&gt;sample, NULL);</span>
<span class="line-added">1691     gst_sample_set_buffer (priv-&gt;sample, GST_BUFFER_CAST (obj));</span>
<span class="line-added">1692     sample = gst_sample_ref (priv-&gt;sample);</span>
1693   } else {
1694     GST_DEBUG_OBJECT (appsink, &quot;we have a list %p&quot;, obj);
<a name="20" id="anc20"></a><span class="line-modified">1695     priv-&gt;sample = gst_sample_make_writable (priv-&gt;sample);</span>
<span class="line-modified">1696     gst_sample_set_buffer (priv-&gt;sample, NULL);</span>
<span class="line-added">1697     gst_sample_set_buffer_list (priv-&gt;sample, GST_BUFFER_LIST_CAST (obj));</span>
<span class="line-added">1698     sample = gst_sample_ref (priv-&gt;sample);</span>
1699   }
1700   gst_mini_object_unref (obj);
1701 
1702   if ((priv-&gt;wait_status &amp; STREAM_WAITING))
<a name="21" id="anc21"></a><span class="line-modified">1703     g_cond_signal (&amp;priv-&gt;cond);</span>
1704 
1705   g_mutex_unlock (&amp;priv-&gt;mutex);
1706 
1707   return sample;
1708 
1709   /* special conditions */
1710 expired:
1711   {
1712     GST_DEBUG_OBJECT (appsink, &quot;timeout expired, return NULL&quot;);
1713     priv-&gt;wait_status &amp;= ~APP_WAITING;
1714     g_mutex_unlock (&amp;priv-&gt;mutex);
1715     return NULL;
1716   }
1717 eos:
1718   {
1719     GST_DEBUG_OBJECT (appsink, &quot;we are EOS, return NULL&quot;);
1720     g_mutex_unlock (&amp;priv-&gt;mutex);
1721     return NULL;
1722   }
1723 not_started:
1724   {
1725     GST_DEBUG_OBJECT (appsink, &quot;we are stopped, return NULL&quot;);
1726     g_mutex_unlock (&amp;priv-&gt;mutex);
1727     return NULL;
1728   }
1729 }
1730 
1731 /**
1732  * gst_app_sink_set_callbacks: (skip)
1733  * @appsink: a #GstAppSink
1734  * @callbacks: the callbacks
1735  * @user_data: a user_data argument for the callbacks
1736  * @notify: a destroy notify function
1737  *
1738  * Set callbacks which will be executed for each new preroll, new sample and eos.
1739  * This is an alternative to using the signals, it has lower overhead and is thus
1740  * less expensive, but also less flexible.
1741  *
1742  * If callbacks are installed, no signals will be emitted for performance
1743  * reasons.
1744  */
1745 void
1746 gst_app_sink_set_callbacks (GstAppSink * appsink,
1747     GstAppSinkCallbacks * callbacks, gpointer user_data, GDestroyNotify notify)
1748 {
1749   GDestroyNotify old_notify;
1750   GstAppSinkPrivate *priv;
1751 
1752   g_return_if_fail (GST_IS_APP_SINK (appsink));
1753   g_return_if_fail (callbacks != NULL);
1754 
1755   priv = appsink-&gt;priv;
1756 
1757   GST_OBJECT_LOCK (appsink);
1758   old_notify = priv-&gt;notify;
1759 
1760   if (old_notify) {
1761     gpointer old_data;
1762 
1763     old_data = priv-&gt;user_data;
1764 
1765     priv-&gt;user_data = NULL;
1766     priv-&gt;notify = NULL;
1767     GST_OBJECT_UNLOCK (appsink);
1768 
1769     old_notify (old_data);
1770 
1771     GST_OBJECT_LOCK (appsink);
1772   }
1773   priv-&gt;callbacks = *callbacks;
1774   priv-&gt;user_data = user_data;
1775   priv-&gt;notify = notify;
1776   GST_OBJECT_UNLOCK (appsink);
1777 }
1778 
1779 /*** GSTURIHANDLER INTERFACE *************************************************/
1780 
1781 static GstURIType
1782 gst_app_sink_uri_get_type (GType type)
1783 {
1784   return GST_URI_SINK;
1785 }
1786 
1787 static const gchar *const *
1788 gst_app_sink_uri_get_protocols (GType type)
1789 {
1790   static const gchar *protocols[] = { &quot;appsink&quot;, NULL };
1791 
1792   return protocols;
1793 }
1794 
1795 static gchar *
1796 gst_app_sink_uri_get_uri (GstURIHandler * handler)
1797 {
1798   return g_strdup (&quot;appsink&quot;);
1799 }
1800 
1801 static gboolean
1802 gst_app_sink_uri_set_uri (GstURIHandler * handler, const gchar * uri,
1803     GError ** error)
1804 {
1805   /* GstURIHandler checks the protocol for us */
1806   return TRUE;
1807 }
1808 
1809 static void
1810 gst_app_sink_uri_handler_init (gpointer g_iface, gpointer iface_data)
1811 {
1812   GstURIHandlerInterface *iface = (GstURIHandlerInterface *) g_iface;
1813 
1814   iface-&gt;get_type = gst_app_sink_uri_get_type;
1815   iface-&gt;get_protocols = gst_app_sink_uri_get_protocols;
1816   iface-&gt;get_uri = gst_app_sink_uri_get_uri;
1817   iface-&gt;set_uri = gst_app_sink_uri_set_uri;
1818 
1819 }
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>