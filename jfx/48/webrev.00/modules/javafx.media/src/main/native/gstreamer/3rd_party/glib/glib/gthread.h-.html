<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gthread.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /* GLIB - Library of useful routines for C programming
  2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Lesser General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2.1 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful, but
 10  * WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Lesser General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Lesser General Public
 15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 16  */
 17 
 18 /*
 19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
 20  * file for a list of people on the GLib Team.  See the ChangeLog
 21  * files for a list of changes.  These files are distributed with
 22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
 23  */
 24 
 25 #ifndef __G_THREAD_H__
 26 #define __G_THREAD_H__
 27 
 28 #if !defined (__GLIB_H_INSIDE__) &amp;&amp; !defined (GLIB_COMPILATION)
 29 #error &quot;Only &lt;glib.h&gt; can be included directly.&quot;
 30 #endif
 31 
 32 #include &lt;glib/gatomic.h&gt;
 33 #include &lt;glib/gerror.h&gt;
 34 #include &lt;glib/gutils.h&gt;
 35 
 36 G_BEGIN_DECLS
 37 
 38 #define G_THREAD_ERROR g_thread_error_quark ()
 39 GLIB_AVAILABLE_IN_ALL
 40 GQuark g_thread_error_quark (void);
 41 
 42 typedef enum
 43 {
 44   G_THREAD_ERROR_AGAIN /* Resource temporarily unavailable */
 45 } GThreadError;
 46 
 47 typedef gpointer (*GThreadFunc) (gpointer data);
 48 
 49 typedef struct _GThread         GThread;
 50 
 51 typedef union  _GMutex          GMutex;
 52 typedef struct _GRecMutex       GRecMutex;
 53 typedef struct _GRWLock         GRWLock;
 54 typedef struct _GCond           GCond;
 55 typedef struct _GPrivate        GPrivate;
 56 typedef struct _GOnce           GOnce;
 57 
 58 union _GMutex
 59 {
 60   /*&lt; private &gt;*/
 61   gpointer p;
 62   guint i[2];
 63 };
 64 
 65 struct _GRWLock
 66 {
 67   /*&lt; private &gt;*/
 68   gpointer p;
 69   guint i[2];
 70 };
 71 
 72 struct _GCond
 73 {
 74   /*&lt; private &gt;*/
 75   gpointer p;
 76   guint i[2];
 77 };
 78 
 79 struct _GRecMutex
 80 {
 81   /*&lt; private &gt;*/
 82   gpointer p;
 83   guint i[2];
 84 };
 85 
 86 #define G_PRIVATE_INIT(notify) { NULL, (notify), { NULL, NULL } }
 87 struct _GPrivate
 88 {
 89   /*&lt; private &gt;*/
 90   gpointer       p;
 91   GDestroyNotify notify;
 92   gpointer future[2];
 93 };
 94 
 95 typedef enum
 96 {
 97   G_ONCE_STATUS_NOTCALLED,
 98   G_ONCE_STATUS_PROGRESS,
 99   G_ONCE_STATUS_READY
100 } GOnceStatus;
101 
102 #define G_ONCE_INIT { G_ONCE_STATUS_NOTCALLED, NULL }
103 struct _GOnce
104 {
105   volatile GOnceStatus status;
106   volatile gpointer retval;
107 };
108 
109 #define G_LOCK_NAME(name)             g__ ## name ## _lock
110 #define G_LOCK_DEFINE_STATIC(name)    static G_LOCK_DEFINE (name)
111 #define G_LOCK_DEFINE(name)           GMutex G_LOCK_NAME (name)
112 #define G_LOCK_EXTERN(name)           extern GMutex G_LOCK_NAME (name)
113 
114 #ifdef G_DEBUG_LOCKS
115 #  define G_LOCK(name)                G_STMT_START{             \
116       g_log (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,                   \
117              &quot;file %s: line %d (%s): locking: %s &quot;,             \
118              __FILE__,        __LINE__, G_STRFUNC,              \
119              #name);                                            \
120       g_mutex_lock (&amp;G_LOCK_NAME (name));                       \
121    }G_STMT_END
122 #  define G_UNLOCK(name)              G_STMT_START{             \
123       g_log (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,                   \
124              &quot;file %s: line %d (%s): unlocking: %s &quot;,           \
125              __FILE__,        __LINE__, G_STRFUNC,              \
126              #name);                                            \
127      g_mutex_unlock (&amp;G_LOCK_NAME (name));                      \
128    }G_STMT_END
129 #  define G_TRYLOCK(name)                                       \
130       (g_log (G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,                  \
131              &quot;file %s: line %d (%s): try locking: %s &quot;,         \
132              __FILE__,        __LINE__, G_STRFUNC,              \
133              #name), g_mutex_trylock (&amp;G_LOCK_NAME (name)))
134 #else  /* !G_DEBUG_LOCKS */
135 #  define G_LOCK(name) g_mutex_lock       (&amp;G_LOCK_NAME (name))
136 #  define G_UNLOCK(name) g_mutex_unlock   (&amp;G_LOCK_NAME (name))
137 #  define G_TRYLOCK(name) g_mutex_trylock (&amp;G_LOCK_NAME (name))
138 #endif /* !G_DEBUG_LOCKS */
139 
140 GLIB_AVAILABLE_IN_2_32
141 GThread *       g_thread_ref                    (GThread        *thread);
142 GLIB_AVAILABLE_IN_2_32
143 void            g_thread_unref                  (GThread        *thread);
144 GLIB_AVAILABLE_IN_2_32
145 GThread *       g_thread_new                    (const gchar    *name,
146                                                  GThreadFunc     func,
147                                                  gpointer        data);
148 GLIB_AVAILABLE_IN_2_32
149 GThread *       g_thread_try_new                (const gchar    *name,
150                                                  GThreadFunc     func,
151                                                  gpointer        data,
152                                                  GError        **error);
153 GLIB_AVAILABLE_IN_ALL
154 GThread *       g_thread_self                   (void);
155 GLIB_AVAILABLE_IN_ALL
156 void            g_thread_exit                   (gpointer        retval);
157 GLIB_AVAILABLE_IN_ALL
158 gpointer        g_thread_join                   (GThread        *thread);
159 GLIB_AVAILABLE_IN_ALL
160 void            g_thread_yield                  (void);
161 
162 
163 GLIB_AVAILABLE_IN_2_32
164 void            g_mutex_init                    (GMutex         *mutex);
165 GLIB_AVAILABLE_IN_2_32
166 void            g_mutex_clear                   (GMutex         *mutex);
167 GLIB_AVAILABLE_IN_ALL
168 void            g_mutex_lock                    (GMutex         *mutex);
169 GLIB_AVAILABLE_IN_ALL
170 gboolean        g_mutex_trylock                 (GMutex         *mutex);
171 GLIB_AVAILABLE_IN_ALL
172 void            g_mutex_unlock                  (GMutex         *mutex);
173 
174 GLIB_AVAILABLE_IN_2_32
175 void            g_rw_lock_init                  (GRWLock        *rw_lock);
176 GLIB_AVAILABLE_IN_2_32
177 void            g_rw_lock_clear                 (GRWLock        *rw_lock);
178 GLIB_AVAILABLE_IN_2_32
179 void            g_rw_lock_writer_lock           (GRWLock        *rw_lock);
180 GLIB_AVAILABLE_IN_2_32
181 gboolean        g_rw_lock_writer_trylock        (GRWLock        *rw_lock);
182 GLIB_AVAILABLE_IN_2_32
183 void            g_rw_lock_writer_unlock         (GRWLock        *rw_lock);
184 GLIB_AVAILABLE_IN_2_32
185 void            g_rw_lock_reader_lock           (GRWLock        *rw_lock);
186 GLIB_AVAILABLE_IN_2_32
187 gboolean        g_rw_lock_reader_trylock        (GRWLock        *rw_lock);
188 GLIB_AVAILABLE_IN_2_32
189 void            g_rw_lock_reader_unlock         (GRWLock        *rw_lock);
190 
191 GLIB_AVAILABLE_IN_2_32
192 void            g_rec_mutex_init                (GRecMutex      *rec_mutex);
193 GLIB_AVAILABLE_IN_2_32
194 void            g_rec_mutex_clear               (GRecMutex      *rec_mutex);
195 GLIB_AVAILABLE_IN_2_32
196 void            g_rec_mutex_lock                (GRecMutex      *rec_mutex);
197 GLIB_AVAILABLE_IN_2_32
198 gboolean        g_rec_mutex_trylock             (GRecMutex      *rec_mutex);
199 GLIB_AVAILABLE_IN_2_32
200 void            g_rec_mutex_unlock              (GRecMutex      *rec_mutex);
201 
202 GLIB_AVAILABLE_IN_2_32
203 void            g_cond_init                     (GCond          *cond);
204 GLIB_AVAILABLE_IN_2_32
205 void            g_cond_clear                    (GCond          *cond);
206 GLIB_AVAILABLE_IN_ALL
207 void            g_cond_wait                     (GCond          *cond,
208                                                  GMutex         *mutex);
209 GLIB_AVAILABLE_IN_ALL
210 void            g_cond_signal                   (GCond          *cond);
211 GLIB_AVAILABLE_IN_ALL
212 void            g_cond_broadcast                (GCond          *cond);
213 GLIB_AVAILABLE_IN_2_32
214 gboolean        g_cond_wait_until               (GCond          *cond,
215                                                  GMutex         *mutex,
216                                                  gint64          end_time);
217 
218 GLIB_AVAILABLE_IN_ALL
219 gpointer        g_private_get                   (GPrivate       *key);
220 GLIB_AVAILABLE_IN_ALL
221 void            g_private_set                   (GPrivate       *key,
222                                                  gpointer        value);
223 GLIB_AVAILABLE_IN_2_32
224 void            g_private_replace               (GPrivate       *key,
225                                                  gpointer        value);
226 
227 GLIB_AVAILABLE_IN_ALL
228 gpointer        g_once_impl                     (GOnce          *once,
229                                                  GThreadFunc     func,
230                                                  gpointer        arg);
231 GLIB_AVAILABLE_IN_ALL
232 gboolean        g_once_init_enter               (volatile void  *location);
233 GLIB_AVAILABLE_IN_ALL
234 void            g_once_init_leave               (volatile void  *location,
235                                                  gsize           result);
236 
237 #ifdef G_ATOMIC_OP_MEMORY_BARRIER_NEEDED
238 # define g_once(once, func, arg) g_once_impl ((once), (func), (arg))
239 #else /* !G_ATOMIC_OP_MEMORY_BARRIER_NEEDED*/
240 # define g_once(once, func, arg) \
241   (((once)-&gt;status == G_ONCE_STATUS_READY) ? \
242    (once)-&gt;retval : \
243    g_once_impl ((once), (func), (arg)))
244 #endif /* G_ATOMIC_OP_MEMORY_BARRIER_NEEDED */
245 
246 #ifdef __GNUC__
247 # define g_once_init_enter(location) \
248   (G_GNUC_EXTENSION ({                                               \
249     G_STATIC_ASSERT (sizeof *(location) == sizeof (gpointer));       \
250     (void) (0 ? (gpointer) *(location) : 0);                         \
251     (!g_atomic_pointer_get (location) &amp;&amp;                             \
252      g_once_init_enter (location));                                  \
253   }))
254 # define g_once_init_leave(location, result) \
255   (G_GNUC_EXTENSION ({                                               \
256     G_STATIC_ASSERT (sizeof *(location) == sizeof (gpointer));       \
257     (void) (0 ? *(location) = (result) : 0);                         \
258     g_once_init_leave ((location), (gsize) (result));                \
259   }))
260 #else
261 # define g_once_init_enter(location) \
262   (g_once_init_enter((location)))
263 # define g_once_init_leave(location, result) \
264   (g_once_init_leave((location), (gsize) (result)))
265 #endif
266 
267 GLIB_AVAILABLE_IN_2_36
268 guint          g_get_num_processors (void);
269 
270 /**
271  * GMutexLocker:
272  *
273  * Opaque type. See g_mutex_locker_new() for details.
274  * Since: 2.44
275  */
276 typedef void GMutexLocker;
277 
278 /**
279  * g_mutex_locker_new:
280  * @mutex: a mutex to lock
281  *
282  * Lock @mutex and return a new #GMutexLocker. Unlock with
283  * g_mutex_locker_free(). Using g_mutex_unlock() on @mutex
284  * while a #GMutexLocker exists can lead to undefined behaviour.
285  *
286  * This is intended to be used with g_autoptr().  Note that g_autoptr()
287  * is only available when using GCC or clang, so the following example
288  * will only work with those compilers:
289  * |[
290  * typedef struct
291  * {
292  *   ...
293  *   GMutex mutex;
294  *   ...
295  * } MyObject;
296  *
297  * static void
298  * my_object_do_stuff (MyObject *self)
299  * {
300  *   g_autoptr(GMutexLocker) locker = g_mutex_locker_new (&amp;self-&gt;mutex);
301  *
302  *   // Code with mutex locked here
303  *
304  *   if (cond)
305  *     // No need to unlock
306  *     return;
307  *
308  *   // Optionally early unlock
309  *   g_clear_pointer (&amp;locker, g_mutex_locker_free);
310  *
311  *   // Code with mutex unlocked here
312  * }
313  * ]|
314  *
315  * Returns: a #GMutexLocker
316  * Since: 2.44
317  */
318 static inline GMutexLocker *
319 g_mutex_locker_new (GMutex *mutex)
320 {
321   g_mutex_lock (mutex);
322   return (GMutexLocker *) mutex;
323 }
324 
325 /**
326  * g_mutex_locker_free:
327  * @locker: a GMutexLocker
328  *
329  * Unlock @locker&#39;s mutex. See g_mutex_locker_new() for details.
330  *
331  * Since: 2.44
332  */
333 static inline void
334 g_mutex_locker_free (GMutexLocker *locker)
335 {
336   g_mutex_unlock ((GMutex *) locker);
337 }
338 
339 G_END_DECLS
340 
341 #endif /* __G_THREAD_H__ */
    </pre>
  </body>
</html>