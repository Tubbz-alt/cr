<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstinfo.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstghostpad.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstinfo.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstinfo.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 138 #define UNW_LOCAL_ONLY
 139 
 140 #include &lt;libunwind.h&gt;
 141 #include &lt;stdio.h&gt;
 142 #include &lt;stdlib.h&gt;
 143 #include &lt;string.h&gt;
 144 #include &lt;stdarg.h&gt;
 145 #include &lt;unistd.h&gt;
 146 #include &lt;errno.h&gt;
 147 
 148 #ifdef HAVE_DW
 149 #include &lt;elfutils/libdwfl.h&gt;
 150 #endif /* HAVE_DW */
 151 #endif /* HAVE_UNWIND */
 152 
 153 #ifdef HAVE_BACKTRACE
 154 #include &lt;execinfo.h&gt;
 155 #define BT_BUF_SIZE 100
 156 #endif /* HAVE_BACKTRACE */
 157 






 158 extern gboolean gst_is_initialized (void);
 159 











 160 /* we want these symbols exported even if debug is disabled, to maintain
 161  * ABI compatibility. Unless GST_REMOVE_DISABLED is defined. */
 162 #if !defined(GST_DISABLE_GST_DEBUG) || !defined(GST_REMOVE_DISABLED)
 163 
 164 /* disabled by default, as soon as some threshold is set &gt; NONE,
 165  * it becomes enabled. */
 166 gboolean _gst_debug_enabled = FALSE;
 167 GstDebugLevel _gst_debug_min = GST_LEVEL_NONE;
 168 
 169 GstDebugCategory *GST_CAT_DEFAULT = NULL;
 170 
 171 GstDebugCategory *GST_CAT_GST_INIT = NULL;
 172 GstDebugCategory *GST_CAT_MEMORY = NULL;
 173 GstDebugCategory *GST_CAT_PARENTAGE = NULL;
 174 GstDebugCategory *GST_CAT_STATES = NULL;
 175 GstDebugCategory *GST_CAT_SCHEDULING = NULL;
 176 
 177 GstDebugCategory *GST_CAT_BUFFER = NULL;
 178 GstDebugCategory *GST_CAT_BUFFER_LIST = NULL;
 179 GstDebugCategory *GST_CAT_BUS = NULL;
</pre>
<hr />
<pre>
 336 static gchar *
 337 _priv_gst_debug_file_name (const gchar * env)
 338 {
 339   gchar *name;
 340 
 341   name = g_strdup (env);
 342   name = _replace_pattern_in_gst_debug_file_name (name, &quot;%p&quot;, getpid ());
 343   name = _replace_pattern_in_gst_debug_file_name (name, &quot;%r&quot;, g_random_int ());
 344 
 345   return name;
 346 }
 347 
 348 /* Initialize the debugging system */
 349 void
 350 _priv_gst_debug_init (void)
 351 {
 352   const gchar *env;
 353   FILE *log_file;
 354 
 355   if (add_default_log_func) {
<span class="line-modified"> 356   env = g_getenv (&quot;GST_DEBUG_FILE&quot;);</span>
<span class="line-modified"> 357   if (env != NULL &amp;&amp; *env != &#39;\0&#39;) {</span>
<span class="line-modified"> 358     if (strcmp (env, &quot;-&quot;) == 0) {</span>
<span class="line-modified"> 359       log_file = stdout;</span>
<span class="line-modified"> 360     } else {</span>
 361         gchar *name = _priv_gst_debug_file_name (env);
 362         log_file = g_fopen (name, &quot;w&quot;);
 363         g_free (name);
<span class="line-modified"> 364       if (log_file == NULL) {</span>
<span class="line-modified"> 365         g_printerr (&quot;Could not open log file &#39;%s&#39; for writing: %s\n&quot;, env,</span>
<span class="line-modified"> 366             g_strerror (errno));</span>
<span class="line-modified"> 367         log_file = stderr;</span>

 368       }


 369     }
<span class="line-removed"> 370   } else {</span>
<span class="line-removed"> 371     log_file = stderr;</span>
<span class="line-removed"> 372   }</span>
 373 
 374     gst_debug_add_log_function (gst_debug_log_default, log_file, NULL);
 375   }
 376 
 377   __gst_printf_pointer_extension_set_func
 378       (gst_info_printf_pointer_extension_func);
 379 
 380   /* do NOT use a single debug function before this line has been run */
 381   GST_CAT_DEFAULT = _gst_debug_category_new (&quot;default&quot;,
 382       GST_DEBUG_UNDERLINE, NULL);
 383   _GST_CAT_DEBUG = _gst_debug_category_new (&quot;GST_DEBUG&quot;,
 384       GST_DEBUG_BOLD | GST_DEBUG_FG_YELLOW, &quot;debugging subsystem&quot;);
 385 
 386   /* FIXME: add descriptions here */
 387   GST_CAT_GST_INIT = _gst_debug_category_new (&quot;GST_INIT&quot;,
 388       GST_DEBUG_BOLD | GST_DEBUG_FG_RED, NULL);
 389   GST_CAT_MEMORY = _gst_debug_category_new (&quot;GST_MEMORY&quot;,
 390       GST_DEBUG_BOLD | GST_DEBUG_FG_BLUE, &quot;memory&quot;);
 391   GST_CAT_PARENTAGE = _gst_debug_category_new (&quot;GST_PARENTAGE&quot;,
 392       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 393   GST_CAT_STATES = _gst_debug_category_new (&quot;GST_STATES&quot;,
 394       GST_DEBUG_BOLD | GST_DEBUG_FG_RED, NULL);
 395   GST_CAT_SCHEDULING = _gst_debug_category_new (&quot;GST_SCHEDULING&quot;,
 396       GST_DEBUG_BOLD | GST_DEBUG_FG_MAGENTA, NULL);
 397   GST_CAT_BUFFER = _gst_debug_category_new (&quot;GST_BUFFER&quot;,
 398       GST_DEBUG_BOLD | GST_DEBUG_BG_GREEN, NULL);
 399   GST_CAT_BUFFER_LIST = _gst_debug_category_new (&quot;GST_BUFFER_LIST&quot;,
 400       GST_DEBUG_BOLD | GST_DEBUG_BG_GREEN, NULL);
 401   GST_CAT_BUS = _gst_debug_category_new (&quot;GST_BUS&quot;, GST_DEBUG_BG_YELLOW, NULL);
 402   GST_CAT_CAPS = _gst_debug_category_new (&quot;GST_CAPS&quot;,
 403       GST_DEBUG_BOLD | GST_DEBUG_FG_BLUE, NULL);
 404   GST_CAT_CLOCK = _gst_debug_category_new (&quot;GST_CLOCK&quot;,
 405       GST_DEBUG_BOLD | GST_DEBUG_FG_YELLOW, NULL);
 406   GST_CAT_ELEMENT_PADS = _gst_debug_category_new (&quot;GST_ELEMENT_PADS&quot;,
 407       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 408   GST_CAT_PADS = _gst_debug_category_new (&quot;GST_PADS&quot;,
<span class="line-modified"> 409       GST_DEBUG_BOLD | GST_DEBUG_FG_RED | GST_DEBUG_BG_RED, NULL);</span>
 410   GST_CAT_PERFORMANCE = _gst_debug_category_new (&quot;GST_PERFORMANCE&quot;,
 411       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 412   GST_CAT_PIPELINE = _gst_debug_category_new (&quot;GST_PIPELINE&quot;,
 413       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 414   GST_CAT_PLUGIN_LOADING = _gst_debug_category_new (&quot;GST_PLUGIN_LOADING&quot;,
 415       GST_DEBUG_BOLD | GST_DEBUG_FG_CYAN, NULL);
 416   GST_CAT_PLUGIN_INFO = _gst_debug_category_new (&quot;GST_PLUGIN_INFO&quot;,
 417       GST_DEBUG_BOLD | GST_DEBUG_FG_CYAN, NULL);
 418   GST_CAT_PROPERTIES = _gst_debug_category_new (&quot;GST_PROPERTIES&quot;,
 419       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_BLUE, NULL);
 420   GST_CAT_NEGOTIATION = _gst_debug_category_new (&quot;GST_NEGOTIATION&quot;,
 421       GST_DEBUG_BOLD | GST_DEBUG_FG_BLUE, NULL);
 422   GST_CAT_REFCOUNTING = _gst_debug_category_new (&quot;GST_REFCOUNTING&quot;,
 423       GST_DEBUG_BOLD | GST_DEBUG_FG_RED | GST_DEBUG_BG_BLUE, NULL);
 424   GST_CAT_ERROR_SYSTEM = _gst_debug_category_new (&quot;GST_ERROR_SYSTEM&quot;,
 425       GST_DEBUG_BOLD | GST_DEBUG_FG_RED | GST_DEBUG_BG_WHITE, NULL);
 426 
 427   GST_CAT_EVENT = _gst_debug_category_new (&quot;GST_EVENT&quot;,
 428       GST_DEBUG_BOLD | GST_DEBUG_FG_BLUE, NULL);
 429   GST_CAT_MESSAGE = _gst_debug_category_new (&quot;GST_MESSAGE&quot;,
</pre>
<hr />
<pre>
 448   /* print out the valgrind message if we&#39;re in valgrind */
 449   _priv_gst_in_valgrind ();
 450 
 451   env = g_getenv (&quot;GST_DEBUG_OPTIONS&quot;);
 452   if (env != NULL) {
 453     if (strstr (env, &quot;full_tags&quot;) || strstr (env, &quot;full-tags&quot;))
 454       pretty_tags = FALSE;
 455     else if (strstr (env, &quot;pretty_tags&quot;) || strstr (env, &quot;pretty-tags&quot;))
 456       pretty_tags = TRUE;
 457   }
 458 
 459   if (g_getenv (&quot;GST_DEBUG_NO_COLOR&quot;) != NULL)
 460     gst_debug_set_color_mode (GST_DEBUG_COLOR_MODE_OFF);
 461   env = g_getenv (&quot;GST_DEBUG_COLOR_MODE&quot;);
 462   if (env)
 463     gst_debug_set_color_mode_from_string (env);
 464 
 465   env = g_getenv (&quot;GST_DEBUG&quot;);
 466   if (env)
 467     gst_debug_set_threshold_from_string (env, FALSE);
<span class="line-modified"> 468   }</span>
 469 
 470 /* we can&#39;t do this further above, because we initialize the GST_CAT_DEFAULT struct */
 471 #define GST_CAT_DEFAULT _GST_CAT_DEBUG
 472 
 473 /**
 474  * gst_debug_log:
 475  * @category: category to log
 476  * @level: level of the message is in
 477  * @file: the file that emitted the message, usually the __FILE__ identifier
 478  * @function: the function that emitted the message
 479  * @line: the line from that the message was emitted, usually __LINE__
 480  * @object: (transfer none) (allow-none): the object this message relates to,
 481  *     or %NULL if none
 482  * @format: a printf style format string
 483  * @...: optional arguments for the format
 484  *
 485  * Logs the given message using the currently registered debugging handlers.
 486  */
 487 void
 488 gst_debug_log (GstDebugCategory * category, GstDebugLevel level,
</pre>
<hr />
<pre>
1231       fflush (log_file);
1232       /* message */
1233       SET_COLOR (clear);
1234       fprintf (log_file, &quot; %s\n&quot;, message_str);
1235       fflush (log_file);
1236     }
1237     g_mutex_unlock (&amp;win_print_mutex);
1238 #endif
1239   } else {
1240     /* no color, all platforms */
1241 #define PRINT_FMT &quot; &quot;PID_FMT&quot; &quot;PTR_FMT&quot; %s &quot;CAT_FMT&quot; %s\n&quot;
1242     fprintf (log_file, &quot;%&quot; GST_TIME_FORMAT PRINT_FMT, GST_TIME_ARGS (elapsed),
1243         pid, g_thread_self (), gst_debug_level_get_name (level),
1244         gst_debug_category_get_name (category), file, line, function, obj,
1245         message_str);
1246     fflush (log_file);
1247 #undef PRINT_FMT
1248   }
1249 
1250   if (object != NULL)
<span class="line-modified">1251   g_free (obj);</span>
1252 }
1253 
1254 /**
1255  * gst_debug_level_get_name:
1256  * @level: the level to get the name for
1257  *
1258  * Get the string representation of a debugging level
1259  *
1260  * Returns: the name
1261  */
1262 const gchar *
1263 gst_debug_level_get_name (GstDebugLevel level)
1264 {
1265   switch (level) {
1266     case GST_LEVEL_NONE:
1267       return &quot;&quot;;
1268     case GST_LEVEL_ERROR:
1269       return &quot;ERROR  &quot;;
1270     case GST_LEVEL_WARNING:
1271       return &quot;WARN   &quot;;
</pre>
<hr />
<pre>
1570 void
1571 gst_debug_set_default_threshold (GstDebugLevel level)
1572 {
1573   g_atomic_int_set (&amp;__default_level, level);
1574   gst_debug_reset_all_thresholds ();
1575 }
1576 
1577 /**
1578  * gst_debug_get_default_threshold:
1579  *
1580  * Returns the default threshold that is used for new categories.
1581  *
1582  * Returns: the default threshold level
1583  */
1584 GstDebugLevel
1585 gst_debug_get_default_threshold (void)
1586 {
1587   return (GstDebugLevel) g_atomic_int_get (&amp;__default_level);
1588 }
1589 














1590 static void
1591 gst_debug_reset_threshold (gpointer category, gpointer unused)
1592 {
1593   GstDebugCategory *cat = (GstDebugCategory *) category;
1594   GSList *walk;
1595 
1596   g_mutex_lock (&amp;__level_name_mutex);
<span class="line-removed">1597   walk = __level_name;</span>
<span class="line-removed">1598   while (walk) {</span>
<span class="line-removed">1599     LevelNameEntry *entry = walk-&gt;data;</span>
1600 
<span class="line-modified">1601     walk = g_slist_next (walk);</span>
<span class="line-modified">1602     if (g_pattern_match_string (entry-&gt;pat, cat-&gt;name)) {</span>
<span class="line-modified">1603       if (gst_is_initialized ())</span>
<span class="line-removed">1604         GST_LOG (&quot;category %s matches pattern %p - gets set to level %d&quot;,</span>
<span class="line-removed">1605             cat-&gt;name, entry-&gt;pat, entry-&gt;level);</span>
<span class="line-removed">1606       gst_debug_category_set_threshold (cat, entry-&gt;level);</span>
<span class="line-removed">1607       goto exit;</span>
<span class="line-removed">1608     }</span>
1609   }
<span class="line-removed">1610   gst_debug_category_set_threshold (cat, gst_debug_get_default_threshold ());</span>
1611 
<span class="line-removed">1612 exit:</span>
1613   g_mutex_unlock (&amp;__level_name_mutex);



1614 }
1615 
1616 static void
1617 gst_debug_reset_all_thresholds (void)
1618 {
1619   g_mutex_lock (&amp;__cat_mutex);
1620   g_slist_foreach (__categories, gst_debug_reset_threshold, NULL);
1621   g_mutex_unlock (&amp;__cat_mutex);
1622 }
1623 
1624 static void
1625 for_each_threshold_by_entry (gpointer data, gpointer user_data)
1626 {
1627   GstDebugCategory *cat = (GstDebugCategory *) data;
1628   LevelNameEntry *entry = (LevelNameEntry *) user_data;
1629 
<span class="line-modified">1630   if (g_pattern_match_string (entry-&gt;pat, cat-&gt;name)) {</span>
<span class="line-removed">1631     if (gst_is_initialized ())</span>
<span class="line-removed">1632       GST_TRACE (&quot;category %s matches pattern %p - gets set to level %d&quot;,</span>
<span class="line-removed">1633           cat-&gt;name, entry-&gt;pat, entry-&gt;level);</span>
<span class="line-removed">1634     gst_debug_category_set_threshold (cat, entry-&gt;level);</span>
<span class="line-removed">1635   }</span>
1636 }
1637 
1638 /**
1639  * gst_debug_set_threshold_for_name:
1640  * @name: name of the categories to set
1641  * @level: level to set them to
1642  *
1643  * Sets all categories which match the given glob style pattern to the given
1644  * level.
1645  */
1646 void
1647 gst_debug_set_threshold_for_name (const gchar * name, GstDebugLevel level)
1648 {
1649   GPatternSpec *pat;
1650   LevelNameEntry *entry;
1651 
1652   g_return_if_fail (name != NULL);
1653 
1654   pat = g_pattern_spec_new (name);
1655   entry = g_slice_new (LevelNameEntry);
</pre>
<hr />
<pre>
1988     gst_debug_set_default_threshold (GST_LEVEL_DEFAULT);
1989 
1990   split = g_strsplit (list, &quot;,&quot;, 0);
1991 
1992   for (walk = split; *walk; walk++) {
1993     if (strchr (*walk, &#39;:&#39;)) {
1994       gchar **values = g_strsplit (*walk, &quot;:&quot;, 2);
1995 
1996       if (values[0] &amp;&amp; values[1]) {
1997         GstDebugLevel level;
1998         const gchar *category;
1999 
2000         if (parse_debug_category (values[0], &amp;category)
2001             &amp;&amp; parse_debug_level (values[1], &amp;level)) {
2002           gst_debug_set_threshold_for_name (category, level);
2003 
2004           /* bump min-level anyway to allow the category to be registered in the
2005            * future still */
2006           if (level &gt; _gst_debug_min) {
2007             _gst_debug_min = level;
<span class="line-modified">2008       }</span>
2009         }
2010       }
2011 
2012       g_strfreev (values);
2013     } else {
2014       GstDebugLevel level;
2015 
2016       if (parse_debug_level (*walk, &amp;level))
2017         gst_debug_set_default_threshold (level);
2018     }
2019   }
2020 
2021   g_strfreev (split);
2022 }
2023 
2024 /*** FUNCTION POINTERS ********************************************************/
2025 
2026 static GHashTable *__gst_function_pointers;     /* NULL */
2027 static GMutex __dbg_functions_mutex;
2028 
</pre>
<hr />
<pre>
2035 #ifdef HAVE_DLADDR
2036   Dl_info dl_info;
2037 #endif
2038 
2039   if (G_UNLIKELY (func == NULL))
2040     return &quot;(NULL)&quot;;
2041 
2042   g_mutex_lock (&amp;__dbg_functions_mutex);
2043   if (G_LIKELY (__gst_function_pointers)) {
2044     ptrname = g_hash_table_lookup (__gst_function_pointers, (gpointer) func);
2045     g_mutex_unlock (&amp;__dbg_functions_mutex);
2046     if (G_LIKELY (ptrname))
2047       return ptrname;
2048   } else {
2049     g_mutex_unlock (&amp;__dbg_functions_mutex);
2050   }
2051   /* we need to create an entry in the hash table for this one so we don&#39;t leak
2052    * the name */
2053 #ifdef HAVE_DLADDR
2054   if (dladdr ((gpointer) func, &amp;dl_info) &amp;&amp; dl_info.dli_sname) {
<span class="line-modified">2055     gchar *name = g_strdup (dl_info.dli_sname);</span>
2056 
2057     _gst_debug_register_funcptr (func, name);
2058     return name;
2059   } else
2060 #endif
2061   {
2062     gchar *name = g_strdup_printf (&quot;%p&quot;, (gpointer) func);

2063 
<span class="line-modified">2064     _gst_debug_register_funcptr (func, name);</span>
<span class="line-modified">2065     return name;</span>


2066   }
2067 }
2068 
2069 void
2070 _gst_debug_register_funcptr (GstDebugFuncPtr func, const gchar * ptrname)
2071 {
2072   gpointer ptr = (gpointer) func;
2073 
2074   g_mutex_lock (&amp;__dbg_functions_mutex);
2075 
2076   if (!__gst_function_pointers)
2077     __gst_function_pointers = g_hash_table_new (g_direct_hash, g_direct_equal);
<span class="line-modified">2078   if (!g_hash_table_lookup (__gst_function_pointers, ptr))</span>
2079     g_hash_table_insert (__gst_function_pointers, ptr, (gpointer) ptrname);














2080 
2081   g_mutex_unlock (&amp;__dbg_functions_mutex);
2082 }
2083 
2084 static void
2085 gst_info_dump_mem_line (gchar * linebuf, gsize linebuf_size,
2086     const guint8 * mem, gsize mem_offset, gsize mem_size)
2087 {
2088   gchar hexstr[50], ascstr[18], digitstr[4];
2089 
2090   if (mem_size &gt; 16)
2091     mem_size = 16;
2092 
2093   hexstr[0] = &#39;\0&#39;;
2094   ascstr[0] = &#39;\0&#39;;
2095 
2096   if (mem != NULL) {
2097     guint i = 0;
2098 
2099     mem += mem_offset;
</pre>
<hr />
<pre>
2142 
2143 GstDebugCategory *
2144 _gst_debug_category_new (const gchar * name, guint color,
2145     const gchar * description)
2146 {
2147   return NULL;
2148 }
2149 
2150 void
2151 _gst_debug_register_funcptr (GstDebugFuncPtr func, const gchar * ptrname)
2152 {
2153 }
2154 
2155 /* This function MUST NOT return NULL */
2156 const gchar *
2157 _gst_debug_nameof_funcptr (GstDebugFuncPtr func)
2158 {
2159   return &quot;(NULL)&quot;;
2160 }
2161 





2162 void
2163 gst_debug_log (GstDebugCategory * category, GstDebugLevel level,
2164     const gchar * file, const gchar * function, gint line,
2165     GObject * object, const gchar * format, ...)
2166 {
2167 }
2168 
2169 void
2170 gst_debug_log_valist (GstDebugCategory * category, GstDebugLevel level,
2171     const gchar * file, const gchar * function, gint line,
2172     GObject * object, const gchar * format, va_list args)
2173 {
2174 }
2175 
2176 const gchar *
2177 gst_debug_message_get (GstDebugMessage * message)
2178 {
2179   return &quot;&quot;;
2180 }
2181 
</pre>
<hr />
<pre>
2599  * This function differs from g_printerr() in that it supports the additional
2600  * printf specifiers that are supported by GStreamer&#39;s debug logging system,
2601  * such as #GST_PTR_FORMAT and #GST_SEGMENT_FORMAT.
2602  *
2603  * This function is primarily for printing debug output.
2604  *
2605  * Since: 1.12
2606  */
2607 void
2608 gst_printerrln (const gchar * format, ...)
2609 {
2610   va_list args;
2611   gchar *str;
2612 
2613   va_start (args, format);
2614   str = gst_info_strdup_vprintf (format, args);
2615   va_end (args);
2616 
2617   g_printerr (&quot;%s\n&quot;, str);
2618   g_free (str);
<span class="line-modified">2619   }</span>
2620 
2621 #ifdef HAVE_UNWIND
2622 #ifdef HAVE_DW
2623 static gboolean
2624 append_debug_info (GString * trace, Dwfl * dwfl, const void *ip)
2625 {
2626   Dwfl_Line *line;
2627   Dwarf_Addr addr;
2628   Dwfl_Module *module;
2629   const gchar *function_name;
2630 
2631   if (dwfl_linux_proc_report (dwfl, getpid ()) != 0)
2632     return FALSE;
2633 
2634   if (dwfl_report_end (dwfl, NULL, NULL))
2635     return FALSE;
2636 
2637   addr = (uintptr_t) ip;
2638   module = dwfl_addrmodule (dwfl, addr);
2639   function_name = dwfl_module_addrname (module, addr);
2640 
2641   g_string_append_printf (trace, &quot;%s (&quot;, function_name ? function_name : &quot;??&quot;);
2642 
2643   line = dwfl_getsrc (dwfl, addr);
2644   if (line != NULL) {
2645     gint nline;
2646     Dwarf_Addr addr;
2647     const gchar *filename = dwfl_lineinfo (line, &amp;addr,
2648         &amp;nline, NULL, NULL, NULL);
2649 
2650     g_string_append_printf (trace, &quot;%s:%d&quot;, strrchr (filename,
2651             G_DIR_SEPARATOR) + 1, nline);
2652   } else {
2653     const gchar *eflfile = NULL;
2654 
2655     dwfl_module_info (module, NULL, NULL, NULL, NULL, NULL, &amp;eflfile, NULL);
2656     g_string_append_printf (trace, &quot;%s:%p&quot;, eflfile ? eflfile : &quot;??&quot;, ip);
<span class="line-modified">2657 }</span>
2658 
2659   return TRUE;
2660 }
2661 #endif /* HAVE_DW */
2662 
2663 static gchar *
2664 generate_unwind_trace (GstStackTraceFlags flags)
2665 {
2666   gint unret;
2667   unw_context_t uc;
2668   unw_cursor_t cursor;
2669   gboolean use_libunwind = TRUE;
2670   GString *trace = g_string_new (NULL);
2671 
2672 #ifdef HAVE_DW
2673   Dwfl *dwfl = NULL;
2674   Dwfl_Callbacks callbacks = {
2675     .find_elf = dwfl_linux_proc_find_elf,
2676     .find_debuginfo = dwfl_standard_find_debuginfo,
2677   };
</pre>
<hr />
<pre>
2744 
2745   trace = g_string_new (NULL);
2746   nptrs = backtrace (buffer, BT_BUF_SIZE);
2747 
2748   strings = backtrace_symbols (buffer, nptrs);
2749 
2750   if (!strings)
2751     return NULL;
2752 
2753   for (j = 0; j &lt; nptrs; j++)
2754     g_string_append_printf (trace, &quot;%s\n&quot;, strings[j]);
2755 
2756   free (strings);
2757 
2758   return g_string_free (trace, FALSE);
2759 }
2760 #else
2761 #define generate_backtrace_trace() NULL
2762 #endif /* HAVE_BACKTRACE */
2763 




























































































2764 /**
2765  * gst_debug_get_stack_trace:
2766  * @flags: A set of #GstStackTraceFlags to determine how the stack
2767  * trace should look like. Pass 0 to retrieve a minimal backtrace.
2768  *
2769  * Returns: (nullable): a stack trace, if libunwind or glibc backtrace are
2770  * present, else %NULL.
2771  *
2772  * Since: 1.12
2773  */
2774 gchar *
2775 gst_debug_get_stack_trace (GstStackTraceFlags flags)
2776 {
2777   gchar *trace = NULL;
2778 #ifdef HAVE_BACKTRACE
2779   gboolean have_backtrace = TRUE;
2780 #else
2781   gboolean have_backtrace = FALSE;
2782 #endif
2783 
2784 #ifdef HAVE_UNWIND
2785   if ((flags &amp; GST_STACK_TRACE_SHOW_FULL) || !have_backtrace)
2786     trace = generate_unwind_trace (flags);
2787 #endif /* HAVE_UNWIND */
2788 




2789   if (trace)
2790     return trace;
2791   else if (have_backtrace)
2792     return generate_backtrace_trace ();
2793 
2794   return NULL;
2795 }
2796 
2797 /**
2798  * gst_debug_print_stack_trace:
2799  *
<span class="line-modified">2800  * If libunwind or glibc backtrace are present</span>
2801  * a stack trace is printed.
2802  */
2803 void
2804 gst_debug_print_stack_trace (void)
2805 {
2806   gchar *trace = gst_debug_get_stack_trace (GST_STACK_TRACE_SHOW_FULL);
2807 
2808   if (trace)
2809     g_print (&quot;%s\n&quot;, trace);
2810 
2811   g_free (trace);
2812 }
2813 
2814 #ifndef GST_DISABLE_GST_DEBUG
2815 typedef struct
2816 {
2817   guint max_size_per_thread;
2818   guint thread_timeout;
2819   GQueue threads;
2820   GHashTable *thread_index;
</pre>
<hr />
<pre>
2835 
2836 static void
2837 gst_ring_buffer_logger_log (GstDebugCategory * category,
2838     GstDebugLevel level,
2839     const gchar * file,
2840     const gchar * function,
2841     gint line, GObject * object, GstDebugMessage * message, gpointer user_data)
2842 {
2843   GstRingBufferLogger *logger = user_data;
2844   gint pid;
2845   GThread *thread;
2846   GstClockTime elapsed;
2847   gchar *obj = NULL;
2848   gchar c;
2849   gchar *output;
2850   gsize output_len;
2851   GstRingBufferLog *log;
2852   gint64 now = g_get_monotonic_time ();
2853   const gchar *message_str = gst_debug_message_get (message);
2854 

































2855   G_LOCK (ring_buffer_logger);
2856 
2857   if (logger-&gt;thread_timeout &gt; 0) {


2858     /* Remove all threads that saw no output since thread_timeout seconds.
2859      * By construction these are all at the tail of the queue, and the queue
2860      * is ordered by last use, so we just need to look at the tail.
2861      */
2862     while (logger-&gt;threads.tail) {
2863       log = logger-&gt;threads.tail-&gt;data;
2864       if (log-&gt;last_use + logger-&gt;thread_timeout * G_USEC_PER_SEC &gt;= now)
2865         break;
2866 
2867       g_hash_table_remove (logger-&gt;thread_index, log-&gt;thread);
<span class="line-modified">2868       while ((output = g_queue_pop_head (&amp;log-&gt;log)))</span>
<span class="line-modified">2869         g_free (output);</span>
2870       g_free (log);
2871       g_queue_pop_tail (&amp;logger-&gt;threads);
2872     }
2873   }
2874 
2875   /* Get logger for this thread, and put it back at the
2876    * head of the threads queue */
<span class="line-removed">2877   thread = g_thread_self ();</span>
2878   log = g_hash_table_lookup (logger-&gt;thread_index, thread);
2879   if (!log) {
2880     log = g_new0 (GstRingBufferLog, 1);
2881     g_queue_init (&amp;log-&gt;log);
2882     log-&gt;log_size = 0;
2883     g_queue_push_head (&amp;logger-&gt;threads, log);
2884     log-&gt;link = logger-&gt;threads.head;
2885     log-&gt;thread = thread;
2886     g_hash_table_insert (logger-&gt;thread_index, thread, log);
2887   } else {
2888     g_queue_unlink (&amp;logger-&gt;threads, log-&gt;link);
2889     g_queue_push_head_link (&amp;logger-&gt;threads, log-&gt;link);
2890   }
2891   log-&gt;last_use = now;
2892 
<span class="line-removed">2893   /* __FILE__ might be a file name or an absolute path or a</span>
<span class="line-removed">2894    * relative path, irrespective of the exact compiler used,</span>
<span class="line-removed">2895    * in which case we want to shorten it to the filename for</span>
<span class="line-removed">2896    * readability. */</span>
<span class="line-removed">2897   c = file[0];</span>
<span class="line-removed">2898   if (c == &#39;.&#39; || c == &#39;/&#39; || c == &#39;\\&#39; || (c != &#39;\0&#39; &amp;&amp; file[1] == &#39;:&#39;)) {</span>
<span class="line-removed">2899     file = gst_path_basename (file);</span>
<span class="line-removed">2900   }</span>
<span class="line-removed">2901 </span>
<span class="line-removed">2902   pid = getpid ();</span>
<span class="line-removed">2903 </span>
<span class="line-removed">2904   if (object) {</span>
<span class="line-removed">2905     obj = gst_debug_print_object (object);</span>
<span class="line-removed">2906   } else {</span>
<span class="line-removed">2907     obj = (gchar *) &quot;&quot;;</span>
<span class="line-removed">2908   }</span>
<span class="line-removed">2909 </span>
<span class="line-removed">2910   elapsed = GST_CLOCK_DIFF (_priv_gst_start_time, gst_util_get_timestamp ());</span>
<span class="line-removed">2911 </span>
<span class="line-removed">2912   /* no color, all platforms */</span>
<span class="line-removed">2913 #define PRINT_FMT &quot; &quot;PID_FMT&quot; &quot;PTR_FMT&quot; %s &quot;CAT_FMT&quot; %s\n&quot;</span>
<span class="line-removed">2914   output =</span>
<span class="line-removed">2915       g_strdup_printf (&quot;%&quot; GST_TIME_FORMAT PRINT_FMT, GST_TIME_ARGS (elapsed),</span>
<span class="line-removed">2916       pid, thread, gst_debug_level_get_name (level),</span>
<span class="line-removed">2917       gst_debug_category_get_name (category), file, line, function, obj,</span>
<span class="line-removed">2918       message_str);</span>
<span class="line-removed">2919 #undef PRINT_FMT</span>
<span class="line-removed">2920 </span>
<span class="line-removed">2921   output_len = strlen (output);</span>
<span class="line-removed">2922 </span>
2923   if (output_len &lt; logger-&gt;max_size_per_thread) {
2924     gchar *buf;
2925 
2926     /* While using a GQueue here is not the most efficient thing to do, we
2927      * have to allocate a string for every output anyway and could just store
2928      * that instead of copying it to an actual ringbuffer.
2929      * Better than GQueue would be GstQueueArray, but that one is in
2930      * libgstbase and we can&#39;t use it here. That one allocation will not make
2931      * much of a difference anymore, considering the number of allocations
2932      * needed to get to this point...
2933      */
2934     while (log-&gt;log_size + output_len &gt; logger-&gt;max_size_per_thread) {
2935       buf = g_queue_pop_head (&amp;log-&gt;log);
2936       log-&gt;log_size -= strlen (buf);
2937       g_free (buf);
2938     }
2939     g_queue_push_tail (&amp;log-&gt;log, output);
2940     log-&gt;log_size += output_len;
2941   } else {
2942     gchar *buf;
2943 
2944     /* Can&#39;t really write anything as the line is bigger than the maximum
2945      * allowed log size already, so just remove everything */
2946 
2947     while ((buf = g_queue_pop_head (&amp;log-&gt;log)))
2948       g_free (buf);
2949     g_free (output);
2950     log-&gt;log_size = 0;
2951   }
2952 
<span class="line-removed">2953   if (object != NULL)</span>
<span class="line-removed">2954     g_free (obj);</span>
<span class="line-removed">2955 </span>
2956   G_UNLOCK (ring_buffer_logger);
2957 }
2958 
2959 /**
2960  * gst_debug_ring_buffer_logger_get_logs:
2961  *
2962  * Fetches the current logs per thread from the ring buffer logger. See
2963  * gst_debug_add_ring_buffer_logger() for details.
2964  *
2965  * Returns: (transfer full) (array zero-terminated): NULL-terminated array of
2966  * strings with the debug output per thread
2967  *
2968  * Since: 1.14
2969  */
2970 gchar **
2971 gst_debug_ring_buffer_logger_get_logs (void)
2972 {
2973   gchar **logs, **tmp;
2974   GList *l;
2975 
</pre>
</td>
<td>
<hr />
<pre>
 138 #define UNW_LOCAL_ONLY
 139 
 140 #include &lt;libunwind.h&gt;
 141 #include &lt;stdio.h&gt;
 142 #include &lt;stdlib.h&gt;
 143 #include &lt;string.h&gt;
 144 #include &lt;stdarg.h&gt;
 145 #include &lt;unistd.h&gt;
 146 #include &lt;errno.h&gt;
 147 
 148 #ifdef HAVE_DW
 149 #include &lt;elfutils/libdwfl.h&gt;
 150 #endif /* HAVE_DW */
 151 #endif /* HAVE_UNWIND */
 152 
 153 #ifdef HAVE_BACKTRACE
 154 #include &lt;execinfo.h&gt;
 155 #define BT_BUF_SIZE 100
 156 #endif /* HAVE_BACKTRACE */
 157 
<span class="line-added"> 158 #ifdef HAVE_DBGHELP</span>
<span class="line-added"> 159 #include &lt;Windows.h&gt;</span>
<span class="line-added"> 160 #include &lt;dbghelp.h&gt;</span>
<span class="line-added"> 161 #include &lt;tlhelp32.h&gt;</span>
<span class="line-added"> 162 #endif /* HAVE_DBGHELP */</span>
<span class="line-added"> 163 </span>
 164 extern gboolean gst_is_initialized (void);
 165 
<span class="line-added"> 166 #ifdef GSTREAMER_LITE</span>
<span class="line-added"> 167 // For some reason it is not defined if GST_DISABLE_GST_DEBUG and</span>
<span class="line-added"> 168 // GST_REMOVE_DISABLED is defined which we do for GSTREAMER_LITE</span>
<span class="line-added"> 169 #ifdef GST_REMOVE_DISABLED</span>
<span class="line-added"> 170 void</span>
<span class="line-added"> 171 _priv_gst_debug_cleanup (void)</span>
<span class="line-added"> 172 {</span>
<span class="line-added"> 173 }</span>
<span class="line-added"> 174 #endif // GST_REMOVE_DISABLED</span>
<span class="line-added"> 175 #endif // GSTREAMER_LITE</span>
<span class="line-added"> 176 </span>
 177 /* we want these symbols exported even if debug is disabled, to maintain
 178  * ABI compatibility. Unless GST_REMOVE_DISABLED is defined. */
 179 #if !defined(GST_DISABLE_GST_DEBUG) || !defined(GST_REMOVE_DISABLED)
 180 
 181 /* disabled by default, as soon as some threshold is set &gt; NONE,
 182  * it becomes enabled. */
 183 gboolean _gst_debug_enabled = FALSE;
 184 GstDebugLevel _gst_debug_min = GST_LEVEL_NONE;
 185 
 186 GstDebugCategory *GST_CAT_DEFAULT = NULL;
 187 
 188 GstDebugCategory *GST_CAT_GST_INIT = NULL;
 189 GstDebugCategory *GST_CAT_MEMORY = NULL;
 190 GstDebugCategory *GST_CAT_PARENTAGE = NULL;
 191 GstDebugCategory *GST_CAT_STATES = NULL;
 192 GstDebugCategory *GST_CAT_SCHEDULING = NULL;
 193 
 194 GstDebugCategory *GST_CAT_BUFFER = NULL;
 195 GstDebugCategory *GST_CAT_BUFFER_LIST = NULL;
 196 GstDebugCategory *GST_CAT_BUS = NULL;
</pre>
<hr />
<pre>
 353 static gchar *
 354 _priv_gst_debug_file_name (const gchar * env)
 355 {
 356   gchar *name;
 357 
 358   name = g_strdup (env);
 359   name = _replace_pattern_in_gst_debug_file_name (name, &quot;%p&quot;, getpid ());
 360   name = _replace_pattern_in_gst_debug_file_name (name, &quot;%r&quot;, g_random_int ());
 361 
 362   return name;
 363 }
 364 
 365 /* Initialize the debugging system */
 366 void
 367 _priv_gst_debug_init (void)
 368 {
 369   const gchar *env;
 370   FILE *log_file;
 371 
 372   if (add_default_log_func) {
<span class="line-modified"> 373     env = g_getenv (&quot;GST_DEBUG_FILE&quot;);</span>
<span class="line-modified"> 374     if (env != NULL &amp;&amp; *env != &#39;\0&#39;) {</span>
<span class="line-modified"> 375       if (strcmp (env, &quot;-&quot;) == 0) {</span>
<span class="line-modified"> 376         log_file = stdout;</span>
<span class="line-modified"> 377       } else {</span>
 378         gchar *name = _priv_gst_debug_file_name (env);
 379         log_file = g_fopen (name, &quot;w&quot;);
 380         g_free (name);
<span class="line-modified"> 381         if (log_file == NULL) {</span>
<span class="line-modified"> 382           g_printerr (&quot;Could not open log file &#39;%s&#39; for writing: %s\n&quot;, env,</span>
<span class="line-modified"> 383               g_strerror (errno));</span>
<span class="line-modified"> 384           log_file = stderr;</span>
<span class="line-added"> 385         }</span>
 386       }
<span class="line-added"> 387     } else {</span>
<span class="line-added"> 388       log_file = stderr;</span>
 389     }



 390 
 391     gst_debug_add_log_function (gst_debug_log_default, log_file, NULL);
 392   }
 393 
 394   __gst_printf_pointer_extension_set_func
 395       (gst_info_printf_pointer_extension_func);
 396 
 397   /* do NOT use a single debug function before this line has been run */
 398   GST_CAT_DEFAULT = _gst_debug_category_new (&quot;default&quot;,
 399       GST_DEBUG_UNDERLINE, NULL);
 400   _GST_CAT_DEBUG = _gst_debug_category_new (&quot;GST_DEBUG&quot;,
 401       GST_DEBUG_BOLD | GST_DEBUG_FG_YELLOW, &quot;debugging subsystem&quot;);
 402 
 403   /* FIXME: add descriptions here */
 404   GST_CAT_GST_INIT = _gst_debug_category_new (&quot;GST_INIT&quot;,
 405       GST_DEBUG_BOLD | GST_DEBUG_FG_RED, NULL);
 406   GST_CAT_MEMORY = _gst_debug_category_new (&quot;GST_MEMORY&quot;,
 407       GST_DEBUG_BOLD | GST_DEBUG_FG_BLUE, &quot;memory&quot;);
 408   GST_CAT_PARENTAGE = _gst_debug_category_new (&quot;GST_PARENTAGE&quot;,
 409       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 410   GST_CAT_STATES = _gst_debug_category_new (&quot;GST_STATES&quot;,
 411       GST_DEBUG_BOLD | GST_DEBUG_FG_RED, NULL);
 412   GST_CAT_SCHEDULING = _gst_debug_category_new (&quot;GST_SCHEDULING&quot;,
 413       GST_DEBUG_BOLD | GST_DEBUG_FG_MAGENTA, NULL);
 414   GST_CAT_BUFFER = _gst_debug_category_new (&quot;GST_BUFFER&quot;,
 415       GST_DEBUG_BOLD | GST_DEBUG_BG_GREEN, NULL);
 416   GST_CAT_BUFFER_LIST = _gst_debug_category_new (&quot;GST_BUFFER_LIST&quot;,
 417       GST_DEBUG_BOLD | GST_DEBUG_BG_GREEN, NULL);
 418   GST_CAT_BUS = _gst_debug_category_new (&quot;GST_BUS&quot;, GST_DEBUG_BG_YELLOW, NULL);
 419   GST_CAT_CAPS = _gst_debug_category_new (&quot;GST_CAPS&quot;,
 420       GST_DEBUG_BOLD | GST_DEBUG_FG_BLUE, NULL);
 421   GST_CAT_CLOCK = _gst_debug_category_new (&quot;GST_CLOCK&quot;,
 422       GST_DEBUG_BOLD | GST_DEBUG_FG_YELLOW, NULL);
 423   GST_CAT_ELEMENT_PADS = _gst_debug_category_new (&quot;GST_ELEMENT_PADS&quot;,
 424       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 425   GST_CAT_PADS = _gst_debug_category_new (&quot;GST_PADS&quot;,
<span class="line-modified"> 426       GST_DEBUG_BOLD | GST_DEBUG_FG_RED | GST_DEBUG_BG_BLUE, NULL);</span>
 427   GST_CAT_PERFORMANCE = _gst_debug_category_new (&quot;GST_PERFORMANCE&quot;,
 428       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 429   GST_CAT_PIPELINE = _gst_debug_category_new (&quot;GST_PIPELINE&quot;,
 430       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 431   GST_CAT_PLUGIN_LOADING = _gst_debug_category_new (&quot;GST_PLUGIN_LOADING&quot;,
 432       GST_DEBUG_BOLD | GST_DEBUG_FG_CYAN, NULL);
 433   GST_CAT_PLUGIN_INFO = _gst_debug_category_new (&quot;GST_PLUGIN_INFO&quot;,
 434       GST_DEBUG_BOLD | GST_DEBUG_FG_CYAN, NULL);
 435   GST_CAT_PROPERTIES = _gst_debug_category_new (&quot;GST_PROPERTIES&quot;,
 436       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_BLUE, NULL);
 437   GST_CAT_NEGOTIATION = _gst_debug_category_new (&quot;GST_NEGOTIATION&quot;,
 438       GST_DEBUG_BOLD | GST_DEBUG_FG_BLUE, NULL);
 439   GST_CAT_REFCOUNTING = _gst_debug_category_new (&quot;GST_REFCOUNTING&quot;,
 440       GST_DEBUG_BOLD | GST_DEBUG_FG_RED | GST_DEBUG_BG_BLUE, NULL);
 441   GST_CAT_ERROR_SYSTEM = _gst_debug_category_new (&quot;GST_ERROR_SYSTEM&quot;,
 442       GST_DEBUG_BOLD | GST_DEBUG_FG_RED | GST_DEBUG_BG_WHITE, NULL);
 443 
 444   GST_CAT_EVENT = _gst_debug_category_new (&quot;GST_EVENT&quot;,
 445       GST_DEBUG_BOLD | GST_DEBUG_FG_BLUE, NULL);
 446   GST_CAT_MESSAGE = _gst_debug_category_new (&quot;GST_MESSAGE&quot;,
</pre>
<hr />
<pre>
 465   /* print out the valgrind message if we&#39;re in valgrind */
 466   _priv_gst_in_valgrind ();
 467 
 468   env = g_getenv (&quot;GST_DEBUG_OPTIONS&quot;);
 469   if (env != NULL) {
 470     if (strstr (env, &quot;full_tags&quot;) || strstr (env, &quot;full-tags&quot;))
 471       pretty_tags = FALSE;
 472     else if (strstr (env, &quot;pretty_tags&quot;) || strstr (env, &quot;pretty-tags&quot;))
 473       pretty_tags = TRUE;
 474   }
 475 
 476   if (g_getenv (&quot;GST_DEBUG_NO_COLOR&quot;) != NULL)
 477     gst_debug_set_color_mode (GST_DEBUG_COLOR_MODE_OFF);
 478   env = g_getenv (&quot;GST_DEBUG_COLOR_MODE&quot;);
 479   if (env)
 480     gst_debug_set_color_mode_from_string (env);
 481 
 482   env = g_getenv (&quot;GST_DEBUG&quot;);
 483   if (env)
 484     gst_debug_set_threshold_from_string (env, FALSE);
<span class="line-modified"> 485 }</span>
 486 
 487 /* we can&#39;t do this further above, because we initialize the GST_CAT_DEFAULT struct */
 488 #define GST_CAT_DEFAULT _GST_CAT_DEBUG
 489 
 490 /**
 491  * gst_debug_log:
 492  * @category: category to log
 493  * @level: level of the message is in
 494  * @file: the file that emitted the message, usually the __FILE__ identifier
 495  * @function: the function that emitted the message
 496  * @line: the line from that the message was emitted, usually __LINE__
 497  * @object: (transfer none) (allow-none): the object this message relates to,
 498  *     or %NULL if none
 499  * @format: a printf style format string
 500  * @...: optional arguments for the format
 501  *
 502  * Logs the given message using the currently registered debugging handlers.
 503  */
 504 void
 505 gst_debug_log (GstDebugCategory * category, GstDebugLevel level,
</pre>
<hr />
<pre>
1248       fflush (log_file);
1249       /* message */
1250       SET_COLOR (clear);
1251       fprintf (log_file, &quot; %s\n&quot;, message_str);
1252       fflush (log_file);
1253     }
1254     g_mutex_unlock (&amp;win_print_mutex);
1255 #endif
1256   } else {
1257     /* no color, all platforms */
1258 #define PRINT_FMT &quot; &quot;PID_FMT&quot; &quot;PTR_FMT&quot; %s &quot;CAT_FMT&quot; %s\n&quot;
1259     fprintf (log_file, &quot;%&quot; GST_TIME_FORMAT PRINT_FMT, GST_TIME_ARGS (elapsed),
1260         pid, g_thread_self (), gst_debug_level_get_name (level),
1261         gst_debug_category_get_name (category), file, line, function, obj,
1262         message_str);
1263     fflush (log_file);
1264 #undef PRINT_FMT
1265   }
1266 
1267   if (object != NULL)
<span class="line-modified">1268     g_free (obj);</span>
1269 }
1270 
1271 /**
1272  * gst_debug_level_get_name:
1273  * @level: the level to get the name for
1274  *
1275  * Get the string representation of a debugging level
1276  *
1277  * Returns: the name
1278  */
1279 const gchar *
1280 gst_debug_level_get_name (GstDebugLevel level)
1281 {
1282   switch (level) {
1283     case GST_LEVEL_NONE:
1284       return &quot;&quot;;
1285     case GST_LEVEL_ERROR:
1286       return &quot;ERROR  &quot;;
1287     case GST_LEVEL_WARNING:
1288       return &quot;WARN   &quot;;
</pre>
<hr />
<pre>
1587 void
1588 gst_debug_set_default_threshold (GstDebugLevel level)
1589 {
1590   g_atomic_int_set (&amp;__default_level, level);
1591   gst_debug_reset_all_thresholds ();
1592 }
1593 
1594 /**
1595  * gst_debug_get_default_threshold:
1596  *
1597  * Returns the default threshold that is used for new categories.
1598  *
1599  * Returns: the default threshold level
1600  */
1601 GstDebugLevel
1602 gst_debug_get_default_threshold (void)
1603 {
1604   return (GstDebugLevel) g_atomic_int_get (&amp;__default_level);
1605 }
1606 
<span class="line-added">1607 static gboolean</span>
<span class="line-added">1608 gst_debug_apply_entry (GstDebugCategory * cat, LevelNameEntry * entry)</span>
<span class="line-added">1609 {</span>
<span class="line-added">1610   if (!g_pattern_match_string (entry-&gt;pat, cat-&gt;name))</span>
<span class="line-added">1611     return FALSE;</span>
<span class="line-added">1612 </span>
<span class="line-added">1613   if (gst_is_initialized ())</span>
<span class="line-added">1614     GST_LOG (&quot;category %s matches pattern %p - gets set to level %d&quot;,</span>
<span class="line-added">1615         cat-&gt;name, entry-&gt;pat, entry-&gt;level);</span>
<span class="line-added">1616 </span>
<span class="line-added">1617   gst_debug_category_set_threshold (cat, entry-&gt;level);</span>
<span class="line-added">1618   return TRUE;</span>
<span class="line-added">1619 }</span>
<span class="line-added">1620 </span>
1621 static void
1622 gst_debug_reset_threshold (gpointer category, gpointer unused)
1623 {
1624   GstDebugCategory *cat = (GstDebugCategory *) category;
1625   GSList *walk;
1626 
1627   g_mutex_lock (&amp;__level_name_mutex);



1628 
<span class="line-modified">1629   for (walk = __level_name; walk != NULL; walk = walk-&gt;next) {</span>
<span class="line-modified">1630     if (gst_debug_apply_entry (cat, walk-&gt;data))</span>
<span class="line-modified">1631       break;</span>





1632   }

1633 

1634   g_mutex_unlock (&amp;__level_name_mutex);
<span class="line-added">1635 </span>
<span class="line-added">1636   if (walk == NULL)</span>
<span class="line-added">1637     gst_debug_category_set_threshold (cat, gst_debug_get_default_threshold ());</span>
1638 }
1639 
1640 static void
1641 gst_debug_reset_all_thresholds (void)
1642 {
1643   g_mutex_lock (&amp;__cat_mutex);
1644   g_slist_foreach (__categories, gst_debug_reset_threshold, NULL);
1645   g_mutex_unlock (&amp;__cat_mutex);
1646 }
1647 
1648 static void
1649 for_each_threshold_by_entry (gpointer data, gpointer user_data)
1650 {
1651   GstDebugCategory *cat = (GstDebugCategory *) data;
1652   LevelNameEntry *entry = (LevelNameEntry *) user_data;
1653 
<span class="line-modified">1654   gst_debug_apply_entry (cat, entry);</span>





1655 }
1656 
1657 /**
1658  * gst_debug_set_threshold_for_name:
1659  * @name: name of the categories to set
1660  * @level: level to set them to
1661  *
1662  * Sets all categories which match the given glob style pattern to the given
1663  * level.
1664  */
1665 void
1666 gst_debug_set_threshold_for_name (const gchar * name, GstDebugLevel level)
1667 {
1668   GPatternSpec *pat;
1669   LevelNameEntry *entry;
1670 
1671   g_return_if_fail (name != NULL);
1672 
1673   pat = g_pattern_spec_new (name);
1674   entry = g_slice_new (LevelNameEntry);
</pre>
<hr />
<pre>
2007     gst_debug_set_default_threshold (GST_LEVEL_DEFAULT);
2008 
2009   split = g_strsplit (list, &quot;,&quot;, 0);
2010 
2011   for (walk = split; *walk; walk++) {
2012     if (strchr (*walk, &#39;:&#39;)) {
2013       gchar **values = g_strsplit (*walk, &quot;:&quot;, 2);
2014 
2015       if (values[0] &amp;&amp; values[1]) {
2016         GstDebugLevel level;
2017         const gchar *category;
2018 
2019         if (parse_debug_category (values[0], &amp;category)
2020             &amp;&amp; parse_debug_level (values[1], &amp;level)) {
2021           gst_debug_set_threshold_for_name (category, level);
2022 
2023           /* bump min-level anyway to allow the category to be registered in the
2024            * future still */
2025           if (level &gt; _gst_debug_min) {
2026             _gst_debug_min = level;
<span class="line-modified">2027           }</span>
2028         }
2029       }
2030 
2031       g_strfreev (values);
2032     } else {
2033       GstDebugLevel level;
2034 
2035       if (parse_debug_level (*walk, &amp;level))
2036         gst_debug_set_default_threshold (level);
2037     }
2038   }
2039 
2040   g_strfreev (split);
2041 }
2042 
2043 /*** FUNCTION POINTERS ********************************************************/
2044 
2045 static GHashTable *__gst_function_pointers;     /* NULL */
2046 static GMutex __dbg_functions_mutex;
2047 
</pre>
<hr />
<pre>
2054 #ifdef HAVE_DLADDR
2055   Dl_info dl_info;
2056 #endif
2057 
2058   if (G_UNLIKELY (func == NULL))
2059     return &quot;(NULL)&quot;;
2060 
2061   g_mutex_lock (&amp;__dbg_functions_mutex);
2062   if (G_LIKELY (__gst_function_pointers)) {
2063     ptrname = g_hash_table_lookup (__gst_function_pointers, (gpointer) func);
2064     g_mutex_unlock (&amp;__dbg_functions_mutex);
2065     if (G_LIKELY (ptrname))
2066       return ptrname;
2067   } else {
2068     g_mutex_unlock (&amp;__dbg_functions_mutex);
2069   }
2070   /* we need to create an entry in the hash table for this one so we don&#39;t leak
2071    * the name */
2072 #ifdef HAVE_DLADDR
2073   if (dladdr ((gpointer) func, &amp;dl_info) &amp;&amp; dl_info.dli_sname) {
<span class="line-modified">2074     const gchar *name = g_intern_string (dl_info.dli_sname);</span>
2075 
2076     _gst_debug_register_funcptr (func, name);
2077     return name;
2078   } else
2079 #endif
2080   {
2081     gchar *name = g_strdup_printf (&quot;%p&quot;, (gpointer) func);
<span class="line-added">2082     const gchar *iname = g_intern_string (name);</span>
2083 
<span class="line-modified">2084     g_free (name);</span>
<span class="line-modified">2085 </span>
<span class="line-added">2086     _gst_debug_register_funcptr (func, iname);</span>
<span class="line-added">2087     return iname;</span>
2088   }
2089 }
2090 
2091 void
2092 _gst_debug_register_funcptr (GstDebugFuncPtr func, const gchar * ptrname)
2093 {
2094   gpointer ptr = (gpointer) func;
2095 
2096   g_mutex_lock (&amp;__dbg_functions_mutex);
2097 
2098   if (!__gst_function_pointers)
2099     __gst_function_pointers = g_hash_table_new (g_direct_hash, g_direct_equal);
<span class="line-modified">2100   if (!g_hash_table_lookup (__gst_function_pointers, ptr)) {</span>
2101     g_hash_table_insert (__gst_function_pointers, ptr, (gpointer) ptrname);
<span class="line-added">2102   }</span>
<span class="line-added">2103 </span>
<span class="line-added">2104   g_mutex_unlock (&amp;__dbg_functions_mutex);</span>
<span class="line-added">2105 }</span>
<span class="line-added">2106 </span>
<span class="line-added">2107 void</span>
<span class="line-added">2108 _priv_gst_debug_cleanup (void)</span>
<span class="line-added">2109 {</span>
<span class="line-added">2110   g_mutex_lock (&amp;__dbg_functions_mutex);</span>
<span class="line-added">2111 </span>
<span class="line-added">2112   if (__gst_function_pointers) {</span>
<span class="line-added">2113     g_hash_table_unref (__gst_function_pointers);</span>
<span class="line-added">2114     __gst_function_pointers = NULL;</span>
<span class="line-added">2115   }</span>
2116 
2117   g_mutex_unlock (&amp;__dbg_functions_mutex);
2118 }
2119 
2120 static void
2121 gst_info_dump_mem_line (gchar * linebuf, gsize linebuf_size,
2122     const guint8 * mem, gsize mem_offset, gsize mem_size)
2123 {
2124   gchar hexstr[50], ascstr[18], digitstr[4];
2125 
2126   if (mem_size &gt; 16)
2127     mem_size = 16;
2128 
2129   hexstr[0] = &#39;\0&#39;;
2130   ascstr[0] = &#39;\0&#39;;
2131 
2132   if (mem != NULL) {
2133     guint i = 0;
2134 
2135     mem += mem_offset;
</pre>
<hr />
<pre>
2178 
2179 GstDebugCategory *
2180 _gst_debug_category_new (const gchar * name, guint color,
2181     const gchar * description)
2182 {
2183   return NULL;
2184 }
2185 
2186 void
2187 _gst_debug_register_funcptr (GstDebugFuncPtr func, const gchar * ptrname)
2188 {
2189 }
2190 
2191 /* This function MUST NOT return NULL */
2192 const gchar *
2193 _gst_debug_nameof_funcptr (GstDebugFuncPtr func)
2194 {
2195   return &quot;(NULL)&quot;;
2196 }
2197 
<span class="line-added">2198 void</span>
<span class="line-added">2199 _priv_gst_debug_cleanup (void)</span>
<span class="line-added">2200 {</span>
<span class="line-added">2201 }</span>
<span class="line-added">2202 </span>
2203 void
2204 gst_debug_log (GstDebugCategory * category, GstDebugLevel level,
2205     const gchar * file, const gchar * function, gint line,
2206     GObject * object, const gchar * format, ...)
2207 {
2208 }
2209 
2210 void
2211 gst_debug_log_valist (GstDebugCategory * category, GstDebugLevel level,
2212     const gchar * file, const gchar * function, gint line,
2213     GObject * object, const gchar * format, va_list args)
2214 {
2215 }
2216 
2217 const gchar *
2218 gst_debug_message_get (GstDebugMessage * message)
2219 {
2220   return &quot;&quot;;
2221 }
2222 
</pre>
<hr />
<pre>
2640  * This function differs from g_printerr() in that it supports the additional
2641  * printf specifiers that are supported by GStreamer&#39;s debug logging system,
2642  * such as #GST_PTR_FORMAT and #GST_SEGMENT_FORMAT.
2643  *
2644  * This function is primarily for printing debug output.
2645  *
2646  * Since: 1.12
2647  */
2648 void
2649 gst_printerrln (const gchar * format, ...)
2650 {
2651   va_list args;
2652   gchar *str;
2653 
2654   va_start (args, format);
2655   str = gst_info_strdup_vprintf (format, args);
2656   va_end (args);
2657 
2658   g_printerr (&quot;%s\n&quot;, str);
2659   g_free (str);
<span class="line-modified">2660 }</span>
2661 
2662 #ifdef HAVE_UNWIND
2663 #ifdef HAVE_DW
2664 static gboolean
2665 append_debug_info (GString * trace, Dwfl * dwfl, const void *ip)
2666 {
2667   Dwfl_Line *line;
2668   Dwarf_Addr addr;
2669   Dwfl_Module *module;
2670   const gchar *function_name;
2671 
2672   if (dwfl_linux_proc_report (dwfl, getpid ()) != 0)
2673     return FALSE;
2674 
2675   if (dwfl_report_end (dwfl, NULL, NULL))
2676     return FALSE;
2677 
2678   addr = (uintptr_t) ip;
2679   module = dwfl_addrmodule (dwfl, addr);
2680   function_name = dwfl_module_addrname (module, addr);
2681 
2682   g_string_append_printf (trace, &quot;%s (&quot;, function_name ? function_name : &quot;??&quot;);
2683 
2684   line = dwfl_getsrc (dwfl, addr);
2685   if (line != NULL) {
2686     gint nline;
2687     Dwarf_Addr addr;
2688     const gchar *filename = dwfl_lineinfo (line, &amp;addr,
2689         &amp;nline, NULL, NULL, NULL);
2690 
2691     g_string_append_printf (trace, &quot;%s:%d&quot;, strrchr (filename,
2692             G_DIR_SEPARATOR) + 1, nline);
2693   } else {
2694     const gchar *eflfile = NULL;
2695 
2696     dwfl_module_info (module, NULL, NULL, NULL, NULL, NULL, &amp;eflfile, NULL);
2697     g_string_append_printf (trace, &quot;%s:%p&quot;, eflfile ? eflfile : &quot;??&quot;, ip);
<span class="line-modified">2698   }</span>
2699 
2700   return TRUE;
2701 }
2702 #endif /* HAVE_DW */
2703 
2704 static gchar *
2705 generate_unwind_trace (GstStackTraceFlags flags)
2706 {
2707   gint unret;
2708   unw_context_t uc;
2709   unw_cursor_t cursor;
2710   gboolean use_libunwind = TRUE;
2711   GString *trace = g_string_new (NULL);
2712 
2713 #ifdef HAVE_DW
2714   Dwfl *dwfl = NULL;
2715   Dwfl_Callbacks callbacks = {
2716     .find_elf = dwfl_linux_proc_find_elf,
2717     .find_debuginfo = dwfl_standard_find_debuginfo,
2718   };
</pre>
<hr />
<pre>
2785 
2786   trace = g_string_new (NULL);
2787   nptrs = backtrace (buffer, BT_BUF_SIZE);
2788 
2789   strings = backtrace_symbols (buffer, nptrs);
2790 
2791   if (!strings)
2792     return NULL;
2793 
2794   for (j = 0; j &lt; nptrs; j++)
2795     g_string_append_printf (trace, &quot;%s\n&quot;, strings[j]);
2796 
2797   free (strings);
2798 
2799   return g_string_free (trace, FALSE);
2800 }
2801 #else
2802 #define generate_backtrace_trace() NULL
2803 #endif /* HAVE_BACKTRACE */
2804 
<span class="line-added">2805 #ifdef HAVE_DBGHELP</span>
<span class="line-added">2806 static void</span>
<span class="line-added">2807 dbghelp_initialize_symbols (HANDLE process)</span>
<span class="line-added">2808 {</span>
<span class="line-added">2809   static gsize initialization_value = 0;</span>
<span class="line-added">2810 </span>
<span class="line-added">2811   if (g_once_init_enter (&amp;initialization_value)) {</span>
<span class="line-added">2812     GST_INFO (&quot;Initializing Windows symbol handler&quot;);</span>
<span class="line-added">2813     SymSetOptions (SYMOPT_LOAD_LINES);</span>
<span class="line-added">2814     SymInitialize (process, NULL, TRUE);</span>
<span class="line-added">2815     GST_INFO (&quot;Initialized Windows symbol handler&quot;);</span>
<span class="line-added">2816 </span>
<span class="line-added">2817     g_once_init_leave (&amp;initialization_value, 1);</span>
<span class="line-added">2818   }</span>
<span class="line-added">2819 }</span>
<span class="line-added">2820 </span>
<span class="line-added">2821 static gchar *</span>
<span class="line-added">2822 generate_dbghelp_trace (void)</span>
<span class="line-added">2823 {</span>
<span class="line-added">2824   HANDLE process = GetCurrentProcess ();</span>
<span class="line-added">2825   HANDLE thread = GetCurrentThread ();</span>
<span class="line-added">2826   IMAGEHLP_MODULE64 module_info;</span>
<span class="line-added">2827   DWORD machine;</span>
<span class="line-added">2828   CONTEXT context;</span>
<span class="line-added">2829   STACKFRAME64 frame = { 0 };</span>
<span class="line-added">2830   PVOID save_context;</span>
<span class="line-added">2831   GString *trace = g_string_new (NULL);</span>
<span class="line-added">2832 </span>
<span class="line-added">2833   dbghelp_initialize_symbols (process);</span>
<span class="line-added">2834 </span>
<span class="line-added">2835   memset (&amp;context, 0, sizeof (CONTEXT));</span>
<span class="line-added">2836   context.ContextFlags = CONTEXT_FULL;</span>
<span class="line-added">2837 </span>
<span class="line-added">2838   RtlCaptureContext (&amp;context);</span>
<span class="line-added">2839 </span>
<span class="line-added">2840   frame.AddrPC.Mode = AddrModeFlat;</span>
<span class="line-added">2841   frame.AddrStack.Mode = AddrModeFlat;</span>
<span class="line-added">2842   frame.AddrFrame.Mode = AddrModeFlat;</span>
<span class="line-added">2843 </span>
<span class="line-added">2844 #if (defined _M_IX86)</span>
<span class="line-added">2845   machine = IMAGE_FILE_MACHINE_I386;</span>
<span class="line-added">2846   frame.AddrFrame.Offset = context.Ebp;</span>
<span class="line-added">2847   frame.AddrPC.Offset = context.Eip;</span>
<span class="line-added">2848   frame.AddrStack.Offset = context.Esp;</span>
<span class="line-added">2849 #elif (defined _M_X64)</span>
<span class="line-added">2850   machine = IMAGE_FILE_MACHINE_AMD64;</span>
<span class="line-added">2851   frame.AddrFrame.Offset = context.Rbp;</span>
<span class="line-added">2852   frame.AddrPC.Offset = context.Rip;</span>
<span class="line-added">2853   frame.AddrStack.Offset = context.Rsp;</span>
<span class="line-added">2854 #else</span>
<span class="line-added">2855   goto done;</span>
<span class="line-added">2856 #endif</span>
<span class="line-added">2857 </span>
<span class="line-added">2858   module_info.SizeOfStruct = sizeof (module_info);</span>
<span class="line-added">2859   save_context = (machine == IMAGE_FILE_MACHINE_I386) ? NULL : &amp;context;</span>
<span class="line-added">2860 </span>
<span class="line-added">2861   while (TRUE) {</span>
<span class="line-added">2862     char buffer[sizeof (SYMBOL_INFO) + MAX_SYM_NAME * sizeof (TCHAR)];</span>
<span class="line-added">2863     PSYMBOL_INFO symbol = (PSYMBOL_INFO) buffer;</span>
<span class="line-added">2864     IMAGEHLP_LINE64 line;</span>
<span class="line-added">2865     DWORD displacement = 0;</span>
<span class="line-added">2866 </span>
<span class="line-added">2867     symbol-&gt;SizeOfStruct = sizeof (SYMBOL_INFO);</span>
<span class="line-added">2868     symbol-&gt;MaxNameLen = MAX_SYM_NAME;</span>
<span class="line-added">2869 </span>
<span class="line-added">2870     line.SizeOfStruct = sizeof (line);</span>
<span class="line-added">2871 </span>
<span class="line-added">2872     if (!StackWalk64 (machine, process, thread, &amp;frame, save_context, 0,</span>
<span class="line-added">2873             SymFunctionTableAccess64, SymGetModuleBase64, 0))</span>
<span class="line-added">2874       break;</span>
<span class="line-added">2875 </span>
<span class="line-added">2876     if (SymFromAddr (process, frame.AddrPC.Offset, 0, symbol))</span>
<span class="line-added">2877       g_string_append_printf (trace, &quot;%s &quot;, symbol-&gt;Name);</span>
<span class="line-added">2878     else</span>
<span class="line-added">2879       g_string_append (trace, &quot;?? &quot;);</span>
<span class="line-added">2880 </span>
<span class="line-added">2881     if (SymGetLineFromAddr64 (process, frame.AddrPC.Offset, &amp;displacement,</span>
<span class="line-added">2882             &amp;line))</span>
<span class="line-added">2883       g_string_append_printf (trace, &quot;(%s:%u)&quot;, line.FileName, line.LineNumber);</span>
<span class="line-added">2884     else if (SymGetModuleInfo64 (process, frame.AddrPC.Offset, &amp;module_info))</span>
<span class="line-added">2885       g_string_append_printf (trace, &quot;(%s)&quot;, module_info.ImageName);</span>
<span class="line-added">2886     else</span>
<span class="line-added">2887       g_string_append_printf (trace, &quot;(%s)&quot;, &quot;??&quot;);</span>
<span class="line-added">2888 </span>
<span class="line-added">2889     g_string_append (trace, &quot;\n&quot;);</span>
<span class="line-added">2890   }</span>
<span class="line-added">2891 </span>
<span class="line-added">2892 done:</span>
<span class="line-added">2893   return g_string_free (trace, FALSE);</span>
<span class="line-added">2894 }</span>
<span class="line-added">2895 #endif /* HAVE_DBGHELP */</span>
<span class="line-added">2896 </span>
2897 /**
2898  * gst_debug_get_stack_trace:
2899  * @flags: A set of #GstStackTraceFlags to determine how the stack
2900  * trace should look like. Pass 0 to retrieve a minimal backtrace.
2901  *
2902  * Returns: (nullable): a stack trace, if libunwind or glibc backtrace are
2903  * present, else %NULL.
2904  *
2905  * Since: 1.12
2906  */
2907 gchar *
2908 gst_debug_get_stack_trace (GstStackTraceFlags flags)
2909 {
2910   gchar *trace = NULL;
2911 #ifdef HAVE_BACKTRACE
2912   gboolean have_backtrace = TRUE;
2913 #else
2914   gboolean have_backtrace = FALSE;
2915 #endif
2916 
2917 #ifdef HAVE_UNWIND
2918   if ((flags &amp; GST_STACK_TRACE_SHOW_FULL) || !have_backtrace)
2919     trace = generate_unwind_trace (flags);
2920 #endif /* HAVE_UNWIND */
2921 
<span class="line-added">2922 #ifdef HAVE_DBGHELP</span>
<span class="line-added">2923   trace = generate_dbghelp_trace ();</span>
<span class="line-added">2924 #endif</span>
<span class="line-added">2925 </span>
2926   if (trace)
2927     return trace;
2928   else if (have_backtrace)
2929     return generate_backtrace_trace ();
2930 
2931   return NULL;
2932 }
2933 
2934 /**
2935  * gst_debug_print_stack_trace:
2936  *
<span class="line-modified">2937  * If libunwind, glibc backtrace or DbgHelp are present</span>
2938  * a stack trace is printed.
2939  */
2940 void
2941 gst_debug_print_stack_trace (void)
2942 {
2943   gchar *trace = gst_debug_get_stack_trace (GST_STACK_TRACE_SHOW_FULL);
2944 
2945   if (trace)
2946     g_print (&quot;%s\n&quot;, trace);
2947 
2948   g_free (trace);
2949 }
2950 
2951 #ifndef GST_DISABLE_GST_DEBUG
2952 typedef struct
2953 {
2954   guint max_size_per_thread;
2955   guint thread_timeout;
2956   GQueue threads;
2957   GHashTable *thread_index;
</pre>
<hr />
<pre>
2972 
2973 static void
2974 gst_ring_buffer_logger_log (GstDebugCategory * category,
2975     GstDebugLevel level,
2976     const gchar * file,
2977     const gchar * function,
2978     gint line, GObject * object, GstDebugMessage * message, gpointer user_data)
2979 {
2980   GstRingBufferLogger *logger = user_data;
2981   gint pid;
2982   GThread *thread;
2983   GstClockTime elapsed;
2984   gchar *obj = NULL;
2985   gchar c;
2986   gchar *output;
2987   gsize output_len;
2988   GstRingBufferLog *log;
2989   gint64 now = g_get_monotonic_time ();
2990   const gchar *message_str = gst_debug_message_get (message);
2991 
<span class="line-added">2992   /* __FILE__ might be a file name or an absolute path or a</span>
<span class="line-added">2993    * relative path, irrespective of the exact compiler used,</span>
<span class="line-added">2994    * in which case we want to shorten it to the filename for</span>
<span class="line-added">2995    * readability. */</span>
<span class="line-added">2996   c = file[0];</span>
<span class="line-added">2997   if (c == &#39;.&#39; || c == &#39;/&#39; || c == &#39;\\&#39; || (c != &#39;\0&#39; &amp;&amp; file[1] == &#39;:&#39;)) {</span>
<span class="line-added">2998     file = gst_path_basename (file);</span>
<span class="line-added">2999   }</span>
<span class="line-added">3000 </span>
<span class="line-added">3001   if (object) {</span>
<span class="line-added">3002     obj = gst_debug_print_object (object);</span>
<span class="line-added">3003   } else {</span>
<span class="line-added">3004     obj = (gchar *) &quot;&quot;;</span>
<span class="line-added">3005   }</span>
<span class="line-added">3006 </span>
<span class="line-added">3007   elapsed = GST_CLOCK_DIFF (_priv_gst_start_time, gst_util_get_timestamp ());</span>
<span class="line-added">3008   pid = getpid ();</span>
<span class="line-added">3009   thread = g_thread_self ();</span>
<span class="line-added">3010 </span>
<span class="line-added">3011   /* no color, all platforms */</span>
<span class="line-added">3012 #define PRINT_FMT &quot; &quot;PID_FMT&quot; &quot;PTR_FMT&quot; %s &quot;CAT_FMT&quot; %s\n&quot;</span>
<span class="line-added">3013   output =</span>
<span class="line-added">3014       g_strdup_printf (&quot;%&quot; GST_TIME_FORMAT PRINT_FMT, GST_TIME_ARGS (elapsed),</span>
<span class="line-added">3015       pid, thread, gst_debug_level_get_name (level),</span>
<span class="line-added">3016       gst_debug_category_get_name (category), file, line, function, obj,</span>
<span class="line-added">3017       message_str);</span>
<span class="line-added">3018 #undef PRINT_FMT</span>
<span class="line-added">3019 </span>
<span class="line-added">3020   output_len = strlen (output);</span>
<span class="line-added">3021 </span>
<span class="line-added">3022   if (object != NULL)</span>
<span class="line-added">3023     g_free (obj);</span>
<span class="line-added">3024 </span>
3025   G_LOCK (ring_buffer_logger);
3026 
3027   if (logger-&gt;thread_timeout &gt; 0) {
<span class="line-added">3028     gchar *buf;</span>
<span class="line-added">3029 </span>
3030     /* Remove all threads that saw no output since thread_timeout seconds.
3031      * By construction these are all at the tail of the queue, and the queue
3032      * is ordered by last use, so we just need to look at the tail.
3033      */
3034     while (logger-&gt;threads.tail) {
3035       log = logger-&gt;threads.tail-&gt;data;
3036       if (log-&gt;last_use + logger-&gt;thread_timeout * G_USEC_PER_SEC &gt;= now)
3037         break;
3038 
3039       g_hash_table_remove (logger-&gt;thread_index, log-&gt;thread);
<span class="line-modified">3040       while ((buf = g_queue_pop_head (&amp;log-&gt;log)))</span>
<span class="line-modified">3041         g_free (buf);</span>
3042       g_free (log);
3043       g_queue_pop_tail (&amp;logger-&gt;threads);
3044     }
3045   }
3046 
3047   /* Get logger for this thread, and put it back at the
3048    * head of the threads queue */

3049   log = g_hash_table_lookup (logger-&gt;thread_index, thread);
3050   if (!log) {
3051     log = g_new0 (GstRingBufferLog, 1);
3052     g_queue_init (&amp;log-&gt;log);
3053     log-&gt;log_size = 0;
3054     g_queue_push_head (&amp;logger-&gt;threads, log);
3055     log-&gt;link = logger-&gt;threads.head;
3056     log-&gt;thread = thread;
3057     g_hash_table_insert (logger-&gt;thread_index, thread, log);
3058   } else {
3059     g_queue_unlink (&amp;logger-&gt;threads, log-&gt;link);
3060     g_queue_push_head_link (&amp;logger-&gt;threads, log-&gt;link);
3061   }
3062   log-&gt;last_use = now;
3063 






























3064   if (output_len &lt; logger-&gt;max_size_per_thread) {
3065     gchar *buf;
3066 
3067     /* While using a GQueue here is not the most efficient thing to do, we
3068      * have to allocate a string for every output anyway and could just store
3069      * that instead of copying it to an actual ringbuffer.
3070      * Better than GQueue would be GstQueueArray, but that one is in
3071      * libgstbase and we can&#39;t use it here. That one allocation will not make
3072      * much of a difference anymore, considering the number of allocations
3073      * needed to get to this point...
3074      */
3075     while (log-&gt;log_size + output_len &gt; logger-&gt;max_size_per_thread) {
3076       buf = g_queue_pop_head (&amp;log-&gt;log);
3077       log-&gt;log_size -= strlen (buf);
3078       g_free (buf);
3079     }
3080     g_queue_push_tail (&amp;log-&gt;log, output);
3081     log-&gt;log_size += output_len;
3082   } else {
3083     gchar *buf;
3084 
3085     /* Can&#39;t really write anything as the line is bigger than the maximum
3086      * allowed log size already, so just remove everything */
3087 
3088     while ((buf = g_queue_pop_head (&amp;log-&gt;log)))
3089       g_free (buf);
3090     g_free (output);
3091     log-&gt;log_size = 0;
3092   }
3093 



3094   G_UNLOCK (ring_buffer_logger);
3095 }
3096 
3097 /**
3098  * gst_debug_ring_buffer_logger_get_logs:
3099  *
3100  * Fetches the current logs per thread from the ring buffer logger. See
3101  * gst_debug_add_ring_buffer_logger() for details.
3102  *
3103  * Returns: (transfer full) (array zero-terminated): NULL-terminated array of
3104  * strings with the debug output per thread
3105  *
3106  * Since: 1.14
3107  */
3108 gchar **
3109 gst_debug_ring_buffer_logger_get_logs (void)
3110 {
3111   gchar **logs, **tmp;
3112   GList *l;
3113 
</pre>
</td>
</tr>
</table>
<center><a href="gstghostpad.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstinfo.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>