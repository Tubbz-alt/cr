<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gtype.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GObject - GLib Type, Object, Parameter and Signal Library
   2  * Copyright (C) 1998-1999, 2000-2001 Tim Janik and Red Hat, Inc.
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General
  15  * Public License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * MT safe
  20  */
  21 
  22 #include &quot;config.h&quot;
  23 
  24 #include &quot;../glib/gvalgrind.h&quot;
  25 #include &lt;string.h&gt;
  26 
  27 #include &quot;gtype.h&quot;
  28 #include &quot;gtype-private.h&quot;
  29 #include &quot;gtypeplugin.h&quot;
  30 #include &quot;gvaluecollector.h&quot;
  31 #include &quot;gatomicarray.h&quot;
  32 #include &quot;gobject_trace.h&quot;
  33 
  34 #include &quot;glib-private.h&quot;
  35 #include &quot;gconstructor.h&quot;
  36 
  37 #ifdef G_OS_WIN32
  38 #include &lt;windows.h&gt;
  39 #endif
  40 
  41 #ifdef  G_ENABLE_DEBUG
  42 #define IF_DEBUG(debug_type)    if (_g_type_debug_flags &amp; G_TYPE_DEBUG_ ## debug_type)
  43 #endif
  44 
  45 /**
  46  * SECTION:gtype
  47  * @short_description: The GLib Runtime type identification and
  48  *     management system
  49  * @title:Type Information
  50  *
  51  * The GType API is the foundation of the GObject system.  It provides the
  52  * facilities for registering and managing all fundamental data types,
  53  * user-defined object and interface types.
  54  *
  55  * For type creation and registration purposes, all types fall into one of
  56  * two categories: static or dynamic.  Static types are never loaded or
  57  * unloaded at run-time as dynamic types may be.  Static types are created
  58  * with g_type_register_static() that gets type specific information passed
  59  * in via a #GTypeInfo structure.
  60  *
  61  * Dynamic types are created with g_type_register_dynamic() which takes a
  62  * #GTypePlugin structure instead. The remaining type information (the
  63  * #GTypeInfo structure) is retrieved during runtime through #GTypePlugin
  64  * and the g_type_plugin_*() API.
  65  *
  66  * These registration functions are usually called only once from a
  67  * function whose only purpose is to return the type identifier for a
  68  * specific class.  Once the type (or class or interface) is registered,
  69  * it may be instantiated, inherited, or implemented depending on exactly
  70  * what sort of type it is.
  71  *
  72  * There is also a third registration function for registering fundamental
  73  * types called g_type_register_fundamental() which requires both a #GTypeInfo
  74  * structure and a #GTypeFundamentalInfo structure but it is seldom used
  75  * since most fundamental types are predefined rather than user-defined.
  76  *
  77  * Type instance and class structs are limited to a total of 64 KiB,
  78  * including all parent types. Similarly, type instances&#39; private data
  79  * (as created by G_ADD_PRIVATE()) are limited to a total of
  80  * 64 KiB. If a type instance needs a large static buffer, allocate it
  81  * separately (typically by using #GArray or #GPtrArray) and put a pointer
  82  * to the buffer in the structure.
  83  *
  84  * As mentioned in the [GType conventions][gtype-conventions], type names must
  85  * be at least three characters long. There is no upper length limit. The first
  86  * character must be a letter (a or A) or an underscore (). Subsequent
  87  * characters can be letters, numbers or any of .
  88  */
  89 
  90 
  91 /* NOTE: some functions (some internal variants and exported ones)
  92  * invalidate data portions of the TypeNodes. if external functions/callbacks
  93  * are called, pointers to memory maintained by TypeNodes have to be looked up
  94  * again. this affects most of the struct TypeNode fields, e.g. -&gt;children or
  95  * CLASSED_NODE_IFACES_ENTRIES() respectively IFACE_NODE_PREREQUISITES() (but
  96  * not -&gt;supers[]), as all those memory portions can get realloc()ed during
  97  * callback invocation.
  98  *
  99  * LOCKING:
 100  * lock handling issues when calling static functions are indicated by
 101  * uppercase letter postfixes, all static functions have to have
 102  * one of the below postfixes:
 103  * - _I:    [Indifferent about locking]
 104  *   function doesn&#39;t care about locks at all
 105  * - _U:    [Unlocked invocation]
 106  *   no read or write lock has to be held across function invocation
 107  *   (locks may be acquired and released during invocation though)
 108  * - _L:    [Locked invocation]
 109  *   a write lock or more than 0 read locks have to be held across
 110  *   function invocation
 111  * - _W:    [Write-locked invocation]
 112  *   a write lock has to be held across function invocation
 113  * - _Wm:   [Write-locked invocation, mutatable]
 114  *   like _W, but the write lock might be released and reacquired
 115  *   during invocation, watch your pointers
 116  * - _WmREC:    [Write-locked invocation, mutatable, recursive]
 117  *   like _Wm, but also acquires recursive mutex class_init_rec_mutex
 118  */
 119 
 120 #ifdef LOCK_DEBUG
 121 #define G_READ_LOCK(rw_lock)    do { g_printerr (G_STRLOC &quot;: readL++\n&quot;); g_rw_lock_reader_lock (rw_lock); } while (0)
 122 #define G_READ_UNLOCK(rw_lock)  do { g_printerr (G_STRLOC &quot;: readL--\n&quot;); g_rw_lock_reader_unlock (rw_lock); } while (0)
 123 #define G_WRITE_LOCK(rw_lock)   do { g_printerr (G_STRLOC &quot;: writeL++\n&quot;); g_rw_lock_writer_lock (rw_lock); } while (0)
 124 #define G_WRITE_UNLOCK(rw_lock) do { g_printerr (G_STRLOC &quot;: writeL--\n&quot;); g_rw_lock_writer_unlock (rw_lock); } while (0)
 125 #else
 126 #define G_READ_LOCK(rw_lock)    g_rw_lock_reader_lock (rw_lock)
 127 #define G_READ_UNLOCK(rw_lock)  g_rw_lock_reader_unlock (rw_lock)
 128 #define G_WRITE_LOCK(rw_lock)   g_rw_lock_writer_lock (rw_lock)
 129 #define G_WRITE_UNLOCK(rw_lock) g_rw_lock_writer_unlock (rw_lock)
 130 #endif
 131 #define INVALID_RECURSION(func, arg, type_name) G_STMT_START{ \
 132     static const gchar _action[] = &quot; invalidly modified type &quot;;  \
 133     gpointer _arg = (gpointer) (arg); const gchar *_tname = (type_name), *_fname = (func); \
 134     if (_arg) \
 135       g_error (&quot;%s(%p)%s&#39;%s&#39;&quot;, _fname, _arg, _action, _tname); \
 136     else \
 137       g_error (&quot;%s()%s&#39;%s&#39;&quot;, _fname, _action, _tname); \
 138 }G_STMT_END
 139 #define g_assert_type_system_initialized() \
 140   g_assert (static_quark_type_flags)
 141 
 142 #define TYPE_FUNDAMENTAL_FLAG_MASK (G_TYPE_FLAG_CLASSED | \
 143                     G_TYPE_FLAG_INSTANTIATABLE | \
 144                     G_TYPE_FLAG_DERIVABLE | \
 145                     G_TYPE_FLAG_DEEP_DERIVABLE)
 146 #define TYPE_FLAG_MASK         (G_TYPE_FLAG_ABSTRACT | G_TYPE_FLAG_VALUE_ABSTRACT)
 147 #define SIZEOF_FUNDAMENTAL_INFO    ((gssize) MAX (MAX (sizeof (GTypeFundamentalInfo), \
 148                                sizeof (gpointer)), \
 149                                                   sizeof (glong)))
 150 
 151 /* The 2*sizeof(size_t) alignment here is borrowed from
 152  * GNU libc, so it should be good most everywhere.
 153  * It is more conservative than is needed on some 64-bit
 154  * platforms, but ia64 does require a 16-byte alignment.
 155  * The SIMD extensions for x86 and ppc32 would want a
 156  * larger alignment than this, but we don&#39;t need to
 157  * do better than malloc.
 158  */
 159 #define STRUCT_ALIGNMENT (2 * sizeof (gsize))
 160 #define ALIGN_STRUCT(offset) \
 161       ((offset + (STRUCT_ALIGNMENT - 1)) &amp; -STRUCT_ALIGNMENT)
 162 
 163 
 164 /* --- typedefs --- */
 165 typedef struct _TypeNode        TypeNode;
 166 typedef struct _CommonData      CommonData;
 167 typedef struct _BoxedData       BoxedData;
 168 typedef struct _IFaceData       IFaceData;
 169 typedef struct _ClassData       ClassData;
 170 typedef struct _InstanceData    InstanceData;
 171 typedef union  _TypeData        TypeData;
 172 typedef struct _IFaceEntries    IFaceEntries;
 173 typedef struct _IFaceEntry      IFaceEntry;
 174 typedef struct _IFaceHolder IFaceHolder;
 175 
 176 
 177 /* --- prototypes --- */
 178 static inline GTypeFundamentalInfo* type_node_fundamental_info_I    (TypeNode       *node);
 179 static        void          type_add_flags_W        (TypeNode       *node,
 180                                      GTypeFlags      flags);
 181 static        void          type_data_make_W        (TypeNode       *node,
 182                                      const GTypeInfo    *info,
 183                                      const GTypeValueTable  *value_table);
 184 static inline void          type_data_ref_Wm        (TypeNode       *node);
 185 static inline void          type_data_unref_U               (TypeNode       *node,
 186                                      gboolean        uncached);
 187 static void             type_data_last_unref_Wm     (TypeNode *              node,
 188                                      gboolean        uncached);
 189 static inline gpointer          type_get_qdata_L        (TypeNode       *node,
 190                                      GQuark          quark);
 191 static inline void          type_set_qdata_W        (TypeNode       *node,
 192                                      GQuark          quark,
 193                                      gpointer        data);
 194 static IFaceHolder*         type_iface_peek_holder_L    (TypeNode       *iface,
 195                                      GType           instance_type);
 196 static gboolean                         type_iface_vtable_base_init_Wm  (TypeNode               *iface,
 197                                                                          TypeNode               *node);
 198 static void                             type_iface_vtable_iface_init_Wm (TypeNode               *iface,
 199                                                                          TypeNode               *node);
 200 static gboolean             type_node_is_a_L        (TypeNode       *node,
 201                                      TypeNode       *iface_node);
 202 
 203 
 204 /* --- enumeration --- */
 205 
 206 /* The InitState enumeration is used to track the progress of initializing
 207  * both classes and interface vtables. Keeping the state of initialization
 208  * is necessary to handle new interfaces being added while we are initializing
 209  * the class or other interfaces.
 210  */
 211 typedef enum
 212 {
 213   UNINITIALIZED,
 214   BASE_CLASS_INIT,
 215   BASE_IFACE_INIT,
 216   CLASS_INIT,
 217   IFACE_INIT,
 218   INITIALIZED
 219 } InitState;
 220 
 221 /* --- structures --- */
 222 struct _TypeNode
 223 {
 224   guint volatile ref_count;
 225 #ifdef G_ENABLE_DEBUG
 226   guint volatile instance_count;
 227 #endif
 228   GTypePlugin *plugin;
 229   guint        n_children; /* writable with lock */
 230   guint        n_supers : 8;
 231   guint        n_prerequisites : 9;
 232   guint        is_classed : 1;
 233   guint        is_instantiatable : 1;
 234   guint        mutatable_check_cache : 1;   /* combines some common path checks */
 235   GType       *children; /* writable with lock */
 236   TypeData * volatile data;
 237   GQuark       qname;
 238   GData       *global_gdata;
 239   union {
 240     GAtomicArray iface_entries;     /* for !iface types */
 241     GAtomicArray offsets;
 242   } _prot;
 243   GType       *prerequisites;
 244   GType        supers[1]; /* flexible array */
 245 };
 246 
 247 #define SIZEOF_BASE_TYPE_NODE()         (G_STRUCT_OFFSET (TypeNode, supers))
 248 #define MAX_N_SUPERS                (255)
 249 #define MAX_N_CHILDREN              (G_MAXUINT)
 250 #define MAX_N_INTERFACES            (255) /* Limited by offsets being 8 bits */
 251 #define MAX_N_PREREQUISITES         (511)
 252 #define NODE_TYPE(node)             (node-&gt;supers[0])
 253 #define NODE_PARENT_TYPE(node)          (node-&gt;supers[1])
 254 #define NODE_FUNDAMENTAL_TYPE(node)     (node-&gt;supers[node-&gt;n_supers])
 255 #define NODE_NAME(node)             (g_quark_to_string (node-&gt;qname))
 256 #define NODE_REFCOUNT(node)                     ((guint) g_atomic_int_get ((int *) &amp;(node)-&gt;ref_count))
 257 #define NODE_IS_BOXED(node)         (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_BOXED)
 258 #define NODE_IS_IFACE(node)         (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_INTERFACE)
 259 #define CLASSED_NODE_IFACES_ENTRIES(node)   (&amp;(node)-&gt;_prot.iface_entries)
 260 #define CLASSED_NODE_IFACES_ENTRIES_LOCKED(node)(G_ATOMIC_ARRAY_GET_LOCKED(CLASSED_NODE_IFACES_ENTRIES((node)), IFaceEntries))
 261 #define IFACE_NODE_N_PREREQUISITES(node)    ((node)-&gt;n_prerequisites)
 262 #define IFACE_NODE_PREREQUISITES(node)      ((node)-&gt;prerequisites)
 263 #define iface_node_get_holders_L(node)      ((IFaceHolder*) type_get_qdata_L ((node), static_quark_iface_holder))
 264 #define iface_node_set_holders_W(node, holders) (type_set_qdata_W ((node), static_quark_iface_holder, (holders)))
 265 #define iface_node_get_dependants_array_L(n)    ((GType*) type_get_qdata_L ((n), static_quark_dependants_array))
 266 #define iface_node_set_dependants_array_W(n,d)  (type_set_qdata_W ((n), static_quark_dependants_array, (d)))
 267 #define TYPE_ID_MASK                ((GType) ((1 &lt;&lt; G_TYPE_FUNDAMENTAL_SHIFT) - 1))
 268 
 269 #define NODE_IS_ANCESTOR(ancestor, node)                                                    \
 270         ((ancestor)-&gt;n_supers &lt;= (node)-&gt;n_supers &amp;&amp;                                        \
 271      (node)-&gt;supers[(node)-&gt;n_supers - (ancestor)-&gt;n_supers] == NODE_TYPE (ancestor))
 272 
 273 struct _IFaceHolder
 274 {
 275   GType           instance_type;
 276   GInterfaceInfo *info;
 277   GTypePlugin    *plugin;
 278   IFaceHolder    *next;
 279 };
 280 
 281 struct _IFaceEntry
 282 {
 283   GType           iface_type;
 284   GTypeInterface *vtable;
 285   InitState       init_state;
 286 };
 287 
 288 struct _IFaceEntries {
 289   guint offset_index;
 290   IFaceEntry entry[1];
 291 };
 292 
 293 #define IFACE_ENTRIES_HEADER_SIZE (sizeof(IFaceEntries) - sizeof(IFaceEntry))
 294 #define IFACE_ENTRIES_N_ENTRIES(_entries) ( (G_ATOMIC_ARRAY_DATA_SIZE((_entries)) - IFACE_ENTRIES_HEADER_SIZE) / sizeof(IFaceEntry) )
 295 
 296 struct _CommonData
 297 {
 298   GTypeValueTable  *value_table;
 299 };
 300 
 301 struct _BoxedData
 302 {
 303   CommonData         data;
 304   GBoxedCopyFunc     copy_func;
 305   GBoxedFreeFunc     free_func;
 306 };
 307 
 308 struct _IFaceData
 309 {
 310   CommonData         common;
 311   guint16            vtable_size;
 312   GBaseInitFunc      vtable_init_base;
 313   GBaseFinalizeFunc  vtable_finalize_base;
 314   GClassInitFunc     dflt_init;
 315   GClassFinalizeFunc dflt_finalize;
 316   gconstpointer      dflt_data;
 317   gpointer           dflt_vtable;
 318 };
 319 
 320 struct _ClassData
 321 {
 322   CommonData         common;
 323   guint16            class_size;
 324   guint16            class_private_size;
 325   int volatile       init_state; /* atomic - g_type_class_ref reads it unlocked */
 326   GBaseInitFunc      class_init_base;
 327   GBaseFinalizeFunc  class_finalize_base;
 328   GClassInitFunc     class_init;
 329   GClassFinalizeFunc class_finalize;
 330   gconstpointer      class_data;
 331   gpointer           class;
 332 };
 333 
 334 struct _InstanceData
 335 {
 336   CommonData         common;
 337   guint16            class_size;
 338   guint16            class_private_size;
 339   int volatile       init_state; /* atomic - g_type_class_ref reads it unlocked */
 340   GBaseInitFunc      class_init_base;
 341   GBaseFinalizeFunc  class_finalize_base;
 342   GClassInitFunc     class_init;
 343   GClassFinalizeFunc class_finalize;
 344   gconstpointer      class_data;
 345   gpointer           class;
 346   guint16            instance_size;
 347   guint16            private_size;
 348   guint16            n_preallocs;
 349   GInstanceInitFunc  instance_init;
 350 };
 351 
 352 union _TypeData
 353 {
 354   CommonData         common;
 355   BoxedData          boxed;
 356   IFaceData          iface;
 357   ClassData          class;
 358   InstanceData       instance;
 359 };
 360 
 361 typedef struct {
 362   gpointer            cache_data;
 363   GTypeClassCacheFunc cache_func;
 364 } ClassCacheFunc;
 365 
 366 typedef struct {
 367   gpointer                check_data;
 368   GTypeInterfaceCheckFunc check_func;
 369 } IFaceCheckFunc;
 370 
 371 
 372 /* --- variables --- */
 373 static GRWLock         type_rw_lock;
 374 static GRecMutex       class_init_rec_mutex;
 375 static guint           static_n_class_cache_funcs = 0;
 376 static ClassCacheFunc *static_class_cache_funcs = NULL;
 377 static guint           static_n_iface_check_funcs = 0;
 378 static IFaceCheckFunc *static_iface_check_funcs = NULL;
 379 static GQuark          static_quark_type_flags = 0;
 380 static GQuark          static_quark_iface_holder = 0;
 381 static GQuark          static_quark_dependants_array = 0;
 382 static guint           type_registration_serial = 0;
 383 GTypeDebugFlags        _g_type_debug_flags = 0;
 384 
 385 /* --- type nodes --- */
 386 static GHashTable       *static_type_nodes_ht = NULL;
 387 static TypeNode     *static_fundamental_type_nodes[(G_TYPE_FUNDAMENTAL_MAX &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT) + 1] = { NULL, };
 388 static GType         static_fundamental_next = G_TYPE_RESERVED_USER_FIRST;
 389 
 390 static inline TypeNode*
 391 lookup_type_node_I (GType utype)
 392 {
 393   if (utype &gt; G_TYPE_FUNDAMENTAL_MAX)
 394     return (TypeNode*) (utype &amp; ~TYPE_ID_MASK);
 395   else
 396     return static_fundamental_type_nodes[utype &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT];
 397 }
 398 
 399 /**
 400  * g_type_get_type_registration_serial:
 401  *
 402  * Returns an opaque serial number that represents the state of the set
 403  * of registered types. Any time a type is registered this serial changes,
 404  * which means you can cache information based on type lookups (such as
 405  * g_type_from_name()) and know if the cache is still valid at a later
 406  * time by comparing the current serial with the one at the type lookup.
 407  *
 408  * Since: 2.36
 409  *
 410  * Returns: An unsigned int, representing the state of type registrations
 411  */
 412 guint
 413 g_type_get_type_registration_serial (void)
 414 {
 415   return (guint)g_atomic_int_get ((gint *)&amp;type_registration_serial);
 416 }
 417 
 418 static TypeNode*
 419 type_node_any_new_W (TypeNode             *pnode,
 420              GType                 ftype,
 421              const gchar          *name,
 422              GTypePlugin          *plugin,
 423              GTypeFundamentalFlags type_flags)
 424 {
 425   guint n_supers;
 426   GType type;
 427   TypeNode *node;
 428   guint i, node_size = 0;
 429 
 430   n_supers = pnode ? pnode-&gt;n_supers + 1 : 0;
 431 
 432   if (!pnode)
 433     node_size += SIZEOF_FUNDAMENTAL_INFO;         /* fundamental type info */
 434   node_size += SIZEOF_BASE_TYPE_NODE ();          /* TypeNode structure */
 435   node_size += (sizeof (GType) * (1 + n_supers + 1)); /* self + ancestors + (0) for -&gt;supers[] */
 436   node = g_malloc0 (node_size);
 437   if (!pnode)                         /* offset fundamental types */
 438     {
 439       node = G_STRUCT_MEMBER_P (node, SIZEOF_FUNDAMENTAL_INFO);
 440       static_fundamental_type_nodes[ftype &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT] = node;
 441       type = ftype;
 442     }
 443   else
 444     type = (GType) node;
 445 
 446   g_assert ((type &amp; TYPE_ID_MASK) == 0);
 447 
 448   node-&gt;n_supers = n_supers;
 449   if (!pnode)
 450     {
 451       node-&gt;supers[0] = type;
 452       node-&gt;supers[1] = 0;
 453 
 454       node-&gt;is_classed = (type_flags &amp; G_TYPE_FLAG_CLASSED) != 0;
 455       node-&gt;is_instantiatable = (type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) != 0;
 456 
 457       if (NODE_IS_IFACE (node))
 458     {
 459           IFACE_NODE_N_PREREQUISITES (node) = 0;
 460       IFACE_NODE_PREREQUISITES (node) = NULL;
 461     }
 462       else
 463     _g_atomic_array_init (CLASSED_NODE_IFACES_ENTRIES (node));
 464     }
 465   else
 466     {
 467       node-&gt;supers[0] = type;
 468       memcpy (node-&gt;supers + 1, pnode-&gt;supers, sizeof (GType) * (1 + pnode-&gt;n_supers + 1));
 469 
 470       node-&gt;is_classed = pnode-&gt;is_classed;
 471       node-&gt;is_instantiatable = pnode-&gt;is_instantiatable;
 472 
 473       if (NODE_IS_IFACE (node))
 474     {
 475       IFACE_NODE_N_PREREQUISITES (node) = 0;
 476       IFACE_NODE_PREREQUISITES (node) = NULL;
 477     }
 478       else
 479     {
 480       guint j;
 481       IFaceEntries *entries;
 482 
 483       entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (pnode),
 484                       IFACE_ENTRIES_HEADER_SIZE,
 485                       0);
 486       if (entries)
 487         {
 488           for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (entries); j++)
 489         {
 490           entries-&gt;entry[j].vtable = NULL;
 491           entries-&gt;entry[j].init_state = UNINITIALIZED;
 492         }
 493           _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node),
 494                       entries);
 495         }
 496     }
 497 
 498       i = pnode-&gt;n_children++;
 499       pnode-&gt;children = g_renew (GType, pnode-&gt;children, pnode-&gt;n_children);
 500       pnode-&gt;children[i] = type;
 501     }
 502 
 503   TRACE(GOBJECT_TYPE_NEW(name, node-&gt;supers[1], type));
 504 
 505   node-&gt;plugin = plugin;
 506   node-&gt;n_children = 0;
 507   node-&gt;children = NULL;
 508   node-&gt;data = NULL;
 509   node-&gt;qname = g_quark_from_string (name);
 510   node-&gt;global_gdata = NULL;
 511   g_hash_table_insert (static_type_nodes_ht,
 512                (gpointer) g_quark_to_string (node-&gt;qname),
 513                (gpointer) type);
 514 
 515   g_atomic_int_inc ((gint *)&amp;type_registration_serial);
 516 
 517   return node;
 518 }
 519 
 520 static inline GTypeFundamentalInfo*
 521 type_node_fundamental_info_I (TypeNode *node)
 522 {
 523   GType ftype = NODE_FUNDAMENTAL_TYPE (node);
 524 
 525   if (ftype != NODE_TYPE (node))
 526     node = lookup_type_node_I (ftype);
 527 
 528   return node ? G_STRUCT_MEMBER_P (node, -SIZEOF_FUNDAMENTAL_INFO) : NULL;
 529 }
 530 
 531 static TypeNode*
 532 type_node_fundamental_new_W (GType                 ftype,
 533                  const gchar          *name,
 534                  GTypeFundamentalFlags type_flags)
 535 {
 536   GTypeFundamentalInfo *finfo;
 537   TypeNode *node;
 538 
 539   g_assert ((ftype &amp; TYPE_ID_MASK) == 0);
 540   g_assert (ftype &lt;= G_TYPE_FUNDAMENTAL_MAX);
 541 
 542   if (ftype &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT == static_fundamental_next)
 543     static_fundamental_next++;
 544 
 545   type_flags &amp;= TYPE_FUNDAMENTAL_FLAG_MASK;
 546 
 547   node = type_node_any_new_W (NULL, ftype, name, NULL, type_flags);
 548 
 549   finfo = type_node_fundamental_info_I (node);
 550   finfo-&gt;type_flags = type_flags;
 551 
 552   return node;
 553 }
 554 
 555 static TypeNode*
 556 type_node_new_W (TypeNode    *pnode,
 557          const gchar *name,
 558          GTypePlugin *plugin)
 559 
 560 {
 561   g_assert (pnode);
 562   g_assert (pnode-&gt;n_supers &lt; MAX_N_SUPERS);
 563   g_assert (pnode-&gt;n_children &lt; MAX_N_CHILDREN);
 564 
 565   return type_node_any_new_W (pnode, NODE_FUNDAMENTAL_TYPE (pnode), name, plugin, 0);
 566 }
 567 
 568 static inline IFaceEntry*
 569 lookup_iface_entry_I (volatile IFaceEntries *entries,
 570               TypeNode *iface_node)
 571 {
 572   guint8 *offsets;
 573   guint offset_index;
 574   IFaceEntry *check;
 575   int index;
 576   IFaceEntry *entry;
 577 
 578   if (entries == NULL)
 579     return NULL;
 580 
 581   G_ATOMIC_ARRAY_DO_TRANSACTION
 582     (&amp;iface_node-&gt;_prot.offsets, guint8,
 583 
 584      entry = NULL;
 585      offsets = transaction_data;
 586      offset_index = entries-&gt;offset_index;
 587      if (offsets != NULL &amp;&amp;
 588      offset_index &lt; G_ATOMIC_ARRAY_DATA_SIZE(offsets))
 589        {
 590      index = offsets[offset_index];
 591      if (index &gt; 0)
 592        {
 593          /* zero means unset, subtract one to get real index */
 594          index -= 1;
 595 
 596          if (index &lt; IFACE_ENTRIES_N_ENTRIES (entries))
 597            {
 598          check = (IFaceEntry *)&amp;entries-&gt;entry[index];
 599          if (check-&gt;iface_type == NODE_TYPE (iface_node))
 600            entry = check;
 601            }
 602        }
 603        }
 604      );
 605 
 606  return entry;
 607 }
 608 
 609 static inline IFaceEntry*
 610 type_lookup_iface_entry_L (TypeNode *node,
 611                TypeNode *iface_node)
 612 {
 613   if (!NODE_IS_IFACE (iface_node))
 614     return NULL;
 615 
 616   return lookup_iface_entry_I (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node),
 617                    iface_node);
 618 }
 619 
 620 
 621 static inline gboolean
 622 type_lookup_iface_vtable_I (TypeNode *node,
 623                 TypeNode *iface_node,
 624                 gpointer *vtable_ptr)
 625 {
 626   IFaceEntry *entry;
 627   gboolean res;
 628 
 629   if (!NODE_IS_IFACE (iface_node))
 630     {
 631       if (vtable_ptr)
 632     *vtable_ptr = NULL;
 633       return FALSE;
 634     }
 635 
 636   G_ATOMIC_ARRAY_DO_TRANSACTION
 637     (CLASSED_NODE_IFACES_ENTRIES (node), IFaceEntries,
 638 
 639      entry = lookup_iface_entry_I (transaction_data, iface_node);
 640      res = entry != NULL;
 641      if (vtable_ptr)
 642        {
 643      if (entry)
 644        *vtable_ptr = entry-&gt;vtable;
 645      else
 646        *vtable_ptr = NULL;
 647        }
 648      );
 649 
 650   return res;
 651 }
 652 
 653 static inline gboolean
 654 type_lookup_prerequisite_L (TypeNode *iface,
 655                 GType     prerequisite_type)
 656 {
 657   if (NODE_IS_IFACE (iface) &amp;&amp; IFACE_NODE_N_PREREQUISITES (iface))
 658     {
 659       GType *prerequisites = IFACE_NODE_PREREQUISITES (iface) - 1;
 660       guint n_prerequisites = IFACE_NODE_N_PREREQUISITES (iface);
 661 
 662       do
 663     {
 664       guint i;
 665       GType *check;
 666 
 667       i = (n_prerequisites + 1) &gt;&gt; 1;
 668       check = prerequisites + i;
 669       if (prerequisite_type == *check)
 670         return TRUE;
 671       else if (prerequisite_type &gt; *check)
 672         {
 673           n_prerequisites -= i;
 674           prerequisites = check;
 675         }
 676       else /* if (prerequisite_type &lt; *check) */
 677         n_prerequisites = i - 1;
 678     }
 679       while (n_prerequisites);
 680     }
 681   return FALSE;
 682 }
 683 
 684 static const gchar*
 685 type_descriptive_name_I (GType type)
 686 {
 687   if (type)
 688     {
 689       TypeNode *node = lookup_type_node_I (type);
 690 
 691       return node ? NODE_NAME (node) : &quot;&lt;unknown&gt;&quot;;
 692     }
 693   else
 694     return &quot;&lt;invalid&gt;&quot;;
 695 }
 696 
 697 
 698 /* --- type consistency checks --- */
 699 static gboolean
 700 check_plugin_U (GTypePlugin *plugin,
 701         gboolean     need_complete_type_info,
 702         gboolean     need_complete_interface_info,
 703         const gchar *type_name)
 704 {
 705   /* G_IS_TYPE_PLUGIN() and G_TYPE_PLUGIN_GET_CLASS() are external calls: _U
 706    */
 707   if (!plugin)
 708     {
 709       g_warning (&quot;plugin handle for type &#39;%s&#39; is NULL&quot;,
 710          type_name);
 711       return FALSE;
 712     }
 713   if (!G_IS_TYPE_PLUGIN (plugin))
 714     {
 715       g_warning (&quot;plugin pointer (%p) for type &#39;%s&#39; is invalid&quot;,
 716          plugin, type_name);
 717       return FALSE;
 718     }
 719   if (need_complete_type_info &amp;&amp; !G_TYPE_PLUGIN_GET_CLASS (plugin)-&gt;complete_type_info)
 720     {
 721       g_warning (&quot;plugin for type &#39;%s&#39; has no complete_type_info() implementation&quot;,
 722          type_name);
 723       return FALSE;
 724     }
 725   if (need_complete_interface_info &amp;&amp; !G_TYPE_PLUGIN_GET_CLASS (plugin)-&gt;complete_interface_info)
 726     {
 727       g_warning (&quot;plugin for type &#39;%s&#39; has no complete_interface_info() implementation&quot;,
 728          type_name);
 729       return FALSE;
 730     }
 731   return TRUE;
 732 }
 733 
 734 static gboolean
 735 check_type_name_I (const gchar *type_name)
 736 {
 737   static const gchar extra_chars[] = &quot;-_+&quot;;
 738   const gchar *p = type_name;
 739   gboolean name_valid;
 740 
 741   if (!type_name[0] || !type_name[1] || !type_name[2])
 742     {
 743       g_warning (&quot;type name &#39;%s&#39; is too short&quot;, type_name);
 744       return FALSE;
 745     }
 746   /* check the first letter */
 747   name_valid = (p[0] &gt;= &#39;A&#39; &amp;&amp; p[0] &lt;= &#39;Z&#39;) || (p[0] &gt;= &#39;a&#39; &amp;&amp; p[0] &lt;= &#39;z&#39;) || p[0] == &#39;_&#39;;
 748   for (p = type_name + 1; *p; p++)
 749     name_valid &amp;= ((p[0] &gt;= &#39;A&#39; &amp;&amp; p[0] &lt;= &#39;Z&#39;) ||
 750            (p[0] &gt;= &#39;a&#39; &amp;&amp; p[0] &lt;= &#39;z&#39;) ||
 751            (p[0] &gt;= &#39;0&#39; &amp;&amp; p[0] &lt;= &#39;9&#39;) ||
 752            strchr (extra_chars, p[0]));
 753   if (!name_valid)
 754     {
 755       g_warning (&quot;type name &#39;%s&#39; contains invalid characters&quot;, type_name);
 756       return FALSE;
 757     }
 758   if (g_type_from_name (type_name))
 759     {
 760       g_warning (&quot;cannot register existing type &#39;%s&#39;&quot;, type_name);
 761       return FALSE;
 762     }
 763 
 764   return TRUE;
 765 }
 766 
 767 static gboolean
 768 check_derivation_I (GType        parent_type,
 769             const gchar *type_name)
 770 {
 771   TypeNode *pnode;
 772   GTypeFundamentalInfo* finfo;
 773 
 774   pnode = lookup_type_node_I (parent_type);
 775   if (!pnode)
 776     {
 777       g_warning (&quot;cannot derive type &#39;%s&#39; from invalid parent type &#39;%s&#39;&quot;,
 778          type_name,
 779          type_descriptive_name_I (parent_type));
 780       return FALSE;
 781     }
 782   finfo = type_node_fundamental_info_I (pnode);
 783   /* ensure flat derivability */
 784   if (!(finfo-&gt;type_flags &amp; G_TYPE_FLAG_DERIVABLE))
 785     {
 786       g_warning (&quot;cannot derive &#39;%s&#39; from non-derivable parent type &#39;%s&#39;&quot;,
 787          type_name,
 788          NODE_NAME (pnode));
 789       return FALSE;
 790     }
 791   /* ensure deep derivability */
 792   if (parent_type != NODE_FUNDAMENTAL_TYPE (pnode) &amp;&amp;
 793       !(finfo-&gt;type_flags &amp; G_TYPE_FLAG_DEEP_DERIVABLE))
 794     {
 795       g_warning (&quot;cannot derive &#39;%s&#39; from non-fundamental parent type &#39;%s&#39;&quot;,
 796          type_name,
 797          NODE_NAME (pnode));
 798       return FALSE;
 799     }
 800 
 801   return TRUE;
 802 }
 803 
 804 static gboolean
 805 check_collect_format_I (const gchar *collect_format)
 806 {
 807   const gchar *p = collect_format;
 808   gchar valid_format[] = { G_VALUE_COLLECT_INT, G_VALUE_COLLECT_LONG,
 809                G_VALUE_COLLECT_INT64, G_VALUE_COLLECT_DOUBLE,
 810                G_VALUE_COLLECT_POINTER, 0 };
 811 
 812   while (*p)
 813     if (!strchr (valid_format, *p++))
 814       return FALSE;
 815   return p - collect_format &lt;= G_VALUE_COLLECT_FORMAT_MAX_LENGTH;
 816 }
 817 
 818 static gboolean
 819 check_value_table_I (const gchar           *type_name,
 820              const GTypeValueTable *value_table)
 821 {
 822   if (!value_table)
 823     return FALSE;
 824   else if (value_table-&gt;value_init == NULL)
 825     {
 826       if (value_table-&gt;value_free || value_table-&gt;value_copy ||
 827       value_table-&gt;value_peek_pointer ||
 828       value_table-&gt;collect_format || value_table-&gt;collect_value ||
 829       value_table-&gt;lcopy_format || value_table-&gt;lcopy_value)
 830     g_warning (&quot;cannot handle uninitializable values of type &#39;%s&#39;&quot;,
 831            type_name);
 832       return FALSE;
 833     }
 834   else /* value_table-&gt;value_init != NULL */
 835     {
 836       if (!value_table-&gt;value_free)
 837     {
 838       /* +++ optional +++
 839        * g_warning (&quot;missing &#39;value_free()&#39; for type &#39;%s&#39;&quot;, type_name);
 840        * return FALSE;
 841        */
 842     }
 843       if (!value_table-&gt;value_copy)
 844     {
 845       g_warning (&quot;missing &#39;value_copy()&#39; for type &#39;%s&#39;&quot;, type_name);
 846       return FALSE;
 847     }
 848       if ((value_table-&gt;collect_format || value_table-&gt;collect_value) &amp;&amp;
 849       (!value_table-&gt;collect_format || !value_table-&gt;collect_value))
 850     {
 851       g_warning (&quot;one of &#39;collect_format&#39; and &#39;collect_value()&#39; is unspecified for type &#39;%s&#39;&quot;,
 852              type_name);
 853       return FALSE;
 854     }
 855       if (value_table-&gt;collect_format &amp;&amp; !check_collect_format_I (value_table-&gt;collect_format))
 856     {
 857       g_warning (&quot;the &#39;%s&#39; specification for type &#39;%s&#39; is too long or invalid&quot;,
 858              &quot;collect_format&quot;,
 859              type_name);
 860       return FALSE;
 861     }
 862       if ((value_table-&gt;lcopy_format || value_table-&gt;lcopy_value) &amp;&amp;
 863       (!value_table-&gt;lcopy_format || !value_table-&gt;lcopy_value))
 864     {
 865       g_warning (&quot;one of &#39;lcopy_format&#39; and &#39;lcopy_value()&#39; is unspecified for type &#39;%s&#39;&quot;,
 866              type_name);
 867       return FALSE;
 868     }
 869       if (value_table-&gt;lcopy_format &amp;&amp; !check_collect_format_I (value_table-&gt;lcopy_format))
 870     {
 871       g_warning (&quot;the &#39;%s&#39; specification for type &#39;%s&#39; is too long or invalid&quot;,
 872              &quot;lcopy_format&quot;,
 873              type_name);
 874       return FALSE;
 875     }
 876     }
 877   return TRUE;
 878 }
 879 
 880 static gboolean
 881 check_type_info_I (TypeNode        *pnode,
 882            GType            ftype,
 883            const gchar     *type_name,
 884            const GTypeInfo *info)
 885 {
 886   GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (lookup_type_node_I (ftype));
 887   gboolean is_interface = ftype == G_TYPE_INTERFACE;
 888 
 889   g_assert (ftype &lt;= G_TYPE_FUNDAMENTAL_MAX &amp;&amp; !(ftype &amp; TYPE_ID_MASK));
 890 
 891   /* check instance members */
 892   if (!(finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) &amp;&amp;
 893       (info-&gt;instance_size || info-&gt;n_preallocs || info-&gt;instance_init))
 894     {
 895       if (pnode)
 896     g_warning (&quot;cannot instantiate &#39;%s&#39;, derived from non-instantiatable parent type &#39;%s&#39;&quot;,
 897            type_name,
 898            NODE_NAME (pnode));
 899       else
 900     g_warning (&quot;cannot instantiate &#39;%s&#39; as non-instantiatable fundamental&quot;,
 901            type_name);
 902       return FALSE;
 903     }
 904   /* check class &amp; interface members */
 905   if (!((finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED) || is_interface) &amp;&amp;
 906       (info-&gt;class_init || info-&gt;class_finalize || info-&gt;class_data ||
 907        info-&gt;class_size || info-&gt;base_init || info-&gt;base_finalize))
 908     {
 909       if (pnode)
 910     g_warning (&quot;cannot create class for &#39;%s&#39;, derived from non-classed parent type &#39;%s&#39;&quot;,
 911            type_name,
 912                    NODE_NAME (pnode));
 913       else
 914     g_warning (&quot;cannot create class for &#39;%s&#39; as non-classed fundamental&quot;,
 915            type_name);
 916       return FALSE;
 917     }
 918   /* check interface size */
 919   if (is_interface &amp;&amp; info-&gt;class_size &lt; sizeof (GTypeInterface))
 920     {
 921       g_warning (&quot;specified interface size for type &#39;%s&#39; is smaller than &#39;GTypeInterface&#39; size&quot;,
 922          type_name);
 923       return FALSE;
 924     }
 925   /* check class size */
 926   if (finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED)
 927     {
 928       if (info-&gt;class_size &lt; sizeof (GTypeClass))
 929     {
 930       g_warning (&quot;specified class size for type &#39;%s&#39; is smaller than &#39;GTypeClass&#39; size&quot;,
 931              type_name);
 932       return FALSE;
 933     }
 934       if (pnode &amp;&amp; info-&gt;class_size &lt; pnode-&gt;data-&gt;class.class_size)
 935     {
 936       g_warning (&quot;specified class size for type &#39;%s&#39; is smaller &quot;
 937              &quot;than the parent type&#39;s &#39;%s&#39; class size&quot;,
 938              type_name,
 939              NODE_NAME (pnode));
 940       return FALSE;
 941     }
 942     }
 943   /* check instance size */
 944   if (finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE)
 945     {
 946       if (info-&gt;instance_size &lt; sizeof (GTypeInstance))
 947     {
 948       g_warning (&quot;specified instance size for type &#39;%s&#39; is smaller than &#39;GTypeInstance&#39; size&quot;,
 949              type_name);
 950       return FALSE;
 951     }
 952       if (pnode &amp;&amp; info-&gt;instance_size &lt; pnode-&gt;data-&gt;instance.instance_size)
 953     {
 954       g_warning (&quot;specified instance size for type &#39;%s&#39; is smaller &quot;
 955              &quot;than the parent type&#39;s &#39;%s&#39; instance size&quot;,
 956              type_name,
 957              NODE_NAME (pnode));
 958       return FALSE;
 959     }
 960     }
 961 
 962   return TRUE;
 963 }
 964 
 965 static TypeNode*
 966 find_conforming_child_type_L (TypeNode *pnode,
 967                   TypeNode *iface)
 968 {
 969   TypeNode *node = NULL;
 970   guint i;
 971 
 972   if (type_lookup_iface_entry_L (pnode, iface))
 973     return pnode;
 974 
 975   for (i = 0; i &lt; pnode-&gt;n_children &amp;&amp; !node; i++)
 976     node = find_conforming_child_type_L (lookup_type_node_I (pnode-&gt;children[i]), iface);
 977 
 978   return node;
 979 }
 980 
 981 static gboolean
 982 check_add_interface_L (GType instance_type,
 983                GType iface_type)
 984 {
 985   TypeNode *node = lookup_type_node_I (instance_type);
 986   TypeNode *iface = lookup_type_node_I (iface_type);
 987   IFaceEntry *entry;
 988   TypeNode *tnode;
 989   GType *prerequisites;
 990   guint i;
 991 
 992 
 993   if (!node || !node-&gt;is_instantiatable)
 994     {
 995       g_warning (&quot;cannot add interfaces to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
 996          type_descriptive_name_I (instance_type));
 997       return FALSE;
 998     }
 999   if (!iface || !NODE_IS_IFACE (iface))
1000     {
1001       g_warning (&quot;cannot add invalid (non-interface) type &#39;%s&#39; to type &#39;%s&#39;&quot;,
1002          type_descriptive_name_I (iface_type),
1003          NODE_NAME (node));
1004       return FALSE;
1005     }
1006   if (node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class)
1007     {
1008       g_warning (&quot;attempting to add an interface (%s) to class (%s) after class_init&quot;,
1009                  NODE_NAME (iface), NODE_NAME (node));
1010       return FALSE;
1011     }
1012   tnode = lookup_type_node_I (NODE_PARENT_TYPE (iface));
1013   if (NODE_PARENT_TYPE (tnode) &amp;&amp; !type_lookup_iface_entry_L (node, tnode))
1014     {
1015       /* 2001/7/31:timj: erk, i guess this warning is junk as interface derivation is flat */
1016       g_warning (&quot;cannot add sub-interface &#39;%s&#39; to type &#39;%s&#39; which does not conform to super-interface &#39;%s&#39;&quot;,
1017          NODE_NAME (iface),
1018          NODE_NAME (node),
1019          NODE_NAME (tnode));
1020       return FALSE;
1021     }
1022   /* allow overriding of interface type introduced for parent type */
1023   entry = type_lookup_iface_entry_L (node, iface);
1024   if (entry &amp;&amp; entry-&gt;vtable == NULL &amp;&amp; !type_iface_peek_holder_L (iface, NODE_TYPE (node)))
1025     {
1026       /* ok, we do conform to this interface already, but the interface vtable was not
1027        * yet intialized, and we just conform to the interface because it got added to
1028        * one of our parents. so we allow overriding of holder info here.
1029        */
1030       return TRUE;
1031     }
1032   /* check whether one of our children already conforms (or whether the interface
1033    * got added to this node already)
1034    */
1035   tnode = find_conforming_child_type_L (node, iface);  /* tnode is_a node */
1036   if (tnode)
1037     {
1038       g_warning (&quot;cannot add interface type &#39;%s&#39; to type &#39;%s&#39;, since type &#39;%s&#39; already conforms to interface&quot;,
1039          NODE_NAME (iface),
1040          NODE_NAME (node),
1041          NODE_NAME (tnode));
1042       return FALSE;
1043     }
1044   prerequisites = IFACE_NODE_PREREQUISITES (iface);
1045   for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
1046     {
1047       tnode = lookup_type_node_I (prerequisites[i]);
1048       if (!type_node_is_a_L (node, tnode))
1049     {
1050       g_warning (&quot;cannot add interface type &#39;%s&#39; to type &#39;%s&#39; which does not conform to prerequisite &#39;%s&#39;&quot;,
1051              NODE_NAME (iface),
1052              NODE_NAME (node),
1053              NODE_NAME (tnode));
1054       return FALSE;
1055     }
1056     }
1057   return TRUE;
1058 }
1059 
1060 static gboolean
1061 check_interface_info_I (TypeNode             *iface,
1062             GType                 instance_type,
1063             const GInterfaceInfo *info)
1064 {
1065   if ((info-&gt;interface_finalize || info-&gt;interface_data) &amp;&amp; !info-&gt;interface_init)
1066     {
1067       g_warning (&quot;interface type &#39;%s&#39; for type &#39;%s&#39; comes without initializer&quot;,
1068          NODE_NAME (iface),
1069          type_descriptive_name_I (instance_type));
1070       return FALSE;
1071     }
1072 
1073   return TRUE;
1074 }
1075 
1076 /* --- type info (type node data) --- */
1077 static void
1078 type_data_make_W (TypeNode              *node,
1079           const GTypeInfo       *info,
1080           const GTypeValueTable *value_table)
1081 {
1082   TypeData *data;
1083   GTypeValueTable *vtable = NULL;
1084   guint vtable_size = 0;
1085 
1086   g_assert (node-&gt;data == NULL &amp;&amp; info != NULL);
1087 
1088   if (!value_table)
1089     {
1090       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
1091 
1092       if (pnode)
1093     vtable = pnode-&gt;data-&gt;common.value_table;
1094       else
1095     {
1096       static const GTypeValueTable zero_vtable = { NULL, };
1097 
1098       value_table = &amp;zero_vtable;
1099     }
1100     }
1101   if (value_table)
1102     {
1103       /* need to setup vtable_size since we have to allocate it with data in one chunk */
1104       vtable_size = sizeof (GTypeValueTable);
1105       if (value_table-&gt;collect_format)
1106     vtable_size += strlen (value_table-&gt;collect_format);
1107       if (value_table-&gt;lcopy_format)
1108     vtable_size += strlen (value_table-&gt;lcopy_format);
1109       vtable_size += 2;
1110     }
1111 
1112   if (node-&gt;is_instantiatable) /* careful, is_instantiatable is also is_classed */
1113     {
1114       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
1115 
1116       data = g_malloc0 (sizeof (InstanceData) + vtable_size);
1117 #ifdef GSTREAMER_LITE
1118       if (data == NULL)
1119           return;
1120 #endif // GSTREAMER_LITE
1121       if (vtable_size)
1122     vtable = G_STRUCT_MEMBER_P (data, sizeof (InstanceData));
1123       data-&gt;instance.class_size = info-&gt;class_size;
1124       data-&gt;instance.class_init_base = info-&gt;base_init;
1125       data-&gt;instance.class_finalize_base = info-&gt;base_finalize;
1126       data-&gt;instance.class_init = info-&gt;class_init;
1127       data-&gt;instance.class_finalize = info-&gt;class_finalize;
1128       data-&gt;instance.class_data = info-&gt;class_data;
1129       data-&gt;instance.class = NULL;
1130       data-&gt;instance.init_state = UNINITIALIZED;
1131       data-&gt;instance.instance_size = info-&gt;instance_size;
1132       /* We&#39;ll set the final value for data-&gt;instance.private size
1133        * after the parent class has been initialized
1134        */
1135       data-&gt;instance.private_size = 0;
1136       data-&gt;instance.class_private_size = 0;
1137       if (pnode)
1138         data-&gt;instance.class_private_size = pnode-&gt;data-&gt;instance.class_private_size;
1139       data-&gt;instance.n_preallocs = MIN (info-&gt;n_preallocs, 1024);
1140       data-&gt;instance.instance_init = info-&gt;instance_init;
1141     }
1142   else if (node-&gt;is_classed) /* only classed */
1143     {
1144       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
1145 
1146       data = g_malloc0 (sizeof (ClassData) + vtable_size);
1147       if (vtable_size)
1148     vtable = G_STRUCT_MEMBER_P (data, sizeof (ClassData));
1149       data-&gt;class.class_size = info-&gt;class_size;
1150       data-&gt;class.class_init_base = info-&gt;base_init;
1151       data-&gt;class.class_finalize_base = info-&gt;base_finalize;
1152       data-&gt;class.class_init = info-&gt;class_init;
1153       data-&gt;class.class_finalize = info-&gt;class_finalize;
1154       data-&gt;class.class_data = info-&gt;class_data;
1155       data-&gt;class.class = NULL;
1156       data-&gt;class.class_private_size = 0;
1157       if (pnode)
1158         data-&gt;class.class_private_size = pnode-&gt;data-&gt;class.class_private_size;
1159       data-&gt;class.init_state = UNINITIALIZED;
1160     }
1161   else if (NODE_IS_IFACE (node))
1162     {
1163       data = g_malloc0 (sizeof (IFaceData) + vtable_size);
1164       if (vtable_size)
1165     vtable = G_STRUCT_MEMBER_P (data, sizeof (IFaceData));
1166       data-&gt;iface.vtable_size = info-&gt;class_size;
1167       data-&gt;iface.vtable_init_base = info-&gt;base_init;
1168       data-&gt;iface.vtable_finalize_base = info-&gt;base_finalize;
1169       data-&gt;iface.dflt_init = info-&gt;class_init;
1170       data-&gt;iface.dflt_finalize = info-&gt;class_finalize;
1171       data-&gt;iface.dflt_data = info-&gt;class_data;
1172       data-&gt;iface.dflt_vtable = NULL;
1173     }
1174   else if (NODE_IS_BOXED (node))
1175     {
1176       data = g_malloc0 (sizeof (BoxedData) + vtable_size);
1177       if (vtable_size)
1178     vtable = G_STRUCT_MEMBER_P (data, sizeof (BoxedData));
1179     }
1180   else
1181     {
1182       data = g_malloc0 (sizeof (CommonData) + vtable_size);
1183       if (vtable_size)
1184     vtable = G_STRUCT_MEMBER_P (data, sizeof (CommonData));
1185     }
1186 
1187   node-&gt;data = data;
1188 
1189   if (vtable_size)
1190     {
1191       gchar *p;
1192 
1193       /* we allocate the vtable and its strings together with the type data, so
1194        * children can take over their parent&#39;s vtable pointer, and we don&#39;t
1195        * need to worry freeing it or not when the child data is destroyed
1196        */
1197       *vtable = *value_table;
1198       p = G_STRUCT_MEMBER_P (vtable, sizeof (*vtable));
1199       p[0] = 0;
1200       vtable-&gt;collect_format = p;
1201       if (value_table-&gt;collect_format)
1202     {
1203       strcat (p, value_table-&gt;collect_format);
1204       p += strlen (value_table-&gt;collect_format);
1205     }
1206       p++;
1207       p[0] = 0;
1208       vtable-&gt;lcopy_format = p;
1209       if (value_table-&gt;lcopy_format)
1210     strcat  (p, value_table-&gt;lcopy_format);
1211     }
1212   node-&gt;data-&gt;common.value_table = vtable;
1213   node-&gt;mutatable_check_cache = (node-&gt;data-&gt;common.value_table-&gt;value_init != NULL &amp;&amp;
1214                  !((G_TYPE_FLAG_VALUE_ABSTRACT | G_TYPE_FLAG_ABSTRACT) &amp;
1215                    GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))));
1216 
1217   g_assert (node-&gt;data-&gt;common.value_table != NULL); /* paranoid */
1218 
1219   g_atomic_int_set ((int *) &amp;node-&gt;ref_count, 1);
1220 }
1221 
1222 static inline void
1223 type_data_ref_Wm (TypeNode *node)
1224 {
1225   if (!node-&gt;data)
1226     {
1227       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
1228       GTypeInfo tmp_info;
1229       GTypeValueTable tmp_value_table;
1230 
1231       g_assert (node-&gt;plugin != NULL);
1232 
1233       if (pnode)
1234     {
1235       type_data_ref_Wm (pnode);
1236       if (node-&gt;data)
1237         INVALID_RECURSION (&quot;g_type_plugin_*&quot;, node-&gt;plugin, NODE_NAME (node));
1238     }
1239 
1240       memset (&amp;tmp_info, 0, sizeof (tmp_info));
1241       memset (&amp;tmp_value_table, 0, sizeof (tmp_value_table));
1242 
1243       G_WRITE_UNLOCK (&amp;type_rw_lock);
1244       g_type_plugin_use (node-&gt;plugin);
1245       g_type_plugin_complete_type_info (node-&gt;plugin, NODE_TYPE (node), &amp;tmp_info, &amp;tmp_value_table);
1246       G_WRITE_LOCK (&amp;type_rw_lock);
1247       if (node-&gt;data)
1248     INVALID_RECURSION (&quot;g_type_plugin_*&quot;, node-&gt;plugin, NODE_NAME (node));
1249 
1250       check_type_info_I (pnode, NODE_FUNDAMENTAL_TYPE (node), NODE_NAME (node), &amp;tmp_info);
1251       type_data_make_W (node, &amp;tmp_info,
1252             check_value_table_I (NODE_NAME (node),
1253                          &amp;tmp_value_table) ? &amp;tmp_value_table : NULL);
1254     }
1255   else
1256     {
1257       g_assert (NODE_REFCOUNT (node) &gt; 0);
1258 
1259       g_atomic_int_inc ((int *) &amp;node-&gt;ref_count);
1260     }
1261 }
1262 
1263 static inline gboolean
1264 type_data_ref_U (TypeNode *node)
1265 {
1266   guint current;
1267 
1268   do {
1269     current = NODE_REFCOUNT (node);
1270 
1271     if (current &lt; 1)
1272       return FALSE;
1273   } while (!g_atomic_int_compare_and_exchange ((int *) &amp;node-&gt;ref_count, current, current + 1));
1274 
1275   return TRUE;
1276 }
1277 
1278 static gboolean
1279 iface_node_has_available_offset_L (TypeNode *iface_node,
1280                    int offset,
1281                    int for_index)
1282 {
1283   guint8 *offsets;
1284 
1285   offsets = G_ATOMIC_ARRAY_GET_LOCKED (&amp;iface_node-&gt;_prot.offsets, guint8);
1286   if (offsets == NULL)
1287     return TRUE;
1288 
1289   if (G_ATOMIC_ARRAY_DATA_SIZE (offsets) &lt;= offset)
1290     return TRUE;
1291 
1292   if (offsets[offset] == 0 ||
1293       offsets[offset] == for_index+1)
1294     return TRUE;
1295 
1296   return FALSE;
1297 }
1298 
1299 static int
1300 find_free_iface_offset_L (IFaceEntries *entries)
1301 {
1302   IFaceEntry *entry;
1303   TypeNode *iface_node;
1304   int offset;
1305   int i;
1306   int n_entries;
1307 
1308   n_entries = IFACE_ENTRIES_N_ENTRIES (entries);
1309   offset = -1;
1310   do
1311     {
1312       offset++;
1313       for (i = 0; i &lt; n_entries; i++)
1314     {
1315       entry = &amp;entries-&gt;entry[i];
1316       iface_node = lookup_type_node_I (entry-&gt;iface_type);
1317 
1318       if (!iface_node_has_available_offset_L (iface_node, offset, i))
1319         break;
1320     }
1321     }
1322   while (i != n_entries);
1323 
1324   return offset;
1325 }
1326 
1327 static void
1328 iface_node_set_offset_L (TypeNode *iface_node,
1329              int offset,
1330              int index)
1331 {
1332   guint8 *offsets, *old_offsets;
1333   int new_size, old_size;
1334   int i;
1335 
1336   old_offsets = G_ATOMIC_ARRAY_GET_LOCKED (&amp;iface_node-&gt;_prot.offsets, guint8);
1337   if (old_offsets == NULL)
1338     old_size = 0;
1339   else
1340     {
1341       old_size = G_ATOMIC_ARRAY_DATA_SIZE (old_offsets);
1342       if (offset &lt; old_size &amp;&amp;
1343       old_offsets[offset] == index + 1)
1344     return; /* Already set to this index, return */
1345     }
1346   new_size = MAX (old_size, offset + 1);
1347 
1348   offsets = _g_atomic_array_copy (&amp;iface_node-&gt;_prot.offsets,
1349                   0, new_size - old_size);
1350 
1351   /* Mark new area as unused */
1352   for (i = old_size; i &lt; new_size; i++)
1353     offsets[i] = 0;
1354 
1355   offsets[offset] = index + 1;
1356 
1357   _g_atomic_array_update (&amp;iface_node-&gt;_prot.offsets, offsets);
1358 }
1359 
1360 static void
1361 type_node_add_iface_entry_W (TypeNode   *node,
1362                  GType       iface_type,
1363                              IFaceEntry *parent_entry)
1364 {
1365   IFaceEntries *entries;
1366   IFaceEntry *entry;
1367   TypeNode *iface_node;
1368   guint i, j;
1369   int num_entries;
1370 
1371   g_assert (node-&gt;is_instantiatable);
1372 
1373   entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
1374   if (entries != NULL)
1375     {
1376       num_entries = IFACE_ENTRIES_N_ENTRIES (entries);
1377 
1378       g_assert (num_entries &lt; MAX_N_INTERFACES);
1379 
1380       for (i = 0; i &lt; num_entries; i++)
1381     {
1382       entry = &amp;entries-&gt;entry[i];
1383       if (entry-&gt;iface_type == iface_type)
1384         {
1385           /* this can happen in two cases:
1386            * - our parent type already conformed to iface_type and node
1387            *   got its own holder info. here, our children already have
1388            *   entries and NULL vtables, since this will only work for
1389            *   uninitialized classes.
1390            * - an interface type is added to an ancestor after it was
1391            *   added to a child type.
1392            */
1393           if (!parent_entry)
1394         g_assert (entry-&gt;vtable == NULL &amp;&amp; entry-&gt;init_state == UNINITIALIZED);
1395           else
1396         {
1397           /* sick, interface is added to ancestor *after* child type;
1398            * nothing todo, the entry and our children were already setup correctly
1399            */
1400         }
1401           return;
1402         }
1403     }
1404     }
1405 
1406   entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (node),
1407                   IFACE_ENTRIES_HEADER_SIZE,
1408                   sizeof (IFaceEntry));
1409   num_entries = IFACE_ENTRIES_N_ENTRIES (entries);
1410   i = num_entries - 1;
1411   if (i == 0)
1412     entries-&gt;offset_index = 0;
1413   entries-&gt;entry[i].iface_type = iface_type;
1414   entries-&gt;entry[i].vtable = NULL;
1415   entries-&gt;entry[i].init_state = UNINITIALIZED;
1416 
1417   if (parent_entry)
1418     {
1419       if (node-&gt;data &amp;&amp; node-&gt;data-&gt;class.init_state &gt;= BASE_IFACE_INIT)
1420         {
1421           entries-&gt;entry[i].init_state = INITIALIZED;
1422           entries-&gt;entry[i].vtable = parent_entry-&gt;vtable;
1423         }
1424     }
1425 
1426   /* Update offsets in iface */
1427   iface_node = lookup_type_node_I (iface_type);
1428 
1429   if (iface_node_has_available_offset_L (iface_node,
1430                      entries-&gt;offset_index,
1431                      i))
1432     {
1433       iface_node_set_offset_L (iface_node,
1434                    entries-&gt;offset_index, i);
1435     }
1436   else
1437    {
1438       entries-&gt;offset_index =
1439     find_free_iface_offset_L (entries);
1440       for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (entries); j++)
1441     {
1442       entry = &amp;entries-&gt;entry[j];
1443       iface_node =
1444         lookup_type_node_I (entry-&gt;iface_type);
1445       iface_node_set_offset_L (iface_node,
1446                    entries-&gt;offset_index, j);
1447     }
1448     }
1449 
1450   _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node), entries);
1451 
1452   if (parent_entry)
1453     {
1454       for (i = 0; i &lt; node-&gt;n_children; i++)
1455         type_node_add_iface_entry_W (lookup_type_node_I (node-&gt;children[i]), iface_type, &amp;entries-&gt;entry[i]);
1456     }
1457 }
1458 
1459 static void
1460 type_add_interface_Wm (TypeNode             *node,
1461                        TypeNode             *iface,
1462                        const GInterfaceInfo *info,
1463                        GTypePlugin          *plugin)
1464 {
1465   IFaceHolder *iholder = g_new0 (IFaceHolder, 1);
1466   IFaceEntry *entry;
1467   guint i;
1468 
1469   g_assert (node-&gt;is_instantiatable &amp;&amp; NODE_IS_IFACE (iface) &amp;&amp; ((info &amp;&amp; !plugin) || (!info &amp;&amp; plugin)));
1470 
1471   iholder-&gt;next = iface_node_get_holders_L (iface);
1472   iface_node_set_holders_W (iface, iholder);
1473   iholder-&gt;instance_type = NODE_TYPE (node);
1474   iholder-&gt;info = info ? g_memdup (info, sizeof (*info)) : NULL;
1475   iholder-&gt;plugin = plugin;
1476 
1477   /* create an iface entry for this type */
1478   type_node_add_iface_entry_W (node, NODE_TYPE (iface), NULL);
1479 
1480   /* if the class is already (partly) initialized, we may need to base
1481    * initalize and/or initialize the new interface.
1482    */
1483   if (node-&gt;data)
1484     {
1485       InitState class_state = node-&gt;data-&gt;class.init_state;
1486 
1487       if (class_state &gt;= BASE_IFACE_INIT)
1488         type_iface_vtable_base_init_Wm (iface, node);
1489 
1490       if (class_state &gt;= IFACE_INIT)
1491         type_iface_vtable_iface_init_Wm (iface, node);
1492     }
1493 
1494   /* create iface entries for children of this type */
1495   entry = type_lookup_iface_entry_L (node, iface);
1496   for (i = 0; i &lt; node-&gt;n_children; i++)
1497     type_node_add_iface_entry_W (lookup_type_node_I (node-&gt;children[i]), NODE_TYPE (iface), entry);
1498 }
1499 
1500 static void
1501 type_iface_add_prerequisite_W (TypeNode *iface,
1502                    TypeNode *prerequisite_node)
1503 {
1504   GType prerequisite_type = NODE_TYPE (prerequisite_node);
1505   GType *prerequisites, *dependants;
1506   guint n_dependants, i;
1507 
1508   g_assert (NODE_IS_IFACE (iface) &amp;&amp;
1509         IFACE_NODE_N_PREREQUISITES (iface) &lt; MAX_N_PREREQUISITES &amp;&amp;
1510         (prerequisite_node-&gt;is_instantiatable || NODE_IS_IFACE (prerequisite_node)));
1511 
1512   prerequisites = IFACE_NODE_PREREQUISITES (iface);
1513   for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
1514     if (prerequisites[i] == prerequisite_type)
1515       return;           /* we already have that prerequisiste */
1516     else if (prerequisites[i] &gt; prerequisite_type)
1517       break;
1518   IFACE_NODE_N_PREREQUISITES (iface) += 1;
1519   IFACE_NODE_PREREQUISITES (iface) = g_renew (GType,
1520                           IFACE_NODE_PREREQUISITES (iface),
1521                           IFACE_NODE_N_PREREQUISITES (iface));
1522   prerequisites = IFACE_NODE_PREREQUISITES (iface);
1523   memmove (prerequisites + i + 1, prerequisites + i,
1524            sizeof (prerequisites[0]) * (IFACE_NODE_N_PREREQUISITES (iface) - i - 1));
1525   prerequisites[i] = prerequisite_type;
1526 
1527   /* we want to get notified when prerequisites get added to prerequisite_node */
1528   if (NODE_IS_IFACE (prerequisite_node))
1529     {
1530       dependants = iface_node_get_dependants_array_L (prerequisite_node);
1531       n_dependants = dependants ? dependants[0] : 0;
1532       n_dependants += 1;
1533       dependants = g_renew (GType, dependants, n_dependants + 1);
1534       dependants[n_dependants] = NODE_TYPE (iface);
1535       dependants[0] = n_dependants;
1536       iface_node_set_dependants_array_W (prerequisite_node, dependants);
1537     }
1538 
1539   /* we need to notify all dependants */
1540   dependants = iface_node_get_dependants_array_L (iface);
1541   n_dependants = dependants ? dependants[0] : 0;
1542   for (i = 1; i &lt;= n_dependants; i++)
1543     type_iface_add_prerequisite_W (lookup_type_node_I (dependants[i]), prerequisite_node);
1544 }
1545 
1546 /**
1547  * g_type_interface_add_prerequisite:
1548  * @interface_type: #GType value of an interface type
1549  * @prerequisite_type: #GType value of an interface or instantiatable type
1550  *
1551  * Adds @prerequisite_type to the list of prerequisites of @interface_type.
1552  * This means that any type implementing @interface_type must also implement
1553  * @prerequisite_type. Prerequisites can be thought of as an alternative to
1554  * interface derivation (which GType doesn&#39;t support). An interface can have
1555  * at most one instantiatable prerequisite type.
1556  */
1557 void
1558 g_type_interface_add_prerequisite (GType interface_type,
1559                    GType prerequisite_type)
1560 {
1561   TypeNode *iface, *prerequisite_node;
1562   IFaceHolder *holders;
1563 
1564   g_return_if_fail (G_TYPE_IS_INTERFACE (interface_type));  /* G_TYPE_IS_INTERFACE() is an external call: _U */
1565   g_return_if_fail (!g_type_is_a (interface_type, prerequisite_type));
1566   g_return_if_fail (!g_type_is_a (prerequisite_type, interface_type));
1567 
1568   iface = lookup_type_node_I (interface_type);
1569   prerequisite_node = lookup_type_node_I (prerequisite_type);
1570   if (!iface || !prerequisite_node || !NODE_IS_IFACE (iface))
1571     {
1572       g_warning (&quot;interface type &#39;%s&#39; or prerequisite type &#39;%s&#39; invalid&quot;,
1573          type_descriptive_name_I (interface_type),
1574          type_descriptive_name_I (prerequisite_type));
1575       return;
1576     }
1577   G_WRITE_LOCK (&amp;type_rw_lock);
1578   holders = iface_node_get_holders_L (iface);
1579   if (holders)
1580     {
1581       G_WRITE_UNLOCK (&amp;type_rw_lock);
1582       g_warning (&quot;unable to add prerequisite &#39;%s&#39; to interface &#39;%s&#39; which is already in use for &#39;%s&#39;&quot;,
1583          type_descriptive_name_I (prerequisite_type),
1584          type_descriptive_name_I (interface_type),
1585          type_descriptive_name_I (holders-&gt;instance_type));
1586       return;
1587     }
1588   if (prerequisite_node-&gt;is_instantiatable)
1589     {
1590       guint i;
1591 
1592       /* can have at most one publicly installable instantiatable prerequisite */
1593       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
1594     {
1595       TypeNode *prnode = lookup_type_node_I (IFACE_NODE_PREREQUISITES (iface)[i]);
1596 
1597       if (prnode-&gt;is_instantiatable)
1598         {
1599           G_WRITE_UNLOCK (&amp;type_rw_lock);
1600           g_warning (&quot;adding prerequisite &#39;%s&#39; to interface &#39;%s&#39; conflicts with existing prerequisite &#39;%s&#39;&quot;,
1601              type_descriptive_name_I (prerequisite_type),
1602              type_descriptive_name_I (interface_type),
1603              type_descriptive_name_I (NODE_TYPE (prnode)));
1604           return;
1605         }
1606     }
1607 
1608       for (i = 0; i &lt; prerequisite_node-&gt;n_supers + 1; i++)
1609     type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisite_node-&gt;supers[i]));
1610       G_WRITE_UNLOCK (&amp;type_rw_lock);
1611     }
1612   else if (NODE_IS_IFACE (prerequisite_node))
1613     {
1614       GType *prerequisites;
1615       guint i;
1616 
1617       prerequisites = IFACE_NODE_PREREQUISITES (prerequisite_node);
1618       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (prerequisite_node); i++)
1619     type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisites[i]));
1620       type_iface_add_prerequisite_W (iface, prerequisite_node);
1621       G_WRITE_UNLOCK (&amp;type_rw_lock);
1622     }
1623   else
1624     {
1625       G_WRITE_UNLOCK (&amp;type_rw_lock);
1626       g_warning (&quot;prerequisite &#39;%s&#39; for interface &#39;%s&#39; is neither instantiatable nor interface&quot;,
1627          type_descriptive_name_I (prerequisite_type),
1628          type_descriptive_name_I (interface_type));
1629     }
1630 }
1631 
1632 /**
1633  * g_type_interface_prerequisites:
1634  * @interface_type: an interface type
1635  * @n_prerequisites: (out) (optional): location to return the number
1636  *     of prerequisites, or %NULL
1637  *
1638  * Returns the prerequisites of an interfaces type.
1639  *
1640  * Since: 2.2
1641  *
1642  * Returns: (array length=n_prerequisites) (transfer full): a
1643  *     newly-allocated zero-terminated array of #GType containing
1644  *     the prerequisites of @interface_type
1645  */
1646 GType*
1647 g_type_interface_prerequisites (GType  interface_type,
1648                 guint *n_prerequisites)
1649 {
1650   TypeNode *iface;
1651 
1652   g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);
1653 
1654   iface = lookup_type_node_I (interface_type);
1655   if (iface)
1656     {
1657       GType *types;
1658       TypeNode *inode = NULL;
1659       guint i, n = 0;
1660 
1661       G_READ_LOCK (&amp;type_rw_lock);
1662       types = g_new0 (GType, IFACE_NODE_N_PREREQUISITES (iface) + 1);
1663       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
1664     {
1665       GType prerequisite = IFACE_NODE_PREREQUISITES (iface)[i];
1666       TypeNode *node = lookup_type_node_I (prerequisite);
1667       if (node-&gt;is_instantiatable)
1668             {
1669               if (!inode || type_node_is_a_L (node, inode))
1670             inode = node;
1671             }
1672       else
1673         types[n++] = NODE_TYPE (node);
1674     }
1675       if (inode)
1676     types[n++] = NODE_TYPE (inode);
1677 
1678       if (n_prerequisites)
1679     *n_prerequisites = n;
1680       G_READ_UNLOCK (&amp;type_rw_lock);
1681 
1682       return types;
1683     }
1684   else
1685     {
1686       if (n_prerequisites)
1687     *n_prerequisites = 0;
1688 
1689       return NULL;
1690     }
1691 }
1692 
1693 
1694 static IFaceHolder*
1695 type_iface_peek_holder_L (TypeNode *iface,
1696               GType     instance_type)
1697 {
1698   IFaceHolder *iholder;
1699 
1700   g_assert (NODE_IS_IFACE (iface));
1701 
1702   iholder = iface_node_get_holders_L (iface);
1703   while (iholder &amp;&amp; iholder-&gt;instance_type != instance_type)
1704     iholder = iholder-&gt;next;
1705   return iholder;
1706 }
1707 
1708 static IFaceHolder*
1709 type_iface_retrieve_holder_info_Wm (TypeNode *iface,
1710                     GType     instance_type,
1711                     gboolean  need_info)
1712 {
1713   IFaceHolder *iholder = type_iface_peek_holder_L (iface, instance_type);
1714 
1715   if (iholder &amp;&amp; !iholder-&gt;info &amp;&amp; need_info)
1716     {
1717       GInterfaceInfo tmp_info;
1718 
1719       g_assert (iholder-&gt;plugin != NULL);
1720 
1721       type_data_ref_Wm (iface);
1722       if (iholder-&gt;info)
1723     INVALID_RECURSION (&quot;g_type_plugin_*&quot;, iface-&gt;plugin, NODE_NAME (iface));
1724 
1725       memset (&amp;tmp_info, 0, sizeof (tmp_info));
1726 
1727       G_WRITE_UNLOCK (&amp;type_rw_lock);
1728       g_type_plugin_use (iholder-&gt;plugin);
1729       g_type_plugin_complete_interface_info (iholder-&gt;plugin, instance_type, NODE_TYPE (iface), &amp;tmp_info);
1730       G_WRITE_LOCK (&amp;type_rw_lock);
1731       if (iholder-&gt;info)
1732         INVALID_RECURSION (&quot;g_type_plugin_*&quot;, iholder-&gt;plugin, NODE_NAME (iface));
1733 
1734       check_interface_info_I (iface, instance_type, &amp;tmp_info);
1735       iholder-&gt;info = g_memdup (&amp;tmp_info, sizeof (tmp_info));
1736     }
1737 
1738   return iholder;   /* we don&#39;t modify write lock upon returning NULL */
1739 }
1740 
1741 static void
1742 type_iface_blow_holder_info_Wm (TypeNode *iface,
1743                 GType     instance_type)
1744 {
1745   IFaceHolder *iholder = iface_node_get_holders_L (iface);
1746 
1747   g_assert (NODE_IS_IFACE (iface));
1748 
1749 #ifdef GSTREAMER_LITE
1750   if (iholder == NULL)
1751       return;
1752 #endif // GSTREAMER_LITE
1753 
1754   while (iholder-&gt;instance_type != instance_type)
1755     iholder = iholder-&gt;next;
1756 
1757   if (iholder-&gt;info &amp;&amp; iholder-&gt;plugin)
1758     {
1759       g_free (iholder-&gt;info);
1760       iholder-&gt;info = NULL;
1761 
1762       G_WRITE_UNLOCK (&amp;type_rw_lock);
1763       g_type_plugin_unuse (iholder-&gt;plugin);
1764       type_data_unref_U (iface, FALSE);
1765       G_WRITE_LOCK (&amp;type_rw_lock);
1766     }
1767 }
1768 
1769 /**
1770  * g_type_create_instance: (skip)
1771  * @type: an instantiatable type to create an instance for
1772  *
1773  * Creates and initializes an instance of @type if @type is valid and
1774  * can be instantiated. The type system only performs basic allocation
1775  * and structure setups for instances: actual instance creation should
1776  * happen through functions supplied by the type&#39;s fundamental type
1777  * implementation.  So use of g_type_create_instance() is reserved for
1778  * implementators of fundamental types only. E.g. instances of the
1779  * #GObject hierarchy should be created via g_object_new() and never
1780  * directly through g_type_create_instance() which doesn&#39;t handle things
1781  * like singleton objects or object construction.
1782  *
1783  * The extended members of the returned instance are guaranteed to be filled
1784  * with zeros.
1785  *
1786  * Note: Do not use this function, unless you&#39;re implementing a
1787  * fundamental type. Also language bindings should not use this
1788  * function, but g_object_new() instead.
1789  *
1790  * Returns: an allocated and initialized instance, subject to further
1791  *     treatment by the fundamental type implementation
1792  */
1793 GTypeInstance*
1794 g_type_create_instance (GType type)
1795 {
1796   TypeNode *node;
1797   GTypeInstance *instance;
1798   GTypeClass *class;
1799   gchar *allocated;
1800   gint private_size;
1801   gint ivar_size;
1802   guint i;
1803 
1804   node = lookup_type_node_I (type);
1805   if (!node || !node-&gt;is_instantiatable)
1806     {
1807       g_error (&quot;cannot create new instance of invalid (non-instantiatable) type &#39;%s&#39;&quot;,
1808          type_descriptive_name_I (type));
1809     }
1810   /* G_TYPE_IS_ABSTRACT() is an external call: _U */
1811   if (!node-&gt;mutatable_check_cache &amp;&amp; G_TYPE_IS_ABSTRACT (type))
1812     {
1813       g_error (&quot;cannot create instance of abstract (non-instantiatable) type &#39;%s&#39;&quot;,
1814          type_descriptive_name_I (type));
1815     }
1816 
1817   class = g_type_class_ref (type);
1818 
1819   /* We allocate the &#39;private&#39; areas before the normal instance data, in
1820    * reverse order.  This allows the private area of a particular class
1821    * to always be at a constant relative address to the instance data.
1822    * If we stored the private data after the instance data this would
1823    * not be the case (since a subclass that added more instance
1824    * variables would push the private data further along).
1825    *
1826    * This presents problems for valgrindability, of course, so we do a
1827    * workaround for that case.  We identify the start of the object to
1828    * valgrind as an allocated block (so that pointers to objects show up
1829    * as &#39;reachable&#39; instead of &#39;possibly lost&#39;).  We then add an extra
1830    * pointer at the end of the object, after all instance data, back to
1831    * the start of the private area so that it is also recorded as
1832    * reachable.  We also add extra private space at the start because
1833    * valgrind doesn&#39;t seem to like us claiming to have allocated an
1834    * address that it saw allocated by malloc().
1835    */
1836   private_size = node-&gt;data-&gt;instance.private_size;
1837   ivar_size = node-&gt;data-&gt;instance.instance_size;
1838 
1839 #ifdef ENABLE_VALGRIND
1840   if (private_size &amp;&amp; RUNNING_ON_VALGRIND)
1841     {
1842       private_size += ALIGN_STRUCT (1);
1843 
1844       /* Allocate one extra pointer size... */
1845       allocated = g_slice_alloc0 (private_size + ivar_size + sizeof (gpointer));
1846       /* ... and point it back to the start of the private data. */
1847       *(gpointer *) (allocated + private_size + ivar_size) = allocated + ALIGN_STRUCT (1);
1848 
1849       /* Tell valgrind that it should treat the object itself as such */
1850       VALGRIND_MALLOCLIKE_BLOCK (allocated + private_size, ivar_size + sizeof (gpointer), 0, TRUE);
1851       VALGRIND_MALLOCLIKE_BLOCK (allocated + ALIGN_STRUCT (1), private_size - ALIGN_STRUCT (1), 0, TRUE);
1852     }
1853   else
1854 #endif
1855     allocated = g_slice_alloc0 (private_size + ivar_size);
1856 
1857   instance = (GTypeInstance *) (allocated + private_size);
1858 
1859   for (i = node-&gt;n_supers; i &gt; 0; i--)
1860     {
1861       TypeNode *pnode;
1862 
1863       pnode = lookup_type_node_I (node-&gt;supers[i]);
1864       if (pnode-&gt;data-&gt;instance.instance_init)
1865     {
1866       instance-&gt;g_class = pnode-&gt;data-&gt;instance.class;
1867       pnode-&gt;data-&gt;instance.instance_init (instance, class);
1868     }
1869     }
1870 
1871   instance-&gt;g_class = class;
1872   if (node-&gt;data-&gt;instance.instance_init)
1873     node-&gt;data-&gt;instance.instance_init (instance, class);
1874 
1875 #ifdef  G_ENABLE_DEBUG
1876   IF_DEBUG (INSTANCE_COUNT)
1877     {
1878       g_atomic_int_inc ((int *) &amp;node-&gt;instance_count);
1879     }
1880 #endif
1881 
1882   TRACE(GOBJECT_OBJECT_NEW(instance, type));
1883 
1884   return instance;
1885 }
1886 
1887 /**
1888  * g_type_free_instance:
1889  * @instance: an instance of a type
1890  *
1891  * Frees an instance of a type, returning it to the instance pool for
1892  * the type, if there is one.
1893  *
1894  * Like g_type_create_instance(), this function is reserved for
1895  * implementors of fundamental types.
1896  */
1897 void
1898 g_type_free_instance (GTypeInstance *instance)
1899 {
1900   TypeNode *node;
1901   GTypeClass *class;
1902   gchar *allocated;
1903   gint private_size;
1904   gint ivar_size;
1905 
1906   g_return_if_fail (instance != NULL &amp;&amp; instance-&gt;g_class != NULL);
1907 
1908   class = instance-&gt;g_class;
1909   node = lookup_type_node_I (class-&gt;g_type);
1910   if (!node || !node-&gt;is_instantiatable || !node-&gt;data || node-&gt;data-&gt;class.class != (gpointer) class)
1911     {
1912       g_warning (&quot;cannot free instance of invalid (non-instantiatable) type &#39;%s&#39;&quot;,
1913          type_descriptive_name_I (class-&gt;g_type));
1914       return;
1915     }
1916   /* G_TYPE_IS_ABSTRACT() is an external call: _U */
1917   if (!node-&gt;mutatable_check_cache &amp;&amp; G_TYPE_IS_ABSTRACT (NODE_TYPE (node)))
1918     {
1919       g_warning (&quot;cannot free instance of abstract (non-instantiatable) type &#39;%s&#39;&quot;,
1920          NODE_NAME (node));
1921       return;
1922     }
1923 
1924   instance-&gt;g_class = NULL;
1925   private_size = node-&gt;data-&gt;instance.private_size;
1926   ivar_size = node-&gt;data-&gt;instance.instance_size;
1927   allocated = ((gchar *) instance) - private_size;
1928 
1929 #ifdef G_ENABLE_DEBUG
1930   memset (allocated, 0xaa, ivar_size + private_size);
1931 #endif
1932 
1933 #ifdef ENABLE_VALGRIND
1934   /* See comment in g_type_create_instance() about what&#39;s going on here.
1935    * We&#39;re basically unwinding what we put into motion there.
1936    */
1937   if (private_size &amp;&amp; RUNNING_ON_VALGRIND)
1938     {
1939       private_size += ALIGN_STRUCT (1);
1940       allocated -= ALIGN_STRUCT (1);
1941 
1942       /* Clear out the extra pointer... */
1943       *(gpointer *) (allocated + private_size + ivar_size) = NULL;
1944       /* ... and ensure we include it in the size we free. */
1945       g_slice_free1 (private_size + ivar_size + sizeof (gpointer), allocated);
1946 
1947       VALGRIND_FREELIKE_BLOCK (allocated + ALIGN_STRUCT (1), 0);
1948       VALGRIND_FREELIKE_BLOCK (instance, 0);
1949     }
1950   else
1951 #endif
1952     g_slice_free1 (private_size + ivar_size, allocated);
1953 
1954 #ifdef  G_ENABLE_DEBUG
1955   IF_DEBUG (INSTANCE_COUNT)
1956     {
1957       g_atomic_int_add ((int *) &amp;node-&gt;instance_count, -1);
1958     }
1959 #endif
1960 
1961   g_type_class_unref (class);
1962 }
1963 
1964 static void
1965 type_iface_ensure_dflt_vtable_Wm (TypeNode *iface)
1966 {
1967   g_assert (iface-&gt;data);
1968 
1969   if (!iface-&gt;data-&gt;iface.dflt_vtable)
1970     {
1971       GTypeInterface *vtable = g_malloc0 (iface-&gt;data-&gt;iface.vtable_size);
1972 #ifdef GSTREAMER_LITE
1973       if (vtable == NULL)
1974           return;
1975 #endif // GSTREAMER_LITE
1976       iface-&gt;data-&gt;iface.dflt_vtable = vtable;
1977       vtable-&gt;g_type = NODE_TYPE (iface);
1978       vtable-&gt;g_instance_type = 0;
1979       if (iface-&gt;data-&gt;iface.vtable_init_base ||
1980           iface-&gt;data-&gt;iface.dflt_init)
1981         {
1982           G_WRITE_UNLOCK (&amp;type_rw_lock);
1983           if (iface-&gt;data-&gt;iface.vtable_init_base)
1984             iface-&gt;data-&gt;iface.vtable_init_base (vtable);
1985           if (iface-&gt;data-&gt;iface.dflt_init)
1986             iface-&gt;data-&gt;iface.dflt_init (vtable, (gpointer) iface-&gt;data-&gt;iface.dflt_data);
1987           G_WRITE_LOCK (&amp;type_rw_lock);
1988         }
1989     }
1990 }
1991 
1992 
1993 /* This is called to allocate and do the first part of initializing
1994  * the interface vtable; type_iface_vtable_iface_init_Wm() does the remainder.
1995  *
1996  * A FALSE return indicates that we didn&#39;t find an init function for
1997  * this type/iface pair, so the vtable from the parent type should
1998  * be used. Note that the write lock is not modified upon a FALSE
1999  * return.
2000  */
2001 static gboolean
2002 type_iface_vtable_base_init_Wm (TypeNode *iface,
2003                 TypeNode *node)
2004 {
2005   IFaceEntry *entry;
2006   IFaceHolder *iholder;
2007   GTypeInterface *vtable = NULL;
2008   TypeNode *pnode;
2009 
2010   /* type_iface_retrieve_holder_info_Wm() doesn&#39;t modify write lock for returning NULL */
2011   iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), TRUE);
2012   if (!iholder)
2013     return FALSE;   /* we don&#39;t modify write lock upon FALSE */
2014 
2015   type_iface_ensure_dflt_vtable_Wm (iface);
2016 
2017   entry = type_lookup_iface_entry_L (node, iface);
2018 #ifdef GSTREAMER_LITE
2019   if (entry == NULL)
2020     return FALSE;
2021 #endif // GSTREAMER_LITE
2022 
2023   g_assert (iface-&gt;data &amp;&amp; entry &amp;&amp; entry-&gt;vtable == NULL &amp;&amp; iholder &amp;&amp; iholder-&gt;info);
2024 
2025   entry-&gt;init_state = IFACE_INIT;
2026 
2027   pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
2028   if (pnode)    /* want to copy over parent iface contents */
2029     {
2030       IFaceEntry *pentry = type_lookup_iface_entry_L (pnode, iface);
2031 
2032       if (pentry)
2033     vtable = g_memdup (pentry-&gt;vtable, iface-&gt;data-&gt;iface.vtable_size);
2034     }
2035   if (!vtable)
2036     vtable = g_memdup (iface-&gt;data-&gt;iface.dflt_vtable, iface-&gt;data-&gt;iface.vtable_size);
2037   entry-&gt;vtable = vtable;
2038   vtable-&gt;g_type = NODE_TYPE (iface);
2039   vtable-&gt;g_instance_type = NODE_TYPE (node);
2040 
2041   if (iface-&gt;data-&gt;iface.vtable_init_base)
2042     {
2043       G_WRITE_UNLOCK (&amp;type_rw_lock);
2044       iface-&gt;data-&gt;iface.vtable_init_base (vtable);
2045       G_WRITE_LOCK (&amp;type_rw_lock);
2046     }
2047   return TRUE;  /* initialized the vtable */
2048 }
2049 
2050 /* Finishes what type_iface_vtable_base_init_Wm started by
2051  * calling the interface init function.
2052  * this function may only be called for types with their
2053  * own interface holder info, i.e. types for which
2054  * g_type_add_interface*() was called and not children thereof.
2055  */
2056 static void
2057 type_iface_vtable_iface_init_Wm (TypeNode *iface,
2058                  TypeNode *node)
2059 {
2060   IFaceEntry *entry = type_lookup_iface_entry_L (node, iface);
2061   IFaceHolder *iholder = type_iface_peek_holder_L (iface, NODE_TYPE (node));
2062   GTypeInterface *vtable = NULL;
2063   guint i;
2064 
2065   /* iholder-&gt;info should have been filled in by type_iface_vtable_base_init_Wm() */
2066   g_assert (iface-&gt;data &amp;&amp; entry &amp;&amp; iholder &amp;&amp; iholder-&gt;info);
2067   g_assert (entry-&gt;init_state == IFACE_INIT); /* assert prior base_init() */
2068 #ifdef GSTREAMER_LITE
2069   if (entry == NULL)
2070     return;
2071 #endif // GSTREAMER_LITE
2072 
2073   entry-&gt;init_state = INITIALIZED;
2074 
2075   vtable = entry-&gt;vtable;
2076 
2077   if (iholder-&gt;info-&gt;interface_init)
2078     {
2079       G_WRITE_UNLOCK (&amp;type_rw_lock);
2080       if (iholder-&gt;info-&gt;interface_init)
2081     iholder-&gt;info-&gt;interface_init (vtable, iholder-&gt;info-&gt;interface_data);
2082       G_WRITE_LOCK (&amp;type_rw_lock);
2083     }
2084 
2085   for (i = 0; i &lt; static_n_iface_check_funcs; i++)
2086     {
2087       GTypeInterfaceCheckFunc check_func = static_iface_check_funcs[i].check_func;
2088       gpointer check_data = static_iface_check_funcs[i].check_data;
2089 
2090       G_WRITE_UNLOCK (&amp;type_rw_lock);
2091       check_func (check_data, (gpointer)vtable);
2092       G_WRITE_LOCK (&amp;type_rw_lock);
2093     }
2094 }
2095 
2096 static gboolean
2097 type_iface_vtable_finalize_Wm (TypeNode       *iface,
2098                    TypeNode       *node,
2099                    GTypeInterface *vtable)
2100 {
2101   IFaceEntry *entry = type_lookup_iface_entry_L (node, iface);
2102   IFaceHolder *iholder;
2103 
2104   /* type_iface_retrieve_holder_info_Wm() doesn&#39;t modify write lock for returning NULL */
2105   iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), FALSE);
2106   if (!iholder)
2107     return FALSE;   /* we don&#39;t modify write lock upon FALSE */
2108 
2109   g_assert (entry &amp;&amp; entry-&gt;vtable == vtable &amp;&amp; iholder-&gt;info);
2110 
2111   entry-&gt;vtable = NULL;
2112   entry-&gt;init_state = UNINITIALIZED;
2113   if (iholder-&gt;info-&gt;interface_finalize || iface-&gt;data-&gt;iface.vtable_finalize_base)
2114     {
2115       G_WRITE_UNLOCK (&amp;type_rw_lock);
2116       if (iholder-&gt;info-&gt;interface_finalize)
2117     iholder-&gt;info-&gt;interface_finalize (vtable, iholder-&gt;info-&gt;interface_data);
2118       if (iface-&gt;data-&gt;iface.vtable_finalize_base)
2119     iface-&gt;data-&gt;iface.vtable_finalize_base (vtable);
2120       G_WRITE_LOCK (&amp;type_rw_lock);
2121     }
2122   vtable-&gt;g_type = 0;
2123   vtable-&gt;g_instance_type = 0;
2124   g_free (vtable);
2125 
2126   type_iface_blow_holder_info_Wm (iface, NODE_TYPE (node));
2127 
2128   return TRUE;  /* write lock modified */
2129 }
2130 
2131 static void
2132 type_class_init_Wm (TypeNode   *node,
2133             GTypeClass *pclass)
2134 {
2135   GSList *slist, *init_slist = NULL;
2136   GTypeClass *class;
2137   IFaceEntries *entries;
2138   IFaceEntry *entry;
2139   TypeNode *bnode, *pnode;
2140   guint i;
2141 
2142   /* Accessing data-&gt;class will work for instantiable types
2143    * too because ClassData is a subset of InstanceData
2144    */
2145   g_assert (node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp;
2146         node-&gt;data-&gt;class.class_size &amp;&amp;
2147         !node-&gt;data-&gt;class.class &amp;&amp;
2148         node-&gt;data-&gt;class.init_state == UNINITIALIZED);
2149   if (node-&gt;data-&gt;class.class_private_size)
2150     class = g_malloc0 (ALIGN_STRUCT (node-&gt;data-&gt;class.class_size) + node-&gt;data-&gt;class.class_private_size);
2151   else
2152     class = g_malloc0 (node-&gt;data-&gt;class.class_size);
2153   node-&gt;data-&gt;class.class = class;
2154   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, BASE_CLASS_INIT);
2155 
2156   if (pclass)
2157     {
2158       TypeNode *pnode = lookup_type_node_I (pclass-&gt;g_type);
2159 
2160       memcpy (class, pclass, pnode-&gt;data-&gt;class.class_size);
2161       memcpy (G_STRUCT_MEMBER_P (class, ALIGN_STRUCT (node-&gt;data-&gt;class.class_size)), G_STRUCT_MEMBER_P (pclass, ALIGN_STRUCT (pnode-&gt;data-&gt;class.class_size)), pnode-&gt;data-&gt;class.class_private_size);
2162 
2163       if (node-&gt;is_instantiatable)
2164     {
2165       /* We need to initialize the private_size here rather than in
2166        * type_data_make_W() since the class init for the parent
2167        * class may have changed pnode-&gt;data-&gt;instance.private_size.
2168        */
2169       node-&gt;data-&gt;instance.private_size = pnode-&gt;data-&gt;instance.private_size;
2170     }
2171     }
2172   class-&gt;g_type = NODE_TYPE (node);
2173 
2174   G_WRITE_UNLOCK (&amp;type_rw_lock);
2175 
2176   /* stack all base class initialization functions, so we
2177    * call them in ascending order.
2178    */
2179   for (bnode = node; bnode; bnode = lookup_type_node_I (NODE_PARENT_TYPE (bnode)))
2180     if (bnode-&gt;data-&gt;class.class_init_base)
2181       init_slist = g_slist_prepend (init_slist, (gpointer) bnode-&gt;data-&gt;class.class_init_base);
2182   for (slist = init_slist; slist; slist = slist-&gt;next)
2183     {
2184       GBaseInitFunc class_init_base = (GBaseInitFunc) slist-&gt;data;
2185 
2186       class_init_base (class);
2187     }
2188   g_slist_free (init_slist);
2189 
2190   G_WRITE_LOCK (&amp;type_rw_lock);
2191 
2192   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, BASE_IFACE_INIT);
2193 
2194   /* Before we initialize the class, base initialize all interfaces, either
2195    * from parent, or through our holder info
2196    */
2197   pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
2198 
2199   i = 0;
2200   while ((entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node)) != NULL &amp;&amp;
2201       i &lt; IFACE_ENTRIES_N_ENTRIES (entries))
2202     {
2203       entry = &amp;entries-&gt;entry[i];
2204       while (i &lt; IFACE_ENTRIES_N_ENTRIES (entries) &amp;&amp;
2205          entry-&gt;init_state == IFACE_INIT)
2206     {
2207       entry++;
2208       i++;
2209     }
2210 
2211       if (i == IFACE_ENTRIES_N_ENTRIES (entries))
2212     break;
2213 
2214       if (!type_iface_vtable_base_init_Wm (lookup_type_node_I (entry-&gt;iface_type), node))
2215     {
2216       guint j;
2217       IFaceEntries *pentries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (pnode);
2218 
2219       /* need to get this interface from parent, type_iface_vtable_base_init_Wm()
2220        * doesn&#39;t modify write lock upon FALSE, so entry is still valid;
2221        */
2222       g_assert (pnode != NULL);
2223 
2224       if (pentries)
2225         for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (pentries); j++)
2226           {
2227         IFaceEntry *pentry = &amp;pentries-&gt;entry[j];
2228 
2229         if (pentry-&gt;iface_type == entry-&gt;iface_type)
2230           {
2231             entry-&gt;vtable = pentry-&gt;vtable;
2232             entry-&gt;init_state = INITIALIZED;
2233             break;
2234           }
2235           }
2236       g_assert (entry-&gt;vtable != NULL);
2237     }
2238 
2239       /* If the write lock was released, additional interface entries might
2240        * have been inserted into CLASSED_NODE_IFACES_ENTRIES (node); they&#39;ll
2241        * be base-initialized when inserted, so we don&#39;t have to worry that
2242        * we might miss them. Uninitialized entries can only be moved higher
2243        * when new ones are inserted.
2244        */
2245       i++;
2246     }
2247 
2248   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, CLASS_INIT);
2249 
2250   G_WRITE_UNLOCK (&amp;type_rw_lock);
2251 
2252   if (node-&gt;data-&gt;class.class_init)
2253     node-&gt;data-&gt;class.class_init (class, (gpointer) node-&gt;data-&gt;class.class_data);
2254 
2255   G_WRITE_LOCK (&amp;type_rw_lock);
2256 
2257   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, IFACE_INIT);
2258 
2259   /* finish initializing the interfaces through our holder info.
2260    * inherited interfaces are already init_state == INITIALIZED, because
2261    * they either got setup in the above base_init loop, or during
2262    * class_init from within type_add_interface_Wm() for this or
2263    * an anchestor type.
2264    */
2265   i = 0;
2266   while ((entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node)) != NULL)
2267     {
2268       entry = &amp;entries-&gt;entry[i];
2269       while (i &lt; IFACE_ENTRIES_N_ENTRIES (entries) &amp;&amp;
2270          entry-&gt;init_state == INITIALIZED)
2271     {
2272       entry++;
2273       i++;
2274     }
2275 
2276       if (i == IFACE_ENTRIES_N_ENTRIES (entries))
2277     break;
2278 
2279       type_iface_vtable_iface_init_Wm (lookup_type_node_I (entry-&gt;iface_type), node);
2280 
2281       /* As in the loop above, additional initialized entries might be inserted
2282        * if the write lock is released, but that&#39;s harmless because the entries
2283        * we need to initialize only move higher in the list.
2284        */
2285       i++;
2286     }
2287 
2288   g_atomic_int_set (&amp;node-&gt;data-&gt;class.init_state, INITIALIZED);
2289 }
2290 
2291 static void
2292 type_data_finalize_class_ifaces_Wm (TypeNode *node)
2293 {
2294   guint i;
2295   IFaceEntries *entries;
2296 
2297   g_assert (node-&gt;is_instantiatable &amp;&amp; node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class &amp;&amp; NODE_REFCOUNT (node) == 0);
2298 
2299  reiterate:
2300   entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
2301   for (i = 0; entries != NULL &amp;&amp; i &lt; IFACE_ENTRIES_N_ENTRIES (entries); i++)
2302     {
2303       IFaceEntry *entry = &amp;entries-&gt;entry[i];
2304       if (entry-&gt;vtable)
2305     {
2306           if (type_iface_vtable_finalize_Wm (lookup_type_node_I (entry-&gt;iface_type), node, entry-&gt;vtable))
2307             {
2308               /* refetch entries, IFACES_ENTRIES might be modified */
2309               goto reiterate;
2310             }
2311           else
2312             {
2313               /* type_iface_vtable_finalize_Wm() doesn&#39;t modify write lock upon FALSE,
2314                * iface vtable came from parent
2315                */
2316               entry-&gt;vtable = NULL;
2317               entry-&gt;init_state = UNINITIALIZED;
2318             }
2319     }
2320     }
2321 }
2322 
2323 static void
2324 type_data_finalize_class_U (TypeNode  *node,
2325                 ClassData *cdata)
2326 {
2327   GTypeClass *class = cdata-&gt;class;
2328   TypeNode *bnode;
2329 
2330   g_assert (cdata-&gt;class &amp;&amp; NODE_REFCOUNT (node) == 0);
2331 
2332   if (cdata-&gt;class_finalize)
2333     cdata-&gt;class_finalize (class, (gpointer) cdata-&gt;class_data);
2334 
2335   /* call all base class destruction functions in descending order
2336    */
2337   if (cdata-&gt;class_finalize_base)
2338     cdata-&gt;class_finalize_base (class);
2339   for (bnode = lookup_type_node_I (NODE_PARENT_TYPE (node)); bnode; bnode = lookup_type_node_I (NODE_PARENT_TYPE (bnode)))
2340     if (bnode-&gt;data-&gt;class.class_finalize_base)
2341       bnode-&gt;data-&gt;class.class_finalize_base (class);
2342 
2343   g_free (cdata-&gt;class);
2344 }
2345 
2346 static void
2347 type_data_last_unref_Wm (TypeNode *node,
2348              gboolean  uncached)
2349 {
2350   g_return_if_fail (node != NULL &amp;&amp; node-&gt;plugin != NULL);
2351 
2352   if (!node-&gt;data || NODE_REFCOUNT (node) == 0)
2353     {
2354       g_warning (&quot;cannot drop last reference to unreferenced type &#39;%s&#39;&quot;,
2355          NODE_NAME (node));
2356       return;
2357     }
2358 
2359   /* call class cache hooks */
2360   if (node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class &amp;&amp; static_n_class_cache_funcs &amp;&amp; !uncached)
2361     {
2362       guint i;
2363 
2364       G_WRITE_UNLOCK (&amp;type_rw_lock);
2365       G_READ_LOCK (&amp;type_rw_lock);
2366       for (i = 0; i &lt; static_n_class_cache_funcs; i++)
2367     {
2368       GTypeClassCacheFunc cache_func = static_class_cache_funcs[i].cache_func;
2369       gpointer cache_data = static_class_cache_funcs[i].cache_data;
2370       gboolean need_break;
2371 
2372       G_READ_UNLOCK (&amp;type_rw_lock);
2373       need_break = cache_func (cache_data, node-&gt;data-&gt;class.class);
2374       G_READ_LOCK (&amp;type_rw_lock);
2375       if (!node-&gt;data || NODE_REFCOUNT (node) == 0)
2376         INVALID_RECURSION (&quot;GType class cache function &quot;, cache_func, NODE_NAME (node));
2377       if (need_break)
2378         break;
2379     }
2380       G_READ_UNLOCK (&amp;type_rw_lock);
2381       G_WRITE_LOCK (&amp;type_rw_lock);
2382     }
2383 
2384   /* may have been re-referenced meanwhile */
2385   if (g_atomic_int_dec_and_test ((int *) &amp;node-&gt;ref_count))
2386     {
2387       GType ptype = NODE_PARENT_TYPE (node);
2388       TypeData *tdata;
2389 
2390       if (node-&gt;is_instantiatable)
2391     {
2392       /* destroy node-&gt;data-&gt;instance.mem_chunk */
2393     }
2394 
2395       tdata = node-&gt;data;
2396       if (node-&gt;is_classed &amp;&amp; tdata-&gt;class.class)
2397     {
2398       if (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node) != NULL)
2399         type_data_finalize_class_ifaces_Wm (node);
2400       node-&gt;mutatable_check_cache = FALSE;
2401       node-&gt;data = NULL;
2402       G_WRITE_UNLOCK (&amp;type_rw_lock);
2403       type_data_finalize_class_U (node, &amp;tdata-&gt;class);
2404       G_WRITE_LOCK (&amp;type_rw_lock);
2405     }
2406       else if (NODE_IS_IFACE (node) &amp;&amp; tdata-&gt;iface.dflt_vtable)
2407         {
2408           node-&gt;mutatable_check_cache = FALSE;
2409           node-&gt;data = NULL;
2410           if (tdata-&gt;iface.dflt_finalize || tdata-&gt;iface.vtable_finalize_base)
2411             {
2412               G_WRITE_UNLOCK (&amp;type_rw_lock);
2413               if (tdata-&gt;iface.dflt_finalize)
2414                 tdata-&gt;iface.dflt_finalize (tdata-&gt;iface.dflt_vtable, (gpointer) tdata-&gt;iface.dflt_data);
2415               if (tdata-&gt;iface.vtable_finalize_base)
2416                 tdata-&gt;iface.vtable_finalize_base (tdata-&gt;iface.dflt_vtable);
2417               G_WRITE_LOCK (&amp;type_rw_lock);
2418             }
2419           g_free (tdata-&gt;iface.dflt_vtable);
2420         }
2421       else
2422         {
2423           node-&gt;mutatable_check_cache = FALSE;
2424           node-&gt;data = NULL;
2425         }
2426 
2427       /* freeing tdata-&gt;common.value_table and its contents is taken care of
2428        * by allocating it in one chunk with tdata
2429        */
2430       g_free (tdata);
2431 
2432       G_WRITE_UNLOCK (&amp;type_rw_lock);
2433       g_type_plugin_unuse (node-&gt;plugin);
2434       if (ptype)
2435     type_data_unref_U (lookup_type_node_I (ptype), FALSE);
2436       G_WRITE_LOCK (&amp;type_rw_lock);
2437     }
2438 }
2439 
2440 static inline void
2441 type_data_unref_U (TypeNode *node,
2442                    gboolean  uncached)
2443 {
2444   guint current;
2445 
2446   do {
2447     current = NODE_REFCOUNT (node);
2448 
2449     if (current &lt;= 1)
2450     {
2451       if (!node-&gt;plugin)
2452     {
2453       g_warning (&quot;static type &#39;%s&#39; unreferenced too often&quot;,
2454              NODE_NAME (node));
2455       return;
2456     }
2457       else
2458         {
2459           /* This is the last reference of a type from a plugin.  We are
2460            * experimentally disabling support for unloading type
2461            * plugins, so don&#39;t allow the last ref to drop.
2462            */
2463           return;
2464         }
2465 
2466       g_assert (current &gt; 0);
2467 
2468       g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
2469       G_WRITE_LOCK (&amp;type_rw_lock);
2470       type_data_last_unref_Wm (node, uncached);
2471       G_WRITE_UNLOCK (&amp;type_rw_lock);
2472       g_rec_mutex_unlock (&amp;class_init_rec_mutex);
2473       return;
2474     }
2475   } while (!g_atomic_int_compare_and_exchange ((int *) &amp;node-&gt;ref_count, current, current - 1));
2476 }
2477 
2478 /**
2479  * g_type_add_class_cache_func: (skip)
2480  * @cache_data: data to be passed to @cache_func
2481  * @cache_func: a #GTypeClassCacheFunc
2482  *
2483  * Adds a #GTypeClassCacheFunc to be called before the reference count of a
2484  * class goes from one to zero. This can be used to prevent premature class
2485  * destruction. All installed #GTypeClassCacheFunc functions will be chained
2486  * until one of them returns %TRUE. The functions have to check the class id
2487  * passed in to figure whether they actually want to cache the class of this
2488  * type, since all classes are routed through the same #GTypeClassCacheFunc
2489  * chain.
2490  */
2491 void
2492 g_type_add_class_cache_func (gpointer            cache_data,
2493                  GTypeClassCacheFunc cache_func)
2494 {
2495   guint i;
2496 
2497   g_return_if_fail (cache_func != NULL);
2498 
2499   G_WRITE_LOCK (&amp;type_rw_lock);
2500   i = static_n_class_cache_funcs++;
2501   static_class_cache_funcs = g_renew (ClassCacheFunc, static_class_cache_funcs, static_n_class_cache_funcs);
2502   static_class_cache_funcs[i].cache_data = cache_data;
2503   static_class_cache_funcs[i].cache_func = cache_func;
2504   G_WRITE_UNLOCK (&amp;type_rw_lock);
2505 }
2506 
2507 /**
2508  * g_type_remove_class_cache_func: (skip)
2509  * @cache_data: data that was given when adding @cache_func
2510  * @cache_func: a #GTypeClassCacheFunc
2511  *
2512  * Removes a previously installed #GTypeClassCacheFunc. The cache
2513  * maintained by @cache_func has to be empty when calling
2514  * g_type_remove_class_cache_func() to avoid leaks.
2515  */
2516 void
2517 g_type_remove_class_cache_func (gpointer            cache_data,
2518                 GTypeClassCacheFunc cache_func)
2519 {
2520   gboolean found_it = FALSE;
2521   guint i;
2522 
2523   g_return_if_fail (cache_func != NULL);
2524 
2525   G_WRITE_LOCK (&amp;type_rw_lock);
2526   for (i = 0; i &lt; static_n_class_cache_funcs; i++)
2527     if (static_class_cache_funcs[i].cache_data == cache_data &amp;&amp;
2528     static_class_cache_funcs[i].cache_func == cache_func)
2529       {
2530     static_n_class_cache_funcs--;
2531     memmove (static_class_cache_funcs + i,
2532                  static_class_cache_funcs + i + 1,
2533                  sizeof (static_class_cache_funcs[0]) * (static_n_class_cache_funcs - i));
2534     static_class_cache_funcs = g_renew (ClassCacheFunc, static_class_cache_funcs, static_n_class_cache_funcs);
2535     found_it = TRUE;
2536     break;
2537       }
2538   G_WRITE_UNLOCK (&amp;type_rw_lock);
2539 
2540   if (!found_it)
2541     g_warning (G_STRLOC &quot;: cannot remove unregistered class cache func %p with data %p&quot;,
2542            cache_func, cache_data);
2543 }
2544 
2545 
2546 /**
2547  * g_type_add_interface_check: (skip)
2548  * @check_data: data to pass to @check_func
2549  * @check_func: function to be called after each interface
2550  *     is initialized
2551  *
2552  * Adds a function to be called after an interface vtable is
2553  * initialized for any class (i.e. after the @interface_init
2554  * member of #GInterfaceInfo has been called).
2555  *
2556  * This function is useful when you want to check an invariant
2557  * that depends on the interfaces of a class. For instance, the
2558  * implementation of #GObject uses this facility to check that an
2559  * object implements all of the properties that are defined on its
2560  * interfaces.
2561  *
2562  * Since: 2.4
2563  */
2564 void
2565 g_type_add_interface_check (gpointer                check_data,
2566                             GTypeInterfaceCheckFunc check_func)
2567 {
2568   guint i;
2569 
2570   g_return_if_fail (check_func != NULL);
2571 
2572   G_WRITE_LOCK (&amp;type_rw_lock);
2573   i = static_n_iface_check_funcs++;
2574   static_iface_check_funcs = g_renew (IFaceCheckFunc, static_iface_check_funcs, static_n_iface_check_funcs);
2575   static_iface_check_funcs[i].check_data = check_data;
2576   static_iface_check_funcs[i].check_func = check_func;
2577   G_WRITE_UNLOCK (&amp;type_rw_lock);
2578 }
2579 
2580 /**
2581  * g_type_remove_interface_check: (skip)
2582  * @check_data: callback data passed to g_type_add_interface_check()
2583  * @check_func: callback function passed to g_type_add_interface_check()
2584  *
2585  * Removes an interface check function added with
2586  * g_type_add_interface_check().
2587  *
2588  * Since: 2.4
2589  */
2590 void
2591 g_type_remove_interface_check (gpointer                check_data,
2592                                GTypeInterfaceCheckFunc check_func)
2593 {
2594   gboolean found_it = FALSE;
2595   guint i;
2596 
2597   g_return_if_fail (check_func != NULL);
2598 
2599   G_WRITE_LOCK (&amp;type_rw_lock);
2600   for (i = 0; i &lt; static_n_iface_check_funcs; i++)
2601     if (static_iface_check_funcs[i].check_data == check_data &amp;&amp;
2602     static_iface_check_funcs[i].check_func == check_func)
2603       {
2604     static_n_iface_check_funcs--;
2605     memmove (static_iface_check_funcs + i,
2606                  static_iface_check_funcs + i + 1,
2607                  sizeof (static_iface_check_funcs[0]) * (static_n_iface_check_funcs - i));
2608     static_iface_check_funcs = g_renew (IFaceCheckFunc, static_iface_check_funcs, static_n_iface_check_funcs);
2609     found_it = TRUE;
2610     break;
2611       }
2612   G_WRITE_UNLOCK (&amp;type_rw_lock);
2613 
2614   if (!found_it)
2615     g_warning (G_STRLOC &quot;: cannot remove unregistered class check func %p with data %p&quot;,
2616            check_func, check_data);
2617 }
2618 
2619 /* --- type registration --- */
2620 /**
2621  * g_type_register_fundamental:
2622  * @type_id: a predefined type identifier
2623  * @type_name: 0-terminated string used as the name of the new type
2624  * @info: #GTypeInfo structure for this type
2625  * @finfo: #GTypeFundamentalInfo structure for this type
2626  * @flags: bitwise combination of #GTypeFlags values
2627  *
2628  * Registers @type_id as the predefined identifier and @type_name as the
2629  * name of a fundamental type. If @type_id is already registered, or a
2630  * type named @type_name is already registered, the behaviour is undefined.
2631  * The type system uses the information contained in the #GTypeInfo structure
2632  * pointed to by @info and the #GTypeFundamentalInfo structure pointed to by
2633  * @finfo to manage the type and its instances. The value of @flags determines
2634  * additional characteristics of the fundamental type.
2635  *
2636  * Returns: the predefined type identifier
2637  */
2638 GType
2639 g_type_register_fundamental (GType                       type_id,
2640                              const gchar                *type_name,
2641                              const GTypeInfo            *info,
2642                              const GTypeFundamentalInfo *finfo,
2643                  GTypeFlags          flags)
2644 {
2645   TypeNode *node;
2646 
2647   g_assert_type_system_initialized ();
2648   g_return_val_if_fail (type_id &gt; 0, 0);
2649   g_return_val_if_fail (type_name != NULL, 0);
2650   g_return_val_if_fail (info != NULL, 0);
2651   g_return_val_if_fail (finfo != NULL, 0);
2652 
2653   if (!check_type_name_I (type_name))
2654     return 0;
2655   if ((type_id &amp; TYPE_ID_MASK) ||
2656       type_id &gt; G_TYPE_FUNDAMENTAL_MAX)
2657     {
2658       g_warning (&quot;attempt to register fundamental type &#39;%s&#39; with invalid type id (%&quot; G_GSIZE_FORMAT &quot;)&quot;,
2659          type_name,
2660          type_id);
2661       return 0;
2662     }
2663   if ((finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) &amp;&amp;
2664       !(finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED))
2665     {
2666       g_warning (&quot;cannot register instantiatable fundamental type &#39;%s&#39; as non-classed&quot;,
2667          type_name);
2668       return 0;
2669     }
2670   if (lookup_type_node_I (type_id))
2671     {
2672       g_warning (&quot;cannot register existing fundamental type &#39;%s&#39; (as &#39;%s&#39;)&quot;,
2673          type_descriptive_name_I (type_id),
2674          type_name);
2675       return 0;
2676     }
2677 
2678   G_WRITE_LOCK (&amp;type_rw_lock);
2679   node = type_node_fundamental_new_W (type_id, type_name, finfo-&gt;type_flags);
2680   type_add_flags_W (node, flags);
2681 
2682   if (check_type_info_I (NULL, NODE_FUNDAMENTAL_TYPE (node), type_name, info))
2683     type_data_make_W (node, info,
2684               check_value_table_I (type_name, info-&gt;value_table) ? info-&gt;value_table : NULL);
2685   G_WRITE_UNLOCK (&amp;type_rw_lock);
2686 
2687   return NODE_TYPE (node);
2688 }
2689 
2690 /**
2691  * g_type_register_static_simple: (skip)
2692  * @parent_type: type from which this type will be derived
2693  * @type_name: 0-terminated string used as the name of the new type
2694  * @class_size: size of the class structure (see #GTypeInfo)
2695  * @class_init: location of the class initialization function (see #GTypeInfo)
2696  * @instance_size: size of the instance structure (see #GTypeInfo)
2697  * @instance_init: location of the instance initialization function (see #GTypeInfo)
2698  * @flags: bitwise combination of #GTypeFlags values
2699  *
2700  * Registers @type_name as the name of a new static type derived from
2701  * @parent_type.  The value of @flags determines the nature (e.g.
2702  * abstract or not) of the type. It works by filling a #GTypeInfo
2703  * struct and calling g_type_register_static().
2704  *
2705  * Since: 2.12
2706  *
2707  * Returns: the new type identifier
2708  */
2709 GType
2710 g_type_register_static_simple (GType             parent_type,
2711                                const gchar      *type_name,
2712                                guint             class_size,
2713                                GClassInitFunc    class_init,
2714                                guint             instance_size,
2715                                GInstanceInitFunc instance_init,
2716                    GTypeFlags    flags)
2717 {
2718   GTypeInfo info;
2719 
2720   /* Instances are not allowed to be larger than this. If you have a big
2721    * fixed-length array or something, point to it instead.
2722    */
2723   g_return_val_if_fail (class_size &lt;= G_MAXUINT16, G_TYPE_INVALID);
2724   g_return_val_if_fail (instance_size &lt;= G_MAXUINT16, G_TYPE_INVALID);
2725 
2726   info.class_size = class_size;
2727   info.base_init = NULL;
2728   info.base_finalize = NULL;
2729   info.class_init = class_init;
2730   info.class_finalize = NULL;
2731   info.class_data = NULL;
2732   info.instance_size = instance_size;
2733   info.n_preallocs = 0;
2734   info.instance_init = instance_init;
2735   info.value_table = NULL;
2736 
2737   return g_type_register_static (parent_type, type_name, &amp;info, flags);
2738 }
2739 
2740 /**
2741  * g_type_register_static:
2742  * @parent_type: type from which this type will be derived
2743  * @type_name: 0-terminated string used as the name of the new type
2744  * @info: #GTypeInfo structure for this type
2745  * @flags: bitwise combination of #GTypeFlags values
2746  *
2747  * Registers @type_name as the name of a new static type derived from
2748  * @parent_type. The type system uses the information contained in the
2749  * #GTypeInfo structure pointed to by @info to manage the type and its
2750  * instances (if not abstract). The value of @flags determines the nature
2751  * (e.g. abstract or not) of the type.
2752  *
2753  * Returns: the new type identifier
2754  */
2755 GType
2756 g_type_register_static (GType            parent_type,
2757                         const gchar     *type_name,
2758                         const GTypeInfo *info,
2759             GTypeFlags   flags)
2760 {
2761   TypeNode *pnode, *node;
2762   GType type = 0;
2763 
2764   g_assert_type_system_initialized ();
2765   g_return_val_if_fail (parent_type &gt; 0, 0);
2766   g_return_val_if_fail (type_name != NULL, 0);
2767   g_return_val_if_fail (info != NULL, 0);
2768 
2769   if (!check_type_name_I (type_name) ||
2770       !check_derivation_I (parent_type, type_name))
2771     return 0;
2772   if (info-&gt;class_finalize)
2773     {
2774       g_warning (&quot;class finalizer specified for static type &#39;%s&#39;&quot;,
2775          type_name);
2776       return 0;
2777     }
2778 
2779   pnode = lookup_type_node_I (parent_type);
2780   G_WRITE_LOCK (&amp;type_rw_lock);
2781   type_data_ref_Wm (pnode);
2782   if (check_type_info_I (pnode, NODE_FUNDAMENTAL_TYPE (pnode), type_name, info))
2783     {
2784       node = type_node_new_W (pnode, type_name, NULL);
2785       type_add_flags_W (node, flags);
2786       type = NODE_TYPE (node);
2787       type_data_make_W (node, info,
2788             check_value_table_I (type_name, info-&gt;value_table) ? info-&gt;value_table : NULL);
2789     }
2790   G_WRITE_UNLOCK (&amp;type_rw_lock);
2791 
2792   return type;
2793 }
2794 
2795 /**
2796  * g_type_register_dynamic:
2797  * @parent_type: type from which this type will be derived
2798  * @type_name: 0-terminated string used as the name of the new type
2799  * @plugin: #GTypePlugin structure to retrieve the #GTypeInfo from
2800  * @flags: bitwise combination of #GTypeFlags values
2801  *
2802  * Registers @type_name as the name of a new dynamic type derived from
2803  * @parent_type.  The type system uses the information contained in the
2804  * #GTypePlugin structure pointed to by @plugin to manage the type and its
2805  * instances (if not abstract).  The value of @flags determines the nature
2806  * (e.g. abstract or not) of the type.
2807  *
2808  * Returns: the new type identifier or #G_TYPE_INVALID if registration failed
2809  */
2810 GType
2811 g_type_register_dynamic (GType        parent_type,
2812              const gchar *type_name,
2813              GTypePlugin *plugin,
2814              GTypeFlags   flags)
2815 {
2816   TypeNode *pnode, *node;
2817   GType type;
2818 
2819   g_assert_type_system_initialized ();
2820   g_return_val_if_fail (parent_type &gt; 0, 0);
2821   g_return_val_if_fail (type_name != NULL, 0);
2822   g_return_val_if_fail (plugin != NULL, 0);
2823 
2824   if (!check_type_name_I (type_name) ||
2825       !check_derivation_I (parent_type, type_name) ||
2826       !check_plugin_U (plugin, TRUE, FALSE, type_name))
2827     return 0;
2828 
2829   G_WRITE_LOCK (&amp;type_rw_lock);
2830   pnode = lookup_type_node_I (parent_type);
2831   node = type_node_new_W (pnode, type_name, plugin);
2832   type_add_flags_W (node, flags);
2833   type = NODE_TYPE (node);
2834   G_WRITE_UNLOCK (&amp;type_rw_lock);
2835 
2836   return type;
2837 }
2838 
2839 /**
2840  * g_type_add_interface_static:
2841  * @instance_type: #GType value of an instantiable type
2842  * @interface_type: #GType value of an interface type
2843  * @info: #GInterfaceInfo structure for this
2844  *        (@instance_type, @interface_type) combination
2845  *
2846  * Adds the static @interface_type to @instantiable_type.
2847  * The information contained in the #GInterfaceInfo structure
2848  * pointed to by @info is used to manage the relationship.
2849  */
2850 void
2851 g_type_add_interface_static (GType                 instance_type,
2852                  GType                 interface_type,
2853                  const GInterfaceInfo *info)
2854 {
2855   /* G_TYPE_IS_INSTANTIATABLE() is an external call: _U */
2856   g_return_if_fail (G_TYPE_IS_INSTANTIATABLE (instance_type));
2857   g_return_if_fail (g_type_parent (interface_type) == G_TYPE_INTERFACE);
2858 
2859   /* we only need to lock class_init_rec_mutex if instance_type already has its
2860    * class initialized, however this function is rarely enough called to take
2861    * the simple route and always acquire class_init_rec_mutex.
2862    */
2863   g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
2864   G_WRITE_LOCK (&amp;type_rw_lock);
2865   if (check_add_interface_L (instance_type, interface_type))
2866     {
2867       TypeNode *node = lookup_type_node_I (instance_type);
2868       TypeNode *iface = lookup_type_node_I (interface_type);
2869       if (check_interface_info_I (iface, NODE_TYPE (node), info))
2870         type_add_interface_Wm (node, iface, info, NULL);
2871     }
2872   G_WRITE_UNLOCK (&amp;type_rw_lock);
2873   g_rec_mutex_unlock (&amp;class_init_rec_mutex);
2874 }
2875 
2876 /**
2877  * g_type_add_interface_dynamic:
2878  * @instance_type: #GType value of an instantiable type
2879  * @interface_type: #GType value of an interface type
2880  * @plugin: #GTypePlugin structure to retrieve the #GInterfaceInfo from
2881  *
2882  * Adds the dynamic @interface_type to @instantiable_type. The information
2883  * contained in the #GTypePlugin structure pointed to by @plugin
2884  * is used to manage the relationship.
2885  */
2886 void
2887 g_type_add_interface_dynamic (GType        instance_type,
2888                   GType        interface_type,
2889                   GTypePlugin *plugin)
2890 {
2891   TypeNode *node;
2892   /* G_TYPE_IS_INSTANTIATABLE() is an external call: _U */
2893   g_return_if_fail (G_TYPE_IS_INSTANTIATABLE (instance_type));
2894   g_return_if_fail (g_type_parent (interface_type) == G_TYPE_INTERFACE);
2895 
2896   node = lookup_type_node_I (instance_type);
2897   if (!check_plugin_U (plugin, FALSE, TRUE, NODE_NAME (node)))
2898     return;
2899 
2900   /* see comment in g_type_add_interface_static() about class_init_rec_mutex */
2901   g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
2902   G_WRITE_LOCK (&amp;type_rw_lock);
2903   if (check_add_interface_L (instance_type, interface_type))
2904     {
2905       TypeNode *iface = lookup_type_node_I (interface_type);
2906       type_add_interface_Wm (node, iface, NULL, plugin);
2907     }
2908   G_WRITE_UNLOCK (&amp;type_rw_lock);
2909   g_rec_mutex_unlock (&amp;class_init_rec_mutex);
2910 }
2911 
2912 
2913 /* --- public API functions --- */
2914 /**
2915  * g_type_class_ref:
2916  * @type: type ID of a classed type
2917  *
2918  * Increments the reference count of the class structure belonging to
2919  * @type. This function will demand-create the class if it doesn&#39;t
2920  * exist already.
2921  *
2922  * Returns: (type GObject.TypeClass) (transfer none): the #GTypeClass
2923  *     structure for the given type ID
2924  */
2925 gpointer
2926 g_type_class_ref (GType type)
2927 {
2928   TypeNode *node;
2929   GType ptype;
2930   gboolean holds_ref;
2931   GTypeClass *pclass;
2932 
2933   /* optimize for common code path */
2934   node = lookup_type_node_I (type);
2935   if (!node || !node-&gt;is_classed)
2936     {
2937       g_warning (&quot;cannot retrieve class for invalid (unclassed) type &#39;%s&#39;&quot;,
2938          type_descriptive_name_I (type));
2939       return NULL;
2940     }
2941 
2942   if (G_LIKELY (type_data_ref_U (node)))
2943     {
2944       if (G_LIKELY (g_atomic_int_get (&amp;node-&gt;data-&gt;class.init_state) == INITIALIZED))
2945         return node-&gt;data-&gt;class.class;
2946       holds_ref = TRUE;
2947     }
2948   else
2949     holds_ref = FALSE;
2950 
2951   /* here, we either have node-&gt;data-&gt;class.class == NULL, or a recursive
2952    * call to g_type_class_ref() with a partly initialized class, or
2953    * node-&gt;data-&gt;class.init_state == INITIALIZED, because any
2954    * concurrently running initialization was guarded by class_init_rec_mutex.
2955    */
2956   g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
2957 
2958   /* we need an initialized parent class for initializing derived classes */
2959   ptype = NODE_PARENT_TYPE (node);
2960   pclass = ptype ? g_type_class_ref (ptype) : NULL;
2961 
2962   G_WRITE_LOCK (&amp;type_rw_lock);
2963 
2964   if (!holds_ref)
2965     type_data_ref_Wm (node);
2966 
2967   if (!node-&gt;data-&gt;class.class) /* class uninitialized */
2968     type_class_init_Wm (node, pclass);
2969 
2970   G_WRITE_UNLOCK (&amp;type_rw_lock);
2971 
2972   if (pclass)
2973     g_type_class_unref (pclass);
2974 
2975   g_rec_mutex_unlock (&amp;class_init_rec_mutex);
2976 
2977   return node-&gt;data-&gt;class.class;
2978 }
2979 
2980 /**
2981  * g_type_class_unref:
2982  * @g_class: (type GObject.TypeClass): a #GTypeClass structure to unref
2983  *
2984  * Decrements the reference count of the class structure being passed in.
2985  * Once the last reference count of a class has been released, classes
2986  * may be finalized by the type system, so further dereferencing of a
2987  * class pointer after g_type_class_unref() are invalid.
2988  */
2989 void
2990 g_type_class_unref (gpointer g_class)
2991 {
2992   TypeNode *node;
2993   GTypeClass *class = g_class;
2994 
2995   g_return_if_fail (g_class != NULL);
2996 
2997   node = lookup_type_node_I (class-&gt;g_type);
2998   if (node &amp;&amp; node-&gt;is_classed &amp;&amp; NODE_REFCOUNT (node))
2999     type_data_unref_U (node, FALSE);
3000   else
3001     g_warning (&quot;cannot unreference class of invalid (unclassed) type &#39;%s&#39;&quot;,
3002            type_descriptive_name_I (class-&gt;g_type));
3003 }
3004 
3005 /**
3006  * g_type_class_unref_uncached: (skip)
3007  * @g_class: (type GObject.TypeClass): a #GTypeClass structure to unref
3008  *
3009  * A variant of g_type_class_unref() for use in #GTypeClassCacheFunc
3010  * implementations. It unreferences a class without consulting the chain
3011  * of #GTypeClassCacheFuncs, avoiding the recursion which would occur
3012  * otherwise.
3013  */
3014 void
3015 g_type_class_unref_uncached (gpointer g_class)
3016 {
3017   TypeNode *node;
3018   GTypeClass *class = g_class;
3019 
3020   g_return_if_fail (g_class != NULL);
3021 
3022   node = lookup_type_node_I (class-&gt;g_type);
3023   if (node &amp;&amp; node-&gt;is_classed &amp;&amp; NODE_REFCOUNT (node))
3024     type_data_unref_U (node, TRUE);
3025   else
3026     g_warning (&quot;cannot unreference class of invalid (unclassed) type &#39;%s&#39;&quot;,
3027            type_descriptive_name_I (class-&gt;g_type));
3028 }
3029 
3030 /**
3031  * g_type_class_peek:
3032  * @type: type ID of a classed type
3033  *
3034  * This function is essentially the same as g_type_class_ref(),
3035  * except that the classes reference count isn&#39;t incremented.
3036  * As a consequence, this function may return %NULL if the class
3037  * of the type passed in does not currently exist (hasn&#39;t been
3038  * referenced before).
3039  *
3040  * Returns: (type GObject.TypeClass) (transfer none): the #GTypeClass
3041  *     structure for the given type ID or %NULL if the class does not
3042  *     currently exist
3043  */
3044 gpointer
3045 g_type_class_peek (GType type)
3046 {
3047   TypeNode *node;
3048   gpointer class;
3049 
3050   node = lookup_type_node_I (type);
3051   if (node &amp;&amp; node-&gt;is_classed &amp;&amp; NODE_REFCOUNT (node) &amp;&amp;
3052       g_atomic_int_get (&amp;node-&gt;data-&gt;class.init_state) == INITIALIZED)
3053     /* ref_count _may_ be 0 */
3054     class = node-&gt;data-&gt;class.class;
3055   else
3056     class = NULL;
3057 
3058   return class;
3059 }
3060 
3061 /**
3062  * g_type_class_peek_static:
3063  * @type: type ID of a classed type
3064  *
3065  * A more efficient version of g_type_class_peek() which works only for
3066  * static types.
3067  *
3068  * Returns: (type GObject.TypeClass) (transfer none): the #GTypeClass
3069  *     structure for the given type ID or %NULL if the class does not
3070  *     currently exist or is dynamically loaded
3071  *
3072  * Since: 2.4
3073  */
3074 gpointer
3075 g_type_class_peek_static (GType type)
3076 {
3077   TypeNode *node;
3078   gpointer class;
3079 
3080   node = lookup_type_node_I (type);
3081   if (node &amp;&amp; node-&gt;is_classed &amp;&amp; NODE_REFCOUNT (node) &amp;&amp;
3082       /* peek only static types: */ node-&gt;plugin == NULL &amp;&amp;
3083       g_atomic_int_get (&amp;node-&gt;data-&gt;class.init_state) == INITIALIZED)
3084     /* ref_count _may_ be 0 */
3085     class = node-&gt;data-&gt;class.class;
3086   else
3087     class = NULL;
3088 
3089   return class;
3090 }
3091 
3092 /**
3093  * g_type_class_peek_parent:
3094  * @g_class: (type GObject.TypeClass): the #GTypeClass structure to
3095  *     retrieve the parent class for
3096  *
3097  * This is a convenience function often needed in class initializers.
3098  * It returns the class structure of the immediate parent type of the
3099  * class passed in.  Since derived classes hold a reference count on
3100  * their parent classes as long as they are instantiated, the returned
3101  * class will always exist.
3102  *
3103  * This function is essentially equivalent to:
3104  * g_type_class_peek (g_type_parent (G_TYPE_FROM_CLASS (g_class)))
3105  *
3106  * Returns: (type GObject.TypeClass) (transfer none): the parent class
3107  *     of @g_class
3108  */
3109 gpointer
3110 g_type_class_peek_parent (gpointer g_class)
3111 {
3112   TypeNode *node;
3113   gpointer class = NULL;
3114 
3115   g_return_val_if_fail (g_class != NULL, NULL);
3116 
3117   node = lookup_type_node_I (G_TYPE_FROM_CLASS (g_class));
3118   /* We used to acquire a read lock here. That is not necessary, since
3119    * parent-&gt;data-&gt;class.class is constant as long as the derived class
3120    * exists.
3121    */
3122   if (node &amp;&amp; node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp; NODE_PARENT_TYPE (node))
3123     {
3124       node = lookup_type_node_I (NODE_PARENT_TYPE (node));
3125       class = node-&gt;data-&gt;class.class;
3126     }
3127   else if (NODE_PARENT_TYPE (node))
3128     g_warning (G_STRLOC &quot;: invalid class pointer &#39;%p&#39;&quot;, g_class);
3129 
3130   return class;
3131 }
3132 
3133 /**
3134  * g_type_interface_peek:
3135  * @instance_class: (type GObject.TypeClass): a #GTypeClass structure
3136  * @iface_type: an interface ID which this class conforms to
3137  *
3138  * Returns the #GTypeInterface structure of an interface to which the
3139  * passed in class conforms.
3140  *
3141  * Returns: (type GObject.TypeInterface) (transfer none): the #GTypeInterface
3142  *     structure of @iface_type if implemented by @instance_class, %NULL
3143  *     otherwise
3144  */
3145 gpointer
3146 g_type_interface_peek (gpointer instance_class,
3147                GType    iface_type)
3148 {
3149   TypeNode *node;
3150   TypeNode *iface;
3151   gpointer vtable = NULL;
3152   GTypeClass *class = instance_class;
3153 
3154   g_return_val_if_fail (instance_class != NULL, NULL);
3155 
3156   node = lookup_type_node_I (class-&gt;g_type);
3157   iface = lookup_type_node_I (iface_type);
3158   if (node &amp;&amp; node-&gt;is_instantiatable &amp;&amp; iface)
3159     type_lookup_iface_vtable_I (node, iface, &amp;vtable);
3160   else
3161     g_warning (G_STRLOC &quot;: invalid class pointer &#39;%p&#39;&quot;, class);
3162 
3163   return vtable;
3164 }
3165 
3166 /**
3167  * g_type_interface_peek_parent:
3168  * @g_iface: (type GObject.TypeInterface): a #GTypeInterface structure
3169  *
3170  * Returns the corresponding #GTypeInterface structure of the parent type
3171  * of the instance type to which @g_iface belongs. This is useful when
3172  * deriving the implementation of an interface from the parent type and
3173  * then possibly overriding some methods.
3174  *
3175  * Returns: (transfer none) (type GObject.TypeInterface): the
3176  *     corresponding #GTypeInterface structure of the parent type of the
3177  *     instance type to which @g_iface belongs, or %NULL if the parent
3178  *     type doesn&#39;t conform to the interface
3179  */
3180 gpointer
3181 g_type_interface_peek_parent (gpointer g_iface)
3182 {
3183   TypeNode *node;
3184   TypeNode *iface;
3185   gpointer vtable = NULL;
3186   GTypeInterface *iface_class = g_iface;
3187 
3188   g_return_val_if_fail (g_iface != NULL, NULL);
3189 
3190   iface = lookup_type_node_I (iface_class-&gt;g_type);
3191   node = lookup_type_node_I (iface_class-&gt;g_instance_type);
3192   if (node)
3193     node = lookup_type_node_I (NODE_PARENT_TYPE (node));
3194   if (node &amp;&amp; node-&gt;is_instantiatable &amp;&amp; iface)
3195     type_lookup_iface_vtable_I (node, iface, &amp;vtable);
3196   else if (node)
3197     g_warning (G_STRLOC &quot;: invalid interface pointer &#39;%p&#39;&quot;, g_iface);
3198 
3199   return vtable;
3200 }
3201 
3202 /**
3203  * g_type_default_interface_ref:
3204  * @g_type: an interface type
3205  *
3206  * Increments the reference count for the interface type @g_type,
3207  * and returns the default interface vtable for the type.
3208  *
3209  * If the type is not currently in use, then the default vtable
3210  * for the type will be created and initalized by calling
3211  * the base interface init and default vtable init functions for
3212  * the type (the @base_init and @class_init members of #GTypeInfo).
3213  * Calling g_type_default_interface_ref() is useful when you
3214  * want to make sure that signals and properties for an interface
3215  * have been installed.
3216  *
3217  * Since: 2.4
3218  *
3219  * Returns: (type GObject.TypeInterface) (transfer none): the default
3220  *     vtable for the interface; call g_type_default_interface_unref()
3221  *     when you are done using the interface.
3222  */
3223 gpointer
3224 g_type_default_interface_ref (GType g_type)
3225 {
3226   TypeNode *node;
3227   gpointer dflt_vtable;
3228 
3229   G_WRITE_LOCK (&amp;type_rw_lock);
3230 
3231   node = lookup_type_node_I (g_type);
3232   if (!node || !NODE_IS_IFACE (node) ||
3233       (node-&gt;data &amp;&amp; NODE_REFCOUNT (node) == 0))
3234     {
3235       G_WRITE_UNLOCK (&amp;type_rw_lock);
3236       g_warning (&quot;cannot retrieve default vtable for invalid or non-interface type &#39;%s&#39;&quot;,
3237          type_descriptive_name_I (g_type));
3238       return NULL;
3239     }
3240 
3241   if (!node-&gt;data || !node-&gt;data-&gt;iface.dflt_vtable)
3242     {
3243       G_WRITE_UNLOCK (&amp;type_rw_lock);
3244       g_rec_mutex_lock (&amp;class_init_rec_mutex); /* required locking order: 1) class_init_rec_mutex, 2) type_rw_lock */
3245       G_WRITE_LOCK (&amp;type_rw_lock);
3246       node = lookup_type_node_I (g_type);
3247       type_data_ref_Wm (node);
3248       type_iface_ensure_dflt_vtable_Wm (node);
3249       g_rec_mutex_unlock (&amp;class_init_rec_mutex);
3250     }
3251   else
3252     type_data_ref_Wm (node); /* ref_count &gt;= 1 already */
3253 
3254   dflt_vtable = node-&gt;data-&gt;iface.dflt_vtable;
3255   G_WRITE_UNLOCK (&amp;type_rw_lock);
3256 
3257   return dflt_vtable;
3258 }
3259 
3260 /**
3261  * g_type_default_interface_peek:
3262  * @g_type: an interface type
3263  *
3264  * If the interface type @g_type is currently in use, returns its
3265  * default interface vtable.
3266  *
3267  * Since: 2.4
3268  *
3269  * Returns: (type GObject.TypeInterface) (transfer none): the default
3270  *     vtable for the interface, or %NULL if the type is not currently
3271  *     in use
3272  */
3273 gpointer
3274 g_type_default_interface_peek (GType g_type)
3275 {
3276   TypeNode *node;
3277   gpointer vtable;
3278 
3279   node = lookup_type_node_I (g_type);
3280   if (node &amp;&amp; NODE_IS_IFACE (node) &amp;&amp; NODE_REFCOUNT (node))
3281     vtable = node-&gt;data-&gt;iface.dflt_vtable;
3282   else
3283     vtable = NULL;
3284 
3285   return vtable;
3286 }
3287 
3288 /**
3289  * g_type_default_interface_unref:
3290  * @g_iface: (type GObject.TypeInterface): the default vtable
3291  *     structure for a interface, as returned by g_type_default_interface_ref()
3292  *
3293  * Decrements the reference count for the type corresponding to the
3294  * interface default vtable @g_iface. If the type is dynamic, then
3295  * when no one is using the interface and all references have
3296  * been released, the finalize function for the interface&#39;s default
3297  * vtable (the @class_finalize member of #GTypeInfo) will be called.
3298  *
3299  * Since: 2.4
3300  */
3301 void
3302 g_type_default_interface_unref (gpointer g_iface)
3303 {
3304   TypeNode *node;
3305   GTypeInterface *vtable = g_iface;
3306 
3307   g_return_if_fail (g_iface != NULL);
3308 
3309   node = lookup_type_node_I (vtable-&gt;g_type);
3310   if (node &amp;&amp; NODE_IS_IFACE (node))
3311     type_data_unref_U (node, FALSE);
3312   else
3313     g_warning (&quot;cannot unreference invalid interface default vtable for &#39;%s&#39;&quot;,
3314            type_descriptive_name_I (vtable-&gt;g_type));
3315 }
3316 
3317 /**
3318  * g_type_name:
3319  * @type: type to return name for
3320  *
3321  * Get the unique name that is assigned to a type ID.  Note that this
3322  * function (like all other GType API) cannot cope with invalid type
3323  * IDs. %G_TYPE_INVALID may be passed to this function, as may be any
3324  * other validly registered type ID, but randomized type IDs should
3325  * not be passed in and will most likely lead to a crash.
3326  *
3327  * Returns: static type name or %NULL
3328  */
3329 const gchar *
3330 g_type_name (GType type)
3331 {
3332   TypeNode *node;
3333 
3334   g_assert_type_system_initialized ();
3335 
3336   node = lookup_type_node_I (type);
3337 
3338   return node ? NODE_NAME (node) : NULL;
3339 }
3340 
3341 /**
3342  * g_type_qname:
3343  * @type: type to return quark of type name for
3344  *
3345  * Get the corresponding quark of the type IDs name.
3346  *
3347  * Returns: the type names quark or 0
3348  */
3349 GQuark
3350 g_type_qname (GType type)
3351 {
3352   TypeNode *node;
3353 
3354   node = lookup_type_node_I (type);
3355 
3356   return node ? node-&gt;qname : 0;
3357 }
3358 
3359 /**
3360  * g_type_from_name:
3361  * @name: type name to lookup
3362  *
3363  * Lookup the type ID from a given type name, returning 0 if no type
3364  * has been registered under this name (this is the preferred method
3365  * to find out by name whether a specific type has been registered
3366  * yet).
3367  *
3368  * Returns: corresponding type ID or 0
3369  */
3370 GType
3371 g_type_from_name (const gchar *name)
3372 {
3373   GType type = 0;
3374 
3375   g_return_val_if_fail (name != NULL, 0);
3376 
3377   G_READ_LOCK (&amp;type_rw_lock);
3378   type = (GType) g_hash_table_lookup (static_type_nodes_ht, name);
3379   G_READ_UNLOCK (&amp;type_rw_lock);
3380 
3381   return type;
3382 }
3383 
3384 /**
3385  * g_type_parent:
3386  * @type: the derived type
3387  *
3388  * Return the direct parent type of the passed in type. If the passed
3389  * in type has no parent, i.e. is a fundamental type, 0 is returned.
3390  *
3391  * Returns: the parent type
3392  */
3393 GType
3394 g_type_parent (GType type)
3395 {
3396   TypeNode *node;
3397 
3398   node = lookup_type_node_I (type);
3399 
3400   return node ? NODE_PARENT_TYPE (node) : 0;
3401 }
3402 
3403 /**
3404  * g_type_depth:
3405  * @type: a #GType
3406  *
3407  * Returns the length of the ancestry of the passed in type. This
3408  * includes the type itself, so that e.g. a fundamental type has depth 1.
3409  *
3410  * Returns: the depth of @type
3411  */
3412 guint
3413 g_type_depth (GType type)
3414 {
3415   TypeNode *node;
3416 
3417   node = lookup_type_node_I (type);
3418 
3419   return node ? node-&gt;n_supers + 1 : 0;
3420 }
3421 
3422 /**
3423  * g_type_next_base:
3424  * @leaf_type: descendant of @root_type and the type to be returned
3425  * @root_type: immediate parent of the returned type
3426  *
3427  * Given a @leaf_type and a @root_type which is contained in its
3428  * anchestry, return the type that @root_type is the immediate parent
3429  * of. In other words, this function determines the type that is
3430  * derived directly from @root_type which is also a base class of
3431  * @leaf_type.  Given a root type and a leaf type, this function can
3432  * be used to determine the types and order in which the leaf type is
3433  * descended from the root type.
3434  *
3435  * Returns: immediate child of @root_type and anchestor of @leaf_type
3436  */
3437 GType
3438 g_type_next_base (GType type,
3439           GType base_type)
3440 {
3441   GType atype = 0;
3442   TypeNode *node;
3443 
3444   node = lookup_type_node_I (type);
3445   if (node)
3446     {
3447       TypeNode *base_node = lookup_type_node_I (base_type);
3448 
3449       if (base_node &amp;&amp; base_node-&gt;n_supers &lt; node-&gt;n_supers)
3450     {
3451       guint n = node-&gt;n_supers - base_node-&gt;n_supers;
3452 
3453       if (node-&gt;supers[n] == base_type)
3454         atype = node-&gt;supers[n - 1];
3455     }
3456     }
3457 
3458   return atype;
3459 }
3460 
3461 static inline gboolean
3462 type_node_check_conformities_UorL (TypeNode *node,
3463                    TypeNode *iface_node,
3464                    /*        support_inheritance */
3465                    gboolean  support_interfaces,
3466                    gboolean  support_prerequisites,
3467                    gboolean  have_lock)
3468 {
3469   gboolean match;
3470 
3471   if (/* support_inheritance &amp;&amp; */
3472       NODE_IS_ANCESTOR (iface_node, node))
3473     return TRUE;
3474 
3475   support_interfaces = support_interfaces &amp;&amp; node-&gt;is_instantiatable &amp;&amp; NODE_IS_IFACE (iface_node);
3476   support_prerequisites = support_prerequisites &amp;&amp; NODE_IS_IFACE (node);
3477   match = FALSE;
3478   if (support_interfaces)
3479     {
3480       if (have_lock)
3481     {
3482       if (type_lookup_iface_entry_L (node, iface_node))
3483         match = TRUE;
3484     }
3485       else
3486     {
3487       if (type_lookup_iface_vtable_I (node, iface_node, NULL))
3488         match = TRUE;
3489     }
3490     }
3491   if (!match &amp;&amp;
3492       support_prerequisites)
3493     {
3494       if (!have_lock)
3495     G_READ_LOCK (&amp;type_rw_lock);
3496       if (support_prerequisites &amp;&amp; type_lookup_prerequisite_L (node, NODE_TYPE (iface_node)))
3497     match = TRUE;
3498       if (!have_lock)
3499     G_READ_UNLOCK (&amp;type_rw_lock);
3500     }
3501   return match;
3502 }
3503 
3504 static gboolean
3505 type_node_is_a_L (TypeNode *node,
3506           TypeNode *iface_node)
3507 {
3508   return type_node_check_conformities_UorL (node, iface_node, TRUE, TRUE, TRUE);
3509 }
3510 
3511 static inline gboolean
3512 type_node_conforms_to_U (TypeNode *node,
3513              TypeNode *iface_node,
3514              gboolean  support_interfaces,
3515              gboolean  support_prerequisites)
3516 {
3517   return type_node_check_conformities_UorL (node, iface_node, support_interfaces, support_prerequisites, FALSE);
3518 }
3519 
3520 /**
3521  * g_type_is_a:
3522  * @type: type to check anchestry for
3523  * @is_a_type: possible anchestor of @type or interface that @type
3524  *     could conform to
3525  *
3526  * If @is_a_type is a derivable type, check whether @type is a
3527  * descendant of @is_a_type. If @is_a_type is an interface, check
3528  * whether @type conforms to it.
3529  *
3530  * Returns: %TRUE if @type is a @is_a_type
3531  */
3532 gboolean
3533 g_type_is_a (GType type,
3534          GType iface_type)
3535 {
3536   TypeNode *node, *iface_node;
3537   gboolean is_a;
3538 
3539   if (type == iface_type)
3540     return TRUE;
3541 
3542   node = lookup_type_node_I (type);
3543   iface_node = lookup_type_node_I (iface_type);
3544   is_a = node &amp;&amp; iface_node &amp;&amp; type_node_conforms_to_U (node, iface_node, TRUE, TRUE);
3545 
3546   return is_a;
3547 }
3548 
3549 /**
3550  * g_type_children:
3551  * @type: the parent type
3552  * @n_children: (out) (optional): location to store the length of
3553  *     the returned array, or %NULL
3554  *
3555  * Return a newly allocated and 0-terminated array of type IDs, listing
3556  * the child types of @type.
3557  *
3558  * Returns: (array length=n_children) (transfer full): Newly allocated
3559  *     and 0-terminated array of child types, free with g_free()
3560  */
3561 GType*
3562 g_type_children (GType  type,
3563          guint *n_children)
3564 {
3565   TypeNode *node;
3566 
3567   node = lookup_type_node_I (type);
3568   if (node)
3569     {
3570       GType *children;
3571 
3572       G_READ_LOCK (&amp;type_rw_lock);  /* -&gt;children is relocatable */
3573       children = g_new (GType, node-&gt;n_children + 1);
3574       if (node-&gt;n_children != 0)
3575       memcpy (children, node-&gt;children, sizeof (GType) * node-&gt;n_children);
3576       children[node-&gt;n_children] = 0;
3577 
3578       if (n_children)
3579     *n_children = node-&gt;n_children;
3580       G_READ_UNLOCK (&amp;type_rw_lock);
3581 
3582       return children;
3583     }
3584   else
3585     {
3586       if (n_children)
3587     *n_children = 0;
3588 
3589       return NULL;
3590     }
3591 }
3592 
3593 /**
3594  * g_type_interfaces:
3595  * @type: the type to list interface types for
3596  * @n_interfaces: (out) (optional): location to store the length of
3597  *     the returned array, or %NULL
3598  *
3599  * Return a newly allocated and 0-terminated array of type IDs, listing
3600  * the interface types that @type conforms to.
3601  *
3602  * Returns: (array length=n_interfaces) (transfer full): Newly allocated
3603  *     and 0-terminated array of interface types, free with g_free()
3604  */
3605 GType*
3606 g_type_interfaces (GType  type,
3607            guint *n_interfaces)
3608 {
3609   TypeNode *node;
3610 
3611   node = lookup_type_node_I (type);
3612   if (node &amp;&amp; node-&gt;is_instantiatable)
3613     {
3614       IFaceEntries *entries;
3615       GType *ifaces;
3616       guint i;
3617 
3618       G_READ_LOCK (&amp;type_rw_lock);
3619       entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
3620       if (entries)
3621     {
3622       ifaces = g_new (GType, IFACE_ENTRIES_N_ENTRIES (entries) + 1);
3623       for (i = 0; i &lt; IFACE_ENTRIES_N_ENTRIES (entries); i++)
3624         ifaces[i] = entries-&gt;entry[i].iface_type;
3625     }
3626       else
3627     {
3628       ifaces = g_new (GType, 1);
3629       i = 0;
3630     }
3631       ifaces[i] = 0;
3632 
3633       if (n_interfaces)
3634     *n_interfaces = i;
3635       G_READ_UNLOCK (&amp;type_rw_lock);
3636 
3637       return ifaces;
3638     }
3639   else
3640     {
3641       if (n_interfaces)
3642     *n_interfaces = 0;
3643 
3644       return NULL;
3645     }
3646 }
3647 
3648 typedef struct _QData QData;
3649 struct _GData
3650 {
3651   guint  n_qdatas;
3652   QData *qdatas;
3653 };
3654 struct _QData
3655 {
3656   GQuark   quark;
3657   gpointer data;
3658 };
3659 
3660 static inline gpointer
3661 type_get_qdata_L (TypeNode *node,
3662           GQuark    quark)
3663 {
3664   GData *gdata = node-&gt;global_gdata;
3665 
3666   if (quark &amp;&amp; gdata &amp;&amp; gdata-&gt;n_qdatas)
3667     {
3668       QData *qdatas = gdata-&gt;qdatas - 1;
3669       guint n_qdatas = gdata-&gt;n_qdatas;
3670 
3671       do
3672     {
3673       guint i;
3674       QData *check;
3675 
3676       i = (n_qdatas + 1) / 2;
3677       check = qdatas + i;
3678       if (quark == check-&gt;quark)
3679         return check-&gt;data;
3680       else if (quark &gt; check-&gt;quark)
3681         {
3682           n_qdatas -= i;
3683           qdatas = check;
3684         }
3685       else /* if (quark &lt; check-&gt;quark) */
3686         n_qdatas = i - 1;
3687     }
3688       while (n_qdatas);
3689     }
3690   return NULL;
3691 }
3692 
3693 /**
3694  * g_type_get_qdata:
3695  * @type: a #GType
3696  * @quark: a #GQuark id to identify the data
3697  *
3698  * Obtains data which has previously been attached to @type
3699  * with g_type_set_qdata().
3700  *
3701  * Note that this does not take subtyping into account; data
3702  * attached to one type with g_type_set_qdata() cannot
3703  * be retrieved from a subtype using g_type_get_qdata().
3704  *
3705  * Returns: (transfer none): the data, or %NULL if no data was found
3706  */
3707 gpointer
3708 g_type_get_qdata (GType  type,
3709           GQuark quark)
3710 {
3711   TypeNode *node;
3712   gpointer data;
3713 
3714   node = lookup_type_node_I (type);
3715   if (node)
3716     {
3717       G_READ_LOCK (&amp;type_rw_lock);
3718       data = type_get_qdata_L (node, quark);
3719       G_READ_UNLOCK (&amp;type_rw_lock);
3720     }
3721   else
3722     {
3723       g_return_val_if_fail (node != NULL, NULL);
3724       data = NULL;
3725     }
3726   return data;
3727 }
3728 
3729 static inline void
3730 type_set_qdata_W (TypeNode *node,
3731           GQuark    quark,
3732           gpointer  data)
3733 {
3734   GData *gdata;
3735   QData *qdata;
3736   guint i;
3737 
3738   /* setup qdata list if necessary */
3739   if (!node-&gt;global_gdata)
3740     node-&gt;global_gdata = g_new0 (GData, 1);
3741   gdata = node-&gt;global_gdata;
3742 
3743   /* try resetting old data */
3744   qdata = gdata-&gt;qdatas;
3745   for (i = 0; i &lt; gdata-&gt;n_qdatas; i++)
3746     if (qdata[i].quark == quark)
3747       {
3748     qdata[i].data = data;
3749     return;
3750       }
3751 
3752   /* add new entry */
3753   gdata-&gt;n_qdatas++;
3754   gdata-&gt;qdatas = g_renew (QData, gdata-&gt;qdatas, gdata-&gt;n_qdatas);
3755   qdata = gdata-&gt;qdatas;
3756   for (i = 0; i &lt; gdata-&gt;n_qdatas - 1; i++)
3757     if (qdata[i].quark &gt; quark)
3758       break;
3759   memmove (qdata + i + 1, qdata + i, sizeof (qdata[0]) * (gdata-&gt;n_qdatas - i - 1));
3760   qdata[i].quark = quark;
3761   qdata[i].data = data;
3762 }
3763 
3764 /**
3765  * g_type_set_qdata:
3766  * @type: a #GType
3767  * @quark: a #GQuark id to identify the data
3768  * @data: the data
3769  *
3770  * Attaches arbitrary data to a type.
3771  */
3772 void
3773 g_type_set_qdata (GType    type,
3774           GQuark   quark,
3775           gpointer data)
3776 {
3777   TypeNode *node;
3778 
3779   g_return_if_fail (quark != 0);
3780 
3781   node = lookup_type_node_I (type);
3782   if (node)
3783     {
3784       G_WRITE_LOCK (&amp;type_rw_lock);
3785       type_set_qdata_W (node, quark, data);
3786       G_WRITE_UNLOCK (&amp;type_rw_lock);
3787     }
3788   else
3789     g_return_if_fail (node != NULL);
3790 }
3791 
3792 static void
3793 type_add_flags_W (TypeNode  *node,
3794           GTypeFlags flags)
3795 {
3796   guint dflags;
3797 
3798   g_return_if_fail ((flags &amp; ~TYPE_FLAG_MASK) == 0);
3799   g_return_if_fail (node != NULL);
3800 
3801   if ((flags &amp; TYPE_FLAG_MASK) &amp;&amp; node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class)
3802     g_warning (&quot;tagging type &#39;%s&#39; as abstract after class initialization&quot;, NODE_NAME (node));
3803   dflags = GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags));
3804   dflags |= flags;
3805   type_set_qdata_W (node, static_quark_type_flags, GUINT_TO_POINTER (dflags));
3806 }
3807 
3808 /**
3809  * g_type_query:
3810  * @type: #GType of a static, classed type
3811  * @query: (out caller-allocates): a user provided structure that is
3812  *     filled in with constant values upon success
3813  *
3814  * Queries the type system for information about a specific type.
3815  * This function will fill in a user-provided structure to hold
3816  * type-specific information. If an invalid #GType is passed in, the
3817  * @type member of the #GTypeQuery is 0. All members filled into the
3818  * #GTypeQuery structure should be considered constant and have to be
3819  * left untouched.
3820  */
3821 void
3822 g_type_query (GType       type,
3823           GTypeQuery *query)
3824 {
3825   TypeNode *node;
3826 
3827   g_return_if_fail (query != NULL);
3828 
3829   /* if node is not static and classed, we won&#39;t allow query */
3830   query-&gt;type = 0;
3831   node = lookup_type_node_I (type);
3832   if (node &amp;&amp; node-&gt;is_classed &amp;&amp; !node-&gt;plugin)
3833     {
3834       /* type is classed and probably even instantiatable */
3835       G_READ_LOCK (&amp;type_rw_lock);
3836       if (node-&gt;data)   /* type is static or referenced */
3837     {
3838       query-&gt;type = NODE_TYPE (node);
3839       query-&gt;type_name = NODE_NAME (node);
3840       query-&gt;class_size = node-&gt;data-&gt;class.class_size;
3841       query-&gt;instance_size = node-&gt;is_instantiatable ? node-&gt;data-&gt;instance.instance_size : 0;
3842     }
3843       G_READ_UNLOCK (&amp;type_rw_lock);
3844     }
3845 }
3846 
3847 /**
3848  * g_type_get_instance_count:
3849  * @type: a #GType
3850  *
3851  * Returns the number of instances allocated of the particular type;
3852  * this is only available if GLib is built with debugging support and
3853  * the instance_count debug flag is set (by setting the GOBJECT_DEBUG
3854  * variable to include instance-count).
3855  *
3856  * Returns: the number of instances allocated of the given type;
3857  *   if instance counts are not available, returns 0.
3858  *
3859  * Since: 2.44
3860  */
3861 int
3862 g_type_get_instance_count (GType type)
3863 {
3864 #ifdef G_ENABLE_DEBUG
3865   TypeNode *node;
3866 
3867   node = lookup_type_node_I (type);
3868   g_return_val_if_fail (node != NULL, 0);
3869 
3870   return g_atomic_int_get (&amp;node-&gt;instance_count);
3871 #else
3872   return 0;
3873 #endif
3874 }
3875 
3876 /* --- implementation details --- */
3877 gboolean
3878 g_type_test_flags (GType type,
3879            guint flags)
3880 {
3881   TypeNode *node;
3882   gboolean result = FALSE;
3883 
3884   node = lookup_type_node_I (type);
3885   if (node)
3886     {
3887       guint fflags = flags &amp; TYPE_FUNDAMENTAL_FLAG_MASK;
3888       guint tflags = flags &amp; TYPE_FLAG_MASK;
3889 
3890       if (fflags)
3891     {
3892       GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (node);
3893 
3894       fflags = (finfo-&gt;type_flags &amp; fflags) == fflags;
3895     }
3896       else
3897     fflags = TRUE;
3898 
3899       if (tflags)
3900     {
3901       G_READ_LOCK (&amp;type_rw_lock);
3902       tflags = (tflags &amp; GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))) == tflags;
3903       G_READ_UNLOCK (&amp;type_rw_lock);
3904     }
3905       else
3906     tflags = TRUE;
3907 
3908       result = tflags &amp;&amp; fflags;
3909     }
3910 
3911   return result;
3912 }
3913 
3914 /**
3915  * g_type_get_plugin:
3916  * @type: #GType to retrieve the plugin for
3917  *
3918  * Returns the #GTypePlugin structure for @type.
3919  *
3920  * Returns: (transfer none): the corresponding plugin
3921  *     if @type is a dynamic type, %NULL otherwise
3922  */
3923 GTypePlugin*
3924 g_type_get_plugin (GType type)
3925 {
3926   TypeNode *node;
3927 
3928   node = lookup_type_node_I (type);
3929 
3930   return node ? node-&gt;plugin : NULL;
3931 }
3932 
3933 /**
3934  * g_type_interface_get_plugin:
3935  * @instance_type: #GType of an instantiatable type
3936  * @interface_type: #GType of an interface type
3937  *
3938  * Returns the #GTypePlugin structure for the dynamic interface
3939  * @interface_type which has been added to @instance_type, or %NULL
3940  * if @interface_type has not been added to @instance_type or does
3941  * not have a #GTypePlugin structure. See g_type_add_interface_dynamic().
3942  *
3943  * Returns: (transfer none): the #GTypePlugin for the dynamic
3944  *     interface @interface_type of @instance_type
3945  */
3946 GTypePlugin*
3947 g_type_interface_get_plugin (GType instance_type,
3948                  GType interface_type)
3949 {
3950   TypeNode *node;
3951   TypeNode *iface;
3952 
3953   g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);    /* G_TYPE_IS_INTERFACE() is an external call: _U */
3954 
3955   node = lookup_type_node_I (instance_type);
3956   iface = lookup_type_node_I (interface_type);
3957   if (node &amp;&amp; iface)
3958     {
3959       IFaceHolder *iholder;
3960       GTypePlugin *plugin;
3961 
3962       G_READ_LOCK (&amp;type_rw_lock);
3963 
3964       iholder = iface_node_get_holders_L (iface);
3965       while (iholder &amp;&amp; iholder-&gt;instance_type != instance_type)
3966     iholder = iholder-&gt;next;
3967       plugin = iholder ? iholder-&gt;plugin : NULL;
3968 
3969       G_READ_UNLOCK (&amp;type_rw_lock);
3970 
3971       return plugin;
3972     }
3973 
3974   g_return_val_if_fail (node == NULL, NULL);
3975   g_return_val_if_fail (iface == NULL, NULL);
3976 
3977   g_warning (G_STRLOC &quot;: attempt to look up plugin for invalid instance/interface type pair.&quot;);
3978 
3979   return NULL;
3980 }
3981 
3982 /**
3983  * g_type_fundamental_next:
3984  *
3985  * Returns the next free fundamental type id which can be used to
3986  * register a new fundamental type with g_type_register_fundamental().
3987  * The returned type ID represents the highest currently registered
3988  * fundamental type identifier.
3989  *
3990  * Returns: the next available fundamental type ID to be registered,
3991  *     or 0 if the type system ran out of fundamental type IDs
3992  */
3993 GType
3994 g_type_fundamental_next (void)
3995 {
3996   GType type;
3997 
3998   G_READ_LOCK (&amp;type_rw_lock);
3999   type = static_fundamental_next;
4000   G_READ_UNLOCK (&amp;type_rw_lock);
4001   type = G_TYPE_MAKE_FUNDAMENTAL (type);
4002   return type &lt;= G_TYPE_FUNDAMENTAL_MAX ? type : 0;
4003 }
4004 
4005 /**
4006  * g_type_fundamental:
4007  * @type_id: valid type ID
4008  *
4009  * Internal function, used to extract the fundamental type ID portion.
4010  * Use G_TYPE_FUNDAMENTAL() instead.
4011  *
4012  * Returns: fundamental type ID
4013  */
4014 GType
4015 g_type_fundamental (GType type_id)
4016 {
4017   TypeNode *node = lookup_type_node_I (type_id);
4018 
4019   return node ? NODE_FUNDAMENTAL_TYPE (node) : 0;
4020 }
4021 
4022 gboolean
4023 g_type_check_instance_is_a (GTypeInstance *type_instance,
4024                 GType          iface_type)
4025 {
4026   TypeNode *node, *iface;
4027   gboolean check;
4028 
4029   if (!type_instance || !type_instance-&gt;g_class)
4030     return FALSE;
4031 
4032   node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);
4033   iface = lookup_type_node_I (iface_type);
4034   check = node &amp;&amp; node-&gt;is_instantiatable &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, TRUE, FALSE);
4035 
4036   return check;
4037 }
4038 
4039 gboolean
4040 g_type_check_instance_is_fundamentally_a (GTypeInstance *type_instance,
4041                                           GType          fundamental_type)
4042 {
4043   TypeNode *node;
4044   if (!type_instance || !type_instance-&gt;g_class)
4045     return FALSE;
4046   node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);
4047   return node &amp;&amp; (NODE_FUNDAMENTAL_TYPE(node) == fundamental_type);
4048 }
4049 
4050 gboolean
4051 g_type_check_class_is_a (GTypeClass *type_class,
4052              GType       is_a_type)
4053 {
4054   TypeNode *node, *iface;
4055   gboolean check;
4056 
4057   if (!type_class)
4058     return FALSE;
4059 
4060   node = lookup_type_node_I (type_class-&gt;g_type);
4061   iface = lookup_type_node_I (is_a_type);
4062   check = node &amp;&amp; node-&gt;is_classed &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, FALSE, FALSE);
4063 
4064   return check;
4065 }
4066 
4067 GTypeInstance*
4068 g_type_check_instance_cast (GTypeInstance *type_instance,
4069                 GType          iface_type)
4070 {
4071   if (type_instance)
4072     {
4073       if (type_instance-&gt;g_class)
4074     {
4075       TypeNode *node, *iface;
4076       gboolean is_instantiatable, check;
4077 
4078       node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);
4079       is_instantiatable = node &amp;&amp; node-&gt;is_instantiatable;
4080       iface = lookup_type_node_I (iface_type);
4081       check = is_instantiatable &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, TRUE, FALSE);
4082       if (check)
4083         return type_instance;
4084 
4085       if (is_instantiatable)
4086         g_warning (&quot;invalid cast from &#39;%s&#39; to &#39;%s&#39;&quot;,
4087                type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type),
4088                type_descriptive_name_I (iface_type));
4089       else
4090         g_warning (&quot;invalid uninstantiatable type &#39;%s&#39; in cast to &#39;%s&#39;&quot;,
4091                type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type),
4092                type_descriptive_name_I (iface_type));
4093     }
4094       else
4095     g_warning (&quot;invalid unclassed pointer in cast to &#39;%s&#39;&quot;,
4096            type_descriptive_name_I (iface_type));
4097     }
4098 
4099   return type_instance;
4100 }
4101 
4102 GTypeClass*
4103 g_type_check_class_cast (GTypeClass *type_class,
4104              GType       is_a_type)
4105 {
4106   if (type_class)
4107     {
4108       TypeNode *node, *iface;
4109       gboolean is_classed, check;
4110 
4111       node = lookup_type_node_I (type_class-&gt;g_type);
4112       is_classed = node &amp;&amp; node-&gt;is_classed;
4113       iface = lookup_type_node_I (is_a_type);
4114       check = is_classed &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, FALSE, FALSE);
4115       if (check)
4116     return type_class;
4117 
4118       if (is_classed)
4119     g_warning (&quot;invalid class cast from &#39;%s&#39; to &#39;%s&#39;&quot;,
4120            type_descriptive_name_I (type_class-&gt;g_type),
4121            type_descriptive_name_I (is_a_type));
4122       else
4123     g_warning (&quot;invalid unclassed type &#39;%s&#39; in class cast to &#39;%s&#39;&quot;,
4124            type_descriptive_name_I (type_class-&gt;g_type),
4125            type_descriptive_name_I (is_a_type));
4126     }
4127   else
4128     g_warning (&quot;invalid class cast from (NULL) pointer to &#39;%s&#39;&quot;,
4129            type_descriptive_name_I (is_a_type));
4130   return type_class;
4131 }
4132 
4133 /**
4134  * g_type_check_instance:
4135  * @instance: a valid #GTypeInstance structure
4136  *
4137  * Private helper function to aid implementation of the
4138  * G_TYPE_CHECK_INSTANCE() macro.
4139  *
4140  * Returns: %TRUE if @instance is valid, %FALSE otherwise
4141  */
4142 gboolean
4143 g_type_check_instance (GTypeInstance *type_instance)
4144 {
4145   /* this function is just here to make the signal system
4146    * conveniently elaborated on instance checks
4147    */
4148   if (type_instance)
4149     {
4150       if (type_instance-&gt;g_class)
4151     {
4152       TypeNode *node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);
4153 
4154       if (node &amp;&amp; node-&gt;is_instantiatable)
4155         return TRUE;
4156 
4157       g_warning (&quot;instance of invalid non-instantiatable type &#39;%s&#39;&quot;,
4158              type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type));
4159     }
4160       else
4161     g_warning (&quot;instance with invalid (NULL) class pointer&quot;);
4162     }
4163   else
4164     g_warning (&quot;invalid (NULL) pointer instance&quot;);
4165 
4166   return FALSE;
4167 }
4168 
4169 static inline gboolean
4170 type_check_is_value_type_U (GType type)
4171 {
4172   GTypeFlags tflags = G_TYPE_FLAG_VALUE_ABSTRACT;
4173   TypeNode *node;
4174 
4175   /* common path speed up */
4176   node = lookup_type_node_I (type);
4177   if (node &amp;&amp; node-&gt;mutatable_check_cache)
4178     return TRUE;
4179 
4180   G_READ_LOCK (&amp;type_rw_lock);
4181  restart_check:
4182   if (node)
4183     {
4184       if (node-&gt;data &amp;&amp; NODE_REFCOUNT (node) &gt; 0 &amp;&amp;
4185       node-&gt;data-&gt;common.value_table-&gt;value_init)
4186     tflags = GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags));
4187       else if (NODE_IS_IFACE (node))
4188     {
4189       guint i;
4190 
4191       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (node); i++)
4192         {
4193           GType prtype = IFACE_NODE_PREREQUISITES (node)[i];
4194           TypeNode *prnode = lookup_type_node_I (prtype);
4195 
4196           if (prnode-&gt;is_instantiatable)
4197         {
4198           type = prtype;
4199           node = lookup_type_node_I (type);
4200           goto restart_check;
4201         }
4202         }
4203     }
4204     }
4205   G_READ_UNLOCK (&amp;type_rw_lock);
4206 
4207   return !(tflags &amp; G_TYPE_FLAG_VALUE_ABSTRACT);
4208 }
4209 
4210 gboolean
4211 g_type_check_is_value_type (GType type)
4212 {
4213   return type_check_is_value_type_U (type);
4214 }
4215 
4216 gboolean
4217 g_type_check_value (const GValue *value)
4218 {
4219   return value &amp;&amp; type_check_is_value_type_U (value-&gt;g_type);
4220 }
4221 
4222 gboolean
4223 g_type_check_value_holds (const GValue *value,
4224               GType         type)
4225 {
4226   return value &amp;&amp; type_check_is_value_type_U (value-&gt;g_type) &amp;&amp; g_type_is_a (value-&gt;g_type, type);
4227 }
4228 
4229 /**
4230  * g_type_value_table_peek: (skip)
4231  * @type: a #GType
4232  *
4233  * Returns the location of the #GTypeValueTable associated with @type.
4234  *
4235  * Note that this function should only be used from source code
4236  * that implements or has internal knowledge of the implementation of
4237  * @type.
4238  *
4239  * Returns: location of the #GTypeValueTable associated with @type or
4240  *     %NULL if there is no #GTypeValueTable associated with @type
4241  */
4242 GTypeValueTable*
4243 g_type_value_table_peek (GType type)
4244 {
4245   GTypeValueTable *vtable = NULL;
4246   TypeNode *node = lookup_type_node_I (type);
4247   gboolean has_refed_data, has_table;
4248 
4249   if (node &amp;&amp; NODE_REFCOUNT (node) &amp;&amp; node-&gt;mutatable_check_cache)
4250     return node-&gt;data-&gt;common.value_table;
4251 
4252   G_READ_LOCK (&amp;type_rw_lock);
4253 
4254  restart_table_peek:
4255   has_refed_data = node &amp;&amp; node-&gt;data &amp;&amp; NODE_REFCOUNT (node) &gt; 0;
4256   has_table = has_refed_data &amp;&amp; node-&gt;data-&gt;common.value_table-&gt;value_init;
4257   if (has_refed_data)
4258     {
4259       if (has_table)
4260     vtable = node-&gt;data-&gt;common.value_table;
4261       else if (NODE_IS_IFACE (node))
4262     {
4263       guint i;
4264 
4265       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (node); i++)
4266         {
4267           GType prtype = IFACE_NODE_PREREQUISITES (node)[i];
4268           TypeNode *prnode = lookup_type_node_I (prtype);
4269 
4270           if (prnode-&gt;is_instantiatable)
4271         {
4272           type = prtype;
4273           node = lookup_type_node_I (type);
4274           goto restart_table_peek;
4275         }
4276         }
4277     }
4278     }
4279 
4280   G_READ_UNLOCK (&amp;type_rw_lock);
4281 
4282   if (vtable)
4283     return vtable;
4284 
4285   if (!node)
4286     g_warning (G_STRLOC &quot;: type id &#39;%&quot; G_GSIZE_FORMAT &quot;&#39; is invalid&quot;, type);
4287   if (!has_refed_data)
4288     g_warning (&quot;can&#39;t peek value table for type &#39;%s&#39; which is not currently referenced&quot;,
4289            type_descriptive_name_I (type));
4290 
4291   return NULL;
4292 }
4293 
4294 const gchar *
4295 g_type_name_from_instance (GTypeInstance *instance)
4296 {
4297   if (!instance)
4298     return &quot;&lt;NULL-instance&gt;&quot;;
4299   else
4300     return g_type_name_from_class (instance-&gt;g_class);
4301 }
4302 
4303 const gchar *
4304 g_type_name_from_class (GTypeClass *g_class)
4305 {
4306   if (!g_class)
4307     return &quot;&lt;NULL-class&gt;&quot;;
4308   else
4309     return g_type_name (g_class-&gt;g_type);
4310 }
4311 
4312 
4313 /* --- private api for gboxed.c --- */
4314 gpointer
4315 _g_type_boxed_copy (GType type, gpointer value)
4316 {
4317   TypeNode *node = lookup_type_node_I (type);
4318 
4319   return node-&gt;data-&gt;boxed.copy_func (value);
4320 }
4321 
4322 void
4323 _g_type_boxed_free (GType type, gpointer value)
4324 {
4325   TypeNode *node = lookup_type_node_I (type);
4326 
4327   node-&gt;data-&gt;boxed.free_func (value);
4328 }
4329 
4330 void
4331 _g_type_boxed_init (GType          type,
4332                     GBoxedCopyFunc copy_func,
4333                     GBoxedFreeFunc free_func)
4334 {
4335   TypeNode *node = lookup_type_node_I (type);
4336 
4337   node-&gt;data-&gt;boxed.copy_func = copy_func;
4338   node-&gt;data-&gt;boxed.free_func = free_func;
4339 }
4340 
4341 /* --- initialization --- */
4342 /**
4343  * g_type_init_with_debug_flags:
4344  * @debug_flags: bitwise combination of #GTypeDebugFlags values for
4345  *     debugging purposes
4346  *
4347  * This function used to initialise the type system with debugging
4348  * flags.  Since GLib 2.36, the type system is initialised automatically
4349  * and this function does nothing.
4350  *
4351  * If you need to enable debugging features, use the GOBJECT_DEBUG
4352  * environment variable.
4353  *
4354  * Deprecated: 2.36: the type system is now initialised automatically
4355  */
4356 void
4357 g_type_init_with_debug_flags (GTypeDebugFlags debug_flags)
4358 {
4359   g_assert_type_system_initialized ();
4360 
4361   if (debug_flags)
4362     g_message (&quot;g_type_init_with_debug_flags() is no longer supported.  Use the GOBJECT_DEBUG environment variable.&quot;);
4363 }
4364 
4365 /**
4366  * g_type_init:
4367  *
4368  * This function used to initialise the type system.  Since GLib 2.36,
4369  * the type system is initialised automatically and this function does
4370  * nothing.
4371  *
4372  * Deprecated: 2.36: the type system is now initialised automatically
4373  */
4374 #if !(defined(GSTREAMER_LITE) &amp;&amp; defined(G_OS_WIN32))
4375 void
4376 g_type_init (void)
4377 {
4378   g_assert_type_system_initialized ();
4379 }
4380 #endif // GSTREAMER_LITE
4381 
4382 #if defined(GSTREAMER_LITE) &amp;&amp; defined(G_OS_WIN32)
4383 // We cannot due static initialization, since it will crash due to
4384 // threading system is not initialized yet.
4385 static void gobject_init (void);
4386 void
4387 g_type_init (void)
4388 {
4389   gobject_init ();
4390 }
4391 #endif // GSTREAMER_LITE
4392 
4393 static void
4394 gobject_init (void)
4395 {
4396   const gchar *env_string;
4397   GTypeInfo info;
4398   TypeNode *node;
4399   GType type;
4400 
4401   /* Ensure GLib is initialized first, see
4402    * https://bugzilla.gnome.org/show_bug.cgi?id=756139
4403    */
4404   GLIB_PRIVATE_CALL (glib_init) ();
4405 
4406   G_WRITE_LOCK (&amp;type_rw_lock);
4407 
4408   /* setup GObject library wide debugging flags */
4409   env_string = g_getenv (&quot;GOBJECT_DEBUG&quot;);
4410   if (env_string != NULL)
4411     {
4412       GDebugKey debug_keys[] = {
4413         { &quot;objects&quot;, G_TYPE_DEBUG_OBJECTS },
4414         { &quot;instance-count&quot;, G_TYPE_DEBUG_INSTANCE_COUNT },
4415         { &quot;signals&quot;, G_TYPE_DEBUG_SIGNALS },
4416       };
4417 
4418       _g_type_debug_flags = g_parse_debug_string (env_string, debug_keys, G_N_ELEMENTS (debug_keys));
4419     }
4420 
4421   /* quarks */
4422   static_quark_type_flags = g_quark_from_static_string (&quot;-g-type-private--GTypeFlags&quot;);
4423   static_quark_iface_holder = g_quark_from_static_string (&quot;-g-type-private--IFaceHolder&quot;);
4424   static_quark_dependants_array = g_quark_from_static_string (&quot;-g-type-private--dependants-array&quot;);
4425 
4426   /* type qname hash table */
4427   static_type_nodes_ht = g_hash_table_new (g_str_hash, g_str_equal);
4428 
4429   /* invalid type G_TYPE_INVALID (0)
4430    */
4431   static_fundamental_type_nodes[0] = NULL;
4432 
4433   /* void type G_TYPE_NONE
4434    */
4435   node = type_node_fundamental_new_W (G_TYPE_NONE, g_intern_static_string (&quot;void&quot;), 0);
4436   type = NODE_TYPE (node);
4437   g_assert (type == G_TYPE_NONE);
4438 
4439   /* interface fundamental type G_TYPE_INTERFACE (!classed)
4440    */
4441   memset (&amp;info, 0, sizeof (info));
4442   node = type_node_fundamental_new_W (G_TYPE_INTERFACE, g_intern_static_string (&quot;GInterface&quot;), G_TYPE_FLAG_DERIVABLE);
4443   type = NODE_TYPE (node);
4444   type_data_make_W (node, &amp;info, NULL);
4445   g_assert (type == G_TYPE_INTERFACE);
4446 
4447   G_WRITE_UNLOCK (&amp;type_rw_lock);
4448 
4449   _g_value_c_init ();
4450 
4451   /* G_TYPE_TYPE_PLUGIN
4452    */
4453   g_type_ensure (g_type_plugin_get_type ());
4454 
4455   /* G_TYPE_* value types
4456    */
4457   _g_value_types_init ();
4458 
4459   /* G_TYPE_ENUM &amp; G_TYPE_FLAGS
4460    */
4461   _g_enum_types_init ();
4462 
4463   /* G_TYPE_BOXED
4464    */
4465   _g_boxed_type_init ();
4466 
4467   /* G_TYPE_PARAM
4468    */
4469   _g_param_type_init ();
4470 
4471   /* G_TYPE_OBJECT
4472    */
4473   _g_object_type_init ();
4474 
4475   /* G_TYPE_PARAM_* pspec types
4476    */
4477   _g_param_spec_types_init ();
4478 
4479   /* Value Transformations
4480    */
4481   _g_value_transforms_init ();
4482 
4483   /* Signal system
4484    */
4485   _g_signal_init ();
4486 }
4487 
4488 #if defined (G_OS_WIN32)
4489 
4490 #ifndef GSTREAMER_LITE
4491 BOOL WINAPI DllMain (HINSTANCE hinstDLL,
4492                      DWORD     fdwReason,
4493                      LPVOID    lpvReserved);
4494 
4495 BOOL WINAPI
4496 DllMain (HINSTANCE hinstDLL,
4497          DWORD     fdwReason,
4498          LPVOID    lpvReserved)
4499 {
4500   switch (fdwReason)
4501     {
4502     case DLL_PROCESS_ATTACH:
4503       gobject_init ();
4504       break;
4505 
4506     default:
4507       /* do nothing */
4508       ;
4509     }
4510 
4511   return TRUE;
4512 }
4513 #endif // GSTREAMER_LITE
4514 
4515 #elif defined (G_HAS_CONSTRUCTORS)
4516 #ifdef G_DEFINE_CONSTRUCTOR_NEEDS_PRAGMA
4517 #pragma G_DEFINE_CONSTRUCTOR_PRAGMA_ARGS(gobject_init_ctor)
4518 #endif
4519 G_DEFINE_CONSTRUCTOR(gobject_init_ctor)
4520 
4521 static void
4522 gobject_init_ctor (void)
4523 {
4524   gobject_init ();
4525 }
4526 
4527 #else
4528 # error Your platform/compiler is missing constructor support
4529 #endif
4530 
4531 /**
4532  * g_type_class_add_private:
4533  * @g_class: (type GObject.TypeClass): class structure for an instantiatable
4534  *    type
4535  * @private_size: size of private structure
4536  *
4537  * Registers a private structure for an instantiatable type.
4538  *
4539  * When an object is allocated, the private structures for
4540  * the type and all of its parent types are allocated
4541  * sequentially in the same memory block as the public
4542  * structures, and are zero-filled.
4543  *
4544  * Note that the accumulated size of the private structures of
4545  * a type and all its parent types cannot exceed 64 KiB.
4546  *
4547  * This function should be called in the type&#39;s class_init() function.
4548  * The private structure can be retrieved using the
4549  * G_TYPE_INSTANCE_GET_PRIVATE() macro.
4550  *
4551  * The following example shows attaching a private structure
4552  * MyObjectPrivate to an object MyObject defined in the standard
4553  * GObject fashion in the type&#39;s class_init() function.
4554  *
4555  * Note the use of a structure member &quot;priv&quot; to avoid the overhead
4556  * of repeatedly calling MY_OBJECT_GET_PRIVATE().
4557  *
4558  * |[&lt;!-- language=&quot;C&quot; --&gt;
4559  * typedef struct _MyObject        MyObject;
4560  * typedef struct _MyObjectPrivate MyObjectPrivate;
4561  *
4562  * struct _MyObject {
4563  *  GObject parent;
4564  *
4565  *  MyObjectPrivate *priv;
4566  * };
4567  *
4568  * struct _MyObjectPrivate {
4569  *   int some_field;
4570  * };
4571  *
4572  * static void
4573  * my_object_class_init (MyObjectClass *klass)
4574  * {
4575  *   g_type_class_add_private (klass, sizeof (MyObjectPrivate));
4576  * }
4577  *
4578  * static void
4579  * my_object_init (MyObject *my_object)
4580  * {
4581  *   my_object-&gt;priv = G_TYPE_INSTANCE_GET_PRIVATE (my_object,
4582  *                                                  MY_TYPE_OBJECT,
4583  *                                                  MyObjectPrivate);
4584  *   // my_object-&gt;priv-&gt;some_field will be automatically initialised to 0
4585  * }
4586  *
4587  * static int
4588  * my_object_get_some_field (MyObject *my_object)
4589  * {
4590  *   MyObjectPrivate *priv;
4591  *
4592  *   g_return_val_if_fail (MY_IS_OBJECT (my_object), 0);
4593  *
4594  *   priv = my_object-&gt;priv;
4595  *
4596  *   return priv-&gt;some_field;
4597  * }
4598  * ]|
4599  *
4600  * Since: 2.4
4601  * Deprecated: 2.58: Use the G_ADD_PRIVATE() macro with the `G_DEFINE_*`
4602  *   family of macros to add instance private data to a type
4603  */
4604 void
4605 g_type_class_add_private (gpointer g_class,
4606               gsize    private_size)
4607 {
4608   GType instance_type = ((GTypeClass *)g_class)-&gt;g_type;
4609   TypeNode *node = lookup_type_node_I (instance_type);
4610 
4611   g_return_if_fail (private_size &gt; 0);
4612   g_return_if_fail (private_size &lt;= 0xffff);
4613 
4614   if (!node || !node-&gt;is_instantiatable || !node-&gt;data || node-&gt;data-&gt;class.class != g_class)
4615     {
4616       g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
4617          type_descriptive_name_I (instance_type));
4618       return;
4619     }
4620 
4621   if (NODE_PARENT_TYPE (node))
4622     {
4623       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
4624       if (node-&gt;data-&gt;instance.private_size != pnode-&gt;data-&gt;instance.private_size)
4625     {
4626       g_warning (&quot;g_type_class_add_private() called multiple times for the same type&quot;);
4627       return;
4628     }
4629     }
4630 
4631   G_WRITE_LOCK (&amp;type_rw_lock);
4632 
4633   private_size = ALIGN_STRUCT (node-&gt;data-&gt;instance.private_size + private_size);
4634   g_assert (private_size &lt;= 0xffff);
4635   node-&gt;data-&gt;instance.private_size = private_size;
4636 
4637   G_WRITE_UNLOCK (&amp;type_rw_lock);
4638 }
4639 
4640 /* semi-private, called only by the G_ADD_PRIVATE macro */
4641 gint
4642 g_type_add_instance_private (GType class_gtype,
4643                              gsize private_size)
4644 {
4645   TypeNode *node = lookup_type_node_I (class_gtype);
4646 
4647   g_return_val_if_fail (private_size &gt; 0, 0);
4648   g_return_val_if_fail (private_size &lt;= 0xffff, 0);
4649 
4650   if (!node || !node-&gt;is_classed || !node-&gt;is_instantiatable || !node-&gt;data)
4651     {
4652       g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
4653          type_descriptive_name_I (class_gtype));
4654       return 0;
4655     }
4656 
4657   if (node-&gt;plugin != NULL)
4658     {
4659       g_warning (&quot;cannot use g_type_add_instance_private() with dynamic type &#39;%s&#39;&quot;,
4660                  type_descriptive_name_I (class_gtype));
4661       return 0;
4662     }
4663 
4664   /* in the future, we want to register the private data size of a type
4665    * directly from the get_type() implementation so that we can take full
4666    * advantage of the type definition macros that we already have.
4667    *
4668    * unfortunately, this does not behave correctly if a class in the middle
4669    * of the type hierarchy uses the &quot;old style&quot; of private data registration
4670    * from the class_init() implementation, as the private data offset is not
4671    * going to be known until the full class hierarchy is initialized.
4672    *
4673    * in order to transition our code to the Glorious New Future(TM), we proceed
4674    * with a two-step implementation: first, we provide this new function to
4675    * register the private data size in the get_type() implementation and we
4676    * hide it behind a macro. the function will return the private size, instead
4677    * of the offset, which will be stored inside a static variable defined by
4678    * the G_DEFINE_TYPE_EXTENDED macro. the G_DEFINE_TYPE_EXTENDED macro will
4679    * check the variable and call g_type_class_add_instance_private(), which
4680    * will use the data size and actually register the private data, then
4681    * return the computed offset of the private data, which will be stored
4682    * inside the static variable, so we can use it to retrieve the pointer
4683    * to the private data structure.
4684    *
4685    * once all our code has been migrated to the new idiomatic form of private
4686    * data registration, we will change the g_type_add_instance_private()
4687    * function to actually perform the registration and return the offset
4688    * of the private data; g_type_class_add_instance_private() already checks
4689    * if the passed argument is negative (meaning that it&#39;s an offset in the
4690    * GTypeInstance allocation) and becomes a no-op if that&#39;s the case. this
4691    * should make the migration fully transparent even if we&#39;re effectively
4692    * copying this macro into everybody&#39;s code.
4693    */
4694   return private_size;
4695 }
4696 
4697 /* semi-private function, should only be used by G_DEFINE_TYPE_EXTENDED */
4698 void
4699 g_type_class_adjust_private_offset (gpointer  g_class,
4700                                     gint     *private_size_or_offset)
4701 {
4702   GType class_gtype = ((GTypeClass *) g_class)-&gt;g_type;
4703   TypeNode *node = lookup_type_node_I (class_gtype);
4704   gssize private_size;
4705 
4706   g_return_if_fail (private_size_or_offset != NULL);
4707 
4708   /* if we have been passed the offset instead of the private data size,
4709    * then we consider this as a no-op, and just return the value. see the
4710    * comment in g_type_add_instance_private() for the full explanation.
4711    */
4712   if (*private_size_or_offset &gt; 0)
4713     g_return_if_fail (*private_size_or_offset &lt;= 0xffff);
4714   else
4715     return;
4716 
4717   if (!node || !node-&gt;is_classed || !node-&gt;is_instantiatable || !node-&gt;data)
4718     {
4719       g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
4720          type_descriptive_name_I (class_gtype));
4721       *private_size_or_offset = 0;
4722       return;
4723     }
4724 
4725   if (NODE_PARENT_TYPE (node))
4726     {
4727       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
4728       if (node-&gt;data-&gt;instance.private_size != pnode-&gt;data-&gt;instance.private_size)
4729     {
4730       g_warning (&quot;g_type_add_instance_private() called multiple times for the same type&quot;);
4731           *private_size_or_offset = 0;
4732       return;
4733     }
4734     }
4735 
4736   G_WRITE_LOCK (&amp;type_rw_lock);
4737 
4738   private_size = ALIGN_STRUCT (node-&gt;data-&gt;instance.private_size + *private_size_or_offset);
4739   g_assert (private_size &lt;= 0xffff);
4740   node-&gt;data-&gt;instance.private_size = private_size;
4741 
4742   *private_size_or_offset = -(gint) node-&gt;data-&gt;instance.private_size;
4743 
4744   G_WRITE_UNLOCK (&amp;type_rw_lock);
4745 }
4746 
4747 gpointer
4748 g_type_instance_get_private (GTypeInstance *instance,
4749                  GType          private_type)
4750 {
4751   TypeNode *node;
4752 
4753   g_return_val_if_fail (instance != NULL &amp;&amp; instance-&gt;g_class != NULL, NULL);
4754 
4755   node = lookup_type_node_I (private_type);
4756   if (G_UNLIKELY (!node || !node-&gt;is_instantiatable))
4757     {
4758       g_warning (&quot;instance of invalid non-instantiatable type &#39;%s&#39;&quot;,
4759                  type_descriptive_name_I (instance-&gt;g_class-&gt;g_type));
4760       return NULL;
4761     }
4762 
4763   return ((gchar *) instance) - node-&gt;data-&gt;instance.private_size;
4764 }
4765 
4766 /**
4767  * g_type_class_get_instance_private_offset: (skip)
4768  * @g_class: (type GObject.TypeClass): a #GTypeClass
4769  *
4770  * Gets the offset of the private data for instances of @g_class.
4771  *
4772  * This is how many bytes you should add to the instance pointer of a
4773  * class in order to get the private data for the type represented by
4774  * @g_class.
4775  *
4776  * You can only call this function after you have registered a private
4777  * data area for @g_class using g_type_class_add_private().
4778  *
4779  * Returns: the offset, in bytes
4780  *
4781  * Since: 2.38
4782  **/
4783 gint
4784 g_type_class_get_instance_private_offset (gpointer g_class)
4785 {
4786   GType instance_type;
4787   guint16 parent_size;
4788   TypeNode *node;
4789 
4790   g_assert (g_class != NULL);
4791 
4792   instance_type = ((GTypeClass *) g_class)-&gt;g_type;
4793   node = lookup_type_node_I (instance_type);
4794 
4795   g_assert (node != NULL);
4796   g_assert (node-&gt;is_instantiatable);
4797 
4798   if (NODE_PARENT_TYPE (node))
4799     {
4800       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
4801 
4802       parent_size = pnode-&gt;data-&gt;instance.private_size;
4803     }
4804   else
4805     parent_size = 0;
4806 
4807   if (node-&gt;data-&gt;instance.private_size == parent_size)
4808     g_error (&quot;g_type_class_get_instance_private_offset() called on class %s but it has no private data&quot;,
4809              g_type_name (instance_type));
4810 
4811   return -(gint) node-&gt;data-&gt;instance.private_size;
4812 }
4813 
4814 /**
4815  * g_type_add_class_private:
4816  * @class_type: GType of an classed type
4817  * @private_size: size of private structure
4818  *
4819  * Registers a private class structure for a classed type;
4820  * when the class is allocated, the private structures for
4821  * the class and all of its parent types are allocated
4822  * sequentially in the same memory block as the public
4823  * structures, and are zero-filled.
4824  *
4825  * This function should be called in the
4826  * type&#39;s get_type() function after the type is registered.
4827  * The private structure can be retrieved using the
4828  * G_TYPE_CLASS_GET_PRIVATE() macro.
4829  *
4830  * Since: 2.24
4831  */
4832 void
4833 g_type_add_class_private (GType    class_type,
4834               gsize    private_size)
4835 {
4836   TypeNode *node = lookup_type_node_I (class_type);
4837   gsize offset;
4838 
4839   g_return_if_fail (private_size &gt; 0);
4840 
4841   if (!node || !node-&gt;is_classed || !node-&gt;data)
4842     {
4843       g_warning (&quot;cannot add class private field to invalid type &#39;%s&#39;&quot;,
4844          type_descriptive_name_I (class_type));
4845       return;
4846     }
4847 
4848   if (NODE_PARENT_TYPE (node))
4849     {
4850       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
4851       if (node-&gt;data-&gt;class.class_private_size != pnode-&gt;data-&gt;class.class_private_size)
4852     {
4853       g_warning (&quot;g_type_add_class_private() called multiple times for the same type&quot;);
4854       return;
4855     }
4856     }
4857 
4858   G_WRITE_LOCK (&amp;type_rw_lock);
4859 
4860   offset = ALIGN_STRUCT (node-&gt;data-&gt;class.class_private_size);
4861   node-&gt;data-&gt;class.class_private_size = offset + private_size;
4862 
4863   G_WRITE_UNLOCK (&amp;type_rw_lock);
4864 }
4865 
4866 gpointer
4867 g_type_class_get_private (GTypeClass *klass,
4868               GType       private_type)
4869 {
4870   TypeNode *class_node;
4871   TypeNode *private_node;
4872   TypeNode *parent_node;
4873   gsize offset;
4874 
4875   g_return_val_if_fail (klass != NULL, NULL);
4876 
4877   class_node = lookup_type_node_I (klass-&gt;g_type);
4878   if (G_UNLIKELY (!class_node || !class_node-&gt;is_classed))
4879     {
4880       g_warning (&quot;class of invalid type &#39;%s&#39;&quot;,
4881          type_descriptive_name_I (klass-&gt;g_type));
4882       return NULL;
4883     }
4884 
4885   private_node = lookup_type_node_I (private_type);
4886   if (G_UNLIKELY (!private_node || !NODE_IS_ANCESTOR (private_node, class_node)))
4887     {
4888       g_warning (&quot;attempt to retrieve private data for invalid type &#39;%s&#39;&quot;,
4889          type_descriptive_name_I (private_type));
4890       return NULL;
4891     }
4892 
4893   offset = ALIGN_STRUCT (class_node-&gt;data-&gt;class.class_size);
4894 
4895   if (NODE_PARENT_TYPE (private_node))
4896     {
4897       parent_node = lookup_type_node_I (NODE_PARENT_TYPE (private_node));
4898       g_assert (parent_node-&gt;data &amp;&amp; NODE_REFCOUNT (parent_node) &gt; 0);
4899 
4900       if (G_UNLIKELY (private_node-&gt;data-&gt;class.class_private_size == parent_node-&gt;data-&gt;class.class_private_size))
4901     {
4902       g_warning (&quot;g_type_instance_get_class_private() requires a prior call to g_type_add_class_private()&quot;);
4903       return NULL;
4904     }
4905 
4906       offset += ALIGN_STRUCT (parent_node-&gt;data-&gt;class.class_private_size);
4907     }
4908 
4909   return G_STRUCT_MEMBER_P (klass, offset);
4910 }
4911 
4912 /**
4913  * g_type_ensure:
4914  * @type: a #GType
4915  *
4916  * Ensures that the indicated @type has been registered with the
4917  * type system, and its _class_init() method has been run.
4918  *
4919  * In theory, simply calling the type&#39;s _get_type() method (or using
4920  * the corresponding macro) is supposed take care of this. However,
4921  * _get_type() methods are often marked %G_GNUC_CONST for performance
4922  * reasons, even though this is technically incorrect (since
4923  * %G_GNUC_CONST requires that the function not have side effects,
4924  * which _get_type() methods do on the first call). As a result, if
4925  * you write a bare call to a _get_type() macro, it may get optimized
4926  * out by the compiler. Using g_type_ensure() guarantees that the
4927  * type&#39;s _get_type() method is called.
4928  *
4929  * Since: 2.34
4930  */
4931 void
4932 g_type_ensure (GType type)
4933 {
4934   /* In theory, @type has already been resolved and so there&#39;s nothing
4935    * to do here. But this protects us in the case where the function
4936    * gets inlined (as it might in gobject_init_ctor() above).
4937    */
4938   if (G_UNLIKELY (type == (GType)-1))
4939     g_error (&quot;can&#39;t happen&quot;);
4940 }
4941 
    </pre>
  </body>
</html>