<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudiometa.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* GStreamer
  2  * Copyright (C) &lt;2011&gt; Wim Taymans &lt;wim.taymans@gmail.com&gt;
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public
 15  * License along with this library; if not, write to the
 16  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  */
 19 
 20 /**
 21  * SECTION:gstaudiometa
<a name="1" id="anc1"></a><span class="line-modified"> 22  * @title: GstAudio meta</span>
 23  * @short_description: Buffer metadata for audio downmix matrix handling
 24  *
 25  * #GstAudioDownmixMeta defines an audio downmix matrix to be send along with
 26  * audio buffers. These functions in this module help to create and attach the
 27  * meta as well as extracting it.
 28  */
<a name="2" id="anc2"></a><span class="line-added"> 29 #ifdef HAVE_CONFIG_H</span>
<span class="line-added"> 30 #include &quot;config.h&quot;</span>
<span class="line-added"> 31 #endif</span>
 32 
 33 #include &lt;string.h&gt;
 34 
 35 #include &quot;gstaudiometa.h&quot;
 36 
 37 static gboolean
 38 gst_audio_downmix_meta_init (GstMeta * meta, gpointer params,
 39     GstBuffer * buffer)
 40 {
 41   GstAudioDownmixMeta *dmeta = (GstAudioDownmixMeta *) meta;
 42 
 43   dmeta-&gt;from_position = dmeta-&gt;to_position = NULL;
 44   dmeta-&gt;from_channels = dmeta-&gt;to_channels = 0;
 45   dmeta-&gt;matrix = NULL;
 46 
 47   return TRUE;
 48 }
 49 
 50 static void
 51 gst_audio_downmix_meta_free (GstMeta * meta, GstBuffer * buffer)
 52 {
 53   GstAudioDownmixMeta *dmeta = (GstAudioDownmixMeta *) meta;
 54 
 55   g_free (dmeta-&gt;from_position);
 56   if (dmeta-&gt;matrix) {
 57     g_free (*dmeta-&gt;matrix);
 58     g_free (dmeta-&gt;matrix);
 59   }
 60 }
 61 
 62 static gboolean
 63 gst_audio_downmix_meta_transform (GstBuffer * dest, GstMeta * meta,
 64     GstBuffer * buffer, GQuark type, gpointer data)
 65 {
 66   GstAudioDownmixMeta *smeta, *dmeta;
 67 
 68   smeta = (GstAudioDownmixMeta *) meta;
 69 
 70   if (GST_META_TRANSFORM_IS_COPY (type)) {
 71     dmeta = gst_buffer_add_audio_downmix_meta (dest, smeta-&gt;from_position,
<a name="3" id="anc3"></a><span class="line-modified"> 72         smeta-&gt;from_channels, smeta-&gt;to_position, smeta-&gt;to_channels,</span>
<span class="line-modified"> 73         (const gfloat **) smeta-&gt;matrix);</span>
 74     if (!dmeta)
 75       return FALSE;
 76   } else {
 77     /* return FALSE, if transform type is not supported */
 78     return FALSE;
 79   }
 80 
 81   return TRUE;
 82 }
 83 
 84 /**
 85  * gst_buffer_get_audio_downmix_meta_for_channels:
 86  * @buffer: a #GstBuffer
 87  * @to_position: (array length=to_channels): the channel positions of
 88  *   the destination
 89  * @to_channels: The number of channels of the destination
 90  *
 91  * Find the #GstAudioDownmixMeta on @buffer for the given destination
 92  * channel positions.
 93  *
 94  * Returns: (transfer none): the #GstAudioDownmixMeta on @buffer.
 95  */
 96 GstAudioDownmixMeta *
 97 gst_buffer_get_audio_downmix_meta_for_channels (GstBuffer * buffer,
 98     const GstAudioChannelPosition * to_position, gint to_channels)
 99 {
100   gpointer state = NULL;
101   GstMeta *meta;
102   const GstMetaInfo *info = GST_AUDIO_DOWNMIX_META_INFO;
103 
104   while ((meta = gst_buffer_iterate_meta (buffer, &amp;state))) {
105     if (meta-&gt;info-&gt;api == info-&gt;api) {
106       GstAudioDownmixMeta *ameta = (GstAudioDownmixMeta *) meta;
107       if (ameta-&gt;to_channels == to_channels &amp;&amp;
108           memcmp (ameta-&gt;to_position, to_position,
109               sizeof (GstAudioChannelPosition) * to_channels) == 0)
110         return ameta;
111     }
112   }
113   return NULL;
114 }
115 
116 /**
117  * gst_buffer_add_audio_downmix_meta:
118  * @buffer: a #GstBuffer
119  * @from_position: (array length=from_channels): the channel positions
120  *   of the source
121  * @from_channels: The number of channels of the source
122  * @to_position: (array length=to_channels): the channel positions of
123  *   the destination
124  * @to_channels: The number of channels of the destination
125  * @matrix: The matrix coefficients.
126  *
127  * Attaches #GstAudioDownmixMeta metadata to @buffer with the given parameters.
128  *
129  * @matrix is an two-dimensional array of @to_channels times @from_channels
130  * coefficients, i.e. the i-th output channels is constructed by multiplicating
131  * the input channels with the coefficients in @matrix[i] and taking the sum
132  * of the results.
133  *
134  * Returns: (transfer none): the #GstAudioDownmixMeta on @buffer.
135  */
136 GstAudioDownmixMeta *
137 gst_buffer_add_audio_downmix_meta (GstBuffer * buffer,
138     const GstAudioChannelPosition * from_position, gint from_channels,
139     const GstAudioChannelPosition * to_position, gint to_channels,
140     const gfloat ** matrix)
141 {
142   GstAudioDownmixMeta *meta;
143   gint i;
144 
145   g_return_val_if_fail (from_position != NULL, NULL);
146   g_return_val_if_fail (from_channels &gt; 0, NULL);
147   g_return_val_if_fail (to_position != NULL, NULL);
148   g_return_val_if_fail (to_channels &gt; 0, NULL);
149   g_return_val_if_fail (matrix != NULL, NULL);
150 
151   meta =
152       (GstAudioDownmixMeta *) gst_buffer_add_meta (buffer,
153       GST_AUDIO_DOWNMIX_META_INFO, NULL);
154 
155   meta-&gt;from_channels = from_channels;
156   meta-&gt;to_channels = to_channels;
157 
158   meta-&gt;from_position =
159       g_new (GstAudioChannelPosition, meta-&gt;from_channels + meta-&gt;to_channels);
160   meta-&gt;to_position = meta-&gt;from_position + meta-&gt;from_channels;
161   memcpy (meta-&gt;from_position, from_position,
162       sizeof (GstAudioChannelPosition) * meta-&gt;from_channels);
163   memcpy (meta-&gt;to_position, to_position,
164       sizeof (GstAudioChannelPosition) * meta-&gt;to_channels);
165 
166   meta-&gt;matrix = g_new (gfloat *, meta-&gt;to_channels);
167   meta-&gt;matrix[0] = g_new (gfloat, meta-&gt;from_channels * meta-&gt;to_channels);
168   memcpy (meta-&gt;matrix[0], matrix[0], sizeof (gfloat) * meta-&gt;from_channels);
169   for (i = 1; i &lt; meta-&gt;to_channels; i++) {
170     meta-&gt;matrix[i] = meta-&gt;matrix[0] + i * meta-&gt;from_channels;
171     memcpy (meta-&gt;matrix[i], matrix[i], sizeof (gfloat) * meta-&gt;from_channels);
172   }
173 
174   return meta;
175 }
176 
177 GType
178 gst_audio_downmix_meta_api_get_type (void)
179 {
180   static volatile GType type;
181   static const gchar *tags[] =
182       { GST_META_TAG_AUDIO_STR, GST_META_TAG_AUDIO_CHANNELS_STR, NULL };
183 
184   if (g_once_init_enter (&amp;type)) {
185     GType _type = gst_meta_api_type_register (&quot;GstAudioDownmixMetaAPI&quot;, tags);
186     g_once_init_leave (&amp;type, _type);
187   }
188   return type;
189 }
190 
191 const GstMetaInfo *
192 gst_audio_downmix_meta_get_info (void)
193 {
194   static const GstMetaInfo *audio_downmix_meta_info = NULL;
195 
196   if (g_once_init_enter ((GstMetaInfo **) &amp; audio_downmix_meta_info)) {
197     const GstMetaInfo *meta =
198         gst_meta_register (GST_AUDIO_DOWNMIX_META_API_TYPE,
199         &quot;GstAudioDownmixMeta&quot;, sizeof (GstAudioDownmixMeta),
200         gst_audio_downmix_meta_init, gst_audio_downmix_meta_free,
201         gst_audio_downmix_meta_transform);
202     g_once_init_leave ((GstMetaInfo **) &amp; audio_downmix_meta_info,
203         (GstMetaInfo *) meta);
204   }
205   return audio_downmix_meta_info;
206 }
207 
208 static gboolean
209 gst_audio_clipping_meta_init (GstMeta * meta, gpointer params,
210     GstBuffer * buffer)
211 {
212   GstAudioClippingMeta *cmeta = (GstAudioClippingMeta *) meta;
213 
214   cmeta-&gt;format = GST_FORMAT_UNDEFINED;
215   cmeta-&gt;start = cmeta-&gt;end = 0;
216 
217   return TRUE;
218 }
219 
220 static gboolean
221 gst_audio_clipping_meta_transform (GstBuffer * dest, GstMeta * meta,
222     GstBuffer * buffer, GQuark type, gpointer data)
223 {
224   GstAudioClippingMeta *smeta, *dmeta;
225 
226   smeta = (GstAudioClippingMeta *) meta;
227 
228   if (GST_META_TRANSFORM_IS_COPY (type)) {
229     GstMetaTransformCopy *copy = data;
230 
231     if (copy-&gt;region)
232       return FALSE;
233 
234     dmeta =
235         gst_buffer_add_audio_clipping_meta (dest, smeta-&gt;format, smeta-&gt;start,
236         smeta-&gt;end);
237     if (!dmeta)
238       return FALSE;
239   } else {
240     /* TODO: Could implement an automatic transform for resampling */
241     /* return FALSE, if transform type is not supported */
242     return FALSE;
243   }
244 
245   return TRUE;
246 }
247 
248 /**
249  * gst_buffer_add_audio_clipping_meta:
250  * @buffer: a #GstBuffer
251  * @format: GstFormat of @start and @stop, GST_FORMAT_DEFAULT is samples
252  * @start: Amount of audio to clip from start of buffer
253  * @end: Amount of  to clip from end of buffer
254  *
255  * Attaches #GstAudioClippingMeta metadata to @buffer with the given parameters.
256  *
257  * Returns: (transfer none): the #GstAudioClippingMeta on @buffer.
258  *
259  * Since: 1.8
260  */
261 GstAudioClippingMeta *
262 gst_buffer_add_audio_clipping_meta (GstBuffer * buffer,
263     GstFormat format, guint64 start, guint64 end)
264 {
265   GstAudioClippingMeta *meta;
266 
267   g_return_val_if_fail (format != GST_FORMAT_UNDEFINED, NULL);
268 
269   meta =
270       (GstAudioClippingMeta *) gst_buffer_add_meta (buffer,
271       GST_AUDIO_CLIPPING_META_INFO, NULL);
272 
273   meta-&gt;format = format;
274   meta-&gt;start = start;
275   meta-&gt;end = end;
276 
277   return meta;
278 }
279 
280 GType
281 gst_audio_clipping_meta_api_get_type (void)
282 {
283   static volatile GType type;
284   static const gchar *tags[] =
285       { GST_META_TAG_AUDIO_STR, GST_META_TAG_AUDIO_RATE_STR, NULL };
286 
287   if (g_once_init_enter (&amp;type)) {
288     GType _type = gst_meta_api_type_register (&quot;GstAudioClippingMetaAPI&quot;, tags);
289     g_once_init_leave (&amp;type, _type);
290   }
291   return type;
292 }
293 
294 const GstMetaInfo *
295 gst_audio_clipping_meta_get_info (void)
296 {
297   static const GstMetaInfo *audio_clipping_meta_info = NULL;
298 
299   if (g_once_init_enter ((GstMetaInfo **) &amp; audio_clipping_meta_info)) {
300     const GstMetaInfo *meta =
301         gst_meta_register (GST_AUDIO_CLIPPING_META_API_TYPE,
302         &quot;GstAudioClippingMeta&quot;, sizeof (GstAudioClippingMeta),
303         gst_audio_clipping_meta_init, NULL,
304         gst_audio_clipping_meta_transform);
305     g_once_init_leave ((GstMetaInfo **) &amp; audio_clipping_meta_info,
306         (GstMetaInfo *) meta);
307   }
308   return audio_clipping_meta_info;
309 }
<a name="4" id="anc4"></a><span class="line-added">310 </span>
<span class="line-added">311 </span>
<span class="line-added">312 static gboolean</span>
<span class="line-added">313 gst_audio_meta_init (GstMeta * meta, gpointer params, GstBuffer * buffer)</span>
<span class="line-added">314 {</span>
<span class="line-added">315   GstAudioMeta *ameta = (GstAudioMeta *) meta;</span>
<span class="line-added">316 </span>
<span class="line-added">317   gst_audio_info_init (&amp;ameta-&gt;info);</span>
<span class="line-added">318   ameta-&gt;samples = 0;</span>
<span class="line-added">319   ameta-&gt;offsets = NULL;</span>
<span class="line-added">320 </span>
<span class="line-added">321   return TRUE;</span>
<span class="line-added">322 }</span>
<span class="line-added">323 </span>
<span class="line-added">324 static void</span>
<span class="line-added">325 gst_audio_meta_free (GstMeta * meta, GstBuffer * buffer)</span>
<span class="line-added">326 {</span>
<span class="line-added">327   GstAudioMeta *ameta = (GstAudioMeta *) meta;</span>
<span class="line-added">328 </span>
<span class="line-added">329   if (ameta-&gt;offsets &amp;&amp; ameta-&gt;offsets != ameta-&gt;priv_offsets_arr)</span>
<span class="line-added">330     g_slice_free1 (ameta-&gt;info.channels * sizeof (gsize), ameta-&gt;offsets);</span>
<span class="line-added">331 }</span>
<span class="line-added">332 </span>
<span class="line-added">333 static gboolean</span>
<span class="line-added">334 gst_audio_meta_transform (GstBuffer * dest, GstMeta * meta,</span>
<span class="line-added">335     GstBuffer * buffer, GQuark type, gpointer data)</span>
<span class="line-added">336 {</span>
<span class="line-added">337   GstAudioMeta *smeta, *dmeta;</span>
<span class="line-added">338 </span>
<span class="line-added">339   smeta = (GstAudioMeta *) meta;</span>
<span class="line-added">340 </span>
<span class="line-added">341   if (GST_META_TRANSFORM_IS_COPY (type)) {</span>
<span class="line-added">342     dmeta = gst_buffer_add_audio_meta (dest, &amp;smeta-&gt;info, smeta-&gt;samples,</span>
<span class="line-added">343         smeta-&gt;offsets);</span>
<span class="line-added">344     if (!dmeta)</span>
<span class="line-added">345       return FALSE;</span>
<span class="line-added">346   } else {</span>
<span class="line-added">347     /* return FALSE, if transform type is not supported */</span>
<span class="line-added">348     return FALSE;</span>
<span class="line-added">349   }</span>
<span class="line-added">350 </span>
<span class="line-added">351   return TRUE;</span>
<span class="line-added">352 }</span>
<span class="line-added">353 </span>
<span class="line-added">354 /**</span>
<span class="line-added">355  * gst_buffer_add_audio_meta:</span>
<span class="line-added">356  * @buffer: a #GstBuffer</span>
<span class="line-added">357  * @info: the audio properties of the buffer</span>
<span class="line-added">358  * @samples: the number of valid samples in the buffer</span>
<span class="line-added">359  * @offsets: (nullable): the offsets (in bytes) where each channel plane starts</span>
<span class="line-added">360  *   in the buffer or %NULL to calculate it (see below); must be %NULL also</span>
<span class="line-added">361  *   when @info-&gt;layout is %GST_AUDIO_LAYOUT_INTERLEAVED</span>
<span class="line-added">362  *</span>
<span class="line-added">363  * Allocates and attaches a #GstAudioMeta on @buffer, which must be writable</span>
<span class="line-added">364  * for that purpose. The fields of the #GstAudioMeta are directly populated</span>
<span class="line-added">365  * from the arguments of this function.</span>
<span class="line-added">366  *</span>
<span class="line-added">367  * When @info-&gt;layout is %GST_AUDIO_LAYOUT_NON_INTERLEAVED and @offsets is</span>
<span class="line-added">368  * %NULL, the offsets are calculated with a formula that assumes the planes are</span>
<span class="line-added">369  * tightly packed and in sequence:</span>
<span class="line-added">370  * offsets[channel] = channel * @samples * sample_stride</span>
<span class="line-added">371  *</span>
<span class="line-added">372  * It is not allowed for channels to overlap in memory,</span>
<span class="line-added">373  * i.e. for each i in [0, channels), the range</span>
<span class="line-added">374  * [@offsets[i], @offsets[i] + @samples * sample_stride) must not overlap</span>
<span class="line-added">375  * with any other such range. This function will assert if the parameters</span>
<span class="line-added">376  * specified cause this restriction to be violated.</span>
<span class="line-added">377  *</span>
<span class="line-added">378  * It is, obviously, also not allowed to specify parameters that would cause</span>
<span class="line-added">379  * out-of-bounds memory access on @buffer. This is also checked, which means</span>
<span class="line-added">380  * that you must add enough memory on the @buffer before adding this meta.</span>
<span class="line-added">381  *</span>
<span class="line-added">382  * Returns: (transfer none): the #GstAudioMeta that was attached on the @buffer</span>
<span class="line-added">383  *</span>
<span class="line-added">384  * Since: 1.16</span>
<span class="line-added">385  */</span>
<span class="line-added">386 GstAudioMeta *</span>
<span class="line-added">387 gst_buffer_add_audio_meta (GstBuffer * buffer, const GstAudioInfo * info,</span>
<span class="line-added">388     gsize samples, gsize offsets[])</span>
<span class="line-added">389 {</span>
<span class="line-added">390   GstAudioMeta *meta;</span>
<span class="line-added">391   gint i;</span>
<span class="line-added">392   gsize plane_size;</span>
<span class="line-added">393 </span>
<span class="line-added">394   g_return_val_if_fail (GST_IS_BUFFER (buffer), FALSE);</span>
<span class="line-added">395   g_return_val_if_fail (info != NULL, NULL);</span>
<span class="line-added">396   g_return_val_if_fail (GST_AUDIO_INFO_IS_VALID (info), NULL);</span>
<span class="line-added">397   g_return_val_if_fail (GST_AUDIO_INFO_FORMAT (info) !=</span>
<span class="line-added">398       GST_AUDIO_FORMAT_UNKNOWN, NULL);</span>
<span class="line-added">399   g_return_val_if_fail (info-&gt;layout == GST_AUDIO_LAYOUT_NON_INTERLEAVED</span>
<span class="line-added">400       || !offsets, NULL);</span>
<span class="line-added">401 </span>
<span class="line-added">402   meta =</span>
<span class="line-added">403       (GstAudioMeta *) gst_buffer_add_meta (buffer, GST_AUDIO_META_INFO, NULL);</span>
<span class="line-added">404 </span>
<span class="line-added">405   meta-&gt;info = *info;</span>
<span class="line-added">406   meta-&gt;samples = samples;</span>
<span class="line-added">407   plane_size = samples * info-&gt;finfo-&gt;width / 8;</span>
<span class="line-added">408 </span>
<span class="line-added">409   if (info-&gt;layout == GST_AUDIO_LAYOUT_NON_INTERLEAVED) {</span>
<span class="line-added">410 #ifndef G_DISABLE_CHECKS</span>
<span class="line-added">411     gsize max_offset = 0;</span>
<span class="line-added">412     gint j;</span>
<span class="line-added">413 #endif</span>
<span class="line-added">414 </span>
<span class="line-added">415     if (G_UNLIKELY (info-&gt;channels &gt; 8))</span>
<span class="line-added">416       meta-&gt;offsets = g_slice_alloc (info-&gt;channels * sizeof (gsize));</span>
<span class="line-added">417     else</span>
<span class="line-added">418       meta-&gt;offsets = meta-&gt;priv_offsets_arr;</span>
<span class="line-added">419 </span>
<span class="line-added">420     if (offsets) {</span>
<span class="line-added">421       for (i = 0; i &lt; info-&gt;channels; i++) {</span>
<span class="line-added">422         meta-&gt;offsets[i] = offsets[i];</span>
<span class="line-added">423 #ifndef G_DISABLE_CHECKS</span>
<span class="line-added">424         max_offset = MAX (max_offset, offsets[i]);</span>
<span class="line-added">425         for (j = 0; j &lt; info-&gt;channels; j++) {</span>
<span class="line-added">426           if (i != j &amp;&amp; !(offsets[j] + plane_size &lt;= offsets[i]</span>
<span class="line-added">427                   || offsets[i] + plane_size &lt;= offsets[j])) {</span>
<span class="line-added">428             g_critical (&quot;GstAudioMeta properties would cause channel memory &quot;</span>
<span class="line-added">429                 &quot;areas to overlap! offsets: %&quot; G_GSIZE_FORMAT &quot; (%d), %&quot;</span>
<span class="line-added">430                 G_GSIZE_FORMAT &quot; (%d) with plane size %&quot; G_GSIZE_FORMAT,</span>
<span class="line-added">431                 offsets[i], i, offsets[j], j, plane_size);</span>
<span class="line-added">432             gst_buffer_remove_meta (buffer, (GstMeta *) meta);</span>
<span class="line-added">433             return NULL;</span>
<span class="line-added">434           }</span>
<span class="line-added">435         }</span>
<span class="line-added">436 #endif</span>
<span class="line-added">437       }</span>
<span class="line-added">438     } else {</span>
<span class="line-added">439       /* default offsets assume channels are laid out sequentially in memory */</span>
<span class="line-added">440       for (i = 0; i &lt; info-&gt;channels; i++)</span>
<span class="line-added">441         meta-&gt;offsets[i] = i * plane_size;</span>
<span class="line-added">442 #ifndef G_DISABLE_CHECKS</span>
<span class="line-added">443       max_offset = meta-&gt;offsets[info-&gt;channels - 1];</span>
<span class="line-added">444 #endif</span>
<span class="line-added">445     }</span>
<span class="line-added">446 </span>
<span class="line-added">447 #ifndef G_DISABLE_CHECKS</span>
<span class="line-added">448     if (max_offset + plane_size &gt; gst_buffer_get_size (buffer)) {</span>
<span class="line-added">449       g_critical (&quot;GstAudioMeta properties would cause &quot;</span>
<span class="line-added">450           &quot;out-of-bounds memory access on the buffer: max_offset %&quot;</span>
<span class="line-added">451           G_GSIZE_FORMAT &quot;, samples %&quot; G_GSIZE_FORMAT &quot;, bps %u, buffer size %&quot;</span>
<span class="line-added">452           G_GSIZE_FORMAT, max_offset, samples, info-&gt;finfo-&gt;width / 8,</span>
<span class="line-added">453           gst_buffer_get_size (buffer));</span>
<span class="line-added">454       gst_buffer_remove_meta (buffer, (GstMeta *) meta);</span>
<span class="line-added">455       return NULL;</span>
<span class="line-added">456     }</span>
<span class="line-added">457 #endif</span>
<span class="line-added">458   }</span>
<span class="line-added">459 </span>
<span class="line-added">460   return meta;</span>
<span class="line-added">461 }</span>
<span class="line-added">462 </span>
<span class="line-added">463 GType</span>
<span class="line-added">464 gst_audio_meta_api_get_type (void)</span>
<span class="line-added">465 {</span>
<span class="line-added">466   static volatile GType type;</span>
<span class="line-added">467   static const gchar *tags[] = {</span>
<span class="line-added">468     GST_META_TAG_AUDIO_STR, GST_META_TAG_AUDIO_CHANNELS_STR,</span>
<span class="line-added">469     GST_META_TAG_AUDIO_RATE_STR, NULL</span>
<span class="line-added">470   };</span>
<span class="line-added">471 </span>
<span class="line-added">472   if (g_once_init_enter (&amp;type)) {</span>
<span class="line-added">473     GType _type = gst_meta_api_type_register (&quot;GstAudioMetaAPI&quot;, tags);</span>
<span class="line-added">474     g_once_init_leave (&amp;type, _type);</span>
<span class="line-added">475   }</span>
<span class="line-added">476   return type;</span>
<span class="line-added">477 }</span>
<span class="line-added">478 </span>
<span class="line-added">479 const GstMetaInfo *</span>
<span class="line-added">480 gst_audio_meta_get_info (void)</span>
<span class="line-added">481 {</span>
<span class="line-added">482   static const GstMetaInfo *audio_meta_info = NULL;</span>
<span class="line-added">483 </span>
<span class="line-added">484   if (g_once_init_enter ((GstMetaInfo **) &amp; audio_meta_info)) {</span>
<span class="line-added">485     const GstMetaInfo *meta = gst_meta_register (GST_AUDIO_META_API_TYPE,</span>
<span class="line-added">486         &quot;GstAudioMeta&quot;, sizeof (GstAudioMeta),</span>
<span class="line-added">487         gst_audio_meta_init,</span>
<span class="line-added">488         gst_audio_meta_free,</span>
<span class="line-added">489         gst_audio_meta_transform);</span>
<span class="line-added">490     g_once_init_leave ((GstMetaInfo **) &amp; audio_meta_info,</span>
<span class="line-added">491         (GstMetaInfo *) meta);</span>
<span class="line-added">492   }</span>
<span class="line-added">493   return audio_meta_info;</span>
<span class="line-added">494 }</span>
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>