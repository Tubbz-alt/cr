<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmain.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gmacros.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gmain.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmain.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  70 #ifdef G_OS_WIN32
  71 #define STRICT
  72 #include &lt;windows.h&gt;
  73 #endif /* G_OS_WIN32 */
  74 
  75 #ifdef HAVE_MACH_MACH_TIME_H
  76 #include &lt;mach/mach_time.h&gt;
  77 #endif
  78 
  79 #include &quot;glib_trace.h&quot;
  80 
  81 #include &quot;gmain.h&quot;
  82 
  83 #include &quot;garray.h&quot;
  84 #include &quot;giochannel.h&quot;
  85 #include &quot;ghash.h&quot;
  86 #include &quot;ghook.h&quot;
  87 #include &quot;gqueue.h&quot;
  88 #include &quot;gstrfuncs.h&quot;
  89 #include &quot;gtestutils.h&quot;

  90 
  91 #ifdef G_OS_WIN32
  92 #include &quot;gwin32.h&quot;
  93 #endif
  94 
  95 #ifdef  G_MAIN_POLL_DEBUG
  96 #include &quot;gtimer.h&quot;
  97 #endif
  98 
  99 #include &quot;gwakeup.h&quot;
 100 #include &quot;gmain-internal.h&quot;
 101 #include &quot;glib-init.h&quot;
 102 #include &quot;glib-private.h&quot;
 103 
 104 /**
 105  * SECTION:main
 106  * @title: The Main Event Loop
 107  * @short_description: manages all available sources of events
 108  *
 109  * The main event loop manages all the available sources of events for
</pre>
<hr />
<pre>
 173  * g_main_context_prepare(), g_main_context_query(),
 174  * g_main_context_check() and g_main_context_dispatch().
 175  *
 176  * ## State of a Main Context # {#mainloop-states}
 177  *
 178  * The operation of these functions can best be seen in terms
 179  * of a state diagram, as shown in this image.
 180  *
 181  * ![](mainloop-states.gif)
 182  *
 183  * On UNIX, the GLib mainloop is incompatible with fork(). Any program
 184  * using the mainloop must either exec() or exit() from the child
 185  * without returning to the mainloop.
 186  *
 187  * ## Memory management of sources # {#mainloop-memory-management}
 188  *
 189  * There are two options for memory management of the user data passed to a
 190  * #GSource to be passed to its callback on invocation. This data is provided
 191  * in calls to g_timeout_add(), g_timeout_add_full(), g_idle_add(), etc. and
 192  * more generally, using g_source_set_callback(). This data is typically an
<span class="line-modified"> 193  * object which �owns� the timeout or idle callback, such as a widget or a</span>
 194  * network protocol implementation. In many cases, it is an error for the
 195  * callback to be invoked after this owning object has been destroyed, as that
 196  * results in use of freed memory.
 197  *
 198  * The first, and preferred, option is to store the source ID returned by
 199  * functions such as g_timeout_add() or g_source_attach(), and explicitly
 200  * remove that source from the main context using g_source_remove() when the
 201  * owning object is finalized. This ensures that the callback can only be
 202  * invoked while the object is still alive.
 203  *
 204  * The second option is to hold a strong reference to the object in the
<span class="line-modified"> 205  * callback, and to release it in the callback�s #GDestroyNotify. This ensures</span>
 206  * that the object is kept alive until after the source is finalized, which is
 207  * guaranteed to be after it is invoked for the final time. The #GDestroyNotify
<span class="line-modified"> 208  * is another callback passed to the �full� variants of #GSource functions (for</span>
 209  * example, g_timeout_add_full()). It is called when the source is finalized,
 210  * and is designed for releasing references like this.
 211  *
 212  * One important caveat of this second approach is that it will keep the object
 213  * alive indefinitely if the main loop is stopped before the #GSource is
 214  * invoked, which may be undesirable.
 215  */
 216 
 217 /* Types */
 218 
 219 typedef struct _GTimeoutSource GTimeoutSource;
 220 typedef struct _GChildWatchSource GChildWatchSource;
 221 typedef struct _GUnixSignalWatchSource GUnixSignalWatchSource;
 222 typedef struct _GPollRec GPollRec;
 223 typedef struct _GSourceCallback GSourceCallback;
 224 
 225 typedef enum
 226 {
 227   G_SOURCE_READY = 1 &lt;&lt; G_HOOK_FLAG_USER_SHIFT,
 228   G_SOURCE_CAN_RECURSE = 1 &lt;&lt; (G_HOOK_FLAG_USER_SHIFT + 1),
</pre>
<hr />
<pre>
 256 #ifdef G_MAIN_POLL_DEBUG
 257 gboolean _g_main_poll_debug = FALSE;
 258 #endif
 259 
 260 struct _GMainContext
 261 {
 262   /* The following lock is used for both the list of sources
 263    * and the list of poll records
 264    */
 265   GMutex mutex;
 266   GCond cond;
 267   GThread *owner;
 268   guint owner_count;
 269   GSList *waiters;
 270 
 271   volatile gint ref_count;
 272 
 273   GHashTable *sources;              /* guint -&gt; GSource */
 274 
 275   GPtrArray *pending_dispatches;
<span class="line-modified"> 276   gint timeout;         /* Timeout for current iteration */</span>
 277 
 278   guint next_id;
 279   GList *source_lists;
 280   gint in_check_or_prepare;
 281 
 282   GPollRec *poll_records;
 283   guint n_poll_records;
 284   GPollFD *cached_poll_array;
 285   guint cached_poll_array_size;
 286 
 287   GWakeup *wakeup;
 288 
 289   GPollFD wake_up_rec;
 290 
 291 /* Flag indicating whether the set of fd&#39;s changed during a poll */
 292   gboolean poll_changed;
 293 
 294   GPollFunc poll_func;
 295 
 296   gint64   time;
 297   gboolean time_is_fresh;
 298 };
 299 
 300 struct _GSourceCallback
 301 {
 302   volatile gint ref_count;
 303   GSourceFunc func;
 304   gpointer    data;
 305   GDestroyNotify notify;
 306 };
 307 
 308 struct _GMainLoop
 309 {
 310   GMainContext *context;
<span class="line-modified"> 311   gboolean is_running;</span>
 312   volatile gint ref_count;
 313 };
 314 
 315 struct _GTimeoutSource
 316 {
 317   GSource     source;

 318   guint       interval;
 319   gboolean    seconds;
 320 };
 321 
 322 struct _GChildWatchSource
 323 {
 324   GSource     source;
 325   GPid        pid;
 326   gint        child_status;
 327 #ifdef G_OS_WIN32
 328   GPollFD     poll;
 329 #else /* G_OS_WIN32 */
<span class="line-modified"> 330   gboolean    child_exited;</span>
 331 #endif /* G_OS_WIN32 */
 332 };
 333 
 334 struct _GUnixSignalWatchSource
 335 {
 336   GSource     source;
 337   int         signum;
<span class="line-modified"> 338   gboolean    pending;</span>
 339 };
 340 
 341 struct _GPollRec
 342 {
 343   GPollFD *fd;
 344   GPollRec *prev;
 345   GPollRec *next;
 346   gint priority;
 347 };
 348 
 349 struct _GSourcePrivate
 350 {
 351   GSList *child_sources;
 352   GSource *parent_source;
 353 
 354   gint64 ready_time;
 355 
 356   /* This is currently only used on UNIX, but we always declare it (and
 357    * let it remain empty on Windows) to avoid #ifdef all over the place.
 358    */
 359   GSList *fds;
 360 };
 361 
 362 typedef struct _GSourceIter
 363 {
 364   GMainContext *context;
 365   gboolean may_modify;
 366   GList *current_list;
 367   GSource *source;
 368 } GSourceIter;
 369 
 370 #define LOCK_CONTEXT(context) g_mutex_lock (&amp;context-&gt;mutex)
 371 #define UNLOCK_CONTEXT(context) g_mutex_unlock (&amp;context-&gt;mutex)
 372 #define G_THREAD_SELF g_thread_self ()
 373 
 374 #define SOURCE_DESTROYED(source) (((source)-&gt;flags &amp; G_HOOK_FLAG_ACTIVE) == 0)
 375 #define SOURCE_BLOCKED(source) (((source)-&gt;flags &amp; G_SOURCE_BLOCKED) != 0)
 376 
<span class="line-removed"> 377 #define SOURCE_UNREF(source, context)                       \</span>
<span class="line-removed"> 378    G_STMT_START {                                           \</span>
<span class="line-removed"> 379     if ((source)-&gt;ref_count &gt; 1)                            \</span>
<span class="line-removed"> 380       (source)-&gt;ref_count--;                                \</span>
<span class="line-removed"> 381     else                                                    \</span>
<span class="line-removed"> 382       g_source_unref_internal ((source), (context), TRUE);  \</span>
<span class="line-removed"> 383    } G_STMT_END</span>
<span class="line-removed"> 384 </span>
<span class="line-removed"> 385 </span>
 386 /* Forward declarations */
 387 
 388 static void g_source_unref_internal             (GSource      *source,
<span class="line-modified"> 389                          GMainContext *context,</span>
<span class="line-modified"> 390                          gboolean      have_lock);</span>
 391 static void g_source_destroy_internal           (GSource      *source,
<span class="line-modified"> 392                          GMainContext *context,</span>
<span class="line-modified"> 393                          gboolean      have_lock);</span>
 394 static void g_source_set_priority_unlocked      (GSource      *source,
<span class="line-modified"> 395                          GMainContext *context,</span>
<span class="line-modified"> 396                          gint          priority);</span>
 397 static void g_child_source_remove_internal      (GSource      *child_source,
 398                                                  GMainContext *context);
 399 
 400 static void g_main_context_poll                 (GMainContext *context,
<span class="line-modified"> 401                          gint          timeout,</span>
<span class="line-modified"> 402                          gint          priority,</span>
<span class="line-modified"> 403                          GPollFD      *fds,</span>
<span class="line-modified"> 404                          gint          n_fds);</span>
 405 static void g_main_context_add_poll_unlocked    (GMainContext *context,
<span class="line-modified"> 406                          gint          priority,</span>
<span class="line-modified"> 407                          GPollFD      *fd);</span>
 408 static void g_main_context_remove_poll_unlocked (GMainContext *context,
<span class="line-modified"> 409                          GPollFD      *fd);</span>
 410 
 411 static void     g_source_iter_init  (GSourceIter   *iter,
<span class="line-modified"> 412                      GMainContext  *context,</span>
<span class="line-modified"> 413                      gboolean       may_modify);</span>
 414 static gboolean g_source_iter_next  (GSourceIter   *iter,
<span class="line-modified"> 415                      GSource      **source);</span>
 416 static void     g_source_iter_clear (GSourceIter   *iter);
 417 
 418 static gboolean g_timeout_dispatch (GSource     *source,
<span class="line-modified"> 419                     GSourceFunc  callback,</span>
<span class="line-modified"> 420                     gpointer     user_data);</span>
 421 static gboolean g_child_watch_prepare  (GSource     *source,
<span class="line-modified"> 422                         gint        *timeout);</span>
 423 static gboolean g_child_watch_check    (GSource     *source);
 424 static gboolean g_child_watch_dispatch (GSource     *source,
<span class="line-modified"> 425                     GSourceFunc  callback,</span>
<span class="line-modified"> 426                     gpointer     user_data);</span>
 427 static void     g_child_watch_finalize (GSource     *source);
 428 #ifdef G_OS_UNIX
 429 static void g_unix_signal_handler (int signum);
 430 static gboolean g_unix_signal_watch_prepare  (GSource     *source,
<span class="line-modified"> 431                           gint        *timeout);</span>
 432 static gboolean g_unix_signal_watch_check    (GSource     *source);
 433 static gboolean g_unix_signal_watch_dispatch (GSource     *source,
<span class="line-modified"> 434                           GSourceFunc  callback,</span>
<span class="line-modified"> 435                           gpointer     user_data);</span>
 436 static void     g_unix_signal_watch_finalize  (GSource     *source);
 437 #endif
 438 static gboolean g_idle_prepare     (GSource     *source,
<span class="line-modified"> 439                     gint        *timeout);</span>
 440 static gboolean g_idle_check       (GSource     *source);
 441 static gboolean g_idle_dispatch    (GSource     *source,
<span class="line-modified"> 442                     GSourceFunc  callback,</span>
<span class="line-modified"> 443                     gpointer     user_data);</span>
 444 
 445 static void block_source (GSource *source);
 446 
 447 static GMainContext *glib_worker_context;
 448 
 449 G_LOCK_DEFINE_STATIC (main_loop);
 450 static GMainContext *default_main_context;
 451 
 452 #ifndef G_OS_WIN32
 453 
 454 
 455 /* UNIX signals work by marking one of these variables then waking the
 456  * worker context to check on them and dispatch accordingly.
 457  */
 458 #ifdef HAVE_SIG_ATOMIC_T
 459 static volatile sig_atomic_t unix_signal_pending[NSIG];
 460 static volatile sig_atomic_t any_unix_signal_pending;
 461 #else
 462 static volatile int unix_signal_pending[NSIG];
 463 static volatile int any_unix_signal_pending;
 464 #endif
<span class="line-removed"> 465 static volatile guint unix_signal_refcount[NSIG];</span>
 466 
 467 /* Guards all the data below */
 468 G_LOCK_DEFINE_STATIC (unix_signal_lock);

 469 static GSList *unix_signal_watches;
 470 static GSList *unix_child_watches;
 471 
 472 GSourceFuncs g_unix_signal_funcs =
 473 {
 474   g_unix_signal_watch_prepare,
 475   g_unix_signal_watch_check,
 476   g_unix_signal_watch_dispatch,
<span class="line-modified"> 477   g_unix_signal_watch_finalize</span>

 478 };
 479 #endif /* !G_OS_WIN32 */
 480 G_LOCK_DEFINE_STATIC (main_context_list);
 481 static GSList *main_context_list = NULL;
 482 
 483 GSourceFuncs g_timeout_funcs =
 484 {
 485   NULL, /* prepare */
 486   NULL, /* check */
 487   g_timeout_dispatch,
<span class="line-modified"> 488   NULL</span>
 489 };
 490 
 491 GSourceFuncs g_child_watch_funcs =
 492 {
 493   g_child_watch_prepare,
 494   g_child_watch_check,
 495   g_child_watch_dispatch,
<span class="line-modified"> 496   g_child_watch_finalize</span>

 497 };
 498 
 499 GSourceFuncs g_idle_funcs =
 500 {
 501   g_idle_prepare,
 502   g_idle_check,
 503   g_idle_dispatch,
<span class="line-modified"> 504   NULL</span>
 505 };
 506 
 507 /**
 508  * g_main_context_ref:
 509  * @context: a #GMainContext
 510  *
 511  * Increases the reference count on a #GMainContext object by one.
 512  *
 513  * Returns: the @context that was passed in (since 2.6)
 514  **/
 515 GMainContext *
 516 g_main_context_ref (GMainContext *context)
 517 {
 518   g_return_val_if_fail (context != NULL, NULL);
 519   g_return_val_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0, NULL);
 520 
 521   g_atomic_int_inc (&amp;context-&gt;ref_count);
 522 
 523   return context;
 524 }
 525 
 526 static inline void
 527 poll_rec_list_free (GMainContext *context,
<span class="line-modified"> 528             GPollRec     *list)</span>
 529 {
 530   g_slice_free_chain (GPollRec, list, next);
 531 }
 532 
 533 /**
 534  * g_main_context_unref:
 535  * @context: a #GMainContext
 536  *
 537  * Decreases the reference count on a #GMainContext object by one. If
 538  * the result is zero, free the context and free all associated memory.
 539  **/
 540 void
 541 g_main_context_unref (GMainContext *context)
 542 {
 543   GSourceIter iter;
 544   GSource *source;
 545   GList *sl_iter;
 546   GSourceList *list;
 547   guint i;
 548 
</pre>
<hr />
<pre>
 678  * specified, and corresponds to the &quot;main&quot; main loop. See also
 679  * g_main_context_get_thread_default().
 680  *
 681  * Returns: (transfer none): the global default main context.
 682  **/
 683 GMainContext *
 684 g_main_context_default (void)
 685 {
 686   /* Slow, but safe */
 687 
 688   G_LOCK (main_loop);
 689 
 690   if (!default_main_context)
 691     {
 692       default_main_context = g_main_context_new ();
 693 
 694       TRACE (GLIB_MAIN_CONTEXT_DEFAULT (default_main_context));
 695 
 696 #ifdef G_MAIN_POLL_DEBUG
 697       if (_g_main_poll_debug)
<span class="line-modified"> 698     g_print (&quot;default context=%p\n&quot;, default_main_context);</span>
 699 #endif
 700     }
 701 
 702   G_UNLOCK (main_loop);
 703 
 704   return default_main_context;
 705 }
 706 
 707 static void
 708 free_context (gpointer data)
 709 {
 710   GMainContext *context = data;
 711 
 712   TRACE (GLIB_MAIN_CONTEXT_FREE (context));
 713 
 714   g_main_context_release (context);
 715   if (context)
 716     g_main_context_unref (context);
 717 }
 718 
</pre>
<hr />
<pre>
 888 
 889 /**
 890  * g_source_new:
 891  * @source_funcs: structure containing functions that implement
 892  *                the sources behavior.
 893  * @struct_size: size of the #GSource structure to create.
 894  *
 895  * Creates a new #GSource structure. The size is specified to
 896  * allow creating structures derived from #GSource that contain
 897  * additional data. The size passed in must be at least
 898  * `sizeof (GSource)`.
 899  *
 900  * The source will not initially be associated with any #GMainContext
 901  * and must be added to one with g_source_attach() before it will be
 902  * executed.
 903  *
 904  * Returns: the newly-created #GSource.
 905  **/
 906 GSource *
 907 g_source_new (GSourceFuncs *source_funcs,
<span class="line-modified"> 908           guint         struct_size)</span>
 909 {
 910   GSource *source;
 911 
 912   g_return_val_if_fail (source_funcs != NULL, NULL);
 913   g_return_val_if_fail (struct_size &gt;= sizeof (GSource), NULL);
 914 
 915   source = (GSource*) g_malloc0 (struct_size);
 916 #ifdef GSTREAMER_LITE
 917   if (source == NULL)
 918     return NULL;
 919 #endif // GSTREAMER_LITE
 920   source-&gt;priv = g_slice_new0 (GSourcePrivate);
 921 #ifdef GSTREAMER_LITE
 922   if (source-&gt;priv == NULL)
 923   {
 924     g_free(source);
 925     return NULL;
 926   }
 927 #endif // GSTREAMER_LITE
 928   source-&gt;source_funcs = source_funcs;
 929   source-&gt;ref_count = 1;
 930 
 931   source-&gt;priority = G_PRIORITY_DEFAULT;
 932 
 933   source-&gt;flags = G_HOOK_FLAG_ACTIVE;
 934 
 935   source-&gt;priv-&gt;ready_time = -1;
 936 
 937   /* NULL/0 initialization for all other fields */
 938 
 939   TRACE (GLIB_SOURCE_NEW (source, source_funcs-&gt;prepare, source_funcs-&gt;check,
 940                           source_funcs-&gt;dispatch, source_funcs-&gt;finalize,
 941                           struct_size));
 942 
 943   return source;
 944 }
 945 
 946 /* Holds context&#39;s lock */
 947 static void
 948 g_source_iter_init (GSourceIter  *iter,
<span class="line-modified"> 949             GMainContext *context,</span>
<span class="line-modified"> 950             gboolean      may_modify)</span>
 951 {
 952   iter-&gt;context = context;
 953   iter-&gt;current_list = NULL;
 954   iter-&gt;source = NULL;
 955   iter-&gt;may_modify = may_modify;
 956 }
 957 
 958 /* Holds context&#39;s lock */
 959 static gboolean
 960 g_source_iter_next (GSourceIter *iter, GSource **source)
 961 {
 962   GSource *next_source;
 963 
 964   if (iter-&gt;source)
 965     next_source = iter-&gt;source-&gt;next;
 966   else
 967     next_source = NULL;
 968 
 969   if (!next_source)
 970     {
 971       if (iter-&gt;current_list)
<span class="line-modified"> 972     iter-&gt;current_list = iter-&gt;current_list-&gt;next;</span>
 973       else
<span class="line-modified"> 974     iter-&gt;current_list = iter-&gt;context-&gt;source_lists;</span>
 975 
 976       if (iter-&gt;current_list)
<span class="line-modified"> 977     {</span>
<span class="line-modified"> 978       GSourceList *source_list = iter-&gt;current_list-&gt;data;</span>
 979 
<span class="line-modified"> 980       next_source = source_list-&gt;head;</span>
<span class="line-modified"> 981     }</span>
 982     }
 983 
 984   /* Note: unreffing iter-&gt;source could potentially cause its
 985    * GSourceList to be removed from source_lists (if iter-&gt;source is
 986    * the only source in its list, and it is destroyed), so we have to
 987    * keep it reffed until after we advance iter-&gt;current_list, above.
 988    */
 989 
 990   if (iter-&gt;source &amp;&amp; iter-&gt;may_modify)
<span class="line-modified"> 991     SOURCE_UNREF (iter-&gt;source, iter-&gt;context);</span>
 992   iter-&gt;source = next_source;
 993   if (iter-&gt;source &amp;&amp; iter-&gt;may_modify)
<span class="line-modified"> 994     iter-&gt;source-&gt;ref_count++;</span>
 995 
 996   *source = iter-&gt;source;
 997   return *source != NULL;
 998 }
 999 
1000 /* Holds context&#39;s lock. Only necessary to call if you broke out of
1001  * the g_source_iter_next() loop early.
1002  */
1003 static void
1004 g_source_iter_clear (GSourceIter *iter)
1005 {
1006   if (iter-&gt;source &amp;&amp; iter-&gt;may_modify)
1007     {
<span class="line-modified">1008       SOURCE_UNREF (iter-&gt;source, iter-&gt;context);</span>
1009       iter-&gt;source = NULL;
1010     }
1011 }
1012 
1013 /* Holds context&#39;s lock
1014  */
1015 static GSourceList *
1016 find_source_list_for_priority (GMainContext *context,
<span class="line-modified">1017                    gint          priority,</span>
<span class="line-modified">1018                    gboolean      create)</span>
1019 {
1020   GList *iter, *last;
1021   GSourceList *source_list;
1022 
1023   last = NULL;
1024   for (iter = context-&gt;source_lists; iter != NULL; last = iter, iter = iter-&gt;next)
1025     {
1026       source_list = iter-&gt;data;
1027 
1028       if (source_list-&gt;priority == priority)
<span class="line-modified">1029     return source_list;</span>
1030 
1031       if (source_list-&gt;priority &gt; priority)
<span class="line-modified">1032     {</span>
<span class="line-modified">1033       if (!create)</span>
<span class="line-modified">1034         return NULL;</span>
<span class="line-modified">1035 </span>
<span class="line-modified">1036       source_list = g_slice_new0 (GSourceList);</span>
<span class="line-modified">1037       source_list-&gt;priority = priority;</span>
<span class="line-modified">1038       context-&gt;source_lists = g_list_insert_before (context-&gt;source_lists,</span>
<span class="line-modified">1039                             iter,</span>
<span class="line-modified">1040                             source_list);</span>
<span class="line-modified">1041       return source_list;</span>
<span class="line-modified">1042     }</span>
1043     }
1044 
1045   if (!create)
1046     return NULL;
1047 
1048   source_list = g_slice_new0 (GSourceList);
1049   source_list-&gt;priority = priority;
1050 
1051   if (!last)
1052     context-&gt;source_lists = g_list_append (NULL, source_list);
1053   else
1054     {
1055       /* This just appends source_list to the end of
1056        * context-&gt;source_lists without having to walk the list again.
1057        */
1058       last = g_list_append (last, source_list);
1059     }
1060   return source_list;
1061 }
1062 
1063 /* Holds context&#39;s lock
1064  */
1065 static void
1066 source_add_to_context (GSource      *source,
<span class="line-modified">1067                GMainContext *context)</span>
1068 {
1069   GSourceList *source_list;
1070   GSource *prev, *next;
1071 
1072   source_list = find_source_list_for_priority (context, source-&gt;priority, TRUE);
1073 
1074   if (source-&gt;priv-&gt;parent_source)
1075     {
1076       g_assert (source_list-&gt;head != NULL);
1077 
1078       /* Put the source immediately before its parent */
1079       prev = source-&gt;priv-&gt;parent_source-&gt;prev;
1080       next = source-&gt;priv-&gt;parent_source;
1081     }
1082   else
1083     {
1084       prev = source_list-&gt;tail;
1085       next = NULL;
1086     }
1087 
1088   source-&gt;next = next;
1089   if (next)
1090     next-&gt;prev = source;
1091   else
1092     source_list-&gt;tail = source;
1093 
1094   source-&gt;prev = prev;
1095   if (prev)
1096     prev-&gt;next = source;
1097   else
1098     source_list-&gt;head = source;
1099 }
1100 
1101 /* Holds context&#39;s lock
1102  */
1103 static void
1104 source_remove_from_context (GSource      *source,
<span class="line-modified">1105                 GMainContext *context)</span>
1106 {
1107   GSourceList *source_list;
1108 
1109   source_list = find_source_list_for_priority (context, source-&gt;priority, FALSE);
1110   g_return_if_fail (source_list != NULL);
1111 #ifdef GSTREAMER_LITE
1112   if (source_list == NULL)
1113     return;
1114 #endif // GSTREAMER_LITE
1115 
1116   if (source-&gt;prev)
1117     source-&gt;prev-&gt;next = source-&gt;next;
1118   else
1119     source_list-&gt;head = source-&gt;next;
1120 
1121   if (source-&gt;next)
1122     source-&gt;next-&gt;prev = source-&gt;prev;
1123   else
1124     source_list-&gt;tail = source-&gt;prev;
1125 
</pre>
<hr />
<pre>
1133     }
1134 }
1135 
1136 static guint
1137 g_source_attach_unlocked (GSource      *source,
1138                           GMainContext *context,
1139                           gboolean      do_wakeup)
1140 {
1141   GSList *tmp_list;
1142   guint id;
1143 
1144   /* The counter may have wrapped, so we must ensure that we do not
1145    * reuse the source id of an existing source.
1146    */
1147   do
1148     id = context-&gt;next_id++;
1149   while (id == 0 || g_hash_table_contains (context-&gt;sources, GUINT_TO_POINTER (id)));
1150 
1151   source-&gt;context = context;
1152   source-&gt;source_id = id;
<span class="line-modified">1153   source-&gt;ref_count++;</span>
1154 
1155   g_hash_table_insert (context-&gt;sources, GUINT_TO_POINTER (id), source);
1156 
1157   source_add_to_context (source, context);
1158 
1159   if (!SOURCE_BLOCKED (source))
1160     {
1161       tmp_list = source-&gt;poll_fds;
1162       while (tmp_list)
1163         {
1164           g_main_context_add_poll_unlocked (context, source-&gt;priority, tmp_list-&gt;data);
1165           tmp_list = tmp_list-&gt;next;
1166         }
1167 
1168       for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
1169         g_main_context_add_poll_unlocked (context, source-&gt;priority, tmp_list-&gt;data);
1170     }
1171 
1172   tmp_list = source-&gt;priv-&gt;child_sources;
1173   while (tmp_list)
</pre>
<hr />
<pre>
1181    */
1182   if (do_wakeup &amp;&amp; context-&gt;owner &amp;&amp; context-&gt;owner != G_THREAD_SELF)
1183     g_wakeup_signal (context-&gt;wakeup);
1184 
1185   return source-&gt;source_id;
1186 }
1187 
1188 /**
1189  * g_source_attach:
1190  * @source: a #GSource
1191  * @context: (nullable): a #GMainContext (if %NULL, the default context will be used)
1192  *
1193  * Adds a #GSource to a @context so that it will be executed within
1194  * that context. Remove it by calling g_source_destroy().
1195  *
1196  * Returns: the ID (greater than 0) for the source within the
1197  *   #GMainContext.
1198  **/
1199 guint
1200 g_source_attach (GSource      *source,
<span class="line-modified">1201          GMainContext *context)</span>
1202 {
1203   guint result = 0;
1204 
1205 #ifdef GSTREAMER_LITE
1206   if (source == NULL) {
1207     return 0;
1208   }
1209 #endif // GSTREAMER_LITE
1210 
1211   g_return_val_if_fail (source-&gt;context == NULL, 0);
1212   g_return_val_if_fail (!SOURCE_DESTROYED (source), 0);
1213 
1214   if (!context)
1215     context = g_main_context_default ();
1216 
1217   LOCK_CONTEXT (context);
1218 
1219   result = g_source_attach_unlocked (source, context, TRUE);
1220 
1221   TRACE (GLIB_MAIN_SOURCE_ATTACH (g_source_get_name (source), source, context,
1222                                   result));
1223 
1224   UNLOCK_CONTEXT (context);
1225 
1226   return result;
1227 }
1228 
1229 static void
1230 g_source_destroy_internal (GSource      *source,
<span class="line-modified">1231                GMainContext *context,</span>
<span class="line-modified">1232                gboolean      have_lock)</span>
1233 {
1234   TRACE (GLIB_MAIN_SOURCE_DESTROY (g_source_get_name (source), source,
1235                                    context));
1236 
1237   if (!have_lock)
1238     LOCK_CONTEXT (context);
1239 
1240   if (!SOURCE_DESTROYED (source))
1241     {
1242       GSList *tmp_list;
1243       gpointer old_cb_data;
1244       GSourceCallbackFuncs *old_cb_funcs;
1245 
1246       source-&gt;flags &amp;= ~G_HOOK_FLAG_ACTIVE;
1247 
1248       old_cb_data = source-&gt;callback_data;
1249       old_cb_funcs = source-&gt;callback_funcs;
1250 
1251       source-&gt;callback_data = NULL;
1252       source-&gt;callback_funcs = NULL;
1253 
1254       if (old_cb_funcs)
<span class="line-modified">1255     {</span>
<span class="line-modified">1256       UNLOCK_CONTEXT (context);</span>
<span class="line-modified">1257       old_cb_funcs-&gt;unref (old_cb_data);</span>
<span class="line-modified">1258       LOCK_CONTEXT (context);</span>
<span class="line-modified">1259     }</span>
1260 
1261       if (!SOURCE_BLOCKED (source))
<span class="line-modified">1262     {</span>
<span class="line-modified">1263       tmp_list = source-&gt;poll_fds;</span>
<span class="line-modified">1264       while (tmp_list)</span>
<span class="line-modified">1265         {</span>
<span class="line-modified">1266           g_main_context_remove_poll_unlocked (context, tmp_list-&gt;data);</span>
<span class="line-modified">1267           tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">1268         }</span>
1269 
1270           for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
1271             g_main_context_remove_poll_unlocked (context, tmp_list-&gt;data);
<span class="line-modified">1272     }</span>
1273 
1274       while (source-&gt;priv-&gt;child_sources)
1275         g_child_source_remove_internal (source-&gt;priv-&gt;child_sources-&gt;data, context);
1276 
1277       if (source-&gt;priv-&gt;parent_source)
1278         g_child_source_remove_internal (source, context);
1279 
1280       g_source_unref_internal (source, context, TRUE);
1281     }
1282 
1283   if (!have_lock)
1284     UNLOCK_CONTEXT (context);
1285 }
1286 
1287 /**
1288  * g_source_destroy:
1289  * @source: a #GSource
1290  *
1291  * Removes a source from its #GMainContext, if any, and mark it as
1292  * destroyed.  The source cannot be subsequently added to another
1293  * context. It is safe to call this on sources which have already been
1294  * removed from their context.
<span class="line-modified">1295  **/</span>



1296 void
1297 g_source_destroy (GSource *source)
1298 {
1299   GMainContext *context;
1300 
1301   g_return_if_fail (source != NULL);
1302 
1303   context = source-&gt;context;
1304 
1305   if (context)
1306     g_source_destroy_internal (source, context, FALSE);
1307   else
1308     source-&gt;flags &amp;= ~G_HOOK_FLAG_ACTIVE;
1309 }
1310 
1311 /**
1312  * g_source_get_id:
1313  * @source: a #GSource
1314  *
1315  * Returns the numeric ID for a particular source. The ID of a source
</pre>
<hr />
<pre>
1368  * g_source_add_poll:
1369  * @source:a #GSource
1370  * @fd: a #GPollFD structure holding information about a file
1371  *      descriptor to watch.
1372  *
1373  * Adds a file descriptor to the set of file descriptors polled for
1374  * this source. This is usually combined with g_source_new() to add an
1375  * event source. The event source&#39;s check function will typically test
1376  * the @revents field in the #GPollFD struct and return %TRUE if events need
1377  * to be processed.
1378  *
1379  * This API is only intended to be used by implementations of #GSource.
1380  * Do not call this API on a #GSource that you did not create.
1381  *
1382  * Using this API forces the linear scanning of event sources on each
1383  * main loop iteration.  Newly-written event sources should try to use
1384  * g_source_add_unix_fd() instead of this API.
1385  **/
1386 void
1387 g_source_add_poll (GSource *source,
<span class="line-modified">1388            GPollFD *fd)</span>
1389 {
1390   GMainContext *context;
1391 
1392   g_return_if_fail (source != NULL);
1393   g_return_if_fail (fd != NULL);
1394   g_return_if_fail (!SOURCE_DESTROYED (source));
1395 
1396 #ifdef GSTREAMER_LITE
1397   if (source == NULL)
1398     return;
1399 #endif // GSTREAMER_LITE
1400 
1401   context = source-&gt;context;
1402 
1403   if (context)
1404     LOCK_CONTEXT (context);
1405 
1406   source-&gt;poll_fds = g_slist_prepend (source-&gt;poll_fds, fd);
1407 
1408   if (context)
1409     {
1410       if (!SOURCE_BLOCKED (source))
<span class="line-modified">1411     g_main_context_add_poll_unlocked (context, source-&gt;priority, fd);</span>
1412       UNLOCK_CONTEXT (context);
1413     }
1414 }
1415 
1416 /**
1417  * g_source_remove_poll:
1418  * @source:a #GSource
1419  * @fd: a #GPollFD structure previously passed to g_source_add_poll().
1420  *
1421  * Removes a file descriptor from the set of file descriptors polled for
1422  * this source.
1423  *
1424  * This API is only intended to be used by implementations of #GSource.
1425  * Do not call this API on a #GSource that you did not create.
1426  **/
1427 void
1428 g_source_remove_poll (GSource *source,
<span class="line-modified">1429               GPollFD *fd)</span>
1430 {
1431   GMainContext *context;
1432 
1433   g_return_if_fail (source != NULL);
1434   g_return_if_fail (fd != NULL);
1435   g_return_if_fail (!SOURCE_DESTROYED (source));
1436 
1437   context = source-&gt;context;
1438 
1439   if (context)
1440     LOCK_CONTEXT (context);
1441 
1442   source-&gt;poll_fds = g_slist_remove (source-&gt;poll_fds, fd);
1443 
1444   if (context)
1445     {
1446       if (!SOURCE_BLOCKED (source))
<span class="line-modified">1447     g_main_context_remove_poll_unlocked (context, fd);</span>
1448       UNLOCK_CONTEXT (context);
1449     }
1450 }
1451 
1452 /**
1453  * g_source_add_child_source:
1454  * @source:a #GSource
1455  * @child_source: a second #GSource that @source should &quot;poll&quot;
1456  *
1457  * Adds @child_source to @source as a &quot;polled&quot; source; when @source is
1458  * added to a #GMainContext, @child_source will be automatically added
1459  * with the same priority, when @child_source is triggered, it will
1460  * cause @source to dispatch (in addition to calling its own
1461  * callback), and when @source is destroyed, it will destroy
1462  * @child_source as well. (@source will also still be dispatched if
1463  * its own prepare/check functions indicate that it is ready.)
1464  *
1465  * If you don&#39;t need @child_source to do anything on its own when it
1466  * triggers, you can call g_source_set_dummy_callback() on it to set a
1467  * callback that does nothing (except return %TRUE if appropriate).
1468  *
1469  * @source will hold a reference on @child_source while @child_source
1470  * is attached to it.
1471  *
1472  * This API is only intended to be used by implementations of #GSource.
1473  * Do not call this API on a #GSource that you did not create.
1474  *
1475  * Since: 2.28
1476  **/
1477 void
1478 g_source_add_child_source (GSource *source,
<span class="line-modified">1479                GSource *child_source)</span>
1480 {
1481   GMainContext *context;
1482 
1483   g_return_if_fail (source != NULL);
1484   g_return_if_fail (child_source != NULL);
1485   g_return_if_fail (!SOURCE_DESTROYED (source));
1486   g_return_if_fail (!SOURCE_DESTROYED (child_source));
1487   g_return_if_fail (child_source-&gt;context == NULL);
1488   g_return_if_fail (child_source-&gt;priv-&gt;parent_source == NULL);
1489 
1490   context = source-&gt;context;
1491 
1492   if (context)
1493     LOCK_CONTEXT (context);
1494 
1495   TRACE (GLIB_SOURCE_ADD_CHILD_SOURCE (source, child_source));
1496 
1497   source-&gt;priv-&gt;child_sources = g_slist_prepend (source-&gt;priv-&gt;child_sources,
<span class="line-modified">1498                          g_source_ref (child_source));</span>
1499   child_source-&gt;priv-&gt;parent_source = source;
1500   g_source_set_priority_unlocked (child_source, NULL, source-&gt;priority);
1501   if (SOURCE_BLOCKED (source))
1502     block_source (child_source);
1503 
1504   if (context)
1505     {
1506       g_source_attach_unlocked (child_source, context, TRUE);
1507       UNLOCK_CONTEXT (context);
1508     }
1509 }
1510 
1511 static void
1512 g_child_source_remove_internal (GSource *child_source,
1513                                 GMainContext *context)
1514 {
1515   GSource *parent_source = child_source-&gt;priv-&gt;parent_source;
1516 
1517   parent_source-&gt;priv-&gt;child_sources =
1518     g_slist_remove (parent_source-&gt;priv-&gt;child_sources, child_source);
</pre>
<hr />
<pre>
1520 
1521   g_source_destroy_internal (child_source, context, TRUE);
1522   g_source_unref_internal (child_source, context, TRUE);
1523 }
1524 
1525 /**
1526  * g_source_remove_child_source:
1527  * @source:a #GSource
1528  * @child_source: a #GSource previously passed to
1529  *     g_source_add_child_source().
1530  *
1531  * Detaches @child_source from @source and destroys it.
1532  *
1533  * This API is only intended to be used by implementations of #GSource.
1534  * Do not call this API on a #GSource that you did not create.
1535  *
1536  * Since: 2.28
1537  **/
1538 void
1539 g_source_remove_child_source (GSource *source,
<span class="line-modified">1540                   GSource *child_source)</span>
1541 {
1542   GMainContext *context;
1543 
1544   g_return_if_fail (source != NULL);
1545   g_return_if_fail (child_source != NULL);
1546   g_return_if_fail (child_source-&gt;priv-&gt;parent_source == source);
1547   g_return_if_fail (!SOURCE_DESTROYED (source));
1548   g_return_if_fail (!SOURCE_DESTROYED (child_source));
1549 
1550   context = source-&gt;context;
1551 
1552   if (context)
1553     LOCK_CONTEXT (context);
1554 
1555   g_child_source_remove_internal (child_source, context);
1556 
1557   if (context)
1558     UNLOCK_CONTEXT (context);
1559 }
1560 
</pre>
<hr />
<pre>
1564   GSourceCallback *callback = cb_data;
1565 
1566   g_atomic_int_inc (&amp;callback-&gt;ref_count);
1567 }
1568 
1569 static void
1570 g_source_callback_unref (gpointer cb_data)
1571 {
1572   GSourceCallback *callback = cb_data;
1573 
1574   if (g_atomic_int_dec_and_test (&amp;callback-&gt;ref_count))
1575     {
1576       if (callback-&gt;notify)
1577         callback-&gt;notify (callback-&gt;data);
1578       g_free (callback);
1579     }
1580 }
1581 
1582 static void
1583 g_source_callback_get (gpointer     cb_data,
<span class="line-modified">1584                GSource     *source,</span>
<span class="line-modified">1585                GSourceFunc *func,</span>
<span class="line-modified">1586                gpointer    *data)</span>
1587 {
1588   GSourceCallback *callback = cb_data;
1589 
1590   *func = callback-&gt;func;
1591   *data = callback-&gt;data;
1592 }
1593 
1594 static GSourceCallbackFuncs g_source_callback_funcs = {
1595   g_source_callback_ref,
1596   g_source_callback_unref,
1597   g_source_callback_get,
1598 };
1599 
1600 /**
1601  * g_source_set_callback_indirect:
1602  * @source: the source
1603  * @callback_data: pointer to callback data &quot;object&quot;
1604  * @callback_funcs: functions for reference counting @callback_data
1605  *                  and getting the callback and data
1606  *
1607  * Sets the callback function storing the data as a refcounted callback
1608  * &quot;object&quot;. This is used internally. Note that calling
1609  * g_source_set_callback_indirect() assumes
1610  * an initial reference count on @callback_data, and thus
1611  * @callback_funcs-&gt;unref will eventually be called once more
1612  * than @callback_funcs-&gt;ref.




1613  **/
1614 void
1615 g_source_set_callback_indirect (GSource              *source,
<span class="line-modified">1616                 gpointer              callback_data,</span>
<span class="line-modified">1617                 GSourceCallbackFuncs *callback_funcs)</span>
1618 {
1619   GMainContext *context;
1620   gpointer old_cb_data;
1621   GSourceCallbackFuncs *old_cb_funcs;
1622 
1623   g_return_if_fail (source != NULL);
1624   g_return_if_fail (callback_funcs != NULL || callback_data == NULL);
1625 
1626   context = source-&gt;context;
1627 
1628   if (context)
1629     LOCK_CONTEXT (context);
1630 
1631   if (callback_funcs != &amp;g_source_callback_funcs)
<span class="line-modified">1632     TRACE (GLIB_SOURCE_SET_CALLBACK_INDIRECT (source, callback_data,</span>
<span class="line-modified">1633                                               callback_funcs-&gt;ref,</span>
<span class="line-modified">1634                                               callback_funcs-&gt;unref,</span>
<span class="line-modified">1635                                               callback_funcs-&gt;get));</span>


1636 
1637   old_cb_data = source-&gt;callback_data;
1638   old_cb_funcs = source-&gt;callback_funcs;
1639 
1640   source-&gt;callback_data = callback_data;
1641   source-&gt;callback_funcs = callback_funcs;
1642 
1643   if (context)
1644     UNLOCK_CONTEXT (context);
1645 
1646   if (old_cb_funcs)
1647     old_cb_funcs-&gt;unref (old_cb_data);
1648 }
1649 
1650 /**
1651  * g_source_set_callback:
1652  * @source: the source
1653  * @func: a callback function
1654  * @data: the data to pass to callback function
1655  * @notify: (nullable): a function to call when @data is no longer in use, or %NULL.
1656  *
1657  * Sets the callback function for a source. The callback for a source is
1658  * called from the source&#39;s dispatch function.
1659  *
1660  * The exact type of @func depends on the type of source; ie. you
1661  * should not count on @func being called with @data as its first
1662  * parameter. Cast @func with G_SOURCE_FUNC() to avoid warnings about
1663  * incompatible function types.
1664  *
1665  * See [memory management of sources][mainloop-memory-management] for details
1666  * on how to handle memory management of @data.
1667  *
1668  * Typically, you won&#39;t use this function. Instead use functions specific
<span class="line-modified">1669  * to the type of source you are using.</span>




1670  **/
1671 void
1672 g_source_set_callback (GSource        *source,
<span class="line-modified">1673                GSourceFunc     func,</span>
<span class="line-modified">1674                gpointer        data,</span>
<span class="line-modified">1675                GDestroyNotify  notify)</span>
1676 {
1677   GSourceCallback *new_callback;
1678 
1679   g_return_if_fail (source != NULL);
1680 #ifdef GSTREAMER_LITE
1681   if (source == NULL)
1682     return;
1683 #endif // GSTREAMER_LITE
1684 
1685   TRACE (GLIB_SOURCE_SET_CALLBACK (source, func, data, notify));
1686 
1687   new_callback = g_new (GSourceCallback, 1);
1688 
1689   new_callback-&gt;ref_count = 1;
1690   new_callback-&gt;func = func;
1691   new_callback-&gt;data = data;
1692   new_callback-&gt;notify = notify;
1693 
1694   g_source_set_callback_indirect (source, new_callback, &amp;g_source_callback_funcs);
1695 }
1696 
1697 
1698 /**
1699  * g_source_set_funcs:
1700  * @source: a #GSource
1701  * @funcs: the new #GSourceFuncs
1702  *
1703  * Sets the source functions (can be used to override
1704  * default implementations) of an unattached source.
1705  *
1706  * Since: 2.12
1707  */
1708 void
1709 g_source_set_funcs (GSource     *source,
<span class="line-modified">1710                GSourceFuncs *funcs)</span>
1711 {
1712   g_return_if_fail (source != NULL);
1713   g_return_if_fail (source-&gt;context == NULL);
<span class="line-modified">1714   g_return_if_fail (source-&gt;ref_count &gt; 0);</span>
1715   g_return_if_fail (funcs != NULL);
1716 
1717   source-&gt;source_funcs = funcs;
1718 }
1719 
1720 static void
1721 g_source_set_priority_unlocked (GSource      *source,
<span class="line-modified">1722                 GMainContext *context,</span>
<span class="line-modified">1723                 gint          priority)</span>
1724 {
1725   GSList *tmp_list;
1726 
1727 #ifdef GSTREAMER_LITE
1728   if (source == NULL || source-&gt;priv == NULL || source-&gt;priv-&gt;parent_source == NULL)
1729     return;
1730 
1731   if (context == NULL)
1732     return;
1733 #endif // GSTREAMER_LITE
1734 
1735   g_return_if_fail (source-&gt;priv-&gt;parent_source == NULL ||
<span class="line-modified">1736             source-&gt;priv-&gt;parent_source-&gt;priority == priority);</span>
1737 
1738   TRACE (GLIB_SOURCE_SET_PRIORITY (source, context, priority));
1739 
1740   if (context)
1741     {
1742       /* Remove the source from the context&#39;s source and then
1743        * add it back after so it is sorted in the correct place
1744        */
1745       source_remove_from_context (source, source-&gt;context);
1746     }
1747 
1748   source-&gt;priority = priority;
1749 
1750   if (context)
1751     {
1752       source_add_to_context (source, source-&gt;context);
1753 
1754       if (!SOURCE_BLOCKED (source))
<span class="line-modified">1755     {</span>
<span class="line-modified">1756       tmp_list = source-&gt;poll_fds;</span>
<span class="line-modified">1757       while (tmp_list)</span>
<span class="line-modified">1758         {</span>
<span class="line-modified">1759           g_main_context_remove_poll_unlocked (context, tmp_list-&gt;data);</span>
<span class="line-modified">1760           g_main_context_add_poll_unlocked (context, priority, tmp_list-&gt;data);</span>
1761 
<span class="line-modified">1762           tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">1763         }</span>
1764 
1765           for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
1766             {
1767               g_main_context_remove_poll_unlocked (context, tmp_list-&gt;data);
1768               g_main_context_add_poll_unlocked (context, priority, tmp_list-&gt;data);
1769             }
<span class="line-modified">1770     }</span>
1771     }
1772 
1773   if (source-&gt;priv-&gt;child_sources)
1774     {
1775       tmp_list = source-&gt;priv-&gt;child_sources;
1776       while (tmp_list)
<span class="line-modified">1777     {</span>
<span class="line-modified">1778       g_source_set_priority_unlocked (tmp_list-&gt;data, context, priority);</span>
<span class="line-modified">1779       tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">1780     }</span>
1781     }
1782 }
1783 
1784 /**
1785  * g_source_set_priority:
1786  * @source: a #GSource
1787  * @priority: the new priority.
1788  *
1789  * Sets the priority of a source. While the main loop is being run, a
1790  * source will be dispatched if it is ready to be dispatched and no
1791  * sources at a higher (numerically smaller) priority are ready to be
1792  * dispatched.
1793  *
1794  * A child source always has the same priority as its parent.  It is not
1795  * permitted to change the priority of a source once it has been added
1796  * as a child of another source.
1797  **/
1798 void
1799 g_source_set_priority (GSource  *source,
<span class="line-modified">1800                gint      priority)</span>
1801 {
1802   GMainContext *context;
1803 
1804 #ifdef GSTREAMER_LITE
1805   if (source == NULL || source-&gt;priv == NULL || source-&gt;priv-&gt;parent_source == NULL)
1806     return;
1807 #endif // GSTREAMER_LITE
1808 
1809   g_return_if_fail (source != NULL);
1810   g_return_if_fail (source-&gt;priv-&gt;parent_source == NULL);
1811 
1812   context = source-&gt;context;
1813 
1814   if (context)
1815     LOCK_CONTEXT (context);
1816   g_source_set_priority_unlocked (source, context, priority);
1817   if (context)
1818     UNLOCK_CONTEXT (context);
1819 }
1820 
</pre>
<hr />
<pre>
1928 gint64
1929 g_source_get_ready_time (GSource *source)
1930 {
1931   g_return_val_if_fail (source != NULL, -1);
1932 
1933   return source-&gt;priv-&gt;ready_time;
1934 }
1935 
1936 /**
1937  * g_source_set_can_recurse:
1938  * @source: a #GSource
1939  * @can_recurse: whether recursion is allowed for this source
1940  *
1941  * Sets whether a source can be called recursively. If @can_recurse is
1942  * %TRUE, then while the source is being dispatched then this source
1943  * will be processed normally. Otherwise, all processing of this
1944  * source is blocked until the dispatch function returns.
1945  **/
1946 void
1947 g_source_set_can_recurse (GSource  *source,
<span class="line-modified">1948               gboolean  can_recurse)</span>
1949 {
1950   GMainContext *context;
1951 
1952   g_return_if_fail (source != NULL);
1953 
1954   context = source-&gt;context;
1955 
1956   if (context)
1957     LOCK_CONTEXT (context);
1958 
1959   if (can_recurse)
1960     source-&gt;flags |= G_SOURCE_CAN_RECURSE;
1961   else
1962     source-&gt;flags &amp;= ~G_SOURCE_CAN_RECURSE;
1963 
1964   if (context)
1965     UNLOCK_CONTEXT (context);
1966 }
1967 
1968 /**
</pre>
<hr />
<pre>
2087 
2088   source = g_main_context_find_source_by_id (NULL, tag);
2089   if (source == NULL)
2090     return;
2091 
2092   g_source_set_name (source, name);
2093 }
2094 
2095 
2096 /**
2097  * g_source_ref:
2098  * @source: a #GSource
2099  *
2100  * Increases the reference count on a source by one.
2101  *
2102  * Returns: @source
2103  **/
2104 GSource *
2105 g_source_ref (GSource *source)
2106 {
<span class="line-removed">2107   GMainContext *context;</span>
<span class="line-removed">2108 </span>
2109   g_return_val_if_fail (source != NULL, NULL);
2110 
<span class="line-modified">2111   context = source-&gt;context;</span>
<span class="line-removed">2112 </span>
<span class="line-removed">2113   if (context)</span>
<span class="line-removed">2114     LOCK_CONTEXT (context);</span>
<span class="line-removed">2115 </span>
<span class="line-removed">2116   source-&gt;ref_count++;</span>
<span class="line-removed">2117 </span>
<span class="line-removed">2118   if (context)</span>
<span class="line-removed">2119     UNLOCK_CONTEXT (context);</span>
2120 
2121   return source;
2122 }
2123 
2124 /* g_source_unref() but possible to call within context lock
2125  */
2126 static void
2127 g_source_unref_internal (GSource      *source,
<span class="line-modified">2128              GMainContext *context,</span>
<span class="line-modified">2129              gboolean      have_lock)</span>
2130 {
2131   gpointer old_cb_data = NULL;
2132   GSourceCallbackFuncs *old_cb_funcs = NULL;
2133 
2134   g_return_if_fail (source != NULL);
2135 
2136   if (!have_lock &amp;&amp; context)
2137     LOCK_CONTEXT (context);
2138 
<span class="line-modified">2139   source-&gt;ref_count--;</span>
<span class="line-removed">2140   if (source-&gt;ref_count == 0)</span>
2141     {
2142       TRACE (GLIB_SOURCE_BEFORE_FREE (source, context,
2143                                       source-&gt;source_funcs-&gt;finalize));
2144 
2145       old_cb_data = source-&gt;callback_data;
2146       old_cb_funcs = source-&gt;callback_funcs;
2147 
2148       source-&gt;callback_data = NULL;
2149       source-&gt;callback_funcs = NULL;
2150 
2151       if (context)
<span class="line-modified">2152     {</span>
<span class="line-modified">2153       if (!SOURCE_DESTROYED (source))</span>
<span class="line-modified">2154         g_warning (G_STRLOC &quot;: ref_count == 0, but source was still attached to a context!&quot;);</span>
<span class="line-modified">2155       source_remove_from_context (source, context);</span>
2156 
2157           g_hash_table_remove (context-&gt;sources, GUINT_TO_POINTER (source-&gt;source_id));
<span class="line-modified">2158     }</span>
2159 
2160       if (source-&gt;source_funcs-&gt;finalize)
<span class="line-modified">2161     {</span>
2162           /* Temporarily increase the ref count again so that GSource methods
2163            * can be called from finalize(). */
<span class="line-modified">2164           source-&gt;ref_count++;</span>
<span class="line-modified">2165       if (context)</span>
<span class="line-modified">2166         UNLOCK_CONTEXT (context);</span>
<span class="line-modified">2167       source-&gt;source_funcs-&gt;finalize (source);</span>
<span class="line-modified">2168       if (context)</span>
<span class="line-modified">2169         LOCK_CONTEXT (context);</span>
<span class="line-modified">2170           source-&gt;ref_count--;</span>
<span class="line-modified">2171     }</span>
2172 
2173       if (old_cb_funcs)
2174         {
2175           /* Temporarily increase the ref count again so that GSource methods
2176            * can be called from callback_funcs.unref(). */
<span class="line-modified">2177           source-&gt;ref_count++;</span>
2178           if (context)
2179             UNLOCK_CONTEXT (context);
2180 
2181           old_cb_funcs-&gt;unref (old_cb_data);
2182 
2183           if (context)
2184             LOCK_CONTEXT (context);
<span class="line-modified">2185           source-&gt;ref_count--;</span>
2186         }
2187 
2188       g_free (source-&gt;name);
2189       source-&gt;name = NULL;
2190 
2191       g_slist_free (source-&gt;poll_fds);
2192       source-&gt;poll_fds = NULL;
2193 
2194       g_slist_free_full (source-&gt;priv-&gt;fds, g_free);
2195 
2196       while (source-&gt;priv-&gt;child_sources)
2197         {
2198           GSource *child_source = source-&gt;priv-&gt;child_sources-&gt;data;
2199 
2200           source-&gt;priv-&gt;child_sources =
2201             g_slist_remove (source-&gt;priv-&gt;child_sources, child_source);
2202           child_source-&gt;priv-&gt;parent_source = NULL;
2203 
2204           g_source_unref_internal (child_source, context, have_lock);
2205         }
2206 
2207       g_slice_free (GSourcePrivate, source-&gt;priv);
2208       source-&gt;priv = NULL;
2209 
2210       g_free (source);
2211     }
2212 
2213   if (!have_lock &amp;&amp; context)
2214     UNLOCK_CONTEXT (context);
<span class="line-modified">2215     }</span>
2216 
2217 /**
2218  * g_source_unref:
2219  * @source: a #GSource
2220  *
2221  * Decreases the reference count of a source by one. If the
2222  * resulting reference count is zero the source and associated
2223  * memory will be destroyed.
2224  **/
2225 void
2226 g_source_unref (GSource *source)
2227 {
2228   g_return_if_fail (source != NULL);
2229 #ifdef GSTREAMER_LITE
2230   if (source == NULL)
2231     return;
2232 #endif // GSTREAMER_LITE
2233 
2234   g_source_unref_internal (source, source-&gt;context, FALSE);
2235 }
2236 
2237 /**
2238  * g_main_context_find_source_by_id:
2239  * @context: (nullable): a #GMainContext (if %NULL, the default context will be used)
2240  * @source_id: the source ID, as returned by g_source_get_id().
2241  *
2242  * Finds a #GSource given a pair of context and ID.
2243  *
<span class="line-modified">2244  * It is a programmer error to attempt to lookup a non-existent source.</span>
2245  *
2246  * More specifically: source IDs can be reissued after a source has been
2247  * destroyed and therefore it is never valid to use this function with a
2248  * source ID which may have already been removed.  An example is when
2249  * scheduling an idle to run in another thread with g_idle_add(): the
2250  * idle may already have run and been removed by the time this function
2251  * is called on its (now invalid) source ID.  This source ID may have
2252  * been reissued, leading to the operation being performed against the
2253  * wrong source.
2254  *
2255  * Returns: (transfer none): the #GSource
2256  **/
2257 GSource *
2258 g_main_context_find_source_by_id (GMainContext *context,
2259                                   guint         source_id)
2260 {
2261   GSource *source;
2262 
2263   g_return_val_if_fail (source_id &gt; 0, NULL);
2264 
</pre>
<hr />
<pre>
2272   if (source &amp;&amp; SOURCE_DESTROYED (source))
2273     source = NULL;
2274 
2275   return source;
2276 }
2277 
2278 /**
2279  * g_main_context_find_source_by_funcs_user_data:
2280  * @context: (nullable): a #GMainContext (if %NULL, the default context will be used).
2281  * @funcs: the @source_funcs passed to g_source_new().
2282  * @user_data: the user data from the callback.
2283  *
2284  * Finds a source with the given source functions and user data.  If
2285  * multiple sources exist with the same source function and user data,
2286  * the first one found will be returned.
2287  *
2288  * Returns: (transfer none): the source, if one was found, otherwise %NULL
2289  **/
2290 GSource *
2291 g_main_context_find_source_by_funcs_user_data (GMainContext *context,
<span class="line-modified">2292                            GSourceFuncs *funcs,</span>
<span class="line-modified">2293                            gpointer      user_data)</span>
2294 {
2295   GSourceIter iter;
2296   GSource *source;
2297 
2298   g_return_val_if_fail (funcs != NULL, NULL);
2299 
2300   if (context == NULL)
2301     context = g_main_context_default ();
2302 
2303   LOCK_CONTEXT (context);
2304 
2305   g_source_iter_init (&amp;iter, context, FALSE);
2306   while (g_source_iter_next (&amp;iter, &amp;source))
2307     {
2308       if (!SOURCE_DESTROYED (source) &amp;&amp;
<span class="line-modified">2309       source-&gt;source_funcs == funcs &amp;&amp;</span>
<span class="line-modified">2310       source-&gt;callback_funcs)</span>
<span class="line-modified">2311     {</span>
<span class="line-modified">2312       GSourceFunc callback;</span>
<span class="line-modified">2313       gpointer callback_data;</span>
2314 
<span class="line-modified">2315       source-&gt;callback_funcs-&gt;get (source-&gt;callback_data, source, &amp;callback, &amp;callback_data);</span>
2316 
<span class="line-modified">2317       if (callback_data == user_data)</span>
<span class="line-modified">2318         break;</span>
<span class="line-modified">2319     }</span>
2320     }
2321   g_source_iter_clear (&amp;iter);
2322 
2323   UNLOCK_CONTEXT (context);
2324 
2325   return source;
2326 }
2327 
2328 /**
2329  * g_main_context_find_source_by_user_data:
2330  * @context: a #GMainContext
2331  * @user_data: the user_data for the callback.
2332  *
2333  * Finds a source with the given user data for the callback.  If
2334  * multiple sources exist with the same user data, the first
2335  * one found will be returned.
2336  *
2337  * Returns: (transfer none): the source, if one was found, otherwise %NULL
2338  **/
2339 GSource *
2340 g_main_context_find_source_by_user_data (GMainContext *context,
<span class="line-modified">2341                      gpointer      user_data)</span>
2342 {
2343   GSourceIter iter;
2344   GSource *source;
2345 
2346   if (context == NULL)
2347     context = g_main_context_default ();
2348 
2349   LOCK_CONTEXT (context);
2350 
2351   g_source_iter_init (&amp;iter, context, FALSE);
2352   while (g_source_iter_next (&amp;iter, &amp;source))
2353     {
2354       if (!SOURCE_DESTROYED (source) &amp;&amp;
<span class="line-modified">2355       source-&gt;callback_funcs)</span>
<span class="line-modified">2356     {</span>
<span class="line-modified">2357       GSourceFunc callback;</span>
<span class="line-modified">2358       gpointer callback_data = NULL;</span>
2359 
<span class="line-modified">2360       source-&gt;callback_funcs-&gt;get (source-&gt;callback_data, source, &amp;callback, &amp;callback_data);</span>
2361 
<span class="line-modified">2362       if (callback_data == user_data)</span>
<span class="line-modified">2363         break;</span>
<span class="line-modified">2364     }</span>
2365     }
2366   g_source_iter_clear (&amp;iter);
2367 
2368   UNLOCK_CONTEXT (context);
2369 
2370   return source;
2371 }
2372 
2373 /**
2374  * g_source_remove:
2375  * @tag: the ID of the source to remove.
2376  *
2377  * Removes the source with the given ID from the default main context. You must
2378  * use g_source_destroy() for sources added to a non-default main context.
2379  *
2380  * The ID of a #GSource is given by g_source_get_id(), or will be
2381  * returned by the functions g_source_attach(), g_idle_add(),
2382  * g_idle_add_full(), g_timeout_add(), g_timeout_add_full(),
2383  * g_child_watch_add(), g_child_watch_add_full(), g_io_add_watch(), and
2384  * g_io_add_watch_full().
</pre>
<hr />
<pre>
2433       g_source_destroy (source);
2434       return TRUE;
2435     }
2436   else
2437     return FALSE;
2438 }
2439 
2440 /**
2441  * g_source_remove_by_funcs_user_data:
2442  * @funcs: The @source_funcs passed to g_source_new()
2443  * @user_data: the user data for the callback
2444  *
2445  * Removes a source from the default main loop context given the
2446  * source functions and user data. If multiple sources exist with the
2447  * same source functions and user data, only one will be destroyed.
2448  *
2449  * Returns: %TRUE if a source was found and removed.
2450  **/
2451 gboolean
2452 g_source_remove_by_funcs_user_data (GSourceFuncs *funcs,
<span class="line-modified">2453                     gpointer      user_data)</span>
2454 {
2455   GSource *source;
2456 
2457   g_return_val_if_fail (funcs != NULL, FALSE);
2458 
2459   source = g_main_context_find_source_by_funcs_user_data (NULL, funcs, user_data);
2460   if (source)
2461     {
2462       g_source_destroy (source);
2463       return TRUE;
2464     }
2465   else
2466     return FALSE;
2467 }
2468 
2469 /**
2470  * g_clear_handle_id: (skip)
2471  * @tag_ptr: (not nullable): a pointer to the handler ID
2472  * @clear_func: (not nullable): the function to call to clear the handler
2473  *
</pre>
<hr />
<pre>
2669                         gpointer  tag)
2670 {
2671   GPollFD *poll_fd;
2672 
2673   g_return_val_if_fail (source != NULL, 0);
2674   g_return_val_if_fail (g_slist_find (source-&gt;priv-&gt;fds, tag), 0);
2675 
2676   poll_fd = tag;
2677 
2678   return poll_fd-&gt;revents;
2679 }
2680 #endif /* G_OS_UNIX */
2681 
2682 /**
2683  * g_get_current_time:
2684  * @result: #GTimeVal structure in which to store current time.
2685  *
2686  * Equivalent to the UNIX gettimeofday() function, but portable.
2687  *
2688  * You may find g_get_real_time() to be more convenient.



2689  **/

2690 void
2691 g_get_current_time (GTimeVal *result)
2692 {
<span class="line-modified">2693 #ifndef G_OS_WIN32</span>
<span class="line-removed">2694   struct timeval r;</span>
<span class="line-removed">2695 </span>
<span class="line-removed">2696   g_return_if_fail (result != NULL);</span>
<span class="line-removed">2697 </span>
<span class="line-removed">2698   /*this is required on alpha, there the timeval structs are int&#39;s</span>
<span class="line-removed">2699     not longs and a cast only would fail horribly*/</span>
<span class="line-removed">2700   gettimeofday (&amp;r, NULL);</span>
<span class="line-removed">2701   result-&gt;tv_sec = r.tv_sec;</span>
<span class="line-removed">2702   result-&gt;tv_usec = r.tv_usec;</span>
<span class="line-removed">2703 #else</span>
<span class="line-removed">2704   FILETIME ft;</span>
<span class="line-removed">2705   guint64 time64;</span>
2706 
2707   g_return_if_fail (result != NULL);
2708 
<span class="line-modified">2709   GetSystemTimeAsFileTime (&amp;ft);</span>
<span class="line-removed">2710   memmove (&amp;time64, &amp;ft, sizeof (FILETIME));</span>
2711 
<span class="line-modified">2712   /* Convert from 100s of nanoseconds since 1601-01-01</span>
<span class="line-modified">2713    * to Unix epoch. Yes, this is Y2038 unsafe.</span>
<span class="line-removed">2714    */</span>
<span class="line-removed">2715   time64 -= G_GINT64_CONSTANT (116444736000000000);</span>
<span class="line-removed">2716   time64 /= 10;</span>
<span class="line-removed">2717 </span>
<span class="line-removed">2718   result-&gt;tv_sec = time64 / 1000000;</span>
<span class="line-removed">2719   result-&gt;tv_usec = time64 % 1000000;</span>
<span class="line-removed">2720 #endif</span>
2721 }

2722 
2723 /**
2724  * g_get_real_time:
2725  *
2726  * Queries the system wall-clock time.
2727  *
2728  * This call is functionally equivalent to g_get_current_time() except
2729  * that the return value is often more convenient than dealing with a
2730  * #GTimeVal.
2731  *
2732  * You should only use this call if you are actually interested in the real
2733  * wall-clock time.  g_get_monotonic_time() is probably more useful for
2734  * measuring intervals.
2735  *
2736  * Returns: the number of microseconds since January 1, 1970 UTC.
2737  *
2738  * Since: 2.28
2739  **/
2740 gint64
2741 g_get_real_time (void)
2742 {
<span class="line-modified">2743   GTimeVal tv;</span>

2744 
<span class="line-modified">2745   g_get_current_time (&amp;tv);</span>


2746 
<span class="line-modified">2747   return (((gint64) tv.tv_sec) * 1000000) + tv.tv_usec;</span>















2748 }
2749 
2750 /**
2751  * g_get_monotonic_time:
2752  *
2753  * Queries the system monotonic time.
2754  *
2755  * The monotonic clock will always increase and doesn&#39;t suffer
2756  * discontinuities when the user (or NTP) changes the system time.  It
2757  * may or may not continue to tick during times where the machine is
2758  * suspended.
2759  *
2760  * We try to use the clock that corresponds as closely as possible to
2761  * the passage of time as measured by system calls such as poll() but it
2762  * may not always be possible to do this.
2763  *
2764  * Returns: the monotonic time, in microseconds
2765  *
2766  * Since: 2.28
2767  **/
2768 #if defined (G_OS_WIN32)
2769 /* NOTE:
2770  * time_usec = ticks_since_boot * usec_per_sec / ticks_per_sec
2771  *
2772  * Doing (ticks_since_boot * usec_per_sec) before the division can overflow 64 bits
2773  * (ticks_since_boot  / ticks_per_sec) and then multiply would not be accurate enough.
2774  * So for now we calculate (usec_per_sec / ticks_per_sec) and use floating point
2775  */
2776 static gdouble g_monotonic_usec_per_tick = 0;
2777 
2778 void
2779 g_clock_win32_init (void)
2780 {
2781   LARGE_INTEGER freq;
2782 
2783   if (!QueryPerformanceFrequency (&amp;freq) || freq.QuadPart == 0)
2784     {
2785       /* The documentation says that this should never happen */
2786       g_assert_not_reached ();
2787       return;
<span class="line-modified">2788 }</span>
2789 
2790   g_monotonic_usec_per_tick = (gdouble)G_USEC_PER_SEC / freq.QuadPart;
2791 }
2792 
2793 gint64
2794 g_get_monotonic_time (void)
2795 {
2796   if (G_LIKELY (g_monotonic_usec_per_tick != 0))
2797     {
2798       LARGE_INTEGER ticks;
2799 
2800       if (QueryPerformanceCounter (&amp;ticks))
2801         return (gint64)(ticks.QuadPart * g_monotonic_usec_per_tick);
2802 
2803       g_warning (&quot;QueryPerformanceCounter Failed (%lu)&quot;, GetLastError ());
2804       g_monotonic_usec_per_tick = 0;
2805     }
2806 
2807   return 0;
<span class="line-modified">2808         }</span>
2809 #elif defined(HAVE_MACH_MACH_TIME_H) /* Mac OS */
2810 gint64
2811 g_get_monotonic_time (void)
2812 {
2813   static mach_timebase_info_data_t timebase_info;
2814 
2815   if (timebase_info.denom == 0)
2816     {
2817       /* This is a fraction that we must use to scale
2818        * mach_absolute_time() by in order to reach nanoseconds.
2819        *
2820        * We&#39;ve only ever observed this to be 1/1, but maybe it could be
2821        * 1000/1 if mach time is microseconds already, or 1/1000 if
2822        * picoseconds.  Try to deal nicely with that.
2823        */
2824       mach_timebase_info (&amp;timebase_info);
2825 
2826       /* We actually want microseconds... */
2827       if (timebase_info.numer % 1000 == 0)
2828         timebase_info.numer /= 1000;
</pre>
<hr />
<pre>
2854 }
2855 #else
2856 gint64
2857 g_get_monotonic_time (void)
2858 {
2859   struct timespec ts;
2860   gint result;
2861 
2862   result = clock_gettime (CLOCK_MONOTONIC, &amp;ts);
2863 
2864   if G_UNLIKELY (result != 0)
2865     g_error (&quot;GLib requires working CLOCK_MONOTONIC&quot;);
2866 
2867   return (((gint64) ts.tv_sec) * 1000000) + (ts.tv_nsec / 1000);
2868 }
2869 #endif
2870 
2871 static void
2872 g_main_dispatch_free (gpointer dispatch)
2873 {
<span class="line-modified">2874   g_slice_free (GMainDispatch, dispatch);</span>
2875 }
2876 
2877 /* Running the main loop */
2878 
2879 static GMainDispatch *
2880 get_dispatch (void)
2881 {
2882   static GPrivate depth_private = G_PRIVATE_INIT (g_main_dispatch_free);
2883   GMainDispatch *dispatch;
2884 
2885   dispatch = g_private_get (&amp;depth_private);
2886 
2887   if (!dispatch)
<span class="line-modified">2888     {</span>
<span class="line-removed">2889       dispatch = g_slice_new0 (GMainDispatch);</span>
<span class="line-removed">2890       g_private_set (&amp;depth_private, dispatch);</span>
<span class="line-removed">2891     }</span>
2892 
2893   return dispatch;
2894 }
2895 
2896 /**
2897  * g_main_depth:
2898  *
2899  * Returns the depth of the stack of calls to
2900  * g_main_context_dispatch() on any #GMainContext in the current thread.
2901  *  That is, when called from the toplevel, it gives 0. When
2902  * called from within a callback from g_main_context_iteration()
2903  * (or g_main_loop_run(), etc.) it returns 1. When called from within
2904  * a callback to a recursive call to g_main_context_iteration(),
2905  * it returns 2. And so forth.
2906  *
2907  * This function is useful in a situation like the following:
2908  * Imagine an extremely simple &quot;garbage collected&quot; system.
2909  *
2910  * |[&lt;!-- language=&quot;C&quot; --&gt;
2911  * static GList *free_list;
</pre>
<hr />
<pre>
3118 
3119   source-&gt;flags |= G_SOURCE_BLOCKED;
3120 
3121   if (source-&gt;context)
3122     {
3123       tmp_list = source-&gt;poll_fds;
3124       while (tmp_list)
3125         {
3126           g_main_context_remove_poll_unlocked (source-&gt;context, tmp_list-&gt;data);
3127           tmp_list = tmp_list-&gt;next;
3128         }
3129 
3130       for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
3131         g_main_context_remove_poll_unlocked (source-&gt;context, tmp_list-&gt;data);
3132     }
3133 
3134   if (source-&gt;priv &amp;&amp; source-&gt;priv-&gt;child_sources)
3135     {
3136       tmp_list = source-&gt;priv-&gt;child_sources;
3137       while (tmp_list)
<span class="line-modified">3138     {</span>
<span class="line-modified">3139       block_source (tmp_list-&gt;data);</span>
<span class="line-modified">3140       tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">3141     }</span>
3142     }
3143 }
3144 
3145 /* HOLDS: source-&gt;context&#39;s lock */
3146 static void
3147 unblock_source (GSource *source)
3148 {
3149   GSList *tmp_list;
3150 
3151   g_return_if_fail (SOURCE_BLOCKED (source)); /* Source already unblocked */
3152   g_return_if_fail (!SOURCE_DESTROYED (source));
3153 
3154   source-&gt;flags &amp;= ~G_SOURCE_BLOCKED;
3155 
3156   tmp_list = source-&gt;poll_fds;
3157   while (tmp_list)
3158     {
3159       g_main_context_add_poll_unlocked (source-&gt;context, source-&gt;priority, tmp_list-&gt;data);
3160       tmp_list = tmp_list-&gt;next;
3161     }
3162 
3163   for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
3164     g_main_context_add_poll_unlocked (source-&gt;context, source-&gt;priority, tmp_list-&gt;data);
3165 
3166   if (source-&gt;priv &amp;&amp; source-&gt;priv-&gt;child_sources)
3167     {
3168       tmp_list = source-&gt;priv-&gt;child_sources;
3169       while (tmp_list)
<span class="line-modified">3170     {</span>
<span class="line-modified">3171       unblock_source (tmp_list-&gt;data);</span>
<span class="line-modified">3172       tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">3173     }</span>
3174     }
3175 }
3176 
3177 /* HOLDS: context&#39;s lock */
3178 static void
3179 g_main_dispatch (GMainContext *context)
3180 {
3181   GMainDispatch *current = get_dispatch ();
3182   guint i;
3183 
3184   for (i = 0; i &lt; context-&gt;pending_dispatches-&gt;len; i++)
3185     {
3186       GSource *source = context-&gt;pending_dispatches-&gt;pdata[i];
3187 
3188       context-&gt;pending_dispatches-&gt;pdata[i] = NULL;
3189       g_assert (source);
3190 
3191       source-&gt;flags &amp;= ~G_SOURCE_READY;
3192 
3193       if (!SOURCE_DESTROYED (source))
<span class="line-modified">3194     {</span>
<span class="line-modified">3195       gboolean was_in_call;</span>
<span class="line-modified">3196       gpointer user_data = NULL;</span>
<span class="line-modified">3197       GSourceFunc callback = NULL;</span>
<span class="line-modified">3198       GSourceCallbackFuncs *cb_funcs;</span>
<span class="line-modified">3199       gpointer cb_data;</span>
<span class="line-modified">3200       gboolean need_destroy;</span>
<span class="line-modified">3201 </span>
<span class="line-modified">3202       gboolean (*dispatch) (GSource *,</span>
<span class="line-modified">3203                 GSourceFunc,</span>
<span class="line-modified">3204                 gpointer);</span>
3205           GSource *prev_source;
3206 
<span class="line-modified">3207       dispatch = source-&gt;source_funcs-&gt;dispatch;</span>
<span class="line-modified">3208       cb_funcs = source-&gt;callback_funcs;</span>
<span class="line-modified">3209       cb_data = source-&gt;callback_data;</span>
3210 
<span class="line-modified">3211       if (cb_funcs)</span>
<span class="line-modified">3212         cb_funcs-&gt;ref (cb_data);</span>
3213 
<span class="line-modified">3214       if ((source-&gt;flags &amp; G_SOURCE_CAN_RECURSE) == 0)</span>
<span class="line-modified">3215         block_source (source);</span>
3216 
<span class="line-modified">3217       was_in_call = source-&gt;flags &amp; G_HOOK_FLAG_IN_CALL;</span>
<span class="line-modified">3218       source-&gt;flags |= G_HOOK_FLAG_IN_CALL;</span>
3219 
<span class="line-modified">3220       if (cb_funcs)</span>
<span class="line-modified">3221         cb_funcs-&gt;get (cb_data, source, &amp;callback, &amp;user_data);</span>
3222 
<span class="line-modified">3223       UNLOCK_CONTEXT (context);</span>
3224 
3225           /* These operations are safe because &#39;current&#39; is thread-local
3226            * and not modified from anywhere but this function.
3227            */
3228           prev_source = current-&gt;source;
3229           current-&gt;source = source;
3230           current-&gt;depth++;
3231 
3232           TRACE (GLIB_MAIN_BEFORE_DISPATCH (g_source_get_name (source), source,
3233                                             dispatch, callback, user_data));
3234           need_destroy = !(* dispatch) (source, callback, user_data);
3235           TRACE (GLIB_MAIN_AFTER_DISPATCH (g_source_get_name (source), source,
3236                                            dispatch, need_destroy));
3237 
3238           current-&gt;source = prev_source;
3239           current-&gt;depth--;
3240 
<span class="line-modified">3241       if (cb_funcs)</span>
<span class="line-modified">3242         cb_funcs-&gt;unref (cb_data);</span>
3243 
<span class="line-modified">3244       LOCK_CONTEXT (context);</span>
3245 
<span class="line-modified">3246       if (!was_in_call)</span>
<span class="line-modified">3247         source-&gt;flags &amp;= ~G_HOOK_FLAG_IN_CALL;</span>
3248 
<span class="line-modified">3249       if (SOURCE_BLOCKED (source) &amp;&amp; !SOURCE_DESTROYED (source))</span>
<span class="line-modified">3250         unblock_source (source);</span>
3251 
<span class="line-modified">3252       /* Note: this depends on the fact that we can&#39;t switch</span>
<span class="line-modified">3253        * sources from one main context to another</span>
<span class="line-modified">3254        */</span>
<span class="line-modified">3255       if (need_destroy &amp;&amp; !SOURCE_DESTROYED (source))</span>
<span class="line-modified">3256         {</span>
<span class="line-modified">3257           g_assert (source-&gt;context == context);</span>
<span class="line-modified">3258           g_source_destroy_internal (source, context, TRUE);</span>
<span class="line-modified">3259         }</span>
<span class="line-modified">3260     }</span>
3261 
<span class="line-modified">3262       SOURCE_UNREF (source, context);</span>
3263     }
3264 
3265   g_ptr_array_set_size (context-&gt;pending_dispatches, 0);
3266 }
3267 
3268 /**
3269  * g_main_context_acquire:
3270  * @context: a #GMainContext
3271  *
3272  * Tries to become the owner of the specified context.
3273  * If some other thread is the owner of the context,
3274  * returns %FALSE immediately. Ownership is properly
3275  * recursive: the owner can require ownership again
3276  * and will release ownership when g_main_context_release()
3277  * is called as many times as g_main_context_acquire().
3278  *
3279  * You must be the owner of a context before you
3280  * can call g_main_context_prepare(), g_main_context_query(),
3281  * g_main_context_check(), g_main_context_dispatch().
3282  *
</pre>
<hr />
<pre>
3324  * with g_main_context_acquire(). If the context was acquired multiple
3325  * times, the ownership will be released only when g_main_context_release()
3326  * is called as many times as it was acquired.
3327  **/
3328 void
3329 g_main_context_release (GMainContext *context)
3330 {
3331   if (context == NULL)
3332     context = g_main_context_default ();
3333 
3334   LOCK_CONTEXT (context);
3335 
3336   context-&gt;owner_count--;
3337   if (context-&gt;owner_count == 0)
3338     {
3339       TRACE (GLIB_MAIN_CONTEXT_RELEASE (context));
3340 
3341       context-&gt;owner = NULL;
3342 
3343       if (context-&gt;waiters)
<span class="line-modified">3344     {</span>
<span class="line-modified">3345       GMainWaiter *waiter = context-&gt;waiters-&gt;data;</span>
<span class="line-modified">3346       gboolean loop_internal_waiter = (waiter-&gt;mutex == &amp;context-&gt;mutex);</span>
<span class="line-modified">3347       context-&gt;waiters = g_slist_delete_link (context-&gt;waiters,</span>
<span class="line-modified">3348                           context-&gt;waiters);</span>
<span class="line-modified">3349       if (!loop_internal_waiter)</span>
<span class="line-modified">3350         g_mutex_lock (waiter-&gt;mutex);</span>
3351 
<span class="line-modified">3352       g_cond_signal (waiter-&gt;cond);</span>
3353 
<span class="line-modified">3354       if (!loop_internal_waiter)</span>
<span class="line-modified">3355         g_mutex_unlock (waiter-&gt;mutex);</span>
<span class="line-modified">3356     }</span>
3357     }
3358 
3359   UNLOCK_CONTEXT (context);
3360 }
3361 
3362 static gboolean
3363 g_main_context_wait_internal (GMainContext *context,
<span class="line-modified">3364              GCond        *cond,</span>
<span class="line-modified">3365              GMutex       *mutex)</span>
3366 {
3367   gboolean result = FALSE;
3368   GThread *self = G_THREAD_SELF;
3369   gboolean loop_internal_waiter;
3370 
3371   if (context == NULL)
3372     context = g_main_context_default ();
3373 
3374   loop_internal_waiter = (mutex == &amp;context-&gt;mutex);
3375 
3376   if (!loop_internal_waiter)
3377     LOCK_CONTEXT (context);
3378 
3379   if (context-&gt;owner &amp;&amp; context-&gt;owner != self)
3380     {
3381       GMainWaiter waiter;
3382 
3383       waiter.cond = cond;
3384       waiter.mutex = mutex;
3385 
3386       context-&gt;waiters = g_slist_append (context-&gt;waiters, &amp;waiter);
3387 
3388       if (!loop_internal_waiter)
<span class="line-modified">3389     UNLOCK_CONTEXT (context);</span>
3390       g_cond_wait (cond, mutex);
3391       if (!loop_internal_waiter)
<span class="line-modified">3392     LOCK_CONTEXT (context);</span>
3393 
3394       context-&gt;waiters = g_slist_remove (context-&gt;waiters, &amp;waiter);
3395     }
3396 
3397   if (!context-&gt;owner)
3398     {
3399       context-&gt;owner = self;
3400       g_assert (context-&gt;owner_count == 0);
3401     }
3402 
3403   if (context-&gt;owner == self)
3404     {
3405       context-&gt;owner_count++;
3406       result = TRUE;
3407     }
3408 
3409   if (!loop_internal_waiter)
3410     UNLOCK_CONTEXT (context);
3411 
3412   return result;
</pre>
<hr />
<pre>
3437     context = g_main_context_default ();
3438 
3439   if (G_UNLIKELY (cond != &amp;context-&gt;cond || mutex != &amp;context-&gt;mutex))
3440     {
3441       static gboolean warned;
3442 
3443       if (!warned)
3444         {
3445           g_critical (&quot;WARNING!! g_main_context_wait() will be removed in a future release.  &quot;
3446                       &quot;If you see this message, please file a bug immediately.&quot;);
3447           warned = TRUE;
3448         }
3449     }
3450 
3451   return g_main_context_wait_internal (context, cond, mutex);
3452 }
3453 
3454 /**
3455  * g_main_context_prepare:
3456  * @context: a #GMainContext
<span class="line-modified">3457  * @priority: location to store priority of highest priority</span>
3458  *            source already ready.
3459  *
3460  * Prepares to poll sources within a main loop. The resulting information
3461  * for polling is determined by calling g_main_context_query ().
3462  *
3463  * You must have successfully acquired the context with
3464  * g_main_context_acquire() before you may call this function.
3465  *
3466  * Returns: %TRUE if some source is ready to be dispatched
3467  *               prior to polling.
3468  **/
3469 gboolean
3470 g_main_context_prepare (GMainContext *context,
<span class="line-modified">3471             gint         *priority)</span>
3472 {
3473   guint i;
3474   gint n_ready = 0;
3475   gint current_priority = G_MAXINT;
3476   GSource *source;
3477   GSourceIter iter;
3478 
3479   if (context == NULL)
3480     context = g_main_context_default ();
3481 
3482   LOCK_CONTEXT (context);
3483 
3484   context-&gt;time_is_fresh = FALSE;
3485 
3486   if (context-&gt;in_check_or_prepare)
3487     {
3488       g_warning (&quot;g_main_context_prepare() called recursively from within a source&#39;s check() or &quot;
<span class="line-modified">3489          &quot;prepare() member.&quot;);</span>
3490       UNLOCK_CONTEXT (context);
3491       return FALSE;
3492     }
3493 
3494   TRACE (GLIB_MAIN_CONTEXT_BEFORE_PREPARE (context));
3495 
3496 #if 0
3497   /* If recursing, finish up current dispatch, before starting over */
3498   if (context-&gt;pending_dispatches)
3499     {
3500       if (dispatch)
<span class="line-modified">3501     g_main_dispatch (context, &amp;current_time);</span>
3502 
3503       UNLOCK_CONTEXT (context);
3504       return TRUE;
3505     }
3506 #endif
3507 
3508   /* If recursing, clear list of pending dispatches */
3509 
3510   for (i = 0; i &lt; context-&gt;pending_dispatches-&gt;len; i++)
3511     {
3512       if (context-&gt;pending_dispatches-&gt;pdata[i])
<span class="line-modified">3513     SOURCE_UNREF ((GSource *)context-&gt;pending_dispatches-&gt;pdata[i], context);</span>
3514     }
3515   g_ptr_array_set_size (context-&gt;pending_dispatches, 0);
3516 
3517   /* Prepare all sources */
3518 
3519   context-&gt;timeout = -1;
3520 
3521   g_source_iter_init (&amp;iter, context, TRUE);
3522   while (g_source_iter_next (&amp;iter, &amp;source))
3523     {
3524       gint source_timeout = -1;
3525 
3526       if (SOURCE_DESTROYED (source) || SOURCE_BLOCKED (source))
<span class="line-modified">3527     continue;</span>
3528       if ((n_ready &gt; 0) &amp;&amp; (source-&gt;priority &gt; current_priority))
<span class="line-modified">3529     break;</span>
3530 
3531       if (!(source-&gt;flags &amp; G_SOURCE_READY))
<span class="line-modified">3532     {</span>
<span class="line-modified">3533       gboolean result;</span>
<span class="line-modified">3534       gboolean (* prepare) (GSource  *source,</span>
3535                                 gint     *timeout);
3536 
3537           prepare = source-&gt;source_funcs-&gt;prepare;
3538 
3539           if (prepare)
3540             {
3541               context-&gt;in_check_or_prepare++;
3542               UNLOCK_CONTEXT (context);
3543 
3544               result = (* prepare) (source, &amp;source_timeout);
3545               TRACE (GLIB_MAIN_AFTER_PREPARE (source, prepare, source_timeout));
3546 
3547               LOCK_CONTEXT (context);
3548               context-&gt;in_check_or_prepare--;
3549             }
3550           else
3551             {
3552               source_timeout = -1;
3553               result = FALSE;
3554             }
3555 
3556           if (result == FALSE &amp;&amp; source-&gt;priv-&gt;ready_time != -1)
3557             {
3558               if (!context-&gt;time_is_fresh)
3559                 {
3560                   context-&gt;time = g_get_monotonic_time ();
3561                   context-&gt;time_is_fresh = TRUE;
3562                 }
3563 
3564               if (source-&gt;priv-&gt;ready_time &lt;= context-&gt;time)
3565                 {
3566                   source_timeout = 0;
3567                   result = TRUE;
3568                 }
3569               else
3570                 {
<span class="line-modified">3571                   gint timeout;</span>
3572 
3573                   /* rounding down will lead to spinning, so always round up */
3574                   timeout = (source-&gt;priv-&gt;ready_time - context-&gt;time + 999) / 1000;
3575 
3576                   if (source_timeout &lt; 0 || timeout &lt; source_timeout)
<span class="line-modified">3577                     source_timeout = timeout;</span>
3578                 }
3579             }
3580 
<span class="line-modified">3581       if (result)</span>
<span class="line-modified">3582         {</span>
<span class="line-modified">3583           GSource *ready_source = source;</span>
3584 
<span class="line-modified">3585           while (ready_source)</span>
<span class="line-modified">3586         {</span>
<span class="line-modified">3587           ready_source-&gt;flags |= G_SOURCE_READY;</span>
<span class="line-modified">3588           ready_source = ready_source-&gt;priv-&gt;parent_source;</span>
<span class="line-removed">3589         }</span>
<span class="line-removed">3590         }</span>
3591     }


3592 
3593       if (source-&gt;flags &amp; G_SOURCE_READY)
<span class="line-modified">3594     {</span>
<span class="line-modified">3595       n_ready++;</span>
<span class="line-modified">3596       current_priority = source-&gt;priority;</span>
<span class="line-modified">3597       context-&gt;timeout = 0;</span>
<span class="line-modified">3598     }</span>
3599 
3600       if (source_timeout &gt;= 0)
<span class="line-modified">3601     {</span>
<span class="line-modified">3602       if (context-&gt;timeout &lt; 0)</span>
<span class="line-modified">3603         context-&gt;timeout = source_timeout;</span>
<span class="line-modified">3604       else</span>
<span class="line-modified">3605         context-&gt;timeout = MIN (context-&gt;timeout, source_timeout);</span>
<span class="line-modified">3606     }</span>
3607     }
3608   g_source_iter_clear (&amp;iter);
3609 
3610   TRACE (GLIB_MAIN_CONTEXT_AFTER_PREPARE (context, current_priority, n_ready));
3611 
3612   UNLOCK_CONTEXT (context);
3613 
3614   if (priority)
3615     *priority = current_priority;
3616 
3617   return (n_ready &gt; 0);
3618 }
3619 
3620 /**
3621  * g_main_context_query:
3622  * @context: a #GMainContext
3623  * @max_priority: maximum priority source to check
3624  * @timeout_: (out): location to store timeout to be used in polling
3625  * @fds: (out caller-allocates) (array length=n_fds): location to
3626  *       store #GPollFD records that need to be polled.
3627  * @n_fds: (in): length of @fds.
3628  *
3629  * Determines information necessary to poll this main loop.
3630  *
3631  * You must have successfully acquired the context with
3632  * g_main_context_acquire() before you may call this function.
3633  *
3634  * Returns: the number of records actually stored in @fds,
3635  *   or, if more than @n_fds records need to be stored, the number
3636  *   of records that need to be stored.
3637  **/
3638 gint
3639 g_main_context_query (GMainContext *context,
<span class="line-modified">3640               gint          max_priority,</span>
<span class="line-modified">3641               gint         *timeout,</span>
<span class="line-modified">3642               GPollFD      *fds,</span>
<span class="line-modified">3643               gint          n_fds)</span>
3644 {
3645   gint n_poll;
3646   GPollRec *pollrec, *lastpollrec;
3647   gushort events;
3648 
3649   LOCK_CONTEXT (context);
3650 
3651   TRACE (GLIB_MAIN_CONTEXT_BEFORE_QUERY (context, max_priority));
3652 
3653   n_poll = 0;
3654   lastpollrec = NULL;
3655   for (pollrec = context-&gt;poll_records; pollrec; pollrec = pollrec-&gt;next)
3656     {
3657       if (pollrec-&gt;priority &gt; max_priority)
3658         continue;
3659 
3660       /* In direct contradiction to the Unix98 spec, IRIX runs into
3661        * difficulty if you pass in POLLERR, POLLHUP or POLLNVAL
3662        * flags in the events field of the pollfd while it should
3663        * just ignoring them. So we mask them out here.
3664        */
3665       events = pollrec-&gt;fd-&gt;events &amp; ~(G_IO_ERR|G_IO_HUP|G_IO_NVAL);
3666 
3667       if (lastpollrec &amp;&amp; pollrec-&gt;fd-&gt;fd == lastpollrec-&gt;fd-&gt;fd)
3668         {
3669           if (n_poll - 1 &lt; n_fds)
3670             fds[n_poll - 1].events |= events;
3671         }
3672       else
3673         {
3674           if (n_poll &lt; n_fds)
3675             {
3676               fds[n_poll].fd = pollrec-&gt;fd-&gt;fd;
3677               fds[n_poll].events = events;
<span class="line-modified">3678       fds[n_poll].revents = 0;</span>
<span class="line-modified">3679     }</span>
3680 
<span class="line-modified">3681       n_poll++;</span>
<span class="line-modified">3682     }</span>
3683 
3684       lastpollrec = pollrec;
3685     }
3686 
3687   context-&gt;poll_changed = FALSE;
3688 
3689   if (timeout)
3690     {
3691       *timeout = context-&gt;timeout;
3692       if (*timeout != 0)
3693         context-&gt;time_is_fresh = FALSE;
3694     }
3695 
3696   TRACE (GLIB_MAIN_CONTEXT_AFTER_QUERY (context, context-&gt;timeout,
3697                                         fds, n_poll));
3698 
3699   UNLOCK_CONTEXT (context);
3700 
3701   return n_poll;
3702 }
3703 
3704 /**
3705  * g_main_context_check:
3706  * @context: a #GMainContext
3707  * @max_priority: the maximum numerical priority of sources to check
3708  * @fds: (array length=n_fds): array of #GPollFD&#39;s that was passed to
3709  *       the last call to g_main_context_query()
3710  * @n_fds: return value of g_main_context_query()
3711  *
3712  * Passes the results of polling back to the main loop.
3713  *
3714  * You must have successfully acquired the context with
3715  * g_main_context_acquire() before you may call this function.
3716  *
3717  * Returns: %TRUE if some sources are ready to be dispatched.
3718  **/
3719 gboolean
3720 g_main_context_check (GMainContext *context,
<span class="line-modified">3721               gint          max_priority,</span>
<span class="line-modified">3722               GPollFD      *fds,</span>
<span class="line-modified">3723               gint          n_fds)</span>
3724 {
3725   GSource *source;
3726   GSourceIter iter;
3727   GPollRec *pollrec;
3728   gint n_ready = 0;
3729   gint i;
3730 
3731   LOCK_CONTEXT (context);
3732 
3733   if (context-&gt;in_check_or_prepare)
3734     {
3735       g_warning (&quot;g_main_context_check() called recursively from within a source&#39;s check() or &quot;
<span class="line-modified">3736          &quot;prepare() member.&quot;);</span>
3737       UNLOCK_CONTEXT (context);
3738       return FALSE;
3739     }
3740 
3741   TRACE (GLIB_MAIN_CONTEXT_BEFORE_CHECK (context, max_priority, fds, n_fds));
3742 
3743   for (i = 0; i &lt; n_fds; i++)
3744     {
3745       if (fds[i].fd == context-&gt;wake_up_rec.fd)
3746         {
3747           if (fds[i].revents)
3748             {
3749               TRACE (GLIB_MAIN_CONTEXT_WAKEUP_ACKNOWLEDGE (context));
<span class="line-modified">3750     g_wakeup_acknowledge (context-&gt;wakeup);</span>
3751             }
3752           break;
3753         }
3754     }
3755 
3756   /* If the set of poll file descriptors changed, bail out
3757    * and let the main loop rerun
3758    */
3759   if (context-&gt;poll_changed)
3760     {
3761       TRACE (GLIB_MAIN_CONTEXT_AFTER_CHECK (context, 0));
3762 
3763       UNLOCK_CONTEXT (context);
3764       return FALSE;
3765     }
3766 
3767   pollrec = context-&gt;poll_records;
3768   i = 0;
3769   while (pollrec &amp;&amp; i &lt; n_fds)
3770     {
3771       while (pollrec &amp;&amp; pollrec-&gt;fd-&gt;fd == fds[i].fd)
3772         {
3773           if (pollrec-&gt;priority &lt;= max_priority)
3774             {
3775               pollrec-&gt;fd-&gt;revents =
3776                 fds[i].revents &amp; (pollrec-&gt;fd-&gt;events | G_IO_ERR | G_IO_HUP | G_IO_NVAL);
3777             }
3778           pollrec = pollrec-&gt;next;
3779         }
3780 
3781       i++;
3782     }
3783 
3784   g_source_iter_init (&amp;iter, context, TRUE);
3785   while (g_source_iter_next (&amp;iter, &amp;source))
3786     {
3787       if (SOURCE_DESTROYED (source) || SOURCE_BLOCKED (source))
<span class="line-modified">3788     continue;</span>
3789       if ((n_ready &gt; 0) &amp;&amp; (source-&gt;priority &gt; max_priority))
<span class="line-modified">3790     break;</span>
3791 
3792       if (!(source-&gt;flags &amp; G_SOURCE_READY))
<span class="line-modified">3793     {</span>
3794           gboolean result;
3795           gboolean (* check) (GSource *source);
3796 
3797           check = source-&gt;source_funcs-&gt;check;
3798 
3799           if (check)
3800             {
3801               /* If the check function is set, call it. */
3802               context-&gt;in_check_or_prepare++;
3803               UNLOCK_CONTEXT (context);
3804 
3805               result = (* check) (source);
3806 
3807               TRACE (GLIB_MAIN_AFTER_CHECK (source, check, result));
3808 
3809               LOCK_CONTEXT (context);
3810               context-&gt;in_check_or_prepare--;
3811             }
3812           else
3813             result = FALSE;
</pre>
<hr />
<pre>
3827                   if (pollfd-&gt;revents)
3828                     {
3829                       result = TRUE;
3830                       break;
3831                     }
3832                 }
3833             }
3834 
3835           if (result == FALSE &amp;&amp; source-&gt;priv-&gt;ready_time != -1)
3836             {
3837               if (!context-&gt;time_is_fresh)
3838                 {
3839                   context-&gt;time = g_get_monotonic_time ();
3840                   context-&gt;time_is_fresh = TRUE;
3841                 }
3842 
3843               if (source-&gt;priv-&gt;ready_time &lt;= context-&gt;time)
3844                 result = TRUE;
3845             }
3846 
<span class="line-modified">3847       if (result)</span>
<span class="line-modified">3848         {</span>
<span class="line-modified">3849           GSource *ready_source = source;</span>
3850 
<span class="line-modified">3851           while (ready_source)</span>
<span class="line-modified">3852         {</span>
<span class="line-modified">3853           ready_source-&gt;flags |= G_SOURCE_READY;</span>
<span class="line-modified">3854           ready_source = ready_source-&gt;priv-&gt;parent_source;</span>
<span class="line-removed">3855         }</span>
<span class="line-removed">3856         }</span>
3857     }


3858 
3859       if (source-&gt;flags &amp; G_SOURCE_READY)
<span class="line-modified">3860     {</span>
<span class="line-modified">3861       source-&gt;ref_count++;</span>
<span class="line-modified">3862       g_ptr_array_add (context-&gt;pending_dispatches, source);</span>
3863 
<span class="line-modified">3864       n_ready++;</span>
3865 
3866           /* never dispatch sources with less priority than the first
3867            * one we choose to dispatch
3868            */
3869           max_priority = source-&gt;priority;
<span class="line-modified">3870     }</span>
3871     }
3872   g_source_iter_clear (&amp;iter);
3873 
3874   TRACE (GLIB_MAIN_CONTEXT_AFTER_CHECK (context, n_ready));
3875 
3876   UNLOCK_CONTEXT (context);
3877 
3878   return n_ready &gt; 0;
3879 }
3880 
3881 /**
3882  * g_main_context_dispatch:
3883  * @context: a #GMainContext
3884  *
3885  * Dispatches all pending sources.
3886  *
3887  * You must have successfully acquired the context with
3888  * g_main_context_acquire() before you may call this function.
3889  **/
3890 void
3891 g_main_context_dispatch (GMainContext *context)
3892 {
3893   LOCK_CONTEXT (context);
3894 
3895   TRACE (GLIB_MAIN_CONTEXT_BEFORE_DISPATCH (context));
3896 
3897   if (context-&gt;pending_dispatches-&gt;len &gt; 0)
3898     {
3899       g_main_dispatch (context);
3900     }
3901 
3902   TRACE (GLIB_MAIN_CONTEXT_AFTER_DISPATCH (context));
3903 
3904   UNLOCK_CONTEXT (context);
3905 }
3906 
3907 /* HOLDS context lock */
3908 static gboolean
3909 g_main_context_iterate (GMainContext *context,
<span class="line-modified">3910             gboolean      block,</span>
<span class="line-modified">3911             gboolean      dispatch,</span>
<span class="line-modified">3912             GThread      *self)</span>
3913 {
3914   gint max_priority;
3915   gint timeout;
3916   gboolean some_ready;
3917   gint nfds, allocated_nfds;
3918   GPollFD *fds = NULL;
3919 
3920   UNLOCK_CONTEXT (context);
3921 
3922   if (!g_main_context_acquire (context))
3923     {
3924       gboolean got_ownership;
3925 
3926       LOCK_CONTEXT (context);
3927 
3928       if (!block)
<span class="line-modified">3929     return FALSE;</span>
3930 
3931       got_ownership = g_main_context_wait_internal (context,
3932                                                     &amp;context-&gt;cond,
3933                                                     &amp;context-&gt;mutex);
3934 
3935       if (!got_ownership)
<span class="line-modified">3936     return FALSE;</span>
3937     }
3938   else
3939     LOCK_CONTEXT (context);
3940 
3941   if (!context-&gt;cached_poll_array)
3942     {
3943       context-&gt;cached_poll_array_size = context-&gt;n_poll_records;
3944       context-&gt;cached_poll_array = g_new (GPollFD, context-&gt;n_poll_records);
3945     }
3946 
3947   allocated_nfds = context-&gt;cached_poll_array_size;
3948   fds = context-&gt;cached_poll_array;
3949 
3950   UNLOCK_CONTEXT (context);
3951 
3952   g_main_context_prepare (context, &amp;max_priority);
3953 
3954   while ((nfds = g_main_context_query (context, max_priority, &amp;timeout, fds,
<span class="line-modified">3955                        allocated_nfds)) &gt; allocated_nfds)</span>
3956     {
3957       LOCK_CONTEXT (context);
3958       g_free (fds);
3959       context-&gt;cached_poll_array_size = allocated_nfds = nfds;
3960       context-&gt;cached_poll_array = fds = g_new (GPollFD, nfds);
3961       UNLOCK_CONTEXT (context);
3962 #ifdef GSTREAMER_LITE
3963       if (fds == NULL) {
3964         return FALSE;
3965       }
3966 #endif // GSTREAMER_LITE
3967     }
3968 
3969   if (!block)
3970     timeout = 0;
3971 
3972   g_main_context_poll (context, timeout, max_priority, fds, nfds);
3973 
3974   some_ready = g_main_context_check (context, max_priority, fds, nfds);
3975 
</pre>
<hr />
<pre>
4037   LOCK_CONTEXT (context);
4038   retval = g_main_context_iterate (context, may_block, TRUE, G_THREAD_SELF);
4039   UNLOCK_CONTEXT (context);
4040 
4041   return retval;
4042 }
4043 
4044 /**
4045  * g_main_loop_new:
4046  * @context: (nullable): a #GMainContext  (if %NULL, the default context will be used).
4047  * @is_running: set to %TRUE to indicate that the loop is running. This
4048  * is not very important since calling g_main_loop_run() will set this to
4049  * %TRUE anyway.
4050  *
4051  * Creates a new #GMainLoop structure.
4052  *
4053  * Returns: a new #GMainLoop.
4054  **/
4055 GMainLoop *
4056 g_main_loop_new (GMainContext *context,
<span class="line-modified">4057          gboolean      is_running)</span>
4058 {
4059   GMainLoop *loop;
4060 
4061   if (!context)
4062     context = g_main_context_default();
4063 
4064   g_main_context_ref (context);
4065 
4066   loop = g_new0 (GMainLoop, 1);
4067   loop-&gt;context = context;
4068   loop-&gt;is_running = is_running != FALSE;
4069   loop-&gt;ref_count = 1;
4070 
4071   TRACE (GLIB_MAIN_LOOP_NEW (loop, context));
4072 
4073   return loop;
4074 }
4075 
4076 /**
4077  * g_main_loop_ref:
</pre>
<hr />
<pre>
4120  * If this is called for the thread of the loop&#39;s #GMainContext,
4121  * it will process events from the loop, otherwise it will
4122  * simply wait.
4123  **/
4124 void
4125 g_main_loop_run (GMainLoop *loop)
4126 {
4127   GThread *self = G_THREAD_SELF;
4128 
4129   g_return_if_fail (loop != NULL);
4130   g_return_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0);
4131 
4132   if (!g_main_context_acquire (loop-&gt;context))
4133     {
4134       gboolean got_ownership = FALSE;
4135 
4136       /* Another thread owns this context */
4137       LOCK_CONTEXT (loop-&gt;context);
4138 
4139       g_atomic_int_inc (&amp;loop-&gt;ref_count);

4140 
<span class="line-modified">4141       if (!loop-&gt;is_running)</span>
<span class="line-removed">4142     loop-&gt;is_running = TRUE;</span>
<span class="line-removed">4143 </span>
<span class="line-removed">4144       while (loop-&gt;is_running &amp;&amp; !got_ownership)</span>
4145         got_ownership = g_main_context_wait_internal (loop-&gt;context,
4146                                                       &amp;loop-&gt;context-&gt;cond,
4147                                                       &amp;loop-&gt;context-&gt;mutex);
4148 
<span class="line-modified">4149       if (!loop-&gt;is_running)</span>
<span class="line-modified">4150     {</span>
<span class="line-modified">4151       UNLOCK_CONTEXT (loop-&gt;context);</span>
<span class="line-modified">4152       if (got_ownership)</span>
<span class="line-modified">4153         g_main_context_release (loop-&gt;context);</span>
<span class="line-modified">4154       g_main_loop_unref (loop);</span>
<span class="line-modified">4155       return;</span>
<span class="line-modified">4156     }</span>
4157 
4158       g_assert (got_ownership);
4159     }
4160   else
4161     LOCK_CONTEXT (loop-&gt;context);
4162 
4163   if (loop-&gt;context-&gt;in_check_or_prepare)
4164     {
4165       g_warning (&quot;g_main_loop_run(): called recursively from within a source&#39;s &quot;
<span class="line-modified">4166          &quot;check() or prepare() member, iteration not possible.&quot;);</span>
4167       return;
4168     }
4169 
4170   g_atomic_int_inc (&amp;loop-&gt;ref_count);
<span class="line-modified">4171   loop-&gt;is_running = TRUE;</span>
<span class="line-modified">4172   while (loop-&gt;is_running)</span>
4173     g_main_context_iterate (loop-&gt;context, TRUE, TRUE, self);
4174 
4175   UNLOCK_CONTEXT (loop-&gt;context);
4176 
4177   g_main_context_release (loop-&gt;context);
4178 
4179   g_main_loop_unref (loop);
4180 }
4181 
4182 /**
4183  * g_main_loop_quit:
4184  * @loop: a #GMainLoop
4185  *
4186  * Stops a #GMainLoop from running. Any calls to g_main_loop_run()
4187  * for the loop will return.
4188  *
4189  * Note that sources that have already been dispatched when
4190  * g_main_loop_quit() is called will still be executed.
4191  **/
4192 void
4193 g_main_loop_quit (GMainLoop *loop)
4194 {
4195   g_return_if_fail (loop != NULL);
4196   g_return_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0);
4197 
4198   LOCK_CONTEXT (loop-&gt;context);
<span class="line-modified">4199   loop-&gt;is_running = FALSE;</span>
4200   g_wakeup_signal (loop-&gt;context-&gt;wakeup);
4201 
4202   g_cond_broadcast (&amp;loop-&gt;context-&gt;cond);
4203 
4204   UNLOCK_CONTEXT (loop-&gt;context);
4205 
4206   TRACE (GLIB_MAIN_LOOP_QUIT (loop));
4207 }
4208 
4209 /**
4210  * g_main_loop_is_running:
4211  * @loop: a #GMainLoop.
4212  *
4213  * Checks to see if the main loop is currently being run via g_main_loop_run().
4214  *
4215  * Returns: %TRUE if the mainloop is currently being run.
4216  **/
4217 gboolean
4218 g_main_loop_is_running (GMainLoop *loop)
4219 {
4220   g_return_val_if_fail (loop != NULL, FALSE);
4221   g_return_val_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0, FALSE);
4222 
<span class="line-modified">4223   return loop-&gt;is_running;</span>
4224 }
4225 
4226 /**
4227  * g_main_loop_get_context:
4228  * @loop: a #GMainLoop.
4229  *
4230  * Returns the #GMainContext of @loop.
4231  *
4232  * Returns: (transfer none): the #GMainContext of @loop
4233  **/
4234 GMainContext *
4235 g_main_loop_get_context (GMainLoop *loop)
4236 {
4237   g_return_val_if_fail (loop != NULL, NULL);
4238   g_return_val_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0, NULL);
4239 
4240   return loop-&gt;context;
4241 }
4242 
4243 /* HOLDS: context&#39;s lock */
4244 static void
4245 g_main_context_poll (GMainContext *context,
<span class="line-modified">4246              gint          timeout,</span>
<span class="line-modified">4247              gint          priority,</span>
<span class="line-modified">4248              GPollFD      *fds,</span>
<span class="line-modified">4249              gint          n_fds)</span>
4250 {
4251 #ifdef  G_MAIN_POLL_DEBUG
4252   GTimer *poll_timer;
4253   GPollRec *pollrec;
4254   gint i;
4255 #endif
4256 
4257   GPollFunc poll_func;
4258 
4259   if (n_fds || timeout != 0)
4260     {
4261       int ret, errsv;
4262 
4263 #ifdef  G_MAIN_POLL_DEBUG
4264       poll_timer = NULL;
4265       if (_g_main_poll_debug)
<span class="line-modified">4266     {</span>
<span class="line-modified">4267       g_print (&quot;polling context=%p n=%d timeout=%d\n&quot;,</span>
<span class="line-modified">4268            context, n_fds, timeout);</span>
<span class="line-modified">4269       poll_timer = g_timer_new ();</span>
<span class="line-modified">4270     }</span>
4271 #endif
4272 
4273       LOCK_CONTEXT (context);
4274 
4275       poll_func = context-&gt;poll_func;
4276 
4277       UNLOCK_CONTEXT (context);
4278       ret = (*poll_func) (fds, n_fds, timeout);
4279       errsv = errno;
4280       if (ret &lt; 0 &amp;&amp; errsv != EINTR)
<span class="line-modified">4281     {</span>
4282 #ifndef G_OS_WIN32
<span class="line-modified">4283       g_warning (&quot;poll(2) failed due to: %s.&quot;,</span>
<span class="line-modified">4284              g_strerror (errsv));</span>
4285 #else
<span class="line-modified">4286       /* If g_poll () returns -1, it has already called g_warning() */</span>
4287 #endif
<span class="line-modified">4288     }</span>
4289 
4290 #ifdef  G_MAIN_POLL_DEBUG
4291       if (_g_main_poll_debug)
<span class="line-modified">4292     {</span>
<span class="line-modified">4293       LOCK_CONTEXT (context);</span>
<span class="line-removed">4294 </span>
<span class="line-removed">4295       g_print (&quot;g_main_poll(%d) timeout: %d - elapsed %12.10f seconds&quot;,</span>
<span class="line-removed">4296            n_fds,</span>
<span class="line-removed">4297            timeout,</span>
<span class="line-removed">4298            g_timer_elapsed (poll_timer, NULL));</span>
<span class="line-removed">4299       g_timer_destroy (poll_timer);</span>
<span class="line-removed">4300       pollrec = context-&gt;poll_records;</span>
4301 
<span class="line-modified">4302       while (pollrec != NULL)</span>
<span class="line-modified">4303         {</span>
<span class="line-modified">4304           i = 0;</span>
<span class="line-modified">4305           while (i &lt; n_fds)</span>











4306         {
<span class="line-modified">4307           if (fds[i].fd == pollrec-&gt;fd-&gt;fd &amp;&amp;</span>
<span class="line-modified">4308               pollrec-&gt;fd-&gt;events &amp;&amp;</span>
<span class="line-modified">4309               fds[i].revents)</span>
<span class="line-modified">4310             {</span>
<span class="line-modified">4311               g_print (&quot; [&quot; G_POLLFD_FORMAT &quot; :&quot;, fds[i].fd);</span>
<span class="line-modified">4312               if (fds[i].revents &amp; G_IO_IN)</span>
<span class="line-modified">4313             g_print (&quot;i&quot;);</span>
<span class="line-modified">4314               if (fds[i].revents &amp; G_IO_OUT)</span>
<span class="line-modified">4315             g_print (&quot;o&quot;);</span>
<span class="line-modified">4316               if (fds[i].revents &amp; G_IO_PRI)</span>
<span class="line-modified">4317             g_print (&quot;p&quot;);</span>
<span class="line-modified">4318               if (fds[i].revents &amp; G_IO_ERR)</span>
<span class="line-modified">4319             g_print (&quot;e&quot;);</span>
<span class="line-modified">4320               if (fds[i].revents &amp; G_IO_HUP)</span>
<span class="line-removed">4321             g_print (&quot;h&quot;);</span>
<span class="line-removed">4322               if (fds[i].revents &amp; G_IO_NVAL)</span>
<span class="line-removed">4323             g_print (&quot;n&quot;);</span>
<span class="line-removed">4324               g_print (&quot;]&quot;);</span>
<span class="line-removed">4325             }</span>
<span class="line-removed">4326           i++;</span>
4327         }
<span class="line-modified">4328           pollrec = pollrec-&gt;next;</span>
<span class="line-removed">4329         }</span>
<span class="line-removed">4330       g_print (&quot;\n&quot;);</span>
<span class="line-removed">4331 </span>
<span class="line-removed">4332       UNLOCK_CONTEXT (context);</span>
4333     }






4334 #endif
4335     } /* if (n_fds || timeout != 0) */
4336 }
4337 
4338 /**
4339  * g_main_context_add_poll:
4340  * @context: (nullable): a #GMainContext (or %NULL for the default context)
4341  * @fd: a #GPollFD structure holding information about a file
4342  *      descriptor to watch.
4343  * @priority: the priority for this file descriptor which should be
4344  *      the same as the priority used for g_source_attach() to ensure that the
4345  *      file descriptor is polled whenever the results may be needed.
4346  *
4347  * Adds a file descriptor to the set of file descriptors polled for
4348  * this context. This will very seldom be used directly. Instead
4349  * a typical event source will use g_source_add_unix_fd() instead.
4350  **/
4351 void
4352 g_main_context_add_poll (GMainContext *context,
<span class="line-modified">4353              GPollFD      *fd,</span>
<span class="line-modified">4354              gint          priority)</span>
4355 {
4356   if (!context)
4357     context = g_main_context_default ();
4358 
4359   g_return_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0);
4360   g_return_if_fail (fd);
4361 
4362   LOCK_CONTEXT (context);
4363   g_main_context_add_poll_unlocked (context, priority, fd);
4364   UNLOCK_CONTEXT (context);
4365 }
4366 
4367 /* HOLDS: main_loop_lock */
4368 static void
4369 g_main_context_add_poll_unlocked (GMainContext *context,
<span class="line-modified">4370                   gint          priority,</span>
<span class="line-modified">4371                   GPollFD      *fd)</span>
4372 {
4373   GPollRec *prevrec, *nextrec;
4374   GPollRec *newrec = g_slice_new (GPollRec);
4375 #ifdef GSTREAMER_LITE
4376   if (newrec == NULL) {
4377     return;
4378   }
4379 #endif // GSTREAMER_LITE
4380 
4381   /* This file descriptor may be checked before we ever poll */
4382   fd-&gt;revents = 0;
4383   newrec-&gt;fd = fd;
4384   newrec-&gt;priority = priority;
4385 
4386   prevrec = NULL;
4387   nextrec = context-&gt;poll_records;
4388   while (nextrec)
4389     {
4390       if (nextrec-&gt;fd-&gt;fd &gt; fd-&gt;fd)
4391         break;
</pre>
<hr />
<pre>
4405     nextrec-&gt;prev = newrec;
4406 
4407   context-&gt;n_poll_records++;
4408 
4409   context-&gt;poll_changed = TRUE;
4410 
4411   /* Now wake up the main loop if it is waiting in the poll() */
4412   g_wakeup_signal (context-&gt;wakeup);
4413 }
4414 
4415 /**
4416  * g_main_context_remove_poll:
4417  * @context:a #GMainContext
4418  * @fd: a #GPollFD descriptor previously added with g_main_context_add_poll()
4419  *
4420  * Removes file descriptor from the set of file descriptors to be
4421  * polled for a particular context.
4422  **/
4423 void
4424 g_main_context_remove_poll (GMainContext *context,
<span class="line-modified">4425                 GPollFD      *fd)</span>
4426 {
4427   if (!context)
4428     context = g_main_context_default ();
4429 
4430   g_return_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0);
4431   g_return_if_fail (fd);
4432 
4433   LOCK_CONTEXT (context);
4434   g_main_context_remove_poll_unlocked (context, fd);
4435   UNLOCK_CONTEXT (context);
4436 }
4437 
4438 static void
4439 g_main_context_remove_poll_unlocked (GMainContext *context,
<span class="line-modified">4440                      GPollFD      *fd)</span>
4441 {
4442   GPollRec *pollrec, *prevrec, *nextrec;
4443 
4444   prevrec = NULL;
4445   pollrec = context-&gt;poll_records;
4446 
4447   while (pollrec)
4448     {
4449       nextrec = pollrec-&gt;next;
4450       if (pollrec-&gt;fd == fd)
<span class="line-modified">4451     {</span>
<span class="line-modified">4452       if (prevrec != NULL)</span>
<span class="line-modified">4453         prevrec-&gt;next = nextrec;</span>
<span class="line-modified">4454       else</span>
<span class="line-modified">4455         context-&gt;poll_records = nextrec;</span>
4456 
<span class="line-modified">4457       if (nextrec != NULL)</span>
<span class="line-modified">4458         nextrec-&gt;prev = prevrec;</span>
4459 
<span class="line-modified">4460       g_slice_free (GPollRec, pollrec);</span>
4461 
<span class="line-modified">4462       context-&gt;n_poll_records--;</span>
<span class="line-modified">4463       break;</span>
<span class="line-modified">4464     }</span>
4465       prevrec = pollrec;
4466       pollrec = nextrec;
4467     }
4468 
4469   context-&gt;poll_changed = TRUE;
4470 
4471   /* Now wake up the main loop if it is waiting in the poll() */
4472   g_wakeup_signal (context-&gt;wakeup);
4473 }
4474 
4475 /**
4476  * g_source_get_current_time:
4477  * @source:  a #GSource
4478  * @timeval: #GTimeVal structure in which to store current time.
4479  *
4480  * This function ignores @source and is otherwise the same as
4481  * g_get_current_time().
4482  *
4483  * Deprecated: 2.28: use g_source_get_time() instead
4484  **/

4485 void
4486 g_source_get_current_time (GSource  *source,
<span class="line-modified">4487                GTimeVal *timeval)</span>
4488 {
4489   g_get_current_time (timeval);
4490 }

4491 
4492 /**
4493  * g_source_get_time:
4494  * @source: a #GSource
4495  *
4496  * Gets the time to be used when checking this source. The advantage of
4497  * calling this function over calling g_get_monotonic_time() directly is
4498  * that when checking multiple sources, GLib can cache a single value
4499  * instead of having to repeatedly get the system monotonic time.
4500  *
4501  * The time here is the system monotonic time, if available, or some
4502  * other reasonable alternative otherwise.  See g_get_monotonic_time().
4503  *
4504  * Returns: the monotonic time in microseconds
4505  *
4506  * Since: 2.28
4507  **/
4508 gint64
4509 g_source_get_time (GSource *source)
4510 {
</pre>
<hr />
<pre>
4528   UNLOCK_CONTEXT (context);
4529 
4530   return result;
4531 }
4532 
4533 /**
4534  * g_main_context_set_poll_func:
4535  * @context: a #GMainContext
4536  * @func: the function to call to poll all file descriptors
4537  *
4538  * Sets the function to use to handle polling of file descriptors. It
4539  * will be used instead of the poll() system call
4540  * (or GLib&#39;s replacement function, which is used where
4541  * poll() isn&#39;t available).
4542  *
4543  * This function could possibly be used to integrate the GLib event
4544  * loop with an external event loop.
4545  **/
4546 void
4547 g_main_context_set_poll_func (GMainContext *context,
<span class="line-modified">4548                   GPollFunc     func)</span>
4549 {
4550   if (!context)
4551     context = g_main_context_default ();
4552 
4553   g_return_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0);
4554 
4555   LOCK_CONTEXT (context);
4556 
4557   if (func)
4558     context-&gt;poll_func = func;
4559   else
4560     context-&gt;poll_func = g_poll;
4561 
4562   UNLOCK_CONTEXT (context);
4563 }
4564 
4565 /**
4566  * g_main_context_get_poll_func:
4567  * @context: a #GMainContext
4568  *
</pre>
<hr />
<pre>
4652   gboolean is_owner;
4653 
4654   if (!context)
4655     context = g_main_context_default ();
4656 
4657   LOCK_CONTEXT (context);
4658   is_owner = context-&gt;owner == G_THREAD_SELF;
4659   UNLOCK_CONTEXT (context);
4660 
4661   return is_owner;
4662 }
4663 
4664 /* Timeouts */
4665 
4666 static void
4667 g_timeout_set_expiration (GTimeoutSource *timeout_source,
4668                           gint64          current_time)
4669 {
4670   gint64 expiration;
4671 
<span class="line-removed">4672   expiration = current_time + (guint64) timeout_source-&gt;interval * 1000;</span>
<span class="line-removed">4673 </span>
4674   if (timeout_source-&gt;seconds)
4675     {
4676       gint64 remainder;
4677       static gint timer_perturb = -1;
4678 
4679       if (timer_perturb == -1)
4680         {
4681           /*
4682            * we want a per machine/session unique &#39;random&#39; value; try the dbus
4683            * address first, that has a UUID in it. If there is no dbus, use the
4684            * hostname for hashing.
4685            */
4686           const char *session_bus_address = g_getenv (&quot;DBUS_SESSION_BUS_ADDRESS&quot;);
4687           if (!session_bus_address)
4688             session_bus_address = g_getenv (&quot;HOSTNAME&quot;);
4689           if (session_bus_address)
4690             timer_perturb = ABS ((gint) g_str_hash (session_bus_address)) % 1000000;
4691           else
4692             timer_perturb = 0;
4693         }
4694 


4695       /* We want the microseconds part of the timeout to land on the
4696        * &#39;timer_perturb&#39; mark, but we need to make sure we don&#39;t try to
4697        * set the timeout in the past.  We do this by ensuring that we
4698        * always only *increase* the expiration time by adding a full
4699        * second in the case that the microsecond portion decreases.
4700        */
4701       expiration -= timer_perturb;
4702 
4703       remainder = expiration % 1000000;
4704       if (remainder &gt;= 1000000/4)
4705         expiration += 1000000;
4706 
4707       expiration -= remainder;
4708       expiration += timer_perturb;
4709     }




4710 
4711   g_source_set_ready_time ((GSource *) timeout_source, expiration);
4712 }
4713 
4714 static gboolean
4715 g_timeout_dispatch (GSource     *source,
4716                     GSourceFunc  callback,
4717                     gpointer     user_data)
4718 {
4719   GTimeoutSource *timeout_source = (GTimeoutSource *)source;
4720   gboolean again;
4721 
4722   if (!callback)
4723     {
4724       g_warning (&quot;Timeout source dispatched without callback. &quot;
4725                  &quot;You must call g_source_set_callback().&quot;);
4726       return FALSE;
4727     }
4728 
4729   again = callback (user_data);
</pre>
<hr />
<pre>
4777  * The source will not initially be associated with any #GMainContext
4778  * and must be added to one with g_source_attach() before it will be
4779  * executed.
4780  *
4781  * The scheduling granularity/accuracy of this timeout source will be
4782  * in seconds.
4783  *
4784  * The interval given is in terms of monotonic time, not wall clock time.
4785  * See g_get_monotonic_time().
4786  *
4787  * Returns: the newly-created timeout source
4788  *
4789  * Since: 2.14
4790  **/
4791 GSource *
4792 g_timeout_source_new_seconds (guint interval)
4793 {
4794   GSource *source = g_source_new (&amp;g_timeout_funcs, sizeof (GTimeoutSource));
4795   GTimeoutSource *timeout_source = (GTimeoutSource *)source;
4796 
<span class="line-modified">4797   timeout_source-&gt;interval = 1000 * interval;</span>
4798   timeout_source-&gt;seconds = TRUE;
4799 
4800   g_timeout_set_expiration (timeout_source, g_get_monotonic_time ());
4801 
4802   return source;
4803 }
4804 #endif // GSTREAMER_LITE
4805 
4806 
4807 /**
4808  * g_timeout_add_full: (rename-to g_timeout_add)
4809  * @priority: the priority of the timeout source. Typically this will be in
4810  *            the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.
4811  * @interval: the time between calls to the function, in milliseconds
4812  *             (1/1000ths of a second)
4813  * @function: function to call
4814  * @data:     data to pass to @function
4815  * @notify: (nullable): function to call when the timeout is removed, or %NULL
4816  *
4817  * Sets a function to be called at regular intervals, with the given
</pre>
<hr />
<pre>
4826  * After each call to the timeout function, the time of the next
4827  * timeout is recalculated based on the current time and the given interval
4828  * (it does not try to &#39;catch up&#39; time lost in delays).
4829  *
4830  * See [memory management of sources][mainloop-memory-management] for details
4831  * on how to handle the return value and memory management of @data.
4832  *
4833  * This internally creates a main loop source using g_timeout_source_new()
4834  * and attaches it to the global #GMainContext using g_source_attach(), so
4835  * the callback will be invoked in whichever thread is running that main
4836  * context. You can do these steps manually if you need greater control or to
4837  * use a custom main context.
4838  *
4839  * The interval given is in terms of monotonic time, not wall clock time.
4840  * See g_get_monotonic_time().
4841  *
4842  * Returns: the ID (greater than 0) of the event source.
4843  **/
4844 guint
4845 g_timeout_add_full (gint           priority,
<span class="line-modified">4846             guint          interval,</span>
<span class="line-modified">4847             GSourceFunc    function,</span>
<span class="line-modified">4848             gpointer       data,</span>
<span class="line-modified">4849             GDestroyNotify notify)</span>
4850 {
4851   GSource *source;
4852   guint id;
4853 
4854   g_return_val_if_fail (function != NULL, 0);
4855 
4856   source = g_timeout_source_new (interval);
4857 #ifdef GSTREAMER_LITE
4858   if (source == NULL)
4859       return 0;
4860 #endif // GSTREAMER_LITE
4861 
4862   if (priority != G_PRIORITY_DEFAULT)
4863     g_source_set_priority (source, priority);
4864 
4865   g_source_set_callback (source, function, data, notify);
4866   id = g_source_attach (source, NULL);
4867 
4868   TRACE (GLIB_TIMEOUT_ADD (source, g_main_context_default (), id, priority, interval, function, data));
4869 
</pre>
<hr />
<pre>
4895  * on how to handle the return value and memory management of @data.
4896  *
4897  * If you want to have a timer in the &quot;seconds&quot; range and do not care
4898  * about the exact time of the first call of the timer, use the
4899  * g_timeout_add_seconds() function; this function allows for more
4900  * optimizations and more efficient system power usage.
4901  *
4902  * This internally creates a main loop source using g_timeout_source_new()
4903  * and attaches it to the global #GMainContext using g_source_attach(), so
4904  * the callback will be invoked in whichever thread is running that main
4905  * context. You can do these steps manually if you need greater control or to
4906  * use a custom main context.
4907  *
4908  * The interval given is in terms of monotonic time, not wall clock
4909  * time.  See g_get_monotonic_time().
4910  *
4911  * Returns: the ID (greater than 0) of the event source.
4912  **/
4913 guint
4914 g_timeout_add (guint32        interval,
<span class="line-modified">4915            GSourceFunc    function,</span>
<span class="line-modified">4916            gpointer       data)</span>
4917 {
4918   return g_timeout_add_full (G_PRIORITY_DEFAULT,
<span class="line-modified">4919                  interval, function, data, NULL);</span>
4920 }
4921 
4922 #ifndef GSTREAMER_LITE
4923 /**
4924  * g_timeout_add_seconds_full: (rename-to g_timeout_add_seconds)
4925  * @priority: the priority of the timeout source. Typically this will be in
4926  *            the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.
4927  * @interval: the time between calls to the function, in seconds
4928  * @function: function to call
4929  * @data:     data to pass to @function
4930  * @notify: (nullable): function to call when the timeout is removed, or %NULL
4931  *
4932  * Sets a function to be called at regular intervals, with @priority.
4933  * The function is called repeatedly until it returns %FALSE, at which
4934  * point the timeout is automatically destroyed and the function will
4935  * not be called again.
4936  *
4937  * Unlike g_timeout_add(), this function operates at whole second granularity.
4938  * The initial starting point of the timer is determined by the implementation
4939  * and the implementation is expected to group multiple timers together so that
</pre>
<hr />
<pre>
5024  *
5025  * Since: 2.14
5026  **/
5027 guint
5028 g_timeout_add_seconds (guint       interval,
5029                        GSourceFunc function,
5030                        gpointer    data)
5031 {
5032   g_return_val_if_fail (function != NULL, 0);
5033 
5034   return g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, interval, function, data, NULL);
5035 }
5036 #endif // GSTREAMER_LITE
5037 
5038 /* Child watch functions */
5039 
5040 #ifdef G_OS_WIN32
5041 
5042 static gboolean
5043 g_child_watch_prepare (GSource *source,
<span class="line-modified">5044                gint    *timeout)</span>
5045 {
5046   *timeout = -1;
5047   return FALSE;
5048 }
5049 
5050 static gboolean
5051 g_child_watch_check (GSource  *source)
5052 {
5053   GChildWatchSource *child_watch_source;
5054   gboolean child_exited;
5055 
5056   child_watch_source = (GChildWatchSource *) source;
5057 
5058   child_exited = child_watch_source-&gt;poll.revents &amp; G_IO_IN;
5059 
5060   if (child_exited)
5061     {
5062       DWORD child_status;
5063 
5064       /*
5065        * Note: We do _not_ check for the special value of STILL_ACTIVE
5066        * since we know that the process has exited and doing so runs into
5067        * problems if the child process &quot;happens to return STILL_ACTIVE(259)&quot;
5068        * as Microsoft&#39;s Platform SDK puts it.
5069        */
5070       if (!GetExitCodeProcess (child_watch_source-&gt;pid, &amp;child_status))
5071         {
<span class="line-modified">5072       gchar *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-modified">5073       g_warning (G_STRLOC &quot;: GetExitCodeProcess() failed: %s&quot;, emsg);</span>
<span class="line-modified">5074       g_free (emsg);</span>
5075 
<span class="line-modified">5076       child_watch_source-&gt;child_status = -1;</span>
<span class="line-modified">5077     }</span>
5078       else
<span class="line-modified">5079     child_watch_source-&gt;child_status = child_status;</span>
5080     }
5081 
5082   return child_exited;
5083 }
5084 
5085 static void
5086 g_child_watch_finalize (GSource *source)
5087 {
5088 }
5089 
5090 #else /* G_OS_WIN32 */
5091 
5092 static void
5093 wake_source (GSource *source)
5094 {
5095   GMainContext *context;
5096 
5097   /* This should be thread-safe:
5098    *
5099    *  - if the source is currently being added to a context, that
</pre>
<hr />
<pre>
5156       pending[i] = unix_signal_pending[i];
5157       if (pending[i])
5158         unix_signal_pending[i] = FALSE;
5159     }
5160 
5161   /* handle GChildWatchSource instances */
5162   if (pending[SIGCHLD])
5163     {
5164       /* The only way we can do this is to scan all of the children.
5165        *
5166        * The docs promise that we will not reap children that we are not
5167        * explicitly watching, so that ties our hands from calling
5168        * waitpid(-1).  We also can&#39;t use siginfo&#39;s si_pid field since if
5169        * multiple SIGCHLD arrive at the same time, one of them can be
5170        * dropped (since a given UNIX signal can only be pending once).
5171        */
5172       for (node = unix_child_watches; node; node = node-&gt;next)
5173         {
5174           GChildWatchSource *source = node-&gt;data;
5175 
<span class="line-modified">5176           if (!source-&gt;child_exited)</span>
5177             {
5178               pid_t pid;
5179               do
5180                 {
5181                   g_assert (source-&gt;pid &gt; 0);
5182 
5183                   pid = waitpid (source-&gt;pid, &amp;source-&gt;child_status, WNOHANG);
5184                   if (pid &gt; 0)
5185                     {
<span class="line-modified">5186                       source-&gt;child_exited = TRUE;</span>
5187                       wake_source ((GSource *) source);
5188                     }
5189                   else if (pid == -1 &amp;&amp; errno == ECHILD)
5190                     {
5191                       g_warning (&quot;GChildWatchSource: Exit status of a child process was requested but ECHILD was received by waitpid(). See the documentation of g_child_watch_source_new() for possible causes.&quot;);
<span class="line-removed">5192                       source-&gt;child_exited = TRUE;</span>
5193                       source-&gt;child_status = 0;

5194                       wake_source ((GSource *) source);
5195                     }
5196                 }
5197               while (pid == -1 &amp;&amp; errno == EINTR);
5198             }
5199         }
5200     }
5201 
5202   /* handle GUnixSignalWatchSource instances */
5203   for (node = unix_signal_watches; node; node = node-&gt;next)
5204     {
5205       GUnixSignalWatchSource *source = node-&gt;data;
5206 
<span class="line-modified">5207       if (!source-&gt;pending)</span>

5208         {
<span class="line-modified">5209           if (pending[source-&gt;signum])</span>
<span class="line-removed">5210             {</span>
<span class="line-removed">5211               source-&gt;pending = TRUE;</span>
<span class="line-removed">5212 </span>
<span class="line-removed">5213               wake_source ((GSource *) source);</span>
<span class="line-removed">5214             }</span>
5215         }
5216     }
5217 
5218 }
5219 
5220 static void
5221 dispatch_unix_signals (void)
5222 {
5223   G_LOCK(unix_signal_lock);
5224   dispatch_unix_signals_unlocked ();
5225   G_UNLOCK(unix_signal_lock);
5226 }
5227 
5228 static gboolean
5229 g_child_watch_prepare (GSource *source,
<span class="line-modified">5230                gint    *timeout)</span>
5231 {
5232   GChildWatchSource *child_watch_source;
5233 
5234   child_watch_source = (GChildWatchSource *) source;
5235 
<span class="line-modified">5236   return child_watch_source-&gt;child_exited;</span>
5237 }
5238 
5239 static gboolean
5240 g_child_watch_check (GSource *source)
5241 {
5242   GChildWatchSource *child_watch_source;
5243 
5244   child_watch_source = (GChildWatchSource *) source;
5245 
<span class="line-modified">5246   return child_watch_source-&gt;child_exited;</span>
5247 }
5248 
5249 static gboolean
5250 g_unix_signal_watch_prepare (GSource *source,
<span class="line-modified">5251                  gint    *timeout)</span>
5252 {
5253   GUnixSignalWatchSource *unix_signal_source;
5254 
5255   unix_signal_source = (GUnixSignalWatchSource *) source;
5256 
<span class="line-modified">5257   return unix_signal_source-&gt;pending;</span>
5258 }
5259 
5260 static gboolean
5261 g_unix_signal_watch_check (GSource  *source)
5262 {
5263   GUnixSignalWatchSource *unix_signal_source;
5264 
5265   unix_signal_source = (GUnixSignalWatchSource *) source;
5266 
<span class="line-modified">5267   return unix_signal_source-&gt;pending;</span>
5268 }
5269 
5270 static gboolean
5271 g_unix_signal_watch_dispatch (GSource    *source,
<span class="line-modified">5272                   GSourceFunc callback,</span>
<span class="line-modified">5273                   gpointer    user_data)</span>
5274 {
5275   GUnixSignalWatchSource *unix_signal_source;
5276   gboolean again;
5277 
5278   unix_signal_source = (GUnixSignalWatchSource *) source;
5279 
5280   if (!callback)
5281     {
5282       g_warning (&quot;Unix signal source dispatched without callback. &quot;
<span class="line-modified">5283          &quot;You must call g_source_set_callback().&quot;);</span>
5284       return FALSE;
5285     }
5286 
<span class="line-modified">5287   again = (callback) (user_data);</span>
5288 
<span class="line-modified">5289   unix_signal_source-&gt;pending = FALSE;</span>
5290 
5291   return again;
5292 }
5293 
5294 static void
5295 ref_unix_signal_handler_unlocked (int signum)
5296 {
5297   /* Ensure we have the worker context */
5298   g_get_worker_context ();
5299   unix_signal_refcount[signum]++;
5300   if (unix_signal_refcount[signum] == 1)
5301     {
5302       struct sigaction action;
5303       action.sa_handler = g_unix_signal_handler;
5304       sigemptyset (&amp;action.sa_mask);
5305 #ifdef SA_RESTART
5306       action.sa_flags = SA_RESTART | SA_NOCLDSTOP;
5307 #else
5308       action.sa_flags = SA_NOCLDSTOP;
5309 #endif
</pre>
<hr />
<pre>
5420 
5421   G_LOCK (unix_signal_lock);
5422   unref_unix_signal_handler_unlocked (unix_signal_source-&gt;signum);
5423   unix_signal_watches = g_slist_remove (unix_signal_watches, source);
5424   G_UNLOCK (unix_signal_lock);
5425 }
5426 
5427 static void
5428 g_child_watch_finalize (GSource *source)
5429 {
5430   G_LOCK (unix_signal_lock);
5431   unix_child_watches = g_slist_remove (unix_child_watches, source);
5432   unref_unix_signal_handler_unlocked (SIGCHLD);
5433   G_UNLOCK (unix_signal_lock);
5434 }
5435 
5436 #endif /* G_OS_WIN32 */
5437 
5438 static gboolean
5439 g_child_watch_dispatch (GSource    *source,
<span class="line-modified">5440             GSourceFunc callback,</span>
<span class="line-modified">5441             gpointer    user_data)</span>
5442 {
5443   GChildWatchSource *child_watch_source;
5444   GChildWatchFunc child_watch_callback = (GChildWatchFunc) callback;
5445 
5446   child_watch_source = (GChildWatchSource *) source;
5447 
5448   if (!callback)
5449     {
5450       g_warning (&quot;Child watch source dispatched without callback. &quot;
<span class="line-modified">5451          &quot;You must call g_source_set_callback().&quot;);</span>
5452       return FALSE;
5453     }
5454 
5455   (child_watch_callback) (child_watch_source-&gt;pid, child_watch_source-&gt;child_status, user_data);
5456 
5457   /* We never keep a child watch source around as the child is gone */
5458   return FALSE;
5459 }
5460 
5461 #ifndef G_OS_WIN32
5462 
5463 static void
5464 g_unix_signal_handler (int signum)
5465 {
5466   gint saved_errno = errno;
5467 
5468   unix_signal_pending[signum] = TRUE;
5469   any_unix_signal_pending = TRUE;
5470 
5471   g_wakeup_signal (glib_worker_context-&gt;wakeup);
</pre>
<hr />
<pre>
5580  * Also, note that on platforms where #GPid must be explicitly closed
5581  * (see g_spawn_close_pid()) @pid must not be closed while the source
5582  * is still active.  Typically, you should invoke g_spawn_close_pid()
5583  * in the callback function for the source.
5584  *
5585  * GLib supports only a single callback per process id.
5586  * On POSIX platforms, the same restrictions mentioned for
5587  * g_child_watch_source_new() apply to this function.
5588  *
5589  * This internally creates a main loop source using
5590  * g_child_watch_source_new() and attaches it to the main loop context
5591  * using g_source_attach(). You can do these steps manually if you
5592  * need greater control.
5593  *
5594  * Returns: the ID (greater than 0) of the event source.
5595  *
5596  * Since: 2.4
5597  **/
5598 guint
5599 g_child_watch_add_full (gint            priority,
<span class="line-modified">5600             GPid            pid,</span>
<span class="line-modified">5601             GChildWatchFunc function,</span>
<span class="line-modified">5602             gpointer        data,</span>
<span class="line-modified">5603             GDestroyNotify  notify)</span>
5604 {
5605   GSource *source;
5606   guint id;
5607 
5608   g_return_val_if_fail (function != NULL, 0);
5609 #ifndef G_OS_WIN32
5610   g_return_val_if_fail (pid &gt; 0, 0);
5611 #endif
5612 
5613   source = g_child_watch_source_new (pid);
5614 
5615   if (priority != G_PRIORITY_DEFAULT)
5616     g_source_set_priority (source, priority);
5617 
5618   g_source_set_callback (source, (GSourceFunc) function, data, notify);
5619   id = g_source_attach (source, NULL);
5620   g_source_unref (source);
5621 
5622   return id;
5623 }
</pre>
<hr />
<pre>
5640  * Note that on platforms where #GPid must be explicitly closed
5641  * (see g_spawn_close_pid()) @pid must not be closed while the
5642  * source is still active. Typically, you will want to call
5643  * g_spawn_close_pid() in the callback function for the source.
5644  *
5645  * GLib supports only a single callback per process id.
5646  * On POSIX platforms, the same restrictions mentioned for
5647  * g_child_watch_source_new() apply to this function.
5648  *
5649  * This internally creates a main loop source using
5650  * g_child_watch_source_new() and attaches it to the main loop context
5651  * using g_source_attach(). You can do these steps manually if you
5652  * need greater control.
5653  *
5654  * Returns: the ID (greater than 0) of the event source.
5655  *
5656  * Since: 2.4
5657  **/
5658 guint
5659 g_child_watch_add (GPid            pid,
<span class="line-modified">5660            GChildWatchFunc function,</span>
<span class="line-modified">5661            gpointer        data)</span>
5662 {
5663   return g_child_watch_add_full (G_PRIORITY_DEFAULT, pid, function, data, NULL);
5664 }
5665 
5666 
5667 /* Idle functions */
5668 
5669 static gboolean
5670 g_idle_prepare  (GSource  *source,
<span class="line-modified">5671          gint     *timeout)</span>
5672 {
5673   *timeout = 0;
5674 
5675   return TRUE;
5676 }
5677 
5678 static gboolean
5679 g_idle_check    (GSource  *source)
5680 {
5681   return TRUE;
5682 }
5683 
5684 static gboolean
5685 g_idle_dispatch (GSource    *source,
<span class="line-modified">5686          GSourceFunc callback,</span>
<span class="line-modified">5687          gpointer    user_data)</span>
5688 {
5689   gboolean again;
5690 
5691   if (!callback)
5692     {
5693       g_warning (&quot;Idle source dispatched without callback. &quot;
<span class="line-modified">5694          &quot;You must call g_source_set_callback().&quot;);</span>
5695       return FALSE;
5696     }
5697 
5698   again = callback (user_data);
5699 
5700   TRACE (GLIB_IDLE_DISPATCH (source, source-&gt;context, callback, user_data, again));
5701 
5702   return again;
5703 }
5704 
5705 /**
5706  * g_idle_source_new:
5707  *
5708  * Creates a new idle source.
5709  *
5710  * The source will not initially be associated with any #GMainContext
5711  * and must be added to one with g_source_attach() before it will be
5712  * executed. Note that the default priority for idle sources is
5713  * %G_PRIORITY_DEFAULT_IDLE, as compared to other sources which
5714  * have a default priority of %G_PRIORITY_DEFAULT.
</pre>
<hr />
<pre>
5737  * @data:     data to pass to @function
5738  * @notify: (nullable): function to call when the idle is removed, or %NULL
5739  *
5740  * Adds a function to be called whenever there are no higher priority
5741  * events pending.  If the function returns %FALSE it is automatically
5742  * removed from the list of event sources and will not be called again.
5743  *
5744  * See [memory management of sources][mainloop-memory-management] for details
5745  * on how to handle the return value and memory management of @data.
5746  *
5747  * This internally creates a main loop source using g_idle_source_new()
5748  * and attaches it to the global #GMainContext using g_source_attach(), so
5749  * the callback will be invoked in whichever thread is running that main
5750  * context. You can do these steps manually if you need greater control or to
5751  * use a custom main context.
5752  *
5753  * Returns: the ID (greater than 0) of the event source.
5754  **/
5755 guint
5756 g_idle_add_full (gint           priority,
<span class="line-modified">5757          GSourceFunc    function,</span>
<span class="line-modified">5758          gpointer       data,</span>
<span class="line-modified">5759          GDestroyNotify notify)</span>
5760 {
5761   GSource *source;
5762   guint id;
5763 
5764   g_return_val_if_fail (function != NULL, 0);
5765 
5766   source = g_idle_source_new ();
5767 
5768   if (priority != G_PRIORITY_DEFAULT_IDLE)
5769     g_source_set_priority (source, priority);
5770 
5771   g_source_set_callback (source, function, data, notify);
5772   id = g_source_attach (source, NULL);
5773 
5774   TRACE (GLIB_IDLE_ADD (source, g_main_context_default (), id, priority, function, data));
5775 
5776   g_source_unref (source);
5777 
5778   return id;
5779 }
</pre>
<hr />
<pre>
5785  *
5786  * Adds a function to be called whenever there are no higher priority
5787  * events pending to the default main loop. The function is given the
5788  * default idle priority, #G_PRIORITY_DEFAULT_IDLE.  If the function
5789  * returns %FALSE it is automatically removed from the list of event
5790  * sources and will not be called again.
5791  *
5792  * See [memory management of sources][mainloop-memory-management] for details
5793  * on how to handle the return value and memory management of @data.
5794  *
5795  * This internally creates a main loop source using g_idle_source_new()
5796  * and attaches it to the global #GMainContext using g_source_attach(), so
5797  * the callback will be invoked in whichever thread is running that main
5798  * context. You can do these steps manually if you need greater control or to
5799  * use a custom main context.
5800  *
5801  * Returns: the ID (greater than 0) of the event source.
5802  **/
5803 guint
5804 g_idle_add (GSourceFunc    function,
<span class="line-modified">5805         gpointer       data)</span>
5806 {
5807   return g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, function, data, NULL);
5808 }
5809 
5810 /**
5811  * g_idle_remove_by_data:
5812  * @data: the data for the idle source&#39;s callback.
5813  *
5814  * Removes the idle function with the given data.
5815  *
5816  * Returns: %TRUE if an idle source was found and removed.
5817  **/
5818 gboolean
5819 g_idle_remove_by_data (gpointer data)
5820 {
5821   return g_source_remove_by_funcs_user_data (&amp;g_idle_funcs, data);
5822 }
5823 
5824 /**
5825  * g_main_context_invoke:
5826  * @context: (nullable): a #GMainContext, or %NULL
5827  * @function: function to call
5828  * @data: data to pass to @function
5829  *
5830  * Invokes a function in such a way that @context is owned during the
5831  * invocation of @function.
5832  *
<span class="line-modified">5833  * If @context is %NULL then the global default main context as</span>
<span class="line-modified">5834  * returned by g_main_context_default() is used.</span>
5835  *
5836  * If @context is owned by the current thread, @function is called
5837  * directly.  Otherwise, if @context is the thread-default main context
5838  * of the current thread and g_main_context_acquire() succeeds, then
5839  * @function is called and g_main_context_release() is called
5840  * afterwards.
5841  *
5842  * In any other case, an idle source is created to call @function and
5843  * that source is attached to @context (presumably to be run in another
5844  * thread).  The idle source is attached with #G_PRIORITY_DEFAULT
5845  * priority.  If you want a different priority, use
5846  * g_main_context_invoke_full().
5847  *
5848  * Note that, as with normal idle functions, @function should probably
5849  * return %FALSE.  If it returns %TRUE, it will be continuously run in a
5850  * loop (and may prevent this call from returning).
5851  *
5852  * Since: 2.28
5853  **/
5854 void
</pre>
</td>
<td>
<hr />
<pre>
  70 #ifdef G_OS_WIN32
  71 #define STRICT
  72 #include &lt;windows.h&gt;
  73 #endif /* G_OS_WIN32 */
  74 
  75 #ifdef HAVE_MACH_MACH_TIME_H
  76 #include &lt;mach/mach_time.h&gt;
  77 #endif
  78 
  79 #include &quot;glib_trace.h&quot;
  80 
  81 #include &quot;gmain.h&quot;
  82 
  83 #include &quot;garray.h&quot;
  84 #include &quot;giochannel.h&quot;
  85 #include &quot;ghash.h&quot;
  86 #include &quot;ghook.h&quot;
  87 #include &quot;gqueue.h&quot;
  88 #include &quot;gstrfuncs.h&quot;
  89 #include &quot;gtestutils.h&quot;
<span class="line-added">  90 #include &quot;gthreadprivate.h&quot;</span>
  91 
  92 #ifdef G_OS_WIN32
  93 #include &quot;gwin32.h&quot;
  94 #endif
  95 
  96 #ifdef  G_MAIN_POLL_DEBUG
  97 #include &quot;gtimer.h&quot;
  98 #endif
  99 
 100 #include &quot;gwakeup.h&quot;
 101 #include &quot;gmain-internal.h&quot;
 102 #include &quot;glib-init.h&quot;
 103 #include &quot;glib-private.h&quot;
 104 
 105 /**
 106  * SECTION:main
 107  * @title: The Main Event Loop
 108  * @short_description: manages all available sources of events
 109  *
 110  * The main event loop manages all the available sources of events for
</pre>
<hr />
<pre>
 174  * g_main_context_prepare(), g_main_context_query(),
 175  * g_main_context_check() and g_main_context_dispatch().
 176  *
 177  * ## State of a Main Context # {#mainloop-states}
 178  *
 179  * The operation of these functions can best be seen in terms
 180  * of a state diagram, as shown in this image.
 181  *
 182  * ![](mainloop-states.gif)
 183  *
 184  * On UNIX, the GLib mainloop is incompatible with fork(). Any program
 185  * using the mainloop must either exec() or exit() from the child
 186  * without returning to the mainloop.
 187  *
 188  * ## Memory management of sources # {#mainloop-memory-management}
 189  *
 190  * There are two options for memory management of the user data passed to a
 191  * #GSource to be passed to its callback on invocation. This data is provided
 192  * in calls to g_timeout_add(), g_timeout_add_full(), g_idle_add(), etc. and
 193  * more generally, using g_source_set_callback(). This data is typically an
<span class="line-modified"> 194  * object which &#39;owns&#39; the timeout or idle callback, such as a widget or a</span>
 195  * network protocol implementation. In many cases, it is an error for the
 196  * callback to be invoked after this owning object has been destroyed, as that
 197  * results in use of freed memory.
 198  *
 199  * The first, and preferred, option is to store the source ID returned by
 200  * functions such as g_timeout_add() or g_source_attach(), and explicitly
 201  * remove that source from the main context using g_source_remove() when the
 202  * owning object is finalized. This ensures that the callback can only be
 203  * invoked while the object is still alive.
 204  *
 205  * The second option is to hold a strong reference to the object in the
<span class="line-modified"> 206  * callback, and to release it in the callback&#39;s #GDestroyNotify. This ensures</span>
 207  * that the object is kept alive until after the source is finalized, which is
 208  * guaranteed to be after it is invoked for the final time. The #GDestroyNotify
<span class="line-modified"> 209  * is another callback passed to the &#39;full&#39; variants of #GSource functions (for</span>
 210  * example, g_timeout_add_full()). It is called when the source is finalized,
 211  * and is designed for releasing references like this.
 212  *
 213  * One important caveat of this second approach is that it will keep the object
 214  * alive indefinitely if the main loop is stopped before the #GSource is
 215  * invoked, which may be undesirable.
 216  */
 217 
 218 /* Types */
 219 
 220 typedef struct _GTimeoutSource GTimeoutSource;
 221 typedef struct _GChildWatchSource GChildWatchSource;
 222 typedef struct _GUnixSignalWatchSource GUnixSignalWatchSource;
 223 typedef struct _GPollRec GPollRec;
 224 typedef struct _GSourceCallback GSourceCallback;
 225 
 226 typedef enum
 227 {
 228   G_SOURCE_READY = 1 &lt;&lt; G_HOOK_FLAG_USER_SHIFT,
 229   G_SOURCE_CAN_RECURSE = 1 &lt;&lt; (G_HOOK_FLAG_USER_SHIFT + 1),
</pre>
<hr />
<pre>
 257 #ifdef G_MAIN_POLL_DEBUG
 258 gboolean _g_main_poll_debug = FALSE;
 259 #endif
 260 
 261 struct _GMainContext
 262 {
 263   /* The following lock is used for both the list of sources
 264    * and the list of poll records
 265    */
 266   GMutex mutex;
 267   GCond cond;
 268   GThread *owner;
 269   guint owner_count;
 270   GSList *waiters;
 271 
 272   volatile gint ref_count;
 273 
 274   GHashTable *sources;              /* guint -&gt; GSource */
 275 
 276   GPtrArray *pending_dispatches;
<span class="line-modified"> 277   gint timeout;     /* Timeout for current iteration */</span>
 278 
 279   guint next_id;
 280   GList *source_lists;
 281   gint in_check_or_prepare;
 282 
 283   GPollRec *poll_records;
 284   guint n_poll_records;
 285   GPollFD *cached_poll_array;
 286   guint cached_poll_array_size;
 287 
 288   GWakeup *wakeup;
 289 
 290   GPollFD wake_up_rec;
 291 
 292 /* Flag indicating whether the set of fd&#39;s changed during a poll */
 293   gboolean poll_changed;
 294 
 295   GPollFunc poll_func;
 296 
 297   gint64   time;
 298   gboolean time_is_fresh;
 299 };
 300 
 301 struct _GSourceCallback
 302 {
 303   volatile gint ref_count;
 304   GSourceFunc func;
 305   gpointer    data;
 306   GDestroyNotify notify;
 307 };
 308 
 309 struct _GMainLoop
 310 {
 311   GMainContext *context;
<span class="line-modified"> 312   gboolean is_running; /* (atomic) */</span>
 313   volatile gint ref_count;
 314 };
 315 
 316 struct _GTimeoutSource
 317 {
 318   GSource     source;
<span class="line-added"> 319   /* Measured in seconds if &#39;seconds&#39; is TRUE, or milliseconds otherwise. */</span>
 320   guint       interval;
 321   gboolean    seconds;
 322 };
 323 
 324 struct _GChildWatchSource
 325 {
 326   GSource     source;
 327   GPid        pid;
 328   gint        child_status;
 329 #ifdef G_OS_WIN32
 330   GPollFD     poll;
 331 #else /* G_OS_WIN32 */
<span class="line-modified"> 332   gboolean    child_exited; /* (atomic) */</span>
 333 #endif /* G_OS_WIN32 */
 334 };
 335 
 336 struct _GUnixSignalWatchSource
 337 {
 338   GSource     source;
 339   int         signum;
<span class="line-modified"> 340   gboolean    pending; /* (atomic) */</span>
 341 };
 342 
 343 struct _GPollRec
 344 {
 345   GPollFD *fd;
 346   GPollRec *prev;
 347   GPollRec *next;
 348   gint priority;
 349 };
 350 
 351 struct _GSourcePrivate
 352 {
 353   GSList *child_sources;
 354   GSource *parent_source;
 355 
 356   gint64 ready_time;
 357 
 358   /* This is currently only used on UNIX, but we always declare it (and
 359    * let it remain empty on Windows) to avoid #ifdef all over the place.
 360    */
 361   GSList *fds;
 362 };
 363 
 364 typedef struct _GSourceIter
 365 {
 366   GMainContext *context;
 367   gboolean may_modify;
 368   GList *current_list;
 369   GSource *source;
 370 } GSourceIter;
 371 
 372 #define LOCK_CONTEXT(context) g_mutex_lock (&amp;context-&gt;mutex)
 373 #define UNLOCK_CONTEXT(context) g_mutex_unlock (&amp;context-&gt;mutex)
 374 #define G_THREAD_SELF g_thread_self ()
 375 
 376 #define SOURCE_DESTROYED(source) (((source)-&gt;flags &amp; G_HOOK_FLAG_ACTIVE) == 0)
 377 #define SOURCE_BLOCKED(source) (((source)-&gt;flags &amp; G_SOURCE_BLOCKED) != 0)
 378 









 379 /* Forward declarations */
 380 
 381 static void g_source_unref_internal             (GSource      *source,
<span class="line-modified"> 382              GMainContext *context,</span>
<span class="line-modified"> 383              gboolean      have_lock);</span>
 384 static void g_source_destroy_internal           (GSource      *source,
<span class="line-modified"> 385              GMainContext *context,</span>
<span class="line-modified"> 386              gboolean      have_lock);</span>
 387 static void g_source_set_priority_unlocked      (GSource      *source,
<span class="line-modified"> 388              GMainContext *context,</span>
<span class="line-modified"> 389              gint          priority);</span>
 390 static void g_child_source_remove_internal      (GSource      *child_source,
 391                                                  GMainContext *context);
 392 
 393 static void g_main_context_poll                 (GMainContext *context,
<span class="line-modified"> 394              gint          timeout,</span>
<span class="line-modified"> 395              gint          priority,</span>
<span class="line-modified"> 396              GPollFD      *fds,</span>
<span class="line-modified"> 397              gint          n_fds);</span>
 398 static void g_main_context_add_poll_unlocked    (GMainContext *context,
<span class="line-modified"> 399              gint          priority,</span>
<span class="line-modified"> 400              GPollFD      *fd);</span>
 401 static void g_main_context_remove_poll_unlocked (GMainContext *context,
<span class="line-modified"> 402              GPollFD      *fd);</span>
 403 
 404 static void     g_source_iter_init  (GSourceIter   *iter,
<span class="line-modified"> 405              GMainContext  *context,</span>
<span class="line-modified"> 406              gboolean       may_modify);</span>
 407 static gboolean g_source_iter_next  (GSourceIter   *iter,
<span class="line-modified"> 408              GSource      **source);</span>
 409 static void     g_source_iter_clear (GSourceIter   *iter);
 410 
 411 static gboolean g_timeout_dispatch (GSource     *source,
<span class="line-modified"> 412             GSourceFunc  callback,</span>
<span class="line-modified"> 413             gpointer     user_data);</span>
 414 static gboolean g_child_watch_prepare  (GSource     *source,
<span class="line-modified"> 415                 gint        *timeout);</span>
 416 static gboolean g_child_watch_check    (GSource     *source);
 417 static gboolean g_child_watch_dispatch (GSource     *source,
<span class="line-modified"> 418           GSourceFunc  callback,</span>
<span class="line-modified"> 419           gpointer     user_data);</span>
 420 static void     g_child_watch_finalize (GSource     *source);
 421 #ifdef G_OS_UNIX
 422 static void g_unix_signal_handler (int signum);
 423 static gboolean g_unix_signal_watch_prepare  (GSource     *source,
<span class="line-modified"> 424                 gint        *timeout);</span>
 425 static gboolean g_unix_signal_watch_check    (GSource     *source);
 426 static gboolean g_unix_signal_watch_dispatch (GSource     *source,
<span class="line-modified"> 427                 GSourceFunc  callback,</span>
<span class="line-modified"> 428                 gpointer     user_data);</span>
 429 static void     g_unix_signal_watch_finalize  (GSource     *source);
 430 #endif
 431 static gboolean g_idle_prepare     (GSource     *source,
<span class="line-modified"> 432             gint        *timeout);</span>
 433 static gboolean g_idle_check       (GSource     *source);
 434 static gboolean g_idle_dispatch    (GSource     *source,
<span class="line-modified"> 435             GSourceFunc  callback,</span>
<span class="line-modified"> 436             gpointer     user_data);</span>
 437 
 438 static void block_source (GSource *source);
 439 
 440 static GMainContext *glib_worker_context;
 441 
 442 G_LOCK_DEFINE_STATIC (main_loop);
 443 static GMainContext *default_main_context;
 444 
 445 #ifndef G_OS_WIN32
 446 
 447 
 448 /* UNIX signals work by marking one of these variables then waking the
 449  * worker context to check on them and dispatch accordingly.
 450  */
 451 #ifdef HAVE_SIG_ATOMIC_T
 452 static volatile sig_atomic_t unix_signal_pending[NSIG];
 453 static volatile sig_atomic_t any_unix_signal_pending;
 454 #else
 455 static volatile int unix_signal_pending[NSIG];
 456 static volatile int any_unix_signal_pending;
 457 #endif

 458 
 459 /* Guards all the data below */
 460 G_LOCK_DEFINE_STATIC (unix_signal_lock);
<span class="line-added"> 461 static guint unix_signal_refcount[NSIG];</span>
 462 static GSList *unix_signal_watches;
 463 static GSList *unix_child_watches;
 464 
 465 GSourceFuncs g_unix_signal_funcs =
 466 {
 467   g_unix_signal_watch_prepare,
 468   g_unix_signal_watch_check,
 469   g_unix_signal_watch_dispatch,
<span class="line-modified"> 470   g_unix_signal_watch_finalize,</span>
<span class="line-added"> 471   NULL, NULL</span>
 472 };
 473 #endif /* !G_OS_WIN32 */
 474 G_LOCK_DEFINE_STATIC (main_context_list);
 475 static GSList *main_context_list = NULL;
 476 
 477 GSourceFuncs g_timeout_funcs =
 478 {
 479   NULL, /* prepare */
 480   NULL, /* check */
 481   g_timeout_dispatch,
<span class="line-modified"> 482   NULL, NULL, NULL</span>
 483 };
 484 
 485 GSourceFuncs g_child_watch_funcs =
 486 {
 487   g_child_watch_prepare,
 488   g_child_watch_check,
 489   g_child_watch_dispatch,
<span class="line-modified"> 490   g_child_watch_finalize,</span>
<span class="line-added"> 491   NULL, NULL</span>
 492 };
 493 
 494 GSourceFuncs g_idle_funcs =
 495 {
 496   g_idle_prepare,
 497   g_idle_check,
 498   g_idle_dispatch,
<span class="line-modified"> 499   NULL, NULL, NULL</span>
 500 };
 501 
 502 /**
 503  * g_main_context_ref:
 504  * @context: a #GMainContext
 505  *
 506  * Increases the reference count on a #GMainContext object by one.
 507  *
 508  * Returns: the @context that was passed in (since 2.6)
 509  **/
 510 GMainContext *
 511 g_main_context_ref (GMainContext *context)
 512 {
 513   g_return_val_if_fail (context != NULL, NULL);
 514   g_return_val_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0, NULL);
 515 
 516   g_atomic_int_inc (&amp;context-&gt;ref_count);
 517 
 518   return context;
 519 }
 520 
 521 static inline void
 522 poll_rec_list_free (GMainContext *context,
<span class="line-modified"> 523         GPollRec     *list)</span>
 524 {
 525   g_slice_free_chain (GPollRec, list, next);
 526 }
 527 
 528 /**
 529  * g_main_context_unref:
 530  * @context: a #GMainContext
 531  *
 532  * Decreases the reference count on a #GMainContext object by one. If
 533  * the result is zero, free the context and free all associated memory.
 534  **/
 535 void
 536 g_main_context_unref (GMainContext *context)
 537 {
 538   GSourceIter iter;
 539   GSource *source;
 540   GList *sl_iter;
 541   GSourceList *list;
 542   guint i;
 543 
</pre>
<hr />
<pre>
 673  * specified, and corresponds to the &quot;main&quot; main loop. See also
 674  * g_main_context_get_thread_default().
 675  *
 676  * Returns: (transfer none): the global default main context.
 677  **/
 678 GMainContext *
 679 g_main_context_default (void)
 680 {
 681   /* Slow, but safe */
 682 
 683   G_LOCK (main_loop);
 684 
 685   if (!default_main_context)
 686     {
 687       default_main_context = g_main_context_new ();
 688 
 689       TRACE (GLIB_MAIN_CONTEXT_DEFAULT (default_main_context));
 690 
 691 #ifdef G_MAIN_POLL_DEBUG
 692       if (_g_main_poll_debug)
<span class="line-modified"> 693   g_print (&quot;default context=%p\n&quot;, default_main_context);</span>
 694 #endif
 695     }
 696 
 697   G_UNLOCK (main_loop);
 698 
 699   return default_main_context;
 700 }
 701 
 702 static void
 703 free_context (gpointer data)
 704 {
 705   GMainContext *context = data;
 706 
 707   TRACE (GLIB_MAIN_CONTEXT_FREE (context));
 708 
 709   g_main_context_release (context);
 710   if (context)
 711     g_main_context_unref (context);
 712 }
 713 
</pre>
<hr />
<pre>
 883 
 884 /**
 885  * g_source_new:
 886  * @source_funcs: structure containing functions that implement
 887  *                the sources behavior.
 888  * @struct_size: size of the #GSource structure to create.
 889  *
 890  * Creates a new #GSource structure. The size is specified to
 891  * allow creating structures derived from #GSource that contain
 892  * additional data. The size passed in must be at least
 893  * `sizeof (GSource)`.
 894  *
 895  * The source will not initially be associated with any #GMainContext
 896  * and must be added to one with g_source_attach() before it will be
 897  * executed.
 898  *
 899  * Returns: the newly-created #GSource.
 900  **/
 901 GSource *
 902 g_source_new (GSourceFuncs *source_funcs,
<span class="line-modified"> 903         guint         struct_size)</span>
 904 {
 905   GSource *source;
 906 
 907   g_return_val_if_fail (source_funcs != NULL, NULL);
 908   g_return_val_if_fail (struct_size &gt;= sizeof (GSource), NULL);
 909 
 910   source = (GSource*) g_malloc0 (struct_size);
 911 #ifdef GSTREAMER_LITE
 912   if (source == NULL)
 913     return NULL;
 914 #endif // GSTREAMER_LITE
 915   source-&gt;priv = g_slice_new0 (GSourcePrivate);
 916 #ifdef GSTREAMER_LITE
 917   if (source-&gt;priv == NULL)
 918   {
 919     g_free(source);
 920     return NULL;
 921   }
 922 #endif // GSTREAMER_LITE
 923   source-&gt;source_funcs = source_funcs;
 924   source-&gt;ref_count = 1;
 925 
 926   source-&gt;priority = G_PRIORITY_DEFAULT;
 927 
 928   source-&gt;flags = G_HOOK_FLAG_ACTIVE;
 929 
 930   source-&gt;priv-&gt;ready_time = -1;
 931 
 932   /* NULL/0 initialization for all other fields */
 933 
 934   TRACE (GLIB_SOURCE_NEW (source, source_funcs-&gt;prepare, source_funcs-&gt;check,
 935                           source_funcs-&gt;dispatch, source_funcs-&gt;finalize,
 936                           struct_size));
 937 
 938   return source;
 939 }
 940 
 941 /* Holds context&#39;s lock */
 942 static void
 943 g_source_iter_init (GSourceIter  *iter,
<span class="line-modified"> 944         GMainContext *context,</span>
<span class="line-modified"> 945         gboolean      may_modify)</span>
 946 {
 947   iter-&gt;context = context;
 948   iter-&gt;current_list = NULL;
 949   iter-&gt;source = NULL;
 950   iter-&gt;may_modify = may_modify;
 951 }
 952 
 953 /* Holds context&#39;s lock */
 954 static gboolean
 955 g_source_iter_next (GSourceIter *iter, GSource **source)
 956 {
 957   GSource *next_source;
 958 
 959   if (iter-&gt;source)
 960     next_source = iter-&gt;source-&gt;next;
 961   else
 962     next_source = NULL;
 963 
 964   if (!next_source)
 965     {
 966       if (iter-&gt;current_list)
<span class="line-modified"> 967   iter-&gt;current_list = iter-&gt;current_list-&gt;next;</span>
 968       else
<span class="line-modified"> 969   iter-&gt;current_list = iter-&gt;context-&gt;source_lists;</span>
 970 
 971       if (iter-&gt;current_list)
<span class="line-modified"> 972   {</span>
<span class="line-modified"> 973     GSourceList *source_list = iter-&gt;current_list-&gt;data;</span>
 974 
<span class="line-modified"> 975     next_source = source_list-&gt;head;</span>
<span class="line-modified"> 976   }</span>
 977     }
 978 
 979   /* Note: unreffing iter-&gt;source could potentially cause its
 980    * GSourceList to be removed from source_lists (if iter-&gt;source is
 981    * the only source in its list, and it is destroyed), so we have to
 982    * keep it reffed until after we advance iter-&gt;current_list, above.
 983    */
 984 
 985   if (iter-&gt;source &amp;&amp; iter-&gt;may_modify)
<span class="line-modified"> 986     g_source_unref_internal (iter-&gt;source, iter-&gt;context, TRUE);</span>
 987   iter-&gt;source = next_source;
 988   if (iter-&gt;source &amp;&amp; iter-&gt;may_modify)
<span class="line-modified"> 989     g_source_ref (iter-&gt;source);</span>
 990 
 991   *source = iter-&gt;source;
 992   return *source != NULL;
 993 }
 994 
 995 /* Holds context&#39;s lock. Only necessary to call if you broke out of
 996  * the g_source_iter_next() loop early.
 997  */
 998 static void
 999 g_source_iter_clear (GSourceIter *iter)
1000 {
1001   if (iter-&gt;source &amp;&amp; iter-&gt;may_modify)
1002     {
<span class="line-modified">1003       g_source_unref_internal (iter-&gt;source, iter-&gt;context, TRUE);</span>
1004       iter-&gt;source = NULL;
1005     }
1006 }
1007 
1008 /* Holds context&#39;s lock
1009  */
1010 static GSourceList *
1011 find_source_list_for_priority (GMainContext *context,
<span class="line-modified">1012              gint          priority,</span>
<span class="line-modified">1013              gboolean      create)</span>
1014 {
1015   GList *iter, *last;
1016   GSourceList *source_list;
1017 
1018   last = NULL;
1019   for (iter = context-&gt;source_lists; iter != NULL; last = iter, iter = iter-&gt;next)
1020     {
1021       source_list = iter-&gt;data;
1022 
1023       if (source_list-&gt;priority == priority)
<span class="line-modified">1024   return source_list;</span>
1025 
1026       if (source_list-&gt;priority &gt; priority)
<span class="line-modified">1027   {</span>
<span class="line-modified">1028     if (!create)</span>
<span class="line-modified">1029       return NULL;</span>
<span class="line-modified">1030 </span>
<span class="line-modified">1031     source_list = g_slice_new0 (GSourceList);</span>
<span class="line-modified">1032     source_list-&gt;priority = priority;</span>
<span class="line-modified">1033     context-&gt;source_lists = g_list_insert_before (context-&gt;source_lists,</span>
<span class="line-modified">1034               iter,</span>
<span class="line-modified">1035               source_list);</span>
<span class="line-modified">1036     return source_list;</span>
<span class="line-modified">1037   }</span>
1038     }
1039 
1040   if (!create)
1041     return NULL;
1042 
1043   source_list = g_slice_new0 (GSourceList);
1044   source_list-&gt;priority = priority;
1045 
1046   if (!last)
1047     context-&gt;source_lists = g_list_append (NULL, source_list);
1048   else
1049     {
1050       /* This just appends source_list to the end of
1051        * context-&gt;source_lists without having to walk the list again.
1052        */
1053       last = g_list_append (last, source_list);
1054     }
1055   return source_list;
1056 }
1057 
1058 /* Holds context&#39;s lock
1059  */
1060 static void
1061 source_add_to_context (GSource      *source,
<span class="line-modified">1062            GMainContext *context)</span>
1063 {
1064   GSourceList *source_list;
1065   GSource *prev, *next;
1066 
1067   source_list = find_source_list_for_priority (context, source-&gt;priority, TRUE);
1068 
1069   if (source-&gt;priv-&gt;parent_source)
1070     {
1071       g_assert (source_list-&gt;head != NULL);
1072 
1073       /* Put the source immediately before its parent */
1074       prev = source-&gt;priv-&gt;parent_source-&gt;prev;
1075       next = source-&gt;priv-&gt;parent_source;
1076     }
1077   else
1078     {
1079       prev = source_list-&gt;tail;
1080       next = NULL;
1081     }
1082 
1083   source-&gt;next = next;
1084   if (next)
1085     next-&gt;prev = source;
1086   else
1087     source_list-&gt;tail = source;
1088 
1089   source-&gt;prev = prev;
1090   if (prev)
1091     prev-&gt;next = source;
1092   else
1093     source_list-&gt;head = source;
1094 }
1095 
1096 /* Holds context&#39;s lock
1097  */
1098 static void
1099 source_remove_from_context (GSource      *source,
<span class="line-modified">1100           GMainContext *context)</span>
1101 {
1102   GSourceList *source_list;
1103 
1104   source_list = find_source_list_for_priority (context, source-&gt;priority, FALSE);
1105   g_return_if_fail (source_list != NULL);
1106 #ifdef GSTREAMER_LITE
1107   if (source_list == NULL)
1108     return;
1109 #endif // GSTREAMER_LITE
1110 
1111   if (source-&gt;prev)
1112     source-&gt;prev-&gt;next = source-&gt;next;
1113   else
1114     source_list-&gt;head = source-&gt;next;
1115 
1116   if (source-&gt;next)
1117     source-&gt;next-&gt;prev = source-&gt;prev;
1118   else
1119     source_list-&gt;tail = source-&gt;prev;
1120 
</pre>
<hr />
<pre>
1128     }
1129 }
1130 
1131 static guint
1132 g_source_attach_unlocked (GSource      *source,
1133                           GMainContext *context,
1134                           gboolean      do_wakeup)
1135 {
1136   GSList *tmp_list;
1137   guint id;
1138 
1139   /* The counter may have wrapped, so we must ensure that we do not
1140    * reuse the source id of an existing source.
1141    */
1142   do
1143     id = context-&gt;next_id++;
1144   while (id == 0 || g_hash_table_contains (context-&gt;sources, GUINT_TO_POINTER (id)));
1145 
1146   source-&gt;context = context;
1147   source-&gt;source_id = id;
<span class="line-modified">1148   g_source_ref (source);</span>
1149 
1150   g_hash_table_insert (context-&gt;sources, GUINT_TO_POINTER (id), source);
1151 
1152   source_add_to_context (source, context);
1153 
1154   if (!SOURCE_BLOCKED (source))
1155     {
1156       tmp_list = source-&gt;poll_fds;
1157       while (tmp_list)
1158         {
1159           g_main_context_add_poll_unlocked (context, source-&gt;priority, tmp_list-&gt;data);
1160           tmp_list = tmp_list-&gt;next;
1161         }
1162 
1163       for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
1164         g_main_context_add_poll_unlocked (context, source-&gt;priority, tmp_list-&gt;data);
1165     }
1166 
1167   tmp_list = source-&gt;priv-&gt;child_sources;
1168   while (tmp_list)
</pre>
<hr />
<pre>
1176    */
1177   if (do_wakeup &amp;&amp; context-&gt;owner &amp;&amp; context-&gt;owner != G_THREAD_SELF)
1178     g_wakeup_signal (context-&gt;wakeup);
1179 
1180   return source-&gt;source_id;
1181 }
1182 
1183 /**
1184  * g_source_attach:
1185  * @source: a #GSource
1186  * @context: (nullable): a #GMainContext (if %NULL, the default context will be used)
1187  *
1188  * Adds a #GSource to a @context so that it will be executed within
1189  * that context. Remove it by calling g_source_destroy().
1190  *
1191  * Returns: the ID (greater than 0) for the source within the
1192  *   #GMainContext.
1193  **/
1194 guint
1195 g_source_attach (GSource      *source,
<span class="line-modified">1196      GMainContext *context)</span>
1197 {
1198   guint result = 0;
1199 
1200 #ifdef GSTREAMER_LITE
1201   if (source == NULL) {
1202     return 0;
1203   }
1204 #endif // GSTREAMER_LITE
1205 
1206   g_return_val_if_fail (source-&gt;context == NULL, 0);
1207   g_return_val_if_fail (!SOURCE_DESTROYED (source), 0);
1208 
1209   if (!context)
1210     context = g_main_context_default ();
1211 
1212   LOCK_CONTEXT (context);
1213 
1214   result = g_source_attach_unlocked (source, context, TRUE);
1215 
1216   TRACE (GLIB_MAIN_SOURCE_ATTACH (g_source_get_name (source), source, context,
1217                                   result));
1218 
1219   UNLOCK_CONTEXT (context);
1220 
1221   return result;
1222 }
1223 
1224 static void
1225 g_source_destroy_internal (GSource      *source,
<span class="line-modified">1226          GMainContext *context,</span>
<span class="line-modified">1227          gboolean      have_lock)</span>
1228 {
1229   TRACE (GLIB_MAIN_SOURCE_DESTROY (g_source_get_name (source), source,
1230                                    context));
1231 
1232   if (!have_lock)
1233     LOCK_CONTEXT (context);
1234 
1235   if (!SOURCE_DESTROYED (source))
1236     {
1237       GSList *tmp_list;
1238       gpointer old_cb_data;
1239       GSourceCallbackFuncs *old_cb_funcs;
1240 
1241       source-&gt;flags &amp;= ~G_HOOK_FLAG_ACTIVE;
1242 
1243       old_cb_data = source-&gt;callback_data;
1244       old_cb_funcs = source-&gt;callback_funcs;
1245 
1246       source-&gt;callback_data = NULL;
1247       source-&gt;callback_funcs = NULL;
1248 
1249       if (old_cb_funcs)
<span class="line-modified">1250   {</span>
<span class="line-modified">1251     UNLOCK_CONTEXT (context);</span>
<span class="line-modified">1252     old_cb_funcs-&gt;unref (old_cb_data);</span>
<span class="line-modified">1253     LOCK_CONTEXT (context);</span>
<span class="line-modified">1254   }</span>
1255 
1256       if (!SOURCE_BLOCKED (source))
<span class="line-modified">1257   {</span>
<span class="line-modified">1258     tmp_list = source-&gt;poll_fds;</span>
<span class="line-modified">1259     while (tmp_list)</span>
<span class="line-modified">1260       {</span>
<span class="line-modified">1261         g_main_context_remove_poll_unlocked (context, tmp_list-&gt;data);</span>
<span class="line-modified">1262         tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">1263       }</span>
1264 
1265           for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
1266             g_main_context_remove_poll_unlocked (context, tmp_list-&gt;data);
<span class="line-modified">1267   }</span>
1268 
1269       while (source-&gt;priv-&gt;child_sources)
1270         g_child_source_remove_internal (source-&gt;priv-&gt;child_sources-&gt;data, context);
1271 
1272       if (source-&gt;priv-&gt;parent_source)
1273         g_child_source_remove_internal (source, context);
1274 
1275       g_source_unref_internal (source, context, TRUE);
1276     }
1277 
1278   if (!have_lock)
1279     UNLOCK_CONTEXT (context);
1280 }
1281 
1282 /**
1283  * g_source_destroy:
1284  * @source: a #GSource
1285  *
1286  * Removes a source from its #GMainContext, if any, and mark it as
1287  * destroyed.  The source cannot be subsequently added to another
1288  * context. It is safe to call this on sources which have already been
1289  * removed from their context.
<span class="line-modified">1290  *</span>
<span class="line-added">1291  * This does not unref the #GSource: if you still hold a reference, use</span>
<span class="line-added">1292  * g_source_unref() to drop it.</span>
<span class="line-added">1293  */</span>
1294 void
1295 g_source_destroy (GSource *source)
1296 {
1297   GMainContext *context;
1298 
1299   g_return_if_fail (source != NULL);
1300 
1301   context = source-&gt;context;
1302 
1303   if (context)
1304     g_source_destroy_internal (source, context, FALSE);
1305   else
1306     source-&gt;flags &amp;= ~G_HOOK_FLAG_ACTIVE;
1307 }
1308 
1309 /**
1310  * g_source_get_id:
1311  * @source: a #GSource
1312  *
1313  * Returns the numeric ID for a particular source. The ID of a source
</pre>
<hr />
<pre>
1366  * g_source_add_poll:
1367  * @source:a #GSource
1368  * @fd: a #GPollFD structure holding information about a file
1369  *      descriptor to watch.
1370  *
1371  * Adds a file descriptor to the set of file descriptors polled for
1372  * this source. This is usually combined with g_source_new() to add an
1373  * event source. The event source&#39;s check function will typically test
1374  * the @revents field in the #GPollFD struct and return %TRUE if events need
1375  * to be processed.
1376  *
1377  * This API is only intended to be used by implementations of #GSource.
1378  * Do not call this API on a #GSource that you did not create.
1379  *
1380  * Using this API forces the linear scanning of event sources on each
1381  * main loop iteration.  Newly-written event sources should try to use
1382  * g_source_add_unix_fd() instead of this API.
1383  **/
1384 void
1385 g_source_add_poll (GSource *source,
<span class="line-modified">1386        GPollFD *fd)</span>
1387 {
1388   GMainContext *context;
1389 
1390   g_return_if_fail (source != NULL);
1391   g_return_if_fail (fd != NULL);
1392   g_return_if_fail (!SOURCE_DESTROYED (source));
1393 
1394 #ifdef GSTREAMER_LITE
1395   if (source == NULL)
1396     return;
1397 #endif // GSTREAMER_LITE
1398 
1399   context = source-&gt;context;
1400 
1401   if (context)
1402     LOCK_CONTEXT (context);
1403 
1404   source-&gt;poll_fds = g_slist_prepend (source-&gt;poll_fds, fd);
1405 
1406   if (context)
1407     {
1408       if (!SOURCE_BLOCKED (source))
<span class="line-modified">1409   g_main_context_add_poll_unlocked (context, source-&gt;priority, fd);</span>
1410       UNLOCK_CONTEXT (context);
1411     }
1412 }
1413 
1414 /**
1415  * g_source_remove_poll:
1416  * @source:a #GSource
1417  * @fd: a #GPollFD structure previously passed to g_source_add_poll().
1418  *
1419  * Removes a file descriptor from the set of file descriptors polled for
1420  * this source.
1421  *
1422  * This API is only intended to be used by implementations of #GSource.
1423  * Do not call this API on a #GSource that you did not create.
1424  **/
1425 void
1426 g_source_remove_poll (GSource *source,
<span class="line-modified">1427           GPollFD *fd)</span>
1428 {
1429   GMainContext *context;
1430 
1431   g_return_if_fail (source != NULL);
1432   g_return_if_fail (fd != NULL);
1433   g_return_if_fail (!SOURCE_DESTROYED (source));
1434 
1435   context = source-&gt;context;
1436 
1437   if (context)
1438     LOCK_CONTEXT (context);
1439 
1440   source-&gt;poll_fds = g_slist_remove (source-&gt;poll_fds, fd);
1441 
1442   if (context)
1443     {
1444       if (!SOURCE_BLOCKED (source))
<span class="line-modified">1445   g_main_context_remove_poll_unlocked (context, fd);</span>
1446       UNLOCK_CONTEXT (context);
1447     }
1448 }
1449 
1450 /**
1451  * g_source_add_child_source:
1452  * @source:a #GSource
1453  * @child_source: a second #GSource that @source should &quot;poll&quot;
1454  *
1455  * Adds @child_source to @source as a &quot;polled&quot; source; when @source is
1456  * added to a #GMainContext, @child_source will be automatically added
1457  * with the same priority, when @child_source is triggered, it will
1458  * cause @source to dispatch (in addition to calling its own
1459  * callback), and when @source is destroyed, it will destroy
1460  * @child_source as well. (@source will also still be dispatched if
1461  * its own prepare/check functions indicate that it is ready.)
1462  *
1463  * If you don&#39;t need @child_source to do anything on its own when it
1464  * triggers, you can call g_source_set_dummy_callback() on it to set a
1465  * callback that does nothing (except return %TRUE if appropriate).
1466  *
1467  * @source will hold a reference on @child_source while @child_source
1468  * is attached to it.
1469  *
1470  * This API is only intended to be used by implementations of #GSource.
1471  * Do not call this API on a #GSource that you did not create.
1472  *
1473  * Since: 2.28
1474  **/
1475 void
1476 g_source_add_child_source (GSource *source,
<span class="line-modified">1477          GSource *child_source)</span>
1478 {
1479   GMainContext *context;
1480 
1481   g_return_if_fail (source != NULL);
1482   g_return_if_fail (child_source != NULL);
1483   g_return_if_fail (!SOURCE_DESTROYED (source));
1484   g_return_if_fail (!SOURCE_DESTROYED (child_source));
1485   g_return_if_fail (child_source-&gt;context == NULL);
1486   g_return_if_fail (child_source-&gt;priv-&gt;parent_source == NULL);
1487 
1488   context = source-&gt;context;
1489 
1490   if (context)
1491     LOCK_CONTEXT (context);
1492 
1493   TRACE (GLIB_SOURCE_ADD_CHILD_SOURCE (source, child_source));
1494 
1495   source-&gt;priv-&gt;child_sources = g_slist_prepend (source-&gt;priv-&gt;child_sources,
<span class="line-modified">1496              g_source_ref (child_source));</span>
1497   child_source-&gt;priv-&gt;parent_source = source;
1498   g_source_set_priority_unlocked (child_source, NULL, source-&gt;priority);
1499   if (SOURCE_BLOCKED (source))
1500     block_source (child_source);
1501 
1502   if (context)
1503     {
1504       g_source_attach_unlocked (child_source, context, TRUE);
1505       UNLOCK_CONTEXT (context);
1506     }
1507 }
1508 
1509 static void
1510 g_child_source_remove_internal (GSource *child_source,
1511                                 GMainContext *context)
1512 {
1513   GSource *parent_source = child_source-&gt;priv-&gt;parent_source;
1514 
1515   parent_source-&gt;priv-&gt;child_sources =
1516     g_slist_remove (parent_source-&gt;priv-&gt;child_sources, child_source);
</pre>
<hr />
<pre>
1518 
1519   g_source_destroy_internal (child_source, context, TRUE);
1520   g_source_unref_internal (child_source, context, TRUE);
1521 }
1522 
1523 /**
1524  * g_source_remove_child_source:
1525  * @source:a #GSource
1526  * @child_source: a #GSource previously passed to
1527  *     g_source_add_child_source().
1528  *
1529  * Detaches @child_source from @source and destroys it.
1530  *
1531  * This API is only intended to be used by implementations of #GSource.
1532  * Do not call this API on a #GSource that you did not create.
1533  *
1534  * Since: 2.28
1535  **/
1536 void
1537 g_source_remove_child_source (GSource *source,
<span class="line-modified">1538             GSource *child_source)</span>
1539 {
1540   GMainContext *context;
1541 
1542   g_return_if_fail (source != NULL);
1543   g_return_if_fail (child_source != NULL);
1544   g_return_if_fail (child_source-&gt;priv-&gt;parent_source == source);
1545   g_return_if_fail (!SOURCE_DESTROYED (source));
1546   g_return_if_fail (!SOURCE_DESTROYED (child_source));
1547 
1548   context = source-&gt;context;
1549 
1550   if (context)
1551     LOCK_CONTEXT (context);
1552 
1553   g_child_source_remove_internal (child_source, context);
1554 
1555   if (context)
1556     UNLOCK_CONTEXT (context);
1557 }
1558 
</pre>
<hr />
<pre>
1562   GSourceCallback *callback = cb_data;
1563 
1564   g_atomic_int_inc (&amp;callback-&gt;ref_count);
1565 }
1566 
1567 static void
1568 g_source_callback_unref (gpointer cb_data)
1569 {
1570   GSourceCallback *callback = cb_data;
1571 
1572   if (g_atomic_int_dec_and_test (&amp;callback-&gt;ref_count))
1573     {
1574       if (callback-&gt;notify)
1575         callback-&gt;notify (callback-&gt;data);
1576       g_free (callback);
1577     }
1578 }
1579 
1580 static void
1581 g_source_callback_get (gpointer     cb_data,
<span class="line-modified">1582            GSource     *source,</span>
<span class="line-modified">1583            GSourceFunc *func,</span>
<span class="line-modified">1584            gpointer    *data)</span>
1585 {
1586   GSourceCallback *callback = cb_data;
1587 
1588   *func = callback-&gt;func;
1589   *data = callback-&gt;data;
1590 }
1591 
1592 static GSourceCallbackFuncs g_source_callback_funcs = {
1593   g_source_callback_ref,
1594   g_source_callback_unref,
1595   g_source_callback_get,
1596 };
1597 
1598 /**
1599  * g_source_set_callback_indirect:
1600  * @source: the source
1601  * @callback_data: pointer to callback data &quot;object&quot;
1602  * @callback_funcs: functions for reference counting @callback_data
1603  *                  and getting the callback and data
1604  *
1605  * Sets the callback function storing the data as a refcounted callback
1606  * &quot;object&quot;. This is used internally. Note that calling
1607  * g_source_set_callback_indirect() assumes
1608  * an initial reference count on @callback_data, and thus
1609  * @callback_funcs-&gt;unref will eventually be called once more
1610  * than @callback_funcs-&gt;ref.
<span class="line-added">1611  *</span>
<span class="line-added">1612  * It is safe to call this function multiple times on a source which has already</span>
<span class="line-added">1613  * been attached to a context. The changes will take effect for the next time</span>
<span class="line-added">1614  * the source is dispatched after this call returns.</span>
1615  **/
1616 void
1617 g_source_set_callback_indirect (GSource              *source,
<span class="line-modified">1618         gpointer              callback_data,</span>
<span class="line-modified">1619         GSourceCallbackFuncs *callback_funcs)</span>
1620 {
1621   GMainContext *context;
1622   gpointer old_cb_data;
1623   GSourceCallbackFuncs *old_cb_funcs;
1624 
1625   g_return_if_fail (source != NULL);
1626   g_return_if_fail (callback_funcs != NULL || callback_data == NULL);
1627 
1628   context = source-&gt;context;
1629 
1630   if (context)
1631     LOCK_CONTEXT (context);
1632 
1633   if (callback_funcs != &amp;g_source_callback_funcs)
<span class="line-modified">1634     {</span>
<span class="line-modified">1635       TRACE (GLIB_SOURCE_SET_CALLBACK_INDIRECT (source, callback_data,</span>
<span class="line-modified">1636                                                 callback_funcs-&gt;ref,</span>
<span class="line-modified">1637                                                 callback_funcs-&gt;unref,</span>
<span class="line-added">1638                                                 callback_funcs-&gt;get));</span>
<span class="line-added">1639     }</span>
1640 
1641   old_cb_data = source-&gt;callback_data;
1642   old_cb_funcs = source-&gt;callback_funcs;
1643 
1644   source-&gt;callback_data = callback_data;
1645   source-&gt;callback_funcs = callback_funcs;
1646 
1647   if (context)
1648     UNLOCK_CONTEXT (context);
1649 
1650   if (old_cb_funcs)
1651     old_cb_funcs-&gt;unref (old_cb_data);
1652 }
1653 
1654 /**
1655  * g_source_set_callback:
1656  * @source: the source
1657  * @func: a callback function
1658  * @data: the data to pass to callback function
1659  * @notify: (nullable): a function to call when @data is no longer in use, or %NULL.
1660  *
1661  * Sets the callback function for a source. The callback for a source is
1662  * called from the source&#39;s dispatch function.
1663  *
1664  * The exact type of @func depends on the type of source; ie. you
1665  * should not count on @func being called with @data as its first
1666  * parameter. Cast @func with G_SOURCE_FUNC() to avoid warnings about
1667  * incompatible function types.
1668  *
1669  * See [memory management of sources][mainloop-memory-management] for details
1670  * on how to handle memory management of @data.
1671  *
1672  * Typically, you won&#39;t use this function. Instead use functions specific
<span class="line-modified">1673  * to the type of source you are using, such as g_idle_add() or g_timeout_add().</span>
<span class="line-added">1674  *</span>
<span class="line-added">1675  * It is safe to call this function multiple times on a source which has already</span>
<span class="line-added">1676  * been attached to a context. The changes will take effect for the next time</span>
<span class="line-added">1677  * the source is dispatched after this call returns.</span>
1678  **/
1679 void
1680 g_source_set_callback (GSource        *source,
<span class="line-modified">1681            GSourceFunc     func,</span>
<span class="line-modified">1682            gpointer        data,</span>
<span class="line-modified">1683            GDestroyNotify  notify)</span>
1684 {
1685   GSourceCallback *new_callback;
1686 
1687   g_return_if_fail (source != NULL);
1688 #ifdef GSTREAMER_LITE
1689   if (source == NULL)
1690     return;
1691 #endif // GSTREAMER_LITE
1692 
1693   TRACE (GLIB_SOURCE_SET_CALLBACK (source, func, data, notify));
1694 
1695   new_callback = g_new (GSourceCallback, 1);
1696 
1697   new_callback-&gt;ref_count = 1;
1698   new_callback-&gt;func = func;
1699   new_callback-&gt;data = data;
1700   new_callback-&gt;notify = notify;
1701 
1702   g_source_set_callback_indirect (source, new_callback, &amp;g_source_callback_funcs);
1703 }
1704 
1705 
1706 /**
1707  * g_source_set_funcs:
1708  * @source: a #GSource
1709  * @funcs: the new #GSourceFuncs
1710  *
1711  * Sets the source functions (can be used to override
1712  * default implementations) of an unattached source.
1713  *
1714  * Since: 2.12
1715  */
1716 void
1717 g_source_set_funcs (GSource     *source,
<span class="line-modified">1718              GSourceFuncs *funcs)</span>
1719 {
1720   g_return_if_fail (source != NULL);
1721   g_return_if_fail (source-&gt;context == NULL);
<span class="line-modified">1722   g_return_if_fail (g_atomic_int_get (&amp;source-&gt;ref_count) &gt; 0);</span>
1723   g_return_if_fail (funcs != NULL);
1724 
1725   source-&gt;source_funcs = funcs;
1726 }
1727 
1728 static void
1729 g_source_set_priority_unlocked (GSource      *source,
<span class="line-modified">1730         GMainContext *context,</span>
<span class="line-modified">1731         gint          priority)</span>
1732 {
1733   GSList *tmp_list;
1734 
1735 #ifdef GSTREAMER_LITE
1736   if (source == NULL || source-&gt;priv == NULL || source-&gt;priv-&gt;parent_source == NULL)
1737     return;
1738 
1739   if (context == NULL)
1740     return;
1741 #endif // GSTREAMER_LITE
1742 
1743   g_return_if_fail (source-&gt;priv-&gt;parent_source == NULL ||
<span class="line-modified">1744         source-&gt;priv-&gt;parent_source-&gt;priority == priority);</span>
1745 
1746   TRACE (GLIB_SOURCE_SET_PRIORITY (source, context, priority));
1747 
1748   if (context)
1749     {
1750       /* Remove the source from the context&#39;s source and then
1751        * add it back after so it is sorted in the correct place
1752        */
1753       source_remove_from_context (source, source-&gt;context);
1754     }
1755 
1756   source-&gt;priority = priority;
1757 
1758   if (context)
1759     {
1760       source_add_to_context (source, source-&gt;context);
1761 
1762       if (!SOURCE_BLOCKED (source))
<span class="line-modified">1763   {</span>
<span class="line-modified">1764     tmp_list = source-&gt;poll_fds;</span>
<span class="line-modified">1765     while (tmp_list)</span>
<span class="line-modified">1766       {</span>
<span class="line-modified">1767         g_main_context_remove_poll_unlocked (context, tmp_list-&gt;data);</span>
<span class="line-modified">1768         g_main_context_add_poll_unlocked (context, priority, tmp_list-&gt;data);</span>
1769 
<span class="line-modified">1770         tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">1771       }</span>
1772 
1773           for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
1774             {
1775               g_main_context_remove_poll_unlocked (context, tmp_list-&gt;data);
1776               g_main_context_add_poll_unlocked (context, priority, tmp_list-&gt;data);
1777             }
<span class="line-modified">1778   }</span>
1779     }
1780 
1781   if (source-&gt;priv-&gt;child_sources)
1782     {
1783       tmp_list = source-&gt;priv-&gt;child_sources;
1784       while (tmp_list)
<span class="line-modified">1785   {</span>
<span class="line-modified">1786     g_source_set_priority_unlocked (tmp_list-&gt;data, context, priority);</span>
<span class="line-modified">1787     tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">1788   }</span>
1789     }
1790 }
1791 
1792 /**
1793  * g_source_set_priority:
1794  * @source: a #GSource
1795  * @priority: the new priority.
1796  *
1797  * Sets the priority of a source. While the main loop is being run, a
1798  * source will be dispatched if it is ready to be dispatched and no
1799  * sources at a higher (numerically smaller) priority are ready to be
1800  * dispatched.
1801  *
1802  * A child source always has the same priority as its parent.  It is not
1803  * permitted to change the priority of a source once it has been added
1804  * as a child of another source.
1805  **/
1806 void
1807 g_source_set_priority (GSource  *source,
<span class="line-modified">1808            gint      priority)</span>
1809 {
1810   GMainContext *context;
1811 
1812 #ifdef GSTREAMER_LITE
1813   if (source == NULL || source-&gt;priv == NULL || source-&gt;priv-&gt;parent_source == NULL)
1814     return;
1815 #endif // GSTREAMER_LITE
1816 
1817   g_return_if_fail (source != NULL);
1818   g_return_if_fail (source-&gt;priv-&gt;parent_source == NULL);
1819 
1820   context = source-&gt;context;
1821 
1822   if (context)
1823     LOCK_CONTEXT (context);
1824   g_source_set_priority_unlocked (source, context, priority);
1825   if (context)
1826     UNLOCK_CONTEXT (context);
1827 }
1828 
</pre>
<hr />
<pre>
1936 gint64
1937 g_source_get_ready_time (GSource *source)
1938 {
1939   g_return_val_if_fail (source != NULL, -1);
1940 
1941   return source-&gt;priv-&gt;ready_time;
1942 }
1943 
1944 /**
1945  * g_source_set_can_recurse:
1946  * @source: a #GSource
1947  * @can_recurse: whether recursion is allowed for this source
1948  *
1949  * Sets whether a source can be called recursively. If @can_recurse is
1950  * %TRUE, then while the source is being dispatched then this source
1951  * will be processed normally. Otherwise, all processing of this
1952  * source is blocked until the dispatch function returns.
1953  **/
1954 void
1955 g_source_set_can_recurse (GSource  *source,
<span class="line-modified">1956         gboolean  can_recurse)</span>
1957 {
1958   GMainContext *context;
1959 
1960   g_return_if_fail (source != NULL);
1961 
1962   context = source-&gt;context;
1963 
1964   if (context)
1965     LOCK_CONTEXT (context);
1966 
1967   if (can_recurse)
1968     source-&gt;flags |= G_SOURCE_CAN_RECURSE;
1969   else
1970     source-&gt;flags &amp;= ~G_SOURCE_CAN_RECURSE;
1971 
1972   if (context)
1973     UNLOCK_CONTEXT (context);
1974 }
1975 
1976 /**
</pre>
<hr />
<pre>
2095 
2096   source = g_main_context_find_source_by_id (NULL, tag);
2097   if (source == NULL)
2098     return;
2099 
2100   g_source_set_name (source, name);
2101 }
2102 
2103 
2104 /**
2105  * g_source_ref:
2106  * @source: a #GSource
2107  *
2108  * Increases the reference count on a source by one.
2109  *
2110  * Returns: @source
2111  **/
2112 GSource *
2113 g_source_ref (GSource *source)
2114 {


2115   g_return_val_if_fail (source != NULL, NULL);
2116 
<span class="line-modified">2117   g_atomic_int_inc (&amp;source-&gt;ref_count);</span>








2118 
2119   return source;
2120 }
2121 
2122 /* g_source_unref() but possible to call within context lock
2123  */
2124 static void
2125 g_source_unref_internal (GSource      *source,
<span class="line-modified">2126        GMainContext *context,</span>
<span class="line-modified">2127        gboolean      have_lock)</span>
2128 {
2129   gpointer old_cb_data = NULL;
2130   GSourceCallbackFuncs *old_cb_funcs = NULL;
2131 
2132   g_return_if_fail (source != NULL);
2133 
2134   if (!have_lock &amp;&amp; context)
2135     LOCK_CONTEXT (context);
2136 
<span class="line-modified">2137   if (g_atomic_int_dec_and_test (&amp;source-&gt;ref_count))</span>

2138     {
2139       TRACE (GLIB_SOURCE_BEFORE_FREE (source, context,
2140                                       source-&gt;source_funcs-&gt;finalize));
2141 
2142       old_cb_data = source-&gt;callback_data;
2143       old_cb_funcs = source-&gt;callback_funcs;
2144 
2145       source-&gt;callback_data = NULL;
2146       source-&gt;callback_funcs = NULL;
2147 
2148       if (context)
<span class="line-modified">2149   {</span>
<span class="line-modified">2150     if (!SOURCE_DESTROYED (source))</span>
<span class="line-modified">2151       g_warning (G_STRLOC &quot;: ref_count == 0, but source was still attached to a context!&quot;);</span>
<span class="line-modified">2152     source_remove_from_context (source, context);</span>
2153 
2154           g_hash_table_remove (context-&gt;sources, GUINT_TO_POINTER (source-&gt;source_id));
<span class="line-modified">2155   }</span>
2156 
2157       if (source-&gt;source_funcs-&gt;finalize)
<span class="line-modified">2158   {</span>
2159           /* Temporarily increase the ref count again so that GSource methods
2160            * can be called from finalize(). */
<span class="line-modified">2161           g_atomic_int_inc (&amp;source-&gt;ref_count);</span>
<span class="line-modified">2162     if (context)</span>
<span class="line-modified">2163       UNLOCK_CONTEXT (context);</span>
<span class="line-modified">2164     source-&gt;source_funcs-&gt;finalize (source);</span>
<span class="line-modified">2165     if (context)</span>
<span class="line-modified">2166       LOCK_CONTEXT (context);</span>
<span class="line-modified">2167           g_atomic_int_add (&amp;source-&gt;ref_count, -1);</span>
<span class="line-modified">2168   }</span>
2169 
2170       if (old_cb_funcs)
2171         {
2172           /* Temporarily increase the ref count again so that GSource methods
2173            * can be called from callback_funcs.unref(). */
<span class="line-modified">2174           g_atomic_int_inc (&amp;source-&gt;ref_count);</span>
2175           if (context)
2176             UNLOCK_CONTEXT (context);
2177 
2178           old_cb_funcs-&gt;unref (old_cb_data);
2179 
2180           if (context)
2181             LOCK_CONTEXT (context);
<span class="line-modified">2182           g_atomic_int_add (&amp;source-&gt;ref_count, -1);</span>
2183         }
2184 
2185       g_free (source-&gt;name);
2186       source-&gt;name = NULL;
2187 
2188       g_slist_free (source-&gt;poll_fds);
2189       source-&gt;poll_fds = NULL;
2190 
2191       g_slist_free_full (source-&gt;priv-&gt;fds, g_free);
2192 
2193       while (source-&gt;priv-&gt;child_sources)
2194         {
2195           GSource *child_source = source-&gt;priv-&gt;child_sources-&gt;data;
2196 
2197           source-&gt;priv-&gt;child_sources =
2198             g_slist_remove (source-&gt;priv-&gt;child_sources, child_source);
2199           child_source-&gt;priv-&gt;parent_source = NULL;
2200 
2201           g_source_unref_internal (child_source, context, have_lock);
2202         }
2203 
2204       g_slice_free (GSourcePrivate, source-&gt;priv);
2205       source-&gt;priv = NULL;
2206 
2207       g_free (source);
2208     }
2209 
2210   if (!have_lock &amp;&amp; context)
2211     UNLOCK_CONTEXT (context);
<span class="line-modified">2212 }</span>
2213 
2214 /**
2215  * g_source_unref:
2216  * @source: a #GSource
2217  *
2218  * Decreases the reference count of a source by one. If the
2219  * resulting reference count is zero the source and associated
2220  * memory will be destroyed.
2221  **/
2222 void
2223 g_source_unref (GSource *source)
2224 {
2225   g_return_if_fail (source != NULL);
2226 #ifdef GSTREAMER_LITE
2227   if (source == NULL)
2228     return;
2229 #endif // GSTREAMER_LITE
2230 
2231   g_source_unref_internal (source, source-&gt;context, FALSE);
2232 }
2233 
2234 /**
2235  * g_main_context_find_source_by_id:
2236  * @context: (nullable): a #GMainContext (if %NULL, the default context will be used)
2237  * @source_id: the source ID, as returned by g_source_get_id().
2238  *
2239  * Finds a #GSource given a pair of context and ID.
2240  *
<span class="line-modified">2241  * It is a programmer error to attempt to look up a non-existent source.</span>
2242  *
2243  * More specifically: source IDs can be reissued after a source has been
2244  * destroyed and therefore it is never valid to use this function with a
2245  * source ID which may have already been removed.  An example is when
2246  * scheduling an idle to run in another thread with g_idle_add(): the
2247  * idle may already have run and been removed by the time this function
2248  * is called on its (now invalid) source ID.  This source ID may have
2249  * been reissued, leading to the operation being performed against the
2250  * wrong source.
2251  *
2252  * Returns: (transfer none): the #GSource
2253  **/
2254 GSource *
2255 g_main_context_find_source_by_id (GMainContext *context,
2256                                   guint         source_id)
2257 {
2258   GSource *source;
2259 
2260   g_return_val_if_fail (source_id &gt; 0, NULL);
2261 
</pre>
<hr />
<pre>
2269   if (source &amp;&amp; SOURCE_DESTROYED (source))
2270     source = NULL;
2271 
2272   return source;
2273 }
2274 
2275 /**
2276  * g_main_context_find_source_by_funcs_user_data:
2277  * @context: (nullable): a #GMainContext (if %NULL, the default context will be used).
2278  * @funcs: the @source_funcs passed to g_source_new().
2279  * @user_data: the user data from the callback.
2280  *
2281  * Finds a source with the given source functions and user data.  If
2282  * multiple sources exist with the same source function and user data,
2283  * the first one found will be returned.
2284  *
2285  * Returns: (transfer none): the source, if one was found, otherwise %NULL
2286  **/
2287 GSource *
2288 g_main_context_find_source_by_funcs_user_data (GMainContext *context,
<span class="line-modified">2289                  GSourceFuncs *funcs,</span>
<span class="line-modified">2290                  gpointer      user_data)</span>
2291 {
2292   GSourceIter iter;
2293   GSource *source;
2294 
2295   g_return_val_if_fail (funcs != NULL, NULL);
2296 
2297   if (context == NULL)
2298     context = g_main_context_default ();
2299 
2300   LOCK_CONTEXT (context);
2301 
2302   g_source_iter_init (&amp;iter, context, FALSE);
2303   while (g_source_iter_next (&amp;iter, &amp;source))
2304     {
2305       if (!SOURCE_DESTROYED (source) &amp;&amp;
<span class="line-modified">2306     source-&gt;source_funcs == funcs &amp;&amp;</span>
<span class="line-modified">2307     source-&gt;callback_funcs)</span>
<span class="line-modified">2308   {</span>
<span class="line-modified">2309     GSourceFunc callback;</span>
<span class="line-modified">2310     gpointer callback_data;</span>
2311 
<span class="line-modified">2312     source-&gt;callback_funcs-&gt;get (source-&gt;callback_data, source, &amp;callback, &amp;callback_data);</span>
2313 
<span class="line-modified">2314     if (callback_data == user_data)</span>
<span class="line-modified">2315       break;</span>
<span class="line-modified">2316   }</span>
2317     }
2318   g_source_iter_clear (&amp;iter);
2319 
2320   UNLOCK_CONTEXT (context);
2321 
2322   return source;
2323 }
2324 
2325 /**
2326  * g_main_context_find_source_by_user_data:
2327  * @context: a #GMainContext
2328  * @user_data: the user_data for the callback.
2329  *
2330  * Finds a source with the given user data for the callback.  If
2331  * multiple sources exist with the same user data, the first
2332  * one found will be returned.
2333  *
2334  * Returns: (transfer none): the source, if one was found, otherwise %NULL
2335  **/
2336 GSource *
2337 g_main_context_find_source_by_user_data (GMainContext *context,
<span class="line-modified">2338            gpointer      user_data)</span>
2339 {
2340   GSourceIter iter;
2341   GSource *source;
2342 
2343   if (context == NULL)
2344     context = g_main_context_default ();
2345 
2346   LOCK_CONTEXT (context);
2347 
2348   g_source_iter_init (&amp;iter, context, FALSE);
2349   while (g_source_iter_next (&amp;iter, &amp;source))
2350     {
2351       if (!SOURCE_DESTROYED (source) &amp;&amp;
<span class="line-modified">2352     source-&gt;callback_funcs)</span>
<span class="line-modified">2353   {</span>
<span class="line-modified">2354     GSourceFunc callback;</span>
<span class="line-modified">2355     gpointer callback_data = NULL;</span>
2356 
<span class="line-modified">2357     source-&gt;callback_funcs-&gt;get (source-&gt;callback_data, source, &amp;callback, &amp;callback_data);</span>
2358 
<span class="line-modified">2359     if (callback_data == user_data)</span>
<span class="line-modified">2360       break;</span>
<span class="line-modified">2361   }</span>
2362     }
2363   g_source_iter_clear (&amp;iter);
2364 
2365   UNLOCK_CONTEXT (context);
2366 
2367   return source;
2368 }
2369 
2370 /**
2371  * g_source_remove:
2372  * @tag: the ID of the source to remove.
2373  *
2374  * Removes the source with the given ID from the default main context. You must
2375  * use g_source_destroy() for sources added to a non-default main context.
2376  *
2377  * The ID of a #GSource is given by g_source_get_id(), or will be
2378  * returned by the functions g_source_attach(), g_idle_add(),
2379  * g_idle_add_full(), g_timeout_add(), g_timeout_add_full(),
2380  * g_child_watch_add(), g_child_watch_add_full(), g_io_add_watch(), and
2381  * g_io_add_watch_full().
</pre>
<hr />
<pre>
2430       g_source_destroy (source);
2431       return TRUE;
2432     }
2433   else
2434     return FALSE;
2435 }
2436 
2437 /**
2438  * g_source_remove_by_funcs_user_data:
2439  * @funcs: The @source_funcs passed to g_source_new()
2440  * @user_data: the user data for the callback
2441  *
2442  * Removes a source from the default main loop context given the
2443  * source functions and user data. If multiple sources exist with the
2444  * same source functions and user data, only one will be destroyed.
2445  *
2446  * Returns: %TRUE if a source was found and removed.
2447  **/
2448 gboolean
2449 g_source_remove_by_funcs_user_data (GSourceFuncs *funcs,
<span class="line-modified">2450             gpointer      user_data)</span>
2451 {
2452   GSource *source;
2453 
2454   g_return_val_if_fail (funcs != NULL, FALSE);
2455 
2456   source = g_main_context_find_source_by_funcs_user_data (NULL, funcs, user_data);
2457   if (source)
2458     {
2459       g_source_destroy (source);
2460       return TRUE;
2461     }
2462   else
2463     return FALSE;
2464 }
2465 
2466 /**
2467  * g_clear_handle_id: (skip)
2468  * @tag_ptr: (not nullable): a pointer to the handler ID
2469  * @clear_func: (not nullable): the function to call to clear the handler
2470  *
</pre>
<hr />
<pre>
2666                         gpointer  tag)
2667 {
2668   GPollFD *poll_fd;
2669 
2670   g_return_val_if_fail (source != NULL, 0);
2671   g_return_val_if_fail (g_slist_find (source-&gt;priv-&gt;fds, tag), 0);
2672 
2673   poll_fd = tag;
2674 
2675   return poll_fd-&gt;revents;
2676 }
2677 #endif /* G_OS_UNIX */
2678 
2679 /**
2680  * g_get_current_time:
2681  * @result: #GTimeVal structure in which to store current time.
2682  *
2683  * Equivalent to the UNIX gettimeofday() function, but portable.
2684  *
2685  * You may find g_get_real_time() to be more convenient.
<span class="line-added">2686  *</span>
<span class="line-added">2687  * Deprecated: 2.62: #GTimeVal is not year-2038-safe. Use g_get_real_time()</span>
<span class="line-added">2688  *    instead.</span>
2689  **/
<span class="line-added">2690 G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
2691 void
2692 g_get_current_time (GTimeVal *result)
2693 {
<span class="line-modified">2694   gint64 tv;</span>












2695 
2696   g_return_if_fail (result != NULL);
2697 
<span class="line-modified">2698   tv = g_get_real_time ();</span>

2699 
<span class="line-modified">2700   result-&gt;tv_sec = tv / 1000000;</span>
<span class="line-modified">2701   result-&gt;tv_usec = tv % 1000000;</span>







2702 }
<span class="line-added">2703 G_GNUC_END_IGNORE_DEPRECATIONS</span>
2704 
2705 /**
2706  * g_get_real_time:
2707  *
2708  * Queries the system wall-clock time.
2709  *
2710  * This call is functionally equivalent to g_get_current_time() except
2711  * that the return value is often more convenient than dealing with a
2712  * #GTimeVal.
2713  *
2714  * You should only use this call if you are actually interested in the real
2715  * wall-clock time.  g_get_monotonic_time() is probably more useful for
2716  * measuring intervals.
2717  *
2718  * Returns: the number of microseconds since January 1, 1970 UTC.
2719  *
2720  * Since: 2.28
2721  **/
2722 gint64
2723 g_get_real_time (void)
2724 {
<span class="line-modified">2725 #ifndef G_OS_WIN32</span>
<span class="line-added">2726   struct timeval r;</span>
2727 
<span class="line-modified">2728   /* this is required on alpha, there the timeval structs are ints</span>
<span class="line-added">2729    * not longs and a cast only would fail horribly */</span>
<span class="line-added">2730   gettimeofday (&amp;r, NULL);</span>
2731 
<span class="line-modified">2732   return (((gint64) r.tv_sec) * 1000000) + r.tv_usec;</span>
<span class="line-added">2733 #else</span>
<span class="line-added">2734   FILETIME ft;</span>
<span class="line-added">2735   guint64 time64;</span>
<span class="line-added">2736 </span>
<span class="line-added">2737   GetSystemTimeAsFileTime (&amp;ft);</span>
<span class="line-added">2738   memmove (&amp;time64, &amp;ft, sizeof (FILETIME));</span>
<span class="line-added">2739 </span>
<span class="line-added">2740   /* Convert from 100s of nanoseconds since 1601-01-01</span>
<span class="line-added">2741    * to Unix epoch. This is Y2038 safe.</span>
<span class="line-added">2742    */</span>
<span class="line-added">2743   time64 -= G_GINT64_CONSTANT (116444736000000000);</span>
<span class="line-added">2744   time64 /= 10;</span>
<span class="line-added">2745 </span>
<span class="line-added">2746   return time64;</span>
<span class="line-added">2747 #endif</span>
2748 }
2749 
2750 /**
2751  * g_get_monotonic_time:
2752  *
2753  * Queries the system monotonic time.
2754  *
2755  * The monotonic clock will always increase and doesn&#39;t suffer
2756  * discontinuities when the user (or NTP) changes the system time.  It
2757  * may or may not continue to tick during times where the machine is
2758  * suspended.
2759  *
2760  * We try to use the clock that corresponds as closely as possible to
2761  * the passage of time as measured by system calls such as poll() but it
2762  * may not always be possible to do this.
2763  *
2764  * Returns: the monotonic time, in microseconds
2765  *
2766  * Since: 2.28
2767  **/
2768 #if defined (G_OS_WIN32)
2769 /* NOTE:
2770  * time_usec = ticks_since_boot * usec_per_sec / ticks_per_sec
2771  *
2772  * Doing (ticks_since_boot * usec_per_sec) before the division can overflow 64 bits
2773  * (ticks_since_boot  / ticks_per_sec) and then multiply would not be accurate enough.
2774  * So for now we calculate (usec_per_sec / ticks_per_sec) and use floating point
2775  */
2776 static gdouble g_monotonic_usec_per_tick = 0;
2777 
2778 void
2779 g_clock_win32_init (void)
2780 {
2781   LARGE_INTEGER freq;
2782 
2783   if (!QueryPerformanceFrequency (&amp;freq) || freq.QuadPart == 0)
2784     {
2785       /* The documentation says that this should never happen */
2786       g_assert_not_reached ();
2787       return;
<span class="line-modified">2788     }</span>
2789 
2790   g_monotonic_usec_per_tick = (gdouble)G_USEC_PER_SEC / freq.QuadPart;
2791 }
2792 
2793 gint64
2794 g_get_monotonic_time (void)
2795 {
2796   if (G_LIKELY (g_monotonic_usec_per_tick != 0))
2797     {
2798       LARGE_INTEGER ticks;
2799 
2800       if (QueryPerformanceCounter (&amp;ticks))
2801         return (gint64)(ticks.QuadPart * g_monotonic_usec_per_tick);
2802 
2803       g_warning (&quot;QueryPerformanceCounter Failed (%lu)&quot;, GetLastError ());
2804       g_monotonic_usec_per_tick = 0;
2805     }
2806 
2807   return 0;
<span class="line-modified">2808 }</span>
2809 #elif defined(HAVE_MACH_MACH_TIME_H) /* Mac OS */
2810 gint64
2811 g_get_monotonic_time (void)
2812 {
2813   static mach_timebase_info_data_t timebase_info;
2814 
2815   if (timebase_info.denom == 0)
2816     {
2817       /* This is a fraction that we must use to scale
2818        * mach_absolute_time() by in order to reach nanoseconds.
2819        *
2820        * We&#39;ve only ever observed this to be 1/1, but maybe it could be
2821        * 1000/1 if mach time is microseconds already, or 1/1000 if
2822        * picoseconds.  Try to deal nicely with that.
2823        */
2824       mach_timebase_info (&amp;timebase_info);
2825 
2826       /* We actually want microseconds... */
2827       if (timebase_info.numer % 1000 == 0)
2828         timebase_info.numer /= 1000;
</pre>
<hr />
<pre>
2854 }
2855 #else
2856 gint64
2857 g_get_monotonic_time (void)
2858 {
2859   struct timespec ts;
2860   gint result;
2861 
2862   result = clock_gettime (CLOCK_MONOTONIC, &amp;ts);
2863 
2864   if G_UNLIKELY (result != 0)
2865     g_error (&quot;GLib requires working CLOCK_MONOTONIC&quot;);
2866 
2867   return (((gint64) ts.tv_sec) * 1000000) + (ts.tv_nsec / 1000);
2868 }
2869 #endif
2870 
2871 static void
2872 g_main_dispatch_free (gpointer dispatch)
2873 {
<span class="line-modified">2874   g_free (dispatch);</span>
2875 }
2876 
2877 /* Running the main loop */
2878 
2879 static GMainDispatch *
2880 get_dispatch (void)
2881 {
2882   static GPrivate depth_private = G_PRIVATE_INIT (g_main_dispatch_free);
2883   GMainDispatch *dispatch;
2884 
2885   dispatch = g_private_get (&amp;depth_private);
2886 
2887   if (!dispatch)
<span class="line-modified">2888     dispatch = g_private_set_alloc0 (&amp;depth_private, sizeof (GMainDispatch));</span>



2889 
2890   return dispatch;
2891 }
2892 
2893 /**
2894  * g_main_depth:
2895  *
2896  * Returns the depth of the stack of calls to
2897  * g_main_context_dispatch() on any #GMainContext in the current thread.
2898  *  That is, when called from the toplevel, it gives 0. When
2899  * called from within a callback from g_main_context_iteration()
2900  * (or g_main_loop_run(), etc.) it returns 1. When called from within
2901  * a callback to a recursive call to g_main_context_iteration(),
2902  * it returns 2. And so forth.
2903  *
2904  * This function is useful in a situation like the following:
2905  * Imagine an extremely simple &quot;garbage collected&quot; system.
2906  *
2907  * |[&lt;!-- language=&quot;C&quot; --&gt;
2908  * static GList *free_list;
</pre>
<hr />
<pre>
3115 
3116   source-&gt;flags |= G_SOURCE_BLOCKED;
3117 
3118   if (source-&gt;context)
3119     {
3120       tmp_list = source-&gt;poll_fds;
3121       while (tmp_list)
3122         {
3123           g_main_context_remove_poll_unlocked (source-&gt;context, tmp_list-&gt;data);
3124           tmp_list = tmp_list-&gt;next;
3125         }
3126 
3127       for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
3128         g_main_context_remove_poll_unlocked (source-&gt;context, tmp_list-&gt;data);
3129     }
3130 
3131   if (source-&gt;priv &amp;&amp; source-&gt;priv-&gt;child_sources)
3132     {
3133       tmp_list = source-&gt;priv-&gt;child_sources;
3134       while (tmp_list)
<span class="line-modified">3135   {</span>
<span class="line-modified">3136     block_source (tmp_list-&gt;data);</span>
<span class="line-modified">3137     tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">3138   }</span>
3139     }
3140 }
3141 
3142 /* HOLDS: source-&gt;context&#39;s lock */
3143 static void
3144 unblock_source (GSource *source)
3145 {
3146   GSList *tmp_list;
3147 
3148   g_return_if_fail (SOURCE_BLOCKED (source)); /* Source already unblocked */
3149   g_return_if_fail (!SOURCE_DESTROYED (source));
3150 
3151   source-&gt;flags &amp;= ~G_SOURCE_BLOCKED;
3152 
3153   tmp_list = source-&gt;poll_fds;
3154   while (tmp_list)
3155     {
3156       g_main_context_add_poll_unlocked (source-&gt;context, source-&gt;priority, tmp_list-&gt;data);
3157       tmp_list = tmp_list-&gt;next;
3158     }
3159 
3160   for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
3161     g_main_context_add_poll_unlocked (source-&gt;context, source-&gt;priority, tmp_list-&gt;data);
3162 
3163   if (source-&gt;priv &amp;&amp; source-&gt;priv-&gt;child_sources)
3164     {
3165       tmp_list = source-&gt;priv-&gt;child_sources;
3166       while (tmp_list)
<span class="line-modified">3167   {</span>
<span class="line-modified">3168     unblock_source (tmp_list-&gt;data);</span>
<span class="line-modified">3169     tmp_list = tmp_list-&gt;next;</span>
<span class="line-modified">3170   }</span>
3171     }
3172 }
3173 
3174 /* HOLDS: context&#39;s lock */
3175 static void
3176 g_main_dispatch (GMainContext *context)
3177 {
3178   GMainDispatch *current = get_dispatch ();
3179   guint i;
3180 
3181   for (i = 0; i &lt; context-&gt;pending_dispatches-&gt;len; i++)
3182     {
3183       GSource *source = context-&gt;pending_dispatches-&gt;pdata[i];
3184 
3185       context-&gt;pending_dispatches-&gt;pdata[i] = NULL;
3186       g_assert (source);
3187 
3188       source-&gt;flags &amp;= ~G_SOURCE_READY;
3189 
3190       if (!SOURCE_DESTROYED (source))
<span class="line-modified">3191   {</span>
<span class="line-modified">3192     gboolean was_in_call;</span>
<span class="line-modified">3193     gpointer user_data = NULL;</span>
<span class="line-modified">3194     GSourceFunc callback = NULL;</span>
<span class="line-modified">3195     GSourceCallbackFuncs *cb_funcs;</span>
<span class="line-modified">3196     gpointer cb_data;</span>
<span class="line-modified">3197     gboolean need_destroy;</span>
<span class="line-modified">3198 </span>
<span class="line-modified">3199     gboolean (*dispatch) (GSource *,</span>
<span class="line-modified">3200         GSourceFunc,</span>
<span class="line-modified">3201         gpointer);</span>
3202           GSource *prev_source;
3203 
<span class="line-modified">3204     dispatch = source-&gt;source_funcs-&gt;dispatch;</span>
<span class="line-modified">3205     cb_funcs = source-&gt;callback_funcs;</span>
<span class="line-modified">3206     cb_data = source-&gt;callback_data;</span>
3207 
<span class="line-modified">3208     if (cb_funcs)</span>
<span class="line-modified">3209       cb_funcs-&gt;ref (cb_data);</span>
3210 
<span class="line-modified">3211     if ((source-&gt;flags &amp; G_SOURCE_CAN_RECURSE) == 0)</span>
<span class="line-modified">3212       block_source (source);</span>
3213 
<span class="line-modified">3214     was_in_call = source-&gt;flags &amp; G_HOOK_FLAG_IN_CALL;</span>
<span class="line-modified">3215     source-&gt;flags |= G_HOOK_FLAG_IN_CALL;</span>
3216 
<span class="line-modified">3217     if (cb_funcs)</span>
<span class="line-modified">3218       cb_funcs-&gt;get (cb_data, source, &amp;callback, &amp;user_data);</span>
3219 
<span class="line-modified">3220     UNLOCK_CONTEXT (context);</span>
3221 
3222           /* These operations are safe because &#39;current&#39; is thread-local
3223            * and not modified from anywhere but this function.
3224            */
3225           prev_source = current-&gt;source;
3226           current-&gt;source = source;
3227           current-&gt;depth++;
3228 
3229           TRACE (GLIB_MAIN_BEFORE_DISPATCH (g_source_get_name (source), source,
3230                                             dispatch, callback, user_data));
3231           need_destroy = !(* dispatch) (source, callback, user_data);
3232           TRACE (GLIB_MAIN_AFTER_DISPATCH (g_source_get_name (source), source,
3233                                            dispatch, need_destroy));
3234 
3235           current-&gt;source = prev_source;
3236           current-&gt;depth--;
3237 
<span class="line-modified">3238     if (cb_funcs)</span>
<span class="line-modified">3239       cb_funcs-&gt;unref (cb_data);</span>
3240 
<span class="line-modified">3241     LOCK_CONTEXT (context);</span>
3242 
<span class="line-modified">3243     if (!was_in_call)</span>
<span class="line-modified">3244       source-&gt;flags &amp;= ~G_HOOK_FLAG_IN_CALL;</span>
3245 
<span class="line-modified">3246     if (SOURCE_BLOCKED (source) &amp;&amp; !SOURCE_DESTROYED (source))</span>
<span class="line-modified">3247       unblock_source (source);</span>
3248 
<span class="line-modified">3249     /* Note: this depends on the fact that we can&#39;t switch</span>
<span class="line-modified">3250      * sources from one main context to another</span>
<span class="line-modified">3251      */</span>
<span class="line-modified">3252     if (need_destroy &amp;&amp; !SOURCE_DESTROYED (source))</span>
<span class="line-modified">3253       {</span>
<span class="line-modified">3254         g_assert (source-&gt;context == context);</span>
<span class="line-modified">3255         g_source_destroy_internal (source, context, TRUE);</span>
<span class="line-modified">3256       }</span>
<span class="line-modified">3257   }</span>
3258 
<span class="line-modified">3259       g_source_unref_internal (source, context, TRUE);</span>
3260     }
3261 
3262   g_ptr_array_set_size (context-&gt;pending_dispatches, 0);
3263 }
3264 
3265 /**
3266  * g_main_context_acquire:
3267  * @context: a #GMainContext
3268  *
3269  * Tries to become the owner of the specified context.
3270  * If some other thread is the owner of the context,
3271  * returns %FALSE immediately. Ownership is properly
3272  * recursive: the owner can require ownership again
3273  * and will release ownership when g_main_context_release()
3274  * is called as many times as g_main_context_acquire().
3275  *
3276  * You must be the owner of a context before you
3277  * can call g_main_context_prepare(), g_main_context_query(),
3278  * g_main_context_check(), g_main_context_dispatch().
3279  *
</pre>
<hr />
<pre>
3321  * with g_main_context_acquire(). If the context was acquired multiple
3322  * times, the ownership will be released only when g_main_context_release()
3323  * is called as many times as it was acquired.
3324  **/
3325 void
3326 g_main_context_release (GMainContext *context)
3327 {
3328   if (context == NULL)
3329     context = g_main_context_default ();
3330 
3331   LOCK_CONTEXT (context);
3332 
3333   context-&gt;owner_count--;
3334   if (context-&gt;owner_count == 0)
3335     {
3336       TRACE (GLIB_MAIN_CONTEXT_RELEASE (context));
3337 
3338       context-&gt;owner = NULL;
3339 
3340       if (context-&gt;waiters)
<span class="line-modified">3341   {</span>
<span class="line-modified">3342     GMainWaiter *waiter = context-&gt;waiters-&gt;data;</span>
<span class="line-modified">3343     gboolean loop_internal_waiter = (waiter-&gt;mutex == &amp;context-&gt;mutex);</span>
<span class="line-modified">3344     context-&gt;waiters = g_slist_delete_link (context-&gt;waiters,</span>
<span class="line-modified">3345               context-&gt;waiters);</span>
<span class="line-modified">3346     if (!loop_internal_waiter)</span>
<span class="line-modified">3347       g_mutex_lock (waiter-&gt;mutex);</span>
3348 
<span class="line-modified">3349     g_cond_signal (waiter-&gt;cond);</span>
3350 
<span class="line-modified">3351     if (!loop_internal_waiter)</span>
<span class="line-modified">3352       g_mutex_unlock (waiter-&gt;mutex);</span>
<span class="line-modified">3353   }</span>
3354     }
3355 
3356   UNLOCK_CONTEXT (context);
3357 }
3358 
3359 static gboolean
3360 g_main_context_wait_internal (GMainContext *context,
<span class="line-modified">3361                               GCond        *cond,</span>
<span class="line-modified">3362                               GMutex       *mutex)</span>
3363 {
3364   gboolean result = FALSE;
3365   GThread *self = G_THREAD_SELF;
3366   gboolean loop_internal_waiter;
3367 
3368   if (context == NULL)
3369     context = g_main_context_default ();
3370 
3371   loop_internal_waiter = (mutex == &amp;context-&gt;mutex);
3372 
3373   if (!loop_internal_waiter)
3374     LOCK_CONTEXT (context);
3375 
3376   if (context-&gt;owner &amp;&amp; context-&gt;owner != self)
3377     {
3378       GMainWaiter waiter;
3379 
3380       waiter.cond = cond;
3381       waiter.mutex = mutex;
3382 
3383       context-&gt;waiters = g_slist_append (context-&gt;waiters, &amp;waiter);
3384 
3385       if (!loop_internal_waiter)
<span class="line-modified">3386         UNLOCK_CONTEXT (context);</span>
3387       g_cond_wait (cond, mutex);
3388       if (!loop_internal_waiter)
<span class="line-modified">3389         LOCK_CONTEXT (context);</span>
3390 
3391       context-&gt;waiters = g_slist_remove (context-&gt;waiters, &amp;waiter);
3392     }
3393 
3394   if (!context-&gt;owner)
3395     {
3396       context-&gt;owner = self;
3397       g_assert (context-&gt;owner_count == 0);
3398     }
3399 
3400   if (context-&gt;owner == self)
3401     {
3402       context-&gt;owner_count++;
3403       result = TRUE;
3404     }
3405 
3406   if (!loop_internal_waiter)
3407     UNLOCK_CONTEXT (context);
3408 
3409   return result;
</pre>
<hr />
<pre>
3434     context = g_main_context_default ();
3435 
3436   if (G_UNLIKELY (cond != &amp;context-&gt;cond || mutex != &amp;context-&gt;mutex))
3437     {
3438       static gboolean warned;
3439 
3440       if (!warned)
3441         {
3442           g_critical (&quot;WARNING!! g_main_context_wait() will be removed in a future release.  &quot;
3443                       &quot;If you see this message, please file a bug immediately.&quot;);
3444           warned = TRUE;
3445         }
3446     }
3447 
3448   return g_main_context_wait_internal (context, cond, mutex);
3449 }
3450 
3451 /**
3452  * g_main_context_prepare:
3453  * @context: a #GMainContext
<span class="line-modified">3454  * @priority: (out) (optional): location to store priority of highest priority</span>
3455  *            source already ready.
3456  *
3457  * Prepares to poll sources within a main loop. The resulting information
3458  * for polling is determined by calling g_main_context_query ().
3459  *
3460  * You must have successfully acquired the context with
3461  * g_main_context_acquire() before you may call this function.
3462  *
3463  * Returns: %TRUE if some source is ready to be dispatched
3464  *               prior to polling.
3465  **/
3466 gboolean
3467 g_main_context_prepare (GMainContext *context,
<span class="line-modified">3468       gint         *priority)</span>
3469 {
3470   guint i;
3471   gint n_ready = 0;
3472   gint current_priority = G_MAXINT;
3473   GSource *source;
3474   GSourceIter iter;
3475 
3476   if (context == NULL)
3477     context = g_main_context_default ();
3478 
3479   LOCK_CONTEXT (context);
3480 
3481   context-&gt;time_is_fresh = FALSE;
3482 
3483   if (context-&gt;in_check_or_prepare)
3484     {
3485       g_warning (&quot;g_main_context_prepare() called recursively from within a source&#39;s check() or &quot;
<span class="line-modified">3486      &quot;prepare() member.&quot;);</span>
3487       UNLOCK_CONTEXT (context);
3488       return FALSE;
3489     }
3490 
3491   TRACE (GLIB_MAIN_CONTEXT_BEFORE_PREPARE (context));
3492 
3493 #if 0
3494   /* If recursing, finish up current dispatch, before starting over */
3495   if (context-&gt;pending_dispatches)
3496     {
3497       if (dispatch)
<span class="line-modified">3498   g_main_dispatch (context, &amp;current_time);</span>
3499 
3500       UNLOCK_CONTEXT (context);
3501       return TRUE;
3502     }
3503 #endif
3504 
3505   /* If recursing, clear list of pending dispatches */
3506 
3507   for (i = 0; i &lt; context-&gt;pending_dispatches-&gt;len; i++)
3508     {
3509       if (context-&gt;pending_dispatches-&gt;pdata[i])
<span class="line-modified">3510         g_source_unref_internal ((GSource *)context-&gt;pending_dispatches-&gt;pdata[i], context, TRUE);</span>
3511     }
3512   g_ptr_array_set_size (context-&gt;pending_dispatches, 0);
3513 
3514   /* Prepare all sources */
3515 
3516   context-&gt;timeout = -1;
3517 
3518   g_source_iter_init (&amp;iter, context, TRUE);
3519   while (g_source_iter_next (&amp;iter, &amp;source))
3520     {
3521       gint source_timeout = -1;
3522 
3523       if (SOURCE_DESTROYED (source) || SOURCE_BLOCKED (source))
<span class="line-modified">3524   continue;</span>
3525       if ((n_ready &gt; 0) &amp;&amp; (source-&gt;priority &gt; current_priority))
<span class="line-modified">3526   break;</span>
3527 
3528       if (!(source-&gt;flags &amp; G_SOURCE_READY))
<span class="line-modified">3529   {</span>
<span class="line-modified">3530     gboolean result;</span>
<span class="line-modified">3531     gboolean (* prepare) (GSource  *source,</span>
3532                                 gint     *timeout);
3533 
3534           prepare = source-&gt;source_funcs-&gt;prepare;
3535 
3536           if (prepare)
3537             {
3538               context-&gt;in_check_or_prepare++;
3539               UNLOCK_CONTEXT (context);
3540 
3541               result = (* prepare) (source, &amp;source_timeout);
3542               TRACE (GLIB_MAIN_AFTER_PREPARE (source, prepare, source_timeout));
3543 
3544               LOCK_CONTEXT (context);
3545               context-&gt;in_check_or_prepare--;
3546             }
3547           else
3548             {
3549               source_timeout = -1;
3550               result = FALSE;
3551             }
3552 
3553           if (result == FALSE &amp;&amp; source-&gt;priv-&gt;ready_time != -1)
3554             {
3555               if (!context-&gt;time_is_fresh)
3556                 {
3557                   context-&gt;time = g_get_monotonic_time ();
3558                   context-&gt;time_is_fresh = TRUE;
3559                 }
3560 
3561               if (source-&gt;priv-&gt;ready_time &lt;= context-&gt;time)
3562                 {
3563                   source_timeout = 0;
3564                   result = TRUE;
3565                 }
3566               else
3567                 {
<span class="line-modified">3568                   gint64 timeout;</span>
3569 
3570                   /* rounding down will lead to spinning, so always round up */
3571                   timeout = (source-&gt;priv-&gt;ready_time - context-&gt;time + 999) / 1000;
3572 
3573                   if (source_timeout &lt; 0 || timeout &lt; source_timeout)
<span class="line-modified">3574                     source_timeout = MIN (timeout, G_MAXINT);</span>
3575                 }
3576             }
3577 
<span class="line-modified">3578     if (result)</span>
<span class="line-modified">3579       {</span>
<span class="line-modified">3580         GSource *ready_source = source;</span>
3581 
<span class="line-modified">3582         while (ready_source)</span>
<span class="line-modified">3583     {</span>
<span class="line-modified">3584       ready_source-&gt;flags |= G_SOURCE_READY;</span>
<span class="line-modified">3585       ready_source = ready_source-&gt;priv-&gt;parent_source;</span>


3586     }
<span class="line-added">3587       }</span>
<span class="line-added">3588   }</span>
3589 
3590       if (source-&gt;flags &amp; G_SOURCE_READY)
<span class="line-modified">3591   {</span>
<span class="line-modified">3592     n_ready++;</span>
<span class="line-modified">3593     current_priority = source-&gt;priority;</span>
<span class="line-modified">3594     context-&gt;timeout = 0;</span>
<span class="line-modified">3595   }</span>
3596 
3597       if (source_timeout &gt;= 0)
<span class="line-modified">3598   {</span>
<span class="line-modified">3599     if (context-&gt;timeout &lt; 0)</span>
<span class="line-modified">3600       context-&gt;timeout = source_timeout;</span>
<span class="line-modified">3601     else</span>
<span class="line-modified">3602       context-&gt;timeout = MIN (context-&gt;timeout, source_timeout);</span>
<span class="line-modified">3603   }</span>
3604     }
3605   g_source_iter_clear (&amp;iter);
3606 
3607   TRACE (GLIB_MAIN_CONTEXT_AFTER_PREPARE (context, current_priority, n_ready));
3608 
3609   UNLOCK_CONTEXT (context);
3610 
3611   if (priority)
3612     *priority = current_priority;
3613 
3614   return (n_ready &gt; 0);
3615 }
3616 
3617 /**
3618  * g_main_context_query:
3619  * @context: a #GMainContext
3620  * @max_priority: maximum priority source to check
3621  * @timeout_: (out): location to store timeout to be used in polling
3622  * @fds: (out caller-allocates) (array length=n_fds): location to
3623  *       store #GPollFD records that need to be polled.
3624  * @n_fds: (in): length of @fds.
3625  *
3626  * Determines information necessary to poll this main loop.
3627  *
3628  * You must have successfully acquired the context with
3629  * g_main_context_acquire() before you may call this function.
3630  *
3631  * Returns: the number of records actually stored in @fds,
3632  *   or, if more than @n_fds records need to be stored, the number
3633  *   of records that need to be stored.
3634  **/
3635 gint
3636 g_main_context_query (GMainContext *context,
<span class="line-modified">3637           gint          max_priority,</span>
<span class="line-modified">3638           gint         *timeout,</span>
<span class="line-modified">3639           GPollFD      *fds,</span>
<span class="line-modified">3640           gint          n_fds)</span>
3641 {
3642   gint n_poll;
3643   GPollRec *pollrec, *lastpollrec;
3644   gushort events;
3645 
3646   LOCK_CONTEXT (context);
3647 
3648   TRACE (GLIB_MAIN_CONTEXT_BEFORE_QUERY (context, max_priority));
3649 
3650   n_poll = 0;
3651   lastpollrec = NULL;
3652   for (pollrec = context-&gt;poll_records; pollrec; pollrec = pollrec-&gt;next)
3653     {
3654       if (pollrec-&gt;priority &gt; max_priority)
3655         continue;
3656 
3657       /* In direct contradiction to the Unix98 spec, IRIX runs into
3658        * difficulty if you pass in POLLERR, POLLHUP or POLLNVAL
3659        * flags in the events field of the pollfd while it should
3660        * just ignoring them. So we mask them out here.
3661        */
3662       events = pollrec-&gt;fd-&gt;events &amp; ~(G_IO_ERR|G_IO_HUP|G_IO_NVAL);
3663 
3664       if (lastpollrec &amp;&amp; pollrec-&gt;fd-&gt;fd == lastpollrec-&gt;fd-&gt;fd)
3665         {
3666           if (n_poll - 1 &lt; n_fds)
3667             fds[n_poll - 1].events |= events;
3668         }
3669       else
3670         {
3671           if (n_poll &lt; n_fds)
3672             {
3673               fds[n_poll].fd = pollrec-&gt;fd-&gt;fd;
3674               fds[n_poll].events = events;
<span class="line-modified">3675               fds[n_poll].revents = 0;</span>
<span class="line-modified">3676             }</span>
3677 
<span class="line-modified">3678           n_poll++;</span>
<span class="line-modified">3679         }</span>
3680 
3681       lastpollrec = pollrec;
3682     }
3683 
3684   context-&gt;poll_changed = FALSE;
3685 
3686   if (timeout)
3687     {
3688       *timeout = context-&gt;timeout;
3689       if (*timeout != 0)
3690         context-&gt;time_is_fresh = FALSE;
3691     }
3692 
3693   TRACE (GLIB_MAIN_CONTEXT_AFTER_QUERY (context, context-&gt;timeout,
3694                                         fds, n_poll));
3695 
3696   UNLOCK_CONTEXT (context);
3697 
3698   return n_poll;
3699 }
3700 
3701 /**
3702  * g_main_context_check:
3703  * @context: a #GMainContext
3704  * @max_priority: the maximum numerical priority of sources to check
3705  * @fds: (array length=n_fds): array of #GPollFD&#39;s that was passed to
3706  *       the last call to g_main_context_query()
3707  * @n_fds: return value of g_main_context_query()
3708  *
3709  * Passes the results of polling back to the main loop.
3710  *
3711  * You must have successfully acquired the context with
3712  * g_main_context_acquire() before you may call this function.
3713  *
3714  * Returns: %TRUE if some sources are ready to be dispatched.
3715  **/
3716 gboolean
3717 g_main_context_check (GMainContext *context,
<span class="line-modified">3718           gint          max_priority,</span>
<span class="line-modified">3719           GPollFD      *fds,</span>
<span class="line-modified">3720           gint          n_fds)</span>
3721 {
3722   GSource *source;
3723   GSourceIter iter;
3724   GPollRec *pollrec;
3725   gint n_ready = 0;
3726   gint i;
3727 
3728   LOCK_CONTEXT (context);
3729 
3730   if (context-&gt;in_check_or_prepare)
3731     {
3732       g_warning (&quot;g_main_context_check() called recursively from within a source&#39;s check() or &quot;
<span class="line-modified">3733      &quot;prepare() member.&quot;);</span>
3734       UNLOCK_CONTEXT (context);
3735       return FALSE;
3736     }
3737 
3738   TRACE (GLIB_MAIN_CONTEXT_BEFORE_CHECK (context, max_priority, fds, n_fds));
3739 
3740   for (i = 0; i &lt; n_fds; i++)
3741     {
3742       if (fds[i].fd == context-&gt;wake_up_rec.fd)
3743         {
3744           if (fds[i].revents)
3745             {
3746               TRACE (GLIB_MAIN_CONTEXT_WAKEUP_ACKNOWLEDGE (context));
<span class="line-modified">3747               g_wakeup_acknowledge (context-&gt;wakeup);</span>
3748             }
3749           break;
3750         }
3751     }
3752 
3753   /* If the set of poll file descriptors changed, bail out
3754    * and let the main loop rerun
3755    */
3756   if (context-&gt;poll_changed)
3757     {
3758       TRACE (GLIB_MAIN_CONTEXT_AFTER_CHECK (context, 0));
3759 
3760       UNLOCK_CONTEXT (context);
3761       return FALSE;
3762     }
3763 
3764   pollrec = context-&gt;poll_records;
3765   i = 0;
3766   while (pollrec &amp;&amp; i &lt; n_fds)
3767     {
3768       while (pollrec &amp;&amp; pollrec-&gt;fd-&gt;fd == fds[i].fd)
3769         {
3770           if (pollrec-&gt;priority &lt;= max_priority)
3771             {
3772               pollrec-&gt;fd-&gt;revents =
3773                 fds[i].revents &amp; (pollrec-&gt;fd-&gt;events | G_IO_ERR | G_IO_HUP | G_IO_NVAL);
3774             }
3775           pollrec = pollrec-&gt;next;
3776         }
3777 
3778       i++;
3779     }
3780 
3781   g_source_iter_init (&amp;iter, context, TRUE);
3782   while (g_source_iter_next (&amp;iter, &amp;source))
3783     {
3784       if (SOURCE_DESTROYED (source) || SOURCE_BLOCKED (source))
<span class="line-modified">3785   continue;</span>
3786       if ((n_ready &gt; 0) &amp;&amp; (source-&gt;priority &gt; max_priority))
<span class="line-modified">3787   break;</span>
3788 
3789       if (!(source-&gt;flags &amp; G_SOURCE_READY))
<span class="line-modified">3790   {</span>
3791           gboolean result;
3792           gboolean (* check) (GSource *source);
3793 
3794           check = source-&gt;source_funcs-&gt;check;
3795 
3796           if (check)
3797             {
3798               /* If the check function is set, call it. */
3799               context-&gt;in_check_or_prepare++;
3800               UNLOCK_CONTEXT (context);
3801 
3802               result = (* check) (source);
3803 
3804               TRACE (GLIB_MAIN_AFTER_CHECK (source, check, result));
3805 
3806               LOCK_CONTEXT (context);
3807               context-&gt;in_check_or_prepare--;
3808             }
3809           else
3810             result = FALSE;
</pre>
<hr />
<pre>
3824                   if (pollfd-&gt;revents)
3825                     {
3826                       result = TRUE;
3827                       break;
3828                     }
3829                 }
3830             }
3831 
3832           if (result == FALSE &amp;&amp; source-&gt;priv-&gt;ready_time != -1)
3833             {
3834               if (!context-&gt;time_is_fresh)
3835                 {
3836                   context-&gt;time = g_get_monotonic_time ();
3837                   context-&gt;time_is_fresh = TRUE;
3838                 }
3839 
3840               if (source-&gt;priv-&gt;ready_time &lt;= context-&gt;time)
3841                 result = TRUE;
3842             }
3843 
<span class="line-modified">3844     if (result)</span>
<span class="line-modified">3845       {</span>
<span class="line-modified">3846         GSource *ready_source = source;</span>
3847 
<span class="line-modified">3848         while (ready_source)</span>
<span class="line-modified">3849     {</span>
<span class="line-modified">3850       ready_source-&gt;flags |= G_SOURCE_READY;</span>
<span class="line-modified">3851       ready_source = ready_source-&gt;priv-&gt;parent_source;</span>


3852     }
<span class="line-added">3853       }</span>
<span class="line-added">3854   }</span>
3855 
3856       if (source-&gt;flags &amp; G_SOURCE_READY)
<span class="line-modified">3857   {</span>
<span class="line-modified">3858           g_source_ref (source);</span>
<span class="line-modified">3859     g_ptr_array_add (context-&gt;pending_dispatches, source);</span>
3860 
<span class="line-modified">3861     n_ready++;</span>
3862 
3863           /* never dispatch sources with less priority than the first
3864            * one we choose to dispatch
3865            */
3866           max_priority = source-&gt;priority;
<span class="line-modified">3867   }</span>
3868     }
3869   g_source_iter_clear (&amp;iter);
3870 
3871   TRACE (GLIB_MAIN_CONTEXT_AFTER_CHECK (context, n_ready));
3872 
3873   UNLOCK_CONTEXT (context);
3874 
3875   return n_ready &gt; 0;
3876 }
3877 
3878 /**
3879  * g_main_context_dispatch:
3880  * @context: a #GMainContext
3881  *
3882  * Dispatches all pending sources.
3883  *
3884  * You must have successfully acquired the context with
3885  * g_main_context_acquire() before you may call this function.
3886  **/
3887 void
3888 g_main_context_dispatch (GMainContext *context)
3889 {
3890   LOCK_CONTEXT (context);
3891 
3892   TRACE (GLIB_MAIN_CONTEXT_BEFORE_DISPATCH (context));
3893 
3894   if (context-&gt;pending_dispatches-&gt;len &gt; 0)
3895     {
3896       g_main_dispatch (context);
3897     }
3898 
3899   TRACE (GLIB_MAIN_CONTEXT_AFTER_DISPATCH (context));
3900 
3901   UNLOCK_CONTEXT (context);
3902 }
3903 
3904 /* HOLDS context lock */
3905 static gboolean
3906 g_main_context_iterate (GMainContext *context,
<span class="line-modified">3907       gboolean      block,</span>
<span class="line-modified">3908       gboolean      dispatch,</span>
<span class="line-modified">3909       GThread      *self)</span>
3910 {
3911   gint max_priority;
3912   gint timeout;
3913   gboolean some_ready;
3914   gint nfds, allocated_nfds;
3915   GPollFD *fds = NULL;
3916 
3917   UNLOCK_CONTEXT (context);
3918 
3919   if (!g_main_context_acquire (context))
3920     {
3921       gboolean got_ownership;
3922 
3923       LOCK_CONTEXT (context);
3924 
3925       if (!block)
<span class="line-modified">3926   return FALSE;</span>
3927 
3928       got_ownership = g_main_context_wait_internal (context,
3929                                                     &amp;context-&gt;cond,
3930                                                     &amp;context-&gt;mutex);
3931 
3932       if (!got_ownership)
<span class="line-modified">3933   return FALSE;</span>
3934     }
3935   else
3936     LOCK_CONTEXT (context);
3937 
3938   if (!context-&gt;cached_poll_array)
3939     {
3940       context-&gt;cached_poll_array_size = context-&gt;n_poll_records;
3941       context-&gt;cached_poll_array = g_new (GPollFD, context-&gt;n_poll_records);
3942     }
3943 
3944   allocated_nfds = context-&gt;cached_poll_array_size;
3945   fds = context-&gt;cached_poll_array;
3946 
3947   UNLOCK_CONTEXT (context);
3948 
3949   g_main_context_prepare (context, &amp;max_priority);
3950 
3951   while ((nfds = g_main_context_query (context, max_priority, &amp;timeout, fds,
<span class="line-modified">3952                allocated_nfds)) &gt; allocated_nfds)</span>
3953     {
3954       LOCK_CONTEXT (context);
3955       g_free (fds);
3956       context-&gt;cached_poll_array_size = allocated_nfds = nfds;
3957       context-&gt;cached_poll_array = fds = g_new (GPollFD, nfds);
3958       UNLOCK_CONTEXT (context);
3959 #ifdef GSTREAMER_LITE
3960       if (fds == NULL) {
3961         return FALSE;
3962       }
3963 #endif // GSTREAMER_LITE
3964     }
3965 
3966   if (!block)
3967     timeout = 0;
3968 
3969   g_main_context_poll (context, timeout, max_priority, fds, nfds);
3970 
3971   some_ready = g_main_context_check (context, max_priority, fds, nfds);
3972 
</pre>
<hr />
<pre>
4034   LOCK_CONTEXT (context);
4035   retval = g_main_context_iterate (context, may_block, TRUE, G_THREAD_SELF);
4036   UNLOCK_CONTEXT (context);
4037 
4038   return retval;
4039 }
4040 
4041 /**
4042  * g_main_loop_new:
4043  * @context: (nullable): a #GMainContext  (if %NULL, the default context will be used).
4044  * @is_running: set to %TRUE to indicate that the loop is running. This
4045  * is not very important since calling g_main_loop_run() will set this to
4046  * %TRUE anyway.
4047  *
4048  * Creates a new #GMainLoop structure.
4049  *
4050  * Returns: a new #GMainLoop.
4051  **/
4052 GMainLoop *
4053 g_main_loop_new (GMainContext *context,
<span class="line-modified">4054      gboolean      is_running)</span>
4055 {
4056   GMainLoop *loop;
4057 
4058   if (!context)
4059     context = g_main_context_default();
4060 
4061   g_main_context_ref (context);
4062 
4063   loop = g_new0 (GMainLoop, 1);
4064   loop-&gt;context = context;
4065   loop-&gt;is_running = is_running != FALSE;
4066   loop-&gt;ref_count = 1;
4067 
4068   TRACE (GLIB_MAIN_LOOP_NEW (loop, context));
4069 
4070   return loop;
4071 }
4072 
4073 /**
4074  * g_main_loop_ref:
</pre>
<hr />
<pre>
4117  * If this is called for the thread of the loop&#39;s #GMainContext,
4118  * it will process events from the loop, otherwise it will
4119  * simply wait.
4120  **/
4121 void
4122 g_main_loop_run (GMainLoop *loop)
4123 {
4124   GThread *self = G_THREAD_SELF;
4125 
4126   g_return_if_fail (loop != NULL);
4127   g_return_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0);
4128 
4129   if (!g_main_context_acquire (loop-&gt;context))
4130     {
4131       gboolean got_ownership = FALSE;
4132 
4133       /* Another thread owns this context */
4134       LOCK_CONTEXT (loop-&gt;context);
4135 
4136       g_atomic_int_inc (&amp;loop-&gt;ref_count);
<span class="line-added">4137       g_atomic_int_set (&amp;loop-&gt;is_running, TRUE);</span>
4138 
<span class="line-modified">4139       while (g_atomic_int_get (&amp;loop-&gt;is_running) &amp;&amp; !got_ownership)</span>



4140         got_ownership = g_main_context_wait_internal (loop-&gt;context,
4141                                                       &amp;loop-&gt;context-&gt;cond,
4142                                                       &amp;loop-&gt;context-&gt;mutex);
4143 
<span class="line-modified">4144       if (!g_atomic_int_get (&amp;loop-&gt;is_running))</span>
<span class="line-modified">4145   {</span>
<span class="line-modified">4146     UNLOCK_CONTEXT (loop-&gt;context);</span>
<span class="line-modified">4147     if (got_ownership)</span>
<span class="line-modified">4148       g_main_context_release (loop-&gt;context);</span>
<span class="line-modified">4149     g_main_loop_unref (loop);</span>
<span class="line-modified">4150     return;</span>
<span class="line-modified">4151   }</span>
4152 
4153       g_assert (got_ownership);
4154     }
4155   else
4156     LOCK_CONTEXT (loop-&gt;context);
4157 
4158   if (loop-&gt;context-&gt;in_check_or_prepare)
4159     {
4160       g_warning (&quot;g_main_loop_run(): called recursively from within a source&#39;s &quot;
<span class="line-modified">4161      &quot;check() or prepare() member, iteration not possible.&quot;);</span>
4162       return;
4163     }
4164 
4165   g_atomic_int_inc (&amp;loop-&gt;ref_count);
<span class="line-modified">4166   g_atomic_int_set (&amp;loop-&gt;is_running, TRUE);</span>
<span class="line-modified">4167   while (g_atomic_int_get (&amp;loop-&gt;is_running))</span>
4168     g_main_context_iterate (loop-&gt;context, TRUE, TRUE, self);
4169 
4170   UNLOCK_CONTEXT (loop-&gt;context);
4171 
4172   g_main_context_release (loop-&gt;context);
4173 
4174   g_main_loop_unref (loop);
4175 }
4176 
4177 /**
4178  * g_main_loop_quit:
4179  * @loop: a #GMainLoop
4180  *
4181  * Stops a #GMainLoop from running. Any calls to g_main_loop_run()
4182  * for the loop will return.
4183  *
4184  * Note that sources that have already been dispatched when
4185  * g_main_loop_quit() is called will still be executed.
4186  **/
4187 void
4188 g_main_loop_quit (GMainLoop *loop)
4189 {
4190   g_return_if_fail (loop != NULL);
4191   g_return_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0);
4192 
4193   LOCK_CONTEXT (loop-&gt;context);
<span class="line-modified">4194   g_atomic_int_set (&amp;loop-&gt;is_running, FALSE);</span>
4195   g_wakeup_signal (loop-&gt;context-&gt;wakeup);
4196 
4197   g_cond_broadcast (&amp;loop-&gt;context-&gt;cond);
4198 
4199   UNLOCK_CONTEXT (loop-&gt;context);
4200 
4201   TRACE (GLIB_MAIN_LOOP_QUIT (loop));
4202 }
4203 
4204 /**
4205  * g_main_loop_is_running:
4206  * @loop: a #GMainLoop.
4207  *
4208  * Checks to see if the main loop is currently being run via g_main_loop_run().
4209  *
4210  * Returns: %TRUE if the mainloop is currently being run.
4211  **/
4212 gboolean
4213 g_main_loop_is_running (GMainLoop *loop)
4214 {
4215   g_return_val_if_fail (loop != NULL, FALSE);
4216   g_return_val_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0, FALSE);
4217 
<span class="line-modified">4218   return g_atomic_int_get (&amp;loop-&gt;is_running);</span>
4219 }
4220 
4221 /**
4222  * g_main_loop_get_context:
4223  * @loop: a #GMainLoop.
4224  *
4225  * Returns the #GMainContext of @loop.
4226  *
4227  * Returns: (transfer none): the #GMainContext of @loop
4228  **/
4229 GMainContext *
4230 g_main_loop_get_context (GMainLoop *loop)
4231 {
4232   g_return_val_if_fail (loop != NULL, NULL);
4233   g_return_val_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0, NULL);
4234 
4235   return loop-&gt;context;
4236 }
4237 
4238 /* HOLDS: context&#39;s lock */
4239 static void
4240 g_main_context_poll (GMainContext *context,
<span class="line-modified">4241          gint          timeout,</span>
<span class="line-modified">4242          gint          priority,</span>
<span class="line-modified">4243          GPollFD      *fds,</span>
<span class="line-modified">4244          gint          n_fds)</span>
4245 {
4246 #ifdef  G_MAIN_POLL_DEBUG
4247   GTimer *poll_timer;
4248   GPollRec *pollrec;
4249   gint i;
4250 #endif
4251 
4252   GPollFunc poll_func;
4253 
4254   if (n_fds || timeout != 0)
4255     {
4256       int ret, errsv;
4257 
4258 #ifdef  G_MAIN_POLL_DEBUG
4259       poll_timer = NULL;
4260       if (_g_main_poll_debug)
<span class="line-modified">4261   {</span>
<span class="line-modified">4262     g_print (&quot;polling context=%p n=%d timeout=%d\n&quot;,</span>
<span class="line-modified">4263        context, n_fds, timeout);</span>
<span class="line-modified">4264     poll_timer = g_timer_new ();</span>
<span class="line-modified">4265   }</span>
4266 #endif
4267 
4268       LOCK_CONTEXT (context);
4269 
4270       poll_func = context-&gt;poll_func;
4271 
4272       UNLOCK_CONTEXT (context);
4273       ret = (*poll_func) (fds, n_fds, timeout);
4274       errsv = errno;
4275       if (ret &lt; 0 &amp;&amp; errsv != EINTR)
<span class="line-modified">4276   {</span>
4277 #ifndef G_OS_WIN32
<span class="line-modified">4278     g_warning (&quot;poll(2) failed due to: %s.&quot;,</span>
<span class="line-modified">4279          g_strerror (errsv));</span>
4280 #else
<span class="line-modified">4281     /* If g_poll () returns -1, it has already called g_warning() */</span>
4282 #endif
<span class="line-modified">4283   }</span>
4284 
4285 #ifdef  G_MAIN_POLL_DEBUG
4286       if (_g_main_poll_debug)
<span class="line-modified">4287   {</span>
<span class="line-modified">4288     LOCK_CONTEXT (context);</span>







4289 
<span class="line-modified">4290     g_print (&quot;g_main_poll(%d) timeout: %d - elapsed %12.10f seconds&quot;,</span>
<span class="line-modified">4291        n_fds,</span>
<span class="line-modified">4292        timeout,</span>
<span class="line-modified">4293        g_timer_elapsed (poll_timer, NULL));</span>
<span class="line-added">4294     g_timer_destroy (poll_timer);</span>
<span class="line-added">4295     pollrec = context-&gt;poll_records;</span>
<span class="line-added">4296 </span>
<span class="line-added">4297     while (pollrec != NULL)</span>
<span class="line-added">4298       {</span>
<span class="line-added">4299         i = 0;</span>
<span class="line-added">4300         while (i &lt; n_fds)</span>
<span class="line-added">4301     {</span>
<span class="line-added">4302       if (fds[i].fd == pollrec-&gt;fd-&gt;fd &amp;&amp;</span>
<span class="line-added">4303           pollrec-&gt;fd-&gt;events &amp;&amp;</span>
<span class="line-added">4304           fds[i].revents)</span>
4305         {
<span class="line-modified">4306           g_print (&quot; [&quot; G_POLLFD_FORMAT &quot; :&quot;, fds[i].fd);</span>
<span class="line-modified">4307           if (fds[i].revents &amp; G_IO_IN)</span>
<span class="line-modified">4308       g_print (&quot;i&quot;);</span>
<span class="line-modified">4309           if (fds[i].revents &amp; G_IO_OUT)</span>
<span class="line-modified">4310       g_print (&quot;o&quot;);</span>
<span class="line-modified">4311           if (fds[i].revents &amp; G_IO_PRI)</span>
<span class="line-modified">4312       g_print (&quot;p&quot;);</span>
<span class="line-modified">4313           if (fds[i].revents &amp; G_IO_ERR)</span>
<span class="line-modified">4314       g_print (&quot;e&quot;);</span>
<span class="line-modified">4315           if (fds[i].revents &amp; G_IO_HUP)</span>
<span class="line-modified">4316       g_print (&quot;h&quot;);</span>
<span class="line-modified">4317           if (fds[i].revents &amp; G_IO_NVAL)</span>
<span class="line-modified">4318       g_print (&quot;n&quot;);</span>
<span class="line-modified">4319           g_print (&quot;]&quot;);</span>






4320         }
<span class="line-modified">4321       i++;</span>




4322     }
<span class="line-added">4323         pollrec = pollrec-&gt;next;</span>
<span class="line-added">4324       }</span>
<span class="line-added">4325     g_print (&quot;\n&quot;);</span>
<span class="line-added">4326 </span>
<span class="line-added">4327     UNLOCK_CONTEXT (context);</span>
<span class="line-added">4328   }</span>
4329 #endif
4330     } /* if (n_fds || timeout != 0) */
4331 }
4332 
4333 /**
4334  * g_main_context_add_poll:
4335  * @context: (nullable): a #GMainContext (or %NULL for the default context)
4336  * @fd: a #GPollFD structure holding information about a file
4337  *      descriptor to watch.
4338  * @priority: the priority for this file descriptor which should be
4339  *      the same as the priority used for g_source_attach() to ensure that the
4340  *      file descriptor is polled whenever the results may be needed.
4341  *
4342  * Adds a file descriptor to the set of file descriptors polled for
4343  * this context. This will very seldom be used directly. Instead
4344  * a typical event source will use g_source_add_unix_fd() instead.
4345  **/
4346 void
4347 g_main_context_add_poll (GMainContext *context,
<span class="line-modified">4348        GPollFD      *fd,</span>
<span class="line-modified">4349        gint          priority)</span>
4350 {
4351   if (!context)
4352     context = g_main_context_default ();
4353 
4354   g_return_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0);
4355   g_return_if_fail (fd);
4356 
4357   LOCK_CONTEXT (context);
4358   g_main_context_add_poll_unlocked (context, priority, fd);
4359   UNLOCK_CONTEXT (context);
4360 }
4361 
4362 /* HOLDS: main_loop_lock */
4363 static void
4364 g_main_context_add_poll_unlocked (GMainContext *context,
<span class="line-modified">4365           gint          priority,</span>
<span class="line-modified">4366           GPollFD      *fd)</span>
4367 {
4368   GPollRec *prevrec, *nextrec;
4369   GPollRec *newrec = g_slice_new (GPollRec);
4370 #ifdef GSTREAMER_LITE
4371   if (newrec == NULL) {
4372     return;
4373   }
4374 #endif // GSTREAMER_LITE
4375 
4376   /* This file descriptor may be checked before we ever poll */
4377   fd-&gt;revents = 0;
4378   newrec-&gt;fd = fd;
4379   newrec-&gt;priority = priority;
4380 
4381   prevrec = NULL;
4382   nextrec = context-&gt;poll_records;
4383   while (nextrec)
4384     {
4385       if (nextrec-&gt;fd-&gt;fd &gt; fd-&gt;fd)
4386         break;
</pre>
<hr />
<pre>
4400     nextrec-&gt;prev = newrec;
4401 
4402   context-&gt;n_poll_records++;
4403 
4404   context-&gt;poll_changed = TRUE;
4405 
4406   /* Now wake up the main loop if it is waiting in the poll() */
4407   g_wakeup_signal (context-&gt;wakeup);
4408 }
4409 
4410 /**
4411  * g_main_context_remove_poll:
4412  * @context:a #GMainContext
4413  * @fd: a #GPollFD descriptor previously added with g_main_context_add_poll()
4414  *
4415  * Removes file descriptor from the set of file descriptors to be
4416  * polled for a particular context.
4417  **/
4418 void
4419 g_main_context_remove_poll (GMainContext *context,
<span class="line-modified">4420           GPollFD      *fd)</span>
4421 {
4422   if (!context)
4423     context = g_main_context_default ();
4424 
4425   g_return_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0);
4426   g_return_if_fail (fd);
4427 
4428   LOCK_CONTEXT (context);
4429   g_main_context_remove_poll_unlocked (context, fd);
4430   UNLOCK_CONTEXT (context);
4431 }
4432 
4433 static void
4434 g_main_context_remove_poll_unlocked (GMainContext *context,
<span class="line-modified">4435              GPollFD      *fd)</span>
4436 {
4437   GPollRec *pollrec, *prevrec, *nextrec;
4438 
4439   prevrec = NULL;
4440   pollrec = context-&gt;poll_records;
4441 
4442   while (pollrec)
4443     {
4444       nextrec = pollrec-&gt;next;
4445       if (pollrec-&gt;fd == fd)
<span class="line-modified">4446   {</span>
<span class="line-modified">4447     if (prevrec != NULL)</span>
<span class="line-modified">4448       prevrec-&gt;next = nextrec;</span>
<span class="line-modified">4449     else</span>
<span class="line-modified">4450       context-&gt;poll_records = nextrec;</span>
4451 
<span class="line-modified">4452     if (nextrec != NULL)</span>
<span class="line-modified">4453       nextrec-&gt;prev = prevrec;</span>
4454 
<span class="line-modified">4455     g_slice_free (GPollRec, pollrec);</span>
4456 
<span class="line-modified">4457     context-&gt;n_poll_records--;</span>
<span class="line-modified">4458     break;</span>
<span class="line-modified">4459   }</span>
4460       prevrec = pollrec;
4461       pollrec = nextrec;
4462     }
4463 
4464   context-&gt;poll_changed = TRUE;
4465 
4466   /* Now wake up the main loop if it is waiting in the poll() */
4467   g_wakeup_signal (context-&gt;wakeup);
4468 }
4469 
4470 /**
4471  * g_source_get_current_time:
4472  * @source:  a #GSource
4473  * @timeval: #GTimeVal structure in which to store current time.
4474  *
4475  * This function ignores @source and is otherwise the same as
4476  * g_get_current_time().
4477  *
4478  * Deprecated: 2.28: use g_source_get_time() instead
4479  **/
<span class="line-added">4480 G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
4481 void
4482 g_source_get_current_time (GSource  *source,
<span class="line-modified">4483          GTimeVal *timeval)</span>
4484 {
4485   g_get_current_time (timeval);
4486 }
<span class="line-added">4487 G_GNUC_END_IGNORE_DEPRECATIONS</span>
4488 
4489 /**
4490  * g_source_get_time:
4491  * @source: a #GSource
4492  *
4493  * Gets the time to be used when checking this source. The advantage of
4494  * calling this function over calling g_get_monotonic_time() directly is
4495  * that when checking multiple sources, GLib can cache a single value
4496  * instead of having to repeatedly get the system monotonic time.
4497  *
4498  * The time here is the system monotonic time, if available, or some
4499  * other reasonable alternative otherwise.  See g_get_monotonic_time().
4500  *
4501  * Returns: the monotonic time in microseconds
4502  *
4503  * Since: 2.28
4504  **/
4505 gint64
4506 g_source_get_time (GSource *source)
4507 {
</pre>
<hr />
<pre>
4525   UNLOCK_CONTEXT (context);
4526 
4527   return result;
4528 }
4529 
4530 /**
4531  * g_main_context_set_poll_func:
4532  * @context: a #GMainContext
4533  * @func: the function to call to poll all file descriptors
4534  *
4535  * Sets the function to use to handle polling of file descriptors. It
4536  * will be used instead of the poll() system call
4537  * (or GLib&#39;s replacement function, which is used where
4538  * poll() isn&#39;t available).
4539  *
4540  * This function could possibly be used to integrate the GLib event
4541  * loop with an external event loop.
4542  **/
4543 void
4544 g_main_context_set_poll_func (GMainContext *context,
<span class="line-modified">4545             GPollFunc     func)</span>
4546 {
4547   if (!context)
4548     context = g_main_context_default ();
4549 
4550   g_return_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0);
4551 
4552   LOCK_CONTEXT (context);
4553 
4554   if (func)
4555     context-&gt;poll_func = func;
4556   else
4557     context-&gt;poll_func = g_poll;
4558 
4559   UNLOCK_CONTEXT (context);
4560 }
4561 
4562 /**
4563  * g_main_context_get_poll_func:
4564  * @context: a #GMainContext
4565  *
</pre>
<hr />
<pre>
4649   gboolean is_owner;
4650 
4651   if (!context)
4652     context = g_main_context_default ();
4653 
4654   LOCK_CONTEXT (context);
4655   is_owner = context-&gt;owner == G_THREAD_SELF;
4656   UNLOCK_CONTEXT (context);
4657 
4658   return is_owner;
4659 }
4660 
4661 /* Timeouts */
4662 
4663 static void
4664 g_timeout_set_expiration (GTimeoutSource *timeout_source,
4665                           gint64          current_time)
4666 {
4667   gint64 expiration;
4668 


4669   if (timeout_source-&gt;seconds)
4670     {
4671       gint64 remainder;
4672       static gint timer_perturb = -1;
4673 
4674       if (timer_perturb == -1)
4675         {
4676           /*
4677            * we want a per machine/session unique &#39;random&#39; value; try the dbus
4678            * address first, that has a UUID in it. If there is no dbus, use the
4679            * hostname for hashing.
4680            */
4681           const char *session_bus_address = g_getenv (&quot;DBUS_SESSION_BUS_ADDRESS&quot;);
4682           if (!session_bus_address)
4683             session_bus_address = g_getenv (&quot;HOSTNAME&quot;);
4684           if (session_bus_address)
4685             timer_perturb = ABS ((gint) g_str_hash (session_bus_address)) % 1000000;
4686           else
4687             timer_perturb = 0;
4688         }
4689 
<span class="line-added">4690       expiration = current_time + (guint64) timeout_source-&gt;interval * 1000 * 1000;</span>
<span class="line-added">4691 </span>
4692       /* We want the microseconds part of the timeout to land on the
4693        * &#39;timer_perturb&#39; mark, but we need to make sure we don&#39;t try to
4694        * set the timeout in the past.  We do this by ensuring that we
4695        * always only *increase* the expiration time by adding a full
4696        * second in the case that the microsecond portion decreases.
4697        */
4698       expiration -= timer_perturb;
4699 
4700       remainder = expiration % 1000000;
4701       if (remainder &gt;= 1000000/4)
4702         expiration += 1000000;
4703 
4704       expiration -= remainder;
4705       expiration += timer_perturb;
4706     }
<span class="line-added">4707   else</span>
<span class="line-added">4708     {</span>
<span class="line-added">4709       expiration = current_time + (guint64) timeout_source-&gt;interval * 1000;</span>
<span class="line-added">4710     }</span>
4711 
4712   g_source_set_ready_time ((GSource *) timeout_source, expiration);
4713 }
4714 
4715 static gboolean
4716 g_timeout_dispatch (GSource     *source,
4717                     GSourceFunc  callback,
4718                     gpointer     user_data)
4719 {
4720   GTimeoutSource *timeout_source = (GTimeoutSource *)source;
4721   gboolean again;
4722 
4723   if (!callback)
4724     {
4725       g_warning (&quot;Timeout source dispatched without callback. &quot;
4726                  &quot;You must call g_source_set_callback().&quot;);
4727       return FALSE;
4728     }
4729 
4730   again = callback (user_data);
</pre>
<hr />
<pre>
4778  * The source will not initially be associated with any #GMainContext
4779  * and must be added to one with g_source_attach() before it will be
4780  * executed.
4781  *
4782  * The scheduling granularity/accuracy of this timeout source will be
4783  * in seconds.
4784  *
4785  * The interval given is in terms of monotonic time, not wall clock time.
4786  * See g_get_monotonic_time().
4787  *
4788  * Returns: the newly-created timeout source
4789  *
4790  * Since: 2.14
4791  **/
4792 GSource *
4793 g_timeout_source_new_seconds (guint interval)
4794 {
4795   GSource *source = g_source_new (&amp;g_timeout_funcs, sizeof (GTimeoutSource));
4796   GTimeoutSource *timeout_source = (GTimeoutSource *)source;
4797 
<span class="line-modified">4798   timeout_source-&gt;interval = interval;</span>
4799   timeout_source-&gt;seconds = TRUE;
4800 
4801   g_timeout_set_expiration (timeout_source, g_get_monotonic_time ());
4802 
4803   return source;
4804 }
4805 #endif // GSTREAMER_LITE
4806 
4807 
4808 /**
4809  * g_timeout_add_full: (rename-to g_timeout_add)
4810  * @priority: the priority of the timeout source. Typically this will be in
4811  *            the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.
4812  * @interval: the time between calls to the function, in milliseconds
4813  *             (1/1000ths of a second)
4814  * @function: function to call
4815  * @data:     data to pass to @function
4816  * @notify: (nullable): function to call when the timeout is removed, or %NULL
4817  *
4818  * Sets a function to be called at regular intervals, with the given
</pre>
<hr />
<pre>
4827  * After each call to the timeout function, the time of the next
4828  * timeout is recalculated based on the current time and the given interval
4829  * (it does not try to &#39;catch up&#39; time lost in delays).
4830  *
4831  * See [memory management of sources][mainloop-memory-management] for details
4832  * on how to handle the return value and memory management of @data.
4833  *
4834  * This internally creates a main loop source using g_timeout_source_new()
4835  * and attaches it to the global #GMainContext using g_source_attach(), so
4836  * the callback will be invoked in whichever thread is running that main
4837  * context. You can do these steps manually if you need greater control or to
4838  * use a custom main context.
4839  *
4840  * The interval given is in terms of monotonic time, not wall clock time.
4841  * See g_get_monotonic_time().
4842  *
4843  * Returns: the ID (greater than 0) of the event source.
4844  **/
4845 guint
4846 g_timeout_add_full (gint           priority,
<span class="line-modified">4847         guint          interval,</span>
<span class="line-modified">4848         GSourceFunc    function,</span>
<span class="line-modified">4849         gpointer       data,</span>
<span class="line-modified">4850         GDestroyNotify notify)</span>
4851 {
4852   GSource *source;
4853   guint id;
4854 
4855   g_return_val_if_fail (function != NULL, 0);
4856 
4857   source = g_timeout_source_new (interval);
4858 #ifdef GSTREAMER_LITE
4859   if (source == NULL)
4860       return 0;
4861 #endif // GSTREAMER_LITE
4862 
4863   if (priority != G_PRIORITY_DEFAULT)
4864     g_source_set_priority (source, priority);
4865 
4866   g_source_set_callback (source, function, data, notify);
4867   id = g_source_attach (source, NULL);
4868 
4869   TRACE (GLIB_TIMEOUT_ADD (source, g_main_context_default (), id, priority, interval, function, data));
4870 
</pre>
<hr />
<pre>
4896  * on how to handle the return value and memory management of @data.
4897  *
4898  * If you want to have a timer in the &quot;seconds&quot; range and do not care
4899  * about the exact time of the first call of the timer, use the
4900  * g_timeout_add_seconds() function; this function allows for more
4901  * optimizations and more efficient system power usage.
4902  *
4903  * This internally creates a main loop source using g_timeout_source_new()
4904  * and attaches it to the global #GMainContext using g_source_attach(), so
4905  * the callback will be invoked in whichever thread is running that main
4906  * context. You can do these steps manually if you need greater control or to
4907  * use a custom main context.
4908  *
4909  * The interval given is in terms of monotonic time, not wall clock
4910  * time.  See g_get_monotonic_time().
4911  *
4912  * Returns: the ID (greater than 0) of the event source.
4913  **/
4914 guint
4915 g_timeout_add (guint32        interval,
<span class="line-modified">4916          GSourceFunc    function,</span>
<span class="line-modified">4917          gpointer       data)</span>
4918 {
4919   return g_timeout_add_full (G_PRIORITY_DEFAULT,
<span class="line-modified">4920            interval, function, data, NULL);</span>
4921 }
4922 
4923 #ifndef GSTREAMER_LITE
4924 /**
4925  * g_timeout_add_seconds_full: (rename-to g_timeout_add_seconds)
4926  * @priority: the priority of the timeout source. Typically this will be in
4927  *            the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.
4928  * @interval: the time between calls to the function, in seconds
4929  * @function: function to call
4930  * @data:     data to pass to @function
4931  * @notify: (nullable): function to call when the timeout is removed, or %NULL
4932  *
4933  * Sets a function to be called at regular intervals, with @priority.
4934  * The function is called repeatedly until it returns %FALSE, at which
4935  * point the timeout is automatically destroyed and the function will
4936  * not be called again.
4937  *
4938  * Unlike g_timeout_add(), this function operates at whole second granularity.
4939  * The initial starting point of the timer is determined by the implementation
4940  * and the implementation is expected to group multiple timers together so that
</pre>
<hr />
<pre>
5025  *
5026  * Since: 2.14
5027  **/
5028 guint
5029 g_timeout_add_seconds (guint       interval,
5030                        GSourceFunc function,
5031                        gpointer    data)
5032 {
5033   g_return_val_if_fail (function != NULL, 0);
5034 
5035   return g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, interval, function, data, NULL);
5036 }
5037 #endif // GSTREAMER_LITE
5038 
5039 /* Child watch functions */
5040 
5041 #ifdef G_OS_WIN32
5042 
5043 static gboolean
5044 g_child_watch_prepare (GSource *source,
<span class="line-modified">5045            gint    *timeout)</span>
5046 {
5047   *timeout = -1;
5048   return FALSE;
5049 }
5050 
5051 static gboolean
5052 g_child_watch_check (GSource  *source)
5053 {
5054   GChildWatchSource *child_watch_source;
5055   gboolean child_exited;
5056 
5057   child_watch_source = (GChildWatchSource *) source;
5058 
5059   child_exited = child_watch_source-&gt;poll.revents &amp; G_IO_IN;
5060 
5061   if (child_exited)
5062     {
5063       DWORD child_status;
5064 
5065       /*
5066        * Note: We do _not_ check for the special value of STILL_ACTIVE
5067        * since we know that the process has exited and doing so runs into
5068        * problems if the child process &quot;happens to return STILL_ACTIVE(259)&quot;
5069        * as Microsoft&#39;s Platform SDK puts it.
5070        */
5071       if (!GetExitCodeProcess (child_watch_source-&gt;pid, &amp;child_status))
5072         {
<span class="line-modified">5073     gchar *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-modified">5074     g_warning (G_STRLOC &quot;: GetExitCodeProcess() failed: %s&quot;, emsg);</span>
<span class="line-modified">5075     g_free (emsg);</span>
5076 
<span class="line-modified">5077     child_watch_source-&gt;child_status = -1;</span>
<span class="line-modified">5078   }</span>
5079       else
<span class="line-modified">5080   child_watch_source-&gt;child_status = child_status;</span>
5081     }
5082 
5083   return child_exited;
5084 }
5085 
5086 static void
5087 g_child_watch_finalize (GSource *source)
5088 {
5089 }
5090 
5091 #else /* G_OS_WIN32 */
5092 
5093 static void
5094 wake_source (GSource *source)
5095 {
5096   GMainContext *context;
5097 
5098   /* This should be thread-safe:
5099    *
5100    *  - if the source is currently being added to a context, that
</pre>
<hr />
<pre>
5157       pending[i] = unix_signal_pending[i];
5158       if (pending[i])
5159         unix_signal_pending[i] = FALSE;
5160     }
5161 
5162   /* handle GChildWatchSource instances */
5163   if (pending[SIGCHLD])
5164     {
5165       /* The only way we can do this is to scan all of the children.
5166        *
5167        * The docs promise that we will not reap children that we are not
5168        * explicitly watching, so that ties our hands from calling
5169        * waitpid(-1).  We also can&#39;t use siginfo&#39;s si_pid field since if
5170        * multiple SIGCHLD arrive at the same time, one of them can be
5171        * dropped (since a given UNIX signal can only be pending once).
5172        */
5173       for (node = unix_child_watches; node; node = node-&gt;next)
5174         {
5175           GChildWatchSource *source = node-&gt;data;
5176 
<span class="line-modified">5177           if (!g_atomic_int_get (&amp;source-&gt;child_exited))</span>
5178             {
5179               pid_t pid;
5180               do
5181                 {
5182                   g_assert (source-&gt;pid &gt; 0);
5183 
5184                   pid = waitpid (source-&gt;pid, &amp;source-&gt;child_status, WNOHANG);
5185                   if (pid &gt; 0)
5186                     {
<span class="line-modified">5187                       g_atomic_int_set (&amp;source-&gt;child_exited, TRUE);</span>
5188                       wake_source ((GSource *) source);
5189                     }
5190                   else if (pid == -1 &amp;&amp; errno == ECHILD)
5191                     {
5192                       g_warning (&quot;GChildWatchSource: Exit status of a child process was requested but ECHILD was received by waitpid(). See the documentation of g_child_watch_source_new() for possible causes.&quot;);

5193                       source-&gt;child_status = 0;
<span class="line-added">5194                       g_atomic_int_set (&amp;source-&gt;child_exited, TRUE);</span>
5195                       wake_source ((GSource *) source);
5196                     }
5197                 }
5198               while (pid == -1 &amp;&amp; errno == EINTR);
5199             }
5200         }
5201     }
5202 
5203   /* handle GUnixSignalWatchSource instances */
5204   for (node = unix_signal_watches; node; node = node-&gt;next)
5205     {
5206       GUnixSignalWatchSource *source = node-&gt;data;
5207 
<span class="line-modified">5208       if (pending[source-&gt;signum] &amp;&amp;</span>
<span class="line-added">5209           g_atomic_int_compare_and_exchange (&amp;source-&gt;pending, FALSE, TRUE))</span>
5210         {
<span class="line-modified">5211           wake_source ((GSource *) source);</span>





5212         }
5213     }
5214 
5215 }
5216 
5217 static void
5218 dispatch_unix_signals (void)
5219 {
5220   G_LOCK(unix_signal_lock);
5221   dispatch_unix_signals_unlocked ();
5222   G_UNLOCK(unix_signal_lock);
5223 }
5224 
5225 static gboolean
5226 g_child_watch_prepare (GSource *source,
<span class="line-modified">5227            gint    *timeout)</span>
5228 {
5229   GChildWatchSource *child_watch_source;
5230 
5231   child_watch_source = (GChildWatchSource *) source;
5232 
<span class="line-modified">5233   return g_atomic_int_get (&amp;child_watch_source-&gt;child_exited);</span>
5234 }
5235 
5236 static gboolean
5237 g_child_watch_check (GSource *source)
5238 {
5239   GChildWatchSource *child_watch_source;
5240 
5241   child_watch_source = (GChildWatchSource *) source;
5242 
<span class="line-modified">5243   return g_atomic_int_get (&amp;child_watch_source-&gt;child_exited);</span>
5244 }
5245 
5246 static gboolean
5247 g_unix_signal_watch_prepare (GSource *source,
<span class="line-modified">5248            gint    *timeout)</span>
5249 {
5250   GUnixSignalWatchSource *unix_signal_source;
5251 
5252   unix_signal_source = (GUnixSignalWatchSource *) source;
5253 
<span class="line-modified">5254   return g_atomic_int_get (&amp;unix_signal_source-&gt;pending);</span>
5255 }
5256 
5257 static gboolean
5258 g_unix_signal_watch_check (GSource  *source)
5259 {
5260   GUnixSignalWatchSource *unix_signal_source;
5261 
5262   unix_signal_source = (GUnixSignalWatchSource *) source;
5263 
<span class="line-modified">5264   return g_atomic_int_get (&amp;unix_signal_source-&gt;pending);</span>
5265 }
5266 
5267 static gboolean
5268 g_unix_signal_watch_dispatch (GSource    *source,
<span class="line-modified">5269             GSourceFunc callback,</span>
<span class="line-modified">5270             gpointer    user_data)</span>
5271 {
5272   GUnixSignalWatchSource *unix_signal_source;
5273   gboolean again;
5274 
5275   unix_signal_source = (GUnixSignalWatchSource *) source;
5276 
5277   if (!callback)
5278     {
5279       g_warning (&quot;Unix signal source dispatched without callback. &quot;
<span class="line-modified">5280      &quot;You must call g_source_set_callback().&quot;);</span>
5281       return FALSE;
5282     }
5283 
<span class="line-modified">5284   g_atomic_int_set (&amp;unix_signal_source-&gt;pending, FALSE);</span>
5285 
<span class="line-modified">5286   again = (callback) (user_data);</span>
5287 
5288   return again;
5289 }
5290 
5291 static void
5292 ref_unix_signal_handler_unlocked (int signum)
5293 {
5294   /* Ensure we have the worker context */
5295   g_get_worker_context ();
5296   unix_signal_refcount[signum]++;
5297   if (unix_signal_refcount[signum] == 1)
5298     {
5299       struct sigaction action;
5300       action.sa_handler = g_unix_signal_handler;
5301       sigemptyset (&amp;action.sa_mask);
5302 #ifdef SA_RESTART
5303       action.sa_flags = SA_RESTART | SA_NOCLDSTOP;
5304 #else
5305       action.sa_flags = SA_NOCLDSTOP;
5306 #endif
</pre>
<hr />
<pre>
5417 
5418   G_LOCK (unix_signal_lock);
5419   unref_unix_signal_handler_unlocked (unix_signal_source-&gt;signum);
5420   unix_signal_watches = g_slist_remove (unix_signal_watches, source);
5421   G_UNLOCK (unix_signal_lock);
5422 }
5423 
5424 static void
5425 g_child_watch_finalize (GSource *source)
5426 {
5427   G_LOCK (unix_signal_lock);
5428   unix_child_watches = g_slist_remove (unix_child_watches, source);
5429   unref_unix_signal_handler_unlocked (SIGCHLD);
5430   G_UNLOCK (unix_signal_lock);
5431 }
5432 
5433 #endif /* G_OS_WIN32 */
5434 
5435 static gboolean
5436 g_child_watch_dispatch (GSource    *source,
<span class="line-modified">5437       GSourceFunc callback,</span>
<span class="line-modified">5438       gpointer    user_data)</span>
5439 {
5440   GChildWatchSource *child_watch_source;
5441   GChildWatchFunc child_watch_callback = (GChildWatchFunc) callback;
5442 
5443   child_watch_source = (GChildWatchSource *) source;
5444 
5445   if (!callback)
5446     {
5447       g_warning (&quot;Child watch source dispatched without callback. &quot;
<span class="line-modified">5448      &quot;You must call g_source_set_callback().&quot;);</span>
5449       return FALSE;
5450     }
5451 
5452   (child_watch_callback) (child_watch_source-&gt;pid, child_watch_source-&gt;child_status, user_data);
5453 
5454   /* We never keep a child watch source around as the child is gone */
5455   return FALSE;
5456 }
5457 
5458 #ifndef G_OS_WIN32
5459 
5460 static void
5461 g_unix_signal_handler (int signum)
5462 {
5463   gint saved_errno = errno;
5464 
5465   unix_signal_pending[signum] = TRUE;
5466   any_unix_signal_pending = TRUE;
5467 
5468   g_wakeup_signal (glib_worker_context-&gt;wakeup);
</pre>
<hr />
<pre>
5577  * Also, note that on platforms where #GPid must be explicitly closed
5578  * (see g_spawn_close_pid()) @pid must not be closed while the source
5579  * is still active.  Typically, you should invoke g_spawn_close_pid()
5580  * in the callback function for the source.
5581  *
5582  * GLib supports only a single callback per process id.
5583  * On POSIX platforms, the same restrictions mentioned for
5584  * g_child_watch_source_new() apply to this function.
5585  *
5586  * This internally creates a main loop source using
5587  * g_child_watch_source_new() and attaches it to the main loop context
5588  * using g_source_attach(). You can do these steps manually if you
5589  * need greater control.
5590  *
5591  * Returns: the ID (greater than 0) of the event source.
5592  *
5593  * Since: 2.4
5594  **/
5595 guint
5596 g_child_watch_add_full (gint            priority,
<span class="line-modified">5597       GPid            pid,</span>
<span class="line-modified">5598       GChildWatchFunc function,</span>
<span class="line-modified">5599       gpointer        data,</span>
<span class="line-modified">5600       GDestroyNotify  notify)</span>
5601 {
5602   GSource *source;
5603   guint id;
5604 
5605   g_return_val_if_fail (function != NULL, 0);
5606 #ifndef G_OS_WIN32
5607   g_return_val_if_fail (pid &gt; 0, 0);
5608 #endif
5609 
5610   source = g_child_watch_source_new (pid);
5611 
5612   if (priority != G_PRIORITY_DEFAULT)
5613     g_source_set_priority (source, priority);
5614 
5615   g_source_set_callback (source, (GSourceFunc) function, data, notify);
5616   id = g_source_attach (source, NULL);
5617   g_source_unref (source);
5618 
5619   return id;
5620 }
</pre>
<hr />
<pre>
5637  * Note that on platforms where #GPid must be explicitly closed
5638  * (see g_spawn_close_pid()) @pid must not be closed while the
5639  * source is still active. Typically, you will want to call
5640  * g_spawn_close_pid() in the callback function for the source.
5641  *
5642  * GLib supports only a single callback per process id.
5643  * On POSIX platforms, the same restrictions mentioned for
5644  * g_child_watch_source_new() apply to this function.
5645  *
5646  * This internally creates a main loop source using
5647  * g_child_watch_source_new() and attaches it to the main loop context
5648  * using g_source_attach(). You can do these steps manually if you
5649  * need greater control.
5650  *
5651  * Returns: the ID (greater than 0) of the event source.
5652  *
5653  * Since: 2.4
5654  **/
5655 guint
5656 g_child_watch_add (GPid            pid,
<span class="line-modified">5657        GChildWatchFunc function,</span>
<span class="line-modified">5658        gpointer        data)</span>
5659 {
5660   return g_child_watch_add_full (G_PRIORITY_DEFAULT, pid, function, data, NULL);
5661 }
5662 
5663 
5664 /* Idle functions */
5665 
5666 static gboolean
5667 g_idle_prepare  (GSource  *source,
<span class="line-modified">5668      gint     *timeout)</span>
5669 {
5670   *timeout = 0;
5671 
5672   return TRUE;
5673 }
5674 
5675 static gboolean
5676 g_idle_check    (GSource  *source)
5677 {
5678   return TRUE;
5679 }
5680 
5681 static gboolean
5682 g_idle_dispatch (GSource    *source,
<span class="line-modified">5683      GSourceFunc callback,</span>
<span class="line-modified">5684      gpointer    user_data)</span>
5685 {
5686   gboolean again;
5687 
5688   if (!callback)
5689     {
5690       g_warning (&quot;Idle source dispatched without callback. &quot;
<span class="line-modified">5691      &quot;You must call g_source_set_callback().&quot;);</span>
5692       return FALSE;
5693     }
5694 
5695   again = callback (user_data);
5696 
5697   TRACE (GLIB_IDLE_DISPATCH (source, source-&gt;context, callback, user_data, again));
5698 
5699   return again;
5700 }
5701 
5702 /**
5703  * g_idle_source_new:
5704  *
5705  * Creates a new idle source.
5706  *
5707  * The source will not initially be associated with any #GMainContext
5708  * and must be added to one with g_source_attach() before it will be
5709  * executed. Note that the default priority for idle sources is
5710  * %G_PRIORITY_DEFAULT_IDLE, as compared to other sources which
5711  * have a default priority of %G_PRIORITY_DEFAULT.
</pre>
<hr />
<pre>
5734  * @data:     data to pass to @function
5735  * @notify: (nullable): function to call when the idle is removed, or %NULL
5736  *
5737  * Adds a function to be called whenever there are no higher priority
5738  * events pending.  If the function returns %FALSE it is automatically
5739  * removed from the list of event sources and will not be called again.
5740  *
5741  * See [memory management of sources][mainloop-memory-management] for details
5742  * on how to handle the return value and memory management of @data.
5743  *
5744  * This internally creates a main loop source using g_idle_source_new()
5745  * and attaches it to the global #GMainContext using g_source_attach(), so
5746  * the callback will be invoked in whichever thread is running that main
5747  * context. You can do these steps manually if you need greater control or to
5748  * use a custom main context.
5749  *
5750  * Returns: the ID (greater than 0) of the event source.
5751  **/
5752 guint
5753 g_idle_add_full (gint           priority,
<span class="line-modified">5754      GSourceFunc    function,</span>
<span class="line-modified">5755      gpointer       data,</span>
<span class="line-modified">5756      GDestroyNotify notify)</span>
5757 {
5758   GSource *source;
5759   guint id;
5760 
5761   g_return_val_if_fail (function != NULL, 0);
5762 
5763   source = g_idle_source_new ();
5764 
5765   if (priority != G_PRIORITY_DEFAULT_IDLE)
5766     g_source_set_priority (source, priority);
5767 
5768   g_source_set_callback (source, function, data, notify);
5769   id = g_source_attach (source, NULL);
5770 
5771   TRACE (GLIB_IDLE_ADD (source, g_main_context_default (), id, priority, function, data));
5772 
5773   g_source_unref (source);
5774 
5775   return id;
5776 }
</pre>
<hr />
<pre>
5782  *
5783  * Adds a function to be called whenever there are no higher priority
5784  * events pending to the default main loop. The function is given the
5785  * default idle priority, #G_PRIORITY_DEFAULT_IDLE.  If the function
5786  * returns %FALSE it is automatically removed from the list of event
5787  * sources and will not be called again.
5788  *
5789  * See [memory management of sources][mainloop-memory-management] for details
5790  * on how to handle the return value and memory management of @data.
5791  *
5792  * This internally creates a main loop source using g_idle_source_new()
5793  * and attaches it to the global #GMainContext using g_source_attach(), so
5794  * the callback will be invoked in whichever thread is running that main
5795  * context. You can do these steps manually if you need greater control or to
5796  * use a custom main context.
5797  *
5798  * Returns: the ID (greater than 0) of the event source.
5799  **/
5800 guint
5801 g_idle_add (GSourceFunc    function,
<span class="line-modified">5802       gpointer       data)</span>
5803 {
5804   return g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, function, data, NULL);
5805 }
5806 
5807 /**
5808  * g_idle_remove_by_data:
5809  * @data: the data for the idle source&#39;s callback.
5810  *
5811  * Removes the idle function with the given data.
5812  *
5813  * Returns: %TRUE if an idle source was found and removed.
5814  **/
5815 gboolean
5816 g_idle_remove_by_data (gpointer data)
5817 {
5818   return g_source_remove_by_funcs_user_data (&amp;g_idle_funcs, data);
5819 }
5820 
5821 /**
5822  * g_main_context_invoke:
5823  * @context: (nullable): a #GMainContext, or %NULL
5824  * @function: function to call
5825  * @data: data to pass to @function
5826  *
5827  * Invokes a function in such a way that @context is owned during the
5828  * invocation of @function.
5829  *
<span class="line-modified">5830  * If @context is %NULL then the global default main context - as</span>
<span class="line-modified">5831  * returned by g_main_context_default() - is used.</span>
5832  *
5833  * If @context is owned by the current thread, @function is called
5834  * directly.  Otherwise, if @context is the thread-default main context
5835  * of the current thread and g_main_context_acquire() succeeds, then
5836  * @function is called and g_main_context_release() is called
5837  * afterwards.
5838  *
5839  * In any other case, an idle source is created to call @function and
5840  * that source is attached to @context (presumably to be run in another
5841  * thread).  The idle source is attached with #G_PRIORITY_DEFAULT
5842  * priority.  If you want a different priority, use
5843  * g_main_context_invoke_full().
5844  *
5845  * Note that, as with normal idle functions, @function should probably
5846  * return %FALSE.  If it returns %TRUE, it will be continuously run in a
5847  * loop (and may prevent this call from returning).
5848  *
5849  * Since: 2.28
5850  **/
5851 void
</pre>
</td>
</tr>
</table>
<center><a href="gmacros.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gmain.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>