<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gstring.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstrfuncs.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstring.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gstring.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 410,42 ***</span>
   * g_string_insert_len:
   * @string: a #GString
   * @pos: position in @string where insertion should
   *       happen, or -1 for at the end
   * @val: bytes to insert
<span class="line-modified">!  * @len: number of bytes of @val to insert</span>
   *
   * Inserts @len bytes of @val into @string at @pos.
<span class="line-removed">-  * Because @len is provided, @val may contain embedded</span>
<span class="line-removed">-  * nuls and need not be nul-terminated. If @pos is -1,</span>
<span class="line-removed">-  * bytes are inserted at the end of the string.</span>
   *
<span class="line-modified">!  * Since this function does not stop at nul bytes, it is</span>
<span class="line-modified">!  * the caller&#39;s responsibility to ensure that @val has at</span>
<span class="line-modified">!  * least @len addressable bytes.</span>
   *
   * Returns: (transfer none): @string
   */
  GString *
  g_string_insert_len (GString     *string,
                       gssize       pos,
                       const gchar *val,
                       gssize       len)
  {
    g_return_val_if_fail (string != NULL, NULL);
    g_return_val_if_fail (len == 0 || val != NULL, string);
  
    if (len == 0)
      return string;
  
    if (len &lt; 0)
      len = strlen (val);
  
    if (pos &lt; 0)
<span class="line-modified">!     pos = string-&gt;len;</span>
    else
<span class="line-modified">!     g_return_val_if_fail (pos &lt;= string-&gt;len, string);</span>
  
    /* Check whether val represents a substring of string.
     * This test probably violates chapter and verse of the C standards,
     * since &quot;&gt;=&quot; and &quot;&lt;=&quot; are only valid when val really is a substring.
     * In practice, it will work on modern archs.
<span class="line-new-header">--- 410,50 ---</span>
   * g_string_insert_len:
   * @string: a #GString
   * @pos: position in @string where insertion should
   *       happen, or -1 for at the end
   * @val: bytes to insert
<span class="line-modified">!  * @len: number of bytes of @val to insert, or -1 for all of @val</span>
   *
   * Inserts @len bytes of @val into @string at @pos.
   *
<span class="line-modified">!  * If @len is positive, @val may contain embedded nuls and need</span>
<span class="line-modified">!  * not be nul-terminated. It is the caller&#39;s responsibility to</span>
<span class="line-modified">!  * ensure that @val has at least @len addressable bytes.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * If @len is negative, @val must be nul-terminated and @len</span>
<span class="line-added">+  * is considered to request the entire string length.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * If @pos is -1, bytes are inserted at the end of the string.</span>
   *
   * Returns: (transfer none): @string
   */
  GString *
  g_string_insert_len (GString     *string,
                       gssize       pos,
                       const gchar *val,
                       gssize       len)
  {
<span class="line-added">+   gsize len_unsigned, pos_unsigned;</span>
<span class="line-added">+ </span>
    g_return_val_if_fail (string != NULL, NULL);
    g_return_val_if_fail (len == 0 || val != NULL, string);
  
    if (len == 0)
      return string;
  
    if (len &lt; 0)
      len = strlen (val);
<span class="line-added">+   len_unsigned = len;</span>
  
    if (pos &lt; 0)
<span class="line-modified">!     pos_unsigned = string-&gt;len;</span>
    else
<span class="line-modified">!     {</span>
<span class="line-added">+       pos_unsigned = pos;</span>
<span class="line-added">+       g_return_val_if_fail (pos_unsigned &lt;= string-&gt;len, string);</span>
<span class="line-added">+     }</span>
  
    /* Check whether val represents a substring of string.
     * This test probably violates chapter and verse of the C standards,
     * since &quot;&gt;=&quot; and &quot;&lt;=&quot; are only valid when val really is a substring.
     * In practice, it will work on modern archs.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 453,49 ***</span>
    if (G_UNLIKELY (val &gt;= string-&gt;str &amp;&amp; val &lt;= string-&gt;str + string-&gt;len))
      {
        gsize offset = val - string-&gt;str;
        gsize precount = 0;
  
<span class="line-modified">!       g_string_maybe_expand (string, len);</span>
        val = string-&gt;str + offset;
        /* At this point, val is valid again.  */
  
        /* Open up space where we are going to insert.  */
<span class="line-modified">!       if (pos &lt; string-&gt;len)</span>
<span class="line-modified">!         memmove (string-&gt;str + pos + len, string-&gt;str + pos, string-&gt;len - pos);</span>
  
        /* Move the source part before the gap, if any.  */
<span class="line-modified">!       if (offset &lt; pos)</span>
          {
<span class="line-modified">!           precount = MIN (len, pos - offset);</span>
<span class="line-modified">!           memcpy (string-&gt;str + pos, val, precount);</span>
          }
  
        /* Move the source part after the gap, if any.  */
<span class="line-modified">!       if (len &gt; precount)</span>
<span class="line-modified">!         memcpy (string-&gt;str + pos + precount,</span>
<span class="line-modified">!                 val + /* Already moved: */ precount + /* Space opened up: */ len,</span>
<span class="line-modified">!                 len - precount);</span>
      }
    else
      {
<span class="line-modified">!       g_string_maybe_expand (string, len);</span>
  
        /* If we aren&#39;t appending at the end, move a hunk
         * of the old string to the end, opening up space
         */
<span class="line-modified">!       if (pos &lt; string-&gt;len)</span>
<span class="line-modified">!         memmove (string-&gt;str + pos + len, string-&gt;str + pos, string-&gt;len - pos);</span>
  
        /* insert the new string */
<span class="line-modified">!       if (len == 1)</span>
<span class="line-modified">!         string-&gt;str[pos] = *val;</span>
        else
<span class="line-modified">!         memcpy (string-&gt;str + pos, val, len);</span>
      }
  
<span class="line-modified">!   string-&gt;len += len;</span>
  
    string-&gt;str[string-&gt;len] = 0;
  
    return string;
  }
<span class="line-new-header">--- 461,52 ---</span>
    if (G_UNLIKELY (val &gt;= string-&gt;str &amp;&amp; val &lt;= string-&gt;str + string-&gt;len))
      {
        gsize offset = val - string-&gt;str;
        gsize precount = 0;
  
<span class="line-modified">!       g_string_maybe_expand (string, len_unsigned);</span>
        val = string-&gt;str + offset;
        /* At this point, val is valid again.  */
  
        /* Open up space where we are going to insert.  */
<span class="line-modified">!       if (pos_unsigned &lt; string-&gt;len)</span>
<span class="line-modified">!         memmove (string-&gt;str + pos_unsigned + len_unsigned,</span>
<span class="line-added">+                  string-&gt;str + pos_unsigned, string-&gt;len - pos_unsigned);</span>
  
        /* Move the source part before the gap, if any.  */
<span class="line-modified">!       if (offset &lt; pos_unsigned)</span>
          {
<span class="line-modified">!           precount = MIN (len_unsigned, pos_unsigned - offset);</span>
<span class="line-modified">!           memcpy (string-&gt;str + pos_unsigned, val, precount);</span>
          }
  
        /* Move the source part after the gap, if any.  */
<span class="line-modified">!       if (len_unsigned &gt; precount)</span>
<span class="line-modified">!         memcpy (string-&gt;str + pos_unsigned + precount,</span>
<span class="line-modified">!                 val + /* Already moved: */ precount +</span>
<span class="line-modified">!                       /* Space opened up: */ len_unsigned,</span>
<span class="line-added">+                 len_unsigned - precount);</span>
      }
    else
      {
<span class="line-modified">!       g_string_maybe_expand (string, len_unsigned);</span>
  
        /* If we aren&#39;t appending at the end, move a hunk
         * of the old string to the end, opening up space
         */
<span class="line-modified">!       if (pos_unsigned &lt; string-&gt;len)</span>
<span class="line-modified">!         memmove (string-&gt;str + pos_unsigned + len_unsigned,</span>
<span class="line-added">+                  string-&gt;str + pos_unsigned, string-&gt;len - pos_unsigned);</span>
  
        /* insert the new string */
<span class="line-modified">!       if (len_unsigned == 1)</span>
<span class="line-modified">!         string-&gt;str[pos_unsigned] = *val;</span>
        else
<span class="line-modified">!         memcpy (string-&gt;str + pos_unsigned, val, len_unsigned);</span>
      }
  
<span class="line-modified">!   string-&gt;len += len_unsigned;</span>
  
    string-&gt;str[string-&gt;len] = 0;
  
    return string;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 603,19 ***</span>
  
  /**
   * g_string_append_len:
   * @string: a #GString
   * @val: bytes to append
<span class="line-modified">!  * @len: number of bytes of @val to use</span>
   *
<span class="line-modified">!  * Appends @len bytes of @val to @string. Because @len is</span>
<span class="line-removed">-  * provided, @val may contain embedded nuls and need not</span>
<span class="line-removed">-  * be nul-terminated.</span>
   *
<span class="line-modified">!  * Since this function does not stop at nul bytes, it is</span>
<span class="line-modified">!  * the caller&#39;s responsibility to ensure that @val has at</span>
<span class="line-modified">!  * least @len addressable bytes.</span>
   *
   * Returns: (transfer none): @string
   */
  GString *
  g_string_append_len (GString     *string,
<span class="line-new-header">--- 614,21 ---</span>
  
  /**
   * g_string_append_len:
   * @string: a #GString
   * @val: bytes to append
<span class="line-modified">!  * @len: number of bytes of @val to use, or -1 for all of @val</span>
   *
<span class="line-modified">!  * Appends @len bytes of @val to @string.</span>
   *
<span class="line-modified">!  * If @len is positive, @val may contain embedded nuls and need</span>
<span class="line-modified">!  * not be nul-terminated. It is the caller&#39;s responsibility to</span>
<span class="line-modified">!  * ensure that @val has at least @len addressable bytes.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * If @len is negative, @val must be nul-terminated and @len</span>
<span class="line-added">+  * is considered to request the entire string length. This</span>
<span class="line-added">+  * makes g_string_append_len() equivalent to g_string_append().</span>
   *
   * Returns: (transfer none): @string
   */
  GString *
  g_string_append_len (GString     *string,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 683,19 ***</span>
  
  /**
   * g_string_prepend_len:
   * @string: a #GString
   * @val: bytes to prepend
<span class="line-modified">!  * @len: number of bytes in @val to prepend</span>
   *
   * Prepends @len bytes of @val to @string.
<span class="line-removed">-  * Because @len is provided, @val may contain</span>
<span class="line-removed">-  * embedded nuls and need not be nul-terminated.</span>
   *
<span class="line-modified">!  * Since this function does not stop at nul bytes,</span>
<span class="line-modified">!  * it is the caller&#39;s responsibility to ensure that</span>
<span class="line-modified">!  * @val has at least @len addressable bytes.</span>
   *
   * Returns: (transfer none): @string
   */
  GString *
  g_string_prepend_len (GString     *string,
<span class="line-new-header">--- 696,21 ---</span>
  
  /**
   * g_string_prepend_len:
   * @string: a #GString
   * @val: bytes to prepend
<span class="line-modified">!  * @len: number of bytes in @val to prepend, or -1 for all of @val</span>
   *
   * Prepends @len bytes of @val to @string.
   *
<span class="line-modified">!  * If @len is positive, @val may contain embedded nuls and need</span>
<span class="line-modified">!  * not be nul-terminated. It is the caller&#39;s responsibility to</span>
<span class="line-modified">!  * ensure that @val has at least @len addressable bytes.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * If @len is negative, @val must be nul-terminated and @len</span>
<span class="line-added">+  * is considered to request the entire string length. This</span>
<span class="line-added">+  * makes g_string_prepend_len() equivalent to g_string_prepend().</span>
   *
   * Returns: (transfer none): @string
   */
  GString *
  g_string_prepend_len (GString     *string,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 775,24 ***</span>
  GString *
  g_string_insert_c (GString *string,
                     gssize   pos,
                     gchar    c)
  {
    g_return_val_if_fail (string != NULL, NULL);
  
    g_string_maybe_expand (string, 1);
  
    if (pos &lt; 0)
      pos = string-&gt;len;
    else
<span class="line-modified">!     g_return_val_if_fail (pos &lt;= string-&gt;len, string);</span>
  
    /* If not just an append, move the old stuff */
<span class="line-modified">!   if (pos &lt; string-&gt;len)</span>
<span class="line-modified">!     memmove (string-&gt;str + pos + 1, string-&gt;str + pos, string-&gt;len - pos);</span>
  
<span class="line-modified">!   string-&gt;str[pos] = c;</span>
  
    string-&gt;len += 1;
  
    string-&gt;str[string-&gt;len] = 0;
  
<span class="line-new-header">--- 790,28 ---</span>
  GString *
  g_string_insert_c (GString *string,
                     gssize   pos,
                     gchar    c)
  {
<span class="line-added">+   gsize pos_unsigned;</span>
<span class="line-added">+ </span>
    g_return_val_if_fail (string != NULL, NULL);
  
    g_string_maybe_expand (string, 1);
  
    if (pos &lt; 0)
      pos = string-&gt;len;
    else
<span class="line-modified">!     g_return_val_if_fail ((gsize) pos &lt;= string-&gt;len, string);</span>
<span class="line-added">+   pos_unsigned = pos;</span>
  
    /* If not just an append, move the old stuff */
<span class="line-modified">!   if (pos_unsigned &lt; string-&gt;len)</span>
<span class="line-modified">!     memmove (string-&gt;str + pos_unsigned + 1,</span>
<span class="line-added">+              string-&gt;str + pos_unsigned, string-&gt;len - pos_unsigned);</span>
  
<span class="line-modified">!   string-&gt;str[pos_unsigned] = c;</span>
  
    string-&gt;len += 1;
  
    string-&gt;str[string-&gt;len] = 0;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 857,14 ***</span>
    g_string_maybe_expand (string, charlen);
  
    if (pos &lt; 0)
      pos = string-&gt;len;
    else
<span class="line-modified">!     g_return_val_if_fail (pos &lt;= string-&gt;len, string);</span>
  
    /* If not just an append, move the old stuff */
<span class="line-modified">!   if (pos &lt; string-&gt;len)</span>
      memmove (string-&gt;str + pos + charlen, string-&gt;str + pos, string-&gt;len - pos);
  
    dest = string-&gt;str + pos;
    /* Code copied from g_unichar_to_utf() */
    for (i = charlen - 1; i &gt; 0; --i)
<span class="line-new-header">--- 876,14 ---</span>
    g_string_maybe_expand (string, charlen);
  
    if (pos &lt; 0)
      pos = string-&gt;len;
    else
<span class="line-modified">!     g_return_val_if_fail ((gsize) pos &lt;= string-&gt;len, string);</span>
  
    /* If not just an append, move the old stuff */
<span class="line-modified">!   if ((gsize) pos &lt; string-&gt;len)</span>
      memmove (string-&gt;str + pos + charlen, string-&gt;str + pos, string-&gt;len - pos);
  
    dest = string-&gt;str + pos;
    /* Code copied from g_unichar_to_utf() */
    for (i = charlen - 1; i &gt; 0; --i)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 967,25 ***</span>
  GString *
  g_string_erase (GString *string,
                  gssize   pos,
                  gssize   len)
  {
    g_return_val_if_fail (string != NULL, NULL);
    g_return_val_if_fail (pos &gt;= 0, string);
<span class="line-modified">!   g_return_val_if_fail (pos &lt;= string-&gt;len, string);</span>
  
    if (len &lt; 0)
<span class="line-modified">!     len = string-&gt;len - pos;</span>
    else
      {
<span class="line-modified">!       g_return_val_if_fail (pos + len &lt;= string-&gt;len, string);</span>
  
<span class="line-modified">!       if (pos + len &lt; string-&gt;len)</span>
<span class="line-modified">!         memmove (string-&gt;str + pos, string-&gt;str + pos + len, string-&gt;len - (pos + len));</span>
      }
  
<span class="line-modified">!   string-&gt;len -= len;</span>
  
    string-&gt;str[string-&gt;len] = 0;
  
    return string;
  }
<span class="line-new-header">--- 986,32 ---</span>
  GString *
  g_string_erase (GString *string,
                  gssize   pos,
                  gssize   len)
  {
<span class="line-added">+   gsize len_unsigned, pos_unsigned;</span>
<span class="line-added">+ </span>
    g_return_val_if_fail (string != NULL, NULL);
    g_return_val_if_fail (pos &gt;= 0, string);
<span class="line-modified">!   pos_unsigned = pos;</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_return_val_if_fail (pos_unsigned &lt;= string-&gt;len, string);</span>
  
    if (len &lt; 0)
<span class="line-modified">!     len_unsigned = string-&gt;len - pos_unsigned;</span>
    else
      {
<span class="line-modified">!       len_unsigned = len;</span>
<span class="line-added">+       g_return_val_if_fail (pos_unsigned + len_unsigned &lt;= string-&gt;len, string);</span>
  
<span class="line-modified">!       if (pos_unsigned + len_unsigned &lt; string-&gt;len)</span>
<span class="line-modified">!         memmove (string-&gt;str + pos_unsigned,</span>
<span class="line-added">+                  string-&gt;str + pos_unsigned + len_unsigned,</span>
<span class="line-added">+                  string-&gt;len - (pos_unsigned + len_unsigned));</span>
      }
  
<span class="line-modified">!   string-&gt;len -= len_unsigned;</span>
  
    string-&gt;str[string-&gt;len] = 0;
  
    return string;
  }
</pre>
<center><a href="gstrfuncs.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstring.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>