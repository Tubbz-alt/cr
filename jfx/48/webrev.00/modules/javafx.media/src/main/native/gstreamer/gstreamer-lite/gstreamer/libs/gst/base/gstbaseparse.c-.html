<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstbaseparse.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 2008 Nokia Corporation. All rights reserved.
   3  *   Contact: Stefan Kost &lt;stefan.kost@nokia.com&gt;
   4  * Copyright (C) 2008 Sebastian Dröge &lt;sebastian.droege@collabora.co.uk&gt;.
   5  * Copyright (C) 2011, Hewlett-Packard Development Company, L.P.
   6  *   Author: Sebastian Dröge &lt;sebastian.droege@collabora.co.uk&gt;, Collabora Ltd.
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public
  19  * License along with this library; if not, write to the
  20  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 /**
  25  * SECTION:gstbaseparse
  26  * @title: GstBaseParse
  27  * @short_description: Base class for stream parsers
  28  * @see_also: #GstBaseTransform
  29  *
  30  * This base class is for parser elements that process data and splits it
  31  * into separate audio/video/whatever frames.
  32  *
  33  * It provides for:
  34  *
  35  *   * provides one sink pad and one source pad
  36  *   * handles state changes
  37  *   * can operate in pull mode or push mode
  38  *   * handles seeking in both modes
  39  *   * handles events (SEGMENT/EOS/FLUSH)
  40  *   * handles queries (POSITION/DURATION/SEEKING/FORMAT/CONVERT)
  41  *   * handles flushing
  42  *
  43  * The purpose of this base class is to provide the basic functionality of
  44  * a parser and share a lot of rather complex code.
  45  *
  46  * # Description of the parsing mechanism:
  47  *
  48  * ## Set-up phase
  49  *
  50  *  * #GstBaseParse calls @start to inform subclass that data processing is
  51  *    about to start now.
  52  *
  53  *  * #GstBaseParse class calls @set_sink_caps to inform the subclass about
  54  *    incoming sinkpad caps. Subclass could already set the srcpad caps
  55  *    accordingly, but this might be delayed until calling
  56  *    gst_base_parse_finish_frame() with a non-queued frame.
  57  *
  58  *  * At least at this point subclass needs to tell the #GstBaseParse class
  59  *    how big data chunks it wants to receive (min_frame_size). It can do
  60  *    this with gst_base_parse_set_min_frame_size().
  61  *
  62  *  * #GstBaseParse class sets up appropriate data passing mode (pull/push)
  63  *    and starts to process the data.
  64  *
  65  * ## Parsing phase
  66  *
  67  *  * #GstBaseParse gathers at least min_frame_size bytes of data either
  68  *    by pulling it from upstream or collecting buffers in an internal
  69  *    #GstAdapter.
  70  *
  71  *  * A buffer of (at least) min_frame_size bytes is passed to subclass with
  72  *    @handle_frame. Subclass checks the contents and can optionally
  73  *    return GST_FLOW_OK along with an amount of data to be skipped to find
  74  *    a valid frame (which will result in a subsequent DISCONT).
  75  *    If, otherwise, the buffer does not hold a complete frame,
  76  *    @handle_frame can merely return and will be called again when additional
  77  *    data is available.  In push mode this amounts to an
  78  *    additional input buffer (thus minimal additional latency), in pull mode
  79  *    this amounts to some arbitrary reasonable buffer size increase.
  80  *    Of course, gst_base_parse_set_min_frame_size() could also be used if a
  81  *    very specific known amount of additional data is required.
  82  *    If, however, the buffer holds a complete valid frame, it can pass
  83  *    the size of this frame to gst_base_parse_finish_frame().
  84  *    If acting as a converter, it can also merely indicate consumed input data
  85  *    while simultaneously providing custom output data.
  86  *    Note that baseclass performs some processing (such as tracking
  87  *    overall consumed data rate versus duration) for each finished frame,
  88  *    but other state is only updated upon each call to @handle_frame
  89  *    (such as tracking upstream input timestamp).
  90  *
  91  *    Subclass is also responsible for setting the buffer metadata
  92  *    (e.g. buffer timestamp and duration, or keyframe if applicable).
  93  *    (although the latter can also be done by #GstBaseParse if it is
  94  *    appropriately configured, see below).  Frame is provided with
  95  *    timestamp derived from upstream (as much as generally possible),
  96  *    duration obtained from configuration (see below), and offset
  97  *    if meaningful (in pull mode).
  98  *
  99  *    Note that @check_valid_frame might receive any small
 100  *    amount of input data when leftover data is being drained (e.g. at EOS).
 101  *
 102  *  * As part of finish frame processing,
 103  *    just prior to actually pushing the buffer in question,
 104  *    it is passed to @pre_push_frame which gives subclass yet one
 105  *    last chance to examine buffer metadata, or to send some custom (tag)
 106  *    events, or to perform custom (segment) filtering.
 107  *
 108  *  * During the parsing process #GstBaseParseClass will handle both srcpad
 109  *    and sinkpad events. They will be passed to subclass if @event or
 110  *    @src_event callbacks have been provided.
 111  *
 112  * ## Shutdown phase
 113  *
 114  * * #GstBaseParse class calls @stop to inform the subclass that data
 115  *   parsing will be stopped.
 116  *
 117  * Subclass is responsible for providing pad template caps for
 118  * source and sink pads. The pads need to be named &quot;sink&quot; and &quot;src&quot;. It also
 119  * needs to set the fixed caps on srcpad, when the format is ensured (e.g.
 120  * when base class calls subclass&#39; @set_sink_caps function).
 121  *
 122  * This base class uses %GST_FORMAT_DEFAULT as a meaning of frames. So,
 123  * subclass conversion routine needs to know that conversion from
 124  * %GST_FORMAT_TIME to %GST_FORMAT_DEFAULT must return the
 125  * frame number that can be found from the given byte position.
 126  *
 127  * #GstBaseParse uses subclasses conversion methods also for seeking (or
 128  * otherwise uses its own default one, see also below).
 129  *
 130  * Subclass @start and @stop functions will be called to inform the beginning
 131  * and end of data processing.
 132  *
 133  * Things that subclass need to take care of:
 134  *
 135  * * Provide pad templates
 136  * * Fixate the source pad caps when appropriate
 137  * * Inform base class how big data chunks should be retrieved. This is
 138  *   done with gst_base_parse_set_min_frame_size() function.
 139  * * Examine data chunks passed to subclass with @handle_frame and pass
 140  *   proper frame(s) to gst_base_parse_finish_frame(), and setting src pad
 141  *   caps and timestamps on frame.
 142  * * Provide conversion functions
 143  * * Update the duration information with gst_base_parse_set_duration()
 144  * * Optionally passthrough using gst_base_parse_set_passthrough()
 145  * * Configure various baseparse parameters using
 146  *   gst_base_parse_set_average_bitrate(), gst_base_parse_set_syncable()
 147  *   and gst_base_parse_set_frame_rate().
 148  *
 149  * * In particular, if subclass is unable to determine a duration, but
 150  *   parsing (or specs) yields a frames per seconds rate, then this can be
 151  *   provided to #GstBaseParse to enable it to cater for
 152  *   buffer time metadata (which will be taken from upstream as much as
 153  *   possible). Internally keeping track of frame durations and respective
 154  *   sizes that have been pushed provides #GstBaseParse with an estimated
 155  *   bitrate. A default @convert (used if not overridden) will then use these
 156  *   rates to perform obvious conversions.  These rates are also used to
 157  *   update (estimated) duration at regular frame intervals.
 158  *
 159  */
 160 
 161 /* TODO:
 162  *  - In push mode provide a queue of adapter-&quot;queued&quot; buffers for upstream
 163  *    buffer metadata
 164  *  - Queue buffers/events until caps are set
 165  */
 166 
 167 #ifdef HAVE_CONFIG_H
 168 #  include &quot;config.h&quot;
 169 #endif
 170 
 171 #include &lt;stdlib.h&gt;
 172 #include &lt;string.h&gt;
 173 
 174 #include &lt;gst/base/gstadapter.h&gt;
 175 
 176 #include &quot;gstbaseparse.h&quot;
 177 
 178 /* FIXME: get rid of old GstIndex code */
 179 #include &quot;gstindex.h&quot;
 180 #include &quot;gstindex.c&quot;
 181 #include &quot;gstmemindex.c&quot;
 182 
 183 #ifdef GSTREAMER_LITE
 184 #undef GST_FUNCTION
 185 #define GST_FUNCTION &quot;&quot;
 186 #endif // GSTREAMER_LITE
 187 
 188 #define GST_BASE_PARSE_FRAME_PRIVATE_FLAG_NOALLOC  (1 &lt;&lt; 0)
 189 
 190 #define MIN_FRAMES_TO_POST_BITRATE 10
 191 #define TARGET_DIFFERENCE          (20 * GST_SECOND)
 192 #define MAX_INDEX_ENTRIES          4096
 193 #define UPDATE_THRESHOLD           2
 194 
 195 #define ABSDIFF(a,b) (((a) &gt; (b)) ? ((a) - (b)) : ((b) - (a)))
 196 
 197 GST_DEBUG_CATEGORY_STATIC (gst_base_parse_debug);
 198 #define GST_CAT_DEFAULT gst_base_parse_debug
 199 
 200 /* Supported formats */
 201 static const GstFormat fmtlist[] = {
 202   GST_FORMAT_DEFAULT,
 203   GST_FORMAT_BYTES,
 204   GST_FORMAT_TIME,
 205   GST_FORMAT_UNDEFINED
 206 };
 207 
 208 #define GST_BASE_PARSE_GET_PRIVATE(obj)  \
 209     (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_BASE_PARSE, GstBaseParsePrivate))
 210 
 211 struct _GstBaseParsePrivate
 212 {
 213   GstPadMode pad_mode;
 214 
 215   GstAdapter *adapter;
 216 
 217   gint64 duration;
 218   GstFormat duration_fmt;
 219   gint64 estimated_duration;
 220   gint64 estimated_drift;
 221 
 222   guint min_frame_size;
 223   gboolean disable_passthrough;
 224   gboolean passthrough;
 225   gboolean pts_interpolate;
 226   gboolean infer_ts;
 227   gboolean syncable;
 228   gboolean has_timing_info;
 229   guint fps_num, fps_den;
 230   gint update_interval;
 231   guint bitrate;
 232   guint lead_in, lead_out;
 233   GstClockTime lead_in_ts, lead_out_ts;
 234   GstClockTime min_latency, max_latency;
 235 
 236   gboolean discont;
 237   gboolean flushing;
 238   gboolean drain;
 239   gboolean saw_gaps;
 240 
 241   gint64 offset;
 242   gint64 sync_offset;
 243   GstClockTime next_pts;
 244   GstClockTime next_dts;
 245   GstClockTime prev_pts;
 246   GstClockTime prev_dts;
 247   gboolean prev_dts_from_pts;
 248   GstClockTime frame_duration;
 249   gboolean seen_keyframe;
 250   gboolean is_video;
 251   gint flushed;
 252 
 253   guint64 framecount;
 254   guint64 bytecount;
 255   guint64 data_bytecount;
 256   guint64 acc_duration;
 257   GstClockTime first_frame_pts;
 258   GstClockTime first_frame_dts;
 259   gint64 first_frame_offset;
 260 
 261   gboolean post_min_bitrate;
 262   gboolean post_avg_bitrate;
 263   gboolean post_max_bitrate;
 264 
 265   guint min_bitrate;
 266   guint avg_bitrate;
 267   guint max_bitrate;
 268   guint posted_avg_bitrate;
 269 
 270   /* frames/buffers that are queued and ready to go on OK */
 271   GQueue queued_frames;
 272 
 273   GstBuffer *cache;
 274 
 275   /* index entry storage, either ours or provided */
 276   GstIndex *index;
 277   gint index_id;
 278   gboolean own_index;
 279   GMutex index_lock;
 280 
 281   /* seek table entries only maintained if upstream is BYTE seekable */
 282   gboolean upstream_seekable;
 283   gboolean upstream_has_duration;
 284   gint64 upstream_size;
 285   GstFormat upstream_format;
 286   /* minimum distance between two index entries */
 287   GstClockTimeDiff idx_interval;
 288   guint64 idx_byte_interval;
 289   /* ts and offset of last entry added */
 290   GstClockTime index_last_ts;
 291   gint64 index_last_offset;
 292   gboolean index_last_valid;
 293 
 294   /* timestamps currently produced are accurate, e.g. started from 0 onwards */
 295   gboolean exact_position;
 296   /* seek events are temporarily kept to match them with newsegments */
 297   GSList *pending_seeks;
 298 
 299   /* reverse playback */
 300   GSList *buffers_pending;
 301   GSList *buffers_head;
 302   GSList *buffers_queued;
 303   GSList *buffers_send;
 304   GstClockTime last_pts;
 305   GstClockTime last_dts;
 306   gint64 last_offset;
 307 
 308   /* Pending serialized events */
 309   GList *pending_events;
 310 
 311   /* If baseparse has checked the caps to identify if it is
 312    * handling video or audio */
 313   gboolean checked_media;
 314 
 315   /* offset of last parsed frame/data */
 316   gint64 prev_offset;
 317   /* force a new frame, regardless of offset */
 318   gboolean new_frame;
 319   /* whether we are merely scanning for a frame */
 320   gboolean scanning;
 321   /* ... and resulting frame, if any */
 322   GstBaseParseFrame *scanned_frame;
 323 
 324   /* TRUE if we&#39;re still detecting the format, i.e.
 325    * if ::detect() is still called for future buffers */
 326   gboolean detecting;
 327   GList *detect_buffers;
 328   guint detect_buffers_size;
 329 
 330   /* True when no buffers have been received yet */
 331   gboolean first_buffer;
 332 
 333   /* if TRUE, a STREAM_START event needs to be pushed */
 334   gboolean push_stream_start;
 335 
 336   /* When we need to skip more data than we have currently */
 337   guint skip;
 338 
 339   /* Tag handling (stream tags only, global tags are passed through as-is) */
 340   GstTagList *upstream_tags;
 341   GstTagList *parser_tags;
 342   GstTagMergeMode parser_tags_merge_mode;
 343   gboolean tags_changed;
 344 };
 345 
 346 typedef struct _GstBaseParseSeek
 347 {
 348   GstSegment segment;
 349   gboolean accurate;
 350   gint64 offset;
 351   GstClockTime start_ts;
 352 } GstBaseParseSeek;
 353 
 354 #define DEFAULT_DISABLE_PASSTHROUGH        FALSE
 355 
 356 enum
 357 {
 358   PROP_0,
 359   PROP_DISABLE_PASSTHROUGH,
 360   PROP_LAST
 361 };
 362 
 363 #define GST_BASE_PARSE_INDEX_LOCK(parse) \
 364   g_mutex_lock (&amp;parse-&gt;priv-&gt;index_lock);
 365 #define GST_BASE_PARSE_INDEX_UNLOCK(parse) \
 366   g_mutex_unlock (&amp;parse-&gt;priv-&gt;index_lock);
 367 
 368 static GstElementClass *parent_class = NULL;
 369 
 370 static void gst_base_parse_class_init (GstBaseParseClass * klass);
 371 static void gst_base_parse_init (GstBaseParse * parse,
 372     GstBaseParseClass * klass);
 373 
 374 GType
 375 gst_base_parse_get_type (void)
 376 {
 377   static volatile gsize base_parse_type = 0;
 378 
 379   if (g_once_init_enter (&amp;base_parse_type)) {
 380     static const GTypeInfo base_parse_info = {
 381       sizeof (GstBaseParseClass),
 382       (GBaseInitFunc) NULL,
 383       (GBaseFinalizeFunc) NULL,
 384       (GClassInitFunc) gst_base_parse_class_init,
 385       NULL,
 386       NULL,
 387       sizeof (GstBaseParse),
 388       0,
 389       (GInstanceInitFunc) gst_base_parse_init,
 390     };
 391     GType _type;
 392 
 393     _type = g_type_register_static (GST_TYPE_ELEMENT,
 394         &quot;GstBaseParse&quot;, &amp;base_parse_info, G_TYPE_FLAG_ABSTRACT);
 395     g_once_init_leave (&amp;base_parse_type, _type);
 396   }
 397   return (GType) base_parse_type;
 398 }
 399 
 400 static void gst_base_parse_finalize (GObject * object);
 401 
 402 static GstStateChangeReturn gst_base_parse_change_state (GstElement * element,
 403     GstStateChange transition);
 404 static void gst_base_parse_reset (GstBaseParse * parse);
 405 
 406 #if 0
 407 static void gst_base_parse_set_index (GstElement * element, GstIndex * index);
 408 static GstIndex *gst_base_parse_get_index (GstElement * element);
 409 #endif
 410 
 411 static gboolean gst_base_parse_sink_activate (GstPad * sinkpad,
 412     GstObject * parent);
 413 static gboolean gst_base_parse_sink_activate_mode (GstPad * pad,
 414     GstObject * parent, GstPadMode mode, gboolean active);
 415 static gboolean gst_base_parse_handle_seek (GstBaseParse * parse,
 416     GstEvent * event);
 417 static void gst_base_parse_set_upstream_tags (GstBaseParse * parse,
 418     GstTagList * taglist);
 419 
 420 static void gst_base_parse_set_property (GObject * object, guint prop_id,
 421     const GValue * value, GParamSpec * pspec);
 422 static void gst_base_parse_get_property (GObject * object, guint prop_id,
 423     GValue * value, GParamSpec * pspec);
 424 
 425 static gboolean gst_base_parse_src_event (GstPad * pad, GstObject * parent,
 426     GstEvent * event);
 427 static gboolean gst_base_parse_src_query (GstPad * pad, GstObject * parent,
 428     GstQuery * query);
 429 
 430 static gboolean gst_base_parse_sink_event (GstPad * pad, GstObject * parent,
 431     GstEvent * event);
 432 static gboolean gst_base_parse_sink_query (GstPad * pad, GstObject * parent,
 433     GstQuery * query);
 434 
 435 static GstFlowReturn gst_base_parse_chain (GstPad * pad, GstObject * parent,
 436     GstBuffer * buffer);
 437 static void gst_base_parse_loop (GstPad * pad);
 438 
 439 static GstFlowReturn gst_base_parse_parse_frame (GstBaseParse * parse,
 440     GstBaseParseFrame * frame);
 441 
 442 static gboolean gst_base_parse_sink_event_default (GstBaseParse * parse,
 443     GstEvent * event);
 444 
 445 static gboolean gst_base_parse_src_event_default (GstBaseParse * parse,
 446     GstEvent * event);
 447 
 448 static gboolean gst_base_parse_sink_query_default (GstBaseParse * parse,
 449     GstQuery * query);
 450 static gboolean gst_base_parse_src_query_default (GstBaseParse * parse,
 451     GstQuery * query);
 452 
 453 static gint64 gst_base_parse_find_offset (GstBaseParse * parse,
 454     GstClockTime time, gboolean before, GstClockTime * _ts);
 455 static GstFlowReturn gst_base_parse_locate_time (GstBaseParse * parse,
 456     GstClockTime * _time, gint64 * _offset);
 457 
 458 static GstFlowReturn gst_base_parse_start_fragment (GstBaseParse * parse);
 459 static GstFlowReturn gst_base_parse_finish_fragment (GstBaseParse * parse,
 460     gboolean prev_head);
 461 static GstFlowReturn gst_base_parse_send_buffers (GstBaseParse * parse);
 462 
 463 static inline GstFlowReturn gst_base_parse_check_sync (GstBaseParse * parse);
 464 
 465 static gboolean gst_base_parse_is_seekable (GstBaseParse * parse);
 466 
 467 static void gst_base_parse_push_pending_events (GstBaseParse * parse);
 468 
 469 static void
 470 gst_base_parse_clear_queues (GstBaseParse * parse)
 471 {
 472   g_slist_foreach (parse-&gt;priv-&gt;buffers_queued, (GFunc) gst_buffer_unref, NULL);
 473   g_slist_free (parse-&gt;priv-&gt;buffers_queued);
 474   parse-&gt;priv-&gt;buffers_queued = NULL;
 475   g_slist_foreach (parse-&gt;priv-&gt;buffers_pending, (GFunc) gst_buffer_unref,
 476       NULL);
 477   g_slist_free (parse-&gt;priv-&gt;buffers_pending);
 478   parse-&gt;priv-&gt;buffers_pending = NULL;
 479   g_slist_foreach (parse-&gt;priv-&gt;buffers_head, (GFunc) gst_buffer_unref, NULL);
 480   g_slist_free (parse-&gt;priv-&gt;buffers_head);
 481   parse-&gt;priv-&gt;buffers_head = NULL;
 482   g_slist_foreach (parse-&gt;priv-&gt;buffers_send, (GFunc) gst_buffer_unref, NULL);
 483   g_slist_free (parse-&gt;priv-&gt;buffers_send);
 484   parse-&gt;priv-&gt;buffers_send = NULL;
 485 
 486   g_list_foreach (parse-&gt;priv-&gt;detect_buffers, (GFunc) gst_buffer_unref, NULL);
 487   g_list_free (parse-&gt;priv-&gt;detect_buffers);
 488   parse-&gt;priv-&gt;detect_buffers = NULL;
 489   parse-&gt;priv-&gt;detect_buffers_size = 0;
 490 
 491   g_queue_foreach (&amp;parse-&gt;priv-&gt;queued_frames,
 492       (GFunc) gst_base_parse_frame_free, NULL);
 493   g_queue_clear (&amp;parse-&gt;priv-&gt;queued_frames);
 494 
 495   gst_buffer_replace (&amp;parse-&gt;priv-&gt;cache, NULL);
 496 
 497   g_list_foreach (parse-&gt;priv-&gt;pending_events, (GFunc) gst_event_unref, NULL);
 498   g_list_free (parse-&gt;priv-&gt;pending_events);
 499   parse-&gt;priv-&gt;pending_events = NULL;
 500 
 501   parse-&gt;priv-&gt;checked_media = FALSE;
 502 }
 503 
 504 static void
 505 gst_base_parse_finalize (GObject * object)
 506 {
 507   GstBaseParse *parse = GST_BASE_PARSE (object);
 508 
 509   g_object_unref (parse-&gt;priv-&gt;adapter);
 510 
 511   if (parse-&gt;priv-&gt;index) {
 512     gst_object_unref (parse-&gt;priv-&gt;index);
 513     parse-&gt;priv-&gt;index = NULL;
 514   }
 515   g_mutex_clear (&amp;parse-&gt;priv-&gt;index_lock);
 516 
 517   gst_base_parse_clear_queues (parse);
 518 
 519   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 520 }
 521 
 522 static void
 523 gst_base_parse_class_init (GstBaseParseClass * klass)
 524 {
 525   GObjectClass *gobject_class;
 526   GstElementClass *gstelement_class;
 527 
 528   gobject_class = G_OBJECT_CLASS (klass);
 529   g_type_class_add_private (klass, sizeof (GstBaseParsePrivate));
 530   parent_class = g_type_class_peek_parent (klass);
 531 
 532   gobject_class-&gt;finalize = GST_DEBUG_FUNCPTR (gst_base_parse_finalize);
 533   gobject_class-&gt;set_property = GST_DEBUG_FUNCPTR (gst_base_parse_set_property);
 534   gobject_class-&gt;get_property = GST_DEBUG_FUNCPTR (gst_base_parse_get_property);
 535 
 536   /**
 537    * GstBaseParse:disable-passthrough:
 538    *
 539    * If set to %TRUE, baseparse will unconditionally force parsing of the
 540    * incoming data. This can be required in the rare cases where the incoming
 541    * side-data (caps, pts, dts, ...) is not trusted by the user and wants to
 542    * force validation and parsing of the incoming data.
 543    * If set to %FALSE, decision of whether to parse the data or not is up to
 544    * the implementation (standard behaviour).
 545    */
 546   g_object_class_install_property (gobject_class, PROP_DISABLE_PASSTHROUGH,
 547       g_param_spec_boolean (&quot;disable-passthrough&quot;, &quot;Disable passthrough&quot;,
 548           &quot;Force processing (disables passthrough)&quot;,
 549           DEFAULT_DISABLE_PASSTHROUGH,
 550           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 551 
 552   gstelement_class = (GstElementClass *) klass;
 553   gstelement_class-&gt;change_state =
 554       GST_DEBUG_FUNCPTR (gst_base_parse_change_state);
 555 
 556 #if 0
 557   gstelement_class-&gt;set_index = GST_DEBUG_FUNCPTR (gst_base_parse_set_index);
 558   gstelement_class-&gt;get_index = GST_DEBUG_FUNCPTR (gst_base_parse_get_index);
 559 #endif
 560 
 561   /* Default handlers */
 562   klass-&gt;sink_event = gst_base_parse_sink_event_default;
 563   klass-&gt;src_event = gst_base_parse_src_event_default;
 564   klass-&gt;sink_query = gst_base_parse_sink_query_default;
 565   klass-&gt;src_query = gst_base_parse_src_query_default;
 566   klass-&gt;convert = gst_base_parse_convert_default;
 567 
 568   GST_DEBUG_CATEGORY_INIT (gst_base_parse_debug, &quot;baseparse&quot;, 0,
 569       &quot;baseparse element&quot;);
 570 }
 571 
 572 static void
 573 gst_base_parse_init (GstBaseParse * parse, GstBaseParseClass * bclass)
 574 {
 575   GstPadTemplate *pad_template;
 576 
 577   GST_DEBUG_OBJECT (parse, &quot;gst_base_parse_init&quot;);
 578 
 579   parse-&gt;priv = GST_BASE_PARSE_GET_PRIVATE (parse);
 580 
 581   pad_template =
 582       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;sink&quot;);
 583   g_return_if_fail (pad_template != NULL);
 584   parse-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 585   gst_pad_set_event_function (parse-&gt;sinkpad,
 586       GST_DEBUG_FUNCPTR (gst_base_parse_sink_event));
 587   gst_pad_set_query_function (parse-&gt;sinkpad,
 588       GST_DEBUG_FUNCPTR (gst_base_parse_sink_query));
 589   gst_pad_set_chain_function (parse-&gt;sinkpad,
 590       GST_DEBUG_FUNCPTR (gst_base_parse_chain));
 591   gst_pad_set_activate_function (parse-&gt;sinkpad,
 592       GST_DEBUG_FUNCPTR (gst_base_parse_sink_activate));
 593   gst_pad_set_activatemode_function (parse-&gt;sinkpad,
 594       GST_DEBUG_FUNCPTR (gst_base_parse_sink_activate_mode));
 595   GST_PAD_SET_PROXY_ALLOCATION (parse-&gt;sinkpad);
 596   gst_element_add_pad (GST_ELEMENT (parse), parse-&gt;sinkpad);
 597 
 598   GST_DEBUG_OBJECT (parse, &quot;sinkpad created&quot;);
 599 
 600   pad_template =
 601       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;src&quot;);
 602   g_return_if_fail (pad_template != NULL);
 603   parse-&gt;srcpad = gst_pad_new_from_template (pad_template, &quot;src&quot;);
 604   gst_pad_set_event_function (parse-&gt;srcpad,
 605       GST_DEBUG_FUNCPTR (gst_base_parse_src_event));
 606   gst_pad_set_query_function (parse-&gt;srcpad,
 607       GST_DEBUG_FUNCPTR (gst_base_parse_src_query));
 608   gst_pad_use_fixed_caps (parse-&gt;srcpad);
 609   gst_element_add_pad (GST_ELEMENT (parse), parse-&gt;srcpad);
 610   GST_DEBUG_OBJECT (parse, &quot;src created&quot;);
 611 
 612   g_queue_init (&amp;parse-&gt;priv-&gt;queued_frames);
 613 
 614   parse-&gt;priv-&gt;adapter = gst_adapter_new ();
 615 
 616   parse-&gt;priv-&gt;pad_mode = GST_PAD_MODE_NONE;
 617 
 618   g_mutex_init (&amp;parse-&gt;priv-&gt;index_lock);
 619 
 620   /* init state */
 621   gst_base_parse_reset (parse);
 622   GST_DEBUG_OBJECT (parse, &quot;init ok&quot;);
 623 
 624   GST_OBJECT_FLAG_SET (parse, GST_ELEMENT_FLAG_INDEXABLE);
 625 
 626   parse-&gt;priv-&gt;upstream_tags = NULL;
 627   parse-&gt;priv-&gt;parser_tags = NULL;
 628   parse-&gt;priv-&gt;parser_tags_merge_mode = GST_TAG_MERGE_APPEND;
 629 }
 630 
 631 static void
 632 gst_base_parse_set_property (GObject * object, guint prop_id,
 633     const GValue * value, GParamSpec * pspec)
 634 {
 635   GstBaseParse *parse = GST_BASE_PARSE (object);
 636 
 637   switch (prop_id) {
 638     case PROP_DISABLE_PASSTHROUGH:
 639       parse-&gt;priv-&gt;disable_passthrough = g_value_get_boolean (value);
 640       break;
 641     default:
 642       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 643       break;
 644   }
 645 }
 646 
 647 static void
 648 gst_base_parse_get_property (GObject * object, guint prop_id, GValue * value,
 649     GParamSpec * pspec)
 650 {
 651   GstBaseParse *parse = GST_BASE_PARSE (object);
 652 
 653   switch (prop_id) {
 654     case PROP_DISABLE_PASSTHROUGH:
 655       g_value_set_boolean (value, parse-&gt;priv-&gt;disable_passthrough);
 656       break;
 657     default:
 658       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 659       break;
 660   }
 661 }
 662 
 663 GstBaseParseFrame *
 664 gst_base_parse_frame_copy (GstBaseParseFrame * frame)
 665 {
 666   GstBaseParseFrame *copy;
 667 
 668   copy = g_slice_dup (GstBaseParseFrame, frame);
 669   copy-&gt;buffer = gst_buffer_ref (frame-&gt;buffer);
 670   copy-&gt;_private_flags &amp;= ~GST_BASE_PARSE_FRAME_PRIVATE_FLAG_NOALLOC;
 671 
 672   GST_TRACE (&quot;copied frame %p -&gt; %p&quot;, frame, copy);
 673 
 674   return copy;
 675 }
 676 
 677 void
 678 gst_base_parse_frame_free (GstBaseParseFrame * frame)
 679 {
 680   GST_TRACE (&quot;freeing frame %p&quot;, frame);
 681 
 682   if (frame-&gt;buffer) {
 683     gst_buffer_unref (frame-&gt;buffer);
 684     frame-&gt;buffer = NULL;
 685   }
 686 
 687   if (!(frame-&gt;_private_flags &amp; GST_BASE_PARSE_FRAME_PRIVATE_FLAG_NOALLOC)) {
 688     g_slice_free (GstBaseParseFrame, frame);
 689   } else {
 690     memset (frame, 0, sizeof (*frame));
 691   }
 692 }
 693 
 694 G_DEFINE_BOXED_TYPE (GstBaseParseFrame, gst_base_parse_frame,
 695         (GBoxedCopyFunc) gst_base_parse_frame_copy,
 696         (GBoxedFreeFunc) gst_base_parse_frame_free);
 697 
 698 /**
 699  * gst_base_parse_frame_init:
 700  * @frame: #GstBaseParseFrame.
 701  *
 702  * Sets a #GstBaseParseFrame to initial state.  Currently this means
 703  * all public fields are zero-ed and a private flag is set to make
 704  * sure gst_base_parse_frame_free() only frees the contents but not
 705  * the actual frame. Use this function to initialise a #GstBaseParseFrame
 706  * allocated on the stack.
 707  */
 708 void
 709 gst_base_parse_frame_init (GstBaseParseFrame * frame)
 710 {
 711   memset (frame, 0, sizeof (GstBaseParseFrame));
 712   frame-&gt;_private_flags = GST_BASE_PARSE_FRAME_PRIVATE_FLAG_NOALLOC;
 713   GST_TRACE (&quot;inited frame %p&quot;, frame);
 714 }
 715 
 716 /**
 717  * gst_base_parse_frame_new:
 718  * @buffer: (transfer none): a #GstBuffer
 719  * @flags: the flags
 720  * @overhead: number of bytes in this frame which should be counted as
 721  *     metadata overhead, ie. not used to calculate the average bitrate.
 722  *     Set to -1 to mark the entire frame as metadata. If in doubt, set to 0.
 723  *
 724  * Allocates a new #GstBaseParseFrame. This function is mainly for bindings,
 725  * elements written in C should usually allocate the frame on the stack and
 726  * then use gst_base_parse_frame_init() to initialise it.
 727  *
 728  * Returns: a newly-allocated #GstBaseParseFrame. Free with
 729  *     gst_base_parse_frame_free() when no longer needed.
 730  */
 731 GstBaseParseFrame *
 732 gst_base_parse_frame_new (GstBuffer * buffer, GstBaseParseFrameFlags flags,
 733     gint overhead)
 734 {
 735   GstBaseParseFrame *frame;
 736 
 737   frame = g_slice_new0 (GstBaseParseFrame);
 738   frame-&gt;buffer = gst_buffer_ref (buffer);
 739 
 740   GST_TRACE (&quot;created frame %p&quot;, frame);
 741   return frame;
 742 }
 743 
 744 static inline void
 745 gst_base_parse_update_flags (GstBaseParse * parse)
 746 {
 747   parse-&gt;flags = 0;
 748 
 749   /* set flags one by one for clarity */
 750   if (G_UNLIKELY (parse-&gt;priv-&gt;drain))
 751     parse-&gt;flags |= GST_BASE_PARSE_FLAG_DRAINING;
 752 
 753   /* losing sync is pretty much a discont (and vice versa), no ? */
 754   if (G_UNLIKELY (parse-&gt;priv-&gt;discont))
 755     parse-&gt;flags |= GST_BASE_PARSE_FLAG_LOST_SYNC;
 756 }
 757 
 758 static inline void
 759 gst_base_parse_update_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
 760 {
 761   if (G_UNLIKELY (parse-&gt;priv-&gt;discont)) {
 762     GST_DEBUG_OBJECT (parse, &quot;marking DISCONT&quot;);
 763     GST_BUFFER_FLAG_SET (frame-&gt;buffer, GST_BUFFER_FLAG_DISCONT);
 764   } else {
 765     GST_BUFFER_FLAG_UNSET (frame-&gt;buffer, GST_BUFFER_FLAG_DISCONT);
 766   }
 767 
 768   if (parse-&gt;priv-&gt;prev_offset != parse-&gt;priv-&gt;offset || parse-&gt;priv-&gt;new_frame) {
 769     GST_LOG_OBJECT (parse, &quot;marking as new frame&quot;);
 770     frame-&gt;flags |= GST_BASE_PARSE_FRAME_FLAG_NEW_FRAME;
 771   }
 772 
 773   frame-&gt;offset = parse-&gt;priv-&gt;prev_offset = parse-&gt;priv-&gt;offset;
 774 }
 775 
 776 static void
 777 gst_base_parse_reset (GstBaseParse * parse)
 778 {
 779   GST_OBJECT_LOCK (parse);
 780   gst_segment_init (&amp;parse-&gt;segment, GST_FORMAT_TIME);
 781   parse-&gt;priv-&gt;duration = -1;
 782   parse-&gt;priv-&gt;min_frame_size = 1;
 783   parse-&gt;priv-&gt;discont = TRUE;
 784   parse-&gt;priv-&gt;flushing = FALSE;
 785   parse-&gt;priv-&gt;saw_gaps = FALSE;
 786   parse-&gt;priv-&gt;offset = 0;
 787   parse-&gt;priv-&gt;sync_offset = 0;
 788   parse-&gt;priv-&gt;update_interval = -1;
 789   parse-&gt;priv-&gt;fps_num = parse-&gt;priv-&gt;fps_den = 0;
 790   parse-&gt;priv-&gt;frame_duration = GST_CLOCK_TIME_NONE;
 791   parse-&gt;priv-&gt;lead_in = parse-&gt;priv-&gt;lead_out = 0;
 792   parse-&gt;priv-&gt;lead_in_ts = parse-&gt;priv-&gt;lead_out_ts = 0;
 793   parse-&gt;priv-&gt;bitrate = 0;
 794   parse-&gt;priv-&gt;framecount = 0;
 795   parse-&gt;priv-&gt;bytecount = 0;
 796   parse-&gt;priv-&gt;acc_duration = 0;
 797   parse-&gt;priv-&gt;first_frame_pts = GST_CLOCK_TIME_NONE;
 798   parse-&gt;priv-&gt;first_frame_dts = GST_CLOCK_TIME_NONE;
 799   parse-&gt;priv-&gt;first_frame_offset = -1;
 800   parse-&gt;priv-&gt;estimated_duration = -1;
 801   parse-&gt;priv-&gt;estimated_drift = 0;
 802   parse-&gt;priv-&gt;next_pts = GST_CLOCK_TIME_NONE;
 803   parse-&gt;priv-&gt;next_dts = 0;
 804   parse-&gt;priv-&gt;syncable = TRUE;
 805   parse-&gt;priv-&gt;disable_passthrough = DEFAULT_DISABLE_PASSTHROUGH;
 806   parse-&gt;priv-&gt;passthrough = FALSE;
 807   parse-&gt;priv-&gt;pts_interpolate = TRUE;
 808   parse-&gt;priv-&gt;infer_ts = TRUE;
 809   parse-&gt;priv-&gt;has_timing_info = FALSE;
 810   parse-&gt;priv-&gt;min_bitrate = G_MAXUINT;
 811   parse-&gt;priv-&gt;max_bitrate = 0;
 812   parse-&gt;priv-&gt;avg_bitrate = 0;
 813   parse-&gt;priv-&gt;posted_avg_bitrate = 0;
 814 
 815   parse-&gt;priv-&gt;index_last_ts = GST_CLOCK_TIME_NONE;
 816   parse-&gt;priv-&gt;index_last_offset = -1;
 817   parse-&gt;priv-&gt;index_last_valid = TRUE;
 818   parse-&gt;priv-&gt;upstream_seekable = FALSE;
 819   parse-&gt;priv-&gt;upstream_size = 0;
 820   parse-&gt;priv-&gt;upstream_has_duration = FALSE;
 821   parse-&gt;priv-&gt;upstream_format = GST_FORMAT_UNDEFINED;
 822   parse-&gt;priv-&gt;idx_interval = 0;
 823   parse-&gt;priv-&gt;idx_byte_interval = 0;
 824   parse-&gt;priv-&gt;exact_position = TRUE;
 825   parse-&gt;priv-&gt;seen_keyframe = FALSE;
 826   parse-&gt;priv-&gt;checked_media = FALSE;
 827 
 828   parse-&gt;priv-&gt;last_dts = GST_CLOCK_TIME_NONE;
 829   parse-&gt;priv-&gt;last_pts = GST_CLOCK_TIME_NONE;
 830   parse-&gt;priv-&gt;last_offset = 0;
 831 
 832   parse-&gt;priv-&gt;skip = 0;
 833 
 834   g_list_foreach (parse-&gt;priv-&gt;pending_events, (GFunc) gst_mini_object_unref,
 835       NULL);
 836   g_list_free (parse-&gt;priv-&gt;pending_events);
 837   parse-&gt;priv-&gt;pending_events = NULL;
 838 
 839   if (parse-&gt;priv-&gt;cache) {
 840     gst_buffer_unref (parse-&gt;priv-&gt;cache);
 841     parse-&gt;priv-&gt;cache = NULL;
 842   }
 843 
 844   g_slist_foreach (parse-&gt;priv-&gt;pending_seeks, (GFunc) g_free, NULL);
 845   g_slist_free (parse-&gt;priv-&gt;pending_seeks);
 846   parse-&gt;priv-&gt;pending_seeks = NULL;
 847 
 848   if (parse-&gt;priv-&gt;adapter)
 849     gst_adapter_clear (parse-&gt;priv-&gt;adapter);
 850 
 851   gst_base_parse_set_upstream_tags (parse, NULL);
 852 
 853   if (parse-&gt;priv-&gt;parser_tags) {
 854     gst_tag_list_unref (parse-&gt;priv-&gt;parser_tags);
 855     parse-&gt;priv-&gt;parser_tags = NULL;
 856   }
 857   parse-&gt;priv-&gt;parser_tags_merge_mode = GST_TAG_MERGE_APPEND;
 858 
 859   parse-&gt;priv-&gt;new_frame = TRUE;
 860 
 861   parse-&gt;priv-&gt;first_buffer = TRUE;
 862 
 863   g_list_foreach (parse-&gt;priv-&gt;detect_buffers, (GFunc) gst_buffer_unref, NULL);
 864   g_list_free (parse-&gt;priv-&gt;detect_buffers);
 865   parse-&gt;priv-&gt;detect_buffers = NULL;
 866   parse-&gt;priv-&gt;detect_buffers_size = 0;
 867   GST_OBJECT_UNLOCK (parse);
 868 }
 869 
 870 static gboolean
 871 gst_base_parse_check_bitrate_tag (GstBaseParse * parse, const gchar * tag)
 872 {
 873   gboolean got_tag = FALSE;
 874   guint n = 0;
 875 
 876   if (parse-&gt;priv-&gt;upstream_tags != NULL)
 877     got_tag = gst_tag_list_get_uint (parse-&gt;priv-&gt;upstream_tags, tag, &amp;n);
 878 
 879   if (!got_tag &amp;&amp; parse-&gt;priv-&gt;parser_tags != NULL)
 880     got_tag = gst_tag_list_get_uint (parse-&gt;priv-&gt;parser_tags, tag, &amp;n);
 881 
 882   return got_tag;
 883 }
 884 
 885 /* check if upstream or subclass tags contain bitrates already */
 886 static void
 887 gst_base_parse_check_bitrate_tags (GstBaseParse * parse)
 888 {
 889   parse-&gt;priv-&gt;post_min_bitrate =
 890       !gst_base_parse_check_bitrate_tag (parse, GST_TAG_MINIMUM_BITRATE);
 891   parse-&gt;priv-&gt;post_avg_bitrate =
 892       !gst_base_parse_check_bitrate_tag (parse, GST_TAG_BITRATE);
 893   parse-&gt;priv-&gt;post_max_bitrate =
 894       !gst_base_parse_check_bitrate_tag (parse, GST_TAG_MAXIMUM_BITRATE);
 895 }
 896 
 897 /* Queues new tag event with the current combined state of the stream tags
 898  * (i.e. upstream tags merged with subclass tags and current baseparse tags) */
 899 static void
 900 gst_base_parse_queue_tag_event_update (GstBaseParse * parse)
 901 {
 902   GstTagList *merged_tags;
 903 
 904   GST_LOG_OBJECT (parse, &quot;upstream : %&quot; GST_PTR_FORMAT,
 905       parse-&gt;priv-&gt;upstream_tags);
 906   GST_LOG_OBJECT (parse, &quot;parser   : %&quot; GST_PTR_FORMAT,
 907       parse-&gt;priv-&gt;parser_tags);
 908   GST_LOG_OBJECT (parse, &quot;mode     : %d&quot;, parse-&gt;priv-&gt;parser_tags_merge_mode);
 909 
 910   merged_tags =
 911       gst_tag_list_merge (parse-&gt;priv-&gt;upstream_tags, parse-&gt;priv-&gt;parser_tags,
 912       parse-&gt;priv-&gt;parser_tags_merge_mode);
 913 
 914   GST_DEBUG_OBJECT (parse, &quot;merged   : %&quot; GST_PTR_FORMAT, merged_tags);
 915 
 916   if (merged_tags == NULL)
 917     return;
 918 
 919   if (gst_tag_list_is_empty (merged_tags)) {
 920     gst_tag_list_unref (merged_tags);
 921     return;
 922   }
 923 
 924   if (parse-&gt;priv-&gt;framecount &gt;= MIN_FRAMES_TO_POST_BITRATE) {
 925     /* only add bitrate tags to non-empty taglists for now, and only if neither
 926      * upstream tags nor the subclass sets the bitrate tag in question already */
 927     if (parse-&gt;priv-&gt;min_bitrate != G_MAXUINT &amp;&amp; parse-&gt;priv-&gt;post_min_bitrate) {
 928       GST_LOG_OBJECT (parse, &quot;adding min bitrate %u&quot;, parse-&gt;priv-&gt;min_bitrate);
 929       gst_tag_list_add (merged_tags, GST_TAG_MERGE_KEEP,
 930           GST_TAG_MINIMUM_BITRATE, parse-&gt;priv-&gt;min_bitrate, NULL);
 931     }
 932     if (parse-&gt;priv-&gt;max_bitrate != 0 &amp;&amp; parse-&gt;priv-&gt;post_max_bitrate) {
 933       GST_LOG_OBJECT (parse, &quot;adding max bitrate %u&quot;, parse-&gt;priv-&gt;max_bitrate);
 934       gst_tag_list_add (merged_tags, GST_TAG_MERGE_KEEP,
 935           GST_TAG_MAXIMUM_BITRATE, parse-&gt;priv-&gt;max_bitrate, NULL);
 936     }
 937     if (parse-&gt;priv-&gt;avg_bitrate != 0 &amp;&amp; parse-&gt;priv-&gt;post_avg_bitrate) {
 938       parse-&gt;priv-&gt;posted_avg_bitrate = parse-&gt;priv-&gt;avg_bitrate;
 939       GST_LOG_OBJECT (parse, &quot;adding avg bitrate %u&quot;, parse-&gt;priv-&gt;avg_bitrate);
 940       gst_tag_list_add (merged_tags, GST_TAG_MERGE_KEEP,
 941           GST_TAG_BITRATE, parse-&gt;priv-&gt;avg_bitrate, NULL);
 942     }
 943   }
 944 
 945   parse-&gt;priv-&gt;pending_events =
 946       g_list_prepend (parse-&gt;priv-&gt;pending_events,
 947       gst_event_new_tag (merged_tags));
 948 }
 949 
 950 /* gst_base_parse_parse_frame:
 951  * @parse: #GstBaseParse.
 952  * @buffer: #GstBuffer.
 953  *
 954  * Default callback for parse_frame.
 955  */
 956 static GstFlowReturn
 957 gst_base_parse_parse_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
 958 {
 959   GstBuffer *buffer = frame-&gt;buffer;
 960 
 961   if (!GST_BUFFER_PTS_IS_VALID (buffer) &amp;&amp;
 962       GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;next_pts)) {
 963     GST_BUFFER_PTS (buffer) = parse-&gt;priv-&gt;next_pts;
 964   }
 965   if (!GST_BUFFER_DTS_IS_VALID (buffer) &amp;&amp;
 966       GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;next_dts)) {
 967     GST_BUFFER_DTS (buffer) = parse-&gt;priv-&gt;next_dts;
 968   }
 969   if (!GST_BUFFER_DURATION_IS_VALID (buffer) &amp;&amp;
 970       GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;frame_duration)) {
 971     GST_BUFFER_DURATION (buffer) = parse-&gt;priv-&gt;frame_duration;
 972   }
 973   return GST_FLOW_OK;
 974 }
 975 
 976 /* gst_base_parse_convert:
 977  * @parse: #GstBaseParse.
 978  * @src_format: #GstFormat describing the source format.
 979  * @src_value: Source value to be converted.
 980  * @dest_format: #GstFormat defining the converted format.
 981  * @dest_value: Pointer where the conversion result will be put.
 982  *
 983  * Converts using configured &quot;convert&quot; vmethod in #GstBaseParse class.
 984  *
 985  * Returns: %TRUE if conversion was successful.
 986  */
 987 static gboolean
 988 gst_base_parse_convert (GstBaseParse * parse,
 989     GstFormat src_format,
 990     gint64 src_value, GstFormat dest_format, gint64 * dest_value)
 991 {
 992   GstBaseParseClass *klass = GST_BASE_PARSE_GET_CLASS (parse);
 993   gboolean ret;
 994 
 995   g_return_val_if_fail (dest_value != NULL, FALSE);
 996 
 997   if (!klass-&gt;convert)
 998     return FALSE;
 999 
1000   ret = klass-&gt;convert (parse, src_format, src_value, dest_format, dest_value);
1001 
1002 #ifndef GST_DISABLE_GST_DEBUG
1003   {
1004     if (ret) {
1005       if (src_format == GST_FORMAT_TIME &amp;&amp; dest_format == GST_FORMAT_BYTES) {
1006         GST_LOG_OBJECT (parse,
1007             &quot;TIME -&gt; BYTES: %&quot; GST_TIME_FORMAT &quot; -&gt; %&quot; G_GINT64_FORMAT,
1008             GST_TIME_ARGS (src_value), *dest_value);
1009       } else if (dest_format == GST_FORMAT_TIME &amp;&amp;
1010           src_format == GST_FORMAT_BYTES) {
1011         GST_LOG_OBJECT (parse,
1012             &quot;BYTES -&gt; TIME: %&quot; G_GINT64_FORMAT &quot; -&gt; %&quot; GST_TIME_FORMAT,
1013             src_value, GST_TIME_ARGS (*dest_value));
1014       } else {
1015         GST_LOG_OBJECT (parse,
1016             &quot;%s -&gt; %s: %&quot; G_GINT64_FORMAT &quot; -&gt; %&quot; G_GINT64_FORMAT,
1017             GST_STR_NULL (gst_format_get_name (src_format)),
1018             GST_STR_NULL (gst_format_get_name (dest_format)),
1019             src_value, *dest_value);
1020       }
1021     } else {
1022       GST_DEBUG_OBJECT (parse, &quot;conversion failed&quot;);
1023     }
1024   }
1025 #endif
1026 
1027   return ret;
1028 }
1029 
1030 static gboolean
1031 update_upstream_provided (GQuark field_id, const GValue * value,
1032     gpointer user_data)
1033 {
1034   GstCaps *default_caps = user_data;
1035   gint i;
1036   gint caps_size;
1037 
1038   caps_size = gst_caps_get_size (default_caps);
1039   for (i = 0; i &lt; caps_size; i++) {
1040     GstStructure *structure = gst_caps_get_structure (default_caps, i);
1041     if (gst_structure_id_has_field (structure, field_id))
1042       gst_structure_id_set_value (structure, field_id, value);
1043   }
1044 
1045   return TRUE;
1046 }
1047 
1048 static GstCaps *
1049 gst_base_parse_negotiate_default_caps (GstBaseParse * parse)
1050 {
1051   GstCaps *caps, *templcaps;
1052   GstCaps *sinkcaps = NULL;
1053   GstCaps *default_caps = NULL;
1054   GstStructure *structure;
1055 
1056   templcaps = gst_pad_get_pad_template_caps (GST_BASE_PARSE_SRC_PAD (parse));
1057   caps = gst_pad_peer_query_caps (GST_BASE_PARSE_SRC_PAD (parse), templcaps);
1058   if (caps)
1059     gst_caps_unref (templcaps);
1060   else
1061     caps = templcaps;
1062   templcaps = NULL;
1063 
1064   if (!caps || gst_caps_is_empty (caps) || gst_caps_is_any (caps)) {
1065     goto caps_error;
1066   }
1067 
1068   GST_LOG_OBJECT (parse, &quot;peer caps  %&quot; GST_PTR_FORMAT, caps);
1069 
1070   /* before fixating, try to use whatever upstream provided */
1071   default_caps = gst_caps_copy (caps);
1072   sinkcaps = gst_pad_get_current_caps (GST_BASE_PARSE_SINK_PAD (parse));
1073 
1074   GST_LOG_OBJECT (parse, &quot;current caps %&quot; GST_PTR_FORMAT &quot; for sinkpad&quot;,
1075       sinkcaps);
1076 
1077   if (sinkcaps) {
1078     structure = gst_caps_get_structure (sinkcaps, 0);
1079     gst_structure_foreach (structure, update_upstream_provided, default_caps);
1080   }
1081 
1082   default_caps = gst_caps_fixate (default_caps);
1083 
1084   if (!default_caps) {
1085     GST_WARNING_OBJECT (parse, &quot;Failed to create default caps !&quot;);
1086     goto caps_error;
1087   }
1088 
1089   GST_INFO_OBJECT (parse,
1090       &quot;Chose default caps %&quot; GST_PTR_FORMAT &quot; for initial gap&quot;, default_caps);
1091 
1092   if (sinkcaps)
1093     gst_caps_unref (sinkcaps);
1094   gst_caps_unref (caps);
1095 
1096   return default_caps;
1097 
1098 caps_error:
1099   {
1100     if (caps)
1101       gst_caps_unref (caps);
1102     if (sinkcaps)
1103       gst_caps_unref (sinkcaps);
1104     return NULL;
1105   }
1106 }
1107 
1108 /* gst_base_parse_sink_event:
1109  * @pad: #GstPad that received the event.
1110  * @event: #GstEvent to be handled.
1111  *
1112  * Handler for sink pad events.
1113  *
1114  * Returns: %TRUE if the event was handled.
1115  */
1116 static gboolean
1117 gst_base_parse_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
1118 {
1119   GstBaseParse *parse = GST_BASE_PARSE (parent);
1120   GstBaseParseClass *bclass = GST_BASE_PARSE_GET_CLASS (parse);
1121   gboolean ret;
1122 
1123   ret = bclass-&gt;sink_event (parse, event);
1124 
1125   return ret;
1126 }
1127 
1128 /* gst_base_parse_sink_event_default:
1129  * @parse: #GstBaseParse.
1130  * @event: #GstEvent to be handled.
1131  *
1132  * Element-level event handler function.
1133  *
1134  * The event will be unreffed only if it has been handled and this
1135  * function returns %TRUE
1136  *
1137  * Returns: %TRUE if the event was handled and not need forwarding.
1138  */
1139 static gboolean
1140 gst_base_parse_sink_event_default (GstBaseParse * parse, GstEvent * event)
1141 {
1142   GstBaseParseClass *klass = GST_BASE_PARSE_GET_CLASS (parse);
1143   gboolean ret = FALSE;
1144   gboolean forward_immediate = FALSE;
1145 
1146   GST_DEBUG_OBJECT (parse, &quot;handling event %d, %s&quot;, GST_EVENT_TYPE (event),
1147       GST_EVENT_TYPE_NAME (event));
1148 
1149   switch (GST_EVENT_TYPE (event)) {
1150     case GST_EVENT_CAPS:
1151     {
1152       GstCaps *caps;
1153 
1154       gst_event_parse_caps (event, &amp;caps);
1155       GST_DEBUG_OBJECT (parse, &quot;caps: %&quot; GST_PTR_FORMAT, caps);
1156 
1157       if (klass-&gt;set_sink_caps)
1158         ret = klass-&gt;set_sink_caps (parse, caps);
1159       else
1160         ret = TRUE;
1161 
1162       /* will send our own caps downstream */
1163       gst_event_unref (event);
1164       event = NULL;
1165       break;
1166     }
1167     case GST_EVENT_SEGMENT:
1168     {
1169       const GstSegment *in_segment;
1170       GstSegment out_segment;
1171       gint64 offset = 0, next_dts;
1172       guint32 seqnum = gst_event_get_seqnum (event);
1173 
1174       gst_event_parse_segment (event, &amp;in_segment);
1175       gst_segment_init (&amp;out_segment, GST_FORMAT_TIME);
1176       out_segment.rate = in_segment-&gt;rate;
1177       out_segment.applied_rate = in_segment-&gt;applied_rate;
1178 
1179       GST_DEBUG_OBJECT (parse, &quot;segment %&quot; GST_SEGMENT_FORMAT, in_segment);
1180 
1181       parse-&gt;priv-&gt;upstream_format = in_segment-&gt;format;
1182       if (in_segment-&gt;format == GST_FORMAT_BYTES) {
1183         GstBaseParseSeek *seek = NULL;
1184         GSList *node;
1185 
1186         /* stop time is allowed to be open-ended, but not start &amp; pos */
1187         offset = in_segment-&gt;time;
1188 
1189         GST_OBJECT_LOCK (parse);
1190         for (node = parse-&gt;priv-&gt;pending_seeks; node; node = node-&gt;next) {
1191           GstBaseParseSeek *tmp = node-&gt;data;
1192 
1193           if (tmp-&gt;offset == offset) {
1194             seek = tmp;
1195             break;
1196           }
1197         }
1198         parse-&gt;priv-&gt;pending_seeks =
1199             g_slist_remove (parse-&gt;priv-&gt;pending_seeks, seek);
1200         GST_OBJECT_UNLOCK (parse);
1201 
1202         if (seek) {
1203           GST_DEBUG_OBJECT (parse,
1204               &quot;Matched newsegment to%s seek: %&quot; GST_SEGMENT_FORMAT,
1205               seek-&gt;accurate ? &quot; accurate&quot; : &quot;&quot;, &amp;seek-&gt;segment);
1206 
1207           out_segment.start = seek-&gt;segment.start;
1208           out_segment.stop = seek-&gt;segment.stop;
1209           out_segment.time = seek-&gt;segment.start;
1210 
1211           next_dts = seek-&gt;start_ts;
1212           parse-&gt;priv-&gt;exact_position = seek-&gt;accurate;
1213           g_free (seek);
1214         } else {
1215           /* best attempt convert */
1216           /* as these are only estimates, stop is kept open-ended to avoid
1217            * premature cutting */
1218           gst_base_parse_convert (parse, GST_FORMAT_BYTES, in_segment-&gt;start,
1219               GST_FORMAT_TIME, (gint64 *) &amp; next_dts);
1220 
1221           out_segment.start = next_dts;
1222           out_segment.stop = GST_CLOCK_TIME_NONE;
1223           out_segment.time = next_dts;
1224 
1225           parse-&gt;priv-&gt;exact_position = (in_segment-&gt;start == 0);
1226         }
1227 
1228         gst_event_unref (event);
1229 
1230         event = gst_event_new_segment (&amp;out_segment);
1231         gst_event_set_seqnum (event, seqnum);
1232 
1233         GST_DEBUG_OBJECT (parse, &quot;Converted incoming segment to TIME. %&quot;
1234             GST_SEGMENT_FORMAT, in_segment);
1235 
1236       } else if (in_segment-&gt;format != GST_FORMAT_TIME) {
1237         /* Unknown incoming segment format. Output a default open-ended
1238          * TIME segment */
1239         gst_event_unref (event);
1240 
1241         out_segment.start = 0;
1242         out_segment.stop = GST_CLOCK_TIME_NONE;
1243         out_segment.time = 0;
1244 
1245         event = gst_event_new_segment (&amp;out_segment);
1246         gst_event_set_seqnum (event, seqnum);
1247 
1248         next_dts = 0;
1249       } else {
1250         /* not considered BYTE seekable if it is talking to us in TIME,
1251          * whatever else it might claim */
1252         parse-&gt;priv-&gt;upstream_seekable = FALSE;
1253         next_dts = in_segment-&gt;start;
1254         gst_event_copy_segment (event, &amp;out_segment);
1255       }
1256 
1257       memcpy (&amp;parse-&gt;segment, &amp;out_segment, sizeof (GstSegment));
1258 
1259       /*
1260          gst_segment_set_newsegment (&amp;parse-&gt;segment, update, rate,
1261           applied_rate, format, start, stop, start);
1262        */
1263 
1264       ret = TRUE;
1265 
1266       /* save the segment for later, right before we push a new buffer so that
1267        * the caps are fixed and the next linked element can receive
1268        * the segment but finish the current segment */
1269       GST_DEBUG_OBJECT (parse, &quot;draining current segment&quot;);
1270       if (in_segment-&gt;rate &gt; 0.0)
1271         gst_base_parse_drain (parse);
1272       else
1273         gst_base_parse_finish_fragment (parse, FALSE);
1274       gst_adapter_clear (parse-&gt;priv-&gt;adapter);
1275 
1276       parse-&gt;priv-&gt;offset = offset;
1277       parse-&gt;priv-&gt;sync_offset = offset;
1278       parse-&gt;priv-&gt;next_dts = next_dts;
1279       parse-&gt;priv-&gt;next_pts = GST_CLOCK_TIME_NONE;
1280       parse-&gt;priv-&gt;last_pts = GST_CLOCK_TIME_NONE;
1281       parse-&gt;priv-&gt;last_dts = GST_CLOCK_TIME_NONE;
1282       parse-&gt;priv-&gt;prev_pts = GST_CLOCK_TIME_NONE;
1283       parse-&gt;priv-&gt;prev_dts = GST_CLOCK_TIME_NONE;
1284       parse-&gt;priv-&gt;prev_dts_from_pts = FALSE;
1285       parse-&gt;priv-&gt;discont = TRUE;
1286       parse-&gt;priv-&gt;seen_keyframe = FALSE;
1287       parse-&gt;priv-&gt;skip = 0;
1288       break;
1289     }
1290 
1291     case GST_EVENT_SEGMENT_DONE:
1292       /* need to drain now, rather than upon a new segment,
1293        * since that would have SEGMENT_DONE come before potential
1294        * delayed last part of the current segment */
1295       GST_DEBUG_OBJECT (parse, &quot;draining current segment&quot;);
1296       if (parse-&gt;segment.rate &gt; 0.0)
1297         gst_base_parse_drain (parse);
1298       else
1299         gst_base_parse_finish_fragment (parse, FALSE);
1300       /* Also forward event immediately, there might be no new data
1301        * coming afterwards that would allow us to forward it later */
1302       forward_immediate = TRUE;
1303       break;
1304 
1305     case GST_EVENT_FLUSH_START:
1306       GST_OBJECT_LOCK (parse);
1307       parse-&gt;priv-&gt;flushing = TRUE;
1308       GST_OBJECT_UNLOCK (parse);
1309       break;
1310 
1311     case GST_EVENT_FLUSH_STOP:
1312       gst_adapter_clear (parse-&gt;priv-&gt;adapter);
1313       gst_base_parse_clear_queues (parse);
1314       parse-&gt;priv-&gt;flushing = FALSE;
1315       parse-&gt;priv-&gt;discont = TRUE;
1316       parse-&gt;priv-&gt;last_pts = GST_CLOCK_TIME_NONE;
1317       parse-&gt;priv-&gt;last_dts = GST_CLOCK_TIME_NONE;
1318       parse-&gt;priv-&gt;new_frame = TRUE;
1319       parse-&gt;priv-&gt;skip = 0;
1320 
1321       forward_immediate = TRUE;
1322       break;
1323 
1324     case GST_EVENT_EOS:
1325       if (parse-&gt;segment.rate &gt; 0.0)
1326         gst_base_parse_drain (parse);
1327       else
1328         gst_base_parse_finish_fragment (parse, TRUE);
1329 
1330       /* If we STILL have zero frames processed, fire an error */
1331       if (parse-&gt;priv-&gt;framecount == 0 &amp;&amp; !parse-&gt;priv-&gt;saw_gaps &amp;&amp;
1332           !parse-&gt;priv-&gt;first_buffer) {
1333         GST_ELEMENT_ERROR (parse, STREAM, WRONG_TYPE,
1334             (&quot;No valid frames found before end of stream&quot;), (NULL));
1335       }
1336 
1337       if (!parse-&gt;priv-&gt;saw_gaps
1338           &amp;&amp; parse-&gt;priv-&gt;framecount &lt; MIN_FRAMES_TO_POST_BITRATE) {
1339         /* We&#39;ve not posted bitrate tags yet - do so now */
1340         gst_base_parse_queue_tag_event_update (parse);
1341       }
1342 
1343       /* newsegment and other serialized events before eos */
1344       gst_base_parse_push_pending_events (parse);
1345 
1346       forward_immediate = TRUE;
1347       break;
1348     case GST_EVENT_CUSTOM_DOWNSTREAM:{
1349       /* FIXME: Code duplicated from libgstvideo because core can&#39;t depend on -base */
1350 #ifndef GST_VIDEO_EVENT_STILL_STATE_NAME
1351 #define GST_VIDEO_EVENT_STILL_STATE_NAME &quot;GstEventStillFrame&quot;
1352 #endif
1353 
1354       const GstStructure *s;
1355       gboolean ev_still_state;
1356 
1357       s = gst_event_get_structure (event);
1358       if (s != NULL &amp;&amp;
1359           gst_structure_has_name (s, GST_VIDEO_EVENT_STILL_STATE_NAME) &amp;&amp;
1360           gst_structure_get_boolean (s, &quot;still-state&quot;, &amp;ev_still_state)) {
1361         if (ev_still_state) {
1362           GST_DEBUG_OBJECT (parse, &quot;draining current data for still-frame&quot;);
1363           if (parse-&gt;segment.rate &gt; 0.0)
1364             gst_base_parse_drain (parse);
1365           else
1366             gst_base_parse_finish_fragment (parse, TRUE);
1367         }
1368         forward_immediate = TRUE;
1369       }
1370       break;
1371     }
1372     case GST_EVENT_GAP:
1373     {
1374       GST_DEBUG_OBJECT (parse, &quot;draining current data due to gap event&quot;);
1375 
1376       /* Ensure we have caps before forwarding the event */
1377       if (!gst_pad_has_current_caps (GST_BASE_PARSE_SRC_PAD (parse))) {
1378         GstCaps *default_caps = NULL;
1379         if ((default_caps = gst_base_parse_negotiate_default_caps (parse))) {
1380           GList *l;
1381           GstEvent *caps_event = gst_event_new_caps (default_caps);
1382 
1383           GST_DEBUG_OBJECT (parse,
1384               &quot;Store caps event to pending list for initial pre-rolling&quot;);
1385 
1386           /* Events are in decreasing order. Go down the list until we
1387            * find the first pre-CAPS event and insert our CAPS event there.
1388            *
1389            * There should be a SEGMENT event already, which is &gt; CAPS */
1390           for (l = parse-&gt;priv-&gt;pending_events; l; l = l-&gt;next) {
1391             GstEvent *e = l-&gt;data;
1392 
1393             if (GST_EVENT_TYPE (e) &lt; GST_EVENT_CAPS) {
1394               parse-&gt;priv-&gt;pending_events =
1395                   g_list_insert_before (parse-&gt;priv-&gt;pending_events, l,
1396                   caps_event);
1397               break;
1398             }
1399           }
1400           /* No pending event that is &lt; CAPS, so we have to add it at the very
1401            * end of the list */
1402           if (!l) {
1403             parse-&gt;priv-&gt;pending_events =
1404                 g_list_append (parse-&gt;priv-&gt;pending_events, caps_event);
1405           }
1406           gst_caps_unref (default_caps);
1407         } else {
1408           gst_event_unref (event);
1409           event = NULL;
1410           ret = FALSE;
1411           GST_ELEMENT_ERROR (parse, STREAM, FORMAT, (NULL),
1412               (&quot;Parser output not negotiated before GAP event.&quot;));
1413           break;
1414         }
1415       }
1416 
1417       gst_base_parse_push_pending_events (parse);
1418 
1419       if (parse-&gt;segment.rate &gt; 0.0)
1420         gst_base_parse_drain (parse);
1421       else
1422         gst_base_parse_finish_fragment (parse, TRUE);
1423       forward_immediate = TRUE;
1424       parse-&gt;priv-&gt;saw_gaps = TRUE;
1425       break;
1426     }
1427     case GST_EVENT_TAG:
1428     {
1429       GstTagList *tags = NULL;
1430 
1431       gst_event_parse_tag (event, &amp;tags);
1432 
1433       /* We only care about stream tags here, global tags we just forward */
1434       if (gst_tag_list_get_scope (tags) != GST_TAG_SCOPE_STREAM)
1435       break;
1436 
1437       gst_base_parse_set_upstream_tags (parse, tags);
1438       gst_base_parse_queue_tag_event_update (parse);
1439       parse-&gt;priv-&gt;tags_changed = FALSE;
1440       gst_event_unref (event);
1441       event = NULL;
1442       ret = TRUE;
1443       break;
1444     }
1445     case GST_EVENT_STREAM_START:
1446     {
1447       if (parse-&gt;priv-&gt;pad_mode != GST_PAD_MODE_PULL)
1448         forward_immediate = TRUE;
1449 
1450       gst_base_parse_set_upstream_tags (parse, NULL);
1451       parse-&gt;priv-&gt;tags_changed = TRUE;
1452       break;
1453     }
1454     default:
1455       break;
1456   }
1457 
1458   /* Forward non-serialized events and EOS/FLUSH_STOP immediately.
1459    * For EOS this is required because no buffer or serialized event
1460    * will come after EOS and nothing could trigger another
1461    * _finish_frame() call.   *
1462    * If the subclass handles sending of EOS manually it can return
1463    * _DROPPED from ::finish() and all other subclasses should have
1464    * decoded/flushed all remaining data before this
1465    *
1466    * For FLUSH_STOP this is required because it is expected
1467    * to be forwarded immediately and no buffers are queued anyway.
1468    */
1469   if (event) {
1470     if (!GST_EVENT_IS_SERIALIZED (event) || forward_immediate) {
1471       ret = gst_pad_push_event (parse-&gt;srcpad, event);
1472     } else {
1473       parse-&gt;priv-&gt;pending_events =
1474           g_list_prepend (parse-&gt;priv-&gt;pending_events, event);
1475       ret = TRUE;
1476     }
1477   }
1478 
1479   GST_DEBUG_OBJECT (parse, &quot;event handled&quot;);
1480 
1481   return ret;
1482 }
1483 
1484 static gboolean
1485 gst_base_parse_sink_query_default (GstBaseParse * parse, GstQuery * query)
1486 {
1487   GstPad *pad;
1488   gboolean res;
1489 
1490   pad = GST_BASE_PARSE_SINK_PAD (parse);
1491 
1492   switch (GST_QUERY_TYPE (query)) {
1493     case GST_QUERY_CAPS:
1494     {
1495       GstBaseParseClass *bclass;
1496 
1497       bclass = GST_BASE_PARSE_GET_CLASS (parse);
1498 
1499       if (bclass-&gt;get_sink_caps) {
1500         GstCaps *caps, *filter;
1501 
1502         gst_query_parse_caps (query, &amp;filter);
1503         caps = bclass-&gt;get_sink_caps (parse, filter);
1504         GST_LOG_OBJECT (parse, &quot;sink getcaps returning caps %&quot; GST_PTR_FORMAT,
1505             caps);
1506         gst_query_set_caps_result (query, caps);
1507         gst_caps_unref (caps);
1508 
1509         res = TRUE;
1510       } else {
1511         GstCaps *caps, *template_caps, *filter;
1512 
1513         gst_query_parse_caps (query, &amp;filter);
1514         template_caps = gst_pad_get_pad_template_caps (pad);
1515         if (filter != NULL) {
1516           caps =
1517               gst_caps_intersect_full (filter, template_caps,
1518               GST_CAPS_INTERSECT_FIRST);
1519           gst_caps_unref (template_caps);
1520         } else {
1521           caps = template_caps;
1522         }
1523         gst_query_set_caps_result (query, caps);
1524         gst_caps_unref (caps);
1525 
1526         res = TRUE;
1527       }
1528       break;
1529     }
1530     default:
1531     {
1532       res = gst_pad_query_default (pad, GST_OBJECT_CAST (parse), query);
1533       break;
1534     }
1535   }
1536 
1537   return res;
1538 }
1539 
1540 static gboolean
1541 gst_base_parse_sink_query (GstPad * pad, GstObject * parent, GstQuery * query)
1542 {
1543   GstBaseParseClass *bclass;
1544   GstBaseParse *parse;
1545   gboolean ret;
1546 
1547   parse = GST_BASE_PARSE (parent);
1548   bclass = GST_BASE_PARSE_GET_CLASS (parse);
1549 
1550   GST_DEBUG_OBJECT (parse, &quot;%s query&quot;, GST_QUERY_TYPE_NAME (query));
1551 
1552   if (bclass-&gt;sink_query)
1553     ret = bclass-&gt;sink_query (parse, query);
1554   else
1555     ret = FALSE;
1556 
1557   GST_LOG_OBJECT (parse, &quot;%s query result: %d %&quot; GST_PTR_FORMAT,
1558       GST_QUERY_TYPE_NAME (query), ret, query);
1559 
1560   return ret;
1561 }
1562 
1563 static gboolean
1564 gst_base_parse_src_query (GstPad * pad, GstObject * parent, GstQuery * query)
1565 {
1566   GstBaseParseClass *bclass;
1567   GstBaseParse *parse;
1568   gboolean ret;
1569 
1570   parse = GST_BASE_PARSE (parent);
1571   bclass = GST_BASE_PARSE_GET_CLASS (parse);
1572 
1573   GST_DEBUG_OBJECT (parse, &quot;%s query: %&quot; GST_PTR_FORMAT,
1574       GST_QUERY_TYPE_NAME (query), query);
1575 
1576   if (bclass-&gt;src_query)
1577     ret = bclass-&gt;src_query (parse, query);
1578   else
1579     ret = FALSE;
1580 
1581   GST_LOG_OBJECT (parse, &quot;%s query result: %d %&quot; GST_PTR_FORMAT,
1582       GST_QUERY_TYPE_NAME (query), ret, query);
1583 
1584   return ret;
1585 }
1586 
1587 /* gst_base_parse_src_event:
1588  * @pad: #GstPad that received the event.
1589  * @event: #GstEvent that was received.
1590  *
1591  * Handler for source pad events.
1592  *
1593  * Returns: %TRUE if the event was handled.
1594  */
1595 static gboolean
1596 gst_base_parse_src_event (GstPad * pad, GstObject * parent, GstEvent * event)
1597 {
1598   GstBaseParse *parse;
1599   GstBaseParseClass *bclass;
1600   gboolean ret = TRUE;
1601 
1602   parse = GST_BASE_PARSE (parent);
1603   bclass = GST_BASE_PARSE_GET_CLASS (parse);
1604 
1605   GST_DEBUG_OBJECT (parse, &quot;event %d, %s&quot;, GST_EVENT_TYPE (event),
1606       GST_EVENT_TYPE_NAME (event));
1607 
1608   if (bclass-&gt;src_event)
1609     ret = bclass-&gt;src_event (parse, event);
1610   else
1611     gst_event_unref (event);
1612 
1613   return ret;
1614 }
1615 
1616 static gboolean
1617 gst_base_parse_is_seekable (GstBaseParse * parse)
1618 {
1619   /* FIXME: could do more here, e.g. check index or just send data from 0
1620    * in pull mode and let decoder/sink clip */
1621   return parse-&gt;priv-&gt;syncable;
1622 }
1623 
1624 /* gst_base_parse_src_event_default:
1625  * @parse: #GstBaseParse.
1626  * @event: #GstEvent that was received.
1627  *
1628  * Default srcpad event handler.
1629  *
1630  * Returns: %TRUE if the event was handled and can be dropped.
1631  */
1632 static gboolean
1633 gst_base_parse_src_event_default (GstBaseParse * parse, GstEvent * event)
1634 {
1635   gboolean res = FALSE;
1636 
1637   switch (GST_EVENT_TYPE (event)) {
1638     case GST_EVENT_SEEK:
1639       if (gst_base_parse_is_seekable (parse))
1640         res = gst_base_parse_handle_seek (parse, event);
1641       break;
1642     default:
1643       res = gst_pad_event_default (parse-&gt;srcpad, GST_OBJECT_CAST (parse),
1644           event);
1645       break;
1646   }
1647   return res;
1648 }
1649 
1650 
1651 /**
1652  * gst_base_parse_convert_default:
1653  * @parse: #GstBaseParse.
1654  * @src_format: #GstFormat describing the source format.
1655  * @src_value: Source value to be converted.
1656  * @dest_format: #GstFormat defining the converted format.
1657  * @dest_value: (out): Pointer where the conversion result will be put.
1658  *
1659  * Default implementation of &quot;convert&quot; vmethod in #GstBaseParse class.
1660  *
1661  * Returns: %TRUE if conversion was successful.
1662  */
1663 gboolean
1664 gst_base_parse_convert_default (GstBaseParse * parse,
1665     GstFormat src_format,
1666     gint64 src_value, GstFormat dest_format, gint64 * dest_value)
1667 {
1668   gboolean ret = FALSE;
1669   guint64 bytes, duration;
1670 
1671   if (G_UNLIKELY (src_format == dest_format)) {
1672     *dest_value = src_value;
1673     return TRUE;
1674   }
1675 
1676   if (G_UNLIKELY (src_value == -1)) {
1677     *dest_value = -1;
1678     return TRUE;
1679   }
1680 
1681   if (G_UNLIKELY (src_value == 0)) {
1682     *dest_value = 0;
1683     return TRUE;
1684   }
1685 
1686   if (parse-&gt;priv-&gt;upstream_format != GST_FORMAT_BYTES) {
1687     /* don&#39;t do byte format conversions if we&#39;re not really parsing
1688      * a raw elementary stream, since we don&#39;t really have BYTES
1689      * position / duration info */
1690     if (src_format == GST_FORMAT_BYTES || dest_format == GST_FORMAT_BYTES)
1691       goto no_slaved_conversions;
1692   }
1693 
1694   /* need at least some frames */
1695   if (!parse-&gt;priv-&gt;framecount)
1696     goto no_framecount;
1697 
1698   duration = parse-&gt;priv-&gt;acc_duration / GST_MSECOND;
1699   bytes = parse-&gt;priv-&gt;bytecount;
1700 
1701   if (G_UNLIKELY (!duration || !bytes))
1702     goto no_duration_bytes;
1703 
1704   if (src_format == GST_FORMAT_BYTES) {
1705     if (dest_format == GST_FORMAT_TIME) {
1706       /* BYTES -&gt; TIME conversion */
1707       GST_DEBUG_OBJECT (parse, &quot;converting bytes -&gt; time&quot;);
1708       *dest_value = gst_util_uint64_scale (src_value, duration, bytes);
1709       *dest_value *= GST_MSECOND;
1710       GST_DEBUG_OBJECT (parse, &quot;conversion result: %&quot; G_GINT64_FORMAT &quot; ms&quot;,
1711           *dest_value / GST_MSECOND);
1712       ret = TRUE;
1713     } else {
1714       GST_DEBUG_OBJECT (parse, &quot;converting bytes -&gt; other not implemented&quot;);
1715     }
1716   } else if (src_format == GST_FORMAT_TIME) {
1717     if (dest_format == GST_FORMAT_BYTES) {
1718       GST_DEBUG_OBJECT (parse, &quot;converting time -&gt; bytes&quot;);
1719       *dest_value = gst_util_uint64_scale (src_value / GST_MSECOND, bytes,
1720           duration);
1721       GST_DEBUG_OBJECT (parse,
1722           &quot;time %&quot; G_GINT64_FORMAT &quot; ms in bytes = %&quot; G_GINT64_FORMAT,
1723           src_value / GST_MSECOND, *dest_value);
1724       ret = TRUE;
1725     } else {
1726       GST_DEBUG_OBJECT (parse, &quot;converting time -&gt; other not implemented&quot;);
1727     }
1728   } else if (src_format == GST_FORMAT_DEFAULT) {
1729     /* DEFAULT == frame-based */
1730     if (dest_format == GST_FORMAT_TIME) {
1731       GST_DEBUG_OBJECT (parse, &quot;converting default -&gt; time&quot;);
1732       if (parse-&gt;priv-&gt;fps_den) {
1733         *dest_value = gst_util_uint64_scale (src_value,
1734             GST_SECOND * parse-&gt;priv-&gt;fps_den, parse-&gt;priv-&gt;fps_num);
1735         ret = TRUE;
1736       }
1737     } else {
1738       GST_DEBUG_OBJECT (parse, &quot;converting default -&gt; other not implemented&quot;);
1739     }
1740   } else {
1741     GST_DEBUG_OBJECT (parse, &quot;conversion not implemented&quot;);
1742   }
1743   return ret;
1744 
1745   /* ERRORS */
1746 no_framecount:
1747   {
1748     GST_DEBUG_OBJECT (parse, &quot;no framecount&quot;);
1749     return FALSE;
1750   }
1751 no_duration_bytes:
1752   {
1753     GST_DEBUG_OBJECT (parse, &quot;no duration %&quot; G_GUINT64_FORMAT &quot;, bytes %&quot;
1754         G_GUINT64_FORMAT, duration, bytes);
1755     return FALSE;
1756   }
1757 no_slaved_conversions:
1758   {
1759     GST_DEBUG_OBJECT (parse,
1760         &quot;Can&#39;t do format conversions when upstream format is not BYTES&quot;);
1761     return FALSE;
1762 }
1763 }
1764 
1765 static void
1766 gst_base_parse_update_duration (GstBaseParse * parse)
1767 {
1768   gint64 ptot, dest_value;
1769 
1770   if (!gst_pad_peer_query_duration (parse-&gt;sinkpad, GST_FORMAT_BYTES, &amp;ptot))
1771     return;
1772 
1773   if (!gst_base_parse_convert (parse, GST_FORMAT_BYTES, ptot,
1774           GST_FORMAT_TIME, &amp;dest_value))
1775     return;
1776 
1777   /* inform if duration changed, but try to avoid spamming */
1778   parse-&gt;priv-&gt;estimated_drift += dest_value - parse-&gt;priv-&gt;estimated_duration;
1779 
1780   parse-&gt;priv-&gt;estimated_duration = dest_value;
1781   GST_LOG_OBJECT (parse,
1782       &quot;updated estimated duration to %&quot; GST_TIME_FORMAT,
1783       GST_TIME_ARGS (dest_value));
1784 
1785         if (parse-&gt;priv-&gt;estimated_drift &gt; GST_SECOND ||
1786             parse-&gt;priv-&gt;estimated_drift &lt; -GST_SECOND) {
1787           gst_element_post_message (GST_ELEMENT (parse),
1788               gst_message_new_duration_changed (GST_OBJECT (parse)));
1789           parse-&gt;priv-&gt;estimated_drift = 0;
1790         }
1791       }
1792 
1793 /* gst_base_parse_update_bitrates:
1794  * @parse: #GstBaseParse.
1795  * @buffer: Current frame as a #GstBuffer
1796  *
1797  * Keeps track of the minimum and maximum bitrates, and also maintains a
1798  * running average bitrate of the stream so far.
1799  */
1800 static void
1801 gst_base_parse_update_bitrates (GstBaseParse * parse, GstBaseParseFrame * frame)
1802 {
1803   guint64 data_len, frame_dur;
1804   gint overhead;
1805   guint frame_bitrate;
1806   guint64 frame_bitrate64;
1807   GstBuffer *buffer = frame-&gt;buffer;
1808 
1809   overhead = frame-&gt;overhead;
1810   if (overhead == -1)
1811     return;
1812 
1813   data_len = gst_buffer_get_size (buffer) - overhead;
1814   parse-&gt;priv-&gt;data_bytecount += data_len;
1815 
1816   /* duration should be valid by now,
1817    * either set by subclass or maybe based on fps settings */
1818   if (GST_BUFFER_DURATION_IS_VALID (buffer) &amp;&amp; parse-&gt;priv-&gt;acc_duration != 0) {
1819     guint64 avg_bitrate;
1820 
1821     /* Calculate duration of a frame from buffer properties */
1822     frame_dur = GST_BUFFER_DURATION (buffer);
1823     avg_bitrate = gst_util_uint64_scale (GST_SECOND,
1824         8 * parse-&gt;priv-&gt;data_bytecount, parse-&gt;priv-&gt;acc_duration);
1825 
1826     if (avg_bitrate &gt; G_MAXUINT)
1827       return;
1828 
1829     parse-&gt;priv-&gt;avg_bitrate = (guint) avg_bitrate;
1830   } else {
1831     /* No way to figure out frame duration (is this even possible?) */
1832     return;
1833   }
1834 
1835   /* override if subclass provided bitrate, e.g. metadata based */
1836   if (parse-&gt;priv-&gt;bitrate) {
1837     parse-&gt;priv-&gt;avg_bitrate = parse-&gt;priv-&gt;bitrate;
1838     /* spread this (confirmed) info ASAP */
1839     if (parse-&gt;priv-&gt;post_avg_bitrate &amp;&amp;
1840         parse-&gt;priv-&gt;posted_avg_bitrate != parse-&gt;priv-&gt;avg_bitrate)
1841       parse-&gt;priv-&gt;tags_changed = TRUE;
1842   }
1843 
1844   if (!frame_dur)
1845     return;
1846 
1847   frame_bitrate64 = gst_util_uint64_scale (GST_SECOND, 8 * data_len, frame_dur);
1848 
1849   if (frame_bitrate64 &gt; G_MAXUINT)
1850     return;
1851 
1852   frame_bitrate = (guint) frame_bitrate64;
1853 
1854   GST_LOG_OBJECT (parse, &quot;frame bitrate %u, avg bitrate %u&quot;, frame_bitrate,
1855       parse-&gt;priv-&gt;avg_bitrate);
1856 
1857   if (parse-&gt;priv-&gt;framecount &lt; MIN_FRAMES_TO_POST_BITRATE)
1858     return;
1859 
1860   if (parse-&gt;priv-&gt;framecount == MIN_FRAMES_TO_POST_BITRATE &amp;&amp;
1861       (parse-&gt;priv-&gt;post_min_bitrate || parse-&gt;priv-&gt;post_avg_bitrate
1862           || parse-&gt;priv-&gt;post_max_bitrate))
1863     parse-&gt;priv-&gt;tags_changed = TRUE;
1864 
1865   if (G_LIKELY (parse-&gt;priv-&gt;framecount &gt;= MIN_FRAMES_TO_POST_BITRATE)) {
1866     if (frame_bitrate &lt; parse-&gt;priv-&gt;min_bitrate) {
1867       parse-&gt;priv-&gt;min_bitrate = frame_bitrate;
1868       if (parse-&gt;priv-&gt;post_min_bitrate)
1869         parse-&gt;priv-&gt;tags_changed = TRUE;
1870     }
1871 
1872     if (frame_bitrate &gt; parse-&gt;priv-&gt;max_bitrate) {
1873       parse-&gt;priv-&gt;max_bitrate = frame_bitrate;
1874       if (parse-&gt;priv-&gt;post_max_bitrate)
1875         parse-&gt;priv-&gt;tags_changed = TRUE;
1876     }
1877 
1878     /* Only update the tag on a 2% change */
1879     if (parse-&gt;priv-&gt;post_avg_bitrate &amp;&amp; parse-&gt;priv-&gt;avg_bitrate) {
1880       guint64 diffprev = gst_util_uint64_scale (100,
1881           ABSDIFF (parse-&gt;priv-&gt;avg_bitrate, parse-&gt;priv-&gt;posted_avg_bitrate),
1882           parse-&gt;priv-&gt;avg_bitrate);
1883       if (diffprev &gt;= UPDATE_THRESHOLD)
1884         parse-&gt;priv-&gt;tags_changed = TRUE;
1885   }
1886 }
1887 }
1888 
1889 /**
1890  * gst_base_parse_add_index_entry:
1891  * @parse: #GstBaseParse.
1892  * @offset: offset of entry
1893  * @ts: timestamp associated with offset
1894  * @key: whether entry refers to keyframe
1895  * @force: add entry disregarding sanity checks
1896  *
1897  * Adds an entry to the index associating @offset to @ts.  It is recommended
1898  * to only add keyframe entries.  @force allows to bypass checks, such as
1899  * whether the stream is (upstream) seekable, another entry is already &quot;close&quot;
1900  * to the new entry, etc.
1901  *
1902  * Returns: #gboolean indicating whether entry was added
1903  */
1904 gboolean
1905 gst_base_parse_add_index_entry (GstBaseParse * parse, guint64 offset,
1906     GstClockTime ts, gboolean key, gboolean force)
1907 {
1908   gboolean ret = FALSE;
1909   GstIndexAssociation associations[2];
1910 
1911   GST_LOG_OBJECT (parse, &quot;Adding key=%d index entry %&quot; GST_TIME_FORMAT
1912       &quot; @ offset 0x%08&quot; G_GINT64_MODIFIER &quot;x&quot;, key, GST_TIME_ARGS (ts), offset);
1913 
1914   if (G_LIKELY (!force)) {
1915 
1916     if (!parse-&gt;priv-&gt;upstream_seekable) {
1917       GST_DEBUG_OBJECT (parse, &quot;upstream not seekable; discarding&quot;);
1918       goto exit;
1919     }
1920 
1921     /* FIXME need better helper data structure that handles these issues
1922      * related to ongoing collecting of index entries */
1923     if (parse-&gt;priv-&gt;index_last_offset + parse-&gt;priv-&gt;idx_byte_interval &gt;=
1924         (gint64) offset) {
1925       GST_LOG_OBJECT (parse,
1926           &quot;already have entries up to offset 0x%08&quot; G_GINT64_MODIFIER &quot;x&quot;,
1927           parse-&gt;priv-&gt;index_last_offset + parse-&gt;priv-&gt;idx_byte_interval);
1928       goto exit;
1929     }
1930 
1931     if (GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;index_last_ts) &amp;&amp;
1932         GST_CLOCK_DIFF (parse-&gt;priv-&gt;index_last_ts, ts) &lt;
1933         parse-&gt;priv-&gt;idx_interval) {
1934       GST_LOG_OBJECT (parse, &quot;entry too close to last time %&quot; GST_TIME_FORMAT,
1935           GST_TIME_ARGS (parse-&gt;priv-&gt;index_last_ts));
1936       goto exit;
1937     }
1938 
1939     /* if last is not really the last one */
1940     if (!parse-&gt;priv-&gt;index_last_valid) {
1941       GstClockTime prev_ts;
1942 
1943       gst_base_parse_find_offset (parse, ts, TRUE, &amp;prev_ts);
1944       if (GST_CLOCK_DIFF (prev_ts, ts) &lt; parse-&gt;priv-&gt;idx_interval) {
1945         GST_LOG_OBJECT (parse,
1946             &quot;entry too close to existing entry %&quot; GST_TIME_FORMAT,
1947             GST_TIME_ARGS (prev_ts));
1948         parse-&gt;priv-&gt;index_last_offset = offset;
1949         parse-&gt;priv-&gt;index_last_ts = ts;
1950         goto exit;
1951       }
1952     }
1953   }
1954 
1955   associations[0].format = GST_FORMAT_TIME;
1956   associations[0].value = ts;
1957   associations[1].format = GST_FORMAT_BYTES;
1958   associations[1].value = offset;
1959 
1960   /* index might change on-the-fly, although that would be nutty app ... */
1961   GST_BASE_PARSE_INDEX_LOCK (parse);
1962   gst_index_add_associationv (parse-&gt;priv-&gt;index, parse-&gt;priv-&gt;index_id,
1963       (key) ? GST_INDEX_ASSOCIATION_FLAG_KEY_UNIT :
1964       GST_INDEX_ASSOCIATION_FLAG_DELTA_UNIT, 2,
1965       (const GstIndexAssociation *) &amp;associations);
1966   GST_BASE_PARSE_INDEX_UNLOCK (parse);
1967 
1968   if (key) {
1969     parse-&gt;priv-&gt;index_last_offset = offset;
1970     parse-&gt;priv-&gt;index_last_ts = ts;
1971   }
1972 
1973   ret = TRUE;
1974 
1975 exit:
1976   return ret;
1977 }
1978 
1979 /* check for seekable upstream, above and beyond a mere query */
1980 static void
1981 gst_base_parse_check_seekability (GstBaseParse * parse)
1982 {
1983   GstQuery *query;
1984   gboolean seekable = FALSE;
1985   gint64 start = -1, stop = -1;
1986   guint idx_interval = 0;
1987   guint64 idx_byte_interval = 0;
1988 
1989   query = gst_query_new_seeking (GST_FORMAT_BYTES);
1990   if (!gst_pad_peer_query (parse-&gt;sinkpad, query)) {
1991     GST_DEBUG_OBJECT (parse, &quot;seeking query failed&quot;);
1992     goto done;
1993   }
1994 
1995   gst_query_parse_seeking (query, NULL, &amp;seekable, &amp;start, &amp;stop);
1996 
1997   /* try harder to query upstream size if we didn&#39;t get it the first time */
1998   if (seekable &amp;&amp; stop == -1) {
1999     GST_DEBUG_OBJECT (parse, &quot;doing duration query to fix up unset stop&quot;);
2000     gst_pad_peer_query_duration (parse-&gt;sinkpad, GST_FORMAT_BYTES, &amp;stop);
2001   }
2002 
2003   /* if upstream doesn&#39;t know the size, it&#39;s likely that it&#39;s not seekable in
2004    * practice even if it technically may be seekable */
2005   if (seekable &amp;&amp; (start != 0 || stop &lt;= start)) {
2006     GST_DEBUG_OBJECT (parse, &quot;seekable but unknown start/stop -&gt; disable&quot;);
2007     seekable = FALSE;
2008   }
2009 
2010   /* let&#39;s not put every single frame into our index */
2011   if (seekable) {
2012     if (stop &lt; 10 * 1024 * 1024)
2013       idx_interval = 100;
2014     else if (stop &lt; 100 * 1024 * 1024)
2015       idx_interval = 500;
2016     else
2017       idx_interval = 1000;
2018 
2019     /* ensure that even for large files (e.g. very long audio files), the index
2020      * stays reasonably-size, with some arbitrary limit to the total number of
2021      * index entries */
2022     idx_byte_interval = (stop - start) / MAX_INDEX_ENTRIES;
2023     GST_DEBUG_OBJECT (parse,
2024         &quot;Limiting index entries to %d, indexing byte interval %&quot;
2025         G_GUINT64_FORMAT &quot; bytes&quot;, MAX_INDEX_ENTRIES, idx_byte_interval);
2026   }
2027 
2028 done:
2029   gst_query_unref (query);
2030 
2031   GST_DEBUG_OBJECT (parse, &quot;seekable: %d (%&quot; G_GUINT64_FORMAT &quot; - %&quot;
2032       G_GUINT64_FORMAT &quot;)&quot;, seekable, start, stop);
2033   parse-&gt;priv-&gt;upstream_seekable = seekable;
2034   parse-&gt;priv-&gt;upstream_size = seekable ? stop : 0;
2035 
2036   GST_DEBUG_OBJECT (parse, &quot;idx_interval: %ums&quot;, idx_interval);
2037   parse-&gt;priv-&gt;idx_interval = idx_interval * GST_MSECOND;
2038   parse-&gt;priv-&gt;idx_byte_interval = idx_byte_interval;
2039 }
2040 
2041 /* some misc checks on upstream */
2042 static void
2043 gst_base_parse_check_upstream (GstBaseParse * parse)
2044 {
2045   gint64 stop;
2046 
2047   if (gst_pad_peer_query_duration (parse-&gt;sinkpad, GST_FORMAT_TIME, &amp;stop))
2048     if (GST_CLOCK_TIME_IS_VALID (stop) &amp;&amp; stop) {
2049       /* upstream has one, accept it also, and no further updates */
2050       gst_base_parse_set_duration (parse, GST_FORMAT_TIME, stop, 0);
2051       parse-&gt;priv-&gt;upstream_has_duration = TRUE;
2052     }
2053 
2054   GST_DEBUG_OBJECT (parse, &quot;upstream_has_duration: %d&quot;,
2055       parse-&gt;priv-&gt;upstream_has_duration);
2056 }
2057 
2058 /* checks src caps to determine if dealing with audio or video */
2059 /* TODO maybe forego automagic stuff and let subclass configure it ? */
2060 static void
2061 gst_base_parse_check_media (GstBaseParse * parse)
2062 {
2063   GstCaps *caps;
2064   GstStructure *s;
2065 
2066   caps = gst_pad_get_current_caps (parse-&gt;srcpad);
2067   if (G_LIKELY (caps) &amp;&amp; (s = gst_caps_get_structure (caps, 0))) {
2068     parse-&gt;priv-&gt;is_video =
2069         g_str_has_prefix (gst_structure_get_name (s), &quot;video&quot;);
2070   } else {
2071     /* historical default */
2072     parse-&gt;priv-&gt;is_video = FALSE;
2073   }
2074   if (caps)
2075     gst_caps_unref (caps);
2076 
2077   parse-&gt;priv-&gt;checked_media = TRUE;
2078   GST_DEBUG_OBJECT (parse, &quot;media is video: %d&quot;, parse-&gt;priv-&gt;is_video);
2079 }
2080 
2081 /* takes ownership of frame */
2082 static void
2083 gst_base_parse_queue_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
2084 {
2085   if (!(frame-&gt;_private_flags &amp; GST_BASE_PARSE_FRAME_PRIVATE_FLAG_NOALLOC)) {
2086     /* frame allocated on the heap, we can just take ownership */
2087     g_queue_push_tail (&amp;parse-&gt;priv-&gt;queued_frames, frame);
2088     GST_TRACE (&quot;queued frame %p&quot;, frame);
2089   } else {
2090     GstBaseParseFrame *copy;
2091 
2092     /* probably allocated on the stack, must make a proper copy */
2093     copy = gst_base_parse_frame_copy (frame);
2094     g_queue_push_tail (&amp;parse-&gt;priv-&gt;queued_frames, copy);
2095     GST_TRACE (&quot;queued frame %p (copy of %p)&quot;, copy, frame);
2096     gst_base_parse_frame_free (frame);
2097   }
2098 }
2099 
2100 /* makes sure that @buf is properly prepared and decorated for passing
2101  * to baseclass, and an equally setup frame is returned setup with @buf.
2102  * Takes ownership of @buf. */
2103 static GstBaseParseFrame *
2104 gst_base_parse_prepare_frame (GstBaseParse * parse, GstBuffer * buffer)
2105 {
2106   GstBaseParseFrame *frame = NULL;
2107 
2108   buffer = gst_buffer_make_writable (buffer);
2109 
2110   GST_LOG_OBJECT (parse,
2111       &quot;preparing frame at offset %&quot; G_GUINT64_FORMAT
2112       &quot; (%#&quot; G_GINT64_MODIFIER &quot;x) of size %&quot; G_GSIZE_FORMAT,
2113       GST_BUFFER_OFFSET (buffer), GST_BUFFER_OFFSET (buffer),
2114       gst_buffer_get_size (buffer));
2115 
2116   GST_BUFFER_OFFSET (buffer) = parse-&gt;priv-&gt;offset;
2117 
2118   gst_base_parse_update_flags (parse);
2119 
2120   frame = gst_base_parse_frame_new (buffer, 0, 0);
2121   gst_buffer_unref (buffer);
2122   gst_base_parse_update_frame (parse, frame);
2123 
2124   /* clear flags for next frame */
2125   parse-&gt;priv-&gt;discont = FALSE;
2126     parse-&gt;priv-&gt;new_frame = FALSE;
2127 
2128   /* use default handler to provide initial (upstream) metadata */
2129   gst_base_parse_parse_frame (parse, frame);
2130 
2131   return frame;
2132 }
2133 
2134 /* Wraps buffer in a frame and dispatches to subclass.
2135  * Also manages data skipping and offset handling (including adapter flushing).
2136  * Takes ownership of @buffer */
2137 static GstFlowReturn
2138 gst_base_parse_handle_buffer (GstBaseParse * parse, GstBuffer * buffer,
2139     gint * skip, gint * flushed)
2140 {
2141   GstBaseParseClass *klass = GST_BASE_PARSE_GET_CLASS (parse);
2142   GstBaseParseFrame *frame;
2143   GstFlowReturn ret;
2144 
2145   g_return_val_if_fail (skip != NULL || flushed != NULL, GST_FLOW_ERROR);
2146 
2147   GST_LOG_OBJECT (parse,
2148       &quot;handling buffer of size %&quot; G_GSIZE_FORMAT &quot; with dts %&quot; GST_TIME_FORMAT
2149       &quot;, pts %&quot; GST_TIME_FORMAT &quot;, duration %&quot; GST_TIME_FORMAT,
2150       gst_buffer_get_size (buffer), GST_TIME_ARGS (GST_BUFFER_DTS (buffer)),
2151       GST_TIME_ARGS (GST_BUFFER_PTS (buffer)),
2152       GST_TIME_ARGS (GST_BUFFER_DURATION (buffer)));
2153 
2154   /* track what is being flushed during this single round of frame processing */
2155   parse-&gt;priv-&gt;flushed = 0;
2156   *skip = 0;
2157 
2158   /* make it easy for _finish_frame to pick up input data */
2159   if (parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_PULL) {
2160     gst_buffer_ref (buffer);
2161     gst_adapter_push (parse-&gt;priv-&gt;adapter, buffer);
2162   }
2163 
2164   frame = gst_base_parse_prepare_frame (parse, buffer);
2165   ret = klass-&gt;handle_frame (parse, frame, skip);
2166 
2167   *flushed = parse-&gt;priv-&gt;flushed;
2168 
2169   GST_LOG_OBJECT (parse, &quot;handle_frame skipped %d, flushed %d&quot;,
2170       *skip, *flushed);
2171 
2172   /* subclass can only do one of these, or semantics are too unclear */
2173   g_assert (*skip == 0 || *flushed == 0);
2174 
2175   /* track skipping */
2176   if (*skip &gt; 0) {
2177     GstClockTime pts, dts;
2178     GstBuffer *outbuf;
2179 
2180     GST_LOG_OBJECT (parse, &quot;finding sync, skipping %d bytes&quot;, *skip);
2181     if (parse-&gt;segment.rate &lt; 0.0 &amp;&amp; !parse-&gt;priv-&gt;buffers_queued) {
2182       /* reverse playback, and no frames found yet, so we are skipping
2183        * the leading part of a fragment, which may form the tail of
2184        * fragment coming later, hopefully subclass skips efficiently ... */
2185       pts = gst_adapter_prev_pts (parse-&gt;priv-&gt;adapter, NULL);
2186       dts = gst_adapter_prev_dts (parse-&gt;priv-&gt;adapter, NULL);
2187       outbuf = gst_adapter_take_buffer (parse-&gt;priv-&gt;adapter, *skip);
2188 #ifdef GSTREAMER_LITE
2189       if (outbuf != NULL) {
2190 #endif // GSTREAMER_LITE
2191       outbuf = gst_buffer_make_writable (outbuf);
2192       GST_BUFFER_PTS (outbuf) = pts;
2193       GST_BUFFER_DTS (outbuf) = dts;
2194       parse-&gt;priv-&gt;buffers_head =
2195           g_slist_prepend (parse-&gt;priv-&gt;buffers_head, outbuf);
2196       outbuf = NULL;
2197 #ifdef GSTREAMER_LITE
2198       }
2199 #endif // GSTREAMER_LITE
2200     } else {
2201       /* If we&#39;re asked to skip more than is available in the adapter,
2202          we need to remember what we need to skip for next iteration */
2203       gsize av = gst_adapter_available (parse-&gt;priv-&gt;adapter);
2204       GST_DEBUG (&quot;Asked to skip %u (%&quot; G_GSIZE_FORMAT &quot; available)&quot;, *skip, av);
2205       if (av &gt;= *skip) {
2206       gst_adapter_flush (parse-&gt;priv-&gt;adapter, *skip);
2207       } else {
2208         GST_DEBUG
2209             (&quot;This is more than available, flushing %&quot; G_GSIZE_FORMAT
2210             &quot;, storing %u to skip&quot;, av, (guint) (*skip - av));
2211         parse-&gt;priv-&gt;skip = *skip - av;
2212         gst_adapter_flush (parse-&gt;priv-&gt;adapter, av);
2213         *skip = av;
2214     }
2215     }
2216     if (!parse-&gt;priv-&gt;discont)
2217       parse-&gt;priv-&gt;sync_offset = parse-&gt;priv-&gt;offset;
2218     parse-&gt;priv-&gt;offset += *skip;
2219     parse-&gt;priv-&gt;discont = TRUE;
2220     /* check for indefinite skipping */
2221     if (ret == GST_FLOW_OK)
2222       ret = gst_base_parse_check_sync (parse);
2223   }
2224 
2225   parse-&gt;priv-&gt;offset += *flushed;
2226 
2227   if (parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_PULL) {
2228     gst_adapter_clear (parse-&gt;priv-&gt;adapter);
2229   }
2230 
2231   if (*skip == 0 &amp;&amp; *flushed == 0) {
2232     /* Carry over discont if we need more data */
2233     if (GST_BUFFER_IS_DISCONT (frame-&gt;buffer))
2234       parse-&gt;priv-&gt;discont = TRUE;
2235   }
2236 
2237   gst_base_parse_frame_free (frame);
2238 
2239   return ret;
2240 }
2241 
2242 /* gst_base_parse_push_pending_events:
2243  * @parse: #GstBaseParse
2244  *
2245  * Pushes the pending events
2246  */
2247 static void
2248 gst_base_parse_push_pending_events (GstBaseParse * parse)
2249 {
2250   if (G_UNLIKELY (parse-&gt;priv-&gt;pending_events)) {
2251     GList *r = g_list_reverse (parse-&gt;priv-&gt;pending_events);
2252     GList *l;
2253 
2254     parse-&gt;priv-&gt;pending_events = NULL;
2255     for (l = r; l != NULL; l = l-&gt;next) {
2256       gst_pad_push_event (parse-&gt;srcpad, GST_EVENT_CAST (l-&gt;data));
2257     }
2258     g_list_free (r);
2259   }
2260 }
2261 
2262 /* gst_base_parse_handle_and_push_frame:
2263  * @parse: #GstBaseParse.
2264  * @klass: #GstBaseParseClass.
2265  * @frame: (transfer full): a #GstBaseParseFrame
2266  *
2267  * Parses the frame from given buffer and pushes it forward. Also performs
2268  * timestamp handling and checks the segment limits.
2269  *
2270  * This is called with srcpad STREAM_LOCK held.
2271  *
2272  * Returns: #GstFlowReturn
2273  */
2274 static GstFlowReturn
2275 gst_base_parse_handle_and_push_frame (GstBaseParse * parse,
2276     GstBaseParseFrame * frame)
2277 {
2278   gint64 offset;
2279   GstBuffer *buffer;
2280 
2281   g_return_val_if_fail (frame != NULL, GST_FLOW_ERROR);
2282 
2283   buffer = frame-&gt;buffer;
2284   offset = frame-&gt;offset;
2285 
2286   /* check if subclass/format can provide ts.
2287    * If so, that allows and enables extra seek and duration determining options */
2288   if (G_UNLIKELY (parse-&gt;priv-&gt;first_frame_offset &lt; 0)) {
2289     if (GST_BUFFER_PTS_IS_VALID (buffer) &amp;&amp; parse-&gt;priv-&gt;has_timing_info
2290         &amp;&amp; parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_PULL) {
2291       parse-&gt;priv-&gt;first_frame_offset = offset;
2292       parse-&gt;priv-&gt;first_frame_pts = GST_BUFFER_PTS (buffer);
2293       parse-&gt;priv-&gt;first_frame_dts = GST_BUFFER_DTS (buffer);
2294       GST_DEBUG_OBJECT (parse, &quot;subclass provided dts %&quot; GST_TIME_FORMAT
2295           &quot;, pts %&quot; GST_TIME_FORMAT &quot; for first frame at offset %&quot;
2296           G_GINT64_FORMAT, GST_TIME_ARGS (parse-&gt;priv-&gt;first_frame_dts),
2297           GST_TIME_ARGS (parse-&gt;priv-&gt;first_frame_pts),
2298           parse-&gt;priv-&gt;first_frame_offset);
2299       if (!GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;duration)) {
2300         gint64 off;
2301         GstClockTime last_ts = G_MAXINT64;
2302 
2303         GST_DEBUG_OBJECT (parse, &quot;no duration; trying scan to determine&quot;);
2304         gst_base_parse_locate_time (parse, &amp;last_ts, &amp;off);
2305         if (GST_CLOCK_TIME_IS_VALID (last_ts))
2306           gst_base_parse_set_duration (parse, GST_FORMAT_TIME, last_ts, 0);
2307       }
2308     } else {
2309       /* disable further checks */
2310       parse-&gt;priv-&gt;first_frame_offset = 0;
2311     }
2312   }
2313 
2314   /* track upstream time if provided, not subclass&#39; internal notion of it */
2315   if (parse-&gt;priv-&gt;upstream_format == GST_FORMAT_TIME) {
2316     GST_BUFFER_PTS (frame-&gt;buffer) = GST_CLOCK_TIME_NONE;
2317     GST_BUFFER_DTS (frame-&gt;buffer) = GST_CLOCK_TIME_NONE;
2318   }
2319 
2320   /* interpolating and no valid pts yet,
2321    * start with dts and carry on from there */
2322   if (parse-&gt;priv-&gt;infer_ts &amp;&amp; parse-&gt;priv-&gt;pts_interpolate
2323       &amp;&amp; !GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;next_pts))
2324     parse-&gt;priv-&gt;next_pts = parse-&gt;priv-&gt;next_dts;
2325 
2326   /* again use default handler to add missing metadata;
2327    * we may have new information on frame properties */
2328   gst_base_parse_parse_frame (parse, frame);
2329 
2330   parse-&gt;priv-&gt;next_pts = GST_CLOCK_TIME_NONE;
2331   if (GST_BUFFER_DTS_IS_VALID (buffer) &amp;&amp; GST_BUFFER_DURATION_IS_VALID (buffer)) {
2332     parse-&gt;priv-&gt;next_dts =
2333         GST_BUFFER_DTS (buffer) + GST_BUFFER_DURATION (buffer);
2334     if (parse-&gt;priv-&gt;pts_interpolate &amp;&amp; GST_BUFFER_PTS_IS_VALID (buffer)) {
2335       GstClockTime next_pts =
2336           GST_BUFFER_PTS (buffer) + GST_BUFFER_DURATION (buffer);
2337       if (next_pts &gt;= parse-&gt;priv-&gt;next_dts)
2338         parse-&gt;priv-&gt;next_pts = next_pts;
2339     }
2340   } else {
2341     /* we lost track, do not produce bogus time next time around
2342      * (probably means parser subclass has given up on parsing as well) */
2343     GST_DEBUG_OBJECT (parse, &quot;no next fallback timestamp&quot;);
2344     parse-&gt;priv-&gt;next_dts = GST_CLOCK_TIME_NONE;
2345   }
2346 
2347   if (parse-&gt;priv-&gt;upstream_seekable &amp;&amp; parse-&gt;priv-&gt;exact_position &amp;&amp;
2348       GST_BUFFER_PTS_IS_VALID (buffer))
2349     gst_base_parse_add_index_entry (parse, offset,
2350         GST_BUFFER_PTS (buffer),
2351         !GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DELTA_UNIT), FALSE);
2352 
2353   /* All OK, push queued frames if there are any */
2354   if (G_UNLIKELY (!g_queue_is_empty (&amp;parse-&gt;priv-&gt;queued_frames))) {
2355     GstBaseParseFrame *queued_frame;
2356 
2357     while ((queued_frame = g_queue_pop_head (&amp;parse-&gt;priv-&gt;queued_frames))) {
2358       gst_base_parse_push_frame (parse, queued_frame);
2359       gst_base_parse_frame_free (queued_frame);
2360     }
2361   }
2362 
2363   return gst_base_parse_push_frame (parse, frame);
2364 }
2365 
2366 /**
2367  * gst_base_parse_push_frame:
2368  * @parse: #GstBaseParse.
2369  * @frame: (transfer none): a #GstBaseParseFrame
2370  *
2371  * Pushes the frame&#39;s buffer downstream, sends any pending events and
2372  * does some timestamp and segment handling. Takes ownership of
2373  * frame&#39;s buffer, though caller retains ownership of @frame.
2374  *
2375  * This must be called with sinkpad STREAM_LOCK held.
2376  *
2377  * Returns: #GstFlowReturn
2378  */
2379 GstFlowReturn
2380 gst_base_parse_push_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
2381 {
2382   GstFlowReturn ret = GST_FLOW_OK;
2383   GstClockTime last_start = GST_CLOCK_TIME_NONE;
2384   GstClockTime last_stop = GST_CLOCK_TIME_NONE;
2385   GstBaseParseClass *klass = GST_BASE_PARSE_GET_CLASS (parse);
2386   GstBuffer *buffer;
2387   gsize size;
2388 
2389   g_return_val_if_fail (frame != NULL, GST_FLOW_ERROR);
2390   g_return_val_if_fail (frame-&gt;buffer != NULL, GST_FLOW_ERROR);
2391 
2392   GST_TRACE_OBJECT (parse, &quot;pushing frame %p&quot;, frame);
2393 
2394   buffer = frame-&gt;buffer;
2395 
2396   GST_LOG_OBJECT (parse,
2397       &quot;processing buffer of size %&quot; G_GSIZE_FORMAT &quot; with dts %&quot; GST_TIME_FORMAT
2398       &quot;, pts %&quot; GST_TIME_FORMAT &quot;, duration %&quot; GST_TIME_FORMAT,
2399       gst_buffer_get_size (buffer),
2400       GST_TIME_ARGS (GST_BUFFER_DTS (buffer)),
2401       GST_TIME_ARGS (GST_BUFFER_PTS (buffer)),
2402       GST_TIME_ARGS (GST_BUFFER_DURATION (buffer)));
2403 
2404   /* update stats */
2405   parse-&gt;priv-&gt;bytecount += frame-&gt;size;
2406   if (G_LIKELY (!(frame-&gt;flags &amp; GST_BASE_PARSE_FRAME_FLAG_NO_FRAME))) {
2407     parse-&gt;priv-&gt;framecount++;
2408     if (GST_BUFFER_DURATION_IS_VALID (buffer)) {
2409       parse-&gt;priv-&gt;acc_duration += GST_BUFFER_DURATION (buffer);
2410     }
2411   }
2412   /* 0 means disabled */
2413   if (parse-&gt;priv-&gt;update_interval &lt; 0)
2414     parse-&gt;priv-&gt;update_interval = 50;
2415   else if (parse-&gt;priv-&gt;update_interval &gt; 0 &amp;&amp;
2416       (parse-&gt;priv-&gt;framecount % parse-&gt;priv-&gt;update_interval) == 0)
2417     gst_base_parse_update_duration (parse);
2418 
2419   if (GST_BUFFER_PTS_IS_VALID (buffer))
2420     last_start = last_stop = GST_BUFFER_PTS (buffer);
2421   if (last_start != GST_CLOCK_TIME_NONE
2422       &amp;&amp; GST_BUFFER_DURATION_IS_VALID (buffer))
2423     last_stop = last_start + GST_BUFFER_DURATION (buffer);
2424 
2425   /* should have caps by now */
2426   if (!gst_pad_has_current_caps (parse-&gt;srcpad))
2427     goto no_caps;
2428 
2429   if (G_UNLIKELY (!parse-&gt;priv-&gt;checked_media)) {
2430     /* have caps; check identity */
2431     gst_base_parse_check_media (parse);
2432   }
2433 
2434   if (parse-&gt;priv-&gt;tags_changed) {
2435     gst_base_parse_queue_tag_event_update (parse);
2436     parse-&gt;priv-&gt;tags_changed = FALSE;
2437   }
2438 
2439   /* Push pending events, including SEGMENT events */
2440   gst_base_parse_push_pending_events (parse);
2441 
2442   /* segment adjustment magic; only if we are running the whole show */
2443   if (!parse-&gt;priv-&gt;passthrough &amp;&amp; parse-&gt;segment.rate &gt; 0.0 &amp;&amp;
2444       (parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_PULL ||
2445           parse-&gt;priv-&gt;upstream_seekable)) {
2446     /* handle gaps */
2447     if (GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.position) &amp;&amp;
2448         GST_CLOCK_TIME_IS_VALID (last_start)) {
2449       GstClockTimeDiff diff;
2450 
2451       /* only send newsegments with increasing start times,
2452        * otherwise if these go back and forth downstream (sinks) increase
2453        * accumulated time and running_time */
2454       diff = GST_CLOCK_DIFF (parse-&gt;segment.position, last_start);
2455       if (G_UNLIKELY (diff &gt; 2 * GST_SECOND
2456               &amp;&amp; last_start &gt; parse-&gt;segment.start
2457               &amp;&amp; (!GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.stop)
2458                   || last_start &lt; parse-&gt;segment.stop))) {
2459 
2460         GST_DEBUG_OBJECT (parse,
2461             &quot;Gap of %&quot; G_GINT64_FORMAT &quot; ns detected in stream &quot; &quot;(%&quot;
2462             GST_TIME_FORMAT &quot; -&gt; %&quot; GST_TIME_FORMAT &quot;). &quot;
2463             &quot;Sending updated SEGMENT events&quot;, diff,
2464             GST_TIME_ARGS (parse-&gt;segment.position),
2465             GST_TIME_ARGS (last_start));
2466 
2467         /* skip gap FIXME */
2468           gst_pad_push_event (parse-&gt;srcpad,
2469             gst_event_new_segment (&amp;parse-&gt;segment));
2470 
2471         parse-&gt;segment.position = last_start;
2472         }
2473       }
2474     }
2475 
2476   /* update bitrates and optionally post corresponding tags
2477    * (following newsegment) */
2478   gst_base_parse_update_bitrates (parse, frame);
2479 
2480   if (klass-&gt;pre_push_frame) {
2481     ret = klass-&gt;pre_push_frame (parse, frame);
2482   } else {
2483     frame-&gt;flags |= GST_BASE_PARSE_FRAME_FLAG_CLIP;
2484   }
2485 
2486   /* Push pending events, if there are any new ones
2487    * like tags added by pre_push_frame */
2488   if (parse-&gt;priv-&gt;tags_changed) {
2489     gst_base_parse_queue_tag_event_update (parse);
2490     parse-&gt;priv-&gt;tags_changed = FALSE;
2491   }
2492   gst_base_parse_push_pending_events (parse);
2493 
2494   /* take final ownership of frame buffer */
2495   if (frame-&gt;out_buffer) {
2496     buffer = frame-&gt;out_buffer;
2497     frame-&gt;out_buffer = NULL;
2498     gst_buffer_replace (&amp;frame-&gt;buffer, NULL);
2499   } else {
2500   buffer = frame-&gt;buffer;
2501   frame-&gt;buffer = NULL;
2502   }
2503 
2504   /* subclass must play nice */
2505   g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
2506 
2507   size = gst_buffer_get_size (buffer);
2508 
2509   parse-&gt;priv-&gt;seen_keyframe |= parse-&gt;priv-&gt;is_video &amp;&amp;
2510       !GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DELTA_UNIT);
2511 
2512   if (frame-&gt;flags &amp; GST_BASE_PARSE_FRAME_FLAG_CLIP) {
2513     if (GST_BUFFER_TIMESTAMP_IS_VALID (buffer) &amp;&amp;
2514         GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.stop) &amp;&amp;
2515         GST_BUFFER_TIMESTAMP (buffer) &gt;
2516         parse-&gt;segment.stop + parse-&gt;priv-&gt;lead_out_ts) {
2517       GST_LOG_OBJECT (parse, &quot;Dropped frame, after segment&quot;);
2518       ret = GST_FLOW_EOS;
2519     } else if (GST_BUFFER_TIMESTAMP_IS_VALID (buffer) &amp;&amp;
2520         GST_BUFFER_DURATION_IS_VALID (buffer) &amp;&amp;
2521         GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.start) &amp;&amp;
2522         GST_BUFFER_TIMESTAMP (buffer) + GST_BUFFER_DURATION (buffer) +
2523         parse-&gt;priv-&gt;lead_in_ts &lt; parse-&gt;segment.start) {
2524       if (parse-&gt;priv-&gt;seen_keyframe) {
2525         GST_LOG_OBJECT (parse, &quot;Frame before segment, after keyframe&quot;);
2526         ret = GST_FLOW_OK;
2527       } else {
2528         GST_LOG_OBJECT (parse, &quot;Dropped frame, before segment&quot;);
2529         ret = GST_BASE_PARSE_FLOW_DROPPED;
2530       }
2531     } else {
2532       ret = GST_FLOW_OK;
2533     }
2534   }
2535 
2536   if (ret == GST_BASE_PARSE_FLOW_DROPPED) {
2537     GST_LOG_OBJECT (parse, &quot;frame (%&quot; G_GSIZE_FORMAT &quot; bytes) dropped&quot;, size);
2538     if (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT))
2539       parse-&gt;priv-&gt;discont = TRUE;
2540     gst_buffer_unref (buffer);
2541     ret = GST_FLOW_OK;
2542   } else if (ret == GST_FLOW_OK) {
2543     if (parse-&gt;segment.rate &gt; 0.0) {
2544       GST_LOG_OBJECT (parse, &quot;pushing frame (%&quot; G_GSIZE_FORMAT &quot; bytes) now..&quot;,
2545           size);
2546       ret = gst_pad_push (parse-&gt;srcpad, buffer);
2547       GST_LOG_OBJECT (parse, &quot;frame pushed, flow %s&quot;, gst_flow_get_name (ret));
2548     } else if (!parse-&gt;priv-&gt;disable_passthrough &amp;&amp; parse-&gt;priv-&gt;passthrough) {
2549 
2550       /* in backwards playback mode, if on passthrough we need to push buffers
2551        * directly without accumulating them into the buffers_queued as baseparse
2552        * will never check for a DISCONT while on passthrough and those buffers
2553        * will never be pushed.
2554        *
2555        * also, as we are on reverse playback, it might be possible that
2556        * passthrough might have just been enabled, so make sure to drain the
2557        * buffers_queued list */
2558       if (G_UNLIKELY (parse-&gt;priv-&gt;buffers_queued != NULL)) {
2559         gst_base_parse_finish_fragment (parse, TRUE);
2560         ret = gst_base_parse_send_buffers (parse);
2561       }
2562 
2563       if (ret == GST_FLOW_OK) {
2564         GST_LOG_OBJECT (parse,
2565             &quot;pushing frame (%&quot; G_GSIZE_FORMAT &quot; bytes) now..&quot;, size);
2566         ret = gst_pad_push (parse-&gt;srcpad, buffer);
2567         GST_LOG_OBJECT (parse, &quot;frame pushed, flow %s&quot;,
2568             gst_flow_get_name (ret));
2569     } else {
2570         GST_LOG_OBJECT (parse,
2571             &quot;frame (%&quot; G_GSIZE_FORMAT &quot; bytes) not pushed: %s&quot;, size,
2572             gst_flow_get_name (ret));
2573         gst_buffer_unref (buffer);
2574       }
2575 
2576     } else {
2577       GST_LOG_OBJECT (parse, &quot;frame (%&quot; G_GSIZE_FORMAT &quot; bytes) queued for now&quot;,
2578           size);
2579       parse-&gt;priv-&gt;buffers_queued =
2580           g_slist_prepend (parse-&gt;priv-&gt;buffers_queued, buffer);
2581       ret = GST_FLOW_OK;
2582     }
2583   } else {
2584     GST_LOG_OBJECT (parse, &quot;frame (%&quot; G_GSIZE_FORMAT &quot; bytes) not pushed: %s&quot;,
2585         size, gst_flow_get_name (ret));
2586     gst_buffer_unref (buffer);
2587     /* if we are not sufficiently in control, let upstream decide on EOS */
2588     if (ret == GST_FLOW_EOS &amp;&amp; !parse-&gt;priv-&gt;disable_passthrough &amp;&amp;
2589         (parse-&gt;priv-&gt;passthrough ||
2590             (parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_PUSH &amp;&amp;
2591                 !parse-&gt;priv-&gt;upstream_seekable)))
2592       ret = GST_FLOW_OK;
2593   }
2594 
2595   /* Update current running segment position */
2596   if ((ret == GST_FLOW_OK || ret == GST_FLOW_NOT_LINKED)
2597       &amp;&amp; last_stop != GST_CLOCK_TIME_NONE
2598       &amp;&amp; parse-&gt;segment.position &lt; last_stop)
2599     parse-&gt;segment.position = last_stop;
2600 
2601   return ret;
2602 
2603   /* ERRORS */
2604 no_caps:
2605   {
2606     if (GST_PAD_IS_FLUSHING (parse-&gt;srcpad))
2607       return GST_FLOW_FLUSHING;
2608 
2609     GST_ELEMENT_ERROR (parse, STREAM, DECODE, (&quot;No caps set&quot;), (NULL));
2610     return GST_FLOW_ERROR;
2611   }
2612 }
2613 
2614 /**
2615  * gst_base_parse_finish_frame:
2616  * @parse: a #GstBaseParse
2617  * @frame: a #GstBaseParseFrame
2618  * @size: consumed input data represented by frame
2619  *
2620  * Collects parsed data and pushes this downstream.
2621  * Source pad caps must be set when this is called.
2622  *
2623  * If @frame&#39;s out_buffer is set, that will be used as subsequent frame data.
2624  * Otherwise, @size samples will be taken from the input and used for output,
2625  * and the output&#39;s metadata (timestamps etc) will be taken as (optionally)
2626  * set by the subclass on @frame&#39;s (input) buffer (which is otherwise
2627  * ignored for any but the above purpose/information).
2628  *
2629  * Note that the latter buffer is invalidated by this call, whereas the
2630  * caller retains ownership of @frame.
2631  *
2632  * Returns: a #GstFlowReturn that should be escalated to caller (of caller)
2633  */
2634 GstFlowReturn
2635 gst_base_parse_finish_frame (GstBaseParse * parse, GstBaseParseFrame * frame,
2636     gint size)
2637 {
2638   GstFlowReturn ret = GST_FLOW_OK;
2639 
2640   g_return_val_if_fail (frame != NULL, GST_FLOW_ERROR);
2641   g_return_val_if_fail (frame-&gt;buffer != NULL, GST_FLOW_ERROR);
2642   g_return_val_if_fail (size &gt; 0 || frame-&gt;out_buffer, GST_FLOW_ERROR);
2643   g_return_val_if_fail (gst_adapter_available (parse-&gt;priv-&gt;adapter) &gt;= size,
2644       GST_FLOW_ERROR);
2645 
2646   GST_LOG_OBJECT (parse, &quot;finished frame at offset %&quot; G_GUINT64_FORMAT &quot;, &quot;
2647       &quot;flushing size %d&quot;, frame-&gt;offset, size);
2648 
2649   /* some one-time start-up */
2650   if (G_UNLIKELY (parse-&gt;priv-&gt;framecount == 0)) {
2651     gst_base_parse_check_seekability (parse);
2652     gst_base_parse_check_upstream (parse);
2653   }
2654 
2655   parse-&gt;priv-&gt;flushed += size;
2656 
2657   if (parse-&gt;priv-&gt;scanning &amp;&amp; frame-&gt;buffer) {
2658     if (!parse-&gt;priv-&gt;scanned_frame) {
2659       parse-&gt;priv-&gt;scanned_frame = gst_base_parse_frame_copy (frame);
2660     }
2661     goto exit;
2662   }
2663 
2664   /* either PUSH or PULL mode arranges for adapter data */
2665   /* ensure output buffer */
2666   if (!frame-&gt;out_buffer) {
2667     GstBuffer *src, *dest;
2668 
2669     frame-&gt;out_buffer = gst_adapter_take_buffer (parse-&gt;priv-&gt;adapter, size);
2670     dest = frame-&gt;out_buffer;
2671     src = frame-&gt;buffer;
2672     GST_BUFFER_PTS (dest) = GST_BUFFER_PTS (src);
2673     GST_BUFFER_DTS (dest) = GST_BUFFER_DTS (src);
2674     GST_BUFFER_OFFSET (dest) = GST_BUFFER_OFFSET (src);
2675     GST_BUFFER_DURATION (dest) = GST_BUFFER_DURATION (src);
2676     GST_BUFFER_OFFSET_END (dest) = GST_BUFFER_OFFSET_END (src);
2677     GST_MINI_OBJECT_FLAGS (dest) = GST_MINI_OBJECT_FLAGS (src);
2678   } else {
2679     gst_adapter_flush (parse-&gt;priv-&gt;adapter, size);
2680   }
2681 
2682   /* use as input for subsequent processing */
2683   gst_buffer_replace (&amp;frame-&gt;buffer, frame-&gt;out_buffer);
2684   gst_buffer_unref (frame-&gt;out_buffer);
2685   frame-&gt;out_buffer = NULL;
2686 
2687   /* mark input size consumed */
2688   frame-&gt;size = size;
2689 
2690   /* subclass might queue frames/data internally if it needs more
2691    * frames to decide on the format, or might request us to queue here. */
2692   if (frame-&gt;flags &amp; GST_BASE_PARSE_FRAME_FLAG_DROP) {
2693     gst_buffer_replace (&amp;frame-&gt;buffer, NULL);
2694     goto exit;
2695   } else if (frame-&gt;flags &amp; GST_BASE_PARSE_FRAME_FLAG_QUEUE) {
2696     GstBaseParseFrame *copy;
2697 
2698     copy = gst_base_parse_frame_copy (frame);
2699     copy-&gt;flags &amp;= ~GST_BASE_PARSE_FRAME_FLAG_QUEUE;
2700     gst_base_parse_queue_frame (parse, copy);
2701     goto exit;
2702   }
2703 
2704   ret = gst_base_parse_handle_and_push_frame (parse, frame);
2705 
2706 exit:
2707   return ret;
2708 }
2709 
2710 /**
2711  * gst_base_parse_drain:
2712  * @parse: a #GstBaseParse
2713  *
2714  * Drains the adapter until it is empty. It decreases the min_frame_size to
2715  * match the current adapter size and calls chain method until the adapter
2716  * is emptied or chain returns with error.
2717  *
2718  * Since: 1.12
2719  */
2720 void
2721 gst_base_parse_drain (GstBaseParse * parse)
2722 {
2723   guint avail;
2724 
2725   GST_DEBUG_OBJECT (parse, &quot;draining&quot;);
2726   parse-&gt;priv-&gt;drain = TRUE;
2727 
2728   for (;;) {
2729     avail = gst_adapter_available (parse-&gt;priv-&gt;adapter);
2730     if (!avail)
2731       break;
2732 
2733     if (gst_base_parse_chain (parse-&gt;sinkpad, GST_OBJECT_CAST (parse),
2734             NULL) != GST_FLOW_OK) {
2735       break;
2736     }
2737 
2738     /* nothing changed, maybe due to truncated frame; break infinite loop */
2739     if (avail == gst_adapter_available (parse-&gt;priv-&gt;adapter)) {
2740       GST_DEBUG_OBJECT (parse, &quot;no change during draining; flushing&quot;);
2741       gst_adapter_clear (parse-&gt;priv-&gt;adapter);
2742     }
2743   }
2744 
2745   parse-&gt;priv-&gt;drain = FALSE;
2746 }
2747 
2748 /* gst_base_parse_send_buffers
2749  *
2750  * Sends buffers collected in send_buffers downstream, and ensures that list
2751  * is empty at the end (errors or not).
2752  */
2753 static GstFlowReturn
2754 gst_base_parse_send_buffers (GstBaseParse * parse)
2755 {
2756   GSList *send = NULL;
2757   GstBuffer *buf;
2758   GstFlowReturn ret = GST_FLOW_OK;
2759   gboolean first = TRUE;
2760 
2761   send = parse-&gt;priv-&gt;buffers_send;
2762 
2763   /* send buffers */
2764   while (send) {
2765     buf = GST_BUFFER_CAST (send-&gt;data);
2766     GST_LOG_OBJECT (parse, &quot;pushing buffer %p, dts %&quot;
2767         GST_TIME_FORMAT &quot;, pts %&quot; GST_TIME_FORMAT &quot;, duration %&quot; GST_TIME_FORMAT
2768         &quot;, offset %&quot; G_GINT64_FORMAT, buf,
2769         GST_TIME_ARGS (GST_BUFFER_DTS (buf)),
2770         GST_TIME_ARGS (GST_BUFFER_PTS (buf)),
2771         GST_TIME_ARGS (GST_BUFFER_DURATION (buf)), GST_BUFFER_OFFSET (buf));
2772 
2773     /* Make sure the first buffer is always DISCONT. If we split
2774      * GOPs inside the parser this is otherwise not guaranteed */
2775     if (first) {
2776       GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);
2777       first = FALSE;
2778     } else {
2779       /* likewise, subsequent buffers should never have DISCONT
2780        * according to the &quot;reverse fragment protocol&quot;, or such would
2781        * confuse a downstream decoder
2782        * (could be DISCONT due to aggregating upstream fragments by parsing) */
2783       GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DISCONT);
2784     }
2785 
2786     /* iterate output queue an push downstream */
2787     ret = gst_pad_push (parse-&gt;srcpad, buf);
2788     send = g_slist_delete_link (send, send);
2789 
2790     /* clear any leftover if error */
2791     if (G_UNLIKELY (ret != GST_FLOW_OK)) {
2792       while (send) {
2793         buf = GST_BUFFER_CAST (send-&gt;data);
2794         gst_buffer_unref (buf);
2795         send = g_slist_delete_link (send, send);
2796       }
2797     }
2798   }
2799 
2800   parse-&gt;priv-&gt;buffers_send = send;
2801 
2802   return ret;
2803 }
2804 
2805 /* gst_base_parse_start_fragment:
2806  *
2807  * Prepares for processing a reverse playback (forward) fragment
2808  * by (re)setting proper state variables.
2809  */
2810 static GstFlowReturn
2811 gst_base_parse_start_fragment (GstBaseParse * parse)
2812 {
2813   GST_LOG_OBJECT (parse, &quot;starting fragment&quot;);
2814 
2815   /* invalidate so no fall-back timestamping is performed;
2816    * ok if taken from subclass or upstream */
2817   parse-&gt;priv-&gt;next_pts = GST_CLOCK_TIME_NONE;
2818   parse-&gt;priv-&gt;prev_pts = GST_CLOCK_TIME_NONE;
2819   parse-&gt;priv-&gt;next_dts = GST_CLOCK_TIME_NONE;
2820   parse-&gt;priv-&gt;prev_dts = GST_CLOCK_TIME_NONE;
2821   parse-&gt;priv-&gt;prev_dts_from_pts = FALSE;
2822   /* prevent it hanging around stop all the time */
2823   parse-&gt;segment.position = GST_CLOCK_TIME_NONE;
2824   /* mark next run */
2825   parse-&gt;priv-&gt;discont = TRUE;
2826 
2827   /* head of previous fragment is now pending tail of current fragment */
2828   parse-&gt;priv-&gt;buffers_pending = parse-&gt;priv-&gt;buffers_head;
2829   parse-&gt;priv-&gt;buffers_head = NULL;
2830 
2831   return GST_FLOW_OK;
2832 }
2833 
2834 
2835 /* gst_base_parse_finish_fragment:
2836  *
2837  * Processes a reverse playback (forward) fragment:
2838  * - append head of last fragment that was skipped to current fragment data
2839  * - drain the resulting current fragment data (i.e. repeated chain)
2840  * - add time/duration (if needed) to frames queued by chain
2841  * - push queued data
2842  */
2843 static GstFlowReturn
2844 gst_base_parse_finish_fragment (GstBaseParse * parse, gboolean prev_head)
2845 {
2846   GstBuffer *buf;
2847   GstFlowReturn ret = GST_FLOW_OK;
2848   gboolean seen_key = FALSE, seen_delta = FALSE;
2849 
2850   GST_LOG_OBJECT (parse, &quot;finishing fragment&quot;);
2851 
2852   /* restore order */
2853   parse-&gt;priv-&gt;buffers_pending = g_slist_reverse (parse-&gt;priv-&gt;buffers_pending);
2854   while (parse-&gt;priv-&gt;buffers_pending) {
2855     buf = GST_BUFFER_CAST (parse-&gt;priv-&gt;buffers_pending-&gt;data);
2856     if (prev_head) {
2857       GST_LOG_OBJECT (parse, &quot;adding pending buffer (size %&quot; G_GSIZE_FORMAT &quot;)&quot;,
2858           gst_buffer_get_size (buf));
2859     gst_adapter_push (parse-&gt;priv-&gt;adapter, buf);
2860     } else {
2861       GST_LOG_OBJECT (parse, &quot;discarding head buffer&quot;);
2862       gst_buffer_unref (buf);
2863     }
2864     parse-&gt;priv-&gt;buffers_pending =
2865         g_slist_delete_link (parse-&gt;priv-&gt;buffers_pending,
2866         parse-&gt;priv-&gt;buffers_pending);
2867   }
2868 
2869   /* chain looks for frames and queues resulting ones (in stead of pushing) */
2870   /* initial skipped data is added to buffers_pending */
2871   gst_base_parse_drain (parse);
2872 
2873   if (parse-&gt;priv-&gt;buffers_send) {
2874     buf = GST_BUFFER_CAST (parse-&gt;priv-&gt;buffers_send-&gt;data);
2875     seen_key |= !GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
2876   }
2877 
2878   /* add metadata (if needed to queued buffers */
2879   GST_LOG_OBJECT (parse, &quot;last timestamp: %&quot; GST_TIME_FORMAT,
2880       GST_TIME_ARGS (parse-&gt;priv-&gt;last_pts));
2881   while (parse-&gt;priv-&gt;buffers_queued) {
2882     buf = GST_BUFFER_CAST (parse-&gt;priv-&gt;buffers_queued-&gt;data);
2883 
2884     /* no touching if upstream or parsing provided time */
2885     if (GST_BUFFER_PTS_IS_VALID (buf)) {
2886       GST_LOG_OBJECT (parse, &quot;buffer has time %&quot; GST_TIME_FORMAT,
2887           GST_TIME_ARGS (GST_BUFFER_PTS (buf)));
2888     } else if (GST_BUFFER_DURATION_IS_VALID (buf)) {
2889       if (GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;last_pts)) {
2890         if (G_LIKELY (GST_BUFFER_DURATION (buf) &lt;= parse-&gt;priv-&gt;last_pts))
2891           parse-&gt;priv-&gt;last_pts -= GST_BUFFER_DURATION (buf);
2892       else
2893           parse-&gt;priv-&gt;last_pts = 0;
2894         GST_BUFFER_PTS (buf) = parse-&gt;priv-&gt;last_pts;
2895       GST_LOG_OBJECT (parse, &quot;applied time %&quot; GST_TIME_FORMAT,
2896             GST_TIME_ARGS (GST_BUFFER_PTS (buf)));
2897       }
2898       if (GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;last_dts)) {
2899         if (G_LIKELY (GST_BUFFER_DURATION (buf) &lt;= parse-&gt;priv-&gt;last_dts))
2900           parse-&gt;priv-&gt;last_dts -= GST_BUFFER_DURATION (buf);
2901         else
2902           parse-&gt;priv-&gt;last_dts = 0;
2903         GST_BUFFER_DTS (buf) = parse-&gt;priv-&gt;last_dts;
2904         GST_LOG_OBJECT (parse, &quot;applied dts %&quot; GST_TIME_FORMAT,
2905             GST_TIME_ARGS (GST_BUFFER_DTS (buf)));
2906       }
2907     } else {
2908       /* no idea, very bad */
2909       GST_WARNING_OBJECT (parse, &quot;could not determine time for buffer&quot;);
2910     }
2911 
2912     parse-&gt;priv-&gt;last_pts = GST_BUFFER_PTS (buf);
2913     parse-&gt;priv-&gt;last_dts = GST_BUFFER_DTS (buf);
2914 
2915     /* reverse order for ascending sending */
2916     /* send downstream at keyframe not preceded by a keyframe
2917      * (e.g. that should identify start of collection of IDR nals) */
2918     if (GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT)) {
2919       if (seen_key) {
2920         ret = gst_base_parse_send_buffers (parse);
2921         /* if a problem, throw all to sending */
2922         if (ret != GST_FLOW_OK) {
2923           parse-&gt;priv-&gt;buffers_send =
2924               g_slist_reverse (parse-&gt;priv-&gt;buffers_queued);
2925           parse-&gt;priv-&gt;buffers_queued = NULL;
2926           break;
2927         }
2928         seen_key = FALSE;
2929       }
2930       seen_delta = TRUE;
2931     } else {
2932       seen_key = TRUE;
2933     }
2934 
2935     parse-&gt;priv-&gt;buffers_send =
2936         g_slist_prepend (parse-&gt;priv-&gt;buffers_send, buf);
2937     parse-&gt;priv-&gt;buffers_queued =
2938         g_slist_delete_link (parse-&gt;priv-&gt;buffers_queued,
2939         parse-&gt;priv-&gt;buffers_queued);
2940   }
2941 
2942   /* audio may have all marked as keyframe, so arrange to send here. Also
2943    * we might have ended the loop above on a keyframe, in which case we
2944    * should */
2945   if (!seen_delta || seen_key)
2946     ret = gst_base_parse_send_buffers (parse);
2947 
2948   /* any trailing unused no longer usable (ideally none) */
2949   if (G_UNLIKELY (gst_adapter_available (parse-&gt;priv-&gt;adapter))) {
2950     GST_DEBUG_OBJECT (parse, &quot;discarding %&quot; G_GSIZE_FORMAT &quot; trailing bytes&quot;,
2951         gst_adapter_available (parse-&gt;priv-&gt;adapter));
2952     gst_adapter_clear (parse-&gt;priv-&gt;adapter);
2953   }
2954 
2955   return ret;
2956 }
2957 
2958 /* small helper that checks whether we have been trying to resync too long */
2959 static inline GstFlowReturn
2960 gst_base_parse_check_sync (GstBaseParse * parse)
2961 {
2962   if (G_UNLIKELY (parse-&gt;priv-&gt;discont &amp;&amp;
2963           parse-&gt;priv-&gt;offset - parse-&gt;priv-&gt;sync_offset &gt; 2 * 1024 * 1024)) {
2964     GST_ELEMENT_ERROR (parse, STREAM, DECODE,
2965         (&quot;Failed to parse stream&quot;), (NULL));
2966     return GST_FLOW_ERROR;
2967   }
2968 
2969   return GST_FLOW_OK;
2970 }
2971 
2972 static GstFlowReturn
2973 gst_base_parse_process_streamheader (GstBaseParse * parse)
2974 {
2975   GstCaps *caps;
2976   GstStructure *str;
2977   const GValue *value;
2978   GstFlowReturn ret = GST_FLOW_OK;
2979 
2980   caps = gst_pad_get_current_caps (GST_BASE_PARSE_SINK_PAD (parse));
2981   if (caps == NULL)
2982     goto notfound;
2983 
2984   str = gst_caps_get_structure (caps, 0);
2985   value = gst_structure_get_value (str, &quot;streamheader&quot;);
2986   if (value == NULL)
2987     goto notfound;
2988 
2989   GST_DEBUG_OBJECT (parse, &quot;Found streamheader field on input caps&quot;);
2990 
2991   if (GST_VALUE_HOLDS_ARRAY (value)) {
2992     gint i;
2993     gsize len = gst_value_array_get_size (value);
2994 
2995     for (i = 0; i &lt; len; i++) {
2996       GstBuffer *buffer =
2997           gst_value_get_buffer (gst_value_array_get_value (value, i));
2998       ret =
2999           gst_base_parse_chain (GST_BASE_PARSE_SINK_PAD (parse),
3000           GST_OBJECT_CAST (parse), gst_buffer_ref (buffer));
3001     }
3002 
3003   } else if (GST_VALUE_HOLDS_BUFFER (value)) {
3004     GstBuffer *buffer = gst_value_get_buffer (value);
3005     ret =
3006         gst_base_parse_chain (GST_BASE_PARSE_SINK_PAD (parse),
3007         GST_OBJECT_CAST (parse), gst_buffer_ref (buffer));
3008   }
3009 
3010   gst_caps_unref (caps);
3011 
3012   return ret;
3013 
3014 notfound:
3015   {
3016     if (caps) {
3017       gst_caps_unref (caps);
3018     }
3019 
3020     GST_DEBUG_OBJECT (parse, &quot;No streamheader on caps&quot;);
3021     return GST_FLOW_OK;
3022   }
3023 }
3024 
3025 static GstFlowReturn
3026 gst_base_parse_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
3027 {
3028   GstBaseParseClass *bclass;
3029   GstBaseParse *parse;
3030   GstFlowReturn ret = GST_FLOW_OK;
3031   GstFlowReturn old_ret = GST_FLOW_OK;
3032   GstBuffer *tmpbuf = NULL;
3033   guint fsize = 1;
3034   gint skip = -1;
3035   guint min_size, av;
3036   GstClockTime pts, dts;
3037 
3038   parse = GST_BASE_PARSE (parent);
3039   bclass = GST_BASE_PARSE_GET_CLASS (parse);
3040   GST_DEBUG_OBJECT (parent, &quot;chain&quot;);
3041 
3042   /* early out for speed, if we need to skip */
3043   if (buffer &amp;&amp; GST_BUFFER_IS_DISCONT (buffer))
3044     parse-&gt;priv-&gt;skip = 0;
3045   if (parse-&gt;priv-&gt;skip &gt; 0) {
3046     gsize bsize = gst_buffer_get_size (buffer);
3047     GST_DEBUG (&quot;Got %&quot; G_GSIZE_FORMAT &quot; buffer, need to skip %u&quot;, bsize,
3048         parse-&gt;priv-&gt;skip);
3049     if (parse-&gt;priv-&gt;skip &gt;= bsize) {
3050       parse-&gt;priv-&gt;skip -= bsize;
3051       GST_DEBUG (&quot;All the buffer is skipped&quot;);
3052       parse-&gt;priv-&gt;offset += bsize;
3053       parse-&gt;priv-&gt;sync_offset = parse-&gt;priv-&gt;offset;
3054       return GST_FLOW_OK;
3055     }
3056     buffer = gst_buffer_make_writable (buffer);
3057     gst_buffer_resize (buffer, parse-&gt;priv-&gt;skip, bsize - parse-&gt;priv-&gt;skip);
3058     parse-&gt;priv-&gt;offset += parse-&gt;priv-&gt;skip;
3059     GST_DEBUG (&quot;Done skipping, we have %u left on this buffer&quot;,
3060         (unsigned) (bsize - parse-&gt;priv-&gt;skip));
3061     parse-&gt;priv-&gt;skip = 0;
3062     parse-&gt;priv-&gt;discont = TRUE;
3063   }
3064 
3065   if (G_UNLIKELY (parse-&gt;priv-&gt;first_buffer)) {
3066     parse-&gt;priv-&gt;first_buffer = FALSE;
3067     if (!GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_HEADER)) {
3068       /* this stream has no header buffers, check if we just prepend the
3069        * streamheader from caps to the stream */
3070       GST_DEBUG_OBJECT (parse, &quot;Looking for streamheader field on caps to &quot;
3071           &quot;prepend to the stream&quot;);
3072       gst_base_parse_process_streamheader (parse);
3073     } else {
3074       GST_DEBUG_OBJECT (parse, &quot;Stream has header buffers, not prepending &quot;
3075           &quot;streamheader from caps&quot;);
3076     }
3077   }
3078 
3079   if (parse-&gt;priv-&gt;detecting) {
3080     GstBuffer *detect_buf;
3081 
3082     if (parse-&gt;priv-&gt;detect_buffers_size == 0) {
3083       detect_buf = gst_buffer_ref (buffer);
3084     } else {
3085       GList *l;
3086       guint offset = 0;
3087 
3088       detect_buf = gst_buffer_new ();
3089 
3090       for (l = parse-&gt;priv-&gt;detect_buffers; l; l = l-&gt;next) {
3091         gsize tmpsize = gst_buffer_get_size (l-&gt;data);
3092 
3093         gst_buffer_copy_into (detect_buf, GST_BUFFER_CAST (l-&gt;data),
3094             GST_BUFFER_COPY_MEMORY, offset, tmpsize);
3095         offset += tmpsize;
3096       }
3097       if (buffer)
3098         gst_buffer_copy_into (detect_buf, buffer, GST_BUFFER_COPY_MEMORY,
3099             offset, gst_buffer_get_size (buffer));
3100     }
3101 
3102     ret = bclass-&gt;detect (parse, detect_buf);
3103     gst_buffer_unref (detect_buf);
3104 
3105     if (ret == GST_FLOW_OK) {
3106       GList *l;
3107 
3108       /* Detected something */
3109       parse-&gt;priv-&gt;detecting = FALSE;
3110 
3111       for (l = parse-&gt;priv-&gt;detect_buffers; l; l = l-&gt;next) {
3112         if (ret == GST_FLOW_OK &amp;&amp; !parse-&gt;priv-&gt;flushing)
3113           ret =
3114               gst_base_parse_chain (GST_BASE_PARSE_SINK_PAD (parse),
3115               parent, GST_BUFFER_CAST (l-&gt;data));
3116         else
3117           gst_buffer_unref (GST_BUFFER_CAST (l-&gt;data));
3118       }
3119       g_list_free (parse-&gt;priv-&gt;detect_buffers);
3120       parse-&gt;priv-&gt;detect_buffers = NULL;
3121       parse-&gt;priv-&gt;detect_buffers_size = 0;
3122 
3123       if (ret != GST_FLOW_OK) {
3124         return ret;
3125       }
3126 
3127       /* Handle the current buffer */
3128     } else if (ret == GST_FLOW_NOT_NEGOTIATED) {
3129       /* Still detecting, append buffer or error out if draining */
3130 
3131       if (parse-&gt;priv-&gt;drain) {
3132         GST_DEBUG_OBJECT (parse, &quot;Draining but did not detect format yet&quot;);
3133         return GST_FLOW_ERROR;
3134       } else if (parse-&gt;priv-&gt;flushing) {
3135         g_list_foreach (parse-&gt;priv-&gt;detect_buffers, (GFunc) gst_buffer_unref,
3136             NULL);
3137         g_list_free (parse-&gt;priv-&gt;detect_buffers);
3138         parse-&gt;priv-&gt;detect_buffers = NULL;
3139         parse-&gt;priv-&gt;detect_buffers_size = 0;
3140       } else {
3141         parse-&gt;priv-&gt;detect_buffers =
3142             g_list_append (parse-&gt;priv-&gt;detect_buffers, buffer);
3143         parse-&gt;priv-&gt;detect_buffers_size += gst_buffer_get_size (buffer);
3144         return GST_FLOW_OK;
3145       }
3146     } else {
3147       /* Something went wrong, subclass responsible for error reporting */
3148       return ret;
3149     }
3150 
3151     /* And now handle the current buffer if detection worked */
3152   }
3153 
3154   if (G_LIKELY (buffer)) {
3155     GST_LOG_OBJECT (parse,
3156         &quot;buffer size: %&quot; G_GSIZE_FORMAT &quot;, offset = %&quot; G_GINT64_FORMAT
3157         &quot;, dts %&quot; GST_TIME_FORMAT &quot;, pts %&quot; GST_TIME_FORMAT,
3158         gst_buffer_get_size (buffer), GST_BUFFER_OFFSET (buffer),
3159         GST_TIME_ARGS (GST_BUFFER_DTS (buffer)),
3160         GST_TIME_ARGS (GST_BUFFER_PTS (buffer)));
3161 
3162     if (G_UNLIKELY (!parse-&gt;priv-&gt;disable_passthrough
3163             &amp;&amp; parse-&gt;priv-&gt;passthrough)) {
3164       GstBaseParseFrame frame;
3165 
3166       gst_base_parse_frame_init (&amp;frame);
3167       frame.buffer = gst_buffer_make_writable (buffer);
3168       ret = gst_base_parse_push_frame (parse, &amp;frame);
3169       gst_base_parse_frame_free (&amp;frame);
3170       return ret;
3171     }
3172     if (G_UNLIKELY (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT))) {
3173     /* upstream feeding us in reverse playback;
3174      * finish previous fragment and start new upon DISCONT */
3175     if (parse-&gt;segment.rate &lt; 0.0) {
3176         GST_DEBUG_OBJECT (parse, &quot;buffer starts new reverse playback fragment&quot;);
3177         ret = gst_base_parse_finish_fragment (parse, TRUE);
3178         gst_base_parse_start_fragment (parse);
3179       } else {
3180         /* discont in the stream, drain and mark discont for next output */
3181         gst_base_parse_drain (parse);
3182         parse-&gt;priv-&gt;discont = TRUE;
3183       }
3184     }
3185     gst_adapter_push (parse-&gt;priv-&gt;adapter, buffer);
3186   }
3187 
3188   /* Parse and push as many frames as possible */
3189   /* Stop either when adapter is empty or we are flushing */
3190   while (!parse-&gt;priv-&gt;flushing) {
3191     gint flush = 0;
3192     gboolean updated_prev_pts = FALSE;
3193 
3194     /* note: if subclass indicates MAX fsize,
3195      * this will not likely be available anyway ... */
3196       min_size = MAX (parse-&gt;priv-&gt;min_frame_size, fsize);
3197       av = gst_adapter_available (parse-&gt;priv-&gt;adapter);
3198 
3199       if (G_UNLIKELY (parse-&gt;priv-&gt;drain)) {
3200         min_size = av;
3201         GST_DEBUG_OBJECT (parse, &quot;draining, data left: %d&quot;, min_size);
3202         if (G_UNLIKELY (!min_size)) {
3203           goto done;
3204         }
3205       }
3206 
3207       /* Collect at least min_frame_size bytes */
3208       if (av &lt; min_size) {
3209       GST_DEBUG_OBJECT (parse, &quot;not enough data available (only %d bytes)&quot;, av);
3210         goto done;
3211       }
3212 
3213     /* move along with upstream timestamp (if any),
3214      * but interpolate in between */
3215     pts = gst_adapter_prev_pts (parse-&gt;priv-&gt;adapter, NULL);
3216     dts = gst_adapter_prev_dts (parse-&gt;priv-&gt;adapter, NULL);
3217     if (GST_CLOCK_TIME_IS_VALID (pts) &amp;&amp; (parse-&gt;priv-&gt;prev_pts != pts)) {
3218       parse-&gt;priv-&gt;prev_pts = parse-&gt;priv-&gt;next_pts = pts;
3219       updated_prev_pts = TRUE;
3220     }
3221 
3222     if (GST_CLOCK_TIME_IS_VALID (dts) &amp;&amp; (parse-&gt;priv-&gt;prev_dts != dts)) {
3223       parse-&gt;priv-&gt;prev_dts = parse-&gt;priv-&gt;next_dts = dts;
3224       parse-&gt;priv-&gt;prev_dts_from_pts = FALSE;
3225     }
3226 
3227     /* we can mess with, erm interpolate, timestamps,
3228      * and incoming stuff has PTS but no DTS seen so far,
3229      * then pick up DTS from PTS and hope for the best ... */
3230     if (parse-&gt;priv-&gt;infer_ts &amp;&amp;
3231         parse-&gt;priv-&gt;pts_interpolate &amp;&amp;
3232         !GST_CLOCK_TIME_IS_VALID (dts) &amp;&amp;
3233         (!GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;prev_dts)
3234             || (parse-&gt;priv-&gt;prev_dts_from_pts &amp;&amp; updated_prev_pts))
3235         &amp;&amp; GST_CLOCK_TIME_IS_VALID (pts)) {
3236       parse-&gt;priv-&gt;prev_dts = parse-&gt;priv-&gt;next_dts = pts;
3237       parse-&gt;priv-&gt;prev_dts_from_pts = TRUE;
3238     }
3239 
3240       /* always pass all available data */
3241     tmpbuf = gst_adapter_get_buffer (parse-&gt;priv-&gt;adapter, av);
3242 
3243     /* already inform subclass what timestamps we have planned,
3244      * at least if provided by time-based upstream */
3245     if (parse-&gt;priv-&gt;upstream_format == GST_FORMAT_TIME) {
3246       tmpbuf = gst_buffer_make_writable (tmpbuf);
3247       GST_BUFFER_PTS (tmpbuf) = parse-&gt;priv-&gt;next_pts;
3248       GST_BUFFER_DTS (tmpbuf) = parse-&gt;priv-&gt;next_dts;
3249       GST_BUFFER_DURATION (tmpbuf) = GST_CLOCK_TIME_NONE;
3250       }
3251 
3252     /* keep the adapter mapped, so keep track of what has to be flushed */
3253     ret = gst_base_parse_handle_buffer (parse, tmpbuf, &amp;skip, &amp;flush);
3254     tmpbuf = NULL;
3255 
3256     if (ret != GST_FLOW_OK &amp;&amp; ret != GST_FLOW_NOT_LINKED) {
3257           goto done;
3258         }
3259     if (skip == 0 &amp;&amp; flush == 0) {
3260       GST_LOG_OBJECT (parse, &quot;nothing skipped and no frames finished, &quot;
3261           &quot;breaking to get more data&quot;);
3262       /* ignore this return as it produced no data */
3263       ret = old_ret;
3264         goto done;
3265       }
3266     if (old_ret == GST_FLOW_OK)
3267     old_ret = ret;
3268     }
3269 
3270 done:
3271   GST_LOG_OBJECT (parse, &quot;chain leaving&quot;);
3272   return ret;
3273 }
3274 
3275 /* pull @size bytes at current offset,
3276  * i.e. at least try to and possibly return a shorter buffer if near the end */
3277 static GstFlowReturn
3278 gst_base_parse_pull_range (GstBaseParse * parse, guint size,
3279     GstBuffer ** buffer)
3280 {
3281   GstFlowReturn ret = GST_FLOW_OK;
3282 
3283   g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
3284 
3285   /* Caching here actually makes much less difference than one would expect.
3286    * We do it mainly to avoid pulling buffers of 1 byte all the time */
3287   if (parse-&gt;priv-&gt;cache) {
3288     gint64 cache_offset = GST_BUFFER_OFFSET (parse-&gt;priv-&gt;cache);
3289     gint cache_size = gst_buffer_get_size (parse-&gt;priv-&gt;cache);
3290 
3291     if (cache_offset &lt;= parse-&gt;priv-&gt;offset &amp;&amp;
3292         (parse-&gt;priv-&gt;offset + size) &lt;= (cache_offset + cache_size)) {
3293       *buffer = gst_buffer_copy_region (parse-&gt;priv-&gt;cache, GST_BUFFER_COPY_ALL,
3294           parse-&gt;priv-&gt;offset - cache_offset, size);
3295 #ifdef GSTREAMER_LITE
3296       if (buffer == NULL)
3297         return GST_FLOW_ERROR;
3298 #endif // GSTREAMER_LITE
3299       GST_BUFFER_OFFSET (*buffer) = parse-&gt;priv-&gt;offset;
3300       return GST_FLOW_OK;
3301     }
3302     /* not enough data in the cache, free cache and get a new one */
3303     gst_buffer_unref (parse-&gt;priv-&gt;cache);
3304     parse-&gt;priv-&gt;cache = NULL;
3305   }
3306 
3307   /* refill the cache */
3308   ret =
3309       gst_pad_pull_range (parse-&gt;sinkpad, parse-&gt;priv-&gt;offset, MAX (size,
3310           64 * 1024), &amp;parse-&gt;priv-&gt;cache);
3311   if (ret != GST_FLOW_OK) {
3312     parse-&gt;priv-&gt;cache = NULL;
3313     return ret;
3314   }
3315 
3316   if (gst_buffer_get_size (parse-&gt;priv-&gt;cache) &gt;= size) {
3317     *buffer =
3318         gst_buffer_copy_region (parse-&gt;priv-&gt;cache, GST_BUFFER_COPY_ALL, 0,
3319         size);
3320 #ifdef GSTREAMER_LITE
3321     if (buffer == NULL)
3322       return GST_FLOW_ERROR;
3323 #endif // GSTREAMER_LITE
3324     GST_BUFFER_OFFSET (*buffer) = parse-&gt;priv-&gt;offset;
3325     return GST_FLOW_OK;
3326   }
3327 
3328   /* Not possible to get enough data, try a last time with
3329    * requesting exactly the size we need */
3330   gst_buffer_unref (parse-&gt;priv-&gt;cache);
3331   parse-&gt;priv-&gt;cache = NULL;
3332 
3333   ret = gst_pad_pull_range (parse-&gt;sinkpad, parse-&gt;priv-&gt;offset, size,
3334       &amp;parse-&gt;priv-&gt;cache);
3335 
3336   if (ret != GST_FLOW_OK) {
3337     GST_DEBUG_OBJECT (parse, &quot;pull_range returned %d&quot;, ret);
3338     *buffer = NULL;
3339     return ret;
3340   }
3341 
3342   if (gst_buffer_get_size (parse-&gt;priv-&gt;cache) &lt; size) {
3343     GST_DEBUG_OBJECT (parse, &quot;Returning short buffer at offset %&quot;
3344         G_GUINT64_FORMAT &quot;: wanted %u bytes, got %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
3345         parse-&gt;priv-&gt;offset, size, gst_buffer_get_size (parse-&gt;priv-&gt;cache));
3346 
3347     *buffer = parse-&gt;priv-&gt;cache;
3348     parse-&gt;priv-&gt;cache = NULL;
3349 
3350     return GST_FLOW_OK;
3351   }
3352 
3353   *buffer =
3354       gst_buffer_copy_region (parse-&gt;priv-&gt;cache, GST_BUFFER_COPY_ALL, 0, size);
3355 #ifdef GSTREAMER_LITE
3356   if (buffer == NULL)
3357     return GST_FLOW_ERROR;
3358 #endif // GSTREAMER_LITE
3359   GST_BUFFER_OFFSET (*buffer) = parse-&gt;priv-&gt;offset;
3360 
3361   return GST_FLOW_OK;
3362 }
3363 
3364 static GstFlowReturn
3365 gst_base_parse_handle_previous_fragment (GstBaseParse * parse)
3366 {
3367   gint64 offset = 0;
3368   GstClockTime ts = 0;
3369   GstBuffer *buffer;
3370   GstFlowReturn ret;
3371 
3372   GST_DEBUG_OBJECT (parse, &quot;fragment ended; last_ts = %&quot; GST_TIME_FORMAT
3373       &quot;, last_offset = %&quot; G_GINT64_FORMAT,
3374       GST_TIME_ARGS (parse-&gt;priv-&gt;last_pts), parse-&gt;priv-&gt;last_offset);
3375 
3376   if (!parse-&gt;priv-&gt;last_offset
3377       || parse-&gt;priv-&gt;last_pts &lt;= parse-&gt;segment.start) {
3378     GST_DEBUG_OBJECT (parse, &quot;past start of segment %&quot; GST_TIME_FORMAT,
3379         GST_TIME_ARGS (parse-&gt;segment.start));
3380     ret = GST_FLOW_EOS;
3381     goto exit;
3382   }
3383 
3384   /* last fragment started at last_offset / last_ts;
3385    * seek back 10s capped at 1MB */
3386   if (parse-&gt;priv-&gt;last_pts &gt;= 10 * GST_SECOND)
3387     ts = parse-&gt;priv-&gt;last_pts - 10 * GST_SECOND;
3388   /* if we are exact now, we will be more so going backwards */
3389   if (parse-&gt;priv-&gt;exact_position) {
3390     offset = gst_base_parse_find_offset (parse, ts, TRUE, NULL);
3391   } else {
3392     if (!gst_base_parse_convert (parse, GST_FORMAT_TIME, ts,
3393             GST_FORMAT_BYTES, &amp;offset)) {
3394       GST_DEBUG_OBJECT (parse, &quot;conversion failed, only BYTE based&quot;);
3395     }
3396   }
3397   offset = CLAMP (offset, parse-&gt;priv-&gt;last_offset - 1024 * 1024,
3398       parse-&gt;priv-&gt;last_offset - 1024);
3399   offset = MAX (0, offset);
3400 
3401   GST_DEBUG_OBJECT (parse, &quot;next fragment from offset %&quot; G_GINT64_FORMAT,
3402       offset);
3403   parse-&gt;priv-&gt;offset = offset;
3404 
3405   ret = gst_base_parse_pull_range (parse, parse-&gt;priv-&gt;last_offset - offset,
3406       &amp;buffer);
3407   if (ret != GST_FLOW_OK)
3408     goto exit;
3409 
3410   /* offset will increase again as fragment is processed/parsed */
3411   parse-&gt;priv-&gt;last_offset = offset;
3412 
3413   gst_base_parse_start_fragment (parse);
3414   gst_adapter_push (parse-&gt;priv-&gt;adapter, buffer);
3415   ret = gst_base_parse_finish_fragment (parse, TRUE);
3416   if (ret != GST_FLOW_OK)
3417     goto exit;
3418 
3419   /* force previous fragment */
3420   parse-&gt;priv-&gt;offset = -1;
3421 
3422 exit:
3423   return ret;
3424 }
3425 
3426 /* PULL mode:
3427  * pull and scan for next frame starting from current offset
3428  * ajusts sync, drain and offset going along */
3429 static GstFlowReturn
3430 gst_base_parse_scan_frame (GstBaseParse * parse, GstBaseParseClass * klass)
3431 {
3432   GstBuffer *buffer;
3433   GstFlowReturn ret = GST_FLOW_OK;
3434   guint fsize, min_size;
3435   gint flushed = 0;
3436   gint skip = 0;
3437 
3438   GST_LOG_OBJECT (parse, &quot;scanning for frame at offset %&quot; G_GUINT64_FORMAT
3439       &quot; (%#&quot; G_GINT64_MODIFIER &quot;x)&quot;, parse-&gt;priv-&gt;offset, parse-&gt;priv-&gt;offset);
3440 
3441   /* let&#39;s make this efficient for all subclass once and for all;
3442    * maybe it does not need this much, but in the latter case, we know we are
3443    * in pull mode here and might as well try to read and supply more anyway
3444    * (so does the buffer caching mechanism) */
3445   fsize = 64 * 1024;
3446 
3447   while (TRUE) {
3448     min_size = MAX (parse-&gt;priv-&gt;min_frame_size, fsize);
3449 
3450     GST_LOG_OBJECT (parse, &quot;reading buffer size %u&quot;, min_size);
3451 
3452     ret = gst_base_parse_pull_range (parse, min_size, &amp;buffer);
3453     if (ret != GST_FLOW_OK)
3454       goto done;
3455 
3456     /* if we got a short read, inform subclass we are draining leftover
3457      * and no more is to be expected */
3458     if (gst_buffer_get_size (buffer) &lt; min_size) {
3459       GST_LOG_OBJECT (parse, &quot;... but did not get that; marked draining&quot;);
3460       parse-&gt;priv-&gt;drain = TRUE;
3461     }
3462 
3463     if (parse-&gt;priv-&gt;detecting) {
3464       ret = klass-&gt;detect (parse, buffer);
3465       if (ret == GST_FLOW_NOT_NEGOTIATED) {
3466         /* If draining we error out, otherwise request a buffer
3467          * with 64kb more */
3468         if (parse-&gt;priv-&gt;drain) {
3469           gst_buffer_unref (buffer);
3470           GST_ERROR_OBJECT (parse, &quot;Failed to detect format but draining&quot;);
3471           return GST_FLOW_ERROR;
3472         } else {
3473           fsize += 64 * 1024;
3474           gst_buffer_unref (buffer);
3475           continue;
3476     }
3477       } else if (ret != GST_FLOW_OK) {
3478     gst_buffer_unref (buffer);
3479         GST_ERROR_OBJECT (parse, &quot;detect() returned %s&quot;,
3480             gst_flow_get_name (ret));
3481         return ret;
3482     }
3483 
3484       /* Else handle this buffer normally */
3485   }
3486 
3487     ret = gst_base_parse_handle_buffer (parse, buffer, &amp;skip, &amp;flushed);
3488     if (ret != GST_FLOW_OK)
3489       break;
3490 
3491     /* If a large amount of data was requested to be skipped, _handle_buffer
3492        might have set the priv-&gt;skip flag to an extra amount on top of skip.
3493        In pull mode, we can just pull from the new offset directly. */
3494     parse-&gt;priv-&gt;offset += parse-&gt;priv-&gt;skip;
3495     parse-&gt;priv-&gt;skip = 0;
3496 
3497     /* something flushed means something happened,
3498      * and we should bail out of this loop so as not to occupy
3499      * the task thread indefinitely */
3500     if (flushed) {
3501       GST_LOG_OBJECT (parse, &quot;frame finished, breaking loop&quot;);
3502       break;
3503     }
3504     /* nothing flushed, no skip and draining, so nothing left to do */
3505     if (!skip &amp;&amp; parse-&gt;priv-&gt;drain) {
3506       GST_LOG_OBJECT (parse, &quot;no activity or result when draining; &quot;
3507           &quot;breaking loop and marking EOS&quot;);
3508       ret = GST_FLOW_EOS;
3509       break;
3510     }
3511     /* otherwise, get some more data
3512      * note that is checked this does not happen indefinitely */
3513     if (!skip) {
3514       GST_LOG_OBJECT (parse, &quot;getting some more data&quot;);
3515       fsize += 64 * 1024;
3516   }
3517     parse-&gt;priv-&gt;drain = FALSE;
3518   }
3519 
3520 done:
3521   return ret;
3522 }
3523 
3524 /* Loop that is used in pull mode to retrieve data from upstream */
3525 static void
3526 gst_base_parse_loop (GstPad * pad)
3527 {
3528   GstBaseParse *parse;
3529   GstBaseParseClass *klass;
3530   GstFlowReturn ret = GST_FLOW_OK;
3531 
3532   parse = GST_BASE_PARSE (gst_pad_get_parent (pad));
3533   klass = GST_BASE_PARSE_GET_CLASS (parse);
3534 
3535   GST_LOG_OBJECT (parse, &quot;Entering parse loop&quot;);
3536 
3537   if (G_UNLIKELY (parse-&gt;priv-&gt;push_stream_start)) {
3538     gchar *stream_id;
3539     GstEvent *event;
3540 
3541     stream_id =
3542         gst_pad_create_stream_id (parse-&gt;srcpad, GST_ELEMENT_CAST (parse),
3543         NULL);
3544 
3545     event = gst_event_new_stream_start (stream_id);
3546     gst_event_set_group_id (event, gst_util_group_id_next ());
3547 
3548     GST_DEBUG_OBJECT (parse, &quot;Pushing STREAM_START&quot;);
3549     gst_pad_push_event (parse-&gt;srcpad, event);
3550     parse-&gt;priv-&gt;push_stream_start = FALSE;
3551     g_free (stream_id);
3552   }
3553 
3554   /* reverse playback:
3555    * first fragment (closest to stop time) is handled normally below,
3556    * then we pull in fragments going backwards */
3557   if (parse-&gt;segment.rate &lt; 0.0) {
3558     /* check if we jumped back to a previous fragment,
3559      * which is a post-first fragment */
3560     if (parse-&gt;priv-&gt;offset &lt; 0) {
3561       ret = gst_base_parse_handle_previous_fragment (parse);
3562       goto done;
3563     }
3564   }
3565 
3566   ret = gst_base_parse_scan_frame (parse, klass);
3567 
3568   /* eat expected eos signalling past segment in reverse playback */
3569   if (parse-&gt;segment.rate &lt; 0.0 &amp;&amp; ret == GST_FLOW_EOS &amp;&amp;
3570       parse-&gt;segment.position &gt;= parse-&gt;segment.stop) {
3571     GST_DEBUG_OBJECT (parse, &quot;downstream has reached end of segment&quot;);
3572     /* push what was accumulated during loop run */
3573     gst_base_parse_finish_fragment (parse, FALSE);
3574     /* force previous fragment */
3575     parse-&gt;priv-&gt;offset = -1;
3576     goto eos;
3577   }
3578 
3579   if (ret != GST_FLOW_OK)
3580     goto done;
3581 
3582 done:
3583   if (ret == GST_FLOW_EOS)
3584     goto eos;
3585   else if (ret != GST_FLOW_OK)
3586     goto pause;
3587 
3588   gst_object_unref (parse);
3589   return;
3590 
3591   /* ERRORS */
3592 eos:
3593   {
3594     ret = GST_FLOW_EOS;
3595     GST_DEBUG_OBJECT (parse, &quot;eos&quot;);
3596     /* fall-through */
3597   }
3598 pause:
3599   {
3600     gboolean push_eos = FALSE;
3601 
3602     GST_DEBUG_OBJECT (parse, &quot;pausing task, reason %s&quot;,
3603         gst_flow_get_name (ret));
3604     gst_pad_pause_task (parse-&gt;sinkpad);
3605 
3606     if (ret == GST_FLOW_EOS) {
3607       /* handle end-of-stream/segment */
3608       if (parse-&gt;segment.flags &amp; GST_SEGMENT_FLAG_SEGMENT) {
3609         gint64 stop;
3610 
3611         if ((stop = parse-&gt;segment.stop) == -1)
3612           stop = parse-&gt;segment.duration;
3613 
3614         GST_DEBUG_OBJECT (parse, &quot;sending segment_done&quot;);
3615 
3616         gst_element_post_message
3617             (GST_ELEMENT_CAST (parse),
3618             gst_message_new_segment_done (GST_OBJECT_CAST (parse),
3619                 GST_FORMAT_TIME, stop));
3620         gst_pad_push_event (parse-&gt;srcpad,
3621             gst_event_new_segment_done (GST_FORMAT_TIME, stop));
3622       } else {
3623         /* If we STILL have zero frames processed, fire an error */
3624         if (parse-&gt;priv-&gt;framecount == 0) {
3625           GST_ELEMENT_ERROR (parse, STREAM, WRONG_TYPE,
3626               (&quot;No valid frames found before end of stream&quot;), (NULL));
3627         }
3628         push_eos = TRUE;
3629       }
3630     } else if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS) {
3631       /* for fatal errors we post an error message, wrong-state is
3632        * not fatal because it happens due to flushes and only means
3633        * that we should stop now. */
3634       GST_ELEMENT_FLOW_ERROR (parse, ret);
3635       push_eos = TRUE;
3636     }
3637     if (push_eos) {
3638       if (parse-&gt;priv-&gt;estimated_duration &lt;= 0) {
3639         gst_base_parse_update_duration (parse);
3640       }
3641       /* Push pending events, including SEGMENT events */
3642       gst_base_parse_push_pending_events (parse);
3643 
3644       gst_pad_push_event (parse-&gt;srcpad, gst_event_new_eos ());
3645     }
3646     gst_object_unref (parse);
3647   }
3648 }
3649 
3650 static gboolean
3651 gst_base_parse_sink_activate (GstPad * sinkpad, GstObject * parent)
3652 {
3653   GstSchedulingFlags sched_flags;
3654   GstBaseParse *parse;
3655   GstQuery *query;
3656   gboolean pull_mode;
3657 
3658   parse = GST_BASE_PARSE (parent);
3659 
3660   GST_DEBUG_OBJECT (parse, &quot;sink activate&quot;);
3661 
3662   query = gst_query_new_scheduling ();
3663   if (!gst_pad_peer_query (sinkpad, query)) {
3664     gst_query_unref (query);
3665     goto baseparse_push;
3666   }
3667 
3668   gst_query_parse_scheduling (query, &amp;sched_flags, NULL, NULL, NULL);
3669 
3670   pull_mode = gst_query_has_scheduling_mode (query, GST_PAD_MODE_PULL)
3671       &amp;&amp; ((sched_flags &amp; GST_SCHEDULING_FLAG_SEEKABLE) != 0);
3672 
3673   gst_query_unref (query);
3674 
3675   if (!pull_mode)
3676     goto baseparse_push;
3677 
3678     GST_DEBUG_OBJECT (parse, &quot;trying to activate in pull mode&quot;);
3679   if (!gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PULL, TRUE))
3680     goto baseparse_push;
3681 
3682   parse-&gt;priv-&gt;push_stream_start = TRUE;
3683   /* In pull mode, upstream is BYTES */
3684   parse-&gt;priv-&gt;upstream_format = GST_FORMAT_BYTES;
3685 
3686   return gst_pad_start_task (sinkpad, (GstTaskFunction) gst_base_parse_loop,
3687       sinkpad, NULL);
3688   /* fallback */
3689 baseparse_push:
3690   {
3691     GST_DEBUG_OBJECT (parse, &quot;trying to activate in push mode&quot;);
3692     return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PUSH, TRUE);
3693   }
3694 }
3695 
3696 static gboolean
3697 gst_base_parse_activate (GstBaseParse * parse, gboolean active)
3698 {
3699   GstBaseParseClass *klass;
3700   gboolean result = TRUE;
3701 
3702   GST_DEBUG_OBJECT (parse, &quot;activate %d&quot;, active);
3703 
3704   klass = GST_BASE_PARSE_GET_CLASS (parse);
3705 
3706   if (active) {
3707     if (parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_NONE &amp;&amp; klass-&gt;start)
3708       result = klass-&gt;start (parse);
3709 
3710     /* If the subclass implements ::detect we want to
3711      * call it for the first buffers now */
3712     parse-&gt;priv-&gt;detecting = (klass-&gt;detect != NULL);
3713   } else {
3714     /* We must make sure streaming has finished before resetting things
3715      * and calling the ::stop vfunc */
3716     GST_PAD_STREAM_LOCK (parse-&gt;sinkpad);
3717     GST_PAD_STREAM_UNLOCK (parse-&gt;sinkpad);
3718 
3719     if (parse-&gt;priv-&gt;pad_mode != GST_PAD_MODE_NONE &amp;&amp; klass-&gt;stop)
3720       result = klass-&gt;stop (parse);
3721 
3722     parse-&gt;priv-&gt;pad_mode = GST_PAD_MODE_NONE;
3723     parse-&gt;priv-&gt;upstream_format = GST_FORMAT_UNDEFINED;
3724   }
3725   GST_DEBUG_OBJECT (parse, &quot;activate return: %d&quot;, result);
3726   return result;
3727 }
3728 
3729 static gboolean
3730 gst_base_parse_sink_activate_mode (GstPad * pad, GstObject * parent,
3731     GstPadMode mode, gboolean active)
3732 {
3733   gboolean result;
3734   GstBaseParse *parse;
3735 
3736   parse = GST_BASE_PARSE (parent);
3737 
3738   GST_DEBUG_OBJECT (parse, &quot;sink %sactivate in %s mode&quot;,
3739       (active) ? &quot;&quot; : &quot;de&quot;, gst_pad_mode_get_name (mode));
3740 
3741   if (!gst_base_parse_activate (parse, active))
3742     goto activate_failed;
3743 
3744   switch (mode) {
3745     case GST_PAD_MODE_PULL:
3746     if (active) {
3747         parse-&gt;priv-&gt;pending_events =
3748             g_list_prepend (parse-&gt;priv-&gt;pending_events,
3749             gst_event_new_segment (&amp;parse-&gt;segment));
3750         result = TRUE;
3751     } else {
3752         result = gst_pad_stop_task (pad);
3753     }
3754       break;
3755     default:
3756       result = TRUE;
3757       break;
3758   }
3759   if (result)
3760     parse-&gt;priv-&gt;pad_mode = active ? mode : GST_PAD_MODE_NONE;
3761 
3762   GST_DEBUG_OBJECT (parse, &quot;sink activate return: %d&quot;, result);
3763 
3764   return result;
3765 
3766   /* ERRORS */
3767 activate_failed:
3768   {
3769     GST_DEBUG_OBJECT (parse, &quot;activate failed&quot;);
3770     return FALSE;
3771   }
3772 }
3773 
3774 /**
3775  * gst_base_parse_set_duration:
3776  * @parse: #GstBaseParse.
3777  * @fmt: #GstFormat.
3778  * @duration: duration value.
3779  * @interval: how often to update the duration estimate based on bitrate, or 0.
3780  *
3781  * Sets the duration of the currently playing media. Subclass can use this
3782  * when it is able to determine duration and/or notices a change in the media
3783  * duration.  Alternatively, if @interval is non-zero (default), then stream
3784  * duration is determined based on estimated bitrate, and updated every @interval
3785  * frames.
3786  */
3787 void
3788 gst_base_parse_set_duration (GstBaseParse * parse,
3789     GstFormat fmt, gint64 duration, gint interval)
3790 {
3791   g_return_if_fail (parse != NULL);
3792 
3793   if (parse-&gt;priv-&gt;upstream_has_duration) {
3794     GST_DEBUG_OBJECT (parse, &quot;using upstream duration; discarding update&quot;);
3795     goto exit;
3796   }
3797 
3798   if (duration != parse-&gt;priv-&gt;duration) {
3799     GstMessage *m;
3800 
3801     m = gst_message_new_duration_changed (GST_OBJECT (parse));
3802     gst_element_post_message (GST_ELEMENT (parse), m);
3803 
3804     /* TODO: what about duration tag? */
3805   }
3806   parse-&gt;priv-&gt;duration = duration;
3807   parse-&gt;priv-&gt;duration_fmt = fmt;
3808   GST_DEBUG_OBJECT (parse, &quot;set duration: %&quot; G_GINT64_FORMAT, duration);
3809   if (fmt == GST_FORMAT_TIME &amp;&amp; GST_CLOCK_TIME_IS_VALID (duration)) {
3810     if (interval != 0) {
3811       GST_DEBUG_OBJECT (parse, &quot;valid duration provided, disabling estimate&quot;);
3812       interval = 0;
3813     }
3814   }
3815   GST_DEBUG_OBJECT (parse, &quot;set update interval: %d&quot;, interval);
3816   parse-&gt;priv-&gt;update_interval = interval;
3817 exit:
3818   return;
3819 }
3820 
3821 /**
3822  * gst_base_parse_set_average_bitrate:
3823  * @parse: #GstBaseParse.
3824  * @bitrate: average bitrate in bits/second
3825  *
3826  * Optionally sets the average bitrate detected in media (if non-zero),
3827  * e.g. based on metadata, as it will be posted to the application.
3828  *
3829  * By default, announced average bitrate is estimated. The average bitrate
3830  * is used to estimate the total duration of the stream and to estimate
3831  * a seek position, if there&#39;s no index and the format is syncable
3832  * (see gst_base_parse_set_syncable()).
3833  */
3834 void
3835 gst_base_parse_set_average_bitrate (GstBaseParse * parse, guint bitrate)
3836 {
3837   parse-&gt;priv-&gt;bitrate = bitrate;
3838   GST_DEBUG_OBJECT (parse, &quot;bitrate %u&quot;, bitrate);
3839 }
3840 
3841 /**
3842  * gst_base_parse_set_min_frame_size:
3843  * @parse: #GstBaseParse.
3844  * @min_size: Minimum size of the data that this base class should give to
3845  *            subclass.
3846  *
3847  * Subclass can use this function to tell the base class that it needs to
3848  * give at least #min_size buffers.
3849  */
3850 void
3851 gst_base_parse_set_min_frame_size (GstBaseParse * parse, guint min_size)
3852 {
3853   g_return_if_fail (parse != NULL);
3854 
3855   parse-&gt;priv-&gt;min_frame_size = min_size;
3856   GST_LOG_OBJECT (parse, &quot;set frame_min_size: %d&quot;, min_size);
3857 }
3858 
3859 /**
3860  * gst_base_parse_set_frame_rate:
3861  * @parse: the #GstBaseParse to set
3862  * @fps_num: frames per second (numerator).
3863  * @fps_den: frames per second (denominator).
3864  * @lead_in: frames needed before a segment for subsequent decode
3865  * @lead_out: frames needed after a segment
3866  *
3867  * If frames per second is configured, parser can take care of buffer duration
3868  * and timestamping.  When performing segment clipping, or seeking to a specific
3869  * location, a corresponding decoder might need an initial @lead_in and a
3870  * following @lead_out number of frames to ensure the desired segment is
3871  * entirely filled upon decoding.
3872  */
3873 void
3874 gst_base_parse_set_frame_rate (GstBaseParse * parse, guint fps_num,
3875     guint fps_den, guint lead_in, guint lead_out)
3876 {
3877   g_return_if_fail (parse != NULL);
3878 
3879   parse-&gt;priv-&gt;fps_num = fps_num;
3880   parse-&gt;priv-&gt;fps_den = fps_den;
3881   if (!fps_num || !fps_den) {
3882     GST_DEBUG_OBJECT (parse, &quot;invalid fps (%d/%d), ignoring parameters&quot;,
3883         fps_num, fps_den);
3884     fps_num = fps_den = 0;
3885     parse-&gt;priv-&gt;frame_duration = GST_CLOCK_TIME_NONE;
3886     parse-&gt;priv-&gt;lead_in = parse-&gt;priv-&gt;lead_out = 0;
3887     parse-&gt;priv-&gt;lead_in_ts = parse-&gt;priv-&gt;lead_out_ts = 0;
3888   } else {
3889     parse-&gt;priv-&gt;frame_duration =
3890         gst_util_uint64_scale (GST_SECOND, fps_den, fps_num);
3891     parse-&gt;priv-&gt;lead_in = lead_in;
3892     parse-&gt;priv-&gt;lead_out = lead_out;
3893     parse-&gt;priv-&gt;lead_in_ts =
3894         gst_util_uint64_scale (GST_SECOND, fps_den * lead_in, fps_num);
3895     parse-&gt;priv-&gt;lead_out_ts =
3896         gst_util_uint64_scale (GST_SECOND, fps_den * lead_out, fps_num);
3897     /* aim for about 1.5s to estimate duration */
3898     if (parse-&gt;priv-&gt;update_interval &lt; 0) {
3899       guint64 interval = gst_util_uint64_scale (fps_num, 3,
3900           G_GUINT64_CONSTANT (2) * fps_den);
3901 
3902       parse-&gt;priv-&gt;update_interval = MIN (interval, G_MAXINT);
3903 
3904       GST_LOG_OBJECT (parse, &quot;estimated update interval to %d frames&quot;,
3905           parse-&gt;priv-&gt;update_interval);
3906     }
3907   }
3908   GST_LOG_OBJECT (parse, &quot;set fps: %d/%d =&gt; duration: %&quot; G_GINT64_FORMAT &quot; ms&quot;,
3909       fps_num, fps_den, parse-&gt;priv-&gt;frame_duration / GST_MSECOND);
3910   GST_LOG_OBJECT (parse, &quot;set lead in: %d frames = %&quot; G_GUINT64_FORMAT &quot; ms, &quot;
3911       &quot;lead out: %d frames = %&quot; G_GUINT64_FORMAT &quot; ms&quot;,
3912       lead_in, parse-&gt;priv-&gt;lead_in_ts / GST_MSECOND,
3913       lead_out, parse-&gt;priv-&gt;lead_out_ts / GST_MSECOND);
3914 }
3915 
3916 /**
3917  * gst_base_parse_set_has_timing_info:
3918  * @parse: a #GstBaseParse
3919  * @has_timing: whether frames carry timing information
3920  *
3921  * Set if frames carry timing information which the subclass can (generally)
3922  * parse and provide.  In particular, intrinsic (rather than estimated) time
3923  * can be obtained following a seek.
3924  */
3925 void
3926 gst_base_parse_set_has_timing_info (GstBaseParse * parse, gboolean has_timing)
3927 {
3928   parse-&gt;priv-&gt;has_timing_info = has_timing;
3929   GST_INFO_OBJECT (parse, &quot;has_timing: %s&quot;, (has_timing) ? &quot;yes&quot; : &quot;no&quot;);
3930 }
3931 
3932 /**
3933  * gst_base_parse_set_syncable:
3934  * @parse: a #GstBaseParse
3935  * @syncable: set if frame starts can be identified
3936  *
3937  * Set if frame starts can be identified. This is set by default and
3938  * determines whether seeking based on bitrate averages
3939  * is possible for a format/stream.
3940  */
3941 void
3942 gst_base_parse_set_syncable (GstBaseParse * parse, gboolean syncable)
3943 {
3944   parse-&gt;priv-&gt;syncable = syncable;
3945   GST_INFO_OBJECT (parse, &quot;syncable: %s&quot;, (syncable) ? &quot;yes&quot; : &quot;no&quot;);
3946 }
3947 
3948 /**
3949  * gst_base_parse_set_passthrough:
3950  * @parse: a #GstBaseParse
3951  * @passthrough: %TRUE if parser should run in passthrough mode
3952  *
3953  * Set if the nature of the format or configuration does not allow (much)
3954  * parsing, and the parser should operate in passthrough mode (which only
3955  * applies when operating in push mode). That is, incoming buffers are
3956  * pushed through unmodified, i.e. no @check_valid_frame or @parse_frame
3957  * callbacks will be invoked, but @pre_push_frame will still be invoked,
3958  * so subclass can perform as much or as little is appropriate for
3959  * passthrough semantics in @pre_push_frame.
3960  */
3961 void
3962 gst_base_parse_set_passthrough (GstBaseParse * parse, gboolean passthrough)
3963 {
3964   parse-&gt;priv-&gt;passthrough = passthrough;
3965   GST_INFO_OBJECT (parse, &quot;passthrough: %s&quot;, (passthrough) ? &quot;yes&quot; : &quot;no&quot;);
3966 }
3967 
3968 /**
3969  * gst_base_parse_set_pts_interpolation:
3970  * @parse: a #GstBaseParse
3971  * @pts_interpolate: %TRUE if parser should interpolate PTS timestamps
3972  *
3973  * By default, the base class will guess PTS timestamps using a simple
3974  * interpolation (previous timestamp + duration), which is incorrect for
3975  * data streams with reordering, where PTS can go backward. Sub-classes
3976  * implementing such formats should disable PTS interpolation.
3977  */
3978 void
3979 gst_base_parse_set_pts_interpolation (GstBaseParse * parse,
3980     gboolean pts_interpolate)
3981 {
3982   parse-&gt;priv-&gt;pts_interpolate = pts_interpolate;
3983   GST_INFO_OBJECT (parse, &quot;PTS interpolation: %s&quot;,
3984       (pts_interpolate) ? &quot;yes&quot; : &quot;no&quot;);
3985 }
3986 
3987 /**
3988  * gst_base_parse_set_infer_ts:
3989  * @parse: a #GstBaseParse
3990  * @infer_ts: %TRUE if parser should infer DTS/PTS from each other
3991  *
3992  * By default, the base class might try to infer PTS from DTS and vice
3993  * versa.  While this is generally correct for audio data, it may not
3994  * be otherwise. Sub-classes implementing such formats should disable
3995  * timestamp inferring.
3996  */
3997 void
3998 gst_base_parse_set_infer_ts (GstBaseParse * parse, gboolean infer_ts)
3999 {
4000   parse-&gt;priv-&gt;infer_ts = infer_ts;
4001   GST_INFO_OBJECT (parse, &quot;TS inferring: %s&quot;, (infer_ts) ? &quot;yes&quot; : &quot;no&quot;);
4002 }
4003 
4004 /**
4005  * gst_base_parse_set_latency:
4006  * @parse: a #GstBaseParse
4007  * @min_latency: minimum parse latency
4008  * @max_latency: maximum parse latency
4009  *
4010  * Sets the minimum and maximum (which may likely be equal) latency introduced
4011  * by the parsing process.  If there is such a latency, which depends on the
4012  * particular parsing of the format, it typically corresponds to 1 frame duration.
4013  */
4014 void
4015 gst_base_parse_set_latency (GstBaseParse * parse, GstClockTime min_latency,
4016     GstClockTime max_latency)
4017 {
4018   g_return_if_fail (min_latency != GST_CLOCK_TIME_NONE);
4019   g_return_if_fail (min_latency &lt;= max_latency);
4020 
4021   GST_OBJECT_LOCK (parse);
4022   parse-&gt;priv-&gt;min_latency = min_latency;
4023   parse-&gt;priv-&gt;max_latency = max_latency;
4024   GST_OBJECT_UNLOCK (parse);
4025   GST_INFO_OBJECT (parse, &quot;min/max latency %&quot; GST_TIME_FORMAT &quot;, %&quot;
4026       GST_TIME_FORMAT, GST_TIME_ARGS (min_latency),
4027       GST_TIME_ARGS (max_latency));
4028 }
4029 
4030 static gboolean
4031 gst_base_parse_get_duration (GstBaseParse * parse, GstFormat format,
4032     GstClockTime * duration)
4033 {
4034   gboolean res = FALSE;
4035 
4036   g_return_val_if_fail (duration != NULL, FALSE);
4037 
4038   *duration = GST_CLOCK_TIME_NONE;
4039   if (parse-&gt;priv-&gt;duration != -1 &amp;&amp; format == parse-&gt;priv-&gt;duration_fmt) {
4040     GST_LOG_OBJECT (parse, &quot;using provided duration&quot;);
4041     *duration = parse-&gt;priv-&gt;duration;
4042     res = TRUE;
4043   } else if (parse-&gt;priv-&gt;duration != -1) {
4044     GST_LOG_OBJECT (parse, &quot;converting provided duration&quot;);
4045     res = gst_base_parse_convert (parse, parse-&gt;priv-&gt;duration_fmt,
4046         parse-&gt;priv-&gt;duration, format, (gint64 *) duration);
4047   } else if (format == GST_FORMAT_TIME &amp;&amp; parse-&gt;priv-&gt;estimated_duration != -1) {
4048     GST_LOG_OBJECT (parse, &quot;using estimated duration&quot;);
4049     *duration = parse-&gt;priv-&gt;estimated_duration;
4050     res = TRUE;
4051   } else {
4052     GST_LOG_OBJECT (parse, &quot;cannot estimate duration&quot;);
4053   }
4054 
4055   GST_LOG_OBJECT (parse, &quot;res: %d, duration %&quot; GST_TIME_FORMAT, res,
4056       GST_TIME_ARGS (*duration));
4057   return res;
4058 }
4059 
4060 static gboolean
4061 gst_base_parse_src_query_default (GstBaseParse * parse, GstQuery * query)
4062 {
4063   gboolean res = FALSE;
4064   GstPad *pad;
4065 
4066   pad = GST_BASE_PARSE_SRC_PAD (parse);
4067 
4068   switch (GST_QUERY_TYPE (query)) {
4069     case GST_QUERY_POSITION:
4070     {
4071       gint64 dest_value;
4072       GstFormat format;
4073 
4074       GST_DEBUG_OBJECT (parse, &quot;position query&quot;);
4075       gst_query_parse_position (query, &amp;format, NULL);
4076 
4077       /* try upstream first */
4078       res = gst_pad_query_default (pad, GST_OBJECT_CAST (parse), query);
4079       if (!res) {
4080         /* Fall back on interpreting segment */
4081       GST_OBJECT_LOCK (parse);
4082         /* Only reply BYTES if upstream is in BYTES already, otherwise
4083          * we&#39;re not in charge */
4084         if (format == GST_FORMAT_BYTES
4085             &amp;&amp; parse-&gt;priv-&gt;upstream_format == GST_FORMAT_BYTES) {
4086         dest_value = parse-&gt;priv-&gt;offset;
4087         res = TRUE;
4088       } else if (format == parse-&gt;segment.format &amp;&amp;
4089             GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.position)) {
4090           dest_value = gst_segment_to_stream_time (&amp;parse-&gt;segment,
4091               parse-&gt;segment.format, parse-&gt;segment.position);
4092         res = TRUE;
4093       }
4094       GST_OBJECT_UNLOCK (parse);
4095         if (!res &amp;&amp; parse-&gt;priv-&gt;upstream_format == GST_FORMAT_BYTES) {
4096           /* no precise result, upstream no idea either, then best estimate */
4097           /* priv-&gt;offset is updated in both PUSH/PULL modes, *iff* we&#39;re
4098            * in charge of things */
4099           res = gst_base_parse_convert (parse,
4100               GST_FORMAT_BYTES, parse-&gt;priv-&gt;offset, format, &amp;dest_value);
4101         }
4102         if (res)
4103           gst_query_set_position (query, format, dest_value);
4104       }
4105       break;
4106     }
4107     case GST_QUERY_DURATION:
4108     {
4109       GstFormat format;
4110       GstClockTime duration;
4111 
4112       GST_DEBUG_OBJECT (parse, &quot;duration query&quot;);
4113       gst_query_parse_duration (query, &amp;format, NULL);
4114 
4115       /* consult upstream */
4116       res = gst_pad_query_default (pad, GST_OBJECT_CAST (parse), query);
4117 
4118       /* otherwise best estimate from us */
4119       if (!res) {
4120         res = gst_base_parse_get_duration (parse, format, &amp;duration);
4121         if (res)
4122           gst_query_set_duration (query, format, duration);
4123       }
4124       break;
4125     }
4126     case GST_QUERY_SEEKING:
4127     {
4128       GstFormat fmt;
4129       GstClockTime duration = GST_CLOCK_TIME_NONE;
4130       gboolean seekable = FALSE;
4131 
4132       GST_DEBUG_OBJECT (parse, &quot;seeking query&quot;);
4133       gst_query_parse_seeking (query, &amp;fmt, NULL, NULL, NULL);
4134 
4135       /* consult upstream */
4136       res = gst_pad_query_default (pad, GST_OBJECT_CAST (parse), query);
4137 
4138       /* we may be able to help if in TIME */
4139       if (fmt == GST_FORMAT_TIME &amp;&amp; gst_base_parse_is_seekable (parse)) {
4140         gst_query_parse_seeking (query, &amp;fmt, &amp;seekable, NULL, NULL);
4141         /* already OK if upstream takes care */
4142         GST_LOG_OBJECT (parse, &quot;upstream handled %d, seekable %d&quot;,
4143             res, seekable);
4144         if (!(res &amp;&amp; seekable)) {
4145           if (!gst_base_parse_get_duration (parse, GST_FORMAT_TIME, &amp;duration)
4146               || duration == -1) {
4147             /* seekable if we still have a chance to get duration later on */
4148             seekable = parse-&gt;priv-&gt;upstream_seekable &amp;&amp;
4149                 (parse-&gt;priv-&gt;update_interval &gt; 0);
4150           } else {
4151             seekable = parse-&gt;priv-&gt;upstream_seekable;
4152             GST_LOG_OBJECT (parse, &quot;already determine upstream seekabled: %d&quot;,
4153                 seekable);
4154           }
4155           gst_query_set_seeking (query, GST_FORMAT_TIME, seekable, 0, duration);
4156           res = TRUE;
4157         }
4158       }
4159       break;
4160     }
4161     case GST_QUERY_FORMATS:
4162       gst_query_set_formatsv (query, 3, fmtlist);
4163       res = TRUE;
4164       break;
4165     case GST_QUERY_CONVERT:
4166     {
4167       GstFormat src_format, dest_format;
4168       gint64 src_value, dest_value;
4169 
4170       gst_query_parse_convert (query, &amp;src_format, &amp;src_value,
4171           &amp;dest_format, &amp;dest_value);
4172 
4173       res = gst_base_parse_convert (parse, src_format, src_value,
4174           dest_format, &amp;dest_value);
4175       if (res) {
4176         gst_query_set_convert (query, src_format, src_value,
4177             dest_format, dest_value);
4178       }
4179       break;
4180     }
4181     case GST_QUERY_LATENCY:
4182     {
4183       if ((res = gst_pad_peer_query (parse-&gt;sinkpad, query))) {
4184         gboolean live;
4185         GstClockTime min_latency, max_latency;
4186 
4187         gst_query_parse_latency (query, &amp;live, &amp;min_latency, &amp;max_latency);
4188         GST_DEBUG_OBJECT (parse, &quot;Peer latency: live %d, min %&quot;
4189             GST_TIME_FORMAT &quot; max %&quot; GST_TIME_FORMAT, live,
4190             GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
4191 
4192         GST_OBJECT_LOCK (parse);
4193         /* add our latency */
4194           min_latency += parse-&gt;priv-&gt;min_latency;
4195         if (max_latency == -1 || parse-&gt;priv-&gt;max_latency == -1)
4196           max_latency = -1;
4197         else
4198           max_latency += parse-&gt;priv-&gt;max_latency;
4199         GST_OBJECT_UNLOCK (parse);
4200 
4201         gst_query_set_latency (query, live, min_latency, max_latency);
4202       }
4203       break;
4204     }
4205     case GST_QUERY_SEGMENT:
4206     {
4207       GstFormat format;
4208       gint64 start, stop;
4209 
4210       format = parse-&gt;segment.format;
4211 
4212       start =
4213           gst_segment_to_stream_time (&amp;parse-&gt;segment, format,
4214           parse-&gt;segment.start);
4215       if ((stop = parse-&gt;segment.stop) == -1)
4216         stop = parse-&gt;segment.duration;
4217       else
4218         stop = gst_segment_to_stream_time (&amp;parse-&gt;segment, format, stop);
4219 
4220       gst_query_set_segment (query, parse-&gt;segment.rate, format, start, stop);
4221       res = TRUE;
4222       break;
4223     }
4224     default:
4225       res = gst_pad_query_default (pad, GST_OBJECT_CAST (parse), query);
4226       break;
4227   }
4228   return res;
4229 }
4230 
4231 /* scans for a cluster start from @pos,
4232  * return GST_FLOW_OK and frame position/time in @pos/@time if found */
4233 static GstFlowReturn
4234 gst_base_parse_find_frame (GstBaseParse * parse, gint64 * pos,
4235     GstClockTime * time, GstClockTime * duration)
4236 {
4237   GstBaseParseClass *klass;
4238   gint64 orig_offset;
4239   gboolean orig_drain, orig_discont;
4240   GstFlowReturn ret = GST_FLOW_OK;
4241   GstBuffer *buf = NULL;
4242   GstBaseParseFrame *sframe = NULL;
4243 
4244   g_return_val_if_fail (pos != NULL, GST_FLOW_ERROR);
4245   g_return_val_if_fail (time != NULL, GST_FLOW_ERROR);
4246   g_return_val_if_fail (duration != NULL, GST_FLOW_ERROR);
4247 
4248   klass = GST_BASE_PARSE_GET_CLASS (parse);
4249 
4250   *time = GST_CLOCK_TIME_NONE;
4251   *duration = GST_CLOCK_TIME_NONE;
4252 
4253   /* save state */
4254   orig_offset = parse-&gt;priv-&gt;offset;
4255   orig_discont = parse-&gt;priv-&gt;discont;
4256   orig_drain = parse-&gt;priv-&gt;drain;
4257 
4258   GST_DEBUG_OBJECT (parse, &quot;scanning for frame starting at %&quot; G_GINT64_FORMAT
4259       &quot; (%#&quot; G_GINT64_MODIFIER &quot;x)&quot;, *pos, *pos);
4260 
4261   /* jump elsewhere and locate next frame */
4262   parse-&gt;priv-&gt;offset = *pos;
4263   /* mark as scanning so frames don&#39;t get processed all the way */
4264   parse-&gt;priv-&gt;scanning = TRUE;
4265   ret = gst_base_parse_scan_frame (parse, klass);
4266   parse-&gt;priv-&gt;scanning = FALSE;
4267   /* retrieve frame found during scan */
4268   sframe = parse-&gt;priv-&gt;scanned_frame;
4269   parse-&gt;priv-&gt;scanned_frame = NULL;
4270 
4271   if (ret != GST_FLOW_OK || !sframe)
4272     goto done;
4273 
4274   /* get offset first, subclass parsing might dump other stuff in there */
4275   *pos = sframe-&gt;offset;
4276   buf = sframe-&gt;buffer;
4277   g_assert (buf);
4278 
4279   /* but it should provide proper time */
4280   *time = GST_BUFFER_TIMESTAMP (buf);
4281   *duration = GST_BUFFER_DURATION (buf);
4282 
4283   GST_LOG_OBJECT (parse,
4284       &quot;frame with time %&quot; GST_TIME_FORMAT &quot; at offset %&quot; G_GINT64_FORMAT,
4285       GST_TIME_ARGS (*time), *pos);
4286 
4287 done:
4288   if (sframe)
4289     gst_base_parse_frame_free (sframe);
4290 
4291   /* restore state */
4292   parse-&gt;priv-&gt;offset = orig_offset;
4293   parse-&gt;priv-&gt;discont = orig_discont;
4294   parse-&gt;priv-&gt;drain = orig_drain;
4295 
4296   return ret;
4297 }
4298 
4299 /* bisect and scan through file for frame starting before @time,
4300  * returns OK and @time/@offset if found, NONE and/or error otherwise
4301  * If @time == G_MAXINT64, scan for duration ( == last frame) */
4302 static GstFlowReturn
4303 gst_base_parse_locate_time (GstBaseParse * parse, GstClockTime * _time,
4304     gint64 * _offset)
4305 {
4306   GstFlowReturn ret = GST_FLOW_OK;
4307   gint64 lpos, hpos, newpos;
4308   GstClockTime time, ltime, htime, newtime, dur;
4309   gboolean cont = TRUE;
4310   const GstClockTime tolerance = TARGET_DIFFERENCE;
4311   const guint chunk = 4 * 1024;
4312 
4313   g_return_val_if_fail (_time != NULL, GST_FLOW_ERROR);
4314   g_return_val_if_fail (_offset != NULL, GST_FLOW_ERROR);
4315 
4316   GST_DEBUG_OBJECT (parse, &quot;Bisecting for time %&quot; GST_TIME_FORMAT,
4317       GST_TIME_ARGS (*_time));
4318 
4319   /* TODO also make keyframe aware if useful some day */
4320 
4321   time = *_time;
4322 
4323   /* basic cases */
4324   if (time == 0) {
4325     *_offset = 0;
4326     return GST_FLOW_OK;
4327   }
4328 
4329   if (time == -1) {
4330     *_offset = -1;
4331     return GST_FLOW_OK;
4332   }
4333 
4334   /* do not know at first */
4335   *_offset = -1;
4336   *_time = GST_CLOCK_TIME_NONE;
4337 
4338   /* need initial positions; start and end */
4339   lpos = parse-&gt;priv-&gt;first_frame_offset;
4340   ltime = parse-&gt;priv-&gt;first_frame_pts;
4341   /* try other one if no luck */
4342   if (!GST_CLOCK_TIME_IS_VALID (ltime))
4343     ltime = parse-&gt;priv-&gt;first_frame_dts;
4344   if (!gst_base_parse_get_duration (parse, GST_FORMAT_TIME, &amp;htime)) {
4345     GST_DEBUG_OBJECT (parse, &quot;Unknown time duration, cannot bisect&quot;);
4346     return GST_FLOW_ERROR;
4347   }
4348   hpos = parse-&gt;priv-&gt;upstream_size;
4349 
4350   GST_DEBUG_OBJECT (parse,
4351       &quot;Bisection initial bounds: bytes %&quot; G_GINT64_FORMAT &quot; %&quot; G_GINT64_FORMAT
4352       &quot;, times %&quot; GST_TIME_FORMAT &quot; %&quot; GST_TIME_FORMAT, lpos, hpos,
4353       GST_TIME_ARGS (ltime), GST_TIME_ARGS (htime));
4354 
4355   /* check preconditions are satisfied;
4356    * start and end are needed, except for special case where we scan for
4357    * last frame to determine duration */
4358   if (parse-&gt;priv-&gt;pad_mode != GST_PAD_MODE_PULL || !hpos ||
4359       !GST_CLOCK_TIME_IS_VALID (ltime) ||
4360       (!GST_CLOCK_TIME_IS_VALID (htime) &amp;&amp; time != G_MAXINT64)) {
4361     return GST_FLOW_OK;
4362   }
4363 
4364   /* shortcut cases */
4365   if (time &lt; ltime) {
4366     goto exit;
4367   } else if (time &lt; ltime + tolerance) {
4368     *_offset = lpos;
4369     *_time = ltime;
4370     goto exit;
4371   } else if (time &gt;= htime) {
4372     *_offset = hpos;
4373     *_time = htime;
4374     goto exit;
4375   }
4376 
4377   while (htime &gt; ltime &amp;&amp; cont) {
4378     GST_LOG_OBJECT (parse,
4379         &quot;lpos: %&quot; G_GUINT64_FORMAT &quot;, ltime: %&quot; GST_TIME_FORMAT, lpos,
4380         GST_TIME_ARGS (ltime));
4381     GST_LOG_OBJECT (parse,
4382         &quot;hpos: %&quot; G_GUINT64_FORMAT &quot;, htime: %&quot; GST_TIME_FORMAT, hpos,
4383         GST_TIME_ARGS (htime));
4384     if (G_UNLIKELY (time == G_MAXINT64)) {
4385       newpos = hpos;
4386     } else if (G_LIKELY (hpos &gt; lpos)) {
4387       newpos =
4388           gst_util_uint64_scale (hpos - lpos, time - ltime, htime - ltime) +
4389           lpos - chunk;
4390     } else {
4391       /* should mean lpos == hpos, since lpos &lt;= hpos is invariant */
4392       newpos = lpos;
4393       /* we check this case once, but not forever, so break loop */
4394       cont = FALSE;
4395     }
4396 
4397     /* ensure */
4398     newpos = CLAMP (newpos, lpos, hpos);
4399     GST_LOG_OBJECT (parse,
4400         &quot;estimated _offset for %&quot; GST_TIME_FORMAT &quot;: %&quot; G_GINT64_FORMAT,
4401         GST_TIME_ARGS (time), newpos);
4402 
4403     ret = gst_base_parse_find_frame (parse, &amp;newpos, &amp;newtime, &amp;dur);
4404     if (ret == GST_FLOW_EOS) {
4405       /* heuristic HACK */
4406       hpos = MAX (lpos, hpos - chunk);
4407       continue;
4408     } else if (ret != GST_FLOW_OK) {
4409       goto exit;
4410     }
4411 
4412     if (newtime == -1 || newpos == -1) {
4413       GST_DEBUG_OBJECT (parse, &quot;subclass did not provide metadata; aborting&quot;);
4414       break;
4415     }
4416 
4417     if (G_UNLIKELY (time == G_MAXINT64)) {
4418       *_offset = newpos;
4419       *_time = newtime;
4420       if (GST_CLOCK_TIME_IS_VALID (dur))
4421         *_time += dur;
4422       break;
4423     } else if (newtime &gt; time) {
4424       /* overshoot */
4425       hpos = (newpos &gt;= hpos) ? MAX (lpos, hpos - chunk) : MAX (lpos, newpos);
4426       htime = newtime;
4427     } else if (newtime + tolerance &gt; time) {
4428       /* close enough undershoot */
4429       *_offset = newpos;
4430       *_time = newtime;
4431       break;
4432     } else if (newtime &lt; ltime) {
4433       /* so a position beyond lpos resulted in earlier time than ltime ... */
4434       GST_DEBUG_OBJECT (parse, &quot;non-ascending time; aborting&quot;);
4435       break;
4436     } else {
4437       /* undershoot too far */
4438       newpos += newpos == lpos ? chunk : 0;
4439       lpos = CLAMP (newpos, lpos, hpos);
4440       ltime = newtime;
4441     }
4442   }
4443 
4444 exit:
4445   GST_LOG_OBJECT (parse, &quot;return offset %&quot; G_GINT64_FORMAT &quot;, time %&quot;
4446       GST_TIME_FORMAT, *_offset, GST_TIME_ARGS (*_time));
4447   return ret;
4448 }
4449 
4450 static gint64
4451 gst_base_parse_find_offset (GstBaseParse * parse, GstClockTime time,
4452     gboolean before, GstClockTime * _ts)
4453 {
4454   gint64 bytes = 0, ts = 0;
4455   GstIndexEntry *entry = NULL;
4456 
4457   if (time == GST_CLOCK_TIME_NONE) {
4458     ts = time;
4459     bytes = -1;
4460     goto exit;
4461   }
4462 
4463   GST_BASE_PARSE_INDEX_LOCK (parse);
4464   if (parse-&gt;priv-&gt;index) {
4465     /* Let&#39;s check if we have an index entry for that time */
4466     entry = gst_index_get_assoc_entry (parse-&gt;priv-&gt;index,
4467         parse-&gt;priv-&gt;index_id,
4468         before ? GST_INDEX_LOOKUP_BEFORE : GST_INDEX_LOOKUP_AFTER,
4469         GST_INDEX_ASSOCIATION_FLAG_KEY_UNIT, GST_FORMAT_TIME, time);
4470   }
4471 
4472   if (entry) {
4473     gst_index_entry_assoc_map (entry, GST_FORMAT_BYTES, &amp;bytes);
4474     gst_index_entry_assoc_map (entry, GST_FORMAT_TIME, &amp;ts);
4475 
4476     GST_DEBUG_OBJECT (parse, &quot;found index entry for %&quot; GST_TIME_FORMAT
4477         &quot; at %&quot; GST_TIME_FORMAT &quot;, offset %&quot; G_GINT64_FORMAT,
4478         GST_TIME_ARGS (time), GST_TIME_ARGS (ts), bytes);
4479   } else {
4480     GST_DEBUG_OBJECT (parse, &quot;no index entry found for %&quot; GST_TIME_FORMAT,
4481         GST_TIME_ARGS (time));
4482     if (!before) {
4483       bytes = -1;
4484       ts = GST_CLOCK_TIME_NONE;
4485     }
4486   }
4487   GST_BASE_PARSE_INDEX_UNLOCK (parse);
4488 
4489 exit:
4490   if (_ts)
4491     *_ts = ts;
4492 
4493   return bytes;
4494 }
4495 
4496 /* returns TRUE if seek succeeded */
4497 static gboolean
4498 gst_base_parse_handle_seek (GstBaseParse * parse, GstEvent * event)
4499 {
4500   gdouble rate;
4501   GstFormat format;
4502   GstSeekFlags flags;
4503   GstSeekType start_type = GST_SEEK_TYPE_NONE, stop_type;
4504   gboolean flush, update, res = TRUE, accurate;
4505   gint64 start, stop, seekpos, seekstop;
4506   GstSegment seeksegment = { 0, };
4507   GstClockTime start_ts;
4508   guint32 seqnum;
4509   GstEvent *segment_event;
4510 
4511   /* try upstream first, unless we&#39;re driving the streaming thread ourselves */
4512   if (parse-&gt;priv-&gt;pad_mode != GST_PAD_MODE_PULL) {
4513     res = gst_pad_push_event (parse-&gt;sinkpad, gst_event_ref (event));
4514     if (res)
4515       goto done;
4516   }
4517 
4518   gst_event_parse_seek (event, &amp;rate, &amp;format, &amp;flags,
4519       &amp;start_type, &amp;start, &amp;stop_type, &amp;stop);
4520   seqnum = gst_event_get_seqnum (event);
4521 
4522   GST_DEBUG_OBJECT (parse, &quot;seek to format %s, rate %f, &quot;
4523       &quot;start type %d at %&quot; GST_TIME_FORMAT &quot;, end type %d at %&quot;
4524       GST_TIME_FORMAT, gst_format_get_name (format), rate,
4525       start_type, GST_TIME_ARGS (start), stop_type, GST_TIME_ARGS (stop));
4526 
4527   /* we can only handle TIME, so check if subclass can convert
4528    * to TIME format if it&#39;s some other format (such as DEFAULT) */
4529   if (format != GST_FORMAT_TIME) {
4530     if (!gst_base_parse_convert (parse, format, start, GST_FORMAT_TIME, &amp;start)
4531         || !gst_base_parse_convert (parse, format, stop, GST_FORMAT_TIME,
4532             &amp;stop))
4533       goto no_convert_to_time;
4534 
4535     GST_INFO_OBJECT (parse, &quot;converted %s format to start time &quot;
4536         &quot;%&quot; GST_TIME_FORMAT &quot; and stop time %&quot; GST_TIME_FORMAT,
4537         gst_format_get_name (format), GST_TIME_ARGS (start),
4538         GST_TIME_ARGS (stop));
4539 
4540     format = GST_FORMAT_TIME;
4541   }
4542 
4543   /* no negative rates in push mode (unless upstream takes care of that, but
4544    * we&#39;ve already tried upstream and it didn&#39;t handle the seek request) */
4545   if (rate &lt; 0.0 &amp;&amp; parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_PUSH)
4546     goto negative_rate;
4547 
4548   if (start_type != GST_SEEK_TYPE_SET ||
4549       (stop_type != GST_SEEK_TYPE_SET &amp;&amp; stop_type != GST_SEEK_TYPE_NONE))
4550     goto wrong_type;
4551 
4552   /* get flush flag */
4553   flush = flags &amp; GST_SEEK_FLAG_FLUSH;
4554 
4555   /* copy segment, we need this because we still need the old
4556    * segment when we close the current segment. */
4557   gst_segment_copy_into (&amp;parse-&gt;segment, &amp;seeksegment);
4558 
4559   GST_DEBUG_OBJECT (parse, &quot;configuring seek&quot;);
4560   gst_segment_do_seek (&amp;seeksegment, rate, format, flags,
4561       start_type, start, stop_type, stop, &amp;update);
4562 
4563   /* accurate seeking implies seek tables are used to obtain position,
4564    * and the requested segment is maintained exactly, not adjusted any way */
4565   accurate = flags &amp; GST_SEEK_FLAG_ACCURATE;
4566 
4567   /* maybe we can be accurate for (almost) free */
4568   gst_base_parse_find_offset (parse, seeksegment.position, TRUE, &amp;start_ts);
4569   if (seeksegment.position &lt;= start_ts + TARGET_DIFFERENCE) {
4570     GST_DEBUG_OBJECT (parse, &quot;accurate seek possible&quot;);
4571     accurate = TRUE;
4572   }
4573 
4574   if (accurate) {
4575     GstClockTime startpos;
4576     if (rate &gt;= 0)
4577       startpos = seeksegment.position;
4578     else
4579       startpos = start;
4580 
4581     /* accurate requested, so ... seek a bit before target */
4582     if (startpos &lt; parse-&gt;priv-&gt;lead_in_ts)
4583       startpos = 0;
4584     else
4585       startpos -= parse-&gt;priv-&gt;lead_in_ts;
4586 
4587     if (seeksegment.stop == -1 &amp;&amp; seeksegment.duration != -1)
4588       seeksegment.stop = seeksegment.start + seeksegment.duration;
4589 
4590     seekpos = gst_base_parse_find_offset (parse, startpos, TRUE, &amp;start_ts);
4591     seekstop = gst_base_parse_find_offset (parse, seeksegment.stop, FALSE,
4592         NULL);
4593   } else {
4594     if (rate &gt;= 0)
4595     start_ts = seeksegment.position;
4596     else
4597       start_ts = start;
4598 
4599     if (seeksegment.stop == -1 &amp;&amp; seeksegment.duration != -1)
4600       seeksegment.stop = seeksegment.start + seeksegment.duration;
4601 
4602     if (!gst_base_parse_convert (parse, format, start_ts,
4603             GST_FORMAT_BYTES, &amp;seekpos))
4604       goto convert_failed;
4605     if (!gst_base_parse_convert (parse, format, seeksegment.stop,
4606             GST_FORMAT_BYTES, &amp;seekstop))
4607       goto convert_failed;
4608   }
4609 
4610   GST_DEBUG_OBJECT (parse,
4611       &quot;seek position %&quot; G_GINT64_FORMAT &quot; in bytes: %&quot; G_GINT64_FORMAT,
4612       start_ts, seekpos);
4613   GST_DEBUG_OBJECT (parse,
4614       &quot;seek stop %&quot; G_GINT64_FORMAT &quot; in bytes: %&quot; G_GINT64_FORMAT,
4615       seeksegment.stop, seekstop);
4616 
4617   if (parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_PULL) {
4618     gint64 last_stop;
4619 
4620     GST_DEBUG_OBJECT (parse, &quot;seek in PULL mode&quot;);
4621 
4622     if (flush) {
4623       if (parse-&gt;srcpad) {
4624         GstEvent *fevent = gst_event_new_flush_start ();
4625         GST_DEBUG_OBJECT (parse, &quot;sending flush start&quot;);
4626 
4627         gst_event_set_seqnum (fevent, seqnum);
4628 
4629         gst_pad_push_event (parse-&gt;srcpad, gst_event_ref (fevent));
4630         /* unlock upstream pull_range */
4631         gst_pad_push_event (parse-&gt;sinkpad, fevent);
4632       }
4633     } else {
4634       gst_pad_pause_task (parse-&gt;sinkpad);
4635     }
4636 
4637     /* we should now be able to grab the streaming thread because we stopped it
4638      * with the above flush/pause code */
4639     GST_PAD_STREAM_LOCK (parse-&gt;sinkpad);
4640 
4641     /* save current position */
4642     last_stop = parse-&gt;segment.position;
4643     GST_DEBUG_OBJECT (parse, &quot;stopped streaming at %&quot; G_GINT64_FORMAT,
4644         last_stop);
4645 
4646     /* now commit to new position */
4647 
4648     /* prepare for streaming again */
4649     if (flush) {
4650       GstEvent *fevent = gst_event_new_flush_stop (TRUE);
4651       GST_DEBUG_OBJECT (parse, &quot;sending flush stop&quot;);
4652       gst_event_set_seqnum (fevent, seqnum);
4653       gst_pad_push_event (parse-&gt;srcpad, gst_event_ref (fevent));
4654       gst_pad_push_event (parse-&gt;sinkpad, fevent);
4655       gst_base_parse_clear_queues (parse);
4656     }
4657 
4658     memcpy (&amp;parse-&gt;segment, &amp;seeksegment, sizeof (GstSegment));
4659 
4660     /* store the newsegment event so it can be sent from the streaming thread. */
4661     /* This will be sent later in _loop() */
4662     segment_event = gst_event_new_segment (&amp;parse-&gt;segment);
4663     gst_event_set_seqnum (segment_event, seqnum);
4664     parse-&gt;priv-&gt;pending_events =
4665         g_list_prepend (parse-&gt;priv-&gt;pending_events, segment_event);
4666 
4667     GST_DEBUG_OBJECT (parse, &quot;Created newseg format %d, &quot;
4668         &quot;start = %&quot; GST_TIME_FORMAT &quot;, stop = %&quot; GST_TIME_FORMAT
4669         &quot;, time = %&quot; GST_TIME_FORMAT, format,
4670         GST_TIME_ARGS (parse-&gt;segment.start),
4671         GST_TIME_ARGS (parse-&gt;segment.stop),
4672         GST_TIME_ARGS (parse-&gt;segment.time));
4673 
4674     /* one last chance in pull mode to stay accurate;
4675      * maybe scan and subclass can find where to go */
4676     if (!accurate) {
4677       gint64 scanpos;
4678       GstClockTime ts = seeksegment.position;
4679 
4680       gst_base_parse_locate_time (parse, &amp;ts, &amp;scanpos);
4681       if (scanpos &gt;= 0) {
4682         accurate = TRUE;
4683         seekpos = scanpos;
4684         /* running collected index now consists of several intervals,
4685          * so optimized check no longer possible */
4686         parse-&gt;priv-&gt;index_last_valid = FALSE;
4687         parse-&gt;priv-&gt;index_last_offset = 0;
4688         parse-&gt;priv-&gt;index_last_ts = 0;
4689       }
4690     }
4691 
4692     /* mark discont if we are going to stream from another position. */
4693     if (seekpos != parse-&gt;priv-&gt;offset) {
4694       GST_DEBUG_OBJECT (parse,
4695           &quot;mark DISCONT, we did a seek to another position&quot;);
4696       parse-&gt;priv-&gt;offset = seekpos;
4697       parse-&gt;priv-&gt;last_offset = seekpos;
4698       parse-&gt;priv-&gt;seen_keyframe = FALSE;
4699       parse-&gt;priv-&gt;discont = TRUE;
4700       parse-&gt;priv-&gt;next_dts = start_ts;
4701       parse-&gt;priv-&gt;next_pts = GST_CLOCK_TIME_NONE;
4702       parse-&gt;priv-&gt;last_dts = GST_CLOCK_TIME_NONE;
4703       parse-&gt;priv-&gt;last_pts = GST_CLOCK_TIME_NONE;
4704       parse-&gt;priv-&gt;sync_offset = seekpos;
4705       parse-&gt;priv-&gt;exact_position = accurate;
4706     }
4707 
4708     /* Start streaming thread if paused */
4709     gst_pad_start_task (parse-&gt;sinkpad,
4710         (GstTaskFunction) gst_base_parse_loop, parse-&gt;sinkpad, NULL);
4711 
4712     GST_PAD_STREAM_UNLOCK (parse-&gt;sinkpad);
4713 
4714     /* handled seek */
4715     res = TRUE;
4716   } else {
4717     GstEvent *new_event;
4718     GstBaseParseSeek *seek;
4719     GstSeekFlags flags = (flush ? GST_SEEK_FLAG_FLUSH : GST_SEEK_FLAG_NONE);
4720 
4721     /* The only thing we need to do in PUSH-mode is to send the
4722        seek event (in bytes) to upstream. Segment / flush handling happens
4723        in corresponding src event handlers */
4724     GST_DEBUG_OBJECT (parse, &quot;seek in PUSH mode&quot;);
4725     if (seekstop &gt;= 0 &amp;&amp; seekstop &lt;= seekpos)
4726       seekstop = seekpos;
4727     new_event = gst_event_new_seek (rate, GST_FORMAT_BYTES, flags,
4728         GST_SEEK_TYPE_SET, seekpos, stop_type, seekstop);
4729     gst_event_set_seqnum (new_event, seqnum);
4730 
4731     /* store segment info so its precise details can be reconstructed when
4732      * receiving newsegment;
4733      * this matters for all details when accurate seeking,
4734      * is most useful to preserve NONE stop time otherwise */
4735     seek = g_new0 (GstBaseParseSeek, 1);
4736     seek-&gt;segment = seeksegment;
4737     seek-&gt;accurate = accurate;
4738     seek-&gt;offset = seekpos;
4739     seek-&gt;start_ts = start_ts;
4740     GST_OBJECT_LOCK (parse);
4741     /* less optimal, but preserves order */
4742     parse-&gt;priv-&gt;pending_seeks =
4743         g_slist_append (parse-&gt;priv-&gt;pending_seeks, seek);
4744     GST_OBJECT_UNLOCK (parse);
4745 
4746     res = gst_pad_push_event (parse-&gt;sinkpad, new_event);
4747 
4748     if (!res) {
4749       GST_OBJECT_LOCK (parse);
4750       parse-&gt;priv-&gt;pending_seeks =
4751           g_slist_remove (parse-&gt;priv-&gt;pending_seeks, seek);
4752       GST_OBJECT_UNLOCK (parse);
4753       g_free (seek);
4754     }
4755   }
4756 
4757 done:
4758     gst_event_unref (event);
4759   return res;
4760 
4761   /* ERRORS */
4762 negative_rate:
4763   {
4764     GST_DEBUG_OBJECT (parse, &quot;negative playback rates delegated upstream.&quot;);
4765     res = FALSE;
4766     goto done;
4767   }
4768 wrong_type:
4769   {
4770     GST_DEBUG_OBJECT (parse, &quot;unsupported seek type.&quot;);
4771     res = FALSE;
4772     goto done;
4773   }
4774 no_convert_to_time:
4775   {
4776     GST_DEBUG_OBJECT (parse, &quot;seek in %s format was requested, but subclass &quot;
4777         &quot;couldn&#39;t convert that into TIME format&quot;, gst_format_get_name (format));
4778     res = FALSE;
4779     goto done;
4780   }
4781 convert_failed:
4782   {
4783     GST_DEBUG_OBJECT (parse, &quot;conversion TIME to BYTES failed.&quot;);
4784     res = FALSE;
4785     goto done;
4786   }
4787 }
4788 
4789 static void
4790 gst_base_parse_set_upstream_tags (GstBaseParse * parse, GstTagList * taglist)
4791 {
4792   if (taglist == parse-&gt;priv-&gt;upstream_tags)
4793     return;
4794 
4795   if (parse-&gt;priv-&gt;upstream_tags) {
4796     gst_tag_list_unref (parse-&gt;priv-&gt;upstream_tags);
4797     parse-&gt;priv-&gt;upstream_tags = NULL;
4798   }
4799 
4800   GST_INFO_OBJECT (parse, &quot;upstream tags: %&quot; GST_PTR_FORMAT, taglist);
4801 
4802   if (taglist != NULL)
4803     parse-&gt;priv-&gt;upstream_tags = gst_tag_list_ref (taglist);
4804 
4805   gst_base_parse_check_bitrate_tags (parse);
4806   }
4807 
4808 #if 0
4809 static void
4810 gst_base_parse_set_index (GstElement * element, GstIndex * index)
4811 {
4812   GstBaseParse *parse = GST_BASE_PARSE (element);
4813 
4814   GST_BASE_PARSE_INDEX_LOCK (parse);
4815   if (parse-&gt;priv-&gt;index)
4816     gst_object_unref (parse-&gt;priv-&gt;index);
4817   if (index) {
4818     parse-&gt;priv-&gt;index = gst_object_ref (index);
4819     gst_index_get_writer_id (index, GST_OBJECT_CAST (element),
4820         &amp;parse-&gt;priv-&gt;index_id);
4821     parse-&gt;priv-&gt;own_index = FALSE;
4822   } else {
4823     parse-&gt;priv-&gt;index = NULL;
4824   }
4825   GST_BASE_PARSE_INDEX_UNLOCK (parse);
4826 }
4827 
4828 static GstIndex *
4829 gst_base_parse_get_index (GstElement * element)
4830 {
4831   GstBaseParse *parse = GST_BASE_PARSE (element);
4832   GstIndex *result = NULL;
4833 
4834   GST_BASE_PARSE_INDEX_LOCK (parse);
4835   if (parse-&gt;priv-&gt;index)
4836     result = gst_object_ref (parse-&gt;priv-&gt;index);
4837   GST_BASE_PARSE_INDEX_UNLOCK (parse);
4838 
4839   return result;
4840 }
4841 #endif
4842 
4843 static GstStateChangeReturn
4844 gst_base_parse_change_state (GstElement * element, GstStateChange transition)
4845 {
4846   GstBaseParse *parse;
4847   GstStateChangeReturn result;
4848 
4849   parse = GST_BASE_PARSE (element);
4850 
4851   switch (transition) {
4852     case GST_STATE_CHANGE_READY_TO_PAUSED:
4853       /* If this is our own index destroy it as the
4854        * old entries might be wrong for the new stream */
4855       GST_BASE_PARSE_INDEX_LOCK (parse);
4856       if (parse-&gt;priv-&gt;own_index) {
4857         gst_object_unref (parse-&gt;priv-&gt;index);
4858         parse-&gt;priv-&gt;index = NULL;
4859         parse-&gt;priv-&gt;own_index = FALSE;
4860       }
4861 
4862       /* If no index was created, generate one */
4863       if (G_UNLIKELY (!parse-&gt;priv-&gt;index)) {
4864         GST_DEBUG_OBJECT (parse, &quot;no index provided creating our own&quot;);
4865 
4866         parse-&gt;priv-&gt;index = g_object_new (gst_mem_index_get_type (), NULL);
4867         gst_index_get_writer_id (parse-&gt;priv-&gt;index, GST_OBJECT (parse),
4868             &amp;parse-&gt;priv-&gt;index_id);
4869         parse-&gt;priv-&gt;own_index = TRUE;
4870       }
4871       GST_BASE_PARSE_INDEX_UNLOCK (parse);
4872       break;
4873     default:
4874       break;
4875   }
4876 
4877   result = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
4878 
4879   switch (transition) {
4880     case GST_STATE_CHANGE_PAUSED_TO_READY:
4881       gst_base_parse_reset (parse);
4882       break;
4883     default:
4884       break;
4885   }
4886 
4887   return result;
4888 }
4889 
4890 /**
4891  * gst_base_parse_set_ts_at_offset:
4892  * @parse: a #GstBaseParse
4893  * @offset: offset into current buffer
4894  *
4895  * This function should only be called from a @handle_frame implementation.
4896  *
4897  * #GstBaseParse creates initial timestamps for frames by using the last
4898  * timestamp seen in the stream before the frame starts.  In certain
4899  * cases, the correct timestamps will occur in the stream after the
4900  * start of the frame, but before the start of the actual picture data.
4901  * This function can be used to set the timestamps based on the offset
4902  * into the frame data that the picture starts.
4903  *
4904  * Since: 1.2
4905  */
4906 void
4907 gst_base_parse_set_ts_at_offset (GstBaseParse * parse, gsize offset)
4908 {
4909   GstClockTime pts, dts;
4910 
4911   g_return_if_fail (GST_IS_BASE_PARSE (parse));
4912 
4913   pts = gst_adapter_prev_pts_at_offset (parse-&gt;priv-&gt;adapter, offset, NULL);
4914   dts = gst_adapter_prev_dts_at_offset (parse-&gt;priv-&gt;adapter, offset, NULL);
4915 
4916   if (!GST_CLOCK_TIME_IS_VALID (pts) || !GST_CLOCK_TIME_IS_VALID (dts)) {
4917     GST_DEBUG_OBJECT (parse,
4918         &quot;offset adapter timestamps dts=%&quot; GST_TIME_FORMAT &quot; pts=%&quot;
4919         GST_TIME_FORMAT, GST_TIME_ARGS (dts), GST_TIME_ARGS (pts));
4920   }
4921   if (GST_CLOCK_TIME_IS_VALID (pts) &amp;&amp; (parse-&gt;priv-&gt;prev_pts != pts))
4922     parse-&gt;priv-&gt;prev_pts = parse-&gt;priv-&gt;next_pts = pts;
4923 
4924   if (GST_CLOCK_TIME_IS_VALID (dts) &amp;&amp; (parse-&gt;priv-&gt;prev_dts != dts)) {
4925     parse-&gt;priv-&gt;prev_dts = parse-&gt;priv-&gt;next_dts = dts;
4926     parse-&gt;priv-&gt;prev_dts_from_pts = FALSE;
4927 }
4928 }
4929 
4930 /**
4931  * gst_base_parse_merge_tags:
4932  * @parse: a #GstBaseParse
4933  * @tags: (allow-none): a #GstTagList to merge, or NULL to unset
4934  *     previously-set tags
4935  * @mode: the #GstTagMergeMode to use, usually #GST_TAG_MERGE_REPLACE
4936  *
4937  * Sets the parser subclass&#39;s tags and how they should be merged with any
4938  * upstream stream tags. This will override any tags previously-set
4939  * with gst_base_parse_merge_tags().
4940  *
4941  * Note that this is provided for convenience, and the subclass is
4942  * not required to use this and can still do tag handling on its own.
4943  *
4944  * Since: 1.6
4945  */
4946 void
4947 gst_base_parse_merge_tags (GstBaseParse * parse, GstTagList * tags,
4948     GstTagMergeMode mode)
4949 {
4950   g_return_if_fail (GST_IS_BASE_PARSE (parse));
4951   g_return_if_fail (tags == NULL || GST_IS_TAG_LIST (tags));
4952   g_return_if_fail (tags == NULL || mode != GST_TAG_MERGE_UNDEFINED);
4953 
4954   GST_OBJECT_LOCK (parse);
4955 
4956   if (tags != parse-&gt;priv-&gt;parser_tags) {
4957     if (parse-&gt;priv-&gt;parser_tags) {
4958       gst_tag_list_unref (parse-&gt;priv-&gt;parser_tags);
4959       parse-&gt;priv-&gt;parser_tags = NULL;
4960       parse-&gt;priv-&gt;parser_tags_merge_mode = GST_TAG_MERGE_APPEND;
4961     }
4962     if (tags) {
4963       parse-&gt;priv-&gt;parser_tags = gst_tag_list_ref (tags);
4964       parse-&gt;priv-&gt;parser_tags_merge_mode = mode;
4965     }
4966 
4967     GST_DEBUG_OBJECT (parse, &quot;setting parser tags to %&quot; GST_PTR_FORMAT
4968         &quot; (mode %d)&quot;, tags, parse-&gt;priv-&gt;parser_tags_merge_mode);
4969 
4970     gst_base_parse_check_bitrate_tags (parse);
4971     parse-&gt;priv-&gt;tags_changed = TRUE;
4972   }
4973 
4974   GST_OBJECT_UNLOCK (parse);
4975 }
    </pre>
  </body>
</html>