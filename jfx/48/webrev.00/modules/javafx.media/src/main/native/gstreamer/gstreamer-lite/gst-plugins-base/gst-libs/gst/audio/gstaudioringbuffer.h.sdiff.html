<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudioringbuffer.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstaudioringbuffer.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstaudiosink.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudioringbuffer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 43 
 44 /**
 45  * GstAudioRingBufferCallback:
 46  * @rbuf: a #GstAudioRingBuffer
 47  * @data: (array length=len): target to fill
 48  * @len: amount to fill
 49  * @user_data: user data
 50  *
 51  * This function is set with gst_audio_ring_buffer_set_callback() and is
 52  * called to fill the memory at @data with @len bytes of samples.
 53  */
 54 typedef void (*GstAudioRingBufferCallback) (GstAudioRingBuffer *rbuf, guint8* data, guint len, gpointer user_data);
 55 
 56 /**
 57  * GstAudioRingBufferState:
 58  * @GST_AUDIO_RING_BUFFER_STATE_STOPPED: The ringbuffer is stopped
 59  * @GST_AUDIO_RING_BUFFER_STATE_PAUSED: The ringbuffer is paused
 60  * @GST_AUDIO_RING_BUFFER_STATE_STARTED: The ringbuffer is started
 61  * @GST_AUDIO_RING_BUFFER_STATE_ERROR: The ringbuffer has encountered an
 62  *     error after it has been started, e.g. because the device was
<span class="line-modified"> 63  *     disconnected (Since 1.2)</span>
 64  *
 65  * The state of the ringbuffer.
 66  */
 67 typedef enum {
 68   GST_AUDIO_RING_BUFFER_STATE_STOPPED,
 69   GST_AUDIO_RING_BUFFER_STATE_PAUSED,
 70   GST_AUDIO_RING_BUFFER_STATE_STARTED,
 71   GST_AUDIO_RING_BUFFER_STATE_ERROR
 72 } GstAudioRingBufferState;
 73 
 74 /**
 75  * GstAudioRingBufferFormatType:
 76  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW: samples in linear or float
 77  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MU_LAW: samples in mulaw
 78  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_A_LAW: samples in alaw
 79  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IMA_ADPCM: samples in ima adpcm
 80  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG: samples in mpeg audio (but not AAC) format
 81  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_GSM: samples in gsm format
 82  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IEC958: samples in IEC958 frames (e.g. AC3)
 83  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_AC3: samples in AC3 format
 84  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_EAC3: samples in EAC3 format
 85  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DTS: samples in DTS format
 86  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC: samples in MPEG-2 AAC ADTS format
 87  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC: samples in MPEG-4 AAC ADTS format
<span class="line-modified"> 88  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC_RAW: samples in MPEG-2 AAC raw format (Since 1.12)</span>
<span class="line-modified"> 89  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC_RAW: samples in MPEG-4 AAC raw format (Since 1.12)</span>
<span class="line-modified"> 90  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_FLAC: samples in FLAC format (Since 1.12)</span>
 91  *
 92  * The format of the samples in the ringbuffer.
 93  */
 94 typedef enum
 95 {
 96   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW,
 97   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MU_LAW,
 98   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_A_LAW,
 99   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IMA_ADPCM,
100   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG,
101   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_GSM,
102   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IEC958,
103   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_AC3,
104   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_EAC3,
105   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DTS,
106   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC,
107   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC,
108   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC_RAW,
109   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC_RAW,
110   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_FLAC
</pre>
<hr />
<pre>
119  * @buffer_time: the total buffer size in microseconds
120  * @segsize: the size of one segment in bytes
121  * @segtotal: the total number of segments
122  * @seglatency: number of segments queued in the lower level device,
123  *  defaults to segtotal
124  *
125  * The structure containing the format specification of the ringbuffer.
126  */
127 struct _GstAudioRingBufferSpec
128 {
129   /*&lt; public &gt;*/
130   /* in */
131   GstCaps  *caps;               /* the caps of the buffer */
132 
133   /* in/out */
134   GstAudioRingBufferFormatType  type;
135   GstAudioInfo                  info;
136 
137 
138   guint64  latency_time;        /* the required/actual latency time, this is the
<span class="line-modified">139                  * actual the size of one segment and the</span>
<span class="line-modified">140                  * minimum possible latency we can achieve. */</span>
141   guint64  buffer_time;         /* the required/actual time of the buffer, this is
<span class="line-modified">142                  * the total size of the buffer and maximum</span>
<span class="line-modified">143                  * latency we can compensate for. */</span>
144   gint     segsize;             /* size of one buffer segment in bytes, this value
<span class="line-modified">145                  * should be chosen to match latency_time as</span>
<span class="line-modified">146                  * well as possible. */</span>
147   gint     segtotal;            /* total number of segments, this value is the
<span class="line-modified">148                  * number of segments of @segsize and should be</span>
<span class="line-modified">149                  * chosen so that it matches buffer_time as</span>
<span class="line-modified">150                  * close as possible. */</span>
151   /* ABI added 0.10.20 */
152   gint     seglatency;          /* number of segments queued in the lower
<span class="line-modified">153                  * level device, defaults to segtotal. */</span>
154 
155   /*&lt; private &gt;*/
156   gpointer _gst_reserved[GST_PADDING];
157 };
158 
159 #define GST_AUDIO_RING_BUFFER_GET_COND(buf) (&amp;(((GstAudioRingBuffer *)buf)-&gt;cond))
160 #define GST_AUDIO_RING_BUFFER_WAIT(buf)     (g_cond_wait (GST_AUDIO_RING_BUFFER_GET_COND (buf), GST_OBJECT_GET_LOCK (buf)))
161 #define GST_AUDIO_RING_BUFFER_SIGNAL(buf)   (g_cond_signal (GST_AUDIO_RING_BUFFER_GET_COND (buf)))
162 #define GST_AUDIO_RING_BUFFER_BROADCAST(buf)(g_cond_broadcast (GST_AUDIO_RING_BUFFER_GET_COND (buf)))
163 
164 /**
165  * GstAudioRingBuffer:
166  * @cond: used to signal start/stop/pause/resume actions
167  * @open: boolean indicating that the ringbuffer is open
168  * @acquired: boolean indicating that the ringbuffer is acquired
169  * @memory: data in the ringbuffer
170  * @size: size of data in the ringbuffer
171  * @spec: format and layout of the ringbuffer data
172  * @samples_per_seg: number of samples in one segment
173  * @empty_seg: pointer to memory holding one segment of silence samples
174  * @state: state of the buffer
175  * @segdone: readpointer in the ringbuffer
176  * @segbase: segment corresponding to segment 0 (unused)
177  * @waiting: is a reader or writer waiting for a free segment
178  *
179  * The ringbuffer base class structure.
180  */
181 struct _GstAudioRingBuffer {
182   GstObject                   object;
183 
184   /*&lt; public &gt;*/ /* with LOCK */
185   GCond                      cond;
186   gboolean                    open;
187   gboolean                    acquired;
188   guint8                     *memory;
189   gsize                       size;

190   GstClockTime               *timestamps;

191   GstAudioRingBufferSpec      spec;
192   gint                        samples_per_seg;
193   guint8                     *empty_seg;
194 
195   /*&lt; public &gt;*/ /* ATOMIC */
196   gint                        state;
197   gint                        segdone;
198   gint                        segbase;
199   gint                        waiting;
200 
201   /*&lt; private &gt;*/
202   GstAudioRingBufferCallback  callback;
203   gpointer                    cb_data;
204 
205   gboolean                    need_reorder;
206   /* gst[channel_reorder_map[i]] = device[i] */
207   gint                        channel_reorder_map[64];
208 
209   gboolean                    flushing;
210   /* ATOMIC */
</pre>
<hr />
<pre>
255   /* ABI added */
256   gboolean     (*activate)     (GstAudioRingBuffer *buf, gboolean active);
257 
258   guint        (*commit)       (GstAudioRingBuffer * buf, guint64 *sample,
259                                 guint8 * data, gint in_samples,
260                                 gint out_samples, gint * accum);
261 
262   void         (*clear_all)    (GstAudioRingBuffer * buf);
263 
264   /*&lt; private &gt;*/
265   gpointer _gst_reserved[GST_PADDING];
266 };
267 
268 GST_AUDIO_API
269 GType gst_audio_ring_buffer_get_type(void);
270 
271 /* callback stuff */
272 
273 GST_AUDIO_API
274 void            gst_audio_ring_buffer_set_callback      (GstAudioRingBuffer *buf,
<span class="line-modified">275                                                        GstAudioRingBufferCallback cb,</span>
<span class="line-modified">276                                                        gpointer user_data);</span>
277 
278 GST_AUDIO_API
279 void            gst_audio_ring_buffer_set_callback_full (GstAudioRingBuffer *buf,
280                                                          GstAudioRingBufferCallback cb,
281                                                          gpointer user_data,
282                                                          GDestroyNotify notify);
283 
284 GST_AUDIO_API
285 gboolean        gst_audio_ring_buffer_parse_caps      (GstAudioRingBufferSpec *spec, GstCaps *caps);
286 
287 GST_AUDIO_API
288 void            gst_audio_ring_buffer_debug_spec_caps (GstAudioRingBufferSpec *spec);
289 
290 GST_AUDIO_API
291 void            gst_audio_ring_buffer_debug_spec_buff (GstAudioRingBufferSpec *spec);
292 
293 GST_AUDIO_API
294 gboolean        gst_audio_ring_buffer_convert         (GstAudioRingBuffer * buf, GstFormat src_fmt,
295                                                        gint64 src_val, GstFormat dest_fmt,
296                                                        gint64 * dest_val);
</pre>
</td>
<td>
<hr />
<pre>
 43 
 44 /**
 45  * GstAudioRingBufferCallback:
 46  * @rbuf: a #GstAudioRingBuffer
 47  * @data: (array length=len): target to fill
 48  * @len: amount to fill
 49  * @user_data: user data
 50  *
 51  * This function is set with gst_audio_ring_buffer_set_callback() and is
 52  * called to fill the memory at @data with @len bytes of samples.
 53  */
 54 typedef void (*GstAudioRingBufferCallback) (GstAudioRingBuffer *rbuf, guint8* data, guint len, gpointer user_data);
 55 
 56 /**
 57  * GstAudioRingBufferState:
 58  * @GST_AUDIO_RING_BUFFER_STATE_STOPPED: The ringbuffer is stopped
 59  * @GST_AUDIO_RING_BUFFER_STATE_PAUSED: The ringbuffer is paused
 60  * @GST_AUDIO_RING_BUFFER_STATE_STARTED: The ringbuffer is started
 61  * @GST_AUDIO_RING_BUFFER_STATE_ERROR: The ringbuffer has encountered an
 62  *     error after it has been started, e.g. because the device was
<span class="line-modified"> 63  *     disconnected (Since: 1.2)</span>
 64  *
 65  * The state of the ringbuffer.
 66  */
 67 typedef enum {
 68   GST_AUDIO_RING_BUFFER_STATE_STOPPED,
 69   GST_AUDIO_RING_BUFFER_STATE_PAUSED,
 70   GST_AUDIO_RING_BUFFER_STATE_STARTED,
 71   GST_AUDIO_RING_BUFFER_STATE_ERROR
 72 } GstAudioRingBufferState;
 73 
 74 /**
 75  * GstAudioRingBufferFormatType:
 76  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW: samples in linear or float
 77  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MU_LAW: samples in mulaw
 78  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_A_LAW: samples in alaw
 79  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IMA_ADPCM: samples in ima adpcm
 80  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG: samples in mpeg audio (but not AAC) format
 81  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_GSM: samples in gsm format
 82  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IEC958: samples in IEC958 frames (e.g. AC3)
 83  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_AC3: samples in AC3 format
 84  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_EAC3: samples in EAC3 format
 85  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DTS: samples in DTS format
 86  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC: samples in MPEG-2 AAC ADTS format
 87  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC: samples in MPEG-4 AAC ADTS format
<span class="line-modified"> 88  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC_RAW: samples in MPEG-2 AAC raw format (Since: 1.12)</span>
<span class="line-modified"> 89  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC_RAW: samples in MPEG-4 AAC raw format (Since: 1.12)</span>
<span class="line-modified"> 90  * @GST_AUDIO_RING_BUFFER_FORMAT_TYPE_FLAC: samples in FLAC format (Since: 1.12)</span>
 91  *
 92  * The format of the samples in the ringbuffer.
 93  */
 94 typedef enum
 95 {
 96   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW,
 97   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MU_LAW,
 98   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_A_LAW,
 99   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IMA_ADPCM,
100   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG,
101   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_GSM,
102   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IEC958,
103   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_AC3,
104   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_EAC3,
105   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DTS,
106   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC,
107   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC,
108   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC_RAW,
109   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC_RAW,
110   GST_AUDIO_RING_BUFFER_FORMAT_TYPE_FLAC
</pre>
<hr />
<pre>
119  * @buffer_time: the total buffer size in microseconds
120  * @segsize: the size of one segment in bytes
121  * @segtotal: the total number of segments
122  * @seglatency: number of segments queued in the lower level device,
123  *  defaults to segtotal
124  *
125  * The structure containing the format specification of the ringbuffer.
126  */
127 struct _GstAudioRingBufferSpec
128 {
129   /*&lt; public &gt;*/
130   /* in */
131   GstCaps  *caps;               /* the caps of the buffer */
132 
133   /* in/out */
134   GstAudioRingBufferFormatType  type;
135   GstAudioInfo                  info;
136 
137 
138   guint64  latency_time;        /* the required/actual latency time, this is the
<span class="line-modified">139          * actual the size of one segment and the</span>
<span class="line-modified">140          * minimum possible latency we can achieve. */</span>
141   guint64  buffer_time;         /* the required/actual time of the buffer, this is
<span class="line-modified">142          * the total size of the buffer and maximum</span>
<span class="line-modified">143          * latency we can compensate for. */</span>
144   gint     segsize;             /* size of one buffer segment in bytes, this value
<span class="line-modified">145          * should be chosen to match latency_time as</span>
<span class="line-modified">146          * well as possible. */</span>
147   gint     segtotal;            /* total number of segments, this value is the
<span class="line-modified">148          * number of segments of @segsize and should be</span>
<span class="line-modified">149          * chosen so that it matches buffer_time as</span>
<span class="line-modified">150          * close as possible. */</span>
151   /* ABI added 0.10.20 */
152   gint     seglatency;          /* number of segments queued in the lower
<span class="line-modified">153          * level device, defaults to segtotal. */</span>
154 
155   /*&lt; private &gt;*/
156   gpointer _gst_reserved[GST_PADDING];
157 };
158 
159 #define GST_AUDIO_RING_BUFFER_GET_COND(buf) (&amp;(((GstAudioRingBuffer *)buf)-&gt;cond))
160 #define GST_AUDIO_RING_BUFFER_WAIT(buf)     (g_cond_wait (GST_AUDIO_RING_BUFFER_GET_COND (buf), GST_OBJECT_GET_LOCK (buf)))
161 #define GST_AUDIO_RING_BUFFER_SIGNAL(buf)   (g_cond_signal (GST_AUDIO_RING_BUFFER_GET_COND (buf)))
162 #define GST_AUDIO_RING_BUFFER_BROADCAST(buf)(g_cond_broadcast (GST_AUDIO_RING_BUFFER_GET_COND (buf)))
163 
164 /**
165  * GstAudioRingBuffer:
166  * @cond: used to signal start/stop/pause/resume actions
167  * @open: boolean indicating that the ringbuffer is open
168  * @acquired: boolean indicating that the ringbuffer is acquired
169  * @memory: data in the ringbuffer
170  * @size: size of data in the ringbuffer
171  * @spec: format and layout of the ringbuffer data
172  * @samples_per_seg: number of samples in one segment
173  * @empty_seg: pointer to memory holding one segment of silence samples
174  * @state: state of the buffer
175  * @segdone: readpointer in the ringbuffer
176  * @segbase: segment corresponding to segment 0 (unused)
177  * @waiting: is a reader or writer waiting for a free segment
178  *
179  * The ringbuffer base class structure.
180  */
181 struct _GstAudioRingBuffer {
182   GstObject                   object;
183 
184   /*&lt; public &gt;*/ /* with LOCK */
185   GCond                      cond;
186   gboolean                    open;
187   gboolean                    acquired;
188   guint8                     *memory;
189   gsize                       size;
<span class="line-added">190   /*&lt; private &gt;*/</span>
191   GstClockTime               *timestamps;
<span class="line-added">192   /*&lt; public &gt;*/ /* with LOCK */</span>
193   GstAudioRingBufferSpec      spec;
194   gint                        samples_per_seg;
195   guint8                     *empty_seg;
196 
197   /*&lt; public &gt;*/ /* ATOMIC */
198   gint                        state;
199   gint                        segdone;
200   gint                        segbase;
201   gint                        waiting;
202 
203   /*&lt; private &gt;*/
204   GstAudioRingBufferCallback  callback;
205   gpointer                    cb_data;
206 
207   gboolean                    need_reorder;
208   /* gst[channel_reorder_map[i]] = device[i] */
209   gint                        channel_reorder_map[64];
210 
211   gboolean                    flushing;
212   /* ATOMIC */
</pre>
<hr />
<pre>
257   /* ABI added */
258   gboolean     (*activate)     (GstAudioRingBuffer *buf, gboolean active);
259 
260   guint        (*commit)       (GstAudioRingBuffer * buf, guint64 *sample,
261                                 guint8 * data, gint in_samples,
262                                 gint out_samples, gint * accum);
263 
264   void         (*clear_all)    (GstAudioRingBuffer * buf);
265 
266   /*&lt; private &gt;*/
267   gpointer _gst_reserved[GST_PADDING];
268 };
269 
270 GST_AUDIO_API
271 GType gst_audio_ring_buffer_get_type(void);
272 
273 /* callback stuff */
274 
275 GST_AUDIO_API
276 void            gst_audio_ring_buffer_set_callback      (GstAudioRingBuffer *buf,
<span class="line-modified">277                                                          GstAudioRingBufferCallback cb,</span>
<span class="line-modified">278                                                          gpointer user_data);</span>
279 
280 GST_AUDIO_API
281 void            gst_audio_ring_buffer_set_callback_full (GstAudioRingBuffer *buf,
282                                                          GstAudioRingBufferCallback cb,
283                                                          gpointer user_data,
284                                                          GDestroyNotify notify);
285 
286 GST_AUDIO_API
287 gboolean        gst_audio_ring_buffer_parse_caps      (GstAudioRingBufferSpec *spec, GstCaps *caps);
288 
289 GST_AUDIO_API
290 void            gst_audio_ring_buffer_debug_spec_caps (GstAudioRingBufferSpec *spec);
291 
292 GST_AUDIO_API
293 void            gst_audio_ring_buffer_debug_spec_buff (GstAudioRingBufferSpec *spec);
294 
295 GST_AUDIO_API
296 gboolean        gst_audio_ring_buffer_convert         (GstAudioRingBuffer * buf, GstFormat src_fmt,
297                                                        gint64 src_val, GstFormat dest_fmt,
298                                                        gint64 * dest_val);
</pre>
</td>
</tr>
</table>
<center><a href="gstaudioringbuffer.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstaudiosink.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>