<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvariant-parser.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gvariant-internal.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gvariant-serialiser.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvariant-parser.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright ï¿½ 2009, 2010 Codethink Limited</span>
   *
   * This library is free software; you can redistribute it and/or
   * modify it under the terms of the GNU Lesser General Public
   * License as published by the Free Software Foundation; either
   * version 2.1 of the License, or (at your option) any later version.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2009, 2010 Codethink Limited</span>
   *
   * This library is free software; you can redistribute it and/or
   * modify it under the terms of the GNU Lesser General Public
   * License as published by the Free Software Foundation; either
   * version 2.1 of the License, or (at your option) any later version.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 208,14 ***</span>
            if (end != stream-&gt;end &amp;&amp; *end)
              end++;
            break;
          }
  
<span class="line-modified">!       else</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           /* ??? */</span>
<span class="line-removed">-         }</span>
  
      case &#39;a&#39;: /* &#39;b&#39; */ case &#39;c&#39;: case &#39;d&#39;: case &#39;e&#39;: case &#39;f&#39;:
      case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;: case &#39;k&#39;: case &#39;l&#39;:
      case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;: case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;:
      case &#39;s&#39;: case &#39;t&#39;: case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;:
<span class="line-new-header">--- 208,11 ---</span>
            if (end != stream-&gt;end &amp;&amp; *end)
              end++;
            break;
          }
  
<span class="line-modified">!       G_GNUC_FALLTHROUGH;</span>
  
      case &#39;a&#39;: /* &#39;b&#39; */ case &#39;c&#39;: case &#39;d&#39;: case &#39;e&#39;: case &#39;f&#39;:
      case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;: case &#39;k&#39;: case &#39;l&#39;:
      case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;: case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;:
      case &#39;s&#39;: case &#39;t&#39;: case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 363,11 ***</span>
  
  static void
  token_stream_assert (TokenStream *stream,
                       const gchar *token)
  {
<span class="line-modified">!   gboolean correct_token;</span>
  
    correct_token = token_stream_consume (stream, token);
    g_assert (correct_token);
  }
  
<span class="line-new-header">--- 360,11 ---</span>
  
  static void
  token_stream_assert (TokenStream *stream,
                       const gchar *token)
  {
<span class="line-modified">!   gboolean correct_token G_GNUC_UNUSED  /* when compiling with G_DISABLE_ASSERT */;</span>
  
    correct_token = token_stream_consume (stream, token);
    g_assert (correct_token);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 419,10 ***</span>
<span class="line-new-header">--- 416,12 ---</span>
        *(*out)++ = *(*in)++;
      }
    while (brackets);
  }
  
<span class="line-added">+ /* Returns the most general pattern that is subpattern of left and subpattern</span>
<span class="line-added">+  * of right, or NULL if there is no such pattern. */</span>
  static gchar *
  pattern_coalesce (const gchar *left,
                    const gchar *right)
  {
    gchar *result;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 459,11 ***</span>
            else if (**one == &#39;M&#39; &amp;&amp; **the_other == &#39;m&#39;)
              {
                *out++ = *(*the_other)++;
              }
  
<span class="line-modified">!           else if (**one == &#39;M&#39; &amp;&amp; **the_other != &#39;m&#39;)</span>
              {
                (*one)++;
              }
  
            else if (**one == &#39;N&#39; &amp;&amp; strchr (&quot;ynqiuxthd&quot;, **the_other))
<span class="line-new-header">--- 458,11 ---</span>
            else if (**one == &#39;M&#39; &amp;&amp; **the_other == &#39;m&#39;)
              {
                *out++ = *(*the_other)++;
              }
  
<span class="line-modified">!           else if (**one == &#39;M&#39; &amp;&amp; **the_other != &#39;m&#39; &amp;&amp; **the_other != &#39;*&#39;)</span>
              {
                (*one)++;
              }
  
            else if (**one == &#39;N&#39; &amp;&amp; strchr (&quot;ynqiuxthd&quot;, **the_other))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 672,10 ***</span>
<span class="line-new-header">--- 671,13 ---</span>
                         GError **error)
  {
    gchar *pattern;
    gint i;
  
<span class="line-added">+   /* Find the pattern which applies to all children in the array, by l-folding a</span>
<span class="line-added">+    * coalesce operation.</span>
<span class="line-added">+    */</span>
    pattern = ast_get_pattern (array[0], error);
  
    if (pattern == NULL)
      return NULL;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 706,12 ***</span>
            while (TRUE)
              {
                gchar *tmp2;
                gchar *m;
  
<span class="line-modified">!               /* if &#39;j&#39; reaches &#39;i&#39; then we failed to find the pair */</span>
<span class="line-modified">!               g_assert (j &lt; i);</span>
  
                tmp2 = ast_get_pattern (array[j], NULL);
                g_assert (tmp2 != NULL);
  
                m = pattern_coalesce (tmp, tmp2);
<span class="line-new-header">--- 708,22 ---</span>
            while (TRUE)
              {
                gchar *tmp2;
                gchar *m;
  
<span class="line-modified">!               /* if &#39;j&#39; reaches &#39;i&#39; then we didn&#39;t find the pair that failed</span>
<span class="line-modified">!                * to coalesce. This shouldn&#39;t happen (see above), but just in</span>
<span class="line-added">+                * case report an error:</span>
<span class="line-added">+                */</span>
<span class="line-added">+               if (j &gt;= i)</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                   ast_set_error (array[i], error, NULL,</span>
<span class="line-added">+                                  G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE,</span>
<span class="line-added">+                                  &quot;unable to find a common type&quot;);</span>
<span class="line-added">+                   g_free (tmp);</span>
<span class="line-added">+                   return NULL;</span>
<span class="line-added">+                 }</span>
  
                tmp2 = ast_get_pattern (array[j], NULL);
                g_assert (tmp2 != NULL);
  
                m = pattern_coalesce (tmp, tmp2);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1529,36 ***</span>
  
    g_free (string-&gt;string);
    g_slice_free (String, string);
  }
  
  static gboolean
  unicode_unescape (const gchar  *src,
                    gint         *src_ofs,
                    gchar        *dest,
                    gint         *dest_ofs,
<span class="line-modified">!                   gint          length,</span>
                    SourceRef    *ref,
                    GError      **error)
  {
    gchar buffer[9];
<span class="line-modified">!   guint64 value;</span>
    gchar *end;
  
    (*src_ofs)++;
  
    g_assert (length &lt; sizeof (buffer));
    strncpy (buffer, src + *src_ofs, length);
    buffer[length] = &#39;\0&#39;;
  
<span class="line-modified">!   value = g_ascii_strtoull (buffer, &amp;end, 0x10);</span>
  
    if (value == 0 || end != buffer + length)
      {
<span class="line-modified">!       parser_set_error (error, ref, NULL,</span>
                          G_VARIANT_PARSE_ERROR_INVALID_CHARACTER,
<span class="line-modified">!                         &quot;invalid %d-character unicode escape&quot;, length);</span>
        return FALSE;
      }
  
    g_assert (value &lt;= G_MAXUINT32);
  
<span class="line-new-header">--- 1541,50 ---</span>
  
    g_free (string-&gt;string);
    g_slice_free (String, string);
  }
  
<span class="line-added">+ /* Accepts exactly @length hexadecimal digits. No leading sign or `0x`/`0X` prefix allowed.</span>
<span class="line-added">+  * No leading/trailing space allowed. */</span>
  static gboolean
  unicode_unescape (const gchar  *src,
                    gint         *src_ofs,
                    gchar        *dest,
                    gint         *dest_ofs,
<span class="line-modified">!                   gsize         length,</span>
                    SourceRef    *ref,
                    GError      **error)
  {
    gchar buffer[9];
<span class="line-modified">!   guint64 value = 0;</span>
    gchar *end;
<span class="line-added">+   gsize n_valid_chars;</span>
  
    (*src_ofs)++;
  
    g_assert (length &lt; sizeof (buffer));
    strncpy (buffer, src + *src_ofs, length);
    buffer[length] = &#39;\0&#39;;
  
<span class="line-modified">!   for (n_valid_chars = 0; n_valid_chars &lt; length; n_valid_chars++)</span>
<span class="line-added">+     if (!g_ascii_isxdigit (buffer[n_valid_chars]))</span>
<span class="line-added">+       break;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (n_valid_chars == length)</span>
<span class="line-added">+     value = g_ascii_strtoull (buffer, &amp;end, 0x10);</span>
  
    if (value == 0 || end != buffer + length)
      {
<span class="line-modified">!       SourceRef escape_ref;</span>
<span class="line-added">+ </span>
<span class="line-added">+       escape_ref = *ref;</span>
<span class="line-added">+       escape_ref.start += *src_ofs;</span>
<span class="line-added">+       escape_ref.end = escape_ref.start + n_valid_chars;</span>
<span class="line-added">+ </span>
<span class="line-added">+       parser_set_error (error, &amp;escape_ref, NULL,</span>
                          G_VARIANT_PARSE_ERROR_INVALID_CHARACTER,
<span class="line-modified">!                         &quot;invalid %&quot; G_GSIZE_FORMAT &quot;-character unicode escape&quot;, length);</span>
        return FALSE;
      }
  
    g_assert (value &lt;= G_MAXUINT32);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1644,10 ***</span>
<span class="line-new-header">--- 1670,12 ---</span>
            case &#39;t&#39;: str[j++] = &#39;\t&#39;; i++; continue;
            case &#39;v&#39;: str[j++] = &#39;\v&#39;; i++; continue;
            case &#39;\n&#39;: i++; continue;
            }
  
<span class="line-added">+         G_GNUC_FALLTHROUGH;</span>
<span class="line-added">+ </span>
        default:
          str[j++] = token[i++];
        }
    str[j++] = &#39;\0&#39;;
    g_free (token);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1771,10 ***</span>
<span class="line-new-header">--- 1799,12 ---</span>
            case &#39;t&#39;: str[j++] = &#39;\t&#39;; i++; continue;
            case &#39;v&#39;: str[j++] = &#39;\v&#39;; i++; continue;
            case &#39;\n&#39;: i++; continue;
            }
  
<span class="line-added">+         G_GNUC_FALLTHROUGH;</span>
<span class="line-added">+ </span>
        default:
          str[j++] = token[i++];
        }
    str[j++] = &#39;\0&#39;;
    g_free (token);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1904,41 ***</span>
        return g_variant_new_byte (abs_val);
  
      case &#39;n&#39;:
        if (abs_val - negative &gt; G_MAXINT16)
          return number_overflow (ast, type, error);
<span class="line-modified">!       return g_variant_new_int16 (negative ? -abs_val : abs_val);</span>
  
      case &#39;q&#39;:
        if (negative || abs_val &gt; G_MAXUINT16)
          return number_overflow (ast, type, error);
        return g_variant_new_uint16 (abs_val);
  
      case &#39;i&#39;:
        if (abs_val - negative &gt; G_MAXINT32)
          return number_overflow (ast, type, error);
<span class="line-modified">!       return g_variant_new_int32 (negative ? -abs_val : abs_val);</span>
  
      case &#39;u&#39;:
        if (negative || abs_val &gt; G_MAXUINT32)
          return number_overflow (ast, type, error);
        return g_variant_new_uint32 (abs_val);
  
      case &#39;x&#39;:
        if (abs_val - negative &gt; G_MAXINT64)
          return number_overflow (ast, type, error);
<span class="line-modified">!       return g_variant_new_int64 (negative ? -abs_val : abs_val);</span>
  
      case &#39;t&#39;:
        if (negative)
          return number_overflow (ast, type, error);
        return g_variant_new_uint64 (abs_val);
  
      case &#39;h&#39;:
        if (abs_val - negative &gt; G_MAXINT32)
          return number_overflow (ast, type, error);
<span class="line-modified">!       return g_variant_new_handle (negative ? -abs_val : abs_val);</span>
  
      default:
        return ast_type_error (ast, type, error);
      }
  }
<span class="line-new-header">--- 1934,53 ---</span>
        return g_variant_new_byte (abs_val);
  
      case &#39;n&#39;:
        if (abs_val - negative &gt; G_MAXINT16)
          return number_overflow (ast, type, error);
<span class="line-modified">!       if (negative &amp;&amp; abs_val &gt; G_MAXINT16)</span>
<span class="line-added">+         return g_variant_new_int16 (G_MININT16);</span>
<span class="line-added">+       return g_variant_new_int16 (negative ?</span>
<span class="line-added">+                                   -((gint16) abs_val) : ((gint16) abs_val));</span>
  
      case &#39;q&#39;:
        if (negative || abs_val &gt; G_MAXUINT16)
          return number_overflow (ast, type, error);
        return g_variant_new_uint16 (abs_val);
  
      case &#39;i&#39;:
        if (abs_val - negative &gt; G_MAXINT32)
          return number_overflow (ast, type, error);
<span class="line-modified">!       if (negative &amp;&amp; abs_val &gt; G_MAXINT32)</span>
<span class="line-added">+         return g_variant_new_int32 (G_MININT32);</span>
<span class="line-added">+       return g_variant_new_int32 (negative ?</span>
<span class="line-added">+                                   -((gint32) abs_val) : ((gint32) abs_val));</span>
  
      case &#39;u&#39;:
        if (negative || abs_val &gt; G_MAXUINT32)
          return number_overflow (ast, type, error);
        return g_variant_new_uint32 (abs_val);
  
      case &#39;x&#39;:
        if (abs_val - negative &gt; G_MAXINT64)
          return number_overflow (ast, type, error);
<span class="line-modified">!       if (negative &amp;&amp; abs_val &gt; G_MAXINT64)</span>
<span class="line-added">+         return g_variant_new_int64 (G_MININT64);</span>
<span class="line-added">+       return g_variant_new_int64 (negative ?</span>
<span class="line-added">+                                   -((gint64) abs_val) : ((gint64) abs_val));</span>
  
      case &#39;t&#39;:
        if (negative)
          return number_overflow (ast, type, error);
        return g_variant_new_uint64 (abs_val);
  
      case &#39;h&#39;:
        if (abs_val - negative &gt; G_MAXINT32)
          return number_overflow (ast, type, error);
<span class="line-modified">!       if (negative &amp;&amp; abs_val &gt; G_MAXINT32)</span>
<span class="line-added">+         return g_variant_new_handle (G_MININT32);</span>
<span class="line-added">+       return g_variant_new_handle (negative ?</span>
<span class="line-added">+                                    -((gint32) abs_val) : ((gint32) abs_val));</span>
  
      default:
        return ast_type_error (ast, type, error);
      }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2590,11 ***</span>
  }
  
  static gboolean
  parse_num (const gchar *num,
             const gchar *limit,
<span class="line-modified">!            gint        *result)</span>
  {
    gchar *endptr;
    gint64 bignum;
  
    bignum = g_ascii_strtoll (num, &amp;endptr, 10);
<span class="line-new-header">--- 2632,11 ---</span>
  }
  
  static gboolean
  parse_num (const gchar *num,
             const gchar *limit,
<span class="line-modified">!            guint       *result)</span>
  {
    gchar *endptr;
    gint64 bignum;
  
    bignum = g_ascii_strtoll (num, &amp;endptr, 10);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2603,11 ***</span>
      return FALSE;
  
    if (bignum &lt; 0 || bignum &gt; G_MAXINT)
      return FALSE;
  
<span class="line-modified">!   *result = bignum;</span>
  
    return TRUE;
  }
  
  static void
<span class="line-new-header">--- 2645,11 ---</span>
      return FALSE;
  
    if (bignum &lt; 0 || bignum &gt; G_MAXINT)
      return FALSE;
  
<span class="line-modified">!   *result = (guint) bignum;</span>
  
    return TRUE;
  }
  
  static void
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2759,29 ***</span>
    err = g_string_new (colon + 1);
    g_string_append (err, &quot;:\n&quot;);
  
    if (dash == NULL || colon &lt; dash)
      {
<span class="line-modified">!       gint point;</span>
  
        /* we have a single point */
        if (!parse_num (error-&gt;message, colon, &amp;point))
          goto out;
  
        if (point &gt;= strlen (source_str))
          /* the error is at the end of the input */
          add_last_line (err, source_str);
        else
<span class="line-modified">!         /* otherwise just treat it as a error at a thin range */</span>
          add_lines_from_range (err, source_str, source_str + point, source_str + point + 1, NULL, NULL);
      }
    else
      {
        /* We have one or two ranges... */
        if (comma &amp;&amp; comma &lt; colon)
          {
<span class="line-modified">!           gint start1, end1, start2, end2;</span>
            const gchar *dash2;
  
            /* Two ranges */
            dash2 = strchr (comma, &#39;-&#39;);
  
<span class="line-new-header">--- 2801,29 ---</span>
    err = g_string_new (colon + 1);
    g_string_append (err, &quot;:\n&quot;);
  
    if (dash == NULL || colon &lt; dash)
      {
<span class="line-modified">!       guint point;</span>
  
        /* we have a single point */
        if (!parse_num (error-&gt;message, colon, &amp;point))
          goto out;
  
        if (point &gt;= strlen (source_str))
          /* the error is at the end of the input */
          add_last_line (err, source_str);
        else
<span class="line-modified">!         /* otherwise just treat it as an error at a thin range */</span>
          add_lines_from_range (err, source_str, source_str + point, source_str + point + 1, NULL, NULL);
      }
    else
      {
        /* We have one or two ranges... */
        if (comma &amp;&amp; comma &lt; colon)
          {
<span class="line-modified">!           guint start1, end1, start2, end2;</span>
            const gchar *dash2;
  
            /* Two ranges */
            dash2 = strchr (comma, &#39;-&#39;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2793,11 ***</span>
                                  source_str + start1, source_str + end1,
                                  source_str + start2, source_str + end2);
          }
        else
          {
<span class="line-modified">!           gint start, end;</span>
  
            /* One range */
            if (!parse_num (error-&gt;message, dash, &amp;start) || !parse_num (dash + 1, colon, &amp;end))
              goto out;
  
<span class="line-new-header">--- 2835,11 ---</span>
                                  source_str + start1, source_str + end1,
                                  source_str + start2, source_str + end2);
          }
        else
          {
<span class="line-modified">!           guint start, end;</span>
  
            /* One range */
            if (!parse_num (error-&gt;message, dash, &amp;start) || !parse_num (dash + 1, colon, &amp;end))
              goto out;
  
</pre>
<center><a href="gvariant-internal.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gvariant-serialiser.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>