<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gstdio.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstdio-private.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstdio.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gstdio.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   2  *
   3  * Copyright 2004 Tor Lillqvist
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public License
  16  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  */
  18 
  19 #include &quot;config.h&quot;
  20 #include &quot;glibconfig.h&quot;
  21 
<span class="line-modified">  22 #define G_STDIO_NO_WRAP_ON_UNIX</span>


  23 
  24 #include &lt;sys/types.h&gt;
  25 #include &lt;sys/stat.h&gt;
  26 #include &lt;fcntl.h&gt;
  27 
  28 #ifdef G_OS_UNIX
  29 #include &lt;unistd.h&gt;
  30 #endif
  31 
  32 #ifdef G_OS_WIN32
  33 #include &lt;windows.h&gt;
  34 #include &lt;errno.h&gt;
  35 #include &lt;wchar.h&gt;
  36 #include &lt;direct.h&gt;
  37 #include &lt;io.h&gt;
  38 #include &lt;sys/utime.h&gt;

  39 #else
  40 #include &lt;utime.h&gt;
  41 #include &lt;errno.h&gt;
  42 #endif
  43 
  44 #include &quot;gstdio.h&quot;
  45 #include &quot;gstdioprivate.h&quot;
  46 
  47 #if !defined (G_OS_UNIX) &amp;&amp; !defined (G_OS_WIN32)
  48 #error Please port this to your operating system
  49 #endif
  50 
  51 #if defined (_MSC_VER) &amp;&amp; !defined(_WIN64)
  52 #undef _wstat
  53 #define _wstat _wstat32
  54 #endif
  55 
  56 #if defined (G_OS_WIN32)
  57 
  58 /* We can&#39;t include Windows DDK and Windows SDK simultaneously,
</pre>
<hr />
<pre>
  82       USHORT SubstituteNameLength;
  83       USHORT PrintNameOffset;
  84       USHORT PrintNameLength;
  85       WCHAR  PathBuffer[1];
  86     } MountPointReparseBuffer;
  87     struct
  88     {
  89       UCHAR  DataBuffer[1];
  90     } GenericReparseBuffer;
  91   };
  92 } REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;
  93 
  94 static int
  95 w32_error_to_errno (DWORD error_code)
  96 {
  97   switch (error_code)
  98     {
  99     case ERROR_ACCESS_DENIED:
 100       return EACCES;
 101       break;
<span class="line-modified"> 102     case ERROR_INVALID_HANDLE:</span>
<span class="line-modified"> 103       return EBADF;</span>



 104       break;
 105     case ERROR_INVALID_FUNCTION:
 106       return EFAULT;
 107       break;
<span class="line-modified"> 108     case ERROR_FILE_NOT_FOUND:</span>
<span class="line-modified"> 109       return ENOENT;</span>
 110       break;
<span class="line-modified"> 111     case ERROR_PATH_NOT_FOUND:</span>
<span class="line-modified"> 112       return ENOENT; /* or ELOOP, or ENAMETOOLONG */</span>




 113       break;
 114     case ERROR_NOT_ENOUGH_MEMORY:
 115     case ERROR_OUTOFMEMORY:
 116       return ENOMEM;
 117       break;






 118     default:
 119       return EIO;
 120       break;
 121     }
 122 }
 123 
 124 #include &quot;gstdio-private.c&quot;
 125 









































































































































































































































































































































































































































 126 static int
 127 _g_win32_stat_utf16_no_trailing_slashes (const gunichar2    *filename,
<span class="line-removed"> 128                                          int                 fd,</span>
 129                                          GWin32PrivateStat  *buf,
 130                                          gboolean            for_symlink)
 131 {
<span class="line-removed"> 132   HANDLE file_handle;</span>
<span class="line-removed"> 133   gboolean succeeded_so_far;</span>
<span class="line-removed"> 134   DWORD error_code;</span>
 135   struct __stat64 statbuf;
 136   BY_HANDLE_FILE_INFORMATION handle_info;
 137   FILE_STANDARD_INFO std_info;
<span class="line-removed"> 138   WIN32_FIND_DATAW finddata;</span>
<span class="line-removed"> 139   DWORD immediate_attributes;</span>
 140   gboolean is_symlink = FALSE;
<span class="line-removed"> 141   gboolean is_directory;</span>
<span class="line-removed"> 142   DWORD open_flags;</span>
 143   wchar_t *filename_target = NULL;
<span class="line-modified"> 144   int result;</span>






 145 
<span class="line-modified"> 146   if (fd &lt; 0)</span>
<span class="line-removed"> 147     {</span>
<span class="line-removed"> 148       immediate_attributes = GetFileAttributesW (filename);</span>
 149 
<span class="line-modified"> 150       if (immediate_attributes == INVALID_FILE_ATTRIBUTES)</span>
<span class="line-modified"> 151         {</span>
<span class="line-modified"> 152           error_code = GetLastError ();</span>
<span class="line-modified"> 153           errno = w32_error_to_errno (error_code);</span>
 154 
<span class="line-modified"> 155           return -1;</span>
<span class="line-modified"> 156         }</span>
 157 
<span class="line-modified"> 158       is_symlink = (immediate_attributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;</span>
<span class="line-modified"> 159       is_directory = (immediate_attributes &amp; FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY;</span>
 160 
<span class="line-modified"> 161       open_flags = FILE_ATTRIBUTE_NORMAL;</span>
 162 
<span class="line-modified"> 163       if (for_symlink &amp;&amp; is_symlink)</span>
<span class="line-modified"> 164         open_flags |= FILE_FLAG_OPEN_REPARSE_POINT;</span>
 165 
<span class="line-modified"> 166       if (is_directory)</span>
<span class="line-modified"> 167         open_flags |= FILE_FLAG_BACKUP_SEMANTICS;</span>
 168 
<span class="line-modified"> 169       file_handle = CreateFileW (filename, FILE_READ_ATTRIBUTES,</span>
<span class="line-modified"> 170                                  FILE_SHARE_READ, NULL, OPEN_EXISTING,</span>
<span class="line-modified"> 171                                  open_flags,</span>
<span class="line-modified"> 172                                  NULL);</span>

 173 
<span class="line-modified"> 174       if (file_handle == INVALID_HANDLE_VALUE)</span>
<span class="line-removed"> 175         {</span>
<span class="line-removed"> 176           error_code = GetLastError ();</span>
<span class="line-removed"> 177           errno = w32_error_to_errno (error_code);</span>
<span class="line-removed"> 178           return -1;</span>
<span class="line-removed"> 179         }</span>
<span class="line-removed"> 180     }</span>
<span class="line-removed"> 181   else</span>
 182     {
<span class="line-modified"> 183       file_handle = (HANDLE) _get_osfhandle (fd);</span>
<span class="line-modified"> 184 </span>
<span class="line-modified"> 185       if (file_handle == INVALID_HANDLE_VALUE)</span>
<span class="line-removed"> 186         return -1;</span>
 187     }
 188 
 189   succeeded_so_far = GetFileInformationByHandle (file_handle,
 190                                                  &amp;handle_info);
 191   error_code = GetLastError ();
 192 
 193   if (succeeded_so_far)
 194     {
 195       succeeded_so_far = GetFileInformationByHandleEx (file_handle,
 196                                                        FileStandardInfo,
 197                                                        &amp;std_info,
 198                                                        sizeof (std_info));
 199       error_code = GetLastError ();
 200     }
 201 
 202   if (!succeeded_so_far)
 203     {
<span class="line-modified"> 204       if (fd &lt; 0)</span>
<span class="line-removed"> 205         CloseHandle (file_handle);</span>
 206       errno = w32_error_to_errno (error_code);
 207       return -1;
 208     }
 209 
 210   /* It&#39;s tempting to use GetFileInformationByHandleEx(FileAttributeTagInfo),
 211    * but it always reports that the ReparseTag is 0.



 212    */
<span class="line-modified"> 213   if (fd &lt; 0)</span>






 214     {
<span class="line-modified"> 215       memset (&amp;finddata, 0, sizeof (finddata));</span>


 216 
<span class="line-modified"> 217       if (handle_info.dwFileAttributes &amp; FILE_ATTRIBUTE_REPARSE_POINT)</span>
<span class="line-removed"> 218         {</span>
<span class="line-removed"> 219           HANDLE tmp = FindFirstFileW (filename,</span>
<span class="line-removed"> 220                                        &amp;finddata);</span>
<span class="line-removed"> 221 </span>
<span class="line-removed"> 222           if (tmp == INVALID_HANDLE_VALUE)</span>
<span class="line-removed"> 223             {</span>
<span class="line-removed"> 224               error_code = GetLastError ();</span>
<span class="line-removed"> 225               errno = w32_error_to_errno (error_code);</span>
<span class="line-removed"> 226               CloseHandle (file_handle);</span>
<span class="line-removed"> 227               return -1;</span>
<span class="line-removed"> 228             }</span>
<span class="line-removed"> 229 </span>
<span class="line-removed"> 230           FindClose (tmp);</span>
<span class="line-removed"> 231         }</span>
 232 
<span class="line-modified"> 233       if (is_symlink &amp;&amp; !for_symlink)</span>
<span class="line-modified"> 234         {</span>
<span class="line-modified"> 235           /* If filename is a symlink, _wstat64 obtains information about</span>
<span class="line-modified"> 236            * the symlink (except that st_size will be 0).</span>
<span class="line-modified"> 237            * To get information about the target we need to resolve</span>
<span class="line-modified"> 238            * the symlink first. And we need _wstat64() to get st_dev,</span>
<span class="line-modified"> 239            * it&#39;s a bother to try finding it ourselves.</span>
<span class="line-modified"> 240            */</span>
<span class="line-modified"> 241           DWORD filename_target_len;</span>
<span class="line-modified"> 242           DWORD new_len;</span>
<span class="line-removed"> 243 </span>
<span class="line-removed"> 244           /* Just in case, give it a real memory location instead of NULL */</span>
<span class="line-removed"> 245           new_len = GetFinalPathNameByHandleW (file_handle,</span>
<span class="line-removed"> 246                                                (wchar_t *) &amp;filename_target_len,</span>
<span class="line-removed"> 247                                                0,</span>
<span class="line-removed"> 248                                                FILE_NAME_NORMALIZED);</span>
<span class="line-removed"> 249 </span>
<span class="line-removed"> 250 #define SANE_LIMIT 1024 * 10</span>
<span class="line-removed"> 251           if (new_len &gt;= SANE_LIMIT)</span>
<span class="line-removed"> 252 #undef SANE_LIMIT</span>
<span class="line-removed"> 253             {</span>
<span class="line-removed"> 254               new_len = 0;</span>
<span class="line-removed"> 255               error_code = ERROR_BUFFER_OVERFLOW;</span>
<span class="line-removed"> 256             }</span>
<span class="line-removed"> 257           else if (new_len == 0)</span>
<span class="line-removed"> 258             {</span>
<span class="line-removed"> 259               error_code = GetLastError ();</span>
<span class="line-removed"> 260             }</span>
<span class="line-removed"> 261 </span>
<span class="line-removed"> 262           if (new_len &gt; 0)</span>
<span class="line-removed"> 263             {</span>
<span class="line-removed"> 264               /* Pretend that new_len doesn&#39;t count the terminating NUL char,</span>
<span class="line-removed"> 265                * and ask for a bit more space than is needed, and allocate even more.</span>
<span class="line-removed"> 266                */</span>
<span class="line-removed"> 267               filename_target_len = new_len + 3;</span>
<span class="line-removed"> 268               filename_target = g_malloc ((filename_target_len + 1) * sizeof (wchar_t));</span>
<span class="line-removed"> 269 </span>
<span class="line-removed"> 270               new_len = GetFinalPathNameByHandleW (file_handle,</span>
<span class="line-removed"> 271                                                    filename_target,</span>
<span class="line-removed"> 272                                                    filename_target_len,</span>
<span class="line-removed"> 273                                                    FILE_NAME_NORMALIZED);</span>
<span class="line-removed"> 274 </span>
<span class="line-removed"> 275               /* filename_target_len is already larger than needed,</span>
<span class="line-removed"> 276                * new_len should be smaller than that, even if the size</span>
<span class="line-removed"> 277                * is off by 1 for some reason.</span>
<span class="line-removed"> 278                */</span>
<span class="line-removed"> 279               if (new_len &gt;= filename_target_len - 1)</span>
<span class="line-removed"> 280                 {</span>
<span class="line-removed"> 281                   new_len = 0;</span>
<span class="line-removed"> 282                   error_code = ERROR_BUFFER_OVERFLOW;</span>
<span class="line-removed"> 283                   g_clear_pointer (&amp;filename_target, g_free);</span>
<span class="line-removed"> 284                 }</span>
<span class="line-removed"> 285               else if (new_len == 0)</span>
<span class="line-removed"> 286                 {</span>
<span class="line-removed"> 287                   g_clear_pointer (&amp;filename_target, g_free);</span>
<span class="line-removed"> 288                 }</span>
<span class="line-removed"> 289               /* GetFinalPathNameByHandle() is documented to return extended paths,</span>
<span class="line-removed"> 290                * strip the extended prefix, if it is followed by a drive letter</span>
<span class="line-removed"> 291                * and a colon. Otherwise keep it (the path could be</span>
<span class="line-removed"> 292                * \\\\?\\Volume{GUID}\\ - it&#39;s only usable in extended form).</span>
<span class="line-removed"> 293                */</span>
<span class="line-removed"> 294               else if (new_len &gt; 0)</span>
<span class="line-removed"> 295                 {</span>
<span class="line-removed"> 296                   gsize len = new_len;</span>
<span class="line-removed"> 297 </span>
<span class="line-removed"> 298                   /* Account for NUL-terminator maybe not being counted.</span>
<span class="line-removed"> 299                    * This is why we overallocated earlier.</span>
<span class="line-removed"> 300                    */</span>
<span class="line-removed"> 301                   if (filename_target[len] != L&#39;\0&#39;)</span>
<span class="line-removed"> 302                     {</span>
<span class="line-removed"> 303                       len++;</span>
<span class="line-removed"> 304                       filename_target[len] = L&#39;\0&#39;;</span>
<span class="line-removed"> 305                 }</span>
<span class="line-removed"> 306 </span>
<span class="line-removed"> 307                   _g_win32_strip_extended_ntobjm_prefix (filename_target, &amp;len);</span>
<span class="line-removed"> 308                   new_len = len;</span>
<span class="line-removed"> 309             }</span>
<span class="line-removed"> 310 </span>
<span class="line-removed"> 311             }</span>
<span class="line-removed"> 312 </span>
<span class="line-removed"> 313           if (new_len == 0)</span>
<span class="line-removed"> 314             succeeded_so_far = FALSE;</span>
<span class="line-removed"> 315         }</span>
 316 
<span class="line-modified"> 317       CloseHandle (file_handle);</span>
<span class="line-modified"> 318     }</span>
<span class="line-removed"> 319   /* else if fd &gt;= 0 the file_handle was obtained via _get_osfhandle()</span>
<span class="line-removed"> 320    * and must not be closed, it is owned by fd.</span>
<span class="line-removed"> 321    */</span>
 322 
<span class="line-modified"> 323   if (!succeeded_so_far)</span>
<span class="line-modified"> 324     {</span>
<span class="line-modified"> 325       errno = w32_error_to_errno (error_code);</span>
<span class="line-modified"> 326       return -1;</span>
<span class="line-modified"> 327     }</span>








 328 
<span class="line-modified"> 329   if (fd &lt; 0)</span>
<span class="line-removed"> 330     result = _wstat64 (filename_target != NULL ? filename_target : filename, &amp;statbuf);</span>
<span class="line-removed"> 331   else</span>
<span class="line-removed"> 332     result = _fstat64 (fd, &amp;statbuf);</span>
 333 
<span class="line-modified"> 334   if (result != 0)</span>
<span class="line-modified"> 335     {</span>
<span class="line-removed"> 336       int errsv = errno;</span>
 337 
<span class="line-modified"> 338       g_free (filename_target);</span>
<span class="line-modified"> 339       errno = errsv;</span>

 340 












 341       return -1;
 342     }
 343 
<span class="line-modified"> 344   g_free (filename_target);</span>
 345 
<span class="line-modified"> 346   buf-&gt;st_dev = statbuf.st_dev;</span>
<span class="line-modified"> 347   buf-&gt;st_mode = statbuf.st_mode;</span>
<span class="line-modified"> 348   buf-&gt;volume_serial = handle_info.dwVolumeSerialNumber;</span>
<span class="line-removed"> 349   buf-&gt;file_index = (((guint64) handle_info.nFileIndexHigh) &lt;&lt; 32) | handle_info.nFileIndexLow;</span>
<span class="line-removed"> 350   /* Note that immediate_attributes is for the symlink</span>
<span class="line-removed"> 351    * (if it&#39;s a symlink), while handle_info contains info</span>
<span class="line-removed"> 352    * about the symlink or the target, depending on the flags</span>
<span class="line-removed"> 353    * we used earlier.</span>
<span class="line-removed"> 354    */</span>
<span class="line-removed"> 355   buf-&gt;attributes = handle_info.dwFileAttributes;</span>
<span class="line-removed"> 356   buf-&gt;st_nlink = handle_info.nNumberOfLinks;</span>
<span class="line-removed"> 357   buf-&gt;st_size = (((guint64) handle_info.nFileSizeHigh) &lt;&lt; 32) | handle_info.nFileSizeLow;</span>
<span class="line-removed"> 358   buf-&gt;allocated_size = std_info.AllocationSize.QuadPart;</span>
 359 
<span class="line-modified"> 360   if (fd &lt; 0 &amp;&amp; buf-&gt;attributes &amp; FILE_ATTRIBUTE_REPARSE_POINT)</span>
<span class="line-modified"> 361     buf-&gt;reparse_tag = finddata.dwReserved0;</span>
<span class="line-removed"> 362   else</span>
<span class="line-removed"> 363     buf-&gt;reparse_tag = 0;</span>
 364 
<span class="line-modified"> 365   buf-&gt;st_ctime = statbuf.st_ctime;</span>
<span class="line-modified"> 366   buf-&gt;st_atime = statbuf.st_atime;</span>
<span class="line-modified"> 367   buf-&gt;st_mtime = statbuf.st_mtime;</span>


 368 
 369   return 0;
 370 }
 371 



 372 static int
 373 _g_win32_stat_utf8 (const gchar       *filename,
 374                     GWin32PrivateStat *buf,
 375                     gboolean           for_symlink)
 376 {
 377   wchar_t *wfilename;
 378   int result;
 379   gsize len;
 380 
 381   if (filename == NULL)
 382     {
 383       errno = EINVAL;
 384       return -1;
 385     }
 386 
 387   len = strlen (filename);
 388 
 389   while (len &gt; 0 &amp;&amp; G_IS_DIR_SEPARATOR (filename[len - 1]))
 390     len--;
 391 
 392   if (len &lt;= 0 ||
 393       (g_path_is_absolute (filename) &amp;&amp; len &lt;= g_path_skip_root (filename) - filename))
 394     len = strlen (filename);
 395 
 396   wfilename = g_utf8_to_utf16 (filename, len, NULL, NULL, NULL);
 397 
 398   if (wfilename == NULL)
 399     {
 400       errno = EINVAL;
 401       return -1;
 402     }
 403 
<span class="line-modified"> 404   result = _g_win32_stat_utf16_no_trailing_slashes (wfilename, -1, buf, for_symlink);</span>
 405 
 406   g_free (wfilename);
 407 
 408   return result;
 409 }
 410 



 411 int
 412 g_win32_stat_utf8 (const gchar       *filename,
 413                    GWin32PrivateStat *buf)
 414 {
 415   return _g_win32_stat_utf8 (filename, buf, FALSE);
 416 }
 417 



 418 int
 419 g_win32_lstat_utf8 (const gchar       *filename,
 420                     GWin32PrivateStat *buf)
 421 {
 422   return _g_win32_stat_utf8 (filename, buf, TRUE);
 423 }
 424 



 425 int
 426 g_win32_fstat (int                fd,
 427                GWin32PrivateStat *buf)
 428 {
<span class="line-modified"> 429   return _g_win32_stat_utf16_no_trailing_slashes (NULL, fd, buf, FALSE);</span>
 430 }
 431 
<span class="line-modified"> 432 static int</span>
<span class="line-modified"> 433 _g_win32_readlink_utf16_raw (const gunichar2 *filename,</span>
<span class="line-modified"> 434                              gunichar2       *buf,</span>
<span class="line-modified"> 435                              gsize            buf_size)</span>


































 436 {
<span class="line-modified"> 437   DWORD returned_bytes;</span>
<span class="line-modified"> 438   BYTE returned_data[MAXIMUM_REPARSE_DATA_BUFFER_SIZE]; /* This is 16k, by the way */</span>
<span class="line-modified"> 439   HANDLE h;</span>
<span class="line-modified"> 440   DWORD attributes;</span>
<span class="line-modified"> 441   REPARSE_DATA_BUFFER *rep_buf;</span>
<span class="line-removed"> 442   DWORD to_copy;</span>
<span class="line-removed"> 443   DWORD error_code;</span>
 444 
<span class="line-modified"> 445   if (buf_size &gt; G_MAXSIZE / sizeof (wchar_t))</span>
<span class="line-modified"> 446     {</span>
<span class="line-modified"> 447       /* &quot;buf_size * sizeof (wchar_t)&quot; overflows */</span>
<span class="line-removed"> 448       errno = EFAULT;</span>
<span class="line-removed"> 449       return -1;</span>
<span class="line-removed"> 450     }</span>
 451 
<span class="line-modified"> 452   if ((attributes = GetFileAttributesW (filename)) == 0)</span>
<span class="line-removed"> 453     {</span>
<span class="line-removed"> 454       error_code = GetLastError ();</span>
<span class="line-removed"> 455       errno = w32_error_to_errno (error_code);</span>
<span class="line-removed"> 456       return -1;</span>
<span class="line-removed"> 457     }</span>
 458 
<span class="line-modified"> 459   if ((attributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) == 0)</span>
 460     {
 461       errno = EINVAL;
 462       return -1;
 463     }
 464 
<span class="line-modified"> 465   /* To read symlink target we need to open the file as a reparse</span>
<span class="line-modified"> 466    * point and use DeviceIoControl() on it.</span>
<span class="line-removed"> 467    */</span>
<span class="line-removed"> 468   h = CreateFileW (filename,</span>
<span class="line-removed"> 469                    FILE_READ_EA,</span>
<span class="line-removed"> 470                    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,</span>
<span class="line-removed"> 471                    NULL, OPEN_EXISTING,</span>
<span class="line-removed"> 472                    FILE_ATTRIBUTE_NORMAL</span>
<span class="line-removed"> 473                    | FILE_FLAG_OPEN_REPARSE_POINT</span>
<span class="line-removed"> 474                    | (attributes &amp; FILE_ATTRIBUTE_DIRECTORY ? FILE_FLAG_BACKUP_SEMANTICS : 0),</span>
<span class="line-removed"> 475                    NULL);</span>
<span class="line-removed"> 476 </span>
<span class="line-removed"> 477   if (h == INVALID_HANDLE_VALUE)</span>
<span class="line-removed"> 478     {</span>
<span class="line-removed"> 479       error_code = GetLastError ();</span>
<span class="line-removed"> 480       errno = w32_error_to_errno (error_code);</span>
<span class="line-removed"> 481       return -1;</span>
<span class="line-removed"> 482     }</span>
<span class="line-removed"> 483 </span>
<span class="line-removed"> 484   if (!DeviceIoControl (h, FSCTL_GET_REPARSE_POINT, NULL, 0,</span>
<span class="line-removed"> 485                         returned_data, MAXIMUM_REPARSE_DATA_BUFFER_SIZE,</span>
<span class="line-removed"> 486                         &amp;returned_bytes, NULL))</span>
<span class="line-removed"> 487     {</span>
<span class="line-removed"> 488       error_code = GetLastError ();</span>
<span class="line-removed"> 489       errno = w32_error_to_errno (error_code);</span>
<span class="line-removed"> 490       CloseHandle (h);</span>
<span class="line-removed"> 491       return -1;</span>
<span class="line-removed"> 492     }</span>
<span class="line-removed"> 493 </span>
<span class="line-removed"> 494   rep_buf = (REPARSE_DATA_BUFFER *) returned_data;</span>
<span class="line-removed"> 495   to_copy = 0;</span>
 496 
<span class="line-modified"> 497   if (rep_buf-&gt;ReparseTag == IO_REPARSE_TAG_SYMLINK)</span>
<span class="line-removed"> 498     {</span>
<span class="line-removed"> 499       to_copy = rep_buf-&gt;SymbolicLinkReparseBuffer.SubstituteNameLength;</span>
<span class="line-removed"> 500 </span>
<span class="line-removed"> 501       if (to_copy &gt; buf_size * sizeof (wchar_t))</span>
<span class="line-removed"> 502         to_copy = buf_size * sizeof (wchar_t);</span>
<span class="line-removed"> 503 </span>
<span class="line-removed"> 504       memcpy (buf,</span>
<span class="line-removed"> 505               &amp;((BYTE *) rep_buf-&gt;SymbolicLinkReparseBuffer.PathBuffer)[rep_buf-&gt;SymbolicLinkReparseBuffer.SubstituteNameOffset],</span>
<span class="line-removed"> 506               to_copy);</span>
<span class="line-removed"> 507     }</span>
<span class="line-removed"> 508   else if (rep_buf-&gt;ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)</span>
<span class="line-removed"> 509     {</span>
<span class="line-removed"> 510       to_copy = rep_buf-&gt;MountPointReparseBuffer.SubstituteNameLength;</span>
<span class="line-removed"> 511 </span>
<span class="line-removed"> 512       if (to_copy &gt; buf_size * sizeof (wchar_t))</span>
<span class="line-removed"> 513         to_copy = buf_size * sizeof (wchar_t);</span>
<span class="line-removed"> 514 </span>
<span class="line-removed"> 515       memcpy (buf,</span>
<span class="line-removed"> 516               &amp;((BYTE *) rep_buf-&gt;MountPointReparseBuffer.PathBuffer)[rep_buf-&gt;MountPointReparseBuffer.SubstituteNameOffset],</span>
<span class="line-removed"> 517               to_copy);</span>
<span class="line-removed"> 518     }</span>
<span class="line-removed"> 519 </span>
<span class="line-removed"> 520   CloseHandle (h);</span>
<span class="line-removed"> 521 </span>
<span class="line-removed"> 522   return to_copy;</span>
<span class="line-removed"> 523 }</span>
<span class="line-removed"> 524 </span>
<span class="line-removed"> 525 static int</span>
<span class="line-removed"> 526 _g_win32_readlink_utf16 (const gunichar2 *filename,</span>
<span class="line-removed"> 527                          gunichar2       *buf,</span>
<span class="line-removed"> 528                          gsize            buf_size)</span>
<span class="line-removed"> 529 {</span>
<span class="line-removed"> 530   int   result = _g_win32_readlink_utf16_raw (filename, buf, buf_size);</span>
<span class="line-removed"> 531   gsize string_size;</span>
<span class="line-removed"> 532 </span>
<span class="line-removed"> 533   if (result &lt;= 0)</span>
<span class="line-removed"> 534     return result;</span>
<span class="line-removed"> 535 </span>
<span class="line-removed"> 536   /* Ensure that output is a multiple of sizeof (gunichar2),</span>
<span class="line-removed"> 537    * cutting any trailing partial gunichar2, if present.</span>
<span class="line-removed"> 538    */</span>
<span class="line-removed"> 539   result -= result % sizeof (gunichar2);</span>
 540 
 541   if (result &lt;= 0)
 542     return result;
 543 
<span class="line-modified"> 544   /* DeviceIoControl () tends to return filenames as NT Object Manager</span>
<span class="line-modified"> 545    * names , i.e. &quot;\\??\\C:\\foo\\bar&quot;.</span>
<span class="line-modified"> 546    * Remove the leading 4-byte \??\ prefix, as glib (as well as many W32 API</span>
<span class="line-modified"> 547    * functions) is unprepared to deal with it. Unless it has no &#39;x:&#39; drive</span>
<span class="line-modified"> 548    * letter part after the prefix, in which case we leave everything</span>
<span class="line-removed"> 549    * as-is, because the path could be &quot;\??\Volume{GUID}&quot; - stripping</span>
<span class="line-removed"> 550    * the prefix will allow it to be confused with relative links</span>
<span class="line-removed"> 551    * targeting &quot;Volume{GUID}&quot;.</span>
<span class="line-removed"> 552    */</span>
<span class="line-removed"> 553   string_size = result / sizeof (gunichar2);</span>
<span class="line-removed"> 554   _g_win32_strip_extended_ntobjm_prefix (buf, &amp;string_size);</span>
 555 
<span class="line-modified"> 556   return string_size * sizeof (gunichar2);</span>
<span class="line-removed"> 557 }</span>
 558 
<span class="line-modified"> 559 static gchar *</span>
<span class="line-removed"> 560 _g_win32_get_mode_alias (const gchar *mode)</span>
<span class="line-removed"> 561     {</span>
<span class="line-removed"> 562   gchar *alias;</span>
<span class="line-removed"> 563 </span>
<span class="line-removed"> 564   alias = g_strdup (mode);</span>
<span class="line-removed"> 565   if (strlen (mode) &gt; 2 &amp;&amp; mode[2] == &#39;+&#39;)</span>
<span class="line-removed"> 566     {</span>
<span class="line-removed"> 567       /* Windows implementation of fopen() does not accept modes such as</span>
<span class="line-removed"> 568        * &quot;wb+&quot;. The &#39;b&#39; needs to be appended to &quot;w+&quot;, i.e. &quot;w+b&quot;. Note</span>
<span class="line-removed"> 569        * that otherwise these 2 modes are supposed to be aliases, hence</span>
<span class="line-removed"> 570        * swappable at will.</span>
<span class="line-removed"> 571        */</span>
<span class="line-removed"> 572       alias[1] = &#39;+&#39;;</span>
<span class="line-removed"> 573       alias[2] = mode[1];</span>
<span class="line-removed"> 574     }</span>
<span class="line-removed"> 575 </span>
<span class="line-removed"> 576   return alias;</span>
<span class="line-removed"> 577 }</span>
<span class="line-removed"> 578 </span>
<span class="line-removed"> 579 int</span>
<span class="line-removed"> 580 g_win32_readlink_utf8 (const gchar *filename,</span>
<span class="line-removed"> 581                        gchar       *buf,</span>
<span class="line-removed"> 582                        gsize        buf_size)</span>
<span class="line-removed"> 583 {</span>
<span class="line-removed"> 584   wchar_t *wfilename;</span>
<span class="line-removed"> 585   int result;</span>
<span class="line-removed"> 586 </span>
<span class="line-removed"> 587   wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);</span>
<span class="line-removed"> 588 </span>
<span class="line-removed"> 589   if (wfilename == NULL)</span>
 590     {
 591       errno = EINVAL;
 592       return -1;
 593     }
 594 
<span class="line-modified"> 595   result = _g_win32_readlink_utf16 (wfilename, (gunichar2 *) buf, buf_size);</span>
<span class="line-removed"> 596 </span>
<span class="line-removed"> 597   g_free (wfilename);</span>
<span class="line-removed"> 598 </span>
<span class="line-removed"> 599   if (result &gt; 0)</span>
 600     {
<span class="line-modified"> 601       glong tmp_len;</span>
<span class="line-modified"> 602       gchar *tmp = g_utf16_to_utf8 ((const gunichar2 *) buf,</span>
<span class="line-removed"> 603                                     result / sizeof (gunichar2),</span>
<span class="line-removed"> 604                                     NULL,</span>
<span class="line-removed"> 605                                     &amp;tmp_len,</span>
<span class="line-removed"> 606                                     NULL);</span>
<span class="line-removed"> 607 </span>
<span class="line-removed"> 608       if (tmp == NULL)</span>
<span class="line-removed"> 609         {</span>
<span class="line-removed"> 610           errno = EINVAL;</span>
<span class="line-removed"> 611           return -1;</span>
<span class="line-removed"> 612         }</span>
<span class="line-removed"> 613 </span>
<span class="line-removed"> 614       if (tmp_len &gt; buf_size - 1)</span>
<span class="line-removed"> 615         tmp_len = buf_size - 1;</span>
<span class="line-removed"> 616 </span>
<span class="line-removed"> 617       memcpy (buf, tmp, tmp_len);</span>
<span class="line-removed"> 618       /* readlink() doesn&#39;t NUL-terminate, but we do.</span>
<span class="line-removed"> 619        * To be compliant, however, we return the</span>
<span class="line-removed"> 620        * number of bytes without the NUL-terminator.</span>
<span class="line-removed"> 621        */</span>
<span class="line-removed"> 622       buf[tmp_len] = &#39;\0&#39;;</span>
<span class="line-removed"> 623       result = tmp_len;</span>
<span class="line-removed"> 624       g_free (tmp);</span>
 625     }
 626 
<span class="line-modified"> 627   return result;</span>






 628 }
 629 
 630 #endif
 631 
 632 /**
 633  * g_access:
 634  * @filename: (type filename): a pathname in the GLib file name encoding
 635  *     (UTF-8 on Windows)
 636  * @mode: as in access()
 637  *
 638  * A wrapper for the POSIX access() function. This function is used to
 639  * test a pathname for one or several of read, write or execute
 640  * permissions, or just existence.
 641  *
 642  * On Windows, the file protection mechanism is not at all POSIX-like,
 643  * and the underlying function in the C library only checks the
 644  * FAT-style READONLY attribute, and does not look at the ACL of a
 645  * file at all. This function is this in practise almost useless on
 646  * Windows. Software that needs to handle file permissions on Windows
 647  * more exactly should use the Win32 API.
 648  *
 649  * See your C library manual for more details about access().
 650  *
 651  * Returns: zero if the pathname refers to an existing file system
 652  *     object that has all the tested permissions, or -1 otherwise
 653  *     or on error.
 654  *
 655  * Since: 2.8
 656  */
 657 int
 658 g_access (const gchar *filename,
<span class="line-modified"> 659       int          mode)</span>
 660 {
 661 #ifdef G_OS_WIN32
 662   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 663   int retval;
 664   int save_errno;
 665 
 666   if (wfilename == NULL)
 667     {
 668       errno = EINVAL;
 669       return -1;
 670     }
 671 
 672 #ifndef X_OK
 673 #define X_OK 1
 674 #endif
 675 
 676   retval = _waccess (wfilename, mode &amp; ~X_OK);
 677   save_errno = errno;
 678 
 679   g_free (wfilename);
</pre>
<hr />
<pre>
 691  *     (UTF-8 on Windows)
 692  * @mode: as in chmod()
 693  *
 694  * A wrapper for the POSIX chmod() function. The chmod() function is
 695  * used to set the permissions of a file system object.
 696  *
 697  * On Windows the file protection mechanism is not at all POSIX-like,
 698  * and the underlying chmod() function in the C library just sets or
 699  * clears the FAT-style READONLY attribute. It does not touch any
 700  * ACL. Software that needs to manage file permissions on Windows
 701  * exactly should use the Win32 API.
 702  *
 703  * See your C library manual for more details about chmod().
 704  *
 705  * Returns: 0 if the operation succeeded, -1 on error
 706  *
 707  * Since: 2.8
 708  */
 709 int
 710 g_chmod (const gchar *filename,
<span class="line-modified"> 711      int          mode)</span>
 712 {
 713 #ifdef G_OS_WIN32
 714   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 715   int retval;
 716   int save_errno;
 717 
 718   if (wfilename == NULL)
 719     {
 720       errno = EINVAL;
 721       return -1;
 722     }
 723 
 724   retval = _wchmod (wfilename, mode);
 725   save_errno = errno;
 726 
 727   g_free (wfilename);
 728 
 729   errno = save_errno;
 730   return retval;
 731 #else
</pre>
<hr />
<pre>
 749  * uses file handles, which are more randomish integers, not small
 750  * integers like file descriptors.
 751  *
 752  * Because file descriptors are specific to the C library on Windows,
 753  * the file descriptor returned by this function makes sense only to
 754  * functions in the same C library. Thus if the GLib-using code uses a
 755  * different C library than GLib does, the file descriptor returned by
 756  * this function cannot be passed to C library functions like write()
 757  * or read().
 758  *
 759  * See your C library manual for more details about open().
 760  *
 761  * Returns: a new file descriptor, or -1 if an error occurred.
 762  *     The return value can be used exactly like the return value
 763  *     from open().
 764  *
 765  * Since: 2.6
 766  */
 767 int
 768 g_open (const gchar *filename,
<span class="line-modified"> 769     int          flags,</span>
<span class="line-modified"> 770     int          mode)</span>
 771 {
 772 #ifdef G_OS_WIN32
 773   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 774   int retval;
 775   int save_errno;
 776 
 777   if (wfilename == NULL)
 778     {
 779       errno = EINVAL;
 780       return -1;
 781     }
 782 
 783   retval = _wopen (wfilename, flags, mode);
 784   save_errno = errno;
 785 
 786   g_free (wfilename);
 787 
 788   errno = save_errno;
 789   return retval;
 790 #else
</pre>
<hr />
<pre>
 813  * uses file handles, which are more randomish integers, not small
 814  * integers like file descriptors.
 815  *
 816  * Because file descriptors are specific to the C library on Windows,
 817  * the file descriptor returned by this function makes sense only to
 818  * functions in the same C library. Thus if the GLib-using code uses a
 819  * different C library than GLib does, the file descriptor returned by
 820  * this function cannot be passed to C library functions like write()
 821  * or read().
 822  *
 823  * See your C library manual for more details about creat().
 824  *
 825  * Returns: a new file descriptor, or -1 if an error occurred.
 826  *     The return value can be used exactly like the return value
 827  *     from creat().
 828  *
 829  * Since: 2.8
 830  */
 831 int
 832 g_creat (const gchar *filename,
<span class="line-modified"> 833      int          mode)</span>
 834 {
 835 #ifdef G_OS_WIN32
 836   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 837   int retval;
 838   int save_errno;
 839 
 840   if (wfilename == NULL)
 841     {
 842       errno = EINVAL;
 843       return -1;
 844     }
 845 
 846   retval = _wcreat (wfilename, mode);
 847   save_errno = errno;
 848 
 849   g_free (wfilename);
 850 
 851   errno = save_errno;
 852   return retval;
 853 #else
</pre>
<hr />
<pre>
 857 
 858 /**
 859  * g_rename:
 860  * @oldfilename: (type filename): a pathname in the GLib file name encoding
 861  *     (UTF-8 on Windows)
 862  * @newfilename: (type filename): a pathname in the GLib file name encoding
 863  *
 864  * A wrapper for the POSIX rename() function. The rename() function
 865  * renames a file, moving it between directories if required.
 866  *
 867  * See your C library manual for more details about how rename() works
 868  * on your system. It is not possible in general on Windows to rename
 869  * a file that is open to some process.
 870  *
 871  * Returns: 0 if the renaming succeeded, -1 if an error occurred
 872  *
 873  * Since: 2.6
 874  */
 875 int
 876 g_rename (const gchar *oldfilename,
<span class="line-modified"> 877       const gchar *newfilename)</span>
 878 {
 879 #ifdef G_OS_WIN32
 880   wchar_t *woldfilename = g_utf8_to_utf16 (oldfilename, -1, NULL, NULL, NULL);
 881   wchar_t *wnewfilename;
 882   int retval;
 883   int save_errno = 0;
 884 
 885   if (woldfilename == NULL)
 886     {
 887       errno = EINVAL;
 888       return -1;
 889     }
 890 
 891   wnewfilename = g_utf8_to_utf16 (newfilename, -1, NULL, NULL, NULL);
 892 
 893   if (wnewfilename == NULL)
 894     {
 895       g_free (woldfilename);
 896       errno = EINVAL;
 897       return -1;
 898     }
 899 
 900   if (MoveFileExW (woldfilename, wnewfilename, MOVEFILE_REPLACE_EXISTING))
 901     retval = 0;
 902   else
 903     {
 904       retval = -1;
<span class="line-modified"> 905       switch (GetLastError ())</span>
<span class="line-removed"> 906     {</span>
<span class="line-removed"> 907 #define CASE(a,b) case ERROR_##a: save_errno = b; break</span>
<span class="line-removed"> 908       CASE (FILE_NOT_FOUND, ENOENT);</span>
<span class="line-removed"> 909       CASE (PATH_NOT_FOUND, ENOENT);</span>
<span class="line-removed"> 910       CASE (ACCESS_DENIED, EACCES);</span>
<span class="line-removed"> 911       CASE (NOT_SAME_DEVICE, EXDEV);</span>
<span class="line-removed"> 912       CASE (LOCK_VIOLATION, EACCES);</span>
<span class="line-removed"> 913       CASE (SHARING_VIOLATION, EACCES);</span>
<span class="line-removed"> 914       CASE (FILE_EXISTS, EEXIST);</span>
<span class="line-removed"> 915       CASE (ALREADY_EXISTS, EEXIST);</span>
<span class="line-removed"> 916 #undef CASE</span>
<span class="line-removed"> 917     default: save_errno = EIO;</span>
<span class="line-removed"> 918     }</span>
 919     }
 920 
 921   g_free (woldfilename);
 922   g_free (wnewfilename);
 923 
 924   errno = save_errno;
 925   return retval;
 926 #else
 927   return rename (oldfilename, newfilename);
 928 #endif
 929 }
 930 
 931 /**
 932  * g_mkdir:
 933  * @filename: (type filename): a pathname in the GLib file name encoding
 934  *     (UTF-8 on Windows)
 935  * @mode: permissions to use for the newly created directory
 936  *
 937  * A wrapper for the POSIX mkdir() function. The mkdir() function
 938  * attempts to create a directory with the given name and permissions.
 939  * The mode argument is ignored on Windows.
 940  *
 941  * See your C library manual for more details about mkdir().
 942  *
 943  * Returns: 0 if the directory was successfully created, -1 if an error
 944  *    occurred
 945  *
 946  * Since: 2.6
 947  */
 948 int
 949 g_mkdir (const gchar *filename,
<span class="line-modified"> 950      int          mode)</span>
 951 {
 952 #ifdef G_OS_WIN32
 953   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 954   int retval;
 955   int save_errno;
 956 
 957   if (wfilename == NULL)
 958     {
 959       errno = EINVAL;
 960       return -1;
 961     }
 962 
 963   retval = _wmkdir (wfilename);
 964   save_errno = errno;
 965 
 966   g_free (wfilename);
 967 
 968   errno = save_errno;
 969   return retval;
 970 #else
</pre>
<hr />
<pre>
1038  * _stat32i64() and _stat64i32(). The one used here is for 32-bit code
1039  * the one with 32-bit size and time fields, specifically called _stat32().
1040  *
1041  * In Microsoft&#39;s compiler, by default struct stat means one with
1042  * 64-bit time fields while in MinGW struct stat is the legacy one
1043  * with 32-bit fields. To hopefully clear up this messs, the gstdio.h
1044  * header defines a type #GStatBuf which is the appropriate struct type
1045  * depending on the platform and/or compiler being used. On POSIX it
1046  * is just struct stat, but note that even on POSIX platforms, stat()
1047  * might be a macro.
1048  *
1049  * See your C library manual for more details about stat().
1050  *
1051  * Returns: 0 if the information was successfully retrieved,
1052  *     -1 if an error occurred
1053  *
1054  * Since: 2.6
1055  */
1056 int
1057 g_stat (const gchar *filename,
<span class="line-modified">1058     GStatBuf    *buf)</span>
1059 {
1060 #ifdef G_OS_WIN32
1061   GWin32PrivateStat w32_buf;
1062   int retval = g_win32_stat_utf8 (filename, &amp;w32_buf);
1063 
1064   buf-&gt;st_dev = w32_buf.st_dev;
1065   buf-&gt;st_ino = w32_buf.st_ino;
1066   buf-&gt;st_mode = w32_buf.st_mode;
1067   buf-&gt;st_nlink = w32_buf.st_nlink;
1068   buf-&gt;st_uid = w32_buf.st_uid;
1069   buf-&gt;st_gid = w32_buf.st_gid;
1070   buf-&gt;st_rdev = w32_buf.st_dev;
1071   buf-&gt;st_size = w32_buf.st_size;
1072   buf-&gt;st_atime = w32_buf.st_atime;
1073   buf-&gt;st_mtime = w32_buf.st_mtime;
1074   buf-&gt;st_ctime = w32_buf.st_ctime;
1075 
1076   return retval;
1077 #else
1078   return stat (filename, buf);
</pre>
<hr />
<pre>
1084  * @filename: (type filename): a pathname in the GLib file name encoding
1085  *     (UTF-8 on Windows)
1086  * @buf: a pointer to a stat struct, which will be filled with the file
1087  *     information
1088  *
1089  * A wrapper for the POSIX lstat() function. The lstat() function is
1090  * like stat() except that in the case of symbolic links, it returns
1091  * information about the symbolic link itself and not the file that it
1092  * refers to. If the system does not support symbolic links g_lstat()
1093  * is identical to g_stat().
1094  *
1095  * See your C library manual for more details about lstat().
1096  *
1097  * Returns: 0 if the information was successfully retrieved,
1098  *     -1 if an error occurred
1099  *
1100  * Since: 2.6
1101  */
1102 int
1103 g_lstat (const gchar *filename,
<span class="line-modified">1104      GStatBuf    *buf)</span>
1105 {
1106 #ifdef HAVE_LSTAT
1107   /* This can&#39;t be Win32, so don&#39;t do the widechar dance. */
1108   return lstat (filename, buf);
1109 #elif defined (G_OS_WIN32)
1110   GWin32PrivateStat w32_buf;
1111   int retval = g_win32_lstat_utf8 (filename, &amp;w32_buf);
1112 
1113   buf-&gt;st_dev = w32_buf.st_dev;
1114   buf-&gt;st_ino = w32_buf.st_ino;
1115   buf-&gt;st_mode = w32_buf.st_mode;
1116   buf-&gt;st_nlink = w32_buf.st_nlink;
1117   buf-&gt;st_uid = w32_buf.st_uid;
1118   buf-&gt;st_gid = w32_buf.st_gid;
1119   buf-&gt;st_rdev = w32_buf.st_dev;
1120   buf-&gt;st_size = w32_buf.st_size;
1121   buf-&gt;st_atime = w32_buf.st_atime;
1122   buf-&gt;st_mtime = w32_buf.st_mtime;
1123   buf-&gt;st_ctime = w32_buf.st_ctime;
1124 
</pre>
<hr />
<pre>
1278  *
1279  * A wrapper for the stdio fopen() function. The fopen() function
1280  * opens a file and associates a new stream with it.
1281  *
1282  * Because file descriptors are specific to the C library on Windows,
1283  * and a file descriptor is part of the FILE struct, the FILE* returned
1284  * by this function makes sense only to functions in the same C library.
1285  * Thus if the GLib-using code uses a different C library than GLib does,
1286  * the FILE* returned by this function cannot be passed to C library
1287  * functions like fprintf() or fread().
1288  *
1289  * See your C library manual for more details about fopen().
1290  *
1291  * Returns: A FILE* if the file was successfully opened, or %NULL if
1292  *     an error occurred
1293  *
1294  * Since: 2.6
1295  */
1296 FILE *
1297 g_fopen (const gchar *filename,
<span class="line-modified">1298      const gchar *mode)</span>
1299 {
1300 #ifdef G_OS_WIN32
1301   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1302   wchar_t *wmode;
<span class="line-removed">1303   gchar   *mode2;</span>
1304   FILE *retval;
1305   int save_errno;
1306 
1307   if (wfilename == NULL)
1308     {
1309       errno = EINVAL;
1310       return NULL;
1311     }
1312 
<span class="line-modified">1313   mode2 = _g_win32_get_mode_alias (mode);</span>
<span class="line-removed">1314   wmode = g_utf8_to_utf16 (mode2, -1, NULL, NULL, NULL);</span>
<span class="line-removed">1315   g_free (mode2);</span>
1316 
1317   if (wmode == NULL)
1318     {
1319       g_free (wfilename);
1320       errno = EINVAL;
1321       return NULL;
1322     }
1323 

1324   retval = _wfopen (wfilename, wmode);
1325   save_errno = errno;
1326 
1327   g_free (wfilename);
1328   g_free (wmode);
1329 
1330   errno = save_errno;
1331   return retval;
1332 #else
1333   return fopen (filename, mode);
1334 #endif
1335 }
1336 
1337 /**
1338  * g_freopen:
1339  * @filename: (type filename): a pathname in the GLib file name encoding
1340  *     (UTF-8 on Windows)
1341  * @mode: a string describing the mode in which the file should be  opened
1342  * @stream: (nullable): an existing stream which will be reused, or %NULL
1343  *
1344  * A wrapper for the POSIX freopen() function. The freopen() function
1345  * opens a file and associates it with an existing stream.
1346  *
1347  * See your C library manual for more details about freopen().
1348  *
1349  * Returns: A FILE* if the file was successfully opened, or %NULL if
1350  *     an error occurred.
1351  *
1352  * Since: 2.6
1353  */
1354 FILE *
1355 g_freopen (const gchar *filename,
<span class="line-modified">1356        const gchar *mode,</span>
<span class="line-modified">1357        FILE        *stream)</span>
1358 {
1359 #ifdef G_OS_WIN32
1360   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1361   wchar_t *wmode;
<span class="line-removed">1362   gchar   *mode2;</span>
1363   FILE *retval;
1364   int save_errno;
1365 
1366   if (wfilename == NULL)
1367     {
1368       errno = EINVAL;
1369       return NULL;
1370     }
1371 
<span class="line-modified">1372   mode2 = _g_win32_get_mode_alias (mode);</span>
<span class="line-removed">1373   wmode = g_utf8_to_utf16 (mode2, -1, NULL, NULL, NULL);</span>
<span class="line-removed">1374   g_free (mode2);</span>
1375 
1376   if (wmode == NULL)
1377     {
1378       g_free (wfilename);
1379       errno = EINVAL;
1380       return NULL;
1381     }
1382 

1383   retval = _wfreopen (wfilename, wmode, stream);
1384   save_errno = errno;
1385 
1386   g_free (wfilename);
1387   g_free (wmode);
1388 
1389   errno = save_errno;
1390   return retval;
1391 #else
1392   return freopen (filename, mode, stream);
1393 #endif
1394 }
1395 
1396 /**
1397  * g_utime:
1398  * @filename: (type filename): a pathname in the GLib file name encoding
1399  *     (UTF-8 on Windows)
1400  * @utb: a pointer to a struct utimbuf.
1401  *
1402  * A wrapper for the POSIX utime() function. The utime() function
1403  * sets the access and modification timestamps of a file.
1404  *
1405  * See your C library manual for more details about how utime() works
1406  * on your system.
1407  *
1408  * Returns: 0 if the operation was successful, -1 if an error occurred
1409  *
1410  * Since: 2.18
1411  */
1412 int
1413 g_utime (const gchar    *filename,
<span class="line-modified">1414      struct utimbuf *utb)</span>
1415 {
1416 #ifdef G_OS_WIN32
1417   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1418   int retval;
1419   int save_errno;
1420 
1421   if (wfilename == NULL)
1422     {
1423       errno = EINVAL;
1424       return -1;
1425     }
1426 
1427   retval = _wutime (wfilename, (struct _utimbuf*) utb);
1428   save_errno = errno;
1429 
1430   g_free (wfilename);
1431 
1432   errno = save_errno;
1433   return retval;
1434 #else
</pre>
</td>
<td>
<hr />
<pre>
   2  *
   3  * Copyright 2004 Tor Lillqvist
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public License
  16  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  */
  18 
  19 #include &quot;config.h&quot;
  20 #include &quot;glibconfig.h&quot;
  21 
<span class="line-modified">  22 /* Don&#39;t redefine (for example) g_open() to open(), since we actually want to</span>
<span class="line-added">  23  * define g_open() in this file and export it as a symbol. See gstdio.h. */</span>
<span class="line-added">  24 #define G_STDIO_WRAP_ON_UNIX</span>
  25 
  26 #include &lt;sys/types.h&gt;
  27 #include &lt;sys/stat.h&gt;
  28 #include &lt;fcntl.h&gt;
  29 
  30 #ifdef G_OS_UNIX
  31 #include &lt;unistd.h&gt;
  32 #endif
  33 
  34 #ifdef G_OS_WIN32
  35 #include &lt;windows.h&gt;
  36 #include &lt;errno.h&gt;
  37 #include &lt;wchar.h&gt;
  38 #include &lt;direct.h&gt;
  39 #include &lt;io.h&gt;
  40 #include &lt;sys/utime.h&gt;
<span class="line-added">  41 #include &lt;stdlib.h&gt; /* for MB_CUR_MAX */</span>
  42 #else
  43 #include &lt;utime.h&gt;
  44 #include &lt;errno.h&gt;
  45 #endif
  46 
  47 #include &quot;gstdio.h&quot;
  48 #include &quot;gstdioprivate.h&quot;
  49 
  50 #if !defined (G_OS_UNIX) &amp;&amp; !defined (G_OS_WIN32)
  51 #error Please port this to your operating system
  52 #endif
  53 
  54 #if defined (_MSC_VER) &amp;&amp; !defined(_WIN64)
  55 #undef _wstat
  56 #define _wstat _wstat32
  57 #endif
  58 
  59 #if defined (G_OS_WIN32)
  60 
  61 /* We can&#39;t include Windows DDK and Windows SDK simultaneously,
</pre>
<hr />
<pre>
  85       USHORT SubstituteNameLength;
  86       USHORT PrintNameOffset;
  87       USHORT PrintNameLength;
  88       WCHAR  PathBuffer[1];
  89     } MountPointReparseBuffer;
  90     struct
  91     {
  92       UCHAR  DataBuffer[1];
  93     } GenericReparseBuffer;
  94   };
  95 } REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;
  96 
  97 static int
  98 w32_error_to_errno (DWORD error_code)
  99 {
 100   switch (error_code)
 101     {
 102     case ERROR_ACCESS_DENIED:
 103       return EACCES;
 104       break;
<span class="line-modified"> 105     case ERROR_ALREADY_EXISTS:</span>
<span class="line-modified"> 106     case ERROR_FILE_EXISTS:</span>
<span class="line-added"> 107       return EEXIST;</span>
<span class="line-added"> 108     case ERROR_FILE_NOT_FOUND:</span>
<span class="line-added"> 109       return ENOENT;</span>
 110       break;
 111     case ERROR_INVALID_FUNCTION:
 112       return EFAULT;
 113       break;
<span class="line-modified"> 114     case ERROR_INVALID_HANDLE:</span>
<span class="line-modified"> 115       return EBADF;</span>
 116       break;
<span class="line-modified"> 117     case ERROR_INVALID_PARAMETER:</span>
<span class="line-modified"> 118       return EINVAL;</span>
<span class="line-added"> 119       break;</span>
<span class="line-added"> 120     case ERROR_LOCK_VIOLATION:</span>
<span class="line-added"> 121     case ERROR_SHARING_VIOLATION:</span>
<span class="line-added"> 122       return EACCES;</span>
 123       break;
 124     case ERROR_NOT_ENOUGH_MEMORY:
 125     case ERROR_OUTOFMEMORY:
 126       return ENOMEM;
 127       break;
<span class="line-added"> 128     case ERROR_NOT_SAME_DEVICE:</span>
<span class="line-added"> 129       return EXDEV;</span>
<span class="line-added"> 130       break;</span>
<span class="line-added"> 131     case ERROR_PATH_NOT_FOUND:</span>
<span class="line-added"> 132       return ENOENT; /* or ELOOP, or ENAMETOOLONG */</span>
<span class="line-added"> 133       break;</span>
 134     default:
 135       return EIO;
 136       break;
 137     }
 138 }
 139 
 140 #include &quot;gstdio-private.c&quot;
 141 
<span class="line-added"> 142 /* Windows implementation of fopen() does not accept modes such as</span>
<span class="line-added"> 143  * &quot;wb+&quot;. The &#39;b&#39; needs to be appended to &quot;w+&quot;, i.e. &quot;w+b&quot;. Note</span>
<span class="line-added"> 144  * that otherwise these 2 modes are supposed to be aliases, hence</span>
<span class="line-added"> 145  * swappable at will. TODO: Is this still true?</span>
<span class="line-added"> 146  */</span>
<span class="line-added"> 147 static void</span>
<span class="line-added"> 148 _g_win32_fix_mode (wchar_t *mode)</span>
<span class="line-added"> 149 {</span>
<span class="line-added"> 150   wchar_t *ptr;</span>
<span class="line-added"> 151   wchar_t temp;</span>
<span class="line-added"> 152 </span>
<span class="line-added"> 153   ptr = wcschr (mode, L&#39;+&#39;);</span>
<span class="line-added"> 154   if (ptr != NULL &amp;&amp; (ptr - mode) &gt; 1)</span>
<span class="line-added"> 155     {</span>
<span class="line-added"> 156       temp = mode[1];</span>
<span class="line-added"> 157       mode[1] = *ptr;</span>
<span class="line-added"> 158       *ptr = temp;</span>
<span class="line-added"> 159     }</span>
<span class="line-added"> 160 }</span>
<span class="line-added"> 161 </span>
<span class="line-added"> 162 /* From</span>
<span class="line-added"> 163  * https://support.microsoft.com/en-ca/help/167296/how-to-convert-a-unix-time-t-to-a-win32-filetime-or-systemtime</span>
<span class="line-added"> 164  * FT = UT * 10000000 + 116444736000000000.</span>
<span class="line-added"> 165  * Therefore:</span>
<span class="line-added"> 166  * UT = (FT - 116444736000000000) / 10000000.</span>
<span class="line-added"> 167  * Converts FILETIME to unix epoch time in form</span>
<span class="line-added"> 168  * of a signed 64-bit integer (can be negative).</span>
<span class="line-added"> 169  */</span>
<span class="line-added"> 170 static gint64</span>
<span class="line-added"> 171 _g_win32_filetime_to_unix_time (FILETIME *ft)</span>
<span class="line-added"> 172 {</span>
<span class="line-added"> 173   gint64 result;</span>
<span class="line-added"> 174   /* 1 unit of FILETIME is 100ns */</span>
<span class="line-added"> 175   const gint64 hundreds_of_usec_per_sec = 10000000;</span>
<span class="line-added"> 176   /* The difference between January 1, 1601 UTC (FILETIME epoch) and UNIX epoch</span>
<span class="line-added"> 177    * in hundreds of nanoseconds.</span>
<span class="line-added"> 178    */</span>
<span class="line-added"> 179   const gint64 filetime_unix_epoch_offset = 116444736000000000;</span>
<span class="line-added"> 180 </span>
<span class="line-added"> 181   result = ((gint64) ft-&gt;dwLowDateTime) | (((gint64) ft-&gt;dwHighDateTime) &lt;&lt; 32);</span>
<span class="line-added"> 182   return (result - filetime_unix_epoch_offset) / hundreds_of_usec_per_sec;</span>
<span class="line-added"> 183 }</span>
<span class="line-added"> 184 </span>
<span class="line-added"> 185 #  ifdef _MSC_VER</span>
<span class="line-added"> 186 #    ifndef S_IXUSR</span>
<span class="line-added"> 187 #      define _S_IRUSR _S_IREAD</span>
<span class="line-added"> 188 #      define _S_IWUSR _S_IWRITE</span>
<span class="line-added"> 189 #      define _S_IXUSR _S_IEXEC</span>
<span class="line-added"> 190 #      define S_IRUSR _S_IRUSR</span>
<span class="line-added"> 191 #      define S_IWUSR _S_IWUSR</span>
<span class="line-added"> 192 #      define S_IXUSR _S_IXUSR</span>
<span class="line-added"> 193 #      define S_IRGRP (S_IRUSR &gt;&gt; 3)</span>
<span class="line-added"> 194 #      define S_IWGRP (S_IWUSR &gt;&gt; 3)</span>
<span class="line-added"> 195 #      define S_IXGRP (S_IXUSR &gt;&gt; 3)</span>
<span class="line-added"> 196 #      define S_IROTH (S_IRGRP &gt;&gt; 3)</span>
<span class="line-added"> 197 #      define S_IWOTH (S_IWGRP &gt;&gt; 3)</span>
<span class="line-added"> 198 #      define S_IXOTH (S_IXGRP &gt;&gt; 3)</span>
<span class="line-added"> 199 #    endif</span>
<span class="line-added"> 200 #    ifndef S_ISDIR</span>
<span class="line-added"> 201 #      define S_ISDIR(m) (((m) &amp; _S_IFMT) == _S_IFDIR)</span>
<span class="line-added"> 202 #    endif</span>
<span class="line-added"> 203 #  endif</span>
<span class="line-added"> 204 </span>
<span class="line-added"> 205 /* Uses filename and BHFI to fill a stat64 structure.</span>
<span class="line-added"> 206  * Tries to reproduce the behaviour and quirks of MS C runtime stat().</span>
<span class="line-added"> 207  */</span>
<span class="line-added"> 208 static int</span>
<span class="line-added"> 209 _g_win32_fill_statbuf_from_handle_info (const wchar_t              *filename,</span>
<span class="line-added"> 210                                         const wchar_t              *filename_target,</span>
<span class="line-added"> 211                                         BY_HANDLE_FILE_INFORMATION *handle_info,</span>
<span class="line-added"> 212                                         struct __stat64            *statbuf)</span>
<span class="line-added"> 213 {</span>
<span class="line-added"> 214   wchar_t drive_letter_w = 0;</span>
<span class="line-added"> 215   size_t drive_letter_size = MB_CUR_MAX;</span>
<span class="line-added"> 216   char *drive_letter = _alloca (drive_letter_size);</span>
<span class="line-added"> 217 </span>
<span class="line-added"> 218   /* If filename (target or link) is absolute,</span>
<span class="line-added"> 219    * then use the drive letter from it as-is.</span>
<span class="line-added"> 220    */</span>
<span class="line-added"> 221   if (filename_target != NULL &amp;&amp;</span>
<span class="line-added"> 222       filename_target[0] != L&#39;\0&#39; &amp;&amp;</span>
<span class="line-added"> 223       filename_target[1] == L&#39;:&#39;)</span>
<span class="line-added"> 224     drive_letter_w = filename_target[0];</span>
<span class="line-added"> 225   else if (filename[0] != L&#39;\0&#39; &amp;&amp;</span>
<span class="line-added"> 226            filename[1] == L&#39;:&#39;)</span>
<span class="line-added"> 227     drive_letter_w = filename[0];</span>
<span class="line-added"> 228 </span>
<span class="line-added"> 229   if (drive_letter_w &gt; 0 &amp;&amp;</span>
<span class="line-added"> 230       iswalpha (drive_letter_w) &amp;&amp;</span>
<span class="line-added"> 231       iswascii (drive_letter_w) &amp;&amp;</span>
<span class="line-added"> 232       wctomb (drive_letter, drive_letter_w) == 1)</span>
<span class="line-added"> 233     statbuf-&gt;st_dev = toupper (drive_letter[0]) - &#39;A&#39;; /* 0 means A: drive */</span>
<span class="line-added"> 234   else</span>
<span class="line-added"> 235     /* Otherwise use the PWD drive.</span>
<span class="line-added"> 236      * Return value of 0 gives us 0 - 1 = -1,</span>
<span class="line-added"> 237      * which is the &quot;no idea&quot; value for st_dev.</span>
<span class="line-added"> 238      */</span>
<span class="line-added"> 239     statbuf-&gt;st_dev = _getdrive () - 1;</span>
<span class="line-added"> 240 </span>
<span class="line-added"> 241   statbuf-&gt;st_rdev = statbuf-&gt;st_dev;</span>
<span class="line-added"> 242   /* Theoretically, it&#39;s possible to set it for ext-FS. No idea how.</span>
<span class="line-added"> 243    * Meaningless for all filesystems that Windows normally uses.</span>
<span class="line-added"> 244    */</span>
<span class="line-added"> 245   statbuf-&gt;st_ino = 0;</span>
<span class="line-added"> 246   statbuf-&gt;st_mode = 0;</span>
<span class="line-added"> 247 </span>
<span class="line-added"> 248   if ((handle_info-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)</span>
<span class="line-added"> 249     statbuf-&gt;st_mode |= S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;</span>
<span class="line-added"> 250   else</span>
<span class="line-added"> 251     statbuf-&gt;st_mode |= S_IFREG;</span>
<span class="line-added"> 252   /* No idea what S_IFCHR means here. */</span>
<span class="line-added"> 253   /* S_IFIFO is not even mentioned in MSDN */</span>
<span class="line-added"> 254   /* S_IFBLK is also not mentioned */</span>
<span class="line-added"> 255 </span>
<span class="line-added"> 256   /* The aim here is to reproduce MS stat() behaviour,</span>
<span class="line-added"> 257    * even if it&#39;s braindead.</span>
<span class="line-added"> 258    */</span>
<span class="line-added"> 259   statbuf-&gt;st_mode |= S_IRUSR | S_IRGRP | S_IROTH;</span>
<span class="line-added"> 260   if ((handle_info-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_READONLY) != FILE_ATTRIBUTE_READONLY)</span>
<span class="line-added"> 261     statbuf-&gt;st_mode |= S_IWUSR | S_IWGRP | S_IWOTH;</span>
<span class="line-added"> 262 </span>
<span class="line-added"> 263   if (!S_ISDIR (statbuf-&gt;st_mode))</span>
<span class="line-added"> 264     {</span>
<span class="line-added"> 265       const wchar_t *name;</span>
<span class="line-added"> 266       const wchar_t *dot = NULL;</span>
<span class="line-added"> 267 </span>
<span class="line-added"> 268       if (filename_target != NULL)</span>
<span class="line-added"> 269         name = filename_target;</span>
<span class="line-added"> 270       else</span>
<span class="line-added"> 271         name = filename;</span>
<span class="line-added"> 272 </span>
<span class="line-added"> 273       do</span>
<span class="line-added"> 274         {</span>
<span class="line-added"> 275           wchar_t *last_dot = wcschr (name, L&#39;.&#39;);</span>
<span class="line-added"> 276           if (last_dot == NULL)</span>
<span class="line-added"> 277             break;</span>
<span class="line-added"> 278           dot = last_dot;</span>
<span class="line-added"> 279           name = &amp;last_dot[1];</span>
<span class="line-added"> 280         }</span>
<span class="line-added"> 281       while (TRUE);</span>
<span class="line-added"> 282 </span>
<span class="line-added"> 283       if ((dot != NULL &amp;&amp;</span>
<span class="line-added"> 284           (wcsicmp (dot, L&quot;.exe&quot;) == 0 ||</span>
<span class="line-added"> 285            wcsicmp (dot, L&quot;.com&quot;) == 0 ||</span>
<span class="line-added"> 286            wcsicmp (dot, L&quot;.bat&quot;) == 0 ||</span>
<span class="line-added"> 287            wcsicmp (dot, L&quot;.cmd&quot;) == 0)))</span>
<span class="line-added"> 288         statbuf-&gt;st_mode |= S_IXUSR | S_IXGRP | S_IXOTH;</span>
<span class="line-added"> 289     }</span>
<span class="line-added"> 290 </span>
<span class="line-added"> 291   statbuf-&gt;st_nlink = handle_info-&gt;nNumberOfLinks;</span>
<span class="line-added"> 292   statbuf-&gt;st_uid = statbuf-&gt;st_gid = 0;</span>
<span class="line-added"> 293   statbuf-&gt;st_size = (((guint64) handle_info-&gt;nFileSizeHigh) &lt;&lt; 32) | handle_info-&gt;nFileSizeLow;</span>
<span class="line-added"> 294   statbuf-&gt;st_ctime = _g_win32_filetime_to_unix_time (&amp;handle_info-&gt;ftCreationTime);</span>
<span class="line-added"> 295   statbuf-&gt;st_mtime = _g_win32_filetime_to_unix_time (&amp;handle_info-&gt;ftLastWriteTime);</span>
<span class="line-added"> 296   statbuf-&gt;st_atime = _g_win32_filetime_to_unix_time (&amp;handle_info-&gt;ftLastAccessTime);</span>
<span class="line-added"> 297 </span>
<span class="line-added"> 298   return 0;</span>
<span class="line-added"> 299 }</span>
<span class="line-added"> 300 </span>
<span class="line-added"> 301 /* Fills our private stat-like structure using data from</span>
<span class="line-added"> 302  * a normal stat64 struct, BHFI, FSI and a reparse tag.</span>
<span class="line-added"> 303  */</span>
<span class="line-added"> 304 static void</span>
<span class="line-added"> 305 _g_win32_fill_privatestat (const struct __stat64            *statbuf,</span>
<span class="line-added"> 306                            const BY_HANDLE_FILE_INFORMATION *handle_info,</span>
<span class="line-added"> 307                            const FILE_STANDARD_INFO         *std_info,</span>
<span class="line-added"> 308                            DWORD                             reparse_tag,</span>
<span class="line-added"> 309                            GWin32PrivateStat                *buf)</span>
<span class="line-added"> 310 {</span>
<span class="line-added"> 311   buf-&gt;st_dev = statbuf-&gt;st_dev;</span>
<span class="line-added"> 312   buf-&gt;st_mode = statbuf-&gt;st_mode;</span>
<span class="line-added"> 313   buf-&gt;volume_serial = handle_info-&gt;dwVolumeSerialNumber;</span>
<span class="line-added"> 314   buf-&gt;file_index = (((guint64) handle_info-&gt;nFileIndexHigh) &lt;&lt; 32) | handle_info-&gt;nFileIndexLow;</span>
<span class="line-added"> 315   buf-&gt;attributes = handle_info-&gt;dwFileAttributes;</span>
<span class="line-added"> 316   buf-&gt;st_nlink = handle_info-&gt;nNumberOfLinks;</span>
<span class="line-added"> 317   buf-&gt;st_size = (((guint64) handle_info-&gt;nFileSizeHigh) &lt;&lt; 32) | handle_info-&gt;nFileSizeLow;</span>
<span class="line-added"> 318   buf-&gt;allocated_size = std_info-&gt;AllocationSize.QuadPart;</span>
<span class="line-added"> 319 </span>
<span class="line-added"> 320   buf-&gt;reparse_tag = reparse_tag;</span>
<span class="line-added"> 321 </span>
<span class="line-added"> 322   buf-&gt;st_ctime = statbuf-&gt;st_ctime;</span>
<span class="line-added"> 323   buf-&gt;st_atime = statbuf-&gt;st_atime;</span>
<span class="line-added"> 324   buf-&gt;st_mtime = statbuf-&gt;st_mtime;</span>
<span class="line-added"> 325 }</span>
<span class="line-added"> 326 </span>
<span class="line-added"> 327 /* Read the link data from a symlink/mountpoint represented</span>
<span class="line-added"> 328  * by the handle. Also reads reparse tag.</span>
<span class="line-added"> 329  * @reparse_tag receives the tag. Can be %NULL if @buf or @alloc_buf</span>
<span class="line-added"> 330  *              is non-NULL.</span>
<span class="line-added"> 331  * @buf receives the link data. Can be %NULL if reparse_tag is non-%NULL.</span>
<span class="line-added"> 332  *      Mutually-exclusive with @alloc_buf.</span>
<span class="line-added"> 333  * @buf_size is the size of the @buf, in bytes.</span>
<span class="line-added"> 334  * @alloc_buf points to a location where internally-allocated buffer</span>
<span class="line-added"> 335  *            pointer will be written. That buffer receives the</span>
<span class="line-added"> 336  *            link data. Mutually-exclusive with @buf.</span>
<span class="line-added"> 337  * @terminate ensures that the buffer is NUL-terminated if</span>
<span class="line-added"> 338  *            it isn&#39;t already. Note that this can erase useful</span>
<span class="line-added"> 339  *            data if @buf is provided and @buf_size is too small.</span>
<span class="line-added"> 340  *            Specifically, with @buf_size &lt;= 2 the buffer will</span>
<span class="line-added"> 341  *            receive an empty string, even if there is some</span>
<span class="line-added"> 342  *            data in the reparse point.</span>
<span class="line-added"> 343  * The contents of @buf or @alloc_buf are presented as-is - could</span>
<span class="line-added"> 344  * be non-NUL-terminated (unless @terminate is %TRUE) or even malformed.</span>
<span class="line-added"> 345  * Returns the number of bytes (!) placed into @buf or @alloc_buf,</span>
<span class="line-added"> 346  * including NUL-terminator (if any).</span>
<span class="line-added"> 347  *</span>
<span class="line-added"> 348  * Returned value of 0 means that there&#39;s no recognizable data in the</span>
<span class="line-added"> 349  * reparse point. @alloc_buf will not be allocated in that case,</span>
<span class="line-added"> 350  * and @buf will be left unmodified.</span>
<span class="line-added"> 351  *</span>
<span class="line-added"> 352  * If @buf and @alloc_buf are %NULL, returns 0 to indicate success.</span>
<span class="line-added"> 353  * Returns -1 to indicate an error, sets errno.</span>
<span class="line-added"> 354  */</span>
<span class="line-added"> 355 static int</span>
<span class="line-added"> 356 _g_win32_readlink_handle_raw (HANDLE      h,</span>
<span class="line-added"> 357                               DWORD      *reparse_tag,</span>
<span class="line-added"> 358                               gunichar2  *buf,</span>
<span class="line-added"> 359                               gsize       buf_size,</span>
<span class="line-added"> 360                               gunichar2 **alloc_buf,</span>
<span class="line-added"> 361                               gboolean    terminate)</span>
<span class="line-added"> 362 {</span>
<span class="line-added"> 363   DWORD error_code;</span>
<span class="line-added"> 364   DWORD returned_bytes = 0;</span>
<span class="line-added"> 365   BYTE *data;</span>
<span class="line-added"> 366   gsize to_copy;</span>
<span class="line-added"> 367   /* This is 16k. It&#39;s impossible to make DeviceIoControl() tell us</span>
<span class="line-added"> 368    * the required size. NtFsControlFile() does have such a feature,</span>
<span class="line-added"> 369    * but for some reason it doesn&#39;t work with CreateFile()-returned handles.</span>
<span class="line-added"> 370    * The only alternative is to repeatedly call DeviceIoControl()</span>
<span class="line-added"> 371    * with bigger and bigger buffers, until it succeeds.</span>
<span class="line-added"> 372    * We choose to sacrifice stack space for speed.</span>
<span class="line-added"> 373    */</span>
<span class="line-added"> 374   BYTE max_buffer[sizeof (REPARSE_DATA_BUFFER) + MAXIMUM_REPARSE_DATA_BUFFER_SIZE] = {0,};</span>
<span class="line-added"> 375   DWORD max_buffer_size = sizeof (REPARSE_DATA_BUFFER) + MAXIMUM_REPARSE_DATA_BUFFER_SIZE;</span>
<span class="line-added"> 376   REPARSE_DATA_BUFFER *rep_buf;</span>
<span class="line-added"> 377 </span>
<span class="line-added"> 378   g_return_val_if_fail ((buf != NULL || alloc_buf != NULL || reparse_tag != NULL) &amp;&amp;</span>
<span class="line-added"> 379                         (buf == NULL || alloc_buf == NULL),</span>
<span class="line-added"> 380                         -1);</span>
<span class="line-added"> 381 </span>
<span class="line-added"> 382   if (!DeviceIoControl (h, FSCTL_GET_REPARSE_POINT, NULL, 0,</span>
<span class="line-added"> 383                         max_buffer,</span>
<span class="line-added"> 384                         max_buffer_size,</span>
<span class="line-added"> 385                         &amp;returned_bytes, NULL))</span>
<span class="line-added"> 386     {</span>
<span class="line-added"> 387       error_code = GetLastError ();</span>
<span class="line-added"> 388       errno = w32_error_to_errno (error_code);</span>
<span class="line-added"> 389       return -1;</span>
<span class="line-added"> 390     }</span>
<span class="line-added"> 391 </span>
<span class="line-added"> 392   rep_buf = (REPARSE_DATA_BUFFER *) max_buffer;</span>
<span class="line-added"> 393 </span>
<span class="line-added"> 394   if (reparse_tag != NULL)</span>
<span class="line-added"> 395     *reparse_tag = rep_buf-&gt;ReparseTag;</span>
<span class="line-added"> 396 </span>
<span class="line-added"> 397   if (buf == NULL &amp;&amp; alloc_buf == NULL)</span>
<span class="line-added"> 398     return 0;</span>
<span class="line-added"> 399 </span>
<span class="line-added"> 400   if (rep_buf-&gt;ReparseTag == IO_REPARSE_TAG_SYMLINK)</span>
<span class="line-added"> 401     {</span>
<span class="line-added"> 402       data = &amp;((BYTE *) rep_buf-&gt;SymbolicLinkReparseBuffer.PathBuffer)[rep_buf-&gt;SymbolicLinkReparseBuffer.SubstituteNameOffset];</span>
<span class="line-added"> 403 </span>
<span class="line-added"> 404       to_copy = rep_buf-&gt;SymbolicLinkReparseBuffer.SubstituteNameLength;</span>
<span class="line-added"> 405     }</span>
<span class="line-added"> 406   else if (rep_buf-&gt;ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)</span>
<span class="line-added"> 407     {</span>
<span class="line-added"> 408       data = &amp;((BYTE *) rep_buf-&gt;MountPointReparseBuffer.PathBuffer)[rep_buf-&gt;MountPointReparseBuffer.SubstituteNameOffset];</span>
<span class="line-added"> 409 </span>
<span class="line-added"> 410       to_copy = rep_buf-&gt;MountPointReparseBuffer.SubstituteNameLength;</span>
<span class="line-added"> 411     }</span>
<span class="line-added"> 412   else</span>
<span class="line-added"> 413     to_copy = 0;</span>
<span class="line-added"> 414 </span>
<span class="line-added"> 415   return _g_win32_copy_and_maybe_terminate (data, to_copy, buf, buf_size, alloc_buf, terminate);</span>
<span class="line-added"> 416 }</span>
<span class="line-added"> 417 </span>
<span class="line-added"> 418 /* Read the link data from a symlink/mountpoint represented</span>
<span class="line-added"> 419  * by the @filename.</span>
<span class="line-added"> 420  * @filename is the name of the file.</span>
<span class="line-added"> 421  * @reparse_tag receives the tag. Can be %NULL if @buf or @alloc_buf</span>
<span class="line-added"> 422  *              is non-%NULL.</span>
<span class="line-added"> 423  * @buf receives the link data. Mutually-exclusive with @alloc_buf.</span>
<span class="line-added"> 424  * @buf_size is the size of the @buf, in bytes.</span>
<span class="line-added"> 425  * @alloc_buf points to a location where internally-allocated buffer</span>
<span class="line-added"> 426  *            pointer will be written. That buffer receives the</span>
<span class="line-added"> 427  *            link data. Mutually-exclusive with @buf.</span>
<span class="line-added"> 428  * @terminate ensures that the buffer is NUL-terminated if</span>
<span class="line-added"> 429  *            it isn&#39;t already</span>
<span class="line-added"> 430  * The contents of @buf or @alloc_buf are presented as-is - could</span>
<span class="line-added"> 431  * be non-NUL-terminated (unless @terminate is TRUE) or even malformed.</span>
<span class="line-added"> 432  * Returns the number of bytes (!) placed into @buf or @alloc_buf.</span>
<span class="line-added"> 433  * Returned value of 0 means that there&#39;s no recognizable data in the</span>
<span class="line-added"> 434  * reparse point. @alloc_buf will not be allocated in that case,</span>
<span class="line-added"> 435  * and @buf will be left unmodified.</span>
<span class="line-added"> 436  * If @buf and @alloc_buf are %NULL, returns 0 to indicate success.</span>
<span class="line-added"> 437  * Returns -1 to indicate an error, sets errno.</span>
<span class="line-added"> 438  */</span>
<span class="line-added"> 439 static int</span>
<span class="line-added"> 440 _g_win32_readlink_utf16_raw (const gunichar2  *filename,</span>
<span class="line-added"> 441                              DWORD            *reparse_tag,</span>
<span class="line-added"> 442                              gunichar2        *buf,</span>
<span class="line-added"> 443                              gsize             buf_size,</span>
<span class="line-added"> 444                              gunichar2       **alloc_buf,</span>
<span class="line-added"> 445                              gboolean          terminate)</span>
<span class="line-added"> 446 {</span>
<span class="line-added"> 447   HANDLE h;</span>
<span class="line-added"> 448   DWORD attributes;</span>
<span class="line-added"> 449   DWORD to_copy;</span>
<span class="line-added"> 450   DWORD error_code;</span>
<span class="line-added"> 451 </span>
<span class="line-added"> 452   if ((attributes = GetFileAttributesW (filename)) == 0)</span>
<span class="line-added"> 453     {</span>
<span class="line-added"> 454       error_code = GetLastError ();</span>
<span class="line-added"> 455       errno = w32_error_to_errno (error_code);</span>
<span class="line-added"> 456       return -1;</span>
<span class="line-added"> 457     }</span>
<span class="line-added"> 458 </span>
<span class="line-added"> 459   if ((attributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) == 0)</span>
<span class="line-added"> 460     {</span>
<span class="line-added"> 461       errno = EINVAL;</span>
<span class="line-added"> 462       return -1;</span>
<span class="line-added"> 463     }</span>
<span class="line-added"> 464 </span>
<span class="line-added"> 465   /* To read symlink target we need to open the file as a reparse</span>
<span class="line-added"> 466    * point and use DeviceIoControl() on it.</span>
<span class="line-added"> 467    */</span>
<span class="line-added"> 468   h = CreateFileW (filename,</span>
<span class="line-added"> 469                    FILE_READ_EA,</span>
<span class="line-added"> 470                    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,</span>
<span class="line-added"> 471                    NULL, OPEN_EXISTING,</span>
<span class="line-added"> 472                    FILE_ATTRIBUTE_NORMAL</span>
<span class="line-added"> 473                    | FILE_FLAG_OPEN_REPARSE_POINT</span>
<span class="line-added"> 474                    | (attributes &amp; FILE_ATTRIBUTE_DIRECTORY ? FILE_FLAG_BACKUP_SEMANTICS : 0),</span>
<span class="line-added"> 475                    NULL);</span>
<span class="line-added"> 476 </span>
<span class="line-added"> 477   if (h == INVALID_HANDLE_VALUE)</span>
<span class="line-added"> 478     {</span>
<span class="line-added"> 479       error_code = GetLastError ();</span>
<span class="line-added"> 480       errno = w32_error_to_errno (error_code);</span>
<span class="line-added"> 481       return -1;</span>
<span class="line-added"> 482     }</span>
<span class="line-added"> 483 </span>
<span class="line-added"> 484   to_copy = _g_win32_readlink_handle_raw (h, reparse_tag, buf, buf_size, alloc_buf, terminate);</span>
<span class="line-added"> 485 </span>
<span class="line-added"> 486   CloseHandle (h);</span>
<span class="line-added"> 487 </span>
<span class="line-added"> 488   return to_copy;</span>
<span class="line-added"> 489 }</span>
<span class="line-added"> 490 </span>
<span class="line-added"> 491 /* Read the link data from a symlink/mountpoint represented</span>
<span class="line-added"> 492  * by a UTF-16 filename or a file handle.</span>
<span class="line-added"> 493  * @filename is the name of the file. Mutually-exclusive with @file_handle.</span>
<span class="line-added"> 494  * @file_handle is the handle of the file. Mutually-exclusive with @filename.</span>
<span class="line-added"> 495  * @reparse_tag receives the tag. Can be %NULL if @buf or @alloc_buf</span>
<span class="line-added"> 496  *              is non-%NULL.</span>
<span class="line-added"> 497  * @buf receives the link data. Mutually-exclusive with @alloc_buf.</span>
<span class="line-added"> 498  * @buf_size is the size of the @buf, in bytes.</span>
<span class="line-added"> 499  * @alloc_buf points to a location where internally-allocated buffer</span>
<span class="line-added"> 500  *            pointer will be written. That buffer receives the</span>
<span class="line-added"> 501  *            link data. Mutually-exclusive with @buf.</span>
<span class="line-added"> 502  * @terminate ensures that the buffer is NUL-terminated if</span>
<span class="line-added"> 503  *            it isn&#39;t already</span>
<span class="line-added"> 504  * The contents of @buf or @alloc_buf are adjusted</span>
<span class="line-added"> 505  * (extended or nt object manager prefix is stripped),</span>
<span class="line-added"> 506  * but otherwise they are presented as-is - could be non-NUL-terminated</span>
<span class="line-added"> 507  * (unless @terminate is TRUE) or even malformed.</span>
<span class="line-added"> 508  * Returns the number of bytes (!) placed into @buf or @alloc_buf.</span>
<span class="line-added"> 509  * Returned value of 0 means that there&#39;s no recognizable data in the</span>
<span class="line-added"> 510  * reparse point. @alloc_buf will not be allocated in that case,</span>
<span class="line-added"> 511  * and @buf will be left unmodified.</span>
<span class="line-added"> 512  * Returns -1 to indicate an error, sets errno.</span>
<span class="line-added"> 513  */</span>
<span class="line-added"> 514 static int</span>
<span class="line-added"> 515 _g_win32_readlink_utf16_handle (const gunichar2  *filename,</span>
<span class="line-added"> 516                                 HANDLE            file_handle,</span>
<span class="line-added"> 517                                 DWORD            *reparse_tag,</span>
<span class="line-added"> 518                                 gunichar2        *buf,</span>
<span class="line-added"> 519                                 gsize             buf_size,</span>
<span class="line-added"> 520                                 gunichar2       **alloc_buf,</span>
<span class="line-added"> 521                                 gboolean          terminate)</span>
<span class="line-added"> 522 {</span>
<span class="line-added"> 523   int   result;</span>
<span class="line-added"> 524   gsize string_size;</span>
<span class="line-added"> 525 </span>
<span class="line-added"> 526   g_return_val_if_fail ((buf != NULL || alloc_buf != NULL || reparse_tag != NULL) &amp;&amp;</span>
<span class="line-added"> 527                         (filename != NULL || file_handle != NULL) &amp;&amp;</span>
<span class="line-added"> 528                         (buf == NULL || alloc_buf == NULL) &amp;&amp;</span>
<span class="line-added"> 529                         (filename == NULL || file_handle == NULL),</span>
<span class="line-added"> 530                         -1);</span>
<span class="line-added"> 531 </span>
<span class="line-added"> 532   if (filename)</span>
<span class="line-added"> 533     result = _g_win32_readlink_utf16_raw (filename, reparse_tag, buf, buf_size, alloc_buf, terminate);</span>
<span class="line-added"> 534   else</span>
<span class="line-added"> 535     result = _g_win32_readlink_handle_raw (file_handle, reparse_tag, buf, buf_size, alloc_buf, terminate);</span>
<span class="line-added"> 536 </span>
<span class="line-added"> 537   if (result &lt;= 0)</span>
<span class="line-added"> 538     return result;</span>
<span class="line-added"> 539 </span>
<span class="line-added"> 540   /* Ensure that output is a multiple of sizeof (gunichar2),</span>
<span class="line-added"> 541    * cutting any trailing partial gunichar2, if present.</span>
<span class="line-added"> 542    */</span>
<span class="line-added"> 543   result -= result % sizeof (gunichar2);</span>
<span class="line-added"> 544 </span>
<span class="line-added"> 545   if (result &lt;= 0)</span>
<span class="line-added"> 546     return result;</span>
<span class="line-added"> 547 </span>
<span class="line-added"> 548   /* DeviceIoControl () tends to return filenames as NT Object Manager</span>
<span class="line-added"> 549    * names , i.e. &quot;\\??\\C:\\foo\\bar&quot;.</span>
<span class="line-added"> 550    * Remove the leading 4-byte &quot;\\??\\&quot; prefix, as glib (as well as many W32 API</span>
<span class="line-added"> 551    * functions) is unprepared to deal with it. Unless it has no &#39;x:&#39; drive</span>
<span class="line-added"> 552    * letter part after the prefix, in which case we leave everything</span>
<span class="line-added"> 553    * as-is, because the path could be &quot;\\??\\Volume{GUID}&quot; - stripping</span>
<span class="line-added"> 554    * the prefix will allow it to be confused with relative links</span>
<span class="line-added"> 555    * targeting &quot;Volume{GUID}&quot;.</span>
<span class="line-added"> 556    */</span>
<span class="line-added"> 557   string_size = result / sizeof (gunichar2);</span>
<span class="line-added"> 558   _g_win32_strip_extended_ntobjm_prefix (buf ? buf : *alloc_buf, &amp;string_size);</span>
<span class="line-added"> 559 </span>
<span class="line-added"> 560   return string_size * sizeof (gunichar2);</span>
<span class="line-added"> 561 }</span>
<span class="line-added"> 562 </span>
<span class="line-added"> 563 /* Works like stat() or lstat(), depending on the value of @for_symlink,</span>
<span class="line-added"> 564  * but accepts filename in UTF-16 and fills our custom stat structure.</span>
<span class="line-added"> 565  * The @filename must not have trailing slashes.</span>
<span class="line-added"> 566  */</span>
 567 static int
 568 _g_win32_stat_utf16_no_trailing_slashes (const gunichar2    *filename,

 569                                          GWin32PrivateStat  *buf,
 570                                          gboolean            for_symlink)
 571 {



 572   struct __stat64 statbuf;
 573   BY_HANDLE_FILE_INFORMATION handle_info;
 574   FILE_STANDARD_INFO std_info;


 575   gboolean is_symlink = FALSE;


 576   wchar_t *filename_target = NULL;
<span class="line-modified"> 577   DWORD immediate_attributes;</span>
<span class="line-added"> 578   DWORD open_flags;</span>
<span class="line-added"> 579   gboolean is_directory;</span>
<span class="line-added"> 580   DWORD reparse_tag = 0;</span>
<span class="line-added"> 581   DWORD error_code;</span>
<span class="line-added"> 582   BOOL succeeded_so_far;</span>
<span class="line-added"> 583   HANDLE file_handle;</span>
 584 
<span class="line-modified"> 585   immediate_attributes = GetFileAttributesW (filename);</span>


 586 
<span class="line-modified"> 587   if (immediate_attributes == INVALID_FILE_ATTRIBUTES)</span>
<span class="line-modified"> 588     {</span>
<span class="line-modified"> 589       error_code = GetLastError ();</span>
<span class="line-modified"> 590       errno = w32_error_to_errno (error_code);</span>
 591 
<span class="line-modified"> 592       return -1;</span>
<span class="line-modified"> 593     }</span>
 594 
<span class="line-modified"> 595   is_symlink = (immediate_attributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;</span>
<span class="line-modified"> 596   is_directory = (immediate_attributes &amp; FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY;</span>
 597 
<span class="line-modified"> 598   open_flags = FILE_ATTRIBUTE_NORMAL;</span>
 599 
<span class="line-modified"> 600   if (for_symlink &amp;&amp; is_symlink)</span>
<span class="line-modified"> 601     open_flags |= FILE_FLAG_OPEN_REPARSE_POINT;</span>
 602 
<span class="line-modified"> 603   if (is_directory)</span>
<span class="line-modified"> 604     open_flags |= FILE_FLAG_BACKUP_SEMANTICS;</span>
 605 
<span class="line-modified"> 606   file_handle = CreateFileW (filename, FILE_READ_ATTRIBUTES | FILE_READ_EA,</span>
<span class="line-modified"> 607                              FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,</span>
<span class="line-modified"> 608                              NULL, OPEN_EXISTING,</span>
<span class="line-modified"> 609                              open_flags,</span>
<span class="line-added"> 610                              NULL);</span>
 611 
<span class="line-modified"> 612   if (file_handle == INVALID_HANDLE_VALUE)</span>







 613     {
<span class="line-modified"> 614       error_code = GetLastError ();</span>
<span class="line-modified"> 615       errno = w32_error_to_errno (error_code);</span>
<span class="line-modified"> 616       return -1;</span>

 617     }
 618 
 619   succeeded_so_far = GetFileInformationByHandle (file_handle,
 620                                                  &amp;handle_info);
 621   error_code = GetLastError ();
 622 
 623   if (succeeded_so_far)
 624     {
 625       succeeded_so_far = GetFileInformationByHandleEx (file_handle,
 626                                                        FileStandardInfo,
 627                                                        &amp;std_info,
 628                                                        sizeof (std_info));
 629       error_code = GetLastError ();
 630     }
 631 
 632   if (!succeeded_so_far)
 633     {
<span class="line-modified"> 634       CloseHandle (file_handle);</span>

 635       errno = w32_error_to_errno (error_code);
 636       return -1;
 637     }
 638 
 639   /* It&#39;s tempting to use GetFileInformationByHandleEx(FileAttributeTagInfo),
 640    * but it always reports that the ReparseTag is 0.
<span class="line-added"> 641    * We already have a handle open for symlink, use that.</span>
<span class="line-added"> 642    * For the target we have to specify a filename, and the function</span>
<span class="line-added"> 643    * will open another handle internally.</span>
 644    */
<span class="line-modified"> 645   if (is_symlink &amp;&amp;</span>
<span class="line-added"> 646       _g_win32_readlink_utf16_handle (for_symlink ? NULL : filename,</span>
<span class="line-added"> 647                                       for_symlink ? file_handle : NULL,</span>
<span class="line-added"> 648                                       &amp;reparse_tag,</span>
<span class="line-added"> 649                                       NULL, 0,</span>
<span class="line-added"> 650                                       for_symlink ? NULL : &amp;filename_target,</span>
<span class="line-added"> 651                                       TRUE) &lt; 0)</span>
 652     {
<span class="line-modified"> 653       CloseHandle (file_handle);</span>
<span class="line-added"> 654       return -1;</span>
<span class="line-added"> 655     }</span>
 656 
<span class="line-modified"> 657   CloseHandle (file_handle);</span>














 658 
<span class="line-modified"> 659   _g_win32_fill_statbuf_from_handle_info (filename,</span>
<span class="line-modified"> 660                                           filename_target,</span>
<span class="line-modified"> 661                                           &amp;handle_info,</span>
<span class="line-modified"> 662                                           &amp;statbuf);</span>
<span class="line-modified"> 663   g_free (filename_target);</span>
<span class="line-modified"> 664   _g_win32_fill_privatestat (&amp;statbuf,</span>
<span class="line-modified"> 665                              &amp;handle_info,</span>
<span class="line-modified"> 666                              &amp;std_info,</span>
<span class="line-modified"> 667                              reparse_tag,</span>
<span class="line-modified"> 668                              buf);</span>









































































 669 
<span class="line-modified"> 670   return 0;</span>
<span class="line-modified"> 671 }</span>



 672 
<span class="line-modified"> 673 /* Works like fstat(), but fills our custom stat structure. */</span>
<span class="line-modified"> 674 static int</span>
<span class="line-modified"> 675 _g_win32_stat_fd (int                 fd,</span>
<span class="line-modified"> 676                   GWin32PrivateStat  *buf)</span>
<span class="line-modified"> 677 {</span>
<span class="line-added"> 678   HANDLE file_handle;</span>
<span class="line-added"> 679   gboolean succeeded_so_far;</span>
<span class="line-added"> 680   DWORD error_code;</span>
<span class="line-added"> 681   struct __stat64 statbuf;</span>
<span class="line-added"> 682   BY_HANDLE_FILE_INFORMATION handle_info;</span>
<span class="line-added"> 683   FILE_STANDARD_INFO std_info;</span>
<span class="line-added"> 684   DWORD reparse_tag = 0;</span>
<span class="line-added"> 685   gboolean is_symlink = FALSE;</span>
 686 
<span class="line-modified"> 687   file_handle = (HANDLE) _get_osfhandle (fd);</span>



 688 
<span class="line-modified"> 689   if (file_handle == INVALID_HANDLE_VALUE)</span>
<span class="line-modified"> 690     return -1;</span>

 691 
<span class="line-modified"> 692   succeeded_so_far = GetFileInformationByHandle (file_handle,</span>
<span class="line-modified"> 693                                                  &amp;handle_info);</span>
<span class="line-added"> 694   error_code = GetLastError ();</span>
 695 
<span class="line-added"> 696   if (succeeded_so_far)</span>
<span class="line-added"> 697     {</span>
<span class="line-added"> 698       succeeded_so_far = GetFileInformationByHandleEx (file_handle,</span>
<span class="line-added"> 699                                                        FileStandardInfo,</span>
<span class="line-added"> 700                                                        &amp;std_info,</span>
<span class="line-added"> 701                                                        sizeof (std_info));</span>
<span class="line-added"> 702       error_code = GetLastError ();</span>
<span class="line-added"> 703     }</span>
<span class="line-added"> 704 </span>
<span class="line-added"> 705   if (!succeeded_so_far)</span>
<span class="line-added"> 706     {</span>
<span class="line-added"> 707       errno = w32_error_to_errno (error_code);</span>
 708       return -1;
 709     }
 710 
<span class="line-modified"> 711   is_symlink = (handle_info.dwFileAttributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;</span>
 712 
<span class="line-modified"> 713   if (is_symlink &amp;&amp;</span>
<span class="line-modified"> 714       _g_win32_readlink_handle_raw (file_handle, &amp;reparse_tag, NULL, 0, NULL, FALSE) &lt; 0)</span>
<span class="line-modified"> 715     return -1;</span>










 716 
<span class="line-modified"> 717   if (_fstat64 (fd, &amp;statbuf) != 0)</span>
<span class="line-modified"> 718     return -1;</span>


 719 
<span class="line-modified"> 720   _g_win32_fill_privatestat (&amp;statbuf,</span>
<span class="line-modified"> 721                              &amp;handle_info,</span>
<span class="line-modified"> 722                              &amp;std_info,</span>
<span class="line-added"> 723                              reparse_tag,</span>
<span class="line-added"> 724                              buf);</span>
 725 
 726   return 0;
 727 }
 728 
<span class="line-added"> 729 /* Works like stat() or lstat(), depending on the value of @for_symlink,</span>
<span class="line-added"> 730  * but accepts filename in UTF-8 and fills our custom stat structure.</span>
<span class="line-added"> 731  */</span>
 732 static int
 733 _g_win32_stat_utf8 (const gchar       *filename,
 734                     GWin32PrivateStat *buf,
 735                     gboolean           for_symlink)
 736 {
 737   wchar_t *wfilename;
 738   int result;
 739   gsize len;
 740 
 741   if (filename == NULL)
 742     {
 743       errno = EINVAL;
 744       return -1;
 745     }
 746 
 747   len = strlen (filename);
 748 
 749   while (len &gt; 0 &amp;&amp; G_IS_DIR_SEPARATOR (filename[len - 1]))
 750     len--;
 751 
 752   if (len &lt;= 0 ||
 753       (g_path_is_absolute (filename) &amp;&amp; len &lt;= g_path_skip_root (filename) - filename))
 754     len = strlen (filename);
 755 
 756   wfilename = g_utf8_to_utf16 (filename, len, NULL, NULL, NULL);
 757 
 758   if (wfilename == NULL)
 759     {
 760       errno = EINVAL;
 761       return -1;
 762     }
 763 
<span class="line-modified"> 764   result = _g_win32_stat_utf16_no_trailing_slashes (wfilename, buf, for_symlink);</span>
 765 
 766   g_free (wfilename);
 767 
 768   return result;
 769 }
 770 
<span class="line-added"> 771 /* Works like stat(), but accepts filename in UTF-8</span>
<span class="line-added"> 772  * and fills our custom stat structure.</span>
<span class="line-added"> 773  */</span>
 774 int
 775 g_win32_stat_utf8 (const gchar       *filename,
 776                    GWin32PrivateStat *buf)
 777 {
 778   return _g_win32_stat_utf8 (filename, buf, FALSE);
 779 }
 780 
<span class="line-added"> 781 /* Works like lstat(), but accepts filename in UTF-8</span>
<span class="line-added"> 782  * and fills our custom stat structure.</span>
<span class="line-added"> 783  */</span>
 784 int
 785 g_win32_lstat_utf8 (const gchar       *filename,
 786                     GWin32PrivateStat *buf)
 787 {
 788   return _g_win32_stat_utf8 (filename, buf, TRUE);
 789 }
 790 
<span class="line-added"> 791 /* Works like fstat(), but accepts filename in UTF-8</span>
<span class="line-added"> 792  * and fills our custom stat structure.</span>
<span class="line-added"> 793  */</span>
 794 int
 795 g_win32_fstat (int                fd,
 796                GWin32PrivateStat *buf)
 797 {
<span class="line-modified"> 798   return _g_win32_stat_fd (fd, buf);</span>
 799 }
 800 
<span class="line-modified"> 801 /**</span>
<span class="line-modified"> 802  * g_win32_readlink_utf8:</span>
<span class="line-modified"> 803  * @filename: (type filename): a pathname in UTF-8</span>
<span class="line-modified"> 804  * @buf: (array length=buf_size) : a buffer to receive the reparse point</span>
<span class="line-added"> 805  *                                 target path. Mutually-exclusive</span>
<span class="line-added"> 806  *                                 with @alloc_buf.</span>
<span class="line-added"> 807  * @buf_size: size of the @buf, in bytes</span>
<span class="line-added"> 808  * @alloc_buf: points to a location where internally-allocated buffer</span>
<span class="line-added"> 809  *             pointer will be written. That buffer receives the</span>
<span class="line-added"> 810  *             link data. Mutually-exclusive with @buf.</span>
<span class="line-added"> 811  * @terminate: ensures that the buffer is NUL-terminated if</span>
<span class="line-added"> 812  *             it isn&#39;t already. If %FALSE, the returned string</span>
<span class="line-added"> 813  *             might not be NUL-terminated (depends entirely on</span>
<span class="line-added"> 814  *             what the contents of the filesystem are).</span>
<span class="line-added"> 815  *</span>
<span class="line-added"> 816  * Tries to read the reparse point indicated by @filename, filling</span>
<span class="line-added"> 817  * @buf or @alloc_buf with the path that the reparse point redirects to.</span>
<span class="line-added"> 818  * The path will be UTF-8-encoded, and an extended path prefix</span>
<span class="line-added"> 819  * or a NT object manager prefix will be removed from it, if</span>
<span class="line-added"> 820  * possible, but otherwise the path is returned as-is. Specifically,</span>
<span class="line-added"> 821  * it could be a &quot;\\\\Volume{GUID}\\&quot; path. It also might use</span>
<span class="line-added"> 822  * backslashes as path separators.</span>
<span class="line-added"> 823  *</span>
<span class="line-added"> 824  * Returns: -1 on error (sets errno), 0 if there&#39;s no (recognizable)</span>
<span class="line-added"> 825  * path in the reparse point (@alloc_buf will not be allocated in that case,</span>
<span class="line-added"> 826  * and @buf will be left unmodified),</span>
<span class="line-added"> 827  * or the number of bytes placed into @buf otherwise,</span>
<span class="line-added"> 828  * including NUL-terminator (if present or if @terminate is TRUE).</span>
<span class="line-added"> 829  * The buffer returned via @alloc_buf should be freed with g_free().</span>
<span class="line-added"> 830  *</span>
<span class="line-added"> 831  * Since: 2.60</span>
<span class="line-added"> 832  */</span>
<span class="line-added"> 833 int</span>
<span class="line-added"> 834 g_win32_readlink_utf8 (const gchar  *filename,</span>
<span class="line-added"> 835                        gchar        *buf,</span>
<span class="line-added"> 836                        gsize         buf_size,</span>
<span class="line-added"> 837                        gchar       **alloc_buf,</span>
<span class="line-added"> 838                        gboolean      terminate)</span>
 839 {
<span class="line-modified"> 840   wchar_t *wfilename;</span>
<span class="line-modified"> 841   int result;</span>
<span class="line-modified"> 842   wchar_t *buf_utf16;</span>
<span class="line-modified"> 843   glong tmp_len;</span>
<span class="line-modified"> 844   gchar *tmp;</span>


 845 
<span class="line-modified"> 846   g_return_val_if_fail ((buf != NULL || alloc_buf != NULL) &amp;&amp;</span>
<span class="line-modified"> 847                         (buf == NULL || alloc_buf == NULL),</span>
<span class="line-modified"> 848                         -1);</span>



 849 
<span class="line-modified"> 850   wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);</span>





 851 
<span class="line-modified"> 852   if (wfilename == NULL)</span>
 853     {
 854       errno = EINVAL;
 855       return -1;
 856     }
 857 
<span class="line-modified"> 858   result = _g_win32_readlink_utf16_handle (wfilename, NULL, NULL,</span>
<span class="line-modified"> 859                                            NULL, 0, &amp;buf_utf16, terminate);</span>





























 860 
<span class="line-modified"> 861   g_free (wfilename);</span>










































 862 
 863   if (result &lt;= 0)
 864     return result;
 865 
<span class="line-modified"> 866   tmp = g_utf16_to_utf8 (buf_utf16,</span>
<span class="line-modified"> 867                          result / sizeof (gunichar2),</span>
<span class="line-modified"> 868                          NULL,</span>
<span class="line-modified"> 869                          &amp;tmp_len,</span>
<span class="line-modified"> 870                          NULL);</span>






 871 
<span class="line-modified"> 872   g_free (buf_utf16);</span>

 873 
<span class="line-modified"> 874   if (tmp == NULL)</span>






























 875     {
 876       errno = EINVAL;
 877       return -1;
 878     }
 879 
<span class="line-modified"> 880   if (alloc_buf)</span>




 881     {
<span class="line-modified"> 882       *alloc_buf = tmp;</span>
<span class="line-modified"> 883       return tmp_len;</span>






















 884     }
 885 
<span class="line-modified"> 886   if (tmp_len &gt; buf_size)</span>
<span class="line-added"> 887     tmp_len = buf_size;</span>
<span class="line-added"> 888 </span>
<span class="line-added"> 889   memcpy (buf, tmp, tmp_len);</span>
<span class="line-added"> 890   g_free (tmp);</span>
<span class="line-added"> 891 </span>
<span class="line-added"> 892   return tmp_len;</span>
 893 }
 894 
 895 #endif
 896 
 897 /**
 898  * g_access:
 899  * @filename: (type filename): a pathname in the GLib file name encoding
 900  *     (UTF-8 on Windows)
 901  * @mode: as in access()
 902  *
 903  * A wrapper for the POSIX access() function. This function is used to
 904  * test a pathname for one or several of read, write or execute
 905  * permissions, or just existence.
 906  *
 907  * On Windows, the file protection mechanism is not at all POSIX-like,
 908  * and the underlying function in the C library only checks the
 909  * FAT-style READONLY attribute, and does not look at the ACL of a
 910  * file at all. This function is this in practise almost useless on
 911  * Windows. Software that needs to handle file permissions on Windows
 912  * more exactly should use the Win32 API.
 913  *
 914  * See your C library manual for more details about access().
 915  *
 916  * Returns: zero if the pathname refers to an existing file system
 917  *     object that has all the tested permissions, or -1 otherwise
 918  *     or on error.
 919  *
 920  * Since: 2.8
 921  */
 922 int
 923 g_access (const gchar *filename,
<span class="line-modified"> 924     int          mode)</span>
 925 {
 926 #ifdef G_OS_WIN32
 927   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 928   int retval;
 929   int save_errno;
 930 
 931   if (wfilename == NULL)
 932     {
 933       errno = EINVAL;
 934       return -1;
 935     }
 936 
 937 #ifndef X_OK
 938 #define X_OK 1
 939 #endif
 940 
 941   retval = _waccess (wfilename, mode &amp; ~X_OK);
 942   save_errno = errno;
 943 
 944   g_free (wfilename);
</pre>
<hr />
<pre>
 956  *     (UTF-8 on Windows)
 957  * @mode: as in chmod()
 958  *
 959  * A wrapper for the POSIX chmod() function. The chmod() function is
 960  * used to set the permissions of a file system object.
 961  *
 962  * On Windows the file protection mechanism is not at all POSIX-like,
 963  * and the underlying chmod() function in the C library just sets or
 964  * clears the FAT-style READONLY attribute. It does not touch any
 965  * ACL. Software that needs to manage file permissions on Windows
 966  * exactly should use the Win32 API.
 967  *
 968  * See your C library manual for more details about chmod().
 969  *
 970  * Returns: 0 if the operation succeeded, -1 on error
 971  *
 972  * Since: 2.8
 973  */
 974 int
 975 g_chmod (const gchar *filename,
<span class="line-modified"> 976    int          mode)</span>
 977 {
 978 #ifdef G_OS_WIN32
 979   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 980   int retval;
 981   int save_errno;
 982 
 983   if (wfilename == NULL)
 984     {
 985       errno = EINVAL;
 986       return -1;
 987     }
 988 
 989   retval = _wchmod (wfilename, mode);
 990   save_errno = errno;
 991 
 992   g_free (wfilename);
 993 
 994   errno = save_errno;
 995   return retval;
 996 #else
</pre>
<hr />
<pre>
1014  * uses file handles, which are more randomish integers, not small
1015  * integers like file descriptors.
1016  *
1017  * Because file descriptors are specific to the C library on Windows,
1018  * the file descriptor returned by this function makes sense only to
1019  * functions in the same C library. Thus if the GLib-using code uses a
1020  * different C library than GLib does, the file descriptor returned by
1021  * this function cannot be passed to C library functions like write()
1022  * or read().
1023  *
1024  * See your C library manual for more details about open().
1025  *
1026  * Returns: a new file descriptor, or -1 if an error occurred.
1027  *     The return value can be used exactly like the return value
1028  *     from open().
1029  *
1030  * Since: 2.6
1031  */
1032 int
1033 g_open (const gchar *filename,
<span class="line-modified">1034   int          flags,</span>
<span class="line-modified">1035   int          mode)</span>
1036 {
1037 #ifdef G_OS_WIN32
1038   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1039   int retval;
1040   int save_errno;
1041 
1042   if (wfilename == NULL)
1043     {
1044       errno = EINVAL;
1045       return -1;
1046     }
1047 
1048   retval = _wopen (wfilename, flags, mode);
1049   save_errno = errno;
1050 
1051   g_free (wfilename);
1052 
1053   errno = save_errno;
1054   return retval;
1055 #else
</pre>
<hr />
<pre>
1078  * uses file handles, which are more randomish integers, not small
1079  * integers like file descriptors.
1080  *
1081  * Because file descriptors are specific to the C library on Windows,
1082  * the file descriptor returned by this function makes sense only to
1083  * functions in the same C library. Thus if the GLib-using code uses a
1084  * different C library than GLib does, the file descriptor returned by
1085  * this function cannot be passed to C library functions like write()
1086  * or read().
1087  *
1088  * See your C library manual for more details about creat().
1089  *
1090  * Returns: a new file descriptor, or -1 if an error occurred.
1091  *     The return value can be used exactly like the return value
1092  *     from creat().
1093  *
1094  * Since: 2.8
1095  */
1096 int
1097 g_creat (const gchar *filename,
<span class="line-modified">1098    int          mode)</span>
1099 {
1100 #ifdef G_OS_WIN32
1101   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1102   int retval;
1103   int save_errno;
1104 
1105   if (wfilename == NULL)
1106     {
1107       errno = EINVAL;
1108       return -1;
1109     }
1110 
1111   retval = _wcreat (wfilename, mode);
1112   save_errno = errno;
1113 
1114   g_free (wfilename);
1115 
1116   errno = save_errno;
1117   return retval;
1118 #else
</pre>
<hr />
<pre>
1122 
1123 /**
1124  * g_rename:
1125  * @oldfilename: (type filename): a pathname in the GLib file name encoding
1126  *     (UTF-8 on Windows)
1127  * @newfilename: (type filename): a pathname in the GLib file name encoding
1128  *
1129  * A wrapper for the POSIX rename() function. The rename() function
1130  * renames a file, moving it between directories if required.
1131  *
1132  * See your C library manual for more details about how rename() works
1133  * on your system. It is not possible in general on Windows to rename
1134  * a file that is open to some process.
1135  *
1136  * Returns: 0 if the renaming succeeded, -1 if an error occurred
1137  *
1138  * Since: 2.6
1139  */
1140 int
1141 g_rename (const gchar *oldfilename,
<span class="line-modified">1142     const gchar *newfilename)</span>
1143 {
1144 #ifdef G_OS_WIN32
1145   wchar_t *woldfilename = g_utf8_to_utf16 (oldfilename, -1, NULL, NULL, NULL);
1146   wchar_t *wnewfilename;
1147   int retval;
1148   int save_errno = 0;
1149 
1150   if (woldfilename == NULL)
1151     {
1152       errno = EINVAL;
1153       return -1;
1154     }
1155 
1156   wnewfilename = g_utf8_to_utf16 (newfilename, -1, NULL, NULL, NULL);
1157 
1158   if (wnewfilename == NULL)
1159     {
1160       g_free (woldfilename);
1161       errno = EINVAL;
1162       return -1;
1163     }
1164 
1165   if (MoveFileExW (woldfilename, wnewfilename, MOVEFILE_REPLACE_EXISTING))
1166     retval = 0;
1167   else
1168     {
1169       retval = -1;
<span class="line-modified">1170       save_errno = w32_error_to_errno (GetLastError ());</span>













1171     }
1172 
1173   g_free (woldfilename);
1174   g_free (wnewfilename);
1175 
1176   errno = save_errno;
1177   return retval;
1178 #else
1179   return rename (oldfilename, newfilename);
1180 #endif
1181 }
1182 
1183 /**
1184  * g_mkdir:
1185  * @filename: (type filename): a pathname in the GLib file name encoding
1186  *     (UTF-8 on Windows)
1187  * @mode: permissions to use for the newly created directory
1188  *
1189  * A wrapper for the POSIX mkdir() function. The mkdir() function
1190  * attempts to create a directory with the given name and permissions.
1191  * The mode argument is ignored on Windows.
1192  *
1193  * See your C library manual for more details about mkdir().
1194  *
1195  * Returns: 0 if the directory was successfully created, -1 if an error
1196  *    occurred
1197  *
1198  * Since: 2.6
1199  */
1200 int
1201 g_mkdir (const gchar *filename,
<span class="line-modified">1202    int          mode)</span>
1203 {
1204 #ifdef G_OS_WIN32
1205   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1206   int retval;
1207   int save_errno;
1208 
1209   if (wfilename == NULL)
1210     {
1211       errno = EINVAL;
1212       return -1;
1213     }
1214 
1215   retval = _wmkdir (wfilename);
1216   save_errno = errno;
1217 
1218   g_free (wfilename);
1219 
1220   errno = save_errno;
1221   return retval;
1222 #else
</pre>
<hr />
<pre>
1290  * _stat32i64() and _stat64i32(). The one used here is for 32-bit code
1291  * the one with 32-bit size and time fields, specifically called _stat32().
1292  *
1293  * In Microsoft&#39;s compiler, by default struct stat means one with
1294  * 64-bit time fields while in MinGW struct stat is the legacy one
1295  * with 32-bit fields. To hopefully clear up this messs, the gstdio.h
1296  * header defines a type #GStatBuf which is the appropriate struct type
1297  * depending on the platform and/or compiler being used. On POSIX it
1298  * is just struct stat, but note that even on POSIX platforms, stat()
1299  * might be a macro.
1300  *
1301  * See your C library manual for more details about stat().
1302  *
1303  * Returns: 0 if the information was successfully retrieved,
1304  *     -1 if an error occurred
1305  *
1306  * Since: 2.6
1307  */
1308 int
1309 g_stat (const gchar *filename,
<span class="line-modified">1310   GStatBuf    *buf)</span>
1311 {
1312 #ifdef G_OS_WIN32
1313   GWin32PrivateStat w32_buf;
1314   int retval = g_win32_stat_utf8 (filename, &amp;w32_buf);
1315 
1316   buf-&gt;st_dev = w32_buf.st_dev;
1317   buf-&gt;st_ino = w32_buf.st_ino;
1318   buf-&gt;st_mode = w32_buf.st_mode;
1319   buf-&gt;st_nlink = w32_buf.st_nlink;
1320   buf-&gt;st_uid = w32_buf.st_uid;
1321   buf-&gt;st_gid = w32_buf.st_gid;
1322   buf-&gt;st_rdev = w32_buf.st_dev;
1323   buf-&gt;st_size = w32_buf.st_size;
1324   buf-&gt;st_atime = w32_buf.st_atime;
1325   buf-&gt;st_mtime = w32_buf.st_mtime;
1326   buf-&gt;st_ctime = w32_buf.st_ctime;
1327 
1328   return retval;
1329 #else
1330   return stat (filename, buf);
</pre>
<hr />
<pre>
1336  * @filename: (type filename): a pathname in the GLib file name encoding
1337  *     (UTF-8 on Windows)
1338  * @buf: a pointer to a stat struct, which will be filled with the file
1339  *     information
1340  *
1341  * A wrapper for the POSIX lstat() function. The lstat() function is
1342  * like stat() except that in the case of symbolic links, it returns
1343  * information about the symbolic link itself and not the file that it
1344  * refers to. If the system does not support symbolic links g_lstat()
1345  * is identical to g_stat().
1346  *
1347  * See your C library manual for more details about lstat().
1348  *
1349  * Returns: 0 if the information was successfully retrieved,
1350  *     -1 if an error occurred
1351  *
1352  * Since: 2.6
1353  */
1354 int
1355 g_lstat (const gchar *filename,
<span class="line-modified">1356    GStatBuf    *buf)</span>
1357 {
1358 #ifdef HAVE_LSTAT
1359   /* This can&#39;t be Win32, so don&#39;t do the widechar dance. */
1360   return lstat (filename, buf);
1361 #elif defined (G_OS_WIN32)
1362   GWin32PrivateStat w32_buf;
1363   int retval = g_win32_lstat_utf8 (filename, &amp;w32_buf);
1364 
1365   buf-&gt;st_dev = w32_buf.st_dev;
1366   buf-&gt;st_ino = w32_buf.st_ino;
1367   buf-&gt;st_mode = w32_buf.st_mode;
1368   buf-&gt;st_nlink = w32_buf.st_nlink;
1369   buf-&gt;st_uid = w32_buf.st_uid;
1370   buf-&gt;st_gid = w32_buf.st_gid;
1371   buf-&gt;st_rdev = w32_buf.st_dev;
1372   buf-&gt;st_size = w32_buf.st_size;
1373   buf-&gt;st_atime = w32_buf.st_atime;
1374   buf-&gt;st_mtime = w32_buf.st_mtime;
1375   buf-&gt;st_ctime = w32_buf.st_ctime;
1376 
</pre>
<hr />
<pre>
1530  *
1531  * A wrapper for the stdio fopen() function. The fopen() function
1532  * opens a file and associates a new stream with it.
1533  *
1534  * Because file descriptors are specific to the C library on Windows,
1535  * and a file descriptor is part of the FILE struct, the FILE* returned
1536  * by this function makes sense only to functions in the same C library.
1537  * Thus if the GLib-using code uses a different C library than GLib does,
1538  * the FILE* returned by this function cannot be passed to C library
1539  * functions like fprintf() or fread().
1540  *
1541  * See your C library manual for more details about fopen().
1542  *
1543  * Returns: A FILE* if the file was successfully opened, or %NULL if
1544  *     an error occurred
1545  *
1546  * Since: 2.6
1547  */
1548 FILE *
1549 g_fopen (const gchar *filename,
<span class="line-modified">1550    const gchar *mode)</span>
1551 {
1552 #ifdef G_OS_WIN32
1553   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1554   wchar_t *wmode;

1555   FILE *retval;
1556   int save_errno;
1557 
1558   if (wfilename == NULL)
1559     {
1560       errno = EINVAL;
1561       return NULL;
1562     }
1563 
<span class="line-modified">1564   wmode = g_utf8_to_utf16 (mode, -1, NULL, NULL, NULL);</span>


1565 
1566   if (wmode == NULL)
1567     {
1568       g_free (wfilename);
1569       errno = EINVAL;
1570       return NULL;
1571     }
1572 
<span class="line-added">1573   _g_win32_fix_mode (wmode);</span>
1574   retval = _wfopen (wfilename, wmode);
1575   save_errno = errno;
1576 
1577   g_free (wfilename);
1578   g_free (wmode);
1579 
1580   errno = save_errno;
1581   return retval;
1582 #else
1583   return fopen (filename, mode);
1584 #endif
1585 }
1586 
1587 /**
1588  * g_freopen:
1589  * @filename: (type filename): a pathname in the GLib file name encoding
1590  *     (UTF-8 on Windows)
1591  * @mode: a string describing the mode in which the file should be  opened
1592  * @stream: (nullable): an existing stream which will be reused, or %NULL
1593  *
1594  * A wrapper for the POSIX freopen() function. The freopen() function
1595  * opens a file and associates it with an existing stream.
1596  *
1597  * See your C library manual for more details about freopen().
1598  *
1599  * Returns: A FILE* if the file was successfully opened, or %NULL if
1600  *     an error occurred.
1601  *
1602  * Since: 2.6
1603  */
1604 FILE *
1605 g_freopen (const gchar *filename,
<span class="line-modified">1606      const gchar *mode,</span>
<span class="line-modified">1607      FILE        *stream)</span>
1608 {
1609 #ifdef G_OS_WIN32
1610   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1611   wchar_t *wmode;

1612   FILE *retval;
1613   int save_errno;
1614 
1615   if (wfilename == NULL)
1616     {
1617       errno = EINVAL;
1618       return NULL;
1619     }
1620 
<span class="line-modified">1621   wmode = g_utf8_to_utf16 (mode, -1, NULL, NULL, NULL);</span>


1622 
1623   if (wmode == NULL)
1624     {
1625       g_free (wfilename);
1626       errno = EINVAL;
1627       return NULL;
1628     }
1629 
<span class="line-added">1630   _g_win32_fix_mode (wmode);</span>
1631   retval = _wfreopen (wfilename, wmode, stream);
1632   save_errno = errno;
1633 
1634   g_free (wfilename);
1635   g_free (wmode);
1636 
1637   errno = save_errno;
1638   return retval;
1639 #else
1640   return freopen (filename, mode, stream);
1641 #endif
1642 }
1643 
1644 /**
1645  * g_utime:
1646  * @filename: (type filename): a pathname in the GLib file name encoding
1647  *     (UTF-8 on Windows)
1648  * @utb: a pointer to a struct utimbuf.
1649  *
1650  * A wrapper for the POSIX utime() function. The utime() function
1651  * sets the access and modification timestamps of a file.
1652  *
1653  * See your C library manual for more details about how utime() works
1654  * on your system.
1655  *
1656  * Returns: 0 if the operation was successful, -1 if an error occurred
1657  *
1658  * Since: 2.18
1659  */
1660 int
1661 g_utime (const gchar    *filename,
<span class="line-modified">1662    struct utimbuf *utb)</span>
1663 {
1664 #ifdef G_OS_WIN32
1665   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1666   int retval;
1667   int save_errno;
1668 
1669   if (wfilename == NULL)
1670     {
1671       errno = EINVAL;
1672       return -1;
1673     }
1674 
1675   retval = _wutime (wfilename, (struct _utimbuf*) utb);
1676   save_errno = errno;
1677 
1678   g_free (wfilename);
1679 
1680   errno = save_errno;
1681   return retval;
1682 #else
</pre>
</td>
</tr>
</table>
<center><a href="gstdio-private.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstdio.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>