<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/ghash.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ggettext.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ghash.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/ghash.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #include &lt;string.h&gt;  /* memset */
  32 
  33 #include &quot;ghash.h&quot;
<span class="line-modified">  34 </span>
  35 #include &quot;glib-private.h&quot;
  36 #include &quot;gstrfuncs.h&quot;
  37 #include &quot;gatomic.h&quot;
  38 #include &quot;gtestutils.h&quot;
  39 #include &quot;gslice.h&quot;
  40 #include &quot;grefcount.h&quot;






















  41 
  42 /**
  43  * SECTION:hash_tables
  44  * @title: Hash Tables
  45  * @short_description: associations between keys and values so that
  46  *     given a key the value can be found quickly
  47  *
  48  * A #GHashTable provides associations between keys and values which is
  49  * optimized so that given a key, the associated value can be found
  50  * very quickly.
  51  *
  52  * Note that neither keys nor values are copied when inserted into the
  53  * #GHashTable, so they must exist for the lifetime of the #GHashTable.
  54  * This means that the use of static strings is OK, but temporary
  55  * strings (i.e. those created in buffers and those returned by GTK+
  56  * widgets) should be copied with g_strdup() before being inserted.
  57  *
  58  * If keys or values are dynamically allocated, you must be careful to
  59  * ensure that they are freed when they are removed from the
  60  * #GHashTable, and also when they are overwritten by new insertions
  61  * into the #GHashTable. It is also not advisable to mix static strings
  62  * and dynamically-allocated strings in a #GHashTable, because it then
  63  * becomes difficult to determine whether the string should be freed.
  64  *
  65  * To create a #GHashTable, use g_hash_table_new().
  66  *
  67  * To insert a key and value into a #GHashTable, use
  68  * g_hash_table_insert().
  69  *
<span class="line-modified">  70  * To lookup a value corresponding to a given key, use</span>
  71  * g_hash_table_lookup() and g_hash_table_lookup_extended().
  72  *
  73  * g_hash_table_lookup_extended() can also be used to simply
  74  * check if a key is present in the hash table.
  75  *
  76  * To remove a key and value, use g_hash_table_remove().
  77  *
  78  * To call a function for each key and value pair use
<span class="line-modified">  79  * g_hash_table_foreach() or use a iterator to iterate over the</span>
  80  * key/value pairs in the hash table, see #GHashTableIter.
  81  *
  82  * To destroy a #GHashTable use g_hash_table_destroy().
  83  *
  84  * A common use-case for hash tables is to store information about a
  85  * set of keys, without associating any particular value with each
  86  * key. GHashTable optimizes one way of doing so: If you store only
  87  * key-value pairs where key == value, then GHashTable does not
  88  * allocate memory to store the values, which can be a considerable
  89  * space saving, if your set is large. The functions
  90  * g_hash_table_add() and g_hash_table_contains() are designed to be
  91  * used when using #GHashTable this way.
  92  *
  93  * #GHashTable is not designed to be statically initialised with keys and
  94  * values known at compile time. To build a static hash table, use a tool such
  95  * as [gperf](https://www.gnu.org/software/gperf/).
  96  */
  97 
  98 /**
  99  * GHashTable:
</pre>
<hr />
<pre>
 196  * This function is deprecated and will be removed in the next major
 197  * release of GLib. It does nothing.
 198  */
 199 
 200 /**
 201  * g_hash_table_thaw:
 202  * @hash_table: a #GHashTable
 203  *
 204  * This function is deprecated and will be removed in the next major
 205  * release of GLib. It does nothing.
 206  */
 207 
 208 #define HASH_TABLE_MIN_SHIFT 3  /* 1 &lt;&lt; 3 == 8 buckets */
 209 
 210 #define UNUSED_HASH_VALUE 0
 211 #define TOMBSTONE_HASH_VALUE 1
 212 #define HASH_IS_UNUSED(h_) ((h_) == UNUSED_HASH_VALUE)
 213 #define HASH_IS_TOMBSTONE(h_) ((h_) == TOMBSTONE_HASH_VALUE)
 214 #define HASH_IS_REAL(h_) ((h_) &gt;= 2)
 215 












 216 struct _GHashTable
 217 {
<span class="line-modified"> 218   gint             size;</span>
 219   gint             mod;
 220   guint            mask;
 221   gint             nnodes;
 222   gint             noccupied;  /* nnodes + tombstones */
 223 
<span class="line-modified"> 224   gpointer        *keys;</span>



 225   guint           *hashes;
<span class="line-modified"> 226   gpointer        *values;</span>
 227 
 228   GHashFunc        hash_func;
 229   GEqualFunc       key_equal_func;
 230   gatomicrefcount  ref_count;
 231 #ifndef G_DISABLE_ASSERT
 232   /*
 233    * Tracks the structure of the hash table, not its contents: is only
 234    * incremented when a node is added or removed (is not incremented
 235    * when the key or data of a node is modified).
 236    */
 237   int              version;
 238 #endif
 239   GDestroyNotify   key_destroy_func;
 240   GDestroyNotify   value_destroy_func;
 241 };
 242 
 243 typedef struct
 244 {
 245   GHashTable  *hash_table;
 246   gpointer     dummy1;
 247   gpointer     dummy2;
<span class="line-modified"> 248   int          position;</span>
 249   gboolean     dummy3;
<span class="line-modified"> 250   int          version;</span>
 251 } RealIter;
 252 
 253 G_STATIC_ASSERT (sizeof (GHashTableIter) == sizeof (RealIter));
<span class="line-modified"> 254 G_STATIC_ASSERT (_g_alignof (GHashTableIter) &gt;= _g_alignof (RealIter));</span>
 255 
 256 /* Each table size has an associated prime modulo (the first prime
 257  * lower than the table size) used to find the initial bucket. Probing
 258  * then works modulo 2^n. The prime modulo is necessary to get a
 259  * good distribution with poor hash functions.
 260  */
 261 static const gint prime_mod [] =
 262 {
 263   1,          /* For 1 &lt;&lt; 0 */
 264   2,
 265   3,
 266   7,
 267   13,
 268   31,
 269   61,
 270   127,
 271   251,
 272   509,
 273   1021,
 274   2039,
</pre>
<hr />
<pre>
 280   131071,
 281   262139,
 282   524287,
 283   1048573,
 284   2097143,
 285   4194301,
 286   8388593,
 287   16777213,
 288   33554393,
 289   67108859,
 290   134217689,
 291   268435399,
 292   536870909,
 293   1073741789,
 294   2147483647  /* For 1 &lt;&lt; 31 */
 295 };
 296 
 297 static void
 298 g_hash_table_set_shift (GHashTable *hash_table, gint shift)
 299 {
<span class="line-removed"> 300   gint i;</span>
<span class="line-removed"> 301   guint mask = 0;</span>
<span class="line-removed"> 302 </span>
 303   hash_table-&gt;size = 1 &lt;&lt; shift;
 304   hash_table-&gt;mod  = prime_mod [shift];
 305 
<span class="line-modified"> 306   for (i = 0; i &lt; shift; i++)</span>
<span class="line-modified"> 307     {</span>
<span class="line-modified"> 308       mask &lt;&lt;= 1;</span>
<span class="line-removed"> 309       mask |= 1;</span>
<span class="line-removed"> 310     }</span>
 311 
<span class="line-modified"> 312   hash_table-&gt;mask = mask;</span>

 313 }
 314 
 315 static gint
 316 g_hash_table_find_closest_shift (gint n)
 317 {
 318   gint i;
 319 
 320   for (i = 0; n; i++)
 321     n &gt;&gt;= 1;
 322 
 323   return i;
 324 }
 325 
 326 static void
 327 g_hash_table_set_shift_from_size (GHashTable *hash_table, gint size)
 328 {
 329   gint shift;
 330 
 331   shift = g_hash_table_find_closest_shift (size);
 332   shift = MAX (shift, HASH_TABLE_MIN_SHIFT);
 333 
 334   g_hash_table_set_shift (hash_table, shift);
 335 }
 336 





























































 337 /*
 338  * g_hash_table_lookup_node:
 339  * @hash_table: our #GHashTable
<span class="line-modified"> 340  * @key: the key to lookup against</span>
 341  * @hash_return: key hash return location
 342  *
 343  * Performs a lookup in the hash table, preserving extra information
 344  * usually needed for insertion.
 345  *
 346  * This function first computes the hash value of the key using the
 347  * user&#39;s hash function.
 348  *
 349  * If an entry in the table matching @key is found then this function
 350  * returns the index of that entry in the table, and if not, the
 351  * index of an unused node (empty or tombstone) where the key can be
 352  * inserted.
 353  *
 354  * The computed hash value is returned in the variable pointed to
 355  * by @hash_return. This is to save insertions from having to compute
 356  * the hash record again for the new record.
 357  *
 358  * Returns: index of the described node
 359  */
 360 static inline guint
</pre>
<hr />
<pre>
 365   guint node_index;
 366   guint node_hash;
 367   guint hash_value;
 368   guint first_tombstone = 0;
 369   gboolean have_tombstone = FALSE;
 370   guint step = 0;
 371 
 372   /* If this happens, then the application is probably doing too much work
 373    * from a destroy notifier. The alternative would be to crash any second
 374    * (as keys, etc. will be NULL).
 375    * Applications need to either use g_hash_table_destroy, or ensure the hash
 376    * table is empty prior to removing the last reference using g_hash_table_unref(). */
 377   g_assert (!g_atomic_ref_count_compare (&amp;hash_table-&gt;ref_count, 0));
 378 
 379   hash_value = hash_table-&gt;hash_func (key);
 380   if (G_UNLIKELY (!HASH_IS_REAL (hash_value)))
 381     hash_value = 2;
 382 
 383   *hash_return = hash_value;
 384 
<span class="line-modified"> 385   node_index = hash_value % hash_table-&gt;mod;</span>
 386   node_hash = hash_table-&gt;hashes[node_index];
 387 
 388   while (!HASH_IS_UNUSED (node_hash))
 389     {
 390       /* We first check if our full hash values
 391        * are equal so we can avoid calling the full-blown
 392        * key equality function in most cases.
 393        */
 394       if (node_hash == hash_value)
 395         {
<span class="line-modified"> 396           gpointer node_key = hash_table-&gt;keys[node_index];</span>
 397 
 398           if (hash_table-&gt;key_equal_func)
 399             {
 400               if (hash_table-&gt;key_equal_func (node_key, key))
 401                 return node_index;
 402             }
 403           else if (node_key == key)
 404             {
 405               return node_index;
 406             }
 407         }
 408       else if (HASH_IS_TOMBSTONE (node_hash) &amp;&amp; !have_tombstone)
 409         {
 410           first_tombstone = node_index;
 411           have_tombstone = TRUE;
 412         }
 413 
 414       step++;
 415       node_index += step;
 416       node_index &amp;= hash_table-&gt;mask;
</pre>
<hr />
<pre>
 426 /*
 427  * g_hash_table_remove_node:
 428  * @hash_table: our #GHashTable
 429  * @node: pointer to node to remove
 430  * @notify: %TRUE if the destroy notify handlers are to be called
 431  *
 432  * Removes a node from the hash table and updates the node count.
 433  * The node is replaced by a tombstone. No table resize is performed.
 434  *
 435  * If @notify is %TRUE then the destroy notify functions are called
 436  * for the key and value of the hash node.
 437  */
 438 static void
 439 g_hash_table_remove_node (GHashTable   *hash_table,
 440                           gint          i,
 441                           gboolean      notify)
 442 {
 443   gpointer key;
 444   gpointer value;
 445 
<span class="line-modified"> 446   key = hash_table-&gt;keys[i];</span>
<span class="line-modified"> 447   value = hash_table-&gt;values[i];</span>
 448 
 449   /* Erect tombstone */
 450   hash_table-&gt;hashes[i] = TOMBSTONE_HASH_VALUE;
 451 
 452   /* Be GC friendly */
<span class="line-modified"> 453   hash_table-&gt;keys[i] = NULL;</span>
<span class="line-modified"> 454   hash_table-&gt;values[i] = NULL;</span>
 455 
 456   hash_table-&gt;nnodes--;
 457 
 458   if (notify &amp;&amp; hash_table-&gt;key_destroy_func)
 459     hash_table-&gt;key_destroy_func (key);
 460 
 461   if (notify &amp;&amp; hash_table-&gt;value_destroy_func)
 462     hash_table-&gt;value_destroy_func (value);
 463 
 464 }
 465 




































 466 /*
 467  * g_hash_table_remove_all_nodes:
 468  * @hash_table: our #GHashTable
 469  * @notify: %TRUE if the destroy notify handlers are to be called
 470  *
<span class="line-modified"> 471  * Removes all nodes from the table.  Since this may be a precursor to</span>
<span class="line-removed"> 472  * freeing the table entirely, no resize is performed.</span>
 473  *
 474  * If @notify is %TRUE then the destroy notify functions are called
 475  * for the key and value of the hash node.








 476  */
 477 static void
 478 g_hash_table_remove_all_nodes (GHashTable *hash_table,
 479                                gboolean    notify,
 480                                gboolean    destruction)
 481 {
 482   int i;
 483   gpointer key;
 484   gpointer value;
 485   gint old_size;
 486   gpointer *old_keys;
 487   gpointer *old_values;
 488   guint    *old_hashes;


 489 
 490   /* If the hash table is already empty, there is nothing to be done. */
 491   if (hash_table-&gt;nnodes == 0)
 492     return;
 493 
 494   hash_table-&gt;nnodes = 0;
 495   hash_table-&gt;noccupied = 0;
 496 

 497   if (!notify ||
 498       (hash_table-&gt;key_destroy_func == NULL &amp;&amp;
 499        hash_table-&gt;value_destroy_func == NULL))
 500     {
 501       if (!destruction)
 502         {
<span class="line-modified"> 503       memset (hash_table-&gt;hashes, 0, hash_table-&gt;size * sizeof (guint));</span>
<span class="line-modified"> 504       memset (hash_table-&gt;keys, 0, hash_table-&gt;size * sizeof (gpointer));</span>
<span class="line-modified"> 505       memset (hash_table-&gt;values, 0, hash_table-&gt;size * sizeof (gpointer));</span>






 506         }
 507 
 508       return;
 509     }
 510 
<span class="line-modified"> 511   /* Keep the old storage space around to iterate over it. */</span>



















 512   old_size = hash_table-&gt;size;
<span class="line-modified"> 513   old_keys   = hash_table-&gt;keys;</span>
<span class="line-modified"> 514   old_values = hash_table-&gt;values;</span>
<span class="line-modified"> 515   old_hashes = hash_table-&gt;hashes;</span>
<span class="line-modified"> 516 </span>
<span class="line-modified"> 517   /* Now create a new storage space; If the table is destroyed we can use the</span>
<span class="line-modified"> 518    * shortcut of not creating a new storage. This saves the allocation at the</span>
<span class="line-removed"> 519    * cost of not allowing any recursive access.</span>
<span class="line-removed"> 520    * However, the application doesn&#39;t own any reference anymore, so access</span>
<span class="line-removed"> 521    * is not allowed. If accesses are done, then either an assert or crash</span>
<span class="line-removed"> 522    * *will* happen. */</span>
<span class="line-removed"> 523   g_hash_table_set_shift (hash_table, HASH_TABLE_MIN_SHIFT);</span>
 524   if (!destruction)
<span class="line-modified"> 525     {</span>
<span class="line-modified"> 526       hash_table-&gt;keys   = g_new0 (gpointer, hash_table-&gt;size);</span>
<span class="line-removed"> 527       hash_table-&gt;values = hash_table-&gt;keys;</span>
<span class="line-removed"> 528       hash_table-&gt;hashes = g_new0 (guint, hash_table-&gt;size);</span>
<span class="line-removed"> 529     }</span>
 530   else
<span class="line-modified"> 531         {</span>
<span class="line-modified"> 532       hash_table-&gt;keys   = NULL;</span>
<span class="line-removed"> 533       hash_table-&gt;values = NULL;</span>
<span class="line-removed"> 534       hash_table-&gt;hashes = NULL;</span>
<span class="line-removed"> 535     }</span>
 536 

 537   for (i = 0; i &lt; old_size; i++)
 538     {
 539       if (HASH_IS_REAL (old_hashes[i]))
 540         {
<span class="line-modified"> 541           key = old_keys[i];</span>
<span class="line-modified"> 542           value = old_values[i];</span>
 543 
 544           old_hashes[i] = UNUSED_HASH_VALUE;
<span class="line-modified"> 545           old_keys[i] = NULL;</span>
<span class="line-modified"> 546           old_values[i] = NULL;</span>

 547 
 548           if (hash_table-&gt;key_destroy_func != NULL)
 549             hash_table-&gt;key_destroy_func (key);
 550 
 551           if (hash_table-&gt;value_destroy_func != NULL)
 552             hash_table-&gt;value_destroy_func (value);
 553         }
<span class="line-modified"> 554         }</span>
 555 
 556   /* Destroy old storage space. */
 557   if (old_keys != old_values)
 558     g_free (old_values);
 559 
 560   g_free (old_keys);
 561   g_free (old_hashes);
<span class="line-modified"> 562     }</span>























































































































 563 
 564 /*
 565  * g_hash_table_resize:
 566  * @hash_table: our #GHashTable
 567  *
 568  * Resizes the hash table to the optimal size based on the number of
 569  * nodes currently held. If you call this function then a resize will
 570  * occur, even if one does not need to occur.
 571  * Use g_hash_table_maybe_resize() instead.
 572  *
 573  * This function may &quot;resize&quot; the hash table to its current size, with
 574  * the side effect of cleaning up tombstones and otherwise optimizing
 575  * the probe sequences.
 576  */
 577 static void
 578 g_hash_table_resize (GHashTable *hash_table)
 579 {
<span class="line-modified"> 580   gpointer *new_keys;</span>
<span class="line-modified"> 581   gpointer *new_values;</span>
<span class="line-modified"> 582   guint *new_hashes;</span>
<span class="line-removed"> 583   gint old_size;</span>
<span class="line-removed"> 584   gint i;</span>
 585 
 586   old_size = hash_table-&gt;size;
<span class="line-modified"> 587   g_hash_table_set_shift_from_size (hash_table, hash_table-&gt;nnodes * 2);</span>
<span class="line-removed"> 588 </span>
<span class="line-removed"> 589   new_keys = g_new0 (gpointer, hash_table-&gt;size);</span>
<span class="line-removed"> 590   if (hash_table-&gt;keys == hash_table-&gt;values)</span>
<span class="line-removed"> 591     new_values = new_keys;</span>
<span class="line-removed"> 592   else</span>
<span class="line-removed"> 593     new_values = g_new0 (gpointer, hash_table-&gt;size);</span>
<span class="line-removed"> 594   new_hashes = g_new0 (guint, hash_table-&gt;size);</span>
<span class="line-removed"> 595 </span>
<span class="line-removed"> 596   for (i = 0; i &lt; old_size; i++)</span>
<span class="line-removed"> 597     {</span>
<span class="line-removed"> 598       guint node_hash = hash_table-&gt;hashes[i];</span>
<span class="line-removed"> 599       guint hash_val;</span>
<span class="line-removed"> 600       guint step = 0;</span>
 601 
<span class="line-modified"> 602       if (!HASH_IS_REAL (node_hash))</span>
<span class="line-modified"> 603         continue;</span>








 604 
<span class="line-modified"> 605       hash_val = node_hash % hash_table-&gt;mod;</span>
 606 
<span class="line-modified"> 607       while (!HASH_IS_UNUSED (new_hashes[hash_val]))</span>
<span class="line-modified"> 608         {</span>
<span class="line-modified"> 609           step++;</span>
<span class="line-modified"> 610           hash_val += step;</span>
<span class="line-removed"> 611           hash_val &amp;= hash_table-&gt;mask;</span>
<span class="line-removed"> 612         }</span>
 613 
<span class="line-modified"> 614       new_hashes[hash_val] = hash_table-&gt;hashes[i];</span>
<span class="line-modified"> 615       new_keys[hash_val] = hash_table-&gt;keys[i];</span>
<span class="line-modified"> 616       new_values[hash_val] = hash_table-&gt;values[i];</span>


 617     }
 618 
<span class="line-modified"> 619   if (hash_table-&gt;keys != hash_table-&gt;values)</span>
<span class="line-modified"> 620     g_free (hash_table-&gt;values);</span>


 621 
<span class="line-modified"> 622   g_free (hash_table-&gt;keys);</span>
<span class="line-removed"> 623   g_free (hash_table-&gt;hashes);</span>
 624 
<span class="line-modified"> 625   hash_table-&gt;keys = new_keys;</span>
<span class="line-modified"> 626   hash_table-&gt;values = new_values;</span>
<span class="line-removed"> 627   hash_table-&gt;hashes = new_hashes;</span>
 628 
 629   hash_table-&gt;noccupied = hash_table-&gt;nnodes;
 630 }
 631 
 632 /*
 633  * g_hash_table_maybe_resize:
 634  * @hash_table: our #GHashTable
 635  *
 636  * Resizes the hash table, if needed.
 637  *
 638  * Essentially, calls g_hash_table_resize() if the table has strayed
 639  * too far from its ideal size for its number of nodes.
 640  */
 641 static inline void
 642 g_hash_table_maybe_resize (GHashTable *hash_table)
 643 {
 644   gint noccupied = hash_table-&gt;noccupied;
 645   gint size = hash_table-&gt;size;
 646 
 647   if ((size &gt; hash_table-&gt;nnodes * 4 &amp;&amp; size &gt; 1 &lt;&lt; HASH_TABLE_MIN_SHIFT) ||
 648       (size &lt;= noccupied + (noccupied / 16)))
 649     g_hash_table_resize (hash_table);
 650 }
 651 
























































































 652 /**
 653  * g_hash_table_new:
 654  * @hash_func: a function to create a hash value from a key
 655  * @key_equal_func: a function to check two keys for equality
 656  *
 657  * Creates a new #GHashTable with a reference count of 1.
 658  *
 659  * Hash values returned by @hash_func are used to determine where keys
 660  * are stored within the #GHashTable data structure. The g_direct_hash(),
 661  * g_int_hash(), g_int64_hash(), g_double_hash() and g_str_hash()
 662  * functions are provided for some common types of keys.
 663  * If @hash_func is %NULL, g_direct_hash() is used.
 664  *
 665  * @key_equal_func is used when looking up keys in the #GHashTable.
 666  * The g_direct_equal(), g_int_equal(), g_int64_equal(), g_double_equal()
 667  * and g_str_equal() functions are provided for the most common types
 668  * of keys. If @key_equal_func is %NULL, keys are compared directly in
 669  * a similar fashion to g_direct_equal(), but without the overhead of
 670  * a function call. @key_equal_func is called with the key from the hash table
 671  * as its first parameter, and the user-provided key to check against as
</pre>
<hr />
<pre>
 703  * This means that you may need to ensure that the hash table is empty by
 704  * calling g_hash_table_remove_all() before releasing the last reference using
 705  * g_hash_table_unref().
 706  *
 707  * Returns: a new #GHashTable
 708  */
 709 GHashTable *
 710 g_hash_table_new_full (GHashFunc      hash_func,
 711                        GEqualFunc     key_equal_func,
 712                        GDestroyNotify key_destroy_func,
 713                        GDestroyNotify value_destroy_func)
 714 {
 715   GHashTable *hash_table;
 716 
 717   hash_table = g_slice_new (GHashTable);
 718 #ifdef GSTREAMER_LITE
 719   if (hash_table == NULL) {
 720     return NULL;
 721   }
 722 #endif // GSTREAMER_LITE
<span class="line-removed"> 723   g_hash_table_set_shift (hash_table, HASH_TABLE_MIN_SHIFT);</span>
 724   g_atomic_ref_count_init (&amp;hash_table-&gt;ref_count);
 725   hash_table-&gt;nnodes             = 0;
 726   hash_table-&gt;noccupied          = 0;
 727   hash_table-&gt;hash_func          = hash_func ? hash_func : g_direct_hash;
 728   hash_table-&gt;key_equal_func     = key_equal_func;
 729 #ifndef G_DISABLE_ASSERT
 730   hash_table-&gt;version            = 0;
 731 #endif
 732   hash_table-&gt;key_destroy_func   = key_destroy_func;
 733   hash_table-&gt;value_destroy_func = value_destroy_func;
<span class="line-modified"> 734   hash_table-&gt;keys               = g_new0 (gpointer, hash_table-&gt;size);</span>
<span class="line-modified"> 735   hash_table-&gt;values             = hash_table-&gt;keys;</span>
<span class="line-removed"> 736   hash_table-&gt;hashes             = g_new0 (guint, hash_table-&gt;size);</span>
 737 
 738   return hash_table;
 739 }
 740 
 741 /**
 742  * g_hash_table_iter_init:
 743  * @iter: an uninitialized #GHashTableIter
 744  * @hash_table: a #GHashTable
 745  *
 746  * Initializes a key/value pair iterator and associates it with
 747  * @hash_table. Modifying the hash table after calling this function
 748  * invalidates the returned iterator.
 749  * |[&lt;!-- language=&quot;C&quot; --&gt;
 750  * GHashTableIter iter;
 751  * gpointer key, value;
 752  *
 753  * g_hash_table_iter_init (&amp;iter, hash_table);
 754  * while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
 755  *   {
 756  *     // do something with key and value
</pre>
<hr />
<pre>
 784  * Advances @iter and retrieves the key and/or value that are now
 785  * pointed to as a result of this advancement. If %FALSE is returned,
 786  * @key and @value are not set, and the iterator becomes invalid.
 787  *
 788  * Returns: %FALSE if the end of the #GHashTable has been reached.
 789  *
 790  * Since: 2.16
 791  */
 792 gboolean
 793 g_hash_table_iter_next (GHashTableIter *iter,
 794                         gpointer       *key,
 795                         gpointer       *value)
 796 {
 797   RealIter *ri = (RealIter *) iter;
 798   gint position;
 799 
 800   g_return_val_if_fail (iter != NULL, FALSE);
 801 #ifndef G_DISABLE_ASSERT
 802   g_return_val_if_fail (ri-&gt;version == ri-&gt;hash_table-&gt;version, FALSE);
 803 #endif
<span class="line-modified"> 804   g_return_val_if_fail (ri-&gt;position &lt; ri-&gt;hash_table-&gt;size, FALSE);</span>
 805 
 806   position = ri-&gt;position;
 807 
 808   do
 809     {
 810       position++;
<span class="line-modified"> 811       if (position &gt;= ri-&gt;hash_table-&gt;size)</span>
 812         {
 813           ri-&gt;position = position;
 814           return FALSE;
 815         }
 816     }
 817   while (!HASH_IS_REAL (ri-&gt;hash_table-&gt;hashes[position]));
 818 
 819   if (key != NULL)
<span class="line-modified"> 820     *key = ri-&gt;hash_table-&gt;keys[position];</span>
 821   if (value != NULL)
<span class="line-modified"> 822     *value = ri-&gt;hash_table-&gt;values[position];</span>
 823 
 824   ri-&gt;position = position;
 825   return TRUE;
 826 }
 827 
 828 /**
 829  * g_hash_table_iter_get_hash_table:
 830  * @iter: an initialized #GHashTableIter
 831  *
 832  * Returns the #GHashTable associated with @iter.
 833  *
 834  * Returns: the #GHashTable associated with @iter.
 835  *
 836  * Since: 2.16
 837  */
 838 GHashTable *
 839 g_hash_table_iter_get_hash_table (GHashTableIter *iter)
 840 {
 841   g_return_val_if_fail (iter != NULL, NULL);
 842 
 843   return ((RealIter *) iter)-&gt;hash_table;
 844 }
 845 
 846 static void
 847 iter_remove_or_steal (RealIter *ri, gboolean notify)
 848 {
 849   g_return_if_fail (ri != NULL);
 850 #ifndef G_DISABLE_ASSERT
 851   g_return_if_fail (ri-&gt;version == ri-&gt;hash_table-&gt;version);
 852 #endif
 853   g_return_if_fail (ri-&gt;position &gt;= 0);
<span class="line-modified"> 854   g_return_if_fail (ri-&gt;position &lt; ri-&gt;hash_table-&gt;size);</span>
 855 
 856   g_hash_table_remove_node (ri-&gt;hash_table, ri-&gt;position, notify);
 857 
 858 #ifndef G_DISABLE_ASSERT
 859   ri-&gt;version++;
 860   ri-&gt;hash_table-&gt;version++;
 861 #endif
 862 }
 863 
 864 /**
 865  * g_hash_table_iter_remove:
 866  * @iter: an initialized #GHashTableIter
 867  *
 868  * Removes the key/value pair currently pointed to by the iterator
 869  * from its associated #GHashTable. Can only be called after
 870  * g_hash_table_iter_next() returned %TRUE, and cannot be called
 871  * more than once for the same key/value pair.
 872  *
 873  * If the #GHashTable was created using g_hash_table_new_full(),
 874  * the key and value are freed using the supplied destroy functions,
</pre>
<hr />
<pre>
 905  * Inserts a value at @node_index in the hash table and updates it.
 906  *
 907  * If @key has been taken out of the existing node (ie it is not
 908  * passed in via a g_hash_table_insert/replace) call, then @reusing_key
 909  * should be %TRUE.
 910  *
 911  * Returns: %TRUE if the key did not exist yet
 912  */
 913 static gboolean
 914 g_hash_table_insert_node (GHashTable *hash_table,
 915                           guint       node_index,
 916                           guint       key_hash,
 917                           gpointer    new_key,
 918                           gpointer    new_value,
 919                           gboolean    keep_new_key,
 920                           gboolean    reusing_key)
 921 {
 922   gboolean already_exists;
 923   guint old_hash;
 924   gpointer key_to_free = NULL;

 925   gpointer value_to_free = NULL;
 926 
 927   old_hash = hash_table-&gt;hashes[node_index];
 928   already_exists = HASH_IS_REAL (old_hash);
 929 
 930   /* Proceed in three steps.  First, deal with the key because it is the
 931    * most complicated.  Then consider if we need to split the table in
 932    * two (because writing the value will result in the set invariant
 933    * becoming broken).  Then deal with the value.
 934    *
 935    * There are three cases for the key:
 936    *
 937    *  - entry already exists in table, reusing key:
 938    *    free the just-passed-in new_key and use the existing value
 939    *
 940    *  - entry already exists in table, not reusing key:
 941    *    free the entry in the table, use the new key
 942    *
 943    *  - entry not already in table:
 944    *    use the new key, free nothing
 945    *
 946    * We update the hash at the same time...
 947    */
 948   if (already_exists)
 949     {
 950       /* Note: we must record the old value before writing the new key
 951        * because we might change the value in the event that the two
 952        * arrays are shared.
 953        */
<span class="line-modified"> 954       value_to_free = hash_table-&gt;values[node_index];</span>
 955 
 956       if (keep_new_key)
 957         {
<span class="line-modified"> 958           key_to_free = hash_table-&gt;keys[node_index];</span>
<span class="line-modified"> 959           hash_table-&gt;keys[node_index] = new_key;</span>
 960         }
 961       else
<span class="line-modified"> 962         key_to_free = new_key;</span>



 963     }
 964   else
 965     {
 966       hash_table-&gt;hashes[node_index] = key_hash;
<span class="line-modified"> 967       hash_table-&gt;keys[node_index] = new_key;</span>
 968     }
 969 
<span class="line-modified"> 970   /* Step two: check if the value that we are about to write to the</span>
<span class="line-modified"> 971    * table is the same as the key in the same position.  If it&#39;s not,</span>
<span class="line-modified"> 972    * split the table.</span>
<span class="line-removed"> 973    */</span>
<span class="line-removed"> 974   if (G_UNLIKELY (hash_table-&gt;keys == hash_table-&gt;values &amp;&amp; hash_table-&gt;keys[node_index] != new_value))</span>
<span class="line-removed"> 975     hash_table-&gt;values = g_memdup (hash_table-&gt;keys, sizeof (gpointer) * hash_table-&gt;size);</span>
 976 
 977   /* Step 3: Actually do the write */
<span class="line-modified"> 978   hash_table-&gt;values[node_index] = new_value;</span>
 979 
 980   /* Now, the bookkeeping... */
 981   if (!already_exists)
 982     {
 983       hash_table-&gt;nnodes++;
 984 
 985       if (HASH_IS_UNUSED (old_hash))
 986         {
 987           /* We replaced an empty node, and not a tombstone */
 988           hash_table-&gt;noccupied++;
 989           g_hash_table_maybe_resize (hash_table);
 990         }
 991 
 992 #ifndef G_DISABLE_ASSERT
 993       hash_table-&gt;version++;
 994 #endif
 995     }
 996 
 997   if (already_exists)
 998     {
</pre>
<hr />
<pre>
1017  * If you supplied a @value_destroy_func when creating the
1018  * #GHashTable, the old value is freed using that function.
1019  *
1020  * Since: 2.30
1021  */
1022 void
1023 g_hash_table_iter_replace (GHashTableIter *iter,
1024                            gpointer        value)
1025 {
1026   RealIter *ri;
1027   guint node_hash;
1028   gpointer key;
1029 
1030   ri = (RealIter *) iter;
1031 
1032   g_return_if_fail (ri != NULL);
1033 #ifndef G_DISABLE_ASSERT
1034   g_return_if_fail (ri-&gt;version == ri-&gt;hash_table-&gt;version);
1035 #endif
1036   g_return_if_fail (ri-&gt;position &gt;= 0);
<span class="line-modified">1037   g_return_if_fail (ri-&gt;position &lt; ri-&gt;hash_table-&gt;size);</span>
1038 
1039   node_hash = ri-&gt;hash_table-&gt;hashes[ri-&gt;position];
<span class="line-modified">1040   key = ri-&gt;hash_table-&gt;keys[ri-&gt;position];</span>

1041 
1042   g_hash_table_insert_node (ri-&gt;hash_table, ri-&gt;position, node_hash, key, value, TRUE, TRUE);
1043 
1044 #ifndef G_DISABLE_ASSERT
1045   ri-&gt;version++;
1046   ri-&gt;hash_table-&gt;version++;
1047 #endif
1048 }
1049 
1050 /**
1051  * g_hash_table_iter_steal:
1052  * @iter: an initialized #GHashTableIter
1053  *
1054  * Removes the key/value pair currently pointed to by the
1055  * iterator from its associated #GHashTable, without calling
1056  * the key and value destroy functions. Can only be called
1057  * after g_hash_table_iter_next() returned %TRUE, and cannot
1058  * be called more than once for the same key/value pair.
1059  *
1060  * Since: 2.16
</pre>
<hr />
<pre>
1141  *
1142  * Looks up a key in a #GHashTable. Note that this function cannot
1143  * distinguish between a key that is not present and one which is present
1144  * and has the value %NULL. If you need this distinction, use
1145  * g_hash_table_lookup_extended().
1146  *
1147  * Returns: (nullable): the associated value, or %NULL if the key is not found
1148  */
1149 gpointer
1150 g_hash_table_lookup (GHashTable    *hash_table,
1151                      gconstpointer  key)
1152 {
1153   guint node_index;
1154   guint node_hash;
1155 
1156   g_return_val_if_fail (hash_table != NULL, NULL);
1157 
1158   node_index = g_hash_table_lookup_node (hash_table, key, &amp;node_hash);
1159 
1160   return HASH_IS_REAL (hash_table-&gt;hashes[node_index])
<span class="line-modified">1161     ? hash_table-&gt;values[node_index]</span>
1162     : NULL;
1163 }
1164 
1165 /**
1166  * g_hash_table_lookup_extended:
1167  * @hash_table: a #GHashTable
1168  * @lookup_key: the key to look up
1169  * @orig_key: (out) (optional): return location for the original key
1170  * @value: (out) (optional) (nullable): return location for the value associated
1171  * with the key
1172  *
1173  * Looks up a key in the #GHashTable, returning the original key and the
1174  * associated value and a #gboolean which is %TRUE if the key was found. This
1175  * is useful if you need to free the memory allocated for the original key,
1176  * for example before calling g_hash_table_remove().
1177  *
1178  * You can actually pass %NULL for @lookup_key to test
1179  * whether the %NULL key exists, provided the hash and equal functions
1180  * of @hash_table are %NULL-safe.
1181  *
1182  * Returns: %TRUE if the key was found in the #GHashTable
1183  */
1184 gboolean
1185 g_hash_table_lookup_extended (GHashTable    *hash_table,
1186                               gconstpointer  lookup_key,
1187                               gpointer      *orig_key,
1188                               gpointer      *value)
1189 {
1190   guint node_index;
1191   guint node_hash;
1192 
1193   g_return_val_if_fail (hash_table != NULL, FALSE);
1194 
1195   node_index = g_hash_table_lookup_node (hash_table, lookup_key, &amp;node_hash);
1196 
1197   if (!HASH_IS_REAL (hash_table-&gt;hashes[node_index]))
<span class="line-modified">1198     return FALSE;</span>







1199 
1200   if (orig_key)
<span class="line-modified">1201     *orig_key = hash_table-&gt;keys[node_index];</span>
1202 
1203   if (value)
<span class="line-modified">1204     *value = hash_table-&gt;values[node_index];</span>
1205 
1206   return TRUE;
1207 }
1208 
1209 /*
1210  * g_hash_table_insert_internal:
1211  * @hash_table: our #GHashTable
1212  * @key: the key to insert
1213  * @value: the value to insert
1214  * @keep_new_key: if %TRUE and this key already exists in the table
1215  *   then call the destroy notify function on the old key.  If %FALSE
1216  *   then call the destroy notify function on the new key.
1217  *
1218  * Implements the common logic for the g_hash_table_insert() and
1219  * g_hash_table_replace() functions.
1220  *
1221  * Do a lookup of @key. If it is found, replace it with the new
1222  * @value (and perhaps the new @key). If it is not found, create
1223  * a new node.
1224  *
</pre>
<hr />
<pre>
1455                              gpointer      *stolen_key,
1456                              gpointer      *stolen_value)
1457 {
1458   guint node_index;
1459   guint node_hash;
1460 
1461   g_return_val_if_fail (hash_table != NULL, FALSE);
1462 
1463   node_index = g_hash_table_lookup_node (hash_table, lookup_key, &amp;node_hash);
1464 
1465   if (!HASH_IS_REAL (hash_table-&gt;hashes[node_index]))
1466     {
1467       if (stolen_key != NULL)
1468         *stolen_key = NULL;
1469       if (stolen_value != NULL)
1470         *stolen_value = NULL;
1471       return FALSE;
1472     }
1473 
1474   if (stolen_key != NULL)
<span class="line-modified">1475     *stolen_key = g_steal_pointer (&amp;hash_table-&gt;keys[node_index]);</span>



1476 
1477   if (stolen_value != NULL)
<span class="line-modified">1478     *stolen_value = g_steal_pointer (&amp;hash_table-&gt;values[node_index]);</span>



1479 
1480   g_hash_table_remove_node (hash_table, node_index, FALSE);
1481   g_hash_table_maybe_resize (hash_table);
1482 
1483 #ifndef G_DISABLE_ASSERT
1484   hash_table-&gt;version++;
1485 #endif
1486 
1487   return TRUE;
1488 }
1489 
1490 /**
1491  * g_hash_table_remove_all:
1492  * @hash_table: a #GHashTable
1493  *
1494  * Removes all keys and their associated values from a #GHashTable.
1495  *
1496  * If the #GHashTable was created using g_hash_table_new_full(),
1497  * the keys and values are freed using the supplied destroy functions,
1498  * otherwise you have to make sure that any dynamically allocated
</pre>
<hr />
<pre>
1544  * @user_data: data for @func
1545  * @notify: %TRUE if the destroy notify handlers are to be called
1546  *
1547  * Implements the common logic for g_hash_table_foreach_remove()
1548  * and g_hash_table_foreach_steal().
1549  *
1550  * Iterates over every node in the table, calling @func with the key
1551  * and value of the node (and @user_data). If @func returns %TRUE the
1552  * node is removed from the table.
1553  *
1554  * If @notify is true then the destroy notify handlers will be called
1555  * for each removed node.
1556  */
1557 static guint
1558 g_hash_table_foreach_remove_or_steal (GHashTable *hash_table,
1559                                       GHRFunc     func,
1560                                       gpointer    user_data,
1561                                       gboolean    notify)
1562 {
1563   guint deleted = 0;
<span class="line-modified">1564   gint i;</span>
1565 #ifndef G_DISABLE_ASSERT
1566   gint version = hash_table-&gt;version;
1567 #endif
1568 
1569   for (i = 0; i &lt; hash_table-&gt;size; i++)
1570     {
1571       guint node_hash = hash_table-&gt;hashes[i];
<span class="line-modified">1572       gpointer node_key = hash_table-&gt;keys[i];</span>
<span class="line-modified">1573       gpointer node_value = hash_table-&gt;values[i];</span>
1574 
1575       if (HASH_IS_REAL (node_hash) &amp;&amp;
1576           (* func) (node_key, node_value, user_data))
1577         {
1578           g_hash_table_remove_node (hash_table, i, notify);
1579           deleted++;
1580         }
1581 
1582 #ifndef G_DISABLE_ASSERT
1583       g_return_val_if_fail (version == hash_table-&gt;version, 0);
1584 #endif
1585     }
1586 
1587   g_hash_table_maybe_resize (hash_table);
1588 
1589 #ifndef G_DISABLE_ASSERT
1590   if (deleted &gt; 0)
1591     hash_table-&gt;version++;
1592 #endif
1593 
</pre>
<hr />
<pre>
1653  * g_hash_table_foreach:
1654  * @hash_table: a #GHashTable
1655  * @func: the function to call for each key/value pair
1656  * @user_data: user data to pass to the function
1657  *
1658  * Calls the given function for each of the key/value pairs in the
1659  * #GHashTable.  The function is passed the key and value of each
1660  * pair, and the given @user_data parameter.  The hash table may not
1661  * be modified while iterating over it (you can&#39;t add/remove
1662  * items). To remove all items matching a predicate, use
1663  * g_hash_table_foreach_remove().
1664  *
1665  * See g_hash_table_find() for performance caveats for linear
1666  * order searches in contrast to g_hash_table_lookup().
1667  */
1668 void
1669 g_hash_table_foreach (GHashTable *hash_table,
1670                       GHFunc      func,
1671                       gpointer    user_data)
1672 {
<span class="line-modified">1673   gint i;</span>
1674 #ifndef G_DISABLE_ASSERT
1675   gint version;
1676 #endif
1677 
1678   g_return_if_fail (hash_table != NULL);
1679   g_return_if_fail (func != NULL);
1680 
1681 #ifndef G_DISABLE_ASSERT
1682   version = hash_table-&gt;version;
1683 #endif
1684 
1685   for (i = 0; i &lt; hash_table-&gt;size; i++)
1686     {
1687       guint node_hash = hash_table-&gt;hashes[i];
<span class="line-modified">1688       gpointer node_key = hash_table-&gt;keys[i];</span>
<span class="line-modified">1689       gpointer node_value = hash_table-&gt;values[i];</span>
1690 
1691       if (HASH_IS_REAL (node_hash))
1692         (* func) (node_key, node_value, user_data);
1693 
1694 #ifndef G_DISABLE_ASSERT
1695       g_return_if_fail (version == hash_table-&gt;version);
1696 #endif
1697     }
1698 }
1699 
1700 /**
1701  * g_hash_table_find:
1702  * @hash_table: a #GHashTable
1703  * @predicate: function to test the key/value pairs for a certain property
1704  * @user_data: user data to pass to the function
1705  *
1706  * Calls the given function for key/value pairs in the #GHashTable
1707  * until @predicate returns %TRUE. The function is passed the key
1708  * and value of each pair, and the given @user_data parameter. The
1709  * hash table may not be modified while iterating over it (you can&#39;t
</pre>
<hr />
<pre>
1711  *
1712  * Note, that hash tables are really only optimized for forward
1713  * lookups, i.e. g_hash_table_lookup(). So code that frequently issues
1714  * g_hash_table_find() or g_hash_table_foreach() (e.g. in the order of
1715  * once per every entry in a hash table) should probably be reworked
1716  * to use additional or different data structures for reverse lookups
1717  * (keep in mind that an O(n) find/foreach operation issued for all n
1718  * values in a hash table ends up needing O(n*n) operations).
1719  *
1720  * Returns: (nullable): The value of the first key/value pair is returned,
1721  *     for which @predicate evaluates to %TRUE. If no pair with the
1722  *     requested property is found, %NULL is returned.
1723  *
1724  * Since: 2.4
1725  */
1726 gpointer
1727 g_hash_table_find (GHashTable *hash_table,
1728                    GHRFunc     predicate,
1729                    gpointer    user_data)
1730 {
<span class="line-modified">1731   gint i;</span>
1732 #ifndef G_DISABLE_ASSERT
1733   gint version;
1734 #endif
1735   gboolean match;
1736 
1737   g_return_val_if_fail (hash_table != NULL, NULL);
1738   g_return_val_if_fail (predicate != NULL, NULL);
1739 
1740 #ifndef G_DISABLE_ASSERT
1741   version = hash_table-&gt;version;
1742 #endif
1743 
1744   match = FALSE;
1745 
1746   for (i = 0; i &lt; hash_table-&gt;size; i++)
1747     {
1748       guint node_hash = hash_table-&gt;hashes[i];
<span class="line-modified">1749       gpointer node_key = hash_table-&gt;keys[i];</span>
<span class="line-modified">1750       gpointer node_value = hash_table-&gt;values[i];</span>
1751 
1752       if (HASH_IS_REAL (node_hash))
1753         match = predicate (node_key, node_value, user_data);
1754 
1755 #ifndef G_DISABLE_ASSERT
1756       g_return_val_if_fail (version == hash_table-&gt;version, NULL);
1757 #endif
1758 
1759       if (match)
1760         return node_value;
1761     }
1762 
1763   return NULL;
1764 }
1765 
1766 /**
1767  * g_hash_table_size:
1768  * @hash_table: a #GHashTable
1769  *
1770  * Returns the number of elements contained in the #GHashTable.
</pre>
<hr />
<pre>
1783  * g_hash_table_get_keys:
1784  * @hash_table: a #GHashTable
1785  *
1786  * Retrieves every key inside @hash_table. The returned data is valid
1787  * until changes to the hash release those keys.
1788  *
1789  * This iterates over every entry in the hash table to build its return value.
1790  * To iterate over the entries in a #GHashTable more efficiently, use a
1791  * #GHashTableIter.
1792  *
1793  * Returns: (transfer container): a #GList containing all the keys
1794  *     inside the hash table. The content of the list is owned by the
1795  *     hash table and should not be modified or freed. Use g_list_free()
1796  *     when done using the list.
1797  *
1798  * Since: 2.14
1799  */
1800 GList *
1801 g_hash_table_get_keys (GHashTable *hash_table)
1802 {
<span class="line-modified">1803   gint i;</span>
1804   GList *retval;
1805 
1806   g_return_val_if_fail (hash_table != NULL, NULL);
1807 
1808   retval = NULL;
1809   for (i = 0; i &lt; hash_table-&gt;size; i++)
1810     {
1811       if (HASH_IS_REAL (hash_table-&gt;hashes[i]))
<span class="line-modified">1812         retval = g_list_prepend (retval, hash_table-&gt;keys[i]);</span>
1813     }
1814 
1815   return retval;
1816 }
1817 
1818 /**
1819  * g_hash_table_get_keys_as_array:
1820  * @hash_table: a #GHashTable
1821  * @length: (out): the length of the returned array
1822  *
1823  * Retrieves every key inside @hash_table, as an array.
1824  *
1825  * The returned array is %NULL-terminated but may contain %NULL as a
1826  * key.  Use @length to determine the true length if it&#39;s possible that
1827  * %NULL was used as the value for a key.
1828  *
1829  * Note: in the common case of a string-keyed #GHashTable, the return
1830  * value of this function can be conveniently cast to (const gchar **).
1831  *
1832  * This iterates over every entry in the hash table to build its return value.
1833  * To iterate over the entries in a #GHashTable more efficiently, use a
1834  * #GHashTableIter.
1835  *
1836  * You should always free the return result with g_free().  In the
1837  * above-mentioned case of a string-keyed hash table, it may be
1838  * appropriate to use g_strfreev() if you call g_hash_table_steal_all()
1839  * first to transfer ownership of the keys.
1840  *
1841  * Returns: (array length=length) (transfer container): a
1842  *   %NULL-terminated array containing each key from the table.
1843  *
1844  * Since: 2.40
1845  **/
1846 gpointer *
1847 g_hash_table_get_keys_as_array (GHashTable *hash_table,
1848                                 guint      *length)
1849 {
1850   gpointer *result;
<span class="line-modified">1851   guint i, j = 0;</span>
1852 
1853   result = g_new (gpointer, hash_table-&gt;nnodes + 1);
1854   for (i = 0; i &lt; hash_table-&gt;size; i++)
1855     {
1856       if (HASH_IS_REAL (hash_table-&gt;hashes[i]))
<span class="line-modified">1857         result[j++] = hash_table-&gt;keys[i];</span>
1858     }
1859   g_assert_cmpint (j, ==, hash_table-&gt;nnodes);
1860   result[j] = NULL;
1861 
1862   if (length)
1863     *length = j;
1864 
1865   return result;
1866 }
1867 
1868 /**
1869  * g_hash_table_get_values:
1870  * @hash_table: a #GHashTable
1871  *
1872  * Retrieves every value inside @hash_table. The returned data
1873  * is valid until @hash_table is modified.
1874  *
1875  * This iterates over every entry in the hash table to build its return value.
1876  * To iterate over the entries in a #GHashTable more efficiently, use a
1877  * #GHashTableIter.
1878  *
1879  * Returns: (transfer container): a #GList containing all the values
1880  *     inside the hash table. The content of the list is owned by the
1881  *     hash table and should not be modified or freed. Use g_list_free()
1882  *     when done using the list.
1883  *
1884  * Since: 2.14
1885  */
1886 GList *
1887 g_hash_table_get_values (GHashTable *hash_table)
1888 {
<span class="line-modified">1889   gint i;</span>
1890   GList *retval;
1891 
1892   g_return_val_if_fail (hash_table != NULL, NULL);
1893 
1894   retval = NULL;
1895   for (i = 0; i &lt; hash_table-&gt;size; i++)
1896     {
1897       if (HASH_IS_REAL (hash_table-&gt;hashes[i]))
<span class="line-modified">1898         retval = g_list_prepend (retval, hash_table-&gt;values[i]);</span>
1899     }
1900 
1901   return retval;
1902 }
1903 
1904 /* Hash functions.
1905  */
1906 
1907 /**
1908  * g_str_equal:
1909  * @v1: (not nullable): a key
1910  * @v2: (not nullable): a key to compare with @v1
1911  *
1912  * Compares two strings for byte-by-byte equality and returns %TRUE
1913  * if they are equal. It can be passed to g_hash_table_new() as the
1914  * @key_equal_func parameter, when using non-%NULL strings as keys in a
1915  * #GHashTable.
1916  *
1917  * This function is typically used for hash table comparisons, but can be used
1918  * for general purpose comparisons of non-%NULL strings. For a %NULL-safe string
</pre>
</td>
<td>
<hr />
<pre>
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #include &lt;string.h&gt;  /* memset */
  32 
  33 #include &quot;ghash.h&quot;
<span class="line-modified">  34 #include &quot;gmacros.h&quot;</span>
  35 #include &quot;glib-private.h&quot;
  36 #include &quot;gstrfuncs.h&quot;
  37 #include &quot;gatomic.h&quot;
  38 #include &quot;gtestutils.h&quot;
  39 #include &quot;gslice.h&quot;
  40 #include &quot;grefcount.h&quot;
<span class="line-added">  41 #include &quot;gvalgrind.h&quot;</span>
<span class="line-added">  42 </span>
<span class="line-added">  43 /* The following #pragma is here so we can do this...</span>
<span class="line-added">  44  *</span>
<span class="line-added">  45  *   #ifndef USE_SMALL_ARRAYS</span>
<span class="line-added">  46  *     is_big = TRUE;</span>
<span class="line-added">  47  *   #endif</span>
<span class="line-added">  48  *     return is_big ? *(((gpointer *) a) + index) : GUINT_TO_POINTER (*(((guint *) a) + index));</span>
<span class="line-added">  49  *</span>
<span class="line-added">  50  * ...instead of this...</span>
<span class="line-added">  51  *</span>
<span class="line-added">  52  *   #ifndef USE_SMALL_ARRAYS</span>
<span class="line-added">  53  *     return *(((gpointer *) a) + index);</span>
<span class="line-added">  54  *   #else</span>
<span class="line-added">  55  *     return is_big ? *(((gpointer *) a) + index) : GUINT_TO_POINTER (*(((guint *) a) + index));</span>
<span class="line-added">  56  *   #endif</span>
<span class="line-added">  57  *</span>
<span class="line-added">  58  * ...and still compile successfully when -Werror=duplicated-branches is passed. */</span>
<span class="line-added">  59 </span>
<span class="line-added">  60 #if defined(__GNUC__) &amp;&amp; __GNUC__ &gt; 6</span>
<span class="line-added">  61 #pragma GCC diagnostic ignored &quot;-Wduplicated-branches&quot;</span>
<span class="line-added">  62 #endif</span>
  63 
  64 /**
  65  * SECTION:hash_tables
  66  * @title: Hash Tables
  67  * @short_description: associations between keys and values so that
  68  *     given a key the value can be found quickly
  69  *
  70  * A #GHashTable provides associations between keys and values which is
  71  * optimized so that given a key, the associated value can be found
  72  * very quickly.
  73  *
  74  * Note that neither keys nor values are copied when inserted into the
  75  * #GHashTable, so they must exist for the lifetime of the #GHashTable.
  76  * This means that the use of static strings is OK, but temporary
  77  * strings (i.e. those created in buffers and those returned by GTK+
  78  * widgets) should be copied with g_strdup() before being inserted.
  79  *
  80  * If keys or values are dynamically allocated, you must be careful to
  81  * ensure that they are freed when they are removed from the
  82  * #GHashTable, and also when they are overwritten by new insertions
  83  * into the #GHashTable. It is also not advisable to mix static strings
  84  * and dynamically-allocated strings in a #GHashTable, because it then
  85  * becomes difficult to determine whether the string should be freed.
  86  *
  87  * To create a #GHashTable, use g_hash_table_new().
  88  *
  89  * To insert a key and value into a #GHashTable, use
  90  * g_hash_table_insert().
  91  *
<span class="line-modified">  92  * To look up a value corresponding to a given key, use</span>
  93  * g_hash_table_lookup() and g_hash_table_lookup_extended().
  94  *
  95  * g_hash_table_lookup_extended() can also be used to simply
  96  * check if a key is present in the hash table.
  97  *
  98  * To remove a key and value, use g_hash_table_remove().
  99  *
 100  * To call a function for each key and value pair use
<span class="line-modified"> 101  * g_hash_table_foreach() or use an iterator to iterate over the</span>
 102  * key/value pairs in the hash table, see #GHashTableIter.
 103  *
 104  * To destroy a #GHashTable use g_hash_table_destroy().
 105  *
 106  * A common use-case for hash tables is to store information about a
 107  * set of keys, without associating any particular value with each
 108  * key. GHashTable optimizes one way of doing so: If you store only
 109  * key-value pairs where key == value, then GHashTable does not
 110  * allocate memory to store the values, which can be a considerable
 111  * space saving, if your set is large. The functions
 112  * g_hash_table_add() and g_hash_table_contains() are designed to be
 113  * used when using #GHashTable this way.
 114  *
 115  * #GHashTable is not designed to be statically initialised with keys and
 116  * values known at compile time. To build a static hash table, use a tool such
 117  * as [gperf](https://www.gnu.org/software/gperf/).
 118  */
 119 
 120 /**
 121  * GHashTable:
</pre>
<hr />
<pre>
 218  * This function is deprecated and will be removed in the next major
 219  * release of GLib. It does nothing.
 220  */
 221 
 222 /**
 223  * g_hash_table_thaw:
 224  * @hash_table: a #GHashTable
 225  *
 226  * This function is deprecated and will be removed in the next major
 227  * release of GLib. It does nothing.
 228  */
 229 
 230 #define HASH_TABLE_MIN_SHIFT 3  /* 1 &lt;&lt; 3 == 8 buckets */
 231 
 232 #define UNUSED_HASH_VALUE 0
 233 #define TOMBSTONE_HASH_VALUE 1
 234 #define HASH_IS_UNUSED(h_) ((h_) == UNUSED_HASH_VALUE)
 235 #define HASH_IS_TOMBSTONE(h_) ((h_) == TOMBSTONE_HASH_VALUE)
 236 #define HASH_IS_REAL(h_) ((h_) &gt;= 2)
 237 
<span class="line-added"> 238 /* If int is smaller than void * on our arch, we start out with</span>
<span class="line-added"> 239  * int-sized keys and values and resize to pointer-sized entries as</span>
<span class="line-added"> 240  * needed. This saves a good amount of memory when the HT is being</span>
<span class="line-added"> 241  * used with e.g. GUINT_TO_POINTER(). */</span>
<span class="line-added"> 242 </span>
<span class="line-added"> 243 #define BIG_ENTRY_SIZE (SIZEOF_VOID_P)</span>
<span class="line-added"> 244 #define SMALL_ENTRY_SIZE (SIZEOF_INT)</span>
<span class="line-added"> 245 </span>
<span class="line-added"> 246 #if SMALL_ENTRY_SIZE &lt; BIG_ENTRY_SIZE</span>
<span class="line-added"> 247 # define USE_SMALL_ARRAYS</span>
<span class="line-added"> 248 #endif</span>
<span class="line-added"> 249 </span>
 250 struct _GHashTable
 251 {
<span class="line-modified"> 252   gsize            size;</span>
 253   gint             mod;
 254   guint            mask;
 255   gint             nnodes;
 256   gint             noccupied;  /* nnodes + tombstones */
 257 
<span class="line-modified"> 258   guint            have_big_keys : 1;</span>
<span class="line-added"> 259   guint            have_big_values : 1;</span>
<span class="line-added"> 260 </span>
<span class="line-added"> 261   gpointer         keys;</span>
 262   guint           *hashes;
<span class="line-modified"> 263   gpointer         values;</span>
 264 
 265   GHashFunc        hash_func;
 266   GEqualFunc       key_equal_func;
 267   gatomicrefcount  ref_count;
 268 #ifndef G_DISABLE_ASSERT
 269   /*
 270    * Tracks the structure of the hash table, not its contents: is only
 271    * incremented when a node is added or removed (is not incremented
 272    * when the key or data of a node is modified).
 273    */
 274   int              version;
 275 #endif
 276   GDestroyNotify   key_destroy_func;
 277   GDestroyNotify   value_destroy_func;
 278 };
 279 
 280 typedef struct
 281 {
 282   GHashTable  *hash_table;
 283   gpointer     dummy1;
 284   gpointer     dummy2;
<span class="line-modified"> 285   gint         position;</span>
 286   gboolean     dummy3;
<span class="line-modified"> 287   gint         version;</span>
 288 } RealIter;
 289 
 290 G_STATIC_ASSERT (sizeof (GHashTableIter) == sizeof (RealIter));
<span class="line-modified"> 291 G_STATIC_ASSERT (G_ALIGNOF (GHashTableIter) &gt;= G_ALIGNOF (RealIter));</span>
 292 
 293 /* Each table size has an associated prime modulo (the first prime
 294  * lower than the table size) used to find the initial bucket. Probing
 295  * then works modulo 2^n. The prime modulo is necessary to get a
 296  * good distribution with poor hash functions.
 297  */
 298 static const gint prime_mod [] =
 299 {
 300   1,          /* For 1 &lt;&lt; 0 */
 301   2,
 302   3,
 303   7,
 304   13,
 305   31,
 306   61,
 307   127,
 308   251,
 309   509,
 310   1021,
 311   2039,
</pre>
<hr />
<pre>
 317   131071,
 318   262139,
 319   524287,
 320   1048573,
 321   2097143,
 322   4194301,
 323   8388593,
 324   16777213,
 325   33554393,
 326   67108859,
 327   134217689,
 328   268435399,
 329   536870909,
 330   1073741789,
 331   2147483647  /* For 1 &lt;&lt; 31 */
 332 };
 333 
 334 static void
 335 g_hash_table_set_shift (GHashTable *hash_table, gint shift)
 336 {



 337   hash_table-&gt;size = 1 &lt;&lt; shift;
 338   hash_table-&gt;mod  = prime_mod [shift];
 339 
<span class="line-modified"> 340   /* hash_table-&gt;size is always a power of two, so we can calculate the mask</span>
<span class="line-modified"> 341    * by simply subtracting 1 from it. The leading assertion ensures that</span>
<span class="line-modified"> 342    * we&#39;re really dealing with a power of two. */</span>


 343 
<span class="line-modified"> 344   g_assert ((hash_table-&gt;size &amp; (hash_table-&gt;size - 1)) == 0);</span>
<span class="line-added"> 345   hash_table-&gt;mask = hash_table-&gt;size - 1;</span>
 346 }
 347 
 348 static gint
 349 g_hash_table_find_closest_shift (gint n)
 350 {
 351   gint i;
 352 
 353   for (i = 0; n; i++)
 354     n &gt;&gt;= 1;
 355 
 356   return i;
 357 }
 358 
 359 static void
 360 g_hash_table_set_shift_from_size (GHashTable *hash_table, gint size)
 361 {
 362   gint shift;
 363 
 364   shift = g_hash_table_find_closest_shift (size);
 365   shift = MAX (shift, HASH_TABLE_MIN_SHIFT);
 366 
 367   g_hash_table_set_shift (hash_table, shift);
 368 }
 369 
<span class="line-added"> 370 static inline gpointer</span>
<span class="line-added"> 371 g_hash_table_realloc_key_or_value_array (gpointer a, guint size, G_GNUC_UNUSED gboolean is_big)</span>
<span class="line-added"> 372 {</span>
<span class="line-added"> 373 #ifdef USE_SMALL_ARRAYS</span>
<span class="line-added"> 374   return g_realloc (a, size * (is_big ? BIG_ENTRY_SIZE : SMALL_ENTRY_SIZE));</span>
<span class="line-added"> 375 #else</span>
<span class="line-added"> 376   return g_renew (gpointer, a, size);</span>
<span class="line-added"> 377 #endif</span>
<span class="line-added"> 378 }</span>
<span class="line-added"> 379 </span>
<span class="line-added"> 380 static inline gpointer</span>
<span class="line-added"> 381 g_hash_table_fetch_key_or_value (gpointer a, guint index, gboolean is_big)</span>
<span class="line-added"> 382 {</span>
<span class="line-added"> 383 #ifndef USE_SMALL_ARRAYS</span>
<span class="line-added"> 384   is_big = TRUE;</span>
<span class="line-added"> 385 #endif</span>
<span class="line-added"> 386   return is_big ? *(((gpointer *) a) + index) : GUINT_TO_POINTER (*(((guint *) a) + index));</span>
<span class="line-added"> 387 }</span>
<span class="line-added"> 388 </span>
<span class="line-added"> 389 static inline void</span>
<span class="line-added"> 390 g_hash_table_assign_key_or_value (gpointer a, guint index, gboolean is_big, gpointer v)</span>
<span class="line-added"> 391 {</span>
<span class="line-added"> 392 #ifndef USE_SMALL_ARRAYS</span>
<span class="line-added"> 393   is_big = TRUE;</span>
<span class="line-added"> 394 #endif</span>
<span class="line-added"> 395   if (is_big)</span>
<span class="line-added"> 396     *(((gpointer *) a) + index) = v;</span>
<span class="line-added"> 397   else</span>
<span class="line-added"> 398     *(((guint *) a) + index) = GPOINTER_TO_UINT (v);</span>
<span class="line-added"> 399 }</span>
<span class="line-added"> 400 </span>
<span class="line-added"> 401 static inline gpointer</span>
<span class="line-added"> 402 g_hash_table_evict_key_or_value (gpointer a, guint index, gboolean is_big, gpointer v)</span>
<span class="line-added"> 403 {</span>
<span class="line-added"> 404 #ifndef USE_SMALL_ARRAYS</span>
<span class="line-added"> 405   is_big = TRUE;</span>
<span class="line-added"> 406 #endif</span>
<span class="line-added"> 407   if (is_big)</span>
<span class="line-added"> 408     {</span>
<span class="line-added"> 409       gpointer r = *(((gpointer *) a) + index);</span>
<span class="line-added"> 410       *(((gpointer *) a) + index) = v;</span>
<span class="line-added"> 411       return r;</span>
<span class="line-added"> 412     }</span>
<span class="line-added"> 413   else</span>
<span class="line-added"> 414     {</span>
<span class="line-added"> 415       gpointer r = GUINT_TO_POINTER (*(((guint *) a) + index));</span>
<span class="line-added"> 416       *(((guint *) a) + index) = GPOINTER_TO_UINT (v);</span>
<span class="line-added"> 417       return r;</span>
<span class="line-added"> 418     }</span>
<span class="line-added"> 419 }</span>
<span class="line-added"> 420 </span>
<span class="line-added"> 421 static inline guint</span>
<span class="line-added"> 422 g_hash_table_hash_to_index (GHashTable *hash_table, guint hash)</span>
<span class="line-added"> 423 {</span>
<span class="line-added"> 424   /* Multiply the hash by a small prime before applying the modulo. This</span>
<span class="line-added"> 425    * prevents the table from becoming densely packed, even with a poor hash</span>
<span class="line-added"> 426    * function. A densely packed table would have poor performance on</span>
<span class="line-added"> 427    * workloads with many failed lookups or a high degree of churn. */</span>
<span class="line-added"> 428   return (hash * 11) % hash_table-&gt;mod;</span>
<span class="line-added"> 429 }</span>
<span class="line-added"> 430 </span>
 431 /*
 432  * g_hash_table_lookup_node:
 433  * @hash_table: our #GHashTable
<span class="line-modified"> 434  * @key: the key to look up against</span>
 435  * @hash_return: key hash return location
 436  *
 437  * Performs a lookup in the hash table, preserving extra information
 438  * usually needed for insertion.
 439  *
 440  * This function first computes the hash value of the key using the
 441  * user&#39;s hash function.
 442  *
 443  * If an entry in the table matching @key is found then this function
 444  * returns the index of that entry in the table, and if not, the
 445  * index of an unused node (empty or tombstone) where the key can be
 446  * inserted.
 447  *
 448  * The computed hash value is returned in the variable pointed to
 449  * by @hash_return. This is to save insertions from having to compute
 450  * the hash record again for the new record.
 451  *
 452  * Returns: index of the described node
 453  */
 454 static inline guint
</pre>
<hr />
<pre>
 459   guint node_index;
 460   guint node_hash;
 461   guint hash_value;
 462   guint first_tombstone = 0;
 463   gboolean have_tombstone = FALSE;
 464   guint step = 0;
 465 
 466   /* If this happens, then the application is probably doing too much work
 467    * from a destroy notifier. The alternative would be to crash any second
 468    * (as keys, etc. will be NULL).
 469    * Applications need to either use g_hash_table_destroy, or ensure the hash
 470    * table is empty prior to removing the last reference using g_hash_table_unref(). */
 471   g_assert (!g_atomic_ref_count_compare (&amp;hash_table-&gt;ref_count, 0));
 472 
 473   hash_value = hash_table-&gt;hash_func (key);
 474   if (G_UNLIKELY (!HASH_IS_REAL (hash_value)))
 475     hash_value = 2;
 476 
 477   *hash_return = hash_value;
 478 
<span class="line-modified"> 479   node_index = g_hash_table_hash_to_index (hash_table, hash_value);</span>
 480   node_hash = hash_table-&gt;hashes[node_index];
 481 
 482   while (!HASH_IS_UNUSED (node_hash))
 483     {
 484       /* We first check if our full hash values
 485        * are equal so we can avoid calling the full-blown
 486        * key equality function in most cases.
 487        */
 488       if (node_hash == hash_value)
 489         {
<span class="line-modified"> 490           gpointer node_key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys);</span>
 491 
 492           if (hash_table-&gt;key_equal_func)
 493             {
 494               if (hash_table-&gt;key_equal_func (node_key, key))
 495                 return node_index;
 496             }
 497           else if (node_key == key)
 498             {
 499               return node_index;
 500             }
 501         }
 502       else if (HASH_IS_TOMBSTONE (node_hash) &amp;&amp; !have_tombstone)
 503         {
 504           first_tombstone = node_index;
 505           have_tombstone = TRUE;
 506         }
 507 
 508       step++;
 509       node_index += step;
 510       node_index &amp;= hash_table-&gt;mask;
</pre>
<hr />
<pre>
 520 /*
 521  * g_hash_table_remove_node:
 522  * @hash_table: our #GHashTable
 523  * @node: pointer to node to remove
 524  * @notify: %TRUE if the destroy notify handlers are to be called
 525  *
 526  * Removes a node from the hash table and updates the node count.
 527  * The node is replaced by a tombstone. No table resize is performed.
 528  *
 529  * If @notify is %TRUE then the destroy notify functions are called
 530  * for the key and value of the hash node.
 531  */
 532 static void
 533 g_hash_table_remove_node (GHashTable   *hash_table,
 534                           gint          i,
 535                           gboolean      notify)
 536 {
 537   gpointer key;
 538   gpointer value;
 539 
<span class="line-modified"> 540   key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys);</span>
<span class="line-modified"> 541   value = g_hash_table_fetch_key_or_value (hash_table-&gt;values, i, hash_table-&gt;have_big_values);</span>
 542 
 543   /* Erect tombstone */
 544   hash_table-&gt;hashes[i] = TOMBSTONE_HASH_VALUE;
 545 
 546   /* Be GC friendly */
<span class="line-modified"> 547   g_hash_table_assign_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys, NULL);</span>
<span class="line-modified"> 548   g_hash_table_assign_key_or_value (hash_table-&gt;values, i, hash_table-&gt;have_big_values, NULL);</span>
 549 
 550   hash_table-&gt;nnodes--;
 551 
 552   if (notify &amp;&amp; hash_table-&gt;key_destroy_func)
 553     hash_table-&gt;key_destroy_func (key);
 554 
 555   if (notify &amp;&amp; hash_table-&gt;value_destroy_func)
 556     hash_table-&gt;value_destroy_func (value);
 557 
 558 }
 559 
<span class="line-added"> 560 /*</span>
<span class="line-added"> 561  * g_hash_table_setup_storage:</span>
<span class="line-added"> 562  * @hash_table: our #GHashTable</span>
<span class="line-added"> 563  *</span>
<span class="line-added"> 564  * Initialise the hash table size, mask, mod, and arrays.</span>
<span class="line-added"> 565  */</span>
<span class="line-added"> 566 static void</span>
<span class="line-added"> 567 g_hash_table_setup_storage (GHashTable *hash_table)</span>
<span class="line-added"> 568 {</span>
<span class="line-added"> 569   gboolean small;</span>
<span class="line-added"> 570 </span>
<span class="line-added"> 571   /* We want to use small arrays only if:</span>
<span class="line-added"> 572    *   - we are running on a system where that makes sense (64 bit); and</span>
<span class="line-added"> 573    *   - we are not running under valgrind.</span>
<span class="line-added"> 574    */</span>
<span class="line-added"> 575   small = FALSE;</span>
<span class="line-added"> 576 </span>
<span class="line-added"> 577 #ifdef USE_SMALL_ARRAYS</span>
<span class="line-added"> 578   small = TRUE;</span>
<span class="line-added"> 579 </span>
<span class="line-added"> 580 # ifdef ENABLE_VALGRIND</span>
<span class="line-added"> 581   if (RUNNING_ON_VALGRIND)</span>
<span class="line-added"> 582     small = FALSE;</span>
<span class="line-added"> 583 # endif</span>
<span class="line-added"> 584 #endif</span>
<span class="line-added"> 585 </span>
<span class="line-added"> 586   g_hash_table_set_shift (hash_table, HASH_TABLE_MIN_SHIFT);</span>
<span class="line-added"> 587 </span>
<span class="line-added"> 588   hash_table-&gt;have_big_keys = !small;</span>
<span class="line-added"> 589   hash_table-&gt;have_big_values = !small;</span>
<span class="line-added"> 590 </span>
<span class="line-added"> 591   hash_table-&gt;keys   = g_hash_table_realloc_key_or_value_array (NULL, hash_table-&gt;size, hash_table-&gt;have_big_keys);</span>
<span class="line-added"> 592   hash_table-&gt;values = hash_table-&gt;keys;</span>
<span class="line-added"> 593   hash_table-&gt;hashes = g_new0 (guint, hash_table-&gt;size);</span>
<span class="line-added"> 594 }</span>
<span class="line-added"> 595 </span>
 596 /*
 597  * g_hash_table_remove_all_nodes:
 598  * @hash_table: our #GHashTable
 599  * @notify: %TRUE if the destroy notify handlers are to be called
 600  *
<span class="line-modified"> 601  * Removes all nodes from the table.</span>

 602  *
 603  * If @notify is %TRUE then the destroy notify functions are called
 604  * for the key and value of the hash node.
<span class="line-added"> 605  *</span>
<span class="line-added"> 606  * Since this may be a precursor to freeing the table entirely, we&#39;d</span>
<span class="line-added"> 607  * ideally perform no resize, and we can indeed avoid that in some</span>
<span class="line-added"> 608  * cases.  However: in the case that we&#39;ll be making callbacks to user</span>
<span class="line-added"> 609  * code (via destroy notifies) we need to consider that the user code</span>
<span class="line-added"> 610  * might call back into the table again.  In this case, we setup a new</span>
<span class="line-added"> 611  * set of arrays so that any callers will see an empty (but valid)</span>
<span class="line-added"> 612  * table.</span>
 613  */
 614 static void
 615 g_hash_table_remove_all_nodes (GHashTable *hash_table,
 616                                gboolean    notify,
 617                                gboolean    destruction)
 618 {
 619   int i;
 620   gpointer key;
 621   gpointer value;
 622   gint old_size;
 623   gpointer *old_keys;
 624   gpointer *old_values;
 625   guint    *old_hashes;
<span class="line-added"> 626   gboolean  old_have_big_keys;</span>
<span class="line-added"> 627   gboolean  old_have_big_values;</span>
 628 
 629   /* If the hash table is already empty, there is nothing to be done. */
 630   if (hash_table-&gt;nnodes == 0)
 631     return;
 632 
 633   hash_table-&gt;nnodes = 0;
 634   hash_table-&gt;noccupied = 0;
 635 
<span class="line-added"> 636   /* Easy case: no callbacks, so we just zero out the arrays */</span>
 637   if (!notify ||
 638       (hash_table-&gt;key_destroy_func == NULL &amp;&amp;
 639        hash_table-&gt;value_destroy_func == NULL))
 640     {
 641       if (!destruction)
 642         {
<span class="line-modified"> 643           memset (hash_table-&gt;hashes, 0, hash_table-&gt;size * sizeof (guint));</span>
<span class="line-modified"> 644 </span>
<span class="line-modified"> 645 #ifdef USE_SMALL_ARRAYS</span>
<span class="line-added"> 646           memset (hash_table-&gt;keys, 0, hash_table-&gt;size * (hash_table-&gt;have_big_keys ? BIG_ENTRY_SIZE : SMALL_ENTRY_SIZE));</span>
<span class="line-added"> 647           memset (hash_table-&gt;values, 0, hash_table-&gt;size * (hash_table-&gt;have_big_values ? BIG_ENTRY_SIZE : SMALL_ENTRY_SIZE));</span>
<span class="line-added"> 648 #else</span>
<span class="line-added"> 649           memset (hash_table-&gt;keys, 0, hash_table-&gt;size * sizeof (gpointer));</span>
<span class="line-added"> 650           memset (hash_table-&gt;values, 0, hash_table-&gt;size * sizeof (gpointer));</span>
<span class="line-added"> 651 #endif</span>
 652         }
 653 
 654       return;
 655     }
 656 
<span class="line-modified"> 657   /* Hard case: we need to do user callbacks.  There are two</span>
<span class="line-added"> 658    * possibilities here:</span>
<span class="line-added"> 659    *</span>
<span class="line-added"> 660    *   1) there are no outstanding references on the table and therefore</span>
<span class="line-added"> 661    *   nobody should be calling into it again (destroying == true)</span>
<span class="line-added"> 662    *</span>
<span class="line-added"> 663    *   2) there are outstanding references, and there may be future</span>
<span class="line-added"> 664    *   calls into the table, either after we return, or from the destroy</span>
<span class="line-added"> 665    *   notifies that we&#39;re about to do (destroying == false)</span>
<span class="line-added"> 666    *</span>
<span class="line-added"> 667    * We handle both cases by taking the current state of the table into</span>
<span class="line-added"> 668    * local variables and replacing it with something else: in the &quot;no</span>
<span class="line-added"> 669    * outstanding references&quot; cases we replace it with a bunch of</span>
<span class="line-added"> 670    * null/zero values so that any access to the table will fail.  In the</span>
<span class="line-added"> 671    * &quot;may receive future calls&quot; case, we reinitialise the struct to</span>
<span class="line-added"> 672    * appear like a newly-created empty table.</span>
<span class="line-added"> 673    *</span>
<span class="line-added"> 674    * In both cases, we take over the references for the current state,</span>
<span class="line-added"> 675    * freeing them below.</span>
<span class="line-added"> 676    */</span>
 677   old_size = hash_table-&gt;size;
<span class="line-modified"> 678   old_have_big_keys = hash_table-&gt;have_big_keys;</span>
<span class="line-modified"> 679   old_have_big_values = hash_table-&gt;have_big_values;</span>
<span class="line-modified"> 680   old_keys   = g_steal_pointer (&amp;hash_table-&gt;keys);</span>
<span class="line-modified"> 681   old_values = g_steal_pointer (&amp;hash_table-&gt;values);</span>
<span class="line-modified"> 682   old_hashes = g_steal_pointer (&amp;hash_table-&gt;hashes);</span>
<span class="line-modified"> 683 </span>





 684   if (!destruction)
<span class="line-modified"> 685     /* Any accesses will see an empty table */</span>
<span class="line-modified"> 686     g_hash_table_setup_storage (hash_table);</span>



 687   else
<span class="line-modified"> 688     /* Will cause a quick crash on any attempted access */</span>
<span class="line-modified"> 689     hash_table-&gt;size = hash_table-&gt;mod = hash_table-&gt;mask = 0;</span>



 690 
<span class="line-added"> 691   /* Now do the actual destroy notifies */</span>
 692   for (i = 0; i &lt; old_size; i++)
 693     {
 694       if (HASH_IS_REAL (old_hashes[i]))
 695         {
<span class="line-modified"> 696           key = g_hash_table_fetch_key_or_value (old_keys, i, old_have_big_keys);</span>
<span class="line-modified"> 697           value = g_hash_table_fetch_key_or_value (old_values, i, old_have_big_values);</span>
 698 
 699           old_hashes[i] = UNUSED_HASH_VALUE;
<span class="line-modified"> 700 </span>
<span class="line-modified"> 701           g_hash_table_assign_key_or_value (old_keys, i, old_have_big_keys, NULL);</span>
<span class="line-added"> 702           g_hash_table_assign_key_or_value (old_values, i, old_have_big_values, NULL);</span>
 703 
 704           if (hash_table-&gt;key_destroy_func != NULL)
 705             hash_table-&gt;key_destroy_func (key);
 706 
 707           if (hash_table-&gt;value_destroy_func != NULL)
 708             hash_table-&gt;value_destroy_func (value);
 709         }
<span class="line-modified"> 710     }</span>
 711 
 712   /* Destroy old storage space. */
 713   if (old_keys != old_values)
 714     g_free (old_values);
 715 
 716   g_free (old_keys);
 717   g_free (old_hashes);
<span class="line-modified"> 718 }</span>
<span class="line-added"> 719 </span>
<span class="line-added"> 720 static void</span>
<span class="line-added"> 721 realloc_arrays (GHashTable *hash_table, gboolean is_a_set)</span>
<span class="line-added"> 722 {</span>
<span class="line-added"> 723   hash_table-&gt;hashes = g_renew (guint, hash_table-&gt;hashes, hash_table-&gt;size);</span>
<span class="line-added"> 724   hash_table-&gt;keys = g_hash_table_realloc_key_or_value_array (hash_table-&gt;keys, hash_table-&gt;size, hash_table-&gt;have_big_keys);</span>
<span class="line-added"> 725 </span>
<span class="line-added"> 726   if (is_a_set)</span>
<span class="line-added"> 727     hash_table-&gt;values = hash_table-&gt;keys;</span>
<span class="line-added"> 728   else</span>
<span class="line-added"> 729     hash_table-&gt;values = g_hash_table_realloc_key_or_value_array (hash_table-&gt;values, hash_table-&gt;size, hash_table-&gt;have_big_values);</span>
<span class="line-added"> 730 }</span>
<span class="line-added"> 731 </span>
<span class="line-added"> 732 /* When resizing the table in place, we use a temporary bit array to keep</span>
<span class="line-added"> 733  * track of which entries have been assigned a proper location in the new</span>
<span class="line-added"> 734  * table layout.</span>
<span class="line-added"> 735  *</span>
<span class="line-added"> 736  * Each bit corresponds to a bucket. A bit is set if an entry was assigned</span>
<span class="line-added"> 737  * its corresponding location during the resize and thus should not be</span>
<span class="line-added"> 738  * evicted. The array starts out cleared to zero. */</span>
<span class="line-added"> 739 </span>
<span class="line-added"> 740 static inline gboolean</span>
<span class="line-added"> 741 get_status_bit (const guint32 *bitmap, guint index)</span>
<span class="line-added"> 742 {</span>
<span class="line-added"> 743   return (bitmap[index / 32] &gt;&gt; (index % 32)) &amp; 1;</span>
<span class="line-added"> 744 }</span>
<span class="line-added"> 745 </span>
<span class="line-added"> 746 static inline void</span>
<span class="line-added"> 747 set_status_bit (guint32 *bitmap, guint index)</span>
<span class="line-added"> 748 {</span>
<span class="line-added"> 749   bitmap[index / 32] |= 1U &lt;&lt; (index % 32);</span>
<span class="line-added"> 750 }</span>
<span class="line-added"> 751 </span>
<span class="line-added"> 752 /* By calling dedicated resize functions for sets and maps, we avoid 2x</span>
<span class="line-added"> 753  * test-and-branch per key in the inner loop. This yields a small</span>
<span class="line-added"> 754  * performance improvement at the cost of a bit of macro gunk. */</span>
<span class="line-added"> 755 </span>
<span class="line-added"> 756 #define DEFINE_RESIZE_FUNC(fname) \</span>
<span class="line-added"> 757 static void fname (GHashTable *hash_table, guint old_size, guint32 *reallocated_buckets_bitmap) \</span>
<span class="line-added"> 758 {                                                                       \</span>
<span class="line-added"> 759   guint i;                                                              \</span>
<span class="line-added"> 760                                                                         \</span>
<span class="line-added"> 761   for (i = 0; i &lt; old_size; i++)                                        \</span>
<span class="line-added"> 762     {                                                                   \</span>
<span class="line-added"> 763       guint node_hash = hash_table-&gt;hashes[i];                          \</span>
<span class="line-added"> 764       gpointer key, value G_GNUC_UNUSED;                                \</span>
<span class="line-added"> 765                                                                         \</span>
<span class="line-added"> 766       if (!HASH_IS_REAL (node_hash))                                    \</span>
<span class="line-added"> 767         {                                                               \</span>
<span class="line-added"> 768           /* Clear tombstones */                                        \</span>
<span class="line-added"> 769           hash_table-&gt;hashes[i] = UNUSED_HASH_VALUE;                    \</span>
<span class="line-added"> 770           continue;                                                     \</span>
<span class="line-added"> 771         }                                                               \</span>
<span class="line-added"> 772                                                                         \</span>
<span class="line-added"> 773       /* Skip entries relocated through eviction */                     \</span>
<span class="line-added"> 774       if (get_status_bit (reallocated_buckets_bitmap, i))               \</span>
<span class="line-added"> 775         continue;                                                       \</span>
<span class="line-added"> 776                                                                         \</span>
<span class="line-added"> 777       hash_table-&gt;hashes[i] = UNUSED_HASH_VALUE;                        \</span>
<span class="line-added"> 778       EVICT_KEYVAL (hash_table, i, NULL, NULL, key, value);             \</span>
<span class="line-added"> 779                                                                         \</span>
<span class="line-added"> 780       for (;;)                                                          \</span>
<span class="line-added"> 781         {                                                               \</span>
<span class="line-added"> 782           guint hash_val;                                               \</span>
<span class="line-added"> 783           guint replaced_hash;                                          \</span>
<span class="line-added"> 784           guint step = 0;                                               \</span>
<span class="line-added"> 785                                                                         \</span>
<span class="line-added"> 786           hash_val = g_hash_table_hash_to_index (hash_table, node_hash); \</span>
<span class="line-added"> 787                                                                         \</span>
<span class="line-added"> 788           while (get_status_bit (reallocated_buckets_bitmap, hash_val)) \</span>
<span class="line-added"> 789             {                                                           \</span>
<span class="line-added"> 790               step++;                                                   \</span>
<span class="line-added"> 791               hash_val += step;                                         \</span>
<span class="line-added"> 792               hash_val &amp;= hash_table-&gt;mask;                             \</span>
<span class="line-added"> 793             }                                                           \</span>
<span class="line-added"> 794                                                                         \</span>
<span class="line-added"> 795           set_status_bit (reallocated_buckets_bitmap, hash_val);        \</span>
<span class="line-added"> 796                                                                         \</span>
<span class="line-added"> 797           replaced_hash = hash_table-&gt;hashes[hash_val];                 \</span>
<span class="line-added"> 798           hash_table-&gt;hashes[hash_val] = node_hash;                     \</span>
<span class="line-added"> 799           if (!HASH_IS_REAL (replaced_hash))                            \</span>
<span class="line-added"> 800             {                                                           \</span>
<span class="line-added"> 801               ASSIGN_KEYVAL (hash_table, hash_val, key, value);         \</span>
<span class="line-added"> 802               break;                                                    \</span>
<span class="line-added"> 803             }                                                           \</span>
<span class="line-added"> 804                                                                         \</span>
<span class="line-added"> 805           node_hash = replaced_hash;                                    \</span>
<span class="line-added"> 806           EVICT_KEYVAL (hash_table, hash_val, key, value, key, value);  \</span>
<span class="line-added"> 807         }                                                               \</span>
<span class="line-added"> 808     }                                                                   \</span>
<span class="line-added"> 809 }</span>
<span class="line-added"> 810 </span>
<span class="line-added"> 811 #define ASSIGN_KEYVAL(ht, index, key, value) G_STMT_START{ \</span>
<span class="line-added"> 812     g_hash_table_assign_key_or_value ((ht)-&gt;keys, (index), (ht)-&gt;have_big_keys, (key)); \</span>
<span class="line-added"> 813     g_hash_table_assign_key_or_value ((ht)-&gt;values, (index), (ht)-&gt;have_big_values, (value)); \</span>
<span class="line-added"> 814   }G_STMT_END</span>
<span class="line-added"> 815 </span>
<span class="line-added"> 816 #define EVICT_KEYVAL(ht, index, key, value, outkey, outvalue) G_STMT_START{ \</span>
<span class="line-added"> 817     (outkey) = g_hash_table_evict_key_or_value ((ht)-&gt;keys, (index), (ht)-&gt;have_big_keys, (key)); \</span>
<span class="line-added"> 818     (outvalue) = g_hash_table_evict_key_or_value ((ht)-&gt;values, (index), (ht)-&gt;have_big_values, (value)); \</span>
<span class="line-added"> 819   }G_STMT_END</span>
<span class="line-added"> 820 </span>
<span class="line-added"> 821 DEFINE_RESIZE_FUNC (resize_map)</span>
<span class="line-added"> 822 </span>
<span class="line-added"> 823 #undef ASSIGN_KEYVAL</span>
<span class="line-added"> 824 #undef EVICT_KEYVAL</span>
<span class="line-added"> 825 </span>
<span class="line-added"> 826 #define ASSIGN_KEYVAL(ht, index, key, value) G_STMT_START{ \</span>
<span class="line-added"> 827     g_hash_table_assign_key_or_value ((ht)-&gt;keys, (index), (ht)-&gt;have_big_keys, (key)); \</span>
<span class="line-added"> 828   }G_STMT_END</span>
<span class="line-added"> 829 </span>
<span class="line-added"> 830 #define EVICT_KEYVAL(ht, index, key, value, outkey, outvalue) G_STMT_START{ \</span>
<span class="line-added"> 831     (outkey) = g_hash_table_evict_key_or_value ((ht)-&gt;keys, (index), (ht)-&gt;have_big_keys, (key)); \</span>
<span class="line-added"> 832   }G_STMT_END</span>
<span class="line-added"> 833 </span>
<span class="line-added"> 834 DEFINE_RESIZE_FUNC (resize_set)</span>
<span class="line-added"> 835 </span>
<span class="line-added"> 836 #undef ASSIGN_KEYVAL</span>
<span class="line-added"> 837 #undef EVICT_KEYVAL</span>
 838 
 839 /*
 840  * g_hash_table_resize:
 841  * @hash_table: our #GHashTable
 842  *
 843  * Resizes the hash table to the optimal size based on the number of
 844  * nodes currently held. If you call this function then a resize will
 845  * occur, even if one does not need to occur.
 846  * Use g_hash_table_maybe_resize() instead.
 847  *
 848  * This function may &quot;resize&quot; the hash table to its current size, with
 849  * the side effect of cleaning up tombstones and otherwise optimizing
 850  * the probe sequences.
 851  */
 852 static void
 853 g_hash_table_resize (GHashTable *hash_table)
 854 {
<span class="line-modified"> 855   guint32 *reallocated_buckets_bitmap;</span>
<span class="line-modified"> 856   gsize old_size;</span>
<span class="line-modified"> 857   gboolean is_a_set;</span>


 858 
 859   old_size = hash_table-&gt;size;
<span class="line-modified"> 860   is_a_set = hash_table-&gt;keys == hash_table-&gt;values;</span>













 861 
<span class="line-modified"> 862   /* The outer checks in g_hash_table_maybe_resize() will only consider</span>
<span class="line-modified"> 863    * cleanup/resize when the load factor goes below .25 (1/4, ignoring</span>
<span class="line-added"> 864    * tombstones) or above .9375 (15/16, including tombstones).</span>
<span class="line-added"> 865    *</span>
<span class="line-added"> 866    * Once this happens, tombstones will always be cleaned out. If our</span>
<span class="line-added"> 867    * load sans tombstones is greater than .75 (1/1.333, see below), we&#39;ll</span>
<span class="line-added"> 868    * take this opportunity to grow the table too.</span>
<span class="line-added"> 869    *</span>
<span class="line-added"> 870    * Immediately after growing, the load factor will be in the range</span>
<span class="line-added"> 871    * .375 .. .469. After shrinking, it will be exactly .5. */</span>
 872 
<span class="line-modified"> 873   g_hash_table_set_shift_from_size (hash_table, hash_table-&gt;nnodes * 1.333);</span>
 874 
<span class="line-modified"> 875   if (hash_table-&gt;size &gt; old_size)</span>
<span class="line-modified"> 876     {</span>
<span class="line-modified"> 877       realloc_arrays (hash_table, is_a_set);</span>
<span class="line-modified"> 878       memset (&amp;hash_table-&gt;hashes[old_size], 0, (hash_table-&gt;size - old_size) * sizeof (guint));</span>


 879 
<span class="line-modified"> 880       reallocated_buckets_bitmap = g_new0 (guint32, (hash_table-&gt;size + 31) / 32);</span>
<span class="line-modified"> 881     }</span>
<span class="line-modified"> 882   else</span>
<span class="line-added"> 883     {</span>
<span class="line-added"> 884       reallocated_buckets_bitmap = g_new0 (guint32, (old_size + 31) / 32);</span>
 885     }
 886 
<span class="line-modified"> 887   if (is_a_set)</span>
<span class="line-modified"> 888     resize_set (hash_table, old_size, reallocated_buckets_bitmap);</span>
<span class="line-added"> 889   else</span>
<span class="line-added"> 890     resize_map (hash_table, old_size, reallocated_buckets_bitmap);</span>
 891 
<span class="line-modified"> 892   g_free (reallocated_buckets_bitmap);</span>

 893 
<span class="line-modified"> 894   if (hash_table-&gt;size &lt; old_size)</span>
<span class="line-modified"> 895     realloc_arrays (hash_table, is_a_set);</span>

 896 
 897   hash_table-&gt;noccupied = hash_table-&gt;nnodes;
 898 }
 899 
 900 /*
 901  * g_hash_table_maybe_resize:
 902  * @hash_table: our #GHashTable
 903  *
 904  * Resizes the hash table, if needed.
 905  *
 906  * Essentially, calls g_hash_table_resize() if the table has strayed
 907  * too far from its ideal size for its number of nodes.
 908  */
 909 static inline void
 910 g_hash_table_maybe_resize (GHashTable *hash_table)
 911 {
 912   gint noccupied = hash_table-&gt;noccupied;
 913   gint size = hash_table-&gt;size;
 914 
 915   if ((size &gt; hash_table-&gt;nnodes * 4 &amp;&amp; size &gt; 1 &lt;&lt; HASH_TABLE_MIN_SHIFT) ||
 916       (size &lt;= noccupied + (noccupied / 16)))
 917     g_hash_table_resize (hash_table);
 918 }
 919 
<span class="line-added"> 920 #ifdef USE_SMALL_ARRAYS</span>
<span class="line-added"> 921 </span>
<span class="line-added"> 922 static inline gboolean</span>
<span class="line-added"> 923 entry_is_big (gpointer v)</span>
<span class="line-added"> 924 {</span>
<span class="line-added"> 925   return (((guintptr) v) &gt;&gt; ((BIG_ENTRY_SIZE - SMALL_ENTRY_SIZE) * 8)) != 0;</span>
<span class="line-added"> 926 }</span>
<span class="line-added"> 927 </span>
<span class="line-added"> 928 static inline gboolean</span>
<span class="line-added"> 929 g_hash_table_maybe_make_big_keys_or_values (gpointer *a_p, gpointer v, gint ht_size)</span>
<span class="line-added"> 930 {</span>
<span class="line-added"> 931   if (entry_is_big (v))</span>
<span class="line-added"> 932     {</span>
<span class="line-added"> 933       guint *a = (guint *) *a_p;</span>
<span class="line-added"> 934       gpointer *a_new;</span>
<span class="line-added"> 935       gint i;</span>
<span class="line-added"> 936 </span>
<span class="line-added"> 937       a_new = g_new (gpointer, ht_size);</span>
<span class="line-added"> 938 </span>
<span class="line-added"> 939       for (i = 0; i &lt; ht_size; i++)</span>
<span class="line-added"> 940         {</span>
<span class="line-added"> 941           a_new[i] = GUINT_TO_POINTER (a[i]);</span>
<span class="line-added"> 942         }</span>
<span class="line-added"> 943 </span>
<span class="line-added"> 944       g_free (a);</span>
<span class="line-added"> 945       *a_p = a_new;</span>
<span class="line-added"> 946       return TRUE;</span>
<span class="line-added"> 947     }</span>
<span class="line-added"> 948 </span>
<span class="line-added"> 949   return FALSE;</span>
<span class="line-added"> 950 }</span>
<span class="line-added"> 951 </span>
<span class="line-added"> 952 #endif</span>
<span class="line-added"> 953 </span>
<span class="line-added"> 954 static inline void</span>
<span class="line-added"> 955 g_hash_table_ensure_keyval_fits (GHashTable *hash_table, gpointer key, gpointer value)</span>
<span class="line-added"> 956 {</span>
<span class="line-added"> 957   gboolean is_a_set = (hash_table-&gt;keys == hash_table-&gt;values);</span>
<span class="line-added"> 958 </span>
<span class="line-added"> 959 #ifdef USE_SMALL_ARRAYS</span>
<span class="line-added"> 960 </span>
<span class="line-added"> 961   /* Convert from set to map? */</span>
<span class="line-added"> 962   if (is_a_set)</span>
<span class="line-added"> 963     {</span>
<span class="line-added"> 964       if (hash_table-&gt;have_big_keys)</span>
<span class="line-added"> 965         {</span>
<span class="line-added"> 966           if (key != value)</span>
<span class="line-added"> 967             hash_table-&gt;values = g_memdup (hash_table-&gt;keys, sizeof (gpointer) * hash_table-&gt;size);</span>
<span class="line-added"> 968           /* Keys and values are both big now, so no need for further checks */</span>
<span class="line-added"> 969           return;</span>
<span class="line-added"> 970         }</span>
<span class="line-added"> 971       else</span>
<span class="line-added"> 972         {</span>
<span class="line-added"> 973           if (key != value)</span>
<span class="line-added"> 974             {</span>
<span class="line-added"> 975               hash_table-&gt;values = g_memdup (hash_table-&gt;keys, sizeof (guint) * hash_table-&gt;size);</span>
<span class="line-added"> 976               is_a_set = FALSE;</span>
<span class="line-added"> 977             }</span>
<span class="line-added"> 978         }</span>
<span class="line-added"> 979     }</span>
<span class="line-added"> 980 </span>
<span class="line-added"> 981   /* Make keys big? */</span>
<span class="line-added"> 982   if (!hash_table-&gt;have_big_keys)</span>
<span class="line-added"> 983     {</span>
<span class="line-added"> 984       hash_table-&gt;have_big_keys = g_hash_table_maybe_make_big_keys_or_values (&amp;hash_table-&gt;keys, key, hash_table-&gt;size);</span>
<span class="line-added"> 985 </span>
<span class="line-added"> 986       if (is_a_set)</span>
<span class="line-added"> 987         {</span>
<span class="line-added"> 988           hash_table-&gt;values = hash_table-&gt;keys;</span>
<span class="line-added"> 989           hash_table-&gt;have_big_values = hash_table-&gt;have_big_keys;</span>
<span class="line-added"> 990         }</span>
<span class="line-added"> 991     }</span>
<span class="line-added"> 992 </span>
<span class="line-added"> 993   /* Make values big? */</span>
<span class="line-added"> 994   if (!is_a_set &amp;&amp; !hash_table-&gt;have_big_values)</span>
<span class="line-added"> 995     {</span>
<span class="line-added"> 996       hash_table-&gt;have_big_values = g_hash_table_maybe_make_big_keys_or_values (&amp;hash_table-&gt;values, value, hash_table-&gt;size);</span>
<span class="line-added"> 997     }</span>
<span class="line-added"> 998 </span>
<span class="line-added"> 999 #else</span>
<span class="line-added">1000 </span>
<span class="line-added">1001   /* Just split if necessary */</span>
<span class="line-added">1002   if (is_a_set &amp;&amp; key != value)</span>
<span class="line-added">1003     hash_table-&gt;values = g_memdup (hash_table-&gt;keys, sizeof (gpointer) * hash_table-&gt;size);</span>
<span class="line-added">1004 </span>
<span class="line-added">1005 #endif</span>
<span class="line-added">1006 }</span>
<span class="line-added">1007 </span>
1008 /**
1009  * g_hash_table_new:
1010  * @hash_func: a function to create a hash value from a key
1011  * @key_equal_func: a function to check two keys for equality
1012  *
1013  * Creates a new #GHashTable with a reference count of 1.
1014  *
1015  * Hash values returned by @hash_func are used to determine where keys
1016  * are stored within the #GHashTable data structure. The g_direct_hash(),
1017  * g_int_hash(), g_int64_hash(), g_double_hash() and g_str_hash()
1018  * functions are provided for some common types of keys.
1019  * If @hash_func is %NULL, g_direct_hash() is used.
1020  *
1021  * @key_equal_func is used when looking up keys in the #GHashTable.
1022  * The g_direct_equal(), g_int_equal(), g_int64_equal(), g_double_equal()
1023  * and g_str_equal() functions are provided for the most common types
1024  * of keys. If @key_equal_func is %NULL, keys are compared directly in
1025  * a similar fashion to g_direct_equal(), but without the overhead of
1026  * a function call. @key_equal_func is called with the key from the hash table
1027  * as its first parameter, and the user-provided key to check against as
</pre>
<hr />
<pre>
1059  * This means that you may need to ensure that the hash table is empty by
1060  * calling g_hash_table_remove_all() before releasing the last reference using
1061  * g_hash_table_unref().
1062  *
1063  * Returns: a new #GHashTable
1064  */
1065 GHashTable *
1066 g_hash_table_new_full (GHashFunc      hash_func,
1067                        GEqualFunc     key_equal_func,
1068                        GDestroyNotify key_destroy_func,
1069                        GDestroyNotify value_destroy_func)
1070 {
1071   GHashTable *hash_table;
1072 
1073   hash_table = g_slice_new (GHashTable);
1074 #ifdef GSTREAMER_LITE
1075   if (hash_table == NULL) {
1076     return NULL;
1077   }
1078 #endif // GSTREAMER_LITE

1079   g_atomic_ref_count_init (&amp;hash_table-&gt;ref_count);
1080   hash_table-&gt;nnodes             = 0;
1081   hash_table-&gt;noccupied          = 0;
1082   hash_table-&gt;hash_func          = hash_func ? hash_func : g_direct_hash;
1083   hash_table-&gt;key_equal_func     = key_equal_func;
1084 #ifndef G_DISABLE_ASSERT
1085   hash_table-&gt;version            = 0;
1086 #endif
1087   hash_table-&gt;key_destroy_func   = key_destroy_func;
1088   hash_table-&gt;value_destroy_func = value_destroy_func;
<span class="line-modified">1089 </span>
<span class="line-modified">1090   g_hash_table_setup_storage (hash_table);</span>

1091 
1092   return hash_table;
1093 }
1094 
1095 /**
1096  * g_hash_table_iter_init:
1097  * @iter: an uninitialized #GHashTableIter
1098  * @hash_table: a #GHashTable
1099  *
1100  * Initializes a key/value pair iterator and associates it with
1101  * @hash_table. Modifying the hash table after calling this function
1102  * invalidates the returned iterator.
1103  * |[&lt;!-- language=&quot;C&quot; --&gt;
1104  * GHashTableIter iter;
1105  * gpointer key, value;
1106  *
1107  * g_hash_table_iter_init (&amp;iter, hash_table);
1108  * while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
1109  *   {
1110  *     // do something with key and value
</pre>
<hr />
<pre>
1138  * Advances @iter and retrieves the key and/or value that are now
1139  * pointed to as a result of this advancement. If %FALSE is returned,
1140  * @key and @value are not set, and the iterator becomes invalid.
1141  *
1142  * Returns: %FALSE if the end of the #GHashTable has been reached.
1143  *
1144  * Since: 2.16
1145  */
1146 gboolean
1147 g_hash_table_iter_next (GHashTableIter *iter,
1148                         gpointer       *key,
1149                         gpointer       *value)
1150 {
1151   RealIter *ri = (RealIter *) iter;
1152   gint position;
1153 
1154   g_return_val_if_fail (iter != NULL, FALSE);
1155 #ifndef G_DISABLE_ASSERT
1156   g_return_val_if_fail (ri-&gt;version == ri-&gt;hash_table-&gt;version, FALSE);
1157 #endif
<span class="line-modified">1158   g_return_val_if_fail (ri-&gt;position &lt; (gssize) ri-&gt;hash_table-&gt;size, FALSE);</span>
1159 
1160   position = ri-&gt;position;
1161 
1162   do
1163     {
1164       position++;
<span class="line-modified">1165       if (position &gt;= (gssize) ri-&gt;hash_table-&gt;size)</span>
1166         {
1167           ri-&gt;position = position;
1168           return FALSE;
1169         }
1170     }
1171   while (!HASH_IS_REAL (ri-&gt;hash_table-&gt;hashes[position]));
1172 
1173   if (key != NULL)
<span class="line-modified">1174     *key = g_hash_table_fetch_key_or_value (ri-&gt;hash_table-&gt;keys, position, ri-&gt;hash_table-&gt;have_big_keys);</span>
1175   if (value != NULL)
<span class="line-modified">1176     *value = g_hash_table_fetch_key_or_value (ri-&gt;hash_table-&gt;values, position, ri-&gt;hash_table-&gt;have_big_values);</span>
1177 
1178   ri-&gt;position = position;
1179   return TRUE;
1180 }
1181 
1182 /**
1183  * g_hash_table_iter_get_hash_table:
1184  * @iter: an initialized #GHashTableIter
1185  *
1186  * Returns the #GHashTable associated with @iter.
1187  *
1188  * Returns: the #GHashTable associated with @iter.
1189  *
1190  * Since: 2.16
1191  */
1192 GHashTable *
1193 g_hash_table_iter_get_hash_table (GHashTableIter *iter)
1194 {
1195   g_return_val_if_fail (iter != NULL, NULL);
1196 
1197   return ((RealIter *) iter)-&gt;hash_table;
1198 }
1199 
1200 static void
1201 iter_remove_or_steal (RealIter *ri, gboolean notify)
1202 {
1203   g_return_if_fail (ri != NULL);
1204 #ifndef G_DISABLE_ASSERT
1205   g_return_if_fail (ri-&gt;version == ri-&gt;hash_table-&gt;version);
1206 #endif
1207   g_return_if_fail (ri-&gt;position &gt;= 0);
<span class="line-modified">1208   g_return_if_fail ((gsize) ri-&gt;position &lt; ri-&gt;hash_table-&gt;size);</span>
1209 
1210   g_hash_table_remove_node (ri-&gt;hash_table, ri-&gt;position, notify);
1211 
1212 #ifndef G_DISABLE_ASSERT
1213   ri-&gt;version++;
1214   ri-&gt;hash_table-&gt;version++;
1215 #endif
1216 }
1217 
1218 /**
1219  * g_hash_table_iter_remove:
1220  * @iter: an initialized #GHashTableIter
1221  *
1222  * Removes the key/value pair currently pointed to by the iterator
1223  * from its associated #GHashTable. Can only be called after
1224  * g_hash_table_iter_next() returned %TRUE, and cannot be called
1225  * more than once for the same key/value pair.
1226  *
1227  * If the #GHashTable was created using g_hash_table_new_full(),
1228  * the key and value are freed using the supplied destroy functions,
</pre>
<hr />
<pre>
1259  * Inserts a value at @node_index in the hash table and updates it.
1260  *
1261  * If @key has been taken out of the existing node (ie it is not
1262  * passed in via a g_hash_table_insert/replace) call, then @reusing_key
1263  * should be %TRUE.
1264  *
1265  * Returns: %TRUE if the key did not exist yet
1266  */
1267 static gboolean
1268 g_hash_table_insert_node (GHashTable *hash_table,
1269                           guint       node_index,
1270                           guint       key_hash,
1271                           gpointer    new_key,
1272                           gpointer    new_value,
1273                           gboolean    keep_new_key,
1274                           gboolean    reusing_key)
1275 {
1276   gboolean already_exists;
1277   guint old_hash;
1278   gpointer key_to_free = NULL;
<span class="line-added">1279   gpointer key_to_keep = NULL;</span>
1280   gpointer value_to_free = NULL;
1281 
1282   old_hash = hash_table-&gt;hashes[node_index];
1283   already_exists = HASH_IS_REAL (old_hash);
1284 
1285   /* Proceed in three steps.  First, deal with the key because it is the
1286    * most complicated.  Then consider if we need to split the table in
1287    * two (because writing the value will result in the set invariant
1288    * becoming broken).  Then deal with the value.
1289    *
1290    * There are three cases for the key:
1291    *
1292    *  - entry already exists in table, reusing key:
1293    *    free the just-passed-in new_key and use the existing value
1294    *
1295    *  - entry already exists in table, not reusing key:
1296    *    free the entry in the table, use the new key
1297    *
1298    *  - entry not already in table:
1299    *    use the new key, free nothing
1300    *
1301    * We update the hash at the same time...
1302    */
1303   if (already_exists)
1304     {
1305       /* Note: we must record the old value before writing the new key
1306        * because we might change the value in the event that the two
1307        * arrays are shared.
1308        */
<span class="line-modified">1309       value_to_free = g_hash_table_fetch_key_or_value (hash_table-&gt;values, node_index, hash_table-&gt;have_big_values);</span>
1310 
1311       if (keep_new_key)
1312         {
<span class="line-modified">1313           key_to_free = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys);</span>
<span class="line-modified">1314           key_to_keep = new_key;</span>
1315         }
1316       else
<span class="line-modified">1317         {</span>
<span class="line-added">1318           key_to_free = new_key;</span>
<span class="line-added">1319           key_to_keep = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys);</span>
<span class="line-added">1320         }</span>
1321     }
1322   else
1323     {
1324       hash_table-&gt;hashes[node_index] = key_hash;
<span class="line-modified">1325       key_to_keep = new_key;</span>
1326     }
1327 
<span class="line-modified">1328   /* Resize key/value arrays and split table as necessary */</span>
<span class="line-modified">1329   g_hash_table_ensure_keyval_fits (hash_table, key_to_keep, new_value);</span>
<span class="line-modified">1330   g_hash_table_assign_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys, key_to_keep);</span>



1331 
1332   /* Step 3: Actually do the write */
<span class="line-modified">1333   g_hash_table_assign_key_or_value (hash_table-&gt;values, node_index, hash_table-&gt;have_big_values, new_value);</span>
1334 
1335   /* Now, the bookkeeping... */
1336   if (!already_exists)
1337     {
1338       hash_table-&gt;nnodes++;
1339 
1340       if (HASH_IS_UNUSED (old_hash))
1341         {
1342           /* We replaced an empty node, and not a tombstone */
1343           hash_table-&gt;noccupied++;
1344           g_hash_table_maybe_resize (hash_table);
1345         }
1346 
1347 #ifndef G_DISABLE_ASSERT
1348       hash_table-&gt;version++;
1349 #endif
1350     }
1351 
1352   if (already_exists)
1353     {
</pre>
<hr />
<pre>
1372  * If you supplied a @value_destroy_func when creating the
1373  * #GHashTable, the old value is freed using that function.
1374  *
1375  * Since: 2.30
1376  */
1377 void
1378 g_hash_table_iter_replace (GHashTableIter *iter,
1379                            gpointer        value)
1380 {
1381   RealIter *ri;
1382   guint node_hash;
1383   gpointer key;
1384 
1385   ri = (RealIter *) iter;
1386 
1387   g_return_if_fail (ri != NULL);
1388 #ifndef G_DISABLE_ASSERT
1389   g_return_if_fail (ri-&gt;version == ri-&gt;hash_table-&gt;version);
1390 #endif
1391   g_return_if_fail (ri-&gt;position &gt;= 0);
<span class="line-modified">1392   g_return_if_fail ((gsize) ri-&gt;position &lt; ri-&gt;hash_table-&gt;size);</span>
1393 
1394   node_hash = ri-&gt;hash_table-&gt;hashes[ri-&gt;position];
<span class="line-modified">1395 </span>
<span class="line-added">1396   key = g_hash_table_fetch_key_or_value (ri-&gt;hash_table-&gt;keys, ri-&gt;position, ri-&gt;hash_table-&gt;have_big_keys);</span>
1397 
1398   g_hash_table_insert_node (ri-&gt;hash_table, ri-&gt;position, node_hash, key, value, TRUE, TRUE);
1399 
1400 #ifndef G_DISABLE_ASSERT
1401   ri-&gt;version++;
1402   ri-&gt;hash_table-&gt;version++;
1403 #endif
1404 }
1405 
1406 /**
1407  * g_hash_table_iter_steal:
1408  * @iter: an initialized #GHashTableIter
1409  *
1410  * Removes the key/value pair currently pointed to by the
1411  * iterator from its associated #GHashTable, without calling
1412  * the key and value destroy functions. Can only be called
1413  * after g_hash_table_iter_next() returned %TRUE, and cannot
1414  * be called more than once for the same key/value pair.
1415  *
1416  * Since: 2.16
</pre>
<hr />
<pre>
1497  *
1498  * Looks up a key in a #GHashTable. Note that this function cannot
1499  * distinguish between a key that is not present and one which is present
1500  * and has the value %NULL. If you need this distinction, use
1501  * g_hash_table_lookup_extended().
1502  *
1503  * Returns: (nullable): the associated value, or %NULL if the key is not found
1504  */
1505 gpointer
1506 g_hash_table_lookup (GHashTable    *hash_table,
1507                      gconstpointer  key)
1508 {
1509   guint node_index;
1510   guint node_hash;
1511 
1512   g_return_val_if_fail (hash_table != NULL, NULL);
1513 
1514   node_index = g_hash_table_lookup_node (hash_table, key, &amp;node_hash);
1515 
1516   return HASH_IS_REAL (hash_table-&gt;hashes[node_index])
<span class="line-modified">1517     ? g_hash_table_fetch_key_or_value (hash_table-&gt;values, node_index, hash_table-&gt;have_big_values)</span>
1518     : NULL;
1519 }
1520 
1521 /**
1522  * g_hash_table_lookup_extended:
1523  * @hash_table: a #GHashTable
1524  * @lookup_key: the key to look up
1525  * @orig_key: (out) (optional): return location for the original key
1526  * @value: (out) (optional) (nullable): return location for the value associated
1527  * with the key
1528  *
1529  * Looks up a key in the #GHashTable, returning the original key and the
1530  * associated value and a #gboolean which is %TRUE if the key was found. This
1531  * is useful if you need to free the memory allocated for the original key,
1532  * for example before calling g_hash_table_remove().
1533  *
1534  * You can actually pass %NULL for @lookup_key to test
1535  * whether the %NULL key exists, provided the hash and equal functions
1536  * of @hash_table are %NULL-safe.
1537  *
1538  * Returns: %TRUE if the key was found in the #GHashTable
1539  */
1540 gboolean
1541 g_hash_table_lookup_extended (GHashTable    *hash_table,
1542                               gconstpointer  lookup_key,
1543                               gpointer      *orig_key,
1544                               gpointer      *value)
1545 {
1546   guint node_index;
1547   guint node_hash;
1548 
1549   g_return_val_if_fail (hash_table != NULL, FALSE);
1550 
1551   node_index = g_hash_table_lookup_node (hash_table, lookup_key, &amp;node_hash);
1552 
1553   if (!HASH_IS_REAL (hash_table-&gt;hashes[node_index]))
<span class="line-modified">1554     {</span>
<span class="line-added">1555       if (orig_key != NULL)</span>
<span class="line-added">1556         *orig_key = NULL;</span>
<span class="line-added">1557       if (value != NULL)</span>
<span class="line-added">1558         *value = NULL;</span>
<span class="line-added">1559 </span>
<span class="line-added">1560       return FALSE;</span>
<span class="line-added">1561     }</span>
1562 
1563   if (orig_key)
<span class="line-modified">1564     *orig_key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys);</span>
1565 
1566   if (value)
<span class="line-modified">1567     *value = g_hash_table_fetch_key_or_value (hash_table-&gt;values, node_index, hash_table-&gt;have_big_values);</span>
1568 
1569   return TRUE;
1570 }
1571 
1572 /*
1573  * g_hash_table_insert_internal:
1574  * @hash_table: our #GHashTable
1575  * @key: the key to insert
1576  * @value: the value to insert
1577  * @keep_new_key: if %TRUE and this key already exists in the table
1578  *   then call the destroy notify function on the old key.  If %FALSE
1579  *   then call the destroy notify function on the new key.
1580  *
1581  * Implements the common logic for the g_hash_table_insert() and
1582  * g_hash_table_replace() functions.
1583  *
1584  * Do a lookup of @key. If it is found, replace it with the new
1585  * @value (and perhaps the new @key). If it is not found, create
1586  * a new node.
1587  *
</pre>
<hr />
<pre>
1818                              gpointer      *stolen_key,
1819                              gpointer      *stolen_value)
1820 {
1821   guint node_index;
1822   guint node_hash;
1823 
1824   g_return_val_if_fail (hash_table != NULL, FALSE);
1825 
1826   node_index = g_hash_table_lookup_node (hash_table, lookup_key, &amp;node_hash);
1827 
1828   if (!HASH_IS_REAL (hash_table-&gt;hashes[node_index]))
1829     {
1830       if (stolen_key != NULL)
1831         *stolen_key = NULL;
1832       if (stolen_value != NULL)
1833         *stolen_value = NULL;
1834       return FALSE;
1835     }
1836 
1837   if (stolen_key != NULL)
<span class="line-modified">1838   {</span>
<span class="line-added">1839     *stolen_key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys);</span>
<span class="line-added">1840     g_hash_table_assign_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys, NULL);</span>
<span class="line-added">1841   }</span>
1842 
1843   if (stolen_value != NULL)
<span class="line-modified">1844   {</span>
<span class="line-added">1845     *stolen_value = g_hash_table_fetch_key_or_value (hash_table-&gt;values, node_index, hash_table-&gt;have_big_values);</span>
<span class="line-added">1846     g_hash_table_assign_key_or_value (hash_table-&gt;values, node_index, hash_table-&gt;have_big_values, NULL);</span>
<span class="line-added">1847   }</span>
1848 
1849   g_hash_table_remove_node (hash_table, node_index, FALSE);
1850   g_hash_table_maybe_resize (hash_table);
1851 
1852 #ifndef G_DISABLE_ASSERT
1853   hash_table-&gt;version++;
1854 #endif
1855 
1856   return TRUE;
1857 }
1858 
1859 /**
1860  * g_hash_table_remove_all:
1861  * @hash_table: a #GHashTable
1862  *
1863  * Removes all keys and their associated values from a #GHashTable.
1864  *
1865  * If the #GHashTable was created using g_hash_table_new_full(),
1866  * the keys and values are freed using the supplied destroy functions,
1867  * otherwise you have to make sure that any dynamically allocated
</pre>
<hr />
<pre>
1913  * @user_data: data for @func
1914  * @notify: %TRUE if the destroy notify handlers are to be called
1915  *
1916  * Implements the common logic for g_hash_table_foreach_remove()
1917  * and g_hash_table_foreach_steal().
1918  *
1919  * Iterates over every node in the table, calling @func with the key
1920  * and value of the node (and @user_data). If @func returns %TRUE the
1921  * node is removed from the table.
1922  *
1923  * If @notify is true then the destroy notify handlers will be called
1924  * for each removed node.
1925  */
1926 static guint
1927 g_hash_table_foreach_remove_or_steal (GHashTable *hash_table,
1928                                       GHRFunc     func,
1929                                       gpointer    user_data,
1930                                       gboolean    notify)
1931 {
1932   guint deleted = 0;
<span class="line-modified">1933   gsize i;</span>
1934 #ifndef G_DISABLE_ASSERT
1935   gint version = hash_table-&gt;version;
1936 #endif
1937 
1938   for (i = 0; i &lt; hash_table-&gt;size; i++)
1939     {
1940       guint node_hash = hash_table-&gt;hashes[i];
<span class="line-modified">1941       gpointer node_key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys);</span>
<span class="line-modified">1942       gpointer node_value = g_hash_table_fetch_key_or_value (hash_table-&gt;values, i, hash_table-&gt;have_big_values);</span>
1943 
1944       if (HASH_IS_REAL (node_hash) &amp;&amp;
1945           (* func) (node_key, node_value, user_data))
1946         {
1947           g_hash_table_remove_node (hash_table, i, notify);
1948           deleted++;
1949         }
1950 
1951 #ifndef G_DISABLE_ASSERT
1952       g_return_val_if_fail (version == hash_table-&gt;version, 0);
1953 #endif
1954     }
1955 
1956   g_hash_table_maybe_resize (hash_table);
1957 
1958 #ifndef G_DISABLE_ASSERT
1959   if (deleted &gt; 0)
1960     hash_table-&gt;version++;
1961 #endif
1962 
</pre>
<hr />
<pre>
2022  * g_hash_table_foreach:
2023  * @hash_table: a #GHashTable
2024  * @func: the function to call for each key/value pair
2025  * @user_data: user data to pass to the function
2026  *
2027  * Calls the given function for each of the key/value pairs in the
2028  * #GHashTable.  The function is passed the key and value of each
2029  * pair, and the given @user_data parameter.  The hash table may not
2030  * be modified while iterating over it (you can&#39;t add/remove
2031  * items). To remove all items matching a predicate, use
2032  * g_hash_table_foreach_remove().
2033  *
2034  * See g_hash_table_find() for performance caveats for linear
2035  * order searches in contrast to g_hash_table_lookup().
2036  */
2037 void
2038 g_hash_table_foreach (GHashTable *hash_table,
2039                       GHFunc      func,
2040                       gpointer    user_data)
2041 {
<span class="line-modified">2042   gsize i;</span>
2043 #ifndef G_DISABLE_ASSERT
2044   gint version;
2045 #endif
2046 
2047   g_return_if_fail (hash_table != NULL);
2048   g_return_if_fail (func != NULL);
2049 
2050 #ifndef G_DISABLE_ASSERT
2051   version = hash_table-&gt;version;
2052 #endif
2053 
2054   for (i = 0; i &lt; hash_table-&gt;size; i++)
2055     {
2056       guint node_hash = hash_table-&gt;hashes[i];
<span class="line-modified">2057       gpointer node_key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys);</span>
<span class="line-modified">2058       gpointer node_value = g_hash_table_fetch_key_or_value (hash_table-&gt;values, i, hash_table-&gt;have_big_values);</span>
2059 
2060       if (HASH_IS_REAL (node_hash))
2061         (* func) (node_key, node_value, user_data);
2062 
2063 #ifndef G_DISABLE_ASSERT
2064       g_return_if_fail (version == hash_table-&gt;version);
2065 #endif
2066     }
2067 }
2068 
2069 /**
2070  * g_hash_table_find:
2071  * @hash_table: a #GHashTable
2072  * @predicate: function to test the key/value pairs for a certain property
2073  * @user_data: user data to pass to the function
2074  *
2075  * Calls the given function for key/value pairs in the #GHashTable
2076  * until @predicate returns %TRUE. The function is passed the key
2077  * and value of each pair, and the given @user_data parameter. The
2078  * hash table may not be modified while iterating over it (you can&#39;t
</pre>
<hr />
<pre>
2080  *
2081  * Note, that hash tables are really only optimized for forward
2082  * lookups, i.e. g_hash_table_lookup(). So code that frequently issues
2083  * g_hash_table_find() or g_hash_table_foreach() (e.g. in the order of
2084  * once per every entry in a hash table) should probably be reworked
2085  * to use additional or different data structures for reverse lookups
2086  * (keep in mind that an O(n) find/foreach operation issued for all n
2087  * values in a hash table ends up needing O(n*n) operations).
2088  *
2089  * Returns: (nullable): The value of the first key/value pair is returned,
2090  *     for which @predicate evaluates to %TRUE. If no pair with the
2091  *     requested property is found, %NULL is returned.
2092  *
2093  * Since: 2.4
2094  */
2095 gpointer
2096 g_hash_table_find (GHashTable *hash_table,
2097                    GHRFunc     predicate,
2098                    gpointer    user_data)
2099 {
<span class="line-modified">2100   gsize i;</span>
2101 #ifndef G_DISABLE_ASSERT
2102   gint version;
2103 #endif
2104   gboolean match;
2105 
2106   g_return_val_if_fail (hash_table != NULL, NULL);
2107   g_return_val_if_fail (predicate != NULL, NULL);
2108 
2109 #ifndef G_DISABLE_ASSERT
2110   version = hash_table-&gt;version;
2111 #endif
2112 
2113   match = FALSE;
2114 
2115   for (i = 0; i &lt; hash_table-&gt;size; i++)
2116     {
2117       guint node_hash = hash_table-&gt;hashes[i];
<span class="line-modified">2118       gpointer node_key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys);</span>
<span class="line-modified">2119       gpointer node_value = g_hash_table_fetch_key_or_value (hash_table-&gt;values, i, hash_table-&gt;have_big_values);</span>
2120 
2121       if (HASH_IS_REAL (node_hash))
2122         match = predicate (node_key, node_value, user_data);
2123 
2124 #ifndef G_DISABLE_ASSERT
2125       g_return_val_if_fail (version == hash_table-&gt;version, NULL);
2126 #endif
2127 
2128       if (match)
2129         return node_value;
2130     }
2131 
2132   return NULL;
2133 }
2134 
2135 /**
2136  * g_hash_table_size:
2137  * @hash_table: a #GHashTable
2138  *
2139  * Returns the number of elements contained in the #GHashTable.
</pre>
<hr />
<pre>
2152  * g_hash_table_get_keys:
2153  * @hash_table: a #GHashTable
2154  *
2155  * Retrieves every key inside @hash_table. The returned data is valid
2156  * until changes to the hash release those keys.
2157  *
2158  * This iterates over every entry in the hash table to build its return value.
2159  * To iterate over the entries in a #GHashTable more efficiently, use a
2160  * #GHashTableIter.
2161  *
2162  * Returns: (transfer container): a #GList containing all the keys
2163  *     inside the hash table. The content of the list is owned by the
2164  *     hash table and should not be modified or freed. Use g_list_free()
2165  *     when done using the list.
2166  *
2167  * Since: 2.14
2168  */
2169 GList *
2170 g_hash_table_get_keys (GHashTable *hash_table)
2171 {
<span class="line-modified">2172   gsize i;</span>
2173   GList *retval;
2174 
2175   g_return_val_if_fail (hash_table != NULL, NULL);
2176 
2177   retval = NULL;
2178   for (i = 0; i &lt; hash_table-&gt;size; i++)
2179     {
2180       if (HASH_IS_REAL (hash_table-&gt;hashes[i]))
<span class="line-modified">2181         retval = g_list_prepend (retval, g_hash_table_fetch_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys));</span>
2182     }
2183 
2184   return retval;
2185 }
2186 
2187 /**
2188  * g_hash_table_get_keys_as_array:
2189  * @hash_table: a #GHashTable
2190  * @length: (out): the length of the returned array
2191  *
2192  * Retrieves every key inside @hash_table, as an array.
2193  *
2194  * The returned array is %NULL-terminated but may contain %NULL as a
2195  * key.  Use @length to determine the true length if it&#39;s possible that
2196  * %NULL was used as the value for a key.
2197  *
2198  * Note: in the common case of a string-keyed #GHashTable, the return
2199  * value of this function can be conveniently cast to (const gchar **).
2200  *
2201  * This iterates over every entry in the hash table to build its return value.
2202  * To iterate over the entries in a #GHashTable more efficiently, use a
2203  * #GHashTableIter.
2204  *
2205  * You should always free the return result with g_free().  In the
2206  * above-mentioned case of a string-keyed hash table, it may be
2207  * appropriate to use g_strfreev() if you call g_hash_table_steal_all()
2208  * first to transfer ownership of the keys.
2209  *
2210  * Returns: (array length=length) (transfer container): a
2211  *   %NULL-terminated array containing each key from the table.
2212  *
2213  * Since: 2.40
2214  **/
2215 gpointer *
2216 g_hash_table_get_keys_as_array (GHashTable *hash_table,
2217                                 guint      *length)
2218 {
2219   gpointer *result;
<span class="line-modified">2220   gsize i, j = 0;</span>
2221 
2222   result = g_new (gpointer, hash_table-&gt;nnodes + 1);
2223   for (i = 0; i &lt; hash_table-&gt;size; i++)
2224     {
2225       if (HASH_IS_REAL (hash_table-&gt;hashes[i]))
<span class="line-modified">2226         result[j++] = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys);</span>
2227     }
2228   g_assert_cmpint (j, ==, hash_table-&gt;nnodes);
2229   result[j] = NULL;
2230 
2231   if (length)
2232     *length = j;
2233 
2234   return result;
2235 }
2236 
2237 /**
2238  * g_hash_table_get_values:
2239  * @hash_table: a #GHashTable
2240  *
2241  * Retrieves every value inside @hash_table. The returned data
2242  * is valid until @hash_table is modified.
2243  *
2244  * This iterates over every entry in the hash table to build its return value.
2245  * To iterate over the entries in a #GHashTable more efficiently, use a
2246  * #GHashTableIter.
2247  *
2248  * Returns: (transfer container): a #GList containing all the values
2249  *     inside the hash table. The content of the list is owned by the
2250  *     hash table and should not be modified or freed. Use g_list_free()
2251  *     when done using the list.
2252  *
2253  * Since: 2.14
2254  */
2255 GList *
2256 g_hash_table_get_values (GHashTable *hash_table)
2257 {
<span class="line-modified">2258   gsize i;</span>
2259   GList *retval;
2260 
2261   g_return_val_if_fail (hash_table != NULL, NULL);
2262 
2263   retval = NULL;
2264   for (i = 0; i &lt; hash_table-&gt;size; i++)
2265     {
2266       if (HASH_IS_REAL (hash_table-&gt;hashes[i]))
<span class="line-modified">2267         retval = g_list_prepend (retval, g_hash_table_fetch_key_or_value (hash_table-&gt;values, i, hash_table-&gt;have_big_values));</span>
2268     }
2269 
2270   return retval;
2271 }
2272 
2273 /* Hash functions.
2274  */
2275 
2276 /**
2277  * g_str_equal:
2278  * @v1: (not nullable): a key
2279  * @v2: (not nullable): a key to compare with @v1
2280  *
2281  * Compares two strings for byte-by-byte equality and returns %TRUE
2282  * if they are equal. It can be passed to g_hash_table_new() as the
2283  * @key_equal_func parameter, when using non-%NULL strings as keys in a
2284  * #GHashTable.
2285  *
2286  * This function is typically used for hash table comparisons, but can be used
2287  * for general purpose comparisons of non-%NULL strings. For a %NULL-safe string
</pre>
</td>
</tr>
</table>
<center><a href="ggettext.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ghash.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>