<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstallocator.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* GStreamer
  2  * Copyright (C) 2011 Wim Taymans &lt;wim.taymans@gmail.be&gt;
  3  *
  4  * gstallocator.c: memory block allocator
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public
 17  * License along with this library; if not, write to the
 18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 /**
 23  * SECTION:gstallocator
 24  * @title: GstAllocator
 25  * @short_description: allocate memory blocks
 26  * @see_also: #GstMemory
 27  *
 28  * Memory is usually created by allocators with a gst_allocator_alloc()
 29  * method call. When %NULL is used as the allocator, the default allocator will
 30  * be used.
 31  *
 32  * New allocators can be registered with gst_allocator_register().
 33  * Allocators are identified by name and can be retrieved with
 34  * gst_allocator_find(). gst_allocator_set_default() can be used to change the
 35  * default allocator.
 36  *
 37  * New memory can be created with gst_memory_new_wrapped() that wraps the memory
 38  * allocated elsewhere.
 39  */
 40 
 41 #ifdef HAVE_CONFIG_H
 42 #include &quot;config.h&quot;
 43 #endif
 44 
 45 #include &quot;gst_private.h&quot;
 46 #include &quot;gstmemory.h&quot;
 47 
 48 GST_DEBUG_CATEGORY_STATIC (gst_allocator_debug);
 49 #define GST_CAT_DEFAULT gst_allocator_debug
 50 
<a name="1" id="anc1"></a><span class="line-removed"> 51 #define GST_ALLOCATOR_GET_PRIVATE(obj)  \</span>
<span class="line-removed"> 52      (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_ALLOCATOR, GstAllocatorPrivate))</span>
<span class="line-removed"> 53 </span>
 54 struct _GstAllocatorPrivate
 55 {
 56   gpointer dummy;
 57 };
 58 
 59 #ifdef GSTREAMER_LITE
 60 // In GStLite we require to have memory aligned to 16 bytes for RAW video.
 61 // For now lets have all memory 16 bytes aligned.
 62 gsize gst_memory_alignment = 15;
 63 #else // GSTREAMER_LITE
 64 #if defined(MEMORY_ALIGNMENT_MALLOC)
 65 gsize gst_memory_alignment = 7;
 66 #elif defined(MEMORY_ALIGNMENT_PAGESIZE)
 67 /* we fill this in in the _init method */
 68 gsize gst_memory_alignment = 0;
 69 #elif defined(MEMORY_ALIGNMENT)
 70 gsize gst_memory_alignment = MEMORY_ALIGNMENT - 1;
 71 #else
 72 #error &quot;No memory alignment configured&quot;
 73 gsize gst_memory_alignment = 0;
 74 #endif
 75 #endif // GSTREAMER_LITE
 76 
 77 /* the default allocator */
 78 static GstAllocator *_default_allocator;
 79 
 80 static GstAllocator *_sysmem_allocator;
 81 
 82 /* registered allocators */
 83 static GRWLock lock;
 84 static GHashTable *allocators;
 85 
<a name="2" id="anc2"></a><span class="line-modified"> 86 G_DEFINE_ABSTRACT_TYPE (GstAllocator, gst_allocator, GST_TYPE_OBJECT);</span>

 87 
 88 static void
 89 gst_allocator_class_init (GstAllocatorClass * klass)
 90 {
<a name="3" id="anc3"></a><span class="line-removed"> 91   g_type_class_add_private (klass, sizeof (GstAllocatorPrivate));</span>
<span class="line-removed"> 92 </span>
 93   GST_DEBUG_CATEGORY_INIT (gst_allocator_debug, &quot;allocator&quot;, 0,
 94       &quot;allocator debug&quot;);
 95 }
 96 
 97 static GstMemory *
 98 _fallback_mem_copy (GstMemory * mem, gssize offset, gssize size)
 99 {
100   GstMemory *copy;
101   GstMapInfo sinfo, dinfo;
102   GstAllocationParams params = { 0, mem-&gt;align, 0, 0, };
103   GstAllocator *allocator;
104 
105   if (!gst_memory_map (mem, &amp;sinfo, GST_MAP_READ))
106     return NULL;
107 
108   if (size == -1)
109     size = sinfo.size &gt; offset ? sinfo.size - offset : 0;
110 
111   /* use the same allocator as the memory we copy  */
112   allocator = mem-&gt;allocator;
113   if (GST_OBJECT_FLAG_IS_SET (allocator, GST_ALLOCATOR_FLAG_CUSTOM_ALLOC))
114     allocator = NULL;
115   copy = gst_allocator_alloc (allocator, size, &amp;params);
116 
117   if (!gst_memory_map (copy, &amp;dinfo, GST_MAP_WRITE)) {
118     GST_CAT_WARNING (GST_CAT_MEMORY, &quot;could not write map memory %p&quot;, copy);
119     gst_allocator_free (mem-&gt;allocator, copy);
120     gst_memory_unmap (mem, &amp;sinfo);
121     return NULL;
122   }
123 
124   GST_CAT_DEBUG (GST_CAT_PERFORMANCE,
125       &quot;memcpy %&quot; G_GSSIZE_FORMAT &quot; memory %p -&gt; %p&quot;, size, mem, copy);
126   memcpy (dinfo.data, sinfo.data + offset, size);
127   gst_memory_unmap (copy, &amp;dinfo);
128   gst_memory_unmap (mem, &amp;sinfo);
129 
130   return copy;
131 }
132 
133 static gboolean
134 _fallback_mem_is_span (GstMemory * mem1, GstMemory * mem2, gsize * offset)
135 {
136   return FALSE;
137 }
138 
139 static void
140 gst_allocator_init (GstAllocator * allocator)
141 {
<a name="4" id="anc4"></a><span class="line-modified">142   allocator-&gt;priv = GST_ALLOCATOR_GET_PRIVATE (allocator);</span>
143 
144   allocator-&gt;mem_copy = _fallback_mem_copy;
145   allocator-&gt;mem_is_span = _fallback_mem_is_span;
146 }
147 
148 G_DEFINE_BOXED_TYPE (GstAllocationParams, gst_allocation_params,
149     (GBoxedCopyFunc) gst_allocation_params_copy,
150     (GBoxedFreeFunc) gst_allocation_params_free);
151 
152 /**
153  * gst_allocation_params_init:
154  * @params: a #GstAllocationParams
155  *
156  * Initialize @params to its default values
157  */
158 void
159 gst_allocation_params_init (GstAllocationParams * params)
160 {
161   g_return_if_fail (params != NULL);
162 
163   memset (params, 0, sizeof (GstAllocationParams));
164 }
165 
166 /**
167  * gst_allocation_params_copy:
168  * @params: (transfer none) (nullable): a #GstAllocationParams
169  *
170  * Create a copy of @params.
171  *
172  * Free-function: gst_allocation_params_free
173  *
174  * Returns: (transfer full) (nullable): a new ##GstAllocationParams, free with
175  * gst_allocation_params_free().
176  */
177 GstAllocationParams *
178 gst_allocation_params_copy (const GstAllocationParams * params)
179 {
180   GstAllocationParams *result = NULL;
181 
182   if (params) {
183     result =
184         (GstAllocationParams *) g_slice_copy (sizeof (GstAllocationParams),
185         params);
186   }
187   return result;
188 }
189 
190 /**
191  * gst_allocation_params_free:
192  * @params: (in) (transfer full): a #GstAllocationParams
193  *
194  * Free @params
195  */
196 void
197 gst_allocation_params_free (GstAllocationParams * params)
198 {
199   g_slice_free (GstAllocationParams, params);
200 }
201 
202 /**
203  * gst_allocator_register:
204  * @name: the name of the allocator
205  * @allocator: (transfer full): #GstAllocator
206  *
207  * Registers the memory @allocator with @name. This function takes ownership of
208  * @allocator.
209  */
210 void
211 gst_allocator_register (const gchar * name, GstAllocator * allocator)
212 {
213   g_return_if_fail (name != NULL);
214   g_return_if_fail (allocator != NULL);
215 
216   GST_CAT_DEBUG (GST_CAT_MEMORY, &quot;registering allocator %p with name \&quot;%s\&quot;&quot;,
217       allocator, name);
218 
219   g_rw_lock_writer_lock (&amp;lock);
220   /* The ref will never be released */
221   GST_OBJECT_FLAG_SET (allocator, GST_OBJECT_FLAG_MAY_BE_LEAKED);
222   g_hash_table_insert (allocators, (gpointer) name, (gpointer) allocator);
223   g_rw_lock_writer_unlock (&amp;lock);
224 }
225 
226 /**
227  * gst_allocator_find:
228  * @name: (allow-none): the name of the allocator
229  *
230  * Find a previously registered allocator with @name. When @name is %NULL, the
231  * default allocator will be returned.
232  *
233  * Returns: (transfer full) (nullable): a #GstAllocator or %NULL when
234  * the allocator with @name was not registered. Use gst_object_unref()
235  * to release the allocator after usage.
236  */
237 GstAllocator *
238 gst_allocator_find (const gchar * name)
239 {
240   GstAllocator *allocator;
241 
242   g_rw_lock_reader_lock (&amp;lock);
243   if (name) {
244     allocator = g_hash_table_lookup (allocators, (gconstpointer) name);
245   } else {
246     allocator = _default_allocator;
247   }
248   if (allocator)
249     gst_object_ref (allocator);
250   g_rw_lock_reader_unlock (&amp;lock);
251 
252   return allocator;
253 }
254 
255 /**
256  * gst_allocator_set_default:
257  * @allocator: (transfer full): a #GstAllocator
258  *
259  * Set the default allocator. This function takes ownership of @allocator.
260  */
261 void
262 gst_allocator_set_default (GstAllocator * allocator)
263 {
264   GstAllocator *old;
265 
266   g_return_if_fail (GST_IS_ALLOCATOR (allocator));
267 
268   g_rw_lock_writer_lock (&amp;lock);
269   old = _default_allocator;
270   _default_allocator = allocator;
271   g_rw_lock_writer_unlock (&amp;lock);
272 
273   if (old)
274     gst_object_unref (old);
275 }
276 
277 /**
278  * gst_allocator_alloc:
279  * @allocator: (transfer none) (allow-none): a #GstAllocator to use
280  * @size: size of the visible memory area
281  * @params: (transfer none) (allow-none): optional parameters
282  *
283  * Use @allocator to allocate a new memory block with memory that is at least
284  * @size big.
285  *
286  * The optional @params can specify the prefix and padding for the memory. If
287  * %NULL is passed, no flags, no extra prefix/padding and a default alignment is
288  * used.
289  *
290  * The prefix/padding will be filled with 0 if flags contains
291  * #GST_MEMORY_FLAG_ZERO_PREFIXED and #GST_MEMORY_FLAG_ZERO_PADDED respectively.
292  *
293  * When @allocator is %NULL, the default allocator will be used.
294  *
295  * The alignment in @params is given as a bitmask so that @align + 1 equals
296  * the amount of bytes to align to. For example, to align to 8 bytes,
297  * use an alignment of 7.
298  *
299  * Returns: (transfer full) (nullable): a new #GstMemory.
300  */
301 GstMemory *
302 gst_allocator_alloc (GstAllocator * allocator, gsize size,
303     GstAllocationParams * params)
304 {
305   GstMemory *mem;
306   static GstAllocationParams defparams = { 0, 0, 0, 0, };
307   GstAllocatorClass *aclass;
308 
309   if (params) {
310     g_return_val_if_fail (((params-&gt;align + 1) &amp; params-&gt;align) == 0, NULL);
311   } else {
312     params = &amp;defparams;
313   }
314 
315   if (allocator == NULL)
316     allocator = _default_allocator;
317 
318   aclass = GST_ALLOCATOR_GET_CLASS (allocator);
319   if (aclass-&gt;alloc)
320     mem = aclass-&gt;alloc (allocator, size, params);
321   else
322     mem = NULL;
323 
324   return mem;
325 }
326 
327 /**
328  * gst_allocator_free:
329  * @allocator: (transfer none): a #GstAllocator to use
330  * @memory: (transfer full): the memory to free
331  *
332  * Free @memory that was previously allocated with gst_allocator_alloc().
333  */
334 void
335 gst_allocator_free (GstAllocator * allocator, GstMemory * memory)
336 {
337   GstAllocatorClass *aclass;
338 
339   g_return_if_fail (GST_IS_ALLOCATOR (allocator));
340   g_return_if_fail (memory != NULL);
341   g_return_if_fail (memory-&gt;allocator == allocator);
342 
343   aclass = GST_ALLOCATOR_GET_CLASS (allocator);
344   if (aclass-&gt;free)
345     aclass-&gt;free (allocator, memory);
346 }
347 
348 /* default memory implementation */
349 typedef struct
350 {
351   GstMemory mem;
352 
353   gsize slice_size;
354   guint8 *data;
355 
356   gpointer user_data;
357   GDestroyNotify notify;
358 } GstMemorySystem;
359 
360 typedef struct
361 {
362   GstAllocator parent;
363 } GstAllocatorSysmem;
364 
365 typedef struct
366 {
367   GstAllocatorClass parent_class;
368 } GstAllocatorSysmemClass;
369 
370 static GType gst_allocator_sysmem_get_type (void);
371 G_DEFINE_TYPE (GstAllocatorSysmem, gst_allocator_sysmem, GST_TYPE_ALLOCATOR);
372 
373 /* initialize the fields */
374 static inline void
375 _sysmem_init (GstMemorySystem * mem, GstMemoryFlags flags,
376     GstMemory * parent, gsize slice_size,
377     gpointer data, gsize maxsize, gsize align, gsize offset, gsize size,
378     gpointer user_data, GDestroyNotify notify)
379 {
380   gst_memory_init (GST_MEMORY_CAST (mem),
381       flags, _sysmem_allocator, parent, maxsize, align, offset, size);
382 
383   mem-&gt;slice_size = slice_size;
384   mem-&gt;data = data;
385   mem-&gt;user_data = user_data;
386   mem-&gt;notify = notify;
387 }
388 
389 /* create a new memory block that manages the given memory */
390 static inline GstMemorySystem *
391 _sysmem_new (GstMemoryFlags flags,
392     GstMemory * parent, gpointer data, gsize maxsize, gsize align, gsize offset,
393     gsize size, gpointer user_data, GDestroyNotify notify)
394 {
395   GstMemorySystem *mem;
396   gsize slice_size;
397 
398   slice_size = sizeof (GstMemorySystem);
399 
400   mem = g_slice_alloc (slice_size);
401   _sysmem_init (mem, flags, parent, slice_size,
402       data, maxsize, align, offset, size, user_data, notify);
403 
404   return mem;
405 }
406 
407 /* allocate the memory and structure in one block */
408 static GstMemorySystem *
409 _sysmem_new_block (GstMemoryFlags flags,
410     gsize maxsize, gsize align, gsize offset, gsize size)
411 {
412   GstMemorySystem *mem;
413   gsize aoffset, slice_size, padding;
414   guint8 *data;
415 
416   /* ensure configured alignment */
417   align |= gst_memory_alignment;
418   /* allocate more to compensate for alignment */
419   maxsize += align;
420   /* alloc header and data in one block */
421   slice_size = sizeof (GstMemorySystem) + maxsize;
422 
423   mem = g_slice_alloc (slice_size);
424   if (mem == NULL)
425     return NULL;
426 
427   data = (guint8 *) mem + sizeof (GstMemorySystem);
428 
429   /* do alignment */
430   if ((aoffset = ((guintptr) data &amp; align))) {
431     aoffset = (align + 1) - aoffset;
432     data += aoffset;
433     maxsize -= aoffset;
434   }
435 
436   if (offset &amp;&amp; (flags &amp; GST_MEMORY_FLAG_ZERO_PREFIXED))
437     memset (data, 0, offset);
438 
439   padding = maxsize - (offset + size);
440   if (padding &amp;&amp; (flags &amp; GST_MEMORY_FLAG_ZERO_PADDED))
441     memset (data + offset + size, 0, padding);
442 
443   _sysmem_init (mem, flags, NULL, slice_size, data, maxsize,
444       align, offset, size, NULL, NULL);
445 
446   return mem;
447 }
448 
449 static gpointer
450 _sysmem_map (GstMemorySystem * mem, gsize maxsize, GstMapFlags flags)
451 {
452   return mem-&gt;data;
453 }
454 
455 static gboolean
456 _sysmem_unmap (GstMemorySystem * mem)
457 {
458   return TRUE;
459 }
460 
461 static GstMemorySystem *
462 _sysmem_copy (GstMemorySystem * mem, gssize offset, gsize size)
463 {
464   GstMemorySystem *copy;
465 
466   if (size == -1)
467     size = mem-&gt;mem.size &gt; offset ? mem-&gt;mem.size - offset : 0;
468 
469   copy = _sysmem_new_block (0, size, mem-&gt;mem.align, 0, size);
470 #ifdef GSTREAMER_LITE
471   if (copy == NULL)
472     return NULL;
473 #endif // GSTREAMER_LITE
474   GST_CAT_DEBUG (GST_CAT_PERFORMANCE,
475       &quot;memcpy %&quot; G_GSIZE_FORMAT &quot; memory %p -&gt; %p&quot;, size, mem, copy);
476   memcpy (copy-&gt;data, mem-&gt;data + mem-&gt;mem.offset + offset, size);
477 
478   return copy;
479 }
480 
481 static GstMemorySystem *
482 _sysmem_share (GstMemorySystem * mem, gssize offset, gsize size)
483 {
484   GstMemorySystem *sub;
485   GstMemory *parent;
486 
487   /* find the real parent */
488   if ((parent = mem-&gt;mem.parent) == NULL)
489     parent = (GstMemory *) mem;
490 
491   if (size == -1)
492     size = mem-&gt;mem.size - offset;
493 
494   /* the shared memory is always readonly */
495   sub =
496       _sysmem_new (GST_MINI_OBJECT_FLAGS (parent) |
497       GST_MINI_OBJECT_FLAG_LOCK_READONLY, parent, mem-&gt;data, mem-&gt;mem.maxsize,
498       mem-&gt;mem.align, mem-&gt;mem.offset + offset, size, NULL, NULL);
499 
500   return sub;
501 }
502 
503 static gboolean
504 _sysmem_is_span (GstMemorySystem * mem1, GstMemorySystem * mem2, gsize * offset)
505 {
506 
507   if (offset) {
508     GstMemorySystem *parent;
509 
510     parent = (GstMemorySystem *) mem1-&gt;mem.parent;
511 
512     *offset = mem1-&gt;mem.offset - parent-&gt;mem.offset;
513   }
514 
515   /* and memory is contiguous */
516   return mem1-&gt;data + mem1-&gt;mem.offset + mem1-&gt;mem.size ==
517       mem2-&gt;data + mem2-&gt;mem.offset;
518 }
519 
520 static GstMemory *
521 default_alloc (GstAllocator * allocator, gsize size,
522     GstAllocationParams * params)
523 {
524   gsize maxsize = size + params-&gt;prefix + params-&gt;padding;
525 
526   return (GstMemory *) _sysmem_new_block (params-&gt;flags,
527       maxsize, params-&gt;align, params-&gt;prefix, size);
528 }
529 
530 static void
531 default_free (GstAllocator * allocator, GstMemory * mem)
532 {
533   GstMemorySystem *dmem = (GstMemorySystem *) mem;
534   gsize slice_size;
535 
536   if (dmem-&gt;notify)
537     dmem-&gt;notify (dmem-&gt;user_data);
538 
539   slice_size = dmem-&gt;slice_size;
540 
541 #ifdef USE_POISONING
542   /* just poison the structs, not all the data */
543   memset (mem, 0xff, sizeof (GstMemorySystem));
544 #endif
545 
546   g_slice_free1 (slice_size, mem);
547 }
548 
549 static void
550 gst_allocator_sysmem_finalize (GObject * obj)
551 {
552   /* Don&#39;t raise warnings if we are shutting down */
553   if (_default_allocator)
<a name="5" id="anc5"></a><span class="line-modified">554   g_warning (&quot;The default memory allocator was freed!&quot;);</span>
555 
556   ((GObjectClass *) gst_allocator_sysmem_parent_class)-&gt;finalize (obj);
557 }
558 
559 static void
560 gst_allocator_sysmem_class_init (GstAllocatorSysmemClass * klass)
561 {
562   GObjectClass *gobject_class;
563   GstAllocatorClass *allocator_class;
564 
565   gobject_class = (GObjectClass *) klass;
566   allocator_class = (GstAllocatorClass *) klass;
567 
568   gobject_class-&gt;finalize = gst_allocator_sysmem_finalize;
569 
570   allocator_class-&gt;alloc = default_alloc;
571   allocator_class-&gt;free = default_free;
572 }
573 
574 static void
575 gst_allocator_sysmem_init (GstAllocatorSysmem * allocator)
576 {
577   GstAllocator *alloc = GST_ALLOCATOR_CAST (allocator);
578 
579   GST_CAT_DEBUG (GST_CAT_MEMORY, &quot;init allocator %p&quot;, allocator);
580 
581   alloc-&gt;mem_type = GST_ALLOCATOR_SYSMEM;
582   alloc-&gt;mem_map = (GstMemoryMapFunction) _sysmem_map;
583   alloc-&gt;mem_unmap = (GstMemoryUnmapFunction) _sysmem_unmap;
584   alloc-&gt;mem_copy = (GstMemoryCopyFunction) _sysmem_copy;
585   alloc-&gt;mem_share = (GstMemoryShareFunction) _sysmem_share;
586   alloc-&gt;mem_is_span = (GstMemoryIsSpanFunction) _sysmem_is_span;
587 }
588 
589 void
590 _priv_gst_allocator_initialize (void)
591 {
592   g_rw_lock_init (&amp;lock);
593   allocators = g_hash_table_new_full (g_str_hash, g_str_equal, NULL,
594       gst_object_unref);
595 
596 #ifdef HAVE_GETPAGESIZE
597 #ifdef MEMORY_ALIGNMENT_PAGESIZE
598   gst_memory_alignment = getpagesize () - 1;
599 #endif
600 #endif
601 
602   GST_CAT_DEBUG (GST_CAT_MEMORY, &quot;memory alignment: %&quot; G_GSIZE_FORMAT,
603       gst_memory_alignment);
604 
605   _sysmem_allocator = g_object_new (gst_allocator_sysmem_get_type (), NULL);
606 
607   /* Clear floating flag */
608   gst_object_ref_sink (_sysmem_allocator);
609 
610   gst_allocator_register (GST_ALLOCATOR_SYSMEM,
611       gst_object_ref (_sysmem_allocator));
612 
613   _default_allocator = gst_object_ref (_sysmem_allocator);
614 }
615 
616 void
617 _priv_gst_allocator_cleanup (void)
618 {
619   gst_object_unref (_sysmem_allocator);
620   _sysmem_allocator = NULL;
621 
622   gst_object_unref (_default_allocator);
623   _default_allocator = NULL;
624 
625   g_clear_pointer (&amp;allocators, g_hash_table_unref);
626 }
627 
628 /**
629  * gst_memory_new_wrapped:
630  * @flags: #GstMemoryFlags
631  * @data: (array length=size) (element-type guint8) (transfer none): data to
632  *   wrap
633  * @maxsize: allocated size of @data
634  * @offset: offset in @data
635  * @size: size of valid data
636  * @user_data: (allow-none): user_data
637  * @notify: (allow-none) (scope async) (closure user_data): called with @user_data when the memory is freed
638  *
639  * Allocate a new memory block that wraps the given @data.
640  *
641  * The prefix/padding must be filled with 0 if @flags contains
642  * #GST_MEMORY_FLAG_ZERO_PREFIXED and #GST_MEMORY_FLAG_ZERO_PADDED respectively.
643  *
644  * Returns: (transfer full) (nullable): a new #GstMemory.
645  */
646 GstMemory *
647 gst_memory_new_wrapped (GstMemoryFlags flags, gpointer data,
648     gsize maxsize, gsize offset, gsize size, gpointer user_data,
649     GDestroyNotify notify)
650 {
651   GstMemorySystem *mem;
652 
653   g_return_val_if_fail (data != NULL, NULL);
654   g_return_val_if_fail (offset + size &lt;= maxsize, NULL);
655 
656   mem =
657       _sysmem_new (flags, NULL, data, maxsize, 0, offset, size, user_data,
658       notify);
659 
660   return (GstMemory *) mem;
661 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>