<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/guniprop.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* guniprop.c - Unicode character properties.
   2  *
   3  * Copyright (C) 1999 Tom Tromey
   4  * Copyright (C) 2000 Red Hat, Inc.
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Lesser General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2.1 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Lesser General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Lesser General Public
  17  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  18  */
  19 
  20 #include &quot;config.h&quot;
  21 
  22 #include &lt;stdlib.h&gt;
  23 #include &lt;stddef.h&gt;
  24 #include &lt;string.h&gt;
  25 #include &lt;locale.h&gt;
  26 
  27 #include &quot;gmem.h&quot;
  28 #include &quot;gstring.h&quot;
  29 #include &quot;gtestutils.h&quot;
  30 #include &quot;gtypes.h&quot;
  31 #include &quot;gunicode.h&quot;
  32 #include &quot;gunichartables.h&quot;
  33 #include &quot;gmirroringtable.h&quot;
  34 #include &quot;gscripttable.h&quot;
  35 #include &quot;gunicodeprivate.h&quot;
  36 #ifdef G_OS_WIN32
  37 #include &quot;gwin32.h&quot;
  38 #endif
  39 
<a name="1" id="anc1"></a>






  40 #define ATTR_TABLE(Page) (((Page) &lt;= G_UNICODE_LAST_PAGE_PART1) \
  41                           ? attr_table_part1[Page] \
  42                           : attr_table_part2[(Page) - 0xe00])
  43 
  44 #define ATTTABLE(Page, Char) \
  45   ((ATTR_TABLE(Page) == G_UNICODE_MAX_TABLE_INDEX) ? 0 : (attr_data[ATTR_TABLE(Page)][Char]))
  46 
  47 #define TTYPE_PART1(Page, Char) \
  48   ((type_table_part1[Page] &gt;= G_UNICODE_MAX_TABLE_INDEX) \
  49    ? (type_table_part1[Page] - G_UNICODE_MAX_TABLE_INDEX) \
  50    : (type_data[type_table_part1[Page]][Char]))
  51 
  52 #define TTYPE_PART2(Page, Char) \
  53   ((type_table_part2[Page] &gt;= G_UNICODE_MAX_TABLE_INDEX) \
  54    ? (type_table_part2[Page] - G_UNICODE_MAX_TABLE_INDEX) \
  55    : (type_data[type_table_part2[Page]][Char]))
  56 
  57 #define TYPE(Char) \
  58   (((Char) &lt;= G_UNICODE_LAST_CHAR_PART1) \
  59    ? TTYPE_PART1 ((Char) &gt;&gt; 8, (Char) &amp; 0xff) \
  60    : (((Char) &gt;= 0xe0000 &amp;&amp; (Char) &lt;= G_UNICODE_LAST_CHAR) \
  61       ? TTYPE_PART2 (((Char) - 0xe0000) &gt;&gt; 8, (Char) &amp; 0xff) \
  62       : G_UNICODE_UNASSIGNED))
  63 
  64 
  65 #define IS(Type, Class) (((guint)1 &lt;&lt; (Type)) &amp; (Class))
  66 #define OR(Type, Rest)  (((guint)1 &lt;&lt; (Type)) | (Rest))
  67 
  68 
  69 
<a name="2" id="anc2"></a><span class="line-modified">  70 #define ISALPHA(Type)   IS ((Type),             \</span>
<span class="line-modified">  71                 OR (G_UNICODE_LOWERCASE_LETTER, \</span>
<span class="line-modified">  72                 OR (G_UNICODE_UPPERCASE_LETTER, \</span>
<span class="line-modified">  73                 OR (G_UNICODE_TITLECASE_LETTER, \</span>
<span class="line-modified">  74                 OR (G_UNICODE_MODIFIER_LETTER,  \</span>
<span class="line-modified">  75                 OR (G_UNICODE_OTHER_LETTER,     0))))))</span>
  76 
<a name="3" id="anc3"></a><span class="line-modified">  77 #define ISALDIGIT(Type) IS ((Type),             \</span>
<span class="line-modified">  78                 OR (G_UNICODE_DECIMAL_NUMBER,   \</span>
<span class="line-modified">  79                 OR (G_UNICODE_LETTER_NUMBER,    \</span>
<span class="line-modified">  80                 OR (G_UNICODE_OTHER_NUMBER,     \</span>
<span class="line-modified">  81                 OR (G_UNICODE_LOWERCASE_LETTER, \</span>
<span class="line-modified">  82                 OR (G_UNICODE_UPPERCASE_LETTER, \</span>
<span class="line-modified">  83                 OR (G_UNICODE_TITLECASE_LETTER, \</span>
<span class="line-modified">  84                 OR (G_UNICODE_MODIFIER_LETTER,  \</span>
<span class="line-modified">  85                 OR (G_UNICODE_OTHER_LETTER,     0)))))))))</span>
  86 
<a name="4" id="anc4"></a><span class="line-modified">  87 #define ISMARK(Type)    IS ((Type),             \</span>
<span class="line-modified">  88                 OR (G_UNICODE_NON_SPACING_MARK, \</span>
<span class="line-modified">  89                 OR (G_UNICODE_SPACING_MARK, \</span>
<span class="line-modified">  90                 OR (G_UNICODE_ENCLOSING_MARK,   0))))</span>
  91 
<a name="5" id="anc5"></a><span class="line-modified">  92 #define ISZEROWIDTHTYPE(Type)   IS ((Type),         \</span>
<span class="line-modified">  93                 OR (G_UNICODE_NON_SPACING_MARK, \</span>
<span class="line-modified">  94                 OR (G_UNICODE_ENCLOSING_MARK,   \</span>
<span class="line-modified">  95                 OR (G_UNICODE_FORMAT,       0))))</span>
  96 
  97 /**
  98  * g_unichar_isalnum:
  99  * @c: a Unicode character
 100  *
 101  * Determines whether a character is alphanumeric.
 102  * Given some UTF-8 text, obtain a character value
 103  * with g_utf8_get_char().
 104  *
 105  * Returns: %TRUE if @c is an alphanumeric character
 106  **/
 107 gboolean
 108 g_unichar_isalnum (gunichar c)
 109 {
 110   return ISALDIGIT (TYPE (c)) ? TRUE : FALSE;
 111 }
 112 
 113 /**
 114  * g_unichar_isalpha:
 115  * @c: a Unicode character
 116  *
 117  * Determines whether a character is alphabetic (i.e. a letter).
 118  * Given some UTF-8 text, obtain a character value with
 119  * g_utf8_get_char().
 120  *
 121  * Returns: %TRUE if @c is an alphabetic character
 122  **/
 123 gboolean
 124 g_unichar_isalpha (gunichar c)
 125 {
 126   return ISALPHA (TYPE (c)) ? TRUE : FALSE;
 127 }
 128 
 129 
 130 /**
 131  * g_unichar_iscntrl:
 132  * @c: a Unicode character
 133  *
 134  * Determines whether a character is a control character.
 135  * Given some UTF-8 text, obtain a character value with
 136  * g_utf8_get_char().
 137  *
 138  * Returns: %TRUE if @c is a control character
 139  **/
 140 gboolean
 141 g_unichar_iscntrl (gunichar c)
 142 {
 143   return TYPE (c) == G_UNICODE_CONTROL;
 144 }
 145 
 146 /**
 147  * g_unichar_isdigit:
 148  * @c: a Unicode character
 149  *
 150  * Determines whether a character is numeric (i.e. a digit).  This
 151  * covers ASCII 0-9 and also digits in other languages/scripts.  Given
 152  * some UTF-8 text, obtain a character value with g_utf8_get_char().
 153  *
 154  * Returns: %TRUE if @c is a digit
 155  **/
 156 gboolean
 157 g_unichar_isdigit (gunichar c)
 158 {
 159   return TYPE (c) == G_UNICODE_DECIMAL_NUMBER;
 160 }
 161 
 162 
 163 /**
 164  * g_unichar_isgraph:
 165  * @c: a Unicode character
 166  *
 167  * Determines whether a character is printable and not a space
 168  * (returns %FALSE for control characters, format characters, and
 169  * spaces). g_unichar_isprint() is similar, but returns %TRUE for
 170  * spaces. Given some UTF-8 text, obtain a character value with
 171  * g_utf8_get_char().
 172  *
 173  * Returns: %TRUE if @c is printable unless it&#39;s a space
 174  **/
 175 gboolean
 176 g_unichar_isgraph (gunichar c)
 177 {
 178   return !IS (TYPE(c),
<a name="6" id="anc6"></a><span class="line-modified"> 179           OR (G_UNICODE_CONTROL,</span>
<span class="line-modified"> 180           OR (G_UNICODE_FORMAT,</span>
<span class="line-modified"> 181           OR (G_UNICODE_UNASSIGNED,</span>
<span class="line-modified"> 182           OR (G_UNICODE_SURROGATE,</span>
<span class="line-modified"> 183           OR (G_UNICODE_SPACE_SEPARATOR,</span>
<span class="line-modified"> 184          0))))));</span>
 185 }
 186 
 187 /**
 188  * g_unichar_islower:
 189  * @c: a Unicode character
 190  *
 191  * Determines whether a character is a lowercase letter.
 192  * Given some UTF-8 text, obtain a character value with
 193  * g_utf8_get_char().
 194  *
 195  * Returns: %TRUE if @c is a lowercase letter
 196  **/
 197 gboolean
 198 g_unichar_islower (gunichar c)
 199 {
 200   return TYPE (c) == G_UNICODE_LOWERCASE_LETTER;
 201 }
 202 
 203 
 204 /**
 205  * g_unichar_isprint:
 206  * @c: a Unicode character
 207  *
 208  * Determines whether a character is printable.
 209  * Unlike g_unichar_isgraph(), returns %TRUE for spaces.
 210  * Given some UTF-8 text, obtain a character value with
 211  * g_utf8_get_char().
 212  *
 213  * Returns: %TRUE if @c is printable
 214  **/
 215 gboolean
 216 g_unichar_isprint (gunichar c)
 217 {
 218   return !IS (TYPE(c),
<a name="7" id="anc7"></a><span class="line-modified"> 219           OR (G_UNICODE_CONTROL,</span>
<span class="line-modified"> 220           OR (G_UNICODE_FORMAT,</span>
<span class="line-modified"> 221           OR (G_UNICODE_UNASSIGNED,</span>
<span class="line-modified"> 222           OR (G_UNICODE_SURROGATE,</span>
<span class="line-modified"> 223          0)))));</span>
 224 }
 225 
 226 /**
 227  * g_unichar_ispunct:
 228  * @c: a Unicode character
 229  *
 230  * Determines whether a character is punctuation or a symbol.
 231  * Given some UTF-8 text, obtain a character value with
 232  * g_utf8_get_char().
 233  *
 234  * Returns: %TRUE if @c is a punctuation or symbol character
 235  **/
 236 gboolean
 237 g_unichar_ispunct (gunichar c)
 238 {
 239   return IS (TYPE(c),
<a name="8" id="anc8"></a><span class="line-modified"> 240          OR (G_UNICODE_CONNECT_PUNCTUATION,</span>
<span class="line-modified"> 241          OR (G_UNICODE_DASH_PUNCTUATION,</span>
<span class="line-modified"> 242          OR (G_UNICODE_CLOSE_PUNCTUATION,</span>
<span class="line-modified"> 243          OR (G_UNICODE_FINAL_PUNCTUATION,</span>
<span class="line-modified"> 244          OR (G_UNICODE_INITIAL_PUNCTUATION,</span>
<span class="line-modified"> 245          OR (G_UNICODE_OTHER_PUNCTUATION,</span>
<span class="line-modified"> 246          OR (G_UNICODE_OPEN_PUNCTUATION,</span>
<span class="line-modified"> 247          OR (G_UNICODE_CURRENCY_SYMBOL,</span>
<span class="line-modified"> 248          OR (G_UNICODE_MODIFIER_SYMBOL,</span>
<span class="line-modified"> 249          OR (G_UNICODE_MATH_SYMBOL,</span>
<span class="line-modified"> 250          OR (G_UNICODE_OTHER_SYMBOL,</span>
<span class="line-modified"> 251         0)))))))))))) ? TRUE : FALSE;</span>
 252 }
 253 
 254 /**
 255  * g_unichar_isspace:
 256  * @c: a Unicode character
 257  *
 258  * Determines whether a character is a space, tab, or line separator
 259  * (newline, carriage return, etc.).  Given some UTF-8 text, obtain a
 260  * character value with g_utf8_get_char().
 261  *
 262  * (Note: don&#39;t use this to do word breaking; you have to use
 263  * Pango or equivalent to get word breaking right, the algorithm
 264  * is fairly complex.)
 265  *
 266  * Returns: %TRUE if @c is a space character
 267  **/
 268 gboolean
 269 g_unichar_isspace (gunichar c)
 270 {
 271   switch (c)
 272     {
 273       /* special-case these since Unicode thinks they are not spaces */
 274     case &#39;\t&#39;:
 275     case &#39;\n&#39;:
 276     case &#39;\r&#39;:
 277     case &#39;\f&#39;:
 278       return TRUE;
 279       break;
 280 
 281     default:
 282       {
<a name="9" id="anc9"></a><span class="line-modified"> 283     return IS (TYPE(c),</span>
<span class="line-modified"> 284                OR (G_UNICODE_SPACE_SEPARATOR,</span>
<span class="line-modified"> 285                OR (G_UNICODE_LINE_SEPARATOR,</span>
 286                    OR (G_UNICODE_PARAGRAPH_SEPARATOR,
<a name="10" id="anc10"></a><span class="line-modified"> 287           0)))) ? TRUE : FALSE;</span>
 288       }
 289       break;
 290     }
 291 }
 292 
 293 /**
 294  * g_unichar_ismark:
 295  * @c: a Unicode character
 296  *
 297  * Determines whether a character is a mark (non-spacing mark,
 298  * combining mark, or enclosing mark in Unicode speak).
 299  * Given some UTF-8 text, obtain a character value
 300  * with g_utf8_get_char().
 301  *
 302  * Note: in most cases where isalpha characters are allowed,
 303  * ismark characters should be allowed to as they are essential
 304  * for writing most European languages as well as many non-Latin
 305  * scripts.
 306  *
 307  * Returns: %TRUE if @c is a mark character
 308  *
 309  * Since: 2.14
 310  **/
 311 gboolean
 312 g_unichar_ismark (gunichar c)
 313 {
 314   return ISMARK (TYPE (c));
 315 }
 316 
 317 /**
 318  * g_unichar_isupper:
 319  * @c: a Unicode character
 320  *
 321  * Determines if a character is uppercase.
 322  *
 323  * Returns: %TRUE if @c is an uppercase character
 324  **/
 325 gboolean
 326 g_unichar_isupper (gunichar c)
 327 {
 328   return TYPE (c) == G_UNICODE_UPPERCASE_LETTER;
 329 }
 330 
 331 /**
 332  * g_unichar_istitle:
 333  * @c: a Unicode character
 334  *
 335  * Determines if a character is titlecase. Some characters in
 336  * Unicode which are composites, such as the DZ digraph
 337  * have three case variants instead of just two. The titlecase
 338  * form is used at the beginning of a word where only the
 339  * first letter is capitalized. The titlecase form of the DZ
 340  * digraph is U+01F2 LATIN CAPITAL LETTTER D WITH SMALL LETTER Z.
 341  *
 342  * Returns: %TRUE if the character is titlecase
 343  **/
 344 gboolean
 345 g_unichar_istitle (gunichar c)
 346 {
 347   unsigned int i;
 348   for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)
 349     if (title_table[i][0] == c)
 350       return TRUE;
 351   return FALSE;
 352 }
 353 
 354 /**
 355  * g_unichar_isxdigit:
 356  * @c: a Unicode character.
 357  *
 358  * Determines if a character is a hexidecimal digit.
 359  *
 360  * Returns: %TRUE if the character is a hexadecimal digit
 361  **/
 362 gboolean
 363 g_unichar_isxdigit (gunichar c)
 364 {
<a name="11" id="anc11"></a><span class="line-modified"> 365   return ((c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;)</span>
<span class="line-modified"> 366       || (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;)</span>
<span class="line-modified"> 367       || (TYPE (c) == G_UNICODE_DECIMAL_NUMBER));</span>


 368 }
 369 
 370 /**
 371  * g_unichar_isdefined:
 372  * @c: a Unicode character
 373  *
 374  * Determines if a given character is assigned in the Unicode
 375  * standard.
 376  *
 377  * Returns: %TRUE if the character has an assigned value
 378  **/
 379 gboolean
 380 g_unichar_isdefined (gunichar c)
 381 {
 382   return !IS (TYPE(c),
<a name="12" id="anc12"></a><span class="line-modified"> 383           OR (G_UNICODE_UNASSIGNED,</span>
<span class="line-modified"> 384           OR (G_UNICODE_SURROGATE,</span>
<span class="line-modified"> 385          0)));</span>
 386 }
 387 
 388 /**
 389  * g_unichar_iszerowidth:
 390  * @c: a Unicode character
 391  *
 392  * Determines if a given character typically takes zero width when rendered.
 393  * The return value is %TRUE for all non-spacing and enclosing marks
 394  * (e.g., combining accents), format characters, zero-width
 395  * space, but not U+00AD SOFT HYPHEN.
 396  *
 397  * A typical use of this function is with one of g_unichar_iswide() or
 398  * g_unichar_iswide_cjk() to determine the number of cells a string occupies
 399  * when displayed on a grid display (terminals).  However, note that not all
 400  * terminals support zero-width rendering of zero-width marks.
 401  *
 402  * Returns: %TRUE if the character has zero width
 403  *
 404  * Since: 2.14
 405  **/
 406 gboolean
 407 g_unichar_iszerowidth (gunichar c)
 408 {
 409   if (G_UNLIKELY (c == 0x00AD))
 410     return FALSE;
 411 
 412   if (G_UNLIKELY (ISZEROWIDTHTYPE (TYPE (c))))
 413     return TRUE;
 414 
 415   if (G_UNLIKELY ((c &gt;= 0x1160 &amp;&amp; c &lt; 0x1200) ||
<a name="13" id="anc13"></a><span class="line-modified"> 416           c == 0x200B))</span>
 417     return TRUE;
 418 
 419   return FALSE;
 420 }
 421 
 422 static int
 423 interval_compare (const void *key, const void *elt)
 424 {
 425   gunichar c = GPOINTER_TO_UINT (key);
 426   struct Interval *interval = (struct Interval *)elt;
 427 
 428   if (c &lt; interval-&gt;start)
 429     return -1;
 430   if (c &gt; interval-&gt;end)
 431     return +1;
 432 
 433   return 0;
 434 }
 435 
 436 #define G_WIDTH_TABLE_MIDPOINT (G_N_ELEMENTS (g_unicode_width_table_wide) / 2)
 437 
 438 static inline gboolean
 439 g_unichar_iswide_bsearch (gunichar ch)
 440 {
 441   int lower = 0;
 442   int upper = G_N_ELEMENTS (g_unicode_width_table_wide) - 1;
 443   static int saved_mid = G_WIDTH_TABLE_MIDPOINT;
 444   int mid = saved_mid;
 445 
 446   do
 447     {
 448       if (ch &lt; g_unicode_width_table_wide[mid].start)
<a name="14" id="anc14"></a><span class="line-modified"> 449     upper = mid - 1;</span>
 450       else if (ch &gt; g_unicode_width_table_wide[mid].end)
<a name="15" id="anc15"></a><span class="line-modified"> 451     lower = mid + 1;</span>
 452       else
<a name="16" id="anc16"></a><span class="line-modified"> 453     return TRUE;</span>
 454 
 455       mid = (lower + upper) / 2;
 456     }
 457   while (lower &lt;= upper);
 458 
 459   return FALSE;
 460 }
 461 
 462 /**
 463  * g_unichar_iswide:
 464  * @c: a Unicode character
 465  *
 466  * Determines if a character is typically rendered in a double-width
 467  * cell.
 468  *
 469  * Returns: %TRUE if the character is wide
 470  **/
 471 gboolean
 472 g_unichar_iswide (gunichar c)
 473 {
 474   if (c &lt; g_unicode_width_table_wide[0].start)
<a name="17" id="anc17"></a><span class="line-modified"> 475   return FALSE;</span>
 476   else
 477     return g_unichar_iswide_bsearch (c);
 478 }
 479 
 480 
 481 /**
 482  * g_unichar_iswide_cjk:
 483  * @c: a Unicode character
 484  *
 485  * Determines if a character is typically rendered in a double-width
 486  * cell under legacy East Asian locales.  If a character is wide according to
 487  * g_unichar_iswide(), then it is also reported wide with this function, but
 488  * the converse is not necessarily true. See the
 489  * [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)
 490  * for details.
 491  *
 492  * If a character passes the g_unichar_iswide() test then it will also pass
 493  * this test, but not the other way around.  Note that some characters may
 494  * pass both this test and g_unichar_iszerowidth().
 495  *
 496  * Returns: %TRUE if the character is wide in legacy East Asian locales
 497  *
 498  * Since: 2.12
 499  */
 500 gboolean
 501 g_unichar_iswide_cjk (gunichar c)
 502 {
 503   if (g_unichar_iswide (c))
 504     return TRUE;
 505 
 506   /* bsearch() is declared attribute(nonnull(1)) so we can&#39;t validly search
 507    * for a NULL key */
 508   if (c == 0)
 509     return FALSE;
 510 
 511   if (bsearch (GUINT_TO_POINTER (c),
 512                g_unicode_width_table_ambiguous,
 513                G_N_ELEMENTS (g_unicode_width_table_ambiguous),
 514                sizeof g_unicode_width_table_ambiguous[0],
<a name="18" id="anc18"></a><span class="line-modified"> 515            interval_compare))</span>
 516     return TRUE;
 517 
 518   return FALSE;
 519 }
 520 
 521 
 522 /**
 523  * g_unichar_toupper:
 524  * @c: a Unicode character
 525  *
 526  * Converts a character to uppercase.
 527  *
 528  * Returns: the result of converting @c to uppercase.
<a name="19" id="anc19"></a><span class="line-modified"> 529  *               If @c is not an lowercase or titlecase character,</span>
 530  *               or has no upper case equivalent @c is returned unchanged.
 531  **/
 532 gunichar
 533 g_unichar_toupper (gunichar c)
 534 {
 535   int t = TYPE (c);
 536   if (t == G_UNICODE_LOWERCASE_LETTER)
 537     {
 538       gunichar val = ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);
 539       if (val &gt;= 0x1000000)
<a name="20" id="anc20"></a><span class="line-modified"> 540     {</span>
<span class="line-modified"> 541       const gchar *p = special_case_table + val - 0x1000000;</span>
 542           val = g_utf8_get_char (p);
<a name="21" id="anc21"></a><span class="line-modified"> 543     }</span>
 544       /* Some lowercase letters, e.g., U+000AA, FEMININE ORDINAL INDICATOR,
 545        * do not have an uppercase equivalent, in which case val will be
 546        * zero.
 547        */
 548       return val ? val : c;
 549     }
 550   else if (t == G_UNICODE_TITLECASE_LETTER)
 551     {
 552       unsigned int i;
 553       for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)
<a name="22" id="anc22"></a><span class="line-modified"> 554     {</span>
<span class="line-modified"> 555       if (title_table[i][0] == c)</span>
<span class="line-modified"> 556         return title_table[i][1] ? title_table[i][1] : c;</span>
<span class="line-modified"> 557     }</span>
 558     }
 559   return c;
 560 }
 561 
 562 /**
 563  * g_unichar_tolower:
 564  * @c: a Unicode character.
 565  *
 566  * Converts a character to lower case.
 567  *
 568  * Returns: the result of converting @c to lower case.
 569  *               If @c is not an upperlower or titlecase character,
 570  *               or has no lowercase equivalent @c is returned unchanged.
 571  **/
 572 gunichar
 573 g_unichar_tolower (gunichar c)
 574 {
 575   int t = TYPE (c);
 576   if (t == G_UNICODE_UPPERCASE_LETTER)
 577     {
 578       gunichar val = ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);
 579       if (val &gt;= 0x1000000)
<a name="23" id="anc23"></a><span class="line-modified"> 580     {</span>
<span class="line-modified"> 581       const gchar *p = special_case_table + val - 0x1000000;</span>
<span class="line-modified"> 582       return g_utf8_get_char (p);</span>
<span class="line-modified"> 583     }</span>
 584       else
<a name="24" id="anc24"></a><span class="line-modified"> 585     {</span>
<span class="line-modified"> 586       /* Not all uppercase letters are guaranteed to have a lowercase</span>
<span class="line-modified"> 587        * equivalent.  If this is the case, val will be zero. */</span>
<span class="line-modified"> 588       return val ? val : c;</span>
<span class="line-modified"> 589     }</span>
 590     }
 591   else if (t == G_UNICODE_TITLECASE_LETTER)
 592     {
 593       unsigned int i;
 594       for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)
<a name="25" id="anc25"></a><span class="line-modified"> 595     {</span>
<span class="line-modified"> 596       if (title_table[i][0] == c)</span>
<span class="line-modified"> 597         return title_table[i][2];</span>
<span class="line-modified"> 598     }</span>
 599     }
 600   return c;
 601 }
 602 
 603 /**
 604  * g_unichar_totitle:
 605  * @c: a Unicode character
 606  *
 607  * Converts a character to the titlecase.
 608  *
 609  * Returns: the result of converting @c to titlecase.
 610  *               If @c is not an uppercase or lowercase character,
 611  *               @c is returned unchanged.
 612  **/
 613 gunichar
 614 g_unichar_totitle (gunichar c)
 615 {
 616   unsigned int i;
<a name="26" id="anc26"></a>





 617   for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)
 618     {
 619       if (title_table[i][0] == c || title_table[i][1] == c
<a name="27" id="anc27"></a><span class="line-modified"> 620       || title_table[i][2] == c)</span>
<span class="line-modified"> 621     return title_table[i][0];</span>
 622     }
 623 
 624   if (TYPE (c) == G_UNICODE_LOWERCASE_LETTER)
 625     return g_unichar_toupper (c);
 626 
 627   return c;
 628 }
 629 
 630 /**
 631  * g_unichar_digit_value:
 632  * @c: a Unicode character
 633  *
 634  * Determines the numeric value of a character as a decimal
 635  * digit.
 636  *
 637  * Returns: If @c is a decimal digit (according to
 638  * g_unichar_isdigit()), its numeric value. Otherwise, -1.
 639  **/
 640 int
 641 g_unichar_digit_value (gunichar c)
 642 {
 643   if (TYPE (c) == G_UNICODE_DECIMAL_NUMBER)
 644     return ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);
 645   return -1;
 646 }
 647 
 648 /**
 649  * g_unichar_xdigit_value:
 650  * @c: a Unicode character
 651  *
 652  * Determines the numeric value of a character as a hexidecimal
 653  * digit.
 654  *
 655  * Returns: If @c is a hex digit (according to
 656  * g_unichar_isxdigit()), its numeric value. Otherwise, -1.
 657  **/
 658 int
 659 g_unichar_xdigit_value (gunichar c)
 660 {
 661   if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;)
 662     return c - &#39;A&#39; + 10;
 663   if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;)
 664     return c - &#39;a&#39; + 10;
<a name="28" id="anc28"></a>



 665   if (TYPE (c) == G_UNICODE_DECIMAL_NUMBER)
 666     return ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);
 667   return -1;
 668 }
 669 
 670 /**
 671  * g_unichar_type:
 672  * @c: a Unicode character
 673  *
 674  * Classifies a Unicode character by type.
 675  *
 676  * Returns: the type of the character.
 677  **/
 678 GUnicodeType
 679 g_unichar_type (gunichar c)
 680 {
 681   return TYPE (c);
 682 }
 683 
 684 /*
 685  * Case mapping functions
 686  */
 687 
 688 typedef enum {
 689   LOCALE_NORMAL,
 690   LOCALE_TURKIC,
 691   LOCALE_LITHUANIAN
 692 } LocaleType;
 693 
 694 static LocaleType
 695 get_locale_type (void)
 696 {
 697 #ifdef G_OS_WIN32
 698   char *tem = g_win32_getlocale ();
 699   char locale[2];
 700 
 701   locale[0] = tem[0];
 702   locale[1] = tem[1];
 703   g_free (tem);
 704 #else
 705   const char *locale = setlocale (LC_CTYPE, NULL);
 706 
 707   if (locale == NULL)
 708     return LOCALE_NORMAL;
 709 #endif
 710 
 711   switch (locale[0])
 712     {
 713    case &#39;a&#39;:
 714       if (locale[1] == &#39;z&#39;)
<a name="29" id="anc29"></a><span class="line-modified"> 715     return LOCALE_TURKIC;</span>
 716       break;
 717     case &#39;l&#39;:
 718       if (locale[1] == &#39;t&#39;)
<a name="30" id="anc30"></a><span class="line-modified"> 719     return LOCALE_LITHUANIAN;</span>
 720       break;
 721     case &#39;t&#39;:
 722       if (locale[1] == &#39;r&#39;)
<a name="31" id="anc31"></a><span class="line-modified"> 723     return LOCALE_TURKIC;</span>
 724       break;
 725     }
 726 
 727   return LOCALE_NORMAL;
 728 }
 729 
 730 static gint
 731 output_marks (const char **p_inout,
<a name="32" id="anc32"></a><span class="line-modified"> 732           char        *out_buffer,</span>
<span class="line-modified"> 733           gboolean     remove_dot)</span>
 734 {
 735   const char *p = *p_inout;
 736   gint len = 0;
 737 
 738   while (*p)
 739     {
 740       gunichar c = g_utf8_get_char (p);
 741 
 742       if (ISMARK (TYPE (c)))
<a name="33" id="anc33"></a><span class="line-modified"> 743     {</span>
<span class="line-modified"> 744       if (!remove_dot || c != 0x307 /* COMBINING DOT ABOVE */)</span>
<span class="line-modified"> 745         len += g_unichar_to_utf8 (c, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-modified"> 746       p = g_utf8_next_char (p);</span>
<span class="line-modified"> 747     }</span>
 748       else
<a name="34" id="anc34"></a><span class="line-modified"> 749     break;</span>
 750     }
 751 
 752   *p_inout = p;
 753   return len;
 754 }
 755 
 756 static gint
 757 output_special_case (gchar *out_buffer,
<a name="35" id="anc35"></a><span class="line-modified"> 758              int    offset,</span>
<span class="line-modified"> 759              int    type,</span>
<span class="line-modified"> 760              int    which)</span>
 761 {
 762   const gchar *p = special_case_table + offset;
 763   gint len;
 764 
 765   if (type != G_UNICODE_TITLECASE_LETTER)
 766     p = g_utf8_next_char (p);
 767 
 768   if (which == 1)
 769     p += strlen (p) + 1;
 770 
 771   len = strlen (p);
 772   if (out_buffer)
 773     memcpy (out_buffer, p, len);
 774 
 775   return len;
 776 }
 777 
 778 static gsize
 779 real_toupper (const gchar *str,
<a name="36" id="anc36"></a><span class="line-modified"> 780           gssize       max_len,</span>
<span class="line-modified"> 781           gchar       *out_buffer,</span>
<span class="line-modified"> 782           LocaleType   locale_type)</span>
 783 {
 784   const gchar *p = str;
 785   const char *last = NULL;
 786   gsize len = 0;
 787   gboolean last_was_i = FALSE;
 788 
 789   while ((max_len &lt; 0 || p &lt; str + max_len) &amp;&amp; *p)
 790     {
 791       gunichar c = g_utf8_get_char (p);
 792       int t = TYPE (c);
 793       gunichar val;
 794 
 795       last = p;
 796       p = g_utf8_next_char (p);
 797 
 798       if (locale_type == LOCALE_LITHUANIAN)
<a name="37" id="anc37"></a>





 799     {
<a name="38" id="anc38"></a><span class="line-modified"> 800       if (c == &#39;i&#39;)</span>
<span class="line-modified"> 801         last_was_i = TRUE;</span>
<span class="line-modified"> 802       else</span>
<span class="line-modified"> 803         {</span>
<span class="line-modified"> 804           if (last_was_i)</span>
<span class="line-modified"> 805         {</span>
<span class="line-removed"> 806           /* Nasty, need to remove any dot above. Though</span>
<span class="line-removed"> 807            * I think only E WITH DOT ABOVE occurs in practice</span>
<span class="line-removed"> 808            * which could simplify this considerably.</span>
<span class="line-removed"> 809            */</span>
<span class="line-removed"> 810           gsize decomp_len, i;</span>
<span class="line-removed"> 811           gunichar decomp[G_UNICHAR_MAX_DECOMPOSITION_LENGTH];</span>
<span class="line-removed"> 812 </span>
<span class="line-removed"> 813           decomp_len = g_unichar_fully_decompose (c, FALSE, decomp, G_N_ELEMENTS (decomp));</span>
<span class="line-removed"> 814           for (i=0; i &lt; decomp_len; i++)</span>
<span class="line-removed"> 815             {</span>
<span class="line-removed"> 816               if (decomp[i] != 0x307 /* COMBINING DOT ABOVE */)</span>
<span class="line-removed"> 817             len += g_unichar_to_utf8 (g_unichar_toupper (decomp[i]), out_buffer ? out_buffer + len : NULL);</span>
<span class="line-removed"> 818             }</span>
<span class="line-removed"> 819 </span>
<span class="line-removed"> 820           len += output_marks (&amp;p, out_buffer ? out_buffer + len : NULL, TRUE);</span>
 821 
<a name="39" id="anc39"></a><span class="line-modified"> 822           continue;</span>




 823         }
 824 
<a name="40" id="anc40"></a><span class="line-modified"> 825           if (!ISMARK (t))</span>
<span class="line-modified"> 826         last_was_i = FALSE;</span>
<span class="line-modified"> 827         }</span>
 828     }
 829 
<a name="41" id="anc41"></a>




 830       if (locale_type == LOCALE_TURKIC &amp;&amp; c == &#39;i&#39;)
<a name="42" id="anc42"></a><span class="line-modified"> 831     {</span>
<span class="line-modified"> 832       /* i =&gt; LATIN CAPITAL LETTER I WITH DOT ABOVE */</span>
<span class="line-modified"> 833       len += g_unichar_to_utf8 (0x130, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-modified"> 834     }</span>
 835       else if (c == 0x0345) /* COMBINING GREEK YPOGEGRAMMENI */
<a name="43" id="anc43"></a><span class="line-modified"> 836     {</span>
<span class="line-modified"> 837       /* Nasty, need to move it after other combining marks .. this would go away if</span>
<span class="line-modified"> 838        * we normalized first.</span>
<span class="line-modified"> 839        */</span>
<span class="line-modified"> 840       len += output_marks (&amp;p, out_buffer ? out_buffer + len : NULL, FALSE);</span>
<span class="line-modified"> 841 </span>
<span class="line-modified"> 842       /* And output as GREEK CAPITAL LETTER IOTA */</span>
<span class="line-modified"> 843       len += g_unichar_to_utf8 (0x399, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-modified"> 844     }</span>
 845       else if (IS (t,
<a name="44" id="anc44"></a><span class="line-modified"> 846            OR (G_UNICODE_LOWERCASE_LETTER,</span>
<span class="line-modified"> 847            OR (G_UNICODE_TITLECASE_LETTER,</span>
<span class="line-modified"> 848           0))))</span>
<span class="line-modified"> 849     {</span>
<span class="line-modified"> 850       val = ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);</span>
 851 
<a name="45" id="anc45"></a><span class="line-modified"> 852       if (val &gt;= 0x1000000)</span>
<span class="line-modified"> 853         {</span>
<span class="line-modified"> 854           len += output_special_case (out_buffer ? out_buffer + len : NULL, val - 0x1000000, t,</span>
<span class="line-modified"> 855                       t == G_UNICODE_LOWERCASE_LETTER ? 0 : 1);</span>
<span class="line-modified"> 856         }</span>
<span class="line-modified"> 857       else</span>
<span class="line-modified"> 858         {</span>
<span class="line-modified"> 859           if (t == G_UNICODE_TITLECASE_LETTER)</span>



 860         {
<a name="46" id="anc46"></a><span class="line-modified"> 861           unsigned int i;</span>
<span class="line-modified"> 862           for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)</span>
<span class="line-modified"> 863             {</span>
<span class="line-modified"> 864               if (title_table[i][0] == c)</span>
<span class="line-modified"> 865             {</span>
<span class="line-removed"> 866               val = title_table[i][1];</span>
<span class="line-removed"> 867               break;</span>
<span class="line-removed"> 868             }</span>
<span class="line-removed"> 869             }</span>
<span class="line-removed"> 870         }</span>
<span class="line-removed"> 871 </span>
<span class="line-removed"> 872           /* Some lowercase letters, e.g., U+000AA, FEMININE ORDINAL INDICATOR,</span>
<span class="line-removed"> 873            * do not have an uppercase equivalent, in which case val will be</span>
<span class="line-removed"> 874            * zero. */</span>
<span class="line-removed"> 875           len += g_unichar_to_utf8 (val ? val : c, out_buffer ? out_buffer + len : NULL);</span>
 876         }
 877     }
<a name="47" id="anc47"></a>






 878       else
<a name="48" id="anc48"></a><span class="line-modified"> 879     {</span>
<span class="line-modified"> 880       gsize char_len = g_utf8_skip[*(guchar *)last];</span>
 881 
<a name="49" id="anc49"></a><span class="line-modified"> 882       if (out_buffer)</span>
<span class="line-modified"> 883         memcpy (out_buffer + len, last, char_len);</span>
 884 
<a name="50" id="anc50"></a><span class="line-modified"> 885       len += char_len;</span>
<span class="line-modified"> 886     }</span>
 887 
 888     }
 889 
 890   return len;
 891 }
 892 
 893 /**
 894  * g_utf8_strup:
 895  * @str: a UTF-8 encoded string
 896  * @len: length of @str, in bytes, or -1 if @str is nul-terminated.
 897  *
 898  * Converts all Unicode characters in the string that have a case
 899  * to uppercase. The exact manner that this is done depends
 900  * on the current locale, and may result in the number of
 901  * characters in the string increasing. (For instance, the
 902  * German ess-zet will be changed to SS.)
 903  *
 904  * Returns: a newly allocated string, with all characters
 905  *    converted to uppercase.
 906  **/
 907 gchar *
 908 g_utf8_strup (const gchar *str,
<a name="51" id="anc51"></a><span class="line-modified"> 909           gssize       len)</span>
 910 {
 911   gsize result_len;
 912   LocaleType locale_type;
 913   gchar *result;
 914 
 915   g_return_val_if_fail (str != NULL, NULL);
 916 
 917   locale_type = get_locale_type ();
 918 
 919   /*
 920    * We use a two pass approach to keep memory management simple
 921    */
 922   result_len = real_toupper (str, len, NULL, locale_type);
 923 #ifdef GSTREAMER_LITE
 924   if (result_len == 0)
 925     return NULL;
 926 #endif // GSTREAMER_LITE
 927   result = g_malloc (result_len + 1);
 928 #ifdef GSTREAMER_LITE
 929   if (result == NULL)
 930     return NULL;
 931 #endif // GSTREAMER_LITE
 932 #ifdef GSTREAMER_LITE
 933   if (real_toupper (str, len, result, locale_type) == 0)
 934     return NULL;
 935 #else // GSTREAMER_LITE
 936   real_toupper (str, len, result, locale_type);
 937 #endif // GSTREAMER_LITE
 938   result[result_len] = &#39;\0&#39;;
 939 
 940   return result;
 941 }
 942 
 943 /* traverses the string checking for characters with combining class == 230
 944  * until a base character is found */
 945 static gboolean
 946 has_more_above (const gchar *str)
 947 {
 948   const gchar *p = str;
 949   gint combining_class;
 950 
 951   while (*p)
 952     {
 953       combining_class = g_unichar_combining_class (g_utf8_get_char (p));
 954       if (combining_class == 230)
 955         return TRUE;
 956       else if (combining_class == 0)
 957         break;
 958 
 959       p = g_utf8_next_char (p);
 960     }
 961 
 962   return FALSE;
 963 }
 964 
 965 static gsize
 966 real_tolower (const gchar *str,
<a name="52" id="anc52"></a><span class="line-modified"> 967           gssize       max_len,</span>
<span class="line-modified"> 968           gchar       *out_buffer,</span>
<span class="line-modified"> 969           LocaleType   locale_type)</span>
 970 {
 971   const gchar *p = str;
 972   const char *last = NULL;
 973   gsize len = 0;
 974 
 975   while ((max_len &lt; 0 || p &lt; str + max_len) &amp;&amp; *p)
 976     {
 977       gunichar c = g_utf8_get_char (p);
 978       int t = TYPE (c);
 979       gunichar val;
 980 
 981       last = p;
 982       p = g_utf8_next_char (p);
 983 
<a name="53" id="anc53"></a><span class="line-modified"> 984       if (locale_type == LOCALE_TURKIC &amp;&amp; c == &#39;I&#39;)</span>
<span class="line-modified"> 985     {</span>

 986           if (g_utf8_get_char (p) == 0x0307)
 987             {
 988               /* I + COMBINING DOT ABOVE =&gt; i (U+0069) */
 989               len += g_unichar_to_utf8 (0x0069, out_buffer ? out_buffer + len : NULL);
 990               p = g_utf8_next_char (p);
 991             }
 992           else
 993             {
 994               /* I =&gt; LATIN SMALL LETTER DOTLESS I */
 995               len += g_unichar_to_utf8 (0x131, out_buffer ? out_buffer + len : NULL);
 996             }
 997         }
 998       /* Introduce an explicit dot above when lowercasing capital I&#39;s and J&#39;s
 999        * whenever there are more accents above. [SpecialCasing.txt] */
1000       else if (locale_type == LOCALE_LITHUANIAN &amp;&amp;
1001                (c == 0x00cc || c == 0x00cd || c == 0x0128))
1002         {
1003           len += g_unichar_to_utf8 (0x0069, out_buffer ? out_buffer + len : NULL);
1004           len += g_unichar_to_utf8 (0x0307, out_buffer ? out_buffer + len : NULL);
1005 
1006           switch (c)
1007             {
1008             case 0x00cc:
1009               len += g_unichar_to_utf8 (0x0300, out_buffer ? out_buffer + len : NULL);
1010               break;
1011             case 0x00cd:
1012               len += g_unichar_to_utf8 (0x0301, out_buffer ? out_buffer + len : NULL);
1013               break;
1014             case 0x0128:
1015               len += g_unichar_to_utf8 (0x0303, out_buffer ? out_buffer + len : NULL);
1016               break;
1017             }
1018         }
1019       else if (locale_type == LOCALE_LITHUANIAN &amp;&amp;
<a name="54" id="anc54"></a><span class="line-modified">1020                (c == &#39;I&#39; || c == &#39;J&#39; || c == 0x012e) &amp;&amp;</span>

1021                has_more_above (p))
1022         {
1023           len += g_unichar_to_utf8 (g_unichar_tolower (c), out_buffer ? out_buffer + len : NULL);
1024           len += g_unichar_to_utf8 (0x0307, out_buffer ? out_buffer + len : NULL);
1025         }
1026       else if (c == 0x03A3) /* GREEK CAPITAL LETTER SIGMA */
<a name="55" id="anc55"></a><span class="line-modified">1027     {</span>
<span class="line-modified">1028       if ((max_len &lt; 0 || p &lt; str + max_len) &amp;&amp; *p)</span>
<span class="line-modified">1029         {</span>
<span class="line-modified">1030           gunichar next_c = g_utf8_get_char (p);</span>
<span class="line-modified">1031           int next_type = TYPE(next_c);</span>
<span class="line-modified">1032 </span>
<span class="line-modified">1033           /* SIGMA mapps differently depending on whether it is</span>
<span class="line-modified">1034            * final or not. The following simplified test would</span>
<span class="line-modified">1035            * fail in the case of combining marks following the</span>
<span class="line-modified">1036            * sigma, but I don&#39;t think that occurs in real text.</span>
<span class="line-modified">1037            * The test here matches that in ICU.</span>
<span class="line-modified">1038            */</span>
<span class="line-modified">1039           if (ISALPHA (next_type)) /* Lu,Ll,Lt,Lm,Lo */</span>
<span class="line-modified">1040         val = 0x3c3;    /* GREEK SMALL SIGMA */</span>
<span class="line-modified">1041           else</span>
<span class="line-modified">1042         val = 0x3c2;    /* GREEK SMALL FINAL SIGMA */</span>
<span class="line-modified">1043         }</span>
<span class="line-modified">1044       else</span>
<span class="line-modified">1045         val = 0x3c2;    /* GREEK SMALL FINAL SIGMA */</span>
1046 
<a name="56" id="anc56"></a><span class="line-modified">1047       len += g_unichar_to_utf8 (val, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-modified">1048     }</span>
1049       else if (IS (t,
<a name="57" id="anc57"></a><span class="line-modified">1050            OR (G_UNICODE_UPPERCASE_LETTER,</span>
<span class="line-modified">1051            OR (G_UNICODE_TITLECASE_LETTER,</span>
<span class="line-modified">1052           0))))</span>
<span class="line-modified">1053     {</span>
<span class="line-modified">1054       val = ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);</span>
1055 
<a name="58" id="anc58"></a><span class="line-modified">1056       if (val &gt;= 0x1000000)</span>
<span class="line-modified">1057         {</span>
<span class="line-modified">1058           len += output_special_case (out_buffer ? out_buffer + len : NULL, val - 0x1000000, t, 0);</span>
<span class="line-modified">1059         }</span>
<span class="line-modified">1060       else</span>
<span class="line-modified">1061         {</span>
<span class="line-modified">1062           if (t == G_UNICODE_TITLECASE_LETTER)</span>



1063         {
<a name="59" id="anc59"></a><span class="line-modified">1064           unsigned int i;</span>
<span class="line-modified">1065           for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)</span>
<span class="line-modified">1066             {</span>
<span class="line-modified">1067               if (title_table[i][0] == c)</span>
<span class="line-modified">1068             {</span>
<span class="line-removed">1069               val = title_table[i][2];</span>
<span class="line-removed">1070               break;</span>
<span class="line-removed">1071             }</span>
<span class="line-removed">1072             }</span>
<span class="line-removed">1073         }</span>
<span class="line-removed">1074 </span>
<span class="line-removed">1075           /* Not all uppercase letters are guaranteed to have a lowercase</span>
<span class="line-removed">1076            * equivalent.  If this is the case, val will be zero. */</span>
<span class="line-removed">1077           len += g_unichar_to_utf8 (val ? val : c, out_buffer ? out_buffer + len : NULL);</span>
1078         }
1079     }
<a name="60" id="anc60"></a>





1080       else
<a name="61" id="anc61"></a><span class="line-modified">1081     {</span>
<span class="line-modified">1082       gsize char_len = g_utf8_skip[*(guchar *)last];</span>
1083 
<a name="62" id="anc62"></a><span class="line-modified">1084       if (out_buffer)</span>
<span class="line-modified">1085         memcpy (out_buffer + len, last, char_len);</span>
1086 
<a name="63" id="anc63"></a><span class="line-modified">1087       len += char_len;</span>
<span class="line-modified">1088     }</span>
1089 
1090     }
1091 
1092   return len;
1093 }
1094 
1095 /**
1096  * g_utf8_strdown:
1097  * @str: a UTF-8 encoded string
1098  * @len: length of @str, in bytes, or -1 if @str is nul-terminated.
1099  *
1100  * Converts all Unicode characters in the string that have a case
1101  * to lowercase. The exact manner that this is done depends
1102  * on the current locale, and may result in the number of
1103  * characters in the string changing.
1104  *
1105  * Returns: a newly allocated string, with all characters
1106  *    converted to lowercase.
1107  **/
1108 gchar *
1109 g_utf8_strdown (const gchar *str,
<a name="64" id="anc64"></a><span class="line-modified">1110         gssize       len)</span>
1111 {
1112   gsize result_len;
1113   LocaleType locale_type;
1114   gchar *result;
1115 
1116   g_return_val_if_fail (str != NULL, NULL);
1117 
1118   locale_type = get_locale_type ();
1119 
1120   /*
1121    * We use a two pass approach to keep memory management simple
1122    */
1123   result_len = real_tolower (str, len, NULL, locale_type);
1124   result = g_malloc (result_len + 1);
1125 #ifdef GSTREAMER_LITE
1126   if (result == NULL)
1127       return NULL;
1128 #endif // GSTREAMER_LITE
1129   real_tolower (str, len, result, locale_type);
1130   result[result_len] = &#39;\0&#39;;
1131 
1132   return result;
1133 }
1134 
1135 /**
1136  * g_utf8_casefold:
1137  * @str: a UTF-8 encoded string
1138  * @len: length of @str, in bytes, or -1 if @str is nul-terminated.
1139  *
1140  * Converts a string into a form that is independent of case. The
1141  * result will not correspond to any particular case, but can be
1142  * compared for equality or ordered with the results of calling
1143  * g_utf8_casefold() on other strings.
1144  *
1145  * Note that calling g_utf8_casefold() followed by g_utf8_collate() is
1146  * only an approximation to the correct linguistic case insensitive
1147  * ordering, though it is a fairly good one. Getting this exactly
1148  * right would require a more sophisticated collation function that
1149  * takes case sensitivity into account. GLib does not currently
1150  * provide such a function.
1151  *
1152  * Returns: a newly allocated string, that is a
1153  *   case independent form of @str.
1154  **/
1155 gchar *
1156 g_utf8_casefold (const gchar *str,
<a name="65" id="anc65"></a><span class="line-modified">1157          gssize       len)</span>
1158 {
1159   GString *result;
1160   const char *p;
1161 
1162   g_return_val_if_fail (str != NULL, NULL);
1163 
1164   result = g_string_new (NULL);
1165   p = str;
1166   while ((len &lt; 0 || p &lt; str + len) &amp;&amp; *p)
1167     {
1168       gunichar ch = g_utf8_get_char (p);
1169 
1170       int start = 0;
1171       int end = G_N_ELEMENTS (casefold_table);
1172 
1173       if (ch &gt;= casefold_table[start].ch &amp;&amp;
1174           ch &lt;= casefold_table[end - 1].ch)
<a name="66" id="anc66"></a>




1175     {
<a name="67" id="anc67"></a><span class="line-modified">1176       while (TRUE)</span>
<span class="line-modified">1177         {</span>
<span class="line-removed">1178           int half = (start + end) / 2;</span>
<span class="line-removed">1179           if (ch == casefold_table[half].ch)</span>
<span class="line-removed">1180         {</span>
<span class="line-removed">1181           g_string_append (result, casefold_table[half].data);</span>
<span class="line-removed">1182           goto next;</span>
<span class="line-removed">1183         }</span>
<span class="line-removed">1184           else if (half == start)</span>
<span class="line-removed">1185         break;</span>
<span class="line-removed">1186           else if (ch &gt; casefold_table[half].ch)</span>
<span class="line-removed">1187         start = half;</span>
<span class="line-removed">1188           else</span>
<span class="line-removed">1189         end = half;</span>
<span class="line-removed">1190         }</span>
1191     }
<a name="68" id="anc68"></a>







1192 
1193       g_string_append_unichar (result, g_unichar_tolower (ch));
1194 
1195     next:
1196       p = g_utf8_next_char (p);
1197     }
1198 
1199   return g_string_free (result, FALSE);
1200 }
1201 
1202 /**
1203  * g_unichar_get_mirror_char:
1204  * @ch: a Unicode character
1205  * @mirrored_ch: location to store the mirrored character
1206  *
1207  * In Unicode, some characters are &quot;mirrored&quot;. This means that their
1208  * images are mirrored horizontally in text that is laid out from right
1209  * to left. For instance, &quot;(&quot; would become its mirror image, &quot;)&quot;, in
1210  * right-to-left text.
1211  *
1212  * If @ch has the Unicode mirrored property and there is another unicode
1213  * character that typically has a glyph that is the mirror image of @ch&#39;s
1214  * glyph and @mirrored_ch is set, it puts that character in the address
1215  * pointed to by @mirrored_ch.  Otherwise the original character is put.
1216  *
1217  * Returns: %TRUE if @ch has a mirrored character, %FALSE otherwise
1218  *
1219  * Since: 2.4
1220  **/
1221 gboolean
1222 g_unichar_get_mirror_char (gunichar ch,
1223                            gunichar *mirrored_ch)
1224 {
1225   gboolean found;
1226   gunichar mirrored;
1227 
1228   mirrored = GLIB_GET_MIRRORING(ch);
1229 
1230   found = ch != mirrored;
1231   if (mirrored_ch)
1232     *mirrored_ch = mirrored;
1233 
1234   return found;
1235 
1236 }
1237 
1238 #define G_SCRIPT_TABLE_MIDPOINT (G_N_ELEMENTS (g_script_table) / 2)
1239 
1240 static inline GUnicodeScript
1241 g_unichar_get_script_bsearch (gunichar ch)
1242 {
1243   int lower = 0;
1244   int upper = G_N_ELEMENTS (g_script_table) - 1;
1245   static int saved_mid = G_SCRIPT_TABLE_MIDPOINT;
1246   int mid = saved_mid;
1247 
1248 
1249   do
1250     {
1251       if (ch &lt; g_script_table[mid].start)
<a name="69" id="anc69"></a><span class="line-modified">1252     upper = mid - 1;</span>
1253       else if (ch &gt;= g_script_table[mid].start + g_script_table[mid].chars)
<a name="70" id="anc70"></a><span class="line-modified">1254     lower = mid + 1;</span>
1255       else
<a name="71" id="anc71"></a><span class="line-modified">1256     return g_script_table[saved_mid = mid].script;</span>
1257 
1258       mid = (lower + upper) / 2;
1259     }
1260   while (lower &lt;= upper);
1261 
1262   return G_UNICODE_SCRIPT_UNKNOWN;
1263 }
1264 
1265 /**
1266  * g_unichar_get_script:
1267  * @ch: a Unicode character
1268  *
1269  * Looks up the #GUnicodeScript for a particular character (as defined
1270  * by Unicode Standard Annex \#24). No check is made for @ch being a
1271  * valid Unicode character; if you pass in invalid character, the
1272  * result is undefined.
1273  *
1274  * This function is equivalent to pango_script_for_unichar() and the
1275  * two are interchangeable.
1276  *
1277  * Returns: the #GUnicodeScript for the character.
1278  *
1279  * Since: 2.14
1280  */
1281 GUnicodeScript
1282 g_unichar_get_script (gunichar ch)
1283 {
1284   if (ch &lt; G_EASY_SCRIPTS_RANGE)
1285     return g_script_easy_table[ch];
1286   else
1287     return g_unichar_get_script_bsearch (ch);
1288 }
1289 
1290 
1291 /* http://unicode.org/iso15924/ */
1292 static const guint32 iso15924_tags[] =
1293 {
1294 #define PACK(a,b,c,d) ((guint32)((((guint8)(a))&lt;&lt;24)|(((guint8)(b))&lt;&lt;16)|(((guint8)(c))&lt;&lt;8)|((guint8)(d))))
1295 
1296     PACK (&#39;Z&#39;,&#39;y&#39;,&#39;y&#39;,&#39;y&#39;), /* G_UNICODE_SCRIPT_COMMON */
1297     PACK (&#39;Z&#39;,&#39;i&#39;,&#39;n&#39;,&#39;h&#39;), /* G_UNICODE_SCRIPT_INHERITED */
1298     PACK (&#39;A&#39;,&#39;r&#39;,&#39;a&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_ARABIC */
1299     PACK (&#39;A&#39;,&#39;r&#39;,&#39;m&#39;,&#39;n&#39;), /* G_UNICODE_SCRIPT_ARMENIAN */
1300     PACK (&#39;B&#39;,&#39;e&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_BENGALI */
1301     PACK (&#39;B&#39;,&#39;o&#39;,&#39;p&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_BOPOMOFO */
1302     PACK (&#39;C&#39;,&#39;h&#39;,&#39;e&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_CHEROKEE */
1303     PACK (&#39;C&#39;,&#39;o&#39;,&#39;p&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_COPTIC */
1304     PACK (&#39;C&#39;,&#39;y&#39;,&#39;r&#39;,&#39;l&#39;), /* G_UNICODE_SCRIPT_CYRILLIC */
1305     PACK (&#39;D&#39;,&#39;s&#39;,&#39;r&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_DESERET */
1306     PACK (&#39;D&#39;,&#39;e&#39;,&#39;v&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_DEVANAGARI */
1307     PACK (&#39;E&#39;,&#39;t&#39;,&#39;h&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_ETHIOPIC */
1308     PACK (&#39;G&#39;,&#39;e&#39;,&#39;o&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_GEORGIAN */
1309     PACK (&#39;G&#39;,&#39;o&#39;,&#39;t&#39;,&#39;h&#39;), /* G_UNICODE_SCRIPT_GOTHIC */
1310     PACK (&#39;G&#39;,&#39;r&#39;,&#39;e&#39;,&#39;k&#39;), /* G_UNICODE_SCRIPT_GREEK */
1311     PACK (&#39;G&#39;,&#39;u&#39;,&#39;j&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_GUJARATI */
1312     PACK (&#39;G&#39;,&#39;u&#39;,&#39;r&#39;,&#39;u&#39;), /* G_UNICODE_SCRIPT_GURMUKHI */
1313     PACK (&#39;H&#39;,&#39;a&#39;,&#39;n&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_HAN */
1314     PACK (&#39;H&#39;,&#39;a&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_HANGUL */
1315     PACK (&#39;H&#39;,&#39;e&#39;,&#39;b&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_HEBREW */
1316     PACK (&#39;H&#39;,&#39;i&#39;,&#39;r&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_HIRAGANA */
1317     PACK (&#39;K&#39;,&#39;n&#39;,&#39;d&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_KANNADA */
1318     PACK (&#39;K&#39;,&#39;a&#39;,&#39;n&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_KATAKANA */
1319     PACK (&#39;K&#39;,&#39;h&#39;,&#39;m&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_KHMER */
1320     PACK (&#39;L&#39;,&#39;a&#39;,&#39;o&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_LAO */
1321     PACK (&#39;L&#39;,&#39;a&#39;,&#39;t&#39;,&#39;n&#39;), /* G_UNICODE_SCRIPT_LATIN */
1322     PACK (&#39;M&#39;,&#39;l&#39;,&#39;y&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_MALAYALAM */
1323     PACK (&#39;M&#39;,&#39;o&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_MONGOLIAN */
1324     PACK (&#39;M&#39;,&#39;y&#39;,&#39;m&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_MYANMAR */
1325     PACK (&#39;O&#39;,&#39;g&#39;,&#39;a&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_OGHAM */
1326     PACK (&#39;I&#39;,&#39;t&#39;,&#39;a&#39;,&#39;l&#39;), /* G_UNICODE_SCRIPT_OLD_ITALIC */
1327     PACK (&#39;O&#39;,&#39;r&#39;,&#39;y&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_ORIYA */
1328     PACK (&#39;R&#39;,&#39;u&#39;,&#39;n&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_RUNIC */
1329     PACK (&#39;S&#39;,&#39;i&#39;,&#39;n&#39;,&#39;h&#39;), /* G_UNICODE_SCRIPT_SINHALA */
1330     PACK (&#39;S&#39;,&#39;y&#39;,&#39;r&#39;,&#39;c&#39;), /* G_UNICODE_SCRIPT_SYRIAC */
1331     PACK (&#39;T&#39;,&#39;a&#39;,&#39;m&#39;,&#39;l&#39;), /* G_UNICODE_SCRIPT_TAMIL */
1332     PACK (&#39;T&#39;,&#39;e&#39;,&#39;l&#39;,&#39;u&#39;), /* G_UNICODE_SCRIPT_TELUGU */
1333     PACK (&#39;T&#39;,&#39;h&#39;,&#39;a&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_THAANA */
1334     PACK (&#39;T&#39;,&#39;h&#39;,&#39;a&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_THAI */
1335     PACK (&#39;T&#39;,&#39;i&#39;,&#39;b&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_TIBETAN */
1336     PACK (&#39;C&#39;,&#39;a&#39;,&#39;n&#39;,&#39;s&#39;), /* G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL */
1337     PACK (&#39;Y&#39;,&#39;i&#39;,&#39;i&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_YI */
1338     PACK (&#39;T&#39;,&#39;g&#39;,&#39;l&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_TAGALOG */
1339     PACK (&#39;H&#39;,&#39;a&#39;,&#39;n&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_HANUNOO */
1340     PACK (&#39;B&#39;,&#39;u&#39;,&#39;h&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_BUHID */
1341     PACK (&#39;T&#39;,&#39;a&#39;,&#39;g&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_TAGBANWA */
1342 
1343   /* Unicode-4.0 additions */
1344     PACK (&#39;B&#39;,&#39;r&#39;,&#39;a&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_BRAILLE */
1345     PACK (&#39;C&#39;,&#39;p&#39;,&#39;r&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_CYPRIOT */
1346     PACK (&#39;L&#39;,&#39;i&#39;,&#39;m&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_LIMBU */
1347     PACK (&#39;O&#39;,&#39;s&#39;,&#39;m&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_OSMANYA */
1348     PACK (&#39;S&#39;,&#39;h&#39;,&#39;a&#39;,&#39;w&#39;), /* G_UNICODE_SCRIPT_SHAVIAN */
1349     PACK (&#39;L&#39;,&#39;i&#39;,&#39;n&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_LINEAR_B */
1350     PACK (&#39;T&#39;,&#39;a&#39;,&#39;l&#39;,&#39;e&#39;), /* G_UNICODE_SCRIPT_TAI_LE */
1351     PACK (&#39;U&#39;,&#39;g&#39;,&#39;a&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_UGARITIC */
1352 
1353   /* Unicode-4.1 additions */
1354     PACK (&#39;T&#39;,&#39;a&#39;,&#39;l&#39;,&#39;u&#39;), /* G_UNICODE_SCRIPT_NEW_TAI_LUE */
1355     PACK (&#39;B&#39;,&#39;u&#39;,&#39;g&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_BUGINESE */
1356     PACK (&#39;G&#39;,&#39;l&#39;,&#39;a&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_GLAGOLITIC */
1357     PACK (&#39;T&#39;,&#39;f&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_TIFINAGH */
1358     PACK (&#39;S&#39;,&#39;y&#39;,&#39;l&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_SYLOTI_NAGRI */
1359     PACK (&#39;X&#39;,&#39;p&#39;,&#39;e&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_OLD_PERSIAN */
1360     PACK (&#39;K&#39;,&#39;h&#39;,&#39;a&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_KHAROSHTHI */
1361 
1362   /* Unicode-5.0 additions */
1363     PACK (&#39;Z&#39;,&#39;z&#39;,&#39;z&#39;,&#39;z&#39;), /* G_UNICODE_SCRIPT_UNKNOWN */
1364     PACK (&#39;B&#39;,&#39;a&#39;,&#39;l&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_BALINESE */
1365     PACK (&#39;X&#39;,&#39;s&#39;,&#39;u&#39;,&#39;x&#39;), /* G_UNICODE_SCRIPT_CUNEIFORM */
1366     PACK (&#39;P&#39;,&#39;h&#39;,&#39;n&#39;,&#39;x&#39;), /* G_UNICODE_SCRIPT_PHOENICIAN */
1367     PACK (&#39;P&#39;,&#39;h&#39;,&#39;a&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_PHAGS_PA */
1368     PACK (&#39;N&#39;,&#39;k&#39;,&#39;o&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_NKO */
1369 
1370   /* Unicode-5.1 additions */
1371     PACK (&#39;K&#39;,&#39;a&#39;,&#39;l&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_KAYAH_LI */
1372     PACK (&#39;L&#39;,&#39;e&#39;,&#39;p&#39;,&#39;c&#39;), /* G_UNICODE_SCRIPT_LEPCHA */
1373     PACK (&#39;R&#39;,&#39;j&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_REJANG */
1374     PACK (&#39;S&#39;,&#39;u&#39;,&#39;n&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_SUNDANESE */
1375     PACK (&#39;S&#39;,&#39;a&#39;,&#39;u&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_SAURASHTRA */
1376     PACK (&#39;C&#39;,&#39;h&#39;,&#39;a&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_CHAM */
1377     PACK (&#39;O&#39;,&#39;l&#39;,&#39;c&#39;,&#39;k&#39;), /* G_UNICODE_SCRIPT_OL_CHIKI */
1378     PACK (&#39;V&#39;,&#39;a&#39;,&#39;i&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_VAI */
1379     PACK (&#39;C&#39;,&#39;a&#39;,&#39;r&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_CARIAN */
1380     PACK (&#39;L&#39;,&#39;y&#39;,&#39;c&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_LYCIAN */
1381     PACK (&#39;L&#39;,&#39;y&#39;,&#39;d&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_LYDIAN */
1382 
1383   /* Unicode-5.2 additions */
1384     PACK (&#39;A&#39;,&#39;v&#39;,&#39;s&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_AVESTAN */
1385     PACK (&#39;B&#39;,&#39;a&#39;,&#39;m&#39;,&#39;u&#39;), /* G_UNICODE_SCRIPT_BAMUM */
1386     PACK (&#39;E&#39;,&#39;g&#39;,&#39;y&#39;,&#39;p&#39;), /* G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS */
1387     PACK (&#39;A&#39;,&#39;r&#39;,&#39;m&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC */
1388     PACK (&#39;P&#39;,&#39;h&#39;,&#39;l&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI */
1389     PACK (&#39;P&#39;,&#39;r&#39;,&#39;t&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN */
1390     PACK (&#39;J&#39;,&#39;a&#39;,&#39;v&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_JAVANESE */
1391     PACK (&#39;K&#39;,&#39;t&#39;,&#39;h&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_KAITHI */
1392     PACK (&#39;L&#39;,&#39;i&#39;,&#39;s&#39;,&#39;u&#39;), /* G_UNICODE_SCRIPT_LISU */
1393     PACK (&#39;M&#39;,&#39;t&#39;,&#39;e&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_MEETEI_MAYEK */
1394     PACK (&#39;S&#39;,&#39;a&#39;,&#39;r&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN */
1395     PACK (&#39;O&#39;,&#39;r&#39;,&#39;k&#39;,&#39;h&#39;), /* G_UNICODE_SCRIPT_OLD_TURKIC */
1396     PACK (&#39;S&#39;,&#39;a&#39;,&#39;m&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_SAMARITAN */
1397     PACK (&#39;L&#39;,&#39;a&#39;,&#39;n&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_TAI_THAM */
1398     PACK (&#39;T&#39;,&#39;a&#39;,&#39;v&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_TAI_VIET */
1399 
1400   /* Unicode-6.0 additions */
1401     PACK (&#39;B&#39;,&#39;a&#39;,&#39;t&#39;,&#39;k&#39;), /* G_UNICODE_SCRIPT_BATAK */
1402     PACK (&#39;B&#39;,&#39;r&#39;,&#39;a&#39;,&#39;h&#39;), /* G_UNICODE_SCRIPT_BRAHMI */
1403     PACK (&#39;M&#39;,&#39;a&#39;,&#39;n&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_MANDAIC */
1404 
1405   /* Unicode-6.1 additions */
1406     PACK (&#39;C&#39;,&#39;a&#39;,&#39;k&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_CHAKMA */
1407     PACK (&#39;M&#39;,&#39;e&#39;,&#39;r&#39;,&#39;c&#39;), /* G_UNICODE_SCRIPT_MEROITIC_CURSIVE */
1408     PACK (&#39;M&#39;,&#39;e&#39;,&#39;r&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS */
1409     PACK (&#39;P&#39;,&#39;l&#39;,&#39;r&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_MIAO */
1410     PACK (&#39;S&#39;,&#39;h&#39;,&#39;r&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_SHARADA */
1411     PACK (&#39;S&#39;,&#39;o&#39;,&#39;r&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_SORA_SOMPENG */
1412     PACK (&#39;T&#39;,&#39;a&#39;,&#39;k&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_TAKRI */
1413 
1414   /* Unicode 7.0 additions */
1415     PACK (&#39;B&#39;,&#39;a&#39;,&#39;s&#39;,&#39;s&#39;), /* G_UNICODE_SCRIPT_BASSA_VAH */
1416     PACK (&#39;A&#39;,&#39;g&#39;,&#39;h&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN */
1417     PACK (&#39;D&#39;,&#39;u&#39;,&#39;p&#39;,&#39;l&#39;), /* G_UNICODE_SCRIPT_DUPLOYAN */
1418     PACK (&#39;E&#39;,&#39;l&#39;,&#39;b&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_ELBASAN */
1419     PACK (&#39;G&#39;,&#39;r&#39;,&#39;a&#39;,&#39;n&#39;), /* G_UNICODE_SCRIPT_GRANTHA */
1420     PACK (&#39;K&#39;,&#39;h&#39;,&#39;o&#39;,&#39;j&#39;), /* G_UNICODE_SCRIPT_KHOJKI*/
1421     PACK (&#39;S&#39;,&#39;i&#39;,&#39;n&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_KHUDAWADI */
1422     PACK (&#39;L&#39;,&#39;i&#39;,&#39;n&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_LINEAR_A */
1423     PACK (&#39;M&#39;,&#39;a&#39;,&#39;h&#39;,&#39;j&#39;), /* G_UNICODE_SCRIPT_MAHAJANI */
<a name="72" id="anc72"></a><span class="line-modified">1424     PACK (&#39;M&#39;,&#39;a&#39;,&#39;n&#39;,&#39;u&#39;), /* G_UNICODE_SCRIPT_MANICHAEAN */</span>
1425     PACK (&#39;M&#39;,&#39;e&#39;,&#39;n&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_MENDE_KIKAKUI */
1426     PACK (&#39;M&#39;,&#39;o&#39;,&#39;d&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_MODI */
1427     PACK (&#39;M&#39;,&#39;r&#39;,&#39;o&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_MRO */
1428     PACK (&#39;N&#39;,&#39;b&#39;,&#39;a&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_NABATAEAN */
1429     PACK (&#39;N&#39;,&#39;a&#39;,&#39;r&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN */
1430     PACK (&#39;P&#39;,&#39;e&#39;,&#39;r&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_OLD_PERMIC */
1431     PACK (&#39;H&#39;,&#39;m&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_PAHAWH_HMONG */
1432     PACK (&#39;P&#39;,&#39;a&#39;,&#39;l&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_PALMYRENE */
1433     PACK (&#39;P&#39;,&#39;a&#39;,&#39;u&#39;,&#39;c&#39;), /* G_UNICODE_SCRIPT_PAU_CIN_HAU */
1434     PACK (&#39;P&#39;,&#39;h&#39;,&#39;l&#39;,&#39;p&#39;), /* G_UNICODE_SCRIPT_PSALTER_PAHLAVI */
1435     PACK (&#39;S&#39;,&#39;i&#39;,&#39;d&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_SIDDHAM */
1436     PACK (&#39;T&#39;,&#39;i&#39;,&#39;r&#39;,&#39;h&#39;), /* G_UNICODE_SCRIPT_TIRHUTA */
1437     PACK (&#39;W&#39;,&#39;a&#39;,&#39;r&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_WARANG_CITI */
1438 
1439   /* Unicode 8.0 additions */
1440     PACK (&#39;A&#39;,&#39;h&#39;,&#39;o&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_AHOM */
1441     PACK (&#39;H&#39;,&#39;l&#39;,&#39;u&#39;,&#39;w&#39;), /* G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS */
1442     PACK (&#39;H&#39;,&#39;a&#39;,&#39;t&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_HATRAN */
1443     PACK (&#39;M&#39;,&#39;u&#39;,&#39;l&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_MULTANI */
1444     PACK (&#39;H&#39;,&#39;u&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_OLD_HUNGARIAN */
1445     PACK (&#39;S&#39;,&#39;g&#39;,&#39;n&#39;,&#39;w&#39;), /* G_UNICODE_SCRIPT_SIGNWRITING */
1446 
1447   /* Unicode 9.0 additions */
1448     PACK (&#39;A&#39;,&#39;d&#39;,&#39;l&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_ADLAM */
1449     PACK (&#39;B&#39;,&#39;h&#39;,&#39;k&#39;,&#39;s&#39;), /* G_UNICODE_SCRIPT_BHAIKSUKI */
1450     PACK (&#39;M&#39;,&#39;a&#39;,&#39;r&#39;,&#39;c&#39;), /* G_UNICODE_SCRIPT_MARCHEN */
1451     PACK (&#39;N&#39;,&#39;e&#39;,&#39;w&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_NEWA */
1452     PACK (&#39;O&#39;,&#39;s&#39;,&#39;g&#39;,&#39;e&#39;), /* G_UNICODE_SCRIPT_OSAGE */
1453     PACK (&#39;T&#39;,&#39;a&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_TANGUT */
1454 
1455   /* Unicode 10.0 additions */
1456     PACK (&#39;G&#39;,&#39;o&#39;,&#39;n&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_MASARAM_GONDI */
1457     PACK (&#39;N&#39;,&#39;s&#39;,&#39;h&#39;,&#39;u&#39;), /* G_UNICODE_SCRIPT_NUSHU */
1458     PACK (&#39;S&#39;,&#39;o&#39;,&#39;y&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_SOYOMBO */
1459     PACK (&#39;Z&#39;,&#39;a&#39;,&#39;n&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_ZANABAZAR_SQUARE */
1460 
1461   /* Unicode 11.0 additions */
1462     PACK (&#39;D&#39;,&#39;o&#39;,&#39;g&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_DOGRA */
1463     PACK (&#39;G&#39;,&#39;o&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_GUNJALA_GONDI */
1464     PACK (&#39;R&#39;,&#39;o&#39;,&#39;h&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_HANIFI_ROHINGYA */
1465     PACK (&#39;M&#39;,&#39;a&#39;,&#39;k&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_MAKASAR */
1466     PACK (&#39;M&#39;,&#39;e&#39;,&#39;d&#39;,&#39;f&#39;), /* G_UNICODE_SCRIPT_MEDEFAIDRIN */
1467     PACK (&#39;S&#39;,&#39;o&#39;,&#39;g&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_OLD_SOGDIAN */
1468     PACK (&#39;S&#39;,&#39;o&#39;,&#39;g&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_SOGDIAN */
<a name="73" id="anc73"></a>





1469 #undef PACK
1470 };
1471 
1472 /**
1473  * g_unicode_script_to_iso15924:
1474  * @script: a Unicode script
1475  *
1476  * Looks up the ISO 15924 code for @script.  ISO 15924 assigns four-letter
1477  * codes to scripts.  For example, the code for Arabic is &#39;Arab&#39;.  The
1478  * four letter codes are encoded as a @guint32 by this function in a
1479  * big-endian fashion.  That is, the code returned for Arabic is
1480  * 0x41726162 (0x41 is ASCII code for &#39;A&#39;, 0x72 is ASCII code for &#39;r&#39;, etc).
1481  *
1482  * See
1483  * [Codes for the representation of names of scripts](http://unicode.org/iso15924/codelists.html)
1484  * for details.
1485  *
1486  * Returns: the ISO 15924 code for @script, encoded as an integer,
1487  *   of zero if @script is %G_UNICODE_SCRIPT_INVALID_CODE or
1488  *   ISO 15924 code &#39;Zzzz&#39; (script code for UNKNOWN) if @script is not understood.
1489  *
1490  * Since: 2.30
1491  */
1492 guint32
1493 g_unicode_script_to_iso15924 (GUnicodeScript script)
1494 {
1495   if (G_UNLIKELY (script == G_UNICODE_SCRIPT_INVALID_CODE))
1496     return 0;
1497 
1498   if (G_UNLIKELY (script &lt; 0 || script &gt;= (int) G_N_ELEMENTS (iso15924_tags)))
1499     return 0x5A7A7A7A;
1500 
1501   return iso15924_tags[script];
1502 }
1503 
1504 /**
1505  * g_unicode_script_from_iso15924:
1506  * @iso15924: a Unicode script
1507  *
1508  * Looks up the Unicode script for @iso15924.  ISO 15924 assigns four-letter
1509  * codes to scripts.  For example, the code for Arabic is &#39;Arab&#39;.
1510  * This function accepts four letter codes encoded as a @guint32 in a
1511  * big-endian fashion.  That is, the code expected for Arabic is
1512  * 0x41726162 (0x41 is ASCII code for &#39;A&#39;, 0x72 is ASCII code for &#39;r&#39;, etc).
1513  *
1514  * See
1515  * [Codes for the representation of names of scripts](http://unicode.org/iso15924/codelists.html)
1516  * for details.
1517  *
1518  * Returns: the Unicode script for @iso15924, or
1519  *   of %G_UNICODE_SCRIPT_INVALID_CODE if @iso15924 is zero and
1520  *   %G_UNICODE_SCRIPT_UNKNOWN if @iso15924 is unknown.
1521  *
1522  * Since: 2.30
1523  */
1524 GUnicodeScript
1525 g_unicode_script_from_iso15924 (guint32 iso15924)
1526 {
1527   unsigned int i;
1528 
1529    if (!iso15924)
1530      return G_UNICODE_SCRIPT_INVALID_CODE;
1531 
1532   for (i = 0; i &lt; G_N_ELEMENTS (iso15924_tags); i++)
1533     if (iso15924_tags[i] == iso15924)
1534       return (GUnicodeScript) i;
1535 
1536   return G_UNICODE_SCRIPT_UNKNOWN;
1537 }
<a name="74" id="anc74"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="74" type="hidden" />
</body>
</html>