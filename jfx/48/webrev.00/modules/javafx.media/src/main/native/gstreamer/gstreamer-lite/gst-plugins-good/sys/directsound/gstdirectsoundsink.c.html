<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/sys/directsound/gstdirectsoundsink.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2 * Copyright (C) 2005 Sebastien Moutte &lt;sebastien@moutte.net&gt;
   3 * Copyright (C) 2007 Pioneers of the Inevitable &lt;songbird@songbirdnest.com&gt;
   4 * Copyright (C) 2010 Fluendo S.A. &lt;support@fluendo.com&gt;
   5 *
   6 * gstdirectsoundsink.c:
   7 *
   8 * This library is free software; you can redistribute it and/or
   9 * modify it under the terms of the GNU Library General Public
  10 * License as published by the Free Software Foundation; either
  11 * version 2 of the License, or (at your option) any later version.
  12 *
  13 * This library is distributed in the hope that it will be useful,
  14 * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16 * Library General Public License for more details.
  17 *
  18 * You should have received a copy of the GNU Library General Public
  19 * License along with this library; if not, write to the
  20 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  21 * Boston, MA 02110-1301, USA.
  22 *
  23 *
  24 * The development of this code was made possible due to the involvement
  25 * of Pioneers of the Inevitable, the creators of the Songbird Music player
  26 *
  27 */
  28 
  29 /**
  30  * SECTION:element-directsoundsink
  31  *
  32  * This element lets you output sound using the DirectSound API.
  33  *
  34  * Note that you should almost always use generic audio conversion elements
  35  * like audioconvert and audioresample in front of an audiosink to make sure
  36  * your pipeline works under all circumstances (those conversion elements will
  37  * act in passthrough-mode if no conversion is necessary).
  38  *
  39  * &lt;refsect2&gt;
  40  * &lt;title&gt;Example pipelines&lt;/title&gt;
  41  * |[
  42  * gst-launch-1.0 -v audiotestsrc ! audioconvert ! volume volume=0.1 ! directsoundsink
  43  * ]| will output a sine wave (continuous beep sound) to your sound card (with
  44  * a very low volume as precaution).
  45  * |[
  46  * gst-launch-1.0 -v filesrc location=music.ogg ! decodebin ! audioconvert ! audioresample ! directsoundsink
  47  * ]| will play an Ogg/Vorbis audio file and output it.
  48  * &lt;/refsect2&gt;
  49  */
  50 
  51 #ifdef HAVE_CONFIG_H
  52 #include &quot;config.h&quot;
  53 #endif
  54 
  55 #include &lt;gst/base/gstbasesink.h&gt;
  56 #include &quot;gstdirectsoundsink.h&quot;
  57 #include &lt;gst/audio/gstaudioiec61937.h&gt;
  58 
  59 #include &lt;math.h&gt;
  60 
  61 #ifdef __CYGWIN__
  62 #include &lt;unistd.h&gt;
  63 #ifndef _swab
  64 #define _swab swab
  65 #endif
  66 #endif
  67 
  68 #define DEFAULT_MUTE FALSE
  69 
  70 GST_DEBUG_CATEGORY_STATIC (directsoundsink_debug);
  71 #define GST_CAT_DEFAULT directsoundsink_debug
  72 
  73 static void gst_directsound_sink_finalize (GObject * object);
  74 
  75 static void gst_directsound_sink_set_property (GObject * object, guint prop_id,
  76     const GValue * value, GParamSpec * pspec);
  77 static void gst_directsound_sink_get_property (GObject * object, guint prop_id,
  78     GValue * value, GParamSpec * pspec);
  79 
  80 static GstCaps *gst_directsound_sink_getcaps (GstBaseSink * bsink,
  81     GstCaps * filter);
  82 static GstBuffer *gst_directsound_sink_payload (GstAudioBaseSink * sink,
  83     GstBuffer * buf);
  84 static gboolean gst_directsound_sink_prepare (GstAudioSink * asink,
  85     GstAudioRingBufferSpec * spec);
  86 static gboolean gst_directsound_sink_unprepare (GstAudioSink * asink);
  87 static gboolean gst_directsound_sink_open (GstAudioSink * asink);
  88 static gboolean gst_directsound_sink_close (GstAudioSink * asink);
  89 static gint gst_directsound_sink_write (GstAudioSink * asink,
  90     gpointer data, guint length);
  91 static guint gst_directsound_sink_delay (GstAudioSink * asink);
  92 static void gst_directsound_sink_reset (GstAudioSink * asink);
  93 static GstCaps *gst_directsound_probe_supported_formats (GstDirectSoundSink *
  94     dsoundsink, const GstCaps * template_caps);
  95 static gboolean gst_directsound_sink_query (GstBaseSink * pad,
  96     GstQuery * query);
  97 
  98 static void gst_directsound_sink_set_volume (GstDirectSoundSink * sink,
  99     gdouble volume, gboolean store);
 100 static gdouble gst_directsound_sink_get_volume (GstDirectSoundSink * sink);
 101 static void gst_directsound_sink_set_mute (GstDirectSoundSink * sink,
 102     gboolean mute);
 103 static gboolean gst_directsound_sink_get_mute (GstDirectSoundSink * sink);
 104 static const gchar *gst_directsound_sink_get_device (GstDirectSoundSink *
 105     dsoundsink);
 106 static void gst_directsound_sink_set_device (GstDirectSoundSink * dsoundsink,
 107     const gchar * device_id);
 108 
 109 static gboolean gst_directsound_sink_is_spdif_format (GstAudioRingBufferSpec *
 110     spec);
 111 
 112 static gchar *gst_hres_to_string (HRESULT hRes);
 113 
 114 static GstStaticPadTemplate directsoundsink_sink_factory =
 115 GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,
 116     GST_PAD_SINK,
 117     GST_PAD_ALWAYS,
 118     GST_STATIC_CAPS (GST_DIRECTSOUND_SINK_CAPS));
 119 
 120 enum
 121 {
 122   PROP_0,
 123   PROP_VOLUME,
 124   PROP_MUTE,
 125   PROP_DEVICE
 126 #ifdef GSTREAMER_LITE
 127   ,PROP_PANORAMA
 128 #endif // GSTREAMER_LITE
 129 };
 130 
 131 #define gst_directsound_sink_parent_class parent_class
 132 G_DEFINE_TYPE_WITH_CODE (GstDirectSoundSink, gst_directsound_sink,
 133     GST_TYPE_AUDIO_SINK, G_IMPLEMENT_INTERFACE (GST_TYPE_STREAM_VOLUME, NULL)
 134     );
 135 
 136 #ifdef GSTREAMER_LITE
 137 static void
 138 gst_directsound_sink_set_pan (GstDirectSoundSink * dsoundsink)
 139 {
 140   if (dsoundsink-&gt;pDSBSecondary)
 141   {
 142     LONG lPan = DSBPAN_CENTER;
 143     double panorama = 0.0;
 144     BOOL bLeftChannel = FALSE;
 145 
 146     panorama = dsoundsink-&gt;panorama;
 147 
 148     /* DirectSound controls pan using units of 100th of a decibel,
 149      * ranging from -10000 (DSBPAN_LEFT) to 10000 (DSBPAN_RIGHT). We use a linear scale of -1.00 - 1.00
 150      * here, so remap.
 151      */
 152     if (panorama &lt; 0.0)
 153     {
 154       bLeftChannel = TRUE;
 155       panorama = panorama * (-1.0);
 156     }
 157 
 158     if (dsoundsink-&gt;panorama == 0.0)
 159       lPan = DSBPAN_CENTER;
 160     else if (dsoundsink-&gt;panorama == 1.0)
 161       lPan = DSBPAN_RIGHT;
 162     else if (dsoundsink-&gt;panorama == -1.0)
 163       lPan = DSBPAN_LEFT;
 164     else
 165     {
 166       lPan = 100 * (long) (20.0 * log10 ((double) 1.0 - panorama));
 167 
 168       if (!bLeftChannel)
 169         lPan = lPan * (-1);
 170 
 171       lPan = CLAMP(lPan, DSBPAN_LEFT, DSBPAN_RIGHT);
 172     }
 173 
 174     IDirectSoundBuffer_SetPan(dsoundsink-&gt;pDSBSecondary, lPan);
 175   }
 176 }
 177 #endif // GSTREAMER_LITE
 178 
 179 static void
 180 gst_directsound_sink_finalize (GObject * object)
 181 {
 182   GstDirectSoundSink *dsoundsink = GST_DIRECTSOUND_SINK (object);
 183 
 184   g_free (dsoundsink-&gt;device_id);
 185   dsoundsink-&gt;device_id = NULL;
 186 
 187   g_mutex_clear (&amp;dsoundsink-&gt;dsound_lock);
 188   gst_object_unref (dsoundsink-&gt;system_clock);
 189   if (dsoundsink-&gt;write_wait_clock_id != NULL) {
 190     gst_clock_id_unref (dsoundsink-&gt;write_wait_clock_id);
 191   }
 192 
 193   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 194 }
 195 
 196 static void
 197 gst_directsound_sink_class_init (GstDirectSoundSinkClass * klass)
 198 {
 199   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 200   GstBaseSinkClass *gstbasesink_class = GST_BASE_SINK_CLASS (klass);
 201   GstAudioSinkClass *gstaudiosink_class = GST_AUDIO_SINK_CLASS (klass);
 202   GstAudioBaseSinkClass *gstaudiobasesink_class =
 203       GST_AUDIO_BASE_SINK_CLASS (klass);
 204   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 205 
 206   GST_DEBUG_CATEGORY_INIT (directsoundsink_debug, &quot;directsoundsink&quot;, 0,
 207       &quot;DirectSound sink&quot;);
 208 
 209   gobject_class-&gt;finalize = gst_directsound_sink_finalize;
 210   gobject_class-&gt;set_property = gst_directsound_sink_set_property;
 211   gobject_class-&gt;get_property = gst_directsound_sink_get_property;
 212 
 213   gstbasesink_class-&gt;get_caps =
 214       GST_DEBUG_FUNCPTR (gst_directsound_sink_getcaps);
 215 
 216   gstbasesink_class-&gt;query = GST_DEBUG_FUNCPTR (gst_directsound_sink_query);
 217 
 218   gstaudiobasesink_class-&gt;payload =
 219       GST_DEBUG_FUNCPTR (gst_directsound_sink_payload);
 220 
 221   gstaudiosink_class-&gt;prepare =
 222       GST_DEBUG_FUNCPTR (gst_directsound_sink_prepare);
 223   gstaudiosink_class-&gt;unprepare =
 224       GST_DEBUG_FUNCPTR (gst_directsound_sink_unprepare);
 225   gstaudiosink_class-&gt;open = GST_DEBUG_FUNCPTR (gst_directsound_sink_open);
 226   gstaudiosink_class-&gt;close = GST_DEBUG_FUNCPTR (gst_directsound_sink_close);
 227   gstaudiosink_class-&gt;write = GST_DEBUG_FUNCPTR (gst_directsound_sink_write);
 228   gstaudiosink_class-&gt;delay = GST_DEBUG_FUNCPTR (gst_directsound_sink_delay);
 229   gstaudiosink_class-&gt;reset = GST_DEBUG_FUNCPTR (gst_directsound_sink_reset);
 230 
 231   g_object_class_install_property (gobject_class,
 232       PROP_VOLUME,
 233       g_param_spec_double (&quot;volume&quot;, &quot;Volume&quot;,
 234           &quot;Volume of this stream&quot;, 0.0, 1.0, 1.0,
 235           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 236 
 237   g_object_class_install_property (gobject_class,
 238       PROP_MUTE,
 239       g_param_spec_boolean (&quot;mute&quot;, &quot;Mute&quot;,
 240           &quot;Mute state of this stream&quot;, DEFAULT_MUTE,
 241           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 242 
 243 #ifdef GSTREAMER_LITE
 244   g_object_class_install_property (gobject_class,
 245       PROP_PANORAMA,
 246       g_param_spec_float (&quot;panorama&quot;, &quot;Panorama&quot;,
 247           &quot;Position in stereo panorama (-1.00 left -&gt; 1.00 right)&quot;, -1.0, 1.0,
 248           0.0, G_PARAM_READWRITE | GST_PARAM_CONTROLLABLE));
 249 #endif // GSTREAMER_LITE
 250 
 251   g_object_class_install_property (gobject_class,
 252       PROP_DEVICE,
 253       g_param_spec_string (&quot;device&quot;, &quot;Device&quot;,
 254           &quot;DirectSound playback device as a GUID string&quot;,
 255           NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 256 
 257   gst_element_class_set_static_metadata (element_class,
 258       &quot;Direct Sound Audio Sink&quot;, &quot;Sink/Audio&quot;,
 259       &quot;Output to a sound card via Direct Sound&quot;,
 260       &quot;Sebastien Moutte &lt;sebastien@moutte.net&gt;&quot;);
 261 
 262   gst_element_class_add_static_pad_template (element_class,
 263       &amp;directsoundsink_sink_factory);
 264 }
 265 
 266 static void
 267 gst_directsound_sink_init (GstDirectSoundSink * dsoundsink)
 268 {
 269   dsoundsink-&gt;volume = 100;
 270   dsoundsink-&gt;mute = FALSE;
 271   dsoundsink-&gt;device_id = NULL;
 272   dsoundsink-&gt;pDS = NULL;
 273   dsoundsink-&gt;cached_caps = NULL;
 274   dsoundsink-&gt;pDSBSecondary = NULL;
 275   dsoundsink-&gt;current_circular_offset = 0;
 276   dsoundsink-&gt;buffer_size = DSBSIZE_MIN;
 277   g_mutex_init (&amp;dsoundsink-&gt;dsound_lock);
 278   dsoundsink-&gt;system_clock = gst_system_clock_obtain ();
 279   dsoundsink-&gt;write_wait_clock_id = NULL;
 280   dsoundsink-&gt;first_buffer_after_reset = FALSE;
 281 #ifdef GSTREAMER_LITE
 282   dsoundsink-&gt;panorama = 0.0;
 283 #endif // GSTREAMER_LITE
 284 }
 285 
 286 static void
 287 gst_directsound_sink_set_property (GObject * object,
 288     guint prop_id, const GValue * value, GParamSpec * pspec)
 289 {
 290   GstDirectSoundSink *sink = GST_DIRECTSOUND_SINK (object);
 291 
 292   switch (prop_id) {
 293     case PROP_VOLUME:
 294       gst_directsound_sink_set_volume (sink, g_value_get_double (value), TRUE);
 295       break;
 296     case PROP_MUTE:
 297       gst_directsound_sink_set_mute (sink, g_value_get_boolean (value));
 298       break;
 299 #ifdef GSTREAMER_LITE
 300     case PROP_PANORAMA:
 301       sink-&gt;panorama = g_value_get_float (value);
 302       gst_directsound_sink_set_pan (sink);
 303       break;
 304 #endif // GSTREAMER_LITE
 305     case PROP_DEVICE:
 306       gst_directsound_sink_set_device (sink, g_value_get_string (value));
 307       break;
 308     default:
 309       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 310       break;
 311   }
 312 }
 313 
 314 static void
 315 gst_directsound_sink_get_property (GObject * object,
 316     guint prop_id, GValue * value, GParamSpec * pspec)
 317 {
 318   GstDirectSoundSink *sink = GST_DIRECTSOUND_SINK (object);
 319 
 320   switch (prop_id) {
 321     case PROP_VOLUME:
 322       g_value_set_double (value, gst_directsound_sink_get_volume (sink));
 323       break;
 324     case PROP_MUTE:
 325       g_value_set_boolean (value, gst_directsound_sink_get_mute (sink));
 326       break;
 327 #ifdef GSTREAMER_LITE
 328     case PROP_PANORAMA:
 329       g_value_set_float (value, sink-&gt;panorama);
 330       break;
 331 #endif // GSTREAMER_LITE
 332     case PROP_DEVICE:
 333       g_value_set_string (value, gst_directsound_sink_get_device (sink));
 334       break;
 335     default:
 336       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 337       break;
 338   }
 339 }
 340 
 341 static GstCaps *
 342 gst_directsound_sink_getcaps (GstBaseSink * bsink, GstCaps * filter)
 343 {
 344   GstElementClass *element_class;
 345   GstPadTemplate *pad_template;
 346   GstDirectSoundSink *dsoundsink = GST_DIRECTSOUND_SINK (bsink);
 347   GstCaps *caps;
 348 
 349   if (dsoundsink-&gt;pDS == NULL) {
 350     GST_DEBUG_OBJECT (dsoundsink, &quot;device not open, using template caps&quot;);
 351     return NULL;                /* base class will get template caps for us */
 352   }
 353 
 354   if (dsoundsink-&gt;cached_caps) {
 355     caps = gst_caps_ref (dsoundsink-&gt;cached_caps);
 356   } else {
 357     element_class = GST_ELEMENT_GET_CLASS (dsoundsink);
 358     pad_template = gst_element_class_get_pad_template (element_class, &quot;sink&quot;);
 359     g_return_val_if_fail (pad_template != NULL, NULL);
 360 
 361     caps = gst_directsound_probe_supported_formats (dsoundsink,
 362         gst_pad_template_get_caps (pad_template));
 363     if (caps)
 364       dsoundsink-&gt;cached_caps = gst_caps_ref (caps);
 365   }
 366 
 367   if (caps &amp;&amp; filter) {
 368     GstCaps *tmp =
 369         gst_caps_intersect_full (filter, caps, GST_CAPS_INTERSECT_FIRST);
 370     gst_caps_unref (caps);
 371     caps = tmp;
 372   }
 373 
 374   if (caps) {
 375     gchar *caps_string = gst_caps_to_string (caps);
 376     GST_DEBUG_OBJECT (dsoundsink, &quot;returning caps %s&quot;, caps_string);
 377     g_free (caps_string);
 378   }
 379 
 380   return caps;
 381 }
 382 
 383 static gboolean
 384 gst_directsound_sink_acceptcaps (GstBaseSink * sink, GstQuery * query)
 385 {
 386   GstDirectSoundSink *dsink = GST_DIRECTSOUND_SINK (sink);
 387   GstPad *pad;
 388   GstCaps *caps;
 389   GstCaps *pad_caps;
 390   GstStructure *st;
 391   gboolean ret = FALSE;
 392   GstAudioRingBufferSpec spec = { 0 };
 393 
 394   if (G_UNLIKELY (dsink == NULL))
 395     return FALSE;
 396 
 397   pad = sink-&gt;sinkpad;
 398 
 399   gst_query_parse_accept_caps (query, &amp;caps);
 400   GST_DEBUG_OBJECT (pad, &quot;caps %&quot; GST_PTR_FORMAT, caps);
 401 
 402   pad_caps = gst_pad_query_caps (pad, NULL);
 403   if (pad_caps) {
 404     gboolean cret = gst_caps_is_subset (caps, pad_caps);
 405     gst_caps_unref (pad_caps);
 406     if (!cret) {
 407       GST_DEBUG_OBJECT (dsink,
 408           &quot;Caps are not a subset of the pad caps, not accepting caps&quot;);
 409       goto done;
 410     }
 411   }
 412 
 413   /* If we&#39;ve not got fixed caps, creating a stream might fail, so let&#39;s just
 414    * return from here with default acceptcaps behaviour */
 415   if (!gst_caps_is_fixed (caps)) {
 416     GST_DEBUG_OBJECT (dsink, &quot;Caps are not fixed, not accepting caps&quot;);
 417     goto done;
 418   }
 419 
 420   spec.latency_time = GST_SECOND;
 421   if (!gst_audio_ring_buffer_parse_caps (&amp;spec, caps)) {
 422     GST_DEBUG_OBJECT (dsink, &quot;Failed to parse caps, not accepting&quot;);
 423     goto done;
 424   }
 425 
 426   /* Make sure input is framed (one frame per buffer) and can be payloaded */
 427   switch (spec.type) {
 428     case GST_AUDIO_RING_BUFFER_FORMAT_TYPE_AC3:
 429     case GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DTS:
 430     {
 431       gboolean framed = FALSE, parsed = FALSE;
 432       st = gst_caps_get_structure (caps, 0);
 433 
 434       gst_structure_get_boolean (st, &quot;framed&quot;, &amp;framed);
 435       gst_structure_get_boolean (st, &quot;parsed&quot;, &amp;parsed);
 436       if ((!framed &amp;&amp; !parsed) || gst_audio_iec61937_frame_size (&amp;spec) &lt;= 0) {
 437         GST_DEBUG_OBJECT (dsink, &quot;Wrong AC3/DTS caps, not accepting&quot;);
 438         goto done;
 439       }
 440     }
 441     default:
 442       break;
 443   }
 444   ret = TRUE;
 445   GST_DEBUG_OBJECT (dsink, &quot;Accepting caps&quot;);
 446 
 447 done:
 448 #ifdef GSTREAMER_LITE
 449   if (spec.caps) {
 450     // gst_audio_ring_buffer_parse_caps() will ref and set spec.caps to caps
 451     // passed to this function. Unref it to avoid memory leak.
 452     gst_caps_unref(spec.caps);
 453   }
 454 #endif // GSTREAMER_LITE
 455   gst_query_set_accept_caps_result (query, ret);
 456   return TRUE;
 457 }
 458 
 459 static gboolean
 460 gst_directsound_sink_query (GstBaseSink * sink, GstQuery * query)
 461 {
 462   gboolean res = TRUE;
 463 
 464   switch (GST_QUERY_TYPE (query)) {
 465     case GST_QUERY_ACCEPT_CAPS:
 466       res = gst_directsound_sink_acceptcaps (sink, query);
 467       break;
 468     default:
 469       res = GST_BASE_SINK_CLASS (parent_class)-&gt;query (sink, query);
 470   }
 471 
 472   return res;
 473 }
 474 
 475 #ifndef GSTREAMER_LITE
 476 static LPGUID
 477 string_to_guid (const gchar * str)
 478 {
 479   HRESULT ret;
 480   gunichar2 *wstr;
 481   LPGUID out;
 482 
 483   wstr = g_utf8_to_utf16 (str, -1, NULL, NULL, NULL);
 484   if (!wstr)
 485     return NULL;
 486 
 487   out = g_new (GUID, 1);
 488   ret = CLSIDFromString ((LPOLESTR) wstr, out);
 489   g_free (wstr);
 490   if (ret != NOERROR) {
 491     g_free (out);
 492     return NULL;
 493   }
 494 
 495   return out;
 496 }
 497 #endif // GSTREAMER_LITE
 498 
 499 static gboolean
 500 gst_directsound_sink_open (GstAudioSink * asink)
 501 {
 502   GstDirectSoundSink *dsoundsink;
 503   HRESULT hRes;
 504   LPGUID lpGuid = NULL;
 505 
 506   dsoundsink = GST_DIRECTSOUND_SINK (asink);
 507 
 508 #ifndef GSTREAMER_LITE
 509   if (dsoundsink-&gt;device_id) {
 510     lpGuid = string_to_guid (dsoundsink-&gt;device_id);
 511     if (lpGuid == NULL) {
 512       GST_ELEMENT_ERROR (dsoundsink, RESOURCE, OPEN_READ,
 513           (&quot;device set but guid not found: %s&quot;, dsoundsink-&gt;device_id), (NULL));
 514       return FALSE;
 515     }
 516   }
 517 #endif // GSTREAMER_LITE
 518 
 519   /* create and initialize a DirectSound object */
 520   if (FAILED (hRes = DirectSoundCreate (lpGuid, &amp;dsoundsink-&gt;pDS, NULL))) {
 521 #ifdef GSTREAMER_LITE
 522     dsoundsink-&gt;pDS = NULL;
 523 #endif // GSTREAMER_LITE
 524     gchar *error_text = gst_hres_to_string (hRes);
 525     GST_ELEMENT_ERROR (dsoundsink, RESOURCE, OPEN_READ,
 526         (&quot;DirectSoundCreate: %s&quot;, error_text), (NULL));
 527     g_free (lpGuid);
 528     g_free (error_text);
 529     return FALSE;
 530   }
 531 
 532   g_free (lpGuid);
 533 
 534   if (FAILED (hRes = IDirectSound_SetCooperativeLevel (dsoundsink-&gt;pDS,
 535               GetDesktopWindow (), DSSCL_PRIORITY))) {
 536 #ifdef GSTREAMER_LITE
 537     if (dsoundsink-&gt;pDS) {
 538       IDirectSound_Release(dsoundsink-&gt;pDS);
 539       dsoundsink-&gt;pDS = NULL;
 540     }
 541 #endif // GSTREAMER_LITE
 542     gchar *error_text = gst_hres_to_string (hRes);
 543     GST_ELEMENT_ERROR (dsoundsink, RESOURCE, OPEN_READ,
 544         (&quot;IDirectSound_SetCooperativeLevel: %s&quot;, error_text), (NULL));
 545     g_free (error_text);
 546     return FALSE;
 547   }
 548 
 549   return TRUE;
 550 }
 551 
 552 static gboolean
 553 gst_directsound_sink_is_spdif_format (GstAudioRingBufferSpec * spec)
 554 {
 555   return spec-&gt;type == GST_AUDIO_RING_BUFFER_FORMAT_TYPE_AC3 ||
 556       spec-&gt;type == GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DTS;
 557 }
 558 
 559 static gboolean
 560 gst_directsound_sink_prepare (GstAudioSink * asink,
 561     GstAudioRingBufferSpec * spec)
 562 {
 563   GstDirectSoundSink *dsoundsink;
 564   HRESULT hRes;
 565   DSBUFFERDESC descSecondary;
 566   WAVEFORMATEX wfx;
 567 
 568   dsoundsink = GST_DIRECTSOUND_SINK (asink);
 569 
 570   /*save number of bytes per sample and buffer format */
 571   dsoundsink-&gt;bytes_per_sample = spec-&gt;info.bpf;
 572   dsoundsink-&gt;type = spec-&gt;type;
 573 
 574 #ifdef GSTREAMER_LITE
 575   dsoundsink-&gt;rate = spec-&gt;info.rate;
 576   if (dsoundsink-&gt;bytes_per_sample == 0 || dsoundsink-&gt;rate == 0)
 577     return FALSE;
 578   if (dsoundsink-&gt;pDS == NULL)
 579     return TRUE;
 580 #endif // GSTREAMER_LITE
 581 
 582   /* fill the WAVEFORMATEX structure with spec params */
 583   memset (&amp;wfx, 0, sizeof (wfx));
 584   if (!gst_directsound_sink_is_spdif_format (spec)) {
 585     wfx.cbSize = sizeof (wfx);
 586     wfx.wFormatTag = WAVE_FORMAT_PCM;
 587     wfx.nChannels = spec-&gt;info.channels;
 588     wfx.nSamplesPerSec = spec-&gt;info.rate;
 589     wfx.wBitsPerSample = (spec-&gt;info.bpf * 8) / wfx.nChannels;
 590     wfx.nBlockAlign = spec-&gt;info.bpf;
 591     wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
 592 
 593     /* Create directsound buffer with size based on our configured
 594      * buffer_size (which is 200 ms by default) */
 595     dsoundsink-&gt;buffer_size =
 596         gst_util_uint64_scale_int (wfx.nAvgBytesPerSec, spec-&gt;buffer_time,
 597         GST_MSECOND);
 598     /* Make sure we make those numbers multiple of our sample size in bytes */
 599     dsoundsink-&gt;buffer_size -= dsoundsink-&gt;buffer_size % spec-&gt;info.bpf;
 600 
 601     spec-&gt;segsize =
 602         gst_util_uint64_scale_int (wfx.nAvgBytesPerSec, spec-&gt;latency_time,
 603         GST_MSECOND);
 604     spec-&gt;segsize -= spec-&gt;segsize % spec-&gt;info.bpf;
 605     spec-&gt;segtotal = dsoundsink-&gt;buffer_size / spec-&gt;segsize;
 606   } else {
 607 #ifdef WAVE_FORMAT_DOLBY_AC3_SPDIF
 608     wfx.cbSize = 0;
 609     wfx.wFormatTag = WAVE_FORMAT_DOLBY_AC3_SPDIF;
 610     wfx.nChannels = 2;
 611     wfx.nSamplesPerSec = 48000;
 612     wfx.wBitsPerSample = 16;
 613     wfx.nBlockAlign = wfx.wBitsPerSample / 8 * wfx.nChannels;
 614     wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
 615 
 616     spec-&gt;segsize = 6144;
 617     spec-&gt;segtotal = 10;
 618 #else
 619     g_assert_not_reached ();
 620 #endif
 621   }
 622 
 623   // Make the final buffer size be an integer number of segments
 624   dsoundsink-&gt;buffer_size = spec-&gt;segsize * spec-&gt;segtotal;
 625 
 626   GST_INFO_OBJECT (dsoundsink, &quot;channels: %d, rate: %d, bytes_per_sample: %d&quot;
 627       &quot; WAVEFORMATEX.nSamplesPerSec: %ld, WAVEFORMATEX.wBitsPerSample: %d,&quot;
 628       &quot; WAVEFORMATEX.nBlockAlign: %d, WAVEFORMATEX.nAvgBytesPerSec: %ld\n&quot;
 629       &quot;Size of dsound circular buffer=&gt;%d\n&quot;,
 630       GST_AUDIO_INFO_CHANNELS (&amp;spec-&gt;info), GST_AUDIO_INFO_RATE (&amp;spec-&gt;info),
 631       GST_AUDIO_INFO_BPF (&amp;spec-&gt;info), wfx.nSamplesPerSec, wfx.wBitsPerSample,
 632       wfx.nBlockAlign, wfx.nAvgBytesPerSec, dsoundsink-&gt;buffer_size);
 633 
 634   /* create a secondary directsound buffer */
 635   memset (&amp;descSecondary, 0, sizeof (DSBUFFERDESC));
 636   descSecondary.dwSize = sizeof (DSBUFFERDESC);
 637 #ifndef GSTREAMER_LITE
 638   descSecondary.dwFlags = DSBCAPS_GETCURRENTPOSITION2 | DSBCAPS_GLOBALFOCUS;
 639 #else // GSTREAMER_LITE
 640   descSecondary.dwFlags = DSBCAPS_GETCURRENTPOSITION2 | DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLPAN;
 641 #endif // GSTREAMER_LITE
 642   if (!gst_directsound_sink_is_spdif_format (spec))
 643     descSecondary.dwFlags |= DSBCAPS_CTRLVOLUME;
 644 
 645   descSecondary.dwBufferBytes = dsoundsink-&gt;buffer_size;
 646   descSecondary.lpwfxFormat = (WAVEFORMATEX *) &amp; wfx;
 647 
 648   hRes = IDirectSound_CreateSoundBuffer (dsoundsink-&gt;pDS, &amp;descSecondary,
 649       &amp;dsoundsink-&gt;pDSBSecondary, NULL);
 650   if (FAILED (hRes)) {
 651 #ifdef GSTREAMER_LITE
 652     if (dsoundsink-&gt;pDS) {
 653       IDirectSound_Release(dsoundsink-&gt;pDS);
 654       dsoundsink-&gt;pDS = NULL;
 655     }
 656     dsoundsink-&gt;pDSBSecondary = NULL;
 657 #endif // GSTREAMER_LITE
 658     gchar *error_text = gst_hres_to_string (hRes);
 659     GST_ELEMENT_ERROR (dsoundsink, RESOURCE, OPEN_READ,
 660         (&quot;IDirectSound_CreateSoundBuffer: %s&quot;, error_text), (NULL));
 661     g_free (error_text);
 662     return FALSE;
 663   }
 664 
 665   gst_directsound_sink_set_volume (dsoundsink,
 666       gst_directsound_sink_get_volume (dsoundsink), FALSE);
 667   gst_directsound_sink_set_mute (dsoundsink, dsoundsink-&gt;mute);
 668 #ifdef GSTREAMER_LITE
 669   gst_directsound_sink_set_pan (dsoundsink);
 670 #endif // GSTREAMER_LITE
 671 
 672   return TRUE;
 673 }
 674 
 675 static gboolean
 676 gst_directsound_sink_unprepare (GstAudioSink * asink)
 677 {
 678   GstDirectSoundSink *dsoundsink;
 679 
 680   dsoundsink = GST_DIRECTSOUND_SINK (asink);
 681 
 682   /* release secondary DirectSound buffer */
 683   if (dsoundsink-&gt;pDSBSecondary) {
 684     IDirectSoundBuffer_Release (dsoundsink-&gt;pDSBSecondary);
 685     dsoundsink-&gt;pDSBSecondary = NULL;
 686   }
 687 
 688   return TRUE;
 689 }
 690 
 691 static gboolean
 692 gst_directsound_sink_close (GstAudioSink * asink)
 693 {
 694   GstDirectSoundSink *dsoundsink = NULL;
 695 
 696   dsoundsink = GST_DIRECTSOUND_SINK (asink);
 697 
 698   /* release DirectSound object */
 699 #ifndef GSTREAMER_LITE
 700   g_return_val_if_fail (dsoundsink-&gt;pDS != NULL, FALSE);
 701 #else // GSTREAMER_LITE
 702   if (dsoundsink-&gt;pDS)
 703 #endif // GSTREAMER_LITE
 704   IDirectSound_Release (dsoundsink-&gt;pDS);
 705   dsoundsink-&gt;pDS = NULL;
 706 
 707   gst_caps_replace (&amp;dsoundsink-&gt;cached_caps, NULL);
 708 
 709   return TRUE;
 710 }
 711 
 712 static gint
 713 gst_directsound_sink_write (GstAudioSink * asink, gpointer data, guint length)
 714 {
 715   GstDirectSoundSink *dsoundsink;
 716   DWORD dwStatus = 0;
 717   HRESULT hRes, hRes2;
 718   LPVOID pLockedBuffer1 = NULL, pLockedBuffer2 = NULL;
 719   DWORD dwSizeBuffer1, dwSizeBuffer2;
 720   DWORD dwCurrentPlayCursor;
 721 #ifdef GSTREAMER_LITE
 722   DWORD samples = 0;
 723   DWORD duration = 0;
 724 #endif // GSTREAMER_LITE
 725 
 726   dsoundsink = GST_DIRECTSOUND_SINK (asink);
 727 
 728 #ifdef GSTREAMER_LITE
 729   if (dsoundsink-&gt;pDS == NULL)
 730   {
 731     GST_DSOUND_LOCK (dsoundsink);
 732     samples = length/dsoundsink-&gt;bytes_per_sample;
 733     duration = (1000*samples)/dsoundsink-&gt;rate;
 734     Sleep(duration);
 735     GST_DSOUND_UNLOCK (dsoundsink);
 736     return length;
 737   }
 738 #endif // GSTREAMER_LITE
 739 
 740   GST_DSOUND_LOCK (dsoundsink);
 741 
 742   /* get current buffer status */
 743   hRes = IDirectSoundBuffer_GetStatus (dsoundsink-&gt;pDSBSecondary, &amp;dwStatus);
 744 
 745   /* get current play cursor position */
 746   hRes2 = IDirectSoundBuffer_GetCurrentPosition (dsoundsink-&gt;pDSBSecondary,
 747       &amp;dwCurrentPlayCursor, NULL);
 748 
 749   if (SUCCEEDED (hRes) &amp;&amp; SUCCEEDED (hRes2) &amp;&amp; (dwStatus &amp; DSBSTATUS_PLAYING)) {
 750     DWORD dwFreeBufferSize = 0;
 751     GstClockTime sleep_time_ms = 0, sleep_until;
 752     GstClockID clock_id;
 753 
 754   calculate_freesize:
 755     /* Calculate the free space in the circular buffer */
 756     if (dwCurrentPlayCursor &lt; dsoundsink-&gt;current_circular_offset)
 757       dwFreeBufferSize =
 758           dsoundsink-&gt;buffer_size - (dsoundsink-&gt;current_circular_offset -
 759           dwCurrentPlayCursor);
 760     else
 761       dwFreeBufferSize =
 762           dwCurrentPlayCursor - dsoundsink-&gt;current_circular_offset;
 763 
 764     /* Not enough free space, wait for some samples to be played out. We could
 765      * write out partial data, but that will result in a tight loop in the
 766      * audioringbuffer write thread, and lead to high CPU usage. */
 767     if (length &gt; dwFreeBufferSize) {
 768       gint rate = GST_AUDIO_BASE_SINK (asink)-&gt;ringbuffer-&gt;spec.info.rate;
 769       /* Wait for a time proportional to the space needed. In reality, the
 770        * directsound sink&#39;s position does not update frequently enough, so we
 771        * will end up waiting for much longer. Note that Sleep() has millisecond
 772        * resolution at best. */
 773       sleep_time_ms = gst_util_uint64_scale_int ((length - dwFreeBufferSize),
 774           1000, dsoundsink-&gt;bytes_per_sample * rate);
 775       /* Make sure we don&#39;t run in a tight loop unnecessarily */
 776       sleep_time_ms = MAX (sleep_time_ms, 10);
 777       sleep_until = gst_clock_get_time (dsoundsink-&gt;system_clock) +
 778           sleep_time_ms * GST_MSECOND;
 779 
 780       GST_DEBUG_OBJECT (dsoundsink,
 781           &quot;length: %u, FreeBufSiz: %ld, sleep_time_ms: %&quot; G_GUINT64_FORMAT
 782           &quot;, bps: %i, rate: %i&quot;, length, dwFreeBufferSize, sleep_time_ms,
 783           dsoundsink-&gt;bytes_per_sample, rate);
 784 
 785       if (G_UNLIKELY (dsoundsink-&gt;write_wait_clock_id == NULL ||
 786               gst_clock_single_shot_id_reinit (dsoundsink-&gt;system_clock,
 787                   dsoundsink-&gt;write_wait_clock_id, sleep_until) == FALSE)) {
 788 
 789         if (dsoundsink-&gt;write_wait_clock_id != NULL) {
 790           gst_clock_id_unref (dsoundsink-&gt;write_wait_clock_id);
 791         }
 792 
 793         dsoundsink-&gt;write_wait_clock_id =
 794             gst_clock_new_single_shot_id (dsoundsink-&gt;system_clock,
 795             sleep_until);
 796       }
 797 
 798       clock_id = dsoundsink-&gt;write_wait_clock_id;
 799       dsoundsink-&gt;reset_while_sleeping = FALSE;
 800 
 801       GST_DSOUND_UNLOCK (dsoundsink);
 802 
 803       /* don&#39;t bother with the return value as we&#39;ll detect reset separately,
 804          as reset could happen between when this returns and we obtain the lock
 805          again -- so we can&#39;t use UNSCHEDULED here */
 806       gst_clock_id_wait (clock_id, NULL);
 807 
 808       GST_DSOUND_LOCK (dsoundsink);
 809 
 810       /* if a reset occurs, exit now */
 811       if (dsoundsink-&gt;reset_while_sleeping == TRUE) {
 812         GST_DSOUND_UNLOCK (dsoundsink);
 813         return -1;
 814       }
 815 
 816       /* May we send out? */
 817       hRes = IDirectSoundBuffer_GetCurrentPosition (dsoundsink-&gt;pDSBSecondary,
 818           &amp;dwCurrentPlayCursor, NULL);
 819       hRes2 =
 820           IDirectSoundBuffer_GetStatus (dsoundsink-&gt;pDSBSecondary, &amp;dwStatus);
 821       if (SUCCEEDED (hRes) &amp;&amp; SUCCEEDED (hRes2)
 822           &amp;&amp; (dwStatus &amp; DSBSTATUS_PLAYING))
 823         goto calculate_freesize;
 824       else {
 825         gchar *err1, *err2;
 826 
 827         dsoundsink-&gt;first_buffer_after_reset = FALSE;
 828         GST_DSOUND_UNLOCK (dsoundsink);
 829 
 830         err1 = gst_hres_to_string (hRes);
 831         err2 = gst_hres_to_string (hRes2);
 832         GST_ELEMENT_ERROR (dsoundsink, RESOURCE, OPEN_WRITE,
 833             (&quot;IDirectSoundBuffer_GetStatus %s, &quot;
 834                 &quot;IDirectSoundBuffer_GetCurrentPosition: %s, dwStatus: %lu&quot;,
 835                 err2, err1, dwStatus), (NULL));
 836         g_free (err1);
 837         g_free (err2);
 838         return -1;
 839       }
 840     }
 841   }
 842 
 843   if (dwStatus &amp; DSBSTATUS_BUFFERLOST) {
 844     hRes = IDirectSoundBuffer_Restore (dsoundsink-&gt;pDSBSecondary);      /*need a loop waiting the buffer is restored?? */
 845     dsoundsink-&gt;current_circular_offset = 0;
 846   }
 847 
 848   /* Lock a buffer of length @length for writing */
 849   hRes = IDirectSoundBuffer_Lock (dsoundsink-&gt;pDSBSecondary,
 850       dsoundsink-&gt;current_circular_offset, length, &amp;pLockedBuffer1,
 851       &amp;dwSizeBuffer1, &amp;pLockedBuffer2, &amp;dwSizeBuffer2, 0L);
 852 
 853   if (SUCCEEDED (hRes)) {
 854     // Write to pointers without reordering.
 855     memcpy (pLockedBuffer1, data, dwSizeBuffer1);
 856     if (pLockedBuffer2 != NULL)
 857       memcpy (pLockedBuffer2, (LPBYTE) data + dwSizeBuffer1, dwSizeBuffer2);
 858 
 859     hRes = IDirectSoundBuffer_Unlock (dsoundsink-&gt;pDSBSecondary, pLockedBuffer1,
 860         dwSizeBuffer1, pLockedBuffer2, dwSizeBuffer2);
 861 
 862     // Update where the buffer will lock (for next time)
 863     dsoundsink-&gt;current_circular_offset += dwSizeBuffer1 + dwSizeBuffer2;
 864     dsoundsink-&gt;current_circular_offset %= dsoundsink-&gt;buffer_size;     /* Circular buffer */
 865   }
 866 
 867   /* if the buffer was not in playing state yet, call play on the buffer
 868      except if this buffer is the fist after a reset (base class call reset and write a buffer when setting the sink to pause) */
 869   if (!(dwStatus &amp; DSBSTATUS_PLAYING) &amp;&amp;
 870       dsoundsink-&gt;first_buffer_after_reset == FALSE) {
 871     hRes = IDirectSoundBuffer_Play (dsoundsink-&gt;pDSBSecondary, 0, 0,
 872         DSBPLAY_LOOPING);
 873   }
 874 
 875   dsoundsink-&gt;first_buffer_after_reset = FALSE;
 876 
 877   GST_DSOUND_UNLOCK (dsoundsink);
 878 
 879   return length;
 880 }
 881 
 882 static guint
 883 gst_directsound_sink_delay (GstAudioSink * asink)
 884 {
 885   GstDirectSoundSink *dsoundsink;
 886   HRESULT hRes;
 887   DWORD dwCurrentPlayCursor;
 888   DWORD dwBytesInQueue = 0;
 889   gint nNbSamplesInQueue = 0;
 890   DWORD dwStatus;
 891 
 892   dsoundsink = GST_DIRECTSOUND_SINK (asink);
 893 
 894 #ifdef GSTREAMER_LITE
 895   if (dsoundsink-&gt;pDS == NULL || dsoundsink-&gt;pDSBSecondary == NULL)
 896     return nNbSamplesInQueue;
 897 #endif // GSTREAMER_LITE
 898 
 899   /* get current buffer status */
 900   hRes = IDirectSoundBuffer_GetStatus (dsoundsink-&gt;pDSBSecondary, &amp;dwStatus);
 901 
 902   if (SUCCEEDED (hRes) &amp;&amp; (dwStatus &amp; DSBSTATUS_PLAYING)) {
 903     /*evaluate the number of samples in queue in the circular buffer */
 904     hRes = IDirectSoundBuffer_GetCurrentPosition (dsoundsink-&gt;pDSBSecondary,
 905         &amp;dwCurrentPlayCursor, NULL);
 906 
 907     if (hRes == S_OK) {
 908       if (dwCurrentPlayCursor &lt; dsoundsink-&gt;current_circular_offset)
 909         dwBytesInQueue =
 910             dsoundsink-&gt;current_circular_offset - dwCurrentPlayCursor;
 911       else
 912         dwBytesInQueue =
 913             dsoundsink-&gt;current_circular_offset + (dsoundsink-&gt;buffer_size -
 914             dwCurrentPlayCursor);
 915 
 916       nNbSamplesInQueue = dwBytesInQueue / dsoundsink-&gt;bytes_per_sample;
 917     }
 918   }
 919 
 920   return nNbSamplesInQueue;
 921 }
 922 
 923 #ifndef GSTREAMER_LITE
 924 static void
 925 gst_directsound_sink_reset (GstAudioSink * asink)
 926 {
 927   GstDirectSoundSink *dsoundsink;
 928   LPVOID pLockedBuffer = NULL;
 929   DWORD dwSizeBuffer = 0;
 930 
 931   dsoundsink = GST_DIRECTSOUND_SINK (asink);
 932 
 933   GST_DSOUND_LOCK (dsoundsink);
 934 
 935   if (dsoundsink-&gt;pDSBSecondary) {
 936     /* stop playing */
 937     HRESULT hRes = IDirectSoundBuffer_Stop (dsoundsink-&gt;pDSBSecondary);
 938 
 939     /* reset position */
 940     hRes = IDirectSoundBuffer_SetCurrentPosition (dsoundsink-&gt;pDSBSecondary, 0);
 941     dsoundsink-&gt;current_circular_offset = 0;
 942 
 943     /* reset the buffer */
 944     hRes = IDirectSoundBuffer_Lock (dsoundsink-&gt;pDSBSecondary,
 945         0, dsoundsink-&gt;buffer_size,
 946         &amp;pLockedBuffer, &amp;dwSizeBuffer, NULL, NULL, 0L);
 947 
 948     if (SUCCEEDED (hRes)) {
 949       memset (pLockedBuffer, 0, dwSizeBuffer);
 950 
 951       hRes =
 952           IDirectSoundBuffer_Unlock (dsoundsink-&gt;pDSBSecondary, pLockedBuffer,
 953           dwSizeBuffer, NULL, 0);
 954     }
 955   }
 956 
 957   dsoundsink-&gt;reset_while_sleeping = TRUE;
 958   dsoundsink-&gt;first_buffer_after_reset = TRUE;
 959   if (dsoundsink-&gt;write_wait_clock_id != NULL) {
 960     gst_clock_id_unschedule (dsoundsink-&gt;write_wait_clock_id);
 961   }
 962 
 963   GST_DSOUND_UNLOCK (dsoundsink);
 964 }
 965 #else // GSTREAMER_LITE
 966 static void
 967 gst_directsound_sink_reset (GstAudioSink * asink)
 968 {
 969   GstDirectSoundSink *dsoundsink;
 970   LPVOID pLockedBuffer1 = NULL, pLockedBuffer2 = NULL;
 971   DWORD dwSizeBuffer1 = 0, dwSizeBuffer2 = 0;
 972   DWORD dwInitialPlayCursor = 0, dwCurrentPlayCursor = 0, dwInitialWriteCursor = 0, dwCurrentWriteCursor = 0;
 973   DWORD buff_size = 0;
 974   HRESULT hRes = S_OK;
 975 
 976   dsoundsink = GST_DIRECTSOUND_SINK (asink);
 977 
 978   GST_DSOUND_LOCK (dsoundsink);
 979 
 980   if (dsoundsink-&gt;pDSBSecondary) {
 981     IDirectSoundBuffer_GetCurrentPosition (dsoundsink-&gt;pDSBSecondary, &amp;dwCurrentPlayCursor, &amp;dwCurrentWriteCursor);
 982     dwInitialPlayCursor = dwCurrentPlayCursor;
 983     dwInitialWriteCursor = dwCurrentWriteCursor;
 984 
 985     /*reset the buffer */
 986     if (dwCurrentPlayCursor &lt;= dwCurrentWriteCursor)
 987       buff_size = dsoundsink-&gt;buffer_size - (dwCurrentWriteCursor-dwCurrentPlayCursor);
 988     else
 989       buff_size = dwCurrentPlayCursor - dwCurrentWriteCursor;
 990 
 991     hRes = IDirectSoundBuffer_Lock (dsoundsink-&gt;pDSBSecondary, 0, buff_size, &amp;pLockedBuffer1, &amp;dwSizeBuffer1, &amp;pLockedBuffer2, &amp;dwSizeBuffer2, DSBLOCK_FROMWRITECURSOR);
 992 
 993     if (SUCCEEDED (hRes))
 994     {
 995       if (pLockedBuffer1)
 996         memset (pLockedBuffer1, 0, dwSizeBuffer1);
 997       if (pLockedBuffer2)
 998         memset (pLockedBuffer2, 0, dwSizeBuffer2);
 999 
1000       IDirectSoundBuffer_Unlock (dsoundsink-&gt;pDSBSecondary, pLockedBuffer1, dwSizeBuffer1, pLockedBuffer2, dwSizeBuffer2);
1001     }
1002 
1003     do
1004     {
1005       IDirectSoundBuffer_GetCurrentPosition (dsoundsink-&gt;pDSBSecondary, &amp;dwCurrentPlayCursor, &amp;dwCurrentWriteCursor);
1006       if (dwInitialPlayCursor &lt;= dwInitialWriteCursor)
1007       {
1008         if (dwCurrentPlayCursor &gt;= dwInitialWriteCursor || dwCurrentPlayCursor &lt;= dwInitialPlayCursor)
1009           break;
1010       }
1011       else
1012       {
1013         if (dwCurrentPlayCursor &lt; dwInitialPlayCursor)
1014         {
1015           if (dwCurrentPlayCursor &gt; dwInitialWriteCursor)
1016             break;
1017         }
1018       }
1019       Sleep(5);
1020     } while (TRUE);
1021 
1022     /*stop playing */
1023     hRes = IDirectSoundBuffer_Stop (dsoundsink-&gt;pDSBSecondary);
1024 
1025     /*reset position */
1026     hRes = IDirectSoundBuffer_SetCurrentPosition (dsoundsink-&gt;pDSBSecondary, 0);
1027     dsoundsink-&gt;current_circular_offset = 0;
1028 
1029     // Now reset entire buffer
1030     hRes = IDirectSoundBuffer_Lock (dsoundsink-&gt;pDSBSecondary,
1031       dsoundsink-&gt;current_circular_offset, dsoundsink-&gt;buffer_size,
1032       &amp;pLockedBuffer1, &amp;dwSizeBuffer1, NULL, NULL, 0L);
1033 
1034     if (SUCCEEDED (hRes)) {
1035       memset (pLockedBuffer1, 0, dwSizeBuffer1);
1036 
1037       hRes =
1038         IDirectSoundBuffer_Unlock (dsoundsink-&gt;pDSBSecondary, pLockedBuffer1,
1039         dwSizeBuffer1, NULL, 0);
1040     }
1041   }
1042 
1043   dsoundsink-&gt;reset_while_sleeping = TRUE;
1044   dsoundsink-&gt;first_buffer_after_reset = TRUE;
1045   if (dsoundsink-&gt;write_wait_clock_id != NULL) {
1046     gst_clock_id_unschedule (dsoundsink-&gt;write_wait_clock_id);
1047   }
1048 
1049   GST_DSOUND_UNLOCK (dsoundsink);
1050 }
1051 #endif // GSTREAMER_LITE
1052 
1053 /*
1054  * gst_directsound_probe_supported_formats:
1055  *
1056  * Takes the template caps and returns the subset which is actually
1057  * supported by this device.
1058  *
1059  */
1060 
1061 static GstCaps *
1062 gst_directsound_probe_supported_formats (GstDirectSoundSink * dsoundsink,
1063     const GstCaps * template_caps)
1064 {
1065   HRESULT hRes;
1066   DSBUFFERDESC descSecondary;
1067   WAVEFORMATEX wfx;
1068   GstCaps *caps;
1069   GstCaps *tmp, *tmp2;
1070   LPDIRECTSOUNDBUFFER tmpBuffer;
1071 
1072   caps = gst_caps_copy (template_caps);
1073 
1074   /*
1075    * Check availability of digital output by trying to create an SPDIF buffer
1076    */
1077 
1078 #ifdef WAVE_FORMAT_DOLBY_AC3_SPDIF
1079   /* fill the WAVEFORMATEX structure with some standard AC3 over SPDIF params */
1080   memset (&amp;wfx, 0, sizeof (wfx));
1081   wfx.cbSize = 0;
1082   wfx.wFormatTag = WAVE_FORMAT_DOLBY_AC3_SPDIF;
1083   wfx.nChannels = 2;
1084   wfx.nSamplesPerSec = 48000;
1085   wfx.wBitsPerSample = 16;
1086   wfx.nBlockAlign = 4;
1087   wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
1088 
1089   // create a secondary directsound buffer
1090   memset (&amp;descSecondary, 0, sizeof (DSBUFFERDESC));
1091   descSecondary.dwSize = sizeof (DSBUFFERDESC);
1092   descSecondary.dwFlags = DSBCAPS_GETCURRENTPOSITION2 | DSBCAPS_GLOBALFOCUS;
1093   descSecondary.dwBufferBytes = 6144;
1094   descSecondary.lpwfxFormat = &amp;wfx;
1095 
1096   hRes = IDirectSound_CreateSoundBuffer (dsoundsink-&gt;pDS, &amp;descSecondary,
1097       &amp;tmpBuffer, NULL);
1098   if (FAILED (hRes)) {
1099     gchar *error_text = gst_hres_to_string (hRes);
1100     GST_INFO_OBJECT (dsoundsink, &quot;AC3 passthrough not supported &quot;
1101         &quot;(IDirectSound_CreateSoundBuffer returned: %s)\n&quot;, error_text);
1102     g_free (error_text);
1103 #ifndef GSTREAMER_LITE
1104     tmp = gst_caps_new_empty_simple (&quot;audio/x-ac3&quot;);
1105     tmp2 = gst_caps_subtract (caps, tmp);
1106     gst_caps_unref (tmp);
1107     gst_caps_unref (caps);
1108     caps = tmp2;
1109     tmp = gst_caps_new_empty_simple (&quot;audio/x-dts&quot;);
1110     tmp2 = gst_caps_subtract (caps, tmp);
1111     gst_caps_unref (tmp);
1112     gst_caps_unref (caps);
1113     caps = tmp2;
1114 #else // GSTREAMER_LITE
1115     {
1116         GstCaps *caps1 = caps;
1117         GstCaps *caps2 = gst_caps_new_simple (&quot;audio/x-iec958&quot;, NULL);
1118         caps = gst_caps_subtract(caps1, caps2);
1119         gst_caps_unref(caps1);
1120         gst_caps_unref(caps2);
1121     }
1122 #endif // GSTREAMER_LITE
1123   } else {
1124     GST_INFO_OBJECT (dsoundsink, &quot;AC3 passthrough supported&quot;);
1125     hRes = IDirectSoundBuffer_Release (tmpBuffer);
1126     if (FAILED (hRes)) {
1127       gchar *error_text = gst_hres_to_string (hRes);
1128       GST_DEBUG_OBJECT (dsoundsink,
1129           &quot;(IDirectSoundBuffer_Release returned: %s)\n&quot;, error_text);
1130       g_free (error_text);
1131     }
1132   }
1133 #else
1134   tmp = gst_caps_new_empty_simple (&quot;audio/x-ac3&quot;);
1135   tmp2 = gst_caps_subtract (caps, tmp);
1136   gst_caps_unref (tmp);
1137   gst_caps_unref (caps);
1138   caps = tmp2;
1139   tmp = gst_caps_new_empty_simple (&quot;audio/x-dts&quot;);
1140   tmp2 = gst_caps_subtract (caps, tmp);
1141   gst_caps_unref (tmp);
1142   gst_caps_unref (caps);
1143   caps = tmp2;
1144 #endif
1145 
1146   return caps;
1147 }
1148 
1149 static GstBuffer *
1150 gst_directsound_sink_payload (GstAudioBaseSink * sink, GstBuffer * buf)
1151 {
1152   if (gst_directsound_sink_is_spdif_format (&amp;sink-&gt;ringbuffer-&gt;spec)) {
1153     gint framesize = gst_audio_iec61937_frame_size (&amp;sink-&gt;ringbuffer-&gt;spec);
1154     GstBuffer *out;
1155     GstMapInfo infobuf, infoout;
1156     gboolean success;
1157 
1158     if (framesize &lt;= 0)
1159       return NULL;
1160 
1161     out = gst_buffer_new_and_alloc (framesize);
1162 
1163     if (!gst_buffer_map (buf, &amp;infobuf, GST_MAP_READWRITE)) {
1164       gst_buffer_unref (out);
1165       return NULL;
1166     }
1167     if (!gst_buffer_map (out, &amp;infoout, GST_MAP_READWRITE)) {
1168       gst_buffer_unmap (buf, &amp;infobuf);
1169       gst_buffer_unref (out);
1170       return NULL;
1171     }
1172     success = gst_audio_iec61937_payload (infobuf.data, infobuf.size,
1173         infoout.data, infoout.size, &amp;sink-&gt;ringbuffer-&gt;spec, G_BYTE_ORDER);
1174     if (!success) {
1175       gst_buffer_unmap (out, &amp;infoout);
1176       gst_buffer_unmap (buf, &amp;infobuf);
1177       gst_buffer_unref (out);
1178       return NULL;
1179     }
1180 
1181     gst_buffer_copy_into (out, buf, GST_BUFFER_COPY_ALL, 0, -1);
1182     /* Fix endianness */
1183     _swab ((gchar *) infoout.data, (gchar *) infoout.data, infobuf.size);
1184     gst_buffer_unmap (out, &amp;infoout);
1185     gst_buffer_unmap (buf, &amp;infobuf);
1186     return out;
1187   } else
1188     return gst_buffer_ref (buf);
1189 }
1190 
1191 static void
1192 gst_directsound_sink_set_volume (GstDirectSoundSink * dsoundsink,
1193     gdouble dvolume, gboolean store)
1194 {
1195   glong volume;
1196 
1197   volume = dvolume * 100;
1198   if (store)
1199     dsoundsink-&gt;volume = volume;
1200 
1201   if (dsoundsink-&gt;pDSBSecondary) {
1202     /* DirectSound controls volume using units of 100th of a decibel,
1203      * ranging from -10000 to 0. We use a linear scale of 0 - 100
1204      * here, so remap.
1205      */
1206     long dsVolume;
1207     if (volume == 0 || dsoundsink-&gt;mute)
1208       dsVolume = -10000;
1209     else
1210       dsVolume = 100 * (long) (20 * log10 ((double) volume / 100.));
1211     dsVolume = CLAMP (dsVolume, -10000, 0);
1212 
1213     GST_DEBUG_OBJECT (dsoundsink,
1214         &quot;Setting volume on secondary buffer to %d from %d&quot;, (int) dsVolume,
1215         (int) volume);
1216     IDirectSoundBuffer_SetVolume (dsoundsink-&gt;pDSBSecondary, dsVolume);
1217   }
1218 }
1219 
1220 gdouble
1221 gst_directsound_sink_get_volume (GstDirectSoundSink * dsoundsink)
1222 {
1223   return (gdouble) dsoundsink-&gt;volume / 100;
1224 }
1225 
1226 static void
1227 gst_directsound_sink_set_mute (GstDirectSoundSink * dsoundsink, gboolean mute)
1228 {
1229   if (mute) {
1230     gst_directsound_sink_set_volume (dsoundsink, 0, FALSE);
1231     dsoundsink-&gt;mute = TRUE;
1232   } else {
1233     gst_directsound_sink_set_volume (dsoundsink,
1234         gst_directsound_sink_get_volume (dsoundsink), FALSE);
1235     dsoundsink-&gt;mute = FALSE;
1236   }
1237 
1238 }
1239 
1240 static gboolean
1241 gst_directsound_sink_get_mute (GstDirectSoundSink * dsoundsink)
1242 {
1243   return dsoundsink-&gt;mute;
1244 }
1245 
1246 static const gchar *
1247 gst_directsound_sink_get_device (GstDirectSoundSink * dsoundsink)
1248 {
1249   return dsoundsink-&gt;device_id;
1250 }
1251 
1252 static void
1253 gst_directsound_sink_set_device (GstDirectSoundSink * dsoundsink,
1254     const gchar * device_id)
1255 {
1256   g_free (dsoundsink-&gt;device_id);
1257   dsoundsink-&gt;device_id = g_strdup (device_id);
1258 }
1259 
1260 /* Converts a HRESULT error to a text string
1261  * LPTSTR is either a */
1262 static gchar *
1263 gst_hres_to_string (HRESULT hRes)
1264 {
1265   DWORD flags;
1266   gchar *ret_text;
1267   LPTSTR error_text = NULL;
1268 
1269   flags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER
1270       | FORMAT_MESSAGE_IGNORE_INSERTS;
1271   FormatMessage (flags, NULL, hRes, MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),
1272       (LPTSTR) &amp; error_text, 0, NULL);
1273 
1274 #ifdef UNICODE
1275   /* If UNICODE is defined, LPTSTR is LPWSTR which is UTF-16 */
1276   ret_text = g_utf16_to_utf8 (error_text, 0, NULL, NULL, NULL);
1277 #else
1278   ret_text = g_strdup (error_text);
1279 #endif
1280 
1281   LocalFree (error_text);
1282   return ret_text;
1283 }
    </pre>
  </body>
</html>