<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gparam.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gobject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gparam.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gparam.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  34  * @see_also: g_object_class_install_property(), g_object_set(),
  35  *     g_object_get(), g_object_set_property(), g_object_get_property(),
  36  *     g_value_register_transform_func()
  37  * @title: GParamSpec
  38  *
  39  * #GParamSpec is an object structure that encapsulates the metadata
  40  * required to specify parameters, such as e.g. #GObject properties.
  41  *
  42  * ## Parameter names # {#canonical-parameter-names}
  43  *
  44  * Parameter names need to start with a letter (a-z or A-Z).
  45  * Subsequent characters can be letters, numbers or a &#39;-&#39;.
  46  * All other characters are replaced by a &#39;-&#39; during construction.
  47  * The result of this replacement is called the canonical name of
  48  * the parameter.
  49  */
  50 
  51 
  52 /* --- defines --- */
  53 #define PARAM_FLOATING_FLAG                     0x2
<span class="line-modified">  54 #define G_PARAM_USER_MASK           (~0U &lt;&lt; G_PARAM_USER_SHIFT)</span>
<span class="line-modified">  55 #define PSPEC_APPLIES_TO_VALUE(pspec, value)    (G_TYPE_CHECK_VALUE_TYPE ((value), G_PARAM_SPEC_VALUE_TYPE (pspec)))</span>
  56 
  57 /* --- prototypes --- */
<span class="line-modified">  58 static void g_param_spec_class_base_init     (GParamSpecClass   *class);</span>
<span class="line-modified">  59 static void g_param_spec_class_base_finalize (GParamSpecClass   *class);</span>
<span class="line-modified">  60 static void g_param_spec_class_init      (GParamSpecClass   *class,</span>
<span class="line-modified">  61                           gpointer               class_data);</span>
<span class="line-modified">  62 static void g_param_spec_init        (GParamSpec        *pspec,</span>
<span class="line-modified">  63                           GParamSpecClass   *class);</span>
<span class="line-modified">  64 static void g_param_spec_finalize        (GParamSpec        *pspec);</span>
<span class="line-modified">  65 static void value_param_init        (GValue     *value);</span>
<span class="line-modified">  66 static void value_param_free_value      (GValue     *value);</span>
<span class="line-modified">  67 static void value_param_copy_value      (const GValue   *src_value,</span>
<span class="line-modified">  68                          GValue     *dest_value);</span>
<span class="line-modified">  69 static void value_param_transform_value (const GValue   *src_value,</span>
<span class="line-modified">  70                          GValue     *dest_value);</span>
<span class="line-modified">  71 static gpointer value_param_peek_pointer    (const GValue   *value);</span>
<span class="line-modified">  72 static gchar*   value_param_collect_value   (GValue     *value,</span>
<span class="line-modified">  73                                                  guint           n_collect_values,</span>
<span class="line-modified">  74                                                  GTypeCValue    *collect_values,</span>
<span class="line-modified">  75                                                  guint           collect_flags);</span>
<span class="line-modified">  76 static gchar*   value_param_lcopy_value     (const GValue   *value,</span>
<span class="line-modified">  77                          guint           n_collect_values,</span>
<span class="line-modified">  78                          GTypeCValue    *collect_values,</span>
<span class="line-modified">  79                          guint           collect_flags);</span>
  80 
  81 typedef struct
  82 {
  83   GValue default_value;
  84   GQuark name_quark;
  85 } GParamSpecPrivate;
  86 
  87 static gint g_param_private_offset;
  88 
  89 /* --- functions --- */
  90 static inline GParamSpecPrivate *
  91 g_param_spec_get_private (GParamSpec *pspec)
  92 {
  93   return &amp;G_STRUCT_MEMBER (GParamSpecPrivate, pspec, g_param_private_offset);
  94 }
  95 
  96 void
  97 _g_param_type_init (void)
  98 {
  99   static const GTypeFundamentalInfo finfo = {
 100     (G_TYPE_FLAG_CLASSED |
 101      G_TYPE_FLAG_INSTANTIATABLE |
 102      G_TYPE_FLAG_DERIVABLE |
 103      G_TYPE_FLAG_DEEP_DERIVABLE),
 104   };
 105   static const GTypeValueTable param_value_table = {
 106     value_param_init,           /* value_init */
 107     value_param_free_value,     /* value_free */
 108     value_param_copy_value,     /* value_copy */
 109     value_param_peek_pointer,   /* value_peek_pointer */
<span class="line-modified"> 110     &quot;p&quot;,            /* collect_format */</span>
 111     value_param_collect_value,  /* collect_value */
<span class="line-modified"> 112     &quot;p&quot;,            /* lcopy_format */</span>
 113     value_param_lcopy_value,    /* lcopy_value */
 114   };
 115   const GTypeInfo param_spec_info = {
 116     sizeof (GParamSpecClass),
 117 
 118     (GBaseInitFunc) g_param_spec_class_base_init,
 119     (GBaseFinalizeFunc) g_param_spec_class_base_finalize,
 120     (GClassInitFunc) g_param_spec_class_init,
 121     (GClassFinalizeFunc) NULL,
<span class="line-modified"> 122     NULL,   /* class_data */</span>
 123 
 124     sizeof (GParamSpec),
<span class="line-modified"> 125     0,      /* n_preallocs */</span>
 126     (GInstanceInitFunc) g_param_spec_init,
 127 
 128     &amp;param_value_table,
 129   };
 130   GType type;
 131 
 132   /* This should be registered as GParamSpec instead of GParam, for
 133    * consistency sake, so that type name can be mapped to struct name,
 134    * However, some language bindings, most noticeable the python ones
 135    * depends on the &quot;GParam&quot; identifier, see #548689
 136    */
 137   type = g_type_register_fundamental (G_TYPE_PARAM, g_intern_static_string (&quot;GParam&quot;), &amp;param_spec_info, &amp;finfo, G_TYPE_FLAG_ABSTRACT);
 138   g_assert (type == G_TYPE_PARAM);
 139   g_param_private_offset = g_type_add_instance_private (type, sizeof (GParamSpecPrivate));
 140   g_value_register_transform_func (G_TYPE_PARAM, G_TYPE_PARAM, value_param_transform_value);
 141 }
 142 
 143 static void
 144 g_param_spec_class_base_init (GParamSpecClass *class)
 145 {
 146 }
 147 
 148 static void
 149 g_param_spec_class_base_finalize (GParamSpecClass *class)
 150 {
 151 }
 152 
 153 static void
 154 g_param_spec_class_init (GParamSpecClass *class,
<span class="line-modified"> 155              gpointer         class_data)</span>
 156 {
 157   class-&gt;value_type = G_TYPE_NONE;
 158   class-&gt;finalize = g_param_spec_finalize;
 159   class-&gt;value_set_default = NULL;
 160   class-&gt;value_validate = NULL;
 161   class-&gt;values_cmp = NULL;
 162 
 163   g_type_class_adjust_private_offset (class, &amp;g_param_private_offset);
 164 }
 165 
 166 static void
 167 g_param_spec_init (GParamSpec      *pspec,
<span class="line-modified"> 168            GParamSpecClass *class)</span>
 169 {
 170   pspec-&gt;name = NULL;
 171   pspec-&gt;_nick = NULL;
 172   pspec-&gt;_blurb = NULL;
 173   pspec-&gt;flags = 0;
 174   pspec-&gt;value_type = class-&gt;value_type;
 175   pspec-&gt;owner_type = 0;
 176   pspec-&gt;qdata = NULL;
 177   g_datalist_set_flags (&amp;pspec-&gt;qdata, PARAM_FLOATING_FLAG);
 178   pspec-&gt;ref_count = 1;
 179   pspec-&gt;param_id = 0;
 180 }
 181 
 182 static void
 183 g_param_spec_finalize (GParamSpec *pspec)
 184 {
 185   GParamSpecPrivate *priv = g_param_spec_get_private (pspec);
 186 
 187   if (priv-&gt;default_value.g_type)
 188     g_value_reset (&amp;priv-&gt;default_value);
</pre>
<hr />
<pre>
 305  * g_param_spec_get_nick:
 306  * @pspec: a valid #GParamSpec
 307  *
 308  * Get the nickname of a #GParamSpec.
 309  *
 310  * Returns: the nickname of @pspec.
 311  */
 312 const gchar *
 313 g_param_spec_get_nick (GParamSpec *pspec)
 314 {
 315   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), NULL);
 316 
 317   if (pspec-&gt;_nick)
 318     return pspec-&gt;_nick;
 319   else
 320     {
 321       GParamSpec *redirect_target;
 322 
 323       redirect_target = g_param_spec_get_redirect_target (pspec);
 324       if (redirect_target &amp;&amp; redirect_target-&gt;_nick)
<span class="line-modified"> 325     return redirect_target-&gt;_nick;</span>
 326     }
 327 
 328   return pspec-&gt;name;
 329 }
 330 
 331 /**
 332  * g_param_spec_get_blurb:
 333  * @pspec: a valid #GParamSpec
 334  *
 335  * Get the short description of a #GParamSpec.
 336  *
 337  * Returns: the short description of @pspec.
 338  */
 339 const gchar *
 340 g_param_spec_get_blurb (GParamSpec *pspec)
 341 {
 342   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), NULL);
 343 
 344   if (pspec-&gt;_blurb)
 345     return pspec-&gt;_blurb;
 346   else
 347     {
 348       GParamSpec *redirect_target;
 349 
 350       redirect_target = g_param_spec_get_redirect_target (pspec);
 351       if (redirect_target &amp;&amp; redirect_target-&gt;_blurb)
<span class="line-modified"> 352     return redirect_target-&gt;_blurb;</span>
 353     }
 354 
 355   return NULL;
 356 }
 357 
 358 static void
 359 canonicalize_key (gchar *key)
 360 {
 361   gchar *p;
 362 
 363   for (p = key; *p != 0; p++)
 364     {
 365       gchar c = *p;
 366 
 367       if (c != &#39;-&#39; &amp;&amp;
<span class="line-modified"> 368       (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) &amp;&amp;</span>
<span class="line-modified"> 369       (c &lt; &#39;A&#39; || c &gt; &#39;Z&#39;) &amp;&amp;</span>
<span class="line-modified"> 370       (c &lt; &#39;a&#39; || c &gt; &#39;z&#39;))</span>
<span class="line-modified"> 371     *p = &#39;-&#39;;</span>
 372     }
 373 }
 374 
 375 static gboolean
 376 is_canonical (const gchar *key)
 377 {
 378   const gchar *p;
 379 
 380   for (p = key; *p != 0; p++)
 381     {
 382       gchar c = *p;
 383 
 384       if (c != &#39;-&#39; &amp;&amp;
<span class="line-modified"> 385       (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) &amp;&amp;</span>
<span class="line-modified"> 386       (c &lt; &#39;A&#39; || c &gt; &#39;Z&#39;) &amp;&amp;</span>
<span class="line-modified"> 387       (c &lt; &#39;a&#39; || c &gt; &#39;z&#39;))</span>
<span class="line-modified"> 388     return FALSE;</span>
 389     }
 390 
 391   return TRUE;
 392 }
 393 
 394 /**
 395  * g_param_spec_internal: (skip)
 396  * @param_type: the #GType for the property; must be derived from #G_TYPE_PARAM
 397  * @name: the canonical name of the property
 398  * @nick: the nickname of the property
 399  * @blurb: a short description of the property
 400  * @flags: a combination of #GParamFlags
 401  *
 402  * Creates a new #GParamSpec instance.
 403  *
 404  * A property name consists of segments consisting of ASCII letters and
 405  * digits, separated by either the &#39;-&#39; or &#39;_&#39; character. The first
 406  * character of a property name must be a letter. Names which violate these
 407  * rules lead to undefined behaviour.
 408  *
 409  * When creating and looking up a #GParamSpec, either separator can be
 410  * used, but they cannot be mixed. Using &#39;-&#39; is considerably more
 411  * efficient and in fact required when using property names as detail
 412  * strings for signals.
 413  *
 414  * Beyond the name, #GParamSpecs have two more descriptive
 415  * strings associated with them, the @nick, which should be suitable
 416  * for use as a label for the property in a property editor, and the
 417  * @blurb, which should be a somewhat longer description, suitable for
 418  * e.g. a tooltip. The @nick and @blurb should ideally be localized.
 419  *
 420  * Returns: (type GObject.ParamSpec): a newly allocated #GParamSpec instance
 421  */
 422 gpointer
 423 g_param_spec_internal (GType        param_type,
<span class="line-modified"> 424                const gchar *name,</span>
<span class="line-modified"> 425                const gchar *nick,</span>
<span class="line-modified"> 426                const gchar *blurb,</span>
<span class="line-modified"> 427                GParamFlags  flags)</span>
 428 {
 429   GParamSpec *pspec;
 430   GParamSpecPrivate *priv;
 431 
 432   g_return_val_if_fail (G_TYPE_IS_PARAM (param_type) &amp;&amp; param_type != G_TYPE_PARAM, NULL);
 433   g_return_val_if_fail (name != NULL, NULL);
 434   g_return_val_if_fail ((name[0] &gt;= &#39;A&#39; &amp;&amp; name[0] &lt;= &#39;Z&#39;) || (name[0] &gt;= &#39;a&#39; &amp;&amp; name[0] &lt;= &#39;z&#39;), NULL);
 435   g_return_val_if_fail (!(flags &amp; G_PARAM_STATIC_NAME) || is_canonical (name), NULL);
 436 
 437   pspec = (gpointer) g_type_create_instance (param_type);
 438 #ifdef GSTREAMER_LITE
 439   if (pspec == NULL)
 440       return NULL;
 441 #endif // GSTREAMER_LITE
 442 
 443   if (flags &amp; G_PARAM_STATIC_NAME)
 444     {
 445       /* pspec-&gt;name is not freed if (flags &amp; G_PARAM_STATIC_NAME) */
 446       pspec-&gt;name = (gchar *) g_intern_static_string (name);
 447       if (!is_canonical (pspec-&gt;name))
</pre>
<hr />
<pre>
 472     pspec-&gt;_blurb = (gchar*) blurb;
 473   else
 474     pspec-&gt;_blurb = g_strdup (blurb);
 475 
 476   pspec-&gt;flags = (flags &amp; G_PARAM_USER_MASK) | (flags &amp; G_PARAM_MASK);
 477 
 478   return pspec;
 479 }
 480 
 481 /**
 482  * g_param_spec_get_qdata:
 483  * @pspec: a valid #GParamSpec
 484  * @quark: a #GQuark, naming the user data pointer
 485  *
 486  * Gets back user data pointers stored via g_param_spec_set_qdata().
 487  *
 488  * Returns: (transfer none): the user data pointer set, or %NULL
 489  */
 490 gpointer
 491 g_param_spec_get_qdata (GParamSpec *pspec,
<span class="line-modified"> 492             GQuark      quark)</span>
 493 {
 494   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), NULL);
 495 
 496   return quark ? g_datalist_id_get_data (&amp;pspec-&gt;qdata, quark) : NULL;
 497 }
 498 
 499 /**
 500  * g_param_spec_set_qdata:
 501  * @pspec: the #GParamSpec to set store a user data pointer
 502  * @quark: a #GQuark, naming the user data pointer
 503  * @data: an opaque user data pointer
 504  *
 505  * Sets an opaque, named pointer on a #GParamSpec. The name is
 506  * specified through a #GQuark (retrieved e.g. via
 507  * g_quark_from_static_string()), and the pointer can be gotten back
 508  * from the @pspec with g_param_spec_get_qdata().  Setting a
 509  * previously set user data pointer, overrides (frees) the old pointer
 510  * set, using %NULL as pointer essentially removes the data stored.
 511  */
 512 void
 513 g_param_spec_set_qdata (GParamSpec *pspec,
<span class="line-modified"> 514             GQuark      quark,</span>
<span class="line-modified"> 515             gpointer    data)</span>
 516 {
 517   g_return_if_fail (G_IS_PARAM_SPEC (pspec));
 518   g_return_if_fail (quark &gt; 0);
 519 
 520   g_datalist_id_set_data (&amp;pspec-&gt;qdata, quark, data);
 521 }
 522 
 523 /**
 524  * g_param_spec_set_qdata_full: (skip)
 525  * @pspec: the #GParamSpec to set store a user data pointer
 526  * @quark: a #GQuark, naming the user data pointer
 527  * @data: an opaque user data pointer
 528  * @destroy: function to invoke with @data as argument, when @data needs to
 529  *  be freed
 530  *
 531  * This function works like g_param_spec_set_qdata(), but in addition,
 532  * a `void (*destroy) (gpointer)` function may be
 533  * specified which is called with @data as argument when the @pspec is
 534  * finalized, or the data is being overwritten by a call to
 535  * g_param_spec_set_qdata() with the same @quark.
 536  */
 537 void
 538 g_param_spec_set_qdata_full (GParamSpec    *pspec,
<span class="line-modified"> 539                  GQuark         quark,</span>
<span class="line-modified"> 540                  gpointer       data,</span>
<span class="line-modified"> 541                  GDestroyNotify destroy)</span>
 542 {
 543   g_return_if_fail (G_IS_PARAM_SPEC (pspec));
 544   g_return_if_fail (quark &gt; 0);
 545 
 546   g_datalist_id_set_data_full (&amp;pspec-&gt;qdata, quark, data, data ? destroy : (GDestroyNotify) NULL);
 547 }
 548 
 549 /**
 550  * g_param_spec_steal_qdata:
 551  * @pspec: the #GParamSpec to get a stored user data pointer from
 552  * @quark: a #GQuark, naming the user data pointer
 553  *
 554  * Gets back user data pointers stored via g_param_spec_set_qdata()
 555  * and removes the @data from @pspec without invoking its destroy()
 556  * function (if any was set).  Usually, calling this function is only
 557  * required to update user data pointers with a destroy notifier.
 558  *
 559  * Returns: (transfer none): the user data pointer set, or %NULL
 560  */
 561 gpointer
 562 g_param_spec_steal_qdata (GParamSpec *pspec,
<span class="line-modified"> 563               GQuark      quark)</span>
 564 {
 565   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), NULL);
 566   g_return_val_if_fail (quark &gt; 0, NULL);
 567 
 568   return g_datalist_id_remove_no_notify (&amp;pspec-&gt;qdata, quark);
 569 }
 570 
 571 /**
 572  * g_param_spec_get_redirect_target:
 573  * @pspec: a #GParamSpec
 574  *
 575  * If the paramspec redirects operations to another paramspec,
 576  * returns that paramspec. Redirect is used typically for
 577  * providing a new implementation of a property in a derived
 578  * type while preserving all the properties from the parent
 579  * type. Redirection is established by creating a property
 580  * of type #GParamSpecOverride. See g_object_class_override_property()
 581  * for an example of the use of this capability.
 582  *
 583  * Since: 2.4
</pre>
<hr />
<pre>
 588 GParamSpec*
 589 g_param_spec_get_redirect_target (GParamSpec *pspec)
 590 {
 591   GTypeInstance *inst = (GTypeInstance *)pspec;
 592 
 593   if (inst &amp;&amp; inst-&gt;g_class &amp;&amp; inst-&gt;g_class-&gt;g_type == G_TYPE_PARAM_OVERRIDE)
 594     return ((GParamSpecOverride*)pspec)-&gt;overridden;
 595   else
 596     return NULL;
 597 }
 598 
 599 /**
 600  * g_param_value_set_default:
 601  * @pspec: a valid #GParamSpec
 602  * @value: a #GValue of correct type for @pspec
 603  *
 604  * Sets @value to its default value as specified in @pspec.
 605  */
 606 void
 607 g_param_value_set_default (GParamSpec *pspec,
<span class="line-modified"> 608                GValue     *value)</span>
 609 {
 610   g_return_if_fail (G_IS_PARAM_SPEC (pspec));
 611   g_return_if_fail (G_IS_VALUE (value));
 612   g_return_if_fail (PSPEC_APPLIES_TO_VALUE (pspec, value));
 613 
 614   g_value_reset (value);
 615   G_PARAM_SPEC_GET_CLASS (pspec)-&gt;value_set_default (pspec, value);
 616 }
 617 
 618 /**
 619  * g_param_value_defaults:
 620  * @pspec: a valid #GParamSpec
 621  * @value: a #GValue of correct type for @pspec
 622  *
 623  * Checks whether @value contains the default value as specified in @pspec.
 624  *
 625  * Returns: whether @value contains the canonical default for this @pspec
 626  */
 627 gboolean
 628 g_param_value_defaults (GParamSpec *pspec,
<span class="line-modified"> 629             GValue     *value)</span>
 630 {
 631   GValue dflt_value = G_VALUE_INIT;
 632   gboolean defaults;
 633 
 634   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), FALSE);
 635   g_return_val_if_fail (G_IS_VALUE (value), FALSE);
 636   g_return_val_if_fail (PSPEC_APPLIES_TO_VALUE (pspec, value), FALSE);
 637 
 638   g_value_init (&amp;dflt_value, G_PARAM_SPEC_VALUE_TYPE (pspec));
 639   G_PARAM_SPEC_GET_CLASS (pspec)-&gt;value_set_default (pspec, &amp;dflt_value);
 640   defaults = G_PARAM_SPEC_GET_CLASS (pspec)-&gt;values_cmp (pspec, value, &amp;dflt_value) == 0;
 641   g_value_unset (&amp;dflt_value);
 642 
 643   return defaults;
 644 }
 645 
 646 /**
 647  * g_param_value_validate:
 648  * @pspec: a valid #GParamSpec
 649  * @value: a #GValue of correct type for @pspec
 650  *
 651  * Ensures that the contents of @value comply with the specifications
 652  * set out by @pspec. For example, a #GParamSpecInt might require
 653  * that integers stored in @value may not be smaller than -42 and not be
 654  * greater than +42. If @value contains an integer outside of this range,
 655  * it is modified accordingly, so the resulting value will fit into the
 656  * range -42 .. +42.
 657  *
 658  * Returns: whether modifying @value was necessary to ensure validity
 659  */
 660 gboolean
 661 g_param_value_validate (GParamSpec *pspec,
<span class="line-modified"> 662             GValue     *value)</span>
 663 {
 664   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), FALSE);
 665   g_return_val_if_fail (G_IS_VALUE (value), FALSE);
 666   g_return_val_if_fail (PSPEC_APPLIES_TO_VALUE (pspec, value), FALSE);
 667 
 668   if (G_PARAM_SPEC_GET_CLASS (pspec)-&gt;value_validate)
 669     {
 670       GValue oval = *value;
 671 
 672       if (G_PARAM_SPEC_GET_CLASS (pspec)-&gt;value_validate (pspec, value) ||
<span class="line-modified"> 673       memcmp (&amp;oval.data, &amp;value-&gt;data, sizeof (oval.data)))</span>
<span class="line-modified"> 674     return TRUE;</span>
 675     }
 676 
 677   return FALSE;
 678 }
 679 
 680 /**
 681  * g_param_value_convert:
 682  * @pspec: a valid #GParamSpec
 683  * @src_value: souce #GValue
 684  * @dest_value: destination #GValue of correct type for @pspec
 685  * @strict_validation: %TRUE requires @dest_value to conform to @pspec
 686  * without modifications
 687  *
 688  * Transforms @src_value into @dest_value if possible, and then
 689  * validates @dest_value, in order for it to conform to @pspec.  If
 690  * @strict_validation is %TRUE this function will only succeed if the
 691  * transformed @dest_value complied to @pspec without modifications.
 692  *
 693  * See also g_value_type_transformable(), g_value_transform() and
 694  * g_param_value_validate().
 695  *
 696  * Returns: %TRUE if transformation and validation were successful,
 697  *  %FALSE otherwise and @dest_value is left untouched.
 698  */
 699 gboolean
 700 g_param_value_convert (GParamSpec   *pspec,
<span class="line-modified"> 701                        const GValue *src_value,</span>
<span class="line-modified"> 702                        GValue       *dest_value,</span>
<span class="line-modified"> 703                gboolean      strict_validation)</span>
 704 {
 705   GValue tmp_value = G_VALUE_INIT;
 706 
 707   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), FALSE);
 708   g_return_val_if_fail (G_IS_VALUE (src_value), FALSE);
 709   g_return_val_if_fail (G_IS_VALUE (dest_value), FALSE);
 710   g_return_val_if_fail (PSPEC_APPLIES_TO_VALUE (pspec, dest_value), FALSE);
 711 
 712   /* better leave dest_value untouched when returning FALSE */
 713 
 714   g_value_init (&amp;tmp_value, G_VALUE_TYPE (dest_value));
 715   if (g_value_transform (src_value, &amp;tmp_value) &amp;&amp;
 716       (!g_param_value_validate (pspec, &amp;tmp_value) || !strict_validation))
 717     {
 718       g_value_unset (dest_value);
 719 
 720       /* values are relocatable */
 721       memcpy (dest_value, &amp;tmp_value, sizeof (tmp_value));
 722 
 723       return TRUE;
</pre>
<hr />
<pre>
 727       g_value_unset (&amp;tmp_value);
 728 
 729       return FALSE;
 730     }
 731 }
 732 
 733 /**
 734  * g_param_values_cmp:
 735  * @pspec: a valid #GParamSpec
 736  * @value1: a #GValue of correct type for @pspec
 737  * @value2: a #GValue of correct type for @pspec
 738  *
 739  * Compares @value1 with @value2 according to @pspec, and return -1, 0 or +1,
 740  * if @value1 is found to be less than, equal to or greater than @value2,
 741  * respectively.
 742  *
 743  * Returns: -1, 0 or +1, for a less than, equal to or greater than result
 744  */
 745 gint
 746 g_param_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 747             const GValue *value1,</span>
<span class="line-modified"> 748             const GValue *value2)</span>
 749 {
 750   gint cmp;
 751 
 752   /* param_values_cmp() effectively does: value1 - value2
 753    * so the return values are:
 754    * -1)  value1 &lt; value2
 755    *  0)  value1 == value2
 756    *  1)  value1 &gt; value2
 757    */
 758   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), 0);
 759   g_return_val_if_fail (G_IS_VALUE (value1), 0);
 760   g_return_val_if_fail (G_IS_VALUE (value2), 0);
 761   g_return_val_if_fail (PSPEC_APPLIES_TO_VALUE (pspec, value1), 0);
 762   g_return_val_if_fail (PSPEC_APPLIES_TO_VALUE (pspec, value2), 0);
 763 
 764   cmp = G_PARAM_SPEC_GET_CLASS (pspec)-&gt;values_cmp (pspec, value1, value2);
 765 
 766   return CLAMP (cmp, -1, 1);
 767 }
 768 
 769 static void
 770 value_param_init (GValue *value)
 771 {
 772   value-&gt;data[0].v_pointer = NULL;
 773 }
 774 
 775 static void
 776 value_param_free_value (GValue *value)
 777 {
 778   if (value-&gt;data[0].v_pointer)
 779     g_param_spec_unref (value-&gt;data[0].v_pointer);
 780 }
 781 
 782 static void
 783 value_param_copy_value (const GValue *src_value,
<span class="line-modified"> 784             GValue       *dest_value)</span>
 785 {
 786   if (src_value-&gt;data[0].v_pointer)
 787     dest_value-&gt;data[0].v_pointer = g_param_spec_ref (src_value-&gt;data[0].v_pointer);
 788   else
 789     dest_value-&gt;data[0].v_pointer = NULL;
 790 }
 791 
 792 static void
 793 value_param_transform_value (const GValue *src_value,
<span class="line-modified"> 794                  GValue       *dest_value)</span>
 795 {
 796   if (src_value-&gt;data[0].v_pointer &amp;&amp;
 797       g_type_is_a (G_PARAM_SPEC_TYPE (dest_value-&gt;data[0].v_pointer), G_VALUE_TYPE (dest_value)))
 798     dest_value-&gt;data[0].v_pointer = g_param_spec_ref (src_value-&gt;data[0].v_pointer);
 799   else
 800     dest_value-&gt;data[0].v_pointer = NULL;
 801 }
 802 
 803 static gpointer
 804 value_param_peek_pointer (const GValue *value)
 805 {
 806   return value-&gt;data[0].v_pointer;
 807 }
 808 
 809 static gchar*
 810 value_param_collect_value (GValue      *value,
<span class="line-modified"> 811                guint        n_collect_values,</span>
<span class="line-modified"> 812                GTypeCValue *collect_values,</span>
<span class="line-modified"> 813                guint        collect_flags)</span>
 814 {
 815   if (collect_values[0].v_pointer)
 816     {
 817       GParamSpec *param = collect_values[0].v_pointer;
 818 
 819       if (param-&gt;g_type_instance.g_class == NULL)
<span class="line-modified"> 820     return g_strconcat (&quot;invalid unclassed param spec pointer for value type &#39;&quot;,</span>
<span class="line-modified"> 821                 G_VALUE_TYPE_NAME (value),</span>
<span class="line-modified"> 822                 &quot;&#39;&quot;,</span>
<span class="line-modified"> 823                 NULL);</span>
 824       else if (!g_value_type_compatible (G_PARAM_SPEC_TYPE (param), G_VALUE_TYPE (value)))
<span class="line-modified"> 825     return g_strconcat (&quot;invalid param spec type &#39;&quot;,</span>
<span class="line-modified"> 826                 G_PARAM_SPEC_TYPE_NAME (param),</span>
<span class="line-modified"> 827                 &quot;&#39; for value type &#39;&quot;,</span>
<span class="line-modified"> 828                 G_VALUE_TYPE_NAME (value),</span>
<span class="line-modified"> 829                 &quot;&#39;&quot;,</span>
<span class="line-modified"> 830                 NULL);</span>
 831       value-&gt;data[0].v_pointer = g_param_spec_ref (param);
 832     }
 833   else
 834     value-&gt;data[0].v_pointer = NULL;
 835 
 836   return NULL;
 837 }
 838 
 839 static gchar*
 840 value_param_lcopy_value (const GValue *value,
<span class="line-modified"> 841              guint         n_collect_values,</span>
<span class="line-modified"> 842              GTypeCValue  *collect_values,</span>
<span class="line-modified"> 843              guint         collect_flags)</span>
 844 {
 845   GParamSpec **param_p = collect_values[0].v_pointer;
 846 
 847   if (!param_p)
 848     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 849 
 850   if (!value-&gt;data[0].v_pointer)
 851     *param_p = NULL;
 852   else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
 853     *param_p = value-&gt;data[0].v_pointer;
 854   else
 855     *param_p = g_param_spec_ref (value-&gt;data[0].v_pointer);
 856 
 857   return NULL;
 858 }
 859 
 860 
 861 /* --- param spec pool --- */
 862 /**
 863  * GParamSpecPool:
</pre>
<hr />
<pre>
 872   GMutex       mutex;
 873   gboolean     type_prefixing;
 874   GHashTable  *hash_table;
 875 };
 876 
 877 static guint
 878 param_spec_pool_hash (gconstpointer key_spec)
 879 {
 880   const GParamSpec *key = key_spec;
 881   const gchar *p;
 882   guint h = key-&gt;owner_type;
 883 
 884   for (p = key-&gt;name; *p; p++)
 885     h = (h &lt;&lt; 5) - h + *p;
 886 
 887   return h;
 888 }
 889 
 890 static gboolean
 891 param_spec_pool_equals (gconstpointer key_spec_1,
<span class="line-modified"> 892             gconstpointer key_spec_2)</span>
 893 {
 894   const GParamSpec *key1 = key_spec_1;
 895   const GParamSpec *key2 = key_spec_2;
 896 
 897   return (key1-&gt;owner_type == key2-&gt;owner_type &amp;&amp;
<span class="line-modified"> 898       strcmp (key1-&gt;name, key2-&gt;name) == 0);</span>
 899 }
 900 
 901 /**
 902  * g_param_spec_pool_new:
 903  * @type_prefixing: Whether the pool will support type-prefixed property names.
 904  *
 905  * Creates a new #GParamSpecPool.
 906  *
 907  * If @type_prefixing is %TRUE, lookups in the newly created pool will
 908  * allow to specify the owner as a colon-separated prefix of the
 909  * property name, like &quot;GtkContainer:border-width&quot;. This feature is
 910  * deprecated, so you should always set @type_prefixing to %FALSE.
 911  *
 912  * Returns: (transfer none): a newly allocated #GParamSpecPool.
 913  */
 914 GParamSpecPool*
 915 g_param_spec_pool_new (gboolean type_prefixing)
 916 {
 917   static GMutex init_mutex;
 918   GParamSpecPool *pool = g_new (GParamSpecPool, 1);
 919 
 920   memcpy (&amp;pool-&gt;mutex, &amp;init_mutex, sizeof (init_mutex));
 921   pool-&gt;type_prefixing = type_prefixing != FALSE;
 922   pool-&gt;hash_table = g_hash_table_new (param_spec_pool_hash, param_spec_pool_equals);
 923 
 924   return pool;
 925 }
 926 
 927 /**
 928  * g_param_spec_pool_insert:
 929  * @pool: a #GParamSpecPool.
 930  * @pspec: the #GParamSpec to insert
 931  * @owner_type: a #GType identifying the owner of @pspec
 932  *
 933  * Inserts a #GParamSpec in the pool.
 934  */
 935 void
 936 g_param_spec_pool_insert (GParamSpecPool *pool,
<span class="line-modified"> 937               GParamSpec     *pspec,</span>
<span class="line-modified"> 938               GType           owner_type)</span>
 939 {
 940   const gchar *p;
 941 
 942   if (pool &amp;&amp; pspec &amp;&amp; owner_type &gt; 0 &amp;&amp; pspec-&gt;owner_type == 0)
 943     {
 944       for (p = pspec-&gt;name; *p; p++)
<span class="line-modified"> 945     {</span>
<span class="line-modified"> 946       if (!strchr (G_CSET_A_2_Z G_CSET_a_2_z G_CSET_DIGITS &quot;-_&quot;, *p))</span>
<span class="line-modified"> 947         {</span>
<span class="line-modified"> 948           g_warning (G_STRLOC &quot;: pspec name \&quot;%s\&quot; contains invalid characters&quot;, pspec-&gt;name);</span>
<span class="line-modified"> 949           return;</span>
<span class="line-modified"> 950         }</span>
<span class="line-modified"> 951     }</span>
 952       g_mutex_lock (&amp;pool-&gt;mutex);
 953       pspec-&gt;owner_type = owner_type;
 954       g_param_spec_ref (pspec);
 955       g_hash_table_add (pool-&gt;hash_table, pspec);
 956       g_mutex_unlock (&amp;pool-&gt;mutex);
 957     }
 958   else
 959     {
 960       g_return_if_fail (pool != NULL);
 961       g_return_if_fail (pspec);
 962       g_return_if_fail (owner_type &gt; 0);
 963       g_return_if_fail (pspec-&gt;owner_type == 0);
 964     }
 965 }
 966 
 967 /**
 968  * g_param_spec_pool_remove:
 969  * @pool: a #GParamSpecPool
 970  * @pspec: the #GParamSpec to remove
 971  *
 972  * Removes a #GParamSpec from the pool.
 973  */
 974 void
 975 g_param_spec_pool_remove (GParamSpecPool *pool,
<span class="line-modified"> 976               GParamSpec     *pspec)</span>
 977 {
 978   if (pool &amp;&amp; pspec)
 979     {
 980       g_mutex_lock (&amp;pool-&gt;mutex);
 981       if (g_hash_table_remove (pool-&gt;hash_table, pspec))
<span class="line-modified"> 982     g_param_spec_unref (pspec);</span>
 983       else
<span class="line-modified"> 984     g_warning (G_STRLOC &quot;: attempt to remove unknown pspec &#39;%s&#39; from pool&quot;, pspec-&gt;name);</span>
 985       g_mutex_unlock (&amp;pool-&gt;mutex);
 986     }
 987   else
 988     {
 989       g_return_if_fail (pool != NULL);
 990       g_return_if_fail (pspec);
 991     }
 992 }
 993 
 994 static inline GParamSpec*
 995 param_spec_ht_lookup (GHashTable  *hash_table,
<span class="line-modified"> 996               const gchar *param_name,</span>
<span class="line-modified"> 997               GType        owner_type,</span>
<span class="line-modified"> 998               gboolean     walk_ancestors)</span>
 999 {
1000   GParamSpec key, *pspec;
1001 
1002   key.owner_type = owner_type;
1003   key.name = (gchar*) param_name;
1004   if (walk_ancestors)
1005     do
1006       {
<span class="line-modified">1007     pspec = g_hash_table_lookup (hash_table, &amp;key);</span>
<span class="line-modified">1008     if (pspec)</span>
<span class="line-modified">1009       return pspec;</span>
<span class="line-modified">1010     key.owner_type = g_type_parent (key.owner_type);</span>
1011       }
1012     while (key.owner_type);
1013   else
1014     pspec = g_hash_table_lookup (hash_table, &amp;key);
1015 
1016   if (!pspec &amp;&amp; !is_canonical (param_name))
1017     {
1018       gchar *canonical;
1019 
1020       canonical = g_strdup (key.name);
1021       canonicalize_key (canonical);
1022 
1023       /* try canonicalized form */
1024       key.name = canonical;
1025       key.owner_type = owner_type;
1026 
1027       if (walk_ancestors)
1028         do
1029           {
1030             pspec = g_hash_table_lookup (hash_table, &amp;key);
</pre>
<hr />
<pre>
1043     }
1044 
1045   return pspec;
1046 }
1047 
1048 /**
1049  * g_param_spec_pool_lookup:
1050  * @pool: a #GParamSpecPool
1051  * @param_name: the name to look for
1052  * @owner_type: the owner to look for
1053  * @walk_ancestors: If %TRUE, also try to find a #GParamSpec with @param_name
1054  *  owned by an ancestor of @owner_type.
1055  *
1056  * Looks up a #GParamSpec in the pool.
1057  *
1058  * Returns: (transfer none): The found #GParamSpec, or %NULL if no
1059  * matching #GParamSpec was found.
1060  */
1061 GParamSpec*
1062 g_param_spec_pool_lookup (GParamSpecPool *pool,
<span class="line-modified">1063               const gchar    *param_name,</span>
<span class="line-modified">1064               GType           owner_type,</span>
<span class="line-modified">1065               gboolean        walk_ancestors)</span>
1066 {
1067   GParamSpec *pspec;
1068   gchar *delim;
1069 
1070   g_return_val_if_fail (pool != NULL, NULL);
1071   g_return_val_if_fail (param_name != NULL, NULL);
1072 
1073   g_mutex_lock (&amp;pool-&gt;mutex);
1074 
1075   delim = pool-&gt;type_prefixing ? strchr (param_name, &#39;:&#39;) : NULL;
1076 
1077   /* try quick and away, i.e. without prefix */
1078   if (!delim)
1079     {
1080       pspec = param_spec_ht_lookup (pool-&gt;hash_table, param_name, owner_type, walk_ancestors);
1081       g_mutex_unlock (&amp;pool-&gt;mutex);
1082 
1083       return pspec;
1084     }
1085 
1086   /* strip type prefix */
1087   if (pool-&gt;type_prefixing &amp;&amp; delim[1] == &#39;:&#39;)
1088     {
1089       guint l = delim - param_name;
1090       gchar stack_buffer[32], *buffer = l &lt; 32 ? stack_buffer : g_new (gchar, l + 1);
1091       GType type;
1092 
1093       strncpy (buffer, param_name, delim - param_name);
1094       buffer[l] = 0;
1095       type = g_type_from_name (buffer);
1096       if (l &gt;= 32)
<span class="line-modified">1097     g_free (buffer);</span>
<span class="line-modified">1098       if (type)     /* type==0 isn&#39;t a valid type pefix */</span>
<span class="line-modified">1099     {</span>
<span class="line-modified">1100       /* sanity check, these cases don&#39;t make a whole lot of sense */</span>
<span class="line-modified">1101       if ((!walk_ancestors &amp;&amp; type != owner_type) || !g_type_is_a (owner_type, type))</span>
<span class="line-modified">1102         {</span>
<span class="line-modified">1103           g_mutex_unlock (&amp;pool-&gt;mutex);</span>
1104 
<span class="line-modified">1105           return NULL;</span>
<span class="line-modified">1106         }</span>
<span class="line-modified">1107       owner_type = type;</span>
<span class="line-modified">1108       param_name += l + 2;</span>
<span class="line-modified">1109       pspec = param_spec_ht_lookup (pool-&gt;hash_table, param_name, owner_type, walk_ancestors);</span>
<span class="line-modified">1110       g_mutex_unlock (&amp;pool-&gt;mutex);</span>
1111 
<span class="line-modified">1112       return pspec;</span>
<span class="line-modified">1113     }</span>
1114     }
1115   /* malformed param_name */
1116 
1117   g_mutex_unlock (&amp;pool-&gt;mutex);
1118 
1119   return NULL;
1120 }
1121 
1122 static void
1123 pool_list (gpointer key,
<span class="line-modified">1124        gpointer value,</span>
<span class="line-modified">1125        gpointer user_data)</span>
1126 {
1127   GParamSpec *pspec = value;
1128   gpointer *data = user_data;
1129   GType owner_type = (GType) data[1];
1130 
1131   if (owner_type == pspec-&gt;owner_type)
1132     data[0] = g_list_prepend (data[0], pspec);
1133 }
1134 
1135 /**
1136  * g_param_spec_pool_list_owned:
1137  * @pool: a #GParamSpecPool
1138  * @owner_type: the owner to look for
1139  *
1140  * Gets an #GList of all #GParamSpecs owned by @owner_type in
1141  * the pool.
1142  *
1143  * Returns: (transfer container) (element-type GObject.ParamSpec): a
1144  *          #GList of all #GParamSpecs owned by @owner_type in
1145  *          the pool#GParamSpecs.
1146  */
1147 GList*
1148 g_param_spec_pool_list_owned (GParamSpecPool *pool,
<span class="line-modified">1149                   GType           owner_type)</span>
1150 {
1151   gpointer data[2];
1152 
1153   g_return_val_if_fail (pool != NULL, NULL);
1154   g_return_val_if_fail (owner_type &gt; 0, NULL);
1155 
1156   g_mutex_lock (&amp;pool-&gt;mutex);
1157   data[0] = NULL;
1158   data[1] = (gpointer) owner_type;
1159   g_hash_table_foreach (pool-&gt;hash_table, pool_list, &amp;data);
1160   g_mutex_unlock (&amp;pool-&gt;mutex);
1161 
1162   return data[0];
1163 }
1164 
1165 static gint
1166 pspec_compare_id (gconstpointer a,
<span class="line-modified">1167           gconstpointer b)</span>
1168 {
1169   const GParamSpec *pspec1 = a, *pspec2 = b;
1170 
1171   if (pspec1-&gt;param_id &lt; pspec2-&gt;param_id)
1172     return -1;
1173 
1174   if (pspec1-&gt;param_id &gt; pspec2-&gt;param_id)
1175     return 1;
1176 
1177   return strcmp (pspec1-&gt;name, pspec2-&gt;name);
1178 }
1179 
1180 static inline GSList*
1181 pspec_list_remove_overridden_and_redirected (GSList     *plist,
<span class="line-modified">1182                          GHashTable *ht,</span>
<span class="line-modified">1183                          GType       owner_type,</span>
<span class="line-modified">1184                          guint      *n_p)</span>
1185 {
1186   GSList *rlist = NULL;
1187 
1188   while (plist)
1189     {
1190       GSList *tmp = plist-&gt;next;
1191       GParamSpec *pspec = plist-&gt;data;
1192       GParamSpec *found;
1193       gboolean remove = FALSE;
1194 
1195       /* Remove paramspecs that are redirected, and also paramspecs
1196        * that have are overridden by non-redirected properties.
1197        * The idea is to get the single paramspec for each name that
1198        * best corresponds to what the application sees.
1199        */
1200       if (g_param_spec_get_redirect_target (pspec))
<span class="line-modified">1201     remove = TRUE;</span>
1202       else
<span class="line-modified">1203     {</span>
<span class="line-modified">1204       found = param_spec_ht_lookup (ht, pspec-&gt;name, owner_type, TRUE);</span>
<span class="line-modified">1205       if (found != pspec)</span>
<span class="line-modified">1206         {</span>
<span class="line-modified">1207           GParamSpec *redirect = g_param_spec_get_redirect_target (found);</span>
<span class="line-modified">1208           if (redirect != pspec)</span>
<span class="line-modified">1209         remove = TRUE;</span>
<span class="line-modified">1210         }</span>
<span class="line-modified">1211     }</span>
1212 
1213       if (remove)
<span class="line-modified">1214     {</span>
<span class="line-modified">1215       g_slist_free_1 (plist);</span>
<span class="line-modified">1216     }</span>
1217       else
<span class="line-modified">1218     {</span>
<span class="line-modified">1219       plist-&gt;next = rlist;</span>
<span class="line-modified">1220       rlist = plist;</span>
<span class="line-modified">1221       *n_p += 1;</span>
<span class="line-modified">1222     }</span>
1223       plist = tmp;
1224     }
1225   return rlist;
1226 }
1227 
1228 static void
1229 pool_depth_list (gpointer key,
<span class="line-modified">1230          gpointer value,</span>
<span class="line-modified">1231          gpointer user_data)</span>
1232 {
1233   GParamSpec *pspec = value;
1234   gpointer *data = user_data;
1235   GSList **slists = data[0];
1236   GType owner_type = (GType) data[1];
1237 
1238   if (g_type_is_a (owner_type, pspec-&gt;owner_type))
1239     {
1240       if (G_TYPE_IS_INTERFACE (pspec-&gt;owner_type))
<span class="line-modified">1241     {</span>
<span class="line-modified">1242       slists[0] = g_slist_prepend (slists[0], pspec);</span>
<span class="line-modified">1243     }</span>
1244       else
<span class="line-modified">1245     {</span>
<span class="line-modified">1246       guint d = g_type_depth (pspec-&gt;owner_type);</span>
1247 
<span class="line-modified">1248       slists[d - 1] = g_slist_prepend (slists[d - 1], pspec);</span>
<span class="line-modified">1249     }</span>
1250     }
1251 }
1252 
1253 /* We handle interfaces specially since we don&#39;t want to
1254  * count interface prerequisites like normal inheritance;
1255  * the property comes from the direct inheritance from
1256  * the prerequisite class, not from the interface that
1257  * prerequires it.
1258  *
1259  * also &#39;depth&#39; isn&#39;t a meaningful concept for interface
1260  * prerequites.
1261  */
1262 static void
1263 pool_depth_list_for_interface (gpointer key,
<span class="line-modified">1264                    gpointer value,</span>
<span class="line-modified">1265                    gpointer user_data)</span>
1266 {
1267   GParamSpec *pspec = value;
1268   gpointer *data = user_data;
1269   GSList **slists = data[0];
1270   GType owner_type = (GType) data[1];
1271 
1272   if (pspec-&gt;owner_type == owner_type)
1273     slists[0] = g_slist_prepend (slists[0], pspec);
1274 }
1275 
1276 /**
1277  * g_param_spec_pool_list:
1278  * @pool: a #GParamSpecPool
1279  * @owner_type: the owner to look for
1280  * @n_pspecs_p: (out): return location for the length of the returned array
1281  *
1282  * Gets an array of all #GParamSpecs owned by @owner_type in
1283  * the pool.
1284  *
1285  * Returns: (array length=n_pspecs_p) (transfer container): a newly
1286  *          allocated array containing pointers to all #GParamSpecs
1287  *          owned by @owner_type in the pool
1288  */
1289 GParamSpec**
1290 g_param_spec_pool_list (GParamSpecPool *pool,
<span class="line-modified">1291             GType           owner_type,</span>
<span class="line-modified">1292             guint          *n_pspecs_p)</span>
1293 {
1294   GParamSpec **pspecs, **p;
1295   GSList **slists, *node;
1296   gpointer data[2];
1297   guint d, i;
1298 
1299   g_return_val_if_fail (pool != NULL, NULL);
1300   g_return_val_if_fail (owner_type &gt; 0, NULL);
1301   g_return_val_if_fail (n_pspecs_p != NULL, NULL);
1302 
1303   g_mutex_lock (&amp;pool-&gt;mutex);
1304   *n_pspecs_p = 0;
1305   d = g_type_depth (owner_type);
1306   slists = g_new0 (GSList*, d);
1307   data[0] = slists;
1308   data[1] = (gpointer) owner_type;
1309 
1310   g_hash_table_foreach (pool-&gt;hash_table,
<span class="line-modified">1311             G_TYPE_IS_INTERFACE (owner_type) ?</span>
<span class="line-modified">1312                pool_depth_list_for_interface :</span>
<span class="line-modified">1313                pool_depth_list,</span>
<span class="line-modified">1314             &amp;data);</span>
1315 
1316   for (i = 0; i &lt; d; i++)
1317     slists[i] = pspec_list_remove_overridden_and_redirected (slists[i], pool-&gt;hash_table, owner_type, n_pspecs_p);
1318   pspecs = g_new (GParamSpec*, *n_pspecs_p + 1);
1319   p = pspecs;
1320   for (i = 0; i &lt; d; i++)
1321     {
1322       slists[i] = g_slist_sort (slists[i], pspec_compare_id);
1323       for (node = slists[i]; node; node = node-&gt;next)
<span class="line-modified">1324     *p++ = node-&gt;data;</span>
1325       g_slist_free (slists[i]);
1326     }
1327   *p++ = NULL;
1328   g_free (slists);
1329   g_mutex_unlock (&amp;pool-&gt;mutex);
1330 
1331   return pspecs;
1332 }
1333 
1334 
1335 /* --- auxiliary functions --- */
1336 typedef struct
1337 {
1338   /* class portion */
1339   GType           value_type;
1340   void          (*finalize)             (GParamSpec   *pspec);
1341   void          (*value_set_default)    (GParamSpec   *pspec,
<span class="line-modified">1342                      GValue       *value);</span>
1343   gboolean      (*value_validate)       (GParamSpec   *pspec,
<span class="line-modified">1344                      GValue       *value);</span>
1345   gint          (*values_cmp)           (GParamSpec   *pspec,
<span class="line-modified">1346                      const GValue *value1,</span>
<span class="line-modified">1347                      const GValue *value2);</span>
1348 } ParamSpecClassInfo;
1349 
1350 static void
1351 param_spec_generic_class_init (gpointer g_class,
<span class="line-modified">1352                    gpointer class_data)</span>
1353 {
1354   GParamSpecClass *class = g_class;
1355   ParamSpecClassInfo *info = class_data;
1356 
1357   class-&gt;value_type = info-&gt;value_type;
1358   if (info-&gt;finalize)
<span class="line-modified">1359     class-&gt;finalize = info-&gt;finalize;           /* optional */</span>
1360   class-&gt;value_set_default = info-&gt;value_set_default;
1361   if (info-&gt;value_validate)
<span class="line-modified">1362     class-&gt;value_validate = info-&gt;value_validate;   /* optional */</span>
1363   class-&gt;values_cmp = info-&gt;values_cmp;
1364   g_free (class_data);
1365 }
1366 
1367 static void
1368 default_value_set_default (GParamSpec *pspec,
<span class="line-modified">1369                GValue     *value)</span>
1370 {
1371   /* value is already zero initialized */
1372 }
1373 
1374 static gint
1375 default_values_cmp (GParamSpec   *pspec,
<span class="line-modified">1376             const GValue *value1,</span>
<span class="line-modified">1377             const GValue *value2)</span>
1378 {
1379   return memcmp (&amp;value1-&gt;data, &amp;value2-&gt;data, sizeof (value1-&gt;data));
1380 }
1381 
1382 /**
1383  * g_param_type_register_static:
1384  * @name: 0-terminated string used as the name of the new #GParamSpec type.
1385  * @pspec_info: The #GParamSpecTypeInfo for this #GParamSpec type.
1386  *
1387  * Registers @name as the name of a new static type derived from
1388  * #G_TYPE_PARAM. The type system uses the information contained in
1389  * the #GParamSpecTypeInfo structure pointed to by @info to manage the
1390  * #GParamSpec type and its instances.
1391  *
1392  * Returns: The new type identifier.
1393  */
1394 GType
1395 g_param_type_register_static (const gchar              *name,
<span class="line-modified">1396                   const GParamSpecTypeInfo *pspec_info)</span>
1397 {
1398   GTypeInfo info = {
1399     sizeof (GParamSpecClass),      /* class_size */
1400     NULL,                          /* base_init */
1401     NULL,                          /* base_destroy */
1402     param_spec_generic_class_init, /* class_init */
1403     NULL,                          /* class_destroy */
1404     NULL,                          /* class_data */
1405     0,                             /* instance_size */
1406     16,                            /* n_preallocs */
1407     NULL,                          /* instance_init */
1408   };
1409   ParamSpecClassInfo *cinfo;
1410 
1411   g_return_val_if_fail (name != NULL, 0);
1412   g_return_val_if_fail (pspec_info != NULL, 0);
1413   g_return_val_if_fail (g_type_from_name (name) == 0, 0);
1414   g_return_val_if_fail (pspec_info-&gt;instance_size &gt;= sizeof (GParamSpec), 0);
1415   g_return_val_if_fail (g_type_name (pspec_info-&gt;value_type) != NULL, 0);
1416   /* default: g_return_val_if_fail (pspec_info-&gt;value_set_default != NULL, 0); */
</pre>
<hr />
<pre>
1423   cinfo = g_new (ParamSpecClassInfo, 1);
1424   cinfo-&gt;value_type = pspec_info-&gt;value_type;
1425   cinfo-&gt;finalize = pspec_info-&gt;finalize;
1426   cinfo-&gt;value_set_default = pspec_info-&gt;value_set_default ? pspec_info-&gt;value_set_default : default_value_set_default;
1427   cinfo-&gt;value_validate = pspec_info-&gt;value_validate;
1428   cinfo-&gt;values_cmp = pspec_info-&gt;values_cmp ? pspec_info-&gt;values_cmp : default_values_cmp;
1429   info.class_data = cinfo;
1430 
1431   return g_type_register_static (G_TYPE_PARAM, name, &amp;info, 0);
1432 }
1433 
1434 /**
1435  * g_value_set_param:
1436  * @value: a valid #GValue of type %G_TYPE_PARAM
1437  * @param: (nullable): the #GParamSpec to be set
1438  *
1439  * Set the contents of a %G_TYPE_PARAM #GValue to @param.
1440  */
1441 void
1442 g_value_set_param (GValue     *value,
<span class="line-modified">1443            GParamSpec *param)</span>
1444 {
1445   g_return_if_fail (G_VALUE_HOLDS_PARAM (value));
1446   if (param)
1447     g_return_if_fail (G_IS_PARAM_SPEC (param));
1448 
1449   if (value-&gt;data[0].v_pointer)
1450     g_param_spec_unref (value-&gt;data[0].v_pointer);
1451   value-&gt;data[0].v_pointer = param;
1452   if (value-&gt;data[0].v_pointer)
1453     g_param_spec_ref (value-&gt;data[0].v_pointer);
1454 }
1455 
1456 /**
1457  * g_value_set_param_take_ownership: (skip)
1458  * @value: a valid #GValue of type %G_TYPE_PARAM
1459  * @param: (nullable): the #GParamSpec to be set
1460  *
1461  * This is an internal function introduced mainly for C marshallers.
1462  *
1463  * Deprecated: 2.4: Use g_value_take_param() instead.
1464  */
1465 void
1466 g_value_set_param_take_ownership (GValue     *value,
<span class="line-modified">1467                   GParamSpec *param)</span>
1468 {
1469   g_value_take_param (value, param);
1470 }
1471 
1472 /**
1473  * g_value_take_param: (skip)
1474  * @value: a valid #GValue of type %G_TYPE_PARAM
1475  * @param: (nullable): the #GParamSpec to be set
1476  *
1477  * Sets the contents of a %G_TYPE_PARAM #GValue to @param and takes
<span class="line-modified">1478  * over the ownership of the callers reference to @param; the caller</span>
1479  * doesn&#39;t have to unref it any more.
1480  *
1481  * Since: 2.4
1482  */
1483 void
1484 g_value_take_param (GValue     *value,
<span class="line-modified">1485             GParamSpec *param)</span>
1486 {
1487   g_return_if_fail (G_VALUE_HOLDS_PARAM (value));
1488   if (param)
1489     g_return_if_fail (G_IS_PARAM_SPEC (param));
1490 
1491   if (value-&gt;data[0].v_pointer)
1492     g_param_spec_unref (value-&gt;data[0].v_pointer);
1493   value-&gt;data[0].v_pointer = param; /* we take over the reference count */
1494 }
1495 
1496 /**
1497  * g_value_get_param:
1498  * @value: a valid #GValue whose type is derived from %G_TYPE_PARAM
1499  *
1500  * Get the contents of a %G_TYPE_PARAM #GValue.
1501  *
1502  * Returns: (transfer none): #GParamSpec content of @value
1503  */
1504 GParamSpec*
1505 g_value_get_param (const GValue *value)
</pre>
<hr />
<pre>
1548    * it will be zero before it is initialised and non-zero after.  We
1549    * have to take care that we don&#39;t write a non-zero value to the type
1550    * field before we are completely done, however, because then another
1551    * thread could come along and find the value partially-initialised.
1552    *
1553    * In order to accomplish this we store the default value in a
1554    * stack-allocated GValue.  We then set the type field in that value
1555    * to zero and copy the contents into place.  We then end by storing
1556    * the type as the last step in order to ensure that we&#39;re completely
1557    * done before a g_once_init_enter() could take the fast path in
1558    * another thread.
1559    */
1560   if (g_once_init_enter (&amp;priv-&gt;default_value.g_type))
1561     {
1562       GValue default_value = G_VALUE_INIT;
1563 
1564       g_value_init (&amp;default_value, pspec-&gt;value_type);
1565       g_param_value_set_default (pspec, &amp;default_value);
1566 
1567       /* store all but the type */
<span class="line-modified">1568       default_value.g_type = 0;</span>
<span class="line-removed">1569       priv-&gt;default_value = default_value;</span>
1570 
1571       g_once_init_leave (&amp;priv-&gt;default_value.g_type, pspec-&gt;value_type);
1572     }
1573 
1574   return &amp;priv-&gt;default_value;
1575 }
1576 
1577 /**
1578  * g_param_spec_get_name_quark:
1579  * @pspec: a #GParamSpec
1580  *
1581  * Gets the GQuark for the name.
1582  *
1583  * Returns: the GQuark for @pspec-&gt;name.
1584  *
1585  * Since: 2.46
1586  */
1587 GQuark
1588 g_param_spec_get_name_quark (GParamSpec *pspec)
1589 {
</pre>
</td>
<td>
<hr />
<pre>
  34  * @see_also: g_object_class_install_property(), g_object_set(),
  35  *     g_object_get(), g_object_set_property(), g_object_get_property(),
  36  *     g_value_register_transform_func()
  37  * @title: GParamSpec
  38  *
  39  * #GParamSpec is an object structure that encapsulates the metadata
  40  * required to specify parameters, such as e.g. #GObject properties.
  41  *
  42  * ## Parameter names # {#canonical-parameter-names}
  43  *
  44  * Parameter names need to start with a letter (a-z or A-Z).
  45  * Subsequent characters can be letters, numbers or a &#39;-&#39;.
  46  * All other characters are replaced by a &#39;-&#39; during construction.
  47  * The result of this replacement is called the canonical name of
  48  * the parameter.
  49  */
  50 
  51 
  52 /* --- defines --- */
  53 #define PARAM_FLOATING_FLAG                     0x2
<span class="line-modified">  54 #define G_PARAM_USER_MASK     (~0U &lt;&lt; G_PARAM_USER_SHIFT)</span>
<span class="line-modified">  55 #define PSPEC_APPLIES_TO_VALUE(pspec, value)  (G_TYPE_CHECK_VALUE_TYPE ((value), G_PARAM_SPEC_VALUE_TYPE (pspec)))</span>
  56 
  57 /* --- prototypes --- */
<span class="line-modified">  58 static void g_param_spec_class_base_init   (GParamSpecClass *class);</span>
<span class="line-modified">  59 static void g_param_spec_class_base_finalize (GParamSpecClass *class);</span>
<span class="line-modified">  60 static void g_param_spec_class_init    (GParamSpecClass *class,</span>
<span class="line-modified">  61               gpointer               class_data);</span>
<span class="line-modified">  62 static void g_param_spec_init    (GParamSpec    *pspec,</span>
<span class="line-modified">  63               GParamSpecClass *class);</span>
<span class="line-modified">  64 static void g_param_spec_finalize    (GParamSpec    *pspec);</span>
<span class="line-modified">  65 static void value_param_init    (GValue   *value);</span>
<span class="line-modified">  66 static void value_param_free_value    (GValue   *value);</span>
<span class="line-modified">  67 static void value_param_copy_value    (const GValue *src_value,</span>
<span class="line-modified">  68              GValue   *dest_value);</span>
<span class="line-modified">  69 static void value_param_transform_value (const GValue *src_value,</span>
<span class="line-modified">  70              GValue   *dest_value);</span>
<span class="line-modified">  71 static gpointer value_param_peek_pointer  (const GValue *value);</span>
<span class="line-modified">  72 static gchar* value_param_collect_value (GValue   *value,</span>
<span class="line-modified">  73              guint           n_collect_values,</span>
<span class="line-modified">  74              GTypeCValue    *collect_values,</span>
<span class="line-modified">  75              guint           collect_flags);</span>
<span class="line-modified">  76 static gchar* value_param_lcopy_value   (const GValue *value,</span>
<span class="line-modified">  77              guint           n_collect_values,</span>
<span class="line-modified">  78              GTypeCValue    *collect_values,</span>
<span class="line-modified">  79              guint           collect_flags);</span>
  80 
  81 typedef struct
  82 {
  83   GValue default_value;
  84   GQuark name_quark;
  85 } GParamSpecPrivate;
  86 
  87 static gint g_param_private_offset;
  88 
  89 /* --- functions --- */
  90 static inline GParamSpecPrivate *
  91 g_param_spec_get_private (GParamSpec *pspec)
  92 {
  93   return &amp;G_STRUCT_MEMBER (GParamSpecPrivate, pspec, g_param_private_offset);
  94 }
  95 
  96 void
  97 _g_param_type_init (void)
  98 {
  99   static const GTypeFundamentalInfo finfo = {
 100     (G_TYPE_FLAG_CLASSED |
 101      G_TYPE_FLAG_INSTANTIATABLE |
 102      G_TYPE_FLAG_DERIVABLE |
 103      G_TYPE_FLAG_DEEP_DERIVABLE),
 104   };
 105   static const GTypeValueTable param_value_table = {
 106     value_param_init,           /* value_init */
 107     value_param_free_value,     /* value_free */
 108     value_param_copy_value,     /* value_copy */
 109     value_param_peek_pointer,   /* value_peek_pointer */
<span class="line-modified"> 110     &quot;p&quot;,      /* collect_format */</span>
 111     value_param_collect_value,  /* collect_value */
<span class="line-modified"> 112     &quot;p&quot;,      /* lcopy_format */</span>
 113     value_param_lcopy_value,    /* lcopy_value */
 114   };
 115   const GTypeInfo param_spec_info = {
 116     sizeof (GParamSpecClass),
 117 
 118     (GBaseInitFunc) g_param_spec_class_base_init,
 119     (GBaseFinalizeFunc) g_param_spec_class_base_finalize,
 120     (GClassInitFunc) g_param_spec_class_init,
 121     (GClassFinalizeFunc) NULL,
<span class="line-modified"> 122     NULL, /* class_data */</span>
 123 
 124     sizeof (GParamSpec),
<span class="line-modified"> 125     0,    /* n_preallocs */</span>
 126     (GInstanceInitFunc) g_param_spec_init,
 127 
 128     &amp;param_value_table,
 129   };
 130   GType type;
 131 
 132   /* This should be registered as GParamSpec instead of GParam, for
 133    * consistency sake, so that type name can be mapped to struct name,
 134    * However, some language bindings, most noticeable the python ones
 135    * depends on the &quot;GParam&quot; identifier, see #548689
 136    */
 137   type = g_type_register_fundamental (G_TYPE_PARAM, g_intern_static_string (&quot;GParam&quot;), &amp;param_spec_info, &amp;finfo, G_TYPE_FLAG_ABSTRACT);
 138   g_assert (type == G_TYPE_PARAM);
 139   g_param_private_offset = g_type_add_instance_private (type, sizeof (GParamSpecPrivate));
 140   g_value_register_transform_func (G_TYPE_PARAM, G_TYPE_PARAM, value_param_transform_value);
 141 }
 142 
 143 static void
 144 g_param_spec_class_base_init (GParamSpecClass *class)
 145 {
 146 }
 147 
 148 static void
 149 g_param_spec_class_base_finalize (GParamSpecClass *class)
 150 {
 151 }
 152 
 153 static void
 154 g_param_spec_class_init (GParamSpecClass *class,
<span class="line-modified"> 155        gpointer         class_data)</span>
 156 {
 157   class-&gt;value_type = G_TYPE_NONE;
 158   class-&gt;finalize = g_param_spec_finalize;
 159   class-&gt;value_set_default = NULL;
 160   class-&gt;value_validate = NULL;
 161   class-&gt;values_cmp = NULL;
 162 
 163   g_type_class_adjust_private_offset (class, &amp;g_param_private_offset);
 164 }
 165 
 166 static void
 167 g_param_spec_init (GParamSpec      *pspec,
<span class="line-modified"> 168        GParamSpecClass *class)</span>
 169 {
 170   pspec-&gt;name = NULL;
 171   pspec-&gt;_nick = NULL;
 172   pspec-&gt;_blurb = NULL;
 173   pspec-&gt;flags = 0;
 174   pspec-&gt;value_type = class-&gt;value_type;
 175   pspec-&gt;owner_type = 0;
 176   pspec-&gt;qdata = NULL;
 177   g_datalist_set_flags (&amp;pspec-&gt;qdata, PARAM_FLOATING_FLAG);
 178   pspec-&gt;ref_count = 1;
 179   pspec-&gt;param_id = 0;
 180 }
 181 
 182 static void
 183 g_param_spec_finalize (GParamSpec *pspec)
 184 {
 185   GParamSpecPrivate *priv = g_param_spec_get_private (pspec);
 186 
 187   if (priv-&gt;default_value.g_type)
 188     g_value_reset (&amp;priv-&gt;default_value);
</pre>
<hr />
<pre>
 305  * g_param_spec_get_nick:
 306  * @pspec: a valid #GParamSpec
 307  *
 308  * Get the nickname of a #GParamSpec.
 309  *
 310  * Returns: the nickname of @pspec.
 311  */
 312 const gchar *
 313 g_param_spec_get_nick (GParamSpec *pspec)
 314 {
 315   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), NULL);
 316 
 317   if (pspec-&gt;_nick)
 318     return pspec-&gt;_nick;
 319   else
 320     {
 321       GParamSpec *redirect_target;
 322 
 323       redirect_target = g_param_spec_get_redirect_target (pspec);
 324       if (redirect_target &amp;&amp; redirect_target-&gt;_nick)
<span class="line-modified"> 325   return redirect_target-&gt;_nick;</span>
 326     }
 327 
 328   return pspec-&gt;name;
 329 }
 330 
 331 /**
 332  * g_param_spec_get_blurb:
 333  * @pspec: a valid #GParamSpec
 334  *
 335  * Get the short description of a #GParamSpec.
 336  *
 337  * Returns: the short description of @pspec.
 338  */
 339 const gchar *
 340 g_param_spec_get_blurb (GParamSpec *pspec)
 341 {
 342   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), NULL);
 343 
 344   if (pspec-&gt;_blurb)
 345     return pspec-&gt;_blurb;
 346   else
 347     {
 348       GParamSpec *redirect_target;
 349 
 350       redirect_target = g_param_spec_get_redirect_target (pspec);
 351       if (redirect_target &amp;&amp; redirect_target-&gt;_blurb)
<span class="line-modified"> 352   return redirect_target-&gt;_blurb;</span>
 353     }
 354 
 355   return NULL;
 356 }
 357 
 358 static void
 359 canonicalize_key (gchar *key)
 360 {
 361   gchar *p;
 362 
 363   for (p = key; *p != 0; p++)
 364     {
 365       gchar c = *p;
 366 
 367       if (c != &#39;-&#39; &amp;&amp;
<span class="line-modified"> 368     (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) &amp;&amp;</span>
<span class="line-modified"> 369     (c &lt; &#39;A&#39; || c &gt; &#39;Z&#39;) &amp;&amp;</span>
<span class="line-modified"> 370     (c &lt; &#39;a&#39; || c &gt; &#39;z&#39;))</span>
<span class="line-modified"> 371   *p = &#39;-&#39;;</span>
 372     }
 373 }
 374 
 375 static gboolean
 376 is_canonical (const gchar *key)
 377 {
 378   const gchar *p;
 379 
 380   for (p = key; *p != 0; p++)
 381     {
 382       gchar c = *p;
 383 
 384       if (c != &#39;-&#39; &amp;&amp;
<span class="line-modified"> 385     (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) &amp;&amp;</span>
<span class="line-modified"> 386     (c &lt; &#39;A&#39; || c &gt; &#39;Z&#39;) &amp;&amp;</span>
<span class="line-modified"> 387     (c &lt; &#39;a&#39; || c &gt; &#39;z&#39;))</span>
<span class="line-modified"> 388   return FALSE;</span>
 389     }
 390 
 391   return TRUE;
 392 }
 393 
 394 /**
 395  * g_param_spec_internal: (skip)
 396  * @param_type: the #GType for the property; must be derived from #G_TYPE_PARAM
 397  * @name: the canonical name of the property
 398  * @nick: the nickname of the property
 399  * @blurb: a short description of the property
 400  * @flags: a combination of #GParamFlags
 401  *
 402  * Creates a new #GParamSpec instance.
 403  *
 404  * A property name consists of segments consisting of ASCII letters and
 405  * digits, separated by either the &#39;-&#39; or &#39;_&#39; character. The first
 406  * character of a property name must be a letter. Names which violate these
 407  * rules lead to undefined behaviour.
 408  *
 409  * When creating and looking up a #GParamSpec, either separator can be
 410  * used, but they cannot be mixed. Using &#39;-&#39; is considerably more
 411  * efficient and in fact required when using property names as detail
 412  * strings for signals.
 413  *
 414  * Beyond the name, #GParamSpecs have two more descriptive
 415  * strings associated with them, the @nick, which should be suitable
 416  * for use as a label for the property in a property editor, and the
 417  * @blurb, which should be a somewhat longer description, suitable for
 418  * e.g. a tooltip. The @nick and @blurb should ideally be localized.
 419  *
 420  * Returns: (type GObject.ParamSpec): a newly allocated #GParamSpec instance
 421  */
 422 gpointer
 423 g_param_spec_internal (GType        param_type,
<span class="line-modified"> 424            const gchar *name,</span>
<span class="line-modified"> 425            const gchar *nick,</span>
<span class="line-modified"> 426            const gchar *blurb,</span>
<span class="line-modified"> 427            GParamFlags  flags)</span>
 428 {
 429   GParamSpec *pspec;
 430   GParamSpecPrivate *priv;
 431 
 432   g_return_val_if_fail (G_TYPE_IS_PARAM (param_type) &amp;&amp; param_type != G_TYPE_PARAM, NULL);
 433   g_return_val_if_fail (name != NULL, NULL);
 434   g_return_val_if_fail ((name[0] &gt;= &#39;A&#39; &amp;&amp; name[0] &lt;= &#39;Z&#39;) || (name[0] &gt;= &#39;a&#39; &amp;&amp; name[0] &lt;= &#39;z&#39;), NULL);
 435   g_return_val_if_fail (!(flags &amp; G_PARAM_STATIC_NAME) || is_canonical (name), NULL);
 436 
 437   pspec = (gpointer) g_type_create_instance (param_type);
 438 #ifdef GSTREAMER_LITE
 439   if (pspec == NULL)
 440       return NULL;
 441 #endif // GSTREAMER_LITE
 442 
 443   if (flags &amp; G_PARAM_STATIC_NAME)
 444     {
 445       /* pspec-&gt;name is not freed if (flags &amp; G_PARAM_STATIC_NAME) */
 446       pspec-&gt;name = (gchar *) g_intern_static_string (name);
 447       if (!is_canonical (pspec-&gt;name))
</pre>
<hr />
<pre>
 472     pspec-&gt;_blurb = (gchar*) blurb;
 473   else
 474     pspec-&gt;_blurb = g_strdup (blurb);
 475 
 476   pspec-&gt;flags = (flags &amp; G_PARAM_USER_MASK) | (flags &amp; G_PARAM_MASK);
 477 
 478   return pspec;
 479 }
 480 
 481 /**
 482  * g_param_spec_get_qdata:
 483  * @pspec: a valid #GParamSpec
 484  * @quark: a #GQuark, naming the user data pointer
 485  *
 486  * Gets back user data pointers stored via g_param_spec_set_qdata().
 487  *
 488  * Returns: (transfer none): the user data pointer set, or %NULL
 489  */
 490 gpointer
 491 g_param_spec_get_qdata (GParamSpec *pspec,
<span class="line-modified"> 492       GQuark      quark)</span>
 493 {
 494   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), NULL);
 495 
 496   return quark ? g_datalist_id_get_data (&amp;pspec-&gt;qdata, quark) : NULL;
 497 }
 498 
 499 /**
 500  * g_param_spec_set_qdata:
 501  * @pspec: the #GParamSpec to set store a user data pointer
 502  * @quark: a #GQuark, naming the user data pointer
 503  * @data: an opaque user data pointer
 504  *
 505  * Sets an opaque, named pointer on a #GParamSpec. The name is
 506  * specified through a #GQuark (retrieved e.g. via
 507  * g_quark_from_static_string()), and the pointer can be gotten back
 508  * from the @pspec with g_param_spec_get_qdata().  Setting a
 509  * previously set user data pointer, overrides (frees) the old pointer
 510  * set, using %NULL as pointer essentially removes the data stored.
 511  */
 512 void
 513 g_param_spec_set_qdata (GParamSpec *pspec,
<span class="line-modified"> 514       GQuark      quark,</span>
<span class="line-modified"> 515       gpointer    data)</span>
 516 {
 517   g_return_if_fail (G_IS_PARAM_SPEC (pspec));
 518   g_return_if_fail (quark &gt; 0);
 519 
 520   g_datalist_id_set_data (&amp;pspec-&gt;qdata, quark, data);
 521 }
 522 
 523 /**
 524  * g_param_spec_set_qdata_full: (skip)
 525  * @pspec: the #GParamSpec to set store a user data pointer
 526  * @quark: a #GQuark, naming the user data pointer
 527  * @data: an opaque user data pointer
 528  * @destroy: function to invoke with @data as argument, when @data needs to
 529  *  be freed
 530  *
 531  * This function works like g_param_spec_set_qdata(), but in addition,
 532  * a `void (*destroy) (gpointer)` function may be
 533  * specified which is called with @data as argument when the @pspec is
 534  * finalized, or the data is being overwritten by a call to
 535  * g_param_spec_set_qdata() with the same @quark.
 536  */
 537 void
 538 g_param_spec_set_qdata_full (GParamSpec    *pspec,
<span class="line-modified"> 539            GQuark         quark,</span>
<span class="line-modified"> 540            gpointer       data,</span>
<span class="line-modified"> 541            GDestroyNotify destroy)</span>
 542 {
 543   g_return_if_fail (G_IS_PARAM_SPEC (pspec));
 544   g_return_if_fail (quark &gt; 0);
 545 
 546   g_datalist_id_set_data_full (&amp;pspec-&gt;qdata, quark, data, data ? destroy : (GDestroyNotify) NULL);
 547 }
 548 
 549 /**
 550  * g_param_spec_steal_qdata:
 551  * @pspec: the #GParamSpec to get a stored user data pointer from
 552  * @quark: a #GQuark, naming the user data pointer
 553  *
 554  * Gets back user data pointers stored via g_param_spec_set_qdata()
 555  * and removes the @data from @pspec without invoking its destroy()
 556  * function (if any was set).  Usually, calling this function is only
 557  * required to update user data pointers with a destroy notifier.
 558  *
 559  * Returns: (transfer none): the user data pointer set, or %NULL
 560  */
 561 gpointer
 562 g_param_spec_steal_qdata (GParamSpec *pspec,
<span class="line-modified"> 563         GQuark      quark)</span>
 564 {
 565   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), NULL);
 566   g_return_val_if_fail (quark &gt; 0, NULL);
 567 
 568   return g_datalist_id_remove_no_notify (&amp;pspec-&gt;qdata, quark);
 569 }
 570 
 571 /**
 572  * g_param_spec_get_redirect_target:
 573  * @pspec: a #GParamSpec
 574  *
 575  * If the paramspec redirects operations to another paramspec,
 576  * returns that paramspec. Redirect is used typically for
 577  * providing a new implementation of a property in a derived
 578  * type while preserving all the properties from the parent
 579  * type. Redirection is established by creating a property
 580  * of type #GParamSpecOverride. See g_object_class_override_property()
 581  * for an example of the use of this capability.
 582  *
 583  * Since: 2.4
</pre>
<hr />
<pre>
 588 GParamSpec*
 589 g_param_spec_get_redirect_target (GParamSpec *pspec)
 590 {
 591   GTypeInstance *inst = (GTypeInstance *)pspec;
 592 
 593   if (inst &amp;&amp; inst-&gt;g_class &amp;&amp; inst-&gt;g_class-&gt;g_type == G_TYPE_PARAM_OVERRIDE)
 594     return ((GParamSpecOverride*)pspec)-&gt;overridden;
 595   else
 596     return NULL;
 597 }
 598 
 599 /**
 600  * g_param_value_set_default:
 601  * @pspec: a valid #GParamSpec
 602  * @value: a #GValue of correct type for @pspec
 603  *
 604  * Sets @value to its default value as specified in @pspec.
 605  */
 606 void
 607 g_param_value_set_default (GParamSpec *pspec,
<span class="line-modified"> 608          GValue     *value)</span>
 609 {
 610   g_return_if_fail (G_IS_PARAM_SPEC (pspec));
 611   g_return_if_fail (G_IS_VALUE (value));
 612   g_return_if_fail (PSPEC_APPLIES_TO_VALUE (pspec, value));
 613 
 614   g_value_reset (value);
 615   G_PARAM_SPEC_GET_CLASS (pspec)-&gt;value_set_default (pspec, value);
 616 }
 617 
 618 /**
 619  * g_param_value_defaults:
 620  * @pspec: a valid #GParamSpec
 621  * @value: a #GValue of correct type for @pspec
 622  *
 623  * Checks whether @value contains the default value as specified in @pspec.
 624  *
 625  * Returns: whether @value contains the canonical default for this @pspec
 626  */
 627 gboolean
 628 g_param_value_defaults (GParamSpec *pspec,
<span class="line-modified"> 629       GValue     *value)</span>
 630 {
 631   GValue dflt_value = G_VALUE_INIT;
 632   gboolean defaults;
 633 
 634   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), FALSE);
 635   g_return_val_if_fail (G_IS_VALUE (value), FALSE);
 636   g_return_val_if_fail (PSPEC_APPLIES_TO_VALUE (pspec, value), FALSE);
 637 
 638   g_value_init (&amp;dflt_value, G_PARAM_SPEC_VALUE_TYPE (pspec));
 639   G_PARAM_SPEC_GET_CLASS (pspec)-&gt;value_set_default (pspec, &amp;dflt_value);
 640   defaults = G_PARAM_SPEC_GET_CLASS (pspec)-&gt;values_cmp (pspec, value, &amp;dflt_value) == 0;
 641   g_value_unset (&amp;dflt_value);
 642 
 643   return defaults;
 644 }
 645 
 646 /**
 647  * g_param_value_validate:
 648  * @pspec: a valid #GParamSpec
 649  * @value: a #GValue of correct type for @pspec
 650  *
 651  * Ensures that the contents of @value comply with the specifications
 652  * set out by @pspec. For example, a #GParamSpecInt might require
 653  * that integers stored in @value may not be smaller than -42 and not be
 654  * greater than +42. If @value contains an integer outside of this range,
 655  * it is modified accordingly, so the resulting value will fit into the
 656  * range -42 .. +42.
 657  *
 658  * Returns: whether modifying @value was necessary to ensure validity
 659  */
 660 gboolean
 661 g_param_value_validate (GParamSpec *pspec,
<span class="line-modified"> 662       GValue     *value)</span>
 663 {
 664   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), FALSE);
 665   g_return_val_if_fail (G_IS_VALUE (value), FALSE);
 666   g_return_val_if_fail (PSPEC_APPLIES_TO_VALUE (pspec, value), FALSE);
 667 
 668   if (G_PARAM_SPEC_GET_CLASS (pspec)-&gt;value_validate)
 669     {
 670       GValue oval = *value;
 671 
 672       if (G_PARAM_SPEC_GET_CLASS (pspec)-&gt;value_validate (pspec, value) ||
<span class="line-modified"> 673     memcmp (&amp;oval.data, &amp;value-&gt;data, sizeof (oval.data)))</span>
<span class="line-modified"> 674   return TRUE;</span>
 675     }
 676 
 677   return FALSE;
 678 }
 679 
 680 /**
 681  * g_param_value_convert:
 682  * @pspec: a valid #GParamSpec
 683  * @src_value: souce #GValue
 684  * @dest_value: destination #GValue of correct type for @pspec
 685  * @strict_validation: %TRUE requires @dest_value to conform to @pspec
 686  * without modifications
 687  *
 688  * Transforms @src_value into @dest_value if possible, and then
 689  * validates @dest_value, in order for it to conform to @pspec.  If
 690  * @strict_validation is %TRUE this function will only succeed if the
 691  * transformed @dest_value complied to @pspec without modifications.
 692  *
 693  * See also g_value_type_transformable(), g_value_transform() and
 694  * g_param_value_validate().
 695  *
 696  * Returns: %TRUE if transformation and validation were successful,
 697  *  %FALSE otherwise and @dest_value is left untouched.
 698  */
 699 gboolean
 700 g_param_value_convert (GParamSpec   *pspec,
<span class="line-modified"> 701            const GValue *src_value,</span>
<span class="line-modified"> 702            GValue       *dest_value,</span>
<span class="line-modified"> 703            gboolean      strict_validation)</span>
 704 {
 705   GValue tmp_value = G_VALUE_INIT;
 706 
 707   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), FALSE);
 708   g_return_val_if_fail (G_IS_VALUE (src_value), FALSE);
 709   g_return_val_if_fail (G_IS_VALUE (dest_value), FALSE);
 710   g_return_val_if_fail (PSPEC_APPLIES_TO_VALUE (pspec, dest_value), FALSE);
 711 
 712   /* better leave dest_value untouched when returning FALSE */
 713 
 714   g_value_init (&amp;tmp_value, G_VALUE_TYPE (dest_value));
 715   if (g_value_transform (src_value, &amp;tmp_value) &amp;&amp;
 716       (!g_param_value_validate (pspec, &amp;tmp_value) || !strict_validation))
 717     {
 718       g_value_unset (dest_value);
 719 
 720       /* values are relocatable */
 721       memcpy (dest_value, &amp;tmp_value, sizeof (tmp_value));
 722 
 723       return TRUE;
</pre>
<hr />
<pre>
 727       g_value_unset (&amp;tmp_value);
 728 
 729       return FALSE;
 730     }
 731 }
 732 
 733 /**
 734  * g_param_values_cmp:
 735  * @pspec: a valid #GParamSpec
 736  * @value1: a #GValue of correct type for @pspec
 737  * @value2: a #GValue of correct type for @pspec
 738  *
 739  * Compares @value1 with @value2 according to @pspec, and return -1, 0 or +1,
 740  * if @value1 is found to be less than, equal to or greater than @value2,
 741  * respectively.
 742  *
 743  * Returns: -1, 0 or +1, for a less than, equal to or greater than result
 744  */
 745 gint
 746 g_param_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 747         const GValue *value1,</span>
<span class="line-modified"> 748         const GValue *value2)</span>
 749 {
 750   gint cmp;
 751 
 752   /* param_values_cmp() effectively does: value1 - value2
 753    * so the return values are:
 754    * -1)  value1 &lt; value2
 755    *  0)  value1 == value2
 756    *  1)  value1 &gt; value2
 757    */
 758   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), 0);
 759   g_return_val_if_fail (G_IS_VALUE (value1), 0);
 760   g_return_val_if_fail (G_IS_VALUE (value2), 0);
 761   g_return_val_if_fail (PSPEC_APPLIES_TO_VALUE (pspec, value1), 0);
 762   g_return_val_if_fail (PSPEC_APPLIES_TO_VALUE (pspec, value2), 0);
 763 
 764   cmp = G_PARAM_SPEC_GET_CLASS (pspec)-&gt;values_cmp (pspec, value1, value2);
 765 
 766   return CLAMP (cmp, -1, 1);
 767 }
 768 
 769 static void
 770 value_param_init (GValue *value)
 771 {
 772   value-&gt;data[0].v_pointer = NULL;
 773 }
 774 
 775 static void
 776 value_param_free_value (GValue *value)
 777 {
 778   if (value-&gt;data[0].v_pointer)
 779     g_param_spec_unref (value-&gt;data[0].v_pointer);
 780 }
 781 
 782 static void
 783 value_param_copy_value (const GValue *src_value,
<span class="line-modified"> 784       GValue       *dest_value)</span>
 785 {
 786   if (src_value-&gt;data[0].v_pointer)
 787     dest_value-&gt;data[0].v_pointer = g_param_spec_ref (src_value-&gt;data[0].v_pointer);
 788   else
 789     dest_value-&gt;data[0].v_pointer = NULL;
 790 }
 791 
 792 static void
 793 value_param_transform_value (const GValue *src_value,
<span class="line-modified"> 794            GValue       *dest_value)</span>
 795 {
 796   if (src_value-&gt;data[0].v_pointer &amp;&amp;
 797       g_type_is_a (G_PARAM_SPEC_TYPE (dest_value-&gt;data[0].v_pointer), G_VALUE_TYPE (dest_value)))
 798     dest_value-&gt;data[0].v_pointer = g_param_spec_ref (src_value-&gt;data[0].v_pointer);
 799   else
 800     dest_value-&gt;data[0].v_pointer = NULL;
 801 }
 802 
 803 static gpointer
 804 value_param_peek_pointer (const GValue *value)
 805 {
 806   return value-&gt;data[0].v_pointer;
 807 }
 808 
 809 static gchar*
 810 value_param_collect_value (GValue      *value,
<span class="line-modified"> 811          guint        n_collect_values,</span>
<span class="line-modified"> 812          GTypeCValue *collect_values,</span>
<span class="line-modified"> 813          guint        collect_flags)</span>
 814 {
 815   if (collect_values[0].v_pointer)
 816     {
 817       GParamSpec *param = collect_values[0].v_pointer;
 818 
 819       if (param-&gt;g_type_instance.g_class == NULL)
<span class="line-modified"> 820   return g_strconcat (&quot;invalid unclassed param spec pointer for value type &#39;&quot;,</span>
<span class="line-modified"> 821           G_VALUE_TYPE_NAME (value),</span>
<span class="line-modified"> 822           &quot;&#39;&quot;,</span>
<span class="line-modified"> 823           NULL);</span>
 824       else if (!g_value_type_compatible (G_PARAM_SPEC_TYPE (param), G_VALUE_TYPE (value)))
<span class="line-modified"> 825   return g_strconcat (&quot;invalid param spec type &#39;&quot;,</span>
<span class="line-modified"> 826           G_PARAM_SPEC_TYPE_NAME (param),</span>
<span class="line-modified"> 827           &quot;&#39; for value type &#39;&quot;,</span>
<span class="line-modified"> 828           G_VALUE_TYPE_NAME (value),</span>
<span class="line-modified"> 829           &quot;&#39;&quot;,</span>
<span class="line-modified"> 830           NULL);</span>
 831       value-&gt;data[0].v_pointer = g_param_spec_ref (param);
 832     }
 833   else
 834     value-&gt;data[0].v_pointer = NULL;
 835 
 836   return NULL;
 837 }
 838 
 839 static gchar*
 840 value_param_lcopy_value (const GValue *value,
<span class="line-modified"> 841        guint         n_collect_values,</span>
<span class="line-modified"> 842        GTypeCValue  *collect_values,</span>
<span class="line-modified"> 843        guint         collect_flags)</span>
 844 {
 845   GParamSpec **param_p = collect_values[0].v_pointer;
 846 
 847   if (!param_p)
 848     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 849 
 850   if (!value-&gt;data[0].v_pointer)
 851     *param_p = NULL;
 852   else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
 853     *param_p = value-&gt;data[0].v_pointer;
 854   else
 855     *param_p = g_param_spec_ref (value-&gt;data[0].v_pointer);
 856 
 857   return NULL;
 858 }
 859 
 860 
 861 /* --- param spec pool --- */
 862 /**
 863  * GParamSpecPool:
</pre>
<hr />
<pre>
 872   GMutex       mutex;
 873   gboolean     type_prefixing;
 874   GHashTable  *hash_table;
 875 };
 876 
 877 static guint
 878 param_spec_pool_hash (gconstpointer key_spec)
 879 {
 880   const GParamSpec *key = key_spec;
 881   const gchar *p;
 882   guint h = key-&gt;owner_type;
 883 
 884   for (p = key-&gt;name; *p; p++)
 885     h = (h &lt;&lt; 5) - h + *p;
 886 
 887   return h;
 888 }
 889 
 890 static gboolean
 891 param_spec_pool_equals (gconstpointer key_spec_1,
<span class="line-modified"> 892       gconstpointer key_spec_2)</span>
 893 {
 894   const GParamSpec *key1 = key_spec_1;
 895   const GParamSpec *key2 = key_spec_2;
 896 
 897   return (key1-&gt;owner_type == key2-&gt;owner_type &amp;&amp;
<span class="line-modified"> 898     strcmp (key1-&gt;name, key2-&gt;name) == 0);</span>
 899 }
 900 
 901 /**
 902  * g_param_spec_pool_new:
 903  * @type_prefixing: Whether the pool will support type-prefixed property names.
 904  *
 905  * Creates a new #GParamSpecPool.
 906  *
 907  * If @type_prefixing is %TRUE, lookups in the newly created pool will
 908  * allow to specify the owner as a colon-separated prefix of the
 909  * property name, like &quot;GtkContainer:border-width&quot;. This feature is
 910  * deprecated, so you should always set @type_prefixing to %FALSE.
 911  *
 912  * Returns: (transfer none): a newly allocated #GParamSpecPool.
 913  */
 914 GParamSpecPool*
 915 g_param_spec_pool_new (gboolean type_prefixing)
 916 {
 917   static GMutex init_mutex;
 918   GParamSpecPool *pool = g_new (GParamSpecPool, 1);
 919 
 920   memcpy (&amp;pool-&gt;mutex, &amp;init_mutex, sizeof (init_mutex));
 921   pool-&gt;type_prefixing = type_prefixing != FALSE;
 922   pool-&gt;hash_table = g_hash_table_new (param_spec_pool_hash, param_spec_pool_equals);
 923 
 924   return pool;
 925 }
 926 
 927 /**
 928  * g_param_spec_pool_insert:
 929  * @pool: a #GParamSpecPool.
 930  * @pspec: the #GParamSpec to insert
 931  * @owner_type: a #GType identifying the owner of @pspec
 932  *
 933  * Inserts a #GParamSpec in the pool.
 934  */
 935 void
 936 g_param_spec_pool_insert (GParamSpecPool *pool,
<span class="line-modified"> 937         GParamSpec     *pspec,</span>
<span class="line-modified"> 938         GType           owner_type)</span>
 939 {
 940   const gchar *p;
 941 
 942   if (pool &amp;&amp; pspec &amp;&amp; owner_type &gt; 0 &amp;&amp; pspec-&gt;owner_type == 0)
 943     {
 944       for (p = pspec-&gt;name; *p; p++)
<span class="line-modified"> 945   {</span>
<span class="line-modified"> 946     if (!strchr (G_CSET_A_2_Z G_CSET_a_2_z G_CSET_DIGITS &quot;-_&quot;, *p))</span>
<span class="line-modified"> 947       {</span>
<span class="line-modified"> 948         g_warning (G_STRLOC &quot;: pspec name \&quot;%s\&quot; contains invalid characters&quot;, pspec-&gt;name);</span>
<span class="line-modified"> 949         return;</span>
<span class="line-modified"> 950       }</span>
<span class="line-modified"> 951   }</span>
 952       g_mutex_lock (&amp;pool-&gt;mutex);
 953       pspec-&gt;owner_type = owner_type;
 954       g_param_spec_ref (pspec);
 955       g_hash_table_add (pool-&gt;hash_table, pspec);
 956       g_mutex_unlock (&amp;pool-&gt;mutex);
 957     }
 958   else
 959     {
 960       g_return_if_fail (pool != NULL);
 961       g_return_if_fail (pspec);
 962       g_return_if_fail (owner_type &gt; 0);
 963       g_return_if_fail (pspec-&gt;owner_type == 0);
 964     }
 965 }
 966 
 967 /**
 968  * g_param_spec_pool_remove:
 969  * @pool: a #GParamSpecPool
 970  * @pspec: the #GParamSpec to remove
 971  *
 972  * Removes a #GParamSpec from the pool.
 973  */
 974 void
 975 g_param_spec_pool_remove (GParamSpecPool *pool,
<span class="line-modified"> 976         GParamSpec     *pspec)</span>
 977 {
 978   if (pool &amp;&amp; pspec)
 979     {
 980       g_mutex_lock (&amp;pool-&gt;mutex);
 981       if (g_hash_table_remove (pool-&gt;hash_table, pspec))
<span class="line-modified"> 982   g_param_spec_unref (pspec);</span>
 983       else
<span class="line-modified"> 984   g_warning (G_STRLOC &quot;: attempt to remove unknown pspec &#39;%s&#39; from pool&quot;, pspec-&gt;name);</span>
 985       g_mutex_unlock (&amp;pool-&gt;mutex);
 986     }
 987   else
 988     {
 989       g_return_if_fail (pool != NULL);
 990       g_return_if_fail (pspec);
 991     }
 992 }
 993 
 994 static inline GParamSpec*
 995 param_spec_ht_lookup (GHashTable  *hash_table,
<span class="line-modified"> 996           const gchar *param_name,</span>
<span class="line-modified"> 997           GType        owner_type,</span>
<span class="line-modified"> 998           gboolean     walk_ancestors)</span>
 999 {
1000   GParamSpec key, *pspec;
1001 
1002   key.owner_type = owner_type;
1003   key.name = (gchar*) param_name;
1004   if (walk_ancestors)
1005     do
1006       {
<span class="line-modified">1007   pspec = g_hash_table_lookup (hash_table, &amp;key);</span>
<span class="line-modified">1008   if (pspec)</span>
<span class="line-modified">1009     return pspec;</span>
<span class="line-modified">1010   key.owner_type = g_type_parent (key.owner_type);</span>
1011       }
1012     while (key.owner_type);
1013   else
1014     pspec = g_hash_table_lookup (hash_table, &amp;key);
1015 
1016   if (!pspec &amp;&amp; !is_canonical (param_name))
1017     {
1018       gchar *canonical;
1019 
1020       canonical = g_strdup (key.name);
1021       canonicalize_key (canonical);
1022 
1023       /* try canonicalized form */
1024       key.name = canonical;
1025       key.owner_type = owner_type;
1026 
1027       if (walk_ancestors)
1028         do
1029           {
1030             pspec = g_hash_table_lookup (hash_table, &amp;key);
</pre>
<hr />
<pre>
1043     }
1044 
1045   return pspec;
1046 }
1047 
1048 /**
1049  * g_param_spec_pool_lookup:
1050  * @pool: a #GParamSpecPool
1051  * @param_name: the name to look for
1052  * @owner_type: the owner to look for
1053  * @walk_ancestors: If %TRUE, also try to find a #GParamSpec with @param_name
1054  *  owned by an ancestor of @owner_type.
1055  *
1056  * Looks up a #GParamSpec in the pool.
1057  *
1058  * Returns: (transfer none): The found #GParamSpec, or %NULL if no
1059  * matching #GParamSpec was found.
1060  */
1061 GParamSpec*
1062 g_param_spec_pool_lookup (GParamSpecPool *pool,
<span class="line-modified">1063         const gchar    *param_name,</span>
<span class="line-modified">1064         GType           owner_type,</span>
<span class="line-modified">1065         gboolean        walk_ancestors)</span>
1066 {
1067   GParamSpec *pspec;
1068   gchar *delim;
1069 
1070   g_return_val_if_fail (pool != NULL, NULL);
1071   g_return_val_if_fail (param_name != NULL, NULL);
1072 
1073   g_mutex_lock (&amp;pool-&gt;mutex);
1074 
1075   delim = pool-&gt;type_prefixing ? strchr (param_name, &#39;:&#39;) : NULL;
1076 
1077   /* try quick and away, i.e. without prefix */
1078   if (!delim)
1079     {
1080       pspec = param_spec_ht_lookup (pool-&gt;hash_table, param_name, owner_type, walk_ancestors);
1081       g_mutex_unlock (&amp;pool-&gt;mutex);
1082 
1083       return pspec;
1084     }
1085 
1086   /* strip type prefix */
1087   if (pool-&gt;type_prefixing &amp;&amp; delim[1] == &#39;:&#39;)
1088     {
1089       guint l = delim - param_name;
1090       gchar stack_buffer[32], *buffer = l &lt; 32 ? stack_buffer : g_new (gchar, l + 1);
1091       GType type;
1092 
1093       strncpy (buffer, param_name, delim - param_name);
1094       buffer[l] = 0;
1095       type = g_type_from_name (buffer);
1096       if (l &gt;= 32)
<span class="line-modified">1097   g_free (buffer);</span>
<span class="line-modified">1098       if (type)   /* type==0 isn&#39;t a valid type pefix */</span>
<span class="line-modified">1099   {</span>
<span class="line-modified">1100     /* sanity check, these cases don&#39;t make a whole lot of sense */</span>
<span class="line-modified">1101     if ((!walk_ancestors &amp;&amp; type != owner_type) || !g_type_is_a (owner_type, type))</span>
<span class="line-modified">1102       {</span>
<span class="line-modified">1103         g_mutex_unlock (&amp;pool-&gt;mutex);</span>
1104 
<span class="line-modified">1105         return NULL;</span>
<span class="line-modified">1106       }</span>
<span class="line-modified">1107     owner_type = type;</span>
<span class="line-modified">1108     param_name += l + 2;</span>
<span class="line-modified">1109     pspec = param_spec_ht_lookup (pool-&gt;hash_table, param_name, owner_type, walk_ancestors);</span>
<span class="line-modified">1110     g_mutex_unlock (&amp;pool-&gt;mutex);</span>
1111 
<span class="line-modified">1112     return pspec;</span>
<span class="line-modified">1113   }</span>
1114     }
1115   /* malformed param_name */
1116 
1117   g_mutex_unlock (&amp;pool-&gt;mutex);
1118 
1119   return NULL;
1120 }
1121 
1122 static void
1123 pool_list (gpointer key,
<span class="line-modified">1124      gpointer value,</span>
<span class="line-modified">1125      gpointer user_data)</span>
1126 {
1127   GParamSpec *pspec = value;
1128   gpointer *data = user_data;
1129   GType owner_type = (GType) data[1];
1130 
1131   if (owner_type == pspec-&gt;owner_type)
1132     data[0] = g_list_prepend (data[0], pspec);
1133 }
1134 
1135 /**
1136  * g_param_spec_pool_list_owned:
1137  * @pool: a #GParamSpecPool
1138  * @owner_type: the owner to look for
1139  *
1140  * Gets an #GList of all #GParamSpecs owned by @owner_type in
1141  * the pool.
1142  *
1143  * Returns: (transfer container) (element-type GObject.ParamSpec): a
1144  *          #GList of all #GParamSpecs owned by @owner_type in
1145  *          the pool#GParamSpecs.
1146  */
1147 GList*
1148 g_param_spec_pool_list_owned (GParamSpecPool *pool,
<span class="line-modified">1149             GType           owner_type)</span>
1150 {
1151   gpointer data[2];
1152 
1153   g_return_val_if_fail (pool != NULL, NULL);
1154   g_return_val_if_fail (owner_type &gt; 0, NULL);
1155 
1156   g_mutex_lock (&amp;pool-&gt;mutex);
1157   data[0] = NULL;
1158   data[1] = (gpointer) owner_type;
1159   g_hash_table_foreach (pool-&gt;hash_table, pool_list, &amp;data);
1160   g_mutex_unlock (&amp;pool-&gt;mutex);
1161 
1162   return data[0];
1163 }
1164 
1165 static gint
1166 pspec_compare_id (gconstpointer a,
<span class="line-modified">1167       gconstpointer b)</span>
1168 {
1169   const GParamSpec *pspec1 = a, *pspec2 = b;
1170 
1171   if (pspec1-&gt;param_id &lt; pspec2-&gt;param_id)
1172     return -1;
1173 
1174   if (pspec1-&gt;param_id &gt; pspec2-&gt;param_id)
1175     return 1;
1176 
1177   return strcmp (pspec1-&gt;name, pspec2-&gt;name);
1178 }
1179 
1180 static inline GSList*
1181 pspec_list_remove_overridden_and_redirected (GSList     *plist,
<span class="line-modified">1182                GHashTable *ht,</span>
<span class="line-modified">1183                GType       owner_type,</span>
<span class="line-modified">1184                guint      *n_p)</span>
1185 {
1186   GSList *rlist = NULL;
1187 
1188   while (plist)
1189     {
1190       GSList *tmp = plist-&gt;next;
1191       GParamSpec *pspec = plist-&gt;data;
1192       GParamSpec *found;
1193       gboolean remove = FALSE;
1194 
1195       /* Remove paramspecs that are redirected, and also paramspecs
1196        * that have are overridden by non-redirected properties.
1197        * The idea is to get the single paramspec for each name that
1198        * best corresponds to what the application sees.
1199        */
1200       if (g_param_spec_get_redirect_target (pspec))
<span class="line-modified">1201   remove = TRUE;</span>
1202       else
<span class="line-modified">1203   {</span>
<span class="line-modified">1204     found = param_spec_ht_lookup (ht, pspec-&gt;name, owner_type, TRUE);</span>
<span class="line-modified">1205     if (found != pspec)</span>
<span class="line-modified">1206       {</span>
<span class="line-modified">1207         GParamSpec *redirect = g_param_spec_get_redirect_target (found);</span>
<span class="line-modified">1208         if (redirect != pspec)</span>
<span class="line-modified">1209     remove = TRUE;</span>
<span class="line-modified">1210       }</span>
<span class="line-modified">1211   }</span>
1212 
1213       if (remove)
<span class="line-modified">1214   {</span>
<span class="line-modified">1215     g_slist_free_1 (plist);</span>
<span class="line-modified">1216   }</span>
1217       else
<span class="line-modified">1218   {</span>
<span class="line-modified">1219     plist-&gt;next = rlist;</span>
<span class="line-modified">1220     rlist = plist;</span>
<span class="line-modified">1221     *n_p += 1;</span>
<span class="line-modified">1222   }</span>
1223       plist = tmp;
1224     }
1225   return rlist;
1226 }
1227 
1228 static void
1229 pool_depth_list (gpointer key,
<span class="line-modified">1230      gpointer value,</span>
<span class="line-modified">1231      gpointer user_data)</span>
1232 {
1233   GParamSpec *pspec = value;
1234   gpointer *data = user_data;
1235   GSList **slists = data[0];
1236   GType owner_type = (GType) data[1];
1237 
1238   if (g_type_is_a (owner_type, pspec-&gt;owner_type))
1239     {
1240       if (G_TYPE_IS_INTERFACE (pspec-&gt;owner_type))
<span class="line-modified">1241   {</span>
<span class="line-modified">1242     slists[0] = g_slist_prepend (slists[0], pspec);</span>
<span class="line-modified">1243   }</span>
1244       else
<span class="line-modified">1245   {</span>
<span class="line-modified">1246     guint d = g_type_depth (pspec-&gt;owner_type);</span>
1247 
<span class="line-modified">1248     slists[d - 1] = g_slist_prepend (slists[d - 1], pspec);</span>
<span class="line-modified">1249   }</span>
1250     }
1251 }
1252 
1253 /* We handle interfaces specially since we don&#39;t want to
1254  * count interface prerequisites like normal inheritance;
1255  * the property comes from the direct inheritance from
1256  * the prerequisite class, not from the interface that
1257  * prerequires it.
1258  *
1259  * also &#39;depth&#39; isn&#39;t a meaningful concept for interface
1260  * prerequites.
1261  */
1262 static void
1263 pool_depth_list_for_interface (gpointer key,
<span class="line-modified">1264              gpointer value,</span>
<span class="line-modified">1265              gpointer user_data)</span>
1266 {
1267   GParamSpec *pspec = value;
1268   gpointer *data = user_data;
1269   GSList **slists = data[0];
1270   GType owner_type = (GType) data[1];
1271 
1272   if (pspec-&gt;owner_type == owner_type)
1273     slists[0] = g_slist_prepend (slists[0], pspec);
1274 }
1275 
1276 /**
1277  * g_param_spec_pool_list:
1278  * @pool: a #GParamSpecPool
1279  * @owner_type: the owner to look for
1280  * @n_pspecs_p: (out): return location for the length of the returned array
1281  *
1282  * Gets an array of all #GParamSpecs owned by @owner_type in
1283  * the pool.
1284  *
1285  * Returns: (array length=n_pspecs_p) (transfer container): a newly
1286  *          allocated array containing pointers to all #GParamSpecs
1287  *          owned by @owner_type in the pool
1288  */
1289 GParamSpec**
1290 g_param_spec_pool_list (GParamSpecPool *pool,
<span class="line-modified">1291       GType           owner_type,</span>
<span class="line-modified">1292       guint          *n_pspecs_p)</span>
1293 {
1294   GParamSpec **pspecs, **p;
1295   GSList **slists, *node;
1296   gpointer data[2];
1297   guint d, i;
1298 
1299   g_return_val_if_fail (pool != NULL, NULL);
1300   g_return_val_if_fail (owner_type &gt; 0, NULL);
1301   g_return_val_if_fail (n_pspecs_p != NULL, NULL);
1302 
1303   g_mutex_lock (&amp;pool-&gt;mutex);
1304   *n_pspecs_p = 0;
1305   d = g_type_depth (owner_type);
1306   slists = g_new0 (GSList*, d);
1307   data[0] = slists;
1308   data[1] = (gpointer) owner_type;
1309 
1310   g_hash_table_foreach (pool-&gt;hash_table,
<span class="line-modified">1311       G_TYPE_IS_INTERFACE (owner_type) ?</span>
<span class="line-modified">1312          pool_depth_list_for_interface :</span>
<span class="line-modified">1313          pool_depth_list,</span>
<span class="line-modified">1314       &amp;data);</span>
1315 
1316   for (i = 0; i &lt; d; i++)
1317     slists[i] = pspec_list_remove_overridden_and_redirected (slists[i], pool-&gt;hash_table, owner_type, n_pspecs_p);
1318   pspecs = g_new (GParamSpec*, *n_pspecs_p + 1);
1319   p = pspecs;
1320   for (i = 0; i &lt; d; i++)
1321     {
1322       slists[i] = g_slist_sort (slists[i], pspec_compare_id);
1323       for (node = slists[i]; node; node = node-&gt;next)
<span class="line-modified">1324   *p++ = node-&gt;data;</span>
1325       g_slist_free (slists[i]);
1326     }
1327   *p++ = NULL;
1328   g_free (slists);
1329   g_mutex_unlock (&amp;pool-&gt;mutex);
1330 
1331   return pspecs;
1332 }
1333 
1334 
1335 /* --- auxiliary functions --- */
1336 typedef struct
1337 {
1338   /* class portion */
1339   GType           value_type;
1340   void          (*finalize)             (GParamSpec   *pspec);
1341   void          (*value_set_default)    (GParamSpec   *pspec,
<span class="line-modified">1342            GValue       *value);</span>
1343   gboolean      (*value_validate)       (GParamSpec   *pspec,
<span class="line-modified">1344            GValue       *value);</span>
1345   gint          (*values_cmp)           (GParamSpec   *pspec,
<span class="line-modified">1346            const GValue *value1,</span>
<span class="line-modified">1347            const GValue *value2);</span>
1348 } ParamSpecClassInfo;
1349 
1350 static void
1351 param_spec_generic_class_init (gpointer g_class,
<span class="line-modified">1352              gpointer class_data)</span>
1353 {
1354   GParamSpecClass *class = g_class;
1355   ParamSpecClassInfo *info = class_data;
1356 
1357   class-&gt;value_type = info-&gt;value_type;
1358   if (info-&gt;finalize)
<span class="line-modified">1359     class-&gt;finalize = info-&gt;finalize;     /* optional */</span>
1360   class-&gt;value_set_default = info-&gt;value_set_default;
1361   if (info-&gt;value_validate)
<span class="line-modified">1362     class-&gt;value_validate = info-&gt;value_validate; /* optional */</span>
1363   class-&gt;values_cmp = info-&gt;values_cmp;
1364   g_free (class_data);
1365 }
1366 
1367 static void
1368 default_value_set_default (GParamSpec *pspec,
<span class="line-modified">1369          GValue     *value)</span>
1370 {
1371   /* value is already zero initialized */
1372 }
1373 
1374 static gint
1375 default_values_cmp (GParamSpec   *pspec,
<span class="line-modified">1376         const GValue *value1,</span>
<span class="line-modified">1377         const GValue *value2)</span>
1378 {
1379   return memcmp (&amp;value1-&gt;data, &amp;value2-&gt;data, sizeof (value1-&gt;data));
1380 }
1381 
1382 /**
1383  * g_param_type_register_static:
1384  * @name: 0-terminated string used as the name of the new #GParamSpec type.
1385  * @pspec_info: The #GParamSpecTypeInfo for this #GParamSpec type.
1386  *
1387  * Registers @name as the name of a new static type derived from
1388  * #G_TYPE_PARAM. The type system uses the information contained in
1389  * the #GParamSpecTypeInfo structure pointed to by @info to manage the
1390  * #GParamSpec type and its instances.
1391  *
1392  * Returns: The new type identifier.
1393  */
1394 GType
1395 g_param_type_register_static (const gchar              *name,
<span class="line-modified">1396             const GParamSpecTypeInfo *pspec_info)</span>
1397 {
1398   GTypeInfo info = {
1399     sizeof (GParamSpecClass),      /* class_size */
1400     NULL,                          /* base_init */
1401     NULL,                          /* base_destroy */
1402     param_spec_generic_class_init, /* class_init */
1403     NULL,                          /* class_destroy */
1404     NULL,                          /* class_data */
1405     0,                             /* instance_size */
1406     16,                            /* n_preallocs */
1407     NULL,                          /* instance_init */
1408   };
1409   ParamSpecClassInfo *cinfo;
1410 
1411   g_return_val_if_fail (name != NULL, 0);
1412   g_return_val_if_fail (pspec_info != NULL, 0);
1413   g_return_val_if_fail (g_type_from_name (name) == 0, 0);
1414   g_return_val_if_fail (pspec_info-&gt;instance_size &gt;= sizeof (GParamSpec), 0);
1415   g_return_val_if_fail (g_type_name (pspec_info-&gt;value_type) != NULL, 0);
1416   /* default: g_return_val_if_fail (pspec_info-&gt;value_set_default != NULL, 0); */
</pre>
<hr />
<pre>
1423   cinfo = g_new (ParamSpecClassInfo, 1);
1424   cinfo-&gt;value_type = pspec_info-&gt;value_type;
1425   cinfo-&gt;finalize = pspec_info-&gt;finalize;
1426   cinfo-&gt;value_set_default = pspec_info-&gt;value_set_default ? pspec_info-&gt;value_set_default : default_value_set_default;
1427   cinfo-&gt;value_validate = pspec_info-&gt;value_validate;
1428   cinfo-&gt;values_cmp = pspec_info-&gt;values_cmp ? pspec_info-&gt;values_cmp : default_values_cmp;
1429   info.class_data = cinfo;
1430 
1431   return g_type_register_static (G_TYPE_PARAM, name, &amp;info, 0);
1432 }
1433 
1434 /**
1435  * g_value_set_param:
1436  * @value: a valid #GValue of type %G_TYPE_PARAM
1437  * @param: (nullable): the #GParamSpec to be set
1438  *
1439  * Set the contents of a %G_TYPE_PARAM #GValue to @param.
1440  */
1441 void
1442 g_value_set_param (GValue     *value,
<span class="line-modified">1443        GParamSpec *param)</span>
1444 {
1445   g_return_if_fail (G_VALUE_HOLDS_PARAM (value));
1446   if (param)
1447     g_return_if_fail (G_IS_PARAM_SPEC (param));
1448 
1449   if (value-&gt;data[0].v_pointer)
1450     g_param_spec_unref (value-&gt;data[0].v_pointer);
1451   value-&gt;data[0].v_pointer = param;
1452   if (value-&gt;data[0].v_pointer)
1453     g_param_spec_ref (value-&gt;data[0].v_pointer);
1454 }
1455 
1456 /**
1457  * g_value_set_param_take_ownership: (skip)
1458  * @value: a valid #GValue of type %G_TYPE_PARAM
1459  * @param: (nullable): the #GParamSpec to be set
1460  *
1461  * This is an internal function introduced mainly for C marshallers.
1462  *
1463  * Deprecated: 2.4: Use g_value_take_param() instead.
1464  */
1465 void
1466 g_value_set_param_take_ownership (GValue     *value,
<span class="line-modified">1467           GParamSpec *param)</span>
1468 {
1469   g_value_take_param (value, param);
1470 }
1471 
1472 /**
1473  * g_value_take_param: (skip)
1474  * @value: a valid #GValue of type %G_TYPE_PARAM
1475  * @param: (nullable): the #GParamSpec to be set
1476  *
1477  * Sets the contents of a %G_TYPE_PARAM #GValue to @param and takes
<span class="line-modified">1478  * over the ownership of the caller&#39;s reference to @param; the caller</span>
1479  * doesn&#39;t have to unref it any more.
1480  *
1481  * Since: 2.4
1482  */
1483 void
1484 g_value_take_param (GValue     *value,
<span class="line-modified">1485         GParamSpec *param)</span>
1486 {
1487   g_return_if_fail (G_VALUE_HOLDS_PARAM (value));
1488   if (param)
1489     g_return_if_fail (G_IS_PARAM_SPEC (param));
1490 
1491   if (value-&gt;data[0].v_pointer)
1492     g_param_spec_unref (value-&gt;data[0].v_pointer);
1493   value-&gt;data[0].v_pointer = param; /* we take over the reference count */
1494 }
1495 
1496 /**
1497  * g_value_get_param:
1498  * @value: a valid #GValue whose type is derived from %G_TYPE_PARAM
1499  *
1500  * Get the contents of a %G_TYPE_PARAM #GValue.
1501  *
1502  * Returns: (transfer none): #GParamSpec content of @value
1503  */
1504 GParamSpec*
1505 g_value_get_param (const GValue *value)
</pre>
<hr />
<pre>
1548    * it will be zero before it is initialised and non-zero after.  We
1549    * have to take care that we don&#39;t write a non-zero value to the type
1550    * field before we are completely done, however, because then another
1551    * thread could come along and find the value partially-initialised.
1552    *
1553    * In order to accomplish this we store the default value in a
1554    * stack-allocated GValue.  We then set the type field in that value
1555    * to zero and copy the contents into place.  We then end by storing
1556    * the type as the last step in order to ensure that we&#39;re completely
1557    * done before a g_once_init_enter() could take the fast path in
1558    * another thread.
1559    */
1560   if (g_once_init_enter (&amp;priv-&gt;default_value.g_type))
1561     {
1562       GValue default_value = G_VALUE_INIT;
1563 
1564       g_value_init (&amp;default_value, pspec-&gt;value_type);
1565       g_param_value_set_default (pspec, &amp;default_value);
1566 
1567       /* store all but the type */
<span class="line-modified">1568       memcpy (priv-&gt;default_value.data, default_value.data, sizeof (default_value.data));</span>

1569 
1570       g_once_init_leave (&amp;priv-&gt;default_value.g_type, pspec-&gt;value_type);
1571     }
1572 
1573   return &amp;priv-&gt;default_value;
1574 }
1575 
1576 /**
1577  * g_param_spec_get_name_quark:
1578  * @pspec: a #GParamSpec
1579  *
1580  * Gets the GQuark for the name.
1581  *
1582  * Returns: the GQuark for @pspec-&gt;name.
1583  *
1584  * Since: 2.46
1585  */
1586 GQuark
1587 g_param_spec_get_name_quark (GParamSpec *pspec)
1588 {
</pre>
</td>
</tr>
</table>
<center><a href="gobject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gparam.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>