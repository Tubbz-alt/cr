diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gchecksum.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gchecksum.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gchecksum.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gchecksum.c
@@ -175,12 +175,11 @@
 
 static gchar *
 digest_to_string (guint8 *digest,
                   gsize   digest_len)
 {
-  gint len = digest_len * 2;
-  gint i;
+  gsize i, len = digest_len * 2;
   gchar *retval;
 
   retval = g_new (gchar, len + 1);
 
   for (i = 0; i < digest_len; i++)
@@ -461,11 +460,11 @@
  * SHA-1 Checksum
  */
 
 /* The following implementation comes from D-Bus dbus-sha.c. I've changed
  * it to use GLib types and to work more like the MD5 implementation above.
- * I left the comments to have an history of this code.
+ * I left the comments to have a history of this code.
  *      -- Emmanuele Bassi, ebassi@gnome.org
  */
 
 /* The following comments have the history of where this code
  * comes from. I actually copied it from GNet in GNOME CVS.
@@ -1088,17 +1087,17 @@
 /*
  * SHA-384, SHA-512, SHA-512/224 and SHA-512/256 Checksums
  *
  * Implemented following FIPS-180-4 standard at
  * http://csrc.nist.gov/publications/fips/fips180-4/fips180-4.pdf.
- * References in the form [�x.y.z] map to sections in that document.
+ * References in the form [x.y.z] map to sections in that document.
  *
  *   Author(s): Eduardo Lima Mitev <elima@igalia.com>
  *              Igor Gnatenko <ignatenko@src.gnome.org>
  */
 
-/* SHA-384, SHA-512, SHA-512/224 and SHA-512/256 functions [�4.1.3] */
+/* SHA-384, SHA-512, SHA-512/224 and SHA-512/256 functions [4.1.3] */
 #define Ch(x,y,z)  ((x & y) ^ (~x & z))
 #define Maj(x,y,z) ((x & y) ^ (x & z) ^ (y & z))
 #define SHR(n,x)   (x >> n)
 #define ROTR(n,x)  (SHR (n, x) | (x << (64 - n)))
 #define SIGMA0(x)  (ROTR (28, x) ^ ROTR (34, x) ^ ROTR (39, x))
@@ -1114,11 +1113,11 @@
     (b)[(i) + 4] = (guint8) (n >> 24);                   \
     (b)[(i) + 5] = (guint8) (n >> 16);                   \
     (b)[(i) + 6] = (guint8) (n >>  8);                   \
     (b)[(i) + 7] = (guint8) (n      ); } G_STMT_END
 
-/* SHA-384 and SHA-512 constants [�4.2.3] */
+/* SHA-384 and SHA-512 constants [4.2.3] */
 static const guint64 SHA2_K[80] = {
   G_GUINT64_CONSTANT (0x428a2f98d728ae22), G_GUINT64_CONSTANT (0x7137449123ef65cd),
   G_GUINT64_CONSTANT (0xb5c0fbcfec4d3b2f), G_GUINT64_CONSTANT (0xe9b5dba58189dbbc),
   G_GUINT64_CONSTANT (0x3956c25bf348b538), G_GUINT64_CONSTANT (0x59f111f1b605d019),
   G_GUINT64_CONSTANT (0x923f82a4af194f9b), G_GUINT64_CONSTANT (0xab1c5ed5da6d8118),
@@ -1162,11 +1161,11 @@
 
 
 static void
 sha384_sum_init (Sha512sum *sha512)
 {
-  /* Initial Hash Value [�5.3.4] */
+  /* Initial Hash Value [5.3.4] */
   sha512->H[0] = G_GUINT64_CONSTANT (0xcbbb9d5dc1059ed8);
   sha512->H[1] = G_GUINT64_CONSTANT (0x629a292a367cd507);
   sha512->H[2] = G_GUINT64_CONSTANT (0x9159015a3070dd17);
   sha512->H[3] = G_GUINT64_CONSTANT (0x152fecd8f70e5939);
   sha512->H[4] = G_GUINT64_CONSTANT (0x67332667ffc00b31);
@@ -1181,11 +1180,11 @@
 }
 
 static void
 sha512_sum_init (Sha512sum *sha512)
 {
-  /* Initial Hash Value [�5.3.5] */
+  /* Initial Hash Value [5.3.5] */
   sha512->H[0] = G_GUINT64_CONSTANT (0x6a09e667f3bcc908);
   sha512->H[1] = G_GUINT64_CONSTANT (0xbb67ae8584caa73b);
   sha512->H[2] = G_GUINT64_CONSTANT (0x3c6ef372fe94f82b);
   sha512->H[3] = G_GUINT64_CONSTANT (0xa54ff53a5f1d36f1);
   sha512->H[4] = G_GUINT64_CONSTANT (0x510e527fade682d1);
@@ -1207,11 +1206,11 @@
   gint t;
   guint64 a, b, c, d, e, f, g, h;
   guint64 M[16];
   guint64 W[80];
 
-  /* SHA-512 hash computation [�6.4.2] */
+  /* SHA-512 hash computation [6.4.2] */
 
   /* prepare the message schedule */
   for (i = 0; i < 16; i++)
     {
       gint p = i * 8;
@@ -1329,11 +1328,11 @@
   gint zeros;
   guint8 pad[SHA2_BLOCK_LEN * 2] = { 0, };
   guint pad_len = 0;
   gint i;
 
-  /* apply padding [�5.1.2] */
+  /* apply padding [5.1.2] */
   l = sha512->block_len * 8;
   zeros = 896 - (l + 1);
 
   if (zeros < 0)
     zeros += 128 * 8;
@@ -1627,11 +1626,11 @@
 
 /**
  * g_checksum_get_string:
  * @checksum: a #GChecksum
  *
- * Gets the digest as an hexadecimal string.
+ * Gets the digest as a hexadecimal string.
  *
  * Once this function has been called the #GChecksum can no longer be
  * updated with g_checksum_update().
  *
  * The hexadecimal characters will be lower case.
