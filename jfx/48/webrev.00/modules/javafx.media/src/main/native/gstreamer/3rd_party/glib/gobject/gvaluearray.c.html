<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gvaluearray.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /* GObject - GLib Type, Object, Parameter and Signal Library
  2  * Copyright (C) 2001 Red Hat, Inc.
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Lesser General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2.1 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Lesser General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Lesser General
 15  * Public License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 16  */
 17 
 18 /*
 19  * MT safe
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 
 24 #include &lt;string.h&gt;
 25 #include &lt;stdlib.h&gt;  /* qsort() */
 26 
 27 #include &quot;gvaluearray.h&quot;
 28 
 29 
 30 /**
 31  * SECTION:value_arrays
 32  * @short_description: A container structure to maintain an array of
 33  *     generic values
 34  * @see_also: #GValue, #GParamSpecValueArray, g_param_spec_value_array()
 35  * @title: Value arrays
 36  *
 37  * The prime purpose of a #GValueArray is for it to be used as an
 38  * object property that holds an array of values. A #GValueArray wraps
 39  * an array of #GValue elements in order for it to be used as a boxed
 40  * type through %G_TYPE_VALUE_ARRAY.
 41  *
 42  * #GValueArray is deprecated in favour of #GArray since GLib 2.32. It
 43  * is possible to create a #GArray that behaves like a #GValueArray by
 44  * using the size of #GValue as the element size, and by setting
 45  * g_value_unset() as the clear function using g_array_set_clear_func(),
 46  * for instance, the following code:
 47  *
 48  * |[&lt;!-- language=&quot;C&quot; --&gt;
 49  *   GValueArray *array = g_value_array_new (10);
 50  * ]|
 51  *
 52  * can be replaced by:
 53  *
 54  * |[&lt;!-- language=&quot;C&quot; --&gt;
 55  *   GArray *array = g_array_sized_new (FALSE, TRUE, sizeof (GValue), 10);
 56  *   g_array_set_clear_func (array, (GDestroyNotify) g_value_unset);
 57  * ]|
 58  *
 59  * Deprecated: 2.32: Use #GArray instead, if possible for the given use case,
 60  *    as described above.
 61  */
 62 
 63 #define GROUP_N_VALUES  (8) /* power of 2 !! */
 64 
 65 
 66 /* --- functions --- */
 67 /**
 68  * g_value_array_get_nth:
 69  * @value_array: #GValueArray to get a value from
 70  * @index_: index of the value of interest
 71  *
 72  * Return a pointer to the value at @index_ containd in @value_array.
 73  *
 74  * Returns: (transfer none): pointer to a value at @index_ in @value_array
 75  *
 76  * Deprecated: 2.32: Use g_array_index() instead.
 77  */
 78 GValue*
 79 g_value_array_get_nth (GValueArray *value_array,
 80            guint        index)
 81 {
 82   g_return_val_if_fail (value_array != NULL, NULL);
 83   g_return_val_if_fail (index &lt; value_array-&gt;n_values, NULL);
 84 
 85   return value_array-&gt;values + index;
 86 }
 87 
 88 static inline void
 89 value_array_grow (GValueArray *value_array,
 90       guint        n_values,
 91       gboolean     zero_init)
 92 {
 93   g_return_if_fail (n_values &gt;= value_array-&gt;n_values);
 94 
 95   value_array-&gt;n_values = n_values;
 96   if (value_array-&gt;n_values &gt; value_array-&gt;n_prealloced)
 97     {
 98       guint i = value_array-&gt;n_prealloced;
 99 
100       value_array-&gt;n_prealloced = (value_array-&gt;n_values + GROUP_N_VALUES - 1) &amp; ~(GROUP_N_VALUES - 1);
101       value_array-&gt;values = g_renew (GValue, value_array-&gt;values, value_array-&gt;n_prealloced);
102       if (!zero_init)
103   i = value_array-&gt;n_values;
104       memset (value_array-&gt;values + i, 0,
105         (value_array-&gt;n_prealloced - i) * sizeof (value_array-&gt;values[0]));
106     }
107 }
108 
109 /**
110  * g_value_array_new:
111  * @n_prealloced: number of values to preallocate space for
112  *
113  * Allocate and initialize a new #GValueArray, optionally preserve space
114  * for @n_prealloced elements. New arrays always contain 0 elements,
115  * regardless of the value of @n_prealloced.
116  *
117  * Returns: a newly allocated #GValueArray with 0 values
118  *
119  * Deprecated: 2.32: Use #GArray and g_array_sized_new() instead.
120  */
121 GValueArray*
122 g_value_array_new (guint n_prealloced)
123 {
124   GValueArray *value_array = g_slice_new (GValueArray);
125 #ifdef GSTREAMER_LITE
126   if (value_array == NULL) {
127     return NULL;
128   }
129 #endif // GSTREAMER_LITE
130 
131   value_array-&gt;n_values = 0;
132   value_array-&gt;n_prealloced = 0;
133   value_array-&gt;values = NULL;
134   value_array_grow (value_array, n_prealloced, TRUE);
135   value_array-&gt;n_values = 0;
136 
137   return value_array;
138 }
139 
140 /**
141  * g_value_array_free: (skip)
142  * @value_array: #GValueArray to free
143  *
144  * Free a #GValueArray including its contents.
145  *
146  * Deprecated: 2.32: Use #GArray and g_array_unref() instead.
147  */
148 void
149 g_value_array_free (GValueArray *value_array)
150 {
151   guint i;
152 
153   g_return_if_fail (value_array != NULL);
154 
155   for (i = 0; i &lt; value_array-&gt;n_values; i++)
156     {
157       GValue *value = value_array-&gt;values + i;
158 
159       if (G_VALUE_TYPE (value) != 0) /* we allow unset values in the array */
160   g_value_unset (value);
161     }
162   g_free (value_array-&gt;values);
163   g_slice_free (GValueArray, value_array);
164 }
165 
166 /**
167  * g_value_array_copy:
168  * @value_array: #GValueArray to copy
169  *
170  * Construct an exact copy of a #GValueArray by duplicating all its
171  * contents.
172  *
173  * Returns: (transfer full): Newly allocated copy of #GValueArray
174  *
175  * Deprecated: 2.32: Use #GArray and g_array_ref() instead.
176  */
177 GValueArray*
178 g_value_array_copy (const GValueArray *value_array)
179 {
180   GValueArray *new_array;
181   guint i;
182 
183   g_return_val_if_fail (value_array != NULL, NULL);
184 
185   new_array = g_slice_new (GValueArray);
186 #ifdef GSTREAMER_LITE
187   if (new_array == NULL) {
188     return NULL;
189   }
190 #endif // GSTREAMER_LITE
191   new_array-&gt;n_values = 0;
192   new_array-&gt;values = NULL;
193   new_array-&gt;n_prealloced = 0;
194   value_array_grow (new_array, value_array-&gt;n_values, TRUE);
195   for (i = 0; i &lt; new_array-&gt;n_values; i++)
196     if (G_VALUE_TYPE (value_array-&gt;values + i) != 0)
197       {
198   GValue *value = new_array-&gt;values + i;
199 
200   g_value_init (value, G_VALUE_TYPE (value_array-&gt;values + i));
201   g_value_copy (value_array-&gt;values + i, value);
202       }
203   return new_array;
204 }
205 
206 /**
207  * g_value_array_prepend:
208  * @value_array: #GValueArray to add an element to
209  * @value: (nullable): #GValue to copy into #GValueArray, or %NULL
210  *
211  * Insert a copy of @value as first element of @value_array. If @value is
212  * %NULL, an uninitialized value is prepended.
213  *
214  *
215  * Returns: (transfer none): the #GValueArray passed in as @value_array
216  *
217  * Deprecated: 2.32: Use #GArray and g_array_prepend_val() instead.
218  */
219 GValueArray*
220 g_value_array_prepend (GValueArray  *value_array,
221            const GValue *value)
222 {
223   g_return_val_if_fail (value_array != NULL, NULL);
224 
225   G_GNUC_BEGIN_IGNORE_DEPRECATIONS
226   return g_value_array_insert (value_array, 0, value);
227   G_GNUC_END_IGNORE_DEPRECATIONS
228 }
229 
230 /**
231  * g_value_array_append:
232  * @value_array: #GValueArray to add an element to
233  * @value: (nullable): #GValue to copy into #GValueArray, or %NULL
234  *
235  * Insert a copy of @value as last element of @value_array. If @value is
236  * %NULL, an uninitialized value is appended.
237  *
238  * Returns: (transfer none): the #GValueArray passed in as @value_array
239  *
240  * Deprecated: 2.32: Use #GArray and g_array_append_val() instead.
241  */
242 GValueArray*
243 g_value_array_append (GValueArray  *value_array,
244           const GValue *value)
245 {
246   g_return_val_if_fail (value_array != NULL, NULL);
247 
248   G_GNUC_BEGIN_IGNORE_DEPRECATIONS
249   return g_value_array_insert (value_array, value_array-&gt;n_values, value);
250   G_GNUC_END_IGNORE_DEPRECATIONS
251 }
252 
253 /**
254  * g_value_array_insert:
255  * @value_array: #GValueArray to add an element to
256  * @index_: insertion position, must be &lt;= value_array-&gt;;n_values
257  * @value: (nullable): #GValue to copy into #GValueArray, or %NULL
258  *
259  * Insert a copy of @value at specified position into @value_array. If @value
260  * is %NULL, an uninitialized value is inserted.
261  *
262  * Returns: (transfer none): the #GValueArray passed in as @value_array
263  *
264  * Deprecated: 2.32: Use #GArray and g_array_insert_val() instead.
265  */
266 GValueArray*
267 g_value_array_insert (GValueArray  *value_array,
268           guint         index,
269           const GValue *value)
270 {
271   guint i;
272 
273   g_return_val_if_fail (value_array != NULL, NULL);
274   g_return_val_if_fail (index &lt;= value_array-&gt;n_values, value_array);
275 
276   i = value_array-&gt;n_values;
277   value_array_grow (value_array, value_array-&gt;n_values + 1, FALSE);
278   if (index + 1 &lt; value_array-&gt;n_values)
279     memmove (value_array-&gt;values + index + 1, value_array-&gt;values + index,
280              (i - index) * sizeof (value_array-&gt;values[0]));
281   memset (value_array-&gt;values + index, 0, sizeof (value_array-&gt;values[0]));
282   if (value)
283     {
284       g_value_init (value_array-&gt;values + index, G_VALUE_TYPE (value));
285       g_value_copy (value, value_array-&gt;values + index);
286     }
287   return value_array;
288 }
289 
290 /**
291  * g_value_array_remove:
292  * @value_array: #GValueArray to remove an element from
293  * @index_: position of value to remove, which must be less than
294  *     @value_array-&gt;n_values
295  *
296  * Remove the value at position @index_ from @value_array.
297  *
298  * Returns: (transfer none): the #GValueArray passed in as @value_array
299  *
300  * Deprecated: 2.32: Use #GArray and g_array_remove_index() instead.
301  */
302 GValueArray*
303 g_value_array_remove (GValueArray *value_array,
304           guint        index)
305 {
306   g_return_val_if_fail (value_array != NULL, NULL);
307   g_return_val_if_fail (index &lt; value_array-&gt;n_values, value_array);
308 
309   if (G_VALUE_TYPE (value_array-&gt;values + index) != 0)
310     g_value_unset (value_array-&gt;values + index);
311   value_array-&gt;n_values--;
312   if (index &lt; value_array-&gt;n_values)
313     memmove (value_array-&gt;values + index, value_array-&gt;values + index + 1,
314              (value_array-&gt;n_values - index) * sizeof (value_array-&gt;values[0]));
315   if (value_array-&gt;n_prealloced &gt; value_array-&gt;n_values)
316     memset (value_array-&gt;values + value_array-&gt;n_values, 0, sizeof (value_array-&gt;values[0]));
317 
318   return value_array;
319 }
320 
321 /**
322  * g_value_array_sort:
323  * @value_array: #GValueArray to sort
324  * @compare_func: (scope call): function to compare elements
325  *
326  * Sort @value_array using @compare_func to compare the elements according to
327  * the semantics of #GCompareFunc.
328  *
329  * The current implementation uses the same sorting algorithm as standard
330  * C qsort() function.
331  *
332  * Returns: (transfer none): the #GValueArray passed in as @value_array
333  *
334  * Deprecated: 2.32: Use #GArray and g_array_sort().
335  */
336 GValueArray*
337 g_value_array_sort (GValueArray *value_array,
338         GCompareFunc compare_func)
339 {
340   g_return_val_if_fail (compare_func != NULL, NULL);
341 
342   if (value_array-&gt;n_values)
343     qsort (value_array-&gt;values,
344      value_array-&gt;n_values,
345      sizeof (value_array-&gt;values[0]),
346      compare_func);
347   return value_array;
348 }
349 
350 /**
351  * g_value_array_sort_with_data: (rename-to g_value_array_sort)
352  * @value_array: #GValueArray to sort
353  * @compare_func: (scope call): function to compare elements
354  * @user_data: (closure): extra data argument provided for @compare_func
355  *
356  * Sort @value_array using @compare_func to compare the elements according
357  * to the semantics of #GCompareDataFunc.
358  *
359  * The current implementation uses the same sorting algorithm as standard
360  * C qsort() function.
361  *
362  * Returns: (transfer none): the #GValueArray passed in as @value_array
363  *
364  * Deprecated: 2.32: Use #GArray and g_array_sort_with_data().
365  */
366 GValueArray*
367 g_value_array_sort_with_data (GValueArray     *value_array,
368             GCompareDataFunc compare_func,
369             gpointer         user_data)
370 {
371   g_return_val_if_fail (value_array != NULL, NULL);
372   g_return_val_if_fail (compare_func != NULL, NULL);
373 
374   if (value_array-&gt;n_values)
375     g_qsort_with_data (value_array-&gt;values,
376            value_array-&gt;n_values,
377            sizeof (value_array-&gt;values[0]),
378            compare_func, user_data);
379   return value_array;
380 }
    </pre>
  </body>
</html>