<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudiodecoder.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 2009 Igalia S.L.
   3  * Author: Iago Toral Quiroga &lt;itoral@igalia.com&gt;
   4  * Copyright (C) 2011 Mark Nauwelaerts &lt;mark.nauwelaerts@collabora.co.uk&gt;.
   5  * Copyright (C) 2011 Nokia Corporation. All rights reserved.
   6  *   Contact: Stefan Kost &lt;stefan.kost@nokia.com&gt;
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public
  19  * License along with this library; if not, write to the
  20  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 /**
  25  * SECTION:gstaudiodecoder
  26  * @title: GstAudioDecoder
  27  * @short_description: Base class for audio decoders
  28  * @see_also: #GstBaseTransform
  29  *
  30  * This base class is for audio decoders turning encoded data into
  31  * raw audio samples.
  32  *
  33  * GstAudioDecoder and subclass should cooperate as follows.
  34  *
  35  * ## Configuration
  36  *
  37  *   * Initially, GstAudioDecoder calls @start when the decoder element
  38  *     is activated, which allows subclass to perform any global setup.
  39  *     Base class (context) parameters can already be set according to subclass
  40  *     capabilities (or possibly upon receive more information in subsequent
  41  *     @set_format).
  42  *   * GstAudioDecoder calls @set_format to inform subclass of the format
  43  *     of input audio data that it is about to receive.
  44  *     While unlikely, it might be called more than once, if changing input
  45  *     parameters require reconfiguration.
  46  *   * GstAudioDecoder calls @stop at end of all processing.
  47  *
  48  * As of configuration stage, and throughout processing, GstAudioDecoder
  49  * provides various (context) parameters, e.g. describing the format of
  50  * output audio data (valid when output caps have been set) or current parsing state.
  51  * Conversely, subclass can and should configure context to inform
  52  * base class of its expectation w.r.t. buffer handling.
  53  *
  54  * ## Data processing
  55  *     * Base class gathers input data, and optionally allows subclass
  56  *       to parse this into subsequently manageable (as defined by subclass)
  57  *       chunks.  Such chunks are subsequently referred to as &#39;frames&#39;,
  58  *       though they may or may not correspond to 1 (or more) audio format frame.
  59  *     * Input frame is provided to subclass&#39; @handle_frame.
  60  *     * If codec processing results in decoded data, subclass should call
  61  *       @gst_audio_decoder_finish_frame to have decoded data pushed
  62  *       downstream.
  63  *     * Just prior to actually pushing a buffer downstream,
  64  *       it is passed to @pre_push.  Subclass should either use this callback
  65  *       to arrange for additional downstream pushing or otherwise ensure such
  66  *       custom pushing occurs after at least a method call has finished since
  67  *       setting src pad caps.
  68  *     * During the parsing process GstAudioDecoderClass will handle both
  69  *       srcpad and sinkpad events. Sink events will be passed to subclass
  70  *       if @event callback has been provided.
  71  *
  72  * ## Shutdown phase
  73  *
  74  *   * GstAudioDecoder class calls @stop to inform the subclass that data
  75  *     parsing will be stopped.
  76  *
  77  * Subclass is responsible for providing pad template caps for
  78  * source and sink pads. The pads need to be named &quot;sink&quot; and &quot;src&quot;. It also
  79  * needs to set the fixed caps on srcpad, when the format is ensured.  This
  80  * is typically when base class calls subclass&#39; @set_format function, though
  81  * it might be delayed until calling @gst_audio_decoder_finish_frame.
  82  *
  83  * In summary, above process should have subclass concentrating on
  84  * codec data processing while leaving other matters to base class,
  85  * such as most notably timestamp handling.  While it may exert more control
  86  * in this area (see e.g. @pre_push), it is very much not recommended.
  87  *
  88  * In particular, base class will try to arrange for perfect output timestamps
  89  * as much as possible while tracking upstream timestamps.
  90  * To this end, if deviation between the next ideal expected perfect timestamp
  91  * and upstream exceeds #GstAudioDecoder:tolerance, then resync to upstream
  92  * occurs (which would happen always if the tolerance mechanism is disabled).
  93  *
  94  * In non-live pipelines, baseclass can also (configurably) arrange for
  95  * output buffer aggregation which may help to redue large(r) numbers of
  96  * small(er) buffers being pushed and processed downstream.
  97  *
  98  * On the other hand, it should be noted that baseclass only provides limited
  99  * seeking support (upon explicit subclass request), as full-fledged support
 100  * should rather be left to upstream demuxer, parser or alike.  This simple
 101  * approach caters for seeking and duration reporting using estimated input
 102  * bitrates.
 103  *
 104  * Things that subclass need to take care of:
 105  *
 106  *   * Provide pad templates
 107  *   * Set source pad caps when appropriate
 108  *   * Set user-configurable properties to sane defaults for format and
 109  *      implementing codec at hand, and convey some subclass capabilities and
 110  *      expectations in context.
 111  *
 112  *   * Accept data in @handle_frame and provide encoded results to
 113  *      @gst_audio_decoder_finish_frame.  If it is prepared to perform
 114  *      PLC, it should also accept NULL data in @handle_frame and provide for
 115  *      data for indicated duration.
 116  *
 117  */
 118 
 119 #ifdef HAVE_CONFIG_H
 120 #include &quot;config.h&quot;
 121 #endif
 122 
 123 #include &quot;gstaudiodecoder.h&quot;
 124 #include &quot;gstaudioutilsprivate.h&quot;
 125 #include &lt;gst/pbutils/descriptions.h&gt;
 126 
 127 #include &lt;string.h&gt;
 128 
 129 GST_DEBUG_CATEGORY (audiodecoder_debug);
 130 #define GST_CAT_DEFAULT audiodecoder_debug
 131 
 132 #define GST_AUDIO_DECODER_GET_PRIVATE(obj)  \
 133     (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_AUDIO_DECODER, \
 134         GstAudioDecoderPrivate))
 135 
 136 enum
 137 {
 138   LAST_SIGNAL
 139 };
 140 
 141 enum
 142 {
 143   PROP_0,
 144   PROP_LATENCY,
 145   PROP_TOLERANCE,
 146   PROP_PLC
 147 };
 148 
 149 #define DEFAULT_LATENCY    0
 150 #define DEFAULT_TOLERANCE  0
 151 #define DEFAULT_PLC        FALSE
 152 #define DEFAULT_DRAINABLE  TRUE
 153 #define DEFAULT_NEEDS_FORMAT  FALSE
 154 
 155 typedef struct _GstAudioDecoderContext
 156 {
 157   /* last negotiated input caps */
 158   GstCaps *input_caps;
 159 
 160   /* (output) audio format */
 161   GstAudioInfo info;
 162   gboolean output_format_changed;
 163 
 164   /* parsing state */
 165   gboolean eos;
 166   gboolean sync;
 167 
 168   gboolean had_output_data;
 169   gboolean had_input_data;
 170 
 171   /* misc */
 172   gint delay;
 173 
 174   /* output */
 175   gboolean do_plc;
 176   gboolean do_estimate_rate;
 177   gint max_errors;
 178   GstCaps *allocation_caps;
 179   /* MT-protected (with LOCK) */
 180   GstClockTime min_latency;
 181   GstClockTime max_latency;
 182 
 183   GstAllocator *allocator;
 184   GstAllocationParams params;
 185 } GstAudioDecoderContext;
 186 
 187 struct _GstAudioDecoderPrivate
 188 {
 189   /* activation status */
 190   gboolean active;
 191 
 192   /* input base/first ts as basis for output ts */
 193   GstClockTime base_ts;
 194   /* input samples processed and sent downstream so far (w.r.t. base_ts) */
 195   guint64 samples;
 196 
 197   /* collected input data */
 198   GstAdapter *adapter;
 199   /* tracking input ts for changes */
 200   GstClockTime prev_ts;
 201   guint64 prev_distance;
 202   /* frames obtained from input */
 203   GQueue frames;
 204   /* collected output data */
 205   GstAdapter *adapter_out;
 206   /* ts and duration for output data collected above */
 207   GstClockTime out_ts, out_dur;
 208   /* mark outgoing discont */
 209   gboolean discont;
 210 
 211   /* subclass gave all it could already */
 212   gboolean drained;
 213   /* subclass currently being forcibly drained */
 214   gboolean force;
 215   /* input_segment are output_segment identical */
 216   gboolean in_out_segment_sync;
 217   /* expecting the buffer with DISCONT flag */
 218   gboolean expecting_discont_buf;
 219 
 220 
 221   /* input bps estimatation */
 222   /* global in bytes seen */
 223   guint64 bytes_in;
 224   /* global samples sent out */
 225   guint64 samples_out;
 226   /* bytes flushed during parsing */
 227   guint sync_flush;
 228   /* error count */
 229   gint error_count;
 230 
 231   /* upstream stream tags (global tags are passed through as-is) */
 232   GstTagList *upstream_tags;
 233 
 234   /* subclass tags */
 235   GstTagList *taglist;          /* FIXME: rename to decoder_tags */
 236   GstTagMergeMode decoder_tags_merge_mode;
 237 
 238   gboolean taglist_changed;     /* FIXME: rename to tags_changed */
 239 
 240   /* whether circumstances allow output aggregation */
 241   gint agg;
 242 
 243   /* reverse playback queues */
 244   /* collect input */
 245   GList *gather;
 246   /* to-be-decoded */
 247   GList *decode;
 248   /* reversed output */
 249   GList *queued;
 250 
 251   /* context storage */
 252   GstAudioDecoderContext ctx;
 253 
 254   /* properties */
 255   GstClockTime latency;
 256   GstClockTime tolerance;
 257   gboolean plc;
 258   gboolean drainable;
 259   gboolean needs_format;
 260 
 261   /* pending serialized sink events, will be sent from finish_frame() */
 262   GList *pending_events;
 263 
 264   /* flags */
 265   gboolean use_default_pad_acceptcaps;
 266 };
 267 
 268 static void gst_audio_decoder_finalize (GObject * object);
 269 static void gst_audio_decoder_set_property (GObject * object,
 270     guint prop_id, const GValue * value, GParamSpec * pspec);
 271 static void gst_audio_decoder_get_property (GObject * object,
 272     guint prop_id, GValue * value, GParamSpec * pspec);
 273 
 274 static void gst_audio_decoder_clear_queues (GstAudioDecoder * dec);
 275 static GstFlowReturn gst_audio_decoder_chain_reverse (GstAudioDecoder *
 276     dec, GstBuffer * buf);
 277 
 278 static GstStateChangeReturn gst_audio_decoder_change_state (GstElement *
 279     element, GstStateChange transition);
 280 static gboolean gst_audio_decoder_sink_eventfunc (GstAudioDecoder * dec,
 281     GstEvent * event);
 282 static gboolean gst_audio_decoder_src_eventfunc (GstAudioDecoder * dec,
 283     GstEvent * event);
 284 static gboolean gst_audio_decoder_sink_event (GstPad * pad, GstObject * parent,
 285     GstEvent * event);
 286 static gboolean gst_audio_decoder_src_event (GstPad * pad, GstObject * parent,
 287     GstEvent * event);
 288 static gboolean gst_audio_decoder_sink_setcaps (GstAudioDecoder * dec,
 289     GstCaps * caps);
 290 static GstFlowReturn gst_audio_decoder_chain (GstPad * pad, GstObject * parent,
 291     GstBuffer * buf);
 292 static gboolean gst_audio_decoder_src_query (GstPad * pad, GstObject * parent,
 293     GstQuery * query);
 294 static gboolean gst_audio_decoder_sink_query (GstPad * pad, GstObject * parent,
 295     GstQuery * query);
 296 static void gst_audio_decoder_reset (GstAudioDecoder * dec, gboolean full);
 297 
 298 static gboolean gst_audio_decoder_decide_allocation_default (GstAudioDecoder *
 299     dec, GstQuery * query);
 300 static gboolean gst_audio_decoder_propose_allocation_default (GstAudioDecoder *
 301     dec, GstQuery * query);
 302 static gboolean gst_audio_decoder_negotiate_default (GstAudioDecoder * dec);
 303 static gboolean gst_audio_decoder_negotiate_unlocked (GstAudioDecoder * dec);
 304 static gboolean gst_audio_decoder_handle_gap (GstAudioDecoder * dec,
 305     GstEvent * event);
 306 static gboolean gst_audio_decoder_sink_query_default (GstAudioDecoder * dec,
 307     GstQuery * query);
 308 static gboolean gst_audio_decoder_src_query_default (GstAudioDecoder * dec,
 309     GstQuery * query);
 310 
 311 static gboolean gst_audio_decoder_transform_meta_default (GstAudioDecoder *
 312     decoder, GstBuffer * outbuf, GstMeta * meta, GstBuffer * inbuf);
 313 
 314 static GstElementClass *parent_class = NULL;
 315 
 316 static void gst_audio_decoder_class_init (GstAudioDecoderClass * klass);
 317 static void gst_audio_decoder_init (GstAudioDecoder * dec,
 318     GstAudioDecoderClass * klass);
 319 
 320 GType
 321 gst_audio_decoder_get_type (void)
 322 {
 323   static volatile gsize audio_decoder_type = 0;
 324 
 325   if (g_once_init_enter (&amp;audio_decoder_type)) {
 326     GType _type;
 327     static const GTypeInfo audio_decoder_info = {
 328       sizeof (GstAudioDecoderClass),
 329       NULL,
 330       NULL,
 331       (GClassInitFunc) gst_audio_decoder_class_init,
 332       NULL,
 333       NULL,
 334       sizeof (GstAudioDecoder),
 335       0,
 336       (GInstanceInitFunc) gst_audio_decoder_init,
 337     };
 338 
 339     _type = g_type_register_static (GST_TYPE_ELEMENT,
 340         &quot;GstAudioDecoder&quot;, &amp;audio_decoder_info, G_TYPE_FLAG_ABSTRACT);
 341     g_once_init_leave (&amp;audio_decoder_type, _type);
 342   }
 343   return audio_decoder_type;
 344 }
 345 
 346 
 347 static void
 348 gst_audio_decoder_class_init (GstAudioDecoderClass * klass)
 349 {
 350   GObjectClass *gobject_class;
 351   GstElementClass *element_class;
 352   GstAudioDecoderClass *audiodecoder_class;
 353 
 354   gobject_class = G_OBJECT_CLASS (klass);
 355   element_class = GST_ELEMENT_CLASS (klass);
 356   audiodecoder_class = GST_AUDIO_DECODER_CLASS (klass);
 357 
 358   parent_class = g_type_class_peek_parent (klass);
 359 
 360   g_type_class_add_private (klass, sizeof (GstAudioDecoderPrivate));
 361 
 362   GST_DEBUG_CATEGORY_INIT (audiodecoder_debug, &quot;audiodecoder&quot;, 0,
 363       &quot;audio decoder base class&quot;);
 364 
 365   gobject_class-&gt;set_property = gst_audio_decoder_set_property;
 366   gobject_class-&gt;get_property = gst_audio_decoder_get_property;
 367   gobject_class-&gt;finalize = gst_audio_decoder_finalize;
 368 
 369   element_class-&gt;change_state =
 370       GST_DEBUG_FUNCPTR (gst_audio_decoder_change_state);
 371 
 372   /* Properties */
 373   g_object_class_install_property (gobject_class, PROP_LATENCY,
 374       g_param_spec_int64 (&quot;min-latency&quot;, &quot;Minimum Latency&quot;,
 375           &quot;Aggregate output data to a minimum of latency time (ns)&quot;,
 376           0, G_MAXINT64, DEFAULT_LATENCY,
 377           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 378 
 379   g_object_class_install_property (gobject_class, PROP_TOLERANCE,
 380       g_param_spec_int64 (&quot;tolerance&quot;, &quot;Tolerance&quot;,
 381           &quot;Perfect ts while timestamp jitter/imperfection within tolerance (ns)&quot;,
 382           0, G_MAXINT64, DEFAULT_TOLERANCE,
 383           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 384 
 385   g_object_class_install_property (gobject_class, PROP_PLC,
 386       g_param_spec_boolean (&quot;plc&quot;, &quot;Packet Loss Concealment&quot;,
 387           &quot;Perform packet loss concealment (if supported)&quot;,
 388           DEFAULT_PLC, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 389 
 390   audiodecoder_class-&gt;sink_event =
 391       GST_DEBUG_FUNCPTR (gst_audio_decoder_sink_eventfunc);
 392   audiodecoder_class-&gt;src_event =
 393       GST_DEBUG_FUNCPTR (gst_audio_decoder_src_eventfunc);
 394   audiodecoder_class-&gt;propose_allocation =
 395       GST_DEBUG_FUNCPTR (gst_audio_decoder_propose_allocation_default);
 396   audiodecoder_class-&gt;decide_allocation =
 397       GST_DEBUG_FUNCPTR (gst_audio_decoder_decide_allocation_default);
 398   audiodecoder_class-&gt;negotiate =
 399       GST_DEBUG_FUNCPTR (gst_audio_decoder_negotiate_default);
 400   audiodecoder_class-&gt;sink_query =
 401       GST_DEBUG_FUNCPTR (gst_audio_decoder_sink_query_default);
 402   audiodecoder_class-&gt;src_query =
 403       GST_DEBUG_FUNCPTR (gst_audio_decoder_src_query_default);
 404   audiodecoder_class-&gt;transform_meta =
 405       GST_DEBUG_FUNCPTR (gst_audio_decoder_transform_meta_default);
 406 }
 407 
 408 static void
 409 gst_audio_decoder_init (GstAudioDecoder * dec, GstAudioDecoderClass * klass)
 410 {
 411   GstPadTemplate *pad_template;
 412 
 413   GST_DEBUG_OBJECT (dec, &quot;gst_audio_decoder_init&quot;);
 414 
 415   dec-&gt;priv = GST_AUDIO_DECODER_GET_PRIVATE (dec);
 416 
 417   /* Setup sink pad */
 418   pad_template =
 419       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (klass), &quot;sink&quot;);
 420   g_return_if_fail (pad_template != NULL);
 421 
 422   dec-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 423   gst_pad_set_event_function (dec-&gt;sinkpad,
 424       GST_DEBUG_FUNCPTR (gst_audio_decoder_sink_event));
 425   gst_pad_set_chain_function (dec-&gt;sinkpad,
 426       GST_DEBUG_FUNCPTR (gst_audio_decoder_chain));
 427   gst_pad_set_query_function (dec-&gt;sinkpad,
 428       GST_DEBUG_FUNCPTR (gst_audio_decoder_sink_query));
 429   gst_element_add_pad (GST_ELEMENT (dec), dec-&gt;sinkpad);
 430   GST_DEBUG_OBJECT (dec, &quot;sinkpad created&quot;);
 431 
 432   /* Setup source pad */
 433   pad_template =
 434       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (klass), &quot;src&quot;);
 435   g_return_if_fail (pad_template != NULL);
 436 
 437   dec-&gt;srcpad = gst_pad_new_from_template (pad_template, &quot;src&quot;);
 438   gst_pad_set_event_function (dec-&gt;srcpad,
 439       GST_DEBUG_FUNCPTR (gst_audio_decoder_src_event));
 440   gst_pad_set_query_function (dec-&gt;srcpad,
 441       GST_DEBUG_FUNCPTR (gst_audio_decoder_src_query));
 442   gst_element_add_pad (GST_ELEMENT (dec), dec-&gt;srcpad);
 443   GST_DEBUG_OBJECT (dec, &quot;srcpad created&quot;);
 444 
 445   dec-&gt;priv-&gt;adapter = gst_adapter_new ();
 446   dec-&gt;priv-&gt;adapter_out = gst_adapter_new ();
 447   g_queue_init (&amp;dec-&gt;priv-&gt;frames);
 448 
 449   g_rec_mutex_init (&amp;dec-&gt;stream_lock);
 450 
 451   /* property default */
 452   dec-&gt;priv-&gt;latency = DEFAULT_LATENCY;
 453   dec-&gt;priv-&gt;tolerance = DEFAULT_TOLERANCE;
 454   dec-&gt;priv-&gt;plc = DEFAULT_PLC;
 455   dec-&gt;priv-&gt;drainable = DEFAULT_DRAINABLE;
 456   dec-&gt;priv-&gt;needs_format = DEFAULT_NEEDS_FORMAT;
 457 
 458   /* init state */
 459   dec-&gt;priv-&gt;ctx.min_latency = 0;
 460   dec-&gt;priv-&gt;ctx.max_latency = 0;
 461   gst_audio_decoder_reset (dec, TRUE);
 462   GST_DEBUG_OBJECT (dec, &quot;init ok&quot;);
 463 }
 464 
 465 static void
 466 gst_audio_decoder_reset (GstAudioDecoder * dec, gboolean full)
 467 {
 468   GST_DEBUG_OBJECT (dec, &quot;gst_audio_decoder_reset&quot;);
 469 
 470   GST_AUDIO_DECODER_STREAM_LOCK (dec);
 471 
 472   if (full) {
 473     dec-&gt;priv-&gt;active = FALSE;
 474     GST_OBJECT_LOCK (dec);
 475     dec-&gt;priv-&gt;bytes_in = 0;
 476     dec-&gt;priv-&gt;samples_out = 0;
 477     GST_OBJECT_UNLOCK (dec);
 478     dec-&gt;priv-&gt;agg = -1;
 479     dec-&gt;priv-&gt;error_count = 0;
 480     gst_audio_decoder_clear_queues (dec);
 481 
 482     if (dec-&gt;priv-&gt;taglist) {
 483       gst_tag_list_unref (dec-&gt;priv-&gt;taglist);
 484       dec-&gt;priv-&gt;taglist = NULL;
 485     }
 486     dec-&gt;priv-&gt;decoder_tags_merge_mode = GST_TAG_MERGE_KEEP_ALL;
 487     if (dec-&gt;priv-&gt;upstream_tags) {
 488       gst_tag_list_unref (dec-&gt;priv-&gt;upstream_tags);
 489       dec-&gt;priv-&gt;upstream_tags = NULL;
 490     }
 491     dec-&gt;priv-&gt;taglist_changed = FALSE;
 492 
 493     gst_segment_init (&amp;dec-&gt;input_segment, GST_FORMAT_TIME);
 494     gst_segment_init (&amp;dec-&gt;output_segment, GST_FORMAT_TIME);
 495     dec-&gt;priv-&gt;in_out_segment_sync = TRUE;
 496 
 497     g_list_foreach (dec-&gt;priv-&gt;pending_events, (GFunc) gst_event_unref, NULL);
 498     g_list_free (dec-&gt;priv-&gt;pending_events);
 499     dec-&gt;priv-&gt;pending_events = NULL;
 500 
 501     if (dec-&gt;priv-&gt;ctx.allocator)
 502       gst_object_unref (dec-&gt;priv-&gt;ctx.allocator);
 503 
 504     GST_OBJECT_LOCK (dec);
 505     gst_caps_replace (&amp;dec-&gt;priv-&gt;ctx.input_caps, NULL);
 506     gst_caps_replace (&amp;dec-&gt;priv-&gt;ctx.allocation_caps, NULL);
 507 
 508     memset (&amp;dec-&gt;priv-&gt;ctx, 0, sizeof (dec-&gt;priv-&gt;ctx));
 509 
 510     gst_audio_info_init (&amp;dec-&gt;priv-&gt;ctx.info);
 511     GST_OBJECT_UNLOCK (dec);
 512     dec-&gt;priv-&gt;ctx.max_errors = GST_AUDIO_DECODER_MAX_ERRORS;
 513     dec-&gt;priv-&gt;ctx.had_output_data = FALSE;
 514     dec-&gt;priv-&gt;ctx.had_input_data = FALSE;
 515   }
 516 
 517   g_queue_foreach (&amp;dec-&gt;priv-&gt;frames, (GFunc) gst_buffer_unref, NULL);
 518   g_queue_clear (&amp;dec-&gt;priv-&gt;frames);
 519   gst_adapter_clear (dec-&gt;priv-&gt;adapter);
 520   gst_adapter_clear (dec-&gt;priv-&gt;adapter_out);
 521   dec-&gt;priv-&gt;out_ts = GST_CLOCK_TIME_NONE;
 522   dec-&gt;priv-&gt;out_dur = 0;
 523   dec-&gt;priv-&gt;prev_ts = GST_CLOCK_TIME_NONE;
 524   dec-&gt;priv-&gt;prev_distance = 0;
 525   dec-&gt;priv-&gt;drained = TRUE;
 526   dec-&gt;priv-&gt;base_ts = GST_CLOCK_TIME_NONE;
 527   dec-&gt;priv-&gt;samples = 0;
 528   dec-&gt;priv-&gt;discont = TRUE;
 529   dec-&gt;priv-&gt;sync_flush = FALSE;
 530 
 531   GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
 532 }
 533 
 534 static void
 535 gst_audio_decoder_finalize (GObject * object)
 536 {
 537   GstAudioDecoder *dec;
 538 
 539   g_return_if_fail (GST_IS_AUDIO_DECODER (object));
 540   dec = GST_AUDIO_DECODER (object);
 541 
 542   if (dec-&gt;priv-&gt;adapter) {
 543     g_object_unref (dec-&gt;priv-&gt;adapter);
 544   }
 545   if (dec-&gt;priv-&gt;adapter_out) {
 546     g_object_unref (dec-&gt;priv-&gt;adapter_out);
 547   }
 548 
 549   g_rec_mutex_clear (&amp;dec-&gt;stream_lock);
 550 
 551   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 552 }
 553 
 554 static GstEvent *
 555 gst_audio_decoder_create_merged_tags_event (GstAudioDecoder * dec)
 556 {
 557   GstTagList *merged_tags;
 558 
 559   GST_LOG_OBJECT (dec, &quot;upstream : %&quot; GST_PTR_FORMAT, dec-&gt;priv-&gt;upstream_tags);
 560   GST_LOG_OBJECT (dec, &quot;decoder  : %&quot; GST_PTR_FORMAT, dec-&gt;priv-&gt;taglist);
 561   GST_LOG_OBJECT (dec, &quot;mode     : %d&quot;, dec-&gt;priv-&gt;decoder_tags_merge_mode);
 562 
 563   merged_tags =
 564       gst_tag_list_merge (dec-&gt;priv-&gt;upstream_tags,
 565       dec-&gt;priv-&gt;taglist, dec-&gt;priv-&gt;decoder_tags_merge_mode);
 566 
 567   GST_DEBUG_OBJECT (dec, &quot;merged   : %&quot; GST_PTR_FORMAT, merged_tags);
 568 
 569   if (merged_tags == NULL)
 570     return NULL;
 571 
 572   if (gst_tag_list_is_empty (merged_tags)) {
 573     gst_tag_list_unref (merged_tags);
 574     return NULL;
 575   }
 576 
 577   return gst_event_new_tag (merged_tags);
 578 }
 579 
 580 static gboolean
 581 gst_audio_decoder_push_event (GstAudioDecoder * dec, GstEvent * event)
 582 {
 583   switch (GST_EVENT_TYPE (event)) {
 584     case GST_EVENT_SEGMENT:{
 585       GstSegment seg;
 586 
 587       GST_AUDIO_DECODER_STREAM_LOCK (dec);
 588       gst_event_copy_segment (event, &amp;seg);
 589 
 590       GST_DEBUG_OBJECT (dec, &quot;starting segment %&quot; GST_SEGMENT_FORMAT, &amp;seg);
 591 
 592       dec-&gt;output_segment = seg;
 593       dec-&gt;priv-&gt;in_out_segment_sync =
 594           gst_segment_is_equal (&amp;dec-&gt;input_segment, &amp;seg);
 595       GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
 596       break;
 597     }
 598     default:
 599       break;
 600   }
 601 
 602   return gst_pad_push_event (dec-&gt;srcpad, event);
 603 }
 604 
 605 static gboolean
 606 gst_audio_decoder_negotiate_default (GstAudioDecoder * dec)
 607 {
 608   GstAudioDecoderClass *klass;
 609   gboolean res = TRUE;
 610   GstCaps *caps;
 611   GstCaps *prevcaps;
 612   GstQuery *query = NULL;
 613   GstAllocator *allocator;
 614   GstAllocationParams params;
 615 
 616   g_return_val_if_fail (GST_IS_AUDIO_DECODER (dec), FALSE);
 617   g_return_val_if_fail (GST_AUDIO_INFO_IS_VALID (&amp;dec-&gt;priv-&gt;ctx.info), FALSE);
 618 
 619   klass = GST_AUDIO_DECODER_GET_CLASS (dec);
 620 
 621   caps = gst_audio_info_to_caps (&amp;dec-&gt;priv-&gt;ctx.info);
 622   if (dec-&gt;priv-&gt;ctx.allocation_caps == NULL)
 623     dec-&gt;priv-&gt;ctx.allocation_caps = gst_caps_ref (caps);
 624 
 625   GST_DEBUG_OBJECT (dec, &quot;setting src caps %&quot; GST_PTR_FORMAT, caps);
 626 
 627   if (dec-&gt;priv-&gt;pending_events) {
 628     GList **pending_events, *l;
 629 
 630     pending_events = &amp;dec-&gt;priv-&gt;pending_events;
 631 
 632     GST_DEBUG_OBJECT (dec, &quot;Pushing pending events&quot;);
 633     for (l = *pending_events; l;) {
 634       GstEvent *event = GST_EVENT (l-&gt;data);
 635       GList *tmp;
 636 
 637       if (GST_EVENT_TYPE (event) &lt; GST_EVENT_CAPS) {
 638         gst_audio_decoder_push_event (dec, l-&gt;data);
 639         tmp = l;
 640         l = l-&gt;next;
 641         *pending_events = g_list_delete_link (*pending_events, tmp);
 642       } else {
 643         l = l-&gt;next;
 644       }
 645     }
 646   }
 647 
 648   prevcaps = gst_pad_get_current_caps (dec-&gt;srcpad);
 649   if (!prevcaps || !gst_caps_is_equal (prevcaps, caps))
 650     res = gst_pad_set_caps (dec-&gt;srcpad, caps);
 651   if (prevcaps)
 652     gst_caps_unref (prevcaps);
 653 
 654   if (!res)
 655     goto done;
 656   dec-&gt;priv-&gt;ctx.output_format_changed = FALSE;
 657 
 658   query = gst_query_new_allocation (dec-&gt;priv-&gt;ctx.allocation_caps, TRUE);
 659   if (!gst_pad_peer_query (dec-&gt;srcpad, query)) {
 660     GST_DEBUG_OBJECT (dec, &quot;didn&#39;t get downstream ALLOCATION hints&quot;);
 661   }
 662 
 663   g_assert (klass-&gt;decide_allocation != NULL);
 664   res = klass-&gt;decide_allocation (dec, query);
 665 
 666   GST_DEBUG_OBJECT (dec, &quot;ALLOCATION (%d) params: %&quot; GST_PTR_FORMAT, res,
 667       query);
 668 
 669   if (!res)
 670     goto no_decide_allocation;
 671 
 672   /* we got configuration from our peer or the decide_allocation method,
 673    * parse them */
 674   if (gst_query_get_n_allocation_params (query) &gt; 0) {
 675     gst_query_parse_nth_allocation_param (query, 0, &amp;allocator, &amp;params);
 676   } else {
 677     allocator = NULL;
 678     gst_allocation_params_init (&amp;params);
 679   }
 680 
 681   if (dec-&gt;priv-&gt;ctx.allocator)
 682     gst_object_unref (dec-&gt;priv-&gt;ctx.allocator);
 683   dec-&gt;priv-&gt;ctx.allocator = allocator;
 684   dec-&gt;priv-&gt;ctx.params = params;
 685 
 686 done:
 687 
 688   if (query)
 689     gst_query_unref (query);
 690   gst_caps_unref (caps);
 691 
 692   return res;
 693 
 694   /* ERRORS */
 695 no_decide_allocation:
 696   {
 697     GST_WARNING_OBJECT (dec, &quot;Subclass failed to decide allocation&quot;);
 698     goto done;
 699   }
 700 }
 701 
 702 static gboolean
 703 gst_audio_decoder_negotiate_unlocked (GstAudioDecoder * dec)
 704 {
 705   GstAudioDecoderClass *klass = GST_AUDIO_DECODER_GET_CLASS (dec);
 706   gboolean ret = TRUE;
 707 
 708   if (G_LIKELY (klass-&gt;negotiate))
 709     ret = klass-&gt;negotiate (dec);
 710 
 711   return ret;
 712 }
 713 
 714 /**
 715  * gst_audio_decoder_negotiate:
 716  * @dec: a #GstAudioDecoder
 717  *
 718  * Negotiate with downstream elements to currently configured #GstAudioInfo.
 719  * Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it again if
 720  * negotiate fails.
 721  *
 722  * Returns: %TRUE if the negotiation succeeded, else %FALSE.
 723  */
 724 gboolean
 725 gst_audio_decoder_negotiate (GstAudioDecoder * dec)
 726 {
 727   GstAudioDecoderClass *klass;
 728   gboolean res = TRUE;
 729 
 730   g_return_val_if_fail (GST_IS_AUDIO_DECODER (dec), FALSE);
 731 
 732   klass = GST_AUDIO_DECODER_GET_CLASS (dec);
 733 
 734   GST_AUDIO_DECODER_STREAM_LOCK (dec);
 735   gst_pad_check_reconfigure (dec-&gt;srcpad);
 736   if (klass-&gt;negotiate) {
 737     res = klass-&gt;negotiate (dec);
 738     if (!res)
 739       gst_pad_mark_reconfigure (dec-&gt;srcpad);
 740   }
 741   GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
 742 
 743   return res;
 744 }
 745 
 746 /**
 747  * gst_audio_decoder_set_output_format:
 748  * @dec: a #GstAudioDecoder
 749  * @info: #GstAudioInfo
 750  *
 751  * Configure output info on the srcpad of @dec.
 752  *
 753  * Returns: %TRUE on success.
 754  **/
 755 gboolean
 756 gst_audio_decoder_set_output_format (GstAudioDecoder * dec,
 757     const GstAudioInfo * info)
 758 {
 759   gboolean res = TRUE;
 760   guint old_rate;
 761   GstCaps *caps = NULL;
 762   GstCaps *templ_caps;
 763 
 764   g_return_val_if_fail (GST_IS_AUDIO_DECODER (dec), FALSE);
 765   g_return_val_if_fail (GST_AUDIO_INFO_IS_VALID (info), FALSE);
 766 
 767   GST_DEBUG_OBJECT (dec, &quot;Setting output format&quot;);
 768 
 769   GST_AUDIO_DECODER_STREAM_LOCK (dec);
 770 
 771   /* If the audio info can&#39;t be converted to caps,
 772    * it was invalid */
 773   caps = gst_audio_info_to_caps (info);
 774   if (!caps)
 775     goto refuse_caps;
 776 
 777   /* Only allow caps that are a subset of the template caps */
 778   templ_caps = gst_pad_get_pad_template_caps (dec-&gt;srcpad);
 779   if (!gst_caps_is_subset (caps, templ_caps)) {
 780     GST_WARNING_OBJECT (dec, &quot;Requested output format %&quot; GST_PTR_FORMAT
 781         &quot; do not match template %&quot; GST_PTR_FORMAT, caps, templ_caps);
 782     gst_caps_unref (templ_caps);
 783     goto refuse_caps;
 784   }
 785   gst_caps_unref (templ_caps);
 786 
 787   /* adjust ts tracking to new sample rate */
 788   old_rate = GST_AUDIO_INFO_RATE (&amp;dec-&gt;priv-&gt;ctx.info);
 789   if (GST_CLOCK_TIME_IS_VALID (dec-&gt;priv-&gt;base_ts) &amp;&amp; old_rate) {
 790     dec-&gt;priv-&gt;base_ts +=
 791         GST_FRAMES_TO_CLOCK_TIME (dec-&gt;priv-&gt;samples, old_rate);
 792     dec-&gt;priv-&gt;samples = 0;
 793   }
 794 
 795   /* copy the GstAudioInfo */
 796   GST_OBJECT_LOCK (dec);
 797   dec-&gt;priv-&gt;ctx.info = *info;
 798   GST_OBJECT_UNLOCK (dec);
 799   dec-&gt;priv-&gt;ctx.output_format_changed = TRUE;
 800 
 801 done:
 802   GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
 803 
 804   if (caps)
 805     gst_caps_unref (caps);
 806 
 807   return res;
 808 
 809   /* ERRORS */
 810 refuse_caps:
 811   {
 812     GST_WARNING_OBJECT (dec, &quot;invalid output format&quot;);
 813     res = FALSE;
 814     goto done;
 815   }
 816 }
 817 
 818 static gboolean
 819 gst_audio_decoder_sink_setcaps (GstAudioDecoder * dec, GstCaps * caps)
 820 {
 821   GstAudioDecoderClass *klass;
 822   gboolean res = TRUE;
 823 
 824   klass = GST_AUDIO_DECODER_GET_CLASS (dec);
 825 
 826   GST_DEBUG_OBJECT (dec, &quot;caps: %&quot; GST_PTR_FORMAT, caps);
 827 
 828   GST_AUDIO_DECODER_STREAM_LOCK (dec);
 829 
 830   if (dec-&gt;priv-&gt;ctx.input_caps
 831       &amp;&amp; gst_caps_is_equal (dec-&gt;priv-&gt;ctx.input_caps, caps)) {
 832     GST_DEBUG_OBJECT (dec, &quot;Caps did not change, not setting again&quot;);
 833     goto done;
 834   }
 835 
 836   /* NOTE pbutils only needed here */
 837   /* TODO maybe (only) upstream demuxer/parser etc should handle this ? */
 838 #if 0
 839   if (!dec-&gt;priv-&gt;taglist)
 840     dec-&gt;priv-&gt;taglist = gst_tag_list_new ();
 841   dec-&gt;priv-&gt;taglist = gst_tag_list_make_writable (dec-&gt;priv-&gt;taglist);
 842   gst_pb_utils_add_codec_description_to_tag_list (dec-&gt;priv-&gt;taglist,
 843       GST_TAG_AUDIO_CODEC, caps);
 844   dec-&gt;priv-&gt;taglist_changed = TRUE;
 845 #endif
 846 
 847   if (klass-&gt;set_format)
 848     res = klass-&gt;set_format (dec, caps);
 849 
 850   if (res)
 851     gst_caps_replace (&amp;dec-&gt;priv-&gt;ctx.input_caps, caps);
 852 
 853 done:
 854   GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
 855 
 856   return res;
 857 }
 858 
 859 static void
 860 gst_audio_decoder_setup (GstAudioDecoder * dec)
 861 {
 862   GstQuery *query;
 863   gboolean res;
 864 
 865   /* check if in live pipeline, then latency messing is no-no */
 866   query = gst_query_new_latency ();
 867   res = gst_pad_peer_query (dec-&gt;sinkpad, query);
 868   if (res) {
 869     gst_query_parse_latency (query, &amp;res, NULL, NULL);
 870     res = !res;
 871   }
 872   gst_query_unref (query);
 873 
 874   /* normalize to bool */
 875   dec-&gt;priv-&gt;agg = ! !res;
 876 }
 877 
 878 static GstFlowReturn
 879 gst_audio_decoder_push_forward (GstAudioDecoder * dec, GstBuffer * buf)
 880 {
 881   GstAudioDecoderClass *klass;
 882   GstAudioDecoderPrivate *priv;
 883   GstAudioDecoderContext *ctx;
 884   GstFlowReturn ret = GST_FLOW_OK;
 885   GstClockTime ts;
 886 
 887   klass = GST_AUDIO_DECODER_GET_CLASS (dec);
 888   priv = dec-&gt;priv;
 889   ctx = &amp;dec-&gt;priv-&gt;ctx;
 890 
 891   g_return_val_if_fail (ctx-&gt;info.bpf != 0, GST_FLOW_ERROR);
 892 
 893   if (G_UNLIKELY (!buf)) {
 894     g_assert_not_reached ();
 895     return GST_FLOW_OK;
 896   }
 897 
 898   ctx-&gt;had_output_data = TRUE;
 899   ts = GST_BUFFER_TIMESTAMP (buf);
 900 
 901   GST_LOG_OBJECT (dec,
 902       &quot;clipping buffer of size %&quot; G_GSIZE_FORMAT &quot; with ts %&quot; GST_TIME_FORMAT
 903       &quot;, duration %&quot; GST_TIME_FORMAT, gst_buffer_get_size (buf),
 904       GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
 905       GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
 906 
 907   /* clip buffer */
 908   buf = gst_audio_buffer_clip (buf, &amp;dec-&gt;output_segment, ctx-&gt;info.rate,
 909       ctx-&gt;info.bpf);
 910   if (G_UNLIKELY (!buf)) {
 911     GST_DEBUG_OBJECT (dec, &quot;no data after clipping to segment&quot;);
 912     /* only check and return EOS if upstream still
 913      * in the same segment and interested as such */
 914     if (dec-&gt;priv-&gt;in_out_segment_sync) {
 915     if (dec-&gt;output_segment.rate &gt;= 0) {
 916       if (ts &gt;= dec-&gt;output_segment.stop)
 917         ret = GST_FLOW_EOS;
 918     } else if (ts &lt; dec-&gt;output_segment.start) {
 919       ret = GST_FLOW_EOS;
 920     }
 921     }
 922     goto exit;
 923   }
 924 
 925   /* decorate */
 926   if (G_UNLIKELY (priv-&gt;discont)) {
 927     GST_LOG_OBJECT (dec, &quot;marking discont&quot;);
 928     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);
 929     priv-&gt;discont = FALSE;
 930   }
 931 
 932   /* track where we are */
 933   if (G_LIKELY (GST_BUFFER_TIMESTAMP_IS_VALID (buf))) {
 934     /* duration should always be valid for raw audio */
 935     g_assert (GST_BUFFER_DURATION_IS_VALID (buf));
 936     dec-&gt;output_segment.position =
 937         GST_BUFFER_TIMESTAMP (buf) + GST_BUFFER_DURATION (buf);
 938   }
 939 
 940   if (klass-&gt;pre_push) {
 941     /* last chance for subclass to do some dirty stuff */
 942     ret = klass-&gt;pre_push (dec, &amp;buf);
 943     if (ret != GST_FLOW_OK || !buf) {
 944       GST_DEBUG_OBJECT (dec, &quot;subclass returned %s, buf %p&quot;,
 945           gst_flow_get_name (ret), buf);
 946       if (buf)
 947         gst_buffer_unref (buf);
 948       goto exit;
 949     }
 950   }
 951 
 952   GST_LOG_OBJECT (dec,
 953       &quot;pushing buffer of size %&quot; G_GSIZE_FORMAT &quot; with ts %&quot; GST_TIME_FORMAT
 954       &quot;, duration %&quot; GST_TIME_FORMAT, gst_buffer_get_size (buf),
 955       GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
 956       GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
 957 
 958   ret = gst_pad_push (dec-&gt;srcpad, buf);
 959 
 960 exit:
 961   return ret;
 962 }
 963 
 964 /* mini aggregator combining output buffers into fewer larger ones,
 965  * if so allowed/configured */
 966 static GstFlowReturn
 967 gst_audio_decoder_output (GstAudioDecoder * dec, GstBuffer * buf)
 968 {
 969   GstAudioDecoderPrivate *priv;
 970   GstFlowReturn ret = GST_FLOW_OK;
 971   GstBuffer *inbuf = NULL;
 972 
 973   priv = dec-&gt;priv;
 974 
 975   if (G_UNLIKELY (priv-&gt;agg &lt; 0))
 976     gst_audio_decoder_setup (dec);
 977 
 978   if (G_LIKELY (buf)) {
 979     GST_LOG_OBJECT (dec,
 980         &quot;output buffer of size %&quot; G_GSIZE_FORMAT &quot; with ts %&quot; GST_TIME_FORMAT
 981         &quot;, duration %&quot; GST_TIME_FORMAT, gst_buffer_get_size (buf),
 982         GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
 983         GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
 984   }
 985 
 986 again:
 987   inbuf = NULL;
 988   if (priv-&gt;agg &amp;&amp; dec-&gt;priv-&gt;latency &gt; 0) {
 989     gint av;
 990     gboolean assemble = FALSE;
 991     const GstClockTimeDiff tol = 10 * GST_MSECOND;
 992     GstClockTimeDiff diff = -100 * GST_MSECOND;
 993 
 994     av = gst_adapter_available (priv-&gt;adapter_out);
 995     if (G_UNLIKELY (!buf)) {
 996       /* forcibly send current */
 997       assemble = TRUE;
 998       GST_LOG_OBJECT (dec, &quot;forcing fragment flush&quot;);
 999     } else if (av &amp;&amp; (!GST_BUFFER_TIMESTAMP_IS_VALID (buf) ||
1000             !GST_CLOCK_TIME_IS_VALID (priv-&gt;out_ts) ||
1001             ((diff = GST_CLOCK_DIFF (GST_BUFFER_TIMESTAMP (buf),
1002                         priv-&gt;out_ts + priv-&gt;out_dur)) &gt; tol) || diff &lt; -tol)) {
1003       assemble = TRUE;
1004       GST_LOG_OBJECT (dec, &quot;buffer %d ms apart from current fragment&quot;,
1005           (gint) (diff / GST_MSECOND));
1006     } else {
1007       /* add or start collecting */
1008       if (!av) {
1009         GST_LOG_OBJECT (dec, &quot;starting new fragment&quot;);
1010         priv-&gt;out_ts = GST_BUFFER_TIMESTAMP (buf);
1011       } else {
1012         GST_LOG_OBJECT (dec, &quot;adding to fragment&quot;);
1013       }
1014       gst_adapter_push (priv-&gt;adapter_out, buf);
1015       priv-&gt;out_dur += GST_BUFFER_DURATION (buf);
1016       av += gst_buffer_get_size (buf);
1017       buf = NULL;
1018     }
1019     if (priv-&gt;out_dur &gt; dec-&gt;priv-&gt;latency)
1020       assemble = TRUE;
1021     if (av &amp;&amp; assemble) {
1022       GST_LOG_OBJECT (dec, &quot;assembling fragment&quot;);
1023       inbuf = buf;
1024       buf = gst_adapter_take_buffer (priv-&gt;adapter_out, av);
1025       GST_BUFFER_TIMESTAMP (buf) = priv-&gt;out_ts;
1026       GST_BUFFER_DURATION (buf) = priv-&gt;out_dur;
1027       priv-&gt;out_ts = GST_CLOCK_TIME_NONE;
1028       priv-&gt;out_dur = 0;
1029     }
1030   }
1031 
1032   if (G_LIKELY (buf)) {
1033     if (dec-&gt;output_segment.rate &gt; 0.0) {
1034       ret = gst_audio_decoder_push_forward (dec, buf);
1035       GST_LOG_OBJECT (dec, &quot;buffer pushed: %s&quot;, gst_flow_get_name (ret));
1036     } else {
1037       ret = GST_FLOW_OK;
1038       priv-&gt;queued = g_list_prepend (priv-&gt;queued, buf);
1039       GST_LOG_OBJECT (dec, &quot;buffer queued&quot;);
1040     }
1041 
1042     if (inbuf) {
1043       buf = inbuf;
1044       goto again;
1045     }
1046   }
1047 
1048   return ret;
1049 }
1050 
1051 static void
1052 send_pending_events (GstAudioDecoder * dec)
1053 {
1054   GstAudioDecoderPrivate *priv = dec-&gt;priv;
1055   GList *pending_events, *l;
1056 
1057   pending_events = priv-&gt;pending_events;
1058   priv-&gt;pending_events = NULL;
1059 
1060   GST_DEBUG_OBJECT (dec, &quot;Pushing pending events&quot;);
1061   for (l = pending_events; l; l = l-&gt;next)
1062     gst_audio_decoder_push_event (dec, l-&gt;data);
1063   g_list_free (pending_events);
1064 }
1065 
1066 /* Iterate the list of pending events, and ensure
1067  * the current output segment is up to date for
1068  * decoding */
1069 static void
1070 apply_pending_events (GstAudioDecoder * dec)
1071 {
1072   GstAudioDecoderPrivate *priv = dec-&gt;priv;
1073   GList *l;
1074 
1075   GST_DEBUG_OBJECT (dec, &quot;Applying pending segments&quot;);
1076   for (l = priv-&gt;pending_events; l; l = l-&gt;next) {
1077     GstEvent *event = GST_EVENT (l-&gt;data);
1078     switch (GST_EVENT_TYPE (event)) {
1079       case GST_EVENT_SEGMENT:{
1080         GstSegment seg;
1081 
1082         GST_AUDIO_DECODER_STREAM_LOCK (dec);
1083         gst_event_copy_segment (event, &amp;seg);
1084 
1085         GST_DEBUG_OBJECT (dec, &quot;starting segment %&quot; GST_SEGMENT_FORMAT, &amp;seg);
1086 
1087         dec-&gt;output_segment = seg;
1088         dec-&gt;priv-&gt;in_out_segment_sync =
1089             gst_segment_is_equal (&amp;dec-&gt;input_segment, &amp;seg);
1090         GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
1091         break;
1092       }
1093       default:
1094         break;
1095     }
1096   }
1097 }
1098 
1099 static GstFlowReturn
1100 check_pending_reconfigure (GstAudioDecoder * dec)
1101 {
1102   GstFlowReturn ret = GST_FLOW_OK;
1103   GstAudioDecoderContext *ctx;
1104   gboolean needs_reconfigure;
1105 
1106   ctx = &amp;dec-&gt;priv-&gt;ctx;
1107 
1108   needs_reconfigure = gst_pad_check_reconfigure (dec-&gt;srcpad);
1109   if (G_UNLIKELY (ctx-&gt;output_format_changed ||
1110           (GST_AUDIO_INFO_IS_VALID (&amp;ctx-&gt;info)
1111               &amp;&amp; needs_reconfigure))) {
1112     if (!gst_audio_decoder_negotiate_unlocked (dec)) {
1113       gst_pad_mark_reconfigure (dec-&gt;srcpad);
1114       if (GST_PAD_IS_FLUSHING (dec-&gt;srcpad))
1115         ret = GST_FLOW_FLUSHING;
1116       else
1117         ret = GST_FLOW_NOT_NEGOTIATED;
1118     }
1119   }
1120   return ret;
1121 }
1122 
1123 static gboolean
1124 gst_audio_decoder_transform_meta_default (GstAudioDecoder *
1125     decoder, GstBuffer * outbuf, GstMeta * meta, GstBuffer * inbuf)
1126 {
1127   const GstMetaInfo *info = meta-&gt;info;
1128   const gchar *const *tags;
1129 
1130   tags = gst_meta_api_type_get_tags (info-&gt;api);
1131 
1132   if (!tags || (g_strv_length ((gchar **) tags) == 1
1133           &amp;&amp; gst_meta_api_type_has_tag (info-&gt;api,
1134               g_quark_from_string (GST_META_TAG_AUDIO_STR))))
1135     return TRUE;
1136 
1137   return FALSE;
1138 }
1139 
1140 typedef struct
1141 {
1142   GstAudioDecoder *decoder;
1143   GstBuffer *outbuf;
1144 } CopyMetaData;
1145 
1146 static gboolean
1147 foreach_metadata (GstBuffer * inbuf, GstMeta ** meta, gpointer user_data)
1148 {
1149   CopyMetaData *data = user_data;
1150   GstAudioDecoder *decoder = data-&gt;decoder;
1151   GstAudioDecoderClass *klass = GST_AUDIO_DECODER_GET_CLASS (decoder);
1152   GstBuffer *outbuf = data-&gt;outbuf;
1153   const GstMetaInfo *info = (*meta)-&gt;info;
1154   gboolean do_copy = FALSE;
1155 
1156   if (gst_meta_api_type_has_tag (info-&gt;api, _gst_meta_tag_memory)) {
1157     /* never call the transform_meta with memory specific metadata */
1158     GST_DEBUG_OBJECT (decoder, &quot;not copying memory specific metadata %s&quot;,
1159         g_type_name (info-&gt;api));
1160     do_copy = FALSE;
1161   } else if (klass-&gt;transform_meta) {
1162     do_copy = klass-&gt;transform_meta (decoder, outbuf, *meta, inbuf);
1163     GST_DEBUG_OBJECT (decoder, &quot;transformed metadata %s: copy: %d&quot;,
1164         g_type_name (info-&gt;api), do_copy);
1165   }
1166 
1167   /* we only copy metadata when the subclass implemented a transform_meta
1168    * function and when it returns %TRUE */
1169   if (do_copy &amp;&amp; info-&gt;transform_func) {
1170     GstMetaTransformCopy copy_data = { FALSE, 0, -1 };
1171     GST_DEBUG_OBJECT (decoder, &quot;copy metadata %s&quot;, g_type_name (info-&gt;api));
1172     /* simply copy then */
1173     info-&gt;transform_func (outbuf, *meta, inbuf,
1174         _gst_meta_transform_copy, &amp;copy_data);
1175   }
1176   return TRUE;
1177 }
1178 
1179 /**
1180  * gst_audio_decoder_finish_frame:
1181  * @dec: a #GstAudioDecoder
1182  * @buf: decoded data
1183  * @frames: number of decoded frames represented by decoded data
1184  *
1185  * Collects decoded data and pushes it downstream.
1186  *
1187  * @buf may be NULL in which case the indicated number of frames
1188  * are discarded and considered to have produced no output
1189  * (e.g. lead-in or setup frames).
1190  * Otherwise, source pad caps must be set when it is called with valid
1191  * data in @buf.
1192  *
1193  * Note that a frame received in gst_audio_decoder_handle_frame() may be
1194  * invalidated by a call to this function.
1195  *
1196  * Returns: a #GstFlowReturn that should be escalated to caller (of caller)
1197  */
1198 GstFlowReturn
1199 gst_audio_decoder_finish_frame (GstAudioDecoder * dec, GstBuffer * buf,
1200     gint frames)
1201 {
1202   GstAudioDecoderPrivate *priv;
1203   GstAudioDecoderContext *ctx;
1204   GstAudioDecoderClass *klass = GST_AUDIO_DECODER_GET_CLASS (dec);
1205   gint samples = 0;
1206   GstClockTime ts, next_ts;
1207   gsize size;
1208   GstFlowReturn ret = GST_FLOW_OK;
1209   GQueue inbufs = G_QUEUE_INIT;
1210 
1211   /* subclass should not hand us no data */
1212   g_return_val_if_fail (buf == NULL || gst_buffer_get_size (buf) &gt; 0,
1213       GST_FLOW_ERROR);
1214   /* no dummy calls please */
1215   g_return_val_if_fail (frames != 0, GST_FLOW_ERROR);
1216 
1217   priv = dec-&gt;priv;
1218   ctx = &amp;dec-&gt;priv-&gt;ctx;
1219   size = buf ? gst_buffer_get_size (buf) : 0;
1220 
1221   /* must know the output format by now */
1222   g_return_val_if_fail (buf == NULL || GST_AUDIO_INFO_IS_VALID (&amp;ctx-&gt;info),
1223       GST_FLOW_ERROR);
1224 
1225   GST_LOG_OBJECT (dec,
1226       &quot;accepting %&quot; G_GSIZE_FORMAT &quot; bytes == %&quot; G_GSIZE_FORMAT
1227       &quot; samples for %d frames&quot;, buf ? size : -1,
1228       buf ? size / ctx-&gt;info.bpf : -1, frames);
1229 
1230   GST_AUDIO_DECODER_STREAM_LOCK (dec);
1231 
1232   if (buf) {
1233     ret = check_pending_reconfigure (dec);
1234     if (ret == GST_FLOW_FLUSHING || ret == GST_FLOW_NOT_NEGOTIATED) {
1235       gst_buffer_unref (buf);
1236       goto exit;
1237     }
1238 
1239     if (priv-&gt;pending_events)
1240       send_pending_events (dec);
1241   }
1242 
1243   /* output shoud be whole number of sample frames */
1244   if (G_LIKELY (buf &amp;&amp; ctx-&gt;info.bpf)) {
1245     if (size % ctx-&gt;info.bpf)
1246       goto wrong_buffer;
1247     /* per channel least */
1248     samples = size / ctx-&gt;info.bpf;
1249   }
1250 
1251   /* frame and ts book-keeping */
1252   if (G_UNLIKELY (frames &lt; 0)) {
1253     if (G_UNLIKELY (-frames - 1 &gt; priv-&gt;frames.length)) {
1254       GST_ELEMENT_WARNING (dec, STREAM, DECODE,
1255           (&quot;received more decoded frames %d than provided %d&quot;, frames,
1256               priv-&gt;frames.length), (NULL));
1257       frames = 0;
1258     } else {
1259       frames = priv-&gt;frames.length + frames + 1;
1260     }
1261   } else if (G_UNLIKELY (frames &gt; priv-&gt;frames.length)) {
1262     if (G_LIKELY (!priv-&gt;force)) {
1263       GST_ELEMENT_WARNING (dec, STREAM, DECODE,
1264           (&quot;received more decoded frames %d than provided %d&quot;, frames,
1265               priv-&gt;frames.length), (NULL));
1266     }
1267     frames = priv-&gt;frames.length;
1268   }
1269 
1270   if (G_LIKELY (priv-&gt;frames.length))
1271     ts = GST_BUFFER_TIMESTAMP (priv-&gt;frames.head-&gt;data);
1272   else
1273     ts = GST_CLOCK_TIME_NONE;
1274 
1275   GST_DEBUG_OBJECT (dec, &quot;leading frame ts %&quot; GST_TIME_FORMAT,
1276       GST_TIME_ARGS (ts));
1277 
1278   while (priv-&gt;frames.length &amp;&amp; frames) {
1279     g_queue_push_tail (&amp;inbufs, g_queue_pop_head (&amp;priv-&gt;frames));
1280     dec-&gt;priv-&gt;ctx.delay = dec-&gt;priv-&gt;frames.length;
1281     frames--;
1282   }
1283 
1284   if (G_UNLIKELY (!buf))
1285     goto exit;
1286 
1287   /* lock on */
1288   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (priv-&gt;base_ts))) {
1289     priv-&gt;base_ts = ts;
1290     GST_DEBUG_OBJECT (dec, &quot;base_ts now %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (ts));
1291   }
1292 
1293   /* still no valid ts, track the segment one */
1294   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (priv-&gt;base_ts)) &amp;&amp;
1295       dec-&gt;output_segment.rate &gt; 0.0) {
1296     priv-&gt;base_ts = dec-&gt;output_segment.start;
1297   }
1298 
1299   /* slightly convoluted approach caters for perfect ts if subclass desires */
1300   if (GST_CLOCK_TIME_IS_VALID (ts)) {
1301     if (dec-&gt;priv-&gt;tolerance &gt; 0) {
1302       GstClockTimeDiff diff;
1303 
1304       g_assert (GST_CLOCK_TIME_IS_VALID (priv-&gt;base_ts));
1305       next_ts = priv-&gt;base_ts +
1306           gst_util_uint64_scale (priv-&gt;samples, GST_SECOND, ctx-&gt;info.rate);
1307       GST_LOG_OBJECT (dec,
1308           &quot;buffer is %&quot; G_GUINT64_FORMAT &quot; samples past base_ts %&quot;
1309           GST_TIME_FORMAT &quot;, expected ts %&quot; GST_TIME_FORMAT, priv-&gt;samples,
1310           GST_TIME_ARGS (priv-&gt;base_ts), GST_TIME_ARGS (next_ts));
1311       diff = GST_CLOCK_DIFF (next_ts, ts);
1312       GST_LOG_OBJECT (dec, &quot;ts diff %d ms&quot;, (gint) (diff / GST_MSECOND));
1313       /* if within tolerance,
1314        * discard buffer ts and carry on producing perfect stream,
1315        * otherwise resync to ts */
1316       if (G_UNLIKELY (diff &lt; (gint64) - dec-&gt;priv-&gt;tolerance ||
1317               diff &gt; (gint64) dec-&gt;priv-&gt;tolerance)) {
1318         GST_DEBUG_OBJECT (dec, &quot;base_ts resync&quot;);
1319         priv-&gt;base_ts = ts;
1320         priv-&gt;samples = 0;
1321       }
1322     } else {
1323       GST_DEBUG_OBJECT (dec, &quot;base_ts resync&quot;);
1324       priv-&gt;base_ts = ts;
1325       priv-&gt;samples = 0;
1326     }
1327   }
1328 
1329   /* delayed one-shot stuff until confirmed data */
1330   if (priv-&gt;taglist &amp;&amp; priv-&gt;taglist_changed) {
1331     GstEvent *tags_event;
1332 
1333     tags_event = gst_audio_decoder_create_merged_tags_event (dec);
1334 
1335     if (tags_event != NULL)
1336       gst_audio_decoder_push_event (dec, tags_event);
1337 
1338     priv-&gt;taglist_changed = FALSE;
1339   }
1340 
1341   buf = gst_buffer_make_writable (buf);
1342   if (G_LIKELY (GST_CLOCK_TIME_IS_VALID (priv-&gt;base_ts))) {
1343     GST_BUFFER_TIMESTAMP (buf) =
1344         priv-&gt;base_ts +
1345         GST_FRAMES_TO_CLOCK_TIME (priv-&gt;samples, ctx-&gt;info.rate);
1346     GST_BUFFER_DURATION (buf) = priv-&gt;base_ts +
1347         GST_FRAMES_TO_CLOCK_TIME (priv-&gt;samples + samples, ctx-&gt;info.rate) -
1348         GST_BUFFER_TIMESTAMP (buf);
1349   } else {
1350     GST_BUFFER_TIMESTAMP (buf) = GST_CLOCK_TIME_NONE;
1351     GST_BUFFER_DURATION (buf) =
1352         GST_FRAMES_TO_CLOCK_TIME (samples, ctx-&gt;info.rate);
1353   }
1354 
1355   if (klass-&gt;transform_meta) {
1356     if (inbufs.length) {
1357       GList *l;
1358       for (l = inbufs.head; l; l = l-&gt;next) {
1359         CopyMetaData data;
1360 
1361         data.decoder = dec;
1362         data.outbuf = buf;
1363         gst_buffer_foreach_meta (l-&gt;data, foreach_metadata, &amp;data);
1364       }
1365     } else {
1366       GST_WARNING_OBJECT (dec,
1367           &quot;Can&#39;t copy metadata because input buffers disappeared&quot;);
1368     }
1369   }
1370 
1371   GST_OBJECT_LOCK (dec);
1372   priv-&gt;samples += samples;
1373   priv-&gt;samples_out += samples;
1374   GST_OBJECT_UNLOCK (dec);
1375 
1376   /* we got data, so note things are looking up */
1377   if (G_UNLIKELY (dec-&gt;priv-&gt;error_count))
1378     dec-&gt;priv-&gt;error_count = 0;
1379 
1380   ret = gst_audio_decoder_output (dec, buf);
1381 
1382 exit:
1383   g_queue_foreach (&amp;inbufs, (GFunc) gst_buffer_unref, NULL);
1384   g_queue_clear (&amp;inbufs);
1385 
1386   GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
1387 
1388   return ret;
1389 
1390   /* ERRORS */
1391 wrong_buffer:
1392   {
1393     GST_ELEMENT_ERROR (dec, STREAM, DECODE, (NULL),
1394         (&quot;buffer size %&quot; G_GSIZE_FORMAT &quot; not a multiple of %d&quot;, size,
1395             ctx-&gt;info.bpf));
1396     gst_buffer_unref (buf);
1397     ret = GST_FLOW_ERROR;
1398     goto exit;
1399   }
1400 }
1401 
1402 static GstFlowReturn
1403 gst_audio_decoder_handle_frame (GstAudioDecoder * dec,
1404     GstAudioDecoderClass * klass, GstBuffer * buffer)
1405 {
1406   /* Skip decoding and send a GAP instead if
1407    * GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO is set and we have timestamps
1408    * FIXME: We only do this for forward playback atm, because reverse
1409    * playback would require accumulating GAP events and pushing them
1410    * out in reverse order as for normal audio samples
1411    */
1412   if (G_UNLIKELY (dec-&gt;input_segment.rate &gt; 0.0
1413           &amp;&amp; dec-&gt;input_segment.flags &amp; GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO)) {
1414     if (buffer) {
1415       GstClockTime ts = GST_BUFFER_PTS (buffer);
1416       if (GST_CLOCK_TIME_IS_VALID (ts)) {
1417         GstEvent *event = gst_event_new_gap (ts, GST_BUFFER_DURATION (buffer));
1418 
1419         gst_buffer_unref (buffer);
1420         GST_LOG_OBJECT (dec, &quot;Skipping decode in trickmode and sending gap&quot;);
1421         gst_audio_decoder_handle_gap (dec, event);
1422         return GST_FLOW_OK;
1423       }
1424     }
1425   }
1426 
1427   if (G_LIKELY (buffer)) {
1428     gsize size = gst_buffer_get_size (buffer);
1429     /* keep around for admin */
1430     GST_LOG_OBJECT (dec,
1431         &quot;tracking frame size %&quot; G_GSIZE_FORMAT &quot;, ts %&quot; GST_TIME_FORMAT, size,
1432         GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buffer)));
1433     g_queue_push_tail (&amp;dec-&gt;priv-&gt;frames, buffer);
1434     dec-&gt;priv-&gt;ctx.delay = dec-&gt;priv-&gt;frames.length;
1435     GST_OBJECT_LOCK (dec);
1436     dec-&gt;priv-&gt;bytes_in += size;
1437     GST_OBJECT_UNLOCK (dec);
1438   } else {
1439     GST_LOG_OBJECT (dec, &quot;providing subclass with NULL frame&quot;);
1440   }
1441 
1442   return klass-&gt;handle_frame (dec, buffer);
1443 }
1444 
1445 /* maybe subclass configurable instead, but this allows for a whole lot of
1446  * raw samples, so at least quite some encoded ... */
1447 #define GST_AUDIO_DECODER_MAX_SYNC     10 * 8 * 2 * 1024
1448 
1449 static GstFlowReturn
1450 gst_audio_decoder_push_buffers (GstAudioDecoder * dec, gboolean force)
1451 {
1452   GstAudioDecoderClass *klass;
1453   GstAudioDecoderPrivate *priv;
1454   GstAudioDecoderContext *ctx;
1455   GstFlowReturn ret = GST_FLOW_OK;
1456   GstBuffer *buffer;
1457   gint av, flush;
1458 
1459   klass = GST_AUDIO_DECODER_GET_CLASS (dec);
1460   priv = dec-&gt;priv;
1461   ctx = &amp;dec-&gt;priv-&gt;ctx;
1462 
1463   g_return_val_if_fail (klass-&gt;handle_frame != NULL, GST_FLOW_ERROR);
1464 
1465   av = gst_adapter_available (priv-&gt;adapter);
1466   GST_DEBUG_OBJECT (dec, &quot;available: %d&quot;, av);
1467 
1468   while (ret == GST_FLOW_OK) {
1469 
1470     flush = 0;
1471     ctx-&gt;eos = force;
1472 
1473     if (G_LIKELY (av)) {
1474       gint len;
1475       GstClockTime ts;
1476       guint64 distance;
1477 
1478       /* parse if needed */
1479       if (klass-&gt;parse) {
1480         gint offset = 0;
1481 
1482         /* limited (legacy) parsing; avoid whole of baseparse */
1483         GST_DEBUG_OBJECT (dec, &quot;parsing available: %d&quot;, av);
1484         /* piggyback sync state on discont */
1485         ctx-&gt;sync = !priv-&gt;discont;
1486         ret = klass-&gt;parse (dec, priv-&gt;adapter, &amp;offset, &amp;len);
1487 
1488         g_assert (offset &lt;= av);
1489         if (offset) {
1490           /* jumped a bit */
1491           GST_DEBUG_OBJECT (dec, &quot;skipped %d; setting DISCONT&quot;, offset);
1492           gst_adapter_flush (priv-&gt;adapter, offset);
1493           flush = offset;
1494           /* avoid parsing indefinitely */
1495           priv-&gt;sync_flush += offset;
1496           if (priv-&gt;sync_flush &gt; GST_AUDIO_DECODER_MAX_SYNC)
1497             goto parse_failed;
1498         }
1499 
1500         if (ret == GST_FLOW_EOS) {
1501           GST_LOG_OBJECT (dec, &quot;no frame yet&quot;);
1502           ret = GST_FLOW_OK;
1503           break;
1504         } else if (ret == GST_FLOW_OK) {
1505           GST_LOG_OBJECT (dec, &quot;frame at offset %d of length %d&quot;, offset, len);
1506           g_assert (len);
1507           g_assert (offset + len &lt;= av);
1508           priv-&gt;sync_flush = 0;
1509         } else {
1510           break;
1511         }
1512       } else {
1513         len = av;
1514       }
1515       /* track upstream ts, but do not get stuck if nothing new upstream */
1516       ts = gst_adapter_prev_pts (priv-&gt;adapter, &amp;distance);
1517       if (ts != priv-&gt;prev_ts || distance &lt;= priv-&gt;prev_distance) {
1518         priv-&gt;prev_ts = ts;
1519         priv-&gt;prev_distance = distance;
1520       } else {
1521         GST_LOG_OBJECT (dec, &quot;ts == prev_ts; discarding&quot;);
1522         ts = GST_CLOCK_TIME_NONE;
1523       }
1524       buffer = gst_adapter_take_buffer (priv-&gt;adapter, len);
1525       buffer = gst_buffer_make_writable (buffer);
1526       GST_BUFFER_TIMESTAMP (buffer) = ts;
1527       flush += len;
1528       priv-&gt;force = FALSE;
1529     } else {
1530       if (!force)
1531         break;
1532       if (!priv-&gt;drainable) {
1533         priv-&gt;drained = TRUE;
1534         break;
1535       }
1536       buffer = NULL;
1537       priv-&gt;force = TRUE;
1538     }
1539 
1540     ret = gst_audio_decoder_handle_frame (dec, klass, buffer);
1541 
1542     /* do not keep pushing it ... */
1543     if (G_UNLIKELY (!av)) {
1544       priv-&gt;drained = TRUE;
1545       break;
1546     }
1547 
1548     av -= flush;
1549     g_assert (av &gt;= 0);
1550   }
1551 
1552   GST_LOG_OBJECT (dec, &quot;done pushing to subclass&quot;);
1553   return ret;
1554 
1555   /* ERRORS */
1556 parse_failed:
1557   {
1558     GST_ELEMENT_ERROR (dec, STREAM, DECODE, (NULL), (&quot;failed to parse stream&quot;));
1559     return GST_FLOW_ERROR;
1560   }
1561 }
1562 
1563 static GstFlowReturn
1564 gst_audio_decoder_drain (GstAudioDecoder * dec)
1565 {
1566   GstFlowReturn ret;
1567 
1568   if (dec-&gt;priv-&gt;drained &amp;&amp; !dec-&gt;priv-&gt;gather)
1569     return GST_FLOW_OK;
1570 
1571   /* Apply any pending events before draining, as that
1572    * may update the pending segment info */
1573   apply_pending_events (dec);
1574 
1575     /* dispatch reverse pending buffers */
1576     /* chain eventually calls upon drain as well, but by that time
1577      * gather list should be clear, so ok ... */
1578     if (dec-&gt;output_segment.rate &lt; 0.0 &amp;&amp; dec-&gt;priv-&gt;gather)
1579       gst_audio_decoder_chain_reverse (dec, NULL);
1580     /* have subclass give all it can */
1581     ret = gst_audio_decoder_push_buffers (dec, TRUE);
1582   if (ret != GST_FLOW_OK) {
1583     GST_WARNING_OBJECT (dec, &quot;audio decoder push buffers failed&quot;);
1584     goto drain_failed;
1585   }
1586     /* ensure all output sent */
1587     ret = gst_audio_decoder_output (dec, NULL);
1588   if (ret != GST_FLOW_OK)
1589     GST_WARNING_OBJECT (dec, &quot;audio decoder output failed&quot;);
1590 
1591 drain_failed:
1592     /* everything should be away now */
1593     if (dec-&gt;priv-&gt;frames.length) {
1594       /* not fatal/impossible though if subclass/codec eats stuff */
1595       GST_WARNING_OBJECT (dec, &quot;still %d frames left after draining&quot;,
1596           dec-&gt;priv-&gt;frames.length);
1597       g_queue_foreach (&amp;dec-&gt;priv-&gt;frames, (GFunc) gst_buffer_unref, NULL);
1598       g_queue_clear (&amp;dec-&gt;priv-&gt;frames);
1599     }
1600 
1601     /* discard (unparsed) leftover */
1602     gst_adapter_clear (dec-&gt;priv-&gt;adapter);
1603     return ret;
1604   }
1605 
1606 /* hard == FLUSH, otherwise discont */
1607 static GstFlowReturn
1608 gst_audio_decoder_flush (GstAudioDecoder * dec, gboolean hard)
1609 {
1610   GstAudioDecoderClass *klass;
1611   GstFlowReturn ret = GST_FLOW_OK;
1612 
1613   klass = GST_AUDIO_DECODER_GET_CLASS (dec);
1614 
1615   GST_LOG_OBJECT (dec, &quot;flush hard %d&quot;, hard);
1616 
1617   if (!hard) {
1618     ret = gst_audio_decoder_drain (dec);
1619   } else {
1620     gst_audio_decoder_clear_queues (dec);
1621     gst_segment_init (&amp;dec-&gt;input_segment, GST_FORMAT_TIME);
1622     gst_segment_init (&amp;dec-&gt;output_segment, GST_FORMAT_TIME);
1623     dec-&gt;priv-&gt;error_count = 0;
1624   }
1625   /* only bother subclass with flushing if known it is already alive
1626    * and kicking out stuff */
1627   if (klass-&gt;flush &amp;&amp; dec-&gt;priv-&gt;samples_out &gt; 0)
1628     klass-&gt;flush (dec, hard);
1629   /* and get (re)set for the sequel */
1630   gst_audio_decoder_reset (dec, FALSE);
1631 
1632   return ret;
1633 }
1634 
1635 static GstFlowReturn
1636 gst_audio_decoder_chain_forward (GstAudioDecoder * dec, GstBuffer * buffer)
1637 {
1638   GstFlowReturn ret = GST_FLOW_OK;
1639 
1640   /* discard silly case, though maybe ts may be of value ?? */
1641   if (G_UNLIKELY (gst_buffer_get_size (buffer) == 0)) {
1642     GST_DEBUG_OBJECT (dec, &quot;discarding empty buffer&quot;);
1643     gst_buffer_unref (buffer);
1644     goto exit;
1645   }
1646 
1647   /* grab buffer */
1648   gst_adapter_push (dec-&gt;priv-&gt;adapter, buffer);
1649   buffer = NULL;
1650   /* new stuff, so we can push subclass again */
1651   dec-&gt;priv-&gt;drained = FALSE;
1652 
1653   /* hand to subclass */
1654   ret = gst_audio_decoder_push_buffers (dec, FALSE);
1655 
1656 exit:
1657   GST_LOG_OBJECT (dec, &quot;chain-done&quot;);
1658   return ret;
1659 }
1660 
1661 static void
1662 gst_audio_decoder_clear_queues (GstAudioDecoder * dec)
1663 {
1664   GstAudioDecoderPrivate *priv = dec-&gt;priv;
1665 
1666   g_list_foreach (priv-&gt;queued, (GFunc) gst_mini_object_unref, NULL);
1667   g_list_free (priv-&gt;queued);
1668   priv-&gt;queued = NULL;
1669   g_list_foreach (priv-&gt;gather, (GFunc) gst_mini_object_unref, NULL);
1670   g_list_free (priv-&gt;gather);
1671   priv-&gt;gather = NULL;
1672   g_list_foreach (priv-&gt;decode, (GFunc) gst_mini_object_unref, NULL);
1673   g_list_free (priv-&gt;decode);
1674   priv-&gt;decode = NULL;
1675 }
1676 
1677 /*
1678  * Input:
1679  *  Buffer decoding order:  7  8  9  4  5  6  3  1  2  EOS
1680  *  Discont flag:           D        D        D  D
1681  *
1682  * - Each Discont marks a discont in the decoding order.
1683  *
1684  * for vorbis, each buffer is a keyframe when we have the previous
1685  * buffer. This means that to decode buffer 7, we need buffer 6, which
1686  * arrives out of order.
1687  *
1688  * we first gather buffers in the gather queue until we get a DISCONT. We
1689  * prepend each incomming buffer so that they are in reversed order.
1690  *
1691  *    gather queue:    9  8  7
1692  *    decode queue:
1693  *    output queue:
1694  *
1695  * When a DISCONT is received (buffer 4), we move the gather queue to the
1696  * decode queue. This is simply done be taking the head of the gather queue
1697  * and prepending it to the decode queue. This yields:
1698  *
1699  *    gather queue:
1700  *    decode queue:    7  8  9
1701  *    output queue:
1702  *
1703  * Then we decode each buffer in the decode queue in order and put the output
1704  * buffer in the output queue. The first buffer (7) will not produce any output
1705  * because it needs the previous buffer (6) which did not arrive yet. This
1706  * yields:
1707  *
1708  *    gather queue:
1709  *    decode queue:    7  8  9
1710  *    output queue:    9  8
1711  *
1712  * Then we remove the consumed buffers from the decode queue. Buffer 7 is not
1713  * completely consumed, we need to keep it around for when we receive buffer
1714  * 6. This yields:
1715  *
1716  *    gather queue:
1717  *    decode queue:    7
1718  *    output queue:    9  8
1719  *
1720  * Then we accumulate more buffers:
1721  *
1722  *    gather queue:    6  5  4
1723  *    decode queue:    7
1724  *    output queue:
1725  *
1726  * prepending to the decode queue on DISCONT yields:
1727  *
1728  *    gather queue:
1729  *    decode queue:    4  5  6  7
1730  *    output queue:
1731  *
1732  * after decoding and keeping buffer 4:
1733  *
1734  *    gather queue:
1735  *    decode queue:    4
1736  *    output queue:    7  6  5
1737  *
1738  * Etc..
1739  */
1740 static GstFlowReturn
1741 gst_audio_decoder_flush_decode (GstAudioDecoder * dec)
1742 {
1743   GstAudioDecoderPrivate *priv = dec-&gt;priv;
1744   GstFlowReturn res = GST_FLOW_OK;
1745   GstClockTime timestamp;
1746   GList *walk;
1747 
1748   walk = priv-&gt;decode;
1749 
1750   GST_DEBUG_OBJECT (dec, &quot;flushing buffers to decoder&quot;);
1751 
1752   /* clear buffer and decoder state */
1753   gst_audio_decoder_flush (dec, FALSE);
1754 
1755   while (walk) {
1756     GList *next;
1757     GstBuffer *buf = GST_BUFFER_CAST (walk-&gt;data);
1758 
1759     GST_DEBUG_OBJECT (dec, &quot;decoding buffer %p, ts %&quot; GST_TIME_FORMAT,
1760         buf, GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)));
1761 
1762     next = g_list_next (walk);
1763     /* decode buffer, resulting data prepended to output queue */
1764     gst_buffer_ref (buf);
1765     res = gst_audio_decoder_chain_forward (dec, buf);
1766 
1767     /* if we generated output, we can discard the buffer, else we
1768      * keep it in the queue */
1769     if (priv-&gt;queued) {
1770       GST_DEBUG_OBJECT (dec, &quot;decoded buffer to %p&quot;, priv-&gt;queued-&gt;data);
1771       priv-&gt;decode = g_list_delete_link (priv-&gt;decode, walk);
1772       gst_buffer_unref (buf);
1773     } else {
1774       GST_DEBUG_OBJECT (dec, &quot;buffer did not decode, keeping&quot;);
1775     }
1776     walk = next;
1777   }
1778 
1779   /* drain any aggregation (or otherwise) leftover */
1780   gst_audio_decoder_drain (dec);
1781 
1782   /* now send queued data downstream */
1783   timestamp = GST_CLOCK_TIME_NONE;
1784   while (priv-&gt;queued) {
1785     GstBuffer *buf = GST_BUFFER_CAST (priv-&gt;queued-&gt;data);
1786     GstClockTime duration;
1787 
1788     duration = GST_BUFFER_DURATION (buf);
1789 
1790     /* duration should always be valid for raw audio */
1791     g_assert (GST_CLOCK_TIME_IS_VALID (duration));
1792 
1793     /* interpolate (backward) if needed */
1794     if (G_LIKELY (timestamp != -1)) {
1795       if (timestamp &gt; duration)
1796         timestamp -= duration;
1797       else
1798         timestamp = 0;
1799     }
1800 
1801     if (!GST_BUFFER_TIMESTAMP_IS_VALID (buf)) {
1802       GST_LOG_OBJECT (dec, &quot;applying reverse interpolated ts %&quot;
1803           GST_TIME_FORMAT, GST_TIME_ARGS (timestamp));
1804       GST_BUFFER_TIMESTAMP (buf) = timestamp;
1805     } else {
1806       /* track otherwise */
1807       timestamp = GST_BUFFER_TIMESTAMP (buf);
1808       GST_LOG_OBJECT (dec, &quot;tracking ts %&quot; GST_TIME_FORMAT,
1809           GST_TIME_ARGS (timestamp));
1810     }
1811 
1812     if (G_LIKELY (res == GST_FLOW_OK)) {
1813       GST_DEBUG_OBJECT (dec, &quot;pushing buffer %p of size %&quot; G_GSIZE_FORMAT &quot;, &quot;
1814           &quot;time %&quot; GST_TIME_FORMAT &quot;, dur %&quot; GST_TIME_FORMAT, buf,
1815           gst_buffer_get_size (buf), GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
1816           GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
1817       /* should be already, but let&#39;s be sure */
1818       buf = gst_buffer_make_writable (buf);
1819       /* avoid stray DISCONT from forward processing,
1820        * which have no meaning in reverse pushing */
1821       GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DISCONT);
1822       res = gst_audio_decoder_push_forward (dec, buf);
1823     } else {
1824       gst_buffer_unref (buf);
1825     }
1826 
1827     priv-&gt;queued = g_list_delete_link (priv-&gt;queued, priv-&gt;queued);
1828   }
1829 
1830   return res;
1831 }
1832 
1833 static GstFlowReturn
1834 gst_audio_decoder_chain_reverse (GstAudioDecoder * dec, GstBuffer * buf)
1835 {
1836   GstAudioDecoderPrivate *priv = dec-&gt;priv;
1837   GstFlowReturn result = GST_FLOW_OK;
1838 
1839   /* if we have a discont, move buffers to the decode list */
1840   if (!buf || GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DISCONT)) {
1841     GST_DEBUG_OBJECT (dec, &quot;received discont&quot;);
1842     while (priv-&gt;gather) {
1843       GstBuffer *gbuf;
1844 
1845       gbuf = GST_BUFFER_CAST (priv-&gt;gather-&gt;data);
1846       /* remove from the gather list */
1847       priv-&gt;gather = g_list_delete_link (priv-&gt;gather, priv-&gt;gather);
1848       /* copy to decode queue */
1849       priv-&gt;decode = g_list_prepend (priv-&gt;decode, gbuf);
1850     }
1851     /* decode stuff in the decode queue */
1852     gst_audio_decoder_flush_decode (dec);
1853   }
1854 
1855   if (G_LIKELY (buf)) {
1856     GST_DEBUG_OBJECT (dec, &quot;gathering buffer %p of size %&quot; G_GSIZE_FORMAT &quot;, &quot;
1857         &quot;time %&quot; GST_TIME_FORMAT &quot;, dur %&quot; GST_TIME_FORMAT, buf,
1858         gst_buffer_get_size (buf), GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
1859         GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
1860 
1861     /* add buffer to gather queue */
1862     priv-&gt;gather = g_list_prepend (priv-&gt;gather, buf);
1863   }
1864 
1865   return result;
1866 }
1867 
1868 static GstFlowReturn
1869 gst_audio_decoder_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
1870 {
1871   GstAudioDecoder *dec;
1872   GstFlowReturn ret;
1873 
1874   dec = GST_AUDIO_DECODER (parent);
1875 
1876   GST_LOG_OBJECT (dec,
1877       &quot;received buffer of size %&quot; G_GSIZE_FORMAT &quot; with ts %&quot; GST_TIME_FORMAT
1878       &quot;, duration %&quot; GST_TIME_FORMAT, gst_buffer_get_size (buffer),
1879       GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buffer)),
1880       GST_TIME_ARGS (GST_BUFFER_DURATION (buffer)));
1881 
1882   GST_AUDIO_DECODER_STREAM_LOCK (dec);
1883 
1884   if (G_UNLIKELY (dec-&gt;priv-&gt;ctx.input_caps == NULL &amp;&amp; dec-&gt;priv-&gt;needs_format))
1885     goto not_negotiated;
1886 
1887   dec-&gt;priv-&gt;ctx.had_input_data = TRUE;
1888 
1889   if (!dec-&gt;priv-&gt;expecting_discont_buf &amp;&amp;
1890       GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT)) {
1891     gint64 samples, ts;
1892 
1893     /* track present position */
1894     ts = dec-&gt;priv-&gt;base_ts;
1895     samples = dec-&gt;priv-&gt;samples;
1896 
1897     GST_DEBUG_OBJECT (dec, &quot;handling discont&quot;);
1898     gst_audio_decoder_flush (dec, FALSE);
1899     dec-&gt;priv-&gt;discont = TRUE;
1900 
1901     /* buffer may claim DISCONT loudly, if it can&#39;t tell us where we are now,
1902      * we&#39;ll stick to where we were ...
1903      * Particularly useful/needed for upstream BYTE based */
1904     if (dec-&gt;input_segment.rate &gt; 0.0
1905         &amp;&amp; !GST_BUFFER_TIMESTAMP_IS_VALID (buffer)) {
1906       GST_DEBUG_OBJECT (dec, &quot;... but restoring previous ts tracking&quot;);
1907       dec-&gt;priv-&gt;base_ts = ts;
1908       dec-&gt;priv-&gt;samples = samples;
1909     }
1910   }
1911   dec-&gt;priv-&gt;expecting_discont_buf = FALSE;
1912 
1913   if (dec-&gt;input_segment.rate &gt; 0.0)
1914     ret = gst_audio_decoder_chain_forward (dec, buffer);
1915   else
1916     ret = gst_audio_decoder_chain_reverse (dec, buffer);
1917 
1918   GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
1919 
1920   return ret;
1921 
1922   /* ERRORS */
1923 not_negotiated:
1924   {
1925     GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
1926     GST_ELEMENT_ERROR (dec, CORE, NEGOTIATION, (NULL),
1927         (&quot;decoder not initialized&quot;));
1928     gst_buffer_unref (buffer);
1929     return GST_FLOW_NOT_NEGOTIATED;
1930   }
1931 }
1932 
1933 /* perform upstream byte &lt;-&gt; time conversion (duration, seeking)
1934  * if subclass allows and if enough data for moderately decent conversion */
1935 static inline gboolean
1936 gst_audio_decoder_do_byte (GstAudioDecoder * dec)
1937 {
1938   gboolean ret;
1939 
1940   GST_OBJECT_LOCK (dec);
1941   ret = dec-&gt;priv-&gt;ctx.do_estimate_rate &amp;&amp; dec-&gt;priv-&gt;ctx.info.bpf &amp;&amp;
1942       dec-&gt;priv-&gt;ctx.info.rate &lt;= dec-&gt;priv-&gt;samples_out;
1943   GST_OBJECT_UNLOCK (dec);
1944 
1945   return ret;
1946 }
1947 
1948 /* Must be called holding the GST_AUDIO_DECODER_STREAM_LOCK */
1949 static gboolean
1950 gst_audio_decoder_negotiate_default_caps (GstAudioDecoder * dec)
1951 {
1952   GstCaps *caps, *templcaps;
1953   gint i;
1954   gint channels = 0;
1955   gint rate;
1956   guint64 channel_mask = 0;
1957   gint caps_size;
1958   GstStructure *structure;
1959   GstAudioInfo info;
1960 
1961   templcaps = gst_pad_get_pad_template_caps (dec-&gt;srcpad);
1962   caps = gst_pad_peer_query_caps (dec-&gt;srcpad, templcaps);
1963   if (caps)
1964     gst_caps_unref (templcaps);
1965   else
1966     caps = templcaps;
1967   templcaps = NULL;
1968 
1969   if (!caps || gst_caps_is_empty (caps) || gst_caps_is_any (caps))
1970     goto caps_error;
1971 
1972   GST_LOG_OBJECT (dec, &quot;peer caps  %&quot; GST_PTR_FORMAT, caps);
1973 
1974   /* before fixating, try to use whatever upstream provided */
1975   caps = gst_caps_make_writable (caps);
1976   caps_size = gst_caps_get_size (caps);
1977   if (dec-&gt;priv-&gt;ctx.input_caps) {
1978     GstCaps *sinkcaps = dec-&gt;priv-&gt;ctx.input_caps;
1979     GstStructure *structure = gst_caps_get_structure (sinkcaps, 0);
1980 
1981     if (gst_structure_get_int (structure, &quot;rate&quot;, &amp;rate)) {
1982       for (i = 0; i &lt; caps_size; i++) {
1983         gst_structure_set (gst_caps_get_structure (caps, i), &quot;rate&quot;,
1984             G_TYPE_INT, rate, NULL);
1985       }
1986     }
1987 
1988     if (gst_structure_get_int (structure, &quot;channels&quot;, &amp;channels)) {
1989       for (i = 0; i &lt; caps_size; i++) {
1990         gst_structure_set (gst_caps_get_structure (caps, i), &quot;channels&quot;,
1991             G_TYPE_INT, channels, NULL);
1992       }
1993     }
1994 
1995     if (gst_structure_get (structure, &quot;channel-mask&quot;, GST_TYPE_BITMASK,
1996             &amp;channel_mask, NULL)) {
1997       for (i = 0; i &lt; caps_size; i++) {
1998         gst_structure_set (gst_caps_get_structure (caps, i), &quot;channel-mask&quot;,
1999             GST_TYPE_BITMASK, channel_mask, NULL);
2000       }
2001     }
2002   }
2003 
2004   for (i = 0; i &lt; caps_size; i++) {
2005     structure = gst_caps_get_structure (caps, i);
2006     if (gst_structure_has_field (structure, &quot;channels&quot;))
2007     gst_structure_fixate_field_nearest_int (structure,
2008         &quot;channels&quot;, GST_AUDIO_DEF_CHANNELS);
2009     else
2010       gst_structure_set (structure, &quot;channels&quot;, G_TYPE_INT,
2011           GST_AUDIO_DEF_CHANNELS, NULL);
2012     if (gst_structure_has_field (structure, &quot;rate&quot;))
2013     gst_structure_fixate_field_nearest_int (structure,
2014         &quot;rate&quot;, GST_AUDIO_DEF_RATE);
2015     else
2016       gst_structure_set (structure, &quot;rate&quot;, G_TYPE_INT, GST_AUDIO_DEF_RATE,
2017           NULL);
2018   }
2019   caps = gst_caps_fixate (caps);
2020   structure = gst_caps_get_structure (caps, 0);
2021 
2022   /* Need to add a channel-mask if channels &gt; 2 */
2023   gst_structure_get_int (structure, &quot;channels&quot;, &amp;channels);
2024   if (channels &gt; 2 &amp;&amp; !gst_structure_has_field (structure, &quot;channel-mask&quot;)) {
2025     channel_mask = gst_audio_channel_get_fallback_mask (channels);
2026     if (channel_mask != 0) {
2027       gst_structure_set (structure, &quot;channel-mask&quot;,
2028           GST_TYPE_BITMASK, channel_mask, NULL);
2029     } else {
2030       GST_WARNING_OBJECT (dec, &quot;No default channel-mask for %d channels&quot;,
2031           channels);
2032     }
2033   }
2034 
2035   if (!caps || !gst_audio_info_from_caps (&amp;info, caps))
2036     goto caps_error;
2037 
2038   GST_OBJECT_LOCK (dec);
2039   dec-&gt;priv-&gt;ctx.info = info;
2040   GST_OBJECT_UNLOCK (dec);
2041 
2042   GST_INFO_OBJECT (dec,
2043       &quot;Chose default caps %&quot; GST_PTR_FORMAT &quot; for initial gap&quot;, caps);
2044   gst_caps_unref (caps);
2045 
2046   return TRUE;
2047 
2048 caps_error:
2049   {
2050     if (caps)
2051       gst_caps_unref (caps);
2052     return FALSE;
2053   }
2054 }
2055 
2056 static gboolean
2057 gst_audio_decoder_handle_gap (GstAudioDecoder * dec, GstEvent * event)
2058 {
2059   gboolean ret;
2060   GstClockTime timestamp, duration;
2061   gboolean needs_reconfigure = FALSE;
2062 
2063   /* Ensure we have caps first */
2064   GST_AUDIO_DECODER_STREAM_LOCK (dec);
2065   if (!GST_AUDIO_INFO_IS_VALID (&amp;dec-&gt;priv-&gt;ctx.info)) {
2066     if (!gst_audio_decoder_negotiate_default_caps (dec)) {
2067       GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
2068       GST_ELEMENT_ERROR (dec, STREAM, FORMAT, (NULL),
2069           (&quot;Decoder output not negotiated before GAP event.&quot;));
2070       return FALSE;
2071     }
2072     needs_reconfigure = TRUE;
2073   }
2074   needs_reconfigure = gst_pad_check_reconfigure (dec-&gt;srcpad)
2075       || needs_reconfigure;
2076   if (G_UNLIKELY (dec-&gt;priv-&gt;ctx.output_format_changed || needs_reconfigure)) {
2077     if (!gst_audio_decoder_negotiate_unlocked (dec)) {
2078       GST_WARNING_OBJECT (dec, &quot;Failed to negotiate with downstream&quot;);
2079       gst_pad_mark_reconfigure (dec-&gt;srcpad);
2080     }
2081   }
2082   GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
2083 
2084   gst_event_parse_gap (event, &amp;timestamp, &amp;duration);
2085 
2086   /* time progressed without data, see if we can fill the gap with
2087    * some concealment data */
2088   GST_DEBUG_OBJECT (dec,
2089       &quot;gap event: plc %d, do_plc %d, position %&quot; GST_TIME_FORMAT
2090       &quot; duration %&quot; GST_TIME_FORMAT,
2091       dec-&gt;priv-&gt;plc, dec-&gt;priv-&gt;ctx.do_plc,
2092       GST_TIME_ARGS (timestamp), GST_TIME_ARGS (duration));
2093 
2094   if (dec-&gt;priv-&gt;plc &amp;&amp; dec-&gt;priv-&gt;ctx.do_plc &amp;&amp; dec-&gt;input_segment.rate &gt; 0.0) {
2095     GstAudioDecoderClass *klass = GST_AUDIO_DECODER_GET_CLASS (dec);
2096     GstBuffer *buf;
2097 
2098     /* hand subclass empty frame with duration that needs covering */
2099     buf = gst_buffer_new ();
2100     GST_BUFFER_TIMESTAMP (buf) = timestamp;
2101     GST_BUFFER_DURATION (buf) = duration;
2102     /* best effort, not much error handling */
2103     gst_audio_decoder_handle_frame (dec, klass, buf);
2104     ret = TRUE;
2105     dec-&gt;priv-&gt;expecting_discont_buf = TRUE;
2106     gst_event_unref (event);
2107   } else {
2108     GstFlowReturn flowret;
2109 
2110     /* sub-class doesn&#39;t know how to handle empty buffers,
2111      * so just try sending GAP downstream */
2112     flowret = check_pending_reconfigure (dec);
2113     if (flowret == GST_FLOW_OK) {
2114       send_pending_events (dec);
2115       ret = gst_audio_decoder_push_event (dec, event);
2116     } else {
2117       ret = FALSE;
2118     }
2119   }
2120   return ret;
2121   }
2122 
2123 static GList *
2124 _flush_events (GstPad * pad, GList * events)
2125 {
2126   GList *tmp;
2127 
2128   for (tmp = events; tmp; tmp = tmp-&gt;next) {
2129     if (GST_EVENT_TYPE (tmp-&gt;data) != GST_EVENT_EOS &amp;&amp;
2130         GST_EVENT_TYPE (tmp-&gt;data) != GST_EVENT_SEGMENT &amp;&amp;
2131         GST_EVENT_IS_STICKY (tmp-&gt;data)) {
2132       gst_pad_store_sticky_event (pad, GST_EVENT_CAST (tmp-&gt;data));
2133     }
2134     gst_event_unref (tmp-&gt;data);
2135   }
2136   g_list_free (events);
2137 
2138   return NULL;
2139 }
2140 
2141 static gboolean
2142 gst_audio_decoder_sink_eventfunc (GstAudioDecoder * dec, GstEvent * event)
2143 {
2144   gboolean ret;
2145 
2146   switch (GST_EVENT_TYPE (event)) {
2147     case GST_EVENT_STREAM_START:
2148       GST_AUDIO_DECODER_STREAM_LOCK (dec);
2149       /* finish any data in current segment and clear the decoder
2150        * to be ready for new stream data */
2151       gst_audio_decoder_drain (dec);
2152       gst_audio_decoder_flush (dec, FALSE);
2153 
2154       GST_DEBUG_OBJECT (dec, &quot;received STREAM_START. Clearing taglist&quot;);
2155       /* Flush upstream tags after a STREAM_START */
2156       if (dec-&gt;priv-&gt;upstream_tags) {
2157         gst_tag_list_unref (dec-&gt;priv-&gt;upstream_tags);
2158         dec-&gt;priv-&gt;upstream_tags = NULL;
2159         dec-&gt;priv-&gt;taglist_changed = TRUE;
2160       }
2161       GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
2162 
2163       ret = gst_audio_decoder_push_event (dec, event);
2164       break;
2165     case GST_EVENT_SEGMENT:
2166     {
2167       GstSegment seg;
2168       GstFormat format;
2169 
2170       GST_AUDIO_DECODER_STREAM_LOCK (dec);
2171       gst_event_copy_segment (event, &amp;seg);
2172 
2173       format = seg.format;
2174       if (format == GST_FORMAT_TIME) {
2175         GST_DEBUG_OBJECT (dec, &quot;received TIME SEGMENT %&quot; GST_SEGMENT_FORMAT,
2176             &amp;seg);
2177       } else {
2178         gint64 nstart;
2179         GST_DEBUG_OBJECT (dec, &quot;received SEGMENT %&quot; GST_SEGMENT_FORMAT, &amp;seg);
2180         /* handle newsegment resulting from legacy simple seeking */
2181         /* note that we need to convert this whether or not enough data
2182          * to handle initial newsegment */
2183         if (dec-&gt;priv-&gt;ctx.do_estimate_rate &amp;&amp;
2184             gst_pad_query_convert (dec-&gt;sinkpad, GST_FORMAT_BYTES, seg.start,
2185                 GST_FORMAT_TIME, &amp;nstart)) {
2186           /* best attempt convert */
2187           /* as these are only estimates, stop is kept open-ended to avoid
2188            * premature cutting */
2189           GST_DEBUG_OBJECT (dec, &quot;converted to TIME start %&quot; GST_TIME_FORMAT,
2190               GST_TIME_ARGS (nstart));
2191           seg.format = GST_FORMAT_TIME;
2192           seg.start = nstart;
2193           seg.time = nstart;
2194           seg.stop = GST_CLOCK_TIME_NONE;
2195           /* replace event */
2196           gst_event_unref (event);
2197           event = gst_event_new_segment (&amp;seg);
2198         } else {
2199           GST_DEBUG_OBJECT (dec, &quot;unsupported format; ignoring&quot;);
2200           GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
2201           gst_event_unref (event);
2202           ret = FALSE;
2203           break;
2204         }
2205       }
2206 
2207       /* prepare for next segment */
2208       /* Use the segment start as a base timestamp
2209          * in case upstream does not come up with anything better
2210          * (e.g. upstream BYTE) */
2211         if (format != GST_FORMAT_TIME) {
2212           dec-&gt;priv-&gt;base_ts = seg.start;
2213           dec-&gt;priv-&gt;samples = 0;
2214         }
2215 
2216       /* and follow along with segment */
2217       dec-&gt;priv-&gt;in_out_segment_sync = FALSE;
2218       dec-&gt;input_segment = seg;
2219       dec-&gt;priv-&gt;pending_events =
2220           g_list_append (dec-&gt;priv-&gt;pending_events, event);
2221       GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
2222 
2223       ret = TRUE;
2224       break;
2225     }
2226     case GST_EVENT_GAP:
2227       ret = gst_audio_decoder_handle_gap (dec, event);
2228       break;
2229     case GST_EVENT_FLUSH_STOP:
2230       GST_AUDIO_DECODER_STREAM_LOCK (dec);
2231       /* prepare for fresh start */
2232       gst_audio_decoder_flush (dec, TRUE);
2233 
2234       dec-&gt;priv-&gt;pending_events = _flush_events (dec-&gt;srcpad,
2235           dec-&gt;priv-&gt;pending_events);
2236       GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
2237 
2238       /* Forward FLUSH_STOP, it is expected to be forwarded immediately
2239        * and no buffers are queued anyway. */
2240       ret = gst_audio_decoder_push_event (dec, event);
2241       break;
2242 
2243     case GST_EVENT_SEGMENT_DONE:
2244       GST_AUDIO_DECODER_STREAM_LOCK (dec);
2245       gst_audio_decoder_drain (dec);
2246       GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
2247 
2248       /* Forward SEGMENT_DONE because no buffer or serialized event might come after
2249        * SEGMENT_DONE and nothing could trigger another _finish_frame() call. */
2250       if (dec-&gt;priv-&gt;pending_events)
2251         send_pending_events (dec);
2252       ret = gst_audio_decoder_push_event (dec, event);
2253       break;
2254 
2255     case GST_EVENT_EOS:
2256       GST_AUDIO_DECODER_STREAM_LOCK (dec);
2257       gst_audio_decoder_drain (dec);
2258       GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
2259 
2260       if (dec-&gt;priv-&gt;ctx.had_input_data &amp;&amp; !dec-&gt;priv-&gt;ctx.had_output_data) {
2261         GST_ELEMENT_ERROR (dec, STREAM, DECODE,
2262             (&quot;No valid frames decoded before end of stream&quot;),
2263             (&quot;no valid frames found&quot;));
2264       }
2265 
2266       /* Forward EOS because no buffer or serialized event will come after
2267        * EOS and nothing could trigger another _finish_frame() call. */
2268       if (dec-&gt;priv-&gt;pending_events)
2269         send_pending_events (dec);
2270       ret = gst_audio_decoder_push_event (dec, event);
2271       break;
2272 
2273     case GST_EVENT_CAPS:
2274     {
2275       GstCaps *caps;
2276 
2277       gst_event_parse_caps (event, &amp;caps);
2278       ret = gst_audio_decoder_sink_setcaps (dec, caps);
2279       gst_event_unref (event);
2280       break;
2281     }
2282     case GST_EVENT_TAG:
2283     {
2284       GstTagList *tags;
2285 
2286       gst_event_parse_tag (event, &amp;tags);
2287 
2288       if (gst_tag_list_get_scope (tags) == GST_TAG_SCOPE_STREAM) {
2289         GST_AUDIO_DECODER_STREAM_LOCK (dec);
2290         if (dec-&gt;priv-&gt;upstream_tags != tags) {
2291           if (dec-&gt;priv-&gt;upstream_tags)
2292             gst_tag_list_unref (dec-&gt;priv-&gt;upstream_tags);
2293           dec-&gt;priv-&gt;upstream_tags = gst_tag_list_ref (tags);
2294           GST_INFO_OBJECT (dec, &quot;upstream stream tags: %&quot; GST_PTR_FORMAT, tags);
2295         }
2296         gst_event_unref (event);
2297         event = gst_audio_decoder_create_merged_tags_event (dec);
2298         dec-&gt;priv-&gt;taglist_changed = FALSE;
2299         GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
2300 
2301         /* No tags, go out of here instead of fall through */
2302         if (!event) {
2303         ret = TRUE;
2304         break;
2305       }
2306       }
2307 
2308       /* fall through */
2309     }
2310     default:
2311       if (!GST_EVENT_IS_SERIALIZED (event)) {
2312         ret =
2313             gst_pad_event_default (dec-&gt;sinkpad, GST_OBJECT_CAST (dec), event);
2314       } else {
2315         GST_DEBUG_OBJECT (dec, &quot;Enqueuing event %d, %s&quot;, GST_EVENT_TYPE (event),
2316             GST_EVENT_TYPE_NAME (event));
2317         GST_AUDIO_DECODER_STREAM_LOCK (dec);
2318         dec-&gt;priv-&gt;pending_events =
2319             g_list_append (dec-&gt;priv-&gt;pending_events, event);
2320         GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
2321         ret = TRUE;
2322       }
2323       break;
2324   }
2325   return ret;
2326 }
2327 
2328 static gboolean
2329 gst_audio_decoder_sink_event (GstPad * pad, GstObject * parent,
2330     GstEvent * event)
2331 {
2332   GstAudioDecoder *dec;
2333   GstAudioDecoderClass *klass;
2334   gboolean ret;
2335 
2336   dec = GST_AUDIO_DECODER (parent);
2337   klass = GST_AUDIO_DECODER_GET_CLASS (dec);
2338 
2339   GST_DEBUG_OBJECT (dec, &quot;received event %d, %s&quot;, GST_EVENT_TYPE (event),
2340       GST_EVENT_TYPE_NAME (event));
2341 
2342   if (klass-&gt;sink_event)
2343     ret = klass-&gt;sink_event (dec, event);
2344   else {
2345     gst_event_unref (event);
2346     ret = FALSE;
2347   }
2348   return ret;
2349 }
2350 
2351 static gboolean
2352 gst_audio_decoder_do_seek (GstAudioDecoder * dec, GstEvent * event)
2353 {
2354   GstSeekFlags flags;
2355   GstSeekType start_type, end_type;
2356   GstFormat format;
2357   gdouble rate;
2358   gint64 start, start_time, end_time;
2359   GstSegment seek_segment;
2360   guint32 seqnum;
2361 
2362   gst_event_parse_seek (event, &amp;rate, &amp;format, &amp;flags, &amp;start_type,
2363       &amp;start_time, &amp;end_type, &amp;end_time);
2364 
2365   /* we&#39;ll handle plain open-ended flushing seeks with the simple approach */
2366   if (rate != 1.0) {
2367     GST_DEBUG_OBJECT (dec, &quot;unsupported seek: rate&quot;);
2368     return FALSE;
2369   }
2370 
2371   if (start_type != GST_SEEK_TYPE_SET) {
2372     GST_DEBUG_OBJECT (dec, &quot;unsupported seek: start time&quot;);
2373     return FALSE;
2374   }
2375 
2376   if ((end_type != GST_SEEK_TYPE_SET &amp;&amp; end_type != GST_SEEK_TYPE_NONE) ||
2377       (end_type == GST_SEEK_TYPE_SET &amp;&amp; end_time != GST_CLOCK_TIME_NONE)) {
2378     GST_DEBUG_OBJECT (dec, &quot;unsupported seek: end time&quot;);
2379     return FALSE;
2380   }
2381 
2382   if (!(flags &amp; GST_SEEK_FLAG_FLUSH)) {
2383     GST_DEBUG_OBJECT (dec, &quot;unsupported seek: not flushing&quot;);
2384     return FALSE;
2385   }
2386 
2387   memcpy (&amp;seek_segment, &amp;dec-&gt;output_segment, sizeof (seek_segment));
2388   gst_segment_do_seek (&amp;seek_segment, rate, format, flags, start_type,
2389       start_time, end_type, end_time, NULL);
2390   start_time = seek_segment.position;
2391 
2392   if (!gst_pad_query_convert (dec-&gt;sinkpad, GST_FORMAT_TIME, start_time,
2393           GST_FORMAT_BYTES, &amp;start)) {
2394     GST_DEBUG_OBJECT (dec, &quot;conversion failed&quot;);
2395     return FALSE;
2396   }
2397 
2398   seqnum = gst_event_get_seqnum (event);
2399   event = gst_event_new_seek (1.0, GST_FORMAT_BYTES, flags,
2400       GST_SEEK_TYPE_SET, start, GST_SEEK_TYPE_NONE, -1);
2401   gst_event_set_seqnum (event, seqnum);
2402 
2403   GST_DEBUG_OBJECT (dec, &quot;seeking to %&quot; GST_TIME_FORMAT &quot; at byte offset %&quot;
2404       G_GINT64_FORMAT, GST_TIME_ARGS (start_time), start);
2405 
2406   return gst_pad_push_event (dec-&gt;sinkpad, event);
2407 }
2408 
2409 static gboolean
2410 gst_audio_decoder_src_eventfunc (GstAudioDecoder * dec, GstEvent * event)
2411 {
2412   gboolean res;
2413 
2414   switch (GST_EVENT_TYPE (event)) {
2415     case GST_EVENT_SEEK:
2416     {
2417       GstFormat format;
2418       gdouble rate;
2419       GstSeekFlags flags;
2420       GstSeekType start_type, stop_type;
2421       gint64 start, stop;
2422       gint64 tstart, tstop;
2423       guint32 seqnum;
2424 
2425       gst_event_parse_seek (event, &amp;rate, &amp;format, &amp;flags, &amp;start_type, &amp;start,
2426           &amp;stop_type, &amp;stop);
2427       seqnum = gst_event_get_seqnum (event);
2428 
2429       /* upstream gets a chance first */
2430       if ((res = gst_pad_push_event (dec-&gt;sinkpad, event)))
2431         break;
2432 
2433       /* if upstream fails for a time seek, maybe we can help if allowed */
2434       if (format == GST_FORMAT_TIME) {
2435         if (gst_audio_decoder_do_byte (dec))
2436           res = gst_audio_decoder_do_seek (dec, event);
2437         break;
2438       }
2439 
2440       /* ... though a non-time seek can be aided as well */
2441       /* First bring the requested format to time */
2442       if (!(res =
2443               gst_pad_query_convert (dec-&gt;srcpad, format, start,
2444                   GST_FORMAT_TIME, &amp;tstart)))
2445         goto convert_error;
2446       if (!(res =
2447               gst_pad_query_convert (dec-&gt;srcpad, format, stop, GST_FORMAT_TIME,
2448                   &amp;tstop)))
2449         goto convert_error;
2450 
2451       /* then seek with time on the peer */
2452       event = gst_event_new_seek (rate, GST_FORMAT_TIME,
2453           flags, start_type, tstart, stop_type, tstop);
2454       gst_event_set_seqnum (event, seqnum);
2455 
2456       res = gst_pad_push_event (dec-&gt;sinkpad, event);
2457       break;
2458     }
2459     default:
2460       res = gst_pad_event_default (dec-&gt;srcpad, GST_OBJECT_CAST (dec), event);
2461       break;
2462   }
2463 done:
2464   return res;
2465 
2466   /* ERRORS */
2467 convert_error:
2468   {
2469     GST_DEBUG_OBJECT (dec, &quot;cannot convert start/stop for seek&quot;);
2470     goto done;
2471   }
2472 }
2473 
2474 static gboolean
2475 gst_audio_decoder_src_event (GstPad * pad, GstObject * parent, GstEvent * event)
2476 {
2477   GstAudioDecoder *dec;
2478   GstAudioDecoderClass *klass;
2479   gboolean ret;
2480 
2481   dec = GST_AUDIO_DECODER (parent);
2482   klass = GST_AUDIO_DECODER_GET_CLASS (dec);
2483 
2484   GST_DEBUG_OBJECT (dec, &quot;received event %d, %s&quot;, GST_EVENT_TYPE (event),
2485       GST_EVENT_TYPE_NAME (event));
2486 
2487   if (klass-&gt;src_event)
2488     ret = klass-&gt;src_event (dec, event);
2489   else {
2490     gst_event_unref (event);
2491     ret = FALSE;
2492   }
2493 
2494   return ret;
2495 }
2496 
2497 static gboolean
2498 gst_audio_decoder_decide_allocation_default (GstAudioDecoder * dec,
2499     GstQuery * query)
2500 {
2501   GstAllocator *allocator = NULL;
2502   GstAllocationParams params;
2503   gboolean update_allocator;
2504 
2505   /* we got configuration from our peer or the decide_allocation method,
2506    * parse them */
2507   if (gst_query_get_n_allocation_params (query) &gt; 0) {
2508     /* try the allocator */
2509     gst_query_parse_nth_allocation_param (query, 0, &amp;allocator, &amp;params);
2510     update_allocator = TRUE;
2511   } else {
2512     allocator = NULL;
2513     gst_allocation_params_init (&amp;params);
2514     update_allocator = FALSE;
2515   }
2516 
2517   if (update_allocator)
2518     gst_query_set_nth_allocation_param (query, 0, allocator, &amp;params);
2519   else
2520     gst_query_add_allocation_param (query, allocator, &amp;params);
2521   if (allocator)
2522     gst_object_unref (allocator);
2523 
2524   return TRUE;
2525 }
2526 
2527 static gboolean
2528 gst_audio_decoder_propose_allocation_default (GstAudioDecoder * dec,
2529     GstQuery * query)
2530 {
2531   return TRUE;
2532 }
2533 
2534 /**
2535  * gst_audio_decoder_proxy_getcaps:
2536  * @decoder: a #GstAudioDecoder
2537  * @caps: (allow-none): initial caps
2538  * @filter: (allow-none): filter caps
2539  *
2540  * Returns caps that express @caps (or sink template caps if @caps == NULL)
2541  * restricted to rate/channels/... combinations supported by downstream
2542  * elements.
2543  *
2544  * Returns: (transfer full): a #GstCaps owned by caller
2545  *
2546  * Since: 1.6
2547  */
2548 GstCaps *
2549 gst_audio_decoder_proxy_getcaps (GstAudioDecoder * decoder, GstCaps * caps,
2550     GstCaps * filter)
2551 {
2552   return __gst_audio_element_proxy_getcaps (GST_ELEMENT_CAST (decoder),
2553       GST_AUDIO_DECODER_SINK_PAD (decoder),
2554       GST_AUDIO_DECODER_SRC_PAD (decoder), caps, filter);
2555 }
2556 
2557 static GstCaps *
2558 gst_audio_decoder_sink_getcaps (GstAudioDecoder * decoder, GstCaps * filter)
2559 {
2560   GstAudioDecoderClass *klass;
2561   GstCaps *caps;
2562 
2563   klass = GST_AUDIO_DECODER_GET_CLASS (decoder);
2564 
2565   if (klass-&gt;getcaps)
2566     caps = klass-&gt;getcaps (decoder, filter);
2567   else
2568     caps = gst_audio_decoder_proxy_getcaps (decoder, NULL, filter);
2569 
2570   GST_LOG_OBJECT (decoder, &quot;Returning caps %&quot; GST_PTR_FORMAT, caps);
2571 
2572   return caps;
2573       }
2574 
2575 static gboolean
2576 gst_audio_decoder_sink_query_default (GstAudioDecoder * dec, GstQuery * query)
2577 {
2578   GstPad *pad = GST_AUDIO_DECODER_SINK_PAD (dec);
2579   gboolean res = FALSE;
2580 
2581   GST_LOG_OBJECT (dec, &quot;handling query: %&quot; GST_PTR_FORMAT, query);
2582 
2583   switch (GST_QUERY_TYPE (query)) {
2584     case GST_QUERY_FORMATS:
2585     {
2586       gst_query_set_formats (query, 2, GST_FORMAT_TIME, GST_FORMAT_BYTES);
2587       res = TRUE;
2588       break;
2589     }
2590     case GST_QUERY_CONVERT:
2591     {
2592       GstFormat src_fmt, dest_fmt;
2593       gint64 src_val, dest_val;
2594 
2595       gst_query_parse_convert (query, &amp;src_fmt, &amp;src_val, &amp;dest_fmt, &amp;dest_val);
2596       GST_OBJECT_LOCK (dec);
2597       res = __gst_audio_encoded_audio_convert (&amp;dec-&gt;priv-&gt;ctx.info,
2598                   dec-&gt;priv-&gt;bytes_in, dec-&gt;priv-&gt;samples_out,
2599           src_fmt, src_val, &amp;dest_fmt, &amp;dest_val);
2600       GST_OBJECT_UNLOCK (dec);
2601       if (!res)
2602         goto error;
2603       gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
2604       break;
2605     }
2606     case GST_QUERY_ALLOCATION:
2607     {
2608       GstAudioDecoderClass *klass = GST_AUDIO_DECODER_GET_CLASS (dec);
2609 
2610       if (klass-&gt;propose_allocation)
2611         res = klass-&gt;propose_allocation (dec, query);
2612       break;
2613     }
2614     case GST_QUERY_CAPS:{
2615       GstCaps *filter, *caps;
2616 
2617       gst_query_parse_caps (query, &amp;filter);
2618       caps = gst_audio_decoder_sink_getcaps (dec, filter);
2619       gst_query_set_caps_result (query, caps);
2620       gst_caps_unref (caps);
2621       res = TRUE;
2622       break;
2623     }
2624     case GST_QUERY_ACCEPT_CAPS:{
2625       if (dec-&gt;priv-&gt;use_default_pad_acceptcaps) {
2626         res =
2627             gst_pad_query_default (GST_AUDIO_DECODER_SINK_PAD (dec),
2628             GST_OBJECT_CAST (dec), query);
2629       } else {
2630         GstCaps *caps;
2631         GstCaps *allowed_caps;
2632         GstCaps *template_caps;
2633         gboolean accept;
2634 
2635         gst_query_parse_accept_caps (query, &amp;caps);
2636 
2637         template_caps = gst_pad_get_pad_template_caps (pad);
2638         accept = gst_caps_is_subset (caps, template_caps);
2639         gst_caps_unref (template_caps);
2640 
2641         if (accept) {
2642           allowed_caps = gst_pad_query_caps (GST_AUDIO_DECODER_SINK_PAD (dec),
2643               caps);
2644 
2645           accept = gst_caps_can_intersect (caps, allowed_caps);
2646 
2647           gst_caps_unref (allowed_caps);
2648         }
2649 
2650         gst_query_set_accept_caps_result (query, accept);
2651         res = TRUE;
2652       }
2653       break;
2654     }
2655     case GST_QUERY_SEEKING:
2656     {
2657       GstFormat format;
2658 
2659       /* non-TIME segments are discarded, so we won&#39;t seek that way either */
2660       gst_query_parse_seeking (query, &amp;format, NULL, NULL, NULL);
2661       if (format != GST_FORMAT_TIME) {
2662         GST_DEBUG_OBJECT (dec, &quot;discarding non-TIME SEEKING query&quot;);
2663         res = FALSE;
2664         break;
2665       }
2666       /* fall-through */
2667     }
2668     default:
2669       res = gst_pad_query_default (pad, GST_OBJECT_CAST (dec), query);
2670       break;
2671   }
2672 
2673 error:
2674   return res;
2675 }
2676 
2677 static gboolean
2678 gst_audio_decoder_sink_query (GstPad * pad, GstObject * parent,
2679     GstQuery * query)
2680 {
2681   GstAudioDecoderClass *dec_class;
2682   GstAudioDecoder *dec;
2683   gboolean ret = FALSE;
2684 
2685   dec = GST_AUDIO_DECODER (parent);
2686   dec_class = GST_AUDIO_DECODER_GET_CLASS (dec);
2687 
2688   GST_DEBUG_OBJECT (pad, &quot;received query %&quot; GST_PTR_FORMAT, query);
2689 
2690   if (dec_class-&gt;sink_query)
2691     ret = dec_class-&gt;sink_query (dec, query);
2692 
2693   return ret;
2694 }
2695 
2696 /* FIXME ? are any of these queries (other than latency) a decoder&#39;s business ??
2697  * also, the conversion stuff might seem to make sense, but seems to not mind
2698  * segment stuff etc at all
2699  * Supposedly that&#39;s backward compatibility ... */
2700 static gboolean
2701 gst_audio_decoder_src_query_default (GstAudioDecoder * dec, GstQuery * query)
2702 {
2703   GstPad *pad = GST_AUDIO_DECODER_SRC_PAD (dec);
2704   gboolean res = FALSE;
2705 
2706   GST_LOG_OBJECT (dec, &quot;handling query: %&quot; GST_PTR_FORMAT, query);
2707 
2708   switch (GST_QUERY_TYPE (query)) {
2709     case GST_QUERY_DURATION:
2710     {
2711       GstFormat format;
2712 
2713       /* upstream in any case */
2714       if ((res = gst_pad_query_default (pad, GST_OBJECT_CAST (dec), query)))
2715         break;
2716 
2717       gst_query_parse_duration (query, &amp;format, NULL);
2718       /* try answering TIME by converting from BYTE if subclass allows  */
2719       if (format == GST_FORMAT_TIME &amp;&amp; gst_audio_decoder_do_byte (dec)) {
2720         gint64 value;
2721 
2722         if (gst_pad_peer_query_duration (dec-&gt;sinkpad, GST_FORMAT_BYTES,
2723                 &amp;value)) {
2724           GST_LOG_OBJECT (dec, &quot;upstream size %&quot; G_GINT64_FORMAT, value);
2725           if (gst_pad_query_convert (dec-&gt;sinkpad, GST_FORMAT_BYTES, value,
2726                   GST_FORMAT_TIME, &amp;value)) {
2727             gst_query_set_duration (query, GST_FORMAT_TIME, value);
2728             res = TRUE;
2729           }
2730         }
2731       }
2732       break;
2733     }
2734     case GST_QUERY_POSITION:
2735     {
2736       GstFormat format;
2737       gint64 time, value;
2738 
2739       if ((res = gst_pad_peer_query (dec-&gt;sinkpad, query))) {
2740         GST_LOG_OBJECT (dec, &quot;returning peer response&quot;);
2741         break;
2742       }
2743 
2744       /* Refuse BYTES format queries. If it made sense to
2745        * answer them, upstream would have already */
2746       gst_query_parse_position (query, &amp;format, NULL);
2747 
2748       if (format == GST_FORMAT_BYTES) {
2749         GST_LOG_OBJECT (dec, &quot;Ignoring BYTES position query&quot;);
2750         break;
2751       }
2752 
2753       /* we start from the last seen time */
2754       time = dec-&gt;output_segment.position;
2755       /* correct for the segment values */
2756       time =
2757           gst_segment_to_stream_time (&amp;dec-&gt;output_segment, GST_FORMAT_TIME,
2758           time);
2759 
2760       GST_LOG_OBJECT (dec,
2761           &quot;query %p: our time: %&quot; GST_TIME_FORMAT, query, GST_TIME_ARGS (time));
2762 
2763       /* and convert to the final format */
2764       if (!(res = gst_pad_query_convert (pad, GST_FORMAT_TIME, time,
2765                   format, &amp;value)))
2766         break;
2767 
2768       gst_query_set_position (query, format, value);
2769 
2770       GST_LOG_OBJECT (dec,
2771           &quot;query %p: we return %&quot; G_GINT64_FORMAT &quot; (format %u)&quot;, query, value,
2772           format);
2773       break;
2774     }
2775     case GST_QUERY_FORMATS:
2776     {
2777       gst_query_set_formats (query, 3,
2778           GST_FORMAT_TIME, GST_FORMAT_BYTES, GST_FORMAT_DEFAULT);
2779       res = TRUE;
2780       break;
2781     }
2782     case GST_QUERY_CONVERT:
2783     {
2784       GstFormat src_fmt, dest_fmt;
2785       gint64 src_val, dest_val;
2786 
2787       gst_query_parse_convert (query, &amp;src_fmt, &amp;src_val, &amp;dest_fmt, &amp;dest_val);
2788       GST_OBJECT_LOCK (dec);
2789       res = gst_audio_info_convert (&amp;dec-&gt;priv-&gt;ctx.info,
2790           src_fmt, src_val, dest_fmt, &amp;dest_val);
2791       GST_OBJECT_UNLOCK (dec);
2792       if (!res)
2793         break;
2794       gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
2795       break;
2796     }
2797     case GST_QUERY_LATENCY:
2798     {
2799       if ((res = gst_pad_peer_query (dec-&gt;sinkpad, query))) {
2800         gboolean live;
2801         GstClockTime min_latency, max_latency;
2802 
2803         gst_query_parse_latency (query, &amp;live, &amp;min_latency, &amp;max_latency);
2804         GST_DEBUG_OBJECT (dec, &quot;Peer latency: live %d, min %&quot;
2805             GST_TIME_FORMAT &quot; max %&quot; GST_TIME_FORMAT, live,
2806             GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
2807 
2808         GST_OBJECT_LOCK (dec);
2809         /* add our latency */
2810           min_latency += dec-&gt;priv-&gt;ctx.min_latency;
2811         if (max_latency == -1 || dec-&gt;priv-&gt;ctx.max_latency == -1)
2812           max_latency = -1;
2813         else
2814           max_latency += dec-&gt;priv-&gt;ctx.max_latency;
2815         GST_OBJECT_UNLOCK (dec);
2816 
2817         gst_query_set_latency (query, live, min_latency, max_latency);
2818       }
2819       break;
2820     }
2821     default:
2822       res = gst_pad_query_default (pad, GST_OBJECT_CAST (dec), query);
2823       break;
2824   }
2825 
2826   return res;
2827 }
2828 
2829 static gboolean
2830 gst_audio_decoder_src_query (GstPad * pad, GstObject * parent, GstQuery * query)
2831 {
2832   GstAudioDecoder *dec;
2833   GstAudioDecoderClass *dec_class;
2834   gboolean ret = FALSE;
2835 
2836   dec = GST_AUDIO_DECODER (parent);
2837   dec_class = GST_AUDIO_DECODER_GET_CLASS (dec);
2838 
2839   GST_DEBUG_OBJECT (pad, &quot;received query %&quot; GST_PTR_FORMAT, query);
2840 
2841   if (dec_class-&gt;src_query)
2842     ret = dec_class-&gt;src_query (dec, query);
2843 
2844   return ret;
2845 }
2846 
2847 static gboolean
2848 gst_audio_decoder_stop (GstAudioDecoder * dec)
2849 {
2850   GstAudioDecoderClass *klass;
2851   gboolean ret = TRUE;
2852 
2853   GST_DEBUG_OBJECT (dec, &quot;gst_audio_decoder_stop&quot;);
2854 
2855   klass = GST_AUDIO_DECODER_GET_CLASS (dec);
2856 
2857   if (klass-&gt;stop) {
2858     ret = klass-&gt;stop (dec);
2859   }
2860 
2861   /* clean up */
2862   gst_audio_decoder_reset (dec, TRUE);
2863 
2864   if (ret)
2865     dec-&gt;priv-&gt;active = FALSE;
2866 
2867   return ret;
2868 }
2869 
2870 static gboolean
2871 gst_audio_decoder_start (GstAudioDecoder * dec)
2872 {
2873   GstAudioDecoderClass *klass;
2874   gboolean ret = TRUE;
2875 
2876   GST_DEBUG_OBJECT (dec, &quot;gst_audio_decoder_start&quot;);
2877 
2878   klass = GST_AUDIO_DECODER_GET_CLASS (dec);
2879 
2880   /* arrange clean state */
2881   gst_audio_decoder_reset (dec, TRUE);
2882 
2883   if (klass-&gt;start) {
2884     ret = klass-&gt;start (dec);
2885   }
2886 
2887   if (ret)
2888     dec-&gt;priv-&gt;active = TRUE;
2889 
2890   return ret;
2891 }
2892 
2893 static void
2894 gst_audio_decoder_get_property (GObject * object, guint prop_id,
2895     GValue * value, GParamSpec * pspec)
2896 {
2897   GstAudioDecoder *dec;
2898 
2899   dec = GST_AUDIO_DECODER (object);
2900 
2901   switch (prop_id) {
2902     case PROP_LATENCY:
2903       g_value_set_int64 (value, dec-&gt;priv-&gt;latency);
2904       break;
2905     case PROP_TOLERANCE:
2906       g_value_set_int64 (value, dec-&gt;priv-&gt;tolerance);
2907       break;
2908     case PROP_PLC:
2909       g_value_set_boolean (value, dec-&gt;priv-&gt;plc);
2910       break;
2911     default:
2912       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
2913       break;
2914   }
2915 }
2916 
2917 static void
2918 gst_audio_decoder_set_property (GObject * object, guint prop_id,
2919     const GValue * value, GParamSpec * pspec)
2920 {
2921   GstAudioDecoder *dec;
2922 
2923   dec = GST_AUDIO_DECODER (object);
2924 
2925   switch (prop_id) {
2926     case PROP_LATENCY:
2927       dec-&gt;priv-&gt;latency = g_value_get_int64 (value);
2928       break;
2929     case PROP_TOLERANCE:
2930       dec-&gt;priv-&gt;tolerance = g_value_get_int64 (value);
2931       break;
2932     case PROP_PLC:
2933       dec-&gt;priv-&gt;plc = g_value_get_boolean (value);
2934       break;
2935     default:
2936       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
2937       break;
2938   }
2939 }
2940 
2941 static GstStateChangeReturn
2942 gst_audio_decoder_change_state (GstElement * element, GstStateChange transition)
2943 {
2944   GstAudioDecoder *codec;
2945   GstAudioDecoderClass *klass;
2946   GstStateChangeReturn ret;
2947 
2948   codec = GST_AUDIO_DECODER (element);
2949   klass = GST_AUDIO_DECODER_GET_CLASS (codec);
2950 
2951   switch (transition) {
2952     case GST_STATE_CHANGE_NULL_TO_READY:
2953       if (klass-&gt;open) {
2954         if (!klass-&gt;open (codec))
2955           goto open_failed;
2956       }
2957       break;
2958     case GST_STATE_CHANGE_READY_TO_PAUSED:
2959       if (!gst_audio_decoder_start (codec)) {
2960         goto start_failed;
2961       }
2962       break;
2963     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
2964       break;
2965     default:
2966       break;
2967   }
2968 
2969   ret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
2970 
2971   switch (transition) {
2972     case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
2973       break;
2974     case GST_STATE_CHANGE_PAUSED_TO_READY:
2975       if (!gst_audio_decoder_stop (codec)) {
2976         goto stop_failed;
2977       }
2978       break;
2979     case GST_STATE_CHANGE_READY_TO_NULL:
2980       if (klass-&gt;close) {
2981         if (!klass-&gt;close (codec))
2982           goto close_failed;
2983       }
2984       break;
2985     default:
2986       break;
2987   }
2988 
2989   return ret;
2990 
2991 start_failed:
2992   {
2993     GST_ELEMENT_ERROR (codec, LIBRARY, INIT, (NULL), (&quot;Failed to start codec&quot;));
2994     return GST_STATE_CHANGE_FAILURE;
2995   }
2996 stop_failed:
2997   {
2998     GST_ELEMENT_ERROR (codec, LIBRARY, INIT, (NULL), (&quot;Failed to stop codec&quot;));
2999     return GST_STATE_CHANGE_FAILURE;
3000   }
3001 open_failed:
3002   {
3003     GST_ELEMENT_ERROR (codec, LIBRARY, INIT, (NULL), (&quot;Failed to open codec&quot;));
3004     return GST_STATE_CHANGE_FAILURE;
3005   }
3006 close_failed:
3007   {
3008     GST_ELEMENT_ERROR (codec, LIBRARY, INIT, (NULL), (&quot;Failed to close codec&quot;));
3009     return GST_STATE_CHANGE_FAILURE;
3010   }
3011 }
3012 
3013 GstFlowReturn
3014 _gst_audio_decoder_error (GstAudioDecoder * dec, gint weight,
3015     GQuark domain, gint code, gchar * txt, gchar * dbg, const gchar * file,
3016     const gchar * function, gint line)
3017 {
3018   if (txt)
3019     GST_WARNING_OBJECT (dec, &quot;error: %s&quot;, txt);
3020   if (dbg)
3021     GST_WARNING_OBJECT (dec, &quot;error: %s&quot;, dbg);
3022   dec-&gt;priv-&gt;error_count += weight;
3023   dec-&gt;priv-&gt;discont = TRUE;
3024   if (dec-&gt;priv-&gt;ctx.max_errors &gt;= 0
3025       &amp;&amp; dec-&gt;priv-&gt;ctx.max_errors &lt; dec-&gt;priv-&gt;error_count) {
3026     gst_element_message_full (GST_ELEMENT (dec), GST_MESSAGE_ERROR, domain,
3027         code, txt, dbg, file, function, line);
3028     return GST_FLOW_ERROR;
3029   } else {
3030     g_free (txt);
3031     g_free (dbg);
3032     return GST_FLOW_OK;
3033   }
3034 }
3035 
3036 /**
3037  * gst_audio_decoder_get_audio_info:
3038  * @dec: a #GstAudioDecoder
3039  *
3040  * Returns: a #GstAudioInfo describing the input audio format
3041  */
3042 GstAudioInfo *
3043 gst_audio_decoder_get_audio_info (GstAudioDecoder * dec)
3044 {
3045   g_return_val_if_fail (GST_IS_AUDIO_DECODER (dec), NULL);
3046 
3047   return &amp;dec-&gt;priv-&gt;ctx.info;
3048 }
3049 
3050 /**
3051  * gst_audio_decoder_set_plc_aware:
3052  * @dec: a #GstAudioDecoder
3053  * @plc: new plc state
3054  *
3055  * Indicates whether or not subclass handles packet loss concealment (plc).
3056  */
3057 void
3058 gst_audio_decoder_set_plc_aware (GstAudioDecoder * dec, gboolean plc)
3059 {
3060   g_return_if_fail (GST_IS_AUDIO_DECODER (dec));
3061 
3062   dec-&gt;priv-&gt;ctx.do_plc = plc;
3063 }
3064 
3065 /**
3066  * gst_audio_decoder_get_plc_aware:
3067  * @dec: a #GstAudioDecoder
3068  *
3069  * Returns: currently configured plc handling
3070  */
3071 gint
3072 gst_audio_decoder_get_plc_aware (GstAudioDecoder * dec)
3073 {
3074   g_return_val_if_fail (GST_IS_AUDIO_DECODER (dec), 0);
3075 
3076   return dec-&gt;priv-&gt;ctx.do_plc;
3077 }
3078 
3079 /**
3080  * gst_audio_decoder_set_estimate_rate:
3081  * @dec: a #GstAudioDecoder
3082  * @enabled: whether to enable byte to time conversion
3083  *
3084  * Allows baseclass to perform byte to time estimated conversion.
3085  */
3086 void
3087 gst_audio_decoder_set_estimate_rate (GstAudioDecoder * dec, gboolean enabled)
3088 {
3089   g_return_if_fail (GST_IS_AUDIO_DECODER (dec));
3090 
3091   dec-&gt;priv-&gt;ctx.do_estimate_rate = enabled;
3092 }
3093 
3094 /**
3095  * gst_audio_decoder_get_estimate_rate:
3096  * @dec: a #GstAudioDecoder
3097  *
3098  * Returns: currently configured byte to time conversion setting
3099  */
3100 gint
3101 gst_audio_decoder_get_estimate_rate (GstAudioDecoder * dec)
3102 {
3103   g_return_val_if_fail (GST_IS_AUDIO_DECODER (dec), 0);
3104 
3105   return dec-&gt;priv-&gt;ctx.do_estimate_rate;
3106 }
3107 
3108 /**
3109  * gst_audio_decoder_get_delay:
3110  * @dec: a #GstAudioDecoder
3111  *
3112  * Returns: currently configured decoder delay
3113  */
3114 gint
3115 gst_audio_decoder_get_delay (GstAudioDecoder * dec)
3116 {
3117   g_return_val_if_fail (GST_IS_AUDIO_DECODER (dec), 0);
3118 
3119   return dec-&gt;priv-&gt;ctx.delay;
3120 }
3121 
3122 /**
3123  * gst_audio_decoder_set_max_errors:
3124  * @dec: a #GstAudioDecoder
3125  * @num: max tolerated errors
3126  *
3127  * Sets numbers of tolerated decoder errors, where a tolerated one is then only
3128  * warned about, but more than tolerated will lead to fatal error. You can set
3129  * -1 for never returning fatal errors. Default is set to
3130  * GST_AUDIO_DECODER_MAX_ERRORS.
3131  */
3132 void
3133 gst_audio_decoder_set_max_errors (GstAudioDecoder * dec, gint num)
3134 {
3135   g_return_if_fail (GST_IS_AUDIO_DECODER (dec));
3136 
3137   dec-&gt;priv-&gt;ctx.max_errors = num;
3138 }
3139 
3140 /**
3141  * gst_audio_decoder_get_max_errors:
3142  * @dec: a #GstAudioDecoder
3143  *
3144  * Returns: currently configured decoder tolerated error count.
3145  */
3146 gint
3147 gst_audio_decoder_get_max_errors (GstAudioDecoder * dec)
3148 {
3149   g_return_val_if_fail (GST_IS_AUDIO_DECODER (dec), 0);
3150 
3151   return dec-&gt;priv-&gt;ctx.max_errors;
3152 }
3153 
3154 /**
3155  * gst_audio_decoder_set_latency:
3156  * @dec: a #GstAudioDecoder
3157  * @min: minimum latency
3158  * @max: maximum latency
3159  *
3160  * Sets decoder latency.
3161  */
3162 void
3163 gst_audio_decoder_set_latency (GstAudioDecoder * dec,
3164     GstClockTime min, GstClockTime max)
3165 {
3166   g_return_if_fail (GST_IS_AUDIO_DECODER (dec));
3167   g_return_if_fail (GST_CLOCK_TIME_IS_VALID (min));
3168   g_return_if_fail (min &lt;= max);
3169 
3170   GST_OBJECT_LOCK (dec);
3171   dec-&gt;priv-&gt;ctx.min_latency = min;
3172   dec-&gt;priv-&gt;ctx.max_latency = max;
3173   GST_OBJECT_UNLOCK (dec);
3174 
3175   /* post latency message on the bus */
3176   gst_element_post_message (GST_ELEMENT (dec),
3177       gst_message_new_latency (GST_OBJECT (dec)));
3178 }
3179 
3180 /**
3181  * gst_audio_decoder_get_latency:
3182  * @dec: a #GstAudioDecoder
3183  * @min: (out) (allow-none): a pointer to storage to hold minimum latency
3184  * @max: (out) (allow-none): a pointer to storage to hold maximum latency
3185  *
3186  * Sets the variables pointed to by @min and @max to the currently configured
3187  * latency.
3188  */
3189 void
3190 gst_audio_decoder_get_latency (GstAudioDecoder * dec,
3191     GstClockTime * min, GstClockTime * max)
3192 {
3193   g_return_if_fail (GST_IS_AUDIO_DECODER (dec));
3194 
3195   GST_OBJECT_LOCK (dec);
3196   if (min)
3197     *min = dec-&gt;priv-&gt;ctx.min_latency;
3198   if (max)
3199     *max = dec-&gt;priv-&gt;ctx.max_latency;
3200   GST_OBJECT_UNLOCK (dec);
3201 }
3202 
3203 /**
3204  * gst_audio_decoder_get_parse_state:
3205  * @dec: a #GstAudioDecoder
3206  * @sync: (out) (optional): a pointer to a variable to hold the current sync state
3207  * @eos: (out) (optional): a pointer to a variable to hold the current eos state
3208  *
3209  * Return current parsing (sync and eos) state.
3210  */
3211 void
3212 gst_audio_decoder_get_parse_state (GstAudioDecoder * dec,
3213     gboolean * sync, gboolean * eos)
3214 {
3215   g_return_if_fail (GST_IS_AUDIO_DECODER (dec));
3216 
3217   if (sync)
3218     *sync = dec-&gt;priv-&gt;ctx.sync;
3219   if (eos)
3220     *eos = dec-&gt;priv-&gt;ctx.eos;
3221 }
3222 
3223 /**
3224  * gst_audio_decoder_set_allocation_caps:
3225  * @dec: a #GstAudioDecoder
3226  * @allocation_caps: (allow-none): a #GstCaps or %NULL
3227  *
3228  * Sets a caps in allocation query which are different from the set
3229  * pad&#39;s caps. Use this function before calling
3230  * gst_audio_decoder_negotiate(). Setting to %NULL the allocation
3231  * query will use the caps from the pad.
3232  *
3233  * Since: 1.10
3234  */
3235 void
3236 gst_audio_decoder_set_allocation_caps (GstAudioDecoder * dec,
3237     GstCaps * allocation_caps)
3238 {
3239   g_return_if_fail (GST_IS_AUDIO_DECODER (dec));
3240 
3241   gst_caps_replace (&amp;dec-&gt;priv-&gt;ctx.allocation_caps, allocation_caps);
3242 }
3243 
3244 /**
3245  * gst_audio_decoder_set_plc:
3246  * @dec: a #GstAudioDecoder
3247  * @enabled: new state
3248  *
3249  * Enable or disable decoder packet loss concealment, provided subclass
3250  * and codec are capable and allow handling plc.
3251  *
3252  * MT safe.
3253  */
3254 void
3255 gst_audio_decoder_set_plc (GstAudioDecoder * dec, gboolean enabled)
3256 {
3257   g_return_if_fail (GST_IS_AUDIO_DECODER (dec));
3258 
3259   GST_LOG_OBJECT (dec, &quot;enabled: %d&quot;, enabled);
3260 
3261   GST_OBJECT_LOCK (dec);
3262   dec-&gt;priv-&gt;plc = enabled;
3263   GST_OBJECT_UNLOCK (dec);
3264 }
3265 
3266 /**
3267  * gst_audio_decoder_get_plc:
3268  * @dec: a #GstAudioDecoder
3269  *
3270  * Queries decoder packet loss concealment handling.
3271  *
3272  * Returns: TRUE if packet loss concealment is enabled.
3273  *
3274  * MT safe.
3275  */
3276 gboolean
3277 gst_audio_decoder_get_plc (GstAudioDecoder * dec)
3278 {
3279   gboolean result;
3280 
3281   g_return_val_if_fail (GST_IS_AUDIO_DECODER (dec), FALSE);
3282 
3283   GST_OBJECT_LOCK (dec);
3284   result = dec-&gt;priv-&gt;plc;
3285   GST_OBJECT_UNLOCK (dec);
3286 
3287   return result;
3288 }
3289 
3290 /**
3291  * gst_audio_decoder_set_min_latency:
3292  * @dec: a #GstAudioDecoder
3293  * @num: new minimum latency
3294  *
3295  * Sets decoder minimum aggregation latency.
3296  *
3297  * MT safe.
3298  */
3299 void
3300 gst_audio_decoder_set_min_latency (GstAudioDecoder * dec, GstClockTime num)
3301 {
3302   g_return_if_fail (GST_IS_AUDIO_DECODER (dec));
3303 
3304   GST_OBJECT_LOCK (dec);
3305   dec-&gt;priv-&gt;latency = num;
3306   GST_OBJECT_UNLOCK (dec);
3307 }
3308 
3309 /**
3310  * gst_audio_decoder_get_min_latency:
3311  * @dec: a #GstAudioDecoder
3312  *
3313  * Queries decoder&#39;s latency aggregation.
3314  *
3315  * Returns: aggregation latency.
3316  *
3317  * MT safe.
3318  */
3319 GstClockTime
3320 gst_audio_decoder_get_min_latency (GstAudioDecoder * dec)
3321 {
3322   GstClockTime result;
3323 
3324   g_return_val_if_fail (GST_IS_AUDIO_DECODER (dec), FALSE);
3325 
3326   GST_OBJECT_LOCK (dec);
3327   result = dec-&gt;priv-&gt;latency;
3328   GST_OBJECT_UNLOCK (dec);
3329 
3330   return result;
3331 }
3332 
3333 /**
3334  * gst_audio_decoder_set_tolerance:
3335  * @dec: a #GstAudioDecoder
3336  * @tolerance: new tolerance
3337  *
3338  * Configures decoder audio jitter tolerance threshold.
3339  *
3340  * MT safe.
3341  */
3342 void
3343 gst_audio_decoder_set_tolerance (GstAudioDecoder * dec, GstClockTime tolerance)
3344 {
3345   g_return_if_fail (GST_IS_AUDIO_DECODER (dec));
3346 
3347   GST_OBJECT_LOCK (dec);
3348   dec-&gt;priv-&gt;tolerance = tolerance;
3349   GST_OBJECT_UNLOCK (dec);
3350 }
3351 
3352 /**
3353  * gst_audio_decoder_get_tolerance:
3354  * @dec: a #GstAudioDecoder
3355  *
3356  * Queries current audio jitter tolerance threshold.
3357  *
3358  * Returns: decoder audio jitter tolerance threshold.
3359  *
3360  * MT safe.
3361  */
3362 GstClockTime
3363 gst_audio_decoder_get_tolerance (GstAudioDecoder * dec)
3364 {
3365   GstClockTime result;
3366 
3367   g_return_val_if_fail (GST_IS_AUDIO_DECODER (dec), 0);
3368 
3369   GST_OBJECT_LOCK (dec);
3370   result = dec-&gt;priv-&gt;tolerance;
3371   GST_OBJECT_UNLOCK (dec);
3372 
3373   return result;
3374 }
3375 
3376 /**
3377  * gst_audio_decoder_set_drainable:
3378  * @dec: a #GstAudioDecoder
3379  * @enabled: new state
3380  *
3381  * Configures decoder drain handling.  If drainable, subclass might
3382  * be handed a NULL buffer to have it return any leftover decoded data.
3383  * Otherwise, it is not considered so capable and will only ever be passed
3384  * real data.
3385  *
3386  * MT safe.
3387  */
3388 void
3389 gst_audio_decoder_set_drainable (GstAudioDecoder * dec, gboolean enabled)
3390 {
3391   g_return_if_fail (GST_IS_AUDIO_DECODER (dec));
3392 
3393   GST_OBJECT_LOCK (dec);
3394   dec-&gt;priv-&gt;drainable = enabled;
3395   GST_OBJECT_UNLOCK (dec);
3396 }
3397 
3398 /**
3399  * gst_audio_decoder_get_drainable:
3400  * @dec: a #GstAudioDecoder
3401  *
3402  * Queries decoder drain handling.
3403  *
3404  * Returns: TRUE if drainable handling is enabled.
3405  *
3406  * MT safe.
3407  */
3408 gboolean
3409 gst_audio_decoder_get_drainable (GstAudioDecoder * dec)
3410 {
3411   gboolean result;
3412 
3413   g_return_val_if_fail (GST_IS_AUDIO_DECODER (dec), 0);
3414 
3415   GST_OBJECT_LOCK (dec);
3416   result = dec-&gt;priv-&gt;drainable;
3417   GST_OBJECT_UNLOCK (dec);
3418 
3419   return result;
3420 }
3421 
3422 /**
3423  * gst_audio_decoder_set_needs_format:
3424  * @dec: a #GstAudioDecoder
3425  * @enabled: new state
3426  *
3427  * Configures decoder format needs.  If enabled, subclass needs to be
3428  * negotiated with format caps before it can process any data.  It will then
3429  * never be handed any data before it has been configured.
3430  * Otherwise, it might be handed data without having been configured and
3431  * is then expected being able to do so either by default
3432  * or based on the input data.
3433  *
3434  * MT safe.
3435  */
3436 void
3437 gst_audio_decoder_set_needs_format (GstAudioDecoder * dec, gboolean enabled)
3438 {
3439   g_return_if_fail (GST_IS_AUDIO_DECODER (dec));
3440 
3441   GST_OBJECT_LOCK (dec);
3442   dec-&gt;priv-&gt;needs_format = enabled;
3443   GST_OBJECT_UNLOCK (dec);
3444 }
3445 
3446 /**
3447  * gst_audio_decoder_get_needs_format:
3448  * @dec: a #GstAudioDecoder
3449  *
3450  * Queries decoder required format handling.
3451  *
3452  * Returns: TRUE if required format handling is enabled.
3453  *
3454  * MT safe.
3455  */
3456 gboolean
3457 gst_audio_decoder_get_needs_format (GstAudioDecoder * dec)
3458 {
3459   gboolean result;
3460 
3461   g_return_val_if_fail (GST_IS_AUDIO_DECODER (dec), FALSE);
3462 
3463   GST_OBJECT_LOCK (dec);
3464   result = dec-&gt;priv-&gt;needs_format;
3465   GST_OBJECT_UNLOCK (dec);
3466 
3467   return result;
3468 }
3469 
3470 /**
3471  * gst_audio_decoder_merge_tags:
3472  * @dec: a #GstAudioDecoder
3473  * @tags: (allow-none): a #GstTagList to merge, or NULL
3474  * @mode: the #GstTagMergeMode to use, usually #GST_TAG_MERGE_REPLACE
3475  *
3476  * Sets the audio decoder tags and how they should be merged with any
3477  * upstream stream tags. This will override any tags previously-set
3478  * with gst_audio_decoder_merge_tags().
3479  *
3480  * Note that this is provided for convenience, and the subclass is
3481  * not required to use this and can still do tag handling on its own.
3482  */
3483 void
3484 gst_audio_decoder_merge_tags (GstAudioDecoder * dec,
3485     const GstTagList * tags, GstTagMergeMode mode)
3486 {
3487   g_return_if_fail (GST_IS_AUDIO_DECODER (dec));
3488   g_return_if_fail (tags == NULL || GST_IS_TAG_LIST (tags));
3489   g_return_if_fail (mode != GST_TAG_MERGE_UNDEFINED);
3490 
3491   GST_AUDIO_DECODER_STREAM_LOCK (dec);
3492   if (dec-&gt;priv-&gt;taglist != tags) {
3493     if (dec-&gt;priv-&gt;taglist) {
3494       gst_tag_list_unref (dec-&gt;priv-&gt;taglist);
3495       dec-&gt;priv-&gt;taglist = NULL;
3496       dec-&gt;priv-&gt;decoder_tags_merge_mode = GST_TAG_MERGE_KEEP_ALL;
3497     }
3498     if (tags) {
3499       dec-&gt;priv-&gt;taglist = gst_tag_list_ref ((GstTagList *) tags);
3500       dec-&gt;priv-&gt;decoder_tags_merge_mode = mode;
3501     }
3502 
3503     GST_DEBUG_OBJECT (dec, &quot;setting decoder tags to %&quot; GST_PTR_FORMAT, tags);
3504   dec-&gt;priv-&gt;taglist_changed = TRUE;
3505   }
3506   GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
3507 }
3508 
3509 /**
3510  * gst_audio_decoder_allocate_output_buffer:
3511  * @dec: a #GstAudioDecoder
3512  * @size: size of the buffer
3513  *
3514  * Helper function that allocates a buffer to hold an audio frame
3515  * for @dec&#39;s current output format.
3516  *
3517  * Returns: (transfer full): allocated buffer
3518  */
3519 GstBuffer *
3520 gst_audio_decoder_allocate_output_buffer (GstAudioDecoder * dec, gsize size)
3521 {
3522   GstBuffer *buffer = NULL;
3523   gboolean needs_reconfigure = FALSE;
3524 
3525   g_return_val_if_fail (size &gt; 0, NULL);
3526 
3527   GST_DEBUG (&quot;alloc src buffer&quot;);
3528 
3529   GST_AUDIO_DECODER_STREAM_LOCK (dec);
3530 
3531   needs_reconfigure = gst_pad_check_reconfigure (dec-&gt;srcpad);
3532   if (G_UNLIKELY (dec-&gt;priv-&gt;ctx.output_format_changed ||
3533           (GST_AUDIO_INFO_IS_VALID (&amp;dec-&gt;priv-&gt;ctx.info)
3534               &amp;&amp; needs_reconfigure))) {
3535     if (!gst_audio_decoder_negotiate_unlocked (dec)) {
3536       GST_INFO_OBJECT (dec, &quot;Failed to negotiate, fallback allocation&quot;);
3537       gst_pad_mark_reconfigure (dec-&gt;srcpad);
3538       goto fallback;
3539     }
3540   }
3541 
3542   buffer =
3543       gst_buffer_new_allocate (dec-&gt;priv-&gt;ctx.allocator, size,
3544       &amp;dec-&gt;priv-&gt;ctx.params);
3545   if (!buffer) {
3546     GST_INFO_OBJECT (dec, &quot;couldn&#39;t allocate output buffer&quot;);
3547     goto fallback;
3548   }
3549 
3550   GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
3551 
3552   return buffer;
3553 fallback:
3554   buffer = gst_buffer_new_allocate (NULL, size, NULL);
3555   GST_AUDIO_DECODER_STREAM_UNLOCK (dec);
3556 
3557   return buffer;
3558 }
3559 
3560 /**
3561  * gst_audio_decoder_get_allocator:
3562  * @dec: a #GstAudioDecoder
3563  * @allocator: (out) (allow-none) (transfer full): the #GstAllocator
3564  * used
3565  * @params: (out) (allow-none) (transfer full): the
3566  * #GstAllocatorParams of @allocator
3567  *
3568  * Lets #GstAudioDecoder sub-classes to know the memory @allocator
3569  * used by the base class and its @params.
3570  *
3571  * Unref the @allocator after use it.
3572  */
3573 void
3574 gst_audio_decoder_get_allocator (GstAudioDecoder * dec,
3575     GstAllocator ** allocator, GstAllocationParams * params)
3576 {
3577   g_return_if_fail (GST_IS_AUDIO_DECODER (dec));
3578 
3579   if (allocator)
3580     *allocator = dec-&gt;priv-&gt;ctx.allocator ?
3581         gst_object_ref (dec-&gt;priv-&gt;ctx.allocator) : NULL;
3582 
3583   if (params)
3584     *params = dec-&gt;priv-&gt;ctx.params;
3585 }
3586 
3587 /**
3588  * gst_audio_decoder_set_use_default_pad_acceptcaps:
3589  * @decoder: a #GstAudioDecoder
3590  * @use: if the default pad accept-caps query handling should be used
3591  *
3592  * Lets #GstAudioDecoder sub-classes decide if they want the sink pad
3593  * to use the default pad query handler to reply to accept-caps queries.
3594  *
3595  * By setting this to true it is possible to further customize the default
3596  * handler with %GST_PAD_SET_ACCEPT_INTERSECT and
3597  * %GST_PAD_SET_ACCEPT_TEMPLATE
3598  *
3599  * Since: 1.6
3600  */
3601 void
3602 gst_audio_decoder_set_use_default_pad_acceptcaps (GstAudioDecoder * decoder,
3603     gboolean use)
3604 {
3605   decoder-&gt;priv-&gt;use_default_pad_acceptcaps = use;
3606 }
    </pre>
  </body>
</html>