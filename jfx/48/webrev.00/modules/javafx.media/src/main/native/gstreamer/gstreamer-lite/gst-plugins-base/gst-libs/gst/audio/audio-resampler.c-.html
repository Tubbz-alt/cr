<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/audio-resampler.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) &lt;2015&gt; Wim Taymans &lt;wim.taymans@gmail.com&gt;
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Library General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Library General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Library General Public
  15  * License along with this library; if not, write to the
  16  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  17  * Boston, MA 02110-1301, USA.
  18  */
  19 
  20 #ifdef HAVE_CONFIG_H
  21 #  include &quot;config.h&quot;
  22 #endif
  23 
  24 #include &lt;string.h&gt;
  25 #include &lt;stdio.h&gt;
  26 #include &lt;math.h&gt;
  27 
  28 #ifdef HAVE_ORC
  29 #include &lt;orc/orc.h&gt;
  30 #endif
  31 
  32 #include &quot;audio-resampler.h&quot;
  33 #include &quot;audio-resampler-private.h&quot;
  34 #include &quot;audio-resampler-macros.h&quot;
  35 
  36 #define MEM_ALIGN(m,a) ((gint8 *)((guintptr)((gint8 *)(m) + ((a)-1)) &amp; ~((a)-1)))
  37 #define ALIGN 16
  38 #define TAPS_OVERREAD 16
  39 
  40 GST_DEBUG_CATEGORY_STATIC (audio_resampler_debug);
  41 #define GST_CAT_DEFAULT audio_resampler_debug
  42 
  43 /**
  44  * SECTION:gstaudioresampler
  45  * @title: GstAudioResampler
  46  * @short_description: Utility structure for resampler information
  47  *
  48  * #GstAudioResampler is a structure which holds the information
  49  * required to perform various kinds of resampling filtering.
  50  *
  51  */
  52 
  53 static const gint oversample_qualities[] = {
  54   4, 4, 4, 8, 8, 16, 16, 16, 16, 32, 32
  55 };
  56 
  57 typedef struct
  58 {
  59   gdouble cutoff;
  60   gdouble downsample_cutoff_factor;
  61   gdouble stopband_attenuation;
  62   gdouble transition_bandwidth;
  63 } KaiserQualityMap;
  64 
  65 static const KaiserQualityMap kaiser_qualities[] = {
  66   {0.860, 0.96511, 60, 0.7},    /* 8 taps */
  67   {0.880, 0.96591, 65, 0.29},   /* 16 taps */
  68   {0.910, 0.96923, 70, 0.145},  /* 32 taps */
  69   {0.920, 0.97600, 80, 0.105},  /* 48 taps */
  70   {0.940, 0.97979, 85, 0.087},  /* 64 taps default quality */
  71   {0.940, 0.98085, 95, 0.077},  /* 80 taps */
  72   {0.945, 0.99471, 100, 0.068}, /* 96 taps */
  73   {0.950, 1.0, 105, 0.055},     /* 128 taps */
  74   {0.960, 1.0, 110, 0.045},     /* 160 taps */
  75   {0.968, 1.0, 115, 0.039},     /* 192 taps */
  76   {0.975, 1.0, 120, 0.0305}     /* 256 taps */
  77 };
  78 
  79 typedef struct
  80 {
  81   gint n_taps;
  82   gdouble cutoff;
  83 } BlackmanQualityMap;
  84 
  85 static const BlackmanQualityMap blackman_qualities[] = {
  86   {8, 0.5,},
  87   {16, 0.6,},
  88   {24, 0.72,},
  89   {32, 0.8,},
  90   {48, 0.85,},                  /* default */
  91   {64, 0.90,},
  92   {80, 0.92,},
  93   {96, 0.933,},
  94   {128, 0.950,},
  95   {148, 0.955,},
  96   {160, 0.960,}
  97 };
  98 
  99 #define DEFAULT_RESAMPLER_METHOD GST_AUDIO_RESAMPLER_METHOD_KAISER
 100 #define DEFAULT_QUALITY GST_AUDIO_RESAMPLER_QUALITY_DEFAULT
 101 #define DEFAULT_OPT_CUBIC_B 1.0
 102 #define DEFAULT_OPT_CUBIC_C 0.0
 103 #define DEFAULT_OPT_FILTER_MODE GST_AUDIO_RESAMPLER_FILTER_MODE_AUTO
 104 #define DEFAULT_OPT_FILTER_MODE_THRESHOLD 1048576
 105 #define DEFAULT_OPT_FILTER_INTERPOLATION GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_CUBIC
 106 #define DEFAULT_OPT_FILTER_OVERSAMPLE 8
 107 #define DEFAULT_OPT_MAX_PHASE_ERROR 0.1
 108 
 109 static gdouble
 110 get_opt_double (GstStructure * options, const gchar * name, gdouble def)
 111 {
 112   gdouble res;
 113   if (!options || !gst_structure_get_double (options, name, &amp;res))
 114     res = def;
 115   return res;
 116 }
 117 
 118 static gint
 119 get_opt_int (GstStructure * options, const gchar * name, gint def)
 120 {
 121   gint res;
 122   if (!options || !gst_structure_get_int (options, name, &amp;res))
 123     res = def;
 124   return res;
 125 }
 126 
 127 static gint
 128 get_opt_enum (GstStructure * options, const gchar * name, GType type, gint def)
 129 {
 130   gint res;
 131   if (!options || !gst_structure_get_enum (options, name, type, &amp;res))
 132     res = def;
 133   return res;
 134 }
 135 
 136 
 137 #define GET_OPT_CUTOFF(options,def) get_opt_double(options, \
 138     GST_AUDIO_RESAMPLER_OPT_CUTOFF,def)
 139 #define GET_OPT_DOWN_CUTOFF_FACTOR(options,def) get_opt_double(options, \
 140     GST_AUDIO_RESAMPLER_OPT_DOWN_CUTOFF_FACTOR, def)
 141 #define GET_OPT_STOP_ATTENUATION(options,def) get_opt_double(options, \
 142     GST_AUDIO_RESAMPLER_OPT_STOP_ATTENUATION, def)
 143 #define GET_OPT_TRANSITION_BANDWIDTH(options,def) get_opt_double(options, \
 144     GST_AUDIO_RESAMPLER_OPT_TRANSITION_BANDWIDTH, def)
 145 #define GET_OPT_CUBIC_B(options) get_opt_double(options, \
 146     GST_AUDIO_RESAMPLER_OPT_CUBIC_B, DEFAULT_OPT_CUBIC_B)
 147 #define GET_OPT_CUBIC_C(options) get_opt_double(options, \
 148     GST_AUDIO_RESAMPLER_OPT_CUBIC_C, DEFAULT_OPT_CUBIC_C)
 149 #define GET_OPT_N_TAPS(options,def) get_opt_int(options, \
 150     GST_AUDIO_RESAMPLER_OPT_N_TAPS, def)
 151 #define GET_OPT_FILTER_MODE(options) get_opt_enum(options, \
 152     GST_AUDIO_RESAMPLER_OPT_FILTER_MODE, GST_TYPE_AUDIO_RESAMPLER_FILTER_MODE, \
 153     DEFAULT_OPT_FILTER_MODE)
 154 #define GET_OPT_FILTER_MODE_THRESHOLD(options) get_opt_int(options, \
 155     GST_AUDIO_RESAMPLER_OPT_FILTER_MODE_THRESHOLD, DEFAULT_OPT_FILTER_MODE_THRESHOLD)
 156 #define GET_OPT_FILTER_INTERPOLATION(options) get_opt_enum(options, \
 157     GST_AUDIO_RESAMPLER_OPT_FILTER_INTERPOLATION, GST_TYPE_AUDIO_RESAMPLER_FILTER_INTERPOLATION, \
 158     DEFAULT_OPT_FILTER_INTERPOLATION)
 159 #define GET_OPT_FILTER_OVERSAMPLE(options) get_opt_int(options, \
 160     GST_AUDIO_RESAMPLER_OPT_FILTER_OVERSAMPLE, DEFAULT_OPT_FILTER_OVERSAMPLE)
 161 #define GET_OPT_MAX_PHASE_ERROR(options) get_opt_double(options, \
 162     GST_AUDIO_RESAMPLER_OPT_MAX_PHASE_ERROR, DEFAULT_OPT_MAX_PHASE_ERROR)
 163 
 164 #include &quot;dbesi0.c&quot;
 165 #define bessel dbesi0
 166 
 167 static inline gdouble
 168 get_linear_tap (gdouble x, gint n_taps)
 169 {
 170   gdouble res = GST_ROUND_UP_2 (n_taps) / 2 - fabs (x);
 171   return res;
 172 }
 173 
 174 static inline gdouble
 175 get_cubic_tap (gdouble x, gint n_taps, gdouble b, gdouble c)
 176 {
 177   gdouble res, a, a2, a3;
 178 
 179   a = fabs (x * 4.0) / n_taps;
 180   a2 = a * a;
 181   a3 = a2 * a;
 182 
 183   if (a &lt;= 1.0)
 184     res = ((12.0 - 9.0 * b - 6.0 * c) * a3 +
 185         (-18.0 + 12.0 * b + 6.0 * c) * a2 + (6.0 - 2.0 * b)) / 6.0;
 186   else if (a &lt;= 2.0)
 187     res = ((-b - 6.0 * c) * a3 +
 188         (6.0 * b + 30.0 * c) * a2 +
 189         (-12.0 * b - 48.0 * c) * a + (8.0 * b + 24.0 * c)) / 6.0;
 190   else
 191     res = 0.0;
 192 
 193   return res;
 194 }
 195 
 196 static inline gdouble
 197 get_blackman_nuttall_tap (gdouble x, gint n_taps, gdouble Fc)
 198 {
 199   gdouble s, y, w;
 200 
 201   y = G_PI * x;
 202   s = (y == 0.0 ? Fc : sin (y * Fc) / y);
 203 
 204   w = 2.0 * y / n_taps + G_PI;
 205   return s * (0.3635819 - 0.4891775 * cos (w) + 0.1365995 * cos (2 * w) -
 206       0.0106411 * cos (3 * w));
 207 }
 208 
 209 static inline gdouble
 210 get_kaiser_tap (gdouble x, gint n_taps, gdouble Fc, gdouble beta)
 211 {
 212   gdouble s, y, w;
 213 
 214   y = G_PI * x;
 215   s = (y == 0.0 ? Fc : sin (y * Fc) / y);
 216 
 217   w = 2.0 * x / n_taps;
 218   return s * bessel (beta * sqrt (MAX (1 - w * w, 0)));
 219 }
 220 
 221 #define MAKE_CONVERT_TAPS_INT_FUNC(type, precision)                     \
 222 static void                                                             \
 223 convert_taps_##type##_c (gdouble *tmp_taps, gpointer taps,              \
 224     gdouble weight, gint n_taps)                                        \
 225 {                                                                       \
 226   gint64 one = (1LL &lt;&lt; precision) - 1;                                  \
 227   type *t = taps;                                                       \
 228   gdouble multiplier = one;                                             \
 229   gint i, j;                                                            \
 230   gdouble offset, l_offset, h_offset;                                   \
 231   gboolean exact = FALSE;                                               \
 232   /* Round to integer, but with an adjustable bias that we use to */    \
 233   /* eliminate the DC error. */                                         \
 234   l_offset = 0.0;                                                       \
 235   h_offset = 1.0;                                                       \
 236   offset = 0.5;                                                         \
 237   for (i = 0; i &lt; 32; i++) {                                            \
 238     gint64 sum = 0;                                                     \
 239     for (j = 0; j &lt; n_taps; j++)                                        \
 240       sum += floor (offset + tmp_taps[j] * multiplier / weight);        \
 241     if (sum == one) {                                                   \
 242       exact = TRUE;                                                     \
 243       break;                                                            \
 244     }                                                                   \
 245     if (l_offset == h_offset)                                           \
 246       break;                                                            \
 247     if (sum &lt; one) {                                                    \
 248       if (offset &gt; l_offset)                                            \
 249         l_offset = offset;                                              \
 250       offset += (h_offset - l_offset) / 2;                              \
 251     } else {                                                            \
 252       if (offset &lt; h_offset)                                            \
 253         h_offset = offset;                                              \
 254       offset -= (h_offset - l_offset) / 2;                              \
 255     }                                                                   \
 256   }                                                                     \
 257   for (j = 0; j &lt; n_taps; j++)                                          \
 258     t[j] = floor (offset + tmp_taps[j] * multiplier / weight);          \
 259   if (!exact)                                                           \
 260     GST_WARNING (&quot;can&#39;t find exact taps&quot;);                              \
 261 }
 262 
 263 #define MAKE_CONVERT_TAPS_FLOAT_FUNC(type)                              \
 264 static void                                                             \
 265 convert_taps_##type##_c (gdouble *tmp_taps, gpointer taps,              \
 266     gdouble weight, gint n_taps)                                        \
 267 {                                                                       \
 268   gint i;                                                               \
 269   type *t = taps;                                                       \
 270   for (i = 0; i &lt; n_taps; i++)                                          \
 271     t[i] = tmp_taps[i] / weight;                                        \
 272 }
 273 
 274 MAKE_CONVERT_TAPS_INT_FUNC (gint16, PRECISION_S16);
 275 MAKE_CONVERT_TAPS_INT_FUNC (gint32, PRECISION_S32);
 276 MAKE_CONVERT_TAPS_FLOAT_FUNC (gfloat);
 277 MAKE_CONVERT_TAPS_FLOAT_FUNC (gdouble);
 278 
 279 static ConvertTapsFunc convert_taps_funcs[] = {
 280   convert_taps_gint16_c,
 281   convert_taps_gint32_c,
 282   convert_taps_gfloat_c,
 283   convert_taps_gdouble_c
 284 };
 285 
 286 #define convert_taps_gint16   convert_taps_funcs[0]
 287 #define convert_taps_gint32   convert_taps_funcs[1]
 288 #define convert_taps_gfloat   convert_taps_funcs[2]
 289 #define convert_taps_gdouble  convert_taps_funcs[3]
 290 
 291 static void
 292 make_taps (GstAudioResampler * resampler, gdouble * res, gdouble x, gint n_taps)
 293 {
 294   gdouble weight = 0.0, *tmp_taps = resampler-&gt;tmp_taps;
 295   gint i;
 296 
 297   switch (resampler-&gt;method) {
 298     case GST_AUDIO_RESAMPLER_METHOD_NEAREST:
 299       break;
 300 
 301     case GST_AUDIO_RESAMPLER_METHOD_LINEAR:
 302       for (i = 0; i &lt; n_taps; i++)
 303         weight += tmp_taps[i] = get_linear_tap (x + i, resampler-&gt;n_taps);
 304       break;
 305 
 306     case GST_AUDIO_RESAMPLER_METHOD_CUBIC:
 307       for (i = 0; i &lt; n_taps; i++)
 308         weight += tmp_taps[i] = get_cubic_tap (x + i, resampler-&gt;n_taps,
 309             resampler-&gt;b, resampler-&gt;c);
 310       break;
 311 
 312     case GST_AUDIO_RESAMPLER_METHOD_BLACKMAN_NUTTALL:
 313       for (i = 0; i &lt; n_taps; i++)
 314         weight += tmp_taps[i] =
 315             get_blackman_nuttall_tap (x + i,
 316             resampler-&gt;n_taps, resampler-&gt;cutoff);
 317       break;
 318 
 319     case GST_AUDIO_RESAMPLER_METHOD_KAISER:
 320       for (i = 0; i &lt; n_taps; i++)
 321         weight += tmp_taps[i] =
 322             get_kaiser_tap (x + i, resampler-&gt;n_taps,
 323             resampler-&gt;cutoff, resampler-&gt;kaiser_beta);
 324       break;
 325   }
 326   resampler-&gt;convert_taps (tmp_taps, res, weight, n_taps);
 327 }
 328 
 329 #define MAKE_COEFF_LINEAR_INT_FUNC(type,type2,prec)                     \
 330 static inline void                                                      \
 331 make_coeff_##type##_linear (gint num, gint denom, type *icoeff)         \
 332 {                                                                       \
 333   type x = ((gint64)num &lt;&lt; prec) / denom;                               \
 334   icoeff[0] = icoeff[2] = x;                                            \
 335   icoeff[1] = icoeff[3] = (type)(((type2)1 &lt;&lt; prec)-1)  - x;            \
 336 }
 337 #define MAKE_COEFF_LINEAR_FLOAT_FUNC(type)                              \
 338 static inline void                                                      \
 339 make_coeff_##type##_linear (gint num, gint denom, type *icoeff)         \
 340 {                                                                       \
 341   type x = (type)num / denom;                                           \
 342   icoeff[0] = icoeff[2] = x;                                            \
 343   icoeff[1] = icoeff[3] = (type)1.0 - x;                                \
 344 }
 345 MAKE_COEFF_LINEAR_INT_FUNC (gint16, gint32, PRECISION_S16);
 346 MAKE_COEFF_LINEAR_INT_FUNC (gint32, gint64, PRECISION_S32);
 347 MAKE_COEFF_LINEAR_FLOAT_FUNC (gfloat);
 348 MAKE_COEFF_LINEAR_FLOAT_FUNC (gdouble);
 349 
 350 #define MAKE_COEFF_CUBIC_INT_FUNC(type,type2,prec)                      \
 351 static inline void                                                      \
 352 make_coeff_##type##_cubic (gint num, gint denom, type *icoeff)          \
 353 {                                                                       \
 354   type2 one = ((type2)1 &lt;&lt; prec) - 1;                                   \
 355   type2 x = ((gint64) num &lt;&lt; prec) / denom;                             \
 356   type2 x2 = (x * x) &gt;&gt; prec;                                           \
 357   type2 x3 = (x2 * x) &gt;&gt; prec;                                          \
 358   icoeff[0] = (((x3 - x) &lt;&lt; prec) / 6) &gt;&gt; prec;                         \
 359   icoeff[1] = x + ((x2 - x3) &gt;&gt; 1);                                     \
 360   icoeff[3] = -(((x &lt;&lt; prec) / 3) &gt;&gt; prec) +                            \
 361             (x2 &gt;&gt; 1) - (((x3 &lt;&lt; prec) / 6) &gt;&gt; prec);                   \
 362   icoeff[2] = one - icoeff[0] - icoeff[1] - icoeff[3];                  \
 363 }
 364 #define MAKE_COEFF_CUBIC_FLOAT_FUNC(type)                               \
 365 static inline void                                                      \
 366 make_coeff_##type##_cubic (gint num, gint denom, type *icoeff)          \
 367 {                                                                       \
 368   type x = (type) num / denom, x2 = x * x, x3 = x2 * x;                 \
 369   icoeff[0] = 0.16667f * (x3 - x);                                      \
 370   icoeff[1] = x + 0.5f * (x2 - x3);                                     \
 371   icoeff[3] = -0.33333f * x + 0.5f * x2 - 0.16667f * x3;                \
 372   icoeff[2] = (type)1.0 - icoeff[0] - icoeff[1] - icoeff[3];            \
 373 }
 374 MAKE_COEFF_CUBIC_INT_FUNC (gint16, gint32, PRECISION_S16);
 375 MAKE_COEFF_CUBIC_INT_FUNC (gint32, gint64, PRECISION_S32);
 376 MAKE_COEFF_CUBIC_FLOAT_FUNC (gfloat);
 377 MAKE_COEFF_CUBIC_FLOAT_FUNC (gdouble);
 378 
 379 #define INTERPOLATE_INT_LINEAR_FUNC(type,type2,prec,limit)      \
 380 static inline void                                              \
 381 interpolate_##type##_linear_c (gpointer op, const gpointer ap,  \
 382     gint len, const gpointer icp, gint astride)                 \
 383 {                                                               \
 384   gint i;                                                       \
 385   type *o = op, *a = ap, *ic = icp;                             \
 386   type2 tmp, c0 = ic[0];                                        \
 387   const type *c[2] = {(type*)((gint8*)a + 0*astride),           \
 388                       (type*)((gint8*)a + 1*astride)};          \
 389                                                                 \
 390   for (i = 0; i &lt; len; i++) {                                   \
 391     tmp = ((type2)c[0][i] - (type2)c[1][i]) * c0 +              \
 392          (((type2)c[1][i]) &lt;&lt; (prec));                          \
 393     o[i] = (tmp + ((type2)1 &lt;&lt; ((prec) - 1))) &gt;&gt; (prec);        \
 394   }                                                             \
 395 }
 396 #define INTERPOLATE_FLOAT_LINEAR_FUNC(type)                     \
 397 static inline void                                              \
 398 interpolate_##type##_linear_c (gpointer op, const gpointer ap,  \
 399     gint len, const gpointer icp, gint astride)                 \
 400 {                                                               \
 401   gint i;                                                       \
 402   type *o = op, *a = ap, *ic = icp;                             \
 403   type c0 = ic[0];                                              \
 404   const type *c[2] = {(type*)((gint8*)a + 0*astride),           \
 405                       (type*)((gint8*)a + 1*astride)};          \
 406                                                                 \
 407   for (i = 0; i &lt; len; i++) {                                   \
 408     o[i] = (c[0][i] - c[1][i]) * c0 + c[1][i];                  \
 409   }                                                             \
 410 }
 411 
 412 INTERPOLATE_INT_LINEAR_FUNC (gint16, gint32, PRECISION_S16, (gint32) 1 &lt;&lt; 15);
 413 INTERPOLATE_INT_LINEAR_FUNC (gint32, gint64, PRECISION_S32, (gint64) 1 &lt;&lt; 31);
 414 INTERPOLATE_FLOAT_LINEAR_FUNC (gfloat);
 415 INTERPOLATE_FLOAT_LINEAR_FUNC (gdouble);
 416 
 417 #define INTERPOLATE_INT_CUBIC_FUNC(type,type2,prec,limit)       \
 418 static inline void                                              \
 419 interpolate_##type##_cubic_c (gpointer op, const gpointer ap,   \
 420     gint len, const gpointer icp, gint astride)                 \
 421 {                                                               \
 422   gint i;                                                       \
 423   type *o = op, *a = ap, *ic = icp;                             \
 424   type2 tmp, c0 = ic[0], c1 = ic[1], c2 = ic[2], c3 = ic[3];    \
 425   const type *c[4] = {(type*)((gint8*)a + 0*astride),           \
 426                       (type*)((gint8*)a + 1*astride),           \
 427                       (type*)((gint8*)a + 2*astride),           \
 428                       (type*)((gint8*)a + 3*astride)};          \
 429                                                                 \
 430   for (i = 0; i &lt; len; i++) {                                   \
 431     tmp = (type2)c[0][i] * c0 + (type2)c[1][i] * c1 +           \
 432           (type2)c[2][i] * c2 + (type2)c[3][i] * c3;            \
 433     tmp = (tmp + ((type2)1 &lt;&lt; ((prec) - 1))) &gt;&gt; (prec);         \
 434     o[i] = CLAMP (tmp, -(limit), (limit) - 1);                  \
 435   }                                                             \
 436 }
 437 #define INTERPOLATE_FLOAT_CUBIC_FUNC(type)                      \
 438 static inline void                                              \
 439 interpolate_##type##_cubic_c (gpointer op, const gpointer ap,   \
 440     gint len, const gpointer icp, gint astride)                 \
 441 {                                                               \
 442   gint i;                                                       \
 443   type *o = op, *a = ap, *ic = icp;                             \
 444   type c0 = ic[0], c1 = ic[1], c2 = ic[2], c3 = ic[3];          \
 445   const type *c[4] = {(type*)((gint8*)a + 0*astride),           \
 446                       (type*)((gint8*)a + 1*astride),           \
 447                       (type*)((gint8*)a + 2*astride),           \
 448                       (type*)((gint8*)a + 3*astride)};          \
 449                                                                 \
 450   for (i = 0; i &lt; len; i++) {                                   \
 451     o[i] = c[0][i] * c0 + c[1][i] * c1 +                        \
 452            c[2][i] * c2 + c[3][i] * c3;                         \
 453   }                                                             \
 454 }
 455 
 456 INTERPOLATE_INT_CUBIC_FUNC (gint16, gint32, PRECISION_S16, (gint32) 1 &lt;&lt; 15);
 457 INTERPOLATE_INT_CUBIC_FUNC (gint32, gint64, PRECISION_S32, (gint64) 1 &lt;&lt; 31);
 458 INTERPOLATE_FLOAT_CUBIC_FUNC (gfloat);
 459 INTERPOLATE_FLOAT_CUBIC_FUNC (gdouble);
 460 
 461 static InterpolateFunc interpolate_funcs[] = {
 462   interpolate_gint16_linear_c,
 463   interpolate_gint32_linear_c,
 464   interpolate_gfloat_linear_c,
 465   interpolate_gdouble_linear_c,
 466 
 467   interpolate_gint16_cubic_c,
 468   interpolate_gint32_cubic_c,
 469   interpolate_gfloat_cubic_c,
 470   interpolate_gdouble_cubic_c,
 471 };
 472 
 473 #define interpolate_gint16_linear  interpolate_funcs[0]
 474 #define interpolate_gint32_linear  interpolate_funcs[1]
 475 #define interpolate_gfloat_linear  interpolate_funcs[2]
 476 #define interpolate_gdouble_linear interpolate_funcs[3]
 477 
 478 #define interpolate_gint16_cubic   interpolate_funcs[4]
 479 #define interpolate_gint32_cubic   interpolate_funcs[5]
 480 #define interpolate_gfloat_cubic   interpolate_funcs[6]
 481 #define interpolate_gdouble_cubic  interpolate_funcs[7]
 482 
 483 #define GET_TAPS_NEAREST_FUNC(type)                                             \
 484 static inline gpointer                                                          \
 485 get_taps_##type##_nearest (GstAudioResampler * resampler,                       \
 486     gint *samp_index, gint *samp_phase, type icoeff[4])                         \
 487 {                                                                               \
 488   gint out_rate = resampler-&gt;out_rate;                                          \
 489   *samp_index += resampler-&gt;samp_inc;                                           \
 490   *samp_phase += resampler-&gt;samp_frac;                                          \
 491   if (*samp_phase &gt;= out_rate) {                                                \
 492     *samp_phase -= out_rate;                                                    \
 493     *samp_index += 1;                                                           \
 494   }                                                                             \
 495   return NULL;                                                                  \
 496 }
 497 GET_TAPS_NEAREST_FUNC (gint16);
 498 GET_TAPS_NEAREST_FUNC (gint32);
 499 GET_TAPS_NEAREST_FUNC (gfloat);
 500 GET_TAPS_NEAREST_FUNC (gdouble);
 501 
 502 #define get_taps_gint16_nearest get_taps_gint16_nearest
 503 #define get_taps_gint32_nearest get_taps_gint32_nearest
 504 #define get_taps_gfloat_nearest get_taps_gfloat_nearest
 505 #define get_taps_gdouble_nearest get_taps_gdouble_nearest
 506 
 507 #define GET_TAPS_FULL_FUNC(type)                                                \
 508 DECL_GET_TAPS_FULL_FUNC(type)                                                   \
 509 {                                                                               \
 510   gpointer res;                                                                 \
 511   gint out_rate = resampler-&gt;out_rate;                                          \
 512   gint n_phases = resampler-&gt;n_phases;                                          \
 513   gint phase = (n_phases == out_rate ? *samp_phase :                            \
 514       ((gint64)*samp_phase * n_phases) / out_rate);                             \
 515                                                                                 \
 516   res = resampler-&gt;cached_phases[phase];                                        \
 517   if (G_UNLIKELY (res == NULL)) {                                               \
 518     res = (gint8 *) resampler-&gt;cached_taps +                                    \
 519                         phase * resampler-&gt;cached_taps_stride;                  \
 520     switch (resampler-&gt;filter_interpolation) {                                  \
 521       case GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_NONE:                       \
 522       {                                                                         \
 523         gdouble x;                                                              \
 524         gint n_taps = resampler-&gt;n_taps;                                        \
 525                                                                                 \
 526         x = 1.0 - n_taps / 2 - (gdouble) phase / n_phases;                      \
 527         make_taps (resampler, res, x, n_taps);                                  \
 528         break;                                                                  \
 529       }                                                                         \
 530       default:                                                                  \
 531       {                                                                         \
 532         gint offset, pos, frac;                                                 \
 533         gint oversample = resampler-&gt;oversample;                                \
 534         gint taps_stride = resampler-&gt;taps_stride;                              \
 535         gint n_taps = resampler-&gt;n_taps;                                        \
 536         type ic[4], *taps;                                                      \
 537                                                                                 \
 538         pos = phase * oversample;                                               \
 539         offset = (oversample - 1) - pos / n_phases;                             \
 540         frac = pos % n_phases;                                                  \
 541                                                                                 \
 542         taps = (type *) ((gint8 *) resampler-&gt;taps + offset * taps_stride);     \
 543                                                                                 \
 544         switch (resampler-&gt;filter_interpolation) {                              \
 545           default:                                                              \
 546           case GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_LINEAR:                 \
 547             make_coeff_##type##_linear (frac, n_phases, ic);                    \
 548             break;                                                              \
 549           case GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_CUBIC:                  \
 550             make_coeff_##type##_cubic (frac, n_phases, ic);                     \
 551             break;                                                              \
 552         }                                                                       \
 553         resampler-&gt;interpolate (res, taps, n_taps, ic, taps_stride);            \
 554       }                                                                         \
 555     }                                                                           \
 556     resampler-&gt;cached_phases[phase] = res;                                      \
 557   }                                                                             \
 558   *samp_index += resampler-&gt;samp_inc;                                           \
 559   *samp_phase += resampler-&gt;samp_frac;                                          \
 560   if (*samp_phase &gt;= out_rate) {                                                \
 561     *samp_phase -= out_rate;                                                    \
 562     *samp_index += 1;                                                           \
 563   }                                                                             \
 564   return res;                                                                   \
 565 }
 566 GET_TAPS_FULL_FUNC (gint16);
 567 GET_TAPS_FULL_FUNC (gint32);
 568 GET_TAPS_FULL_FUNC (gfloat);
 569 GET_TAPS_FULL_FUNC (gdouble);
 570 
 571 #define GET_TAPS_INTERPOLATE_FUNC(type,inter)                   \
 572 DECL_GET_TAPS_INTERPOLATE_FUNC (type, inter)                    \
 573 {                                                               \
 574   gpointer res;                                                 \
 575   gint out_rate = resampler-&gt;out_rate;                          \
 576   gint offset, frac, pos;                                       \
 577   gint oversample = resampler-&gt;oversample;                      \
 578   gint taps_stride = resampler-&gt;taps_stride;                    \
 579                                                                 \
 580   pos = *samp_phase * oversample;                               \
 581   offset = (oversample - 1) - pos / out_rate;                   \
 582   frac = pos % out_rate;                                        \
 583                                                                 \
 584   res = (gint8 *) resampler-&gt;taps + offset * taps_stride;       \
 585   make_coeff_##type##_##inter (frac, out_rate, icoeff);         \
 586                                                                 \
 587   *samp_index += resampler-&gt;samp_inc;                           \
 588   *samp_phase += resampler-&gt;samp_frac;                          \
 589   if (*samp_phase &gt;= out_rate) {                                \
 590     *samp_phase -= out_rate;                                    \
 591     *samp_index += 1;                                           \
 592   }                                                             \
 593   return res;                                                   \
 594 }
 595 
 596 GET_TAPS_INTERPOLATE_FUNC (gint16, linear);
 597 GET_TAPS_INTERPOLATE_FUNC (gint32, linear);
 598 GET_TAPS_INTERPOLATE_FUNC (gfloat, linear);
 599 GET_TAPS_INTERPOLATE_FUNC (gdouble, linear);
 600 
 601 GET_TAPS_INTERPOLATE_FUNC (gint16, cubic);
 602 GET_TAPS_INTERPOLATE_FUNC (gint32, cubic);
 603 GET_TAPS_INTERPOLATE_FUNC (gfloat, cubic);
 604 GET_TAPS_INTERPOLATE_FUNC (gdouble, cubic);
 605 
 606 #define INNER_PRODUCT_NEAREST_FUNC(type)                        \
 607 static inline void                                              \
 608 inner_product_##type##_nearest_1_c (type * o, const type * a,   \
 609     const type * b, gint len, const type *ic, gint bstride)     \
 610 {                                                               \
 611   *o = *a;                                                      \
 612 }
 613 INNER_PRODUCT_NEAREST_FUNC (gint16);
 614 INNER_PRODUCT_NEAREST_FUNC (gint32);
 615 INNER_PRODUCT_NEAREST_FUNC (gfloat);
 616 INNER_PRODUCT_NEAREST_FUNC (gdouble);
 617 
 618 #define INNER_PRODUCT_INT_FULL_FUNC(type,type2,prec,limit)      \
 619 static inline void                                              \
 620 inner_product_##type##_full_1_c (type * o, const type * a,      \
 621     const type * b, gint len, const type *ic, gint bstride)     \
 622 {                                                               \
 623   gint i;                                                       \
 624   type2 res[4] = { 0, 0, 0, 0 };                                \
 625                                                                 \
 626   for (i = 0; i &lt; len; i += 4) {                                \
 627     res[0] += (type2) a[i + 0] * (type2) b[i + 0];              \
 628     res[1] += (type2) a[i + 1] * (type2) b[i + 1];              \
 629     res[2] += (type2) a[i + 2] * (type2) b[i + 2];              \
 630     res[3] += (type2) a[i + 3] * (type2) b[i + 3];              \
 631   }                                                             \
 632   res[0] = res[0] + res[1] + res[2] + res[3];                   \
 633   res[0] = (res[0] + ((type2)1 &lt;&lt; ((prec) - 1))) &gt;&gt; (prec);     \
 634   *o = CLAMP (res[0], -(limit), (limit) - 1);                   \
 635 }
 636 
 637 INNER_PRODUCT_INT_FULL_FUNC (gint16, gint32, PRECISION_S16, (gint32) 1 &lt;&lt; 15);
 638 INNER_PRODUCT_INT_FULL_FUNC (gint32, gint64, PRECISION_S32, (gint64) 1 &lt;&lt; 31);
 639 
 640 #define INNER_PRODUCT_INT_LINEAR_FUNC(type,type2,prec,limit)    \
 641 static inline void                                              \
 642 inner_product_##type##_linear_1_c (type * o, const type * a,    \
 643     const type * b, gint len, const type *ic, gint bstride)     \
 644 {                                                               \
 645   gint i;                                                       \
 646   type2 res[4] = { 0, 0, 0, 0 }, c0 = ic[0];                    \
 647   const type *c[2] = {(type*)((gint8*)b + 0*bstride),           \
 648                       (type*)((gint8*)b + 1*bstride)};          \
 649                                                                 \
 650   for (i = 0; i &lt; len; i += 2) {                                \
 651     res[0] += (type2) a[i + 0] * (type2) c[0][i + 0];           \
 652     res[1] += (type2) a[i + 0] * (type2) c[1][i + 0];           \
 653     res[2] += (type2) a[i + 1] * (type2) c[0][i + 1];           \
 654     res[3] += (type2) a[i + 1] * (type2) c[1][i + 1];           \
 655   }                                                             \
 656   res[0] = (res[0] + res[2]) &gt;&gt; (prec);                         \
 657   res[1] = (res[1] + res[3]) &gt;&gt; (prec);                         \
 658   res[0] = ((type2)(type)res[0] - (type2)(type)res[1]) * c0 +   \
 659            ((type2)(type)res[1] &lt;&lt; (prec));                     \
 660   res[0] = (res[0] + ((type2)1 &lt;&lt; ((prec) - 1))) &gt;&gt; (prec);     \
 661   *o = CLAMP (res[0], -(limit), (limit) - 1);                   \
 662 }
 663 
 664 INNER_PRODUCT_INT_LINEAR_FUNC (gint16, gint32, PRECISION_S16, (gint32) 1 &lt;&lt; 15);
 665 INNER_PRODUCT_INT_LINEAR_FUNC (gint32, gint64, PRECISION_S32, (gint64) 1 &lt;&lt; 31);
 666 
 667 #define INNER_PRODUCT_INT_CUBIC_FUNC(type,type2,prec,limit)     \
 668 static inline void                                              \
 669 inner_product_##type##_cubic_1_c (type * o, const type * a,     \
 670     const type * b, gint len, const type *ic, gint bstride)     \
 671 {                                                               \
 672   gint i;                                                       \
 673   type2 res[4] = { 0, 0, 0, 0 };                                \
 674   const type *c[4] = {(type*)((gint8*)b + 0*bstride),           \
 675                       (type*)((gint8*)b + 1*bstride),           \
 676                       (type*)((gint8*)b + 2*bstride),           \
 677                       (type*)((gint8*)b + 3*bstride)};          \
 678                                                                 \
 679   for (i = 0; i &lt; len; i++) {                                   \
 680     res[0] += (type2) a[i] * (type2) c[0][i];                   \
 681     res[1] += (type2) a[i] * (type2) c[1][i];                   \
 682     res[2] += (type2) a[i] * (type2) c[2][i];                   \
 683     res[3] += (type2) a[i] * (type2) c[3][i];                   \
 684   }                                                             \
 685   res[0] = (type2)(type)(res[0] &gt;&gt; (prec)) * (type2) ic[0] +    \
 686            (type2)(type)(res[1] &gt;&gt; (prec)) * (type2) ic[1] +    \
 687            (type2)(type)(res[2] &gt;&gt; (prec)) * (type2) ic[2] +    \
 688            (type2)(type)(res[3] &gt;&gt; (prec)) * (type2) ic[3];     \
 689   res[0] = (res[0] + ((type2)1 &lt;&lt; ((prec) - 1))) &gt;&gt; (prec);     \
 690   *o = CLAMP (res[0], -(limit), (limit) - 1);                   \
 691 }
 692 
 693 INNER_PRODUCT_INT_CUBIC_FUNC (gint16, gint32, PRECISION_S16, (gint32) 1 &lt;&lt; 15);
 694 INNER_PRODUCT_INT_CUBIC_FUNC (gint32, gint64, PRECISION_S32, (gint64) 1 &lt;&lt; 31);
 695 
 696 #define INNER_PRODUCT_FLOAT_FULL_FUNC(type)                     \
 697 static inline void                                              \
 698 inner_product_##type##_full_1_c (type * o, const type * a,      \
 699     const type * b, gint len, const type *ic, gint bstride)     \
 700 {                                                               \
 701   gint i;                                                       \
 702   type res[4] = { 0.0, 0.0, 0.0, 0.0 };                         \
 703                                                                 \
 704   for (i = 0; i &lt; len; i += 4) {                                \
 705     res[0] += a[i + 0] * b[i + 0];                              \
 706     res[1] += a[i + 1] * b[i + 1];                              \
 707     res[2] += a[i + 2] * b[i + 2];                              \
 708     res[3] += a[i + 3] * b[i + 3];                              \
 709   }                                                             \
 710   *o = res[0] + res[1] + res[2] + res[3];                       \
 711 }
 712 
 713 INNER_PRODUCT_FLOAT_FULL_FUNC (gfloat);
 714 INNER_PRODUCT_FLOAT_FULL_FUNC (gdouble);
 715 
 716 #define INNER_PRODUCT_FLOAT_LINEAR_FUNC(type)                   \
 717 static inline void                                              \
 718 inner_product_##type##_linear_1_c (type * o, const type * a,    \
 719     const type * b, gint len, const type *ic, gint bstride)     \
 720 {                                                               \
 721   gint i;                                                       \
 722   type res[4] = { 0.0, 0.0, 0.0, 0.0 };                         \
 723   const type *c[2] = {(type*)((gint8*)b + 0*bstride),           \
 724                       (type*)((gint8*)b + 1*bstride)};          \
 725                                                                 \
 726   for (i = 0; i &lt; len; i += 2) {                                \
 727     res[0] += a[i + 0] * c[0][i + 0];                           \
 728     res[1] += a[i + 0] * c[1][i + 0];                           \
 729     res[2] += a[i + 1] * c[0][i + 1];                           \
 730     res[3] += a[i + 1] * c[1][i + 1];                           \
 731   }                                                             \
 732   res[0] += res[2];                                             \
 733   res[1] += res[3];                                             \
 734   *o = (res[0] - res[1]) * ic[0] + res[1];                      \
 735 }
 736 INNER_PRODUCT_FLOAT_LINEAR_FUNC (gfloat);
 737 INNER_PRODUCT_FLOAT_LINEAR_FUNC (gdouble);
 738 
 739 #define INNER_PRODUCT_FLOAT_CUBIC_FUNC(type)                    \
 740 static inline void                                              \
 741 inner_product_##type##_cubic_1_c (type * o, const type * a,     \
 742     const type * b, gint len, const type *ic, gint bstride)     \
 743 {                                                               \
 744   gint i;                                                       \
 745   type res[4] = { 0.0, 0.0, 0.0, 0.0 };                         \
 746   const type *c[4] = {(type*)((gint8*)b + 0*bstride),           \
 747                       (type*)((gint8*)b + 1*bstride),           \
 748                       (type*)((gint8*)b + 2*bstride),           \
 749                       (type*)((gint8*)b + 3*bstride)};          \
 750                                                                 \
 751   for (i = 0; i &lt; len; i++) {                                   \
 752     res[0] += a[i] * c[0][i];                                   \
 753     res[1] += a[i] * c[1][i];                                   \
 754     res[2] += a[i] * c[2][i];                                   \
 755     res[3] += a[i] * c[3][i];                                   \
 756   }                                                             \
 757   *o = res[0] * ic[0] + res[1] * ic[1] +                        \
 758        res[2] * ic[2] + res[3] * ic[3];                         \
 759 }
 760 INNER_PRODUCT_FLOAT_CUBIC_FUNC (gfloat);
 761 INNER_PRODUCT_FLOAT_CUBIC_FUNC (gdouble);
 762 
 763 MAKE_RESAMPLE_FUNC_STATIC (gint16, nearest, 1, c);
 764 MAKE_RESAMPLE_FUNC_STATIC (gint32, nearest, 1, c);
 765 MAKE_RESAMPLE_FUNC_STATIC (gfloat, nearest, 1, c);
 766 MAKE_RESAMPLE_FUNC_STATIC (gdouble, nearest, 1, c);
 767 
 768 MAKE_RESAMPLE_FUNC_STATIC (gint16, full, 1, c);
 769 MAKE_RESAMPLE_FUNC_STATIC (gint32, full, 1, c);
 770 MAKE_RESAMPLE_FUNC_STATIC (gfloat, full, 1, c);
 771 MAKE_RESAMPLE_FUNC_STATIC (gdouble, full, 1, c);
 772 
 773 MAKE_RESAMPLE_FUNC_STATIC (gint16, linear, 1, c);
 774 MAKE_RESAMPLE_FUNC_STATIC (gint32, linear, 1, c);
 775 MAKE_RESAMPLE_FUNC_STATIC (gfloat, linear, 1, c);
 776 MAKE_RESAMPLE_FUNC_STATIC (gdouble, linear, 1, c);
 777 
 778 MAKE_RESAMPLE_FUNC_STATIC (gint16, cubic, 1, c);
 779 MAKE_RESAMPLE_FUNC_STATIC (gint32, cubic, 1, c);
 780 MAKE_RESAMPLE_FUNC_STATIC (gfloat, cubic, 1, c);
 781 MAKE_RESAMPLE_FUNC_STATIC (gdouble, cubic, 1, c);
 782 
 783 static ResampleFunc resample_funcs[] = {
 784   resample_gint16_nearest_1_c,
 785   resample_gint32_nearest_1_c,
 786   resample_gfloat_nearest_1_c,
 787   resample_gdouble_nearest_1_c,
 788 
 789   resample_gint16_full_1_c,
 790   resample_gint32_full_1_c,
 791   resample_gfloat_full_1_c,
 792   resample_gdouble_full_1_c,
 793 
 794   resample_gint16_linear_1_c,
 795   resample_gint32_linear_1_c,
 796   resample_gfloat_linear_1_c,
 797   resample_gdouble_linear_1_c,
 798 
 799   resample_gint16_cubic_1_c,
 800   resample_gint32_cubic_1_c,
 801   resample_gfloat_cubic_1_c,
 802   resample_gdouble_cubic_1_c,
 803 };
 804 
 805 #define resample_gint16_nearest_1 resample_funcs[0]
 806 #define resample_gint32_nearest_1 resample_funcs[1]
 807 #define resample_gfloat_nearest_1 resample_funcs[2]
 808 #define resample_gdouble_nearest_1 resample_funcs[3]
 809 
 810 #define resample_gint16_full_1 resample_funcs[4]
 811 #define resample_gint32_full_1 resample_funcs[5]
 812 #define resample_gfloat_full_1 resample_funcs[6]
 813 #define resample_gdouble_full_1 resample_funcs[7]
 814 
 815 #define resample_gint16_linear_1 resample_funcs[8]
 816 #define resample_gint32_linear_1 resample_funcs[9]
 817 #define resample_gfloat_linear_1 resample_funcs[10]
 818 #define resample_gdouble_linear_1 resample_funcs[11]
 819 
 820 #define resample_gint16_cubic_1 resample_funcs[12]
 821 #define resample_gint32_cubic_1 resample_funcs[13]
 822 #define resample_gfloat_cubic_1 resample_funcs[14]
 823 #define resample_gdouble_cubic_1 resample_funcs[15]
 824 
 825 #if defined HAVE_ORC &amp;&amp; !defined DISABLE_ORC
 826 # if defined (HAVE_ARM_NEON)
 827 #  define CHECK_NEON
 828 #  include &quot;audio-resampler-neon.h&quot;
 829 # endif
 830 # if defined (__i386__) || defined (__x86_64__)
 831 #  define CHECK_X86
 832 #  include &quot;audio-resampler-x86.h&quot;
 833 # endif
 834 #endif
 835 
 836 static void
 837 audio_resampler_init (void)
 838 {
 839   static gsize init_gonce = 0;
 840 
 841   if (g_once_init_enter (&amp;init_gonce)) {
 842 
 843     GST_DEBUG_CATEGORY_INIT (audio_resampler_debug, &quot;audio-resampler&quot;, 0,
 844         &quot;audio-resampler object&quot;);
 845 
 846 #if defined HAVE_ORC &amp;&amp; !defined DISABLE_ORC
 847     orc_init ();
 848     {
 849       OrcTarget *target = orc_target_get_default ();
 850       gint i;
 851 
 852       if (target) {
 853         const gchar *name;
 854         unsigned int flags = orc_target_get_default_flags (target);
 855 
 856         for (i = -1; i &lt; 32; ++i) {
 857           if (i == -1) {
 858             name = orc_target_get_name (target);
 859             GST_DEBUG (&quot;target %s, default flags %08x&quot;, name, flags);
 860           } else if (flags &amp; (1U &lt;&lt; i)) {
 861             name = orc_target_get_flag_name (target, i);
 862             GST_DEBUG (&quot;target flag %s&quot;, name);
 863           } else
 864             name = NULL;
 865 
 866           if (name) {
 867 #ifdef CHECK_X86
 868             audio_resampler_check_x86 (name);
 869 #endif
 870 #ifdef CHECK_NEON
 871             audio_resampler_check_neon (name);
 872 #endif
 873           }
 874         }
 875       }
 876     }
 877 #endif
 878     g_once_init_leave (&amp;init_gonce, 1);
 879   }
 880 }
 881 
 882 #define MAKE_DEINTERLEAVE_FUNC(type)                                    \
 883 static void                                                             \
 884 deinterleave_ ##type (GstAudioResampler * resampler, gpointer sbuf[],   \
 885     gpointer in[], gsize in_frames)                                     \
 886 {                                                                       \
 887   gint i, c, channels = resampler-&gt;channels;                            \
 888   gsize samples_avail = resampler-&gt;samples_avail;                       \
 889   for (c = 0; c &lt; channels; c++) {                                      \
 890     type *s = (type *) sbuf[c] + samples_avail;                         \
 891     if (G_UNLIKELY (in == NULL)) {                                      \
 892       for (i = 0; i &lt; in_frames; i++)                                   \
 893         s[i] = 0;                                                       \
 894     } else {                                                            \
 895       type *ip = (type *) in[0] + c;                                    \
 896       for (i = 0; i &lt; in_frames; i++, ip += channels)                   \
 897         s[i] = *ip;                                                     \
 898     }                                                                   \
 899   }                                                                     \
 900 }
 901 
 902 MAKE_DEINTERLEAVE_FUNC (gint16);
 903 MAKE_DEINTERLEAVE_FUNC (gint32);
 904 MAKE_DEINTERLEAVE_FUNC (gfloat);
 905 MAKE_DEINTERLEAVE_FUNC (gdouble);
 906 
 907 static DeinterleaveFunc deinterleave_funcs[] = {
 908   deinterleave_gint16,
 909   deinterleave_gint32,
 910   deinterleave_gfloat,
 911   deinterleave_gdouble
 912 };
 913 
 914 static void
 915 calculate_kaiser_params (GstAudioResampler * resampler)
 916 {
 917   gdouble A, B, dw, tr_bw, Fc;
 918   gint n;
 919   const KaiserQualityMap *q = &amp;kaiser_qualities[DEFAULT_QUALITY];
 920 
 921   /* default cutoff */
 922   Fc = q-&gt;cutoff;
 923   if (resampler-&gt;out_rate &lt; resampler-&gt;in_rate)
 924     Fc *= q-&gt;downsample_cutoff_factor;
 925 
 926   Fc = GET_OPT_CUTOFF (resampler-&gt;options, Fc);
 927   A = GET_OPT_STOP_ATTENUATION (resampler-&gt;options, q-&gt;stopband_attenuation);
 928   tr_bw =
 929       GET_OPT_TRANSITION_BANDWIDTH (resampler-&gt;options,
 930       q-&gt;transition_bandwidth);
 931 
 932   GST_LOG (&quot;Fc %f, A %f, tr_bw %f&quot;, Fc, A, tr_bw);
 933 
 934   /* calculate Beta */
 935   if (A &gt; 50)
 936     B = 0.1102 * (A - 8.7);
 937   else if (A &gt;= 21)
 938     B = 0.5842 * pow (A - 21, 0.4) + 0.07886 * (A - 21);
 939   else
 940     B = 0.0;
 941   /* calculate transition width in radians */
 942   dw = 2 * G_PI * (tr_bw);
 943   /* order of the filter */
 944   n = (A - 8.0) / (2.285 * dw);
 945 
 946   resampler-&gt;kaiser_beta = B;
 947   resampler-&gt;n_taps = n + 1;
 948   resampler-&gt;cutoff = Fc;
 949 
 950   GST_LOG (&quot;using Beta %f n_taps %d cutoff %f&quot;, resampler-&gt;kaiser_beta,
 951       resampler-&gt;n_taps, resampler-&gt;cutoff);
 952 }
 953 
 954 static void
 955 alloc_taps_mem (GstAudioResampler * resampler, gint bps, gint n_taps,
 956     gint n_phases)
 957 {
 958   if (resampler-&gt;alloc_taps &gt;= n_taps &amp;&amp; resampler-&gt;alloc_phases &gt;= n_phases)
 959     return;
 960 
 961   GST_DEBUG (&quot;allocate bps %d n_taps %d n_phases %d&quot;, bps, n_taps, n_phases);
 962 
 963   resampler-&gt;tmp_taps =
 964       g_realloc_n (resampler-&gt;tmp_taps, n_taps, sizeof (gdouble));
 965 
 966   resampler-&gt;taps_stride = GST_ROUND_UP_32 (bps * (n_taps + TAPS_OVERREAD));
 967 
 968   g_free (resampler-&gt;taps_mem);
 969   resampler-&gt;taps_mem =
 970       g_malloc0 (n_phases * resampler-&gt;taps_stride + ALIGN - 1);
 971   resampler-&gt;taps = MEM_ALIGN ((gint8 *) resampler-&gt;taps_mem, ALIGN);
 972   resampler-&gt;alloc_taps = n_taps;
 973   resampler-&gt;alloc_phases = n_phases;
 974 }
 975 
 976 static void
 977 alloc_cache_mem (GstAudioResampler * resampler, gint bps, gint n_taps,
 978     gint n_phases)
 979 {
 980   gsize phases_size;
 981 
 982   resampler-&gt;tmp_taps =
 983       g_realloc_n (resampler-&gt;tmp_taps, n_taps, sizeof (gdouble));
 984 
 985   resampler-&gt;cached_taps_stride =
 986       GST_ROUND_UP_32 (bps * (n_taps + TAPS_OVERREAD));
 987 
 988   phases_size = sizeof (gpointer) * n_phases;
 989 
 990   g_free (resampler-&gt;cached_taps_mem);
 991   resampler-&gt;cached_taps_mem =
 992       g_malloc0 (phases_size + n_phases * resampler-&gt;cached_taps_stride +
 993       ALIGN - 1);
 994   resampler-&gt;cached_taps =
 995       MEM_ALIGN ((gint8 *) resampler-&gt;cached_taps_mem + phases_size, ALIGN);
 996   resampler-&gt;cached_phases = resampler-&gt;cached_taps_mem;
 997 }
 998 
 999 static void
1000 setup_functions (GstAudioResampler * resampler)
1001 {
1002   gint index, fidx;
1003 
1004   index = resampler-&gt;format_index;
1005 
1006   if (resampler-&gt;in_rate == resampler-&gt;out_rate)
1007     resampler-&gt;resample = resample_funcs[index];
1008   else {
1009     switch (resampler-&gt;filter_interpolation) {
1010       default:
1011       case GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_NONE:
1012         fidx = 0;
1013         break;
1014       case GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_LINEAR:
1015         GST_DEBUG (&quot;using linear interpolation for filter coefficients&quot;);
1016         fidx = 0;
1017         break;
1018       case GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_CUBIC:
1019         GST_DEBUG (&quot;using cubic interpolation for filter coefficients&quot;);
1020         fidx = 4;
1021         break;
1022     }
1023     GST_DEBUG (&quot;using filter interpolate function %d&quot;, index + fidx);
1024     resampler-&gt;interpolate = interpolate_funcs[index + fidx];
1025 
1026     switch (resampler-&gt;method) {
1027       case GST_AUDIO_RESAMPLER_METHOD_NEAREST:
1028         GST_DEBUG (&quot;using nearest filter function&quot;);
1029         break;
1030       default:
1031         index += 4;
1032         switch (resampler-&gt;filter_mode) {
1033           default:
1034           case GST_AUDIO_RESAMPLER_FILTER_MODE_FULL:
1035             GST_DEBUG (&quot;using full filter function&quot;);
1036             break;
1037           case GST_AUDIO_RESAMPLER_FILTER_MODE_INTERPOLATED:
1038             index += 4 + fidx;
1039             GST_DEBUG (&quot;using interpolated filter function&quot;);
1040             break;
1041         }
1042         break;
1043     }
1044     GST_DEBUG (&quot;using resample function %d&quot;, index);
1045     resampler-&gt;resample = resample_funcs[index];
1046   }
1047 }
1048 
1049 static void
1050 resampler_calculate_taps (GstAudioResampler * resampler)
1051 {
1052   gint bps;
1053   gint n_taps, oversample;
1054   gint in_rate, out_rate;
1055   gboolean scale = TRUE, sinc_table = FALSE;
1056   GstAudioResamplerFilterInterpolation filter_interpolation;
1057 
1058   switch (resampler-&gt;method) {
1059     case GST_AUDIO_RESAMPLER_METHOD_NEAREST:
1060       resampler-&gt;n_taps = 2;
1061       scale = FALSE;
1062       break;
1063     case GST_AUDIO_RESAMPLER_METHOD_LINEAR:
1064       resampler-&gt;n_taps = GET_OPT_N_TAPS (resampler-&gt;options, 2);
1065       break;
1066     case GST_AUDIO_RESAMPLER_METHOD_CUBIC:
1067       resampler-&gt;n_taps = GET_OPT_N_TAPS (resampler-&gt;options, 4);
1068       resampler-&gt;b = GET_OPT_CUBIC_B (resampler-&gt;options);
1069       resampler-&gt;c = GET_OPT_CUBIC_C (resampler-&gt;options);;
1070       break;
1071     case GST_AUDIO_RESAMPLER_METHOD_BLACKMAN_NUTTALL:
1072     {
1073       const BlackmanQualityMap *q = &amp;blackman_qualities[DEFAULT_QUALITY];
1074       resampler-&gt;n_taps = GET_OPT_N_TAPS (resampler-&gt;options, q-&gt;n_taps);
1075       resampler-&gt;cutoff = GET_OPT_CUTOFF (resampler-&gt;options, q-&gt;cutoff);
1076       sinc_table = TRUE;
1077       break;
1078     }
1079     case GST_AUDIO_RESAMPLER_METHOD_KAISER:
1080       calculate_kaiser_params (resampler);
1081       sinc_table = TRUE;
1082       break;
1083   }
1084 
1085   in_rate = resampler-&gt;in_rate;
1086   out_rate = resampler-&gt;out_rate;
1087 
1088   if (out_rate &lt; in_rate &amp;&amp; scale) {
1089     resampler-&gt;cutoff = resampler-&gt;cutoff * out_rate / in_rate;
1090     resampler-&gt;n_taps =
1091         gst_util_uint64_scale_int (resampler-&gt;n_taps, in_rate, out_rate);
1092   }
1093 
1094   if (sinc_table) {
1095     resampler-&gt;n_taps = GST_ROUND_UP_8 (resampler-&gt;n_taps);
1096     resampler-&gt;filter_mode = GET_OPT_FILTER_MODE (resampler-&gt;options);
1097     resampler-&gt;filter_threshold =
1098         GET_OPT_FILTER_MODE_THRESHOLD (resampler-&gt;options);
1099     filter_interpolation = GET_OPT_FILTER_INTERPOLATION (resampler-&gt;options);
1100 
1101   } else {
1102     resampler-&gt;filter_mode = GST_AUDIO_RESAMPLER_FILTER_MODE_FULL;
1103     filter_interpolation = GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_NONE;
1104   }
1105 
1106   /* calculate oversampling for interpolated filter */
1107   if (filter_interpolation != GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_NONE) {
1108     gint mult = 2;
1109 
1110     oversample = GET_OPT_FILTER_OVERSAMPLE (resampler-&gt;options);
1111     while (oversample &gt; 1) {
1112       if (mult * out_rate &gt;= in_rate)
1113         break;
1114 
1115       mult *= 2;
1116       oversample &gt;&gt;= 1;
1117     }
1118 
1119     switch (filter_interpolation) {
1120       case GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_LINEAR:
1121         oversample *= 11;
1122         break;
1123       default:
1124         break;
1125     }
1126   } else {
1127     oversample = 1;
1128   }
1129   resampler-&gt;oversample = oversample;
1130 
1131   n_taps = resampler-&gt;n_taps;
1132   bps = resampler-&gt;bps;
1133 
1134   GST_LOG (&quot;using n_taps %d cutoff %f oversample %d&quot;, n_taps, resampler-&gt;cutoff,
1135       oversample);
1136 
1137   if (resampler-&gt;filter_mode == GST_AUDIO_RESAMPLER_FILTER_MODE_AUTO) {
1138     if (out_rate &lt;= oversample
1139         &amp;&amp; !(resampler-&gt;flags &amp; GST_AUDIO_RESAMPLER_FLAG_VARIABLE_RATE)) {
1140       /* don&#39;t interpolate if we need to calculate at least the same amount
1141        * of filter coefficients than the full table case */
1142       resampler-&gt;filter_mode = GST_AUDIO_RESAMPLER_FILTER_MODE_FULL;
1143       GST_DEBUG (&quot;automatically selected full filter, %d &lt;= %d&quot;, out_rate,
1144           oversample);
1145     } else if (bps * n_taps * out_rate &lt; resampler-&gt;filter_threshold) {
1146       /* switch to full filter when memory is below threshold */
1147       resampler-&gt;filter_mode = GST_AUDIO_RESAMPLER_FILTER_MODE_FULL;
1148       GST_DEBUG (&quot;automatically selected full filter, memory %d &lt;= %d&quot;,
1149           bps * n_taps * out_rate, resampler-&gt;filter_threshold);
1150     } else {
1151       GST_DEBUG (&quot;automatically selected interpolated filter&quot;);
1152       resampler-&gt;filter_mode = GST_AUDIO_RESAMPLER_FILTER_MODE_INTERPOLATED;
1153     }
1154   }
1155   /* interpolated table but no interpolation given, assume default */
1156   if (resampler-&gt;filter_mode != GST_AUDIO_RESAMPLER_FILTER_MODE_FULL &amp;&amp;
1157       filter_interpolation == GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_NONE)
1158     filter_interpolation = DEFAULT_OPT_FILTER_INTERPOLATION;
1159 
1160   resampler-&gt;filter_interpolation = filter_interpolation;
1161 
1162   if (resampler-&gt;filter_mode == GST_AUDIO_RESAMPLER_FILTER_MODE_FULL &amp;&amp;
1163       resampler-&gt;method != GST_AUDIO_RESAMPLER_METHOD_NEAREST) {
1164     GST_DEBUG (&quot;setting up filter cache&quot;);
1165     resampler-&gt;n_phases = out_rate;
1166     alloc_cache_mem (resampler, bps, n_taps, out_rate);
1167   }
1168 
1169   if (resampler-&gt;filter_interpolation !=
1170       GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_NONE) {
1171     gint i, isize;
1172     gdouble x;
1173     gpointer taps;
1174 
1175     switch (resampler-&gt;filter_interpolation) {
1176       default:
1177       case GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_LINEAR:
1178         GST_DEBUG (&quot;using linear interpolation to build filter&quot;);
1179         isize = 2;
1180         break;
1181       case GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_CUBIC:
1182         GST_DEBUG (&quot;using cubic interpolation to build filter&quot;);
1183         isize = 4;
1184         break;
1185     }
1186 
1187     alloc_taps_mem (resampler, bps, n_taps, oversample + isize);
1188 
1189     for (i = 0; i &lt; oversample + isize; i++) {
1190       x = -(n_taps / 2) + i / (gdouble) oversample;
1191       taps = (gint8 *) resampler-&gt;taps + i * resampler-&gt;taps_stride;
1192       make_taps (resampler, taps, x, n_taps);
1193     }
1194   }
1195 }
1196 
1197 #define PRINT_TAPS(type,print)                          \
1198 G_STMT_START {                                          \
1199   type sum = 0.0, *taps;                                \
1200   type icoeff[4];                                       \
1201   gint samp_index = 0, samp_phase = i;                  \
1202                                                         \
1203   taps = get_taps_##type##_full (resampler, &amp;samp_index,\
1204       &amp;samp_phase, icoeff);                             \
1205                                                         \
1206   for (j = 0; j &lt; n_taps; j++) {                        \
1207     type tap = taps[j];                                 \
1208     fprintf (stderr, &quot;\t%&quot; print &quot; &quot;, tap);             \
1209     sum += tap;                                         \
1210   }                                                     \
1211   fprintf (stderr, &quot;\t: sum %&quot; print &quot;\n&quot;, sum);        \
1212 } G_STMT_END
1213 
1214 static void
1215 resampler_dump (GstAudioResampler * resampler)
1216 {
1217 #if 0
1218   gint i, n_taps, out_rate;
1219   gint64 a;
1220 
1221   out_rate = resampler-&gt;out_rate;
1222   n_taps = resampler-&gt;n_taps;
1223 
1224   fprintf (stderr, &quot;out size %d, max taps %d\n&quot;, out_rate, n_taps);
1225 
1226   a = g_get_monotonic_time ();
1227 
1228   for (i = 0; i &lt; out_rate; i++) {
1229     gint j;
1230 
1231     //fprintf (stderr, &quot;%u: %d %d\t &quot;, i, t-&gt;sample_inc, t-&gt;next_phase);
1232     switch (resampler-&gt;format) {
1233       case GST_AUDIO_FORMAT_F64:
1234         PRINT_TAPS (gdouble, &quot;f&quot;);
1235         break;
1236       case GST_AUDIO_FORMAT_F32:
1237         PRINT_TAPS (gfloat, &quot;f&quot;);
1238         break;
1239       case GST_AUDIO_FORMAT_S32:
1240         PRINT_TAPS (gint32, &quot;d&quot;);
1241         break;
1242       case GST_AUDIO_FORMAT_S16:
1243         PRINT_TAPS (gint16, &quot;d&quot;);
1244         break;
1245       default:
1246         break;
1247     }
1248   }
1249   fprintf (stderr, &quot;time %&quot; G_GUINT64_FORMAT &quot;\n&quot;, g_get_monotonic_time () - a);
1250 #endif
1251 }
1252 
1253 /**
1254  * gst_audio_resampler_options_set_quality:
1255  * @method: a #GstAudioResamplerMethod
1256  * @quality: the quality
1257  * @in_rate: the input rate
1258  * @out_rate: the output rate
1259  * @options: a #GstStructure
1260  *
1261  * Set the parameters for resampling from @in_rate to @out_rate using @method
1262  * for @quality in @options.
1263  */
1264 void
1265 gst_audio_resampler_options_set_quality (GstAudioResamplerMethod method,
1266     guint quality, gint in_rate, gint out_rate, GstStructure * options)
1267 {
1268   g_return_if_fail (options != NULL);
1269   g_return_if_fail (quality &lt;= GST_AUDIO_RESAMPLER_QUALITY_MAX);
1270   g_return_if_fail (in_rate &gt; 0 &amp;&amp; out_rate &gt; 0);
1271 
1272   switch (method) {
1273     case GST_AUDIO_RESAMPLER_METHOD_NEAREST:
1274       break;
1275     case GST_AUDIO_RESAMPLER_METHOD_LINEAR:
1276       gst_structure_set (options,
1277           GST_AUDIO_RESAMPLER_OPT_N_TAPS, G_TYPE_INT, 2, NULL);
1278       break;
1279     case GST_AUDIO_RESAMPLER_METHOD_CUBIC:
1280       gst_structure_set (options,
1281           GST_AUDIO_RESAMPLER_OPT_N_TAPS, G_TYPE_INT, 4,
1282           GST_AUDIO_RESAMPLER_OPT_CUBIC_B, G_TYPE_DOUBLE, DEFAULT_OPT_CUBIC_B,
1283           GST_AUDIO_RESAMPLER_OPT_CUBIC_C, G_TYPE_DOUBLE, DEFAULT_OPT_CUBIC_C,
1284           NULL);
1285       break;
1286     case GST_AUDIO_RESAMPLER_METHOD_BLACKMAN_NUTTALL:
1287     {
1288       const BlackmanQualityMap *map = &amp;blackman_qualities[quality];
1289       gst_structure_set (options,
1290           GST_AUDIO_RESAMPLER_OPT_N_TAPS, G_TYPE_INT, map-&gt;n_taps,
1291           GST_AUDIO_RESAMPLER_OPT_CUTOFF, G_TYPE_DOUBLE, map-&gt;cutoff, NULL);
1292       break;
1293     }
1294     case GST_AUDIO_RESAMPLER_METHOD_KAISER:
1295     {
1296       const KaiserQualityMap *map = &amp;kaiser_qualities[quality];
1297       gdouble cutoff;
1298 
1299       cutoff = map-&gt;cutoff;
1300       if (out_rate &lt; in_rate)
1301         cutoff *= map-&gt;downsample_cutoff_factor;
1302 
1303       gst_structure_set (options,
1304           GST_AUDIO_RESAMPLER_OPT_CUTOFF, G_TYPE_DOUBLE, cutoff,
1305           GST_AUDIO_RESAMPLER_OPT_STOP_ATTENUATION, G_TYPE_DOUBLE,
1306           map-&gt;stopband_attenuation,
1307           GST_AUDIO_RESAMPLER_OPT_TRANSITION_BANDWIDTH, G_TYPE_DOUBLE,
1308           map-&gt;transition_bandwidth, NULL);
1309       break;
1310     }
1311   }
1312   gst_structure_set (options,
1313       GST_AUDIO_RESAMPLER_OPT_FILTER_OVERSAMPLE, G_TYPE_INT,
1314       oversample_qualities[quality], NULL);
1315 }
1316 
1317 /**
1318  * gst_audio_resampler_new:
1319  * @method: a #GstAudioResamplerMethod
1320  * @flags: #GstAudioResamplerFlags
1321  * @in_rate: input rate
1322  * @out_rate: output rate
1323  * @options: extra options
1324  *
1325  * Make a new resampler.
1326  *
1327  * Returns: (skip) (transfer full): %TRUE on success
1328  */
1329 GstAudioResampler *
1330 gst_audio_resampler_new (GstAudioResamplerMethod method,
1331     GstAudioResamplerFlags flags,
1332     GstAudioFormat format, gint channels,
1333     gint in_rate, gint out_rate, GstStructure * options)
1334 {
1335   gboolean non_interleaved;
1336   GstAudioResampler *resampler;
1337   const GstAudioFormatInfo *info;
1338   GstStructure *def_options = NULL;
1339 
1340   g_return_val_if_fail (method &gt;= GST_AUDIO_RESAMPLER_METHOD_NEAREST
1341       &amp;&amp; method &lt;= GST_AUDIO_RESAMPLER_METHOD_KAISER, NULL);
1342   g_return_val_if_fail (format == GST_AUDIO_FORMAT_S16 ||
1343       format == GST_AUDIO_FORMAT_S32 || format == GST_AUDIO_FORMAT_F32 ||
1344       format == GST_AUDIO_FORMAT_F64, NULL);
1345   g_return_val_if_fail (channels &gt; 0, NULL);
1346   g_return_val_if_fail (in_rate &gt; 0, NULL);
1347   g_return_val_if_fail (out_rate &gt; 0, NULL);
1348 
1349   audio_resampler_init ();
1350 
1351   resampler = g_slice_new0 (GstAudioResampler);
1352   resampler-&gt;method = method;
1353   resampler-&gt;flags = flags;
1354   resampler-&gt;format = format;
1355   resampler-&gt;channels = channels;
1356 
1357   switch (format) {
1358     case GST_AUDIO_FORMAT_S16:
1359       resampler-&gt;format_index = 0;
1360       break;
1361     case GST_AUDIO_FORMAT_S32:
1362       resampler-&gt;format_index = 1;
1363       break;
1364     case GST_AUDIO_FORMAT_F32:
1365       resampler-&gt;format_index = 2;
1366       break;
1367     case GST_AUDIO_FORMAT_F64:
1368       resampler-&gt;format_index = 3;
1369       break;
1370     default:
1371       g_assert_not_reached ();
1372       break;
1373   }
1374 
1375   info = gst_audio_format_get_info (format);
1376   resampler-&gt;bps = GST_AUDIO_FORMAT_INFO_WIDTH (info) / 8;
1377   resampler-&gt;sbuf = g_malloc0 (sizeof (gpointer) * channels);
1378 
1379   non_interleaved =
1380       (resampler-&gt;flags &amp; GST_AUDIO_RESAMPLER_FLAG_NON_INTERLEAVED_OUT);
1381 
1382   /* we resample each channel separately */
1383   resampler-&gt;blocks = resampler-&gt;channels;
1384   resampler-&gt;inc = 1;
1385   resampler-&gt;ostride = non_interleaved ? 1 : resampler-&gt;channels;
1386   resampler-&gt;deinterleave = deinterleave_funcs[resampler-&gt;format_index];
1387   resampler-&gt;convert_taps = convert_taps_funcs[resampler-&gt;format_index];
1388 
1389   GST_DEBUG (&quot;method %d, bps %d, channels %d&quot;, method, resampler-&gt;bps,
1390       resampler-&gt;channels);
1391 
1392   if (options == NULL) {
1393     options = def_options =
1394         gst_structure_new_empty (&quot;GstAudioResampler.options&quot;);
1395     gst_audio_resampler_options_set_quality (DEFAULT_RESAMPLER_METHOD,
1396         GST_AUDIO_RESAMPLER_QUALITY_DEFAULT, in_rate, out_rate, options);
1397   }
1398 
1399   gst_audio_resampler_update (resampler, in_rate, out_rate, options);
1400   gst_audio_resampler_reset (resampler);
1401 
1402   if (def_options)
1403     gst_structure_free (def_options);
1404 
1405   return resampler;
1406 }
1407 
1408 /* make the buffers to hold the (deinterleaved) samples */
1409 static inline gpointer *
1410 get_sample_bufs (GstAudioResampler * resampler, gsize need)
1411 {
1412   if (G_LIKELY (resampler-&gt;samples_len &lt; need)) {
1413     gint c, blocks = resampler-&gt;blocks;
1414     gsize bytes, to_move = 0;
1415     gint8 *ptr, *samples;
1416 
1417     GST_LOG (&quot;realloc %d -&gt; %d&quot;, (gint) resampler-&gt;samples_len, (gint) need);
1418 
1419     bytes = GST_ROUND_UP_N (need * resampler-&gt;bps * resampler-&gt;inc, ALIGN);
1420 
1421     samples = g_malloc0 (blocks * bytes + ALIGN - 1);
1422     ptr = MEM_ALIGN (samples, ALIGN);
1423 
1424     /* if we had some data, move history */
1425     if (resampler-&gt;samples_len &gt; 0)
1426       to_move = resampler-&gt;samples_avail * resampler-&gt;bps * resampler-&gt;inc;
1427 
1428     /* set up new pointers */
1429     for (c = 0; c &lt; blocks; c++) {
1430       memcpy (ptr + (c * bytes), resampler-&gt;sbuf[c], to_move);
1431       resampler-&gt;sbuf[c] = ptr + (c * bytes);
1432     }
1433     g_free (resampler-&gt;samples);
1434     resampler-&gt;samples = samples;
1435     resampler-&gt;samples_len = need;
1436   }
1437   return resampler-&gt;sbuf;
1438 }
1439 
1440 /**
1441  * gst_audio_resampler_reset:
1442  * @resampler: a #GstAudioResampler
1443  *
1444  * Reset @resampler to the state it was when it was first created, discarding
1445  * all sample history.
1446  */
1447 void
1448 gst_audio_resampler_reset (GstAudioResampler * resampler)
1449 {
1450   g_return_if_fail (resampler != NULL);
1451 
1452   if (resampler-&gt;samples) {
1453     gsize bytes;
1454     gint c, blocks, bpf;
1455 
1456     bpf = resampler-&gt;bps * resampler-&gt;inc;
1457     bytes = (resampler-&gt;n_taps / 2) * bpf;
1458     blocks = resampler-&gt;blocks;
1459 
1460     for (c = 0; c &lt; blocks; c++)
1461       memset (resampler-&gt;sbuf[c], 0, bytes);
1462   }
1463   /* half of the filter is filled with 0 */
1464   resampler-&gt;samp_index = 0;
1465   resampler-&gt;samples_avail = resampler-&gt;n_taps / 2 - 1;
1466 }
1467 
1468 /**
1469  * gst_audio_resampler_update:
1470  * @resampler: a #GstAudioResampler
1471  * @in_rate: new input rate
1472  * @out_rate: new output rate
1473  * @options: new options or %NULL
1474  *
1475  * Update the resampler parameters for @resampler. This function should
1476  * not be called concurrently with any other function on @resampler.
1477  *
1478  * When @in_rate or @out_rate is 0, its value is unchanged.
1479  *
1480  * When @options is %NULL, the previously configured options are reused.
1481  *
1482  * Returns: %TRUE if the new parameters could be set
1483  */
1484 gboolean
1485 gst_audio_resampler_update (GstAudioResampler * resampler,
1486     gint in_rate, gint out_rate, GstStructure * options)
1487 {
1488   gint gcd, samp_phase, old_n_taps;
1489   gdouble max_error;
1490 
1491   g_return_val_if_fail (resampler != NULL, FALSE);
1492 
1493   if (in_rate &lt;= 0)
1494     in_rate = resampler-&gt;in_rate;
1495   if (out_rate &lt;= 0)
1496     out_rate = resampler-&gt;out_rate;
1497 
1498   if (resampler-&gt;out_rate &gt; 0) {
1499     GST_INFO (&quot;old phase %d/%d&quot;, resampler-&gt;samp_phase, resampler-&gt;out_rate);
1500     samp_phase =
1501         gst_util_uint64_scale_int (resampler-&gt;samp_phase, out_rate,
1502         resampler-&gt;out_rate);
1503   } else
1504     samp_phase = 0;
1505 
1506   gcd = gst_util_greatest_common_divisor (in_rate, out_rate);
1507 
1508   max_error = GET_OPT_MAX_PHASE_ERROR (resampler-&gt;options);
1509 
1510   if (max_error &lt; 1.0e-8) {
1511     GST_INFO (&quot;using exact phase divider&quot;);
1512     gcd = gst_util_greatest_common_divisor (gcd, samp_phase);
1513   } else {
1514     while (gcd &gt; 1) {
1515       gdouble ph1 = (gdouble) samp_phase / out_rate;
1516       gint factor = 2;
1517 
1518       /* reduce the factor until we have a phase error of less than 10% */
1519       gdouble ph2 = (gdouble) (samp_phase / gcd) / (out_rate / gcd);
1520 
1521       if (fabs (ph1 - ph2) &lt; max_error)
1522         break;
1523 
1524       while (gcd % factor != 0)
1525         factor++;
1526       gcd /= factor;
1527 
1528       GST_INFO (&quot;divide by factor %d, gcd %d&quot;, factor, gcd);
1529     }
1530   }
1531 
1532   GST_INFO (&quot;phase %d out_rate %d, in_rate %d, gcd %d&quot;, samp_phase, out_rate,
1533       in_rate, gcd);
1534 
1535   resampler-&gt;samp_phase = samp_phase /= gcd;
1536   resampler-&gt;in_rate = in_rate /= gcd;
1537   resampler-&gt;out_rate = out_rate /= gcd;
1538 
1539   GST_INFO (&quot;new phase %d/%d&quot;, resampler-&gt;samp_phase, resampler-&gt;out_rate);
1540 
1541   resampler-&gt;samp_inc = in_rate / out_rate;
1542   resampler-&gt;samp_frac = in_rate % out_rate;
1543 
1544   if (options) {
1545     GST_INFO (&quot;have new options, reconfigure filter&quot;);
1546 
1547     if (resampler-&gt;options)
1548       gst_structure_free (resampler-&gt;options);
1549     resampler-&gt;options = gst_structure_copy (options);
1550 
1551     old_n_taps = resampler-&gt;n_taps;
1552 
1553     resampler_calculate_taps (resampler);
1554     resampler_dump (resampler);
1555 
1556     if (old_n_taps &gt; 0 &amp;&amp; old_n_taps != resampler-&gt;n_taps) {
1557       gpointer *sbuf;
1558       gint i, bpf, bytes, soff, doff, diff;
1559 
1560       sbuf = get_sample_bufs (resampler, resampler-&gt;n_taps);
1561 
1562       bpf = resampler-&gt;bps * resampler-&gt;inc;
1563       bytes = resampler-&gt;samples_avail * bpf;
1564       soff = doff = resampler-&gt;samp_index * bpf;
1565 
1566       diff = ((gint) resampler-&gt;n_taps - old_n_taps) / 2;
1567 
1568       GST_DEBUG (&quot;taps %d-&gt;%d, %d&quot;, old_n_taps, resampler-&gt;n_taps, diff);
1569 
1570       if (diff &lt; 0) {
1571         /* diff &lt; 0, decrease taps, adjust source */
1572         soff += -diff * bpf;
1573         bytes -= -diff * bpf;
1574       } else {
1575         /* diff &gt; 0, increase taps, adjust dest */
1576         doff += diff * bpf;
1577       }
1578 
1579       /* now shrink or enlarge the history buffer, when we enlarge we
1580        * just leave the old samples in there. FIXME, probably do something better
1581        * like mirror or fill with zeroes. */
1582       for (i = 0; i &lt; resampler-&gt;blocks; i++)
1583         memmove ((gint8 *) sbuf[i] + doff, (gint8 *) sbuf[i] + soff, bytes);
1584 
1585       resampler-&gt;samples_avail += diff;
1586     }
1587   } else if (resampler-&gt;filter_mode == GST_AUDIO_RESAMPLER_FILTER_MODE_FULL) {
1588     GST_DEBUG (&quot;setting up filter cache&quot;);
1589     resampler-&gt;n_phases = resampler-&gt;out_rate;
1590     alloc_cache_mem (resampler, resampler-&gt;bps, resampler-&gt;n_taps,
1591         resampler-&gt;n_phases);
1592   }
1593   setup_functions (resampler);
1594 
1595   return TRUE;
1596 }
1597 
1598 /**
1599  * gst_audio_resampler_free:
1600  * @resampler: a #GstAudioResampler
1601  *
1602  * Free a previously allocated #GstAudioResampler @resampler.
1603  *
1604  * Since: 1.6
1605  */
1606 void
1607 gst_audio_resampler_free (GstAudioResampler * resampler)
1608 {
1609   g_return_if_fail (resampler != NULL);
1610 
1611   g_free (resampler-&gt;cached_taps_mem);
1612   g_free (resampler-&gt;taps_mem);
1613   g_free (resampler-&gt;tmp_taps);
1614   g_free (resampler-&gt;samples);
1615   g_free (resampler-&gt;sbuf);
1616   if (resampler-&gt;options)
1617     gst_structure_free (resampler-&gt;options);
1618   g_slice_free (GstAudioResampler, resampler);
1619 }
1620 
1621 /**
1622  * gst_audio_resampler_get_out_frames:
1623  * @resampler: a #GstAudioResampler
1624  * @in_frames: number of input frames
1625  *
1626  * Get the number of output frames that would be currently available when
1627  * @in_frames are given to @resampler.
1628  *
1629  * Returns: The number of frames that would be availabe after giving
1630  * @in_frames as input to @resampler.
1631  */
1632 gsize
1633 gst_audio_resampler_get_out_frames (GstAudioResampler * resampler,
1634     gsize in_frames)
1635 {
1636   gsize need, avail, out;
1637 
1638   g_return_val_if_fail (resampler != NULL, 0);
1639 
1640   need = resampler-&gt;n_taps + resampler-&gt;samp_index + resampler-&gt;skip;
1641   avail = resampler-&gt;samples_avail + in_frames;
1642   GST_LOG (&quot;need %d = %d + %d + %d, avail %d = %d + %d&quot;, (gint) need,
1643       resampler-&gt;n_taps, resampler-&gt;samp_index, resampler-&gt;skip,
1644       (gint) avail, (gint) resampler-&gt;samples_avail, (gint) in_frames);
1645   if (avail &lt; need)
1646     return 0;
1647 
1648   out = (avail - need) * resampler-&gt;out_rate;
1649   if (out &lt; resampler-&gt;samp_phase)
1650     return 0;
1651 
1652   out = ((out - resampler-&gt;samp_phase) / resampler-&gt;in_rate) + 1;
1653   GST_LOG (&quot;out %d = ((%d * %d - %d) / %d) + 1&quot;, (gint) out,
1654       (gint) (avail - need), resampler-&gt;out_rate, resampler-&gt;samp_phase,
1655       resampler-&gt;in_rate);
1656 
1657   return out;
1658 }
1659 
1660 /**
1661  * gst_audio_resampler_get_in_frames:
1662  * @resampler: a #GstAudioResampler
1663  * @out_frames: number of input frames
1664  *
1665  * Get the number of input frames that would currently be needed
1666  * to produce @out_frames from @resampler.
1667  *
1668  * Returns: The number of input frames needed for producing
1669  * @out_frames of data from @resampler.
1670  */
1671 gsize
1672 gst_audio_resampler_get_in_frames (GstAudioResampler * resampler,
1673     gsize out_frames)
1674 {
1675   gsize in_frames;
1676 
1677   g_return_val_if_fail (resampler != NULL, 0);
1678 
1679   in_frames =
1680       (resampler-&gt;samp_phase +
1681       out_frames * resampler-&gt;samp_frac) / resampler-&gt;out_rate;
1682   in_frames += out_frames * resampler-&gt;samp_inc;
1683 
1684   return in_frames;
1685 }
1686 
1687 /**
1688  * gst_audio_resampler_get_max_latency:
1689  * @resampler: a #GstAudioResampler
1690  *
1691  * Get the maximum number of input samples that the resampler would
1692  * need before producing output.
1693  *
1694  * Returns: the latency of @resampler as expressed in the number of
1695  * frames.
1696  */
1697 gsize
1698 gst_audio_resampler_get_max_latency (GstAudioResampler * resampler)
1699 {
1700   g_return_val_if_fail (resampler != NULL, 0);
1701 
1702   return resampler-&gt;n_taps / 2;
1703 }
1704 
1705 /**
1706  * gst_audio_resampler_resample:
1707  * @resampler: a #GstAudioResampler
1708  * @in: input samples
1709  * @in_frames: number of input frames
1710  * @out: output samples
1711  * @out_frames: number of output frames
1712  *
1713  * Perform resampling on @in_frames frames in @in and write @out_frames to @out.
1714  *
1715  * In case the samples are interleaved, @in and @out must point to an
1716  * array with a single element pointing to a block of interleaved samples.
1717  *
1718  * If non-interleaved samples are used, @in and @out must point to an
1719  * array with pointers to memory blocks, one for each channel.
1720  *
1721  * @in may be %NULL, in which case @in_frames of silence samples are pushed
1722  * into the resampler.
1723  *
1724  * This function always produces @out_frames of output and consumes @in_frames of
1725  * input. Use gst_audio_resampler_get_out_frames() and
1726  * gst_audio_resampler_get_in_frames() to make sure @in_frames and @out_frames
1727  * are matching and @in and @out point to enough memory.
1728  */
1729 void
1730 gst_audio_resampler_resample (GstAudioResampler * resampler,
1731     gpointer in[], gsize in_frames, gpointer out[], gsize out_frames)
1732 {
1733   gsize samples_avail;
1734   gsize need, consumed;
1735   gpointer *sbuf;
1736 
1737   /* do sample skipping */
1738   if (G_UNLIKELY (resampler-&gt;skip &gt;= in_frames)) {
1739     /* we need tp skip all input */
1740     resampler-&gt;skip -= in_frames;
1741     return;
1742   }
1743   /* skip the last samples by advancing the sample index */
1744   resampler-&gt;samp_index += resampler-&gt;skip;
1745 
1746   samples_avail = resampler-&gt;samples_avail;
1747 
1748   /* make sure we have enough space to copy our samples */
1749   sbuf = get_sample_bufs (resampler, in_frames + samples_avail);
1750 
1751   /* copy/deinterleave the samples */
1752   resampler-&gt;deinterleave (resampler, sbuf, in, in_frames);
1753 
1754   /* update new amount of samples in our buffer */
1755   resampler-&gt;samples_avail = samples_avail += in_frames;
1756 
1757   need = resampler-&gt;n_taps + resampler-&gt;samp_index;
1758   if (G_UNLIKELY (samples_avail &lt; need)) {
1759     /* not enough samples to start */
1760     return;
1761   }
1762 
1763   /* resample all channels */
1764   resampler-&gt;resample (resampler, sbuf, samples_avail, out, out_frames,
1765       &amp;consumed);
1766 
1767   GST_LOG (&quot;in %&quot; G_GSIZE_FORMAT &quot;, avail %&quot; G_GSIZE_FORMAT &quot;, consumed %&quot;
1768       G_GSIZE_FORMAT, in_frames, samples_avail, consumed);
1769 
1770   /* update pointers */
1771   if (G_LIKELY (consumed &gt; 0)) {
1772     gssize left = samples_avail - consumed;
1773     if (left &gt; 0) {
1774       /* we consumed part of our samples */
1775       resampler-&gt;samples_avail = left;
1776     } else {
1777       /* we consumed all our samples, empty our buffers */
1778       resampler-&gt;samples_avail = 0;
1779       resampler-&gt;skip = -left;
1780     }
1781   }
1782 }
    </pre>
  </body>
</html>