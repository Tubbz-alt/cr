<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gstdio.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* gstdio.c - wrappers for C library functions
   2  *
   3  * Copyright 2004 Tor Lillqvist
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public License
  16  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  */
  18 
  19 #include &quot;config.h&quot;
  20 #include &quot;glibconfig.h&quot;
  21 
<a name="1" id="anc1"></a><span class="line-modified">  22 /* Don&#39;t redefine (for example) g_open() to open(), since we actually want to</span>
<span class="line-added">  23  * define g_open() in this file and export it as a symbol. See gstdio.h. */</span>
<span class="line-added">  24 #define G_STDIO_WRAP_ON_UNIX</span>
  25 
  26 #include &lt;sys/types.h&gt;
  27 #include &lt;sys/stat.h&gt;
  28 #include &lt;fcntl.h&gt;
  29 
  30 #ifdef G_OS_UNIX
  31 #include &lt;unistd.h&gt;
  32 #endif
  33 
  34 #ifdef G_OS_WIN32
  35 #include &lt;windows.h&gt;
  36 #include &lt;errno.h&gt;
  37 #include &lt;wchar.h&gt;
  38 #include &lt;direct.h&gt;
  39 #include &lt;io.h&gt;
  40 #include &lt;sys/utime.h&gt;
<a name="2" id="anc2"></a><span class="line-added">  41 #include &lt;stdlib.h&gt; /* for MB_CUR_MAX */</span>
  42 #else
  43 #include &lt;utime.h&gt;
  44 #include &lt;errno.h&gt;
  45 #endif
  46 
  47 #include &quot;gstdio.h&quot;
  48 #include &quot;gstdioprivate.h&quot;
  49 
  50 #if !defined (G_OS_UNIX) &amp;&amp; !defined (G_OS_WIN32)
  51 #error Please port this to your operating system
  52 #endif
  53 
  54 #if defined (_MSC_VER) &amp;&amp; !defined(_WIN64)
  55 #undef _wstat
  56 #define _wstat _wstat32
  57 #endif
  58 
  59 #if defined (G_OS_WIN32)
  60 
  61 /* We can&#39;t include Windows DDK and Windows SDK simultaneously,
  62  * so let&#39;s copy this here from MinGW-w64 DDK.
  63  * The structure is ultimately documented here:
  64  * https://msdn.microsoft.com/en-us/library/ff552012(v=vs.85).aspx
  65  */
  66 typedef struct _REPARSE_DATA_BUFFER
  67 {
  68   ULONG  ReparseTag;
  69   USHORT ReparseDataLength;
  70   USHORT Reserved;
  71   union
  72   {
  73     struct
  74     {
  75       USHORT SubstituteNameOffset;
  76       USHORT SubstituteNameLength;
  77       USHORT PrintNameOffset;
  78       USHORT PrintNameLength;
  79       ULONG  Flags;
  80       WCHAR  PathBuffer[1];
  81     } SymbolicLinkReparseBuffer;
  82     struct
  83     {
  84       USHORT SubstituteNameOffset;
  85       USHORT SubstituteNameLength;
  86       USHORT PrintNameOffset;
  87       USHORT PrintNameLength;
  88       WCHAR  PathBuffer[1];
  89     } MountPointReparseBuffer;
  90     struct
  91     {
  92       UCHAR  DataBuffer[1];
  93     } GenericReparseBuffer;
  94   };
  95 } REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;
  96 
  97 static int
  98 w32_error_to_errno (DWORD error_code)
  99 {
 100   switch (error_code)
 101     {
 102     case ERROR_ACCESS_DENIED:
 103       return EACCES;
 104       break;
<a name="3" id="anc3"></a><span class="line-modified"> 105     case ERROR_ALREADY_EXISTS:</span>
<span class="line-modified"> 106     case ERROR_FILE_EXISTS:</span>
<span class="line-added"> 107       return EEXIST;</span>
<span class="line-added"> 108     case ERROR_FILE_NOT_FOUND:</span>
<span class="line-added"> 109       return ENOENT;</span>
 110       break;
 111     case ERROR_INVALID_FUNCTION:
 112       return EFAULT;
 113       break;
<a name="4" id="anc4"></a><span class="line-modified"> 114     case ERROR_INVALID_HANDLE:</span>
<span class="line-modified"> 115       return EBADF;</span>
 116       break;
<a name="5" id="anc5"></a><span class="line-modified"> 117     case ERROR_INVALID_PARAMETER:</span>
<span class="line-modified"> 118       return EINVAL;</span>
<span class="line-added"> 119       break;</span>
<span class="line-added"> 120     case ERROR_LOCK_VIOLATION:</span>
<span class="line-added"> 121     case ERROR_SHARING_VIOLATION:</span>
<span class="line-added"> 122       return EACCES;</span>
 123       break;
 124     case ERROR_NOT_ENOUGH_MEMORY:
 125     case ERROR_OUTOFMEMORY:
 126       return ENOMEM;
 127       break;
<a name="6" id="anc6"></a><span class="line-added"> 128     case ERROR_NOT_SAME_DEVICE:</span>
<span class="line-added"> 129       return EXDEV;</span>
<span class="line-added"> 130       break;</span>
<span class="line-added"> 131     case ERROR_PATH_NOT_FOUND:</span>
<span class="line-added"> 132       return ENOENT; /* or ELOOP, or ENAMETOOLONG */</span>
<span class="line-added"> 133       break;</span>
 134     default:
 135       return EIO;
 136       break;
 137     }
 138 }
 139 
 140 #include &quot;gstdio-private.c&quot;
 141 
<a name="7" id="anc7"></a><span class="line-added"> 142 /* Windows implementation of fopen() does not accept modes such as</span>
<span class="line-added"> 143  * &quot;wb+&quot;. The &#39;b&#39; needs to be appended to &quot;w+&quot;, i.e. &quot;w+b&quot;. Note</span>
<span class="line-added"> 144  * that otherwise these 2 modes are supposed to be aliases, hence</span>
<span class="line-added"> 145  * swappable at will. TODO: Is this still true?</span>
<span class="line-added"> 146  */</span>
<span class="line-added"> 147 static void</span>
<span class="line-added"> 148 _g_win32_fix_mode (wchar_t *mode)</span>
<span class="line-added"> 149 {</span>
<span class="line-added"> 150   wchar_t *ptr;</span>
<span class="line-added"> 151   wchar_t temp;</span>
<span class="line-added"> 152 </span>
<span class="line-added"> 153   ptr = wcschr (mode, L&#39;+&#39;);</span>
<span class="line-added"> 154   if (ptr != NULL &amp;&amp; (ptr - mode) &gt; 1)</span>
<span class="line-added"> 155     {</span>
<span class="line-added"> 156       temp = mode[1];</span>
<span class="line-added"> 157       mode[1] = *ptr;</span>
<span class="line-added"> 158       *ptr = temp;</span>
<span class="line-added"> 159     }</span>
<span class="line-added"> 160 }</span>
<span class="line-added"> 161 </span>
<span class="line-added"> 162 /* From</span>
<span class="line-added"> 163  * https://support.microsoft.com/en-ca/help/167296/how-to-convert-a-unix-time-t-to-a-win32-filetime-or-systemtime</span>
<span class="line-added"> 164  * FT = UT * 10000000 + 116444736000000000.</span>
<span class="line-added"> 165  * Therefore:</span>
<span class="line-added"> 166  * UT = (FT - 116444736000000000) / 10000000.</span>
<span class="line-added"> 167  * Converts FILETIME to unix epoch time in form</span>
<span class="line-added"> 168  * of a signed 64-bit integer (can be negative).</span>
<span class="line-added"> 169  */</span>
<span class="line-added"> 170 static gint64</span>
<span class="line-added"> 171 _g_win32_filetime_to_unix_time (FILETIME *ft)</span>
<span class="line-added"> 172 {</span>
<span class="line-added"> 173   gint64 result;</span>
<span class="line-added"> 174   /* 1 unit of FILETIME is 100ns */</span>
<span class="line-added"> 175   const gint64 hundreds_of_usec_per_sec = 10000000;</span>
<span class="line-added"> 176   /* The difference between January 1, 1601 UTC (FILETIME epoch) and UNIX epoch</span>
<span class="line-added"> 177    * in hundreds of nanoseconds.</span>
<span class="line-added"> 178    */</span>
<span class="line-added"> 179   const gint64 filetime_unix_epoch_offset = 116444736000000000;</span>
<span class="line-added"> 180 </span>
<span class="line-added"> 181   result = ((gint64) ft-&gt;dwLowDateTime) | (((gint64) ft-&gt;dwHighDateTime) &lt;&lt; 32);</span>
<span class="line-added"> 182   return (result - filetime_unix_epoch_offset) / hundreds_of_usec_per_sec;</span>
<span class="line-added"> 183 }</span>
<span class="line-added"> 184 </span>
<span class="line-added"> 185 #  ifdef _MSC_VER</span>
<span class="line-added"> 186 #    ifndef S_IXUSR</span>
<span class="line-added"> 187 #      define _S_IRUSR _S_IREAD</span>
<span class="line-added"> 188 #      define _S_IWUSR _S_IWRITE</span>
<span class="line-added"> 189 #      define _S_IXUSR _S_IEXEC</span>
<span class="line-added"> 190 #      define S_IRUSR _S_IRUSR</span>
<span class="line-added"> 191 #      define S_IWUSR _S_IWUSR</span>
<span class="line-added"> 192 #      define S_IXUSR _S_IXUSR</span>
<span class="line-added"> 193 #      define S_IRGRP (S_IRUSR &gt;&gt; 3)</span>
<span class="line-added"> 194 #      define S_IWGRP (S_IWUSR &gt;&gt; 3)</span>
<span class="line-added"> 195 #      define S_IXGRP (S_IXUSR &gt;&gt; 3)</span>
<span class="line-added"> 196 #      define S_IROTH (S_IRGRP &gt;&gt; 3)</span>
<span class="line-added"> 197 #      define S_IWOTH (S_IWGRP &gt;&gt; 3)</span>
<span class="line-added"> 198 #      define S_IXOTH (S_IXGRP &gt;&gt; 3)</span>
<span class="line-added"> 199 #    endif</span>
<span class="line-added"> 200 #    ifndef S_ISDIR</span>
<span class="line-added"> 201 #      define S_ISDIR(m) (((m) &amp; _S_IFMT) == _S_IFDIR)</span>
<span class="line-added"> 202 #    endif</span>
<span class="line-added"> 203 #  endif</span>
<span class="line-added"> 204 </span>
<span class="line-added"> 205 /* Uses filename and BHFI to fill a stat64 structure.</span>
<span class="line-added"> 206  * Tries to reproduce the behaviour and quirks of MS C runtime stat().</span>
<span class="line-added"> 207  */</span>
<span class="line-added"> 208 static int</span>
<span class="line-added"> 209 _g_win32_fill_statbuf_from_handle_info (const wchar_t              *filename,</span>
<span class="line-added"> 210                                         const wchar_t              *filename_target,</span>
<span class="line-added"> 211                                         BY_HANDLE_FILE_INFORMATION *handle_info,</span>
<span class="line-added"> 212                                         struct __stat64            *statbuf)</span>
<span class="line-added"> 213 {</span>
<span class="line-added"> 214   wchar_t drive_letter_w = 0;</span>
<span class="line-added"> 215   size_t drive_letter_size = MB_CUR_MAX;</span>
<span class="line-added"> 216   char *drive_letter = _alloca (drive_letter_size);</span>
<span class="line-added"> 217 </span>
<span class="line-added"> 218   /* If filename (target or link) is absolute,</span>
<span class="line-added"> 219    * then use the drive letter from it as-is.</span>
<span class="line-added"> 220    */</span>
<span class="line-added"> 221   if (filename_target != NULL &amp;&amp;</span>
<span class="line-added"> 222       filename_target[0] != L&#39;\0&#39; &amp;&amp;</span>
<span class="line-added"> 223       filename_target[1] == L&#39;:&#39;)</span>
<span class="line-added"> 224     drive_letter_w = filename_target[0];</span>
<span class="line-added"> 225   else if (filename[0] != L&#39;\0&#39; &amp;&amp;</span>
<span class="line-added"> 226            filename[1] == L&#39;:&#39;)</span>
<span class="line-added"> 227     drive_letter_w = filename[0];</span>
<span class="line-added"> 228 </span>
<span class="line-added"> 229   if (drive_letter_w &gt; 0 &amp;&amp;</span>
<span class="line-added"> 230       iswalpha (drive_letter_w) &amp;&amp;</span>
<span class="line-added"> 231       iswascii (drive_letter_w) &amp;&amp;</span>
<span class="line-added"> 232       wctomb (drive_letter, drive_letter_w) == 1)</span>
<span class="line-added"> 233     statbuf-&gt;st_dev = toupper (drive_letter[0]) - &#39;A&#39;; /* 0 means A: drive */</span>
<span class="line-added"> 234   else</span>
<span class="line-added"> 235     /* Otherwise use the PWD drive.</span>
<span class="line-added"> 236      * Return value of 0 gives us 0 - 1 = -1,</span>
<span class="line-added"> 237      * which is the &quot;no idea&quot; value for st_dev.</span>
<span class="line-added"> 238      */</span>
<span class="line-added"> 239     statbuf-&gt;st_dev = _getdrive () - 1;</span>
<span class="line-added"> 240 </span>
<span class="line-added"> 241   statbuf-&gt;st_rdev = statbuf-&gt;st_dev;</span>
<span class="line-added"> 242   /* Theoretically, it&#39;s possible to set it for ext-FS. No idea how.</span>
<span class="line-added"> 243    * Meaningless for all filesystems that Windows normally uses.</span>
<span class="line-added"> 244    */</span>
<span class="line-added"> 245   statbuf-&gt;st_ino = 0;</span>
<span class="line-added"> 246   statbuf-&gt;st_mode = 0;</span>
<span class="line-added"> 247 </span>
<span class="line-added"> 248   if ((handle_info-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)</span>
<span class="line-added"> 249     statbuf-&gt;st_mode |= S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;</span>
<span class="line-added"> 250   else</span>
<span class="line-added"> 251     statbuf-&gt;st_mode |= S_IFREG;</span>
<span class="line-added"> 252   /* No idea what S_IFCHR means here. */</span>
<span class="line-added"> 253   /* S_IFIFO is not even mentioned in MSDN */</span>
<span class="line-added"> 254   /* S_IFBLK is also not mentioned */</span>
<span class="line-added"> 255 </span>
<span class="line-added"> 256   /* The aim here is to reproduce MS stat() behaviour,</span>
<span class="line-added"> 257    * even if it&#39;s braindead.</span>
<span class="line-added"> 258    */</span>
<span class="line-added"> 259   statbuf-&gt;st_mode |= S_IRUSR | S_IRGRP | S_IROTH;</span>
<span class="line-added"> 260   if ((handle_info-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_READONLY) != FILE_ATTRIBUTE_READONLY)</span>
<span class="line-added"> 261     statbuf-&gt;st_mode |= S_IWUSR | S_IWGRP | S_IWOTH;</span>
<span class="line-added"> 262 </span>
<span class="line-added"> 263   if (!S_ISDIR (statbuf-&gt;st_mode))</span>
<span class="line-added"> 264     {</span>
<span class="line-added"> 265       const wchar_t *name;</span>
<span class="line-added"> 266       const wchar_t *dot = NULL;</span>
<span class="line-added"> 267 </span>
<span class="line-added"> 268       if (filename_target != NULL)</span>
<span class="line-added"> 269         name = filename_target;</span>
<span class="line-added"> 270       else</span>
<span class="line-added"> 271         name = filename;</span>
<span class="line-added"> 272 </span>
<span class="line-added"> 273       do</span>
<span class="line-added"> 274         {</span>
<span class="line-added"> 275           wchar_t *last_dot = wcschr (name, L&#39;.&#39;);</span>
<span class="line-added"> 276           if (last_dot == NULL)</span>
<span class="line-added"> 277             break;</span>
<span class="line-added"> 278           dot = last_dot;</span>
<span class="line-added"> 279           name = &amp;last_dot[1];</span>
<span class="line-added"> 280         }</span>
<span class="line-added"> 281       while (TRUE);</span>
<span class="line-added"> 282 </span>
<span class="line-added"> 283       if ((dot != NULL &amp;&amp;</span>
<span class="line-added"> 284           (wcsicmp (dot, L&quot;.exe&quot;) == 0 ||</span>
<span class="line-added"> 285            wcsicmp (dot, L&quot;.com&quot;) == 0 ||</span>
<span class="line-added"> 286            wcsicmp (dot, L&quot;.bat&quot;) == 0 ||</span>
<span class="line-added"> 287            wcsicmp (dot, L&quot;.cmd&quot;) == 0)))</span>
<span class="line-added"> 288         statbuf-&gt;st_mode |= S_IXUSR | S_IXGRP | S_IXOTH;</span>
<span class="line-added"> 289     }</span>
<span class="line-added"> 290 </span>
<span class="line-added"> 291   statbuf-&gt;st_nlink = handle_info-&gt;nNumberOfLinks;</span>
<span class="line-added"> 292   statbuf-&gt;st_uid = statbuf-&gt;st_gid = 0;</span>
<span class="line-added"> 293   statbuf-&gt;st_size = (((guint64) handle_info-&gt;nFileSizeHigh) &lt;&lt; 32) | handle_info-&gt;nFileSizeLow;</span>
<span class="line-added"> 294   statbuf-&gt;st_ctime = _g_win32_filetime_to_unix_time (&amp;handle_info-&gt;ftCreationTime);</span>
<span class="line-added"> 295   statbuf-&gt;st_mtime = _g_win32_filetime_to_unix_time (&amp;handle_info-&gt;ftLastWriteTime);</span>
<span class="line-added"> 296   statbuf-&gt;st_atime = _g_win32_filetime_to_unix_time (&amp;handle_info-&gt;ftLastAccessTime);</span>
<span class="line-added"> 297 </span>
<span class="line-added"> 298   return 0;</span>
<span class="line-added"> 299 }</span>
<span class="line-added"> 300 </span>
<span class="line-added"> 301 /* Fills our private stat-like structure using data from</span>
<span class="line-added"> 302  * a normal stat64 struct, BHFI, FSI and a reparse tag.</span>
<span class="line-added"> 303  */</span>
<span class="line-added"> 304 static void</span>
<span class="line-added"> 305 _g_win32_fill_privatestat (const struct __stat64            *statbuf,</span>
<span class="line-added"> 306                            const BY_HANDLE_FILE_INFORMATION *handle_info,</span>
<span class="line-added"> 307                            const FILE_STANDARD_INFO         *std_info,</span>
<span class="line-added"> 308                            DWORD                             reparse_tag,</span>
<span class="line-added"> 309                            GWin32PrivateStat                *buf)</span>
<span class="line-added"> 310 {</span>
<span class="line-added"> 311   buf-&gt;st_dev = statbuf-&gt;st_dev;</span>
<span class="line-added"> 312   buf-&gt;st_mode = statbuf-&gt;st_mode;</span>
<span class="line-added"> 313   buf-&gt;volume_serial = handle_info-&gt;dwVolumeSerialNumber;</span>
<span class="line-added"> 314   buf-&gt;file_index = (((guint64) handle_info-&gt;nFileIndexHigh) &lt;&lt; 32) | handle_info-&gt;nFileIndexLow;</span>
<span class="line-added"> 315   buf-&gt;attributes = handle_info-&gt;dwFileAttributes;</span>
<span class="line-added"> 316   buf-&gt;st_nlink = handle_info-&gt;nNumberOfLinks;</span>
<span class="line-added"> 317   buf-&gt;st_size = (((guint64) handle_info-&gt;nFileSizeHigh) &lt;&lt; 32) | handle_info-&gt;nFileSizeLow;</span>
<span class="line-added"> 318   buf-&gt;allocated_size = std_info-&gt;AllocationSize.QuadPart;</span>
<span class="line-added"> 319 </span>
<span class="line-added"> 320   buf-&gt;reparse_tag = reparse_tag;</span>
<span class="line-added"> 321 </span>
<span class="line-added"> 322   buf-&gt;st_ctime = statbuf-&gt;st_ctime;</span>
<span class="line-added"> 323   buf-&gt;st_atime = statbuf-&gt;st_atime;</span>
<span class="line-added"> 324   buf-&gt;st_mtime = statbuf-&gt;st_mtime;</span>
<span class="line-added"> 325 }</span>
<span class="line-added"> 326 </span>
<span class="line-added"> 327 /* Read the link data from a symlink/mountpoint represented</span>
<span class="line-added"> 328  * by the handle. Also reads reparse tag.</span>
<span class="line-added"> 329  * @reparse_tag receives the tag. Can be %NULL if @buf or @alloc_buf</span>
<span class="line-added"> 330  *              is non-NULL.</span>
<span class="line-added"> 331  * @buf receives the link data. Can be %NULL if reparse_tag is non-%NULL.</span>
<span class="line-added"> 332  *      Mutually-exclusive with @alloc_buf.</span>
<span class="line-added"> 333  * @buf_size is the size of the @buf, in bytes.</span>
<span class="line-added"> 334  * @alloc_buf points to a location where internally-allocated buffer</span>
<span class="line-added"> 335  *            pointer will be written. That buffer receives the</span>
<span class="line-added"> 336  *            link data. Mutually-exclusive with @buf.</span>
<span class="line-added"> 337  * @terminate ensures that the buffer is NUL-terminated if</span>
<span class="line-added"> 338  *            it isn&#39;t already. Note that this can erase useful</span>
<span class="line-added"> 339  *            data if @buf is provided and @buf_size is too small.</span>
<span class="line-added"> 340  *            Specifically, with @buf_size &lt;= 2 the buffer will</span>
<span class="line-added"> 341  *            receive an empty string, even if there is some</span>
<span class="line-added"> 342  *            data in the reparse point.</span>
<span class="line-added"> 343  * The contents of @buf or @alloc_buf are presented as-is - could</span>
<span class="line-added"> 344  * be non-NUL-terminated (unless @terminate is %TRUE) or even malformed.</span>
<span class="line-added"> 345  * Returns the number of bytes (!) placed into @buf or @alloc_buf,</span>
<span class="line-added"> 346  * including NUL-terminator (if any).</span>
<span class="line-added"> 347  *</span>
<span class="line-added"> 348  * Returned value of 0 means that there&#39;s no recognizable data in the</span>
<span class="line-added"> 349  * reparse point. @alloc_buf will not be allocated in that case,</span>
<span class="line-added"> 350  * and @buf will be left unmodified.</span>
<span class="line-added"> 351  *</span>
<span class="line-added"> 352  * If @buf and @alloc_buf are %NULL, returns 0 to indicate success.</span>
<span class="line-added"> 353  * Returns -1 to indicate an error, sets errno.</span>
<span class="line-added"> 354  */</span>
<span class="line-added"> 355 static int</span>
<span class="line-added"> 356 _g_win32_readlink_handle_raw (HANDLE      h,</span>
<span class="line-added"> 357                               DWORD      *reparse_tag,</span>
<span class="line-added"> 358                               gunichar2  *buf,</span>
<span class="line-added"> 359                               gsize       buf_size,</span>
<span class="line-added"> 360                               gunichar2 **alloc_buf,</span>
<span class="line-added"> 361                               gboolean    terminate)</span>
<span class="line-added"> 362 {</span>
<span class="line-added"> 363   DWORD error_code;</span>
<span class="line-added"> 364   DWORD returned_bytes = 0;</span>
<span class="line-added"> 365   BYTE *data;</span>
<span class="line-added"> 366   gsize to_copy;</span>
<span class="line-added"> 367   /* This is 16k. It&#39;s impossible to make DeviceIoControl() tell us</span>
<span class="line-added"> 368    * the required size. NtFsControlFile() does have such a feature,</span>
<span class="line-added"> 369    * but for some reason it doesn&#39;t work with CreateFile()-returned handles.</span>
<span class="line-added"> 370    * The only alternative is to repeatedly call DeviceIoControl()</span>
<span class="line-added"> 371    * with bigger and bigger buffers, until it succeeds.</span>
<span class="line-added"> 372    * We choose to sacrifice stack space for speed.</span>
<span class="line-added"> 373    */</span>
<span class="line-added"> 374   BYTE max_buffer[sizeof (REPARSE_DATA_BUFFER) + MAXIMUM_REPARSE_DATA_BUFFER_SIZE] = {0,};</span>
<span class="line-added"> 375   DWORD max_buffer_size = sizeof (REPARSE_DATA_BUFFER) + MAXIMUM_REPARSE_DATA_BUFFER_SIZE;</span>
<span class="line-added"> 376   REPARSE_DATA_BUFFER *rep_buf;</span>
<span class="line-added"> 377 </span>
<span class="line-added"> 378   g_return_val_if_fail ((buf != NULL || alloc_buf != NULL || reparse_tag != NULL) &amp;&amp;</span>
<span class="line-added"> 379                         (buf == NULL || alloc_buf == NULL),</span>
<span class="line-added"> 380                         -1);</span>
<span class="line-added"> 381 </span>
<span class="line-added"> 382   if (!DeviceIoControl (h, FSCTL_GET_REPARSE_POINT, NULL, 0,</span>
<span class="line-added"> 383                         max_buffer,</span>
<span class="line-added"> 384                         max_buffer_size,</span>
<span class="line-added"> 385                         &amp;returned_bytes, NULL))</span>
<span class="line-added"> 386     {</span>
<span class="line-added"> 387       error_code = GetLastError ();</span>
<span class="line-added"> 388       errno = w32_error_to_errno (error_code);</span>
<span class="line-added"> 389       return -1;</span>
<span class="line-added"> 390     }</span>
<span class="line-added"> 391 </span>
<span class="line-added"> 392   rep_buf = (REPARSE_DATA_BUFFER *) max_buffer;</span>
<span class="line-added"> 393 </span>
<span class="line-added"> 394   if (reparse_tag != NULL)</span>
<span class="line-added"> 395     *reparse_tag = rep_buf-&gt;ReparseTag;</span>
<span class="line-added"> 396 </span>
<span class="line-added"> 397   if (buf == NULL &amp;&amp; alloc_buf == NULL)</span>
<span class="line-added"> 398     return 0;</span>
<span class="line-added"> 399 </span>
<span class="line-added"> 400   if (rep_buf-&gt;ReparseTag == IO_REPARSE_TAG_SYMLINK)</span>
<span class="line-added"> 401     {</span>
<span class="line-added"> 402       data = &amp;((BYTE *) rep_buf-&gt;SymbolicLinkReparseBuffer.PathBuffer)[rep_buf-&gt;SymbolicLinkReparseBuffer.SubstituteNameOffset];</span>
<span class="line-added"> 403 </span>
<span class="line-added"> 404       to_copy = rep_buf-&gt;SymbolicLinkReparseBuffer.SubstituteNameLength;</span>
<span class="line-added"> 405     }</span>
<span class="line-added"> 406   else if (rep_buf-&gt;ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)</span>
<span class="line-added"> 407     {</span>
<span class="line-added"> 408       data = &amp;((BYTE *) rep_buf-&gt;MountPointReparseBuffer.PathBuffer)[rep_buf-&gt;MountPointReparseBuffer.SubstituteNameOffset];</span>
<span class="line-added"> 409 </span>
<span class="line-added"> 410       to_copy = rep_buf-&gt;MountPointReparseBuffer.SubstituteNameLength;</span>
<span class="line-added"> 411     }</span>
<span class="line-added"> 412   else</span>
<span class="line-added"> 413     to_copy = 0;</span>
<span class="line-added"> 414 </span>
<span class="line-added"> 415   return _g_win32_copy_and_maybe_terminate (data, to_copy, buf, buf_size, alloc_buf, terminate);</span>
<span class="line-added"> 416 }</span>
<span class="line-added"> 417 </span>
<span class="line-added"> 418 /* Read the link data from a symlink/mountpoint represented</span>
<span class="line-added"> 419  * by the @filename.</span>
<span class="line-added"> 420  * @filename is the name of the file.</span>
<span class="line-added"> 421  * @reparse_tag receives the tag. Can be %NULL if @buf or @alloc_buf</span>
<span class="line-added"> 422  *              is non-%NULL.</span>
<span class="line-added"> 423  * @buf receives the link data. Mutually-exclusive with @alloc_buf.</span>
<span class="line-added"> 424  * @buf_size is the size of the @buf, in bytes.</span>
<span class="line-added"> 425  * @alloc_buf points to a location where internally-allocated buffer</span>
<span class="line-added"> 426  *            pointer will be written. That buffer receives the</span>
<span class="line-added"> 427  *            link data. Mutually-exclusive with @buf.</span>
<span class="line-added"> 428  * @terminate ensures that the buffer is NUL-terminated if</span>
<span class="line-added"> 429  *            it isn&#39;t already</span>
<span class="line-added"> 430  * The contents of @buf or @alloc_buf are presented as-is - could</span>
<span class="line-added"> 431  * be non-NUL-terminated (unless @terminate is TRUE) or even malformed.</span>
<span class="line-added"> 432  * Returns the number of bytes (!) placed into @buf or @alloc_buf.</span>
<span class="line-added"> 433  * Returned value of 0 means that there&#39;s no recognizable data in the</span>
<span class="line-added"> 434  * reparse point. @alloc_buf will not be allocated in that case,</span>
<span class="line-added"> 435  * and @buf will be left unmodified.</span>
<span class="line-added"> 436  * If @buf and @alloc_buf are %NULL, returns 0 to indicate success.</span>
<span class="line-added"> 437  * Returns -1 to indicate an error, sets errno.</span>
<span class="line-added"> 438  */</span>
<span class="line-added"> 439 static int</span>
<span class="line-added"> 440 _g_win32_readlink_utf16_raw (const gunichar2  *filename,</span>
<span class="line-added"> 441                              DWORD            *reparse_tag,</span>
<span class="line-added"> 442                              gunichar2        *buf,</span>
<span class="line-added"> 443                              gsize             buf_size,</span>
<span class="line-added"> 444                              gunichar2       **alloc_buf,</span>
<span class="line-added"> 445                              gboolean          terminate)</span>
<span class="line-added"> 446 {</span>
<span class="line-added"> 447   HANDLE h;</span>
<span class="line-added"> 448   DWORD attributes;</span>
<span class="line-added"> 449   DWORD to_copy;</span>
<span class="line-added"> 450   DWORD error_code;</span>
<span class="line-added"> 451 </span>
<span class="line-added"> 452   if ((attributes = GetFileAttributesW (filename)) == 0)</span>
<span class="line-added"> 453     {</span>
<span class="line-added"> 454       error_code = GetLastError ();</span>
<span class="line-added"> 455       errno = w32_error_to_errno (error_code);</span>
<span class="line-added"> 456       return -1;</span>
<span class="line-added"> 457     }</span>
<span class="line-added"> 458 </span>
<span class="line-added"> 459   if ((attributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) == 0)</span>
<span class="line-added"> 460     {</span>
<span class="line-added"> 461       errno = EINVAL;</span>
<span class="line-added"> 462       return -1;</span>
<span class="line-added"> 463     }</span>
<span class="line-added"> 464 </span>
<span class="line-added"> 465   /* To read symlink target we need to open the file as a reparse</span>
<span class="line-added"> 466    * point and use DeviceIoControl() on it.</span>
<span class="line-added"> 467    */</span>
<span class="line-added"> 468   h = CreateFileW (filename,</span>
<span class="line-added"> 469                    FILE_READ_EA,</span>
<span class="line-added"> 470                    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,</span>
<span class="line-added"> 471                    NULL, OPEN_EXISTING,</span>
<span class="line-added"> 472                    FILE_ATTRIBUTE_NORMAL</span>
<span class="line-added"> 473                    | FILE_FLAG_OPEN_REPARSE_POINT</span>
<span class="line-added"> 474                    | (attributes &amp; FILE_ATTRIBUTE_DIRECTORY ? FILE_FLAG_BACKUP_SEMANTICS : 0),</span>
<span class="line-added"> 475                    NULL);</span>
<span class="line-added"> 476 </span>
<span class="line-added"> 477   if (h == INVALID_HANDLE_VALUE)</span>
<span class="line-added"> 478     {</span>
<span class="line-added"> 479       error_code = GetLastError ();</span>
<span class="line-added"> 480       errno = w32_error_to_errno (error_code);</span>
<span class="line-added"> 481       return -1;</span>
<span class="line-added"> 482     }</span>
<span class="line-added"> 483 </span>
<span class="line-added"> 484   to_copy = _g_win32_readlink_handle_raw (h, reparse_tag, buf, buf_size, alloc_buf, terminate);</span>
<span class="line-added"> 485 </span>
<span class="line-added"> 486   CloseHandle (h);</span>
<span class="line-added"> 487 </span>
<span class="line-added"> 488   return to_copy;</span>
<span class="line-added"> 489 }</span>
<span class="line-added"> 490 </span>
<span class="line-added"> 491 /* Read the link data from a symlink/mountpoint represented</span>
<span class="line-added"> 492  * by a UTF-16 filename or a file handle.</span>
<span class="line-added"> 493  * @filename is the name of the file. Mutually-exclusive with @file_handle.</span>
<span class="line-added"> 494  * @file_handle is the handle of the file. Mutually-exclusive with @filename.</span>
<span class="line-added"> 495  * @reparse_tag receives the tag. Can be %NULL if @buf or @alloc_buf</span>
<span class="line-added"> 496  *              is non-%NULL.</span>
<span class="line-added"> 497  * @buf receives the link data. Mutually-exclusive with @alloc_buf.</span>
<span class="line-added"> 498  * @buf_size is the size of the @buf, in bytes.</span>
<span class="line-added"> 499  * @alloc_buf points to a location where internally-allocated buffer</span>
<span class="line-added"> 500  *            pointer will be written. That buffer receives the</span>
<span class="line-added"> 501  *            link data. Mutually-exclusive with @buf.</span>
<span class="line-added"> 502  * @terminate ensures that the buffer is NUL-terminated if</span>
<span class="line-added"> 503  *            it isn&#39;t already</span>
<span class="line-added"> 504  * The contents of @buf or @alloc_buf are adjusted</span>
<span class="line-added"> 505  * (extended or nt object manager prefix is stripped),</span>
<span class="line-added"> 506  * but otherwise they are presented as-is - could be non-NUL-terminated</span>
<span class="line-added"> 507  * (unless @terminate is TRUE) or even malformed.</span>
<span class="line-added"> 508  * Returns the number of bytes (!) placed into @buf or @alloc_buf.</span>
<span class="line-added"> 509  * Returned value of 0 means that there&#39;s no recognizable data in the</span>
<span class="line-added"> 510  * reparse point. @alloc_buf will not be allocated in that case,</span>
<span class="line-added"> 511  * and @buf will be left unmodified.</span>
<span class="line-added"> 512  * Returns -1 to indicate an error, sets errno.</span>
<span class="line-added"> 513  */</span>
<span class="line-added"> 514 static int</span>
<span class="line-added"> 515 _g_win32_readlink_utf16_handle (const gunichar2  *filename,</span>
<span class="line-added"> 516                                 HANDLE            file_handle,</span>
<span class="line-added"> 517                                 DWORD            *reparse_tag,</span>
<span class="line-added"> 518                                 gunichar2        *buf,</span>
<span class="line-added"> 519                                 gsize             buf_size,</span>
<span class="line-added"> 520                                 gunichar2       **alloc_buf,</span>
<span class="line-added"> 521                                 gboolean          terminate)</span>
<span class="line-added"> 522 {</span>
<span class="line-added"> 523   int   result;</span>
<span class="line-added"> 524   gsize string_size;</span>
<span class="line-added"> 525 </span>
<span class="line-added"> 526   g_return_val_if_fail ((buf != NULL || alloc_buf != NULL || reparse_tag != NULL) &amp;&amp;</span>
<span class="line-added"> 527                         (filename != NULL || file_handle != NULL) &amp;&amp;</span>
<span class="line-added"> 528                         (buf == NULL || alloc_buf == NULL) &amp;&amp;</span>
<span class="line-added"> 529                         (filename == NULL || file_handle == NULL),</span>
<span class="line-added"> 530                         -1);</span>
<span class="line-added"> 531 </span>
<span class="line-added"> 532   if (filename)</span>
<span class="line-added"> 533     result = _g_win32_readlink_utf16_raw (filename, reparse_tag, buf, buf_size, alloc_buf, terminate);</span>
<span class="line-added"> 534   else</span>
<span class="line-added"> 535     result = _g_win32_readlink_handle_raw (file_handle, reparse_tag, buf, buf_size, alloc_buf, terminate);</span>
<span class="line-added"> 536 </span>
<span class="line-added"> 537   if (result &lt;= 0)</span>
<span class="line-added"> 538     return result;</span>
<span class="line-added"> 539 </span>
<span class="line-added"> 540   /* Ensure that output is a multiple of sizeof (gunichar2),</span>
<span class="line-added"> 541    * cutting any trailing partial gunichar2, if present.</span>
<span class="line-added"> 542    */</span>
<span class="line-added"> 543   result -= result % sizeof (gunichar2);</span>
<span class="line-added"> 544 </span>
<span class="line-added"> 545   if (result &lt;= 0)</span>
<span class="line-added"> 546     return result;</span>
<span class="line-added"> 547 </span>
<span class="line-added"> 548   /* DeviceIoControl () tends to return filenames as NT Object Manager</span>
<span class="line-added"> 549    * names , i.e. &quot;\\??\\C:\\foo\\bar&quot;.</span>
<span class="line-added"> 550    * Remove the leading 4-byte &quot;\\??\\&quot; prefix, as glib (as well as many W32 API</span>
<span class="line-added"> 551    * functions) is unprepared to deal with it. Unless it has no &#39;x:&#39; drive</span>
<span class="line-added"> 552    * letter part after the prefix, in which case we leave everything</span>
<span class="line-added"> 553    * as-is, because the path could be &quot;\\??\\Volume{GUID}&quot; - stripping</span>
<span class="line-added"> 554    * the prefix will allow it to be confused with relative links</span>
<span class="line-added"> 555    * targeting &quot;Volume{GUID}&quot;.</span>
<span class="line-added"> 556    */</span>
<span class="line-added"> 557   string_size = result / sizeof (gunichar2);</span>
<span class="line-added"> 558   _g_win32_strip_extended_ntobjm_prefix (buf ? buf : *alloc_buf, &amp;string_size);</span>
<span class="line-added"> 559 </span>
<span class="line-added"> 560   return string_size * sizeof (gunichar2);</span>
<span class="line-added"> 561 }</span>
<span class="line-added"> 562 </span>
<span class="line-added"> 563 /* Works like stat() or lstat(), depending on the value of @for_symlink,</span>
<span class="line-added"> 564  * but accepts filename in UTF-16 and fills our custom stat structure.</span>
<span class="line-added"> 565  * The @filename must not have trailing slashes.</span>
<span class="line-added"> 566  */</span>
 567 static int
 568 _g_win32_stat_utf16_no_trailing_slashes (const gunichar2    *filename,
<a name="8" id="anc8"></a>
 569                                          GWin32PrivateStat  *buf,
 570                                          gboolean            for_symlink)
 571 {
<a name="9" id="anc9"></a>


 572   struct __stat64 statbuf;
 573   BY_HANDLE_FILE_INFORMATION handle_info;
 574   FILE_STANDARD_INFO std_info;
<a name="10" id="anc10"></a>

 575   gboolean is_symlink = FALSE;
<a name="11" id="anc11"></a>

 576   wchar_t *filename_target = NULL;
<a name="12" id="anc12"></a><span class="line-modified"> 577   DWORD immediate_attributes;</span>
<span class="line-added"> 578   DWORD open_flags;</span>
<span class="line-added"> 579   gboolean is_directory;</span>
<span class="line-added"> 580   DWORD reparse_tag = 0;</span>
<span class="line-added"> 581   DWORD error_code;</span>
<span class="line-added"> 582   BOOL succeeded_so_far;</span>
<span class="line-added"> 583   HANDLE file_handle;</span>
 584 
<a name="13" id="anc13"></a><span class="line-modified"> 585   immediate_attributes = GetFileAttributesW (filename);</span>


 586 
<a name="14" id="anc14"></a><span class="line-modified"> 587   if (immediate_attributes == INVALID_FILE_ATTRIBUTES)</span>
<span class="line-modified"> 588     {</span>
<span class="line-modified"> 589       error_code = GetLastError ();</span>
<span class="line-modified"> 590       errno = w32_error_to_errno (error_code);</span>
 591 
<a name="15" id="anc15"></a><span class="line-modified"> 592       return -1;</span>
<span class="line-modified"> 593     }</span>
 594 
<a name="16" id="anc16"></a><span class="line-modified"> 595   is_symlink = (immediate_attributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;</span>
<span class="line-modified"> 596   is_directory = (immediate_attributes &amp; FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY;</span>
 597 
<a name="17" id="anc17"></a><span class="line-modified"> 598   open_flags = FILE_ATTRIBUTE_NORMAL;</span>
 599 
<a name="18" id="anc18"></a><span class="line-modified"> 600   if (for_symlink &amp;&amp; is_symlink)</span>
<span class="line-modified"> 601     open_flags |= FILE_FLAG_OPEN_REPARSE_POINT;</span>
 602 
<a name="19" id="anc19"></a><span class="line-modified"> 603   if (is_directory)</span>
<span class="line-modified"> 604     open_flags |= FILE_FLAG_BACKUP_SEMANTICS;</span>
 605 
<a name="20" id="anc20"></a><span class="line-modified"> 606   file_handle = CreateFileW (filename, FILE_READ_ATTRIBUTES | FILE_READ_EA,</span>
<span class="line-modified"> 607                              FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,</span>
<span class="line-modified"> 608                              NULL, OPEN_EXISTING,</span>
<span class="line-modified"> 609                              open_flags,</span>
<span class="line-added"> 610                              NULL);</span>
 611 
<a name="21" id="anc21"></a><span class="line-modified"> 612   if (file_handle == INVALID_HANDLE_VALUE)</span>







 613     {
<a name="22" id="anc22"></a><span class="line-modified"> 614       error_code = GetLastError ();</span>
<span class="line-modified"> 615       errno = w32_error_to_errno (error_code);</span>
<span class="line-modified"> 616       return -1;</span>

 617     }
 618 
 619   succeeded_so_far = GetFileInformationByHandle (file_handle,
 620                                                  &amp;handle_info);
 621   error_code = GetLastError ();
 622 
 623   if (succeeded_so_far)
 624     {
 625       succeeded_so_far = GetFileInformationByHandleEx (file_handle,
 626                                                        FileStandardInfo,
 627                                                        &amp;std_info,
 628                                                        sizeof (std_info));
 629       error_code = GetLastError ();
 630     }
 631 
 632   if (!succeeded_so_far)
 633     {
<a name="23" id="anc23"></a><span class="line-modified"> 634       CloseHandle (file_handle);</span>

 635       errno = w32_error_to_errno (error_code);
 636       return -1;
 637     }
 638 
 639   /* It&#39;s tempting to use GetFileInformationByHandleEx(FileAttributeTagInfo),
 640    * but it always reports that the ReparseTag is 0.
<a name="24" id="anc24"></a><span class="line-added"> 641    * We already have a handle open for symlink, use that.</span>
<span class="line-added"> 642    * For the target we have to specify a filename, and the function</span>
<span class="line-added"> 643    * will open another handle internally.</span>
 644    */
<a name="25" id="anc25"></a><span class="line-modified"> 645   if (is_symlink &amp;&amp;</span>
<span class="line-added"> 646       _g_win32_readlink_utf16_handle (for_symlink ? NULL : filename,</span>
<span class="line-added"> 647                                       for_symlink ? file_handle : NULL,</span>
<span class="line-added"> 648                                       &amp;reparse_tag,</span>
<span class="line-added"> 649                                       NULL, 0,</span>
<span class="line-added"> 650                                       for_symlink ? NULL : &amp;filename_target,</span>
<span class="line-added"> 651                                       TRUE) &lt; 0)</span>
 652     {
<a name="26" id="anc26"></a><span class="line-modified"> 653       CloseHandle (file_handle);</span>
<span class="line-added"> 654       return -1;</span>
<span class="line-added"> 655     }</span>
 656 
<a name="27" id="anc27"></a><span class="line-modified"> 657   CloseHandle (file_handle);</span>














 658 
<a name="28" id="anc28"></a><span class="line-modified"> 659   _g_win32_fill_statbuf_from_handle_info (filename,</span>
<span class="line-modified"> 660                                           filename_target,</span>
<span class="line-modified"> 661                                           &amp;handle_info,</span>
<span class="line-modified"> 662                                           &amp;statbuf);</span>
<span class="line-modified"> 663   g_free (filename_target);</span>
<span class="line-modified"> 664   _g_win32_fill_privatestat (&amp;statbuf,</span>
<span class="line-modified"> 665                              &amp;handle_info,</span>
<span class="line-modified"> 666                              &amp;std_info,</span>
<span class="line-modified"> 667                              reparse_tag,</span>
<span class="line-modified"> 668                              buf);</span>









































































 669 
<a name="29" id="anc29"></a><span class="line-modified"> 670   return 0;</span>
<span class="line-modified"> 671 }</span>



 672 
<a name="30" id="anc30"></a><span class="line-modified"> 673 /* Works like fstat(), but fills our custom stat structure. */</span>
<span class="line-modified"> 674 static int</span>
<span class="line-modified"> 675 _g_win32_stat_fd (int                 fd,</span>
<span class="line-modified"> 676                   GWin32PrivateStat  *buf)</span>
<span class="line-modified"> 677 {</span>
<span class="line-added"> 678   HANDLE file_handle;</span>
<span class="line-added"> 679   gboolean succeeded_so_far;</span>
<span class="line-added"> 680   DWORD error_code;</span>
<span class="line-added"> 681   struct __stat64 statbuf;</span>
<span class="line-added"> 682   BY_HANDLE_FILE_INFORMATION handle_info;</span>
<span class="line-added"> 683   FILE_STANDARD_INFO std_info;</span>
<span class="line-added"> 684   DWORD reparse_tag = 0;</span>
<span class="line-added"> 685   gboolean is_symlink = FALSE;</span>
 686 
<a name="31" id="anc31"></a><span class="line-modified"> 687   file_handle = (HANDLE) _get_osfhandle (fd);</span>



 688 
<a name="32" id="anc32"></a><span class="line-modified"> 689   if (file_handle == INVALID_HANDLE_VALUE)</span>
<span class="line-modified"> 690     return -1;</span>

 691 
<a name="33" id="anc33"></a><span class="line-modified"> 692   succeeded_so_far = GetFileInformationByHandle (file_handle,</span>
<span class="line-modified"> 693                                                  &amp;handle_info);</span>
<span class="line-added"> 694   error_code = GetLastError ();</span>
 695 
<a name="34" id="anc34"></a><span class="line-added"> 696   if (succeeded_so_far)</span>
<span class="line-added"> 697     {</span>
<span class="line-added"> 698       succeeded_so_far = GetFileInformationByHandleEx (file_handle,</span>
<span class="line-added"> 699                                                        FileStandardInfo,</span>
<span class="line-added"> 700                                                        &amp;std_info,</span>
<span class="line-added"> 701                                                        sizeof (std_info));</span>
<span class="line-added"> 702       error_code = GetLastError ();</span>
<span class="line-added"> 703     }</span>
<span class="line-added"> 704 </span>
<span class="line-added"> 705   if (!succeeded_so_far)</span>
<span class="line-added"> 706     {</span>
<span class="line-added"> 707       errno = w32_error_to_errno (error_code);</span>
 708       return -1;
 709     }
 710 
<a name="35" id="anc35"></a><span class="line-modified"> 711   is_symlink = (handle_info.dwFileAttributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;</span>
 712 
<a name="36" id="anc36"></a><span class="line-modified"> 713   if (is_symlink &amp;&amp;</span>
<span class="line-modified"> 714       _g_win32_readlink_handle_raw (file_handle, &amp;reparse_tag, NULL, 0, NULL, FALSE) &lt; 0)</span>
<span class="line-modified"> 715     return -1;</span>










 716 
<a name="37" id="anc37"></a><span class="line-modified"> 717   if (_fstat64 (fd, &amp;statbuf) != 0)</span>
<span class="line-modified"> 718     return -1;</span>


 719 
<a name="38" id="anc38"></a><span class="line-modified"> 720   _g_win32_fill_privatestat (&amp;statbuf,</span>
<span class="line-modified"> 721                              &amp;handle_info,</span>
<span class="line-modified"> 722                              &amp;std_info,</span>
<span class="line-added"> 723                              reparse_tag,</span>
<span class="line-added"> 724                              buf);</span>
 725 
 726   return 0;
 727 }
 728 
<a name="39" id="anc39"></a><span class="line-added"> 729 /* Works like stat() or lstat(), depending on the value of @for_symlink,</span>
<span class="line-added"> 730  * but accepts filename in UTF-8 and fills our custom stat structure.</span>
<span class="line-added"> 731  */</span>
 732 static int
 733 _g_win32_stat_utf8 (const gchar       *filename,
 734                     GWin32PrivateStat *buf,
 735                     gboolean           for_symlink)
 736 {
 737   wchar_t *wfilename;
 738   int result;
 739   gsize len;
 740 
 741   if (filename == NULL)
 742     {
 743       errno = EINVAL;
 744       return -1;
 745     }
 746 
 747   len = strlen (filename);
 748 
 749   while (len &gt; 0 &amp;&amp; G_IS_DIR_SEPARATOR (filename[len - 1]))
 750     len--;
 751 
 752   if (len &lt;= 0 ||
 753       (g_path_is_absolute (filename) &amp;&amp; len &lt;= g_path_skip_root (filename) - filename))
 754     len = strlen (filename);
 755 
 756   wfilename = g_utf8_to_utf16 (filename, len, NULL, NULL, NULL);
 757 
 758   if (wfilename == NULL)
 759     {
 760       errno = EINVAL;
 761       return -1;
 762     }
 763 
<a name="40" id="anc40"></a><span class="line-modified"> 764   result = _g_win32_stat_utf16_no_trailing_slashes (wfilename, buf, for_symlink);</span>
 765 
 766   g_free (wfilename);
 767 
 768   return result;
 769 }
 770 
<a name="41" id="anc41"></a><span class="line-added"> 771 /* Works like stat(), but accepts filename in UTF-8</span>
<span class="line-added"> 772  * and fills our custom stat structure.</span>
<span class="line-added"> 773  */</span>
 774 int
 775 g_win32_stat_utf8 (const gchar       *filename,
 776                    GWin32PrivateStat *buf)
 777 {
 778   return _g_win32_stat_utf8 (filename, buf, FALSE);
 779 }
 780 
<a name="42" id="anc42"></a><span class="line-added"> 781 /* Works like lstat(), but accepts filename in UTF-8</span>
<span class="line-added"> 782  * and fills our custom stat structure.</span>
<span class="line-added"> 783  */</span>
 784 int
 785 g_win32_lstat_utf8 (const gchar       *filename,
 786                     GWin32PrivateStat *buf)
 787 {
 788   return _g_win32_stat_utf8 (filename, buf, TRUE);
 789 }
 790 
<a name="43" id="anc43"></a><span class="line-added"> 791 /* Works like fstat(), but accepts filename in UTF-8</span>
<span class="line-added"> 792  * and fills our custom stat structure.</span>
<span class="line-added"> 793  */</span>
 794 int
 795 g_win32_fstat (int                fd,
 796                GWin32PrivateStat *buf)
 797 {
<a name="44" id="anc44"></a><span class="line-modified"> 798   return _g_win32_stat_fd (fd, buf);</span>
 799 }
 800 
<a name="45" id="anc45"></a><span class="line-modified"> 801 /**</span>
<span class="line-modified"> 802  * g_win32_readlink_utf8:</span>
<span class="line-modified"> 803  * @filename: (type filename): a pathname in UTF-8</span>
<span class="line-modified"> 804  * @buf: (array length=buf_size) : a buffer to receive the reparse point</span>
<span class="line-added"> 805  *                                 target path. Mutually-exclusive</span>
<span class="line-added"> 806  *                                 with @alloc_buf.</span>
<span class="line-added"> 807  * @buf_size: size of the @buf, in bytes</span>
<span class="line-added"> 808  * @alloc_buf: points to a location where internally-allocated buffer</span>
<span class="line-added"> 809  *             pointer will be written. That buffer receives the</span>
<span class="line-added"> 810  *             link data. Mutually-exclusive with @buf.</span>
<span class="line-added"> 811  * @terminate: ensures that the buffer is NUL-terminated if</span>
<span class="line-added"> 812  *             it isn&#39;t already. If %FALSE, the returned string</span>
<span class="line-added"> 813  *             might not be NUL-terminated (depends entirely on</span>
<span class="line-added"> 814  *             what the contents of the filesystem are).</span>
<span class="line-added"> 815  *</span>
<span class="line-added"> 816  * Tries to read the reparse point indicated by @filename, filling</span>
<span class="line-added"> 817  * @buf or @alloc_buf with the path that the reparse point redirects to.</span>
<span class="line-added"> 818  * The path will be UTF-8-encoded, and an extended path prefix</span>
<span class="line-added"> 819  * or a NT object manager prefix will be removed from it, if</span>
<span class="line-added"> 820  * possible, but otherwise the path is returned as-is. Specifically,</span>
<span class="line-added"> 821  * it could be a &quot;\\\\Volume{GUID}\\&quot; path. It also might use</span>
<span class="line-added"> 822  * backslashes as path separators.</span>
<span class="line-added"> 823  *</span>
<span class="line-added"> 824  * Returns: -1 on error (sets errno), 0 if there&#39;s no (recognizable)</span>
<span class="line-added"> 825  * path in the reparse point (@alloc_buf will not be allocated in that case,</span>
<span class="line-added"> 826  * and @buf will be left unmodified),</span>
<span class="line-added"> 827  * or the number of bytes placed into @buf otherwise,</span>
<span class="line-added"> 828  * including NUL-terminator (if present or if @terminate is TRUE).</span>
<span class="line-added"> 829  * The buffer returned via @alloc_buf should be freed with g_free().</span>
<span class="line-added"> 830  *</span>
<span class="line-added"> 831  * Since: 2.60</span>
<span class="line-added"> 832  */</span>
<span class="line-added"> 833 int</span>
<span class="line-added"> 834 g_win32_readlink_utf8 (const gchar  *filename,</span>
<span class="line-added"> 835                        gchar        *buf,</span>
<span class="line-added"> 836                        gsize         buf_size,</span>
<span class="line-added"> 837                        gchar       **alloc_buf,</span>
<span class="line-added"> 838                        gboolean      terminate)</span>
 839 {
<a name="46" id="anc46"></a><span class="line-modified"> 840   wchar_t *wfilename;</span>
<span class="line-modified"> 841   int result;</span>
<span class="line-modified"> 842   wchar_t *buf_utf16;</span>
<span class="line-modified"> 843   glong tmp_len;</span>
<span class="line-modified"> 844   gchar *tmp;</span>


 845 
<a name="47" id="anc47"></a><span class="line-modified"> 846   g_return_val_if_fail ((buf != NULL || alloc_buf != NULL) &amp;&amp;</span>
<span class="line-modified"> 847                         (buf == NULL || alloc_buf == NULL),</span>
<span class="line-modified"> 848                         -1);</span>



 849 
<a name="48" id="anc48"></a><span class="line-modified"> 850   wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);</span>





 851 
<a name="49" id="anc49"></a><span class="line-modified"> 852   if (wfilename == NULL)</span>
 853     {
 854       errno = EINVAL;
 855       return -1;
 856     }
 857 
<a name="50" id="anc50"></a><span class="line-modified"> 858   result = _g_win32_readlink_utf16_handle (wfilename, NULL, NULL,</span>
<span class="line-modified"> 859                                            NULL, 0, &amp;buf_utf16, terminate);</span>





























 860 
<a name="51" id="anc51"></a><span class="line-modified"> 861   g_free (wfilename);</span>










































 862 
 863   if (result &lt;= 0)
 864     return result;
 865 
<a name="52" id="anc52"></a><span class="line-modified"> 866   tmp = g_utf16_to_utf8 (buf_utf16,</span>
<span class="line-modified"> 867                          result / sizeof (gunichar2),</span>
<span class="line-modified"> 868                          NULL,</span>
<span class="line-modified"> 869                          &amp;tmp_len,</span>
<span class="line-modified"> 870                          NULL);</span>






 871 
<a name="53" id="anc53"></a><span class="line-modified"> 872   g_free (buf_utf16);</span>

 873 
<a name="54" id="anc54"></a><span class="line-modified"> 874   if (tmp == NULL)</span>






























 875     {
 876       errno = EINVAL;
 877       return -1;
 878     }
 879 
<a name="55" id="anc55"></a><span class="line-modified"> 880   if (alloc_buf)</span>




 881     {
<a name="56" id="anc56"></a><span class="line-modified"> 882       *alloc_buf = tmp;</span>
<span class="line-modified"> 883       return tmp_len;</span>






















 884     }
 885 
<a name="57" id="anc57"></a><span class="line-modified"> 886   if (tmp_len &gt; buf_size)</span>
<span class="line-added"> 887     tmp_len = buf_size;</span>
<span class="line-added"> 888 </span>
<span class="line-added"> 889   memcpy (buf, tmp, tmp_len);</span>
<span class="line-added"> 890   g_free (tmp);</span>
<span class="line-added"> 891 </span>
<span class="line-added"> 892   return tmp_len;</span>
 893 }
 894 
 895 #endif
 896 
 897 /**
 898  * g_access:
 899  * @filename: (type filename): a pathname in the GLib file name encoding
 900  *     (UTF-8 on Windows)
 901  * @mode: as in access()
 902  *
 903  * A wrapper for the POSIX access() function. This function is used to
 904  * test a pathname for one or several of read, write or execute
 905  * permissions, or just existence.
 906  *
 907  * On Windows, the file protection mechanism is not at all POSIX-like,
 908  * and the underlying function in the C library only checks the
 909  * FAT-style READONLY attribute, and does not look at the ACL of a
 910  * file at all. This function is this in practise almost useless on
 911  * Windows. Software that needs to handle file permissions on Windows
 912  * more exactly should use the Win32 API.
 913  *
 914  * See your C library manual for more details about access().
 915  *
 916  * Returns: zero if the pathname refers to an existing file system
 917  *     object that has all the tested permissions, or -1 otherwise
 918  *     or on error.
 919  *
 920  * Since: 2.8
 921  */
 922 int
 923 g_access (const gchar *filename,
<a name="58" id="anc58"></a><span class="line-modified"> 924     int          mode)</span>
 925 {
 926 #ifdef G_OS_WIN32
 927   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 928   int retval;
 929   int save_errno;
 930 
 931   if (wfilename == NULL)
 932     {
 933       errno = EINVAL;
 934       return -1;
 935     }
 936 
 937 #ifndef X_OK
 938 #define X_OK 1
 939 #endif
 940 
 941   retval = _waccess (wfilename, mode &amp; ~X_OK);
 942   save_errno = errno;
 943 
 944   g_free (wfilename);
 945 
 946   errno = save_errno;
 947   return retval;
 948 #else
 949   return access (filename, mode);
 950 #endif
 951 }
 952 
 953 /**
 954  * g_chmod:
 955  * @filename: (type filename): a pathname in the GLib file name encoding
 956  *     (UTF-8 on Windows)
 957  * @mode: as in chmod()
 958  *
 959  * A wrapper for the POSIX chmod() function. The chmod() function is
 960  * used to set the permissions of a file system object.
 961  *
 962  * On Windows the file protection mechanism is not at all POSIX-like,
 963  * and the underlying chmod() function in the C library just sets or
 964  * clears the FAT-style READONLY attribute. It does not touch any
 965  * ACL. Software that needs to manage file permissions on Windows
 966  * exactly should use the Win32 API.
 967  *
 968  * See your C library manual for more details about chmod().
 969  *
 970  * Returns: 0 if the operation succeeded, -1 on error
 971  *
 972  * Since: 2.8
 973  */
 974 int
 975 g_chmod (const gchar *filename,
<a name="59" id="anc59"></a><span class="line-modified"> 976    int          mode)</span>
 977 {
 978 #ifdef G_OS_WIN32
 979   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 980   int retval;
 981   int save_errno;
 982 
 983   if (wfilename == NULL)
 984     {
 985       errno = EINVAL;
 986       return -1;
 987     }
 988 
 989   retval = _wchmod (wfilename, mode);
 990   save_errno = errno;
 991 
 992   g_free (wfilename);
 993 
 994   errno = save_errno;
 995   return retval;
 996 #else
 997   return chmod (filename, mode);
 998 #endif
 999 }
1000 /**
1001  * g_open:
1002  * @filename: (type filename): a pathname in the GLib file name encoding
1003  *     (UTF-8 on Windows)
1004  * @flags: as in open()
1005  * @mode: as in open()
1006  *
1007  * A wrapper for the POSIX open() function. The open() function is
1008  * used to convert a pathname into a file descriptor.
1009  *
1010  * On POSIX systems file descriptors are implemented by the operating
1011  * system. On Windows, it&#39;s the C library that implements open() and
1012  * file descriptors. The actual Win32 API for opening files is quite
1013  * different, see MSDN documentation for CreateFile(). The Win32 API
1014  * uses file handles, which are more randomish integers, not small
1015  * integers like file descriptors.
1016  *
1017  * Because file descriptors are specific to the C library on Windows,
1018  * the file descriptor returned by this function makes sense only to
1019  * functions in the same C library. Thus if the GLib-using code uses a
1020  * different C library than GLib does, the file descriptor returned by
1021  * this function cannot be passed to C library functions like write()
1022  * or read().
1023  *
1024  * See your C library manual for more details about open().
1025  *
1026  * Returns: a new file descriptor, or -1 if an error occurred.
1027  *     The return value can be used exactly like the return value
1028  *     from open().
1029  *
1030  * Since: 2.6
1031  */
1032 int
1033 g_open (const gchar *filename,
<a name="60" id="anc60"></a><span class="line-modified">1034   int          flags,</span>
<span class="line-modified">1035   int          mode)</span>
1036 {
1037 #ifdef G_OS_WIN32
1038   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1039   int retval;
1040   int save_errno;
1041 
1042   if (wfilename == NULL)
1043     {
1044       errno = EINVAL;
1045       return -1;
1046     }
1047 
1048   retval = _wopen (wfilename, flags, mode);
1049   save_errno = errno;
1050 
1051   g_free (wfilename);
1052 
1053   errno = save_errno;
1054   return retval;
1055 #else
1056   int fd;
1057   do
1058     fd = open (filename, flags, mode);
1059   while (G_UNLIKELY (fd == -1 &amp;&amp; errno == EINTR));
1060   return fd;
1061 #endif
1062 }
1063 
1064 /**
1065  * g_creat:
1066  * @filename: (type filename): a pathname in the GLib file name encoding
1067  *     (UTF-8 on Windows)
1068  * @mode: as in creat()
1069  *
1070  * A wrapper for the POSIX creat() function. The creat() function is
1071  * used to convert a pathname into a file descriptor, creating a file
1072  * if necessary.
1073  *
1074  * On POSIX systems file descriptors are implemented by the operating
1075  * system. On Windows, it&#39;s the C library that implements creat() and
1076  * file descriptors. The actual Windows API for opening files is
1077  * different, see MSDN documentation for CreateFile(). The Win32 API
1078  * uses file handles, which are more randomish integers, not small
1079  * integers like file descriptors.
1080  *
1081  * Because file descriptors are specific to the C library on Windows,
1082  * the file descriptor returned by this function makes sense only to
1083  * functions in the same C library. Thus if the GLib-using code uses a
1084  * different C library than GLib does, the file descriptor returned by
1085  * this function cannot be passed to C library functions like write()
1086  * or read().
1087  *
1088  * See your C library manual for more details about creat().
1089  *
1090  * Returns: a new file descriptor, or -1 if an error occurred.
1091  *     The return value can be used exactly like the return value
1092  *     from creat().
1093  *
1094  * Since: 2.8
1095  */
1096 int
1097 g_creat (const gchar *filename,
<a name="61" id="anc61"></a><span class="line-modified">1098    int          mode)</span>
1099 {
1100 #ifdef G_OS_WIN32
1101   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1102   int retval;
1103   int save_errno;
1104 
1105   if (wfilename == NULL)
1106     {
1107       errno = EINVAL;
1108       return -1;
1109     }
1110 
1111   retval = _wcreat (wfilename, mode);
1112   save_errno = errno;
1113 
1114   g_free (wfilename);
1115 
1116   errno = save_errno;
1117   return retval;
1118 #else
1119   return creat (filename, mode);
1120 #endif
1121 }
1122 
1123 /**
1124  * g_rename:
1125  * @oldfilename: (type filename): a pathname in the GLib file name encoding
1126  *     (UTF-8 on Windows)
1127  * @newfilename: (type filename): a pathname in the GLib file name encoding
1128  *
1129  * A wrapper for the POSIX rename() function. The rename() function
1130  * renames a file, moving it between directories if required.
1131  *
1132  * See your C library manual for more details about how rename() works
1133  * on your system. It is not possible in general on Windows to rename
1134  * a file that is open to some process.
1135  *
1136  * Returns: 0 if the renaming succeeded, -1 if an error occurred
1137  *
1138  * Since: 2.6
1139  */
1140 int
1141 g_rename (const gchar *oldfilename,
<a name="62" id="anc62"></a><span class="line-modified">1142     const gchar *newfilename)</span>
1143 {
1144 #ifdef G_OS_WIN32
1145   wchar_t *woldfilename = g_utf8_to_utf16 (oldfilename, -1, NULL, NULL, NULL);
1146   wchar_t *wnewfilename;
1147   int retval;
1148   int save_errno = 0;
1149 
1150   if (woldfilename == NULL)
1151     {
1152       errno = EINVAL;
1153       return -1;
1154     }
1155 
1156   wnewfilename = g_utf8_to_utf16 (newfilename, -1, NULL, NULL, NULL);
1157 
1158   if (wnewfilename == NULL)
1159     {
1160       g_free (woldfilename);
1161       errno = EINVAL;
1162       return -1;
1163     }
1164 
1165   if (MoveFileExW (woldfilename, wnewfilename, MOVEFILE_REPLACE_EXISTING))
1166     retval = 0;
1167   else
1168     {
1169       retval = -1;
<a name="63" id="anc63"></a><span class="line-modified">1170       save_errno = w32_error_to_errno (GetLastError ());</span>













1171     }
1172 
1173   g_free (woldfilename);
1174   g_free (wnewfilename);
1175 
1176   errno = save_errno;
1177   return retval;
1178 #else
1179   return rename (oldfilename, newfilename);
1180 #endif
1181 }
1182 
1183 /**
1184  * g_mkdir:
1185  * @filename: (type filename): a pathname in the GLib file name encoding
1186  *     (UTF-8 on Windows)
1187  * @mode: permissions to use for the newly created directory
1188  *
1189  * A wrapper for the POSIX mkdir() function. The mkdir() function
1190  * attempts to create a directory with the given name and permissions.
1191  * The mode argument is ignored on Windows.
1192  *
1193  * See your C library manual for more details about mkdir().
1194  *
1195  * Returns: 0 if the directory was successfully created, -1 if an error
1196  *    occurred
1197  *
1198  * Since: 2.6
1199  */
1200 int
1201 g_mkdir (const gchar *filename,
<a name="64" id="anc64"></a><span class="line-modified">1202    int          mode)</span>
1203 {
1204 #ifdef G_OS_WIN32
1205   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1206   int retval;
1207   int save_errno;
1208 
1209   if (wfilename == NULL)
1210     {
1211       errno = EINVAL;
1212       return -1;
1213     }
1214 
1215   retval = _wmkdir (wfilename);
1216   save_errno = errno;
1217 
1218   g_free (wfilename);
1219 
1220   errno = save_errno;
1221   return retval;
1222 #else
1223   return mkdir (filename, mode);
1224 #endif
1225 }
1226 
1227 /**
1228  * g_chdir:
1229  * @path: (type filename): a pathname in the GLib file name encoding
1230  *     (UTF-8 on Windows)
1231  *
1232  * A wrapper for the POSIX chdir() function. The function changes the
1233  * current directory of the process to @path.
1234  *
1235  * See your C library manual for more details about chdir().
1236  *
1237  * Returns: 0 on success, -1 if an error occurred.
1238  *
1239  * Since: 2.8
1240  */
1241 int
1242 g_chdir (const gchar *path)
1243 {
1244 #ifdef G_OS_WIN32
1245   wchar_t *wpath = g_utf8_to_utf16 (path, -1, NULL, NULL, NULL);
1246   int retval;
1247   int save_errno;
1248 
1249   if (wpath == NULL)
1250     {
1251       errno = EINVAL;
1252       return -1;
1253     }
1254 
1255   retval = _wchdir (wpath);
1256   save_errno = errno;
1257 
1258   g_free (wpath);
1259 
1260   errno = save_errno;
1261   return retval;
1262 #else
1263   return chdir (path);
1264 #endif
1265 }
1266 
1267 /**
1268  * GStatBuf:
1269  *
1270  * A type corresponding to the appropriate struct type for the stat()
1271  * system call, depending on the platform and/or compiler being used.
1272  *
1273  * See g_stat() for more information.
1274  */
1275 /**
1276  * g_stat:
1277  * @filename: (type filename): a pathname in the GLib file name encoding
1278  *     (UTF-8 on Windows)
1279  * @buf: a pointer to a stat struct, which will be filled with the file
1280  *     information
1281  *
1282  * A wrapper for the POSIX stat() function. The stat() function
1283  * returns information about a file. On Windows the stat() function in
1284  * the C library checks only the FAT-style READONLY attribute and does
1285  * not look at the ACL at all. Thus on Windows the protection bits in
1286  * the @st_mode field are a fabrication of little use.
1287  *
1288  * On Windows the Microsoft C libraries have several variants of the
1289  * stat struct and stat() function with names like _stat(), _stat32(),
1290  * _stat32i64() and _stat64i32(). The one used here is for 32-bit code
1291  * the one with 32-bit size and time fields, specifically called _stat32().
1292  *
1293  * In Microsoft&#39;s compiler, by default struct stat means one with
1294  * 64-bit time fields while in MinGW struct stat is the legacy one
1295  * with 32-bit fields. To hopefully clear up this messs, the gstdio.h
1296  * header defines a type #GStatBuf which is the appropriate struct type
1297  * depending on the platform and/or compiler being used. On POSIX it
1298  * is just struct stat, but note that even on POSIX platforms, stat()
1299  * might be a macro.
1300  *
1301  * See your C library manual for more details about stat().
1302  *
1303  * Returns: 0 if the information was successfully retrieved,
1304  *     -1 if an error occurred
1305  *
1306  * Since: 2.6
1307  */
1308 int
1309 g_stat (const gchar *filename,
<a name="65" id="anc65"></a><span class="line-modified">1310   GStatBuf    *buf)</span>
1311 {
1312 #ifdef G_OS_WIN32
1313   GWin32PrivateStat w32_buf;
1314   int retval = g_win32_stat_utf8 (filename, &amp;w32_buf);
1315 
1316   buf-&gt;st_dev = w32_buf.st_dev;
1317   buf-&gt;st_ino = w32_buf.st_ino;
1318   buf-&gt;st_mode = w32_buf.st_mode;
1319   buf-&gt;st_nlink = w32_buf.st_nlink;
1320   buf-&gt;st_uid = w32_buf.st_uid;
1321   buf-&gt;st_gid = w32_buf.st_gid;
1322   buf-&gt;st_rdev = w32_buf.st_dev;
1323   buf-&gt;st_size = w32_buf.st_size;
1324   buf-&gt;st_atime = w32_buf.st_atime;
1325   buf-&gt;st_mtime = w32_buf.st_mtime;
1326   buf-&gt;st_ctime = w32_buf.st_ctime;
1327 
1328   return retval;
1329 #else
1330   return stat (filename, buf);
1331 #endif
1332 }
1333 
1334 /**
1335  * g_lstat:
1336  * @filename: (type filename): a pathname in the GLib file name encoding
1337  *     (UTF-8 on Windows)
1338  * @buf: a pointer to a stat struct, which will be filled with the file
1339  *     information
1340  *
1341  * A wrapper for the POSIX lstat() function. The lstat() function is
1342  * like stat() except that in the case of symbolic links, it returns
1343  * information about the symbolic link itself and not the file that it
1344  * refers to. If the system does not support symbolic links g_lstat()
1345  * is identical to g_stat().
1346  *
1347  * See your C library manual for more details about lstat().
1348  *
1349  * Returns: 0 if the information was successfully retrieved,
1350  *     -1 if an error occurred
1351  *
1352  * Since: 2.6
1353  */
1354 int
1355 g_lstat (const gchar *filename,
<a name="66" id="anc66"></a><span class="line-modified">1356    GStatBuf    *buf)</span>
1357 {
1358 #ifdef HAVE_LSTAT
1359   /* This can&#39;t be Win32, so don&#39;t do the widechar dance. */
1360   return lstat (filename, buf);
1361 #elif defined (G_OS_WIN32)
1362   GWin32PrivateStat w32_buf;
1363   int retval = g_win32_lstat_utf8 (filename, &amp;w32_buf);
1364 
1365   buf-&gt;st_dev = w32_buf.st_dev;
1366   buf-&gt;st_ino = w32_buf.st_ino;
1367   buf-&gt;st_mode = w32_buf.st_mode;
1368   buf-&gt;st_nlink = w32_buf.st_nlink;
1369   buf-&gt;st_uid = w32_buf.st_uid;
1370   buf-&gt;st_gid = w32_buf.st_gid;
1371   buf-&gt;st_rdev = w32_buf.st_dev;
1372   buf-&gt;st_size = w32_buf.st_size;
1373   buf-&gt;st_atime = w32_buf.st_atime;
1374   buf-&gt;st_mtime = w32_buf.st_mtime;
1375   buf-&gt;st_ctime = w32_buf.st_ctime;
1376 
1377   return retval;
1378 #else
1379   return g_stat (filename, buf);
1380 #endif
1381 }
1382 
1383 /**
1384  * g_unlink:
1385  * @filename: (type filename): a pathname in the GLib file name encoding
1386  *     (UTF-8 on Windows)
1387  *
1388  * A wrapper for the POSIX unlink() function. The unlink() function
1389  * deletes a name from the filesystem. If this was the last link to the
1390  * file and no processes have it opened, the diskspace occupied by the
1391  * file is freed.
1392  *
1393  * See your C library manual for more details about unlink(). Note
1394  * that on Windows, it is in general not possible to delete files that
1395  * are open to some process, or mapped into memory.
1396  *
1397  * Returns: 0 if the name was successfully deleted, -1 if an error
1398  *    occurred
1399  *
1400  * Since: 2.6
1401  */
1402 int
1403 g_unlink (const gchar *filename)
1404 {
1405 #ifdef G_OS_WIN32
1406   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1407   int retval;
1408   int save_errno;
1409 
1410   if (wfilename == NULL)
1411     {
1412       errno = EINVAL;
1413       return -1;
1414     }
1415 
1416   retval = _wunlink (wfilename);
1417   save_errno = errno;
1418 
1419   g_free (wfilename);
1420 
1421   errno = save_errno;
1422   return retval;
1423 #else
1424   return unlink (filename);
1425 #endif
1426 }
1427 
1428 /**
1429  * g_remove:
1430  * @filename: (type filename): a pathname in the GLib file name encoding
1431  *     (UTF-8 on Windows)
1432  *
1433  * A wrapper for the POSIX remove() function. The remove() function
1434  * deletes a name from the filesystem.
1435  *
1436  * See your C library manual for more details about how remove() works
1437  * on your system. On Unix, remove() removes also directories, as it
1438  * calls unlink() for files and rmdir() for directories. On Windows,
1439  * although remove() in the C library only works for files, this
1440  * function tries first remove() and then if that fails rmdir(), and
1441  * thus works for both files and directories. Note however, that on
1442  * Windows, it is in general not possible to remove a file that is
1443  * open to some process, or mapped into memory.
1444  *
1445  * If this function fails on Windows you can&#39;t infer too much from the
1446  * errno value. rmdir() is tried regardless of what caused remove() to
1447  * fail. Any errno value set by remove() will be overwritten by that
1448  * set by rmdir().
1449  *
1450  * Returns: 0 if the file was successfully removed, -1 if an error
1451  *    occurred
1452  *
1453  * Since: 2.6
1454  */
1455 int
1456 g_remove (const gchar *filename)
1457 {
1458 #ifdef G_OS_WIN32
1459   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1460   int retval;
1461   int save_errno;
1462 
1463   if (wfilename == NULL)
1464     {
1465       errno = EINVAL;
1466       return -1;
1467     }
1468 
1469   retval = _wremove (wfilename);
1470   if (retval == -1)
1471     retval = _wrmdir (wfilename);
1472   save_errno = errno;
1473 
1474   g_free (wfilename);
1475 
1476   errno = save_errno;
1477   return retval;
1478 #else
1479   return remove (filename);
1480 #endif
1481 }
1482 
1483 /**
1484  * g_rmdir:
1485  * @filename: (type filename): a pathname in the GLib file name encoding
1486  *     (UTF-8 on Windows)
1487  *
1488  * A wrapper for the POSIX rmdir() function. The rmdir() function
1489  * deletes a directory from the filesystem.
1490  *
1491  * See your C library manual for more details about how rmdir() works
1492  * on your system.
1493  *
1494  * Returns: 0 if the directory was successfully removed, -1 if an error
1495  *    occurred
1496  *
1497  * Since: 2.6
1498  */
1499 int
1500 g_rmdir (const gchar *filename)
1501 {
1502 #ifdef G_OS_WIN32
1503   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1504   int retval;
1505   int save_errno;
1506 
1507   if (wfilename == NULL)
1508     {
1509       errno = EINVAL;
1510       return -1;
1511     }
1512 
1513   retval = _wrmdir (wfilename);
1514   save_errno = errno;
1515 
1516   g_free (wfilename);
1517 
1518   errno = save_errno;
1519   return retval;
1520 #else
1521   return rmdir (filename);
1522 #endif
1523 }
1524 
1525 /**
1526  * g_fopen:
1527  * @filename: (type filename): a pathname in the GLib file name encoding
1528  *     (UTF-8 on Windows)
1529  * @mode: a string describing the mode in which the file should be opened
1530  *
1531  * A wrapper for the stdio fopen() function. The fopen() function
1532  * opens a file and associates a new stream with it.
1533  *
1534  * Because file descriptors are specific to the C library on Windows,
1535  * and a file descriptor is part of the FILE struct, the FILE* returned
1536  * by this function makes sense only to functions in the same C library.
1537  * Thus if the GLib-using code uses a different C library than GLib does,
1538  * the FILE* returned by this function cannot be passed to C library
1539  * functions like fprintf() or fread().
1540  *
1541  * See your C library manual for more details about fopen().
1542  *
1543  * Returns: A FILE* if the file was successfully opened, or %NULL if
1544  *     an error occurred
1545  *
1546  * Since: 2.6
1547  */
1548 FILE *
1549 g_fopen (const gchar *filename,
<a name="67" id="anc67"></a><span class="line-modified">1550    const gchar *mode)</span>
1551 {
1552 #ifdef G_OS_WIN32
1553   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1554   wchar_t *wmode;
<a name="68" id="anc68"></a>
1555   FILE *retval;
1556   int save_errno;
1557 
1558   if (wfilename == NULL)
1559     {
1560       errno = EINVAL;
1561       return NULL;
1562     }
1563 
<a name="69" id="anc69"></a><span class="line-modified">1564   wmode = g_utf8_to_utf16 (mode, -1, NULL, NULL, NULL);</span>


1565 
1566   if (wmode == NULL)
1567     {
1568       g_free (wfilename);
1569       errno = EINVAL;
1570       return NULL;
1571     }
1572 
<a name="70" id="anc70"></a><span class="line-added">1573   _g_win32_fix_mode (wmode);</span>
1574   retval = _wfopen (wfilename, wmode);
1575   save_errno = errno;
1576 
1577   g_free (wfilename);
1578   g_free (wmode);
1579 
1580   errno = save_errno;
1581   return retval;
1582 #else
1583   return fopen (filename, mode);
1584 #endif
1585 }
1586 
1587 /**
1588  * g_freopen:
1589  * @filename: (type filename): a pathname in the GLib file name encoding
1590  *     (UTF-8 on Windows)
1591  * @mode: a string describing the mode in which the file should be  opened
1592  * @stream: (nullable): an existing stream which will be reused, or %NULL
1593  *
1594  * A wrapper for the POSIX freopen() function. The freopen() function
1595  * opens a file and associates it with an existing stream.
1596  *
1597  * See your C library manual for more details about freopen().
1598  *
1599  * Returns: A FILE* if the file was successfully opened, or %NULL if
1600  *     an error occurred.
1601  *
1602  * Since: 2.6
1603  */
1604 FILE *
1605 g_freopen (const gchar *filename,
<a name="71" id="anc71"></a><span class="line-modified">1606      const gchar *mode,</span>
<span class="line-modified">1607      FILE        *stream)</span>
1608 {
1609 #ifdef G_OS_WIN32
1610   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1611   wchar_t *wmode;
<a name="72" id="anc72"></a>
1612   FILE *retval;
1613   int save_errno;
1614 
1615   if (wfilename == NULL)
1616     {
1617       errno = EINVAL;
1618       return NULL;
1619     }
1620 
<a name="73" id="anc73"></a><span class="line-modified">1621   wmode = g_utf8_to_utf16 (mode, -1, NULL, NULL, NULL);</span>


1622 
1623   if (wmode == NULL)
1624     {
1625       g_free (wfilename);
1626       errno = EINVAL;
1627       return NULL;
1628     }
1629 
<a name="74" id="anc74"></a><span class="line-added">1630   _g_win32_fix_mode (wmode);</span>
1631   retval = _wfreopen (wfilename, wmode, stream);
1632   save_errno = errno;
1633 
1634   g_free (wfilename);
1635   g_free (wmode);
1636 
1637   errno = save_errno;
1638   return retval;
1639 #else
1640   return freopen (filename, mode, stream);
1641 #endif
1642 }
1643 
1644 /**
1645  * g_utime:
1646  * @filename: (type filename): a pathname in the GLib file name encoding
1647  *     (UTF-8 on Windows)
1648  * @utb: a pointer to a struct utimbuf.
1649  *
1650  * A wrapper for the POSIX utime() function. The utime() function
1651  * sets the access and modification timestamps of a file.
1652  *
1653  * See your C library manual for more details about how utime() works
1654  * on your system.
1655  *
1656  * Returns: 0 if the operation was successful, -1 if an error occurred
1657  *
1658  * Since: 2.18
1659  */
1660 int
1661 g_utime (const gchar    *filename,
<a name="75" id="anc75"></a><span class="line-modified">1662    struct utimbuf *utb)</span>
1663 {
1664 #ifdef G_OS_WIN32
1665   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1666   int retval;
1667   int save_errno;
1668 
1669   if (wfilename == NULL)
1670     {
1671       errno = EINVAL;
1672       return -1;
1673     }
1674 
1675   retval = _wutime (wfilename, (struct _utimbuf*) utb);
1676   save_errno = errno;
1677 
1678   g_free (wfilename);
1679 
1680   errno = save_errno;
1681   return retval;
1682 #else
1683   return utime (filename, utb);
1684 #endif
1685 }
1686 
1687 /**
1688  * g_close:
1689  * @fd: A file descriptor
1690  * @error: a #GError
1691  *
1692  * This wraps the close() call; in case of error, %errno will be
1693  * preserved, but the error will also be stored as a #GError in @error.
1694  *
1695  * Besides using #GError, there is another major reason to prefer this
1696  * function over the call provided by the system; on Unix, it will
1697  * attempt to correctly handle %EINTR, which has platform-specific
1698  * semantics.
1699  *
1700  * Returns: %TRUE on success, %FALSE if there was an error.
1701  *
1702  * Since: 2.36
1703  */
1704 gboolean
1705 g_close (gint       fd,
1706          GError   **error)
1707 {
1708   int res;
1709   res = close (fd);
1710   /* Just ignore EINTR for now; a retry loop is the wrong thing to do
1711    * on Linux at least.  Anyone who wants to add a conditional check
1712    * for e.g. HP-UX is welcome to do so later...
1713    *
1714    * http://lkml.indiana.edu/hypermail/linux/kernel/0509.1/0877.html
1715    * https://bugzilla.gnome.org/show_bug.cgi?id=682819
1716    * http://utcc.utoronto.ca/~cks/space/blog/unix/CloseEINTR
1717    * https://sites.google.com/site/michaelsafyan/software-engineering/checkforeintrwheninvokingclosethinkagain
1718    */
1719   if (G_UNLIKELY (res == -1 &amp;&amp; errno == EINTR))
1720     return TRUE;
1721   else if (res == -1)
1722     {
1723       int errsv = errno;
1724       g_set_error_literal (error, G_FILE_ERROR,
1725                            g_file_error_from_errno (errsv),
1726                            g_strerror (errsv));
1727       errno = errsv;
1728       return FALSE;
1729     }
1730   return TRUE;
1731 }
1732 
<a name="76" id="anc76"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="76" type="hidden" />
</body>
</html>