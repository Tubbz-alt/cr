<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstbuffer.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2000 Wim Taymans &lt;wtay@chello.be&gt;
   4  *
   5  * gstbuffer.c: Buffer operations
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 
  23 /**
  24  * SECTION:gstbuffer
  25  * @title: GstBuffer
  26  * @short_description: Data-passing buffer type
  27  * @see_also: #GstPad, #GstMiniObject, #GstMemory, #GstMeta, #GstBufferPool
  28  *
  29  * Buffers are the basic unit of data transfer in GStreamer. They contain the
  30  * timing and offset along with other arbitrary metadata that is associated
  31  * with the #GstMemory blocks that the buffer contains.
  32  *
  33  * Buffers are usually created with gst_buffer_new(). After a buffer has been
  34  * created one will typically allocate memory for it and add it to the buffer.
  35  * The following example creates a buffer that can hold a given video frame
  36  * with a given width, height and bits per plane.
  37  * |[&lt;!-- language=&quot;C&quot; --&gt;
  38  *   GstBuffer *buffer;
  39  *   GstMemory *memory;
  40  *   gint size, width, height, bpp;
  41  *   ...
  42  *   size = width * height * bpp;
  43  *   buffer = gst_buffer_new ();
  44  *   memory = gst_allocator_alloc (NULL, size, NULL);
  45  *   gst_buffer_insert_memory (buffer, -1, memory);
  46  *   ...
  47  * ]|
  48  *
  49  * Alternatively, use gst_buffer_new_allocate() to create a buffer with
  50  * preallocated data of a given size.
  51  *
  52  * Buffers can contain a list of #GstMemory objects. You can retrieve how many
  53  * memory objects with gst_buffer_n_memory() and you can get a pointer
  54  * to memory with gst_buffer_peek_memory()
  55  *
  56  * A buffer will usually have timestamps, and a duration, but neither of these
  57  * are guaranteed (they may be set to #GST_CLOCK_TIME_NONE). Whenever a
  58  * meaningful value can be given for these, they should be set. The timestamps
  59  * and duration are measured in nanoseconds (they are #GstClockTime values).
  60  *
  61  * The buffer DTS refers to the timestamp when the buffer should be decoded and
  62  * is usually monotonically increasing. The buffer PTS refers to the timestamp when
  63  * the buffer content should be presented to the user and is not always
  64  * monotonically increasing.
  65  *
  66  * A buffer can also have one or both of a start and an end offset. These are
  67  * media-type specific. For video buffers, the start offset will generally be
  68  * the frame number. For audio buffers, it will be the number of samples
  69  * produced so far. For compressed data, it could be the byte offset in a
  70  * source or destination file. Likewise, the end offset will be the offset of
  71  * the end of the buffer. These can only be meaningfully interpreted if you
  72  * know the media type of the buffer (the preceding CAPS event). Either or both
  73  * can be set to #GST_BUFFER_OFFSET_NONE.
  74  *
  75  * gst_buffer_ref() is used to increase the refcount of a buffer. This must be
  76  * done when you want to keep a handle to the buffer after pushing it to the
  77  * next element. The buffer refcount determines the writability of the buffer, a
  78  * buffer is only writable when the refcount is exactly 1, i.e. when the caller
  79  * has the only reference to the buffer.
  80  *
  81  * To efficiently create a smaller buffer out of an existing one, you can
  82  * use gst_buffer_copy_region(). This method tries to share the memory objects
  83  * between the two buffers.
  84  *
  85  * If a plug-in wants to modify the buffer data or metadata in-place, it should
  86  * first obtain a buffer that is safe to modify by using
  87  * gst_buffer_make_writable().  This function is optimized so that a copy will
  88  * only be made when it is necessary.
  89  *
  90  * Several flags of the buffer can be set and unset with the
  91  * GST_BUFFER_FLAG_SET() and GST_BUFFER_FLAG_UNSET() macros. Use
  92  * GST_BUFFER_FLAG_IS_SET() to test if a certain #GstBufferFlags flag is set.
  93  *
  94  * Buffers can be efficiently merged into a larger buffer with
  95  * gst_buffer_append(). Copying of memory will only be done when absolutely
  96  * needed.
  97  *
  98  * Arbitrary extra metadata can be set on a buffer with gst_buffer_add_meta().
  99  * Metadata can be retrieved with gst_buffer_get_meta(). See also #GstMeta
 100  *
 101  * An element should either unref the buffer or push it out on a src pad
 102  * using gst_pad_push() (see #GstPad).
 103  *
 104  * Buffers are usually freed by unreffing them with gst_buffer_unref(). When
 105  * the refcount drops to 0, any memory and metadata pointed to by the buffer is
 106  * unreffed as well. Buffers allocated from a #GstBufferPool will be returned to
 107  * the pool when the refcount drops to 0.
 108  *
 109  * The #GstParentBufferMeta is a meta which can be attached to a #GstBuffer
 110  * to hold a reference to another buffer that is only released when the child
 111  * #GstBuffer is released.
 112  *
 113  * Typically, #GstParentBufferMeta is used when the child buffer is directly
 114  * using the #GstMemory of the parent buffer, and wants to prevent the parent
 115  * buffer from being returned to a buffer pool until the #GstMemory is available
 116  * for re-use. (Since: 1.6)
 117  *
 118  */
 119 #include &quot;gst_private.h&quot;
 120 
 121 #ifdef HAVE_UNISTD_H
 122 #include &lt;unistd.h&gt;
 123 #endif
 124 #ifdef HAVE_STDLIB_H
 125 #include &lt;stdlib.h&gt;
 126 #endif
 127 
 128 #include &quot;gstbuffer.h&quot;
 129 #include &quot;gstbufferpool.h&quot;
 130 #include &quot;gstinfo.h&quot;
 131 #include &quot;gstutils.h&quot;
 132 #include &quot;gstversion.h&quot;
 133 
 134 GType _gst_buffer_type = 0;
 135 
 136 /* info-&gt;size will be sizeof(FooMeta) which contains a GstMeta at the beginning
 137  * too, and then there is again a GstMeta in GstMetaItem, so subtract one. */
 138 #define ITEM_SIZE(info) ((info)-&gt;size + sizeof (GstMetaItem) - sizeof (GstMeta))
 139 
 140 #define GST_BUFFER_MEM_MAX         16
 141 
 142 #define GST_BUFFER_SLICE_SIZE(b)   (((GstBufferImpl *)(b))-&gt;slice_size)
 143 #define GST_BUFFER_MEM_LEN(b)      (((GstBufferImpl *)(b))-&gt;len)
 144 #define GST_BUFFER_MEM_ARRAY(b)    (((GstBufferImpl *)(b))-&gt;mem)
 145 #define GST_BUFFER_MEM_PTR(b,i)    (((GstBufferImpl *)(b))-&gt;mem[i])
 146 #define GST_BUFFER_BUFMEM(b)       (((GstBufferImpl *)(b))-&gt;bufmem)
 147 #define GST_BUFFER_META(b)         (((GstBufferImpl *)(b))-&gt;item)
 148 #define GST_BUFFER_TAIL_META(b)    (((GstBufferImpl *)(b))-&gt;tail_item)
 149 
 150 typedef struct
 151 {
 152   GstBuffer buffer;
 153 
 154   gsize slice_size;
 155 
 156   /* the memory blocks */
 157   guint len;
 158   GstMemory *mem[GST_BUFFER_MEM_MAX];
 159 
 160   /* memory of the buffer when allocated from 1 chunk */
 161   GstMemory *bufmem;
 162 
 163   /* FIXME, make metadata allocation more efficient by using part of the
 164    * GstBufferImpl */
 165   GstMetaItem *item;
 166   GstMetaItem *tail_item;
 167 } GstBufferImpl;
 168 
 169 static gint64 meta_seq;         /* 0 *//* ATOMIC */
 170 
 171 /* TODO: use GLib&#39;s once https://gitlab.gnome.org/GNOME/glib/issues/1076 lands */
 172 #if defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8)
 173 static inline gint64
 174 gst_atomic_int64_inc (volatile gint64 * atomic)
 175 {
 176   return __sync_fetch_and_add (atomic, 1);
 177 }
 178 #elif defined (G_PLATFORM_WIN32)
 179 #include &lt;windows.h&gt;
 180 static inline gint64
 181 gst_atomic_int64_inc (volatile gint64 * atomic)
 182 {
 183   return InterlockedExchangeAdd64 (atomic, 1);
 184 }
 185 #else
 186 #warning No 64-bit atomic int defined for this platform/toolchain!
 187 #define NO_64BIT_ATOMIC_INT_FOR_PLATFORM
 188 G_LOCK_DEFINE_STATIC (meta_seq);
 189 static inline gint64
 190 gst_atomic_int64_inc (volatile gint64 * atomic)
 191 {
 192   gint64 ret;
 193 
 194   G_LOCK (meta_seq);
 195   ret = *atomic++;
 196   G_UNLOCK (meta_seq);
 197 
 198   return ret;
 199 }
 200 #endif
 201 
 202 static gboolean
 203 _is_span (GstMemory ** mem, gsize len, gsize * poffset, GstMemory ** parent)
 204 {
 205   GstMemory *mcur, *mprv;
 206   gboolean have_offset = FALSE;
 207   gsize i;
 208 
 209   mcur = mprv = NULL;
 210 
 211   for (i = 0; i &lt; len; i++) {
 212     if (mcur)
 213       mprv = mcur;
 214     mcur = mem[i];
 215 
 216     if (mprv &amp;&amp; mcur) {
 217       gsize poffs;
 218 
 219       /* check if memory is contiguous */
 220       if (!gst_memory_is_span (mprv, mcur, &amp;poffs))
 221         return FALSE;
 222 
 223       if (!have_offset) {
 224         if (poffset)
 225           *poffset = poffs;
 226         if (parent)
 227           *parent = mprv-&gt;parent;
 228 
 229         have_offset = TRUE;
 230       }
 231     }
 232   }
 233   return have_offset;
 234 }
 235 
 236 static GstMemory *
 237 _get_merged_memory (GstBuffer * buffer, guint idx, guint length)
 238 {
 239   GstMemory **mem, *result = NULL;
 240 
 241   GST_CAT_LOG (GST_CAT_BUFFER, &quot;buffer %p, idx %u, length %u&quot;, buffer, idx,
 242       length);
 243 
 244   mem = GST_BUFFER_MEM_ARRAY (buffer);
 245 
 246   if (G_UNLIKELY (length == 0)) {
 247     result = NULL;
 248   } else if (G_LIKELY (length == 1)) {
 249     result = gst_memory_ref (mem[idx]);
 250   } else {
 251     GstMemory *parent = NULL;
 252     gsize size, poffset = 0;
 253 
 254     size = gst_buffer_get_sizes_range (buffer, idx, length, NULL, NULL);
 255 
 256     if (G_UNLIKELY (_is_span (mem + idx, length, &amp;poffset, &amp;parent))) {
 257       if (!GST_MEMORY_IS_NO_SHARE (parent))
 258         result = gst_memory_share (parent, poffset, size);
 259       if (!result) {
 260         GST_CAT_DEBUG (GST_CAT_PERFORMANCE, &quot;copy for merge %p&quot;, parent);
 261         result = gst_memory_copy (parent, poffset, size);
 262       }
 263     } else {
 264       gsize i, tocopy, left;
 265       GstMapInfo sinfo, dinfo;
 266       guint8 *ptr;
 267 
 268       result = gst_allocator_alloc (NULL, size, NULL);
 269       if (result == NULL || !gst_memory_map (result, &amp;dinfo, GST_MAP_WRITE)) {
 270         GST_CAT_ERROR (GST_CAT_BUFFER, &quot;Failed to map memory writable&quot;);
 271         if (result)
 272           gst_memory_unref (result);
 273         return NULL;
 274       }
 275 
 276       ptr = dinfo.data;
 277       left = size;
 278 
 279       for (i = idx; i &lt; (idx + length) &amp;&amp; left &gt; 0; i++) {
 280         if (!gst_memory_map (mem[i], &amp;sinfo, GST_MAP_READ)) {
 281           GST_CAT_ERROR (GST_CAT_BUFFER,
 282               &quot;buffer %p, idx %u, length %u failed to map readable&quot;, buffer,
 283               idx, length);
 284           gst_memory_unmap (result, &amp;dinfo);
 285           gst_memory_unref (result);
 286           return NULL;
 287         }
 288         tocopy = MIN (sinfo.size, left);
 289         GST_CAT_DEBUG (GST_CAT_PERFORMANCE,
 290             &quot;memcpy %&quot; G_GSIZE_FORMAT &quot; bytes for merge %p from memory %p&quot;,
 291             tocopy, result, mem[i]);
 292         memcpy (ptr, (guint8 *) sinfo.data, tocopy);
 293         left -= tocopy;
 294         ptr += tocopy;
 295         gst_memory_unmap (mem[i], &amp;sinfo);
 296       }
 297       gst_memory_unmap (result, &amp;dinfo);
 298     }
 299   }
 300   return result;
 301 }
 302 
 303 static void
 304 _replace_memory (GstBuffer * buffer, guint len, guint idx, guint length,
 305     GstMemory * mem)
 306 {
 307   gsize end, i;
 308 
 309   end = idx + length;
 310 
 311   GST_CAT_LOG (GST_CAT_BUFFER,
 312       &quot;buffer %p replace %u-%&quot; G_GSIZE_FORMAT &quot; with memory %p&quot;, buffer, idx,
 313       end, mem);
 314 
 315   /* unref old memory */
 316   for (i = idx; i &lt; end; i++) {
 317     GstMemory *old = GST_BUFFER_MEM_PTR (buffer, i);
 318 
 319     gst_memory_unlock (old, GST_LOCK_FLAG_EXCLUSIVE);
 320     gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (old),
 321         GST_MINI_OBJECT_CAST (buffer));
 322     gst_memory_unref (old);
 323   }
 324 
 325   if (mem != NULL) {
 326     /* replace with single memory */
 327     gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (mem),
 328         GST_MINI_OBJECT_CAST (buffer));
 329     gst_memory_lock (mem, GST_LOCK_FLAG_EXCLUSIVE);
 330     GST_BUFFER_MEM_PTR (buffer, idx) = mem;
 331     idx++;
 332     length--;
 333   }
 334 
 335   if (end &lt; len) {
 336     memmove (&amp;GST_BUFFER_MEM_PTR (buffer, idx),
 337         &amp;GST_BUFFER_MEM_PTR (buffer, end), (len - end) * sizeof (gpointer));
 338   }
 339   GST_BUFFER_MEM_LEN (buffer) = len - length;
 340   GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
 341 }
 342 
 343 /**
 344  * gst_buffer_get_flags:
 345  * @buffer: a #GstBuffer
 346  *
 347  * Get the #GstBufferFlags flags set on this buffer.
 348  *
 349  * Returns: the flags set on this buffer.
 350  *
 351  * Since: 1.10
 352  */
 353 GstBufferFlags
 354 gst_buffer_get_flags (GstBuffer * buffer)
 355 {
 356   return (GstBufferFlags) GST_BUFFER_FLAGS (buffer);
 357 }
 358 
 359 /**
 360  * gst_buffer_flag_is_set:
 361  * @buffer: a #GstBuffer
 362  * @flags: the #GstBufferFlags flag to check.
 363  *
 364  * Gives the status of a specific flag on a buffer.
 365  *
 366  * Returns: %TRUE if all flags in @flags are found on @buffer.
 367  *
 368  * Since: 1.10
 369  */
 370 gboolean
 371 gst_buffer_has_flags (GstBuffer * buffer, GstBufferFlags flags)
 372 {
 373   return GST_BUFFER_FLAG_IS_SET (buffer, flags);
 374 }
 375 
 376 /**
 377  * gst_buffer_set_flags:
 378  * @buffer: a #GstBuffer
 379  * @flags: the #GstBufferFlags to set.
 380  *
 381  * Sets one or more buffer flags on a buffer.
 382  *
 383  * Returns: %TRUE if @flags were successfully set on buffer.
 384  *
 385  * Since: 1.10
 386  */
 387 gboolean
 388 gst_buffer_set_flags (GstBuffer * buffer, GstBufferFlags flags)
 389 {
 390   GST_BUFFER_FLAG_SET (buffer, flags);
 391   return TRUE;
 392 }
 393 
 394 /**
 395  * gst_buffer_unset_flags:
 396  * @buffer: a #GstBuffer
 397  * @flags: the #GstBufferFlags to clear
 398  *
 399  * Clears one or more buffer flags.
 400  *
 401  * Returns: true if @flags is successfully cleared from buffer.
 402  *
 403  * Since: 1.10
 404  */
 405 gboolean
 406 gst_buffer_unset_flags (GstBuffer * buffer, GstBufferFlags flags)
 407 {
 408   GST_BUFFER_FLAG_UNSET (buffer, flags);
 409   return TRUE;
 410 }
 411 
 412 
 413 
 414 /* transfer full for return and transfer none for @mem */
 415 static inline GstMemory *
 416 _memory_get_exclusive_reference (GstMemory * mem)
 417 {
 418   GstMemory *ret = NULL;
 419 
 420   if (gst_memory_lock (mem, GST_LOCK_FLAG_EXCLUSIVE)) {
 421     ret = gst_memory_ref (mem);
 422   } else {
 423     /* we cannot take another exclusive lock as the memory is already
 424      * locked WRITE + EXCLUSIVE according to part-miniobject.txt */
 425     ret = gst_memory_copy (mem, 0, -1);
 426 
 427     if (ret) {
 428       if (!gst_memory_lock (ret, GST_LOCK_FLAG_EXCLUSIVE)) {
 429         gst_memory_unref (ret);
 430         ret = NULL;
 431       }
 432     }
 433   }
 434 
 435   if (!ret)
 436     GST_CAT_WARNING (GST_CAT_BUFFER, &quot;Failed to acquire an exclusive lock for &quot;
 437         &quot;memory %p&quot;, mem);
 438 
 439   return ret;
 440 }
 441 
 442 static inline void
 443 _memory_add (GstBuffer * buffer, gint idx, GstMemory * mem)
 444 {
 445   guint i, len = GST_BUFFER_MEM_LEN (buffer);
 446 
 447   GST_CAT_LOG (GST_CAT_BUFFER, &quot;buffer %p, idx %d, mem %p&quot;, buffer, idx, mem);
 448 
 449   if (G_UNLIKELY (len &gt;= GST_BUFFER_MEM_MAX)) {
 450     /* too many buffer, span them. */
 451     /* FIXME, there is room for improvement here: We could only try to merge
 452      * 2 buffers to make some room. If we can&#39;t efficiently merge 2 buffers we
 453      * could try to only merge the two smallest buffers to avoid memcpy, etc. */
 454     GST_CAT_DEBUG (GST_CAT_PERFORMANCE, &quot;memory array overflow in buffer %p&quot;,
 455         buffer);
 456     _replace_memory (buffer, len, 0, len, _get_merged_memory (buffer, 0, len));
 457     /* we now have 1 single spanned buffer */
 458     len = 1;
 459   }
 460 
 461   if (idx == -1)
 462     idx = len;
 463 
 464   for (i = len; i &gt; idx; i--) {
 465     /* move buffers to insert, FIXME, we need to insert first and then merge */
 466     GST_BUFFER_MEM_PTR (buffer, i) = GST_BUFFER_MEM_PTR (buffer, i - 1);
 467   }
 468   /* and insert the new buffer */
 469   GST_BUFFER_MEM_PTR (buffer, idx) = mem;
 470   GST_BUFFER_MEM_LEN (buffer) = len + 1;
 471   gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (mem),
 472       GST_MINI_OBJECT_CAST (buffer));
 473 
 474   GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
 475 }
 476 
 477 GST_DEFINE_MINI_OBJECT_TYPE (GstBuffer, gst_buffer);
 478 
 479 void
 480 _priv_gst_buffer_initialize (void)
 481 {
 482   _gst_buffer_type = gst_buffer_get_type ();
 483 
 484 #ifdef NO_64BIT_ATOMIC_INT_FOR_PLATFORM
 485   GST_CAT_WARNING (GST_CAT_PERFORMANCE,
 486       &quot;No 64-bit atomic int defined for this platform/toolchain!&quot;);
 487 #endif
 488 }
 489 
 490 /**
 491  * gst_buffer_get_max_memory:
 492  *
 493  * Get the maximum amount of memory blocks that a buffer can hold. This is a
 494  * compile time constant that can be queried with the function.
 495  *
 496  * When more memory blocks are added, existing memory blocks will be merged
 497  * together to make room for the new block.
 498  *
 499  * Returns: the maximum amount of memory blocks that a buffer can hold.
 500  *
 501  * Since: 1.2
 502  */
 503 guint
 504 gst_buffer_get_max_memory (void)
 505 {
 506   return GST_BUFFER_MEM_MAX;
 507 }
 508 
 509 /**
 510  * gst_buffer_copy_into:
 511  * @dest: a destination #GstBuffer
 512  * @src: a source #GstBuffer
 513  * @flags: flags indicating what metadata fields should be copied.
 514  * @offset: offset to copy from
 515  * @size: total size to copy. If -1, all data is copied.
 516  *
 517  * Copies the information from @src into @dest.
 518  *
 519  * If @dest already contains memory and @flags contains GST_BUFFER_COPY_MEMORY,
 520  * the memory from @src will be appended to @dest.
 521  *
 522  * @flags indicate which fields will be copied.
 523  *
 524  * Returns: %TRUE if the copying succeeded, %FALSE otherwise.
 525  */
 526 gboolean
 527 gst_buffer_copy_into (GstBuffer * dest, GstBuffer * src,
 528     GstBufferCopyFlags flags, gsize offset, gsize size)
 529 {
 530   GstMetaItem *walk;
 531   gsize bufsize;
 532   gboolean region = FALSE;
 533 
 534   g_return_val_if_fail (dest != NULL, FALSE);
 535   g_return_val_if_fail (src != NULL, FALSE);
 536 
 537   /* nothing to copy if the buffers are the same */
 538   if (G_UNLIKELY (dest == src))
 539     return TRUE;
 540 
 541   g_return_val_if_fail (gst_buffer_is_writable (dest), FALSE);
 542 
 543   bufsize = gst_buffer_get_size (src);
 544   g_return_val_if_fail (bufsize &gt;= offset, FALSE);
 545   if (offset &gt; 0)
 546     region = TRUE;
 547   if (size == -1)
 548     size = bufsize - offset;
 549   if (size &lt; bufsize)
 550     region = TRUE;
 551   g_return_val_if_fail (bufsize &gt;= offset + size, FALSE);
 552 
 553   GST_CAT_LOG (GST_CAT_BUFFER, &quot;copy %p to %p, offset %&quot; G_GSIZE_FORMAT
 554       &quot;-%&quot; G_GSIZE_FORMAT &quot;/%&quot; G_GSIZE_FORMAT, src, dest, offset, size,
 555       bufsize);
 556 
 557   if (flags &amp; GST_BUFFER_COPY_FLAGS) {
 558     /* copy flags */
 559     guint flags_mask = ~GST_BUFFER_FLAG_TAG_MEMORY;
 560 
 561     GST_MINI_OBJECT_FLAGS (dest) =
 562         (GST_MINI_OBJECT_FLAGS (src) &amp; flags_mask) |
 563         (GST_MINI_OBJECT_FLAGS (dest) &amp; ~flags_mask);
 564   }
 565 
 566   if (flags &amp; GST_BUFFER_COPY_TIMESTAMPS) {
 567     if (offset == 0) {
 568       GST_BUFFER_PTS (dest) = GST_BUFFER_PTS (src);
 569       GST_BUFFER_DTS (dest) = GST_BUFFER_DTS (src);
 570       GST_BUFFER_OFFSET (dest) = GST_BUFFER_OFFSET (src);
 571       if (size == bufsize) {
 572         GST_BUFFER_DURATION (dest) = GST_BUFFER_DURATION (src);
 573         GST_BUFFER_OFFSET_END (dest) = GST_BUFFER_OFFSET_END (src);
 574       }
 575     } else {
 576       GST_BUFFER_PTS (dest) = GST_CLOCK_TIME_NONE;
 577       GST_BUFFER_DTS (dest) = GST_CLOCK_TIME_NONE;
 578       GST_BUFFER_DURATION (dest) = GST_CLOCK_TIME_NONE;
 579       GST_BUFFER_OFFSET (dest) = GST_BUFFER_OFFSET_NONE;
 580       GST_BUFFER_OFFSET_END (dest) = GST_BUFFER_OFFSET_NONE;
 581     }
 582   }
 583 
 584   if (flags &amp; GST_BUFFER_COPY_MEMORY) {
 585     gsize skip, left, len, dest_len, i, bsize;
 586     gboolean deep;
 587 
 588     deep = flags &amp; GST_BUFFER_COPY_DEEP;
 589 
 590     len = GST_BUFFER_MEM_LEN (src);
 591     dest_len = GST_BUFFER_MEM_LEN (dest);
 592     left = size;
 593     skip = offset;
 594 
 595     /* copy and make regions of the memory */
 596     for (i = 0; i &lt; len &amp;&amp; left &gt; 0; i++) {
 597       GstMemory *mem = GST_BUFFER_MEM_PTR (src, i);
 598 
 599       bsize = gst_memory_get_sizes (mem, NULL, NULL);
 600 
 601       if (bsize &lt;= skip) {
 602         /* don&#39;t copy buffer */
 603         skip -= bsize;
 604       } else {
 605         GstMemory *newmem = NULL;
 606         gsize tocopy;
 607 
 608         tocopy = MIN (bsize - skip, left);
 609 
 610         if (tocopy &lt; bsize &amp;&amp; !deep &amp;&amp; !GST_MEMORY_IS_NO_SHARE (mem)) {
 611           /* we need to clip something */
 612           newmem = gst_memory_share (mem, skip, tocopy);
 613           if (newmem) {
 614             gst_memory_lock (newmem, GST_LOCK_FLAG_EXCLUSIVE);
 615             skip = 0;
 616           }
 617         }
 618 
 619         if (deep || GST_MEMORY_IS_NO_SHARE (mem) || (!newmem &amp;&amp; tocopy &lt; bsize)) {
 620           /* deep copy or we&#39;re not allowed to share this memory
 621            * between buffers, always copy then */
 622           newmem = gst_memory_copy (mem, skip, tocopy);
 623           if (newmem) {
 624             gst_memory_lock (newmem, GST_LOCK_FLAG_EXCLUSIVE);
 625             skip = 0;
 626           }
 627         } else if (!newmem) {
 628           newmem = _memory_get_exclusive_reference (mem);
 629         }
 630 
 631         if (!newmem) {
 632           gst_buffer_remove_memory_range (dest, dest_len, -1);
 633           return FALSE;
 634         }
 635 
 636         _memory_add (dest, -1, newmem);
 637         left -= tocopy;
 638       }
 639     }
 640     if (flags &amp; GST_BUFFER_COPY_MERGE) {
 641       GstMemory *mem;
 642 
 643       len = GST_BUFFER_MEM_LEN (dest);
 644       mem = _get_merged_memory (dest, 0, len);
 645       if (!mem) {
 646         gst_buffer_remove_memory_range (dest, dest_len, -1);
 647         return FALSE;
 648       }
 649       _replace_memory (dest, len, 0, len, mem);
 650     }
 651   }
 652 
 653   if (flags &amp; GST_BUFFER_COPY_META) {
 654     /* NOTE: GstGLSyncMeta copying relies on the meta
 655      *       being copied now, after the buffer data,
 656      *       so this has to happen last */
 657     for (walk = GST_BUFFER_META (src); walk; walk = walk-&gt;next) {
 658       GstMeta *meta = &amp;walk-&gt;meta;
 659       const GstMetaInfo *info = meta-&gt;info;
 660 
 661       /* Don&#39;t copy memory metas if we only copied part of the buffer, didn&#39;t
 662        * copy memories or merged memories. In all these cases the memory
 663        * structure has changed and the memory meta becomes meaningless.
 664        */
 665       if ((region || !(flags &amp; GST_BUFFER_COPY_MEMORY)
 666               || (flags &amp; GST_BUFFER_COPY_MERGE))
 667           &amp;&amp; gst_meta_api_type_has_tag (info-&gt;api, _gst_meta_tag_memory)) {
 668         GST_CAT_DEBUG (GST_CAT_BUFFER,
 669             &quot;don&#39;t copy memory meta %p of API type %s&quot;, meta,
 670             g_type_name (info-&gt;api));
 671       } else if (info-&gt;transform_func) {
 672         GstMetaTransformCopy copy_data;
 673 
 674         copy_data.region = region;
 675         copy_data.offset = offset;
 676         copy_data.size = size;
 677 
 678         if (!info-&gt;transform_func (dest, meta, src,
 679                 _gst_meta_transform_copy, &amp;copy_data)) {
 680           GST_CAT_ERROR (GST_CAT_BUFFER,
 681               &quot;failed to copy meta %p of API type %s&quot;, meta,
 682               g_type_name (info-&gt;api));
 683         }
 684       }
 685     }
 686   }
 687 
 688   return TRUE;
 689 }
 690 
 691 static GstBuffer *
 692 gst_buffer_copy_with_flags (const GstBuffer * buffer, GstBufferCopyFlags flags)
 693 {
 694   GstBuffer *copy;
 695 
 696   g_return_val_if_fail (buffer != NULL, NULL);
 697 
 698   /* create a fresh new buffer */
 699   copy = gst_buffer_new ();
 700 
 701   /* copy what the &#39;flags&#39; want from our parent */
 702   /* FIXME why we can&#39;t pass const to gst_buffer_copy_into() ? */
 703   if (!gst_buffer_copy_into (copy, (GstBuffer *) buffer, flags, 0, -1))
 704     gst_buffer_replace (&amp;copy, NULL);
 705 
 706   if (copy)
 707     GST_BUFFER_FLAG_UNSET (copy, GST_BUFFER_FLAG_TAG_MEMORY);
 708 
 709   return copy;
 710 }
 711 
 712 static GstBuffer *
 713 _gst_buffer_copy (const GstBuffer * buffer)
 714 {
 715   return gst_buffer_copy_with_flags (buffer, GST_BUFFER_COPY_ALL);
 716 }
 717 
 718 /**
 719  * gst_buffer_copy_deep:
 720  * @buf: a #GstBuffer.
 721  *
 722  * Create a copy of the given buffer. This will make a newly allocated
 723  * copy of the data the source buffer contains.
 724  *
 725  * Returns: (transfer full): a new copy of @buf.
 726  *
 727  * Since: 1.6
 728  */
 729 GstBuffer *
 730 gst_buffer_copy_deep (const GstBuffer * buffer)
 731 {
 732   return gst_buffer_copy_with_flags (buffer,
 733       GST_BUFFER_COPY_ALL | GST_BUFFER_COPY_DEEP);
 734 }
 735 
 736 /* the default dispose function revives the buffer and returns it to the
 737  * pool when there is a pool */
 738 static gboolean
 739 _gst_buffer_dispose (GstBuffer * buffer)
 740 {
 741   GstBufferPool *pool;
 742 
 743   /* no pool, do free */
 744   if ((pool = buffer-&gt;pool) == NULL)
 745     return TRUE;
 746 
 747   /* keep the buffer alive */
 748   gst_buffer_ref (buffer);
 749   /* return the buffer to the pool */
 750   GST_CAT_LOG (GST_CAT_BUFFER, &quot;release %p to pool %p&quot;, buffer, pool);
 751   gst_buffer_pool_release_buffer (pool, buffer);
 752 
 753   return FALSE;
 754 }
 755 
 756 static void
 757 _gst_buffer_free (GstBuffer * buffer)
 758 {
 759   GstMetaItem *walk, *next;
 760   guint i, len;
 761   gsize msize;
 762 
 763   g_return_if_fail (buffer != NULL);
 764 
 765   GST_CAT_LOG (GST_CAT_BUFFER, &quot;finalize %p&quot;, buffer);
 766 
 767   /* free metadata */
 768   for (walk = GST_BUFFER_META (buffer); walk; walk = next) {
 769     GstMeta *meta = &amp;walk-&gt;meta;
 770     const GstMetaInfo *info = meta-&gt;info;
 771 
 772     /* call free_func if any */
 773     if (info-&gt;free_func)
 774       info-&gt;free_func (meta, buffer);
 775 
 776     next = walk-&gt;next;
 777     /* and free the slice */
 778     g_slice_free1 (ITEM_SIZE (info), walk);
 779   }
 780 
 781   /* get the size, when unreffing the memory, we could also unref the buffer
 782    * itself */
 783   msize = GST_BUFFER_SLICE_SIZE (buffer);
 784 
 785   /* free our memory */
 786   len = GST_BUFFER_MEM_LEN (buffer);
 787   for (i = 0; i &lt; len; i++) {
 788     gst_memory_unlock (GST_BUFFER_MEM_PTR (buffer, i), GST_LOCK_FLAG_EXCLUSIVE);
 789     gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (GST_BUFFER_MEM_PTR
 790             (buffer, i)), GST_MINI_OBJECT_CAST (buffer));
 791     gst_memory_unref (GST_BUFFER_MEM_PTR (buffer, i));
 792   }
 793 
 794   /* we set msize to 0 when the buffer is part of the memory block */
 795   if (msize) {
 796 #ifdef USE_POISONING
 797     memset (buffer, 0xff, msize);
 798 #endif
 799     g_slice_free1 (msize, buffer);
 800   } else {
 801     gst_memory_unref (GST_BUFFER_BUFMEM (buffer));
 802   }
 803 }
 804 
 805 static void
 806 gst_buffer_init (GstBufferImpl * buffer, gsize size)
 807 {
 808   gst_mini_object_init (GST_MINI_OBJECT_CAST (buffer), 0, _gst_buffer_type,
 809       (GstMiniObjectCopyFunction) _gst_buffer_copy,
 810       (GstMiniObjectDisposeFunction) _gst_buffer_dispose,
 811       (GstMiniObjectFreeFunction) _gst_buffer_free);
 812 
 813   GST_BUFFER_SLICE_SIZE (buffer) = size;
 814 
 815   GST_BUFFER (buffer)-&gt;pool = NULL;
 816   GST_BUFFER_PTS (buffer) = GST_CLOCK_TIME_NONE;
 817   GST_BUFFER_DTS (buffer) = GST_CLOCK_TIME_NONE;
 818   GST_BUFFER_DURATION (buffer) = GST_CLOCK_TIME_NONE;
 819   GST_BUFFER_OFFSET (buffer) = GST_BUFFER_OFFSET_NONE;
 820   GST_BUFFER_OFFSET_END (buffer) = GST_BUFFER_OFFSET_NONE;
 821 
 822   GST_BUFFER_MEM_LEN (buffer) = 0;
 823   GST_BUFFER_META (buffer) = NULL;
 824 }
 825 
 826 /**
 827  * gst_buffer_new:
 828  *
 829  * Creates a newly allocated buffer without any data.
 830  *
 831  * MT safe.
 832  *
 833  * Returns: (transfer full): the new #GstBuffer.
 834  */
 835 GstBuffer *
 836 gst_buffer_new (void)
 837 {
 838   GstBufferImpl *newbuf;
 839 
 840   newbuf = g_slice_new (GstBufferImpl);
 841   GST_CAT_LOG (GST_CAT_BUFFER, &quot;new %p&quot;, newbuf);
 842 
 843   gst_buffer_init (newbuf, sizeof (GstBufferImpl));
 844 
 845   return GST_BUFFER_CAST (newbuf);
 846 }
 847 
 848 /**
 849  * gst_buffer_new_allocate:
 850  * @allocator: (transfer none) (allow-none): the #GstAllocator to use, or %NULL to use the
 851  *     default allocator
 852  * @size: the size in bytes of the new buffer&#39;s data.
 853  * @params: (transfer none) (allow-none): optional parameters
 854  *
 855  * Tries to create a newly allocated buffer with data of the given size and
 856  * extra parameters from @allocator. If the requested amount of memory can&#39;t be
 857  * allocated, %NULL will be returned. The allocated buffer memory is not cleared.
 858  *
 859  * When @allocator is %NULL, the default memory allocator will be used.
 860  *
 861  * Note that when @size == 0, the buffer will not have memory associated with it.
 862  *
 863  * MT safe.
 864  *
 865  * Returns: (transfer full) (nullable): a new #GstBuffer, or %NULL if
 866  *     the memory couldn&#39;t be allocated.
 867  */
 868 GstBuffer *
 869 gst_buffer_new_allocate (GstAllocator * allocator, gsize size,
 870     GstAllocationParams * params)
 871 {
 872   GstBuffer *newbuf;
 873   GstMemory *mem;
 874 #if 0
 875   guint8 *data;
 876   gsize asize;
 877 #endif
 878 
 879 #if 1
 880   if (size &gt; 0) {
 881     mem = gst_allocator_alloc (allocator, size, params);
 882     if (G_UNLIKELY (mem == NULL))
 883       goto no_memory;
 884   } else {
 885     mem = NULL;
 886   }
 887 
 888   newbuf = gst_buffer_new ();
 889 
 890   if (mem != NULL) {
 891     gst_memory_lock (mem, GST_LOCK_FLAG_EXCLUSIVE);
 892     _memory_add (newbuf, -1, mem);
 893   }
 894 
 895   GST_CAT_LOG (GST_CAT_BUFFER,
 896       &quot;new buffer %p of size %&quot; G_GSIZE_FORMAT &quot; from allocator %p&quot;, newbuf,
 897       size, allocator);
 898 #endif
 899 
 900 #if 0
 901   asize = sizeof (GstBufferImpl) + size;
 902   data = g_slice_alloc (asize);
 903   if (G_UNLIKELY (data == NULL))
 904     goto no_memory;
 905 
 906   newbuf = GST_BUFFER_CAST (data);
 907 
 908   gst_buffer_init ((GstBufferImpl *) data, asize);
 909   if (size &gt; 0) {
 910     mem = gst_memory_new_wrapped (0, data + sizeof (GstBufferImpl), NULL,
 911         size, 0, size);
 912     _memory_add (newbuf, -1, mem, TRUE);
 913   }
 914 #endif
 915 
 916 #if 0
 917   /* allocate memory and buffer, it might be interesting to do this but there
 918    * are many complications. We need to keep the memory mapped to access the
 919    * buffer fields and the memory for the buffer might be just very slow. We
 920    * also need to do some more magic to get the alignment right. */
 921   asize = sizeof (GstBufferImpl) + size;
 922   mem = gst_allocator_alloc (allocator, asize, align);
 923   if (G_UNLIKELY (mem == NULL))
 924     goto no_memory;
 925 
 926   /* map the data part and init the buffer in it, set the buffer size to 0 so
 927    * that a finalize won&#39;t free the buffer */
 928   data = gst_memory_map (mem, &amp;asize, NULL, GST_MAP_WRITE);
 929   gst_buffer_init ((GstBufferImpl *) data, 0);
 930   gst_memory_unmap (mem);
 931 
 932   /* strip off the buffer */
 933   gst_memory_resize (mem, sizeof (GstBufferImpl), size);
 934 
 935   newbuf = GST_BUFFER_CAST (data);
 936   GST_BUFFER_BUFMEM (newbuf) = mem;
 937 
 938   if (size &gt; 0)
 939     _memory_add (newbuf, -1, gst_memory_ref (mem), TRUE);
 940 #endif
 941   GST_BUFFER_FLAG_UNSET (newbuf, GST_BUFFER_FLAG_TAG_MEMORY);
 942 
 943   return newbuf;
 944 
 945   /* ERRORS */
 946 no_memory:
 947   {
 948     GST_CAT_WARNING (GST_CAT_BUFFER,
 949         &quot;failed to allocate %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, size);
 950     return NULL;
 951   }
 952 }
 953 
 954 /**
 955  * gst_buffer_new_wrapped_full:
 956  * @flags: #GstMemoryFlags
 957  * @data: (array length=size) (element-type guint8) (transfer none): data to wrap
 958  * @maxsize: allocated size of @data
 959  * @offset: offset in @data
 960  * @size: size of valid data
 961  * @user_data: (allow-none): user_data
 962  * @notify: (allow-none) (scope async) (closure user_data): called with @user_data when the memory is freed
 963  *
 964  * Allocate a new buffer that wraps the given memory. @data must point to
 965  * @maxsize of memory, the wrapped buffer will have the region from @offset and
 966  * @size visible.
 967  *
 968  * When the buffer is destroyed, @notify will be called with @user_data.
 969  *
 970  * The prefix/padding must be filled with 0 if @flags contains
 971  * #GST_MEMORY_FLAG_ZERO_PREFIXED and #GST_MEMORY_FLAG_ZERO_PADDED respectively.
 972  *
 973  * Returns: (transfer full): a new #GstBuffer
 974  */
 975 GstBuffer *
 976 gst_buffer_new_wrapped_full (GstMemoryFlags flags, gpointer data,
 977     gsize maxsize, gsize offset, gsize size, gpointer user_data,
 978     GDestroyNotify notify)
 979 {
 980   GstMemory *mem;
 981   GstBuffer *newbuf;
 982 
 983   newbuf = gst_buffer_new ();
 984   mem =
 985       gst_memory_new_wrapped (flags, data, maxsize, offset, size, user_data,
 986       notify);
 987   gst_memory_lock (mem, GST_LOCK_FLAG_EXCLUSIVE);
 988   _memory_add (newbuf, -1, mem);
 989   GST_BUFFER_FLAG_UNSET (newbuf, GST_BUFFER_FLAG_TAG_MEMORY);
 990 
 991   return newbuf;
 992 }
 993 
 994 /**
 995  * gst_buffer_new_wrapped:
 996  * @data: (array length=size) (element-type guint8) (transfer full): data to wrap
 997  * @size: allocated size of @data
 998  *
 999  * Creates a new buffer that wraps the given @data. The memory will be freed
1000  * with g_free and will be marked writable.
1001  *
1002  * MT safe.
1003  *
1004  * Returns: (transfer full): a new #GstBuffer
1005  */
1006 GstBuffer *
1007 gst_buffer_new_wrapped (gpointer data, gsize size)
1008 {
1009   return gst_buffer_new_wrapped_full (0, data, size, 0, size, data, g_free);
1010 }
1011 
1012 /**
1013  * gst_buffer_new_wrapped_bytes:
1014  * @bytes: (transfer none): a #GBytes to wrap
1015  *
1016  * Creates a new #GstBuffer that wraps the given @bytes. The data inside
1017  * @bytes cannot be %NULL and the resulting buffer will be marked as read only.
1018  *
1019  * MT safe.
1020  *
1021  * Returns: (transfer full): a new #GstBuffer wrapping @bytes
1022  *
1023  * Since: 1.16
1024  */
1025 GstBuffer *
1026 gst_buffer_new_wrapped_bytes (GBytes * bytes)
1027 {
1028   guint8 *bytes_data;
1029   gsize size;
1030 
1031   g_return_val_if_fail (bytes != NULL, NULL);
1032   bytes_data = (guint8 *) g_bytes_get_data (bytes, &amp;size);
1033   g_return_val_if_fail (bytes_data != NULL, NULL);
1034 
1035   return gst_buffer_new_wrapped_full (GST_MEMORY_FLAG_READONLY, bytes_data,
1036       size, 0, size, g_bytes_ref (bytes), (GDestroyNotify) g_bytes_unref);
1037 }
1038 
1039 /**
1040  * gst_buffer_n_memory:
1041  * @buffer: a #GstBuffer.
1042  *
1043  * Get the amount of memory blocks that this buffer has. This amount is never
1044  * larger than what gst_buffer_get_max_memory() returns.
1045  *
1046  * Returns: the number of memory blocks this buffer is made of.
1047  */
1048 guint
1049 gst_buffer_n_memory (GstBuffer * buffer)
1050 {
1051   g_return_val_if_fail (GST_IS_BUFFER (buffer), 0);
1052 
1053   return GST_BUFFER_MEM_LEN (buffer);
1054 }
1055 
1056 /**
1057  * gst_buffer_prepend_memory:
1058  * @buffer: a #GstBuffer.
1059  * @mem: (transfer full): a #GstMemory.
1060  *
1061  * Prepend the memory block @mem to @buffer. This function takes
1062  * ownership of @mem and thus doesn&#39;t increase its refcount.
1063  *
1064  * This function is identical to gst_buffer_insert_memory() with an index of 0.
1065  * See gst_buffer_insert_memory() for more details.
1066  */
1067 void
1068 gst_buffer_prepend_memory (GstBuffer * buffer, GstMemory * mem)
1069 {
1070   gst_buffer_insert_memory (buffer, 0, mem);
1071 }
1072 
1073 /**
1074  * gst_buffer_append_memory:
1075  * @buffer: a #GstBuffer.
1076  * @mem: (transfer full): a #GstMemory.
1077  *
1078  * Append the memory block @mem to @buffer. This function takes
1079  * ownership of @mem and thus doesn&#39;t increase its refcount.
1080  *
1081  * This function is identical to gst_buffer_insert_memory() with an index of -1.
1082  * See gst_buffer_insert_memory() for more details.
1083  */
1084 void
1085 gst_buffer_append_memory (GstBuffer * buffer, GstMemory * mem)
1086 {
1087   gst_buffer_insert_memory (buffer, -1, mem);
1088 }
1089 
1090 /**
1091  * gst_buffer_insert_memory:
1092  * @buffer: a #GstBuffer.
1093  * @idx: the index to add the memory at, or -1 to append it to the end
1094  * @mem: (transfer full): a #GstMemory.
1095  *
1096  * Insert the memory block @mem to @buffer at @idx. This function takes ownership
1097  * of @mem and thus doesn&#39;t increase its refcount.
1098  *
1099  * Only gst_buffer_get_max_memory() can be added to a buffer. If more memory is
1100  * added, existing memory blocks will automatically be merged to make room for
1101  * the new memory.
1102  */
1103 void
1104 gst_buffer_insert_memory (GstBuffer * buffer, gint idx, GstMemory * mem)
1105 {
1106   GstMemory *tmp;
1107 
1108   g_return_if_fail (GST_IS_BUFFER (buffer));
1109   g_return_if_fail (gst_buffer_is_writable (buffer));
1110   g_return_if_fail (mem != NULL);
1111   g_return_if_fail (idx == -1 ||
1112       (idx &gt;= 0 &amp;&amp; idx &lt;= GST_BUFFER_MEM_LEN (buffer)));
1113 
1114   tmp = _memory_get_exclusive_reference (mem);
1115   g_return_if_fail (tmp != NULL);
1116   gst_memory_unref (mem);
1117   _memory_add (buffer, idx, tmp);
1118 }
1119 
1120 static GstMemory *
1121 _get_mapped (GstBuffer * buffer, guint idx, GstMapInfo * info,
1122     GstMapFlags flags)
1123 {
1124   GstMemory *mem, *mapped;
1125 
1126   mem = gst_memory_ref (GST_BUFFER_MEM_PTR (buffer, idx));
1127 
1128   mapped = gst_memory_make_mapped (mem, info, flags);
1129 
1130   if (mapped != mem) {
1131     /* memory changed, lock new memory */
1132     gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (mapped),
1133         GST_MINI_OBJECT_CAST (buffer));
1134     gst_memory_lock (mapped, GST_LOCK_FLAG_EXCLUSIVE);
1135     GST_BUFFER_MEM_PTR (buffer, idx) = mapped;
1136     /* unlock old memory */
1137     gst_memory_unlock (mem, GST_LOCK_FLAG_EXCLUSIVE);
1138     gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (mem),
1139         GST_MINI_OBJECT_CAST (buffer));
1140     GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
1141   }
1142   gst_memory_unref (mem);
1143 
1144   return mapped;
1145 }
1146 
1147 /**
1148  * gst_buffer_peek_memory:
1149  * @buffer: a #GstBuffer.
1150  * @idx: an index
1151  *
1152  * Get the memory block at @idx in @buffer. The memory block stays valid until
1153  * the memory block in @buffer is removed, replaced or merged, typically with
1154  * any call that modifies the memory in @buffer.
1155  *
1156  * Returns: (transfer none) (nullable): the #GstMemory at @idx.
1157  */
1158 GstMemory *
1159 gst_buffer_peek_memory (GstBuffer * buffer, guint idx)
1160 {
1161   guint len;
1162 
1163   g_return_val_if_fail (GST_IS_BUFFER (buffer), NULL);
1164   len = GST_BUFFER_MEM_LEN (buffer);
1165   g_return_val_if_fail (idx &lt; len, NULL);
1166 
1167   return GST_BUFFER_MEM_PTR (buffer, idx);
1168 }
1169 
1170 /**
1171  * gst_buffer_get_memory:
1172  * @buffer: a #GstBuffer.
1173  * @idx: an index
1174  *
1175  * Get the memory block at index @idx in @buffer.
1176  *
1177  * Returns: (transfer full) (nullable): a #GstMemory that contains the data of the
1178  * memory block at @idx. Use gst_memory_unref () after usage.
1179  */
1180 GstMemory *
1181 gst_buffer_get_memory (GstBuffer * buffer, guint idx)
1182 {
1183   return gst_buffer_get_memory_range (buffer, idx, 1);
1184 }
1185 
1186 /**
1187  * gst_buffer_get_all_memory:
1188  * @buffer: a #GstBuffer.
1189  *
1190  * Get all the memory block in @buffer. The memory blocks will be merged
1191  * into one large #GstMemory.
1192  *
1193  * Returns: (transfer full) (nullable): a #GstMemory that contains the merged memory.
1194  * Use gst_memory_unref () after usage.
1195  */
1196 GstMemory *
1197 gst_buffer_get_all_memory (GstBuffer * buffer)
1198 {
1199   return gst_buffer_get_memory_range (buffer, 0, -1);
1200 }
1201 
1202 /**
1203  * gst_buffer_get_memory_range:
1204  * @buffer: a #GstBuffer.
1205  * @idx: an index
1206  * @length: a length
1207  *
1208  * Get @length memory blocks in @buffer starting at @idx. The memory blocks will
1209  * be merged into one large #GstMemory.
1210  *
1211  * If @length is -1, all memory starting from @idx is merged.
1212  *
1213  * Returns: (transfer full) (nullable): a #GstMemory that contains the merged data of @length
1214  *    blocks starting at @idx. Use gst_memory_unref () after usage.
1215  */
1216 GstMemory *
1217 gst_buffer_get_memory_range (GstBuffer * buffer, guint idx, gint length)
1218 {
1219   guint len;
1220 
1221   GST_CAT_DEBUG (GST_CAT_BUFFER, &quot;idx %u, length %d&quot;, idx, length);
1222 
1223   g_return_val_if_fail (GST_IS_BUFFER (buffer), NULL);
1224   len = GST_BUFFER_MEM_LEN (buffer);
1225   g_return_val_if_fail ((len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) ||
1226       (length == -1 &amp;&amp; idx &lt; len) || (length &gt; 0 &amp;&amp; length + idx &lt;= len), NULL);
1227 
1228   if (length == -1)
1229     length = len - idx;
1230 
1231   return _get_merged_memory (buffer, idx, length);
1232 }
1233 
1234 /**
1235  * gst_buffer_replace_memory:
1236  * @buffer: a #GstBuffer.
1237  * @idx: an index
1238  * @mem: (transfer full): a #GstMemory
1239  *
1240  * Replaces the memory block at index @idx in @buffer with @mem.
1241  */
1242 void
1243 gst_buffer_replace_memory (GstBuffer * buffer, guint idx, GstMemory * mem)
1244 {
1245   gst_buffer_replace_memory_range (buffer, idx, 1, mem);
1246 }
1247 
1248 /**
1249  * gst_buffer_replace_all_memory:
1250  * @buffer: a #GstBuffer.
1251  * @mem: (transfer full): a #GstMemory
1252  *
1253  * Replaces all memory in @buffer with @mem.
1254  */
1255 void
1256 gst_buffer_replace_all_memory (GstBuffer * buffer, GstMemory * mem)
1257 {
1258   gst_buffer_replace_memory_range (buffer, 0, -1, mem);
1259 }
1260 
1261 /**
1262  * gst_buffer_replace_memory_range:
1263  * @buffer: a #GstBuffer.
1264  * @idx: an index
1265  * @length: a length should not be 0
1266  * @mem: (transfer full): a #GstMemory
1267  *
1268  * Replaces @length memory blocks in @buffer starting at @idx with @mem.
1269  *
1270  * If @length is -1, all memory starting from @idx will be removed and
1271  * replaced with @mem.
1272  *
1273  * @buffer should be writable.
1274  */
1275 void
1276 gst_buffer_replace_memory_range (GstBuffer * buffer, guint idx, gint length,
1277     GstMemory * mem)
1278 {
1279   guint len;
1280 
1281   g_return_if_fail (GST_IS_BUFFER (buffer));
1282   g_return_if_fail (gst_buffer_is_writable (buffer));
1283 
1284   GST_CAT_DEBUG (GST_CAT_BUFFER, &quot;idx %u, length %d, %p&quot;, idx, length, mem);
1285 
1286   len = GST_BUFFER_MEM_LEN (buffer);
1287   g_return_if_fail ((len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) ||
1288       (length == -1 &amp;&amp; idx &lt; len) || (length &gt; 0 &amp;&amp; length + idx &lt;= len));
1289 
1290   if (length == -1)
1291     length = len - idx;
1292 
1293   _replace_memory (buffer, len, idx, length, mem);
1294 }
1295 
1296 /**
1297  * gst_buffer_remove_memory:
1298  * @buffer: a #GstBuffer.
1299  * @idx: an index
1300  *
1301  * Remove the memory block in @b at index @i.
1302  */
1303 void
1304 gst_buffer_remove_memory (GstBuffer * buffer, guint idx)
1305 {
1306   gst_buffer_remove_memory_range (buffer, idx, 1);
1307 }
1308 
1309 /**
1310  * gst_buffer_remove_all_memory:
1311  * @buffer: a #GstBuffer.
1312  *
1313  * Remove all the memory blocks in @buffer.
1314  */
1315 void
1316 gst_buffer_remove_all_memory (GstBuffer * buffer)
1317 {
1318   gst_buffer_remove_memory_range (buffer, 0, -1);
1319 }
1320 
1321 /**
1322  * gst_buffer_remove_memory_range:
1323  * @buffer: a #GstBuffer.
1324  * @idx: an index
1325  * @length: a length
1326  *
1327  * Remove @length memory blocks in @buffer starting from @idx.
1328  *
1329  * @length can be -1, in which case all memory starting from @idx is removed.
1330  */
1331 void
1332 gst_buffer_remove_memory_range (GstBuffer * buffer, guint idx, gint length)
1333 {
1334   guint len;
1335 
1336   g_return_if_fail (GST_IS_BUFFER (buffer));
1337   g_return_if_fail (gst_buffer_is_writable (buffer));
1338 
1339   GST_CAT_DEBUG (GST_CAT_BUFFER, &quot;idx %u, length %d&quot;, idx, length);
1340 
1341   len = GST_BUFFER_MEM_LEN (buffer);
1342   g_return_if_fail ((len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) ||
1343       (length == -1 &amp;&amp; idx &lt; len) || length + idx &lt;= len);
1344 
1345   if (length == -1)
1346     length = len - idx;
1347 
1348   _replace_memory (buffer, len, idx, length, NULL);
1349 }
1350 
1351 /**
1352  * gst_buffer_find_memory:
1353  * @buffer: a #GstBuffer.
1354  * @offset: an offset
1355  * @size: a size
1356  * @idx: (out): pointer to index
1357  * @length: (out): pointer to length
1358  * @skip: (out): pointer to skip
1359  *
1360  * Find the memory blocks that span @size bytes starting from @offset
1361  * in @buffer.
1362  *
1363  * When this function returns %TRUE, @idx will contain the index of the first
1364  * memory block where the byte for @offset can be found and @length contains the
1365  * number of memory blocks containing the @size remaining bytes. @skip contains
1366  * the number of bytes to skip in the memory block at @idx to get to the byte
1367  * for @offset.
1368  *
1369  * @size can be -1 to get all the memory blocks after @idx.
1370  *
1371  * Returns: %TRUE when @size bytes starting from @offset could be found in
1372  * @buffer and @idx, @length and @skip will be filled.
1373  */
1374 gboolean
1375 gst_buffer_find_memory (GstBuffer * buffer, gsize offset, gsize size,
1376     guint * idx, guint * length, gsize * skip)
1377 {
1378   guint i, len, found;
1379 
1380   g_return_val_if_fail (GST_IS_BUFFER (buffer), FALSE);
1381   g_return_val_if_fail (idx != NULL, FALSE);
1382   g_return_val_if_fail (length != NULL, FALSE);
1383   g_return_val_if_fail (skip != NULL, FALSE);
1384 
1385   len = GST_BUFFER_MEM_LEN (buffer);
1386 
1387   found = 0;
1388   for (i = 0; i &lt; len; i++) {
1389     GstMemory *mem;
1390     gsize s;
1391 
1392     mem = GST_BUFFER_MEM_PTR (buffer, i);
1393     s = gst_memory_get_sizes (mem, NULL, NULL);
1394 
1395     if (s &lt;= offset) {
1396       /* block before offset, or empty block, skip */
1397       offset -= s;
1398     } else {
1399       /* block after offset */
1400       if (found == 0) {
1401         /* first block, remember index and offset */
1402         *idx = i;
1403         *skip = offset;
1404         if (size == -1) {
1405           /* return remaining blocks */
1406           *length = len - i;
1407           return TRUE;
1408         }
1409         s -= offset;
1410         offset = 0;
1411       }
1412       /* count the amount of found bytes */
1413       found += s;
1414       if (found &gt;= size) {
1415         /* we have enough bytes */
1416         *length = i - *idx + 1;
1417         return TRUE;
1418       }
1419     }
1420   }
1421   return FALSE;
1422 }
1423 
1424 /**
1425  * gst_buffer_is_memory_range_writable:
1426  * @buffer: a #GstBuffer.
1427  * @idx: an index
1428  * @length: a length should not be 0
1429  *
1430  * Check if @length memory blocks in @buffer starting from @idx are writable.
1431  *
1432  * @length can be -1 to check all the memory blocks after @idx.
1433  *
1434  * Note that this function does not check if @buffer is writable, use
1435  * gst_buffer_is_writable() to check that if needed.
1436  *
1437  * Returns: %TRUE if the memory range is writable
1438  *
1439  * Since: 1.4
1440  */
1441 gboolean
1442 gst_buffer_is_memory_range_writable (GstBuffer * buffer, guint idx, gint length)
1443 {
1444   guint i, len;
1445 
1446   g_return_val_if_fail (GST_IS_BUFFER (buffer), FALSE);
1447 
1448   GST_CAT_DEBUG (GST_CAT_BUFFER, &quot;idx %u, length %d&quot;, idx, length);
1449 
1450   len = GST_BUFFER_MEM_LEN (buffer);
1451   g_return_val_if_fail ((len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) ||
1452       (length == -1 &amp;&amp; idx &lt; len) || (length &gt; 0 &amp;&amp; length + idx &lt;= len),
1453       FALSE);
1454 #ifdef GSTREAMER_LITE
1455   gboolean expr = (len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) || (length == -1 &amp;&amp; idx &lt; len) || (length &gt; 0 &amp;&amp; length + idx &lt;= len);
1456   if (!expr) {
1457     return FALSE;
1458   }
1459 #endif // GSTREAMER_LITE
1460 
1461   if (length == -1)
1462     len -= idx;
1463   else
1464     len = length;
1465 
1466   for (i = 0; i &lt; len; i++) {
1467     if (!gst_memory_is_writable (GST_BUFFER_MEM_PTR (buffer, i + idx)))
1468       return FALSE;
1469   }
1470   return TRUE;
1471 }
1472 
1473 /**
1474  * gst_buffer_is_all_memory_writable:
1475  * @buffer: a #GstBuffer.
1476  *
1477  * Check if all memory blocks in @buffer are writable.
1478  *
1479  * Note that this function does not check if @buffer is writable, use
1480  * gst_buffer_is_writable() to check that if needed.
1481  *
1482  * Returns: %TRUE if all memory blocks in @buffer are writable
1483  *
1484  * Since: 1.4
1485  */
1486 gboolean
1487 gst_buffer_is_all_memory_writable (GstBuffer * buffer)
1488 {
1489   return gst_buffer_is_memory_range_writable (buffer, 0, -1);
1490 }
1491 
1492 /**
1493  * gst_buffer_get_sizes:
1494  * @buffer: a #GstBuffer.
1495  * @offset: (out) (allow-none): a pointer to the offset
1496  * @maxsize: (out) (allow-none): a pointer to the maxsize
1497  *
1498  * Get the total size of the memory blocks in @b.
1499  *
1500  * When not %NULL, @offset will contain the offset of the data in the
1501  * first memory block in @buffer and @maxsize will contain the sum of
1502  * the size and @offset and the amount of extra padding on the last
1503  * memory block.  @offset and @maxsize can be used to resize the
1504  * buffer memory blocks with gst_buffer_resize().
1505  *
1506  * Returns: total size of the memory blocks in @buffer.
1507  */
1508 gsize
1509 gst_buffer_get_sizes (GstBuffer * buffer, gsize * offset, gsize * maxsize)
1510 {
1511   return gst_buffer_get_sizes_range (buffer, 0, -1, offset, maxsize);
1512 }
1513 
1514 /**
1515  * gst_buffer_get_size:
1516  * @buffer: a #GstBuffer.
1517  *
1518  * Get the total size of the memory blocks in @buffer.
1519  *
1520  * Returns: total size of the memory blocks in @buffer.
1521  */
1522 gsize
1523 gst_buffer_get_size (GstBuffer * buffer)
1524 {
1525   return gst_buffer_get_sizes_range (buffer, 0, -1, NULL, NULL);
1526 }
1527 
1528 /**
1529  * gst_buffer_get_sizes_range:
1530  * @buffer: a #GstBuffer.
1531  * @idx: an index
1532  * @length: a length
1533  * @offset: (out) (allow-none): a pointer to the offset
1534  * @maxsize: (out) (allow-none): a pointer to the maxsize
1535  *
1536  * Get the total size of @length memory blocks stating from @idx in @buffer.
1537  *
1538  * When not %NULL, @offset will contain the offset of the data in the
1539  * memory block in @buffer at @idx and @maxsize will contain the sum of the size
1540  * and @offset and the amount of extra padding on the memory block at @idx +
1541  * @length -1.
1542  * @offset and @maxsize can be used to resize the buffer memory blocks with
1543  * gst_buffer_resize_range().
1544  *
1545  * Returns: total size of @length memory blocks starting at @idx in @buffer.
1546  */
1547 gsize
1548 gst_buffer_get_sizes_range (GstBuffer * buffer, guint idx, gint length,
1549     gsize * offset, gsize * maxsize)
1550 {
1551   guint len;
1552   gsize size;
1553   GstMemory *mem;
1554 
1555   g_return_val_if_fail (GST_IS_BUFFER (buffer), 0);
1556   len = GST_BUFFER_MEM_LEN (buffer);
1557   g_return_val_if_fail ((len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) ||
1558       (length == -1 &amp;&amp; idx &lt; len) || (length + idx &lt;= len), 0);
1559 #ifdef GSTREAMER_LITE
1560   gboolean expr = (len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) || (length == -1 &amp;&amp; idx &lt; len) || (length + idx &lt;= len);
1561   if (!expr) {
1562     return 0;
1563   }
1564 #endif // GSTREAMER_LITE
1565 
1566   if (length == -1)
1567     length = len - idx;
1568 
1569   if (G_LIKELY (length == 1)) {
1570     /* common case */
1571     mem = GST_BUFFER_MEM_PTR (buffer, idx);
1572     size = gst_memory_get_sizes (mem, offset, maxsize);
1573   } else {
1574     guint i, end;
1575     gsize extra, offs;
1576 
1577     end = idx + length;
1578     size = offs = extra = 0;
1579     for (i = idx; i &lt; end; i++) {
1580       gsize s, o, ms;
1581 
1582       mem = GST_BUFFER_MEM_PTR (buffer, i);
1583       s = gst_memory_get_sizes (mem, &amp;o, &amp;ms);
1584 
1585       if (s) {
1586         if (size == 0)
1587           /* first size, take accumulated data before as the offset */
1588           offs = extra + o;
1589         /* add sizes */
1590         size += s;
1591         /* save the amount of data after this block */
1592         extra = ms - (o + s);
1593       } else {
1594         /* empty block, add as extra */
1595         extra += ms;
1596       }
1597     }
1598     if (offset)
1599       *offset = offs;
1600     if (maxsize)
1601       *maxsize = offs + size + extra;
1602   }
1603   return size;
1604 }
1605 
1606 /**
1607  * gst_buffer_resize:
1608  * @buffer: a #GstBuffer.
1609  * @offset: the offset adjustment
1610  * @size: the new size or -1 to just adjust the offset
1611  *
1612  * Set the offset and total size of the memory blocks in @buffer.
1613  */
1614 void
1615 gst_buffer_resize (GstBuffer * buffer, gssize offset, gssize size)
1616 {
1617   gst_buffer_resize_range (buffer, 0, -1, offset, size);
1618 }
1619 
1620 /**
1621  * gst_buffer_set_size:
1622  * @buffer: a #GstBuffer.
1623  * @size: the new size
1624  *
1625  * Set the total size of the memory blocks in @buffer.
1626  */
1627 void
1628 gst_buffer_set_size (GstBuffer * buffer, gssize size)
1629 {
1630   gst_buffer_resize_range (buffer, 0, -1, 0, size);
1631 }
1632 
1633 /**
1634  * gst_buffer_resize_range:
1635  * @buffer: a #GstBuffer.
1636  * @idx: an index
1637  * @length: a length
1638  * @offset: the offset adjustment
1639  * @size: the new size or -1 to just adjust the offset
1640  *
1641  * Set the total size of the @length memory blocks starting at @idx in
1642  * @buffer
1643  *
1644  * Returns: %TRUE if resizing succeeded, %FALSE otherwise.
1645  */
1646 gboolean
1647 gst_buffer_resize_range (GstBuffer * buffer, guint idx, gint length,
1648     gssize offset, gssize size)
1649 {
1650   guint i, len, end;
1651   gsize bsize, bufsize, bufoffs, bufmax;
1652 
1653   g_return_val_if_fail (gst_buffer_is_writable (buffer), FALSE);
1654   g_return_val_if_fail (size &gt;= -1, FALSE);
1655 #ifdef GSTREAMER_LITE
1656   if (!gst_buffer_is_writable (buffer)) {
1657     return FALSE;
1658   }
1659   if (size &lt; -1) {
1660     return FALSE;
1661   }
1662 #endif // GSTREAMER_LITE
1663 
1664   len = GST_BUFFER_MEM_LEN (buffer);
1665   g_return_val_if_fail ((len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) ||
1666       (length == -1 &amp;&amp; idx &lt; len) || (length + idx &lt;= len), FALSE);
1667 #ifdef GSTREAMER_LITE
1668   gboolean expr = (len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) || (length == -1 &amp;&amp; idx &lt; len) || (length + idx &lt;= len);
1669   if (!expr) {
1670     return FALSE;
1671   }
1672 #endif // GSTREAMER_LITE
1673 
1674   if (length == -1)
1675     length = len - idx;
1676 
1677   bufsize = gst_buffer_get_sizes_range (buffer, idx, length, &amp;bufoffs, &amp;bufmax);
1678 
1679   GST_CAT_LOG (GST_CAT_BUFFER, &quot;trim %p %&quot; G_GSSIZE_FORMAT &quot;-%&quot; G_GSSIZE_FORMAT
1680       &quot; size:%&quot; G_GSIZE_FORMAT &quot; offs:%&quot; G_GSIZE_FORMAT &quot; max:%&quot;
1681       G_GSIZE_FORMAT, buffer, offset, size, bufsize, bufoffs, bufmax);
1682 
1683   /* we can&#39;t go back further than the current offset or past the end of the
1684    * buffer */
1685   g_return_val_if_fail ((offset &lt; 0 &amp;&amp; bufoffs &gt;= -offset) || (offset &gt;= 0
1686           &amp;&amp; bufoffs + offset &lt;= bufmax), FALSE);
1687 #ifdef GSTREAMER_LITE
1688   expr = (offset &lt; 0 &amp;&amp; bufoffs &gt;= -offset) || (offset &gt;= 0 &amp;&amp; bufoffs + offset &lt;= bufmax);
1689   if (!expr) {
1690     return FALSE;
1691   }
1692 #endif // GSTREAMER_LITE
1693   if (size == -1) {
1694     g_return_val_if_fail (bufsize &gt;= offset, FALSE);
1695 #ifdef GSTREAMER_LITE
1696   expr = bufsize &gt;= offset;
1697   if (!expr) {
1698     return FALSE;
1699   }
1700 #endif // GSTREAMER_LITE
1701     size = bufsize - offset;
1702   }
1703   g_return_val_if_fail (bufmax &gt;= bufoffs + offset + size, FALSE);
1704 #ifdef GSTREAMER_LITE
1705   expr = bufmax &gt;= bufoffs + offset + size;
1706   if (!expr) {
1707     return FALSE;
1708   }
1709 #endif // GSTREAMER_LITE
1710 
1711   /* no change */
1712   if (offset == 0 &amp;&amp; size == bufsize)
1713     return TRUE;
1714 
1715   end = idx + length;
1716   /* copy and trim */
1717   for (i = idx; i &lt; end; i++) {
1718     GstMemory *mem;
1719     gsize left, noffs;
1720 
1721     mem = GST_BUFFER_MEM_PTR (buffer, i);
1722     bsize = gst_memory_get_sizes (mem, NULL, NULL);
1723 
1724     noffs = 0;
1725     /* last buffer always gets resized to the remaining size */
1726     if (i + 1 == end)
1727       left = size;
1728     /* shrink buffers before the offset */
1729     else if ((gssize) bsize &lt;= offset) {
1730       left = 0;
1731       noffs = offset - bsize;
1732       offset = 0;
1733     }
1734     /* clip other buffers */
1735     else
1736       left = MIN (bsize - offset, size);
1737 
1738     if (offset != 0 || left != bsize) {
1739       if (gst_memory_is_writable (mem)) {
1740         gst_memory_resize (mem, offset, left);
1741       } else {
1742         GstMemory *newmem = NULL;
1743 
1744         if (!GST_MEMORY_IS_NO_SHARE (mem))
1745           newmem = gst_memory_share (mem, offset, left);
1746 
1747         if (!newmem)
1748           newmem = gst_memory_copy (mem, offset, left);
1749 
1750         if (newmem == NULL)
1751           return FALSE;
1752 
1753         gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (newmem),
1754             GST_MINI_OBJECT_CAST (buffer));
1755         gst_memory_lock (newmem, GST_LOCK_FLAG_EXCLUSIVE);
1756         GST_BUFFER_MEM_PTR (buffer, i) = newmem;
1757         gst_memory_unlock (mem, GST_LOCK_FLAG_EXCLUSIVE);
1758         gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (mem),
1759             GST_MINI_OBJECT_CAST (buffer));
1760         gst_memory_unref (mem);
1761 
1762         GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
1763       }
1764     }
1765 
1766     offset = noffs;
1767     size -= left;
1768   }
1769 
1770   return TRUE;
1771 }
1772 
1773 /**
1774  * gst_buffer_map:
1775  * @buffer: a #GstBuffer.
1776  * @info: (out): info about the mapping
1777  * @flags: flags for the mapping
1778  *
1779  * This function fills @info with the #GstMapInfo of all merged memory
1780  * blocks in @buffer.
1781  *
1782  * @flags describe the desired access of the memory. When @flags is
1783  * #GST_MAP_WRITE, @buffer should be writable (as returned from
1784  * gst_buffer_is_writable()).
1785  *
1786  * When @buffer is writable but the memory isn&#39;t, a writable copy will
1787  * automatically be created and returned. The readonly copy of the
1788  * buffer memory will then also be replaced with this writable copy.
1789  *
1790  * The memory in @info should be unmapped with gst_buffer_unmap() after
1791  * usage.
1792  *
1793  * Returns: %TRUE if the map succeeded and @info contains valid data.
1794  */
1795 gboolean
1796 gst_buffer_map (GstBuffer * buffer, GstMapInfo * info, GstMapFlags flags)
1797 {
1798   return gst_buffer_map_range (buffer, 0, -1, info, flags);
1799 }
1800 
1801 /**
1802  * gst_buffer_map_range:
1803  * @buffer: a #GstBuffer.
1804  * @idx: an index
1805  * @length: a length
1806  * @info: (out): info about the mapping
1807  * @flags: flags for the mapping
1808  *
1809  * This function fills @info with the #GstMapInfo of @length merged memory blocks
1810  * starting at @idx in @buffer. When @length is -1, all memory blocks starting
1811  * from @idx are merged and mapped.
1812  *
1813  * @flags describe the desired access of the memory. When @flags is
1814  * #GST_MAP_WRITE, @buffer should be writable (as returned from
1815  * gst_buffer_is_writable()).
1816  *
1817  * When @buffer is writable but the memory isn&#39;t, a writable copy will
1818  * automatically be created and returned. The readonly copy of the buffer memory
1819  * will then also be replaced with this writable copy.
1820  *
1821  * The memory in @info should be unmapped with gst_buffer_unmap() after usage.
1822  *
1823  * Returns: %TRUE if the map succeeded and @info contains valid
1824  * data.
1825  */
1826 gboolean
1827 gst_buffer_map_range (GstBuffer * buffer, guint idx, gint length,
1828     GstMapInfo * info, GstMapFlags flags)
1829 {
1830   GstMemory *mem, *nmem;
1831   gboolean write, writable;
1832   gsize len;
1833 
1834   g_return_val_if_fail (GST_IS_BUFFER (buffer), FALSE);
1835   g_return_val_if_fail (info != NULL, FALSE);
1836   len = GST_BUFFER_MEM_LEN (buffer);
1837   g_return_val_if_fail ((len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) ||
1838       (length == -1 &amp;&amp; idx &lt; len) || (length &gt; 0
1839           &amp;&amp; length + idx &lt;= len), FALSE);
1840 
1841   GST_CAT_LOG (GST_CAT_BUFFER, &quot;buffer %p, idx %u, length %d, flags %04x&quot;,
1842       buffer, idx, length, flags);
1843 
1844   write = (flags &amp; GST_MAP_WRITE) != 0;
1845   writable = gst_buffer_is_writable (buffer);
1846 
1847   /* check if we can write when asked for write access */
1848   if (G_UNLIKELY (write &amp;&amp; !writable))
1849     goto not_writable;
1850 
1851   if (length == -1)
1852     length = len - idx;
1853 
1854   mem = _get_merged_memory (buffer, idx, length);
1855   if (G_UNLIKELY (mem == NULL))
1856     goto no_memory;
1857 
1858   /* now try to map */
1859   nmem = gst_memory_make_mapped (mem, info, flags);
1860   if (G_UNLIKELY (nmem == NULL))
1861     goto cannot_map;
1862 
1863   /* if we merged or when the map returned a different memory, we try to replace
1864    * the memory in the buffer */
1865   if (G_UNLIKELY (length &gt; 1 || nmem != mem)) {
1866     /* if the buffer is writable, replace the memory */
1867     if (writable) {
1868       _replace_memory (buffer, len, idx, length, gst_memory_ref (nmem));
1869     } else {
1870       if (len &gt; 1) {
1871         GST_CAT_DEBUG (GST_CAT_PERFORMANCE,
1872             &quot;temporary mapping for memory %p in buffer %p&quot;, nmem, buffer);
1873       }
1874     }
1875   }
1876   return TRUE;
1877 
1878   /* ERROR */
1879 not_writable:
1880   {
1881     GST_WARNING_OBJECT (buffer, &quot;write map requested on non-writable buffer&quot;);
1882     g_critical (&quot;write map requested on non-writable buffer&quot;);
1883     memset (info, 0, sizeof (GstMapInfo));
1884     return FALSE;
1885   }
1886 no_memory:
1887   {
1888     /* empty buffer, we need to return NULL */
1889     GST_DEBUG_OBJECT (buffer, &quot;can&#39;t get buffer memory&quot;);
1890     memset (info, 0, sizeof (GstMapInfo));
1891     return TRUE;
1892   }
1893 cannot_map:
1894   {
1895     GST_DEBUG_OBJECT (buffer, &quot;cannot map memory&quot;);
1896     memset (info, 0, sizeof (GstMapInfo));
1897     return FALSE;
1898   }
1899 }
1900 
1901 /**
1902  * gst_buffer_unmap:
1903  * @buffer: a #GstBuffer.
1904  * @info: a #GstMapInfo
1905  *
1906  * Release the memory previously mapped with gst_buffer_map().
1907  */
1908 void
1909 gst_buffer_unmap (GstBuffer * buffer, GstMapInfo * info)
1910 {
1911   g_return_if_fail (GST_IS_BUFFER (buffer));
1912   g_return_if_fail (info != NULL);
1913 
1914   /* we need to check for NULL, it is possible that we tried to map a buffer
1915    * without memory and we should be able to unmap that fine */
1916   if (G_LIKELY (info-&gt;memory)) {
1917     gst_memory_unmap (info-&gt;memory, info);
1918     gst_memory_unref (info-&gt;memory);
1919   }
1920 }
1921 
1922 /**
1923  * gst_buffer_fill:
1924  * @buffer: a #GstBuffer.
1925  * @offset: the offset to fill
1926  * @src: (array length=size) (element-type guint8): the source address
1927  * @size: the size to fill
1928  *
1929  * Copy @size bytes from @src to @buffer at @offset.
1930  *
1931  * Returns: The amount of bytes copied. This value can be lower than @size
1932  *    when @buffer did not contain enough data.
1933  */
1934 gsize
1935 gst_buffer_fill (GstBuffer * buffer, gsize offset, gconstpointer src,
1936     gsize size)
1937 {
1938   gsize i, len, left;
1939   const guint8 *ptr = src;
1940 
1941   g_return_val_if_fail (GST_IS_BUFFER (buffer), 0);
1942   g_return_val_if_fail (gst_buffer_is_writable (buffer), 0);
1943   g_return_val_if_fail (src != NULL || size == 0, 0);
1944 
1945   GST_CAT_LOG (GST_CAT_BUFFER,
1946       &quot;buffer %p, offset %&quot; G_GSIZE_FORMAT &quot;, size %&quot; G_GSIZE_FORMAT, buffer,
1947       offset, size);
1948 
1949   len = GST_BUFFER_MEM_LEN (buffer);
1950   left = size;
1951 
1952   for (i = 0; i &lt; len &amp;&amp; left &gt; 0; i++) {
1953     GstMapInfo info;
1954     gsize tocopy;
1955     GstMemory *mem;
1956 
1957     mem = _get_mapped (buffer, i, &amp;info, GST_MAP_WRITE);
1958     if (info.size &gt; offset) {
1959       /* we have enough */
1960       tocopy = MIN (info.size - offset, left);
1961       memcpy ((guint8 *) info.data + offset, ptr, tocopy);
1962       left -= tocopy;
1963       ptr += tocopy;
1964       offset = 0;
1965     } else {
1966       /* offset past buffer, skip */
1967       offset -= info.size;
1968     }
1969     gst_memory_unmap (mem, &amp;info);
1970   }
1971   return size - left;
1972 }
1973 
1974 /**
1975  * gst_buffer_extract:
1976  * @buffer: a #GstBuffer.
1977  * @offset: the offset to extract
1978  * @dest: (out caller-allocates) (array length=size) (element-type guint8):
1979  *     the destination address
1980  * @size: the size to extract
1981  *
1982  * Copy @size bytes starting from @offset in @buffer to @dest.
1983  *
1984  * Returns: The amount of bytes extracted. This value can be lower than @size
1985  *    when @buffer did not contain enough data.
1986  */
1987 gsize
1988 gst_buffer_extract (GstBuffer * buffer, gsize offset, gpointer dest, gsize size)
1989 {
1990   gsize i, len, left;
1991   guint8 *ptr = dest;
1992 
1993   g_return_val_if_fail (GST_IS_BUFFER (buffer), 0);
1994   g_return_val_if_fail (dest != NULL, 0);
1995 
1996   GST_CAT_LOG (GST_CAT_BUFFER,
1997       &quot;buffer %p, offset %&quot; G_GSIZE_FORMAT &quot;, size %&quot; G_GSIZE_FORMAT, buffer,
1998       offset, size);
1999 
2000   len = GST_BUFFER_MEM_LEN (buffer);
2001   left = size;
2002 
2003   for (i = 0; i &lt; len &amp;&amp; left &gt; 0; i++) {
2004     GstMapInfo info;
2005     gsize tocopy;
2006     GstMemory *mem;
2007 
2008     mem = _get_mapped (buffer, i, &amp;info, GST_MAP_READ);
2009     if (info.size &gt; offset) {
2010       /* we have enough */
2011       tocopy = MIN (info.size - offset, left);
2012       memcpy (ptr, (guint8 *) info.data + offset, tocopy);
2013       left -= tocopy;
2014       ptr += tocopy;
2015       offset = 0;
2016     } else {
2017       /* offset past buffer, skip */
2018       offset -= info.size;
2019     }
2020     gst_memory_unmap (mem, &amp;info);
2021   }
2022   return size - left;
2023 }
2024 
2025 /**
2026  * gst_buffer_memcmp:
2027  * @buffer: a #GstBuffer.
2028  * @offset: the offset in @buffer
2029  * @mem: (array length=size) (element-type guint8): the memory to compare
2030  * @size: the size to compare
2031  *
2032  * Compare @size bytes starting from @offset in @buffer with the memory in @mem.
2033  *
2034  * Returns: 0 if the memory is equal.
2035  */
2036 gint
2037 gst_buffer_memcmp (GstBuffer * buffer, gsize offset, gconstpointer mem,
2038     gsize size)
2039 {
2040   gsize i, len;
2041   const guint8 *ptr = mem;
2042   gint res = 0;
2043 
2044   g_return_val_if_fail (GST_IS_BUFFER (buffer), 0);
2045   g_return_val_if_fail (mem != NULL, 0);
2046 
2047   GST_CAT_LOG (GST_CAT_BUFFER,
2048       &quot;buffer %p, offset %&quot; G_GSIZE_FORMAT &quot;, size %&quot; G_GSIZE_FORMAT, buffer,
2049       offset, size);
2050 
2051   if (G_UNLIKELY (gst_buffer_get_size (buffer) &lt; offset + size))
2052     return -1;
2053 
2054   len = GST_BUFFER_MEM_LEN (buffer);
2055 
2056   for (i = 0; i &lt; len &amp;&amp; size &gt; 0 &amp;&amp; res == 0; i++) {
2057     GstMapInfo info;
2058     gsize tocmp;
2059     GstMemory *mem;
2060 
2061     mem = _get_mapped (buffer, i, &amp;info, GST_MAP_READ);
2062     if (info.size &gt; offset) {
2063       /* we have enough */
2064       tocmp = MIN (info.size - offset, size);
2065       res = memcmp (ptr, (guint8 *) info.data + offset, tocmp);
2066       size -= tocmp;
2067       ptr += tocmp;
2068       offset = 0;
2069     } else {
2070       /* offset past buffer, skip */
2071       offset -= info.size;
2072     }
2073     gst_memory_unmap (mem, &amp;info);
2074   }
2075   return res;
2076 }
2077 
2078 /**
2079  * gst_buffer_memset:
2080  * @buffer: a #GstBuffer.
2081  * @offset: the offset in @buffer
2082  * @val: the value to set
2083  * @size: the size to set
2084  *
2085  * Fill @buf with @size bytes with @val starting from @offset.
2086  *
2087  * Returns: The amount of bytes filled. This value can be lower than @size
2088  *    when @buffer did not contain enough data.
2089  */
2090 gsize
2091 gst_buffer_memset (GstBuffer * buffer, gsize offset, guint8 val, gsize size)
2092 {
2093   gsize i, len, left;
2094 
2095   g_return_val_if_fail (GST_IS_BUFFER (buffer), 0);
2096   g_return_val_if_fail (gst_buffer_is_writable (buffer), 0);
2097 
2098   GST_CAT_LOG (GST_CAT_BUFFER,
2099       &quot;buffer %p, offset %&quot; G_GSIZE_FORMAT &quot;, val %02x, size %&quot; G_GSIZE_FORMAT,
2100       buffer, offset, val, size);
2101 
2102   len = GST_BUFFER_MEM_LEN (buffer);
2103   left = size;
2104 
2105   for (i = 0; i &lt; len &amp;&amp; left &gt; 0; i++) {
2106     GstMapInfo info;
2107     gsize toset;
2108     GstMemory *mem;
2109 
2110     mem = _get_mapped (buffer, i, &amp;info, GST_MAP_WRITE);
2111     if (info.size &gt; offset) {
2112       /* we have enough */
2113       toset = MIN (info.size - offset, left);
2114       memset ((guint8 *) info.data + offset, val, toset);
2115       left -= toset;
2116       offset = 0;
2117     } else {
2118       /* offset past buffer, skip */
2119       offset -= info.size;
2120     }
2121     gst_memory_unmap (mem, &amp;info);
2122   }
2123   return size - left;
2124 }
2125 
2126 /**
2127  * gst_buffer_copy_region:
2128  * @parent: a #GstBuffer.
2129  * @flags: the #GstBufferCopyFlags
2130  * @offset: the offset into parent #GstBuffer at which the new sub-buffer
2131  *          begins.
2132  * @size: the size of the new #GstBuffer sub-buffer, in bytes. If -1, all
2133  *        data is copied.
2134  *
2135  * Creates a sub-buffer from @parent at @offset and @size.
2136  * This sub-buffer uses the actual memory space of the parent buffer.
2137  * This function will copy the offset and timestamp fields when the
2138  * offset is 0. If not, they will be set to #GST_CLOCK_TIME_NONE and
2139  * #GST_BUFFER_OFFSET_NONE.
2140  * If @offset equals 0 and @size equals the total size of @buffer, the
2141  * duration and offset end fields are also copied. If not they will be set
2142  * to #GST_CLOCK_TIME_NONE and #GST_BUFFER_OFFSET_NONE.
2143  *
2144  * MT safe.
2145  *
2146  * Returns: (transfer full): the new #GstBuffer or %NULL if the arguments were
2147  *     invalid.
2148  */
2149 GstBuffer *
2150 gst_buffer_copy_region (GstBuffer * buffer, GstBufferCopyFlags flags,
2151     gsize offset, gsize size)
2152 {
2153   GstBuffer *copy;
2154 
2155   g_return_val_if_fail (buffer != NULL, NULL);
2156 
2157   /* create the new buffer */
2158   copy = gst_buffer_new ();
2159 
2160   GST_CAT_LOG (GST_CAT_BUFFER, &quot;new region copy %p of %p %&quot; G_GSIZE_FORMAT
2161       &quot;-%&quot; G_GSIZE_FORMAT, copy, buffer, offset, size);
2162 
2163   if (!gst_buffer_copy_into (copy, buffer, flags, offset, size))
2164     gst_buffer_replace (&amp;copy, NULL);
2165 
2166   return copy;
2167 }
2168 
2169 /**
2170  * gst_buffer_append:
2171  * @buf1: (transfer full): the first source #GstBuffer to append.
2172  * @buf2: (transfer full): the second source #GstBuffer to append.
2173  *
2174  * Append all the memory from @buf2 to @buf1. The result buffer will contain a
2175  * concatenation of the memory of @buf1 and @buf2.
2176  *
2177  * Returns: (transfer full): the new #GstBuffer that contains the memory
2178  *     of the two source buffers.
2179  */
2180 GstBuffer *
2181 gst_buffer_append (GstBuffer * buf1, GstBuffer * buf2)
2182 {
2183   return gst_buffer_append_region (buf1, buf2, 0, -1);
2184 }
2185 
2186 /**
2187  * gst_buffer_append_region:
2188  * @buf1: (transfer full): the first source #GstBuffer to append.
2189  * @buf2: (transfer full): the second source #GstBuffer to append.
2190  * @offset: the offset in @buf2
2191  * @size: the size or -1 of @buf2
2192  *
2193  * Append @size bytes at @offset from @buf2 to @buf1. The result buffer will
2194  * contain a concatenation of the memory of @buf1 and the requested region of
2195  * @buf2.
2196  *
2197  * Returns: (transfer full): the new #GstBuffer that contains the memory
2198  *     of the two source buffers.
2199  */
2200 GstBuffer *
2201 gst_buffer_append_region (GstBuffer * buf1, GstBuffer * buf2, gssize offset,
2202     gssize size)
2203 {
2204   gsize i, len;
2205 
2206   g_return_val_if_fail (GST_IS_BUFFER (buf1), NULL);
2207   g_return_val_if_fail (GST_IS_BUFFER (buf2), NULL);
2208 
2209   buf1 = gst_buffer_make_writable (buf1);
2210   buf2 = gst_buffer_make_writable (buf2);
2211 
2212   gst_buffer_resize (buf2, offset, size);
2213 
2214   len = GST_BUFFER_MEM_LEN (buf2);
2215   for (i = 0; i &lt; len; i++) {
2216     GstMemory *mem;
2217 
2218     mem = GST_BUFFER_MEM_PTR (buf2, i);
2219     gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (mem),
2220         GST_MINI_OBJECT_CAST (buf2));
2221     GST_BUFFER_MEM_PTR (buf2, i) = NULL;
2222     _memory_add (buf1, -1, mem);
2223   }
2224 
2225   GST_BUFFER_MEM_LEN (buf2) = 0;
2226   GST_BUFFER_FLAG_SET (buf2, GST_BUFFER_FLAG_TAG_MEMORY);
2227   gst_buffer_unref (buf2);
2228 
2229   return buf1;
2230 }
2231 
2232 /**
2233  * gst_buffer_get_meta:
2234  * @buffer: a #GstBuffer
2235  * @api: the #GType of an API
2236  *
2237  * Get the metadata for @api on buffer. When there is no such metadata, %NULL is
2238  * returned. If multiple metadata with the given @api are attached to this
2239  * buffer only the first one is returned.  To handle multiple metadata with a
2240  * given API use gst_buffer_iterate_meta() or gst_buffer_foreach_meta() instead
2241  * and check the meta-&gt;info.api member for the API type.
2242  *
2243  * Returns: (transfer none) (nullable): the metadata for @api on
2244  * @buffer.
2245  */
2246 GstMeta *
2247 gst_buffer_get_meta (GstBuffer * buffer, GType api)
2248 {
2249   GstMetaItem *item;
2250   GstMeta *result = NULL;
2251 
2252   g_return_val_if_fail (buffer != NULL, NULL);
2253   g_return_val_if_fail (api != 0, NULL);
2254 
2255   /* find GstMeta of the requested API */
2256   for (item = GST_BUFFER_META (buffer); item; item = item-&gt;next) {
2257     GstMeta *meta = &amp;item-&gt;meta;
2258     if (meta-&gt;info-&gt;api == api) {
2259       result = meta;
2260       break;
2261     }
2262   }
2263   return result;
2264 }
2265 
2266 /**
2267  * gst_buffer_get_n_meta:
2268  * @buffer: a #GstBuffer
2269  * @api_type: the #GType of an API
2270  *
2271  * Returns: number of metas of type @api_type on @buffer.
2272  *
2273  * Since: 1.14
2274  */
2275 guint
2276 gst_buffer_get_n_meta (GstBuffer * buffer, GType api_type)
2277 {
2278   gpointer state = NULL;
2279   GstMeta *meta;
2280   guint n = 0;
2281 
2282   while ((meta = gst_buffer_iterate_meta_filtered (buffer, &amp;state, api_type)))
2283     ++n;
2284 
2285   return n;
2286 }
2287 
2288 /**
2289  * gst_buffer_add_meta:
2290  * @buffer: a #GstBuffer
2291  * @info: a #GstMetaInfo
2292  * @params: params for @info
2293  *
2294  * Add metadata for @info to @buffer using the parameters in @params.
2295  *
2296  * Returns: (transfer none) (nullable): the metadata for the api in @info on @buffer.
2297  */
2298 GstMeta *
2299 gst_buffer_add_meta (GstBuffer * buffer, const GstMetaInfo * info,
2300     gpointer params)
2301 {
2302   GstMetaItem *item;
2303   GstMeta *result = NULL;
2304   gsize size;
2305 
2306   g_return_val_if_fail (buffer != NULL, NULL);
2307   g_return_val_if_fail (info != NULL, NULL);
2308   g_return_val_if_fail (gst_buffer_is_writable (buffer), NULL);
2309 
2310   /* create a new slice */
2311   size = ITEM_SIZE (info);
2312   /* We warn in gst_meta_register() about metas without
2313    * init function but let&#39;s play safe here and prevent
2314    * uninitialized memory
2315    */
2316   if (!info-&gt;init_func)
2317     item = g_slice_alloc0 (size);
2318   else
2319     item = g_slice_alloc (size);
2320   result = &amp;item-&gt;meta;
2321   result-&gt;info = info;
2322   result-&gt;flags = GST_META_FLAG_NONE;
2323   GST_CAT_DEBUG (GST_CAT_BUFFER,
2324       &quot;alloc metadata %p (%s) of size %&quot; G_GSIZE_FORMAT, result,
2325       g_type_name (info-&gt;type), info-&gt;size);
2326 
2327   /* call the init_func when needed */
2328   if (info-&gt;init_func)
2329     if (!info-&gt;init_func (result, params, buffer))
2330       goto init_failed;
2331 
2332   item-&gt;seq_num = gst_atomic_int64_inc (&amp;meta_seq);
2333   item-&gt;next = NULL;
2334 
2335   if (!GST_BUFFER_META (buffer)) {
2336     GST_BUFFER_META (buffer) = item;
2337     GST_BUFFER_TAIL_META (buffer) = item;
2338   } else {
2339     GST_BUFFER_TAIL_META (buffer)-&gt;next = item;
2340     GST_BUFFER_TAIL_META (buffer) = item;
2341   }
2342 
2343   return result;
2344 
2345 init_failed:
2346   {
2347     g_slice_free1 (size, item);
2348     return NULL;
2349   }
2350 }
2351 
2352 /**
2353  * gst_buffer_remove_meta:
2354  * @buffer: a #GstBuffer
2355  * @meta: a #GstMeta
2356  *
2357  * Remove the metadata for @meta on @buffer.
2358  *
2359  * Returns: %TRUE if the metadata existed and was removed, %FALSE if no such
2360  * metadata was on @buffer.
2361  */
2362 gboolean
2363 gst_buffer_remove_meta (GstBuffer * buffer, GstMeta * meta)
2364 {
2365   GstMetaItem *walk, *prev;
2366 
2367   g_return_val_if_fail (buffer != NULL, FALSE);
2368   g_return_val_if_fail (meta != NULL, FALSE);
2369   g_return_val_if_fail (gst_buffer_is_writable (buffer), FALSE);
2370   g_return_val_if_fail (!GST_META_FLAG_IS_SET (meta, GST_META_FLAG_LOCKED),
2371       FALSE);
2372 
2373   /* find the metadata and delete */
2374   prev = GST_BUFFER_META (buffer);
2375   for (walk = prev; walk; walk = walk-&gt;next) {
2376     GstMeta *m = &amp;walk-&gt;meta;
2377     if (m == meta) {
2378       const GstMetaInfo *info = meta-&gt;info;
2379 
2380       /* remove from list */
2381       if (GST_BUFFER_TAIL_META (buffer) == walk) {
2382         if (prev != walk)
2383           GST_BUFFER_TAIL_META (buffer) = prev;
2384         else
2385           GST_BUFFER_TAIL_META (buffer) = NULL;
2386       }
2387 
2388       if (GST_BUFFER_META (buffer) == walk)
2389         GST_BUFFER_META (buffer) = walk-&gt;next;
2390       else
2391         prev-&gt;next = walk-&gt;next;
2392 
2393       /* call free_func if any */
2394       if (info-&gt;free_func)
2395         info-&gt;free_func (m, buffer);
2396 
2397       /* and free the slice */
2398       g_slice_free1 (ITEM_SIZE (info), walk);
2399       break;
2400     }
2401     prev = walk;
2402   }
2403   return walk != NULL;
2404 }
2405 
2406 /**
2407  * gst_buffer_iterate_meta: (skip)
2408  * @buffer: a #GstBuffer
2409  * @state: (out caller-allocates): an opaque state pointer
2410  *
2411  * Retrieve the next #GstMeta after @current. If @state points
2412  * to %NULL, the first metadata is returned.
2413  *
2414  * @state will be updated with an opaque state pointer
2415  *
2416  * Returns: (transfer none) (nullable): The next #GstMeta or %NULL
2417  * when there are no more items.
2418  */
2419 GstMeta *
2420 gst_buffer_iterate_meta (GstBuffer * buffer, gpointer * state)
2421 {
2422   GstMetaItem **meta;
2423 
2424   g_return_val_if_fail (buffer != NULL, NULL);
2425   g_return_val_if_fail (state != NULL, NULL);
2426 
2427   meta = (GstMetaItem **) state;
2428   if (*meta == NULL)
2429     /* state NULL, move to first item */
2430     *meta = GST_BUFFER_META (buffer);
2431   else
2432     /* state !NULL, move to next item in list */
2433     *meta = (*meta)-&gt;next;
2434 
2435   if (*meta)
2436     return &amp;(*meta)-&gt;meta;
2437   else
2438     return NULL;
2439 }
2440 
2441 /**
2442  * gst_buffer_iterate_meta_filtered: (skip)
2443  * @buffer: a #GstBuffer
2444  * @state: (out caller-allocates): an opaque state pointer
2445  * @meta_api_type: only return #GstMeta of this type
2446  *
2447  * Retrieve the next #GstMeta of type @meta_api_type after the current one
2448  * according to @state. If @state points to %NULL, the first metadata of
2449  * type @meta_api_type is returned.
2450  *
2451  * @state will be updated with an opaque state pointer
2452  *
2453  * Returns: (transfer none) (nullable): The next #GstMeta of type
2454  * @meta_api_type or %NULL when there are no more items.
2455  *
2456  * Since: 1.12
2457  */
2458 GstMeta *
2459 gst_buffer_iterate_meta_filtered (GstBuffer * buffer, gpointer * state,
2460     GType meta_api_type)
2461 {
2462   GstMetaItem **meta;
2463 
2464   g_return_val_if_fail (buffer != NULL, NULL);
2465   g_return_val_if_fail (state != NULL, NULL);
2466 
2467   meta = (GstMetaItem **) state;
2468   if (*meta == NULL)
2469     /* state NULL, move to first item */
2470     *meta = GST_BUFFER_META (buffer);
2471   else
2472     /* state !NULL, move to next item in list */
2473     *meta = (*meta)-&gt;next;
2474 
2475   while (*meta != NULL &amp;&amp; (*meta)-&gt;meta.info-&gt;api != meta_api_type)
2476     *meta = (*meta)-&gt;next;
2477 
2478   if (*meta)
2479     return &amp;(*meta)-&gt;meta;
2480   else
2481     return NULL;
2482 }
2483 
2484 /**
2485  * gst_buffer_foreach_meta:
2486  * @buffer: a #GstBuffer
2487  * @func: (scope call): a #GstBufferForeachMetaFunc to call
2488  * @user_data: (closure): user data passed to @func
2489  *
2490  * Call @func with @user_data for each meta in @buffer.
2491  *
2492  * @func can modify the passed meta pointer or its contents. The return value
2493  * of @func define if this function returns or if the remaining metadata items
2494  * in the buffer should be skipped.
2495  *
2496  * Returns: %FALSE when @func returned %FALSE for one of the metadata.
2497  */
2498 gboolean
2499 gst_buffer_foreach_meta (GstBuffer * buffer, GstBufferForeachMetaFunc func,
2500     gpointer user_data)
2501 {
2502   GstMetaItem *walk, *prev, *next;
2503   gboolean res = TRUE;
2504 
2505   g_return_val_if_fail (buffer != NULL, FALSE);
2506   g_return_val_if_fail (func != NULL, FALSE);
2507 
2508   /* find the metadata and delete */
2509   prev = GST_BUFFER_META (buffer);
2510   for (walk = prev; walk; walk = next) {
2511     GstMeta *m, *new;
2512 
2513     m = new = &amp;walk-&gt;meta;
2514     next = walk-&gt;next;
2515 
2516     res = func (buffer, &amp;new, user_data);
2517 
2518     if (new == NULL) {
2519       const GstMetaInfo *info = m-&gt;info;
2520 
2521       GST_CAT_DEBUG (GST_CAT_BUFFER, &quot;remove metadata %p (%s)&quot;, m,
2522           g_type_name (info-&gt;type));
2523 
2524       g_return_val_if_fail (gst_buffer_is_writable (buffer), FALSE);
2525       g_return_val_if_fail (!GST_META_FLAG_IS_SET (m, GST_META_FLAG_LOCKED),
2526           FALSE);
2527 
2528       if (GST_BUFFER_TAIL_META (buffer) == walk) {
2529         if (prev != walk)
2530           GST_BUFFER_TAIL_META (buffer) = prev;
2531         else
2532           GST_BUFFER_TAIL_META (buffer) = NULL;
2533       }
2534 
2535       /* remove from list */
2536       if (GST_BUFFER_META (buffer) == walk)
2537         prev = GST_BUFFER_META (buffer) = next;
2538       else
2539         prev-&gt;next = next;
2540 
2541       /* call free_func if any */
2542       if (info-&gt;free_func)
2543         info-&gt;free_func (m, buffer);
2544 
2545       /* and free the slice */
2546       g_slice_free1 (ITEM_SIZE (info), walk);
2547     } else {
2548       prev = walk;
2549     }
2550     if (!res)
2551       break;
2552   }
2553   return res;
2554 }
2555 
2556 /**
2557  * gst_buffer_extract_dup:
2558  * @buffer: a #GstBuffer
2559  * @offset: the offset to extract
2560  * @size: the size to extract
2561  * @dest: (array length=dest_size) (element-type guint8) (out): A pointer where
2562  *  the destination array will be written. Might be %NULL if the size is 0.
2563  * @dest_size: (out): A location where the size of @dest can be written
2564  *
2565  * Extracts a copy of at most @size bytes the data at @offset into
2566  * newly-allocated memory. @dest must be freed using g_free() when done.
2567  *
2568  * Since: 1.0.10
2569  */
2570 
2571 void
2572 gst_buffer_extract_dup (GstBuffer * buffer, gsize offset, gsize size,
2573     gpointer * dest, gsize * dest_size)
2574 {
2575   gsize real_size, alloc_size;
2576 
2577   real_size = gst_buffer_get_size (buffer);
2578 
2579   alloc_size = MIN (real_size - offset, size);
2580   if (alloc_size == 0) {
2581     *dest = NULL;
2582     *dest_size = 0;
2583   } else {
2584     *dest = g_malloc (alloc_size);
2585     *dest_size = gst_buffer_extract (buffer, offset, *dest, size);
2586   }
2587 }
2588 
2589 GST_DEBUG_CATEGORY_STATIC (gst_parent_buffer_meta_debug);
2590 
2591 /**
2592  * gst_buffer_add_parent_buffer_meta:
2593  * @buffer: (transfer none): a #GstBuffer
2594  * @ref: (transfer none): a #GstBuffer to ref
2595  *
2596  * Add a #GstParentBufferMeta to @buffer that holds a reference on
2597  * @ref until the buffer is freed.
2598  *
2599  * Returns: (transfer none) (nullable): The #GstParentBufferMeta that was added to the buffer
2600  *
2601  * Since: 1.6
2602  */
2603 GstParentBufferMeta *
2604 gst_buffer_add_parent_buffer_meta (GstBuffer * buffer, GstBuffer * ref)
2605 {
2606   GstParentBufferMeta *meta;
2607 
2608   g_return_val_if_fail (GST_IS_BUFFER (ref), NULL);
2609 
2610   meta =
2611       (GstParentBufferMeta *) gst_buffer_add_meta (buffer,
2612       GST_PARENT_BUFFER_META_INFO, NULL);
2613 
2614   if (!meta)
2615     return NULL;
2616 
2617   meta-&gt;buffer = gst_buffer_ref (ref);
2618 
2619   return meta;
2620 }
2621 
2622 static gboolean
2623 _gst_parent_buffer_meta_transform (GstBuffer * dest, GstMeta * meta,
2624     GstBuffer * buffer, GQuark type, gpointer data)
2625 {
2626   GstParentBufferMeta *dmeta, *smeta;
2627 
2628   smeta = (GstParentBufferMeta *) meta;
2629 
2630   if (GST_META_TRANSFORM_IS_COPY (type)) {
2631     /* copy over the reference to the parent buffer.
2632      * Usually, this meta means we need to keep the parent buffer
2633      * alive because one of the child memories is in use, which
2634      * might not be the case if memory is deep copied or sub-regioned,
2635      * but we can&#39;t tell, so keep the meta */
2636     dmeta = gst_buffer_add_parent_buffer_meta (dest, smeta-&gt;buffer);
2637     if (!dmeta)
2638       return FALSE;
2639 
2640     GST_CAT_DEBUG (gst_parent_buffer_meta_debug,
2641         &quot;copy buffer reference metadata&quot;);
2642   } else {
2643     /* return FALSE, if transform type is not supported */
2644     return FALSE;
2645   }
2646   return TRUE;
2647 }
2648 
2649 static void
2650 _gst_parent_buffer_meta_free (GstParentBufferMeta * parent_meta,
2651     GstBuffer * buffer)
2652 {
2653   GST_CAT_DEBUG (gst_parent_buffer_meta_debug,
2654       &quot;Dropping reference on buffer %p&quot;, parent_meta-&gt;buffer);
2655   gst_buffer_unref (parent_meta-&gt;buffer);
2656 }
2657 
2658 static gboolean
2659 _gst_parent_buffer_meta_init (GstParentBufferMeta * parent_meta,
2660     gpointer params, GstBuffer * buffer)
2661 {
2662   static volatile gsize _init;
2663 
2664   if (g_once_init_enter (&amp;_init)) {
2665     GST_DEBUG_CATEGORY_INIT (gst_parent_buffer_meta_debug, &quot;parentbuffermeta&quot;,
2666         0, &quot;parentbuffermeta&quot;);
2667     g_once_init_leave (&amp;_init, 1);
2668   }
2669 
2670   parent_meta-&gt;buffer = NULL;
2671 
2672   return TRUE;
2673 }
2674 
2675 GType
2676 gst_parent_buffer_meta_api_get_type (void)
2677 {
2678   static volatile GType type = 0;
2679   static const gchar *tags[] = { NULL };
2680 
2681   if (g_once_init_enter (&amp;type)) {
2682     GType _type = gst_meta_api_type_register (&quot;GstParentBufferMetaAPI&quot;, tags);
2683     g_once_init_leave (&amp;type, _type);
2684   }
2685 
2686   return type;
2687 }
2688 
2689 /**
2690  * gst_parent_buffer_meta_get_info:
2691  *
2692  * Get the global #GstMetaInfo describing  the #GstParentBufferMeta meta.
2693  *
2694  * Returns: (transfer none): The #GstMetaInfo
2695  *
2696  * Since: 1.6
2697  */
2698 const GstMetaInfo *
2699 gst_parent_buffer_meta_get_info (void)
2700 {
2701   static const GstMetaInfo *meta_info = NULL;
2702 
2703   if (g_once_init_enter ((GstMetaInfo **) &amp; meta_info)) {
2704     const GstMetaInfo *meta =
2705         gst_meta_register (gst_parent_buffer_meta_api_get_type (),
2706         &quot;GstParentBufferMeta&quot;,
2707         sizeof (GstParentBufferMeta),
2708         (GstMetaInitFunction) _gst_parent_buffer_meta_init,
2709         (GstMetaFreeFunction) _gst_parent_buffer_meta_free,
2710         _gst_parent_buffer_meta_transform);
2711     g_once_init_leave ((GstMetaInfo **) &amp; meta_info, (GstMetaInfo *) meta);
2712   }
2713 
2714   return meta_info;
2715 }
2716 
2717 GST_DEBUG_CATEGORY_STATIC (gst_reference_timestamp_meta_debug);
2718 
2719 /**
2720  * gst_buffer_add_reference_timestamp_meta:
2721  * @buffer: (transfer none): a #GstBuffer
2722  * @reference: (transfer none): identifier for the timestamp reference.
2723  * @timestamp: timestamp
2724  * @duration: duration, or %GST_CLOCK_TIME_NONE
2725  *
2726  * Add a #GstReferenceTimestampMeta to @buffer that holds a @timestamp and
2727  * optionally @duration based on a specific timestamp @reference. See the
2728  * documentation of #GstReferenceTimestampMeta for details.
2729  *
2730  * Returns: (transfer none) (nullable): The #GstReferenceTimestampMeta that was added to the buffer
2731  *
2732  * Since: 1.14
2733  */
2734 GstReferenceTimestampMeta *
2735 gst_buffer_add_reference_timestamp_meta (GstBuffer * buffer,
2736     GstCaps * reference, GstClockTime timestamp, GstClockTime duration)
2737 {
2738   GstReferenceTimestampMeta *meta;
2739 
2740   g_return_val_if_fail (GST_IS_CAPS (reference), NULL);
2741   g_return_val_if_fail (timestamp != GST_CLOCK_TIME_NONE, NULL);
2742 
2743   meta =
2744       (GstReferenceTimestampMeta *) gst_buffer_add_meta (buffer,
2745       GST_REFERENCE_TIMESTAMP_META_INFO, NULL);
2746 
2747   if (!meta)
2748     return NULL;
2749 
2750   meta-&gt;reference = gst_caps_ref (reference);
2751   meta-&gt;timestamp = timestamp;
2752   meta-&gt;duration = duration;
2753 
2754   return meta;
2755 }
2756 
2757 /**
2758  * gst_buffer_get_reference_timestamp_meta:
2759  * @buffer: a #GstBuffer
2760  * @reference: (allow-none): a reference #GstCaps
2761  *
2762  * Find the first #GstReferenceTimestampMeta on @buffer that conforms to
2763  * @reference. Conformance is tested by checking if the meta&#39;s reference is a
2764  * subset of @reference.
2765  *
2766  * Buffers can contain multiple #GstReferenceTimestampMeta metadata items.
2767  *
2768  * Returns: (transfer none) (nullable): the #GstReferenceTimestampMeta or %NULL when there
2769  * is no such metadata on @buffer.
2770  *
2771  * Since: 1.14
2772  */
2773 GstReferenceTimestampMeta *
2774 gst_buffer_get_reference_timestamp_meta (GstBuffer * buffer,
2775     GstCaps * reference)
2776 {
2777   gpointer state = NULL;
2778   GstMeta *meta;
2779   const GstMetaInfo *info = GST_REFERENCE_TIMESTAMP_META_INFO;
2780 
2781   while ((meta = gst_buffer_iterate_meta (buffer, &amp;state))) {
2782     if (meta-&gt;info-&gt;api == info-&gt;api) {
2783       GstReferenceTimestampMeta *rmeta = (GstReferenceTimestampMeta *) meta;
2784 
2785       if (!reference)
2786         return rmeta;
2787       if (gst_caps_is_subset (rmeta-&gt;reference, reference))
2788         return rmeta;
2789     }
2790   }
2791   return NULL;
2792 }
2793 
2794 static gboolean
2795 _gst_reference_timestamp_meta_transform (GstBuffer * dest, GstMeta * meta,
2796     GstBuffer * buffer, GQuark type, gpointer data)
2797 {
2798   GstReferenceTimestampMeta *dmeta, *smeta;
2799 
2800   /* we copy over the reference timestamp meta, independent of transformation
2801    * that happens. If it applied to the original buffer, it still applies to
2802    * the new buffer as it refers to the time when the media was captured */
2803   smeta = (GstReferenceTimestampMeta *) meta;
2804   dmeta =
2805       gst_buffer_add_reference_timestamp_meta (dest, smeta-&gt;reference,
2806       smeta-&gt;timestamp, smeta-&gt;duration);
2807   if (!dmeta)
2808     return FALSE;
2809 
2810   GST_CAT_DEBUG (gst_reference_timestamp_meta_debug,
2811       &quot;copy reference timestamp metadata from buffer %p to %p&quot;, buffer, dest);
2812 
2813   return TRUE;
2814 }
2815 
2816 static void
2817 _gst_reference_timestamp_meta_free (GstReferenceTimestampMeta * meta,
2818     GstBuffer * buffer)
2819 {
2820   if (meta-&gt;reference)
2821     gst_caps_unref (meta-&gt;reference);
2822 }
2823 
2824 static gboolean
2825 _gst_reference_timestamp_meta_init (GstReferenceTimestampMeta * meta,
2826     gpointer params, GstBuffer * buffer)
2827 {
2828   static volatile gsize _init;
2829 
2830   if (g_once_init_enter (&amp;_init)) {
2831     GST_DEBUG_CATEGORY_INIT (gst_reference_timestamp_meta_debug,
2832         &quot;referencetimestampmeta&quot;, 0, &quot;referencetimestampmeta&quot;);
2833     g_once_init_leave (&amp;_init, 1);
2834   }
2835 
2836   meta-&gt;reference = NULL;
2837   meta-&gt;timestamp = GST_CLOCK_TIME_NONE;
2838   meta-&gt;duration = GST_CLOCK_TIME_NONE;
2839 
2840   return TRUE;
2841 }
2842 
2843 GType
2844 gst_reference_timestamp_meta_api_get_type (void)
2845 {
2846   static volatile GType type = 0;
2847   static const gchar *tags[] = { NULL };
2848 
2849   if (g_once_init_enter (&amp;type)) {
2850     GType _type =
2851         gst_meta_api_type_register (&quot;GstReferenceTimestampMetaAPI&quot;, tags);
2852     g_once_init_leave (&amp;type, _type);
2853   }
2854 
2855   return type;
2856 }
2857 
2858 /**
2859  * gst_reference_timestamp_meta_get_info:
2860  *
2861  * Get the global #GstMetaInfo describing  the #GstReferenceTimestampMeta meta.
2862  *
2863  * Returns: (transfer none): The #GstMetaInfo
2864  *
2865  * Since: 1.14
2866  */
2867 const GstMetaInfo *
2868 gst_reference_timestamp_meta_get_info (void)
2869 {
2870   static const GstMetaInfo *meta_info = NULL;
2871 
2872   if (g_once_init_enter ((GstMetaInfo **) &amp; meta_info)) {
2873     const GstMetaInfo *meta =
2874         gst_meta_register (gst_reference_timestamp_meta_api_get_type (),
2875         &quot;GstReferenceTimestampMeta&quot;,
2876         sizeof (GstReferenceTimestampMeta),
2877         (GstMetaInitFunction) _gst_reference_timestamp_meta_init,
2878         (GstMetaFreeFunction) _gst_reference_timestamp_meta_free,
2879         _gst_reference_timestamp_meta_transform);
2880     g_once_init_leave ((GstMetaInfo **) &amp; meta_info, (GstMetaInfo *) meta);
2881   }
2882 
2883   return meta_info;
2884 }
    </pre>
  </body>
</html>