<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstbasesink.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstbaseparse.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstbasesink.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstbasesink.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 135  * information can then be used by upstream elements to reduce their processing
 136  * rate, for example.
 137  *
 138  * The #GstBaseSink:async property can be used to instruct the sink to never
 139  * perform an ASYNC state change. This feature is mostly usable when dealing
 140  * with non-synchronized streams or sparse streams.
 141  */
 142 
 143 #ifdef HAVE_CONFIG_H
 144 #  include &quot;config.h&quot;
 145 #endif
 146 
 147 #include &lt;gst/gst_private.h&gt;
 148 
 149 #include &quot;gstbasesink.h&quot;
 150 #include &lt;gst/gst-i18n-lib.h&gt;
 151 
 152 GST_DEBUG_CATEGORY_STATIC (gst_base_sink_debug);
 153 #define GST_CAT_DEFAULT gst_base_sink_debug
 154 
<span class="line-removed"> 155 #define GST_BASE_SINK_GET_PRIVATE(obj)  \</span>
<span class="line-removed"> 156    (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_BASE_SINK, GstBaseSinkPrivate))</span>
<span class="line-removed"> 157 </span>
 158 #define GST_FLOW_STEP GST_FLOW_CUSTOM_ERROR
 159 
 160 typedef struct
 161 {
 162   gboolean valid;               /* if this info is valid */
 163   guint32 seqnum;               /* the seqnum of the STEP event */
 164   GstFormat format;             /* the format of the amount */
 165   guint64 amount;               /* the total amount of data to skip */
 166   guint64 position;             /* the position in the stepped data */
 167   guint64 duration;             /* the duration in time of the skipped data */
 168   guint64 start;                /* running_time of the start */
 169   gdouble rate;                 /* rate of skipping */
 170   gdouble start_rate;           /* rate before skipping */
 171   guint64 start_start;          /* start position skipping */
 172   guint64 start_stop;           /* stop position skipping */
 173   gboolean flush;               /* if this was a flushing step */
 174   gboolean intermediate;        /* if this is an intermediate step */
 175   gboolean need_preroll;        /* if we need preroll after this step */
 176 } GstStepInfo;
 177 
 178 struct _GstBaseSinkPrivate
 179 {
 180   gint qos_enabled;             /* ATOMIC */
 181   gboolean async_enabled;
 182   GstClockTimeDiff ts_offset;
 183   GstClockTime render_delay;

 184 
 185   /* start, stop of current buffer, stream time, used to report position */
 186   GstClockTime current_sstart;
 187   GstClockTime current_sstop;
 188 
 189   /* start, stop and jitter of current buffer, running time */
 190   GstClockTime current_rstart;
 191   GstClockTime current_rstop;
 192   GstClockTimeDiff current_jitter;
 193   /* the running time of the previous buffer */
 194   GstClockTime prev_rstart;
 195 
 196   /* EOS sync time in running time */
 197   GstClockTime eos_rtime;
 198 
 199   /* last buffer that arrived in time, running time */
 200   GstClockTime last_render_time;
 201   /* when the last buffer left the sink, running time */
 202   GstClockTime last_left;
 203 
 204   /* running averages go here these are done on running time */
 205   GstClockTime avg_pt, avg_in_diff;
 206   gdouble avg_rate;             /* average with infinite window */
 207 
 208   /* number of rendered and dropped frames */
 209   guint64 rendered;
 210   guint64 dropped;
 211 
 212   /* latency stuff */
 213   GstClockTime latency;
 214 
<span class="line-modified"> 215   /* if we already commited the state */</span>
<span class="line-modified"> 216   gboolean commited;</span>
 217   /* state change to playing ongoing */
 218   gboolean to_playing;
 219 
 220   /* when we received EOS */
 221   gboolean received_eos;
 222 
 223   /* when we are prerolled and able to report latency */
 224   gboolean have_latency;
 225 
 226   /* the last buffer we prerolled or rendered. Useful for making snapshots */
 227   gint enable_last_sample;      /* atomic */
 228   GstBuffer *last_buffer;
 229   GstCaps *last_caps;
 230   GstBufferList *last_buffer_list;
 231 
 232   /* negotiated caps */
 233   GstCaps *caps;
 234 
 235   /* blocksize for pulling */
 236   guint blocksize;
</pre>
<hr />
<pre>
 273  * window so we can react faster to badness. */
 274 #define UPDATE_RUNNING_AVG_P(avg,val) DO_RUNNING_AVG(avg,val,16)
 275 #define UPDATE_RUNNING_AVG_N(avg,val) DO_RUNNING_AVG(avg,val,4)
 276 
 277 /* BaseSink properties */
 278 
 279 #define DEFAULT_CAN_ACTIVATE_PULL FALSE /* fixme: enable me */
 280 #define DEFAULT_CAN_ACTIVATE_PUSH TRUE
 281 
 282 #define DEFAULT_SYNC                TRUE
 283 #define DEFAULT_MAX_LATENESS        -1
 284 #define DEFAULT_QOS                 FALSE
 285 #define DEFAULT_ASYNC               TRUE
 286 #define DEFAULT_TS_OFFSET           0
 287 #define DEFAULT_BLOCKSIZE           4096
 288 #define DEFAULT_RENDER_DELAY        0
 289 #define DEFAULT_ENABLE_LAST_SAMPLE  TRUE
 290 #define DEFAULT_THROTTLE_TIME       0
 291 #define DEFAULT_MAX_BITRATE         0
 292 #define DEFAULT_DROP_OUT_OF_SEGMENT TRUE

 293 
 294 enum
 295 {
 296   PROP_0,
 297   PROP_SYNC,
 298   PROP_MAX_LATENESS,
 299   PROP_QOS,
 300   PROP_ASYNC,
 301   PROP_TS_OFFSET,
 302   PROP_ENABLE_LAST_SAMPLE,
 303   PROP_LAST_SAMPLE,
 304   PROP_BLOCKSIZE,
 305   PROP_RENDER_DELAY,
 306   PROP_THROTTLE_TIME,
 307   PROP_MAX_BITRATE,

 308   PROP_LAST
 309 };
 310 
 311 static GstElementClass *parent_class = NULL;

 312 
 313 static void gst_base_sink_class_init (GstBaseSinkClass * klass);
 314 static void gst_base_sink_init (GstBaseSink * trans, gpointer g_class);
 315 static void gst_base_sink_finalize (GObject * object);
 316 
 317 GType
 318 gst_base_sink_get_type (void)
 319 {
 320   static volatile gsize base_sink_type = 0;
 321 
 322   if (g_once_init_enter (&amp;base_sink_type)) {
 323     GType _type;
 324     static const GTypeInfo base_sink_info = {
 325       sizeof (GstBaseSinkClass),
 326       NULL,
 327       NULL,
 328       (GClassInitFunc) gst_base_sink_class_init,
 329       NULL,
 330       NULL,
 331       sizeof (GstBaseSink),
 332       0,
 333       (GInstanceInitFunc) gst_base_sink_init,
 334     };
 335 
 336     _type = g_type_register_static (GST_TYPE_ELEMENT,
 337         &quot;GstBaseSink&quot;, &amp;base_sink_info, G_TYPE_FLAG_ABSTRACT);




 338     g_once_init_leave (&amp;base_sink_type, _type);
 339   }
 340   return base_sink_type;
 341 }
 342 






 343 static void gst_base_sink_set_property (GObject * object, guint prop_id,
 344     const GValue * value, GParamSpec * pspec);
 345 static void gst_base_sink_get_property (GObject * object, guint prop_id,
 346     GValue * value, GParamSpec * pspec);
 347 
 348 static gboolean gst_base_sink_send_event (GstElement * element,
 349     GstEvent * event);
 350 static gboolean default_element_query (GstElement * element, GstQuery * query);
 351 
 352 static GstCaps *gst_base_sink_default_get_caps (GstBaseSink * sink,
 353     GstCaps * caps);
 354 static gboolean gst_base_sink_default_set_caps (GstBaseSink * sink,
 355     GstCaps * caps);
 356 static void gst_base_sink_default_get_times (GstBaseSink * basesink,
 357     GstBuffer * buffer, GstClockTime * start, GstClockTime * end);
 358 static gboolean gst_base_sink_set_flushing (GstBaseSink * basesink,
 359     GstPad * pad, gboolean flushing);
 360 static gboolean gst_base_sink_default_activate_pull (GstBaseSink * basesink,
 361     gboolean active);
 362 static gboolean gst_base_sink_default_do_seek (GstBaseSink * sink,
</pre>
<hr />
<pre>
 390 
 391 static gboolean gst_base_sink_negotiate_pull (GstBaseSink * basesink);
 392 static GstCaps *gst_base_sink_default_fixate (GstBaseSink * bsink,
 393     GstCaps * caps);
 394 static GstCaps *gst_base_sink_fixate (GstBaseSink * bsink, GstCaps * caps);
 395 
 396 /* check if an object was too late */
 397 static gboolean gst_base_sink_is_too_late (GstBaseSink * basesink,
 398     GstMiniObject * obj, GstClockTime rstart, GstClockTime rstop,
 399     GstClockReturn status, GstClockTimeDiff jitter, gboolean render);
 400 
 401 static void
 402 gst_base_sink_class_init (GstBaseSinkClass * klass)
 403 {
 404   GObjectClass *gobject_class;
 405   GstElementClass *gstelement_class;
 406 
 407   gobject_class = G_OBJECT_CLASS (klass);
 408   gstelement_class = GST_ELEMENT_CLASS (klass);
 409 



 410   GST_DEBUG_CATEGORY_INIT (gst_base_sink_debug, &quot;basesink&quot;, 0,
 411       &quot;basesink element&quot;);
 412 
<span class="line-removed"> 413   g_type_class_add_private (klass, sizeof (GstBaseSinkPrivate));</span>
<span class="line-removed"> 414 </span>
 415   parent_class = g_type_class_peek_parent (klass);
 416 
 417   gobject_class-&gt;finalize = gst_base_sink_finalize;
 418   gobject_class-&gt;set_property = gst_base_sink_set_property;
 419   gobject_class-&gt;get_property = gst_base_sink_get_property;
 420 
 421   g_object_class_install_property (gobject_class, PROP_SYNC,
 422       g_param_spec_boolean (&quot;sync&quot;, &quot;Sync&quot;, &quot;Sync on the clock&quot;, DEFAULT_SYNC,
 423           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 424 
 425   g_object_class_install_property (gobject_class, PROP_MAX_LATENESS,
 426       g_param_spec_int64 (&quot;max-lateness&quot;, &quot;Max Lateness&quot;,
 427           &quot;Maximum number of nanoseconds that a buffer can be late before it &quot;
 428           &quot;is dropped (-1 unlimited)&quot;, -1, G_MAXINT64, DEFAULT_MAX_LATENESS,
 429           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 430 
 431   g_object_class_install_property (gobject_class, PROP_QOS,
 432       g_param_spec_boolean (&quot;qos&quot;, &quot;Qos&quot;,
 433           &quot;Generate Quality-of-Service events upstream&quot;, DEFAULT_QOS,
 434           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
</pre>
<hr />
<pre>
 510    */
 511   g_object_class_install_property (gobject_class, PROP_THROTTLE_TIME,
 512       g_param_spec_uint64 (&quot;throttle-time&quot;, &quot;Throttle time&quot;,
 513           &quot;The time to keep between rendered buffers (0 = disabled)&quot;, 0,
 514           G_MAXUINT64, DEFAULT_THROTTLE_TIME,
 515           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 516   /**
 517    * GstBaseSink:max-bitrate:
 518    *
 519    * Control the maximum amount of bits that will be rendered per second.
 520    * Setting this property to a value bigger than 0 will make the sink delay
 521    * rendering of the buffers when it would exceed to max-bitrate.
 522    *
 523    * Since: 1.2
 524    */
 525   g_object_class_install_property (gobject_class, PROP_MAX_BITRATE,
 526       g_param_spec_uint64 (&quot;max-bitrate&quot;, &quot;Max Bitrate&quot;,
 527           &quot;The maximum bits per second to render (0 = disabled)&quot;, 0,
 528           G_MAXUINT64, DEFAULT_MAX_BITRATE,
 529           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));














 530 
 531   gstelement_class-&gt;change_state =
 532       GST_DEBUG_FUNCPTR (gst_base_sink_change_state);
 533   gstelement_class-&gt;send_event = GST_DEBUG_FUNCPTR (gst_base_sink_send_event);
 534   gstelement_class-&gt;query = GST_DEBUG_FUNCPTR (default_element_query);
 535 
 536   klass-&gt;get_caps = GST_DEBUG_FUNCPTR (gst_base_sink_default_get_caps);
 537   klass-&gt;set_caps = GST_DEBUG_FUNCPTR (gst_base_sink_default_set_caps);
 538   klass-&gt;fixate = GST_DEBUG_FUNCPTR (gst_base_sink_default_fixate);
 539   klass-&gt;activate_pull =
 540       GST_DEBUG_FUNCPTR (gst_base_sink_default_activate_pull);
 541   klass-&gt;get_times = GST_DEBUG_FUNCPTR (gst_base_sink_default_get_times);
 542   klass-&gt;query = GST_DEBUG_FUNCPTR (gst_base_sink_default_query);
 543   klass-&gt;event = GST_DEBUG_FUNCPTR (gst_base_sink_default_event);
 544   klass-&gt;wait_event = GST_DEBUG_FUNCPTR (gst_base_sink_default_wait_event);
 545 
 546   /* Registering debug symbols for function pointers */
 547   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_fixate);
 548   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_pad_activate);
 549   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_pad_activate_mode);
</pre>
<hr />
<pre>
 605 
 606 static GstCaps *
 607 gst_base_sink_fixate (GstBaseSink * bsink, GstCaps * caps)
 608 {
 609   GstBaseSinkClass *bclass;
 610 
 611   bclass = GST_BASE_SINK_GET_CLASS (bsink);
 612 
 613   if (bclass-&gt;fixate)
 614     caps = bclass-&gt;fixate (bsink, caps);
 615 
 616   return caps;
 617 }
 618 
 619 static void
 620 gst_base_sink_init (GstBaseSink * basesink, gpointer g_class)
 621 {
 622   GstPadTemplate *pad_template;
 623   GstBaseSinkPrivate *priv;
 624 
<span class="line-modified"> 625   basesink-&gt;priv = priv = GST_BASE_SINK_GET_PRIVATE (basesink);</span>
 626 
 627   pad_template =
 628       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (g_class), &quot;sink&quot;);
 629   g_return_if_fail (pad_template != NULL);
 630 
 631   basesink-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 632 
 633   gst_pad_set_activate_function (basesink-&gt;sinkpad, gst_base_sink_pad_activate);
 634   gst_pad_set_activatemode_function (basesink-&gt;sinkpad,
 635       gst_base_sink_pad_activate_mode);
 636   gst_pad_set_query_function (basesink-&gt;sinkpad, gst_base_sink_sink_query);
 637   gst_pad_set_event_function (basesink-&gt;sinkpad, gst_base_sink_event);
 638   gst_pad_set_chain_function (basesink-&gt;sinkpad, gst_base_sink_chain);
 639   gst_pad_set_chain_list_function (basesink-&gt;sinkpad, gst_base_sink_chain_list);
 640   gst_element_add_pad (GST_ELEMENT_CAST (basesink), basesink-&gt;sinkpad);
 641 
 642   basesink-&gt;pad_mode = GST_PAD_MODE_NONE;
 643   g_mutex_init (&amp;basesink-&gt;preroll_lock);
 644   g_cond_init (&amp;basesink-&gt;preroll_cond);
 645   priv-&gt;have_latency = FALSE;
 646 
 647   basesink-&gt;can_activate_push = DEFAULT_CAN_ACTIVATE_PUSH;
 648   basesink-&gt;can_activate_pull = DEFAULT_CAN_ACTIVATE_PULL;
 649 
 650   basesink-&gt;sync = DEFAULT_SYNC;
 651   basesink-&gt;max_lateness = DEFAULT_MAX_LATENESS;
 652   g_atomic_int_set (&amp;priv-&gt;qos_enabled, DEFAULT_QOS);
 653   priv-&gt;async_enabled = DEFAULT_ASYNC;
 654   priv-&gt;ts_offset = DEFAULT_TS_OFFSET;
 655   priv-&gt;render_delay = DEFAULT_RENDER_DELAY;

 656   priv-&gt;blocksize = DEFAULT_BLOCKSIZE;
 657   priv-&gt;cached_clock_id = NULL;
 658   g_atomic_int_set (&amp;priv-&gt;enable_last_sample, DEFAULT_ENABLE_LAST_SAMPLE);
 659   priv-&gt;throttle_time = DEFAULT_THROTTLE_TIME;
 660   priv-&gt;max_bitrate = DEFAULT_MAX_BITRATE;
 661 
 662   priv-&gt;drop_out_of_segment = DEFAULT_DROP_OUT_OF_SEGMENT;
 663 
 664   GST_OBJECT_FLAG_SET (basesink, GST_ELEMENT_FLAG_SINK);
 665 }
 666 
 667 static void
 668 gst_base_sink_finalize (GObject * object)
 669 {
 670   GstBaseSink *basesink;
 671 
 672   basesink = GST_BASE_SINK (object);
 673 
 674   g_mutex_clear (&amp;basesink-&gt;preroll_lock);
 675   g_cond_clear (&amp;basesink-&gt;preroll_cond);
</pre>
<hr />
<pre>
 717   GST_OBJECT_LOCK (sink);
 718   res = sink-&gt;sync;
 719   GST_OBJECT_UNLOCK (sink);
 720 
 721   return res;
 722 }
 723 
 724 /**
 725  * gst_base_sink_set_drop_out_of_segment:
 726  * @sink: the sink
 727  * @drop_out_of_segment: drop buffers outside the segment
 728  *
 729  * Configure @sink to drop buffers which are outside the current segment
 730  *
 731  * Since: 1.12
 732  */
 733 void
 734 gst_base_sink_set_drop_out_of_segment (GstBaseSink * sink,
 735     gboolean drop_out_of_segment)
 736 {
<span class="line-removed"> 737   GstBaseSinkPrivate *priv;</span>
<span class="line-removed"> 738 </span>
 739   g_return_if_fail (GST_IS_BASE_SINK (sink));
 740 
<span class="line-removed"> 741   priv = GST_BASE_SINK_GET_PRIVATE (sink);</span>
<span class="line-removed"> 742 </span>
 743   GST_OBJECT_LOCK (sink);
<span class="line-modified"> 744   priv-&gt;drop_out_of_segment = drop_out_of_segment;</span>
 745   GST_OBJECT_UNLOCK (sink);
 746 
 747 }
 748 
 749 /**
 750  * gst_base_sink_get_drop_out_of_segment:
 751  * @sink: the sink
 752  *
 753  * Checks if @sink is currently configured to drop buffers which are outside
 754  * the current segment
 755  *
 756  * Returns: %TRUE if the sink is configured to drop buffers outside the
 757  * current segment.
 758  *
 759  * Since: 1.12
 760  */
 761 gboolean
 762 gst_base_sink_get_drop_out_of_segment (GstBaseSink * sink)
 763 {
<span class="line-removed"> 764   GstBaseSinkPrivate *priv;</span>
 765   gboolean res;
 766 
 767   g_return_val_if_fail (GST_IS_BASE_SINK (sink), FALSE);
 768 
<span class="line-removed"> 769   priv = GST_BASE_SINK_GET_PRIVATE (sink);</span>
<span class="line-removed"> 770 </span>
 771   GST_OBJECT_LOCK (sink);
<span class="line-modified"> 772   res = priv-&gt;drop_out_of_segment;</span>
 773   GST_OBJECT_UNLOCK (sink);
 774 
 775   return res;
 776 }
 777 
 778 /**
 779  * gst_base_sink_set_max_lateness:
 780  * @sink: the sink
 781  * @max_lateness: the new max lateness value.
 782  *
 783  * Sets the new max lateness value to @max_lateness. This value is
 784  * used to decide if a buffer should be dropped or not based on the
 785  * buffer timestamp and the current clock time. A value of -1 means
 786  * an unlimited time.
 787  */
 788 void
 789 gst_base_sink_set_max_lateness (GstBaseSink * sink, gint64 max_lateness)
 790 {
 791   g_return_if_fail (GST_IS_BASE_SINK (sink));
 792 
</pre>
<hr />
<pre>
1131  *
1132  * Query the sink for the latency parameters. The latency will be queried from
1133  * the upstream elements. @live will be %TRUE if @sink is configured to
1134  * synchronize against the clock. @upstream_live will be %TRUE if an upstream
1135  * element is live.
1136  *
1137  * If both @live and @upstream_live are %TRUE, the sink will want to compensate
1138  * for the latency introduced by the upstream elements by setting the
1139  * @min_latency to a strictly positive value.
1140  *
1141  * This function is mostly used by subclasses.
1142  *
1143  * Returns: %TRUE if the query succeeded.
1144  */
1145 gboolean
1146 gst_base_sink_query_latency (GstBaseSink * sink, gboolean * live,
1147     gboolean * upstream_live, GstClockTime * min_latency,
1148     GstClockTime * max_latency)
1149 {
1150   gboolean l, us_live, res, have_latency;
<span class="line-modified">1151   GstClockTime min, max, render_delay;</span>
1152   GstQuery *query;
1153   GstClockTime us_min, us_max;
1154 
1155   /* we are live when we sync to the clock */
1156   GST_OBJECT_LOCK (sink);
1157   l = sink-&gt;sync;
1158   have_latency = sink-&gt;priv-&gt;have_latency;
1159   render_delay = sink-&gt;priv-&gt;render_delay;

1160   GST_OBJECT_UNLOCK (sink);
1161 
1162   /* assume no latency */
1163   min = 0;
1164   max = -1;
1165   us_live = FALSE;
1166 
1167   if (have_latency) {
1168     GST_DEBUG_OBJECT (sink, &quot;we are ready for LATENCY query&quot;);
1169     /* we are ready for a latency query this is when we preroll or when we are
1170      * not async. */
1171     query = gst_query_new_latency ();
1172 
1173     /* ask the peer for the latency */
1174     if ((res = gst_pad_peer_query (sink-&gt;sinkpad, query))) {
1175       /* get upstream min and max latency */
1176       gst_query_parse_latency (query, &amp;us_live, &amp;us_min, &amp;us_max);
1177 
1178       if (us_live) {
1179         /* upstream live, use its latency, subclasses should use these
1180          * values to create the complete latency. */
1181         min = us_min;
1182         max = us_max;


















1183       }
1184       if (l) {
1185         /* we need to add the render delay if we are live */
1186         min += render_delay;
1187         if (max != -1)
1188           max += render_delay;
1189       }
1190     }
1191     gst_query_unref (query);
1192   } else {
1193     GST_DEBUG_OBJECT (sink, &quot;we are not yet ready for LATENCY query&quot;);
1194     res = FALSE;
1195   }
1196 
1197   /* not live, we tried to do the query, if it failed we return TRUE anyway */
1198   if (!res) {
1199     if (!l) {
1200       res = TRUE;
1201       GST_DEBUG_OBJECT (sink, &quot;latency query failed but we are not live&quot;);
1202     } else {
</pre>
<hr />
<pre>
1394  * Get the maximum amount of bits per second that the sink will render.
1395  *
1396  * Returns: the maximum number of bits per second @sink will render.
1397  *
1398  * Since: 1.2
1399  */
1400 guint64
1401 gst_base_sink_get_max_bitrate (GstBaseSink * sink)
1402 {
1403   guint64 res;
1404 
1405   g_return_val_if_fail (GST_IS_BASE_SINK (sink), 0);
1406 
1407   GST_OBJECT_LOCK (sink);
1408   res = sink-&gt;priv-&gt;max_bitrate;
1409   GST_OBJECT_UNLOCK (sink);
1410 
1411   return res;
1412 }
1413 





























































1414 static void
1415 gst_base_sink_set_property (GObject * object, guint prop_id,
1416     const GValue * value, GParamSpec * pspec)
1417 {
1418   GstBaseSink *sink = GST_BASE_SINK (object);
1419 
1420   switch (prop_id) {
1421     case PROP_SYNC:
1422       gst_base_sink_set_sync (sink, g_value_get_boolean (value));
1423       break;
1424     case PROP_MAX_LATENESS:
1425       gst_base_sink_set_max_lateness (sink, g_value_get_int64 (value));
1426       break;
1427     case PROP_QOS:
1428       gst_base_sink_set_qos_enabled (sink, g_value_get_boolean (value));
1429       break;
1430     case PROP_ASYNC:
1431       gst_base_sink_set_async_enabled (sink, g_value_get_boolean (value));
1432       break;
1433     case PROP_TS_OFFSET:
1434       gst_base_sink_set_ts_offset (sink, g_value_get_int64 (value));
1435       break;
1436     case PROP_BLOCKSIZE:
1437       gst_base_sink_set_blocksize (sink, g_value_get_uint (value));
1438       break;
1439     case PROP_RENDER_DELAY:
1440       gst_base_sink_set_render_delay (sink, g_value_get_uint64 (value));
1441       break;
1442     case PROP_ENABLE_LAST_SAMPLE:
1443       gst_base_sink_set_last_sample_enabled (sink, g_value_get_boolean (value));
1444       break;
1445     case PROP_THROTTLE_TIME:
1446       gst_base_sink_set_throttle_time (sink, g_value_get_uint64 (value));
1447       break;
1448     case PROP_MAX_BITRATE:
1449       gst_base_sink_set_max_bitrate (sink, g_value_get_uint64 (value));
1450       break;



1451     default:
1452       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
1453       break;
1454   }
1455 }
1456 
1457 static void
1458 gst_base_sink_get_property (GObject * object, guint prop_id, GValue * value,
1459     GParamSpec * pspec)
1460 {
1461   GstBaseSink *sink = GST_BASE_SINK (object);
1462 
1463   switch (prop_id) {
1464     case PROP_SYNC:
1465       g_value_set_boolean (value, gst_base_sink_get_sync (sink));
1466       break;
1467     case PROP_MAX_LATENESS:
1468       g_value_set_int64 (value, gst_base_sink_get_max_lateness (sink));
1469       break;
1470     case PROP_QOS:
</pre>
<hr />
<pre>
1477       g_value_set_int64 (value, gst_base_sink_get_ts_offset (sink));
1478       break;
1479     case PROP_LAST_SAMPLE:
1480       gst_value_take_sample (value, gst_base_sink_get_last_sample (sink));
1481       break;
1482     case PROP_ENABLE_LAST_SAMPLE:
1483       g_value_set_boolean (value, gst_base_sink_is_last_sample_enabled (sink));
1484       break;
1485     case PROP_BLOCKSIZE:
1486       g_value_set_uint (value, gst_base_sink_get_blocksize (sink));
1487       break;
1488     case PROP_RENDER_DELAY:
1489       g_value_set_uint64 (value, gst_base_sink_get_render_delay (sink));
1490       break;
1491     case PROP_THROTTLE_TIME:
1492       g_value_set_uint64 (value, gst_base_sink_get_throttle_time (sink));
1493       break;
1494     case PROP_MAX_BITRATE:
1495       g_value_set_uint64 (value, gst_base_sink_get_max_bitrate (sink));
1496       break;



1497     default:
1498       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
1499       break;
1500   }
1501 }
1502 
1503 
1504 static GstCaps *
1505 gst_base_sink_default_get_caps (GstBaseSink * sink, GstCaps * filter)
1506 {
1507   return NULL;
1508 }
1509 
1510 static gboolean
1511 gst_base_sink_default_set_caps (GstBaseSink * sink, GstCaps * caps)
1512 {
1513   return TRUE;
1514 }
1515 
1516 /* with PREROLL_LOCK, STREAM_LOCK */
</pre>
<hr />
<pre>
1518 gst_base_sink_commit_state (GstBaseSink * basesink)
1519 {
1520   /* commit state and proceed to next pending state */
1521   GstState current, next, pending, post_pending;
1522   gboolean post_paused = FALSE;
1523   gboolean post_async_done = FALSE;
1524   gboolean post_playing = FALSE;
1525 
1526   /* we are certainly not playing async anymore now */
1527   basesink-&gt;playing_async = FALSE;
1528 
1529   GST_OBJECT_LOCK (basesink);
1530   current = GST_STATE (basesink);
1531   next = GST_STATE_NEXT (basesink);
1532   pending = GST_STATE_PENDING (basesink);
1533   post_pending = pending;
1534 
1535   switch (pending) {
1536     case GST_STATE_PLAYING:
1537     {
<span class="line-modified">1538       GST_DEBUG_OBJECT (basesink, &quot;commiting state to PLAYING&quot;);</span>
1539 
1540       basesink-&gt;need_preroll = FALSE;
1541       post_async_done = TRUE;
<span class="line-modified">1542       basesink-&gt;priv-&gt;commited = TRUE;</span>
1543       post_playing = TRUE;
1544       /* post PAUSED too when we were READY */
1545       if (current == GST_STATE_READY) {
1546         post_paused = TRUE;
1547       }
1548       break;
1549     }
1550     case GST_STATE_PAUSED:
<span class="line-modified">1551       GST_DEBUG_OBJECT (basesink, &quot;commiting state to PAUSED&quot;);</span>
1552       post_paused = TRUE;
1553       post_async_done = TRUE;
<span class="line-modified">1554       basesink-&gt;priv-&gt;commited = TRUE;</span>
1555       post_pending = GST_STATE_VOID_PENDING;
1556       break;
1557     case GST_STATE_READY:
1558     case GST_STATE_NULL:
1559       goto stopping;
1560     case GST_STATE_VOID_PENDING:
1561       goto nothing_pending;
1562     default:
1563       break;
1564   }
1565 
1566   /* we can report latency queries now */
1567   basesink-&gt;priv-&gt;have_latency = TRUE;
1568 
1569   GST_STATE (basesink) = pending;
1570   GST_STATE_NEXT (basesink) = GST_STATE_VOID_PENDING;
1571   GST_STATE_PENDING (basesink) = GST_STATE_VOID_PENDING;
1572   GST_STATE_RETURN (basesink) = GST_STATE_CHANGE_SUCCESS;
1573   GST_OBJECT_UNLOCK (basesink);
1574 
</pre>
<hr />
<pre>
2163 
2164   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (time)))
2165     goto invalid_time;
2166 
2167   GST_OBJECT_LOCK (sink);
2168   if (G_UNLIKELY (!sink-&gt;sync))
2169     goto no_sync;
2170 
2171   if (G_UNLIKELY ((clock = GST_ELEMENT_CLOCK (sink)) == NULL))
2172     goto no_clock;
2173 
2174   base_time = GST_ELEMENT_CAST (sink)-&gt;base_time;
2175   GST_LOG_OBJECT (sink,
2176       &quot;time %&quot; GST_TIME_FORMAT &quot;, base_time %&quot; GST_TIME_FORMAT,
2177       GST_TIME_ARGS (time), GST_TIME_ARGS (base_time));
2178 
2179   /* add base_time to running_time to get the time against the clock */
2180   time += base_time;
2181 
2182   /* Re-use existing clockid if available */
<span class="line-removed">2183   /* FIXME: Casting to GstClockEntry only works because the types</span>
<span class="line-removed">2184    * are the same */</span>
2185   if (G_LIKELY (sink-&gt;priv-&gt;cached_clock_id != NULL
<span class="line-modified">2186           &amp;&amp; GST_CLOCK_ENTRY_CLOCK ((GstClockEntry *) sink-&gt;</span>
<span class="line-removed">2187               priv-&gt;cached_clock_id) == clock)) {</span>
2188     if (!gst_clock_single_shot_id_reinit (clock, sink-&gt;priv-&gt;cached_clock_id,
2189             time)) {
2190       gst_clock_id_unref (sink-&gt;priv-&gt;cached_clock_id);
2191       sink-&gt;priv-&gt;cached_clock_id = gst_clock_new_single_shot_id (clock, time);
2192     }
2193   } else {
2194     if (sink-&gt;priv-&gt;cached_clock_id != NULL)
2195       gst_clock_id_unref (sink-&gt;priv-&gt;cached_clock_id);
2196     sink-&gt;priv-&gt;cached_clock_id = gst_clock_new_single_shot_id (clock, time);
2197   }
2198   GST_OBJECT_UNLOCK (sink);
2199 
2200   /* A blocking wait is performed on the clock. We save the ClockID
2201    * so we can unlock the entry at any time. While we are blocking, we
2202    * release the PREROLL_LOCK so that other threads can interrupt the
2203    * entry. */
2204   sink-&gt;clock_id = sink-&gt;priv-&gt;cached_clock_id;
2205   /* release the preroll lock while waiting */
2206   GST_BASE_SINK_PREROLL_UNLOCK (sink);
2207 
</pre>
<hr />
<pre>
2363         goto preroll_failed;
2364     }
2365   }
2366   return GST_FLOW_OK;
2367 
2368   /* ERRORS */
2369 prepare_canceled:
2370   {
2371     GST_DEBUG_OBJECT (sink, &quot;prepare failed, abort state&quot;);
2372     gst_element_abort_state (GST_ELEMENT_CAST (sink));
2373     return ret;
2374   }
2375 preroll_canceled:
2376   {
2377     GST_DEBUG_OBJECT (sink, &quot;preroll failed, abort state&quot;);
2378     gst_element_abort_state (GST_ELEMENT_CAST (sink));
2379     return ret;
2380   }
2381 stopping:
2382   {
<span class="line-modified">2383     GST_DEBUG_OBJECT (sink, &quot;stopping while commiting state&quot;);</span>
2384     return GST_FLOW_FLUSHING;
2385   }
2386 preroll_failed:
2387   {
2388     GST_DEBUG_OBJECT (sink, &quot;preroll failed: %s&quot;, gst_flow_get_name (ret));
2389     return ret;
2390   }
2391 }
2392 
2393 /**
2394  * gst_base_sink_wait:
2395  * @sink: the sink
2396  * @time: the running_time to be reached
2397  * @jitter: (out) (allow-none): the jitter to be filled with time diff, or %NULL
2398  *
2399  * This function will wait for preroll to complete and will then block until @time
2400  * is reached. It is usually called by subclasses that use their own internal
2401  * synchronisation but want to let some synchronization (like EOS) be handled
2402  * by the base class.
2403  *
</pre>
<hr />
<pre>
2434         GST_TIME_FORMAT, GST_TIME_ARGS (time));
2435 
2436     /* compensate for latency, ts_offset and render delay */
2437     stime = gst_base_sink_adjust_time (sink, time);
2438 
2439     /* wait for the clock, this can be interrupted because we got shut down or
2440      * we PAUSED. */
2441     status = gst_base_sink_wait_clock (sink, stime, jitter);
2442 
2443     GST_DEBUG_OBJECT (sink, &quot;clock returned %d&quot;, status);
2444 
2445     /* invalid time, no clock or sync disabled, just continue then */
2446     if (status == GST_CLOCK_BADTIME)
2447       break;
2448 
2449     /* waiting could have been interrupted and we can be flushing now */
2450     if (G_UNLIKELY (sink-&gt;flushing))
2451       goto flushing;
2452 
2453     /* retry if we got unscheduled, which means we did not reach the timeout
<span class="line-modified">2454      * yet. if some other error occures, we continue. */</span>
2455   } while (status == GST_CLOCK_UNSCHEDULED);
2456 
2457   GST_DEBUG_OBJECT (sink, &quot;end of stream&quot;);
2458 
2459   return GST_FLOW_OK;
2460 
2461   /* ERRORS */
2462 flushing:
2463   {
2464     GST_DEBUG_OBJECT (sink, &quot;we are flushing&quot;);
2465     return GST_FLOW_FLUSHING;
2466   }
2467 }
2468 
2469 /* with STREAM_LOCK, PREROLL_LOCK
2470  *
2471  * Make sure we are in PLAYING and synchronize an object to the clock.
2472  *
2473  * If we need preroll, we are not in PLAYING. We try to commit the state
2474  * if needed and then block if we still are not PLAYING.
</pre>
<hr />
<pre>
3404     GST_OBJECT_UNLOCK (basesink);
3405   }
3406 
3407   bclass = GST_BASE_SINK_GET_CLASS (basesink);
3408 
3409   /* check if the buffer needs to be dropped, we first ask the subclass for the
3410    * start and end */
3411   if (bclass-&gt;get_times)
3412     bclass-&gt;get_times (basesink, sync_buf, &amp;start, &amp;end);
3413 
3414   if (!GST_CLOCK_TIME_IS_VALID (start)) {
3415     /* if the subclass does not want sync, we use our own values so that we at
3416      * least clip the buffer to the segment */
3417     gst_base_sink_default_get_times (basesink, sync_buf, &amp;start, &amp;end);
3418   }
3419 
3420   GST_DEBUG_OBJECT (basesink, &quot;got times start: %&quot; GST_TIME_FORMAT
3421       &quot;, end: %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (start), GST_TIME_ARGS (end));
3422 
3423   /* a dropped buffer does not participate in anything. Buffer can only be
<span class="line-modified">3424    * dropped if their PTS falls completly outside the segment, while we sync</span>
3425    * preferably on DTS */
3426   if (GST_CLOCK_TIME_IS_VALID (start) &amp;&amp; (segment-&gt;format == GST_FORMAT_TIME)) {
3427     GstClockTime pts = GST_BUFFER_PTS (sync_buf);
3428     GstClockTime pts_end = GST_CLOCK_TIME_NONE;
3429 
3430     if (!GST_CLOCK_TIME_IS_VALID (pts))
3431       pts = start;
3432 
3433     if (GST_CLOCK_TIME_IS_VALID (end))
3434       pts_end = pts + (end - start);
3435 
3436     if (G_UNLIKELY (!gst_segment_clip (segment,
3437                 GST_FORMAT_TIME, pts, pts_end, NULL, NULL)
3438             &amp;&amp; priv-&gt;drop_out_of_segment))
3439       goto out_of_segment;
3440   }
3441 
3442   if (bclass-&gt;prepare || bclass-&gt;prepare_list) {
3443     gboolean do_sync = TRUE, stepped = FALSE, syncable = TRUE;
3444     GstClockTime sstart, sstop, rstart, rstop, rnext;
</pre>
<hr />
<pre>
4202   GstQuery *query;
4203   gboolean pull_mode;
4204 
4205   basesink = GST_BASE_SINK (parent);
4206 
4207   GST_DEBUG_OBJECT (basesink, &quot;Trying pull mode first&quot;);
4208 
4209   gst_base_sink_set_flushing (basesink, pad, FALSE);
4210 
4211   /* we need to have the pull mode enabled */
4212   if (!basesink-&gt;can_activate_pull) {
4213     GST_DEBUG_OBJECT (basesink, &quot;pull mode disabled&quot;);
4214     goto fallback;
4215   }
4216 
4217   /* check if downstreams supports pull mode at all */
4218   query = gst_query_new_scheduling ();
4219 
4220   if (!gst_pad_peer_query (pad, query)) {
4221     gst_query_unref (query);
<span class="line-modified">4222     GST_DEBUG_OBJECT (basesink, &quot;peer query faild, no pull mode&quot;);</span>
4223     goto fallback;
4224   }
4225 
4226   /* parse result of the query */
4227   pull_mode = gst_query_has_scheduling_mode (query, GST_PAD_MODE_PULL);
4228   gst_query_unref (query);
4229 
4230   if (!pull_mode) {
4231     GST_DEBUG_OBJECT (basesink, &quot;pull mode not supported&quot;);
4232     goto fallback;
4233   }
4234 
4235   /* set the pad mode before starting the task so that it&#39;s in the
4236    * correct state for the new thread. also the sink set_caps and get_caps
4237    * function checks this */
4238   basesink-&gt;pad_mode = GST_PAD_MODE_PULL;
4239 
4240   /* we first try to negotiate a format so that when we try to activate
4241    * downstream, it knows about our format */
4242   if (!gst_base_sink_negotiate_pull (basesink)) {
</pre>
<hr />
<pre>
5061     case GST_STATE_CHANGE_READY_TO_PAUSED:
5062       /* need to complete preroll before this state change completes, there
5063        * is no data flow in READY so we can safely assume we need to preroll. */
5064       GST_BASE_SINK_PREROLL_LOCK (basesink);
5065       GST_DEBUG_OBJECT (basesink, &quot;READY to PAUSED&quot;);
5066       basesink-&gt;have_newsegment = FALSE;
5067       gst_segment_init (&amp;basesink-&gt;segment, GST_FORMAT_UNDEFINED);
5068       basesink-&gt;offset = 0;
5069       basesink-&gt;have_preroll = FALSE;
5070       priv-&gt;step_unlock = FALSE;
5071       basesink-&gt;need_preroll = TRUE;
5072       basesink-&gt;playing_async = TRUE;
5073       priv-&gt;current_sstart = GST_CLOCK_TIME_NONE;
5074       priv-&gt;current_sstop = GST_CLOCK_TIME_NONE;
5075       priv-&gt;eos_rtime = GST_CLOCK_TIME_NONE;
5076       priv-&gt;latency = 0;
5077       basesink-&gt;eos = FALSE;
5078       priv-&gt;received_eos = FALSE;
5079       gst_base_sink_reset_qos (basesink);
5080       priv-&gt;rc_next = -1;
<span class="line-modified">5081       priv-&gt;commited = FALSE;</span>
5082       priv-&gt;call_preroll = TRUE;
5083       priv-&gt;current_step.valid = FALSE;
5084       priv-&gt;pending_step.valid = FALSE;
5085       if (priv-&gt;async_enabled) {
5086         GST_DEBUG_OBJECT (basesink, &quot;doing async state change&quot;);
5087         /* when async enabled, post async-start message and return ASYNC from
5088          * the state change function */
5089         ret = GST_STATE_CHANGE_ASYNC;
5090         gst_element_post_message (GST_ELEMENT_CAST (basesink),
5091             gst_message_new_async_start (GST_OBJECT_CAST (basesink)));
5092       } else {
5093         priv-&gt;have_latency = TRUE;
5094       }
5095       GST_BASE_SINK_PREROLL_UNLOCK (basesink);
5096       break;
5097     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
5098       GST_BASE_SINK_PREROLL_LOCK (basesink);
5099       g_atomic_int_set (&amp;basesink-&gt;priv-&gt;to_playing, TRUE);
5100       if (!gst_base_sink_needs_preroll (basesink)) {
5101         GST_DEBUG_OBJECT (basesink, &quot;PAUSED to PLAYING, don&#39;t need preroll&quot;);
5102         /* no preroll needed anymore now. */
5103         basesink-&gt;playing_async = FALSE;
5104         basesink-&gt;need_preroll = FALSE;
5105         if (basesink-&gt;eos) {
5106           GstMessage *message;
5107 
5108           /* need to post EOS message here */
5109           GST_DEBUG_OBJECT (basesink, &quot;Now posting EOS&quot;);
5110           message = gst_message_new_eos (GST_OBJECT_CAST (basesink));
5111           gst_message_set_seqnum (message, basesink-&gt;priv-&gt;seqnum);
5112           gst_element_post_message (GST_ELEMENT_CAST (basesink), message);
5113         } else {
5114           GST_DEBUG_OBJECT (basesink, &quot;signal preroll&quot;);
5115           GST_BASE_SINK_PREROLL_SIGNAL (basesink);
5116         }
5117       } else {
5118         GST_DEBUG_OBJECT (basesink, &quot;PAUSED to PLAYING, we are not prerolled&quot;);
5119         basesink-&gt;need_preroll = TRUE;
5120         basesink-&gt;playing_async = TRUE;
5121         priv-&gt;call_preroll = TRUE;
<span class="line-modified">5122         priv-&gt;commited = FALSE;</span>
5123         if (priv-&gt;async_enabled) {
5124           GST_DEBUG_OBJECT (basesink, &quot;doing async state change&quot;);
5125           ret = GST_STATE_CHANGE_ASYNC;
5126           gst_element_post_message (GST_ELEMENT_CAST (basesink),
5127               gst_message_new_async_start (GST_OBJECT_CAST (basesink)));
5128         }
5129       }
5130       GST_BASE_SINK_PREROLL_UNLOCK (basesink);
5131       break;
5132     default:
5133       break;
5134   }
5135 
5136   {
5137     GstStateChangeReturn bret;
5138 
5139     bret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
5140     if (G_UNLIKELY (bret == GST_STATE_CHANGE_FAILURE))
5141       goto activate_failed;
5142   }
</pre>
<hr />
<pre>
5167       if (basesink-&gt;clock_id) {
5168         GST_DEBUG_OBJECT (basesink, &quot;unschedule clock&quot;);
5169         gst_clock_id_unschedule (basesink-&gt;clock_id);
5170       }
5171 
5172       /* if we don&#39;t have a preroll buffer we need to wait for a preroll and
5173        * return ASYNC. */
5174       if (!gst_base_sink_needs_preroll (basesink)) {
5175         GST_DEBUG_OBJECT (basesink, &quot;PLAYING to PAUSED, we are prerolled&quot;);
5176         basesink-&gt;playing_async = FALSE;
5177         basesink-&gt;need_preroll = FALSE;
5178       } else {
5179         if (GST_STATE_TARGET (GST_ELEMENT (basesink)) &lt;= GST_STATE_READY) {
5180           GST_DEBUG_OBJECT (basesink, &quot;element is &lt;= READY&quot;);
5181           ret = GST_STATE_CHANGE_SUCCESS;
5182         } else {
5183           GST_DEBUG_OBJECT (basesink,
5184               &quot;PLAYING to PAUSED, we are not prerolled&quot;);
5185           basesink-&gt;playing_async = TRUE;
5186           basesink-&gt;need_preroll = TRUE;
<span class="line-modified">5187           priv-&gt;commited = FALSE;</span>
5188           priv-&gt;call_preroll = TRUE;
5189           if (priv-&gt;async_enabled) {
5190             GST_DEBUG_OBJECT (basesink, &quot;doing async state change&quot;);
5191             ret = GST_STATE_CHANGE_ASYNC;
5192             gst_element_post_message (GST_ELEMENT_CAST (basesink),
5193                 gst_message_new_async_start (GST_OBJECT_CAST (basesink)));
5194           }
5195         }
5196       }
5197       GST_DEBUG_OBJECT (basesink, &quot;rendered: %&quot; G_GUINT64_FORMAT
5198           &quot;, dropped: %&quot; G_GUINT64_FORMAT, priv-&gt;rendered, priv-&gt;dropped);
5199 
5200       gst_base_sink_reset_qos (basesink);
5201       GST_BASE_SINK_PREROLL_UNLOCK (basesink);
5202       break;
5203     case GST_STATE_CHANGE_PAUSED_TO_READY:
5204       GST_BASE_SINK_PREROLL_LOCK (basesink);
5205       /* start by resetting our position state with the object lock so that the
5206        * position query gets the right idea. We do this before we post the
5207        * messages so that the message handlers pick this up. */
5208       GST_OBJECT_LOCK (basesink);
5209       basesink-&gt;have_newsegment = FALSE;
5210       priv-&gt;current_sstart = GST_CLOCK_TIME_NONE;
5211       priv-&gt;current_sstop = GST_CLOCK_TIME_NONE;
5212       priv-&gt;have_latency = FALSE;
5213       if (priv-&gt;cached_clock_id) {
5214         gst_clock_id_unref (priv-&gt;cached_clock_id);
5215         priv-&gt;cached_clock_id = NULL;
5216       }
5217       gst_caps_replace (&amp;basesink-&gt;priv-&gt;caps, NULL);
5218       GST_OBJECT_UNLOCK (basesink);
5219 
5220       gst_base_sink_set_last_buffer (basesink, NULL);
5221       gst_base_sink_set_last_buffer_list (basesink, NULL);
5222       priv-&gt;call_preroll = FALSE;
5223 
<span class="line-modified">5224       if (!priv-&gt;commited) {</span>
5225         if (priv-&gt;async_enabled) {
5226           GST_DEBUG_OBJECT (basesink, &quot;PAUSED to READY, posting async-done&quot;);
5227 
5228           gst_element_post_message (GST_ELEMENT_CAST (basesink),
5229               gst_message_new_state_changed (GST_OBJECT_CAST (basesink),
5230                   GST_STATE_PLAYING, GST_STATE_PAUSED, GST_STATE_READY));
5231 
5232           gst_element_post_message (GST_ELEMENT_CAST (basesink),
5233               gst_message_new_async_done (GST_OBJECT_CAST (basesink),
5234                   GST_CLOCK_TIME_NONE));
5235         }
<span class="line-modified">5236         priv-&gt;commited = TRUE;</span>
5237       } else {
5238         GST_DEBUG_OBJECT (basesink, &quot;PAUSED to READY, don&#39;t need_preroll&quot;);
5239       }
5240       GST_BASE_SINK_PREROLL_UNLOCK (basesink);
5241       break;
5242     case GST_STATE_CHANGE_READY_TO_NULL:
5243       if (bclass-&gt;stop) {
5244         if (!bclass-&gt;stop (basesink)) {
5245           GST_WARNING_OBJECT (basesink, &quot;failed to stop&quot;);
5246         }
5247       }
5248       gst_base_sink_set_last_buffer (basesink, NULL);
5249       gst_base_sink_set_last_buffer_list (basesink, NULL);
5250       priv-&gt;call_preroll = FALSE;
5251       break;
5252     default:
5253       break;
5254   }
5255 
5256   return ret;
</pre>
</td>
<td>
<hr />
<pre>
 135  * information can then be used by upstream elements to reduce their processing
 136  * rate, for example.
 137  *
 138  * The #GstBaseSink:async property can be used to instruct the sink to never
 139  * perform an ASYNC state change. This feature is mostly usable when dealing
 140  * with non-synchronized streams or sparse streams.
 141  */
 142 
 143 #ifdef HAVE_CONFIG_H
 144 #  include &quot;config.h&quot;
 145 #endif
 146 
 147 #include &lt;gst/gst_private.h&gt;
 148 
 149 #include &quot;gstbasesink.h&quot;
 150 #include &lt;gst/gst-i18n-lib.h&gt;
 151 
 152 GST_DEBUG_CATEGORY_STATIC (gst_base_sink_debug);
 153 #define GST_CAT_DEFAULT gst_base_sink_debug
 154 



 155 #define GST_FLOW_STEP GST_FLOW_CUSTOM_ERROR
 156 
 157 typedef struct
 158 {
 159   gboolean valid;               /* if this info is valid */
 160   guint32 seqnum;               /* the seqnum of the STEP event */
 161   GstFormat format;             /* the format of the amount */
 162   guint64 amount;               /* the total amount of data to skip */
 163   guint64 position;             /* the position in the stepped data */
 164   guint64 duration;             /* the duration in time of the skipped data */
 165   guint64 start;                /* running_time of the start */
 166   gdouble rate;                 /* rate of skipping */
 167   gdouble start_rate;           /* rate before skipping */
 168   guint64 start_start;          /* start position skipping */
 169   guint64 start_stop;           /* stop position skipping */
 170   gboolean flush;               /* if this was a flushing step */
 171   gboolean intermediate;        /* if this is an intermediate step */
 172   gboolean need_preroll;        /* if we need preroll after this step */
 173 } GstStepInfo;
 174 
 175 struct _GstBaseSinkPrivate
 176 {
 177   gint qos_enabled;             /* ATOMIC */
 178   gboolean async_enabled;
 179   GstClockTimeDiff ts_offset;
 180   GstClockTime render_delay;
<span class="line-added"> 181   GstClockTime processing_deadline;</span>
 182 
 183   /* start, stop of current buffer, stream time, used to report position */
 184   GstClockTime current_sstart;
 185   GstClockTime current_sstop;
 186 
 187   /* start, stop and jitter of current buffer, running time */
 188   GstClockTime current_rstart;
 189   GstClockTime current_rstop;
 190   GstClockTimeDiff current_jitter;
 191   /* the running time of the previous buffer */
 192   GstClockTime prev_rstart;
 193 
 194   /* EOS sync time in running time */
 195   GstClockTime eos_rtime;
 196 
 197   /* last buffer that arrived in time, running time */
 198   GstClockTime last_render_time;
 199   /* when the last buffer left the sink, running time */
 200   GstClockTime last_left;
 201 
 202   /* running averages go here these are done on running time */
 203   GstClockTime avg_pt, avg_in_diff;
 204   gdouble avg_rate;             /* average with infinite window */
 205 
 206   /* number of rendered and dropped frames */
 207   guint64 rendered;
 208   guint64 dropped;
 209 
 210   /* latency stuff */
 211   GstClockTime latency;
 212 
<span class="line-modified"> 213   /* if we already committed the state */</span>
<span class="line-modified"> 214   gboolean committed;</span>
 215   /* state change to playing ongoing */
 216   gboolean to_playing;
 217 
 218   /* when we received EOS */
 219   gboolean received_eos;
 220 
 221   /* when we are prerolled and able to report latency */
 222   gboolean have_latency;
 223 
 224   /* the last buffer we prerolled or rendered. Useful for making snapshots */
 225   gint enable_last_sample;      /* atomic */
 226   GstBuffer *last_buffer;
 227   GstCaps *last_caps;
 228   GstBufferList *last_buffer_list;
 229 
 230   /* negotiated caps */
 231   GstCaps *caps;
 232 
 233   /* blocksize for pulling */
 234   guint blocksize;
</pre>
<hr />
<pre>
 271  * window so we can react faster to badness. */
 272 #define UPDATE_RUNNING_AVG_P(avg,val) DO_RUNNING_AVG(avg,val,16)
 273 #define UPDATE_RUNNING_AVG_N(avg,val) DO_RUNNING_AVG(avg,val,4)
 274 
 275 /* BaseSink properties */
 276 
 277 #define DEFAULT_CAN_ACTIVATE_PULL FALSE /* fixme: enable me */
 278 #define DEFAULT_CAN_ACTIVATE_PUSH TRUE
 279 
 280 #define DEFAULT_SYNC                TRUE
 281 #define DEFAULT_MAX_LATENESS        -1
 282 #define DEFAULT_QOS                 FALSE
 283 #define DEFAULT_ASYNC               TRUE
 284 #define DEFAULT_TS_OFFSET           0
 285 #define DEFAULT_BLOCKSIZE           4096
 286 #define DEFAULT_RENDER_DELAY        0
 287 #define DEFAULT_ENABLE_LAST_SAMPLE  TRUE
 288 #define DEFAULT_THROTTLE_TIME       0
 289 #define DEFAULT_MAX_BITRATE         0
 290 #define DEFAULT_DROP_OUT_OF_SEGMENT TRUE
<span class="line-added"> 291 #define DEFAULT_PROCESSING_DEADLINE (20 * GST_MSECOND)</span>
 292 
 293 enum
 294 {
 295   PROP_0,
 296   PROP_SYNC,
 297   PROP_MAX_LATENESS,
 298   PROP_QOS,
 299   PROP_ASYNC,
 300   PROP_TS_OFFSET,
 301   PROP_ENABLE_LAST_SAMPLE,
 302   PROP_LAST_SAMPLE,
 303   PROP_BLOCKSIZE,
 304   PROP_RENDER_DELAY,
 305   PROP_THROTTLE_TIME,
 306   PROP_MAX_BITRATE,
<span class="line-added"> 307   PROP_PROCESSING_DEADLINE,</span>
 308   PROP_LAST
 309 };
 310 
 311 static GstElementClass *parent_class = NULL;
<span class="line-added"> 312 static gint private_offset = 0;</span>
 313 
 314 static void gst_base_sink_class_init (GstBaseSinkClass * klass);
 315 static void gst_base_sink_init (GstBaseSink * trans, gpointer g_class);
 316 static void gst_base_sink_finalize (GObject * object);
 317 
 318 GType
 319 gst_base_sink_get_type (void)
 320 {
 321   static volatile gsize base_sink_type = 0;
 322 
 323   if (g_once_init_enter (&amp;base_sink_type)) {
 324     GType _type;
 325     static const GTypeInfo base_sink_info = {
 326       sizeof (GstBaseSinkClass),
 327       NULL,
 328       NULL,
 329       (GClassInitFunc) gst_base_sink_class_init,
 330       NULL,
 331       NULL,
 332       sizeof (GstBaseSink),
 333       0,
 334       (GInstanceInitFunc) gst_base_sink_init,
 335     };
 336 
 337     _type = g_type_register_static (GST_TYPE_ELEMENT,
 338         &quot;GstBaseSink&quot;, &amp;base_sink_info, G_TYPE_FLAG_ABSTRACT);
<span class="line-added"> 339 </span>
<span class="line-added"> 340     private_offset =</span>
<span class="line-added"> 341         g_type_add_instance_private (_type, sizeof (GstBaseSinkPrivate));</span>
<span class="line-added"> 342 </span>
 343     g_once_init_leave (&amp;base_sink_type, _type);
 344   }
 345   return base_sink_type;
 346 }
 347 
<span class="line-added"> 348 static inline GstBaseSinkPrivate *</span>
<span class="line-added"> 349 gst_base_sink_get_instance_private (GstBaseSink * self)</span>
<span class="line-added"> 350 {</span>
<span class="line-added"> 351   return (G_STRUCT_MEMBER_P (self, private_offset));</span>
<span class="line-added"> 352 }</span>
<span class="line-added"> 353 </span>
 354 static void gst_base_sink_set_property (GObject * object, guint prop_id,
 355     const GValue * value, GParamSpec * pspec);
 356 static void gst_base_sink_get_property (GObject * object, guint prop_id,
 357     GValue * value, GParamSpec * pspec);
 358 
 359 static gboolean gst_base_sink_send_event (GstElement * element,
 360     GstEvent * event);
 361 static gboolean default_element_query (GstElement * element, GstQuery * query);
 362 
 363 static GstCaps *gst_base_sink_default_get_caps (GstBaseSink * sink,
 364     GstCaps * caps);
 365 static gboolean gst_base_sink_default_set_caps (GstBaseSink * sink,
 366     GstCaps * caps);
 367 static void gst_base_sink_default_get_times (GstBaseSink * basesink,
 368     GstBuffer * buffer, GstClockTime * start, GstClockTime * end);
 369 static gboolean gst_base_sink_set_flushing (GstBaseSink * basesink,
 370     GstPad * pad, gboolean flushing);
 371 static gboolean gst_base_sink_default_activate_pull (GstBaseSink * basesink,
 372     gboolean active);
 373 static gboolean gst_base_sink_default_do_seek (GstBaseSink * sink,
</pre>
<hr />
<pre>
 401 
 402 static gboolean gst_base_sink_negotiate_pull (GstBaseSink * basesink);
 403 static GstCaps *gst_base_sink_default_fixate (GstBaseSink * bsink,
 404     GstCaps * caps);
 405 static GstCaps *gst_base_sink_fixate (GstBaseSink * bsink, GstCaps * caps);
 406 
 407 /* check if an object was too late */
 408 static gboolean gst_base_sink_is_too_late (GstBaseSink * basesink,
 409     GstMiniObject * obj, GstClockTime rstart, GstClockTime rstop,
 410     GstClockReturn status, GstClockTimeDiff jitter, gboolean render);
 411 
 412 static void
 413 gst_base_sink_class_init (GstBaseSinkClass * klass)
 414 {
 415   GObjectClass *gobject_class;
 416   GstElementClass *gstelement_class;
 417 
 418   gobject_class = G_OBJECT_CLASS (klass);
 419   gstelement_class = GST_ELEMENT_CLASS (klass);
 420 
<span class="line-added"> 421   if (private_offset != 0)</span>
<span class="line-added"> 422     g_type_class_adjust_private_offset (klass, &amp;private_offset);</span>
<span class="line-added"> 423 </span>
 424   GST_DEBUG_CATEGORY_INIT (gst_base_sink_debug, &quot;basesink&quot;, 0,
 425       &quot;basesink element&quot;);
 426 


 427   parent_class = g_type_class_peek_parent (klass);
 428 
 429   gobject_class-&gt;finalize = gst_base_sink_finalize;
 430   gobject_class-&gt;set_property = gst_base_sink_set_property;
 431   gobject_class-&gt;get_property = gst_base_sink_get_property;
 432 
 433   g_object_class_install_property (gobject_class, PROP_SYNC,
 434       g_param_spec_boolean (&quot;sync&quot;, &quot;Sync&quot;, &quot;Sync on the clock&quot;, DEFAULT_SYNC,
 435           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 436 
 437   g_object_class_install_property (gobject_class, PROP_MAX_LATENESS,
 438       g_param_spec_int64 (&quot;max-lateness&quot;, &quot;Max Lateness&quot;,
 439           &quot;Maximum number of nanoseconds that a buffer can be late before it &quot;
 440           &quot;is dropped (-1 unlimited)&quot;, -1, G_MAXINT64, DEFAULT_MAX_LATENESS,
 441           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 442 
 443   g_object_class_install_property (gobject_class, PROP_QOS,
 444       g_param_spec_boolean (&quot;qos&quot;, &quot;Qos&quot;,
 445           &quot;Generate Quality-of-Service events upstream&quot;, DEFAULT_QOS,
 446           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
</pre>
<hr />
<pre>
 522    */
 523   g_object_class_install_property (gobject_class, PROP_THROTTLE_TIME,
 524       g_param_spec_uint64 (&quot;throttle-time&quot;, &quot;Throttle time&quot;,
 525           &quot;The time to keep between rendered buffers (0 = disabled)&quot;, 0,
 526           G_MAXUINT64, DEFAULT_THROTTLE_TIME,
 527           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 528   /**
 529    * GstBaseSink:max-bitrate:
 530    *
 531    * Control the maximum amount of bits that will be rendered per second.
 532    * Setting this property to a value bigger than 0 will make the sink delay
 533    * rendering of the buffers when it would exceed to max-bitrate.
 534    *
 535    * Since: 1.2
 536    */
 537   g_object_class_install_property (gobject_class, PROP_MAX_BITRATE,
 538       g_param_spec_uint64 (&quot;max-bitrate&quot;, &quot;Max Bitrate&quot;,
 539           &quot;The maximum bits per second to render (0 = disabled)&quot;, 0,
 540           G_MAXUINT64, DEFAULT_MAX_BITRATE,
 541           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
<span class="line-added"> 542   /**</span>
<span class="line-added"> 543    * GstBaseSink:processing-deadline:</span>
<span class="line-added"> 544    *</span>
<span class="line-added"> 545    * Maximum amount of time (in nanoseconds) that the pipeline can take</span>
<span class="line-added"> 546    * for processing the buffer. This is added to the latency of live</span>
<span class="line-added"> 547    * pipelines.</span>
<span class="line-added"> 548    *</span>
<span class="line-added"> 549    * Since: 1.16</span>
<span class="line-added"> 550    */</span>
<span class="line-added"> 551   g_object_class_install_property (gobject_class, PROP_PROCESSING_DEADLINE,</span>
<span class="line-added"> 552       g_param_spec_uint64 (&quot;processing-deadline&quot;, &quot;Processing deadline&quot;,</span>
<span class="line-added"> 553           &quot;Maximum processing deadline in nanoseconds&quot;, 0, G_MAXUINT64,</span>
<span class="line-added"> 554           DEFAULT_PROCESSING_DEADLINE,</span>
<span class="line-added"> 555           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));</span>
 556 
 557   gstelement_class-&gt;change_state =
 558       GST_DEBUG_FUNCPTR (gst_base_sink_change_state);
 559   gstelement_class-&gt;send_event = GST_DEBUG_FUNCPTR (gst_base_sink_send_event);
 560   gstelement_class-&gt;query = GST_DEBUG_FUNCPTR (default_element_query);
 561 
 562   klass-&gt;get_caps = GST_DEBUG_FUNCPTR (gst_base_sink_default_get_caps);
 563   klass-&gt;set_caps = GST_DEBUG_FUNCPTR (gst_base_sink_default_set_caps);
 564   klass-&gt;fixate = GST_DEBUG_FUNCPTR (gst_base_sink_default_fixate);
 565   klass-&gt;activate_pull =
 566       GST_DEBUG_FUNCPTR (gst_base_sink_default_activate_pull);
 567   klass-&gt;get_times = GST_DEBUG_FUNCPTR (gst_base_sink_default_get_times);
 568   klass-&gt;query = GST_DEBUG_FUNCPTR (gst_base_sink_default_query);
 569   klass-&gt;event = GST_DEBUG_FUNCPTR (gst_base_sink_default_event);
 570   klass-&gt;wait_event = GST_DEBUG_FUNCPTR (gst_base_sink_default_wait_event);
 571 
 572   /* Registering debug symbols for function pointers */
 573   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_fixate);
 574   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_pad_activate);
 575   GST_DEBUG_REGISTER_FUNCPTR (gst_base_sink_pad_activate_mode);
</pre>
<hr />
<pre>
 631 
 632 static GstCaps *
 633 gst_base_sink_fixate (GstBaseSink * bsink, GstCaps * caps)
 634 {
 635   GstBaseSinkClass *bclass;
 636 
 637   bclass = GST_BASE_SINK_GET_CLASS (bsink);
 638 
 639   if (bclass-&gt;fixate)
 640     caps = bclass-&gt;fixate (bsink, caps);
 641 
 642   return caps;
 643 }
 644 
 645 static void
 646 gst_base_sink_init (GstBaseSink * basesink, gpointer g_class)
 647 {
 648   GstPadTemplate *pad_template;
 649   GstBaseSinkPrivate *priv;
 650 
<span class="line-modified"> 651   basesink-&gt;priv = priv = gst_base_sink_get_instance_private (basesink);</span>
 652 
 653   pad_template =
 654       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (g_class), &quot;sink&quot;);
 655   g_return_if_fail (pad_template != NULL);
 656 
 657   basesink-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 658 
 659   gst_pad_set_activate_function (basesink-&gt;sinkpad, gst_base_sink_pad_activate);
 660   gst_pad_set_activatemode_function (basesink-&gt;sinkpad,
 661       gst_base_sink_pad_activate_mode);
 662   gst_pad_set_query_function (basesink-&gt;sinkpad, gst_base_sink_sink_query);
 663   gst_pad_set_event_function (basesink-&gt;sinkpad, gst_base_sink_event);
 664   gst_pad_set_chain_function (basesink-&gt;sinkpad, gst_base_sink_chain);
 665   gst_pad_set_chain_list_function (basesink-&gt;sinkpad, gst_base_sink_chain_list);
 666   gst_element_add_pad (GST_ELEMENT_CAST (basesink), basesink-&gt;sinkpad);
 667 
 668   basesink-&gt;pad_mode = GST_PAD_MODE_NONE;
 669   g_mutex_init (&amp;basesink-&gt;preroll_lock);
 670   g_cond_init (&amp;basesink-&gt;preroll_cond);
 671   priv-&gt;have_latency = FALSE;
 672 
 673   basesink-&gt;can_activate_push = DEFAULT_CAN_ACTIVATE_PUSH;
 674   basesink-&gt;can_activate_pull = DEFAULT_CAN_ACTIVATE_PULL;
 675 
 676   basesink-&gt;sync = DEFAULT_SYNC;
 677   basesink-&gt;max_lateness = DEFAULT_MAX_LATENESS;
 678   g_atomic_int_set (&amp;priv-&gt;qos_enabled, DEFAULT_QOS);
 679   priv-&gt;async_enabled = DEFAULT_ASYNC;
 680   priv-&gt;ts_offset = DEFAULT_TS_OFFSET;
 681   priv-&gt;render_delay = DEFAULT_RENDER_DELAY;
<span class="line-added"> 682   priv-&gt;processing_deadline = DEFAULT_PROCESSING_DEADLINE;</span>
 683   priv-&gt;blocksize = DEFAULT_BLOCKSIZE;
 684   priv-&gt;cached_clock_id = NULL;
 685   g_atomic_int_set (&amp;priv-&gt;enable_last_sample, DEFAULT_ENABLE_LAST_SAMPLE);
 686   priv-&gt;throttle_time = DEFAULT_THROTTLE_TIME;
 687   priv-&gt;max_bitrate = DEFAULT_MAX_BITRATE;
 688 
 689   priv-&gt;drop_out_of_segment = DEFAULT_DROP_OUT_OF_SEGMENT;
 690 
 691   GST_OBJECT_FLAG_SET (basesink, GST_ELEMENT_FLAG_SINK);
 692 }
 693 
 694 static void
 695 gst_base_sink_finalize (GObject * object)
 696 {
 697   GstBaseSink *basesink;
 698 
 699   basesink = GST_BASE_SINK (object);
 700 
 701   g_mutex_clear (&amp;basesink-&gt;preroll_lock);
 702   g_cond_clear (&amp;basesink-&gt;preroll_cond);
</pre>
<hr />
<pre>
 744   GST_OBJECT_LOCK (sink);
 745   res = sink-&gt;sync;
 746   GST_OBJECT_UNLOCK (sink);
 747 
 748   return res;
 749 }
 750 
 751 /**
 752  * gst_base_sink_set_drop_out_of_segment:
 753  * @sink: the sink
 754  * @drop_out_of_segment: drop buffers outside the segment
 755  *
 756  * Configure @sink to drop buffers which are outside the current segment
 757  *
 758  * Since: 1.12
 759  */
 760 void
 761 gst_base_sink_set_drop_out_of_segment (GstBaseSink * sink,
 762     gboolean drop_out_of_segment)
 763 {


 764   g_return_if_fail (GST_IS_BASE_SINK (sink));
 765 


 766   GST_OBJECT_LOCK (sink);
<span class="line-modified"> 767   sink-&gt;priv-&gt;drop_out_of_segment = drop_out_of_segment;</span>
 768   GST_OBJECT_UNLOCK (sink);
 769 
 770 }
 771 
 772 /**
 773  * gst_base_sink_get_drop_out_of_segment:
 774  * @sink: the sink
 775  *
 776  * Checks if @sink is currently configured to drop buffers which are outside
 777  * the current segment
 778  *
 779  * Returns: %TRUE if the sink is configured to drop buffers outside the
 780  * current segment.
 781  *
 782  * Since: 1.12
 783  */
 784 gboolean
 785 gst_base_sink_get_drop_out_of_segment (GstBaseSink * sink)
 786 {

 787   gboolean res;
 788 
 789   g_return_val_if_fail (GST_IS_BASE_SINK (sink), FALSE);
 790 


 791   GST_OBJECT_LOCK (sink);
<span class="line-modified"> 792   res = sink-&gt;priv-&gt;drop_out_of_segment;</span>
 793   GST_OBJECT_UNLOCK (sink);
 794 
 795   return res;
 796 }
 797 
 798 /**
 799  * gst_base_sink_set_max_lateness:
 800  * @sink: the sink
 801  * @max_lateness: the new max lateness value.
 802  *
 803  * Sets the new max lateness value to @max_lateness. This value is
 804  * used to decide if a buffer should be dropped or not based on the
 805  * buffer timestamp and the current clock time. A value of -1 means
 806  * an unlimited time.
 807  */
 808 void
 809 gst_base_sink_set_max_lateness (GstBaseSink * sink, gint64 max_lateness)
 810 {
 811   g_return_if_fail (GST_IS_BASE_SINK (sink));
 812 
</pre>
<hr />
<pre>
1151  *
1152  * Query the sink for the latency parameters. The latency will be queried from
1153  * the upstream elements. @live will be %TRUE if @sink is configured to
1154  * synchronize against the clock. @upstream_live will be %TRUE if an upstream
1155  * element is live.
1156  *
1157  * If both @live and @upstream_live are %TRUE, the sink will want to compensate
1158  * for the latency introduced by the upstream elements by setting the
1159  * @min_latency to a strictly positive value.
1160  *
1161  * This function is mostly used by subclasses.
1162  *
1163  * Returns: %TRUE if the query succeeded.
1164  */
1165 gboolean
1166 gst_base_sink_query_latency (GstBaseSink * sink, gboolean * live,
1167     gboolean * upstream_live, GstClockTime * min_latency,
1168     GstClockTime * max_latency)
1169 {
1170   gboolean l, us_live, res, have_latency;
<span class="line-modified">1171   GstClockTime min, max, render_delay, processing_deadline;</span>
1172   GstQuery *query;
1173   GstClockTime us_min, us_max;
1174 
1175   /* we are live when we sync to the clock */
1176   GST_OBJECT_LOCK (sink);
1177   l = sink-&gt;sync;
1178   have_latency = sink-&gt;priv-&gt;have_latency;
1179   render_delay = sink-&gt;priv-&gt;render_delay;
<span class="line-added">1180   processing_deadline = sink-&gt;priv-&gt;processing_deadline;</span>
1181   GST_OBJECT_UNLOCK (sink);
1182 
1183   /* assume no latency */
1184   min = 0;
1185   max = -1;
1186   us_live = FALSE;
1187 
1188   if (have_latency) {
1189     GST_DEBUG_OBJECT (sink, &quot;we are ready for LATENCY query&quot;);
1190     /* we are ready for a latency query this is when we preroll or when we are
1191      * not async. */
1192     query = gst_query_new_latency ();
1193 
1194     /* ask the peer for the latency */
1195     if ((res = gst_pad_peer_query (sink-&gt;sinkpad, query))) {
1196       /* get upstream min and max latency */
1197       gst_query_parse_latency (query, &amp;us_live, &amp;us_min, &amp;us_max);
1198 
1199       if (us_live) {
1200         /* upstream live, use its latency, subclasses should use these
1201          * values to create the complete latency. */
1202         min = us_min;
1203         max = us_max;
<span class="line-added">1204 </span>
<span class="line-added">1205         if (l) {</span>
<span class="line-added">1206           if (max == -1 || min + processing_deadline &lt;= max)</span>
<span class="line-added">1207             min += processing_deadline;</span>
<span class="line-added">1208           else {</span>
<span class="line-added">1209             GST_ELEMENT_WARNING (sink, CORE, CLOCK,</span>
<span class="line-added">1210                 (_(&quot;Pipeline construction is invalid, please add queues.&quot;)),</span>
<span class="line-added">1211                 (&quot;Not enough buffering available for &quot;</span>
<span class="line-added">1212                     &quot; the processing deadline of %&quot; GST_TIME_FORMAT</span>
<span class="line-added">1213                     &quot;, add enough queues to buffer  %&quot; GST_TIME_FORMAT</span>
<span class="line-added">1214                     &quot; additional data. Shortening processing latency to %&quot;</span>
<span class="line-added">1215                     GST_TIME_FORMAT &quot;.&quot;,</span>
<span class="line-added">1216                     GST_TIME_ARGS (processing_deadline),</span>
<span class="line-added">1217                     GST_TIME_ARGS (min + processing_deadline - max),</span>
<span class="line-added">1218                     GST_TIME_ARGS (max - min)));</span>
<span class="line-added">1219             min = max;</span>
<span class="line-added">1220           }</span>
<span class="line-added">1221         }</span>
1222       }
1223       if (l) {
1224         /* we need to add the render delay if we are live */
1225         min += render_delay;
1226         if (max != -1)
1227           max += render_delay;
1228       }
1229     }
1230     gst_query_unref (query);
1231   } else {
1232     GST_DEBUG_OBJECT (sink, &quot;we are not yet ready for LATENCY query&quot;);
1233     res = FALSE;
1234   }
1235 
1236   /* not live, we tried to do the query, if it failed we return TRUE anyway */
1237   if (!res) {
1238     if (!l) {
1239       res = TRUE;
1240       GST_DEBUG_OBJECT (sink, &quot;latency query failed but we are not live&quot;);
1241     } else {
</pre>
<hr />
<pre>
1433  * Get the maximum amount of bits per second that the sink will render.
1434  *
1435  * Returns: the maximum number of bits per second @sink will render.
1436  *
1437  * Since: 1.2
1438  */
1439 guint64
1440 gst_base_sink_get_max_bitrate (GstBaseSink * sink)
1441 {
1442   guint64 res;
1443 
1444   g_return_val_if_fail (GST_IS_BASE_SINK (sink), 0);
1445 
1446   GST_OBJECT_LOCK (sink);
1447   res = sink-&gt;priv-&gt;max_bitrate;
1448   GST_OBJECT_UNLOCK (sink);
1449 
1450   return res;
1451 }
1452 
<span class="line-added">1453 /**</span>
<span class="line-added">1454  * gst_base_sink_set_processing_deadline:</span>
<span class="line-added">1455  * @sink: a #GstBaseSink</span>
<span class="line-added">1456  * @processing_deadline: the new processing deadline in nanoseconds.</span>
<span class="line-added">1457  *</span>
<span class="line-added">1458  * Maximum amount of time (in nanoseconds) that the pipeline can take</span>
<span class="line-added">1459  * for processing the buffer. This is added to the latency of live</span>
<span class="line-added">1460  * pipelines.</span>
<span class="line-added">1461  *</span>
<span class="line-added">1462  * This function is usually called by subclasses.</span>
<span class="line-added">1463  *</span>
<span class="line-added">1464  * Since: 1.16</span>
<span class="line-added">1465  */</span>
<span class="line-added">1466 void</span>
<span class="line-added">1467 gst_base_sink_set_processing_deadline (GstBaseSink * sink,</span>
<span class="line-added">1468     GstClockTime processing_deadline)</span>
<span class="line-added">1469 {</span>
<span class="line-added">1470   GstClockTime old_processing_deadline;</span>
<span class="line-added">1471 </span>
<span class="line-added">1472   g_return_if_fail (GST_IS_BASE_SINK (sink));</span>
<span class="line-added">1473 </span>
<span class="line-added">1474   GST_OBJECT_LOCK (sink);</span>
<span class="line-added">1475   old_processing_deadline = sink-&gt;priv-&gt;processing_deadline;</span>
<span class="line-added">1476   sink-&gt;priv-&gt;processing_deadline = processing_deadline;</span>
<span class="line-added">1477   GST_LOG_OBJECT (sink, &quot;set render processing_deadline to %&quot; GST_TIME_FORMAT,</span>
<span class="line-added">1478       GST_TIME_ARGS (processing_deadline));</span>
<span class="line-added">1479   GST_OBJECT_UNLOCK (sink);</span>
<span class="line-added">1480 </span>
<span class="line-added">1481   if (processing_deadline != old_processing_deadline) {</span>
<span class="line-added">1482     GST_DEBUG_OBJECT (sink, &quot;posting latency changed&quot;);</span>
<span class="line-added">1483     gst_element_post_message (GST_ELEMENT_CAST (sink),</span>
<span class="line-added">1484         gst_message_new_latency (GST_OBJECT_CAST (sink)));</span>
<span class="line-added">1485   }</span>
<span class="line-added">1486 }</span>
<span class="line-added">1487 </span>
<span class="line-added">1488 /**</span>
<span class="line-added">1489  * gst_base_sink_get_processing_deadline:</span>
<span class="line-added">1490  * @sink: a #GstBaseSink</span>
<span class="line-added">1491  *</span>
<span class="line-added">1492  * Get the processing deadline of @sink. see</span>
<span class="line-added">1493  * gst_base_sink_set_processing_deadline() for more information about</span>
<span class="line-added">1494  * the processing deadline.</span>
<span class="line-added">1495  *</span>
<span class="line-added">1496  * Returns: the processing deadline</span>
<span class="line-added">1497  *</span>
<span class="line-added">1498  * Since: 1.16</span>
<span class="line-added">1499  */</span>
<span class="line-added">1500 GstClockTime</span>
<span class="line-added">1501 gst_base_sink_get_processing_deadline (GstBaseSink * sink)</span>
<span class="line-added">1502 {</span>
<span class="line-added">1503   GstClockTimeDiff res;</span>
<span class="line-added">1504 </span>
<span class="line-added">1505   g_return_val_if_fail (GST_IS_BASE_SINK (sink), 0);</span>
<span class="line-added">1506 </span>
<span class="line-added">1507   GST_OBJECT_LOCK (sink);</span>
<span class="line-added">1508   res = sink-&gt;priv-&gt;processing_deadline;</span>
<span class="line-added">1509   GST_OBJECT_UNLOCK (sink);</span>
<span class="line-added">1510 </span>
<span class="line-added">1511   return res;</span>
<span class="line-added">1512 }</span>
<span class="line-added">1513 </span>
1514 static void
1515 gst_base_sink_set_property (GObject * object, guint prop_id,
1516     const GValue * value, GParamSpec * pspec)
1517 {
1518   GstBaseSink *sink = GST_BASE_SINK (object);
1519 
1520   switch (prop_id) {
1521     case PROP_SYNC:
1522       gst_base_sink_set_sync (sink, g_value_get_boolean (value));
1523       break;
1524     case PROP_MAX_LATENESS:
1525       gst_base_sink_set_max_lateness (sink, g_value_get_int64 (value));
1526       break;
1527     case PROP_QOS:
1528       gst_base_sink_set_qos_enabled (sink, g_value_get_boolean (value));
1529       break;
1530     case PROP_ASYNC:
1531       gst_base_sink_set_async_enabled (sink, g_value_get_boolean (value));
1532       break;
1533     case PROP_TS_OFFSET:
1534       gst_base_sink_set_ts_offset (sink, g_value_get_int64 (value));
1535       break;
1536     case PROP_BLOCKSIZE:
1537       gst_base_sink_set_blocksize (sink, g_value_get_uint (value));
1538       break;
1539     case PROP_RENDER_DELAY:
1540       gst_base_sink_set_render_delay (sink, g_value_get_uint64 (value));
1541       break;
1542     case PROP_ENABLE_LAST_SAMPLE:
1543       gst_base_sink_set_last_sample_enabled (sink, g_value_get_boolean (value));
1544       break;
1545     case PROP_THROTTLE_TIME:
1546       gst_base_sink_set_throttle_time (sink, g_value_get_uint64 (value));
1547       break;
1548     case PROP_MAX_BITRATE:
1549       gst_base_sink_set_max_bitrate (sink, g_value_get_uint64 (value));
1550       break;
<span class="line-added">1551     case PROP_PROCESSING_DEADLINE:</span>
<span class="line-added">1552       gst_base_sink_set_processing_deadline (sink, g_value_get_uint64 (value));</span>
<span class="line-added">1553       break;</span>
1554     default:
1555       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
1556       break;
1557   }
1558 }
1559 
1560 static void
1561 gst_base_sink_get_property (GObject * object, guint prop_id, GValue * value,
1562     GParamSpec * pspec)
1563 {
1564   GstBaseSink *sink = GST_BASE_SINK (object);
1565 
1566   switch (prop_id) {
1567     case PROP_SYNC:
1568       g_value_set_boolean (value, gst_base_sink_get_sync (sink));
1569       break;
1570     case PROP_MAX_LATENESS:
1571       g_value_set_int64 (value, gst_base_sink_get_max_lateness (sink));
1572       break;
1573     case PROP_QOS:
</pre>
<hr />
<pre>
1580       g_value_set_int64 (value, gst_base_sink_get_ts_offset (sink));
1581       break;
1582     case PROP_LAST_SAMPLE:
1583       gst_value_take_sample (value, gst_base_sink_get_last_sample (sink));
1584       break;
1585     case PROP_ENABLE_LAST_SAMPLE:
1586       g_value_set_boolean (value, gst_base_sink_is_last_sample_enabled (sink));
1587       break;
1588     case PROP_BLOCKSIZE:
1589       g_value_set_uint (value, gst_base_sink_get_blocksize (sink));
1590       break;
1591     case PROP_RENDER_DELAY:
1592       g_value_set_uint64 (value, gst_base_sink_get_render_delay (sink));
1593       break;
1594     case PROP_THROTTLE_TIME:
1595       g_value_set_uint64 (value, gst_base_sink_get_throttle_time (sink));
1596       break;
1597     case PROP_MAX_BITRATE:
1598       g_value_set_uint64 (value, gst_base_sink_get_max_bitrate (sink));
1599       break;
<span class="line-added">1600     case PROP_PROCESSING_DEADLINE:</span>
<span class="line-added">1601       g_value_set_uint64 (value, gst_base_sink_get_processing_deadline (sink));</span>
<span class="line-added">1602       break;</span>
1603     default:
1604       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
1605       break;
1606   }
1607 }
1608 
1609 
1610 static GstCaps *
1611 gst_base_sink_default_get_caps (GstBaseSink * sink, GstCaps * filter)
1612 {
1613   return NULL;
1614 }
1615 
1616 static gboolean
1617 gst_base_sink_default_set_caps (GstBaseSink * sink, GstCaps * caps)
1618 {
1619   return TRUE;
1620 }
1621 
1622 /* with PREROLL_LOCK, STREAM_LOCK */
</pre>
<hr />
<pre>
1624 gst_base_sink_commit_state (GstBaseSink * basesink)
1625 {
1626   /* commit state and proceed to next pending state */
1627   GstState current, next, pending, post_pending;
1628   gboolean post_paused = FALSE;
1629   gboolean post_async_done = FALSE;
1630   gboolean post_playing = FALSE;
1631 
1632   /* we are certainly not playing async anymore now */
1633   basesink-&gt;playing_async = FALSE;
1634 
1635   GST_OBJECT_LOCK (basesink);
1636   current = GST_STATE (basesink);
1637   next = GST_STATE_NEXT (basesink);
1638   pending = GST_STATE_PENDING (basesink);
1639   post_pending = pending;
1640 
1641   switch (pending) {
1642     case GST_STATE_PLAYING:
1643     {
<span class="line-modified">1644       GST_DEBUG_OBJECT (basesink, &quot;committing state to PLAYING&quot;);</span>
1645 
1646       basesink-&gt;need_preroll = FALSE;
1647       post_async_done = TRUE;
<span class="line-modified">1648       basesink-&gt;priv-&gt;committed = TRUE;</span>
1649       post_playing = TRUE;
1650       /* post PAUSED too when we were READY */
1651       if (current == GST_STATE_READY) {
1652         post_paused = TRUE;
1653       }
1654       break;
1655     }
1656     case GST_STATE_PAUSED:
<span class="line-modified">1657       GST_DEBUG_OBJECT (basesink, &quot;committing state to PAUSED&quot;);</span>
1658       post_paused = TRUE;
1659       post_async_done = TRUE;
<span class="line-modified">1660       basesink-&gt;priv-&gt;committed = TRUE;</span>
1661       post_pending = GST_STATE_VOID_PENDING;
1662       break;
1663     case GST_STATE_READY:
1664     case GST_STATE_NULL:
1665       goto stopping;
1666     case GST_STATE_VOID_PENDING:
1667       goto nothing_pending;
1668     default:
1669       break;
1670   }
1671 
1672   /* we can report latency queries now */
1673   basesink-&gt;priv-&gt;have_latency = TRUE;
1674 
1675   GST_STATE (basesink) = pending;
1676   GST_STATE_NEXT (basesink) = GST_STATE_VOID_PENDING;
1677   GST_STATE_PENDING (basesink) = GST_STATE_VOID_PENDING;
1678   GST_STATE_RETURN (basesink) = GST_STATE_CHANGE_SUCCESS;
1679   GST_OBJECT_UNLOCK (basesink);
1680 
</pre>
<hr />
<pre>
2269 
2270   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (time)))
2271     goto invalid_time;
2272 
2273   GST_OBJECT_LOCK (sink);
2274   if (G_UNLIKELY (!sink-&gt;sync))
2275     goto no_sync;
2276 
2277   if (G_UNLIKELY ((clock = GST_ELEMENT_CLOCK (sink)) == NULL))
2278     goto no_clock;
2279 
2280   base_time = GST_ELEMENT_CAST (sink)-&gt;base_time;
2281   GST_LOG_OBJECT (sink,
2282       &quot;time %&quot; GST_TIME_FORMAT &quot;, base_time %&quot; GST_TIME_FORMAT,
2283       GST_TIME_ARGS (time), GST_TIME_ARGS (base_time));
2284 
2285   /* add base_time to running_time to get the time against the clock */
2286   time += base_time;
2287 
2288   /* Re-use existing clockid if available */


2289   if (G_LIKELY (sink-&gt;priv-&gt;cached_clock_id != NULL
<span class="line-modified">2290           &amp;&amp; gst_clock_id_uses_clock (sink-&gt;priv-&gt;cached_clock_id, clock))) {</span>

2291     if (!gst_clock_single_shot_id_reinit (clock, sink-&gt;priv-&gt;cached_clock_id,
2292             time)) {
2293       gst_clock_id_unref (sink-&gt;priv-&gt;cached_clock_id);
2294       sink-&gt;priv-&gt;cached_clock_id = gst_clock_new_single_shot_id (clock, time);
2295     }
2296   } else {
2297     if (sink-&gt;priv-&gt;cached_clock_id != NULL)
2298       gst_clock_id_unref (sink-&gt;priv-&gt;cached_clock_id);
2299     sink-&gt;priv-&gt;cached_clock_id = gst_clock_new_single_shot_id (clock, time);
2300   }
2301   GST_OBJECT_UNLOCK (sink);
2302 
2303   /* A blocking wait is performed on the clock. We save the ClockID
2304    * so we can unlock the entry at any time. While we are blocking, we
2305    * release the PREROLL_LOCK so that other threads can interrupt the
2306    * entry. */
2307   sink-&gt;clock_id = sink-&gt;priv-&gt;cached_clock_id;
2308   /* release the preroll lock while waiting */
2309   GST_BASE_SINK_PREROLL_UNLOCK (sink);
2310 
</pre>
<hr />
<pre>
2466         goto preroll_failed;
2467     }
2468   }
2469   return GST_FLOW_OK;
2470 
2471   /* ERRORS */
2472 prepare_canceled:
2473   {
2474     GST_DEBUG_OBJECT (sink, &quot;prepare failed, abort state&quot;);
2475     gst_element_abort_state (GST_ELEMENT_CAST (sink));
2476     return ret;
2477   }
2478 preroll_canceled:
2479   {
2480     GST_DEBUG_OBJECT (sink, &quot;preroll failed, abort state&quot;);
2481     gst_element_abort_state (GST_ELEMENT_CAST (sink));
2482     return ret;
2483   }
2484 stopping:
2485   {
<span class="line-modified">2486     GST_DEBUG_OBJECT (sink, &quot;stopping while committing state&quot;);</span>
2487     return GST_FLOW_FLUSHING;
2488   }
2489 preroll_failed:
2490   {
2491     GST_DEBUG_OBJECT (sink, &quot;preroll failed: %s&quot;, gst_flow_get_name (ret));
2492     return ret;
2493   }
2494 }
2495 
2496 /**
2497  * gst_base_sink_wait:
2498  * @sink: the sink
2499  * @time: the running_time to be reached
2500  * @jitter: (out) (allow-none): the jitter to be filled with time diff, or %NULL
2501  *
2502  * This function will wait for preroll to complete and will then block until @time
2503  * is reached. It is usually called by subclasses that use their own internal
2504  * synchronisation but want to let some synchronization (like EOS) be handled
2505  * by the base class.
2506  *
</pre>
<hr />
<pre>
2537         GST_TIME_FORMAT, GST_TIME_ARGS (time));
2538 
2539     /* compensate for latency, ts_offset and render delay */
2540     stime = gst_base_sink_adjust_time (sink, time);
2541 
2542     /* wait for the clock, this can be interrupted because we got shut down or
2543      * we PAUSED. */
2544     status = gst_base_sink_wait_clock (sink, stime, jitter);
2545 
2546     GST_DEBUG_OBJECT (sink, &quot;clock returned %d&quot;, status);
2547 
2548     /* invalid time, no clock or sync disabled, just continue then */
2549     if (status == GST_CLOCK_BADTIME)
2550       break;
2551 
2552     /* waiting could have been interrupted and we can be flushing now */
2553     if (G_UNLIKELY (sink-&gt;flushing))
2554       goto flushing;
2555 
2556     /* retry if we got unscheduled, which means we did not reach the timeout
<span class="line-modified">2557      * yet. if some other error occurs, we continue. */</span>
2558   } while (status == GST_CLOCK_UNSCHEDULED);
2559 
2560   GST_DEBUG_OBJECT (sink, &quot;end of stream&quot;);
2561 
2562   return GST_FLOW_OK;
2563 
2564   /* ERRORS */
2565 flushing:
2566   {
2567     GST_DEBUG_OBJECT (sink, &quot;we are flushing&quot;);
2568     return GST_FLOW_FLUSHING;
2569   }
2570 }
2571 
2572 /* with STREAM_LOCK, PREROLL_LOCK
2573  *
2574  * Make sure we are in PLAYING and synchronize an object to the clock.
2575  *
2576  * If we need preroll, we are not in PLAYING. We try to commit the state
2577  * if needed and then block if we still are not PLAYING.
</pre>
<hr />
<pre>
3507     GST_OBJECT_UNLOCK (basesink);
3508   }
3509 
3510   bclass = GST_BASE_SINK_GET_CLASS (basesink);
3511 
3512   /* check if the buffer needs to be dropped, we first ask the subclass for the
3513    * start and end */
3514   if (bclass-&gt;get_times)
3515     bclass-&gt;get_times (basesink, sync_buf, &amp;start, &amp;end);
3516 
3517   if (!GST_CLOCK_TIME_IS_VALID (start)) {
3518     /* if the subclass does not want sync, we use our own values so that we at
3519      * least clip the buffer to the segment */
3520     gst_base_sink_default_get_times (basesink, sync_buf, &amp;start, &amp;end);
3521   }
3522 
3523   GST_DEBUG_OBJECT (basesink, &quot;got times start: %&quot; GST_TIME_FORMAT
3524       &quot;, end: %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (start), GST_TIME_ARGS (end));
3525 
3526   /* a dropped buffer does not participate in anything. Buffer can only be
<span class="line-modified">3527    * dropped if their PTS falls completely outside the segment, while we sync</span>
3528    * preferably on DTS */
3529   if (GST_CLOCK_TIME_IS_VALID (start) &amp;&amp; (segment-&gt;format == GST_FORMAT_TIME)) {
3530     GstClockTime pts = GST_BUFFER_PTS (sync_buf);
3531     GstClockTime pts_end = GST_CLOCK_TIME_NONE;
3532 
3533     if (!GST_CLOCK_TIME_IS_VALID (pts))
3534       pts = start;
3535 
3536     if (GST_CLOCK_TIME_IS_VALID (end))
3537       pts_end = pts + (end - start);
3538 
3539     if (G_UNLIKELY (!gst_segment_clip (segment,
3540                 GST_FORMAT_TIME, pts, pts_end, NULL, NULL)
3541             &amp;&amp; priv-&gt;drop_out_of_segment))
3542       goto out_of_segment;
3543   }
3544 
3545   if (bclass-&gt;prepare || bclass-&gt;prepare_list) {
3546     gboolean do_sync = TRUE, stepped = FALSE, syncable = TRUE;
3547     GstClockTime sstart, sstop, rstart, rstop, rnext;
</pre>
<hr />
<pre>
4305   GstQuery *query;
4306   gboolean pull_mode;
4307 
4308   basesink = GST_BASE_SINK (parent);
4309 
4310   GST_DEBUG_OBJECT (basesink, &quot;Trying pull mode first&quot;);
4311 
4312   gst_base_sink_set_flushing (basesink, pad, FALSE);
4313 
4314   /* we need to have the pull mode enabled */
4315   if (!basesink-&gt;can_activate_pull) {
4316     GST_DEBUG_OBJECT (basesink, &quot;pull mode disabled&quot;);
4317     goto fallback;
4318   }
4319 
4320   /* check if downstreams supports pull mode at all */
4321   query = gst_query_new_scheduling ();
4322 
4323   if (!gst_pad_peer_query (pad, query)) {
4324     gst_query_unref (query);
<span class="line-modified">4325     GST_DEBUG_OBJECT (basesink, &quot;peer query failed, no pull mode&quot;);</span>
4326     goto fallback;
4327   }
4328 
4329   /* parse result of the query */
4330   pull_mode = gst_query_has_scheduling_mode (query, GST_PAD_MODE_PULL);
4331   gst_query_unref (query);
4332 
4333   if (!pull_mode) {
4334     GST_DEBUG_OBJECT (basesink, &quot;pull mode not supported&quot;);
4335     goto fallback;
4336   }
4337 
4338   /* set the pad mode before starting the task so that it&#39;s in the
4339    * correct state for the new thread. also the sink set_caps and get_caps
4340    * function checks this */
4341   basesink-&gt;pad_mode = GST_PAD_MODE_PULL;
4342 
4343   /* we first try to negotiate a format so that when we try to activate
4344    * downstream, it knows about our format */
4345   if (!gst_base_sink_negotiate_pull (basesink)) {
</pre>
<hr />
<pre>
5164     case GST_STATE_CHANGE_READY_TO_PAUSED:
5165       /* need to complete preroll before this state change completes, there
5166        * is no data flow in READY so we can safely assume we need to preroll. */
5167       GST_BASE_SINK_PREROLL_LOCK (basesink);
5168       GST_DEBUG_OBJECT (basesink, &quot;READY to PAUSED&quot;);
5169       basesink-&gt;have_newsegment = FALSE;
5170       gst_segment_init (&amp;basesink-&gt;segment, GST_FORMAT_UNDEFINED);
5171       basesink-&gt;offset = 0;
5172       basesink-&gt;have_preroll = FALSE;
5173       priv-&gt;step_unlock = FALSE;
5174       basesink-&gt;need_preroll = TRUE;
5175       basesink-&gt;playing_async = TRUE;
5176       priv-&gt;current_sstart = GST_CLOCK_TIME_NONE;
5177       priv-&gt;current_sstop = GST_CLOCK_TIME_NONE;
5178       priv-&gt;eos_rtime = GST_CLOCK_TIME_NONE;
5179       priv-&gt;latency = 0;
5180       basesink-&gt;eos = FALSE;
5181       priv-&gt;received_eos = FALSE;
5182       gst_base_sink_reset_qos (basesink);
5183       priv-&gt;rc_next = -1;
<span class="line-modified">5184       priv-&gt;committed = FALSE;</span>
5185       priv-&gt;call_preroll = TRUE;
5186       priv-&gt;current_step.valid = FALSE;
5187       priv-&gt;pending_step.valid = FALSE;
5188       if (priv-&gt;async_enabled) {
5189         GST_DEBUG_OBJECT (basesink, &quot;doing async state change&quot;);
5190         /* when async enabled, post async-start message and return ASYNC from
5191          * the state change function */
5192         ret = GST_STATE_CHANGE_ASYNC;
5193         gst_element_post_message (GST_ELEMENT_CAST (basesink),
5194             gst_message_new_async_start (GST_OBJECT_CAST (basesink)));
5195       } else {
5196         priv-&gt;have_latency = TRUE;
5197       }
5198       GST_BASE_SINK_PREROLL_UNLOCK (basesink);
5199       break;
5200     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
5201       GST_BASE_SINK_PREROLL_LOCK (basesink);
5202       g_atomic_int_set (&amp;basesink-&gt;priv-&gt;to_playing, TRUE);
5203       if (!gst_base_sink_needs_preroll (basesink)) {
5204         GST_DEBUG_OBJECT (basesink, &quot;PAUSED to PLAYING, don&#39;t need preroll&quot;);
5205         /* no preroll needed anymore now. */
5206         basesink-&gt;playing_async = FALSE;
5207         basesink-&gt;need_preroll = FALSE;
5208         if (basesink-&gt;eos) {
5209           GstMessage *message;
5210 
5211           /* need to post EOS message here */
5212           GST_DEBUG_OBJECT (basesink, &quot;Now posting EOS&quot;);
5213           message = gst_message_new_eos (GST_OBJECT_CAST (basesink));
5214           gst_message_set_seqnum (message, basesink-&gt;priv-&gt;seqnum);
5215           gst_element_post_message (GST_ELEMENT_CAST (basesink), message);
5216         } else {
5217           GST_DEBUG_OBJECT (basesink, &quot;signal preroll&quot;);
5218           GST_BASE_SINK_PREROLL_SIGNAL (basesink);
5219         }
5220       } else {
5221         GST_DEBUG_OBJECT (basesink, &quot;PAUSED to PLAYING, we are not prerolled&quot;);
5222         basesink-&gt;need_preroll = TRUE;
5223         basesink-&gt;playing_async = TRUE;
5224         priv-&gt;call_preroll = TRUE;
<span class="line-modified">5225         priv-&gt;committed = FALSE;</span>
5226         if (priv-&gt;async_enabled) {
5227           GST_DEBUG_OBJECT (basesink, &quot;doing async state change&quot;);
5228           ret = GST_STATE_CHANGE_ASYNC;
5229           gst_element_post_message (GST_ELEMENT_CAST (basesink),
5230               gst_message_new_async_start (GST_OBJECT_CAST (basesink)));
5231         }
5232       }
5233       GST_BASE_SINK_PREROLL_UNLOCK (basesink);
5234       break;
5235     default:
5236       break;
5237   }
5238 
5239   {
5240     GstStateChangeReturn bret;
5241 
5242     bret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
5243     if (G_UNLIKELY (bret == GST_STATE_CHANGE_FAILURE))
5244       goto activate_failed;
5245   }
</pre>
<hr />
<pre>
5270       if (basesink-&gt;clock_id) {
5271         GST_DEBUG_OBJECT (basesink, &quot;unschedule clock&quot;);
5272         gst_clock_id_unschedule (basesink-&gt;clock_id);
5273       }
5274 
5275       /* if we don&#39;t have a preroll buffer we need to wait for a preroll and
5276        * return ASYNC. */
5277       if (!gst_base_sink_needs_preroll (basesink)) {
5278         GST_DEBUG_OBJECT (basesink, &quot;PLAYING to PAUSED, we are prerolled&quot;);
5279         basesink-&gt;playing_async = FALSE;
5280         basesink-&gt;need_preroll = FALSE;
5281       } else {
5282         if (GST_STATE_TARGET (GST_ELEMENT (basesink)) &lt;= GST_STATE_READY) {
5283           GST_DEBUG_OBJECT (basesink, &quot;element is &lt;= READY&quot;);
5284           ret = GST_STATE_CHANGE_SUCCESS;
5285         } else {
5286           GST_DEBUG_OBJECT (basesink,
5287               &quot;PLAYING to PAUSED, we are not prerolled&quot;);
5288           basesink-&gt;playing_async = TRUE;
5289           basesink-&gt;need_preroll = TRUE;
<span class="line-modified">5290           priv-&gt;committed = FALSE;</span>
5291           priv-&gt;call_preroll = TRUE;
5292           if (priv-&gt;async_enabled) {
5293             GST_DEBUG_OBJECT (basesink, &quot;doing async state change&quot;);
5294             ret = GST_STATE_CHANGE_ASYNC;
5295             gst_element_post_message (GST_ELEMENT_CAST (basesink),
5296                 gst_message_new_async_start (GST_OBJECT_CAST (basesink)));
5297           }
5298         }
5299       }
5300       GST_DEBUG_OBJECT (basesink, &quot;rendered: %&quot; G_GUINT64_FORMAT
5301           &quot;, dropped: %&quot; G_GUINT64_FORMAT, priv-&gt;rendered, priv-&gt;dropped);
5302 
5303       gst_base_sink_reset_qos (basesink);
5304       GST_BASE_SINK_PREROLL_UNLOCK (basesink);
5305       break;
5306     case GST_STATE_CHANGE_PAUSED_TO_READY:
5307       GST_BASE_SINK_PREROLL_LOCK (basesink);
5308       /* start by resetting our position state with the object lock so that the
5309        * position query gets the right idea. We do this before we post the
5310        * messages so that the message handlers pick this up. */
5311       GST_OBJECT_LOCK (basesink);
5312       basesink-&gt;have_newsegment = FALSE;
5313       priv-&gt;current_sstart = GST_CLOCK_TIME_NONE;
5314       priv-&gt;current_sstop = GST_CLOCK_TIME_NONE;
5315       priv-&gt;have_latency = FALSE;
5316       if (priv-&gt;cached_clock_id) {
5317         gst_clock_id_unref (priv-&gt;cached_clock_id);
5318         priv-&gt;cached_clock_id = NULL;
5319       }
5320       gst_caps_replace (&amp;basesink-&gt;priv-&gt;caps, NULL);
5321       GST_OBJECT_UNLOCK (basesink);
5322 
5323       gst_base_sink_set_last_buffer (basesink, NULL);
5324       gst_base_sink_set_last_buffer_list (basesink, NULL);
5325       priv-&gt;call_preroll = FALSE;
5326 
<span class="line-modified">5327       if (!priv-&gt;committed) {</span>
5328         if (priv-&gt;async_enabled) {
5329           GST_DEBUG_OBJECT (basesink, &quot;PAUSED to READY, posting async-done&quot;);
5330 
5331           gst_element_post_message (GST_ELEMENT_CAST (basesink),
5332               gst_message_new_state_changed (GST_OBJECT_CAST (basesink),
5333                   GST_STATE_PLAYING, GST_STATE_PAUSED, GST_STATE_READY));
5334 
5335           gst_element_post_message (GST_ELEMENT_CAST (basesink),
5336               gst_message_new_async_done (GST_OBJECT_CAST (basesink),
5337                   GST_CLOCK_TIME_NONE));
5338         }
<span class="line-modified">5339         priv-&gt;committed = TRUE;</span>
5340       } else {
5341         GST_DEBUG_OBJECT (basesink, &quot;PAUSED to READY, don&#39;t need_preroll&quot;);
5342       }
5343       GST_BASE_SINK_PREROLL_UNLOCK (basesink);
5344       break;
5345     case GST_STATE_CHANGE_READY_TO_NULL:
5346       if (bclass-&gt;stop) {
5347         if (!bclass-&gt;stop (basesink)) {
5348           GST_WARNING_OBJECT (basesink, &quot;failed to stop&quot;);
5349         }
5350       }
5351       gst_base_sink_set_last_buffer (basesink, NULL);
5352       gst_base_sink_set_last_buffer_list (basesink, NULL);
5353       priv-&gt;call_preroll = FALSE;
5354       break;
5355     default:
5356       break;
5357   }
5358 
5359   return ret;
</pre>
</td>
</tr>
</table>
<center><a href="gstbaseparse.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstbasesink.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>