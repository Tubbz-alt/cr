<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/video-converter.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="video-color.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="video-converter.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/video-converter.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2063 
2064 static GstLineCache *
2065 chain_pack (GstVideoConverter * convert, GstLineCache * prev, gint idx)
2066 {
2067   convert-&gt;pack_nlines = convert-&gt;out_info.finfo-&gt;pack_lines;
2068   convert-&gt;pack_pstride = convert-&gt;current_pstride;
2069   convert-&gt;identity_pack =
2070       (convert-&gt;out_info.finfo-&gt;format ==
2071       convert-&gt;out_info.finfo-&gt;unpack_format);
2072   GST_DEBUG (&quot;chain pack line format %s, pstride %d, identity_pack %d (%d %d)&quot;,
2073       gst_video_format_to_string (convert-&gt;current_format),
2074       convert-&gt;current_pstride, convert-&gt;identity_pack,
2075       convert-&gt;out_info.finfo-&gt;format, convert-&gt;out_info.finfo-&gt;unpack_format);
2076 
2077   return prev;
2078 }
2079 
2080 static void
2081 setup_allocators (GstVideoConverter * convert)
2082 {
<span class="line-modified">2083   GstLineCache *cache;</span>
2084   GstLineCacheAllocLineFunc alloc_line;
2085   gboolean alloc_writable;
2086   gpointer user_data;
2087   GDestroyNotify notify;
<span class="line-modified">2088   gint width, n_lines;</span>
2089   gint i;
2090 
2091   width = MAX (convert-&gt;in_maxwidth, convert-&gt;out_maxwidth);
2092   width += convert-&gt;out_x;
2093 
2094   for (i = 0; i &lt; convert-&gt;conversion_runner-&gt;n_threads; i++) {
<span class="line-removed">2095     n_lines = 1;</span>
<span class="line-removed">2096 </span>
2097     /* start with using dest lines if we can directly write into it */
2098     if (convert-&gt;identity_pack) {
2099       alloc_line = get_dest_line;
2100       alloc_writable = TRUE;
2101       user_data = convert;
2102       notify = NULL;
2103     } else {
2104       user_data =
2105           converter_alloc_new (sizeof (guint16) * width * 4, 4 + BACKLOG,
2106           convert, NULL);
2107       setup_border_alloc (convert, user_data);
2108       notify = (GDestroyNotify) converter_alloc_free;
2109       alloc_line = get_border_temp_line;
2110       /* when we add a border, we need to write */
2111       alloc_writable = convert-&gt;borderline != NULL;
2112     }
2113 













2114     /* now walk backwards, we try to write into the dest lines directly
2115      * and keep track if the source needs to be writable */
2116     for (cache = convert-&gt;pack_lines[i]; cache; cache = cache-&gt;prev) {
2117       gst_line_cache_set_alloc_line_func (cache, alloc_line, user_data, notify);
2118       cache-&gt;alloc_writable = alloc_writable;
<span class="line-removed">2119       n_lines = MAX (n_lines, cache-&gt;n_lines);</span>
2120 
2121       /* make sure only one cache frees the allocator */
2122       notify = NULL;
2123 
2124       if (!cache-&gt;pass_alloc) {
2125         /* can&#39;t pass allocator, make new temp line allocator */
2126         user_data =
2127             converter_alloc_new (sizeof (guint16) * width * 4,
<span class="line-modified">2128             n_lines + cache-&gt;backlog, convert, NULL);</span>
2129         notify = (GDestroyNotify) converter_alloc_free;
2130         alloc_line = get_temp_line;
2131         alloc_writable = FALSE;
<span class="line-removed">2132         n_lines = cache-&gt;n_lines;</span>
2133       }
2134       /* if someone writes to the input, we need a writable line from the
2135        * previous cache */
2136       if (cache-&gt;write_input)
2137         alloc_writable = TRUE;
2138     }
2139     /* free leftover allocator */
2140     if (notify)
2141       notify (user_data);
2142   }
2143 }
2144 
2145 static void
2146 setup_borderline (GstVideoConverter * convert)
2147 {
2148   gint width;
2149 
2150   width = MAX (convert-&gt;in_maxwidth, convert-&gt;out_maxwidth);
2151   width += convert-&gt;out_x;
2152 
</pre>
<hr />
<pre>
5810     case GST_VIDEO_FORMAT_Y41B:
5811     case GST_VIDEO_FORMAT_Y42B:
5812     case GST_VIDEO_FORMAT_Y444:
5813     case GST_VIDEO_FORMAT_GRAY8:
5814     case GST_VIDEO_FORMAT_A420:
5815     case GST_VIDEO_FORMAT_YUV9:
5816     case GST_VIDEO_FORMAT_YVU9:
5817     case GST_VIDEO_FORMAT_GBR:
5818     case GST_VIDEO_FORMAT_GBRA:
5819       res = GST_VIDEO_FORMAT_GRAY8;
5820       break;
5821     case GST_VIDEO_FORMAT_GRAY16_BE:
5822     case GST_VIDEO_FORMAT_GRAY16_LE:
5823       res = GST_VIDEO_FORMAT_GRAY16_BE;
5824       break;
5825     case GST_VIDEO_FORMAT_YUY2:
5826     case GST_VIDEO_FORMAT_UYVY:
5827     case GST_VIDEO_FORMAT_VYUY:
5828     case GST_VIDEO_FORMAT_YVYU:
5829     case GST_VIDEO_FORMAT_AYUV:

5830     case GST_VIDEO_FORMAT_RGBx:
5831     case GST_VIDEO_FORMAT_BGRx:
5832     case GST_VIDEO_FORMAT_xRGB:
5833     case GST_VIDEO_FORMAT_xBGR:
5834     case GST_VIDEO_FORMAT_RGBA:
5835     case GST_VIDEO_FORMAT_BGRA:
5836     case GST_VIDEO_FORMAT_ARGB:
5837     case GST_VIDEO_FORMAT_ABGR:
5838     case GST_VIDEO_FORMAT_RGB:
5839     case GST_VIDEO_FORMAT_BGR:
5840     case GST_VIDEO_FORMAT_v308:
5841     case GST_VIDEO_FORMAT_IYU2:
5842     case GST_VIDEO_FORMAT_ARGB64:
5843     case GST_VIDEO_FORMAT_AYUV64:
5844       res = format;
5845       break;
5846     case GST_VIDEO_FORMAT_RGB15:
5847     case GST_VIDEO_FORMAT_BGR15:
5848     case GST_VIDEO_FORMAT_RGB16:
5849     case GST_VIDEO_FORMAT_BGR16:
5850       res = GST_VIDEO_FORMAT_NV12;
5851       break;
5852     case GST_VIDEO_FORMAT_NV12:
5853     case GST_VIDEO_FORMAT_NV21:
5854     case GST_VIDEO_FORMAT_NV16:
5855     case GST_VIDEO_FORMAT_NV61:
5856     case GST_VIDEO_FORMAT_NV24:
5857       res = plane == 0 ? GST_VIDEO_FORMAT_GRAY8 : GST_VIDEO_FORMAT_NV12;
5858       break;
5859     case GST_VIDEO_FORMAT_UNKNOWN:
5860     case GST_VIDEO_FORMAT_ENCODED:
5861     case GST_VIDEO_FORMAT_v210:
5862     case GST_VIDEO_FORMAT_v216:


5863     case GST_VIDEO_FORMAT_UYVP:
5864     case GST_VIDEO_FORMAT_RGB8P:
5865     case GST_VIDEO_FORMAT_IYU1:
5866     case GST_VIDEO_FORMAT_r210:
5867     case GST_VIDEO_FORMAT_I420_10BE:
5868     case GST_VIDEO_FORMAT_I420_10LE:
5869     case GST_VIDEO_FORMAT_I422_10BE:
5870     case GST_VIDEO_FORMAT_I422_10LE:
5871     case GST_VIDEO_FORMAT_Y444_10BE:
5872     case GST_VIDEO_FORMAT_Y444_10LE:
5873     case GST_VIDEO_FORMAT_I420_12BE:
5874     case GST_VIDEO_FORMAT_I420_12LE:
5875     case GST_VIDEO_FORMAT_I422_12BE:
5876     case GST_VIDEO_FORMAT_I422_12LE:
5877     case GST_VIDEO_FORMAT_Y444_12BE:
5878     case GST_VIDEO_FORMAT_Y444_12LE:
5879     case GST_VIDEO_FORMAT_GBR_10BE:
5880     case GST_VIDEO_FORMAT_GBR_10LE:
5881     case GST_VIDEO_FORMAT_GBRA_10BE:
5882     case GST_VIDEO_FORMAT_GBRA_10LE:
5883     case GST_VIDEO_FORMAT_GBR_12BE:
5884     case GST_VIDEO_FORMAT_GBR_12LE:
5885     case GST_VIDEO_FORMAT_GBRA_12BE:
5886     case GST_VIDEO_FORMAT_GBRA_12LE:
5887     case GST_VIDEO_FORMAT_NV12_64Z32:
5888     case GST_VIDEO_FORMAT_A420_10BE:
5889     case GST_VIDEO_FORMAT_A420_10LE:
5890     case GST_VIDEO_FORMAT_A422_10BE:
5891     case GST_VIDEO_FORMAT_A422_10LE:
5892     case GST_VIDEO_FORMAT_A444_10BE:
5893     case GST_VIDEO_FORMAT_A444_10LE:
5894     case GST_VIDEO_FORMAT_P010_10BE:
5895     case GST_VIDEO_FORMAT_P010_10LE:
5896     case GST_VIDEO_FORMAT_GRAY10_LE32:
5897     case GST_VIDEO_FORMAT_NV12_10LE32:
5898     case GST_VIDEO_FORMAT_NV16_10LE32:


5899       res = format;
5900       g_assert_not_reached ();
5901       break;
5902   }
5903   return res;
5904 }
5905 
5906 static gboolean
5907 is_merge_yuv (GstVideoInfo * info)
5908 {
5909   switch (GST_VIDEO_INFO_FORMAT (info)) {
5910     case GST_VIDEO_FORMAT_YUY2:
5911     case GST_VIDEO_FORMAT_YVYU:
5912     case GST_VIDEO_FORMAT_UYVY:
5913     case GST_VIDEO_FORMAT_VYUY:
5914       return TRUE;
5915     default:
5916       return FALSE;
5917   }
5918 }
5919 
5920 static gboolean
5921 setup_scale (GstVideoConverter * convert)
5922 {
5923   int i, n_planes;
<span class="line-modified">5924   gint method, cr_method, stride, in_width, in_height, out_width, out_height;</span>
5925   guint taps;
5926   GstVideoInfo *in_info, *out_info;
5927   const GstVideoFormatInfo *in_finfo, *out_finfo;
5928   GstVideoFormat in_format, out_format;
5929   guint n_threads = convert-&gt;conversion_runner-&gt;n_threads;
5930 
5931   in_info = &amp;convert-&gt;in_info;
5932   out_info = &amp;convert-&gt;out_info;
5933 
5934   in_finfo = in_info-&gt;finfo;
5935   out_finfo = out_info-&gt;finfo;
5936 
5937   n_planes = GST_VIDEO_INFO_N_PLANES (out_info);
5938 
5939   method = GET_OPT_RESAMPLER_METHOD (convert);
5940   if (method == GST_VIDEO_RESAMPLER_METHOD_NEAREST)
5941     cr_method = method;
5942   else
5943     cr_method = GET_OPT_CHROMA_RESAMPLER_METHOD (convert);
5944   taps = GET_OPT_RESAMPLER_TAPS (convert);
</pre>
<hr />
<pre>
5954 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
5955     case GST_VIDEO_FORMAT_GRAY16_BE:
5956 #else
5957     case GST_VIDEO_FORMAT_GRAY16_LE:
5958 #endif
5959       if (method != GST_VIDEO_RESAMPLER_METHOD_NEAREST) {
5960         GST_DEBUG (&quot;%s only with nearest resampling&quot;,
5961             gst_video_format_to_string (in_format));
5962         return FALSE;
5963       }
5964       break;
5965     default:
5966       break;
5967   }
5968 
5969   in_width = convert-&gt;in_width;
5970   in_height = convert-&gt;in_height;
5971   out_width = convert-&gt;out_width;
5972   out_height = convert-&gt;out_height;
5973 
<span class="line-removed">5974   stride = 0;</span>
<span class="line-removed">5975 </span>
5976   if (n_planes == 1 &amp;&amp; !GST_VIDEO_FORMAT_INFO_IS_GRAY (out_finfo)) {
5977     gint pstride;
5978     guint j;
5979 
5980     if (is_merge_yuv (in_info)) {
5981       GstVideoScaler *y_scaler, *uv_scaler;
5982 
5983       if (in_width != out_width) {
5984         convert-&gt;fh_scaler[0].scaler = g_new (GstVideoScaler *, n_threads);
5985         for (j = 0; j &lt; n_threads; j++) {
5986           y_scaler =
5987               gst_video_scaler_new (method, GST_VIDEO_SCALER_FLAG_NONE, taps,
5988               GST_VIDEO_FORMAT_INFO_SCALE_WIDTH (in_finfo, GST_VIDEO_COMP_Y,
5989                   in_width), GST_VIDEO_FORMAT_INFO_SCALE_WIDTH (out_finfo,
5990                   GST_VIDEO_COMP_Y, out_width), convert-&gt;config);
5991           uv_scaler =
5992               gst_video_scaler_new (method, GST_VIDEO_SCALER_FLAG_NONE,
5993               gst_video_scaler_get_max_taps (y_scaler),
5994               GST_VIDEO_FORMAT_INFO_SCALE_WIDTH (in_finfo, GST_VIDEO_COMP_U,
5995                   in_width), GST_VIDEO_FORMAT_INFO_SCALE_WIDTH (out_finfo,
</pre>
<hr />
<pre>
6010       convert-&gt;fin_x[0] = GST_ROUND_UP_2 (convert-&gt;in_x) * pstride;
6011       convert-&gt;fout_x[0] = GST_ROUND_UP_2 (convert-&gt;out_x) * pstride;
6012 
6013     } else {
6014       if (in_width != out_width &amp;&amp; in_width != 0 &amp;&amp; out_width != 0) {
6015         convert-&gt;fh_scaler[0].scaler = g_new (GstVideoScaler *, n_threads);
6016         for (j = 0; j &lt; n_threads; j++) {
6017           convert-&gt;fh_scaler[0].scaler[j] =
6018               gst_video_scaler_new (method, GST_VIDEO_SCALER_FLAG_NONE, taps,
6019               in_width, out_width, convert-&gt;config);
6020         }
6021       } else {
6022         convert-&gt;fh_scaler[0].scaler = NULL;
6023       }
6024 
6025       pstride = GST_VIDEO_FORMAT_INFO_PSTRIDE (out_finfo, GST_VIDEO_COMP_R);
6026       convert-&gt;fin_x[0] = convert-&gt;in_x * pstride;
6027       convert-&gt;fout_x[0] = convert-&gt;out_x * pstride;
6028     }
6029 
<span class="line-removed">6030     stride = MAX (stride, GST_VIDEO_INFO_PLANE_STRIDE (in_info, 0));</span>
<span class="line-removed">6031     stride = MAX (stride, GST_VIDEO_INFO_PLANE_STRIDE (out_info, 0));</span>
<span class="line-removed">6032 </span>
6033     if (in_height != out_height &amp;&amp; in_height != 0 &amp;&amp; out_height != 0) {
6034       convert-&gt;fv_scaler[0].scaler = g_new (GstVideoScaler *, n_threads);
6035 
6036       for (j = 0; j &lt; n_threads; j++) {
6037         convert-&gt;fv_scaler[0].scaler[j] =
6038             gst_video_scaler_new (method, GST_VIDEO_SCALER_FLAG_NONE, taps,
6039             in_height, out_height, convert-&gt;config);
6040       }
6041     } else {
6042       convert-&gt;fv_scaler[0].scaler = NULL;
6043     }
6044 
6045     convert-&gt;fin_y[0] = convert-&gt;in_y;
6046     convert-&gt;fout_y[0] = convert-&gt;out_y;
6047     convert-&gt;fout_width[0] = out_width;
6048     convert-&gt;fout_height[0] = out_height;
6049     convert-&gt;fconvert[0] = convert_plane_hv;
6050     convert-&gt;fformat[0] = get_scale_format (in_format, 0);
6051     convert-&gt;fsplane[0] = 0;
6052   } else {
6053     for (i = 0; i &lt; n_planes; i++) {
6054       gint comp, n_comp, j, iw, ih, ow, oh, pstride;
6055       gboolean need_v_scaler, need_h_scaler;
6056       GstStructure *config;
6057       gint resample_method;
6058 
6059       n_comp = GST_VIDEO_FORMAT_INFO_N_COMPONENTS (in_finfo);
6060 
6061       /* find the component in this plane and map it to the plane of
6062        * the source */
6063       comp = -1;
6064       for (j = 0; j &lt; n_comp; j++) {
6065         if (GST_VIDEO_FORMAT_INFO_PLANE (out_finfo, j) == i) {
6066           comp = j;
6067           break;
6068         }
6069       }
6070 
<span class="line-removed">6071       stride = MAX (stride, GST_VIDEO_INFO_COMP_STRIDE (in_info, i));</span>
<span class="line-removed">6072       stride = MAX (stride, GST_VIDEO_INFO_COMP_STRIDE (out_info, i));</span>
<span class="line-removed">6073 </span>
6074       iw = GST_VIDEO_FORMAT_INFO_SCALE_WIDTH (in_finfo, i, in_width);
6075       ih = GST_VIDEO_FORMAT_INFO_SCALE_HEIGHT (in_finfo, i, in_height);
6076       ow = GST_VIDEO_FORMAT_INFO_SCALE_WIDTH (out_finfo, i, out_width);
6077       oh = GST_VIDEO_FORMAT_INFO_SCALE_HEIGHT (out_finfo, i, out_height);
6078 
6079       GST_DEBUG (&quot;plane %d: %dx%d -&gt; %dx%d&quot;, i, iw, ih, ow, oh);
6080 
6081       convert-&gt;fout_width[i] = ow;
6082       convert-&gt;fout_height[i] = oh;
6083 
6084       pstride = GST_VIDEO_FORMAT_INFO_PSTRIDE (out_finfo, i);
6085       convert-&gt;fin_x[i] =
6086           GST_VIDEO_FORMAT_INFO_SCALE_WIDTH (in_finfo, i, convert-&gt;in_x);
6087       convert-&gt;fin_x[i] *= pstride;
6088       convert-&gt;fin_y[i] =
6089           GST_VIDEO_FORMAT_INFO_SCALE_HEIGHT (in_finfo, i, convert-&gt;in_y);
6090       convert-&gt;fout_x[i] =
6091           GST_VIDEO_FORMAT_INFO_SCALE_WIDTH (out_finfo, i, convert-&gt;out_x);
6092       convert-&gt;fout_x[i] *= pstride;
6093       convert-&gt;fout_y[i] =
</pre>
</td>
<td>
<hr />
<pre>
2063 
2064 static GstLineCache *
2065 chain_pack (GstVideoConverter * convert, GstLineCache * prev, gint idx)
2066 {
2067   convert-&gt;pack_nlines = convert-&gt;out_info.finfo-&gt;pack_lines;
2068   convert-&gt;pack_pstride = convert-&gt;current_pstride;
2069   convert-&gt;identity_pack =
2070       (convert-&gt;out_info.finfo-&gt;format ==
2071       convert-&gt;out_info.finfo-&gt;unpack_format);
2072   GST_DEBUG (&quot;chain pack line format %s, pstride %d, identity_pack %d (%d %d)&quot;,
2073       gst_video_format_to_string (convert-&gt;current_format),
2074       convert-&gt;current_pstride, convert-&gt;identity_pack,
2075       convert-&gt;out_info.finfo-&gt;format, convert-&gt;out_info.finfo-&gt;unpack_format);
2076 
2077   return prev;
2078 }
2079 
2080 static void
2081 setup_allocators (GstVideoConverter * convert)
2082 {
<span class="line-modified">2083   GstLineCache *cache, *prev;</span>
2084   GstLineCacheAllocLineFunc alloc_line;
2085   gboolean alloc_writable;
2086   gpointer user_data;
2087   GDestroyNotify notify;
<span class="line-modified">2088   gint width;</span>
2089   gint i;
2090 
2091   width = MAX (convert-&gt;in_maxwidth, convert-&gt;out_maxwidth);
2092   width += convert-&gt;out_x;
2093 
2094   for (i = 0; i &lt; convert-&gt;conversion_runner-&gt;n_threads; i++) {


2095     /* start with using dest lines if we can directly write into it */
2096     if (convert-&gt;identity_pack) {
2097       alloc_line = get_dest_line;
2098       alloc_writable = TRUE;
2099       user_data = convert;
2100       notify = NULL;
2101     } else {
2102       user_data =
2103           converter_alloc_new (sizeof (guint16) * width * 4, 4 + BACKLOG,
2104           convert, NULL);
2105       setup_border_alloc (convert, user_data);
2106       notify = (GDestroyNotify) converter_alloc_free;
2107       alloc_line = get_border_temp_line;
2108       /* when we add a border, we need to write */
2109       alloc_writable = convert-&gt;borderline != NULL;
2110     }
2111 
<span class="line-added">2112     /* First step, try to calculate how many temp lines we need. Go backwards,</span>
<span class="line-added">2113      * keep track of the maximum number of lines we need for each intermediate</span>
<span class="line-added">2114      * step.  */</span>
<span class="line-added">2115     for (prev = cache = convert-&gt;pack_lines[i]; cache; cache = cache-&gt;prev) {</span>
<span class="line-added">2116       GST_DEBUG (&quot;looking at cache %p, %d lines, %d backlog&quot;, cache,</span>
<span class="line-added">2117           cache-&gt;n_lines, cache-&gt;backlog);</span>
<span class="line-added">2118       prev-&gt;n_lines = MAX (prev-&gt;n_lines, cache-&gt;n_lines);</span>
<span class="line-added">2119       if (!cache-&gt;pass_alloc) {</span>
<span class="line-added">2120         GST_DEBUG (&quot;cache %p, needs %d lines&quot;, prev, prev-&gt;n_lines);</span>
<span class="line-added">2121         prev = cache;</span>
<span class="line-added">2122       }</span>
<span class="line-added">2123     }</span>
<span class="line-added">2124 </span>
2125     /* now walk backwards, we try to write into the dest lines directly
2126      * and keep track if the source needs to be writable */
2127     for (cache = convert-&gt;pack_lines[i]; cache; cache = cache-&gt;prev) {
2128       gst_line_cache_set_alloc_line_func (cache, alloc_line, user_data, notify);
2129       cache-&gt;alloc_writable = alloc_writable;

2130 
2131       /* make sure only one cache frees the allocator */
2132       notify = NULL;
2133 
2134       if (!cache-&gt;pass_alloc) {
2135         /* can&#39;t pass allocator, make new temp line allocator */
2136         user_data =
2137             converter_alloc_new (sizeof (guint16) * width * 4,
<span class="line-modified">2138             cache-&gt;n_lines + cache-&gt;backlog, convert, NULL);</span>
2139         notify = (GDestroyNotify) converter_alloc_free;
2140         alloc_line = get_temp_line;
2141         alloc_writable = FALSE;

2142       }
2143       /* if someone writes to the input, we need a writable line from the
2144        * previous cache */
2145       if (cache-&gt;write_input)
2146         alloc_writable = TRUE;
2147     }
2148     /* free leftover allocator */
2149     if (notify)
2150       notify (user_data);
2151   }
2152 }
2153 
2154 static void
2155 setup_borderline (GstVideoConverter * convert)
2156 {
2157   gint width;
2158 
2159   width = MAX (convert-&gt;in_maxwidth, convert-&gt;out_maxwidth);
2160   width += convert-&gt;out_x;
2161 
</pre>
<hr />
<pre>
5819     case GST_VIDEO_FORMAT_Y41B:
5820     case GST_VIDEO_FORMAT_Y42B:
5821     case GST_VIDEO_FORMAT_Y444:
5822     case GST_VIDEO_FORMAT_GRAY8:
5823     case GST_VIDEO_FORMAT_A420:
5824     case GST_VIDEO_FORMAT_YUV9:
5825     case GST_VIDEO_FORMAT_YVU9:
5826     case GST_VIDEO_FORMAT_GBR:
5827     case GST_VIDEO_FORMAT_GBRA:
5828       res = GST_VIDEO_FORMAT_GRAY8;
5829       break;
5830     case GST_VIDEO_FORMAT_GRAY16_BE:
5831     case GST_VIDEO_FORMAT_GRAY16_LE:
5832       res = GST_VIDEO_FORMAT_GRAY16_BE;
5833       break;
5834     case GST_VIDEO_FORMAT_YUY2:
5835     case GST_VIDEO_FORMAT_UYVY:
5836     case GST_VIDEO_FORMAT_VYUY:
5837     case GST_VIDEO_FORMAT_YVYU:
5838     case GST_VIDEO_FORMAT_AYUV:
<span class="line-added">5839     case GST_VIDEO_FORMAT_VUYA:</span>
5840     case GST_VIDEO_FORMAT_RGBx:
5841     case GST_VIDEO_FORMAT_BGRx:
5842     case GST_VIDEO_FORMAT_xRGB:
5843     case GST_VIDEO_FORMAT_xBGR:
5844     case GST_VIDEO_FORMAT_RGBA:
5845     case GST_VIDEO_FORMAT_BGRA:
5846     case GST_VIDEO_FORMAT_ARGB:
5847     case GST_VIDEO_FORMAT_ABGR:
5848     case GST_VIDEO_FORMAT_RGB:
5849     case GST_VIDEO_FORMAT_BGR:
5850     case GST_VIDEO_FORMAT_v308:
5851     case GST_VIDEO_FORMAT_IYU2:
5852     case GST_VIDEO_FORMAT_ARGB64:
5853     case GST_VIDEO_FORMAT_AYUV64:
5854       res = format;
5855       break;
5856     case GST_VIDEO_FORMAT_RGB15:
5857     case GST_VIDEO_FORMAT_BGR15:
5858     case GST_VIDEO_FORMAT_RGB16:
5859     case GST_VIDEO_FORMAT_BGR16:
5860       res = GST_VIDEO_FORMAT_NV12;
5861       break;
5862     case GST_VIDEO_FORMAT_NV12:
5863     case GST_VIDEO_FORMAT_NV21:
5864     case GST_VIDEO_FORMAT_NV16:
5865     case GST_VIDEO_FORMAT_NV61:
5866     case GST_VIDEO_FORMAT_NV24:
5867       res = plane == 0 ? GST_VIDEO_FORMAT_GRAY8 : GST_VIDEO_FORMAT_NV12;
5868       break;
5869     case GST_VIDEO_FORMAT_UNKNOWN:
5870     case GST_VIDEO_FORMAT_ENCODED:
5871     case GST_VIDEO_FORMAT_v210:
5872     case GST_VIDEO_FORMAT_v216:
<span class="line-added">5873     case GST_VIDEO_FORMAT_Y210:</span>
<span class="line-added">5874     case GST_VIDEO_FORMAT_Y410:</span>
5875     case GST_VIDEO_FORMAT_UYVP:
5876     case GST_VIDEO_FORMAT_RGB8P:
5877     case GST_VIDEO_FORMAT_IYU1:
5878     case GST_VIDEO_FORMAT_r210:
5879     case GST_VIDEO_FORMAT_I420_10BE:
5880     case GST_VIDEO_FORMAT_I420_10LE:
5881     case GST_VIDEO_FORMAT_I422_10BE:
5882     case GST_VIDEO_FORMAT_I422_10LE:
5883     case GST_VIDEO_FORMAT_Y444_10BE:
5884     case GST_VIDEO_FORMAT_Y444_10LE:
5885     case GST_VIDEO_FORMAT_I420_12BE:
5886     case GST_VIDEO_FORMAT_I420_12LE:
5887     case GST_VIDEO_FORMAT_I422_12BE:
5888     case GST_VIDEO_FORMAT_I422_12LE:
5889     case GST_VIDEO_FORMAT_Y444_12BE:
5890     case GST_VIDEO_FORMAT_Y444_12LE:
5891     case GST_VIDEO_FORMAT_GBR_10BE:
5892     case GST_VIDEO_FORMAT_GBR_10LE:
5893     case GST_VIDEO_FORMAT_GBRA_10BE:
5894     case GST_VIDEO_FORMAT_GBRA_10LE:
5895     case GST_VIDEO_FORMAT_GBR_12BE:
5896     case GST_VIDEO_FORMAT_GBR_12LE:
5897     case GST_VIDEO_FORMAT_GBRA_12BE:
5898     case GST_VIDEO_FORMAT_GBRA_12LE:
5899     case GST_VIDEO_FORMAT_NV12_64Z32:
5900     case GST_VIDEO_FORMAT_A420_10BE:
5901     case GST_VIDEO_FORMAT_A420_10LE:
5902     case GST_VIDEO_FORMAT_A422_10BE:
5903     case GST_VIDEO_FORMAT_A422_10LE:
5904     case GST_VIDEO_FORMAT_A444_10BE:
5905     case GST_VIDEO_FORMAT_A444_10LE:
5906     case GST_VIDEO_FORMAT_P010_10BE:
5907     case GST_VIDEO_FORMAT_P010_10LE:
5908     case GST_VIDEO_FORMAT_GRAY10_LE32:
5909     case GST_VIDEO_FORMAT_NV12_10LE32:
5910     case GST_VIDEO_FORMAT_NV16_10LE32:
<span class="line-added">5911     case GST_VIDEO_FORMAT_NV12_10LE40:</span>
<span class="line-added">5912     case GST_VIDEO_FORMAT_BGR10A2_LE:</span>
5913       res = format;
5914       g_assert_not_reached ();
5915       break;
5916   }
5917   return res;
5918 }
5919 
5920 static gboolean
5921 is_merge_yuv (GstVideoInfo * info)
5922 {
5923   switch (GST_VIDEO_INFO_FORMAT (info)) {
5924     case GST_VIDEO_FORMAT_YUY2:
5925     case GST_VIDEO_FORMAT_YVYU:
5926     case GST_VIDEO_FORMAT_UYVY:
5927     case GST_VIDEO_FORMAT_VYUY:
5928       return TRUE;
5929     default:
5930       return FALSE;
5931   }
5932 }
5933 
5934 static gboolean
5935 setup_scale (GstVideoConverter * convert)
5936 {
5937   int i, n_planes;
<span class="line-modified">5938   gint method, cr_method, in_width, in_height, out_width, out_height;</span>
5939   guint taps;
5940   GstVideoInfo *in_info, *out_info;
5941   const GstVideoFormatInfo *in_finfo, *out_finfo;
5942   GstVideoFormat in_format, out_format;
5943   guint n_threads = convert-&gt;conversion_runner-&gt;n_threads;
5944 
5945   in_info = &amp;convert-&gt;in_info;
5946   out_info = &amp;convert-&gt;out_info;
5947 
5948   in_finfo = in_info-&gt;finfo;
5949   out_finfo = out_info-&gt;finfo;
5950 
5951   n_planes = GST_VIDEO_INFO_N_PLANES (out_info);
5952 
5953   method = GET_OPT_RESAMPLER_METHOD (convert);
5954   if (method == GST_VIDEO_RESAMPLER_METHOD_NEAREST)
5955     cr_method = method;
5956   else
5957     cr_method = GET_OPT_CHROMA_RESAMPLER_METHOD (convert);
5958   taps = GET_OPT_RESAMPLER_TAPS (convert);
</pre>
<hr />
<pre>
5968 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
5969     case GST_VIDEO_FORMAT_GRAY16_BE:
5970 #else
5971     case GST_VIDEO_FORMAT_GRAY16_LE:
5972 #endif
5973       if (method != GST_VIDEO_RESAMPLER_METHOD_NEAREST) {
5974         GST_DEBUG (&quot;%s only with nearest resampling&quot;,
5975             gst_video_format_to_string (in_format));
5976         return FALSE;
5977       }
5978       break;
5979     default:
5980       break;
5981   }
5982 
5983   in_width = convert-&gt;in_width;
5984   in_height = convert-&gt;in_height;
5985   out_width = convert-&gt;out_width;
5986   out_height = convert-&gt;out_height;
5987 


5988   if (n_planes == 1 &amp;&amp; !GST_VIDEO_FORMAT_INFO_IS_GRAY (out_finfo)) {
5989     gint pstride;
5990     guint j;
5991 
5992     if (is_merge_yuv (in_info)) {
5993       GstVideoScaler *y_scaler, *uv_scaler;
5994 
5995       if (in_width != out_width) {
5996         convert-&gt;fh_scaler[0].scaler = g_new (GstVideoScaler *, n_threads);
5997         for (j = 0; j &lt; n_threads; j++) {
5998           y_scaler =
5999               gst_video_scaler_new (method, GST_VIDEO_SCALER_FLAG_NONE, taps,
6000               GST_VIDEO_FORMAT_INFO_SCALE_WIDTH (in_finfo, GST_VIDEO_COMP_Y,
6001                   in_width), GST_VIDEO_FORMAT_INFO_SCALE_WIDTH (out_finfo,
6002                   GST_VIDEO_COMP_Y, out_width), convert-&gt;config);
6003           uv_scaler =
6004               gst_video_scaler_new (method, GST_VIDEO_SCALER_FLAG_NONE,
6005               gst_video_scaler_get_max_taps (y_scaler),
6006               GST_VIDEO_FORMAT_INFO_SCALE_WIDTH (in_finfo, GST_VIDEO_COMP_U,
6007                   in_width), GST_VIDEO_FORMAT_INFO_SCALE_WIDTH (out_finfo,
</pre>
<hr />
<pre>
6022       convert-&gt;fin_x[0] = GST_ROUND_UP_2 (convert-&gt;in_x) * pstride;
6023       convert-&gt;fout_x[0] = GST_ROUND_UP_2 (convert-&gt;out_x) * pstride;
6024 
6025     } else {
6026       if (in_width != out_width &amp;&amp; in_width != 0 &amp;&amp; out_width != 0) {
6027         convert-&gt;fh_scaler[0].scaler = g_new (GstVideoScaler *, n_threads);
6028         for (j = 0; j &lt; n_threads; j++) {
6029           convert-&gt;fh_scaler[0].scaler[j] =
6030               gst_video_scaler_new (method, GST_VIDEO_SCALER_FLAG_NONE, taps,
6031               in_width, out_width, convert-&gt;config);
6032         }
6033       } else {
6034         convert-&gt;fh_scaler[0].scaler = NULL;
6035       }
6036 
6037       pstride = GST_VIDEO_FORMAT_INFO_PSTRIDE (out_finfo, GST_VIDEO_COMP_R);
6038       convert-&gt;fin_x[0] = convert-&gt;in_x * pstride;
6039       convert-&gt;fout_x[0] = convert-&gt;out_x * pstride;
6040     }
6041 



6042     if (in_height != out_height &amp;&amp; in_height != 0 &amp;&amp; out_height != 0) {
6043       convert-&gt;fv_scaler[0].scaler = g_new (GstVideoScaler *, n_threads);
6044 
6045       for (j = 0; j &lt; n_threads; j++) {
6046         convert-&gt;fv_scaler[0].scaler[j] =
6047             gst_video_scaler_new (method, GST_VIDEO_SCALER_FLAG_NONE, taps,
6048             in_height, out_height, convert-&gt;config);
6049       }
6050     } else {
6051       convert-&gt;fv_scaler[0].scaler = NULL;
6052     }
6053 
6054     convert-&gt;fin_y[0] = convert-&gt;in_y;
6055     convert-&gt;fout_y[0] = convert-&gt;out_y;
6056     convert-&gt;fout_width[0] = out_width;
6057     convert-&gt;fout_height[0] = out_height;
6058     convert-&gt;fconvert[0] = convert_plane_hv;
6059     convert-&gt;fformat[0] = get_scale_format (in_format, 0);
6060     convert-&gt;fsplane[0] = 0;
6061   } else {
6062     for (i = 0; i &lt; n_planes; i++) {
6063       gint comp, n_comp, j, iw, ih, ow, oh, pstride;
6064       gboolean need_v_scaler, need_h_scaler;
6065       GstStructure *config;
6066       gint resample_method;
6067 
6068       n_comp = GST_VIDEO_FORMAT_INFO_N_COMPONENTS (in_finfo);
6069 
6070       /* find the component in this plane and map it to the plane of
6071        * the source */
6072       comp = -1;
6073       for (j = 0; j &lt; n_comp; j++) {
6074         if (GST_VIDEO_FORMAT_INFO_PLANE (out_finfo, j) == i) {
6075           comp = j;
6076           break;
6077         }
6078       }
6079 



6080       iw = GST_VIDEO_FORMAT_INFO_SCALE_WIDTH (in_finfo, i, in_width);
6081       ih = GST_VIDEO_FORMAT_INFO_SCALE_HEIGHT (in_finfo, i, in_height);
6082       ow = GST_VIDEO_FORMAT_INFO_SCALE_WIDTH (out_finfo, i, out_width);
6083       oh = GST_VIDEO_FORMAT_INFO_SCALE_HEIGHT (out_finfo, i, out_height);
6084 
6085       GST_DEBUG (&quot;plane %d: %dx%d -&gt; %dx%d&quot;, i, iw, ih, ow, oh);
6086 
6087       convert-&gt;fout_width[i] = ow;
6088       convert-&gt;fout_height[i] = oh;
6089 
6090       pstride = GST_VIDEO_FORMAT_INFO_PSTRIDE (out_finfo, i);
6091       convert-&gt;fin_x[i] =
6092           GST_VIDEO_FORMAT_INFO_SCALE_WIDTH (in_finfo, i, convert-&gt;in_x);
6093       convert-&gt;fin_x[i] *= pstride;
6094       convert-&gt;fin_y[i] =
6095           GST_VIDEO_FORMAT_INFO_SCALE_HEIGHT (in_finfo, i, convert-&gt;in_y);
6096       convert-&gt;fout_x[i] =
6097           GST_VIDEO_FORMAT_INFO_SCALE_WIDTH (out_finfo, i, convert-&gt;out_x);
6098       convert-&gt;fout_x[i] *= pstride;
6099       convert-&gt;fout_y[i] =
</pre>
</td>
</tr>
</table>
<center><a href="video-color.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="video-converter.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>