<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gclosure.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GObject - GLib Type, Object, Parameter and Signal Library
   2  * Copyright (C) 2000-2001 Red Hat, Inc.
   3  * Copyright (C) 2005 Imendio AB
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General
  16  * Public License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  */
  18 
  19 /*
  20  * MT safe with regards to reference counting.
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 
  25 #include &quot;../glib/gvalgrind.h&quot;
  26 #include &lt;string.h&gt;
  27 
  28 #include &lt;ffi.h&gt;
  29 
  30 #include &quot;gclosure.h&quot;
  31 #include &quot;gboxed.h&quot;
  32 #include &quot;gobject.h&quot;
  33 #include &quot;genums.h&quot;
  34 #include &quot;gvalue.h&quot;
  35 #include &quot;gvaluetypes.h&quot;
  36 #include &quot;gtype-private.h&quot;
  37 
  38 
  39 /**
  40  * SECTION:gclosure
  41  * @short_description: Functions as first-class objects
  42  * @title: Closures
  43  *
  44  * A #GClosure represents a callback supplied by the programmer. It
  45  * will generally comprise a function of some kind and a marshaller
  46  * used to call it. It is the responsibility of the marshaller to
  47  * convert the arguments for the invocation from #GValues into
  48  * a suitable form, perform the callback on the converted arguments,
  49  * and transform the return value back into a #GValue.
  50  *
  51  * In the case of C programs, a closure usually just holds a pointer
  52  * to a function and maybe a data argument, and the marshaller
  53  * converts between #GValue and native C types. The GObject
  54  * library provides the #GCClosure type for this purpose. Bindings for
  55  * other languages need marshallers which convert between #GValues
  56  * and suitable representations in the runtime of the language in
  57  * order to use functions written in that language as callbacks. Use
  58  * g_closure_set_marshal() to set the marshaller on such a custom
  59  * closure implementation.
  60  *
  61  * Within GObject, closures play an important role in the
  62  * implementation of signals. When a signal is registered, the
  63  * @c_marshaller argument to g_signal_new() specifies the default C
  64  * marshaller for any closure which is connected to this
  65  * signal. GObject provides a number of C marshallers for this
  66  * purpose, see the g_cclosure_marshal_*() functions. Additional C
  67  * marshallers can be generated with the [glib-genmarshal][glib-genmarshal]
  68  * utility.  Closures can be explicitly connected to signals with
  69  * g_signal_connect_closure(), but it usually more convenient to let
  70  * GObject create a closure automatically by using one of the
  71  * g_signal_connect_*() functions which take a callback function/user
  72  * data pair.
  73  *
  74  * Using closures has a number of important advantages over a simple
  75  * callback function/data pointer combination:
  76  *
  77  * - Closures allow the callee to get the types of the callback parameters,
  78  *   which means that language bindings don&#39;t have to write individual glue
  79  *   for each callback type.
  80  *
  81  * - The reference counting of #GClosure makes it easy to handle reentrancy
  82  *   right; if a callback is removed while it is being invoked, the closure
  83  *   and its parameters won&#39;t be freed until the invocation finishes.
  84  *
  85  * - g_closure_invalidate() and invalidation notifiers allow callbacks to be
  86  *   automatically removed when the objects they point to go away.
  87  */
  88 
  89 #define CLOSURE_MAX_REF_COUNT       ((1 &lt;&lt; 15) - 1)
  90 #define CLOSURE_MAX_N_GUARDS        ((1 &lt;&lt; 1) - 1)
  91 #define CLOSURE_MAX_N_FNOTIFIERS    ((1 &lt;&lt; 2) - 1)
  92 #define CLOSURE_MAX_N_INOTIFIERS    ((1 &lt;&lt; 8) - 1)
  93 #define CLOSURE_N_MFUNCS(cl)        (((cl)-&gt;n_guards &lt;&lt; 1L))
  94 /* same as G_CLOSURE_N_NOTIFIERS() (keep in sync) */
  95 #define CLOSURE_N_NOTIFIERS(cl)     (CLOSURE_N_MFUNCS (cl) + \
  96                                          (cl)-&gt;n_fnotifiers + \
  97                                          (cl)-&gt;n_inotifiers)
  98 
  99 typedef union {
 100   GClosure closure;
 101   volatile gint vint;
 102 } ClosureInt;
 103 
 104 #define CHANGE_FIELD(_closure, _field, _OP, _value, _must_set, _SET_OLD, _SET_NEW)      \
 105 G_STMT_START {                                                                          \
 106   ClosureInt *cunion = (ClosureInt*) _closure;                                      \
 107   gint new_int, old_int, success;                                                   \
 108   do                                                                            \
 109     {                                                                           \
 110       ClosureInt tmp;                                                           \
 111       tmp.vint = old_int = cunion-&gt;vint;                                        \
 112       _SET_OLD tmp.closure._field;                                                      \
 113       tmp.closure._field _OP _value;                                            \
 114       _SET_NEW tmp.closure._field;                                                      \
 115       new_int = tmp.vint;                                                       \
 116       success = g_atomic_int_compare_and_exchange (&amp;cunion-&gt;vint, old_int, new_int);    \
 117     }                                                                           \
 118   while (!success &amp;&amp; _must_set);                                                        \
 119 } G_STMT_END
 120 
 121 #define SWAP(_closure, _field, _value, _oldv)   CHANGE_FIELD (_closure, _field, =, _value, TRUE, *(_oldv) =,     (void) )
 122 #define SET(_closure, _field, _value)           CHANGE_FIELD (_closure, _field, =, _value, TRUE,     (void),     (void) )
 123 #define INC(_closure, _field)                   CHANGE_FIELD (_closure, _field, +=,     1, TRUE,     (void),     (void) )
 124 #define INC_ASSIGN(_closure, _field, _newv)     CHANGE_FIELD (_closure, _field, +=,     1, TRUE,     (void), *(_newv) = )
 125 #define DEC(_closure, _field)                   CHANGE_FIELD (_closure, _field, -=,     1, TRUE,     (void),     (void) )
 126 #define DEC_ASSIGN(_closure, _field, _newv)     CHANGE_FIELD (_closure, _field, -=,     1, TRUE,     (void), *(_newv) = )
 127 
 128 #if 0   /* for non-thread-safe closures */
 129 #define SWAP(cl,f,v,o)     (void) (*(o) = cl-&gt;f, cl-&gt;f = v)
 130 #define SET(cl,f,v)        (void) (cl-&gt;f = v)
 131 #define INC(cl,f)          (void) (cl-&gt;f += 1)
 132 #define INC_ASSIGN(cl,f,n) (void) (cl-&gt;f += 1, *(n) = cl-&gt;f)
 133 #define DEC(cl,f)          (void) (cl-&gt;f -= 1)
 134 #define DEC_ASSIGN(cl,f,n) (void) (cl-&gt;f -= 1, *(n) = cl-&gt;f)
 135 #endif
 136 
 137 enum {
 138   FNOTIFY,
 139   INOTIFY,
 140   PRE_NOTIFY,
 141   POST_NOTIFY
 142 };
 143 
 144 
 145 /* --- functions --- */
 146 /**
 147  * g_closure_new_simple:
 148  * @sizeof_closure: the size of the structure to allocate, must be at least
 149  *                  `sizeof (GClosure)`
 150  * @data: data to store in the @data field of the newly allocated #GClosure
 151  *
 152  * Allocates a struct of the given size and initializes the initial
 153  * part as a #GClosure. This function is mainly useful when
 154  * implementing new types of closures.
 155  *
 156  * |[&lt;!-- language=&quot;C&quot; --&gt;
 157  * typedef struct _MyClosure MyClosure;
 158  * struct _MyClosure
 159  * {
 160  *   GClosure closure;
 161  *   // extra data goes here
 162  * };
 163  *
 164  * static void
 165  * my_closure_finalize (gpointer  notify_data,
 166  *                      GClosure *closure)
 167  * {
 168  *   MyClosure *my_closure = (MyClosure *)closure;
 169  *
 170  *   // free extra data here
 171  * }
 172  *
 173  * MyClosure *my_closure_new (gpointer data)
 174  * {
 175  *   GClosure *closure;
 176  *   MyClosure *my_closure;
 177  *
 178  *   closure = g_closure_new_simple (sizeof (MyClosure), data);
 179  *   my_closure = (MyClosure *) closure;
 180  *
 181  *   // initialize extra data here
 182  *
 183  *   g_closure_add_finalize_notifier (closure, notify_data,
 184  *                                    my_closure_finalize);
 185  *   return my_closure;
 186  * }
 187  * ]|
 188  *
 189  * Returns: (transfer none): a floating reference to a new #GClosure
 190  */
 191 GClosure*
 192 g_closure_new_simple (guint           sizeof_closure,
 193               gpointer        data)
 194 {
 195   GClosure *closure;
 196   gint private_size;
 197   gchar *allocated;
 198 
 199   g_return_val_if_fail (sizeof_closure &gt;= sizeof (GClosure), NULL);
 200 
 201   private_size = sizeof (GRealClosure) - sizeof (GClosure);
 202 
 203 #ifdef ENABLE_VALGRIND
 204   /* See comments in gtype.c about what&#39;s going on here... */
 205   if (RUNNING_ON_VALGRIND)
 206     {
 207       private_size += sizeof (gpointer);
 208 
 209       allocated = g_malloc0 (private_size + sizeof_closure + sizeof (gpointer));
 210 #ifdef GSTREAMER_LITE
 211       if (allocated == NULL)
 212         return NULL;
 213 #endif // GSTREAMER_LITE
 214 
 215       *(gpointer *) (allocated + private_size + sizeof_closure) = allocated + sizeof (gpointer);
 216 
 217       VALGRIND_MALLOCLIKE_BLOCK (allocated + private_size, sizeof_closure + sizeof (gpointer), 0, TRUE);
 218       VALGRIND_MALLOCLIKE_BLOCK (allocated + sizeof (gpointer), private_size - sizeof (gpointer), 0, TRUE);
 219     }
 220   else
 221 #endif
 222     allocated = g_malloc0 (private_size + sizeof_closure);
 223 #ifdef GSTREAMER_LITE
 224     if (allocated == NULL)
 225       return NULL;
 226 #endif // GSTREAMER_LITE
 227 
 228   closure = (GClosure *) (allocated + private_size);
 229 
 230   SET (closure, ref_count, 1);
 231   SET (closure, floating, TRUE);
 232   closure-&gt;data = data;
 233 
 234   return closure;
 235 }
 236 
 237 static inline void
 238 closure_invoke_notifiers (GClosure *closure,
 239               guint     notify_type)
 240 {
 241   /* notifier layout:
 242    *     n_guards    n_guards     n_fnotif.  n_inotifiers
 243    * -&gt;[[pre_guards][post_guards][fnotifiers][inotifiers]]
 244    *
 245    * CLOSURE_N_MFUNCS(cl)    = n_guards + n_guards;
 246    * CLOSURE_N_NOTIFIERS(cl) = CLOSURE_N_MFUNCS(cl) + n_fnotifiers + n_inotifiers
 247    *
 248    * constrains/catches:
 249    * - closure-&gt;notifiers may be reloacted during callback
 250    * - closure-&gt;n_fnotifiers and closure-&gt;n_inotifiers may change during callback
 251    * - i.e. callbacks can be removed/added during invocation
 252    * - must prepare for callback removal during FNOTIFY and INOTIFY (done via -&gt;marshal= &amp; -&gt;data=)
 253    * - must distinguish (-&gt;marshal= &amp; -&gt;data=) for INOTIFY vs. FNOTIFY (via -&gt;in_inotify)
 254    * + closure-&gt;n_guards is const during PRE_NOTIFY &amp; POST_NOTIFY
 255    * + none of the callbacks can cause recursion
 256    * + closure-&gt;n_inotifiers is const 0 during FNOTIFY
 257    */
 258   switch (notify_type)
 259     {
 260       GClosureNotifyData *ndata;
 261       guint i, offs;
 262     case FNOTIFY:
 263       while (closure-&gt;n_fnotifiers)
 264     {
 265           guint n;
 266       DEC_ASSIGN (closure, n_fnotifiers, &amp;n);
 267 
 268       ndata = closure-&gt;notifiers + CLOSURE_N_MFUNCS (closure) + n;
 269       closure-&gt;marshal = (GClosureMarshal) ndata-&gt;notify;
 270       closure-&gt;data = ndata-&gt;data;
 271       ndata-&gt;notify (ndata-&gt;data, closure);
 272     }
 273       closure-&gt;marshal = NULL;
 274       closure-&gt;data = NULL;
 275       break;
 276     case INOTIFY:
 277       SET (closure, in_inotify, TRUE);
 278       while (closure-&gt;n_inotifiers)
 279     {
 280           guint n;
 281           DEC_ASSIGN (closure, n_inotifiers, &amp;n);
 282 
 283       ndata = closure-&gt;notifiers + CLOSURE_N_MFUNCS (closure) + closure-&gt;n_fnotifiers + n;
 284       closure-&gt;marshal = (GClosureMarshal) ndata-&gt;notify;
 285       closure-&gt;data = ndata-&gt;data;
 286       ndata-&gt;notify (ndata-&gt;data, closure);
 287     }
 288       closure-&gt;marshal = NULL;
 289       closure-&gt;data = NULL;
 290       SET (closure, in_inotify, FALSE);
 291       break;
 292     case PRE_NOTIFY:
 293       i = closure-&gt;n_guards;
 294       offs = 0;
 295       while (i--)
 296     {
 297       ndata = closure-&gt;notifiers + offs + i;
 298       ndata-&gt;notify (ndata-&gt;data, closure);
 299     }
 300       break;
 301     case POST_NOTIFY:
 302       i = closure-&gt;n_guards;
 303       offs = i;
 304       while (i--)
 305     {
 306       ndata = closure-&gt;notifiers + offs + i;
 307       ndata-&gt;notify (ndata-&gt;data, closure);
 308     }
 309       break;
 310     }
 311 }
 312 
 313 static void
 314 g_closure_set_meta_va_marshal (GClosure       *closure,
 315                    GVaClosureMarshal va_meta_marshal)
 316 {
 317   GRealClosure *real_closure;
 318 
 319   g_return_if_fail (closure != NULL);
 320   g_return_if_fail (va_meta_marshal != NULL);
 321   g_return_if_fail (closure-&gt;is_invalid == FALSE);
 322   g_return_if_fail (closure-&gt;in_marshal == FALSE);
 323 
 324   real_closure = G_REAL_CLOSURE (closure);
 325 
 326   g_return_if_fail (real_closure-&gt;meta_marshal != NULL);
 327 
 328   real_closure-&gt;va_meta_marshal = va_meta_marshal;
 329 }
 330 
 331 /**
 332  * g_closure_set_meta_marshal: (skip)
 333  * @closure: a #GClosure
 334  * @marshal_data: (closure meta_marshal): context-dependent data to pass
 335  *  to @meta_marshal
 336  * @meta_marshal: a #GClosureMarshal function
 337  *
 338  * Sets the meta marshaller of @closure.  A meta marshaller wraps
 339  * @closure-&gt;marshal and modifies the way it is called in some
 340  * fashion. The most common use of this facility is for C callbacks.
 341  * The same marshallers (generated by [glib-genmarshal][glib-genmarshal]),
 342  * are used everywhere, but the way that we get the callback function
 343  * differs. In most cases we want to use @closure-&gt;callback, but in
 344  * other cases we want to use some different technique to retrieve the
 345  * callback function.
 346  *
 347  * For example, class closures for signals (see
 348  * g_signal_type_cclosure_new()) retrieve the callback function from a
 349  * fixed offset in the class structure.  The meta marshaller retrieves
 350  * the right callback and passes it to the marshaller as the
 351  * @marshal_data argument.
 352  */
 353 void
 354 g_closure_set_meta_marshal (GClosure       *closure,
 355                 gpointer        marshal_data,
 356                 GClosureMarshal meta_marshal)
 357 {
 358   GRealClosure *real_closure;
 359 
 360   g_return_if_fail (closure != NULL);
 361   g_return_if_fail (meta_marshal != NULL);
 362   g_return_if_fail (closure-&gt;is_invalid == FALSE);
 363   g_return_if_fail (closure-&gt;in_marshal == FALSE);
 364 
 365   real_closure = G_REAL_CLOSURE (closure);
 366 
 367   g_return_if_fail (real_closure-&gt;meta_marshal == NULL);
 368 
 369   real_closure-&gt;meta_marshal = meta_marshal;
 370   real_closure-&gt;meta_marshal_data = marshal_data;
 371 }
 372 
 373 /**
 374  * g_closure_add_marshal_guards: (skip)
 375  * @closure: a #GClosure
 376  * @pre_marshal_data: (closure pre_marshal_notify): data to pass
 377  *  to @pre_marshal_notify
 378  * @pre_marshal_notify: a function to call before the closure callback
 379  * @post_marshal_data: (closure post_marshal_notify): data to pass
 380  *  to @post_marshal_notify
 381  * @post_marshal_notify: a function to call after the closure callback
 382  *
 383  * Adds a pair of notifiers which get invoked before and after the
 384  * closure callback, respectively. This is typically used to protect
 385  * the extra arguments for the duration of the callback. See
 386  * g_object_watch_closure() for an example of marshal guards.
 387  */
 388 void
 389 g_closure_add_marshal_guards (GClosure      *closure,
 390                   gpointer       pre_marshal_data,
 391                   GClosureNotify pre_marshal_notify,
 392                   gpointer       post_marshal_data,
 393                   GClosureNotify post_marshal_notify)
 394 {
 395   guint i;
 396 
 397   g_return_if_fail (closure != NULL);
 398   g_return_if_fail (pre_marshal_notify != NULL);
 399   g_return_if_fail (post_marshal_notify != NULL);
 400   g_return_if_fail (closure-&gt;is_invalid == FALSE);
 401   g_return_if_fail (closure-&gt;in_marshal == FALSE);
 402   g_return_if_fail (closure-&gt;n_guards &lt; CLOSURE_MAX_N_GUARDS);
 403 
 404   closure-&gt;notifiers = g_renew (GClosureNotifyData, closure-&gt;notifiers, CLOSURE_N_NOTIFIERS (closure) + 2);
 405   if (closure-&gt;n_inotifiers)
 406     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
 407             closure-&gt;n_fnotifiers +
 408             closure-&gt;n_inotifiers + 1)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
 409                                       closure-&gt;n_fnotifiers + 0)];
 410   if (closure-&gt;n_inotifiers &gt; 1)
 411     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
 412             closure-&gt;n_fnotifiers +
 413             closure-&gt;n_inotifiers)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
 414                                       closure-&gt;n_fnotifiers + 1)];
 415   if (closure-&gt;n_fnotifiers)
 416     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
 417             closure-&gt;n_fnotifiers + 1)] = closure-&gt;notifiers[CLOSURE_N_MFUNCS (closure) + 0];
 418   if (closure-&gt;n_fnotifiers &gt; 1)
 419     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
 420             closure-&gt;n_fnotifiers)] = closure-&gt;notifiers[CLOSURE_N_MFUNCS (closure) + 1];
 421   if (closure-&gt;n_guards)
 422     closure-&gt;notifiers[(closure-&gt;n_guards +
 423             closure-&gt;n_guards + 1)] = closure-&gt;notifiers[closure-&gt;n_guards];
 424   i = closure-&gt;n_guards;
 425   closure-&gt;notifiers[i].data = pre_marshal_data;
 426   closure-&gt;notifiers[i].notify = pre_marshal_notify;
 427   closure-&gt;notifiers[i + 1].data = post_marshal_data;
 428   closure-&gt;notifiers[i + 1].notify = post_marshal_notify;
 429   INC (closure, n_guards);
 430 }
 431 
 432 /**
 433  * g_closure_add_finalize_notifier: (skip)
 434  * @closure: a #GClosure
 435  * @notify_data: (closure notify_func): data to pass to @notify_func
 436  * @notify_func: the callback function to register
 437  *
 438  * Registers a finalization notifier which will be called when the
 439  * reference count of @closure goes down to 0. Multiple finalization
 440  * notifiers on a single closure are invoked in unspecified order. If
 441  * a single call to g_closure_unref() results in the closure being
 442  * both invalidated and finalized, then the invalidate notifiers will
 443  * be run before the finalize notifiers.
 444  */
 445 void
 446 g_closure_add_finalize_notifier (GClosure      *closure,
 447                  gpointer       notify_data,
 448                  GClosureNotify notify_func)
 449 {
 450   guint i;
 451 
 452   g_return_if_fail (closure != NULL);
 453   g_return_if_fail (notify_func != NULL);
 454   g_return_if_fail (closure-&gt;n_fnotifiers &lt; CLOSURE_MAX_N_FNOTIFIERS);
 455 
 456   closure-&gt;notifiers = g_renew (GClosureNotifyData, closure-&gt;notifiers, CLOSURE_N_NOTIFIERS (closure) + 1);
 457   if (closure-&gt;n_inotifiers)
 458     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
 459             closure-&gt;n_fnotifiers +
 460             closure-&gt;n_inotifiers)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
 461                                       closure-&gt;n_fnotifiers + 0)];
 462   i = CLOSURE_N_MFUNCS (closure) + closure-&gt;n_fnotifiers;
 463   closure-&gt;notifiers[i].data = notify_data;
 464   closure-&gt;notifiers[i].notify = notify_func;
 465   INC (closure, n_fnotifiers);
 466 }
 467 
 468 /**
 469  * g_closure_add_invalidate_notifier: (skip)
 470  * @closure: a #GClosure
 471  * @notify_data: (closure notify_func): data to pass to @notify_func
 472  * @notify_func: the callback function to register
 473  *
 474  * Registers an invalidation notifier which will be called when the
 475  * @closure is invalidated with g_closure_invalidate(). Invalidation
 476  * notifiers are invoked before finalization notifiers, in an
 477  * unspecified order.
 478  */
 479 void
 480 g_closure_add_invalidate_notifier (GClosure      *closure,
 481                    gpointer       notify_data,
 482                    GClosureNotify notify_func)
 483 {
 484   guint i;
 485 
 486   g_return_if_fail (closure != NULL);
 487   g_return_if_fail (notify_func != NULL);
 488   g_return_if_fail (closure-&gt;is_invalid == FALSE);
 489   g_return_if_fail (closure-&gt;n_inotifiers &lt; CLOSURE_MAX_N_INOTIFIERS);
 490 
 491   closure-&gt;notifiers = g_renew (GClosureNotifyData, closure-&gt;notifiers, CLOSURE_N_NOTIFIERS (closure) + 1);
 492   i = CLOSURE_N_MFUNCS (closure) + closure-&gt;n_fnotifiers + closure-&gt;n_inotifiers;
 493   closure-&gt;notifiers[i].data = notify_data;
 494   closure-&gt;notifiers[i].notify = notify_func;
 495   INC (closure, n_inotifiers);
 496 }
 497 
 498 static inline gboolean
 499 closure_try_remove_inotify (GClosure       *closure,
 500                 gpointer       notify_data,
 501                 GClosureNotify notify_func)
 502 {
 503   GClosureNotifyData *ndata, *nlast;
 504 
 505   nlast = closure-&gt;notifiers + CLOSURE_N_NOTIFIERS (closure) - 1;
 506   for (ndata = nlast + 1 - closure-&gt;n_inotifiers; ndata &lt;= nlast; ndata++)
 507     if (ndata-&gt;notify == notify_func &amp;&amp; ndata-&gt;data == notify_data)
 508       {
 509     DEC (closure, n_inotifiers);
 510     if (ndata &lt; nlast)
 511       *ndata = *nlast;
 512 
 513     return TRUE;
 514       }
 515   return FALSE;
 516 }
 517 
 518 static inline gboolean
 519 closure_try_remove_fnotify (GClosure       *closure,
 520                 gpointer       notify_data,
 521                 GClosureNotify notify_func)
 522 {
 523   GClosureNotifyData *ndata, *nlast;
 524 
 525   nlast = closure-&gt;notifiers + CLOSURE_N_NOTIFIERS (closure) - closure-&gt;n_inotifiers - 1;
 526   for (ndata = nlast + 1 - closure-&gt;n_fnotifiers; ndata &lt;= nlast; ndata++)
 527     if (ndata-&gt;notify == notify_func &amp;&amp; ndata-&gt;data == notify_data)
 528       {
 529     DEC (closure, n_fnotifiers);
 530     if (ndata &lt; nlast)
 531       *ndata = *nlast;
 532     if (closure-&gt;n_inotifiers)
 533       closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
 534                   closure-&gt;n_fnotifiers)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
 535                                         closure-&gt;n_fnotifiers +
 536                                         closure-&gt;n_inotifiers)];
 537     return TRUE;
 538       }
 539   return FALSE;
 540 }
 541 
 542 /**
 543  * g_closure_ref:
 544  * @closure: #GClosure to increment the reference count on
 545  *
 546  * Increments the reference count on a closure to force it staying
 547  * alive while the caller holds a pointer to it.
 548  *
 549  * Returns: (transfer none): The @closure passed in, for convenience
 550  */
 551 GClosure*
 552 g_closure_ref (GClosure *closure)
 553 {
 554   guint new_ref_count;
 555   g_return_val_if_fail (closure != NULL, NULL);
 556   g_return_val_if_fail (closure-&gt;ref_count &gt; 0, NULL);
 557   g_return_val_if_fail (closure-&gt;ref_count &lt; CLOSURE_MAX_REF_COUNT, NULL);
 558 
 559   INC_ASSIGN (closure, ref_count, &amp;new_ref_count);
 560   g_return_val_if_fail (new_ref_count &gt; 1, NULL);
 561 
 562   return closure;
 563 }
 564 
 565 /**
 566  * g_closure_invalidate:
 567  * @closure: GClosure to invalidate
 568  *
 569  * Sets a flag on the closure to indicate that its calling
 570  * environment has become invalid, and thus causes any future
 571  * invocations of g_closure_invoke() on this @closure to be
 572  * ignored. Also, invalidation notifiers installed on the closure will
 573  * be called at this point. Note that unless you are holding a
 574  * reference to the closure yourself, the invalidation notifiers may
 575  * unref the closure and cause it to be destroyed, so if you need to
 576  * access the closure after calling g_closure_invalidate(), make sure
 577  * that you&#39;ve previously called g_closure_ref().
 578  *
 579  * Note that g_closure_invalidate() will also be called when the
 580  * reference count of a closure drops to zero (unless it has already
 581  * been invalidated before).
 582  */
 583 void
 584 g_closure_invalidate (GClosure *closure)
 585 {
 586   g_return_if_fail (closure != NULL);
 587 
 588   if (!closure-&gt;is_invalid)
 589     {
 590       gboolean was_invalid;
 591       g_closure_ref (closure);           /* preserve floating flag */
 592       SWAP (closure, is_invalid, TRUE, &amp;was_invalid);
 593       /* invalidate only once */
 594       if (!was_invalid)
 595         closure_invoke_notifiers (closure, INOTIFY);
 596       g_closure_unref (closure);
 597     }
 598 }
 599 
 600 /**
 601  * g_closure_unref:
 602  * @closure: #GClosure to decrement the reference count on
 603  *
 604  * Decrements the reference count of a closure after it was previously
 605  * incremented by the same caller. If no other callers are using the
 606  * closure, then the closure will be destroyed and freed.
 607  */
 608 void
 609 g_closure_unref (GClosure *closure)
 610 {
 611   guint new_ref_count;
 612 
 613   g_return_if_fail (closure != NULL);
 614   g_return_if_fail (closure-&gt;ref_count &gt; 0);
 615 
 616   if (closure-&gt;ref_count == 1)  /* last unref, invalidate first */
 617     g_closure_invalidate (closure);
 618 
 619   DEC_ASSIGN (closure, ref_count, &amp;new_ref_count);
 620 
 621   if (new_ref_count == 0)
 622     {
 623       closure_invoke_notifiers (closure, FNOTIFY);
 624       g_free (closure-&gt;notifiers);
 625 
 626 #ifdef GSTREAMER_LITE
 627 #ifdef ENABLE_VALGRIND
 628       /* See comments in gtype.c about what&#39;s going on here... */
 629       if (RUNNING_ON_VALGRIND)
 630         {
 631           gchar *allocated;
 632 
 633           allocated = (gchar *) G_REAL_CLOSURE (closure);
 634           allocated -= sizeof (gpointer);
 635 
 636           g_free (allocated);
 637 
 638           VALGRIND_FREELIKE_BLOCK (allocated + sizeof (gpointer), 0);
 639           VALGRIND_FREELIKE_BLOCK (closure, 0);
 640         }
 641       else
 642         g_free (G_REAL_CLOSURE (closure));
 643 #endif // ENABLE_VALGRIND
 644 #endif // GSTREAMER_LITE
 645 
 646 #ifndef GSTREAMER_LITE
 647       /* See comments in gtype.c about what&#39;s going on here... */
 648       if (RUNNING_ON_VALGRIND)
 649         {
 650           gchar *allocated;
 651 
 652           allocated = (gchar *) G_REAL_CLOSURE (closure);
 653           allocated -= sizeof (gpointer);
 654 
 655           g_free (allocated);
 656 
 657           VALGRIND_FREELIKE_BLOCK (allocated + sizeof (gpointer), 0);
 658           VALGRIND_FREELIKE_BLOCK (closure, 0);
 659         }
 660       else
 661         g_free (G_REAL_CLOSURE (closure));
 662 #endif // GSTREAMER_LITE
 663     }
 664 }
 665 
 666 /**
 667  * g_closure_sink:
 668  * @closure: #GClosure to decrement the initial reference count on, if it&#39;s
 669  *           still being held
 670  *
 671  * Takes over the initial ownership of a closure.  Each closure is
 672  * initially created in a &quot;floating&quot; state, which means that the initial
 673  * reference count is not owned by any caller. g_closure_sink() checks
 674  * to see if the object is still floating, and if so, unsets the
 675  * floating state and decreases the reference count. If the closure
 676  * is not floating, g_closure_sink() does nothing. The reason for the
 677  * existence of the floating state is to prevent cumbersome code
 678  * sequences like:
 679  * |[&lt;!-- language=&quot;C&quot; --&gt;
 680  * closure = g_cclosure_new (cb_func, cb_data);
 681  * g_source_set_closure (source, closure);
 682  * g_closure_unref (closure); // GObject doesn&#39;t really need this
 683  * ]|
 684  * Because g_source_set_closure() (and similar functions) take ownership of the
 685  * initial reference count, if it is unowned, we instead can write:
 686  * |[&lt;!-- language=&quot;C&quot; --&gt;
 687  * g_source_set_closure (source, g_cclosure_new (cb_func, cb_data));
 688  * ]|
 689  *
 690  * Generally, this function is used together with g_closure_ref(). Ane example
 691  * of storing a closure for later notification looks like:
 692  * |[&lt;!-- language=&quot;C&quot; --&gt;
 693  * static GClosure *notify_closure = NULL;
 694  * void
 695  * foo_notify_set_closure (GClosure *closure)
 696  * {
 697  *   if (notify_closure)
 698  *     g_closure_unref (notify_closure);
 699  *   notify_closure = closure;
 700  *   if (notify_closure)
 701  *     {
 702  *       g_closure_ref (notify_closure);
 703  *       g_closure_sink (notify_closure);
 704  *     }
 705  * }
 706  * ]|
 707  *
 708  * Because g_closure_sink() may decrement the reference count of a closure
 709  * (if it hasn&#39;t been called on @closure yet) just like g_closure_unref(),
 710  * g_closure_ref() should be called prior to this function.
 711  */
 712 void
 713 g_closure_sink (GClosure *closure)
 714 {
 715   g_return_if_fail (closure != NULL);
 716   g_return_if_fail (closure-&gt;ref_count &gt; 0);
 717 
 718   /* floating is basically a kludge to avoid creating closures
 719    * with a ref_count of 0. so the initial ref_count a closure has
 720    * is unowned. with invoking g_closure_sink() code may
 721    * indicate that it takes over that intiial ref_count.
 722    */
 723   if (closure-&gt;floating)
 724     {
 725       gboolean was_floating;
 726       SWAP (closure, floating, FALSE, &amp;was_floating);
 727       /* unref floating flag only once */
 728       if (was_floating)
 729         g_closure_unref (closure);
 730     }
 731 }
 732 
 733 /**
 734  * g_closure_remove_invalidate_notifier: (skip)
 735  * @closure: a #GClosure
 736  * @notify_data: data which was passed to g_closure_add_invalidate_notifier()
 737  *               when registering @notify_func
 738  * @notify_func: the callback function to remove
 739  *
 740  * Removes an invalidation notifier.
 741  *
 742  * Notice that notifiers are automatically removed after they are run.
 743  */
 744 void
 745 g_closure_remove_invalidate_notifier (GClosure      *closure,
 746                       gpointer       notify_data,
 747                       GClosureNotify notify_func)
 748 {
 749   g_return_if_fail (closure != NULL);
 750   g_return_if_fail (notify_func != NULL);
 751 
 752   if (closure-&gt;is_invalid &amp;&amp; closure-&gt;in_inotify &amp;&amp; /* account removal of notify_func() while it&#39;s called */
 753       ((gpointer) closure-&gt;marshal) == ((gpointer) notify_func) &amp;&amp;
 754       closure-&gt;data == notify_data)
 755     closure-&gt;marshal = NULL;
 756   else if (!closure_try_remove_inotify (closure, notify_data, notify_func))
 757     g_warning (G_STRLOC &quot;: unable to remove uninstalled invalidation notifier: %p (%p)&quot;,
 758            notify_func, notify_data);
 759 }
 760 
 761 /**
 762  * g_closure_remove_finalize_notifier: (skip)
 763  * @closure: a #GClosure
 764  * @notify_data: data which was passed to g_closure_add_finalize_notifier()
 765  *  when registering @notify_func
 766  * @notify_func: the callback function to remove
 767  *
 768  * Removes a finalization notifier.
 769  *
 770  * Notice that notifiers are automatically removed after they are run.
 771  */
 772 void
 773 g_closure_remove_finalize_notifier (GClosure      *closure,
 774                     gpointer       notify_data,
 775                     GClosureNotify notify_func)
 776 {
 777   g_return_if_fail (closure != NULL);
 778   g_return_if_fail (notify_func != NULL);
 779 
 780   if (closure-&gt;is_invalid &amp;&amp; !closure-&gt;in_inotify &amp;&amp; /* account removal of notify_func() while it&#39;s called */
 781       ((gpointer) closure-&gt;marshal) == ((gpointer) notify_func) &amp;&amp;
 782       closure-&gt;data == notify_data)
 783     closure-&gt;marshal = NULL;
 784   else if (!closure_try_remove_fnotify (closure, notify_data, notify_func))
 785     g_warning (G_STRLOC &quot;: unable to remove uninstalled finalization notifier: %p (%p)&quot;,
 786                notify_func, notify_data);
 787 }
 788 
 789 /**
 790  * g_closure_invoke:
 791  * @closure: a #GClosure
 792  * @return_value: (optional) (out): a #GValue to store the return
 793  *                value. May be %NULL if the callback of @closure
 794  *                doesn&#39;t return a value.
 795  * @n_param_values: the length of the @param_values array
 796  * @param_values: (array length=n_param_values): an array of
 797  *                #GValues holding the arguments on which to
 798  *                invoke the callback of @closure
 799  * @invocation_hint: (nullable): a context-dependent invocation hint
 800  *
 801  * Invokes the closure, i.e. executes the callback represented by the @closure.
 802  */
 803 void
 804 g_closure_invoke (GClosure       *closure,
 805           GValue /*out*/ *return_value,
 806           guint           n_param_values,
 807           const GValue   *param_values,
 808           gpointer        invocation_hint)
 809 {
 810   GRealClosure *real_closure;
 811 
 812   g_return_if_fail (closure != NULL);
 813 
 814   real_closure = G_REAL_CLOSURE (closure);
 815 
 816   g_closure_ref (closure);      /* preserve floating flag */
 817   if (!closure-&gt;is_invalid)
 818     {
 819       GClosureMarshal marshal;
 820       gpointer marshal_data;
 821       gboolean in_marshal = closure-&gt;in_marshal;
 822 
 823       g_return_if_fail (closure-&gt;marshal || real_closure-&gt;meta_marshal);
 824 
 825       SET (closure, in_marshal, TRUE);
 826       if (real_closure-&gt;meta_marshal)
 827     {
 828       marshal_data = real_closure-&gt;meta_marshal_data;
 829       marshal = real_closure-&gt;meta_marshal;
 830     }
 831       else
 832     {
 833       marshal_data = NULL;
 834       marshal = closure-&gt;marshal;
 835     }
 836       if (!in_marshal)
 837     closure_invoke_notifiers (closure, PRE_NOTIFY);
 838       marshal (closure,
 839            return_value,
 840            n_param_values, param_values,
 841            invocation_hint,
 842            marshal_data);
 843       if (!in_marshal)
 844     closure_invoke_notifiers (closure, POST_NOTIFY);
 845       SET (closure, in_marshal, in_marshal);
 846     }
 847   g_closure_unref (closure);
 848 }
 849 
 850 gboolean
 851 _g_closure_supports_invoke_va (GClosure       *closure)
 852 {
 853   GRealClosure *real_closure;
 854 
 855   g_return_val_if_fail (closure != NULL, FALSE);
 856 
 857   real_closure = G_REAL_CLOSURE (closure);
 858 
 859   return
 860     real_closure-&gt;va_marshal != NULL &amp;&amp;
 861     (real_closure-&gt;meta_marshal == NULL ||
 862      real_closure-&gt;va_meta_marshal != NULL);
 863 }
 864 
 865 void
 866 _g_closure_invoke_va (GClosure       *closure,
 867               GValue /*out*/ *return_value,
 868               gpointer        instance,
 869               va_list         args,
 870               int             n_params,
 871               GType          *param_types)
 872 {
 873   GRealClosure *real_closure;
 874 
 875   g_return_if_fail (closure != NULL);
 876 
 877   real_closure = G_REAL_CLOSURE (closure);
 878 
 879   g_closure_ref (closure);      /* preserve floating flag */
 880   if (!closure-&gt;is_invalid)
 881     {
 882       GVaClosureMarshal marshal;
 883       gpointer marshal_data;
 884       gboolean in_marshal = closure-&gt;in_marshal;
 885 
 886       g_return_if_fail (closure-&gt;marshal || real_closure-&gt;meta_marshal);
 887 
 888       SET (closure, in_marshal, TRUE);
 889       if (real_closure-&gt;va_meta_marshal)
 890     {
 891       marshal_data = real_closure-&gt;meta_marshal_data;
 892       marshal = real_closure-&gt;va_meta_marshal;
 893     }
 894       else
 895     {
 896       marshal_data = NULL;
 897       marshal = real_closure-&gt;va_marshal;
 898     }
 899       if (!in_marshal)
 900     closure_invoke_notifiers (closure, PRE_NOTIFY);
 901       marshal (closure,
 902            return_value,
 903            instance, args,
 904            marshal_data,
 905            n_params, param_types);
 906       if (!in_marshal)
 907     closure_invoke_notifiers (closure, POST_NOTIFY);
 908       SET (closure, in_marshal, in_marshal);
 909     }
 910   g_closure_unref (closure);
 911 }
 912 
 913 
 914 /**
 915  * g_closure_set_marshal: (skip)
 916  * @closure: a #GClosure
 917  * @marshal: a #GClosureMarshal function
 918  *
 919  * Sets the marshaller of @closure. The `marshal_data`
 920  * of @marshal provides a way for a meta marshaller to provide additional
 921  * information to the marshaller. (See g_closure_set_meta_marshal().) For
 922  * GObject&#39;s C predefined marshallers (the g_cclosure_marshal_*()
 923  * functions), what it provides is a callback function to use instead of
 924  * @closure-&gt;callback.
 925  */
 926 void
 927 g_closure_set_marshal (GClosure       *closure,
 928                GClosureMarshal marshal)
 929 {
 930   g_return_if_fail (closure != NULL);
 931   g_return_if_fail (marshal != NULL);
 932 
 933   if (closure-&gt;marshal &amp;&amp; closure-&gt;marshal != marshal)
 934     g_warning (&quot;attempt to override closure-&gt;marshal (%p) with new marshal (%p)&quot;,
 935            closure-&gt;marshal, marshal);
 936   else
 937     closure-&gt;marshal = marshal;
 938 }
 939 
 940 void
 941 _g_closure_set_va_marshal (GClosure       *closure,
 942                GVaClosureMarshal marshal)
 943 {
 944   GRealClosure *real_closure;
 945 
 946   g_return_if_fail (closure != NULL);
 947   g_return_if_fail (marshal != NULL);
 948 
 949   real_closure = G_REAL_CLOSURE (closure);
 950 
 951   if (real_closure-&gt;va_marshal &amp;&amp; real_closure-&gt;va_marshal != marshal)
 952     g_warning (&quot;attempt to override closure-&gt;va_marshal (%p) with new marshal (%p)&quot;,
 953            real_closure-&gt;va_marshal, marshal);
 954   else
 955     real_closure-&gt;va_marshal = marshal;
 956 }
 957 
 958 /**
 959  * g_cclosure_new: (skip)
 960  * @callback_func: the function to invoke
 961  * @user_data: (closure callback_func): user data to pass to @callback_func
 962  * @destroy_data: destroy notify to be called when @user_data is no longer used
 963  *
 964  * Creates a new closure which invokes @callback_func with @user_data as
 965  * the last parameter.
 966  *
 967  * Returns: (transfer none): a floating reference to a new #GCClosure
 968  */
 969 GClosure*
 970 g_cclosure_new (GCallback      callback_func,
 971         gpointer       user_data,
 972         GClosureNotify destroy_data)
 973 {
 974   GClosure *closure;
 975 
 976   g_return_val_if_fail (callback_func != NULL, NULL);
 977 
 978   closure = g_closure_new_simple (sizeof (GCClosure), user_data);
 979 #ifdef GSTREAMER_LITE
 980   if (closure == NULL)
 981     return NULL;
 982 #endif // GSTREAMER_LITE
 983   if (destroy_data)
 984     g_closure_add_finalize_notifier (closure, user_data, destroy_data);
 985   ((GCClosure*) closure)-&gt;callback = (gpointer) callback_func;
 986 
 987   return closure;
 988 }
 989 
 990 /**
 991  * g_cclosure_new_swap: (skip)
 992  * @callback_func: the function to invoke
 993  * @user_data: (closure callback_func): user data to pass to @callback_func
 994  * @destroy_data: destroy notify to be called when @user_data is no longer used
 995  *
 996  * Creates a new closure which invokes @callback_func with @user_data as
 997  * the first parameter.
 998  *
 999  * Returns: (transfer none): a floating reference to a new #GCClosure
1000  */
1001 GClosure*
1002 g_cclosure_new_swap (GCallback      callback_func,
1003              gpointer       user_data,
1004              GClosureNotify destroy_data)
1005 {
1006   GClosure *closure;
1007 
1008   g_return_val_if_fail (callback_func != NULL, NULL);
1009 
1010   closure = g_closure_new_simple (sizeof (GCClosure), user_data);
1011 #ifdef GSTREAMER_LITE
1012   if (closure == NULL)
1013     return NULL;
1014 #endif // GSTREAMER_LITE
1015   if (destroy_data)
1016     g_closure_add_finalize_notifier (closure, user_data, destroy_data);
1017   ((GCClosure*) closure)-&gt;callback = (gpointer) callback_func;
1018   SET (closure, derivative_flag, TRUE);
1019 
1020   return closure;
1021 }
1022 
1023 static void
1024 g_type_class_meta_marshal (GClosure       *closure,
1025                GValue /*out*/ *return_value,
1026                guint           n_param_values,
1027                const GValue   *param_values,
1028                gpointer        invocation_hint,
1029                gpointer        marshal_data)
1030 {
1031   GTypeClass *class;
1032   gpointer callback;
1033   /* GType itype = (GType) closure-&gt;data; */
1034   guint offset = GPOINTER_TO_UINT (marshal_data);
1035 
1036   class = G_TYPE_INSTANCE_GET_CLASS (g_value_peek_pointer (param_values + 0), itype, GTypeClass);
1037   callback = G_STRUCT_MEMBER (gpointer, class, offset);
1038   if (callback)
1039     closure-&gt;marshal (closure,
1040               return_value,
1041               n_param_values, param_values,
1042               invocation_hint,
1043               callback);
1044 }
1045 
1046 static void
1047 g_type_class_meta_marshalv (GClosure *closure,
1048                 GValue   *return_value,
1049                 gpointer  instance,
1050                 va_list   args,
1051                 gpointer  marshal_data,
1052                 int       n_params,
1053                 GType    *param_types)
1054 {
1055   GRealClosure *real_closure;
1056   GTypeClass *class;
1057   gpointer callback;
1058   /* GType itype = (GType) closure-&gt;data; */
1059   guint offset = GPOINTER_TO_UINT (marshal_data);
1060 
1061   real_closure = G_REAL_CLOSURE (closure);
1062 
1063   class = G_TYPE_INSTANCE_GET_CLASS (instance, itype, GTypeClass);
1064   callback = G_STRUCT_MEMBER (gpointer, class, offset);
1065   if (callback)
1066     real_closure-&gt;va_marshal (closure,
1067                   return_value,
1068                   instance, args,
1069                   callback,
1070                   n_params,
1071                   param_types);
1072 }
1073 
1074 static void
1075 g_type_iface_meta_marshal (GClosure       *closure,
1076                GValue /*out*/ *return_value,
1077                guint           n_param_values,
1078                const GValue   *param_values,
1079                gpointer        invocation_hint,
1080                gpointer        marshal_data)
1081 {
1082   GTypeClass *class;
1083   gpointer callback;
1084   GType itype = (GType) closure-&gt;data;
1085   guint offset = GPOINTER_TO_UINT (marshal_data);
1086 
1087   class = G_TYPE_INSTANCE_GET_INTERFACE (g_value_peek_pointer (param_values + 0), itype, GTypeClass);
1088   callback = G_STRUCT_MEMBER (gpointer, class, offset);
1089   if (callback)
1090     closure-&gt;marshal (closure,
1091               return_value,
1092               n_param_values, param_values,
1093               invocation_hint,
1094               callback);
1095 }
1096 
1097 gboolean
1098 _g_closure_is_void (GClosure *closure,
1099             gpointer instance)
1100 {
1101   GRealClosure *real_closure;
1102   GTypeClass *class;
1103   gpointer callback;
1104   GType itype;
1105   guint offset;
1106 
1107   if (closure-&gt;is_invalid)
1108     return TRUE;
1109 
1110   real_closure = G_REAL_CLOSURE (closure);
1111 
1112   if (real_closure-&gt;meta_marshal == g_type_iface_meta_marshal)
1113     {
1114       itype = (GType) closure-&gt;data;
1115       offset = GPOINTER_TO_UINT (real_closure-&gt;meta_marshal_data);
1116 
1117       class = G_TYPE_INSTANCE_GET_INTERFACE (instance, itype, GTypeClass);
1118       callback = G_STRUCT_MEMBER (gpointer, class, offset);
1119       return callback == NULL;
1120     }
1121   else if (real_closure-&gt;meta_marshal == g_type_class_meta_marshal)
1122     {
1123       offset = GPOINTER_TO_UINT (real_closure-&gt;meta_marshal_data);
1124 
1125       class = G_TYPE_INSTANCE_GET_CLASS (instance, itype, GTypeClass);
1126       callback = G_STRUCT_MEMBER (gpointer, class, offset);
1127       return callback == NULL;
1128     }
1129 
1130   return FALSE;
1131 }
1132 
1133 static void
1134 g_type_iface_meta_marshalv (GClosure *closure,
1135                 GValue   *return_value,
1136                 gpointer  instance,
1137                 va_list   args,
1138                 gpointer  marshal_data,
1139                 int       n_params,
1140                 GType    *param_types)
1141 {
1142   GRealClosure *real_closure;
1143   GTypeClass *class;
1144   gpointer callback;
1145   GType itype = (GType) closure-&gt;data;
1146   guint offset = GPOINTER_TO_UINT (marshal_data);
1147 
1148   real_closure = G_REAL_CLOSURE (closure);
1149 
1150   class = G_TYPE_INSTANCE_GET_INTERFACE (instance, itype, GTypeClass);
1151   callback = G_STRUCT_MEMBER (gpointer, class, offset);
1152   if (callback)
1153     real_closure-&gt;va_marshal (closure,
1154                   return_value,
1155                   instance, args,
1156                   callback,
1157                   n_params,
1158                   param_types);
1159 }
1160 
1161 /**
1162  * g_signal_type_cclosure_new:
1163  * @itype: the #GType identifier of an interface or classed type
1164  * @struct_offset: the offset of the member function of @itype&#39;s class
1165  *  structure which is to be invoked by the new closure
1166  *
1167  * Creates a new closure which invokes the function found at the offset
1168  * @struct_offset in the class structure of the interface or classed type
1169  * identified by @itype.
1170  *
1171  * Returns: (transfer none): a floating reference to a new #GCClosure
1172  */
1173 GClosure*
1174 g_signal_type_cclosure_new (GType    itype,
1175                 guint    struct_offset)
1176 {
1177   GClosure *closure;
1178 
1179   g_return_val_if_fail (G_TYPE_IS_CLASSED (itype) || G_TYPE_IS_INTERFACE (itype), NULL);
1180   g_return_val_if_fail (struct_offset &gt;= sizeof (GTypeClass), NULL);
1181 
1182   closure = g_closure_new_simple (sizeof (GClosure), (gpointer) itype);
1183   if (G_TYPE_IS_INTERFACE (itype))
1184     {
1185       g_closure_set_meta_marshal (closure, GUINT_TO_POINTER (struct_offset), g_type_iface_meta_marshal);
1186       g_closure_set_meta_va_marshal (closure, g_type_iface_meta_marshalv);
1187     }
1188   else
1189     {
1190       g_closure_set_meta_marshal (closure, GUINT_TO_POINTER (struct_offset), g_type_class_meta_marshal);
1191       g_closure_set_meta_va_marshal (closure, g_type_class_meta_marshalv);
1192     }
1193   return closure;
1194 }
1195 
1196 #include &lt;ffi.h&gt;
1197 static ffi_type *
1198 value_to_ffi_type (const GValue *gvalue,
1199                    gpointer *value,
1200                    gint *enum_tmpval,
1201                    gboolean *tmpval_used)
1202 {
1203   ffi_type *rettype = NULL;
1204   GType type = g_type_fundamental (G_VALUE_TYPE (gvalue));
1205   g_assert (type != G_TYPE_INVALID);
1206 
1207   if (enum_tmpval)
1208     {
1209       g_assert (tmpval_used != NULL);
1210       *tmpval_used = FALSE;
1211     }
1212 
1213   switch (type)
1214     {
1215     case G_TYPE_BOOLEAN:
1216     case G_TYPE_CHAR:
1217     case G_TYPE_INT:
1218       rettype = &amp;ffi_type_sint;
1219       *value = (gpointer)&amp;(gvalue-&gt;data[0].v_int);
1220       break;
1221     case G_TYPE_ENUM:
1222       /* enums are stored in v_long even though they are integers, which makes
1223        * marshalling through libffi somewhat complicated.  They need to be
1224        * marshalled as signed ints, but we need to use a temporary int sized
1225        * value to pass to libffi otherwise it&#39;ll pull the wrong value on
1226        * BE machines with 32-bit integers when treating v_long as 32-bit int.
1227        */
1228       g_assert (enum_tmpval != NULL);
1229       rettype = &amp;ffi_type_sint;
1230       *enum_tmpval = g_value_get_enum (gvalue);
1231       *value = enum_tmpval;
1232       *tmpval_used = TRUE;
1233       break;
1234     case G_TYPE_FLAGS:
1235       g_assert (enum_tmpval != NULL);
1236       rettype = &amp;ffi_type_uint;
1237       *enum_tmpval = g_value_get_flags (gvalue);
1238       *value = enum_tmpval;
1239       *tmpval_used = TRUE;
1240       break;
1241     case G_TYPE_UCHAR:
1242     case G_TYPE_UINT:
1243       rettype = &amp;ffi_type_uint;
1244       *value = (gpointer)&amp;(gvalue-&gt;data[0].v_uint);
1245       break;
1246     case G_TYPE_STRING:
1247     case G_TYPE_OBJECT:
1248     case G_TYPE_BOXED:
1249     case G_TYPE_PARAM:
1250     case G_TYPE_POINTER:
1251     case G_TYPE_INTERFACE:
1252     case G_TYPE_VARIANT:
1253       rettype = &amp;ffi_type_pointer;
1254       *value = (gpointer)&amp;(gvalue-&gt;data[0].v_pointer);
1255       break;
1256     case G_TYPE_FLOAT:
1257       rettype = &amp;ffi_type_float;
1258       *value = (gpointer)&amp;(gvalue-&gt;data[0].v_float);
1259       break;
1260     case G_TYPE_DOUBLE:
1261       rettype = &amp;ffi_type_double;
1262       *value = (gpointer)&amp;(gvalue-&gt;data[0].v_double);
1263       break;
1264     case G_TYPE_LONG:
1265       rettype = &amp;ffi_type_slong;
1266       *value = (gpointer)&amp;(gvalue-&gt;data[0].v_long);
1267       break;
1268     case G_TYPE_ULONG:
1269       rettype = &amp;ffi_type_ulong;
1270       *value = (gpointer)&amp;(gvalue-&gt;data[0].v_ulong);
1271       break;
1272     case G_TYPE_INT64:
1273       rettype = &amp;ffi_type_sint64;
1274       *value = (gpointer)&amp;(gvalue-&gt;data[0].v_int64);
1275       break;
1276     case G_TYPE_UINT64:
1277       rettype = &amp;ffi_type_uint64;
1278       *value = (gpointer)&amp;(gvalue-&gt;data[0].v_uint64);
1279       break;
1280     default:
1281       rettype = &amp;ffi_type_pointer;
1282       *value = NULL;
1283       g_warning (&quot;value_to_ffi_type: Unsupported fundamental type: %s&quot;, g_type_name (type));
1284       break;
1285     }
1286   return rettype;
1287 }
1288 
1289 static void
1290 value_from_ffi_type (GValue *gvalue, gpointer *value)
1291 {
1292   ffi_arg *int_val = (ffi_arg*) value;
1293 
1294   switch (g_type_fundamental (G_VALUE_TYPE (gvalue)))
1295     {
1296     case G_TYPE_INT:
1297       g_value_set_int (gvalue, (gint) *int_val);
1298       break;
1299     case G_TYPE_FLOAT:
1300       g_value_set_float (gvalue, *(gfloat*)value);
1301       break;
1302     case G_TYPE_DOUBLE:
1303       g_value_set_double (gvalue, *(gdouble*)value);
1304       break;
1305     case G_TYPE_BOOLEAN:
1306       g_value_set_boolean (gvalue, (gboolean) *int_val);
1307       break;
1308     case G_TYPE_STRING:
1309       g_value_take_string (gvalue, *(gchar**)value);
1310       break;
1311     case G_TYPE_CHAR:
1312       g_value_set_schar (gvalue, (gint8) *int_val);
1313       break;
1314     case G_TYPE_UCHAR:
1315       g_value_set_uchar (gvalue, (guchar) *int_val);
1316       break;
1317     case G_TYPE_UINT:
1318       g_value_set_uint (gvalue, (guint) *int_val);
1319       break;
1320     case G_TYPE_POINTER:
1321       g_value_set_pointer (gvalue, *(gpointer*)value);
1322       break;
1323     case G_TYPE_LONG:
1324       g_value_set_long (gvalue, (glong) *int_val);
1325       break;
1326     case G_TYPE_ULONG:
1327       g_value_set_ulong (gvalue, (gulong) *int_val);
1328       break;
1329     case G_TYPE_INT64:
1330       g_value_set_int64 (gvalue, (gint64) *int_val);
1331       break;
1332     case G_TYPE_UINT64:
1333       g_value_set_uint64 (gvalue, (guint64) *int_val);
1334       break;
1335     case G_TYPE_BOXED:
1336       g_value_take_boxed (gvalue, *(gpointer*)value);
1337       break;
1338     case G_TYPE_ENUM:
1339       g_value_set_enum (gvalue, (gint) *int_val);
1340       break;
1341     case G_TYPE_FLAGS:
1342       g_value_set_flags (gvalue, (guint) *int_val);
1343       break;
1344     case G_TYPE_PARAM:
1345       g_value_take_param (gvalue, *(gpointer*)value);
1346       break;
1347     case G_TYPE_OBJECT:
1348       g_value_take_object (gvalue, *(gpointer*)value);
1349       break;
1350     case G_TYPE_VARIANT:
1351       g_value_take_variant (gvalue, *(gpointer*)value);
1352       break;
1353     default:
1354       g_warning (&quot;value_from_ffi_type: Unsupported fundamental type: %s&quot;,
1355                 g_type_name (g_type_fundamental (G_VALUE_TYPE (gvalue))));
1356     }
1357 }
1358 
1359 typedef union {
1360   gpointer _gpointer;
1361   float _float;
1362   double _double;
1363   gint _gint;
1364   guint _guint;
1365   glong _glong;
1366   gulong _gulong;
1367   gint64 _gint64;
1368   guint64 _guint64;
1369 } va_arg_storage;
1370 
1371 static ffi_type *
1372 va_to_ffi_type (GType gtype,
1373         va_list *va,
1374         va_arg_storage *storage)
1375 {
1376   ffi_type *rettype = NULL;
1377   GType type = g_type_fundamental (gtype);
1378   g_assert (type != G_TYPE_INVALID);
1379 
1380   switch (type)
1381     {
1382     case G_TYPE_BOOLEAN:
1383     case G_TYPE_CHAR:
1384     case G_TYPE_INT:
1385     case G_TYPE_ENUM:
1386       rettype = &amp;ffi_type_sint;
1387       storage-&gt;_gint = va_arg (*va, gint);
1388       break;
1389     case G_TYPE_UCHAR:
1390     case G_TYPE_UINT:
1391     case G_TYPE_FLAGS:
1392       rettype = &amp;ffi_type_uint;
1393       storage-&gt;_guint = va_arg (*va, guint);
1394       break;
1395     case G_TYPE_STRING:
1396     case G_TYPE_OBJECT:
1397     case G_TYPE_BOXED:
1398     case G_TYPE_PARAM:
1399     case G_TYPE_POINTER:
1400     case G_TYPE_INTERFACE:
1401     case G_TYPE_VARIANT:
1402       rettype = &amp;ffi_type_pointer;
1403       storage-&gt;_gpointer = va_arg (*va, gpointer);
1404       break;
1405     case G_TYPE_FLOAT:
1406       /* Float args are passed as doubles in varargs */
1407       rettype = &amp;ffi_type_float;
1408       storage-&gt;_float = (float)va_arg (*va, double);
1409       break;
1410     case G_TYPE_DOUBLE:
1411       rettype = &amp;ffi_type_double;
1412       storage-&gt;_double = va_arg (*va, double);
1413       break;
1414     case G_TYPE_LONG:
1415       rettype = &amp;ffi_type_slong;
1416       storage-&gt;_glong = va_arg (*va, glong);
1417       break;
1418     case G_TYPE_ULONG:
1419       rettype = &amp;ffi_type_ulong;
1420       storage-&gt;_gulong = va_arg (*va, gulong);
1421       break;
1422     case G_TYPE_INT64:
1423       rettype = &amp;ffi_type_sint64;
1424       storage-&gt;_gint64 = va_arg (*va, gint64);
1425       break;
1426     case G_TYPE_UINT64:
1427       rettype = &amp;ffi_type_uint64;
1428       storage-&gt;_guint64 = va_arg (*va, guint64);
1429       break;
1430     default:
1431       rettype = &amp;ffi_type_pointer;
1432       storage-&gt;_guint64  = 0;
1433       g_warning (&quot;va_to_ffi_type: Unsupported fundamental type: %s&quot;, g_type_name (type));
1434       break;
1435     }
1436   return rettype;
1437 }
1438 
1439 /**
1440  * g_cclosure_marshal_generic:
1441  * @closure: A #GClosure.
1442  * @return_gvalue: A #GValue to store the return value. May be %NULL
1443  *   if the callback of closure doesn&#39;t return a value.
1444  * @n_param_values: The length of the @param_values array.
1445  * @param_values: An array of #GValues holding the arguments
1446  *   on which to invoke the callback of closure.
1447  * @invocation_hint: The invocation hint given as the last argument to
1448  *   g_closure_invoke().
1449  * @marshal_data: Additional data specified when registering the
1450  *   marshaller, see g_closure_set_marshal() and
1451  *   g_closure_set_meta_marshal()
1452  *
1453  * A generic marshaller function implemented via
1454  * [libffi](http://sourceware.org/libffi/).
1455  *
1456  * Normally this function is not passed explicitly to g_signal_new(),
1457  * but used automatically by GLib when specifying a %NULL marshaller.
1458  *
1459  * Since: 2.30
1460  */
1461 void
1462 g_cclosure_marshal_generic (GClosure     *closure,
1463                             GValue       *return_gvalue,
1464                             guint         n_param_values,
1465                             const GValue *param_values,
1466                             gpointer      invocation_hint,
1467                             gpointer      marshal_data)
1468 {
1469   ffi_type *rtype;
1470   void *rvalue;
1471   int n_args;
1472   ffi_type **atypes;
1473   void **args;
1474   int i;
1475   ffi_cif cif;
1476   GCClosure *cc = (GCClosure*) closure;
1477   gint *enum_tmpval;
1478   gboolean tmpval_used = FALSE;
1479 
1480   enum_tmpval = g_alloca (sizeof (gint));
1481   if (return_gvalue &amp;&amp; G_VALUE_TYPE (return_gvalue))
1482     {
1483       rtype = value_to_ffi_type (return_gvalue, &amp;rvalue, enum_tmpval, &amp;tmpval_used);
1484     }
1485   else
1486     {
1487       rtype = &amp;ffi_type_void;
1488     }
1489 
1490   rvalue = g_alloca (MAX (rtype-&gt;size, sizeof (ffi_arg)));
1491 
1492   n_args = n_param_values + 1;
1493   atypes = g_alloca (sizeof (ffi_type *) * n_args);
1494   args =  g_alloca (sizeof (gpointer) * n_args);
1495 
1496   if (tmpval_used)
1497     enum_tmpval = g_alloca (sizeof (gint));
1498 
1499   if (G_CCLOSURE_SWAP_DATA (closure))
1500     {
1501       atypes[n_args-1] = value_to_ffi_type (param_values + 0,
1502                                             &amp;args[n_args-1],
1503                                             enum_tmpval,
1504                                             &amp;tmpval_used);
1505       atypes[0] = &amp;ffi_type_pointer;
1506       args[0] = &amp;closure-&gt;data;
1507     }
1508   else
1509     {
1510       atypes[0] = value_to_ffi_type (param_values + 0,
1511                                      &amp;args[0],
1512                                      enum_tmpval,
1513                                      &amp;tmpval_used);
1514       atypes[n_args-1] = &amp;ffi_type_pointer;
1515       args[n_args-1] = &amp;closure-&gt;data;
1516     }
1517 
1518   for (i = 1; i &lt; n_args - 1; i++)
1519     {
1520       if (tmpval_used)
1521         enum_tmpval = g_alloca (sizeof (gint));
1522 
1523       atypes[i] = value_to_ffi_type (param_values + i,
1524                                      &amp;args[i],
1525                                      enum_tmpval,
1526                                      &amp;tmpval_used);
1527     }
1528 
1529   if (ffi_prep_cif (&amp;cif, FFI_DEFAULT_ABI, n_args, rtype, atypes) != FFI_OK)
1530     return;
1531 
1532   ffi_call (&amp;cif, marshal_data ? marshal_data : cc-&gt;callback, rvalue, args);
1533 
1534   if (return_gvalue &amp;&amp; G_VALUE_TYPE (return_gvalue))
1535     value_from_ffi_type (return_gvalue, rvalue);
1536 }
1537 
1538 /**
1539  * g_cclosure_marshal_generic_va:
1540  * @closure: the #GClosure to which the marshaller belongs
1541  * @return_value: (nullable): a #GValue to store the return
1542  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
1543  *  value.
1544  * @instance: (type GObject.TypeInstance): the instance on which the closure is
1545  *  invoked.
1546  * @args_list: va_list of arguments to be passed to the closure.
1547  * @marshal_data: (nullable): additional data specified when
1548  *  registering the marshaller, see g_closure_set_marshal() and
1549  *  g_closure_set_meta_marshal()
1550  * @n_params: the length of the @param_types array
1551  * @param_types: (array length=n_params): the #GType of each argument from
1552  *  @args_list.
1553  *
1554  * A generic #GVaClosureMarshal function implemented via
1555  * [libffi](http://sourceware.org/libffi/).
1556  *
1557  * Since: 2.30
1558  */
1559 void
1560 g_cclosure_marshal_generic_va (GClosure *closure,
1561                    GValue   *return_value,
1562                    gpointer  instance,
1563                    va_list   args_list,
1564                    gpointer  marshal_data,
1565                    int       n_params,
1566                    GType    *param_types)
1567 {
1568   ffi_type *rtype;
1569   void *rvalue;
1570   int n_args;
1571   ffi_type **atypes;
1572   void **args;
1573   va_arg_storage *storage;
1574   int i;
1575   ffi_cif cif;
1576   GCClosure *cc = (GCClosure*) closure;
1577   gint *enum_tmpval;
1578   gboolean tmpval_used = FALSE;
1579   va_list args_copy;
1580 
1581   enum_tmpval = g_alloca (sizeof (gint));
1582   if (return_value &amp;&amp; G_VALUE_TYPE (return_value))
1583     {
1584       rtype = value_to_ffi_type (return_value, &amp;rvalue, enum_tmpval, &amp;tmpval_used);
1585     }
1586   else
1587     {
1588       rtype = &amp;ffi_type_void;
1589     }
1590 
1591   rvalue = g_alloca (MAX (rtype-&gt;size, sizeof (ffi_arg)));
1592 
1593   n_args = n_params + 2;
1594   atypes = g_alloca (sizeof (ffi_type *) * n_args);
1595   args =  g_alloca (sizeof (gpointer) * n_args);
1596   storage = g_alloca (sizeof (va_arg_storage) * n_params);
1597 
1598   if (G_CCLOSURE_SWAP_DATA (closure))
1599     {
1600       atypes[n_args-1] = &amp;ffi_type_pointer;
1601       args[n_args-1] = &amp;instance;
1602       atypes[0] = &amp;ffi_type_pointer;
1603       args[0] = &amp;closure-&gt;data;
1604     }
1605   else
1606     {
1607       atypes[0] = &amp;ffi_type_pointer;
1608       args[0] = &amp;instance;
1609       atypes[n_args-1] = &amp;ffi_type_pointer;
1610       args[n_args-1] = &amp;closure-&gt;data;
1611     }
1612 
1613   G_VA_COPY (args_copy, args_list);
1614 
1615   /* Box non-primitive arguments */
1616   for (i = 0; i &lt; n_params; i++)
1617     {
1618       GType type = param_types[i]  &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
1619       GType fundamental = G_TYPE_FUNDAMENTAL (type);
1620 
1621       atypes[i+1] = va_to_ffi_type (type,
1622                     &amp;args_copy,
1623                     &amp;storage[i]);
1624       args[i+1] = &amp;storage[i];
1625 
1626       if ((param_types[i]  &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0)
1627     {
1628       if (fundamental == G_TYPE_STRING &amp;&amp; storage[i]._gpointer != NULL)
1629         storage[i]._gpointer = g_strdup (storage[i]._gpointer);
1630       else if (fundamental == G_TYPE_PARAM &amp;&amp; storage[i]._gpointer != NULL)
1631         storage[i]._gpointer = g_param_spec_ref (storage[i]._gpointer);
1632       else if (fundamental == G_TYPE_BOXED &amp;&amp; storage[i]._gpointer != NULL)
1633         storage[i]._gpointer = g_boxed_copy (type, storage[i]._gpointer);
1634       else if (fundamental == G_TYPE_VARIANT &amp;&amp; storage[i]._gpointer != NULL)
1635         storage[i]._gpointer = g_variant_ref_sink (storage[i]._gpointer);
1636     }
1637       if (fundamental == G_TYPE_OBJECT &amp;&amp; storage[i]._gpointer != NULL)
1638     storage[i]._gpointer = g_object_ref (storage[i]._gpointer);
1639     }
1640 
1641   va_end (args_copy);
1642 
1643   if (ffi_prep_cif (&amp;cif, FFI_DEFAULT_ABI, n_args, rtype, atypes) != FFI_OK)
1644     return;
1645 
1646   ffi_call (&amp;cif, marshal_data ? marshal_data : cc-&gt;callback, rvalue, args);
1647 
1648   /* Unbox non-primitive arguments */
1649   for (i = 0; i &lt; n_params; i++)
1650     {
1651       GType type = param_types[i]  &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
1652       GType fundamental = G_TYPE_FUNDAMENTAL (type);
1653 
1654       if ((param_types[i]  &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0)
1655     {
1656       if (fundamental == G_TYPE_STRING &amp;&amp; storage[i]._gpointer != NULL)
1657         g_free (storage[i]._gpointer);
1658       else if (fundamental == G_TYPE_PARAM &amp;&amp; storage[i]._gpointer != NULL)
1659         g_param_spec_unref (storage[i]._gpointer);
1660       else if (fundamental == G_TYPE_BOXED &amp;&amp; storage[i]._gpointer != NULL)
1661         g_boxed_free (type, storage[i]._gpointer);
1662       else if (fundamental == G_TYPE_VARIANT &amp;&amp; storage[i]._gpointer != NULL)
1663         g_variant_unref (storage[i]._gpointer);
1664     }
1665       if (fundamental == G_TYPE_OBJECT &amp;&amp; storage[i]._gpointer != NULL)
1666     g_object_unref (storage[i]._gpointer);
1667     }
1668 
1669   if (return_value &amp;&amp; G_VALUE_TYPE (return_value))
1670     value_from_ffi_type (return_value, rvalue);
1671 }
1672 
1673 /**
1674  * g_cclosure_marshal_VOID__VOID:
1675  * @closure: the #GClosure to which the marshaller belongs
1676  * @return_value: ignored
1677  * @n_param_values: 1
1678  * @param_values: a #GValue array holding only the instance
1679  * @invocation_hint: the invocation hint given as the last argument
1680  *  to g_closure_invoke()
1681  * @marshal_data: additional data specified when registering the marshaller
1682  *
1683  * A marshaller for a #GCClosure with a callback of type
1684  * `void (*callback) (gpointer instance, gpointer user_data)`.
1685  */
1686 
1687 /**
1688  * g_cclosure_marshal_VOID__BOOLEAN:
1689  * @closure: the #GClosure to which the marshaller belongs
1690  * @return_value: ignored
1691  * @n_param_values: 2
1692  * @param_values: a #GValue array holding the instance and the #gboolean parameter
1693  * @invocation_hint: the invocation hint given as the last argument
1694  *  to g_closure_invoke()
1695  * @marshal_data: additional data specified when registering the marshaller
1696  *
1697  * A marshaller for a #GCClosure with a callback of type
1698  * `void (*callback) (gpointer instance, gboolean arg1, gpointer user_data)`.
1699  */
1700 
1701 /**
1702  * g_cclosure_marshal_VOID__CHAR:
1703  * @closure: the #GClosure to which the marshaller belongs
1704  * @return_value: ignored
1705  * @n_param_values: 2
1706  * @param_values: a #GValue array holding the instance and the #gchar parameter
1707  * @invocation_hint: the invocation hint given as the last argument
1708  *  to g_closure_invoke()
1709  * @marshal_data: additional data specified when registering the marshaller
1710  *
1711  * A marshaller for a #GCClosure with a callback of type
1712  * `void (*callback) (gpointer instance, gchar arg1, gpointer user_data)`.
1713  */
1714 
1715 /**
1716  * g_cclosure_marshal_VOID__UCHAR:
1717  * @closure: the #GClosure to which the marshaller belongs
1718  * @return_value: ignored
1719  * @n_param_values: 2
1720  * @param_values: a #GValue array holding the instance and the #guchar parameter
1721  * @invocation_hint: the invocation hint given as the last argument
1722  *  to g_closure_invoke()
1723  * @marshal_data: additional data specified when registering the marshaller
1724  *
1725  * A marshaller for a #GCClosure with a callback of type
1726  * `void (*callback) (gpointer instance, guchar arg1, gpointer user_data)`.
1727  */
1728 
1729 /**
1730  * g_cclosure_marshal_VOID__INT:
1731  * @closure: the #GClosure to which the marshaller belongs
1732  * @return_value: ignored
1733  * @n_param_values: 2
1734  * @param_values: a #GValue array holding the instance and the #gint parameter
1735  * @invocation_hint: the invocation hint given as the last argument
1736  *  to g_closure_invoke()
1737  * @marshal_data: additional data specified when registering the marshaller
1738  *
1739  * A marshaller for a #GCClosure with a callback of type
1740  * `void (*callback) (gpointer instance, gint arg1, gpointer user_data)`.
1741  */
1742 
1743 /**
1744  * g_cclosure_marshal_VOID__UINT:
1745  * @closure: the #GClosure to which the marshaller belongs
1746  * @return_value: ignored
1747  * @n_param_values: 2
1748  * @param_values: a #GValue array holding the instance and the #guint parameter
1749  * @invocation_hint: the invocation hint given as the last argument
1750  *  to g_closure_invoke()
1751  * @marshal_data: additional data specified when registering the marshaller
1752  *
1753  * A marshaller for a #GCClosure with a callback of type
1754  * `void (*callback) (gpointer instance, guint arg1, gpointer user_data)`.
1755  */
1756 
1757 /**
1758  * g_cclosure_marshal_VOID__LONG:
1759  * @closure: the #GClosure to which the marshaller belongs
1760  * @return_value: ignored
1761  * @n_param_values: 2
1762  * @param_values: a #GValue array holding the instance and the #glong parameter
1763  * @invocation_hint: the invocation hint given as the last argument
1764  *  to g_closure_invoke()
1765  * @marshal_data: additional data specified when registering the marshaller
1766  *
1767  * A marshaller for a #GCClosure with a callback of type
1768  * `void (*callback) (gpointer instance, glong arg1, gpointer user_data)`.
1769  */
1770 
1771 /**
1772  * g_cclosure_marshal_VOID__ULONG:
1773  * @closure: the #GClosure to which the marshaller belongs
1774  * @return_value: ignored
1775  * @n_param_values: 2
1776  * @param_values: a #GValue array holding the instance and the #gulong parameter
1777  * @invocation_hint: the invocation hint given as the last argument
1778  *  to g_closure_invoke()
1779  * @marshal_data: additional data specified when registering the marshaller
1780  *
1781  * A marshaller for a #GCClosure with a callback of type
1782  * `void (*callback) (gpointer instance, gulong arg1, gpointer user_data)`.
1783  */
1784 
1785 /**
1786  * g_cclosure_marshal_VOID__ENUM:
1787  * @closure: the #GClosure to which the marshaller belongs
1788  * @return_value: ignored
1789  * @n_param_values: 2
1790  * @param_values: a #GValue array holding the instance and the enumeration parameter
1791  * @invocation_hint: the invocation hint given as the last argument
1792  *  to g_closure_invoke()
1793  * @marshal_data: additional data specified when registering the marshaller
1794  *
1795  * A marshaller for a #GCClosure with a callback of type
1796  * `void (*callback) (gpointer instance, gint arg1, gpointer user_data)` where the #gint parameter denotes an enumeration type..
1797  */
1798 
1799 /**
1800  * g_cclosure_marshal_VOID__FLAGS:
1801  * @closure: the #GClosure to which the marshaller belongs
1802  * @return_value: ignored
1803  * @n_param_values: 2
1804  * @param_values: a #GValue array holding the instance and the flags parameter
1805  * @invocation_hint: the invocation hint given as the last argument
1806  *  to g_closure_invoke()
1807  * @marshal_data: additional data specified when registering the marshaller
1808  *
1809  * A marshaller for a #GCClosure with a callback of type
1810  * `void (*callback) (gpointer instance, gint arg1, gpointer user_data)` where the #gint parameter denotes a flags type.
1811  */
1812 
1813 /**
1814  * g_cclosure_marshal_VOID__FLOAT:
1815  * @closure: the #GClosure to which the marshaller belongs
1816  * @return_value: ignored
1817  * @n_param_values: 2
1818  * @param_values: a #GValue array holding the instance and the #gfloat parameter
1819  * @invocation_hint: the invocation hint given as the last argument
1820  *  to g_closure_invoke()
1821  * @marshal_data: additional data specified when registering the marshaller
1822  *
1823  * A marshaller for a #GCClosure with a callback of type
1824  * `void (*callback) (gpointer instance, gfloat arg1, gpointer user_data)`.
1825  */
1826 
1827 /**
1828  * g_cclosure_marshal_VOID__DOUBLE:
1829  * @closure: the #GClosure to which the marshaller belongs
1830  * @return_value: ignored
1831  * @n_param_values: 2
1832  * @param_values: a #GValue array holding the instance and the #gdouble parameter
1833  * @invocation_hint: the invocation hint given as the last argument
1834  *  to g_closure_invoke()
1835  * @marshal_data: additional data specified when registering the marshaller
1836  *
1837  * A marshaller for a #GCClosure with a callback of type
1838  * `void (*callback) (gpointer instance, gdouble arg1, gpointer user_data)`.
1839  */
1840 
1841 /**
1842  * g_cclosure_marshal_VOID__STRING:
1843  * @closure: the #GClosure to which the marshaller belongs
1844  * @return_value: ignored
1845  * @n_param_values: 2
1846  * @param_values: a #GValue array holding the instance and the #gchar* parameter
1847  * @invocation_hint: the invocation hint given as the last argument
1848  *  to g_closure_invoke()
1849  * @marshal_data: additional data specified when registering the marshaller
1850  *
1851  * A marshaller for a #GCClosure with a callback of type
1852  * `void (*callback) (gpointer instance, const gchar *arg1, gpointer user_data)`.
1853  */
1854 
1855 /**
1856  * g_cclosure_marshal_VOID__PARAM:
1857  * @closure: the #GClosure to which the marshaller belongs
1858  * @return_value: ignored
1859  * @n_param_values: 2
1860  * @param_values: a #GValue array holding the instance and the #GParamSpec* parameter
1861  * @invocation_hint: the invocation hint given as the last argument
1862  *  to g_closure_invoke()
1863  * @marshal_data: additional data specified when registering the marshaller
1864  *
1865  * A marshaller for a #GCClosure with a callback of type
1866  * `void (*callback) (gpointer instance, GParamSpec *arg1, gpointer user_data)`.
1867  */
1868 
1869 /**
1870  * g_cclosure_marshal_VOID__BOXED:
1871  * @closure: the #GClosure to which the marshaller belongs
1872  * @return_value: ignored
1873  * @n_param_values: 2
1874  * @param_values: a #GValue array holding the instance and the #GBoxed* parameter
1875  * @invocation_hint: the invocation hint given as the last argument
1876  *  to g_closure_invoke()
1877  * @marshal_data: additional data specified when registering the marshaller
1878  *
1879  * A marshaller for a #GCClosure with a callback of type
1880  * `void (*callback) (gpointer instance, GBoxed *arg1, gpointer user_data)`.
1881  */
1882 
1883 /**
1884  * g_cclosure_marshal_VOID__POINTER:
1885  * @closure: the #GClosure to which the marshaller belongs
1886  * @return_value: ignored
1887  * @n_param_values: 2
1888  * @param_values: a #GValue array holding the instance and the #gpointer parameter
1889  * @invocation_hint: the invocation hint given as the last argument
1890  *  to g_closure_invoke()
1891  * @marshal_data: additional data specified when registering the marshaller
1892  *
1893  * A marshaller for a #GCClosure with a callback of type
1894  * `void (*callback) (gpointer instance, gpointer arg1, gpointer user_data)`.
1895  */
1896 
1897 /**
1898  * g_cclosure_marshal_VOID__OBJECT:
1899  * @closure: the #GClosure to which the marshaller belongs
1900  * @return_value: ignored
1901  * @n_param_values: 2
1902  * @param_values: a #GValue array holding the instance and the #GObject* parameter
1903  * @invocation_hint: the invocation hint given as the last argument
1904  *  to g_closure_invoke()
1905  * @marshal_data: additional data specified when registering the marshaller
1906  *
1907  * A marshaller for a #GCClosure with a callback of type
1908  * `void (*callback) (gpointer instance, GObject *arg1, gpointer user_data)`.
1909  */
1910 
1911 /**
1912  * g_cclosure_marshal_VOID__VARIANT:
1913  * @closure: the #GClosure to which the marshaller belongs
1914  * @return_value: ignored
1915  * @n_param_values: 2
1916  * @param_values: a #GValue array holding the instance and the #GVariant* parameter
1917  * @invocation_hint: the invocation hint given as the last argument
1918  *  to g_closure_invoke()
1919  * @marshal_data: additional data specified when registering the marshaller
1920  *
1921  * A marshaller for a #GCClosure with a callback of type
1922  * `void (*callback) (gpointer instance, GVariant *arg1, gpointer user_data)`.
1923  *
1924  * Since: 2.26
1925  */
1926 
1927 /**
1928  * g_cclosure_marshal_VOID__UINT_POINTER:
1929  * @closure: the #GClosure to which the marshaller belongs
1930  * @return_value: ignored
1931  * @n_param_values: 3
1932  * @param_values: a #GValue array holding instance, arg1 and arg2
1933  * @invocation_hint: the invocation hint given as the last argument
1934  *  to g_closure_invoke()
1935  * @marshal_data: additional data specified when registering the marshaller
1936  *
1937  * A marshaller for a #GCClosure with a callback of type
1938  * `void (*callback) (gpointer instance, guint arg1, gpointer arg2, gpointer user_data)`.
1939  */
1940 
1941 /**
1942  * g_cclosure_marshal_BOOLEAN__FLAGS:
1943  * @closure: the #GClosure to which the marshaller belongs
1944  * @return_value: a #GValue which can store the returned #gboolean
1945  * @n_param_values: 2
1946  * @param_values: a #GValue array holding instance and arg1
1947  * @invocation_hint: the invocation hint given as the last argument
1948  *  to g_closure_invoke()
1949  * @marshal_data: additional data specified when registering the marshaller
1950  *
1951  * A marshaller for a #GCClosure with a callback of type
1952  * `gboolean (*callback) (gpointer instance, gint arg1, gpointer user_data)` where the #gint parameter
1953  * denotes a flags type.
1954  */
1955 
1956 /**
1957  * g_cclosure_marshal_BOOL__FLAGS:
1958  *
1959  * Another name for g_cclosure_marshal_BOOLEAN__FLAGS().
1960  */
1961 /**
1962  * g_cclosure_marshal_STRING__OBJECT_POINTER:
1963  * @closure: the #GClosure to which the marshaller belongs
1964  * @return_value: a #GValue, which can store the returned string
1965  * @n_param_values: 3
1966  * @param_values: a #GValue array holding instance, arg1 and arg2
1967  * @invocation_hint: the invocation hint given as the last argument
1968  *  to g_closure_invoke()
1969  * @marshal_data: additional data specified when registering the marshaller
1970  *
1971  * A marshaller for a #GCClosure with a callback of type
1972  * `gchar* (*callback) (gpointer instance, GObject *arg1, gpointer arg2, gpointer user_data)`.
1973  */
1974 /**
1975  * g_cclosure_marshal_BOOLEAN__OBJECT_BOXED_BOXED:
1976  * @closure: the #GClosure to which the marshaller belongs
1977  * @return_value: a #GValue, which can store the returned string
1978  * @n_param_values: 3
1979  * @param_values: a #GValue array holding instance, arg1 and arg2
1980  * @invocation_hint: the invocation hint given as the last argument
1981  *  to g_closure_invoke()
1982  * @marshal_data: additional data specified when registering the marshaller
1983  *
1984  * A marshaller for a #GCClosure with a callback of type
1985  * `gboolean (*callback) (gpointer instance, GBoxed *arg1, GBoxed *arg2, gpointer user_data)`.
1986  *
1987  * Since: 2.26
1988  */
    </pre>
  </body>
</html>