<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/garray.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="galloca.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="garray.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/garray.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 306  * Returns: Size of each element, in bytes
 307  *
 308  * Since: 2.22
 309  */
 310 guint
 311 g_array_get_element_size (GArray *array)
 312 {
 313   GRealArray *rarray = (GRealArray*) array;
 314 
 315   g_return_val_if_fail (array, 0);
 316 
 317   return rarray-&gt;elt_size;
 318 }
 319 
 320 /**
 321  * g_array_free:
 322  * @array: a #GArray
 323  * @free_segment: if %TRUE the actual element data is freed as well
 324  *
 325  * Frees the memory allocated for the #GArray. If @free_segment is
<span class="line-modified"> 326  * %TRUE it frees the memory block holding the elements as well and</span>
<span class="line-removed"> 327  * also each element if @array has a @element_free_func set. Pass</span>
 328  * %FALSE if you want to free the #GArray wrapper but preserve the
<span class="line-modified"> 329  * underlying array for use elsewhere. If the reference count of @array</span>
<span class="line-modified"> 330  * is greater than one, the #GArray wrapper is preserved but the size</span>
<span class="line-modified"> 331  * of @array will be set to zero.</span>
 332  *
<span class="line-modified"> 333  * If array elements contain dynamically-allocated memory, they should</span>
<span class="line-modified"> 334  * be freed separately.</span>

 335  *
 336  * This function is not thread-safe. If using a #GArray from multiple
 337  * threads, use only the atomic g_array_ref() and g_array_unref()
 338  * functions.
 339  *
 340  * Returns: the element data if @free_segment is %FALSE, otherwise
 341  *     %NULL. The element data should be freed using g_free().
 342  */
 343 gchar*
 344 g_array_free (GArray   *farray,
 345               gboolean  free_segment)
 346 {
 347   GRealArray *array = (GRealArray*) farray;
 348   ArrayFreeFlags flags;
 349 
 350   g_return_val_if_fail (array, NULL);
 351 
 352   flags = (free_segment ? FREE_SEGMENT : 0);
 353 
 354   /* if others are holding a reference, preserve the wrapper but do free/return the data */
</pre>
<hr />
<pre>
 495            g_array_elt_len (array, array-&gt;len));
 496 
 497   memcpy (g_array_elt_pos (array, 0), data, g_array_elt_len (array, len));
 498 
 499   array-&gt;len += len;
 500 
 501   g_array_zero_terminate (array);
 502 
 503   return farray;
 504 }
 505 
 506 /**
 507  * g_array_insert_vals:
 508  * @array: a #GArray
 509  * @index_: the index to place the elements at
 510  * @data: (nullable): a pointer to the elements to insert
 511  * @len: the number of elements to insert
 512  *
 513  * Inserts @len elements into a #GArray at the given index.
 514  *
<span class="line-modified"> 515  * If @index_ is greater than the arrayâ€™s current length, the array is expanded.</span>
 516  * The elements between the old end of the array and the newly inserted elements
 517  * will be initialised to zero if the array was configured to clear elements;
 518  * otherwise their values will be undefined.
 519  *
 520  * @data may be %NULL if (and only if) @len is zero. If @len is zero, this
 521  * function is a no-op.
 522  *
 523  * Returns: the #GArray
 524  */
 525 /**
 526  * g_array_insert_val:
 527  * @a: a #GArray
 528  * @i: the index to place the element at
 529  * @v: the value to insert into the array
 530  *
 531  * Inserts an element into an array at the given index.
 532  *
 533  * g_array_insert_val() is a macro which uses a reference to the value
 534  * parameter @v. This means that you cannot use it with literal values
 535  * such as &quot;27&quot;. You must use variables.
</pre>
<hr />
<pre>
 773  * There used to be a comment here about making the sort stable by
 774  * using the addresses of the elements in the comparison function.
 775  * This did not actually work, so any such code should be removed.
 776  */
 777 void
 778 g_array_sort_with_data (GArray           *farray,
 779                         GCompareDataFunc  compare_func,
 780                         gpointer          user_data)
 781 {
 782   GRealArray *array = (GRealArray*) farray;
 783 
 784   g_return_if_fail (array != NULL);
 785 
 786   g_qsort_with_data (array-&gt;data,
 787                      array-&gt;len,
 788                      array-&gt;elt_size,
 789                      compare_func,
 790                      user_data);
 791 }
 792 



















































































 793 /* Returns the smallest power of 2 greater than n, or n if
 794  * such power does not fit in a guint
 795  */
 796 static guint
 797 g_nearest_pow (guint num)
 798 {
<span class="line-modified"> 799   guint n = 1;</span>


 800 
<span class="line-modified"> 801   while (n &lt; num &amp;&amp; n &gt; 0)</span>
<span class="line-modified"> 802     n &lt;&lt;= 1;</span>






 803 
<span class="line-modified"> 804   return n ? n : num;</span>
 805 }
 806 
 807 static void
 808 g_array_maybe_expand (GRealArray *array,
 809                       guint       len)
 810 {
 811   guint want_alloc;
 812 
 813   /* Detect potential overflow */
 814   if G_UNLIKELY ((G_MAXUINT - array-&gt;len) &lt; len)
 815     g_error (&quot;adding %u to array would overflow&quot;, len);
 816 
 817   want_alloc = g_array_elt_len (array, array-&gt;len + len +
<span class="line-modified"> 818                                       array-&gt;zero_terminated);</span>
 819 
 820   if (want_alloc &gt; array-&gt;alloc)
 821     {
 822       want_alloc = g_nearest_pow (want_alloc);
 823       want_alloc = MAX (want_alloc, MIN_ARRAY_SIZE);
 824 
 825       array-&gt;data = g_realloc (array-&gt;data, want_alloc);
 826 
 827       if (G_UNLIKELY (g_mem_gc_friendly))
 828         memset (array-&gt;data + array-&gt;alloc, 0, want_alloc - array-&gt;alloc);
 829 
 830       array-&gt;alloc = want_alloc;
 831     }
 832 }
 833 
 834 /**
 835  * SECTION:arrays_pointer
 836  * @title: Pointer Arrays
 837  * @short_description: arrays of pointers to any type of data, which
 838  *     grow automatically as new elements are added
</pre>
<hr />
<pre>
 895   guint           len;
 896   guint           alloc;
 897   gatomicrefcount ref_count;
 898   GDestroyNotify  element_free_func;
 899 };
 900 
 901 /**
 902  * g_ptr_array_index:
 903  * @array: a #GPtrArray
 904  * @index_: the index of the pointer to return
 905  *
 906  * Returns the pointer at the given index of the pointer array.
 907  *
 908  * This does not perform bounds checking on the given @index_,
 909  * so you are responsible for checking it against the array length.
 910  *
 911  * Returns: the pointer at the given index
 912  */
 913 
 914 static void g_ptr_array_maybe_expand (GRealPtrArray *array,
<span class="line-modified"> 915                                       gint           len);</span>
 916 
 917 /**
 918  * g_ptr_array_new:
 919  *
 920  * Creates a new #GPtrArray with a reference count of 1.
 921  *
 922  * Returns: the new #GPtrArray
 923  */
 924 GPtrArray*
 925 g_ptr_array_new (void)
 926 {
 927   return g_ptr_array_sized_new (0);
 928 }
 929 





















































 930 /**
 931  * g_ptr_array_sized_new:
 932  * @reserved_size: number of pointers preallocated
 933  *
 934  * Creates a new #GPtrArray with @reserved_size pointers preallocated
 935  * and a reference count of 1. This avoids frequent reallocation, if
 936  * you are going to add many pointers to the array. Note however that
 937  * the size of the array is still 0.
 938  *
 939  * Returns: the new #GPtrArray
 940  */
 941 GPtrArray*
 942 g_ptr_array_sized_new (guint reserved_size)
 943 {
 944   GRealPtrArray *array;
 945 
 946   array = g_slice_new (GRealPtrArray);
 947 #ifdef GSTREAMER_LITE
 948   if (array == NULL) {
 949     return NULL;
 950   }
 951 #endif // GSTREAMER_LITE
 952 
 953   array-&gt;pdata = NULL;
 954   array-&gt;len = 0;
 955   array-&gt;alloc = 0;
 956   array-&gt;element_free_func = NULL;
 957 
 958   g_atomic_ref_count_init (&amp;array-&gt;ref_count);
 959 
 960   if (reserved_size != 0)
 961     g_ptr_array_maybe_expand (array, reserved_size);
 962 
 963   return (GPtrArray*) array;
 964 }
 965 




























 966 /**
 967  * g_ptr_array_new_with_free_func:
 968  * @element_free_func: (nullable): A function to free elements with
 969  *     destroy @array or %NULL
 970  *
 971  * Creates a new #GPtrArray with a reference count of 1 and use
 972  * @element_free_func for freeing each element when the array is destroyed
 973  * either via g_ptr_array_unref(), when g_ptr_array_free() is called with
 974  * @free_segment set to %TRUE or when removing elements.
 975  *
 976  * Returns: A new #GPtrArray
 977  *
 978  * Since: 2.22
 979  */
 980 GPtrArray*
 981 g_ptr_array_new_with_free_func (GDestroyNotify element_free_func)
 982 {
 983   GPtrArray *array;
 984 
 985   array = g_ptr_array_new ();
</pre>
<hr />
<pre>
1163     }
1164   else
1165     segment = rarray-&gt;pdata;
1166 
1167   if (flags &amp; PRESERVE_WRAPPER)
1168     {
1169       rarray-&gt;pdata = NULL;
1170       rarray-&gt;len = 0;
1171       rarray-&gt;alloc = 0;
1172     }
1173   else
1174     {
1175       g_slice_free1 (sizeof (GRealPtrArray), rarray);
1176     }
1177 
1178   return segment;
1179 }
1180 
1181 static void
1182 g_ptr_array_maybe_expand (GRealPtrArray *array,
<span class="line-modified">1183                           gint           len)</span>
1184 {
1185   /* Detect potential overflow */
1186   if G_UNLIKELY ((G_MAXUINT - array-&gt;len) &lt; len)
1187     g_error (&quot;adding %u to array would overflow&quot;, len);
1188 
1189   if ((array-&gt;len + len) &gt; array-&gt;alloc)
1190     {
1191       guint old_alloc = array-&gt;alloc;
1192       array-&gt;alloc = g_nearest_pow (array-&gt;len + len);
1193       array-&gt;alloc = MAX (array-&gt;alloc, MIN_ARRAY_SIZE);
1194       array-&gt;pdata = g_realloc (array-&gt;pdata, sizeof (gpointer) * array-&gt;alloc);
1195       if (G_UNLIKELY (g_mem_gc_friendly))
1196         for ( ; old_alloc &lt; array-&gt;alloc; old_alloc++)
1197           array-&gt;pdata [old_alloc] = NULL;
1198     }
1199 }
1200 
1201 /**
1202  * g_ptr_array_set_size:
1203  * @array: a #GPtrArray
</pre>
<hr />
<pre>
1489  * @array: a #GPtrArray
1490  * @data: the pointer to add
1491  *
1492  * Adds a pointer to the end of the pointer array. The array will grow
1493  * in size automatically if necessary.
1494  */
1495 void
1496 g_ptr_array_add (GPtrArray *array,
1497                  gpointer   data)
1498 {
1499   GRealPtrArray *rarray = (GRealPtrArray *)array;
1500 
1501   g_return_if_fail (rarray);
1502   g_return_if_fail (rarray-&gt;len == 0 || (rarray-&gt;len != 0 &amp;&amp; rarray-&gt;pdata != NULL));
1503 
1504   g_ptr_array_maybe_expand (rarray, 1);
1505 
1506   rarray-&gt;pdata[rarray-&gt;len++] = data;
1507 }
1508 



















































































1509 /**
1510  * g_ptr_array_insert:
1511  * @array: a #GPtrArray
1512  * @index_: the index to place the new element at, or -1 to append
1513  * @data: the pointer to add.
1514  *
1515  * Inserts an element into the pointer array at the given index. The
1516  * array will grow in size automatically if necessary.
1517  *
1518  * Since: 2.40
1519  */
1520 void
1521 g_ptr_array_insert (GPtrArray *array,
1522                     gint       index_,
1523                     gpointer   data)
1524 {
1525   GRealPtrArray *rarray = (GRealPtrArray *)array;
1526 
1527   g_return_if_fail (rarray);
1528   g_return_if_fail (index_ &gt;= -1);
1529   g_return_if_fail (index_ &lt;= (gint)rarray-&gt;len);
1530 
1531   g_ptr_array_maybe_expand (rarray, 1);
1532 
1533   if (index_ &lt; 0)
1534     index_ = rarray-&gt;len;
1535 
<span class="line-modified">1536   if (index_ &lt; rarray-&gt;len)</span>
1537     memmove (&amp;(rarray-&gt;pdata[index_ + 1]),
1538              &amp;(rarray-&gt;pdata[index_]),
1539              (rarray-&gt;len - index_) * sizeof (gpointer));
1540 
1541   rarray-&gt;len++;
1542   rarray-&gt;pdata[index_] = data;
1543 }
1544 
1545 /**
1546  * g_ptr_array_sort:
1547  * @array: a #GPtrArray
1548  * @compare_func: comparison function
1549  *
1550  * Sorts the array, using @compare_func which should be a qsort()-style
1551  * comparison function (returns less than zero for first arg is less
1552  * than second arg, zero for equal, greater than zero if irst arg is
1553  * greater than second arg).
1554  *
1555  * Note that the comparison function for g_ptr_array_sort() doesn&#39;t
1556  * take the pointers from the array as arguments, it takes pointers to
</pre>
</td>
<td>
<hr />
<pre>
 306  * Returns: Size of each element, in bytes
 307  *
 308  * Since: 2.22
 309  */
 310 guint
 311 g_array_get_element_size (GArray *array)
 312 {
 313   GRealArray *rarray = (GRealArray*) array;
 314 
 315   g_return_val_if_fail (array, 0);
 316 
 317   return rarray-&gt;elt_size;
 318 }
 319 
 320 /**
 321  * g_array_free:
 322  * @array: a #GArray
 323  * @free_segment: if %TRUE the actual element data is freed as well
 324  *
 325  * Frees the memory allocated for the #GArray. If @free_segment is
<span class="line-modified"> 326  * %TRUE it frees the memory block holding the elements as well. Pass</span>

 327  * %FALSE if you want to free the #GArray wrapper but preserve the
<span class="line-modified"> 328  * underlying array for use elsewhere. If the reference count of</span>
<span class="line-modified"> 329  * @array is greater than one, the #GArray wrapper is preserved but</span>
<span class="line-modified"> 330  * the size of  @array will be set to zero.</span>
 331  *
<span class="line-modified"> 332  * If array contents point to dynamically-allocated memory, they should</span>
<span class="line-modified"> 333  * be freed separately if @free_seg is %TRUE and no @clear_func</span>
<span class="line-added"> 334  * function has been set for @array.</span>
 335  *
 336  * This function is not thread-safe. If using a #GArray from multiple
 337  * threads, use only the atomic g_array_ref() and g_array_unref()
 338  * functions.
 339  *
 340  * Returns: the element data if @free_segment is %FALSE, otherwise
 341  *     %NULL. The element data should be freed using g_free().
 342  */
 343 gchar*
 344 g_array_free (GArray   *farray,
 345               gboolean  free_segment)
 346 {
 347   GRealArray *array = (GRealArray*) farray;
 348   ArrayFreeFlags flags;
 349 
 350   g_return_val_if_fail (array, NULL);
 351 
 352   flags = (free_segment ? FREE_SEGMENT : 0);
 353 
 354   /* if others are holding a reference, preserve the wrapper but do free/return the data */
</pre>
<hr />
<pre>
 495            g_array_elt_len (array, array-&gt;len));
 496 
 497   memcpy (g_array_elt_pos (array, 0), data, g_array_elt_len (array, len));
 498 
 499   array-&gt;len += len;
 500 
 501   g_array_zero_terminate (array);
 502 
 503   return farray;
 504 }
 505 
 506 /**
 507  * g_array_insert_vals:
 508  * @array: a #GArray
 509  * @index_: the index to place the elements at
 510  * @data: (nullable): a pointer to the elements to insert
 511  * @len: the number of elements to insert
 512  *
 513  * Inserts @len elements into a #GArray at the given index.
 514  *
<span class="line-modified"> 515  * If @index_ is greater than the array&#39;s current length, the array is expanded.</span>
 516  * The elements between the old end of the array and the newly inserted elements
 517  * will be initialised to zero if the array was configured to clear elements;
 518  * otherwise their values will be undefined.
 519  *
 520  * @data may be %NULL if (and only if) @len is zero. If @len is zero, this
 521  * function is a no-op.
 522  *
 523  * Returns: the #GArray
 524  */
 525 /**
 526  * g_array_insert_val:
 527  * @a: a #GArray
 528  * @i: the index to place the element at
 529  * @v: the value to insert into the array
 530  *
 531  * Inserts an element into an array at the given index.
 532  *
 533  * g_array_insert_val() is a macro which uses a reference to the value
 534  * parameter @v. This means that you cannot use it with literal values
 535  * such as &quot;27&quot;. You must use variables.
</pre>
<hr />
<pre>
 773  * There used to be a comment here about making the sort stable by
 774  * using the addresses of the elements in the comparison function.
 775  * This did not actually work, so any such code should be removed.
 776  */
 777 void
 778 g_array_sort_with_data (GArray           *farray,
 779                         GCompareDataFunc  compare_func,
 780                         gpointer          user_data)
 781 {
 782   GRealArray *array = (GRealArray*) farray;
 783 
 784   g_return_if_fail (array != NULL);
 785 
 786   g_qsort_with_data (array-&gt;data,
 787                      array-&gt;len,
 788                      array-&gt;elt_size,
 789                      compare_func,
 790                      user_data);
 791 }
 792 
<span class="line-added"> 793 /**</span>
<span class="line-added"> 794  * g_array_binary_search:</span>
<span class="line-added"> 795  * @array: a #GArray.</span>
<span class="line-added"> 796  * @target: a pointer to the item to look up.</span>
<span class="line-added"> 797  * @compare_func: A #GCompareFunc used to locate @target.</span>
<span class="line-added"> 798  * @out_match_index: (optional) (out caller-allocates): return location</span>
<span class="line-added"> 799  *    for the index of the element, if found.</span>
<span class="line-added"> 800  *</span>
<span class="line-added"> 801  * Checks whether @target exists in @array by performing a binary</span>
<span class="line-added"> 802  * search based on the given comparison function @compare_func which</span>
<span class="line-added"> 803  * get pointers to items as arguments. If the element is found, %TRUE</span>
<span class="line-added"> 804  * is returned and the element&#39;s index is returned in @out_match_index</span>
<span class="line-added"> 805  * (if non-%NULL). Otherwise, %FALSE is returned and @out_match_index</span>
<span class="line-added"> 806  * is undefined. If @target exists multiple times in @array, the index</span>
<span class="line-added"> 807  * of the first instance is returned. This search is using a binary</span>
<span class="line-added"> 808  * search, so the @array must absolutely be sorted to return a correct</span>
<span class="line-added"> 809  * result (if not, the function may produce false-negative).</span>
<span class="line-added"> 810  *</span>
<span class="line-added"> 811  * This example defines a comparison function and search an element in a #GArray:</span>
<span class="line-added"> 812  * |[&lt;!-- language=&quot;C&quot; --&gt;</span>
<span class="line-added"> 813  * static gint*</span>
<span class="line-added"> 814  * cmpint (gconstpointer a, gconstpointer b)</span>
<span class="line-added"> 815  * {</span>
<span class="line-added"> 816  *   const gint *_a = a;</span>
<span class="line-added"> 817  *   const gint *_b = b;</span>
<span class="line-added"> 818  *</span>
<span class="line-added"> 819  *   return *_a - *_b;</span>
<span class="line-added"> 820  * }</span>
<span class="line-added"> 821  * ...</span>
<span class="line-added"> 822  * gint i = 424242;</span>
<span class="line-added"> 823  * guint matched_index;</span>
<span class="line-added"> 824  * gboolean result = g_array_binary_search (garray, &amp;i, cmpint, &amp;matched_index);</span>
<span class="line-added"> 825  * ...</span>
<span class="line-added"> 826  * ]|</span>
<span class="line-added"> 827  *</span>
<span class="line-added"> 828  * Returns: %TRUE if @target is one of the elements of @array, %FALSE otherwise.</span>
<span class="line-added"> 829  *</span>
<span class="line-added"> 830  * Since: 2.62</span>
<span class="line-added"> 831  */</span>
<span class="line-added"> 832 gboolean</span>
<span class="line-added"> 833 g_array_binary_search (GArray        *array,</span>
<span class="line-added"> 834                        gconstpointer  target,</span>
<span class="line-added"> 835                        GCompareFunc   compare_func,</span>
<span class="line-added"> 836                        guint         *out_match_index)</span>
<span class="line-added"> 837 {</span>
<span class="line-added"> 838   gboolean result = FALSE;</span>
<span class="line-added"> 839   GRealArray *_array = (GRealArray *) array;</span>
<span class="line-added"> 840   guint left, middle, right;</span>
<span class="line-added"> 841   gint val;</span>
<span class="line-added"> 842 </span>
<span class="line-added"> 843   g_return_val_if_fail (_array != NULL, FALSE);</span>
<span class="line-added"> 844   g_return_val_if_fail (compare_func != NULL, FALSE);</span>
<span class="line-added"> 845 </span>
<span class="line-added"> 846   if (G_LIKELY(_array-&gt;len))</span>
<span class="line-added"> 847     {</span>
<span class="line-added"> 848       left = 0;</span>
<span class="line-added"> 849       right = _array-&gt;len - 1;</span>
<span class="line-added"> 850 </span>
<span class="line-added"> 851       while (left &lt;= right)</span>
<span class="line-added"> 852         {</span>
<span class="line-added"> 853           middle = left + (right - left) / 2;</span>
<span class="line-added"> 854 </span>
<span class="line-added"> 855           val = compare_func (_array-&gt;data + (_array-&gt;elt_size * middle), target);</span>
<span class="line-added"> 856           if (val == 0)</span>
<span class="line-added"> 857             {</span>
<span class="line-added"> 858               result = TRUE;</span>
<span class="line-added"> 859               break;</span>
<span class="line-added"> 860             }</span>
<span class="line-added"> 861           else if (val &lt; 0)</span>
<span class="line-added"> 862             left = middle + 1;</span>
<span class="line-added"> 863           else if (/* val &gt; 0 &amp;&amp; */ middle &gt; 0)</span>
<span class="line-added"> 864             right = middle - 1;</span>
<span class="line-added"> 865           else</span>
<span class="line-added"> 866             break;  /* element not found */</span>
<span class="line-added"> 867         }</span>
<span class="line-added"> 868     }</span>
<span class="line-added"> 869 </span>
<span class="line-added"> 870   if (result &amp;&amp; out_match_index != NULL)</span>
<span class="line-added"> 871     *out_match_index = middle;</span>
<span class="line-added"> 872 </span>
<span class="line-added"> 873   return result;</span>
<span class="line-added"> 874 }</span>
<span class="line-added"> 875 </span>
 876 /* Returns the smallest power of 2 greater than n, or n if
 877  * such power does not fit in a guint
 878  */
 879 static guint
 880 g_nearest_pow (guint num)
 881 {
<span class="line-modified"> 882   guint n = num - 1;</span>
<span class="line-added"> 883 </span>
<span class="line-added"> 884   g_assert (num &gt; 0);</span>
 885 
<span class="line-modified"> 886   n |= n &gt;&gt; 1;</span>
<span class="line-modified"> 887   n |= n &gt;&gt; 2;</span>
<span class="line-added"> 888   n |= n &gt;&gt; 4;</span>
<span class="line-added"> 889   n |= n &gt;&gt; 8;</span>
<span class="line-added"> 890   n |= n &gt;&gt; 16;</span>
<span class="line-added"> 891 #if SIZEOF_INT == 8</span>
<span class="line-added"> 892   n |= n &gt;&gt; 32;</span>
<span class="line-added"> 893 #endif</span>
 894 
<span class="line-modified"> 895   return n + 1;</span>
 896 }
 897 
 898 static void
 899 g_array_maybe_expand (GRealArray *array,
 900                       guint       len)
 901 {
 902   guint want_alloc;
 903 
 904   /* Detect potential overflow */
 905   if G_UNLIKELY ((G_MAXUINT - array-&gt;len) &lt; len)
 906     g_error (&quot;adding %u to array would overflow&quot;, len);
 907 
 908   want_alloc = g_array_elt_len (array, array-&gt;len + len +
<span class="line-modified"> 909                                 array-&gt;zero_terminated);</span>
 910 
 911   if (want_alloc &gt; array-&gt;alloc)
 912     {
 913       want_alloc = g_nearest_pow (want_alloc);
 914       want_alloc = MAX (want_alloc, MIN_ARRAY_SIZE);
 915 
 916       array-&gt;data = g_realloc (array-&gt;data, want_alloc);
 917 
 918       if (G_UNLIKELY (g_mem_gc_friendly))
 919         memset (array-&gt;data + array-&gt;alloc, 0, want_alloc - array-&gt;alloc);
 920 
 921       array-&gt;alloc = want_alloc;
 922     }
 923 }
 924 
 925 /**
 926  * SECTION:arrays_pointer
 927  * @title: Pointer Arrays
 928  * @short_description: arrays of pointers to any type of data, which
 929  *     grow automatically as new elements are added
</pre>
<hr />
<pre>
 986   guint           len;
 987   guint           alloc;
 988   gatomicrefcount ref_count;
 989   GDestroyNotify  element_free_func;
 990 };
 991 
 992 /**
 993  * g_ptr_array_index:
 994  * @array: a #GPtrArray
 995  * @index_: the index of the pointer to return
 996  *
 997  * Returns the pointer at the given index of the pointer array.
 998  *
 999  * This does not perform bounds checking on the given @index_,
1000  * so you are responsible for checking it against the array length.
1001  *
1002  * Returns: the pointer at the given index
1003  */
1004 
1005 static void g_ptr_array_maybe_expand (GRealPtrArray *array,
<span class="line-modified">1006                                       guint          len);</span>
1007 
1008 /**
1009  * g_ptr_array_new:
1010  *
1011  * Creates a new #GPtrArray with a reference count of 1.
1012  *
1013  * Returns: the new #GPtrArray
1014  */
1015 GPtrArray*
1016 g_ptr_array_new (void)
1017 {
1018   return g_ptr_array_sized_new (0);
1019 }
1020 
<span class="line-added">1021 /**</span>
<span class="line-added">1022  * g_ptr_array_copy:</span>
<span class="line-added">1023  * @array: #GPtrArray to duplicate</span>
<span class="line-added">1024  * @func: (nullable): a copy function used to copy every element in the array</span>
<span class="line-added">1025  * @user_data: user data passed to the copy function @func, or %NULL</span>
<span class="line-added">1026  *</span>
<span class="line-added">1027  * Makes a full (deep) copy of a #GPtrArray.</span>
<span class="line-added">1028  *</span>
<span class="line-added">1029  * @func, as a #GCopyFunc, takes two arguments, the data to be copied</span>
<span class="line-added">1030  * and a @user_data pointer. On common processor architectures, it&#39;s safe to</span>
<span class="line-added">1031  * pass %NULL as @user_data if the copy function takes only one argument. You</span>
<span class="line-added">1032  * may get compiler warnings from this though if compiling with GCC&#39;s</span>
<span class="line-added">1033  * `-Wcast-function-type` warning.</span>
<span class="line-added">1034  *</span>
<span class="line-added">1035  * If @func is %NULL, then only the pointers (and not what they are</span>
<span class="line-added">1036  * pointing to) are copied to the new #GPtrArray.</span>
<span class="line-added">1037  *</span>
<span class="line-added">1038  * The copy of @array will have the same #GDestroyNotify for its elements as</span>
<span class="line-added">1039  * @array.</span>
<span class="line-added">1040  *</span>
<span class="line-added">1041  * Returns: (transfer full): a deep copy of the initial #GPtrArray.</span>
<span class="line-added">1042  *</span>
<span class="line-added">1043  * Since: 2.62</span>
<span class="line-added">1044  **/</span>
<span class="line-added">1045 GPtrArray *</span>
<span class="line-added">1046 g_ptr_array_copy (GPtrArray *array,</span>
<span class="line-added">1047                   GCopyFunc  func,</span>
<span class="line-added">1048                   gpointer   user_data)</span>
<span class="line-added">1049 {</span>
<span class="line-added">1050   gsize i;</span>
<span class="line-added">1051   GPtrArray *new_array;</span>
<span class="line-added">1052 </span>
<span class="line-added">1053   g_return_val_if_fail (array != NULL, NULL);</span>
<span class="line-added">1054 </span>
<span class="line-added">1055   new_array = g_ptr_array_sized_new (array-&gt;len);</span>
<span class="line-added">1056   g_ptr_array_set_free_func (new_array, ((GRealPtrArray *) array)-&gt;element_free_func);</span>
<span class="line-added">1057 </span>
<span class="line-added">1058   if (func != NULL)</span>
<span class="line-added">1059     {</span>
<span class="line-added">1060       for (i = 0; i &lt; array-&gt;len; i++)</span>
<span class="line-added">1061         new_array-&gt;pdata[i] = func (array-&gt;pdata[i], user_data);</span>
<span class="line-added">1062     }</span>
<span class="line-added">1063   else</span>
<span class="line-added">1064     {</span>
<span class="line-added">1065       memcpy (new_array-&gt;pdata, array-&gt;pdata,</span>
<span class="line-added">1066               array-&gt;len * sizeof (*array-&gt;pdata));</span>
<span class="line-added">1067     }</span>
<span class="line-added">1068 </span>
<span class="line-added">1069   new_array-&gt;len = array-&gt;len;</span>
<span class="line-added">1070 </span>
<span class="line-added">1071   return new_array;</span>
<span class="line-added">1072 }</span>
<span class="line-added">1073 </span>
1074 /**
1075  * g_ptr_array_sized_new:
1076  * @reserved_size: number of pointers preallocated
1077  *
1078  * Creates a new #GPtrArray with @reserved_size pointers preallocated
1079  * and a reference count of 1. This avoids frequent reallocation, if
1080  * you are going to add many pointers to the array. Note however that
1081  * the size of the array is still 0.
1082  *
1083  * Returns: the new #GPtrArray
1084  */
1085 GPtrArray*
1086 g_ptr_array_sized_new (guint reserved_size)
1087 {
1088   GRealPtrArray *array;
1089 
1090   array = g_slice_new (GRealPtrArray);
1091 #ifdef GSTREAMER_LITE
1092   if (array == NULL) {
1093     return NULL;
1094   }
1095 #endif // GSTREAMER_LITE
1096 
1097   array-&gt;pdata = NULL;
1098   array-&gt;len = 0;
1099   array-&gt;alloc = 0;
1100   array-&gt;element_free_func = NULL;
1101 
1102   g_atomic_ref_count_init (&amp;array-&gt;ref_count);
1103 
1104   if (reserved_size != 0)
1105     g_ptr_array_maybe_expand (array, reserved_size);
1106 
1107   return (GPtrArray*) array;
1108 }
1109 
<span class="line-added">1110 /**</span>
<span class="line-added">1111  * g_array_copy:</span>
<span class="line-added">1112  * @array: A #GArray.</span>
<span class="line-added">1113  *</span>
<span class="line-added">1114  * Create a shallow copy of a #GArray. If the array elements consist of</span>
<span class="line-added">1115  * pointers to data, the pointers are copied but the actual data is not.</span>
<span class="line-added">1116  *</span>
<span class="line-added">1117  * Returns: (transfer container): A copy of @array.</span>
<span class="line-added">1118  *</span>
<span class="line-added">1119  * Since: 2.62</span>
<span class="line-added">1120  **/</span>
<span class="line-added">1121 GArray *</span>
<span class="line-added">1122 g_array_copy (GArray *array)</span>
<span class="line-added">1123 {</span>
<span class="line-added">1124   GRealArray *rarray = (GRealArray *) array;</span>
<span class="line-added">1125   GRealArray *new_rarray;</span>
<span class="line-added">1126 </span>
<span class="line-added">1127   g_return_val_if_fail (rarray != NULL, NULL);</span>
<span class="line-added">1128 </span>
<span class="line-added">1129   new_rarray =</span>
<span class="line-added">1130     (GRealArray *) g_array_sized_new (rarray-&gt;zero_terminated, rarray-&gt;clear,</span>
<span class="line-added">1131                                       rarray-&gt;elt_size, rarray-&gt;len);</span>
<span class="line-added">1132   new_rarray-&gt;len = rarray-&gt;len;</span>
<span class="line-added">1133   memcpy (new_rarray-&gt;data, rarray-&gt;data, rarray-&gt;alloc);</span>
<span class="line-added">1134 </span>
<span class="line-added">1135   return (GArray *) new_rarray;</span>
<span class="line-added">1136 }</span>
<span class="line-added">1137 </span>
1138 /**
1139  * g_ptr_array_new_with_free_func:
1140  * @element_free_func: (nullable): A function to free elements with
1141  *     destroy @array or %NULL
1142  *
1143  * Creates a new #GPtrArray with a reference count of 1 and use
1144  * @element_free_func for freeing each element when the array is destroyed
1145  * either via g_ptr_array_unref(), when g_ptr_array_free() is called with
1146  * @free_segment set to %TRUE or when removing elements.
1147  *
1148  * Returns: A new #GPtrArray
1149  *
1150  * Since: 2.22
1151  */
1152 GPtrArray*
1153 g_ptr_array_new_with_free_func (GDestroyNotify element_free_func)
1154 {
1155   GPtrArray *array;
1156 
1157   array = g_ptr_array_new ();
</pre>
<hr />
<pre>
1335     }
1336   else
1337     segment = rarray-&gt;pdata;
1338 
1339   if (flags &amp; PRESERVE_WRAPPER)
1340     {
1341       rarray-&gt;pdata = NULL;
1342       rarray-&gt;len = 0;
1343       rarray-&gt;alloc = 0;
1344     }
1345   else
1346     {
1347       g_slice_free1 (sizeof (GRealPtrArray), rarray);
1348     }
1349 
1350   return segment;
1351 }
1352 
1353 static void
1354 g_ptr_array_maybe_expand (GRealPtrArray *array,
<span class="line-modified">1355                           guint          len)</span>
1356 {
1357   /* Detect potential overflow */
1358   if G_UNLIKELY ((G_MAXUINT - array-&gt;len) &lt; len)
1359     g_error (&quot;adding %u to array would overflow&quot;, len);
1360 
1361   if ((array-&gt;len + len) &gt; array-&gt;alloc)
1362     {
1363       guint old_alloc = array-&gt;alloc;
1364       array-&gt;alloc = g_nearest_pow (array-&gt;len + len);
1365       array-&gt;alloc = MAX (array-&gt;alloc, MIN_ARRAY_SIZE);
1366       array-&gt;pdata = g_realloc (array-&gt;pdata, sizeof (gpointer) * array-&gt;alloc);
1367       if (G_UNLIKELY (g_mem_gc_friendly))
1368         for ( ; old_alloc &lt; array-&gt;alloc; old_alloc++)
1369           array-&gt;pdata [old_alloc] = NULL;
1370     }
1371 }
1372 
1373 /**
1374  * g_ptr_array_set_size:
1375  * @array: a #GPtrArray
</pre>
<hr />
<pre>
1661  * @array: a #GPtrArray
1662  * @data: the pointer to add
1663  *
1664  * Adds a pointer to the end of the pointer array. The array will grow
1665  * in size automatically if necessary.
1666  */
1667 void
1668 g_ptr_array_add (GPtrArray *array,
1669                  gpointer   data)
1670 {
1671   GRealPtrArray *rarray = (GRealPtrArray *)array;
1672 
1673   g_return_if_fail (rarray);
1674   g_return_if_fail (rarray-&gt;len == 0 || (rarray-&gt;len != 0 &amp;&amp; rarray-&gt;pdata != NULL));
1675 
1676   g_ptr_array_maybe_expand (rarray, 1);
1677 
1678   rarray-&gt;pdata[rarray-&gt;len++] = data;
1679 }
1680 
<span class="line-added">1681 /**</span>
<span class="line-added">1682  * g_ptr_array_extend:</span>
<span class="line-added">1683  * @array_to_extend: a #GPtrArray.</span>
<span class="line-added">1684  * @array: (transfer none): a #GPtrArray to add to the end of @array_to_extend.</span>
<span class="line-added">1685  * @func: (nullable): a copy function used to copy every element in the array</span>
<span class="line-added">1686  * @user_data: user data passed to the copy function @func, or %NULL</span>
<span class="line-added">1687  *</span>
<span class="line-added">1688  * Adds all pointers of @array to the end of the array @array_to_extend.</span>
<span class="line-added">1689  * The array will grow in size automatically if needed. @array_to_extend is</span>
<span class="line-added">1690  * modified in-place.</span>
<span class="line-added">1691  *</span>
<span class="line-added">1692  * @func, as a #GCopyFunc, takes two arguments, the data to be copied</span>
<span class="line-added">1693  * and a @user_data pointer. On common processor architectures, it&#39;s safe to</span>
<span class="line-added">1694  * pass %NULL as @user_data if the copy function takes only one argument. You</span>
<span class="line-added">1695  * may get compiler warnings from this though if compiling with GCC&#39;s</span>
<span class="line-added">1696  * `-Wcast-function-type` warning.</span>
<span class="line-added">1697  *</span>
<span class="line-added">1698  * If @func is %NULL, then only the pointers (and not what they are</span>
<span class="line-added">1699  * pointing to) are copied to the new #GPtrArray.</span>
<span class="line-added">1700  *</span>
<span class="line-added">1701  * Since: 2.62</span>
<span class="line-added">1702  **/</span>
<span class="line-added">1703 void</span>
<span class="line-added">1704 g_ptr_array_extend (GPtrArray  *array_to_extend,</span>
<span class="line-added">1705                     GPtrArray  *array,</span>
<span class="line-added">1706                     GCopyFunc   func,</span>
<span class="line-added">1707                     gpointer    user_data)</span>
<span class="line-added">1708 {</span>
<span class="line-added">1709   GRealPtrArray *rarray_to_extend = (GRealPtrArray *) array_to_extend;</span>
<span class="line-added">1710   gsize i;</span>
<span class="line-added">1711 </span>
<span class="line-added">1712   g_return_if_fail (array_to_extend != NULL);</span>
<span class="line-added">1713   g_return_if_fail (array != NULL);</span>
<span class="line-added">1714 </span>
<span class="line-added">1715   g_ptr_array_maybe_expand (rarray_to_extend, array-&gt;len);</span>
<span class="line-added">1716 </span>
<span class="line-added">1717   if (func != NULL)</span>
<span class="line-added">1718     {</span>
<span class="line-added">1719       for (i = 0; i &lt; array-&gt;len; i++)</span>
<span class="line-added">1720         rarray_to_extend-&gt;pdata[i + rarray_to_extend-&gt;len] =</span>
<span class="line-added">1721           func (array-&gt;pdata[i], user_data);</span>
<span class="line-added">1722     }</span>
<span class="line-added">1723   else</span>
<span class="line-added">1724     {</span>
<span class="line-added">1725       memcpy (rarray_to_extend-&gt;pdata + rarray_to_extend-&gt;len, array-&gt;pdata,</span>
<span class="line-added">1726               array-&gt;len * sizeof (*array-&gt;pdata));</span>
<span class="line-added">1727     }</span>
<span class="line-added">1728 </span>
<span class="line-added">1729   rarray_to_extend-&gt;len += array-&gt;len;</span>
<span class="line-added">1730 }</span>
<span class="line-added">1731 </span>
<span class="line-added">1732 /**</span>
<span class="line-added">1733  * g_ptr_array_extend_and_steal:</span>
<span class="line-added">1734  * @array_to_extend: (transfer none): a #GPtrArray.</span>
<span class="line-added">1735  * @array: (transfer container): a #GPtrArray to add to the end of</span>
<span class="line-added">1736  *     @array_to_extend.</span>
<span class="line-added">1737  *</span>
<span class="line-added">1738  * Adds all the pointers in @array to the end of @array_to_extend, transferring</span>
<span class="line-added">1739  * ownership of each element from @array to @array_to_extend and modifying</span>
<span class="line-added">1740  * @array_to_extend in-place. @array is then freed.</span>
<span class="line-added">1741  *</span>
<span class="line-added">1742  * As with g_ptr_array_free(), @array will be destroyed if its reference count</span>
<span class="line-added">1743  * is 1. If its reference count is higher, it will be decremented and the</span>
<span class="line-added">1744  * length of @array set to zero.</span>
<span class="line-added">1745  *</span>
<span class="line-added">1746  * Since: 2.62</span>
<span class="line-added">1747  **/</span>
<span class="line-added">1748 void</span>
<span class="line-added">1749 g_ptr_array_extend_and_steal (GPtrArray  *array_to_extend,</span>
<span class="line-added">1750                               GPtrArray  *array)</span>
<span class="line-added">1751 {</span>
<span class="line-added">1752   gpointer *pdata;</span>
<span class="line-added">1753 </span>
<span class="line-added">1754   g_ptr_array_extend (array_to_extend, array, NULL, NULL);</span>
<span class="line-added">1755 </span>
<span class="line-added">1756   /* Get rid of @array without triggering the GDestroyNotify attached</span>
<span class="line-added">1757    * to the elements moved from @array to @array_to_extend. */</span>
<span class="line-added">1758   pdata = g_steal_pointer (&amp;array-&gt;pdata);</span>
<span class="line-added">1759   array-&gt;len = 0;</span>
<span class="line-added">1760   g_ptr_array_unref (array);</span>
<span class="line-added">1761   g_free (pdata);</span>
<span class="line-added">1762 }</span>
<span class="line-added">1763 </span>
1764 /**
1765  * g_ptr_array_insert:
1766  * @array: a #GPtrArray
1767  * @index_: the index to place the new element at, or -1 to append
1768  * @data: the pointer to add.
1769  *
1770  * Inserts an element into the pointer array at the given index. The
1771  * array will grow in size automatically if necessary.
1772  *
1773  * Since: 2.40
1774  */
1775 void
1776 g_ptr_array_insert (GPtrArray *array,
1777                     gint       index_,
1778                     gpointer   data)
1779 {
1780   GRealPtrArray *rarray = (GRealPtrArray *)array;
1781 
1782   g_return_if_fail (rarray);
1783   g_return_if_fail (index_ &gt;= -1);
1784   g_return_if_fail (index_ &lt;= (gint)rarray-&gt;len);
1785 
1786   g_ptr_array_maybe_expand (rarray, 1);
1787 
1788   if (index_ &lt; 0)
1789     index_ = rarray-&gt;len;
1790 
<span class="line-modified">1791   if ((guint) index_ &lt; rarray-&gt;len)</span>
1792     memmove (&amp;(rarray-&gt;pdata[index_ + 1]),
1793              &amp;(rarray-&gt;pdata[index_]),
1794              (rarray-&gt;len - index_) * sizeof (gpointer));
1795 
1796   rarray-&gt;len++;
1797   rarray-&gt;pdata[index_] = data;
1798 }
1799 
1800 /**
1801  * g_ptr_array_sort:
1802  * @array: a #GPtrArray
1803  * @compare_func: comparison function
1804  *
1805  * Sorts the array, using @compare_func which should be a qsort()-style
1806  * comparison function (returns less than zero for first arg is less
1807  * than second arg, zero for equal, greater than zero if irst arg is
1808  * greater than second arg).
1809  *
1810  * Note that the comparison function for g_ptr_array_sort() doesn&#39;t
1811  * take the pointers from the array as arguments, it takes pointers to
</pre>
</td>
</tr>
</table>
<center><a href="galloca.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="garray.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>