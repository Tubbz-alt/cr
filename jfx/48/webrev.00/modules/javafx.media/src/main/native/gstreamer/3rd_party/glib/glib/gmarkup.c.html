<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmarkup.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* gmarkup.c - Simple XML-like parser
   2  *
   3  *  Copyright 2000, 2003 Red Hat, Inc.
   4  *  Copyright 2007, 2008 Ryan Lortie &lt;desrt@desrt.ca&gt;
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Lesser General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2.1 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Lesser General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Lesser General Public License
  17  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  18  */
  19 
  20 #include &quot;config.h&quot;
  21 
  22 #include &lt;stdarg.h&gt;
  23 #include &lt;string.h&gt;
  24 #include &lt;stdio.h&gt;
  25 #include &lt;stdlib.h&gt;
  26 #include &lt;errno.h&gt;
  27 
  28 #include &quot;gmarkup.h&quot;
  29 
  30 #include &quot;gatomic.h&quot;
  31 #include &quot;gslice.h&quot;
  32 #include &quot;galloca.h&quot;
  33 #include &quot;gstrfuncs.h&quot;
  34 #include &quot;gstring.h&quot;
  35 #include &quot;gtestutils.h&quot;
  36 #include &quot;glibintl.h&quot;
  37 #include &quot;gthread.h&quot;
  38 
  39 /**
  40  * SECTION:markup
  41  * @Title: Simple XML Subset Parser
  42  * @Short_description: parses a subset of XML
  43  * @See_also: [XML Specification](http://www.w3.org/TR/REC-xml/)
  44  *
  45  * The &quot;GMarkup&quot; parser is intended to parse a simple markup format
  46  * that&#39;s a subset of XML. This is a small, efficient, easy-to-use
  47  * parser. It should not be used if you expect to interoperate with
  48  * other applications generating full-scale XML, and must not be used if you
  49  * expect to parse untrusted input. However, it&#39;s very
  50  * useful for application data files, config files, etc. where you
  51  * know your application will be the only one writing the file.
  52  * Full-scale XML parsers should be able to parse the subset used by
  53  * GMarkup, so you can easily migrate to full-scale XML at a later
  54  * time if the need arises.
  55  *
  56  * GMarkup is not guaranteed to signal an error on all invalid XML;
  57  * the parser may accept documents that an XML parser would not.
  58  * However, XML documents which are not well-formed (which is a
  59  * weaker condition than being valid. See the
  60  * [XML specification](http://www.w3.org/TR/REC-xml/)
  61  * for definitions of these terms.) are not considered valid GMarkup
  62  * documents.
  63  *
  64  * Simplifications to XML include:
  65  *
  66  * - Only UTF-8 encoding is allowed
  67  *
  68  * - No user-defined entities
  69  *
  70  * - Processing instructions, comments and the doctype declaration
  71  *   are &quot;passed through&quot; but are not interpreted in any way
  72  *
  73  * - No DTD or validation
  74  *
  75  * The markup format does support:
  76  *
  77  * - Elements
  78  *
  79  * - Attributes
  80  *
  81  * - 5 standard entities: &amp;amp; &amp;lt; &amp;gt; &amp;quot; &amp;apos;
  82  *
  83  * - Character references
  84  *
  85  * - Sections marked as CDATA
  86  */
  87 
  88 G_DEFINE_QUARK (g-markup-error-quark, g_markup_error)
  89 
  90 typedef enum
  91 {
  92   STATE_START,
  93   STATE_AFTER_OPEN_ANGLE,
  94   STATE_AFTER_CLOSE_ANGLE,
  95   STATE_AFTER_ELISION_SLASH, /* the slash that obviates need for end element */
  96   STATE_INSIDE_OPEN_TAG_NAME,
  97   STATE_INSIDE_ATTRIBUTE_NAME,
  98   STATE_AFTER_ATTRIBUTE_NAME,
  99   STATE_BETWEEN_ATTRIBUTES,
 100   STATE_AFTER_ATTRIBUTE_EQUALS_SIGN,
 101   STATE_INSIDE_ATTRIBUTE_VALUE_SQ,
 102   STATE_INSIDE_ATTRIBUTE_VALUE_DQ,
 103   STATE_INSIDE_TEXT,
 104   STATE_AFTER_CLOSE_TAG_SLASH,
 105   STATE_INSIDE_CLOSE_TAG_NAME,
 106   STATE_AFTER_CLOSE_TAG_NAME,
 107   STATE_INSIDE_PASSTHROUGH,
 108   STATE_ERROR
 109 } GMarkupParseState;
 110 
 111 typedef struct
 112 {
 113   const char *prev_element;
 114   const GMarkupParser *prev_parser;
 115   gpointer prev_user_data;
 116 } GMarkupRecursionTracker;
 117 
 118 struct _GMarkupParseContext
 119 {
 120   const GMarkupParser *parser;
 121 
 122   volatile gint ref_count;
 123 
 124   GMarkupParseFlags flags;
 125 
 126   gint line_number;
 127   gint char_number;
 128 
 129   GMarkupParseState state;
 130 
 131   gpointer user_data;
 132   GDestroyNotify dnotify;
 133 
 134   /* A piece of character data or an element that
 135    * hasn&#39;t &quot;ended&quot; yet so we haven&#39;t yet called
 136    * the callback for it.
 137    */
 138   GString *partial_chunk;
 139   GSList *spare_chunks;
 140 
 141   GSList *tag_stack;
 142   GSList *tag_stack_gstr;
 143   GSList *spare_list_nodes;
 144 
 145   GString **attr_names;
 146   GString **attr_values;
 147   gint cur_attr;
 148   gint alloc_attrs;
 149 
 150   const gchar *current_text;
 151   gssize       current_text_len;
 152   const gchar *current_text_end;
 153 
 154   /* used to save the start of the last interesting thingy */
 155   const gchar *start;
 156 
 157   const gchar *iter;
 158 
 159   guint document_empty : 1;
 160   guint parsing : 1;
 161   guint awaiting_pop : 1;
 162   gint balance;
 163 
 164   /* subparser support */
 165   GSList *subparser_stack; /* (GMarkupRecursionTracker *) */
 166   const char *subparser_element;
 167   gpointer held_user_data;
 168 };
 169 
 170 /*
 171  * Helpers to reduce our allocation overhead, we have
 172  * a well defined allocation lifecycle.
 173  */
 174 static GSList *
 175 get_list_node (GMarkupParseContext *context, gpointer data)
 176 {
 177   GSList *node;
 178   if (context-&gt;spare_list_nodes != NULL)
 179     {
 180       node = context-&gt;spare_list_nodes;
 181       context-&gt;spare_list_nodes = g_slist_remove_link (context-&gt;spare_list_nodes, node);
 182     }
 183   else
 184     node = g_slist_alloc();
 185   node-&gt;data = data;
 186   return node;
 187 }
 188 
 189 static void
 190 free_list_node (GMarkupParseContext *context, GSList *node)
 191 {
 192   node-&gt;data = NULL;
 193   context-&gt;spare_list_nodes = g_slist_concat (node, context-&gt;spare_list_nodes);
 194 }
 195 
 196 static inline void
 197 string_blank (GString *string)
 198 {
 199   string-&gt;str[0] = &#39;\0&#39;;
 200   string-&gt;len = 0;
 201 }
 202 
 203 /**
 204  * g_markup_parse_context_new:
 205  * @parser: a #GMarkupParser
 206  * @flags: one or more #GMarkupParseFlags
 207  * @user_data: user data to pass to #GMarkupParser functions
 208  * @user_data_dnotify: user data destroy notifier called when
 209  *     the parse context is freed
 210  *
 211  * Creates a new parse context. A parse context is used to parse
 212  * marked-up documents. You can feed any number of documents into
 213  * a context, as long as no errors occur; once an error occurs,
 214  * the parse context can&#39;t continue to parse text (you have to
 215  * free it and create a new parse context).
 216  *
 217  * Returns: a new #GMarkupParseContext
 218  **/
 219 GMarkupParseContext *
 220 g_markup_parse_context_new (const GMarkupParser *parser,
 221                             GMarkupParseFlags    flags,
 222                             gpointer             user_data,
 223                             GDestroyNotify       user_data_dnotify)
 224 {
 225   GMarkupParseContext *context;
 226 
 227   g_return_val_if_fail (parser != NULL, NULL);
 228 
 229   context = g_new (GMarkupParseContext, 1);
 230 
 231   context-&gt;ref_count = 1;
 232   context-&gt;parser = parser;
 233   context-&gt;flags = flags;
 234   context-&gt;user_data = user_data;
 235   context-&gt;dnotify = user_data_dnotify;
 236 
 237   context-&gt;line_number = 1;
 238   context-&gt;char_number = 1;
 239 
 240   context-&gt;partial_chunk = NULL;
 241   context-&gt;spare_chunks = NULL;
 242   context-&gt;spare_list_nodes = NULL;
 243 
 244   context-&gt;state = STATE_START;
 245   context-&gt;tag_stack = NULL;
 246   context-&gt;tag_stack_gstr = NULL;
 247   context-&gt;attr_names = NULL;
 248   context-&gt;attr_values = NULL;
 249   context-&gt;cur_attr = -1;
 250   context-&gt;alloc_attrs = 0;
 251 
 252   context-&gt;current_text = NULL;
 253   context-&gt;current_text_len = -1;
 254   context-&gt;current_text_end = NULL;
 255 
 256   context-&gt;start = NULL;
 257   context-&gt;iter = NULL;
 258 
 259   context-&gt;document_empty = TRUE;
 260   context-&gt;parsing = FALSE;
 261 
 262   context-&gt;awaiting_pop = FALSE;
 263   context-&gt;subparser_stack = NULL;
 264   context-&gt;subparser_element = NULL;
 265 
 266   /* this is only looked at if awaiting_pop = TRUE.  initialise anyway. */
 267   context-&gt;held_user_data = NULL;
 268 
 269   context-&gt;balance = 0;
 270 
 271   return context;
 272 }
 273 
 274 /**
 275  * g_markup_parse_context_ref:
 276  * @context: a #GMarkupParseContext
 277  *
 278  * Increases the reference count of @context.
 279  *
 280  * Returns: the same @context
 281  *
 282  * Since: 2.36
 283  **/
 284 GMarkupParseContext *
 285 g_markup_parse_context_ref (GMarkupParseContext *context)
 286 {
 287   g_return_val_if_fail (context != NULL, NULL);
 288   g_return_val_if_fail (context-&gt;ref_count &gt; 0, NULL);
 289 
 290   g_atomic_int_inc (&amp;context-&gt;ref_count);
 291 
 292   return context;
 293 }
 294 
 295 /**
 296  * g_markup_parse_context_unref:
 297  * @context: a #GMarkupParseContext
 298  *
 299  * Decreases the reference count of @context.  When its reference count
 300  * drops to 0, it is freed.
 301  *
 302  * Since: 2.36
 303  **/
 304 void
 305 g_markup_parse_context_unref (GMarkupParseContext *context)
 306 {
 307   g_return_if_fail (context != NULL);
 308   g_return_if_fail (context-&gt;ref_count &gt; 0);
 309 
 310   if (g_atomic_int_dec_and_test (&amp;context-&gt;ref_count))
 311     g_markup_parse_context_free (context);
 312 }
 313 
 314 static void
 315 string_full_free (gpointer ptr)
 316 {
 317   g_string_free (ptr, TRUE);
 318 }
 319 
 320 static void clear_attributes (GMarkupParseContext *context);
 321 
 322 /**
 323  * g_markup_parse_context_free:
 324  * @context: a #GMarkupParseContext
 325  *
 326  * Frees a #GMarkupParseContext.
 327  *
 328  * This function can&#39;t be called from inside one of the
 329  * #GMarkupParser functions or while a subparser is pushed.
 330  */
 331 void
 332 g_markup_parse_context_free (GMarkupParseContext *context)
 333 {
 334   g_return_if_fail (context != NULL);
 335   g_return_if_fail (!context-&gt;parsing);
 336   g_return_if_fail (!context-&gt;subparser_stack);
 337   g_return_if_fail (!context-&gt;awaiting_pop);
 338 
 339   if (context-&gt;dnotify)
 340     (* context-&gt;dnotify) (context-&gt;user_data);
 341 
 342   clear_attributes (context);
 343   g_free (context-&gt;attr_names);
 344   g_free (context-&gt;attr_values);
 345 
 346   g_slist_free_full (context-&gt;tag_stack_gstr, string_full_free);
 347   g_slist_free (context-&gt;tag_stack);
 348 
 349   g_slist_free_full (context-&gt;spare_chunks, string_full_free);
 350   g_slist_free (context-&gt;spare_list_nodes);
 351 
 352   if (context-&gt;partial_chunk)
 353     g_string_free (context-&gt;partial_chunk, TRUE);
 354 
 355   g_free (context);
 356 }
 357 
 358 static void pop_subparser_stack (GMarkupParseContext *context);
 359 
 360 static void
 361 mark_error (GMarkupParseContext *context,
 362             GError              *error)
 363 {
 364   context-&gt;state = STATE_ERROR;
 365 
 366   if (context-&gt;parser-&gt;error)
 367     (*context-&gt;parser-&gt;error) (context, error, context-&gt;user_data);
 368 
 369   /* report the error all the way up to free all the user-data */
 370   while (context-&gt;subparser_stack)
 371     {
 372       pop_subparser_stack (context);
 373       context-&gt;awaiting_pop = FALSE; /* already been freed */
 374 
 375       if (context-&gt;parser-&gt;error)
 376         (*context-&gt;parser-&gt;error) (context, error, context-&gt;user_data);
 377     }
 378 }
 379 
 380 static void
 381 set_error (GMarkupParseContext  *context,
 382            GError              **error,
 383            GMarkupError          code,
 384            const gchar          *format,
 385            ...) G_GNUC_PRINTF (4, 5);
 386 
 387 static void
 388 set_error_literal (GMarkupParseContext  *context,
 389                    GError              **error,
 390                    GMarkupError          code,
 391                    const gchar          *message)
 392 {
 393   GError *tmp_error;
 394 
 395   tmp_error = g_error_new_literal (G_MARKUP_ERROR, code, message);
 396 
 397   g_prefix_error (&amp;tmp_error,
 398                   _(&quot;Error on line %d char %d: &quot;),
 399                   context-&gt;line_number,
 400                   context-&gt;char_number);
 401 
 402   mark_error (context, tmp_error);
 403 
 404   g_propagate_error (error, tmp_error);
 405 }
 406 
 407 G_GNUC_PRINTF(4, 5)
 408 static void
 409 set_error (GMarkupParseContext  *context,
 410            GError              **error,
 411            GMarkupError          code,
 412            const gchar          *format,
 413            ...)
 414 {
 415   gchar *s;
 416   gchar *s_valid;
 417   va_list args;
 418 
 419   va_start (args, format);
 420   s = g_strdup_vprintf (format, args);
 421   va_end (args);
 422 
 423   /* Make sure that the GError message is valid UTF-8
 424    * even if it is complaining about invalid UTF-8 in the markup
 425    */
 426   s_valid = g_utf8_make_valid (s, -1);
 427   set_error_literal (context, error, code, s);
 428 
 429   g_free (s);
 430   g_free (s_valid);
 431 }
 432 
 433 static void
 434 propagate_error (GMarkupParseContext  *context,
 435                  GError              **dest,
 436                  GError               *src)
 437 {
 438   if (context-&gt;flags &amp; G_MARKUP_PREFIX_ERROR_POSITION)
 439     g_prefix_error (&amp;src,
 440                     _(&quot;Error on line %d char %d: &quot;),
 441                     context-&gt;line_number,
 442                     context-&gt;char_number);
 443 
 444   mark_error (context, src);
 445 
 446   g_propagate_error (dest, src);
 447 }
 448 
 449 #define IS_COMMON_NAME_END_CHAR(c) \
 450   ((c) == &#39;=&#39; || (c) == &#39;/&#39; || (c) == &#39;&gt;&#39; || (c) == &#39; &#39;)
 451 
 452 static gboolean
 453 slow_name_validate (GMarkupParseContext  *context,
 454                     const gchar          *name,
 455                     GError              **error)
 456 {
 457   const gchar *p = name;
 458 
 459   if (!g_utf8_validate (name, -1, NULL))
 460     {
 461       set_error (context, error, G_MARKUP_ERROR_BAD_UTF8,
 462                  _(&quot;Invalid UTF-8 encoded text in name - not valid &#39;%s&#39;&quot;), name);
 463       return FALSE;
 464     }
 465 
 466   if (!(g_ascii_isalpha (*p) ||
 467         (!IS_COMMON_NAME_END_CHAR (*p) &amp;&amp;
 468          (*p == &#39;_&#39; ||
 469           *p == &#39;:&#39; ||
 470           g_unichar_isalpha (g_utf8_get_char (p))))))
 471     {
 472       set_error (context, error, G_MARKUP_ERROR_PARSE,
 473                  _(&quot;&#39;%s&#39; is not a valid name&quot;), name);
 474       return FALSE;
 475     }
 476 
 477   for (p = g_utf8_next_char (name); *p != &#39;\0&#39;; p = g_utf8_next_char (p))
 478     {
 479       /* is_name_char */
 480       if (!(g_ascii_isalnum (*p) ||
 481             (!IS_COMMON_NAME_END_CHAR (*p) &amp;&amp;
 482              (*p == &#39;.&#39; ||
 483               *p == &#39;-&#39; ||
 484               *p == &#39;_&#39; ||
 485               *p == &#39;:&#39; ||
 486               g_unichar_isalpha (g_utf8_get_char (p))))))
 487         {
 488           set_error (context, error, G_MARKUP_ERROR_PARSE,
 489                      _(&quot;&#39;%s&#39; is not a valid name: &#39;%c&#39;&quot;), name, *p);
 490           return FALSE;
 491         }
 492     }
 493   return TRUE;
 494 }
 495 
 496 /*
 497  * Use me for elements, attributes etc.
 498  */
 499 static gboolean
 500 name_validate (GMarkupParseContext  *context,
 501                const gchar          *name,
 502                GError              **error)
 503 {
 504   char mask;
 505   const char *p;
 506 
 507   /* name start char */
 508   p = name;
 509   if (G_UNLIKELY (IS_COMMON_NAME_END_CHAR (*p) ||
 510                   !(g_ascii_isalpha (*p) || *p == &#39;_&#39; || *p == &#39;:&#39;)))
 511     goto slow_validate;
 512 
 513   for (mask = *p++; *p != &#39;\0&#39;; p++)
 514     {
 515       mask |= *p;
 516 
 517       /* is_name_char */
 518       if (G_UNLIKELY (!(g_ascii_isalnum (*p) ||
 519                         (!IS_COMMON_NAME_END_CHAR (*p) &amp;&amp;
 520                          (*p == &#39;.&#39; ||
 521                           *p == &#39;-&#39; ||
 522                           *p == &#39;_&#39; ||
 523                           *p == &#39;:&#39;)))))
 524         goto slow_validate;
 525     }
 526 
 527   if (mask &amp; 0x80) /* un-common / non-ascii */
 528     goto slow_validate;
 529 
 530   return TRUE;
 531 
 532  slow_validate:
 533   return slow_name_validate (context, name, error);
 534 }
 535 
 536 static gboolean
 537 text_validate (GMarkupParseContext  *context,
 538                const gchar          *p,
 539                gint                  len,
 540                GError              **error)
 541 {
 542   if (!g_utf8_validate_len (p, len, NULL))
 543     {
 544       set_error (context, error, G_MARKUP_ERROR_BAD_UTF8,
 545                  _(&quot;Invalid UTF-8 encoded text in name - not valid &#39;%s&#39;&quot;), p);
 546       return FALSE;
 547     }
 548   else
 549     return TRUE;
 550 }
 551 
 552 static gchar*
 553 char_str (gunichar c,
 554           gchar   *buf)
 555 {
 556   memset (buf, 0, 8);
 557   g_unichar_to_utf8 (c, buf);
 558   return buf;
 559 }
 560 
 561 /* Format the next UTF-8 character as a gchar* for printing in error output
 562  * when we encounter a syntax error. This correctly handles invalid UTF-8,
 563  * emitting it as hex escapes. */
 564 static gchar*
 565 utf8_str (const gchar *utf8,
 566           gsize        max_len,
 567           gchar       *buf)
 568 {
 569   gunichar c = g_utf8_get_char_validated (utf8, max_len);
 570   if (c == (gunichar) -1 || c == (gunichar) -2)
 571     {
 572       guchar ch = (max_len &gt; 0) ? (guchar) *utf8 : 0;
 573       gchar *temp = g_strdup_printf (&quot;\\x%02x&quot;, (guint) ch);
 574       memset (buf, 0, 8);
 575       memcpy (buf, temp, strlen (temp));
 576       g_free (temp);
 577     }
 578   else
 579     char_str (c, buf);
 580   return buf;
 581 }
 582 
 583 G_GNUC_PRINTF(5, 6)
 584 static void
 585 set_unescape_error (GMarkupParseContext  *context,
 586                     GError              **error,
 587                     const gchar          *remaining_text,
 588                     GMarkupError          code,
 589                     const gchar          *format,
 590                     ...)
 591 {
 592   GError *tmp_error;
 593   gchar *s;
 594   va_list args;
 595   gint remaining_newlines;
 596   const gchar *p;
 597 
 598   remaining_newlines = 0;
 599   p = remaining_text;
 600   while (*p != &#39;\0&#39;)
 601     {
 602       if (*p == &#39;\n&#39;)
 603         ++remaining_newlines;
 604       ++p;
 605     }
 606 
 607   va_start (args, format);
 608   s = g_strdup_vprintf (format, args);
 609   va_end (args);
 610 
 611   tmp_error = g_error_new (G_MARKUP_ERROR,
 612                            code,
 613                            _(&quot;Error on line %d: %s&quot;),
 614                            context-&gt;line_number - remaining_newlines,
 615                            s);
 616 
 617   g_free (s);
 618 
 619   mark_error (context, tmp_error);
 620 
 621   g_propagate_error (error, tmp_error);
 622 }
 623 
 624 /*
 625  * re-write the GString in-place, unescaping anything that escaped.
 626  * most XML does not contain entities, or escaping.
 627  */
 628 static gboolean
 629 unescape_gstring_inplace (GMarkupParseContext  *context,
 630                           GString              *string,
 631                           gboolean             *is_ascii,
 632                           GError              **error)
 633 {
 634   char mask, *to;
 635   const char *from;
 636   gboolean normalize_attribute;
 637 
 638   *is_ascii = FALSE;
 639 
 640   /* are we unescaping an attribute or not ? */
 641   if (context-&gt;state == STATE_INSIDE_ATTRIBUTE_VALUE_SQ ||
 642       context-&gt;state == STATE_INSIDE_ATTRIBUTE_VALUE_DQ)
 643     normalize_attribute = TRUE;
 644   else
 645     normalize_attribute = FALSE;
 646 
 647   /*
 648    * Meeks&#39; theorem: unescaping can only shrink text.
 649    * for &amp;lt; etc. this is obvious, for &amp;#xffff; more
 650    * thought is required, but this is patently so.
 651    */
 652   mask = 0;
 653   for (from = to = string-&gt;str; *from != &#39;\0&#39;; from++, to++)
 654     {
 655       *to = *from;
 656 
 657       mask |= *to;
 658       if (normalize_attribute &amp;&amp; (*to == &#39;\t&#39; || *to == &#39;\n&#39;))
 659         *to = &#39; &#39;;
 660       if (*to == &#39;\r&#39;)
 661         {
 662           *to = normalize_attribute ? &#39; &#39; : &#39;\n&#39;;
 663           if (from[1] == &#39;\n&#39;)
 664             from++;
 665         }
 666       if (*from == &#39;&amp;&#39;)
 667         {
 668           from++;
 669           if (*from == &#39;#&#39;)
 670             {
 671               gint base = 10;
 672               gulong l;
 673               gchar *end = NULL;
 674 
 675               from++;
 676 
 677               if (*from == &#39;x&#39;)
 678                 {
 679                   base = 16;
 680                   from++;
 681                 }
 682 
 683               errno = 0;
 684               l = strtoul (from, &amp;end, base);
 685 
 686               if (end == from || errno != 0)
 687                 {
 688                   set_unescape_error (context, error,
 689                                       from, G_MARKUP_ERROR_PARSE,
 690                                       _(&quot;Failed to parse &#39;%-.*s&#39;, which &quot;
 691                                         &quot;should have been a digit &quot;
 692                                         &quot;inside a character reference &quot;
 693                                         &quot;(&amp;#234; for example) - perhaps &quot;
 694                                         &quot;the digit is too large&quot;),
 695                                       (int)(end - from), from);
 696                   return FALSE;
 697                 }
 698               else if (*end != &#39;;&#39;)
 699                 {
 700                   set_unescape_error (context, error,
 701                                       from, G_MARKUP_ERROR_PARSE,
 702                                       _(&quot;Character reference did not end with a &quot;
 703                                         &quot;semicolon; &quot;
 704                                         &quot;most likely you used an ampersand &quot;
 705                                         &quot;character without intending to start &quot;
 706                                         &quot;an entity - escape ampersand as &amp;amp;&quot;));
 707                   return FALSE;
 708                 }
 709               else
 710                 {
 711                   /* characters XML 1.1 permits */
 712                   if ((0 &lt; l &amp;&amp; l &lt;= 0xD7FF) ||
 713                       (0xE000 &lt;= l &amp;&amp; l &lt;= 0xFFFD) ||
 714                       (0x10000 &lt;= l &amp;&amp; l &lt;= 0x10FFFF))
 715                     {
 716                       gchar buf[8];
 717                       char_str (l, buf);
 718                       strcpy (to, buf);
 719                       to += strlen (buf) - 1;
 720                       from = end;
 721                       if (l &gt;= 0x80) /* not ascii */
 722                         mask |= 0x80;
 723                     }
 724                   else
 725                     {
 726                       set_unescape_error (context, error,
 727                                           from, G_MARKUP_ERROR_PARSE,
 728                                           _(&quot;Character reference &#39;%-.*s&#39; does not &quot;
 729                                             &quot;encode a permitted character&quot;),
 730                                           (int)(end - from), from);
 731                       return FALSE;
 732                     }
 733                 }
 734             }
 735 
 736           else if (strncmp (from, &quot;lt;&quot;, 3) == 0)
 737             {
 738               *to = &#39;&lt;&#39;;
 739               from += 2;
 740             }
 741           else if (strncmp (from, &quot;gt;&quot;, 3) == 0)
 742             {
 743               *to = &#39;&gt;&#39;;
 744               from += 2;
 745             }
 746           else if (strncmp (from, &quot;amp;&quot;, 4) == 0)
 747             {
 748               *to = &#39;&amp;&#39;;
 749               from += 3;
 750             }
 751           else if (strncmp (from, &quot;quot;&quot;, 5) == 0)
 752             {
 753               *to = &#39;&quot;&#39;;
 754               from += 4;
 755             }
 756           else if (strncmp (from, &quot;apos;&quot;, 5) == 0)
 757             {
 758               *to = &#39;\&#39;&#39;;
 759               from += 4;
 760             }
 761           else
 762             {
 763               if (*from == &#39;;&#39;)
 764                 set_unescape_error (context, error,
 765                                     from, G_MARKUP_ERROR_PARSE,
 766                                     _(&quot;Empty entity &#39;&amp;;&#39; seen; valid &quot;
 767                                       &quot;entities are: &amp;amp; &amp;quot; &amp;lt; &amp;gt; &amp;apos;&quot;));
 768               else
 769                 {
 770                   const char *end = strchr (from, &#39;;&#39;);
 771                   if (end)
 772                     set_unescape_error (context, error,
 773                                         from, G_MARKUP_ERROR_PARSE,
 774                                         _(&quot;Entity name &#39;%-.*s&#39; is not known&quot;),
 775                                         (int)(end - from), from);
 776                   else
 777                     set_unescape_error (context, error,
 778                                         from, G_MARKUP_ERROR_PARSE,
 779                                         _(&quot;Entity did not end with a semicolon; &quot;
 780                                           &quot;most likely you used an ampersand &quot;
 781                                           &quot;character without intending to start &quot;
 782                                           &quot;an entity - escape ampersand as &amp;amp;&quot;));
 783                 }
 784               return FALSE;
 785             }
 786         }
 787     }
 788 
 789   g_assert (to - string-&gt;str &lt;= (gssize) string-&gt;len);
 790   if (to - string-&gt;str != (gssize) string-&gt;len)
 791     g_string_truncate (string, to - string-&gt;str);
 792 
 793   *is_ascii = !(mask &amp; 0x80);
 794 
 795   return TRUE;
 796 }
 797 
 798 static inline gboolean
 799 advance_char (GMarkupParseContext *context)
 800 {
 801   context-&gt;iter++;
 802   context-&gt;char_number++;
 803 
 804   if (G_UNLIKELY (context-&gt;iter == context-&gt;current_text_end))
 805       return FALSE;
 806 
 807   else if (G_UNLIKELY (*context-&gt;iter == &#39;\n&#39;))
 808     {
 809       context-&gt;line_number++;
 810       context-&gt;char_number = 1;
 811     }
 812 
 813   return TRUE;
 814 }
 815 
 816 static inline gboolean
 817 xml_isspace (char c)
 818 {
 819   return c == &#39; &#39; || c == &#39;\t&#39; || c == &#39;\n&#39; || c == &#39;\r&#39;;
 820 }
 821 
 822 static void
 823 skip_spaces (GMarkupParseContext *context)
 824 {
 825   do
 826     {
 827       if (!xml_isspace (*context-&gt;iter))
 828         return;
 829     }
 830   while (advance_char (context));
 831 }
 832 
 833 static void
 834 advance_to_name_end (GMarkupParseContext *context)
 835 {
 836   do
 837     {
 838       if (IS_COMMON_NAME_END_CHAR (*(context-&gt;iter)))
 839         return;
 840       if (xml_isspace (*(context-&gt;iter)))
 841         return;
 842     }
 843   while (advance_char (context));
 844 }
 845 
 846 static void
 847 release_chunk (GMarkupParseContext *context, GString *str)
 848 {
 849   GSList *node;
 850   if (!str)
 851     return;
 852   if (str-&gt;allocated_len &gt; 256)
 853     { /* large strings are unusual and worth freeing */
 854       g_string_free (str, TRUE);
 855       return;
 856     }
 857   string_blank (str);
 858   node = get_list_node (context, str);
 859   context-&gt;spare_chunks = g_slist_concat (node, context-&gt;spare_chunks);
 860 }
 861 
 862 static void
 863 add_to_partial (GMarkupParseContext *context,
 864                 const gchar         *text_start,
 865                 const gchar         *text_end)
 866 {
 867   if (context-&gt;partial_chunk == NULL)
 868     { /* allocate a new chunk to parse into */
 869 
 870       if (context-&gt;spare_chunks != NULL)
 871         {
 872           GSList *node = context-&gt;spare_chunks;
 873           context-&gt;spare_chunks = g_slist_remove_link (context-&gt;spare_chunks, node);
 874           context-&gt;partial_chunk = node-&gt;data;
 875           free_list_node (context, node);
 876         }
 877       else
 878         context-&gt;partial_chunk = g_string_sized_new (MAX (28, text_end - text_start));
 879     }
 880 
 881   if (text_start != text_end)
 882     g_string_insert_len (context-&gt;partial_chunk, -1,
 883                          text_start, text_end - text_start);
 884 }
 885 
 886 static inline void
 887 truncate_partial (GMarkupParseContext *context)
 888 {
 889   if (context-&gt;partial_chunk != NULL)
 890     string_blank (context-&gt;partial_chunk);
 891 }
 892 
 893 static inline const gchar*
 894 current_element (GMarkupParseContext *context)
 895 {
 896   return context-&gt;tag_stack-&gt;data;
 897 }
 898 
 899 static void
 900 pop_subparser_stack (GMarkupParseContext *context)
 901 {
 902   GMarkupRecursionTracker *tracker;
 903 
 904   g_assert (context-&gt;subparser_stack);
 905 
 906   tracker = context-&gt;subparser_stack-&gt;data;
 907 
 908   context-&gt;awaiting_pop = TRUE;
 909   context-&gt;held_user_data = context-&gt;user_data;
 910 
 911   context-&gt;user_data = tracker-&gt;prev_user_data;
 912   context-&gt;parser = tracker-&gt;prev_parser;
 913   context-&gt;subparser_element = tracker-&gt;prev_element;
 914   g_slice_free (GMarkupRecursionTracker, tracker);
 915 
 916   context-&gt;subparser_stack = g_slist_delete_link (context-&gt;subparser_stack,
 917                                                   context-&gt;subparser_stack);
 918 }
 919 
 920 static void
 921 push_partial_as_tag (GMarkupParseContext *context)
 922 {
 923   GString *str = context-&gt;partial_chunk;
 924   /* sadly, this is exported by gmarkup_get_element_stack as-is */
 925   context-&gt;tag_stack = g_slist_concat (get_list_node (context, str-&gt;str), context-&gt;tag_stack);
 926   context-&gt;tag_stack_gstr = g_slist_concat (get_list_node (context, str), context-&gt;tag_stack_gstr);
 927   context-&gt;partial_chunk = NULL;
 928 }
 929 
 930 static void
 931 pop_tag (GMarkupParseContext *context)
 932 {
 933   GSList *nodea, *nodeb;
 934 
 935   nodea = context-&gt;tag_stack;
 936   nodeb = context-&gt;tag_stack_gstr;
 937   release_chunk (context, nodeb-&gt;data);
 938   context-&gt;tag_stack = g_slist_remove_link (context-&gt;tag_stack, nodea);
 939   context-&gt;tag_stack_gstr = g_slist_remove_link (context-&gt;tag_stack_gstr, nodeb);
 940   free_list_node (context, nodea);
 941   free_list_node (context, nodeb);
 942 }
 943 
 944 static void
 945 possibly_finish_subparser (GMarkupParseContext *context)
 946 {
 947   if (current_element (context) == context-&gt;subparser_element)
 948     pop_subparser_stack (context);
 949 }
 950 
 951 static void
 952 ensure_no_outstanding_subparser (GMarkupParseContext *context)
 953 {
 954   if (context-&gt;awaiting_pop)
 955     g_critical (&quot;During the first end_element call after invoking a &quot;
 956                 &quot;subparser you must pop the subparser stack and handle &quot;
 957                 &quot;the freeing of the subparser user_data.  This can be &quot;
 958                 &quot;done by calling the end function of the subparser.  &quot;
 959                 &quot;Very probably, your program just leaked memory.&quot;);
 960 
 961   /* let valgrind watch the pointer disappear... */
 962   context-&gt;held_user_data = NULL;
 963   context-&gt;awaiting_pop = FALSE;
 964 }
 965 
 966 static const gchar*
 967 current_attribute (GMarkupParseContext *context)
 968 {
 969   g_assert (context-&gt;cur_attr &gt;= 0);
 970   return context-&gt;attr_names[context-&gt;cur_attr]-&gt;str;
 971 }
 972 
 973 static void
 974 add_attribute (GMarkupParseContext *context, GString *str)
 975 {
 976   if (context-&gt;cur_attr + 2 &gt;= context-&gt;alloc_attrs)
 977     {
 978       context-&gt;alloc_attrs += 5; /* silly magic number */
 979       context-&gt;attr_names = g_realloc (context-&gt;attr_names, sizeof(GString*)*context-&gt;alloc_attrs);
 980       context-&gt;attr_values = g_realloc (context-&gt;attr_values, sizeof(GString*)*context-&gt;alloc_attrs);
 981     }
 982   context-&gt;cur_attr++;
 983   context-&gt;attr_names[context-&gt;cur_attr] = str;
 984   context-&gt;attr_values[context-&gt;cur_attr] = NULL;
 985   context-&gt;attr_names[context-&gt;cur_attr+1] = NULL;
 986   context-&gt;attr_values[context-&gt;cur_attr+1] = NULL;
 987 }
 988 
 989 static void
 990 clear_attributes (GMarkupParseContext *context)
 991 {
 992   /* Go ahead and free the attributes. */
 993   for (; context-&gt;cur_attr &gt;= 0; context-&gt;cur_attr--)
 994     {
 995       int pos = context-&gt;cur_attr;
 996       release_chunk (context, context-&gt;attr_names[pos]);
 997       release_chunk (context, context-&gt;attr_values[pos]);
 998       context-&gt;attr_names[pos] = context-&gt;attr_values[pos] = NULL;
 999     }
1000   g_assert (context-&gt;cur_attr == -1);
1001   g_assert (context-&gt;attr_names == NULL ||
1002             context-&gt;attr_names[0] == NULL);
1003   g_assert (context-&gt;attr_values == NULL ||
1004             context-&gt;attr_values[0] == NULL);
1005 }
1006 
1007 /* This has to be a separate function to ensure the alloca&#39;s
1008  * are unwound on exit - otherwise we grow &amp; blow the stack
1009  * with large documents
1010  */
1011 static inline void
1012 emit_start_element (GMarkupParseContext  *context,
1013                     GError              **error)
1014 {
1015   int i, j = 0;
1016   const gchar *start_name;
1017   const gchar **attr_names;
1018   const gchar **attr_values;
1019   GError *tmp_error;
1020 
1021   /* In case we want to ignore qualified tags and we see that we have
1022    * one here, we push a subparser.  This will ignore all tags inside of
1023    * the qualified tag.
1024    *
1025    * We deal with the end of the subparser from emit_end_element.
1026    */
1027   if ((context-&gt;flags &amp; G_MARKUP_IGNORE_QUALIFIED) &amp;&amp; strchr (current_element (context), &#39;:&#39;))
1028     {
1029       static const GMarkupParser ignore_parser;
1030       g_markup_parse_context_push (context, &amp;ignore_parser, NULL);
1031       clear_attributes (context);
1032       return;
1033     }
1034 
1035   attr_names = g_newa (const gchar *, context-&gt;cur_attr + 2);
1036   attr_values = g_newa (const gchar *, context-&gt;cur_attr + 2);
1037   for (i = 0; i &lt; context-&gt;cur_attr + 1; i++)
1038     {
1039       /* Possibly omit qualified attribute names from the list */
1040       if ((context-&gt;flags &amp; G_MARKUP_IGNORE_QUALIFIED) &amp;&amp; strchr (context-&gt;attr_names[i]-&gt;str, &#39;:&#39;))
1041         continue;
1042 
1043       attr_names[j] = context-&gt;attr_names[i]-&gt;str;
1044       attr_values[j] = context-&gt;attr_values[i]-&gt;str;
1045       j++;
1046     }
1047   attr_names[j] = NULL;
1048   attr_values[j] = NULL;
1049 
1050   /* Call user callback for element start */
1051   tmp_error = NULL;
1052   start_name = current_element (context);
1053 
1054   if (!name_validate (context, start_name, error))
1055     return;
1056 
1057   if (context-&gt;parser-&gt;start_element)
1058     (* context-&gt;parser-&gt;start_element) (context,
1059                                         start_name,
1060                                         (const gchar **)attr_names,
1061                                         (const gchar **)attr_values,
1062                                         context-&gt;user_data,
1063                                         &amp;tmp_error);
1064   clear_attributes (context);
1065 
1066   if (tmp_error != NULL)
1067     propagate_error (context, error, tmp_error);
1068 }
1069 
1070 static void
1071 emit_end_element (GMarkupParseContext  *context,
1072                   GError              **error)
1073 {
1074   /* We need to pop the tag stack and call the end_element
1075    * function, since this is the close tag
1076    */
1077   GError *tmp_error = NULL;
1078 
1079   g_assert (context-&gt;tag_stack != NULL);
1080 
1081   possibly_finish_subparser (context);
1082 
1083   /* We might have just returned from our ignore subparser */
1084   if ((context-&gt;flags &amp; G_MARKUP_IGNORE_QUALIFIED) &amp;&amp; strchr (current_element (context), &#39;:&#39;))
1085     {
1086       g_markup_parse_context_pop (context);
1087       pop_tag (context);
1088       return;
1089     }
1090 
1091   tmp_error = NULL;
1092   if (context-&gt;parser-&gt;end_element)
1093     (* context-&gt;parser-&gt;end_element) (context,
1094                                       current_element (context),
1095                                       context-&gt;user_data,
1096                                       &amp;tmp_error);
1097 
1098   ensure_no_outstanding_subparser (context);
1099 
1100   if (tmp_error)
1101     {
1102       mark_error (context, tmp_error);
1103       g_propagate_error (error, tmp_error);
1104     }
1105 
1106   pop_tag (context);
1107 }
1108 
1109 /**
1110  * g_markup_parse_context_parse:
1111  * @context: a #GMarkupParseContext
1112  * @text: chunk of text to parse
1113  * @text_len: length of @text in bytes
1114  * @error: return location for a #GError
1115  *
1116  * Feed some data to the #GMarkupParseContext.
1117  *
1118  * The data need not be valid UTF-8; an error will be signaled if
1119  * it&#39;s invalid. The data need not be an entire document; you can
1120  * feed a document into the parser incrementally, via multiple calls
1121  * to this function. Typically, as you receive data from a network
1122  * connection or file, you feed each received chunk of data into this
1123  * function, aborting the process if an error occurs. Once an error
1124  * is reported, no further data may be fed to the #GMarkupParseContext;
1125  * all errors are fatal.
1126  *
1127  * Returns: %FALSE if an error occurred, %TRUE on success
1128  */
1129 gboolean
1130 g_markup_parse_context_parse (GMarkupParseContext  *context,
1131                               const gchar          *text,
1132                               gssize                text_len,
1133                               GError              **error)
1134 {
1135   g_return_val_if_fail (context != NULL, FALSE);
1136   g_return_val_if_fail (text != NULL, FALSE);
1137   g_return_val_if_fail (context-&gt;state != STATE_ERROR, FALSE);
1138   g_return_val_if_fail (!context-&gt;parsing, FALSE);
1139 
1140   if (text_len &lt; 0)
1141     text_len = strlen (text);
1142 
1143   if (text_len == 0)
1144     return TRUE;
1145 
1146   context-&gt;parsing = TRUE;
1147 
1148 
1149   context-&gt;current_text = text;
1150   context-&gt;current_text_len = text_len;
1151   context-&gt;current_text_end = context-&gt;current_text + text_len;
1152   context-&gt;iter = context-&gt;current_text;
1153   context-&gt;start = context-&gt;iter;
1154 
1155   while (context-&gt;iter != context-&gt;current_text_end)
1156     {
1157       switch (context-&gt;state)
1158         {
1159         case STATE_START:
1160           /* Possible next state: AFTER_OPEN_ANGLE */
1161 
1162           g_assert (context-&gt;tag_stack == NULL);
1163 
1164           /* whitespace is ignored outside of any elements */
1165           skip_spaces (context);
1166 
1167           if (context-&gt;iter != context-&gt;current_text_end)
1168             {
1169               if (*context-&gt;iter == &#39;&lt;&#39;)
1170                 {
1171                   /* Move after the open angle */
1172                   advance_char (context);
1173 
1174                   context-&gt;state = STATE_AFTER_OPEN_ANGLE;
1175 
1176                   /* this could start a passthrough */
1177                   context-&gt;start = context-&gt;iter;
1178 
1179                   /* document is now non-empty */
1180                   context-&gt;document_empty = FALSE;
1181                 }
1182               else
1183                 {
1184                   set_error_literal (context,
1185                                      error,
1186                                      G_MARKUP_ERROR_PARSE,
1187                                      _(&quot;Document must begin with an element (e.g. &lt;book&gt;)&quot;));
1188                 }
1189             }
1190           break;
1191 
1192         case STATE_AFTER_OPEN_ANGLE:
1193           /* Possible next states: INSIDE_OPEN_TAG_NAME,
1194            *  AFTER_CLOSE_TAG_SLASH, INSIDE_PASSTHROUGH
1195            */
1196           if (*context-&gt;iter == &#39;?&#39; ||
1197               *context-&gt;iter == &#39;!&#39;)
1198             {
1199               /* include &lt; in the passthrough */
1200               const gchar *openangle = &quot;&lt;&quot;;
1201               add_to_partial (context, openangle, openangle + 1);
1202               context-&gt;start = context-&gt;iter;
1203               context-&gt;balance = 1;
1204               context-&gt;state = STATE_INSIDE_PASSTHROUGH;
1205             }
1206           else if (*context-&gt;iter == &#39;/&#39;)
1207             {
1208               /* move after it */
1209               advance_char (context);
1210 
1211               context-&gt;state = STATE_AFTER_CLOSE_TAG_SLASH;
1212             }
1213           else if (!IS_COMMON_NAME_END_CHAR (*(context-&gt;iter)))
1214             {
1215               context-&gt;state = STATE_INSIDE_OPEN_TAG_NAME;
1216 
1217               /* start of tag name */
1218               context-&gt;start = context-&gt;iter;
1219             }
1220           else
1221             {
1222               gchar buf[8];
1223 
1224               set_error (context,
1225                          error,
1226                          G_MARKUP_ERROR_PARSE,
1227                          _(&quot;&#39;%s&#39; is not a valid character following &quot;
1228                            &quot;a &#39;&lt;&#39; character; it may not begin an &quot;
1229                            &quot;element name&quot;),
1230                          utf8_str (context-&gt;iter,
1231                                    context-&gt;current_text_end - context-&gt;iter, buf));
1232             }
1233           break;
1234 
1235           /* The AFTER_CLOSE_ANGLE state is actually sort of
1236            * broken, because it doesn&#39;t correspond to a range
1237            * of characters in the input stream as the others do,
1238            * and thus makes things harder to conceptualize
1239            */
1240         case STATE_AFTER_CLOSE_ANGLE:
1241           /* Possible next states: INSIDE_TEXT, STATE_START */
1242           if (context-&gt;tag_stack == NULL)
1243             {
1244               context-&gt;start = NULL;
1245               context-&gt;state = STATE_START;
1246             }
1247           else
1248             {
1249               context-&gt;start = context-&gt;iter;
1250               context-&gt;state = STATE_INSIDE_TEXT;
1251             }
1252           break;
1253 
1254         case STATE_AFTER_ELISION_SLASH:
1255           /* Possible next state: AFTER_CLOSE_ANGLE */
1256           if (*context-&gt;iter == &#39;&gt;&#39;)
1257             {
1258               /* move after the close angle */
1259               advance_char (context);
1260               context-&gt;state = STATE_AFTER_CLOSE_ANGLE;
1261               emit_end_element (context, error);
1262             }
1263           else
1264             {
1265               gchar buf[8];
1266 
1267               set_error (context,
1268                          error,
1269                          G_MARKUP_ERROR_PARSE,
1270                          _(&quot;Odd character &#39;%s&#39;, expected a &#39;&gt;&#39; character &quot;
1271                            &quot;to end the empty-element tag &#39;%s&#39;&quot;),
1272                          utf8_str (context-&gt;iter,
1273                                    context-&gt;current_text_end - context-&gt;iter, buf),
1274                          current_element (context));
1275             }
1276           break;
1277 
1278         case STATE_INSIDE_OPEN_TAG_NAME:
1279           /* Possible next states: BETWEEN_ATTRIBUTES */
1280 
1281           /* if there&#39;s a partial chunk then it&#39;s the first part of the
1282            * tag name. If there&#39;s a context-&gt;start then it&#39;s the start
1283            * of the tag name in current_text, the partial chunk goes
1284            * before that start though.
1285            */
1286           advance_to_name_end (context);
1287 
1288           if (context-&gt;iter == context-&gt;current_text_end)
1289             {
1290               /* The name hasn&#39;t necessarily ended. Merge with
1291                * partial chunk, leave state unchanged.
1292                */
1293               add_to_partial (context, context-&gt;start, context-&gt;iter);
1294             }
1295           else
1296             {
1297               /* The name has ended. Combine it with the partial chunk
1298                * if any; push it on the stack; enter next state.
1299                */
1300               add_to_partial (context, context-&gt;start, context-&gt;iter);
1301               push_partial_as_tag (context);
1302 
1303               context-&gt;state = STATE_BETWEEN_ATTRIBUTES;
1304               context-&gt;start = NULL;
1305             }
1306           break;
1307 
1308         case STATE_INSIDE_ATTRIBUTE_NAME:
1309           /* Possible next states: AFTER_ATTRIBUTE_NAME */
1310 
1311           advance_to_name_end (context);
1312           add_to_partial (context, context-&gt;start, context-&gt;iter);
1313 
1314           /* read the full name, if we enter the equals sign state
1315            * then add the attribute to the list (without the value),
1316            * otherwise store a partial chunk to be prepended later.
1317            */
1318           if (context-&gt;iter != context-&gt;current_text_end)
1319             context-&gt;state = STATE_AFTER_ATTRIBUTE_NAME;
1320           break;
1321 
1322         case STATE_AFTER_ATTRIBUTE_NAME:
1323           /* Possible next states: AFTER_ATTRIBUTE_EQUALS_SIGN */
1324 
1325           skip_spaces (context);
1326 
1327           if (context-&gt;iter != context-&gt;current_text_end)
1328             {
1329               /* The name has ended. Combine it with the partial chunk
1330                * if any; push it on the stack; enter next state.
1331                */
1332               if (!name_validate (context, context-&gt;partial_chunk-&gt;str, error))
1333                 break;
1334 
1335               add_attribute (context, context-&gt;partial_chunk);
1336 
1337               context-&gt;partial_chunk = NULL;
1338               context-&gt;start = NULL;
1339 
1340               if (*context-&gt;iter == &#39;=&#39;)
1341                 {
1342                   advance_char (context);
1343                   context-&gt;state = STATE_AFTER_ATTRIBUTE_EQUALS_SIGN;
1344                 }
1345               else
1346                 {
1347                   gchar buf[8];
1348 
1349                   set_error (context,
1350                              error,
1351                              G_MARKUP_ERROR_PARSE,
1352                              _(&quot;Odd character &#39;%s&#39;, expected a &#39;=&#39; after &quot;
1353                                &quot;attribute name &#39;%s&#39; of element &#39;%s&#39;&quot;),
1354                              utf8_str (context-&gt;iter,
1355                                        context-&gt;current_text_end - context-&gt;iter, buf),
1356                              current_attribute (context),
1357                              current_element (context));
1358 
1359                 }
1360             }
1361           break;
1362 
1363         case STATE_BETWEEN_ATTRIBUTES:
1364           /* Possible next states: AFTER_CLOSE_ANGLE,
1365            * AFTER_ELISION_SLASH, INSIDE_ATTRIBUTE_NAME
1366            */
1367           skip_spaces (context);
1368 
1369           if (context-&gt;iter != context-&gt;current_text_end)
1370             {
1371               if (*context-&gt;iter == &#39;/&#39;)
1372                 {
1373                   advance_char (context);
1374                   context-&gt;state = STATE_AFTER_ELISION_SLASH;
1375                 }
1376               else if (*context-&gt;iter == &#39;&gt;&#39;)
1377                 {
1378                   advance_char (context);
1379                   context-&gt;state = STATE_AFTER_CLOSE_ANGLE;
1380                 }
1381               else if (!IS_COMMON_NAME_END_CHAR (*(context-&gt;iter)))
1382                 {
1383                   context-&gt;state = STATE_INSIDE_ATTRIBUTE_NAME;
1384                   /* start of attribute name */
1385                   context-&gt;start = context-&gt;iter;
1386                 }
1387               else
1388                 {
1389                   gchar buf[8];
1390 
1391                   set_error (context,
1392                              error,
1393                              G_MARKUP_ERROR_PARSE,
1394                              _(&quot;Odd character &#39;%s&#39;, expected a &#39;&gt;&#39; or &#39;/&#39; &quot;
1395                                &quot;character to end the start tag of &quot;
1396                                &quot;element &#39;%s&#39;, or optionally an attribute; &quot;
1397                                &quot;perhaps you used an invalid character in &quot;
1398                                &quot;an attribute name&quot;),
1399                              utf8_str (context-&gt;iter,
1400                                        context-&gt;current_text_end - context-&gt;iter, buf),
1401                              current_element (context));
1402                 }
1403 
1404               /* If we&#39;re done with attributes, invoke
1405                * the start_element callback
1406                */
1407               if (context-&gt;state == STATE_AFTER_ELISION_SLASH ||
1408                   context-&gt;state == STATE_AFTER_CLOSE_ANGLE)
1409                 emit_start_element (context, error);
1410             }
1411           break;
1412 
1413         case STATE_AFTER_ATTRIBUTE_EQUALS_SIGN:
1414           /* Possible next state: INSIDE_ATTRIBUTE_VALUE_[SQ/DQ] */
1415 
1416           skip_spaces (context);
1417 
1418           if (context-&gt;iter != context-&gt;current_text_end)
1419             {
1420               if (*context-&gt;iter == &#39;&quot;&#39;)
1421                 {
1422                   advance_char (context);
1423                   context-&gt;state = STATE_INSIDE_ATTRIBUTE_VALUE_DQ;
1424                   context-&gt;start = context-&gt;iter;
1425                 }
1426               else if (*context-&gt;iter == &#39;\&#39;&#39;)
1427                 {
1428                   advance_char (context);
1429                   context-&gt;state = STATE_INSIDE_ATTRIBUTE_VALUE_SQ;
1430                   context-&gt;start = context-&gt;iter;
1431                 }
1432               else
1433                 {
1434                   gchar buf[8];
1435 
1436                   set_error (context,
1437                              error,
1438                              G_MARKUP_ERROR_PARSE,
1439                              _(&quot;Odd character &#39;%s&#39;, expected an open quote mark &quot;
1440                                &quot;after the equals sign when giving value for &quot;
1441                                &quot;attribute &#39;%s&#39; of element &#39;%s&#39;&quot;),
1442                              utf8_str (context-&gt;iter,
1443                                        context-&gt;current_text_end - context-&gt;iter, buf),
1444                              current_attribute (context),
1445                              current_element (context));
1446                 }
1447             }
1448           break;
1449 
1450         case STATE_INSIDE_ATTRIBUTE_VALUE_SQ:
1451         case STATE_INSIDE_ATTRIBUTE_VALUE_DQ:
1452           /* Possible next states: BETWEEN_ATTRIBUTES */
1453           {
1454             gchar delim;
1455 
1456             if (context-&gt;state == STATE_INSIDE_ATTRIBUTE_VALUE_SQ)
1457               {
1458                 delim = &#39;\&#39;&#39;;
1459               }
1460             else
1461               {
1462                 delim = &#39;&quot;&#39;;
1463               }
1464 
1465             do
1466               {
1467                 if (*context-&gt;iter == delim)
1468                   break;
1469               }
1470             while (advance_char (context));
1471           }
1472           if (context-&gt;iter == context-&gt;current_text_end)
1473             {
1474               /* The value hasn&#39;t necessarily ended. Merge with
1475                * partial chunk, leave state unchanged.
1476                */
1477               add_to_partial (context, context-&gt;start, context-&gt;iter);
1478             }
1479           else
1480             {
1481               gboolean is_ascii;
1482               /* The value has ended at the quote mark. Combine it
1483                * with the partial chunk if any; set it for the current
1484                * attribute.
1485                */
1486               add_to_partial (context, context-&gt;start, context-&gt;iter);
1487 
1488               g_assert (context-&gt;cur_attr &gt;= 0);
1489 
1490               if (unescape_gstring_inplace (context, context-&gt;partial_chunk, &amp;is_ascii, error) &amp;&amp;
1491                   (is_ascii || text_validate (context, context-&gt;partial_chunk-&gt;str,
1492                                               context-&gt;partial_chunk-&gt;len, error)))
1493                 {
1494                   /* success, advance past quote and set state. */
1495                   context-&gt;attr_values[context-&gt;cur_attr] = context-&gt;partial_chunk;
1496                   context-&gt;partial_chunk = NULL;
1497                   advance_char (context);
1498                   context-&gt;state = STATE_BETWEEN_ATTRIBUTES;
1499                   context-&gt;start = NULL;
1500                 }
1501 
1502               truncate_partial (context);
1503             }
1504           break;
1505 
1506         case STATE_INSIDE_TEXT:
1507           /* Possible next states: AFTER_OPEN_ANGLE */
1508           do
1509             {
1510               if (*context-&gt;iter == &#39;&lt;&#39;)
1511                 break;
1512             }
1513           while (advance_char (context));
1514 
1515           /* The text hasn&#39;t necessarily ended. Merge with
1516            * partial chunk, leave state unchanged.
1517            */
1518 
1519           add_to_partial (context, context-&gt;start, context-&gt;iter);
1520 
1521           if (context-&gt;iter != context-&gt;current_text_end)
1522             {
1523               gboolean is_ascii;
1524 
1525               /* The text has ended at the open angle. Call the text
1526                * callback.
1527                */
1528               if (unescape_gstring_inplace (context, context-&gt;partial_chunk, &amp;is_ascii, error) &amp;&amp;
1529                   (is_ascii || text_validate (context, context-&gt;partial_chunk-&gt;str,
1530                                               context-&gt;partial_chunk-&gt;len, error)))
1531                 {
1532                   GError *tmp_error = NULL;
1533 
1534                   if (context-&gt;parser-&gt;text)
1535                     (*context-&gt;parser-&gt;text) (context,
1536                                               context-&gt;partial_chunk-&gt;str,
1537                                               context-&gt;partial_chunk-&gt;len,
1538                                               context-&gt;user_data,
1539                                               &amp;tmp_error);
1540 
1541                   if (tmp_error == NULL)
1542                     {
1543                       /* advance past open angle and set state. */
1544                       advance_char (context);
1545                       context-&gt;state = STATE_AFTER_OPEN_ANGLE;
1546                       /* could begin a passthrough */
1547                       context-&gt;start = context-&gt;iter;
1548                     }
1549                   else
1550                     propagate_error (context, error, tmp_error);
1551                 }
1552 
1553               truncate_partial (context);
1554             }
1555           break;
1556 
1557         case STATE_AFTER_CLOSE_TAG_SLASH:
1558           /* Possible next state: INSIDE_CLOSE_TAG_NAME */
1559           if (!IS_COMMON_NAME_END_CHAR (*(context-&gt;iter)))
1560             {
1561               context-&gt;state = STATE_INSIDE_CLOSE_TAG_NAME;
1562 
1563               /* start of tag name */
1564               context-&gt;start = context-&gt;iter;
1565             }
1566           else
1567             {
1568               gchar buf[8];
1569 
1570               set_error (context,
1571                          error,
1572                          G_MARKUP_ERROR_PARSE,
1573                          _(&quot;&#39;%s&#39; is not a valid character following &quot;
1574                            &quot;the characters &#39;&lt;/&#39;; &#39;%s&#39; may not begin an &quot;
1575                            &quot;element name&quot;),
1576                          utf8_str (context-&gt;iter,
1577                                    context-&gt;current_text_end - context-&gt;iter, buf),
1578                          utf8_str (context-&gt;iter,
1579                                    context-&gt;current_text_end - context-&gt;iter, buf));
1580             }
1581           break;
1582 
1583         case STATE_INSIDE_CLOSE_TAG_NAME:
1584           /* Possible next state: AFTER_CLOSE_TAG_NAME */
1585           advance_to_name_end (context);
1586           add_to_partial (context, context-&gt;start, context-&gt;iter);
1587 
1588           if (context-&gt;iter != context-&gt;current_text_end)
1589             context-&gt;state = STATE_AFTER_CLOSE_TAG_NAME;
1590           break;
1591 
1592         case STATE_AFTER_CLOSE_TAG_NAME:
1593           /* Possible next state: AFTER_CLOSE_TAG_SLASH */
1594 
1595           skip_spaces (context);
1596 
1597           if (context-&gt;iter != context-&gt;current_text_end)
1598             {
1599               GString *close_name;
1600 
1601               close_name = context-&gt;partial_chunk;
1602               context-&gt;partial_chunk = NULL;
1603 
1604               if (*context-&gt;iter != &#39;&gt;&#39;)
1605                 {
1606                   gchar buf[8];
1607 
1608                   set_error (context,
1609                              error,
1610                              G_MARKUP_ERROR_PARSE,
1611                              _(&quot;&#39;%s&#39; is not a valid character following &quot;
1612                                &quot;the close element name &#39;%s&#39;; the allowed &quot;
1613                                &quot;character is &#39;&gt;&#39;&quot;),
1614                              utf8_str (context-&gt;iter,
1615                                        context-&gt;current_text_end - context-&gt;iter, buf),
1616                              close_name-&gt;str);
1617                 }
1618               else if (context-&gt;tag_stack == NULL)
1619                 {
1620                   set_error (context,
1621                              error,
1622                              G_MARKUP_ERROR_PARSE,
1623                              _(&quot;Element &#39;%s&#39; was closed, no element &quot;
1624                                &quot;is currently open&quot;),
1625                              close_name-&gt;str);
1626                 }
1627               else if (strcmp (close_name-&gt;str, current_element (context)) != 0)
1628                 {
1629                   set_error (context,
1630                              error,
1631                              G_MARKUP_ERROR_PARSE,
1632                              _(&quot;Element &#39;%s&#39; was closed, but the currently &quot;
1633                                &quot;open element is &#39;%s&#39;&quot;),
1634                              close_name-&gt;str,
1635                              current_element (context));
1636                 }
1637               else
1638                 {
1639                   advance_char (context);
1640                   context-&gt;state = STATE_AFTER_CLOSE_ANGLE;
1641                   context-&gt;start = NULL;
1642 
1643                   emit_end_element (context, error);
1644                 }
1645               context-&gt;partial_chunk = close_name;
1646               truncate_partial (context);
1647             }
1648           break;
1649 
1650         case STATE_INSIDE_PASSTHROUGH:
1651           /* Possible next state: AFTER_CLOSE_ANGLE */
1652           do
1653             {
1654               if (*context-&gt;iter == &#39;&lt;&#39;)
1655                 context-&gt;balance++;
1656               if (*context-&gt;iter == &#39;&gt;&#39;)
1657                 {
1658                   gchar *str;
1659                   gsize len;
1660 
1661                   context-&gt;balance--;
1662                   add_to_partial (context, context-&gt;start, context-&gt;iter);
1663                   context-&gt;start = context-&gt;iter;
1664 
1665                   str = context-&gt;partial_chunk-&gt;str;
1666                   len = context-&gt;partial_chunk-&gt;len;
1667 
1668                   if (str[1] == &#39;?&#39; &amp;&amp; str[len - 1] == &#39;?&#39;)
1669                     break;
1670                   if (strncmp (str, &quot;&lt;!--&quot;, 4) == 0 &amp;&amp;
1671                       strcmp (str + len - 2, &quot;--&quot;) == 0)
1672                     break;
1673                   if (strncmp (str, &quot;&lt;![CDATA[&quot;, 9) == 0 &amp;&amp;
1674                       strcmp (str + len - 2, &quot;]]&quot;) == 0)
1675                     break;
1676                   if (strncmp (str, &quot;&lt;!DOCTYPE&quot;, 9) == 0 &amp;&amp;
1677                       context-&gt;balance == 0)
1678                     break;
1679                 }
1680             }
1681           while (advance_char (context));
1682 
1683           if (context-&gt;iter == context-&gt;current_text_end)
1684             {
1685               /* The passthrough hasn&#39;t necessarily ended. Merge with
1686                * partial chunk, leave state unchanged.
1687                */
1688                add_to_partial (context, context-&gt;start, context-&gt;iter);
1689             }
1690           else
1691             {
1692               /* The passthrough has ended at the close angle. Combine
1693                * it with the partial chunk if any. Call the passthrough
1694                * callback. Note that the open/close angles are
1695                * included in the text of the passthrough.
1696                */
1697               GError *tmp_error = NULL;
1698 
1699               advance_char (context); /* advance past close angle */
1700               add_to_partial (context, context-&gt;start, context-&gt;iter);
1701 
1702               if (context-&gt;flags &amp; G_MARKUP_TREAT_CDATA_AS_TEXT &amp;&amp;
1703                   strncmp (context-&gt;partial_chunk-&gt;str, &quot;&lt;![CDATA[&quot;, 9) == 0)
1704                 {
1705                   if (context-&gt;parser-&gt;text &amp;&amp;
1706                       text_validate (context,
1707                                      context-&gt;partial_chunk-&gt;str + 9,
1708                                      context-&gt;partial_chunk-&gt;len - 12,
1709                                      error))
1710                     (*context-&gt;parser-&gt;text) (context,
1711                                               context-&gt;partial_chunk-&gt;str + 9,
1712                                               context-&gt;partial_chunk-&gt;len - 12,
1713                                               context-&gt;user_data,
1714                                               &amp;tmp_error);
1715                 }
1716               else if (context-&gt;parser-&gt;passthrough &amp;&amp;
1717                        text_validate (context,
1718                                       context-&gt;partial_chunk-&gt;str,
1719                                       context-&gt;partial_chunk-&gt;len,
1720                                       error))
1721                 (*context-&gt;parser-&gt;passthrough) (context,
1722                                                  context-&gt;partial_chunk-&gt;str,
1723                                                  context-&gt;partial_chunk-&gt;len,
1724                                                  context-&gt;user_data,
1725                                                  &amp;tmp_error);
1726 
1727               truncate_partial (context);
1728 
1729               if (tmp_error == NULL)
1730                 {
1731                   context-&gt;state = STATE_AFTER_CLOSE_ANGLE;
1732                   context-&gt;start = context-&gt;iter; /* could begin text */
1733                 }
1734               else
1735                 propagate_error (context, error, tmp_error);
1736             }
1737           break;
1738 
1739         case STATE_ERROR:
1740           goto finished;
1741           break;
1742 
1743         default:
1744           g_assert_not_reached ();
1745           break;
1746         }
1747     }
1748 
1749  finished:
1750   context-&gt;parsing = FALSE;
1751 
1752   return context-&gt;state != STATE_ERROR;
1753 }
1754 
1755 /**
1756  * g_markup_parse_context_end_parse:
1757  * @context: a #GMarkupParseContext
1758  * @error: return location for a #GError
1759  *
1760  * Signals to the #GMarkupParseContext that all data has been
1761  * fed into the parse context with g_markup_parse_context_parse().
1762  *
1763  * This function reports an error if the document isn&#39;t complete,
1764  * for example if elements are still open.
1765  *
1766  * Returns: %TRUE on success, %FALSE if an error was set
1767  */
1768 gboolean
1769 g_markup_parse_context_end_parse (GMarkupParseContext  *context,
1770                                   GError              **error)
1771 {
1772   g_return_val_if_fail (context != NULL, FALSE);
1773   g_return_val_if_fail (!context-&gt;parsing, FALSE);
1774   g_return_val_if_fail (context-&gt;state != STATE_ERROR, FALSE);
1775 
1776   if (context-&gt;partial_chunk != NULL)
1777     {
1778       g_string_free (context-&gt;partial_chunk, TRUE);
1779       context-&gt;partial_chunk = NULL;
1780     }
1781 
1782   if (context-&gt;document_empty)
1783     {
1784       set_error_literal (context, error, G_MARKUP_ERROR_EMPTY,
1785                          _(&quot;Document was empty or contained only whitespace&quot;));
1786       return FALSE;
1787     }
1788 
1789   context-&gt;parsing = TRUE;
1790 
1791   switch (context-&gt;state)
1792     {
1793     case STATE_START:
1794       /* Nothing to do */
1795       break;
1796 
1797     case STATE_AFTER_OPEN_ANGLE:
1798       set_error_literal (context, error, G_MARKUP_ERROR_PARSE,
1799                          _(&quot;Document ended unexpectedly just after an open angle bracket &#39;&lt;&#39;&quot;));
1800       break;
1801 
1802     case STATE_AFTER_CLOSE_ANGLE:
1803       if (context-&gt;tag_stack != NULL)
1804         {
1805           /* Error message the same as for INSIDE_TEXT */
1806           set_error (context, error, G_MARKUP_ERROR_PARSE,
1807                      _(&quot;Document ended unexpectedly with elements still open - &quot;
1808                        &quot;&#39;%s&#39; was the last element opened&quot;),
1809                      current_element (context));
1810         }
1811       break;
1812 
1813     case STATE_AFTER_ELISION_SLASH:
1814       set_error (context, error, G_MARKUP_ERROR_PARSE,
1815                  _(&quot;Document ended unexpectedly, expected to see a close angle &quot;
1816                    &quot;bracket ending the tag &lt;%s/&gt;&quot;), current_element (context));
1817       break;
1818 
1819     case STATE_INSIDE_OPEN_TAG_NAME:
1820       set_error_literal (context, error, G_MARKUP_ERROR_PARSE,
1821                          _(&quot;Document ended unexpectedly inside an element name&quot;));
1822       break;
1823 
1824     case STATE_INSIDE_ATTRIBUTE_NAME:
1825     case STATE_AFTER_ATTRIBUTE_NAME:
1826       set_error_literal (context, error, G_MARKUP_ERROR_PARSE,
1827                          _(&quot;Document ended unexpectedly inside an attribute name&quot;));
1828       break;
1829 
1830     case STATE_BETWEEN_ATTRIBUTES:
1831       set_error_literal (context, error, G_MARKUP_ERROR_PARSE,
1832                          _(&quot;Document ended unexpectedly inside an element-opening &quot;
1833                            &quot;tag.&quot;));
1834       break;
1835 
1836     case STATE_AFTER_ATTRIBUTE_EQUALS_SIGN:
1837       set_error_literal (context, error, G_MARKUP_ERROR_PARSE,
1838                          _(&quot;Document ended unexpectedly after the equals sign &quot;
1839                            &quot;following an attribute name; no attribute value&quot;));
1840       break;
1841 
1842     case STATE_INSIDE_ATTRIBUTE_VALUE_SQ:
1843     case STATE_INSIDE_ATTRIBUTE_VALUE_DQ:
1844       set_error_literal (context, error, G_MARKUP_ERROR_PARSE,
1845                          _(&quot;Document ended unexpectedly while inside an attribute &quot;
1846                            &quot;value&quot;));
1847       break;
1848 
1849     case STATE_INSIDE_TEXT:
1850       g_assert (context-&gt;tag_stack != NULL);
1851       set_error (context, error, G_MARKUP_ERROR_PARSE,
1852                  _(&quot;Document ended unexpectedly with elements still open - &quot;
1853                    &quot;&#39;%s&#39; was the last element opened&quot;),
1854                  current_element (context));
1855       break;
1856 
1857     case STATE_AFTER_CLOSE_TAG_SLASH:
1858     case STATE_INSIDE_CLOSE_TAG_NAME:
1859     case STATE_AFTER_CLOSE_TAG_NAME:
1860       if (context-&gt;tag_stack != NULL)
1861         set_error (context, error, G_MARKUP_ERROR_PARSE,
1862                    _(&quot;Document ended unexpectedly inside the close tag for &quot;
1863                      &quot;element &#39;%s&#39;&quot;), current_element (context));
1864       else
1865         set_error (context, error, G_MARKUP_ERROR_PARSE,
1866                    _(&quot;Document ended unexpectedly inside the close tag for an &quot;
1867                      &quot;unopened element&quot;));
1868       break;
1869 
1870     case STATE_INSIDE_PASSTHROUGH:
1871       set_error_literal (context, error, G_MARKUP_ERROR_PARSE,
1872                          _(&quot;Document ended unexpectedly inside a comment or &quot;
1873                            &quot;processing instruction&quot;));
1874       break;
1875 
1876     case STATE_ERROR:
1877     default:
1878       g_assert_not_reached ();
1879       break;
1880     }
1881 
1882   context-&gt;parsing = FALSE;
1883 
1884   return context-&gt;state != STATE_ERROR;
1885 }
1886 
1887 /**
1888  * g_markup_parse_context_get_element:
1889  * @context: a #GMarkupParseContext
1890  *
1891  * Retrieves the name of the currently open element.
1892  *
1893  * If called from the start_element or end_element handlers this will
1894  * give the element_name as passed to those functions. For the parent
1895  * elements, see g_markup_parse_context_get_element_stack().
1896  *
1897  * Returns: the name of the currently open element, or %NULL
1898  *
1899  * Since: 2.2
1900  */
1901 const gchar *
1902 g_markup_parse_context_get_element (GMarkupParseContext *context)
1903 {
1904   g_return_val_if_fail (context != NULL, NULL);
1905 
1906   if (context-&gt;tag_stack == NULL)
1907     return NULL;
1908   else
1909     return current_element (context);
1910 }
1911 
1912 /**
1913  * g_markup_parse_context_get_element_stack:
1914  * @context: a #GMarkupParseContext
1915  *
1916  * Retrieves the element stack from the internal state of the parser.
1917  *
1918  * The returned #GSList is a list of strings where the first item is
1919  * the currently open tag (as would be returned by
1920  * g_markup_parse_context_get_element()) and the next item is its
1921  * immediate parent.
1922  *
1923  * This function is intended to be used in the start_element and
1924  * end_element handlers where g_markup_parse_context_get_element()
1925  * would merely return the name of the element that is being
1926  * processed.
1927  *
1928  * Returns: the element stack, which must not be modified
1929  *
1930  * Since: 2.16
1931  */
1932 const GSList *
1933 g_markup_parse_context_get_element_stack (GMarkupParseContext *context)
1934 {
1935   g_return_val_if_fail (context != NULL, NULL);
1936   return context-&gt;tag_stack;
1937 }
1938 
1939 /**
1940  * g_markup_parse_context_get_position:
1941  * @context: a #GMarkupParseContext
1942  * @line_number: (nullable): return location for a line number, or %NULL
1943  * @char_number: (nullable): return location for a char-on-line number, or %NULL
1944  *
1945  * Retrieves the current line number and the number of the character on
1946  * that line. Intended for use in error messages; there are no strict
1947  * semantics for what constitutes the &quot;current&quot; line number other than
1948  * &quot;the best number we could come up with for error messages.&quot;
1949  */
1950 void
1951 g_markup_parse_context_get_position (GMarkupParseContext *context,
1952                                      gint                *line_number,
1953                                      gint                *char_number)
1954 {
1955   g_return_if_fail (context != NULL);
1956 
1957   if (line_number)
1958     *line_number = context-&gt;line_number;
1959 
1960   if (char_number)
1961     *char_number = context-&gt;char_number;
1962 }
1963 
1964 /**
1965  * g_markup_parse_context_get_user_data:
1966  * @context: a #GMarkupParseContext
1967  *
1968  * Returns the user_data associated with @context.
1969  *
1970  * This will either be the user_data that was provided to
1971  * g_markup_parse_context_new() or to the most recent call
1972  * of g_markup_parse_context_push().
1973  *
1974  * Returns: the provided user_data. The returned data belongs to
1975  *     the markup context and will be freed when
1976  *     g_markup_parse_context_free() is called.
1977  *
1978  * Since: 2.18
1979  */
1980 gpointer
1981 g_markup_parse_context_get_user_data (GMarkupParseContext *context)
1982 {
1983   return context-&gt;user_data;
1984 }
1985 
1986 /**
1987  * g_markup_parse_context_push:
1988  * @context: a #GMarkupParseContext
1989  * @parser: a #GMarkupParser
1990  * @user_data: user data to pass to #GMarkupParser functions
1991  *
1992  * Temporarily redirects markup data to a sub-parser.
1993  *
1994  * This function may only be called from the start_element handler of
1995  * a #GMarkupParser. It must be matched with a corresponding call to
1996  * g_markup_parse_context_pop() in the matching end_element handler
1997  * (except in the case that the parser aborts due to an error).
1998  *
1999  * All tags, text and other data between the matching tags is
2000  * redirected to the subparser given by @parser. @user_data is used
2001  * as the user_data for that parser. @user_data is also passed to the
2002  * error callback in the event that an error occurs. This includes
2003  * errors that occur in subparsers of the subparser.
2004  *
2005  * The end tag matching the start tag for which this call was made is
2006  * handled by the previous parser (which is given its own user_data)
2007  * which is why g_markup_parse_context_pop() is provided to allow &quot;one
2008  * last access&quot; to the @user_data provided to this function. In the
2009  * case of error, the @user_data provided here is passed directly to
2010  * the error callback of the subparser and g_markup_parse_context_pop()
2011  * should not be called. In either case, if @user_data was allocated
2012  * then it ought to be freed from both of these locations.
2013  *
2014  * This function is not intended to be directly called by users
2015  * interested in invoking subparsers. Instead, it is intended to be
2016  * used by the subparsers themselves to implement a higher-level
2017  * interface.
2018  *
2019  * As an example, see the following implementation of a simple
2020  * parser that counts the number of tags encountered.
2021  *
2022  * |[&lt;!-- language=&quot;C&quot; --&gt;
2023  * typedef struct
2024  * {
2025  *   gint tag_count;
2026  * } CounterData;
2027  *
2028  * static void
2029  * counter_start_element (GMarkupParseContext  *context,
2030  *                        const gchar          *element_name,
2031  *                        const gchar         **attribute_names,
2032  *                        const gchar         **attribute_values,
2033  *                        gpointer              user_data,
2034  *                        GError              **error)
2035  * {
2036  *   CounterData *data = user_data;
2037  *
2038  *   data-&gt;tag_count++;
2039  * }
2040  *
2041  * static void
2042  * counter_error (GMarkupParseContext *context,
2043  *                GError              *error,
2044  *                gpointer             user_data)
2045  * {
2046  *   CounterData *data = user_data;
2047  *
2048  *   g_slice_free (CounterData, data);
2049  * }
2050  *
2051  * static GMarkupParser counter_subparser =
2052  * {
2053  *   counter_start_element,
2054  *   NULL,
2055  *   NULL,
2056  *   NULL,
2057  *   counter_error
2058  * };
2059  * ]|
2060  *
2061  * In order to allow this parser to be easily used as a subparser, the
2062  * following interface is provided:
2063  *
2064  * |[&lt;!-- language=&quot;C&quot; --&gt;
2065  * void
2066  * start_counting (GMarkupParseContext *context)
2067  * {
2068  *   CounterData *data = g_slice_new (CounterData);
2069  *
2070  *   data-&gt;tag_count = 0;
2071  *   g_markup_parse_context_push (context, &amp;counter_subparser, data);
2072  * }
2073  *
2074  * gint
2075  * end_counting (GMarkupParseContext *context)
2076  * {
2077  *   CounterData *data = g_markup_parse_context_pop (context);
2078  *   int result;
2079  *
2080  *   result = data-&gt;tag_count;
2081  *   g_slice_free (CounterData, data);
2082  *
2083  *   return result;
2084  * }
2085  * ]|
2086  *
2087  * The subparser would then be used as follows:
2088  *
2089  * |[&lt;!-- language=&quot;C&quot; --&gt;
2090  * static void start_element (context, element_name, ...)
2091  * {
2092  *   if (strcmp (element_name, &quot;count-these&quot;) == 0)
2093  *     start_counting (context);
2094  *
2095  *   // else, handle other tags...
2096  * }
2097  *
2098  * static void end_element (context, element_name, ...)
2099  * {
2100  *   if (strcmp (element_name, &quot;count-these&quot;) == 0)
2101  *     g_print (&quot;Counted %d tags\n&quot;, end_counting (context));
2102  *
2103  *   // else, handle other tags...
2104  * }
2105  * ]|
2106  *
2107  * Since: 2.18
2108  **/
2109 void
2110 g_markup_parse_context_push (GMarkupParseContext *context,
2111                              const GMarkupParser *parser,
2112                              gpointer             user_data)
2113 {
2114   GMarkupRecursionTracker *tracker;
2115 
2116   tracker = g_slice_new (GMarkupRecursionTracker);
2117 #ifdef GSTREAMER_LITE
2118   if (tracker == NULL) {
2119     return;
2120   }
2121 #endif // GSTREAMER_LITE
2122   tracker-&gt;prev_element = context-&gt;subparser_element;
2123   tracker-&gt;prev_parser = context-&gt;parser;
2124   tracker-&gt;prev_user_data = context-&gt;user_data;
2125 
2126   context-&gt;subparser_element = current_element (context);
2127   context-&gt;parser = parser;
2128   context-&gt;user_data = user_data;
2129 
2130   context-&gt;subparser_stack = g_slist_prepend (context-&gt;subparser_stack,
2131                                               tracker);
2132 }
2133 
2134 /**
2135  * g_markup_parse_context_pop:
2136  * @context: a #GMarkupParseContext
2137  *
2138  * Completes the process of a temporary sub-parser redirection.
2139  *
2140  * This function exists to collect the user_data allocated by a
2141  * matching call to g_markup_parse_context_push(). It must be called
2142  * in the end_element handler corresponding to the start_element
2143  * handler during which g_markup_parse_context_push() was called.
2144  * You must not call this function from the error callback -- the
2145  * @user_data is provided directly to the callback in that case.
2146  *
2147  * This function is not intended to be directly called by users
2148  * interested in invoking subparsers. Instead, it is intended to
2149  * be used by the subparsers themselves to implement a higher-level
2150  * interface.
2151  *
2152  * Returns: the user data passed to g_markup_parse_context_push()
2153  *
2154  * Since: 2.18
2155  */
2156 gpointer
2157 g_markup_parse_context_pop (GMarkupParseContext *context)
2158 {
2159   gpointer user_data;
2160 
2161   if (!context-&gt;awaiting_pop)
2162     possibly_finish_subparser (context);
2163 
2164   g_assert (context-&gt;awaiting_pop);
2165 
2166   context-&gt;awaiting_pop = FALSE;
2167 
2168   /* valgrind friendliness */
2169   user_data = context-&gt;held_user_data;
2170   context-&gt;held_user_data = NULL;
2171 
2172   return user_data;
2173 }
2174 
2175 #define APPEND_TEXT_AND_SEEK(_str, _start, _end)          \
2176   G_STMT_START {                                          \
2177     if (_end &gt; _start)                                    \
2178       g_string_append_len (_str, _start, _end - _start);  \
2179     _start = ++_end;                                      \
2180   } G_STMT_END
2181 
2182 /*
2183  * https://www.w3.org/TR/REC-xml/ defines the set of valid
2184  * characters as:
2185  *   #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
2186  *
2187  * That is, from non-ASCII UTF-8 character set, only 0xC27F - 0xC284 and
2188  * 0xC286 - 0xC29F have to be escaped (excluding the surrogate blocks).
2189  * Corresponding Unicode code points are [0x7F-0x84] and [0x86-0x9F].
2190  *
2191  * So instead of using costly g_utf8_next_char or similar UTF8 functions, it&#39;s
2192  * better to read each byte, and make an exception for 0xC2XX.
2193  */
2194 static void
2195 append_escaped_text (GString     *str,
2196                      const gchar *text,
2197                      gssize       length)
2198 {
2199   const gchar *p, *pending;
2200   const gchar *end;
2201 
2202   p = pending = text;
2203   end = text + length;
2204 
2205   while (p &lt; end &amp;&amp; pending &lt; end)
2206     {
2207       guchar c = (guchar) *pending;
2208 
2209       switch (c)
2210         {
2211         case &#39;&amp;&#39;:
2212           APPEND_TEXT_AND_SEEK (str, p, pending);
2213           g_string_append (str, &quot;&amp;amp;&quot;);
2214           break;
2215 
2216         case &#39;&lt;&#39;:
2217           APPEND_TEXT_AND_SEEK (str, p, pending);
2218           g_string_append (str, &quot;&amp;lt;&quot;);
2219           break;
2220 
2221         case &#39;&gt;&#39;:
2222           APPEND_TEXT_AND_SEEK (str, p, pending);
2223           g_string_append (str, &quot;&amp;gt;&quot;);
2224           break;
2225 
2226         case &#39;\&#39;&#39;:
2227           APPEND_TEXT_AND_SEEK (str, p, pending);
2228           g_string_append (str, &quot;&amp;apos;&quot;);
2229           break;
2230 
2231         case &#39;&quot;&#39;:
2232           APPEND_TEXT_AND_SEEK (str, p, pending);
2233           g_string_append (str, &quot;&amp;quot;&quot;);
2234           break;
2235 
2236         default:
2237           if ((0x1 &lt;= c &amp;&amp; c &lt;= 0x8) ||
2238               (0xb &lt;= c &amp;&amp; c  &lt;= 0xc) ||
2239               (0xe &lt;= c &amp;&amp; c &lt;= 0x1f) ||
2240               (c == 0x7f))
2241             {
2242               APPEND_TEXT_AND_SEEK (str, p, pending);
2243               g_string_append_printf (str, &quot;&amp;#x%x;&quot;, c);
2244             }
2245           /* The utf-8 control characters to escape begins with 0xc2 byte */
2246           else if (c == 0xc2)
2247             {
2248               gunichar u = g_utf8_get_char (pending);
2249 
2250               if ((0x7f &lt; u &amp;&amp; u &lt;= 0x84) ||
2251                   (0x86 &lt;= u &amp;&amp; u &lt;= 0x9f))
2252                 {
2253                   APPEND_TEXT_AND_SEEK (str, p, pending);
2254                   g_string_append_printf (str, &quot;&amp;#x%x;&quot;, u);
2255 
2256                   /*
2257                    * We have appended a two byte character above, which
2258                    * is one byte ahead of what we read on every loop.
2259                    * Increment to skip 0xc2 and point to the right location.
2260                    */
2261                   p++;
2262                 }
2263               else
2264                 pending++;
2265             }
2266           else
2267             pending++;
2268           break;
2269         }
2270     }
2271 
2272   if (pending &gt; p)
2273     g_string_append_len (str, p, pending - p);
2274 }
2275 
2276 #undef APPEND_TEXT_AND_SEEK
2277 
2278 /**
2279  * g_markup_escape_text:
2280  * @text: some valid UTF-8 text
2281  * @length: length of @text in bytes, or -1 if the text is nul-terminated
2282  *
2283  * Escapes text so that the markup parser will parse it verbatim.
2284  * Less than, greater than, ampersand, etc. are replaced with the
2285  * corresponding entities. This function would typically be used
2286  * when writing out a file to be parsed with the markup parser.
2287  *
2288  * Note that this function doesn&#39;t protect whitespace and line endings
2289  * from being processed according to the XML rules for normalization
2290  * of line endings and attribute values.
2291  *
2292  * Note also that this function will produce character references in
2293  * the range of &amp;#x1; ... &amp;#x1f; for all control sequences
2294  * except for tabstop, newline and carriage return.  The character
2295  * references in this range are not valid XML 1.0, but they are
2296  * valid XML 1.1 and will be accepted by the GMarkup parser.
2297  *
2298  * Returns: a newly allocated string with the escaped text
2299  */
2300 gchar*
2301 g_markup_escape_text (const gchar *text,
2302                       gssize       length)
2303 {
2304   GString *str;
2305 
2306   g_return_val_if_fail (text != NULL, NULL);
2307 
2308   if (length &lt; 0)
2309     length = strlen (text);
2310 
2311   /* prealloc at least as long as original text */
2312   str = g_string_sized_new (length);
2313   append_escaped_text (str, text, length);
2314 
2315   return g_string_free (str, FALSE);
2316 }
2317 
2318 /*
2319  * find_conversion:
2320  * @format: a printf-style format string
2321  * @after: location to store a pointer to the character after
2322  *     the returned conversion. On a %NULL return, returns the
2323  *     pointer to the trailing NUL in the string
2324  *
2325  * Find the next conversion in a printf-style format string.
2326  * Partially based on code from printf-parser.c,
2327  * Copyright (C) 1999-2000, 2002-2003 Free Software Foundation, Inc.
2328  *
2329  * Returns: pointer to the next conversion in @format,
2330  *  or %NULL, if none.
2331  */
2332 static const char *
2333 find_conversion (const char  *format,
2334                  const char **after)
2335 {
2336   const char *start = format;
2337   const char *cp;
2338 
2339   while (*start != &#39;\0&#39; &amp;&amp; *start != &#39;%&#39;)
2340     start++;
2341 
2342   if (*start == &#39;\0&#39;)
2343     {
2344       *after = start;
2345       return NULL;
2346     }
2347 
2348   cp = start + 1;
2349 
2350   if (*cp == &#39;\0&#39;)
2351     {
2352       *after = cp;
2353       return NULL;
2354     }
2355 
2356   /* Test for positional argument.  */
2357   if (*cp &gt;= &#39;0&#39; &amp;&amp; *cp &lt;= &#39;9&#39;)
2358     {
2359       const char *np;
2360 
2361       for (np = cp; *np &gt;= &#39;0&#39; &amp;&amp; *np &lt;= &#39;9&#39;; np++)
2362         ;
2363       if (*np == &#39;$&#39;)
2364         cp = np + 1;
2365     }
2366 
2367   /* Skip the flags.  */
2368   for (;;)
2369     {
2370       if (*cp == &#39;\&#39;&#39; ||
2371           *cp == &#39;-&#39; ||
2372           *cp == &#39;+&#39; ||
2373           *cp == &#39; &#39; ||
2374           *cp == &#39;#&#39; ||
2375           *cp == &#39;0&#39;)
2376         cp++;
2377       else
2378         break;
2379     }
2380 
2381   /* Skip the field width.  */
2382   if (*cp == &#39;*&#39;)
2383     {
2384       cp++;
2385 
2386       /* Test for positional argument.  */
2387       if (*cp &gt;= &#39;0&#39; &amp;&amp; *cp &lt;= &#39;9&#39;)
2388         {
2389           const char *np;
2390 
2391           for (np = cp; *np &gt;= &#39;0&#39; &amp;&amp; *np &lt;= &#39;9&#39;; np++)
2392             ;
2393           if (*np == &#39;$&#39;)
2394             cp = np + 1;
2395         }
2396     }
2397   else
2398     {
2399       for (; *cp &gt;= &#39;0&#39; &amp;&amp; *cp &lt;= &#39;9&#39;; cp++)
2400         ;
2401     }
2402 
2403   /* Skip the precision.  */
2404   if (*cp == &#39;.&#39;)
2405     {
2406       cp++;
2407       if (*cp == &#39;*&#39;)
2408         {
2409           /* Test for positional argument.  */
2410           if (*cp &gt;= &#39;0&#39; &amp;&amp; *cp &lt;= &#39;9&#39;)
2411             {
2412               const char *np;
2413 
2414               for (np = cp; *np &gt;= &#39;0&#39; &amp;&amp; *np &lt;= &#39;9&#39;; np++)
2415                 ;
2416               if (*np == &#39;$&#39;)
2417                 cp = np + 1;
2418             }
2419         }
2420       else
2421         {
2422           for (; *cp &gt;= &#39;0&#39; &amp;&amp; *cp &lt;= &#39;9&#39;; cp++)
2423             ;
2424         }
2425     }
2426 
2427   /* Skip argument type/size specifiers.  */
2428   while (*cp == &#39;h&#39; ||
2429          *cp == &#39;L&#39; ||
2430          *cp == &#39;l&#39; ||
2431          *cp == &#39;j&#39; ||
2432          *cp == &#39;z&#39; ||
2433          *cp == &#39;Z&#39; ||
2434          *cp == &#39;t&#39;)
2435     cp++;
2436 
2437   /* Skip the conversion character.  */
2438   cp++;
2439 
2440   *after = cp;
2441   return start;
2442 }
2443 
2444 /**
2445  * g_markup_vprintf_escaped:
2446  * @format: printf() style format string
2447  * @args: variable argument list, similar to vprintf()
2448  *
2449  * Formats the data in @args according to @format, escaping
2450  * all string and character arguments in the fashion
2451  * of g_markup_escape_text(). See g_markup_printf_escaped().
2452  *
2453  * Returns: newly allocated result from formatting
2454  *  operation. Free with g_free().
2455  *
2456  * Since: 2.4
2457  */
2458 
2459 #ifdef GSTREAMER_LITE
2460 #ifndef G_OS_WIN32
2461 #pragma GCC diagnostic push
2462 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
2463 #endif // G_OS_WIN32
2464 #else // GSTREAMER_LITE
2465 #pragma GCC diagnostic push
2466 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
2467 #endif // GSTREAMER_LITE
2468 
2469 gchar *
2470 g_markup_vprintf_escaped (const gchar *format,
2471                           va_list      args)
2472 {
2473   GString *format1;
2474   GString *format2;
2475   GString *result = NULL;
2476   gchar *output1 = NULL;
2477   gchar *output2 = NULL;
2478   const char *p, *op1, *op2;
2479   va_list args2;
2480 
2481   /* The technique here, is that we make two format strings that
2482    * have the identical conversions in the identical order to the
2483    * original strings, but differ in the text in-between. We
2484    * then use the normal g_strdup_vprintf() to format the arguments
2485    * with the two new format strings. By comparing the results,
2486    * we can figure out what segments of the output come from
2487    * the original format string, and what from the arguments,
2488    * and thus know what portions of the string to escape.
2489    *
2490    * For instance, for:
2491    *
2492    *  g_markup_printf_escaped (&quot;%s ate %d apples&quot;, &quot;Susan &amp; Fred&quot;, 5);
2493    *
2494    * We form the two format strings &quot;%sX%dX&quot; and %sY%sY&quot;. The results
2495    * of formatting with those two strings are
2496    *
2497    * &quot;%sX%dX&quot; =&gt; &quot;Susan &amp; FredX5X&quot;
2498    * &quot;%sY%dY&quot; =&gt; &quot;Susan &amp; FredY5Y&quot;
2499    *
2500    * To find the span of the first argument, we find the first position
2501    * where the two arguments differ, which tells us that the first
2502    * argument formatted to &quot;Susan &amp; Fred&quot;. We then escape that
2503    * to &quot;Susan &amp; Fred&quot; and join up with the intermediate portions
2504    * of the format string and the second argument to get
2505    * &quot;Susan &amp; Fred ate 5 apples&quot;.
2506    */
2507 
2508   /* Create the two modified format strings
2509    */
2510   format1 = g_string_new (NULL);
2511   format2 = g_string_new (NULL);
2512   p = format;
2513   while (TRUE)
2514     {
2515       const char *after;
2516       const char *conv = find_conversion (p, &amp;after);
2517       if (!conv)
2518         break;
2519 
2520       g_string_append_len (format1, conv, after - conv);
2521       g_string_append_c (format1, &#39;X&#39;);
2522       g_string_append_len (format2, conv, after - conv);
2523       g_string_append_c (format2, &#39;Y&#39;);
2524 
2525       p = after;
2526     }
2527 
2528   /* Use them to format the arguments
2529    */
2530   G_VA_COPY (args2, args);
2531 
2532   output1 = g_strdup_vprintf (format1-&gt;str, args);
2533 
2534   if (!output1)
2535     {
2536       va_end (args2);
2537       goto cleanup;
2538     }
2539 
2540   output2 = g_strdup_vprintf (format2-&gt;str, args2);
2541   va_end (args2);
2542   if (!output2)
2543     goto cleanup;
2544   result = g_string_new (NULL);
2545 
2546   /* Iterate through the original format string again,
2547    * copying the non-conversion portions and the escaped
2548    * converted arguments to the output string.
2549    */
2550   op1 = output1;
2551   op2 = output2;
2552   p = format;
2553   while (TRUE)
2554     {
2555       const char *after;
2556       const char *output_start;
2557       const char *conv = find_conversion (p, &amp;after);
2558       char *escaped;
2559 
2560       if (!conv)        /* The end, after points to the trailing \0 */
2561         {
2562           g_string_append_len (result, p, after - p);
2563           break;
2564         }
2565 
2566       g_string_append_len (result, p, conv - p);
2567       output_start = op1;
2568       while (*op1 == *op2)
2569         {
2570           op1++;
2571           op2++;
2572         }
2573 
2574       escaped = g_markup_escape_text (output_start, op1 - output_start);
2575       g_string_append (result, escaped);
2576       g_free (escaped);
2577 
2578       p = after;
2579       op1++;
2580       op2++;
2581     }
2582 
2583  cleanup:
2584   g_string_free (format1, TRUE);
2585   g_string_free (format2, TRUE);
2586   g_free (output1);
2587   g_free (output2);
2588 
2589   if (result)
2590     return g_string_free (result, FALSE);
2591   else
2592     return NULL;
2593 }
2594 
2595 #ifdef GSTREAMER_LITE
2596 #ifndef G_OS_WIN32
2597 #pragma GCC diagnostic pop
2598 #endif // G_OS_WIN32
2599 #else // GSTREAMER_LITE
2600 #pragma GCC diagnostic pop
2601 #endif // GSTREAMER_LITE
2602 
2603 /**
2604  * g_markup_printf_escaped:
2605  * @format: printf() style format string
2606  * @...: the arguments to insert in the format string
2607  *
2608  * Formats arguments according to @format, escaping
2609  * all string and character arguments in the fashion
2610  * of g_markup_escape_text(). This is useful when you
2611  * want to insert literal strings into XML-style markup
2612  * output, without having to worry that the strings
2613  * might themselves contain markup.
2614  *
2615  * |[&lt;!-- language=&quot;C&quot; --&gt;
2616  * const char *store = &quot;Fortnum &amp; Mason&quot;;
2617  * const char *item = &quot;Tea&quot;;
2618  * char *output;
2619  *
2620  * output = g_markup_printf_escaped (&quot;&lt;purchase&gt;&quot;
2621  *                                   &quot;&lt;store&gt;%s&lt;/store&gt;&quot;
2622  *                                   &quot;&lt;item&gt;%s&lt;/item&gt;&quot;
2623  *                                   &quot;&lt;/purchase&gt;&quot;,
2624  *                                   store, item);
2625  * ]|
2626  *
2627  * Returns: newly allocated result from formatting
2628  *    operation. Free with g_free().
2629  *
2630  * Since: 2.4
2631  */
2632 gchar *
2633 g_markup_printf_escaped (const gchar *format, ...)
2634 {
2635   char *result;
2636   va_list args;
2637 
2638   va_start (args, format);
2639   result = g_markup_vprintf_escaped (format, args);
2640   va_end (args);
2641 
2642   return result;
2643 }
2644 
2645 static gboolean
2646 g_markup_parse_boolean (const char  *string,
2647                         gboolean    *value)
2648 {
2649   char const * const falses[] = { &quot;false&quot;, &quot;f&quot;, &quot;no&quot;, &quot;n&quot;, &quot;0&quot; };
2650   char const * const trues[] = { &quot;true&quot;, &quot;t&quot;, &quot;yes&quot;, &quot;y&quot;, &quot;1&quot; };
2651   gsize i;
2652 
2653   for (i = 0; i &lt; G_N_ELEMENTS (falses); i++)
2654     {
2655       if (g_ascii_strcasecmp (string, falses[i]) == 0)
2656         {
2657           if (value != NULL)
2658             *value = FALSE;
2659 
2660           return TRUE;
2661         }
2662     }
2663 
2664   for (i = 0; i &lt; G_N_ELEMENTS (trues); i++)
2665     {
2666       if (g_ascii_strcasecmp (string, trues[i]) == 0)
2667         {
2668           if (value != NULL)
2669             *value = TRUE;
2670 
2671           return TRUE;
2672         }
2673     }
2674 
2675   return FALSE;
2676 }
2677 
2678 /**
2679  * GMarkupCollectType:
2680  * @G_MARKUP_COLLECT_INVALID: used to terminate the list of attributes
2681  *     to collect
2682  * @G_MARKUP_COLLECT_STRING: collect the string pointer directly from
2683  *     the attribute_values[] array. Expects a parameter of type (const
2684  *     char **). If %G_MARKUP_COLLECT_OPTIONAL is specified and the
2685  *     attribute isn&#39;t present then the pointer will be set to %NULL
2686  * @G_MARKUP_COLLECT_STRDUP: as with %G_MARKUP_COLLECT_STRING, but
2687  *     expects a parameter of type (char **) and g_strdup()s the
2688  *     returned pointer. The pointer must be freed with g_free()
2689  * @G_MARKUP_COLLECT_BOOLEAN: expects a parameter of type (gboolean *)
2690  *     and parses the attribute value as a boolean. Sets %FALSE if the
2691  *     attribute isn&#39;t present. Valid boolean values consist of
2692  *     (case-insensitive) &quot;false&quot;, &quot;f&quot;, &quot;no&quot;, &quot;n&quot;, &quot;0&quot; and &quot;true&quot;, &quot;t&quot;,
2693  *     &quot;yes&quot;, &quot;y&quot;, &quot;1&quot;
2694  * @G_MARKUP_COLLECT_TRISTATE: as with %G_MARKUP_COLLECT_BOOLEAN, but
2695  *     in the case of a missing attribute a value is set that compares
2696  *     equal to neither %FALSE nor %TRUE G_MARKUP_COLLECT_OPTIONAL is
2697  *     implied
2698  * @G_MARKUP_COLLECT_OPTIONAL: can be bitwise ORed with the other fields.
2699  *     If present, allows the attribute not to appear. A default value
2700  *     is set depending on what value type is used
2701  *
2702  * A mixed enumerated type and flags field. You must specify one type
2703  * (string, strdup, boolean, tristate).  Additionally, you may  optionally
2704  * bitwise OR the type with the flag %G_MARKUP_COLLECT_OPTIONAL.
2705  *
2706  * It is likely that this enum will be extended in the future to
2707  * support other types.
2708  */
2709 
2710 /**
2711  * g_markup_collect_attributes:
2712  * @element_name: the current tag name
2713  * @attribute_names: the attribute names
2714  * @attribute_values: the attribute values
2715  * @error: a pointer to a #GError or %NULL
2716  * @first_type: the #GMarkupCollectType of the first attribute
2717  * @first_attr: the name of the first attribute
2718  * @...: a pointer to the storage location of the first attribute
2719  *     (or %NULL), followed by more types names and pointers, ending
2720  *     with %G_MARKUP_COLLECT_INVALID
2721  *
2722  * Collects the attributes of the element from the data passed to the
2723  * #GMarkupParser start_element function, dealing with common error
2724  * conditions and supporting boolean values.
2725  *
2726  * This utility function is not required to write a parser but can save
2727  * a lot of typing.
2728  *
2729  * The @element_name, @attribute_names, @attribute_values and @error
2730  * parameters passed to the start_element callback should be passed
2731  * unmodified to this function.
2732  *
2733  * Following these arguments is a list of &quot;supported&quot; attributes to collect.
2734  * It is an error to specify multiple attributes with the same name. If any
2735  * attribute not in the list appears in the @attribute_names array then an
2736  * unknown attribute error will result.
2737  *
2738  * The #GMarkupCollectType field allows specifying the type of collection
2739  * to perform and if a given attribute must appear or is optional.
2740  *
2741  * The attribute name is simply the name of the attribute to collect.
2742  *
2743  * The pointer should be of the appropriate type (see the descriptions
2744  * under #GMarkupCollectType) and may be %NULL in case a particular
2745  * attribute is to be allowed but ignored.
2746  *
2747  * This function deals with issuing errors for missing attributes
2748  * (of type %G_MARKUP_ERROR_MISSING_ATTRIBUTE), unknown attributes
2749  * (of type %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE) and duplicate
2750  * attributes (of type %G_MARKUP_ERROR_INVALID_CONTENT) as well
2751  * as parse errors for boolean-valued attributes (again of type
2752  * %G_MARKUP_ERROR_INVALID_CONTENT). In all of these cases %FALSE
2753  * will be returned and @error will be set as appropriate.
2754  *
2755  * Returns: %TRUE if successful
2756  *
2757  * Since: 2.16
2758  **/
2759 gboolean
2760 g_markup_collect_attributes (const gchar         *element_name,
2761                              const gchar        **attribute_names,
2762                              const gchar        **attribute_values,
2763                              GError             **error,
2764                              GMarkupCollectType   first_type,
2765                              const gchar         *first_attr,
2766                              ...)
2767 {
2768   GMarkupCollectType type;
2769   const gchar *attr;
2770   guint64 collected;
2771   int written;
2772   va_list ap;
2773   int i;
2774 
2775   type = first_type;
2776   attr = first_attr;
2777   collected = 0;
2778   written = 0;
2779 
2780   va_start (ap, first_attr);
2781   while (type != G_MARKUP_COLLECT_INVALID)
2782     {
2783       gboolean mandatory;
2784       const gchar *value;
2785 
2786       mandatory = !(type &amp; G_MARKUP_COLLECT_OPTIONAL);
2787       type &amp;= (G_MARKUP_COLLECT_OPTIONAL - 1);
2788 
2789       /* tristate records a value != TRUE and != FALSE
2790        * for the case where the attribute is missing
2791        */
2792       if (type == G_MARKUP_COLLECT_TRISTATE)
2793         mandatory = FALSE;
2794 
2795       for (i = 0; attribute_names[i]; i++)
2796         if (i &gt;= 40 || !(collected &amp; (G_GUINT64_CONSTANT(1) &lt;&lt; i)))
2797           if (!strcmp (attribute_names[i], attr))
2798             break;
2799 
2800       /* ISO C99 only promises that the user can pass up to 127 arguments.
2801        * Subtracting the first 4 arguments plus the final NULL and dividing
2802        * by 3 arguments per collected attribute, we are left with a maximum
2803        * number of supported attributes of (127 - 5) / 3 = 40.
2804        *
2805        * In reality, nobody is ever going to call us with anywhere close to
2806        * 40 attributes to collect, so it is safe to assume that if i &gt; 40
2807        * then the user has given some invalid or repeated arguments.  These
2808        * problems will be caught and reported at the end of the function.
2809        *
2810        * We know at this point that we have an error, but we don&#39;t know
2811        * what error it is, so just continue...
2812        */
2813       if (i &lt; 40)
2814         collected |= (G_GUINT64_CONSTANT(1) &lt;&lt; i);
2815 
2816       value = attribute_values[i];
2817 
2818       if (value == NULL &amp;&amp; mandatory)
2819         {
2820           g_set_error (error, G_MARKUP_ERROR,
2821                        G_MARKUP_ERROR_MISSING_ATTRIBUTE,
2822                        &quot;element &#39;%s&#39; requires attribute &#39;%s&#39;&quot;,
2823                        element_name, attr);
2824 
2825           va_end (ap);
2826           goto failure;
2827         }
2828 
2829       switch (type)
2830         {
2831         case G_MARKUP_COLLECT_STRING:
2832           {
2833             const char **str_ptr;
2834 
2835             str_ptr = va_arg (ap, const char **);
2836 
2837             if (str_ptr != NULL)
2838               *str_ptr = value;
2839           }
2840           break;
2841 
2842         case G_MARKUP_COLLECT_STRDUP:
2843           {
2844             char **str_ptr;
2845 
2846             str_ptr = va_arg (ap, char **);
2847 
2848             if (str_ptr != NULL)
2849               *str_ptr = g_strdup (value);
2850           }
2851           break;
2852 
2853         case G_MARKUP_COLLECT_BOOLEAN:
2854         case G_MARKUP_COLLECT_TRISTATE:
2855           if (value == NULL)
2856             {
2857               gboolean *bool_ptr;
2858 
2859               bool_ptr = va_arg (ap, gboolean *);
2860 
2861               if (bool_ptr != NULL)
2862                 {
2863                   if (type == G_MARKUP_COLLECT_TRISTATE)
2864                     /* constructivists rejoice!
2865                      * neither false nor true...
2866                      */
2867                     *bool_ptr = -1;
2868 
2869                   else /* G_MARKUP_COLLECT_BOOLEAN */
2870                     *bool_ptr = FALSE;
2871                 }
2872             }
2873           else
2874             {
2875               if (!g_markup_parse_boolean (value, va_arg (ap, gboolean *)))
2876                 {
2877                   g_set_error (error, G_MARKUP_ERROR,
2878                                G_MARKUP_ERROR_INVALID_CONTENT,
2879                                &quot;element &#39;%s&#39;, attribute &#39;%s&#39;, value &#39;%s&#39; &quot;
2880                                &quot;cannot be parsed as a boolean value&quot;,
2881                                element_name, attr, value);
2882 
2883                   va_end (ap);
2884                   goto failure;
2885                 }
2886             }
2887 
2888           break;
2889 
2890         default:
2891           g_assert_not_reached ();
2892         }
2893 
2894       written++;
2895       type = va_arg (ap, GMarkupCollectType);
2896       if (type != G_MARKUP_COLLECT_INVALID)
2897         attr = va_arg (ap, const char *);
2898     }
2899   va_end (ap);
2900 
2901   /* ensure we collected all the arguments */
2902   for (i = 0; attribute_names[i]; i++)
2903     if ((collected &amp; (G_GUINT64_CONSTANT(1) &lt;&lt; i)) == 0)
2904       {
2905         /* attribute not collected:  could be caused by two things.
2906          *
2907          * 1) it doesn&#39;t exist in our list of attributes
2908          * 2) it existed but was matched by a duplicate attribute earlier
2909          *
2910          * find out.
2911          */
2912         int j;
2913 
2914         for (j = 0; j &lt; i; j++)
2915           if (strcmp (attribute_names[i], attribute_names[j]) == 0)
2916             /* duplicate! */
2917             break;
2918 
2919         /* j is now the first occurrence of attribute_names[i] */
2920         if (i == j)
2921           g_set_error (error, G_MARKUP_ERROR,
2922                        G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE,
2923                        &quot;attribute &#39;%s&#39; invalid for element &#39;%s&#39;&quot;,
2924                        attribute_names[i], element_name);
2925         else
2926           g_set_error (error, G_MARKUP_ERROR,
2927                        G_MARKUP_ERROR_INVALID_CONTENT,
2928                        &quot;attribute &#39;%s&#39; given multiple times for element &#39;%s&#39;&quot;,
2929                        attribute_names[i], element_name);
2930 
2931         goto failure;
2932       }
2933 
2934   return TRUE;
2935 
2936 failure:
2937   /* replay the above to free allocations */
2938   type = first_type;
2939   attr = first_attr;
2940 
2941   va_start (ap, first_attr);
2942   while (type != G_MARKUP_COLLECT_INVALID)
2943     {
2944       gpointer ptr;
2945 
2946       ptr = va_arg (ap, gpointer);
2947 
2948       if (ptr != NULL)
2949         {
2950           switch (type &amp; (G_MARKUP_COLLECT_OPTIONAL - 1))
2951             {
2952             case G_MARKUP_COLLECT_STRDUP:
2953               if (written)
2954                 g_free (*(char **) ptr);
2955               *(char **) ptr = NULL;
2956               break;
2957 
2958             case G_MARKUP_COLLECT_STRING:
2959               *(char **) ptr = NULL;
2960               break;
2961 
2962             case G_MARKUP_COLLECT_BOOLEAN:
2963               *(gboolean *) ptr = FALSE;
2964               break;
2965 
2966             case G_MARKUP_COLLECT_TRISTATE:
2967               *(gboolean *) ptr = -1;
2968               break;
2969             }
2970         }
2971 
2972       type = va_arg (ap, GMarkupCollectType);
2973       if (type != G_MARKUP_COLLECT_INVALID)
2974         attr = va_arg (ap, const char *);
2975     }
2976   va_end (ap);
2977 
2978   return FALSE;
2979 }
    </pre>
  </body>
</html>