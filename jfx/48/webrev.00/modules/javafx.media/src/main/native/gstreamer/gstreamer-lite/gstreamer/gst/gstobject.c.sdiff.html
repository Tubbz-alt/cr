<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstobject.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstminiobject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstobject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstobject.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 278  * the floating flag while leaving the reference count unchanged. If the object
 279  * is not floating, then this call adds a new normal reference increasing the
 280  * reference count by one.
 281  *
 282  * For more background on &quot;floating references&quot; please see the #GObject
 283  * documentation.
 284  */
 285 gpointer
 286 gst_object_ref_sink (gpointer object)
 287 {
 288   g_return_val_if_fail (object != NULL, NULL);
 289 
 290 #ifdef DEBUG_REFCOUNT
 291   GST_CAT_TRACE_OBJECT (GST_CAT_REFCOUNTING, object, &quot;%p ref_sink %d-&gt;%d&quot;,
 292       object, ((GObject *) object)-&gt;ref_count,
 293       ((GObject *) object)-&gt;ref_count + 1);
 294 #endif
 295   return g_object_ref_sink (object);
 296 }
 297 
























 298 /**
 299  * gst_object_replace:
 300  * @oldobj: (inout) (transfer full) (nullable): pointer to a place of
 301  *     a #GstObject to replace
 302  * @newobj: (transfer none) (allow-none): a new #GstObject
 303  *
 304  * Atomically modifies a pointer to point to a new object.
 305  * The reference count of @oldobj is decreased and the reference count of
 306  * @newobj is increased.
 307  *
 308  * Either @newobj and the value pointed to by @oldobj may be %NULL.
 309  *
 310  * Returns: %TRUE if @newobj was different from @oldobj
 311  */
 312 gboolean
 313 gst_object_replace (GstObject ** oldobj, GstObject * newobj)
 314 {
 315   GstObject *oldptr;
 316 
 317   g_return_val_if_fail (oldobj != NULL, FALSE);
</pre>
<hr />
<pre>
1407   g_return_val_if_fail (GST_CLOCK_TIME_IS_VALID (timestamp), FALSE);
1408   g_return_val_if_fail (GST_CLOCK_TIME_IS_VALID (interval), FALSE);
1409   g_return_val_if_fail (values, FALSE);
1410 
1411   GST_OBJECT_LOCK (object);
1412   if ((binding = gst_object_find_control_binding (object, property_name))) {
1413     res = gst_control_binding_get_g_value_array (binding, timestamp, interval,
1414         n_values, values);
1415   }
1416   GST_OBJECT_UNLOCK (object);
1417   return res;
1418 }
1419 
1420 
1421 /**
1422  * gst_object_get_control_rate:
1423  * @object: the object that has controlled properties
1424  *
1425  * Obtain the control-rate for this @object. Audio processing #GstElement
1426  * objects will use this rate to sub-divide their processing loop and call
<span class="line-modified">1427  * gst_object_sync_values() inbetween. The length of the processing segment</span>
1428  * should be up to @control-rate nanoseconds.
1429  *
1430  * If the @object is not under property control, this will return
1431  * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
1432  *
1433  * The control-rate is not expected to change if the element is in
1434  * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
1435  *
1436  * Returns: the control rate in nanoseconds
1437  */
1438 GstClockTime
1439 gst_object_get_control_rate (GstObject * object)
1440 {
1441   g_return_val_if_fail (GST_IS_OBJECT (object), FALSE);
1442 
1443   return object-&gt;control_rate;
1444 }
1445 
1446 /**
1447  * gst_object_set_control_rate:
1448  * @object: the object that has controlled properties
1449  * @control_rate: the new control-rate in nanoseconds.
1450  *
1451  * Change the control-rate for this @object. Audio processing #GstElement
1452  * objects will use this rate to sub-divide their processing loop and call
<span class="line-modified">1453  * gst_object_sync_values() inbetween. The length of the processing segment</span>
1454  * should be up to @control-rate nanoseconds.
1455  *
1456  * The control-rate should not change if the element is in %GST_STATE_PAUSED or
1457  * %GST_STATE_PLAYING.
1458  */
1459 void
1460 gst_object_set_control_rate (GstObject * object, GstClockTime control_rate)
1461 {
1462   g_return_if_fail (GST_IS_OBJECT (object));
1463 
1464   object-&gt;control_rate = control_rate;
1465 }
</pre>
</td>
<td>
<hr />
<pre>
 278  * the floating flag while leaving the reference count unchanged. If the object
 279  * is not floating, then this call adds a new normal reference increasing the
 280  * reference count by one.
 281  *
 282  * For more background on &quot;floating references&quot; please see the #GObject
 283  * documentation.
 284  */
 285 gpointer
 286 gst_object_ref_sink (gpointer object)
 287 {
 288   g_return_val_if_fail (object != NULL, NULL);
 289 
 290 #ifdef DEBUG_REFCOUNT
 291   GST_CAT_TRACE_OBJECT (GST_CAT_REFCOUNTING, object, &quot;%p ref_sink %d-&gt;%d&quot;,
 292       object, ((GObject *) object)-&gt;ref_count,
 293       ((GObject *) object)-&gt;ref_count + 1);
 294 #endif
 295   return g_object_ref_sink (object);
 296 }
 297 
<span class="line-added"> 298 /**</span>
<span class="line-added"> 299  * gst_clear_object: (skip)</span>
<span class="line-added"> 300  * @object_ptr: a pointer to a #GstObject reference</span>
<span class="line-added"> 301  *</span>
<span class="line-added"> 302  * Clears a reference to a #GstObject.</span>
<span class="line-added"> 303  *</span>
<span class="line-added"> 304  * @object_ptr must not be %NULL.</span>
<span class="line-added"> 305  *</span>
<span class="line-added"> 306  * If the reference is %NULL then this function does nothing.</span>
<span class="line-added"> 307  * Otherwise, the reference count of the object is decreased using</span>
<span class="line-added"> 308  * gst_object_unref() and the pointer is set to %NULL.</span>
<span class="line-added"> 309  *</span>
<span class="line-added"> 310  * A macro is also included that allows this function to be used without</span>
<span class="line-added"> 311  * pointer casts.</span>
<span class="line-added"> 312  *</span>
<span class="line-added"> 313  * Since: 1.16</span>
<span class="line-added"> 314  **/</span>
<span class="line-added"> 315 #undef gst_clear_object</span>
<span class="line-added"> 316 void</span>
<span class="line-added"> 317 gst_clear_object (GstObject ** object_ptr)</span>
<span class="line-added"> 318 {</span>
<span class="line-added"> 319   g_clear_pointer (object_ptr, gst_object_unref);</span>
<span class="line-added"> 320 }</span>
<span class="line-added"> 321 </span>
 322 /**
 323  * gst_object_replace:
 324  * @oldobj: (inout) (transfer full) (nullable): pointer to a place of
 325  *     a #GstObject to replace
 326  * @newobj: (transfer none) (allow-none): a new #GstObject
 327  *
 328  * Atomically modifies a pointer to point to a new object.
 329  * The reference count of @oldobj is decreased and the reference count of
 330  * @newobj is increased.
 331  *
 332  * Either @newobj and the value pointed to by @oldobj may be %NULL.
 333  *
 334  * Returns: %TRUE if @newobj was different from @oldobj
 335  */
 336 gboolean
 337 gst_object_replace (GstObject ** oldobj, GstObject * newobj)
 338 {
 339   GstObject *oldptr;
 340 
 341   g_return_val_if_fail (oldobj != NULL, FALSE);
</pre>
<hr />
<pre>
1431   g_return_val_if_fail (GST_CLOCK_TIME_IS_VALID (timestamp), FALSE);
1432   g_return_val_if_fail (GST_CLOCK_TIME_IS_VALID (interval), FALSE);
1433   g_return_val_if_fail (values, FALSE);
1434 
1435   GST_OBJECT_LOCK (object);
1436   if ((binding = gst_object_find_control_binding (object, property_name))) {
1437     res = gst_control_binding_get_g_value_array (binding, timestamp, interval,
1438         n_values, values);
1439   }
1440   GST_OBJECT_UNLOCK (object);
1441   return res;
1442 }
1443 
1444 
1445 /**
1446  * gst_object_get_control_rate:
1447  * @object: the object that has controlled properties
1448  *
1449  * Obtain the control-rate for this @object. Audio processing #GstElement
1450  * objects will use this rate to sub-divide their processing loop and call
<span class="line-modified">1451  * gst_object_sync_values() in between. The length of the processing segment</span>
1452  * should be up to @control-rate nanoseconds.
1453  *
1454  * If the @object is not under property control, this will return
1455  * %GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.
1456  *
1457  * The control-rate is not expected to change if the element is in
1458  * %GST_STATE_PAUSED or %GST_STATE_PLAYING.
1459  *
1460  * Returns: the control rate in nanoseconds
1461  */
1462 GstClockTime
1463 gst_object_get_control_rate (GstObject * object)
1464 {
1465   g_return_val_if_fail (GST_IS_OBJECT (object), FALSE);
1466 
1467   return object-&gt;control_rate;
1468 }
1469 
1470 /**
1471  * gst_object_set_control_rate:
1472  * @object: the object that has controlled properties
1473  * @control_rate: the new control-rate in nanoseconds.
1474  *
1475  * Change the control-rate for this @object. Audio processing #GstElement
1476  * objects will use this rate to sub-divide their processing loop and call
<span class="line-modified">1477  * gst_object_sync_values() in between. The length of the processing segment</span>
1478  * should be up to @control-rate nanoseconds.
1479  *
1480  * The control-rate should not change if the element is in %GST_STATE_PAUSED or
1481  * %GST_STATE_PLAYING.
1482  */
1483 void
1484 gst_object_set_control_rate (GstObject * object, GstClockTime control_rate)
1485 {
1486   g_return_if_fail (GST_IS_OBJECT (object));
1487 
1488   object-&gt;control_rate = control_rate;
1489 }
</pre>
</td>
</tr>
</table>
<center><a href="gstminiobject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstobject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>