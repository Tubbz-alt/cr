diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gconvert.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gconvert.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gconvert.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gconvert.c
@@ -44,23 +44,16 @@
 #include "gcharsetprivate.h"
 #include "gslist.h"
 #include "gstrfuncs.h"
 #include "gtestutils.h"
 #include "gthread.h"
+#include "gthreadprivate.h"
 #include "gunicode.h"
 #include "gfileutils.h"
 
 #include "glibintl.h"
 
-#if defined(USE_LIBICONV_GNU) && !defined (_LIBICONV_H)
-#error GNU libiconv in use but included iconv.h not from libiconv
-#endif
-#if !defined(USE_LIBICONV_GNU) && defined (_LIBICONV_H) \
-     && !defined (__APPLE_CC__) && !defined (__LP_64__)
-#error GNU libiconv not in use but included iconv.h is from libiconv
-#endif
-
 
 /**
  * SECTION:conversions
  * @title: Character Set Conversion
  * @short_description: convert strings between different character sets
@@ -167,12 +160,12 @@
 
 G_DEFINE_QUARK (g_convert_error, g_convert_error)
 
 static gboolean
 try_conversion (const char *to_codeset,
-        const char *from_codeset,
-        iconv_t    *cd)
+    const char *from_codeset,
+    iconv_t    *cd)
 {
   *cd = iconv_open (to_codeset, from_codeset);
 
   if (*cd == (iconv_t)-1 && errno == EINVAL)
     return FALSE;
@@ -180,23 +173,23 @@
     return TRUE;
 }
 
 static gboolean
 try_to_aliases (const char **to_aliases,
-        const char  *from_codeset,
-        iconv_t     *cd)
+    const char  *from_codeset,
+    iconv_t     *cd)
 {
   if (to_aliases)
     {
       const char **p = to_aliases;
       while (*p)
-    {
-      if (try_conversion (*p, from_codeset, cd))
-        return TRUE;
+  {
+    if (try_conversion (*p, from_codeset, cd))
+      return TRUE;
 
-      p++;
-    }
+    p++;
+  }
     }
 
   return FALSE;
 }
 
@@ -215,36 +208,36 @@
  * Returns: a "conversion descriptor", or (GIConv)-1 if
  *  opening the converter failed.
  **/
 GIConv
 g_iconv_open (const gchar  *to_codeset,
-          const gchar  *from_codeset)
+        const gchar  *from_codeset)
 {
   iconv_t cd;
 
   if (!try_conversion (to_codeset, from_codeset, &cd))
     {
       const char **to_aliases = _g_charset_get_aliases (to_codeset);
       const char **from_aliases = _g_charset_get_aliases (from_codeset);
 
       if (from_aliases)
-    {
-      const char **p = from_aliases;
-      while (*p)
-        {
-          if (try_conversion (to_codeset, *p, &cd))
-        goto out;
+  {
+    const char **p = from_aliases;
+    while (*p)
+      {
+        if (try_conversion (to_codeset, *p, &cd))
+    goto out;
 
-          if (try_to_aliases (to_aliases, *p, &cd))
-        goto out;
+        if (try_to_aliases (to_aliases, *p, &cd))
+    goto out;
 
-          p++;
-        }
-    }
+        p++;
+      }
+  }
 
       if (try_to_aliases (to_aliases, from_codeset, &cd))
-    goto out;
+  goto out;
     }
 
  out:
   return (cd == (iconv_t)-1) ? (GIConv)-1 : (GIConv)cd;
 }
@@ -273,14 +266,14 @@
  *
  * Returns: count of non-reversible conversions, or -1 on error
  **/
 gsize
 g_iconv (GIConv   converter,
-     gchar  **inbuf,
-     gsize   *inbytes_left,
-     gchar  **outbuf,
-     gsize   *outbytes_left)
+   gchar  **inbuf,
+   gsize   *inbytes_left,
+   gchar  **outbuf,
+   gsize   *outbytes_left)
 {
   iconv_t cd = (iconv_t)converter;
 
   return iconv (cd, inbuf, inbytes_left, outbuf, outbytes_left);
 }
@@ -308,31 +301,31 @@
   return iconv_close (cd);
 }
 
 static GIConv
 open_converter (const gchar *to_codeset,
-        const gchar *from_codeset,
-        GError     **error)
+    const gchar *from_codeset,
+    GError     **error)
 {
   GIConv cd;
 
   cd = g_iconv_open (to_codeset, from_codeset);
 
   if (cd == (GIConv) -1)
     {
       /* Something went wrong.  */
       if (error)
-    {
-      if (errno == EINVAL)
-        g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_NO_CONVERSION,
-             _("Conversion from character set '%s' to '%s' is not supported"),
-             from_codeset, to_codeset);
-      else
-        g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,
-             _("Could not open converter from '%s' to '%s'"),
-             from_codeset, to_codeset);
-    }
+  {
+    if (errno == EINVAL)
+      g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_NO_CONVERSION,
+       _("Conversion from character set '%s' to '%s' is not supported"),
+       from_codeset, to_codeset);
+    else
+      g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,
+       _("Could not open converter from '%s' to '%s'"),
+       from_codeset, to_codeset);
+  }
     }
 
   return cd;
 }
 
@@ -392,15 +385,15 @@
  *               containing the converted string, which must be freed with
  *               g_free(). Otherwise %NULL and @error will be set.
  **/
 gchar*
 g_convert_with_iconv (const gchar *str,
-              gssize       len,
-              GIConv       converter,
-              gsize       *bytes_read,
-              gsize       *bytes_written,
-              GError     **error)
+          gssize       len,
+          GIConv       converter,
+          gsize       *bytes_read,
+          gsize       *bytes_written,
+          GError     **error)
 {
   gchar *dest;
   gchar *outp;
   const gchar *p;
   gsize inbytes_remaining;
@@ -429,84 +422,84 @@
         err = g_iconv (converter, NULL, &inbytes_remaining, &outp, &outbytes_remaining);
       else
         err = g_iconv (converter, (char **)&p, &inbytes_remaining, &outp, &outbytes_remaining);
 
       if (err == (gsize) -1)
-    {
-      switch (errno)
+  {
+    switch (errno)
+      {
+      case EINVAL:
+        /* Incomplete text, do not report an error */
+        done = TRUE;
+        break;
+      case E2BIG:
         {
-        case EINVAL:
-          /* Incomplete text, do not report an error */
-          done = TRUE;
-          break;
-        case E2BIG:
-          {
-        gsize used = outp - dest;
-
-        outbuf_size *= 2;
-        dest = g_realloc (dest, outbuf_size);
-
-        outp = dest + used;
-        outbytes_remaining = outbuf_size - used - NUL_TERMINATOR_LENGTH;
-          }
-          break;
-        case EILSEQ:
+    gsize used = outp - dest;
+
+    outbuf_size *= 2;
+    dest = g_realloc (dest, outbuf_size);
+
+    outp = dest + used;
+    outbytes_remaining = outbuf_size - used - NUL_TERMINATOR_LENGTH;
+        }
+        break;
+      case EILSEQ:
               g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
                                    _("Invalid byte sequence in conversion input"));
-          have_error = TRUE;
-          break;
-        default:
+        have_error = TRUE;
+        break;
+      default:
               {
                 int errsv = errno;
 
                 g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,
                              _("Error during conversion: %s"),
                              g_strerror (errsv));
               }
-          have_error = TRUE;
-          break;
-        }
-    }
+        have_error = TRUE;
+        break;
+      }
+  }
       else if (err > 0)
         {
           /* @err gives the number of replacement characters used. */
           g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
                                _("Unrepresentable character in conversion input"));
           have_error = TRUE;
         }
       else
-    {
-      if (!reset)
-        {
-          /* call g_iconv with NULL inbuf to cleanup shift state */
-          reset = TRUE;
-          inbytes_remaining = 0;
-        }
-      else
-        done = TRUE;
-    }
+  {
+    if (!reset)
+      {
+        /* call g_iconv with NULL inbuf to cleanup shift state */
+        reset = TRUE;
+        inbytes_remaining = 0;
+      }
+    else
+      done = TRUE;
+  }
     }
 
   memset (outp, 0, NUL_TERMINATOR_LENGTH);
 
   if (bytes_read)
     *bytes_read = p - str;
   else
     {
       if ((p - str) != len)
-    {
+  {
           if (!have_error)
             {
               g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_PARTIAL_INPUT,
                                    _("Partial character sequence at end of input"));
               have_error = TRUE;
             }
-    }
+  }
     }
 
   if (bytes_written)
-    *bytes_written = outp - dest;   /* Doesn't include '\0' */
+    *bytes_written = outp - dest; /* Doesn't include '\0' */
 
   if (have_error)
     {
       g_free (dest);
       return NULL;
@@ -562,12 +555,12 @@
 g_convert (const gchar *str,
            gssize       len,
            const gchar *to_codeset,
            const gchar *from_codeset,
            gsize       *bytes_read,
-       gsize       *bytes_written,
-       GError     **error)
+     gsize       *bytes_written,
+     GError     **error)
 {
   gchar *res;
   GIConv cd;
 
   g_return_val_if_fail (str != NULL, NULL);
@@ -586,12 +579,12 @@
 
       return NULL;
     }
 
   res = g_convert_with_iconv (str, len, cd,
-                  bytes_read, bytes_written,
-                  error);
+            bytes_read, bytes_written,
+            error);
 
   close_converter (cd);
 
   return res;
 }
@@ -644,17 +637,17 @@
  *          containing the converted string, which must be freed with g_free().
  *          Otherwise %NULL and @error will be set.
  **/
 gchar*
 g_convert_with_fallback (const gchar *str,
-             gssize       len,
-             const gchar *to_codeset,
-             const gchar *from_codeset,
-             const gchar *fallback,
-             gsize       *bytes_read,
-             gsize       *bytes_written,
-             GError     **error)
+       gssize       len,
+       const gchar *to_codeset,
+       const gchar *from_codeset,
+       const gchar *fallback,
+       gsize       *bytes_read,
+       gsize       *bytes_written,
+       GError     **error)
 {
   gchar *utf8;
   gchar *dest;
   gchar *outp;
   const gchar *insert_str = NULL;
@@ -680,11 +673,11 @@
 
   /* Try an exact conversion; we only proceed if this fails
    * due to an illegal sequence in the input string.
    */
   dest = g_convert (str, len, to_codeset, from_codeset,
-            bytes_read, bytes_written, &local_error);
+        bytes_read, bytes_written, &local_error);
   if (!local_error)
     return dest;
 
   if (!g_error_matches (local_error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE))
     {
@@ -710,11 +703,11 @@
 
       return NULL;
     }
 
   utf8 = g_convert (str, len, "UTF-8", from_codeset,
-            bytes_read, &inbytes_remaining, error);
+        bytes_read, &inbytes_remaining, error);
   if (!utf8)
     {
       close_converter (cd);
       if (bytes_written)
         *bytes_written = 0;
@@ -740,106 +733,107 @@
       gsize inbytes_tmp = inbytes_remaining;
       err = g_iconv (cd, (char **)&p, &inbytes_tmp, &outp, &outbytes_remaining);
       inbytes_remaining = inbytes_tmp;
 
       if (err == (gsize) -1)
-    {
-      switch (errno)
+  {
+    switch (errno)
+      {
+      case EINVAL:
+        g_assert_not_reached();
+        break;
+      case E2BIG:
         {
-        case EINVAL:
-          g_assert_not_reached();
-          break;
-        case E2BIG:
-          {
-        gsize used = outp - dest;
+    gsize used = outp - dest;
 
-        outbuf_size *= 2;
-        dest = g_realloc (dest, outbuf_size);
+    outbuf_size *= 2;
+    dest = g_realloc (dest, outbuf_size);
 
-        outp = dest + used;
-        outbytes_remaining = outbuf_size - used - NUL_TERMINATOR_LENGTH;
+    outp = dest + used;
+    outbytes_remaining = outbuf_size - used - NUL_TERMINATOR_LENGTH;
 
-        break;
-          }
-        case EILSEQ:
-          if (save_p)
-        {
-          /* Error converting fallback string - fatal
-           */
-          g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
-                   _("Cannot convert fallback '%s' to codeset '%s'"),
-                   insert_str, to_codeset);
-          have_error = TRUE;
-          break;
+    break;
         }
-          else if (p)
+      case EILSEQ:
+        if (save_p)
+    {
+      /* Error converting fallback string - fatal
+       */
+      g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
+             _("Cannot convert fallback '%s' to codeset '%s'"),
+             insert_str, to_codeset);
+      have_error = TRUE;
+      break;
+    }
+        else if (p)
+    {
+      if (!fallback)
         {
-          if (!fallback)
-            {
-              gunichar ch = g_utf8_get_char (p);
-              insert_str = g_strdup_printf (ch < 0x10000 ? "\\u%04x" : "\\U%08x",
-                            ch);
-            }
-          else
-            insert_str = fallback;
-
-          save_p = g_utf8_next_char (p);
-          save_inbytes = inbytes_remaining - (save_p - p);
-          p = insert_str;
-          inbytes_remaining = strlen (p);
-          break;
+          gunichar ch = g_utf8_get_char (p);
+          insert_str = g_strdup_printf (ch < 0x10000 ? "\\u%04x" : "\\U%08x",
+                ch);
         }
-          /* fall thru if p is NULL */
-        default:
+      else
+        insert_str = fallback;
+
+      save_p = g_utf8_next_char (p);
+      save_inbytes = inbytes_remaining - (save_p - p);
+      p = insert_str;
+      inbytes_remaining = strlen (p);
+      break;
+    }
+              /* if p is null */
+              G_GNUC_FALLTHROUGH;
+      default:
               {
                 int errsv = errno;
 
                 g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,
                              _("Error during conversion: %s"),
                              g_strerror (errsv));
               }
 
-          have_error = TRUE;
-          break;
-        }
-    }
-      else
-    {
-      if (save_p)
-        {
-          if (!fallback)
-        g_free ((gchar *)insert_str);
-          p = save_p;
-          inbytes_remaining = save_inbytes;
-          save_p = NULL;
-        }
-      else if (p)
-        {
-          /* call g_iconv with NULL inbuf to cleanup shift state */
-          p = NULL;
-          inbytes_remaining = 0;
-        }
+        have_error = TRUE;
+        break;
+      }
+  }
       else
-        done = TRUE;
-    }
+  {
+    if (save_p)
+      {
+        if (!fallback)
+    g_free ((gchar *)insert_str);
+        p = save_p;
+        inbytes_remaining = save_inbytes;
+        save_p = NULL;
+      }
+    else if (p)
+      {
+        /* call g_iconv with NULL inbuf to cleanup shift state */
+        p = NULL;
+        inbytes_remaining = 0;
+      }
+    else
+      done = TRUE;
+  }
     }
 
   /* Cleanup
    */
   memset (outp, 0, NUL_TERMINATOR_LENGTH);
 
   close_converter (cd);
 
   if (bytes_written)
-    *bytes_written = outp - dest;   /* Doesn't include '\0' */
+    *bytes_written = outp - dest; /* Doesn't include '\0' */
 
   g_free (utf8);
 
   if (have_error)
     {
       if (save_p && !fallback)
-    g_free ((gchar *)insert_str);
+  g_free ((gchar *)insert_str);
       g_free (dest);
       return NULL;
     }
   else
     return dest;
@@ -862,24 +856,24 @@
  * On error, @bytes_read will be set to the byte offset after the last valid
  * and non-nul UTF-8 sequence in @string, and @bytes_written will be set to 0.
  */
 static gchar *
 strdup_len (const gchar *string,
-        gssize       len,
-        gsize       *bytes_read,
-        gsize       *bytes_written,
-        GError     **error)
+      gssize       len,
+      gsize       *bytes_read,
+      gsize       *bytes_written,
+      GError     **error)
 {
   gsize real_len;
   const gchar *end_valid;
 
   if (!g_utf8_validate (string, len, &end_valid))
     {
       if (bytes_read)
-    *bytes_read = end_valid - string;
+  *bytes_read = end_valid - string;
       if (bytes_written)
-    *bytes_written = 0;
+  *bytes_written = 0;
 
       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
                            _("Invalid byte sequence in conversion input"));
       return NULL;
     }
@@ -1003,14 +997,14 @@
  *
  * Returns: (type utf8): The converted string, or %NULL on an error.
  **/
 gchar *
 g_locale_to_utf8 (const gchar  *opsysstring,
-          gssize        len,
-          gsize        *bytes_read,
-          gsize        *bytes_written,
-          GError      **error)
+      gssize        len,
+      gsize        *bytes_read,
+      gsize        *bytes_written,
+      GError      **error)
 {
   const char *charset;
 
   if (g_get_charset (&charset))
     return strdup_len (opsysstring, len, bytes_read, bytes_written, error);
@@ -1052,14 +1046,14 @@
  *          A newly-allocated buffer containing the converted string,
  *          or %NULL on an error, and error will be set.
  **/
 gchar *
 g_locale_from_utf8 (const gchar *utf8string,
-            gssize       len,
-            gsize       *bytes_read,
-            gsize       *bytes_written,
-            GError     **error)
+        gssize       len,
+        gsize       *bytes_read,
+        gsize       *bytes_written,
+        GError     **error)
 {
   const gchar *charset;
 
   if (g_get_charset (&charset))
     return strdup_len (utf8string, len, bytes_read, bytes_written, error);
@@ -1128,14 +1122,11 @@
   static GPrivate cache_private = G_PRIVATE_INIT (filename_charset_cache_free);
   GFilenameCharsetCache *cache = g_private_get (&cache_private);
   const gchar *charset;
 
   if (!cache)
-    {
-      cache = g_new0 (GFilenameCharsetCache, 1);
-      g_private_set (&cache_private, cache);
-    }
+    cache = g_private_set_alloc0 (&cache_private, sizeof (GFilenameCharsetCache));
 
   g_get_charset (&charset);
 
   if (!(cache->charset && strcmp (cache->charset, charset) == 0))
     {
@@ -1147,38 +1138,38 @@
       g_strfreev (cache->filename_charsets);
       cache->charset = g_strdup (charset);
 
       p = getenv ("G_FILENAME_ENCODING");
       if (p != NULL && p[0] != '\0')
-    {
-      cache->filename_charsets = g_strsplit (p, ",", 0);
-      cache->is_utf8 = (strcmp (cache->filename_charsets[0], "UTF-8") == 0);
+  {
+    cache->filename_charsets = g_strsplit (p, ",", 0);
+    cache->is_utf8 = (strcmp (cache->filename_charsets[0], "UTF-8") == 0);
 
-      for (i = 0; cache->filename_charsets[i]; i++)
-        {
-          if (strcmp ("@locale", cache->filename_charsets[i]) == 0)
-        {
-          g_get_charset (&new_charset);
-          g_free (cache->filename_charsets[i]);
-          cache->filename_charsets[i] = g_strdup (new_charset);
-        }
-        }
-    }
-      else if (getenv ("G_BROKEN_FILENAMES") != NULL)
+    for (i = 0; cache->filename_charsets[i]; i++)
+      {
+        if (strcmp ("@locale", cache->filename_charsets[i]) == 0)
     {
-      cache->filename_charsets = g_new0 (gchar *, 2);
-      cache->is_utf8 = g_get_charset (&new_charset);
-      cache->filename_charsets[0] = g_strdup (new_charset);
+      g_get_charset (&new_charset);
+      g_free (cache->filename_charsets[i]);
+      cache->filename_charsets[i] = g_strdup (new_charset);
     }
+      }
+  }
+      else if (getenv ("G_BROKEN_FILENAMES") != NULL)
+  {
+    cache->filename_charsets = g_new0 (gchar *, 2);
+    cache->is_utf8 = g_get_charset (&new_charset);
+    cache->filename_charsets[0] = g_strdup (new_charset);
+  }
       else
-    {
-      cache->filename_charsets = g_new0 (gchar *, 3);
-      cache->is_utf8 = TRUE;
-      cache->filename_charsets[0] = g_strdup ("UTF-8");
-      if (!g_get_charset (&new_charset))
-        cache->filename_charsets[1] = g_strdup (new_charset);
-    }
+  {
+    cache->filename_charsets = g_new0 (gchar *, 3);
+    cache->is_utf8 = TRUE;
+    cache->filename_charsets[0] = g_strdup ("UTF-8");
+    if (!g_get_charset (&new_charset))
+      cache->filename_charsets[1] = g_strdup (new_charset);
+  }
     }
 
   if (filename_charsets)
     *filename_charsets = (const gchar **)cache->filename_charsets;
 
@@ -1265,14 +1256,14 @@
  *
  * Returns: (type utf8): The converted string, or %NULL on an error.
  **/
 gchar*
 g_filename_to_utf8 (const gchar *opsysstring,
-            gssize       len,
-            gsize       *bytes_read,
-            gsize       *bytes_written,
-            GError     **error)
+        gssize       len,
+        gsize       *bytes_read,
+        gsize       *bytes_written,
+        GError     **error)
 {
   const gchar *charset;
 
   g_return_val_if_fail (opsysstring != NULL, NULL);
 
@@ -1317,14 +1308,14 @@
  * Returns: (type filename):
  *               The converted string, or %NULL on an error.
  **/
 gchar*
 g_filename_from_utf8 (const gchar *utf8string,
-              gssize       len,
-              gsize       *bytes_read,
-              gsize       *bytes_written,
-              GError     **error)
+          gssize       len,
+          gsize       *bytes_read,
+          gsize       *bytes_written,
+          GError     **error)
 {
   const gchar *charset;
 
   if (get_filename_charset (&charset))
     return strdup_len (utf8string, len, bytes_read, bytes_written, error);
@@ -1346,11 +1337,11 @@
   /* Eat one character at a time. */
   h = haystack;
   n = needle;
 
   while (*n && *h &&
-     g_ascii_tolower (*n) == g_ascii_tolower (*h))
+   g_ascii_tolower (*n) == g_ascii_tolower (*h))
     {
       n++;
       h++;
     }
 
@@ -1385,11 +1376,11 @@
 
 /* Note: This escape function works on file: URIs, but if you want to
  * escape something else, please read RFC-2396 */
 static gchar *
 g_escape_uri_string (const gchar *string,
-             UnsafeCharacterSet mask)
+         UnsafeCharacterSet mask)
 {
 #define ACCEPTABLE(a) ((a)>=32 && (a)<128 && (acceptable[(a)-32] & use_mask))
 
   const gchar *p;
   gchar *q;
@@ -1397,50 +1388,50 @@
   int c;
   gint unacceptable;
   UnsafeCharacterSet use_mask;
 
   g_return_val_if_fail (mask == UNSAFE_ALL
-            || mask == UNSAFE_ALLOW_PLUS
-            || mask == UNSAFE_PATH
-            || mask == UNSAFE_HOST
-            || mask == UNSAFE_SLASHES, NULL);
+      || mask == UNSAFE_ALLOW_PLUS
+      || mask == UNSAFE_PATH
+      || mask == UNSAFE_HOST
+      || mask == UNSAFE_SLASHES, NULL);
 
   unacceptable = 0;
   use_mask = mask;
   for (p = string; *p != '\0'; p++)
     {
       c = (guchar) *p;
       if (!ACCEPTABLE (c))
-    unacceptable++;
+  unacceptable++;
     }
 
   result = g_malloc (p - string + unacceptable * 2 + 1);
 
   use_mask = mask;
   for (q = result, p = string; *p != '\0'; p++)
     {
       c = (guchar) *p;
 
       if (!ACCEPTABLE (c))
-    {
-      *q++ = '%'; /* means hex coming */
-      *q++ = hex[c >> 4];
-      *q++ = hex[c & 15];
-    }
+  {
+    *q++ = '%'; /* means hex coming */
+    *q++ = hex[c >> 4];
+    *q++ = hex[c & 15];
+  }
       else
-    *q++ = *p;
+  *q++ = *p;
     }
 
   *q = '\0';
 
   return result;
 }
 
 
 static gchar *
 g_escape_file_uri (const gchar *hostname,
-           const gchar *pathname)
+       const gchar *pathname)
 {
   char *escaped_hostname = NULL;
   char *escaped_path;
   char *res;
 
@@ -1467,14 +1458,14 @@
     }
 
   escaped_path = g_escape_uri_string (pathname, UNSAFE_PATH);
 
   res = g_strconcat ("file://",
-             (escaped_hostname) ? escaped_hostname : "",
-             (*escaped_path != '/') ? "/" : "",
-             escaped_path,
-             NULL);
+         (escaped_hostname) ? escaped_hostname : "",
+         (*escaped_path != '/') ? "/" : "",
+         escaped_path,
+         NULL);
 
 #ifdef G_OS_WIN32
   g_free ((char *) pathname);
 #endif
 
@@ -1501,13 +1492,13 @@
   return (first_digit << 4) | second_digit;
 }
 
 static gchar *
 g_unescape_uri_string (const char *escaped,
-               int         len,
-               const char *illegal_escaped_characters,
-               gboolean    ascii_must_not_be_escaped)
+           int         len,
+           const char *illegal_escaped_characters,
+           gboolean    ascii_must_not_be_escaped)
 {
   const gchar *in, *in_end;
   gchar *out, *result;
   int c;
 
@@ -1523,31 +1514,31 @@
   for (in = escaped, in_end = escaped + len; in < in_end; in++)
     {
       c = *in;
 
       if (c == '%')
-    {
-      /* catch partial escape sequences past the end of the substring */
-      if (in + 3 > in_end)
-        break;
+  {
+    /* catch partial escape sequences past the end of the substring */
+    if (in + 3 > in_end)
+      break;
 
-      c = unescape_character (in + 1);
+    c = unescape_character (in + 1);
 
-      /* catch bad escape sequences and NUL characters */
-      if (c <= 0)
-        break;
+    /* catch bad escape sequences and NUL characters */
+    if (c <= 0)
+      break;
 
-      /* catch escaped ASCII */
-      if (ascii_must_not_be_escaped && c <= 0x7F)
-        break;
+    /* catch escaped ASCII */
+    if (ascii_must_not_be_escaped && c <= 0x7F)
+      break;
 
-      /* catch other illegal escaped characters */
-      if (strchr (illegal_escaped_characters, c) != NULL)
-        break;
+    /* catch other illegal escaped characters */
+    if (strchr (illegal_escaped_characters, c) != NULL)
+      break;
 
-      in += 2;
-    }
+    in += 2;
+  }
 
       *out++ = c;
     }
 
   g_assert (out - result <= len);
@@ -1588,25 +1579,25 @@
     {
       /* read in a label */
       c = g_utf8_get_char (p);
       p = g_utf8_next_char (p);
       if (!is_asciialphanum (c))
-    return FALSE;
+  return FALSE;
       first_char = c;
       do
-    {
-      last_char = c;
-      c = g_utf8_get_char (p);
-      p = g_utf8_next_char (p);
-    }
+  {
+    last_char = c;
+    c = g_utf8_get_char (p);
+    p = g_utf8_next_char (p);
+  }
       while (is_asciialphanum (c) || c == '-');
       if (last_char == '-')
-    return FALSE;
+  return FALSE;
 
       /* if that was the last label, check that it was a toplabel */
       if (c == '\0' || (c == '.' && *p == '\0'))
-    return is_asciialpha (first_char);
+  return is_asciialpha (first_char);
     }
   while (c == '.');
   return FALSE;
 }
 
@@ -1625,12 +1616,12 @@
  * Returns: (type filename): a newly-allocated string holding
  *               the resulting filename, or %NULL on an error.
  **/
 gchar *
 g_filename_from_uri (const gchar *uri,
-             gchar      **hostname,
-             GError     **error)
+         gchar      **hostname,
+         GError     **error)
 {
   const char *path_part;
   const char *host_part;
   char *unescaped_hostname;
   char *result;
@@ -1644,22 +1635,22 @@
     *hostname = NULL;
 
   if (!has_case_prefix (uri, "file:/"))
     {
       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,
-           _("The URI '%s' is not an absolute URI using the 'file' scheme"),
-           uri);
+       _("The URI '%s' is not an absolute URI using the 'file' scheme"),
+       uri);
       return NULL;
     }
 
   path_part = uri + strlen ("file:");
 
   if (strchr (path_part, '#') != NULL)
     {
       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,
-           _("The local file URI '%s' may not include a '#'"),
-           uri);
+       _("The local file URI '%s' may not include a '#'"),
+       uri);
       return NULL;
     }
 
   if (has_case_prefix (path_part, "///"))
     path_part += 2;
@@ -1669,42 +1660,42 @@
       host_part = path_part;
 
       path_part = strchr (path_part, '/');
 
       if (path_part == NULL)
-    {
-      g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,
-               _("The URI '%s' is invalid"),
-               uri);
-      return NULL;
-    }
+  {
+    g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,
+           _("The URI '%s' is invalid"),
+           uri);
+    return NULL;
+  }
 
       unescaped_hostname = g_unescape_uri_string (host_part, path_part - host_part, "", TRUE);
 
       if (unescaped_hostname == NULL ||
-      !hostname_validate (unescaped_hostname))
-    {
-      g_free (unescaped_hostname);
-      g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,
-               _("The hostname of the URI '%s' is invalid"),
-               uri);
-      return NULL;
-    }
+    !hostname_validate (unescaped_hostname))
+  {
+    g_free (unescaped_hostname);
+    g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,
+           _("The hostname of the URI '%s' is invalid"),
+           uri);
+    return NULL;
+  }
 
       if (hostname)
-    *hostname = unescaped_hostname;
+  *hostname = unescaped_hostname;
       else
-    g_free (unescaped_hostname);
+  g_free (unescaped_hostname);
     }
 
   filename = g_unescape_uri_string (path_part, -1, "/", FALSE);
 
   if (filename == NULL)
     {
       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,
-           _("The URI '%s' contains invalidly escaped characters"),
-           uri);
+       _("The URI '%s' contains invalidly escaped characters"),
+       uri);
       return NULL;
     }
 
   offs = 0;
 #ifdef G_OS_WIN32
@@ -1729,16 +1720,16 @@
    * the filename from the drive letter.
    */
   if (g_ascii_isalpha (filename[1]))
     {
       if (filename[2] == ':')
-    offs = 1;
+  offs = 1;
       else if (filename[2] == '|')
-    {
-      filename[2] = ':';
-      offs = 1;
-    }
+  {
+    filename[2] = ':';
+    offs = 1;
+  }
     }
 #endif
 
   result = g_strdup (filename + offs);
   g_free (filename);
@@ -1761,28 +1752,28 @@
  * Returns: a newly-allocated string holding the resulting
  *               URI, or %NULL on an error.
  **/
 gchar *
 g_filename_to_uri (const gchar *filename,
-           const gchar *hostname,
-           GError     **error)
+       const gchar *hostname,
+       GError     **error)
 {
   char *escaped_uri;
 
   g_return_val_if_fail (filename != NULL, NULL);
 
   if (!g_path_is_absolute (filename))
     {
       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_NOT_ABSOLUTE_PATH,
-           _("The pathname '%s' is not an absolute path"),
-           filename);
+       _("The pathname '%s' is not an absolute path"),
+       filename);
       return NULL;
     }
 
   if (hostname &&
       !(g_utf8_validate (hostname, -1, NULL)
-    && hostname_validate (hostname)))
+  && hostname_validate (hostname)))
     {
       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
                            _("Invalid hostname"));
       return NULL;
     }
@@ -1832,34 +1823,34 @@
    * We do allow comments like specified in RFC 2483.
    */
   while (p)
     {
       if (*p != '#')
-    {
-      while (g_ascii_isspace (*p))
-        p++;
+  {
+    while (g_ascii_isspace (*p))
+      p++;
 
-      q = p;
-      while (*q && (*q != '\n') && (*q != '\r'))
-        q++;
+    q = p;
+    while (*q && (*q != '\n') && (*q != '\r'))
+      q++;
 
-      if (q > p)
-        {
-          q--;
-          while (q > p && g_ascii_isspace (*q))
+    if (q > p)
+      {
         q--;
+        while (q > p && g_ascii_isspace (*q))
+    q--;
 
-          if (q > p)
-        {
-          uris = g_slist_prepend (uris, g_strndup (p, q - p + 1));
-          n_uris++;
-        }
-        }
+        if (q > p)
+    {
+      uris = g_slist_prepend (uris, g_strndup (p, q - p + 1));
+      n_uris++;
     }
+      }
+  }
       p = strchr (p, '\n');
       if (p)
-    p++;
+  p++;
     }
 
   result = g_new (gchar *, n_uris + 1);
 
   result[n_uris--] = NULL;
@@ -1949,26 +1940,26 @@
   is_utf8 = g_get_filename_charsets (&charsets);
 
   if (is_utf8)
     {
       if (g_utf8_validate (filename, -1, NULL))
-    display_name = g_strdup (filename);
+  display_name = g_strdup (filename);
     }
 
   if (!display_name)
     {
       /* Try to convert from the filename charsets to UTF-8.
        * Skip the first charset if it is UTF-8.
        */
       for (i = is_utf8 ? 1 : 0; charsets[i]; i++)
-    {
-      display_name = g_convert (filename, -1, "UTF-8", charsets[i],
-                    NULL, NULL, NULL);
+  {
+    display_name = g_convert (filename, -1, "UTF-8", charsets[i],
+            NULL, NULL, NULL);
 
-      if (display_name)
-        break;
-    }
+    if (display_name)
+      break;
+  }
     }
 
   /* if all conversions failed, we replace invalid UTF-8
    * by a question mark
    */
