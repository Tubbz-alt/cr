<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvarianttype.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2007, 2008 Ryan Lortie</span>
<span class="line-modified">   3  * Copyright (C) 2009, 2010 Codethink Limited</span>
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public
  16  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  *
  18  * Author: Ryan Lortie &lt;desrt@desrt.ca&gt;
  19  */
  20 
  21 #include &quot;config.h&quot;
  22 
  23 #include &quot;gvarianttype.h&quot;
  24 
  25 #include &lt;glib/gtestutils.h&gt;
  26 #include &lt;glib/gstrfuncs.h&gt;
  27 #include &lt;glib/gvariant-internal.h&gt;
  28 
  29 #include &lt;string.h&gt;
  30 
  31 
  32 /**
  33  * SECTION:gvarianttype
  34  * @title: GVariantType
  35  * @short_description: introduction to the GVariant type system
  36  * @see_also: #GVariantType, #GVariant
  37  *
  38  * This section introduces the GVariant type system. It is based, in
  39  * large part, on the D-Bus type system, with two major changes and
  40  * some minor lifting of restrictions. The
  41  * [D-Bus specification](http://dbus.freedesktop.org/doc/dbus-specification.html),
  42  * therefore, provides a significant amount of
  43  * information that is useful when working with GVariant.
  44  *
  45  * The first major change with respect to the D-Bus type system is the
  46  * introduction of maybe (or &quot;nullable&quot;) types.  Any type in GVariant can be
  47  * converted to a maybe type, in which case, &quot;nothing&quot; (or &quot;null&quot;) becomes a
  48  * valid value.  Maybe types have been added by introducing the
  49  * character &quot;m&quot; to type strings.
  50  *
  51  * The second major change is that the GVariant type system supports the
  52  * concept of &quot;indefinite types&quot; -- types that are less specific than
  53  * the normal types found in D-Bus.  For example, it is possible to speak
  54  * of &quot;an array of any type&quot; in GVariant, where the D-Bus type system
  55  * would require you to speak of &quot;an array of integers&quot; or &quot;an array of
  56  * strings&quot;.  Indefinite types have been added by introducing the
  57  * characters &quot;*&quot;, &quot;?&quot; and &quot;r&quot; to type strings.
  58  *
  59  * Finally, all arbitrary restrictions relating to the complexity of
  60  * types are lifted along with the restriction that dictionary entries
  61  * may only appear nested inside of arrays.
  62  *
  63  * Just as in D-Bus, GVariant types are described with strings (&quot;type
  64  * strings&quot;).  Subject to the differences mentioned above, these strings
  65  * are of the same form as those found in DBus.  Note, however: D-Bus
  66  * always works in terms of messages and therefore individual type
  67  * strings appear nowhere in its interface.  Instead, &quot;signatures&quot;
  68  * are a concatenation of the strings of the type of each argument in a
  69  * message.  GVariant deals with single values directly so GVariant type
  70  * strings always describe the type of exactly one value.  This means
  71  * that a D-Bus signature string is generally not a valid GVariant type
  72  * string -- except in the case that it is the signature of a message
  73  * containing exactly one argument.
  74  *
  75  * An indefinite type is similar in spirit to what may be called an
  76  * abstract type in other type systems.  No value can exist that has an
  77  * indefinite type as its type, but values can exist that have types
  78  * that are subtypes of indefinite types.  That is to say,
  79  * g_variant_get_type() will never return an indefinite type, but
  80  * calling g_variant_is_of_type() with an indefinite type may return
  81  * %TRUE.  For example, you cannot have a value that represents &quot;an
  82  * array of no particular type&quot;, but you can have an &quot;array of integers&quot;
  83  * which certainly matches the type of &quot;an array of no particular type&quot;,
  84  * since &quot;array of integers&quot; is a subtype of &quot;array of no particular
  85  * type&quot;.
  86  *
  87  * This is similar to how instances of abstract classes may not
  88  * directly exist in other type systems, but instances of their
  89  * non-abstract subtypes may.  For example, in GTK, no object that has
  90  * the type of #GtkBin can exist (since #GtkBin is an abstract class),
  91  * but a #GtkWindow can certainly be instantiated, and you would say
  92  * that the #GtkWindow is a #GtkBin (since #GtkWindow is a subclass of
  93  * #GtkBin).
  94  *
  95  * ## GVariant Type Strings
  96  *
  97  * A GVariant type string can be any of the following:
  98  *
  99  * - any basic type string (listed below)
 100  *
 101  * - &quot;v&quot;, &quot;r&quot; or &quot;*&quot;
 102  *
 103  * - one of the characters &#39;a&#39; or &#39;m&#39;, followed by another type string
 104  *
 105  * - the character &#39;(&#39;, followed by a concatenation of zero or more other
 106  *   type strings, followed by the character &#39;)&#39;
 107  *
 108  * - the character &#39;{&#39;, followed by a basic type string (see below),
 109  *   followed by another type string, followed by the character &#39;}&#39;
 110  *
 111  * A basic type string describes a basic type (as per
 112  * g_variant_type_is_basic()) and is always a single character in length.
 113  * The valid basic type strings are &quot;b&quot;, &quot;y&quot;, &quot;n&quot;, &quot;q&quot;, &quot;i&quot;, &quot;u&quot;, &quot;x&quot;, &quot;t&quot;,
 114  * &quot;h&quot;, &quot;d&quot;, &quot;s&quot;, &quot;o&quot;, &quot;g&quot; and &quot;?&quot;.
 115  *
 116  * The above definition is recursive to arbitrary depth. &quot;aaaaai&quot; and
 117  * &quot;(ui(nq((y)))s)&quot; are both valid type strings, as is
 118  * &quot;a(aa(ui)(qna{ya(yd)}))&quot;. In order to not hit memory limits, #GVariant
 119  * imposes a limit on recursion depth of 65 nested containers. This is the
 120  * limit in the D-Bus specification (64) plus one to allow a #GDBusMessage to
 121  * be nested in a top-level tuple.
 122  *
 123  * The meaning of each of the characters is as follows:
 124  * - `b`: the type string of %G_VARIANT_TYPE_BOOLEAN; a boolean value.
 125  * - `y`: the type string of %G_VARIANT_TYPE_BYTE; a byte.
 126  * - `n`: the type string of %G_VARIANT_TYPE_INT16; a signed 16 bit integer.
 127  * - `q`: the type string of %G_VARIANT_TYPE_UINT16; an unsigned 16 bit integer.
 128  * - `i`: the type string of %G_VARIANT_TYPE_INT32; a signed 32 bit integer.
 129  * - `u`: the type string of %G_VARIANT_TYPE_UINT32; an unsigned 32 bit integer.
 130  * - `x`: the type string of %G_VARIANT_TYPE_INT64; a signed 64 bit integer.
 131  * - `t`: the type string of %G_VARIANT_TYPE_UINT64; an unsigned 64 bit integer.
 132  * - `h`: the type string of %G_VARIANT_TYPE_HANDLE; a signed 32 bit value
 133  *   that, by convention, is used as an index into an array of file
 134  *   descriptors that are sent alongside a D-Bus message.
 135  * - `d`: the type string of %G_VARIANT_TYPE_DOUBLE; a double precision
 136  *   floating point value.
 137  * - `s`: the type string of %G_VARIANT_TYPE_STRING; a string.
 138  * - `o`: the type string of %G_VARIANT_TYPE_OBJECT_PATH; a string in the form
 139  *   of a D-Bus object path.
 140  * - `g`: the type string of %G_VARIANT_TYPE_SIGNATURE; a string in the form of
 141  *   a D-Bus type signature.
 142  * - `?`: the type string of %G_VARIANT_TYPE_BASIC; an indefinite type that
 143  *   is a supertype of any of the basic types.
 144  * - `v`: the type string of %G_VARIANT_TYPE_VARIANT; a container type that
 145  *   contain any other type of value.
 146  * - `a`: used as a prefix on another type string to mean an array of that
 147  *   type; the type string &quot;ai&quot;, for example, is the type of an array of
 148  *   signed 32-bit integers.
 149  * - `m`: used as a prefix on another type string to mean a &quot;maybe&quot;, or
 150  *   &quot;nullable&quot;, version of that type; the type string &quot;ms&quot;, for example,
 151  *   is the type of a value that maybe contains a string, or maybe contains
 152  *   nothing.
 153  * - `()`: used to enclose zero or more other concatenated type strings to
 154  *   create a tuple type; the type string &quot;(is)&quot;, for example, is the type of
 155  *   a pair of an integer and a string.
 156  * - `r`: the type string of %G_VARIANT_TYPE_TUPLE; an indefinite type that is
 157  *   a supertype of any tuple type, regardless of the number of items.
 158  * - `{}`: used to enclose a basic type string concatenated with another type
 159  *   string to create a dictionary entry type, which usually appears inside of
 160  *   an array to form a dictionary; the type string &quot;a{sd}&quot;, for example, is
 161  *   the type of a dictionary that maps strings to double precision floating
 162  *   point values.
 163  *
 164  *   The first type (the basic type) is the key type and the second type is
 165  *   the value type. The reason that the first type is restricted to being a
 166  *   basic type is so that it can easily be hashed.
 167  * - `*`: the type string of %G_VARIANT_TYPE_ANY; the indefinite type that is
 168  *   a supertype of all types.  Note that, as with all type strings, this
 169  *   character represents exactly one type. It cannot be used inside of tuples
 170  *   to mean &quot;any number of items&quot;.
 171  *
 172  * Any type string of a container that contains an indefinite type is,
 173  * itself, an indefinite type. For example, the type string &quot;a*&quot;
 174  * (corresponding to %G_VARIANT_TYPE_ARRAY) is an indefinite type
 175  * that is a supertype of every array type. &quot;(*s)&quot; is a supertype
 176  * of all tuples that contain exactly two items where the second
 177  * item is a string.
 178  *
 179  * &quot;a{?*}&quot; is an indefinite type that is a supertype of all arrays
 180  * containing dictionary entries where the key is any basic type and
 181  * the value is any type at all.  This is, by definition, a dictionary,
 182  * so this type string corresponds to %G_VARIANT_TYPE_DICTIONARY. Note
 183  * that, due to the restriction that the key of a dictionary entry must
 184  * be a basic type, &quot;{**}&quot; is not a valid type string.
 185  */
 186 
 187 
 188 static gboolean
 189 g_variant_type_check (const GVariantType *type)
 190 {
 191   if (type == NULL)
 192     return FALSE;
 193 
 194 #if 0
 195   return g_variant_type_string_scan ((const gchar *) type, NULL, NULL);
 196 #else
 197   return TRUE;
 198 #endif
 199 }
 200 
 201 static gboolean
 202 variant_type_string_scan_internal (const gchar  *string,
<a name="2" id="anc2"></a><span class="line-modified"> 203                                    const gchar  *limit,</span>
 204                                    const gchar **endptr,
 205                                    gsize        *depth,
 206                                    gsize         depth_limit)
 207 {
 208   gsize max_depth = 0, child_depth;
 209 
 210   g_return_val_if_fail (string != NULL, FALSE);
 211 
 212   if (string == limit || *string == &#39;\0&#39;)
 213     return FALSE;
 214 
 215   switch (*string++)
 216     {
 217     case &#39;(&#39;:
 218       while (string == limit || *string != &#39;)&#39;)
 219         {
 220           if (depth_limit == 0 ||
 221               !variant_type_string_scan_internal (string, limit, &amp;string,
 222                                                   &amp;child_depth,
 223                                                   depth_limit - 1))
<a name="3" id="anc3"></a><span class="line-modified"> 224             return FALSE;</span>
 225 
 226           max_depth = MAX (max_depth, child_depth + 1);
 227         }
 228 
 229       string++;
 230       break;
 231 
 232     case &#39;{&#39;:
 233       if (depth_limit == 0 ||
 234           string == limit || *string == &#39;\0&#39; ||                                  /* { */
 235           !strchr (&quot;bynqihuxtdsog?&quot;, *string++) ||                               /* key */
 236           !variant_type_string_scan_internal (string, limit, &amp;string,
 237                                               &amp;child_depth, depth_limit - 1) ||  /* value */
 238           string == limit || *string++ != &#39;}&#39;)                                   /* } */
 239         return FALSE;
 240 
 241       max_depth = MAX (max_depth, child_depth + 1);
 242       break;
 243 
 244     case &#39;m&#39;: case &#39;a&#39;:
 245       if (depth_limit == 0 ||
 246           !variant_type_string_scan_internal (string, limit, &amp;string,
 247                                               &amp;child_depth, depth_limit - 1))
 248         return FALSE;
 249 
 250       max_depth = MAX (max_depth, child_depth + 1);
 251       break;
 252 
 253     case &#39;b&#39;: case &#39;y&#39;: case &#39;n&#39;: case &#39;q&#39;: case &#39;i&#39;: case &#39;u&#39;:
 254     case &#39;x&#39;: case &#39;t&#39;: case &#39;d&#39;: case &#39;s&#39;: case &#39;o&#39;: case &#39;g&#39;:
 255     case &#39;v&#39;: case &#39;r&#39;: case &#39;*&#39;: case &#39;?&#39;: case &#39;h&#39;:
 256       max_depth = MAX (max_depth, 1);
 257       break;
 258 
 259     default:
 260       return FALSE;
 261     }
 262 
 263   if (endptr != NULL)
 264     *endptr = string;
 265   if (depth != NULL)
 266     *depth = max_depth;
 267 
 268   return TRUE;
 269 }
 270 
 271 /**
 272  * g_variant_type_string_scan:
 273  * @string: a pointer to any string
 274  * @limit: (nullable): the end of @string, or %NULL
 275  * @endptr: (out) (optional): location to store the end pointer, or %NULL
 276  *
 277  * Scan for a single complete and valid GVariant type string in @string.
 278  * The memory pointed to by @limit (or bytes beyond it) is never
 279  * accessed.
 280  *
 281  * If a valid type string is found, @endptr is updated to point to the
 282  * first character past the end of the string that was found and %TRUE
 283  * is returned.
 284  *
 285  * If there is no valid type string starting at @string, or if the type
 286  * string does not end before @limit then %FALSE is returned.
 287  *
 288  * For the simple case of checking if a string is a valid type string,
 289  * see g_variant_type_string_is_valid().
 290  *
 291  * Returns: %TRUE if a valid type string was found
 292  *
 293  * Since: 2.24
 294  **/
 295 gboolean
 296 g_variant_type_string_scan (const gchar  *string,
 297                             const gchar  *limit,
 298                             const gchar **endptr)
 299 {
 300   return variant_type_string_scan_internal (string, limit, endptr, NULL,
 301                                             G_VARIANT_MAX_RECURSION_DEPTH);
 302 }
 303 
 304 /* &lt; private &gt;
 305  * g_variant_type_string_get_depth_:
 306  * @type_string: a pointer to any string
 307  *
 308  * Get the maximum depth of the nested types in @type_string. A basic type will
 309  * return depth 1, and a container type will return a greater value. The depth
 310  * of a tuple is 1 plus the depth of its deepest child type.
 311  *
 312  * If @type_string is not a valid #GVariant type string, 0 will be returned.
 313  *
 314  * Returns: depth of @type_string, or 0 on error
<a name="4" id="anc4"></a><span class="line-modified"> 315  * Since: 2.60</span>
 316  */
 317 gsize
 318 g_variant_type_string_get_depth_ (const gchar *type_string)
 319 {
 320   const gchar *endptr;
 321   gsize depth = 0;
 322 
 323   g_return_val_if_fail (type_string != NULL, 0);
 324 
 325   if (!variant_type_string_scan_internal (type_string, NULL, &amp;endptr, &amp;depth,
 326                                           G_VARIANT_MAX_RECURSION_DEPTH) ||
 327       *endptr != &#39;\0&#39;)
 328     return 0;
 329 
 330   return depth;
 331 }
 332 
 333 /**
 334  * g_variant_type_string_is_valid:
 335  * @type_string: a pointer to any string
 336  *
 337  * Checks if @type_string is a valid GVariant type string.  This call is
 338  * equivalent to calling g_variant_type_string_scan() and confirming
 339  * that the following character is a nul terminator.
 340  *
 341  * Returns: %TRUE if @type_string is exactly one valid type string
 342  *
 343  * Since 2.24
 344  **/
 345 gboolean
 346 g_variant_type_string_is_valid (const gchar *type_string)
 347 {
 348   const gchar *endptr;
 349 
 350   g_return_val_if_fail (type_string != NULL, FALSE);
 351 
 352   if (!g_variant_type_string_scan (type_string, NULL, &amp;endptr))
 353     return FALSE;
 354 
 355   return *endptr == &#39;\0&#39;;
 356 }
 357 
 358 /**
 359  * g_variant_type_free:
 360  * @type: (nullable): a #GVariantType, or %NULL
 361  *
 362  * Frees a #GVariantType that was allocated with
 363  * g_variant_type_copy(), g_variant_type_new() or one of the container
 364  * type constructor functions.
 365  *
 366  * In the case that @type is %NULL, this function does nothing.
 367  *
 368  * Since 2.24
 369  **/
 370 void
 371 g_variant_type_free (GVariantType *type)
 372 {
 373   g_return_if_fail (type == NULL || g_variant_type_check (type));
 374 
 375   g_free (type);
 376 }
 377 
 378 /**
 379  * g_variant_type_copy:
 380  * @type: a #GVariantType
 381  *
 382  * Makes a copy of a #GVariantType.  It is appropriate to call
 383  * g_variant_type_free() on the return value.  @type may not be %NULL.
 384  *
 385  * Returns: (transfer full): a new #GVariantType
 386  *
 387  * Since 2.24
 388  **/
 389 GVariantType *
 390 g_variant_type_copy (const GVariantType *type)
 391 {
 392   gsize length;
 393   gchar *new;
 394 
 395   g_return_val_if_fail (g_variant_type_check (type), NULL);
 396 
 397   length = g_variant_type_get_string_length (type);
 398   new = g_malloc (length + 1);
 399 #ifdef GSTREAMER_LITE
 400   if (new == NULL)
 401       return NULL;
 402 #endif // GSTREAMER_LITE
 403 
 404   memcpy (new, type, length);
 405   new[length] = &#39;\0&#39;;
 406 
 407   return (GVariantType *) new;
 408 }
 409 
 410 /**
 411  * g_variant_type_new:
 412  * @type_string: a valid GVariant type string
 413  *
 414  * Creates a new #GVariantType corresponding to the type string given
 415  * by @type_string.  It is appropriate to call g_variant_type_free() on
 416  * the return value.
 417  *
 418  * It is a programmer error to call this function with an invalid type
 419  * string.  Use g_variant_type_string_is_valid() if you are unsure.
 420  *
 421  * Returns: (transfer full): a new #GVariantType
 422  *
 423  * Since: 2.24
 424  */
 425 GVariantType *
 426 g_variant_type_new (const gchar *type_string)
 427 {
 428   g_return_val_if_fail (type_string != NULL, NULL);
 429 
 430   return g_variant_type_copy (G_VARIANT_TYPE (type_string));
 431 }
 432 
 433 /**
 434  * g_variant_type_get_string_length:
 435  * @type: a #GVariantType
 436  *
 437  * Returns the length of the type string corresponding to the given
 438  * @type.  This function must be used to determine the valid extent of
 439  * the memory region returned by g_variant_type_peek_string().
 440  *
 441  * Returns: the length of the corresponding type string
 442  *
 443  * Since 2.24
 444  **/
 445 gsize
 446 g_variant_type_get_string_length (const GVariantType *type)
 447 {
 448   const gchar *type_string = (const gchar *) type;
 449   gint brackets = 0;
 450   gsize index = 0;
 451 
 452   g_return_val_if_fail (g_variant_type_check (type), 0);
 453 
 454   do
 455     {
 456       while (type_string[index] == &#39;a&#39; || type_string[index] == &#39;m&#39;)
 457         index++;
 458 
 459       if (type_string[index] == &#39;(&#39; || type_string[index] == &#39;{&#39;)
 460         brackets++;
 461 
 462       else if (type_string[index] == &#39;)&#39; || type_string[index] == &#39;}&#39;)
 463         brackets--;
 464 
 465       index++;
 466     }
 467   while (brackets);
 468 
 469   return index;
 470 }
 471 
 472 /*
 473   This function is not introspectable, it returns something that
 474   is not an array and neither a string
 475 */
 476 /**
 477  * g_variant_type_peek_string: (skip)
 478  * @type: a #GVariantType
 479  *
 480  * Returns the type string corresponding to the given @type.  The
 481  * result is not nul-terminated; in order to determine its length you
 482  * must call g_variant_type_get_string_length().
 483  *
 484  * To get a nul-terminated string, see g_variant_type_dup_string().
 485  *
 486  * Returns: the corresponding type string (not nul-terminated)
 487  *
 488  * Since 2.24
 489  **/
 490 const gchar *
 491 g_variant_type_peek_string (const GVariantType *type)
 492 {
 493   g_return_val_if_fail (g_variant_type_check (type), NULL);
 494 
 495   return (const gchar *) type;
 496 }
 497 
 498 /**
 499  * g_variant_type_dup_string:
 500  * @type: a #GVariantType
 501  *
 502  * Returns a newly-allocated copy of the type string corresponding to
 503  * @type.  The returned string is nul-terminated.  It is appropriate to
 504  * call g_free() on the return value.
 505  *
 506  * Returns: (transfer full): the corresponding type string
 507  *
 508  * Since 2.24
 509  **/
 510 gchar *
 511 g_variant_type_dup_string (const GVariantType *type)
 512 {
 513   g_return_val_if_fail (g_variant_type_check (type), NULL);
 514 
 515   return g_strndup (g_variant_type_peek_string (type),
 516                     g_variant_type_get_string_length (type));
 517 }
 518 
 519 /**
 520  * g_variant_type_is_definite:
 521  * @type: a #GVariantType
 522  *
 523  * Determines if the given @type is definite (ie: not indefinite).
 524  *
 525  * A type is definite if its type string does not contain any indefinite
 526  * type characters (&#39;*&#39;, &#39;?&#39;, or &#39;r&#39;).
 527  *
 528  * A #GVariant instance may not have an indefinite type, so calling
 529  * this function on the result of g_variant_get_type() will always
 530  * result in %TRUE being returned.  Calling this function on an
 531  * indefinite type like %G_VARIANT_TYPE_ARRAY, however, will result in
 532  * %FALSE being returned.
 533  *
 534  * Returns: %TRUE if @type is definite
 535  *
 536  * Since 2.24
 537  **/
 538 gboolean
 539 g_variant_type_is_definite (const GVariantType *type)
 540 {
 541   const gchar *type_string;
 542   gsize type_length;
 543   gsize i;
 544 
 545   g_return_val_if_fail (g_variant_type_check (type), FALSE);
 546 
 547   type_length = g_variant_type_get_string_length (type);
 548   type_string = g_variant_type_peek_string (type);
 549 
 550   for (i = 0; i &lt; type_length; i++)
 551     if (type_string[i] == &#39;*&#39; ||
 552         type_string[i] == &#39;?&#39; ||
 553         type_string[i] == &#39;r&#39;)
 554       return FALSE;
 555 
 556   return TRUE;
 557 }
 558 
 559 /**
 560  * g_variant_type_is_container:
 561  * @type: a #GVariantType
 562  *
 563  * Determines if the given @type is a container type.
 564  *
 565  * Container types are any array, maybe, tuple, or dictionary
 566  * entry types plus the variant type.
 567  *
 568  * This function returns %TRUE for any indefinite type for which every
 569  * definite subtype is a container -- %G_VARIANT_TYPE_ARRAY, for
 570  * example.
 571  *
 572  * Returns: %TRUE if @type is a container type
 573  *
 574  * Since 2.24
 575  **/
 576 gboolean
 577 g_variant_type_is_container (const GVariantType *type)
 578 {
 579   gchar first_char;
 580 
 581   g_return_val_if_fail (g_variant_type_check (type), FALSE);
 582 
 583   first_char = g_variant_type_peek_string (type)[0];
 584   switch (first_char)
 585   {
 586     case &#39;a&#39;:
 587     case &#39;m&#39;:
 588     case &#39;r&#39;:
 589     case &#39;(&#39;:
 590     case &#39;{&#39;:
 591     case &#39;v&#39;:
 592       return TRUE;
 593 
 594     default:
 595       return FALSE;
 596   }
 597 }
 598 
 599 /**
 600  * g_variant_type_is_basic:
 601  * @type: a #GVariantType
 602  *
 603  * Determines if the given @type is a basic type.
 604  *
 605  * Basic types are booleans, bytes, integers, doubles, strings, object
 606  * paths and signatures.
 607  *
 608  * Only a basic type may be used as the key of a dictionary entry.
 609  *
 610  * This function returns %FALSE for all indefinite types except
 611  * %G_VARIANT_TYPE_BASIC.
 612  *
 613  * Returns: %TRUE if @type is a basic type
 614  *
 615  * Since 2.24
 616  **/
 617 gboolean
 618 g_variant_type_is_basic (const GVariantType *type)
 619 {
 620   gchar first_char;
 621 
 622   g_return_val_if_fail (g_variant_type_check (type), FALSE);
 623 
 624   first_char = g_variant_type_peek_string (type)[0];
 625   switch (first_char)
 626   {
 627     case &#39;b&#39;:
 628     case &#39;y&#39;:
 629     case &#39;n&#39;:
 630     case &#39;q&#39;:
 631     case &#39;i&#39;:
 632     case &#39;h&#39;:
 633     case &#39;u&#39;:
 634     case &#39;t&#39;:
 635     case &#39;x&#39;:
 636     case &#39;d&#39;:
 637     case &#39;s&#39;:
 638     case &#39;o&#39;:
 639     case &#39;g&#39;:
 640     case &#39;?&#39;:
 641       return TRUE;
 642 
 643     default:
 644       return FALSE;
 645   }
 646 }
 647 
 648 /**
 649  * g_variant_type_is_maybe:
 650  * @type: a #GVariantType
 651  *
 652  * Determines if the given @type is a maybe type.  This is true if the
 653  * type string for @type starts with an &#39;m&#39;.
 654  *
 655  * This function returns %TRUE for any indefinite type for which every
 656  * definite subtype is a maybe type -- %G_VARIANT_TYPE_MAYBE, for
 657  * example.
 658  *
 659  * Returns: %TRUE if @type is a maybe type
 660  *
 661  * Since 2.24
 662  **/
 663 gboolean
 664 g_variant_type_is_maybe (const GVariantType *type)
 665 {
 666   g_return_val_if_fail (g_variant_type_check (type), FALSE);
 667 
 668   return g_variant_type_peek_string (type)[0] == &#39;m&#39;;
 669 }
 670 
 671 /**
 672  * g_variant_type_is_array:
 673  * @type: a #GVariantType
 674  *
 675  * Determines if the given @type is an array type.  This is true if the
 676  * type string for @type starts with an &#39;a&#39;.
 677  *
 678  * This function returns %TRUE for any indefinite type for which every
 679  * definite subtype is an array type -- %G_VARIANT_TYPE_ARRAY, for
 680  * example.
 681  *
 682  * Returns: %TRUE if @type is an array type
 683  *
 684  * Since 2.24
 685  **/
 686 gboolean
 687 g_variant_type_is_array (const GVariantType *type)
 688 {
 689   g_return_val_if_fail (g_variant_type_check (type), FALSE);
 690 
 691   return g_variant_type_peek_string (type)[0] == &#39;a&#39;;
 692 }
 693 
 694 /**
 695  * g_variant_type_is_tuple:
 696  * @type: a #GVariantType
 697  *
 698  * Determines if the given @type is a tuple type.  This is true if the
 699  * type string for @type starts with a &#39;(&#39; or if @type is
 700  * %G_VARIANT_TYPE_TUPLE.
 701  *
 702  * This function returns %TRUE for any indefinite type for which every
 703  * definite subtype is a tuple type -- %G_VARIANT_TYPE_TUPLE, for
 704  * example.
 705  *
 706  * Returns: %TRUE if @type is a tuple type
 707  *
 708  * Since 2.24
 709  **/
 710 gboolean
 711 g_variant_type_is_tuple (const GVariantType *type)
 712 {
 713   gchar type_char;
 714 
 715   g_return_val_if_fail (g_variant_type_check (type), FALSE);
 716 
 717   type_char = g_variant_type_peek_string (type)[0];
 718   return type_char == &#39;r&#39; || type_char == &#39;(&#39;;
 719 }
 720 
 721 /**
 722  * g_variant_type_is_dict_entry:
 723  * @type: a #GVariantType
 724  *
 725  * Determines if the given @type is a dictionary entry type.  This is
 726  * true if the type string for @type starts with a &#39;{&#39;.
 727  *
 728  * This function returns %TRUE for any indefinite type for which every
 729  * definite subtype is a dictionary entry type --
 730  * %G_VARIANT_TYPE_DICT_ENTRY, for example.
 731  *
 732  * Returns: %TRUE if @type is a dictionary entry type
 733  *
 734  * Since 2.24
 735  **/
 736 gboolean
 737 g_variant_type_is_dict_entry (const GVariantType *type)
 738 {
 739   g_return_val_if_fail (g_variant_type_check (type), FALSE);
 740 
 741   return g_variant_type_peek_string (type)[0] == &#39;{&#39;;
 742 }
 743 
 744 /**
 745  * g_variant_type_is_variant:
 746  * @type: a #GVariantType
 747  *
 748  * Determines if the given @type is the variant type.
 749  *
 750  * Returns: %TRUE if @type is the variant type
 751  *
 752  * Since 2.24
 753  **/
 754 gboolean
 755 g_variant_type_is_variant (const GVariantType *type)
 756 {
 757   g_return_val_if_fail (g_variant_type_check (type), FALSE);
 758 
 759   return g_variant_type_peek_string (type)[0] == &#39;v&#39;;
 760 }
 761 
 762 /**
 763  * g_variant_type_hash:
 764  * @type: (type GVariantType): a #GVariantType
 765  *
 766  * Hashes @type.
 767  *
 768  * The argument type of @type is only #gconstpointer to allow use with
 769  * #GHashTable without function pointer casting.  A valid
 770  * #GVariantType must be provided.
 771  *
 772  * Returns: the hash value
 773  *
 774  * Since 2.24
 775  **/
 776 guint
 777 g_variant_type_hash (gconstpointer type)
 778 {
 779   const gchar *type_string;
 780   guint value = 0;
 781   gsize length;
 782   gsize i;
 783 
 784   g_return_val_if_fail (g_variant_type_check (type), 0);
 785 
 786   type_string = g_variant_type_peek_string (type);
 787   length = g_variant_type_get_string_length (type);
 788 
 789   for (i = 0; i &lt; length; i++)
 790     value = (value &lt;&lt; 5) - value + type_string[i];
 791 
 792   return value;
 793 }
 794 
 795 /**
 796  * g_variant_type_equal:
 797  * @type1: (type GVariantType): a #GVariantType
 798  * @type2: (type GVariantType): a #GVariantType
 799  *
 800  * Compares @type1 and @type2 for equality.
 801  *
 802  * Only returns %TRUE if the types are exactly equal.  Even if one type
 803  * is an indefinite type and the other is a subtype of it, %FALSE will
 804  * be returned if they are not exactly equal.  If you want to check for
 805  * subtypes, use g_variant_type_is_subtype_of().
 806  *
 807  * The argument types of @type1 and @type2 are only #gconstpointer to
 808  * allow use with #GHashTable without function pointer casting.  For
 809  * both arguments, a valid #GVariantType must be provided.
 810  *
 811  * Returns: %TRUE if @type1 and @type2 are exactly equal
 812  *
 813  * Since 2.24
 814  **/
 815 gboolean
 816 g_variant_type_equal (gconstpointer type1,
 817                       gconstpointer type2)
 818 {
 819   const gchar *string1, *string2;
 820   gsize size1, size2;
 821 
 822   g_return_val_if_fail (g_variant_type_check (type1), FALSE);
 823   g_return_val_if_fail (g_variant_type_check (type2), FALSE);
 824 
 825   if (type1 == type2)
 826     return TRUE;
 827 
 828   size1 = g_variant_type_get_string_length (type1);
 829   size2 = g_variant_type_get_string_length (type2);
 830 
 831   if (size1 != size2)
 832     return FALSE;
 833 
 834   string1 = g_variant_type_peek_string (type1);
 835   string2 = g_variant_type_peek_string (type2);
 836 
 837   return memcmp (string1, string2, size1) == 0;
 838 }
 839 
 840 /**
 841  * g_variant_type_is_subtype_of:
 842  * @type: a #GVariantType
 843  * @supertype: a #GVariantType
 844  *
 845  * Checks if @type is a subtype of @supertype.
 846  *
 847  * This function returns %TRUE if @type is a subtype of @supertype.  All
 848  * types are considered to be subtypes of themselves.  Aside from that,
 849  * only indefinite types can have subtypes.
 850  *
 851  * Returns: %TRUE if @type is a subtype of @supertype
 852  *
 853  * Since 2.24
 854  **/
 855 gboolean
 856 g_variant_type_is_subtype_of (const GVariantType *type,
 857                               const GVariantType *supertype)
 858 {
 859   const gchar *supertype_string;
 860   const gchar *supertype_end;
 861   const gchar *type_string;
 862 
 863   g_return_val_if_fail (g_variant_type_check (type), FALSE);
 864   g_return_val_if_fail (g_variant_type_check (supertype), FALSE);
 865 
 866   supertype_string = g_variant_type_peek_string (supertype);
 867   type_string = g_variant_type_peek_string (type);
 868 
 869   supertype_end = supertype_string +
 870                   g_variant_type_get_string_length (supertype);
 871 
 872   /* we know that type and supertype are both well-formed, so it&#39;s
 873    * safe to treat this merely as a text processing problem.
 874    */
 875   while (supertype_string &lt; supertype_end)
 876     {
 877       char supertype_char = *supertype_string++;
 878 
 879       if (supertype_char == *type_string)
 880         type_string++;
 881 
 882       else if (*type_string == &#39;)&#39;)
 883         return FALSE;
 884 
 885       else
 886         {
 887           const GVariantType *target_type = (GVariantType *) type_string;
 888 
 889           switch (supertype_char)
 890             {
 891             case &#39;r&#39;:
 892               if (!g_variant_type_is_tuple (target_type))
 893                 return FALSE;
 894               break;
 895 
 896             case &#39;*&#39;:
 897               break;
 898 
 899             case &#39;?&#39;:
 900               if (!g_variant_type_is_basic (target_type))
 901                 return FALSE;
 902               break;
 903 
 904             default:
 905               return FALSE;
 906             }
 907 
 908           type_string += g_variant_type_get_string_length (target_type);
 909         }
 910     }
 911 
 912   return TRUE;
 913 }
 914 
 915 /**
 916  * g_variant_type_element:
 917  * @type: an array or maybe #GVariantType
 918  *
 919  * Determines the element type of an array or maybe type.
 920  *
 921  * This function may only be used with array or maybe types.
 922  *
 923  * Returns: (transfer none): the element type of @type
 924  *
 925  * Since 2.24
 926  **/
 927 const GVariantType *
 928 g_variant_type_element (const GVariantType *type)
 929 {
 930   const gchar *type_string;
 931 
 932   g_return_val_if_fail (g_variant_type_check (type), NULL);
 933 
 934   type_string = g_variant_type_peek_string (type);
 935 
 936   g_assert (type_string[0] == &#39;a&#39; || type_string[0] == &#39;m&#39;);
 937 
 938   return (const GVariantType *) &amp;type_string[1];
 939 }
 940 
 941 /**
 942  * g_variant_type_first:
 943  * @type: a tuple or dictionary entry #GVariantType
 944  *
 945  * Determines the first item type of a tuple or dictionary entry
 946  * type.
 947  *
 948  * This function may only be used with tuple or dictionary entry types,
 949  * but must not be used with the generic tuple type
 950  * %G_VARIANT_TYPE_TUPLE.
 951  *
 952  * In the case of a dictionary entry type, this returns the type of
 953  * the key.
 954  *
 955  * %NULL is returned in case of @type being %G_VARIANT_TYPE_UNIT.
 956  *
 957  * This call, together with g_variant_type_next() provides an iterator
 958  * interface over tuple and dictionary entry types.
 959  *
 960  * Returns: (transfer none): the first item type of @type, or %NULL
 961  *
 962  * Since 2.24
 963  **/
 964 const GVariantType *
 965 g_variant_type_first (const GVariantType *type)
 966 {
 967   const gchar *type_string;
 968 
 969   g_return_val_if_fail (g_variant_type_check (type), NULL);
 970 
 971   type_string = g_variant_type_peek_string (type);
 972   g_assert (type_string[0] == &#39;(&#39; || type_string[0] == &#39;{&#39;);
 973 
 974   if (type_string[1] == &#39;)&#39;)
 975     return NULL;
 976 
 977   return (const GVariantType *) &amp;type_string[1];
 978 }
 979 
 980 /**
 981  * g_variant_type_next:
 982  * @type: a #GVariantType from a previous call
 983  *
 984  * Determines the next item type of a tuple or dictionary entry
 985  * type.
 986  *
 987  * @type must be the result of a previous call to
 988  * g_variant_type_first() or g_variant_type_next().
 989  *
 990  * If called on the key type of a dictionary entry then this call
 991  * returns the value type.  If called on the value type of a dictionary
 992  * entry then this call returns %NULL.
 993  *
 994  * For tuples, %NULL is returned when @type is the last item in a tuple.
 995  *
 996  * Returns: (transfer none): the next #GVariantType after @type, or %NULL
 997  *
 998  * Since 2.24
 999  **/
1000 const GVariantType *
1001 g_variant_type_next (const GVariantType *type)
1002 {
1003   const gchar *type_string;
1004 
1005   g_return_val_if_fail (g_variant_type_check (type), NULL);
1006 
1007   type_string = g_variant_type_peek_string (type);
1008   type_string += g_variant_type_get_string_length (type);
1009 
1010   if (*type_string == &#39;)&#39; || *type_string == &#39;}&#39;)
1011     return NULL;
1012 
1013   return (const GVariantType *) type_string;
1014 }
1015 
1016 /**
1017  * g_variant_type_n_items:
1018  * @type: a tuple or dictionary entry #GVariantType
1019  *
1020  * Determines the number of items contained in a tuple or
1021  * dictionary entry type.
1022  *
1023  * This function may only be used with tuple or dictionary entry types,
1024  * but must not be used with the generic tuple type
1025  * %G_VARIANT_TYPE_TUPLE.
1026  *
1027  * In the case of a dictionary entry type, this function will always
1028  * return 2.
1029  *
1030  * Returns: the number of items in @type
1031  *
1032  * Since 2.24
1033  **/
1034 gsize
1035 g_variant_type_n_items (const GVariantType *type)
1036 {
1037   gsize count = 0;
1038 
1039   g_return_val_if_fail (g_variant_type_check (type), 0);
1040 
1041   for (type = g_variant_type_first (type);
1042        type;
1043        type = g_variant_type_next (type))
1044     count++;
1045 
1046   return count;
1047 }
1048 
1049 /**
1050  * g_variant_type_key:
1051  * @type: a dictionary entry #GVariantType
1052  *
1053  * Determines the key type of a dictionary entry type.
1054  *
1055  * This function may only be used with a dictionary entry type.  Other
1056  * than the additional restriction, this call is equivalent to
1057  * g_variant_type_first().
1058  *
1059  * Returns: (transfer none): the key type of the dictionary entry
1060  *
1061  * Since 2.24
1062  **/
1063 const GVariantType *
1064 g_variant_type_key (const GVariantType *type)
1065 {
1066   const gchar *type_string;
1067 
1068   g_return_val_if_fail (g_variant_type_check (type), NULL);
1069 
1070   type_string = g_variant_type_peek_string (type);
1071   g_assert (type_string[0] == &#39;{&#39;);
1072 
1073   return (const GVariantType *) &amp;type_string[1];
1074 }
1075 
1076 /**
1077  * g_variant_type_value:
1078  * @type: a dictionary entry #GVariantType
1079  *
1080  * Determines the value type of a dictionary entry type.
1081  *
1082  * This function may only be used with a dictionary entry type.
1083  *
1084  * Returns: (transfer none): the value type of the dictionary entry
1085  *
1086  * Since 2.24
1087  **/
1088 const GVariantType *
1089 g_variant_type_value (const GVariantType *type)
1090 {
<a name="5" id="anc5"></a><span class="line-added">1091 #ifndef G_DISABLE_ASSERT</span>
1092   const gchar *type_string;
<a name="6" id="anc6"></a><span class="line-added">1093 #endif</span>
1094 
1095   g_return_val_if_fail (g_variant_type_check (type), NULL);
1096 
<a name="7" id="anc7"></a><span class="line-added">1097 #ifndef G_DISABLE_ASSERT</span>
1098   type_string = g_variant_type_peek_string (type);
1099   g_assert (type_string[0] == &#39;{&#39;);
<a name="8" id="anc8"></a><span class="line-added">1100 #endif</span>
1101 
1102   return g_variant_type_next (g_variant_type_key (type));
1103 }
1104 
1105 /**
1106  * g_variant_type_new_tuple:
1107  * @items: (array length=length): an array of #GVariantTypes, one for each item
1108  * @length: the length of @items, or -1
1109  *
1110  * Constructs a new tuple type, from @items.
1111  *
1112  * @length is the number of items in @items, or -1 to indicate that
1113  * @items is %NULL-terminated.
1114  *
1115  * It is appropriate to call g_variant_type_free() on the return value.
1116  *
1117  * Returns: (transfer full): a new tuple #GVariantType
1118  *
1119  * Since 2.24
1120  **/
1121 static GVariantType *
1122 g_variant_type_new_tuple_slow (const GVariantType * const *items,
1123                                gint                        length)
1124 {
1125   /* the &quot;slow&quot; version is needed in case the static buffer of 1024
1126    * bytes is exceeded when running the normal version.  this will
1127    * happen only in truly insane code, so it can be slow.
1128    */
1129   GString *string;
1130   gint i;
1131 
1132   string = g_string_new (&quot;(&quot;);
1133   for (i = 0; i &lt; length; i++)
1134     {
1135       const GVariantType *type;
1136       gsize size;
1137 
1138       g_return_val_if_fail (g_variant_type_check (items[i]), NULL);
1139 
1140       type = items[i];
1141       size = g_variant_type_get_string_length (type);
1142       g_string_append_len (string, (const gchar *) type, size);
1143     }
1144   g_string_append_c (string, &#39;)&#39;);
1145 
1146   return (GVariantType *) g_string_free (string, FALSE);
1147 }
1148 
1149 GVariantType *
1150 g_variant_type_new_tuple (const GVariantType * const *items,
1151                           gint                        length)
1152 {
1153   char buffer[1024];
1154   gsize offset;
1155   gsize i;
1156   gsize length_unsigned;
1157 
1158   g_return_val_if_fail (length == 0 || items != NULL, NULL);
1159 
1160   if (length &lt; 0)
1161     for (length_unsigned = 0; items[length_unsigned] != NULL; length_unsigned++);
1162   else
1163     length_unsigned = (gsize) length;
1164 
1165   offset = 0;
1166   buffer[offset++] = &#39;(&#39;;
1167 
1168   for (i = 0; i &lt; length_unsigned; i++)
1169     {
1170       const GVariantType *type;
1171       gsize size;
1172 
1173       g_return_val_if_fail (g_variant_type_check (items[i]), NULL);
1174 
1175       type = items[i];
1176       size = g_variant_type_get_string_length (type);
1177 
1178       if (offset + size &gt;= sizeof buffer) /* leave room for &#39;)&#39; */
1179         return g_variant_type_new_tuple_slow (items, length_unsigned);
1180 
1181       memcpy (&amp;buffer[offset], type, size);
1182       offset += size;
1183     }
1184 
1185   g_assert (offset &lt; sizeof buffer);
1186   buffer[offset++] = &#39;)&#39;;
1187 
1188   return (GVariantType *) g_memdup (buffer, offset);
1189 }
1190 
1191 /**
1192  * g_variant_type_new_array: (constructor)
1193  * @element: a #GVariantType
1194  *
1195  * Constructs the type corresponding to an array of elements of the
1196  * type @type.
1197  *
1198  * It is appropriate to call g_variant_type_free() on the return value.
1199  *
1200  * Returns: (transfer full): a new array #GVariantType
1201  *
1202  * Since 2.24
1203  **/
1204 GVariantType *
1205 g_variant_type_new_array (const GVariantType *element)
1206 {
1207   gsize size;
1208   gchar *new;
1209 
1210   g_return_val_if_fail (g_variant_type_check (element), NULL);
1211 
1212   size = g_variant_type_get_string_length (element);
1213   new = g_malloc (size + 1);
1214 #ifdef GSTREAMER_LITE
1215   if (new == NULL)
1216       return NULL;
1217 #endif // GSTREAMER_LITE
1218 
1219   new[0] = &#39;a&#39;;
1220   memcpy (new + 1, element, size);
1221 
1222   return (GVariantType *) new;
1223 }
1224 
1225 /**
1226  * g_variant_type_new_maybe: (constructor)
1227  * @element: a #GVariantType
1228  *
1229  * Constructs the type corresponding to a maybe instance containing
1230  * type @type or Nothing.
1231  *
1232  * It is appropriate to call g_variant_type_free() on the return value.
1233  *
1234  * Returns: (transfer full): a new maybe #GVariantType
1235  *
1236  * Since 2.24
1237  **/
1238 GVariantType *
1239 g_variant_type_new_maybe (const GVariantType *element)
1240 {
1241   gsize size;
1242   gchar *new;
1243 
1244   g_return_val_if_fail (g_variant_type_check (element), NULL);
1245 
1246   size = g_variant_type_get_string_length (element);
1247   new = g_malloc (size + 1);
1248 #ifdef GSTREAMER_LITE
1249   if (new == NULL)
1250       return NULL;
1251 #endif // GSTREAMER_LITE
1252 
1253   new[0] = &#39;m&#39;;
1254   memcpy (new + 1, element, size);
1255 
1256   return (GVariantType *) new;
1257 }
1258 
1259 /**
1260  * g_variant_type_new_dict_entry: (constructor)
1261  * @key: a basic #GVariantType
1262  * @value: a #GVariantType
1263  *
1264  * Constructs the type corresponding to a dictionary entry with a key
1265  * of type @key and a value of type @value.
1266  *
1267  * It is appropriate to call g_variant_type_free() on the return value.
1268  *
1269  * Returns: (transfer full): a new dictionary entry #GVariantType
1270  *
1271  * Since 2.24
1272  **/
1273 GVariantType *
1274 g_variant_type_new_dict_entry (const GVariantType *key,
1275                                const GVariantType *value)
1276 {
1277   gsize keysize, valsize;
1278   gchar *new;
1279 
1280   g_return_val_if_fail (g_variant_type_check (key), NULL);
1281   g_return_val_if_fail (g_variant_type_check (value), NULL);
1282 
1283   keysize = g_variant_type_get_string_length (key);
1284   valsize = g_variant_type_get_string_length (value);
1285 
1286   new = g_malloc (1 + keysize + valsize + 1);
1287 #ifdef GSTREAMER_LITE
1288   if (new == NULL)
1289       return NULL;
1290 #endif // GSTREAMER_LITE
1291 
1292   new[0] = &#39;{&#39;;
1293   memcpy (new + 1, key, keysize);
1294   memcpy (new + 1 + keysize, value, valsize);
1295   new[1 + keysize + valsize] = &#39;}&#39;;
1296 
1297   return (GVariantType *) new;
1298 }
1299 
1300 /* private */
1301 const GVariantType *
1302 g_variant_type_checked_ (const gchar *type_string)
1303 {
1304   g_return_val_if_fail (g_variant_type_string_is_valid (type_string), NULL);
1305   return (const GVariantType *) type_string;
1306 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>