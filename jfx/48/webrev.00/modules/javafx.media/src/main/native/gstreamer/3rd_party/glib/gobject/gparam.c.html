<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gparam.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GObject - GLib Type, Object, Parameter and Signal Library
   2  * Copyright (C) 1997-1999, 2000-2001 Tim Janik and Red Hat, Inc.
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General
  15  * Public License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * MT safe
  20  */
  21 
  22 #include &quot;config.h&quot;
  23 
  24 #include &lt;string.h&gt;
  25 
  26 #include &quot;gparam.h&quot;
  27 #include &quot;gparamspecs.h&quot;
  28 #include &quot;gvaluecollector.h&quot;
  29 #include &quot;gtype-private.h&quot;
  30 
  31 /**
  32  * SECTION:gparamspec
  33  * @short_description: Metadata for parameter specifications
  34  * @see_also: g_object_class_install_property(), g_object_set(),
  35  *     g_object_get(), g_object_set_property(), g_object_get_property(),
  36  *     g_value_register_transform_func()
  37  * @title: GParamSpec
  38  *
  39  * #GParamSpec is an object structure that encapsulates the metadata
  40  * required to specify parameters, such as e.g. #GObject properties.
  41  *
  42  * ## Parameter names # {#canonical-parameter-names}
  43  *
  44  * Parameter names need to start with a letter (a-z or A-Z).
  45  * Subsequent characters can be letters, numbers or a &#39;-&#39;.
  46  * All other characters are replaced by a &#39;-&#39; during construction.
  47  * The result of this replacement is called the canonical name of
  48  * the parameter.
  49  */
  50 
  51 
  52 /* --- defines --- */
  53 #define PARAM_FLOATING_FLAG                     0x2
  54 #define G_PARAM_USER_MASK     (~0U &lt;&lt; G_PARAM_USER_SHIFT)
  55 #define PSPEC_APPLIES_TO_VALUE(pspec, value)  (G_TYPE_CHECK_VALUE_TYPE ((value), G_PARAM_SPEC_VALUE_TYPE (pspec)))
  56 
  57 /* --- prototypes --- */
  58 static void g_param_spec_class_base_init   (GParamSpecClass *class);
  59 static void g_param_spec_class_base_finalize (GParamSpecClass *class);
  60 static void g_param_spec_class_init    (GParamSpecClass *class,
  61               gpointer               class_data);
  62 static void g_param_spec_init    (GParamSpec    *pspec,
  63               GParamSpecClass *class);
  64 static void g_param_spec_finalize    (GParamSpec    *pspec);
  65 static void value_param_init    (GValue   *value);
  66 static void value_param_free_value    (GValue   *value);
  67 static void value_param_copy_value    (const GValue *src_value,
  68              GValue   *dest_value);
  69 static void value_param_transform_value (const GValue *src_value,
  70              GValue   *dest_value);
  71 static gpointer value_param_peek_pointer  (const GValue *value);
  72 static gchar* value_param_collect_value (GValue   *value,
  73              guint           n_collect_values,
  74              GTypeCValue    *collect_values,
  75              guint           collect_flags);
  76 static gchar* value_param_lcopy_value   (const GValue *value,
  77              guint           n_collect_values,
  78              GTypeCValue    *collect_values,
  79              guint           collect_flags);
  80 
  81 typedef struct
  82 {
  83   GValue default_value;
  84   GQuark name_quark;
  85 } GParamSpecPrivate;
  86 
  87 static gint g_param_private_offset;
  88 
  89 /* --- functions --- */
  90 static inline GParamSpecPrivate *
  91 g_param_spec_get_private (GParamSpec *pspec)
  92 {
  93   return &amp;G_STRUCT_MEMBER (GParamSpecPrivate, pspec, g_param_private_offset);
  94 }
  95 
  96 void
  97 _g_param_type_init (void)
  98 {
  99   static const GTypeFundamentalInfo finfo = {
 100     (G_TYPE_FLAG_CLASSED |
 101      G_TYPE_FLAG_INSTANTIATABLE |
 102      G_TYPE_FLAG_DERIVABLE |
 103      G_TYPE_FLAG_DEEP_DERIVABLE),
 104   };
 105   static const GTypeValueTable param_value_table = {
 106     value_param_init,           /* value_init */
 107     value_param_free_value,     /* value_free */
 108     value_param_copy_value,     /* value_copy */
 109     value_param_peek_pointer,   /* value_peek_pointer */
 110     &quot;p&quot;,      /* collect_format */
 111     value_param_collect_value,  /* collect_value */
 112     &quot;p&quot;,      /* lcopy_format */
 113     value_param_lcopy_value,    /* lcopy_value */
 114   };
 115   const GTypeInfo param_spec_info = {
 116     sizeof (GParamSpecClass),
 117 
 118     (GBaseInitFunc) g_param_spec_class_base_init,
 119     (GBaseFinalizeFunc) g_param_spec_class_base_finalize,
 120     (GClassInitFunc) g_param_spec_class_init,
 121     (GClassFinalizeFunc) NULL,
 122     NULL, /* class_data */
 123 
 124     sizeof (GParamSpec),
 125     0,    /* n_preallocs */
 126     (GInstanceInitFunc) g_param_spec_init,
 127 
 128     &amp;param_value_table,
 129   };
 130   GType type;
 131 
 132   /* This should be registered as GParamSpec instead of GParam, for
 133    * consistency sake, so that type name can be mapped to struct name,
 134    * However, some language bindings, most noticeable the python ones
 135    * depends on the &quot;GParam&quot; identifier, see #548689
 136    */
 137   type = g_type_register_fundamental (G_TYPE_PARAM, g_intern_static_string (&quot;GParam&quot;), &amp;param_spec_info, &amp;finfo, G_TYPE_FLAG_ABSTRACT);
 138   g_assert (type == G_TYPE_PARAM);
 139   g_param_private_offset = g_type_add_instance_private (type, sizeof (GParamSpecPrivate));
 140   g_value_register_transform_func (G_TYPE_PARAM, G_TYPE_PARAM, value_param_transform_value);
 141 }
 142 
 143 static void
 144 g_param_spec_class_base_init (GParamSpecClass *class)
 145 {
 146 }
 147 
 148 static void
 149 g_param_spec_class_base_finalize (GParamSpecClass *class)
 150 {
 151 }
 152 
 153 static void
 154 g_param_spec_class_init (GParamSpecClass *class,
 155        gpointer         class_data)
 156 {
 157   class-&gt;value_type = G_TYPE_NONE;
 158   class-&gt;finalize = g_param_spec_finalize;
 159   class-&gt;value_set_default = NULL;
 160   class-&gt;value_validate = NULL;
 161   class-&gt;values_cmp = NULL;
 162 
 163   g_type_class_adjust_private_offset (class, &amp;g_param_private_offset);
 164 }
 165 
 166 static void
 167 g_param_spec_init (GParamSpec      *pspec,
 168        GParamSpecClass *class)
 169 {
 170   pspec-&gt;name = NULL;
 171   pspec-&gt;_nick = NULL;
 172   pspec-&gt;_blurb = NULL;
 173   pspec-&gt;flags = 0;
 174   pspec-&gt;value_type = class-&gt;value_type;
 175   pspec-&gt;owner_type = 0;
 176   pspec-&gt;qdata = NULL;
 177   g_datalist_set_flags (&amp;pspec-&gt;qdata, PARAM_FLOATING_FLAG);
 178   pspec-&gt;ref_count = 1;
 179   pspec-&gt;param_id = 0;
 180 }
 181 
 182 static void
 183 g_param_spec_finalize (GParamSpec *pspec)
 184 {
 185   GParamSpecPrivate *priv = g_param_spec_get_private (pspec);
 186 
 187   if (priv-&gt;default_value.g_type)
 188     g_value_reset (&amp;priv-&gt;default_value);
 189 
 190   g_datalist_clear (&amp;pspec-&gt;qdata);
 191 
 192   if (!(pspec-&gt;flags &amp; G_PARAM_STATIC_NICK))
 193     g_free (pspec-&gt;_nick);
 194 
 195   if (!(pspec-&gt;flags &amp; G_PARAM_STATIC_BLURB))
 196     g_free (pspec-&gt;_blurb);
 197 
 198   g_type_free_instance ((GTypeInstance*) pspec);
 199 }
 200 
 201 /**
 202  * g_param_spec_ref: (skip)
 203  * @pspec: a valid #GParamSpec
 204  *
 205  * Increments the reference count of @pspec.
 206  *
 207  * Returns: the #GParamSpec that was passed into this function
 208  */
 209 GParamSpec*
 210 g_param_spec_ref (GParamSpec *pspec)
 211 {
 212   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), NULL);
 213 
 214   g_atomic_int_inc ((int *)&amp;pspec-&gt;ref_count);
 215 
 216   return pspec;
 217 }
 218 
 219 /**
 220  * g_param_spec_unref: (skip)
 221  * @pspec: a valid #GParamSpec
 222  *
 223  * Decrements the reference count of a @pspec.
 224  */
 225 void
 226 g_param_spec_unref (GParamSpec *pspec)
 227 {
 228   gboolean is_zero;
 229 
 230   g_return_if_fail (G_IS_PARAM_SPEC (pspec));
 231 
 232   is_zero = g_atomic_int_dec_and_test ((int *)&amp;pspec-&gt;ref_count);
 233 
 234   if (G_UNLIKELY (is_zero))
 235     {
 236       G_PARAM_SPEC_GET_CLASS (pspec)-&gt;finalize (pspec);
 237     }
 238 }
 239 
 240 /**
 241  * g_param_spec_sink:
 242  * @pspec: a valid #GParamSpec
 243  *
 244  * The initial reference count of a newly created #GParamSpec is 1,
 245  * even though no one has explicitly called g_param_spec_ref() on it
 246  * yet. So the initial reference count is flagged as &quot;floating&quot;, until
 247  * someone calls `g_param_spec_ref (pspec); g_param_spec_sink
 248  * (pspec);` in sequence on it, taking over the initial
 249  * reference count (thus ending up with a @pspec that has a reference
 250  * count of 1 still, but is not flagged &quot;floating&quot; anymore).
 251  */
 252 void
 253 g_param_spec_sink (GParamSpec *pspec)
 254 {
 255   gsize oldvalue;
 256   g_return_if_fail (G_IS_PARAM_SPEC (pspec));
 257 
 258   oldvalue = g_atomic_pointer_and (&amp;pspec-&gt;qdata, ~(gsize)PARAM_FLOATING_FLAG);
 259   if (oldvalue &amp; PARAM_FLOATING_FLAG)
 260     g_param_spec_unref (pspec);
 261 }
 262 
 263 /**
 264  * g_param_spec_ref_sink: (skip)
 265  * @pspec: a valid #GParamSpec
 266  *
 267  * Convenience function to ref and sink a #GParamSpec.
 268  *
 269  * Since: 2.10
 270  * Returns: the #GParamSpec that was passed into this function
 271  */
 272 GParamSpec*
 273 g_param_spec_ref_sink (GParamSpec *pspec)
 274 {
 275   gsize oldvalue;
 276   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), NULL);
 277 
 278   oldvalue = g_atomic_pointer_and (&amp;pspec-&gt;qdata, ~(gsize)PARAM_FLOATING_FLAG);
 279   if (!(oldvalue &amp; PARAM_FLOATING_FLAG))
 280     g_param_spec_ref (pspec);
 281 
 282   return pspec;
 283 }
 284 
 285 /**
 286  * g_param_spec_get_name:
 287  * @pspec: a valid #GParamSpec
 288  *
 289  * Get the name of a #GParamSpec.
 290  *
 291  * The name is always an &quot;interned&quot; string (as per g_intern_string()).
 292  * This allows for pointer-value comparisons.
 293  *
 294  * Returns: the name of @pspec.
 295  */
 296 const gchar *
 297 g_param_spec_get_name (GParamSpec *pspec)
 298 {
 299   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), NULL);
 300 
 301   return pspec-&gt;name;
 302 }
 303 
 304 /**
 305  * g_param_spec_get_nick:
 306  * @pspec: a valid #GParamSpec
 307  *
 308  * Get the nickname of a #GParamSpec.
 309  *
 310  * Returns: the nickname of @pspec.
 311  */
 312 const gchar *
 313 g_param_spec_get_nick (GParamSpec *pspec)
 314 {
 315   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), NULL);
 316 
 317   if (pspec-&gt;_nick)
 318     return pspec-&gt;_nick;
 319   else
 320     {
 321       GParamSpec *redirect_target;
 322 
 323       redirect_target = g_param_spec_get_redirect_target (pspec);
 324       if (redirect_target &amp;&amp; redirect_target-&gt;_nick)
 325   return redirect_target-&gt;_nick;
 326     }
 327 
 328   return pspec-&gt;name;
 329 }
 330 
 331 /**
 332  * g_param_spec_get_blurb:
 333  * @pspec: a valid #GParamSpec
 334  *
 335  * Get the short description of a #GParamSpec.
 336  *
 337  * Returns: the short description of @pspec.
 338  */
 339 const gchar *
 340 g_param_spec_get_blurb (GParamSpec *pspec)
 341 {
 342   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), NULL);
 343 
 344   if (pspec-&gt;_blurb)
 345     return pspec-&gt;_blurb;
 346   else
 347     {
 348       GParamSpec *redirect_target;
 349 
 350       redirect_target = g_param_spec_get_redirect_target (pspec);
 351       if (redirect_target &amp;&amp; redirect_target-&gt;_blurb)
 352   return redirect_target-&gt;_blurb;
 353     }
 354 
 355   return NULL;
 356 }
 357 
 358 static void
 359 canonicalize_key (gchar *key)
 360 {
 361   gchar *p;
 362 
 363   for (p = key; *p != 0; p++)
 364     {
 365       gchar c = *p;
 366 
 367       if (c != &#39;-&#39; &amp;&amp;
 368     (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) &amp;&amp;
 369     (c &lt; &#39;A&#39; || c &gt; &#39;Z&#39;) &amp;&amp;
 370     (c &lt; &#39;a&#39; || c &gt; &#39;z&#39;))
 371   *p = &#39;-&#39;;
 372     }
 373 }
 374 
 375 static gboolean
 376 is_canonical (const gchar *key)
 377 {
 378   const gchar *p;
 379 
 380   for (p = key; *p != 0; p++)
 381     {
 382       gchar c = *p;
 383 
 384       if (c != &#39;-&#39; &amp;&amp;
 385     (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) &amp;&amp;
 386     (c &lt; &#39;A&#39; || c &gt; &#39;Z&#39;) &amp;&amp;
 387     (c &lt; &#39;a&#39; || c &gt; &#39;z&#39;))
 388   return FALSE;
 389     }
 390 
 391   return TRUE;
 392 }
 393 
 394 /**
 395  * g_param_spec_internal: (skip)
 396  * @param_type: the #GType for the property; must be derived from #G_TYPE_PARAM
 397  * @name: the canonical name of the property
 398  * @nick: the nickname of the property
 399  * @blurb: a short description of the property
 400  * @flags: a combination of #GParamFlags
 401  *
 402  * Creates a new #GParamSpec instance.
 403  *
 404  * A property name consists of segments consisting of ASCII letters and
 405  * digits, separated by either the &#39;-&#39; or &#39;_&#39; character. The first
 406  * character of a property name must be a letter. Names which violate these
 407  * rules lead to undefined behaviour.
 408  *
 409  * When creating and looking up a #GParamSpec, either separator can be
 410  * used, but they cannot be mixed. Using &#39;-&#39; is considerably more
 411  * efficient and in fact required when using property names as detail
 412  * strings for signals.
 413  *
 414  * Beyond the name, #GParamSpecs have two more descriptive
 415  * strings associated with them, the @nick, which should be suitable
 416  * for use as a label for the property in a property editor, and the
 417  * @blurb, which should be a somewhat longer description, suitable for
 418  * e.g. a tooltip. The @nick and @blurb should ideally be localized.
 419  *
 420  * Returns: (type GObject.ParamSpec): a newly allocated #GParamSpec instance
 421  */
 422 gpointer
 423 g_param_spec_internal (GType        param_type,
 424            const gchar *name,
 425            const gchar *nick,
 426            const gchar *blurb,
 427            GParamFlags  flags)
 428 {
 429   GParamSpec *pspec;
 430   GParamSpecPrivate *priv;
 431 
 432   g_return_val_if_fail (G_TYPE_IS_PARAM (param_type) &amp;&amp; param_type != G_TYPE_PARAM, NULL);
 433   g_return_val_if_fail (name != NULL, NULL);
 434   g_return_val_if_fail ((name[0] &gt;= &#39;A&#39; &amp;&amp; name[0] &lt;= &#39;Z&#39;) || (name[0] &gt;= &#39;a&#39; &amp;&amp; name[0] &lt;= &#39;z&#39;), NULL);
 435   g_return_val_if_fail (!(flags &amp; G_PARAM_STATIC_NAME) || is_canonical (name), NULL);
 436 
 437   pspec = (gpointer) g_type_create_instance (param_type);
 438 #ifdef GSTREAMER_LITE
 439   if (pspec == NULL)
 440       return NULL;
 441 #endif // GSTREAMER_LITE
 442 
 443   if (flags &amp; G_PARAM_STATIC_NAME)
 444     {
 445       /* pspec-&gt;name is not freed if (flags &amp; G_PARAM_STATIC_NAME) */
 446       pspec-&gt;name = (gchar *) g_intern_static_string (name);
 447       if (!is_canonical (pspec-&gt;name))
 448         g_warning (&quot;G_PARAM_STATIC_NAME used with non-canonical pspec name: %s&quot;, pspec-&gt;name);
 449     }
 450   else
 451     {
 452       if (is_canonical (name))
 453         pspec-&gt;name = (gchar *) g_intern_string (name);
 454       else
 455         {
 456           gchar *tmp = g_strdup (name);
 457           canonicalize_key (tmp);
 458           pspec-&gt;name = (gchar *) g_intern_string (tmp);
 459           g_free (tmp);
 460         }
 461     }
 462 
 463   priv = g_param_spec_get_private (pspec);
 464   priv-&gt;name_quark = g_quark_from_string (pspec-&gt;name);
 465 
 466   if (flags &amp; G_PARAM_STATIC_NICK)
 467     pspec-&gt;_nick = (gchar*) nick;
 468   else
 469     pspec-&gt;_nick = g_strdup (nick);
 470 
 471   if (flags &amp; G_PARAM_STATIC_BLURB)
 472     pspec-&gt;_blurb = (gchar*) blurb;
 473   else
 474     pspec-&gt;_blurb = g_strdup (blurb);
 475 
 476   pspec-&gt;flags = (flags &amp; G_PARAM_USER_MASK) | (flags &amp; G_PARAM_MASK);
 477 
 478   return pspec;
 479 }
 480 
 481 /**
 482  * g_param_spec_get_qdata:
 483  * @pspec: a valid #GParamSpec
 484  * @quark: a #GQuark, naming the user data pointer
 485  *
 486  * Gets back user data pointers stored via g_param_spec_set_qdata().
 487  *
 488  * Returns: (transfer none): the user data pointer set, or %NULL
 489  */
 490 gpointer
 491 g_param_spec_get_qdata (GParamSpec *pspec,
 492       GQuark      quark)
 493 {
 494   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), NULL);
 495 
 496   return quark ? g_datalist_id_get_data (&amp;pspec-&gt;qdata, quark) : NULL;
 497 }
 498 
 499 /**
 500  * g_param_spec_set_qdata:
 501  * @pspec: the #GParamSpec to set store a user data pointer
 502  * @quark: a #GQuark, naming the user data pointer
 503  * @data: an opaque user data pointer
 504  *
 505  * Sets an opaque, named pointer on a #GParamSpec. The name is
 506  * specified through a #GQuark (retrieved e.g. via
 507  * g_quark_from_static_string()), and the pointer can be gotten back
 508  * from the @pspec with g_param_spec_get_qdata().  Setting a
 509  * previously set user data pointer, overrides (frees) the old pointer
 510  * set, using %NULL as pointer essentially removes the data stored.
 511  */
 512 void
 513 g_param_spec_set_qdata (GParamSpec *pspec,
 514       GQuark      quark,
 515       gpointer    data)
 516 {
 517   g_return_if_fail (G_IS_PARAM_SPEC (pspec));
 518   g_return_if_fail (quark &gt; 0);
 519 
 520   g_datalist_id_set_data (&amp;pspec-&gt;qdata, quark, data);
 521 }
 522 
 523 /**
 524  * g_param_spec_set_qdata_full: (skip)
 525  * @pspec: the #GParamSpec to set store a user data pointer
 526  * @quark: a #GQuark, naming the user data pointer
 527  * @data: an opaque user data pointer
 528  * @destroy: function to invoke with @data as argument, when @data needs to
 529  *  be freed
 530  *
 531  * This function works like g_param_spec_set_qdata(), but in addition,
 532  * a `void (*destroy) (gpointer)` function may be
 533  * specified which is called with @data as argument when the @pspec is
 534  * finalized, or the data is being overwritten by a call to
 535  * g_param_spec_set_qdata() with the same @quark.
 536  */
 537 void
 538 g_param_spec_set_qdata_full (GParamSpec    *pspec,
 539            GQuark         quark,
 540            gpointer       data,
 541            GDestroyNotify destroy)
 542 {
 543   g_return_if_fail (G_IS_PARAM_SPEC (pspec));
 544   g_return_if_fail (quark &gt; 0);
 545 
 546   g_datalist_id_set_data_full (&amp;pspec-&gt;qdata, quark, data, data ? destroy : (GDestroyNotify) NULL);
 547 }
 548 
 549 /**
 550  * g_param_spec_steal_qdata:
 551  * @pspec: the #GParamSpec to get a stored user data pointer from
 552  * @quark: a #GQuark, naming the user data pointer
 553  *
 554  * Gets back user data pointers stored via g_param_spec_set_qdata()
 555  * and removes the @data from @pspec without invoking its destroy()
 556  * function (if any was set).  Usually, calling this function is only
 557  * required to update user data pointers with a destroy notifier.
 558  *
 559  * Returns: (transfer none): the user data pointer set, or %NULL
 560  */
 561 gpointer
 562 g_param_spec_steal_qdata (GParamSpec *pspec,
 563         GQuark      quark)
 564 {
 565   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), NULL);
 566   g_return_val_if_fail (quark &gt; 0, NULL);
 567 
 568   return g_datalist_id_remove_no_notify (&amp;pspec-&gt;qdata, quark);
 569 }
 570 
 571 /**
 572  * g_param_spec_get_redirect_target:
 573  * @pspec: a #GParamSpec
 574  *
 575  * If the paramspec redirects operations to another paramspec,
 576  * returns that paramspec. Redirect is used typically for
 577  * providing a new implementation of a property in a derived
 578  * type while preserving all the properties from the parent
 579  * type. Redirection is established by creating a property
 580  * of type #GParamSpecOverride. See g_object_class_override_property()
 581  * for an example of the use of this capability.
 582  *
 583  * Since: 2.4
 584  *
 585  * Returns: (transfer none): paramspec to which requests on this
 586  *          paramspec should be redirected, or %NULL if none.
 587  */
 588 GParamSpec*
 589 g_param_spec_get_redirect_target (GParamSpec *pspec)
 590 {
 591   GTypeInstance *inst = (GTypeInstance *)pspec;
 592 
 593   if (inst &amp;&amp; inst-&gt;g_class &amp;&amp; inst-&gt;g_class-&gt;g_type == G_TYPE_PARAM_OVERRIDE)
 594     return ((GParamSpecOverride*)pspec)-&gt;overridden;
 595   else
 596     return NULL;
 597 }
 598 
 599 /**
 600  * g_param_value_set_default:
 601  * @pspec: a valid #GParamSpec
 602  * @value: a #GValue of correct type for @pspec
 603  *
 604  * Sets @value to its default value as specified in @pspec.
 605  */
 606 void
 607 g_param_value_set_default (GParamSpec *pspec,
 608          GValue     *value)
 609 {
 610   g_return_if_fail (G_IS_PARAM_SPEC (pspec));
 611   g_return_if_fail (G_IS_VALUE (value));
 612   g_return_if_fail (PSPEC_APPLIES_TO_VALUE (pspec, value));
 613 
 614   g_value_reset (value);
 615   G_PARAM_SPEC_GET_CLASS (pspec)-&gt;value_set_default (pspec, value);
 616 }
 617 
 618 /**
 619  * g_param_value_defaults:
 620  * @pspec: a valid #GParamSpec
 621  * @value: a #GValue of correct type for @pspec
 622  *
 623  * Checks whether @value contains the default value as specified in @pspec.
 624  *
 625  * Returns: whether @value contains the canonical default for this @pspec
 626  */
 627 gboolean
 628 g_param_value_defaults (GParamSpec *pspec,
 629       GValue     *value)
 630 {
 631   GValue dflt_value = G_VALUE_INIT;
 632   gboolean defaults;
 633 
 634   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), FALSE);
 635   g_return_val_if_fail (G_IS_VALUE (value), FALSE);
 636   g_return_val_if_fail (PSPEC_APPLIES_TO_VALUE (pspec, value), FALSE);
 637 
 638   g_value_init (&amp;dflt_value, G_PARAM_SPEC_VALUE_TYPE (pspec));
 639   G_PARAM_SPEC_GET_CLASS (pspec)-&gt;value_set_default (pspec, &amp;dflt_value);
 640   defaults = G_PARAM_SPEC_GET_CLASS (pspec)-&gt;values_cmp (pspec, value, &amp;dflt_value) == 0;
 641   g_value_unset (&amp;dflt_value);
 642 
 643   return defaults;
 644 }
 645 
 646 /**
 647  * g_param_value_validate:
 648  * @pspec: a valid #GParamSpec
 649  * @value: a #GValue of correct type for @pspec
 650  *
 651  * Ensures that the contents of @value comply with the specifications
 652  * set out by @pspec. For example, a #GParamSpecInt might require
 653  * that integers stored in @value may not be smaller than -42 and not be
 654  * greater than +42. If @value contains an integer outside of this range,
 655  * it is modified accordingly, so the resulting value will fit into the
 656  * range -42 .. +42.
 657  *
 658  * Returns: whether modifying @value was necessary to ensure validity
 659  */
 660 gboolean
 661 g_param_value_validate (GParamSpec *pspec,
 662       GValue     *value)
 663 {
 664   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), FALSE);
 665   g_return_val_if_fail (G_IS_VALUE (value), FALSE);
 666   g_return_val_if_fail (PSPEC_APPLIES_TO_VALUE (pspec, value), FALSE);
 667 
 668   if (G_PARAM_SPEC_GET_CLASS (pspec)-&gt;value_validate)
 669     {
 670       GValue oval = *value;
 671 
 672       if (G_PARAM_SPEC_GET_CLASS (pspec)-&gt;value_validate (pspec, value) ||
 673     memcmp (&amp;oval.data, &amp;value-&gt;data, sizeof (oval.data)))
 674   return TRUE;
 675     }
 676 
 677   return FALSE;
 678 }
 679 
 680 /**
 681  * g_param_value_convert:
 682  * @pspec: a valid #GParamSpec
 683  * @src_value: souce #GValue
 684  * @dest_value: destination #GValue of correct type for @pspec
 685  * @strict_validation: %TRUE requires @dest_value to conform to @pspec
 686  * without modifications
 687  *
 688  * Transforms @src_value into @dest_value if possible, and then
 689  * validates @dest_value, in order for it to conform to @pspec.  If
 690  * @strict_validation is %TRUE this function will only succeed if the
 691  * transformed @dest_value complied to @pspec without modifications.
 692  *
 693  * See also g_value_type_transformable(), g_value_transform() and
 694  * g_param_value_validate().
 695  *
 696  * Returns: %TRUE if transformation and validation were successful,
 697  *  %FALSE otherwise and @dest_value is left untouched.
 698  */
 699 gboolean
 700 g_param_value_convert (GParamSpec   *pspec,
 701            const GValue *src_value,
 702            GValue       *dest_value,
 703            gboolean      strict_validation)
 704 {
 705   GValue tmp_value = G_VALUE_INIT;
 706 
 707   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), FALSE);
 708   g_return_val_if_fail (G_IS_VALUE (src_value), FALSE);
 709   g_return_val_if_fail (G_IS_VALUE (dest_value), FALSE);
 710   g_return_val_if_fail (PSPEC_APPLIES_TO_VALUE (pspec, dest_value), FALSE);
 711 
 712   /* better leave dest_value untouched when returning FALSE */
 713 
 714   g_value_init (&amp;tmp_value, G_VALUE_TYPE (dest_value));
 715   if (g_value_transform (src_value, &amp;tmp_value) &amp;&amp;
 716       (!g_param_value_validate (pspec, &amp;tmp_value) || !strict_validation))
 717     {
 718       g_value_unset (dest_value);
 719 
 720       /* values are relocatable */
 721       memcpy (dest_value, &amp;tmp_value, sizeof (tmp_value));
 722 
 723       return TRUE;
 724     }
 725   else
 726     {
 727       g_value_unset (&amp;tmp_value);
 728 
 729       return FALSE;
 730     }
 731 }
 732 
 733 /**
 734  * g_param_values_cmp:
 735  * @pspec: a valid #GParamSpec
 736  * @value1: a #GValue of correct type for @pspec
 737  * @value2: a #GValue of correct type for @pspec
 738  *
 739  * Compares @value1 with @value2 according to @pspec, and return -1, 0 or +1,
 740  * if @value1 is found to be less than, equal to or greater than @value2,
 741  * respectively.
 742  *
 743  * Returns: -1, 0 or +1, for a less than, equal to or greater than result
 744  */
 745 gint
 746 g_param_values_cmp (GParamSpec   *pspec,
 747         const GValue *value1,
 748         const GValue *value2)
 749 {
 750   gint cmp;
 751 
 752   /* param_values_cmp() effectively does: value1 - value2
 753    * so the return values are:
 754    * -1)  value1 &lt; value2
 755    *  0)  value1 == value2
 756    *  1)  value1 &gt; value2
 757    */
 758   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), 0);
 759   g_return_val_if_fail (G_IS_VALUE (value1), 0);
 760   g_return_val_if_fail (G_IS_VALUE (value2), 0);
 761   g_return_val_if_fail (PSPEC_APPLIES_TO_VALUE (pspec, value1), 0);
 762   g_return_val_if_fail (PSPEC_APPLIES_TO_VALUE (pspec, value2), 0);
 763 
 764   cmp = G_PARAM_SPEC_GET_CLASS (pspec)-&gt;values_cmp (pspec, value1, value2);
 765 
 766   return CLAMP (cmp, -1, 1);
 767 }
 768 
 769 static void
 770 value_param_init (GValue *value)
 771 {
 772   value-&gt;data[0].v_pointer = NULL;
 773 }
 774 
 775 static void
 776 value_param_free_value (GValue *value)
 777 {
 778   if (value-&gt;data[0].v_pointer)
 779     g_param_spec_unref (value-&gt;data[0].v_pointer);
 780 }
 781 
 782 static void
 783 value_param_copy_value (const GValue *src_value,
 784       GValue       *dest_value)
 785 {
 786   if (src_value-&gt;data[0].v_pointer)
 787     dest_value-&gt;data[0].v_pointer = g_param_spec_ref (src_value-&gt;data[0].v_pointer);
 788   else
 789     dest_value-&gt;data[0].v_pointer = NULL;
 790 }
 791 
 792 static void
 793 value_param_transform_value (const GValue *src_value,
 794            GValue       *dest_value)
 795 {
 796   if (src_value-&gt;data[0].v_pointer &amp;&amp;
 797       g_type_is_a (G_PARAM_SPEC_TYPE (dest_value-&gt;data[0].v_pointer), G_VALUE_TYPE (dest_value)))
 798     dest_value-&gt;data[0].v_pointer = g_param_spec_ref (src_value-&gt;data[0].v_pointer);
 799   else
 800     dest_value-&gt;data[0].v_pointer = NULL;
 801 }
 802 
 803 static gpointer
 804 value_param_peek_pointer (const GValue *value)
 805 {
 806   return value-&gt;data[0].v_pointer;
 807 }
 808 
 809 static gchar*
 810 value_param_collect_value (GValue      *value,
 811          guint        n_collect_values,
 812          GTypeCValue *collect_values,
 813          guint        collect_flags)
 814 {
 815   if (collect_values[0].v_pointer)
 816     {
 817       GParamSpec *param = collect_values[0].v_pointer;
 818 
 819       if (param-&gt;g_type_instance.g_class == NULL)
 820   return g_strconcat (&quot;invalid unclassed param spec pointer for value type &#39;&quot;,
 821           G_VALUE_TYPE_NAME (value),
 822           &quot;&#39;&quot;,
 823           NULL);
 824       else if (!g_value_type_compatible (G_PARAM_SPEC_TYPE (param), G_VALUE_TYPE (value)))
 825   return g_strconcat (&quot;invalid param spec type &#39;&quot;,
 826           G_PARAM_SPEC_TYPE_NAME (param),
 827           &quot;&#39; for value type &#39;&quot;,
 828           G_VALUE_TYPE_NAME (value),
 829           &quot;&#39;&quot;,
 830           NULL);
 831       value-&gt;data[0].v_pointer = g_param_spec_ref (param);
 832     }
 833   else
 834     value-&gt;data[0].v_pointer = NULL;
 835 
 836   return NULL;
 837 }
 838 
 839 static gchar*
 840 value_param_lcopy_value (const GValue *value,
 841        guint         n_collect_values,
 842        GTypeCValue  *collect_values,
 843        guint         collect_flags)
 844 {
 845   GParamSpec **param_p = collect_values[0].v_pointer;
 846 
 847   if (!param_p)
 848     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
 849 
 850   if (!value-&gt;data[0].v_pointer)
 851     *param_p = NULL;
 852   else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
 853     *param_p = value-&gt;data[0].v_pointer;
 854   else
 855     *param_p = g_param_spec_ref (value-&gt;data[0].v_pointer);
 856 
 857   return NULL;
 858 }
 859 
 860 
 861 /* --- param spec pool --- */
 862 /**
 863  * GParamSpecPool:
 864  *
 865  * A #GParamSpecPool maintains a collection of #GParamSpecs which can be
 866  * quickly accessed by owner and name. The implementation of the #GObject property
 867  * system uses such a pool to store the #GParamSpecs of the properties all object
 868  * types.
 869  */
 870 struct _GParamSpecPool
 871 {
 872   GMutex       mutex;
 873   gboolean     type_prefixing;
 874   GHashTable  *hash_table;
 875 };
 876 
 877 static guint
 878 param_spec_pool_hash (gconstpointer key_spec)
 879 {
 880   const GParamSpec *key = key_spec;
 881   const gchar *p;
 882   guint h = key-&gt;owner_type;
 883 
 884   for (p = key-&gt;name; *p; p++)
 885     h = (h &lt;&lt; 5) - h + *p;
 886 
 887   return h;
 888 }
 889 
 890 static gboolean
 891 param_spec_pool_equals (gconstpointer key_spec_1,
 892       gconstpointer key_spec_2)
 893 {
 894   const GParamSpec *key1 = key_spec_1;
 895   const GParamSpec *key2 = key_spec_2;
 896 
 897   return (key1-&gt;owner_type == key2-&gt;owner_type &amp;&amp;
 898     strcmp (key1-&gt;name, key2-&gt;name) == 0);
 899 }
 900 
 901 /**
 902  * g_param_spec_pool_new:
 903  * @type_prefixing: Whether the pool will support type-prefixed property names.
 904  *
 905  * Creates a new #GParamSpecPool.
 906  *
 907  * If @type_prefixing is %TRUE, lookups in the newly created pool will
 908  * allow to specify the owner as a colon-separated prefix of the
 909  * property name, like &quot;GtkContainer:border-width&quot;. This feature is
 910  * deprecated, so you should always set @type_prefixing to %FALSE.
 911  *
 912  * Returns: (transfer none): a newly allocated #GParamSpecPool.
 913  */
 914 GParamSpecPool*
 915 g_param_spec_pool_new (gboolean type_prefixing)
 916 {
 917   static GMutex init_mutex;
 918   GParamSpecPool *pool = g_new (GParamSpecPool, 1);
 919 
 920   memcpy (&amp;pool-&gt;mutex, &amp;init_mutex, sizeof (init_mutex));
 921   pool-&gt;type_prefixing = type_prefixing != FALSE;
 922   pool-&gt;hash_table = g_hash_table_new (param_spec_pool_hash, param_spec_pool_equals);
 923 
 924   return pool;
 925 }
 926 
 927 /**
 928  * g_param_spec_pool_insert:
 929  * @pool: a #GParamSpecPool.
 930  * @pspec: the #GParamSpec to insert
 931  * @owner_type: a #GType identifying the owner of @pspec
 932  *
 933  * Inserts a #GParamSpec in the pool.
 934  */
 935 void
 936 g_param_spec_pool_insert (GParamSpecPool *pool,
 937         GParamSpec     *pspec,
 938         GType           owner_type)
 939 {
 940   const gchar *p;
 941 
 942   if (pool &amp;&amp; pspec &amp;&amp; owner_type &gt; 0 &amp;&amp; pspec-&gt;owner_type == 0)
 943     {
 944       for (p = pspec-&gt;name; *p; p++)
 945   {
 946     if (!strchr (G_CSET_A_2_Z G_CSET_a_2_z G_CSET_DIGITS &quot;-_&quot;, *p))
 947       {
 948         g_warning (G_STRLOC &quot;: pspec name \&quot;%s\&quot; contains invalid characters&quot;, pspec-&gt;name);
 949         return;
 950       }
 951   }
 952       g_mutex_lock (&amp;pool-&gt;mutex);
 953       pspec-&gt;owner_type = owner_type;
 954       g_param_spec_ref (pspec);
 955       g_hash_table_add (pool-&gt;hash_table, pspec);
 956       g_mutex_unlock (&amp;pool-&gt;mutex);
 957     }
 958   else
 959     {
 960       g_return_if_fail (pool != NULL);
 961       g_return_if_fail (pspec);
 962       g_return_if_fail (owner_type &gt; 0);
 963       g_return_if_fail (pspec-&gt;owner_type == 0);
 964     }
 965 }
 966 
 967 /**
 968  * g_param_spec_pool_remove:
 969  * @pool: a #GParamSpecPool
 970  * @pspec: the #GParamSpec to remove
 971  *
 972  * Removes a #GParamSpec from the pool.
 973  */
 974 void
 975 g_param_spec_pool_remove (GParamSpecPool *pool,
 976         GParamSpec     *pspec)
 977 {
 978   if (pool &amp;&amp; pspec)
 979     {
 980       g_mutex_lock (&amp;pool-&gt;mutex);
 981       if (g_hash_table_remove (pool-&gt;hash_table, pspec))
 982   g_param_spec_unref (pspec);
 983       else
 984   g_warning (G_STRLOC &quot;: attempt to remove unknown pspec &#39;%s&#39; from pool&quot;, pspec-&gt;name);
 985       g_mutex_unlock (&amp;pool-&gt;mutex);
 986     }
 987   else
 988     {
 989       g_return_if_fail (pool != NULL);
 990       g_return_if_fail (pspec);
 991     }
 992 }
 993 
 994 static inline GParamSpec*
 995 param_spec_ht_lookup (GHashTable  *hash_table,
 996           const gchar *param_name,
 997           GType        owner_type,
 998           gboolean     walk_ancestors)
 999 {
1000   GParamSpec key, *pspec;
1001 
1002   key.owner_type = owner_type;
1003   key.name = (gchar*) param_name;
1004   if (walk_ancestors)
1005     do
1006       {
1007   pspec = g_hash_table_lookup (hash_table, &amp;key);
1008   if (pspec)
1009     return pspec;
1010   key.owner_type = g_type_parent (key.owner_type);
1011       }
1012     while (key.owner_type);
1013   else
1014     pspec = g_hash_table_lookup (hash_table, &amp;key);
1015 
1016   if (!pspec &amp;&amp; !is_canonical (param_name))
1017     {
1018       gchar *canonical;
1019 
1020       canonical = g_strdup (key.name);
1021       canonicalize_key (canonical);
1022 
1023       /* try canonicalized form */
1024       key.name = canonical;
1025       key.owner_type = owner_type;
1026 
1027       if (walk_ancestors)
1028         do
1029           {
1030             pspec = g_hash_table_lookup (hash_table, &amp;key);
1031             if (pspec)
1032               {
1033                 g_free (canonical);
1034                 return pspec;
1035               }
1036             key.owner_type = g_type_parent (key.owner_type);
1037           }
1038         while (key.owner_type);
1039       else
1040         pspec = g_hash_table_lookup (hash_table, &amp;key);
1041 
1042       g_free (canonical);
1043     }
1044 
1045   return pspec;
1046 }
1047 
1048 /**
1049  * g_param_spec_pool_lookup:
1050  * @pool: a #GParamSpecPool
1051  * @param_name: the name to look for
1052  * @owner_type: the owner to look for
1053  * @walk_ancestors: If %TRUE, also try to find a #GParamSpec with @param_name
1054  *  owned by an ancestor of @owner_type.
1055  *
1056  * Looks up a #GParamSpec in the pool.
1057  *
1058  * Returns: (transfer none): The found #GParamSpec, or %NULL if no
1059  * matching #GParamSpec was found.
1060  */
1061 GParamSpec*
1062 g_param_spec_pool_lookup (GParamSpecPool *pool,
1063         const gchar    *param_name,
1064         GType           owner_type,
1065         gboolean        walk_ancestors)
1066 {
1067   GParamSpec *pspec;
1068   gchar *delim;
1069 
1070   g_return_val_if_fail (pool != NULL, NULL);
1071   g_return_val_if_fail (param_name != NULL, NULL);
1072 
1073   g_mutex_lock (&amp;pool-&gt;mutex);
1074 
1075   delim = pool-&gt;type_prefixing ? strchr (param_name, &#39;:&#39;) : NULL;
1076 
1077   /* try quick and away, i.e. without prefix */
1078   if (!delim)
1079     {
1080       pspec = param_spec_ht_lookup (pool-&gt;hash_table, param_name, owner_type, walk_ancestors);
1081       g_mutex_unlock (&amp;pool-&gt;mutex);
1082 
1083       return pspec;
1084     }
1085 
1086   /* strip type prefix */
1087   if (pool-&gt;type_prefixing &amp;&amp; delim[1] == &#39;:&#39;)
1088     {
1089       guint l = delim - param_name;
1090       gchar stack_buffer[32], *buffer = l &lt; 32 ? stack_buffer : g_new (gchar, l + 1);
1091       GType type;
1092 
1093       strncpy (buffer, param_name, delim - param_name);
1094       buffer[l] = 0;
1095       type = g_type_from_name (buffer);
1096       if (l &gt;= 32)
1097   g_free (buffer);
1098       if (type)   /* type==0 isn&#39;t a valid type pefix */
1099   {
1100     /* sanity check, these cases don&#39;t make a whole lot of sense */
1101     if ((!walk_ancestors &amp;&amp; type != owner_type) || !g_type_is_a (owner_type, type))
1102       {
1103         g_mutex_unlock (&amp;pool-&gt;mutex);
1104 
1105         return NULL;
1106       }
1107     owner_type = type;
1108     param_name += l + 2;
1109     pspec = param_spec_ht_lookup (pool-&gt;hash_table, param_name, owner_type, walk_ancestors);
1110     g_mutex_unlock (&amp;pool-&gt;mutex);
1111 
1112     return pspec;
1113   }
1114     }
1115   /* malformed param_name */
1116 
1117   g_mutex_unlock (&amp;pool-&gt;mutex);
1118 
1119   return NULL;
1120 }
1121 
1122 static void
1123 pool_list (gpointer key,
1124      gpointer value,
1125      gpointer user_data)
1126 {
1127   GParamSpec *pspec = value;
1128   gpointer *data = user_data;
1129   GType owner_type = (GType) data[1];
1130 
1131   if (owner_type == pspec-&gt;owner_type)
1132     data[0] = g_list_prepend (data[0], pspec);
1133 }
1134 
1135 /**
1136  * g_param_spec_pool_list_owned:
1137  * @pool: a #GParamSpecPool
1138  * @owner_type: the owner to look for
1139  *
1140  * Gets an #GList of all #GParamSpecs owned by @owner_type in
1141  * the pool.
1142  *
1143  * Returns: (transfer container) (element-type GObject.ParamSpec): a
1144  *          #GList of all #GParamSpecs owned by @owner_type in
1145  *          the pool#GParamSpecs.
1146  */
1147 GList*
1148 g_param_spec_pool_list_owned (GParamSpecPool *pool,
1149             GType           owner_type)
1150 {
1151   gpointer data[2];
1152 
1153   g_return_val_if_fail (pool != NULL, NULL);
1154   g_return_val_if_fail (owner_type &gt; 0, NULL);
1155 
1156   g_mutex_lock (&amp;pool-&gt;mutex);
1157   data[0] = NULL;
1158   data[1] = (gpointer) owner_type;
1159   g_hash_table_foreach (pool-&gt;hash_table, pool_list, &amp;data);
1160   g_mutex_unlock (&amp;pool-&gt;mutex);
1161 
1162   return data[0];
1163 }
1164 
1165 static gint
1166 pspec_compare_id (gconstpointer a,
1167       gconstpointer b)
1168 {
1169   const GParamSpec *pspec1 = a, *pspec2 = b;
1170 
1171   if (pspec1-&gt;param_id &lt; pspec2-&gt;param_id)
1172     return -1;
1173 
1174   if (pspec1-&gt;param_id &gt; pspec2-&gt;param_id)
1175     return 1;
1176 
1177   return strcmp (pspec1-&gt;name, pspec2-&gt;name);
1178 }
1179 
1180 static inline GSList*
1181 pspec_list_remove_overridden_and_redirected (GSList     *plist,
1182                GHashTable *ht,
1183                GType       owner_type,
1184                guint      *n_p)
1185 {
1186   GSList *rlist = NULL;
1187 
1188   while (plist)
1189     {
1190       GSList *tmp = plist-&gt;next;
1191       GParamSpec *pspec = plist-&gt;data;
1192       GParamSpec *found;
1193       gboolean remove = FALSE;
1194 
1195       /* Remove paramspecs that are redirected, and also paramspecs
1196        * that have are overridden by non-redirected properties.
1197        * The idea is to get the single paramspec for each name that
1198        * best corresponds to what the application sees.
1199        */
1200       if (g_param_spec_get_redirect_target (pspec))
1201   remove = TRUE;
1202       else
1203   {
1204     found = param_spec_ht_lookup (ht, pspec-&gt;name, owner_type, TRUE);
1205     if (found != pspec)
1206       {
1207         GParamSpec *redirect = g_param_spec_get_redirect_target (found);
1208         if (redirect != pspec)
1209     remove = TRUE;
1210       }
1211   }
1212 
1213       if (remove)
1214   {
1215     g_slist_free_1 (plist);
1216   }
1217       else
1218   {
1219     plist-&gt;next = rlist;
1220     rlist = plist;
1221     *n_p += 1;
1222   }
1223       plist = tmp;
1224     }
1225   return rlist;
1226 }
1227 
1228 static void
1229 pool_depth_list (gpointer key,
1230      gpointer value,
1231      gpointer user_data)
1232 {
1233   GParamSpec *pspec = value;
1234   gpointer *data = user_data;
1235   GSList **slists = data[0];
1236   GType owner_type = (GType) data[1];
1237 
1238   if (g_type_is_a (owner_type, pspec-&gt;owner_type))
1239     {
1240       if (G_TYPE_IS_INTERFACE (pspec-&gt;owner_type))
1241   {
1242     slists[0] = g_slist_prepend (slists[0], pspec);
1243   }
1244       else
1245   {
1246     guint d = g_type_depth (pspec-&gt;owner_type);
1247 
1248     slists[d - 1] = g_slist_prepend (slists[d - 1], pspec);
1249   }
1250     }
1251 }
1252 
1253 /* We handle interfaces specially since we don&#39;t want to
1254  * count interface prerequisites like normal inheritance;
1255  * the property comes from the direct inheritance from
1256  * the prerequisite class, not from the interface that
1257  * prerequires it.
1258  *
1259  * also &#39;depth&#39; isn&#39;t a meaningful concept for interface
1260  * prerequites.
1261  */
1262 static void
1263 pool_depth_list_for_interface (gpointer key,
1264              gpointer value,
1265              gpointer user_data)
1266 {
1267   GParamSpec *pspec = value;
1268   gpointer *data = user_data;
1269   GSList **slists = data[0];
1270   GType owner_type = (GType) data[1];
1271 
1272   if (pspec-&gt;owner_type == owner_type)
1273     slists[0] = g_slist_prepend (slists[0], pspec);
1274 }
1275 
1276 /**
1277  * g_param_spec_pool_list:
1278  * @pool: a #GParamSpecPool
1279  * @owner_type: the owner to look for
1280  * @n_pspecs_p: (out): return location for the length of the returned array
1281  *
1282  * Gets an array of all #GParamSpecs owned by @owner_type in
1283  * the pool.
1284  *
1285  * Returns: (array length=n_pspecs_p) (transfer container): a newly
1286  *          allocated array containing pointers to all #GParamSpecs
1287  *          owned by @owner_type in the pool
1288  */
1289 GParamSpec**
1290 g_param_spec_pool_list (GParamSpecPool *pool,
1291       GType           owner_type,
1292       guint          *n_pspecs_p)
1293 {
1294   GParamSpec **pspecs, **p;
1295   GSList **slists, *node;
1296   gpointer data[2];
1297   guint d, i;
1298 
1299   g_return_val_if_fail (pool != NULL, NULL);
1300   g_return_val_if_fail (owner_type &gt; 0, NULL);
1301   g_return_val_if_fail (n_pspecs_p != NULL, NULL);
1302 
1303   g_mutex_lock (&amp;pool-&gt;mutex);
1304   *n_pspecs_p = 0;
1305   d = g_type_depth (owner_type);
1306   slists = g_new0 (GSList*, d);
1307   data[0] = slists;
1308   data[1] = (gpointer) owner_type;
1309 
1310   g_hash_table_foreach (pool-&gt;hash_table,
1311       G_TYPE_IS_INTERFACE (owner_type) ?
1312          pool_depth_list_for_interface :
1313          pool_depth_list,
1314       &amp;data);
1315 
1316   for (i = 0; i &lt; d; i++)
1317     slists[i] = pspec_list_remove_overridden_and_redirected (slists[i], pool-&gt;hash_table, owner_type, n_pspecs_p);
1318   pspecs = g_new (GParamSpec*, *n_pspecs_p + 1);
1319   p = pspecs;
1320   for (i = 0; i &lt; d; i++)
1321     {
1322       slists[i] = g_slist_sort (slists[i], pspec_compare_id);
1323       for (node = slists[i]; node; node = node-&gt;next)
1324   *p++ = node-&gt;data;
1325       g_slist_free (slists[i]);
1326     }
1327   *p++ = NULL;
1328   g_free (slists);
1329   g_mutex_unlock (&amp;pool-&gt;mutex);
1330 
1331   return pspecs;
1332 }
1333 
1334 
1335 /* --- auxiliary functions --- */
1336 typedef struct
1337 {
1338   /* class portion */
1339   GType           value_type;
1340   void          (*finalize)             (GParamSpec   *pspec);
1341   void          (*value_set_default)    (GParamSpec   *pspec,
1342            GValue       *value);
1343   gboolean      (*value_validate)       (GParamSpec   *pspec,
1344            GValue       *value);
1345   gint          (*values_cmp)           (GParamSpec   *pspec,
1346            const GValue *value1,
1347            const GValue *value2);
1348 } ParamSpecClassInfo;
1349 
1350 static void
1351 param_spec_generic_class_init (gpointer g_class,
1352              gpointer class_data)
1353 {
1354   GParamSpecClass *class = g_class;
1355   ParamSpecClassInfo *info = class_data;
1356 
1357   class-&gt;value_type = info-&gt;value_type;
1358   if (info-&gt;finalize)
1359     class-&gt;finalize = info-&gt;finalize;     /* optional */
1360   class-&gt;value_set_default = info-&gt;value_set_default;
1361   if (info-&gt;value_validate)
1362     class-&gt;value_validate = info-&gt;value_validate; /* optional */
1363   class-&gt;values_cmp = info-&gt;values_cmp;
1364   g_free (class_data);
1365 }
1366 
1367 static void
1368 default_value_set_default (GParamSpec *pspec,
1369          GValue     *value)
1370 {
1371   /* value is already zero initialized */
1372 }
1373 
1374 static gint
1375 default_values_cmp (GParamSpec   *pspec,
1376         const GValue *value1,
1377         const GValue *value2)
1378 {
1379   return memcmp (&amp;value1-&gt;data, &amp;value2-&gt;data, sizeof (value1-&gt;data));
1380 }
1381 
1382 /**
1383  * g_param_type_register_static:
1384  * @name: 0-terminated string used as the name of the new #GParamSpec type.
1385  * @pspec_info: The #GParamSpecTypeInfo for this #GParamSpec type.
1386  *
1387  * Registers @name as the name of a new static type derived from
1388  * #G_TYPE_PARAM. The type system uses the information contained in
1389  * the #GParamSpecTypeInfo structure pointed to by @info to manage the
1390  * #GParamSpec type and its instances.
1391  *
1392  * Returns: The new type identifier.
1393  */
1394 GType
1395 g_param_type_register_static (const gchar              *name,
1396             const GParamSpecTypeInfo *pspec_info)
1397 {
1398   GTypeInfo info = {
1399     sizeof (GParamSpecClass),      /* class_size */
1400     NULL,                          /* base_init */
1401     NULL,                          /* base_destroy */
1402     param_spec_generic_class_init, /* class_init */
1403     NULL,                          /* class_destroy */
1404     NULL,                          /* class_data */
1405     0,                             /* instance_size */
1406     16,                            /* n_preallocs */
1407     NULL,                          /* instance_init */
1408   };
1409   ParamSpecClassInfo *cinfo;
1410 
1411   g_return_val_if_fail (name != NULL, 0);
1412   g_return_val_if_fail (pspec_info != NULL, 0);
1413   g_return_val_if_fail (g_type_from_name (name) == 0, 0);
1414   g_return_val_if_fail (pspec_info-&gt;instance_size &gt;= sizeof (GParamSpec), 0);
1415   g_return_val_if_fail (g_type_name (pspec_info-&gt;value_type) != NULL, 0);
1416   /* default: g_return_val_if_fail (pspec_info-&gt;value_set_default != NULL, 0); */
1417   /* optional: g_return_val_if_fail (pspec_info-&gt;value_validate != NULL, 0); */
1418   /* default: g_return_val_if_fail (pspec_info-&gt;values_cmp != NULL, 0); */
1419 
1420   info.instance_size = pspec_info-&gt;instance_size;
1421   info.n_preallocs = pspec_info-&gt;n_preallocs;
1422   info.instance_init = (GInstanceInitFunc) pspec_info-&gt;instance_init;
1423   cinfo = g_new (ParamSpecClassInfo, 1);
1424   cinfo-&gt;value_type = pspec_info-&gt;value_type;
1425   cinfo-&gt;finalize = pspec_info-&gt;finalize;
1426   cinfo-&gt;value_set_default = pspec_info-&gt;value_set_default ? pspec_info-&gt;value_set_default : default_value_set_default;
1427   cinfo-&gt;value_validate = pspec_info-&gt;value_validate;
1428   cinfo-&gt;values_cmp = pspec_info-&gt;values_cmp ? pspec_info-&gt;values_cmp : default_values_cmp;
1429   info.class_data = cinfo;
1430 
1431   return g_type_register_static (G_TYPE_PARAM, name, &amp;info, 0);
1432 }
1433 
1434 /**
1435  * g_value_set_param:
1436  * @value: a valid #GValue of type %G_TYPE_PARAM
1437  * @param: (nullable): the #GParamSpec to be set
1438  *
1439  * Set the contents of a %G_TYPE_PARAM #GValue to @param.
1440  */
1441 void
1442 g_value_set_param (GValue     *value,
1443        GParamSpec *param)
1444 {
1445   g_return_if_fail (G_VALUE_HOLDS_PARAM (value));
1446   if (param)
1447     g_return_if_fail (G_IS_PARAM_SPEC (param));
1448 
1449   if (value-&gt;data[0].v_pointer)
1450     g_param_spec_unref (value-&gt;data[0].v_pointer);
1451   value-&gt;data[0].v_pointer = param;
1452   if (value-&gt;data[0].v_pointer)
1453     g_param_spec_ref (value-&gt;data[0].v_pointer);
1454 }
1455 
1456 /**
1457  * g_value_set_param_take_ownership: (skip)
1458  * @value: a valid #GValue of type %G_TYPE_PARAM
1459  * @param: (nullable): the #GParamSpec to be set
1460  *
1461  * This is an internal function introduced mainly for C marshallers.
1462  *
1463  * Deprecated: 2.4: Use g_value_take_param() instead.
1464  */
1465 void
1466 g_value_set_param_take_ownership (GValue     *value,
1467           GParamSpec *param)
1468 {
1469   g_value_take_param (value, param);
1470 }
1471 
1472 /**
1473  * g_value_take_param: (skip)
1474  * @value: a valid #GValue of type %G_TYPE_PARAM
1475  * @param: (nullable): the #GParamSpec to be set
1476  *
1477  * Sets the contents of a %G_TYPE_PARAM #GValue to @param and takes
1478  * over the ownership of the caller&#39;s reference to @param; the caller
1479  * doesn&#39;t have to unref it any more.
1480  *
1481  * Since: 2.4
1482  */
1483 void
1484 g_value_take_param (GValue     *value,
1485         GParamSpec *param)
1486 {
1487   g_return_if_fail (G_VALUE_HOLDS_PARAM (value));
1488   if (param)
1489     g_return_if_fail (G_IS_PARAM_SPEC (param));
1490 
1491   if (value-&gt;data[0].v_pointer)
1492     g_param_spec_unref (value-&gt;data[0].v_pointer);
1493   value-&gt;data[0].v_pointer = param; /* we take over the reference count */
1494 }
1495 
1496 /**
1497  * g_value_get_param:
1498  * @value: a valid #GValue whose type is derived from %G_TYPE_PARAM
1499  *
1500  * Get the contents of a %G_TYPE_PARAM #GValue.
1501  *
1502  * Returns: (transfer none): #GParamSpec content of @value
1503  */
1504 GParamSpec*
1505 g_value_get_param (const GValue *value)
1506 {
1507   g_return_val_if_fail (G_VALUE_HOLDS_PARAM (value), NULL);
1508 
1509   return value-&gt;data[0].v_pointer;
1510 }
1511 
1512 /**
1513  * g_value_dup_param: (skip)
1514  * @value: a valid #GValue whose type is derived from %G_TYPE_PARAM
1515  *
1516  * Get the contents of a %G_TYPE_PARAM #GValue, increasing its
1517  * reference count.
1518  *
1519  * Returns: #GParamSpec content of @value, should be unreferenced when
1520  *          no longer needed.
1521  */
1522 GParamSpec*
1523 g_value_dup_param (const GValue *value)
1524 {
1525   g_return_val_if_fail (G_VALUE_HOLDS_PARAM (value), NULL);
1526 
1527   return value-&gt;data[0].v_pointer ? g_param_spec_ref (value-&gt;data[0].v_pointer) : NULL;
1528 }
1529 
1530 /**
1531  * g_param_spec_get_default_value:
1532  * @pspec: a #GParamSpec
1533  *
1534  * Gets the default value of @pspec as a pointer to a #GValue.
1535  *
1536  * The #GValue will remain valid for the life of @pspec.
1537  *
1538  * Returns: a pointer to a #GValue which must not be modified
1539  *
1540  * Since: 2.38
1541  **/
1542 const GValue *
1543 g_param_spec_get_default_value (GParamSpec *pspec)
1544 {
1545   GParamSpecPrivate *priv = g_param_spec_get_private (pspec);
1546 
1547   /* We use the type field of the GValue as the key for the once because
1548    * it will be zero before it is initialised and non-zero after.  We
1549    * have to take care that we don&#39;t write a non-zero value to the type
1550    * field before we are completely done, however, because then another
1551    * thread could come along and find the value partially-initialised.
1552    *
1553    * In order to accomplish this we store the default value in a
1554    * stack-allocated GValue.  We then set the type field in that value
1555    * to zero and copy the contents into place.  We then end by storing
1556    * the type as the last step in order to ensure that we&#39;re completely
1557    * done before a g_once_init_enter() could take the fast path in
1558    * another thread.
1559    */
1560   if (g_once_init_enter (&amp;priv-&gt;default_value.g_type))
1561     {
1562       GValue default_value = G_VALUE_INIT;
1563 
1564       g_value_init (&amp;default_value, pspec-&gt;value_type);
1565       g_param_value_set_default (pspec, &amp;default_value);
1566 
1567       /* store all but the type */
1568       memcpy (priv-&gt;default_value.data, default_value.data, sizeof (default_value.data));
1569 
1570       g_once_init_leave (&amp;priv-&gt;default_value.g_type, pspec-&gt;value_type);
1571     }
1572 
1573   return &amp;priv-&gt;default_value;
1574 }
1575 
1576 /**
1577  * g_param_spec_get_name_quark:
1578  * @pspec: a #GParamSpec
1579  *
1580  * Gets the GQuark for the name.
1581  *
1582  * Returns: the GQuark for @pspec-&gt;name.
1583  *
1584  * Since: 2.46
1585  */
1586 GQuark
1587 g_param_spec_get_name_quark (GParamSpec *pspec)
1588 {
1589   GParamSpecPrivate *priv = g_param_spec_get_private (pspec);
1590 
1591   /* Return the quark that we&#39;ve stashed away at creation time.
1592    * This lets us avoid a lock and a hash table lookup when
1593    * dispatching property change notification.
1594    */
1595 
1596   return priv-&gt;name_quark;
1597 }
    </pre>
  </body>
</html>