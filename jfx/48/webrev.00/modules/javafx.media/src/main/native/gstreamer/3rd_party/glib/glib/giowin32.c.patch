diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/giowin32.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/giowin32.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/giowin32.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/giowin32.c
@@ -89,53 +89,53 @@
 #define BUFFER_SIZE 4096
 
 typedef enum {
   G_IO_WIN32_WINDOWS_MESSAGES,  /* Windows messages */
 
-  G_IO_WIN32_FILE_DESC,     /* Unix-like file descriptors from
-                                 * _open() or _pipe(), except for
-                                 * console IO. Separate thread to read
-                                 * or write.
-                                 */
+  G_IO_WIN32_FILE_DESC,   /* Unix-like file descriptors from
+         * _open() or _pipe(), except for
+         * console IO. Separate thread to read
+         * or write.
+         */
 
-  G_IO_WIN32_CONSOLE,       /* Console IO (usually stdin, stdout, stderr) */
+  G_IO_WIN32_CONSOLE,   /* Console IO (usually stdin, stdout, stderr) */
 
-  G_IO_WIN32_SOCKET     /* Sockets. No separate thread. */
+  G_IO_WIN32_SOCKET   /* Sockets. No separate thread. */
 } GIOWin32ChannelType;
 
 struct _GIOWin32Channel {
   GIOChannel channel;
-  gint fd;          /* Either a Unix-like file handle as provided
-                                 * by the Microsoft C runtime, or a SOCKET
-                                 * as provided by WinSock.
-                                 */
+  gint fd;      /* Either a Unix-like file handle as provided
+         * by the Microsoft C runtime, or a SOCKET
+         * as provided by WinSock.
+         */
   GIOWin32ChannelType type;
 
   gboolean debug;
 
   /* Field used by G_IO_WIN32_WINDOWS_MESSAGES channels */
-  HWND hwnd;            /* Handle of window, or NULL */
+  HWND hwnd;      /* Handle of window, or NULL */
 
   /* Fields used by G_IO_WIN32_FILE_DESC channels. */
   CRITICAL_SECTION mutex;
 
-  int direction;        /* 0 means we read from it,
-                                 * 1 means we write to it.
-                                 */
+  int direction;    /* 0 means we read from it,
+         * 1 means we write to it.
+         */
 
-  gboolean running;     /* Is reader or writer thread
-                                 * running. FALSE if EOF has been
-                                 * reached by the reader thread.
-                                 */
+  gboolean running;   /* Is reader or writer thread
+         * running. FALSE if EOF has been
+         * reached by the reader thread.
+         */
 
-  gboolean needs_close;     /* If the channel has been closed while
-                                 * the reader thread was still running.
-                                 */
+  gboolean needs_close;   /* If the channel has been closed while
+         * the reader thread was still running.
+         */
 
-  guint thread_id;      /* If non-NULL the channel has or has
-                                 * had a reader or writer thread.
-                                 */
+  guint thread_id;    /* If non-NULL the channel has or has
+         * had a reader or writer thread.
+         */
   HANDLE data_avail_event;
 
   gushort revents;
 
   /* Data is kept in a circular buffer. To be able to distinguish between
@@ -146,12 +146,12 @@
    *
    * Empty:    wrp == rdp
    * Full:     (wrp + 1) % BUFFER_SIZE == rdp
    * Partial:  otherwise
    */
-  guchar *buffer;       /* (Circular) buffer */
-  gint wrp, rdp;        /* Buffer indices for writing and reading */
+  guchar *buffer;   /* (Circular) buffer */
+  gint wrp, rdp;    /* Buffer indices for writing and reading */
   HANDLE space_avail_event;
 
   /* Fields used by G_IO_WIN32_SOCKET channels */
   int event_mask;
   int last_events;
@@ -169,22 +169,22 @@
 
 static void
 g_win32_print_access_mode (int flags)
 {
   g_print ("%s%s%s%s%s%s%s%s%s%s",
-       ((flags & 0x3) == _O_RDWR ? "O_RDWR" :
-        ((flags & 0x3) == _O_RDONLY ? "O_RDONLY" :
-         ((flags & 0x3) == _O_WRONLY ? "O_WRONLY" : "0"))),
-       (flags & _O_APPEND ? "|O_APPEND" : ""),
-       (flags & _O_RANDOM ? "|O_RANDOM" : ""),
-       (flags & _O_SEQUENTIAL ? "|O_SEQUENTIAL" : ""),
-       (flags & _O_TEMPORARY ? "|O_TEMPORARY" : ""),
-       (flags & _O_CREAT ? "|O_CREAT" : ""),
-       (flags & _O_TRUNC ? "|O_TRUNC" : ""),
-       (flags & _O_EXCL ? "|O_EXCL" : ""),
-       (flags & _O_TEXT ? "|O_TEXT" : ""),
-       (flags & _O_BINARY ? "|O_BINARY" : ""));
+     ((flags & 0x3) == _O_RDWR ? "O_RDWR" :
+      ((flags & 0x3) == _O_RDONLY ? "O_RDONLY" :
+       ((flags & 0x3) == _O_WRONLY ? "O_WRONLY" : "0"))),
+     (flags & _O_APPEND ? "|O_APPEND" : ""),
+     (flags & _O_RANDOM ? "|O_RANDOM" : ""),
+     (flags & _O_SEQUENTIAL ? "|O_SEQUENTIAL" : ""),
+     (flags & _O_TEMPORARY ? "|O_TEMPORARY" : ""),
+     (flags & _O_CREAT ? "|O_CREAT" : ""),
+     (flags & _O_TRUNC ? "|O_TRUNC" : ""),
+     (flags & _O_EXCL ? "|O_EXCL" : ""),
+     (flags & _O_TEXT ? "|O_TEXT" : ""),
+     (flags & _O_BINARY ? "|O_BINARY" : ""));
 }
 
 static void
 g_win32_print_gioflags (GIOFlags flags)
 {
@@ -226,11 +226,11 @@
   BIT (ADDRESS_LIST_CHANGE);
 
 #undef BIT
 
   if ((mask & ~checked_bits) != 0)
-      bufp += sprintf (bufp, "|%#x", mask & ~checked_bits);
+    bufp += sprintf (bufp, "|%#x", mask & ~checked_bits);
 
   return g_quark_to_string (g_quark_from_string (buf));
 }
 
 static const char *
@@ -253,11 +253,11 @@
   BIT (NVAL);
 
 #undef BIT
 
   if ((condition & ~checked_bits) != 0)
-      bufp += sprintf (bufp, "|%#x", condition & ~checked_bits);
+    bufp += sprintf (bufp, "|%#x", condition & ~checked_bits);
 
   return g_quark_to_string (g_quark_from_string (buf));
 }
 
 static gboolean
@@ -318,14 +318,14 @@
 
   g_io_channel_ref ((GIOChannel *)channel);
 
   if (channel->debug)
     g_print ("read_thread %#x: start fd=%d, data_avail=%p space_avail=%p\n",
-         channel->thread_id,
-         channel->fd,
-         channel->data_avail_event,
-         channel->space_avail_event);
+       channel->thread_id,
+       channel->fd,
+       channel->data_avail_event,
+       channel->space_avail_event);
 
   channel->direction = 0;
   channel->buffer = g_malloc (BUFFER_SIZE);
   channel->rdp = channel->wrp = 0;
   channel->running = TRUE;
@@ -334,81 +334,81 @@
 
   EnterCriticalSection (&channel->mutex);
   while (channel->running)
     {
       if (channel->debug)
-    g_print ("read_thread %#x: rdp=%d, wrp=%d\n",
-         channel->thread_id, channel->rdp, channel->wrp);
+  g_print ("read_thread %#x: rdp=%d, wrp=%d\n",
+     channel->thread_id, channel->rdp, channel->wrp);
       if ((channel->wrp + 1) % BUFFER_SIZE == channel->rdp)
-    {
-      /* Buffer is full */
-      if (channel->debug)
-        g_print ("read_thread %#x: resetting space_avail\n",
-             channel->thread_id);
-      ResetEvent (channel->space_avail_event);
-      if (channel->debug)
-        g_print ("read_thread %#x: waiting for space\n",
-             channel->thread_id);
-      LeaveCriticalSection (&channel->mutex);
-      WaitForSingleObject (channel->space_avail_event, INFINITE);
-      EnterCriticalSection (&channel->mutex);
-      if (channel->debug)
-        g_print ("read_thread %#x: rdp=%d, wrp=%d\n",
-             channel->thread_id, channel->rdp, channel->wrp);
-    }
+  {
+    /* Buffer is full */
+    if (channel->debug)
+      g_print ("read_thread %#x: resetting space_avail\n",
+         channel->thread_id);
+    ResetEvent (channel->space_avail_event);
+    if (channel->debug)
+      g_print ("read_thread %#x: waiting for space\n",
+         channel->thread_id);
+    LeaveCriticalSection (&channel->mutex);
+    WaitForSingleObject (channel->space_avail_event, INFINITE);
+    EnterCriticalSection (&channel->mutex);
+    if (channel->debug)
+      g_print ("read_thread %#x: rdp=%d, wrp=%d\n",
+         channel->thread_id, channel->rdp, channel->wrp);
+  }
 
       buffer = channel->buffer + channel->wrp;
 
       /* Always leave at least one byte unused gap to be able to
        * distinguish between the full and empty condition...
        */
       nbytes = MIN ((channel->rdp + BUFFER_SIZE - channel->wrp - 1) % BUFFER_SIZE,
-            BUFFER_SIZE - channel->wrp);
+        BUFFER_SIZE - channel->wrp);
 
       if (channel->debug)
-    g_print ("read_thread %#x: calling read() for %d bytes\n",
-         channel->thread_id, nbytes);
+  g_print ("read_thread %#x: calling read() for %d bytes\n",
+     channel->thread_id, nbytes);
 
       LeaveCriticalSection (&channel->mutex);
 
       nbytes = read (channel->fd, buffer, nbytes);
 
       EnterCriticalSection (&channel->mutex);
 
       channel->revents = G_IO_IN;
       if (nbytes == 0)
-    channel->revents |= G_IO_HUP;
+  channel->revents |= G_IO_HUP;
       else if (nbytes < 0)
-    channel->revents |= G_IO_ERR;
+  channel->revents |= G_IO_ERR;
 
       if (channel->debug)
-    g_print ("read_thread %#x: read() returned %d, rdp=%d, wrp=%d\n",
-         channel->thread_id, nbytes, channel->rdp, channel->wrp);
+  g_print ("read_thread %#x: read() returned %d, rdp=%d, wrp=%d\n",
+     channel->thread_id, nbytes, channel->rdp, channel->wrp);
 
       if (nbytes <= 0)
-    break;
+  break;
 
       channel->wrp = (channel->wrp + nbytes) % BUFFER_SIZE;
       if (channel->debug)
-    g_print ("read_thread %#x: rdp=%d, wrp=%d, setting data_avail\n",
-         channel->thread_id, channel->rdp, channel->wrp);
+  g_print ("read_thread %#x: rdp=%d, wrp=%d, setting data_avail\n",
+     channel->thread_id, channel->rdp, channel->wrp);
       SetEvent (channel->data_avail_event);
     }
 
   channel->running = FALSE;
   if (channel->needs_close)
     {
       if (channel->debug)
-    g_print ("read_thread %#x: channel fd %d needs closing\n",
-         channel->thread_id, channel->fd);
+  g_print ("read_thread %#x: channel fd %d needs closing\n",
+     channel->thread_id, channel->fd);
       close (channel->fd);
       channel->fd = -1;
     }
 
   if (channel->debug)
     g_print ("read_thread %#x: EOF, rdp=%d, wrp=%d, setting data_avail\n",
-         channel->thread_id, channel->rdp, channel->wrp);
+       channel->thread_id, channel->rdp, channel->wrp);
   SetEvent (channel->data_avail_event);
   LeaveCriticalSection (&channel->mutex);
 
   g_io_channel_unref ((GIOChannel *)channel);
 
@@ -429,14 +429,14 @@
 
   g_io_channel_ref ((GIOChannel *)channel);
 
   if (channel->debug)
     g_print ("write_thread %#x: start fd=%d, data_avail=%p space_avail=%p\n",
-         channel->thread_id,
-         channel->fd,
-         channel->data_avail_event,
-         channel->space_avail_event);
+       channel->thread_id,
+       channel->fd,
+       channel->data_avail_event,
+       channel->space_avail_event);
 
   channel->direction = 1;
   channel->buffer = g_malloc (BUFFER_SIZE);
   channel->rdp = channel->wrp = 0;
   channel->running = TRUE;
@@ -451,77 +451,77 @@
 
   EnterCriticalSection (&channel->mutex);
   while (channel->running || channel->rdp != channel->wrp)
     {
       if (channel->debug)
-    g_print ("write_thread %#x: rdp=%d, wrp=%d\n",
-         channel->thread_id, channel->rdp, channel->wrp);
+  g_print ("write_thread %#x: rdp=%d, wrp=%d\n",
+     channel->thread_id, channel->rdp, channel->wrp);
       if (channel->wrp == channel->rdp)
-    {
-      /* Buffer is empty. */
-      if (channel->debug)
-        g_print ("write_thread %#x: resetting space_avail\n",
-             channel->thread_id);
-      ResetEvent (channel->space_avail_event);
-      if (channel->debug)
-        g_print ("write_thread %#x: waiting for data\n",
-             channel->thread_id);
-      channel->revents = G_IO_OUT;
-      SetEvent (channel->data_avail_event);
-      LeaveCriticalSection (&channel->mutex);
-      WaitForSingleObject (channel->space_avail_event, INFINITE);
+  {
+    /* Buffer is empty. */
+    if (channel->debug)
+      g_print ("write_thread %#x: resetting space_avail\n",
+         channel->thread_id);
+    ResetEvent (channel->space_avail_event);
+    if (channel->debug)
+      g_print ("write_thread %#x: waiting for data\n",
+         channel->thread_id);
+    channel->revents = G_IO_OUT;
+    SetEvent (channel->data_avail_event);
+    LeaveCriticalSection (&channel->mutex);
+    WaitForSingleObject (channel->space_avail_event, INFINITE);
 
-      EnterCriticalSection (&channel->mutex);
-      if (channel->rdp == channel->wrp)
-        break;
+    EnterCriticalSection (&channel->mutex);
+    if (channel->rdp == channel->wrp)
+      break;
 
-      if (channel->debug)
-        g_print ("write_thread %#x: rdp=%d, wrp=%d\n",
-             channel->thread_id, channel->rdp, channel->wrp);
-    }
+    if (channel->debug)
+      g_print ("write_thread %#x: rdp=%d, wrp=%d\n",
+         channel->thread_id, channel->rdp, channel->wrp);
+  }
 
       buffer = channel->buffer + channel->rdp;
       if (channel->rdp < channel->wrp)
-    nbytes = channel->wrp - channel->rdp;
+  nbytes = channel->wrp - channel->rdp;
       else
-    nbytes = BUFFER_SIZE - channel->rdp;
+  nbytes = BUFFER_SIZE - channel->rdp;
 
       if (channel->debug)
-    g_print ("write_thread %#x: calling write() for %d bytes\n",
-         channel->thread_id, nbytes);
+  g_print ("write_thread %#x: calling write() for %d bytes\n",
+     channel->thread_id, nbytes);
 
       LeaveCriticalSection (&channel->mutex);
       nbytes = write (channel->fd, buffer, nbytes);
       EnterCriticalSection (&channel->mutex);
 
       if (channel->debug)
-    g_print ("write_thread %#x: write(%i) returned %d, rdp=%d, wrp=%d\n",
-         channel->thread_id, channel->fd, nbytes, channel->rdp, channel->wrp);
+  g_print ("write_thread %#x: write(%i) returned %d, rdp=%d, wrp=%d\n",
+     channel->thread_id, channel->fd, nbytes, channel->rdp, channel->wrp);
 
       channel->revents = 0;
       if (nbytes > 0)
-    channel->revents |= G_IO_OUT;
+  channel->revents |= G_IO_OUT;
       else if (nbytes <= 0)
-    channel->revents |= G_IO_ERR;
+  channel->revents |= G_IO_ERR;
 
       channel->rdp = (channel->rdp + nbytes) % BUFFER_SIZE;
 
       if (nbytes <= 0)
-    break;
+  break;
 
       if (channel->debug)
-    g_print ("write_thread: setting data_avail for thread %#x\n",
-         channel->thread_id);
+  g_print ("write_thread: setting data_avail for thread %#x\n",
+     channel->thread_id);
       SetEvent (channel->data_avail_event);
     }
 
   channel->running = FALSE;
   if (channel->needs_close)
     {
       if (channel->debug)
-    g_print ("write_thread %#x: channel fd %d needs closing\n",
-         channel->thread_id, channel->fd);
+  g_print ("write_thread %#x: channel fd %d needs closing\n",
+     channel->thread_id, channel->fd);
       close (channel->fd);
       channel->fd = -1;
     }
 
   LeaveCriticalSection (&channel->mutex);
@@ -531,22 +531,22 @@
   return 0;
 }
 
 static void
 create_thread (GIOWin32Channel     *channel,
-           GIOCondition         condition,
-           unsigned (__stdcall *thread) (void *parameter))
+         GIOCondition         condition,
+         unsigned (__stdcall *thread) (void *parameter))
 {
   HANDLE thread_handle;
   int errsv;
 
   thread_handle = (HANDLE) _beginthreadex (NULL, 0, thread, channel, 0,
-                       &channel->thread_id);
+             &channel->thread_id);
   errsv = errno;
   if (thread_handle == 0)
     g_warning ("Error creating thread: %s.",
-           g_strerror (errsv));
+         g_strerror (errsv));
   else if (!CloseHandle (thread_handle))
     {
       gchar *emsg = g_win32_error_message (GetLastError ());
 
       g_warning ("Error closing thread handle: %s.", emsg);
@@ -556,67 +556,67 @@
   WaitForSingleObject (channel->space_avail_event, INFINITE);
 }
 
 static GIOStatus
 buffer_read (GIOWin32Channel *channel,
-         gchar           *dest,
-         gsize            count,
-         gsize           *bytes_read,
-         GError         **err)
+       gchar           *dest,
+       gsize            count,
+       gsize           *bytes_read,
+       GError         **err)
 {
   guint nbytes;
   guint left = count;
 
   EnterCriticalSection (&channel->mutex);
   if (channel->debug)
     g_print ("reading from thread %#x %" G_GSIZE_FORMAT " bytes, rdp=%d, wrp=%d\n",
-         channel->thread_id, count, channel->rdp, channel->wrp);
+       channel->thread_id, count, channel->rdp, channel->wrp);
 
   if (channel->wrp == channel->rdp)
     {
       LeaveCriticalSection (&channel->mutex);
       if (channel->debug)
-    g_print ("waiting for data from thread %#x\n", channel->thread_id);
+  g_print ("waiting for data from thread %#x\n", channel->thread_id);
       WaitForSingleObject (channel->data_avail_event, INFINITE);
       if (channel->debug)
-    g_print ("done waiting for data from thread %#x\n", channel->thread_id);
+  g_print ("done waiting for data from thread %#x\n", channel->thread_id);
       EnterCriticalSection (&channel->mutex);
       if (channel->wrp == channel->rdp && !channel->running)
-    {
-      if (channel->debug)
-        g_print ("wrp==rdp, !running\n");
-      LeaveCriticalSection (&channel->mutex);
+  {
+    if (channel->debug)
+      g_print ("wrp==rdp, !running\n");
+    LeaveCriticalSection (&channel->mutex);
           *bytes_read = 0;
-      return G_IO_STATUS_EOF;
-    }
+    return G_IO_STATUS_EOF;
+  }
     }
 
   if (channel->rdp < channel->wrp)
     nbytes = channel->wrp - channel->rdp;
   else
     nbytes = BUFFER_SIZE - channel->rdp;
   LeaveCriticalSection (&channel->mutex);
   nbytes = MIN (left, nbytes);
   if (channel->debug)
     g_print ("moving %d bytes from thread %#x\n",
-         nbytes, channel->thread_id);
+       nbytes, channel->thread_id);
   memcpy (dest, channel->buffer + channel->rdp, nbytes);
   dest += nbytes;
   left -= nbytes;
   EnterCriticalSection (&channel->mutex);
   channel->rdp = (channel->rdp + nbytes) % BUFFER_SIZE;
   if (channel->debug)
     g_print ("setting space_avail for thread %#x\n", channel->thread_id);
   SetEvent (channel->space_avail_event);
   if (channel->debug)
     g_print ("for thread %#x: rdp=%d, wrp=%d\n",
-         channel->thread_id, channel->rdp, channel->wrp);
+       channel->thread_id, channel->rdp, channel->wrp);
   if (channel->running && channel->wrp == channel->rdp)
     {
       if (channel->debug)
-    g_print ("resetting data_avail of thread %#x\n",
-         channel->thread_id);
+  g_print ("resetting data_avail of thread %#x\n",
+     channel->thread_id);
       ResetEvent (channel->data_avail_event);
     };
   LeaveCriticalSection (&channel->mutex);
 
   /* We have no way to indicate any errors form the actual
@@ -627,66 +627,66 @@
 }
 
 
 static GIOStatus
 buffer_write (GIOWin32Channel *channel,
-          const gchar     *dest,
-          gsize            count,
-          gsize           *bytes_written,
-          GError         **err)
+        const gchar     *dest,
+        gsize            count,
+        gsize           *bytes_written,
+        GError         **err)
 {
   guint nbytes;
   guint left = count;
 
   EnterCriticalSection (&channel->mutex);
   if (channel->debug)
     g_print ("buffer_write: writing to thread %#x %" G_GSIZE_FORMAT " bytes, rdp=%d, wrp=%d\n",
-         channel->thread_id, count, channel->rdp, channel->wrp);
+       channel->thread_id, count, channel->rdp, channel->wrp);
 
   if ((channel->wrp + 1) % BUFFER_SIZE == channel->rdp)
     {
       /* Buffer is full */
       if (channel->debug)
-    g_print ("buffer_write: tid %#x: resetting data_avail\n",
-         channel->thread_id);
+  g_print ("buffer_write: tid %#x: resetting data_avail\n",
+     channel->thread_id);
       ResetEvent (channel->data_avail_event);
       if (channel->debug)
-    g_print ("buffer_write: tid %#x: waiting for space\n",
-         channel->thread_id);
+  g_print ("buffer_write: tid %#x: waiting for space\n",
+     channel->thread_id);
       LeaveCriticalSection (&channel->mutex);
       WaitForSingleObject (channel->data_avail_event, INFINITE);
       EnterCriticalSection (&channel->mutex);
       if (channel->debug)
-    g_print ("buffer_write: tid %#x: rdp=%d, wrp=%d\n",
-         channel->thread_id, channel->rdp, channel->wrp);
+  g_print ("buffer_write: tid %#x: rdp=%d, wrp=%d\n",
+     channel->thread_id, channel->rdp, channel->wrp);
     }
 
   nbytes = MIN ((channel->rdp + BUFFER_SIZE - channel->wrp - 1) % BUFFER_SIZE,
-        BUFFER_SIZE - channel->wrp);
+    BUFFER_SIZE - channel->wrp);
 
   LeaveCriticalSection (&channel->mutex);
   nbytes = MIN (left, nbytes);
   if (channel->debug)
     g_print ("buffer_write: tid %#x: writing %d bytes\n",
-         channel->thread_id, nbytes);
+       channel->thread_id, nbytes);
   memcpy (channel->buffer + channel->wrp, dest, nbytes);
   dest += nbytes;
   left -= nbytes;
   EnterCriticalSection (&channel->mutex);
 
   channel->wrp = (channel->wrp + nbytes) % BUFFER_SIZE;
   if (channel->debug)
     g_print ("buffer_write: tid %#x: rdp=%d, wrp=%d, setting space_avail\n",
-         channel->thread_id, channel->rdp, channel->wrp);
+       channel->thread_id, channel->rdp, channel->wrp);
   SetEvent (channel->space_avail_event);
 
   if ((channel->wrp + 1) % BUFFER_SIZE == channel->rdp)
     {
       /* Buffer is full */
       if (channel->debug)
-    g_print ("buffer_write: tid %#x: resetting data_avail\n",
-         channel->thread_id);
+  g_print ("buffer_write: tid %#x: resetting data_avail\n",
+     channel->thread_id);
       ResetEvent (channel->data_avail_event);
     }
 
   LeaveCriticalSection (&channel->mutex);
 
@@ -698,11 +698,11 @@
 }
 
 
 static gboolean
 g_io_win32_prepare (GSource *source,
-            gint    *timeout)
+        gint    *timeout)
 {
   GIOWin32Watch *watch = (GIOWin32Watch *)source;
   GIOCondition buffer_condition = g_io_channel_get_buffer_condition (watch->channel);
   GIOWin32Channel *channel = (GIOWin32Channel *)watch->channel;
   int event_mask;
@@ -714,90 +714,90 @@
 
   switch (channel->type)
     {
     case G_IO_WIN32_WINDOWS_MESSAGES:
       if (channel->debug)
-    g_print (" MSG");
+  g_print (" MSG");
       break;
 
     case G_IO_WIN32_CONSOLE:
       if (channel->debug)
-    g_print (" CON");
+  g_print (" CON");
       break;
 
     case G_IO_WIN32_FILE_DESC:
       if (channel->debug)
-    g_print (" FD thread=%#x buffer_condition:{%s}"
-         "\n  watch->pollfd.events:{%s} watch->pollfd.revents:{%s} channel->revents:{%s}",
-         channel->thread_id, condition_to_string (buffer_condition),
-         condition_to_string (watch->pollfd.events),
-         condition_to_string (watch->pollfd.revents),
-         condition_to_string (channel->revents));
+  g_print (" FD thread=%#x buffer_condition:{%s}"
+     "\n  watch->pollfd.events:{%s} watch->pollfd.revents:{%s} channel->revents:{%s}",
+     channel->thread_id, condition_to_string (buffer_condition),
+     condition_to_string (watch->pollfd.events),
+     condition_to_string (watch->pollfd.revents),
+     condition_to_string (channel->revents));
 
       EnterCriticalSection (&channel->mutex);
       if (channel->running)
-    {
-      if (channel->direction == 0 && channel->wrp == channel->rdp)
-        {
-          if (channel->debug)
-        g_print ("\n  setting revents=0");
-          channel->revents = 0;
-        }
-    }
+  {
+    if (channel->direction == 0 && channel->wrp == channel->rdp)
+      {
+        if (channel->debug)
+    g_print ("\n  setting revents=0");
+        channel->revents = 0;
+      }
+  }
       else
-    {
-      if (channel->direction == 1
-          && (channel->wrp + 1) % BUFFER_SIZE == channel->rdp)
-        {
-          if (channel->debug)
-        g_print ("\n setting revents=0");
-          channel->revents = 0;
-        }
-    }
+  {
+    if (channel->direction == 1
+        && (channel->wrp + 1) % BUFFER_SIZE == channel->rdp)
+      {
+        if (channel->debug)
+    g_print ("\n setting revents=0");
+        channel->revents = 0;
+      }
+  }
       LeaveCriticalSection (&channel->mutex);
       break;
 
     case G_IO_WIN32_SOCKET:
       if (channel->debug)
-    g_print (" SOCK");
+  g_print (" SOCK");
       event_mask = 0;
       if (watch->condition & G_IO_IN)
-    event_mask |= (FD_READ | FD_ACCEPT);
+  event_mask |= (FD_READ | FD_ACCEPT);
       if (watch->condition & G_IO_OUT)
-    event_mask |= (FD_WRITE | FD_CONNECT);
+  event_mask |= (FD_WRITE | FD_CONNECT);
       event_mask |= FD_CLOSE;
 
       if (channel->event_mask != event_mask)
-    {
+  {
+    if (channel->debug)
+      g_print ("\n  WSAEventSelect(%d,%p,{%s})",
+         channel->fd, (HANDLE) watch->pollfd.fd,
+         event_mask_to_string (event_mask));
+    if (WSAEventSelect (channel->fd, (HANDLE) watch->pollfd.fd,
+            event_mask) == SOCKET_ERROR)
       if (channel->debug)
-        g_print ("\n  WSAEventSelect(%d,%p,{%s})",
-             channel->fd, (HANDLE) watch->pollfd.fd,
-             event_mask_to_string (event_mask));
-      if (WSAEventSelect (channel->fd, (HANDLE) watch->pollfd.fd,
-                  event_mask) == SOCKET_ERROR)
-        if (channel->debug)
-          {
-        gchar *emsg = g_win32_error_message (WSAGetLastError ());
+        {
+    gchar *emsg = g_win32_error_message (WSAGetLastError ());
 
-        g_print (" failed: %s", emsg);
-        g_free (emsg);
-          }
-      channel->event_mask = event_mask;
+    g_print (" failed: %s", emsg);
+    g_free (emsg);
+        }
+    channel->event_mask = event_mask;
 
-      if (channel->debug)
-        g_print ("\n  setting last_events=0");
-      channel->last_events = 0;
+    if (channel->debug)
+      g_print ("\n  setting last_events=0");
+    channel->last_events = 0;
 
-      if ((event_mask & FD_WRITE) &&
-          channel->ever_writable &&
-          !channel->write_would_have_blocked)
-        {
-          if (channel->debug)
-        g_print (" WSASetEvent(%p)", (WSAEVENT) watch->pollfd.fd);
-          WSASetEvent ((WSAEVENT) watch->pollfd.fd);
-        }
-    }
+    if ((event_mask & FD_WRITE) &&
+        channel->ever_writable &&
+        !channel->write_would_have_blocked)
+      {
+        if (channel->debug)
+    g_print (" WSASetEvent(%p)", (WSAEVENT) watch->pollfd.fd);
+        WSASetEvent ((WSAEVENT) watch->pollfd.fd);
+      }
+  }
       break;
 
     default:
       g_assert_not_reached ();
       g_abort ();
@@ -822,128 +822,128 @@
 
   switch (channel->type)
     {
     case G_IO_WIN32_WINDOWS_MESSAGES:
       if (channel->debug)
-    g_print (" MSG\n");
+  g_print (" MSG\n");
       return (PeekMessage (&msg, channel->hwnd, 0, 0, PM_NOREMOVE));
 
     case G_IO_WIN32_FILE_DESC:
       if (channel->debug)
-    g_print (" FD thread=%#x buffer_condition=%s\n"
-         "  watch->pollfd.events={%s} watch->pollfd.revents={%s} channel->revents={%s}\n",
-         channel->thread_id, condition_to_string (buffer_condition),
-         condition_to_string (watch->pollfd.events),
-         condition_to_string (watch->pollfd.revents),
-         condition_to_string (channel->revents));
+  g_print (" FD thread=%#x buffer_condition=%s\n"
+     "  watch->pollfd.events={%s} watch->pollfd.revents={%s} channel->revents={%s}\n",
+     channel->thread_id, condition_to_string (buffer_condition),
+     condition_to_string (watch->pollfd.events),
+     condition_to_string (watch->pollfd.revents),
+     condition_to_string (channel->revents));
 
       watch->pollfd.revents = (watch->pollfd.events & channel->revents);
 
       return ((watch->pollfd.revents | buffer_condition) & watch->condition);
 
     case G_IO_WIN32_CONSOLE:
       if (channel->debug)
-    g_print (" CON\n");
+  g_print (" CON\n");
       if (watch->channel->is_writeable)
-    return TRUE;
+  return TRUE;
       else if (watch->channel->is_readable)
         {
-      INPUT_RECORD buffer;
-      DWORD n;
-      if (PeekConsoleInput ((HANDLE) watch->pollfd.fd, &buffer, 1, &n) &&
-          n == 1)
-        {
-          /* _kbhit() does quite complex processing to find out
-           * whether at least one of the key events pending corresponds
-           * to a "real" character that can be read.
-           */
-          if (_kbhit ())
-        return TRUE;
-
-          /* Discard all other kinds of events */
-          ReadConsoleInput ((HANDLE) watch->pollfd.fd, &buffer, 1, &n);
-        }
+    INPUT_RECORD buffer;
+    DWORD n;
+    if (PeekConsoleInput ((HANDLE) watch->pollfd.fd, &buffer, 1, &n) &&
+        n == 1)
+      {
+        /* _kbhit() does quite complex processing to find out
+         * whether at least one of the key events pending corresponds
+         * to a "real" character that can be read.
+         */
+        if (_kbhit ())
+    return TRUE;
+
+        /* Discard all other kinds of events */
+        ReadConsoleInput ((HANDLE) watch->pollfd.fd, &buffer, 1, &n);
+      }
         }
       return FALSE;
 
     case G_IO_WIN32_SOCKET:
       if (channel->debug)
-    g_print (" SOCK");
+  g_print (" SOCK");
       if (channel->last_events & FD_WRITE)
-    {
-      if (channel->debug)
-        g_print (" sock=%d event=%p last_events has FD_WRITE",
-             channel->fd, (HANDLE) watch->pollfd.fd);
-    }
+  {
+    if (channel->debug)
+      g_print (" sock=%d event=%p last_events has FD_WRITE",
+         channel->fd, (HANDLE) watch->pollfd.fd);
+  }
       else
-    {
-      WSAEnumNetworkEvents (channel->fd, 0, &events);
+  {
+    WSAEnumNetworkEvents (channel->fd, 0, &events);
 
-      if (channel->debug)
-        g_print ("\n  revents={%s} condition={%s}"
-             "\n  WSAEnumNetworkEvents(%d,0) sets events={%s}",
-             condition_to_string (watch->pollfd.revents),
-             condition_to_string (watch->condition),
-             channel->fd,
-             event_mask_to_string (events.lNetworkEvents));
-
-      if (watch->pollfd.revents != 0 &&
-          events.lNetworkEvents == 0 &&
-          !(channel->event_mask & FD_WRITE))
-        {
-          channel->event_mask = 0;
-          if (channel->debug)
-        g_print ("\n  WSAEventSelect(%d,%p,{})",
-             channel->fd, (HANDLE) watch->pollfd.fd);
-          WSAEventSelect (channel->fd, (HANDLE) watch->pollfd.fd, 0);
-          if (channel->debug)
-        g_print ("  ResetEvent(%p)",
-             (HANDLE) watch->pollfd.fd);
-          ResetEvent ((HANDLE) watch->pollfd.fd);
-        }
-      else if (events.lNetworkEvents & FD_WRITE)
-        channel->ever_writable = TRUE;
-      channel->last_events = events.lNetworkEvents;
-    }
+    if (channel->debug)
+      g_print ("\n  revents={%s} condition={%s}"
+         "\n  WSAEnumNetworkEvents(%d,0) sets events={%s}",
+         condition_to_string (watch->pollfd.revents),
+         condition_to_string (watch->condition),
+         channel->fd,
+         event_mask_to_string (events.lNetworkEvents));
+
+    if (watch->pollfd.revents != 0 &&
+        events.lNetworkEvents == 0 &&
+        !(channel->event_mask & FD_WRITE))
+      {
+        channel->event_mask = 0;
+        if (channel->debug)
+    g_print ("\n  WSAEventSelect(%d,%p,{})",
+       channel->fd, (HANDLE) watch->pollfd.fd);
+        WSAEventSelect (channel->fd, (HANDLE) watch->pollfd.fd, 0);
+        if (channel->debug)
+    g_print ("  ResetEvent(%p)",
+       (HANDLE) watch->pollfd.fd);
+        ResetEvent ((HANDLE) watch->pollfd.fd);
+      }
+    else if (events.lNetworkEvents & FD_WRITE)
+      channel->ever_writable = TRUE;
+    channel->last_events = events.lNetworkEvents;
+  }
 
       watch->pollfd.revents = 0;
       if (channel->last_events & (FD_READ | FD_ACCEPT))
-    watch->pollfd.revents |= G_IO_IN;
+  watch->pollfd.revents |= G_IO_IN;
 
       if (channel->last_events & FD_WRITE)
-    watch->pollfd.revents |= G_IO_OUT;
+  watch->pollfd.revents |= G_IO_OUT;
       else
-    {
-      /* We have called WSAEnumNetworkEvents() above but it didn't
-       * set FD_WRITE.
-       */
-      if (events.lNetworkEvents & FD_CONNECT)
-        {
-          if (events.iErrorCode[FD_CONNECT_BIT] == 0)
-        watch->pollfd.revents |= G_IO_OUT;
-          else
-        watch->pollfd.revents |= (G_IO_HUP | G_IO_ERR);
-        }
-      if (watch->pollfd.revents == 0 && (channel->last_events & (FD_CLOSE)))
-        watch->pollfd.revents |= G_IO_HUP;
-    }
+  {
+    /* We have called WSAEnumNetworkEvents() above but it didn't
+     * set FD_WRITE.
+     */
+    if (events.lNetworkEvents & FD_CONNECT)
+      {
+        if (events.iErrorCode[FD_CONNECT_BIT] == 0)
+    watch->pollfd.revents |= G_IO_OUT;
+        else
+    watch->pollfd.revents |= (G_IO_HUP | G_IO_ERR);
+      }
+    if (watch->pollfd.revents == 0 && (channel->last_events & (FD_CLOSE)))
+      watch->pollfd.revents |= G_IO_HUP;
+  }
 
       /* Regardless of WSAEnumNetworkEvents() result, if watching for
        * writability, and if we have ever got a FD_WRITE event, and
        * unless last write would have blocked, set G_IO_OUT. But never
        * set both G_IO_OUT and G_IO_HUP.
        */
       if (!(watch->pollfd.revents & G_IO_HUP) &&
-      channel->ever_writable &&
-      !channel->write_would_have_blocked &&
-      (channel->event_mask & FD_WRITE))
-    watch->pollfd.revents |= G_IO_OUT;
+    channel->ever_writable &&
+    !channel->write_would_have_blocked &&
+    (channel->event_mask & FD_WRITE))
+  watch->pollfd.revents |= G_IO_OUT;
 
       if (channel->debug)
-    g_print ("\n  revents={%s} retval={%s}\n",
-         condition_to_string (watch->pollfd.revents),
-         condition_to_string ((watch->pollfd.revents | buffer_condition) & watch->condition));
+  g_print ("\n  revents={%s} retval={%s}\n",
+     condition_to_string (watch->pollfd.revents),
+     condition_to_string ((watch->pollfd.revents | buffer_condition) & watch->condition));
 
       return ((watch->pollfd.revents | buffer_condition) & watch->condition);
 
     default:
       g_assert_not_reached ();
@@ -951,34 +951,34 @@
     }
 }
 
 static gboolean
 g_io_win32_dispatch (GSource     *source,
-             GSourceFunc  callback,
-             gpointer     user_data)
+         GSourceFunc  callback,
+         gpointer     user_data)
 {
   GIOFunc func = (GIOFunc)callback;
   GIOWin32Watch *watch = (GIOWin32Watch *)source;
   GIOWin32Channel *channel = (GIOWin32Channel *)watch->channel;
   GIOCondition buffer_condition = g_io_channel_get_buffer_condition (watch->channel);
 
   if (!func)
     {
       g_warning ("IO Watch dispatched without callback. "
-         "You must call g_source_connect().");
+     "You must call g_source_connect().");
       return FALSE;
     }
 
   if (channel->debug)
     g_print ("g_io_win32_dispatch: pollfd.revents=%s condition=%s result=%s\n",
-         condition_to_string (watch->pollfd.revents),
-         condition_to_string (watch->condition),
-         condition_to_string ((watch->pollfd.revents | buffer_condition) & watch->condition));
+       condition_to_string (watch->pollfd.revents),
+       condition_to_string (watch->condition),
+       condition_to_string ((watch->pollfd.revents | buffer_condition) & watch->condition));
 
   return (*func) (watch->channel,
-          (watch->pollfd.revents | buffer_condition) & watch->condition,
-          user_data);
+      (watch->pollfd.revents | buffer_condition) & watch->condition,
+      user_data);
 }
 
 static void
 g_io_win32_finalize (GSource *source)
 {
@@ -990,26 +990,26 @@
 
   switch (channel->type)
     {
     case G_IO_WIN32_WINDOWS_MESSAGES:
       if (channel->debug)
-    g_print (" MSG");
+  g_print (" MSG");
       break;
 
     case G_IO_WIN32_CONSOLE:
       if (channel->debug)
-    g_print (" CON");
+  g_print (" CON");
       break;
 
     case G_IO_WIN32_FILE_DESC:
       if (channel->debug)
-    g_print (" FD thread=%#x", channel->thread_id);
+  g_print (" FD thread=%#x", channel->thread_id);
       break;
 
     case G_IO_WIN32_SOCKET:
       if (channel->debug)
-    g_print (" SOCK sock=%d", channel->fd);
+  g_print (" SOCK sock=%d", channel->fd);
       break;
 
     default:
       g_assert_not_reached ();
       g_abort ();
@@ -1026,14 +1026,14 @@
   g_io_win32_finalize
 };
 
 static GIOStatus
 g_io_win32_msg_read (GIOChannel *channel,
-             gchar      *buf,
-             gsize       count,
-             gsize      *bytes_read,
-             GError    **err)
+         gchar      *buf,
+         gsize       count,
+         gsize      *bytes_read,
+         GError    **err)
 {
   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
   MSG msg;               /* In case of alignment problems */
 
   *bytes_read = 0;
@@ -1045,11 +1045,11 @@
       return G_IO_STATUS_ERROR;
     }
 
   if (win32_channel->debug)
     g_print ("g_io_win32_msg_read: channel=%p hwnd=%p\n",
-         channel, win32_channel->hwnd);
+       channel, win32_channel->hwnd);
   if (!PeekMessage (&msg, win32_channel->hwnd, 0, 0, PM_REMOVE))
     return G_IO_STATUS_AGAIN;
 
   memmove (buf, &msg, sizeof (MSG));
   *bytes_read = sizeof (MSG);
@@ -1057,14 +1057,14 @@
   return G_IO_STATUS_NORMAL;
 }
 
 static GIOStatus
 g_io_win32_msg_write (GIOChannel  *channel,
-              const gchar *buf,
-              gsize        count,
-              gsize       *bytes_written,
-              GError     **err)
+          const gchar *buf,
+          gsize        count,
+          gsize       *bytes_written,
+          GError     **err)
 {
   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
   MSG msg;
 
   *bytes_written = 0;
@@ -1093,11 +1093,11 @@
   return G_IO_STATUS_NORMAL;
 }
 
 static GIOStatus
 g_io_win32_msg_close (GIOChannel *channel,
-              GError    **err)
+          GError    **err)
 {
   /* Nothing to be done. Or should we set hwnd to some invalid value? */
 
   return G_IO_STATUS_NORMAL;
 }
@@ -1113,60 +1113,60 @@
   DeleteCriticalSection (&win32_channel->mutex);
 
   if (win32_channel->data_avail_event)
     if (!CloseHandle (win32_channel->data_avail_event))
       if (win32_channel->debug)
-    {
-      gchar *emsg = g_win32_error_message (GetLastError ());
+  {
+    gchar *emsg = g_win32_error_message (GetLastError ());
 
-      g_print ("  CloseHandle(%p) failed: %s\n",
-           win32_channel->data_avail_event, emsg);
-      g_free (emsg);
-    }
+    g_print ("  CloseHandle(%p) failed: %s\n",
+       win32_channel->data_avail_event, emsg);
+    g_free (emsg);
+  }
 
   g_free (win32_channel->buffer);
 
   if (win32_channel->space_avail_event)
     if (!CloseHandle (win32_channel->space_avail_event))
       if (win32_channel->debug)
-    {
-      gchar *emsg = g_win32_error_message (GetLastError ());
+  {
+    gchar *emsg = g_win32_error_message (GetLastError ());
 
-      g_print ("  CloseHandle(%p) failed: %s\n",
-           win32_channel->space_avail_event, emsg);
-      g_free (emsg);
-    }
+    g_print ("  CloseHandle(%p) failed: %s\n",
+       win32_channel->space_avail_event, emsg);
+    g_free (emsg);
+  }
 
   if (win32_channel->type == G_IO_WIN32_SOCKET &&
       win32_channel->fd != -1)
     if (WSAEventSelect (win32_channel->fd, NULL, 0) == SOCKET_ERROR)
       if (win32_channel->debug)
-    {
-      gchar *emsg = g_win32_error_message (WSAGetLastError ());
+  {
+    gchar *emsg = g_win32_error_message (WSAGetLastError ());
 
-      g_print ("  WSAEventSelect(%d,NULL,{}) failed: %s\n",
-           win32_channel->fd, emsg);
-      g_free (emsg);
-    }
+    g_print ("  WSAEventSelect(%d,NULL,{}) failed: %s\n",
+       win32_channel->fd, emsg);
+    g_free (emsg);
+  }
 
   if (win32_channel->event)
     if (!WSACloseEvent (win32_channel->event))
       if (win32_channel->debug)
-    {
-      gchar *emsg = g_win32_error_message (WSAGetLastError ());
+  {
+    gchar *emsg = g_win32_error_message (WSAGetLastError ());
 
-      g_print ("  WSACloseEvent(%p) failed: %s\n",
-           win32_channel->event, emsg);
-      g_free (emsg);
-    }
+    g_print ("  WSACloseEvent(%p) failed: %s\n",
+       win32_channel->event, emsg);
+    g_free (emsg);
+  }
 
   g_free (win32_channel);
 }
 
 static GSource *
 g_io_win32_msg_create_watch (GIOChannel   *channel,
-                 GIOCondition  condition)
+           GIOCondition  condition)
 {
   GIOWin32Watch *watch;
   GSource *source;
 
   source = g_source_new (&g_io_watch_funcs, sizeof (GIOWin32Watch));
@@ -1186,22 +1186,22 @@
   return source;
 }
 
 static GIOStatus
 g_io_win32_fd_and_console_read (GIOChannel *channel,
-                gchar      *buf,
-                gsize       count,
-                gsize      *bytes_read,
-                GError    **err)
+        gchar      *buf,
+        gsize       count,
+        gsize      *bytes_read,
+        GError    **err)
 {
   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
   gint result;
   int errsv;
 
   if (win32_channel->debug)
     g_print ("g_io_win32_fd_read: fd=%d count=%" G_GSIZE_FORMAT "\n",
-         win32_channel->fd, count);
+       win32_channel->fd, count);
 
   if (win32_channel->thread_id)
     {
       return buffer_read (win32_channel, buf, count, bytes_read, err);
     }
@@ -1217,32 +1217,32 @@
       *bytes_read = 0;
 
       switch (errsv)
         {
 #ifdef EAGAIN
-    case EAGAIN:
-      return G_IO_STATUS_AGAIN;
+  case EAGAIN:
+    return G_IO_STATUS_AGAIN;
 #endif
-    default:
-      g_set_error_literal (err, G_IO_CHANNEL_ERROR,
+  default:
+    g_set_error_literal (err, G_IO_CHANNEL_ERROR,
                                g_io_channel_error_from_errno (errsv),
                                g_strerror (errsv));
-      return G_IO_STATUS_ERROR;
+    return G_IO_STATUS_ERROR;
         }
     }
 
   *bytes_read = result;
 
   return (result > 0) ? G_IO_STATUS_NORMAL : G_IO_STATUS_EOF;
 }
 
 static GIOStatus
 g_io_win32_fd_and_console_write (GIOChannel  *channel,
-                 const gchar *buf,
-                 gsize        count,
-                 gsize       *bytes_written,
-                 GError     **err)
+         const gchar *buf,
+         gsize        count,
+         gsize       *bytes_written,
+         GError     **err)
 {
   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
   gint result;
   int errsv;
 
@@ -1254,40 +1254,40 @@
   result = write (win32_channel->fd, buf, count);
   errsv = errno;
 
   if (win32_channel->debug)
     g_print ("g_io_win32_fd_write: fd=%d count=%" G_GSIZE_FORMAT " => %d\n",
-         win32_channel->fd, count, result);
+       win32_channel->fd, count, result);
 
   if (result < 0)
     {
       *bytes_written = 0;
 
       switch (errsv)
         {
 #ifdef EAGAIN
-    case EAGAIN:
-      return G_IO_STATUS_AGAIN;
+  case EAGAIN:
+    return G_IO_STATUS_AGAIN;
 #endif
-    default:
-      g_set_error_literal (err, G_IO_CHANNEL_ERROR,
+  default:
+    g_set_error_literal (err, G_IO_CHANNEL_ERROR,
                                g_io_channel_error_from_errno (errsv),
                                g_strerror (errsv));
-      return G_IO_STATUS_ERROR;
+    return G_IO_STATUS_ERROR;
         }
     }
 
   *bytes_written = result;
 
   return G_IO_STATUS_NORMAL;
 }
 
 static GIOStatus
 g_io_win32_fd_seek (GIOChannel *channel,
-            gint64      offset,
-            GSeekType   type,
-            GError    **err)
+        gint64      offset,
+        GSeekType   type,
+        GError    **err)
 {
   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
   int whence, errsv;
   off_t tmp_offset;
   off_t result;
@@ -1332,39 +1332,39 @@
   return G_IO_STATUS_NORMAL;
 }
 
 static GIOStatus
 g_io_win32_fd_close (GIOChannel *channel,
-                 GError    **err)
+               GError    **err)
 {
   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
 
   if (win32_channel->debug)
     g_print ("g_io_win32_fd_close: thread=%#x: fd=%d\n",
-         win32_channel->thread_id,
-         win32_channel->fd);
+       win32_channel->thread_id,
+       win32_channel->fd);
   EnterCriticalSection (&win32_channel->mutex);
   if (win32_channel->running)
     {
       if (win32_channel->debug)
-    g_print ("thread %#x: running, marking fd %d for later close\n",
-         win32_channel->thread_id, win32_channel->fd);
+  g_print ("thread %#x: running, marking fd %d for later close\n",
+     win32_channel->thread_id, win32_channel->fd);
       win32_channel->running = FALSE;
       win32_channel->needs_close = TRUE;
       if (win32_channel->direction == 0)
-    SetEvent (win32_channel->data_avail_event);
+  SetEvent (win32_channel->data_avail_event);
       else
-    SetEvent (win32_channel->space_avail_event);
+  SetEvent (win32_channel->space_avail_event);
     }
   else
     {
       if (win32_channel->debug)
-    g_print ("closing fd %d\n", win32_channel->fd);
+  g_print ("closing fd %d\n", win32_channel->fd);
       close (win32_channel->fd);
       if (win32_channel->debug)
-    g_print ("closed fd %d, setting to -1\n",
-         win32_channel->fd);
+  g_print ("closed fd %d, setting to -1\n",
+     win32_channel->fd);
       win32_channel->fd = -1;
     }
   LeaveCriticalSection (&win32_channel->mutex);
 
   /* FIXME error detection? */
@@ -1372,11 +1372,11 @@
   return G_IO_STATUS_NORMAL;
 }
 
 static GSource *
 g_io_win32_fd_create_watch (GIOChannel    *channel,
-                GIOCondition   condition)
+          GIOCondition   condition)
 {
   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
   GSource *source = g_source_new (&g_io_watch_funcs, sizeof (GIOWin32Watch));
   GIOWin32Watch *watch = (GIOWin32Watch *)source;
 
@@ -1391,31 +1391,31 @@
   watch->pollfd.fd = (gintptr) win32_channel->data_avail_event;
   watch->pollfd.events = condition;
 
   if (win32_channel->debug)
     g_print ("g_io_win32_fd_create_watch: channel=%p fd=%d condition={%s} event=%p\n",
-         channel, win32_channel->fd,
-         condition_to_string (condition), (HANDLE) watch->pollfd.fd);
+       channel, win32_channel->fd,
+       condition_to_string (condition), (HANDLE) watch->pollfd.fd);
 
   EnterCriticalSection (&win32_channel->mutex);
   if (win32_channel->thread_id == 0)
     {
       if (condition & G_IO_IN)
-    create_thread (win32_channel, condition, read_thread);
+  create_thread (win32_channel, condition, read_thread);
       else if (condition & G_IO_OUT)
-    create_thread (win32_channel, condition, write_thread);
+  create_thread (win32_channel, condition, write_thread);
     }
 
   g_source_add_poll (source, &watch->pollfd);
   LeaveCriticalSection (&win32_channel->mutex);
 
   return source;
 }
 
 static GIOStatus
 g_io_win32_console_close (GIOChannel *channel,
-                  GError    **err)
+              GError    **err)
 {
   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
 
   if (close (win32_channel->fd) < 0)
     {
@@ -1429,11 +1429,11 @@
   return G_IO_STATUS_NORMAL;
 }
 
 static GSource *
 g_io_win32_console_create_watch (GIOChannel    *channel,
-                 GIOCondition   condition)
+         GIOCondition   condition)
 {
   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
   GSource *source = g_source_new (&g_io_watch_funcs, sizeof (GIOWin32Watch));
   GIOWin32Watch *watch = (GIOWin32Watch *)source;
 
@@ -1450,23 +1450,23 @@
   return source;
 }
 
 static GIOStatus
 g_io_win32_sock_read (GIOChannel *channel,
-              gchar      *buf,
-              gsize       count,
-              gsize      *bytes_read,
-              GError    **err)
+          gchar      *buf,
+          gsize       count,
+          gsize      *bytes_read,
+          GError    **err)
 {
   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
   gint result;
   GIOChannelError error;
   int winsock_error;
 
   if (win32_channel->debug)
     g_print ("g_io_win32_sock_read: channel=%p sock=%d count=%" G_GSIZE_FORMAT,
-         channel, win32_channel->fd, count);
+       channel, win32_channel->fd, count);
 
   result = recv (win32_channel->fd, buf, count, 0);
   if (result == SOCKET_ERROR)
     winsock_error = WSAGetLastError ();
 
@@ -1476,58 +1476,58 @@
   if (result == SOCKET_ERROR)
     {
       gchar *emsg = g_win32_error_message (winsock_error);
 
       if (win32_channel->debug)
-    g_print (" %s\n", emsg);
+  g_print (" %s\n", emsg);
 
       *bytes_read = 0;
 
       switch (winsock_error)
-    {
-    case WSAEINVAL:
+  {
+  case WSAEINVAL:
           error = G_IO_CHANNEL_ERROR_INVAL;
           break;
-    case WSAEWOULDBLOCK:
-      g_free (emsg);
+  case WSAEWOULDBLOCK:
+    g_free (emsg);
           return G_IO_STATUS_AGAIN;
-    default:
-      error = G_IO_CHANNEL_ERROR_FAILED;
+  default:
+    error = G_IO_CHANNEL_ERROR_FAILED;
           break;
-    }
+  }
       g_set_error_literal (err, G_IO_CHANNEL_ERROR, error, emsg);
       g_free (emsg);
 
       return G_IO_STATUS_ERROR;
     }
   else
     {
       if (win32_channel->debug)
-    g_print ("\n");
+  g_print ("\n");
       *bytes_read = result;
       if (result == 0)
-    return G_IO_STATUS_EOF;
+  return G_IO_STATUS_EOF;
       else
-    return G_IO_STATUS_NORMAL;
+  return G_IO_STATUS_NORMAL;
     }
 }
 
 static GIOStatus
 g_io_win32_sock_write (GIOChannel  *channel,
-               const gchar *buf,
-               gsize        count,
-               gsize       *bytes_written,
-               GError     **err)
+           const gchar *buf,
+           gsize        count,
+           gsize       *bytes_written,
+           GError     **err)
 {
   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
   gint result;
   GIOChannelError error;
   int winsock_error;
 
   if (win32_channel->debug)
     g_print ("g_io_win32_sock_write: channel=%p sock=%d count=%" G_GSIZE_FORMAT,
-         channel, win32_channel->fd, count);
+       channel, win32_channel->fd, count);
 
   result = send (win32_channel->fd, buf, count, 0);
   if (result == SOCKET_ERROR)
     winsock_error = WSAGetLastError ();
 
@@ -1537,55 +1537,55 @@
   if (result == SOCKET_ERROR)
     {
       gchar *emsg = g_win32_error_message (winsock_error);
 
       if (win32_channel->debug)
-    g_print (" %s\n", emsg);
+  g_print (" %s\n", emsg);
 
       *bytes_written = 0;
 
       switch (winsock_error)
-    {
-    case WSAEINVAL:
-      error = G_IO_CHANNEL_ERROR_INVAL;
+  {
+  case WSAEINVAL:
+    error = G_IO_CHANNEL_ERROR_INVAL;
           break;
-    case WSAEWOULDBLOCK:
-      win32_channel->write_would_have_blocked = TRUE;
-      win32_channel->last_events = 0;
-      g_free (emsg);
+  case WSAEWOULDBLOCK:
+    win32_channel->write_would_have_blocked = TRUE;
+    win32_channel->last_events = 0;
+    g_free (emsg);
           return G_IO_STATUS_AGAIN;
-    default:
-      error = G_IO_CHANNEL_ERROR_FAILED;
+  default:
+    error = G_IO_CHANNEL_ERROR_FAILED;
           break;
-    }
+  }
       g_set_error_literal (err, G_IO_CHANNEL_ERROR, error, emsg);
       g_free (emsg);
 
       return G_IO_STATUS_ERROR;
     }
   else
     {
       if (win32_channel->debug)
-    g_print ("\n");
+  g_print ("\n");
       *bytes_written = result;
       win32_channel->write_would_have_blocked = FALSE;
 
       return G_IO_STATUS_NORMAL;
     }
 }
 
 static GIOStatus
 g_io_win32_sock_close (GIOChannel *channel,
-               GError    **err)
+           GError    **err)
 {
   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
 
   if (win32_channel->fd != -1)
     {
       if (win32_channel->debug)
-    g_print ("g_io_win32_sock_close: channel=%p sock=%d\n",
-         channel, win32_channel->fd);
+  g_print ("g_io_win32_sock_close: channel=%p sock=%d\n",
+     channel, win32_channel->fd);
 
       closesocket (win32_channel->fd);
       win32_channel->fd = -1;
     }
 
@@ -1594,11 +1594,11 @@
   return G_IO_STATUS_NORMAL;
 }
 
 static GSource *
 g_io_win32_sock_create_watch (GIOChannel    *channel,
-                  GIOCondition   condition)
+            GIOCondition   condition)
 {
   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
   GSource *source = g_source_new (&g_io_watch_funcs, sizeof (GIOWin32Watch));
   GIOWin32Watch *watch = (GIOWin32Watch *)source;
 
@@ -1613,12 +1613,12 @@
   watch->pollfd.fd = (gintptr) win32_channel->event;
   watch->pollfd.events = condition;
 
   if (win32_channel->debug)
     g_print ("g_io_win32_sock_create_watch: channel=%p sock=%d event=%p condition={%s}\n",
-         channel, win32_channel->fd, (HANDLE) watch->pollfd.fd,
-         condition_to_string (watch->condition));
+       channel, win32_channel->fd, (HANDLE) watch->pollfd.fd,
+       condition_to_string (watch->condition));
 
   g_source_add_poll (source, &watch->pollfd);
 
   return source;
 }
@@ -1761,12 +1761,12 @@
   return channel;
 }
 
 static GIOStatus
 g_io_win32_unimpl_set_flags (GIOChannel *channel,
-                 GIOFlags    flags,
-                 GError    **err)
+           GIOFlags    flags,
+           GError    **err)
 {
   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
 
   if (win32_channel->debug)
     {
@@ -1782,30 +1782,30 @@
   return G_IO_STATUS_ERROR;
 }
 
 static GIOFlags
 g_io_win32_fd_get_flags_internal (GIOChannel      *channel,
-                  struct _stati64 *st)
+          struct _stati64 *st)
 {
   GIOWin32Channel *win32_channel = (GIOWin32Channel *) channel;
   gchar c;
   DWORD count;
 
   if (st->st_mode & _S_IFIFO)
     {
       channel->is_readable =
-    (PeekNamedPipe ((HANDLE) _get_osfhandle (win32_channel->fd), &c, 0, &count, NULL, NULL) != 0) || GetLastError () == ERROR_BROKEN_PIPE;
+  (PeekNamedPipe ((HANDLE) _get_osfhandle (win32_channel->fd), &c, 0, &count, NULL, NULL) != 0) || GetLastError () == ERROR_BROKEN_PIPE;
       channel->is_writeable =
-    (WriteFile ((HANDLE) _get_osfhandle (win32_channel->fd), &c, 0, &count, NULL) != 0);
+  (WriteFile ((HANDLE) _get_osfhandle (win32_channel->fd), &c, 0, &count, NULL) != 0);
       channel->is_seekable  = FALSE;
     }
   else
     {
       channel->is_readable =
-    (ReadFile ((HANDLE) _get_osfhandle (win32_channel->fd), &c, 0, &count, NULL) != 0);
+  (ReadFile ((HANDLE) _get_osfhandle (win32_channel->fd), &c, 0, &count, NULL) != 0);
       channel->is_writeable =
-    (WriteFile ((HANDLE) _get_osfhandle (win32_channel->fd), &c, 0, &count, NULL) != 0);
+  (WriteFile ((HANDLE) _get_osfhandle (win32_channel->fd), &c, 0, &count, NULL) != 0);
       channel->is_seekable = TRUE;
     }
 
   /* XXX: G_IO_FLAG_APPEND */
   /* XXX: G_IO_FLAG_NONBLOCK */
@@ -1861,12 +1861,12 @@
   return 0;
 }
 
 static GIOStatus
 g_io_win32_sock_set_flags (GIOChannel *channel,
-               GIOFlags    flags,
-               GError    **err)
+         GIOFlags    flags,
+         GError    **err)
 {
   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
   u_long arg;
 
   if (win32_channel->debug)
@@ -1878,35 +1878,35 @@
 
   if (flags & G_IO_FLAG_NONBLOCK)
     {
       arg = 1;
       if (ioctlsocket (win32_channel->fd, FIONBIO, &arg) == SOCKET_ERROR)
-    {
-      gchar *emsg = g_win32_error_message (WSAGetLastError ());
+  {
+    gchar *emsg = g_win32_error_message (WSAGetLastError ());
 
-      g_set_error_literal (err, G_IO_CHANNEL_ERROR,
-                   G_IO_CHANNEL_ERROR_FAILED,
-                   emsg);
-      g_free (emsg);
+    g_set_error_literal (err, G_IO_CHANNEL_ERROR,
+             G_IO_CHANNEL_ERROR_FAILED,
+             emsg);
+    g_free (emsg);
 
-      return G_IO_STATUS_ERROR;
-    }
+    return G_IO_STATUS_ERROR;
+  }
     }
   else
     {
       arg = 0;
       if (ioctlsocket (win32_channel->fd, FIONBIO, &arg) == SOCKET_ERROR)
-    {
-      gchar *emsg = g_win32_error_message (WSAGetLastError ());
+  {
+    gchar *emsg = g_win32_error_message (WSAGetLastError ());
 
-      g_set_error_literal (err, G_IO_CHANNEL_ERROR,
-                   G_IO_CHANNEL_ERROR_FAILED,
-                   emsg);
-      g_free (emsg);
+    g_set_error_literal (err, G_IO_CHANNEL_ERROR,
+             G_IO_CHANNEL_ERROR_FAILED,
+             emsg);
+    g_free (emsg);
 
-      return G_IO_STATUS_ERROR;
-    }
+    return G_IO_STATUS_ERROR;
+  }
     }
 
   return G_IO_STATUS_NORMAL;
 }
 
@@ -1984,11 +1984,11 @@
 
   g_io_channel_init (channel);
   g_io_channel_win32_init (win32_channel);
   if (win32_channel->debug)
     g_print ("g_io_channel_win32_new_messages: channel=%p hwnd=%p\n",
-         channel, (HWND) hwnd);
+       channel, (HWND) hwnd);
   channel->funcs = &win32_channel_msg_funcs;
   win32_channel->type = G_IO_WIN32_WINDOWS_MESSAGES;
   win32_channel->hwnd = (HWND) hwnd;
 
   /* XXX: check this. */
@@ -2000,11 +2000,11 @@
   return channel;
 }
 
 static GIOChannel *
 g_io_channel_win32_new_fd_internal (gint             fd,
-                    struct _stati64 *st)
+            struct _stati64 *st)
 {
   GIOWin32Channel *win32_channel;
   GIOChannel *channel;
 
   win32_channel = g_new (GIOWin32Channel, 1);
@@ -2015,11 +2015,11 @@
 
   win32_channel->fd = fd;
 
   if (win32_channel->debug)
     g_print ("g_io_channel_win32_new_fd: channel=%p fd=%u\n",
-         channel, fd);
+       channel, fd);
 
   if (st->st_mode & _S_IFCHR) /* console */
     {
       channel->funcs = &win32_channel_console_funcs;
       win32_channel->type = G_IO_WIN32_CONSOLE;
@@ -2109,11 +2109,11 @@
 
   g_io_channel_init (channel);
   g_io_channel_win32_init (win32_channel);
   if (win32_channel->debug)
     g_print ("g_io_channel_win32_new_socket: channel=%p sock=%d\n",
-         channel, socket);
+       channel, socket);
   channel->funcs = &win32_channel_sock_funcs;
   win32_channel->type = G_IO_WIN32_SOCKET;
   win32_channel->fd = socket;
 
   channel->is_readable = TRUE;
@@ -2155,55 +2155,55 @@
   return g_io_channel_win32_get_fd (channel);
 }
 
 void
 g_io_channel_win32_set_debug (GIOChannel *channel,
-                  gboolean    flag)
+            gboolean    flag)
 {
   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
 
   win32_channel->debug = flag;
 }
 
 gint
 g_io_channel_win32_poll (GPollFD *fds,
-             gint     n_fds,
-             gint     timeout)
+       gint     n_fds,
+       gint     timeout)
 {
   g_return_val_if_fail (n_fds >= 0, 0);
 
   return g_poll (fds, n_fds, timeout);
 }
 
 void
 g_io_channel_win32_make_pollfd (GIOChannel   *channel,
-                GIOCondition  condition,
-                GPollFD      *fd)
+        GIOCondition  condition,
+        GPollFD      *fd)
 {
   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
 
   switch (win32_channel->type)
     {
     case G_IO_WIN32_FILE_DESC:
       if (win32_channel->data_avail_event == NULL)
-    create_events (win32_channel);
+  create_events (win32_channel);
 
       fd->fd = (gintptr) win32_channel->data_avail_event;
 
       if (win32_channel->thread_id == 0)
-    {
-      /* Is it meaningful for a file descriptor to be polled for
-       * both IN and OUT? For what kind of file descriptor would
-       * that be? Doesn't seem to make sense, in practise the file
-       * descriptors handled here are always read or write ends of
-       * pipes surely, and thus unidirectional.
-       */
-      if (condition & G_IO_IN)
-        create_thread (win32_channel, condition, read_thread);
-      else if (condition & G_IO_OUT)
-        create_thread (win32_channel, condition, write_thread);
-    }
+  {
+    /* Is it meaningful for a file descriptor to be polled for
+     * both IN and OUT? For what kind of file descriptor would
+     * that be? Doesn't seem to make sense, in practise the file
+     * descriptors handled here are always read or write ends of
+     * pipes surely, and thus unidirectional.
+     */
+    if (condition & G_IO_IN)
+      create_thread (win32_channel, condition, read_thread);
+    else if (condition & G_IO_OUT)
+      create_thread (win32_channel, condition, write_thread);
+  }
       break;
 
     case G_IO_WIN32_CONSOLE:
       fd->fd = _get_osfhandle (win32_channel->fd);
       break;
