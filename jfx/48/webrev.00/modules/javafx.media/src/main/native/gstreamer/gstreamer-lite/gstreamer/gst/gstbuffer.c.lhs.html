<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstbuffer.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2000 Wim Taymans &lt;wtay@chello.be&gt;
   4  *
   5  * gstbuffer.c: Buffer operations
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 
  23 /**
  24  * SECTION:gstbuffer
  25  * @title: GstBuffer
  26  * @short_description: Data-passing buffer type
  27  * @see_also: #GstPad, #GstMiniObject, #GstMemory, #GstMeta, #GstBufferPool
  28  *
  29  * Buffers are the basic unit of data transfer in GStreamer. They contain the
  30  * timing and offset along with other arbitrary metadata that is associated
  31  * with the #GstMemory blocks that the buffer contains.
  32  *
  33  * Buffers are usually created with gst_buffer_new(). After a buffer has been
  34  * created one will typically allocate memory for it and add it to the buffer.
  35  * The following example creates a buffer that can hold a given video frame
  36  * with a given width, height and bits per plane.
  37  * |[&lt;!-- language=&quot;C&quot; --&gt;
  38  *   GstBuffer *buffer;
  39  *   GstMemory *memory;
  40  *   gint size, width, height, bpp;
  41  *   ...
  42  *   size = width * height * bpp;
  43  *   buffer = gst_buffer_new ();
  44  *   memory = gst_allocator_alloc (NULL, size, NULL);
  45  *   gst_buffer_insert_memory (buffer, -1, memory);
  46  *   ...
  47  * ]|
  48  *
  49  * Alternatively, use gst_buffer_new_allocate() to create a buffer with
  50  * preallocated data of a given size.
  51  *
  52  * Buffers can contain a list of #GstMemory objects. You can retrieve how many
  53  * memory objects with gst_buffer_n_memory() and you can get a pointer
  54  * to memory with gst_buffer_peek_memory()
  55  *
  56  * A buffer will usually have timestamps, and a duration, but neither of these
  57  * are guaranteed (they may be set to #GST_CLOCK_TIME_NONE). Whenever a
  58  * meaningful value can be given for these, they should be set. The timestamps
  59  * and duration are measured in nanoseconds (they are #GstClockTime values).
  60  *
  61  * The buffer DTS refers to the timestamp when the buffer should be decoded and
  62  * is usually monotonically increasing. The buffer PTS refers to the timestamp when
  63  * the buffer content should be presented to the user and is not always
  64  * monotonically increasing.
  65  *
  66  * A buffer can also have one or both of a start and an end offset. These are
  67  * media-type specific. For video buffers, the start offset will generally be
  68  * the frame number. For audio buffers, it will be the number of samples
  69  * produced so far. For compressed data, it could be the byte offset in a
  70  * source or destination file. Likewise, the end offset will be the offset of
  71  * the end of the buffer. These can only be meaningfully interpreted if you
  72  * know the media type of the buffer (the preceding CAPS event). Either or both
  73  * can be set to #GST_BUFFER_OFFSET_NONE.
  74  *
  75  * gst_buffer_ref() is used to increase the refcount of a buffer. This must be
  76  * done when you want to keep a handle to the buffer after pushing it to the
  77  * next element. The buffer refcount determines the writability of the buffer, a
  78  * buffer is only writable when the refcount is exactly 1, i.e. when the caller
  79  * has the only reference to the buffer.
  80  *
  81  * To efficiently create a smaller buffer out of an existing one, you can
  82  * use gst_buffer_copy_region(). This method tries to share the memory objects
  83  * between the two buffers.
  84  *
  85  * If a plug-in wants to modify the buffer data or metadata in-place, it should
  86  * first obtain a buffer that is safe to modify by using
  87  * gst_buffer_make_writable().  This function is optimized so that a copy will
  88  * only be made when it is necessary.
  89  *
  90  * Several flags of the buffer can be set and unset with the
  91  * GST_BUFFER_FLAG_SET() and GST_BUFFER_FLAG_UNSET() macros. Use
  92  * GST_BUFFER_FLAG_IS_SET() to test if a certain #GstBufferFlags flag is set.
  93  *
  94  * Buffers can be efficiently merged into a larger buffer with
  95  * gst_buffer_append(). Copying of memory will only be done when absolutely
  96  * needed.
  97  *
  98  * Arbitrary extra metadata can be set on a buffer with gst_buffer_add_meta().
  99  * Metadata can be retrieved with gst_buffer_get_meta(). See also #GstMeta
 100  *
 101  * An element should either unref the buffer or push it out on a src pad
 102  * using gst_pad_push() (see #GstPad).
 103  *
 104  * Buffers are usually freed by unreffing them with gst_buffer_unref(). When
 105  * the refcount drops to 0, any memory and metadata pointed to by the buffer is
 106  * unreffed as well. Buffers allocated from a #GstBufferPool will be returned to
 107  * the pool when the refcount drops to 0.
 108  *
 109  * The #GstParentBufferMeta is a meta which can be attached to a #GstBuffer
 110  * to hold a reference to another buffer that is only released when the child
 111  * #GstBuffer is released.
 112  *
 113  * Typically, #GstParentBufferMeta is used when the child buffer is directly
 114  * using the #GstMemory of the parent buffer, and wants to prevent the parent
 115  * buffer from being returned to a buffer pool until the #GstMemory is available
<a name="1" id="anc1"></a><span class="line-modified"> 116  * for re-use. (Since 1.6)</span>
 117  *
 118  */
 119 #include &quot;gst_private.h&quot;
 120 
 121 #ifdef HAVE_UNISTD_H
 122 #include &lt;unistd.h&gt;
 123 #endif
 124 #ifdef HAVE_STDLIB_H
 125 #include &lt;stdlib.h&gt;
 126 #endif
 127 
 128 #include &quot;gstbuffer.h&quot;
 129 #include &quot;gstbufferpool.h&quot;
 130 #include &quot;gstinfo.h&quot;
 131 #include &quot;gstutils.h&quot;
 132 #include &quot;gstversion.h&quot;
 133 
 134 GType _gst_buffer_type = 0;
 135 
<a name="2" id="anc2"></a><span class="line-modified"> 136 typedef struct _GstMetaItem GstMetaItem;</span>
<span class="line-modified"> 137 </span>
<span class="line-modified"> 138 struct _GstMetaItem</span>
<span class="line-removed"> 139 {</span>
<span class="line-removed"> 140   GstMetaItem *next;</span>
<span class="line-removed"> 141   GstMeta meta;</span>
<span class="line-removed"> 142 };</span>
<span class="line-removed"> 143 #define ITEM_SIZE(info) ((info)-&gt;size + sizeof (GstMetaItem))</span>
 144 
 145 #define GST_BUFFER_MEM_MAX         16
 146 
 147 #define GST_BUFFER_SLICE_SIZE(b)   (((GstBufferImpl *)(b))-&gt;slice_size)
 148 #define GST_BUFFER_MEM_LEN(b)      (((GstBufferImpl *)(b))-&gt;len)
 149 #define GST_BUFFER_MEM_ARRAY(b)    (((GstBufferImpl *)(b))-&gt;mem)
 150 #define GST_BUFFER_MEM_PTR(b,i)    (((GstBufferImpl *)(b))-&gt;mem[i])
 151 #define GST_BUFFER_BUFMEM(b)       (((GstBufferImpl *)(b))-&gt;bufmem)
 152 #define GST_BUFFER_META(b)         (((GstBufferImpl *)(b))-&gt;item)
<a name="3" id="anc3"></a>
 153 
 154 typedef struct
 155 {
 156   GstBuffer buffer;
 157 
 158   gsize slice_size;
 159 
 160   /* the memory blocks */
 161   guint len;
 162   GstMemory *mem[GST_BUFFER_MEM_MAX];
 163 
 164   /* memory of the buffer when allocated from 1 chunk */
 165   GstMemory *bufmem;
 166 
 167   /* FIXME, make metadata allocation more efficient by using part of the
 168    * GstBufferImpl */
 169   GstMetaItem *item;
<a name="4" id="anc4"></a>
 170 } GstBufferImpl;
 171 
<a name="5" id="anc5"></a>































 172 
 173 static gboolean
 174 _is_span (GstMemory ** mem, gsize len, gsize * poffset, GstMemory ** parent)
 175 {
 176   GstMemory *mcur, *mprv;
 177   gboolean have_offset = FALSE;
 178   gsize i;
 179 
 180   mcur = mprv = NULL;
 181 
 182   for (i = 0; i &lt; len; i++) {
 183     if (mcur)
 184       mprv = mcur;
 185     mcur = mem[i];
 186 
 187     if (mprv &amp;&amp; mcur) {
 188       gsize poffs;
 189 
 190       /* check if memory is contiguous */
 191       if (!gst_memory_is_span (mprv, mcur, &amp;poffs))
 192         return FALSE;
 193 
 194       if (!have_offset) {
 195         if (poffset)
 196           *poffset = poffs;
 197         if (parent)
 198           *parent = mprv-&gt;parent;
 199 
 200         have_offset = TRUE;
 201       }
 202     }
 203   }
 204   return have_offset;
 205 }
 206 
 207 static GstMemory *
 208 _get_merged_memory (GstBuffer * buffer, guint idx, guint length)
 209 {
 210   GstMemory **mem, *result = NULL;
 211 
 212   GST_CAT_LOG (GST_CAT_BUFFER, &quot;buffer %p, idx %u, length %u&quot;, buffer, idx,
 213       length);
 214 
 215   mem = GST_BUFFER_MEM_ARRAY (buffer);
 216 
 217   if (G_UNLIKELY (length == 0)) {
 218     result = NULL;
 219   } else if (G_LIKELY (length == 1)) {
 220     result = gst_memory_ref (mem[idx]);
 221   } else {
 222     GstMemory *parent = NULL;
 223     gsize size, poffset = 0;
 224 
 225     size = gst_buffer_get_sizes_range (buffer, idx, length, NULL, NULL);
 226 
 227     if (G_UNLIKELY (_is_span (mem + idx, length, &amp;poffset, &amp;parent))) {
 228       if (!GST_MEMORY_IS_NO_SHARE (parent))
 229         result = gst_memory_share (parent, poffset, size);
 230       if (!result) {
 231         GST_CAT_DEBUG (GST_CAT_PERFORMANCE, &quot;copy for merge %p&quot;, parent);
 232         result = gst_memory_copy (parent, poffset, size);
 233       }
 234     } else {
 235       gsize i, tocopy, left;
 236       GstMapInfo sinfo, dinfo;
 237       guint8 *ptr;
 238 
 239       result = gst_allocator_alloc (NULL, size, NULL);
 240       if (result == NULL || !gst_memory_map (result, &amp;dinfo, GST_MAP_WRITE)) {
 241         GST_CAT_ERROR (GST_CAT_BUFFER, &quot;Failed to map memory writable&quot;);
 242         if (result)
 243           gst_memory_unref (result);
 244         return NULL;
 245       }
 246 
 247       ptr = dinfo.data;
 248       left = size;
 249 
 250       for (i = idx; i &lt; (idx + length) &amp;&amp; left &gt; 0; i++) {
 251         if (!gst_memory_map (mem[i], &amp;sinfo, GST_MAP_READ)) {
 252           GST_CAT_ERROR (GST_CAT_BUFFER,
 253               &quot;buffer %p, idx %u, length %u failed to map readable&quot;, buffer,
 254               idx, length);
 255           gst_memory_unmap (result, &amp;dinfo);
 256           gst_memory_unref (result);
 257           return NULL;
 258         }
 259         tocopy = MIN (sinfo.size, left);
 260         GST_CAT_DEBUG (GST_CAT_PERFORMANCE,
 261             &quot;memcpy %&quot; G_GSIZE_FORMAT &quot; bytes for merge %p from memory %p&quot;,
 262             tocopy, result, mem[i]);
 263         memcpy (ptr, (guint8 *) sinfo.data, tocopy);
 264         left -= tocopy;
 265         ptr += tocopy;
 266         gst_memory_unmap (mem[i], &amp;sinfo);
 267       }
 268       gst_memory_unmap (result, &amp;dinfo);
 269     }
 270   }
 271   return result;
 272 }
 273 
 274 static void
 275 _replace_memory (GstBuffer * buffer, guint len, guint idx, guint length,
 276     GstMemory * mem)
 277 {
 278   gsize end, i;
 279 
 280   end = idx + length;
 281 
 282   GST_CAT_LOG (GST_CAT_BUFFER,
 283       &quot;buffer %p replace %u-%&quot; G_GSIZE_FORMAT &quot; with memory %p&quot;, buffer, idx,
 284       end, mem);
 285 
 286   /* unref old memory */
 287   for (i = idx; i &lt; end; i++) {
 288     GstMemory *old = GST_BUFFER_MEM_PTR (buffer, i);
 289 
 290     gst_memory_unlock (old, GST_LOCK_FLAG_EXCLUSIVE);
<a name="6" id="anc6"></a>

 291     gst_memory_unref (old);
 292   }
 293 
 294   if (mem != NULL) {
 295     /* replace with single memory */
<a name="7" id="anc7"></a>

 296     gst_memory_lock (mem, GST_LOCK_FLAG_EXCLUSIVE);
 297     GST_BUFFER_MEM_PTR (buffer, idx) = mem;
 298     idx++;
 299     length--;
 300   }
 301 
 302   if (end &lt; len) {
 303     memmove (&amp;GST_BUFFER_MEM_PTR (buffer, idx),
 304         &amp;GST_BUFFER_MEM_PTR (buffer, end), (len - end) * sizeof (gpointer));
 305   }
 306   GST_BUFFER_MEM_LEN (buffer) = len - length;
 307   GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
 308 }
 309 
 310 /**
 311  * gst_buffer_get_flags:
 312  * @buffer: a #GstBuffer
 313  *
 314  * Get the #GstBufferFlags flags set on this buffer.
 315  *
 316  * Returns: the flags set on this buffer.
 317  *
 318  * Since: 1.10
 319  */
 320 GstBufferFlags
 321 gst_buffer_get_flags (GstBuffer * buffer)
 322 {
 323   return (GstBufferFlags) GST_BUFFER_FLAGS (buffer);
 324 }
 325 
 326 /**
 327  * gst_buffer_flag_is_set:
 328  * @buffer: a #GstBuffer
 329  * @flags: the #GstBufferFlags flag to check.
 330  *
 331  * Gives the status of a specific flag on a buffer.
 332  *
 333  * Returns: %TRUE if all flags in @flags are found on @buffer.
 334  *
 335  * Since: 1.10
 336  */
 337 gboolean
 338 gst_buffer_has_flags (GstBuffer * buffer, GstBufferFlags flags)
 339 {
 340   return GST_BUFFER_FLAG_IS_SET (buffer, flags);
 341 }
 342 
 343 /**
 344  * gst_buffer_set_flags:
 345  * @buffer: a #GstBuffer
 346  * @flags: the #GstBufferFlags to set.
 347  *
 348  * Sets one or more buffer flags on a buffer.
 349  *
 350  * Returns: %TRUE if @flags were successfully set on buffer.
 351  *
 352  * Since: 1.10
 353  */
 354 gboolean
 355 gst_buffer_set_flags (GstBuffer * buffer, GstBufferFlags flags)
 356 {
 357   GST_BUFFER_FLAG_SET (buffer, flags);
 358   return TRUE;
 359 }
 360 
 361 /**
 362  * gst_buffer_unset_flags:
 363  * @buffer: a #GstBuffer
 364  * @flags: the #GstBufferFlags to clear
 365  *
 366  * Clears one or more buffer flags.
 367  *
 368  * Returns: true if @flags is successfully cleared from buffer.
 369  *
 370  * Since: 1.10
 371  */
 372 gboolean
 373 gst_buffer_unset_flags (GstBuffer * buffer, GstBufferFlags flags)
 374 {
 375   GST_BUFFER_FLAG_UNSET (buffer, flags);
 376   return TRUE;
 377 }
 378 
 379 
 380 
 381 /* transfer full for return and transfer none for @mem */
 382 static inline GstMemory *
 383 _memory_get_exclusive_reference (GstMemory * mem)
 384 {
 385   GstMemory *ret = NULL;
 386 
 387   if (gst_memory_lock (mem, GST_LOCK_FLAG_EXCLUSIVE)) {
 388     ret = gst_memory_ref (mem);
 389   } else {
 390     /* we cannot take another exclusive lock as the memory is already
 391      * locked WRITE + EXCLUSIVE according to part-miniobject.txt */
 392     ret = gst_memory_copy (mem, 0, -1);
 393 
 394     if (ret) {
 395       if (!gst_memory_lock (ret, GST_LOCK_FLAG_EXCLUSIVE)) {
 396         gst_memory_unref (ret);
 397         ret = NULL;
 398       }
 399     }
 400   }
 401 
 402   if (!ret)
 403     GST_CAT_WARNING (GST_CAT_BUFFER, &quot;Failed to acquire an exclusive lock for &quot;
 404         &quot;memory %p&quot;, mem);
 405 
 406   return ret;
 407 }
 408 
 409 static inline void
 410 _memory_add (GstBuffer * buffer, gint idx, GstMemory * mem)
 411 {
 412   guint i, len = GST_BUFFER_MEM_LEN (buffer);
 413 
 414   GST_CAT_LOG (GST_CAT_BUFFER, &quot;buffer %p, idx %d, mem %p&quot;, buffer, idx, mem);
 415 
 416   if (G_UNLIKELY (len &gt;= GST_BUFFER_MEM_MAX)) {
 417     /* too many buffer, span them. */
 418     /* FIXME, there is room for improvement here: We could only try to merge
 419      * 2 buffers to make some room. If we can&#39;t efficiently merge 2 buffers we
 420      * could try to only merge the two smallest buffers to avoid memcpy, etc. */
 421     GST_CAT_DEBUG (GST_CAT_PERFORMANCE, &quot;memory array overflow in buffer %p&quot;,
 422         buffer);
 423     _replace_memory (buffer, len, 0, len, _get_merged_memory (buffer, 0, len));
 424     /* we now have 1 single spanned buffer */
 425     len = 1;
 426   }
 427 
 428   if (idx == -1)
 429     idx = len;
 430 
 431   for (i = len; i &gt; idx; i--) {
 432     /* move buffers to insert, FIXME, we need to insert first and then merge */
 433     GST_BUFFER_MEM_PTR (buffer, i) = GST_BUFFER_MEM_PTR (buffer, i - 1);
 434   }
 435   /* and insert the new buffer */
 436   GST_BUFFER_MEM_PTR (buffer, idx) = mem;
 437   GST_BUFFER_MEM_LEN (buffer) = len + 1;
<a name="8" id="anc8"></a>

 438 
 439   GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
 440 }
 441 
 442 GST_DEFINE_MINI_OBJECT_TYPE (GstBuffer, gst_buffer);
 443 
 444 void
 445 _priv_gst_buffer_initialize (void)
 446 {
 447   _gst_buffer_type = gst_buffer_get_type ();
<a name="9" id="anc9"></a>




 448 }
 449 
 450 /**
 451  * gst_buffer_get_max_memory:
 452  *
 453  * Get the maximum amount of memory blocks that a buffer can hold. This is a
 454  * compile time constant that can be queried with the function.
 455  *
 456  * When more memory blocks are added, existing memory blocks will be merged
 457  * together to make room for the new block.
 458  *
 459  * Returns: the maximum amount of memory blocks that a buffer can hold.
 460  *
 461  * Since: 1.2
 462  */
 463 guint
 464 gst_buffer_get_max_memory (void)
 465 {
 466   return GST_BUFFER_MEM_MAX;
 467 }
 468 
 469 /**
 470  * gst_buffer_copy_into:
 471  * @dest: a destination #GstBuffer
 472  * @src: a source #GstBuffer
 473  * @flags: flags indicating what metadata fields should be copied.
 474  * @offset: offset to copy from
 475  * @size: total size to copy. If -1, all data is copied.
 476  *
 477  * Copies the information from @src into @dest.
 478  *
 479  * If @dest already contains memory and @flags contains GST_BUFFER_COPY_MEMORY,
 480  * the memory from @src will be appended to @dest.
 481  *
 482  * @flags indicate which fields will be copied.
 483  *
 484  * Returns: %TRUE if the copying succeeded, %FALSE otherwise.
 485  */
 486 gboolean
 487 gst_buffer_copy_into (GstBuffer * dest, GstBuffer * src,
 488     GstBufferCopyFlags flags, gsize offset, gsize size)
 489 {
 490   GstMetaItem *walk;
 491   gsize bufsize;
 492   gboolean region = FALSE;
 493 
 494   g_return_val_if_fail (dest != NULL, FALSE);
 495   g_return_val_if_fail (src != NULL, FALSE);
 496 
 497   /* nothing to copy if the buffers are the same */
 498   if (G_UNLIKELY (dest == src))
 499     return TRUE;
 500 
 501   g_return_val_if_fail (gst_buffer_is_writable (dest), FALSE);
 502 
 503   bufsize = gst_buffer_get_size (src);
 504   g_return_val_if_fail (bufsize &gt;= offset, FALSE);
 505   if (offset &gt; 0)
 506     region = TRUE;
 507   if (size == -1)
 508     size = bufsize - offset;
 509   if (size &lt; bufsize)
 510     region = TRUE;
 511   g_return_val_if_fail (bufsize &gt;= offset + size, FALSE);
 512 
 513   GST_CAT_LOG (GST_CAT_BUFFER, &quot;copy %p to %p, offset %&quot; G_GSIZE_FORMAT
 514       &quot;-%&quot; G_GSIZE_FORMAT &quot;/%&quot; G_GSIZE_FORMAT, src, dest, offset, size,
 515       bufsize);
 516 
 517   if (flags &amp; GST_BUFFER_COPY_FLAGS) {
 518     /* copy flags */
 519     guint flags_mask = ~GST_BUFFER_FLAG_TAG_MEMORY;
 520 
 521     GST_MINI_OBJECT_FLAGS (dest) =
 522         (GST_MINI_OBJECT_FLAGS (src) &amp; flags_mask) |
 523         (GST_MINI_OBJECT_FLAGS (dest) &amp; ~flags_mask);
 524   }
 525 
 526   if (flags &amp; GST_BUFFER_COPY_TIMESTAMPS) {
 527     if (offset == 0) {
 528       GST_BUFFER_PTS (dest) = GST_BUFFER_PTS (src);
 529       GST_BUFFER_DTS (dest) = GST_BUFFER_DTS (src);
 530       GST_BUFFER_OFFSET (dest) = GST_BUFFER_OFFSET (src);
 531       if (size == bufsize) {
 532         GST_BUFFER_DURATION (dest) = GST_BUFFER_DURATION (src);
 533         GST_BUFFER_OFFSET_END (dest) = GST_BUFFER_OFFSET_END (src);
 534       }
 535     } else {
 536       GST_BUFFER_PTS (dest) = GST_CLOCK_TIME_NONE;
 537       GST_BUFFER_DTS (dest) = GST_CLOCK_TIME_NONE;
 538       GST_BUFFER_DURATION (dest) = GST_CLOCK_TIME_NONE;
 539       GST_BUFFER_OFFSET (dest) = GST_BUFFER_OFFSET_NONE;
 540       GST_BUFFER_OFFSET_END (dest) = GST_BUFFER_OFFSET_NONE;
 541     }
 542   }
 543 
 544   if (flags &amp; GST_BUFFER_COPY_MEMORY) {
 545     gsize skip, left, len, dest_len, i, bsize;
 546     gboolean deep;
 547 
 548     deep = flags &amp; GST_BUFFER_COPY_DEEP;
 549 
 550     len = GST_BUFFER_MEM_LEN (src);
 551     dest_len = GST_BUFFER_MEM_LEN (dest);
 552     left = size;
 553     skip = offset;
 554 
 555     /* copy and make regions of the memory */
 556     for (i = 0; i &lt; len &amp;&amp; left &gt; 0; i++) {
 557       GstMemory *mem = GST_BUFFER_MEM_PTR (src, i);
 558 
 559       bsize = gst_memory_get_sizes (mem, NULL, NULL);
 560 
 561       if (bsize &lt;= skip) {
 562         /* don&#39;t copy buffer */
 563         skip -= bsize;
 564       } else {
 565         GstMemory *newmem = NULL;
 566         gsize tocopy;
 567 
 568         tocopy = MIN (bsize - skip, left);
 569 
 570         if (tocopy &lt; bsize &amp;&amp; !deep &amp;&amp; !GST_MEMORY_IS_NO_SHARE (mem)) {
 571           /* we need to clip something */
 572           newmem = gst_memory_share (mem, skip, tocopy);
 573           if (newmem) {
 574             gst_memory_lock (newmem, GST_LOCK_FLAG_EXCLUSIVE);
 575             skip = 0;
<a name="10" id="anc10"></a><span class="line-modified"> 576         }</span>
 577         }
 578 
 579         if (deep || GST_MEMORY_IS_NO_SHARE (mem) || (!newmem &amp;&amp; tocopy &lt; bsize)) {
 580           /* deep copy or we&#39;re not allowed to share this memory
 581            * between buffers, always copy then */
 582           newmem = gst_memory_copy (mem, skip, tocopy);
 583           if (newmem) {
 584             gst_memory_lock (newmem, GST_LOCK_FLAG_EXCLUSIVE);
<a name="11" id="anc11"></a><span class="line-modified"> 585           skip = 0;</span>
 586           }
 587         } else if (!newmem) {
 588           newmem = _memory_get_exclusive_reference (mem);
 589         }
 590 
 591         if (!newmem) {
 592           gst_buffer_remove_memory_range (dest, dest_len, -1);
 593           return FALSE;
 594         }
 595 
 596         _memory_add (dest, -1, newmem);
 597         left -= tocopy;
 598       }
 599     }
 600     if (flags &amp; GST_BUFFER_COPY_MERGE) {
 601       GstMemory *mem;
 602 
 603       len = GST_BUFFER_MEM_LEN (dest);
 604       mem = _get_merged_memory (dest, 0, len);
 605       if (!mem) {
 606         gst_buffer_remove_memory_range (dest, dest_len, -1);
 607         return FALSE;
 608       }
 609       _replace_memory (dest, len, 0, len, mem);
 610     }
 611   }
 612 
 613   if (flags &amp; GST_BUFFER_COPY_META) {
 614     /* NOTE: GstGLSyncMeta copying relies on the meta
 615      *       being copied now, after the buffer data,
 616      *       so this has to happen last */
 617     for (walk = GST_BUFFER_META (src); walk; walk = walk-&gt;next) {
 618       GstMeta *meta = &amp;walk-&gt;meta;
 619       const GstMetaInfo *info = meta-&gt;info;
 620 
 621       /* Don&#39;t copy memory metas if we only copied part of the buffer, didn&#39;t
 622        * copy memories or merged memories. In all these cases the memory
 623        * structure has changed and the memory meta becomes meaningless.
 624        */
 625       if ((region || !(flags &amp; GST_BUFFER_COPY_MEMORY)
 626               || (flags &amp; GST_BUFFER_COPY_MERGE))
 627           &amp;&amp; gst_meta_api_type_has_tag (info-&gt;api, _gst_meta_tag_memory)) {
 628         GST_CAT_DEBUG (GST_CAT_BUFFER,
 629             &quot;don&#39;t copy memory meta %p of API type %s&quot;, meta,
 630             g_type_name (info-&gt;api));
 631       } else if (info-&gt;transform_func) {
 632         GstMetaTransformCopy copy_data;
 633 
 634         copy_data.region = region;
 635         copy_data.offset = offset;
 636         copy_data.size = size;
 637 
 638         if (!info-&gt;transform_func (dest, meta, src,
 639                 _gst_meta_transform_copy, &amp;copy_data)) {
 640           GST_CAT_ERROR (GST_CAT_BUFFER,
 641               &quot;failed to copy meta %p of API type %s&quot;, meta,
 642               g_type_name (info-&gt;api));
<a name="12" id="anc12"></a>
 643       }
 644     }
 645   }
<a name="13" id="anc13"></a><span class="line-removed"> 646   }</span>
 647 
 648   return TRUE;
 649 }
 650 
 651 static GstBuffer *
 652 gst_buffer_copy_with_flags (const GstBuffer * buffer, GstBufferCopyFlags flags)
 653 {
 654   GstBuffer *copy;
 655 
 656   g_return_val_if_fail (buffer != NULL, NULL);
 657 
 658   /* create a fresh new buffer */
 659   copy = gst_buffer_new ();
 660 
 661   /* copy what the &#39;flags&#39; want from our parent */
 662   /* FIXME why we can&#39;t pass const to gst_buffer_copy_into() ? */
 663   if (!gst_buffer_copy_into (copy, (GstBuffer *) buffer, flags, 0, -1))
 664     gst_buffer_replace (&amp;copy, NULL);
 665 
 666   if (copy)
 667     GST_BUFFER_FLAG_UNSET (copy, GST_BUFFER_FLAG_TAG_MEMORY);
 668 
 669   return copy;
 670 }
 671 
 672 static GstBuffer *
 673 _gst_buffer_copy (const GstBuffer * buffer)
 674 {
 675   return gst_buffer_copy_with_flags (buffer, GST_BUFFER_COPY_ALL);
 676 }
 677 
 678 /**
 679  * gst_buffer_copy_deep:
 680  * @buf: a #GstBuffer.
 681  *
 682  * Create a copy of the given buffer. This will make a newly allocated
 683  * copy of the data the source buffer contains.
 684  *
 685  * Returns: (transfer full): a new copy of @buf.
 686  *
 687  * Since: 1.6
 688  */
 689 GstBuffer *
 690 gst_buffer_copy_deep (const GstBuffer * buffer)
 691 {
 692   return gst_buffer_copy_with_flags (buffer,
 693       GST_BUFFER_COPY_ALL | GST_BUFFER_COPY_DEEP);
 694 }
 695 
 696 /* the default dispose function revives the buffer and returns it to the
 697  * pool when there is a pool */
 698 static gboolean
 699 _gst_buffer_dispose (GstBuffer * buffer)
 700 {
 701   GstBufferPool *pool;
 702 
 703   /* no pool, do free */
 704   if ((pool = buffer-&gt;pool) == NULL)
 705     return TRUE;
 706 
 707   /* keep the buffer alive */
 708   gst_buffer_ref (buffer);
 709   /* return the buffer to the pool */
 710   GST_CAT_LOG (GST_CAT_BUFFER, &quot;release %p to pool %p&quot;, buffer, pool);
 711   gst_buffer_pool_release_buffer (pool, buffer);
 712 
 713   return FALSE;
 714 }
 715 
 716 static void
 717 _gst_buffer_free (GstBuffer * buffer)
 718 {
 719   GstMetaItem *walk, *next;
 720   guint i, len;
 721   gsize msize;
 722 
 723   g_return_if_fail (buffer != NULL);
 724 
 725   GST_CAT_LOG (GST_CAT_BUFFER, &quot;finalize %p&quot;, buffer);
 726 
 727   /* free metadata */
 728   for (walk = GST_BUFFER_META (buffer); walk; walk = next) {
 729     GstMeta *meta = &amp;walk-&gt;meta;
 730     const GstMetaInfo *info = meta-&gt;info;
 731 
 732     /* call free_func if any */
 733     if (info-&gt;free_func)
 734       info-&gt;free_func (meta, buffer);
 735 
 736     next = walk-&gt;next;
 737     /* and free the slice */
 738     g_slice_free1 (ITEM_SIZE (info), walk);
 739   }
 740 
 741   /* get the size, when unreffing the memory, we could also unref the buffer
 742    * itself */
 743   msize = GST_BUFFER_SLICE_SIZE (buffer);
 744 
 745   /* free our memory */
 746   len = GST_BUFFER_MEM_LEN (buffer);
 747   for (i = 0; i &lt; len; i++) {
 748     gst_memory_unlock (GST_BUFFER_MEM_PTR (buffer, i), GST_LOCK_FLAG_EXCLUSIVE);
<a name="14" id="anc14"></a>

 749     gst_memory_unref (GST_BUFFER_MEM_PTR (buffer, i));
 750   }
 751 
 752   /* we set msize to 0 when the buffer is part of the memory block */
 753   if (msize) {
 754 #ifdef USE_POISONING
 755     memset (buffer, 0xff, msize);
 756 #endif
 757     g_slice_free1 (msize, buffer);
 758   } else {
 759     gst_memory_unref (GST_BUFFER_BUFMEM (buffer));
 760   }
 761 }
 762 
 763 static void
 764 gst_buffer_init (GstBufferImpl * buffer, gsize size)
 765 {
 766   gst_mini_object_init (GST_MINI_OBJECT_CAST (buffer), 0, _gst_buffer_type,
 767       (GstMiniObjectCopyFunction) _gst_buffer_copy,
 768       (GstMiniObjectDisposeFunction) _gst_buffer_dispose,
 769       (GstMiniObjectFreeFunction) _gst_buffer_free);
 770 
 771   GST_BUFFER_SLICE_SIZE (buffer) = size;
 772 
 773   GST_BUFFER (buffer)-&gt;pool = NULL;
 774   GST_BUFFER_PTS (buffer) = GST_CLOCK_TIME_NONE;
 775   GST_BUFFER_DTS (buffer) = GST_CLOCK_TIME_NONE;
 776   GST_BUFFER_DURATION (buffer) = GST_CLOCK_TIME_NONE;
 777   GST_BUFFER_OFFSET (buffer) = GST_BUFFER_OFFSET_NONE;
 778   GST_BUFFER_OFFSET_END (buffer) = GST_BUFFER_OFFSET_NONE;
 779 
 780   GST_BUFFER_MEM_LEN (buffer) = 0;
 781   GST_BUFFER_META (buffer) = NULL;
 782 }
 783 
 784 /**
 785  * gst_buffer_new:
 786  *
 787  * Creates a newly allocated buffer without any data.
 788  *
 789  * MT safe.
 790  *
 791  * Returns: (transfer full): the new #GstBuffer.
 792  */
 793 GstBuffer *
 794 gst_buffer_new (void)
 795 {
 796   GstBufferImpl *newbuf;
 797 
 798   newbuf = g_slice_new (GstBufferImpl);
 799   GST_CAT_LOG (GST_CAT_BUFFER, &quot;new %p&quot;, newbuf);
 800 
 801   gst_buffer_init (newbuf, sizeof (GstBufferImpl));
 802 
 803   return GST_BUFFER_CAST (newbuf);
 804 }
 805 
 806 /**
 807  * gst_buffer_new_allocate:
 808  * @allocator: (transfer none) (allow-none): the #GstAllocator to use, or %NULL to use the
 809  *     default allocator
 810  * @size: the size in bytes of the new buffer&#39;s data.
 811  * @params: (transfer none) (allow-none): optional parameters
 812  *
 813  * Tries to create a newly allocated buffer with data of the given size and
 814  * extra parameters from @allocator. If the requested amount of memory can&#39;t be
 815  * allocated, %NULL will be returned. The allocated buffer memory is not cleared.
 816  *
 817  * When @allocator is %NULL, the default memory allocator will be used.
 818  *
 819  * Note that when @size == 0, the buffer will not have memory associated with it.
 820  *
 821  * MT safe.
 822  *
 823  * Returns: (transfer full) (nullable): a new #GstBuffer, or %NULL if
 824  *     the memory couldn&#39;t be allocated.
 825  */
 826 GstBuffer *
 827 gst_buffer_new_allocate (GstAllocator * allocator, gsize size,
 828     GstAllocationParams * params)
 829 {
 830   GstBuffer *newbuf;
 831   GstMemory *mem;
 832 #if 0
 833   guint8 *data;
 834   gsize asize;
 835 #endif
 836 
 837 #if 1
 838   if (size &gt; 0) {
 839     mem = gst_allocator_alloc (allocator, size, params);
 840     if (G_UNLIKELY (mem == NULL))
 841       goto no_memory;
 842   } else {
 843     mem = NULL;
 844   }
 845 
 846   newbuf = gst_buffer_new ();
 847 
 848   if (mem != NULL) {
 849     gst_memory_lock (mem, GST_LOCK_FLAG_EXCLUSIVE);
 850     _memory_add (newbuf, -1, mem);
 851   }
 852 
 853   GST_CAT_LOG (GST_CAT_BUFFER,
 854       &quot;new buffer %p of size %&quot; G_GSIZE_FORMAT &quot; from allocator %p&quot;, newbuf,
 855       size, allocator);
 856 #endif
 857 
 858 #if 0
 859   asize = sizeof (GstBufferImpl) + size;
 860   data = g_slice_alloc (asize);
 861   if (G_UNLIKELY (data == NULL))
 862     goto no_memory;
 863 
 864   newbuf = GST_BUFFER_CAST (data);
 865 
 866   gst_buffer_init ((GstBufferImpl *) data, asize);
 867   if (size &gt; 0) {
 868     mem = gst_memory_new_wrapped (0, data + sizeof (GstBufferImpl), NULL,
 869         size, 0, size);
 870     _memory_add (newbuf, -1, mem, TRUE);
 871   }
 872 #endif
 873 
 874 #if 0
 875   /* allocate memory and buffer, it might be interesting to do this but there
 876    * are many complications. We need to keep the memory mapped to access the
 877    * buffer fields and the memory for the buffer might be just very slow. We
 878    * also need to do some more magic to get the alignment right. */
 879   asize = sizeof (GstBufferImpl) + size;
 880   mem = gst_allocator_alloc (allocator, asize, align);
 881   if (G_UNLIKELY (mem == NULL))
 882     goto no_memory;
 883 
 884   /* map the data part and init the buffer in it, set the buffer size to 0 so
 885    * that a finalize won&#39;t free the buffer */
 886   data = gst_memory_map (mem, &amp;asize, NULL, GST_MAP_WRITE);
 887   gst_buffer_init ((GstBufferImpl *) data, 0);
 888   gst_memory_unmap (mem);
 889 
 890   /* strip off the buffer */
 891   gst_memory_resize (mem, sizeof (GstBufferImpl), size);
 892 
 893   newbuf = GST_BUFFER_CAST (data);
 894   GST_BUFFER_BUFMEM (newbuf) = mem;
 895 
 896   if (size &gt; 0)
 897     _memory_add (newbuf, -1, gst_memory_ref (mem), TRUE);
 898 #endif
 899   GST_BUFFER_FLAG_UNSET (newbuf, GST_BUFFER_FLAG_TAG_MEMORY);
 900 
 901   return newbuf;
 902 
 903   /* ERRORS */
 904 no_memory:
 905   {
 906     GST_CAT_WARNING (GST_CAT_BUFFER,
 907         &quot;failed to allocate %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, size);
 908     return NULL;
 909   }
 910 }
 911 
 912 /**
 913  * gst_buffer_new_wrapped_full:
 914  * @flags: #GstMemoryFlags
 915  * @data: (array length=size) (element-type guint8) (transfer none): data to wrap
 916  * @maxsize: allocated size of @data
 917  * @offset: offset in @data
 918  * @size: size of valid data
 919  * @user_data: (allow-none): user_data
 920  * @notify: (allow-none) (scope async) (closure user_data): called with @user_data when the memory is freed
 921  *
 922  * Allocate a new buffer that wraps the given memory. @data must point to
 923  * @maxsize of memory, the wrapped buffer will have the region from @offset and
 924  * @size visible.
 925  *
 926  * When the buffer is destroyed, @notify will be called with @user_data.
 927  *
 928  * The prefix/padding must be filled with 0 if @flags contains
 929  * #GST_MEMORY_FLAG_ZERO_PREFIXED and #GST_MEMORY_FLAG_ZERO_PADDED respectively.
 930  *
 931  * Returns: (transfer full): a new #GstBuffer
 932  */
 933 GstBuffer *
 934 gst_buffer_new_wrapped_full (GstMemoryFlags flags, gpointer data,
 935     gsize maxsize, gsize offset, gsize size, gpointer user_data,
 936     GDestroyNotify notify)
 937 {
 938   GstMemory *mem;
 939   GstBuffer *newbuf;
 940 
 941   newbuf = gst_buffer_new ();
 942   mem =
 943       gst_memory_new_wrapped (flags, data, maxsize, offset, size, user_data,
 944       notify);
 945   gst_memory_lock (mem, GST_LOCK_FLAG_EXCLUSIVE);
 946   _memory_add (newbuf, -1, mem);
 947   GST_BUFFER_FLAG_UNSET (newbuf, GST_BUFFER_FLAG_TAG_MEMORY);
 948 
 949   return newbuf;
 950 }
 951 
 952 /**
 953  * gst_buffer_new_wrapped:
 954  * @data: (array length=size) (element-type guint8) (transfer full): data to wrap
 955  * @size: allocated size of @data
 956  *
 957  * Creates a new buffer that wraps the given @data. The memory will be freed
 958  * with g_free and will be marked writable.
 959  *
 960  * MT safe.
 961  *
 962  * Returns: (transfer full): a new #GstBuffer
 963  */
 964 GstBuffer *
 965 gst_buffer_new_wrapped (gpointer data, gsize size)
 966 {
 967   return gst_buffer_new_wrapped_full (0, data, size, 0, size, data, g_free);
 968 }
 969 
<a name="15" id="anc15"></a>


























 970 /**
 971  * gst_buffer_n_memory:
 972  * @buffer: a #GstBuffer.
 973  *
 974  * Get the amount of memory blocks that this buffer has. This amount is never
 975  * larger than what gst_buffer_get_max_memory() returns.
 976  *
 977  * Returns: the number of memory blocks this buffer is made of.
 978  */
 979 guint
 980 gst_buffer_n_memory (GstBuffer * buffer)
 981 {
 982   g_return_val_if_fail (GST_IS_BUFFER (buffer), 0);
 983 
 984   return GST_BUFFER_MEM_LEN (buffer);
 985 }
 986 
 987 /**
 988  * gst_buffer_prepend_memory:
 989  * @buffer: a #GstBuffer.
 990  * @mem: (transfer full): a #GstMemory.
 991  *
 992  * Prepend the memory block @mem to @buffer. This function takes
 993  * ownership of @mem and thus doesn&#39;t increase its refcount.
 994  *
 995  * This function is identical to gst_buffer_insert_memory() with an index of 0.
 996  * See gst_buffer_insert_memory() for more details.
 997  */
 998 void
 999 gst_buffer_prepend_memory (GstBuffer * buffer, GstMemory * mem)
1000 {
1001   gst_buffer_insert_memory (buffer, 0, mem);
1002 }
1003 
1004 /**
1005  * gst_buffer_append_memory:
1006  * @buffer: a #GstBuffer.
1007  * @mem: (transfer full): a #GstMemory.
1008  *
1009  * Append the memory block @mem to @buffer. This function takes
1010  * ownership of @mem and thus doesn&#39;t increase its refcount.
1011  *
1012  * This function is identical to gst_buffer_insert_memory() with an index of -1.
1013  * See gst_buffer_insert_memory() for more details.
1014  */
1015 void
1016 gst_buffer_append_memory (GstBuffer * buffer, GstMemory * mem)
1017 {
1018   gst_buffer_insert_memory (buffer, -1, mem);
1019 }
1020 
1021 /**
1022  * gst_buffer_insert_memory:
1023  * @buffer: a #GstBuffer.
1024  * @idx: the index to add the memory at, or -1 to append it to the end
1025  * @mem: (transfer full): a #GstMemory.
1026  *
1027  * Insert the memory block @mem to @buffer at @idx. This function takes ownership
1028  * of @mem and thus doesn&#39;t increase its refcount.
1029  *
1030  * Only gst_buffer_get_max_memory() can be added to a buffer. If more memory is
1031  * added, existing memory blocks will automatically be merged to make room for
1032  * the new memory.
1033  */
1034 void
1035 gst_buffer_insert_memory (GstBuffer * buffer, gint idx, GstMemory * mem)
1036 {
1037   GstMemory *tmp;
1038 
1039   g_return_if_fail (GST_IS_BUFFER (buffer));
1040   g_return_if_fail (gst_buffer_is_writable (buffer));
1041   g_return_if_fail (mem != NULL);
1042   g_return_if_fail (idx == -1 ||
1043       (idx &gt;= 0 &amp;&amp; idx &lt;= GST_BUFFER_MEM_LEN (buffer)));
1044 
1045   tmp = _memory_get_exclusive_reference (mem);
1046   g_return_if_fail (tmp != NULL);
1047   gst_memory_unref (mem);
1048   _memory_add (buffer, idx, tmp);
1049 }
1050 
1051 static GstMemory *
1052 _get_mapped (GstBuffer * buffer, guint idx, GstMapInfo * info,
1053     GstMapFlags flags)
1054 {
1055   GstMemory *mem, *mapped;
1056 
1057   mem = gst_memory_ref (GST_BUFFER_MEM_PTR (buffer, idx));
1058 
1059   mapped = gst_memory_make_mapped (mem, info, flags);
1060 
1061   if (mapped != mem) {
1062     /* memory changed, lock new memory */
<a name="16" id="anc16"></a>

1063     gst_memory_lock (mapped, GST_LOCK_FLAG_EXCLUSIVE);
1064     GST_BUFFER_MEM_PTR (buffer, idx) = mapped;
1065     /* unlock old memory */
1066     gst_memory_unlock (mem, GST_LOCK_FLAG_EXCLUSIVE);
<a name="17" id="anc17"></a>

1067     GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
1068   }
1069   gst_memory_unref (mem);
1070 
1071   return mapped;
1072 }
1073 
1074 /**
1075  * gst_buffer_peek_memory:
1076  * @buffer: a #GstBuffer.
1077  * @idx: an index
1078  *
1079  * Get the memory block at @idx in @buffer. The memory block stays valid until
1080  * the memory block in @buffer is removed, replaced or merged, typically with
1081  * any call that modifies the memory in @buffer.
1082  *
1083  * Returns: (transfer none) (nullable): the #GstMemory at @idx.
1084  */
1085 GstMemory *
1086 gst_buffer_peek_memory (GstBuffer * buffer, guint idx)
1087 {
1088   guint len;
1089 
1090   g_return_val_if_fail (GST_IS_BUFFER (buffer), NULL);
1091   len = GST_BUFFER_MEM_LEN (buffer);
1092   g_return_val_if_fail (idx &lt; len, NULL);
1093 
1094   return GST_BUFFER_MEM_PTR (buffer, idx);
1095 }
1096 
1097 /**
1098  * gst_buffer_get_memory:
1099  * @buffer: a #GstBuffer.
1100  * @idx: an index
1101  *
1102  * Get the memory block at index @idx in @buffer.
1103  *
1104  * Returns: (transfer full) (nullable): a #GstMemory that contains the data of the
1105  * memory block at @idx. Use gst_memory_unref () after usage.
1106  */
1107 GstMemory *
1108 gst_buffer_get_memory (GstBuffer * buffer, guint idx)
1109 {
1110   return gst_buffer_get_memory_range (buffer, idx, 1);
1111 }
1112 
1113 /**
1114  * gst_buffer_get_all_memory:
1115  * @buffer: a #GstBuffer.
1116  *
1117  * Get all the memory block in @buffer. The memory blocks will be merged
1118  * into one large #GstMemory.
1119  *
1120  * Returns: (transfer full) (nullable): a #GstMemory that contains the merged memory.
1121  * Use gst_memory_unref () after usage.
1122  */
1123 GstMemory *
1124 gst_buffer_get_all_memory (GstBuffer * buffer)
1125 {
1126   return gst_buffer_get_memory_range (buffer, 0, -1);
1127 }
1128 
1129 /**
1130  * gst_buffer_get_memory_range:
1131  * @buffer: a #GstBuffer.
1132  * @idx: an index
1133  * @length: a length
1134  *
1135  * Get @length memory blocks in @buffer starting at @idx. The memory blocks will
1136  * be merged into one large #GstMemory.
1137  *
1138  * If @length is -1, all memory starting from @idx is merged.
1139  *
1140  * Returns: (transfer full) (nullable): a #GstMemory that contains the merged data of @length
1141  *    blocks starting at @idx. Use gst_memory_unref () after usage.
1142  */
1143 GstMemory *
1144 gst_buffer_get_memory_range (GstBuffer * buffer, guint idx, gint length)
1145 {
1146   guint len;
1147 
1148   GST_CAT_DEBUG (GST_CAT_BUFFER, &quot;idx %u, length %d&quot;, idx, length);
1149 
1150   g_return_val_if_fail (GST_IS_BUFFER (buffer), NULL);
1151   len = GST_BUFFER_MEM_LEN (buffer);
1152   g_return_val_if_fail ((len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) ||
1153       (length == -1 &amp;&amp; idx &lt; len) || (length &gt; 0 &amp;&amp; length + idx &lt;= len), NULL);
1154 
1155   if (length == -1)
1156     length = len - idx;
1157 
1158   return _get_merged_memory (buffer, idx, length);
1159 }
1160 
1161 /**
1162  * gst_buffer_replace_memory:
1163  * @buffer: a #GstBuffer.
1164  * @idx: an index
1165  * @mem: (transfer full): a #GstMemory
1166  *
1167  * Replaces the memory block at index @idx in @buffer with @mem.
1168  */
1169 void
1170 gst_buffer_replace_memory (GstBuffer * buffer, guint idx, GstMemory * mem)
1171 {
1172   gst_buffer_replace_memory_range (buffer, idx, 1, mem);
1173 }
1174 
1175 /**
1176  * gst_buffer_replace_all_memory:
1177  * @buffer: a #GstBuffer.
1178  * @mem: (transfer full): a #GstMemory
1179  *
1180  * Replaces all memory in @buffer with @mem.
1181  */
1182 void
1183 gst_buffer_replace_all_memory (GstBuffer * buffer, GstMemory * mem)
1184 {
1185   gst_buffer_replace_memory_range (buffer, 0, -1, mem);
1186 }
1187 
1188 /**
1189  * gst_buffer_replace_memory_range:
1190  * @buffer: a #GstBuffer.
1191  * @idx: an index
1192  * @length: a length should not be 0
1193  * @mem: (transfer full): a #GstMemory
1194  *
1195  * Replaces @length memory blocks in @buffer starting at @idx with @mem.
1196  *
1197  * If @length is -1, all memory starting from @idx will be removed and
1198  * replaced with @mem.
1199  *
1200  * @buffer should be writable.
1201  */
1202 void
1203 gst_buffer_replace_memory_range (GstBuffer * buffer, guint idx, gint length,
1204     GstMemory * mem)
1205 {
1206   guint len;
1207 
1208   g_return_if_fail (GST_IS_BUFFER (buffer));
1209   g_return_if_fail (gst_buffer_is_writable (buffer));
1210 
1211   GST_CAT_DEBUG (GST_CAT_BUFFER, &quot;idx %u, length %d, %p&quot;, idx, length, mem);
1212 
1213   len = GST_BUFFER_MEM_LEN (buffer);
1214   g_return_if_fail ((len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) ||
1215       (length == -1 &amp;&amp; idx &lt; len) || (length &gt; 0 &amp;&amp; length + idx &lt;= len));
1216 
1217   if (length == -1)
1218     length = len - idx;
1219 
1220   _replace_memory (buffer, len, idx, length, mem);
1221 }
1222 
1223 /**
1224  * gst_buffer_remove_memory:
1225  * @buffer: a #GstBuffer.
1226  * @idx: an index
1227  *
1228  * Remove the memory block in @b at index @i.
1229  */
1230 void
1231 gst_buffer_remove_memory (GstBuffer * buffer, guint idx)
1232 {
1233   gst_buffer_remove_memory_range (buffer, idx, 1);
1234 }
1235 
1236 /**
1237  * gst_buffer_remove_all_memory:
1238  * @buffer: a #GstBuffer.
1239  *
1240  * Remove all the memory blocks in @buffer.
1241  */
1242 void
1243 gst_buffer_remove_all_memory (GstBuffer * buffer)
1244 {
1245   gst_buffer_remove_memory_range (buffer, 0, -1);
1246 }
1247 
1248 /**
1249  * gst_buffer_remove_memory_range:
1250  * @buffer: a #GstBuffer.
1251  * @idx: an index
1252  * @length: a length
1253  *
1254  * Remove @length memory blocks in @buffer starting from @idx.
1255  *
1256  * @length can be -1, in which case all memory starting from @idx is removed.
1257  */
1258 void
1259 gst_buffer_remove_memory_range (GstBuffer * buffer, guint idx, gint length)
1260 {
1261   guint len;
1262 
1263   g_return_if_fail (GST_IS_BUFFER (buffer));
1264   g_return_if_fail (gst_buffer_is_writable (buffer));
1265 
1266   GST_CAT_DEBUG (GST_CAT_BUFFER, &quot;idx %u, length %d&quot;, idx, length);
1267 
1268   len = GST_BUFFER_MEM_LEN (buffer);
1269   g_return_if_fail ((len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) ||
1270       (length == -1 &amp;&amp; idx &lt; len) || length + idx &lt;= len);
1271 
1272   if (length == -1)
1273     length = len - idx;
1274 
1275   _replace_memory (buffer, len, idx, length, NULL);
1276 }
1277 
1278 /**
1279  * gst_buffer_find_memory:
1280  * @buffer: a #GstBuffer.
1281  * @offset: an offset
1282  * @size: a size
1283  * @idx: (out): pointer to index
1284  * @length: (out): pointer to length
1285  * @skip: (out): pointer to skip
1286  *
1287  * Find the memory blocks that span @size bytes starting from @offset
1288  * in @buffer.
1289  *
1290  * When this function returns %TRUE, @idx will contain the index of the first
1291  * memory block where the byte for @offset can be found and @length contains the
1292  * number of memory blocks containing the @size remaining bytes. @skip contains
1293  * the number of bytes to skip in the memory block at @idx to get to the byte
1294  * for @offset.
1295  *
1296  * @size can be -1 to get all the memory blocks after @idx.
1297  *
1298  * Returns: %TRUE when @size bytes starting from @offset could be found in
1299  * @buffer and @idx, @length and @skip will be filled.
1300  */
1301 gboolean
1302 gst_buffer_find_memory (GstBuffer * buffer, gsize offset, gsize size,
1303     guint * idx, guint * length, gsize * skip)
1304 {
1305   guint i, len, found;
1306 
1307   g_return_val_if_fail (GST_IS_BUFFER (buffer), FALSE);
1308   g_return_val_if_fail (idx != NULL, FALSE);
1309   g_return_val_if_fail (length != NULL, FALSE);
1310   g_return_val_if_fail (skip != NULL, FALSE);
1311 
1312   len = GST_BUFFER_MEM_LEN (buffer);
1313 
1314   found = 0;
1315   for (i = 0; i &lt; len; i++) {
1316     GstMemory *mem;
1317     gsize s;
1318 
1319     mem = GST_BUFFER_MEM_PTR (buffer, i);
1320     s = gst_memory_get_sizes (mem, NULL, NULL);
1321 
1322     if (s &lt;= offset) {
1323       /* block before offset, or empty block, skip */
1324       offset -= s;
1325     } else {
1326       /* block after offset */
1327       if (found == 0) {
1328         /* first block, remember index and offset */
1329         *idx = i;
1330         *skip = offset;
1331         if (size == -1) {
1332           /* return remaining blocks */
1333           *length = len - i;
1334           return TRUE;
1335         }
1336         s -= offset;
1337         offset = 0;
1338       }
1339       /* count the amount of found bytes */
1340       found += s;
1341       if (found &gt;= size) {
1342         /* we have enough bytes */
1343         *length = i - *idx + 1;
1344         return TRUE;
1345       }
1346     }
1347   }
1348   return FALSE;
1349 }
1350 
1351 /**
1352  * gst_buffer_is_memory_range_writable:
1353  * @buffer: a #GstBuffer.
1354  * @idx: an index
1355  * @length: a length should not be 0
1356  *
1357  * Check if @length memory blocks in @buffer starting from @idx are writable.
1358  *
1359  * @length can be -1 to check all the memory blocks after @idx.
1360  *
1361  * Note that this function does not check if @buffer is writable, use
1362  * gst_buffer_is_writable() to check that if needed.
1363  *
1364  * Returns: %TRUE if the memory range is writable
1365  *
1366  * Since: 1.4
1367  */
1368 gboolean
1369 gst_buffer_is_memory_range_writable (GstBuffer * buffer, guint idx, gint length)
1370 {
1371   guint i, len;
1372 
1373   g_return_val_if_fail (GST_IS_BUFFER (buffer), FALSE);
1374 
1375   GST_CAT_DEBUG (GST_CAT_BUFFER, &quot;idx %u, length %d&quot;, idx, length);
1376 
1377   len = GST_BUFFER_MEM_LEN (buffer);
1378   g_return_val_if_fail ((len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) ||
1379       (length == -1 &amp;&amp; idx &lt; len) || (length &gt; 0 &amp;&amp; length + idx &lt;= len),
1380       FALSE);
1381 #ifdef GSTREAMER_LITE
1382   gboolean expr = (len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) || (length == -1 &amp;&amp; idx &lt; len) || (length &gt; 0 &amp;&amp; length + idx &lt;= len);
1383   if (!expr) {
1384     return FALSE;
1385   }
1386 #endif // GSTREAMER_LITE
1387 
1388   if (length == -1)
1389     len -= idx;
1390   else
1391     len = length;
1392 
1393   for (i = 0; i &lt; len; i++) {
1394     if (!gst_memory_is_writable (GST_BUFFER_MEM_PTR (buffer, i + idx)))
1395       return FALSE;
1396   }
1397   return TRUE;
1398 }
1399 
1400 /**
1401  * gst_buffer_is_all_memory_writable:
1402  * @buffer: a #GstBuffer.
1403  *
1404  * Check if all memory blocks in @buffer are writable.
1405  *
1406  * Note that this function does not check if @buffer is writable, use
1407  * gst_buffer_is_writable() to check that if needed.
1408  *
1409  * Returns: %TRUE if all memory blocks in @buffer are writable
1410  *
1411  * Since: 1.4
1412  */
1413 gboolean
1414 gst_buffer_is_all_memory_writable (GstBuffer * buffer)
1415 {
1416   return gst_buffer_is_memory_range_writable (buffer, 0, -1);
1417 }
1418 
1419 /**
1420  * gst_buffer_get_sizes:
1421  * @buffer: a #GstBuffer.
1422  * @offset: (out) (allow-none): a pointer to the offset
1423  * @maxsize: (out) (allow-none): a pointer to the maxsize
1424  *
1425  * Get the total size of the memory blocks in @b.
1426  *
1427  * When not %NULL, @offset will contain the offset of the data in the
1428  * first memory block in @buffer and @maxsize will contain the sum of
1429  * the size and @offset and the amount of extra padding on the last
1430  * memory block.  @offset and @maxsize can be used to resize the
1431  * buffer memory blocks with gst_buffer_resize().
1432  *
1433  * Returns: total size of the memory blocks in @buffer.
1434  */
1435 gsize
1436 gst_buffer_get_sizes (GstBuffer * buffer, gsize * offset, gsize * maxsize)
1437 {
1438   return gst_buffer_get_sizes_range (buffer, 0, -1, offset, maxsize);
1439 }
1440 
1441 /**
1442  * gst_buffer_get_size:
1443  * @buffer: a #GstBuffer.
1444  *
1445  * Get the total size of the memory blocks in @buffer.
1446  *
1447  * Returns: total size of the memory blocks in @buffer.
1448  */
1449 gsize
1450 gst_buffer_get_size (GstBuffer * buffer)
1451 {
1452   return gst_buffer_get_sizes_range (buffer, 0, -1, NULL, NULL);
1453 }
1454 
1455 /**
1456  * gst_buffer_get_sizes_range:
1457  * @buffer: a #GstBuffer.
1458  * @idx: an index
1459  * @length: a length
1460  * @offset: (out) (allow-none): a pointer to the offset
1461  * @maxsize: (out) (allow-none): a pointer to the maxsize
1462  *
1463  * Get the total size of @length memory blocks stating from @idx in @buffer.
1464  *
1465  * When not %NULL, @offset will contain the offset of the data in the
1466  * memory block in @buffer at @idx and @maxsize will contain the sum of the size
1467  * and @offset and the amount of extra padding on the memory block at @idx +
1468  * @length -1.
1469  * @offset and @maxsize can be used to resize the buffer memory blocks with
1470  * gst_buffer_resize_range().
1471  *
1472  * Returns: total size of @length memory blocks starting at @idx in @buffer.
1473  */
1474 gsize
1475 gst_buffer_get_sizes_range (GstBuffer * buffer, guint idx, gint length,
1476     gsize * offset, gsize * maxsize)
1477 {
1478   guint len;
1479   gsize size;
1480   GstMemory *mem;
1481 
1482   g_return_val_if_fail (GST_IS_BUFFER (buffer), 0);
1483   len = GST_BUFFER_MEM_LEN (buffer);
1484   g_return_val_if_fail ((len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) ||
1485       (length == -1 &amp;&amp; idx &lt; len) || (length + idx &lt;= len), 0);
1486 #ifdef GSTREAMER_LITE
1487   gboolean expr = (len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) || (length == -1 &amp;&amp; idx &lt; len) || (length + idx &lt;= len);
1488   if (!expr) {
1489     return 0;
1490   }
1491 #endif // GSTREAMER_LITE
1492 
1493   if (length == -1)
1494     length = len - idx;
1495 
1496   if (G_LIKELY (length == 1)) {
1497     /* common case */
1498     mem = GST_BUFFER_MEM_PTR (buffer, idx);
1499     size = gst_memory_get_sizes (mem, offset, maxsize);
1500   } else {
1501     guint i, end;
1502     gsize extra, offs;
1503 
1504     end = idx + length;
1505     size = offs = extra = 0;
1506     for (i = idx; i &lt; end; i++) {
1507       gsize s, o, ms;
1508 
1509       mem = GST_BUFFER_MEM_PTR (buffer, i);
1510       s = gst_memory_get_sizes (mem, &amp;o, &amp;ms);
1511 
1512       if (s) {
1513         if (size == 0)
1514           /* first size, take accumulated data before as the offset */
1515           offs = extra + o;
1516         /* add sizes */
1517         size += s;
1518         /* save the amount of data after this block */
1519         extra = ms - (o + s);
1520       } else {
1521         /* empty block, add as extra */
1522         extra += ms;
1523       }
1524     }
1525     if (offset)
1526       *offset = offs;
1527     if (maxsize)
1528       *maxsize = offs + size + extra;
1529   }
1530   return size;
1531 }
1532 
1533 /**
1534  * gst_buffer_resize:
1535  * @buffer: a #GstBuffer.
1536  * @offset: the offset adjustment
1537  * @size: the new size or -1 to just adjust the offset
1538  *
1539  * Set the offset and total size of the memory blocks in @buffer.
1540  */
1541 void
1542 gst_buffer_resize (GstBuffer * buffer, gssize offset, gssize size)
1543 {
1544   gst_buffer_resize_range (buffer, 0, -1, offset, size);
1545 }
1546 
1547 /**
1548  * gst_buffer_set_size:
1549  * @buffer: a #GstBuffer.
1550  * @size: the new size
1551  *
1552  * Set the total size of the memory blocks in @buffer.
1553  */
1554 void
1555 gst_buffer_set_size (GstBuffer * buffer, gssize size)
1556 {
1557   gst_buffer_resize_range (buffer, 0, -1, 0, size);
1558 }
1559 
1560 /**
1561  * gst_buffer_resize_range:
1562  * @buffer: a #GstBuffer.
1563  * @idx: an index
1564  * @length: a length
1565  * @offset: the offset adjustment
1566  * @size: the new size or -1 to just adjust the offset
1567  *
1568  * Set the total size of the @length memory blocks starting at @idx in
1569  * @buffer
1570  *
1571  * Returns: %TRUE if resizing succeeded, %FALSE otherwise.
1572  */
1573 gboolean
1574 gst_buffer_resize_range (GstBuffer * buffer, guint idx, gint length,
1575     gssize offset, gssize size)
1576 {
1577   guint i, len, end;
1578   gsize bsize, bufsize, bufoffs, bufmax;
1579 
1580   g_return_val_if_fail (gst_buffer_is_writable (buffer), FALSE);
1581   g_return_val_if_fail (size &gt;= -1, FALSE);
1582 #ifdef GSTREAMER_LITE
1583   if (!gst_buffer_is_writable (buffer)) {
1584     return FALSE;
1585   }
1586   if (size &lt; -1) {
1587     return FALSE;
1588   }
1589 #endif // GSTREAMER_LITE
1590 
1591   len = GST_BUFFER_MEM_LEN (buffer);
1592   g_return_val_if_fail ((len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) ||
1593       (length == -1 &amp;&amp; idx &lt; len) || (length + idx &lt;= len), FALSE);
1594 #ifdef GSTREAMER_LITE
1595   gboolean expr = (len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) || (length == -1 &amp;&amp; idx &lt; len) || (length + idx &lt;= len);
1596   if (!expr) {
1597     return FALSE;
1598   }
1599 #endif // GSTREAMER_LITE
1600 
1601   if (length == -1)
1602     length = len - idx;
1603 
1604   bufsize = gst_buffer_get_sizes_range (buffer, idx, length, &amp;bufoffs, &amp;bufmax);
1605 
1606   GST_CAT_LOG (GST_CAT_BUFFER, &quot;trim %p %&quot; G_GSSIZE_FORMAT &quot;-%&quot; G_GSSIZE_FORMAT
1607       &quot; size:%&quot; G_GSIZE_FORMAT &quot; offs:%&quot; G_GSIZE_FORMAT &quot; max:%&quot;
1608       G_GSIZE_FORMAT, buffer, offset, size, bufsize, bufoffs, bufmax);
1609 
1610   /* we can&#39;t go back further than the current offset or past the end of the
1611    * buffer */
1612   g_return_val_if_fail ((offset &lt; 0 &amp;&amp; bufoffs &gt;= -offset) || (offset &gt;= 0
1613           &amp;&amp; bufoffs + offset &lt;= bufmax), FALSE);
1614 #ifdef GSTREAMER_LITE
1615   expr = (offset &lt; 0 &amp;&amp; bufoffs &gt;= -offset) || (offset &gt;= 0 &amp;&amp; bufoffs + offset &lt;= bufmax);
1616   if (!expr) {
1617     return FALSE;
1618   }
1619 #endif // GSTREAMER_LITE
1620   if (size == -1) {
1621     g_return_val_if_fail (bufsize &gt;= offset, FALSE);
1622 #ifdef GSTREAMER_LITE
1623   expr = bufsize &gt;= offset;
1624   if (!expr) {
1625     return FALSE;
1626   }
1627 #endif // GSTREAMER_LITE
1628     size = bufsize - offset;
1629   }
1630   g_return_val_if_fail (bufmax &gt;= bufoffs + offset + size, FALSE);
1631 #ifdef GSTREAMER_LITE
1632   expr = bufmax &gt;= bufoffs + offset + size;
1633   if (!expr) {
1634     return FALSE;
1635   }
1636 #endif // GSTREAMER_LITE
1637 
1638   /* no change */
1639   if (offset == 0 &amp;&amp; size == bufsize)
1640     return TRUE;
1641 
1642   end = idx + length;
1643   /* copy and trim */
1644   for (i = idx; i &lt; end; i++) {
1645     GstMemory *mem;
1646     gsize left, noffs;
1647 
1648     mem = GST_BUFFER_MEM_PTR (buffer, i);
1649     bsize = gst_memory_get_sizes (mem, NULL, NULL);
1650 
1651     noffs = 0;
1652     /* last buffer always gets resized to the remaining size */
1653     if (i + 1 == end)
1654       left = size;
1655     /* shrink buffers before the offset */
1656     else if ((gssize) bsize &lt;= offset) {
1657       left = 0;
1658       noffs = offset - bsize;
1659       offset = 0;
1660     }
1661     /* clip other buffers */
1662     else
1663       left = MIN (bsize - offset, size);
1664 
1665     if (offset != 0 || left != bsize) {
1666       if (gst_memory_is_writable (mem)) {
1667         gst_memory_resize (mem, offset, left);
1668       } else {
1669         GstMemory *newmem = NULL;
1670 
1671         if (!GST_MEMORY_IS_NO_SHARE (mem))
1672           newmem = gst_memory_share (mem, offset, left);
1673 
1674         if (!newmem)
1675           newmem = gst_memory_copy (mem, offset, left);
1676 
1677         if (newmem == NULL)
1678           return FALSE;
1679 
<a name="18" id="anc18"></a>

1680         gst_memory_lock (newmem, GST_LOCK_FLAG_EXCLUSIVE);
1681         GST_BUFFER_MEM_PTR (buffer, i) = newmem;
1682         gst_memory_unlock (mem, GST_LOCK_FLAG_EXCLUSIVE);
<a name="19" id="anc19"></a>

1683         gst_memory_unref (mem);
1684 
1685         GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
1686       }
1687     }
1688 
1689     offset = noffs;
1690     size -= left;
1691   }
1692 
1693   return TRUE;
1694 }
1695 
1696 /**
1697  * gst_buffer_map:
1698  * @buffer: a #GstBuffer.
1699  * @info: (out): info about the mapping
1700  * @flags: flags for the mapping
1701  *
1702  * This function fills @info with the #GstMapInfo of all merged memory
1703  * blocks in @buffer.
1704  *
1705  * @flags describe the desired access of the memory. When @flags is
1706  * #GST_MAP_WRITE, @buffer should be writable (as returned from
1707  * gst_buffer_is_writable()).
1708  *
1709  * When @buffer is writable but the memory isn&#39;t, a writable copy will
1710  * automatically be created and returned. The readonly copy of the
1711  * buffer memory will then also be replaced with this writable copy.
1712  *
1713  * The memory in @info should be unmapped with gst_buffer_unmap() after
1714  * usage.
1715  *
1716  * Returns: %TRUE if the map succeeded and @info contains valid data.
1717  */
1718 gboolean
1719 gst_buffer_map (GstBuffer * buffer, GstMapInfo * info, GstMapFlags flags)
1720 {
1721   return gst_buffer_map_range (buffer, 0, -1, info, flags);
1722 }
1723 
1724 /**
1725  * gst_buffer_map_range:
1726  * @buffer: a #GstBuffer.
1727  * @idx: an index
1728  * @length: a length
1729  * @info: (out): info about the mapping
1730  * @flags: flags for the mapping
1731  *
1732  * This function fills @info with the #GstMapInfo of @length merged memory blocks
1733  * starting at @idx in @buffer. When @length is -1, all memory blocks starting
1734  * from @idx are merged and mapped.
1735  *
1736  * @flags describe the desired access of the memory. When @flags is
1737  * #GST_MAP_WRITE, @buffer should be writable (as returned from
1738  * gst_buffer_is_writable()).
1739  *
1740  * When @buffer is writable but the memory isn&#39;t, a writable copy will
1741  * automatically be created and returned. The readonly copy of the buffer memory
1742  * will then also be replaced with this writable copy.
1743  *
1744  * The memory in @info should be unmapped with gst_buffer_unmap() after usage.
1745  *
1746  * Returns: %TRUE if the map succeeded and @info contains valid
1747  * data.
1748  */
1749 gboolean
1750 gst_buffer_map_range (GstBuffer * buffer, guint idx, gint length,
1751     GstMapInfo * info, GstMapFlags flags)
1752 {
1753   GstMemory *mem, *nmem;
1754   gboolean write, writable;
1755   gsize len;
1756 
1757   g_return_val_if_fail (GST_IS_BUFFER (buffer), FALSE);
1758   g_return_val_if_fail (info != NULL, FALSE);
1759   len = GST_BUFFER_MEM_LEN (buffer);
1760   g_return_val_if_fail ((len == 0 &amp;&amp; idx == 0 &amp;&amp; length == -1) ||
1761       (length == -1 &amp;&amp; idx &lt; len) || (length &gt; 0
1762           &amp;&amp; length + idx &lt;= len), FALSE);
1763 
1764   GST_CAT_LOG (GST_CAT_BUFFER, &quot;buffer %p, idx %u, length %d, flags %04x&quot;,
1765       buffer, idx, length, flags);
1766 
1767   write = (flags &amp; GST_MAP_WRITE) != 0;
1768   writable = gst_buffer_is_writable (buffer);
1769 
1770   /* check if we can write when asked for write access */
1771   if (G_UNLIKELY (write &amp;&amp; !writable))
1772     goto not_writable;
1773 
1774   if (length == -1)
1775     length = len - idx;
1776 
1777   mem = _get_merged_memory (buffer, idx, length);
1778   if (G_UNLIKELY (mem == NULL))
1779     goto no_memory;
1780 
1781   /* now try to map */
1782   nmem = gst_memory_make_mapped (mem, info, flags);
1783   if (G_UNLIKELY (nmem == NULL))
1784     goto cannot_map;
1785 
1786   /* if we merged or when the map returned a different memory, we try to replace
1787    * the memory in the buffer */
1788   if (G_UNLIKELY (length &gt; 1 || nmem != mem)) {
1789     /* if the buffer is writable, replace the memory */
1790     if (writable) {
1791       _replace_memory (buffer, len, idx, length, gst_memory_ref (nmem));
1792     } else {
1793       if (len &gt; 1) {
1794         GST_CAT_DEBUG (GST_CAT_PERFORMANCE,
1795             &quot;temporary mapping for memory %p in buffer %p&quot;, nmem, buffer);
1796       }
1797     }
1798   }
1799   return TRUE;
1800 
1801   /* ERROR */
1802 not_writable:
1803   {
1804     GST_WARNING_OBJECT (buffer, &quot;write map requested on non-writable buffer&quot;);
1805     g_critical (&quot;write map requested on non-writable buffer&quot;);
1806     memset (info, 0, sizeof (GstMapInfo));
1807     return FALSE;
1808   }
1809 no_memory:
1810   {
1811     /* empty buffer, we need to return NULL */
1812     GST_DEBUG_OBJECT (buffer, &quot;can&#39;t get buffer memory&quot;);
1813     memset (info, 0, sizeof (GstMapInfo));
1814     return TRUE;
1815   }
1816 cannot_map:
1817   {
1818     GST_DEBUG_OBJECT (buffer, &quot;cannot map memory&quot;);
1819     memset (info, 0, sizeof (GstMapInfo));
1820     return FALSE;
1821   }
1822 }
1823 
1824 /**
1825  * gst_buffer_unmap:
1826  * @buffer: a #GstBuffer.
1827  * @info: a #GstMapInfo
1828  *
1829  * Release the memory previously mapped with gst_buffer_map().
1830  */
1831 void
1832 gst_buffer_unmap (GstBuffer * buffer, GstMapInfo * info)
1833 {
1834   g_return_if_fail (GST_IS_BUFFER (buffer));
1835   g_return_if_fail (info != NULL);
1836 
1837   /* we need to check for NULL, it is possible that we tried to map a buffer
1838    * without memory and we should be able to unmap that fine */
1839   if (G_LIKELY (info-&gt;memory)) {
1840     gst_memory_unmap (info-&gt;memory, info);
1841     gst_memory_unref (info-&gt;memory);
1842   }
1843 }
1844 
1845 /**
1846  * gst_buffer_fill:
1847  * @buffer: a #GstBuffer.
1848  * @offset: the offset to fill
1849  * @src: (array length=size) (element-type guint8): the source address
1850  * @size: the size to fill
1851  *
1852  * Copy @size bytes from @src to @buffer at @offset.
1853  *
1854  * Returns: The amount of bytes copied. This value can be lower than @size
1855  *    when @buffer did not contain enough data.
1856  */
1857 gsize
1858 gst_buffer_fill (GstBuffer * buffer, gsize offset, gconstpointer src,
1859     gsize size)
1860 {
1861   gsize i, len, left;
1862   const guint8 *ptr = src;
1863 
1864   g_return_val_if_fail (GST_IS_BUFFER (buffer), 0);
1865   g_return_val_if_fail (gst_buffer_is_writable (buffer), 0);
1866   g_return_val_if_fail (src != NULL || size == 0, 0);
1867 
1868   GST_CAT_LOG (GST_CAT_BUFFER,
1869       &quot;buffer %p, offset %&quot; G_GSIZE_FORMAT &quot;, size %&quot; G_GSIZE_FORMAT, buffer,
1870       offset, size);
1871 
1872   len = GST_BUFFER_MEM_LEN (buffer);
1873   left = size;
1874 
1875   for (i = 0; i &lt; len &amp;&amp; left &gt; 0; i++) {
1876     GstMapInfo info;
1877     gsize tocopy;
1878     GstMemory *mem;
1879 
1880     mem = _get_mapped (buffer, i, &amp;info, GST_MAP_WRITE);
1881     if (info.size &gt; offset) {
1882       /* we have enough */
1883       tocopy = MIN (info.size - offset, left);
1884       memcpy ((guint8 *) info.data + offset, ptr, tocopy);
1885       left -= tocopy;
1886       ptr += tocopy;
1887       offset = 0;
1888     } else {
1889       /* offset past buffer, skip */
1890       offset -= info.size;
1891     }
1892     gst_memory_unmap (mem, &amp;info);
1893   }
1894   return size - left;
1895 }
1896 
1897 /**
1898  * gst_buffer_extract:
1899  * @buffer: a #GstBuffer.
1900  * @offset: the offset to extract
1901  * @dest: (out caller-allocates) (array length=size) (element-type guint8):
1902  *     the destination address
1903  * @size: the size to extract
1904  *
1905  * Copy @size bytes starting from @offset in @buffer to @dest.
1906  *
1907  * Returns: The amount of bytes extracted. This value can be lower than @size
1908  *    when @buffer did not contain enough data.
1909  */
1910 gsize
1911 gst_buffer_extract (GstBuffer * buffer, gsize offset, gpointer dest, gsize size)
1912 {
1913   gsize i, len, left;
1914   guint8 *ptr = dest;
1915 
1916   g_return_val_if_fail (GST_IS_BUFFER (buffer), 0);
1917   g_return_val_if_fail (dest != NULL, 0);
1918 
1919   GST_CAT_LOG (GST_CAT_BUFFER,
1920       &quot;buffer %p, offset %&quot; G_GSIZE_FORMAT &quot;, size %&quot; G_GSIZE_FORMAT, buffer,
1921       offset, size);
1922 
1923   len = GST_BUFFER_MEM_LEN (buffer);
1924   left = size;
1925 
1926   for (i = 0; i &lt; len &amp;&amp; left &gt; 0; i++) {
1927     GstMapInfo info;
1928     gsize tocopy;
1929     GstMemory *mem;
1930 
1931     mem = _get_mapped (buffer, i, &amp;info, GST_MAP_READ);
1932     if (info.size &gt; offset) {
1933       /* we have enough */
1934       tocopy = MIN (info.size - offset, left);
1935       memcpy (ptr, (guint8 *) info.data + offset, tocopy);
1936       left -= tocopy;
1937       ptr += tocopy;
1938       offset = 0;
1939     } else {
1940       /* offset past buffer, skip */
1941       offset -= info.size;
1942     }
1943     gst_memory_unmap (mem, &amp;info);
1944   }
1945   return size - left;
1946 }
1947 
1948 /**
1949  * gst_buffer_memcmp:
1950  * @buffer: a #GstBuffer.
1951  * @offset: the offset in @buffer
1952  * @mem: (array length=size) (element-type guint8): the memory to compare
1953  * @size: the size to compare
1954  *
1955  * Compare @size bytes starting from @offset in @buffer with the memory in @mem.
1956  *
1957  * Returns: 0 if the memory is equal.
1958  */
1959 gint
1960 gst_buffer_memcmp (GstBuffer * buffer, gsize offset, gconstpointer mem,
1961     gsize size)
1962 {
1963   gsize i, len;
1964   const guint8 *ptr = mem;
1965   gint res = 0;
1966 
1967   g_return_val_if_fail (GST_IS_BUFFER (buffer), 0);
1968   g_return_val_if_fail (mem != NULL, 0);
1969 
1970   GST_CAT_LOG (GST_CAT_BUFFER,
1971       &quot;buffer %p, offset %&quot; G_GSIZE_FORMAT &quot;, size %&quot; G_GSIZE_FORMAT, buffer,
1972       offset, size);
1973 
1974   if (G_UNLIKELY (gst_buffer_get_size (buffer) &lt; offset + size))
1975     return -1;
1976 
1977   len = GST_BUFFER_MEM_LEN (buffer);
1978 
1979   for (i = 0; i &lt; len &amp;&amp; size &gt; 0 &amp;&amp; res == 0; i++) {
1980     GstMapInfo info;
1981     gsize tocmp;
1982     GstMemory *mem;
1983 
1984     mem = _get_mapped (buffer, i, &amp;info, GST_MAP_READ);
1985     if (info.size &gt; offset) {
1986       /* we have enough */
1987       tocmp = MIN (info.size - offset, size);
1988       res = memcmp (ptr, (guint8 *) info.data + offset, tocmp);
1989       size -= tocmp;
1990       ptr += tocmp;
1991       offset = 0;
1992     } else {
1993       /* offset past buffer, skip */
1994       offset -= info.size;
1995     }
1996     gst_memory_unmap (mem, &amp;info);
1997   }
1998   return res;
1999 }
2000 
2001 /**
2002  * gst_buffer_memset:
2003  * @buffer: a #GstBuffer.
2004  * @offset: the offset in @buffer
2005  * @val: the value to set
2006  * @size: the size to set
2007  *
2008  * Fill @buf with @size bytes with @val starting from @offset.
2009  *
2010  * Returns: The amount of bytes filled. This value can be lower than @size
2011  *    when @buffer did not contain enough data.
2012  */
2013 gsize
2014 gst_buffer_memset (GstBuffer * buffer, gsize offset, guint8 val, gsize size)
2015 {
2016   gsize i, len, left;
2017 
2018   g_return_val_if_fail (GST_IS_BUFFER (buffer), 0);
2019   g_return_val_if_fail (gst_buffer_is_writable (buffer), 0);
2020 
2021   GST_CAT_LOG (GST_CAT_BUFFER,
2022       &quot;buffer %p, offset %&quot; G_GSIZE_FORMAT &quot;, val %02x, size %&quot; G_GSIZE_FORMAT,
2023       buffer, offset, val, size);
2024 
2025   len = GST_BUFFER_MEM_LEN (buffer);
2026   left = size;
2027 
2028   for (i = 0; i &lt; len &amp;&amp; left &gt; 0; i++) {
2029     GstMapInfo info;
2030     gsize toset;
2031     GstMemory *mem;
2032 
2033     mem = _get_mapped (buffer, i, &amp;info, GST_MAP_WRITE);
2034     if (info.size &gt; offset) {
2035       /* we have enough */
2036       toset = MIN (info.size - offset, left);
2037       memset ((guint8 *) info.data + offset, val, toset);
2038       left -= toset;
2039       offset = 0;
2040     } else {
2041       /* offset past buffer, skip */
2042       offset -= info.size;
2043     }
2044     gst_memory_unmap (mem, &amp;info);
2045   }
2046   return size - left;
2047 }
2048 
2049 /**
2050  * gst_buffer_copy_region:
2051  * @parent: a #GstBuffer.
2052  * @flags: the #GstBufferCopyFlags
2053  * @offset: the offset into parent #GstBuffer at which the new sub-buffer
2054  *          begins.
2055  * @size: the size of the new #GstBuffer sub-buffer, in bytes. If -1, all
2056  *        data is copied.
2057  *
2058  * Creates a sub-buffer from @parent at @offset and @size.
2059  * This sub-buffer uses the actual memory space of the parent buffer.
2060  * This function will copy the offset and timestamp fields when the
2061  * offset is 0. If not, they will be set to #GST_CLOCK_TIME_NONE and
2062  * #GST_BUFFER_OFFSET_NONE.
2063  * If @offset equals 0 and @size equals the total size of @buffer, the
2064  * duration and offset end fields are also copied. If not they will be set
2065  * to #GST_CLOCK_TIME_NONE and #GST_BUFFER_OFFSET_NONE.
2066  *
2067  * MT safe.
2068  *
2069  * Returns: (transfer full): the new #GstBuffer or %NULL if the arguments were
2070  *     invalid.
2071  */
2072 GstBuffer *
2073 gst_buffer_copy_region (GstBuffer * buffer, GstBufferCopyFlags flags,
2074     gsize offset, gsize size)
2075 {
2076   GstBuffer *copy;
2077 
2078   g_return_val_if_fail (buffer != NULL, NULL);
2079 
2080   /* create the new buffer */
2081   copy = gst_buffer_new ();
2082 
2083   GST_CAT_LOG (GST_CAT_BUFFER, &quot;new region copy %p of %p %&quot; G_GSIZE_FORMAT
2084       &quot;-%&quot; G_GSIZE_FORMAT, copy, buffer, offset, size);
2085 
2086   if (!gst_buffer_copy_into (copy, buffer, flags, offset, size))
2087     gst_buffer_replace (&amp;copy, NULL);
2088 
2089   return copy;
2090 }
2091 
2092 /**
2093  * gst_buffer_append:
2094  * @buf1: (transfer full): the first source #GstBuffer to append.
2095  * @buf2: (transfer full): the second source #GstBuffer to append.
2096  *
2097  * Append all the memory from @buf2 to @buf1. The result buffer will contain a
2098  * concatenation of the memory of @buf1 and @buf2.
2099  *
2100  * Returns: (transfer full): the new #GstBuffer that contains the memory
2101  *     of the two source buffers.
2102  */
2103 GstBuffer *
2104 gst_buffer_append (GstBuffer * buf1, GstBuffer * buf2)
2105 {
2106   return gst_buffer_append_region (buf1, buf2, 0, -1);
2107 }
2108 
2109 /**
2110  * gst_buffer_append_region:
2111  * @buf1: (transfer full): the first source #GstBuffer to append.
2112  * @buf2: (transfer full): the second source #GstBuffer to append.
2113  * @offset: the offset in @buf2
2114  * @size: the size or -1 of @buf2
2115  *
2116  * Append @size bytes at @offset from @buf2 to @buf1. The result buffer will
2117  * contain a concatenation of the memory of @buf1 and the requested region of
2118  * @buf2.
2119  *
2120  * Returns: (transfer full): the new #GstBuffer that contains the memory
2121  *     of the two source buffers.
2122  */
2123 GstBuffer *
2124 gst_buffer_append_region (GstBuffer * buf1, GstBuffer * buf2, gssize offset,
2125     gssize size)
2126 {
2127   gsize i, len;
2128 
2129   g_return_val_if_fail (GST_IS_BUFFER (buf1), NULL);
2130   g_return_val_if_fail (GST_IS_BUFFER (buf2), NULL);
2131 
2132   buf1 = gst_buffer_make_writable (buf1);
2133   buf2 = gst_buffer_make_writable (buf2);
2134 
2135   gst_buffer_resize (buf2, offset, size);
2136 
2137   len = GST_BUFFER_MEM_LEN (buf2);
2138   for (i = 0; i &lt; len; i++) {
2139     GstMemory *mem;
2140 
2141     mem = GST_BUFFER_MEM_PTR (buf2, i);
<a name="20" id="anc20"></a>

2142     GST_BUFFER_MEM_PTR (buf2, i) = NULL;
2143     _memory_add (buf1, -1, mem);
2144   }
2145 
2146   GST_BUFFER_MEM_LEN (buf2) = 0;
2147   GST_BUFFER_FLAG_SET (buf2, GST_BUFFER_FLAG_TAG_MEMORY);
2148   gst_buffer_unref (buf2);
2149 
2150   return buf1;
2151 }
2152 
2153 /**
2154  * gst_buffer_get_meta:
2155  * @buffer: a #GstBuffer
2156  * @api: the #GType of an API
2157  *
2158  * Get the metadata for @api on buffer. When there is no such metadata, %NULL is
2159  * returned. If multiple metadata with the given @api are attached to this
2160  * buffer only the first one is returned.  To handle multiple metadata with a
2161  * given API use gst_buffer_iterate_meta() or gst_buffer_foreach_meta() instead
2162  * and check the meta-&gt;info.api member for the API type.
2163  *
2164  * Returns: (transfer none) (nullable): the metadata for @api on
2165  * @buffer.
2166  */
2167 GstMeta *
2168 gst_buffer_get_meta (GstBuffer * buffer, GType api)
2169 {
2170   GstMetaItem *item;
2171   GstMeta *result = NULL;
2172 
2173   g_return_val_if_fail (buffer != NULL, NULL);
2174   g_return_val_if_fail (api != 0, NULL);
2175 
2176   /* find GstMeta of the requested API */
2177   for (item = GST_BUFFER_META (buffer); item; item = item-&gt;next) {
2178     GstMeta *meta = &amp;item-&gt;meta;
2179     if (meta-&gt;info-&gt;api == api) {
2180       result = meta;
2181       break;
2182     }
2183   }
2184   return result;
2185 }
2186 
2187 /**
2188  * gst_buffer_get_n_meta:
2189  * @buffer: a #GstBuffer
2190  * @api_type: the #GType of an API
2191  *
2192  * Returns: number of metas of type @api_type on @buffer.
2193  *
2194  * Since: 1.14
2195  */
2196 guint
2197 gst_buffer_get_n_meta (GstBuffer * buffer, GType api_type)
2198 {
2199   gpointer state = NULL;
2200   GstMeta *meta;
2201   guint n = 0;
2202 
2203   while ((meta = gst_buffer_iterate_meta_filtered (buffer, &amp;state, api_type)))
2204     ++n;
2205 
2206   return n;
2207 }
2208 
2209 /**
2210  * gst_buffer_add_meta:
2211  * @buffer: a #GstBuffer
2212  * @info: a #GstMetaInfo
2213  * @params: params for @info
2214  *
2215  * Add metadata for @info to @buffer using the parameters in @params.
2216  *
2217  * Returns: (transfer none) (nullable): the metadata for the api in @info on @buffer.
2218  */
2219 GstMeta *
2220 gst_buffer_add_meta (GstBuffer * buffer, const GstMetaInfo * info,
2221     gpointer params)
2222 {
2223   GstMetaItem *item;
2224   GstMeta *result = NULL;
2225   gsize size;
2226 
2227   g_return_val_if_fail (buffer != NULL, NULL);
2228   g_return_val_if_fail (info != NULL, NULL);
2229   g_return_val_if_fail (gst_buffer_is_writable (buffer), NULL);
2230 
2231   /* create a new slice */
2232   size = ITEM_SIZE (info);
2233   /* We warn in gst_meta_register() about metas without
2234    * init function but let&#39;s play safe here and prevent
2235    * uninitialized memory
2236    */
2237   if (!info-&gt;init_func)
2238     item = g_slice_alloc0 (size);
2239   else
<a name="21" id="anc21"></a><span class="line-modified">2240   item = g_slice_alloc (size);</span>
2241   result = &amp;item-&gt;meta;
2242   result-&gt;info = info;
2243   result-&gt;flags = GST_META_FLAG_NONE;
2244   GST_CAT_DEBUG (GST_CAT_BUFFER,
2245       &quot;alloc metadata %p (%s) of size %&quot; G_GSIZE_FORMAT, result,
2246       g_type_name (info-&gt;type), info-&gt;size);
2247 
2248   /* call the init_func when needed */
2249   if (info-&gt;init_func)
2250     if (!info-&gt;init_func (result, params, buffer))
2251       goto init_failed;
2252 
<a name="22" id="anc22"></a><span class="line-modified">2253   /* and add to the list of metadata */</span>
<span class="line-modified">2254   item-&gt;next = GST_BUFFER_META (buffer);</span>
<span class="line-modified">2255   GST_BUFFER_META (buffer) = item;</span>







2256 
2257   return result;
2258 
2259 init_failed:
2260   {
2261     g_slice_free1 (size, item);
2262     return NULL;
2263   }
2264 }
2265 
2266 /**
2267  * gst_buffer_remove_meta:
2268  * @buffer: a #GstBuffer
2269  * @meta: a #GstMeta
2270  *
2271  * Remove the metadata for @meta on @buffer.
2272  *
2273  * Returns: %TRUE if the metadata existed and was removed, %FALSE if no such
2274  * metadata was on @buffer.
2275  */
2276 gboolean
2277 gst_buffer_remove_meta (GstBuffer * buffer, GstMeta * meta)
2278 {
2279   GstMetaItem *walk, *prev;
2280 
2281   g_return_val_if_fail (buffer != NULL, FALSE);
2282   g_return_val_if_fail (meta != NULL, FALSE);
2283   g_return_val_if_fail (gst_buffer_is_writable (buffer), FALSE);
2284   g_return_val_if_fail (!GST_META_FLAG_IS_SET (meta, GST_META_FLAG_LOCKED),
2285       FALSE);
2286 
2287   /* find the metadata and delete */
2288   prev = GST_BUFFER_META (buffer);
2289   for (walk = prev; walk; walk = walk-&gt;next) {
2290     GstMeta *m = &amp;walk-&gt;meta;
2291     if (m == meta) {
2292       const GstMetaInfo *info = meta-&gt;info;
2293 
2294       /* remove from list */
<a name="23" id="anc23"></a>






2295       if (GST_BUFFER_META (buffer) == walk)
2296         GST_BUFFER_META (buffer) = walk-&gt;next;
2297       else
2298         prev-&gt;next = walk-&gt;next;
<a name="24" id="anc24"></a>
2299       /* call free_func if any */
2300       if (info-&gt;free_func)
2301         info-&gt;free_func (m, buffer);
2302 
2303       /* and free the slice */
2304       g_slice_free1 (ITEM_SIZE (info), walk);
2305       break;
2306     }
2307     prev = walk;
2308   }
2309   return walk != NULL;
2310 }
2311 
2312 /**
2313  * gst_buffer_iterate_meta: (skip)
2314  * @buffer: a #GstBuffer
2315  * @state: (out caller-allocates): an opaque state pointer
2316  *
2317  * Retrieve the next #GstMeta after @current. If @state points
2318  * to %NULL, the first metadata is returned.
2319  *
2320  * @state will be updated with an opaque state pointer
2321  *
2322  * Returns: (transfer none) (nullable): The next #GstMeta or %NULL
2323  * when there are no more items.
2324  */
2325 GstMeta *
2326 gst_buffer_iterate_meta (GstBuffer * buffer, gpointer * state)
2327 {
2328   GstMetaItem **meta;
2329 
2330   g_return_val_if_fail (buffer != NULL, NULL);
2331   g_return_val_if_fail (state != NULL, NULL);
2332 
2333   meta = (GstMetaItem **) state;
2334   if (*meta == NULL)
2335     /* state NULL, move to first item */
2336     *meta = GST_BUFFER_META (buffer);
2337   else
2338     /* state !NULL, move to next item in list */
2339     *meta = (*meta)-&gt;next;
2340 
2341   if (*meta)
2342     return &amp;(*meta)-&gt;meta;
2343   else
2344     return NULL;
2345 }
2346 
2347 /**
2348  * gst_buffer_iterate_meta_filtered: (skip)
2349  * @buffer: a #GstBuffer
2350  * @state: (out caller-allocates): an opaque state pointer
2351  * @meta_api_type: only return #GstMeta of this type
2352  *
2353  * Retrieve the next #GstMeta of type @meta_api_type after the current one
2354  * according to @state. If @state points to %NULL, the first metadata of
2355  * type @meta_api_type is returned.
2356  *
2357  * @state will be updated with an opaque state pointer
2358  *
2359  * Returns: (transfer none) (nullable): The next #GstMeta of type
2360  * @meta_api_type or %NULL when there are no more items.
2361  *
2362  * Since: 1.12
2363  */
2364 GstMeta *
2365 gst_buffer_iterate_meta_filtered (GstBuffer * buffer, gpointer * state,
2366     GType meta_api_type)
2367 {
2368   GstMetaItem **meta;
2369 
2370   g_return_val_if_fail (buffer != NULL, NULL);
2371   g_return_val_if_fail (state != NULL, NULL);
2372 
2373   meta = (GstMetaItem **) state;
2374   if (*meta == NULL)
2375     /* state NULL, move to first item */
2376     *meta = GST_BUFFER_META (buffer);
2377   else
2378     /* state !NULL, move to next item in list */
2379     *meta = (*meta)-&gt;next;
2380 
2381   while (*meta != NULL &amp;&amp; (*meta)-&gt;meta.info-&gt;api != meta_api_type)
2382     *meta = (*meta)-&gt;next;
2383 
2384   if (*meta)
2385     return &amp;(*meta)-&gt;meta;
2386   else
2387     return NULL;
2388 }
2389 
2390 /**
2391  * gst_buffer_foreach_meta:
2392  * @buffer: a #GstBuffer
2393  * @func: (scope call): a #GstBufferForeachMetaFunc to call
2394  * @user_data: (closure): user data passed to @func
2395  *
2396  * Call @func with @user_data for each meta in @buffer.
2397  *
2398  * @func can modify the passed meta pointer or its contents. The return value
2399  * of @func define if this function returns or if the remaining metadata items
2400  * in the buffer should be skipped.
2401  *
2402  * Returns: %FALSE when @func returned %FALSE for one of the metadata.
2403  */
2404 gboolean
2405 gst_buffer_foreach_meta (GstBuffer * buffer, GstBufferForeachMetaFunc func,
2406     gpointer user_data)
2407 {
2408   GstMetaItem *walk, *prev, *next;
2409   gboolean res = TRUE;
2410 
2411   g_return_val_if_fail (buffer != NULL, FALSE);
2412   g_return_val_if_fail (func != NULL, FALSE);
2413 
2414   /* find the metadata and delete */
2415   prev = GST_BUFFER_META (buffer);
2416   for (walk = prev; walk; walk = next) {
2417     GstMeta *m, *new;
2418 
2419     m = new = &amp;walk-&gt;meta;
2420     next = walk-&gt;next;
2421 
2422     res = func (buffer, &amp;new, user_data);
2423 
2424     if (new == NULL) {
2425       const GstMetaInfo *info = m-&gt;info;
2426 
2427       GST_CAT_DEBUG (GST_CAT_BUFFER, &quot;remove metadata %p (%s)&quot;, m,
2428           g_type_name (info-&gt;type));
2429 
2430       g_return_val_if_fail (gst_buffer_is_writable (buffer), FALSE);
2431       g_return_val_if_fail (!GST_META_FLAG_IS_SET (m, GST_META_FLAG_LOCKED),
2432           FALSE);
2433 
<a name="25" id="anc25"></a>






2434       /* remove from list */
2435       if (GST_BUFFER_META (buffer) == walk)
<a name="26" id="anc26"></a><span class="line-modified">2436         GST_BUFFER_META (buffer) = next;</span>
2437       else
2438         prev-&gt;next = next;
2439 
<a name="27" id="anc27"></a><span class="line-removed">2440       prev = next;</span>
<span class="line-removed">2441 </span>
2442       /* call free_func if any */
2443       if (info-&gt;free_func)
2444         info-&gt;free_func (m, buffer);
2445 
2446       /* and free the slice */
2447       g_slice_free1 (ITEM_SIZE (info), walk);
2448     } else {
2449       prev = walk;
2450     }
2451     if (!res)
2452       break;
2453   }
2454   return res;
2455 }
2456 
2457 /**
2458  * gst_buffer_extract_dup:
2459  * @buffer: a #GstBuffer
2460  * @offset: the offset to extract
2461  * @size: the size to extract
2462  * @dest: (array length=dest_size) (element-type guint8) (out): A pointer where
2463  *  the destination array will be written. Might be %NULL if the size is 0.
2464  * @dest_size: (out): A location where the size of @dest can be written
2465  *
2466  * Extracts a copy of at most @size bytes the data at @offset into
2467  * newly-allocated memory. @dest must be freed using g_free() when done.
2468  *
2469  * Since: 1.0.10
2470  */
2471 
2472 void
2473 gst_buffer_extract_dup (GstBuffer * buffer, gsize offset, gsize size,
2474     gpointer * dest, gsize * dest_size)
2475 {
2476   gsize real_size, alloc_size;
2477 
2478   real_size = gst_buffer_get_size (buffer);
2479 
2480   alloc_size = MIN (real_size - offset, size);
2481   if (alloc_size == 0) {
2482     *dest = NULL;
2483     *dest_size = 0;
2484   } else {
2485     *dest = g_malloc (alloc_size);
<a name="28" id="anc28"></a><span class="line-modified">2486   *dest_size = gst_buffer_extract (buffer, offset, *dest, size);</span>
<span class="line-modified">2487 }</span>
2488 }
2489 
2490 GST_DEBUG_CATEGORY_STATIC (gst_parent_buffer_meta_debug);
2491 
2492 /**
2493  * gst_buffer_add_parent_buffer_meta:
2494  * @buffer: (transfer none): a #GstBuffer
2495  * @ref: (transfer none): a #GstBuffer to ref
2496  *
2497  * Add a #GstParentBufferMeta to @buffer that holds a reference on
2498  * @ref until the buffer is freed.
2499  *
2500  * Returns: (transfer none) (nullable): The #GstParentBufferMeta that was added to the buffer
2501  *
2502  * Since: 1.6
2503  */
2504 GstParentBufferMeta *
2505 gst_buffer_add_parent_buffer_meta (GstBuffer * buffer, GstBuffer * ref)
2506 {
2507   GstParentBufferMeta *meta;
2508 
2509   g_return_val_if_fail (GST_IS_BUFFER (ref), NULL);
2510 
2511   meta =
2512       (GstParentBufferMeta *) gst_buffer_add_meta (buffer,
2513       GST_PARENT_BUFFER_META_INFO, NULL);
2514 
2515   if (!meta)
2516     return NULL;
2517 
2518   meta-&gt;buffer = gst_buffer_ref (ref);
2519 
2520   return meta;
2521 }
2522 
2523 static gboolean
2524 _gst_parent_buffer_meta_transform (GstBuffer * dest, GstMeta * meta,
2525     GstBuffer * buffer, GQuark type, gpointer data)
2526 {
2527   GstParentBufferMeta *dmeta, *smeta;
2528 
2529   smeta = (GstParentBufferMeta *) meta;
2530 
2531   if (GST_META_TRANSFORM_IS_COPY (type)) {
2532     /* copy over the reference to the parent buffer.
2533      * Usually, this meta means we need to keep the parent buffer
2534      * alive because one of the child memories is in use, which
2535      * might not be the case if memory is deep copied or sub-regioned,
2536      * but we can&#39;t tell, so keep the meta */
2537     dmeta = gst_buffer_add_parent_buffer_meta (dest, smeta-&gt;buffer);
2538     if (!dmeta)
2539       return FALSE;
2540 
2541     GST_CAT_DEBUG (gst_parent_buffer_meta_debug,
2542         &quot;copy buffer reference metadata&quot;);
2543   } else {
2544     /* return FALSE, if transform type is not supported */
2545     return FALSE;
2546   }
2547   return TRUE;
2548 }
2549 
2550 static void
2551 _gst_parent_buffer_meta_free (GstParentBufferMeta * parent_meta,
2552     GstBuffer * buffer)
2553 {
2554   GST_CAT_DEBUG (gst_parent_buffer_meta_debug,
2555       &quot;Dropping reference on buffer %p&quot;, parent_meta-&gt;buffer);
2556   gst_buffer_unref (parent_meta-&gt;buffer);
2557 }
2558 
2559 static gboolean
2560 _gst_parent_buffer_meta_init (GstParentBufferMeta * parent_meta,
2561     gpointer params, GstBuffer * buffer)
2562 {
2563   static volatile gsize _init;
2564 
2565   if (g_once_init_enter (&amp;_init)) {
2566     GST_DEBUG_CATEGORY_INIT (gst_parent_buffer_meta_debug, &quot;parentbuffermeta&quot;,
2567         0, &quot;parentbuffermeta&quot;);
2568     g_once_init_leave (&amp;_init, 1);
2569   }
2570 
2571   parent_meta-&gt;buffer = NULL;
2572 
2573   return TRUE;
2574 }
2575 
2576 GType
2577 gst_parent_buffer_meta_api_get_type (void)
2578 {
2579   static volatile GType type = 0;
2580   static const gchar *tags[] = { NULL };
2581 
2582   if (g_once_init_enter (&amp;type)) {
2583     GType _type = gst_meta_api_type_register (&quot;GstParentBufferMetaAPI&quot;, tags);
2584     g_once_init_leave (&amp;type, _type);
2585   }
2586 
2587   return type;
2588 }
2589 
2590 /**
2591  * gst_parent_buffer_meta_get_info:
2592  *
2593  * Get the global #GstMetaInfo describing  the #GstParentBufferMeta meta.
2594  *
2595  * Returns: (transfer none): The #GstMetaInfo
2596  *
2597  * Since: 1.6
2598  */
2599 const GstMetaInfo *
2600 gst_parent_buffer_meta_get_info (void)
2601 {
2602   static const GstMetaInfo *meta_info = NULL;
2603 
2604   if (g_once_init_enter ((GstMetaInfo **) &amp; meta_info)) {
2605     const GstMetaInfo *meta =
2606         gst_meta_register (gst_parent_buffer_meta_api_get_type (),
2607         &quot;GstParentBufferMeta&quot;,
2608         sizeof (GstParentBufferMeta),
2609         (GstMetaInitFunction) _gst_parent_buffer_meta_init,
2610         (GstMetaFreeFunction) _gst_parent_buffer_meta_free,
2611         _gst_parent_buffer_meta_transform);
2612     g_once_init_leave ((GstMetaInfo **) &amp; meta_info, (GstMetaInfo *) meta);
2613   }
2614 
2615   return meta_info;
2616 }
2617 
2618 GST_DEBUG_CATEGORY_STATIC (gst_reference_timestamp_meta_debug);
2619 
2620 /**
2621  * gst_buffer_add_reference_timestamp_meta:
2622  * @buffer: (transfer none): a #GstBuffer
2623  * @reference: (transfer none): identifier for the timestamp reference.
2624  * @timestamp: timestamp
2625  * @duration: duration, or %GST_CLOCK_TIME_NONE
2626  *
2627  * Add a #GstReferenceTimestampMeta to @buffer that holds a @timestamp and
2628  * optionally @duration based on a specific timestamp @reference. See the
2629  * documentation of #GstReferenceTimestampMeta for details.
2630  *
2631  * Returns: (transfer none) (nullable): The #GstReferenceTimestampMeta that was added to the buffer
2632  *
2633  * Since: 1.14
2634  */
2635 GstReferenceTimestampMeta *
2636 gst_buffer_add_reference_timestamp_meta (GstBuffer * buffer,
2637     GstCaps * reference, GstClockTime timestamp, GstClockTime duration)
2638 {
2639   GstReferenceTimestampMeta *meta;
2640 
2641   g_return_val_if_fail (GST_IS_CAPS (reference), NULL);
2642   g_return_val_if_fail (timestamp != GST_CLOCK_TIME_NONE, NULL);
2643 
2644   meta =
2645       (GstReferenceTimestampMeta *) gst_buffer_add_meta (buffer,
2646       GST_REFERENCE_TIMESTAMP_META_INFO, NULL);
2647 
2648   if (!meta)
2649     return NULL;
2650 
2651   meta-&gt;reference = gst_caps_ref (reference);
2652   meta-&gt;timestamp = timestamp;
2653   meta-&gt;duration = duration;
2654 
2655   return meta;
2656 }
2657 
2658 /**
2659  * gst_buffer_get_reference_timestamp_meta:
2660  * @buffer: a #GstBuffer
2661  * @reference: (allow-none): a reference #GstCaps
2662  *
2663  * Find the first #GstReferenceTimestampMeta on @buffer that conforms to
2664  * @reference. Conformance is tested by checking if the meta&#39;s reference is a
2665  * subset of @reference.
2666  *
2667  * Buffers can contain multiple #GstReferenceTimestampMeta metadata items.
2668  *
2669  * Returns: (transfer none) (nullable): the #GstReferenceTimestampMeta or %NULL when there
2670  * is no such metadata on @buffer.
2671  *
2672  * Since: 1.14
2673  */
2674 GstReferenceTimestampMeta *
2675 gst_buffer_get_reference_timestamp_meta (GstBuffer * buffer,
2676     GstCaps * reference)
2677 {
2678   gpointer state = NULL;
2679   GstMeta *meta;
2680   const GstMetaInfo *info = GST_REFERENCE_TIMESTAMP_META_INFO;
2681 
2682   while ((meta = gst_buffer_iterate_meta (buffer, &amp;state))) {
2683     if (meta-&gt;info-&gt;api == info-&gt;api) {
2684       GstReferenceTimestampMeta *rmeta = (GstReferenceTimestampMeta *) meta;
2685 
2686       if (!reference)
2687         return rmeta;
2688       if (gst_caps_is_subset (rmeta-&gt;reference, reference))
2689         return rmeta;
2690     }
2691   }
2692   return NULL;
2693 }
2694 
2695 static gboolean
2696 _gst_reference_timestamp_meta_transform (GstBuffer * dest, GstMeta * meta,
2697     GstBuffer * buffer, GQuark type, gpointer data)
2698 {
2699   GstReferenceTimestampMeta *dmeta, *smeta;
2700 
2701   /* we copy over the reference timestamp meta, independent of transformation
2702    * that happens. If it applied to the original buffer, it still applies to
2703    * the new buffer as it refers to the time when the media was captured */
2704   smeta = (GstReferenceTimestampMeta *) meta;
2705   dmeta =
2706       gst_buffer_add_reference_timestamp_meta (dest, smeta-&gt;reference,
2707       smeta-&gt;timestamp, smeta-&gt;duration);
2708   if (!dmeta)
2709     return FALSE;
2710 
2711   GST_CAT_DEBUG (gst_reference_timestamp_meta_debug,
2712       &quot;copy reference timestamp metadata from buffer %p to %p&quot;, buffer, dest);
2713 
2714   return TRUE;
2715 }
2716 
2717 static void
2718 _gst_reference_timestamp_meta_free (GstReferenceTimestampMeta * meta,
2719     GstBuffer * buffer)
2720 {
2721   if (meta-&gt;reference)
2722     gst_caps_unref (meta-&gt;reference);
2723 }
2724 
2725 static gboolean
2726 _gst_reference_timestamp_meta_init (GstReferenceTimestampMeta * meta,
2727     gpointer params, GstBuffer * buffer)
2728 {
2729   static volatile gsize _init;
2730 
2731   if (g_once_init_enter (&amp;_init)) {
2732     GST_DEBUG_CATEGORY_INIT (gst_reference_timestamp_meta_debug,
2733         &quot;referencetimestampmeta&quot;, 0, &quot;referencetimestampmeta&quot;);
2734     g_once_init_leave (&amp;_init, 1);
2735   }
2736 
2737   meta-&gt;reference = NULL;
2738   meta-&gt;timestamp = GST_CLOCK_TIME_NONE;
2739   meta-&gt;duration = GST_CLOCK_TIME_NONE;
2740 
2741   return TRUE;
2742 }
2743 
2744 GType
2745 gst_reference_timestamp_meta_api_get_type (void)
2746 {
2747   static volatile GType type = 0;
2748   static const gchar *tags[] = { NULL };
2749 
2750   if (g_once_init_enter (&amp;type)) {
2751     GType _type =
2752         gst_meta_api_type_register (&quot;GstReferenceTimestampMetaAPI&quot;, tags);
2753     g_once_init_leave (&amp;type, _type);
2754   }
2755 
2756   return type;
2757 }
2758 
2759 /**
2760  * gst_reference_timestamp_meta_get_info:
2761  *
2762  * Get the global #GstMetaInfo describing  the #GstReferenceTimestampMeta meta.
2763  *
2764  * Returns: (transfer none): The #GstMetaInfo
2765  *
2766  * Since: 1.14
2767  */
2768 const GstMetaInfo *
2769 gst_reference_timestamp_meta_get_info (void)
2770 {
2771   static const GstMetaInfo *meta_info = NULL;
2772 
2773   if (g_once_init_enter ((GstMetaInfo **) &amp; meta_info)) {
2774     const GstMetaInfo *meta =
2775         gst_meta_register (gst_reference_timestamp_meta_api_get_type (),
2776         &quot;GstReferenceTimestampMeta&quot;,
2777         sizeof (GstReferenceTimestampMeta),
2778         (GstMetaInitFunction) _gst_reference_timestamp_meta_init,
2779         (GstMetaFreeFunction) _gst_reference_timestamp_meta_free,
2780         _gst_reference_timestamp_meta_transform);
2781     g_once_init_leave ((GstMetaInfo **) &amp; meta_info, (GstMetaInfo *) meta);
2782   }
2783 
2784   return meta_info;
2785 }
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>