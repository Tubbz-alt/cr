<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gconvert.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gconstructor.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gconvert.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gconvert.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  29 #include &lt;string.h&gt;
  30 #include &lt;stdlib.h&gt;
  31 
  32 #ifdef G_OS_WIN32
  33 #include &quot;win_iconv.c&quot;
  34 #endif
  35 
  36 #ifdef G_PLATFORM_WIN32
  37 #define STRICT
  38 #include &lt;windows.h&gt;
  39 #undef STRICT
  40 #endif
  41 
  42 #include &quot;gconvert.h&quot;
  43 
  44 #include &quot;gcharsetprivate.h&quot;
  45 #include &quot;gslist.h&quot;
  46 #include &quot;gstrfuncs.h&quot;
  47 #include &quot;gtestutils.h&quot;
  48 #include &quot;gthread.h&quot;

  49 #include &quot;gunicode.h&quot;
  50 #include &quot;gfileutils.h&quot;
  51 
  52 #include &quot;glibintl.h&quot;
  53 
<span class="line-removed">  54 #if defined(USE_LIBICONV_GNU) &amp;&amp; !defined (_LIBICONV_H)</span>
<span class="line-removed">  55 #error GNU libiconv in use but included iconv.h not from libiconv</span>
<span class="line-removed">  56 #endif</span>
<span class="line-removed">  57 #if !defined(USE_LIBICONV_GNU) &amp;&amp; defined (_LIBICONV_H) \</span>
<span class="line-removed">  58      &amp;&amp; !defined (__APPLE_CC__) &amp;&amp; !defined (__LP_64__)</span>
<span class="line-removed">  59 #error GNU libiconv not in use but included iconv.h is from libiconv</span>
<span class="line-removed">  60 #endif</span>
<span class="line-removed">  61 </span>
  62 
  63 /**
  64  * SECTION:conversions
  65  * @title: Character Set Conversion
  66  * @short_description: convert strings between different character sets
  67  *
  68  * The g_convert() family of function wraps the functionality of iconv().
  69  * In addition to pure character set conversions, GLib has functions to
  70  * deal with the extra complications of encodings for file names.
  71  *
  72  * ## File Name Encodings
  73  *
  74  * Historically, UNIX has not had a defined encoding for file names:
  75  * a file name is valid as long as it does not have path separators
  76  * in it (&quot;/&quot;). However, displaying file names may require conversion:
  77  * from the character set in which they were created, to the character
  78  * set in which the application operates. Consider the Spanish file name
  79  * &quot;Presentacion.sxi&quot;. If the application which created it uses
  80  * ISO-8859-1 for its encoding,
  81  * |[
</pre>
<hr />
<pre>
 152  *
 153  * 3. If your user interface lets the user type a file name for saving
 154  *    or renaming, convert it to the encoding used for file names in
 155  *    the file system by using g_filename_from_utf8(). Pass the converted
 156  *    file name to functions like fopen(). If conversion fails, ask the
 157  *    user to enter a different file name. This can happen if the user
 158  *    types Japanese characters when `G_FILENAME_ENCODING` is set to
 159  *    `ISO-8859-1`, for example.
 160  */
 161 
 162 /* We try to terminate strings in unknown charsets with this many zero bytes
 163  * to ensure that multibyte strings really are nul-terminated when we return
 164  * them from g_convert() and friends.
 165  */
 166 #define NUL_TERMINATOR_LENGTH 4
 167 
 168 G_DEFINE_QUARK (g_convert_error, g_convert_error)
 169 
 170 static gboolean
 171 try_conversion (const char *to_codeset,
<span class="line-modified"> 172         const char *from_codeset,</span>
<span class="line-modified"> 173         iconv_t    *cd)</span>
 174 {
 175   *cd = iconv_open (to_codeset, from_codeset);
 176 
 177   if (*cd == (iconv_t)-1 &amp;&amp; errno == EINVAL)
 178     return FALSE;
 179   else
 180     return TRUE;
 181 }
 182 
 183 static gboolean
 184 try_to_aliases (const char **to_aliases,
<span class="line-modified"> 185         const char  *from_codeset,</span>
<span class="line-modified"> 186         iconv_t     *cd)</span>
 187 {
 188   if (to_aliases)
 189     {
 190       const char **p = to_aliases;
 191       while (*p)
<span class="line-modified"> 192     {</span>
<span class="line-modified"> 193       if (try_conversion (*p, from_codeset, cd))</span>
<span class="line-modified"> 194         return TRUE;</span>
 195 
<span class="line-modified"> 196       p++;</span>
<span class="line-modified"> 197     }</span>
 198     }
 199 
 200   return FALSE;
 201 }
 202 
 203 /**
 204  * g_iconv_open: (skip)
 205  * @to_codeset: destination codeset
 206  * @from_codeset: source codeset
 207  *
 208  * Same as the standard UNIX routine iconv_open(), but
 209  * may be implemented via libiconv on UNIX flavors that lack
 210  * a native implementation.
 211  *
 212  * GLib provides g_convert() and g_locale_to_utf8() which are likely
 213  * more convenient than the raw iconv wrappers.
 214  *
 215  * Returns: a &quot;conversion descriptor&quot;, or (GIConv)-1 if
 216  *  opening the converter failed.
 217  **/
 218 GIConv
 219 g_iconv_open (const gchar  *to_codeset,
<span class="line-modified"> 220           const gchar  *from_codeset)</span>
 221 {
 222   iconv_t cd;
 223 
 224   if (!try_conversion (to_codeset, from_codeset, &amp;cd))
 225     {
 226       const char **to_aliases = _g_charset_get_aliases (to_codeset);
 227       const char **from_aliases = _g_charset_get_aliases (from_codeset);
 228 
 229       if (from_aliases)
<span class="line-modified"> 230     {</span>
<span class="line-modified"> 231       const char **p = from_aliases;</span>
<span class="line-modified"> 232       while (*p)</span>
<span class="line-modified"> 233         {</span>
<span class="line-modified"> 234           if (try_conversion (to_codeset, *p, &amp;cd))</span>
<span class="line-modified"> 235         goto out;</span>
 236 
<span class="line-modified"> 237           if (try_to_aliases (to_aliases, *p, &amp;cd))</span>
<span class="line-modified"> 238         goto out;</span>
 239 
<span class="line-modified"> 240           p++;</span>
<span class="line-modified"> 241         }</span>
<span class="line-modified"> 242     }</span>
 243 
 244       if (try_to_aliases (to_aliases, from_codeset, &amp;cd))
<span class="line-modified"> 245     goto out;</span>
 246     }
 247 
 248  out:
 249   return (cd == (iconv_t)-1) ? (GIConv)-1 : (GIConv)cd;
 250 }
 251 
 252 /**
 253  * g_iconv: (skip)
 254  * @converter: conversion descriptor from g_iconv_open()
 255  * @inbuf: bytes to convert
 256  * @inbytes_left: inout parameter, bytes remaining to convert in @inbuf
 257  * @outbuf: converted output bytes
 258  * @outbytes_left: inout parameter, bytes available to fill in @outbuf
 259  *
 260  * Same as the standard UNIX routine iconv(), but
 261  * may be implemented via libiconv on UNIX flavors that lack
 262  * a native implementation.
 263  *
 264  * GLib provides g_convert() and g_locale_to_utf8() which are likely
 265  * more convenient than the raw iconv wrappers.
 266  *
 267  * Note that the behaviour of iconv() for characters which are valid in the
 268  * input character set, but which have no representation in the output character
 269  * set, is implementation defined. This function may return success (with a
 270  * positive number of non-reversible conversions as replacement characters were
 271  * used), or it may return -1 and set an error such as %EILSEQ, in such a
 272  * situation.
 273  *
 274  * Returns: count of non-reversible conversions, or -1 on error
 275  **/
 276 gsize
 277 g_iconv (GIConv   converter,
<span class="line-modified"> 278      gchar  **inbuf,</span>
<span class="line-modified"> 279      gsize   *inbytes_left,</span>
<span class="line-modified"> 280      gchar  **outbuf,</span>
<span class="line-modified"> 281      gsize   *outbytes_left)</span>
 282 {
 283   iconv_t cd = (iconv_t)converter;
 284 
 285   return iconv (cd, inbuf, inbytes_left, outbuf, outbytes_left);
 286 }
 287 
 288 /**
 289  * g_iconv_close: (skip)
 290  * @converter: a conversion descriptor from g_iconv_open()
 291  *
 292  * Same as the standard UNIX routine iconv_close(), but
 293  * may be implemented via libiconv on UNIX flavors that lack
 294  * a native implementation. Should be called to clean up
 295  * the conversion descriptor from g_iconv_open() when
 296  * you are done converting things.
 297  *
 298  * GLib provides g_convert() and g_locale_to_utf8() which are likely
 299  * more convenient than the raw iconv wrappers.
 300  *
 301  * Returns: -1 on error, 0 on success
 302  **/
 303 gint
 304 g_iconv_close (GIConv converter)
 305 {
 306   iconv_t cd = (iconv_t)converter;
 307 
 308   return iconv_close (cd);
 309 }
 310 
 311 static GIConv
 312 open_converter (const gchar *to_codeset,
<span class="line-modified"> 313         const gchar *from_codeset,</span>
<span class="line-modified"> 314         GError     **error)</span>
 315 {
 316   GIConv cd;
 317 
 318   cd = g_iconv_open (to_codeset, from_codeset);
 319 
 320   if (cd == (GIConv) -1)
 321     {
 322       /* Something went wrong.  */
 323       if (error)
<span class="line-modified"> 324     {</span>
<span class="line-modified"> 325       if (errno == EINVAL)</span>
<span class="line-modified"> 326         g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_NO_CONVERSION,</span>
<span class="line-modified"> 327              _(&quot;Conversion from character set &#39;%s&#39; to &#39;%s&#39; is not supported&quot;),</span>
<span class="line-modified"> 328              from_codeset, to_codeset);</span>
<span class="line-modified"> 329       else</span>
<span class="line-modified"> 330         g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,</span>
<span class="line-modified"> 331              _(&quot;Could not open converter from &#39;%s&#39; to &#39;%s&#39;&quot;),</span>
<span class="line-modified"> 332              from_codeset, to_codeset);</span>
<span class="line-modified"> 333     }</span>
 334     }
 335 
 336   return cd;
 337 }
 338 
 339 static int
 340 close_converter (GIConv cd)
 341 {
 342   if (cd == (GIConv) -1)
 343     return 0;
 344 
 345   return g_iconv_close (cd);
 346 }
 347 
 348 /**
 349  * g_convert_with_iconv: (skip)
 350  * @str:           (array length=len) (element-type guint8):
 351  *                 the string to convert.
 352  * @len:           the length of the string in bytes, or -1 if the string is
 353  *                 nul-terminated (Note that some encodings may allow nul
</pre>
<hr />
<pre>
 377  * g_convert_with_iconv() or g_convert_with_fallback(). (An example of
 378  * this is the GNU C converter for CP1255 which does not emit a base
 379  * character until it knows that the next character is not a mark that
 380  * could combine with the base character.)
 381  *
 382  * Characters which are valid in the input character set, but which have no
 383  * representation in the output character set will result in a
 384  * %G_CONVERT_ERROR_ILLEGAL_SEQUENCE error. This is in contrast to the iconv()
 385  * specification, which leaves this behaviour implementation defined. Note that
 386  * this is the same error code as is returned for an invalid byte sequence in
 387  * the input character set. To get defined behaviour for conversion of
 388  * unrepresentable characters, use g_convert_with_fallback().
 389  *
 390  * Returns: (array length=bytes_written) (element-type guint8) (transfer full):
 391  *               If the conversion was successful, a newly allocated buffer
 392  *               containing the converted string, which must be freed with
 393  *               g_free(). Otherwise %NULL and @error will be set.
 394  **/
 395 gchar*
 396 g_convert_with_iconv (const gchar *str,
<span class="line-modified"> 397               gssize       len,</span>
<span class="line-modified"> 398               GIConv       converter,</span>
<span class="line-modified"> 399               gsize       *bytes_read,</span>
<span class="line-modified"> 400               gsize       *bytes_written,</span>
<span class="line-modified"> 401               GError     **error)</span>
 402 {
 403   gchar *dest;
 404   gchar *outp;
 405   const gchar *p;
 406   gsize inbytes_remaining;
 407   gsize outbytes_remaining;
 408   gsize err;
 409   gsize outbuf_size;
 410   gboolean have_error = FALSE;
 411   gboolean done = FALSE;
 412   gboolean reset = FALSE;
 413 
 414   g_return_val_if_fail (converter != (GIConv) -1, NULL);
 415 
 416   if (len &lt; 0)
 417     len = strlen (str);
 418 
 419   p = str;
 420   inbytes_remaining = len;
 421   outbuf_size = len + NUL_TERMINATOR_LENGTH;
 422 
 423   outbytes_remaining = outbuf_size - NUL_TERMINATOR_LENGTH;
 424   outp = dest = g_malloc (outbuf_size);
 425 
 426   while (!done &amp;&amp; !have_error)
 427     {
 428       if (reset)
 429         err = g_iconv (converter, NULL, &amp;inbytes_remaining, &amp;outp, &amp;outbytes_remaining);
 430       else
 431         err = g_iconv (converter, (char **)&amp;p, &amp;inbytes_remaining, &amp;outp, &amp;outbytes_remaining);
 432 
 433       if (err == (gsize) -1)
<span class="line-modified"> 434     {</span>
<span class="line-modified"> 435       switch (errno)</span>






 436         {
<span class="line-modified"> 437         case EINVAL:</span>
<span class="line-modified"> 438           /* Incomplete text, do not report an error */</span>
<span class="line-modified"> 439           done = TRUE;</span>
<span class="line-modified"> 440           break;</span>
<span class="line-modified"> 441         case E2BIG:</span>
<span class="line-modified"> 442           {</span>
<span class="line-modified"> 443         gsize used = outp - dest;</span>
<span class="line-modified"> 444 </span>
<span class="line-modified"> 445         outbuf_size *= 2;</span>
<span class="line-modified"> 446         dest = g_realloc (dest, outbuf_size);</span>
<span class="line-removed"> 447 </span>
<span class="line-removed"> 448         outp = dest + used;</span>
<span class="line-removed"> 449         outbytes_remaining = outbuf_size - used - NUL_TERMINATOR_LENGTH;</span>
<span class="line-removed"> 450           }</span>
<span class="line-removed"> 451           break;</span>
<span class="line-removed"> 452         case EILSEQ:</span>
 453               g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
 454                                    _(&quot;Invalid byte sequence in conversion input&quot;));
<span class="line-modified"> 455           have_error = TRUE;</span>
<span class="line-modified"> 456           break;</span>
<span class="line-modified"> 457         default:</span>
 458               {
 459                 int errsv = errno;
 460 
 461                 g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,
 462                              _(&quot;Error during conversion: %s&quot;),
 463                              g_strerror (errsv));
 464               }
<span class="line-modified"> 465           have_error = TRUE;</span>
<span class="line-modified"> 466           break;</span>
<span class="line-modified"> 467         }</span>
<span class="line-modified"> 468     }</span>
 469       else if (err &gt; 0)
 470         {
 471           /* @err gives the number of replacement characters used. */
 472           g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
 473                                _(&quot;Unrepresentable character in conversion input&quot;));
 474           have_error = TRUE;
 475         }
 476       else
<span class="line-modified"> 477     {</span>
<span class="line-modified"> 478       if (!reset)</span>
<span class="line-modified"> 479         {</span>
<span class="line-modified"> 480           /* call g_iconv with NULL inbuf to cleanup shift state */</span>
<span class="line-modified"> 481           reset = TRUE;</span>
<span class="line-modified"> 482           inbytes_remaining = 0;</span>
<span class="line-modified"> 483         }</span>
<span class="line-modified"> 484       else</span>
<span class="line-modified"> 485         done = TRUE;</span>
<span class="line-modified"> 486     }</span>
 487     }
 488 
 489   memset (outp, 0, NUL_TERMINATOR_LENGTH);
 490 
 491   if (bytes_read)
 492     *bytes_read = p - str;
 493   else
 494     {
 495       if ((p - str) != len)
<span class="line-modified"> 496     {</span>
 497           if (!have_error)
 498             {
 499               g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_PARTIAL_INPUT,
 500                                    _(&quot;Partial character sequence at end of input&quot;));
 501               have_error = TRUE;
 502             }
<span class="line-modified"> 503     }</span>
 504     }
 505 
 506   if (bytes_written)
<span class="line-modified"> 507     *bytes_written = outp - dest;   /* Doesn&#39;t include &#39;\0&#39; */</span>
 508 
 509   if (have_error)
 510     {
 511       g_free (dest);
 512       return NULL;
 513     }
 514   else
 515     return dest;
 516 }
 517 
 518 /**
 519  * g_convert:
 520  * @str:           (array length=len) (element-type guint8):
 521  *                 the string to convert.
 522  * @len:           the length of the string in bytes, or -1 if the string is
 523  *                 nul-terminated (Note that some encodings may allow nul
 524  *                 bytes to occur inside strings. In that case, using -1
 525  *                 for the @len parameter is unsafe)
 526  * @to_codeset:    name of character set into which to convert @str
 527  * @from_codeset:  character set of @str.
</pre>
<hr />
<pre>
 547  * then this won&#39;t be preserved across successive calls to g_convert(),
 548  * g_convert_with_iconv() or g_convert_with_fallback(). (An example of
 549  * this is the GNU C converter for CP1255 which does not emit a base
 550  * character until it knows that the next character is not a mark that
 551  * could combine with the base character.)
 552  *
 553  * Using extensions such as &quot;//TRANSLIT&quot; may not work (or may not work
 554  * well) on many platforms.  Consider using g_str_to_ascii() instead.
 555  *
 556  * Returns: (array length=bytes_written) (element-type guint8) (transfer full):
 557  *          If the conversion was successful, a newly allocated buffer
 558  *          containing the converted string, which must be freed with g_free().
 559  *          Otherwise %NULL and @error will be set.
 560  **/
 561 gchar*
 562 g_convert (const gchar *str,
 563            gssize       len,
 564            const gchar *to_codeset,
 565            const gchar *from_codeset,
 566            gsize       *bytes_read,
<span class="line-modified"> 567        gsize       *bytes_written,</span>
<span class="line-modified"> 568        GError     **error)</span>
 569 {
 570   gchar *res;
 571   GIConv cd;
 572 
 573   g_return_val_if_fail (str != NULL, NULL);
 574   g_return_val_if_fail (to_codeset != NULL, NULL);
 575   g_return_val_if_fail (from_codeset != NULL, NULL);
 576 
 577   cd = open_converter (to_codeset, from_codeset, error);
 578 
 579   if (cd == (GIConv) -1)
 580     {
 581       if (bytes_read)
 582         *bytes_read = 0;
 583 
 584       if (bytes_written)
 585         *bytes_written = 0;
 586 
 587       return NULL;
 588     }
 589 
 590   res = g_convert_with_iconv (str, len, cd,
<span class="line-modified"> 591                   bytes_read, bytes_written,</span>
<span class="line-modified"> 592                   error);</span>
 593 
 594   close_converter (cd);
 595 
 596   return res;
 597 }
 598 
 599 /**
 600  * g_convert_with_fallback:
 601  * @str:          (array length=len) (element-type guint8):
 602  *                the string to convert.
 603  * @len:          the length of the string in bytes, or -1 if the string is
 604  *                 nul-terminated (Note that some encodings may allow nul
 605  *                 bytes to occur inside strings. In that case, using -1
 606  *                 for the @len parameter is unsafe)
 607  * @to_codeset:   name of character set into which to convert @str
 608  * @from_codeset: character set of @str.
 609  * @fallback:     UTF-8 string to use in place of characters not
 610  *                present in the target encoding. (The string must be
 611  *                representable in the target encoding).
 612  *                If %NULL, characters not in the target encoding will
</pre>
<hr />
<pre>
 629  * to @to_codeset in their iconv() functions,
 630  * in which case GLib will simply return that approximate conversion.
 631  *
 632  * Note that you should use g_iconv() for streaming conversions.
 633  * Despite the fact that @bytes_read can return information about partial
 634  * characters, the g_convert_... functions are not generally suitable
 635  * for streaming. If the underlying converter maintains internal state,
 636  * then this won&#39;t be preserved across successive calls to g_convert(),
 637  * g_convert_with_iconv() or g_convert_with_fallback(). (An example of
 638  * this is the GNU C converter for CP1255 which does not emit a base
 639  * character until it knows that the next character is not a mark that
 640  * could combine with the base character.)
 641  *
 642  * Returns: (array length=bytes_written) (element-type guint8) (transfer full):
 643  *          If the conversion was successful, a newly allocated buffer
 644  *          containing the converted string, which must be freed with g_free().
 645  *          Otherwise %NULL and @error will be set.
 646  **/
 647 gchar*
 648 g_convert_with_fallback (const gchar *str,
<span class="line-modified"> 649              gssize       len,</span>
<span class="line-modified"> 650              const gchar *to_codeset,</span>
<span class="line-modified"> 651              const gchar *from_codeset,</span>
<span class="line-modified"> 652              const gchar *fallback,</span>
<span class="line-modified"> 653              gsize       *bytes_read,</span>
<span class="line-modified"> 654              gsize       *bytes_written,</span>
<span class="line-modified"> 655              GError     **error)</span>
 656 {
 657   gchar *utf8;
 658   gchar *dest;
 659   gchar *outp;
 660   const gchar *insert_str = NULL;
 661   const gchar *p;
 662   gsize inbytes_remaining;
 663   const gchar *save_p = NULL;
 664   gsize save_inbytes = 0;
 665   gsize outbytes_remaining;
 666   gsize err;
 667   GIConv cd;
 668   gsize outbuf_size;
 669   gboolean have_error = FALSE;
 670   gboolean done = FALSE;
 671 
 672   GError *local_error = NULL;
 673 
 674   g_return_val_if_fail (str != NULL, NULL);
 675   g_return_val_if_fail (to_codeset != NULL, NULL);
 676   g_return_val_if_fail (from_codeset != NULL, NULL);
 677 
 678   if (len &lt; 0)
 679     len = strlen (str);
 680 
 681   /* Try an exact conversion; we only proceed if this fails
 682    * due to an illegal sequence in the input string.
 683    */
 684   dest = g_convert (str, len, to_codeset, from_codeset,
<span class="line-modified"> 685             bytes_read, bytes_written, &amp;local_error);</span>
 686   if (!local_error)
 687     return dest;
 688 
 689   if (!g_error_matches (local_error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE))
 690     {
 691       g_propagate_error (error, local_error);
 692       return NULL;
 693     }
 694   else
 695     g_error_free (local_error);
 696 
 697   local_error = NULL;
 698 
 699   /* No go; to proceed, we need a converter from &quot;UTF-8&quot; to
 700    * to_codeset, and the string as UTF-8.
 701    */
 702   cd = open_converter (to_codeset, &quot;UTF-8&quot;, error);
 703   if (cd == (GIConv) -1)
 704     {
 705       if (bytes_read)
 706         *bytes_read = 0;
 707 
 708       if (bytes_written)
 709         *bytes_written = 0;
 710 
 711       return NULL;
 712     }
 713 
 714   utf8 = g_convert (str, len, &quot;UTF-8&quot;, from_codeset,
<span class="line-modified"> 715             bytes_read, &amp;inbytes_remaining, error);</span>
 716   if (!utf8)
 717     {
 718       close_converter (cd);
 719       if (bytes_written)
 720         *bytes_written = 0;
 721       return NULL;
 722     }
 723 
 724   /* Now the heart of the code. We loop through the UTF-8 string, and
 725    * whenever we hit an offending character, we form fallback, convert
 726    * the fallback to the target codeset, and then go back to
 727    * converting the original string after finishing with the fallback.
 728    *
 729    * The variables save_p and save_inbytes store the input state
 730    * for the original string while we are converting the fallback
 731    */
 732   p = utf8;
 733 
 734   outbuf_size = len + NUL_TERMINATOR_LENGTH;
 735   outbytes_remaining = outbuf_size - NUL_TERMINATOR_LENGTH;
 736   outp = dest = g_malloc (outbuf_size);
 737 
 738   while (!done &amp;&amp; !have_error)
 739     {
 740       gsize inbytes_tmp = inbytes_remaining;
 741       err = g_iconv (cd, (char **)&amp;p, &amp;inbytes_tmp, &amp;outp, &amp;outbytes_remaining);
 742       inbytes_remaining = inbytes_tmp;
 743 
 744       if (err == (gsize) -1)
<span class="line-modified"> 745     {</span>
<span class="line-modified"> 746       switch (errno)</span>





 747         {
<span class="line-modified"> 748         case EINVAL:</span>
<span class="line-removed"> 749           g_assert_not_reached();</span>
<span class="line-removed"> 750           break;</span>
<span class="line-removed"> 751         case E2BIG:</span>
<span class="line-removed"> 752           {</span>
<span class="line-removed"> 753         gsize used = outp - dest;</span>
 754 
<span class="line-modified"> 755         outbuf_size *= 2;</span>
<span class="line-modified"> 756         dest = g_realloc (dest, outbuf_size);</span>
 757 
<span class="line-modified"> 758         outp = dest + used;</span>
<span class="line-modified"> 759         outbytes_remaining = outbuf_size - used - NUL_TERMINATOR_LENGTH;</span>
 760 
<span class="line-modified"> 761         break;</span>
<span class="line-removed"> 762           }</span>
<span class="line-removed"> 763         case EILSEQ:</span>
<span class="line-removed"> 764           if (save_p)</span>
<span class="line-removed"> 765         {</span>
<span class="line-removed"> 766           /* Error converting fallback string - fatal</span>
<span class="line-removed"> 767            */</span>
<span class="line-removed"> 768           g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
<span class="line-removed"> 769                    _(&quot;Cannot convert fallback &#39;%s&#39; to codeset &#39;%s&#39;&quot;),</span>
<span class="line-removed"> 770                    insert_str, to_codeset);</span>
<span class="line-removed"> 771           have_error = TRUE;</span>
<span class="line-removed"> 772           break;</span>
 773         }
<span class="line-modified"> 774           else if (p)</span>













 775         {
<span class="line-modified"> 776           if (!fallback)</span>
<span class="line-modified"> 777             {</span>
<span class="line-modified"> 778               gunichar ch = g_utf8_get_char (p);</span>
<span class="line-removed"> 779               insert_str = g_strdup_printf (ch &lt; 0x10000 ? &quot;\\u%04x&quot; : &quot;\\U%08x&quot;,</span>
<span class="line-removed"> 780                             ch);</span>
<span class="line-removed"> 781             }</span>
<span class="line-removed"> 782           else</span>
<span class="line-removed"> 783             insert_str = fallback;</span>
<span class="line-removed"> 784 </span>
<span class="line-removed"> 785           save_p = g_utf8_next_char (p);</span>
<span class="line-removed"> 786           save_inbytes = inbytes_remaining - (save_p - p);</span>
<span class="line-removed"> 787           p = insert_str;</span>
<span class="line-removed"> 788           inbytes_remaining = strlen (p);</span>
<span class="line-removed"> 789           break;</span>
 790         }
<span class="line-modified"> 791           /* fall thru if p is NULL */</span>
<span class="line-modified"> 792         default:</span>










 793               {
 794                 int errsv = errno;
 795 
 796                 g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,
 797                              _(&quot;Error during conversion: %s&quot;),
 798                              g_strerror (errsv));
 799               }
 800 
<span class="line-modified"> 801           have_error = TRUE;</span>
<span class="line-modified"> 802           break;</span>
<span class="line-modified"> 803         }</span>
<span class="line-modified"> 804     }</span>
<span class="line-removed"> 805       else</span>
<span class="line-removed"> 806     {</span>
<span class="line-removed"> 807       if (save_p)</span>
<span class="line-removed"> 808         {</span>
<span class="line-removed"> 809           if (!fallback)</span>
<span class="line-removed"> 810         g_free ((gchar *)insert_str);</span>
<span class="line-removed"> 811           p = save_p;</span>
<span class="line-removed"> 812           inbytes_remaining = save_inbytes;</span>
<span class="line-removed"> 813           save_p = NULL;</span>
<span class="line-removed"> 814         }</span>
<span class="line-removed"> 815       else if (p)</span>
<span class="line-removed"> 816         {</span>
<span class="line-removed"> 817           /* call g_iconv with NULL inbuf to cleanup shift state */</span>
<span class="line-removed"> 818           p = NULL;</span>
<span class="line-removed"> 819           inbytes_remaining = 0;</span>
<span class="line-removed"> 820         }</span>
 821       else
<span class="line-modified"> 822         done = TRUE;</span>
<span class="line-modified"> 823     }</span>
















 824     }
 825 
 826   /* Cleanup
 827    */
 828   memset (outp, 0, NUL_TERMINATOR_LENGTH);
 829 
 830   close_converter (cd);
 831 
 832   if (bytes_written)
<span class="line-modified"> 833     *bytes_written = outp - dest;   /* Doesn&#39;t include &#39;\0&#39; */</span>
 834 
 835   g_free (utf8);
 836 
 837   if (have_error)
 838     {
 839       if (save_p &amp;&amp; !fallback)
<span class="line-modified"> 840     g_free ((gchar *)insert_str);</span>
 841       g_free (dest);
 842       return NULL;
 843     }
 844   else
 845     return dest;
 846 }
 847 
 848 /*
 849  * g_locale_to_utf8
 850  *
 851  *
 852  */
 853 
 854 /*
 855  * Validate @string as UTF-8. @len can be negative if @string is
 856  * nul-terminated, or a non-negative value in bytes. If @string ends in an
 857  * incomplete sequence, or contains any illegal sequences or nul codepoints,
 858  * %NULL will be returned and the error set to
 859  * %G_CONVERT_ERROR_ILLEGAL_SEQUENCE.
 860  * On success, @bytes_read and @bytes_written, if provided, will be set to
 861  * the number of bytes in @string up to @len or the terminating nul byte.
 862  * On error, @bytes_read will be set to the byte offset after the last valid
 863  * and non-nul UTF-8 sequence in @string, and @bytes_written will be set to 0.
 864  */
 865 static gchar *
 866 strdup_len (const gchar *string,
<span class="line-modified"> 867         gssize       len,</span>
<span class="line-modified"> 868         gsize       *bytes_read,</span>
<span class="line-modified"> 869         gsize       *bytes_written,</span>
<span class="line-modified"> 870         GError     **error)</span>
 871 {
 872   gsize real_len;
 873   const gchar *end_valid;
 874 
 875   if (!g_utf8_validate (string, len, &amp;end_valid))
 876     {
 877       if (bytes_read)
<span class="line-modified"> 878     *bytes_read = end_valid - string;</span>
 879       if (bytes_written)
<span class="line-modified"> 880     *bytes_written = 0;</span>
 881 
 882       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
 883                            _(&quot;Invalid byte sequence in conversion input&quot;));
 884       return NULL;
 885     }
 886 
 887   real_len = end_valid - string;
 888 
 889   if (bytes_read)
 890     *bytes_read = real_len;
 891   if (bytes_written)
 892     *bytes_written = real_len;
 893 
 894   return g_strndup (string, real_len);
 895 }
 896 
 897 typedef enum
 898 {
 899   CONVERT_CHECK_NO_NULS_IN_INPUT  = 1 &lt;&lt; 0,
 900   CONVERT_CHECK_NO_NULS_IN_OUTPUT = 1 &lt;&lt; 1
</pre>
<hr />
<pre>
 988  *                 buffer (not including the terminating nul).
 989  * @error:         location to store the error occurring, or %NULL to ignore
 990  *                 errors. Any of the errors in #GConvertError may occur.
 991  *
 992  * Converts a string which is in the encoding used for strings by
 993  * the C runtime (usually the same as that used by the operating
 994  * system) in the [current locale][setlocale] into a UTF-8 string.
 995  *
 996  * If the source encoding is not UTF-8 and the conversion output contains a
 997  * nul character, the error %G_CONVERT_ERROR_EMBEDDED_NUL is set and the
 998  * function returns %NULL.
 999  * If the source encoding is UTF-8, an embedded nul character is treated with
1000  * the %G_CONVERT_ERROR_ILLEGAL_SEQUENCE error for backward compatibility with
1001  * earlier versions of this library. Use g_convert() to produce output that
1002  * may contain embedded nul characters.
1003  *
1004  * Returns: (type utf8): The converted string, or %NULL on an error.
1005  **/
1006 gchar *
1007 g_locale_to_utf8 (const gchar  *opsysstring,
<span class="line-modified">1008           gssize        len,</span>
<span class="line-modified">1009           gsize        *bytes_read,</span>
<span class="line-modified">1010           gsize        *bytes_written,</span>
<span class="line-modified">1011           GError      **error)</span>
1012 {
1013   const char *charset;
1014 
1015   if (g_get_charset (&amp;charset))
1016     return strdup_len (opsysstring, len, bytes_read, bytes_written, error);
1017   else
1018     return convert_checked (opsysstring, len, &quot;UTF-8&quot;, charset,
1019                             CONVERT_CHECK_NO_NULS_IN_OUTPUT,
1020                             bytes_read, bytes_written, error);
1021 }
1022 
1023 /**
1024  * g_locale_from_utf8:
1025  * @utf8string:    a UTF-8 encoded string
1026  * @len:           the length of the string, or -1 if the string is
1027  *                 nul-terminated.
1028  * @bytes_read: (out) (optional): location to store the number of bytes in the
1029  *                 input string that were successfully converted, or %NULL.
1030  *                 Even if the conversion was successful, this may be
1031  *                 less than @len if there were partial characters
</pre>
<hr />
<pre>
1037  *                 buffer (not including the terminating nul).
1038  * @error:         location to store the error occurring, or %NULL to ignore
1039  *                 errors. Any of the errors in #GConvertError may occur.
1040  *
1041  * Converts a string from UTF-8 to the encoding used for strings by
1042  * the C runtime (usually the same as that used by the operating
1043  * system) in the [current locale][setlocale]. On Windows this means
1044  * the system codepage.
1045  *
1046  * The input string shall not contain nul characters even if the @len
1047  * argument is positive. A nul character found inside the string will result
1048  * in error %G_CONVERT_ERROR_ILLEGAL_SEQUENCE. Use g_convert() to convert
1049  * input that may contain embedded nul characters.
1050  *
1051  * Returns: (array length=bytes_written) (element-type guint8) (transfer full):
1052  *          A newly-allocated buffer containing the converted string,
1053  *          or %NULL on an error, and error will be set.
1054  **/
1055 gchar *
1056 g_locale_from_utf8 (const gchar *utf8string,
<span class="line-modified">1057             gssize       len,</span>
<span class="line-modified">1058             gsize       *bytes_read,</span>
<span class="line-modified">1059             gsize       *bytes_written,</span>
<span class="line-modified">1060             GError     **error)</span>
1061 {
1062   const gchar *charset;
1063 
1064   if (g_get_charset (&amp;charset))
1065     return strdup_len (utf8string, len, bytes_read, bytes_written, error);
1066   else
1067     return convert_checked (utf8string, len, charset, &quot;UTF-8&quot;,
1068                             CONVERT_CHECK_NO_NULS_IN_INPUT,
1069                             bytes_read, bytes_written, error);
1070 }
1071 
1072 #ifndef G_PLATFORM_WIN32
1073 
1074 typedef struct _GFilenameCharsetCache GFilenameCharsetCache;
1075 
1076 struct _GFilenameCharsetCache {
1077   gboolean is_utf8;
1078   gchar *charset;
1079   gchar **filename_charsets;
1080 };
</pre>
<hr />
<pre>
1113  * is also put in the list of encodings.
1114  *
1115  * The returned @charsets belong to GLib and must not be freed.
1116  *
1117  * Note that on Unix, regardless of the locale character set or
1118  * `G_FILENAME_ENCODING` value, the actual file names present
1119  * on a system might be in any random encoding or just gibberish.
1120  *
1121  * Returns: %TRUE if the filename encoding is UTF-8.
1122  *
1123  * Since: 2.6
1124  */
1125 gboolean
1126 g_get_filename_charsets (const gchar ***filename_charsets)
1127 {
1128   static GPrivate cache_private = G_PRIVATE_INIT (filename_charset_cache_free);
1129   GFilenameCharsetCache *cache = g_private_get (&amp;cache_private);
1130   const gchar *charset;
1131 
1132   if (!cache)
<span class="line-modified">1133     {</span>
<span class="line-removed">1134       cache = g_new0 (GFilenameCharsetCache, 1);</span>
<span class="line-removed">1135       g_private_set (&amp;cache_private, cache);</span>
<span class="line-removed">1136     }</span>
1137 
1138   g_get_charset (&amp;charset);
1139 
1140   if (!(cache-&gt;charset &amp;&amp; strcmp (cache-&gt;charset, charset) == 0))
1141     {
1142       const gchar *new_charset;
1143       gchar *p;
1144       gint i;
1145 
1146       g_free (cache-&gt;charset);
1147       g_strfreev (cache-&gt;filename_charsets);
1148       cache-&gt;charset = g_strdup (charset);
1149 
1150       p = getenv (&quot;G_FILENAME_ENCODING&quot;);
1151       if (p != NULL &amp;&amp; p[0] != &#39;\0&#39;)
<span class="line-modified">1152     {</span>
<span class="line-modified">1153       cache-&gt;filename_charsets = g_strsplit (p, &quot;,&quot;, 0);</span>
<span class="line-modified">1154       cache-&gt;is_utf8 = (strcmp (cache-&gt;filename_charsets[0], &quot;UTF-8&quot;) == 0);</span>
1155 
<span class="line-modified">1156       for (i = 0; cache-&gt;filename_charsets[i]; i++)</span>
<span class="line-modified">1157         {</span>
<span class="line-modified">1158           if (strcmp (&quot;@locale&quot;, cache-&gt;filename_charsets[i]) == 0)</span>
<span class="line-removed">1159         {</span>
<span class="line-removed">1160           g_get_charset (&amp;new_charset);</span>
<span class="line-removed">1161           g_free (cache-&gt;filename_charsets[i]);</span>
<span class="line-removed">1162           cache-&gt;filename_charsets[i] = g_strdup (new_charset);</span>
<span class="line-removed">1163         }</span>
<span class="line-removed">1164         }</span>
<span class="line-removed">1165     }</span>
<span class="line-removed">1166       else if (getenv (&quot;G_BROKEN_FILENAMES&quot;) != NULL)</span>
1167     {
<span class="line-modified">1168       cache-&gt;filename_charsets = g_new0 (gchar *, 2);</span>
<span class="line-modified">1169       cache-&gt;is_utf8 = g_get_charset (&amp;new_charset);</span>
<span class="line-modified">1170       cache-&gt;filename_charsets[0] = g_strdup (new_charset);</span>
1171     }








1172       else
<span class="line-modified">1173     {</span>
<span class="line-modified">1174       cache-&gt;filename_charsets = g_new0 (gchar *, 3);</span>
<span class="line-modified">1175       cache-&gt;is_utf8 = TRUE;</span>
<span class="line-modified">1176       cache-&gt;filename_charsets[0] = g_strdup (&quot;UTF-8&quot;);</span>
<span class="line-modified">1177       if (!g_get_charset (&amp;new_charset))</span>
<span class="line-modified">1178         cache-&gt;filename_charsets[1] = g_strdup (new_charset);</span>
<span class="line-modified">1179     }</span>
1180     }
1181 
1182   if (filename_charsets)
1183     *filename_charsets = (const gchar **)cache-&gt;filename_charsets;
1184 
1185   return cache-&gt;is_utf8;
1186 }
1187 
1188 #else /* G_PLATFORM_WIN32 */
1189 
1190 gboolean
1191 g_get_filename_charsets (const gchar ***filename_charsets)
1192 {
1193   static const gchar *charsets[] = {
1194     &quot;UTF-8&quot;,
1195     NULL
1196   };
1197 
1198 #ifdef G_OS_WIN32
1199   /* On Windows GLib pretends that the filename charset is UTF-8 */
</pre>
<hr />
<pre>
1250  * @error:         location to store the error occurring, or %NULL to ignore
1251  *                 errors. Any of the errors in #GConvertError may occur.
1252  *
1253  * Converts a string which is in the encoding used by GLib for
1254  * filenames into a UTF-8 string. Note that on Windows GLib uses UTF-8
1255  * for filenames; on other platforms, this function indirectly depends on
1256  * the [current locale][setlocale].
1257  *
1258  * The input string shall not contain nul characters even if the @len
1259  * argument is positive. A nul character found inside the string will result
1260  * in error %G_CONVERT_ERROR_ILLEGAL_SEQUENCE.
1261  * If the source encoding is not UTF-8 and the conversion output contains a
1262  * nul character, the error %G_CONVERT_ERROR_EMBEDDED_NUL is set and the
1263  * function returns %NULL. Use g_convert() to produce output that
1264  * may contain embedded nul characters.
1265  *
1266  * Returns: (type utf8): The converted string, or %NULL on an error.
1267  **/
1268 gchar*
1269 g_filename_to_utf8 (const gchar *opsysstring,
<span class="line-modified">1270             gssize       len,</span>
<span class="line-modified">1271             gsize       *bytes_read,</span>
<span class="line-modified">1272             gsize       *bytes_written,</span>
<span class="line-modified">1273             GError     **error)</span>
1274 {
1275   const gchar *charset;
1276 
1277   g_return_val_if_fail (opsysstring != NULL, NULL);
1278 
1279   if (get_filename_charset (&amp;charset))
1280     return strdup_len (opsysstring, len, bytes_read, bytes_written, error);
1281   else
1282     return convert_checked (opsysstring, len, &quot;UTF-8&quot;, charset,
1283                             CONVERT_CHECK_NO_NULS_IN_INPUT |
1284                             CONVERT_CHECK_NO_NULS_IN_OUTPUT,
1285                             bytes_read, bytes_written, error);
1286 }
1287 
1288 /**
1289  * g_filename_from_utf8:
1290  * @utf8string:    (type utf8): a UTF-8 encoded string.
1291  * @len:           the length of the string, or -1 if the string is
1292  *                 nul-terminated.
1293  * @bytes_read:    (out) (optional): location to store the number of bytes in
</pre>
<hr />
<pre>
1302  *                 the output buffer (not including the terminating nul).
1303  * @error:         location to store the error occurring, or %NULL to ignore
1304  *                 errors. Any of the errors in #GConvertError may occur.
1305  *
1306  * Converts a string from UTF-8 to the encoding GLib uses for
1307  * filenames. Note that on Windows GLib uses UTF-8 for filenames;
1308  * on other platforms, this function indirectly depends on the
1309  * [current locale][setlocale].
1310  *
1311  * The input string shall not contain nul characters even if the @len
1312  * argument is positive. A nul character found inside the string will result
1313  * in error %G_CONVERT_ERROR_ILLEGAL_SEQUENCE. If the filename encoding is
1314  * not UTF-8 and the conversion output contains a nul character, the error
1315  * %G_CONVERT_ERROR_EMBEDDED_NUL is set and the function returns %NULL.
1316  *
1317  * Returns: (type filename):
1318  *               The converted string, or %NULL on an error.
1319  **/
1320 gchar*
1321 g_filename_from_utf8 (const gchar *utf8string,
<span class="line-modified">1322               gssize       len,</span>
<span class="line-modified">1323               gsize       *bytes_read,</span>
<span class="line-modified">1324               gsize       *bytes_written,</span>
<span class="line-modified">1325               GError     **error)</span>
1326 {
1327   const gchar *charset;
1328 
1329   if (get_filename_charset (&amp;charset))
1330     return strdup_len (utf8string, len, bytes_read, bytes_written, error);
1331   else
1332     return convert_checked (utf8string, len, charset, &quot;UTF-8&quot;,
1333                             CONVERT_CHECK_NO_NULS_IN_INPUT |
1334                             CONVERT_CHECK_NO_NULS_IN_OUTPUT,
1335                             bytes_read, bytes_written, error);
1336 }
1337 
1338 /* Test of haystack has the needle prefix, comparing case
1339  * insensitive. haystack may be UTF-8, but needle must
1340  * contain only ascii. */
1341 static gboolean
1342 has_case_prefix (const gchar *haystack, const gchar *needle)
1343 {
1344   const gchar *h, *n;
1345 
1346   /* Eat one character at a time. */
1347   h = haystack;
1348   n = needle;
1349 
1350   while (*n &amp;&amp; *h &amp;&amp;
<span class="line-modified">1351      g_ascii_tolower (*n) == g_ascii_tolower (*h))</span>
1352     {
1353       n++;
1354       h++;
1355     }
1356 
1357   return *n == &#39;\0&#39;;
1358 }
1359 
1360 typedef enum {
1361   UNSAFE_ALL        = 0x1,  /* Escape all unsafe characters   */
1362   UNSAFE_ALLOW_PLUS = 0x2,  /* Allows &#39;+&#39;  */
1363   UNSAFE_PATH       = 0x8,  /* Allows &#39;/&#39;, &#39;&amp;&#39;, &#39;=&#39;, &#39;:&#39;, &#39;@&#39;, &#39;+&#39;, &#39;$&#39; and &#39;,&#39; */
1364   UNSAFE_HOST       = 0x10, /* Allows &#39;/&#39; and &#39;:&#39; and &#39;@&#39; */
1365   UNSAFE_SLASHES    = 0x20  /* Allows all characters except for &#39;/&#39; and &#39;%&#39; */
1366 } UnsafeCharacterSet;
1367 
1368 static const guchar acceptable[96] = {
1369   /* A table of the ASCII chars from space (32) to DEL (127) */
1370   /*      !    &quot;    #    $    %    &amp;    &#39;    (    )    *    +    ,    -    .    / */
1371   0x00,0x3F,0x20,0x20,0x28,0x00,0x2C,0x3F,0x3F,0x3F,0x3F,0x2A,0x28,0x3F,0x3F,0x1C,
1372   /* 0    1    2    3    4    5    6    7    8    9    :    ;    &lt;    =    &gt;    ? */
1373   0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x38,0x20,0x20,0x2C,0x20,0x20,
1374   /* @    A    B    C    D    E    F    G    H    I    J    K    L    M    N    O */
1375   0x38,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
1376   /* P    Q    R    S    T    U    V    W    X    Y    Z    [    \    ]    ^    _ */
1377   0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x20,0x20,0x20,0x20,0x3F,
1378   /* `    a    b    c    d    e    f    g    h    i    j    k    l    m    n    o */
1379   0x20,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
1380   /* p    q    r    s    t    u    v    w    x    y    z    {    |    }    ~  DEL */
1381   0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x20,0x20,0x20,0x3F,0x20
1382 };
1383 
1384 static const gchar hex[16] = &quot;0123456789ABCDEF&quot;;
1385 
1386 /* Note: This escape function works on file: URIs, but if you want to
1387  * escape something else, please read RFC-2396 */
1388 static gchar *
1389 g_escape_uri_string (const gchar *string,
<span class="line-modified">1390              UnsafeCharacterSet mask)</span>
1391 {
1392 #define ACCEPTABLE(a) ((a)&gt;=32 &amp;&amp; (a)&lt;128 &amp;&amp; (acceptable[(a)-32] &amp; use_mask))
1393 
1394   const gchar *p;
1395   gchar *q;
1396   gchar *result;
1397   int c;
1398   gint unacceptable;
1399   UnsafeCharacterSet use_mask;
1400 
1401   g_return_val_if_fail (mask == UNSAFE_ALL
<span class="line-modified">1402             || mask == UNSAFE_ALLOW_PLUS</span>
<span class="line-modified">1403             || mask == UNSAFE_PATH</span>
<span class="line-modified">1404             || mask == UNSAFE_HOST</span>
<span class="line-modified">1405             || mask == UNSAFE_SLASHES, NULL);</span>
1406 
1407   unacceptable = 0;
1408   use_mask = mask;
1409   for (p = string; *p != &#39;\0&#39;; p++)
1410     {
1411       c = (guchar) *p;
1412       if (!ACCEPTABLE (c))
<span class="line-modified">1413     unacceptable++;</span>
1414     }
1415 
1416   result = g_malloc (p - string + unacceptable * 2 + 1);
1417 
1418   use_mask = mask;
1419   for (q = result, p = string; *p != &#39;\0&#39;; p++)
1420     {
1421       c = (guchar) *p;
1422 
1423       if (!ACCEPTABLE (c))
<span class="line-modified">1424     {</span>
<span class="line-modified">1425       *q++ = &#39;%&#39;; /* means hex coming */</span>
<span class="line-modified">1426       *q++ = hex[c &gt;&gt; 4];</span>
<span class="line-modified">1427       *q++ = hex[c &amp; 15];</span>
<span class="line-modified">1428     }</span>
1429       else
<span class="line-modified">1430     *q++ = *p;</span>
1431     }
1432 
1433   *q = &#39;\0&#39;;
1434 
1435   return result;
1436 }
1437 
1438 
1439 static gchar *
1440 g_escape_file_uri (const gchar *hostname,
<span class="line-modified">1441            const gchar *pathname)</span>
1442 {
1443   char *escaped_hostname = NULL;
1444   char *escaped_path;
1445   char *res;
1446 
1447 #ifdef G_OS_WIN32
1448   char *p, *backslash;
1449 
1450   /* Turn backslashes into forward slashes. That&#39;s what Netscape
1451    * does, and they are actually more or less equivalent in Windows.
1452    */
1453 
1454   pathname = g_strdup (pathname);
1455   p = (char *) pathname;
1456 
1457   while ((backslash = strchr (p, &#39;\\&#39;)) != NULL)
1458     {
1459       *backslash = &#39;/&#39;;
1460       p = backslash + 1;
1461     }
1462 #endif
1463 
1464   if (hostname &amp;&amp; *hostname != &#39;\0&#39;)
1465     {
1466       escaped_hostname = g_escape_uri_string (hostname, UNSAFE_HOST);
1467     }
1468 
1469   escaped_path = g_escape_uri_string (pathname, UNSAFE_PATH);
1470 
1471   res = g_strconcat (&quot;file://&quot;,
<span class="line-modified">1472              (escaped_hostname) ? escaped_hostname : &quot;&quot;,</span>
<span class="line-modified">1473              (*escaped_path != &#39;/&#39;) ? &quot;/&quot; : &quot;&quot;,</span>
<span class="line-modified">1474              escaped_path,</span>
<span class="line-modified">1475              NULL);</span>
1476 
1477 #ifdef G_OS_WIN32
1478   g_free ((char *) pathname);
1479 #endif
1480 
1481   g_free (escaped_hostname);
1482   g_free (escaped_path);
1483 
1484   return res;
1485 }
1486 
1487 static int
1488 unescape_character (const char *scanner)
1489 {
1490   int first_digit;
1491   int second_digit;
1492 
1493   first_digit = g_ascii_xdigit_value (scanner[0]);
1494   if (first_digit &lt; 0)
1495     return -1;
1496 
1497   second_digit = g_ascii_xdigit_value (scanner[1]);
1498   if (second_digit &lt; 0)
1499     return -1;
1500 
1501   return (first_digit &lt;&lt; 4) | second_digit;
1502 }
1503 
1504 static gchar *
1505 g_unescape_uri_string (const char *escaped,
<span class="line-modified">1506                int         len,</span>
<span class="line-modified">1507                const char *illegal_escaped_characters,</span>
<span class="line-modified">1508                gboolean    ascii_must_not_be_escaped)</span>
1509 {
1510   const gchar *in, *in_end;
1511   gchar *out, *result;
1512   int c;
1513 
1514   if (escaped == NULL)
1515     return NULL;
1516 
1517   if (len &lt; 0)
1518     len = strlen (escaped);
1519 
1520   result = g_malloc (len + 1);
1521 
1522   out = result;
1523   for (in = escaped, in_end = escaped + len; in &lt; in_end; in++)
1524     {
1525       c = *in;
1526 
1527       if (c == &#39;%&#39;)
<span class="line-modified">1528     {</span>
<span class="line-modified">1529       /* catch partial escape sequences past the end of the substring */</span>
<span class="line-modified">1530       if (in + 3 &gt; in_end)</span>
<span class="line-modified">1531         break;</span>
1532 
<span class="line-modified">1533       c = unescape_character (in + 1);</span>
1534 
<span class="line-modified">1535       /* catch bad escape sequences and NUL characters */</span>
<span class="line-modified">1536       if (c &lt;= 0)</span>
<span class="line-modified">1537         break;</span>
1538 
<span class="line-modified">1539       /* catch escaped ASCII */</span>
<span class="line-modified">1540       if (ascii_must_not_be_escaped &amp;&amp; c &lt;= 0x7F)</span>
<span class="line-modified">1541         break;</span>
1542 
<span class="line-modified">1543       /* catch other illegal escaped characters */</span>
<span class="line-modified">1544       if (strchr (illegal_escaped_characters, c) != NULL)</span>
<span class="line-modified">1545         break;</span>
1546 
<span class="line-modified">1547       in += 2;</span>
<span class="line-modified">1548     }</span>
1549 
1550       *out++ = c;
1551     }
1552 
1553   g_assert (out - result &lt;= len);
1554   *out = &#39;\0&#39;;
1555 
1556   if (in != in_end)
1557     {
1558       g_free (result);
1559       return NULL;
1560     }
1561 
1562   return result;
1563 }
1564 
1565 static gboolean
1566 is_asciialphanum (gunichar c)
1567 {
1568   return c &lt;= 0x7F &amp;&amp; g_ascii_isalnum (c);
</pre>
<hr />
<pre>
1573 {
1574   return c &lt;= 0x7F &amp;&amp; g_ascii_isalpha (c);
1575 }
1576 
1577 /* allows an empty string */
1578 static gboolean
1579 hostname_validate (const char *hostname)
1580 {
1581   const char *p;
1582   gunichar c, first_char, last_char;
1583 
1584   p = hostname;
1585   if (*p == &#39;\0&#39;)
1586     return TRUE;
1587   do
1588     {
1589       /* read in a label */
1590       c = g_utf8_get_char (p);
1591       p = g_utf8_next_char (p);
1592       if (!is_asciialphanum (c))
<span class="line-modified">1593     return FALSE;</span>
1594       first_char = c;
1595       do
<span class="line-modified">1596     {</span>
<span class="line-modified">1597       last_char = c;</span>
<span class="line-modified">1598       c = g_utf8_get_char (p);</span>
<span class="line-modified">1599       p = g_utf8_next_char (p);</span>
<span class="line-modified">1600     }</span>
1601       while (is_asciialphanum (c) || c == &#39;-&#39;);
1602       if (last_char == &#39;-&#39;)
<span class="line-modified">1603     return FALSE;</span>
1604 
1605       /* if that was the last label, check that it was a toplabel */
1606       if (c == &#39;\0&#39; || (c == &#39;.&#39; &amp;&amp; *p == &#39;\0&#39;))
<span class="line-modified">1607     return is_asciialpha (first_char);</span>
1608     }
1609   while (c == &#39;.&#39;);
1610   return FALSE;
1611 }
1612 
1613 /**
1614  * g_filename_from_uri:
1615  * @uri: a uri describing a filename (escaped, encoded in ASCII).
1616  * @hostname: (out) (optional) (nullable): Location to store hostname for the URI.
1617  *            If there is no hostname in the URI, %NULL will be
1618  *            stored in this location.
1619  * @error: location to store the error occurring, or %NULL to ignore
1620  *         errors. Any of the errors in #GConvertError may occur.
1621  *
1622  * Converts an escaped ASCII-encoded URI to a local filename in the
1623  * encoding used for filenames.
1624  *
1625  * Returns: (type filename): a newly-allocated string holding
1626  *               the resulting filename, or %NULL on an error.
1627  **/
1628 gchar *
1629 g_filename_from_uri (const gchar *uri,
<span class="line-modified">1630              gchar      **hostname,</span>
<span class="line-modified">1631              GError     **error)</span>
1632 {
1633   const char *path_part;
1634   const char *host_part;
1635   char *unescaped_hostname;
1636   char *result;
1637   char *filename;
1638   int offs;
1639 #ifdef G_OS_WIN32
1640   char *p, *slash;
1641 #endif
1642 
1643   if (hostname)
1644     *hostname = NULL;
1645 
1646   if (!has_case_prefix (uri, &quot;file:/&quot;))
1647     {
1648       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,
<span class="line-modified">1649            _(&quot;The URI &#39;%s&#39; is not an absolute URI using the &#39;file&#39; scheme&quot;),</span>
<span class="line-modified">1650            uri);</span>
1651       return NULL;
1652     }
1653 
1654   path_part = uri + strlen (&quot;file:&quot;);
1655 
1656   if (strchr (path_part, &#39;#&#39;) != NULL)
1657     {
1658       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,
<span class="line-modified">1659            _(&quot;The local file URI &#39;%s&#39; may not include a &#39;#&#39;&quot;),</span>
<span class="line-modified">1660            uri);</span>
1661       return NULL;
1662     }
1663 
1664   if (has_case_prefix (path_part, &quot;///&quot;))
1665     path_part += 2;
1666   else if (has_case_prefix (path_part, &quot;//&quot;))
1667     {
1668       path_part += 2;
1669       host_part = path_part;
1670 
1671       path_part = strchr (path_part, &#39;/&#39;);
1672 
1673       if (path_part == NULL)
<span class="line-modified">1674     {</span>
<span class="line-modified">1675       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,</span>
<span class="line-modified">1676                _(&quot;The URI &#39;%s&#39; is invalid&quot;),</span>
<span class="line-modified">1677                uri);</span>
<span class="line-modified">1678       return NULL;</span>
<span class="line-modified">1679     }</span>
1680 
1681       unescaped_hostname = g_unescape_uri_string (host_part, path_part - host_part, &quot;&quot;, TRUE);
1682 
1683       if (unescaped_hostname == NULL ||
<span class="line-modified">1684       !hostname_validate (unescaped_hostname))</span>
<span class="line-modified">1685     {</span>
<span class="line-modified">1686       g_free (unescaped_hostname);</span>
<span class="line-modified">1687       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,</span>
<span class="line-modified">1688                _(&quot;The hostname of the URI &#39;%s&#39; is invalid&quot;),</span>
<span class="line-modified">1689                uri);</span>
<span class="line-modified">1690       return NULL;</span>
<span class="line-modified">1691     }</span>
1692 
1693       if (hostname)
<span class="line-modified">1694     *hostname = unescaped_hostname;</span>
1695       else
<span class="line-modified">1696     g_free (unescaped_hostname);</span>
1697     }
1698 
1699   filename = g_unescape_uri_string (path_part, -1, &quot;/&quot;, FALSE);
1700 
1701   if (filename == NULL)
1702     {
1703       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,
<span class="line-modified">1704            _(&quot;The URI &#39;%s&#39; contains invalidly escaped characters&quot;),</span>
<span class="line-modified">1705            uri);</span>
1706       return NULL;
1707     }
1708 
1709   offs = 0;
1710 #ifdef G_OS_WIN32
1711   /* Drop localhost */
1712   if (hostname &amp;&amp; *hostname != NULL &amp;&amp;
1713       g_ascii_strcasecmp (*hostname, &quot;localhost&quot;) == 0)
1714     {
1715       g_free (*hostname);
1716       *hostname = NULL;
1717     }
1718 
1719   /* Turn slashes into backslashes, because that&#39;s the canonical spelling */
1720   p = filename;
1721   while ((slash = strchr (p, &#39;/&#39;)) != NULL)
1722     {
1723       *slash = &#39;\\&#39;;
1724       p = slash + 1;
1725     }
1726 
1727   /* Windows URIs with a drive letter can be like &quot;file://host/c:/foo&quot;
1728    * or &quot;file://host/c|/foo&quot; (some Netscape versions). In those cases, start
1729    * the filename from the drive letter.
1730    */
1731   if (g_ascii_isalpha (filename[1]))
1732     {
1733       if (filename[2] == &#39;:&#39;)
<span class="line-modified">1734     offs = 1;</span>
1735       else if (filename[2] == &#39;|&#39;)
<span class="line-modified">1736     {</span>
<span class="line-modified">1737       filename[2] = &#39;:&#39;;</span>
<span class="line-modified">1738       offs = 1;</span>
<span class="line-modified">1739     }</span>
1740     }
1741 #endif
1742 
1743   result = g_strdup (filename + offs);
1744   g_free (filename);
1745 
1746   return result;
1747 }
1748 
1749 /**
1750  * g_filename_to_uri:
1751  * @filename: (type filename): an absolute filename specified in the GLib file
1752  *     name encoding, which is the on-disk file name bytes on Unix, and UTF-8
1753  *     on Windows
1754  * @hostname: (nullable): A UTF-8 encoded hostname, or %NULL for none.
1755  * @error: location to store the error occurring, or %NULL to ignore
1756  *         errors. Any of the errors in #GConvertError may occur.
1757  *
1758  * Converts an absolute filename to an escaped ASCII-encoded URI, with the path
1759  * component following Section 3.3. of RFC 2396.
1760  *
1761  * Returns: a newly-allocated string holding the resulting
1762  *               URI, or %NULL on an error.
1763  **/
1764 gchar *
1765 g_filename_to_uri (const gchar *filename,
<span class="line-modified">1766            const gchar *hostname,</span>
<span class="line-modified">1767            GError     **error)</span>
1768 {
1769   char *escaped_uri;
1770 
1771   g_return_val_if_fail (filename != NULL, NULL);
1772 
1773   if (!g_path_is_absolute (filename))
1774     {
1775       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_NOT_ABSOLUTE_PATH,
<span class="line-modified">1776            _(&quot;The pathname &#39;%s&#39; is not an absolute path&quot;),</span>
<span class="line-modified">1777            filename);</span>
1778       return NULL;
1779     }
1780 
1781   if (hostname &amp;&amp;
1782       !(g_utf8_validate (hostname, -1, NULL)
<span class="line-modified">1783     &amp;&amp; hostname_validate (hostname)))</span>
1784     {
1785       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
1786                            _(&quot;Invalid hostname&quot;));
1787       return NULL;
1788     }
1789 
1790 #ifdef G_OS_WIN32
1791   /* Don&#39;t use localhost unnecessarily */
1792   if (hostname &amp;&amp; g_ascii_strcasecmp (hostname, &quot;localhost&quot;) == 0)
1793     hostname = NULL;
1794 #endif
1795 
1796   escaped_uri = g_escape_file_uri (hostname, filename);
1797 
1798   return escaped_uri;
1799 }
1800 
1801 /**
1802  * g_uri_list_extract_uris:
1803  * @uri_list: an URI list
</pre>
<hr />
<pre>
1817 {
1818   GSList *uris, *u;
1819   const gchar *p, *q;
1820   gchar **result;
1821   gint n_uris = 0;
1822 
1823   uris = NULL;
1824 
1825   p = uri_list;
1826 
1827   /* We don&#39;t actually try to validate the URI according to RFC
1828    * 2396, or even check for allowed characters - we just ignore
1829    * comments and trim whitespace off the ends.  We also
1830    * allow LF delimination as well as the specified CRLF.
1831    *
1832    * We do allow comments like specified in RFC 2483.
1833    */
1834   while (p)
1835     {
1836       if (*p != &#39;#&#39;)
<span class="line-modified">1837     {</span>
<span class="line-modified">1838       while (g_ascii_isspace (*p))</span>
<span class="line-modified">1839         p++;</span>
1840 
<span class="line-modified">1841       q = p;</span>
<span class="line-modified">1842       while (*q &amp;&amp; (*q != &#39;\n&#39;) &amp;&amp; (*q != &#39;\r&#39;))</span>
<span class="line-modified">1843         q++;</span>
1844 
<span class="line-modified">1845       if (q &gt; p)</span>
<span class="line-modified">1846         {</span>
<span class="line-removed">1847           q--;</span>
<span class="line-removed">1848           while (q &gt; p &amp;&amp; g_ascii_isspace (*q))</span>
1849         q--;


1850 
<span class="line-modified">1851           if (q &gt; p)</span>
<span class="line-modified">1852         {</span>
<span class="line-modified">1853           uris = g_slist_prepend (uris, g_strndup (p, q - p + 1));</span>
<span class="line-modified">1854           n_uris++;</span>
<span class="line-removed">1855         }</span>
<span class="line-removed">1856         }</span>
1857     }


1858       p = strchr (p, &#39;\n&#39;);
1859       if (p)
<span class="line-modified">1860     p++;</span>
1861     }
1862 
1863   result = g_new (gchar *, n_uris + 1);
1864 
1865   result[n_uris--] = NULL;
1866   for (u = uris; u; u = u-&gt;next)
1867     result[n_uris--] = u-&gt;data;
1868 
1869   g_slist_free (uris);
1870 
1871   return result;
1872 }
1873 
1874 /**
1875  * g_filename_display_basename:
1876  * @filename: (type filename): an absolute pathname in the
1877  *     GLib file name encoding
1878  *
1879  * Returns the display basename for the particular filename, guaranteed
1880  * to be valid UTF-8. The display name might not be identical to the filename,
</pre>
<hr />
<pre>
1934  * translation of filenames.
1935  *
1936  * Returns: a newly allocated string containing
1937  *   a rendition of the filename in valid UTF-8
1938  *
1939  * Since: 2.6
1940  **/
1941 gchar *
1942 g_filename_display_name (const gchar *filename)
1943 {
1944   gint i;
1945   const gchar **charsets;
1946   gchar *display_name = NULL;
1947   gboolean is_utf8;
1948 
1949   is_utf8 = g_get_filename_charsets (&amp;charsets);
1950 
1951   if (is_utf8)
1952     {
1953       if (g_utf8_validate (filename, -1, NULL))
<span class="line-modified">1954     display_name = g_strdup (filename);</span>
1955     }
1956 
1957   if (!display_name)
1958     {
1959       /* Try to convert from the filename charsets to UTF-8.
1960        * Skip the first charset if it is UTF-8.
1961        */
1962       for (i = is_utf8 ? 1 : 0; charsets[i]; i++)
<span class="line-modified">1963     {</span>
<span class="line-modified">1964       display_name = g_convert (filename, -1, &quot;UTF-8&quot;, charsets[i],</span>
<span class="line-modified">1965                     NULL, NULL, NULL);</span>
1966 
<span class="line-modified">1967       if (display_name)</span>
<span class="line-modified">1968         break;</span>
<span class="line-modified">1969     }</span>
1970     }
1971 
1972   /* if all conversions failed, we replace invalid UTF-8
1973    * by a question mark
1974    */
1975   if (!display_name)
1976     display_name = g_utf8_make_valid (filename, -1);
1977 
1978   return display_name;
1979 }
1980 
1981 #ifdef G_OS_WIN32
1982 
1983 /* Binary compatibility versions. Not for newly compiled code. */
1984 
1985 _GLIB_EXTERN gchar *g_filename_to_utf8_utf8   (const gchar  *opsysstring,
1986                                                gssize        len,
1987                                                gsize        *bytes_read,
1988                                                gsize        *bytes_written,
1989                                                GError      **error) G_GNUC_MALLOC;
</pre>
</td>
<td>
<hr />
<pre>
  29 #include &lt;string.h&gt;
  30 #include &lt;stdlib.h&gt;
  31 
  32 #ifdef G_OS_WIN32
  33 #include &quot;win_iconv.c&quot;
  34 #endif
  35 
  36 #ifdef G_PLATFORM_WIN32
  37 #define STRICT
  38 #include &lt;windows.h&gt;
  39 #undef STRICT
  40 #endif
  41 
  42 #include &quot;gconvert.h&quot;
  43 
  44 #include &quot;gcharsetprivate.h&quot;
  45 #include &quot;gslist.h&quot;
  46 #include &quot;gstrfuncs.h&quot;
  47 #include &quot;gtestutils.h&quot;
  48 #include &quot;gthread.h&quot;
<span class="line-added">  49 #include &quot;gthreadprivate.h&quot;</span>
  50 #include &quot;gunicode.h&quot;
  51 #include &quot;gfileutils.h&quot;
  52 
  53 #include &quot;glibintl.h&quot;
  54 








  55 
  56 /**
  57  * SECTION:conversions
  58  * @title: Character Set Conversion
  59  * @short_description: convert strings between different character sets
  60  *
  61  * The g_convert() family of function wraps the functionality of iconv().
  62  * In addition to pure character set conversions, GLib has functions to
  63  * deal with the extra complications of encodings for file names.
  64  *
  65  * ## File Name Encodings
  66  *
  67  * Historically, UNIX has not had a defined encoding for file names:
  68  * a file name is valid as long as it does not have path separators
  69  * in it (&quot;/&quot;). However, displaying file names may require conversion:
  70  * from the character set in which they were created, to the character
  71  * set in which the application operates. Consider the Spanish file name
  72  * &quot;Presentacion.sxi&quot;. If the application which created it uses
  73  * ISO-8859-1 for its encoding,
  74  * |[
</pre>
<hr />
<pre>
 145  *
 146  * 3. If your user interface lets the user type a file name for saving
 147  *    or renaming, convert it to the encoding used for file names in
 148  *    the file system by using g_filename_from_utf8(). Pass the converted
 149  *    file name to functions like fopen(). If conversion fails, ask the
 150  *    user to enter a different file name. This can happen if the user
 151  *    types Japanese characters when `G_FILENAME_ENCODING` is set to
 152  *    `ISO-8859-1`, for example.
 153  */
 154 
 155 /* We try to terminate strings in unknown charsets with this many zero bytes
 156  * to ensure that multibyte strings really are nul-terminated when we return
 157  * them from g_convert() and friends.
 158  */
 159 #define NUL_TERMINATOR_LENGTH 4
 160 
 161 G_DEFINE_QUARK (g_convert_error, g_convert_error)
 162 
 163 static gboolean
 164 try_conversion (const char *to_codeset,
<span class="line-modified"> 165     const char *from_codeset,</span>
<span class="line-modified"> 166     iconv_t    *cd)</span>
 167 {
 168   *cd = iconv_open (to_codeset, from_codeset);
 169 
 170   if (*cd == (iconv_t)-1 &amp;&amp; errno == EINVAL)
 171     return FALSE;
 172   else
 173     return TRUE;
 174 }
 175 
 176 static gboolean
 177 try_to_aliases (const char **to_aliases,
<span class="line-modified"> 178     const char  *from_codeset,</span>
<span class="line-modified"> 179     iconv_t     *cd)</span>
 180 {
 181   if (to_aliases)
 182     {
 183       const char **p = to_aliases;
 184       while (*p)
<span class="line-modified"> 185   {</span>
<span class="line-modified"> 186     if (try_conversion (*p, from_codeset, cd))</span>
<span class="line-modified"> 187       return TRUE;</span>
 188 
<span class="line-modified"> 189     p++;</span>
<span class="line-modified"> 190   }</span>
 191     }
 192 
 193   return FALSE;
 194 }
 195 
 196 /**
 197  * g_iconv_open: (skip)
 198  * @to_codeset: destination codeset
 199  * @from_codeset: source codeset
 200  *
 201  * Same as the standard UNIX routine iconv_open(), but
 202  * may be implemented via libiconv on UNIX flavors that lack
 203  * a native implementation.
 204  *
 205  * GLib provides g_convert() and g_locale_to_utf8() which are likely
 206  * more convenient than the raw iconv wrappers.
 207  *
 208  * Returns: a &quot;conversion descriptor&quot;, or (GIConv)-1 if
 209  *  opening the converter failed.
 210  **/
 211 GIConv
 212 g_iconv_open (const gchar  *to_codeset,
<span class="line-modified"> 213         const gchar  *from_codeset)</span>
 214 {
 215   iconv_t cd;
 216 
 217   if (!try_conversion (to_codeset, from_codeset, &amp;cd))
 218     {
 219       const char **to_aliases = _g_charset_get_aliases (to_codeset);
 220       const char **from_aliases = _g_charset_get_aliases (from_codeset);
 221 
 222       if (from_aliases)
<span class="line-modified"> 223   {</span>
<span class="line-modified"> 224     const char **p = from_aliases;</span>
<span class="line-modified"> 225     while (*p)</span>
<span class="line-modified"> 226       {</span>
<span class="line-modified"> 227         if (try_conversion (to_codeset, *p, &amp;cd))</span>
<span class="line-modified"> 228     goto out;</span>
 229 
<span class="line-modified"> 230         if (try_to_aliases (to_aliases, *p, &amp;cd))</span>
<span class="line-modified"> 231     goto out;</span>
 232 
<span class="line-modified"> 233         p++;</span>
<span class="line-modified"> 234       }</span>
<span class="line-modified"> 235   }</span>
 236 
 237       if (try_to_aliases (to_aliases, from_codeset, &amp;cd))
<span class="line-modified"> 238   goto out;</span>
 239     }
 240 
 241  out:
 242   return (cd == (iconv_t)-1) ? (GIConv)-1 : (GIConv)cd;
 243 }
 244 
 245 /**
 246  * g_iconv: (skip)
 247  * @converter: conversion descriptor from g_iconv_open()
 248  * @inbuf: bytes to convert
 249  * @inbytes_left: inout parameter, bytes remaining to convert in @inbuf
 250  * @outbuf: converted output bytes
 251  * @outbytes_left: inout parameter, bytes available to fill in @outbuf
 252  *
 253  * Same as the standard UNIX routine iconv(), but
 254  * may be implemented via libiconv on UNIX flavors that lack
 255  * a native implementation.
 256  *
 257  * GLib provides g_convert() and g_locale_to_utf8() which are likely
 258  * more convenient than the raw iconv wrappers.
 259  *
 260  * Note that the behaviour of iconv() for characters which are valid in the
 261  * input character set, but which have no representation in the output character
 262  * set, is implementation defined. This function may return success (with a
 263  * positive number of non-reversible conversions as replacement characters were
 264  * used), or it may return -1 and set an error such as %EILSEQ, in such a
 265  * situation.
 266  *
 267  * Returns: count of non-reversible conversions, or -1 on error
 268  **/
 269 gsize
 270 g_iconv (GIConv   converter,
<span class="line-modified"> 271    gchar  **inbuf,</span>
<span class="line-modified"> 272    gsize   *inbytes_left,</span>
<span class="line-modified"> 273    gchar  **outbuf,</span>
<span class="line-modified"> 274    gsize   *outbytes_left)</span>
 275 {
 276   iconv_t cd = (iconv_t)converter;
 277 
 278   return iconv (cd, inbuf, inbytes_left, outbuf, outbytes_left);
 279 }
 280 
 281 /**
 282  * g_iconv_close: (skip)
 283  * @converter: a conversion descriptor from g_iconv_open()
 284  *
 285  * Same as the standard UNIX routine iconv_close(), but
 286  * may be implemented via libiconv on UNIX flavors that lack
 287  * a native implementation. Should be called to clean up
 288  * the conversion descriptor from g_iconv_open() when
 289  * you are done converting things.
 290  *
 291  * GLib provides g_convert() and g_locale_to_utf8() which are likely
 292  * more convenient than the raw iconv wrappers.
 293  *
 294  * Returns: -1 on error, 0 on success
 295  **/
 296 gint
 297 g_iconv_close (GIConv converter)
 298 {
 299   iconv_t cd = (iconv_t)converter;
 300 
 301   return iconv_close (cd);
 302 }
 303 
 304 static GIConv
 305 open_converter (const gchar *to_codeset,
<span class="line-modified"> 306     const gchar *from_codeset,</span>
<span class="line-modified"> 307     GError     **error)</span>
 308 {
 309   GIConv cd;
 310 
 311   cd = g_iconv_open (to_codeset, from_codeset);
 312 
 313   if (cd == (GIConv) -1)
 314     {
 315       /* Something went wrong.  */
 316       if (error)
<span class="line-modified"> 317   {</span>
<span class="line-modified"> 318     if (errno == EINVAL)</span>
<span class="line-modified"> 319       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_NO_CONVERSION,</span>
<span class="line-modified"> 320        _(&quot;Conversion from character set &#39;%s&#39; to &#39;%s&#39; is not supported&quot;),</span>
<span class="line-modified"> 321        from_codeset, to_codeset);</span>
<span class="line-modified"> 322     else</span>
<span class="line-modified"> 323       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,</span>
<span class="line-modified"> 324        _(&quot;Could not open converter from &#39;%s&#39; to &#39;%s&#39;&quot;),</span>
<span class="line-modified"> 325        from_codeset, to_codeset);</span>
<span class="line-modified"> 326   }</span>
 327     }
 328 
 329   return cd;
 330 }
 331 
 332 static int
 333 close_converter (GIConv cd)
 334 {
 335   if (cd == (GIConv) -1)
 336     return 0;
 337 
 338   return g_iconv_close (cd);
 339 }
 340 
 341 /**
 342  * g_convert_with_iconv: (skip)
 343  * @str:           (array length=len) (element-type guint8):
 344  *                 the string to convert.
 345  * @len:           the length of the string in bytes, or -1 if the string is
 346  *                 nul-terminated (Note that some encodings may allow nul
</pre>
<hr />
<pre>
 370  * g_convert_with_iconv() or g_convert_with_fallback(). (An example of
 371  * this is the GNU C converter for CP1255 which does not emit a base
 372  * character until it knows that the next character is not a mark that
 373  * could combine with the base character.)
 374  *
 375  * Characters which are valid in the input character set, but which have no
 376  * representation in the output character set will result in a
 377  * %G_CONVERT_ERROR_ILLEGAL_SEQUENCE error. This is in contrast to the iconv()
 378  * specification, which leaves this behaviour implementation defined. Note that
 379  * this is the same error code as is returned for an invalid byte sequence in
 380  * the input character set. To get defined behaviour for conversion of
 381  * unrepresentable characters, use g_convert_with_fallback().
 382  *
 383  * Returns: (array length=bytes_written) (element-type guint8) (transfer full):
 384  *               If the conversion was successful, a newly allocated buffer
 385  *               containing the converted string, which must be freed with
 386  *               g_free(). Otherwise %NULL and @error will be set.
 387  **/
 388 gchar*
 389 g_convert_with_iconv (const gchar *str,
<span class="line-modified"> 390           gssize       len,</span>
<span class="line-modified"> 391           GIConv       converter,</span>
<span class="line-modified"> 392           gsize       *bytes_read,</span>
<span class="line-modified"> 393           gsize       *bytes_written,</span>
<span class="line-modified"> 394           GError     **error)</span>
 395 {
 396   gchar *dest;
 397   gchar *outp;
 398   const gchar *p;
 399   gsize inbytes_remaining;
 400   gsize outbytes_remaining;
 401   gsize err;
 402   gsize outbuf_size;
 403   gboolean have_error = FALSE;
 404   gboolean done = FALSE;
 405   gboolean reset = FALSE;
 406 
 407   g_return_val_if_fail (converter != (GIConv) -1, NULL);
 408 
 409   if (len &lt; 0)
 410     len = strlen (str);
 411 
 412   p = str;
 413   inbytes_remaining = len;
 414   outbuf_size = len + NUL_TERMINATOR_LENGTH;
 415 
 416   outbytes_remaining = outbuf_size - NUL_TERMINATOR_LENGTH;
 417   outp = dest = g_malloc (outbuf_size);
 418 
 419   while (!done &amp;&amp; !have_error)
 420     {
 421       if (reset)
 422         err = g_iconv (converter, NULL, &amp;inbytes_remaining, &amp;outp, &amp;outbytes_remaining);
 423       else
 424         err = g_iconv (converter, (char **)&amp;p, &amp;inbytes_remaining, &amp;outp, &amp;outbytes_remaining);
 425 
 426       if (err == (gsize) -1)
<span class="line-modified"> 427   {</span>
<span class="line-modified"> 428     switch (errno)</span>
<span class="line-added"> 429       {</span>
<span class="line-added"> 430       case EINVAL:</span>
<span class="line-added"> 431         /* Incomplete text, do not report an error */</span>
<span class="line-added"> 432         done = TRUE;</span>
<span class="line-added"> 433         break;</span>
<span class="line-added"> 434       case E2BIG:</span>
 435         {
<span class="line-modified"> 436     gsize used = outp - dest;</span>
<span class="line-modified"> 437 </span>
<span class="line-modified"> 438     outbuf_size *= 2;</span>
<span class="line-modified"> 439     dest = g_realloc (dest, outbuf_size);</span>
<span class="line-modified"> 440 </span>
<span class="line-modified"> 441     outp = dest + used;</span>
<span class="line-modified"> 442     outbytes_remaining = outbuf_size - used - NUL_TERMINATOR_LENGTH;</span>
<span class="line-modified"> 443         }</span>
<span class="line-modified"> 444         break;</span>
<span class="line-modified"> 445       case EILSEQ:</span>






 446               g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
 447                                    _(&quot;Invalid byte sequence in conversion input&quot;));
<span class="line-modified"> 448         have_error = TRUE;</span>
<span class="line-modified"> 449         break;</span>
<span class="line-modified"> 450       default:</span>
 451               {
 452                 int errsv = errno;
 453 
 454                 g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,
 455                              _(&quot;Error during conversion: %s&quot;),
 456                              g_strerror (errsv));
 457               }
<span class="line-modified"> 458         have_error = TRUE;</span>
<span class="line-modified"> 459         break;</span>
<span class="line-modified"> 460       }</span>
<span class="line-modified"> 461   }</span>
 462       else if (err &gt; 0)
 463         {
 464           /* @err gives the number of replacement characters used. */
 465           g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
 466                                _(&quot;Unrepresentable character in conversion input&quot;));
 467           have_error = TRUE;
 468         }
 469       else
<span class="line-modified"> 470   {</span>
<span class="line-modified"> 471     if (!reset)</span>
<span class="line-modified"> 472       {</span>
<span class="line-modified"> 473         /* call g_iconv with NULL inbuf to cleanup shift state */</span>
<span class="line-modified"> 474         reset = TRUE;</span>
<span class="line-modified"> 475         inbytes_remaining = 0;</span>
<span class="line-modified"> 476       }</span>
<span class="line-modified"> 477     else</span>
<span class="line-modified"> 478       done = TRUE;</span>
<span class="line-modified"> 479   }</span>
 480     }
 481 
 482   memset (outp, 0, NUL_TERMINATOR_LENGTH);
 483 
 484   if (bytes_read)
 485     *bytes_read = p - str;
 486   else
 487     {
 488       if ((p - str) != len)
<span class="line-modified"> 489   {</span>
 490           if (!have_error)
 491             {
 492               g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_PARTIAL_INPUT,
 493                                    _(&quot;Partial character sequence at end of input&quot;));
 494               have_error = TRUE;
 495             }
<span class="line-modified"> 496   }</span>
 497     }
 498 
 499   if (bytes_written)
<span class="line-modified"> 500     *bytes_written = outp - dest; /* Doesn&#39;t include &#39;\0&#39; */</span>
 501 
 502   if (have_error)
 503     {
 504       g_free (dest);
 505       return NULL;
 506     }
 507   else
 508     return dest;
 509 }
 510 
 511 /**
 512  * g_convert:
 513  * @str:           (array length=len) (element-type guint8):
 514  *                 the string to convert.
 515  * @len:           the length of the string in bytes, or -1 if the string is
 516  *                 nul-terminated (Note that some encodings may allow nul
 517  *                 bytes to occur inside strings. In that case, using -1
 518  *                 for the @len parameter is unsafe)
 519  * @to_codeset:    name of character set into which to convert @str
 520  * @from_codeset:  character set of @str.
</pre>
<hr />
<pre>
 540  * then this won&#39;t be preserved across successive calls to g_convert(),
 541  * g_convert_with_iconv() or g_convert_with_fallback(). (An example of
 542  * this is the GNU C converter for CP1255 which does not emit a base
 543  * character until it knows that the next character is not a mark that
 544  * could combine with the base character.)
 545  *
 546  * Using extensions such as &quot;//TRANSLIT&quot; may not work (or may not work
 547  * well) on many platforms.  Consider using g_str_to_ascii() instead.
 548  *
 549  * Returns: (array length=bytes_written) (element-type guint8) (transfer full):
 550  *          If the conversion was successful, a newly allocated buffer
 551  *          containing the converted string, which must be freed with g_free().
 552  *          Otherwise %NULL and @error will be set.
 553  **/
 554 gchar*
 555 g_convert (const gchar *str,
 556            gssize       len,
 557            const gchar *to_codeset,
 558            const gchar *from_codeset,
 559            gsize       *bytes_read,
<span class="line-modified"> 560      gsize       *bytes_written,</span>
<span class="line-modified"> 561      GError     **error)</span>
 562 {
 563   gchar *res;
 564   GIConv cd;
 565 
 566   g_return_val_if_fail (str != NULL, NULL);
 567   g_return_val_if_fail (to_codeset != NULL, NULL);
 568   g_return_val_if_fail (from_codeset != NULL, NULL);
 569 
 570   cd = open_converter (to_codeset, from_codeset, error);
 571 
 572   if (cd == (GIConv) -1)
 573     {
 574       if (bytes_read)
 575         *bytes_read = 0;
 576 
 577       if (bytes_written)
 578         *bytes_written = 0;
 579 
 580       return NULL;
 581     }
 582 
 583   res = g_convert_with_iconv (str, len, cd,
<span class="line-modified"> 584             bytes_read, bytes_written,</span>
<span class="line-modified"> 585             error);</span>
 586 
 587   close_converter (cd);
 588 
 589   return res;
 590 }
 591 
 592 /**
 593  * g_convert_with_fallback:
 594  * @str:          (array length=len) (element-type guint8):
 595  *                the string to convert.
 596  * @len:          the length of the string in bytes, or -1 if the string is
 597  *                 nul-terminated (Note that some encodings may allow nul
 598  *                 bytes to occur inside strings. In that case, using -1
 599  *                 for the @len parameter is unsafe)
 600  * @to_codeset:   name of character set into which to convert @str
 601  * @from_codeset: character set of @str.
 602  * @fallback:     UTF-8 string to use in place of characters not
 603  *                present in the target encoding. (The string must be
 604  *                representable in the target encoding).
 605  *                If %NULL, characters not in the target encoding will
</pre>
<hr />
<pre>
 622  * to @to_codeset in their iconv() functions,
 623  * in which case GLib will simply return that approximate conversion.
 624  *
 625  * Note that you should use g_iconv() for streaming conversions.
 626  * Despite the fact that @bytes_read can return information about partial
 627  * characters, the g_convert_... functions are not generally suitable
 628  * for streaming. If the underlying converter maintains internal state,
 629  * then this won&#39;t be preserved across successive calls to g_convert(),
 630  * g_convert_with_iconv() or g_convert_with_fallback(). (An example of
 631  * this is the GNU C converter for CP1255 which does not emit a base
 632  * character until it knows that the next character is not a mark that
 633  * could combine with the base character.)
 634  *
 635  * Returns: (array length=bytes_written) (element-type guint8) (transfer full):
 636  *          If the conversion was successful, a newly allocated buffer
 637  *          containing the converted string, which must be freed with g_free().
 638  *          Otherwise %NULL and @error will be set.
 639  **/
 640 gchar*
 641 g_convert_with_fallback (const gchar *str,
<span class="line-modified"> 642        gssize       len,</span>
<span class="line-modified"> 643        const gchar *to_codeset,</span>
<span class="line-modified"> 644        const gchar *from_codeset,</span>
<span class="line-modified"> 645        const gchar *fallback,</span>
<span class="line-modified"> 646        gsize       *bytes_read,</span>
<span class="line-modified"> 647        gsize       *bytes_written,</span>
<span class="line-modified"> 648        GError     **error)</span>
 649 {
 650   gchar *utf8;
 651   gchar *dest;
 652   gchar *outp;
 653   const gchar *insert_str = NULL;
 654   const gchar *p;
 655   gsize inbytes_remaining;
 656   const gchar *save_p = NULL;
 657   gsize save_inbytes = 0;
 658   gsize outbytes_remaining;
 659   gsize err;
 660   GIConv cd;
 661   gsize outbuf_size;
 662   gboolean have_error = FALSE;
 663   gboolean done = FALSE;
 664 
 665   GError *local_error = NULL;
 666 
 667   g_return_val_if_fail (str != NULL, NULL);
 668   g_return_val_if_fail (to_codeset != NULL, NULL);
 669   g_return_val_if_fail (from_codeset != NULL, NULL);
 670 
 671   if (len &lt; 0)
 672     len = strlen (str);
 673 
 674   /* Try an exact conversion; we only proceed if this fails
 675    * due to an illegal sequence in the input string.
 676    */
 677   dest = g_convert (str, len, to_codeset, from_codeset,
<span class="line-modified"> 678         bytes_read, bytes_written, &amp;local_error);</span>
 679   if (!local_error)
 680     return dest;
 681 
 682   if (!g_error_matches (local_error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE))
 683     {
 684       g_propagate_error (error, local_error);
 685       return NULL;
 686     }
 687   else
 688     g_error_free (local_error);
 689 
 690   local_error = NULL;
 691 
 692   /* No go; to proceed, we need a converter from &quot;UTF-8&quot; to
 693    * to_codeset, and the string as UTF-8.
 694    */
 695   cd = open_converter (to_codeset, &quot;UTF-8&quot;, error);
 696   if (cd == (GIConv) -1)
 697     {
 698       if (bytes_read)
 699         *bytes_read = 0;
 700 
 701       if (bytes_written)
 702         *bytes_written = 0;
 703 
 704       return NULL;
 705     }
 706 
 707   utf8 = g_convert (str, len, &quot;UTF-8&quot;, from_codeset,
<span class="line-modified"> 708         bytes_read, &amp;inbytes_remaining, error);</span>
 709   if (!utf8)
 710     {
 711       close_converter (cd);
 712       if (bytes_written)
 713         *bytes_written = 0;
 714       return NULL;
 715     }
 716 
 717   /* Now the heart of the code. We loop through the UTF-8 string, and
 718    * whenever we hit an offending character, we form fallback, convert
 719    * the fallback to the target codeset, and then go back to
 720    * converting the original string after finishing with the fallback.
 721    *
 722    * The variables save_p and save_inbytes store the input state
 723    * for the original string while we are converting the fallback
 724    */
 725   p = utf8;
 726 
 727   outbuf_size = len + NUL_TERMINATOR_LENGTH;
 728   outbytes_remaining = outbuf_size - NUL_TERMINATOR_LENGTH;
 729   outp = dest = g_malloc (outbuf_size);
 730 
 731   while (!done &amp;&amp; !have_error)
 732     {
 733       gsize inbytes_tmp = inbytes_remaining;
 734       err = g_iconv (cd, (char **)&amp;p, &amp;inbytes_tmp, &amp;outp, &amp;outbytes_remaining);
 735       inbytes_remaining = inbytes_tmp;
 736 
 737       if (err == (gsize) -1)
<span class="line-modified"> 738   {</span>
<span class="line-modified"> 739     switch (errno)</span>
<span class="line-added"> 740       {</span>
<span class="line-added"> 741       case EINVAL:</span>
<span class="line-added"> 742         g_assert_not_reached();</span>
<span class="line-added"> 743         break;</span>
<span class="line-added"> 744       case E2BIG:</span>
 745         {
<span class="line-modified"> 746     gsize used = outp - dest;</span>





 747 
<span class="line-modified"> 748     outbuf_size *= 2;</span>
<span class="line-modified"> 749     dest = g_realloc (dest, outbuf_size);</span>
 750 
<span class="line-modified"> 751     outp = dest + used;</span>
<span class="line-modified"> 752     outbytes_remaining = outbuf_size - used - NUL_TERMINATOR_LENGTH;</span>
 753 
<span class="line-modified"> 754     break;</span>











 755         }
<span class="line-modified"> 756       case EILSEQ:</span>
<span class="line-added"> 757         if (save_p)</span>
<span class="line-added"> 758     {</span>
<span class="line-added"> 759       /* Error converting fallback string - fatal</span>
<span class="line-added"> 760        */</span>
<span class="line-added"> 761       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
<span class="line-added"> 762              _(&quot;Cannot convert fallback &#39;%s&#39; to codeset &#39;%s&#39;&quot;),</span>
<span class="line-added"> 763              insert_str, to_codeset);</span>
<span class="line-added"> 764       have_error = TRUE;</span>
<span class="line-added"> 765       break;</span>
<span class="line-added"> 766     }</span>
<span class="line-added"> 767         else if (p)</span>
<span class="line-added"> 768     {</span>
<span class="line-added"> 769       if (!fallback)</span>
 770         {
<span class="line-modified"> 771           gunichar ch = g_utf8_get_char (p);</span>
<span class="line-modified"> 772           insert_str = g_strdup_printf (ch &lt; 0x10000 ? &quot;\\u%04x&quot; : &quot;\\U%08x&quot;,</span>
<span class="line-modified"> 773                 ch);</span>











 774         }
<span class="line-modified"> 775       else</span>
<span class="line-modified"> 776         insert_str = fallback;</span>
<span class="line-added"> 777 </span>
<span class="line-added"> 778       save_p = g_utf8_next_char (p);</span>
<span class="line-added"> 779       save_inbytes = inbytes_remaining - (save_p - p);</span>
<span class="line-added"> 780       p = insert_str;</span>
<span class="line-added"> 781       inbytes_remaining = strlen (p);</span>
<span class="line-added"> 782       break;</span>
<span class="line-added"> 783     }</span>
<span class="line-added"> 784               /* if p is null */</span>
<span class="line-added"> 785               G_GNUC_FALLTHROUGH;</span>
<span class="line-added"> 786       default:</span>
 787               {
 788                 int errsv = errno;
 789 
 790                 g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,
 791                              _(&quot;Error during conversion: %s&quot;),
 792                              g_strerror (errsv));
 793               }
 794 
<span class="line-modified"> 795         have_error = TRUE;</span>
<span class="line-modified"> 796         break;</span>
<span class="line-modified"> 797       }</span>
<span class="line-modified"> 798   }</span>
















 799       else
<span class="line-modified"> 800   {</span>
<span class="line-modified"> 801     if (save_p)</span>
<span class="line-added"> 802       {</span>
<span class="line-added"> 803         if (!fallback)</span>
<span class="line-added"> 804     g_free ((gchar *)insert_str);</span>
<span class="line-added"> 805         p = save_p;</span>
<span class="line-added"> 806         inbytes_remaining = save_inbytes;</span>
<span class="line-added"> 807         save_p = NULL;</span>
<span class="line-added"> 808       }</span>
<span class="line-added"> 809     else if (p)</span>
<span class="line-added"> 810       {</span>
<span class="line-added"> 811         /* call g_iconv with NULL inbuf to cleanup shift state */</span>
<span class="line-added"> 812         p = NULL;</span>
<span class="line-added"> 813         inbytes_remaining = 0;</span>
<span class="line-added"> 814       }</span>
<span class="line-added"> 815     else</span>
<span class="line-added"> 816       done = TRUE;</span>
<span class="line-added"> 817   }</span>
 818     }
 819 
 820   /* Cleanup
 821    */
 822   memset (outp, 0, NUL_TERMINATOR_LENGTH);
 823 
 824   close_converter (cd);
 825 
 826   if (bytes_written)
<span class="line-modified"> 827     *bytes_written = outp - dest; /* Doesn&#39;t include &#39;\0&#39; */</span>
 828 
 829   g_free (utf8);
 830 
 831   if (have_error)
 832     {
 833       if (save_p &amp;&amp; !fallback)
<span class="line-modified"> 834   g_free ((gchar *)insert_str);</span>
 835       g_free (dest);
 836       return NULL;
 837     }
 838   else
 839     return dest;
 840 }
 841 
 842 /*
 843  * g_locale_to_utf8
 844  *
 845  *
 846  */
 847 
 848 /*
 849  * Validate @string as UTF-8. @len can be negative if @string is
 850  * nul-terminated, or a non-negative value in bytes. If @string ends in an
 851  * incomplete sequence, or contains any illegal sequences or nul codepoints,
 852  * %NULL will be returned and the error set to
 853  * %G_CONVERT_ERROR_ILLEGAL_SEQUENCE.
 854  * On success, @bytes_read and @bytes_written, if provided, will be set to
 855  * the number of bytes in @string up to @len or the terminating nul byte.
 856  * On error, @bytes_read will be set to the byte offset after the last valid
 857  * and non-nul UTF-8 sequence in @string, and @bytes_written will be set to 0.
 858  */
 859 static gchar *
 860 strdup_len (const gchar *string,
<span class="line-modified"> 861       gssize       len,</span>
<span class="line-modified"> 862       gsize       *bytes_read,</span>
<span class="line-modified"> 863       gsize       *bytes_written,</span>
<span class="line-modified"> 864       GError     **error)</span>
 865 {
 866   gsize real_len;
 867   const gchar *end_valid;
 868 
 869   if (!g_utf8_validate (string, len, &amp;end_valid))
 870     {
 871       if (bytes_read)
<span class="line-modified"> 872   *bytes_read = end_valid - string;</span>
 873       if (bytes_written)
<span class="line-modified"> 874   *bytes_written = 0;</span>
 875 
 876       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
 877                            _(&quot;Invalid byte sequence in conversion input&quot;));
 878       return NULL;
 879     }
 880 
 881   real_len = end_valid - string;
 882 
 883   if (bytes_read)
 884     *bytes_read = real_len;
 885   if (bytes_written)
 886     *bytes_written = real_len;
 887 
 888   return g_strndup (string, real_len);
 889 }
 890 
 891 typedef enum
 892 {
 893   CONVERT_CHECK_NO_NULS_IN_INPUT  = 1 &lt;&lt; 0,
 894   CONVERT_CHECK_NO_NULS_IN_OUTPUT = 1 &lt;&lt; 1
</pre>
<hr />
<pre>
 982  *                 buffer (not including the terminating nul).
 983  * @error:         location to store the error occurring, or %NULL to ignore
 984  *                 errors. Any of the errors in #GConvertError may occur.
 985  *
 986  * Converts a string which is in the encoding used for strings by
 987  * the C runtime (usually the same as that used by the operating
 988  * system) in the [current locale][setlocale] into a UTF-8 string.
 989  *
 990  * If the source encoding is not UTF-8 and the conversion output contains a
 991  * nul character, the error %G_CONVERT_ERROR_EMBEDDED_NUL is set and the
 992  * function returns %NULL.
 993  * If the source encoding is UTF-8, an embedded nul character is treated with
 994  * the %G_CONVERT_ERROR_ILLEGAL_SEQUENCE error for backward compatibility with
 995  * earlier versions of this library. Use g_convert() to produce output that
 996  * may contain embedded nul characters.
 997  *
 998  * Returns: (type utf8): The converted string, or %NULL on an error.
 999  **/
1000 gchar *
1001 g_locale_to_utf8 (const gchar  *opsysstring,
<span class="line-modified">1002       gssize        len,</span>
<span class="line-modified">1003       gsize        *bytes_read,</span>
<span class="line-modified">1004       gsize        *bytes_written,</span>
<span class="line-modified">1005       GError      **error)</span>
1006 {
1007   const char *charset;
1008 
1009   if (g_get_charset (&amp;charset))
1010     return strdup_len (opsysstring, len, bytes_read, bytes_written, error);
1011   else
1012     return convert_checked (opsysstring, len, &quot;UTF-8&quot;, charset,
1013                             CONVERT_CHECK_NO_NULS_IN_OUTPUT,
1014                             bytes_read, bytes_written, error);
1015 }
1016 
1017 /**
1018  * g_locale_from_utf8:
1019  * @utf8string:    a UTF-8 encoded string
1020  * @len:           the length of the string, or -1 if the string is
1021  *                 nul-terminated.
1022  * @bytes_read: (out) (optional): location to store the number of bytes in the
1023  *                 input string that were successfully converted, or %NULL.
1024  *                 Even if the conversion was successful, this may be
1025  *                 less than @len if there were partial characters
</pre>
<hr />
<pre>
1031  *                 buffer (not including the terminating nul).
1032  * @error:         location to store the error occurring, or %NULL to ignore
1033  *                 errors. Any of the errors in #GConvertError may occur.
1034  *
1035  * Converts a string from UTF-8 to the encoding used for strings by
1036  * the C runtime (usually the same as that used by the operating
1037  * system) in the [current locale][setlocale]. On Windows this means
1038  * the system codepage.
1039  *
1040  * The input string shall not contain nul characters even if the @len
1041  * argument is positive. A nul character found inside the string will result
1042  * in error %G_CONVERT_ERROR_ILLEGAL_SEQUENCE. Use g_convert() to convert
1043  * input that may contain embedded nul characters.
1044  *
1045  * Returns: (array length=bytes_written) (element-type guint8) (transfer full):
1046  *          A newly-allocated buffer containing the converted string,
1047  *          or %NULL on an error, and error will be set.
1048  **/
1049 gchar *
1050 g_locale_from_utf8 (const gchar *utf8string,
<span class="line-modified">1051         gssize       len,</span>
<span class="line-modified">1052         gsize       *bytes_read,</span>
<span class="line-modified">1053         gsize       *bytes_written,</span>
<span class="line-modified">1054         GError     **error)</span>
1055 {
1056   const gchar *charset;
1057 
1058   if (g_get_charset (&amp;charset))
1059     return strdup_len (utf8string, len, bytes_read, bytes_written, error);
1060   else
1061     return convert_checked (utf8string, len, charset, &quot;UTF-8&quot;,
1062                             CONVERT_CHECK_NO_NULS_IN_INPUT,
1063                             bytes_read, bytes_written, error);
1064 }
1065 
1066 #ifndef G_PLATFORM_WIN32
1067 
1068 typedef struct _GFilenameCharsetCache GFilenameCharsetCache;
1069 
1070 struct _GFilenameCharsetCache {
1071   gboolean is_utf8;
1072   gchar *charset;
1073   gchar **filename_charsets;
1074 };
</pre>
<hr />
<pre>
1107  * is also put in the list of encodings.
1108  *
1109  * The returned @charsets belong to GLib and must not be freed.
1110  *
1111  * Note that on Unix, regardless of the locale character set or
1112  * `G_FILENAME_ENCODING` value, the actual file names present
1113  * on a system might be in any random encoding or just gibberish.
1114  *
1115  * Returns: %TRUE if the filename encoding is UTF-8.
1116  *
1117  * Since: 2.6
1118  */
1119 gboolean
1120 g_get_filename_charsets (const gchar ***filename_charsets)
1121 {
1122   static GPrivate cache_private = G_PRIVATE_INIT (filename_charset_cache_free);
1123   GFilenameCharsetCache *cache = g_private_get (&amp;cache_private);
1124   const gchar *charset;
1125 
1126   if (!cache)
<span class="line-modified">1127     cache = g_private_set_alloc0 (&amp;cache_private, sizeof (GFilenameCharsetCache));</span>



1128 
1129   g_get_charset (&amp;charset);
1130 
1131   if (!(cache-&gt;charset &amp;&amp; strcmp (cache-&gt;charset, charset) == 0))
1132     {
1133       const gchar *new_charset;
1134       gchar *p;
1135       gint i;
1136 
1137       g_free (cache-&gt;charset);
1138       g_strfreev (cache-&gt;filename_charsets);
1139       cache-&gt;charset = g_strdup (charset);
1140 
1141       p = getenv (&quot;G_FILENAME_ENCODING&quot;);
1142       if (p != NULL &amp;&amp; p[0] != &#39;\0&#39;)
<span class="line-modified">1143   {</span>
<span class="line-modified">1144     cache-&gt;filename_charsets = g_strsplit (p, &quot;,&quot;, 0);</span>
<span class="line-modified">1145     cache-&gt;is_utf8 = (strcmp (cache-&gt;filename_charsets[0], &quot;UTF-8&quot;) == 0);</span>
1146 
<span class="line-modified">1147     for (i = 0; cache-&gt;filename_charsets[i]; i++)</span>
<span class="line-modified">1148       {</span>
<span class="line-modified">1149         if (strcmp (&quot;@locale&quot;, cache-&gt;filename_charsets[i]) == 0)</span>








1150     {
<span class="line-modified">1151       g_get_charset (&amp;new_charset);</span>
<span class="line-modified">1152       g_free (cache-&gt;filename_charsets[i]);</span>
<span class="line-modified">1153       cache-&gt;filename_charsets[i] = g_strdup (new_charset);</span>
1154     }
<span class="line-added">1155       }</span>
<span class="line-added">1156   }</span>
<span class="line-added">1157       else if (getenv (&quot;G_BROKEN_FILENAMES&quot;) != NULL)</span>
<span class="line-added">1158   {</span>
<span class="line-added">1159     cache-&gt;filename_charsets = g_new0 (gchar *, 2);</span>
<span class="line-added">1160     cache-&gt;is_utf8 = g_get_charset (&amp;new_charset);</span>
<span class="line-added">1161     cache-&gt;filename_charsets[0] = g_strdup (new_charset);</span>
<span class="line-added">1162   }</span>
1163       else
<span class="line-modified">1164   {</span>
<span class="line-modified">1165     cache-&gt;filename_charsets = g_new0 (gchar *, 3);</span>
<span class="line-modified">1166     cache-&gt;is_utf8 = TRUE;</span>
<span class="line-modified">1167     cache-&gt;filename_charsets[0] = g_strdup (&quot;UTF-8&quot;);</span>
<span class="line-modified">1168     if (!g_get_charset (&amp;new_charset))</span>
<span class="line-modified">1169       cache-&gt;filename_charsets[1] = g_strdup (new_charset);</span>
<span class="line-modified">1170   }</span>
1171     }
1172 
1173   if (filename_charsets)
1174     *filename_charsets = (const gchar **)cache-&gt;filename_charsets;
1175 
1176   return cache-&gt;is_utf8;
1177 }
1178 
1179 #else /* G_PLATFORM_WIN32 */
1180 
1181 gboolean
1182 g_get_filename_charsets (const gchar ***filename_charsets)
1183 {
1184   static const gchar *charsets[] = {
1185     &quot;UTF-8&quot;,
1186     NULL
1187   };
1188 
1189 #ifdef G_OS_WIN32
1190   /* On Windows GLib pretends that the filename charset is UTF-8 */
</pre>
<hr />
<pre>
1241  * @error:         location to store the error occurring, or %NULL to ignore
1242  *                 errors. Any of the errors in #GConvertError may occur.
1243  *
1244  * Converts a string which is in the encoding used by GLib for
1245  * filenames into a UTF-8 string. Note that on Windows GLib uses UTF-8
1246  * for filenames; on other platforms, this function indirectly depends on
1247  * the [current locale][setlocale].
1248  *
1249  * The input string shall not contain nul characters even if the @len
1250  * argument is positive. A nul character found inside the string will result
1251  * in error %G_CONVERT_ERROR_ILLEGAL_SEQUENCE.
1252  * If the source encoding is not UTF-8 and the conversion output contains a
1253  * nul character, the error %G_CONVERT_ERROR_EMBEDDED_NUL is set and the
1254  * function returns %NULL. Use g_convert() to produce output that
1255  * may contain embedded nul characters.
1256  *
1257  * Returns: (type utf8): The converted string, or %NULL on an error.
1258  **/
1259 gchar*
1260 g_filename_to_utf8 (const gchar *opsysstring,
<span class="line-modified">1261         gssize       len,</span>
<span class="line-modified">1262         gsize       *bytes_read,</span>
<span class="line-modified">1263         gsize       *bytes_written,</span>
<span class="line-modified">1264         GError     **error)</span>
1265 {
1266   const gchar *charset;
1267 
1268   g_return_val_if_fail (opsysstring != NULL, NULL);
1269 
1270   if (get_filename_charset (&amp;charset))
1271     return strdup_len (opsysstring, len, bytes_read, bytes_written, error);
1272   else
1273     return convert_checked (opsysstring, len, &quot;UTF-8&quot;, charset,
1274                             CONVERT_CHECK_NO_NULS_IN_INPUT |
1275                             CONVERT_CHECK_NO_NULS_IN_OUTPUT,
1276                             bytes_read, bytes_written, error);
1277 }
1278 
1279 /**
1280  * g_filename_from_utf8:
1281  * @utf8string:    (type utf8): a UTF-8 encoded string.
1282  * @len:           the length of the string, or -1 if the string is
1283  *                 nul-terminated.
1284  * @bytes_read:    (out) (optional): location to store the number of bytes in
</pre>
<hr />
<pre>
1293  *                 the output buffer (not including the terminating nul).
1294  * @error:         location to store the error occurring, or %NULL to ignore
1295  *                 errors. Any of the errors in #GConvertError may occur.
1296  *
1297  * Converts a string from UTF-8 to the encoding GLib uses for
1298  * filenames. Note that on Windows GLib uses UTF-8 for filenames;
1299  * on other platforms, this function indirectly depends on the
1300  * [current locale][setlocale].
1301  *
1302  * The input string shall not contain nul characters even if the @len
1303  * argument is positive. A nul character found inside the string will result
1304  * in error %G_CONVERT_ERROR_ILLEGAL_SEQUENCE. If the filename encoding is
1305  * not UTF-8 and the conversion output contains a nul character, the error
1306  * %G_CONVERT_ERROR_EMBEDDED_NUL is set and the function returns %NULL.
1307  *
1308  * Returns: (type filename):
1309  *               The converted string, or %NULL on an error.
1310  **/
1311 gchar*
1312 g_filename_from_utf8 (const gchar *utf8string,
<span class="line-modified">1313           gssize       len,</span>
<span class="line-modified">1314           gsize       *bytes_read,</span>
<span class="line-modified">1315           gsize       *bytes_written,</span>
<span class="line-modified">1316           GError     **error)</span>
1317 {
1318   const gchar *charset;
1319 
1320   if (get_filename_charset (&amp;charset))
1321     return strdup_len (utf8string, len, bytes_read, bytes_written, error);
1322   else
1323     return convert_checked (utf8string, len, charset, &quot;UTF-8&quot;,
1324                             CONVERT_CHECK_NO_NULS_IN_INPUT |
1325                             CONVERT_CHECK_NO_NULS_IN_OUTPUT,
1326                             bytes_read, bytes_written, error);
1327 }
1328 
1329 /* Test of haystack has the needle prefix, comparing case
1330  * insensitive. haystack may be UTF-8, but needle must
1331  * contain only ascii. */
1332 static gboolean
1333 has_case_prefix (const gchar *haystack, const gchar *needle)
1334 {
1335   const gchar *h, *n;
1336 
1337   /* Eat one character at a time. */
1338   h = haystack;
1339   n = needle;
1340 
1341   while (*n &amp;&amp; *h &amp;&amp;
<span class="line-modified">1342    g_ascii_tolower (*n) == g_ascii_tolower (*h))</span>
1343     {
1344       n++;
1345       h++;
1346     }
1347 
1348   return *n == &#39;\0&#39;;
1349 }
1350 
1351 typedef enum {
1352   UNSAFE_ALL        = 0x1,  /* Escape all unsafe characters   */
1353   UNSAFE_ALLOW_PLUS = 0x2,  /* Allows &#39;+&#39;  */
1354   UNSAFE_PATH       = 0x8,  /* Allows &#39;/&#39;, &#39;&amp;&#39;, &#39;=&#39;, &#39;:&#39;, &#39;@&#39;, &#39;+&#39;, &#39;$&#39; and &#39;,&#39; */
1355   UNSAFE_HOST       = 0x10, /* Allows &#39;/&#39; and &#39;:&#39; and &#39;@&#39; */
1356   UNSAFE_SLASHES    = 0x20  /* Allows all characters except for &#39;/&#39; and &#39;%&#39; */
1357 } UnsafeCharacterSet;
1358 
1359 static const guchar acceptable[96] = {
1360   /* A table of the ASCII chars from space (32) to DEL (127) */
1361   /*      !    &quot;    #    $    %    &amp;    &#39;    (    )    *    +    ,    -    .    / */
1362   0x00,0x3F,0x20,0x20,0x28,0x00,0x2C,0x3F,0x3F,0x3F,0x3F,0x2A,0x28,0x3F,0x3F,0x1C,
1363   /* 0    1    2    3    4    5    6    7    8    9    :    ;    &lt;    =    &gt;    ? */
1364   0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x38,0x20,0x20,0x2C,0x20,0x20,
1365   /* @    A    B    C    D    E    F    G    H    I    J    K    L    M    N    O */
1366   0x38,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
1367   /* P    Q    R    S    T    U    V    W    X    Y    Z    [    \    ]    ^    _ */
1368   0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x20,0x20,0x20,0x20,0x3F,
1369   /* `    a    b    c    d    e    f    g    h    i    j    k    l    m    n    o */
1370   0x20,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
1371   /* p    q    r    s    t    u    v    w    x    y    z    {    |    }    ~  DEL */
1372   0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x20,0x20,0x20,0x3F,0x20
1373 };
1374 
1375 static const gchar hex[16] = &quot;0123456789ABCDEF&quot;;
1376 
1377 /* Note: This escape function works on file: URIs, but if you want to
1378  * escape something else, please read RFC-2396 */
1379 static gchar *
1380 g_escape_uri_string (const gchar *string,
<span class="line-modified">1381          UnsafeCharacterSet mask)</span>
1382 {
1383 #define ACCEPTABLE(a) ((a)&gt;=32 &amp;&amp; (a)&lt;128 &amp;&amp; (acceptable[(a)-32] &amp; use_mask))
1384 
1385   const gchar *p;
1386   gchar *q;
1387   gchar *result;
1388   int c;
1389   gint unacceptable;
1390   UnsafeCharacterSet use_mask;
1391 
1392   g_return_val_if_fail (mask == UNSAFE_ALL
<span class="line-modified">1393       || mask == UNSAFE_ALLOW_PLUS</span>
<span class="line-modified">1394       || mask == UNSAFE_PATH</span>
<span class="line-modified">1395       || mask == UNSAFE_HOST</span>
<span class="line-modified">1396       || mask == UNSAFE_SLASHES, NULL);</span>
1397 
1398   unacceptable = 0;
1399   use_mask = mask;
1400   for (p = string; *p != &#39;\0&#39;; p++)
1401     {
1402       c = (guchar) *p;
1403       if (!ACCEPTABLE (c))
<span class="line-modified">1404   unacceptable++;</span>
1405     }
1406 
1407   result = g_malloc (p - string + unacceptable * 2 + 1);
1408 
1409   use_mask = mask;
1410   for (q = result, p = string; *p != &#39;\0&#39;; p++)
1411     {
1412       c = (guchar) *p;
1413 
1414       if (!ACCEPTABLE (c))
<span class="line-modified">1415   {</span>
<span class="line-modified">1416     *q++ = &#39;%&#39;; /* means hex coming */</span>
<span class="line-modified">1417     *q++ = hex[c &gt;&gt; 4];</span>
<span class="line-modified">1418     *q++ = hex[c &amp; 15];</span>
<span class="line-modified">1419   }</span>
1420       else
<span class="line-modified">1421   *q++ = *p;</span>
1422     }
1423 
1424   *q = &#39;\0&#39;;
1425 
1426   return result;
1427 }
1428 
1429 
1430 static gchar *
1431 g_escape_file_uri (const gchar *hostname,
<span class="line-modified">1432        const gchar *pathname)</span>
1433 {
1434   char *escaped_hostname = NULL;
1435   char *escaped_path;
1436   char *res;
1437 
1438 #ifdef G_OS_WIN32
1439   char *p, *backslash;
1440 
1441   /* Turn backslashes into forward slashes. That&#39;s what Netscape
1442    * does, and they are actually more or less equivalent in Windows.
1443    */
1444 
1445   pathname = g_strdup (pathname);
1446   p = (char *) pathname;
1447 
1448   while ((backslash = strchr (p, &#39;\\&#39;)) != NULL)
1449     {
1450       *backslash = &#39;/&#39;;
1451       p = backslash + 1;
1452     }
1453 #endif
1454 
1455   if (hostname &amp;&amp; *hostname != &#39;\0&#39;)
1456     {
1457       escaped_hostname = g_escape_uri_string (hostname, UNSAFE_HOST);
1458     }
1459 
1460   escaped_path = g_escape_uri_string (pathname, UNSAFE_PATH);
1461 
1462   res = g_strconcat (&quot;file://&quot;,
<span class="line-modified">1463          (escaped_hostname) ? escaped_hostname : &quot;&quot;,</span>
<span class="line-modified">1464          (*escaped_path != &#39;/&#39;) ? &quot;/&quot; : &quot;&quot;,</span>
<span class="line-modified">1465          escaped_path,</span>
<span class="line-modified">1466          NULL);</span>
1467 
1468 #ifdef G_OS_WIN32
1469   g_free ((char *) pathname);
1470 #endif
1471 
1472   g_free (escaped_hostname);
1473   g_free (escaped_path);
1474 
1475   return res;
1476 }
1477 
1478 static int
1479 unescape_character (const char *scanner)
1480 {
1481   int first_digit;
1482   int second_digit;
1483 
1484   first_digit = g_ascii_xdigit_value (scanner[0]);
1485   if (first_digit &lt; 0)
1486     return -1;
1487 
1488   second_digit = g_ascii_xdigit_value (scanner[1]);
1489   if (second_digit &lt; 0)
1490     return -1;
1491 
1492   return (first_digit &lt;&lt; 4) | second_digit;
1493 }
1494 
1495 static gchar *
1496 g_unescape_uri_string (const char *escaped,
<span class="line-modified">1497            int         len,</span>
<span class="line-modified">1498            const char *illegal_escaped_characters,</span>
<span class="line-modified">1499            gboolean    ascii_must_not_be_escaped)</span>
1500 {
1501   const gchar *in, *in_end;
1502   gchar *out, *result;
1503   int c;
1504 
1505   if (escaped == NULL)
1506     return NULL;
1507 
1508   if (len &lt; 0)
1509     len = strlen (escaped);
1510 
1511   result = g_malloc (len + 1);
1512 
1513   out = result;
1514   for (in = escaped, in_end = escaped + len; in &lt; in_end; in++)
1515     {
1516       c = *in;
1517 
1518       if (c == &#39;%&#39;)
<span class="line-modified">1519   {</span>
<span class="line-modified">1520     /* catch partial escape sequences past the end of the substring */</span>
<span class="line-modified">1521     if (in + 3 &gt; in_end)</span>
<span class="line-modified">1522       break;</span>
1523 
<span class="line-modified">1524     c = unescape_character (in + 1);</span>
1525 
<span class="line-modified">1526     /* catch bad escape sequences and NUL characters */</span>
<span class="line-modified">1527     if (c &lt;= 0)</span>
<span class="line-modified">1528       break;</span>
1529 
<span class="line-modified">1530     /* catch escaped ASCII */</span>
<span class="line-modified">1531     if (ascii_must_not_be_escaped &amp;&amp; c &lt;= 0x7F)</span>
<span class="line-modified">1532       break;</span>
1533 
<span class="line-modified">1534     /* catch other illegal escaped characters */</span>
<span class="line-modified">1535     if (strchr (illegal_escaped_characters, c) != NULL)</span>
<span class="line-modified">1536       break;</span>
1537 
<span class="line-modified">1538     in += 2;</span>
<span class="line-modified">1539   }</span>
1540 
1541       *out++ = c;
1542     }
1543 
1544   g_assert (out - result &lt;= len);
1545   *out = &#39;\0&#39;;
1546 
1547   if (in != in_end)
1548     {
1549       g_free (result);
1550       return NULL;
1551     }
1552 
1553   return result;
1554 }
1555 
1556 static gboolean
1557 is_asciialphanum (gunichar c)
1558 {
1559   return c &lt;= 0x7F &amp;&amp; g_ascii_isalnum (c);
</pre>
<hr />
<pre>
1564 {
1565   return c &lt;= 0x7F &amp;&amp; g_ascii_isalpha (c);
1566 }
1567 
1568 /* allows an empty string */
1569 static gboolean
1570 hostname_validate (const char *hostname)
1571 {
1572   const char *p;
1573   gunichar c, first_char, last_char;
1574 
1575   p = hostname;
1576   if (*p == &#39;\0&#39;)
1577     return TRUE;
1578   do
1579     {
1580       /* read in a label */
1581       c = g_utf8_get_char (p);
1582       p = g_utf8_next_char (p);
1583       if (!is_asciialphanum (c))
<span class="line-modified">1584   return FALSE;</span>
1585       first_char = c;
1586       do
<span class="line-modified">1587   {</span>
<span class="line-modified">1588     last_char = c;</span>
<span class="line-modified">1589     c = g_utf8_get_char (p);</span>
<span class="line-modified">1590     p = g_utf8_next_char (p);</span>
<span class="line-modified">1591   }</span>
1592       while (is_asciialphanum (c) || c == &#39;-&#39;);
1593       if (last_char == &#39;-&#39;)
<span class="line-modified">1594   return FALSE;</span>
1595 
1596       /* if that was the last label, check that it was a toplabel */
1597       if (c == &#39;\0&#39; || (c == &#39;.&#39; &amp;&amp; *p == &#39;\0&#39;))
<span class="line-modified">1598   return is_asciialpha (first_char);</span>
1599     }
1600   while (c == &#39;.&#39;);
1601   return FALSE;
1602 }
1603 
1604 /**
1605  * g_filename_from_uri:
1606  * @uri: a uri describing a filename (escaped, encoded in ASCII).
1607  * @hostname: (out) (optional) (nullable): Location to store hostname for the URI.
1608  *            If there is no hostname in the URI, %NULL will be
1609  *            stored in this location.
1610  * @error: location to store the error occurring, or %NULL to ignore
1611  *         errors. Any of the errors in #GConvertError may occur.
1612  *
1613  * Converts an escaped ASCII-encoded URI to a local filename in the
1614  * encoding used for filenames.
1615  *
1616  * Returns: (type filename): a newly-allocated string holding
1617  *               the resulting filename, or %NULL on an error.
1618  **/
1619 gchar *
1620 g_filename_from_uri (const gchar *uri,
<span class="line-modified">1621          gchar      **hostname,</span>
<span class="line-modified">1622          GError     **error)</span>
1623 {
1624   const char *path_part;
1625   const char *host_part;
1626   char *unescaped_hostname;
1627   char *result;
1628   char *filename;
1629   int offs;
1630 #ifdef G_OS_WIN32
1631   char *p, *slash;
1632 #endif
1633 
1634   if (hostname)
1635     *hostname = NULL;
1636 
1637   if (!has_case_prefix (uri, &quot;file:/&quot;))
1638     {
1639       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,
<span class="line-modified">1640        _(&quot;The URI &#39;%s&#39; is not an absolute URI using the &#39;file&#39; scheme&quot;),</span>
<span class="line-modified">1641        uri);</span>
1642       return NULL;
1643     }
1644 
1645   path_part = uri + strlen (&quot;file:&quot;);
1646 
1647   if (strchr (path_part, &#39;#&#39;) != NULL)
1648     {
1649       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,
<span class="line-modified">1650        _(&quot;The local file URI &#39;%s&#39; may not include a &#39;#&#39;&quot;),</span>
<span class="line-modified">1651        uri);</span>
1652       return NULL;
1653     }
1654 
1655   if (has_case_prefix (path_part, &quot;///&quot;))
1656     path_part += 2;
1657   else if (has_case_prefix (path_part, &quot;//&quot;))
1658     {
1659       path_part += 2;
1660       host_part = path_part;
1661 
1662       path_part = strchr (path_part, &#39;/&#39;);
1663 
1664       if (path_part == NULL)
<span class="line-modified">1665   {</span>
<span class="line-modified">1666     g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,</span>
<span class="line-modified">1667            _(&quot;The URI &#39;%s&#39; is invalid&quot;),</span>
<span class="line-modified">1668            uri);</span>
<span class="line-modified">1669     return NULL;</span>
<span class="line-modified">1670   }</span>
1671 
1672       unescaped_hostname = g_unescape_uri_string (host_part, path_part - host_part, &quot;&quot;, TRUE);
1673 
1674       if (unescaped_hostname == NULL ||
<span class="line-modified">1675     !hostname_validate (unescaped_hostname))</span>
<span class="line-modified">1676   {</span>
<span class="line-modified">1677     g_free (unescaped_hostname);</span>
<span class="line-modified">1678     g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,</span>
<span class="line-modified">1679            _(&quot;The hostname of the URI &#39;%s&#39; is invalid&quot;),</span>
<span class="line-modified">1680            uri);</span>
<span class="line-modified">1681     return NULL;</span>
<span class="line-modified">1682   }</span>
1683 
1684       if (hostname)
<span class="line-modified">1685   *hostname = unescaped_hostname;</span>
1686       else
<span class="line-modified">1687   g_free (unescaped_hostname);</span>
1688     }
1689 
1690   filename = g_unescape_uri_string (path_part, -1, &quot;/&quot;, FALSE);
1691 
1692   if (filename == NULL)
1693     {
1694       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,
<span class="line-modified">1695        _(&quot;The URI &#39;%s&#39; contains invalidly escaped characters&quot;),</span>
<span class="line-modified">1696        uri);</span>
1697       return NULL;
1698     }
1699 
1700   offs = 0;
1701 #ifdef G_OS_WIN32
1702   /* Drop localhost */
1703   if (hostname &amp;&amp; *hostname != NULL &amp;&amp;
1704       g_ascii_strcasecmp (*hostname, &quot;localhost&quot;) == 0)
1705     {
1706       g_free (*hostname);
1707       *hostname = NULL;
1708     }
1709 
1710   /* Turn slashes into backslashes, because that&#39;s the canonical spelling */
1711   p = filename;
1712   while ((slash = strchr (p, &#39;/&#39;)) != NULL)
1713     {
1714       *slash = &#39;\\&#39;;
1715       p = slash + 1;
1716     }
1717 
1718   /* Windows URIs with a drive letter can be like &quot;file://host/c:/foo&quot;
1719    * or &quot;file://host/c|/foo&quot; (some Netscape versions). In those cases, start
1720    * the filename from the drive letter.
1721    */
1722   if (g_ascii_isalpha (filename[1]))
1723     {
1724       if (filename[2] == &#39;:&#39;)
<span class="line-modified">1725   offs = 1;</span>
1726       else if (filename[2] == &#39;|&#39;)
<span class="line-modified">1727   {</span>
<span class="line-modified">1728     filename[2] = &#39;:&#39;;</span>
<span class="line-modified">1729     offs = 1;</span>
<span class="line-modified">1730   }</span>
1731     }
1732 #endif
1733 
1734   result = g_strdup (filename + offs);
1735   g_free (filename);
1736 
1737   return result;
1738 }
1739 
1740 /**
1741  * g_filename_to_uri:
1742  * @filename: (type filename): an absolute filename specified in the GLib file
1743  *     name encoding, which is the on-disk file name bytes on Unix, and UTF-8
1744  *     on Windows
1745  * @hostname: (nullable): A UTF-8 encoded hostname, or %NULL for none.
1746  * @error: location to store the error occurring, or %NULL to ignore
1747  *         errors. Any of the errors in #GConvertError may occur.
1748  *
1749  * Converts an absolute filename to an escaped ASCII-encoded URI, with the path
1750  * component following Section 3.3. of RFC 2396.
1751  *
1752  * Returns: a newly-allocated string holding the resulting
1753  *               URI, or %NULL on an error.
1754  **/
1755 gchar *
1756 g_filename_to_uri (const gchar *filename,
<span class="line-modified">1757        const gchar *hostname,</span>
<span class="line-modified">1758        GError     **error)</span>
1759 {
1760   char *escaped_uri;
1761 
1762   g_return_val_if_fail (filename != NULL, NULL);
1763 
1764   if (!g_path_is_absolute (filename))
1765     {
1766       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_NOT_ABSOLUTE_PATH,
<span class="line-modified">1767        _(&quot;The pathname &#39;%s&#39; is not an absolute path&quot;),</span>
<span class="line-modified">1768        filename);</span>
1769       return NULL;
1770     }
1771 
1772   if (hostname &amp;&amp;
1773       !(g_utf8_validate (hostname, -1, NULL)
<span class="line-modified">1774   &amp;&amp; hostname_validate (hostname)))</span>
1775     {
1776       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
1777                            _(&quot;Invalid hostname&quot;));
1778       return NULL;
1779     }
1780 
1781 #ifdef G_OS_WIN32
1782   /* Don&#39;t use localhost unnecessarily */
1783   if (hostname &amp;&amp; g_ascii_strcasecmp (hostname, &quot;localhost&quot;) == 0)
1784     hostname = NULL;
1785 #endif
1786 
1787   escaped_uri = g_escape_file_uri (hostname, filename);
1788 
1789   return escaped_uri;
1790 }
1791 
1792 /**
1793  * g_uri_list_extract_uris:
1794  * @uri_list: an URI list
</pre>
<hr />
<pre>
1808 {
1809   GSList *uris, *u;
1810   const gchar *p, *q;
1811   gchar **result;
1812   gint n_uris = 0;
1813 
1814   uris = NULL;
1815 
1816   p = uri_list;
1817 
1818   /* We don&#39;t actually try to validate the URI according to RFC
1819    * 2396, or even check for allowed characters - we just ignore
1820    * comments and trim whitespace off the ends.  We also
1821    * allow LF delimination as well as the specified CRLF.
1822    *
1823    * We do allow comments like specified in RFC 2483.
1824    */
1825   while (p)
1826     {
1827       if (*p != &#39;#&#39;)
<span class="line-modified">1828   {</span>
<span class="line-modified">1829     while (g_ascii_isspace (*p))</span>
<span class="line-modified">1830       p++;</span>
1831 
<span class="line-modified">1832     q = p;</span>
<span class="line-modified">1833     while (*q &amp;&amp; (*q != &#39;\n&#39;) &amp;&amp; (*q != &#39;\r&#39;))</span>
<span class="line-modified">1834       q++;</span>
1835 
<span class="line-modified">1836     if (q &gt; p)</span>
<span class="line-modified">1837       {</span>


1838         q--;
<span class="line-added">1839         while (q &gt; p &amp;&amp; g_ascii_isspace (*q))</span>
<span class="line-added">1840     q--;</span>
1841 
<span class="line-modified">1842         if (q &gt; p)</span>
<span class="line-modified">1843     {</span>
<span class="line-modified">1844       uris = g_slist_prepend (uris, g_strndup (p, q - p + 1));</span>
<span class="line-modified">1845       n_uris++;</span>


1846     }
<span class="line-added">1847       }</span>
<span class="line-added">1848   }</span>
1849       p = strchr (p, &#39;\n&#39;);
1850       if (p)
<span class="line-modified">1851   p++;</span>
1852     }
1853 
1854   result = g_new (gchar *, n_uris + 1);
1855 
1856   result[n_uris--] = NULL;
1857   for (u = uris; u; u = u-&gt;next)
1858     result[n_uris--] = u-&gt;data;
1859 
1860   g_slist_free (uris);
1861 
1862   return result;
1863 }
1864 
1865 /**
1866  * g_filename_display_basename:
1867  * @filename: (type filename): an absolute pathname in the
1868  *     GLib file name encoding
1869  *
1870  * Returns the display basename for the particular filename, guaranteed
1871  * to be valid UTF-8. The display name might not be identical to the filename,
</pre>
<hr />
<pre>
1925  * translation of filenames.
1926  *
1927  * Returns: a newly allocated string containing
1928  *   a rendition of the filename in valid UTF-8
1929  *
1930  * Since: 2.6
1931  **/
1932 gchar *
1933 g_filename_display_name (const gchar *filename)
1934 {
1935   gint i;
1936   const gchar **charsets;
1937   gchar *display_name = NULL;
1938   gboolean is_utf8;
1939 
1940   is_utf8 = g_get_filename_charsets (&amp;charsets);
1941 
1942   if (is_utf8)
1943     {
1944       if (g_utf8_validate (filename, -1, NULL))
<span class="line-modified">1945   display_name = g_strdup (filename);</span>
1946     }
1947 
1948   if (!display_name)
1949     {
1950       /* Try to convert from the filename charsets to UTF-8.
1951        * Skip the first charset if it is UTF-8.
1952        */
1953       for (i = is_utf8 ? 1 : 0; charsets[i]; i++)
<span class="line-modified">1954   {</span>
<span class="line-modified">1955     display_name = g_convert (filename, -1, &quot;UTF-8&quot;, charsets[i],</span>
<span class="line-modified">1956             NULL, NULL, NULL);</span>
1957 
<span class="line-modified">1958     if (display_name)</span>
<span class="line-modified">1959       break;</span>
<span class="line-modified">1960   }</span>
1961     }
1962 
1963   /* if all conversions failed, we replace invalid UTF-8
1964    * by a question mark
1965    */
1966   if (!display_name)
1967     display_name = g_utf8_make_valid (filename, -1);
1968 
1969   return display_name;
1970 }
1971 
1972 #ifdef G_OS_WIN32
1973 
1974 /* Binary compatibility versions. Not for newly compiled code. */
1975 
1976 _GLIB_EXTERN gchar *g_filename_to_utf8_utf8   (const gchar  *opsysstring,
1977                                                gssize        len,
1978                                                gsize        *bytes_read,
1979                                                gsize        *bytes_written,
1980                                                GError      **error) G_GNUC_MALLOC;
</pre>
</td>
</tr>
</table>
<center><a href="gconstructor.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gconvert.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>