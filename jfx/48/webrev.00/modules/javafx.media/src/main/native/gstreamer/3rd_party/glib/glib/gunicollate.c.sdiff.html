<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gunicollate.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gunicodeprivate.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gunidecomp.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gunicollate.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  3  *  Copyright 2001,2005 Red Hat, Inc.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Lesser General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2.1 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Lesser General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Lesser General Public License
 16  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 17  */
 18 
 19 #include &quot;config.h&quot;
 20 
 21 #include &lt;locale.h&gt;
 22 #include &lt;string.h&gt;
<span class="line-modified"> 23 #ifdef __STDC_ISO_10646__</span>
 24 #include &lt;wchar.h&gt;
 25 #endif
 26 
 27 #ifdef HAVE_CARBON
 28 #include &lt;CoreServices/CoreServices.h&gt;
 29 #endif
 30 
 31 #include &quot;gmem.h&quot;
 32 #include &quot;gunicode.h&quot;
 33 #include &quot;gunicodeprivate.h&quot;
 34 #include &quot;gstring.h&quot;
 35 #include &quot;gstrfuncs.h&quot;
 36 #include &quot;gtestutils.h&quot;
 37 #include &quot;gcharset.h&quot;
<span class="line-removed"> 38 #ifndef __STDC_ISO_10646__</span>
 39 #include &quot;gconvert.h&quot;
<span class="line-removed"> 40 #endif</span>
 41 



 42 
 43 #ifdef _MSC_VER
 44 /* Workaround for bug in MSVCR80.DLL */
 45 static gsize
 46 msc_strxfrm_wrapper (char       *string1,
<span class="line-modified"> 47              const char *string2,</span>
<span class="line-modified"> 48              gsize       count)</span>
 49 {
 50   if (!string1 || count &lt;= 0)
 51     {
 52       char tmp;
 53 
 54       return strxfrm (&amp;tmp, string2, 1);
 55     }
 56   return strxfrm (string1, string2, count);
 57 }
 58 #define strxfrm msc_strxfrm_wrapper
 59 #endif
 60 
 61 /**
 62  * g_utf8_collate:
 63  * @str1: a UTF-8 encoded string
 64  * @str2: a UTF-8 encoded string
 65  *
 66  * Compares two strings for ordering using the linguistically
 67  * correct rules for the [current locale][setlocale].
 68  * When sorting a large number of strings, it will be significantly
 69  * faster to obtain collation keys with g_utf8_collate_key() and
 70  * compare the keys with strcmp() when sorting instead of sorting
 71  * the original strings.
 72  *
 73  * Returns: &lt; 0 if @str1 compares before @str2,
 74  *   0 if they compare equal, &gt; 0 if @str1 compares after @str2.
 75  **/
 76 gint
 77 g_utf8_collate (const gchar *str1,
<span class="line-modified"> 78         const gchar *str2)</span>
 79 {
 80   gint result;
 81 
 82 #ifdef HAVE_CARBON
 83 
 84   UniChar *str1_utf16;
 85   UniChar *str2_utf16;
 86   glong len1;
 87   glong len2;
 88   SInt32 retval = 0;
 89 
 90   g_return_val_if_fail (str1 != NULL, 0);
 91   g_return_val_if_fail (str2 != NULL, 0);
 92 
 93   str1_utf16 = g_utf8_to_utf16 (str1, -1, NULL, &amp;len1, NULL);
 94   str2_utf16 = g_utf8_to_utf16 (str2, -1, NULL, &amp;len2, NULL);
 95 
 96   UCCompareTextDefault (kUCCollateStandardOptions,
 97                         str1_utf16, len1, str2_utf16, len2,
 98                         NULL, &amp;retval);
 99   result = retval;
100 
101   g_free (str2_utf16);
102   g_free (str1_utf16);
103 
<span class="line-modified">104 #elif defined(__STDC_ISO_10646__)</span>
105 
106   gunichar *str1_norm;
107   gunichar *str2_norm;
108 
109   g_return_val_if_fail (str1 != NULL, 0);
110   g_return_val_if_fail (str2 != NULL, 0);
111 
112   str1_norm = _g_utf8_normalize_wc (str1, -1, G_NORMALIZE_ALL_COMPOSE);
113   str2_norm = _g_utf8_normalize_wc (str2, -1, G_NORMALIZE_ALL_COMPOSE);
114 
115   result = wcscoll ((wchar_t *)str1_norm, (wchar_t *)str2_norm);
116 
117   g_free (str1_norm);
118   g_free (str2_norm);
119 
<span class="line-modified">120 #else /* !__STDC_ISO_10646__ */</span>
121 
122   const gchar *charset;
123   gchar *str1_norm;
124   gchar *str2_norm;
125 
126   g_return_val_if_fail (str1 != NULL, 0);
127   g_return_val_if_fail (str2 != NULL, 0);
128 
129   str1_norm = g_utf8_normalize (str1, -1, G_NORMALIZE_ALL_COMPOSE);
130   str2_norm = g_utf8_normalize (str2, -1, G_NORMALIZE_ALL_COMPOSE);
131 
132   if (g_get_charset (&amp;charset))
133     {
134       result = strcoll (str1_norm, str2_norm);
135     }
136   else
137     {
138       gchar *str1_locale = g_convert (str1_norm, -1, charset, &quot;UTF-8&quot;, NULL, NULL, NULL);
139       gchar *str2_locale = g_convert (str2_norm, -1, charset, &quot;UTF-8&quot;, NULL, NULL, NULL);
140 
141       if (str1_locale &amp;&amp; str2_locale)
<span class="line-modified">142     result =  strcoll (str1_locale, str2_locale);</span>
143       else if (str1_locale)
<span class="line-modified">144     result = -1;</span>
145       else if (str2_locale)
<span class="line-modified">146     result = 1;</span>
147       else
<span class="line-modified">148     result = strcmp (str1_norm, str2_norm);</span>
149 
150       g_free (str1_locale);
151       g_free (str2_locale);
152     }
153 
154   g_free (str1_norm);
155   g_free (str2_norm);
156 
<span class="line-modified">157 #endif /* __STDC_ISO_10646__ */</span>
158 
159   return result;
160 }
161 
<span class="line-modified">162 #if defined(__STDC_ISO_10646__)</span>
163 /* We need UTF-8 encoding of numbers to encode the weights if
164  * we are using wcsxfrm. However, we aren&#39;t encoding Unicode
165  * characters, so we can&#39;t simply use g_unichar_to_utf8.
166  *
167  * The following routine is taken (with modification) from GNU
168  * libc&#39;s strxfrm routine:
169  *
170  * Copyright (C) 1995-1999,2000,2001 Free Software Foundation, Inc.
171  * Written by Ulrich Drepper &lt;drepper@cygnus.com&gt;, 1995.
172  */
173 static inline int
174 utf8_encode (char *buf, wchar_t val)
175 {
176   int retval;
177 
178   if (val &lt; 0x80)
179     {
180       if (buf)
<span class="line-modified">181     *buf++ = (char) val;</span>
182       retval = 1;
183     }
184   else
185     {
186       int step;
187 
188       for (step = 2; step &lt; 6; ++step)
189         if ((val &amp; (~(guint32)0 &lt;&lt; (5 * step + 1))) == 0)
190           break;
191       retval = step;
192 
193       if (buf)
<span class="line-modified">194     {</span>
<span class="line-modified">195       *buf = (unsigned char) (~0xff &gt;&gt; step);</span>
<span class="line-modified">196       --step;</span>
<span class="line-modified">197       do</span>
<span class="line-modified">198         {</span>
<span class="line-modified">199           buf[step] = 0x80 | (val &amp; 0x3f);</span>
<span class="line-modified">200           val &gt;&gt;= 6;</span>
<span class="line-modified">201         }</span>
<span class="line-modified">202       while (--step &gt; 0);</span>
<span class="line-modified">203       *buf |= val;</span>
<span class="line-modified">204     }</span>
205     }
206 
207   return retval;
208 }
<span class="line-modified">209 #endif /* __STDC_ISO_10646__ */</span>
210 
211 #ifdef HAVE_CARBON
212 
213 static gchar *
214 collate_key_to_string (UCCollationValue *key,
215                        gsize             key_len)
216 {
217   gchar *result;
218   gsize result_len;
219   long *lkey = (long *) key;
220 
221   /* UCCollationValue format:
222    *
223    * UCCollateOptions (32/64 bits)
224    * SizeInBytes      (32/64 bits)
225    * Value            (8 bits arrey)
226    *
227    * UCCollateOptions: ordering option mask of the collator
228    * used to create the key. Size changes on 32-bit / 64-bit
229    * hosts. On 64-bits also the extra half-word seems to have
</pre>
<hr />
<pre>
356 /**
357  * g_utf8_collate_key:
358  * @str: a UTF-8 encoded string.
359  * @len: length of @str, in bytes, or -1 if @str is nul-terminated.
360  *
361  * Converts a string into a collation key that can be compared
362  * with other collation keys produced by the same function using
363  * strcmp().
364  *
365  * The results of comparing the collation keys of two strings
366  * with strcmp() will always be the same as comparing the two
367  * original keys with g_utf8_collate().
368  *
369  * Note that this function depends on the [current locale][setlocale].
370  *
371  * Returns: a newly allocated string. This string should
372  *   be freed with g_free() when you are done with it.
373  **/
374 gchar *
375 g_utf8_collate_key (const gchar *str,
<span class="line-modified">376             gssize       len)</span>
377 {
378   gchar *result;
379 
380 #ifdef HAVE_CARBON
381 
382   g_return_val_if_fail (str != NULL, NULL);
383   result = carbon_collate_key (str, len);
384 
<span class="line-modified">385 #elif defined(__STDC_ISO_10646__)</span>
386 
387   gsize xfrm_len;
388   gunichar *str_norm;
389   wchar_t *result_wc;
390   gsize i;
391   gsize result_len = 0;
392 
393   g_return_val_if_fail (str != NULL, NULL);
394 
395   str_norm = _g_utf8_normalize_wc (str, len, G_NORMALIZE_ALL_COMPOSE);
396 
397   xfrm_len = wcsxfrm (NULL, (wchar_t *)str_norm, 0);
398   result_wc = g_new (wchar_t, xfrm_len + 1);
399   wcsxfrm (result_wc, (wchar_t *)str_norm, xfrm_len + 1);
400 
401   for (i = 0; i &lt; xfrm_len; i++)
402     result_len += utf8_encode (NULL, result_wc[i]);
403 
404   result = g_malloc (result_len + 1);
405   result_len = 0;
406   for (i = 0; i &lt; xfrm_len; i++)
407     result_len += utf8_encode (result + result_len, result_wc[i]);
408 
409   result[result_len] = &#39;\0&#39;;
410 
411   g_free (result_wc);
412   g_free (str_norm);
413 
414   return result;
<span class="line-modified">415 #else /* !__STDC_ISO_10646__ */</span>
416 
417   gsize xfrm_len;
418   const gchar *charset;
419   gchar *str_norm;
420 
421   g_return_val_if_fail (str != NULL, NULL);
422 
423   str_norm = g_utf8_normalize (str, len, G_NORMALIZE_ALL_COMPOSE);
424 
425   result = NULL;
426 
427   if (g_get_charset (&amp;charset))
428     {
429       xfrm_len = strxfrm (NULL, str_norm, 0);
430       if (xfrm_len &gt;= 0 &amp;&amp; xfrm_len &lt; G_MAXINT - 2)
431         {
432           result = g_malloc (xfrm_len + 1);
433           strxfrm (result, str_norm, xfrm_len + 1);
434         }
435     }
436   else
437     {
438       gchar *str_locale = g_convert (str_norm, -1, charset, &quot;UTF-8&quot;, NULL, NULL, NULL);
439 
440       if (str_locale)
<span class="line-modified">441     {</span>
<span class="line-modified">442       xfrm_len = strxfrm (NULL, str_locale, 0);</span>
<span class="line-modified">443       if (xfrm_len &lt; 0 || xfrm_len &gt;= G_MAXINT - 2)</span>
<span class="line-modified">444         {</span>
<span class="line-modified">445           g_free (str_locale);</span>
<span class="line-modified">446           str_locale = NULL;</span>
<span class="line-modified">447         }</span>
<span class="line-modified">448     }</span>
449       if (str_locale)
<span class="line-modified">450     {</span>
<span class="line-modified">451       result = g_malloc (xfrm_len + 2);</span>
<span class="line-modified">452       result[0] = &#39;A&#39;;</span>
<span class="line-modified">453       strxfrm (result + 1, str_locale, xfrm_len + 1);</span>
454 
<span class="line-modified">455       g_free (str_locale);</span>
<span class="line-modified">456     }</span>
457     }
458 
459   if (!result)
460     {
461       xfrm_len = strlen (str_norm);
462       result = g_malloc (xfrm_len + 2);
463       result[0] = &#39;B&#39;;
464       memcpy (result + 1, str_norm, xfrm_len);
465       result[xfrm_len+1] = &#39;\0&#39;;
466     }
467 
468   g_free (str_norm);
<span class="line-modified">469 #endif /* __STDC_ISO_10646__ */</span>
470 
471   return result;
472 }
473 
474 /* This is a collation key that is very very likely to sort before any
475  * collation key that libc strxfrm generates. We use this before any
476  * special case (dot or number) to make sure that its sorted before
477  * anything else.
478  */
479 #define COLLATION_SENTINEL &quot;\1\1\1&quot;
480 
481 /**
482  * g_utf8_collate_key_for_filename:
483  * @str: a UTF-8 encoded string.
484  * @len: length of @str, in bytes, or -1 if @str is nul-terminated.
485  *
486  * Converts a string into a collation key that can be compared
487  * with other collation keys produced by the same function using strcmp().
488  *
489  * In order to sort filenames correctly, this function treats the dot &#39;.&#39;
490  * as a special case. Most dictionary orderings seem to consider it
491  * insignificant, thus producing the ordering &quot;event.c&quot; &quot;eventgenerator.c&quot;
492  * &quot;event.h&quot; instead of &quot;event.c&quot; &quot;event.h&quot; &quot;eventgenerator.c&quot;. Also, we
493  * would like to treat numbers intelligently so that &quot;file1&quot; &quot;file10&quot; &quot;file5&quot;
494  * is sorted as &quot;file1&quot; &quot;file5&quot; &quot;file10&quot;.
495  *
496  * Note that this function depends on the [current locale][setlocale].
497  *
498  * Returns: a newly allocated string. This string should
499  *   be freed with g_free() when you are done with it.
500  *
501  * Since: 2.8
502  */
503 gchar *
504 g_utf8_collate_key_for_filename (const gchar *str,
<span class="line-modified">505                  gssize       len)</span>
506 {
507 #ifndef HAVE_CARBON
508   GString *result;
509   GString *append;
510   const gchar *p;
511   const gchar *prev;
512   const gchar *end;
513   gchar *collate_key;
514   gint digits;
515   gint leading_zeros;
516 
517   /*
518    * How it works:
519    *
520    * Split the filename into collatable substrings which do
521    * not contain [.0-9] and special-cased substrings. The collatable
522    * substrings are run through the normal g_utf8_collate_key() and the
523    * resulting keys are concatenated with keys generated from the
524    * special-cased substrings.
525    *
</pre>
<hr />
<pre>
555    * the number of leading digits as a byte at the very end of the collation
556    * key.
557    *
558    * To try avoid conflict with any collation key sequence generated by libc we
559    * start each switch to a special cased part with a sentinel that hopefully
560    * will sort before anything libc will generate.
561    */
562 
563   if (len &lt; 0)
564     len = strlen (str);
565 
566   result = g_string_sized_new (len * 2);
567   append = g_string_sized_new (0);
568 
569   end = str + len;
570 
571   /* No need to use utf8 functions, since we&#39;re only looking for ascii chars */
572   for (prev = p = str; p &lt; end; p++)
573     {
574       switch (*p)
<span class="line-modified">575     {</span>
<span class="line-modified">576     case &#39;.&#39;:</span>
<span class="line-modified">577       if (prev != p)</span>
<span class="line-modified">578         {</span>
<span class="line-modified">579           collate_key = g_utf8_collate_key (prev, p - prev);</span>
<span class="line-modified">580           g_string_append (result, collate_key);</span>
<span class="line-modified">581           g_free (collate_key);</span>
<span class="line-modified">582         }</span>
<span class="line-modified">583 </span>
<span class="line-modified">584       g_string_append (result, COLLATION_SENTINEL &quot;\1&quot;);</span>
<span class="line-modified">585 </span>
<span class="line-modified">586       /* skip the dot */</span>
<span class="line-modified">587       prev = p + 1;</span>
<span class="line-modified">588       break;</span>
<span class="line-modified">589 </span>
<span class="line-modified">590     case &#39;0&#39;:</span>
<span class="line-modified">591     case &#39;1&#39;:</span>
<span class="line-modified">592     case &#39;2&#39;:</span>
<span class="line-modified">593     case &#39;3&#39;:</span>
<span class="line-modified">594     case &#39;4&#39;:</span>
<span class="line-modified">595     case &#39;5&#39;:</span>
<span class="line-modified">596     case &#39;6&#39;:</span>
<span class="line-modified">597     case &#39;7&#39;:</span>
<span class="line-modified">598     case &#39;8&#39;:</span>
<span class="line-modified">599     case &#39;9&#39;:</span>
<span class="line-modified">600       if (prev != p)</span>
<span class="line-modified">601         {</span>
<span class="line-modified">602           collate_key = g_utf8_collate_key (prev, p - prev);</span>
<span class="line-modified">603           g_string_append (result, collate_key);</span>
<span class="line-modified">604           g_free (collate_key);</span>
<span class="line-modified">605         }</span>
<span class="line-modified">606 </span>
<span class="line-modified">607       g_string_append (result, COLLATION_SENTINEL &quot;\2&quot;);</span>
<span class="line-modified">608 </span>
<span class="line-modified">609       prev = p;</span>
<span class="line-modified">610 </span>
<span class="line-modified">611       /* write d-1 colons */</span>
<span class="line-modified">612       if (*p == &#39;0&#39;)</span>
<span class="line-modified">613         {</span>
<span class="line-modified">614           leading_zeros = 1;</span>
<span class="line-modified">615           digits = 0;</span>
<span class="line-modified">616         }</span>
<span class="line-modified">617       else</span>
<span class="line-modified">618         {</span>
<span class="line-modified">619           leading_zeros = 0;</span>
<span class="line-modified">620           digits = 1;</span>
<span class="line-modified">621         }</span>
<span class="line-modified">622 </span>
<span class="line-modified">623       while (++p &lt; end)</span>
<span class="line-modified">624         {</span>
<span class="line-modified">625           if (*p == &#39;0&#39; &amp;&amp; !digits)</span>
<span class="line-modified">626         ++leading_zeros;</span>
<span class="line-modified">627           else if (g_ascii_isdigit(*p))</span>
<span class="line-modified">628         ++digits;</span>
<span class="line-modified">629           else</span>
630                 {
<span class="line-modified">631           /* count an all-zero sequence as</span>
632                    * one digit plus leading zeros
633                    */
634               if (!digits)
635                     {
636                       ++digits;
637                       --leading_zeros;
638                     }
<span class="line-removed">639           break;</span>
<span class="line-removed">640                 }</span>
<span class="line-removed">641         }</span>
<span class="line-removed">642 </span>
<span class="line-removed">643       while (digits &gt; 1)</span>
<span class="line-removed">644         {</span>
<span class="line-removed">645           g_string_append_c (result, &#39;:&#39;);</span>
<span class="line-removed">646           --digits;</span>
<span class="line-removed">647         }</span>
<span class="line-removed">648 </span>
<span class="line-removed">649       if (leading_zeros &gt; 0)</span>
<span class="line-removed">650         {</span>
<span class="line-removed">651           g_string_append_c (append, (char)leading_zeros);</span>
<span class="line-removed">652           prev += leading_zeros;</span>
<span class="line-removed">653         }</span>
<span class="line-removed">654 </span>
<span class="line-removed">655       /* write the number itself */</span>
<span class="line-removed">656       g_string_append_len (result, prev, p - prev);</span>
<span class="line-removed">657 </span>
<span class="line-removed">658       prev = p;</span>
<span class="line-removed">659       --p;    /* go one step back to avoid disturbing outer loop */</span>
<span class="line-removed">660       break;</span>
<span class="line-removed">661 </span>
<span class="line-removed">662     default:</span>
<span class="line-removed">663       /* other characters just accumulate */</span>
664       break;
<span class="line-modified">665     }</span>

























666     }
667 
668   if (prev != p)
669     {
670       collate_key = g_utf8_collate_key (prev, p - prev);
671       g_string_append (result, collate_key);
672       g_free (collate_key);
673     }
674 
675   g_string_append (result, append-&gt;str);
676   g_string_free (append, TRUE);
677 
678   return g_string_free (result, FALSE);
679 #else /* HAVE_CARBON */
680   return carbon_collate_key_for_filename (str, len);
681 #endif
682 }
</pre>
</td>
<td>
<hr />
<pre>
  3  *  Copyright 2001,2005 Red Hat, Inc.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Lesser General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2.1 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Lesser General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Lesser General Public License
 16  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 17  */
 18 
 19 #include &quot;config.h&quot;
 20 
 21 #include &lt;locale.h&gt;
 22 #include &lt;string.h&gt;
<span class="line-modified"> 23 #ifdef HAVE_WCHAR_H</span>
 24 #include &lt;wchar.h&gt;
 25 #endif
 26 
 27 #ifdef HAVE_CARBON
 28 #include &lt;CoreServices/CoreServices.h&gt;
 29 #endif
 30 
 31 #include &quot;gmem.h&quot;
 32 #include &quot;gunicode.h&quot;
 33 #include &quot;gunicodeprivate.h&quot;
 34 #include &quot;gstring.h&quot;
 35 #include &quot;gstrfuncs.h&quot;
 36 #include &quot;gtestutils.h&quot;
 37 #include &quot;gcharset.h&quot;

 38 #include &quot;gconvert.h&quot;

 39 
<span class="line-added"> 40 #if SIZEOF_WCHAR_T == 4 &amp;&amp; defined(__STDC_ISO_10646__)</span>
<span class="line-added"> 41 #define GUNICHAR_EQUALS_WCHAR_T 1</span>
<span class="line-added"> 42 #endif</span>
 43 
 44 #ifdef _MSC_VER
 45 /* Workaround for bug in MSVCR80.DLL */
 46 static gsize
 47 msc_strxfrm_wrapper (char       *string1,
<span class="line-modified"> 48          const char *string2,</span>
<span class="line-modified"> 49          gsize       count)</span>
 50 {
 51   if (!string1 || count &lt;= 0)
 52     {
 53       char tmp;
 54 
 55       return strxfrm (&amp;tmp, string2, 1);
 56     }
 57   return strxfrm (string1, string2, count);
 58 }
 59 #define strxfrm msc_strxfrm_wrapper
 60 #endif
 61 
 62 /**
 63  * g_utf8_collate:
 64  * @str1: a UTF-8 encoded string
 65  * @str2: a UTF-8 encoded string
 66  *
 67  * Compares two strings for ordering using the linguistically
 68  * correct rules for the [current locale][setlocale].
 69  * When sorting a large number of strings, it will be significantly
 70  * faster to obtain collation keys with g_utf8_collate_key() and
 71  * compare the keys with strcmp() when sorting instead of sorting
 72  * the original strings.
 73  *
 74  * Returns: &lt; 0 if @str1 compares before @str2,
 75  *   0 if they compare equal, &gt; 0 if @str1 compares after @str2.
 76  **/
 77 gint
 78 g_utf8_collate (const gchar *str1,
<span class="line-modified"> 79     const gchar *str2)</span>
 80 {
 81   gint result;
 82 
 83 #ifdef HAVE_CARBON
 84 
 85   UniChar *str1_utf16;
 86   UniChar *str2_utf16;
 87   glong len1;
 88   glong len2;
 89   SInt32 retval = 0;
 90 
 91   g_return_val_if_fail (str1 != NULL, 0);
 92   g_return_val_if_fail (str2 != NULL, 0);
 93 
 94   str1_utf16 = g_utf8_to_utf16 (str1, -1, NULL, &amp;len1, NULL);
 95   str2_utf16 = g_utf8_to_utf16 (str2, -1, NULL, &amp;len2, NULL);
 96 
 97   UCCompareTextDefault (kUCCollateStandardOptions,
 98                         str1_utf16, len1, str2_utf16, len2,
 99                         NULL, &amp;retval);
100   result = retval;
101 
102   g_free (str2_utf16);
103   g_free (str1_utf16);
104 
<span class="line-modified">105 #elif defined(HAVE_WCHAR_H) &amp;&amp; defined(GUNICHAR_EQUALS_WCHAR_T)</span>
106 
107   gunichar *str1_norm;
108   gunichar *str2_norm;
109 
110   g_return_val_if_fail (str1 != NULL, 0);
111   g_return_val_if_fail (str2 != NULL, 0);
112 
113   str1_norm = _g_utf8_normalize_wc (str1, -1, G_NORMALIZE_ALL_COMPOSE);
114   str2_norm = _g_utf8_normalize_wc (str2, -1, G_NORMALIZE_ALL_COMPOSE);
115 
116   result = wcscoll ((wchar_t *)str1_norm, (wchar_t *)str2_norm);
117 
118   g_free (str1_norm);
119   g_free (str2_norm);
120 
<span class="line-modified">121 #else</span>
122 
123   const gchar *charset;
124   gchar *str1_norm;
125   gchar *str2_norm;
126 
127   g_return_val_if_fail (str1 != NULL, 0);
128   g_return_val_if_fail (str2 != NULL, 0);
129 
130   str1_norm = g_utf8_normalize (str1, -1, G_NORMALIZE_ALL_COMPOSE);
131   str2_norm = g_utf8_normalize (str2, -1, G_NORMALIZE_ALL_COMPOSE);
132 
133   if (g_get_charset (&amp;charset))
134     {
135       result = strcoll (str1_norm, str2_norm);
136     }
137   else
138     {
139       gchar *str1_locale = g_convert (str1_norm, -1, charset, &quot;UTF-8&quot;, NULL, NULL, NULL);
140       gchar *str2_locale = g_convert (str2_norm, -1, charset, &quot;UTF-8&quot;, NULL, NULL, NULL);
141 
142       if (str1_locale &amp;&amp; str2_locale)
<span class="line-modified">143   result =  strcoll (str1_locale, str2_locale);</span>
144       else if (str1_locale)
<span class="line-modified">145   result = -1;</span>
146       else if (str2_locale)
<span class="line-modified">147   result = 1;</span>
148       else
<span class="line-modified">149   result = strcmp (str1_norm, str2_norm);</span>
150 
151       g_free (str1_locale);
152       g_free (str2_locale);
153     }
154 
155   g_free (str1_norm);
156   g_free (str2_norm);
157 
<span class="line-modified">158 #endif</span>
159 
160   return result;
161 }
162 
<span class="line-modified">163 #if defined(HAVE_WCHAR_H) &amp;&amp; defined(GUNICHAR_EQUALS_WCHAR_T)</span>
164 /* We need UTF-8 encoding of numbers to encode the weights if
165  * we are using wcsxfrm. However, we aren&#39;t encoding Unicode
166  * characters, so we can&#39;t simply use g_unichar_to_utf8.
167  *
168  * The following routine is taken (with modification) from GNU
169  * libc&#39;s strxfrm routine:
170  *
171  * Copyright (C) 1995-1999,2000,2001 Free Software Foundation, Inc.
172  * Written by Ulrich Drepper &lt;drepper@cygnus.com&gt;, 1995.
173  */
174 static inline int
175 utf8_encode (char *buf, wchar_t val)
176 {
177   int retval;
178 
179   if (val &lt; 0x80)
180     {
181       if (buf)
<span class="line-modified">182   *buf++ = (char) val;</span>
183       retval = 1;
184     }
185   else
186     {
187       int step;
188 
189       for (step = 2; step &lt; 6; ++step)
190         if ((val &amp; (~(guint32)0 &lt;&lt; (5 * step + 1))) == 0)
191           break;
192       retval = step;
193 
194       if (buf)
<span class="line-modified">195   {</span>
<span class="line-modified">196     *buf = (unsigned char) (~0xff &gt;&gt; step);</span>
<span class="line-modified">197     --step;</span>
<span class="line-modified">198     do</span>
<span class="line-modified">199       {</span>
<span class="line-modified">200         buf[step] = 0x80 | (val &amp; 0x3f);</span>
<span class="line-modified">201         val &gt;&gt;= 6;</span>
<span class="line-modified">202       }</span>
<span class="line-modified">203     while (--step &gt; 0);</span>
<span class="line-modified">204     *buf |= val;</span>
<span class="line-modified">205   }</span>
206     }
207 
208   return retval;
209 }
<span class="line-modified">210 #endif</span>
211 
212 #ifdef HAVE_CARBON
213 
214 static gchar *
215 collate_key_to_string (UCCollationValue *key,
216                        gsize             key_len)
217 {
218   gchar *result;
219   gsize result_len;
220   long *lkey = (long *) key;
221 
222   /* UCCollationValue format:
223    *
224    * UCCollateOptions (32/64 bits)
225    * SizeInBytes      (32/64 bits)
226    * Value            (8 bits arrey)
227    *
228    * UCCollateOptions: ordering option mask of the collator
229    * used to create the key. Size changes on 32-bit / 64-bit
230    * hosts. On 64-bits also the extra half-word seems to have
</pre>
<hr />
<pre>
357 /**
358  * g_utf8_collate_key:
359  * @str: a UTF-8 encoded string.
360  * @len: length of @str, in bytes, or -1 if @str is nul-terminated.
361  *
362  * Converts a string into a collation key that can be compared
363  * with other collation keys produced by the same function using
364  * strcmp().
365  *
366  * The results of comparing the collation keys of two strings
367  * with strcmp() will always be the same as comparing the two
368  * original keys with g_utf8_collate().
369  *
370  * Note that this function depends on the [current locale][setlocale].
371  *
372  * Returns: a newly allocated string. This string should
373  *   be freed with g_free() when you are done with it.
374  **/
375 gchar *
376 g_utf8_collate_key (const gchar *str,
<span class="line-modified">377         gssize       len)</span>
378 {
379   gchar *result;
380 
381 #ifdef HAVE_CARBON
382 
383   g_return_val_if_fail (str != NULL, NULL);
384   result = carbon_collate_key (str, len);
385 
<span class="line-modified">386 #elif defined(HAVE_WCHAR_H) &amp;&amp; defined(GUNICHAR_EQUALS_WCHAR_T)</span>
387 
388   gsize xfrm_len;
389   gunichar *str_norm;
390   wchar_t *result_wc;
391   gsize i;
392   gsize result_len = 0;
393 
394   g_return_val_if_fail (str != NULL, NULL);
395 
396   str_norm = _g_utf8_normalize_wc (str, len, G_NORMALIZE_ALL_COMPOSE);
397 
398   xfrm_len = wcsxfrm (NULL, (wchar_t *)str_norm, 0);
399   result_wc = g_new (wchar_t, xfrm_len + 1);
400   wcsxfrm (result_wc, (wchar_t *)str_norm, xfrm_len + 1);
401 
402   for (i = 0; i &lt; xfrm_len; i++)
403     result_len += utf8_encode (NULL, result_wc[i]);
404 
405   result = g_malloc (result_len + 1);
406   result_len = 0;
407   for (i = 0; i &lt; xfrm_len; i++)
408     result_len += utf8_encode (result + result_len, result_wc[i]);
409 
410   result[result_len] = &#39;\0&#39;;
411 
412   g_free (result_wc);
413   g_free (str_norm);
414 
415   return result;
<span class="line-modified">416 #else</span>
417 
418   gsize xfrm_len;
419   const gchar *charset;
420   gchar *str_norm;
421 
422   g_return_val_if_fail (str != NULL, NULL);
423 
424   str_norm = g_utf8_normalize (str, len, G_NORMALIZE_ALL_COMPOSE);
425 
426   result = NULL;
427 
428   if (g_get_charset (&amp;charset))
429     {
430       xfrm_len = strxfrm (NULL, str_norm, 0);
431       if (xfrm_len &gt;= 0 &amp;&amp; xfrm_len &lt; G_MAXINT - 2)
432         {
433           result = g_malloc (xfrm_len + 1);
434           strxfrm (result, str_norm, xfrm_len + 1);
435         }
436     }
437   else
438     {
439       gchar *str_locale = g_convert (str_norm, -1, charset, &quot;UTF-8&quot;, NULL, NULL, NULL);
440 
441       if (str_locale)
<span class="line-modified">442   {</span>
<span class="line-modified">443     xfrm_len = strxfrm (NULL, str_locale, 0);</span>
<span class="line-modified">444     if (xfrm_len &lt; 0 || xfrm_len &gt;= G_MAXINT - 2)</span>
<span class="line-modified">445       {</span>
<span class="line-modified">446         g_free (str_locale);</span>
<span class="line-modified">447         str_locale = NULL;</span>
<span class="line-modified">448       }</span>
<span class="line-modified">449   }</span>
450       if (str_locale)
<span class="line-modified">451   {</span>
<span class="line-modified">452     result = g_malloc (xfrm_len + 2);</span>
<span class="line-modified">453     result[0] = &#39;A&#39;;</span>
<span class="line-modified">454     strxfrm (result + 1, str_locale, xfrm_len + 1);</span>
455 
<span class="line-modified">456     g_free (str_locale);</span>
<span class="line-modified">457   }</span>
458     }
459 
460   if (!result)
461     {
462       xfrm_len = strlen (str_norm);
463       result = g_malloc (xfrm_len + 2);
464       result[0] = &#39;B&#39;;
465       memcpy (result + 1, str_norm, xfrm_len);
466       result[xfrm_len+1] = &#39;\0&#39;;
467     }
468 
469   g_free (str_norm);
<span class="line-modified">470 #endif</span>
471 
472   return result;
473 }
474 
475 /* This is a collation key that is very very likely to sort before any
476  * collation key that libc strxfrm generates. We use this before any
477  * special case (dot or number) to make sure that its sorted before
478  * anything else.
479  */
480 #define COLLATION_SENTINEL &quot;\1\1\1&quot;
481 
482 /**
483  * g_utf8_collate_key_for_filename:
484  * @str: a UTF-8 encoded string.
485  * @len: length of @str, in bytes, or -1 if @str is nul-terminated.
486  *
487  * Converts a string into a collation key that can be compared
488  * with other collation keys produced by the same function using strcmp().
489  *
490  * In order to sort filenames correctly, this function treats the dot &#39;.&#39;
491  * as a special case. Most dictionary orderings seem to consider it
492  * insignificant, thus producing the ordering &quot;event.c&quot; &quot;eventgenerator.c&quot;
493  * &quot;event.h&quot; instead of &quot;event.c&quot; &quot;event.h&quot; &quot;eventgenerator.c&quot;. Also, we
494  * would like to treat numbers intelligently so that &quot;file1&quot; &quot;file10&quot; &quot;file5&quot;
495  * is sorted as &quot;file1&quot; &quot;file5&quot; &quot;file10&quot;.
496  *
497  * Note that this function depends on the [current locale][setlocale].
498  *
499  * Returns: a newly allocated string. This string should
500  *   be freed with g_free() when you are done with it.
501  *
502  * Since: 2.8
503  */
504 gchar *
505 g_utf8_collate_key_for_filename (const gchar *str,
<span class="line-modified">506          gssize       len)</span>
507 {
508 #ifndef HAVE_CARBON
509   GString *result;
510   GString *append;
511   const gchar *p;
512   const gchar *prev;
513   const gchar *end;
514   gchar *collate_key;
515   gint digits;
516   gint leading_zeros;
517 
518   /*
519    * How it works:
520    *
521    * Split the filename into collatable substrings which do
522    * not contain [.0-9] and special-cased substrings. The collatable
523    * substrings are run through the normal g_utf8_collate_key() and the
524    * resulting keys are concatenated with keys generated from the
525    * special-cased substrings.
526    *
</pre>
<hr />
<pre>
556    * the number of leading digits as a byte at the very end of the collation
557    * key.
558    *
559    * To try avoid conflict with any collation key sequence generated by libc we
560    * start each switch to a special cased part with a sentinel that hopefully
561    * will sort before anything libc will generate.
562    */
563 
564   if (len &lt; 0)
565     len = strlen (str);
566 
567   result = g_string_sized_new (len * 2);
568   append = g_string_sized_new (0);
569 
570   end = str + len;
571 
572   /* No need to use utf8 functions, since we&#39;re only looking for ascii chars */
573   for (prev = p = str; p &lt; end; p++)
574     {
575       switch (*p)
<span class="line-modified">576   {</span>
<span class="line-modified">577   case &#39;.&#39;:</span>
<span class="line-modified">578     if (prev != p)</span>
<span class="line-modified">579       {</span>
<span class="line-modified">580         collate_key = g_utf8_collate_key (prev, p - prev);</span>
<span class="line-modified">581         g_string_append (result, collate_key);</span>
<span class="line-modified">582         g_free (collate_key);</span>
<span class="line-modified">583       }</span>
<span class="line-modified">584 </span>
<span class="line-modified">585     g_string_append (result, COLLATION_SENTINEL &quot;\1&quot;);</span>
<span class="line-modified">586 </span>
<span class="line-modified">587     /* skip the dot */</span>
<span class="line-modified">588     prev = p + 1;</span>
<span class="line-modified">589     break;</span>
<span class="line-modified">590 </span>
<span class="line-modified">591   case &#39;0&#39;:</span>
<span class="line-modified">592   case &#39;1&#39;:</span>
<span class="line-modified">593   case &#39;2&#39;:</span>
<span class="line-modified">594   case &#39;3&#39;:</span>
<span class="line-modified">595   case &#39;4&#39;:</span>
<span class="line-modified">596   case &#39;5&#39;:</span>
<span class="line-modified">597   case &#39;6&#39;:</span>
<span class="line-modified">598   case &#39;7&#39;:</span>
<span class="line-modified">599   case &#39;8&#39;:</span>
<span class="line-modified">600   case &#39;9&#39;:</span>
<span class="line-modified">601     if (prev != p)</span>
<span class="line-modified">602       {</span>
<span class="line-modified">603         collate_key = g_utf8_collate_key (prev, p - prev);</span>
<span class="line-modified">604         g_string_append (result, collate_key);</span>
<span class="line-modified">605         g_free (collate_key);</span>
<span class="line-modified">606       }</span>
<span class="line-modified">607 </span>
<span class="line-modified">608     g_string_append (result, COLLATION_SENTINEL &quot;\2&quot;);</span>
<span class="line-modified">609 </span>
<span class="line-modified">610     prev = p;</span>
<span class="line-modified">611 </span>
<span class="line-modified">612     /* write d-1 colons */</span>
<span class="line-modified">613     if (*p == &#39;0&#39;)</span>
<span class="line-modified">614       {</span>
<span class="line-modified">615         leading_zeros = 1;</span>
<span class="line-modified">616         digits = 0;</span>
<span class="line-modified">617       }</span>
<span class="line-modified">618     else</span>
<span class="line-modified">619       {</span>
<span class="line-modified">620         leading_zeros = 0;</span>
<span class="line-modified">621         digits = 1;</span>
<span class="line-modified">622       }</span>
<span class="line-modified">623 </span>
<span class="line-modified">624     while (++p &lt; end)</span>
<span class="line-modified">625       {</span>
<span class="line-modified">626         if (*p == &#39;0&#39; &amp;&amp; !digits)</span>
<span class="line-modified">627     ++leading_zeros;</span>
<span class="line-modified">628         else if (g_ascii_isdigit(*p))</span>
<span class="line-modified">629     ++digits;</span>
<span class="line-modified">630         else</span>
631                 {
<span class="line-modified">632       /* count an all-zero sequence as</span>
633                    * one digit plus leading zeros
634                    */
635               if (!digits)
636                     {
637                       ++digits;
638                       --leading_zeros;
639                     }

























640       break;
<span class="line-modified">641                 }</span>
<span class="line-added">642       }</span>
<span class="line-added">643 </span>
<span class="line-added">644     while (digits &gt; 1)</span>
<span class="line-added">645       {</span>
<span class="line-added">646         g_string_append_c (result, &#39;:&#39;);</span>
<span class="line-added">647         --digits;</span>
<span class="line-added">648       }</span>
<span class="line-added">649 </span>
<span class="line-added">650     if (leading_zeros &gt; 0)</span>
<span class="line-added">651       {</span>
<span class="line-added">652         g_string_append_c (append, (char)leading_zeros);</span>
<span class="line-added">653         prev += leading_zeros;</span>
<span class="line-added">654       }</span>
<span class="line-added">655 </span>
<span class="line-added">656     /* write the number itself */</span>
<span class="line-added">657     g_string_append_len (result, prev, p - prev);</span>
<span class="line-added">658 </span>
<span class="line-added">659     prev = p;</span>
<span class="line-added">660     --p;    /* go one step back to avoid disturbing outer loop */</span>
<span class="line-added">661     break;</span>
<span class="line-added">662 </span>
<span class="line-added">663   default:</span>
<span class="line-added">664     /* other characters just accumulate */</span>
<span class="line-added">665     break;</span>
<span class="line-added">666   }</span>
667     }
668 
669   if (prev != p)
670     {
671       collate_key = g_utf8_collate_key (prev, p - prev);
672       g_string_append (result, collate_key);
673       g_free (collate_key);
674     }
675 
676   g_string_append (result, append-&gt;str);
677   g_string_free (append, TRUE);
678 
679   return g_string_free (result, FALSE);
680 #else /* HAVE_CARBON */
681   return carbon_collate_key_for_filename (str, len);
682 #endif
683 }
</pre>
</td>
</tr>
</table>
<center><a href="gunicodeprivate.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gunidecomp.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>