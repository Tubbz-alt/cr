<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gmarshal.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">   1 </span>
<span class="line-removed">   2 #include &quot;config.h&quot;</span>
<span class="line-removed">   3 </span>
<span class="line-removed">   4 #include &quot;gobject.h&quot;</span>
<span class="line-removed">   5 #include &quot;genums.h&quot;</span>
<span class="line-removed">   6 #include &quot;gboxed.h&quot;</span>
<span class="line-removed">   7 #include &quot;gvaluetypes.h&quot;</span>
<span class="line-removed">   8 </span>
<span class="line-removed">   9 /**</span>
<span class="line-removed">  10  * g_cclosure_marshal_VOID__VOID:</span>
<span class="line-removed">  11  * @closure: A #GClosure.</span>
<span class="line-removed">  12  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed">  13  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed">  14  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed">  15  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed">  16  *   on which to invoke the callback of closure.</span>
<span class="line-removed">  17  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed">  18  *   g_closure_invoke().</span>
<span class="line-removed">  19  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed">  20  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed">  21  *   g_closure_set_meta_marshal()</span>
<span class="line-removed">  22  *</span>
<span class="line-removed">  23  * A #GClosureMarshal function for use with signals with no arguments.</span>
<span class="line-removed">  24  */</span>
<span class="line-removed">  25 /**</span>
<span class="line-removed">  26  * g_cclosure_marshal_VOID__BOOLEAN:</span>
<span class="line-removed">  27  * @closure: A #GClosure.</span>
<span class="line-removed">  28  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed">  29  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed">  30  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed">  31  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed">  32  *   on which to invoke the callback of closure.</span>
<span class="line-removed">  33  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed">  34  *   g_closure_invoke().</span>
<span class="line-removed">  35  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed">  36  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed">  37  *   g_closure_set_meta_marshal()</span>
<span class="line-removed">  38  *</span>
<span class="line-removed">  39  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed">  40  * boolean argument.</span>
<span class="line-removed">  41  */</span>
<span class="line-removed">  42 /**</span>
<span class="line-removed">  43  * g_cclosure_marshal_VOID__CHAR:</span>
<span class="line-removed">  44  * @closure: A #GClosure.</span>
<span class="line-removed">  45  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed">  46  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed">  47  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed">  48  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed">  49  *   on which to invoke the callback of closure.</span>
<span class="line-removed">  50  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed">  51  *   g_closure_invoke().</span>
<span class="line-removed">  52  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed">  53  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed">  54  *   g_closure_set_meta_marshal()</span>
<span class="line-removed">  55  *</span>
<span class="line-removed">  56  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed">  57  * character argument.</span>
<span class="line-removed">  58  */</span>
<span class="line-removed">  59 /**</span>
<span class="line-removed">  60  * g_cclosure_marshal_VOID__UCHAR:</span>
<span class="line-removed">  61  * @closure: A #GClosure.</span>
<span class="line-removed">  62  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed">  63  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed">  64  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed">  65  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed">  66  *   on which to invoke the callback of closure.</span>
<span class="line-removed">  67  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed">  68  *   g_closure_invoke().</span>
<span class="line-removed">  69  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed">  70  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed">  71  *   g_closure_set_meta_marshal()</span>
<span class="line-removed">  72  *</span>
<span class="line-removed">  73  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed">  74  * unsigned character argument.</span>
<span class="line-removed">  75  */</span>
<span class="line-removed">  76 /**</span>
<span class="line-removed">  77  * g_cclosure_marshal_VOID__INT:</span>
<span class="line-removed">  78  * @closure: A #GClosure.</span>
<span class="line-removed">  79  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed">  80  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed">  81  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed">  82  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed">  83  *   on which to invoke the callback of closure.</span>
<span class="line-removed">  84  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed">  85  *   g_closure_invoke().</span>
<span class="line-removed">  86  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed">  87  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed">  88  *   g_closure_set_meta_marshal()</span>
<span class="line-removed">  89  *</span>
<span class="line-removed">  90  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed">  91  * integer argument.</span>
<span class="line-removed">  92  */</span>
<span class="line-removed">  93 /**</span>
<span class="line-removed">  94  * g_cclosure_marshal_VOID__UINT:</span>
<span class="line-removed">  95  * @closure: A #GClosure.</span>
<span class="line-removed">  96  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed">  97  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed">  98  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed">  99  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 100  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 101  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 102  *   g_closure_invoke().</span>
<span class="line-removed"> 103  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 104  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 105  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 106  *</span>
<span class="line-removed"> 107  * A #GClosureMarshal function for use with signals with with a single</span>
<span class="line-removed"> 108  * unsigned integer argument.</span>
<span class="line-removed"> 109  */</span>
<span class="line-removed"> 110 /**</span>
<span class="line-removed"> 111  * g_cclosure_marshal_VOID__LONG:</span>
<span class="line-removed"> 112  * @closure: A #GClosure.</span>
<span class="line-removed"> 113  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 114  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 115  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 116  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 117  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 118  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 119  *   g_closure_invoke().</span>
<span class="line-removed"> 120  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 121  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 122  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 123  *</span>
<span class="line-removed"> 124  * A #GClosureMarshal function for use with signals with with a single</span>
<span class="line-removed"> 125  * long integer argument.</span>
<span class="line-removed"> 126  */</span>
<span class="line-removed"> 127 /**</span>
<span class="line-removed"> 128  * g_cclosure_marshal_VOID__ULONG:</span>
<span class="line-removed"> 129  * @closure: A #GClosure.</span>
<span class="line-removed"> 130  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 131  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 132  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 133  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 134  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 135  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 136  *   g_closure_invoke().</span>
<span class="line-removed"> 137  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 138  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 139  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 140  *</span>
<span class="line-removed"> 141  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed"> 142  * unsigned long integer argument.</span>
<span class="line-removed"> 143  */</span>
<span class="line-removed"> 144 /**</span>
<span class="line-removed"> 145  * g_cclosure_marshal_VOID__ENUM:</span>
<span class="line-removed"> 146  * @closure: A #GClosure.</span>
<span class="line-removed"> 147  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 148  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 149  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 150  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 151  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 152  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 153  *   g_closure_invoke().</span>
<span class="line-removed"> 154  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 155  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 156  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 157  *</span>
<span class="line-removed"> 158  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed"> 159  * argument with an enumerated type.</span>
<span class="line-removed"> 160  */</span>
<span class="line-removed"> 161 /**</span>
<span class="line-removed"> 162  * g_cclosure_marshal_VOID__FLAGS:</span>
<span class="line-removed"> 163  * @closure: A #GClosure.</span>
<span class="line-removed"> 164  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 165  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 166  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 167  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 168  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 169  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 170  *   g_closure_invoke().</span>
<span class="line-removed"> 171  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 172  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 173  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 174  *</span>
<span class="line-removed"> 175  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed"> 176  * argument with a flags types.</span>
<span class="line-removed"> 177  */</span>
<span class="line-removed"> 178 /**</span>
<span class="line-removed"> 179  * g_cclosure_marshal_VOID__FLOAT:</span>
<span class="line-removed"> 180  * @closure: A #GClosure.</span>
<span class="line-removed"> 181  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 182  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 183  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 184  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 185  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 186  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 187  *   g_closure_invoke().</span>
<span class="line-removed"> 188  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 189  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 190  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 191  *</span>
<span class="line-removed"> 192  * A #GClosureMarshal function for use with signals with one</span>
<span class="line-removed"> 193  * single-precision floating point argument.</span>
<span class="line-removed"> 194  */</span>
<span class="line-removed"> 195 /**</span>
<span class="line-removed"> 196  * g_cclosure_marshal_VOID__DOUBLE:</span>
<span class="line-removed"> 197  * @closure: A #GClosure.</span>
<span class="line-removed"> 198  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 199  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 200  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 201  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 202  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 203  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 204  *   g_closure_invoke().</span>
<span class="line-removed"> 205  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 206  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 207  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 208  *</span>
<span class="line-removed"> 209  * A #GClosureMarshal function for use with signals with one</span>
<span class="line-removed"> 210  * double-precision floating point argument.</span>
<span class="line-removed"> 211  */</span>
<span class="line-removed"> 212 /**</span>
<span class="line-removed"> 213  * g_cclosure_marshal_VOID__STRING:</span>
<span class="line-removed"> 214  * @closure: A #GClosure.</span>
<span class="line-removed"> 215  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 216  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 217  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 218  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 219  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 220  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 221  *   g_closure_invoke().</span>
<span class="line-removed"> 222  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 223  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 224  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 225  *</span>
<span class="line-removed"> 226  * A #GClosureMarshal function for use with signals with a single string</span>
<span class="line-removed"> 227  * argument.</span>
<span class="line-removed"> 228  */</span>
<span class="line-removed"> 229 /**</span>
<span class="line-removed"> 230  * g_cclosure_marshal_VOID__PARAM:</span>
<span class="line-removed"> 231  * @closure: A #GClosure.</span>
<span class="line-removed"> 232  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 233  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 234  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 235  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 236  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 237  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 238  *   g_closure_invoke().</span>
<span class="line-removed"> 239  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 240  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 241  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 242  *</span>
<span class="line-removed"> 243  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed"> 244  * argument of type #GParamSpec.</span>
<span class="line-removed"> 245  */</span>
<span class="line-removed"> 246 /**</span>
<span class="line-removed"> 247  * g_cclosure_marshal_VOID__BOXED:</span>
<span class="line-removed"> 248  * @closure: A #GClosure.</span>
<span class="line-removed"> 249  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 250  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 251  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 252  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 253  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 254  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 255  *   g_closure_invoke().</span>
<span class="line-removed"> 256  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 257  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 258  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 259  *</span>
<span class="line-removed"> 260  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed"> 261  * argument which is any boxed pointer type.</span>
<span class="line-removed"> 262  */</span>
<span class="line-removed"> 263 /**</span>
<span class="line-removed"> 264  * g_cclosure_marshal_VOID__POINTER:</span>
<span class="line-removed"> 265  * @closure: A #GClosure.</span>
<span class="line-removed"> 266  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 267  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 268  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 269  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 270  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 271  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 272  *   g_closure_invoke().</span>
<span class="line-removed"> 273  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 274  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 275  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 276  *</span>
<span class="line-removed"> 277  * A #GClosureMarshal function for use with signals with a single raw</span>
<span class="line-removed"> 278  * pointer argument type.</span>
<span class="line-removed"> 279  *</span>
<span class="line-removed"> 280  * If it is possible, it is better to use one of the more specific</span>
<span class="line-removed"> 281  * functions such as g_cclosure_marshal_VOID__OBJECT() or</span>
<span class="line-removed"> 282  * g_cclosure_marshal_VOID__OBJECT().</span>
<span class="line-removed"> 283  */</span>
<span class="line-removed"> 284 /**</span>
<span class="line-removed"> 285  * g_cclosure_marshal_VOID__OBJECT:</span>
<span class="line-removed"> 286  * @closure: A #GClosure.</span>
<span class="line-removed"> 287  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 288  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 289  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 290  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 291  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 292  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 293  *   g_closure_invoke().</span>
<span class="line-removed"> 294  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 295  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 296  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 297  *</span>
<span class="line-removed"> 298  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed"> 299  * #GObject argument.</span>
<span class="line-removed"> 300  */</span>
<span class="line-removed"> 301 /**</span>
<span class="line-removed"> 302  * g_cclosure_marshal_VOID__VARIANT:</span>
<span class="line-removed"> 303  * @closure: A #GClosure.</span>
<span class="line-removed"> 304  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 305  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 306  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 307  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 308  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 309  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 310  *   g_closure_invoke().</span>
<span class="line-removed"> 311  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 312  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 313  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 314  *</span>
<span class="line-removed"> 315  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed"> 316  * #GVariant argument.</span>
<span class="line-removed"> 317  */</span>
<span class="line-removed"> 318 /**</span>
<span class="line-removed"> 319  * g_cclosure_marshal_STRING__OBJECT_POINTER:</span>
<span class="line-removed"> 320  * @closure: A #GClosure.</span>
<span class="line-removed"> 321  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 322  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 323  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 324  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 325  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 326  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 327  *   g_closure_invoke().</span>
<span class="line-removed"> 328  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 329  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 330  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 331  *</span>
<span class="line-removed"> 332  * A #GClosureMarshal function for use with signals with handlers that</span>
<span class="line-removed"> 333  * take a #GObject and a pointer and produce a string.  It is highly</span>
<span class="line-removed"> 334  * unlikely that your signal handler fits this description.</span>
<span class="line-removed"> 335  */</span>
<span class="line-removed"> 336 /**</span>
<span class="line-removed"> 337  * g_cclosure_marshal_VOID__UINT_POINTER:</span>
<span class="line-removed"> 338  * @closure: A #GClosure.</span>
<span class="line-removed"> 339  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 340  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 341  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 342  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 343  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 344  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 345  *   g_closure_invoke().</span>
<span class="line-removed"> 346  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 347  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 348  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 349  *</span>
<span class="line-removed"> 350  * A #GClosureMarshal function for use with signals with a unsigned int</span>
<span class="line-removed"> 351  * and a pointer as arguments.</span>
<span class="line-removed"> 352  */</span>
<span class="line-removed"> 353 /**</span>
<span class="line-removed"> 354  * g_cclosure_marshal_BOOLEAN__FLAGS:</span>
<span class="line-removed"> 355  * @closure: A #GClosure.</span>
<span class="line-removed"> 356  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 357  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 358  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 359  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 360  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 361  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 362  *   g_closure_invoke().</span>
<span class="line-removed"> 363  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 364  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 365  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 366  *</span>
<span class="line-removed"> 367  * A #GClosureMarshal function for use with signals with handlers that</span>
<span class="line-removed"> 368  * take a flags type as an argument and return a boolean.  If you have</span>
<span class="line-removed"> 369  * such a signal, you will probably also need to use an accumulator,</span>
<span class="line-removed"> 370  * such as g_signal_accumulator_true_handled().</span>
<span class="line-removed"> 371  */</span>
<span class="line-removed"> 372 /**</span>
<span class="line-removed"> 373  * g_cclosure_marshal_BOOL__FLAGS:</span>
<span class="line-removed"> 374  * @closure: A #GClosure.</span>
<span class="line-removed"> 375  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 376  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 377  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 378  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 379  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 380  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 381  *   g_closure_invoke().</span>
<span class="line-removed"> 382  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 383  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 384  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 385  *</span>
<span class="line-removed"> 386  * An old alias for g_cclosure_marshal_BOOLEAN__FLAGS().</span>
<span class="line-removed"> 387  */</span>
<span class="line-removed"> 388 /**</span>
<span class="line-removed"> 389  * g_cclosure_marshal_BOOLEAN__BOXED_BOXED:</span>
<span class="line-removed"> 390  * @closure: A #GClosure.</span>
<span class="line-removed"> 391  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 392  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 393  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 394  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 395  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 396  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 397  *   g_closure_invoke().</span>
<span class="line-removed"> 398  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 399  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 400  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 401  *</span>
<span class="line-removed"> 402  * A #GClosureMarshal function for use with signals with handlers that</span>
<span class="line-removed"> 403  * take two boxed pointers as arguments and return a boolean.  If you</span>
<span class="line-removed"> 404  * have such a signal, you will probably also need to use an</span>
<span class="line-removed"> 405  * accumulator, such as g_signal_accumulator_true_handled().</span>
<span class="line-removed"> 406  */</span>
<span class="line-removed"> 407 /**</span>
<span class="line-removed"> 408  * g_cclosure_marshal_BOOL__BOXED_BOXED:</span>
<span class="line-removed"> 409  * @closure: A #GClosure.</span>
<span class="line-removed"> 410  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 411  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 412  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 413  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 414  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 415  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 416  *   g_closure_invoke().</span>
<span class="line-removed"> 417  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 418  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 419  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 420  *</span>
<span class="line-removed"> 421  * An old alias for g_cclosure_marshal_BOOLEAN__BOXED_BOXED().</span>
<span class="line-removed"> 422  */</span>
<span class="line-removed"> 423 /**</span>
<span class="line-removed"> 424  * g_cclosure_marshal_VOID__VOIDv:</span>
<span class="line-removed"> 425  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 426  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 427  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 428  *  value.</span>
<span class="line-removed"> 429  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 430  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 431  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 432  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 433  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 434  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 435  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 436  *  @args.</span>
<span class="line-removed"> 437  *</span>
<span class="line-removed"> 438  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__VOID().</span>
<span class="line-removed"> 439  */</span>
<span class="line-removed"> 440 </span>
<span class="line-removed"> 441 /**</span>
<span class="line-removed"> 442  * g_cclosure_marshal_VOID__BOOLEANv:</span>
<span class="line-removed"> 443  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 444  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 445  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 446  *  value.</span>
<span class="line-removed"> 447  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 448  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 449  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 450  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 451  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 452  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 453  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 454  *  @args.</span>
<span class="line-removed"> 455  *</span>
<span class="line-removed"> 456  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__BOOLEAN().</span>
<span class="line-removed"> 457  */</span>
<span class="line-removed"> 458 /**</span>
<span class="line-removed"> 459  * g_cclosure_marshal_VOID__CHARv:</span>
<span class="line-removed"> 460  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 461  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 462  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 463  *  value.</span>
<span class="line-removed"> 464  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 465  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 466  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 467  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 468  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 469  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 470  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 471  *  @args.</span>
<span class="line-removed"> 472  *</span>
<span class="line-removed"> 473  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__CHAR().</span>
<span class="line-removed"> 474  */</span>
<span class="line-removed"> 475 /**</span>
<span class="line-removed"> 476  * g_cclosure_marshal_VOID__UCHARv:</span>
<span class="line-removed"> 477  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 478  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 479  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 480  *  value.</span>
<span class="line-removed"> 481  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 482  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 483  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 484  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 485  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 486  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 487  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 488  *  @args.</span>
<span class="line-removed"> 489  *</span>
<span class="line-removed"> 490  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UCHAR().</span>
<span class="line-removed"> 491  */</span>
<span class="line-removed"> 492 /**</span>
<span class="line-removed"> 493  * g_cclosure_marshal_VOID__INTv:</span>
<span class="line-removed"> 494  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 495  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 496  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 497  *  value.</span>
<span class="line-removed"> 498  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 499  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 500  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 501  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 502  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 503  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 504  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 505  *  @args.</span>
<span class="line-removed"> 506  *</span>
<span class="line-removed"> 507  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__INT().</span>
<span class="line-removed"> 508  */</span>
<span class="line-removed"> 509 /**</span>
<span class="line-removed"> 510  * g_cclosure_marshal_VOID__UINTv:</span>
<span class="line-removed"> 511  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 512  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 513  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 514  *  value.</span>
<span class="line-removed"> 515  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 516  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 517  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 518  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 519  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 520  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 521  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 522  *  @args.</span>
<span class="line-removed"> 523  *</span>
<span class="line-removed"> 524  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UINT().</span>
<span class="line-removed"> 525  */</span>
<span class="line-removed"> 526 /**</span>
<span class="line-removed"> 527  * g_cclosure_marshal_VOID__LONGv:</span>
<span class="line-removed"> 528  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 529  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 530  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 531  *  value.</span>
<span class="line-removed"> 532  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 533  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 534  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 535  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 536  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 537  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 538  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 539  *  @args.</span>
<span class="line-removed"> 540  *</span>
<span class="line-removed"> 541  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__LONG().</span>
<span class="line-removed"> 542  */</span>
<span class="line-removed"> 543 /**</span>
<span class="line-removed"> 544  * g_cclosure_marshal_VOID__ULONGv:</span>
<span class="line-removed"> 545  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 546  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 547  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 548  *  value.</span>
<span class="line-removed"> 549  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 550  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 551  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 552  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 553  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 554  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 555  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 556  *  @args.</span>
<span class="line-removed"> 557  *</span>
<span class="line-removed"> 558  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__ULONG().</span>
<span class="line-removed"> 559  */</span>
<span class="line-removed"> 560 /**</span>
<span class="line-removed"> 561  * g_cclosure_marshal_VOID__ENUMv:</span>
<span class="line-removed"> 562  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 563  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 564  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 565  *  value.</span>
<span class="line-removed"> 566  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 567  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 568  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 569  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 570  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 571  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 572  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 573  *  @args.</span>
<span class="line-removed"> 574  *</span>
<span class="line-removed"> 575  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__ENUM().</span>
<span class="line-removed"> 576  */</span>
<span class="line-removed"> 577 /**</span>
<span class="line-removed"> 578  * g_cclosure_marshal_VOID__FLAGSv:</span>
<span class="line-removed"> 579  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 580  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 581  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 582  *  value.</span>
<span class="line-removed"> 583  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 584  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 585  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 586  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 587  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 588  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 589  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 590  *  @args.</span>
<span class="line-removed"> 591  *</span>
<span class="line-removed"> 592  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__FLAGS().</span>
<span class="line-removed"> 593  */</span>
<span class="line-removed"> 594 /**</span>
<span class="line-removed"> 595  * g_cclosure_marshal_VOID__FLOATv:</span>
<span class="line-removed"> 596  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 597  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 598  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 599  *  value.</span>
<span class="line-removed"> 600  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 601  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 602  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 603  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 604  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 605  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 606  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 607  *  @args.</span>
<span class="line-removed"> 608  *</span>
<span class="line-removed"> 609  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__FLOAT().</span>
<span class="line-removed"> 610  */</span>
<span class="line-removed"> 611 /**</span>
<span class="line-removed"> 612  * g_cclosure_marshal_VOID__DOUBLEv:</span>
<span class="line-removed"> 613  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 614  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 615  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 616  *  value.</span>
<span class="line-removed"> 617  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 618  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 619  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 620  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 621  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 622  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 623  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 624  *  @args.</span>
<span class="line-removed"> 625  *</span>
<span class="line-removed"> 626  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__DOUBLE().</span>
<span class="line-removed"> 627  */</span>
<span class="line-removed"> 628 /**</span>
<span class="line-removed"> 629  * g_cclosure_marshal_VOID__STRINGv:</span>
<span class="line-removed"> 630  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 631  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 632  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 633  *  value.</span>
<span class="line-removed"> 634  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 635  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 636  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 637  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 638  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 639  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 640  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 641  *  @args.</span>
<span class="line-removed"> 642  *</span>
<span class="line-removed"> 643  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__STRING().</span>
<span class="line-removed"> 644  */</span>
<span class="line-removed"> 645 /**</span>
<span class="line-removed"> 646  * g_cclosure_marshal_VOID__PARAMv:</span>
<span class="line-removed"> 647  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 648  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 649  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 650  *  value.</span>
<span class="line-removed"> 651  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 652  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 653  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 654  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 655  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 656  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 657  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 658  *  @args.</span>
<span class="line-removed"> 659  *</span>
<span class="line-removed"> 660  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__PARAM().</span>
<span class="line-removed"> 661  */</span>
<span class="line-removed"> 662 /**</span>
<span class="line-removed"> 663  * g_cclosure_marshal_VOID__BOXEDv:</span>
<span class="line-removed"> 664  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 665  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 666  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 667  *  value.</span>
<span class="line-removed"> 668  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 669  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 670  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 671  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 672  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 673  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 674  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 675  *  @args.</span>
<span class="line-removed"> 676  *</span>
<span class="line-removed"> 677  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__BOXED().</span>
<span class="line-removed"> 678  */</span>
<span class="line-removed"> 679 /**</span>
<span class="line-removed"> 680  * g_cclosure_marshal_VOID__POINTERv:</span>
<span class="line-removed"> 681  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 682  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 683  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 684  *  value.</span>
<span class="line-removed"> 685  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 686  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 687  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 688  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 689  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 690  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 691  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 692  *  @args.</span>
<span class="line-removed"> 693  *</span>
<span class="line-removed"> 694  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__POINTER().</span>
<span class="line-removed"> 695  */</span>
<span class="line-removed"> 696 /**</span>
<span class="line-removed"> 697  * g_cclosure_marshal_VOID__OBJECTv:</span>
<span class="line-removed"> 698  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 699  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 700  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 701  *  value.</span>
<span class="line-removed"> 702  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 703  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 704  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 705  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 706  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 707  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 708  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 709  *  @args.</span>
<span class="line-removed"> 710  *</span>
<span class="line-removed"> 711  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__OBJECT().</span>
<span class="line-removed"> 712  */</span>
<span class="line-removed"> 713 /**</span>
<span class="line-removed"> 714  * g_cclosure_marshal_VOID__VARIANTv:</span>
<span class="line-removed"> 715  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 716  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 717  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 718  *  value.</span>
<span class="line-removed"> 719  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 720  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 721  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 722  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 723  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 724  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 725  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 726  *  @args.</span>
<span class="line-removed"> 727  *</span>
<span class="line-removed"> 728  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__VARIANT().</span>
<span class="line-removed"> 729  */</span>
<span class="line-removed"> 730 /**</span>
<span class="line-removed"> 731  * g_cclosure_marshal_STRING__OBJECT_POINTERv:</span>
<span class="line-removed"> 732  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 733  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 734  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 735  *  value.</span>
<span class="line-removed"> 736  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 737  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 738  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 739  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 740  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 741  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 742  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 743  *  @args.</span>
<span class="line-removed"> 744  *</span>
<span class="line-removed"> 745  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_STRING__OBJECT_POINTER().</span>
<span class="line-removed"> 746  */</span>
<span class="line-removed"> 747 /**</span>
<span class="line-removed"> 748  * g_cclosure_marshal_VOID__UINT_POINTERv:</span>
<span class="line-removed"> 749  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 750  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 751  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 752  *  value.</span>
<span class="line-removed"> 753  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 754  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 755  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 756  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 757  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 758  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 759  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 760  *  @args.</span>
 761  *
<a name="2" id="anc2"></a><span class="line-modified"> 762  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UINT_POINTER().</span>
<span class="line-modified"> 763  */</span>
<span class="line-modified"> 764 /**</span>
<span class="line-modified"> 765  * g_cclosure_marshal_BOOLEAN__FLAGSv:</span>
<span class="line-removed"> 766  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 767  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 768  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 769  *  value.</span>
<span class="line-removed"> 770  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 771  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 772  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 773  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 774  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 775  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 776  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 777  *  @args.</span>
 778  *
<a name="3" id="anc3"></a><span class="line-modified"> 779  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_BOOLEAN__FLAGS().</span>
<span class="line-modified"> 780  */</span>
<span class="line-modified"> 781 /**</span>
<span class="line-modified"> 782  * g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv:</span>
<span class="line-removed"> 783  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 784  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 785  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 786  *  value.</span>
<span class="line-removed"> 787  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 788  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 789  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 790  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 791  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 792  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 793  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 794  *  @args.</span>
 795  *
<a name="4" id="anc4"></a><span class="line-modified"> 796  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_BOOLEAN__BOXED_BOXED().</span>

 797  */
 798 
<a name="5" id="anc5"></a>







 799 #ifdef G_ENABLE_DEBUG
 800 #define g_marshal_value_peek_boolean(v)  g_value_get_boolean (v)
 801 #define g_marshal_value_peek_char(v)     g_value_get_schar (v)
 802 #define g_marshal_value_peek_uchar(v)    g_value_get_uchar (v)
 803 #define g_marshal_value_peek_int(v)      g_value_get_int (v)
 804 #define g_marshal_value_peek_uint(v)     g_value_get_uint (v)
 805 #define g_marshal_value_peek_long(v)     g_value_get_long (v)
 806 #define g_marshal_value_peek_ulong(v)    g_value_get_ulong (v)
 807 #define g_marshal_value_peek_int64(v)    g_value_get_int64 (v)
 808 #define g_marshal_value_peek_uint64(v)   g_value_get_uint64 (v)
 809 #define g_marshal_value_peek_enum(v)     g_value_get_enum (v)
 810 #define g_marshal_value_peek_flags(v)    g_value_get_flags (v)
 811 #define g_marshal_value_peek_float(v)    g_value_get_float (v)
 812 #define g_marshal_value_peek_double(v)   g_value_get_double (v)
 813 #define g_marshal_value_peek_string(v)   (char*) g_value_get_string (v)
 814 #define g_marshal_value_peek_param(v)    g_value_get_param (v)
 815 #define g_marshal_value_peek_boxed(v)    g_value_get_boxed (v)
 816 #define g_marshal_value_peek_pointer(v)  g_value_get_pointer (v)
 817 #define g_marshal_value_peek_object(v)   g_value_get_object (v)
 818 #define g_marshal_value_peek_variant(v)  g_value_get_variant (v)
 819 #else /* !G_ENABLE_DEBUG */
 820 /* WARNING: This code accesses GValues directly, which is UNSUPPORTED API.
 821  *          Do not access GValues directly in your code. Instead, use the
 822  *          g_value_get_*() functions
 823  */
 824 #define g_marshal_value_peek_boolean(v)  (v)-&gt;data[0].v_int
 825 #define g_marshal_value_peek_char(v)     (v)-&gt;data[0].v_int
 826 #define g_marshal_value_peek_uchar(v)    (v)-&gt;data[0].v_uint
 827 #define g_marshal_value_peek_int(v)      (v)-&gt;data[0].v_int
 828 #define g_marshal_value_peek_uint(v)     (v)-&gt;data[0].v_uint
 829 #define g_marshal_value_peek_long(v)     (v)-&gt;data[0].v_long
 830 #define g_marshal_value_peek_ulong(v)    (v)-&gt;data[0].v_ulong
 831 #define g_marshal_value_peek_int64(v)    (v)-&gt;data[0].v_int64
 832 #define g_marshal_value_peek_uint64(v)   (v)-&gt;data[0].v_uint64
 833 #define g_marshal_value_peek_enum(v)     (v)-&gt;data[0].v_long
 834 #define g_marshal_value_peek_flags(v)    (v)-&gt;data[0].v_ulong
 835 #define g_marshal_value_peek_float(v)    (v)-&gt;data[0].v_float
 836 #define g_marshal_value_peek_double(v)   (v)-&gt;data[0].v_double
 837 #define g_marshal_value_peek_string(v)   (v)-&gt;data[0].v_pointer
 838 #define g_marshal_value_peek_param(v)    (v)-&gt;data[0].v_pointer
 839 #define g_marshal_value_peek_boxed(v)    (v)-&gt;data[0].v_pointer
 840 #define g_marshal_value_peek_pointer(v)  (v)-&gt;data[0].v_pointer
 841 #define g_marshal_value_peek_object(v)   (v)-&gt;data[0].v_pointer
 842 #define g_marshal_value_peek_variant(v)  (v)-&gt;data[0].v_pointer
 843 #endif /* !G_ENABLE_DEBUG */
 844 
 845 
<a name="6" id="anc6"></a><span class="line-modified"> 846 /* VOID:VOID (./gmarshal.list:6) */</span>
















 847 void
 848 g_cclosure_marshal_VOID__VOID (GClosure     *closure,
 849                                GValue       *return_value G_GNUC_UNUSED,
 850                                guint         n_param_values,
 851                                const GValue *param_values,
 852                                gpointer      invocation_hint G_GNUC_UNUSED,
 853                                gpointer      marshal_data)
 854 {
 855   typedef void (*GMarshalFunc_VOID__VOID) (gpointer     data1,
 856                                            gpointer     data2);
 857   GMarshalFunc_VOID__VOID callback;
 858   GCClosure *cc = (GCClosure*) closure;
 859   gpointer data1, data2;
 860 
 861   g_return_if_fail (n_param_values == 1);
 862 
 863   if (G_CCLOSURE_SWAP_DATA (closure))
 864     {
 865       data1 = closure-&gt;data;
 866       data2 = g_value_peek_pointer (param_values + 0);
 867     }
 868   else
 869     {
 870       data1 = g_value_peek_pointer (param_values + 0);
 871       data2 = closure-&gt;data;
 872     }
 873   callback = (GMarshalFunc_VOID__VOID) (marshal_data ? marshal_data : cc-&gt;callback);
 874 
 875   callback (data1,
 876             data2);
 877 }
<a name="7" id="anc7"></a>

















 878 void
 879 g_cclosure_marshal_VOID__VOIDv (GClosure     *closure,
 880                                 GValue       *return_value,
 881                                 gpointer      instance,
 882                                 va_list       args,
 883                                 gpointer      marshal_data,
 884                                 int           n_params,
 885                                 GType        *param_types)
 886 {
 887   typedef void (*GMarshalFunc_VOID__VOID) (gpointer     instance,
 888                                            gpointer     data);
 889   GCClosure *cc = (GCClosure*) closure;
 890   gpointer data1, data2;
 891   GMarshalFunc_VOID__VOID callback;
 892 
 893   if (G_CCLOSURE_SWAP_DATA (closure))
 894     {
 895       data1 = closure-&gt;data;
 896       data2 = instance;
 897     }
 898   else
 899     {
 900       data1 = instance;
 901       data2 = closure-&gt;data;
 902     }
 903   callback = (GMarshalFunc_VOID__VOID) (marshal_data ? marshal_data : cc-&gt;callback);
 904 
 905   callback (data1,
 906             data2);
 907 }
 908 
<a name="8" id="anc8"></a><span class="line-modified"> 909 </span>
<span class="line-modified"> 910 /* VOID:BOOLEAN (./gmarshal.list:7) */</span>
















 911 void
 912 g_cclosure_marshal_VOID__BOOLEAN (GClosure     *closure,
 913                                   GValue       *return_value G_GNUC_UNUSED,
 914                                   guint         n_param_values,
 915                                   const GValue *param_values,
 916                                   gpointer      invocation_hint G_GNUC_UNUSED,
 917                                   gpointer      marshal_data)
 918 {
 919   typedef void (*GMarshalFunc_VOID__BOOLEAN) (gpointer     data1,
 920                                               gboolean     arg_1,
 921                                               gpointer     data2);
 922   GMarshalFunc_VOID__BOOLEAN callback;
 923   GCClosure *cc = (GCClosure*) closure;
 924   gpointer data1, data2;
 925 
 926   g_return_if_fail (n_param_values == 2);
 927 
 928   if (G_CCLOSURE_SWAP_DATA (closure))
 929     {
 930       data1 = closure-&gt;data;
 931       data2 = g_value_peek_pointer (param_values + 0);
 932     }
 933   else
 934     {
 935       data1 = g_value_peek_pointer (param_values + 0);
 936       data2 = closure-&gt;data;
 937     }
 938   callback = (GMarshalFunc_VOID__BOOLEAN) (marshal_data ? marshal_data : cc-&gt;callback);
 939 
 940   callback (data1,
 941             g_marshal_value_peek_boolean (param_values + 1),
 942             data2);
 943 }
<a name="9" id="anc9"></a>

















 944 void
 945 g_cclosure_marshal_VOID__BOOLEANv (GClosure     *closure,
 946                                    GValue       *return_value,
 947                                    gpointer      instance,
 948                                    va_list       args,
 949                                    gpointer      marshal_data,
 950                                    int           n_params,
 951                                    GType        *param_types)
 952 {
 953   typedef void (*GMarshalFunc_VOID__BOOLEAN) (gpointer     instance,
 954                                               gboolean     arg_0,
 955                                               gpointer     data);
 956   GCClosure *cc = (GCClosure*) closure;
 957   gpointer data1, data2;
 958   GMarshalFunc_VOID__BOOLEAN callback;
 959   gboolean arg0;
 960   va_list args_copy;
 961 
 962   G_VA_COPY (args_copy, args);
 963   arg0 = (gboolean) va_arg (args_copy, gboolean);
 964   va_end (args_copy);
 965 
 966   if (G_CCLOSURE_SWAP_DATA (closure))
 967     {
 968       data1 = closure-&gt;data;
 969       data2 = instance;
 970     }
 971   else
 972     {
 973       data1 = instance;
 974       data2 = closure-&gt;data;
 975     }
 976   callback = (GMarshalFunc_VOID__BOOLEAN) (marshal_data ? marshal_data : cc-&gt;callback);
 977 
 978   callback (data1,
 979             arg0,
 980             data2);
 981 }
 982 
<a name="10" id="anc10"></a><span class="line-modified"> 983 </span>
<span class="line-modified"> 984 /* VOID:CHAR (./gmarshal.list:8) */</span>
















 985 void
 986 g_cclosure_marshal_VOID__CHAR (GClosure     *closure,
 987                                GValue       *return_value G_GNUC_UNUSED,
 988                                guint         n_param_values,
 989                                const GValue *param_values,
 990                                gpointer      invocation_hint G_GNUC_UNUSED,
 991                                gpointer      marshal_data)
 992 {
 993   typedef void (*GMarshalFunc_VOID__CHAR) (gpointer     data1,
 994                                            gchar        arg_1,
 995                                            gpointer     data2);
 996   GMarshalFunc_VOID__CHAR callback;
 997   GCClosure *cc = (GCClosure*) closure;
 998   gpointer data1, data2;
 999 
1000   g_return_if_fail (n_param_values == 2);
1001 
1002   if (G_CCLOSURE_SWAP_DATA (closure))
1003     {
1004       data1 = closure-&gt;data;
1005       data2 = g_value_peek_pointer (param_values + 0);
1006     }
1007   else
1008     {
1009       data1 = g_value_peek_pointer (param_values + 0);
1010       data2 = closure-&gt;data;
1011     }
1012   callback = (GMarshalFunc_VOID__CHAR) (marshal_data ? marshal_data : cc-&gt;callback);
1013 
1014   callback (data1,
1015             g_marshal_value_peek_char (param_values + 1),
1016             data2);
1017 }
<a name="11" id="anc11"></a>

















1018 void
1019 g_cclosure_marshal_VOID__CHARv (GClosure     *closure,
1020                                 GValue       *return_value,
1021                                 gpointer      instance,
1022                                 va_list       args,
1023                                 gpointer      marshal_data,
1024                                 int           n_params,
1025                                 GType        *param_types)
1026 {
1027   typedef void (*GMarshalFunc_VOID__CHAR) (gpointer     instance,
1028                                            gchar        arg_0,
1029                                            gpointer     data);
1030   GCClosure *cc = (GCClosure*) closure;
1031   gpointer data1, data2;
1032   GMarshalFunc_VOID__CHAR callback;
1033   gchar arg0;
1034   va_list args_copy;
1035 
1036   G_VA_COPY (args_copy, args);
1037   arg0 = (gchar) va_arg (args_copy, gint);
1038   va_end (args_copy);
1039 
1040   if (G_CCLOSURE_SWAP_DATA (closure))
1041     {
1042       data1 = closure-&gt;data;
1043       data2 = instance;
1044     }
1045   else
1046     {
1047       data1 = instance;
1048       data2 = closure-&gt;data;
1049     }
1050   callback = (GMarshalFunc_VOID__CHAR) (marshal_data ? marshal_data : cc-&gt;callback);
1051 
1052   callback (data1,
1053             arg0,
1054             data2);
1055 }
1056 
<a name="12" id="anc12"></a><span class="line-modified">1057 </span>
<span class="line-modified">1058 /* VOID:UCHAR (./gmarshal.list:9) */</span>
















1059 void
1060 g_cclosure_marshal_VOID__UCHAR (GClosure     *closure,
1061                                 GValue       *return_value G_GNUC_UNUSED,
1062                                 guint         n_param_values,
1063                                 const GValue *param_values,
1064                                 gpointer      invocation_hint G_GNUC_UNUSED,
1065                                 gpointer      marshal_data)
1066 {
1067   typedef void (*GMarshalFunc_VOID__UCHAR) (gpointer     data1,
1068                                             guchar       arg_1,
1069                                             gpointer     data2);
1070   GMarshalFunc_VOID__UCHAR callback;
1071   GCClosure *cc = (GCClosure*) closure;
1072   gpointer data1, data2;
1073 
1074   g_return_if_fail (n_param_values == 2);
1075 
1076   if (G_CCLOSURE_SWAP_DATA (closure))
1077     {
1078       data1 = closure-&gt;data;
1079       data2 = g_value_peek_pointer (param_values + 0);
1080     }
1081   else
1082     {
1083       data1 = g_value_peek_pointer (param_values + 0);
1084       data2 = closure-&gt;data;
1085     }
1086   callback = (GMarshalFunc_VOID__UCHAR) (marshal_data ? marshal_data : cc-&gt;callback);
1087 
1088   callback (data1,
1089             g_marshal_value_peek_uchar (param_values + 1),
1090             data2);
1091 }
<a name="13" id="anc13"></a>

















1092 void
1093 g_cclosure_marshal_VOID__UCHARv (GClosure     *closure,
1094                                  GValue       *return_value,
1095                                  gpointer      instance,
1096                                  va_list       args,
1097                                  gpointer      marshal_data,
1098                                  int           n_params,
1099                                  GType        *param_types)
1100 {
1101   typedef void (*GMarshalFunc_VOID__UCHAR) (gpointer     instance,
1102                                             guchar       arg_0,
1103                                             gpointer     data);
1104   GCClosure *cc = (GCClosure*) closure;
1105   gpointer data1, data2;
1106   GMarshalFunc_VOID__UCHAR callback;
1107   guchar arg0;
1108   va_list args_copy;
1109 
1110   G_VA_COPY (args_copy, args);
1111   arg0 = (guchar) va_arg (args_copy, guint);
1112   va_end (args_copy);
1113 
1114   if (G_CCLOSURE_SWAP_DATA (closure))
1115     {
1116       data1 = closure-&gt;data;
1117       data2 = instance;
1118     }
1119   else
1120     {
1121       data1 = instance;
1122       data2 = closure-&gt;data;
1123     }
1124   callback = (GMarshalFunc_VOID__UCHAR) (marshal_data ? marshal_data : cc-&gt;callback);
1125 
1126   callback (data1,
1127             arg0,
1128             data2);
1129 }
1130 
<a name="14" id="anc14"></a><span class="line-modified">1131 </span>
<span class="line-modified">1132 /* VOID:INT (./gmarshal.list:10) */</span>
















1133 void
1134 g_cclosure_marshal_VOID__INT (GClosure     *closure,
1135                               GValue       *return_value G_GNUC_UNUSED,
1136                               guint         n_param_values,
1137                               const GValue *param_values,
1138                               gpointer      invocation_hint G_GNUC_UNUSED,
1139                               gpointer      marshal_data)
1140 {
1141   typedef void (*GMarshalFunc_VOID__INT) (gpointer     data1,
1142                                           gint         arg_1,
1143                                           gpointer     data2);
1144   GMarshalFunc_VOID__INT callback;
1145   GCClosure *cc = (GCClosure*) closure;
1146   gpointer data1, data2;
1147 
1148   g_return_if_fail (n_param_values == 2);
1149 
1150   if (G_CCLOSURE_SWAP_DATA (closure))
1151     {
1152       data1 = closure-&gt;data;
1153       data2 = g_value_peek_pointer (param_values + 0);
1154     }
1155   else
1156     {
1157       data1 = g_value_peek_pointer (param_values + 0);
1158       data2 = closure-&gt;data;
1159     }
1160   callback = (GMarshalFunc_VOID__INT) (marshal_data ? marshal_data : cc-&gt;callback);
1161 
1162   callback (data1,
1163             g_marshal_value_peek_int (param_values + 1),
1164             data2);
1165 }
<a name="15" id="anc15"></a>

















1166 void
1167 g_cclosure_marshal_VOID__INTv (GClosure     *closure,
1168                                GValue       *return_value,
1169                                gpointer      instance,
1170                                va_list       args,
1171                                gpointer      marshal_data,
1172                                int           n_params,
1173                                GType        *param_types)
1174 {
1175   typedef void (*GMarshalFunc_VOID__INT) (gpointer     instance,
1176                                           gint         arg_0,
1177                                           gpointer     data);
1178   GCClosure *cc = (GCClosure*) closure;
1179   gpointer data1, data2;
1180   GMarshalFunc_VOID__INT callback;
1181   gint arg0;
1182   va_list args_copy;
1183 
1184  G_VA_COPY (args_copy, args);
1185   arg0 = (gint) va_arg (args_copy, gint);
1186   va_end (args_copy);
1187 
1188   if (G_CCLOSURE_SWAP_DATA (closure))
1189     {
1190       data1 = closure-&gt;data;
1191       data2 = instance;
1192     }
1193   else
1194     {
1195       data1 = instance;
1196       data2 = closure-&gt;data;
1197     }
1198   callback = (GMarshalFunc_VOID__INT) (marshal_data ? marshal_data : cc-&gt;callback);
1199 
1200   callback (data1,
1201             arg0,
1202             data2);
1203 }
1204 
<a name="16" id="anc16"></a><span class="line-modified">1205 </span>
<span class="line-modified">1206 /* VOID:UINT (./gmarshal.list:11) */</span>
















1207 void
1208 g_cclosure_marshal_VOID__UINT (GClosure     *closure,
1209                                GValue       *return_value G_GNUC_UNUSED,
1210                                guint         n_param_values,
1211                                const GValue *param_values,
1212                                gpointer      invocation_hint G_GNUC_UNUSED,
1213                                gpointer      marshal_data)
1214 {
1215   typedef void (*GMarshalFunc_VOID__UINT) (gpointer     data1,
1216                                            guint        arg_1,
1217                                            gpointer     data2);
1218   GMarshalFunc_VOID__UINT callback;
1219   GCClosure *cc = (GCClosure*) closure;
1220   gpointer data1, data2;
1221 
1222   g_return_if_fail (n_param_values == 2);
1223 
1224   if (G_CCLOSURE_SWAP_DATA (closure))
1225     {
1226       data1 = closure-&gt;data;
1227       data2 = g_value_peek_pointer (param_values + 0);
1228     }
1229   else
1230     {
1231       data1 = g_value_peek_pointer (param_values + 0);
1232       data2 = closure-&gt;data;
1233     }
1234   callback = (GMarshalFunc_VOID__UINT) (marshal_data ? marshal_data : cc-&gt;callback);
1235 
1236   callback (data1,
1237             g_marshal_value_peek_uint (param_values + 1),
1238             data2);
1239 }
<a name="17" id="anc17"></a>

















1240 void
1241 g_cclosure_marshal_VOID__UINTv (GClosure     *closure,
1242                                 GValue       *return_value,
1243                                 gpointer      instance,
1244                                 va_list       args,
1245                                 gpointer      marshal_data,
1246                                 int           n_params,
1247                                 GType        *param_types)
1248 {
1249   typedef void (*GMarshalFunc_VOID__UINT) (gpointer     instance,
1250                                            guint        arg_0,
1251                                            gpointer     data);
1252   GCClosure *cc = (GCClosure*) closure;
1253   gpointer data1, data2;
1254   GMarshalFunc_VOID__UINT callback;
1255   guint arg0;
1256   va_list args_copy;
1257 
1258   G_VA_COPY (args_copy, args);
1259   arg0 = (guint) va_arg (args_copy, guint);
1260   va_end (args_copy);
1261 
1262   if (G_CCLOSURE_SWAP_DATA (closure))
1263     {
1264       data1 = closure-&gt;data;
1265       data2 = instance;
1266     }
1267   else
1268     {
1269       data1 = instance;
1270       data2 = closure-&gt;data;
1271     }
1272   callback = (GMarshalFunc_VOID__UINT) (marshal_data ? marshal_data : cc-&gt;callback);
1273 
1274   callback (data1,
1275             arg0,
1276             data2);
1277 }
1278 
<a name="18" id="anc18"></a><span class="line-modified">1279 </span>
<span class="line-modified">1280 /* VOID:LONG (./gmarshal.list:12) */</span>
















1281 void
1282 g_cclosure_marshal_VOID__LONG (GClosure     *closure,
1283                                GValue       *return_value G_GNUC_UNUSED,
1284                                guint         n_param_values,
1285                                const GValue *param_values,
1286                                gpointer      invocation_hint G_GNUC_UNUSED,
1287                                gpointer      marshal_data)
1288 {
1289   typedef void (*GMarshalFunc_VOID__LONG) (gpointer     data1,
1290                                            glong        arg_1,
1291                                            gpointer     data2);
1292   GMarshalFunc_VOID__LONG callback;
1293   GCClosure *cc = (GCClosure*) closure;
1294   gpointer data1, data2;
1295 
1296   g_return_if_fail (n_param_values == 2);
1297 
1298   if (G_CCLOSURE_SWAP_DATA (closure))
1299     {
1300       data1 = closure-&gt;data;
1301       data2 = g_value_peek_pointer (param_values + 0);
1302     }
1303   else
1304     {
1305       data1 = g_value_peek_pointer (param_values + 0);
1306       data2 = closure-&gt;data;
1307     }
1308   callback = (GMarshalFunc_VOID__LONG) (marshal_data ? marshal_data : cc-&gt;callback);
1309 
1310   callback (data1,
1311             g_marshal_value_peek_long (param_values + 1),
1312             data2);
1313 }
<a name="19" id="anc19"></a>

















1314 void
1315 g_cclosure_marshal_VOID__LONGv (GClosure     *closure,
1316                                 GValue       *return_value,
1317                                 gpointer      instance,
1318                                 va_list       args,
1319                                 gpointer      marshal_data,
1320                                 int           n_params,
1321                                 GType        *param_types)
1322 {
1323   typedef void (*GMarshalFunc_VOID__LONG) (gpointer     instance,
1324                                            glong        arg_0,
1325                                            gpointer     data);
1326   GCClosure *cc = (GCClosure*) closure;
1327   gpointer data1, data2;
1328   GMarshalFunc_VOID__LONG callback;
1329   glong arg0;
1330   va_list args_copy;
1331 
1332   G_VA_COPY (args_copy, args);
1333   arg0 = (glong) va_arg (args_copy, glong);
1334   va_end (args_copy);
1335 
1336   if (G_CCLOSURE_SWAP_DATA (closure))
1337     {
1338       data1 = closure-&gt;data;
1339       data2 = instance;
1340     }
1341   else
1342     {
1343       data1 = instance;
1344       data2 = closure-&gt;data;
1345     }
1346   callback = (GMarshalFunc_VOID__LONG) (marshal_data ? marshal_data : cc-&gt;callback);
1347 
1348   callback (data1,
1349             arg0,
1350             data2);
1351 }
1352 
<a name="20" id="anc20"></a><span class="line-modified">1353 </span>
<span class="line-modified">1354 /* VOID:ULONG (./gmarshal.list:13) */</span>
















1355 void
1356 g_cclosure_marshal_VOID__ULONG (GClosure     *closure,
1357                                 GValue       *return_value G_GNUC_UNUSED,
1358                                 guint         n_param_values,
1359                                 const GValue *param_values,
1360                                 gpointer      invocation_hint G_GNUC_UNUSED,
1361                                 gpointer      marshal_data)
1362 {
1363   typedef void (*GMarshalFunc_VOID__ULONG) (gpointer     data1,
1364                                             gulong       arg_1,
1365                                             gpointer     data2);
1366   GMarshalFunc_VOID__ULONG callback;
1367   GCClosure *cc = (GCClosure*) closure;
1368   gpointer data1, data2;
1369 
1370   g_return_if_fail (n_param_values == 2);
1371 
1372   if (G_CCLOSURE_SWAP_DATA (closure))
1373     {
1374       data1 = closure-&gt;data;
1375       data2 = g_value_peek_pointer (param_values + 0);
1376     }
1377   else
1378     {
1379       data1 = g_value_peek_pointer (param_values + 0);
1380       data2 = closure-&gt;data;
1381     }
1382   callback = (GMarshalFunc_VOID__ULONG) (marshal_data ? marshal_data : cc-&gt;callback);
1383 
1384   callback (data1,
1385             g_marshal_value_peek_ulong (param_values + 1),
1386             data2);
1387 }
<a name="21" id="anc21"></a>

















1388 void
1389 g_cclosure_marshal_VOID__ULONGv (GClosure     *closure,
1390                                  GValue       *return_value,
1391                                  gpointer      instance,
1392                                  va_list       args,
1393                                  gpointer      marshal_data,
1394                                  int           n_params,
1395                                  GType        *param_types)
1396 {
1397   typedef void (*GMarshalFunc_VOID__ULONG) (gpointer     instance,
1398                                             gulong       arg_0,
1399                                             gpointer     data);
1400   GCClosure *cc = (GCClosure*) closure;
1401   gpointer data1, data2;
1402   GMarshalFunc_VOID__ULONG callback;
1403   gulong arg0;
1404   va_list args_copy;
1405 
1406   G_VA_COPY (args_copy, args);
1407   arg0 = (gulong) va_arg (args_copy, gulong);
1408   va_end (args_copy);
1409 
1410   if (G_CCLOSURE_SWAP_DATA (closure))
1411     {
1412       data1 = closure-&gt;data;
1413       data2 = instance;
1414     }
1415   else
1416     {
1417       data1 = instance;
1418       data2 = closure-&gt;data;
1419     }
1420   callback = (GMarshalFunc_VOID__ULONG) (marshal_data ? marshal_data : cc-&gt;callback);
1421 
1422   callback (data1,
1423             arg0,
1424             data2);
1425 }
1426 
<a name="22" id="anc22"></a><span class="line-modified">1427 </span>
<span class="line-modified">1428 /* VOID:ENUM (./gmarshal.list:14) */</span>
















1429 void
1430 g_cclosure_marshal_VOID__ENUM (GClosure     *closure,
1431                                GValue       *return_value G_GNUC_UNUSED,
1432                                guint         n_param_values,
1433                                const GValue *param_values,
1434                                gpointer      invocation_hint G_GNUC_UNUSED,
1435                                gpointer      marshal_data)
1436 {
1437   typedef void (*GMarshalFunc_VOID__ENUM) (gpointer     data1,
1438                                            gint         arg_1,
1439                                            gpointer     data2);
1440   GMarshalFunc_VOID__ENUM callback;
1441   GCClosure *cc = (GCClosure*) closure;
1442   gpointer data1, data2;
1443 
1444   g_return_if_fail (n_param_values == 2);
1445 
1446   if (G_CCLOSURE_SWAP_DATA (closure))
1447     {
1448       data1 = closure-&gt;data;
1449       data2 = g_value_peek_pointer (param_values + 0);
1450     }
1451   else
1452     {
1453       data1 = g_value_peek_pointer (param_values + 0);
1454       data2 = closure-&gt;data;
1455     }
1456   callback = (GMarshalFunc_VOID__ENUM) (marshal_data ? marshal_data : cc-&gt;callback);
1457 
1458   callback (data1,
1459             g_marshal_value_peek_enum (param_values + 1),
1460             data2);
1461 }
<a name="23" id="anc23"></a>

















1462 void
1463 g_cclosure_marshal_VOID__ENUMv (GClosure     *closure,
1464                                 GValue       *return_value,
1465                                 gpointer      instance,
1466                                 va_list       args,
1467                                 gpointer      marshal_data,
1468                                 int           n_params,
1469                                 GType        *param_types)
1470 {
1471   typedef void (*GMarshalFunc_VOID__ENUM) (gpointer     instance,
1472                                            gint         arg_0,
1473                                            gpointer     data);
1474   GCClosure *cc = (GCClosure*) closure;
1475   gpointer data1, data2;
1476   GMarshalFunc_VOID__ENUM callback;
1477   gint arg0;
1478   va_list args_copy;
1479 
1480   G_VA_COPY (args_copy, args);
1481   arg0 = (gint) va_arg (args_copy, gint);
1482   va_end (args_copy);
1483 
1484   if (G_CCLOSURE_SWAP_DATA (closure))
1485     {
1486       data1 = closure-&gt;data;
1487       data2 = instance;
1488     }
1489   else
1490     {
1491       data1 = instance;
1492       data2 = closure-&gt;data;
1493     }
1494   callback = (GMarshalFunc_VOID__ENUM) (marshal_data ? marshal_data : cc-&gt;callback);
1495 
1496   callback (data1,
1497             arg0,
1498             data2);
1499 }
1500 
<a name="24" id="anc24"></a><span class="line-modified">1501 </span>
<span class="line-modified">1502 /* VOID:FLAGS (./gmarshal.list:15) */</span>
















1503 void
1504 g_cclosure_marshal_VOID__FLAGS (GClosure     *closure,
1505                                 GValue       *return_value G_GNUC_UNUSED,
1506                                 guint         n_param_values,
1507                                 const GValue *param_values,
1508                                 gpointer      invocation_hint G_GNUC_UNUSED,
1509                                 gpointer      marshal_data)
1510 {
1511   typedef void (*GMarshalFunc_VOID__FLAGS) (gpointer     data1,
1512                                             guint        arg_1,
1513                                             gpointer     data2);
1514   GMarshalFunc_VOID__FLAGS callback;
1515   GCClosure *cc = (GCClosure*) closure;
1516   gpointer data1, data2;
1517 
1518   g_return_if_fail (n_param_values == 2);
1519 
1520   if (G_CCLOSURE_SWAP_DATA (closure))
1521     {
1522       data1 = closure-&gt;data;
1523       data2 = g_value_peek_pointer (param_values + 0);
1524     }
1525   else
1526     {
1527       data1 = g_value_peek_pointer (param_values + 0);
1528       data2 = closure-&gt;data;
1529     }
1530   callback = (GMarshalFunc_VOID__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
1531 
1532   callback (data1,
1533             g_marshal_value_peek_flags (param_values + 1),
1534             data2);
1535 }
<a name="25" id="anc25"></a>

















1536 void
1537 g_cclosure_marshal_VOID__FLAGSv (GClosure     *closure,
1538                                  GValue       *return_value,
1539                                  gpointer      instance,
1540                                  va_list       args,
1541                                  gpointer      marshal_data,
1542                                  int           n_params,
1543                                  GType        *param_types)
1544 {
1545   typedef void (*GMarshalFunc_VOID__FLAGS) (gpointer     instance,
1546                                             guint        arg_0,
1547                                             gpointer     data);
1548   GCClosure *cc = (GCClosure*) closure;
1549   gpointer data1, data2;
1550   GMarshalFunc_VOID__FLAGS callback;
1551   guint arg0;
1552   va_list args_copy;
1553 
1554   G_VA_COPY (args_copy, args);
1555   arg0 = (guint) va_arg (args_copy, guint);
1556   va_end (args_copy);
1557 
1558   if (G_CCLOSURE_SWAP_DATA (closure))
1559     {
1560       data1 = closure-&gt;data;
1561       data2 = instance;
1562     }
1563   else
1564     {
1565       data1 = instance;
1566       data2 = closure-&gt;data;
1567     }
1568   callback = (GMarshalFunc_VOID__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
1569 
1570   callback (data1,
1571             arg0,
1572             data2);
1573 }
1574 
<a name="26" id="anc26"></a><span class="line-modified">1575 </span>
<span class="line-modified">1576 /* VOID:FLOAT (./gmarshal.list:16) */</span>
















1577 void
1578 g_cclosure_marshal_VOID__FLOAT (GClosure     *closure,
1579                                 GValue       *return_value G_GNUC_UNUSED,
1580                                 guint         n_param_values,
1581                                 const GValue *param_values,
1582                                 gpointer      invocation_hint G_GNUC_UNUSED,
1583                                 gpointer      marshal_data)
1584 {
1585   typedef void (*GMarshalFunc_VOID__FLOAT) (gpointer     data1,
1586                                             gfloat       arg_1,
1587                                             gpointer     data2);
1588   GMarshalFunc_VOID__FLOAT callback;
1589   GCClosure *cc = (GCClosure*) closure;
1590   gpointer data1, data2;
1591 
1592   g_return_if_fail (n_param_values == 2);
1593 
1594   if (G_CCLOSURE_SWAP_DATA (closure))
1595     {
1596       data1 = closure-&gt;data;
1597       data2 = g_value_peek_pointer (param_values + 0);
1598     }
1599   else
1600     {
1601       data1 = g_value_peek_pointer (param_values + 0);
1602       data2 = closure-&gt;data;
1603     }
1604   callback = (GMarshalFunc_VOID__FLOAT) (marshal_data ? marshal_data : cc-&gt;callback);
1605 
1606   callback (data1,
1607             g_marshal_value_peek_float (param_values + 1),
1608             data2);
1609 }
<a name="27" id="anc27"></a>

















1610 void
1611 g_cclosure_marshal_VOID__FLOATv (GClosure     *closure,
1612                                  GValue       *return_value,
1613                                  gpointer      instance,
1614                                  va_list       args,
1615                                  gpointer      marshal_data,
1616                                  int           n_params,
1617                                  GType        *param_types)
1618 {
1619   typedef void (*GMarshalFunc_VOID__FLOAT) (gpointer     instance,
1620                                             gfloat       arg_0,
1621                                             gpointer     data);
1622   GCClosure *cc = (GCClosure*) closure;
1623   gpointer data1, data2;
1624   GMarshalFunc_VOID__FLOAT callback;
1625   gfloat arg0;
1626   va_list args_copy;
1627 
1628   G_VA_COPY (args_copy, args);
1629   arg0 = (gfloat) va_arg (args_copy, gdouble);
1630   va_end (args_copy);
1631 
1632   if (G_CCLOSURE_SWAP_DATA (closure))
1633     {
1634       data1 = closure-&gt;data;
1635       data2 = instance;
1636     }
1637   else
1638     {
1639       data1 = instance;
1640       data2 = closure-&gt;data;
1641     }
1642   callback = (GMarshalFunc_VOID__FLOAT) (marshal_data ? marshal_data : cc-&gt;callback);
1643 
1644   callback (data1,
1645             arg0,
1646             data2);
1647 }
1648 
<a name="28" id="anc28"></a><span class="line-modified">1649 </span>
<span class="line-modified">1650 /* VOID:DOUBLE (./gmarshal.list:17) */</span>
















1651 void
1652 g_cclosure_marshal_VOID__DOUBLE (GClosure     *closure,
1653                                  GValue       *return_value G_GNUC_UNUSED,
1654                                  guint         n_param_values,
1655                                  const GValue *param_values,
1656                                  gpointer      invocation_hint G_GNUC_UNUSED,
1657                                  gpointer      marshal_data)
1658 {
1659   typedef void (*GMarshalFunc_VOID__DOUBLE) (gpointer     data1,
1660                                              gdouble      arg_1,
1661                                              gpointer     data2);
1662   GMarshalFunc_VOID__DOUBLE callback;
1663   GCClosure *cc = (GCClosure*) closure;
1664   gpointer data1, data2;
1665 
1666   g_return_if_fail (n_param_values == 2);
1667 
1668   if (G_CCLOSURE_SWAP_DATA (closure))
1669     {
1670       data1 = closure-&gt;data;
1671       data2 = g_value_peek_pointer (param_values + 0);
1672     }
1673   else
1674     {
1675       data1 = g_value_peek_pointer (param_values + 0);
1676       data2 = closure-&gt;data;
1677     }
1678   callback = (GMarshalFunc_VOID__DOUBLE) (marshal_data ? marshal_data : cc-&gt;callback);
1679 
1680   callback (data1,
1681             g_marshal_value_peek_double (param_values + 1),
1682             data2);
1683 }
<a name="29" id="anc29"></a>

















1684 void
1685 g_cclosure_marshal_VOID__DOUBLEv (GClosure     *closure,
1686                                   GValue       *return_value,
1687                                   gpointer      instance,
1688                                   va_list       args,
1689                                   gpointer      marshal_data,
1690                                   int           n_params,
1691                                   GType        *param_types)
1692 {
1693   typedef void (*GMarshalFunc_VOID__DOUBLE) (gpointer     instance,
1694                                              gdouble      arg_0,
1695                                              gpointer     data);
1696   GCClosure *cc = (GCClosure*) closure;
1697   gpointer data1, data2;
1698   GMarshalFunc_VOID__DOUBLE callback;
1699   gdouble arg0;
1700   va_list args_copy;
1701 
1702   G_VA_COPY (args_copy, args);
1703   arg0 = (gdouble) va_arg (args_copy, gdouble);
1704   va_end (args_copy);
1705 
1706   if (G_CCLOSURE_SWAP_DATA (closure))
1707     {
1708       data1 = closure-&gt;data;
1709       data2 = instance;
1710     }
1711   else
1712     {
1713       data1 = instance;
1714       data2 = closure-&gt;data;
1715     }
1716   callback = (GMarshalFunc_VOID__DOUBLE) (marshal_data ? marshal_data : cc-&gt;callback);
1717 
1718   callback (data1,
1719             arg0,
1720             data2);
1721 }
1722 
<a name="30" id="anc30"></a><span class="line-modified">1723 </span>
<span class="line-modified">1724 /* VOID:STRING (./gmarshal.list:18) */</span>
















1725 void
1726 g_cclosure_marshal_VOID__STRING (GClosure     *closure,
1727                                  GValue       *return_value G_GNUC_UNUSED,
1728                                  guint         n_param_values,
1729                                  const GValue *param_values,
1730                                  gpointer      invocation_hint G_GNUC_UNUSED,
1731                                  gpointer      marshal_data)
1732 {
1733   typedef void (*GMarshalFunc_VOID__STRING) (gpointer     data1,
1734                                              gpointer     arg_1,
1735                                              gpointer     data2);
1736   GMarshalFunc_VOID__STRING callback;
1737   GCClosure *cc = (GCClosure*) closure;
1738   gpointer data1, data2;
1739 
1740   g_return_if_fail (n_param_values == 2);
1741 
1742   if (G_CCLOSURE_SWAP_DATA (closure))
1743     {
1744       data1 = closure-&gt;data;
1745       data2 = g_value_peek_pointer (param_values + 0);
1746     }
1747   else
1748     {
1749       data1 = g_value_peek_pointer (param_values + 0);
1750       data2 = closure-&gt;data;
1751     }
1752   callback = (GMarshalFunc_VOID__STRING) (marshal_data ? marshal_data : cc-&gt;callback);
1753 
1754   callback (data1,
1755             g_marshal_value_peek_string (param_values + 1),
1756             data2);
1757 }
<a name="31" id="anc31"></a>

















1758 void
1759 g_cclosure_marshal_VOID__STRINGv (GClosure     *closure,
1760                                   GValue       *return_value,
1761                                   gpointer      instance,
1762                                   va_list       args,
1763                                   gpointer      marshal_data,
1764                                   int           n_params,
1765                                   GType        *param_types)
1766 {
1767   typedef void (*GMarshalFunc_VOID__STRING) (gpointer     instance,
1768                                              gpointer     arg_0,
1769                                              gpointer     data);
1770   GCClosure *cc = (GCClosure*) closure;
1771   gpointer data1, data2;
1772   GMarshalFunc_VOID__STRING callback;
1773   gpointer arg0;
1774   va_list args_copy;
1775 
1776   G_VA_COPY (args_copy, args);
1777   arg0 = (gpointer) va_arg (args_copy, gpointer);
1778   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1779     arg0 = g_strdup (arg0);
1780   va_end (args_copy);
1781 
1782   if (G_CCLOSURE_SWAP_DATA (closure))
1783     {
1784       data1 = closure-&gt;data;
1785       data2 = instance;
1786     }
1787   else
1788     {
1789       data1 = instance;
1790       data2 = closure-&gt;data;
1791     }
1792   callback = (GMarshalFunc_VOID__STRING) (marshal_data ? marshal_data : cc-&gt;callback);
1793 
1794   callback (data1,
1795             arg0,
1796             data2);
1797   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1798     g_free (arg0);
1799 }
1800 
<a name="32" id="anc32"></a><span class="line-modified">1801 </span>
<span class="line-modified">1802 /* VOID:PARAM (./gmarshal.list:19) */</span>
















1803 void
1804 g_cclosure_marshal_VOID__PARAM (GClosure     *closure,
1805                                 GValue       *return_value G_GNUC_UNUSED,
1806                                 guint         n_param_values,
1807                                 const GValue *param_values,
1808                                 gpointer      invocation_hint G_GNUC_UNUSED,
1809                                 gpointer      marshal_data)
1810 {
1811   typedef void (*GMarshalFunc_VOID__PARAM) (gpointer     data1,
1812                                             gpointer     arg_1,
1813                                             gpointer     data2);
1814   GMarshalFunc_VOID__PARAM callback;
1815   GCClosure *cc = (GCClosure*) closure;
1816   gpointer data1, data2;
1817 
1818   g_return_if_fail (n_param_values == 2);
1819 
1820   if (G_CCLOSURE_SWAP_DATA (closure))
1821     {
1822       data1 = closure-&gt;data;
1823       data2 = g_value_peek_pointer (param_values + 0);
1824     }
1825   else
1826     {
1827       data1 = g_value_peek_pointer (param_values + 0);
1828       data2 = closure-&gt;data;
1829     }
1830   callback = (GMarshalFunc_VOID__PARAM) (marshal_data ? marshal_data : cc-&gt;callback);
1831 
1832   callback (data1,
1833             g_marshal_value_peek_param (param_values + 1),
1834             data2);
1835 }
<a name="33" id="anc33"></a>

















1836 void
1837 g_cclosure_marshal_VOID__PARAMv (GClosure     *closure,
1838                                  GValue       *return_value,
1839                                  gpointer      instance,
1840                                  va_list       args,
1841                                  gpointer      marshal_data,
1842                                  int           n_params,
1843                                  GType        *param_types)
1844 {
1845   typedef void (*GMarshalFunc_VOID__PARAM) (gpointer     instance,
1846                                             gpointer     arg_0,
1847                                             gpointer     data);
1848   GCClosure *cc = (GCClosure*) closure;
1849   gpointer data1, data2;
1850   GMarshalFunc_VOID__PARAM callback;
1851   gpointer arg0;
1852   va_list args_copy;
1853 
1854   G_VA_COPY (args_copy, args);
1855   arg0 = (gpointer) va_arg (args_copy, gpointer);
1856   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1857     arg0 = g_param_spec_ref (arg0);
1858   va_end (args_copy);
1859 
1860   if (G_CCLOSURE_SWAP_DATA (closure))
1861     {
1862       data1 = closure-&gt;data;
1863       data2 = instance;
1864     }
1865   else
1866     {
1867       data1 = instance;
1868       data2 = closure-&gt;data;
1869     }
1870   callback = (GMarshalFunc_VOID__PARAM) (marshal_data ? marshal_data : cc-&gt;callback);
1871 
1872   callback (data1,
1873             arg0,
1874             data2);
1875   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1876     g_param_spec_unref (arg0);
1877 }
1878 
<a name="34" id="anc34"></a><span class="line-modified">1879 </span>
<span class="line-modified">1880 /* VOID:BOXED (./gmarshal.list:20) */</span>
















1881 void
1882 g_cclosure_marshal_VOID__BOXED (GClosure     *closure,
1883                                 GValue       *return_value G_GNUC_UNUSED,
1884                                 guint         n_param_values,
1885                                 const GValue *param_values,
1886                                 gpointer      invocation_hint G_GNUC_UNUSED,
1887                                 gpointer      marshal_data)
1888 {
1889   typedef void (*GMarshalFunc_VOID__BOXED) (gpointer     data1,
1890                                             gpointer     arg_1,
1891                                             gpointer     data2);
1892   GMarshalFunc_VOID__BOXED callback;
1893   GCClosure *cc = (GCClosure*) closure;
1894   gpointer data1, data2;
1895 
1896   g_return_if_fail (n_param_values == 2);
1897 
1898   if (G_CCLOSURE_SWAP_DATA (closure))
1899     {
1900       data1 = closure-&gt;data;
1901       data2 = g_value_peek_pointer (param_values + 0);
1902     }
1903   else
1904     {
1905       data1 = g_value_peek_pointer (param_values + 0);
1906       data2 = closure-&gt;data;
1907     }
1908   callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
1909 
1910   callback (data1,
1911             g_marshal_value_peek_boxed (param_values + 1),
1912             data2);
1913 }
<a name="35" id="anc35"></a>

















1914 void
1915 g_cclosure_marshal_VOID__BOXEDv (GClosure     *closure,
1916                                  GValue       *return_value,
1917                                  gpointer      instance,
1918                                  va_list       args,
1919                                  gpointer      marshal_data,
1920                                  int           n_params,
1921                                  GType        *param_types)
1922 {
1923   typedef void (*GMarshalFunc_VOID__BOXED) (gpointer     instance,
1924                                             gpointer     arg_0,
1925                                             gpointer     data);
1926   GCClosure *cc = (GCClosure*) closure;
1927   gpointer data1, data2;
1928   GMarshalFunc_VOID__BOXED callback;
1929   gpointer arg0;
1930   va_list args_copy;
1931 
1932   G_VA_COPY (args_copy, args);
1933   arg0 = (gpointer) va_arg (args_copy, gpointer);
1934   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1935     arg0 = g_boxed_copy (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
1936   va_end (args_copy);
1937 
1938   if (G_CCLOSURE_SWAP_DATA (closure))
1939     {
1940       data1 = closure-&gt;data;
1941       data2 = instance;
1942     }
1943   else
1944     {
1945       data1 = instance;
1946       data2 = closure-&gt;data;
1947     }
1948   callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
1949 
1950   callback (data1,
1951             arg0,
1952             data2);
1953   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1954     g_boxed_free (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
1955 }
1956 
<a name="36" id="anc36"></a><span class="line-modified">1957 </span>
<span class="line-modified">1958 /* VOID:POINTER (./gmarshal.list:21) */</span>




















1959 void
1960 g_cclosure_marshal_VOID__POINTER (GClosure     *closure,
1961                                   GValue       *return_value G_GNUC_UNUSED,
1962                                   guint         n_param_values,
1963                                   const GValue *param_values,
1964                                   gpointer      invocation_hint G_GNUC_UNUSED,
1965                                   gpointer      marshal_data)
1966 {
1967   typedef void (*GMarshalFunc_VOID__POINTER) (gpointer     data1,
1968                                               gpointer     arg_1,
1969                                               gpointer     data2);
1970   GMarshalFunc_VOID__POINTER callback;
1971   GCClosure *cc = (GCClosure*) closure;
1972   gpointer data1, data2;
1973 
1974   g_return_if_fail (n_param_values == 2);
1975 
1976   if (G_CCLOSURE_SWAP_DATA (closure))
1977     {
1978       data1 = closure-&gt;data;
1979       data2 = g_value_peek_pointer (param_values + 0);
1980     }
1981   else
1982     {
1983       data1 = g_value_peek_pointer (param_values + 0);
1984       data2 = closure-&gt;data;
1985     }
1986   callback = (GMarshalFunc_VOID__POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
1987 
1988   callback (data1,
1989             g_marshal_value_peek_pointer (param_values + 1),
1990             data2);
1991 }
<a name="37" id="anc37"></a>

















1992 void
1993 g_cclosure_marshal_VOID__POINTERv (GClosure     *closure,
1994                                    GValue       *return_value,
1995                                    gpointer      instance,
1996                                    va_list       args,
1997                                    gpointer      marshal_data,
1998                                    int           n_params,
1999                                    GType        *param_types)
2000 {
2001   typedef void (*GMarshalFunc_VOID__POINTER) (gpointer     instance,
2002                                               gpointer     arg_0,
2003                                               gpointer     data);
2004   GCClosure *cc = (GCClosure*) closure;
2005   gpointer data1, data2;
2006   GMarshalFunc_VOID__POINTER callback;
2007   gpointer arg0;
2008   va_list args_copy;
2009 
2010   G_VA_COPY (args_copy, args);
2011   arg0 = (gpointer) va_arg (args_copy, gpointer);
2012   va_end (args_copy);
2013 
2014   if (G_CCLOSURE_SWAP_DATA (closure))
2015     {
2016       data1 = closure-&gt;data;
2017       data2 = instance;
2018     }
2019   else
2020     {
2021       data1 = instance;
2022       data2 = closure-&gt;data;
2023     }
2024   callback = (GMarshalFunc_VOID__POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2025 
2026   callback (data1,
2027             arg0,
2028             data2);
2029 }
2030 
<a name="38" id="anc38"></a><span class="line-modified">2031 </span>
<span class="line-modified">2032 /* VOID:OBJECT (./gmarshal.list:22) */</span>
















2033 void
2034 g_cclosure_marshal_VOID__OBJECT (GClosure     *closure,
2035                                  GValue       *return_value G_GNUC_UNUSED,
2036                                  guint         n_param_values,
2037                                  const GValue *param_values,
2038                                  gpointer      invocation_hint G_GNUC_UNUSED,
2039                                  gpointer      marshal_data)
2040 {
2041   typedef void (*GMarshalFunc_VOID__OBJECT) (gpointer     data1,
2042                                              gpointer     arg_1,
2043                                              gpointer     data2);
2044   GMarshalFunc_VOID__OBJECT callback;
2045   GCClosure *cc = (GCClosure*) closure;
2046   gpointer data1, data2;
2047 
2048   g_return_if_fail (n_param_values == 2);
2049 
2050   if (G_CCLOSURE_SWAP_DATA (closure))
2051     {
2052       data1 = closure-&gt;data;
2053       data2 = g_value_peek_pointer (param_values + 0);
2054     }
2055   else
2056     {
2057       data1 = g_value_peek_pointer (param_values + 0);
2058       data2 = closure-&gt;data;
2059     }
2060   callback = (GMarshalFunc_VOID__OBJECT) (marshal_data ? marshal_data : cc-&gt;callback);
2061 
2062   callback (data1,
2063             g_marshal_value_peek_object (param_values + 1),
2064             data2);
2065 }
<a name="39" id="anc39"></a>

















2066 void
2067 g_cclosure_marshal_VOID__OBJECTv (GClosure     *closure,
2068                                   GValue       *return_value,
2069                                   gpointer      instance,
2070                                   va_list       args,
2071                                   gpointer      marshal_data,
2072                                   int           n_params,
2073                                   GType        *param_types)
2074 {
2075   typedef void (*GMarshalFunc_VOID__OBJECT) (gpointer     instance,
2076                                              gpointer     arg_0,
2077                                              gpointer     data);
2078   GCClosure *cc = (GCClosure*) closure;
2079   gpointer data1, data2;
2080   GMarshalFunc_VOID__OBJECT callback;
2081   gpointer arg0;
2082   va_list args_copy;
2083 
2084   G_VA_COPY (args_copy, args);
2085   arg0 = (gpointer) va_arg (args_copy, gpointer);
2086   if (arg0 != NULL)
2087     arg0 = g_object_ref (arg0);
2088   va_end (args_copy);
2089 
2090   if (G_CCLOSURE_SWAP_DATA (closure))
2091     {
2092       data1 = closure-&gt;data;
2093       data2 = instance;
2094     }
2095   else
2096     {
2097       data1 = instance;
2098       data2 = closure-&gt;data;
2099     }
2100   callback = (GMarshalFunc_VOID__OBJECT) (marshal_data ? marshal_data : cc-&gt;callback);
2101 
2102   callback (data1,
2103             arg0,
2104             data2);
2105   if (arg0 != NULL)
2106     g_object_unref (arg0);
2107 }
2108 
<a name="40" id="anc40"></a><span class="line-modified">2109 </span>
<span class="line-modified">2110 /* VOID:VARIANT (./gmarshal.list:23) */</span>
















2111 void
2112 g_cclosure_marshal_VOID__VARIANT (GClosure     *closure,
2113                                   GValue       *return_value G_GNUC_UNUSED,
2114                                   guint         n_param_values,
2115                                   const GValue *param_values,
2116                                   gpointer      invocation_hint G_GNUC_UNUSED,
2117                                   gpointer      marshal_data)
2118 {
2119   typedef void (*GMarshalFunc_VOID__VARIANT) (gpointer     data1,
2120                                               gpointer     arg_1,
2121                                               gpointer     data2);
2122   GMarshalFunc_VOID__VARIANT callback;
2123   GCClosure *cc = (GCClosure*) closure;
2124   gpointer data1, data2;
2125 
2126   g_return_if_fail (n_param_values == 2);
2127 
2128   if (G_CCLOSURE_SWAP_DATA (closure))
2129     {
2130       data1 = closure-&gt;data;
2131       data2 = g_value_peek_pointer (param_values + 0);
2132     }
2133   else
2134     {
2135       data1 = g_value_peek_pointer (param_values + 0);
2136       data2 = closure-&gt;data;
2137     }
2138   callback = (GMarshalFunc_VOID__VARIANT) (marshal_data ? marshal_data : cc-&gt;callback);
2139 
2140   callback (data1,
2141             g_marshal_value_peek_variant (param_values + 1),
2142             data2);
2143 }
<a name="41" id="anc41"></a>

















2144 void
2145 g_cclosure_marshal_VOID__VARIANTv (GClosure     *closure,
2146                                    GValue       *return_value,
2147                                    gpointer      instance,
2148                                    va_list       args,
2149                                    gpointer      marshal_data,
2150                                    int           n_params,
2151                                    GType        *param_types)
2152 {
2153   typedef void (*GMarshalFunc_VOID__VARIANT) (gpointer     instance,
2154                                               gpointer     arg_0,
2155                                               gpointer     data);
2156   GCClosure *cc = (GCClosure*) closure;
2157   gpointer data1, data2;
2158   GMarshalFunc_VOID__VARIANT callback;
2159   gpointer arg0;
2160   va_list args_copy;
2161 
2162   G_VA_COPY (args_copy, args);
2163   arg0 = (gpointer) va_arg (args_copy, gpointer);
2164   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2165     arg0 = g_variant_ref_sink (arg0);
2166   va_end (args_copy);
2167 
2168   if (G_CCLOSURE_SWAP_DATA (closure))
2169     {
2170       data1 = closure-&gt;data;
2171       data2 = instance;
2172     }
2173   else
2174     {
2175       data1 = instance;
2176       data2 = closure-&gt;data;
2177     }
2178   callback = (GMarshalFunc_VOID__VARIANT) (marshal_data ? marshal_data : cc-&gt;callback);
2179 
2180   callback (data1,
2181             arg0,
2182             data2);
2183   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2184     g_variant_unref (arg0);
2185 }
2186 
<a name="42" id="anc42"></a><span class="line-modified">2187 </span>
<span class="line-modified">2188 /* VOID:UINT,POINTER (./gmarshal.list:26) */</span>
















2189 void
2190 g_cclosure_marshal_VOID__UINT_POINTER (GClosure     *closure,
2191                                        GValue       *return_value G_GNUC_UNUSED,
2192                                        guint         n_param_values,
2193                                        const GValue *param_values,
2194                                        gpointer      invocation_hint G_GNUC_UNUSED,
2195                                        gpointer      marshal_data)
2196 {
2197   typedef void (*GMarshalFunc_VOID__UINT_POINTER) (gpointer     data1,
2198                                                    guint        arg_1,
2199                                                    gpointer     arg_2,
2200                                                    gpointer     data2);
2201   GMarshalFunc_VOID__UINT_POINTER callback;
2202   GCClosure *cc = (GCClosure*) closure;
2203   gpointer data1, data2;
2204 
2205   g_return_if_fail (n_param_values == 3);
2206 
2207   if (G_CCLOSURE_SWAP_DATA (closure))
2208     {
2209       data1 = closure-&gt;data;
2210       data2 = g_value_peek_pointer (param_values + 0);
2211     }
2212   else
2213     {
2214       data1 = g_value_peek_pointer (param_values + 0);
2215       data2 = closure-&gt;data;
2216     }
2217   callback = (GMarshalFunc_VOID__UINT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2218 
2219   callback (data1,
2220             g_marshal_value_peek_uint (param_values + 1),
2221             g_marshal_value_peek_pointer (param_values + 2),
2222             data2);
2223 }
<a name="43" id="anc43"></a>

















2224 void
2225 g_cclosure_marshal_VOID__UINT_POINTERv (GClosure     *closure,
2226                                         GValue       *return_value,
2227                                         gpointer      instance,
2228                                         va_list       args,
2229                                         gpointer      marshal_data,
2230                                         int           n_params,
2231                                         GType        *param_types)
2232 {
2233   typedef void (*GMarshalFunc_VOID__UINT_POINTER) (gpointer     instance,
2234                                                    guint        arg_0,
2235                                                    gpointer     arg_1,
2236                                                    gpointer     data);
2237   GCClosure *cc = (GCClosure*) closure;
2238   gpointer data1, data2;
2239   GMarshalFunc_VOID__UINT_POINTER callback;
2240   guint arg0;
2241   gpointer arg1;
2242   va_list args_copy;
2243 
2244   G_VA_COPY (args_copy, args);
2245   arg0 = (guint) va_arg (args_copy, guint);
2246   arg1 = (gpointer) va_arg (args_copy, gpointer);
2247   va_end (args_copy);
2248 
2249   if (G_CCLOSURE_SWAP_DATA (closure))
2250     {
2251       data1 = closure-&gt;data;
2252       data2 = instance;
2253     }
2254   else
2255     {
2256       data1 = instance;
2257       data2 = closure-&gt;data;
2258     }
2259   callback = (GMarshalFunc_VOID__UINT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2260 
2261   callback (data1,
2262             arg0,
2263             arg1,
2264             data2);
2265 }
2266 
<a name="44" id="anc44"></a><span class="line-modified">2267 </span>
<span class="line-modified">2268 /* BOOL:FLAGS (./gmarshal.list:27) */</span>


















2269 void
2270 g_cclosure_marshal_BOOLEAN__FLAGS (GClosure     *closure,
2271                                    GValue       *return_value G_GNUC_UNUSED,
2272                                    guint         n_param_values,
2273                                    const GValue *param_values,
2274                                    gpointer      invocation_hint G_GNUC_UNUSED,
2275                                    gpointer      marshal_data)
2276 {
2277   typedef gboolean (*GMarshalFunc_BOOLEAN__FLAGS) (gpointer     data1,
2278                                                    guint        arg_1,
2279                                                    gpointer     data2);
2280   GMarshalFunc_BOOLEAN__FLAGS callback;
2281   GCClosure *cc = (GCClosure*) closure;
2282   gpointer data1, data2;
2283   gboolean v_return;
2284 
2285   g_return_if_fail (return_value != NULL);
2286   g_return_if_fail (n_param_values == 2);
2287 
2288   if (G_CCLOSURE_SWAP_DATA (closure))
2289     {
2290       data1 = closure-&gt;data;
2291       data2 = g_value_peek_pointer (param_values + 0);
2292     }
2293   else
2294     {
2295       data1 = g_value_peek_pointer (param_values + 0);
2296       data2 = closure-&gt;data;
2297     }
2298   callback = (GMarshalFunc_BOOLEAN__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
2299 
2300   v_return = callback (data1,
2301                        g_marshal_value_peek_flags (param_values + 1),
2302                        data2);
2303 
2304   g_value_set_boolean (return_value, v_return);
2305 }
<a name="45" id="anc45"></a>

















2306 void
2307 g_cclosure_marshal_BOOLEAN__FLAGSv (GClosure     *closure,
2308                                     GValue       *return_value,
2309                                     gpointer      instance,
2310                                     va_list       args,
2311                                     gpointer      marshal_data,
2312                                     int           n_params,
2313                                     GType        *param_types)
2314 {
2315   typedef gboolean (*GMarshalFunc_BOOLEAN__FLAGS) (gpointer     instance,
2316                                                    guint        arg_0,
2317                                                    gpointer     data);
2318   GCClosure *cc = (GCClosure*) closure;
2319   gpointer data1, data2;
2320   GMarshalFunc_BOOLEAN__FLAGS callback;
2321   guint arg0;
2322   va_list args_copy;
2323   gboolean v_return;
2324 
2325   g_return_if_fail (return_value != NULL);
2326 
2327   G_VA_COPY (args_copy, args);
2328   arg0 = (guint) va_arg (args_copy, guint);
2329   va_end (args_copy);
2330 
2331   if (G_CCLOSURE_SWAP_DATA (closure))
2332     {
2333       data1 = closure-&gt;data;
2334       data2 = instance;
2335     }
2336   else
2337     {
2338       data1 = instance;
2339       data2 = closure-&gt;data;
2340     }
2341   callback = (GMarshalFunc_BOOLEAN__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
2342 
2343   v_return = callback (data1,
2344                        arg0,
2345                        data2);
2346 
2347   g_value_set_boolean (return_value, v_return);
2348 }
2349 
<a name="46" id="anc46"></a><span class="line-modified">2350 </span>
<span class="line-modified">2351 /* STRING:OBJECT,POINTER (./gmarshal.list:28) */</span>

















2352 void
2353 g_cclosure_marshal_STRING__OBJECT_POINTER (GClosure     *closure,
2354                                            GValue       *return_value G_GNUC_UNUSED,
2355                                            guint         n_param_values,
2356                                            const GValue *param_values,
2357                                            gpointer      invocation_hint G_GNUC_UNUSED,
2358                                            gpointer      marshal_data)
2359 {
2360   typedef gchar* (*GMarshalFunc_STRING__OBJECT_POINTER) (gpointer     data1,
2361                                                          gpointer     arg_1,
2362                                                          gpointer     arg_2,
2363                                                          gpointer     data2);
2364   GMarshalFunc_STRING__OBJECT_POINTER callback;
2365   GCClosure *cc = (GCClosure*) closure;
2366   gpointer data1, data2;
2367   gchar* v_return;
2368 
2369   g_return_if_fail (return_value != NULL);
2370   g_return_if_fail (n_param_values == 3);
2371 
2372   if (G_CCLOSURE_SWAP_DATA (closure))
2373     {
2374       data1 = closure-&gt;data;
2375       data2 = g_value_peek_pointer (param_values + 0);
2376     }
2377   else
2378     {
2379       data1 = g_value_peek_pointer (param_values + 0);
2380       data2 = closure-&gt;data;
2381     }
2382   callback = (GMarshalFunc_STRING__OBJECT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2383 
2384   v_return = callback (data1,
2385                        g_marshal_value_peek_object (param_values + 1),
2386                        g_marshal_value_peek_pointer (param_values + 2),
2387                        data2);
2388 
2389   g_value_take_string (return_value, v_return);
2390 }
<a name="47" id="anc47"></a>

















2391 void
2392 g_cclosure_marshal_STRING__OBJECT_POINTERv (GClosure     *closure,
2393                                             GValue       *return_value,
2394                                             gpointer      instance,
2395                                             va_list       args,
2396                                             gpointer      marshal_data,
2397                                             int           n_params,
2398                                             GType        *param_types)
2399 {
2400   typedef gchar* (*GMarshalFunc_STRING__OBJECT_POINTER) (gpointer     instance,
2401                                                          gpointer     arg_0,
2402                                                          gpointer     arg_1,
2403                                                          gpointer     data);
2404   GCClosure *cc = (GCClosure*) closure;
2405   gpointer data1, data2;
2406   GMarshalFunc_STRING__OBJECT_POINTER callback;
2407   gpointer arg0;
2408   gpointer arg1;
2409   va_list args_copy;
2410   gchar* v_return;
2411 
2412   g_return_if_fail (return_value != NULL);
2413 
2414   G_VA_COPY (args_copy, args);
2415   arg0 = (gpointer) va_arg (args_copy, gpointer);
2416   if (arg0 != NULL)
2417     arg0 = g_object_ref (arg0);
2418   arg1 = (gpointer) va_arg (args_copy, gpointer);
2419   va_end (args_copy);
2420 
2421   if (G_CCLOSURE_SWAP_DATA (closure))
2422     {
2423       data1 = closure-&gt;data;
2424       data2 = instance;
2425     }
2426   else
2427     {
2428       data1 = instance;
2429       data2 = closure-&gt;data;
2430     }
2431   callback = (GMarshalFunc_STRING__OBJECT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2432 
2433   v_return = callback (data1,
2434                        arg0,
2435                        arg1,
2436                        data2);
2437   if (arg0 != NULL)
2438     g_object_unref (arg0);
2439 
2440   g_value_take_string (return_value, v_return);
2441 }
2442 
<a name="48" id="anc48"></a><span class="line-modified">2443 </span>
<span class="line-modified">2444 /* BOOL:BOXED,BOXED (./gmarshal.list:29) */</span>


















2445 void
2446 g_cclosure_marshal_BOOLEAN__BOXED_BOXED (GClosure     *closure,
2447                                          GValue       *return_value G_GNUC_UNUSED,
2448                                          guint         n_param_values,
2449                                          const GValue *param_values,
2450                                          gpointer      invocation_hint G_GNUC_UNUSED,
2451                                          gpointer      marshal_data)
2452 {
2453   typedef gboolean (*GMarshalFunc_BOOLEAN__BOXED_BOXED) (gpointer     data1,
2454                                                          gpointer     arg_1,
2455                                                          gpointer     arg_2,
2456                                                          gpointer     data2);
2457   GMarshalFunc_BOOLEAN__BOXED_BOXED callback;
2458   GCClosure *cc = (GCClosure*) closure;
2459   gpointer data1, data2;
2460   gboolean v_return;
2461 
2462   g_return_if_fail (return_value != NULL);
2463   g_return_if_fail (n_param_values == 3);
2464 
2465   if (G_CCLOSURE_SWAP_DATA (closure))
2466     {
2467       data1 = closure-&gt;data;
2468       data2 = g_value_peek_pointer (param_values + 0);
2469     }
2470   else
2471     {
2472       data1 = g_value_peek_pointer (param_values + 0);
2473       data2 = closure-&gt;data;
2474     }
2475   callback = (GMarshalFunc_BOOLEAN__BOXED_BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
2476 
2477   v_return = callback (data1,
2478                        g_marshal_value_peek_boxed (param_values + 1),
2479                        g_marshal_value_peek_boxed (param_values + 2),
2480                        data2);
2481 
2482   g_value_set_boolean (return_value, v_return);
2483 }
<a name="49" id="anc49"></a>

















2484 void
2485 g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv (GClosure     *closure,
2486                                           GValue       *return_value,
2487                                           gpointer      instance,
2488                                           va_list       args,
2489                                           gpointer      marshal_data,
2490                                           int           n_params,
2491                                           GType        *param_types)
2492 {
2493   typedef gboolean (*GMarshalFunc_BOOLEAN__BOXED_BOXED) (gpointer     instance,
2494                                                          gpointer     arg_0,
2495                                                          gpointer     arg_1,
2496                                                          gpointer     data);
2497   GCClosure *cc = (GCClosure*) closure;
2498   gpointer data1, data2;
2499   GMarshalFunc_BOOLEAN__BOXED_BOXED callback;
2500   gpointer arg0;
2501   gpointer arg1;
2502   va_list args_copy;
2503   gboolean v_return;
2504 
2505   g_return_if_fail (return_value != NULL);
2506 
2507   G_VA_COPY (args_copy, args);
2508   arg0 = (gpointer) va_arg (args_copy, gpointer);
2509   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2510     arg0 = g_boxed_copy (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
2511   arg1 = (gpointer) va_arg (args_copy, gpointer);
2512   if ((param_types[1] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg1 != NULL)
2513     arg1 = g_boxed_copy (param_types[1] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
2514   va_end (args_copy);
2515 
2516   if (G_CCLOSURE_SWAP_DATA (closure))
2517     {
2518       data1 = closure-&gt;data;
2519       data2 = instance;
2520     }
2521   else
2522     {
2523       data1 = instance;
2524       data2 = closure-&gt;data;
2525     }
2526   callback = (GMarshalFunc_BOOLEAN__BOXED_BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
2527 
2528   v_return = callback (data1,
2529                        arg0,
2530                        arg1,
2531                        data2);
2532   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2533     g_boxed_free (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
2534   if ((param_types[1] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg1 != NULL)
2535     g_boxed_free (param_types[1] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
2536 
2537   g_value_set_boolean (return_value, v_return);
2538 }
<a name="50" id="anc50"></a><span class="line-removed">2539 </span>
<span class="line-removed">2540 </span>
<a name="51" id="anc51"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="51" type="hidden" />
</body>
</html>