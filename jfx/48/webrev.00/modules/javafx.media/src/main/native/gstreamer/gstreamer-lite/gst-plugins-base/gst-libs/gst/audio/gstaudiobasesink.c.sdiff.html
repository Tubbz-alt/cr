<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudiobasesink.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="audio.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstaudiobasesrc.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudiobasesink.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 
  23 /**
  24  * SECTION:gstaudiobasesink
  25  * @title: GstAudioBaseSink
  26  * @short_description: Base class for audio sinks
  27  * @see_also: #GstAudioSink, #GstAudioRingBuffer.
  28  *
  29  * This is the base class for audio sinks. Subclasses need to implement the
  30  * ::create_ringbuffer vmethod. This base class will then take care of
  31  * writing samples to the ringbuffer, synchronisation, clipping and flushing.
  32  */



  33 
  34 #include &lt;string.h&gt;
  35 
  36 #include &lt;gst/audio/audio.h&gt;
  37 #include &quot;gstaudiobasesink.h&quot;
  38 
  39 GST_DEBUG_CATEGORY_STATIC (gst_audio_base_sink_debug);
  40 #define GST_CAT_DEFAULT gst_audio_base_sink_debug
  41 
<span class="line-removed">  42 #define GST_AUDIO_BASE_SINK_GET_PRIVATE(obj)  \</span>
<span class="line-removed">  43    (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_AUDIO_BASE_SINK, GstAudioBaseSinkPrivate))</span>
<span class="line-removed">  44 </span>
  45 struct _GstAudioBaseSinkPrivate
  46 {
  47   /* upstream latency */
  48   GstClockTime us_latency;
  49   /* the clock slaving algorithm in use */
  50   GstAudioBaseSinkSlaveMethod slave_method;
  51   /* running average of clock skew */
  52   GstClockTimeDiff avg_skew;
  53   /* the number of samples we aligned last time */
  54   gint64 last_align;
  55 
  56   gboolean sync_latency;
  57 
  58   GstClockTime eos_time;
  59 
  60   /* number of microseconds we allow clock slaving to drift
  61    * before resyncing */
  62   guint64 drift_tolerance;
  63 
  64   /* number of nanoseconds we allow timestamps to drift
</pre>
<hr />
<pre>
 112 enum
 113 {
 114   PROP_0,
 115 
 116   PROP_BUFFER_TIME,
 117   PROP_LATENCY_TIME,
 118   PROP_PROVIDE_CLOCK,
 119   PROP_SLAVE_METHOD,
 120   PROP_CAN_ACTIVATE_PULL,
 121   PROP_ALIGNMENT_THRESHOLD,
 122   PROP_DRIFT_TOLERANCE,
 123   PROP_DISCONT_WAIT,
 124 
 125   PROP_LAST
 126 };
 127 
 128 #define _do_init \
 129     GST_DEBUG_CATEGORY_INIT (gst_audio_base_sink_debug, &quot;audiobasesink&quot;, 0, &quot;audiobasesink element&quot;);
 130 #define gst_audio_base_sink_parent_class parent_class
 131 G_DEFINE_TYPE_WITH_CODE (GstAudioBaseSink, gst_audio_base_sink,
<span class="line-modified"> 132     GST_TYPE_BASE_SINK, _do_init);</span>
 133 
 134 static void gst_audio_base_sink_dispose (GObject * object);
 135 
 136 static void gst_audio_base_sink_set_property (GObject * object, guint prop_id,
 137     const GValue * value, GParamSpec * pspec);
 138 static void gst_audio_base_sink_get_property (GObject * object, guint prop_id,
 139     GValue * value, GParamSpec * pspec);
 140 
 141 static GstStateChangeReturn gst_audio_base_sink_change_state (GstElement *
 142     element, GstStateChange transition);
 143 static gboolean gst_audio_base_sink_activate_pull (GstBaseSink * basesink,
 144     gboolean active);
 145 static gboolean gst_audio_base_sink_query (GstElement * element, GstQuery *
 146     query);
 147 
 148 static GstClock *gst_audio_base_sink_provide_clock (GstElement * elem);
 149 static inline void gst_audio_base_sink_reset_sync (GstAudioBaseSink * sink);
 150 static GstClockTime gst_audio_base_sink_get_time (GstClock * clock,
 151     GstAudioBaseSink * sink);
 152 static void gst_audio_base_sink_callback (GstAudioRingBuffer * rbuf,
</pre>
<hr />
<pre>
 167 static GstCaps *gst_audio_base_sink_fixate (GstBaseSink * bsink,
 168     GstCaps * caps);
 169 
 170 static gboolean gst_audio_base_sink_query_pad (GstBaseSink * bsink,
 171     GstQuery * query);
 172 
 173 
 174 /* static guint gst_audio_base_sink_signals[LAST_SIGNAL] = { 0 }; */
 175 
 176 static void
 177 gst_audio_base_sink_class_init (GstAudioBaseSinkClass * klass)
 178 {
 179   GObjectClass *gobject_class;
 180   GstElementClass *gstelement_class;
 181   GstBaseSinkClass *gstbasesink_class;
 182 
 183   gobject_class = (GObjectClass *) klass;
 184   gstelement_class = (GstElementClass *) klass;
 185   gstbasesink_class = (GstBaseSinkClass *) klass;
 186 
<span class="line-removed"> 187   g_type_class_add_private (klass, sizeof (GstAudioBaseSinkPrivate));</span>
<span class="line-removed"> 188 </span>
 189   gobject_class-&gt;set_property = gst_audio_base_sink_set_property;
 190   gobject_class-&gt;get_property = gst_audio_base_sink_get_property;
 191   gobject_class-&gt;dispose = gst_audio_base_sink_dispose;
 192 
 193   g_object_class_install_property (gobject_class, PROP_BUFFER_TIME,
 194       g_param_spec_int64 (&quot;buffer-time&quot;, &quot;Buffer Time&quot;,
 195           &quot;Size of audio buffer in microseconds, this is the minimum &quot;
 196           &quot;latency that the sink reports&quot;, 1, G_MAXINT64, DEFAULT_BUFFER_TIME,
 197           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 198 
 199   g_object_class_install_property (gobject_class, PROP_LATENCY_TIME,
 200       g_param_spec_int64 (&quot;latency-time&quot;, &quot;Latency Time&quot;,
 201           &quot;The minimum amount of data to write in each iteration &quot;
 202           &quot;in microseconds&quot;, 1, G_MAXINT64, DEFAULT_LATENCY_TIME,
 203           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 204 
 205   g_object_class_install_property (gobject_class, PROP_PROVIDE_CLOCK,
 206       g_param_spec_boolean (&quot;provide-clock&quot;, &quot;Provide Clock&quot;,
 207           &quot;Provide a clock to be used as the global pipeline clock&quot;,
 208           DEFAULT_PROVIDE_CLOCK, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
</pre>
<hr />
<pre>
 265   gstbasesink_class-&gt;wait_event =
 266       GST_DEBUG_FUNCPTR (gst_audio_base_sink_wait_event);
 267   gstbasesink_class-&gt;get_times =
 268       GST_DEBUG_FUNCPTR (gst_audio_base_sink_get_times);
 269   gstbasesink_class-&gt;preroll = GST_DEBUG_FUNCPTR (gst_audio_base_sink_preroll);
 270   gstbasesink_class-&gt;render = GST_DEBUG_FUNCPTR (gst_audio_base_sink_render);
 271   gstbasesink_class-&gt;query = GST_DEBUG_FUNCPTR (gst_audio_base_sink_query_pad);
 272   gstbasesink_class-&gt;activate_pull =
 273       GST_DEBUG_FUNCPTR (gst_audio_base_sink_activate_pull);
 274 
 275   /* ref class from a thread-safe context to work around missing bit of
 276    * thread-safety in GObject */
 277   g_type_class_ref (GST_TYPE_AUDIO_CLOCK);
 278   g_type_class_ref (GST_TYPE_AUDIO_RING_BUFFER);
 279 
 280 }
 281 
 282 static void
 283 gst_audio_base_sink_init (GstAudioBaseSink * audiobasesink)
 284 {
<span class="line-modified"> 285   GstBaseSink *basesink;</span>
 286 
<span class="line-modified"> 287   audiobasesink-&gt;priv = GST_AUDIO_BASE_SINK_GET_PRIVATE (audiobasesink);</span>

 288 
 289   audiobasesink-&gt;buffer_time = DEFAULT_BUFFER_TIME;
 290   audiobasesink-&gt;latency_time = DEFAULT_LATENCY_TIME;
 291   audiobasesink-&gt;priv-&gt;slave_method = DEFAULT_SLAVE_METHOD;
 292   audiobasesink-&gt;priv-&gt;drift_tolerance = DEFAULT_DRIFT_TOLERANCE;
 293   audiobasesink-&gt;priv-&gt;alignment_threshold = DEFAULT_ALIGNMENT_THRESHOLD;
 294   audiobasesink-&gt;priv-&gt;discont_wait = DEFAULT_DISCONT_WAIT;
 295   audiobasesink-&gt;priv-&gt;custom_slaving_callback = NULL;
 296   audiobasesink-&gt;priv-&gt;custom_slaving_cb_data = NULL;
 297   audiobasesink-&gt;priv-&gt;custom_slaving_cb_notify = NULL;
 298 
 299   audiobasesink-&gt;provided_clock = gst_audio_clock_new (&quot;GstAudioSinkClock&quot;,
 300       (GstAudioClockGetTimeFunc) gst_audio_base_sink_get_time, audiobasesink,
 301       NULL);
 302 
<span class="line-removed"> 303   basesink = GST_BASE_SINK_CAST (audiobasesink);</span>
 304   basesink-&gt;can_activate_push = TRUE;
 305   basesink-&gt;can_activate_pull = DEFAULT_CAN_ACTIVATE_PULL;
 306 
 307   gst_base_sink_set_last_sample_enabled (basesink, FALSE);
 308   if (DEFAULT_PROVIDE_CLOCK)
 309     GST_OBJECT_FLAG_SET (basesink, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 310   else
 311     GST_OBJECT_FLAG_UNSET (basesink, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 312 }
 313 
 314 static void
 315 gst_audio_base_sink_dispose (GObject * object)
 316 {
 317   GstAudioBaseSink *sink;
 318 
 319   sink = GST_AUDIO_BASE_SINK (object);
 320 
 321   if (sink-&gt;priv-&gt;custom_slaving_cb_notify)
 322     sink-&gt;priv-&gt;custom_slaving_cb_notify (sink-&gt;priv-&gt;custom_slaving_cb_data);
 323 
</pre>
<hr />
<pre>
1121   GstFlowReturn ret = GST_FLOW_OK;
1122   gboolean clear_force_start_flag = FALSE;
1123 
1124   /* For both gap and EOS events, make sure the ringbuffer is running
1125    * before trying to wait on the event! */
1126   switch (GST_EVENT_TYPE (event)) {
1127     case GST_EVENT_EOS:
1128     case GST_EVENT_GAP:
1129       /* We must have a negotiated format before starting the ringbuffer */
1130       if (G_UNLIKELY (!gst_audio_ring_buffer_is_acquired (sink-&gt;ringbuffer))) {
1131         GST_ELEMENT_ERROR (sink, STREAM, FORMAT, (NULL),
1132             (&quot;Sink not negotiated before %s event.&quot;,
1133                 GST_EVENT_TYPE_NAME (event)));
1134         return GST_FLOW_ERROR;
1135       }
1136 
1137       gst_audio_base_sink_force_start (sink);
1138       /* Make sure the ringbuffer will start again if interrupted during event_wait() */
1139       g_atomic_int_set (&amp;sink-&gt;eos_rendering, 1);
1140       clear_force_start_flag = TRUE;
<span class="line-modified">1141         break;</span>
1142     default:
1143       break;
<span class="line-modified">1144       }</span>
1145 
1146   ret = GST_BASE_SINK_CLASS (parent_class)-&gt;wait_event (bsink, event);
1147   if (ret != GST_FLOW_OK)
1148     goto done;
1149 
1150   switch (GST_EVENT_TYPE (event)) {
1151     case GST_EVENT_EOS:
1152       /* now wait till we played everything */
1153       ret = gst_audio_base_sink_drain (sink);
1154       break;
1155     default:
1156       break;
1157   }
1158 
1159 done:
1160   if (clear_force_start_flag)
1161     g_atomic_int_set (&amp;sink-&gt;eos_rendering, 0);
1162   return ret;
1163 }
1164 
</pre>
<hr />
<pre>
1407   render_stop = clock_convert_external (render_stop, cinternal, cexternal,
1408       crate_num, crate_denom);
1409 
1410   GST_DEBUG_OBJECT (sink,
1411       &quot;after slaving: start %&quot; GST_TIME_FORMAT &quot; - stop %&quot; GST_TIME_FORMAT,
1412       GST_TIME_ARGS (render_start), GST_TIME_ARGS (render_stop));
1413 
1414   *srender_start = render_start;
1415   *srender_stop = render_stop;
1416 }
1417 
1418 /* algorithm to calculate sample positions that will result in changing the
1419  * playout pointer to match the clock rate of the master */
1420 static void
1421 gst_audio_base_sink_skew_slaving (GstAudioBaseSink * sink,
1422     GstClockTime render_start, GstClockTime render_stop,
1423     GstClockTime * srender_start, GstClockTime * srender_stop)
1424 {
1425   GstClockTime cinternal, cexternal, crate_num, crate_denom;
1426   GstClockTime etime, itime;
<span class="line-modified">1427   GstClockTimeDiff skew, mdrift, mdrift2;</span>
1428   gint driftsamples;
1429   gint64 last_align;
1430 
1431   /* get calibration parameters to compensate for offsets */
1432   gst_clock_get_calibration (sink-&gt;provided_clock, &amp;cinternal, &amp;cexternal,
1433       &amp;crate_num, &amp;crate_denom);
1434 
1435   /* sample clocks and figure out clock skew */
1436   etime = gst_clock_get_time (GST_ELEMENT_CLOCK (sink));
1437   itime = gst_audio_clock_get_time (GST_AUDIO_CLOCK (sink-&gt;provided_clock));
1438   itime =
1439       gst_audio_clock_adjust (GST_AUDIO_CLOCK (sink-&gt;provided_clock), itime);
1440 
1441   GST_DEBUG_OBJECT (sink,
1442       &quot;internal %&quot; GST_TIME_FORMAT &quot; external %&quot; GST_TIME_FORMAT
1443       &quot; cinternal %&quot; GST_TIME_FORMAT &quot; cexternal %&quot; GST_TIME_FORMAT,
1444       GST_TIME_ARGS (itime), GST_TIME_ARGS (etime),
1445       GST_TIME_ARGS (cinternal), GST_TIME_ARGS (cexternal));
1446 
1447   /* make sure we never go below 0 */
</pre>
<hr />
<pre>
1449   itime = itime &gt; cinternal ? itime - cinternal : 0;
1450 
1451   /* do itime - etime.
1452    * positive value means external clock goes slower
1453    * negative value means external clock goes faster */
1454   skew = GST_CLOCK_DIFF (etime, itime);
1455   if (sink-&gt;priv-&gt;avg_skew == -1) {
1456     /* first observation */
1457     sink-&gt;priv-&gt;avg_skew = skew;
1458   } else {
1459     /* next observations use a moving average */
1460     sink-&gt;priv-&gt;avg_skew = (31 * sink-&gt;priv-&gt;avg_skew + skew) / 32;
1461   }
1462 
1463   GST_DEBUG_OBJECT (sink, &quot;internal %&quot; GST_TIME_FORMAT &quot; external %&quot;
1464       GST_TIME_FORMAT &quot; skew %&quot; GST_STIME_FORMAT &quot; avg %&quot; GST_STIME_FORMAT,
1465       GST_TIME_ARGS (itime), GST_TIME_ARGS (etime), GST_STIME_ARGS (skew),
1466       GST_STIME_ARGS (sink-&gt;priv-&gt;avg_skew));
1467 
1468   /* the max drift we allow */
<span class="line-modified">1469   mdrift = sink-&gt;priv-&gt;drift_tolerance * 1000;</span>
<span class="line-removed">1470   mdrift2 = mdrift / 2;</span>
1471 
1472   /* adjust playout pointer based on skew */
1473   if (sink-&gt;priv-&gt;avg_skew &gt; mdrift2) {
<span class="line-modified">1474     /* master is running slower, move internal time forward */</span>
1475     GST_WARNING_OBJECT (sink,
1476         &quot;correct clock skew %&quot; GST_STIME_FORMAT &quot; &gt; %&quot; GST_STIME_FORMAT,
1477         GST_STIME_ARGS (sink-&gt;priv-&gt;avg_skew), GST_STIME_ARGS (mdrift2));
1478 
<span class="line-modified">1479     if (sink-&gt;priv-&gt;avg_skew &gt; (2 * mdrift)) {</span>
<span class="line-modified">1480       cexternal -= sink-&gt;priv-&gt;avg_skew;</span>
<span class="line-modified">1481       sink-&gt;priv-&gt;avg_skew = 0;</span>
<span class="line-modified">1482     } else {</span>
<span class="line-modified">1483     cexternal = cexternal &gt; mdrift ? cexternal - mdrift : 0;</span>
<span class="line-modified">1484     sink-&gt;priv-&gt;avg_skew -= mdrift;</span>
<span class="line-modified">1485     }</span>



1486 
<span class="line-modified">1487     driftsamples = (sink-&gt;ringbuffer-&gt;spec.info.rate * mdrift) / GST_SECOND;</span>
1488     last_align = sink-&gt;priv-&gt;last_align;
1489 
1490     /* if we were aligning in the wrong direction or we aligned more than what
1491      * we will correct, resync */
1492     if (last_align &lt; 0 || last_align &gt; driftsamples)
1493       sink-&gt;next_sample = -1;
1494 
1495     GST_DEBUG_OBJECT (sink,
1496         &quot;last_align %&quot; G_GINT64_FORMAT &quot; driftsamples %u, next %&quot;
1497         G_GUINT64_FORMAT, last_align, driftsamples, sink-&gt;next_sample);
1498 
1499     gst_clock_set_calibration (sink-&gt;provided_clock, cinternal, cexternal,
1500         crate_num, crate_denom);
1501   } else if (sink-&gt;priv-&gt;avg_skew &lt; -mdrift2) {
1502     /* master is running faster, move external time forwards */
1503     GST_WARNING_OBJECT (sink,
1504         &quot;correct clock skew %&quot; GST_STIME_FORMAT &quot; &lt; -%&quot; GST_STIME_FORMAT,
1505         GST_STIME_ARGS (sink-&gt;priv-&gt;avg_skew), GST_STIME_ARGS (mdrift2));
1506 
<span class="line-modified">1507     if (sink-&gt;priv-&gt;avg_skew &lt; (2 * -mdrift)) {</span>
<span class="line-modified">1508       cexternal -= sink-&gt;priv-&gt;avg_skew;</span>
<span class="line-modified">1509       sink-&gt;priv-&gt;avg_skew = 0;</span>
<span class="line-modified">1510     } else {</span>
<span class="line-modified">1511     cexternal += mdrift;</span>
<span class="line-modified">1512     sink-&gt;priv-&gt;avg_skew += mdrift;</span>
<span class="line-modified">1513     }</span>
1514 
<span class="line-modified">1515     driftsamples = (sink-&gt;ringbuffer-&gt;spec.info.rate * mdrift) / GST_SECOND;</span>
1516     last_align = sink-&gt;priv-&gt;last_align;
1517 
1518     /* if we were aligning in the wrong direction or we aligned more than what
1519      * we will correct, resync */
1520     if (last_align &gt; 0 || -last_align &gt; driftsamples)
1521       sink-&gt;next_sample = -1;
1522 
1523     GST_DEBUG_OBJECT (sink,
1524         &quot;last_align %&quot; G_GINT64_FORMAT &quot; driftsamples %u, next %&quot;
1525         G_GUINT64_FORMAT, last_align, driftsamples, sink-&gt;next_sample);
1526 
1527     gst_clock_set_calibration (sink-&gt;provided_clock, cinternal, cexternal,
1528         crate_num, crate_denom);
1529   }
1530 
1531   /* convert, ignoring speed */
1532   render_start = clock_convert_external (render_start, cinternal, cexternal,
1533       crate_num, crate_denom);
1534   render_stop = clock_convert_external (render_stop, cinternal, cexternal,
1535       crate_num, crate_denom);
</pre>
<hr />
<pre>
1860 
1861   /* Before we go on, let&#39;s see if we need to payload the data. If yes, we also
1862    * need to unref the output buffer before leaving. */
1863   if (bclass-&gt;payload) {
1864     out = bclass-&gt;payload (sink, buf);
1865 
1866     if (!out)
1867       goto payload_failed;
1868 
1869     buf = out;
1870   }
1871 
1872   bpf = GST_AUDIO_INFO_BPF (&amp;ringbuf-&gt;spec.info);
1873   rate = GST_AUDIO_INFO_RATE (&amp;ringbuf-&gt;spec.info);
1874 
1875   size = gst_buffer_get_size (buf);
1876   if (G_UNLIKELY (size % bpf) != 0)
1877     goto wrong_size;
1878 
1879   samples = size / bpf;
<span class="line-removed">1880   out_samples = samples;</span>
1881 
1882   time = GST_BUFFER_TIMESTAMP (buf);
1883 
1884   /* Last ditch attempt to ensure that we only play silence if
1885    * we are in trickmode no-audio mode (or if a buffer is marked as a GAP)
1886    * by dropping the buffer contents and rendering as a gap event instead */
1887   if (G_UNLIKELY ((bsink-&gt;segment.flags &amp; GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO)
1888           || (buf &amp;&amp; GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_GAP)))) {
1889     GstClockTime duration;
1890     GstEvent *event;
1891     GstBaseSinkClass *bclass;
1892     GST_DEBUG_OBJECT (bsink,
1893         &quot;Received GAP or ignoring audio for trickplay. Dropping contents&quot;);
1894 
1895     duration = gst_util_uint64_scale_int (samples, GST_SECOND, rate);
1896     event = gst_event_new_gap (time, duration);
1897 
1898     bclass = GST_BASE_SINK_GET_CLASS (bsink);
1899     ret = bclass-&gt;wait_event (bsink, event);
1900     gst_event_unref (event);
</pre>
<hr />
<pre>
2002   render_start =
2003       gst_segment_to_running_time (&amp;bsink-&gt;segment, GST_FORMAT_TIME, time);
2004   render_stop =
2005       gst_segment_to_running_time (&amp;bsink-&gt;segment, GST_FORMAT_TIME, stop);
2006 
2007   GST_DEBUG_OBJECT (sink,
2008       &quot;running: start %&quot; GST_TIME_FORMAT &quot; - stop %&quot; GST_TIME_FORMAT,
2009       GST_TIME_ARGS (render_start), GST_TIME_ARGS (render_stop));
2010 
2011   /* store the time of the last sample, we&#39;ll use this to perform sync on the
2012    * last sample when draining the buffer */
2013   if (G_LIKELY (bsink-&gt;segment.rate &gt;= 0.0)) {
2014     sink-&gt;priv-&gt;eos_time = render_stop;
2015   } else {
2016     sink-&gt;priv-&gt;eos_time = render_start;
2017   }
2018 
2019   if (G_UNLIKELY (sync_offset != 0)) {
2020     /* compensate for ts-offset and delay. We know this will not underflow
2021      * because we clipped above. */
<span class="line-modified">2022   GST_DEBUG_OBJECT (sink,</span>
<span class="line-modified">2023       &quot;compensating for sync-offset %&quot; GST_TIME_FORMAT,</span>
<span class="line-modified">2024       GST_TIME_ARGS (sync_offset));</span>
<span class="line-modified">2025   render_start += sync_offset;</span>
<span class="line-modified">2026   render_stop += sync_offset;</span>
2027   }
2028 
2029   if (base_time != 0) {
2030     GST_DEBUG_OBJECT (sink, &quot;adding base_time %&quot; GST_TIME_FORMAT,
<span class="line-modified">2031       GST_TIME_ARGS (base_time));</span>
2032 
<span class="line-modified">2033   /* add base time to sync against the clock */</span>
<span class="line-modified">2034   render_start += base_time;</span>
<span class="line-modified">2035   render_stop += base_time;</span>
2036   }
2037 
2038   if (G_UNLIKELY ((slaved = (clock != sink-&gt;provided_clock)))) {
2039     /* handle clock slaving */
2040     gst_audio_base_sink_handle_slaving (sink, render_start, render_stop,
2041         &amp;render_start, &amp;render_stop);
2042   } else {
2043     /* no slaving needed but we need to adapt to the clock calibration
2044      * parameters */
2045     gst_audio_base_sink_none_slaving (sink, render_start, render_stop,
2046         &amp;render_start, &amp;render_stop);
2047   }
2048 
2049   GST_DEBUG_OBJECT (sink,
2050       &quot;final timestamps: start %&quot; GST_TIME_FORMAT &quot; - stop %&quot; GST_TIME_FORMAT,
2051       GST_TIME_ARGS (render_start), GST_TIME_ARGS (render_stop));
2052 
2053   /* bring to position in the ringbuffer */
2054   time_offset = GST_AUDIO_CLOCK_CAST (sink-&gt;provided_clock)-&gt;time_offset;
2055 
</pre>
<hr />
<pre>
2399   } else {
2400     GST_DEBUG_OBJECT (basesink, &quot;deactivating pull&quot;);
2401     gst_audio_ring_buffer_set_callback (sink-&gt;ringbuffer, NULL, NULL);
2402     ret = gst_audio_ring_buffer_activate (sink-&gt;ringbuffer, FALSE);
2403   }
2404 
2405   return ret;
2406 }
2407 
2408 static GstStateChangeReturn
2409 gst_audio_base_sink_change_state (GstElement * element,
2410     GstStateChange transition)
2411 {
2412   GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
2413   GstAudioBaseSink *sink = GST_AUDIO_BASE_SINK (element);
2414 
2415   switch (transition) {
2416     case GST_STATE_CHANGE_NULL_TO_READY:{
2417       GstAudioRingBuffer *rb;
2418 
<span class="line-modified">2419         gst_audio_clock_reset (GST_AUDIO_CLOCK (sink-&gt;provided_clock), 0);</span>
2420       rb = gst_audio_base_sink_create_ringbuffer (sink);
2421       if (rb == NULL)
2422         goto create_failed;
2423 
2424       GST_OBJECT_LOCK (sink);
2425       sink-&gt;ringbuffer = rb;
2426       GST_OBJECT_UNLOCK (sink);
2427 
2428       if (!gst_audio_ring_buffer_open_device (sink-&gt;ringbuffer)) {
2429         GST_OBJECT_LOCK (sink);
2430         gst_object_unparent (GST_OBJECT_CAST (sink-&gt;ringbuffer));
2431         sink-&gt;ringbuffer = NULL;
2432         GST_OBJECT_UNLOCK (sink);
2433         goto open_failed;
2434       }
2435       break;
2436     }
2437     case GST_STATE_CHANGE_READY_TO_PAUSED:
2438       gst_audio_base_sink_reset_sync (sink);
2439       gst_audio_ring_buffer_set_flushing (sink-&gt;ringbuffer, FALSE);
</pre>
</td>
<td>
<hr />
<pre>
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 
  23 /**
  24  * SECTION:gstaudiobasesink
  25  * @title: GstAudioBaseSink
  26  * @short_description: Base class for audio sinks
  27  * @see_also: #GstAudioSink, #GstAudioRingBuffer.
  28  *
  29  * This is the base class for audio sinks. Subclasses need to implement the
  30  * ::create_ringbuffer vmethod. This base class will then take care of
  31  * writing samples to the ringbuffer, synchronisation, clipping and flushing.
  32  */
<span class="line-added">  33 #ifdef HAVE_CONFIG_H</span>
<span class="line-added">  34 #include &quot;config.h&quot;</span>
<span class="line-added">  35 #endif</span>
  36 
  37 #include &lt;string.h&gt;
  38 
  39 #include &lt;gst/audio/audio.h&gt;
  40 #include &quot;gstaudiobasesink.h&quot;
  41 
  42 GST_DEBUG_CATEGORY_STATIC (gst_audio_base_sink_debug);
  43 #define GST_CAT_DEFAULT gst_audio_base_sink_debug
  44 



  45 struct _GstAudioBaseSinkPrivate
  46 {
  47   /* upstream latency */
  48   GstClockTime us_latency;
  49   /* the clock slaving algorithm in use */
  50   GstAudioBaseSinkSlaveMethod slave_method;
  51   /* running average of clock skew */
  52   GstClockTimeDiff avg_skew;
  53   /* the number of samples we aligned last time */
  54   gint64 last_align;
  55 
  56   gboolean sync_latency;
  57 
  58   GstClockTime eos_time;
  59 
  60   /* number of microseconds we allow clock slaving to drift
  61    * before resyncing */
  62   guint64 drift_tolerance;
  63 
  64   /* number of nanoseconds we allow timestamps to drift
</pre>
<hr />
<pre>
 112 enum
 113 {
 114   PROP_0,
 115 
 116   PROP_BUFFER_TIME,
 117   PROP_LATENCY_TIME,
 118   PROP_PROVIDE_CLOCK,
 119   PROP_SLAVE_METHOD,
 120   PROP_CAN_ACTIVATE_PULL,
 121   PROP_ALIGNMENT_THRESHOLD,
 122   PROP_DRIFT_TOLERANCE,
 123   PROP_DISCONT_WAIT,
 124 
 125   PROP_LAST
 126 };
 127 
 128 #define _do_init \
 129     GST_DEBUG_CATEGORY_INIT (gst_audio_base_sink_debug, &quot;audiobasesink&quot;, 0, &quot;audiobasesink element&quot;);
 130 #define gst_audio_base_sink_parent_class parent_class
 131 G_DEFINE_TYPE_WITH_CODE (GstAudioBaseSink, gst_audio_base_sink,
<span class="line-modified"> 132     GST_TYPE_BASE_SINK, G_ADD_PRIVATE (GstAudioBaseSink) _do_init);</span>
 133 
 134 static void gst_audio_base_sink_dispose (GObject * object);
 135 
 136 static void gst_audio_base_sink_set_property (GObject * object, guint prop_id,
 137     const GValue * value, GParamSpec * pspec);
 138 static void gst_audio_base_sink_get_property (GObject * object, guint prop_id,
 139     GValue * value, GParamSpec * pspec);
 140 
 141 static GstStateChangeReturn gst_audio_base_sink_change_state (GstElement *
 142     element, GstStateChange transition);
 143 static gboolean gst_audio_base_sink_activate_pull (GstBaseSink * basesink,
 144     gboolean active);
 145 static gboolean gst_audio_base_sink_query (GstElement * element, GstQuery *
 146     query);
 147 
 148 static GstClock *gst_audio_base_sink_provide_clock (GstElement * elem);
 149 static inline void gst_audio_base_sink_reset_sync (GstAudioBaseSink * sink);
 150 static GstClockTime gst_audio_base_sink_get_time (GstClock * clock,
 151     GstAudioBaseSink * sink);
 152 static void gst_audio_base_sink_callback (GstAudioRingBuffer * rbuf,
</pre>
<hr />
<pre>
 167 static GstCaps *gst_audio_base_sink_fixate (GstBaseSink * bsink,
 168     GstCaps * caps);
 169 
 170 static gboolean gst_audio_base_sink_query_pad (GstBaseSink * bsink,
 171     GstQuery * query);
 172 
 173 
 174 /* static guint gst_audio_base_sink_signals[LAST_SIGNAL] = { 0 }; */
 175 
 176 static void
 177 gst_audio_base_sink_class_init (GstAudioBaseSinkClass * klass)
 178 {
 179   GObjectClass *gobject_class;
 180   GstElementClass *gstelement_class;
 181   GstBaseSinkClass *gstbasesink_class;
 182 
 183   gobject_class = (GObjectClass *) klass;
 184   gstelement_class = (GstElementClass *) klass;
 185   gstbasesink_class = (GstBaseSinkClass *) klass;
 186 


 187   gobject_class-&gt;set_property = gst_audio_base_sink_set_property;
 188   gobject_class-&gt;get_property = gst_audio_base_sink_get_property;
 189   gobject_class-&gt;dispose = gst_audio_base_sink_dispose;
 190 
 191   g_object_class_install_property (gobject_class, PROP_BUFFER_TIME,
 192       g_param_spec_int64 (&quot;buffer-time&quot;, &quot;Buffer Time&quot;,
 193           &quot;Size of audio buffer in microseconds, this is the minimum &quot;
 194           &quot;latency that the sink reports&quot;, 1, G_MAXINT64, DEFAULT_BUFFER_TIME,
 195           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 196 
 197   g_object_class_install_property (gobject_class, PROP_LATENCY_TIME,
 198       g_param_spec_int64 (&quot;latency-time&quot;, &quot;Latency Time&quot;,
 199           &quot;The minimum amount of data to write in each iteration &quot;
 200           &quot;in microseconds&quot;, 1, G_MAXINT64, DEFAULT_LATENCY_TIME,
 201           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 202 
 203   g_object_class_install_property (gobject_class, PROP_PROVIDE_CLOCK,
 204       g_param_spec_boolean (&quot;provide-clock&quot;, &quot;Provide Clock&quot;,
 205           &quot;Provide a clock to be used as the global pipeline clock&quot;,
 206           DEFAULT_PROVIDE_CLOCK, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
</pre>
<hr />
<pre>
 263   gstbasesink_class-&gt;wait_event =
 264       GST_DEBUG_FUNCPTR (gst_audio_base_sink_wait_event);
 265   gstbasesink_class-&gt;get_times =
 266       GST_DEBUG_FUNCPTR (gst_audio_base_sink_get_times);
 267   gstbasesink_class-&gt;preroll = GST_DEBUG_FUNCPTR (gst_audio_base_sink_preroll);
 268   gstbasesink_class-&gt;render = GST_DEBUG_FUNCPTR (gst_audio_base_sink_render);
 269   gstbasesink_class-&gt;query = GST_DEBUG_FUNCPTR (gst_audio_base_sink_query_pad);
 270   gstbasesink_class-&gt;activate_pull =
 271       GST_DEBUG_FUNCPTR (gst_audio_base_sink_activate_pull);
 272 
 273   /* ref class from a thread-safe context to work around missing bit of
 274    * thread-safety in GObject */
 275   g_type_class_ref (GST_TYPE_AUDIO_CLOCK);
 276   g_type_class_ref (GST_TYPE_AUDIO_RING_BUFFER);
 277 
 278 }
 279 
 280 static void
 281 gst_audio_base_sink_init (GstAudioBaseSink * audiobasesink)
 282 {
<span class="line-modified"> 283   GstBaseSink *basesink = GST_BASE_SINK_CAST (audiobasesink);</span>
 284 
<span class="line-modified"> 285   audiobasesink-&gt;priv =</span>
<span class="line-added"> 286       gst_audio_base_sink_get_instance_private (audiobasesink);</span>
 287 
 288   audiobasesink-&gt;buffer_time = DEFAULT_BUFFER_TIME;
 289   audiobasesink-&gt;latency_time = DEFAULT_LATENCY_TIME;
 290   audiobasesink-&gt;priv-&gt;slave_method = DEFAULT_SLAVE_METHOD;
 291   audiobasesink-&gt;priv-&gt;drift_tolerance = DEFAULT_DRIFT_TOLERANCE;
 292   audiobasesink-&gt;priv-&gt;alignment_threshold = DEFAULT_ALIGNMENT_THRESHOLD;
 293   audiobasesink-&gt;priv-&gt;discont_wait = DEFAULT_DISCONT_WAIT;
 294   audiobasesink-&gt;priv-&gt;custom_slaving_callback = NULL;
 295   audiobasesink-&gt;priv-&gt;custom_slaving_cb_data = NULL;
 296   audiobasesink-&gt;priv-&gt;custom_slaving_cb_notify = NULL;
 297 
 298   audiobasesink-&gt;provided_clock = gst_audio_clock_new (&quot;GstAudioSinkClock&quot;,
 299       (GstAudioClockGetTimeFunc) gst_audio_base_sink_get_time, audiobasesink,
 300       NULL);
 301 

 302   basesink-&gt;can_activate_push = TRUE;
 303   basesink-&gt;can_activate_pull = DEFAULT_CAN_ACTIVATE_PULL;
 304 
 305   gst_base_sink_set_last_sample_enabled (basesink, FALSE);
 306   if (DEFAULT_PROVIDE_CLOCK)
 307     GST_OBJECT_FLAG_SET (basesink, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 308   else
 309     GST_OBJECT_FLAG_UNSET (basesink, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 310 }
 311 
 312 static void
 313 gst_audio_base_sink_dispose (GObject * object)
 314 {
 315   GstAudioBaseSink *sink;
 316 
 317   sink = GST_AUDIO_BASE_SINK (object);
 318 
 319   if (sink-&gt;priv-&gt;custom_slaving_cb_notify)
 320     sink-&gt;priv-&gt;custom_slaving_cb_notify (sink-&gt;priv-&gt;custom_slaving_cb_data);
 321 
</pre>
<hr />
<pre>
1119   GstFlowReturn ret = GST_FLOW_OK;
1120   gboolean clear_force_start_flag = FALSE;
1121 
1122   /* For both gap and EOS events, make sure the ringbuffer is running
1123    * before trying to wait on the event! */
1124   switch (GST_EVENT_TYPE (event)) {
1125     case GST_EVENT_EOS:
1126     case GST_EVENT_GAP:
1127       /* We must have a negotiated format before starting the ringbuffer */
1128       if (G_UNLIKELY (!gst_audio_ring_buffer_is_acquired (sink-&gt;ringbuffer))) {
1129         GST_ELEMENT_ERROR (sink, STREAM, FORMAT, (NULL),
1130             (&quot;Sink not negotiated before %s event.&quot;,
1131                 GST_EVENT_TYPE_NAME (event)));
1132         return GST_FLOW_ERROR;
1133       }
1134 
1135       gst_audio_base_sink_force_start (sink);
1136       /* Make sure the ringbuffer will start again if interrupted during event_wait() */
1137       g_atomic_int_set (&amp;sink-&gt;eos_rendering, 1);
1138       clear_force_start_flag = TRUE;
<span class="line-modified">1139       break;</span>
1140     default:
1141       break;
<span class="line-modified">1142   }</span>
1143 
1144   ret = GST_BASE_SINK_CLASS (parent_class)-&gt;wait_event (bsink, event);
1145   if (ret != GST_FLOW_OK)
1146     goto done;
1147 
1148   switch (GST_EVENT_TYPE (event)) {
1149     case GST_EVENT_EOS:
1150       /* now wait till we played everything */
1151       ret = gst_audio_base_sink_drain (sink);
1152       break;
1153     default:
1154       break;
1155   }
1156 
1157 done:
1158   if (clear_force_start_flag)
1159     g_atomic_int_set (&amp;sink-&gt;eos_rendering, 0);
1160   return ret;
1161 }
1162 
</pre>
<hr />
<pre>
1405   render_stop = clock_convert_external (render_stop, cinternal, cexternal,
1406       crate_num, crate_denom);
1407 
1408   GST_DEBUG_OBJECT (sink,
1409       &quot;after slaving: start %&quot; GST_TIME_FORMAT &quot; - stop %&quot; GST_TIME_FORMAT,
1410       GST_TIME_ARGS (render_start), GST_TIME_ARGS (render_stop));
1411 
1412   *srender_start = render_start;
1413   *srender_stop = render_stop;
1414 }
1415 
1416 /* algorithm to calculate sample positions that will result in changing the
1417  * playout pointer to match the clock rate of the master */
1418 static void
1419 gst_audio_base_sink_skew_slaving (GstAudioBaseSink * sink,
1420     GstClockTime render_start, GstClockTime render_stop,
1421     GstClockTime * srender_start, GstClockTime * srender_stop)
1422 {
1423   GstClockTime cinternal, cexternal, crate_num, crate_denom;
1424   GstClockTime etime, itime;
<span class="line-modified">1425   GstClockTimeDiff skew, drift, mdrift2;</span>
1426   gint driftsamples;
1427   gint64 last_align;
1428 
1429   /* get calibration parameters to compensate for offsets */
1430   gst_clock_get_calibration (sink-&gt;provided_clock, &amp;cinternal, &amp;cexternal,
1431       &amp;crate_num, &amp;crate_denom);
1432 
1433   /* sample clocks and figure out clock skew */
1434   etime = gst_clock_get_time (GST_ELEMENT_CLOCK (sink));
1435   itime = gst_audio_clock_get_time (GST_AUDIO_CLOCK (sink-&gt;provided_clock));
1436   itime =
1437       gst_audio_clock_adjust (GST_AUDIO_CLOCK (sink-&gt;provided_clock), itime);
1438 
1439   GST_DEBUG_OBJECT (sink,
1440       &quot;internal %&quot; GST_TIME_FORMAT &quot; external %&quot; GST_TIME_FORMAT
1441       &quot; cinternal %&quot; GST_TIME_FORMAT &quot; cexternal %&quot; GST_TIME_FORMAT,
1442       GST_TIME_ARGS (itime), GST_TIME_ARGS (etime),
1443       GST_TIME_ARGS (cinternal), GST_TIME_ARGS (cexternal));
1444 
1445   /* make sure we never go below 0 */
</pre>
<hr />
<pre>
1447   itime = itime &gt; cinternal ? itime - cinternal : 0;
1448 
1449   /* do itime - etime.
1450    * positive value means external clock goes slower
1451    * negative value means external clock goes faster */
1452   skew = GST_CLOCK_DIFF (etime, itime);
1453   if (sink-&gt;priv-&gt;avg_skew == -1) {
1454     /* first observation */
1455     sink-&gt;priv-&gt;avg_skew = skew;
1456   } else {
1457     /* next observations use a moving average */
1458     sink-&gt;priv-&gt;avg_skew = (31 * sink-&gt;priv-&gt;avg_skew + skew) / 32;
1459   }
1460 
1461   GST_DEBUG_OBJECT (sink, &quot;internal %&quot; GST_TIME_FORMAT &quot; external %&quot;
1462       GST_TIME_FORMAT &quot; skew %&quot; GST_STIME_FORMAT &quot; avg %&quot; GST_STIME_FORMAT,
1463       GST_TIME_ARGS (itime), GST_TIME_ARGS (etime), GST_STIME_ARGS (skew),
1464       GST_STIME_ARGS (sink-&gt;priv-&gt;avg_skew));
1465 
1466   /* the max drift we allow */
<span class="line-modified">1467   mdrift2 = (sink-&gt;priv-&gt;drift_tolerance * 1000) / 2;</span>

1468 
1469   /* adjust playout pointer based on skew */
1470   if (sink-&gt;priv-&gt;avg_skew &gt; mdrift2) {
<span class="line-modified">1471     /* master is running slower, move external time backwards */</span>
1472     GST_WARNING_OBJECT (sink,
1473         &quot;correct clock skew %&quot; GST_STIME_FORMAT &quot; &gt; %&quot; GST_STIME_FORMAT,
1474         GST_STIME_ARGS (sink-&gt;priv-&gt;avg_skew), GST_STIME_ARGS (mdrift2));
1475 
<span class="line-modified">1476     /* Move the external time backward by the average skew, but don&#39;t ever</span>
<span class="line-modified">1477      * go negative.  Moving the average skew by the same distance defines</span>
<span class="line-modified">1478      * the new clock skew window center point.  This allows the clock to</span>
<span class="line-modified">1479      * drift equally into either direction after the correction. */</span>
<span class="line-modified">1480     if (G_LIKELY (cexternal &gt; sink-&gt;priv-&gt;avg_skew))</span>
<span class="line-modified">1481       drift = sink-&gt;priv-&gt;avg_skew;</span>
<span class="line-modified">1482     else</span>
<span class="line-added">1483       drift = cexternal;</span>
<span class="line-added">1484     cexternal -= drift;</span>
<span class="line-added">1485     sink-&gt;priv-&gt;avg_skew -= drift;</span>
1486 
<span class="line-modified">1487     driftsamples = (sink-&gt;ringbuffer-&gt;spec.info.rate * drift) / GST_SECOND;</span>
1488     last_align = sink-&gt;priv-&gt;last_align;
1489 
1490     /* if we were aligning in the wrong direction or we aligned more than what
1491      * we will correct, resync */
1492     if (last_align &lt; 0 || last_align &gt; driftsamples)
1493       sink-&gt;next_sample = -1;
1494 
1495     GST_DEBUG_OBJECT (sink,
1496         &quot;last_align %&quot; G_GINT64_FORMAT &quot; driftsamples %u, next %&quot;
1497         G_GUINT64_FORMAT, last_align, driftsamples, sink-&gt;next_sample);
1498 
1499     gst_clock_set_calibration (sink-&gt;provided_clock, cinternal, cexternal,
1500         crate_num, crate_denom);
1501   } else if (sink-&gt;priv-&gt;avg_skew &lt; -mdrift2) {
1502     /* master is running faster, move external time forwards */
1503     GST_WARNING_OBJECT (sink,
1504         &quot;correct clock skew %&quot; GST_STIME_FORMAT &quot; &lt; -%&quot; GST_STIME_FORMAT,
1505         GST_STIME_ARGS (sink-&gt;priv-&gt;avg_skew), GST_STIME_ARGS (mdrift2));
1506 
<span class="line-modified">1507     /* Move the external time forward by the average skew, and move the</span>
<span class="line-modified">1508      * average skew by the same distance (which equals a reset to 0). This</span>
<span class="line-modified">1509      * defines the new clock skew window center point.  This allows the</span>
<span class="line-modified">1510      * clock to drift equally into either direction after the correction. */</span>
<span class="line-modified">1511     drift = -sink-&gt;priv-&gt;avg_skew;</span>
<span class="line-modified">1512     cexternal += drift;</span>
<span class="line-modified">1513     sink-&gt;priv-&gt;avg_skew = 0;</span>
1514 
<span class="line-modified">1515     driftsamples = (sink-&gt;ringbuffer-&gt;spec.info.rate * drift) / GST_SECOND;</span>
1516     last_align = sink-&gt;priv-&gt;last_align;
1517 
1518     /* if we were aligning in the wrong direction or we aligned more than what
1519      * we will correct, resync */
1520     if (last_align &gt; 0 || -last_align &gt; driftsamples)
1521       sink-&gt;next_sample = -1;
1522 
1523     GST_DEBUG_OBJECT (sink,
1524         &quot;last_align %&quot; G_GINT64_FORMAT &quot; driftsamples %u, next %&quot;
1525         G_GUINT64_FORMAT, last_align, driftsamples, sink-&gt;next_sample);
1526 
1527     gst_clock_set_calibration (sink-&gt;provided_clock, cinternal, cexternal,
1528         crate_num, crate_denom);
1529   }
1530 
1531   /* convert, ignoring speed */
1532   render_start = clock_convert_external (render_start, cinternal, cexternal,
1533       crate_num, crate_denom);
1534   render_stop = clock_convert_external (render_stop, cinternal, cexternal,
1535       crate_num, crate_denom);
</pre>
<hr />
<pre>
1860 
1861   /* Before we go on, let&#39;s see if we need to payload the data. If yes, we also
1862    * need to unref the output buffer before leaving. */
1863   if (bclass-&gt;payload) {
1864     out = bclass-&gt;payload (sink, buf);
1865 
1866     if (!out)
1867       goto payload_failed;
1868 
1869     buf = out;
1870   }
1871 
1872   bpf = GST_AUDIO_INFO_BPF (&amp;ringbuf-&gt;spec.info);
1873   rate = GST_AUDIO_INFO_RATE (&amp;ringbuf-&gt;spec.info);
1874 
1875   size = gst_buffer_get_size (buf);
1876   if (G_UNLIKELY (size % bpf) != 0)
1877     goto wrong_size;
1878 
1879   samples = size / bpf;

1880 
1881   time = GST_BUFFER_TIMESTAMP (buf);
1882 
1883   /* Last ditch attempt to ensure that we only play silence if
1884    * we are in trickmode no-audio mode (or if a buffer is marked as a GAP)
1885    * by dropping the buffer contents and rendering as a gap event instead */
1886   if (G_UNLIKELY ((bsink-&gt;segment.flags &amp; GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO)
1887           || (buf &amp;&amp; GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_GAP)))) {
1888     GstClockTime duration;
1889     GstEvent *event;
1890     GstBaseSinkClass *bclass;
1891     GST_DEBUG_OBJECT (bsink,
1892         &quot;Received GAP or ignoring audio for trickplay. Dropping contents&quot;);
1893 
1894     duration = gst_util_uint64_scale_int (samples, GST_SECOND, rate);
1895     event = gst_event_new_gap (time, duration);
1896 
1897     bclass = GST_BASE_SINK_GET_CLASS (bsink);
1898     ret = bclass-&gt;wait_event (bsink, event);
1899     gst_event_unref (event);
</pre>
<hr />
<pre>
2001   render_start =
2002       gst_segment_to_running_time (&amp;bsink-&gt;segment, GST_FORMAT_TIME, time);
2003   render_stop =
2004       gst_segment_to_running_time (&amp;bsink-&gt;segment, GST_FORMAT_TIME, stop);
2005 
2006   GST_DEBUG_OBJECT (sink,
2007       &quot;running: start %&quot; GST_TIME_FORMAT &quot; - stop %&quot; GST_TIME_FORMAT,
2008       GST_TIME_ARGS (render_start), GST_TIME_ARGS (render_stop));
2009 
2010   /* store the time of the last sample, we&#39;ll use this to perform sync on the
2011    * last sample when draining the buffer */
2012   if (G_LIKELY (bsink-&gt;segment.rate &gt;= 0.0)) {
2013     sink-&gt;priv-&gt;eos_time = render_stop;
2014   } else {
2015     sink-&gt;priv-&gt;eos_time = render_start;
2016   }
2017 
2018   if (G_UNLIKELY (sync_offset != 0)) {
2019     /* compensate for ts-offset and delay. We know this will not underflow
2020      * because we clipped above. */
<span class="line-modified">2021     GST_DEBUG_OBJECT (sink,</span>
<span class="line-modified">2022         &quot;compensating for sync-offset %&quot; GST_TIME_FORMAT,</span>
<span class="line-modified">2023         GST_TIME_ARGS (sync_offset));</span>
<span class="line-modified">2024     render_start += sync_offset;</span>
<span class="line-modified">2025     render_stop += sync_offset;</span>
2026   }
2027 
2028   if (base_time != 0) {
2029     GST_DEBUG_OBJECT (sink, &quot;adding base_time %&quot; GST_TIME_FORMAT,
<span class="line-modified">2030         GST_TIME_ARGS (base_time));</span>
2031 
<span class="line-modified">2032     /* add base time to sync against the clock */</span>
<span class="line-modified">2033     render_start += base_time;</span>
<span class="line-modified">2034     render_stop += base_time;</span>
2035   }
2036 
2037   if (G_UNLIKELY ((slaved = (clock != sink-&gt;provided_clock)))) {
2038     /* handle clock slaving */
2039     gst_audio_base_sink_handle_slaving (sink, render_start, render_stop,
2040         &amp;render_start, &amp;render_stop);
2041   } else {
2042     /* no slaving needed but we need to adapt to the clock calibration
2043      * parameters */
2044     gst_audio_base_sink_none_slaving (sink, render_start, render_stop,
2045         &amp;render_start, &amp;render_stop);
2046   }
2047 
2048   GST_DEBUG_OBJECT (sink,
2049       &quot;final timestamps: start %&quot; GST_TIME_FORMAT &quot; - stop %&quot; GST_TIME_FORMAT,
2050       GST_TIME_ARGS (render_start), GST_TIME_ARGS (render_stop));
2051 
2052   /* bring to position in the ringbuffer */
2053   time_offset = GST_AUDIO_CLOCK_CAST (sink-&gt;provided_clock)-&gt;time_offset;
2054 
</pre>
<hr />
<pre>
2398   } else {
2399     GST_DEBUG_OBJECT (basesink, &quot;deactivating pull&quot;);
2400     gst_audio_ring_buffer_set_callback (sink-&gt;ringbuffer, NULL, NULL);
2401     ret = gst_audio_ring_buffer_activate (sink-&gt;ringbuffer, FALSE);
2402   }
2403 
2404   return ret;
2405 }
2406 
2407 static GstStateChangeReturn
2408 gst_audio_base_sink_change_state (GstElement * element,
2409     GstStateChange transition)
2410 {
2411   GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
2412   GstAudioBaseSink *sink = GST_AUDIO_BASE_SINK (element);
2413 
2414   switch (transition) {
2415     case GST_STATE_CHANGE_NULL_TO_READY:{
2416       GstAudioRingBuffer *rb;
2417 
<span class="line-modified">2418       gst_audio_clock_reset (GST_AUDIO_CLOCK (sink-&gt;provided_clock), 0);</span>
2419       rb = gst_audio_base_sink_create_ringbuffer (sink);
2420       if (rb == NULL)
2421         goto create_failed;
2422 
2423       GST_OBJECT_LOCK (sink);
2424       sink-&gt;ringbuffer = rb;
2425       GST_OBJECT_UNLOCK (sink);
2426 
2427       if (!gst_audio_ring_buffer_open_device (sink-&gt;ringbuffer)) {
2428         GST_OBJECT_LOCK (sink);
2429         gst_object_unparent (GST_OBJECT_CAST (sink-&gt;ringbuffer));
2430         sink-&gt;ringbuffer = NULL;
2431         GST_OBJECT_UNLOCK (sink);
2432         goto open_failed;
2433       }
2434       break;
2435     }
2436     case GST_STATE_CHANGE_READY_TO_PAUSED:
2437       gst_audio_base_sink_reset_sync (sink);
2438       gst_audio_ring_buffer_set_flushing (sink-&gt;ringbuffer, FALSE);
</pre>
</td>
</tr>
</table>
<center><a href="audio.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstaudiobasesrc.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>