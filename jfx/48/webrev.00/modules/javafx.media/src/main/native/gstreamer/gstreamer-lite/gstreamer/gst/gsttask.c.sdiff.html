<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gsttask.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gsttaglist.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gsttaskpool.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gsttask.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 72 #include &quot;gstinfo.h&quot;
 73 #include &quot;gsttask.h&quot;
 74 #include &quot;glib-compat-private.h&quot;
 75 
 76 #include &lt;stdio.h&gt;
 77 
 78 #ifdef HAVE_SYS_PRCTL_H
 79 #include &lt;sys/prctl.h&gt;
 80 #endif
 81 
 82 #ifdef HAVE_PTHREAD_SETNAME_NP_WITHOUT_TID
 83 #include &lt;pthread.h&gt;
 84 #endif
 85 
 86 GST_DEBUG_CATEGORY_STATIC (task_debug);
 87 #define GST_CAT_DEFAULT (task_debug)
 88 
 89 #define SET_TASK_STATE(t,s) (g_atomic_int_set (&amp;GST_TASK_STATE(t), (s)))
 90 #define GET_TASK_STATE(t)   ((GstTaskState) g_atomic_int_get (&amp;GST_TASK_STATE(t)))
 91 
<span class="line-removed"> 92 #define GST_TASK_GET_PRIVATE(obj)  \</span>
<span class="line-removed"> 93    (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_TASK, GstTaskPrivate))</span>
<span class="line-removed"> 94 </span>
 95 struct _GstTaskPrivate
 96 {
 97   /* callbacks for managing the thread of this task */
 98   GstTaskThreadFunc enter_func;
 99   gpointer enter_user_data;
100   GDestroyNotify enter_notify;
101 
102   GstTaskThreadFunc leave_func;
103   gpointer leave_user_data;
104   GDestroyNotify leave_notify;
105 
106   /* configured pool */
107   GstTaskPool *pool;
108 
109   /* remember the pool and id that is currently running. */
110   gpointer id;
111   GstTaskPool *pool_id;
112 };
113 
114 #ifdef _MSC_VER
</pre>
<hr />
<pre>
136   __try {
137     RaiseException (0x406D1388, 0, sizeof (info) / sizeof (DWORD),
138         (const ULONG_PTR *) &amp;info);
139   }
140   __except (EXCEPTION_CONTINUE_EXECUTION) {
141   }
142 }
143 #endif
144 
145 static void gst_task_finalize (GObject * object);
146 
147 static void gst_task_func (GstTask * task);
148 
149 static GMutex pool_lock;
150 
151 #define _do_init \
152 { \
153   GST_DEBUG_CATEGORY_INIT (task_debug, &quot;task&quot;, 0, &quot;Processing tasks&quot;); \
154 }
155 
<span class="line-modified">156 G_DEFINE_TYPE_WITH_CODE (GstTask, gst_task, GST_TYPE_OBJECT, _do_init);</span>

157 
158 static void
159 init_klass_pool (GstTaskClass * klass)
160 {
161   g_mutex_lock (&amp;pool_lock);
162   if (klass-&gt;pool) {
163     gst_task_pool_cleanup (klass-&gt;pool);
164     gst_object_unref (klass-&gt;pool);
165   }
166   klass-&gt;pool = gst_task_pool_new ();
167   /* Classes are never destroyed so this ref will never be dropped */
168   GST_OBJECT_FLAG_SET (klass-&gt;pool, GST_OBJECT_FLAG_MAY_BE_LEAKED);
169   gst_task_pool_prepare (klass-&gt;pool, NULL);
170   g_mutex_unlock (&amp;pool_lock);
171 }
172 
173 static void
174 gst_task_class_init (GstTaskClass * klass)
175 {
176   GObjectClass *gobject_class;
177 
178   gobject_class = (GObjectClass *) klass;
179 
<span class="line-removed">180   g_type_class_add_private (klass, sizeof (GstTaskPrivate));</span>
<span class="line-removed">181 </span>
182   gobject_class-&gt;finalize = gst_task_finalize;
183 
184   init_klass_pool (klass);
185 }
186 
187 static void
188 gst_task_init (GstTask * task)
189 {
190   GstTaskClass *klass;
191 
192   klass = GST_TASK_GET_CLASS (task);
193 
<span class="line-modified">194   task-&gt;priv = GST_TASK_GET_PRIVATE (task);</span>
195   task-&gt;running = FALSE;
196   task-&gt;thread = NULL;
197   task-&gt;lock = NULL;
198   g_cond_init (&amp;task-&gt;cond);
199   SET_TASK_STATE (task, GST_TASK_STOPPED);
200 
201   /* use the default klass pool for this task, users can
202    * override this later */
203   g_mutex_lock (&amp;pool_lock);
204   task-&gt;priv-&gt;pool = gst_object_ref (klass-&gt;pool);
205   g_mutex_unlock (&amp;pool_lock);
206 }
207 
208 static void
209 gst_task_finalize (GObject * object)
210 {
211   GstTask *task = GST_TASK (object);
212   GstTaskPrivate *priv = task-&gt;priv;
213 
214   GST_DEBUG (&quot;task %p finalize&quot;, task);
</pre>
<hr />
<pre>
291    * the mutex. */
292   GST_OBJECT_LOCK (task);
293   if (GET_TASK_STATE (task) == GST_TASK_STOPPED)
294     goto exit;
295   lock = GST_TASK_GET_LOCK (task);
296   if (G_UNLIKELY (lock == NULL))
297     goto no_lock;
298   task-&gt;thread = tself;
299   GST_OBJECT_UNLOCK (task);
300 
301   /* fire the enter_func callback when we need to */
302   if (priv-&gt;enter_func)
303     priv-&gt;enter_func (task, tself, priv-&gt;enter_user_data);
304 
305   /* locking order is TASK_LOCK, LOCK */
306   g_rec_mutex_lock (lock);
307   /* configure the thread name now */
308   gst_task_configure_name (task);
309 
310   while (G_LIKELY (GET_TASK_STATE (task) != GST_TASK_STOPPED)) {
<span class="line-modified">311       GST_OBJECT_LOCK (task);</span>
<span class="line-modified">312       while (G_UNLIKELY (GST_TASK_STATE (task) == GST_TASK_PAUSED)) {</span>
<span class="line-modified">313         g_rec_mutex_unlock (lock);</span>
<span class="line-modified">314 </span>
<span class="line-modified">315         GST_TASK_SIGNAL (task);</span>
<span class="line-modified">316         GST_INFO_OBJECT (task, &quot;Task going to paused&quot;);</span>
<span class="line-modified">317         GST_TASK_WAIT (task);</span>
<span class="line-modified">318         GST_INFO_OBJECT (task, &quot;Task resume from paused&quot;);</span>
<span class="line-modified">319         GST_OBJECT_UNLOCK (task);</span>
<span class="line-modified">320         /* locking order.. */</span>
<span class="line-modified">321         g_rec_mutex_lock (lock);</span>
322       GST_OBJECT_LOCK (task);
323     }
324 
<span class="line-modified">325         if (G_UNLIKELY (GET_TASK_STATE (task) == GST_TASK_STOPPED)) {</span>
<span class="line-modified">326           GST_OBJECT_UNLOCK (task);</span>
327       break;
328     } else {
329       GST_OBJECT_UNLOCK (task);
330     }
331 
332     task-&gt;func (task-&gt;user_data);
333   }
334 
335   g_rec_mutex_unlock (lock);
336 
337   GST_OBJECT_LOCK (task);
338   task-&gt;thread = NULL;
339 
340 exit:
341   if (priv-&gt;leave_func) {
342     /* fire the leave_func callback when we need to. We need to do this before
343      * we signal the task and with the task lock released. */
344     GST_OBJECT_UNLOCK (task);
345     priv-&gt;leave_func (task, tself, priv-&gt;leave_user_data);
346     GST_OBJECT_LOCK (task);
</pre>
</td>
<td>
<hr />
<pre>
 72 #include &quot;gstinfo.h&quot;
 73 #include &quot;gsttask.h&quot;
 74 #include &quot;glib-compat-private.h&quot;
 75 
 76 #include &lt;stdio.h&gt;
 77 
 78 #ifdef HAVE_SYS_PRCTL_H
 79 #include &lt;sys/prctl.h&gt;
 80 #endif
 81 
 82 #ifdef HAVE_PTHREAD_SETNAME_NP_WITHOUT_TID
 83 #include &lt;pthread.h&gt;
 84 #endif
 85 
 86 GST_DEBUG_CATEGORY_STATIC (task_debug);
 87 #define GST_CAT_DEFAULT (task_debug)
 88 
 89 #define SET_TASK_STATE(t,s) (g_atomic_int_set (&amp;GST_TASK_STATE(t), (s)))
 90 #define GET_TASK_STATE(t)   ((GstTaskState) g_atomic_int_get (&amp;GST_TASK_STATE(t)))
 91 



 92 struct _GstTaskPrivate
 93 {
 94   /* callbacks for managing the thread of this task */
 95   GstTaskThreadFunc enter_func;
 96   gpointer enter_user_data;
 97   GDestroyNotify enter_notify;
 98 
 99   GstTaskThreadFunc leave_func;
100   gpointer leave_user_data;
101   GDestroyNotify leave_notify;
102 
103   /* configured pool */
104   GstTaskPool *pool;
105 
106   /* remember the pool and id that is currently running. */
107   gpointer id;
108   GstTaskPool *pool_id;
109 };
110 
111 #ifdef _MSC_VER
</pre>
<hr />
<pre>
133   __try {
134     RaiseException (0x406D1388, 0, sizeof (info) / sizeof (DWORD),
135         (const ULONG_PTR *) &amp;info);
136   }
137   __except (EXCEPTION_CONTINUE_EXECUTION) {
138   }
139 }
140 #endif
141 
142 static void gst_task_finalize (GObject * object);
143 
144 static void gst_task_func (GstTask * task);
145 
146 static GMutex pool_lock;
147 
148 #define _do_init \
149 { \
150   GST_DEBUG_CATEGORY_INIT (task_debug, &quot;task&quot;, 0, &quot;Processing tasks&quot;); \
151 }
152 
<span class="line-modified">153 G_DEFINE_TYPE_WITH_CODE (GstTask, gst_task, GST_TYPE_OBJECT,</span>
<span class="line-added">154     G_ADD_PRIVATE (GstTask) _do_init);</span>
155 
156 static void
157 init_klass_pool (GstTaskClass * klass)
158 {
159   g_mutex_lock (&amp;pool_lock);
160   if (klass-&gt;pool) {
161     gst_task_pool_cleanup (klass-&gt;pool);
162     gst_object_unref (klass-&gt;pool);
163   }
164   klass-&gt;pool = gst_task_pool_new ();
165   /* Classes are never destroyed so this ref will never be dropped */
166   GST_OBJECT_FLAG_SET (klass-&gt;pool, GST_OBJECT_FLAG_MAY_BE_LEAKED);
167   gst_task_pool_prepare (klass-&gt;pool, NULL);
168   g_mutex_unlock (&amp;pool_lock);
169 }
170 
171 static void
172 gst_task_class_init (GstTaskClass * klass)
173 {
174   GObjectClass *gobject_class;
175 
176   gobject_class = (GObjectClass *) klass;
177 


178   gobject_class-&gt;finalize = gst_task_finalize;
179 
180   init_klass_pool (klass);
181 }
182 
183 static void
184 gst_task_init (GstTask * task)
185 {
186   GstTaskClass *klass;
187 
188   klass = GST_TASK_GET_CLASS (task);
189 
<span class="line-modified">190   task-&gt;priv = gst_task_get_instance_private (task);</span>
191   task-&gt;running = FALSE;
192   task-&gt;thread = NULL;
193   task-&gt;lock = NULL;
194   g_cond_init (&amp;task-&gt;cond);
195   SET_TASK_STATE (task, GST_TASK_STOPPED);
196 
197   /* use the default klass pool for this task, users can
198    * override this later */
199   g_mutex_lock (&amp;pool_lock);
200   task-&gt;priv-&gt;pool = gst_object_ref (klass-&gt;pool);
201   g_mutex_unlock (&amp;pool_lock);
202 }
203 
204 static void
205 gst_task_finalize (GObject * object)
206 {
207   GstTask *task = GST_TASK (object);
208   GstTaskPrivate *priv = task-&gt;priv;
209 
210   GST_DEBUG (&quot;task %p finalize&quot;, task);
</pre>
<hr />
<pre>
287    * the mutex. */
288   GST_OBJECT_LOCK (task);
289   if (GET_TASK_STATE (task) == GST_TASK_STOPPED)
290     goto exit;
291   lock = GST_TASK_GET_LOCK (task);
292   if (G_UNLIKELY (lock == NULL))
293     goto no_lock;
294   task-&gt;thread = tself;
295   GST_OBJECT_UNLOCK (task);
296 
297   /* fire the enter_func callback when we need to */
298   if (priv-&gt;enter_func)
299     priv-&gt;enter_func (task, tself, priv-&gt;enter_user_data);
300 
301   /* locking order is TASK_LOCK, LOCK */
302   g_rec_mutex_lock (lock);
303   /* configure the thread name now */
304   gst_task_configure_name (task);
305 
306   while (G_LIKELY (GET_TASK_STATE (task) != GST_TASK_STOPPED)) {
<span class="line-modified">307     GST_OBJECT_LOCK (task);</span>
<span class="line-modified">308     while (G_UNLIKELY (GST_TASK_STATE (task) == GST_TASK_PAUSED)) {</span>
<span class="line-modified">309       g_rec_mutex_unlock (lock);</span>
<span class="line-modified">310 </span>
<span class="line-modified">311       GST_TASK_SIGNAL (task);</span>
<span class="line-modified">312       GST_INFO_OBJECT (task, &quot;Task going to paused&quot;);</span>
<span class="line-modified">313       GST_TASK_WAIT (task);</span>
<span class="line-modified">314       GST_INFO_OBJECT (task, &quot;Task resume from paused&quot;);</span>
<span class="line-modified">315       GST_OBJECT_UNLOCK (task);</span>
<span class="line-modified">316       /* locking order.. */</span>
<span class="line-modified">317       g_rec_mutex_lock (lock);</span>
318       GST_OBJECT_LOCK (task);
319     }
320 
<span class="line-modified">321     if (G_UNLIKELY (GET_TASK_STATE (task) == GST_TASK_STOPPED)) {</span>
<span class="line-modified">322       GST_OBJECT_UNLOCK (task);</span>
323       break;
324     } else {
325       GST_OBJECT_UNLOCK (task);
326     }
327 
328     task-&gt;func (task-&gt;user_data);
329   }
330 
331   g_rec_mutex_unlock (lock);
332 
333   GST_OBJECT_LOCK (task);
334   task-&gt;thread = NULL;
335 
336 exit:
337   if (priv-&gt;leave_func) {
338     /* fire the leave_func callback when we need to. We need to do this before
339      * we signal the task and with the task lock released. */
340     GST_OBJECT_UNLOCK (task);
341     priv-&gt;leave_func (task, tself, priv-&gt;leave_user_data);
342     GST_OBJECT_LOCK (task);
</pre>
</td>
</tr>
</table>
<center><a href="gsttaglist.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gsttaskpool.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>