<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/tag/gsttagdemux.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstid3tag.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gsttageditingprivate.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/tag/gsttagdemux.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 150     GstCaps * new_caps);
 151 
 152 static gboolean gst_tag_demux_srcpad_event (GstPad * pad, GstObject * parent,
 153     GstEvent * event);
 154 static gboolean gst_tag_demux_sink_activate (GstPad * sinkpad,
 155     GstObject * parent);
 156 static GstStateChangeReturn gst_tag_demux_change_state (GstElement * element,
 157     GstStateChange transition);
 158 static gboolean gst_tag_demux_pad_query (GstPad * pad, GstObject * parent,
 159     GstQuery * query);
 160 static gboolean gst_tag_demux_get_upstream_size (GstTagDemux * tagdemux);
 161 static void gst_tag_demux_send_pending_events (GstTagDemux * tagdemux);
 162 static void gst_tag_demux_send_tag_event (GstTagDemux * tagdemux);
 163 static gboolean gst_tag_demux_send_new_segment (GstTagDemux * tagdemux);
 164 
 165 static void gst_tag_demux_base_init (gpointer g_class);
 166 static void gst_tag_demux_class_init (gpointer g_class, gpointer d);
 167 static void gst_tag_demux_init (GstTagDemux * obj, GstTagDemuxClass * klass);
 168 
 169 static gpointer parent_class;   /* NULL */

 170 
 171 /* Cannot use boilerplate macros here because we want the abstract flag */
 172 GType
 173 gst_tag_demux_get_type (void)
 174 {
 175   static GType object_type;     /* 0 */
 176 
 177   if (object_type == 0) {
 178     static const GTypeInfo object_info = {
 179       sizeof (GstTagDemuxClass),
 180       gst_tag_demux_base_init,
 181       NULL,                     /* base_finalize */
 182       gst_tag_demux_class_init,
 183       NULL,                     /* class_finalize */
 184       NULL,                     /* class_data */
 185       sizeof (GstTagDemux),
 186       0,                        /* n_preallocs */
 187       (GInstanceInitFunc) gst_tag_demux_init
 188     };
 189 
 190     object_type = g_type_register_static (GST_TYPE_ELEMENT,
 191         &quot;GstTagDemux&quot;, &amp;object_info, G_TYPE_FLAG_ABSTRACT);



 192   }
 193 
 194   return object_type;
 195 }
 196 






 197 static void
 198 gst_tag_demux_base_init (gpointer klass)
 199 {
 200   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 201 
 202   gst_element_class_add_static_pad_template (element_class, &amp;src_factory);
 203 
 204   GST_DEBUG_CATEGORY_INIT (tagdemux_debug, &quot;tagdemux&quot;, 0,
 205       &quot;tag demux base class&quot;);
 206 }
 207 
 208 static void
 209 gst_tag_demux_class_init (gpointer klass, gpointer d)
 210 {
 211   GstTagDemuxClass *tagdemux_class = GST_TAG_DEMUX_CLASS (klass);
 212   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 213   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 214 
 215   parent_class = g_type_class_peek_parent (klass);
 216 
 217   gobject_class-&gt;dispose = gst_tag_demux_dispose;
 218 
 219   element_class-&gt;change_state = GST_DEBUG_FUNCPTR (gst_tag_demux_change_state);
 220 
<span class="line-modified"> 221   g_type_class_add_private (klass, sizeof (GstTagDemuxPrivate));</span>

 222 
 223   /* subclasses must set at least one of these */
 224   tagdemux_class-&gt;min_start_size = 0;
 225   tagdemux_class-&gt;min_end_size = 0;
 226 }
 227 
 228 static void
 229 gst_tag_demux_reset (GstTagDemux * tagdemux)
 230 {
 231   GstBuffer **buffer_p = &amp;tagdemux-&gt;priv-&gt;collect;
 232   GstCaps **caps_p = &amp;tagdemux-&gt;priv-&gt;src_caps;
 233 
 234   tagdemux-&gt;priv-&gt;strip_start = 0;
 235   tagdemux-&gt;priv-&gt;strip_end = 0;
 236   tagdemux-&gt;priv-&gt;upstream_size = -1;
 237   tagdemux-&gt;priv-&gt;state = GST_TAG_DEMUX_READ_START_TAG;
 238   tagdemux-&gt;priv-&gt;send_tag_event = FALSE;
 239 
 240   gst_buffer_replace (buffer_p, NULL);
 241   tagdemux-&gt;priv-&gt;collect_size = 0;
</pre>
<hr />
<pre>
 250   if (tagdemux-&gt;priv-&gt;parsed_tags) {
 251     gst_tag_list_unref (tagdemux-&gt;priv-&gt;parsed_tags);
 252     tagdemux-&gt;priv-&gt;parsed_tags = NULL;
 253   }
 254 
 255   gst_segment_init (&amp;tagdemux-&gt;priv-&gt;segment, GST_FORMAT_UNDEFINED);
 256   tagdemux-&gt;priv-&gt;need_newseg = TRUE;
 257 
 258   g_list_foreach (tagdemux-&gt;priv-&gt;pending_events,
 259       (GFunc) gst_mini_object_unref, NULL);
 260   g_list_free (tagdemux-&gt;priv-&gt;pending_events);
 261   tagdemux-&gt;priv-&gt;pending_events = NULL;
 262 }
 263 
 264 static void
 265 gst_tag_demux_init (GstTagDemux * demux, GstTagDemuxClass * gclass)
 266 {
 267   GstElementClass *element_klass = GST_ELEMENT_CLASS (gclass);
 268   GstPadTemplate *tmpl;
 269 
<span class="line-modified"> 270   demux-&gt;priv = g_type_instance_get_private ((GTypeInstance *) demux,</span>
<span class="line-removed"> 271       GST_TYPE_TAG_DEMUX);</span>
 272 
 273   /* sink pad */
 274   tmpl = gst_element_class_get_pad_template (element_klass, &quot;sink&quot;);
 275   if (tmpl) {
 276     demux-&gt;priv-&gt;sinkpad = gst_pad_new_from_template (tmpl, &quot;sink&quot;);
 277 
 278     gst_pad_set_activatemode_function (demux-&gt;priv-&gt;sinkpad,
 279         GST_DEBUG_FUNCPTR (gst_tag_demux_sink_activate_mode));
 280     gst_pad_set_activate_function (demux-&gt;priv-&gt;sinkpad,
 281         GST_DEBUG_FUNCPTR (gst_tag_demux_sink_activate));
 282     gst_pad_set_event_function (demux-&gt;priv-&gt;sinkpad,
 283         GST_DEBUG_FUNCPTR (gst_tag_demux_sink_event));
 284     gst_pad_set_chain_function (demux-&gt;priv-&gt;sinkpad,
 285         GST_DEBUG_FUNCPTR (gst_tag_demux_chain));
 286     gst_element_add_pad (GST_ELEMENT (demux), demux-&gt;priv-&gt;sinkpad);
 287   } else {
 288     g_warning (&quot;GstTagDemux subclass %s must provide a sink pad template&quot;,
 289         G_OBJECT_TYPE_NAME (demux));
 290   }
 291 
</pre>
<hr />
<pre>
 315   gst_tag_demux_reset (tagdemux);
 316   if (tagdemux-&gt;priv-&gt;adapter) {
 317     g_object_unref (tagdemux-&gt;priv-&gt;adapter);
 318     tagdemux-&gt;priv-&gt;adapter = NULL;
 319   }
 320 
 321   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
 322 }
 323 
 324 // FIXME: convert to set_caps / sending a caps event
 325 static void
 326 gst_tag_demux_set_src_caps (GstTagDemux * tagdemux, GstCaps * new_caps)
 327 {
 328   GstCaps *old_caps = tagdemux-&gt;priv-&gt;src_caps;
 329 
 330   if (old_caps == NULL || !gst_caps_is_equal (new_caps, old_caps)) {
 331     GstEvent *event;
 332 
 333     gst_caps_replace (&amp;tagdemux-&gt;priv-&gt;src_caps, new_caps);
 334 
<span class="line-modified"> 335       GST_DEBUG_OBJECT (tagdemux, &quot;Changing src pad caps to %&quot; GST_PTR_FORMAT,</span>
<span class="line-modified"> 336           tagdemux-&gt;priv-&gt;src_caps);</span>
 337 
 338     event =
 339         gst_pad_get_sticky_event (tagdemux-&gt;priv-&gt;sinkpad,
 340         GST_EVENT_STREAM_START, 0);
 341     if (!event) {
 342       gchar *stream_id = gst_pad_create_stream_id (tagdemux-&gt;priv-&gt;srcpad,
 343           GST_ELEMENT_CAST (tagdemux), NULL);
 344       GST_DEBUG_OBJECT (tagdemux, &quot;Creating new STREAM_START event&quot;);
 345       event = gst_event_new_stream_start (stream_id);
 346       g_free (stream_id);
 347       gst_event_set_group_id (event, gst_util_group_id_next ());
 348     }
 349     gst_pad_push_event (tagdemux-&gt;priv-&gt;srcpad, event);
 350 
 351     gst_pad_set_caps (tagdemux-&gt;priv-&gt;srcpad, tagdemux-&gt;priv-&gt;src_caps);
 352   } else {
 353     /* Caps never changed */
 354   }
 355 }
 356 
</pre>
<hr />
<pre>
 646           /* Just break for more data */
 647           gst_buffer_unref (typefind_buf);
 648           return GST_FLOW_OK;
 649         }
 650 
 651         /* We failed typefind */
 652         GST_ELEMENT_ERROR (demux, STREAM, TYPE_NOT_FOUND, (NULL),
 653             (&quot;Could not detect type for contents within tag&quot;));
 654         gst_buffer_unref (typefind_buf);
 655         gst_buffer_unref (demux-&gt;priv-&gt;collect);
 656         demux-&gt;priv-&gt;collect = NULL;
 657         demux-&gt;priv-&gt;collect_size = 0;
 658         return GST_FLOW_ERROR;
 659       }
 660       gst_buffer_unref (typefind_buf);
 661 
 662       GST_DEBUG_OBJECT (demux, &quot;Found type %&quot; GST_PTR_FORMAT &quot; with a &quot;
 663           &quot;probability of %u&quot;, caps, probability);
 664 
 665       gst_tag_demux_set_src_caps (demux, caps);
<span class="line-modified"> 666         gst_caps_unref (caps);</span>
 667 
 668       /* Move onto streaming and fall-through to push out existing
 669        * data */
 670       demux-&gt;priv-&gt;state = GST_TAG_DEMUX_STREAMING;
 671       /* fall-through */
 672     }
 673     case GST_TAG_DEMUX_STREAMING:{
 674       GstBuffer *outbuf = NULL;
 675       gsize outbuf_size;
 676 
 677       update_collected (demux);
 678 
 679       /* Trim the buffer and adjust offset */
 680       if (demux-&gt;priv-&gt;collect) {
 681         outbuf = demux-&gt;priv-&gt;collect;
 682         demux-&gt;priv-&gt;collect = NULL;
 683         demux-&gt;priv-&gt;collect_size = 0;
 684         if (!gst_tag_demux_trim_buffer (demux, &amp;outbuf, &amp;outbuf_size))
 685           return GST_FLOW_EOS;
 686       }
</pre>
<hr />
<pre>
 718   return gst_tag_demux_chain_buffer (GST_TAG_DEMUX (parent), buf, FALSE);
 719 }
 720 
 721 static gboolean
 722 gst_tag_demux_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
 723 {
 724   GstTagDemux *demux;
 725   gboolean ret;
 726 
 727   demux = GST_TAG_DEMUX (parent);
 728 
 729   switch (GST_EVENT_TYPE (event)) {
 730     case GST_EVENT_EOS:
 731       if (!gst_pad_has_current_caps (demux-&gt;priv-&gt;srcpad)) {
 732         GST_INFO_OBJECT (demux, &quot;EOS before we found a type&quot;);
 733 
 734         /* push final buffer with eos indication to force typefinding */
 735         gst_tag_demux_chain_buffer (demux, gst_buffer_new (), TRUE);
 736 
 737         if (!gst_pad_has_current_caps (demux-&gt;priv-&gt;srcpad)) {
<span class="line-modified"> 738         GST_ELEMENT_ERROR (demux, STREAM, TYPE_NOT_FOUND, (NULL), (NULL));</span>
<span class="line-modified"> 739       }</span>
 740       }
 741       ret = gst_pad_event_default (pad, parent, event);
 742       break;
 743     case GST_EVENT_SEGMENT:
 744     {
 745       gst_event_copy_segment (event, &amp;demux-&gt;priv-&gt;segment);
 746 
 747       demux-&gt;priv-&gt;need_newseg = TRUE;
 748       gst_event_unref (event);
 749       ret = TRUE;
 750       break;
 751     }
 752     case GST_EVENT_FLUSH_STOP:
 753     case GST_EVENT_FLUSH_START:
 754       ret = gst_pad_event_default (pad, parent, event);
 755       break;
 756     case GST_EVENT_CAPS:
 757       /* we drop the caps event. We do typefind and push a new caps event. */
 758       ret = gst_pad_event_default (pad, parent, event);
 759       break;
</pre>
<hr />
<pre>
 904     gst_element_post_message (GST_ELEMENT (tagdemux), msg);
 905   }
 906 
 907   tagdemux-&gt;priv-&gt;need_newseg = TRUE;
 908 
 909   /* restart our task since it might have been stopped when we did the
 910    * flush. */
 911   gst_pad_start_task (tagdemux-&gt;priv-&gt;sinkpad,
 912       (GstTaskFunction) gst_tag_demux_element_loop, tagdemux, NULL);
 913 
 914   /* streaming can continue now */
 915   GST_PAD_STREAM_UNLOCK (tagdemux-&gt;priv-&gt;sinkpad);
 916 
 917   return TRUE;
 918 }
 919 
 920 static gboolean
 921 gst_tag_demux_seek_push (GstTagDemux * tagdemux, GstEvent * event)
 922 {
 923   gboolean res = FALSE;
<span class="line-modified"> 924       gdouble rate;</span>
<span class="line-modified"> 925       GstFormat format;</span>
 926   GstSeekType start_type, stop_type;
<span class="line-modified"> 927       GstSeekFlags flags;</span>
 928   gint64 start, stop;
 929 
<span class="line-modified"> 930       gst_event_parse_seek (event, &amp;rate, &amp;format, &amp;flags,</span>
 931       &amp;start_type, &amp;start, &amp;stop_type, &amp;stop);
 932 
<span class="line-modified"> 933       if (format == GST_FORMAT_BYTES &amp;&amp;</span>
<span class="line-modified"> 934           tagdemux-&gt;priv-&gt;state == GST_TAG_DEMUX_STREAMING &amp;&amp;</span>
<span class="line-modified"> 935           gst_pad_is_linked (tagdemux-&gt;priv-&gt;sinkpad)) {</span>
<span class="line-modified"> 936         GstEvent *upstream;</span>
 937 
 938     switch (start_type) {
<span class="line-modified"> 939           case GST_SEEK_TYPE_SET:</span>
 940         if (start == -1)
 941           start = 0;
 942         start += tagdemux-&gt;priv-&gt;strip_start;
<span class="line-modified"> 943             break;</span>
<span class="line-modified"> 944           case GST_SEEK_TYPE_END:</span>
<span class="line-modified"> 945             /* Adjust the seek to be relative to the start of any end tag</span>
<span class="line-modified"> 946              * (note: 10 bytes before end is represented by stop=-10) */</span>
 947         if (start &gt; 0)
 948           start = 0;
 949         start -= tagdemux-&gt;priv-&gt;strip_end;
<span class="line-modified"> 950             break;</span>
<span class="line-modified"> 951           case GST_SEEK_TYPE_NONE:</span>
<span class="line-modified"> 952           default:</span>
<span class="line-modified"> 953             break;</span>
<span class="line-modified"> 954         }</span>
<span class="line-modified"> 955         switch (stop_type) {</span>
<span class="line-modified"> 956           case GST_SEEK_TYPE_SET:</span>
<span class="line-modified"> 957             if (stop != -1) {</span>
<span class="line-modified"> 958               /* -1 means the end of the file, pass it upstream intact */</span>
<span class="line-modified"> 959               stop += tagdemux-&gt;priv-&gt;strip_start;</span>
<span class="line-removed"> 960             }</span>
<span class="line-removed"> 961             break;</span>
<span class="line-removed"> 962           case GST_SEEK_TYPE_END:</span>
<span class="line-removed"> 963             /* Adjust the seek to be relative to the start of any end tag</span>
<span class="line-removed"> 964              * (note: 10 bytes before end is represented by stop=-10) */</span>
<span class="line-removed"> 965             if (stop &gt; 0)</span>
<span class="line-removed"> 966               stop = 0;</span>
<span class="line-removed"> 967             stop -= tagdemux-&gt;priv-&gt;strip_end;</span>
<span class="line-removed"> 968             break;</span>
<span class="line-removed"> 969           case GST_SEEK_TYPE_NONE:</span>
<span class="line-removed"> 970           default:</span>
<span class="line-removed"> 971             break;</span>
 972         }
<span class="line-modified"> 973         upstream = gst_event_new_seek (rate, format, flags,</span>












 974         start_type, start, stop_type, stop);
<span class="line-modified"> 975         res = gst_pad_push_event (tagdemux-&gt;priv-&gt;sinkpad, upstream);</span>
 976   } else if (format == GST_FORMAT_TIME &amp;&amp;
 977       tagdemux-&gt;priv-&gt;state == GST_TAG_DEMUX_STREAMING &amp;&amp;
 978       gst_pad_is_linked (tagdemux-&gt;priv-&gt;sinkpad)) {
 979     res = gst_pad_push_event (tagdemux-&gt;priv-&gt;sinkpad, gst_event_ref (event));
<span class="line-modified"> 980       }</span>
 981 
 982   return res;
 983 }
 984 
 985 static gboolean
 986 gst_tag_demux_srcpad_event (GstPad * pad, GstObject * parent, GstEvent * event)
 987 {
 988   GstTagDemux *tagdemux;
 989   gboolean res = FALSE;
 990 
 991   tagdemux = GST_TAG_DEMUX (parent);
 992 
 993   /* Handle SEEK events, with adjusted byte offsets and sizes. */
 994 
 995   switch (GST_EVENT_TYPE (event)) {
 996     case GST_EVENT_SEEK:
 997     {
 998       if (GST_PAD_MODE (tagdemux-&gt;priv-&gt;sinkpad) == GST_PAD_MODE_PUSH)
 999         res = gst_tag_demux_seek_push (tagdemux, event);
1000       else
</pre>
<hr />
<pre>
1368       (GstTypeFindHelperGetRangeFunction) gst_tag_demux_read_range,
1369       demux-&gt;priv-&gt;upstream_size
1370       - (demux-&gt;priv-&gt;strip_start + demux-&gt;priv-&gt;strip_end), NULL,
1371       &amp;caps, &amp;probability);
1372   if (ret != GST_FLOW_OK)
1373     goto read_tag_error;
1374 
1375   GST_INFO_OBJECT (demux, &quot;Found type %&quot; GST_PTR_FORMAT &quot; with a &quot;
1376       &quot;probability of %u&quot;, caps, probability);
1377 
1378   /* 3 - If we didn&#39;t find the caps, fail */
1379   if (caps == NULL)
1380     goto no_caps;
1381 
1382   /* tag reading and typefinding were already done, don&#39;t do them again in
1383    * the chain function if we end up in push mode */
1384   demux-&gt;priv-&gt;state = GST_TAG_DEMUX_STREAMING;
1385 
1386   /* 6 Set the srcpad caps now that we know them */
1387   gst_tag_demux_set_src_caps (demux, caps);
<span class="line-modified">1388       gst_caps_unref (caps);</span>
1389 
1390 skip_typefinding:
1391 
1392   /* set it again, in case we skipped typefinding */
1393   demux-&gt;priv-&gt;state = GST_TAG_DEMUX_STREAMING;
1394   demux-&gt;priv-&gt;offset += demux-&gt;priv-&gt;strip_start;
1395 
1396   return ret;
1397 
1398   /* ERRORS */
1399 no_size:
1400   {
1401     GST_ELEMENT_ERROR (demux, STREAM, TYPE_NOT_FOUND,
1402         (&quot;Could not get stream size&quot;), (NULL));
1403     return GST_FLOW_ERROR;
1404   }
1405 read_tag_error:
1406   {
1407     if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS)
1408       GST_ELEMENT_FLOW_ERROR (demux, ret);
</pre>
<hr />
<pre>
1438  * 4. set caps on srcpad
1439  */
1440 static void
1441 gst_tag_demux_element_loop (GstTagDemux * demux)
1442 {
1443   GstFlowReturn ret;
1444 
1445   switch (demux-&gt;priv-&gt;state) {
1446     case GST_TAG_DEMUX_READ_START_TAG:
1447     case GST_TAG_DEMUX_TYPEFINDING:
1448       ret = gst_tag_demux_element_find (demux);
1449       break;
1450     case GST_TAG_DEMUX_STREAMING:
1451     {
1452       GstBuffer *outbuf = NULL;
1453 
1454       if (demux-&gt;priv-&gt;need_newseg) {
1455         demux-&gt;priv-&gt;need_newseg = FALSE;
1456         /* FIXME: check segment, should be 0-N for downstream */
1457         gst_tag_demux_send_new_segment (demux);
<span class="line-modified">1458   }</span>
1459 
1460       /* Send our own pending tag event */
1461       if (demux-&gt;priv-&gt;send_tag_event) {
1462         gst_tag_demux_send_tag_event (demux);
1463         demux-&gt;priv-&gt;send_tag_event = FALSE;
1464       }
1465 
1466       /* Pull data and push it downstream */
1467       ret = gst_pad_pull_range (demux-&gt;priv-&gt;sinkpad, demux-&gt;priv-&gt;offset,
1468           DEFAULT_PULL_BLOCKSIZE, &amp;outbuf);
1469 
1470       if (ret != GST_FLOW_OK)
1471         break;
1472 
1473       GST_BUFFER_OFFSET (outbuf) =
1474           demux-&gt;priv-&gt;offset - demux-&gt;priv-&gt;strip_start;
1475       demux-&gt;priv-&gt;offset += gst_buffer_get_size (outbuf);
1476       GST_BUFFER_OFFSET_END (outbuf) =
1477           demux-&gt;priv-&gt;offset - demux-&gt;priv-&gt;strip_start;
1478 
1479       ret = gst_pad_push (demux-&gt;priv-&gt;srcpad, outbuf);
1480       break;
<span class="line-modified">1481   }</span>
1482     default:
1483       ret = GST_FLOW_ERROR;
1484       break;
1485   }
1486   if (ret != GST_FLOW_OK)
1487     goto pause;
1488 
1489   return;
1490 
1491   /* ERRORS */
1492 pause:
1493   {
1494     const gchar *reason = gst_flow_get_name (ret);
1495     gboolean push_eos = FALSE;
1496 
1497     GST_LOG_OBJECT (demux, &quot;pausing task, reason %s&quot;, reason);
1498     gst_pad_pause_task (demux-&gt;priv-&gt;sinkpad);
1499 
1500     if (ret == GST_FLOW_EOS) {
1501       /* perform EOS logic */
1502 
1503       if (demux-&gt;priv-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
1504         gint64 stop;
1505 
1506         /* for segment playback we need to post when (in stream time)
1507          * we stopped, this is either stop (when set) or the duration. */
1508         if ((stop = demux-&gt;priv-&gt;segment.stop) == -1)
1509           stop = demux-&gt;priv-&gt;offset;
1510 
1511         GST_LOG_OBJECT (demux, &quot;Sending segment done, at end of segment&quot;);
1512         gst_element_post_message (GST_ELEMENT_CAST (demux),
1513             gst_message_new_segment_done (GST_OBJECT_CAST (demux),
1514                 GST_FORMAT_BYTES, stop));
1515         gst_pad_push_event (demux-&gt;priv-&gt;srcpad,
1516             gst_event_new_segment_done (GST_FORMAT_BYTES, stop));
1517       } else {
1518         push_eos = TRUE;
<span class="line-modified">1519   }</span>
1520     } else if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS) {
1521       /* for fatal errors we post an error message */
1522       GST_ELEMENT_FLOW_ERROR (demux, ret);
1523       push_eos = TRUE;
1524     }
1525     if (push_eos) {
1526       /* send EOS, and prevent hanging if no streams yet */
1527       GST_LOG_OBJECT (demux, &quot;Sending EOS, at end of stream&quot;);
1528       gst_pad_push_event (demux-&gt;priv-&gt;srcpad, gst_event_new_eos ());
1529     }
1530     return;
1531   }
1532 }
1533 
1534 static gboolean
1535 gst_tag_demux_sink_activate_mode (GstPad * pad, GstObject * parent,
1536     GstPadMode mode, gboolean active)
1537 {
1538   GstTagDemux *demux = GST_TAG_DEMUX (parent);
1539   gboolean res;
</pre>
<hr />
<pre>
1811         GST_PTR_FORMAT, GST_EVENT_TYPE_NAME (events-&gt;data), events-&gt;data);
1812     gst_pad_push_event (demux-&gt;priv-&gt;srcpad, GST_EVENT (events-&gt;data));
1813     events = g_list_delete_link (events, events);
1814   }
1815 }
1816 
1817 static void
1818 gst_tag_demux_send_tag_event (GstTagDemux * demux)
1819 {
1820   /* FIXME: what&#39;s the correct merge mode? Docs need to tell... */
1821   GstTagList *merged = gst_tag_list_merge (demux-&gt;priv-&gt;event_tags,
1822       demux-&gt;priv-&gt;parsed_tags, GST_TAG_MERGE_KEEP);
1823 
1824   if (merged) {
1825     GstEvent *event = gst_event_new_tag (merged);
1826 #ifdef GSTREAMER_LITE
1827   if (event == NULL)
1828     return;
1829 #endif // GSTREAMER_LITE
1830 
<span class="line-removed">1831     GST_EVENT_TIMESTAMP (event) = 0;</span>
1832     GST_DEBUG_OBJECT (demux, &quot;Sending tag event on src pad&quot;);
1833     gst_pad_push_event (demux-&gt;priv-&gt;srcpad, event);
1834   }
1835 }
1836 
1837 static gboolean
1838 gst_tag_demux_send_new_segment (GstTagDemux * tagdemux)
1839 {
1840   GstEvent *event;
1841   gint64 start, stop, time;
1842   GstSegment *seg = &amp;tagdemux-&gt;priv-&gt;segment;
1843   GstSegment newseg;
1844 
1845   if (seg-&gt;format == GST_FORMAT_UNDEFINED) {
1846     GST_LOG_OBJECT (tagdemux,
1847         &quot;No new segment received before first buffer. Using default&quot;);
1848     gst_segment_init (seg, GST_FORMAT_BYTES);
1849     seg-&gt;start = tagdemux-&gt;priv-&gt;strip_start;
1850     seg-&gt;time = tagdemux-&gt;priv-&gt;strip_start;
1851   }
</pre>
</td>
<td>
<hr />
<pre>
 150     GstCaps * new_caps);
 151 
 152 static gboolean gst_tag_demux_srcpad_event (GstPad * pad, GstObject * parent,
 153     GstEvent * event);
 154 static gboolean gst_tag_demux_sink_activate (GstPad * sinkpad,
 155     GstObject * parent);
 156 static GstStateChangeReturn gst_tag_demux_change_state (GstElement * element,
 157     GstStateChange transition);
 158 static gboolean gst_tag_demux_pad_query (GstPad * pad, GstObject * parent,
 159     GstQuery * query);
 160 static gboolean gst_tag_demux_get_upstream_size (GstTagDemux * tagdemux);
 161 static void gst_tag_demux_send_pending_events (GstTagDemux * tagdemux);
 162 static void gst_tag_demux_send_tag_event (GstTagDemux * tagdemux);
 163 static gboolean gst_tag_demux_send_new_segment (GstTagDemux * tagdemux);
 164 
 165 static void gst_tag_demux_base_init (gpointer g_class);
 166 static void gst_tag_demux_class_init (gpointer g_class, gpointer d);
 167 static void gst_tag_demux_init (GstTagDemux * obj, GstTagDemuxClass * klass);
 168 
 169 static gpointer parent_class;   /* NULL */
<span class="line-added"> 170 static gint private_offset = 0;</span>
 171 
 172 /* Cannot use boilerplate macros here because we want the abstract flag */
 173 GType
 174 gst_tag_demux_get_type (void)
 175 {
 176   static GType object_type;     /* 0 */
 177 
 178   if (object_type == 0) {
 179     static const GTypeInfo object_info = {
 180       sizeof (GstTagDemuxClass),
 181       gst_tag_demux_base_init,
 182       NULL,                     /* base_finalize */
 183       gst_tag_demux_class_init,
 184       NULL,                     /* class_finalize */
 185       NULL,                     /* class_data */
 186       sizeof (GstTagDemux),
 187       0,                        /* n_preallocs */
 188       (GInstanceInitFunc) gst_tag_demux_init
 189     };
 190 
 191     object_type = g_type_register_static (GST_TYPE_ELEMENT,
 192         &quot;GstTagDemux&quot;, &amp;object_info, G_TYPE_FLAG_ABSTRACT);
<span class="line-added"> 193 </span>
<span class="line-added"> 194     private_offset =</span>
<span class="line-added"> 195         g_type_add_instance_private (object_type, sizeof (GstTagDemuxPrivate));</span>
 196   }
 197 
 198   return object_type;
 199 }
 200 
<span class="line-added"> 201 static inline GstTagDemuxPrivate *</span>
<span class="line-added"> 202 gst_tag_demux_get_instance_private (GstTagDemux * self)</span>
<span class="line-added"> 203 {</span>
<span class="line-added"> 204   return (G_STRUCT_MEMBER_P (self, private_offset));</span>
<span class="line-added"> 205 }</span>
<span class="line-added"> 206 </span>
 207 static void
 208 gst_tag_demux_base_init (gpointer klass)
 209 {
 210   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 211 
 212   gst_element_class_add_static_pad_template (element_class, &amp;src_factory);
 213 
 214   GST_DEBUG_CATEGORY_INIT (tagdemux_debug, &quot;tagdemux&quot;, 0,
 215       &quot;tag demux base class&quot;);
 216 }
 217 
 218 static void
 219 gst_tag_demux_class_init (gpointer klass, gpointer d)
 220 {
 221   GstTagDemuxClass *tagdemux_class = GST_TAG_DEMUX_CLASS (klass);
 222   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 223   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 224 
 225   parent_class = g_type_class_peek_parent (klass);
 226 
 227   gobject_class-&gt;dispose = gst_tag_demux_dispose;
 228 
 229   element_class-&gt;change_state = GST_DEBUG_FUNCPTR (gst_tag_demux_change_state);
 230 
<span class="line-modified"> 231   if (private_offset != 0)</span>
<span class="line-added"> 232     g_type_class_adjust_private_offset (klass, &amp;private_offset);</span>
 233 
 234   /* subclasses must set at least one of these */
 235   tagdemux_class-&gt;min_start_size = 0;
 236   tagdemux_class-&gt;min_end_size = 0;
 237 }
 238 
 239 static void
 240 gst_tag_demux_reset (GstTagDemux * tagdemux)
 241 {
 242   GstBuffer **buffer_p = &amp;tagdemux-&gt;priv-&gt;collect;
 243   GstCaps **caps_p = &amp;tagdemux-&gt;priv-&gt;src_caps;
 244 
 245   tagdemux-&gt;priv-&gt;strip_start = 0;
 246   tagdemux-&gt;priv-&gt;strip_end = 0;
 247   tagdemux-&gt;priv-&gt;upstream_size = -1;
 248   tagdemux-&gt;priv-&gt;state = GST_TAG_DEMUX_READ_START_TAG;
 249   tagdemux-&gt;priv-&gt;send_tag_event = FALSE;
 250 
 251   gst_buffer_replace (buffer_p, NULL);
 252   tagdemux-&gt;priv-&gt;collect_size = 0;
</pre>
<hr />
<pre>
 261   if (tagdemux-&gt;priv-&gt;parsed_tags) {
 262     gst_tag_list_unref (tagdemux-&gt;priv-&gt;parsed_tags);
 263     tagdemux-&gt;priv-&gt;parsed_tags = NULL;
 264   }
 265 
 266   gst_segment_init (&amp;tagdemux-&gt;priv-&gt;segment, GST_FORMAT_UNDEFINED);
 267   tagdemux-&gt;priv-&gt;need_newseg = TRUE;
 268 
 269   g_list_foreach (tagdemux-&gt;priv-&gt;pending_events,
 270       (GFunc) gst_mini_object_unref, NULL);
 271   g_list_free (tagdemux-&gt;priv-&gt;pending_events);
 272   tagdemux-&gt;priv-&gt;pending_events = NULL;
 273 }
 274 
 275 static void
 276 gst_tag_demux_init (GstTagDemux * demux, GstTagDemuxClass * gclass)
 277 {
 278   GstElementClass *element_klass = GST_ELEMENT_CLASS (gclass);
 279   GstPadTemplate *tmpl;
 280 
<span class="line-modified"> 281   demux-&gt;priv = gst_tag_demux_get_instance_private (demux);</span>

 282 
 283   /* sink pad */
 284   tmpl = gst_element_class_get_pad_template (element_klass, &quot;sink&quot;);
 285   if (tmpl) {
 286     demux-&gt;priv-&gt;sinkpad = gst_pad_new_from_template (tmpl, &quot;sink&quot;);
 287 
 288     gst_pad_set_activatemode_function (demux-&gt;priv-&gt;sinkpad,
 289         GST_DEBUG_FUNCPTR (gst_tag_demux_sink_activate_mode));
 290     gst_pad_set_activate_function (demux-&gt;priv-&gt;sinkpad,
 291         GST_DEBUG_FUNCPTR (gst_tag_demux_sink_activate));
 292     gst_pad_set_event_function (demux-&gt;priv-&gt;sinkpad,
 293         GST_DEBUG_FUNCPTR (gst_tag_demux_sink_event));
 294     gst_pad_set_chain_function (demux-&gt;priv-&gt;sinkpad,
 295         GST_DEBUG_FUNCPTR (gst_tag_demux_chain));
 296     gst_element_add_pad (GST_ELEMENT (demux), demux-&gt;priv-&gt;sinkpad);
 297   } else {
 298     g_warning (&quot;GstTagDemux subclass %s must provide a sink pad template&quot;,
 299         G_OBJECT_TYPE_NAME (demux));
 300   }
 301 
</pre>
<hr />
<pre>
 325   gst_tag_demux_reset (tagdemux);
 326   if (tagdemux-&gt;priv-&gt;adapter) {
 327     g_object_unref (tagdemux-&gt;priv-&gt;adapter);
 328     tagdemux-&gt;priv-&gt;adapter = NULL;
 329   }
 330 
 331   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
 332 }
 333 
 334 // FIXME: convert to set_caps / sending a caps event
 335 static void
 336 gst_tag_demux_set_src_caps (GstTagDemux * tagdemux, GstCaps * new_caps)
 337 {
 338   GstCaps *old_caps = tagdemux-&gt;priv-&gt;src_caps;
 339 
 340   if (old_caps == NULL || !gst_caps_is_equal (new_caps, old_caps)) {
 341     GstEvent *event;
 342 
 343     gst_caps_replace (&amp;tagdemux-&gt;priv-&gt;src_caps, new_caps);
 344 
<span class="line-modified"> 345     GST_DEBUG_OBJECT (tagdemux, &quot;Changing src pad caps to %&quot; GST_PTR_FORMAT,</span>
<span class="line-modified"> 346         tagdemux-&gt;priv-&gt;src_caps);</span>
 347 
 348     event =
 349         gst_pad_get_sticky_event (tagdemux-&gt;priv-&gt;sinkpad,
 350         GST_EVENT_STREAM_START, 0);
 351     if (!event) {
 352       gchar *stream_id = gst_pad_create_stream_id (tagdemux-&gt;priv-&gt;srcpad,
 353           GST_ELEMENT_CAST (tagdemux), NULL);
 354       GST_DEBUG_OBJECT (tagdemux, &quot;Creating new STREAM_START event&quot;);
 355       event = gst_event_new_stream_start (stream_id);
 356       g_free (stream_id);
 357       gst_event_set_group_id (event, gst_util_group_id_next ());
 358     }
 359     gst_pad_push_event (tagdemux-&gt;priv-&gt;srcpad, event);
 360 
 361     gst_pad_set_caps (tagdemux-&gt;priv-&gt;srcpad, tagdemux-&gt;priv-&gt;src_caps);
 362   } else {
 363     /* Caps never changed */
 364   }
 365 }
 366 
</pre>
<hr />
<pre>
 656           /* Just break for more data */
 657           gst_buffer_unref (typefind_buf);
 658           return GST_FLOW_OK;
 659         }
 660 
 661         /* We failed typefind */
 662         GST_ELEMENT_ERROR (demux, STREAM, TYPE_NOT_FOUND, (NULL),
 663             (&quot;Could not detect type for contents within tag&quot;));
 664         gst_buffer_unref (typefind_buf);
 665         gst_buffer_unref (demux-&gt;priv-&gt;collect);
 666         demux-&gt;priv-&gt;collect = NULL;
 667         demux-&gt;priv-&gt;collect_size = 0;
 668         return GST_FLOW_ERROR;
 669       }
 670       gst_buffer_unref (typefind_buf);
 671 
 672       GST_DEBUG_OBJECT (demux, &quot;Found type %&quot; GST_PTR_FORMAT &quot; with a &quot;
 673           &quot;probability of %u&quot;, caps, probability);
 674 
 675       gst_tag_demux_set_src_caps (demux, caps);
<span class="line-modified"> 676       gst_caps_unref (caps);</span>
 677 
 678       /* Move onto streaming and fall-through to push out existing
 679        * data */
 680       demux-&gt;priv-&gt;state = GST_TAG_DEMUX_STREAMING;
 681       /* fall-through */
 682     }
 683     case GST_TAG_DEMUX_STREAMING:{
 684       GstBuffer *outbuf = NULL;
 685       gsize outbuf_size;
 686 
 687       update_collected (demux);
 688 
 689       /* Trim the buffer and adjust offset */
 690       if (demux-&gt;priv-&gt;collect) {
 691         outbuf = demux-&gt;priv-&gt;collect;
 692         demux-&gt;priv-&gt;collect = NULL;
 693         demux-&gt;priv-&gt;collect_size = 0;
 694         if (!gst_tag_demux_trim_buffer (demux, &amp;outbuf, &amp;outbuf_size))
 695           return GST_FLOW_EOS;
 696       }
</pre>
<hr />
<pre>
 728   return gst_tag_demux_chain_buffer (GST_TAG_DEMUX (parent), buf, FALSE);
 729 }
 730 
 731 static gboolean
 732 gst_tag_demux_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
 733 {
 734   GstTagDemux *demux;
 735   gboolean ret;
 736 
 737   demux = GST_TAG_DEMUX (parent);
 738 
 739   switch (GST_EVENT_TYPE (event)) {
 740     case GST_EVENT_EOS:
 741       if (!gst_pad_has_current_caps (demux-&gt;priv-&gt;srcpad)) {
 742         GST_INFO_OBJECT (demux, &quot;EOS before we found a type&quot;);
 743 
 744         /* push final buffer with eos indication to force typefinding */
 745         gst_tag_demux_chain_buffer (demux, gst_buffer_new (), TRUE);
 746 
 747         if (!gst_pad_has_current_caps (demux-&gt;priv-&gt;srcpad)) {
<span class="line-modified"> 748           GST_ELEMENT_ERROR (demux, STREAM, TYPE_NOT_FOUND, (NULL), (NULL));</span>
<span class="line-modified"> 749         }</span>
 750       }
 751       ret = gst_pad_event_default (pad, parent, event);
 752       break;
 753     case GST_EVENT_SEGMENT:
 754     {
 755       gst_event_copy_segment (event, &amp;demux-&gt;priv-&gt;segment);
 756 
 757       demux-&gt;priv-&gt;need_newseg = TRUE;
 758       gst_event_unref (event);
 759       ret = TRUE;
 760       break;
 761     }
 762     case GST_EVENT_FLUSH_STOP:
 763     case GST_EVENT_FLUSH_START:
 764       ret = gst_pad_event_default (pad, parent, event);
 765       break;
 766     case GST_EVENT_CAPS:
 767       /* we drop the caps event. We do typefind and push a new caps event. */
 768       ret = gst_pad_event_default (pad, parent, event);
 769       break;
</pre>
<hr />
<pre>
 914     gst_element_post_message (GST_ELEMENT (tagdemux), msg);
 915   }
 916 
 917   tagdemux-&gt;priv-&gt;need_newseg = TRUE;
 918 
 919   /* restart our task since it might have been stopped when we did the
 920    * flush. */
 921   gst_pad_start_task (tagdemux-&gt;priv-&gt;sinkpad,
 922       (GstTaskFunction) gst_tag_demux_element_loop, tagdemux, NULL);
 923 
 924   /* streaming can continue now */
 925   GST_PAD_STREAM_UNLOCK (tagdemux-&gt;priv-&gt;sinkpad);
 926 
 927   return TRUE;
 928 }
 929 
 930 static gboolean
 931 gst_tag_demux_seek_push (GstTagDemux * tagdemux, GstEvent * event)
 932 {
 933   gboolean res = FALSE;
<span class="line-modified"> 934   gdouble rate;</span>
<span class="line-modified"> 935   GstFormat format;</span>
 936   GstSeekType start_type, stop_type;
<span class="line-modified"> 937   GstSeekFlags flags;</span>
 938   gint64 start, stop;
 939 
<span class="line-modified"> 940   gst_event_parse_seek (event, &amp;rate, &amp;format, &amp;flags,</span>
 941       &amp;start_type, &amp;start, &amp;stop_type, &amp;stop);
 942 
<span class="line-modified"> 943   if (format == GST_FORMAT_BYTES &amp;&amp;</span>
<span class="line-modified"> 944       tagdemux-&gt;priv-&gt;state == GST_TAG_DEMUX_STREAMING &amp;&amp;</span>
<span class="line-modified"> 945       gst_pad_is_linked (tagdemux-&gt;priv-&gt;sinkpad)) {</span>
<span class="line-modified"> 946     GstEvent *upstream;</span>
 947 
 948     switch (start_type) {
<span class="line-modified"> 949       case GST_SEEK_TYPE_SET:</span>
 950         if (start == -1)
 951           start = 0;
 952         start += tagdemux-&gt;priv-&gt;strip_start;
<span class="line-modified"> 953         break;</span>
<span class="line-modified"> 954       case GST_SEEK_TYPE_END:</span>
<span class="line-modified"> 955         /* Adjust the seek to be relative to the start of any end tag</span>
<span class="line-modified"> 956          * (note: 10 bytes before end is represented by stop=-10) */</span>
 957         if (start &gt; 0)
 958           start = 0;
 959         start -= tagdemux-&gt;priv-&gt;strip_end;
<span class="line-modified"> 960         break;</span>
<span class="line-modified"> 961       case GST_SEEK_TYPE_NONE:</span>
<span class="line-modified"> 962       default:</span>
<span class="line-modified"> 963         break;</span>
<span class="line-modified"> 964     }</span>
<span class="line-modified"> 965     switch (stop_type) {</span>
<span class="line-modified"> 966       case GST_SEEK_TYPE_SET:</span>
<span class="line-modified"> 967         if (stop != -1) {</span>
<span class="line-modified"> 968           /* -1 means the end of the file, pass it upstream intact */</span>
<span class="line-modified"> 969           stop += tagdemux-&gt;priv-&gt;strip_start;</span>












 970         }
<span class="line-modified"> 971         break;</span>
<span class="line-added"> 972       case GST_SEEK_TYPE_END:</span>
<span class="line-added"> 973         /* Adjust the seek to be relative to the start of any end tag</span>
<span class="line-added"> 974          * (note: 10 bytes before end is represented by stop=-10) */</span>
<span class="line-added"> 975         if (stop &gt; 0)</span>
<span class="line-added"> 976           stop = 0;</span>
<span class="line-added"> 977         stop -= tagdemux-&gt;priv-&gt;strip_end;</span>
<span class="line-added"> 978         break;</span>
<span class="line-added"> 979       case GST_SEEK_TYPE_NONE:</span>
<span class="line-added"> 980       default:</span>
<span class="line-added"> 981         break;</span>
<span class="line-added"> 982     }</span>
<span class="line-added"> 983     upstream = gst_event_new_seek (rate, format, flags,</span>
 984         start_type, start, stop_type, stop);
<span class="line-modified"> 985     res = gst_pad_push_event (tagdemux-&gt;priv-&gt;sinkpad, upstream);</span>
 986   } else if (format == GST_FORMAT_TIME &amp;&amp;
 987       tagdemux-&gt;priv-&gt;state == GST_TAG_DEMUX_STREAMING &amp;&amp;
 988       gst_pad_is_linked (tagdemux-&gt;priv-&gt;sinkpad)) {
 989     res = gst_pad_push_event (tagdemux-&gt;priv-&gt;sinkpad, gst_event_ref (event));
<span class="line-modified"> 990   }</span>
 991 
 992   return res;
 993 }
 994 
 995 static gboolean
 996 gst_tag_demux_srcpad_event (GstPad * pad, GstObject * parent, GstEvent * event)
 997 {
 998   GstTagDemux *tagdemux;
 999   gboolean res = FALSE;
1000 
1001   tagdemux = GST_TAG_DEMUX (parent);
1002 
1003   /* Handle SEEK events, with adjusted byte offsets and sizes. */
1004 
1005   switch (GST_EVENT_TYPE (event)) {
1006     case GST_EVENT_SEEK:
1007     {
1008       if (GST_PAD_MODE (tagdemux-&gt;priv-&gt;sinkpad) == GST_PAD_MODE_PUSH)
1009         res = gst_tag_demux_seek_push (tagdemux, event);
1010       else
</pre>
<hr />
<pre>
1378       (GstTypeFindHelperGetRangeFunction) gst_tag_demux_read_range,
1379       demux-&gt;priv-&gt;upstream_size
1380       - (demux-&gt;priv-&gt;strip_start + demux-&gt;priv-&gt;strip_end), NULL,
1381       &amp;caps, &amp;probability);
1382   if (ret != GST_FLOW_OK)
1383     goto read_tag_error;
1384 
1385   GST_INFO_OBJECT (demux, &quot;Found type %&quot; GST_PTR_FORMAT &quot; with a &quot;
1386       &quot;probability of %u&quot;, caps, probability);
1387 
1388   /* 3 - If we didn&#39;t find the caps, fail */
1389   if (caps == NULL)
1390     goto no_caps;
1391 
1392   /* tag reading and typefinding were already done, don&#39;t do them again in
1393    * the chain function if we end up in push mode */
1394   demux-&gt;priv-&gt;state = GST_TAG_DEMUX_STREAMING;
1395 
1396   /* 6 Set the srcpad caps now that we know them */
1397   gst_tag_demux_set_src_caps (demux, caps);
<span class="line-modified">1398   gst_caps_unref (caps);</span>
1399 
1400 skip_typefinding:
1401 
1402   /* set it again, in case we skipped typefinding */
1403   demux-&gt;priv-&gt;state = GST_TAG_DEMUX_STREAMING;
1404   demux-&gt;priv-&gt;offset += demux-&gt;priv-&gt;strip_start;
1405 
1406   return ret;
1407 
1408   /* ERRORS */
1409 no_size:
1410   {
1411     GST_ELEMENT_ERROR (demux, STREAM, TYPE_NOT_FOUND,
1412         (&quot;Could not get stream size&quot;), (NULL));
1413     return GST_FLOW_ERROR;
1414   }
1415 read_tag_error:
1416   {
1417     if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS)
1418       GST_ELEMENT_FLOW_ERROR (demux, ret);
</pre>
<hr />
<pre>
1448  * 4. set caps on srcpad
1449  */
1450 static void
1451 gst_tag_demux_element_loop (GstTagDemux * demux)
1452 {
1453   GstFlowReturn ret;
1454 
1455   switch (demux-&gt;priv-&gt;state) {
1456     case GST_TAG_DEMUX_READ_START_TAG:
1457     case GST_TAG_DEMUX_TYPEFINDING:
1458       ret = gst_tag_demux_element_find (demux);
1459       break;
1460     case GST_TAG_DEMUX_STREAMING:
1461     {
1462       GstBuffer *outbuf = NULL;
1463 
1464       if (demux-&gt;priv-&gt;need_newseg) {
1465         demux-&gt;priv-&gt;need_newseg = FALSE;
1466         /* FIXME: check segment, should be 0-N for downstream */
1467         gst_tag_demux_send_new_segment (demux);
<span class="line-modified">1468       }</span>
1469 
1470       /* Send our own pending tag event */
1471       if (demux-&gt;priv-&gt;send_tag_event) {
1472         gst_tag_demux_send_tag_event (demux);
1473         demux-&gt;priv-&gt;send_tag_event = FALSE;
1474       }
1475 
1476       /* Pull data and push it downstream */
1477       ret = gst_pad_pull_range (demux-&gt;priv-&gt;sinkpad, demux-&gt;priv-&gt;offset,
1478           DEFAULT_PULL_BLOCKSIZE, &amp;outbuf);
1479 
1480       if (ret != GST_FLOW_OK)
1481         break;
1482 
1483       GST_BUFFER_OFFSET (outbuf) =
1484           demux-&gt;priv-&gt;offset - demux-&gt;priv-&gt;strip_start;
1485       demux-&gt;priv-&gt;offset += gst_buffer_get_size (outbuf);
1486       GST_BUFFER_OFFSET_END (outbuf) =
1487           demux-&gt;priv-&gt;offset - demux-&gt;priv-&gt;strip_start;
1488 
1489       ret = gst_pad_push (demux-&gt;priv-&gt;srcpad, outbuf);
1490       break;
<span class="line-modified">1491     }</span>
1492     default:
1493       ret = GST_FLOW_ERROR;
1494       break;
1495   }
1496   if (ret != GST_FLOW_OK)
1497     goto pause;
1498 
1499   return;
1500 
1501   /* ERRORS */
1502 pause:
1503   {
1504     const gchar *reason = gst_flow_get_name (ret);
1505     gboolean push_eos = FALSE;
1506 
1507     GST_LOG_OBJECT (demux, &quot;pausing task, reason %s&quot;, reason);
1508     gst_pad_pause_task (demux-&gt;priv-&gt;sinkpad);
1509 
1510     if (ret == GST_FLOW_EOS) {
1511       /* perform EOS logic */
1512 
1513       if (demux-&gt;priv-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
1514         gint64 stop;
1515 
1516         /* for segment playback we need to post when (in stream time)
1517          * we stopped, this is either stop (when set) or the duration. */
1518         if ((stop = demux-&gt;priv-&gt;segment.stop) == -1)
1519           stop = demux-&gt;priv-&gt;offset;
1520 
1521         GST_LOG_OBJECT (demux, &quot;Sending segment done, at end of segment&quot;);
1522         gst_element_post_message (GST_ELEMENT_CAST (demux),
1523             gst_message_new_segment_done (GST_OBJECT_CAST (demux),
1524                 GST_FORMAT_BYTES, stop));
1525         gst_pad_push_event (demux-&gt;priv-&gt;srcpad,
1526             gst_event_new_segment_done (GST_FORMAT_BYTES, stop));
1527       } else {
1528         push_eos = TRUE;
<span class="line-modified">1529       }</span>
1530     } else if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS) {
1531       /* for fatal errors we post an error message */
1532       GST_ELEMENT_FLOW_ERROR (demux, ret);
1533       push_eos = TRUE;
1534     }
1535     if (push_eos) {
1536       /* send EOS, and prevent hanging if no streams yet */
1537       GST_LOG_OBJECT (demux, &quot;Sending EOS, at end of stream&quot;);
1538       gst_pad_push_event (demux-&gt;priv-&gt;srcpad, gst_event_new_eos ());
1539     }
1540     return;
1541   }
1542 }
1543 
1544 static gboolean
1545 gst_tag_demux_sink_activate_mode (GstPad * pad, GstObject * parent,
1546     GstPadMode mode, gboolean active)
1547 {
1548   GstTagDemux *demux = GST_TAG_DEMUX (parent);
1549   gboolean res;
</pre>
<hr />
<pre>
1821         GST_PTR_FORMAT, GST_EVENT_TYPE_NAME (events-&gt;data), events-&gt;data);
1822     gst_pad_push_event (demux-&gt;priv-&gt;srcpad, GST_EVENT (events-&gt;data));
1823     events = g_list_delete_link (events, events);
1824   }
1825 }
1826 
1827 static void
1828 gst_tag_demux_send_tag_event (GstTagDemux * demux)
1829 {
1830   /* FIXME: what&#39;s the correct merge mode? Docs need to tell... */
1831   GstTagList *merged = gst_tag_list_merge (demux-&gt;priv-&gt;event_tags,
1832       demux-&gt;priv-&gt;parsed_tags, GST_TAG_MERGE_KEEP);
1833 
1834   if (merged) {
1835     GstEvent *event = gst_event_new_tag (merged);
1836 #ifdef GSTREAMER_LITE
1837   if (event == NULL)
1838     return;
1839 #endif // GSTREAMER_LITE
1840 

1841     GST_DEBUG_OBJECT (demux, &quot;Sending tag event on src pad&quot;);
1842     gst_pad_push_event (demux-&gt;priv-&gt;srcpad, event);
1843   }
1844 }
1845 
1846 static gboolean
1847 gst_tag_demux_send_new_segment (GstTagDemux * tagdemux)
1848 {
1849   GstEvent *event;
1850   gint64 start, stop, time;
1851   GstSegment *seg = &amp;tagdemux-&gt;priv-&gt;segment;
1852   GstSegment newseg;
1853 
1854   if (seg-&gt;format == GST_FORMAT_UNDEFINED) {
1855     GST_LOG_OBJECT (tagdemux,
1856         &quot;No new segment received before first buffer. Using default&quot;);
1857     gst_segment_init (seg, GST_FORMAT_BYTES);
1858     seg-&gt;start = tagdemux-&gt;priv-&gt;strip_start;
1859     seg-&gt;time = tagdemux-&gt;priv-&gt;strip_start;
1860   }
</pre>
</td>
</tr>
</table>
<center><a href="gstid3tag.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gsttageditingprivate.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>