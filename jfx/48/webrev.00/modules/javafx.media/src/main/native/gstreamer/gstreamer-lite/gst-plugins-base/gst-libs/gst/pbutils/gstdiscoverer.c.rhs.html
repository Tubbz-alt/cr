<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/pbutils/gstdiscoverer.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 2009 Edward Hervey &lt;edward.hervey@collabora.co.uk&gt;
   3  *               2009 Nokia Corporation
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Library General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Library General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Library General Public
  16  * License along with this library; if not, write to the
  17  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  18  * Boston, MA 02110-1301, USA.
  19  */
  20 
  21 /**
  22  * SECTION:gstdiscoverer
  23  * @title: GstDiscoverer
  24  * @short_description: Utility for discovering information on URIs.
  25  *
  26  * The #GstDiscoverer is a utility object which allows to get as much
  27  * information as possible from one or many URIs.
  28  *
  29  * It provides two APIs, allowing usage in blocking or non-blocking mode.
  30  *
  31  * The blocking mode just requires calling gst_discoverer_discover_uri()
  32  * with the URI one wishes to discover.
  33  *
  34  * The non-blocking mode requires a running #GMainLoop iterating a
  35  * #GMainContext, where one connects to the various signals, appends the
  36  * URIs to be processed (through gst_discoverer_discover_uri_async()) and then
  37  * asks for the discovery to begin (through gst_discoverer_start()).
  38  * By default this will use the GLib default main context unless you have
  39  * set a custom context using g_main_context_push_thread_default().
  40  *
  41  * All the information is returned in a #GstDiscovererInfo structure.
  42  */
  43 
  44 #ifdef HAVE_CONFIG_H
  45 #include &quot;config.h&quot;
  46 #endif
  47 
  48 #include &lt;gst/video/video.h&gt;
  49 #include &lt;gst/audio/audio.h&gt;
  50 
  51 #include &lt;string.h&gt;
  52 
  53 #include &quot;pbutils.h&quot;
  54 #include &quot;pbutils-private.h&quot;
  55 
<a name="1" id="anc1"></a><span class="line-added">  56 /* For g_stat () */</span>
<span class="line-added">  57 #include &lt;glib/gstdio.h&gt;</span>
<span class="line-added">  58 </span>
  59 GST_DEBUG_CATEGORY_STATIC (discoverer_debug);
  60 #define GST_CAT_DEFAULT discoverer_debug
<a name="2" id="anc2"></a><span class="line-added">  61 #define CACHE_DIRNAME &quot;discoverer&quot;</span>
  62 
  63 static GQuark _CAPS_QUARK;
  64 static GQuark _TAGS_QUARK;
  65 static GQuark _ELEMENT_SRCPAD_QUARK;
  66 static GQuark _TOC_QUARK;
  67 static GQuark _STREAM_ID_QUARK;
  68 static GQuark _MISSING_PLUGIN_QUARK;
  69 static GQuark _STREAM_TOPOLOGY_QUARK;
  70 static GQuark _TOPOLOGY_PAD_QUARK;
  71 
  72 
  73 typedef struct
  74 {
  75   GstDiscoverer *dc;
  76   GstPad *pad;
  77   GstElement *queue;
  78   GstElement *sink;
  79   GstTagList *tags;
  80   GstToc *toc;
  81   gchar *stream_id;
  82   gulong probe_id;
  83 } PrivateStream;
  84 
  85 struct _GstDiscovererPrivate
  86 {
  87   gboolean async;
  88 
  89   /* allowed time to discover each uri in nanoseconds */
  90   GstClockTime timeout;
  91 
  92   /* list of pending URI to process (current excluded) */
  93   GList *pending_uris;
  94 
  95   GMutex lock;
  96   /* TRUE if cleaning up discoverer */
  97   gboolean cleanup;
  98 
  99   /* TRUE if processing a URI */
 100   gboolean processing;
 101 
 102   /* TRUE if discoverer has been started */
 103   gboolean running;
 104 
 105   /* current items */
 106   GstDiscovererInfo *current_info;
 107   GError *current_error;
 108   GstStructure *current_topology;
 109 
 110   /* List of private streams */
 111   GList *streams;
 112 
 113   /* List of these sinks and their handler IDs (to remove the probe) */
 114   guint pending_subtitle_pads;
 115 
 116   /* Whether we received no_more_pads */
 117   gboolean no_more_pads;
 118 
 119   GstState target_state;
 120   GstState current_state;
 121 
 122   /* Global elements */
 123   GstBin *pipeline;
 124   GstElement *uridecodebin;
 125   GstBus *bus;
 126 
 127   GType decodebin_type;
 128 
 129   /* Custom main context variables */
 130   GMainContext *ctx;
<a name="3" id="anc3"></a><span class="line-modified"> 131   GSource *bus_source;</span>
<span class="line-modified"> 132   GSource *timeout_source;</span>
 133 
 134   /* reusable queries */
 135   GstQuery *seeking_query;
 136 
 137   /* Handler ids for various callbacks */
 138   gulong pad_added_id;
 139   gulong pad_remove_id;
 140   gulong no_more_pads_id;
 141   gulong source_chg_id;
 142   gulong element_added_id;
 143   gulong bus_cb_id;
<a name="4" id="anc4"></a><span class="line-added"> 144 </span>
<span class="line-added"> 145   gboolean use_cache;</span>
 146 };
 147 
 148 #define DISCO_LOCK(dc) g_mutex_lock (&amp;dc-&gt;priv-&gt;lock);
 149 #define DISCO_UNLOCK(dc) g_mutex_unlock (&amp;dc-&gt;priv-&gt;lock);
 150 
 151 static void
 152 _do_init (void)
 153 {
 154   GST_DEBUG_CATEGORY_INIT (discoverer_debug, &quot;discoverer&quot;, 0, &quot;Discoverer&quot;);
 155 
 156   _CAPS_QUARK = g_quark_from_static_string (&quot;caps&quot;);
 157   _ELEMENT_SRCPAD_QUARK = g_quark_from_static_string (&quot;element-srcpad&quot;);
 158   _TAGS_QUARK = g_quark_from_static_string (&quot;tags&quot;);
 159   _TOC_QUARK = g_quark_from_static_string (&quot;toc&quot;);
 160   _STREAM_ID_QUARK = g_quark_from_static_string (&quot;stream-id&quot;);
 161   _MISSING_PLUGIN_QUARK = g_quark_from_static_string (&quot;missing-plugin&quot;);
 162   _STREAM_TOPOLOGY_QUARK = g_quark_from_static_string (&quot;stream-topology&quot;);
 163   _TOPOLOGY_PAD_QUARK = g_quark_from_static_string (&quot;pad&quot;);
 164 };
 165 
 166 G_DEFINE_TYPE_EXTENDED (GstDiscoverer, gst_discoverer, G_TYPE_OBJECT, 0,
<a name="5" id="anc5"></a><span class="line-modified"> 167     G_ADD_PRIVATE (GstDiscoverer) _do_init ());</span>
 168 
 169 enum
 170 {
 171   SIGNAL_FINISHED,
 172   SIGNAL_STARTING,
 173   SIGNAL_DISCOVERED,
 174   SIGNAL_SOURCE_SETUP,
 175   LAST_SIGNAL
 176 };
 177 
 178 #define DEFAULT_PROP_TIMEOUT 15 * GST_SECOND
<a name="6" id="anc6"></a><span class="line-added"> 179 #define DEFAULT_PROP_USE_CACHE FALSE</span>
 180 
 181 enum
 182 {
 183   PROP_0,
<a name="7" id="anc7"></a><span class="line-modified"> 184   PROP_TIMEOUT,</span>
<span class="line-added"> 185   PROP_USE_CACHE</span>
 186 };
 187 
 188 static guint gst_discoverer_signals[LAST_SIGNAL] = { 0 };
 189 
 190 static void gst_discoverer_set_timeout (GstDiscoverer * dc,
 191     GstClockTime timeout);
 192 static gboolean async_timeout_cb (GstDiscoverer * dc);
 193 
 194 static void discoverer_bus_cb (GstBus * bus, GstMessage * msg,
 195     GstDiscoverer * dc);
 196 static void uridecodebin_pad_added_cb (GstElement * uridecodebin, GstPad * pad,
 197     GstDiscoverer * dc);
 198 static void uridecodebin_pad_removed_cb (GstElement * uridecodebin,
 199     GstPad * pad, GstDiscoverer * dc);
 200 static void uridecodebin_no_more_pads_cb (GstElement * uridecodebin,
 201     GstDiscoverer * dc);
 202 static void uridecodebin_source_changed_cb (GstElement * uridecodebin,
 203     GParamSpec * pspec, GstDiscoverer * dc);
 204 
 205 static void gst_discoverer_dispose (GObject * dc);
 206 static void gst_discoverer_finalize (GObject * dc);
 207 static void gst_discoverer_set_property (GObject * object, guint prop_id,
 208     const GValue * value, GParamSpec * pspec);
 209 static void gst_discoverer_get_property (GObject * object, guint prop_id,
 210     GValue * value, GParamSpec * pspec);
<a name="8" id="anc8"></a><span class="line-added"> 211 static gboolean _setup_locked (GstDiscoverer * dc);</span>
<span class="line-added"> 212 static void handle_current_async (GstDiscoverer * dc);</span>
<span class="line-added"> 213 static gboolean emit_discovererd_and_next (GstDiscoverer * dc);</span>
<span class="line-added"> 214 static GVariant *gst_discoverer_info_to_variant_recurse (GstDiscovererStreamInfo</span>
<span class="line-added"> 215     * sinfo, GstDiscovererSerializeFlags flags);</span>
<span class="line-added"> 216 static GstDiscovererStreamInfo *_parse_discovery (GVariant * variant,</span>
<span class="line-added"> 217     GstDiscovererInfo * info);</span>
 218 
 219 static void
 220 gst_discoverer_class_init (GstDiscovererClass * klass)
 221 {
 222   GObjectClass *gobject_class = (GObjectClass *) klass;
 223 
 224   gobject_class-&gt;dispose = gst_discoverer_dispose;
 225   gobject_class-&gt;finalize = gst_discoverer_finalize;
 226 
 227   gobject_class-&gt;set_property = gst_discoverer_set_property;
 228   gobject_class-&gt;get_property = gst_discoverer_get_property;
 229 
<a name="9" id="anc9"></a>
 230 
 231   /* properties */
 232   /**
 233    * GstDiscoverer:timeout:
 234    *
 235    * The duration (in nanoseconds) after which the discovery of an individual
 236    * URI will timeout.
 237    *
 238    * If the discovery of a URI times out, the %GST_DISCOVERER_TIMEOUT will be
 239    * set on the result flags.
 240    */
 241   g_object_class_install_property (gobject_class, PROP_TIMEOUT,
 242       g_param_spec_uint64 (&quot;timeout&quot;, &quot;timeout&quot;, &quot;Timeout&quot;,
 243           GST_SECOND, 3600 * GST_SECOND, DEFAULT_PROP_TIMEOUT,
 244           G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS));
 245 
<a name="10" id="anc10"></a><span class="line-added"> 246   /**</span>
<span class="line-added"> 247    * GstDiscoverer::use-cache:</span>
<span class="line-added"> 248    *</span>
<span class="line-added"> 249    * Whether to use a serialized version of the discoverer info from our</span>
<span class="line-added"> 250    * own cache if accessible. This allows the discovery to be much faster</span>
<span class="line-added"> 251    * as when using this option, we do not need to create a #GstPipeline</span>
<span class="line-added"> 252    * and run it, but instead, just reload the #GstDiscovererInfo in its</span>
<span class="line-added"> 253    * serialized form.</span>
<span class="line-added"> 254    *</span>
<span class="line-added"> 255    * The cache files are saved in `$XDG_CACHE_DIR/gstreamer-1.0/discoverer/`.</span>
<span class="line-added"> 256    *</span>
<span class="line-added"> 257    * Since: 1.16</span>
<span class="line-added"> 258    */</span>
<span class="line-added"> 259   g_object_class_install_property (gobject_class, PROP_USE_CACHE,</span>
<span class="line-added"> 260       g_param_spec_boolean (&quot;use-cache&quot;, &quot;use cache&quot;, &quot;Use cache&quot;,</span>
<span class="line-added"> 261           DEFAULT_PROP_USE_CACHE,</span>
<span class="line-added"> 262           G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS));</span>
<span class="line-added"> 263 </span>
 264   /* signals */
 265   /**
 266    * GstDiscoverer::finished:
 267    * @discoverer: the #GstDiscoverer
 268    *
 269    * Will be emitted in async mode when all pending URIs have been processed.
 270    */
 271   gst_discoverer_signals[SIGNAL_FINISHED] =
 272       g_signal_new (&quot;finished&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 273       G_STRUCT_OFFSET (GstDiscovererClass, finished),
 274       NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0, G_TYPE_NONE);
 275 
 276   /**
 277    * GstDiscoverer::starting:
 278    * @discoverer: the #GstDiscoverer
 279    *
 280    * Will be emitted when the discover starts analyzing the pending URIs
 281    */
 282   gst_discoverer_signals[SIGNAL_STARTING] =
 283       g_signal_new (&quot;starting&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 284       G_STRUCT_OFFSET (GstDiscovererClass, starting),
 285       NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0, G_TYPE_NONE);
 286 
 287   /**
 288    * GstDiscoverer::discovered:
 289    * @discoverer: the #GstDiscoverer
 290    * @info: the results #GstDiscovererInfo
 291    * @error: (allow-none) (type GLib.Error): #GError, which will be non-NULL
 292    *                                         if an error occurred during
 293    *                                         discovery. You must not free
 294    *                                         this #GError, it will be freed by
 295    *                                         the discoverer.
 296    *
 297    * Will be emitted in async mode when all information on a URI could be
 298    * discovered, or an error occurred.
 299    *
 300    * When an error occurs, @info might still contain some partial information,
 301    * depending on the circumstances of the error.
 302    */
 303   gst_discoverer_signals[SIGNAL_DISCOVERED] =
 304       g_signal_new (&quot;discovered&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 305       G_STRUCT_OFFSET (GstDiscovererClass, discovered),
 306       NULL, NULL, g_cclosure_marshal_generic,
 307       G_TYPE_NONE, 2, GST_TYPE_DISCOVERER_INFO,
 308       G_TYPE_ERROR | G_SIGNAL_TYPE_STATIC_SCOPE);
 309 
 310   /**
 311    * GstDiscoverer::source-setup:
 312    * @discoverer: the #GstDiscoverer
 313    * @source: source element
 314    *
 315    * This signal is emitted after the source element has been created for, so
 316    * the URI being discovered, so it can be configured by setting additional
 317    * properties (e.g. set a proxy server for an http source, or set the device
 318    * and read speed for an audio cd source).
 319    *
 320    * This signal is usually emitted from the context of a GStreamer streaming
 321    * thread.
 322    */
 323   gst_discoverer_signals[SIGNAL_SOURCE_SETUP] =
 324       g_signal_new (&quot;source-setup&quot;, G_TYPE_FROM_CLASS (klass),
 325       G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstDiscovererClass, source_setup),
 326       NULL, NULL, g_cclosure_marshal_generic, G_TYPE_NONE, 1, GST_TYPE_ELEMENT);
 327 }
 328 
 329 static void
 330 uridecodebin_element_added_cb (GstElement * uridecodebin,
 331     GstElement * child, GstDiscoverer * dc)
 332 {
 333   GST_DEBUG (&quot;New element added to uridecodebin : %s&quot;,
 334       GST_ELEMENT_NAME (child));
 335 
 336   if (G_OBJECT_TYPE (child) == dc-&gt;priv-&gt;decodebin_type) {
 337     g_object_set (child, &quot;post-stream-topology&quot;, TRUE, NULL);
 338   }
 339 }
 340 
 341 static void
 342 gst_discoverer_init (GstDiscoverer * dc)
 343 {
 344   GstElement *tmp;
 345   GstFormat format = GST_FORMAT_TIME;
 346 
<a name="11" id="anc11"></a><span class="line-modified"> 347   dc-&gt;priv = gst_discoverer_get_instance_private (dc);</span>

 348 
 349   dc-&gt;priv-&gt;timeout = DEFAULT_PROP_TIMEOUT;
<a name="12" id="anc12"></a><span class="line-added"> 350   dc-&gt;priv-&gt;use_cache = DEFAULT_PROP_USE_CACHE;</span>
 351   dc-&gt;priv-&gt;async = FALSE;
 352 
 353   g_mutex_init (&amp;dc-&gt;priv-&gt;lock);
 354 
 355   dc-&gt;priv-&gt;pending_subtitle_pads = 0;
 356 
 357   dc-&gt;priv-&gt;current_state = GST_STATE_NULL;
 358   dc-&gt;priv-&gt;target_state = GST_STATE_NULL;
 359   dc-&gt;priv-&gt;no_more_pads = FALSE;
 360 
 361   GST_LOG (&quot;Creating pipeline&quot;);
 362   dc-&gt;priv-&gt;pipeline = (GstBin *) gst_pipeline_new (&quot;Discoverer&quot;);
 363   GST_LOG_OBJECT (dc, &quot;Creating uridecodebin&quot;);
 364   dc-&gt;priv-&gt;uridecodebin =
 365       gst_element_factory_make (&quot;uridecodebin&quot;, &quot;discoverer-uri&quot;);
 366   if (G_UNLIKELY (dc-&gt;priv-&gt;uridecodebin == NULL)) {
 367     GST_ERROR (&quot;Can&#39;t create uridecodebin&quot;);
 368     return;
 369   }
 370   GST_LOG_OBJECT (dc, &quot;Adding uridecodebin to pipeline&quot;);
 371   gst_bin_add (dc-&gt;priv-&gt;pipeline, dc-&gt;priv-&gt;uridecodebin);
 372 
 373   dc-&gt;priv-&gt;pad_added_id =
 374       g_signal_connect_object (dc-&gt;priv-&gt;uridecodebin, &quot;pad-added&quot;,
 375       G_CALLBACK (uridecodebin_pad_added_cb), dc, 0);
 376   dc-&gt;priv-&gt;pad_remove_id =
 377       g_signal_connect_object (dc-&gt;priv-&gt;uridecodebin, &quot;pad-removed&quot;,
 378       G_CALLBACK (uridecodebin_pad_removed_cb), dc, 0);
 379   dc-&gt;priv-&gt;no_more_pads_id =
 380       g_signal_connect_object (dc-&gt;priv-&gt;uridecodebin, &quot;no-more-pads&quot;,
 381       G_CALLBACK (uridecodebin_no_more_pads_cb), dc, 0);
 382   dc-&gt;priv-&gt;source_chg_id =
 383       g_signal_connect_object (dc-&gt;priv-&gt;uridecodebin, &quot;notify::source&quot;,
 384       G_CALLBACK (uridecodebin_source_changed_cb), dc, 0);
 385 
 386   GST_LOG_OBJECT (dc, &quot;Getting pipeline bus&quot;);
 387   dc-&gt;priv-&gt;bus = gst_pipeline_get_bus ((GstPipeline *) dc-&gt;priv-&gt;pipeline);
 388 
 389   dc-&gt;priv-&gt;bus_cb_id =
 390       g_signal_connect_object (dc-&gt;priv-&gt;bus, &quot;message&quot;,
 391       G_CALLBACK (discoverer_bus_cb), dc, 0);
 392 
 393   GST_DEBUG_OBJECT (dc, &quot;Done initializing Discoverer&quot;);
 394 
 395   /* This is ugly. We get the GType of decodebin so we can quickly detect
 396    * when a decodebin is added to uridecodebin so we can set the
 397    * post-stream-topology setting to TRUE */
 398   dc-&gt;priv-&gt;element_added_id =
 399       g_signal_connect_object (dc-&gt;priv-&gt;uridecodebin, &quot;element-added&quot;,
 400       G_CALLBACK (uridecodebin_element_added_cb), dc, 0);
 401   tmp = gst_element_factory_make (&quot;decodebin&quot;, NULL);
 402   dc-&gt;priv-&gt;decodebin_type = G_OBJECT_TYPE (tmp);
 403   gst_object_unref (tmp);
 404 
 405   /* create queries */
 406   dc-&gt;priv-&gt;seeking_query = gst_query_new_seeking (format);
 407 }
 408 
 409 static void
 410 discoverer_reset (GstDiscoverer * dc)
 411 {
 412   GST_DEBUG_OBJECT (dc, &quot;Resetting&quot;);
 413 
 414   if (dc-&gt;priv-&gt;pending_uris) {
 415     g_list_foreach (dc-&gt;priv-&gt;pending_uris, (GFunc) g_free, NULL);
 416     g_list_free (dc-&gt;priv-&gt;pending_uris);
 417     dc-&gt;priv-&gt;pending_uris = NULL;
 418   }
 419 
 420   if (dc-&gt;priv-&gt;pipeline)
 421     gst_element_set_state ((GstElement *) dc-&gt;priv-&gt;pipeline, GST_STATE_NULL);
 422 }
 423 
 424 #define DISCONNECT_SIGNAL(o,i) G_STMT_START{           \
 425   if ((i) &amp;&amp; g_signal_handler_is_connected ((o), (i))) \
 426     g_signal_handler_disconnect ((o), (i));            \
 427   (i) = 0;                                             \
 428 }G_STMT_END
 429 
 430 static void
 431 gst_discoverer_dispose (GObject * obj)
 432 {
 433   GstDiscoverer *dc = (GstDiscoverer *) obj;
 434 
 435   GST_DEBUG_OBJECT (dc, &quot;Disposing&quot;);
 436 
 437   discoverer_reset (dc);
 438 
 439   if (G_LIKELY (dc-&gt;priv-&gt;pipeline)) {
 440     /* Workaround for bug #118536 */
 441     DISCONNECT_SIGNAL (dc-&gt;priv-&gt;uridecodebin, dc-&gt;priv-&gt;pad_added_id);
 442     DISCONNECT_SIGNAL (dc-&gt;priv-&gt;uridecodebin, dc-&gt;priv-&gt;pad_remove_id);
 443     DISCONNECT_SIGNAL (dc-&gt;priv-&gt;uridecodebin, dc-&gt;priv-&gt;no_more_pads_id);
 444     DISCONNECT_SIGNAL (dc-&gt;priv-&gt;uridecodebin, dc-&gt;priv-&gt;source_chg_id);
 445     DISCONNECT_SIGNAL (dc-&gt;priv-&gt;uridecodebin, dc-&gt;priv-&gt;element_added_id);
 446     DISCONNECT_SIGNAL (dc-&gt;priv-&gt;bus, dc-&gt;priv-&gt;bus_cb_id);
 447 
 448     /* pipeline was set to NULL in _reset */
 449     gst_object_unref (dc-&gt;priv-&gt;pipeline);
 450     if (dc-&gt;priv-&gt;bus)
 451       gst_object_unref (dc-&gt;priv-&gt;bus);
 452 
 453     dc-&gt;priv-&gt;pipeline = NULL;
 454     dc-&gt;priv-&gt;uridecodebin = NULL;
 455     dc-&gt;priv-&gt;bus = NULL;
 456   }
 457 
 458   gst_discoverer_stop (dc);
 459 
 460   if (dc-&gt;priv-&gt;seeking_query) {
 461     gst_query_unref (dc-&gt;priv-&gt;seeking_query);
 462     dc-&gt;priv-&gt;seeking_query = NULL;
 463   }
 464 
 465   G_OBJECT_CLASS (gst_discoverer_parent_class)-&gt;dispose (obj);
 466 }
 467 
 468 static void
 469 gst_discoverer_finalize (GObject * obj)
 470 {
 471   GstDiscoverer *dc = (GstDiscoverer *) obj;
 472 
 473   g_mutex_clear (&amp;dc-&gt;priv-&gt;lock);
 474 
 475   G_OBJECT_CLASS (gst_discoverer_parent_class)-&gt;finalize (obj);
 476 }
 477 
 478 static void
 479 gst_discoverer_set_property (GObject * object, guint prop_id,
 480     const GValue * value, GParamSpec * pspec)
 481 {
 482   GstDiscoverer *dc = (GstDiscoverer *) object;
 483 
 484   switch (prop_id) {
 485     case PROP_TIMEOUT:
 486       gst_discoverer_set_timeout (dc, g_value_get_uint64 (value));
 487       break;
<a name="13" id="anc13"></a><span class="line-added"> 488     case PROP_USE_CACHE:</span>
<span class="line-added"> 489       DISCO_LOCK (dc);</span>
<span class="line-added"> 490       dc-&gt;priv-&gt;use_cache = g_value_get_boolean (value);</span>
<span class="line-added"> 491       DISCO_UNLOCK (dc);</span>
<span class="line-added"> 492       break;</span>
 493     default:
 494       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 495       break;
 496   }
 497 }
 498 
 499 static void
 500 gst_discoverer_get_property (GObject * object, guint prop_id,
 501     GValue * value, GParamSpec * pspec)
 502 {
 503   GstDiscoverer *dc = (GstDiscoverer *) object;
 504 
 505   switch (prop_id) {
 506     case PROP_TIMEOUT:
 507       DISCO_LOCK (dc);
 508       g_value_set_uint64 (value, dc-&gt;priv-&gt;timeout);
 509       DISCO_UNLOCK (dc);
 510       break;
<a name="14" id="anc14"></a><span class="line-added"> 511     case PROP_USE_CACHE:</span>
<span class="line-added"> 512       DISCO_LOCK (dc);</span>
<span class="line-added"> 513       g_value_set_boolean (value, dc-&gt;priv-&gt;use_cache);</span>
<span class="line-added"> 514       DISCO_UNLOCK (dc);</span>
<span class="line-added"> 515       break;</span>
 516     default:
 517       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 518       break;
 519   }
 520 }
 521 
 522 static void
 523 gst_discoverer_set_timeout (GstDiscoverer * dc, GstClockTime timeout)
 524 {
 525   GST_DEBUG_OBJECT (dc, &quot;timeout : %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (timeout));
 526 
 527   /* FIXME : update current pending timeout if we&#39;re running */
 528   DISCO_LOCK (dc);
 529   dc-&gt;priv-&gt;timeout = timeout;
 530   DISCO_UNLOCK (dc);
 531 }
 532 
 533 static GstPadProbeReturn
 534 _event_probe (GstPad * pad, GstPadProbeInfo * info, PrivateStream * ps)
 535 {
 536   GstEvent *event = GST_PAD_PROBE_INFO_EVENT (info);
 537 
 538   switch (GST_EVENT_TYPE (event)) {
 539     case GST_EVENT_TAG:{
 540       GstTagList *tl = NULL, *tmp;
 541 
 542       gst_event_parse_tag (event, &amp;tl);
 543       GST_DEBUG_OBJECT (pad, &quot;tags %&quot; GST_PTR_FORMAT, tl);
 544       DISCO_LOCK (ps-&gt;dc);
 545       /* If preroll is complete, drop these tags - the collected information is
 546        * possibly already being processed and adding more tags would be racy */
 547       if (G_LIKELY (ps-&gt;dc-&gt;priv-&gt;processing)) {
 548         GST_DEBUG_OBJECT (pad, &quot;private stream %p old tags %&quot; GST_PTR_FORMAT,
 549             ps, ps-&gt;tags);
 550         tmp = gst_tag_list_merge (ps-&gt;tags, tl, GST_TAG_MERGE_APPEND);
 551         if (ps-&gt;tags)
 552           gst_tag_list_unref (ps-&gt;tags);
 553         ps-&gt;tags = tmp;
 554         GST_DEBUG_OBJECT (pad, &quot;private stream %p new tags %&quot; GST_PTR_FORMAT,
 555             ps, tmp);
 556       } else
 557         GST_DEBUG_OBJECT (pad, &quot;Dropping tags since preroll is done&quot;);
 558       DISCO_UNLOCK (ps-&gt;dc);
 559       break;
 560     }
 561     case GST_EVENT_TOC:{
 562       GstToc *tmp;
 563 
 564       gst_event_parse_toc (event, &amp;tmp, NULL);
 565       GST_DEBUG_OBJECT (pad, &quot;toc %&quot; GST_PTR_FORMAT, tmp);
 566       DISCO_LOCK (ps-&gt;dc);
 567       ps-&gt;toc = tmp;
 568       if (G_LIKELY (ps-&gt;dc-&gt;priv-&gt;processing)) {
 569         GST_DEBUG_OBJECT (pad, &quot;private stream %p toc %&quot; GST_PTR_FORMAT, ps,
 570             tmp);
 571       } else
 572         GST_DEBUG_OBJECT (pad, &quot;Dropping toc since preroll is done&quot;);
 573       DISCO_UNLOCK (ps-&gt;dc);
 574       break;
 575     }
 576     case GST_EVENT_STREAM_START:{
 577       const gchar *stream_id;
 578 
 579       gst_event_parse_stream_start (event, &amp;stream_id);
 580 
 581       g_free (ps-&gt;stream_id);
 582       ps-&gt;stream_id = stream_id ? g_strdup (stream_id) : NULL;
 583       break;
 584     }
 585     default:
 586       break;
 587   }
 588 
 589   return GST_PAD_PROBE_OK;
 590 }
 591 
<a name="15" id="anc15"></a><span class="line-modified"> 592 static GstStaticCaps subtitle_caps =</span>
<span class="line-modified"> 593     GST_STATIC_CAPS</span>
<span class="line-modified"> 594     (&quot;application/x-ssa; application/x-ass; application/x-kate&quot;);</span>

 595 
 596 static gboolean
 597 is_subtitle_caps (const GstCaps * caps)
 598 {
 599   GstCaps *subs_caps;
<a name="16" id="anc16"></a><span class="line-added"> 600   GstStructure *s;</span>
<span class="line-added"> 601   const gchar *name;</span>
 602   gboolean ret;
 603 
<a name="17" id="anc17"></a><span class="line-added"> 604   s = gst_caps_get_structure (caps, 0);</span>
<span class="line-added"> 605   if (!s)</span>
<span class="line-added"> 606     return FALSE;</span>
<span class="line-added"> 607 </span>
<span class="line-added"> 608   name = gst_structure_get_name (s);</span>
<span class="line-added"> 609   if (g_str_has_prefix (name, &quot;text/&quot;) ||</span>
<span class="line-added"> 610       g_str_has_prefix (name, &quot;subpicture/&quot;) ||</span>
<span class="line-added"> 611       g_str_has_prefix (name, &quot;subtitle/&quot;) ||</span>
<span class="line-added"> 612       g_str_has_prefix (name, &quot;closedcaption/&quot;) ||</span>
<span class="line-added"> 613       g_str_has_prefix (name, &quot;application/x-subtitle&quot;))</span>
<span class="line-added"> 614     return TRUE;</span>
<span class="line-added"> 615 </span>
 616   subs_caps = gst_static_caps_get (&amp;subtitle_caps);
 617   ret = gst_caps_can_intersect (caps, subs_caps);
 618   gst_caps_unref (subs_caps);
 619 
 620   return ret;
 621 }
 622 
 623 static GstPadProbeReturn
 624 got_subtitle_data (GstPad * pad, GstPadProbeInfo * info, GstDiscoverer * dc)
 625 {
 626   GstMessage *msg;
 627 
 628   if (!(GST_IS_BUFFER (info-&gt;data) || (GST_IS_EVENT (info-&gt;data)
 629               &amp;&amp; (GST_EVENT_TYPE ((GstEvent *) info-&gt;data) == GST_EVENT_GAP
 630                   || GST_EVENT_TYPE ((GstEvent *) info-&gt;data) ==
 631                   GST_EVENT_EOS))))
 632     return GST_PAD_PROBE_OK;
 633 
 634 
 635   DISCO_LOCK (dc);
 636 
 637   dc-&gt;priv-&gt;pending_subtitle_pads--;
 638 
 639   msg = gst_message_new_application (NULL,
 640       gst_structure_new_empty (&quot;DiscovererDone&quot;));
 641   gst_element_post_message ((GstElement *) dc-&gt;priv-&gt;pipeline, msg);
 642 
 643   DISCO_UNLOCK (dc);
 644 
 645   return GST_PAD_PROBE_REMOVE;
 646 
 647 }
 648 
 649 static void
 650 uridecodebin_source_changed_cb (GstElement * uridecodebin,
 651     GParamSpec * pspec, GstDiscoverer * dc)
 652 {
 653   GstElement *src;
 654   /* get a handle to the source */
 655   g_object_get (uridecodebin, pspec-&gt;name, &amp;src, NULL);
 656 
 657   GST_DEBUG_OBJECT (dc, &quot;got a new source %p&quot;, src);
 658 
 659   g_signal_emit (dc, gst_discoverer_signals[SIGNAL_SOURCE_SETUP], 0, src);
 660   gst_object_unref (src);
 661 }
 662 
 663 static void
 664 uridecodebin_pad_added_cb (GstElement * uridecodebin, GstPad * pad,
 665     GstDiscoverer * dc)
 666 {
 667   PrivateStream *ps;
 668   GstPad *sinkpad = NULL;
 669   GstCaps *caps;
 670   gchar *padname;
 671   gchar *tmpname;
 672 
 673   GST_DEBUG_OBJECT (dc, &quot;pad %s:%s&quot;, GST_DEBUG_PAD_NAME (pad));
 674 
 675   DISCO_LOCK (dc);
 676   if (dc-&gt;priv-&gt;cleanup) {
 677     GST_WARNING_OBJECT (dc, &quot;Cleanup, not adding pad&quot;);
 678     DISCO_UNLOCK (dc);
 679     return;
 680   }
 681   if (dc-&gt;priv-&gt;current_error) {
 682     GST_WARNING_OBJECT (dc, &quot;Ongoing error, not adding more pads&quot;);
 683     DISCO_UNLOCK (dc);
 684     return;
 685   }
 686   ps = g_slice_new0 (PrivateStream);
 687 
 688   ps-&gt;dc = dc;
 689   ps-&gt;pad = pad;
 690   padname = gst_pad_get_name (pad);
 691   tmpname = g_strdup_printf (&quot;discoverer-queue-%s&quot;, padname);
 692   ps-&gt;queue = gst_element_factory_make (&quot;queue&quot;, tmpname);
 693   g_free (tmpname);
 694   tmpname = g_strdup_printf (&quot;discoverer-sink-%s&quot;, padname);
 695   ps-&gt;sink = gst_element_factory_make (&quot;fakesink&quot;, tmpname);
 696   g_free (tmpname);
 697   g_free (padname);
 698 
 699   if (G_UNLIKELY (ps-&gt;queue == NULL || ps-&gt;sink == NULL))
 700     goto error;
 701 
 702   g_object_set (ps-&gt;sink, &quot;silent&quot;, TRUE, NULL);
 703   g_object_set (ps-&gt;queue, &quot;max-size-buffers&quot;, 1, &quot;silent&quot;, TRUE, NULL);
 704 
 705   caps = gst_pad_query_caps (pad, NULL);
 706 
 707   sinkpad = gst_element_get_static_pad (ps-&gt;queue, &quot;sink&quot;);
 708   if (sinkpad == NULL)
 709     goto error;
 710 
 711   if (is_subtitle_caps (caps)) {
 712     /* Subtitle streams are sparse and may not provide any information - don&#39;t
 713      * wait for data to preroll */
 714     ps-&gt;probe_id =
 715         gst_pad_add_probe (sinkpad, GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM,
 716         (GstPadProbeCallback) got_subtitle_data, dc, NULL);
 717     g_object_set (ps-&gt;sink, &quot;async&quot;, FALSE, NULL);
 718     dc-&gt;priv-&gt;pending_subtitle_pads++;
 719   }
 720 
 721   gst_caps_unref (caps);
 722 
 723   gst_bin_add_many (dc-&gt;priv-&gt;pipeline, ps-&gt;queue, ps-&gt;sink, NULL);
 724 
 725   if (!gst_element_link_pads_full (ps-&gt;queue, &quot;src&quot;, ps-&gt;sink, &quot;sink&quot;,
 726           GST_PAD_LINK_CHECK_NOTHING))
 727     goto error;
 728   if (!gst_element_sync_state_with_parent (ps-&gt;sink))
 729     goto error;
 730   if (!gst_element_sync_state_with_parent (ps-&gt;queue))
 731     goto error;
 732 
 733   if (gst_pad_link_full (pad, sinkpad,
 734           GST_PAD_LINK_CHECK_NOTHING) != GST_PAD_LINK_OK)
 735     goto error;
 736   gst_object_unref (sinkpad);
 737 
 738   /* Add an event probe */
 739   gst_pad_add_probe (pad, GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM,
 740       (GstPadProbeCallback) _event_probe, ps, NULL);
 741 
 742   dc-&gt;priv-&gt;streams = g_list_append (dc-&gt;priv-&gt;streams, ps);
 743   DISCO_UNLOCK (dc);
 744 
 745   GST_DEBUG_OBJECT (dc, &quot;Done handling pad&quot;);
 746 
 747   return;
 748 
 749 error:
 750   GST_ERROR_OBJECT (dc, &quot;Error while handling pad&quot;);
 751   if (sinkpad)
 752     gst_object_unref (sinkpad);
 753   if (ps-&gt;queue)
 754     gst_object_unref (ps-&gt;queue);
 755   if (ps-&gt;sink)
 756     gst_object_unref (ps-&gt;sink);
 757   g_slice_free (PrivateStream, ps);
 758   DISCO_UNLOCK (dc);
 759   return;
 760 }
 761 
 762 static void
 763 uridecodebin_no_more_pads_cb (GstElement * uridecodebin, GstDiscoverer * dc)
 764 {
 765   GstMessage *msg = gst_message_new_application (NULL,
 766       gst_structure_new_empty (&quot;DiscovererDone&quot;));
 767 
 768   DISCO_LOCK (dc);
 769   dc-&gt;priv-&gt;no_more_pads = TRUE;
 770   gst_element_post_message ((GstElement *) dc-&gt;priv-&gt;pipeline, msg);
 771   DISCO_UNLOCK (dc);
 772 }
 773 
 774 static void
 775 uridecodebin_pad_removed_cb (GstElement * uridecodebin, GstPad * pad,
 776     GstDiscoverer * dc)
 777 {
 778   GList *tmp;
 779   PrivateStream *ps;
 780   GstPad *sinkpad;
 781 
 782   GST_DEBUG_OBJECT (dc, &quot;pad %s:%s&quot;, GST_DEBUG_PAD_NAME (pad));
 783 
 784   /* Find the PrivateStream */
 785   DISCO_LOCK (dc);
 786   for (tmp = dc-&gt;priv-&gt;streams; tmp; tmp = tmp-&gt;next) {
 787     ps = (PrivateStream *) tmp-&gt;data;
 788     if (ps-&gt;pad == pad)
 789       break;
 790   }
 791 
 792   if (tmp == NULL) {
 793     DISCO_UNLOCK (dc);
 794     GST_DEBUG (&quot;The removed pad wasn&#39;t controlled by us !&quot;);
 795     return;
 796   }
 797 
 798   if (ps-&gt;probe_id)
 799     gst_pad_remove_probe (pad, ps-&gt;probe_id);
 800 
 801   dc-&gt;priv-&gt;streams = g_list_delete_link (dc-&gt;priv-&gt;streams, tmp);
 802 
 803   gst_element_set_state (ps-&gt;sink, GST_STATE_NULL);
 804   gst_element_set_state (ps-&gt;queue, GST_STATE_NULL);
 805   gst_element_unlink (ps-&gt;queue, ps-&gt;sink);
 806 
 807   sinkpad = gst_element_get_static_pad (ps-&gt;queue, &quot;sink&quot;);
 808   gst_pad_unlink (pad, sinkpad);
 809   gst_object_unref (sinkpad);
 810 
 811   /* references removed here */
 812   gst_bin_remove_many (dc-&gt;priv-&gt;pipeline, ps-&gt;sink, ps-&gt;queue, NULL);
 813 
 814   DISCO_UNLOCK (dc);
 815   if (ps-&gt;tags) {
 816     gst_tag_list_unref (ps-&gt;tags);
 817   }
 818   if (ps-&gt;toc) {
 819     gst_toc_unref (ps-&gt;toc);
 820   }
 821   g_free (ps-&gt;stream_id);
 822 
 823   g_slice_free (PrivateStream, ps);
 824 
 825   GST_DEBUG (&quot;Done handling pad&quot;);
 826 }
 827 
 828 static GstStructure *
 829 collect_stream_information (GstDiscoverer * dc, PrivateStream * ps, guint idx)
 830 {
 831   GstCaps *caps;
 832   GstStructure *st;
 833   gchar *stname;
 834 
 835   stname = g_strdup_printf (&quot;stream-%02d&quot;, idx);
 836   st = gst_structure_new_empty (stname);
 837   g_free (stname);
 838 
 839   /* Get caps */
 840   caps = gst_pad_get_current_caps (ps-&gt;pad);
 841   if (!caps) {
 842     GST_WARNING (&quot;Couldn&#39;t get negotiated caps from %s:%s&quot;,
 843         GST_DEBUG_PAD_NAME (ps-&gt;pad));
 844     caps = gst_pad_query_caps (ps-&gt;pad, NULL);
 845   }
 846   if (caps) {
 847     GST_DEBUG (&quot;stream-%02d, got caps %&quot; GST_PTR_FORMAT, idx, caps);
 848     gst_structure_id_set (st, _CAPS_QUARK, GST_TYPE_CAPS, caps, NULL);
 849     gst_caps_unref (caps);
 850   }
 851   if (ps-&gt;tags)
 852     gst_structure_id_set (st, _TAGS_QUARK, GST_TYPE_TAG_LIST, ps-&gt;tags, NULL);
 853   if (ps-&gt;toc)
 854     gst_structure_id_set (st, _TOC_QUARK, GST_TYPE_TOC, ps-&gt;toc, NULL);
 855   if (ps-&gt;stream_id)
 856     gst_structure_id_set (st, _STREAM_ID_QUARK, G_TYPE_STRING, ps-&gt;stream_id,
 857         NULL);
 858 
 859   return st;
 860 }
 861 
 862 /* takes ownership of new_tags, may replace *taglist with a new one */
 863 static void
 864 gst_discoverer_merge_and_replace_tags (GstTagList ** taglist,
 865     GstTagList * new_tags)
 866 {
 867   if (new_tags == NULL)
 868     return;
 869 
 870   if (*taglist == NULL) {
 871     *taglist = new_tags;
 872     return;
 873   }
 874 
 875   gst_tag_list_insert (*taglist, new_tags, GST_TAG_MERGE_REPLACE);
 876   gst_tag_list_unref (new_tags);
 877 }
 878 
 879 static void
 880 collect_common_information (GstDiscovererStreamInfo * info,
 881     const GstStructure * st)
 882 {
 883   if (gst_structure_id_has_field (st, _TOC_QUARK)) {
 884     gst_structure_id_get (st, _TOC_QUARK, GST_TYPE_TOC, &amp;info-&gt;toc, NULL);
 885   }
 886 
 887   if (gst_structure_id_has_field (st, _STREAM_ID_QUARK)) {
 888     gst_structure_id_get (st, _STREAM_ID_QUARK, G_TYPE_STRING, &amp;info-&gt;stream_id,
 889         NULL);
 890   }
 891 }
 892 
 893 static GstDiscovererStreamInfo *
 894 make_info (GstDiscovererStreamInfo * parent, GType type, GstCaps * caps)
 895 {
 896   GstDiscovererStreamInfo *info;
 897 
 898   if (parent)
 899     info = gst_discoverer_stream_info_ref (parent);
 900   else {
 901     info = g_object_new (type, NULL);
 902     if (caps)
 903       info-&gt;caps = gst_caps_ref (caps);
 904   }
 905   return info;
 906 }
 907 
 908 /* Parses a set of caps and tags in st and populates a GstDiscovererStreamInfo
 909  * structure (parent, if !NULL, otherwise it allocates one)
 910  */
 911 static GstDiscovererStreamInfo *
 912 collect_information (GstDiscoverer * dc, const GstStructure * st,
 913     GstDiscovererStreamInfo * parent)
 914 {
 915   GstPad *srcpad;
 916   GstCaps *caps = NULL;
 917   GstStructure *caps_st;
 918   GstTagList *tags_st;
 919   const gchar *name;
 920   gint tmp, tmp2;
 921   guint utmp;
 922 
 923   if (!st || (!gst_structure_id_has_field (st, _CAPS_QUARK)
 924           &amp;&amp; !gst_structure_id_has_field (st, _ELEMENT_SRCPAD_QUARK))) {
 925     GST_WARNING (&quot;Couldn&#39;t find caps !&quot;);
 926     return make_info (parent, GST_TYPE_DISCOVERER_STREAM_INFO, NULL);
 927   }
 928 
 929   if (gst_structure_id_get (st, _ELEMENT_SRCPAD_QUARK, GST_TYPE_PAD, &amp;srcpad,
 930           NULL)) {
 931     caps = gst_pad_get_current_caps (srcpad);
 932     gst_object_unref (srcpad);
 933   }
 934   if (!caps) {
 935     gst_structure_id_get (st, _CAPS_QUARK, GST_TYPE_CAPS, &amp;caps, NULL);
 936   }
 937 
 938   if (!caps || gst_caps_is_empty (caps) || gst_caps_is_any (caps)) {
 939     GST_WARNING (&quot;Couldn&#39;t find caps !&quot;);
 940     if (caps)
 941       gst_caps_unref (caps);
 942     return make_info (parent, GST_TYPE_DISCOVERER_STREAM_INFO, NULL);
 943   }
 944 
 945   caps_st = gst_caps_get_structure (caps, 0);
 946   name = gst_structure_get_name (caps_st);
 947 
 948   if (g_str_has_prefix (name, &quot;audio/&quot;)) {
 949     GstDiscovererAudioInfo *info;
 950     const gchar *format_str;
 951     guint64 channel_mask;
 952 
 953     info = (GstDiscovererAudioInfo *) make_info (parent,
 954         GST_TYPE_DISCOVERER_AUDIO_INFO, caps);
 955 
 956     if (gst_structure_get_int (caps_st, &quot;rate&quot;, &amp;tmp))
 957       info-&gt;sample_rate = (guint) tmp;
 958 
 959     if (gst_structure_get_int (caps_st, &quot;channels&quot;, &amp;tmp))
 960       info-&gt;channels = (guint) tmp;
 961 
 962     if (gst_structure_get (caps_st, &quot;channel-mask&quot;, GST_TYPE_BITMASK,
 963             &amp;channel_mask, NULL)) {
 964       info-&gt;channel_mask = channel_mask;
 965     } else if (info-&gt;channels) {
 966       info-&gt;channel_mask = gst_audio_channel_get_fallback_mask (info-&gt;channels);
 967     }
 968 
 969     /* FIXME: we only want to extract depth if raw audio is what&#39;s in the
 970      * container (i.e. not if there is a decoder involved) */
 971     format_str = gst_structure_get_string (caps_st, &quot;format&quot;);
 972     if (format_str != NULL) {
 973       const GstAudioFormatInfo *finfo;
 974       GstAudioFormat format;
 975 
 976       format = gst_audio_format_from_string (format_str);
 977       finfo = gst_audio_format_get_info (format);
 978       if (finfo)
 979         info-&gt;depth = GST_AUDIO_FORMAT_INFO_DEPTH (finfo);
 980     }
 981 
 982     if (gst_structure_id_has_field (st, _TAGS_QUARK)) {
 983       gst_structure_id_get (st, _TAGS_QUARK, GST_TYPE_TAG_LIST, &amp;tags_st, NULL);
 984       if (gst_tag_list_get_uint (tags_st, GST_TAG_BITRATE, &amp;utmp) ||
 985           gst_tag_list_get_uint (tags_st, GST_TAG_NOMINAL_BITRATE, &amp;utmp))
 986         info-&gt;bitrate = utmp;
 987 
 988       if (gst_tag_list_get_uint (tags_st, GST_TAG_MAXIMUM_BITRATE, &amp;utmp))
 989         info-&gt;max_bitrate = utmp;
 990 
 991       /* FIXME: Is it worth it to remove the tags we&#39;ve parsed? */
 992       gst_discoverer_merge_and_replace_tags (&amp;info-&gt;parent.tags, tags_st);
 993     }
 994 
 995     collect_common_information (&amp;info-&gt;parent, st);
 996 
 997     if (!info-&gt;language &amp;&amp; ((GstDiscovererStreamInfo *) info)-&gt;tags) {
 998       gchar *language;
 999       if (gst_tag_list_get_string (((GstDiscovererStreamInfo *) info)-&gt;tags,
1000               GST_TAG_LANGUAGE_CODE, &amp;language)) {
1001         info-&gt;language = language;
1002       }
1003     }
1004 
1005     gst_caps_unref (caps);
1006     return (GstDiscovererStreamInfo *) info;
1007 
1008   } else if (g_str_has_prefix (name, &quot;video/&quot;) ||
1009       g_str_has_prefix (name, &quot;image/&quot;)) {
1010     GstDiscovererVideoInfo *info;
1011     const gchar *caps_str;
1012 
1013     info = (GstDiscovererVideoInfo *) make_info (parent,
1014         GST_TYPE_DISCOVERER_VIDEO_INFO, caps);
1015 
1016     if (gst_structure_get_int (caps_st, &quot;width&quot;, &amp;tmp))
1017       info-&gt;width = (guint) tmp;
1018     if (gst_structure_get_int (caps_st, &quot;height&quot;, &amp;tmp))
1019       info-&gt;height = (guint) tmp;
1020 
1021     if (gst_structure_get_fraction (caps_st, &quot;framerate&quot;, &amp;tmp, &amp;tmp2)) {
1022       info-&gt;framerate_num = (guint) tmp;
1023       info-&gt;framerate_denom = (guint) tmp2;
1024     } else {
1025       info-&gt;framerate_num = 0;
1026       info-&gt;framerate_denom = 1;
1027     }
1028 
1029     if (gst_structure_get_fraction (caps_st, &quot;pixel-aspect-ratio&quot;, &amp;tmp, &amp;tmp2)) {
1030       info-&gt;par_num = (guint) tmp;
1031       info-&gt;par_denom = (guint) tmp2;
1032     } else {
1033       info-&gt;par_num = 1;
1034       info-&gt;par_denom = 1;
1035     }
1036 
1037     /* FIXME: we only want to extract depth if raw video is what&#39;s in the
1038      * container (i.e. not if there is a decoder involved) */
1039     caps_str = gst_structure_get_string (caps_st, &quot;format&quot;);
1040     if (caps_str != NULL) {
1041       const GstVideoFormatInfo *finfo;
1042       GstVideoFormat format;
1043 
1044       format = gst_video_format_from_string (caps_str);
1045       finfo = gst_video_format_get_info (format);
1046       if (finfo)
1047         info-&gt;depth = finfo-&gt;bits * finfo-&gt;n_components;
1048     }
1049 
1050     caps_str = gst_structure_get_string (caps_st, &quot;interlace-mode&quot;);
1051     if (!caps_str || strcmp (caps_str, &quot;progressive&quot;) == 0)
1052       info-&gt;interlaced = FALSE;
1053     else
1054       info-&gt;interlaced = TRUE;
1055 
1056     if (gst_structure_id_has_field (st, _TAGS_QUARK)) {
1057       gst_structure_id_get (st, _TAGS_QUARK, GST_TYPE_TAG_LIST, &amp;tags_st, NULL);
1058       if (gst_tag_list_get_uint (tags_st, GST_TAG_BITRATE, &amp;utmp) ||
1059           gst_tag_list_get_uint (tags_st, GST_TAG_NOMINAL_BITRATE, &amp;utmp))
1060         info-&gt;bitrate = utmp;
1061 
1062       if (gst_tag_list_get_uint (tags_st, GST_TAG_MAXIMUM_BITRATE, &amp;utmp))
1063         info-&gt;max_bitrate = utmp;
1064 
1065       /* FIXME: Is it worth it to remove the tags we&#39;ve parsed? */
1066       gst_discoverer_merge_and_replace_tags (&amp;info-&gt;parent.tags, tags_st);
1067     }
1068 
1069     collect_common_information (&amp;info-&gt;parent, st);
1070 
1071     gst_caps_unref (caps);
1072     return (GstDiscovererStreamInfo *) info;
1073 
1074   } else if (is_subtitle_caps (caps)) {
1075     GstDiscovererSubtitleInfo *info;
1076 
1077     info = (GstDiscovererSubtitleInfo *) make_info (parent,
1078         GST_TYPE_DISCOVERER_SUBTITLE_INFO, caps);
1079 
1080     if (gst_structure_id_has_field (st, _TAGS_QUARK)) {
1081       const gchar *language;
1082 
1083       gst_structure_id_get (st, _TAGS_QUARK, GST_TYPE_TAG_LIST, &amp;tags_st, NULL);
1084 
1085       language = gst_structure_get_string (caps_st, GST_TAG_LANGUAGE_CODE);
1086       if (language)
1087         info-&gt;language = g_strdup (language);
1088 
1089       /* FIXME: Is it worth it to remove the tags we&#39;ve parsed? */
1090       gst_discoverer_merge_and_replace_tags (&amp;info-&gt;parent.tags, tags_st);
1091     }
1092 
1093     collect_common_information (&amp;info-&gt;parent, st);
1094 
1095     if (!info-&gt;language &amp;&amp; ((GstDiscovererStreamInfo *) info)-&gt;tags) {
1096       gchar *language;
1097       if (gst_tag_list_get_string (((GstDiscovererStreamInfo *) info)-&gt;tags,
1098               GST_TAG_LANGUAGE_CODE, &amp;language)) {
1099         info-&gt;language = language;
1100       }
1101     }
1102 
1103     gst_caps_unref (caps);
1104     return (GstDiscovererStreamInfo *) info;
1105 
1106   } else {
1107     /* None of the above - populate what information we can */
1108     GstDiscovererStreamInfo *info;
1109 
1110     info = make_info (parent, GST_TYPE_DISCOVERER_STREAM_INFO, caps);
1111 
1112     if (gst_structure_id_get (st, _TAGS_QUARK, GST_TYPE_TAG_LIST, &amp;tags_st,
1113             NULL)) {
1114       gst_discoverer_merge_and_replace_tags (&amp;info-&gt;tags, tags_st);
1115     }
1116 
1117     collect_common_information (info, st);
1118 
1119     gst_caps_unref (caps);
1120     return info;
1121   }
1122 
1123 }
1124 
1125 static GstStructure *
1126 find_stream_for_node (GstDiscoverer * dc, const GstStructure * topology)
1127 {
1128   GstPad *pad;
1129   GstPad *target_pad = NULL;
1130   GstStructure *st = NULL;
1131   PrivateStream *ps;
1132   guint i;
1133   GList *tmp;
1134 
1135   if (!dc-&gt;priv-&gt;streams) {
1136     return NULL;
1137   }
1138 
1139   if (!gst_structure_id_has_field (topology, _TOPOLOGY_PAD_QUARK)) {
1140     GST_DEBUG (&quot;Could not find pad for node %&quot; GST_PTR_FORMAT, topology);
1141     return NULL;
1142   }
1143 
1144   gst_structure_id_get (topology, _TOPOLOGY_PAD_QUARK,
1145       GST_TYPE_PAD, &amp;pad, NULL);
1146 
1147   for (i = 0, tmp = dc-&gt;priv-&gt;streams; tmp; tmp = tmp-&gt;next, i++) {
1148     ps = (PrivateStream *) tmp-&gt;data;
1149 
1150     target_pad = gst_ghost_pad_get_target (GST_GHOST_PAD (ps-&gt;pad));
1151     if (target_pad == NULL)
1152       continue;
1153     gst_object_unref (target_pad);
1154 
1155     if (target_pad == pad)
1156       break;
1157   }
1158 
1159   if (tmp)
1160     st = collect_stream_information (dc, ps, i);
1161 
1162   gst_object_unref (pad);
1163 
1164   return st;
1165 }
1166 
1167 /* this can fail due to {framed,parsed}={TRUE,FALSE} differences, thus we filter
1168  * the parent */
1169 static gboolean
1170 child_is_same_stream (const GstCaps * _parent, const GstCaps * child)
1171 {
1172   GstCaps *parent;
1173   gboolean res;
1174 
1175   if (_parent == child)
1176     return TRUE;
1177   if (!_parent)
1178     return FALSE;
1179   if (!child)
1180     return FALSE;
1181 
1182   parent = copy_and_clean_caps (_parent);
1183   res = gst_caps_can_intersect (parent, child);
1184   gst_caps_unref (parent);
1185   return res;
1186 }
1187 
1188 
1189 static gboolean
1190 child_is_raw_stream (const GstCaps * parent, const GstCaps * child)
1191 {
1192   const GstStructure *st1, *st2;
1193   const gchar *name1, *name2;
1194 
1195   if (parent == child)
1196     return TRUE;
1197   if (!parent)
1198     return FALSE;
1199   if (!child)
1200     return FALSE;
1201 
1202   st1 = gst_caps_get_structure (parent, 0);
1203   name1 = gst_structure_get_name (st1);
1204   st2 = gst_caps_get_structure (child, 0);
1205   name2 = gst_structure_get_name (st2);
1206 
1207   if ((g_str_has_prefix (name1, &quot;audio/&quot;) &amp;&amp;
1208           g_str_has_prefix (name2, &quot;audio/x-raw&quot;)) ||
1209       ((g_str_has_prefix (name1, &quot;video/&quot;) ||
1210               g_str_has_prefix (name1, &quot;image/&quot;)) &amp;&amp;
1211           g_str_has_prefix (name2, &quot;video/x-raw&quot;))) {
1212     /* child is the &quot;raw&quot; sub-stream corresponding to parent */
1213     return TRUE;
1214   }
1215 
1216   if (is_subtitle_caps (parent))
1217     return TRUE;
1218 
1219   return FALSE;
1220 }
1221 
1222 /* If a parent is non-NULL, collected stream information will be appended to it
1223  * (and where the information exists, it will be overriden)
1224  */
1225 static GstDiscovererStreamInfo *
1226 parse_stream_topology (GstDiscoverer * dc, const GstStructure * topology,
1227     GstDiscovererStreamInfo * parent)
1228 {
1229   GstDiscovererStreamInfo *res = NULL;
1230   GstCaps *caps = NULL;
1231   const GValue *nval = NULL;
1232 
1233   GST_DEBUG (&quot;parsing: %&quot; GST_PTR_FORMAT, topology);
1234 
1235   nval = gst_structure_get_value (topology, &quot;next&quot;);
1236 
1237   if (nval == NULL || GST_VALUE_HOLDS_STRUCTURE (nval)) {
1238     GstStructure *st = find_stream_for_node (dc, topology);
1239     gboolean add_to_list = TRUE;
1240 
1241     if (st) {
1242       res = collect_information (dc, st, parent);
1243       gst_structure_free (st);
1244     } else {
1245       /* Didn&#39;t find a stream structure, so let&#39;s just use the caps we have */
1246       res = collect_information (dc, topology, parent);
1247     }
1248 
1249     if (nval == NULL) {
1250       /* FIXME : aggregate with information from main streams */
1251       GST_DEBUG (&quot;Coudn&#39;t find &#39;next&#39; ! might be the last entry&quot;);
1252     } else {
1253       GstPad *srcpad;
1254 
1255       st = (GstStructure *) gst_value_get_structure (nval);
1256 
1257       GST_DEBUG (&quot;next is a structure %&quot; GST_PTR_FORMAT, st);
1258 
1259       if (!parent)
1260         parent = res;
1261 
1262       if (gst_structure_id_get (st, _ELEMENT_SRCPAD_QUARK, GST_TYPE_PAD,
1263               &amp;srcpad, NULL)) {
1264         caps = gst_pad_get_current_caps (srcpad);
1265         gst_object_unref (srcpad);
1266       }
1267       if (!caps) {
1268         gst_structure_id_get (st, _CAPS_QUARK, GST_TYPE_CAPS, &amp;caps, NULL);
1269       }
1270 
1271       if (caps) {
1272         if (child_is_same_stream (parent-&gt;caps, caps)) {
1273           /* We sometimes get an extra sub-stream from the parser. If this is
1274            * the case, we just replace the parent caps with this stream&#39;s caps
1275            * since they might contain more information */
1276           gst_caps_replace (&amp;parent-&gt;caps, caps);
1277 
1278           parse_stream_topology (dc, st, parent);
1279           add_to_list = FALSE;
1280         } else if (child_is_raw_stream (parent-&gt;caps, caps)) {
1281           /* This is the &quot;raw&quot; stream corresponding to the parent. This
1282            * contains more information than the parent, tags etc. */
1283           parse_stream_topology (dc, st, parent);
1284           add_to_list = FALSE;
1285         } else {
1286           GstDiscovererStreamInfo *next = parse_stream_topology (dc, st, NULL);
1287           res-&gt;next = next;
1288           next-&gt;previous = res;
1289         }
1290         gst_caps_unref (caps);
1291       }
1292     }
1293 
1294     if (add_to_list) {
1295       dc-&gt;priv-&gt;current_info-&gt;stream_list =
1296           g_list_append (dc-&gt;priv-&gt;current_info-&gt;stream_list, res);
1297     } else {
1298       gst_discoverer_stream_info_unref (res);
1299     }
1300 
1301   } else if (GST_VALUE_HOLDS_LIST (nval)) {
1302     guint i, len;
1303     GstDiscovererContainerInfo *cont;
1304     GstTagList *tags;
1305     GstPad *srcpad;
1306 
1307     if (gst_structure_id_get (topology, _ELEMENT_SRCPAD_QUARK, GST_TYPE_PAD,
1308             &amp;srcpad, NULL)) {
1309       caps = gst_pad_get_current_caps (srcpad);
1310       gst_object_unref (srcpad);
1311     }
1312     if (!caps) {
1313       gst_structure_id_get (topology, _CAPS_QUARK, GST_TYPE_CAPS, &amp;caps, NULL);
1314     }
1315 
1316     if (!caps)
1317       GST_WARNING (&quot;Couldn&#39;t find caps !&quot;);
1318 
1319     len = gst_value_list_get_size (nval);
1320     GST_DEBUG (&quot;next is a list of %d entries&quot;, len);
1321 
1322     cont = (GstDiscovererContainerInfo *)
1323         g_object_new (GST_TYPE_DISCOVERER_CONTAINER_INFO, NULL);
1324     cont-&gt;parent.caps = caps;
1325     res = (GstDiscovererStreamInfo *) cont;
1326 
1327     if (gst_structure_id_has_field (topology, _TAGS_QUARK)) {
1328       GstTagList *tmp;
1329 
1330       gst_structure_id_get (topology, _TAGS_QUARK,
1331           GST_TYPE_TAG_LIST, &amp;tags, NULL);
1332 
1333       GST_DEBUG (&quot;Merge tags %&quot; GST_PTR_FORMAT, tags);
1334 
1335       tmp =
1336           gst_tag_list_merge (cont-&gt;parent.tags, (GstTagList *) tags,
1337           GST_TAG_MERGE_APPEND);
1338       gst_tag_list_unref (tags);
1339       if (cont-&gt;parent.tags)
1340         gst_tag_list_unref (cont-&gt;parent.tags);
1341       cont-&gt;parent.tags = tmp;
1342       GST_DEBUG (&quot;Container info tags %&quot; GST_PTR_FORMAT, tmp);
1343     }
1344 
1345     for (i = 0; i &lt; len; i++) {
1346       const GValue *subv = gst_value_list_get_value (nval, i);
1347       const GstStructure *subst = gst_value_get_structure (subv);
1348       GstDiscovererStreamInfo *substream;
1349 
1350       GST_DEBUG (&quot;%d %&quot; GST_PTR_FORMAT, i, subst);
1351 
1352       substream = parse_stream_topology (dc, subst, NULL);
1353 
1354       substream-&gt;previous = res;
1355       cont-&gt;streams =
1356           g_list_append (cont-&gt;streams,
1357           gst_discoverer_stream_info_ref (substream));
1358     }
1359   }
1360 
1361   return res;
1362 }
1363 
<a name="18" id="anc18"></a><span class="line-added">1364 /* Required DISCO_LOCK to be taken, and will release it */</span>
<span class="line-added">1365 static void</span>
<span class="line-added">1366 setup_next_uri_locked (GstDiscoverer * dc)</span>
<span class="line-added">1367 {</span>
<span class="line-added">1368   if (dc-&gt;priv-&gt;pending_uris != NULL) {</span>
<span class="line-added">1369     gboolean ready = _setup_locked (dc);</span>
<span class="line-added">1370     DISCO_UNLOCK (dc);</span>
<span class="line-added">1371 </span>
<span class="line-added">1372     if (!ready) {</span>
<span class="line-added">1373       /* Start timeout */</span>
<span class="line-added">1374       handle_current_async (dc);</span>
<span class="line-added">1375     } else {</span>
<span class="line-added">1376       g_idle_add_full (G_PRIORITY_DEFAULT_IDLE,</span>
<span class="line-added">1377           (GSourceFunc) emit_discovererd_and_next, gst_object_ref (dc),</span>
<span class="line-added">1378           gst_object_unref);</span>
<span class="line-added">1379     }</span>
<span class="line-added">1380   } else {</span>
<span class="line-added">1381     /* We&#39;re done ! */</span>
<span class="line-added">1382     DISCO_UNLOCK (dc);</span>
<span class="line-added">1383     g_signal_emit (dc, gst_discoverer_signals[SIGNAL_FINISHED], 0);</span>
<span class="line-added">1384   }</span>
<span class="line-added">1385 }</span>
<span class="line-added">1386 </span>
<span class="line-added">1387 </span>
<span class="line-added">1388 static void</span>
<span class="line-added">1389 emit_discovererd (GstDiscoverer * dc)</span>
<span class="line-added">1390 {</span>
<span class="line-added">1391   GST_DEBUG_OBJECT (dc, &quot;Emitting &#39;discoverered&#39; %s&quot;,</span>
<span class="line-added">1392       dc-&gt;priv-&gt;current_info-&gt;uri);</span>
<span class="line-added">1393   g_signal_emit (dc, gst_discoverer_signals[SIGNAL_DISCOVERED], 0,</span>
<span class="line-added">1394       dc-&gt;priv-&gt;current_info, dc-&gt;priv-&gt;current_error);</span>
<span class="line-added">1395   /* Clients get a copy of current_info since it is a boxed type */</span>
<span class="line-added">1396   gst_discoverer_info_unref (dc-&gt;priv-&gt;current_info);</span>
<span class="line-added">1397   dc-&gt;priv-&gt;current_info = NULL;</span>
<span class="line-added">1398 }</span>
<span class="line-added">1399 </span>
<span class="line-added">1400 static gboolean</span>
<span class="line-added">1401 emit_discovererd_and_next (GstDiscoverer * dc)</span>
<span class="line-added">1402 {</span>
<span class="line-added">1403   emit_discovererd (dc);</span>
<span class="line-added">1404 </span>
<span class="line-added">1405   DISCO_LOCK (dc);</span>
<span class="line-added">1406   setup_next_uri_locked (dc);</span>
<span class="line-added">1407 </span>
<span class="line-added">1408   return G_SOURCE_REMOVE;</span>
<span class="line-added">1409 }</span>
<span class="line-added">1410 </span>
1411 /* Called when pipeline is pre-rolled */
1412 static void
1413 discoverer_collect (GstDiscoverer * dc)
1414 {
1415   GST_DEBUG (&quot;Collecting information&quot;);
1416 
1417   /* Stop the timeout handler if present */
<a name="19" id="anc19"></a><span class="line-modified">1418   if (dc-&gt;priv-&gt;timeout_source) {</span>
<span class="line-modified">1419     g_source_destroy (dc-&gt;priv-&gt;timeout_source);</span>
<span class="line-modified">1420     g_source_unref (dc-&gt;priv-&gt;timeout_source);</span>
<span class="line-added">1421     dc-&gt;priv-&gt;timeout_source = NULL;</span>
<span class="line-added">1422   }</span>
<span class="line-added">1423 </span>
<span class="line-added">1424   if (dc-&gt;priv-&gt;use_cache &amp;&amp; dc-&gt;priv-&gt;current_info</span>
<span class="line-added">1425       &amp;&amp; dc-&gt;priv-&gt;current_info-&gt;from_cache) {</span>
<span class="line-added">1426     GST_DEBUG_OBJECT (dc,</span>
<span class="line-added">1427         &quot;Nothing to collect as the info was built from&quot; &quot; the cache&quot;);</span>
<span class="line-added">1428     return;</span>
1429   }
1430 
1431   if (dc-&gt;priv-&gt;streams) {
1432     /* FIXME : Make this querying optional */
1433     if (TRUE) {
1434       GstElement *pipeline = (GstElement *) dc-&gt;priv-&gt;pipeline;
1435       gint64 dur;
1436 
1437       GST_DEBUG (&quot;Attempting to query duration&quot;);
1438 
1439       if (gst_element_query_duration (pipeline, GST_FORMAT_TIME, &amp;dur)) {
1440         GST_DEBUG (&quot;Got duration %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (dur));
1441         dc-&gt;priv-&gt;current_info-&gt;duration = (guint64) dur;
1442       } else if (dc-&gt;priv-&gt;current_info-&gt;result != GST_DISCOVERER_ERROR) {
1443         GstStateChangeReturn sret;
1444         /* Note: We don&#39;t switch to PLAYING if we previously saw an ERROR since
1445          * the state of various element isn&#39;t guaranteed anymore */
1446 
1447         /* Some parsers may not even return a rough estimate right away, e.g.
1448          * because they&#39;ve only processed a single frame so far, so if we
1449          * didn&#39;t get a duration the first time, spin a bit and try again.
1450          * Ugly, but still better than making parsers or other elements return
1451          * completely bogus values. We need some API extensions to solve this
1452          * better. */
1453         GST_INFO (&quot;No duration yet, try a bit harder..&quot;);
1454         /* Make sure we don&#39;t add/remove elements while switching to PLAYING itself */
1455         DISCO_LOCK (dc);
1456         sret = gst_element_set_state (pipeline, GST_STATE_PLAYING);
1457         DISCO_UNLOCK (dc);
1458         if (sret != GST_STATE_CHANGE_FAILURE) {
1459           int i;
1460 
1461           for (i = 0; i &lt; 2; ++i) {
1462             g_usleep (G_USEC_PER_SEC / 20);
1463             if (gst_element_query_duration (pipeline, GST_FORMAT_TIME, &amp;dur)
1464                 &amp;&amp; dur &gt; 0) {
1465               GST_DEBUG (&quot;Got duration %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (dur));
1466               dc-&gt;priv-&gt;current_info-&gt;duration = (guint64) dur;
1467               break;
1468             }
1469           }
1470           gst_element_set_state (pipeline, GST_STATE_PAUSED);
1471         }
1472       }
1473 
1474       if (dc-&gt;priv-&gt;seeking_query) {
1475         if (gst_element_query (pipeline, dc-&gt;priv-&gt;seeking_query)) {
1476           GstFormat format;
1477           gboolean seekable;
1478 
1479           gst_query_parse_seeking (dc-&gt;priv-&gt;seeking_query, &amp;format,
1480               &amp;seekable, NULL, NULL);
1481           if (format == GST_FORMAT_TIME) {
1482             GST_DEBUG (&quot;Got seekable %d&quot;, seekable);
1483             dc-&gt;priv-&gt;current_info-&gt;seekable = seekable;
1484           }
1485         }
1486       }
1487     }
1488 
1489     if (dc-&gt;priv-&gt;target_state == GST_STATE_PAUSED)
1490       dc-&gt;priv-&gt;current_info-&gt;live = FALSE;
1491     else
1492       dc-&gt;priv-&gt;current_info-&gt;live = TRUE;
1493 
1494     if (dc-&gt;priv-&gt;current_topology)
1495       dc-&gt;priv-&gt;current_info-&gt;stream_info = parse_stream_topology (dc,
1496           dc-&gt;priv-&gt;current_topology, NULL);
1497 
1498     /*
1499      * Images need some special handling. They do not have a duration, have
1500      * caps named image/&lt;foo&gt; (th exception being MJPEG video which is also
1501      * type image/jpeg), and should consist of precisely one stream (actually
1502      * initially there are 2, the image and raw stream, but we squash these
1503      * while parsing the stream topology). At some point, if we find that these
1504      * conditions are not sufficient, we can count the number of decoders and
1505      * parsers in the chain, and if there&#39;s more than one decoder, or any
1506      * parser at all, we should not mark this as an image.
1507      */
1508     if (dc-&gt;priv-&gt;current_info-&gt;duration == 0 &amp;&amp;
1509         dc-&gt;priv-&gt;current_info-&gt;stream_info != NULL &amp;&amp;
1510         dc-&gt;priv-&gt;current_info-&gt;stream_info-&gt;next == NULL) {
1511       GstDiscovererStreamInfo *stream_info;
1512       GstStructure *st;
1513 
1514       stream_info = dc-&gt;priv-&gt;current_info-&gt;stream_info;
1515       st = gst_caps_get_structure (stream_info-&gt;caps, 0);
1516 
1517       if (g_str_has_prefix (gst_structure_get_name (st), &quot;image/&quot;))
1518         ((GstDiscovererVideoInfo *) stream_info)-&gt;is_image = TRUE;
1519     }
1520   }
1521 
<a name="20" id="anc20"></a><span class="line-modified">1522   if (dc-&gt;priv-&gt;use_cache &amp;&amp; dc-&gt;priv-&gt;current_info-&gt;cachefile &amp;&amp;</span>
<span class="line-modified">1523       dc-&gt;priv-&gt;current_info-&gt;result == GST_DISCOVERER_OK) {</span>
<span class="line-modified">1524     GVariant *variant = gst_discoverer_info_to_variant (dc-&gt;priv-&gt;current_info,</span>
<span class="line-modified">1525         GST_DISCOVERER_SERIALIZE_ALL);</span>
<span class="line-modified">1526 </span>
<span class="line-modified">1527     g_file_set_contents (dc-&gt;priv-&gt;current_info-&gt;cachefile,</span>
<span class="line-modified">1528         g_variant_get_data (variant), g_variant_get_size (variant), NULL);</span>
1529   }
<a name="21" id="anc21"></a><span class="line-added">1530 </span>
<span class="line-added">1531   if (dc-&gt;priv-&gt;async)</span>
<span class="line-added">1532     emit_discovererd (dc);</span>
1533 }
1534 
1535 static void
1536 get_async_cb (gpointer cb_data, GSource * source, GSourceFunc * func,
1537     gpointer * data)
1538 {
1539   *func = (GSourceFunc) async_timeout_cb;
1540   *data = cb_data;
1541 }
1542 
1543 /* Wrapper since GSourceCallbackFuncs don&#39;t expect a return value from ref() */
1544 static void
1545 _void_g_object_ref (gpointer object)
1546 {
1547   g_object_ref (G_OBJECT (object));
1548 }
1549 
1550 static void
1551 handle_current_async (GstDiscoverer * dc)
1552 {
1553   GSource *source;
1554   static GSourceCallbackFuncs cb_funcs = {
1555     _void_g_object_ref,
1556     g_object_unref,
1557     get_async_cb,
1558   };
1559 
1560   /* Attach a timeout to the main context */
1561   source = g_timeout_source_new (dc-&gt;priv-&gt;timeout / GST_MSECOND);
1562   g_source_set_callback_indirect (source, g_object_ref (dc), &amp;cb_funcs);
<a name="22" id="anc22"></a><span class="line-modified">1563   g_source_attach (source, dc-&gt;priv-&gt;ctx);</span>
<span class="line-modified">1564   dc-&gt;priv-&gt;timeout_source = source;</span>
1565 }
1566 
1567 
1568 /* Returns TRUE if processing should stop */
1569 static gboolean
1570 handle_message (GstDiscoverer * dc, GstMessage * msg)
1571 {
1572   gboolean done = FALSE;
1573   const gchar *dump_name = NULL;
1574 
1575   GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg), &quot;got a %s message&quot;,
1576       GST_MESSAGE_TYPE_NAME (msg));
1577 
1578   switch (GST_MESSAGE_TYPE (msg)) {
1579     case GST_MESSAGE_ERROR:{
1580       GError *gerr;
1581       gchar *debug;
1582 
1583       gst_message_parse_error (msg, &amp;gerr, &amp;debug);
1584       GST_WARNING_OBJECT (GST_MESSAGE_SRC (msg),
1585           &quot;Got an error [debug:%s], [message:%s]&quot;, debug, gerr-&gt;message);
1586       dc-&gt;priv-&gt;current_error = gerr;
1587       g_free (debug);
1588 
1589       /* We need to stop */
1590       done = TRUE;
1591       dump_name = &quot;gst-discoverer-error&quot;;
1592 
1593       /* Don&#39;t override missing plugin result code for missing plugin errors */
1594       if (dc-&gt;priv-&gt;current_info-&gt;result != GST_DISCOVERER_MISSING_PLUGINS ||
1595           (!g_error_matches (gerr, GST_CORE_ERROR,
1596                   GST_CORE_ERROR_MISSING_PLUGIN) &amp;&amp;
1597               !g_error_matches (gerr, GST_STREAM_ERROR,
1598                   GST_STREAM_ERROR_CODEC_NOT_FOUND))) {
1599         GST_DEBUG (&quot;Setting result to ERROR&quot;);
1600         dc-&gt;priv-&gt;current_info-&gt;result = GST_DISCOVERER_ERROR;
1601       }
1602     }
1603       break;
1604 
1605     case GST_MESSAGE_WARNING:{
1606       GError *err;
1607       gchar *debug = NULL;
1608 
1609       gst_message_parse_warning (msg, &amp;err, &amp;debug);
1610       GST_WARNING_OBJECT (GST_MESSAGE_SRC (msg),
1611           &quot;Got a warning [debug:%s], [message:%s]&quot;, debug, err-&gt;message);
1612       g_clear_error (&amp;err);
1613       g_free (debug);
1614       dump_name = &quot;gst-discoverer-warning&quot;;
1615       break;
1616     }
1617 
1618     case GST_MESSAGE_EOS:
1619       GST_DEBUG (&quot;Got EOS !&quot;);
1620       done = TRUE;
1621       dump_name = &quot;gst-discoverer-eos&quot;;
1622       break;
1623 
1624     case GST_MESSAGE_APPLICATION:{
1625       const gchar *name =
1626           gst_structure_get_name (gst_message_get_structure (msg));
1627 
1628       if (g_strcmp0 (name, &quot;DiscovererDone&quot;))
1629         break;
1630 
1631       /* Maybe we already reached the target state, and all we&#39;re waiting for
1632        * is either the subtitle tags or no_more_pads
1633        */
1634       DISCO_LOCK (dc);
1635       if (dc-&gt;priv-&gt;pending_subtitle_pads == 0)
1636         done = dc-&gt;priv-&gt;no_more_pads
1637             &amp;&amp; dc-&gt;priv-&gt;target_state == dc-&gt;priv-&gt;current_state;
1638       DISCO_UNLOCK (dc);
1639 
1640       if (done)
1641         dump_name = &quot;gst-discoverer-application-message&quot;;
1642     }
1643       break;
1644 
1645     case GST_MESSAGE_STATE_CHANGED:{
1646       GstState old, new, pending;
1647 
1648       gst_message_parse_state_changed (msg, &amp;old, &amp;new, &amp;pending);
1649       if (GST_MESSAGE_SRC (msg) == (GstObject *) dc-&gt;priv-&gt;pipeline) {
1650         DISCO_LOCK (dc);
1651         dc-&gt;priv-&gt;current_state = new;
1652 
1653         if (dc-&gt;priv-&gt;pending_subtitle_pads == 0)
1654           done = dc-&gt;priv-&gt;no_more_pads
1655               &amp;&amp; dc-&gt;priv-&gt;target_state == dc-&gt;priv-&gt;current_state;
1656         /* Else we should get unblocked in GST_MESSAGE_APPLICATION */
1657 
1658         DISCO_UNLOCK (dc);
1659       }
1660 
1661       if (done)
1662         dump_name = &quot;gst-discoverer-target-state&quot;;
1663     }
1664       break;
1665 
1666     case GST_MESSAGE_ELEMENT:
1667     {
1668       GQuark sttype;
1669       const GstStructure *structure;
1670 
1671       structure = gst_message_get_structure (msg);
1672       sttype = gst_structure_get_name_id (structure);
1673       GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg),
1674           &quot;structure %&quot; GST_PTR_FORMAT, structure);
1675       if (sttype == _MISSING_PLUGIN_QUARK) {
1676         GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg),
1677             &quot;Setting result to MISSING_PLUGINS&quot;);
1678         dc-&gt;priv-&gt;current_info-&gt;result = GST_DISCOVERER_MISSING_PLUGINS;
1679         /* FIXME 2.0 Remove completely the -&gt;misc
1680          * Keep the old behaviour for now.
1681          */
1682         if (dc-&gt;priv-&gt;current_info-&gt;misc)
1683           gst_structure_free (dc-&gt;priv-&gt;current_info-&gt;misc);
1684         dc-&gt;priv-&gt;current_info-&gt;misc = gst_structure_copy (structure);
1685         g_ptr_array_add (dc-&gt;priv-&gt;current_info-&gt;missing_elements_details,
1686             gst_missing_plugin_message_get_installer_detail (msg));
1687       } else if (sttype == _STREAM_TOPOLOGY_QUARK) {
1688         if (dc-&gt;priv-&gt;current_topology)
1689           gst_structure_free (dc-&gt;priv-&gt;current_topology);
1690         dc-&gt;priv-&gt;current_topology = gst_structure_copy (structure);
1691       }
1692     }
1693       break;
1694 
1695     case GST_MESSAGE_TAG:
1696     {
1697       GstTagList *tl, *tmp;
1698 
1699       gst_message_parse_tag (msg, &amp;tl);
1700       GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg), &quot;Got tags %&quot; GST_PTR_FORMAT, tl);
1701       /* Merge with current tags */
1702       tmp =
1703           gst_tag_list_merge (dc-&gt;priv-&gt;current_info-&gt;tags, tl,
1704           GST_TAG_MERGE_APPEND);
1705       gst_tag_list_unref (tl);
1706       if (dc-&gt;priv-&gt;current_info-&gt;tags)
1707         gst_tag_list_unref (dc-&gt;priv-&gt;current_info-&gt;tags);
1708       dc-&gt;priv-&gt;current_info-&gt;tags = tmp;
1709       GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg), &quot;Current info %p, tags %&quot;
1710           GST_PTR_FORMAT, dc-&gt;priv-&gt;current_info, tmp);
1711     }
1712       break;
1713 
1714     case GST_MESSAGE_TOC:
1715     {
1716       GstToc *tmp;
1717 
1718       gst_message_parse_toc (msg, &amp;tmp, NULL);
1719       GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg), &quot;Got toc %&quot; GST_PTR_FORMAT, tmp);
1720       if (dc-&gt;priv-&gt;current_info-&gt;toc)
1721         gst_toc_unref (dc-&gt;priv-&gt;current_info-&gt;toc);
1722       dc-&gt;priv-&gt;current_info-&gt;toc = tmp;        /* transfer ownership */
1723       GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg), &quot;Current info %p, toc %&quot;
1724           GST_PTR_FORMAT, dc-&gt;priv-&gt;current_info, tmp);
1725     }
1726       break;
1727 
1728     default:
1729       break;
1730   }
1731 
1732   if (dump_name != NULL) {
1733     /* dump graph when done or for warnings */
1734     GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS (GST_BIN (dc-&gt;priv-&gt;pipeline),
1735         GST_DEBUG_GRAPH_SHOW_ALL, dump_name);
1736   }
1737   return done;
1738 }
1739 
1740 static void
1741 handle_current_sync (GstDiscoverer * dc)
1742 {
1743   GTimer *timer;
1744   gdouble deadline = ((gdouble) dc-&gt;priv-&gt;timeout) / GST_SECOND;
1745   GstMessage *msg;
1746   gboolean done = FALSE;
1747 
1748   timer = g_timer_new ();
1749   g_timer_start (timer);
1750 
1751   do {
1752     /* poll bus with timeout */
1753     /* FIXME : make the timeout more fine-tuned */
1754     if ((msg = gst_bus_timed_pop (dc-&gt;priv-&gt;bus, GST_SECOND / 2))) {
1755       done = handle_message (dc, msg);
1756       gst_message_unref (msg);
1757     }
1758   } while (!done &amp;&amp; (g_timer_elapsed (timer, NULL) &lt; deadline));
1759 
1760   /* return result */
1761   if (!done) {
1762     GST_DEBUG (&quot;we timed out! Setting result to TIMEOUT&quot;);
1763     dc-&gt;priv-&gt;current_info-&gt;result = GST_DISCOVERER_TIMEOUT;
1764   }
1765 
1766   DISCO_LOCK (dc);
1767   dc-&gt;priv-&gt;processing = FALSE;
1768   DISCO_UNLOCK (dc);
1769 
1770 
1771   GST_DEBUG (&quot;Done&quot;);
1772 
1773   g_timer_stop (timer);
1774   g_timer_destroy (timer);
1775 }
1776 
<a name="23" id="anc23"></a><span class="line-modified">1777 static gchar *</span>
<span class="line-added">1778 _serialized_info_get_path (GstDiscoverer * dc, gchar * uri)</span>
<span class="line-added">1779 {</span>
<span class="line-added">1780   GChecksum *cs = NULL;</span>
<span class="line-added">1781   GStatBuf file_status;</span>
<span class="line-added">1782   gchar *location = NULL, *res = NULL, *cache_dir = NULL, *tmp = NULL,</span>
<span class="line-added">1783       *protocol = gst_uri_get_protocol (uri), hash_dirname[3] = &quot;00&quot;;</span>
<span class="line-added">1784   const gchar *checksum;</span>
<span class="line-added">1785 </span>
<span class="line-added">1786   if (g_ascii_strcasecmp (protocol, &quot;file&quot;) != 0) {</span>
<span class="line-added">1787     GST_DEBUG_OBJECT (dc, &quot;Can not work with serialized DiscovererInfo&quot;</span>
<span class="line-added">1788         &quot; on non local files - protocol: %s&quot;, protocol);</span>
<span class="line-added">1789 </span>
<span class="line-added">1790     goto done;</span>
<span class="line-added">1791   }</span>
<span class="line-added">1792 </span>
<span class="line-added">1793   location = gst_uri_get_location (uri);</span>
<span class="line-added">1794   if (g_stat (location, &amp;file_status) &lt; 0) {</span>
<span class="line-added">1795     GST_DEBUG_OBJECT (dc, &quot;Could not get stat for file: %s&quot;, location);</span>
<span class="line-added">1796 </span>
<span class="line-added">1797     goto done;</span>
<span class="line-added">1798   }</span>
<span class="line-added">1799 </span>
<span class="line-added">1800   tmp = g_strdup_printf (&quot;%s-%&quot; G_GSIZE_FORMAT &quot;-%&quot; G_GINT64_FORMAT,</span>
<span class="line-added">1801       location, (gsize) file_status.st_size, (gint64) file_status.st_mtime);</span>
<span class="line-added">1802   cs = g_checksum_new (G_CHECKSUM_SHA1);</span>
<span class="line-added">1803   g_checksum_update (cs, (const guchar *) tmp, strlen (tmp));</span>
<span class="line-added">1804   checksum = g_checksum_get_string (cs);</span>
<span class="line-added">1805 </span>
<span class="line-added">1806   hash_dirname[0] = checksum[0];</span>
<span class="line-added">1807   hash_dirname[1] = checksum[1];</span>
<span class="line-added">1808   cache_dir =</span>
<span class="line-added">1809       g_build_filename (g_get_user_cache_dir (), &quot;gstreamer-&quot; GST_API_VERSION,</span>
<span class="line-added">1810       CACHE_DIRNAME, hash_dirname, NULL);</span>
<span class="line-added">1811   g_mkdir_with_parents (cache_dir, 0777);</span>
<span class="line-added">1812 </span>
<span class="line-added">1813   res = g_build_filename (cache_dir, &amp;checksum[2], NULL);</span>
<span class="line-added">1814 </span>
<span class="line-added">1815 done:</span>
<span class="line-added">1816   g_free (cache_dir);</span>
<span class="line-added">1817   g_free (location);</span>
<span class="line-added">1818   g_free (tmp);</span>
<span class="line-added">1819   g_free (protocol);</span>
<span class="line-added">1820 </span>
<span class="line-added">1821   return res;</span>
<span class="line-added">1822 }</span>
<span class="line-added">1823 </span>
<span class="line-added">1824 static GstDiscovererInfo *</span>
<span class="line-added">1825 _get_info_from_cachefile (GstDiscoverer * dc, gchar * cachefile)</span>
<span class="line-added">1826 {</span>
<span class="line-added">1827   gchar *data;</span>
<span class="line-added">1828   gsize length;</span>
<span class="line-added">1829 </span>
<span class="line-added">1830   if (g_file_get_contents (cachefile, &amp;data, &amp;length, NULL)) {</span>
<span class="line-added">1831     GstDiscovererInfo *info = NULL;</span>
<span class="line-added">1832     GVariant *variant =</span>
<span class="line-added">1833         g_variant_new_from_data (G_VARIANT_TYPE (&quot;v&quot;), data, length,</span>
<span class="line-added">1834         TRUE, NULL, NULL);</span>
<span class="line-added">1835 </span>
<span class="line-added">1836     info = gst_discoverer_info_from_variant (variant);</span>
<span class="line-added">1837     g_variant_unref (variant);</span>
<span class="line-added">1838 </span>
<span class="line-added">1839     if (info) {</span>
<span class="line-added">1840       info-&gt;cachefile = cachefile;</span>
<span class="line-added">1841       info-&gt;from_cache = (gpointer) 0x01;</span>
<span class="line-added">1842     }</span>
<span class="line-added">1843 </span>
<span class="line-added">1844     GST_INFO_OBJECT (dc, &quot;Got info from cache: %p&quot;, info);</span>
<span class="line-added">1845 </span>
<span class="line-added">1846     return info;</span>
<span class="line-added">1847   }</span>
<span class="line-added">1848 </span>
<span class="line-added">1849   return NULL;</span>
<span class="line-added">1850 }</span>
<span class="line-added">1851 </span>
<span class="line-added">1852 static gboolean</span>
1853 _setup_locked (GstDiscoverer * dc)
1854 {
1855   GstStateChangeReturn ret;
<a name="24" id="anc24"></a><span class="line-added">1856   gchar *uri = (gchar *) dc-&gt;priv-&gt;pending_uris-&gt;data;</span>
<span class="line-added">1857   gchar *cachefile = NULL;</span>
<span class="line-added">1858 </span>
<span class="line-added">1859   dc-&gt;priv-&gt;pending_uris =</span>
<span class="line-added">1860       g_list_delete_link (dc-&gt;priv-&gt;pending_uris, dc-&gt;priv-&gt;pending_uris);</span>
<span class="line-added">1861 </span>
<span class="line-added">1862   if (dc-&gt;priv-&gt;use_cache) {</span>
<span class="line-added">1863     cachefile = _serialized_info_get_path (dc, uri);</span>
<span class="line-added">1864     if (cachefile)</span>
<span class="line-added">1865       dc-&gt;priv-&gt;current_info = _get_info_from_cachefile (dc, cachefile);</span>
<span class="line-added">1866 </span>
<span class="line-added">1867     if (dc-&gt;priv-&gt;current_info) {</span>
<span class="line-added">1868       /* Make sure the URI is exactly what the user passed in */</span>
<span class="line-added">1869       g_free (dc-&gt;priv-&gt;current_info-&gt;uri);</span>
<span class="line-added">1870       dc-&gt;priv-&gt;current_info-&gt;uri = uri;</span>
<span class="line-added">1871 </span>
<span class="line-added">1872       dc-&gt;priv-&gt;current_info-&gt;cachefile = cachefile;</span>
<span class="line-added">1873       dc-&gt;priv-&gt;processing = FALSE;</span>
<span class="line-added">1874       dc-&gt;priv-&gt;target_state = GST_STATE_NULL;</span>
<span class="line-added">1875 </span>
<span class="line-added">1876       return TRUE;</span>
<span class="line-added">1877     }</span>
<span class="line-added">1878   }</span>
1879 
1880   GST_DEBUG (&quot;Setting up&quot;);
1881 
1882   /* Pop URI off the pending URI list */
1883   dc-&gt;priv-&gt;current_info =
1884       (GstDiscovererInfo *) g_object_new (GST_TYPE_DISCOVERER_INFO, NULL);
<a name="25" id="anc25"></a><span class="line-modified">1885   dc-&gt;priv-&gt;current_info-&gt;cachefile = cachefile;</span>
<span class="line-modified">1886   dc-&gt;priv-&gt;current_info-&gt;uri = uri;</span>

1887 
1888   /* set uri on uridecodebin */
1889   g_object_set (dc-&gt;priv-&gt;uridecodebin, &quot;uri&quot;, dc-&gt;priv-&gt;current_info-&gt;uri,
1890       NULL);
1891 
1892   GST_DEBUG (&quot;Current is now %s&quot;, dc-&gt;priv-&gt;current_info-&gt;uri);
1893 
1894   dc-&gt;priv-&gt;processing = TRUE;
1895 
1896   dc-&gt;priv-&gt;target_state = GST_STATE_PAUSED;
1897 
1898   /* set pipeline to PAUSED */
1899   DISCO_UNLOCK (dc);
1900   GST_DEBUG (&quot;Setting pipeline to PAUSED&quot;);
1901   ret =
1902       gst_element_set_state ((GstElement *) dc-&gt;priv-&gt;pipeline,
1903       dc-&gt;priv-&gt;target_state);
1904 
1905   if (ret == GST_STATE_CHANGE_NO_PREROLL) {
1906     GST_DEBUG (&quot;Source is live, switching to PLAYING&quot;);
1907     dc-&gt;priv-&gt;target_state = GST_STATE_PLAYING;
1908     ret =
1909         gst_element_set_state ((GstElement *) dc-&gt;priv-&gt;pipeline,
1910         dc-&gt;priv-&gt;target_state);
1911   }
1912   DISCO_LOCK (dc);
1913 
1914 
1915   GST_DEBUG_OBJECT (dc, &quot;Pipeline going to PAUSED : %s&quot;,
1916       gst_element_state_change_return_get_name (ret));
<a name="26" id="anc26"></a><span class="line-added">1917 </span>
<span class="line-added">1918   return FALSE;</span>
1919 }
1920 
1921 static void
1922 discoverer_cleanup (GstDiscoverer * dc)
1923 {
1924   GST_DEBUG (&quot;Cleaning up&quot;);
1925 
1926   DISCO_LOCK (dc);
1927   dc-&gt;priv-&gt;cleanup = TRUE;
1928   DISCO_UNLOCK (dc);
1929 
1930   gst_bus_set_flushing (dc-&gt;priv-&gt;bus, TRUE);
1931 
1932   DISCO_LOCK (dc);
1933   if (dc-&gt;priv-&gt;current_error) {
1934     g_error_free (dc-&gt;priv-&gt;current_error);
1935     DISCO_UNLOCK (dc);
1936     gst_element_set_state ((GstElement *) dc-&gt;priv-&gt;pipeline, GST_STATE_NULL);
1937   } else {
1938     DISCO_UNLOCK (dc);
1939   }
1940 
1941   gst_element_set_state ((GstElement *) dc-&gt;priv-&gt;pipeline, GST_STATE_READY);
1942   gst_bus_set_flushing (dc-&gt;priv-&gt;bus, FALSE);
1943 
1944   DISCO_LOCK (dc);
1945   dc-&gt;priv-&gt;current_error = NULL;
1946   if (dc-&gt;priv-&gt;current_topology) {
1947     gst_structure_free (dc-&gt;priv-&gt;current_topology);
1948     dc-&gt;priv-&gt;current_topology = NULL;
1949   }
1950 
1951   dc-&gt;priv-&gt;current_info = NULL;
1952 
1953   dc-&gt;priv-&gt;pending_subtitle_pads = 0;
1954 
1955   dc-&gt;priv-&gt;current_state = GST_STATE_NULL;
1956   dc-&gt;priv-&gt;target_state = GST_STATE_NULL;
1957   dc-&gt;priv-&gt;no_more_pads = FALSE;
1958   dc-&gt;priv-&gt;cleanup = FALSE;
1959 
1960 
1961   /* Try popping the next uri */
1962   if (dc-&gt;priv-&gt;async) {
<a name="27" id="anc27"></a><span class="line-modified">1963     setup_next_uri_locked (dc);</span>









1964   } else
1965     DISCO_UNLOCK (dc);
1966 
1967   GST_DEBUG (&quot;out&quot;);
1968 }
1969 
1970 static void
1971 discoverer_bus_cb (GstBus * bus, GstMessage * msg, GstDiscoverer * dc)
1972 {
1973   if (dc-&gt;priv-&gt;processing) {
1974     if (handle_message (dc, msg)) {
1975       GST_DEBUG (&quot;Stopping asynchronously&quot;);
1976       /* Serialise with _event_probe() */
1977       DISCO_LOCK (dc);
1978       dc-&gt;priv-&gt;processing = FALSE;
1979       DISCO_UNLOCK (dc);
1980       discoverer_collect (dc);
1981       discoverer_cleanup (dc);
1982     }
1983   }
1984 }
1985 
1986 static gboolean
1987 async_timeout_cb (GstDiscoverer * dc)
1988 {
1989   if (!g_source_is_destroyed (g_main_current_source ())) {
<a name="28" id="anc28"></a>
1990     GST_DEBUG (&quot;Setting result to TIMEOUT&quot;);
1991     dc-&gt;priv-&gt;current_info-&gt;result = GST_DISCOVERER_TIMEOUT;
1992     dc-&gt;priv-&gt;processing = FALSE;
1993     discoverer_collect (dc);
1994     discoverer_cleanup (dc);
1995   }
1996   return FALSE;
1997 }
1998 
1999 /* If there is a pending URI, it will pop it from the list of pending
2000  * URIs and start the discovery on it.
2001  *
2002  * Returns GST_DISCOVERER_OK if the next URI was popped and is processing,
2003  * else a error flag.
2004  */
2005 static GstDiscovererResult
2006 start_discovering (GstDiscoverer * dc)
2007 {
<a name="29" id="anc29"></a><span class="line-added">2008   gboolean ready;</span>
2009   GstDiscovererResult res = GST_DISCOVERER_OK;
2010 
2011   GST_DEBUG (&quot;Starting&quot;);
2012 
2013   DISCO_LOCK (dc);
2014   if (dc-&gt;priv-&gt;pending_uris == NULL) {
2015     GST_WARNING (&quot;No URI to process&quot;);
2016     res = GST_DISCOVERER_URI_INVALID;
2017     DISCO_UNLOCK (dc);
2018     goto beach;
2019   }
2020 
2021   if (dc-&gt;priv-&gt;current_info != NULL) {
2022     GST_WARNING (&quot;Already processing a file&quot;);
2023     res = GST_DISCOVERER_BUSY;
2024     DISCO_UNLOCK (dc);
2025     goto beach;
2026   }
2027 
2028   g_signal_emit (dc, gst_discoverer_signals[SIGNAL_STARTING], 0);
2029 
<a name="30" id="anc30"></a><span class="line-modified">2030   ready = _setup_locked (dc);</span>
2031 
2032   DISCO_UNLOCK (dc);
2033 
<a name="31" id="anc31"></a><span class="line-modified">2034   if (dc-&gt;priv-&gt;async) {</span>
<span class="line-added">2035     if (ready) {</span>
<span class="line-added">2036       g_idle_add_full (G_PRIORITY_DEFAULT_IDLE,</span>
<span class="line-added">2037           (GSourceFunc) emit_discovererd_and_next, gst_object_ref (dc),</span>
<span class="line-added">2038           gst_object_unref);</span>
<span class="line-added">2039 </span>
<span class="line-added">2040       goto beach;</span>
<span class="line-added">2041     }</span>
<span class="line-added">2042 </span>
2043     handle_current_async (dc);
<a name="32" id="anc32"></a><span class="line-modified">2044   } else {</span>
<span class="line-modified">2045     if (!ready)</span>
<span class="line-added">2046       handle_current_sync (dc);</span>
<span class="line-added">2047   }</span>
2048 
2049 beach:
2050   return res;
2051 }
2052 
2053 /* Serializing code */
2054 
2055 static GVariant *
2056 _serialize_common_stream_info (GstDiscovererStreamInfo * sinfo,
2057     GstDiscovererSerializeFlags flags)
2058 {
2059   GVariant *common;
<a name="33" id="anc33"></a><span class="line-added">2060   GVariant *nextv = NULL;</span>
2061   gchar *caps_str = NULL, *tags_str = NULL, *misc_str = NULL;
2062 
2063   if (sinfo-&gt;caps &amp;&amp; (flags &amp; GST_DISCOVERER_SERIALIZE_CAPS))
2064     caps_str = gst_caps_to_string (sinfo-&gt;caps);
2065 
2066   if (sinfo-&gt;tags &amp;&amp; (flags &amp; GST_DISCOVERER_SERIALIZE_TAGS))
2067     tags_str = gst_tag_list_to_string (sinfo-&gt;tags);
2068 
2069   if (sinfo-&gt;misc &amp;&amp; (flags &amp; GST_DISCOVERER_SERIALIZE_MISC))
2070     misc_str = gst_structure_to_string (sinfo-&gt;misc);
2071 
<a name="34" id="anc34"></a><span class="line-added">2072 </span>
<span class="line-added">2073   if (sinfo-&gt;next)</span>
<span class="line-added">2074     nextv = gst_discoverer_info_to_variant_recurse (sinfo-&gt;next, flags);</span>
<span class="line-added">2075   else</span>
<span class="line-added">2076     nextv = g_variant_new (&quot;()&quot;);</span>
<span class="line-added">2077 </span>
2078   common =
<a name="35" id="anc35"></a><span class="line-modified">2079       g_variant_new (&quot;(msmsmsmsv)&quot;, sinfo-&gt;stream_id, caps_str, tags_str,</span>
<span class="line-modified">2080       misc_str, nextv);</span>
2081 
2082   g_free (caps_str);
2083   g_free (tags_str);
2084   g_free (misc_str);
2085 
2086   return common;
2087 }
2088 
2089 static GVariant *
2090 _serialize_info (GstDiscovererInfo * info, GstDiscovererSerializeFlags flags)
2091 {
2092   gchar *tags_str = NULL;
2093   GVariant *ret;
2094 
2095   if (info-&gt;tags &amp;&amp; (flags &amp; GST_DISCOVERER_SERIALIZE_TAGS))
2096     tags_str = gst_tag_list_to_string (info-&gt;tags);
2097 
2098   ret =
2099       g_variant_new (&quot;(mstbmsb)&quot;, info-&gt;uri, info-&gt;duration, info-&gt;seekable,
2100       tags_str, info-&gt;live);
2101 
2102   g_free (tags_str);
2103 
2104   return ret;
2105 }
2106 
2107 static GVariant *
2108 _serialize_audio_stream_info (GstDiscovererAudioInfo * ainfo)
2109 {
2110   return g_variant_new (&quot;(uuuuumst)&quot;,
2111       ainfo-&gt;channels,
2112       ainfo-&gt;sample_rate,
2113       ainfo-&gt;bitrate, ainfo-&gt;max_bitrate, ainfo-&gt;depth, ainfo-&gt;language,
2114       ainfo-&gt;channel_mask);
2115 }
2116 
2117 static GVariant *
2118 _serialize_video_stream_info (GstDiscovererVideoInfo * vinfo)
2119 {
2120   return g_variant_new (&quot;(uuuuuuubuub)&quot;,
2121       vinfo-&gt;width,
2122       vinfo-&gt;height,
2123       vinfo-&gt;depth,
2124       vinfo-&gt;framerate_num,
2125       vinfo-&gt;framerate_denom,
2126       vinfo-&gt;par_num,
2127       vinfo-&gt;par_denom,
2128       vinfo-&gt;interlaced, vinfo-&gt;bitrate, vinfo-&gt;max_bitrate, vinfo-&gt;is_image);
2129 }
2130 
2131 static GVariant *
2132 _serialize_subtitle_stream_info (GstDiscovererSubtitleInfo * sinfo)
2133 {
2134   return g_variant_new (&quot;ms&quot;, sinfo-&gt;language);
2135 }
2136 
2137 static GVariant *
2138 gst_discoverer_info_to_variant_recurse (GstDiscovererStreamInfo * sinfo,
2139     GstDiscovererSerializeFlags flags)
2140 {
2141   GVariant *stream_variant = NULL;
2142   GVariant *common_stream_variant =
2143       _serialize_common_stream_info (sinfo, flags);
2144 
2145   if (GST_IS_DISCOVERER_CONTAINER_INFO (sinfo)) {
2146     GList *tmp;
2147     GList *streams =
2148         gst_discoverer_container_info_get_streams (GST_DISCOVERER_CONTAINER_INFO
2149         (sinfo));
2150 
2151     if (g_list_length (streams) &gt; 0) {
2152       GVariantBuilder children;
2153       GVariant *child_variant;
2154       g_variant_builder_init (&amp;children, G_VARIANT_TYPE_ARRAY);
2155 
2156       for (tmp = streams; tmp; tmp = tmp-&gt;next) {
2157         child_variant =
2158             gst_discoverer_info_to_variant_recurse (tmp-&gt;data, flags);
2159         g_variant_builder_add (&amp;children, &quot;v&quot;, child_variant);
2160       }
2161       stream_variant =
2162           g_variant_new (&quot;(yvav)&quot;, &#39;c&#39;, common_stream_variant, &amp;children);
2163     } else {
2164       stream_variant =
2165           g_variant_new (&quot;(yvav)&quot;, &#39;c&#39;, common_stream_variant, NULL);
2166     }
2167 
2168     gst_discoverer_stream_info_list_free (streams);
2169   } else if (GST_IS_DISCOVERER_AUDIO_INFO (sinfo)) {
2170     GVariant *audio_stream_info =
2171         _serialize_audio_stream_info (GST_DISCOVERER_AUDIO_INFO (sinfo));
2172     stream_variant =
2173         g_variant_new (&quot;(yvv)&quot;, &#39;a&#39;, common_stream_variant, audio_stream_info);
2174   } else if (GST_IS_DISCOVERER_VIDEO_INFO (sinfo)) {
2175     GVariant *video_stream_info =
2176         _serialize_video_stream_info (GST_DISCOVERER_VIDEO_INFO (sinfo));
2177     stream_variant =
2178         g_variant_new (&quot;(yvv)&quot;, &#39;v&#39;, common_stream_variant, video_stream_info);
2179   } else if (GST_IS_DISCOVERER_SUBTITLE_INFO (sinfo)) {
2180     GVariant *subtitle_stream_info =
2181         _serialize_subtitle_stream_info (GST_DISCOVERER_SUBTITLE_INFO (sinfo));
2182     stream_variant =
2183         g_variant_new (&quot;(yvv)&quot;, &#39;s&#39;, common_stream_variant,
2184         subtitle_stream_info);
<a name="36" id="anc36"></a><span class="line-added">2185   } else {</span>
<span class="line-added">2186     GVariant *nextv = NULL;</span>
<span class="line-added">2187     GstDiscovererStreamInfo *ninfo =</span>
<span class="line-added">2188         gst_discoverer_stream_info_get_next (sinfo);</span>
<span class="line-added">2189 </span>
<span class="line-added">2190     nextv = gst_discoverer_info_to_variant_recurse (ninfo, flags);</span>
<span class="line-added">2191 </span>
<span class="line-added">2192     stream_variant =</span>
<span class="line-added">2193         g_variant_new (&quot;(yvv)&quot;, &#39;n&#39;, common_stream_variant,</span>
<span class="line-added">2194         g_variant_new (&quot;v&quot;, nextv));</span>
2195   }
2196 
2197   return stream_variant;
2198 }
2199 
2200 /* Parsing code */
2201 
2202 #define GET_FROM_TUPLE(v, t, n, val) G_STMT_START{         \
2203   GVariant *child = g_variant_get_child_value (v, n); \
2204   *val = g_variant_get_##t(child); \
2205   g_variant_unref (child); \
2206 }G_STMT_END
2207 
2208 static const gchar *
2209 _maybe_get_string_from_tuple (GVariant * tuple, guint index)
2210 {
2211   const gchar *ret = NULL;
2212   GVariant *maybe;
2213   GET_FROM_TUPLE (tuple, maybe, index, &amp;maybe);
2214   if (maybe) {
2215     ret = g_variant_get_string (maybe, NULL);
2216     g_variant_unref (maybe);
2217   }
2218 
2219   return ret;
2220 }
2221 
2222 static void
2223 _parse_info (GstDiscovererInfo * info, GVariant * info_variant)
2224 {
2225   const gchar *str;
2226 
2227   str = _maybe_get_string_from_tuple (info_variant, 0);
2228   if (str)
2229     info-&gt;uri = g_strdup (str);
2230 
2231   GET_FROM_TUPLE (info_variant, uint64, 1, &amp;info-&gt;duration);
2232   GET_FROM_TUPLE (info_variant, boolean, 2, &amp;info-&gt;seekable);
2233 
2234   str = _maybe_get_string_from_tuple (info_variant, 3);
2235   if (str)
2236     info-&gt;tags = gst_tag_list_new_from_string (str);
2237 
2238   GET_FROM_TUPLE (info_variant, boolean, 4, &amp;info-&gt;live);
2239 }
2240 
2241 static void
<a name="37" id="anc37"></a><span class="line-modified">2242 _parse_common_stream_info (GstDiscovererStreamInfo * sinfo, GVariant * common,</span>
<span class="line-added">2243     GstDiscovererInfo * info)</span>
2244 {
2245   const gchar *str;
2246 
2247   str = _maybe_get_string_from_tuple (common, 0);
2248   if (str)
2249     sinfo-&gt;stream_id = g_strdup (str);
2250 
2251   str = _maybe_get_string_from_tuple (common, 1);
2252   if (str)
2253     sinfo-&gt;caps = gst_caps_from_string (str);
2254 
2255   str = _maybe_get_string_from_tuple (common, 2);
2256   if (str)
2257     sinfo-&gt;tags = gst_tag_list_new_from_string (str);
2258 
2259   str = _maybe_get_string_from_tuple (common, 3);
2260   if (str)
2261     sinfo-&gt;misc = gst_structure_new_from_string (str);
2262 
<a name="38" id="anc38"></a><span class="line-added">2263   if (g_variant_n_children (common) &gt; 4) {</span>
<span class="line-added">2264     GVariant *nextv;</span>
<span class="line-added">2265 </span>
<span class="line-added">2266     GET_FROM_TUPLE (common, variant, 4, &amp;nextv);</span>
<span class="line-added">2267     if (g_variant_n_children (nextv) &gt; 0) {</span>
<span class="line-added">2268       sinfo-&gt;next = _parse_discovery (nextv, info);</span>
<span class="line-added">2269     }</span>
<span class="line-added">2270   }</span>
<span class="line-added">2271 </span>
2272   g_variant_unref (common);
2273 }
2274 
2275 static void
2276 _parse_audio_stream_info (GstDiscovererAudioInfo * ainfo, GVariant * specific)
2277 {
2278   const gchar *str;
2279 
2280   GET_FROM_TUPLE (specific, uint32, 0, &amp;ainfo-&gt;channels);
2281   GET_FROM_TUPLE (specific, uint32, 1, &amp;ainfo-&gt;sample_rate);
2282   GET_FROM_TUPLE (specific, uint32, 2, &amp;ainfo-&gt;bitrate);
2283   GET_FROM_TUPLE (specific, uint32, 3, &amp;ainfo-&gt;max_bitrate);
2284   GET_FROM_TUPLE (specific, uint32, 4, &amp;ainfo-&gt;depth);
2285 
2286   str = _maybe_get_string_from_tuple (specific, 5);
2287 
2288   if (str)
2289     ainfo-&gt;language = g_strdup (str);
2290 
2291   GET_FROM_TUPLE (specific, uint64, 6, &amp;ainfo-&gt;channel_mask);
2292 
2293   g_variant_unref (specific);
2294 }
2295 
2296 static void
2297 _parse_video_stream_info (GstDiscovererVideoInfo * vinfo, GVariant * specific)
2298 {
2299   GET_FROM_TUPLE (specific, uint32, 0, &amp;vinfo-&gt;width);
2300   GET_FROM_TUPLE (specific, uint32, 1, &amp;vinfo-&gt;height);
2301   GET_FROM_TUPLE (specific, uint32, 2, &amp;vinfo-&gt;depth);
2302   GET_FROM_TUPLE (specific, uint32, 3, &amp;vinfo-&gt;framerate_num);
2303   GET_FROM_TUPLE (specific, uint32, 4, &amp;vinfo-&gt;framerate_denom);
2304   GET_FROM_TUPLE (specific, uint32, 5, &amp;vinfo-&gt;par_num);
2305   GET_FROM_TUPLE (specific, uint32, 6, &amp;vinfo-&gt;par_denom);
2306   GET_FROM_TUPLE (specific, boolean, 7, &amp;vinfo-&gt;interlaced);
2307   GET_FROM_TUPLE (specific, uint32, 8, &amp;vinfo-&gt;bitrate);
2308   GET_FROM_TUPLE (specific, uint32, 9, &amp;vinfo-&gt;max_bitrate);
2309   GET_FROM_TUPLE (specific, boolean, 10, &amp;vinfo-&gt;is_image);
2310 
2311   g_variant_unref (specific);
2312 }
2313 
2314 static void
2315 _parse_subtitle_stream_info (GstDiscovererSubtitleInfo * sinfo,
2316     GVariant * specific)
2317 {
2318   GVariant *maybe;
2319 
2320   maybe = g_variant_get_maybe (specific);
2321   if (maybe) {
2322     sinfo-&gt;language = g_strdup (g_variant_get_string (maybe, NULL));
2323     g_variant_unref (maybe);
2324   }
2325 
2326   g_variant_unref (specific);
2327 }
2328 
2329 static GstDiscovererStreamInfo *
2330 _parse_discovery (GVariant * variant, GstDiscovererInfo * info)
2331 {
2332   gchar type;
2333   GVariant *common = g_variant_get_child_value (variant, 1);
2334   GVariant *specific = g_variant_get_child_value (variant, 2);
2335   GstDiscovererStreamInfo *sinfo = NULL;
2336 
2337   GET_FROM_TUPLE (variant, byte, 0, &amp;type);
2338   switch (type) {
2339     case &#39;c&#39;:
2340       sinfo = g_object_new (GST_TYPE_DISCOVERER_CONTAINER_INFO, NULL);
2341       break;
2342     case &#39;a&#39;:
2343       sinfo = g_object_new (GST_TYPE_DISCOVERER_AUDIO_INFO, NULL);
2344       _parse_audio_stream_info (GST_DISCOVERER_AUDIO_INFO (sinfo),
2345           g_variant_get_child_value (specific, 0));
2346       break;
2347     case &#39;v&#39;:
2348       sinfo = g_object_new (GST_TYPE_DISCOVERER_VIDEO_INFO, NULL);
2349       _parse_video_stream_info (GST_DISCOVERER_VIDEO_INFO (sinfo),
2350           g_variant_get_child_value (specific, 0));
2351       break;
2352     case &#39;s&#39;:
2353       sinfo = g_object_new (GST_TYPE_DISCOVERER_SUBTITLE_INFO, NULL);
2354       _parse_subtitle_stream_info (GST_DISCOVERER_SUBTITLE_INFO (sinfo),
2355           g_variant_get_child_value (specific, 0));
2356       break;
<a name="39" id="anc39"></a><span class="line-added">2357     case &#39;n&#39;:</span>
<span class="line-added">2358       sinfo = g_object_new (GST_TYPE_DISCOVERER_STREAM_INFO, NULL);</span>
<span class="line-added">2359       break;</span>
2360     default:
2361       GST_WARNING (&quot;Unexpected discoverer info type %d&quot;, type);
2362       goto out;
2363   }
2364 
<a name="40" id="anc40"></a><span class="line-modified">2365   _parse_common_stream_info (sinfo, g_variant_get_child_value (common, 0),</span>
<span class="line-added">2366       info);</span>
2367 
<a name="41" id="anc41"></a><span class="line-modified">2368   if (!GST_IS_DISCOVERER_CONTAINER_INFO (sinfo))</span>
<span class="line-added">2369     info-&gt;stream_list = g_list_append (info-&gt;stream_list, sinfo);</span>
2370 
2371   if (!info-&gt;stream_info) {
2372     info-&gt;stream_info = sinfo;
2373   }
2374 
2375   if (GST_IS_DISCOVERER_CONTAINER_INFO (sinfo)) {
2376     GVariantIter iter;
2377     GVariant *child;
2378 
2379     GstDiscovererContainerInfo *cinfo = GST_DISCOVERER_CONTAINER_INFO (sinfo);
2380     g_variant_iter_init (&amp;iter, specific);
2381     while ((child = g_variant_iter_next_value (&amp;iter))) {
2382       GstDiscovererStreamInfo *child_info;
2383       child_info = _parse_discovery (g_variant_get_variant (child), info);
2384       if (child_info != NULL) {
2385         cinfo-&gt;streams =
2386             g_list_append (cinfo-&gt;streams,
2387             gst_discoverer_stream_info_ref (child_info));
2388       }
2389       g_variant_unref (child);
2390     }
2391   }
2392 
2393 out:
2394 
2395   g_variant_unref (common);
2396   g_variant_unref (specific);
2397   g_variant_unref (variant);
2398   return sinfo;
2399 }
2400 
2401 /**
2402  * gst_discoverer_start:
2403  * @discoverer: A #GstDiscoverer
2404  *
2405  * Allow asynchronous discovering of URIs to take place.
2406  * A #GMainLoop must be available for #GstDiscoverer to properly work in
2407  * asynchronous mode.
2408  */
2409 void
2410 gst_discoverer_start (GstDiscoverer * discoverer)
2411 {
2412   GSource *source;
2413   GMainContext *ctx = NULL;
2414 
2415   g_return_if_fail (GST_IS_DISCOVERER (discoverer));
2416 
2417   GST_DEBUG_OBJECT (discoverer, &quot;Starting...&quot;);
2418 
2419   if (discoverer-&gt;priv-&gt;async) {
2420     GST_DEBUG_OBJECT (discoverer, &quot;We were already started&quot;);
2421     return;
2422   }
2423 
2424   discoverer-&gt;priv-&gt;async = TRUE;
2425   discoverer-&gt;priv-&gt;running = TRUE;
2426 
2427   ctx = g_main_context_get_thread_default ();
2428 
2429   /* Connect to bus signals */
2430   if (ctx == NULL)
2431     ctx = g_main_context_default ();
2432 
2433   source = gst_bus_create_watch (discoverer-&gt;priv-&gt;bus);
2434   g_source_set_callback (source, (GSourceFunc) gst_bus_async_signal_func,
2435       NULL, NULL);
<a name="42" id="anc42"></a><span class="line-modified">2436   g_source_attach (source, ctx);</span>
<span class="line-modified">2437   discoverer-&gt;priv-&gt;bus_source = source;</span>
2438   discoverer-&gt;priv-&gt;ctx = g_main_context_ref (ctx);
2439 
2440   start_discovering (discoverer);
2441   GST_DEBUG_OBJECT (discoverer, &quot;Started&quot;);
2442 }
2443 
2444 /**
2445  * gst_discoverer_stop:
2446  * @discoverer: A #GstDiscoverer
2447  *
2448  * Stop the discovery of any pending URIs and clears the list of
2449  * pending URIS (if any).
2450  */
2451 void
2452 gst_discoverer_stop (GstDiscoverer * discoverer)
2453 {
2454   g_return_if_fail (GST_IS_DISCOVERER (discoverer));
2455 
2456   GST_DEBUG_OBJECT (discoverer, &quot;Stopping...&quot;);
2457 
2458   if (!discoverer-&gt;priv-&gt;async) {
2459     GST_DEBUG_OBJECT (discoverer,
2460         &quot;We were already stopped, or running synchronously&quot;);
2461     return;
2462   }
2463 
2464   DISCO_LOCK (discoverer);
2465   if (discoverer-&gt;priv-&gt;processing) {
2466     /* We prevent any further processing by setting the bus to
2467      * flushing and setting the pipeline to READY.
2468      * _reset() will take care of the rest of the cleanup */
2469     if (discoverer-&gt;priv-&gt;bus)
2470       gst_bus_set_flushing (discoverer-&gt;priv-&gt;bus, TRUE);
2471     if (discoverer-&gt;priv-&gt;pipeline)
2472       gst_element_set_state ((GstElement *) discoverer-&gt;priv-&gt;pipeline,
2473           GST_STATE_READY);
2474   }
2475   discoverer-&gt;priv-&gt;running = FALSE;
2476   DISCO_UNLOCK (discoverer);
2477 
2478   /* Remove timeout handler */
<a name="43" id="anc43"></a><span class="line-modified">2479   if (discoverer-&gt;priv-&gt;timeout_source) {</span>
<span class="line-modified">2480     g_source_destroy (discoverer-&gt;priv-&gt;timeout_source);</span>
<span class="line-modified">2481     g_source_unref (discoverer-&gt;priv-&gt;timeout_source);</span>
<span class="line-added">2482     discoverer-&gt;priv-&gt;timeout_source = NULL;</span>
2483   }
2484   /* Remove signal watch */
<a name="44" id="anc44"></a><span class="line-modified">2485   if (discoverer-&gt;priv-&gt;bus_source) {</span>
<span class="line-modified">2486     g_source_destroy (discoverer-&gt;priv-&gt;bus_source);</span>
<span class="line-modified">2487     g_source_unref (discoverer-&gt;priv-&gt;bus_source);</span>
<span class="line-added">2488     discoverer-&gt;priv-&gt;bus_source = NULL;</span>
2489   }
2490   /* Unref main context */
2491   if (discoverer-&gt;priv-&gt;ctx) {
2492     g_main_context_unref (discoverer-&gt;priv-&gt;ctx);
2493     discoverer-&gt;priv-&gt;ctx = NULL;
2494   }
2495   discoverer_reset (discoverer);
2496 
2497   discoverer-&gt;priv-&gt;async = FALSE;
2498 
2499   GST_DEBUG_OBJECT (discoverer, &quot;Stopped&quot;);
2500 }
2501 
2502 /**
2503  * gst_discoverer_discover_uri_async:
2504  * @discoverer: A #GstDiscoverer
2505  * @uri: the URI to add.
2506  *
2507  * Appends the given @uri to the list of URIs to discoverer. The actual
2508  * discovery of the @uri will only take place if gst_discoverer_start() has
2509  * been called.
2510  *
2511  * A copy of @uri will be made internally, so the caller can safely g_free()
2512  * afterwards.
2513  *
2514  * Returns: %TRUE if the @uri was successfully appended to the list of pending
2515  * uris, else %FALSE
2516  */
2517 gboolean
2518 gst_discoverer_discover_uri_async (GstDiscoverer * discoverer,
2519     const gchar * uri)
2520 {
2521   gboolean can_run;
2522 
2523   g_return_val_if_fail (GST_IS_DISCOVERER (discoverer), FALSE);
2524 
2525   GST_DEBUG_OBJECT (discoverer, &quot;uri : %s&quot;, uri);
2526 
2527   DISCO_LOCK (discoverer);
2528   can_run = (discoverer-&gt;priv-&gt;pending_uris == NULL);
2529   discoverer-&gt;priv-&gt;pending_uris =
2530       g_list_append (discoverer-&gt;priv-&gt;pending_uris, g_strdup (uri));
2531   DISCO_UNLOCK (discoverer);
2532 
2533   if (can_run)
2534     start_discovering (discoverer);
2535 
2536   return TRUE;
2537 }
2538 
2539 
2540 /* Synchronous mode */
2541 /**
2542  * gst_discoverer_discover_uri:
2543  * @discoverer: A #GstDiscoverer
2544  * @uri: The URI to run on.
2545  * @err: (out) (allow-none): If an error occurred, this field will be filled in.
2546  *
2547  * Synchronously discovers the given @uri.
2548  *
2549  * A copy of @uri will be made internally, so the caller can safely g_free()
2550  * afterwards.
2551  *
2552  * Returns: (transfer full): the result of the scanning. Can be %NULL if an
2553  * error occurred.
2554  */
2555 GstDiscovererInfo *
2556 gst_discoverer_discover_uri (GstDiscoverer * discoverer, const gchar * uri,
2557     GError ** err)
2558 {
2559   GstDiscovererResult res = 0;
2560   GstDiscovererInfo *info;
2561 
2562   g_return_val_if_fail (GST_IS_DISCOVERER (discoverer), NULL);
2563   g_return_val_if_fail (uri, NULL);
2564 
2565   GST_DEBUG_OBJECT (discoverer, &quot;uri:%s&quot;, uri);
2566 
2567   DISCO_LOCK (discoverer);
2568   if (G_UNLIKELY (discoverer-&gt;priv-&gt;current_info)) {
2569     DISCO_UNLOCK (discoverer);
2570     GST_WARNING_OBJECT (discoverer, &quot;Already handling a uri&quot;);
2571     if (err)
2572       *err = g_error_new (GST_CORE_ERROR, GST_CORE_ERROR_FAILED,
2573           &quot;Already handling a uri&quot;);
2574     return NULL;
2575   }
2576 
2577   discoverer-&gt;priv-&gt;pending_uris =
2578       g_list_append (discoverer-&gt;priv-&gt;pending_uris, g_strdup (uri));
2579   DISCO_UNLOCK (discoverer);
2580 
2581   res = start_discovering (discoverer);
2582   discoverer_collect (discoverer);
2583 
2584   /* Get results */
2585   if (err) {
2586     if (discoverer-&gt;priv-&gt;current_error)
2587       *err = g_error_copy (discoverer-&gt;priv-&gt;current_error);
2588     else
2589       *err = NULL;
2590   }
2591   if (res != GST_DISCOVERER_OK) {
2592     GST_DEBUG (&quot;Setting result to %d (was %d)&quot;, res,
2593         discoverer-&gt;priv-&gt;current_info-&gt;result);
2594     discoverer-&gt;priv-&gt;current_info-&gt;result = res;
2595   }
2596   info = discoverer-&gt;priv-&gt;current_info;
2597 
2598   discoverer_cleanup (discoverer);
2599 
2600   return info;
2601 }
2602 
2603 /**
2604  * gst_discoverer_new:
2605  * @timeout: timeout per file, in nanoseconds. Allowed are values between
2606  *     one second (#GST_SECOND) and one hour (3600 * #GST_SECOND)
2607  * @err: a pointer to a #GError. can be %NULL
2608  *
2609  * Creates a new #GstDiscoverer with the provided timeout.
2610  *
2611  * Returns: (transfer full): The new #GstDiscoverer.
2612  * If an error occurred when creating the discoverer, @err will be set
2613  * accordingly and %NULL will be returned. If @err is set, the caller must
2614  * free it when no longer needed using g_error_free().
2615  */
2616 GstDiscoverer *
2617 gst_discoverer_new (GstClockTime timeout, GError ** err)
2618 {
2619   GstDiscoverer *res;
2620 
2621   res = g_object_new (GST_TYPE_DISCOVERER, &quot;timeout&quot;, timeout, NULL);
2622   if (res-&gt;priv-&gt;uridecodebin == NULL) {
2623     if (err)
2624       *err = g_error_new (GST_CORE_ERROR, GST_CORE_ERROR_MISSING_PLUGIN,
2625           &quot;Couldn&#39;t create &#39;uridecodebin&#39; element&quot;);
2626     gst_object_unref (res);
2627     res = NULL;
2628   }
2629   return res;
2630 }
2631 
2632 /**
2633  * gst_discoverer_info_to_variant:
2634  * @info: A #GstDiscovererInfo
2635  * @flags: A combination of #GstDiscovererSerializeFlags to specify
2636  * what needs to be serialized.
2637  *
2638  * Serializes @info to a #GVariant that can be parsed again
2639  * through gst_discoverer_info_from_variant().
2640  *
2641  * Note that any #GstToc (s) that might have been discovered will not be serialized
2642  * for now.
2643  *
2644  * Returns: (transfer full): A newly-allocated #GVariant representing @info.
2645  *
2646  * Since: 1.6
2647  */
2648 GVariant *
2649 gst_discoverer_info_to_variant (GstDiscovererInfo * info,
2650     GstDiscovererSerializeFlags flags)
2651 {
2652   /* FIXME: implement TOC support */
2653   GVariant *stream_variant;
<a name="45" id="anc45"></a><span class="line-modified">2654   GVariant *variant, *info_variant;</span>
2655   GstDiscovererStreamInfo *sinfo;
2656   GVariant *wrapper;
2657 
2658   g_return_val_if_fail (GST_IS_DISCOVERER_INFO (info), NULL);
2659   g_return_val_if_fail (gst_discoverer_info_get_result (info) ==
2660       GST_DISCOVERER_OK, NULL);
2661 
2662   sinfo = gst_discoverer_info_get_stream_info (info);
2663   stream_variant = gst_discoverer_info_to_variant_recurse (sinfo, flags);
<a name="46" id="anc46"></a><span class="line-modified">2664   info_variant = _serialize_info (info, flags);</span>
<span class="line-modified">2665 </span>
<span class="line-added">2666   variant = g_variant_new (&quot;(vv)&quot;, info_variant, stream_variant);</span>
2667 
2668   /* Returning a wrapper implies some small overhead, but simplifies
2669    * deserializing from bytes */
2670   wrapper = g_variant_new_variant (variant);
2671 
2672   gst_discoverer_stream_info_unref (sinfo);
2673   return wrapper;
2674 }
2675 
2676 /**
2677  * gst_discoverer_info_from_variant:
2678  * @variant: A #GVariant to deserialize into a #GstDiscovererInfo.
2679  *
2680  * Parses a #GVariant as produced by gst_discoverer_info_to_variant()
2681  * back to a #GstDiscovererInfo.
2682  *
2683  * Returns: (transfer full): A newly-allocated #GstDiscovererInfo.
2684  *
2685  * Since: 1.6
2686  */
2687 GstDiscovererInfo *
2688 gst_discoverer_info_from_variant (GVariant * variant)
2689 {
2690   GstDiscovererInfo *info = g_object_new (GST_TYPE_DISCOVERER_INFO, NULL);
2691   GVariant *info_variant = g_variant_get_variant (variant);
2692   GVariant *info_specific_variant;
2693   GVariant *wrapped;
2694 
2695   GET_FROM_TUPLE (info_variant, variant, 0, &amp;info_specific_variant);
2696   GET_FROM_TUPLE (info_variant, variant, 1, &amp;wrapped);
2697 
2698   _parse_info (info, info_specific_variant);
2699   _parse_discovery (wrapped, info);
2700   g_variant_unref (info_specific_variant);
2701   g_variant_unref (info_variant);
2702 
2703   return info;
2704 }
<a name="47" id="anc47"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="47" type="hidden" />
</body>
</html>