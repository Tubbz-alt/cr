<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gchecksum.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* gchecksum.h - data hashing functions
   2  *
   3  * Copyright (C) 2007  Emmanuele Bassi  &lt;ebassi@gnome.org&gt;
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public License
  16  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  */
  18 
  19 #include &quot;config.h&quot;
  20 
  21 #include &lt;string.h&gt;
  22 
  23 #include &quot;gchecksum.h&quot;
  24 
  25 #include &quot;gslice.h&quot;
  26 #include &quot;gmem.h&quot;
  27 #include &quot;gstrfuncs.h&quot;
  28 #include &quot;gtestutils.h&quot;
  29 #include &quot;gtypes.h&quot;
  30 #include &quot;glibintl.h&quot;
  31 
  32 
  33 /**
  34  * SECTION:checksum
  35  * @title: Data Checksums
  36  * @short_description: computes the checksum for data
  37  *
  38  * GLib provides a generic API for computing checksums (or &quot;digests&quot;)
  39  * for a sequence of arbitrary bytes, using various hashing algorithms
  40  * like MD5, SHA-1 and SHA-256. Checksums are commonly used in various
  41  * environments and specifications.
  42  *
  43  * GLib supports incremental checksums using the GChecksum data
  44  * structure, by calling g_checksum_update() as long as there&#39;s data
  45  * available and then using g_checksum_get_string() or
  46  * g_checksum_get_digest() to compute the checksum and return it either
  47  * as a string in hexadecimal form, or as a raw sequence of bytes. To
  48  * compute the checksum for binary blobs and NUL-terminated strings in
  49  * one go, use the convenience functions g_compute_checksum_for_data()
  50  * and g_compute_checksum_for_string(), respectively.
  51  *
  52  * Support for checksums has been added in GLib 2.16
  53  **/
  54 
  55 #define IS_VALID_TYPE(type)     ((type) &gt;= G_CHECKSUM_MD5 &amp;&amp; (type) &lt;= G_CHECKSUM_SHA384)
  56 
  57 /* The fact that these are lower case characters is part of the ABI */
  58 static const gchar hex_digits[] = &quot;0123456789abcdef&quot;;
  59 
  60 #define MD5_DATASIZE    64
  61 #define MD5_DIGEST_LEN  16
  62 
  63 typedef struct
  64 {
  65   guint32 buf[4];
  66   guint32 bits[2];
  67 
  68   union {
  69     guchar data[MD5_DATASIZE];
  70     guint32 data32[MD5_DATASIZE / 4];
  71   } u;
  72 
  73   guchar digest[MD5_DIGEST_LEN];
  74 } Md5sum;
  75 
  76 #define SHA1_DATASIZE   64
  77 #define SHA1_DIGEST_LEN 20
  78 
  79 typedef struct
  80 {
  81   guint32 buf[5];
  82   guint32 bits[2];
  83 
  84   /* we pack 64 unsigned chars into 16 32-bit unsigned integers */
  85   guint32 data[16];
  86 
  87   guchar digest[SHA1_DIGEST_LEN];
  88 } Sha1sum;
  89 
  90 #define SHA256_DATASIZE         64
  91 #define SHA256_DIGEST_LEN       32
  92 
  93 typedef struct
  94 {
  95   guint32 buf[8];
  96   guint32 bits[2];
  97 
  98   guint8 data[SHA256_DATASIZE];
  99 
 100   guchar digest[SHA256_DIGEST_LEN];
 101 } Sha256sum;
 102 
 103 /* SHA2 is common thing for SHA-384, SHA-512, SHA-512/224 and SHA-512/256 */
 104 #define SHA2_BLOCK_LEN         128 /* 1024 bits message block */
 105 #define SHA384_DIGEST_LEN       48
 106 #define SHA512_DIGEST_LEN       64
 107 
 108 typedef struct
 109 {
 110   guint64 H[8];
 111 
 112   guint8 block[SHA2_BLOCK_LEN];
 113   guint8 block_len;
 114 
 115   guint64 data_len[2];
 116 
 117   guchar digest[SHA512_DIGEST_LEN];
 118 } Sha512sum;
 119 
 120 struct _GChecksum
 121 {
 122   GChecksumType type;
 123 
 124   gchar *digest_str;
 125 
 126   union {
 127     Md5sum md5;
 128     Sha1sum sha1;
 129     Sha256sum sha256;
 130     Sha512sum sha512;
 131   } sum;
 132 };
 133 
 134 /* we need different byte swapping functions because MD5 expects buffers
 135  * to be little-endian, while SHA1 and SHA256 expect them in big-endian
 136  * form.
 137  */
 138 
 139 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
 140 #define md5_byte_reverse(buffer,length)
 141 #else
 142 /* assume that the passed buffer is integer aligned */
 143 static inline void
 144 md5_byte_reverse (guchar *buffer,
 145                   gulong  length)
 146 {
 147   guint32 bit;
 148 
 149   do
 150     {
 151       bit = (guint32) ((unsigned) buffer[3] &lt;&lt; 8 | buffer[2]) &lt;&lt; 16 |
 152                       ((unsigned) buffer[1] &lt;&lt; 8 | buffer[0]);
 153       * (guint32 *) buffer = bit;
 154       buffer += 4;
 155     }
 156   while (--length);
 157 }
 158 #endif /* G_BYTE_ORDER == G_LITTLE_ENDIAN */
 159 
 160 #if G_BYTE_ORDER == G_BIG_ENDIAN
 161 #define sha_byte_reverse(buffer,length)
 162 #else
 163 static inline void
 164 sha_byte_reverse (guint32 *buffer,
 165                   gint     length)
 166 {
 167   length /= sizeof (guint32);
 168   while (length--)
 169     {
 170       *buffer = GUINT32_SWAP_LE_BE (*buffer);
 171       ++buffer;
 172     }
 173 }
 174 #endif /* G_BYTE_ORDER == G_BIG_ENDIAN */
 175 
 176 static gchar *
 177 digest_to_string (guint8 *digest,
 178                   gsize   digest_len)
 179 {
 180   gint len = digest_len * 2;
 181   gint i;
 182   gchar *retval;
 183 
 184   retval = g_new (gchar, len + 1);
 185 
 186   for (i = 0; i &lt; digest_len; i++)
 187     {
 188       guint8 byte = digest[i];
 189 
 190       retval[2 * i] = hex_digits[byte &gt;&gt; 4];
 191       retval[2 * i + 1] = hex_digits[byte &amp; 0xf];
 192     }
 193 
 194   retval[len] = 0;
 195 
 196   return retval;
 197 }
 198 
 199 /*
 200  * MD5 Checksum
 201  */
 202 
 203 /* This MD5 digest computation is based on the equivalent code
 204  * written by Colin Plumb. It came with this notice:
 205  *
 206  * This code implements the MD5 message-digest algorithm.
 207  * The algorithm is due to Ron Rivest.  This code was
 208  * written by Colin Plumb in 1993, no copyright is claimed.
 209  * This code is in the public domain; do with it what you wish.
 210  *
 211  * Equivalent code is available from RSA Data Security, Inc.
 212  * This code has been tested against that, and is equivalent,
 213  * except that you don&#39;t need to include two pages of legalese
 214  * with every copy.
 215  */
 216 
 217 static void
 218 md5_sum_init (Md5sum *md5)
 219 {
 220   /* arbitrary constants */
 221   md5-&gt;buf[0] = 0x67452301;
 222   md5-&gt;buf[1] = 0xefcdab89;
 223   md5-&gt;buf[2] = 0x98badcfe;
 224   md5-&gt;buf[3] = 0x10325476;
 225 
 226   md5-&gt;bits[0] = md5-&gt;bits[1] = 0;
 227 }
 228 
 229 /*
 230  * The core of the MD5 algorithm, this alters an existing MD5 hash to
 231  * reflect the addition of 16 longwords of new data.  md5_sum_update()
 232  * blocks the data and converts bytes into longwords for this routine.
 233  */
 234 static void
 235 md5_transform (guint32       buf[4],
 236                guint32 const in[16])
 237 {
 238   guint32 a, b, c, d;
 239 
 240 /* The four core functions - F1 is optimized somewhat */
 241 #define F1(x, y, z)     (z ^ (x &amp; (y ^ z)))
 242 #define F2(x, y, z)     F1 (z, x, y)
 243 #define F3(x, y, z)     (x ^ y ^ z)
 244 #define F4(x, y, z)     (y ^ (x | ~z))
 245 
 246 /* This is the central step in the MD5 algorithm. */
 247 #define md5_step(f, w, x, y, z, data, s) \
 248         ( w += f (x, y, z) + data,  w = w &lt;&lt; s | w &gt;&gt; (32 - s),  w += x )
 249 
 250   a = buf[0];
 251   b = buf[1];
 252   c = buf[2];
 253   d = buf[3];
 254 
 255   md5_step (F1, a, b, c, d, in[0]  + 0xd76aa478,  7);
 256   md5_step (F1, d, a, b, c, in[1]  + 0xe8c7b756, 12);
 257   md5_step (F1, c, d, a, b, in[2]  + 0x242070db, 17);
 258   md5_step (F1, b, c, d, a, in[3]  + 0xc1bdceee, 22);
 259   md5_step (F1, a, b, c, d, in[4]  + 0xf57c0faf,  7);
 260   md5_step (F1, d, a, b, c, in[5]  + 0x4787c62a, 12);
 261   md5_step (F1, c, d, a, b, in[6]  + 0xa8304613, 17);
 262   md5_step (F1, b, c, d, a, in[7]  + 0xfd469501, 22);
 263   md5_step (F1, a, b, c, d, in[8]  + 0x698098d8,  7);
 264   md5_step (F1, d, a, b, c, in[9]  + 0x8b44f7af, 12);
 265   md5_step (F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
 266   md5_step (F1, b, c, d, a, in[11] + 0x895cd7be, 22);
 267   md5_step (F1, a, b, c, d, in[12] + 0x6b901122,  7);
 268   md5_step (F1, d, a, b, c, in[13] + 0xfd987193, 12);
 269   md5_step (F1, c, d, a, b, in[14] + 0xa679438e, 17);
 270   md5_step (F1, b, c, d, a, in[15] + 0x49b40821, 22);
 271 
 272   md5_step (F2, a, b, c, d, in[1]  + 0xf61e2562,  5);
 273   md5_step (F2, d, a, b, c, in[6]  + 0xc040b340,  9);
 274   md5_step (F2, c, d, a, b, in[11] + 0x265e5a51, 14);
 275   md5_step (F2, b, c, d, a, in[0]  + 0xe9b6c7aa, 20);
 276   md5_step (F2, a, b, c, d, in[5]  + 0xd62f105d,  5);
 277   md5_step (F2, d, a, b, c, in[10] + 0x02441453,  9);
 278   md5_step (F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
 279   md5_step (F2, b, c, d, a, in[4]  + 0xe7d3fbc8, 20);
 280   md5_step (F2, a, b, c, d, in[9]  + 0x21e1cde6,  5);
 281   md5_step (F2, d, a, b, c, in[14] + 0xc33707d6,  9);
 282   md5_step (F2, c, d, a, b, in[3]  + 0xf4d50d87, 14);
 283   md5_step (F2, b, c, d, a, in[8]  + 0x455a14ed, 20);
 284   md5_step (F2, a, b, c, d, in[13] + 0xa9e3e905,  5);
 285   md5_step (F2, d, a, b, c, in[2]  + 0xfcefa3f8,  9);
 286   md5_step (F2, c, d, a, b, in[7]  + 0x676f02d9, 14);
 287   md5_step (F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);
 288 
 289   md5_step (F3, a, b, c, d, in[5]  + 0xfffa3942,  4);
 290   md5_step (F3, d, a, b, c, in[8]  + 0x8771f681, 11);
 291   md5_step (F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
 292   md5_step (F3, b, c, d, a, in[14] + 0xfde5380c, 23);
 293   md5_step (F3, a, b, c, d, in[1]  + 0xa4beea44,  4);
 294   md5_step (F3, d, a, b, c, in[4]  + 0x4bdecfa9, 11);
 295   md5_step (F3, c, d, a, b, in[7]  + 0xf6bb4b60, 16);
 296   md5_step (F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
 297   md5_step (F3, a, b, c, d, in[13] + 0x289b7ec6,  4);
 298   md5_step (F3, d, a, b, c, in[0]  + 0xeaa127fa, 11);
 299   md5_step (F3, c, d, a, b, in[3]  + 0xd4ef3085, 16);
 300   md5_step (F3, b, c, d, a, in[6]  + 0x04881d05, 23);
 301   md5_step (F3, a, b, c, d, in[9]  + 0xd9d4d039,  4);
 302   md5_step (F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
 303   md5_step (F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
 304   md5_step (F3, b, c, d, a, in[2]  + 0xc4ac5665, 23);
 305 
 306   md5_step (F4, a, b, c, d, in[0]  + 0xf4292244,  6);
 307   md5_step (F4, d, a, b, c, in[7]  + 0x432aff97, 10);
 308   md5_step (F4, c, d, a, b, in[14] + 0xab9423a7, 15);
 309   md5_step (F4, b, c, d, a, in[5]  + 0xfc93a039, 21);
 310   md5_step (F4, a, b, c, d, in[12] + 0x655b59c3,  6);
 311   md5_step (F4, d, a, b, c, in[3]  + 0x8f0ccc92, 10);
 312   md5_step (F4, c, d, a, b, in[10] + 0xffeff47d, 15);
 313   md5_step (F4, b, c, d, a, in[1]  + 0x85845dd1, 21);
 314   md5_step (F4, a, b, c, d, in[8]  + 0x6fa87e4f,  6);
 315   md5_step (F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
 316   md5_step (F4, c, d, a, b, in[6]  + 0xa3014314, 15);
 317   md5_step (F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
 318   md5_step (F4, a, b, c, d, in[4]  + 0xf7537e82,  6);
 319   md5_step (F4, d, a, b, c, in[11] + 0xbd3af235, 10);
 320   md5_step (F4, c, d, a, b, in[2]  + 0x2ad7d2bb, 15);
 321   md5_step (F4, b, c, d, a, in[9]  + 0xeb86d391, 21);
 322 
 323   buf[0] += a;
 324   buf[1] += b;
 325   buf[2] += c;
 326   buf[3] += d;
 327 
 328 #undef F1
 329 #undef F2
 330 #undef F3
 331 #undef F4
 332 #undef md5_step
 333 }
 334 
 335 static void
 336 md5_sum_update (Md5sum       *md5,
 337                 const guchar *data,
 338                 gsize         length)
 339 {
 340   guint32 bit;
 341 
 342   bit = md5-&gt;bits[0];
 343   md5-&gt;bits[0] = bit + ((guint32) length &lt;&lt; 3);
 344 
 345   /* carry from low to high */
 346   if (md5-&gt;bits[0] &lt; bit)
 347     md5-&gt;bits[1] += 1;
 348 
 349   md5-&gt;bits[1] += length &gt;&gt; 29;
 350 
 351   /* bytes already in Md5sum-&gt;u.data */
 352   bit = (bit &gt;&gt; 3) &amp; 0x3f;
 353 
 354   /* handle any leading odd-sized chunks */
 355   if (bit)
 356     {
 357       guchar *p = md5-&gt;u.data + bit;
 358 
 359       bit = MD5_DATASIZE - bit;
 360       if (length &lt; bit)
 361         {
 362           memcpy (p, data, length);
 363           return;
 364         }
 365 
 366       memcpy (p, data, bit);
 367 
 368       md5_byte_reverse (md5-&gt;u.data, 16);
 369       md5_transform (md5-&gt;buf, md5-&gt;u.data32);
 370 
 371       data += bit;
 372       length -= bit;
 373     }
 374 
 375   /* process data in 64-byte chunks */
 376   while (length &gt;= MD5_DATASIZE)
 377     {
 378       memcpy (md5-&gt;u.data, data, MD5_DATASIZE);
 379 
 380       md5_byte_reverse (md5-&gt;u.data, 16);
 381       md5_transform (md5-&gt;buf, md5-&gt;u.data32);
 382 
 383       data += MD5_DATASIZE;
 384       length -= MD5_DATASIZE;
 385     }
 386 
 387   /* handle any remaining bytes of data */
 388   memcpy (md5-&gt;u.data, data, length);
 389 }
 390 
 391 /* closes a checksum */
 392 static void
 393 md5_sum_close (Md5sum *md5)
 394 {
 395   guint count;
 396   guchar *p;
 397 
 398   /* Compute number of bytes mod 64 */
 399   count = (md5-&gt;bits[0] &gt;&gt; 3) &amp; 0x3F;
 400 
 401   /* Set the first char of padding to 0x80.
 402    * This is safe since there is always at least one byte free
 403    */
 404   p = md5-&gt;u.data + count;
 405   *p++ = 0x80;
 406 
 407   /* Bytes of padding needed to make 64 bytes */
 408   count = MD5_DATASIZE - 1 - count;
 409 
 410   /* Pad out to 56 mod 64 */
 411   if (count &lt; 8)
 412     {
 413       /* Two lots of padding:  Pad the first block to 64 bytes */
 414       memset (p, 0, count);
 415 
 416       md5_byte_reverse (md5-&gt;u.data, 16);
 417       md5_transform (md5-&gt;buf, md5-&gt;u.data32);
 418 
 419       /* Now fill the next block with 56 bytes */
 420       memset (md5-&gt;u.data, 0, MD5_DATASIZE - 8);
 421     }
 422   else
 423     {
 424       /* Pad block to 56 bytes */
 425       memset (p, 0, count - 8);
 426     }
 427 
 428   md5_byte_reverse (md5-&gt;u.data, 14);
 429 
 430   /* Append length in bits and transform */
 431   md5-&gt;u.data32[14] = md5-&gt;bits[0];
 432   md5-&gt;u.data32[15] = md5-&gt;bits[1];
 433 
 434   md5_transform (md5-&gt;buf, md5-&gt;u.data32);
 435   md5_byte_reverse ((guchar *) md5-&gt;buf, 4);
 436 
 437   memcpy (md5-&gt;digest, md5-&gt;buf, 16);
 438 
 439   /* Reset buffers in case they contain sensitive data */
 440   memset (md5-&gt;buf, 0, sizeof (md5-&gt;buf));
 441   memset (md5-&gt;u.data, 0, sizeof (md5-&gt;u.data));
 442 }
 443 
 444 static gchar *
 445 md5_sum_to_string (Md5sum *md5)
 446 {
 447   return digest_to_string (md5-&gt;digest, MD5_DIGEST_LEN);
 448 }
 449 
 450 static void
 451 md5_sum_digest (Md5sum *md5,
 452                 guint8 *digest)
 453 {
 454   gint i;
 455 
 456   for (i = 0; i &lt; MD5_DIGEST_LEN; i++)
 457     digest[i] = md5-&gt;digest[i];
 458 }
 459 
 460 /*
 461  * SHA-1 Checksum
 462  */
 463 
 464 /* The following implementation comes from D-Bus dbus-sha.c. I&#39;ve changed
 465  * it to use GLib types and to work more like the MD5 implementation above.
 466  * I left the comments to have an history of this code.
 467  *      -- Emmanuele Bassi, ebassi@gnome.org
 468  */
 469 
 470 /* The following comments have the history of where this code
 471  * comes from. I actually copied it from GNet in GNOME CVS.
 472  * - hp@redhat.com
 473  */
 474 
 475 /*
 476  *  sha.h : Implementation of the Secure Hash Algorithm
 477  *
 478  * Part of the Python Cryptography Toolkit, version 1.0.0
 479  *
 480  * Copyright (C) 1995, A.M. Kuchling
 481  *
 482  * Distribute and use freely; there are no restrictions on further
 483  * dissemination and usage except those imposed by the laws of your
 484  * country of residence.
 485  *
 486  */
 487 
 488 /* SHA: NIST&#39;s Secure Hash Algorithm */
 489 
 490 /* Based on SHA code originally posted to sci.crypt by Peter Gutmann
 491    in message &lt;30ajo5$oe8@ccu2.auckland.ac.nz&gt;.
 492    Modified to test for endianness on creation of SHA objects by AMK.
 493    Also, the original specification of SHA was found to have a weakness
 494    by NSA/NIST.  This code implements the fixed version of SHA.
 495 */
 496 
 497 /* Here&#39;s the first paragraph of Peter Gutmann&#39;s posting:
 498 
 499 The following is my SHA (FIPS 180) code updated to allow use of the &quot;fixed&quot;
 500 SHA, thanks to Jim Gillogly and an anonymous contributor for the information on
 501 what&#39;s changed in the new version.  The fix is a simple change which involves
 502 adding a single rotate in the initial expansion function.  It is unknown
 503 whether this is an optimal solution to the problem which was discovered in the
 504 SHA or whether it&#39;s simply a bandaid which fixes the problem with a minimum of
 505 effort (for example the reengineering of a great many Capstone chips).
 506 */
 507 
 508 static void
 509 sha1_sum_init (Sha1sum *sha1)
 510 {
 511   /* initialize constants */
 512   sha1-&gt;buf[0] = 0x67452301L;
 513   sha1-&gt;buf[1] = 0xEFCDAB89L;
 514   sha1-&gt;buf[2] = 0x98BADCFEL;
 515   sha1-&gt;buf[3] = 0x10325476L;
 516   sha1-&gt;buf[4] = 0xC3D2E1F0L;
 517 
 518   /* initialize bits */
 519   sha1-&gt;bits[0] = sha1-&gt;bits[1] = 0;
 520 }
 521 
 522 /* The SHA f()-functions. */
 523 
 524 #define f1(x,y,z)       (z ^ (x &amp; (y ^ z)))             /* Rounds  0-19 */
 525 #define f2(x,y,z)       (x ^ y ^ z)                     /* Rounds 20-39 */
 526 #define f3(x,y,z)       (( x &amp; y) | (z &amp; (x | y)))      /* Rounds 40-59 */
 527 #define f4(x,y,z)       (x ^ y ^ z)                     /* Rounds 60-79 */
 528 
 529 /* The SHA Mysterious Constants */
 530 #define K1  0x5A827999L                                 /* Rounds  0-19 */
 531 #define K2  0x6ED9EBA1L                                 /* Rounds 20-39 */
 532 #define K3  0x8F1BBCDCL                                 /* Rounds 40-59 */
 533 #define K4  0xCA62C1D6L                                 /* Rounds 60-79 */
 534 
 535 /* 32-bit rotate left - kludged with shifts */
 536 #define ROTL(n,X) (((X) &lt;&lt; n ) | ((X) &gt;&gt; (32 - n)))
 537 
 538 /* The initial expanding function.  The hash function is defined over an
 539    80-word expanded input array W, where the first 16 are copies of the input
 540    data, and the remaining 64 are defined by
 541 
 542         W[ i ] = W[ i - 16 ] ^ W[ i - 14 ] ^ W[ i - 8 ] ^ W[ i - 3 ]
 543 
 544    This implementation generates these values on the fly in a circular
 545    buffer - thanks to Colin Plumb, colin@nyx10.cs.du.edu for this
 546    optimization.
 547 
 548    The updated SHA changes the expanding function by adding a rotate of 1
 549    bit.  Thanks to Jim Gillogly, jim@rand.org, and an anonymous contributor
 550    for this information */
 551 
 552 #define expand(W,i) (W[ i &amp; 15 ] = ROTL (1, (W[ i       &amp; 15] ^ \
 553                                              W[(i - 14) &amp; 15] ^ \
 554                                              W[(i -  8) &amp; 15] ^ \
 555                                              W[(i -  3) &amp; 15])))
 556 
 557 
 558 /* The prototype SHA sub-round.  The fundamental sub-round is:
 559 
 560         a&#39; = e + ROTL( 5, a ) + f( b, c, d ) + k + data;
 561         b&#39; = a;
 562         c&#39; = ROTL( 30, b );
 563         d&#39; = c;
 564         e&#39; = d;
 565 
 566    but this is implemented by unrolling the loop 5 times and renaming the
 567    variables ( e, a, b, c, d ) = ( a&#39;, b&#39;, c&#39;, d&#39;, e&#39; ) each iteration.
 568    This code is then replicated 20 times for each of the 4 functions, using
 569    the next 20 values from the W[] array each time */
 570 
 571 #define subRound(a, b, c, d, e, f, k, data) \
 572    (e += ROTL (5, a) + f(b, c, d) + k + data, b = ROTL (30, b))
 573 
 574 static void
 575 sha1_transform (guint32  buf[5],
 576                 guint32  in[16])
 577 {
 578   guint32 A, B, C, D, E;
 579 
 580   A = buf[0];
 581   B = buf[1];
 582   C = buf[2];
 583   D = buf[3];
 584   E = buf[4];
 585 
 586   /* Heavy mangling, in 4 sub-rounds of 20 iterations each. */
 587   subRound (A, B, C, D, E, f1, K1, in[0]);
 588   subRound (E, A, B, C, D, f1, K1, in[1]);
 589   subRound (D, E, A, B, C, f1, K1, in[2]);
 590   subRound (C, D, E, A, B, f1, K1, in[3]);
 591   subRound (B, C, D, E, A, f1, K1, in[4]);
 592   subRound (A, B, C, D, E, f1, K1, in[5]);
 593   subRound (E, A, B, C, D, f1, K1, in[6]);
 594   subRound (D, E, A, B, C, f1, K1, in[7]);
 595   subRound (C, D, E, A, B, f1, K1, in[8]);
 596   subRound (B, C, D, E, A, f1, K1, in[9]);
 597   subRound (A, B, C, D, E, f1, K1, in[10]);
 598   subRound (E, A, B, C, D, f1, K1, in[11]);
 599   subRound (D, E, A, B, C, f1, K1, in[12]);
 600   subRound (C, D, E, A, B, f1, K1, in[13]);
 601   subRound (B, C, D, E, A, f1, K1, in[14]);
 602   subRound (A, B, C, D, E, f1, K1, in[15]);
 603   subRound (E, A, B, C, D, f1, K1, expand (in, 16));
 604   subRound (D, E, A, B, C, f1, K1, expand (in, 17));
 605   subRound (C, D, E, A, B, f1, K1, expand (in, 18));
 606   subRound (B, C, D, E, A, f1, K1, expand (in, 19));
 607 
 608   subRound (A, B, C, D, E, f2, K2, expand (in, 20));
 609   subRound (E, A, B, C, D, f2, K2, expand (in, 21));
 610   subRound (D, E, A, B, C, f2, K2, expand (in, 22));
 611   subRound (C, D, E, A, B, f2, K2, expand (in, 23));
 612   subRound (B, C, D, E, A, f2, K2, expand (in, 24));
 613   subRound (A, B, C, D, E, f2, K2, expand (in, 25));
 614   subRound (E, A, B, C, D, f2, K2, expand (in, 26));
 615   subRound (D, E, A, B, C, f2, K2, expand (in, 27));
 616   subRound (C, D, E, A, B, f2, K2, expand (in, 28));
 617   subRound (B, C, D, E, A, f2, K2, expand (in, 29));
 618   subRound (A, B, C, D, E, f2, K2, expand (in, 30));
 619   subRound (E, A, B, C, D, f2, K2, expand (in, 31));
 620   subRound (D, E, A, B, C, f2, K2, expand (in, 32));
 621   subRound (C, D, E, A, B, f2, K2, expand (in, 33));
 622   subRound (B, C, D, E, A, f2, K2, expand (in, 34));
 623   subRound (A, B, C, D, E, f2, K2, expand (in, 35));
 624   subRound (E, A, B, C, D, f2, K2, expand (in, 36));
 625   subRound (D, E, A, B, C, f2, K2, expand (in, 37));
 626   subRound (C, D, E, A, B, f2, K2, expand (in, 38));
 627   subRound (B, C, D, E, A, f2, K2, expand (in, 39));
 628 
 629   subRound (A, B, C, D, E, f3, K3, expand (in, 40));
 630   subRound (E, A, B, C, D, f3, K3, expand (in, 41));
 631   subRound (D, E, A, B, C, f3, K3, expand (in, 42));
 632   subRound (C, D, E, A, B, f3, K3, expand (in, 43));
 633   subRound (B, C, D, E, A, f3, K3, expand (in, 44));
 634   subRound (A, B, C, D, E, f3, K3, expand (in, 45));
 635   subRound (E, A, B, C, D, f3, K3, expand (in, 46));
 636   subRound (D, E, A, B, C, f3, K3, expand (in, 47));
 637   subRound (C, D, E, A, B, f3, K3, expand (in, 48));
 638   subRound (B, C, D, E, A, f3, K3, expand (in, 49));
 639   subRound (A, B, C, D, E, f3, K3, expand (in, 50));
 640   subRound (E, A, B, C, D, f3, K3, expand (in, 51));
 641   subRound (D, E, A, B, C, f3, K3, expand (in, 52));
 642   subRound (C, D, E, A, B, f3, K3, expand (in, 53));
 643   subRound (B, C, D, E, A, f3, K3, expand (in, 54));
 644   subRound (A, B, C, D, E, f3, K3, expand (in, 55));
 645   subRound (E, A, B, C, D, f3, K3, expand (in, 56));
 646   subRound (D, E, A, B, C, f3, K3, expand (in, 57));
 647   subRound (C, D, E, A, B, f3, K3, expand (in, 58));
 648   subRound (B, C, D, E, A, f3, K3, expand (in, 59));
 649 
 650   subRound (A, B, C, D, E, f4, K4, expand (in, 60));
 651   subRound (E, A, B, C, D, f4, K4, expand (in, 61));
 652   subRound (D, E, A, B, C, f4, K4, expand (in, 62));
 653   subRound (C, D, E, A, B, f4, K4, expand (in, 63));
 654   subRound (B, C, D, E, A, f4, K4, expand (in, 64));
 655   subRound (A, B, C, D, E, f4, K4, expand (in, 65));
 656   subRound (E, A, B, C, D, f4, K4, expand (in, 66));
 657   subRound (D, E, A, B, C, f4, K4, expand (in, 67));
 658   subRound (C, D, E, A, B, f4, K4, expand (in, 68));
 659   subRound (B, C, D, E, A, f4, K4, expand (in, 69));
 660   subRound (A, B, C, D, E, f4, K4, expand (in, 70));
 661   subRound (E, A, B, C, D, f4, K4, expand (in, 71));
 662   subRound (D, E, A, B, C, f4, K4, expand (in, 72));
 663   subRound (C, D, E, A, B, f4, K4, expand (in, 73));
 664   subRound (B, C, D, E, A, f4, K4, expand (in, 74));
 665   subRound (A, B, C, D, E, f4, K4, expand (in, 75));
 666   subRound (E, A, B, C, D, f4, K4, expand (in, 76));
 667   subRound (D, E, A, B, C, f4, K4, expand (in, 77));
 668   subRound (C, D, E, A, B, f4, K4, expand (in, 78));
 669   subRound (B, C, D, E, A, f4, K4, expand (in, 79));
 670 
 671   /* Build message digest */
 672   buf[0] += A;
 673   buf[1] += B;
 674   buf[2] += C;
 675   buf[3] += D;
 676   buf[4] += E;
 677 }
 678 
 679 #undef K1
 680 #undef K2
 681 #undef K3
 682 #undef K4
 683 #undef f1
 684 #undef f2
 685 #undef f3
 686 #undef f4
 687 #undef ROTL
 688 #undef expand
 689 #undef subRound
 690 
 691 static void
 692 sha1_sum_update (Sha1sum      *sha1,
 693                  const guchar *buffer,
 694                  gsize         count)
 695 {
 696   guint32 tmp;
 697   guint dataCount;
 698 
 699   /* Update bitcount */
 700   tmp = sha1-&gt;bits[0];
 701   if ((sha1-&gt;bits[0] = tmp + ((guint32) count &lt;&lt; 3) ) &lt; tmp)
 702     sha1-&gt;bits[1] += 1;             /* Carry from low to high */
 703   sha1-&gt;bits[1] += count &gt;&gt; 29;
 704 
 705   /* Get count of bytes already in data */
 706   dataCount = (guint) (tmp &gt;&gt; 3) &amp; 0x3F;
 707 
 708   /* Handle any leading odd-sized chunks */
 709   if (dataCount)
 710     {
 711       guchar *p = (guchar *) sha1-&gt;data + dataCount;
 712 
 713       dataCount = SHA1_DATASIZE - dataCount;
 714       if (count &lt; dataCount)
 715         {
 716           memcpy (p, buffer, count);
 717           return;
 718         }
 719 
 720       memcpy (p, buffer, dataCount);
 721 
 722       sha_byte_reverse (sha1-&gt;data, SHA1_DATASIZE);
 723       sha1_transform (sha1-&gt;buf, sha1-&gt;data);
 724 
 725       buffer += dataCount;
 726       count -= dataCount;
 727     }
 728 
 729   /* Process data in SHA1_DATASIZE chunks */
 730   while (count &gt;= SHA1_DATASIZE)
 731     {
 732       memcpy (sha1-&gt;data, buffer, SHA1_DATASIZE);
 733 
 734       sha_byte_reverse (sha1-&gt;data, SHA1_DATASIZE);
 735       sha1_transform (sha1-&gt;buf, sha1-&gt;data);
 736 
 737       buffer += SHA1_DATASIZE;
 738       count -= SHA1_DATASIZE;
 739     }
 740 
 741   /* Handle any remaining bytes of data. */
 742   memcpy (sha1-&gt;data, buffer, count);
 743 }
 744 
 745 /* Final wrapup - pad to SHA_DATASIZE-byte boundary with the bit pattern
 746    1 0* (64-bit count of bits processed, MSB-first) */
 747 static void
 748 sha1_sum_close (Sha1sum *sha1)
 749 {
 750   gint count;
 751   guchar *data_p;
 752 
 753   /* Compute number of bytes mod 64 */
 754   count = (gint) ((sha1-&gt;bits[0] &gt;&gt; 3) &amp; 0x3f);
 755 
 756   /* Set the first char of padding to 0x80.  This is safe since there is
 757      always at least one byte free */
 758   data_p = (guchar *) sha1-&gt;data + count;
 759   *data_p++ = 0x80;
 760 
 761   /* Bytes of padding needed to make 64 bytes */
 762   count = SHA1_DATASIZE - 1 - count;
 763 
 764   /* Pad out to 56 mod 64 */
 765   if (count &lt; 8)
 766     {
 767       /* Two lots of padding:  Pad the first block to 64 bytes */
 768       memset (data_p, 0, count);
 769 
 770       sha_byte_reverse (sha1-&gt;data, SHA1_DATASIZE);
 771       sha1_transform (sha1-&gt;buf, sha1-&gt;data);
 772 
 773       /* Now fill the next block with 56 bytes */
 774       memset (sha1-&gt;data, 0, SHA1_DATASIZE - 8);
 775     }
 776   else
 777     {
 778       /* Pad block to 56 bytes */
 779       memset (data_p, 0, count - 8);
 780     }
 781 
 782   /* Append length in bits and transform */
 783   sha1-&gt;data[14] = sha1-&gt;bits[1];
 784   sha1-&gt;data[15] = sha1-&gt;bits[0];
 785 
 786   sha_byte_reverse (sha1-&gt;data, SHA1_DATASIZE - 8);
 787   sha1_transform (sha1-&gt;buf, sha1-&gt;data);
 788   sha_byte_reverse (sha1-&gt;buf, SHA1_DIGEST_LEN);
 789 
 790   memcpy (sha1-&gt;digest, sha1-&gt;buf, SHA1_DIGEST_LEN);
 791 
 792   /* Reset buffers in case they contain sensitive data */
 793   memset (sha1-&gt;buf, 0, sizeof (sha1-&gt;buf));
 794   memset (sha1-&gt;data, 0, sizeof (sha1-&gt;data));
 795 }
 796 
 797 static gchar *
 798 sha1_sum_to_string (Sha1sum *sha1)
 799 {
 800   return digest_to_string (sha1-&gt;digest, SHA1_DIGEST_LEN);
 801 }
 802 
 803 static void
 804 sha1_sum_digest (Sha1sum *sha1,
 805                  guint8  *digest)
 806 {
 807   gint i;
 808 
 809   for (i = 0; i &lt; SHA1_DIGEST_LEN; i++)
 810     digest[i] = sha1-&gt;digest[i];
 811 }
 812 
 813 /*
 814  * SHA-256 Checksum
 815  */
 816 
 817 /* adapted from the SHA256 implementation in gsk/src/hash/gskhash.c.
 818  *
 819  * Copyright (C) 2006 Dave Benson
 820  * Released under the terms of the GNU Lesser General Public License
 821  */
 822 
 823 static void
 824 sha256_sum_init (Sha256sum *sha256)
 825 {
 826   sha256-&gt;buf[0] = 0x6a09e667;
 827   sha256-&gt;buf[1] = 0xbb67ae85;
 828   sha256-&gt;buf[2] = 0x3c6ef372;
 829   sha256-&gt;buf[3] = 0xa54ff53a;
 830   sha256-&gt;buf[4] = 0x510e527f;
 831   sha256-&gt;buf[5] = 0x9b05688c;
 832   sha256-&gt;buf[6] = 0x1f83d9ab;
 833   sha256-&gt;buf[7] = 0x5be0cd19;
 834 
 835   sha256-&gt;bits[0] = sha256-&gt;bits[1] = 0;
 836 }
 837 
 838 #define GET_UINT32(n,b,i)               G_STMT_START{   \
 839     (n) = ((guint32) (b)[(i)    ] &lt;&lt; 24)                \
 840         | ((guint32) (b)[(i) + 1] &lt;&lt; 16)                \
 841         | ((guint32) (b)[(i) + 2] &lt;&lt;  8)                \
 842         | ((guint32) (b)[(i) + 3]      ); } G_STMT_END
 843 
 844 #define PUT_UINT32(n,b,i)               G_STMT_START{   \
 845     (b)[(i)    ] = (guint8) ((n) &gt;&gt; 24);                \
 846     (b)[(i) + 1] = (guint8) ((n) &gt;&gt; 16);                \
 847     (b)[(i) + 2] = (guint8) ((n) &gt;&gt;  8);                \
 848     (b)[(i) + 3] = (guint8) ((n)      ); } G_STMT_END
 849 
 850 static void
 851 sha256_transform (guint32      buf[8],
 852                   guint8 const data[64])
 853 {
 854   guint32 temp1, temp2, W[64];
 855   guint32 A, B, C, D, E, F, G, H;
 856 
 857   GET_UINT32 (W[0],  data,  0);
 858   GET_UINT32 (W[1],  data,  4);
 859   GET_UINT32 (W[2],  data,  8);
 860   GET_UINT32 (W[3],  data, 12);
 861   GET_UINT32 (W[4],  data, 16);
 862   GET_UINT32 (W[5],  data, 20);
 863   GET_UINT32 (W[6],  data, 24);
 864   GET_UINT32 (W[7],  data, 28);
 865   GET_UINT32 (W[8],  data, 32);
 866   GET_UINT32 (W[9],  data, 36);
 867   GET_UINT32 (W[10], data, 40);
 868   GET_UINT32 (W[11], data, 44);
 869   GET_UINT32 (W[12], data, 48);
 870   GET_UINT32 (W[13], data, 52);
 871   GET_UINT32 (W[14], data, 56);
 872   GET_UINT32 (W[15], data, 60);
 873 
 874 #define SHR(x,n)        ((x &amp; 0xFFFFFFFF) &gt;&gt; n)
 875 #define ROTR(x,n)       (SHR (x,n) | (x &lt;&lt; (32 - n)))
 876 
 877 #define S0(x) (ROTR (x, 7) ^ ROTR (x,18) ^  SHR (x, 3))
 878 #define S1(x) (ROTR (x,17) ^ ROTR (x,19) ^  SHR (x,10))
 879 #define S2(x) (ROTR (x, 2) ^ ROTR (x,13) ^ ROTR (x,22))
 880 #define S3(x) (ROTR (x, 6) ^ ROTR (x,11) ^ ROTR (x,25))
 881 
 882 #define F0(x,y,z) ((x &amp; y) | (z &amp; (x | y)))
 883 #define F1(x,y,z) (z ^ (x &amp; (y ^ z)))
 884 
 885 #define R(t)    (W[t] = S1(W[t -  2]) + W[t -  7] + \
 886                         S0(W[t - 15]) + W[t - 16])
 887 
 888 #define P(a,b,c,d,e,f,g,h,x,K)          G_STMT_START {  \
 889         temp1 = h + S3(e) + F1(e,f,g) + K + x;          \
 890         temp2 = S2(a) + F0(a,b,c);                      \
 891         d += temp1; h = temp1 + temp2; } G_STMT_END
 892 
 893   A = buf[0];
 894   B = buf[1];
 895   C = buf[2];
 896   D = buf[3];
 897   E = buf[4];
 898   F = buf[5];
 899   G = buf[6];
 900   H = buf[7];
 901 
 902   P (A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98);
 903   P (H, A, B, C, D, E, F, G, W[ 1], 0x71374491);
 904   P (G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF);
 905   P (F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5);
 906   P (E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B);
 907   P (D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1);
 908   P (C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4);
 909   P (B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5);
 910   P (A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98);
 911   P (H, A, B, C, D, E, F, G, W[ 9], 0x12835B01);
 912   P (G, H, A, B, C, D, E, F, W[10], 0x243185BE);
 913   P (F, G, H, A, B, C, D, E, W[11], 0x550C7DC3);
 914   P (E, F, G, H, A, B, C, D, W[12], 0x72BE5D74);
 915   P (D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE);
 916   P (C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7);
 917   P (B, C, D, E, F, G, H, A, W[15], 0xC19BF174);
 918   P (A, B, C, D, E, F, G, H, R(16), 0xE49B69C1);
 919   P (H, A, B, C, D, E, F, G, R(17), 0xEFBE4786);
 920   P (G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6);
 921   P (F, G, H, A, B, C, D, E, R(19), 0x240CA1CC);
 922   P (E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F);
 923   P (D, E, F, G, H, A, B, C, R(21), 0x4A7484AA);
 924   P (C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC);
 925   P (B, C, D, E, F, G, H, A, R(23), 0x76F988DA);
 926   P (A, B, C, D, E, F, G, H, R(24), 0x983E5152);
 927   P (H, A, B, C, D, E, F, G, R(25), 0xA831C66D);
 928   P (G, H, A, B, C, D, E, F, R(26), 0xB00327C8);
 929   P (F, G, H, A, B, C, D, E, R(27), 0xBF597FC7);
 930   P (E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3);
 931   P (D, E, F, G, H, A, B, C, R(29), 0xD5A79147);
 932   P (C, D, E, F, G, H, A, B, R(30), 0x06CA6351);
 933   P (B, C, D, E, F, G, H, A, R(31), 0x14292967);
 934   P (A, B, C, D, E, F, G, H, R(32), 0x27B70A85);
 935   P (H, A, B, C, D, E, F, G, R(33), 0x2E1B2138);
 936   P (G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC);
 937   P (F, G, H, A, B, C, D, E, R(35), 0x53380D13);
 938   P (E, F, G, H, A, B, C, D, R(36), 0x650A7354);
 939   P (D, E, F, G, H, A, B, C, R(37), 0x766A0ABB);
 940   P (C, D, E, F, G, H, A, B, R(38), 0x81C2C92E);
 941   P (B, C, D, E, F, G, H, A, R(39), 0x92722C85);
 942   P (A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1);
 943   P (H, A, B, C, D, E, F, G, R(41), 0xA81A664B);
 944   P (G, H, A, B, C, D, E, F, R(42), 0xC24B8B70);
 945   P (F, G, H, A, B, C, D, E, R(43), 0xC76C51A3);
 946   P (E, F, G, H, A, B, C, D, R(44), 0xD192E819);
 947   P (D, E, F, G, H, A, B, C, R(45), 0xD6990624);
 948   P (C, D, E, F, G, H, A, B, R(46), 0xF40E3585);
 949   P (B, C, D, E, F, G, H, A, R(47), 0x106AA070);
 950   P (A, B, C, D, E, F, G, H, R(48), 0x19A4C116);
 951   P (H, A, B, C, D, E, F, G, R(49), 0x1E376C08);
 952   P (G, H, A, B, C, D, E, F, R(50), 0x2748774C);
 953   P (F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5);
 954   P (E, F, G, H, A, B, C, D, R(52), 0x391C0CB3);
 955   P (D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A);
 956   P (C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F);
 957   P (B, C, D, E, F, G, H, A, R(55), 0x682E6FF3);
 958   P (A, B, C, D, E, F, G, H, R(56), 0x748F82EE);
 959   P (H, A, B, C, D, E, F, G, R(57), 0x78A5636F);
 960   P (G, H, A, B, C, D, E, F, R(58), 0x84C87814);
 961   P (F, G, H, A, B, C, D, E, R(59), 0x8CC70208);
 962   P (E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA);
 963   P (D, E, F, G, H, A, B, C, R(61), 0xA4506CEB);
 964   P (C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7);
 965   P (B, C, D, E, F, G, H, A, R(63), 0xC67178F2);
 966 
 967 #undef SHR
 968 #undef ROTR
 969 #undef S0
 970 #undef S1
 971 #undef S2
 972 #undef S3
 973 #undef F0
 974 #undef F1
 975 #undef R
 976 #undef P
 977 
 978   buf[0] += A;
 979   buf[1] += B;
 980   buf[2] += C;
 981   buf[3] += D;
 982   buf[4] += E;
 983   buf[5] += F;
 984   buf[6] += G;
 985   buf[7] += H;
 986 }
 987 
 988 static void
 989 sha256_sum_update (Sha256sum    *sha256,
 990                    const guchar *buffer,
 991                    gsize         length)
 992 {
 993   guint32 left, fill;
 994   const guint8 *input = buffer;
 995 
 996   if (length == 0)
 997     return;
 998 
 999   left = sha256-&gt;bits[0] &amp; 0x3F;
1000   fill = 64 - left;
1001 
1002   sha256-&gt;bits[0] += length;
1003   sha256-&gt;bits[0] &amp;= 0xFFFFFFFF;
1004 
1005   if (sha256-&gt;bits[0] &lt; length)
1006       sha256-&gt;bits[1]++;
1007 
1008   if (left &gt; 0 &amp;&amp; length &gt;= fill)
1009     {
1010       memcpy ((sha256-&gt;data + left), input, fill);
1011 
1012       sha256_transform (sha256-&gt;buf, sha256-&gt;data);
1013       length -= fill;
1014       input += fill;
1015 
1016       left = 0;
1017     }
1018 
1019   while (length &gt;= SHA256_DATASIZE)
1020     {
1021       sha256_transform (sha256-&gt;buf, input);
1022 
1023       length -= 64;
1024       input += 64;
1025     }
1026 
1027   if (length)
1028     memcpy (sha256-&gt;data + left, input, length);
1029 }
1030 
1031 static guint8 sha256_padding[64] =
1032 {
1033  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1034     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1035     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
1036     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
1037 };
1038 
1039 static void
1040 sha256_sum_close (Sha256sum *sha256)
1041 {
1042   guint32 last, padn;
1043   guint32 high, low;
1044   guint8 msglen[8];
1045 
1046   high = (sha256-&gt;bits[0] &gt;&gt; 29)
1047        | (sha256-&gt;bits[1] &lt;&lt;  3);
1048   low  = (sha256-&gt;bits[0] &lt;&lt;  3);
1049 
1050   PUT_UINT32 (high, msglen, 0);
1051   PUT_UINT32 (low, msglen, 4);
1052 
1053   last = sha256-&gt;bits[0] &amp; 0x3F;
1054   padn = (last &lt; 56) ? (56 - last) : (120 - last);
1055 
1056   sha256_sum_update (sha256, sha256_padding, padn);
1057   sha256_sum_update (sha256, msglen, 8);
1058 
1059   PUT_UINT32 (sha256-&gt;buf[0], sha256-&gt;digest,  0);
1060   PUT_UINT32 (sha256-&gt;buf[1], sha256-&gt;digest,  4);
1061   PUT_UINT32 (sha256-&gt;buf[2], sha256-&gt;digest,  8);
1062   PUT_UINT32 (sha256-&gt;buf[3], sha256-&gt;digest, 12);
1063   PUT_UINT32 (sha256-&gt;buf[4], sha256-&gt;digest, 16);
1064   PUT_UINT32 (sha256-&gt;buf[5], sha256-&gt;digest, 20);
1065   PUT_UINT32 (sha256-&gt;buf[6], sha256-&gt;digest, 24);
1066   PUT_UINT32 (sha256-&gt;buf[7], sha256-&gt;digest, 28);
1067 }
1068 
1069 #undef PUT_UINT32
1070 #undef GET_UINT32
1071 
1072 static gchar *
1073 sha256_sum_to_string (Sha256sum *sha256)
1074 {
1075   return digest_to_string (sha256-&gt;digest, SHA256_DIGEST_LEN);
1076 }
1077 
1078 static void
1079 sha256_sum_digest (Sha256sum *sha256,
1080                    guint8    *digest)
1081 {
1082   gint i;
1083 
1084   for (i = 0; i &lt; SHA256_DIGEST_LEN; i++)
1085     digest[i] = sha256-&gt;digest[i];
1086 }
1087 
1088 /*
1089  * SHA-384, SHA-512, SHA-512/224 and SHA-512/256 Checksums
1090  *
1091  * Implemented following FIPS-180-4 standard at
1092  * http://csrc.nist.gov/publications/fips/fips180-4/fips180-4.pdf.
1093  * References in the form [�x.y.z] map to sections in that document.
1094  *
1095  *   Author(s): Eduardo Lima Mitev &lt;elima@igalia.com&gt;
1096  *              Igor Gnatenko &lt;ignatenko@src.gnome.org&gt;
1097  */
1098 
1099 /* SHA-384, SHA-512, SHA-512/224 and SHA-512/256 functions [�4.1.3] */
1100 #define Ch(x,y,z)  ((x &amp; y) ^ (~x &amp; z))
1101 #define Maj(x,y,z) ((x &amp; y) ^ (x &amp; z) ^ (y &amp; z))
1102 #define SHR(n,x)   (x &gt;&gt; n)
1103 #define ROTR(n,x)  (SHR (n, x) | (x &lt;&lt; (64 - n)))
1104 #define SIGMA0(x)  (ROTR (28, x) ^ ROTR (34, x) ^ ROTR (39, x))
1105 #define SIGMA1(x)  (ROTR (14, x) ^ ROTR (18, x) ^ ROTR (41, x))
1106 #define sigma0(x)  (ROTR ( 1, x) ^ ROTR ( 8, x) ^ SHR  ( 7, x))
1107 #define sigma1(x)  (ROTR (19, x) ^ ROTR (61, x) ^ SHR  ( 6, x))
1108 
1109 #define PUT_UINT64(n,b,i)                G_STMT_START{   \
1110     (b)[(i)    ] = (guint8) (n &gt;&gt; 56);                   \
1111     (b)[(i) + 1] = (guint8) (n &gt;&gt; 48);                   \
1112     (b)[(i) + 2] = (guint8) (n &gt;&gt; 40);                   \
1113     (b)[(i) + 3] = (guint8) (n &gt;&gt; 32);                   \
1114     (b)[(i) + 4] = (guint8) (n &gt;&gt; 24);                   \
1115     (b)[(i) + 5] = (guint8) (n &gt;&gt; 16);                   \
1116     (b)[(i) + 6] = (guint8) (n &gt;&gt;  8);                   \
1117     (b)[(i) + 7] = (guint8) (n      ); } G_STMT_END
1118 
1119 /* SHA-384 and SHA-512 constants [�4.2.3] */
1120 static const guint64 SHA2_K[80] = {
1121   G_GUINT64_CONSTANT (0x428a2f98d728ae22), G_GUINT64_CONSTANT (0x7137449123ef65cd),
1122   G_GUINT64_CONSTANT (0xb5c0fbcfec4d3b2f), G_GUINT64_CONSTANT (0xe9b5dba58189dbbc),
1123   G_GUINT64_CONSTANT (0x3956c25bf348b538), G_GUINT64_CONSTANT (0x59f111f1b605d019),
1124   G_GUINT64_CONSTANT (0x923f82a4af194f9b), G_GUINT64_CONSTANT (0xab1c5ed5da6d8118),
1125   G_GUINT64_CONSTANT (0xd807aa98a3030242), G_GUINT64_CONSTANT (0x12835b0145706fbe),
1126   G_GUINT64_CONSTANT (0x243185be4ee4b28c), G_GUINT64_CONSTANT (0x550c7dc3d5ffb4e2),
1127   G_GUINT64_CONSTANT (0x72be5d74f27b896f), G_GUINT64_CONSTANT (0x80deb1fe3b1696b1),
1128   G_GUINT64_CONSTANT (0x9bdc06a725c71235), G_GUINT64_CONSTANT (0xc19bf174cf692694),
1129   G_GUINT64_CONSTANT (0xe49b69c19ef14ad2), G_GUINT64_CONSTANT (0xefbe4786384f25e3),
1130   G_GUINT64_CONSTANT (0x0fc19dc68b8cd5b5), G_GUINT64_CONSTANT (0x240ca1cc77ac9c65),
1131   G_GUINT64_CONSTANT (0x2de92c6f592b0275), G_GUINT64_CONSTANT (0x4a7484aa6ea6e483),
1132   G_GUINT64_CONSTANT (0x5cb0a9dcbd41fbd4), G_GUINT64_CONSTANT (0x76f988da831153b5),
1133   G_GUINT64_CONSTANT (0x983e5152ee66dfab), G_GUINT64_CONSTANT (0xa831c66d2db43210),
1134   G_GUINT64_CONSTANT (0xb00327c898fb213f), G_GUINT64_CONSTANT (0xbf597fc7beef0ee4),
1135   G_GUINT64_CONSTANT (0xc6e00bf33da88fc2), G_GUINT64_CONSTANT (0xd5a79147930aa725),
1136   G_GUINT64_CONSTANT (0x06ca6351e003826f), G_GUINT64_CONSTANT (0x142929670a0e6e70),
1137   G_GUINT64_CONSTANT (0x27b70a8546d22ffc), G_GUINT64_CONSTANT (0x2e1b21385c26c926),
1138   G_GUINT64_CONSTANT (0x4d2c6dfc5ac42aed), G_GUINT64_CONSTANT (0x53380d139d95b3df),
1139   G_GUINT64_CONSTANT (0x650a73548baf63de), G_GUINT64_CONSTANT (0x766a0abb3c77b2a8),
1140   G_GUINT64_CONSTANT (0x81c2c92e47edaee6), G_GUINT64_CONSTANT (0x92722c851482353b),
1141   G_GUINT64_CONSTANT (0xa2bfe8a14cf10364), G_GUINT64_CONSTANT (0xa81a664bbc423001),
1142   G_GUINT64_CONSTANT (0xc24b8b70d0f89791), G_GUINT64_CONSTANT (0xc76c51a30654be30),
1143   G_GUINT64_CONSTANT (0xd192e819d6ef5218), G_GUINT64_CONSTANT (0xd69906245565a910),
1144   G_GUINT64_CONSTANT (0xf40e35855771202a), G_GUINT64_CONSTANT (0x106aa07032bbd1b8),
1145   G_GUINT64_CONSTANT (0x19a4c116b8d2d0c8), G_GUINT64_CONSTANT (0x1e376c085141ab53),
1146   G_GUINT64_CONSTANT (0x2748774cdf8eeb99), G_GUINT64_CONSTANT (0x34b0bcb5e19b48a8),
1147   G_GUINT64_CONSTANT (0x391c0cb3c5c95a63), G_GUINT64_CONSTANT (0x4ed8aa4ae3418acb),
1148   G_GUINT64_CONSTANT (0x5b9cca4f7763e373), G_GUINT64_CONSTANT (0x682e6ff3d6b2b8a3),
1149   G_GUINT64_CONSTANT (0x748f82ee5defb2fc), G_GUINT64_CONSTANT (0x78a5636f43172f60),
1150   G_GUINT64_CONSTANT (0x84c87814a1f0ab72), G_GUINT64_CONSTANT (0x8cc702081a6439ec),
1151   G_GUINT64_CONSTANT (0x90befffa23631e28), G_GUINT64_CONSTANT (0xa4506cebde82bde9),
1152   G_GUINT64_CONSTANT (0xbef9a3f7b2c67915), G_GUINT64_CONSTANT (0xc67178f2e372532b),
1153   G_GUINT64_CONSTANT (0xca273eceea26619c), G_GUINT64_CONSTANT (0xd186b8c721c0c207),
1154   G_GUINT64_CONSTANT (0xeada7dd6cde0eb1e), G_GUINT64_CONSTANT (0xf57d4f7fee6ed178),
1155   G_GUINT64_CONSTANT (0x06f067aa72176fba), G_GUINT64_CONSTANT (0x0a637dc5a2c898a6),
1156   G_GUINT64_CONSTANT (0x113f9804bef90dae), G_GUINT64_CONSTANT (0x1b710b35131c471b),
1157   G_GUINT64_CONSTANT (0x28db77f523047d84), G_GUINT64_CONSTANT (0x32caab7b40c72493),
1158   G_GUINT64_CONSTANT (0x3c9ebe0a15c9bebc), G_GUINT64_CONSTANT (0x431d67c49c100d4c),
1159   G_GUINT64_CONSTANT (0x4cc5d4becb3e42b6), G_GUINT64_CONSTANT (0x597f299cfc657e2a),
1160   G_GUINT64_CONSTANT (0x5fcb6fab3ad6faec), G_GUINT64_CONSTANT (0x6c44198c4a475817)
1161 };
1162 
1163 
1164 static void
1165 sha384_sum_init (Sha512sum *sha512)
1166 {
1167   /* Initial Hash Value [�5.3.4] */
1168   sha512-&gt;H[0] = G_GUINT64_CONSTANT (0xcbbb9d5dc1059ed8);
1169   sha512-&gt;H[1] = G_GUINT64_CONSTANT (0x629a292a367cd507);
1170   sha512-&gt;H[2] = G_GUINT64_CONSTANT (0x9159015a3070dd17);
1171   sha512-&gt;H[3] = G_GUINT64_CONSTANT (0x152fecd8f70e5939);
1172   sha512-&gt;H[4] = G_GUINT64_CONSTANT (0x67332667ffc00b31);
1173   sha512-&gt;H[5] = G_GUINT64_CONSTANT (0x8eb44a8768581511);
1174   sha512-&gt;H[6] = G_GUINT64_CONSTANT (0xdb0c2e0d64f98fa7);
1175   sha512-&gt;H[7] = G_GUINT64_CONSTANT (0x47b5481dbefa4fa4);
1176 
1177   sha512-&gt;block_len = 0;
1178 
1179   sha512-&gt;data_len[0] = 0;
1180   sha512-&gt;data_len[1] = 0;
1181 }
1182 
1183 static void
1184 sha512_sum_init (Sha512sum *sha512)
1185 {
1186   /* Initial Hash Value [�5.3.5] */
1187   sha512-&gt;H[0] = G_GUINT64_CONSTANT (0x6a09e667f3bcc908);
1188   sha512-&gt;H[1] = G_GUINT64_CONSTANT (0xbb67ae8584caa73b);
1189   sha512-&gt;H[2] = G_GUINT64_CONSTANT (0x3c6ef372fe94f82b);
1190   sha512-&gt;H[3] = G_GUINT64_CONSTANT (0xa54ff53a5f1d36f1);
1191   sha512-&gt;H[4] = G_GUINT64_CONSTANT (0x510e527fade682d1);
1192   sha512-&gt;H[5] = G_GUINT64_CONSTANT (0x9b05688c2b3e6c1f);
1193   sha512-&gt;H[6] = G_GUINT64_CONSTANT (0x1f83d9abfb41bd6b);
1194   sha512-&gt;H[7] = G_GUINT64_CONSTANT (0x5be0cd19137e2179);
1195 
1196   sha512-&gt;block_len = 0;
1197 
1198   sha512-&gt;data_len[0] = 0;
1199   sha512-&gt;data_len[1] = 0;
1200 }
1201 
1202 static void
1203 sha512_transform (guint64      H[8],
1204                   guint8 const data[SHA2_BLOCK_LEN])
1205 {
1206   gint i;
1207   gint t;
1208   guint64 a, b, c, d, e, f, g, h;
1209   guint64 M[16];
1210   guint64 W[80];
1211 
1212   /* SHA-512 hash computation [�6.4.2] */
1213 
1214   /* prepare the message schedule */
1215   for (i = 0; i &lt; 16; i++)
1216     {
1217       gint p = i * 8;
1218 
1219       M[i] =
1220         ((guint64) data[p + 0] &lt;&lt; 56) |
1221         ((guint64) data[p + 1] &lt;&lt; 48) |
1222         ((guint64) data[p + 2] &lt;&lt; 40) |
1223         ((guint64) data[p + 3] &lt;&lt; 32) |
1224         ((guint64) data[p + 4] &lt;&lt; 24) |
1225         ((guint64) data[p + 5] &lt;&lt; 16) |
1226         ((guint64) data[p + 6] &lt;&lt;  8) |
1227         ((guint64) data[p + 7]      );
1228     }
1229 
1230   for (t = 0; t &lt; 80; t++)
1231     if (t &lt; 16)
1232       W[t] = M[t];
1233     else
1234       W[t] = sigma1 (W[t - 2]) + W[t - 7] + sigma0 (W[t - 15]) + W[t - 16];
1235 
1236   /* initialize the eight working variables */
1237   a = H[0];
1238   b = H[1];
1239   c = H[2];
1240   d = H[3];
1241   e = H[4];
1242   f = H[5];
1243   g = H[6];
1244   h = H[7];
1245 
1246   for (t = 0; t &lt; 80; t++)
1247     {
1248       guint64 T1, T2;
1249 
1250       T1 = h + SIGMA1 (e) + Ch (e, f, g) + SHA2_K[t] + W[t];
1251       T2 = SIGMA0 (a) + Maj (a, b, c);
1252       h = g;
1253       g = f;
1254       f = e;
1255       e = d + T1;
1256       d = c;
1257       c = b;
1258       b = a;
1259       a = T1 + T2;
1260     }
1261 
1262   /* Compute the intermediate hash value H */
1263   H[0] += a;
1264   H[1] += b;
1265   H[2] += c;
1266   H[3] += d;
1267   H[4] += e;
1268   H[5] += f;
1269   H[6] += g;
1270   H[7] += h;
1271 }
1272 
1273 static void
1274 sha512_sum_update (Sha512sum    *sha512,
1275                    const guchar *buffer,
1276                    gsize         length)
1277 {
1278   gsize block_left, offset = 0;
1279 
1280   if (length == 0)
1281     return;
1282 
1283   sha512-&gt;data_len[0] += length * 8;
1284   if (sha512-&gt;data_len[0] &lt; length)
1285     sha512-&gt;data_len[1]++;
1286 
1287   /* try to fill current block */
1288   block_left = SHA2_BLOCK_LEN - sha512-&gt;block_len;
1289   if (block_left &gt; 0)
1290     {
1291       gsize fill_len;
1292 
1293       fill_len = MIN (block_left, length);
1294       memcpy (sha512-&gt;block + sha512-&gt;block_len, buffer, fill_len);
1295       sha512-&gt;block_len += fill_len;
1296       length -= fill_len;
1297       offset += fill_len;
1298 
1299       if (sha512-&gt;block_len == SHA2_BLOCK_LEN)
1300         {
1301           sha512_transform (sha512-&gt;H, sha512-&gt;block);
1302           sha512-&gt;block_len = 0;
1303         }
1304     }
1305 
1306   /* process complete blocks */
1307   while (length &gt;= SHA2_BLOCK_LEN)
1308     {
1309       memcpy (sha512-&gt;block, buffer + offset, SHA2_BLOCK_LEN);
1310 
1311       sha512_transform (sha512-&gt;H, sha512-&gt;block);
1312 
1313       length -= SHA2_BLOCK_LEN;
1314       offset += SHA2_BLOCK_LEN;
1315     }
1316 
1317   /* keep remaining data for next block */
1318   if (length &gt; 0)
1319     {
1320       memcpy (sha512-&gt;block, buffer + offset, length);
1321       sha512-&gt;block_len = length;
1322     }
1323 }
1324 
1325 static void
1326 sha512_sum_close (Sha512sum *sha512)
1327 {
1328   guint l;
1329   gint zeros;
1330   guint8 pad[SHA2_BLOCK_LEN * 2] = { 0, };
1331   guint pad_len = 0;
1332   gint i;
1333 
1334   /* apply padding [�5.1.2] */
1335   l = sha512-&gt;block_len * 8;
1336   zeros = 896 - (l + 1);
1337 
1338   if (zeros &lt; 0)
1339     zeros += 128 * 8;
1340 
1341   pad[0] = 0x80; /* 1000 0000 */
1342   zeros -= 7;
1343   pad_len++;
1344 
1345   memset (pad + pad_len, 0x00, zeros / 8);
1346   pad_len += zeros / 8;
1347   zeros = zeros % 8;
1348 
1349   /* put message bit length at the end of padding */
1350   PUT_UINT64 (sha512-&gt;data_len[1], pad, pad_len);
1351   pad_len += 8;
1352 
1353   PUT_UINT64 (sha512-&gt;data_len[0], pad, pad_len);
1354   pad_len += 8;
1355 
1356   /* update checksum with the padded block */
1357   sha512_sum_update (sha512, pad, pad_len);
1358 
1359   /* copy resulting 64-bit words into digest */
1360   for (i = 0; i &lt; 8; i++)
1361     PUT_UINT64 (sha512-&gt;H[i], sha512-&gt;digest, i * 8);
1362 }
1363 
1364 static gchar *
1365 sha384_sum_to_string (Sha512sum *sha512)
1366 {
1367   return digest_to_string (sha512-&gt;digest, SHA384_DIGEST_LEN);
1368 }
1369 
1370 static gchar *
1371 sha512_sum_to_string (Sha512sum *sha512)
1372 {
1373   return digest_to_string (sha512-&gt;digest, SHA512_DIGEST_LEN);
1374 }
1375 
1376 static void
1377 sha384_sum_digest (Sha512sum *sha512,
1378                    guint8    *digest)
1379 {
1380   memcpy (digest, sha512-&gt;digest, SHA384_DIGEST_LEN);
1381 }
1382 
1383 static void
1384 sha512_sum_digest (Sha512sum *sha512,
1385                    guint8    *digest)
1386 {
1387   memcpy (digest, sha512-&gt;digest, SHA512_DIGEST_LEN);
1388 }
1389 
1390 #undef Ch
1391 #undef Maj
1392 #undef SHR
1393 #undef ROTR
1394 #undef SIGMA0
1395 #undef SIGMA1
1396 #undef sigma0
1397 #undef sigma1
1398 
1399 #undef PUT_UINT64
1400 
1401 /*
1402  * Public API
1403  */
1404 
1405 /**
1406  * g_checksum_type_get_length:
1407  * @checksum_type: a #GChecksumType
1408  *
1409  * Gets the length in bytes of digests of type @checksum_type
1410  *
1411  * Returns: the checksum length, or -1 if @checksum_type is
1412  * not supported.
1413  *
1414  * Since: 2.16
1415  */
1416 gssize
1417 g_checksum_type_get_length (GChecksumType checksum_type)
1418 {
1419   gssize len = -1;
1420 
1421   switch (checksum_type)
1422     {
1423     case G_CHECKSUM_MD5:
1424       len = MD5_DIGEST_LEN;
1425       break;
1426     case G_CHECKSUM_SHA1:
1427       len = SHA1_DIGEST_LEN;
1428       break;
1429     case G_CHECKSUM_SHA256:
1430       len = SHA256_DIGEST_LEN;
1431       break;
1432     case G_CHECKSUM_SHA384:
1433       len = SHA384_DIGEST_LEN;
1434       break;
1435     case G_CHECKSUM_SHA512:
1436       len = SHA512_DIGEST_LEN;
1437       break;
1438     default:
1439       len = -1;
1440       break;
1441     }
1442 
1443   return len;
1444 }
1445 
1446 /**
1447  * g_checksum_new:
1448  * @checksum_type: the desired type of checksum
1449  *
1450  * Creates a new #GChecksum, using the checksum algorithm @checksum_type.
1451  * If the @checksum_type is not known, %NULL is returned.
1452  * A #GChecksum can be used to compute the checksum, or digest, of an
1453  * arbitrary binary blob, using different hashing algorithms.
1454  *
1455  * A #GChecksum works by feeding a binary blob through g_checksum_update()
1456  * until there is data to be checked; the digest can then be extracted
1457  * using g_checksum_get_string(), which will return the checksum as a
1458  * hexadecimal string; or g_checksum_get_digest(), which will return a
1459  * vector of raw bytes. Once either g_checksum_get_string() or
1460  * g_checksum_get_digest() have been called on a #GChecksum, the checksum
1461  * will be closed and it won&#39;t be possible to call g_checksum_update()
1462  * on it anymore.
1463  *
1464  * Returns: (transfer full): the newly created #GChecksum, or %NULL.
1465  *   Use g_checksum_free() to free the memory allocated by it.
1466  *
1467  * Since: 2.16
1468  */
1469 GChecksum *
1470 g_checksum_new (GChecksumType checksum_type)
1471 {
1472   GChecksum *checksum;
1473 
1474   if (! IS_VALID_TYPE (checksum_type))
1475     return NULL;
1476 
1477   checksum = g_slice_new0 (GChecksum);
1478   checksum-&gt;type = checksum_type;
1479 
1480   g_checksum_reset (checksum);
1481 
1482   return checksum;
1483 }
1484 
1485 /**
1486  * g_checksum_reset:
1487  * @checksum: the #GChecksum to reset
1488  *
1489  * Resets the state of the @checksum back to its initial state.
1490  *
1491  * Since: 2.18
1492  **/
1493 void
1494 g_checksum_reset (GChecksum *checksum)
1495 {
1496   g_return_if_fail (checksum != NULL);
1497 
1498   g_free (checksum-&gt;digest_str);
1499   checksum-&gt;digest_str = NULL;
1500 
1501   switch (checksum-&gt;type)
1502     {
1503     case G_CHECKSUM_MD5:
1504       md5_sum_init (&amp;(checksum-&gt;sum.md5));
1505       break;
1506     case G_CHECKSUM_SHA1:
1507       sha1_sum_init (&amp;(checksum-&gt;sum.sha1));
1508       break;
1509     case G_CHECKSUM_SHA256:
1510       sha256_sum_init (&amp;(checksum-&gt;sum.sha256));
1511       break;
1512     case G_CHECKSUM_SHA384:
1513       sha384_sum_init (&amp;(checksum-&gt;sum.sha512));
1514       break;
1515     case G_CHECKSUM_SHA512:
1516       sha512_sum_init (&amp;(checksum-&gt;sum.sha512));
1517       break;
1518     default:
1519       g_assert_not_reached ();
1520       break;
1521     }
1522 }
1523 
1524 /**
1525  * g_checksum_copy:
1526  * @checksum: the #GChecksum to copy
1527  *
1528  * Copies a #GChecksum. If @checksum has been closed, by calling
1529  * g_checksum_get_string() or g_checksum_get_digest(), the copied
1530  * checksum will be closed as well.
1531  *
1532  * Returns: the copy of the passed #GChecksum. Use g_checksum_free()
1533  *   when finished using it.
1534  *
1535  * Since: 2.16
1536  */
1537 GChecksum *
1538 g_checksum_copy (const GChecksum *checksum)
1539 {
1540   GChecksum *copy;
1541 
1542   g_return_val_if_fail (checksum != NULL, NULL);
1543 
1544   copy = g_slice_new (GChecksum);
1545 #ifdef GSTREAMER_LITE
1546   if (copy == NULL) {
1547     return NULL;
1548   }
1549 #endif // GSTREAMER_LITE
1550   *copy = *checksum;
1551 
1552   copy-&gt;digest_str = g_strdup (checksum-&gt;digest_str);
1553 
1554   return copy;
1555 }
1556 
1557 /**
1558  * g_checksum_free:
1559  * @checksum: a #GChecksum
1560  *
1561  * Frees the memory allocated for @checksum.
1562  *
1563  * Since: 2.16
1564  */
1565 void
1566 g_checksum_free (GChecksum *checksum)
1567 {
1568   if (G_LIKELY (checksum))
1569     {
1570       g_free (checksum-&gt;digest_str);
1571 
1572       g_slice_free (GChecksum, checksum);
1573     }
1574 }
1575 
1576 /**
1577  * g_checksum_update:
1578  * @checksum: a #GChecksum
1579  * @data: (array length=length) (element-type guint8): buffer used to compute the checksum
1580  * @length: size of the buffer, or -1 if it is a null-terminated string.
1581  *
1582  * Feeds @data into an existing #GChecksum. The checksum must still be
1583  * open, that is g_checksum_get_string() or g_checksum_get_digest() must
1584  * not have been called on @checksum.
1585  *
1586  * Since: 2.16
1587  */
1588 void
1589 g_checksum_update (GChecksum    *checksum,
1590                    const guchar *data,
1591                    gssize        length)
1592 {
1593   g_return_if_fail (checksum != NULL);
1594   g_return_if_fail (length == 0 || data != NULL);
1595 
1596   if (length &lt; 0)
1597     length = strlen ((const gchar *) data);
1598 
1599   if (checksum-&gt;digest_str)
1600     {
1601       g_warning (&quot;The checksum &#39;%s&#39; has been closed and cannot be updated &quot;
1602                  &quot;anymore.&quot;,
1603                  checksum-&gt;digest_str);
1604       return;
1605     }
1606 
1607   switch (checksum-&gt;type)
1608     {
1609     case G_CHECKSUM_MD5:
1610       md5_sum_update (&amp;(checksum-&gt;sum.md5), data, length);
1611       break;
1612     case G_CHECKSUM_SHA1:
1613       sha1_sum_update (&amp;(checksum-&gt;sum.sha1), data, length);
1614       break;
1615     case G_CHECKSUM_SHA256:
1616       sha256_sum_update (&amp;(checksum-&gt;sum.sha256), data, length);
1617       break;
1618     case G_CHECKSUM_SHA384:
1619     case G_CHECKSUM_SHA512:
1620       sha512_sum_update (&amp;(checksum-&gt;sum.sha512), data, length);
1621       break;
1622     default:
1623       g_assert_not_reached ();
1624       break;
1625     }
1626 }
1627 
1628 /**
1629  * g_checksum_get_string:
1630  * @checksum: a #GChecksum
1631  *
1632  * Gets the digest as an hexadecimal string.
1633  *
1634  * Once this function has been called the #GChecksum can no longer be
1635  * updated with g_checksum_update().
1636  *
1637  * The hexadecimal characters will be lower case.
1638  *
1639  * Returns: the hexadecimal representation of the checksum. The
1640  *   returned string is owned by the checksum and should not be modified
1641  *   or freed.
1642  *
1643  * Since: 2.16
1644  */
1645 const gchar *
1646 g_checksum_get_string (GChecksum *checksum)
1647 {
1648   gchar *str = NULL;
1649 
1650   g_return_val_if_fail (checksum != NULL, NULL);
1651 
1652   if (checksum-&gt;digest_str)
1653     return checksum-&gt;digest_str;
1654 
1655   switch (checksum-&gt;type)
1656     {
1657     case G_CHECKSUM_MD5:
1658       md5_sum_close (&amp;(checksum-&gt;sum.md5));
1659       str = md5_sum_to_string (&amp;(checksum-&gt;sum.md5));
1660       break;
1661     case G_CHECKSUM_SHA1:
1662       sha1_sum_close (&amp;(checksum-&gt;sum.sha1));
1663       str = sha1_sum_to_string (&amp;(checksum-&gt;sum.sha1));
1664       break;
1665     case G_CHECKSUM_SHA256:
1666       sha256_sum_close (&amp;(checksum-&gt;sum.sha256));
1667       str = sha256_sum_to_string (&amp;(checksum-&gt;sum.sha256));
1668       break;
1669     case G_CHECKSUM_SHA384:
1670       sha512_sum_close (&amp;(checksum-&gt;sum.sha512));
1671       str = sha384_sum_to_string (&amp;(checksum-&gt;sum.sha512));
1672       break;
1673     case G_CHECKSUM_SHA512:
1674       sha512_sum_close (&amp;(checksum-&gt;sum.sha512));
1675       str = sha512_sum_to_string (&amp;(checksum-&gt;sum.sha512));
1676       break;
1677     default:
1678       g_assert_not_reached ();
1679       break;
1680     }
1681 
1682   checksum-&gt;digest_str = str;
1683 
1684   return checksum-&gt;digest_str;
1685 }
1686 
1687 /**
1688  * g_checksum_get_digest: (skip)
1689  * @checksum: a #GChecksum
1690  * @buffer: (array length=digest_len): output buffer
1691  * @digest_len: (inout): an inout parameter. The caller initializes it to the size of @buffer.
1692  *   After the call it contains the length of the digest.
1693  *
1694  * Gets the digest from @checksum as a raw binary vector and places it
1695  * into @buffer. The size of the digest depends on the type of checksum.
1696  *
1697  * Once this function has been called, the #GChecksum is closed and can
1698  * no longer be updated with g_checksum_update().
1699  *
1700  * Since: 2.16
1701  */
1702 void
1703 g_checksum_get_digest (GChecksum  *checksum,
1704                        guint8     *buffer,
1705                        gsize      *digest_len)
1706 {
1707   gboolean checksum_open = FALSE;
1708   gchar *str = NULL;
1709   gsize len;
1710 
1711   g_return_if_fail (checksum != NULL);
1712 
1713   len = g_checksum_type_get_length (checksum-&gt;type);
1714   g_return_if_fail (*digest_len &gt;= len);
1715 
1716   checksum_open = !!(checksum-&gt;digest_str == NULL);
1717 
1718   switch (checksum-&gt;type)
1719     {
1720     case G_CHECKSUM_MD5:
1721       if (checksum_open)
1722         {
1723           md5_sum_close (&amp;(checksum-&gt;sum.md5));
1724           str = md5_sum_to_string (&amp;(checksum-&gt;sum.md5));
1725         }
1726       md5_sum_digest (&amp;(checksum-&gt;sum.md5), buffer);
1727       break;
1728     case G_CHECKSUM_SHA1:
1729       if (checksum_open)
1730         {
1731           sha1_sum_close (&amp;(checksum-&gt;sum.sha1));
1732           str = sha1_sum_to_string (&amp;(checksum-&gt;sum.sha1));
1733         }
1734       sha1_sum_digest (&amp;(checksum-&gt;sum.sha1), buffer);
1735       break;
1736     case G_CHECKSUM_SHA256:
1737       if (checksum_open)
1738         {
1739           sha256_sum_close (&amp;(checksum-&gt;sum.sha256));
1740           str = sha256_sum_to_string (&amp;(checksum-&gt;sum.sha256));
1741         }
1742       sha256_sum_digest (&amp;(checksum-&gt;sum.sha256), buffer);
1743       break;
1744     case G_CHECKSUM_SHA384:
1745       if (checksum_open)
1746         {
1747           sha512_sum_close (&amp;(checksum-&gt;sum.sha512));
1748           str = sha384_sum_to_string (&amp;(checksum-&gt;sum.sha512));
1749         }
1750       sha384_sum_digest (&amp;(checksum-&gt;sum.sha512), buffer);
1751       break;
1752     case G_CHECKSUM_SHA512:
1753       if (checksum_open)
1754         {
1755           sha512_sum_close (&amp;(checksum-&gt;sum.sha512));
1756           str = sha512_sum_to_string (&amp;(checksum-&gt;sum.sha512));
1757         }
1758       sha512_sum_digest (&amp;(checksum-&gt;sum.sha512), buffer);
1759       break;
1760     default:
1761       g_assert_not_reached ();
1762       break;
1763     }
1764 
1765   if (str)
1766     checksum-&gt;digest_str = str;
1767 
1768   *digest_len = len;
1769 }
1770 
1771 /**
1772  * g_compute_checksum_for_data:
1773  * @checksum_type: a #GChecksumType
1774  * @data: (array length=length) (element-type guint8): binary blob to compute the digest of
1775  * @length: length of @data
1776  *
1777  * Computes the checksum for a binary @data of @length. This is a
1778  * convenience wrapper for g_checksum_new(), g_checksum_get_string()
1779  * and g_checksum_free().
1780  *
1781  * The hexadecimal string returned will be in lower case.
1782  *
1783  * Returns: the digest of the binary data as a string in hexadecimal.
1784  *   The returned string should be freed with g_free() when done using it.
1785  *
1786  * Since: 2.16
1787  */
1788 gchar *
1789 g_compute_checksum_for_data (GChecksumType  checksum_type,
1790                              const guchar  *data,
1791                              gsize          length)
1792 {
1793   GChecksum *checksum;
1794   gchar *retval;
1795 
1796   g_return_val_if_fail (IS_VALID_TYPE (checksum_type), NULL);
1797   g_return_val_if_fail (length == 0 || data != NULL, NULL);
1798 
1799   checksum = g_checksum_new (checksum_type);
1800   if (!checksum)
1801     return NULL;
1802 
1803   g_checksum_update (checksum, data, length);
1804   retval = g_strdup (g_checksum_get_string (checksum));
1805   g_checksum_free (checksum);
1806 
1807   return retval;
1808 }
1809 
1810 /**
1811  * g_compute_checksum_for_string:
1812  * @checksum_type: a #GChecksumType
1813  * @str: the string to compute the checksum of
1814  * @length: the length of the string, or -1 if the string is null-terminated.
1815  *
1816  * Computes the checksum of a string.
1817  *
1818  * The hexadecimal string returned will be in lower case.
1819  *
1820  * Returns: the checksum as a hexadecimal string. The returned string
1821  *   should be freed with g_free() when done using it.
1822  *
1823  * Since: 2.16
1824  */
1825 gchar *
1826 g_compute_checksum_for_string (GChecksumType  checksum_type,
1827                                const gchar   *str,
1828                                gssize         length)
1829 {
1830   g_return_val_if_fail (IS_VALID_TYPE (checksum_type), NULL);
1831   g_return_val_if_fail (length == 0 || str != NULL, NULL);
1832 
1833   if (length &lt; 0)
1834     length = strlen (str);
1835 
1836   return g_compute_checksum_for_data (checksum_type, (const guchar *) str, length);
1837 }
1838 
1839 /**
1840  * g_compute_checksum_for_bytes:
1841  * @checksum_type: a #GChecksumType
1842  * @data: binary blob to compute the digest of
1843  *
1844  * Computes the checksum for a binary @data. This is a
1845  * convenience wrapper for g_checksum_new(), g_checksum_get_string()
1846  * and g_checksum_free().
1847  *
1848  * The hexadecimal string returned will be in lower case.
1849  *
1850  * Returns: the digest of the binary data as a string in hexadecimal.
1851  *   The returned string should be freed with g_free() when done using it.
1852  *
1853  * Since: 2.34
1854  */
1855 gchar *
1856 g_compute_checksum_for_bytes (GChecksumType  checksum_type,
1857                               GBytes        *data)
1858 {
1859   gconstpointer byte_data;
1860   gsize length;
1861 
1862   g_return_val_if_fail (IS_VALID_TYPE (checksum_type), NULL);
1863   g_return_val_if_fail (data != NULL, NULL);
1864 
1865   byte_data = g_bytes_get_data (data, &amp;length);
1866   return g_compute_checksum_for_data (checksum_type, byte_data, length);
1867 }
    </pre>
  </body>
</html>