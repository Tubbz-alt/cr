<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gbacktrace.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gatomic.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gbase64.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gbacktrace.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
108  * {
109  *   g_log_set_handler (MY_LOG_DOMAIN,
110  *                      G_LOG_LEVEL_WARNING |
111  *                      G_LOG_LEVEL_ERROR |
112  *                      G_LOG_LEVEL_CRITICAL,
113  *                      log_handler,
114  *                      NULL);
115  *   ...
116  * ]|
117  *
118  * If &quot;[E]xit&quot; is selected, the application terminates with a call
119  * to _exit(0).
120  *
121  * If &quot;[S]tack&quot; trace is selected, g_on_error_stack_trace() is called.
122  * This invokes gdb, which attaches to the current process and shows
123  * a stack trace. The prompt is then shown again.
124  *
125  * If &quot;[P]roceed&quot; is selected, the function returns.
126  *
127  * This function may cause different actions on non-UNIX platforms.




128  */
129 void
130 g_on_error_query (const gchar *prg_name)
131 {
132 #ifndef G_OS_WIN32
133   static const gchar * const query1 = &quot;[E]xit, [H]alt&quot;;
134   static const gchar * const query2 = &quot;, show [S]tack trace&quot;;
135   static const gchar * const query3 = &quot; or [P]roceed&quot;;
136   gchar buf[16];
137 
138   if (!prg_name)
139     prg_name = g_get_prgname ();
140 
141  retry:
142 
143   if (prg_name)
144     _g_fprintf (stdout,
145                 &quot;%s (pid:%u): %s%s%s: &quot;,
146                 prg_name,
147                 (guint) getpid (),
</pre>
<hr />
<pre>
171            &amp;&amp; (buf[0] == &#39;S&#39; || buf[0] == &#39;s&#39;)
172            &amp;&amp; buf[1] == &#39;\n&#39;)
173     {
174       g_on_error_stack_trace (prg_name);
175       goto retry;
176     }
177   else if ((buf[0] == &#39;H&#39; || buf[0] == &#39;h&#39;)
178            &amp;&amp; buf[1] == &#39;\n&#39;)
179     {
180       while (glib_on_error_halt)
181         ;
182       glib_on_error_halt = TRUE;
183       return;
184     }
185   else
186     goto retry;
187 #else
188   if (!prg_name)
189     prg_name = g_get_prgname ();
190 



191   MessageBox (NULL, &quot;g_on_error_query called, program terminating&quot;,
192               (prg_name &amp;&amp; *prg_name) ? prg_name : NULL,
193               MB_OK|MB_ICONERROR);




194   _exit(0);
195 #endif
196 }
197 
198 /**
199  * g_on_error_stack_trace:
200  * @prg_name: the program name, needed by gdb for the &quot;[S]tack trace&quot;
201  *     option
202  *
203  * Invokes gdb, which attaches to the current process and shows a
204  * stack trace. Called by g_on_error_query() when the &quot;[S]tack trace&quot;
205  * option is selected. You can get the current process&#39;s program name
206  * with g_get_prgname(), assuming that you have called gtk_init() or
207  * gdk_init().
208  *
209  * This function may cause different actions on non-UNIX platforms.






210  */
211 void
212 g_on_error_stack_trace (const gchar *prg_name)
213 {
214 #if defined(G_OS_UNIX)
215   pid_t pid;
216   gchar buf[16];
217   const gchar *args[4] = { &quot;gdb&quot;, NULL, NULL, NULL };
218   int status;
219 
220   if (!prg_name)
221     return;
222 
223   _g_sprintf (buf, &quot;%u&quot;, (guint) getpid ());
224 
225   args[1] = prg_name;
226   args[2] = buf;
227 
228   pid = fork ();
229   if (pid == 0)
</pre>
<hr />
<pre>
275   fd_set readset;
276   struct timeval tv;
277   int sel, idx, state;
278   char buffer[256];
279   char c;
280 
281   stack_trace_done = FALSE;
282   signal (SIGCHLD, stack_trace_sigchld);
283 
284   if ((pipe (in_fd) == -1) || (pipe (out_fd) == -1))
285     {
286       perror (&quot;unable to open pipe&quot;);
287       _exit (0);
288     }
289 
290   pid = fork ();
291   if (pid == 0)
292     {
293       /* Save stderr for printing failure below */
294       int old_err = dup (2);
<span class="line-modified">295       fcntl (old_err, F_SETFD, fcntl (old_err, F_GETFD) | FD_CLOEXEC);</span>

296 
297       close (0); dup (in_fd[0]);   /* set the stdin to the in pipe */
298       close (1); dup (out_fd[1]);  /* set the stdout to the out pipe */
299       close (2); dup (out_fd[1]);  /* set the stderr to the out pipe */
300 
301       execvp (args[0], (char **) args);      /* exec gdb */
302 
303       /* Print failure to original stderr */
<span class="line-modified">304       close (2); dup (old_err);</span>




305       perror (&quot;exec gdb failed&quot;);
306       _exit (0);
307     }
308   else if (pid == (pid_t) -1)
309     {
310       perror (&quot;unable to fork&quot;);
311       _exit (0);
312     }
313 
314   FD_ZERO (&amp;fdset);
315   FD_SET (out_fd[0], &amp;fdset);
316 
317   write (in_fd[1], &quot;backtrace\n&quot;, 10);
318   write (in_fd[1], &quot;p x = 0\n&quot;, 8);
319   write (in_fd[1], &quot;quit\n&quot;, 5);
320 
321   idx = 0;
322   state = 0;
323 
324   while (1)
</pre>
</td>
<td>
<hr />
<pre>
108  * {
109  *   g_log_set_handler (MY_LOG_DOMAIN,
110  *                      G_LOG_LEVEL_WARNING |
111  *                      G_LOG_LEVEL_ERROR |
112  *                      G_LOG_LEVEL_CRITICAL,
113  *                      log_handler,
114  *                      NULL);
115  *   ...
116  * ]|
117  *
118  * If &quot;[E]xit&quot; is selected, the application terminates with a call
119  * to _exit(0).
120  *
121  * If &quot;[S]tack&quot; trace is selected, g_on_error_stack_trace() is called.
122  * This invokes gdb, which attaches to the current process and shows
123  * a stack trace. The prompt is then shown again.
124  *
125  * If &quot;[P]roceed&quot; is selected, the function returns.
126  *
127  * This function may cause different actions on non-UNIX platforms.
<span class="line-added">128  *</span>
<span class="line-added">129  * On Windows consider using the `G_DEBUGGER` environment</span>
<span class="line-added">130  * variable (see [Running GLib Applications](glib-running.html)) and</span>
<span class="line-added">131  * calling g_on_error_stack_trace() instead.</span>
132  */
133 void
134 g_on_error_query (const gchar *prg_name)
135 {
136 #ifndef G_OS_WIN32
137   static const gchar * const query1 = &quot;[E]xit, [H]alt&quot;;
138   static const gchar * const query2 = &quot;, show [S]tack trace&quot;;
139   static const gchar * const query3 = &quot; or [P]roceed&quot;;
140   gchar buf[16];
141 
142   if (!prg_name)
143     prg_name = g_get_prgname ();
144 
145  retry:
146 
147   if (prg_name)
148     _g_fprintf (stdout,
149                 &quot;%s (pid:%u): %s%s%s: &quot;,
150                 prg_name,
151                 (guint) getpid (),
</pre>
<hr />
<pre>
175            &amp;&amp; (buf[0] == &#39;S&#39; || buf[0] == &#39;s&#39;)
176            &amp;&amp; buf[1] == &#39;\n&#39;)
177     {
178       g_on_error_stack_trace (prg_name);
179       goto retry;
180     }
181   else if ((buf[0] == &#39;H&#39; || buf[0] == &#39;h&#39;)
182            &amp;&amp; buf[1] == &#39;\n&#39;)
183     {
184       while (glib_on_error_halt)
185         ;
186       glib_on_error_halt = TRUE;
187       return;
188     }
189   else
190     goto retry;
191 #else
192   if (!prg_name)
193     prg_name = g_get_prgname ();
194 
<span class="line-added">195   /* MessageBox is allowed on UWP apps only when building against</span>
<span class="line-added">196    * the debug CRT, which will set -D_DEBUG */</span>
<span class="line-added">197 #if defined(_DEBUG) || !defined(G_WINAPI_ONLY_APP)</span>
198   MessageBox (NULL, &quot;g_on_error_query called, program terminating&quot;,
199               (prg_name &amp;&amp; *prg_name) ? prg_name : NULL,
200               MB_OK|MB_ICONERROR);
<span class="line-added">201 #else</span>
<span class="line-added">202   printf (&quot;g_on_error_query called, program &#39;%s&#39; terminating\n&quot;,</span>
<span class="line-added">203       (prg_name &amp;&amp; *prg_name) ? prg_name : &quot;(null)&quot;);</span>
<span class="line-added">204 #endif</span>
205   _exit(0);
206 #endif
207 }
208 
209 /**
210  * g_on_error_stack_trace:
211  * @prg_name: the program name, needed by gdb for the &quot;[S]tack trace&quot;
212  *     option
213  *
214  * Invokes gdb, which attaches to the current process and shows a
215  * stack trace. Called by g_on_error_query() when the &quot;[S]tack trace&quot;
216  * option is selected. You can get the current process&#39;s program name
217  * with g_get_prgname(), assuming that you have called gtk_init() or
218  * gdk_init().
219  *
220  * This function may cause different actions on non-UNIX platforms.
<span class="line-added">221  *</span>
<span class="line-added">222  * When running on Windows, this function is *not* called by</span>
<span class="line-added">223  * g_on_error_query(). If called directly, it will raise an</span>
<span class="line-added">224  * exception, which will crash the program. If the `G_DEBUGGER` environment</span>
<span class="line-added">225  * variable is set, a debugger will be invoked to attach and</span>
<span class="line-added">226  * handle that exception (see [Running GLib Applications](glib-running.html)).</span>
227  */
228 void
229 g_on_error_stack_trace (const gchar *prg_name)
230 {
231 #if defined(G_OS_UNIX)
232   pid_t pid;
233   gchar buf[16];
234   const gchar *args[4] = { &quot;gdb&quot;, NULL, NULL, NULL };
235   int status;
236 
237   if (!prg_name)
238     return;
239 
240   _g_sprintf (buf, &quot;%u&quot;, (guint) getpid ());
241 
242   args[1] = prg_name;
243   args[2] = buf;
244 
245   pid = fork ();
246   if (pid == 0)
</pre>
<hr />
<pre>
292   fd_set readset;
293   struct timeval tv;
294   int sel, idx, state;
295   char buffer[256];
296   char c;
297 
298   stack_trace_done = FALSE;
299   signal (SIGCHLD, stack_trace_sigchld);
300 
301   if ((pipe (in_fd) == -1) || (pipe (out_fd) == -1))
302     {
303       perror (&quot;unable to open pipe&quot;);
304       _exit (0);
305     }
306 
307   pid = fork ();
308   if (pid == 0)
309     {
310       /* Save stderr for printing failure below */
311       int old_err = dup (2);
<span class="line-modified">312       if (old_err != -1)</span>
<span class="line-added">313         fcntl (old_err, F_SETFD, fcntl (old_err, F_GETFD) | FD_CLOEXEC);</span>
314 
315       close (0); dup (in_fd[0]);   /* set the stdin to the in pipe */
316       close (1); dup (out_fd[1]);  /* set the stdout to the out pipe */
317       close (2); dup (out_fd[1]);  /* set the stderr to the out pipe */
318 
319       execvp (args[0], (char **) args);      /* exec gdb */
320 
321       /* Print failure to original stderr */
<span class="line-modified">322       if (old_err != -1)</span>
<span class="line-added">323         {</span>
<span class="line-added">324           close (2);</span>
<span class="line-added">325           dup (old_err);</span>
<span class="line-added">326         }</span>
327       perror (&quot;exec gdb failed&quot;);
328       _exit (0);
329     }
330   else if (pid == (pid_t) -1)
331     {
332       perror (&quot;unable to fork&quot;);
333       _exit (0);
334     }
335 
336   FD_ZERO (&amp;fdset);
337   FD_SET (out_fd[0], &amp;fdset);
338 
339   write (in_fd[1], &quot;backtrace\n&quot;, 10);
340   write (in_fd[1], &quot;p x = 0\n&quot;, 8);
341   write (in_fd[1], &quot;quit\n&quot;, 5);
342 
343   idx = 0;
344   state = 0;
345 
346   while (1)
</pre>
</td>
</tr>
</table>
<center><a href="gatomic.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gbase64.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>