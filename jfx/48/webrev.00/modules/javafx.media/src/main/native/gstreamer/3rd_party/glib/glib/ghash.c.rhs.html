<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/ghash.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #include &lt;string.h&gt;  /* memset */
  32 
  33 #include &quot;ghash.h&quot;
<a name="1" id="anc1"></a><span class="line-modified">  34 #include &quot;gmacros.h&quot;</span>
  35 #include &quot;glib-private.h&quot;
  36 #include &quot;gstrfuncs.h&quot;
  37 #include &quot;gatomic.h&quot;
  38 #include &quot;gtestutils.h&quot;
  39 #include &quot;gslice.h&quot;
  40 #include &quot;grefcount.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  41 #include &quot;gvalgrind.h&quot;</span>
<span class="line-added">  42 </span>
<span class="line-added">  43 /* The following #pragma is here so we can do this...</span>
<span class="line-added">  44  *</span>
<span class="line-added">  45  *   #ifndef USE_SMALL_ARRAYS</span>
<span class="line-added">  46  *     is_big = TRUE;</span>
<span class="line-added">  47  *   #endif</span>
<span class="line-added">  48  *     return is_big ? *(((gpointer *) a) + index) : GUINT_TO_POINTER (*(((guint *) a) + index));</span>
<span class="line-added">  49  *</span>
<span class="line-added">  50  * ...instead of this...</span>
<span class="line-added">  51  *</span>
<span class="line-added">  52  *   #ifndef USE_SMALL_ARRAYS</span>
<span class="line-added">  53  *     return *(((gpointer *) a) + index);</span>
<span class="line-added">  54  *   #else</span>
<span class="line-added">  55  *     return is_big ? *(((gpointer *) a) + index) : GUINT_TO_POINTER (*(((guint *) a) + index));</span>
<span class="line-added">  56  *   #endif</span>
<span class="line-added">  57  *</span>
<span class="line-added">  58  * ...and still compile successfully when -Werror=duplicated-branches is passed. */</span>
<span class="line-added">  59 </span>
<span class="line-added">  60 #if defined(__GNUC__) &amp;&amp; __GNUC__ &gt; 6</span>
<span class="line-added">  61 #pragma GCC diagnostic ignored &quot;-Wduplicated-branches&quot;</span>
<span class="line-added">  62 #endif</span>
  63 
  64 /**
  65  * SECTION:hash_tables
  66  * @title: Hash Tables
  67  * @short_description: associations between keys and values so that
  68  *     given a key the value can be found quickly
  69  *
  70  * A #GHashTable provides associations between keys and values which is
  71  * optimized so that given a key, the associated value can be found
  72  * very quickly.
  73  *
  74  * Note that neither keys nor values are copied when inserted into the
  75  * #GHashTable, so they must exist for the lifetime of the #GHashTable.
  76  * This means that the use of static strings is OK, but temporary
  77  * strings (i.e. those created in buffers and those returned by GTK+
  78  * widgets) should be copied with g_strdup() before being inserted.
  79  *
  80  * If keys or values are dynamically allocated, you must be careful to
  81  * ensure that they are freed when they are removed from the
  82  * #GHashTable, and also when they are overwritten by new insertions
  83  * into the #GHashTable. It is also not advisable to mix static strings
  84  * and dynamically-allocated strings in a #GHashTable, because it then
  85  * becomes difficult to determine whether the string should be freed.
  86  *
  87  * To create a #GHashTable, use g_hash_table_new().
  88  *
  89  * To insert a key and value into a #GHashTable, use
  90  * g_hash_table_insert().
  91  *
<a name="3" id="anc3"></a><span class="line-modified">  92  * To look up a value corresponding to a given key, use</span>
  93  * g_hash_table_lookup() and g_hash_table_lookup_extended().
  94  *
  95  * g_hash_table_lookup_extended() can also be used to simply
  96  * check if a key is present in the hash table.
  97  *
  98  * To remove a key and value, use g_hash_table_remove().
  99  *
 100  * To call a function for each key and value pair use
<a name="4" id="anc4"></a><span class="line-modified"> 101  * g_hash_table_foreach() or use an iterator to iterate over the</span>
 102  * key/value pairs in the hash table, see #GHashTableIter.
 103  *
 104  * To destroy a #GHashTable use g_hash_table_destroy().
 105  *
 106  * A common use-case for hash tables is to store information about a
 107  * set of keys, without associating any particular value with each
 108  * key. GHashTable optimizes one way of doing so: If you store only
 109  * key-value pairs where key == value, then GHashTable does not
 110  * allocate memory to store the values, which can be a considerable
 111  * space saving, if your set is large. The functions
 112  * g_hash_table_add() and g_hash_table_contains() are designed to be
 113  * used when using #GHashTable this way.
 114  *
 115  * #GHashTable is not designed to be statically initialised with keys and
 116  * values known at compile time. To build a static hash table, use a tool such
 117  * as [gperf](https://www.gnu.org/software/gperf/).
 118  */
 119 
 120 /**
 121  * GHashTable:
 122  *
 123  * The #GHashTable struct is an opaque data structure to represent a
 124  * [Hash Table][glib-Hash-Tables]. It should only be accessed via the
 125  * following functions.
 126  */
 127 
 128 /**
 129  * GHashFunc:
 130  * @key: a key
 131  *
 132  * Specifies the type of the hash function which is passed to
 133  * g_hash_table_new() when a #GHashTable is created.
 134  *
 135  * The function is passed a key and should return a #guint hash value.
 136  * The functions g_direct_hash(), g_int_hash() and g_str_hash() provide
 137  * hash functions which can be used when the key is a #gpointer, #gint*,
 138  * and #gchar* respectively.
 139  *
 140  * g_direct_hash() is also the appropriate hash function for keys
 141  * of the form `GINT_TO_POINTER (n)` (or similar macros).
 142  *
 143  * A good hash functions should produce
 144  * hash values that are evenly distributed over a fairly large range.
 145  * The modulus is taken with the hash table size (a prime number) to
 146  * find the &#39;bucket&#39; to place each key into. The function should also
 147  * be very fast, since it is called for each key lookup.
 148  *
 149  * Note that the hash functions provided by GLib have these qualities,
 150  * but are not particularly robust against manufactured keys that
 151  * cause hash collisions. Therefore, you should consider choosing
 152  * a more secure hash function when using a GHashTable with keys
 153  * that originate in untrusted data (such as HTTP requests).
 154  * Using g_str_hash() in that situation might make your application
 155  * vulerable to
 156  * [Algorithmic Complexity Attacks](https://lwn.net/Articles/474912/).
 157  *
 158  * The key to choosing a good hash is unpredictability.  Even
 159  * cryptographic hashes are very easy to find collisions for when the
 160  * remainder is taken modulo a somewhat predictable prime number.  There
 161  * must be an element of randomness that an attacker is unable to guess.
 162  *
 163  * Returns: the hash value corresponding to the key
 164  */
 165 
 166 /**
 167  * GHFunc:
 168  * @key: a key
 169  * @value: the value corresponding to the key
 170  * @user_data: user data passed to g_hash_table_foreach()
 171  *
 172  * Specifies the type of the function passed to g_hash_table_foreach().
 173  * It is called with each key/value pair, together with the @user_data
 174  * parameter which is passed to g_hash_table_foreach().
 175  */
 176 
 177 /**
 178  * GHRFunc:
 179  * @key: a key
 180  * @value: the value associated with the key
 181  * @user_data: user data passed to g_hash_table_remove()
 182  *
 183  * Specifies the type of the function passed to
 184  * g_hash_table_foreach_remove(). It is called with each key/value
 185  * pair, together with the @user_data parameter passed to
 186  * g_hash_table_foreach_remove(). It should return %TRUE if the
 187  * key/value pair should be removed from the #GHashTable.
 188  *
 189  * Returns: %TRUE if the key/value pair should be removed from the
 190  *     #GHashTable
 191  */
 192 
 193 /**
 194  * GEqualFunc:
 195  * @a: a value
 196  * @b: a value to compare with
 197  *
 198  * Specifies the type of a function used to test two values for
 199  * equality. The function should return %TRUE if both values are equal
 200  * and %FALSE otherwise.
 201  *
 202  * Returns: %TRUE if @a = @b; %FALSE otherwise
 203  */
 204 
 205 /**
 206  * GHashTableIter:
 207  *
 208  * A GHashTableIter structure represents an iterator that can be used
 209  * to iterate over the elements of a #GHashTable. GHashTableIter
 210  * structures are typically allocated on the stack and then initialized
 211  * with g_hash_table_iter_init().
 212  */
 213 
 214 /**
 215  * g_hash_table_freeze:
 216  * @hash_table: a #GHashTable
 217  *
 218  * This function is deprecated and will be removed in the next major
 219  * release of GLib. It does nothing.
 220  */
 221 
 222 /**
 223  * g_hash_table_thaw:
 224  * @hash_table: a #GHashTable
 225  *
 226  * This function is deprecated and will be removed in the next major
 227  * release of GLib. It does nothing.
 228  */
 229 
 230 #define HASH_TABLE_MIN_SHIFT 3  /* 1 &lt;&lt; 3 == 8 buckets */
 231 
 232 #define UNUSED_HASH_VALUE 0
 233 #define TOMBSTONE_HASH_VALUE 1
 234 #define HASH_IS_UNUSED(h_) ((h_) == UNUSED_HASH_VALUE)
 235 #define HASH_IS_TOMBSTONE(h_) ((h_) == TOMBSTONE_HASH_VALUE)
 236 #define HASH_IS_REAL(h_) ((h_) &gt;= 2)
 237 
<a name="5" id="anc5"></a><span class="line-added"> 238 /* If int is smaller than void * on our arch, we start out with</span>
<span class="line-added"> 239  * int-sized keys and values and resize to pointer-sized entries as</span>
<span class="line-added"> 240  * needed. This saves a good amount of memory when the HT is being</span>
<span class="line-added"> 241  * used with e.g. GUINT_TO_POINTER(). */</span>
<span class="line-added"> 242 </span>
<span class="line-added"> 243 #define BIG_ENTRY_SIZE (SIZEOF_VOID_P)</span>
<span class="line-added"> 244 #define SMALL_ENTRY_SIZE (SIZEOF_INT)</span>
<span class="line-added"> 245 </span>
<span class="line-added"> 246 #if SMALL_ENTRY_SIZE &lt; BIG_ENTRY_SIZE</span>
<span class="line-added"> 247 # define USE_SMALL_ARRAYS</span>
<span class="line-added"> 248 #endif</span>
<span class="line-added"> 249 </span>
 250 struct _GHashTable
 251 {
<a name="6" id="anc6"></a><span class="line-modified"> 252   gsize            size;</span>
 253   gint             mod;
 254   guint            mask;
 255   gint             nnodes;
 256   gint             noccupied;  /* nnodes + tombstones */
 257 
<a name="7" id="anc7"></a><span class="line-modified"> 258   guint            have_big_keys : 1;</span>
<span class="line-added"> 259   guint            have_big_values : 1;</span>
<span class="line-added"> 260 </span>
<span class="line-added"> 261   gpointer         keys;</span>
 262   guint           *hashes;
<a name="8" id="anc8"></a><span class="line-modified"> 263   gpointer         values;</span>
 264 
 265   GHashFunc        hash_func;
 266   GEqualFunc       key_equal_func;
 267   gatomicrefcount  ref_count;
 268 #ifndef G_DISABLE_ASSERT
 269   /*
 270    * Tracks the structure of the hash table, not its contents: is only
 271    * incremented when a node is added or removed (is not incremented
 272    * when the key or data of a node is modified).
 273    */
 274   int              version;
 275 #endif
 276   GDestroyNotify   key_destroy_func;
 277   GDestroyNotify   value_destroy_func;
 278 };
 279 
 280 typedef struct
 281 {
 282   GHashTable  *hash_table;
 283   gpointer     dummy1;
 284   gpointer     dummy2;
<a name="9" id="anc9"></a><span class="line-modified"> 285   gint         position;</span>
 286   gboolean     dummy3;
<a name="10" id="anc10"></a><span class="line-modified"> 287   gint         version;</span>
 288 } RealIter;
 289 
 290 G_STATIC_ASSERT (sizeof (GHashTableIter) == sizeof (RealIter));
<a name="11" id="anc11"></a><span class="line-modified"> 291 G_STATIC_ASSERT (G_ALIGNOF (GHashTableIter) &gt;= G_ALIGNOF (RealIter));</span>
 292 
 293 /* Each table size has an associated prime modulo (the first prime
 294  * lower than the table size) used to find the initial bucket. Probing
 295  * then works modulo 2^n. The prime modulo is necessary to get a
 296  * good distribution with poor hash functions.
 297  */
 298 static const gint prime_mod [] =
 299 {
 300   1,          /* For 1 &lt;&lt; 0 */
 301   2,
 302   3,
 303   7,
 304   13,
 305   31,
 306   61,
 307   127,
 308   251,
 309   509,
 310   1021,
 311   2039,
 312   4093,
 313   8191,
 314   16381,
 315   32749,
 316   65521,      /* For 1 &lt;&lt; 16 */
 317   131071,
 318   262139,
 319   524287,
 320   1048573,
 321   2097143,
 322   4194301,
 323   8388593,
 324   16777213,
 325   33554393,
 326   67108859,
 327   134217689,
 328   268435399,
 329   536870909,
 330   1073741789,
 331   2147483647  /* For 1 &lt;&lt; 31 */
 332 };
 333 
 334 static void
 335 g_hash_table_set_shift (GHashTable *hash_table, gint shift)
 336 {
<a name="12" id="anc12"></a>


 337   hash_table-&gt;size = 1 &lt;&lt; shift;
 338   hash_table-&gt;mod  = prime_mod [shift];
 339 
<a name="13" id="anc13"></a><span class="line-modified"> 340   /* hash_table-&gt;size is always a power of two, so we can calculate the mask</span>
<span class="line-modified"> 341    * by simply subtracting 1 from it. The leading assertion ensures that</span>
<span class="line-modified"> 342    * we&#39;re really dealing with a power of two. */</span>


 343 
<a name="14" id="anc14"></a><span class="line-modified"> 344   g_assert ((hash_table-&gt;size &amp; (hash_table-&gt;size - 1)) == 0);</span>
<span class="line-added"> 345   hash_table-&gt;mask = hash_table-&gt;size - 1;</span>
 346 }
 347 
 348 static gint
 349 g_hash_table_find_closest_shift (gint n)
 350 {
 351   gint i;
 352 
 353   for (i = 0; n; i++)
 354     n &gt;&gt;= 1;
 355 
 356   return i;
 357 }
 358 
 359 static void
 360 g_hash_table_set_shift_from_size (GHashTable *hash_table, gint size)
 361 {
 362   gint shift;
 363 
 364   shift = g_hash_table_find_closest_shift (size);
 365   shift = MAX (shift, HASH_TABLE_MIN_SHIFT);
 366 
 367   g_hash_table_set_shift (hash_table, shift);
 368 }
 369 
<a name="15" id="anc15"></a><span class="line-added"> 370 static inline gpointer</span>
<span class="line-added"> 371 g_hash_table_realloc_key_or_value_array (gpointer a, guint size, G_GNUC_UNUSED gboolean is_big)</span>
<span class="line-added"> 372 {</span>
<span class="line-added"> 373 #ifdef USE_SMALL_ARRAYS</span>
<span class="line-added"> 374   return g_realloc (a, size * (is_big ? BIG_ENTRY_SIZE : SMALL_ENTRY_SIZE));</span>
<span class="line-added"> 375 #else</span>
<span class="line-added"> 376   return g_renew (gpointer, a, size);</span>
<span class="line-added"> 377 #endif</span>
<span class="line-added"> 378 }</span>
<span class="line-added"> 379 </span>
<span class="line-added"> 380 static inline gpointer</span>
<span class="line-added"> 381 g_hash_table_fetch_key_or_value (gpointer a, guint index, gboolean is_big)</span>
<span class="line-added"> 382 {</span>
<span class="line-added"> 383 #ifndef USE_SMALL_ARRAYS</span>
<span class="line-added"> 384   is_big = TRUE;</span>
<span class="line-added"> 385 #endif</span>
<span class="line-added"> 386   return is_big ? *(((gpointer *) a) + index) : GUINT_TO_POINTER (*(((guint *) a) + index));</span>
<span class="line-added"> 387 }</span>
<span class="line-added"> 388 </span>
<span class="line-added"> 389 static inline void</span>
<span class="line-added"> 390 g_hash_table_assign_key_or_value (gpointer a, guint index, gboolean is_big, gpointer v)</span>
<span class="line-added"> 391 {</span>
<span class="line-added"> 392 #ifndef USE_SMALL_ARRAYS</span>
<span class="line-added"> 393   is_big = TRUE;</span>
<span class="line-added"> 394 #endif</span>
<span class="line-added"> 395   if (is_big)</span>
<span class="line-added"> 396     *(((gpointer *) a) + index) = v;</span>
<span class="line-added"> 397   else</span>
<span class="line-added"> 398     *(((guint *) a) + index) = GPOINTER_TO_UINT (v);</span>
<span class="line-added"> 399 }</span>
<span class="line-added"> 400 </span>
<span class="line-added"> 401 static inline gpointer</span>
<span class="line-added"> 402 g_hash_table_evict_key_or_value (gpointer a, guint index, gboolean is_big, gpointer v)</span>
<span class="line-added"> 403 {</span>
<span class="line-added"> 404 #ifndef USE_SMALL_ARRAYS</span>
<span class="line-added"> 405   is_big = TRUE;</span>
<span class="line-added"> 406 #endif</span>
<span class="line-added"> 407   if (is_big)</span>
<span class="line-added"> 408     {</span>
<span class="line-added"> 409       gpointer r = *(((gpointer *) a) + index);</span>
<span class="line-added"> 410       *(((gpointer *) a) + index) = v;</span>
<span class="line-added"> 411       return r;</span>
<span class="line-added"> 412     }</span>
<span class="line-added"> 413   else</span>
<span class="line-added"> 414     {</span>
<span class="line-added"> 415       gpointer r = GUINT_TO_POINTER (*(((guint *) a) + index));</span>
<span class="line-added"> 416       *(((guint *) a) + index) = GPOINTER_TO_UINT (v);</span>
<span class="line-added"> 417       return r;</span>
<span class="line-added"> 418     }</span>
<span class="line-added"> 419 }</span>
<span class="line-added"> 420 </span>
<span class="line-added"> 421 static inline guint</span>
<span class="line-added"> 422 g_hash_table_hash_to_index (GHashTable *hash_table, guint hash)</span>
<span class="line-added"> 423 {</span>
<span class="line-added"> 424   /* Multiply the hash by a small prime before applying the modulo. This</span>
<span class="line-added"> 425    * prevents the table from becoming densely packed, even with a poor hash</span>
<span class="line-added"> 426    * function. A densely packed table would have poor performance on</span>
<span class="line-added"> 427    * workloads with many failed lookups or a high degree of churn. */</span>
<span class="line-added"> 428   return (hash * 11) % hash_table-&gt;mod;</span>
<span class="line-added"> 429 }</span>
<span class="line-added"> 430 </span>
 431 /*
 432  * g_hash_table_lookup_node:
 433  * @hash_table: our #GHashTable
<a name="16" id="anc16"></a><span class="line-modified"> 434  * @key: the key to look up against</span>
 435  * @hash_return: key hash return location
 436  *
 437  * Performs a lookup in the hash table, preserving extra information
 438  * usually needed for insertion.
 439  *
 440  * This function first computes the hash value of the key using the
 441  * user&#39;s hash function.
 442  *
 443  * If an entry in the table matching @key is found then this function
 444  * returns the index of that entry in the table, and if not, the
 445  * index of an unused node (empty or tombstone) where the key can be
 446  * inserted.
 447  *
 448  * The computed hash value is returned in the variable pointed to
 449  * by @hash_return. This is to save insertions from having to compute
 450  * the hash record again for the new record.
 451  *
 452  * Returns: index of the described node
 453  */
 454 static inline guint
 455 g_hash_table_lookup_node (GHashTable    *hash_table,
 456                           gconstpointer  key,
 457                           guint         *hash_return)
 458 {
 459   guint node_index;
 460   guint node_hash;
 461   guint hash_value;
 462   guint first_tombstone = 0;
 463   gboolean have_tombstone = FALSE;
 464   guint step = 0;
 465 
 466   /* If this happens, then the application is probably doing too much work
 467    * from a destroy notifier. The alternative would be to crash any second
 468    * (as keys, etc. will be NULL).
 469    * Applications need to either use g_hash_table_destroy, or ensure the hash
 470    * table is empty prior to removing the last reference using g_hash_table_unref(). */
 471   g_assert (!g_atomic_ref_count_compare (&amp;hash_table-&gt;ref_count, 0));
 472 
 473   hash_value = hash_table-&gt;hash_func (key);
 474   if (G_UNLIKELY (!HASH_IS_REAL (hash_value)))
 475     hash_value = 2;
 476 
 477   *hash_return = hash_value;
 478 
<a name="17" id="anc17"></a><span class="line-modified"> 479   node_index = g_hash_table_hash_to_index (hash_table, hash_value);</span>
 480   node_hash = hash_table-&gt;hashes[node_index];
 481 
 482   while (!HASH_IS_UNUSED (node_hash))
 483     {
 484       /* We first check if our full hash values
 485        * are equal so we can avoid calling the full-blown
 486        * key equality function in most cases.
 487        */
 488       if (node_hash == hash_value)
 489         {
<a name="18" id="anc18"></a><span class="line-modified"> 490           gpointer node_key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys);</span>
 491 
 492           if (hash_table-&gt;key_equal_func)
 493             {
 494               if (hash_table-&gt;key_equal_func (node_key, key))
 495                 return node_index;
 496             }
 497           else if (node_key == key)
 498             {
 499               return node_index;
 500             }
 501         }
 502       else if (HASH_IS_TOMBSTONE (node_hash) &amp;&amp; !have_tombstone)
 503         {
 504           first_tombstone = node_index;
 505           have_tombstone = TRUE;
 506         }
 507 
 508       step++;
 509       node_index += step;
 510       node_index &amp;= hash_table-&gt;mask;
 511       node_hash = hash_table-&gt;hashes[node_index];
 512     }
 513 
 514   if (have_tombstone)
 515     return first_tombstone;
 516 
 517   return node_index;
 518 }
 519 
 520 /*
 521  * g_hash_table_remove_node:
 522  * @hash_table: our #GHashTable
 523  * @node: pointer to node to remove
 524  * @notify: %TRUE if the destroy notify handlers are to be called
 525  *
 526  * Removes a node from the hash table and updates the node count.
 527  * The node is replaced by a tombstone. No table resize is performed.
 528  *
 529  * If @notify is %TRUE then the destroy notify functions are called
 530  * for the key and value of the hash node.
 531  */
 532 static void
 533 g_hash_table_remove_node (GHashTable   *hash_table,
 534                           gint          i,
 535                           gboolean      notify)
 536 {
 537   gpointer key;
 538   gpointer value;
 539 
<a name="19" id="anc19"></a><span class="line-modified"> 540   key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys);</span>
<span class="line-modified"> 541   value = g_hash_table_fetch_key_or_value (hash_table-&gt;values, i, hash_table-&gt;have_big_values);</span>
 542 
 543   /* Erect tombstone */
 544   hash_table-&gt;hashes[i] = TOMBSTONE_HASH_VALUE;
 545 
 546   /* Be GC friendly */
<a name="20" id="anc20"></a><span class="line-modified"> 547   g_hash_table_assign_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys, NULL);</span>
<span class="line-modified"> 548   g_hash_table_assign_key_or_value (hash_table-&gt;values, i, hash_table-&gt;have_big_values, NULL);</span>
 549 
 550   hash_table-&gt;nnodes--;
 551 
 552   if (notify &amp;&amp; hash_table-&gt;key_destroy_func)
 553     hash_table-&gt;key_destroy_func (key);
 554 
 555   if (notify &amp;&amp; hash_table-&gt;value_destroy_func)
 556     hash_table-&gt;value_destroy_func (value);
 557 
 558 }
 559 
<a name="21" id="anc21"></a><span class="line-added"> 560 /*</span>
<span class="line-added"> 561  * g_hash_table_setup_storage:</span>
<span class="line-added"> 562  * @hash_table: our #GHashTable</span>
<span class="line-added"> 563  *</span>
<span class="line-added"> 564  * Initialise the hash table size, mask, mod, and arrays.</span>
<span class="line-added"> 565  */</span>
<span class="line-added"> 566 static void</span>
<span class="line-added"> 567 g_hash_table_setup_storage (GHashTable *hash_table)</span>
<span class="line-added"> 568 {</span>
<span class="line-added"> 569   gboolean small;</span>
<span class="line-added"> 570 </span>
<span class="line-added"> 571   /* We want to use small arrays only if:</span>
<span class="line-added"> 572    *   - we are running on a system where that makes sense (64 bit); and</span>
<span class="line-added"> 573    *   - we are not running under valgrind.</span>
<span class="line-added"> 574    */</span>
<span class="line-added"> 575   small = FALSE;</span>
<span class="line-added"> 576 </span>
<span class="line-added"> 577 #ifdef USE_SMALL_ARRAYS</span>
<span class="line-added"> 578   small = TRUE;</span>
<span class="line-added"> 579 </span>
<span class="line-added"> 580 # ifdef ENABLE_VALGRIND</span>
<span class="line-added"> 581   if (RUNNING_ON_VALGRIND)</span>
<span class="line-added"> 582     small = FALSE;</span>
<span class="line-added"> 583 # endif</span>
<span class="line-added"> 584 #endif</span>
<span class="line-added"> 585 </span>
<span class="line-added"> 586   g_hash_table_set_shift (hash_table, HASH_TABLE_MIN_SHIFT);</span>
<span class="line-added"> 587 </span>
<span class="line-added"> 588   hash_table-&gt;have_big_keys = !small;</span>
<span class="line-added"> 589   hash_table-&gt;have_big_values = !small;</span>
<span class="line-added"> 590 </span>
<span class="line-added"> 591   hash_table-&gt;keys   = g_hash_table_realloc_key_or_value_array (NULL, hash_table-&gt;size, hash_table-&gt;have_big_keys);</span>
<span class="line-added"> 592   hash_table-&gt;values = hash_table-&gt;keys;</span>
<span class="line-added"> 593   hash_table-&gt;hashes = g_new0 (guint, hash_table-&gt;size);</span>
<span class="line-added"> 594 }</span>
<span class="line-added"> 595 </span>
 596 /*
 597  * g_hash_table_remove_all_nodes:
 598  * @hash_table: our #GHashTable
 599  * @notify: %TRUE if the destroy notify handlers are to be called
 600  *
<a name="22" id="anc22"></a><span class="line-modified"> 601  * Removes all nodes from the table.</span>

 602  *
 603  * If @notify is %TRUE then the destroy notify functions are called
 604  * for the key and value of the hash node.
<a name="23" id="anc23"></a><span class="line-added"> 605  *</span>
<span class="line-added"> 606  * Since this may be a precursor to freeing the table entirely, we&#39;d</span>
<span class="line-added"> 607  * ideally perform no resize, and we can indeed avoid that in some</span>
<span class="line-added"> 608  * cases.  However: in the case that we&#39;ll be making callbacks to user</span>
<span class="line-added"> 609  * code (via destroy notifies) we need to consider that the user code</span>
<span class="line-added"> 610  * might call back into the table again.  In this case, we setup a new</span>
<span class="line-added"> 611  * set of arrays so that any callers will see an empty (but valid)</span>
<span class="line-added"> 612  * table.</span>
 613  */
 614 static void
 615 g_hash_table_remove_all_nodes (GHashTable *hash_table,
 616                                gboolean    notify,
 617                                gboolean    destruction)
 618 {
 619   int i;
 620   gpointer key;
 621   gpointer value;
 622   gint old_size;
 623   gpointer *old_keys;
 624   gpointer *old_values;
 625   guint    *old_hashes;
<a name="24" id="anc24"></a><span class="line-added"> 626   gboolean  old_have_big_keys;</span>
<span class="line-added"> 627   gboolean  old_have_big_values;</span>
 628 
 629   /* If the hash table is already empty, there is nothing to be done. */
 630   if (hash_table-&gt;nnodes == 0)
 631     return;
 632 
 633   hash_table-&gt;nnodes = 0;
 634   hash_table-&gt;noccupied = 0;
 635 
<a name="25" id="anc25"></a><span class="line-added"> 636   /* Easy case: no callbacks, so we just zero out the arrays */</span>
 637   if (!notify ||
 638       (hash_table-&gt;key_destroy_func == NULL &amp;&amp;
 639        hash_table-&gt;value_destroy_func == NULL))
 640     {
 641       if (!destruction)
 642         {
<a name="26" id="anc26"></a><span class="line-modified"> 643           memset (hash_table-&gt;hashes, 0, hash_table-&gt;size * sizeof (guint));</span>
<span class="line-modified"> 644 </span>
<span class="line-modified"> 645 #ifdef USE_SMALL_ARRAYS</span>
<span class="line-added"> 646           memset (hash_table-&gt;keys, 0, hash_table-&gt;size * (hash_table-&gt;have_big_keys ? BIG_ENTRY_SIZE : SMALL_ENTRY_SIZE));</span>
<span class="line-added"> 647           memset (hash_table-&gt;values, 0, hash_table-&gt;size * (hash_table-&gt;have_big_values ? BIG_ENTRY_SIZE : SMALL_ENTRY_SIZE));</span>
<span class="line-added"> 648 #else</span>
<span class="line-added"> 649           memset (hash_table-&gt;keys, 0, hash_table-&gt;size * sizeof (gpointer));</span>
<span class="line-added"> 650           memset (hash_table-&gt;values, 0, hash_table-&gt;size * sizeof (gpointer));</span>
<span class="line-added"> 651 #endif</span>
 652         }
 653 
 654       return;
 655     }
 656 
<a name="27" id="anc27"></a><span class="line-modified"> 657   /* Hard case: we need to do user callbacks.  There are two</span>
<span class="line-added"> 658    * possibilities here:</span>
<span class="line-added"> 659    *</span>
<span class="line-added"> 660    *   1) there are no outstanding references on the table and therefore</span>
<span class="line-added"> 661    *   nobody should be calling into it again (destroying == true)</span>
<span class="line-added"> 662    *</span>
<span class="line-added"> 663    *   2) there are outstanding references, and there may be future</span>
<span class="line-added"> 664    *   calls into the table, either after we return, or from the destroy</span>
<span class="line-added"> 665    *   notifies that we&#39;re about to do (destroying == false)</span>
<span class="line-added"> 666    *</span>
<span class="line-added"> 667    * We handle both cases by taking the current state of the table into</span>
<span class="line-added"> 668    * local variables and replacing it with something else: in the &quot;no</span>
<span class="line-added"> 669    * outstanding references&quot; cases we replace it with a bunch of</span>
<span class="line-added"> 670    * null/zero values so that any access to the table will fail.  In the</span>
<span class="line-added"> 671    * &quot;may receive future calls&quot; case, we reinitialise the struct to</span>
<span class="line-added"> 672    * appear like a newly-created empty table.</span>
<span class="line-added"> 673    *</span>
<span class="line-added"> 674    * In both cases, we take over the references for the current state,</span>
<span class="line-added"> 675    * freeing them below.</span>
<span class="line-added"> 676    */</span>
 677   old_size = hash_table-&gt;size;
<a name="28" id="anc28"></a><span class="line-modified"> 678   old_have_big_keys = hash_table-&gt;have_big_keys;</span>
<span class="line-modified"> 679   old_have_big_values = hash_table-&gt;have_big_values;</span>
<span class="line-modified"> 680   old_keys   = g_steal_pointer (&amp;hash_table-&gt;keys);</span>
<span class="line-modified"> 681   old_values = g_steal_pointer (&amp;hash_table-&gt;values);</span>
<span class="line-modified"> 682   old_hashes = g_steal_pointer (&amp;hash_table-&gt;hashes);</span>
<span class="line-modified"> 683 </span>





 684   if (!destruction)
<a name="29" id="anc29"></a><span class="line-modified"> 685     /* Any accesses will see an empty table */</span>
<span class="line-modified"> 686     g_hash_table_setup_storage (hash_table);</span>



 687   else
<a name="30" id="anc30"></a><span class="line-modified"> 688     /* Will cause a quick crash on any attempted access */</span>
<span class="line-modified"> 689     hash_table-&gt;size = hash_table-&gt;mod = hash_table-&gt;mask = 0;</span>



 690 
<a name="31" id="anc31"></a><span class="line-added"> 691   /* Now do the actual destroy notifies */</span>
 692   for (i = 0; i &lt; old_size; i++)
 693     {
 694       if (HASH_IS_REAL (old_hashes[i]))
 695         {
<a name="32" id="anc32"></a><span class="line-modified"> 696           key = g_hash_table_fetch_key_or_value (old_keys, i, old_have_big_keys);</span>
<span class="line-modified"> 697           value = g_hash_table_fetch_key_or_value (old_values, i, old_have_big_values);</span>
 698 
 699           old_hashes[i] = UNUSED_HASH_VALUE;
<a name="33" id="anc33"></a><span class="line-modified"> 700 </span>
<span class="line-modified"> 701           g_hash_table_assign_key_or_value (old_keys, i, old_have_big_keys, NULL);</span>
<span class="line-added"> 702           g_hash_table_assign_key_or_value (old_values, i, old_have_big_values, NULL);</span>
 703 
 704           if (hash_table-&gt;key_destroy_func != NULL)
 705             hash_table-&gt;key_destroy_func (key);
 706 
 707           if (hash_table-&gt;value_destroy_func != NULL)
 708             hash_table-&gt;value_destroy_func (value);
 709         }
<a name="34" id="anc34"></a><span class="line-modified"> 710     }</span>
 711 
 712   /* Destroy old storage space. */
 713   if (old_keys != old_values)
 714     g_free (old_values);
 715 
 716   g_free (old_keys);
 717   g_free (old_hashes);
<a name="35" id="anc35"></a><span class="line-modified"> 718 }</span>
<span class="line-added"> 719 </span>
<span class="line-added"> 720 static void</span>
<span class="line-added"> 721 realloc_arrays (GHashTable *hash_table, gboolean is_a_set)</span>
<span class="line-added"> 722 {</span>
<span class="line-added"> 723   hash_table-&gt;hashes = g_renew (guint, hash_table-&gt;hashes, hash_table-&gt;size);</span>
<span class="line-added"> 724   hash_table-&gt;keys = g_hash_table_realloc_key_or_value_array (hash_table-&gt;keys, hash_table-&gt;size, hash_table-&gt;have_big_keys);</span>
<span class="line-added"> 725 </span>
<span class="line-added"> 726   if (is_a_set)</span>
<span class="line-added"> 727     hash_table-&gt;values = hash_table-&gt;keys;</span>
<span class="line-added"> 728   else</span>
<span class="line-added"> 729     hash_table-&gt;values = g_hash_table_realloc_key_or_value_array (hash_table-&gt;values, hash_table-&gt;size, hash_table-&gt;have_big_values);</span>
<span class="line-added"> 730 }</span>
<span class="line-added"> 731 </span>
<span class="line-added"> 732 /* When resizing the table in place, we use a temporary bit array to keep</span>
<span class="line-added"> 733  * track of which entries have been assigned a proper location in the new</span>
<span class="line-added"> 734  * table layout.</span>
<span class="line-added"> 735  *</span>
<span class="line-added"> 736  * Each bit corresponds to a bucket. A bit is set if an entry was assigned</span>
<span class="line-added"> 737  * its corresponding location during the resize and thus should not be</span>
<span class="line-added"> 738  * evicted. The array starts out cleared to zero. */</span>
<span class="line-added"> 739 </span>
<span class="line-added"> 740 static inline gboolean</span>
<span class="line-added"> 741 get_status_bit (const guint32 *bitmap, guint index)</span>
<span class="line-added"> 742 {</span>
<span class="line-added"> 743   return (bitmap[index / 32] &gt;&gt; (index % 32)) &amp; 1;</span>
<span class="line-added"> 744 }</span>
<span class="line-added"> 745 </span>
<span class="line-added"> 746 static inline void</span>
<span class="line-added"> 747 set_status_bit (guint32 *bitmap, guint index)</span>
<span class="line-added"> 748 {</span>
<span class="line-added"> 749   bitmap[index / 32] |= 1U &lt;&lt; (index % 32);</span>
<span class="line-added"> 750 }</span>
<span class="line-added"> 751 </span>
<span class="line-added"> 752 /* By calling dedicated resize functions for sets and maps, we avoid 2x</span>
<span class="line-added"> 753  * test-and-branch per key in the inner loop. This yields a small</span>
<span class="line-added"> 754  * performance improvement at the cost of a bit of macro gunk. */</span>
<span class="line-added"> 755 </span>
<span class="line-added"> 756 #define DEFINE_RESIZE_FUNC(fname) \</span>
<span class="line-added"> 757 static void fname (GHashTable *hash_table, guint old_size, guint32 *reallocated_buckets_bitmap) \</span>
<span class="line-added"> 758 {                                                                       \</span>
<span class="line-added"> 759   guint i;                                                              \</span>
<span class="line-added"> 760                                                                         \</span>
<span class="line-added"> 761   for (i = 0; i &lt; old_size; i++)                                        \</span>
<span class="line-added"> 762     {                                                                   \</span>
<span class="line-added"> 763       guint node_hash = hash_table-&gt;hashes[i];                          \</span>
<span class="line-added"> 764       gpointer key, value G_GNUC_UNUSED;                                \</span>
<span class="line-added"> 765                                                                         \</span>
<span class="line-added"> 766       if (!HASH_IS_REAL (node_hash))                                    \</span>
<span class="line-added"> 767         {                                                               \</span>
<span class="line-added"> 768           /* Clear tombstones */                                        \</span>
<span class="line-added"> 769           hash_table-&gt;hashes[i] = UNUSED_HASH_VALUE;                    \</span>
<span class="line-added"> 770           continue;                                                     \</span>
<span class="line-added"> 771         }                                                               \</span>
<span class="line-added"> 772                                                                         \</span>
<span class="line-added"> 773       /* Skip entries relocated through eviction */                     \</span>
<span class="line-added"> 774       if (get_status_bit (reallocated_buckets_bitmap, i))               \</span>
<span class="line-added"> 775         continue;                                                       \</span>
<span class="line-added"> 776                                                                         \</span>
<span class="line-added"> 777       hash_table-&gt;hashes[i] = UNUSED_HASH_VALUE;                        \</span>
<span class="line-added"> 778       EVICT_KEYVAL (hash_table, i, NULL, NULL, key, value);             \</span>
<span class="line-added"> 779                                                                         \</span>
<span class="line-added"> 780       for (;;)                                                          \</span>
<span class="line-added"> 781         {                                                               \</span>
<span class="line-added"> 782           guint hash_val;                                               \</span>
<span class="line-added"> 783           guint replaced_hash;                                          \</span>
<span class="line-added"> 784           guint step = 0;                                               \</span>
<span class="line-added"> 785                                                                         \</span>
<span class="line-added"> 786           hash_val = g_hash_table_hash_to_index (hash_table, node_hash); \</span>
<span class="line-added"> 787                                                                         \</span>
<span class="line-added"> 788           while (get_status_bit (reallocated_buckets_bitmap, hash_val)) \</span>
<span class="line-added"> 789             {                                                           \</span>
<span class="line-added"> 790               step++;                                                   \</span>
<span class="line-added"> 791               hash_val += step;                                         \</span>
<span class="line-added"> 792               hash_val &amp;= hash_table-&gt;mask;                             \</span>
<span class="line-added"> 793             }                                                           \</span>
<span class="line-added"> 794                                                                         \</span>
<span class="line-added"> 795           set_status_bit (reallocated_buckets_bitmap, hash_val);        \</span>
<span class="line-added"> 796                                                                         \</span>
<span class="line-added"> 797           replaced_hash = hash_table-&gt;hashes[hash_val];                 \</span>
<span class="line-added"> 798           hash_table-&gt;hashes[hash_val] = node_hash;                     \</span>
<span class="line-added"> 799           if (!HASH_IS_REAL (replaced_hash))                            \</span>
<span class="line-added"> 800             {                                                           \</span>
<span class="line-added"> 801               ASSIGN_KEYVAL (hash_table, hash_val, key, value);         \</span>
<span class="line-added"> 802               break;                                                    \</span>
<span class="line-added"> 803             }                                                           \</span>
<span class="line-added"> 804                                                                         \</span>
<span class="line-added"> 805           node_hash = replaced_hash;                                    \</span>
<span class="line-added"> 806           EVICT_KEYVAL (hash_table, hash_val, key, value, key, value);  \</span>
<span class="line-added"> 807         }                                                               \</span>
<span class="line-added"> 808     }                                                                   \</span>
<span class="line-added"> 809 }</span>
<span class="line-added"> 810 </span>
<span class="line-added"> 811 #define ASSIGN_KEYVAL(ht, index, key, value) G_STMT_START{ \</span>
<span class="line-added"> 812     g_hash_table_assign_key_or_value ((ht)-&gt;keys, (index), (ht)-&gt;have_big_keys, (key)); \</span>
<span class="line-added"> 813     g_hash_table_assign_key_or_value ((ht)-&gt;values, (index), (ht)-&gt;have_big_values, (value)); \</span>
<span class="line-added"> 814   }G_STMT_END</span>
<span class="line-added"> 815 </span>
<span class="line-added"> 816 #define EVICT_KEYVAL(ht, index, key, value, outkey, outvalue) G_STMT_START{ \</span>
<span class="line-added"> 817     (outkey) = g_hash_table_evict_key_or_value ((ht)-&gt;keys, (index), (ht)-&gt;have_big_keys, (key)); \</span>
<span class="line-added"> 818     (outvalue) = g_hash_table_evict_key_or_value ((ht)-&gt;values, (index), (ht)-&gt;have_big_values, (value)); \</span>
<span class="line-added"> 819   }G_STMT_END</span>
<span class="line-added"> 820 </span>
<span class="line-added"> 821 DEFINE_RESIZE_FUNC (resize_map)</span>
<span class="line-added"> 822 </span>
<span class="line-added"> 823 #undef ASSIGN_KEYVAL</span>
<span class="line-added"> 824 #undef EVICT_KEYVAL</span>
<span class="line-added"> 825 </span>
<span class="line-added"> 826 #define ASSIGN_KEYVAL(ht, index, key, value) G_STMT_START{ \</span>
<span class="line-added"> 827     g_hash_table_assign_key_or_value ((ht)-&gt;keys, (index), (ht)-&gt;have_big_keys, (key)); \</span>
<span class="line-added"> 828   }G_STMT_END</span>
<span class="line-added"> 829 </span>
<span class="line-added"> 830 #define EVICT_KEYVAL(ht, index, key, value, outkey, outvalue) G_STMT_START{ \</span>
<span class="line-added"> 831     (outkey) = g_hash_table_evict_key_or_value ((ht)-&gt;keys, (index), (ht)-&gt;have_big_keys, (key)); \</span>
<span class="line-added"> 832   }G_STMT_END</span>
<span class="line-added"> 833 </span>
<span class="line-added"> 834 DEFINE_RESIZE_FUNC (resize_set)</span>
<span class="line-added"> 835 </span>
<span class="line-added"> 836 #undef ASSIGN_KEYVAL</span>
<span class="line-added"> 837 #undef EVICT_KEYVAL</span>
 838 
 839 /*
 840  * g_hash_table_resize:
 841  * @hash_table: our #GHashTable
 842  *
 843  * Resizes the hash table to the optimal size based on the number of
 844  * nodes currently held. If you call this function then a resize will
 845  * occur, even if one does not need to occur.
 846  * Use g_hash_table_maybe_resize() instead.
 847  *
 848  * This function may &quot;resize&quot; the hash table to its current size, with
 849  * the side effect of cleaning up tombstones and otherwise optimizing
 850  * the probe sequences.
 851  */
 852 static void
 853 g_hash_table_resize (GHashTable *hash_table)
 854 {
<a name="36" id="anc36"></a><span class="line-modified"> 855   guint32 *reallocated_buckets_bitmap;</span>
<span class="line-modified"> 856   gsize old_size;</span>
<span class="line-modified"> 857   gboolean is_a_set;</span>


 858 
 859   old_size = hash_table-&gt;size;
<a name="37" id="anc37"></a><span class="line-modified"> 860   is_a_set = hash_table-&gt;keys == hash_table-&gt;values;</span>













 861 
<a name="38" id="anc38"></a><span class="line-modified"> 862   /* The outer checks in g_hash_table_maybe_resize() will only consider</span>
<span class="line-modified"> 863    * cleanup/resize when the load factor goes below .25 (1/4, ignoring</span>
<span class="line-added"> 864    * tombstones) or above .9375 (15/16, including tombstones).</span>
<span class="line-added"> 865    *</span>
<span class="line-added"> 866    * Once this happens, tombstones will always be cleaned out. If our</span>
<span class="line-added"> 867    * load sans tombstones is greater than .75 (1/1.333, see below), we&#39;ll</span>
<span class="line-added"> 868    * take this opportunity to grow the table too.</span>
<span class="line-added"> 869    *</span>
<span class="line-added"> 870    * Immediately after growing, the load factor will be in the range</span>
<span class="line-added"> 871    * .375 .. .469. After shrinking, it will be exactly .5. */</span>
 872 
<a name="39" id="anc39"></a><span class="line-modified"> 873   g_hash_table_set_shift_from_size (hash_table, hash_table-&gt;nnodes * 1.333);</span>
 874 
<a name="40" id="anc40"></a><span class="line-modified"> 875   if (hash_table-&gt;size &gt; old_size)</span>
<span class="line-modified"> 876     {</span>
<span class="line-modified"> 877       realloc_arrays (hash_table, is_a_set);</span>
<span class="line-modified"> 878       memset (&amp;hash_table-&gt;hashes[old_size], 0, (hash_table-&gt;size - old_size) * sizeof (guint));</span>


 879 
<a name="41" id="anc41"></a><span class="line-modified"> 880       reallocated_buckets_bitmap = g_new0 (guint32, (hash_table-&gt;size + 31) / 32);</span>
<span class="line-modified"> 881     }</span>
<span class="line-modified"> 882   else</span>
<span class="line-added"> 883     {</span>
<span class="line-added"> 884       reallocated_buckets_bitmap = g_new0 (guint32, (old_size + 31) / 32);</span>
 885     }
 886 
<a name="42" id="anc42"></a><span class="line-modified"> 887   if (is_a_set)</span>
<span class="line-modified"> 888     resize_set (hash_table, old_size, reallocated_buckets_bitmap);</span>
<span class="line-added"> 889   else</span>
<span class="line-added"> 890     resize_map (hash_table, old_size, reallocated_buckets_bitmap);</span>
 891 
<a name="43" id="anc43"></a><span class="line-modified"> 892   g_free (reallocated_buckets_bitmap);</span>

 893 
<a name="44" id="anc44"></a><span class="line-modified"> 894   if (hash_table-&gt;size &lt; old_size)</span>
<span class="line-modified"> 895     realloc_arrays (hash_table, is_a_set);</span>

 896 
 897   hash_table-&gt;noccupied = hash_table-&gt;nnodes;
 898 }
 899 
 900 /*
 901  * g_hash_table_maybe_resize:
 902  * @hash_table: our #GHashTable
 903  *
 904  * Resizes the hash table, if needed.
 905  *
 906  * Essentially, calls g_hash_table_resize() if the table has strayed
 907  * too far from its ideal size for its number of nodes.
 908  */
 909 static inline void
 910 g_hash_table_maybe_resize (GHashTable *hash_table)
 911 {
 912   gint noccupied = hash_table-&gt;noccupied;
 913   gint size = hash_table-&gt;size;
 914 
 915   if ((size &gt; hash_table-&gt;nnodes * 4 &amp;&amp; size &gt; 1 &lt;&lt; HASH_TABLE_MIN_SHIFT) ||
 916       (size &lt;= noccupied + (noccupied / 16)))
 917     g_hash_table_resize (hash_table);
 918 }
 919 
<a name="45" id="anc45"></a><span class="line-added"> 920 #ifdef USE_SMALL_ARRAYS</span>
<span class="line-added"> 921 </span>
<span class="line-added"> 922 static inline gboolean</span>
<span class="line-added"> 923 entry_is_big (gpointer v)</span>
<span class="line-added"> 924 {</span>
<span class="line-added"> 925   return (((guintptr) v) &gt;&gt; ((BIG_ENTRY_SIZE - SMALL_ENTRY_SIZE) * 8)) != 0;</span>
<span class="line-added"> 926 }</span>
<span class="line-added"> 927 </span>
<span class="line-added"> 928 static inline gboolean</span>
<span class="line-added"> 929 g_hash_table_maybe_make_big_keys_or_values (gpointer *a_p, gpointer v, gint ht_size)</span>
<span class="line-added"> 930 {</span>
<span class="line-added"> 931   if (entry_is_big (v))</span>
<span class="line-added"> 932     {</span>
<span class="line-added"> 933       guint *a = (guint *) *a_p;</span>
<span class="line-added"> 934       gpointer *a_new;</span>
<span class="line-added"> 935       gint i;</span>
<span class="line-added"> 936 </span>
<span class="line-added"> 937       a_new = g_new (gpointer, ht_size);</span>
<span class="line-added"> 938 </span>
<span class="line-added"> 939       for (i = 0; i &lt; ht_size; i++)</span>
<span class="line-added"> 940         {</span>
<span class="line-added"> 941           a_new[i] = GUINT_TO_POINTER (a[i]);</span>
<span class="line-added"> 942         }</span>
<span class="line-added"> 943 </span>
<span class="line-added"> 944       g_free (a);</span>
<span class="line-added"> 945       *a_p = a_new;</span>
<span class="line-added"> 946       return TRUE;</span>
<span class="line-added"> 947     }</span>
<span class="line-added"> 948 </span>
<span class="line-added"> 949   return FALSE;</span>
<span class="line-added"> 950 }</span>
<span class="line-added"> 951 </span>
<span class="line-added"> 952 #endif</span>
<span class="line-added"> 953 </span>
<span class="line-added"> 954 static inline void</span>
<span class="line-added"> 955 g_hash_table_ensure_keyval_fits (GHashTable *hash_table, gpointer key, gpointer value)</span>
<span class="line-added"> 956 {</span>
<span class="line-added"> 957   gboolean is_a_set = (hash_table-&gt;keys == hash_table-&gt;values);</span>
<span class="line-added"> 958 </span>
<span class="line-added"> 959 #ifdef USE_SMALL_ARRAYS</span>
<span class="line-added"> 960 </span>
<span class="line-added"> 961   /* Convert from set to map? */</span>
<span class="line-added"> 962   if (is_a_set)</span>
<span class="line-added"> 963     {</span>
<span class="line-added"> 964       if (hash_table-&gt;have_big_keys)</span>
<span class="line-added"> 965         {</span>
<span class="line-added"> 966           if (key != value)</span>
<span class="line-added"> 967             hash_table-&gt;values = g_memdup (hash_table-&gt;keys, sizeof (gpointer) * hash_table-&gt;size);</span>
<span class="line-added"> 968           /* Keys and values are both big now, so no need for further checks */</span>
<span class="line-added"> 969           return;</span>
<span class="line-added"> 970         }</span>
<span class="line-added"> 971       else</span>
<span class="line-added"> 972         {</span>
<span class="line-added"> 973           if (key != value)</span>
<span class="line-added"> 974             {</span>
<span class="line-added"> 975               hash_table-&gt;values = g_memdup (hash_table-&gt;keys, sizeof (guint) * hash_table-&gt;size);</span>
<span class="line-added"> 976               is_a_set = FALSE;</span>
<span class="line-added"> 977             }</span>
<span class="line-added"> 978         }</span>
<span class="line-added"> 979     }</span>
<span class="line-added"> 980 </span>
<span class="line-added"> 981   /* Make keys big? */</span>
<span class="line-added"> 982   if (!hash_table-&gt;have_big_keys)</span>
<span class="line-added"> 983     {</span>
<span class="line-added"> 984       hash_table-&gt;have_big_keys = g_hash_table_maybe_make_big_keys_or_values (&amp;hash_table-&gt;keys, key, hash_table-&gt;size);</span>
<span class="line-added"> 985 </span>
<span class="line-added"> 986       if (is_a_set)</span>
<span class="line-added"> 987         {</span>
<span class="line-added"> 988           hash_table-&gt;values = hash_table-&gt;keys;</span>
<span class="line-added"> 989           hash_table-&gt;have_big_values = hash_table-&gt;have_big_keys;</span>
<span class="line-added"> 990         }</span>
<span class="line-added"> 991     }</span>
<span class="line-added"> 992 </span>
<span class="line-added"> 993   /* Make values big? */</span>
<span class="line-added"> 994   if (!is_a_set &amp;&amp; !hash_table-&gt;have_big_values)</span>
<span class="line-added"> 995     {</span>
<span class="line-added"> 996       hash_table-&gt;have_big_values = g_hash_table_maybe_make_big_keys_or_values (&amp;hash_table-&gt;values, value, hash_table-&gt;size);</span>
<span class="line-added"> 997     }</span>
<span class="line-added"> 998 </span>
<span class="line-added"> 999 #else</span>
<span class="line-added">1000 </span>
<span class="line-added">1001   /* Just split if necessary */</span>
<span class="line-added">1002   if (is_a_set &amp;&amp; key != value)</span>
<span class="line-added">1003     hash_table-&gt;values = g_memdup (hash_table-&gt;keys, sizeof (gpointer) * hash_table-&gt;size);</span>
<span class="line-added">1004 </span>
<span class="line-added">1005 #endif</span>
<span class="line-added">1006 }</span>
<span class="line-added">1007 </span>
1008 /**
1009  * g_hash_table_new:
1010  * @hash_func: a function to create a hash value from a key
1011  * @key_equal_func: a function to check two keys for equality
1012  *
1013  * Creates a new #GHashTable with a reference count of 1.
1014  *
1015  * Hash values returned by @hash_func are used to determine where keys
1016  * are stored within the #GHashTable data structure. The g_direct_hash(),
1017  * g_int_hash(), g_int64_hash(), g_double_hash() and g_str_hash()
1018  * functions are provided for some common types of keys.
1019  * If @hash_func is %NULL, g_direct_hash() is used.
1020  *
1021  * @key_equal_func is used when looking up keys in the #GHashTable.
1022  * The g_direct_equal(), g_int_equal(), g_int64_equal(), g_double_equal()
1023  * and g_str_equal() functions are provided for the most common types
1024  * of keys. If @key_equal_func is %NULL, keys are compared directly in
1025  * a similar fashion to g_direct_equal(), but without the overhead of
1026  * a function call. @key_equal_func is called with the key from the hash table
1027  * as its first parameter, and the user-provided key to check against as
1028  * its second.
1029  *
1030  * Returns: a new #GHashTable
1031  */
1032 GHashTable *
1033 g_hash_table_new (GHashFunc  hash_func,
1034                   GEqualFunc key_equal_func)
1035 {
1036   return g_hash_table_new_full (hash_func, key_equal_func, NULL, NULL);
1037 }
1038 
1039 
1040 /**
1041  * g_hash_table_new_full:
1042  * @hash_func: a function to create a hash value from a key
1043  * @key_equal_func: a function to check two keys for equality
1044  * @key_destroy_func: (nullable): a function to free the memory allocated for the key
1045  *     used when removing the entry from the #GHashTable, or %NULL
1046  *     if you don&#39;t want to supply such a function.
1047  * @value_destroy_func: (nullable): a function to free the memory allocated for the
1048  *     value used when removing the entry from the #GHashTable, or %NULL
1049  *     if you don&#39;t want to supply such a function.
1050  *
1051  * Creates a new #GHashTable like g_hash_table_new() with a reference
1052  * count of 1 and allows to specify functions to free the memory
1053  * allocated for the key and value that get called when removing the
1054  * entry from the #GHashTable.
1055  *
1056  * Since version 2.42 it is permissible for destroy notify functions to
1057  * recursively remove further items from the hash table. This is only
1058  * permissible if the application still holds a reference to the hash table.
1059  * This means that you may need to ensure that the hash table is empty by
1060  * calling g_hash_table_remove_all() before releasing the last reference using
1061  * g_hash_table_unref().
1062  *
1063  * Returns: a new #GHashTable
1064  */
1065 GHashTable *
1066 g_hash_table_new_full (GHashFunc      hash_func,
1067                        GEqualFunc     key_equal_func,
1068                        GDestroyNotify key_destroy_func,
1069                        GDestroyNotify value_destroy_func)
1070 {
1071   GHashTable *hash_table;
1072 
1073   hash_table = g_slice_new (GHashTable);
1074 #ifdef GSTREAMER_LITE
1075   if (hash_table == NULL) {
1076     return NULL;
1077   }
1078 #endif // GSTREAMER_LITE
<a name="46" id="anc46"></a>
1079   g_atomic_ref_count_init (&amp;hash_table-&gt;ref_count);
1080   hash_table-&gt;nnodes             = 0;
1081   hash_table-&gt;noccupied          = 0;
1082   hash_table-&gt;hash_func          = hash_func ? hash_func : g_direct_hash;
1083   hash_table-&gt;key_equal_func     = key_equal_func;
1084 #ifndef G_DISABLE_ASSERT
1085   hash_table-&gt;version            = 0;
1086 #endif
1087   hash_table-&gt;key_destroy_func   = key_destroy_func;
1088   hash_table-&gt;value_destroy_func = value_destroy_func;
<a name="47" id="anc47"></a><span class="line-modified">1089 </span>
<span class="line-modified">1090   g_hash_table_setup_storage (hash_table);</span>

1091 
1092   return hash_table;
1093 }
1094 
1095 /**
1096  * g_hash_table_iter_init:
1097  * @iter: an uninitialized #GHashTableIter
1098  * @hash_table: a #GHashTable
1099  *
1100  * Initializes a key/value pair iterator and associates it with
1101  * @hash_table. Modifying the hash table after calling this function
1102  * invalidates the returned iterator.
1103  * |[&lt;!-- language=&quot;C&quot; --&gt;
1104  * GHashTableIter iter;
1105  * gpointer key, value;
1106  *
1107  * g_hash_table_iter_init (&amp;iter, hash_table);
1108  * while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
1109  *   {
1110  *     // do something with key and value
1111  *   }
1112  * ]|
1113  *
1114  * Since: 2.16
1115  */
1116 void
1117 g_hash_table_iter_init (GHashTableIter *iter,
1118                         GHashTable     *hash_table)
1119 {
1120   RealIter *ri = (RealIter *) iter;
1121 
1122   g_return_if_fail (iter != NULL);
1123   g_return_if_fail (hash_table != NULL);
1124 
1125   ri-&gt;hash_table = hash_table;
1126   ri-&gt;position = -1;
1127 #ifndef G_DISABLE_ASSERT
1128   ri-&gt;version = hash_table-&gt;version;
1129 #endif
1130 }
1131 
1132 /**
1133  * g_hash_table_iter_next:
1134  * @iter: an initialized #GHashTableIter
1135  * @key: (out) (optional): a location to store the key
1136  * @value: (out) (optional) (nullable): a location to store the value
1137  *
1138  * Advances @iter and retrieves the key and/or value that are now
1139  * pointed to as a result of this advancement. If %FALSE is returned,
1140  * @key and @value are not set, and the iterator becomes invalid.
1141  *
1142  * Returns: %FALSE if the end of the #GHashTable has been reached.
1143  *
1144  * Since: 2.16
1145  */
1146 gboolean
1147 g_hash_table_iter_next (GHashTableIter *iter,
1148                         gpointer       *key,
1149                         gpointer       *value)
1150 {
1151   RealIter *ri = (RealIter *) iter;
1152   gint position;
1153 
1154   g_return_val_if_fail (iter != NULL, FALSE);
1155 #ifndef G_DISABLE_ASSERT
1156   g_return_val_if_fail (ri-&gt;version == ri-&gt;hash_table-&gt;version, FALSE);
1157 #endif
<a name="48" id="anc48"></a><span class="line-modified">1158   g_return_val_if_fail (ri-&gt;position &lt; (gssize) ri-&gt;hash_table-&gt;size, FALSE);</span>
1159 
1160   position = ri-&gt;position;
1161 
1162   do
1163     {
1164       position++;
<a name="49" id="anc49"></a><span class="line-modified">1165       if (position &gt;= (gssize) ri-&gt;hash_table-&gt;size)</span>
1166         {
1167           ri-&gt;position = position;
1168           return FALSE;
1169         }
1170     }
1171   while (!HASH_IS_REAL (ri-&gt;hash_table-&gt;hashes[position]));
1172 
1173   if (key != NULL)
<a name="50" id="anc50"></a><span class="line-modified">1174     *key = g_hash_table_fetch_key_or_value (ri-&gt;hash_table-&gt;keys, position, ri-&gt;hash_table-&gt;have_big_keys);</span>
1175   if (value != NULL)
<a name="51" id="anc51"></a><span class="line-modified">1176     *value = g_hash_table_fetch_key_or_value (ri-&gt;hash_table-&gt;values, position, ri-&gt;hash_table-&gt;have_big_values);</span>
1177 
1178   ri-&gt;position = position;
1179   return TRUE;
1180 }
1181 
1182 /**
1183  * g_hash_table_iter_get_hash_table:
1184  * @iter: an initialized #GHashTableIter
1185  *
1186  * Returns the #GHashTable associated with @iter.
1187  *
1188  * Returns: the #GHashTable associated with @iter.
1189  *
1190  * Since: 2.16
1191  */
1192 GHashTable *
1193 g_hash_table_iter_get_hash_table (GHashTableIter *iter)
1194 {
1195   g_return_val_if_fail (iter != NULL, NULL);
1196 
1197   return ((RealIter *) iter)-&gt;hash_table;
1198 }
1199 
1200 static void
1201 iter_remove_or_steal (RealIter *ri, gboolean notify)
1202 {
1203   g_return_if_fail (ri != NULL);
1204 #ifndef G_DISABLE_ASSERT
1205   g_return_if_fail (ri-&gt;version == ri-&gt;hash_table-&gt;version);
1206 #endif
1207   g_return_if_fail (ri-&gt;position &gt;= 0);
<a name="52" id="anc52"></a><span class="line-modified">1208   g_return_if_fail ((gsize) ri-&gt;position &lt; ri-&gt;hash_table-&gt;size);</span>
1209 
1210   g_hash_table_remove_node (ri-&gt;hash_table, ri-&gt;position, notify);
1211 
1212 #ifndef G_DISABLE_ASSERT
1213   ri-&gt;version++;
1214   ri-&gt;hash_table-&gt;version++;
1215 #endif
1216 }
1217 
1218 /**
1219  * g_hash_table_iter_remove:
1220  * @iter: an initialized #GHashTableIter
1221  *
1222  * Removes the key/value pair currently pointed to by the iterator
1223  * from its associated #GHashTable. Can only be called after
1224  * g_hash_table_iter_next() returned %TRUE, and cannot be called
1225  * more than once for the same key/value pair.
1226  *
1227  * If the #GHashTable was created using g_hash_table_new_full(),
1228  * the key and value are freed using the supplied destroy functions,
1229  * otherwise you have to make sure that any dynamically allocated
1230  * values are freed yourself.
1231  *
1232  * It is safe to continue iterating the #GHashTable afterward:
1233  * |[&lt;!-- language=&quot;C&quot; --&gt;
1234  * while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
1235  *   {
1236  *     if (condition)
1237  *       g_hash_table_iter_remove (&amp;iter);
1238  *   }
1239  * ]|
1240  *
1241  * Since: 2.16
1242  */
1243 void
1244 g_hash_table_iter_remove (GHashTableIter *iter)
1245 {
1246   iter_remove_or_steal ((RealIter *) iter, TRUE);
1247 }
1248 
1249 /*
1250  * g_hash_table_insert_node:
1251  * @hash_table: our #GHashTable
1252  * @node_index: pointer to node to insert/replace
1253  * @key_hash: key hash
1254  * @key: (nullable): key to replace with, or %NULL
1255  * @value: value to replace with
1256  * @keep_new_key: whether to replace the key in the node with @key
1257  * @reusing_key: whether @key was taken out of the existing node
1258  *
1259  * Inserts a value at @node_index in the hash table and updates it.
1260  *
1261  * If @key has been taken out of the existing node (ie it is not
1262  * passed in via a g_hash_table_insert/replace) call, then @reusing_key
1263  * should be %TRUE.
1264  *
1265  * Returns: %TRUE if the key did not exist yet
1266  */
1267 static gboolean
1268 g_hash_table_insert_node (GHashTable *hash_table,
1269                           guint       node_index,
1270                           guint       key_hash,
1271                           gpointer    new_key,
1272                           gpointer    new_value,
1273                           gboolean    keep_new_key,
1274                           gboolean    reusing_key)
1275 {
1276   gboolean already_exists;
1277   guint old_hash;
1278   gpointer key_to_free = NULL;
<a name="53" id="anc53"></a><span class="line-added">1279   gpointer key_to_keep = NULL;</span>
1280   gpointer value_to_free = NULL;
1281 
1282   old_hash = hash_table-&gt;hashes[node_index];
1283   already_exists = HASH_IS_REAL (old_hash);
1284 
1285   /* Proceed in three steps.  First, deal with the key because it is the
1286    * most complicated.  Then consider if we need to split the table in
1287    * two (because writing the value will result in the set invariant
1288    * becoming broken).  Then deal with the value.
1289    *
1290    * There are three cases for the key:
1291    *
1292    *  - entry already exists in table, reusing key:
1293    *    free the just-passed-in new_key and use the existing value
1294    *
1295    *  - entry already exists in table, not reusing key:
1296    *    free the entry in the table, use the new key
1297    *
1298    *  - entry not already in table:
1299    *    use the new key, free nothing
1300    *
1301    * We update the hash at the same time...
1302    */
1303   if (already_exists)
1304     {
1305       /* Note: we must record the old value before writing the new key
1306        * because we might change the value in the event that the two
1307        * arrays are shared.
1308        */
<a name="54" id="anc54"></a><span class="line-modified">1309       value_to_free = g_hash_table_fetch_key_or_value (hash_table-&gt;values, node_index, hash_table-&gt;have_big_values);</span>
1310 
1311       if (keep_new_key)
1312         {
<a name="55" id="anc55"></a><span class="line-modified">1313           key_to_free = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys);</span>
<span class="line-modified">1314           key_to_keep = new_key;</span>
1315         }
1316       else
<a name="56" id="anc56"></a><span class="line-modified">1317         {</span>
<span class="line-added">1318           key_to_free = new_key;</span>
<span class="line-added">1319           key_to_keep = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys);</span>
<span class="line-added">1320         }</span>
1321     }
1322   else
1323     {
1324       hash_table-&gt;hashes[node_index] = key_hash;
<a name="57" id="anc57"></a><span class="line-modified">1325       key_to_keep = new_key;</span>
1326     }
1327 
<a name="58" id="anc58"></a><span class="line-modified">1328   /* Resize key/value arrays and split table as necessary */</span>
<span class="line-modified">1329   g_hash_table_ensure_keyval_fits (hash_table, key_to_keep, new_value);</span>
<span class="line-modified">1330   g_hash_table_assign_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys, key_to_keep);</span>



1331 
1332   /* Step 3: Actually do the write */
<a name="59" id="anc59"></a><span class="line-modified">1333   g_hash_table_assign_key_or_value (hash_table-&gt;values, node_index, hash_table-&gt;have_big_values, new_value);</span>
1334 
1335   /* Now, the bookkeeping... */
1336   if (!already_exists)
1337     {
1338       hash_table-&gt;nnodes++;
1339 
1340       if (HASH_IS_UNUSED (old_hash))
1341         {
1342           /* We replaced an empty node, and not a tombstone */
1343           hash_table-&gt;noccupied++;
1344           g_hash_table_maybe_resize (hash_table);
1345         }
1346 
1347 #ifndef G_DISABLE_ASSERT
1348       hash_table-&gt;version++;
1349 #endif
1350     }
1351 
1352   if (already_exists)
1353     {
1354       if (hash_table-&gt;key_destroy_func &amp;&amp; !reusing_key)
1355         (* hash_table-&gt;key_destroy_func) (key_to_free);
1356       if (hash_table-&gt;value_destroy_func)
1357         (* hash_table-&gt;value_destroy_func) (value_to_free);
1358     }
1359 
1360   return !already_exists;
1361 }
1362 
1363 /**
1364  * g_hash_table_iter_replace:
1365  * @iter: an initialized #GHashTableIter
1366  * @value: the value to replace with
1367  *
1368  * Replaces the value currently pointed to by the iterator
1369  * from its associated #GHashTable. Can only be called after
1370  * g_hash_table_iter_next() returned %TRUE.
1371  *
1372  * If you supplied a @value_destroy_func when creating the
1373  * #GHashTable, the old value is freed using that function.
1374  *
1375  * Since: 2.30
1376  */
1377 void
1378 g_hash_table_iter_replace (GHashTableIter *iter,
1379                            gpointer        value)
1380 {
1381   RealIter *ri;
1382   guint node_hash;
1383   gpointer key;
1384 
1385   ri = (RealIter *) iter;
1386 
1387   g_return_if_fail (ri != NULL);
1388 #ifndef G_DISABLE_ASSERT
1389   g_return_if_fail (ri-&gt;version == ri-&gt;hash_table-&gt;version);
1390 #endif
1391   g_return_if_fail (ri-&gt;position &gt;= 0);
<a name="60" id="anc60"></a><span class="line-modified">1392   g_return_if_fail ((gsize) ri-&gt;position &lt; ri-&gt;hash_table-&gt;size);</span>
1393 
1394   node_hash = ri-&gt;hash_table-&gt;hashes[ri-&gt;position];
<a name="61" id="anc61"></a><span class="line-modified">1395 </span>
<span class="line-added">1396   key = g_hash_table_fetch_key_or_value (ri-&gt;hash_table-&gt;keys, ri-&gt;position, ri-&gt;hash_table-&gt;have_big_keys);</span>
1397 
1398   g_hash_table_insert_node (ri-&gt;hash_table, ri-&gt;position, node_hash, key, value, TRUE, TRUE);
1399 
1400 #ifndef G_DISABLE_ASSERT
1401   ri-&gt;version++;
1402   ri-&gt;hash_table-&gt;version++;
1403 #endif
1404 }
1405 
1406 /**
1407  * g_hash_table_iter_steal:
1408  * @iter: an initialized #GHashTableIter
1409  *
1410  * Removes the key/value pair currently pointed to by the
1411  * iterator from its associated #GHashTable, without calling
1412  * the key and value destroy functions. Can only be called
1413  * after g_hash_table_iter_next() returned %TRUE, and cannot
1414  * be called more than once for the same key/value pair.
1415  *
1416  * Since: 2.16
1417  */
1418 void
1419 g_hash_table_iter_steal (GHashTableIter *iter)
1420 {
1421   iter_remove_or_steal ((RealIter *) iter, FALSE);
1422 }
1423 
1424 
1425 /**
1426  * g_hash_table_ref:
1427  * @hash_table: a valid #GHashTable
1428  *
1429  * Atomically increments the reference count of @hash_table by one.
1430  * This function is MT-safe and may be called from any thread.
1431  *
1432  * Returns: the passed in #GHashTable
1433  *
1434  * Since: 2.10
1435  */
1436 GHashTable *
1437 g_hash_table_ref (GHashTable *hash_table)
1438 {
1439   g_return_val_if_fail (hash_table != NULL, NULL);
1440 
1441   g_atomic_ref_count_inc (&amp;hash_table-&gt;ref_count);
1442 
1443   return hash_table;
1444 }
1445 
1446 /**
1447  * g_hash_table_unref:
1448  * @hash_table: a valid #GHashTable
1449  *
1450  * Atomically decrements the reference count of @hash_table by one.
1451  * If the reference count drops to 0, all keys and values will be
1452  * destroyed, and all memory allocated by the hash table is released.
1453  * This function is MT-safe and may be called from any thread.
1454  *
1455  * Since: 2.10
1456  */
1457 void
1458 g_hash_table_unref (GHashTable *hash_table)
1459 {
1460   g_return_if_fail (hash_table != NULL);
1461 
1462   if (g_atomic_ref_count_dec (&amp;hash_table-&gt;ref_count))
1463     {
1464       g_hash_table_remove_all_nodes (hash_table, TRUE, TRUE);
1465       if (hash_table-&gt;keys != hash_table-&gt;values)
1466         g_free (hash_table-&gt;values);
1467       g_free (hash_table-&gt;keys);
1468       g_free (hash_table-&gt;hashes);
1469       g_slice_free (GHashTable, hash_table);
1470     }
1471 }
1472 
1473 /**
1474  * g_hash_table_destroy:
1475  * @hash_table: a #GHashTable
1476  *
1477  * Destroys all keys and values in the #GHashTable and decrements its
1478  * reference count by 1. If keys and/or values are dynamically allocated,
1479  * you should either free them first or create the #GHashTable with destroy
1480  * notifiers using g_hash_table_new_full(). In the latter case the destroy
1481  * functions you supplied will be called on all keys and values during the
1482  * destruction phase.
1483  */
1484 void
1485 g_hash_table_destroy (GHashTable *hash_table)
1486 {
1487   g_return_if_fail (hash_table != NULL);
1488 
1489   g_hash_table_remove_all (hash_table);
1490   g_hash_table_unref (hash_table);
1491 }
1492 
1493 /**
1494  * g_hash_table_lookup:
1495  * @hash_table: a #GHashTable
1496  * @key: the key to look up
1497  *
1498  * Looks up a key in a #GHashTable. Note that this function cannot
1499  * distinguish between a key that is not present and one which is present
1500  * and has the value %NULL. If you need this distinction, use
1501  * g_hash_table_lookup_extended().
1502  *
1503  * Returns: (nullable): the associated value, or %NULL if the key is not found
1504  */
1505 gpointer
1506 g_hash_table_lookup (GHashTable    *hash_table,
1507                      gconstpointer  key)
1508 {
1509   guint node_index;
1510   guint node_hash;
1511 
1512   g_return_val_if_fail (hash_table != NULL, NULL);
1513 
1514   node_index = g_hash_table_lookup_node (hash_table, key, &amp;node_hash);
1515 
1516   return HASH_IS_REAL (hash_table-&gt;hashes[node_index])
<a name="62" id="anc62"></a><span class="line-modified">1517     ? g_hash_table_fetch_key_or_value (hash_table-&gt;values, node_index, hash_table-&gt;have_big_values)</span>
1518     : NULL;
1519 }
1520 
1521 /**
1522  * g_hash_table_lookup_extended:
1523  * @hash_table: a #GHashTable
1524  * @lookup_key: the key to look up
1525  * @orig_key: (out) (optional): return location for the original key
1526  * @value: (out) (optional) (nullable): return location for the value associated
1527  * with the key
1528  *
1529  * Looks up a key in the #GHashTable, returning the original key and the
1530  * associated value and a #gboolean which is %TRUE if the key was found. This
1531  * is useful if you need to free the memory allocated for the original key,
1532  * for example before calling g_hash_table_remove().
1533  *
1534  * You can actually pass %NULL for @lookup_key to test
1535  * whether the %NULL key exists, provided the hash and equal functions
1536  * of @hash_table are %NULL-safe.
1537  *
1538  * Returns: %TRUE if the key was found in the #GHashTable
1539  */
1540 gboolean
1541 g_hash_table_lookup_extended (GHashTable    *hash_table,
1542                               gconstpointer  lookup_key,
1543                               gpointer      *orig_key,
1544                               gpointer      *value)
1545 {
1546   guint node_index;
1547   guint node_hash;
1548 
1549   g_return_val_if_fail (hash_table != NULL, FALSE);
1550 
1551   node_index = g_hash_table_lookup_node (hash_table, lookup_key, &amp;node_hash);
1552 
1553   if (!HASH_IS_REAL (hash_table-&gt;hashes[node_index]))
<a name="63" id="anc63"></a><span class="line-modified">1554     {</span>
<span class="line-added">1555       if (orig_key != NULL)</span>
<span class="line-added">1556         *orig_key = NULL;</span>
<span class="line-added">1557       if (value != NULL)</span>
<span class="line-added">1558         *value = NULL;</span>
<span class="line-added">1559 </span>
<span class="line-added">1560       return FALSE;</span>
<span class="line-added">1561     }</span>
1562 
1563   if (orig_key)
<a name="64" id="anc64"></a><span class="line-modified">1564     *orig_key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys);</span>
1565 
1566   if (value)
<a name="65" id="anc65"></a><span class="line-modified">1567     *value = g_hash_table_fetch_key_or_value (hash_table-&gt;values, node_index, hash_table-&gt;have_big_values);</span>
1568 
1569   return TRUE;
1570 }
1571 
1572 /*
1573  * g_hash_table_insert_internal:
1574  * @hash_table: our #GHashTable
1575  * @key: the key to insert
1576  * @value: the value to insert
1577  * @keep_new_key: if %TRUE and this key already exists in the table
1578  *   then call the destroy notify function on the old key.  If %FALSE
1579  *   then call the destroy notify function on the new key.
1580  *
1581  * Implements the common logic for the g_hash_table_insert() and
1582  * g_hash_table_replace() functions.
1583  *
1584  * Do a lookup of @key. If it is found, replace it with the new
1585  * @value (and perhaps the new @key). If it is not found, create
1586  * a new node.
1587  *
1588  * Returns: %TRUE if the key did not exist yet
1589  */
1590 static gboolean
1591 g_hash_table_insert_internal (GHashTable *hash_table,
1592                               gpointer    key,
1593                               gpointer    value,
1594                               gboolean    keep_new_key)
1595 {
1596   guint key_hash;
1597   guint node_index;
1598 
1599   g_return_val_if_fail (hash_table != NULL, FALSE);
1600 
1601   node_index = g_hash_table_lookup_node (hash_table, key, &amp;key_hash);
1602 
1603   return g_hash_table_insert_node (hash_table, node_index, key_hash, key, value, keep_new_key, FALSE);
1604 }
1605 
1606 /**
1607  * g_hash_table_insert:
1608  * @hash_table: a #GHashTable
1609  * @key: a key to insert
1610  * @value: the value to associate with the key
1611  *
1612  * Inserts a new key and value into a #GHashTable.
1613  *
1614  * If the key already exists in the #GHashTable its current
1615  * value is replaced with the new value. If you supplied a
1616  * @value_destroy_func when creating the #GHashTable, the old
1617  * value is freed using that function. If you supplied a
1618  * @key_destroy_func when creating the #GHashTable, the passed
1619  * key is freed using that function.
1620  *
1621  * Starting from GLib 2.40, this function returns a boolean value to
1622  * indicate whether the newly added value was already in the hash table
1623  * or not.
1624  *
1625  * Returns: %TRUE if the key did not exist yet
1626  */
1627 gboolean
1628 g_hash_table_insert (GHashTable *hash_table,
1629                      gpointer    key,
1630                      gpointer    value)
1631 {
1632   return g_hash_table_insert_internal (hash_table, key, value, FALSE);
1633 }
1634 
1635 /**
1636  * g_hash_table_replace:
1637  * @hash_table: a #GHashTable
1638  * @key: a key to insert
1639  * @value: the value to associate with the key
1640  *
1641  * Inserts a new key and value into a #GHashTable similar to
1642  * g_hash_table_insert(). The difference is that if the key
1643  * already exists in the #GHashTable, it gets replaced by the
1644  * new key. If you supplied a @value_destroy_func when creating
1645  * the #GHashTable, the old value is freed using that function.
1646  * If you supplied a @key_destroy_func when creating the
1647  * #GHashTable, the old key is freed using that function.
1648  *
1649  * Starting from GLib 2.40, this function returns a boolean value to
1650  * indicate whether the newly added value was already in the hash table
1651  * or not.
1652  *
1653  * Returns: %TRUE if the key did not exist yet
1654  */
1655 gboolean
1656 g_hash_table_replace (GHashTable *hash_table,
1657                       gpointer    key,
1658                       gpointer    value)
1659 {
1660   return g_hash_table_insert_internal (hash_table, key, value, TRUE);
1661 }
1662 
1663 /**
1664  * g_hash_table_add:
1665  * @hash_table: a #GHashTable
1666  * @key: a key to insert
1667  *
1668  * This is a convenience function for using a #GHashTable as a set.  It
1669  * is equivalent to calling g_hash_table_replace() with @key as both the
1670  * key and the value.
1671  *
1672  * When a hash table only ever contains keys that have themselves as the
1673  * corresponding value it is able to be stored more efficiently.  See
1674  * the discussion in the section description.
1675  *
1676  * Starting from GLib 2.40, this function returns a boolean value to
1677  * indicate whether the newly added value was already in the hash table
1678  * or not.
1679  *
1680  * Returns: %TRUE if the key did not exist yet
1681  *
1682  * Since: 2.32
1683  */
1684 gboolean
1685 g_hash_table_add (GHashTable *hash_table,
1686                   gpointer    key)
1687 {
1688   return g_hash_table_insert_internal (hash_table, key, key, TRUE);
1689 }
1690 
1691 /**
1692  * g_hash_table_contains:
1693  * @hash_table: a #GHashTable
1694  * @key: a key to check
1695  *
1696  * Checks if @key is in @hash_table.
1697  *
1698  * Returns: %TRUE if @key is in @hash_table, %FALSE otherwise.
1699  *
1700  * Since: 2.32
1701  **/
1702 gboolean
1703 g_hash_table_contains (GHashTable    *hash_table,
1704                        gconstpointer  key)
1705 {
1706   guint node_index;
1707   guint node_hash;
1708 
1709   g_return_val_if_fail (hash_table != NULL, FALSE);
1710 
1711   node_index = g_hash_table_lookup_node (hash_table, key, &amp;node_hash);
1712 
1713   return HASH_IS_REAL (hash_table-&gt;hashes[node_index]);
1714 }
1715 
1716 /*
1717  * g_hash_table_remove_internal:
1718  * @hash_table: our #GHashTable
1719  * @key: the key to remove
1720  * @notify: %TRUE if the destroy notify handlers are to be called
1721  * Returns: %TRUE if a node was found and removed, else %FALSE
1722  *
1723  * Implements the common logic for the g_hash_table_remove() and
1724  * g_hash_table_steal() functions.
1725  *
1726  * Do a lookup of @key and remove it if it is found, calling the
1727  * destroy notify handlers only if @notify is %TRUE.
1728  */
1729 static gboolean
1730 g_hash_table_remove_internal (GHashTable    *hash_table,
1731                               gconstpointer  key,
1732                               gboolean       notify)
1733 {
1734   guint node_index;
1735   guint node_hash;
1736 
1737   g_return_val_if_fail (hash_table != NULL, FALSE);
1738 
1739   node_index = g_hash_table_lookup_node (hash_table, key, &amp;node_hash);
1740 
1741   if (!HASH_IS_REAL (hash_table-&gt;hashes[node_index]))
1742     return FALSE;
1743 
1744   g_hash_table_remove_node (hash_table, node_index, notify);
1745   g_hash_table_maybe_resize (hash_table);
1746 
1747 #ifndef G_DISABLE_ASSERT
1748   hash_table-&gt;version++;
1749 #endif
1750 
1751   return TRUE;
1752 }
1753 
1754 /**
1755  * g_hash_table_remove:
1756  * @hash_table: a #GHashTable
1757  * @key: the key to remove
1758  *
1759  * Removes a key and its associated value from a #GHashTable.
1760  *
1761  * If the #GHashTable was created using g_hash_table_new_full(), the
1762  * key and value are freed using the supplied destroy functions, otherwise
1763  * you have to make sure that any dynamically allocated values are freed
1764  * yourself.
1765  *
1766  * Returns: %TRUE if the key was found and removed from the #GHashTable
1767  */
1768 gboolean
1769 g_hash_table_remove (GHashTable    *hash_table,
1770                      gconstpointer  key)
1771 {
1772   return g_hash_table_remove_internal (hash_table, key, TRUE);
1773 }
1774 
1775 /**
1776  * g_hash_table_steal:
1777  * @hash_table: a #GHashTable
1778  * @key: the key to remove
1779  *
1780  * Removes a key and its associated value from a #GHashTable without
1781  * calling the key and value destroy functions.
1782  *
1783  * Returns: %TRUE if the key was found and removed from the #GHashTable
1784  */
1785 gboolean
1786 g_hash_table_steal (GHashTable    *hash_table,
1787                     gconstpointer  key)
1788 {
1789   return g_hash_table_remove_internal (hash_table, key, FALSE);
1790 }
1791 
1792 /**
1793  * g_hash_table_steal_extended:
1794  * @hash_table: a #GHashTable
1795  * @lookup_key: the key to look up
1796  * @stolen_key: (out) (optional) (transfer full): return location for the
1797  *    original key
1798  * @stolen_value: (out) (optional) (nullable) (transfer full): return location
1799  *    for the value associated with the key
1800  *
1801  * Looks up a key in the #GHashTable, stealing the original key and the
1802  * associated value and returning %TRUE if the key was found. If the key was
1803  * not found, %FALSE is returned.
1804  *
1805  * If found, the stolen key and value are removed from the hash table without
1806  * calling the key and value destroy functions, and ownership is transferred to
1807  * the caller of this method; as with g_hash_table_steal().
1808  *
1809  * You can pass %NULL for @lookup_key, provided the hash and equal functions
1810  * of @hash_table are %NULL-safe.
1811  *
1812  * Returns: %TRUE if the key was found in the #GHashTable
1813  * Since: 2.58
1814  */
1815 gboolean
1816 g_hash_table_steal_extended (GHashTable    *hash_table,
1817                              gconstpointer  lookup_key,
1818                              gpointer      *stolen_key,
1819                              gpointer      *stolen_value)
1820 {
1821   guint node_index;
1822   guint node_hash;
1823 
1824   g_return_val_if_fail (hash_table != NULL, FALSE);
1825 
1826   node_index = g_hash_table_lookup_node (hash_table, lookup_key, &amp;node_hash);
1827 
1828   if (!HASH_IS_REAL (hash_table-&gt;hashes[node_index]))
1829     {
1830       if (stolen_key != NULL)
1831         *stolen_key = NULL;
1832       if (stolen_value != NULL)
1833         *stolen_value = NULL;
1834       return FALSE;
1835     }
1836 
1837   if (stolen_key != NULL)
<a name="66" id="anc66"></a><span class="line-modified">1838   {</span>
<span class="line-added">1839     *stolen_key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys);</span>
<span class="line-added">1840     g_hash_table_assign_key_or_value (hash_table-&gt;keys, node_index, hash_table-&gt;have_big_keys, NULL);</span>
<span class="line-added">1841   }</span>
1842 
1843   if (stolen_value != NULL)
<a name="67" id="anc67"></a><span class="line-modified">1844   {</span>
<span class="line-added">1845     *stolen_value = g_hash_table_fetch_key_or_value (hash_table-&gt;values, node_index, hash_table-&gt;have_big_values);</span>
<span class="line-added">1846     g_hash_table_assign_key_or_value (hash_table-&gt;values, node_index, hash_table-&gt;have_big_values, NULL);</span>
<span class="line-added">1847   }</span>
1848 
1849   g_hash_table_remove_node (hash_table, node_index, FALSE);
1850   g_hash_table_maybe_resize (hash_table);
1851 
1852 #ifndef G_DISABLE_ASSERT
1853   hash_table-&gt;version++;
1854 #endif
1855 
1856   return TRUE;
1857 }
1858 
1859 /**
1860  * g_hash_table_remove_all:
1861  * @hash_table: a #GHashTable
1862  *
1863  * Removes all keys and their associated values from a #GHashTable.
1864  *
1865  * If the #GHashTable was created using g_hash_table_new_full(),
1866  * the keys and values are freed using the supplied destroy functions,
1867  * otherwise you have to make sure that any dynamically allocated
1868  * values are freed yourself.
1869  *
1870  * Since: 2.12
1871  */
1872 void
1873 g_hash_table_remove_all (GHashTable *hash_table)
1874 {
1875   g_return_if_fail (hash_table != NULL);
1876 
1877 #ifndef G_DISABLE_ASSERT
1878   if (hash_table-&gt;nnodes != 0)
1879     hash_table-&gt;version++;
1880 #endif
1881 
1882   g_hash_table_remove_all_nodes (hash_table, TRUE, FALSE);
1883   g_hash_table_maybe_resize (hash_table);
1884 }
1885 
1886 /**
1887  * g_hash_table_steal_all:
1888  * @hash_table: a #GHashTable
1889  *
1890  * Removes all keys and their associated values from a #GHashTable
1891  * without calling the key and value destroy functions.
1892  *
1893  * Since: 2.12
1894  */
1895 void
1896 g_hash_table_steal_all (GHashTable *hash_table)
1897 {
1898   g_return_if_fail (hash_table != NULL);
1899 
1900 #ifndef G_DISABLE_ASSERT
1901   if (hash_table-&gt;nnodes != 0)
1902     hash_table-&gt;version++;
1903 #endif
1904 
1905   g_hash_table_remove_all_nodes (hash_table, FALSE, FALSE);
1906   g_hash_table_maybe_resize (hash_table);
1907 }
1908 
1909 /*
1910  * g_hash_table_foreach_remove_or_steal:
1911  * @hash_table: a #GHashTable
1912  * @func: the user&#39;s callback function
1913  * @user_data: data for @func
1914  * @notify: %TRUE if the destroy notify handlers are to be called
1915  *
1916  * Implements the common logic for g_hash_table_foreach_remove()
1917  * and g_hash_table_foreach_steal().
1918  *
1919  * Iterates over every node in the table, calling @func with the key
1920  * and value of the node (and @user_data). If @func returns %TRUE the
1921  * node is removed from the table.
1922  *
1923  * If @notify is true then the destroy notify handlers will be called
1924  * for each removed node.
1925  */
1926 static guint
1927 g_hash_table_foreach_remove_or_steal (GHashTable *hash_table,
1928                                       GHRFunc     func,
1929                                       gpointer    user_data,
1930                                       gboolean    notify)
1931 {
1932   guint deleted = 0;
<a name="68" id="anc68"></a><span class="line-modified">1933   gsize i;</span>
1934 #ifndef G_DISABLE_ASSERT
1935   gint version = hash_table-&gt;version;
1936 #endif
1937 
1938   for (i = 0; i &lt; hash_table-&gt;size; i++)
1939     {
1940       guint node_hash = hash_table-&gt;hashes[i];
<a name="69" id="anc69"></a><span class="line-modified">1941       gpointer node_key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys);</span>
<span class="line-modified">1942       gpointer node_value = g_hash_table_fetch_key_or_value (hash_table-&gt;values, i, hash_table-&gt;have_big_values);</span>
1943 
1944       if (HASH_IS_REAL (node_hash) &amp;&amp;
1945           (* func) (node_key, node_value, user_data))
1946         {
1947           g_hash_table_remove_node (hash_table, i, notify);
1948           deleted++;
1949         }
1950 
1951 #ifndef G_DISABLE_ASSERT
1952       g_return_val_if_fail (version == hash_table-&gt;version, 0);
1953 #endif
1954     }
1955 
1956   g_hash_table_maybe_resize (hash_table);
1957 
1958 #ifndef G_DISABLE_ASSERT
1959   if (deleted &gt; 0)
1960     hash_table-&gt;version++;
1961 #endif
1962 
1963   return deleted;
1964 }
1965 
1966 /**
1967  * g_hash_table_foreach_remove:
1968  * @hash_table: a #GHashTable
1969  * @func: the function to call for each key/value pair
1970  * @user_data: user data to pass to the function
1971  *
1972  * Calls the given function for each key/value pair in the
1973  * #GHashTable. If the function returns %TRUE, then the key/value
1974  * pair is removed from the #GHashTable. If you supplied key or
1975  * value destroy functions when creating the #GHashTable, they are
1976  * used to free the memory allocated for the removed keys and values.
1977  *
1978  * See #GHashTableIter for an alternative way to loop over the
1979  * key/value pairs in the hash table.
1980  *
1981  * Returns: the number of key/value pairs removed
1982  */
1983 guint
1984 g_hash_table_foreach_remove (GHashTable *hash_table,
1985                              GHRFunc     func,
1986                              gpointer    user_data)
1987 {
1988   g_return_val_if_fail (hash_table != NULL, 0);
1989   g_return_val_if_fail (func != NULL, 0);
1990 
1991   return g_hash_table_foreach_remove_or_steal (hash_table, func, user_data, TRUE);
1992 }
1993 
1994 /**
1995  * g_hash_table_foreach_steal:
1996  * @hash_table: a #GHashTable
1997  * @func: the function to call for each key/value pair
1998  * @user_data: user data to pass to the function
1999  *
2000  * Calls the given function for each key/value pair in the
2001  * #GHashTable. If the function returns %TRUE, then the key/value
2002  * pair is removed from the #GHashTable, but no key or value
2003  * destroy functions are called.
2004  *
2005  * See #GHashTableIter for an alternative way to loop over the
2006  * key/value pairs in the hash table.
2007  *
2008  * Returns: the number of key/value pairs removed.
2009  */
2010 guint
2011 g_hash_table_foreach_steal (GHashTable *hash_table,
2012                             GHRFunc     func,
2013                             gpointer    user_data)
2014 {
2015   g_return_val_if_fail (hash_table != NULL, 0);
2016   g_return_val_if_fail (func != NULL, 0);
2017 
2018   return g_hash_table_foreach_remove_or_steal (hash_table, func, user_data, FALSE);
2019 }
2020 
2021 /**
2022  * g_hash_table_foreach:
2023  * @hash_table: a #GHashTable
2024  * @func: the function to call for each key/value pair
2025  * @user_data: user data to pass to the function
2026  *
2027  * Calls the given function for each of the key/value pairs in the
2028  * #GHashTable.  The function is passed the key and value of each
2029  * pair, and the given @user_data parameter.  The hash table may not
2030  * be modified while iterating over it (you can&#39;t add/remove
2031  * items). To remove all items matching a predicate, use
2032  * g_hash_table_foreach_remove().
2033  *
2034  * See g_hash_table_find() for performance caveats for linear
2035  * order searches in contrast to g_hash_table_lookup().
2036  */
2037 void
2038 g_hash_table_foreach (GHashTable *hash_table,
2039                       GHFunc      func,
2040                       gpointer    user_data)
2041 {
<a name="70" id="anc70"></a><span class="line-modified">2042   gsize i;</span>
2043 #ifndef G_DISABLE_ASSERT
2044   gint version;
2045 #endif
2046 
2047   g_return_if_fail (hash_table != NULL);
2048   g_return_if_fail (func != NULL);
2049 
2050 #ifndef G_DISABLE_ASSERT
2051   version = hash_table-&gt;version;
2052 #endif
2053 
2054   for (i = 0; i &lt; hash_table-&gt;size; i++)
2055     {
2056       guint node_hash = hash_table-&gt;hashes[i];
<a name="71" id="anc71"></a><span class="line-modified">2057       gpointer node_key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys);</span>
<span class="line-modified">2058       gpointer node_value = g_hash_table_fetch_key_or_value (hash_table-&gt;values, i, hash_table-&gt;have_big_values);</span>
2059 
2060       if (HASH_IS_REAL (node_hash))
2061         (* func) (node_key, node_value, user_data);
2062 
2063 #ifndef G_DISABLE_ASSERT
2064       g_return_if_fail (version == hash_table-&gt;version);
2065 #endif
2066     }
2067 }
2068 
2069 /**
2070  * g_hash_table_find:
2071  * @hash_table: a #GHashTable
2072  * @predicate: function to test the key/value pairs for a certain property
2073  * @user_data: user data to pass to the function
2074  *
2075  * Calls the given function for key/value pairs in the #GHashTable
2076  * until @predicate returns %TRUE. The function is passed the key
2077  * and value of each pair, and the given @user_data parameter. The
2078  * hash table may not be modified while iterating over it (you can&#39;t
2079  * add/remove items).
2080  *
2081  * Note, that hash tables are really only optimized for forward
2082  * lookups, i.e. g_hash_table_lookup(). So code that frequently issues
2083  * g_hash_table_find() or g_hash_table_foreach() (e.g. in the order of
2084  * once per every entry in a hash table) should probably be reworked
2085  * to use additional or different data structures for reverse lookups
2086  * (keep in mind that an O(n) find/foreach operation issued for all n
2087  * values in a hash table ends up needing O(n*n) operations).
2088  *
2089  * Returns: (nullable): The value of the first key/value pair is returned,
2090  *     for which @predicate evaluates to %TRUE. If no pair with the
2091  *     requested property is found, %NULL is returned.
2092  *
2093  * Since: 2.4
2094  */
2095 gpointer
2096 g_hash_table_find (GHashTable *hash_table,
2097                    GHRFunc     predicate,
2098                    gpointer    user_data)
2099 {
<a name="72" id="anc72"></a><span class="line-modified">2100   gsize i;</span>
2101 #ifndef G_DISABLE_ASSERT
2102   gint version;
2103 #endif
2104   gboolean match;
2105 
2106   g_return_val_if_fail (hash_table != NULL, NULL);
2107   g_return_val_if_fail (predicate != NULL, NULL);
2108 
2109 #ifndef G_DISABLE_ASSERT
2110   version = hash_table-&gt;version;
2111 #endif
2112 
2113   match = FALSE;
2114 
2115   for (i = 0; i &lt; hash_table-&gt;size; i++)
2116     {
2117       guint node_hash = hash_table-&gt;hashes[i];
<a name="73" id="anc73"></a><span class="line-modified">2118       gpointer node_key = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys);</span>
<span class="line-modified">2119       gpointer node_value = g_hash_table_fetch_key_or_value (hash_table-&gt;values, i, hash_table-&gt;have_big_values);</span>
2120 
2121       if (HASH_IS_REAL (node_hash))
2122         match = predicate (node_key, node_value, user_data);
2123 
2124 #ifndef G_DISABLE_ASSERT
2125       g_return_val_if_fail (version == hash_table-&gt;version, NULL);
2126 #endif
2127 
2128       if (match)
2129         return node_value;
2130     }
2131 
2132   return NULL;
2133 }
2134 
2135 /**
2136  * g_hash_table_size:
2137  * @hash_table: a #GHashTable
2138  *
2139  * Returns the number of elements contained in the #GHashTable.
2140  *
2141  * Returns: the number of key/value pairs in the #GHashTable.
2142  */
2143 guint
2144 g_hash_table_size (GHashTable *hash_table)
2145 {
2146   g_return_val_if_fail (hash_table != NULL, 0);
2147 
2148   return hash_table-&gt;nnodes;
2149 }
2150 
2151 /**
2152  * g_hash_table_get_keys:
2153  * @hash_table: a #GHashTable
2154  *
2155  * Retrieves every key inside @hash_table. The returned data is valid
2156  * until changes to the hash release those keys.
2157  *
2158  * This iterates over every entry in the hash table to build its return value.
2159  * To iterate over the entries in a #GHashTable more efficiently, use a
2160  * #GHashTableIter.
2161  *
2162  * Returns: (transfer container): a #GList containing all the keys
2163  *     inside the hash table. The content of the list is owned by the
2164  *     hash table and should not be modified or freed. Use g_list_free()
2165  *     when done using the list.
2166  *
2167  * Since: 2.14
2168  */
2169 GList *
2170 g_hash_table_get_keys (GHashTable *hash_table)
2171 {
<a name="74" id="anc74"></a><span class="line-modified">2172   gsize i;</span>
2173   GList *retval;
2174 
2175   g_return_val_if_fail (hash_table != NULL, NULL);
2176 
2177   retval = NULL;
2178   for (i = 0; i &lt; hash_table-&gt;size; i++)
2179     {
2180       if (HASH_IS_REAL (hash_table-&gt;hashes[i]))
<a name="75" id="anc75"></a><span class="line-modified">2181         retval = g_list_prepend (retval, g_hash_table_fetch_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys));</span>
2182     }
2183 
2184   return retval;
2185 }
2186 
2187 /**
2188  * g_hash_table_get_keys_as_array:
2189  * @hash_table: a #GHashTable
2190  * @length: (out): the length of the returned array
2191  *
2192  * Retrieves every key inside @hash_table, as an array.
2193  *
2194  * The returned array is %NULL-terminated but may contain %NULL as a
2195  * key.  Use @length to determine the true length if it&#39;s possible that
2196  * %NULL was used as the value for a key.
2197  *
2198  * Note: in the common case of a string-keyed #GHashTable, the return
2199  * value of this function can be conveniently cast to (const gchar **).
2200  *
2201  * This iterates over every entry in the hash table to build its return value.
2202  * To iterate over the entries in a #GHashTable more efficiently, use a
2203  * #GHashTableIter.
2204  *
2205  * You should always free the return result with g_free().  In the
2206  * above-mentioned case of a string-keyed hash table, it may be
2207  * appropriate to use g_strfreev() if you call g_hash_table_steal_all()
2208  * first to transfer ownership of the keys.
2209  *
2210  * Returns: (array length=length) (transfer container): a
2211  *   %NULL-terminated array containing each key from the table.
2212  *
2213  * Since: 2.40
2214  **/
2215 gpointer *
2216 g_hash_table_get_keys_as_array (GHashTable *hash_table,
2217                                 guint      *length)
2218 {
2219   gpointer *result;
<a name="76" id="anc76"></a><span class="line-modified">2220   gsize i, j = 0;</span>
2221 
2222   result = g_new (gpointer, hash_table-&gt;nnodes + 1);
2223   for (i = 0; i &lt; hash_table-&gt;size; i++)
2224     {
2225       if (HASH_IS_REAL (hash_table-&gt;hashes[i]))
<a name="77" id="anc77"></a><span class="line-modified">2226         result[j++] = g_hash_table_fetch_key_or_value (hash_table-&gt;keys, i, hash_table-&gt;have_big_keys);</span>
2227     }
2228   g_assert_cmpint (j, ==, hash_table-&gt;nnodes);
2229   result[j] = NULL;
2230 
2231   if (length)
2232     *length = j;
2233 
2234   return result;
2235 }
2236 
2237 /**
2238  * g_hash_table_get_values:
2239  * @hash_table: a #GHashTable
2240  *
2241  * Retrieves every value inside @hash_table. The returned data
2242  * is valid until @hash_table is modified.
2243  *
2244  * This iterates over every entry in the hash table to build its return value.
2245  * To iterate over the entries in a #GHashTable more efficiently, use a
2246  * #GHashTableIter.
2247  *
2248  * Returns: (transfer container): a #GList containing all the values
2249  *     inside the hash table. The content of the list is owned by the
2250  *     hash table and should not be modified or freed. Use g_list_free()
2251  *     when done using the list.
2252  *
2253  * Since: 2.14
2254  */
2255 GList *
2256 g_hash_table_get_values (GHashTable *hash_table)
2257 {
<a name="78" id="anc78"></a><span class="line-modified">2258   gsize i;</span>
2259   GList *retval;
2260 
2261   g_return_val_if_fail (hash_table != NULL, NULL);
2262 
2263   retval = NULL;
2264   for (i = 0; i &lt; hash_table-&gt;size; i++)
2265     {
2266       if (HASH_IS_REAL (hash_table-&gt;hashes[i]))
<a name="79" id="anc79"></a><span class="line-modified">2267         retval = g_list_prepend (retval, g_hash_table_fetch_key_or_value (hash_table-&gt;values, i, hash_table-&gt;have_big_values));</span>
2268     }
2269 
2270   return retval;
2271 }
2272 
2273 /* Hash functions.
2274  */
2275 
2276 /**
2277  * g_str_equal:
2278  * @v1: (not nullable): a key
2279  * @v2: (not nullable): a key to compare with @v1
2280  *
2281  * Compares two strings for byte-by-byte equality and returns %TRUE
2282  * if they are equal. It can be passed to g_hash_table_new() as the
2283  * @key_equal_func parameter, when using non-%NULL strings as keys in a
2284  * #GHashTable.
2285  *
2286  * This function is typically used for hash table comparisons, but can be used
2287  * for general purpose comparisons of non-%NULL strings. For a %NULL-safe string
2288  * comparison function, see g_strcmp0().
2289  *
2290  * Returns: %TRUE if the two keys match
2291  */
2292 gboolean
2293 g_str_equal (gconstpointer v1,
2294              gconstpointer v2)
2295 {
2296   const gchar *string1 = v1;
2297   const gchar *string2 = v2;
2298 
2299   return strcmp (string1, string2) == 0;
2300 }
2301 
2302 /**
2303  * g_str_hash:
2304  * @v: (not nullable): a string key
2305  *
2306  * Converts a string to a hash value.
2307  *
2308  * This function implements the widely used &quot;djb&quot; hash apparently
2309  * posted by Daniel Bernstein to comp.lang.c some time ago.  The 32
2310  * bit unsigned hash value starts at 5381 and for each byte &#39;c&#39; in
2311  * the string, is updated: `hash = hash * 33 + c`. This function
2312  * uses the signed value of each byte.
2313  *
2314  * It can be passed to g_hash_table_new() as the @hash_func parameter,
2315  * when using non-%NULL strings as keys in a #GHashTable.
2316  *
2317  * Note that this function may not be a perfect fit for all use cases.
2318  * For example, it produces some hash collisions with strings as short
2319  * as 2.
2320  *
2321  * Returns: a hash value corresponding to the key
2322  */
2323 guint
2324 g_str_hash (gconstpointer v)
2325 {
2326   const signed char *p;
2327   guint32 h = 5381;
2328 
2329   for (p = v; *p != &#39;\0&#39;; p++)
2330     h = (h &lt;&lt; 5) + h + *p;
2331 
2332   return h;
2333 }
2334 
2335 /**
2336  * g_direct_hash:
2337  * @v: (nullable): a #gpointer key
2338  *
2339  * Converts a gpointer to a hash value.
2340  * It can be passed to g_hash_table_new() as the @hash_func parameter,
2341  * when using opaque pointers compared by pointer value as keys in a
2342  * #GHashTable.
2343  *
2344  * This hash function is also appropriate for keys that are integers
2345  * stored in pointers, such as `GINT_TO_POINTER (n)`.
2346  *
2347  * Returns: a hash value corresponding to the key.
2348  */
2349 guint
2350 g_direct_hash (gconstpointer v)
2351 {
2352   return GPOINTER_TO_UINT (v);
2353 }
2354 
2355 /**
2356  * g_direct_equal:
2357  * @v1: (nullable): a key
2358  * @v2: (nullable): a key to compare with @v1
2359  *
2360  * Compares two #gpointer arguments and returns %TRUE if they are equal.
2361  * It can be passed to g_hash_table_new() as the @key_equal_func
2362  * parameter, when using opaque pointers compared by pointer value as
2363  * keys in a #GHashTable.
2364  *
2365  * This equality function is also appropriate for keys that are integers
2366  * stored in pointers, such as `GINT_TO_POINTER (n)`.
2367  *
2368  * Returns: %TRUE if the two keys match.
2369  */
2370 gboolean
2371 g_direct_equal (gconstpointer v1,
2372                 gconstpointer v2)
2373 {
2374   return v1 == v2;
2375 }
2376 
2377 /**
2378  * g_int_equal:
2379  * @v1: (not nullable): a pointer to a #gint key
2380  * @v2: (not nullable): a pointer to a #gint key to compare with @v1
2381  *
2382  * Compares the two #gint values being pointed to and returns
2383  * %TRUE if they are equal.
2384  * It can be passed to g_hash_table_new() as the @key_equal_func
2385  * parameter, when using non-%NULL pointers to integers as keys in a
2386  * #GHashTable.
2387  *
2388  * Note that this function acts on pointers to #gint, not on #gint
2389  * directly: if your hash table&#39;s keys are of the form
2390  * `GINT_TO_POINTER (n)`, use g_direct_equal() instead.
2391  *
2392  * Returns: %TRUE if the two keys match.
2393  */
2394 gboolean
2395 g_int_equal (gconstpointer v1,
2396              gconstpointer v2)
2397 {
2398   return *((const gint*) v1) == *((const gint*) v2);
2399 }
2400 
2401 /**
2402  * g_int_hash:
2403  * @v: (not nullable): a pointer to a #gint key
2404  *
2405  * Converts a pointer to a #gint to a hash value.
2406  * It can be passed to g_hash_table_new() as the @hash_func parameter,
2407  * when using non-%NULL pointers to integer values as keys in a #GHashTable.
2408  *
2409  * Note that this function acts on pointers to #gint, not on #gint
2410  * directly: if your hash table&#39;s keys are of the form
2411  * `GINT_TO_POINTER (n)`, use g_direct_hash() instead.
2412  *
2413  * Returns: a hash value corresponding to the key.
2414  */
2415 guint
2416 g_int_hash (gconstpointer v)
2417 {
2418   return *(const gint*) v;
2419 }
2420 
2421 /**
2422  * g_int64_equal:
2423  * @v1: (not nullable): a pointer to a #gint64 key
2424  * @v2: (not nullable): a pointer to a #gint64 key to compare with @v1
2425  *
2426  * Compares the two #gint64 values being pointed to and returns
2427  * %TRUE if they are equal.
2428  * It can be passed to g_hash_table_new() as the @key_equal_func
2429  * parameter, when using non-%NULL pointers to 64-bit integers as keys in a
2430  * #GHashTable.
2431  *
2432  * Returns: %TRUE if the two keys match.
2433  *
2434  * Since: 2.22
2435  */
2436 gboolean
2437 g_int64_equal (gconstpointer v1,
2438                gconstpointer v2)
2439 {
2440   return *((const gint64*) v1) == *((const gint64*) v2);
2441 }
2442 
2443 /**
2444  * g_int64_hash:
2445  * @v: (not nullable): a pointer to a #gint64 key
2446  *
2447  * Converts a pointer to a #gint64 to a hash value.
2448  *
2449  * It can be passed to g_hash_table_new() as the @hash_func parameter,
2450  * when using non-%NULL pointers to 64-bit integer values as keys in a
2451  * #GHashTable.
2452  *
2453  * Returns: a hash value corresponding to the key.
2454  *
2455  * Since: 2.22
2456  */
2457 guint
2458 g_int64_hash (gconstpointer v)
2459 {
2460   return (guint) *(const gint64*) v;
2461 }
2462 
2463 /**
2464  * g_double_equal:
2465  * @v1: (not nullable): a pointer to a #gdouble key
2466  * @v2: (not nullable): a pointer to a #gdouble key to compare with @v1
2467  *
2468  * Compares the two #gdouble values being pointed to and returns
2469  * %TRUE if they are equal.
2470  * It can be passed to g_hash_table_new() as the @key_equal_func
2471  * parameter, when using non-%NULL pointers to doubles as keys in a
2472  * #GHashTable.
2473  *
2474  * Returns: %TRUE if the two keys match.
2475  *
2476  * Since: 2.22
2477  */
2478 gboolean
2479 g_double_equal (gconstpointer v1,
2480                 gconstpointer v2)
2481 {
2482   return *((const gdouble*) v1) == *((const gdouble*) v2);
2483 }
2484 
2485 /**
2486  * g_double_hash:
2487  * @v: (not nullable): a pointer to a #gdouble key
2488  *
2489  * Converts a pointer to a #gdouble to a hash value.
2490  * It can be passed to g_hash_table_new() as the @hash_func parameter,
2491  * It can be passed to g_hash_table_new() as the @hash_func parameter,
2492  * when using non-%NULL pointers to doubles as keys in a #GHashTable.
2493  *
2494  * Returns: a hash value corresponding to the key.
2495  *
2496  * Since: 2.22
2497  */
2498 guint
2499 g_double_hash (gconstpointer v)
2500 {
2501   return (guint) *(const gdouble*) v;
2502 }
<a name="80" id="anc80"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="80" type="hidden" />
</body>
</html>