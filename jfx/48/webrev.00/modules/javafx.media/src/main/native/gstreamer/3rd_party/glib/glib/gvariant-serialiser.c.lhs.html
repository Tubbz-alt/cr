<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvariant-serialiser.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright � 2007, 2008 Ryan Lortie</span>
<span class="line-modified">   3  * Copyright � 2010 Codethink Limited</span>
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public
  16  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  *
  18  * Author: Ryan Lortie &lt;desrt@desrt.ca&gt;
  19  */
  20 
  21 /* Prologue {{{1 */
  22 #include &quot;config.h&quot;
  23 
  24 #include &quot;gvariant-serialiser.h&quot;
<a name="2" id="anc2"></a><span class="line-removed">  25 #include &quot;gunicodeprivate.h&quot;</span>
  26 
  27 #include &lt;glib/gvariant-internal.h&gt;
  28 #include &lt;glib/gtestutils.h&gt;
  29 #include &lt;glib/gstrfuncs.h&gt;
  30 #include &lt;glib/gtypes.h&gt;
  31 
  32 #include &lt;string.h&gt;
  33 
  34 
  35 /* GVariantSerialiser
  36  *
  37  * After this prologue section, this file has roughly 2 parts.
  38  *
  39  * The first part is split up into sections according to various
  40  * container types.  Maybe, Array, Tuple, Variant.  The Maybe and Array
  41  * sections are subdivided for element types being fixed or
  42  * variable-sized types.
  43  *
  44  * Each section documents the format of that particular type of
  45  * container and implements 5 functions for dealing with it:
  46  *
  47  *  n_children:
  48  *    - determines (according to serialised data) how many child values
  49  *      are inside a particular container value.
  50  *
  51  *  get_child:
  52  *    - gets the type of and the serialised data corresponding to a
  53  *      given child value within the container value.
  54  *
  55  *  needed_size:
  56  *    - determines how much space would be required to serialise a
  57  *      container of this type, containing the given children so that
  58  *      buffers can be preallocated before serialising.
  59  *
  60  *  serialise:
  61  *    - write the serialised data for a container of this type,
  62  *      containing the given children, to a buffer.
  63  *
  64  *  is_normal:
  65  *    - check the given data to ensure that it is in normal form.  For a
  66  *      given set of child values, there is exactly one normal form for
  67  *      the serialised data of a container.  Other forms are possible
  68  *      while maintaining the same children (for example, by inserting
  69  *      something other than zero bytes as padding) but only one form is
  70  *      the normal form.
  71  *
  72  * The second part contains the main entry point for each of the above 5
  73  * functions and logic to dispatch it to the handler for the appropriate
  74  * container type code.
  75  *
  76  * The second part also contains a routine to byteswap serialised
  77  * values.  This code makes use of the n_children() and get_child()
  78  * functions above to do its work so no extra support is needed on a
  79  * per-container-type basis.
  80  *
  81  * There is also additional code for checking for normal form.  All
  82  * numeric types are always in normal form since the full range of
  83  * values is permitted (eg: 0 to 255 is a valid byte).  Special checks
  84  * need to be performed for booleans (only 0 or 1 allowed), strings
  85  * (properly nul-terminated) and object paths and signature strings
  86  * (meeting the D-Bus specification requirements).  Depth checks need to be
  87  * performed for nested types (arrays, tuples, and variants), to avoid massive
  88  * recursion which could exhaust our stack when handling untrusted input.
  89  */
  90 
  91 /* &lt; private &gt;
  92  * GVariantSerialised:
  93  * @type_info: the #GVariantTypeInfo of this value
  94  * @data: (nullable): the serialised data of this value, or %NULL
  95  * @size: the size of this value
  96  *
  97  * A structure representing a GVariant in serialised form.  This
  98  * structure is used with #GVariantSerialisedFiller functions and as the
  99  * primary interface to the serialiser.  See #GVariantSerialisedFiller
 100  * for a description of its use there.
 101  *
 102  * When used with the serialiser API functions, the following invariants
 103  * apply to all #GVariantTypeSerialised structures passed to and
 104  * returned from the serialiser.
 105  *
 106  * @type_info must be non-%NULL.
 107  *
 108  * @data must be properly aligned for the type described by @type_info.
 109  *
 110  * If @type_info describes a fixed-sized type then @size must always be
 111  * equal to the fixed size of that type.
 112  *
 113  * For fixed-sized types (and only fixed-sized types), @data may be
 114  * %NULL even if @size is non-zero.  This happens when a framing error
 115  * occurs while attempting to extract a fixed-sized value out of a
 116  * variable-sized container.  There is no data to return for the
 117  * fixed-sized type, yet @size must be non-zero.  The effect of this
 118  * combination should be as if @data were a pointer to an
 119  * appropriately-sized zero-filled region.
 120  *
 121  * @depth has no restrictions; the depth of a top-level serialised #GVariant is
 122  * zero, and it increases for each level of nested child.
 123  */
 124 
 125 /* &lt; private &gt;
 126  * g_variant_serialised_check:
 127  * @serialised: a #GVariantSerialised struct
 128  *
 129  * Checks @serialised for validity according to the invariants described
 130  * above.
<a name="3" id="anc3"></a>

 131  */
<a name="4" id="anc4"></a><span class="line-modified"> 132 static void</span>
 133 g_variant_serialised_check (GVariantSerialised serialised)
 134 {
 135   gsize fixed_size;
 136   guint alignment;
 137 
<a name="5" id="anc5"></a><span class="line-modified"> 138   g_assert (serialised.type_info != NULL);</span>

 139   g_variant_type_info_query (serialised.type_info, &amp;alignment, &amp;fixed_size);
 140 
<a name="6" id="anc6"></a><span class="line-modified"> 141   if (fixed_size)</span>
<span class="line-modified"> 142     g_assert_cmpint (serialised.size, ==, fixed_size);</span>
<span class="line-modified"> 143   else</span>
<span class="line-modified"> 144     g_assert (serialised.size == 0 || serialised.data != NULL);</span>

 145 
 146   /* Depending on the native alignment requirements of the machine, the
 147    * compiler will insert either 3 or 7 padding bytes after the char.
 148    * This will result in the sizeof() the struct being 12 or 16.
 149    * Subtract 9 to get 3 or 7 which is a nice bitmask to apply to get
 150    * the alignment bits that we &quot;care about&quot; being zero: in the
 151    * 4-aligned case, we care about 2 bits, and in the 8-aligned case, we
 152    * care about 3 bits.
 153    */
 154   alignment &amp;= sizeof (struct {
 155                          char a;
 156                          union {
 157                            guint64 x;
 158                            void *y;
 159                            gdouble z;
 160                          } b;
 161                        }
 162                       ) - 9;
 163 
 164   /* Some OSes (FreeBSD is a known example) have a malloc() that returns
 165    * unaligned memory if you request small sizes.  &#39;malloc (1);&#39;, for
 166    * example, has been seen to return pointers aligned to 6 mod 16.
 167    *
 168    * Check if this is a small allocation and return without enforcing
 169    * the alignment assertion if this is the case.
 170    */
<a name="7" id="anc7"></a><span class="line-modified"> 171   if (serialised.size &lt;= alignment)</span>
<span class="line-modified"> 172     return;</span>
<span class="line-removed"> 173 </span>
<span class="line-removed"> 174   g_assert_cmpint (alignment &amp; (gsize) serialised.data, ==, 0);</span>
 175 }
 176 
 177 /* &lt; private &gt;
 178  * GVariantSerialisedFiller:
 179  * @serialised: a #GVariantSerialised instance to fill
 180  * @data: data from the children array
 181  *
 182  * This function is called back from g_variant_serialiser_needed_size()
 183  * and g_variant_serialiser_serialise().  It fills in missing details
 184  * from a partially-complete #GVariantSerialised.
 185  *
 186  * The @data parameter passed back to the function is one of the items
 187  * that was passed to the serialiser in the @children array.  It
 188  * represents a single child item of the container that is being
 189  * serialised.  The information filled in to @serialised is the
 190  * information for this child.
 191  *
 192  * If the @type_info field of @serialised is %NULL then the callback
 193  * function must set it to the type information corresponding to the
 194  * type of the child.  No reference should be added.  If it is non-%NULL
 195  * then the callback should assert that it is equal to the actual type
 196  * of the child.
 197  *
 198  * If the @size field is zero then the callback must fill it in with the
 199  * required amount of space to store the serialised form of the child.
 200  * If it is non-zero then the callback should assert that it is equal to
 201  * the needed size of the child.
 202  *
 203  * If @data is non-%NULL then it points to a space that is properly
 204  * aligned for and large enough to store the serialised data of the
 205  * child.  The callback must store the serialised form of the child at
 206  * @data.
 207  *
 208  * If the child value is another container then the callback will likely
 209  * recurse back into the serialiser by calling
 210  * g_variant_serialiser_needed_size() to determine @size and
 211  * g_variant_serialiser_serialise() to write to @data.
 212  */
 213 
 214 /* PART 1: Container types {{{1
 215  *
 216  * This section contains the serialiser implementation functions for
 217  * each container type.
 218  */
 219 
 220 /* Maybe {{{2
 221  *
 222  * Maybe types are handled depending on if the element type of the maybe
 223  * type is a fixed-sized or variable-sized type.  Although all maybe
 224  * types themselves are variable-sized types, herein, a maybe value with
 225  * a fixed-sized element type is called a &quot;fixed-sized maybe&quot; for
 226  * convenience and a maybe value with a variable-sized element type is
 227  * called a &quot;variable-sized maybe&quot;.
 228  */
 229 
 230 /* Fixed-sized Maybe {{{3
 231  *
 232  * The size of a maybe value with a fixed-sized element type is either 0
 233  * or equal to the fixed size of its element type.  The case where the
 234  * size of the maybe value is zero corresponds to the &quot;Nothing&quot; case and
 235  * the case where the size of the maybe value is equal to the fixed size
 236  * of the element type corresponds to the &quot;Just&quot; case; in that case, the
 237  * serialised data of the child value forms the entire serialised data
 238  * of the maybe value.
 239  *
 240  * In the event that a fixed-sized maybe value is presented with a size
 241  * that is not equal to the fixed size of the element type then the
 242  * value must be taken to be &quot;Nothing&quot;.
 243  */
 244 
 245 static gsize
 246 gvs_fixed_sized_maybe_n_children (GVariantSerialised value)
 247 {
 248   gsize element_fixed_size;
 249 
 250   g_variant_type_info_query_element (value.type_info, NULL,
 251                                      &amp;element_fixed_size);
 252 
 253   return (element_fixed_size == value.size) ? 1 : 0;
 254 }
 255 
 256 static GVariantSerialised
 257 gvs_fixed_sized_maybe_get_child (GVariantSerialised value,
 258                                  gsize              index_)
 259 {
 260   /* the child has the same bounds as the
 261    * container, so just update the type.
 262    */
 263   value.type_info = g_variant_type_info_element (value.type_info);
 264   g_variant_type_info_ref (value.type_info);
 265   value.depth++;
 266 
 267   return value;
 268 }
 269 
 270 static gsize
 271 gvs_fixed_sized_maybe_needed_size (GVariantTypeInfo         *type_info,
 272                                    GVariantSerialisedFiller  gvs_filler,
 273                                    const gpointer           *children,
 274                                    gsize                     n_children)
 275 {
 276   if (n_children)
 277     {
 278       gsize element_fixed_size;
 279 
 280       g_variant_type_info_query_element (type_info, NULL,
 281                                          &amp;element_fixed_size);
 282 
 283       return element_fixed_size;
 284     }
 285   else
 286     return 0;
 287 }
 288 
 289 static void
 290 gvs_fixed_sized_maybe_serialise (GVariantSerialised        value,
 291                                  GVariantSerialisedFiller  gvs_filler,
 292                                  const gpointer           *children,
 293                                  gsize                     n_children)
 294 {
 295   if (n_children)
 296     {
 297       GVariantSerialised child = { NULL, value.data, value.size, value.depth + 1 };
 298 
 299       gvs_filler (&amp;child, children[0]);
 300     }
 301 }
 302 
 303 static gboolean
 304 gvs_fixed_sized_maybe_is_normal (GVariantSerialised value)
 305 {
 306   if (value.size &gt; 0)
 307     {
 308       gsize element_fixed_size;
 309 
 310       g_variant_type_info_query_element (value.type_info,
 311                                          NULL, &amp;element_fixed_size);
 312 
 313       if (value.size != element_fixed_size)
 314         return FALSE;
 315 
 316       /* proper element size: &quot;Just&quot;.  recurse to the child. */
 317       value.type_info = g_variant_type_info_element (value.type_info);
 318       value.depth++;
 319 
 320       return g_variant_serialised_is_normal (value);
 321     }
 322 
 323   /* size of 0: &quot;Nothing&quot; */
 324   return TRUE;
 325 }
 326 
 327 /* Variable-sized Maybe
 328  *
 329  * The size of a maybe value with a variable-sized element type is
 330  * either 0 or strictly greater than 0.  The case where the size of the
 331  * maybe value is zero corresponds to the &quot;Nothing&quot; case and the case
 332  * where the size of the maybe value is greater than zero corresponds to
 333  * the &quot;Just&quot; case; in that case, the serialised data of the child value
 334  * forms the first part of the serialised data of the maybe value and is
 335  * followed by a single zero byte.  This zero byte is always appended,
 336  * regardless of any zero bytes that may already be at the end of the
 337  * serialised ata of the child value.
 338  */
 339 
 340 static gsize
 341 gvs_variable_sized_maybe_n_children (GVariantSerialised value)
 342 {
 343   return (value.size &gt; 0) ? 1 : 0;
 344 }
 345 
 346 static GVariantSerialised
 347 gvs_variable_sized_maybe_get_child (GVariantSerialised value,
 348                                     gsize              index_)
 349 {
 350   /* remove the padding byte and update the type. */
 351   value.type_info = g_variant_type_info_element (value.type_info);
 352   g_variant_type_info_ref (value.type_info);
 353   value.size--;
 354 
 355   /* if it&#39;s zero-sized then it may as well be NULL */
 356   if (value.size == 0)
 357     value.data = NULL;
 358 
 359   value.depth++;
 360 
 361   return value;
 362 }
 363 
 364 static gsize
 365 gvs_variable_sized_maybe_needed_size (GVariantTypeInfo         *type_info,
 366                                       GVariantSerialisedFiller  gvs_filler,
 367                                       const gpointer           *children,
 368                                       gsize                     n_children)
 369 {
 370   if (n_children)
 371     {
 372       GVariantSerialised child = { 0, };
 373 
 374       gvs_filler (&amp;child, children[0]);
 375 
 376       return child.size + 1;
 377     }
 378   else
 379     return 0;
 380 }
 381 
 382 static void
 383 gvs_variable_sized_maybe_serialise (GVariantSerialised        value,
 384                                     GVariantSerialisedFiller  gvs_filler,
 385                                     const gpointer           *children,
 386                                     gsize                     n_children)
 387 {
 388   if (n_children)
 389     {
 390       GVariantSerialised child = { NULL, value.data, value.size - 1, value.depth + 1 };
 391 
 392       /* write the data for the child.  */
 393       gvs_filler (&amp;child, children[0]);
 394       value.data[child.size] = &#39;\0&#39;;
 395     }
 396 }
 397 
 398 static gboolean
 399 gvs_variable_sized_maybe_is_normal (GVariantSerialised value)
 400 {
 401   if (value.size == 0)
 402     return TRUE;
 403 
 404   if (value.data[value.size - 1] != &#39;\0&#39;)
 405     return FALSE;
 406 
 407   value.type_info = g_variant_type_info_element (value.type_info);
 408   value.size--;
 409   value.depth++;
 410 
 411   return g_variant_serialised_is_normal (value);
 412 }
 413 
 414 /* Arrays {{{2
 415  *
 416  * Just as with maybe types, array types are handled depending on if the
 417  * element type of the array type is a fixed-sized or variable-sized
 418  * type.  Similar to maybe types, for convenience, an array value with a
 419  * fixed-sized element type is called a &quot;fixed-sized array&quot; and an array
 420  * value with a variable-sized element type is called a &quot;variable sized
 421  * array&quot;.
 422  */
 423 
 424 /* Fixed-sized Array {{{3
 425  *
 426  * For fixed sized arrays, the serialised data is simply a concatenation
 427  * of the serialised data of each element, in order.  Since fixed-sized
 428  * values always have a fixed size that is a multiple of their alignment
 429  * requirement no extra padding is required.
 430  *
 431  * In the event that a fixed-sized array is presented with a size that
 432  * is not an integer multiple of the element size then the value of the
 433  * array must be taken as being empty.
 434  */
 435 
 436 static gsize
 437 gvs_fixed_sized_array_n_children (GVariantSerialised value)
 438 {
 439   gsize element_fixed_size;
 440 
 441   g_variant_type_info_query_element (value.type_info, NULL,
 442                                      &amp;element_fixed_size);
 443 
 444   if (value.size % element_fixed_size == 0)
 445     return value.size / element_fixed_size;
 446 
 447   return 0;
 448 }
 449 
 450 static GVariantSerialised
 451 gvs_fixed_sized_array_get_child (GVariantSerialised value,
 452                                  gsize              index_)
 453 {
 454   GVariantSerialised child = { 0, };
 455 
 456   child.type_info = g_variant_type_info_element (value.type_info);
 457   g_variant_type_info_query (child.type_info, NULL, &amp;child.size);
 458   child.data = value.data + (child.size * index_);
 459   g_variant_type_info_ref (child.type_info);
 460   child.depth = value.depth + 1;
 461 
 462   return child;
 463 }
 464 
 465 static gsize
 466 gvs_fixed_sized_array_needed_size (GVariantTypeInfo         *type_info,
 467                                    GVariantSerialisedFiller  gvs_filler,
 468                                    const gpointer           *children,
 469                                    gsize                     n_children)
 470 {
 471   gsize element_fixed_size;
 472 
 473   g_variant_type_info_query_element (type_info, NULL, &amp;element_fixed_size);
 474 
 475   return element_fixed_size * n_children;
 476 }
 477 
 478 static void
 479 gvs_fixed_sized_array_serialise (GVariantSerialised        value,
 480                                  GVariantSerialisedFiller  gvs_filler,
 481                                  const gpointer           *children,
 482                                  gsize                     n_children)
 483 {
 484   GVariantSerialised child = { 0, };
 485   gsize i;
 486 
 487   child.type_info = g_variant_type_info_element (value.type_info);
 488   g_variant_type_info_query (child.type_info, NULL, &amp;child.size);
 489   child.data = value.data;
 490   child.depth = value.depth + 1;
 491 
 492   for (i = 0; i &lt; n_children; i++)
 493     {
 494       gvs_filler (&amp;child, children[i]);
 495       child.data += child.size;
 496     }
 497 }
 498 
 499 static gboolean
 500 gvs_fixed_sized_array_is_normal (GVariantSerialised value)
 501 {
 502   GVariantSerialised child = { 0, };
 503 
 504   child.type_info = g_variant_type_info_element (value.type_info);
 505   g_variant_type_info_query (child.type_info, NULL, &amp;child.size);
 506   child.depth = value.depth + 1;
 507 
 508   if (value.size % child.size != 0)
 509     return FALSE;
 510 
 511   for (child.data = value.data;
 512        child.data &lt; value.data + value.size;
 513        child.data += child.size)
 514     {
 515       if (!g_variant_serialised_is_normal (child))
 516         return FALSE;
 517     }
 518 
 519   return TRUE;
 520 }
 521 
 522 /* Variable-sized Array {{{3
 523  *
 524  * Variable sized arrays, containing variable-sized elements, must be
 525  * able to determine the boundaries between the elements.  The items
 526  * cannot simply be concatenated.  Additionally, we are faced with the
 527  * fact that non-fixed-sized values do not necessarily have a size that
 528  * is a multiple of their alignment requirement, so we may need to
 529  * insert zero-filled padding.
 530  *
 531  * While it is possible to find the start of an item by starting from
 532  * the end of the item before it and padding for alignment, it is not
 533  * generally possible to do the reverse operation.  For this reason, we
 534  * record the end point of each element in the array.
 535  *
 536  * GVariant works in terms of &quot;offsets&quot;.  An offset is a pointer to a
 537  * boundary between two bytes.  In 4 bytes of serialised data, there
 538  * would be 5 possible offsets: one at the start (&#39;0&#39;), one between each
 539  * pair of adjacent bytes (&#39;1&#39;, &#39;2&#39;, &#39;3&#39;) and one at the end (&#39;4&#39;).
 540  *
 541  * The numeric value of an offset is an unsigned integer given relative
 542  * to the start of the serialised data of the array.  Offsets are always
 543  * stored in little endian byte order and are always only as big as they
 544  * need to be.  For example, in 255 bytes of serialised data, there are
 545  * 256 offsets.  All possibilities can be stored in an 8 bit unsigned
 546  * integer.  In 256 bytes of serialised data, however, there are 257
 547  * possible offsets so 16 bit integers must be used.  The size of an
 548  * offset is always a power of 2.
 549  *
 550  * The offsets are stored at the end of the serialised data of the
 551  * array.  They are simply concatenated on without any particular
 552  * alignment.  The size of the offsets is included in the size of the
 553  * serialised data for purposes of determining the size of the offsets.
 554  * This presents a possibly ambiguity; in certain cases, a particular
 555  * value of array could have two different serialised forms.
 556  *
 557  * Imagine an array containing a single string of 253 bytes in length
 558  * (so, 254 bytes including the nul terminator).  Now the offset must be
 559  * written.  If an 8 bit offset is written, it will bring the size of
 560  * the array&#39;s serialised data to 255 -- which means that the use of an
 561  * 8 bit offset was valid.  If a 16 bit offset is used then the total
 562  * size of the array will be 256 -- which means that the use of a 16 bit
 563  * offset was valid.  Although both of these will be accepted by the
 564  * deserialiser, only the smaller of the two is considered to be in
 565  * normal form and that is the one that the serialiser must produce.
 566  */
 567 
 568 /* bytes may be NULL if (size == 0). */
 569 static inline gsize
 570 gvs_read_unaligned_le (guchar *bytes,
 571                        guint   size)
 572 {
 573   union
 574   {
 575     guchar bytes[GLIB_SIZEOF_SIZE_T];
 576     gsize integer;
 577   } tmpvalue;
 578 
 579   tmpvalue.integer = 0;
 580   if (bytes != NULL)
 581     memcpy (&amp;tmpvalue.bytes, bytes, size);
 582 
 583   return GSIZE_FROM_LE (tmpvalue.integer);
 584 }
 585 
 586 static inline void
 587 gvs_write_unaligned_le (guchar *bytes,
 588                         gsize   value,
 589                         guint   size)
 590 {
 591   union
 592   {
 593     guchar bytes[GLIB_SIZEOF_SIZE_T];
 594     gsize integer;
 595   } tmpvalue;
 596 
 597   tmpvalue.integer = GSIZE_TO_LE (value);
 598   memcpy (bytes, &amp;tmpvalue.bytes, size);
 599 }
 600 
 601 static guint
 602 gvs_get_offset_size (gsize size)
 603 {
 604   if (size &gt; G_MAXUINT32)
 605     return 8;
 606 
 607   else if (size &gt; G_MAXUINT16)
 608     return 4;
 609 
 610   else if (size &gt; G_MAXUINT8)
 611     return 2;
 612 
 613   else if (size &gt; 0)
 614     return 1;
 615 
 616   return 0;
 617 }
 618 
 619 static gsize
 620 gvs_calculate_total_size (gsize body_size,
 621                           gsize offsets)
 622 {
 623   if (body_size + 1 * offsets &lt;= G_MAXUINT8)
 624     return body_size + 1 * offsets;
 625 
 626   if (body_size + 2 * offsets &lt;= G_MAXUINT16)
 627     return body_size + 2 * offsets;
 628 
 629   if (body_size + 4 * offsets &lt;= G_MAXUINT32)
 630     return body_size + 4 * offsets;
 631 
 632   return body_size + 8 * offsets;
 633 }
 634 
 635 static gsize
 636 gvs_variable_sized_array_n_children (GVariantSerialised value)
 637 {
 638   gsize offsets_array_size;
 639   gsize offset_size;
 640   gsize last_end;
 641 
 642   if (value.size == 0)
 643     return 0;
 644 
 645   offset_size = gvs_get_offset_size (value.size);
 646 
 647   last_end = gvs_read_unaligned_le (value.data + value.size -
 648                                     offset_size, offset_size);
 649 
 650   if (last_end &gt; value.size)
 651     return 0;
 652 
 653   offsets_array_size = value.size - last_end;
 654 
 655   if (offsets_array_size % offset_size)
 656     return 0;
 657 
 658   return offsets_array_size / offset_size;
 659 }
 660 
 661 static GVariantSerialised
 662 gvs_variable_sized_array_get_child (GVariantSerialised value,
 663                                     gsize              index_)
 664 {
 665   GVariantSerialised child = { 0, };
 666   gsize offset_size;
 667   gsize last_end;
 668   gsize start;
 669   gsize end;
 670 
 671   child.type_info = g_variant_type_info_element (value.type_info);
 672   g_variant_type_info_ref (child.type_info);
 673   child.depth = value.depth + 1;
 674 
 675   offset_size = gvs_get_offset_size (value.size);
 676 
 677   last_end = gvs_read_unaligned_le (value.data + value.size -
 678                                     offset_size, offset_size);
 679 
 680   if (index_ &gt; 0)
 681     {
 682       guint alignment;
 683 
 684       start = gvs_read_unaligned_le (value.data + last_end +
 685                                      (offset_size * (index_ - 1)),
 686                                      offset_size);
 687 
 688       g_variant_type_info_query (child.type_info, &amp;alignment, NULL);
 689       start += (-start) &amp; alignment;
 690     }
 691   else
 692     start = 0;
 693 
 694   end = gvs_read_unaligned_le (value.data + last_end +
 695                                (offset_size * index_),
 696                                offset_size);
 697 
 698   if (start &lt; end &amp;&amp; end &lt;= value.size &amp;&amp; end &lt;= last_end)
 699     {
 700       child.data = value.data + start;
 701       child.size = end - start;
 702     }
 703 
 704   return child;
 705 }
 706 
 707 static gsize
 708 gvs_variable_sized_array_needed_size (GVariantTypeInfo         *type_info,
 709                                       GVariantSerialisedFiller  gvs_filler,
 710                                       const gpointer           *children,
 711                                       gsize                     n_children)
 712 {
 713   guint alignment;
 714   gsize offset;
 715   gsize i;
 716 
 717   g_variant_type_info_query (type_info, &amp;alignment, NULL);
 718   offset = 0;
 719 
 720   for (i = 0; i &lt; n_children; i++)
 721     {
 722       GVariantSerialised child = { 0, };
 723 
 724       offset += (-offset) &amp; alignment;
 725       gvs_filler (&amp;child, children[i]);
 726       offset += child.size;
 727     }
 728 
 729   return gvs_calculate_total_size (offset, n_children);
 730 }
 731 
 732 static void
 733 gvs_variable_sized_array_serialise (GVariantSerialised        value,
 734                                     GVariantSerialisedFiller  gvs_filler,
 735                                     const gpointer           *children,
 736                                     gsize                     n_children)
 737 {
 738   guchar *offset_ptr;
 739   gsize offset_size;
 740   guint alignment;
 741   gsize offset;
 742   gsize i;
 743 
 744   g_variant_type_info_query (value.type_info, &amp;alignment, NULL);
 745   offset_size = gvs_get_offset_size (value.size);
 746   offset = 0;
 747 
 748   offset_ptr = value.data + value.size - offset_size * n_children;
 749 
 750   for (i = 0; i &lt; n_children; i++)
 751     {
 752       GVariantSerialised child = { 0, };
 753 
 754       while (offset &amp; alignment)
 755         value.data[offset++] = &#39;\0&#39;;
 756 
 757       child.data = value.data + offset;
 758       gvs_filler (&amp;child, children[i]);
 759       offset += child.size;
 760 
 761       gvs_write_unaligned_le (offset_ptr, offset, offset_size);
 762       offset_ptr += offset_size;
 763     }
 764 }
 765 
 766 static gboolean
 767 gvs_variable_sized_array_is_normal (GVariantSerialised value)
 768 {
 769   GVariantSerialised child = { 0, };
 770   gsize offsets_array_size;
 771   guchar *offsets_array;
 772   guint offset_size;
 773   guint alignment;
 774   gsize last_end;
 775   gsize length;
 776   gsize offset;
 777   gsize i;
 778 
 779   if (value.size == 0)
 780     return TRUE;
 781 
 782   offset_size = gvs_get_offset_size (value.size);
 783   last_end = gvs_read_unaligned_le (value.data + value.size -
 784                                     offset_size, offset_size);
 785 
 786   if (last_end &gt; value.size)
 787     return FALSE;
 788 
 789   offsets_array_size = value.size - last_end;
 790 
 791   if (offsets_array_size % offset_size)
 792     return FALSE;
 793 
 794   offsets_array = value.data + value.size - offsets_array_size;
 795   length = offsets_array_size / offset_size;
 796 
 797   if (length == 0)
 798     return FALSE;
 799 
 800   child.type_info = g_variant_type_info_element (value.type_info);
 801   g_variant_type_info_query (child.type_info, &amp;alignment, NULL);
 802   child.depth = value.depth + 1;
 803   offset = 0;
 804 
 805   for (i = 0; i &lt; length; i++)
 806     {
 807       gsize this_end;
 808 
 809       this_end = gvs_read_unaligned_le (offsets_array + offset_size * i,
 810                                         offset_size);
 811 
 812       if (this_end &lt; offset || this_end &gt; last_end)
 813         return FALSE;
 814 
 815       while (offset &amp; alignment)
 816         {
 817           if (!(offset &lt; this_end &amp;&amp; value.data[offset] == &#39;\0&#39;))
 818             return FALSE;
 819           offset++;
 820         }
 821 
 822       child.data = value.data + offset;
 823       child.size = this_end - offset;
 824 
 825       if (child.size == 0)
 826         child.data = NULL;
 827 
 828       if (!g_variant_serialised_is_normal (child))
 829         return FALSE;
 830 
 831       offset = this_end;
 832     }
 833 
 834   g_assert (offset == last_end);
 835 
 836   return TRUE;
 837 }
 838 
 839 /* Tuples {{{2
 840  *
 841  * Since tuples can contain a mix of variable- and fixed-sized items,
 842  * they are, in terms of serialisation, a hybrid of variable-sized and
 843  * fixed-sized arrays.
 844  *
 845  * Offsets are only stored for variable-sized items.  Also, since the
 846  * number of items in a tuple is known from its type, we are able to
 847  * know exactly how many offsets to expect in the serialised data (and
 848  * therefore how much space is taken up by the offset array).  This
 849  * means that we know where the end of the serialised data for the last
 850  * item is -- we can just subtract the size of the offset array from the
 851  * total size of the tuple.  For this reason, the last item in the tuple
 852  * doesn&#39;t need an offset stored.
 853  *
 854  * Tuple offsets are stored in reverse.  This design choice allows
 855  * iterator-based deserialisers to be more efficient.
 856  *
 857  * Most of the &quot;heavy lifting&quot; here is handled by the GVariantTypeInfo
 858  * for the tuple.  See the notes in gvarianttypeinfo.h.
 859  */
 860 
 861 static gsize
 862 gvs_tuple_n_children (GVariantSerialised value)
 863 {
 864   return g_variant_type_info_n_members (value.type_info);
 865 }
 866 
 867 static GVariantSerialised
 868 gvs_tuple_get_child (GVariantSerialised value,
 869                      gsize              index_)
 870 {
 871   const GVariantMemberInfo *member_info;
 872   GVariantSerialised child = { 0, };
 873   gsize offset_size;
 874   gsize start, end, last_end;
 875 
 876   member_info = g_variant_type_info_member_info (value.type_info, index_);
 877   child.type_info = g_variant_type_info_ref (member_info-&gt;type_info);
 878   child.depth = value.depth + 1;
 879   offset_size = gvs_get_offset_size (value.size);
 880 
 881   /* tuples are the only (potentially) fixed-sized containers, so the
 882    * only ones that have to deal with the possibility of having %NULL
 883    * data with a non-zero %size if errors occurred elsewhere.
 884    */
 885   if G_UNLIKELY (value.data == NULL &amp;&amp; value.size != 0)
 886     {
 887       g_variant_type_info_query (child.type_info, NULL, &amp;child.size);
 888 
 889       /* this can only happen in fixed-sized tuples,
 890        * so the child must also be fixed sized.
 891        */
 892       g_assert (child.size != 0);
 893       child.data = NULL;
 894 
 895       return child;
 896     }
 897 
 898   if (member_info-&gt;ending_type == G_VARIANT_MEMBER_ENDING_OFFSET)
 899     {
 900       if (offset_size * (member_info-&gt;i + 2) &gt; value.size)
 901         return child;
 902     }
 903   else
 904     {
 905       if (offset_size * (member_info-&gt;i + 1) &gt; value.size)
 906         {
 907           /* if the child is fixed size, return its size.
 908            * if child is not fixed-sized, return size = 0.
 909            */
 910           g_variant_type_info_query (child.type_info, NULL, &amp;child.size);
 911 
 912           return child;
 913         }
 914     }
 915 
 916   if (member_info-&gt;i + 1)
 917     start = gvs_read_unaligned_le (value.data + value.size -
 918                                    offset_size * (member_info-&gt;i + 1),
 919                                    offset_size);
 920   else
 921     start = 0;
 922 
 923   start += member_info-&gt;a;
 924   start &amp;= member_info-&gt;b;
 925   start |= member_info-&gt;c;
 926 
 927   if (member_info-&gt;ending_type == G_VARIANT_MEMBER_ENDING_LAST)
 928     end = value.size - offset_size * (member_info-&gt;i + 1);
 929 
 930   else if (member_info-&gt;ending_type == G_VARIANT_MEMBER_ENDING_FIXED)
 931     {
 932       gsize fixed_size;
 933 
 934       g_variant_type_info_query (child.type_info, NULL, &amp;fixed_size);
 935       end = start + fixed_size;
 936       child.size = fixed_size;
 937     }
 938 
 939   else /* G_VARIANT_MEMBER_ENDING_OFFSET */
 940     end = gvs_read_unaligned_le (value.data + value.size -
 941                                  offset_size * (member_info-&gt;i + 2),
 942                                  offset_size);
 943 
 944   /* The child should not extend into the offset table. */
 945   if (index_ != g_variant_type_info_n_members (value.type_info) - 1)
 946     {
 947       GVariantSerialised last_child;
 948       last_child = gvs_tuple_get_child (value,
 949                                         g_variant_type_info_n_members (value.type_info) - 1);
 950       last_end = last_child.data + last_child.size - value.data;
 951       g_variant_type_info_unref (last_child.type_info);
 952     }
 953   else
 954     last_end = end;
 955 
 956   if (start &lt; end &amp;&amp; end &lt;= value.size &amp;&amp; end &lt;= last_end)
 957     {
 958       child.data = value.data + start;
 959       child.size = end - start;
 960     }
 961 
 962   return child;
 963 }
 964 
 965 static gsize
 966 gvs_tuple_needed_size (GVariantTypeInfo         *type_info,
 967                        GVariantSerialisedFiller  gvs_filler,
 968                        const gpointer           *children,
 969                        gsize                     n_children)
 970 {
 971   const GVariantMemberInfo *member_info = NULL;
 972   gsize fixed_size;
 973   gsize offset;
 974   gsize i;
 975 
 976   g_variant_type_info_query (type_info, NULL, &amp;fixed_size);
 977 
 978   if (fixed_size)
 979     return fixed_size;
 980 
 981   offset = 0;
 982 
 983   for (i = 0; i &lt; n_children; i++)
 984     {
 985       guint alignment;
 986 
 987       member_info = g_variant_type_info_member_info (type_info, i);
 988       g_variant_type_info_query (member_info-&gt;type_info,
 989                                  &amp;alignment, &amp;fixed_size);
 990       offset += (-offset) &amp; alignment;
 991 
 992       if (fixed_size)
 993         offset += fixed_size;
 994       else
 995         {
 996           GVariantSerialised child = { 0, };
 997 
 998           gvs_filler (&amp;child, children[i]);
 999           offset += child.size;
1000         }
1001     }
1002 
1003   return gvs_calculate_total_size (offset, member_info-&gt;i + 1);
1004 }
1005 
1006 static void
1007 gvs_tuple_serialise (GVariantSerialised        value,
1008                      GVariantSerialisedFiller  gvs_filler,
1009                      const gpointer           *children,
1010                      gsize                     n_children)
1011 {
1012   gsize offset_size;
1013   gsize offset;
1014   gsize i;
1015 
1016   offset_size = gvs_get_offset_size (value.size);
1017   offset = 0;
1018 
1019   for (i = 0; i &lt; n_children; i++)
1020     {
1021       const GVariantMemberInfo *member_info;
1022       GVariantSerialised child = { 0, };
1023       guint alignment;
1024 
1025       member_info = g_variant_type_info_member_info (value.type_info, i);
1026       g_variant_type_info_query (member_info-&gt;type_info, &amp;alignment, NULL);
1027 
1028       while (offset &amp; alignment)
1029         value.data[offset++] = &#39;\0&#39;;
1030 
1031       child.data = value.data + offset;
1032       gvs_filler (&amp;child, children[i]);
1033       offset += child.size;
1034 
1035       if (member_info-&gt;ending_type == G_VARIANT_MEMBER_ENDING_OFFSET)
1036         {
1037           value.size -= offset_size;
1038           gvs_write_unaligned_le (value.data + value.size,
1039                                   offset, offset_size);
1040         }
1041     }
1042 
1043   while (offset &lt; value.size)
1044     value.data[offset++] = &#39;\0&#39;;
1045 }
1046 
1047 static gboolean
1048 gvs_tuple_is_normal (GVariantSerialised value)
1049 {
1050   guint offset_size;
1051   gsize offset_ptr;
1052   gsize length;
1053   gsize offset;
1054   gsize i;
1055 
1056   /* as per the comment in gvs_tuple_get_child() */
1057   if G_UNLIKELY (value.data == NULL &amp;&amp; value.size != 0)
1058     return FALSE;
1059 
1060   offset_size = gvs_get_offset_size (value.size);
1061   length = g_variant_type_info_n_members (value.type_info);
1062   offset_ptr = value.size;
1063   offset = 0;
1064 
1065   for (i = 0; i &lt; length; i++)
1066     {
1067       const GVariantMemberInfo *member_info;
1068       GVariantSerialised child;
1069       gsize fixed_size;
1070       guint alignment;
1071       gsize end;
1072 
1073       member_info = g_variant_type_info_member_info (value.type_info, i);
1074       child.type_info = member_info-&gt;type_info;
1075       child.depth = value.depth + 1;
1076 
1077       g_variant_type_info_query (child.type_info, &amp;alignment, &amp;fixed_size);
1078 
1079       while (offset &amp; alignment)
1080         {
1081           if (offset &gt; value.size || value.data[offset] != &#39;\0&#39;)
1082             return FALSE;
1083           offset++;
1084         }
1085 
1086       child.data = value.data + offset;
1087 
1088       switch (member_info-&gt;ending_type)
1089         {
1090         case G_VARIANT_MEMBER_ENDING_FIXED:
1091           end = offset + fixed_size;
1092           break;
1093 
1094         case G_VARIANT_MEMBER_ENDING_LAST:
1095           end = offset_ptr;
1096           break;
1097 
1098         case G_VARIANT_MEMBER_ENDING_OFFSET:
1099           if (offset_ptr &lt; offset_size)
1100             return FALSE;
1101 
1102           offset_ptr -= offset_size;
1103 
1104           if (offset_ptr &lt; offset)
1105             return FALSE;
1106 
1107           end = gvs_read_unaligned_le (value.data + offset_ptr, offset_size);
1108           break;
1109 
1110         default:
1111           g_assert_not_reached ();
1112         }
1113 
1114       if (end &lt; offset || end &gt; offset_ptr)
1115         return FALSE;
1116 
1117       child.size = end - offset;
1118 
1119       if (child.size == 0)
1120         child.data = NULL;
1121 
1122       if (!g_variant_serialised_is_normal (child))
1123         return FALSE;
1124 
1125       offset = end;
1126     }
1127 
1128   {
1129     gsize fixed_size;
1130     guint alignment;
1131 
1132     g_variant_type_info_query (value.type_info, &amp;alignment, &amp;fixed_size);
1133 
1134     if (fixed_size)
1135       {
1136         g_assert (fixed_size == value.size);
1137         g_assert (offset_ptr == value.size);
1138 
1139         if (i == 0)
1140           {
1141             if (value.data[offset++] != &#39;\0&#39;)
1142               return FALSE;
1143           }
1144         else
1145           {
1146             while (offset &amp; alignment)
1147               if (value.data[offset++] != &#39;\0&#39;)
1148                 return FALSE;
1149           }
1150 
1151         g_assert (offset == value.size);
1152       }
1153   }
1154 
1155   return offset_ptr == offset;
1156 }
1157 
1158 /* Variants {{{2
1159  *
1160  * Variants are stored by storing the serialised data of the child,
1161  * followed by a &#39;\0&#39; character, followed by the type string of the
1162  * child.
1163  *
1164  * In the case that a value is presented that contains no &#39;\0&#39;
1165  * character, or doesn&#39;t have a single well-formed definite type string
1166  * following that character, the variant must be taken as containing the
1167  * unit tuple: ().
1168  */
1169 
1170 static inline gsize
1171 gvs_variant_n_children (GVariantSerialised value)
1172 {
1173   return 1;
1174 }
1175 
1176 static inline GVariantSerialised
1177 gvs_variant_get_child (GVariantSerialised value,
1178                        gsize              index_)
1179 {
1180   GVariantSerialised child = { 0, };
1181 
1182   /* NOTE: not O(1) and impossible for it to be... */
1183   if (value.size)
1184     {
1185       /* find &#39;\0&#39; character */
1186       for (child.size = value.size - 1; child.size; child.size--)
1187         if (value.data[child.size] == &#39;\0&#39;)
1188           break;
1189 
1190       /* ensure we didn&#39;t just hit the start of the string */
1191       if (value.data[child.size] == &#39;\0&#39;)
1192         {
1193           const gchar *type_string = (gchar *) &amp;value.data[child.size + 1];
1194           const gchar *limit = (gchar *) &amp;value.data[value.size];
1195           const gchar *end;
1196 
1197           if (g_variant_type_string_scan (type_string, limit, &amp;end) &amp;&amp;
1198               end == limit)
1199             {
1200               const GVariantType *type = (GVariantType *) type_string;
1201 
1202               if (g_variant_type_is_definite (type))
1203                 {
1204                   gsize fixed_size;
1205                   gsize child_type_depth;
1206 
1207                   child.type_info = g_variant_type_info_get (type);
1208                   child.depth = value.depth + 1;
1209 
1210                   if (child.size != 0)
1211                     /* only set to non-%NULL if size &gt; 0 */
1212                     child.data = value.data;
1213 
1214                   g_variant_type_info_query (child.type_info,
1215                                              NULL, &amp;fixed_size);
1216                   child_type_depth = g_variant_type_info_query_depth (child.type_info);
1217 
1218                   if ((!fixed_size || fixed_size == child.size) &amp;&amp;
1219                       value.depth &lt; G_VARIANT_MAX_RECURSION_DEPTH - child_type_depth)
1220                     return child;
1221 
1222                   g_variant_type_info_unref (child.type_info);
1223                 }
1224             }
1225         }
1226     }
1227 
1228   child.type_info = g_variant_type_info_get (G_VARIANT_TYPE_UNIT);
1229   child.data = NULL;
1230   child.size = 1;
1231   child.depth = value.depth + 1;
1232 
1233   return child;
1234 }
1235 
1236 static inline gsize
1237 gvs_variant_needed_size (GVariantTypeInfo         *type_info,
1238                          GVariantSerialisedFiller  gvs_filler,
1239                          const gpointer           *children,
1240                          gsize                     n_children)
1241 {
1242   GVariantSerialised child = { 0, };
1243   const gchar *type_string;
1244 
1245   gvs_filler (&amp;child, children[0]);
1246   type_string = g_variant_type_info_get_type_string (child.type_info);
1247 
1248   return child.size + 1 + strlen (type_string);
1249 }
1250 
1251 static inline void
1252 gvs_variant_serialise (GVariantSerialised        value,
1253                        GVariantSerialisedFiller  gvs_filler,
1254                        const gpointer           *children,
1255                        gsize                     n_children)
1256 {
1257   GVariantSerialised child = { 0, };
1258   const gchar *type_string;
1259 
1260   child.data = value.data;
1261 
1262   gvs_filler (&amp;child, children[0]);
1263   type_string = g_variant_type_info_get_type_string (child.type_info);
1264   value.data[child.size] = &#39;\0&#39;;
1265   memcpy (value.data + child.size + 1, type_string, strlen (type_string));
1266 }
1267 
1268 static inline gboolean
1269 gvs_variant_is_normal (GVariantSerialised value)
1270 {
1271   GVariantSerialised child;
1272   gboolean normal;
1273   gsize child_type_depth;
1274 
1275   child = gvs_variant_get_child (value, 0);
1276   child_type_depth = g_variant_type_info_query_depth (child.type_info);
1277 
1278   normal = (value.depth &lt; G_VARIANT_MAX_RECURSION_DEPTH - child_type_depth) &amp;&amp;
1279            (child.data != NULL || child.size == 0) &amp;&amp;
1280            g_variant_serialised_is_normal (child);
1281 
1282   g_variant_type_info_unref (child.type_info);
1283 
1284   return normal;
1285 }
1286 
1287 
1288 
1289 /* PART 2: Serialiser API {{{1
1290  *
1291  * This is the implementation of the API of the serialiser as advertised
1292  * in gvariant-serialiser.h.
1293  */
1294 
1295 /* Dispatch Utilities {{{2
1296  *
1297  * These macros allow a given function (for example,
1298  * g_variant_serialiser_serialise) to be dispatched to the appropriate
1299  * type-specific function above (fixed/variable-sized maybe,
1300  * fixed/variable-sized array, tuple or variant).
1301  */
1302 #define DISPATCH_FIXED(type_info, before, after) \
1303   {                                                     \
1304     gsize fixed_size;                                   \
1305                                                         \
1306     g_variant_type_info_query_element (type_info, NULL, \
1307                                        &amp;fixed_size);    \
1308                                                         \
1309     if (fixed_size)                                     \
1310       {                                                 \
1311         before ## fixed_sized ## after                  \
1312       }                                                 \
1313     else                                                \
1314       {                                                 \
1315         before ## variable_sized ## after               \
1316       }                                                 \
1317   }
1318 
1319 #define DISPATCH_CASES(type_info, before, after) \
1320   switch (g_variant_type_info_get_type_char (type_info))        \
1321     {                                                           \
1322       case G_VARIANT_TYPE_INFO_CHAR_MAYBE:                      \
1323         DISPATCH_FIXED (type_info, before, _maybe ## after)     \
1324                                                                 \
1325       case G_VARIANT_TYPE_INFO_CHAR_ARRAY:                      \
1326         DISPATCH_FIXED (type_info, before, _array ## after)     \
1327                                                                 \
1328       case G_VARIANT_TYPE_INFO_CHAR_DICT_ENTRY:                 \
1329       case G_VARIANT_TYPE_INFO_CHAR_TUPLE:                      \
1330         {                                                       \
1331           before ## tuple ## after                              \
1332         }                                                       \
1333                                                                 \
1334       case G_VARIANT_TYPE_INFO_CHAR_VARIANT:                    \
1335         {                                                       \
1336           before ## variant ## after                            \
1337         }                                                       \
1338     }
1339 
1340 /* Serialiser entry points {{{2
1341  *
1342  * These are the functions that are called in order for the serialiser
1343  * to do its thing.
1344  */
1345 
1346 /* &lt; private &gt;
1347  * g_variant_serialised_n_children:
1348  * @serialised: a #GVariantSerialised
1349  *
1350  * For serialised data that represents a container value (maybes,
1351  * tuples, arrays, variants), determine how many child items are inside
1352  * that container.
1353  *
1354  * Returns: the number of children
1355  */
1356 gsize
1357 g_variant_serialised_n_children (GVariantSerialised serialised)
1358 {
<a name="8" id="anc8"></a><span class="line-modified">1359   g_variant_serialised_check (serialised);</span>
1360 
1361   DISPATCH_CASES (serialised.type_info,
1362 
1363                   return gvs_/**/,/**/_n_children (serialised);
1364 
1365                  )
1366   g_assert_not_reached ();
1367 }
1368 
1369 /* &lt; private &gt;
1370  * g_variant_serialised_get_child:
1371  * @serialised: a #GVariantSerialised
1372  * @index_: the index of the child to fetch
1373  *
1374  * Extracts a child from a serialised data representing a container
1375  * value.
1376  *
1377  * It is an error to call this function with an index out of bounds.
1378  *
1379  * If the result .data == %NULL and .size &gt; 0 then there has been an
1380  * error extracting the requested fixed-sized value.  This number of
1381  * zero bytes needs to be allocated instead.
1382  *
1383  * In the case that .data == %NULL and .size == 0 then a zero-sized
1384  * item of a variable-sized type is being returned.
1385  *
1386  * .data is never non-%NULL if size is 0.
1387  *
1388  * Returns: a #GVariantSerialised for the child
1389  */
1390 GVariantSerialised
1391 g_variant_serialised_get_child (GVariantSerialised serialised,
1392                                 gsize              index_)
1393 {
1394   GVariantSerialised child;
1395 
<a name="9" id="anc9"></a><span class="line-modified">1396   g_variant_serialised_check (serialised);</span>
1397 
1398   if G_LIKELY (index_ &lt; g_variant_serialised_n_children (serialised))
1399     {
1400       DISPATCH_CASES (serialised.type_info,
1401 
1402                       child = gvs_/**/,/**/_get_child (serialised, index_);
1403                       g_assert (child.size || child.data == NULL);
<a name="10" id="anc10"></a><span class="line-modified">1404                       g_variant_serialised_check (child);</span>
1405                       return child;
1406 
1407                      )
1408       g_assert_not_reached ();
1409     }
1410 
1411   g_error (&quot;Attempt to access item %&quot;G_GSIZE_FORMAT
1412            &quot; in a container with only %&quot;G_GSIZE_FORMAT&quot; items&quot;,
1413            index_, g_variant_serialised_n_children (serialised));
1414 }
1415 
1416 /* &lt; private &gt;
1417  * g_variant_serialiser_serialise:
1418  * @serialised: a #GVariantSerialised, properly set up
1419  * @gvs_filler: the filler function
1420  * @children: an array of child items
1421  * @n_children: the size of @children
1422  *
1423  * Writes data in serialised form.
1424  *
1425  * The type_info field of @serialised must be filled in to type info for
1426  * the type that we are serialising.
1427  *
1428  * The size field of @serialised must be filled in with the value
1429  * returned by a previous call to g_variant_serialiser_needed_size().
1430  *
1431  * The data field of @serialised must be a pointer to a properly-aligned
1432  * memory region large enough to serialise into (ie: at least as big as
1433  * the size field).
1434  *
1435  * This function is only resonsible for serialising the top-level
1436  * container.  @gvs_filler is called on each child of the container in
1437  * order for all of the data of that child to be filled in.
1438  */
1439 void
1440 g_variant_serialiser_serialise (GVariantSerialised        serialised,
1441                                 GVariantSerialisedFiller  gvs_filler,
1442                                 const gpointer           *children,
1443                                 gsize                     n_children)
1444 {
<a name="11" id="anc11"></a><span class="line-modified">1445   g_variant_serialised_check (serialised);</span>
1446 
1447   DISPATCH_CASES (serialised.type_info,
1448 
1449                   gvs_/**/,/**/_serialise (serialised, gvs_filler,
1450                                            children, n_children);
1451                   return;
1452 
1453                  )
1454   g_assert_not_reached ();
1455 }
1456 
1457 /* &lt; private &gt;
1458  * g_variant_serialiser_needed_size:
1459  * @type_info: the type to serialise for
1460  * @gvs_filler: the filler function
1461  * @children: an array of child items
1462  * @n_children: the size of @children
1463  *
1464  * Determines how much memory would be needed to serialise this value.
1465  *
1466  * This function is only resonsible for performing calculations for the
1467  * top-level container.  @gvs_filler is called on each child of the
1468  * container in order to determine its size.
1469  */
1470 gsize
1471 g_variant_serialiser_needed_size (GVariantTypeInfo         *type_info,
1472                                   GVariantSerialisedFiller  gvs_filler,
1473                                   const gpointer           *children,
1474                                   gsize                     n_children)
1475 {
1476   DISPATCH_CASES (type_info,
1477 
1478                   return gvs_/**/,/**/_needed_size (type_info, gvs_filler,
1479                                                     children, n_children);
1480 
1481                  )
1482   g_assert_not_reached ();
1483 }
1484 
1485 /* Byteswapping {{{2 */
1486 
1487 /* &lt; private &gt;
1488  * g_variant_serialised_byteswap:
1489  * @value: a #GVariantSerialised
1490  *
1491  * Byte-swap serialised data.  The result of this function is only
1492  * well-defined if the data is in normal form.
1493  */
1494 void
1495 g_variant_serialised_byteswap (GVariantSerialised serialised)
1496 {
1497   gsize fixed_size;
1498   guint alignment;
1499 
<a name="12" id="anc12"></a><span class="line-modified">1500   g_variant_serialised_check (serialised);</span>
1501 
1502   if (!serialised.data)
1503     return;
1504 
1505   /* the types we potentially need to byteswap are
1506    * exactly those with alignment requirements.
1507    */
1508   g_variant_type_info_query (serialised.type_info, &amp;alignment, &amp;fixed_size);
1509   if (!alignment)
1510     return;
1511 
1512   /* if fixed size and alignment are equal then we are down
1513    * to the base integer type and we should swap it.  the
1514    * only exception to this is if we have a tuple with a
1515    * single item, and then swapping it will be OK anyway.
1516    */
1517   if (alignment + 1 == fixed_size)
1518     {
1519       switch (fixed_size)
1520       {
1521         case 2:
1522           {
1523             guint16 *ptr = (guint16 *) serialised.data;
1524 
1525             g_assert_cmpint (serialised.size, ==, 2);
1526             *ptr = GUINT16_SWAP_LE_BE (*ptr);
1527           }
1528           return;
1529 
1530         case 4:
1531           {
1532             guint32 *ptr = (guint32 *) serialised.data;
1533 
1534             g_assert_cmpint (serialised.size, ==, 4);
1535             *ptr = GUINT32_SWAP_LE_BE (*ptr);
1536           }
1537           return;
1538 
1539         case 8:
1540           {
1541             guint64 *ptr = (guint64 *) serialised.data;
1542 
1543             g_assert_cmpint (serialised.size, ==, 8);
1544             *ptr = GUINT64_SWAP_LE_BE (*ptr);
1545           }
1546           return;
1547 
1548         default:
1549           g_assert_not_reached ();
1550       }
1551     }
1552 
1553   /* else, we have a container that potentially contains
1554    * some children that need to be byteswapped.
1555    */
1556   else
1557     {
1558       gsize children, i;
1559 
1560       children = g_variant_serialised_n_children (serialised);
1561       for (i = 0; i &lt; children; i++)
1562         {
1563           GVariantSerialised child;
1564 
1565           child = g_variant_serialised_get_child (serialised, i);
1566           g_variant_serialised_byteswap (child);
1567           g_variant_type_info_unref (child.type_info);
1568         }
1569     }
1570 }
1571 
1572 /* Normal form checking {{{2 */
1573 
1574 /* &lt; private &gt;
1575  * g_variant_serialised_is_normal:
1576  * @serialised: a #GVariantSerialised
1577  *
1578  * Determines, recursively if @serialised is in normal form.  There is
1579  * precisely one normal form of serialised data for each possible value.
1580  *
1581  * It is possible that multiple byte sequences form the serialised data
1582  * for a given value if, for example, the padding bytes are filled in
1583  * with something other than zeros, but only one form is the normal
1584  * form.
1585  */
1586 gboolean
1587 g_variant_serialised_is_normal (GVariantSerialised serialised)
1588 {
1589   DISPATCH_CASES (serialised.type_info,
1590 
1591                   return gvs_/**/,/**/_is_normal (serialised);
1592 
1593                  )
1594 
1595   if (serialised.data == NULL)
1596     return FALSE;
1597   if (serialised.depth &gt;= G_VARIANT_MAX_RECURSION_DEPTH)
1598     return FALSE;
1599 
1600   /* some hard-coded terminal cases */
1601   switch (g_variant_type_info_get_type_char (serialised.type_info))
1602     {
1603     case &#39;b&#39;: /* boolean */
1604       return serialised.data[0] &lt; 2;
1605 
1606     case &#39;s&#39;: /* string */
1607       return g_variant_serialiser_is_string (serialised.data,
1608                                              serialised.size);
1609 
1610     case &#39;o&#39;:
1611       return g_variant_serialiser_is_object_path (serialised.data,
1612                                                   serialised.size);
1613 
1614     case &#39;g&#39;:
1615       return g_variant_serialiser_is_signature (serialised.data,
1616                                                 serialised.size);
1617 
1618     default:
1619       /* all of the other types are fixed-sized numerical types for
1620        * which all possible values are valid (including various NaN
1621        * representations for floating point values).
1622        */
1623       return TRUE;
1624     }
1625 }
1626 
1627 /* Validity-checking functions {{{2
1628  *
1629  * Checks if strings, object paths and signature strings are valid.
1630  */
1631 
1632 /* &lt; private &gt;
1633  * g_variant_serialiser_is_string:
1634  * @data: a possible string
1635  * @size: the size of @data
1636  *
1637  * Ensures that @data is a valid string with a nul terminator at the end
1638  * and no nul bytes embedded.
1639  */
1640 gboolean
1641 g_variant_serialiser_is_string (gconstpointer data,
1642                                 gsize         size)
1643 {
1644   const gchar *expected_end;
1645   const gchar *end;
1646 
1647   /* Strings must end with a nul terminator. */
1648   if (size == 0)
1649     return FALSE;
1650 
1651   expected_end = ((gchar *) data) + size - 1;
1652 
1653   if (*expected_end != &#39;\0&#39;)
1654     return FALSE;
1655 
<a name="13" id="anc13"></a><span class="line-modified">1656   _g_utf8_validate_len (data, size, &amp;end);</span>
1657 
1658   return end == expected_end;
1659 }
1660 
1661 /* &lt; private &gt;
1662  * g_variant_serialiser_is_object_path:
1663  * @data: a possible D-Bus object path
1664  * @size: the size of @data
1665  *
1666  * Performs the checks for being a valid string.
1667  *
1668  * Also, ensures that @data is a valid DBus object path, as per the D-Bus
1669  * specification.
1670  */
1671 gboolean
1672 g_variant_serialiser_is_object_path (gconstpointer data,
1673                                      gsize         size)
1674 {
1675   const gchar *string = data;
1676   gsize i;
1677 
1678   if (!g_variant_serialiser_is_string (data, size))
1679     return FALSE;
1680 
1681   /* The path must begin with an ASCII &#39;/&#39; (integer 47) character */
1682   if (string[0] != &#39;/&#39;)
1683     return FALSE;
1684 
1685   for (i = 1; string[i]; i++)
1686     /* Each element must only contain the ASCII characters
1687      * &quot;[A-Z][a-z][0-9]_&quot;
1688      */
1689     if (g_ascii_isalnum (string[i]) || string[i] == &#39;_&#39;)
1690       ;
1691 
1692     /* must consist of elements separated by slash characters. */
1693     else if (string[i] == &#39;/&#39;)
1694       {
1695         /* No element may be the empty string. */
1696         /* Multiple &#39;/&#39; characters cannot occur in sequence. */
1697         if (string[i - 1] == &#39;/&#39;)
1698           return FALSE;
1699       }
1700 
1701     else
1702       return FALSE;
1703 
1704   /* A trailing &#39;/&#39; character is not allowed unless the path is the
1705    * root path (a single &#39;/&#39; character).
1706    */
1707   if (i &gt; 1 &amp;&amp; string[i - 1] == &#39;/&#39;)
1708     return FALSE;
1709 
1710   return TRUE;
1711 }
1712 
1713 /* &lt; private &gt;
1714  * g_variant_serialiser_is_signature:
1715  * @data: a possible D-Bus signature
1716  * @size: the size of @data
1717  *
1718  * Performs the checks for being a valid string.
1719  *
1720  * Also, ensures that @data is a valid D-Bus type signature, as per the
1721  * D-Bus specification. Note that this means the empty string is valid, as the
<a name="14" id="anc14"></a><span class="line-modified">1722  * D-Bus specification defines a signature as “zero or more single complete</span>
<span class="line-modified">1723  * types”.</span>
1724  */
1725 gboolean
1726 g_variant_serialiser_is_signature (gconstpointer data,
1727                                    gsize         size)
1728 {
1729   const gchar *string = data;
1730   gsize first_invalid;
1731 
1732   if (!g_variant_serialiser_is_string (data, size))
1733     return FALSE;
1734 
1735   /* make sure no non-definite characters appear */
1736   first_invalid = strspn (string, &quot;ybnqiuxthdvasog(){}&quot;);
1737   if (string[first_invalid])
1738     return FALSE;
1739 
1740   /* make sure each type string is well-formed */
1741   while (*string)
1742     if (!g_variant_type_string_scan (string, NULL, &amp;string))
1743       return FALSE;
1744 
1745   return TRUE;
1746 }
1747 
1748 /* Epilogue {{{1 */
1749 /* vim:set foldmethod=marker: */
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>