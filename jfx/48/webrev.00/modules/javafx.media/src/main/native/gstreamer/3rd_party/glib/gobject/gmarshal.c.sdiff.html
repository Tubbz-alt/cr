<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gmarshal.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="genums.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gmarshal.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gmarshal.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 </span>
<span class="line-removed">   2 #include &quot;config.h&quot;</span>
<span class="line-removed">   3 </span>
<span class="line-removed">   4 #include &quot;gobject.h&quot;</span>
<span class="line-removed">   5 #include &quot;genums.h&quot;</span>
<span class="line-removed">   6 #include &quot;gboxed.h&quot;</span>
<span class="line-removed">   7 #include &quot;gvaluetypes.h&quot;</span>
<span class="line-removed">   8 </span>
<span class="line-removed">   9 /**</span>
<span class="line-removed">  10  * g_cclosure_marshal_VOID__VOID:</span>
<span class="line-removed">  11  * @closure: A #GClosure.</span>
<span class="line-removed">  12  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed">  13  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed">  14  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed">  15  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed">  16  *   on which to invoke the callback of closure.</span>
<span class="line-removed">  17  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed">  18  *   g_closure_invoke().</span>
<span class="line-removed">  19  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed">  20  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed">  21  *   g_closure_set_meta_marshal()</span>
<span class="line-removed">  22  *</span>
<span class="line-removed">  23  * A #GClosureMarshal function for use with signals with no arguments.</span>
<span class="line-removed">  24  */</span>
<span class="line-removed">  25 /**</span>
<span class="line-removed">  26  * g_cclosure_marshal_VOID__BOOLEAN:</span>
<span class="line-removed">  27  * @closure: A #GClosure.</span>
<span class="line-removed">  28  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed">  29  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed">  30  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed">  31  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed">  32  *   on which to invoke the callback of closure.</span>
<span class="line-removed">  33  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed">  34  *   g_closure_invoke().</span>
<span class="line-removed">  35  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed">  36  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed">  37  *   g_closure_set_meta_marshal()</span>
<span class="line-removed">  38  *</span>
<span class="line-removed">  39  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed">  40  * boolean argument.</span>
<span class="line-removed">  41  */</span>
<span class="line-removed">  42 /**</span>
<span class="line-removed">  43  * g_cclosure_marshal_VOID__CHAR:</span>
<span class="line-removed">  44  * @closure: A #GClosure.</span>
<span class="line-removed">  45  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed">  46  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed">  47  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed">  48  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed">  49  *   on which to invoke the callback of closure.</span>
<span class="line-removed">  50  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed">  51  *   g_closure_invoke().</span>
<span class="line-removed">  52  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed">  53  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed">  54  *   g_closure_set_meta_marshal()</span>
<span class="line-removed">  55  *</span>
<span class="line-removed">  56  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed">  57  * character argument.</span>
<span class="line-removed">  58  */</span>
<span class="line-removed">  59 /**</span>
<span class="line-removed">  60  * g_cclosure_marshal_VOID__UCHAR:</span>
<span class="line-removed">  61  * @closure: A #GClosure.</span>
<span class="line-removed">  62  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed">  63  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed">  64  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed">  65  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed">  66  *   on which to invoke the callback of closure.</span>
<span class="line-removed">  67  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed">  68  *   g_closure_invoke().</span>
<span class="line-removed">  69  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed">  70  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed">  71  *   g_closure_set_meta_marshal()</span>
<span class="line-removed">  72  *</span>
<span class="line-removed">  73  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed">  74  * unsigned character argument.</span>
<span class="line-removed">  75  */</span>
<span class="line-removed">  76 /**</span>
<span class="line-removed">  77  * g_cclosure_marshal_VOID__INT:</span>
<span class="line-removed">  78  * @closure: A #GClosure.</span>
<span class="line-removed">  79  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed">  80  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed">  81  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed">  82  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed">  83  *   on which to invoke the callback of closure.</span>
<span class="line-removed">  84  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed">  85  *   g_closure_invoke().</span>
<span class="line-removed">  86  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed">  87  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed">  88  *   g_closure_set_meta_marshal()</span>
<span class="line-removed">  89  *</span>
<span class="line-removed">  90  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed">  91  * integer argument.</span>
<span class="line-removed">  92  */</span>
<span class="line-removed">  93 /**</span>
<span class="line-removed">  94  * g_cclosure_marshal_VOID__UINT:</span>
<span class="line-removed">  95  * @closure: A #GClosure.</span>
<span class="line-removed">  96  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed">  97  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed">  98  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed">  99  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 100  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 101  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 102  *   g_closure_invoke().</span>
<span class="line-removed"> 103  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 104  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 105  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 106  *</span>
<span class="line-removed"> 107  * A #GClosureMarshal function for use with signals with with a single</span>
<span class="line-removed"> 108  * unsigned integer argument.</span>
<span class="line-removed"> 109  */</span>
<span class="line-removed"> 110 /**</span>
<span class="line-removed"> 111  * g_cclosure_marshal_VOID__LONG:</span>
<span class="line-removed"> 112  * @closure: A #GClosure.</span>
<span class="line-removed"> 113  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 114  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 115  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 116  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 117  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 118  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 119  *   g_closure_invoke().</span>
<span class="line-removed"> 120  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 121  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 122  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 123  *</span>
<span class="line-removed"> 124  * A #GClosureMarshal function for use with signals with with a single</span>
<span class="line-removed"> 125  * long integer argument.</span>
<span class="line-removed"> 126  */</span>
<span class="line-removed"> 127 /**</span>
<span class="line-removed"> 128  * g_cclosure_marshal_VOID__ULONG:</span>
<span class="line-removed"> 129  * @closure: A #GClosure.</span>
<span class="line-removed"> 130  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 131  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 132  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 133  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 134  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 135  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 136  *   g_closure_invoke().</span>
<span class="line-removed"> 137  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 138  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 139  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 140  *</span>
<span class="line-removed"> 141  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed"> 142  * unsigned long integer argument.</span>
<span class="line-removed"> 143  */</span>
<span class="line-removed"> 144 /**</span>
<span class="line-removed"> 145  * g_cclosure_marshal_VOID__ENUM:</span>
<span class="line-removed"> 146  * @closure: A #GClosure.</span>
<span class="line-removed"> 147  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 148  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 149  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 150  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 151  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 152  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 153  *   g_closure_invoke().</span>
<span class="line-removed"> 154  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 155  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 156  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 157  *</span>
<span class="line-removed"> 158  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed"> 159  * argument with an enumerated type.</span>
<span class="line-removed"> 160  */</span>
<span class="line-removed"> 161 /**</span>
<span class="line-removed"> 162  * g_cclosure_marshal_VOID__FLAGS:</span>
<span class="line-removed"> 163  * @closure: A #GClosure.</span>
<span class="line-removed"> 164  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 165  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 166  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 167  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 168  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 169  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 170  *   g_closure_invoke().</span>
<span class="line-removed"> 171  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 172  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 173  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 174  *</span>
<span class="line-removed"> 175  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed"> 176  * argument with a flags types.</span>
<span class="line-removed"> 177  */</span>
<span class="line-removed"> 178 /**</span>
<span class="line-removed"> 179  * g_cclosure_marshal_VOID__FLOAT:</span>
<span class="line-removed"> 180  * @closure: A #GClosure.</span>
<span class="line-removed"> 181  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 182  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 183  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 184  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 185  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 186  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 187  *   g_closure_invoke().</span>
<span class="line-removed"> 188  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 189  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 190  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 191  *</span>
<span class="line-removed"> 192  * A #GClosureMarshal function for use with signals with one</span>
<span class="line-removed"> 193  * single-precision floating point argument.</span>
<span class="line-removed"> 194  */</span>
<span class="line-removed"> 195 /**</span>
<span class="line-removed"> 196  * g_cclosure_marshal_VOID__DOUBLE:</span>
<span class="line-removed"> 197  * @closure: A #GClosure.</span>
<span class="line-removed"> 198  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 199  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 200  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 201  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 202  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 203  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 204  *   g_closure_invoke().</span>
<span class="line-removed"> 205  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 206  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 207  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 208  *</span>
<span class="line-removed"> 209  * A #GClosureMarshal function for use with signals with one</span>
<span class="line-removed"> 210  * double-precision floating point argument.</span>
<span class="line-removed"> 211  */</span>
<span class="line-removed"> 212 /**</span>
<span class="line-removed"> 213  * g_cclosure_marshal_VOID__STRING:</span>
<span class="line-removed"> 214  * @closure: A #GClosure.</span>
<span class="line-removed"> 215  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 216  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 217  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 218  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 219  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 220  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 221  *   g_closure_invoke().</span>
<span class="line-removed"> 222  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 223  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 224  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 225  *</span>
<span class="line-removed"> 226  * A #GClosureMarshal function for use with signals with a single string</span>
<span class="line-removed"> 227  * argument.</span>
<span class="line-removed"> 228  */</span>
<span class="line-removed"> 229 /**</span>
<span class="line-removed"> 230  * g_cclosure_marshal_VOID__PARAM:</span>
<span class="line-removed"> 231  * @closure: A #GClosure.</span>
<span class="line-removed"> 232  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 233  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 234  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 235  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 236  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 237  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 238  *   g_closure_invoke().</span>
<span class="line-removed"> 239  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 240  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 241  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 242  *</span>
<span class="line-removed"> 243  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed"> 244  * argument of type #GParamSpec.</span>
<span class="line-removed"> 245  */</span>
<span class="line-removed"> 246 /**</span>
<span class="line-removed"> 247  * g_cclosure_marshal_VOID__BOXED:</span>
<span class="line-removed"> 248  * @closure: A #GClosure.</span>
<span class="line-removed"> 249  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 250  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 251  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 252  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 253  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 254  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 255  *   g_closure_invoke().</span>
<span class="line-removed"> 256  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 257  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 258  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 259  *</span>
<span class="line-removed"> 260  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed"> 261  * argument which is any boxed pointer type.</span>
<span class="line-removed"> 262  */</span>
<span class="line-removed"> 263 /**</span>
<span class="line-removed"> 264  * g_cclosure_marshal_VOID__POINTER:</span>
<span class="line-removed"> 265  * @closure: A #GClosure.</span>
<span class="line-removed"> 266  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 267  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 268  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 269  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 270  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 271  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 272  *   g_closure_invoke().</span>
<span class="line-removed"> 273  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 274  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 275  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 276  *</span>
<span class="line-removed"> 277  * A #GClosureMarshal function for use with signals with a single raw</span>
<span class="line-removed"> 278  * pointer argument type.</span>
<span class="line-removed"> 279  *</span>
<span class="line-removed"> 280  * If it is possible, it is better to use one of the more specific</span>
<span class="line-removed"> 281  * functions such as g_cclosure_marshal_VOID__OBJECT() or</span>
<span class="line-removed"> 282  * g_cclosure_marshal_VOID__OBJECT().</span>
<span class="line-removed"> 283  */</span>
<span class="line-removed"> 284 /**</span>
<span class="line-removed"> 285  * g_cclosure_marshal_VOID__OBJECT:</span>
<span class="line-removed"> 286  * @closure: A #GClosure.</span>
<span class="line-removed"> 287  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 288  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 289  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 290  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 291  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 292  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 293  *   g_closure_invoke().</span>
<span class="line-removed"> 294  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 295  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 296  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 297  *</span>
<span class="line-removed"> 298  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed"> 299  * #GObject argument.</span>
<span class="line-removed"> 300  */</span>
<span class="line-removed"> 301 /**</span>
<span class="line-removed"> 302  * g_cclosure_marshal_VOID__VARIANT:</span>
<span class="line-removed"> 303  * @closure: A #GClosure.</span>
<span class="line-removed"> 304  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 305  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 306  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 307  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 308  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 309  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 310  *   g_closure_invoke().</span>
<span class="line-removed"> 311  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 312  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 313  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 314  *</span>
<span class="line-removed"> 315  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-removed"> 316  * #GVariant argument.</span>
<span class="line-removed"> 317  */</span>
<span class="line-removed"> 318 /**</span>
<span class="line-removed"> 319  * g_cclosure_marshal_STRING__OBJECT_POINTER:</span>
<span class="line-removed"> 320  * @closure: A #GClosure.</span>
<span class="line-removed"> 321  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 322  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 323  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 324  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 325  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 326  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 327  *   g_closure_invoke().</span>
<span class="line-removed"> 328  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 329  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 330  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 331  *</span>
<span class="line-removed"> 332  * A #GClosureMarshal function for use with signals with handlers that</span>
<span class="line-removed"> 333  * take a #GObject and a pointer and produce a string.  It is highly</span>
<span class="line-removed"> 334  * unlikely that your signal handler fits this description.</span>
<span class="line-removed"> 335  */</span>
<span class="line-removed"> 336 /**</span>
<span class="line-removed"> 337  * g_cclosure_marshal_VOID__UINT_POINTER:</span>
<span class="line-removed"> 338  * @closure: A #GClosure.</span>
<span class="line-removed"> 339  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 340  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 341  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 342  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 343  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 344  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 345  *   g_closure_invoke().</span>
<span class="line-removed"> 346  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 347  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 348  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 349  *</span>
<span class="line-removed"> 350  * A #GClosureMarshal function for use with signals with a unsigned int</span>
<span class="line-removed"> 351  * and a pointer as arguments.</span>
<span class="line-removed"> 352  */</span>
<span class="line-removed"> 353 /**</span>
<span class="line-removed"> 354  * g_cclosure_marshal_BOOLEAN__FLAGS:</span>
<span class="line-removed"> 355  * @closure: A #GClosure.</span>
<span class="line-removed"> 356  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 357  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 358  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 359  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 360  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 361  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 362  *   g_closure_invoke().</span>
<span class="line-removed"> 363  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 364  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 365  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 366  *</span>
<span class="line-removed"> 367  * A #GClosureMarshal function for use with signals with handlers that</span>
<span class="line-removed"> 368  * take a flags type as an argument and return a boolean.  If you have</span>
<span class="line-removed"> 369  * such a signal, you will probably also need to use an accumulator,</span>
<span class="line-removed"> 370  * such as g_signal_accumulator_true_handled().</span>
<span class="line-removed"> 371  */</span>
<span class="line-removed"> 372 /**</span>
<span class="line-removed"> 373  * g_cclosure_marshal_BOOL__FLAGS:</span>
<span class="line-removed"> 374  * @closure: A #GClosure.</span>
<span class="line-removed"> 375  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 376  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 377  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 378  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 379  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 380  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 381  *   g_closure_invoke().</span>
<span class="line-removed"> 382  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 383  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 384  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 385  *</span>
<span class="line-removed"> 386  * An old alias for g_cclosure_marshal_BOOLEAN__FLAGS().</span>
<span class="line-removed"> 387  */</span>
<span class="line-removed"> 388 /**</span>
<span class="line-removed"> 389  * g_cclosure_marshal_BOOLEAN__BOXED_BOXED:</span>
<span class="line-removed"> 390  * @closure: A #GClosure.</span>
<span class="line-removed"> 391  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 392  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 393  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 394  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 395  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 396  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 397  *   g_closure_invoke().</span>
<span class="line-removed"> 398  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 399  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 400  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 401  *</span>
<span class="line-removed"> 402  * A #GClosureMarshal function for use with signals with handlers that</span>
<span class="line-removed"> 403  * take two boxed pointers as arguments and return a boolean.  If you</span>
<span class="line-removed"> 404  * have such a signal, you will probably also need to use an</span>
<span class="line-removed"> 405  * accumulator, such as g_signal_accumulator_true_handled().</span>
<span class="line-removed"> 406  */</span>
<span class="line-removed"> 407 /**</span>
<span class="line-removed"> 408  * g_cclosure_marshal_BOOL__BOXED_BOXED:</span>
<span class="line-removed"> 409  * @closure: A #GClosure.</span>
<span class="line-removed"> 410  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-removed"> 411  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-removed"> 412  * @n_param_values: The length of the @param_values array.</span>
<span class="line-removed"> 413  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-removed"> 414  *   on which to invoke the callback of closure.</span>
<span class="line-removed"> 415  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-removed"> 416  *   g_closure_invoke().</span>
<span class="line-removed"> 417  * @marshal_data: Additional data specified when registering the</span>
<span class="line-removed"> 418  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 419  *   g_closure_set_meta_marshal()</span>
<span class="line-removed"> 420  *</span>
<span class="line-removed"> 421  * An old alias for g_cclosure_marshal_BOOLEAN__BOXED_BOXED().</span>
<span class="line-removed"> 422  */</span>
<span class="line-removed"> 423 /**</span>
<span class="line-removed"> 424  * g_cclosure_marshal_VOID__VOIDv:</span>
<span class="line-removed"> 425  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 426  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 427  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 428  *  value.</span>
<span class="line-removed"> 429  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 430  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 431  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 432  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 433  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 434  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 435  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 436  *  @args.</span>
<span class="line-removed"> 437  *</span>
<span class="line-removed"> 438  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__VOID().</span>
<span class="line-removed"> 439  */</span>
<span class="line-removed"> 440 </span>
<span class="line-removed"> 441 /**</span>
<span class="line-removed"> 442  * g_cclosure_marshal_VOID__BOOLEANv:</span>
<span class="line-removed"> 443  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 444  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 445  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 446  *  value.</span>
<span class="line-removed"> 447  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 448  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 449  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 450  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 451  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 452  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 453  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 454  *  @args.</span>
<span class="line-removed"> 455  *</span>
<span class="line-removed"> 456  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__BOOLEAN().</span>
<span class="line-removed"> 457  */</span>
<span class="line-removed"> 458 /**</span>
<span class="line-removed"> 459  * g_cclosure_marshal_VOID__CHARv:</span>
<span class="line-removed"> 460  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 461  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 462  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 463  *  value.</span>
<span class="line-removed"> 464  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 465  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 466  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 467  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 468  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 469  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 470  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 471  *  @args.</span>
<span class="line-removed"> 472  *</span>
<span class="line-removed"> 473  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__CHAR().</span>
<span class="line-removed"> 474  */</span>
<span class="line-removed"> 475 /**</span>
<span class="line-removed"> 476  * g_cclosure_marshal_VOID__UCHARv:</span>
<span class="line-removed"> 477  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 478  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 479  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 480  *  value.</span>
<span class="line-removed"> 481  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 482  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 483  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 484  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 485  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 486  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 487  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 488  *  @args.</span>
<span class="line-removed"> 489  *</span>
<span class="line-removed"> 490  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UCHAR().</span>
<span class="line-removed"> 491  */</span>
<span class="line-removed"> 492 /**</span>
<span class="line-removed"> 493  * g_cclosure_marshal_VOID__INTv:</span>
<span class="line-removed"> 494  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 495  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 496  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 497  *  value.</span>
<span class="line-removed"> 498  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 499  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 500  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 501  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 502  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 503  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 504  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 505  *  @args.</span>
<span class="line-removed"> 506  *</span>
<span class="line-removed"> 507  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__INT().</span>
<span class="line-removed"> 508  */</span>
<span class="line-removed"> 509 /**</span>
<span class="line-removed"> 510  * g_cclosure_marshal_VOID__UINTv:</span>
<span class="line-removed"> 511  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 512  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 513  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 514  *  value.</span>
<span class="line-removed"> 515  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 516  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 517  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 518  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 519  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 520  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 521  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 522  *  @args.</span>
<span class="line-removed"> 523  *</span>
<span class="line-removed"> 524  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UINT().</span>
<span class="line-removed"> 525  */</span>
<span class="line-removed"> 526 /**</span>
<span class="line-removed"> 527  * g_cclosure_marshal_VOID__LONGv:</span>
<span class="line-removed"> 528  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 529  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 530  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 531  *  value.</span>
<span class="line-removed"> 532  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 533  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 534  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 535  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 536  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 537  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 538  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 539  *  @args.</span>
<span class="line-removed"> 540  *</span>
<span class="line-removed"> 541  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__LONG().</span>
<span class="line-removed"> 542  */</span>
<span class="line-removed"> 543 /**</span>
<span class="line-removed"> 544  * g_cclosure_marshal_VOID__ULONGv:</span>
<span class="line-removed"> 545  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 546  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 547  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 548  *  value.</span>
<span class="line-removed"> 549  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 550  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 551  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 552  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 553  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 554  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 555  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 556  *  @args.</span>
<span class="line-removed"> 557  *</span>
<span class="line-removed"> 558  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__ULONG().</span>
<span class="line-removed"> 559  */</span>
<span class="line-removed"> 560 /**</span>
<span class="line-removed"> 561  * g_cclosure_marshal_VOID__ENUMv:</span>
<span class="line-removed"> 562  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 563  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 564  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 565  *  value.</span>
<span class="line-removed"> 566  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 567  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 568  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 569  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 570  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 571  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 572  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 573  *  @args.</span>
<span class="line-removed"> 574  *</span>
<span class="line-removed"> 575  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__ENUM().</span>
<span class="line-removed"> 576  */</span>
<span class="line-removed"> 577 /**</span>
<span class="line-removed"> 578  * g_cclosure_marshal_VOID__FLAGSv:</span>
<span class="line-removed"> 579  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 580  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 581  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 582  *  value.</span>
<span class="line-removed"> 583  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 584  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 585  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 586  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 587  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 588  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 589  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 590  *  @args.</span>
<span class="line-removed"> 591  *</span>
<span class="line-removed"> 592  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__FLAGS().</span>
<span class="line-removed"> 593  */</span>
<span class="line-removed"> 594 /**</span>
<span class="line-removed"> 595  * g_cclosure_marshal_VOID__FLOATv:</span>
<span class="line-removed"> 596  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 597  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 598  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 599  *  value.</span>
<span class="line-removed"> 600  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 601  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 602  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 603  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 604  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 605  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 606  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 607  *  @args.</span>
<span class="line-removed"> 608  *</span>
<span class="line-removed"> 609  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__FLOAT().</span>
<span class="line-removed"> 610  */</span>
<span class="line-removed"> 611 /**</span>
<span class="line-removed"> 612  * g_cclosure_marshal_VOID__DOUBLEv:</span>
<span class="line-removed"> 613  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 614  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 615  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 616  *  value.</span>
<span class="line-removed"> 617  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 618  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 619  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 620  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 621  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 622  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 623  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 624  *  @args.</span>
<span class="line-removed"> 625  *</span>
<span class="line-removed"> 626  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__DOUBLE().</span>
<span class="line-removed"> 627  */</span>
<span class="line-removed"> 628 /**</span>
<span class="line-removed"> 629  * g_cclosure_marshal_VOID__STRINGv:</span>
<span class="line-removed"> 630  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 631  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 632  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 633  *  value.</span>
<span class="line-removed"> 634  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 635  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 636  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 637  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 638  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 639  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 640  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 641  *  @args.</span>
<span class="line-removed"> 642  *</span>
<span class="line-removed"> 643  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__STRING().</span>
<span class="line-removed"> 644  */</span>
<span class="line-removed"> 645 /**</span>
<span class="line-removed"> 646  * g_cclosure_marshal_VOID__PARAMv:</span>
<span class="line-removed"> 647  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 648  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 649  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 650  *  value.</span>
<span class="line-removed"> 651  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 652  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 653  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 654  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 655  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 656  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 657  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 658  *  @args.</span>
<span class="line-removed"> 659  *</span>
<span class="line-removed"> 660  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__PARAM().</span>
<span class="line-removed"> 661  */</span>
<span class="line-removed"> 662 /**</span>
<span class="line-removed"> 663  * g_cclosure_marshal_VOID__BOXEDv:</span>
<span class="line-removed"> 664  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 665  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 666  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 667  *  value.</span>
<span class="line-removed"> 668  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 669  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 670  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 671  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 672  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 673  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 674  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 675  *  @args.</span>
<span class="line-removed"> 676  *</span>
<span class="line-removed"> 677  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__BOXED().</span>
<span class="line-removed"> 678  */</span>
<span class="line-removed"> 679 /**</span>
<span class="line-removed"> 680  * g_cclosure_marshal_VOID__POINTERv:</span>
<span class="line-removed"> 681  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 682  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 683  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 684  *  value.</span>
<span class="line-removed"> 685  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 686  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 687  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 688  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 689  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 690  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 691  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 692  *  @args.</span>
<span class="line-removed"> 693  *</span>
<span class="line-removed"> 694  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__POINTER().</span>
<span class="line-removed"> 695  */</span>
<span class="line-removed"> 696 /**</span>
<span class="line-removed"> 697  * g_cclosure_marshal_VOID__OBJECTv:</span>
<span class="line-removed"> 698  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 699  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 700  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 701  *  value.</span>
<span class="line-removed"> 702  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 703  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 704  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 705  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 706  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 707  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 708  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 709  *  @args.</span>
<span class="line-removed"> 710  *</span>
<span class="line-removed"> 711  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__OBJECT().</span>
<span class="line-removed"> 712  */</span>
<span class="line-removed"> 713 /**</span>
<span class="line-removed"> 714  * g_cclosure_marshal_VOID__VARIANTv:</span>
<span class="line-removed"> 715  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 716  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 717  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 718  *  value.</span>
<span class="line-removed"> 719  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 720  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 721  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 722  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 723  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 724  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 725  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 726  *  @args.</span>
<span class="line-removed"> 727  *</span>
<span class="line-removed"> 728  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__VARIANT().</span>
<span class="line-removed"> 729  */</span>
<span class="line-removed"> 730 /**</span>
<span class="line-removed"> 731  * g_cclosure_marshal_STRING__OBJECT_POINTERv:</span>
<span class="line-removed"> 732  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 733  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 734  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 735  *  value.</span>
<span class="line-removed"> 736  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 737  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 738  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 739  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 740  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 741  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 742  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 743  *  @args.</span>
<span class="line-removed"> 744  *</span>
<span class="line-removed"> 745  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_STRING__OBJECT_POINTER().</span>
<span class="line-removed"> 746  */</span>
<span class="line-removed"> 747 /**</span>
<span class="line-removed"> 748  * g_cclosure_marshal_VOID__UINT_POINTERv:</span>
<span class="line-removed"> 749  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 750  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 751  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 752  *  value.</span>
<span class="line-removed"> 753  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 754  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 755  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 756  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 757  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 758  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 759  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 760  *  @args.</span>
 761  *
<span class="line-modified"> 762  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UINT_POINTER().</span>
<span class="line-modified"> 763  */</span>
<span class="line-modified"> 764 /**</span>
<span class="line-modified"> 765  * g_cclosure_marshal_BOOLEAN__FLAGSv:</span>
<span class="line-removed"> 766  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 767  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 768  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 769  *  value.</span>
<span class="line-removed"> 770  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 771  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 772  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 773  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 774  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 775  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 776  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 777  *  @args.</span>
 778  *
<span class="line-modified"> 779  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_BOOLEAN__FLAGS().</span>
<span class="line-modified"> 780  */</span>
<span class="line-modified"> 781 /**</span>
<span class="line-modified"> 782  * g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv:</span>
<span class="line-removed"> 783  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-removed"> 784  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-removed"> 785  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-removed"> 786  *  value.</span>
<span class="line-removed"> 787  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-removed"> 788  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-removed"> 789  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-removed"> 790  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-removed"> 791  *  g_closure_set_meta_marshal()</span>
<span class="line-removed"> 792  * @n_params: the length of the @param_types array</span>
<span class="line-removed"> 793  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-removed"> 794  *  @args.</span>
 795  *
<span class="line-modified"> 796  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_BOOLEAN__BOXED_BOXED().</span>

 797  */
 798 








 799 #ifdef G_ENABLE_DEBUG
 800 #define g_marshal_value_peek_boolean(v)  g_value_get_boolean (v)
 801 #define g_marshal_value_peek_char(v)     g_value_get_schar (v)
 802 #define g_marshal_value_peek_uchar(v)    g_value_get_uchar (v)
 803 #define g_marshal_value_peek_int(v)      g_value_get_int (v)
 804 #define g_marshal_value_peek_uint(v)     g_value_get_uint (v)
 805 #define g_marshal_value_peek_long(v)     g_value_get_long (v)
 806 #define g_marshal_value_peek_ulong(v)    g_value_get_ulong (v)
 807 #define g_marshal_value_peek_int64(v)    g_value_get_int64 (v)
 808 #define g_marshal_value_peek_uint64(v)   g_value_get_uint64 (v)
 809 #define g_marshal_value_peek_enum(v)     g_value_get_enum (v)
 810 #define g_marshal_value_peek_flags(v)    g_value_get_flags (v)
 811 #define g_marshal_value_peek_float(v)    g_value_get_float (v)
 812 #define g_marshal_value_peek_double(v)   g_value_get_double (v)
 813 #define g_marshal_value_peek_string(v)   (char*) g_value_get_string (v)
 814 #define g_marshal_value_peek_param(v)    g_value_get_param (v)
 815 #define g_marshal_value_peek_boxed(v)    g_value_get_boxed (v)
 816 #define g_marshal_value_peek_pointer(v)  g_value_get_pointer (v)
 817 #define g_marshal_value_peek_object(v)   g_value_get_object (v)
 818 #define g_marshal_value_peek_variant(v)  g_value_get_variant (v)
</pre>
<hr />
<pre>
 826 #define g_marshal_value_peek_uchar(v)    (v)-&gt;data[0].v_uint
 827 #define g_marshal_value_peek_int(v)      (v)-&gt;data[0].v_int
 828 #define g_marshal_value_peek_uint(v)     (v)-&gt;data[0].v_uint
 829 #define g_marshal_value_peek_long(v)     (v)-&gt;data[0].v_long
 830 #define g_marshal_value_peek_ulong(v)    (v)-&gt;data[0].v_ulong
 831 #define g_marshal_value_peek_int64(v)    (v)-&gt;data[0].v_int64
 832 #define g_marshal_value_peek_uint64(v)   (v)-&gt;data[0].v_uint64
 833 #define g_marshal_value_peek_enum(v)     (v)-&gt;data[0].v_long
 834 #define g_marshal_value_peek_flags(v)    (v)-&gt;data[0].v_ulong
 835 #define g_marshal_value_peek_float(v)    (v)-&gt;data[0].v_float
 836 #define g_marshal_value_peek_double(v)   (v)-&gt;data[0].v_double
 837 #define g_marshal_value_peek_string(v)   (v)-&gt;data[0].v_pointer
 838 #define g_marshal_value_peek_param(v)    (v)-&gt;data[0].v_pointer
 839 #define g_marshal_value_peek_boxed(v)    (v)-&gt;data[0].v_pointer
 840 #define g_marshal_value_peek_pointer(v)  (v)-&gt;data[0].v_pointer
 841 #define g_marshal_value_peek_object(v)   (v)-&gt;data[0].v_pointer
 842 #define g_marshal_value_peek_variant(v)  (v)-&gt;data[0].v_pointer
 843 #endif /* !G_ENABLE_DEBUG */
 844 
 845 
<span class="line-modified"> 846 /* VOID:VOID (./gmarshal.list:6) */</span>
















 847 void
 848 g_cclosure_marshal_VOID__VOID (GClosure     *closure,
 849                                GValue       *return_value G_GNUC_UNUSED,
 850                                guint         n_param_values,
 851                                const GValue *param_values,
 852                                gpointer      invocation_hint G_GNUC_UNUSED,
 853                                gpointer      marshal_data)
 854 {
 855   typedef void (*GMarshalFunc_VOID__VOID) (gpointer     data1,
 856                                            gpointer     data2);
 857   GMarshalFunc_VOID__VOID callback;
 858   GCClosure *cc = (GCClosure*) closure;
 859   gpointer data1, data2;
 860 
 861   g_return_if_fail (n_param_values == 1);
 862 
 863   if (G_CCLOSURE_SWAP_DATA (closure))
 864     {
 865       data1 = closure-&gt;data;
 866       data2 = g_value_peek_pointer (param_values + 0);
 867     }
 868   else
 869     {
 870       data1 = g_value_peek_pointer (param_values + 0);
 871       data2 = closure-&gt;data;
 872     }
 873   callback = (GMarshalFunc_VOID__VOID) (marshal_data ? marshal_data : cc-&gt;callback);
 874 
 875   callback (data1,
 876             data2);
 877 }


















 878 void
 879 g_cclosure_marshal_VOID__VOIDv (GClosure     *closure,
 880                                 GValue       *return_value,
 881                                 gpointer      instance,
 882                                 va_list       args,
 883                                 gpointer      marshal_data,
 884                                 int           n_params,
 885                                 GType        *param_types)
 886 {
 887   typedef void (*GMarshalFunc_VOID__VOID) (gpointer     instance,
 888                                            gpointer     data);
 889   GCClosure *cc = (GCClosure*) closure;
 890   gpointer data1, data2;
 891   GMarshalFunc_VOID__VOID callback;
 892 
 893   if (G_CCLOSURE_SWAP_DATA (closure))
 894     {
 895       data1 = closure-&gt;data;
 896       data2 = instance;
 897     }
 898   else
 899     {
 900       data1 = instance;
 901       data2 = closure-&gt;data;
 902     }
 903   callback = (GMarshalFunc_VOID__VOID) (marshal_data ? marshal_data : cc-&gt;callback);
 904 
 905   callback (data1,
 906             data2);
 907 }
 908 
<span class="line-modified"> 909 </span>
<span class="line-modified"> 910 /* VOID:BOOLEAN (./gmarshal.list:7) */</span>
















 911 void
 912 g_cclosure_marshal_VOID__BOOLEAN (GClosure     *closure,
 913                                   GValue       *return_value G_GNUC_UNUSED,
 914                                   guint         n_param_values,
 915                                   const GValue *param_values,
 916                                   gpointer      invocation_hint G_GNUC_UNUSED,
 917                                   gpointer      marshal_data)
 918 {
 919   typedef void (*GMarshalFunc_VOID__BOOLEAN) (gpointer     data1,
 920                                               gboolean     arg_1,
 921                                               gpointer     data2);
 922   GMarshalFunc_VOID__BOOLEAN callback;
 923   GCClosure *cc = (GCClosure*) closure;
 924   gpointer data1, data2;
 925 
 926   g_return_if_fail (n_param_values == 2);
 927 
 928   if (G_CCLOSURE_SWAP_DATA (closure))
 929     {
 930       data1 = closure-&gt;data;
 931       data2 = g_value_peek_pointer (param_values + 0);
 932     }
 933   else
 934     {
 935       data1 = g_value_peek_pointer (param_values + 0);
 936       data2 = closure-&gt;data;
 937     }
 938   callback = (GMarshalFunc_VOID__BOOLEAN) (marshal_data ? marshal_data : cc-&gt;callback);
 939 
 940   callback (data1,
 941             g_marshal_value_peek_boolean (param_values + 1),
 942             data2);
 943 }


















 944 void
 945 g_cclosure_marshal_VOID__BOOLEANv (GClosure     *closure,
 946                                    GValue       *return_value,
 947                                    gpointer      instance,
 948                                    va_list       args,
 949                                    gpointer      marshal_data,
 950                                    int           n_params,
 951                                    GType        *param_types)
 952 {
 953   typedef void (*GMarshalFunc_VOID__BOOLEAN) (gpointer     instance,
 954                                               gboolean     arg_0,
 955                                               gpointer     data);
 956   GCClosure *cc = (GCClosure*) closure;
 957   gpointer data1, data2;
 958   GMarshalFunc_VOID__BOOLEAN callback;
 959   gboolean arg0;
 960   va_list args_copy;
 961 
 962   G_VA_COPY (args_copy, args);
 963   arg0 = (gboolean) va_arg (args_copy, gboolean);
 964   va_end (args_copy);
 965 
 966   if (G_CCLOSURE_SWAP_DATA (closure))
 967     {
 968       data1 = closure-&gt;data;
 969       data2 = instance;
 970     }
 971   else
 972     {
 973       data1 = instance;
 974       data2 = closure-&gt;data;
 975     }
 976   callback = (GMarshalFunc_VOID__BOOLEAN) (marshal_data ? marshal_data : cc-&gt;callback);
 977 
 978   callback (data1,
 979             arg0,
 980             data2);
 981 }
 982 
<span class="line-modified"> 983 </span>
<span class="line-modified"> 984 /* VOID:CHAR (./gmarshal.list:8) */</span>
















 985 void
 986 g_cclosure_marshal_VOID__CHAR (GClosure     *closure,
 987                                GValue       *return_value G_GNUC_UNUSED,
 988                                guint         n_param_values,
 989                                const GValue *param_values,
 990                                gpointer      invocation_hint G_GNUC_UNUSED,
 991                                gpointer      marshal_data)
 992 {
 993   typedef void (*GMarshalFunc_VOID__CHAR) (gpointer     data1,
 994                                            gchar        arg_1,
 995                                            gpointer     data2);
 996   GMarshalFunc_VOID__CHAR callback;
 997   GCClosure *cc = (GCClosure*) closure;
 998   gpointer data1, data2;
 999 
1000   g_return_if_fail (n_param_values == 2);
1001 
1002   if (G_CCLOSURE_SWAP_DATA (closure))
1003     {
1004       data1 = closure-&gt;data;
1005       data2 = g_value_peek_pointer (param_values + 0);
1006     }
1007   else
1008     {
1009       data1 = g_value_peek_pointer (param_values + 0);
1010       data2 = closure-&gt;data;
1011     }
1012   callback = (GMarshalFunc_VOID__CHAR) (marshal_data ? marshal_data : cc-&gt;callback);
1013 
1014   callback (data1,
1015             g_marshal_value_peek_char (param_values + 1),
1016             data2);
1017 }


















1018 void
1019 g_cclosure_marshal_VOID__CHARv (GClosure     *closure,
1020                                 GValue       *return_value,
1021                                 gpointer      instance,
1022                                 va_list       args,
1023                                 gpointer      marshal_data,
1024                                 int           n_params,
1025                                 GType        *param_types)
1026 {
1027   typedef void (*GMarshalFunc_VOID__CHAR) (gpointer     instance,
1028                                            gchar        arg_0,
1029                                            gpointer     data);
1030   GCClosure *cc = (GCClosure*) closure;
1031   gpointer data1, data2;
1032   GMarshalFunc_VOID__CHAR callback;
1033   gchar arg0;
1034   va_list args_copy;
1035 
1036   G_VA_COPY (args_copy, args);
1037   arg0 = (gchar) va_arg (args_copy, gint);
1038   va_end (args_copy);
1039 
1040   if (G_CCLOSURE_SWAP_DATA (closure))
1041     {
1042       data1 = closure-&gt;data;
1043       data2 = instance;
1044     }
1045   else
1046     {
1047       data1 = instance;
1048       data2 = closure-&gt;data;
1049     }
1050   callback = (GMarshalFunc_VOID__CHAR) (marshal_data ? marshal_data : cc-&gt;callback);
1051 
1052   callback (data1,
1053             arg0,
1054             data2);
1055 }
1056 
<span class="line-modified">1057 </span>
<span class="line-modified">1058 /* VOID:UCHAR (./gmarshal.list:9) */</span>
















1059 void
1060 g_cclosure_marshal_VOID__UCHAR (GClosure     *closure,
1061                                 GValue       *return_value G_GNUC_UNUSED,
1062                                 guint         n_param_values,
1063                                 const GValue *param_values,
1064                                 gpointer      invocation_hint G_GNUC_UNUSED,
1065                                 gpointer      marshal_data)
1066 {
1067   typedef void (*GMarshalFunc_VOID__UCHAR) (gpointer     data1,
1068                                             guchar       arg_1,
1069                                             gpointer     data2);
1070   GMarshalFunc_VOID__UCHAR callback;
1071   GCClosure *cc = (GCClosure*) closure;
1072   gpointer data1, data2;
1073 
1074   g_return_if_fail (n_param_values == 2);
1075 
1076   if (G_CCLOSURE_SWAP_DATA (closure))
1077     {
1078       data1 = closure-&gt;data;
1079       data2 = g_value_peek_pointer (param_values + 0);
1080     }
1081   else
1082     {
1083       data1 = g_value_peek_pointer (param_values + 0);
1084       data2 = closure-&gt;data;
1085     }
1086   callback = (GMarshalFunc_VOID__UCHAR) (marshal_data ? marshal_data : cc-&gt;callback);
1087 
1088   callback (data1,
1089             g_marshal_value_peek_uchar (param_values + 1),
1090             data2);
1091 }


















1092 void
1093 g_cclosure_marshal_VOID__UCHARv (GClosure     *closure,
1094                                  GValue       *return_value,
1095                                  gpointer      instance,
1096                                  va_list       args,
1097                                  gpointer      marshal_data,
1098                                  int           n_params,
1099                                  GType        *param_types)
1100 {
1101   typedef void (*GMarshalFunc_VOID__UCHAR) (gpointer     instance,
1102                                             guchar       arg_0,
1103                                             gpointer     data);
1104   GCClosure *cc = (GCClosure*) closure;
1105   gpointer data1, data2;
1106   GMarshalFunc_VOID__UCHAR callback;
1107   guchar arg0;
1108   va_list args_copy;
1109 
1110   G_VA_COPY (args_copy, args);
1111   arg0 = (guchar) va_arg (args_copy, guint);
1112   va_end (args_copy);
1113 
1114   if (G_CCLOSURE_SWAP_DATA (closure))
1115     {
1116       data1 = closure-&gt;data;
1117       data2 = instance;
1118     }
1119   else
1120     {
1121       data1 = instance;
1122       data2 = closure-&gt;data;
1123     }
1124   callback = (GMarshalFunc_VOID__UCHAR) (marshal_data ? marshal_data : cc-&gt;callback);
1125 
1126   callback (data1,
1127             arg0,
1128             data2);
1129 }
1130 
<span class="line-modified">1131 </span>
<span class="line-modified">1132 /* VOID:INT (./gmarshal.list:10) */</span>
















1133 void
1134 g_cclosure_marshal_VOID__INT (GClosure     *closure,
1135                               GValue       *return_value G_GNUC_UNUSED,
1136                               guint         n_param_values,
1137                               const GValue *param_values,
1138                               gpointer      invocation_hint G_GNUC_UNUSED,
1139                               gpointer      marshal_data)
1140 {
1141   typedef void (*GMarshalFunc_VOID__INT) (gpointer     data1,
1142                                           gint         arg_1,
1143                                           gpointer     data2);
1144   GMarshalFunc_VOID__INT callback;
1145   GCClosure *cc = (GCClosure*) closure;
1146   gpointer data1, data2;
1147 
1148   g_return_if_fail (n_param_values == 2);
1149 
1150   if (G_CCLOSURE_SWAP_DATA (closure))
1151     {
1152       data1 = closure-&gt;data;
1153       data2 = g_value_peek_pointer (param_values + 0);
1154     }
1155   else
1156     {
1157       data1 = g_value_peek_pointer (param_values + 0);
1158       data2 = closure-&gt;data;
1159     }
1160   callback = (GMarshalFunc_VOID__INT) (marshal_data ? marshal_data : cc-&gt;callback);
1161 
1162   callback (data1,
1163             g_marshal_value_peek_int (param_values + 1),
1164             data2);
1165 }


















1166 void
1167 g_cclosure_marshal_VOID__INTv (GClosure     *closure,
1168                                GValue       *return_value,
1169                                gpointer      instance,
1170                                va_list       args,
1171                                gpointer      marshal_data,
1172                                int           n_params,
1173                                GType        *param_types)
1174 {
1175   typedef void (*GMarshalFunc_VOID__INT) (gpointer     instance,
1176                                           gint         arg_0,
1177                                           gpointer     data);
1178   GCClosure *cc = (GCClosure*) closure;
1179   gpointer data1, data2;
1180   GMarshalFunc_VOID__INT callback;
1181   gint arg0;
1182   va_list args_copy;
1183 
1184  G_VA_COPY (args_copy, args);
1185   arg0 = (gint) va_arg (args_copy, gint);
1186   va_end (args_copy);
1187 
1188   if (G_CCLOSURE_SWAP_DATA (closure))
1189     {
1190       data1 = closure-&gt;data;
1191       data2 = instance;
1192     }
1193   else
1194     {
1195       data1 = instance;
1196       data2 = closure-&gt;data;
1197     }
1198   callback = (GMarshalFunc_VOID__INT) (marshal_data ? marshal_data : cc-&gt;callback);
1199 
1200   callback (data1,
1201             arg0,
1202             data2);
1203 }
1204 
<span class="line-modified">1205 </span>
<span class="line-modified">1206 /* VOID:UINT (./gmarshal.list:11) */</span>
















1207 void
1208 g_cclosure_marshal_VOID__UINT (GClosure     *closure,
1209                                GValue       *return_value G_GNUC_UNUSED,
1210                                guint         n_param_values,
1211                                const GValue *param_values,
1212                                gpointer      invocation_hint G_GNUC_UNUSED,
1213                                gpointer      marshal_data)
1214 {
1215   typedef void (*GMarshalFunc_VOID__UINT) (gpointer     data1,
1216                                            guint        arg_1,
1217                                            gpointer     data2);
1218   GMarshalFunc_VOID__UINT callback;
1219   GCClosure *cc = (GCClosure*) closure;
1220   gpointer data1, data2;
1221 
1222   g_return_if_fail (n_param_values == 2);
1223 
1224   if (G_CCLOSURE_SWAP_DATA (closure))
1225     {
1226       data1 = closure-&gt;data;
1227       data2 = g_value_peek_pointer (param_values + 0);
1228     }
1229   else
1230     {
1231       data1 = g_value_peek_pointer (param_values + 0);
1232       data2 = closure-&gt;data;
1233     }
1234   callback = (GMarshalFunc_VOID__UINT) (marshal_data ? marshal_data : cc-&gt;callback);
1235 
1236   callback (data1,
1237             g_marshal_value_peek_uint (param_values + 1),
1238             data2);
1239 }


















1240 void
1241 g_cclosure_marshal_VOID__UINTv (GClosure     *closure,
1242                                 GValue       *return_value,
1243                                 gpointer      instance,
1244                                 va_list       args,
1245                                 gpointer      marshal_data,
1246                                 int           n_params,
1247                                 GType        *param_types)
1248 {
1249   typedef void (*GMarshalFunc_VOID__UINT) (gpointer     instance,
1250                                            guint        arg_0,
1251                                            gpointer     data);
1252   GCClosure *cc = (GCClosure*) closure;
1253   gpointer data1, data2;
1254   GMarshalFunc_VOID__UINT callback;
1255   guint arg0;
1256   va_list args_copy;
1257 
1258   G_VA_COPY (args_copy, args);
1259   arg0 = (guint) va_arg (args_copy, guint);
1260   va_end (args_copy);
1261 
1262   if (G_CCLOSURE_SWAP_DATA (closure))
1263     {
1264       data1 = closure-&gt;data;
1265       data2 = instance;
1266     }
1267   else
1268     {
1269       data1 = instance;
1270       data2 = closure-&gt;data;
1271     }
1272   callback = (GMarshalFunc_VOID__UINT) (marshal_data ? marshal_data : cc-&gt;callback);
1273 
1274   callback (data1,
1275             arg0,
1276             data2);
1277 }
1278 
<span class="line-modified">1279 </span>
<span class="line-modified">1280 /* VOID:LONG (./gmarshal.list:12) */</span>
















1281 void
1282 g_cclosure_marshal_VOID__LONG (GClosure     *closure,
1283                                GValue       *return_value G_GNUC_UNUSED,
1284                                guint         n_param_values,
1285                                const GValue *param_values,
1286                                gpointer      invocation_hint G_GNUC_UNUSED,
1287                                gpointer      marshal_data)
1288 {
1289   typedef void (*GMarshalFunc_VOID__LONG) (gpointer     data1,
1290                                            glong        arg_1,
1291                                            gpointer     data2);
1292   GMarshalFunc_VOID__LONG callback;
1293   GCClosure *cc = (GCClosure*) closure;
1294   gpointer data1, data2;
1295 
1296   g_return_if_fail (n_param_values == 2);
1297 
1298   if (G_CCLOSURE_SWAP_DATA (closure))
1299     {
1300       data1 = closure-&gt;data;
1301       data2 = g_value_peek_pointer (param_values + 0);
1302     }
1303   else
1304     {
1305       data1 = g_value_peek_pointer (param_values + 0);
1306       data2 = closure-&gt;data;
1307     }
1308   callback = (GMarshalFunc_VOID__LONG) (marshal_data ? marshal_data : cc-&gt;callback);
1309 
1310   callback (data1,
1311             g_marshal_value_peek_long (param_values + 1),
1312             data2);
1313 }


















1314 void
1315 g_cclosure_marshal_VOID__LONGv (GClosure     *closure,
1316                                 GValue       *return_value,
1317                                 gpointer      instance,
1318                                 va_list       args,
1319                                 gpointer      marshal_data,
1320                                 int           n_params,
1321                                 GType        *param_types)
1322 {
1323   typedef void (*GMarshalFunc_VOID__LONG) (gpointer     instance,
1324                                            glong        arg_0,
1325                                            gpointer     data);
1326   GCClosure *cc = (GCClosure*) closure;
1327   gpointer data1, data2;
1328   GMarshalFunc_VOID__LONG callback;
1329   glong arg0;
1330   va_list args_copy;
1331 
1332   G_VA_COPY (args_copy, args);
1333   arg0 = (glong) va_arg (args_copy, glong);
1334   va_end (args_copy);
1335 
1336   if (G_CCLOSURE_SWAP_DATA (closure))
1337     {
1338       data1 = closure-&gt;data;
1339       data2 = instance;
1340     }
1341   else
1342     {
1343       data1 = instance;
1344       data2 = closure-&gt;data;
1345     }
1346   callback = (GMarshalFunc_VOID__LONG) (marshal_data ? marshal_data : cc-&gt;callback);
1347 
1348   callback (data1,
1349             arg0,
1350             data2);
1351 }
1352 
<span class="line-modified">1353 </span>
<span class="line-modified">1354 /* VOID:ULONG (./gmarshal.list:13) */</span>
















1355 void
1356 g_cclosure_marshal_VOID__ULONG (GClosure     *closure,
1357                                 GValue       *return_value G_GNUC_UNUSED,
1358                                 guint         n_param_values,
1359                                 const GValue *param_values,
1360                                 gpointer      invocation_hint G_GNUC_UNUSED,
1361                                 gpointer      marshal_data)
1362 {
1363   typedef void (*GMarshalFunc_VOID__ULONG) (gpointer     data1,
1364                                             gulong       arg_1,
1365                                             gpointer     data2);
1366   GMarshalFunc_VOID__ULONG callback;
1367   GCClosure *cc = (GCClosure*) closure;
1368   gpointer data1, data2;
1369 
1370   g_return_if_fail (n_param_values == 2);
1371 
1372   if (G_CCLOSURE_SWAP_DATA (closure))
1373     {
1374       data1 = closure-&gt;data;
1375       data2 = g_value_peek_pointer (param_values + 0);
1376     }
1377   else
1378     {
1379       data1 = g_value_peek_pointer (param_values + 0);
1380       data2 = closure-&gt;data;
1381     }
1382   callback = (GMarshalFunc_VOID__ULONG) (marshal_data ? marshal_data : cc-&gt;callback);
1383 
1384   callback (data1,
1385             g_marshal_value_peek_ulong (param_values + 1),
1386             data2);
1387 }


















1388 void
1389 g_cclosure_marshal_VOID__ULONGv (GClosure     *closure,
1390                                  GValue       *return_value,
1391                                  gpointer      instance,
1392                                  va_list       args,
1393                                  gpointer      marshal_data,
1394                                  int           n_params,
1395                                  GType        *param_types)
1396 {
1397   typedef void (*GMarshalFunc_VOID__ULONG) (gpointer     instance,
1398                                             gulong       arg_0,
1399                                             gpointer     data);
1400   GCClosure *cc = (GCClosure*) closure;
1401   gpointer data1, data2;
1402   GMarshalFunc_VOID__ULONG callback;
1403   gulong arg0;
1404   va_list args_copy;
1405 
1406   G_VA_COPY (args_copy, args);
1407   arg0 = (gulong) va_arg (args_copy, gulong);
1408   va_end (args_copy);
1409 
1410   if (G_CCLOSURE_SWAP_DATA (closure))
1411     {
1412       data1 = closure-&gt;data;
1413       data2 = instance;
1414     }
1415   else
1416     {
1417       data1 = instance;
1418       data2 = closure-&gt;data;
1419     }
1420   callback = (GMarshalFunc_VOID__ULONG) (marshal_data ? marshal_data : cc-&gt;callback);
1421 
1422   callback (data1,
1423             arg0,
1424             data2);
1425 }
1426 
<span class="line-modified">1427 </span>
<span class="line-modified">1428 /* VOID:ENUM (./gmarshal.list:14) */</span>
















1429 void
1430 g_cclosure_marshal_VOID__ENUM (GClosure     *closure,
1431                                GValue       *return_value G_GNUC_UNUSED,
1432                                guint         n_param_values,
1433                                const GValue *param_values,
1434                                gpointer      invocation_hint G_GNUC_UNUSED,
1435                                gpointer      marshal_data)
1436 {
1437   typedef void (*GMarshalFunc_VOID__ENUM) (gpointer     data1,
1438                                            gint         arg_1,
1439                                            gpointer     data2);
1440   GMarshalFunc_VOID__ENUM callback;
1441   GCClosure *cc = (GCClosure*) closure;
1442   gpointer data1, data2;
1443 
1444   g_return_if_fail (n_param_values == 2);
1445 
1446   if (G_CCLOSURE_SWAP_DATA (closure))
1447     {
1448       data1 = closure-&gt;data;
1449       data2 = g_value_peek_pointer (param_values + 0);
1450     }
1451   else
1452     {
1453       data1 = g_value_peek_pointer (param_values + 0);
1454       data2 = closure-&gt;data;
1455     }
1456   callback = (GMarshalFunc_VOID__ENUM) (marshal_data ? marshal_data : cc-&gt;callback);
1457 
1458   callback (data1,
1459             g_marshal_value_peek_enum (param_values + 1),
1460             data2);
1461 }


















1462 void
1463 g_cclosure_marshal_VOID__ENUMv (GClosure     *closure,
1464                                 GValue       *return_value,
1465                                 gpointer      instance,
1466                                 va_list       args,
1467                                 gpointer      marshal_data,
1468                                 int           n_params,
1469                                 GType        *param_types)
1470 {
1471   typedef void (*GMarshalFunc_VOID__ENUM) (gpointer     instance,
1472                                            gint         arg_0,
1473                                            gpointer     data);
1474   GCClosure *cc = (GCClosure*) closure;
1475   gpointer data1, data2;
1476   GMarshalFunc_VOID__ENUM callback;
1477   gint arg0;
1478   va_list args_copy;
1479 
1480   G_VA_COPY (args_copy, args);
1481   arg0 = (gint) va_arg (args_copy, gint);
1482   va_end (args_copy);
1483 
1484   if (G_CCLOSURE_SWAP_DATA (closure))
1485     {
1486       data1 = closure-&gt;data;
1487       data2 = instance;
1488     }
1489   else
1490     {
1491       data1 = instance;
1492       data2 = closure-&gt;data;
1493     }
1494   callback = (GMarshalFunc_VOID__ENUM) (marshal_data ? marshal_data : cc-&gt;callback);
1495 
1496   callback (data1,
1497             arg0,
1498             data2);
1499 }
1500 
<span class="line-modified">1501 </span>
<span class="line-modified">1502 /* VOID:FLAGS (./gmarshal.list:15) */</span>
















1503 void
1504 g_cclosure_marshal_VOID__FLAGS (GClosure     *closure,
1505                                 GValue       *return_value G_GNUC_UNUSED,
1506                                 guint         n_param_values,
1507                                 const GValue *param_values,
1508                                 gpointer      invocation_hint G_GNUC_UNUSED,
1509                                 gpointer      marshal_data)
1510 {
1511   typedef void (*GMarshalFunc_VOID__FLAGS) (gpointer     data1,
1512                                             guint        arg_1,
1513                                             gpointer     data2);
1514   GMarshalFunc_VOID__FLAGS callback;
1515   GCClosure *cc = (GCClosure*) closure;
1516   gpointer data1, data2;
1517 
1518   g_return_if_fail (n_param_values == 2);
1519 
1520   if (G_CCLOSURE_SWAP_DATA (closure))
1521     {
1522       data1 = closure-&gt;data;
1523       data2 = g_value_peek_pointer (param_values + 0);
1524     }
1525   else
1526     {
1527       data1 = g_value_peek_pointer (param_values + 0);
1528       data2 = closure-&gt;data;
1529     }
1530   callback = (GMarshalFunc_VOID__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
1531 
1532   callback (data1,
1533             g_marshal_value_peek_flags (param_values + 1),
1534             data2);
1535 }


















1536 void
1537 g_cclosure_marshal_VOID__FLAGSv (GClosure     *closure,
1538                                  GValue       *return_value,
1539                                  gpointer      instance,
1540                                  va_list       args,
1541                                  gpointer      marshal_data,
1542                                  int           n_params,
1543                                  GType        *param_types)
1544 {
1545   typedef void (*GMarshalFunc_VOID__FLAGS) (gpointer     instance,
1546                                             guint        arg_0,
1547                                             gpointer     data);
1548   GCClosure *cc = (GCClosure*) closure;
1549   gpointer data1, data2;
1550   GMarshalFunc_VOID__FLAGS callback;
1551   guint arg0;
1552   va_list args_copy;
1553 
1554   G_VA_COPY (args_copy, args);
1555   arg0 = (guint) va_arg (args_copy, guint);
1556   va_end (args_copy);
1557 
1558   if (G_CCLOSURE_SWAP_DATA (closure))
1559     {
1560       data1 = closure-&gt;data;
1561       data2 = instance;
1562     }
1563   else
1564     {
1565       data1 = instance;
1566       data2 = closure-&gt;data;
1567     }
1568   callback = (GMarshalFunc_VOID__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
1569 
1570   callback (data1,
1571             arg0,
1572             data2);
1573 }
1574 
<span class="line-modified">1575 </span>
<span class="line-modified">1576 /* VOID:FLOAT (./gmarshal.list:16) */</span>
















1577 void
1578 g_cclosure_marshal_VOID__FLOAT (GClosure     *closure,
1579                                 GValue       *return_value G_GNUC_UNUSED,
1580                                 guint         n_param_values,
1581                                 const GValue *param_values,
1582                                 gpointer      invocation_hint G_GNUC_UNUSED,
1583                                 gpointer      marshal_data)
1584 {
1585   typedef void (*GMarshalFunc_VOID__FLOAT) (gpointer     data1,
1586                                             gfloat       arg_1,
1587                                             gpointer     data2);
1588   GMarshalFunc_VOID__FLOAT callback;
1589   GCClosure *cc = (GCClosure*) closure;
1590   gpointer data1, data2;
1591 
1592   g_return_if_fail (n_param_values == 2);
1593 
1594   if (G_CCLOSURE_SWAP_DATA (closure))
1595     {
1596       data1 = closure-&gt;data;
1597       data2 = g_value_peek_pointer (param_values + 0);
1598     }
1599   else
1600     {
1601       data1 = g_value_peek_pointer (param_values + 0);
1602       data2 = closure-&gt;data;
1603     }
1604   callback = (GMarshalFunc_VOID__FLOAT) (marshal_data ? marshal_data : cc-&gt;callback);
1605 
1606   callback (data1,
1607             g_marshal_value_peek_float (param_values + 1),
1608             data2);
1609 }


















1610 void
1611 g_cclosure_marshal_VOID__FLOATv (GClosure     *closure,
1612                                  GValue       *return_value,
1613                                  gpointer      instance,
1614                                  va_list       args,
1615                                  gpointer      marshal_data,
1616                                  int           n_params,
1617                                  GType        *param_types)
1618 {
1619   typedef void (*GMarshalFunc_VOID__FLOAT) (gpointer     instance,
1620                                             gfloat       arg_0,
1621                                             gpointer     data);
1622   GCClosure *cc = (GCClosure*) closure;
1623   gpointer data1, data2;
1624   GMarshalFunc_VOID__FLOAT callback;
1625   gfloat arg0;
1626   va_list args_copy;
1627 
1628   G_VA_COPY (args_copy, args);
1629   arg0 = (gfloat) va_arg (args_copy, gdouble);
1630   va_end (args_copy);
1631 
1632   if (G_CCLOSURE_SWAP_DATA (closure))
1633     {
1634       data1 = closure-&gt;data;
1635       data2 = instance;
1636     }
1637   else
1638     {
1639       data1 = instance;
1640       data2 = closure-&gt;data;
1641     }
1642   callback = (GMarshalFunc_VOID__FLOAT) (marshal_data ? marshal_data : cc-&gt;callback);
1643 
1644   callback (data1,
1645             arg0,
1646             data2);
1647 }
1648 
<span class="line-modified">1649 </span>
<span class="line-modified">1650 /* VOID:DOUBLE (./gmarshal.list:17) */</span>
















1651 void
1652 g_cclosure_marshal_VOID__DOUBLE (GClosure     *closure,
1653                                  GValue       *return_value G_GNUC_UNUSED,
1654                                  guint         n_param_values,
1655                                  const GValue *param_values,
1656                                  gpointer      invocation_hint G_GNUC_UNUSED,
1657                                  gpointer      marshal_data)
1658 {
1659   typedef void (*GMarshalFunc_VOID__DOUBLE) (gpointer     data1,
1660                                              gdouble      arg_1,
1661                                              gpointer     data2);
1662   GMarshalFunc_VOID__DOUBLE callback;
1663   GCClosure *cc = (GCClosure*) closure;
1664   gpointer data1, data2;
1665 
1666   g_return_if_fail (n_param_values == 2);
1667 
1668   if (G_CCLOSURE_SWAP_DATA (closure))
1669     {
1670       data1 = closure-&gt;data;
1671       data2 = g_value_peek_pointer (param_values + 0);
1672     }
1673   else
1674     {
1675       data1 = g_value_peek_pointer (param_values + 0);
1676       data2 = closure-&gt;data;
1677     }
1678   callback = (GMarshalFunc_VOID__DOUBLE) (marshal_data ? marshal_data : cc-&gt;callback);
1679 
1680   callback (data1,
1681             g_marshal_value_peek_double (param_values + 1),
1682             data2);
1683 }


















1684 void
1685 g_cclosure_marshal_VOID__DOUBLEv (GClosure     *closure,
1686                                   GValue       *return_value,
1687                                   gpointer      instance,
1688                                   va_list       args,
1689                                   gpointer      marshal_data,
1690                                   int           n_params,
1691                                   GType        *param_types)
1692 {
1693   typedef void (*GMarshalFunc_VOID__DOUBLE) (gpointer     instance,
1694                                              gdouble      arg_0,
1695                                              gpointer     data);
1696   GCClosure *cc = (GCClosure*) closure;
1697   gpointer data1, data2;
1698   GMarshalFunc_VOID__DOUBLE callback;
1699   gdouble arg0;
1700   va_list args_copy;
1701 
1702   G_VA_COPY (args_copy, args);
1703   arg0 = (gdouble) va_arg (args_copy, gdouble);
1704   va_end (args_copy);
1705 
1706   if (G_CCLOSURE_SWAP_DATA (closure))
1707     {
1708       data1 = closure-&gt;data;
1709       data2 = instance;
1710     }
1711   else
1712     {
1713       data1 = instance;
1714       data2 = closure-&gt;data;
1715     }
1716   callback = (GMarshalFunc_VOID__DOUBLE) (marshal_data ? marshal_data : cc-&gt;callback);
1717 
1718   callback (data1,
1719             arg0,
1720             data2);
1721 }
1722 
<span class="line-modified">1723 </span>
<span class="line-modified">1724 /* VOID:STRING (./gmarshal.list:18) */</span>
















1725 void
1726 g_cclosure_marshal_VOID__STRING (GClosure     *closure,
1727                                  GValue       *return_value G_GNUC_UNUSED,
1728                                  guint         n_param_values,
1729                                  const GValue *param_values,
1730                                  gpointer      invocation_hint G_GNUC_UNUSED,
1731                                  gpointer      marshal_data)
1732 {
1733   typedef void (*GMarshalFunc_VOID__STRING) (gpointer     data1,
1734                                              gpointer     arg_1,
1735                                              gpointer     data2);
1736   GMarshalFunc_VOID__STRING callback;
1737   GCClosure *cc = (GCClosure*) closure;
1738   gpointer data1, data2;
1739 
1740   g_return_if_fail (n_param_values == 2);
1741 
1742   if (G_CCLOSURE_SWAP_DATA (closure))
1743     {
1744       data1 = closure-&gt;data;
1745       data2 = g_value_peek_pointer (param_values + 0);
1746     }
1747   else
1748     {
1749       data1 = g_value_peek_pointer (param_values + 0);
1750       data2 = closure-&gt;data;
1751     }
1752   callback = (GMarshalFunc_VOID__STRING) (marshal_data ? marshal_data : cc-&gt;callback);
1753 
1754   callback (data1,
1755             g_marshal_value_peek_string (param_values + 1),
1756             data2);
1757 }


















1758 void
1759 g_cclosure_marshal_VOID__STRINGv (GClosure     *closure,
1760                                   GValue       *return_value,
1761                                   gpointer      instance,
1762                                   va_list       args,
1763                                   gpointer      marshal_data,
1764                                   int           n_params,
1765                                   GType        *param_types)
1766 {
1767   typedef void (*GMarshalFunc_VOID__STRING) (gpointer     instance,
1768                                              gpointer     arg_0,
1769                                              gpointer     data);
1770   GCClosure *cc = (GCClosure*) closure;
1771   gpointer data1, data2;
1772   GMarshalFunc_VOID__STRING callback;
1773   gpointer arg0;
1774   va_list args_copy;
1775 
1776   G_VA_COPY (args_copy, args);
1777   arg0 = (gpointer) va_arg (args_copy, gpointer);
</pre>
<hr />
<pre>
1781 
1782   if (G_CCLOSURE_SWAP_DATA (closure))
1783     {
1784       data1 = closure-&gt;data;
1785       data2 = instance;
1786     }
1787   else
1788     {
1789       data1 = instance;
1790       data2 = closure-&gt;data;
1791     }
1792   callback = (GMarshalFunc_VOID__STRING) (marshal_data ? marshal_data : cc-&gt;callback);
1793 
1794   callback (data1,
1795             arg0,
1796             data2);
1797   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1798     g_free (arg0);
1799 }
1800 
<span class="line-modified">1801 </span>
<span class="line-modified">1802 /* VOID:PARAM (./gmarshal.list:19) */</span>
















1803 void
1804 g_cclosure_marshal_VOID__PARAM (GClosure     *closure,
1805                                 GValue       *return_value G_GNUC_UNUSED,
1806                                 guint         n_param_values,
1807                                 const GValue *param_values,
1808                                 gpointer      invocation_hint G_GNUC_UNUSED,
1809                                 gpointer      marshal_data)
1810 {
1811   typedef void (*GMarshalFunc_VOID__PARAM) (gpointer     data1,
1812                                             gpointer     arg_1,
1813                                             gpointer     data2);
1814   GMarshalFunc_VOID__PARAM callback;
1815   GCClosure *cc = (GCClosure*) closure;
1816   gpointer data1, data2;
1817 
1818   g_return_if_fail (n_param_values == 2);
1819 
1820   if (G_CCLOSURE_SWAP_DATA (closure))
1821     {
1822       data1 = closure-&gt;data;
1823       data2 = g_value_peek_pointer (param_values + 0);
1824     }
1825   else
1826     {
1827       data1 = g_value_peek_pointer (param_values + 0);
1828       data2 = closure-&gt;data;
1829     }
1830   callback = (GMarshalFunc_VOID__PARAM) (marshal_data ? marshal_data : cc-&gt;callback);
1831 
1832   callback (data1,
1833             g_marshal_value_peek_param (param_values + 1),
1834             data2);
1835 }


















1836 void
1837 g_cclosure_marshal_VOID__PARAMv (GClosure     *closure,
1838                                  GValue       *return_value,
1839                                  gpointer      instance,
1840                                  va_list       args,
1841                                  gpointer      marshal_data,
1842                                  int           n_params,
1843                                  GType        *param_types)
1844 {
1845   typedef void (*GMarshalFunc_VOID__PARAM) (gpointer     instance,
1846                                             gpointer     arg_0,
1847                                             gpointer     data);
1848   GCClosure *cc = (GCClosure*) closure;
1849   gpointer data1, data2;
1850   GMarshalFunc_VOID__PARAM callback;
1851   gpointer arg0;
1852   va_list args_copy;
1853 
1854   G_VA_COPY (args_copy, args);
1855   arg0 = (gpointer) va_arg (args_copy, gpointer);
</pre>
<hr />
<pre>
1859 
1860   if (G_CCLOSURE_SWAP_DATA (closure))
1861     {
1862       data1 = closure-&gt;data;
1863       data2 = instance;
1864     }
1865   else
1866     {
1867       data1 = instance;
1868       data2 = closure-&gt;data;
1869     }
1870   callback = (GMarshalFunc_VOID__PARAM) (marshal_data ? marshal_data : cc-&gt;callback);
1871 
1872   callback (data1,
1873             arg0,
1874             data2);
1875   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1876     g_param_spec_unref (arg0);
1877 }
1878 
<span class="line-modified">1879 </span>
<span class="line-modified">1880 /* VOID:BOXED (./gmarshal.list:20) */</span>
















1881 void
1882 g_cclosure_marshal_VOID__BOXED (GClosure     *closure,
1883                                 GValue       *return_value G_GNUC_UNUSED,
1884                                 guint         n_param_values,
1885                                 const GValue *param_values,
1886                                 gpointer      invocation_hint G_GNUC_UNUSED,
1887                                 gpointer      marshal_data)
1888 {
1889   typedef void (*GMarshalFunc_VOID__BOXED) (gpointer     data1,
1890                                             gpointer     arg_1,
1891                                             gpointer     data2);
1892   GMarshalFunc_VOID__BOXED callback;
1893   GCClosure *cc = (GCClosure*) closure;
1894   gpointer data1, data2;
1895 
1896   g_return_if_fail (n_param_values == 2);
1897 
1898   if (G_CCLOSURE_SWAP_DATA (closure))
1899     {
1900       data1 = closure-&gt;data;
1901       data2 = g_value_peek_pointer (param_values + 0);
1902     }
1903   else
1904     {
1905       data1 = g_value_peek_pointer (param_values + 0);
1906       data2 = closure-&gt;data;
1907     }
1908   callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
1909 
1910   callback (data1,
1911             g_marshal_value_peek_boxed (param_values + 1),
1912             data2);
1913 }


















1914 void
1915 g_cclosure_marshal_VOID__BOXEDv (GClosure     *closure,
1916                                  GValue       *return_value,
1917                                  gpointer      instance,
1918                                  va_list       args,
1919                                  gpointer      marshal_data,
1920                                  int           n_params,
1921                                  GType        *param_types)
1922 {
1923   typedef void (*GMarshalFunc_VOID__BOXED) (gpointer     instance,
1924                                             gpointer     arg_0,
1925                                             gpointer     data);
1926   GCClosure *cc = (GCClosure*) closure;
1927   gpointer data1, data2;
1928   GMarshalFunc_VOID__BOXED callback;
1929   gpointer arg0;
1930   va_list args_copy;
1931 
1932   G_VA_COPY (args_copy, args);
1933   arg0 = (gpointer) va_arg (args_copy, gpointer);
</pre>
<hr />
<pre>
1937 
1938   if (G_CCLOSURE_SWAP_DATA (closure))
1939     {
1940       data1 = closure-&gt;data;
1941       data2 = instance;
1942     }
1943   else
1944     {
1945       data1 = instance;
1946       data2 = closure-&gt;data;
1947     }
1948   callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
1949 
1950   callback (data1,
1951             arg0,
1952             data2);
1953   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1954     g_boxed_free (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
1955 }
1956 
<span class="line-modified">1957 </span>
<span class="line-modified">1958 /* VOID:POINTER (./gmarshal.list:21) */</span>




















1959 void
1960 g_cclosure_marshal_VOID__POINTER (GClosure     *closure,
1961                                   GValue       *return_value G_GNUC_UNUSED,
1962                                   guint         n_param_values,
1963                                   const GValue *param_values,
1964                                   gpointer      invocation_hint G_GNUC_UNUSED,
1965                                   gpointer      marshal_data)
1966 {
1967   typedef void (*GMarshalFunc_VOID__POINTER) (gpointer     data1,
1968                                               gpointer     arg_1,
1969                                               gpointer     data2);
1970   GMarshalFunc_VOID__POINTER callback;
1971   GCClosure *cc = (GCClosure*) closure;
1972   gpointer data1, data2;
1973 
1974   g_return_if_fail (n_param_values == 2);
1975 
1976   if (G_CCLOSURE_SWAP_DATA (closure))
1977     {
1978       data1 = closure-&gt;data;
1979       data2 = g_value_peek_pointer (param_values + 0);
1980     }
1981   else
1982     {
1983       data1 = g_value_peek_pointer (param_values + 0);
1984       data2 = closure-&gt;data;
1985     }
1986   callback = (GMarshalFunc_VOID__POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
1987 
1988   callback (data1,
1989             g_marshal_value_peek_pointer (param_values + 1),
1990             data2);
1991 }


















1992 void
1993 g_cclosure_marshal_VOID__POINTERv (GClosure     *closure,
1994                                    GValue       *return_value,
1995                                    gpointer      instance,
1996                                    va_list       args,
1997                                    gpointer      marshal_data,
1998                                    int           n_params,
1999                                    GType        *param_types)
2000 {
2001   typedef void (*GMarshalFunc_VOID__POINTER) (gpointer     instance,
2002                                               gpointer     arg_0,
2003                                               gpointer     data);
2004   GCClosure *cc = (GCClosure*) closure;
2005   gpointer data1, data2;
2006   GMarshalFunc_VOID__POINTER callback;
2007   gpointer arg0;
2008   va_list args_copy;
2009 
2010   G_VA_COPY (args_copy, args);
2011   arg0 = (gpointer) va_arg (args_copy, gpointer);
2012   va_end (args_copy);
2013 
2014   if (G_CCLOSURE_SWAP_DATA (closure))
2015     {
2016       data1 = closure-&gt;data;
2017       data2 = instance;
2018     }
2019   else
2020     {
2021       data1 = instance;
2022       data2 = closure-&gt;data;
2023     }
2024   callback = (GMarshalFunc_VOID__POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2025 
2026   callback (data1,
2027             arg0,
2028             data2);
2029 }
2030 
<span class="line-modified">2031 </span>
<span class="line-modified">2032 /* VOID:OBJECT (./gmarshal.list:22) */</span>
















2033 void
2034 g_cclosure_marshal_VOID__OBJECT (GClosure     *closure,
2035                                  GValue       *return_value G_GNUC_UNUSED,
2036                                  guint         n_param_values,
2037                                  const GValue *param_values,
2038                                  gpointer      invocation_hint G_GNUC_UNUSED,
2039                                  gpointer      marshal_data)
2040 {
2041   typedef void (*GMarshalFunc_VOID__OBJECT) (gpointer     data1,
2042                                              gpointer     arg_1,
2043                                              gpointer     data2);
2044   GMarshalFunc_VOID__OBJECT callback;
2045   GCClosure *cc = (GCClosure*) closure;
2046   gpointer data1, data2;
2047 
2048   g_return_if_fail (n_param_values == 2);
2049 
2050   if (G_CCLOSURE_SWAP_DATA (closure))
2051     {
2052       data1 = closure-&gt;data;
2053       data2 = g_value_peek_pointer (param_values + 0);
2054     }
2055   else
2056     {
2057       data1 = g_value_peek_pointer (param_values + 0);
2058       data2 = closure-&gt;data;
2059     }
2060   callback = (GMarshalFunc_VOID__OBJECT) (marshal_data ? marshal_data : cc-&gt;callback);
2061 
2062   callback (data1,
2063             g_marshal_value_peek_object (param_values + 1),
2064             data2);
2065 }


















2066 void
2067 g_cclosure_marshal_VOID__OBJECTv (GClosure     *closure,
2068                                   GValue       *return_value,
2069                                   gpointer      instance,
2070                                   va_list       args,
2071                                   gpointer      marshal_data,
2072                                   int           n_params,
2073                                   GType        *param_types)
2074 {
2075   typedef void (*GMarshalFunc_VOID__OBJECT) (gpointer     instance,
2076                                              gpointer     arg_0,
2077                                              gpointer     data);
2078   GCClosure *cc = (GCClosure*) closure;
2079   gpointer data1, data2;
2080   GMarshalFunc_VOID__OBJECT callback;
2081   gpointer arg0;
2082   va_list args_copy;
2083 
2084   G_VA_COPY (args_copy, args);
2085   arg0 = (gpointer) va_arg (args_copy, gpointer);
</pre>
<hr />
<pre>
2089 
2090   if (G_CCLOSURE_SWAP_DATA (closure))
2091     {
2092       data1 = closure-&gt;data;
2093       data2 = instance;
2094     }
2095   else
2096     {
2097       data1 = instance;
2098       data2 = closure-&gt;data;
2099     }
2100   callback = (GMarshalFunc_VOID__OBJECT) (marshal_data ? marshal_data : cc-&gt;callback);
2101 
2102   callback (data1,
2103             arg0,
2104             data2);
2105   if (arg0 != NULL)
2106     g_object_unref (arg0);
2107 }
2108 
<span class="line-modified">2109 </span>
<span class="line-modified">2110 /* VOID:VARIANT (./gmarshal.list:23) */</span>
















2111 void
2112 g_cclosure_marshal_VOID__VARIANT (GClosure     *closure,
2113                                   GValue       *return_value G_GNUC_UNUSED,
2114                                   guint         n_param_values,
2115                                   const GValue *param_values,
2116                                   gpointer      invocation_hint G_GNUC_UNUSED,
2117                                   gpointer      marshal_data)
2118 {
2119   typedef void (*GMarshalFunc_VOID__VARIANT) (gpointer     data1,
2120                                               gpointer     arg_1,
2121                                               gpointer     data2);
2122   GMarshalFunc_VOID__VARIANT callback;
2123   GCClosure *cc = (GCClosure*) closure;
2124   gpointer data1, data2;
2125 
2126   g_return_if_fail (n_param_values == 2);
2127 
2128   if (G_CCLOSURE_SWAP_DATA (closure))
2129     {
2130       data1 = closure-&gt;data;
2131       data2 = g_value_peek_pointer (param_values + 0);
2132     }
2133   else
2134     {
2135       data1 = g_value_peek_pointer (param_values + 0);
2136       data2 = closure-&gt;data;
2137     }
2138   callback = (GMarshalFunc_VOID__VARIANT) (marshal_data ? marshal_data : cc-&gt;callback);
2139 
2140   callback (data1,
2141             g_marshal_value_peek_variant (param_values + 1),
2142             data2);
2143 }


















2144 void
2145 g_cclosure_marshal_VOID__VARIANTv (GClosure     *closure,
2146                                    GValue       *return_value,
2147                                    gpointer      instance,
2148                                    va_list       args,
2149                                    gpointer      marshal_data,
2150                                    int           n_params,
2151                                    GType        *param_types)
2152 {
2153   typedef void (*GMarshalFunc_VOID__VARIANT) (gpointer     instance,
2154                                               gpointer     arg_0,
2155                                               gpointer     data);
2156   GCClosure *cc = (GCClosure*) closure;
2157   gpointer data1, data2;
2158   GMarshalFunc_VOID__VARIANT callback;
2159   gpointer arg0;
2160   va_list args_copy;
2161 
2162   G_VA_COPY (args_copy, args);
2163   arg0 = (gpointer) va_arg (args_copy, gpointer);
</pre>
<hr />
<pre>
2167 
2168   if (G_CCLOSURE_SWAP_DATA (closure))
2169     {
2170       data1 = closure-&gt;data;
2171       data2 = instance;
2172     }
2173   else
2174     {
2175       data1 = instance;
2176       data2 = closure-&gt;data;
2177     }
2178   callback = (GMarshalFunc_VOID__VARIANT) (marshal_data ? marshal_data : cc-&gt;callback);
2179 
2180   callback (data1,
2181             arg0,
2182             data2);
2183   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2184     g_variant_unref (arg0);
2185 }
2186 
<span class="line-modified">2187 </span>
<span class="line-modified">2188 /* VOID:UINT,POINTER (./gmarshal.list:26) */</span>
















2189 void
2190 g_cclosure_marshal_VOID__UINT_POINTER (GClosure     *closure,
2191                                        GValue       *return_value G_GNUC_UNUSED,
2192                                        guint         n_param_values,
2193                                        const GValue *param_values,
2194                                        gpointer      invocation_hint G_GNUC_UNUSED,
2195                                        gpointer      marshal_data)
2196 {
2197   typedef void (*GMarshalFunc_VOID__UINT_POINTER) (gpointer     data1,
2198                                                    guint        arg_1,
2199                                                    gpointer     arg_2,
2200                                                    gpointer     data2);
2201   GMarshalFunc_VOID__UINT_POINTER callback;
2202   GCClosure *cc = (GCClosure*) closure;
2203   gpointer data1, data2;
2204 
2205   g_return_if_fail (n_param_values == 3);
2206 
2207   if (G_CCLOSURE_SWAP_DATA (closure))
2208     {
2209       data1 = closure-&gt;data;
2210       data2 = g_value_peek_pointer (param_values + 0);
2211     }
2212   else
2213     {
2214       data1 = g_value_peek_pointer (param_values + 0);
2215       data2 = closure-&gt;data;
2216     }
2217   callback = (GMarshalFunc_VOID__UINT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2218 
2219   callback (data1,
2220             g_marshal_value_peek_uint (param_values + 1),
2221             g_marshal_value_peek_pointer (param_values + 2),
2222             data2);
2223 }


















2224 void
2225 g_cclosure_marshal_VOID__UINT_POINTERv (GClosure     *closure,
2226                                         GValue       *return_value,
2227                                         gpointer      instance,
2228                                         va_list       args,
2229                                         gpointer      marshal_data,
2230                                         int           n_params,
2231                                         GType        *param_types)
2232 {
2233   typedef void (*GMarshalFunc_VOID__UINT_POINTER) (gpointer     instance,
2234                                                    guint        arg_0,
2235                                                    gpointer     arg_1,
2236                                                    gpointer     data);
2237   GCClosure *cc = (GCClosure*) closure;
2238   gpointer data1, data2;
2239   GMarshalFunc_VOID__UINT_POINTER callback;
2240   guint arg0;
2241   gpointer arg1;
2242   va_list args_copy;
2243 
</pre>
<hr />
<pre>
2247   va_end (args_copy);
2248 
2249   if (G_CCLOSURE_SWAP_DATA (closure))
2250     {
2251       data1 = closure-&gt;data;
2252       data2 = instance;
2253     }
2254   else
2255     {
2256       data1 = instance;
2257       data2 = closure-&gt;data;
2258     }
2259   callback = (GMarshalFunc_VOID__UINT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2260 
2261   callback (data1,
2262             arg0,
2263             arg1,
2264             data2);
2265 }
2266 
<span class="line-modified">2267 </span>
<span class="line-modified">2268 /* BOOL:FLAGS (./gmarshal.list:27) */</span>


















2269 void
2270 g_cclosure_marshal_BOOLEAN__FLAGS (GClosure     *closure,
2271                                    GValue       *return_value G_GNUC_UNUSED,
2272                                    guint         n_param_values,
2273                                    const GValue *param_values,
2274                                    gpointer      invocation_hint G_GNUC_UNUSED,
2275                                    gpointer      marshal_data)
2276 {
2277   typedef gboolean (*GMarshalFunc_BOOLEAN__FLAGS) (gpointer     data1,
2278                                                    guint        arg_1,
2279                                                    gpointer     data2);
2280   GMarshalFunc_BOOLEAN__FLAGS callback;
2281   GCClosure *cc = (GCClosure*) closure;
2282   gpointer data1, data2;
2283   gboolean v_return;
2284 
2285   g_return_if_fail (return_value != NULL);
2286   g_return_if_fail (n_param_values == 2);
2287 
2288   if (G_CCLOSURE_SWAP_DATA (closure))
2289     {
2290       data1 = closure-&gt;data;
2291       data2 = g_value_peek_pointer (param_values + 0);
2292     }
2293   else
2294     {
2295       data1 = g_value_peek_pointer (param_values + 0);
2296       data2 = closure-&gt;data;
2297     }
2298   callback = (GMarshalFunc_BOOLEAN__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
2299 
2300   v_return = callback (data1,
2301                        g_marshal_value_peek_flags (param_values + 1),
2302                        data2);
2303 
2304   g_value_set_boolean (return_value, v_return);
2305 }


















2306 void
2307 g_cclosure_marshal_BOOLEAN__FLAGSv (GClosure     *closure,
2308                                     GValue       *return_value,
2309                                     gpointer      instance,
2310                                     va_list       args,
2311                                     gpointer      marshal_data,
2312                                     int           n_params,
2313                                     GType        *param_types)
2314 {
2315   typedef gboolean (*GMarshalFunc_BOOLEAN__FLAGS) (gpointer     instance,
2316                                                    guint        arg_0,
2317                                                    gpointer     data);
2318   GCClosure *cc = (GCClosure*) closure;
2319   gpointer data1, data2;
2320   GMarshalFunc_BOOLEAN__FLAGS callback;
2321   guint arg0;
2322   va_list args_copy;
2323   gboolean v_return;
2324 
2325   g_return_if_fail (return_value != NULL);
</pre>
<hr />
<pre>
2330 
2331   if (G_CCLOSURE_SWAP_DATA (closure))
2332     {
2333       data1 = closure-&gt;data;
2334       data2 = instance;
2335     }
2336   else
2337     {
2338       data1 = instance;
2339       data2 = closure-&gt;data;
2340     }
2341   callback = (GMarshalFunc_BOOLEAN__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
2342 
2343   v_return = callback (data1,
2344                        arg0,
2345                        data2);
2346 
2347   g_value_set_boolean (return_value, v_return);
2348 }
2349 
<span class="line-modified">2350 </span>
<span class="line-modified">2351 /* STRING:OBJECT,POINTER (./gmarshal.list:28) */</span>

















2352 void
2353 g_cclosure_marshal_STRING__OBJECT_POINTER (GClosure     *closure,
2354                                            GValue       *return_value G_GNUC_UNUSED,
2355                                            guint         n_param_values,
2356                                            const GValue *param_values,
2357                                            gpointer      invocation_hint G_GNUC_UNUSED,
2358                                            gpointer      marshal_data)
2359 {
2360   typedef gchar* (*GMarshalFunc_STRING__OBJECT_POINTER) (gpointer     data1,
2361                                                          gpointer     arg_1,
2362                                                          gpointer     arg_2,
2363                                                          gpointer     data2);
2364   GMarshalFunc_STRING__OBJECT_POINTER callback;
2365   GCClosure *cc = (GCClosure*) closure;
2366   gpointer data1, data2;
2367   gchar* v_return;
2368 
2369   g_return_if_fail (return_value != NULL);
2370   g_return_if_fail (n_param_values == 3);
2371 
2372   if (G_CCLOSURE_SWAP_DATA (closure))
2373     {
2374       data1 = closure-&gt;data;
2375       data2 = g_value_peek_pointer (param_values + 0);
2376     }
2377   else
2378     {
2379       data1 = g_value_peek_pointer (param_values + 0);
2380       data2 = closure-&gt;data;
2381     }
2382   callback = (GMarshalFunc_STRING__OBJECT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2383 
2384   v_return = callback (data1,
2385                        g_marshal_value_peek_object (param_values + 1),
2386                        g_marshal_value_peek_pointer (param_values + 2),
2387                        data2);
2388 
2389   g_value_take_string (return_value, v_return);
2390 }


















2391 void
2392 g_cclosure_marshal_STRING__OBJECT_POINTERv (GClosure     *closure,
2393                                             GValue       *return_value,
2394                                             gpointer      instance,
2395                                             va_list       args,
2396                                             gpointer      marshal_data,
2397                                             int           n_params,
2398                                             GType        *param_types)
2399 {
2400   typedef gchar* (*GMarshalFunc_STRING__OBJECT_POINTER) (gpointer     instance,
2401                                                          gpointer     arg_0,
2402                                                          gpointer     arg_1,
2403                                                          gpointer     data);
2404   GCClosure *cc = (GCClosure*) closure;
2405   gpointer data1, data2;
2406   GMarshalFunc_STRING__OBJECT_POINTER callback;
2407   gpointer arg0;
2408   gpointer arg1;
2409   va_list args_copy;
2410   gchar* v_return;
</pre>
<hr />
<pre>
2423       data1 = closure-&gt;data;
2424       data2 = instance;
2425     }
2426   else
2427     {
2428       data1 = instance;
2429       data2 = closure-&gt;data;
2430     }
2431   callback = (GMarshalFunc_STRING__OBJECT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2432 
2433   v_return = callback (data1,
2434                        arg0,
2435                        arg1,
2436                        data2);
2437   if (arg0 != NULL)
2438     g_object_unref (arg0);
2439 
2440   g_value_take_string (return_value, v_return);
2441 }
2442 
<span class="line-modified">2443 </span>
<span class="line-modified">2444 /* BOOL:BOXED,BOXED (./gmarshal.list:29) */</span>


















2445 void
2446 g_cclosure_marshal_BOOLEAN__BOXED_BOXED (GClosure     *closure,
2447                                          GValue       *return_value G_GNUC_UNUSED,
2448                                          guint         n_param_values,
2449                                          const GValue *param_values,
2450                                          gpointer      invocation_hint G_GNUC_UNUSED,
2451                                          gpointer      marshal_data)
2452 {
2453   typedef gboolean (*GMarshalFunc_BOOLEAN__BOXED_BOXED) (gpointer     data1,
2454                                                          gpointer     arg_1,
2455                                                          gpointer     arg_2,
2456                                                          gpointer     data2);
2457   GMarshalFunc_BOOLEAN__BOXED_BOXED callback;
2458   GCClosure *cc = (GCClosure*) closure;
2459   gpointer data1, data2;
2460   gboolean v_return;
2461 
2462   g_return_if_fail (return_value != NULL);
2463   g_return_if_fail (n_param_values == 3);
2464 
2465   if (G_CCLOSURE_SWAP_DATA (closure))
2466     {
2467       data1 = closure-&gt;data;
2468       data2 = g_value_peek_pointer (param_values + 0);
2469     }
2470   else
2471     {
2472       data1 = g_value_peek_pointer (param_values + 0);
2473       data2 = closure-&gt;data;
2474     }
2475   callback = (GMarshalFunc_BOOLEAN__BOXED_BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
2476 
2477   v_return = callback (data1,
2478                        g_marshal_value_peek_boxed (param_values + 1),
2479                        g_marshal_value_peek_boxed (param_values + 2),
2480                        data2);
2481 
2482   g_value_set_boolean (return_value, v_return);
2483 }


















2484 void
2485 g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv (GClosure     *closure,
2486                                           GValue       *return_value,
2487                                           gpointer      instance,
2488                                           va_list       args,
2489                                           gpointer      marshal_data,
2490                                           int           n_params,
2491                                           GType        *param_types)
2492 {
2493   typedef gboolean (*GMarshalFunc_BOOLEAN__BOXED_BOXED) (gpointer     instance,
2494                                                          gpointer     arg_0,
2495                                                          gpointer     arg_1,
2496                                                          gpointer     data);
2497   GCClosure *cc = (GCClosure*) closure;
2498   gpointer data1, data2;
2499   GMarshalFunc_BOOLEAN__BOXED_BOXED callback;
2500   gpointer arg0;
2501   gpointer arg1;
2502   va_list args_copy;
2503   gboolean v_return;
</pre>
<hr />
<pre>
2519       data2 = instance;
2520     }
2521   else
2522     {
2523       data1 = instance;
2524       data2 = closure-&gt;data;
2525     }
2526   callback = (GMarshalFunc_BOOLEAN__BOXED_BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
2527 
2528   v_return = callback (data1,
2529                        arg0,
2530                        arg1,
2531                        data2);
2532   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2533     g_boxed_free (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
2534   if ((param_types[1] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg1 != NULL)
2535     g_boxed_free (param_types[1] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
2536 
2537   g_value_set_boolean (return_value, v_return);
2538 }
<span class="line-removed">2539 </span>
<span class="line-removed">2540 </span>
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /* GObject - GLib Type, Object, Parameter and Signal Library</span>























































































































































































































































































































































































































































































































































































































































































































































































   2  *
<span class="line-modified">   3  * This library is free software; you can redistribute it and/or</span>
<span class="line-modified">   4  * modify it under the terms of the GNU Lesser General Public</span>
<span class="line-modified">   5  * License as published by the Free Software Foundation; either</span>
<span class="line-modified">   6  * version 2.1 of the License, or (at your option) any later version.</span>












   7  *
<span class="line-modified">   8  * This library is distributed in the hope that it will be useful,</span>
<span class="line-modified">   9  * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="line-modified">  10  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="line-modified">  11  * Lesser General Public License for more details.</span>












  12  *
<span class="line-modified">  13  * You should have received a copy of the GNU Lesser General</span>
<span class="line-added">  14  * Public License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  15  */
  16 
<span class="line-added">  17 #include &quot;config.h&quot;</span>
<span class="line-added">  18 </span>
<span class="line-added">  19 #include &quot;gobject.h&quot;</span>
<span class="line-added">  20 #include &quot;genums.h&quot;</span>
<span class="line-added">  21 #include &quot;gboxed.h&quot;</span>
<span class="line-added">  22 #include &quot;gvaluetypes.h&quot;</span>
<span class="line-added">  23 </span>
<span class="line-added">  24 </span>
  25 #ifdef G_ENABLE_DEBUG
  26 #define g_marshal_value_peek_boolean(v)  g_value_get_boolean (v)
  27 #define g_marshal_value_peek_char(v)     g_value_get_schar (v)
  28 #define g_marshal_value_peek_uchar(v)    g_value_get_uchar (v)
  29 #define g_marshal_value_peek_int(v)      g_value_get_int (v)
  30 #define g_marshal_value_peek_uint(v)     g_value_get_uint (v)
  31 #define g_marshal_value_peek_long(v)     g_value_get_long (v)
  32 #define g_marshal_value_peek_ulong(v)    g_value_get_ulong (v)
  33 #define g_marshal_value_peek_int64(v)    g_value_get_int64 (v)
  34 #define g_marshal_value_peek_uint64(v)   g_value_get_uint64 (v)
  35 #define g_marshal_value_peek_enum(v)     g_value_get_enum (v)
  36 #define g_marshal_value_peek_flags(v)    g_value_get_flags (v)
  37 #define g_marshal_value_peek_float(v)    g_value_get_float (v)
  38 #define g_marshal_value_peek_double(v)   g_value_get_double (v)
  39 #define g_marshal_value_peek_string(v)   (char*) g_value_get_string (v)
  40 #define g_marshal_value_peek_param(v)    g_value_get_param (v)
  41 #define g_marshal_value_peek_boxed(v)    g_value_get_boxed (v)
  42 #define g_marshal_value_peek_pointer(v)  g_value_get_pointer (v)
  43 #define g_marshal_value_peek_object(v)   g_value_get_object (v)
  44 #define g_marshal_value_peek_variant(v)  g_value_get_variant (v)
</pre>
<hr />
<pre>
  52 #define g_marshal_value_peek_uchar(v)    (v)-&gt;data[0].v_uint
  53 #define g_marshal_value_peek_int(v)      (v)-&gt;data[0].v_int
  54 #define g_marshal_value_peek_uint(v)     (v)-&gt;data[0].v_uint
  55 #define g_marshal_value_peek_long(v)     (v)-&gt;data[0].v_long
  56 #define g_marshal_value_peek_ulong(v)    (v)-&gt;data[0].v_ulong
  57 #define g_marshal_value_peek_int64(v)    (v)-&gt;data[0].v_int64
  58 #define g_marshal_value_peek_uint64(v)   (v)-&gt;data[0].v_uint64
  59 #define g_marshal_value_peek_enum(v)     (v)-&gt;data[0].v_long
  60 #define g_marshal_value_peek_flags(v)    (v)-&gt;data[0].v_ulong
  61 #define g_marshal_value_peek_float(v)    (v)-&gt;data[0].v_float
  62 #define g_marshal_value_peek_double(v)   (v)-&gt;data[0].v_double
  63 #define g_marshal_value_peek_string(v)   (v)-&gt;data[0].v_pointer
  64 #define g_marshal_value_peek_param(v)    (v)-&gt;data[0].v_pointer
  65 #define g_marshal_value_peek_boxed(v)    (v)-&gt;data[0].v_pointer
  66 #define g_marshal_value_peek_pointer(v)  (v)-&gt;data[0].v_pointer
  67 #define g_marshal_value_peek_object(v)   (v)-&gt;data[0].v_pointer
  68 #define g_marshal_value_peek_variant(v)  (v)-&gt;data[0].v_pointer
  69 #endif /* !G_ENABLE_DEBUG */
  70 
  71 
<span class="line-modified">  72 /**</span>
<span class="line-added">  73  * g_cclosure_marshal_VOID__VOID:</span>
<span class="line-added">  74  * @closure: A #GClosure.</span>
<span class="line-added">  75  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">  76  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">  77  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">  78  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">  79  *   on which to invoke the callback of closure.</span>
<span class="line-added">  80  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">  81  *   g_closure_invoke().</span>
<span class="line-added">  82  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">  83  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">  84  *   g_closure_set_meta_marshal()</span>
<span class="line-added">  85  *</span>
<span class="line-added">  86  * A #GClosureMarshal function for use with signals with no arguments.</span>
<span class="line-added">  87  */</span>
<span class="line-added">  88 /* VOID:VOID */</span>
  89 void
  90 g_cclosure_marshal_VOID__VOID (GClosure     *closure,
  91                                GValue       *return_value G_GNUC_UNUSED,
  92                                guint         n_param_values,
  93                                const GValue *param_values,
  94                                gpointer      invocation_hint G_GNUC_UNUSED,
  95                                gpointer      marshal_data)
  96 {
  97   typedef void (*GMarshalFunc_VOID__VOID) (gpointer     data1,
  98                                            gpointer     data2);
  99   GMarshalFunc_VOID__VOID callback;
 100   GCClosure *cc = (GCClosure*) closure;
 101   gpointer data1, data2;
 102 
 103   g_return_if_fail (n_param_values == 1);
 104 
 105   if (G_CCLOSURE_SWAP_DATA (closure))
 106     {
 107       data1 = closure-&gt;data;
 108       data2 = g_value_peek_pointer (param_values + 0);
 109     }
 110   else
 111     {
 112       data1 = g_value_peek_pointer (param_values + 0);
 113       data2 = closure-&gt;data;
 114     }
 115   callback = (GMarshalFunc_VOID__VOID) (marshal_data ? marshal_data : cc-&gt;callback);
 116 
 117   callback (data1,
 118             data2);
 119 }
<span class="line-added"> 120 </span>
<span class="line-added"> 121 /**</span>
<span class="line-added"> 122  * g_cclosure_marshal_VOID__VOIDv:</span>
<span class="line-added"> 123  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added"> 124  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added"> 125  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added"> 126  *  value.</span>
<span class="line-added"> 127  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added"> 128  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added"> 129  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added"> 130  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 131  *  g_closure_set_meta_marshal()</span>
<span class="line-added"> 132  * @n_params: the length of the @param_types array</span>
<span class="line-added"> 133  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added"> 134  *  @args.</span>
<span class="line-added"> 135  *</span>
<span class="line-added"> 136  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__VOID().</span>
<span class="line-added"> 137  */</span>
 138 void
 139 g_cclosure_marshal_VOID__VOIDv (GClosure     *closure,
 140                                 GValue       *return_value,
 141                                 gpointer      instance,
 142                                 va_list       args,
 143                                 gpointer      marshal_data,
 144                                 int           n_params,
 145                                 GType        *param_types)
 146 {
 147   typedef void (*GMarshalFunc_VOID__VOID) (gpointer     instance,
 148                                            gpointer     data);
 149   GCClosure *cc = (GCClosure*) closure;
 150   gpointer data1, data2;
 151   GMarshalFunc_VOID__VOID callback;
 152 
 153   if (G_CCLOSURE_SWAP_DATA (closure))
 154     {
 155       data1 = closure-&gt;data;
 156       data2 = instance;
 157     }
 158   else
 159     {
 160       data1 = instance;
 161       data2 = closure-&gt;data;
 162     }
 163   callback = (GMarshalFunc_VOID__VOID) (marshal_data ? marshal_data : cc-&gt;callback);
 164 
 165   callback (data1,
 166             data2);
 167 }
 168 
<span class="line-modified"> 169 /**</span>
<span class="line-modified"> 170  * g_cclosure_marshal_VOID__BOOLEAN:</span>
<span class="line-added"> 171  * @closure: A #GClosure.</span>
<span class="line-added"> 172  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added"> 173  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added"> 174  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added"> 175  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added"> 176  *   on which to invoke the callback of closure.</span>
<span class="line-added"> 177  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added"> 178  *   g_closure_invoke().</span>
<span class="line-added"> 179  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added"> 180  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 181  *   g_closure_set_meta_marshal()</span>
<span class="line-added"> 182  *</span>
<span class="line-added"> 183  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added"> 184  * boolean argument.</span>
<span class="line-added"> 185  */</span>
<span class="line-added"> 186 /* VOID:BOOLEAN */</span>
 187 void
 188 g_cclosure_marshal_VOID__BOOLEAN (GClosure     *closure,
 189                                   GValue       *return_value G_GNUC_UNUSED,
 190                                   guint         n_param_values,
 191                                   const GValue *param_values,
 192                                   gpointer      invocation_hint G_GNUC_UNUSED,
 193                                   gpointer      marshal_data)
 194 {
 195   typedef void (*GMarshalFunc_VOID__BOOLEAN) (gpointer     data1,
 196                                               gboolean     arg_1,
 197                                               gpointer     data2);
 198   GMarshalFunc_VOID__BOOLEAN callback;
 199   GCClosure *cc = (GCClosure*) closure;
 200   gpointer data1, data2;
 201 
 202   g_return_if_fail (n_param_values == 2);
 203 
 204   if (G_CCLOSURE_SWAP_DATA (closure))
 205     {
 206       data1 = closure-&gt;data;
 207       data2 = g_value_peek_pointer (param_values + 0);
 208     }
 209   else
 210     {
 211       data1 = g_value_peek_pointer (param_values + 0);
 212       data2 = closure-&gt;data;
 213     }
 214   callback = (GMarshalFunc_VOID__BOOLEAN) (marshal_data ? marshal_data : cc-&gt;callback);
 215 
 216   callback (data1,
 217             g_marshal_value_peek_boolean (param_values + 1),
 218             data2);
 219 }
<span class="line-added"> 220 </span>
<span class="line-added"> 221 /**</span>
<span class="line-added"> 222  * g_cclosure_marshal_VOID__BOOLEANv:</span>
<span class="line-added"> 223  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added"> 224  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added"> 225  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added"> 226  *  value.</span>
<span class="line-added"> 227  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added"> 228  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added"> 229  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added"> 230  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 231  *  g_closure_set_meta_marshal()</span>
<span class="line-added"> 232  * @n_params: the length of the @param_types array</span>
<span class="line-added"> 233  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added"> 234  *  @args.</span>
<span class="line-added"> 235  *</span>
<span class="line-added"> 236  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__BOOLEAN().</span>
<span class="line-added"> 237  */</span>
 238 void
 239 g_cclosure_marshal_VOID__BOOLEANv (GClosure     *closure,
 240                                    GValue       *return_value,
 241                                    gpointer      instance,
 242                                    va_list       args,
 243                                    gpointer      marshal_data,
 244                                    int           n_params,
 245                                    GType        *param_types)
 246 {
 247   typedef void (*GMarshalFunc_VOID__BOOLEAN) (gpointer     instance,
 248                                               gboolean     arg_0,
 249                                               gpointer     data);
 250   GCClosure *cc = (GCClosure*) closure;
 251   gpointer data1, data2;
 252   GMarshalFunc_VOID__BOOLEAN callback;
 253   gboolean arg0;
 254   va_list args_copy;
 255 
 256   G_VA_COPY (args_copy, args);
 257   arg0 = (gboolean) va_arg (args_copy, gboolean);
 258   va_end (args_copy);
 259 
 260   if (G_CCLOSURE_SWAP_DATA (closure))
 261     {
 262       data1 = closure-&gt;data;
 263       data2 = instance;
 264     }
 265   else
 266     {
 267       data1 = instance;
 268       data2 = closure-&gt;data;
 269     }
 270   callback = (GMarshalFunc_VOID__BOOLEAN) (marshal_data ? marshal_data : cc-&gt;callback);
 271 
 272   callback (data1,
 273             arg0,
 274             data2);
 275 }
 276 
<span class="line-modified"> 277 /**</span>
<span class="line-modified"> 278  * g_cclosure_marshal_VOID__CHAR:</span>
<span class="line-added"> 279  * @closure: A #GClosure.</span>
<span class="line-added"> 280  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added"> 281  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added"> 282  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added"> 283  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added"> 284  *   on which to invoke the callback of closure.</span>
<span class="line-added"> 285  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added"> 286  *   g_closure_invoke().</span>
<span class="line-added"> 287  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added"> 288  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 289  *   g_closure_set_meta_marshal()</span>
<span class="line-added"> 290  *</span>
<span class="line-added"> 291  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added"> 292  * character argument.</span>
<span class="line-added"> 293  */</span>
<span class="line-added"> 294 /* VOID:CHAR */</span>
 295 void
 296 g_cclosure_marshal_VOID__CHAR (GClosure     *closure,
 297                                GValue       *return_value G_GNUC_UNUSED,
 298                                guint         n_param_values,
 299                                const GValue *param_values,
 300                                gpointer      invocation_hint G_GNUC_UNUSED,
 301                                gpointer      marshal_data)
 302 {
 303   typedef void (*GMarshalFunc_VOID__CHAR) (gpointer     data1,
 304                                            gchar        arg_1,
 305                                            gpointer     data2);
 306   GMarshalFunc_VOID__CHAR callback;
 307   GCClosure *cc = (GCClosure*) closure;
 308   gpointer data1, data2;
 309 
 310   g_return_if_fail (n_param_values == 2);
 311 
 312   if (G_CCLOSURE_SWAP_DATA (closure))
 313     {
 314       data1 = closure-&gt;data;
 315       data2 = g_value_peek_pointer (param_values + 0);
 316     }
 317   else
 318     {
 319       data1 = g_value_peek_pointer (param_values + 0);
 320       data2 = closure-&gt;data;
 321     }
 322   callback = (GMarshalFunc_VOID__CHAR) (marshal_data ? marshal_data : cc-&gt;callback);
 323 
 324   callback (data1,
 325             g_marshal_value_peek_char (param_values + 1),
 326             data2);
 327 }
<span class="line-added"> 328 </span>
<span class="line-added"> 329 /**</span>
<span class="line-added"> 330  * g_cclosure_marshal_VOID__CHARv:</span>
<span class="line-added"> 331  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added"> 332  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added"> 333  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added"> 334  *  value.</span>
<span class="line-added"> 335  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added"> 336  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added"> 337  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added"> 338  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 339  *  g_closure_set_meta_marshal()</span>
<span class="line-added"> 340  * @n_params: the length of the @param_types array</span>
<span class="line-added"> 341  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added"> 342  *  @args.</span>
<span class="line-added"> 343  *</span>
<span class="line-added"> 344  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__CHAR().</span>
<span class="line-added"> 345  */</span>
 346 void
 347 g_cclosure_marshal_VOID__CHARv (GClosure     *closure,
 348                                 GValue       *return_value,
 349                                 gpointer      instance,
 350                                 va_list       args,
 351                                 gpointer      marshal_data,
 352                                 int           n_params,
 353                                 GType        *param_types)
 354 {
 355   typedef void (*GMarshalFunc_VOID__CHAR) (gpointer     instance,
 356                                            gchar        arg_0,
 357                                            gpointer     data);
 358   GCClosure *cc = (GCClosure*) closure;
 359   gpointer data1, data2;
 360   GMarshalFunc_VOID__CHAR callback;
 361   gchar arg0;
 362   va_list args_copy;
 363 
 364   G_VA_COPY (args_copy, args);
 365   arg0 = (gchar) va_arg (args_copy, gint);
 366   va_end (args_copy);
 367 
 368   if (G_CCLOSURE_SWAP_DATA (closure))
 369     {
 370       data1 = closure-&gt;data;
 371       data2 = instance;
 372     }
 373   else
 374     {
 375       data1 = instance;
 376       data2 = closure-&gt;data;
 377     }
 378   callback = (GMarshalFunc_VOID__CHAR) (marshal_data ? marshal_data : cc-&gt;callback);
 379 
 380   callback (data1,
 381             arg0,
 382             data2);
 383 }
 384 
<span class="line-modified"> 385 /**</span>
<span class="line-modified"> 386  * g_cclosure_marshal_VOID__UCHAR:</span>
<span class="line-added"> 387  * @closure: A #GClosure.</span>
<span class="line-added"> 388  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added"> 389  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added"> 390  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added"> 391  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added"> 392  *   on which to invoke the callback of closure.</span>
<span class="line-added"> 393  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added"> 394  *   g_closure_invoke().</span>
<span class="line-added"> 395  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added"> 396  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 397  *   g_closure_set_meta_marshal()</span>
<span class="line-added"> 398  *</span>
<span class="line-added"> 399  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added"> 400  * unsigned character argument.</span>
<span class="line-added"> 401  */</span>
<span class="line-added"> 402 /* VOID:UCHAR */</span>
 403 void
 404 g_cclosure_marshal_VOID__UCHAR (GClosure     *closure,
 405                                 GValue       *return_value G_GNUC_UNUSED,
 406                                 guint         n_param_values,
 407                                 const GValue *param_values,
 408                                 gpointer      invocation_hint G_GNUC_UNUSED,
 409                                 gpointer      marshal_data)
 410 {
 411   typedef void (*GMarshalFunc_VOID__UCHAR) (gpointer     data1,
 412                                             guchar       arg_1,
 413                                             gpointer     data2);
 414   GMarshalFunc_VOID__UCHAR callback;
 415   GCClosure *cc = (GCClosure*) closure;
 416   gpointer data1, data2;
 417 
 418   g_return_if_fail (n_param_values == 2);
 419 
 420   if (G_CCLOSURE_SWAP_DATA (closure))
 421     {
 422       data1 = closure-&gt;data;
 423       data2 = g_value_peek_pointer (param_values + 0);
 424     }
 425   else
 426     {
 427       data1 = g_value_peek_pointer (param_values + 0);
 428       data2 = closure-&gt;data;
 429     }
 430   callback = (GMarshalFunc_VOID__UCHAR) (marshal_data ? marshal_data : cc-&gt;callback);
 431 
 432   callback (data1,
 433             g_marshal_value_peek_uchar (param_values + 1),
 434             data2);
 435 }
<span class="line-added"> 436 </span>
<span class="line-added"> 437 /**</span>
<span class="line-added"> 438  * g_cclosure_marshal_VOID__UCHARv:</span>
<span class="line-added"> 439  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added"> 440  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added"> 441  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added"> 442  *  value.</span>
<span class="line-added"> 443  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added"> 444  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added"> 445  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added"> 446  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 447  *  g_closure_set_meta_marshal()</span>
<span class="line-added"> 448  * @n_params: the length of the @param_types array</span>
<span class="line-added"> 449  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added"> 450  *  @args.</span>
<span class="line-added"> 451  *</span>
<span class="line-added"> 452  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UCHAR().</span>
<span class="line-added"> 453  */</span>
 454 void
 455 g_cclosure_marshal_VOID__UCHARv (GClosure     *closure,
 456                                  GValue       *return_value,
 457                                  gpointer      instance,
 458                                  va_list       args,
 459                                  gpointer      marshal_data,
 460                                  int           n_params,
 461                                  GType        *param_types)
 462 {
 463   typedef void (*GMarshalFunc_VOID__UCHAR) (gpointer     instance,
 464                                             guchar       arg_0,
 465                                             gpointer     data);
 466   GCClosure *cc = (GCClosure*) closure;
 467   gpointer data1, data2;
 468   GMarshalFunc_VOID__UCHAR callback;
 469   guchar arg0;
 470   va_list args_copy;
 471 
 472   G_VA_COPY (args_copy, args);
 473   arg0 = (guchar) va_arg (args_copy, guint);
 474   va_end (args_copy);
 475 
 476   if (G_CCLOSURE_SWAP_DATA (closure))
 477     {
 478       data1 = closure-&gt;data;
 479       data2 = instance;
 480     }
 481   else
 482     {
 483       data1 = instance;
 484       data2 = closure-&gt;data;
 485     }
 486   callback = (GMarshalFunc_VOID__UCHAR) (marshal_data ? marshal_data : cc-&gt;callback);
 487 
 488   callback (data1,
 489             arg0,
 490             data2);
 491 }
 492 
<span class="line-modified"> 493 /**</span>
<span class="line-modified"> 494  * g_cclosure_marshal_VOID__INT:</span>
<span class="line-added"> 495  * @closure: A #GClosure.</span>
<span class="line-added"> 496  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added"> 497  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added"> 498  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added"> 499  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added"> 500  *   on which to invoke the callback of closure.</span>
<span class="line-added"> 501  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added"> 502  *   g_closure_invoke().</span>
<span class="line-added"> 503  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added"> 504  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 505  *   g_closure_set_meta_marshal()</span>
<span class="line-added"> 506  *</span>
<span class="line-added"> 507  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added"> 508  * integer argument.</span>
<span class="line-added"> 509  */</span>
<span class="line-added"> 510 /* VOID:INT */</span>
 511 void
 512 g_cclosure_marshal_VOID__INT (GClosure     *closure,
 513                               GValue       *return_value G_GNUC_UNUSED,
 514                               guint         n_param_values,
 515                               const GValue *param_values,
 516                               gpointer      invocation_hint G_GNUC_UNUSED,
 517                               gpointer      marshal_data)
 518 {
 519   typedef void (*GMarshalFunc_VOID__INT) (gpointer     data1,
 520                                           gint         arg_1,
 521                                           gpointer     data2);
 522   GMarshalFunc_VOID__INT callback;
 523   GCClosure *cc = (GCClosure*) closure;
 524   gpointer data1, data2;
 525 
 526   g_return_if_fail (n_param_values == 2);
 527 
 528   if (G_CCLOSURE_SWAP_DATA (closure))
 529     {
 530       data1 = closure-&gt;data;
 531       data2 = g_value_peek_pointer (param_values + 0);
 532     }
 533   else
 534     {
 535       data1 = g_value_peek_pointer (param_values + 0);
 536       data2 = closure-&gt;data;
 537     }
 538   callback = (GMarshalFunc_VOID__INT) (marshal_data ? marshal_data : cc-&gt;callback);
 539 
 540   callback (data1,
 541             g_marshal_value_peek_int (param_values + 1),
 542             data2);
 543 }
<span class="line-added"> 544 </span>
<span class="line-added"> 545 /**</span>
<span class="line-added"> 546  * g_cclosure_marshal_VOID__INTv:</span>
<span class="line-added"> 547  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added"> 548  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added"> 549  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added"> 550  *  value.</span>
<span class="line-added"> 551  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added"> 552  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added"> 553  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added"> 554  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 555  *  g_closure_set_meta_marshal()</span>
<span class="line-added"> 556  * @n_params: the length of the @param_types array</span>
<span class="line-added"> 557  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added"> 558  *  @args.</span>
<span class="line-added"> 559  *</span>
<span class="line-added"> 560  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__INT().</span>
<span class="line-added"> 561  */</span>
 562 void
 563 g_cclosure_marshal_VOID__INTv (GClosure     *closure,
 564                                GValue       *return_value,
 565                                gpointer      instance,
 566                                va_list       args,
 567                                gpointer      marshal_data,
 568                                int           n_params,
 569                                GType        *param_types)
 570 {
 571   typedef void (*GMarshalFunc_VOID__INT) (gpointer     instance,
 572                                           gint         arg_0,
 573                                           gpointer     data);
 574   GCClosure *cc = (GCClosure*) closure;
 575   gpointer data1, data2;
 576   GMarshalFunc_VOID__INT callback;
 577   gint arg0;
 578   va_list args_copy;
 579 
 580  G_VA_COPY (args_copy, args);
 581   arg0 = (gint) va_arg (args_copy, gint);
 582   va_end (args_copy);
 583 
 584   if (G_CCLOSURE_SWAP_DATA (closure))
 585     {
 586       data1 = closure-&gt;data;
 587       data2 = instance;
 588     }
 589   else
 590     {
 591       data1 = instance;
 592       data2 = closure-&gt;data;
 593     }
 594   callback = (GMarshalFunc_VOID__INT) (marshal_data ? marshal_data : cc-&gt;callback);
 595 
 596   callback (data1,
 597             arg0,
 598             data2);
 599 }
 600 
<span class="line-modified"> 601 /**</span>
<span class="line-modified"> 602  * g_cclosure_marshal_VOID__UINT:</span>
<span class="line-added"> 603  * @closure: A #GClosure.</span>
<span class="line-added"> 604  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added"> 605  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added"> 606  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added"> 607  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added"> 608  *   on which to invoke the callback of closure.</span>
<span class="line-added"> 609  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added"> 610  *   g_closure_invoke().</span>
<span class="line-added"> 611  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added"> 612  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 613  *   g_closure_set_meta_marshal()</span>
<span class="line-added"> 614  *</span>
<span class="line-added"> 615  * A #GClosureMarshal function for use with signals with with a single</span>
<span class="line-added"> 616  * unsigned integer argument.</span>
<span class="line-added"> 617  */</span>
<span class="line-added"> 618 /* VOID:UINT */</span>
 619 void
 620 g_cclosure_marshal_VOID__UINT (GClosure     *closure,
 621                                GValue       *return_value G_GNUC_UNUSED,
 622                                guint         n_param_values,
 623                                const GValue *param_values,
 624                                gpointer      invocation_hint G_GNUC_UNUSED,
 625                                gpointer      marshal_data)
 626 {
 627   typedef void (*GMarshalFunc_VOID__UINT) (gpointer     data1,
 628                                            guint        arg_1,
 629                                            gpointer     data2);
 630   GMarshalFunc_VOID__UINT callback;
 631   GCClosure *cc = (GCClosure*) closure;
 632   gpointer data1, data2;
 633 
 634   g_return_if_fail (n_param_values == 2);
 635 
 636   if (G_CCLOSURE_SWAP_DATA (closure))
 637     {
 638       data1 = closure-&gt;data;
 639       data2 = g_value_peek_pointer (param_values + 0);
 640     }
 641   else
 642     {
 643       data1 = g_value_peek_pointer (param_values + 0);
 644       data2 = closure-&gt;data;
 645     }
 646   callback = (GMarshalFunc_VOID__UINT) (marshal_data ? marshal_data : cc-&gt;callback);
 647 
 648   callback (data1,
 649             g_marshal_value_peek_uint (param_values + 1),
 650             data2);
 651 }
<span class="line-added"> 652 </span>
<span class="line-added"> 653 /**</span>
<span class="line-added"> 654  * g_cclosure_marshal_VOID__UINTv:</span>
<span class="line-added"> 655  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added"> 656  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added"> 657  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added"> 658  *  value.</span>
<span class="line-added"> 659  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added"> 660  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added"> 661  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added"> 662  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 663  *  g_closure_set_meta_marshal()</span>
<span class="line-added"> 664  * @n_params: the length of the @param_types array</span>
<span class="line-added"> 665  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added"> 666  *  @args.</span>
<span class="line-added"> 667  *</span>
<span class="line-added"> 668  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UINT().</span>
<span class="line-added"> 669  */</span>
 670 void
 671 g_cclosure_marshal_VOID__UINTv (GClosure     *closure,
 672                                 GValue       *return_value,
 673                                 gpointer      instance,
 674                                 va_list       args,
 675                                 gpointer      marshal_data,
 676                                 int           n_params,
 677                                 GType        *param_types)
 678 {
 679   typedef void (*GMarshalFunc_VOID__UINT) (gpointer     instance,
 680                                            guint        arg_0,
 681                                            gpointer     data);
 682   GCClosure *cc = (GCClosure*) closure;
 683   gpointer data1, data2;
 684   GMarshalFunc_VOID__UINT callback;
 685   guint arg0;
 686   va_list args_copy;
 687 
 688   G_VA_COPY (args_copy, args);
 689   arg0 = (guint) va_arg (args_copy, guint);
 690   va_end (args_copy);
 691 
 692   if (G_CCLOSURE_SWAP_DATA (closure))
 693     {
 694       data1 = closure-&gt;data;
 695       data2 = instance;
 696     }
 697   else
 698     {
 699       data1 = instance;
 700       data2 = closure-&gt;data;
 701     }
 702   callback = (GMarshalFunc_VOID__UINT) (marshal_data ? marshal_data : cc-&gt;callback);
 703 
 704   callback (data1,
 705             arg0,
 706             data2);
 707 }
 708 
<span class="line-modified"> 709 /**</span>
<span class="line-modified"> 710  * g_cclosure_marshal_VOID__LONG:</span>
<span class="line-added"> 711  * @closure: A #GClosure.</span>
<span class="line-added"> 712  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added"> 713  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added"> 714  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added"> 715  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added"> 716  *   on which to invoke the callback of closure.</span>
<span class="line-added"> 717  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added"> 718  *   g_closure_invoke().</span>
<span class="line-added"> 719  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added"> 720  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 721  *   g_closure_set_meta_marshal()</span>
<span class="line-added"> 722  *</span>
<span class="line-added"> 723  * A #GClosureMarshal function for use with signals with with a single</span>
<span class="line-added"> 724  * long integer argument.</span>
<span class="line-added"> 725  */</span>
<span class="line-added"> 726 /* VOID:LONG */</span>
 727 void
 728 g_cclosure_marshal_VOID__LONG (GClosure     *closure,
 729                                GValue       *return_value G_GNUC_UNUSED,
 730                                guint         n_param_values,
 731                                const GValue *param_values,
 732                                gpointer      invocation_hint G_GNUC_UNUSED,
 733                                gpointer      marshal_data)
 734 {
 735   typedef void (*GMarshalFunc_VOID__LONG) (gpointer     data1,
 736                                            glong        arg_1,
 737                                            gpointer     data2);
 738   GMarshalFunc_VOID__LONG callback;
 739   GCClosure *cc = (GCClosure*) closure;
 740   gpointer data1, data2;
 741 
 742   g_return_if_fail (n_param_values == 2);
 743 
 744   if (G_CCLOSURE_SWAP_DATA (closure))
 745     {
 746       data1 = closure-&gt;data;
 747       data2 = g_value_peek_pointer (param_values + 0);
 748     }
 749   else
 750     {
 751       data1 = g_value_peek_pointer (param_values + 0);
 752       data2 = closure-&gt;data;
 753     }
 754   callback = (GMarshalFunc_VOID__LONG) (marshal_data ? marshal_data : cc-&gt;callback);
 755 
 756   callback (data1,
 757             g_marshal_value_peek_long (param_values + 1),
 758             data2);
 759 }
<span class="line-added"> 760 </span>
<span class="line-added"> 761 /**</span>
<span class="line-added"> 762  * g_cclosure_marshal_VOID__LONGv:</span>
<span class="line-added"> 763  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added"> 764  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added"> 765  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added"> 766  *  value.</span>
<span class="line-added"> 767  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added"> 768  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added"> 769  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added"> 770  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 771  *  g_closure_set_meta_marshal()</span>
<span class="line-added"> 772  * @n_params: the length of the @param_types array</span>
<span class="line-added"> 773  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added"> 774  *  @args.</span>
<span class="line-added"> 775  *</span>
<span class="line-added"> 776  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__LONG().</span>
<span class="line-added"> 777  */</span>
 778 void
 779 g_cclosure_marshal_VOID__LONGv (GClosure     *closure,
 780                                 GValue       *return_value,
 781                                 gpointer      instance,
 782                                 va_list       args,
 783                                 gpointer      marshal_data,
 784                                 int           n_params,
 785                                 GType        *param_types)
 786 {
 787   typedef void (*GMarshalFunc_VOID__LONG) (gpointer     instance,
 788                                            glong        arg_0,
 789                                            gpointer     data);
 790   GCClosure *cc = (GCClosure*) closure;
 791   gpointer data1, data2;
 792   GMarshalFunc_VOID__LONG callback;
 793   glong arg0;
 794   va_list args_copy;
 795 
 796   G_VA_COPY (args_copy, args);
 797   arg0 = (glong) va_arg (args_copy, glong);
 798   va_end (args_copy);
 799 
 800   if (G_CCLOSURE_SWAP_DATA (closure))
 801     {
 802       data1 = closure-&gt;data;
 803       data2 = instance;
 804     }
 805   else
 806     {
 807       data1 = instance;
 808       data2 = closure-&gt;data;
 809     }
 810   callback = (GMarshalFunc_VOID__LONG) (marshal_data ? marshal_data : cc-&gt;callback);
 811 
 812   callback (data1,
 813             arg0,
 814             data2);
 815 }
 816 
<span class="line-modified"> 817 /**</span>
<span class="line-modified"> 818  * g_cclosure_marshal_VOID__ULONG:</span>
<span class="line-added"> 819  * @closure: A #GClosure.</span>
<span class="line-added"> 820  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added"> 821  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added"> 822  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added"> 823  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added"> 824  *   on which to invoke the callback of closure.</span>
<span class="line-added"> 825  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added"> 826  *   g_closure_invoke().</span>
<span class="line-added"> 827  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added"> 828  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 829  *   g_closure_set_meta_marshal()</span>
<span class="line-added"> 830  *</span>
<span class="line-added"> 831  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added"> 832  * unsigned long integer argument.</span>
<span class="line-added"> 833  */</span>
<span class="line-added"> 834 /* VOID:ULONG */</span>
 835 void
 836 g_cclosure_marshal_VOID__ULONG (GClosure     *closure,
 837                                 GValue       *return_value G_GNUC_UNUSED,
 838                                 guint         n_param_values,
 839                                 const GValue *param_values,
 840                                 gpointer      invocation_hint G_GNUC_UNUSED,
 841                                 gpointer      marshal_data)
 842 {
 843   typedef void (*GMarshalFunc_VOID__ULONG) (gpointer     data1,
 844                                             gulong       arg_1,
 845                                             gpointer     data2);
 846   GMarshalFunc_VOID__ULONG callback;
 847   GCClosure *cc = (GCClosure*) closure;
 848   gpointer data1, data2;
 849 
 850   g_return_if_fail (n_param_values == 2);
 851 
 852   if (G_CCLOSURE_SWAP_DATA (closure))
 853     {
 854       data1 = closure-&gt;data;
 855       data2 = g_value_peek_pointer (param_values + 0);
 856     }
 857   else
 858     {
 859       data1 = g_value_peek_pointer (param_values + 0);
 860       data2 = closure-&gt;data;
 861     }
 862   callback = (GMarshalFunc_VOID__ULONG) (marshal_data ? marshal_data : cc-&gt;callback);
 863 
 864   callback (data1,
 865             g_marshal_value_peek_ulong (param_values + 1),
 866             data2);
 867 }
<span class="line-added"> 868 </span>
<span class="line-added"> 869 /**</span>
<span class="line-added"> 870  * g_cclosure_marshal_VOID__ULONGv:</span>
<span class="line-added"> 871  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added"> 872  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added"> 873  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added"> 874  *  value.</span>
<span class="line-added"> 875  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added"> 876  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added"> 877  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added"> 878  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 879  *  g_closure_set_meta_marshal()</span>
<span class="line-added"> 880  * @n_params: the length of the @param_types array</span>
<span class="line-added"> 881  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added"> 882  *  @args.</span>
<span class="line-added"> 883  *</span>
<span class="line-added"> 884  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__ULONG().</span>
<span class="line-added"> 885  */</span>
 886 void
 887 g_cclosure_marshal_VOID__ULONGv (GClosure     *closure,
 888                                  GValue       *return_value,
 889                                  gpointer      instance,
 890                                  va_list       args,
 891                                  gpointer      marshal_data,
 892                                  int           n_params,
 893                                  GType        *param_types)
 894 {
 895   typedef void (*GMarshalFunc_VOID__ULONG) (gpointer     instance,
 896                                             gulong       arg_0,
 897                                             gpointer     data);
 898   GCClosure *cc = (GCClosure*) closure;
 899   gpointer data1, data2;
 900   GMarshalFunc_VOID__ULONG callback;
 901   gulong arg0;
 902   va_list args_copy;
 903 
 904   G_VA_COPY (args_copy, args);
 905   arg0 = (gulong) va_arg (args_copy, gulong);
 906   va_end (args_copy);
 907 
 908   if (G_CCLOSURE_SWAP_DATA (closure))
 909     {
 910       data1 = closure-&gt;data;
 911       data2 = instance;
 912     }
 913   else
 914     {
 915       data1 = instance;
 916       data2 = closure-&gt;data;
 917     }
 918   callback = (GMarshalFunc_VOID__ULONG) (marshal_data ? marshal_data : cc-&gt;callback);
 919 
 920   callback (data1,
 921             arg0,
 922             data2);
 923 }
 924 
<span class="line-modified"> 925 /**</span>
<span class="line-modified"> 926  * g_cclosure_marshal_VOID__ENUM:</span>
<span class="line-added"> 927  * @closure: A #GClosure.</span>
<span class="line-added"> 928  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added"> 929  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added"> 930  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added"> 931  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added"> 932  *   on which to invoke the callback of closure.</span>
<span class="line-added"> 933  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added"> 934  *   g_closure_invoke().</span>
<span class="line-added"> 935  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added"> 936  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 937  *   g_closure_set_meta_marshal()</span>
<span class="line-added"> 938  *</span>
<span class="line-added"> 939  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added"> 940  * argument with an enumerated type.</span>
<span class="line-added"> 941  */</span>
<span class="line-added"> 942 /* VOID:ENUM */</span>
 943 void
 944 g_cclosure_marshal_VOID__ENUM (GClosure     *closure,
 945                                GValue       *return_value G_GNUC_UNUSED,
 946                                guint         n_param_values,
 947                                const GValue *param_values,
 948                                gpointer      invocation_hint G_GNUC_UNUSED,
 949                                gpointer      marshal_data)
 950 {
 951   typedef void (*GMarshalFunc_VOID__ENUM) (gpointer     data1,
 952                                            gint         arg_1,
 953                                            gpointer     data2);
 954   GMarshalFunc_VOID__ENUM callback;
 955   GCClosure *cc = (GCClosure*) closure;
 956   gpointer data1, data2;
 957 
 958   g_return_if_fail (n_param_values == 2);
 959 
 960   if (G_CCLOSURE_SWAP_DATA (closure))
 961     {
 962       data1 = closure-&gt;data;
 963       data2 = g_value_peek_pointer (param_values + 0);
 964     }
 965   else
 966     {
 967       data1 = g_value_peek_pointer (param_values + 0);
 968       data2 = closure-&gt;data;
 969     }
 970   callback = (GMarshalFunc_VOID__ENUM) (marshal_data ? marshal_data : cc-&gt;callback);
 971 
 972   callback (data1,
 973             g_marshal_value_peek_enum (param_values + 1),
 974             data2);
 975 }
<span class="line-added"> 976 </span>
<span class="line-added"> 977 /**</span>
<span class="line-added"> 978  * g_cclosure_marshal_VOID__ENUMv:</span>
<span class="line-added"> 979  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added"> 980  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added"> 981  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added"> 982  *  value.</span>
<span class="line-added"> 983  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added"> 984  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added"> 985  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added"> 986  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added"> 987  *  g_closure_set_meta_marshal()</span>
<span class="line-added"> 988  * @n_params: the length of the @param_types array</span>
<span class="line-added"> 989  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added"> 990  *  @args.</span>
<span class="line-added"> 991  *</span>
<span class="line-added"> 992  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__ENUM().</span>
<span class="line-added"> 993  */</span>
 994 void
 995 g_cclosure_marshal_VOID__ENUMv (GClosure     *closure,
 996                                 GValue       *return_value,
 997                                 gpointer      instance,
 998                                 va_list       args,
 999                                 gpointer      marshal_data,
1000                                 int           n_params,
1001                                 GType        *param_types)
1002 {
1003   typedef void (*GMarshalFunc_VOID__ENUM) (gpointer     instance,
1004                                            gint         arg_0,
1005                                            gpointer     data);
1006   GCClosure *cc = (GCClosure*) closure;
1007   gpointer data1, data2;
1008   GMarshalFunc_VOID__ENUM callback;
1009   gint arg0;
1010   va_list args_copy;
1011 
1012   G_VA_COPY (args_copy, args);
1013   arg0 = (gint) va_arg (args_copy, gint);
1014   va_end (args_copy);
1015 
1016   if (G_CCLOSURE_SWAP_DATA (closure))
1017     {
1018       data1 = closure-&gt;data;
1019       data2 = instance;
1020     }
1021   else
1022     {
1023       data1 = instance;
1024       data2 = closure-&gt;data;
1025     }
1026   callback = (GMarshalFunc_VOID__ENUM) (marshal_data ? marshal_data : cc-&gt;callback);
1027 
1028   callback (data1,
1029             arg0,
1030             data2);
1031 }
1032 
<span class="line-modified">1033 /**</span>
<span class="line-modified">1034  * g_cclosure_marshal_VOID__FLAGS:</span>
<span class="line-added">1035  * @closure: A #GClosure.</span>
<span class="line-added">1036  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">1037  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">1038  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">1039  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">1040  *   on which to invoke the callback of closure.</span>
<span class="line-added">1041  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">1042  *   g_closure_invoke().</span>
<span class="line-added">1043  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">1044  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1045  *   g_closure_set_meta_marshal()</span>
<span class="line-added">1046  *</span>
<span class="line-added">1047  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added">1048  * argument with a flags types.</span>
<span class="line-added">1049  */</span>
<span class="line-added">1050 /* VOID:FLAGS */</span>
1051 void
1052 g_cclosure_marshal_VOID__FLAGS (GClosure     *closure,
1053                                 GValue       *return_value G_GNUC_UNUSED,
1054                                 guint         n_param_values,
1055                                 const GValue *param_values,
1056                                 gpointer      invocation_hint G_GNUC_UNUSED,
1057                                 gpointer      marshal_data)
1058 {
1059   typedef void (*GMarshalFunc_VOID__FLAGS) (gpointer     data1,
1060                                             guint        arg_1,
1061                                             gpointer     data2);
1062   GMarshalFunc_VOID__FLAGS callback;
1063   GCClosure *cc = (GCClosure*) closure;
1064   gpointer data1, data2;
1065 
1066   g_return_if_fail (n_param_values == 2);
1067 
1068   if (G_CCLOSURE_SWAP_DATA (closure))
1069     {
1070       data1 = closure-&gt;data;
1071       data2 = g_value_peek_pointer (param_values + 0);
1072     }
1073   else
1074     {
1075       data1 = g_value_peek_pointer (param_values + 0);
1076       data2 = closure-&gt;data;
1077     }
1078   callback = (GMarshalFunc_VOID__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
1079 
1080   callback (data1,
1081             g_marshal_value_peek_flags (param_values + 1),
1082             data2);
1083 }
<span class="line-added">1084 </span>
<span class="line-added">1085 /**</span>
<span class="line-added">1086  * g_cclosure_marshal_VOID__FLAGSv:</span>
<span class="line-added">1087  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">1088  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">1089  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">1090  *  value.</span>
<span class="line-added">1091  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">1092  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">1093  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">1094  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1095  *  g_closure_set_meta_marshal()</span>
<span class="line-added">1096  * @n_params: the length of the @param_types array</span>
<span class="line-added">1097  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">1098  *  @args.</span>
<span class="line-added">1099  *</span>
<span class="line-added">1100  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__FLAGS().</span>
<span class="line-added">1101  */</span>
1102 void
1103 g_cclosure_marshal_VOID__FLAGSv (GClosure     *closure,
1104                                  GValue       *return_value,
1105                                  gpointer      instance,
1106                                  va_list       args,
1107                                  gpointer      marshal_data,
1108                                  int           n_params,
1109                                  GType        *param_types)
1110 {
1111   typedef void (*GMarshalFunc_VOID__FLAGS) (gpointer     instance,
1112                                             guint        arg_0,
1113                                             gpointer     data);
1114   GCClosure *cc = (GCClosure*) closure;
1115   gpointer data1, data2;
1116   GMarshalFunc_VOID__FLAGS callback;
1117   guint arg0;
1118   va_list args_copy;
1119 
1120   G_VA_COPY (args_copy, args);
1121   arg0 = (guint) va_arg (args_copy, guint);
1122   va_end (args_copy);
1123 
1124   if (G_CCLOSURE_SWAP_DATA (closure))
1125     {
1126       data1 = closure-&gt;data;
1127       data2 = instance;
1128     }
1129   else
1130     {
1131       data1 = instance;
1132       data2 = closure-&gt;data;
1133     }
1134   callback = (GMarshalFunc_VOID__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
1135 
1136   callback (data1,
1137             arg0,
1138             data2);
1139 }
1140 
<span class="line-modified">1141 /**</span>
<span class="line-modified">1142  * g_cclosure_marshal_VOID__FLOAT:</span>
<span class="line-added">1143  * @closure: A #GClosure.</span>
<span class="line-added">1144  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">1145  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">1146  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">1147  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">1148  *   on which to invoke the callback of closure.</span>
<span class="line-added">1149  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">1150  *   g_closure_invoke().</span>
<span class="line-added">1151  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">1152  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1153  *   g_closure_set_meta_marshal()</span>
<span class="line-added">1154  *</span>
<span class="line-added">1155  * A #GClosureMarshal function for use with signals with one</span>
<span class="line-added">1156  * single-precision floating point argument.</span>
<span class="line-added">1157  */</span>
<span class="line-added">1158 /* VOID:FLOAT */</span>
1159 void
1160 g_cclosure_marshal_VOID__FLOAT (GClosure     *closure,
1161                                 GValue       *return_value G_GNUC_UNUSED,
1162                                 guint         n_param_values,
1163                                 const GValue *param_values,
1164                                 gpointer      invocation_hint G_GNUC_UNUSED,
1165                                 gpointer      marshal_data)
1166 {
1167   typedef void (*GMarshalFunc_VOID__FLOAT) (gpointer     data1,
1168                                             gfloat       arg_1,
1169                                             gpointer     data2);
1170   GMarshalFunc_VOID__FLOAT callback;
1171   GCClosure *cc = (GCClosure*) closure;
1172   gpointer data1, data2;
1173 
1174   g_return_if_fail (n_param_values == 2);
1175 
1176   if (G_CCLOSURE_SWAP_DATA (closure))
1177     {
1178       data1 = closure-&gt;data;
1179       data2 = g_value_peek_pointer (param_values + 0);
1180     }
1181   else
1182     {
1183       data1 = g_value_peek_pointer (param_values + 0);
1184       data2 = closure-&gt;data;
1185     }
1186   callback = (GMarshalFunc_VOID__FLOAT) (marshal_data ? marshal_data : cc-&gt;callback);
1187 
1188   callback (data1,
1189             g_marshal_value_peek_float (param_values + 1),
1190             data2);
1191 }
<span class="line-added">1192 </span>
<span class="line-added">1193 /**</span>
<span class="line-added">1194  * g_cclosure_marshal_VOID__FLOATv:</span>
<span class="line-added">1195  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">1196  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">1197  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">1198  *  value.</span>
<span class="line-added">1199  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">1200  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">1201  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">1202  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1203  *  g_closure_set_meta_marshal()</span>
<span class="line-added">1204  * @n_params: the length of the @param_types array</span>
<span class="line-added">1205  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">1206  *  @args.</span>
<span class="line-added">1207  *</span>
<span class="line-added">1208  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__FLOAT().</span>
<span class="line-added">1209  */</span>
1210 void
1211 g_cclosure_marshal_VOID__FLOATv (GClosure     *closure,
1212                                  GValue       *return_value,
1213                                  gpointer      instance,
1214                                  va_list       args,
1215                                  gpointer      marshal_data,
1216                                  int           n_params,
1217                                  GType        *param_types)
1218 {
1219   typedef void (*GMarshalFunc_VOID__FLOAT) (gpointer     instance,
1220                                             gfloat       arg_0,
1221                                             gpointer     data);
1222   GCClosure *cc = (GCClosure*) closure;
1223   gpointer data1, data2;
1224   GMarshalFunc_VOID__FLOAT callback;
1225   gfloat arg0;
1226   va_list args_copy;
1227 
1228   G_VA_COPY (args_copy, args);
1229   arg0 = (gfloat) va_arg (args_copy, gdouble);
1230   va_end (args_copy);
1231 
1232   if (G_CCLOSURE_SWAP_DATA (closure))
1233     {
1234       data1 = closure-&gt;data;
1235       data2 = instance;
1236     }
1237   else
1238     {
1239       data1 = instance;
1240       data2 = closure-&gt;data;
1241     }
1242   callback = (GMarshalFunc_VOID__FLOAT) (marshal_data ? marshal_data : cc-&gt;callback);
1243 
1244   callback (data1,
1245             arg0,
1246             data2);
1247 }
1248 
<span class="line-modified">1249 /**</span>
<span class="line-modified">1250  * g_cclosure_marshal_VOID__DOUBLE:</span>
<span class="line-added">1251  * @closure: A #GClosure.</span>
<span class="line-added">1252  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">1253  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">1254  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">1255  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">1256  *   on which to invoke the callback of closure.</span>
<span class="line-added">1257  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">1258  *   g_closure_invoke().</span>
<span class="line-added">1259  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">1260  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1261  *   g_closure_set_meta_marshal()</span>
<span class="line-added">1262  *</span>
<span class="line-added">1263  * A #GClosureMarshal function for use with signals with one</span>
<span class="line-added">1264  * double-precision floating point argument.</span>
<span class="line-added">1265  */</span>
<span class="line-added">1266 /* VOID:DOUBLE */</span>
1267 void
1268 g_cclosure_marshal_VOID__DOUBLE (GClosure     *closure,
1269                                  GValue       *return_value G_GNUC_UNUSED,
1270                                  guint         n_param_values,
1271                                  const GValue *param_values,
1272                                  gpointer      invocation_hint G_GNUC_UNUSED,
1273                                  gpointer      marshal_data)
1274 {
1275   typedef void (*GMarshalFunc_VOID__DOUBLE) (gpointer     data1,
1276                                              gdouble      arg_1,
1277                                              gpointer     data2);
1278   GMarshalFunc_VOID__DOUBLE callback;
1279   GCClosure *cc = (GCClosure*) closure;
1280   gpointer data1, data2;
1281 
1282   g_return_if_fail (n_param_values == 2);
1283 
1284   if (G_CCLOSURE_SWAP_DATA (closure))
1285     {
1286       data1 = closure-&gt;data;
1287       data2 = g_value_peek_pointer (param_values + 0);
1288     }
1289   else
1290     {
1291       data1 = g_value_peek_pointer (param_values + 0);
1292       data2 = closure-&gt;data;
1293     }
1294   callback = (GMarshalFunc_VOID__DOUBLE) (marshal_data ? marshal_data : cc-&gt;callback);
1295 
1296   callback (data1,
1297             g_marshal_value_peek_double (param_values + 1),
1298             data2);
1299 }
<span class="line-added">1300 </span>
<span class="line-added">1301 /**</span>
<span class="line-added">1302  * g_cclosure_marshal_VOID__DOUBLEv:</span>
<span class="line-added">1303  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">1304  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">1305  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">1306  *  value.</span>
<span class="line-added">1307  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">1308  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">1309  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">1310  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1311  *  g_closure_set_meta_marshal()</span>
<span class="line-added">1312  * @n_params: the length of the @param_types array</span>
<span class="line-added">1313  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">1314  *  @args.</span>
<span class="line-added">1315  *</span>
<span class="line-added">1316  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__DOUBLE().</span>
<span class="line-added">1317  */</span>
1318 void
1319 g_cclosure_marshal_VOID__DOUBLEv (GClosure     *closure,
1320                                   GValue       *return_value,
1321                                   gpointer      instance,
1322                                   va_list       args,
1323                                   gpointer      marshal_data,
1324                                   int           n_params,
1325                                   GType        *param_types)
1326 {
1327   typedef void (*GMarshalFunc_VOID__DOUBLE) (gpointer     instance,
1328                                              gdouble      arg_0,
1329                                              gpointer     data);
1330   GCClosure *cc = (GCClosure*) closure;
1331   gpointer data1, data2;
1332   GMarshalFunc_VOID__DOUBLE callback;
1333   gdouble arg0;
1334   va_list args_copy;
1335 
1336   G_VA_COPY (args_copy, args);
1337   arg0 = (gdouble) va_arg (args_copy, gdouble);
1338   va_end (args_copy);
1339 
1340   if (G_CCLOSURE_SWAP_DATA (closure))
1341     {
1342       data1 = closure-&gt;data;
1343       data2 = instance;
1344     }
1345   else
1346     {
1347       data1 = instance;
1348       data2 = closure-&gt;data;
1349     }
1350   callback = (GMarshalFunc_VOID__DOUBLE) (marshal_data ? marshal_data : cc-&gt;callback);
1351 
1352   callback (data1,
1353             arg0,
1354             data2);
1355 }
1356 
<span class="line-modified">1357 /**</span>
<span class="line-modified">1358  * g_cclosure_marshal_VOID__STRING:</span>
<span class="line-added">1359  * @closure: A #GClosure.</span>
<span class="line-added">1360  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">1361  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">1362  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">1363  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">1364  *   on which to invoke the callback of closure.</span>
<span class="line-added">1365  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">1366  *   g_closure_invoke().</span>
<span class="line-added">1367  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">1368  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1369  *   g_closure_set_meta_marshal()</span>
<span class="line-added">1370  *</span>
<span class="line-added">1371  * A #GClosureMarshal function for use with signals with a single string</span>
<span class="line-added">1372  * argument.</span>
<span class="line-added">1373  */</span>
<span class="line-added">1374 /* VOID:STRING */</span>
1375 void
1376 g_cclosure_marshal_VOID__STRING (GClosure     *closure,
1377                                  GValue       *return_value G_GNUC_UNUSED,
1378                                  guint         n_param_values,
1379                                  const GValue *param_values,
1380                                  gpointer      invocation_hint G_GNUC_UNUSED,
1381                                  gpointer      marshal_data)
1382 {
1383   typedef void (*GMarshalFunc_VOID__STRING) (gpointer     data1,
1384                                              gpointer     arg_1,
1385                                              gpointer     data2);
1386   GMarshalFunc_VOID__STRING callback;
1387   GCClosure *cc = (GCClosure*) closure;
1388   gpointer data1, data2;
1389 
1390   g_return_if_fail (n_param_values == 2);
1391 
1392   if (G_CCLOSURE_SWAP_DATA (closure))
1393     {
1394       data1 = closure-&gt;data;
1395       data2 = g_value_peek_pointer (param_values + 0);
1396     }
1397   else
1398     {
1399       data1 = g_value_peek_pointer (param_values + 0);
1400       data2 = closure-&gt;data;
1401     }
1402   callback = (GMarshalFunc_VOID__STRING) (marshal_data ? marshal_data : cc-&gt;callback);
1403 
1404   callback (data1,
1405             g_marshal_value_peek_string (param_values + 1),
1406             data2);
1407 }
<span class="line-added">1408 </span>
<span class="line-added">1409 /**</span>
<span class="line-added">1410  * g_cclosure_marshal_VOID__STRINGv:</span>
<span class="line-added">1411  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">1412  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">1413  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">1414  *  value.</span>
<span class="line-added">1415  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">1416  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">1417  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">1418  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1419  *  g_closure_set_meta_marshal()</span>
<span class="line-added">1420  * @n_params: the length of the @param_types array</span>
<span class="line-added">1421  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">1422  *  @args.</span>
<span class="line-added">1423  *</span>
<span class="line-added">1424  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__STRING().</span>
<span class="line-added">1425  */</span>
1426 void
1427 g_cclosure_marshal_VOID__STRINGv (GClosure     *closure,
1428                                   GValue       *return_value,
1429                                   gpointer      instance,
1430                                   va_list       args,
1431                                   gpointer      marshal_data,
1432                                   int           n_params,
1433                                   GType        *param_types)
1434 {
1435   typedef void (*GMarshalFunc_VOID__STRING) (gpointer     instance,
1436                                              gpointer     arg_0,
1437                                              gpointer     data);
1438   GCClosure *cc = (GCClosure*) closure;
1439   gpointer data1, data2;
1440   GMarshalFunc_VOID__STRING callback;
1441   gpointer arg0;
1442   va_list args_copy;
1443 
1444   G_VA_COPY (args_copy, args);
1445   arg0 = (gpointer) va_arg (args_copy, gpointer);
</pre>
<hr />
<pre>
1449 
1450   if (G_CCLOSURE_SWAP_DATA (closure))
1451     {
1452       data1 = closure-&gt;data;
1453       data2 = instance;
1454     }
1455   else
1456     {
1457       data1 = instance;
1458       data2 = closure-&gt;data;
1459     }
1460   callback = (GMarshalFunc_VOID__STRING) (marshal_data ? marshal_data : cc-&gt;callback);
1461 
1462   callback (data1,
1463             arg0,
1464             data2);
1465   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1466     g_free (arg0);
1467 }
1468 
<span class="line-modified">1469 /**</span>
<span class="line-modified">1470  * g_cclosure_marshal_VOID__PARAM:</span>
<span class="line-added">1471  * @closure: A #GClosure.</span>
<span class="line-added">1472  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">1473  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">1474  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">1475  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">1476  *   on which to invoke the callback of closure.</span>
<span class="line-added">1477  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">1478  *   g_closure_invoke().</span>
<span class="line-added">1479  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">1480  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1481  *   g_closure_set_meta_marshal()</span>
<span class="line-added">1482  *</span>
<span class="line-added">1483  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added">1484  * argument of type #GParamSpec.</span>
<span class="line-added">1485  */</span>
<span class="line-added">1486 /* VOID:PARAM */</span>
1487 void
1488 g_cclosure_marshal_VOID__PARAM (GClosure     *closure,
1489                                 GValue       *return_value G_GNUC_UNUSED,
1490                                 guint         n_param_values,
1491                                 const GValue *param_values,
1492                                 gpointer      invocation_hint G_GNUC_UNUSED,
1493                                 gpointer      marshal_data)
1494 {
1495   typedef void (*GMarshalFunc_VOID__PARAM) (gpointer     data1,
1496                                             gpointer     arg_1,
1497                                             gpointer     data2);
1498   GMarshalFunc_VOID__PARAM callback;
1499   GCClosure *cc = (GCClosure*) closure;
1500   gpointer data1, data2;
1501 
1502   g_return_if_fail (n_param_values == 2);
1503 
1504   if (G_CCLOSURE_SWAP_DATA (closure))
1505     {
1506       data1 = closure-&gt;data;
1507       data2 = g_value_peek_pointer (param_values + 0);
1508     }
1509   else
1510     {
1511       data1 = g_value_peek_pointer (param_values + 0);
1512       data2 = closure-&gt;data;
1513     }
1514   callback = (GMarshalFunc_VOID__PARAM) (marshal_data ? marshal_data : cc-&gt;callback);
1515 
1516   callback (data1,
1517             g_marshal_value_peek_param (param_values + 1),
1518             data2);
1519 }
<span class="line-added">1520 </span>
<span class="line-added">1521 /**</span>
<span class="line-added">1522  * g_cclosure_marshal_VOID__PARAMv:</span>
<span class="line-added">1523  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">1524  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">1525  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">1526  *  value.</span>
<span class="line-added">1527  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">1528  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">1529  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">1530  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1531  *  g_closure_set_meta_marshal()</span>
<span class="line-added">1532  * @n_params: the length of the @param_types array</span>
<span class="line-added">1533  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">1534  *  @args.</span>
<span class="line-added">1535  *</span>
<span class="line-added">1536  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__PARAM().</span>
<span class="line-added">1537  */</span>
1538 void
1539 g_cclosure_marshal_VOID__PARAMv (GClosure     *closure,
1540                                  GValue       *return_value,
1541                                  gpointer      instance,
1542                                  va_list       args,
1543                                  gpointer      marshal_data,
1544                                  int           n_params,
1545                                  GType        *param_types)
1546 {
1547   typedef void (*GMarshalFunc_VOID__PARAM) (gpointer     instance,
1548                                             gpointer     arg_0,
1549                                             gpointer     data);
1550   GCClosure *cc = (GCClosure*) closure;
1551   gpointer data1, data2;
1552   GMarshalFunc_VOID__PARAM callback;
1553   gpointer arg0;
1554   va_list args_copy;
1555 
1556   G_VA_COPY (args_copy, args);
1557   arg0 = (gpointer) va_arg (args_copy, gpointer);
</pre>
<hr />
<pre>
1561 
1562   if (G_CCLOSURE_SWAP_DATA (closure))
1563     {
1564       data1 = closure-&gt;data;
1565       data2 = instance;
1566     }
1567   else
1568     {
1569       data1 = instance;
1570       data2 = closure-&gt;data;
1571     }
1572   callback = (GMarshalFunc_VOID__PARAM) (marshal_data ? marshal_data : cc-&gt;callback);
1573 
1574   callback (data1,
1575             arg0,
1576             data2);
1577   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1578     g_param_spec_unref (arg0);
1579 }
1580 
<span class="line-modified">1581 /**</span>
<span class="line-modified">1582  * g_cclosure_marshal_VOID__BOXED:</span>
<span class="line-added">1583  * @closure: A #GClosure.</span>
<span class="line-added">1584  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">1585  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">1586  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">1587  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">1588  *   on which to invoke the callback of closure.</span>
<span class="line-added">1589  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">1590  *   g_closure_invoke().</span>
<span class="line-added">1591  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">1592  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1593  *   g_closure_set_meta_marshal()</span>
<span class="line-added">1594  *</span>
<span class="line-added">1595  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added">1596  * argument which is any boxed pointer type.</span>
<span class="line-added">1597  */</span>
<span class="line-added">1598 /* VOID:BOXED */</span>
1599 void
1600 g_cclosure_marshal_VOID__BOXED (GClosure     *closure,
1601                                 GValue       *return_value G_GNUC_UNUSED,
1602                                 guint         n_param_values,
1603                                 const GValue *param_values,
1604                                 gpointer      invocation_hint G_GNUC_UNUSED,
1605                                 gpointer      marshal_data)
1606 {
1607   typedef void (*GMarshalFunc_VOID__BOXED) (gpointer     data1,
1608                                             gpointer     arg_1,
1609                                             gpointer     data2);
1610   GMarshalFunc_VOID__BOXED callback;
1611   GCClosure *cc = (GCClosure*) closure;
1612   gpointer data1, data2;
1613 
1614   g_return_if_fail (n_param_values == 2);
1615 
1616   if (G_CCLOSURE_SWAP_DATA (closure))
1617     {
1618       data1 = closure-&gt;data;
1619       data2 = g_value_peek_pointer (param_values + 0);
1620     }
1621   else
1622     {
1623       data1 = g_value_peek_pointer (param_values + 0);
1624       data2 = closure-&gt;data;
1625     }
1626   callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
1627 
1628   callback (data1,
1629             g_marshal_value_peek_boxed (param_values + 1),
1630             data2);
1631 }
<span class="line-added">1632 </span>
<span class="line-added">1633 /**</span>
<span class="line-added">1634  * g_cclosure_marshal_VOID__BOXEDv:</span>
<span class="line-added">1635  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">1636  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">1637  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">1638  *  value.</span>
<span class="line-added">1639  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">1640  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">1641  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">1642  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1643  *  g_closure_set_meta_marshal()</span>
<span class="line-added">1644  * @n_params: the length of the @param_types array</span>
<span class="line-added">1645  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">1646  *  @args.</span>
<span class="line-added">1647  *</span>
<span class="line-added">1648  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__BOXED().</span>
<span class="line-added">1649  */</span>
1650 void
1651 g_cclosure_marshal_VOID__BOXEDv (GClosure     *closure,
1652                                  GValue       *return_value,
1653                                  gpointer      instance,
1654                                  va_list       args,
1655                                  gpointer      marshal_data,
1656                                  int           n_params,
1657                                  GType        *param_types)
1658 {
1659   typedef void (*GMarshalFunc_VOID__BOXED) (gpointer     instance,
1660                                             gpointer     arg_0,
1661                                             gpointer     data);
1662   GCClosure *cc = (GCClosure*) closure;
1663   gpointer data1, data2;
1664   GMarshalFunc_VOID__BOXED callback;
1665   gpointer arg0;
1666   va_list args_copy;
1667 
1668   G_VA_COPY (args_copy, args);
1669   arg0 = (gpointer) va_arg (args_copy, gpointer);
</pre>
<hr />
<pre>
1673 
1674   if (G_CCLOSURE_SWAP_DATA (closure))
1675     {
1676       data1 = closure-&gt;data;
1677       data2 = instance;
1678     }
1679   else
1680     {
1681       data1 = instance;
1682       data2 = closure-&gt;data;
1683     }
1684   callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
1685 
1686   callback (data1,
1687             arg0,
1688             data2);
1689   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1690     g_boxed_free (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
1691 }
1692 
<span class="line-modified">1693 /**</span>
<span class="line-modified">1694  * g_cclosure_marshal_VOID__POINTER:</span>
<span class="line-added">1695  * @closure: A #GClosure.</span>
<span class="line-added">1696  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">1697  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">1698  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">1699  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">1700  *   on which to invoke the callback of closure.</span>
<span class="line-added">1701  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">1702  *   g_closure_invoke().</span>
<span class="line-added">1703  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">1704  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1705  *   g_closure_set_meta_marshal()</span>
<span class="line-added">1706  *</span>
<span class="line-added">1707  * A #GClosureMarshal function for use with signals with a single raw</span>
<span class="line-added">1708  * pointer argument type.</span>
<span class="line-added">1709  *</span>
<span class="line-added">1710  * If it is possible, it is better to use one of the more specific</span>
<span class="line-added">1711  * functions such as g_cclosure_marshal_VOID__OBJECT() or</span>
<span class="line-added">1712  * g_cclosure_marshal_VOID__OBJECT().</span>
<span class="line-added">1713  */</span>
<span class="line-added">1714 /* VOID:POINTER */</span>
1715 void
1716 g_cclosure_marshal_VOID__POINTER (GClosure     *closure,
1717                                   GValue       *return_value G_GNUC_UNUSED,
1718                                   guint         n_param_values,
1719                                   const GValue *param_values,
1720                                   gpointer      invocation_hint G_GNUC_UNUSED,
1721                                   gpointer      marshal_data)
1722 {
1723   typedef void (*GMarshalFunc_VOID__POINTER) (gpointer     data1,
1724                                               gpointer     arg_1,
1725                                               gpointer     data2);
1726   GMarshalFunc_VOID__POINTER callback;
1727   GCClosure *cc = (GCClosure*) closure;
1728   gpointer data1, data2;
1729 
1730   g_return_if_fail (n_param_values == 2);
1731 
1732   if (G_CCLOSURE_SWAP_DATA (closure))
1733     {
1734       data1 = closure-&gt;data;
1735       data2 = g_value_peek_pointer (param_values + 0);
1736     }
1737   else
1738     {
1739       data1 = g_value_peek_pointer (param_values + 0);
1740       data2 = closure-&gt;data;
1741     }
1742   callback = (GMarshalFunc_VOID__POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
1743 
1744   callback (data1,
1745             g_marshal_value_peek_pointer (param_values + 1),
1746             data2);
1747 }
<span class="line-added">1748 </span>
<span class="line-added">1749 /**</span>
<span class="line-added">1750  * g_cclosure_marshal_VOID__POINTERv:</span>
<span class="line-added">1751  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">1752  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">1753  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">1754  *  value.</span>
<span class="line-added">1755  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">1756  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">1757  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">1758  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1759  *  g_closure_set_meta_marshal()</span>
<span class="line-added">1760  * @n_params: the length of the @param_types array</span>
<span class="line-added">1761  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">1762  *  @args.</span>
<span class="line-added">1763  *</span>
<span class="line-added">1764  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__POINTER().</span>
<span class="line-added">1765  */</span>
1766 void
1767 g_cclosure_marshal_VOID__POINTERv (GClosure     *closure,
1768                                    GValue       *return_value,
1769                                    gpointer      instance,
1770                                    va_list       args,
1771                                    gpointer      marshal_data,
1772                                    int           n_params,
1773                                    GType        *param_types)
1774 {
1775   typedef void (*GMarshalFunc_VOID__POINTER) (gpointer     instance,
1776                                               gpointer     arg_0,
1777                                               gpointer     data);
1778   GCClosure *cc = (GCClosure*) closure;
1779   gpointer data1, data2;
1780   GMarshalFunc_VOID__POINTER callback;
1781   gpointer arg0;
1782   va_list args_copy;
1783 
1784   G_VA_COPY (args_copy, args);
1785   arg0 = (gpointer) va_arg (args_copy, gpointer);
1786   va_end (args_copy);
1787 
1788   if (G_CCLOSURE_SWAP_DATA (closure))
1789     {
1790       data1 = closure-&gt;data;
1791       data2 = instance;
1792     }
1793   else
1794     {
1795       data1 = instance;
1796       data2 = closure-&gt;data;
1797     }
1798   callback = (GMarshalFunc_VOID__POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
1799 
1800   callback (data1,
1801             arg0,
1802             data2);
1803 }
1804 
<span class="line-modified">1805 /**</span>
<span class="line-modified">1806  * g_cclosure_marshal_VOID__OBJECT:</span>
<span class="line-added">1807  * @closure: A #GClosure.</span>
<span class="line-added">1808  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">1809  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">1810  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">1811  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">1812  *   on which to invoke the callback of closure.</span>
<span class="line-added">1813  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">1814  *   g_closure_invoke().</span>
<span class="line-added">1815  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">1816  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1817  *   g_closure_set_meta_marshal()</span>
<span class="line-added">1818  *</span>
<span class="line-added">1819  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added">1820  * #GObject argument.</span>
<span class="line-added">1821  */</span>
<span class="line-added">1822 /* VOID:OBJECT */</span>
1823 void
1824 g_cclosure_marshal_VOID__OBJECT (GClosure     *closure,
1825                                  GValue       *return_value G_GNUC_UNUSED,
1826                                  guint         n_param_values,
1827                                  const GValue *param_values,
1828                                  gpointer      invocation_hint G_GNUC_UNUSED,
1829                                  gpointer      marshal_data)
1830 {
1831   typedef void (*GMarshalFunc_VOID__OBJECT) (gpointer     data1,
1832                                              gpointer     arg_1,
1833                                              gpointer     data2);
1834   GMarshalFunc_VOID__OBJECT callback;
1835   GCClosure *cc = (GCClosure*) closure;
1836   gpointer data1, data2;
1837 
1838   g_return_if_fail (n_param_values == 2);
1839 
1840   if (G_CCLOSURE_SWAP_DATA (closure))
1841     {
1842       data1 = closure-&gt;data;
1843       data2 = g_value_peek_pointer (param_values + 0);
1844     }
1845   else
1846     {
1847       data1 = g_value_peek_pointer (param_values + 0);
1848       data2 = closure-&gt;data;
1849     }
1850   callback = (GMarshalFunc_VOID__OBJECT) (marshal_data ? marshal_data : cc-&gt;callback);
1851 
1852   callback (data1,
1853             g_marshal_value_peek_object (param_values + 1),
1854             data2);
1855 }
<span class="line-added">1856 </span>
<span class="line-added">1857 /**</span>
<span class="line-added">1858  * g_cclosure_marshal_VOID__OBJECTv:</span>
<span class="line-added">1859  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">1860  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">1861  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">1862  *  value.</span>
<span class="line-added">1863  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">1864  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">1865  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">1866  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1867  *  g_closure_set_meta_marshal()</span>
<span class="line-added">1868  * @n_params: the length of the @param_types array</span>
<span class="line-added">1869  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">1870  *  @args.</span>
<span class="line-added">1871  *</span>
<span class="line-added">1872  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__OBJECT().</span>
<span class="line-added">1873  */</span>
1874 void
1875 g_cclosure_marshal_VOID__OBJECTv (GClosure     *closure,
1876                                   GValue       *return_value,
1877                                   gpointer      instance,
1878                                   va_list       args,
1879                                   gpointer      marshal_data,
1880                                   int           n_params,
1881                                   GType        *param_types)
1882 {
1883   typedef void (*GMarshalFunc_VOID__OBJECT) (gpointer     instance,
1884                                              gpointer     arg_0,
1885                                              gpointer     data);
1886   GCClosure *cc = (GCClosure*) closure;
1887   gpointer data1, data2;
1888   GMarshalFunc_VOID__OBJECT callback;
1889   gpointer arg0;
1890   va_list args_copy;
1891 
1892   G_VA_COPY (args_copy, args);
1893   arg0 = (gpointer) va_arg (args_copy, gpointer);
</pre>
<hr />
<pre>
1897 
1898   if (G_CCLOSURE_SWAP_DATA (closure))
1899     {
1900       data1 = closure-&gt;data;
1901       data2 = instance;
1902     }
1903   else
1904     {
1905       data1 = instance;
1906       data2 = closure-&gt;data;
1907     }
1908   callback = (GMarshalFunc_VOID__OBJECT) (marshal_data ? marshal_data : cc-&gt;callback);
1909 
1910   callback (data1,
1911             arg0,
1912             data2);
1913   if (arg0 != NULL)
1914     g_object_unref (arg0);
1915 }
1916 
<span class="line-modified">1917 /**</span>
<span class="line-modified">1918  * g_cclosure_marshal_VOID__VARIANT:</span>
<span class="line-added">1919  * @closure: A #GClosure.</span>
<span class="line-added">1920  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">1921  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">1922  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">1923  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">1924  *   on which to invoke the callback of closure.</span>
<span class="line-added">1925  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">1926  *   g_closure_invoke().</span>
<span class="line-added">1927  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">1928  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1929  *   g_closure_set_meta_marshal()</span>
<span class="line-added">1930  *</span>
<span class="line-added">1931  * A #GClosureMarshal function for use with signals with a single</span>
<span class="line-added">1932  * #GVariant argument.</span>
<span class="line-added">1933  */</span>
<span class="line-added">1934 /* VOID:VARIANT */</span>
1935 void
1936 g_cclosure_marshal_VOID__VARIANT (GClosure     *closure,
1937                                   GValue       *return_value G_GNUC_UNUSED,
1938                                   guint         n_param_values,
1939                                   const GValue *param_values,
1940                                   gpointer      invocation_hint G_GNUC_UNUSED,
1941                                   gpointer      marshal_data)
1942 {
1943   typedef void (*GMarshalFunc_VOID__VARIANT) (gpointer     data1,
1944                                               gpointer     arg_1,
1945                                               gpointer     data2);
1946   GMarshalFunc_VOID__VARIANT callback;
1947   GCClosure *cc = (GCClosure*) closure;
1948   gpointer data1, data2;
1949 
1950   g_return_if_fail (n_param_values == 2);
1951 
1952   if (G_CCLOSURE_SWAP_DATA (closure))
1953     {
1954       data1 = closure-&gt;data;
1955       data2 = g_value_peek_pointer (param_values + 0);
1956     }
1957   else
1958     {
1959       data1 = g_value_peek_pointer (param_values + 0);
1960       data2 = closure-&gt;data;
1961     }
1962   callback = (GMarshalFunc_VOID__VARIANT) (marshal_data ? marshal_data : cc-&gt;callback);
1963 
1964   callback (data1,
1965             g_marshal_value_peek_variant (param_values + 1),
1966             data2);
1967 }
<span class="line-added">1968 </span>
<span class="line-added">1969 /**</span>
<span class="line-added">1970  * g_cclosure_marshal_VOID__VARIANTv:</span>
<span class="line-added">1971  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">1972  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">1973  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">1974  *  value.</span>
<span class="line-added">1975  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">1976  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">1977  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">1978  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">1979  *  g_closure_set_meta_marshal()</span>
<span class="line-added">1980  * @n_params: the length of the @param_types array</span>
<span class="line-added">1981  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">1982  *  @args.</span>
<span class="line-added">1983  *</span>
<span class="line-added">1984  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__VARIANT().</span>
<span class="line-added">1985  */</span>
1986 void
1987 g_cclosure_marshal_VOID__VARIANTv (GClosure     *closure,
1988                                    GValue       *return_value,
1989                                    gpointer      instance,
1990                                    va_list       args,
1991                                    gpointer      marshal_data,
1992                                    int           n_params,
1993                                    GType        *param_types)
1994 {
1995   typedef void (*GMarshalFunc_VOID__VARIANT) (gpointer     instance,
1996                                               gpointer     arg_0,
1997                                               gpointer     data);
1998   GCClosure *cc = (GCClosure*) closure;
1999   gpointer data1, data2;
2000   GMarshalFunc_VOID__VARIANT callback;
2001   gpointer arg0;
2002   va_list args_copy;
2003 
2004   G_VA_COPY (args_copy, args);
2005   arg0 = (gpointer) va_arg (args_copy, gpointer);
</pre>
<hr />
<pre>
2009 
2010   if (G_CCLOSURE_SWAP_DATA (closure))
2011     {
2012       data1 = closure-&gt;data;
2013       data2 = instance;
2014     }
2015   else
2016     {
2017       data1 = instance;
2018       data2 = closure-&gt;data;
2019     }
2020   callback = (GMarshalFunc_VOID__VARIANT) (marshal_data ? marshal_data : cc-&gt;callback);
2021 
2022   callback (data1,
2023             arg0,
2024             data2);
2025   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2026     g_variant_unref (arg0);
2027 }
2028 
<span class="line-modified">2029 /**</span>
<span class="line-modified">2030  * g_cclosure_marshal_VOID__UINT_POINTER:</span>
<span class="line-added">2031  * @closure: A #GClosure.</span>
<span class="line-added">2032  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">2033  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">2034  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">2035  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">2036  *   on which to invoke the callback of closure.</span>
<span class="line-added">2037  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">2038  *   g_closure_invoke().</span>
<span class="line-added">2039  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">2040  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">2041  *   g_closure_set_meta_marshal()</span>
<span class="line-added">2042  *</span>
<span class="line-added">2043  * A #GClosureMarshal function for use with signals with an unsigned int</span>
<span class="line-added">2044  * and a pointer as arguments.</span>
<span class="line-added">2045  */</span>
<span class="line-added">2046 /* VOID:UINT,POINTER */</span>
2047 void
2048 g_cclosure_marshal_VOID__UINT_POINTER (GClosure     *closure,
2049                                        GValue       *return_value G_GNUC_UNUSED,
2050                                        guint         n_param_values,
2051                                        const GValue *param_values,
2052                                        gpointer      invocation_hint G_GNUC_UNUSED,
2053                                        gpointer      marshal_data)
2054 {
2055   typedef void (*GMarshalFunc_VOID__UINT_POINTER) (gpointer     data1,
2056                                                    guint        arg_1,
2057                                                    gpointer     arg_2,
2058                                                    gpointer     data2);
2059   GMarshalFunc_VOID__UINT_POINTER callback;
2060   GCClosure *cc = (GCClosure*) closure;
2061   gpointer data1, data2;
2062 
2063   g_return_if_fail (n_param_values == 3);
2064 
2065   if (G_CCLOSURE_SWAP_DATA (closure))
2066     {
2067       data1 = closure-&gt;data;
2068       data2 = g_value_peek_pointer (param_values + 0);
2069     }
2070   else
2071     {
2072       data1 = g_value_peek_pointer (param_values + 0);
2073       data2 = closure-&gt;data;
2074     }
2075   callback = (GMarshalFunc_VOID__UINT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2076 
2077   callback (data1,
2078             g_marshal_value_peek_uint (param_values + 1),
2079             g_marshal_value_peek_pointer (param_values + 2),
2080             data2);
2081 }
<span class="line-added">2082 </span>
<span class="line-added">2083 /**</span>
<span class="line-added">2084  * g_cclosure_marshal_VOID__UINT_POINTERv:</span>
<span class="line-added">2085  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">2086  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">2087  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">2088  *  value.</span>
<span class="line-added">2089  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">2090  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">2091  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">2092  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">2093  *  g_closure_set_meta_marshal()</span>
<span class="line-added">2094  * @n_params: the length of the @param_types array</span>
<span class="line-added">2095  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">2096  *  @args.</span>
<span class="line-added">2097  *</span>
<span class="line-added">2098  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UINT_POINTER().</span>
<span class="line-added">2099  */</span>
2100 void
2101 g_cclosure_marshal_VOID__UINT_POINTERv (GClosure     *closure,
2102                                         GValue       *return_value,
2103                                         gpointer      instance,
2104                                         va_list       args,
2105                                         gpointer      marshal_data,
2106                                         int           n_params,
2107                                         GType        *param_types)
2108 {
2109   typedef void (*GMarshalFunc_VOID__UINT_POINTER) (gpointer     instance,
2110                                                    guint        arg_0,
2111                                                    gpointer     arg_1,
2112                                                    gpointer     data);
2113   GCClosure *cc = (GCClosure*) closure;
2114   gpointer data1, data2;
2115   GMarshalFunc_VOID__UINT_POINTER callback;
2116   guint arg0;
2117   gpointer arg1;
2118   va_list args_copy;
2119 
</pre>
<hr />
<pre>
2123   va_end (args_copy);
2124 
2125   if (G_CCLOSURE_SWAP_DATA (closure))
2126     {
2127       data1 = closure-&gt;data;
2128       data2 = instance;
2129     }
2130   else
2131     {
2132       data1 = instance;
2133       data2 = closure-&gt;data;
2134     }
2135   callback = (GMarshalFunc_VOID__UINT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2136 
2137   callback (data1,
2138             arg0,
2139             arg1,
2140             data2);
2141 }
2142 
<span class="line-modified">2143 /**</span>
<span class="line-modified">2144  * g_cclosure_marshal_BOOLEAN__FLAGS:</span>
<span class="line-added">2145  * @closure: A #GClosure.</span>
<span class="line-added">2146  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">2147  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">2148  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">2149  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">2150  *   on which to invoke the callback of closure.</span>
<span class="line-added">2151  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">2152  *   g_closure_invoke().</span>
<span class="line-added">2153  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">2154  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">2155  *   g_closure_set_meta_marshal()</span>
<span class="line-added">2156  *</span>
<span class="line-added">2157  * A #GClosureMarshal function for use with signals with handlers that</span>
<span class="line-added">2158  * take a flags type as an argument and return a boolean.  If you have</span>
<span class="line-added">2159  * such a signal, you will probably also need to use an accumulator,</span>
<span class="line-added">2160  * such as g_signal_accumulator_true_handled().</span>
<span class="line-added">2161  */</span>
<span class="line-added">2162 /* BOOL:FLAGS */</span>
2163 void
2164 g_cclosure_marshal_BOOLEAN__FLAGS (GClosure     *closure,
2165                                    GValue       *return_value G_GNUC_UNUSED,
2166                                    guint         n_param_values,
2167                                    const GValue *param_values,
2168                                    gpointer      invocation_hint G_GNUC_UNUSED,
2169                                    gpointer      marshal_data)
2170 {
2171   typedef gboolean (*GMarshalFunc_BOOLEAN__FLAGS) (gpointer     data1,
2172                                                    guint        arg_1,
2173                                                    gpointer     data2);
2174   GMarshalFunc_BOOLEAN__FLAGS callback;
2175   GCClosure *cc = (GCClosure*) closure;
2176   gpointer data1, data2;
2177   gboolean v_return;
2178 
2179   g_return_if_fail (return_value != NULL);
2180   g_return_if_fail (n_param_values == 2);
2181 
2182   if (G_CCLOSURE_SWAP_DATA (closure))
2183     {
2184       data1 = closure-&gt;data;
2185       data2 = g_value_peek_pointer (param_values + 0);
2186     }
2187   else
2188     {
2189       data1 = g_value_peek_pointer (param_values + 0);
2190       data2 = closure-&gt;data;
2191     }
2192   callback = (GMarshalFunc_BOOLEAN__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
2193 
2194   v_return = callback (data1,
2195                        g_marshal_value_peek_flags (param_values + 1),
2196                        data2);
2197 
2198   g_value_set_boolean (return_value, v_return);
2199 }
<span class="line-added">2200 </span>
<span class="line-added">2201 /**</span>
<span class="line-added">2202  * g_cclosure_marshal_BOOLEAN__FLAGSv:</span>
<span class="line-added">2203  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">2204  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">2205  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">2206  *  value.</span>
<span class="line-added">2207  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">2208  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">2209  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">2210  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">2211  *  g_closure_set_meta_marshal()</span>
<span class="line-added">2212  * @n_params: the length of the @param_types array</span>
<span class="line-added">2213  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">2214  *  @args.</span>
<span class="line-added">2215  *</span>
<span class="line-added">2216  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_BOOLEAN__FLAGS().</span>
<span class="line-added">2217  */</span>
2218 void
2219 g_cclosure_marshal_BOOLEAN__FLAGSv (GClosure     *closure,
2220                                     GValue       *return_value,
2221                                     gpointer      instance,
2222                                     va_list       args,
2223                                     gpointer      marshal_data,
2224                                     int           n_params,
2225                                     GType        *param_types)
2226 {
2227   typedef gboolean (*GMarshalFunc_BOOLEAN__FLAGS) (gpointer     instance,
2228                                                    guint        arg_0,
2229                                                    gpointer     data);
2230   GCClosure *cc = (GCClosure*) closure;
2231   gpointer data1, data2;
2232   GMarshalFunc_BOOLEAN__FLAGS callback;
2233   guint arg0;
2234   va_list args_copy;
2235   gboolean v_return;
2236 
2237   g_return_if_fail (return_value != NULL);
</pre>
<hr />
<pre>
2242 
2243   if (G_CCLOSURE_SWAP_DATA (closure))
2244     {
2245       data1 = closure-&gt;data;
2246       data2 = instance;
2247     }
2248   else
2249     {
2250       data1 = instance;
2251       data2 = closure-&gt;data;
2252     }
2253   callback = (GMarshalFunc_BOOLEAN__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
2254 
2255   v_return = callback (data1,
2256                        arg0,
2257                        data2);
2258 
2259   g_value_set_boolean (return_value, v_return);
2260 }
2261 
<span class="line-modified">2262 /**</span>
<span class="line-modified">2263  * g_cclosure_marshal_STRING__OBJECT_POINTER:</span>
<span class="line-added">2264  * @closure: A #GClosure.</span>
<span class="line-added">2265  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">2266  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">2267  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">2268  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">2269  *   on which to invoke the callback of closure.</span>
<span class="line-added">2270  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">2271  *   g_closure_invoke().</span>
<span class="line-added">2272  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">2273  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">2274  *   g_closure_set_meta_marshal()</span>
<span class="line-added">2275  *</span>
<span class="line-added">2276  * A #GClosureMarshal function for use with signals with handlers that</span>
<span class="line-added">2277  * take a #GObject and a pointer and produce a string.  It is highly</span>
<span class="line-added">2278  * unlikely that your signal handler fits this description.</span>
<span class="line-added">2279  */</span>
<span class="line-added">2280 /* STRING:OBJECT,POINTER */</span>
2281 void
2282 g_cclosure_marshal_STRING__OBJECT_POINTER (GClosure     *closure,
2283                                            GValue       *return_value G_GNUC_UNUSED,
2284                                            guint         n_param_values,
2285                                            const GValue *param_values,
2286                                            gpointer      invocation_hint G_GNUC_UNUSED,
2287                                            gpointer      marshal_data)
2288 {
2289   typedef gchar* (*GMarshalFunc_STRING__OBJECT_POINTER) (gpointer     data1,
2290                                                          gpointer     arg_1,
2291                                                          gpointer     arg_2,
2292                                                          gpointer     data2);
2293   GMarshalFunc_STRING__OBJECT_POINTER callback;
2294   GCClosure *cc = (GCClosure*) closure;
2295   gpointer data1, data2;
2296   gchar* v_return;
2297 
2298   g_return_if_fail (return_value != NULL);
2299   g_return_if_fail (n_param_values == 3);
2300 
2301   if (G_CCLOSURE_SWAP_DATA (closure))
2302     {
2303       data1 = closure-&gt;data;
2304       data2 = g_value_peek_pointer (param_values + 0);
2305     }
2306   else
2307     {
2308       data1 = g_value_peek_pointer (param_values + 0);
2309       data2 = closure-&gt;data;
2310     }
2311   callback = (GMarshalFunc_STRING__OBJECT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2312 
2313   v_return = callback (data1,
2314                        g_marshal_value_peek_object (param_values + 1),
2315                        g_marshal_value_peek_pointer (param_values + 2),
2316                        data2);
2317 
2318   g_value_take_string (return_value, v_return);
2319 }
<span class="line-added">2320 </span>
<span class="line-added">2321 /**</span>
<span class="line-added">2322  * g_cclosure_marshal_STRING__OBJECT_POINTERv:</span>
<span class="line-added">2323  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">2324  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">2325  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">2326  *  value.</span>
<span class="line-added">2327  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">2328  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">2329  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">2330  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">2331  *  g_closure_set_meta_marshal()</span>
<span class="line-added">2332  * @n_params: the length of the @param_types array</span>
<span class="line-added">2333  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">2334  *  @args.</span>
<span class="line-added">2335  *</span>
<span class="line-added">2336  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_STRING__OBJECT_POINTER().</span>
<span class="line-added">2337  */</span>
2338 void
2339 g_cclosure_marshal_STRING__OBJECT_POINTERv (GClosure     *closure,
2340                                             GValue       *return_value,
2341                                             gpointer      instance,
2342                                             va_list       args,
2343                                             gpointer      marshal_data,
2344                                             int           n_params,
2345                                             GType        *param_types)
2346 {
2347   typedef gchar* (*GMarshalFunc_STRING__OBJECT_POINTER) (gpointer     instance,
2348                                                          gpointer     arg_0,
2349                                                          gpointer     arg_1,
2350                                                          gpointer     data);
2351   GCClosure *cc = (GCClosure*) closure;
2352   gpointer data1, data2;
2353   GMarshalFunc_STRING__OBJECT_POINTER callback;
2354   gpointer arg0;
2355   gpointer arg1;
2356   va_list args_copy;
2357   gchar* v_return;
</pre>
<hr />
<pre>
2370       data1 = closure-&gt;data;
2371       data2 = instance;
2372     }
2373   else
2374     {
2375       data1 = instance;
2376       data2 = closure-&gt;data;
2377     }
2378   callback = (GMarshalFunc_STRING__OBJECT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2379 
2380   v_return = callback (data1,
2381                        arg0,
2382                        arg1,
2383                        data2);
2384   if (arg0 != NULL)
2385     g_object_unref (arg0);
2386 
2387   g_value_take_string (return_value, v_return);
2388 }
2389 
<span class="line-modified">2390 /**</span>
<span class="line-modified">2391  * g_cclosure_marshal_BOOLEAN__BOXED_BOXED:</span>
<span class="line-added">2392  * @closure: A #GClosure.</span>
<span class="line-added">2393  * @return_value: A #GValue to store the return value. May be %NULL</span>
<span class="line-added">2394  *   if the callback of closure doesn&#39;t return a value.</span>
<span class="line-added">2395  * @n_param_values: The length of the @param_values array.</span>
<span class="line-added">2396  * @param_values: An array of #GValues holding the arguments</span>
<span class="line-added">2397  *   on which to invoke the callback of closure.</span>
<span class="line-added">2398  * @invocation_hint: The invocation hint given as the last argument to</span>
<span class="line-added">2399  *   g_closure_invoke().</span>
<span class="line-added">2400  * @marshal_data: Additional data specified when registering the</span>
<span class="line-added">2401  *   marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">2402  *   g_closure_set_meta_marshal()</span>
<span class="line-added">2403  *</span>
<span class="line-added">2404  * A #GClosureMarshal function for use with signals with handlers that</span>
<span class="line-added">2405  * take two boxed pointers as arguments and return a boolean.  If you</span>
<span class="line-added">2406  * have such a signal, you will probably also need to use an</span>
<span class="line-added">2407  * accumulator, such as g_signal_accumulator_true_handled().</span>
<span class="line-added">2408  */</span>
<span class="line-added">2409 /* BOOL:BOXED,BOXED */</span>
2410 void
2411 g_cclosure_marshal_BOOLEAN__BOXED_BOXED (GClosure     *closure,
2412                                          GValue       *return_value G_GNUC_UNUSED,
2413                                          guint         n_param_values,
2414                                          const GValue *param_values,
2415                                          gpointer      invocation_hint G_GNUC_UNUSED,
2416                                          gpointer      marshal_data)
2417 {
2418   typedef gboolean (*GMarshalFunc_BOOLEAN__BOXED_BOXED) (gpointer     data1,
2419                                                          gpointer     arg_1,
2420                                                          gpointer     arg_2,
2421                                                          gpointer     data2);
2422   GMarshalFunc_BOOLEAN__BOXED_BOXED callback;
2423   GCClosure *cc = (GCClosure*) closure;
2424   gpointer data1, data2;
2425   gboolean v_return;
2426 
2427   g_return_if_fail (return_value != NULL);
2428   g_return_if_fail (n_param_values == 3);
2429 
2430   if (G_CCLOSURE_SWAP_DATA (closure))
2431     {
2432       data1 = closure-&gt;data;
2433       data2 = g_value_peek_pointer (param_values + 0);
2434     }
2435   else
2436     {
2437       data1 = g_value_peek_pointer (param_values + 0);
2438       data2 = closure-&gt;data;
2439     }
2440   callback = (GMarshalFunc_BOOLEAN__BOXED_BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
2441 
2442   v_return = callback (data1,
2443                        g_marshal_value_peek_boxed (param_values + 1),
2444                        g_marshal_value_peek_boxed (param_values + 2),
2445                        data2);
2446 
2447   g_value_set_boolean (return_value, v_return);
2448 }
<span class="line-added">2449 </span>
<span class="line-added">2450 /**</span>
<span class="line-added">2451  * g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv:</span>
<span class="line-added">2452  * @closure: the #GClosure to which the marshaller belongs</span>
<span class="line-added">2453  * @return_value: (nullable): a #GValue to store the return</span>
<span class="line-added">2454  *  value. May be %NULL if the callback of @closure doesn&#39;t return a</span>
<span class="line-added">2455  *  value.</span>
<span class="line-added">2456  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.</span>
<span class="line-added">2457  * @args: va_list of arguments to be passed to the closure.</span>
<span class="line-added">2458  * @marshal_data: (nullable): additional data specified when</span>
<span class="line-added">2459  *  registering the marshaller, see g_closure_set_marshal() and</span>
<span class="line-added">2460  *  g_closure_set_meta_marshal()</span>
<span class="line-added">2461  * @n_params: the length of the @param_types array</span>
<span class="line-added">2462  * @param_types: (array length=n_params): the #GType of each argument from</span>
<span class="line-added">2463  *  @args.</span>
<span class="line-added">2464  *</span>
<span class="line-added">2465  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_BOOLEAN__BOXED_BOXED().</span>
<span class="line-added">2466  */</span>
2467 void
2468 g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv (GClosure     *closure,
2469                                           GValue       *return_value,
2470                                           gpointer      instance,
2471                                           va_list       args,
2472                                           gpointer      marshal_data,
2473                                           int           n_params,
2474                                           GType        *param_types)
2475 {
2476   typedef gboolean (*GMarshalFunc_BOOLEAN__BOXED_BOXED) (gpointer     instance,
2477                                                          gpointer     arg_0,
2478                                                          gpointer     arg_1,
2479                                                          gpointer     data);
2480   GCClosure *cc = (GCClosure*) closure;
2481   gpointer data1, data2;
2482   GMarshalFunc_BOOLEAN__BOXED_BOXED callback;
2483   gpointer arg0;
2484   gpointer arg1;
2485   va_list args_copy;
2486   gboolean v_return;
</pre>
<hr />
<pre>
2502       data2 = instance;
2503     }
2504   else
2505     {
2506       data1 = instance;
2507       data2 = closure-&gt;data;
2508     }
2509   callback = (GMarshalFunc_BOOLEAN__BOXED_BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
2510 
2511   v_return = callback (data1,
2512                        arg0,
2513                        arg1,
2514                        data2);
2515   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2516     g_boxed_free (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
2517   if ((param_types[1] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg1 != NULL)
2518     g_boxed_free (param_types[1] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
2519 
2520   g_value_set_boolean (return_value, v_return);
2521 }


</pre>
</td>
</tr>
</table>
<center><a href="genums.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gmarshal.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>