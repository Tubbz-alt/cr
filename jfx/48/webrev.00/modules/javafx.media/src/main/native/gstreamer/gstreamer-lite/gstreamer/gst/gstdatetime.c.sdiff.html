<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstdatetime.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstcontrolbinding.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstdebugutils.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstdatetime.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
179 
180 /**
181  * gst_date_time_has_second:
182  * @datetime: a #GstDateTime
183  *
184  * Returns: %TRUE if @datetime&lt;!-- --&gt;&#39;s second field is set, otherwise %FALSE
185  */
186 gboolean
187 gst_date_time_has_second (const GstDateTime * datetime)
188 {
189   g_return_val_if_fail (datetime != NULL, FALSE);
190 
191   return (datetime-&gt;fields &gt;= GST_DATE_TIME_FIELDS_YMD_HMS);
192 }
193 
194 /**
195  * gst_date_time_get_year:
196  * @datetime: a #GstDateTime
197  *
198  * Returns the year of this #GstDateTime
<span class="line-modified">199  * Call gst_date_time_has_year before, to avoid warnings.</span>
200  *
201  * Return value: The year of this #GstDateTime
202  */
203 gint
204 gst_date_time_get_year (const GstDateTime * datetime)
205 {
206   g_return_val_if_fail (datetime != NULL, 0);
207 
208   return g_date_time_get_year (datetime-&gt;datetime);
209 }
210 
211 /**
212  * gst_date_time_get_month:
213  * @datetime: a #GstDateTime
214  *
215  * Returns the month of this #GstDateTime. January is 1, February is 2, etc..
<span class="line-modified">216  * Call gst_date_time_has_month before, to avoid warnings.</span>
217  *
218  * Return value: The month of this #GstDateTime
219  */
220 gint
221 gst_date_time_get_month (const GstDateTime * datetime)
222 {
223   g_return_val_if_fail (datetime != NULL, 0);
224   g_return_val_if_fail (gst_date_time_has_month (datetime), 0);
225 
226   return g_date_time_get_month (datetime-&gt;datetime);
227 }
228 
229 /**
230  * gst_date_time_get_day:
231  * @datetime: a #GstDateTime
232  *
233  * Returns the day of the month of this #GstDateTime.
<span class="line-modified">234  * Call gst_date_time_has_day before, to avoid warnings.</span>
235  *
236  * Return value: The day of this #GstDateTime
237  */
238 gint
239 gst_date_time_get_day (const GstDateTime * datetime)
240 {
241   g_return_val_if_fail (datetime != NULL, 0);
242   g_return_val_if_fail (gst_date_time_has_day (datetime), 0);
243 
244   return g_date_time_get_day_of_month (datetime-&gt;datetime);
245 }
246 
247 /**
248  * gst_date_time_get_hour:
249  * @datetime: a #GstDateTime
250  *
251  * Retrieves the hour of the day represented by @datetime in the gregorian
252  * calendar. The return is in the range of 0 to 23.
<span class="line-modified">253  * Call gst_date_time_has_haur before, to avoid warnings.</span>
254  *
255  * Return value: the hour of the day
256  */
257 gint
258 gst_date_time_get_hour (const GstDateTime * datetime)
259 {
260   g_return_val_if_fail (datetime != NULL, 0);
261   g_return_val_if_fail (gst_date_time_has_time (datetime), 0);
262 
263   return g_date_time_get_hour (datetime-&gt;datetime);
264 }
265 
266 /**
267  * gst_date_time_get_minute:
268  * @datetime: a #GstDateTime
269  *
270  * Retrieves the minute of the hour represented by @datetime in the gregorian
271  * calendar.
<span class="line-modified">272  * Call gst_date_time_has_minute before, to avoid warnings.</span>
273  *
274  * Return value: the minute of the hour
275  */
276 gint
277 gst_date_time_get_minute (const GstDateTime * datetime)
278 {
279   g_return_val_if_fail (datetime != NULL, 0);
280   g_return_val_if_fail (gst_date_time_has_time (datetime), 0);
281 
282   return g_date_time_get_minute (datetime-&gt;datetime);
283 }
284 
285 /**
286  * gst_date_time_get_second:
287  * @datetime: a #GstDateTime
288  *
289  * Retrieves the second of the minute represented by @datetime in the gregorian
290  * calendar.
<span class="line-modified">291  * Call gst_date_time_has_second before, to avoid warnings.</span>
292  *
293  * Return value: the second represented by @datetime
294  */
295 gint
296 gst_date_time_get_second (const GstDateTime * datetime)
297 {
298   g_return_val_if_fail (datetime != NULL, 0);
299   g_return_val_if_fail (gst_date_time_has_second (datetime), 0);
300 
301   return g_date_time_get_second (datetime-&gt;datetime);
302 }
303 
304 /**
305  * gst_date_time_get_microsecond:
306  * @datetime: a #GstDateTime
307  *
308  * Retrieves the fractional part of the seconds in microseconds represented by
309  * @datetime in the gregorian calendar.
310  *
311  * Return value: the microsecond of the second
</pre>
<hr />
<pre>
481  * @seconds: the second of the minute, or -1
482  *
483  * Creates a new #GstDateTime using the date and times in the gregorian calendar
484  * in the local timezone.
485  *
486  * @year should be from 1 to 9999, @month should be from 1 to 12, @day from
487  * 1 to 31, @hour from 0 to 23, @minutes and @seconds from 0 to 59.
488  *
489  * If @month is -1, then the #GstDateTime created will only contain @year,
490  * and all other fields will be considered not set.
491  *
492  * If @day is -1, then the #GstDateTime created will only contain @year and
493  * @month and all other fields will be considered not set.
494  *
495  * If @hour is -1, then the #GstDateTime created will only contain @year and
496  * @month and @day, and the time fields will be considered not set. In this
497  * case @minute and @seconds should also be -1.
498  *
499  * Free-function: gst_date_time_unref
500  *
<span class="line-modified">501  * Return value: (transfer full) (nullable): the newly created #GstDateTime</span>
502  */
503 GstDateTime *
504 gst_date_time_new_local_time (gint year, gint month, gint day, gint hour,
505     gint minute, gdouble seconds)
506 {
507   GstDateTimeFields fields;
508   GstDateTime *datetime;
509 
510   g_return_val_if_fail (year &gt; 0 &amp;&amp; year &lt;= 9999, NULL);
511   g_return_val_if_fail ((month &gt; 0 &amp;&amp; month &lt;= 12) || month == -1, NULL);
512   g_return_val_if_fail ((day &gt; 0 &amp;&amp; day &lt;= 31) || day == -1, NULL);
513   g_return_val_if_fail ((hour &gt;= 0 &amp;&amp; hour &lt; 24) || hour == -1, NULL);
514   g_return_val_if_fail ((minute &gt;= 0 &amp;&amp; minute &lt; 60) || minute == -1, NULL);
515   g_return_val_if_fail ((seconds &gt;= 0 &amp;&amp; seconds &lt; 60) || seconds == -1, NULL);
516 
517   fields = gst_date_time_check_fields (&amp;year, &amp;month, &amp;day,
518       &amp;hour, &amp;minute, &amp;seconds);
519 
520   datetime = gst_date_time_new_from_g_date_time (g_date_time_new_local (year,
521           month, day, hour, minute, seconds));
</pre>
<hr />
<pre>
594  * @minute: the minute of the hour
595  * @seconds: the second of the minute
596  *
597  * Creates a new #GstDateTime using the date and times in the gregorian calendar
598  * in the supplied timezone.
599  *
600  * @year should be from 1 to 9999, @month should be from 1 to 12, @day from
601  * 1 to 31, @hour from 0 to 23, @minutes and @seconds from 0 to 59.
602  *
603  * Note that @tzoffset is a float and was chosen so for being able to handle
604  * some fractional timezones, while it still keeps the readability of
605  * representing it in hours for most timezones.
606  *
607  * If value is -1 then all over value will be ignored. For example
608  * if @month == -1, then #GstDateTime will created only for @year. If
609  * @day == -1, then #GstDateTime will created for @year and @month and
610  * so on.
611  *
612  * Free-function: gst_date_time_unref
613  *
<span class="line-modified">614  * Return value: (transfer full) (nullable): the newly created #GstDateTime</span>
615  */
616 GstDateTime *
617 gst_date_time_new (gfloat tzoffset, gint year, gint month, gint day, gint hour,
618     gint minute, gdouble seconds)
619 {
620   GstDateTimeFields fields;
621   gchar buf[6];
622   GTimeZone *tz;
623   GDateTime *dt;
624   GstDateTime *datetime;
625   gint tzhour, tzminute;
626 
627   g_return_val_if_fail (year &gt; 0 &amp;&amp; year &lt;= 9999, NULL);
628   g_return_val_if_fail ((month &gt; 0 &amp;&amp; month &lt;= 12) || month == -1, NULL);
629   g_return_val_if_fail ((day &gt; 0 &amp;&amp; day &lt;= 31) || day == -1, NULL);
630   g_return_val_if_fail ((hour &gt;= 0 &amp;&amp; hour &lt; 24) || hour == -1, NULL);
631   g_return_val_if_fail ((minute &gt;= 0 &amp;&amp; minute &lt; 60) || minute == -1, NULL);
632   g_return_val_if_fail ((seconds &gt;= 0 &amp;&amp; seconds &lt; 60) || seconds == -1, NULL);
633   g_return_val_if_fail (tzoffset &gt;= -12.0 &amp;&amp; tzoffset &lt;= 12.0, NULL);
634   g_return_val_if_fail ((hour &gt;= 0 &amp;&amp; minute &gt;= 0) ||
</pre>
<hr />
<pre>
775   gint year = -1, month = -1, day = -1, hour = -1, minute = -1;
776   gint gmt_offset_hour = -99, gmt_offset_min = -99;
777   gdouble second = -1.0;
778   gfloat tzoffset = 0.0;
779   guint64 usecs;
780   gint len, ret;
781 
782   g_return_val_if_fail (string != NULL, NULL);
783 
784   GST_DEBUG (&quot;Parsing &#39;%s&#39; into a datetime&quot;, string);
785 
786   len = strlen (string);
787 
788   /* The input string is expected to start either with a year (4 digits) or
789    * with an hour (2 digits). Hour must be followed by minute. In any case,
790    * the string must be at least 4 characters long and start with 2 digits */
791   if (len &lt; 4 || !g_ascii_isdigit (string[0]) || !g_ascii_isdigit (string[1]))
792     return NULL;
793 
794   if (g_ascii_isdigit (string[2]) &amp;&amp; g_ascii_isdigit (string[3])) {
<span class="line-modified">795   ret = sscanf (string, &quot;%04d-%02d-%02d&quot;, &amp;year, &amp;month, &amp;day);</span>
796 
<span class="line-modified">797   if (ret == 0)</span>
<span class="line-modified">798     return NULL;</span>
799 
<span class="line-modified">800   if (ret == 3 &amp;&amp; day &lt;= 0) {</span>
<span class="line-modified">801     ret = 2;</span>
<span class="line-modified">802     day = -1;</span>
<span class="line-modified">803   }</span>
804 
<span class="line-modified">805   if (ret &gt;= 2 &amp;&amp; month &lt;= 0) {</span>
<span class="line-modified">806     ret = 1;</span>
<span class="line-modified">807     month = day = -1;</span>
<span class="line-modified">808   }</span>
809 
810     if (ret &gt;= 1 &amp;&amp; (year &lt;= 0 || year &gt; 9999 || month &gt; 12 || day &gt; 31))
<span class="line-modified">811     return NULL;</span>
812 
<span class="line-modified">813   else if (ret &gt;= 1 &amp;&amp; len &lt; 16)</span>
<span class="line-modified">814     /* YMD is 10 chars. XMD + HM will be 16 chars. if it is less,</span>
<span class="line-modified">815      * it make no sense to continue. We will stay with YMD. */</span>
<span class="line-modified">816     goto ymd;</span>
817 
<span class="line-modified">818   string += 10;</span>
<span class="line-modified">819   /* Exit if there is no expeceted value on this stage */</span>
<span class="line-modified">820   if (!(*string == &#39;T&#39; || *string == &#39;-&#39; || *string == &#39; &#39;))</span>
<span class="line-modified">821     goto ymd;</span>
822 
823     string += 1;
824   }
825   /* if hour or minute fails, then we will use only ymd. */
826   hour = g_ascii_strtoull (string, (gchar **) &amp; string, 10);
827   if (hour &gt; 24 || *string != &#39;:&#39;)
828     goto ymd;
829 
830   /* minute */
831   minute = g_ascii_strtoull (string + 1, (gchar **) &amp; string, 10);
832   if (minute &gt; 59)
833     goto ymd;
834 
835   /* second */
836   if (*string == &#39;:&#39;) {
837     second = g_ascii_strtoull (string + 1, (gchar **) &amp; string, 10);
838     /* if we fail here, we still can reuse hour and minute. We
839      * will still attempt to parse any timezone information */
840     if (second &gt; 59) {
841       second = -1.0;
</pre>
<hr />
<pre>
913       g_date_time_unref (now_utc);
914     } else {
915       now_in_given_tz = now_utc;
916     }
917     g_date_time_get_ymd (now_in_given_tz, &amp;year, &amp;month, &amp;day);
918     g_date_time_unref (now_in_given_tz);
919   }
920   return gst_date_time_new (tzoffset, year, month, day, hour, minute, second);
921 ymd:
922   if (year == -1) {
923     /* No date was supplied and time failed to parse */
924     return NULL;
925   }
926   return gst_date_time_new_ymd (year, month, day);
927 }
928 
929 static void
930 gst_date_time_free (GstDateTime * datetime)
931 {
932   g_date_time_unref (datetime-&gt;datetime);





933   g_slice_free (GstDateTime, datetime);
934 }
935 
936 /**
937  * gst_date_time_ref:
938  * @datetime: a #GstDateTime
939  *
940  * Atomically increments the reference count of @datetime by one.
941  *
942  * Return value: (transfer full): the reference @datetime
943  */
944 GstDateTime *
945 gst_date_time_ref (GstDateTime * datetime)
946 {
947   return (GstDateTime *) gst_mini_object_ref (GST_MINI_OBJECT_CAST (datetime));
948 }
949 
950 /**
951  * gst_date_time_unref:
952  * @datetime: (transfer full): a #GstDateTime
</pre>
</td>
<td>
<hr />
<pre>
179 
180 /**
181  * gst_date_time_has_second:
182  * @datetime: a #GstDateTime
183  *
184  * Returns: %TRUE if @datetime&lt;!-- --&gt;&#39;s second field is set, otherwise %FALSE
185  */
186 gboolean
187 gst_date_time_has_second (const GstDateTime * datetime)
188 {
189   g_return_val_if_fail (datetime != NULL, FALSE);
190 
191   return (datetime-&gt;fields &gt;= GST_DATE_TIME_FIELDS_YMD_HMS);
192 }
193 
194 /**
195  * gst_date_time_get_year:
196  * @datetime: a #GstDateTime
197  *
198  * Returns the year of this #GstDateTime
<span class="line-modified">199  * Call gst_date_time_has_year() before, to avoid warnings.</span>
200  *
201  * Return value: The year of this #GstDateTime
202  */
203 gint
204 gst_date_time_get_year (const GstDateTime * datetime)
205 {
206   g_return_val_if_fail (datetime != NULL, 0);
207 
208   return g_date_time_get_year (datetime-&gt;datetime);
209 }
210 
211 /**
212  * gst_date_time_get_month:
213  * @datetime: a #GstDateTime
214  *
215  * Returns the month of this #GstDateTime. January is 1, February is 2, etc..
<span class="line-modified">216  * Call gst_date_time_has_month() before, to avoid warnings.</span>
217  *
218  * Return value: The month of this #GstDateTime
219  */
220 gint
221 gst_date_time_get_month (const GstDateTime * datetime)
222 {
223   g_return_val_if_fail (datetime != NULL, 0);
224   g_return_val_if_fail (gst_date_time_has_month (datetime), 0);
225 
226   return g_date_time_get_month (datetime-&gt;datetime);
227 }
228 
229 /**
230  * gst_date_time_get_day:
231  * @datetime: a #GstDateTime
232  *
233  * Returns the day of the month of this #GstDateTime.
<span class="line-modified">234  * Call gst_date_time_has_day() before, to avoid warnings.</span>
235  *
236  * Return value: The day of this #GstDateTime
237  */
238 gint
239 gst_date_time_get_day (const GstDateTime * datetime)
240 {
241   g_return_val_if_fail (datetime != NULL, 0);
242   g_return_val_if_fail (gst_date_time_has_day (datetime), 0);
243 
244   return g_date_time_get_day_of_month (datetime-&gt;datetime);
245 }
246 
247 /**
248  * gst_date_time_get_hour:
249  * @datetime: a #GstDateTime
250  *
251  * Retrieves the hour of the day represented by @datetime in the gregorian
252  * calendar. The return is in the range of 0 to 23.
<span class="line-modified">253  * Call gst_date_time_has_time() before, to avoid warnings.</span>
254  *
255  * Return value: the hour of the day
256  */
257 gint
258 gst_date_time_get_hour (const GstDateTime * datetime)
259 {
260   g_return_val_if_fail (datetime != NULL, 0);
261   g_return_val_if_fail (gst_date_time_has_time (datetime), 0);
262 
263   return g_date_time_get_hour (datetime-&gt;datetime);
264 }
265 
266 /**
267  * gst_date_time_get_minute:
268  * @datetime: a #GstDateTime
269  *
270  * Retrieves the minute of the hour represented by @datetime in the gregorian
271  * calendar.
<span class="line-modified">272  * Call gst_date_time_has_time() before, to avoid warnings.</span>
273  *
274  * Return value: the minute of the hour
275  */
276 gint
277 gst_date_time_get_minute (const GstDateTime * datetime)
278 {
279   g_return_val_if_fail (datetime != NULL, 0);
280   g_return_val_if_fail (gst_date_time_has_time (datetime), 0);
281 
282   return g_date_time_get_minute (datetime-&gt;datetime);
283 }
284 
285 /**
286  * gst_date_time_get_second:
287  * @datetime: a #GstDateTime
288  *
289  * Retrieves the second of the minute represented by @datetime in the gregorian
290  * calendar.
<span class="line-modified">291  * Call gst_date_time_has_time() before, to avoid warnings.</span>
292  *
293  * Return value: the second represented by @datetime
294  */
295 gint
296 gst_date_time_get_second (const GstDateTime * datetime)
297 {
298   g_return_val_if_fail (datetime != NULL, 0);
299   g_return_val_if_fail (gst_date_time_has_second (datetime), 0);
300 
301   return g_date_time_get_second (datetime-&gt;datetime);
302 }
303 
304 /**
305  * gst_date_time_get_microsecond:
306  * @datetime: a #GstDateTime
307  *
308  * Retrieves the fractional part of the seconds in microseconds represented by
309  * @datetime in the gregorian calendar.
310  *
311  * Return value: the microsecond of the second
</pre>
<hr />
<pre>
481  * @seconds: the second of the minute, or -1
482  *
483  * Creates a new #GstDateTime using the date and times in the gregorian calendar
484  * in the local timezone.
485  *
486  * @year should be from 1 to 9999, @month should be from 1 to 12, @day from
487  * 1 to 31, @hour from 0 to 23, @minutes and @seconds from 0 to 59.
488  *
489  * If @month is -1, then the #GstDateTime created will only contain @year,
490  * and all other fields will be considered not set.
491  *
492  * If @day is -1, then the #GstDateTime created will only contain @year and
493  * @month and all other fields will be considered not set.
494  *
495  * If @hour is -1, then the #GstDateTime created will only contain @year and
496  * @month and @day, and the time fields will be considered not set. In this
497  * case @minute and @seconds should also be -1.
498  *
499  * Free-function: gst_date_time_unref
500  *
<span class="line-modified">501  * Return value: (transfer full): the newly created #GstDateTime</span>
502  */
503 GstDateTime *
504 gst_date_time_new_local_time (gint year, gint month, gint day, gint hour,
505     gint minute, gdouble seconds)
506 {
507   GstDateTimeFields fields;
508   GstDateTime *datetime;
509 
510   g_return_val_if_fail (year &gt; 0 &amp;&amp; year &lt;= 9999, NULL);
511   g_return_val_if_fail ((month &gt; 0 &amp;&amp; month &lt;= 12) || month == -1, NULL);
512   g_return_val_if_fail ((day &gt; 0 &amp;&amp; day &lt;= 31) || day == -1, NULL);
513   g_return_val_if_fail ((hour &gt;= 0 &amp;&amp; hour &lt; 24) || hour == -1, NULL);
514   g_return_val_if_fail ((minute &gt;= 0 &amp;&amp; minute &lt; 60) || minute == -1, NULL);
515   g_return_val_if_fail ((seconds &gt;= 0 &amp;&amp; seconds &lt; 60) || seconds == -1, NULL);
516 
517   fields = gst_date_time_check_fields (&amp;year, &amp;month, &amp;day,
518       &amp;hour, &amp;minute, &amp;seconds);
519 
520   datetime = gst_date_time_new_from_g_date_time (g_date_time_new_local (year,
521           month, day, hour, minute, seconds));
</pre>
<hr />
<pre>
594  * @minute: the minute of the hour
595  * @seconds: the second of the minute
596  *
597  * Creates a new #GstDateTime using the date and times in the gregorian calendar
598  * in the supplied timezone.
599  *
600  * @year should be from 1 to 9999, @month should be from 1 to 12, @day from
601  * 1 to 31, @hour from 0 to 23, @minutes and @seconds from 0 to 59.
602  *
603  * Note that @tzoffset is a float and was chosen so for being able to handle
604  * some fractional timezones, while it still keeps the readability of
605  * representing it in hours for most timezones.
606  *
607  * If value is -1 then all over value will be ignored. For example
608  * if @month == -1, then #GstDateTime will created only for @year. If
609  * @day == -1, then #GstDateTime will created for @year and @month and
610  * so on.
611  *
612  * Free-function: gst_date_time_unref
613  *
<span class="line-modified">614  * Return value: (transfer full): the newly created #GstDateTime</span>
615  */
616 GstDateTime *
617 gst_date_time_new (gfloat tzoffset, gint year, gint month, gint day, gint hour,
618     gint minute, gdouble seconds)
619 {
620   GstDateTimeFields fields;
621   gchar buf[6];
622   GTimeZone *tz;
623   GDateTime *dt;
624   GstDateTime *datetime;
625   gint tzhour, tzminute;
626 
627   g_return_val_if_fail (year &gt; 0 &amp;&amp; year &lt;= 9999, NULL);
628   g_return_val_if_fail ((month &gt; 0 &amp;&amp; month &lt;= 12) || month == -1, NULL);
629   g_return_val_if_fail ((day &gt; 0 &amp;&amp; day &lt;= 31) || day == -1, NULL);
630   g_return_val_if_fail ((hour &gt;= 0 &amp;&amp; hour &lt; 24) || hour == -1, NULL);
631   g_return_val_if_fail ((minute &gt;= 0 &amp;&amp; minute &lt; 60) || minute == -1, NULL);
632   g_return_val_if_fail ((seconds &gt;= 0 &amp;&amp; seconds &lt; 60) || seconds == -1, NULL);
633   g_return_val_if_fail (tzoffset &gt;= -12.0 &amp;&amp; tzoffset &lt;= 12.0, NULL);
634   g_return_val_if_fail ((hour &gt;= 0 &amp;&amp; minute &gt;= 0) ||
</pre>
<hr />
<pre>
775   gint year = -1, month = -1, day = -1, hour = -1, minute = -1;
776   gint gmt_offset_hour = -99, gmt_offset_min = -99;
777   gdouble second = -1.0;
778   gfloat tzoffset = 0.0;
779   guint64 usecs;
780   gint len, ret;
781 
782   g_return_val_if_fail (string != NULL, NULL);
783 
784   GST_DEBUG (&quot;Parsing &#39;%s&#39; into a datetime&quot;, string);
785 
786   len = strlen (string);
787 
788   /* The input string is expected to start either with a year (4 digits) or
789    * with an hour (2 digits). Hour must be followed by minute. In any case,
790    * the string must be at least 4 characters long and start with 2 digits */
791   if (len &lt; 4 || !g_ascii_isdigit (string[0]) || !g_ascii_isdigit (string[1]))
792     return NULL;
793 
794   if (g_ascii_isdigit (string[2]) &amp;&amp; g_ascii_isdigit (string[3])) {
<span class="line-modified">795     ret = sscanf (string, &quot;%04d-%02d-%02d&quot;, &amp;year, &amp;month, &amp;day);</span>
796 
<span class="line-modified">797     if (ret == 0)</span>
<span class="line-modified">798       return NULL;</span>
799 
<span class="line-modified">800     if (ret == 3 &amp;&amp; day &lt;= 0) {</span>
<span class="line-modified">801       ret = 2;</span>
<span class="line-modified">802       day = -1;</span>
<span class="line-modified">803     }</span>
804 
<span class="line-modified">805     if (ret &gt;= 2 &amp;&amp; month &lt;= 0) {</span>
<span class="line-modified">806       ret = 1;</span>
<span class="line-modified">807       month = day = -1;</span>
<span class="line-modified">808     }</span>
809 
810     if (ret &gt;= 1 &amp;&amp; (year &lt;= 0 || year &gt; 9999 || month &gt; 12 || day &gt; 31))
<span class="line-modified">811       return NULL;</span>
812 
<span class="line-modified">813     else if (ret &gt;= 1 &amp;&amp; len &lt; 16)</span>
<span class="line-modified">814       /* YMD is 10 chars. XMD + HM will be 16 chars. if it is less,</span>
<span class="line-modified">815        * it make no sense to continue. We will stay with YMD. */</span>
<span class="line-modified">816       goto ymd;</span>
817 
<span class="line-modified">818     string += 10;</span>
<span class="line-modified">819     /* Exit if there is no expeceted value on this stage */</span>
<span class="line-modified">820     if (!(*string == &#39;T&#39; || *string == &#39;-&#39; || *string == &#39; &#39;))</span>
<span class="line-modified">821       goto ymd;</span>
822 
823     string += 1;
824   }
825   /* if hour or minute fails, then we will use only ymd. */
826   hour = g_ascii_strtoull (string, (gchar **) &amp; string, 10);
827   if (hour &gt; 24 || *string != &#39;:&#39;)
828     goto ymd;
829 
830   /* minute */
831   minute = g_ascii_strtoull (string + 1, (gchar **) &amp; string, 10);
832   if (minute &gt; 59)
833     goto ymd;
834 
835   /* second */
836   if (*string == &#39;:&#39;) {
837     second = g_ascii_strtoull (string + 1, (gchar **) &amp; string, 10);
838     /* if we fail here, we still can reuse hour and minute. We
839      * will still attempt to parse any timezone information */
840     if (second &gt; 59) {
841       second = -1.0;
</pre>
<hr />
<pre>
913       g_date_time_unref (now_utc);
914     } else {
915       now_in_given_tz = now_utc;
916     }
917     g_date_time_get_ymd (now_in_given_tz, &amp;year, &amp;month, &amp;day);
918     g_date_time_unref (now_in_given_tz);
919   }
920   return gst_date_time_new (tzoffset, year, month, day, hour, minute, second);
921 ymd:
922   if (year == -1) {
923     /* No date was supplied and time failed to parse */
924     return NULL;
925   }
926   return gst_date_time_new_ymd (year, month, day);
927 }
928 
929 static void
930 gst_date_time_free (GstDateTime * datetime)
931 {
932   g_date_time_unref (datetime-&gt;datetime);
<span class="line-added">933 </span>
<span class="line-added">934 #ifdef USE_POISONING</span>
<span class="line-added">935   memset (datetime, 0xff, sizeof (GstDateTime));</span>
<span class="line-added">936 #endif</span>
<span class="line-added">937 </span>
938   g_slice_free (GstDateTime, datetime);
939 }
940 
941 /**
942  * gst_date_time_ref:
943  * @datetime: a #GstDateTime
944  *
945  * Atomically increments the reference count of @datetime by one.
946  *
947  * Return value: (transfer full): the reference @datetime
948  */
949 GstDateTime *
950 gst_date_time_ref (GstDateTime * datetime)
951 {
952   return (GstDateTime *) gst_mini_object_ref (GST_MINI_OBJECT_CAST (datetime));
953 }
954 
955 /**
956  * gst_date_time_unref:
957  * @datetime: (transfer full): a #GstDateTime
</pre>
</td>
</tr>
</table>
<center><a href="gstcontrolbinding.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstdebugutils.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>