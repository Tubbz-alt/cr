<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn-win32-helper.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gslist.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gspawn-win32.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn-win32-helper.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21 
 22 #include &lt;fcntl.h&gt;
 23 
 24 /* For _CrtSetReportMode, we don&#39;t want Windows CRT (2005 and later)
 25  * to terminate the process if a bad file descriptor is passed into
 26  * _get_osfhandle().  This is necessary because we use _get_osfhandle()
 27  * to check the validity of the fd before we try to call close() on
 28  * it as attempting to close an invalid fd will cause the Windows CRT
 29  * to abort() this program internally.
 30  *
 31  * Please see http://msdn.microsoft.com/zh-tw/library/ks2530z6%28v=vs.80%29.aspx
 32  * for an explanation on this.
 33  */
 34 #if (defined (_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1400)
 35 #include &lt;crtdbg.h&gt;
 36 #endif
 37 
 38 #undef G_LOG_DOMAIN
 39 #include &quot;glib.h&quot;
 40 #define GSPAWN_HELPER
<span class="line-modified"> 41 #include &quot;gspawn-win32.c&quot;   /* For shared definitions */</span>
 42 
 43 
 44 static void
 45 write_err_and_exit (gint    fd,
<span class="line-modified"> 46             gintptr msg)</span>
 47 {
 48   gintptr en = errno;
 49 
 50   write (fd, &amp;msg, sizeof(gintptr));
 51   write (fd, &amp;en, sizeof(gintptr));
 52 
 53   _exit (1);
 54 }
 55 
 56 #ifdef __GNUC__
 57 #  ifndef _stdcall
 58 #    define _stdcall  __attribute__((stdcall))
 59 #  endif
 60 #endif
 61 
 62 /* We build gspawn-win32-helper.exe as a Windows GUI application
 63  * to avoid any temporarily flashing console windows in case
 64  * the gspawn function is invoked by a GUI program. Thus, no main()
 65  * but a WinMain().
 66  */
 67 
 68 /* Copy of protect_argv that handles wchar_t strings */
 69 
 70 static gint
 71 protect_wargv (gint       argc,
<span class="line-modified"> 72            wchar_t  **wargv,</span>
<span class="line-modified"> 73            wchar_t ***new_wargv)</span>
 74 {
 75   gint i;
 76 
 77   *new_wargv = g_new (wchar_t *, argc+1);
 78 
 79   /* Quote each argv element if necessary, so that it will get
 80    * reconstructed correctly in the C runtime startup code.  Note that
 81    * the unquoting algorithm in the C runtime is really weird, and
 82    * rather different than what Unix shells do. See stdargv.c in the C
 83    * runtime sources (in the Platform SDK, in src/crt).
 84    *
<span class="line-modified"> 85    * Note that an new_wargv[0] constructed by this function should</span>
 86    * *not* be passed as the filename argument to a _wspawn* or _wexec*
 87    * family function. That argument should be the real file name
 88    * without any quoting.
 89    */
 90   for (i = 0; i &lt; argc; i++)
 91     {
 92       wchar_t *p = wargv[i];
 93       wchar_t *q;
 94       gint len = 0;

 95       gboolean need_dblquotes = FALSE;
 96       while (*p)
<span class="line-modified"> 97     {</span>
<span class="line-modified"> 98       if (*p == &#39; &#39; || *p == &#39;\t&#39;)</span>
<span class="line-modified"> 99         need_dblquotes = TRUE;</span>
<span class="line-modified">100       else if (*p == &#39;&quot;&#39;)</span>
<span class="line-modified">101         len++;</span>
<span class="line-modified">102       else if (*p == &#39;\\&#39;)</span>
<span class="line-modified">103         {</span>
<span class="line-modified">104           wchar_t *pp = p;</span>
<span class="line-modified">105           while (*pp &amp;&amp; *pp == &#39;\\&#39;)</span>
<span class="line-modified">106         pp++;</span>
<span class="line-removed">107           if (*pp == &#39;&quot;&#39;)</span>
<span class="line-removed">108         len++;</span>
<span class="line-removed">109         }</span>
<span class="line-removed">110       len++;</span>
<span class="line-removed">111       p++;</span>
<span class="line-removed">112     }</span>
113 
114       q = (*new_wargv)[i] = g_new (wchar_t, len + need_dblquotes*2 + 1);
115       p = wargv[i];
116 
117       if (need_dblquotes)
<span class="line-modified">118     *q++ = &#39;&quot;&#39;;</span>
119 




120       while (*p)
<span class="line-modified">121     {</span>
<span class="line-modified">122       if (*p == &#39;&quot;&#39;)</span>
<span class="line-modified">123         *q++ = &#39;\\&#39;;</span>
<span class="line-modified">124       else if (*p == &#39;\\&#39;)</span>
<span class="line-removed">125         {</span>
<span class="line-removed">126           wchar_t *pp = p;</span>
<span class="line-removed">127           while (*pp &amp;&amp; *pp == &#39;\\&#39;)</span>
<span class="line-removed">128         pp++;</span>
<span class="line-removed">129           if (*pp == &#39;&quot;&#39;)</span>
130         *q++ = &#39;\\&#39;;
<span class="line-modified">131         }</span>
<span class="line-modified">132       *q++ = *p;</span>
<span class="line-modified">133       p++;</span>
<span class="line-modified">134     }</span>










135 
136       if (need_dblquotes)






137     *q++ = &#39;&quot;&#39;;

138       *q++ = &#39;\0&#39;;
139     }
140   (*new_wargv)[argc] = NULL;
141 
142   return argc;
143 }
144 
145 #if (defined (_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1400)
146 /*
147  * This is the (empty) invalid parameter handler
148  * that is used for Visual C++ 2005 (and later) builds
149  * so that we can use this instead of the system automatically
150  * aborting the process.
151  *
152  * This is necessary as we use _get_oshandle() to check the validity
153  * of the file descriptors as we close them, so when an invalid file
154  * descriptor is passed into that function as we check on it, we get
155  * -1 as the result, instead of the gspawn helper program aborting.
156  *
157  * Please see http://msdn.microsoft.com/zh-tw/library/ks2530z6%28v=vs.80%29.aspx
158  * for an explanation on this.
159  */
160 extern void
161 myInvalidParameterHandler(const wchar_t *expression,
162                           const wchar_t *function,
163                           const wchar_t *file,
164                           unsigned int   line,
165                           uintptr_t      pReserved);
166 #endif
167 
168 #ifndef GSTREAMER_LITE
169 #ifndef HELPER_CONSOLE
170 int _stdcall
171 WinMain (struct HINSTANCE__ *hInstance,
<span class="line-modified">172      struct HINSTANCE__ *hPrevInstance,</span>
<span class="line-modified">173      char               *lpszCmdLine,</span>
<span class="line-modified">174      int                 nCmdShow)</span>
175 #else
176 int
177 main (int ignored_argc, char **ignored_argv)
178 #endif
179 {
180   int child_err_report_fd = -1;
181   int helper_sync_fd = -1;

182   int i;
183   int fd;
184   int mode;
185   gintptr handle;
186   int saved_errno;
187   gintptr no_error = CHILD_NO_ERROR;
188   gint argv_zero_offset = ARG_PROGRAM;
189   wchar_t **new_wargv;
190   int argc;
191   char **argv;
192   wchar_t **wargv;
193   char c;
194 
195 #if (defined (_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1400)
196   /* set up our empty invalid parameter handler */
197   _invalid_parameter_handler oldHandler, newHandler;
198   newHandler = myInvalidParameterHandler;
199   oldHandler = _set_invalid_parameter_handler(newHandler);
200 
201   /* Disable the message box for assertions. */
</pre>
<hr />
<pre>
227 
228   /* argv[ARG_HELPER_SYNC] is the file descriptor number we read a
229    * byte that tells us it is OK to exit. We have to wait until the
230    * parent allows us to exit, so that the parent has had time to
231    * duplicate the process handle we sent it. Duplicating a handle
232    * from another process works only if that other process exists.
233    */
234   helper_sync_fd = atoi (argv[ARG_HELPER_SYNC]);
235 
236   /* argv[ARG_STDIN..ARG_STDERR] are the file descriptor numbers that
237    * should be dup2&#39;d to 0, 1 and 2. &#39;-&#39; if the corresponding fd
238    * should be left alone, and &#39;z&#39; if it should be connected to the
239    * bit bucket NUL:.
240    */
241   if (argv[ARG_STDIN][0] == &#39;-&#39;)
242     ; /* Nothing */
243   else if (argv[ARG_STDIN][0] == &#39;z&#39;)
244     {
245       fd = open (&quot;NUL:&quot;, O_RDONLY);
246       if (fd != 0)
<span class="line-modified">247     {</span>
<span class="line-modified">248       dup2 (fd, 0);</span>
<span class="line-modified">249       close (fd);</span>
<span class="line-modified">250     }</span>
251     }
252   else
253     {
254       fd = atoi (argv[ARG_STDIN]);
255       if (fd != 0)
<span class="line-modified">256     {</span>
<span class="line-modified">257       dup2 (fd, 0);</span>
<span class="line-modified">258       close (fd);</span>
<span class="line-modified">259     }</span>
260     }
261 
262   if (argv[ARG_STDOUT][0] == &#39;-&#39;)
263     ; /* Nothing */
264   else if (argv[ARG_STDOUT][0] == &#39;z&#39;)
265     {
266       fd = open (&quot;NUL:&quot;, O_WRONLY);
267       if (fd != 1)
<span class="line-modified">268     {</span>
<span class="line-modified">269       dup2 (fd, 1);</span>
<span class="line-modified">270       close (fd);</span>
<span class="line-modified">271     }</span>
272     }
273   else
274     {
275       fd = atoi (argv[ARG_STDOUT]);
276       if (fd != 1)
<span class="line-modified">277     {</span>
<span class="line-modified">278       dup2 (fd, 1);</span>
<span class="line-modified">279       close (fd);</span>
<span class="line-modified">280     }</span>
281     }
282 

283   if (argv[ARG_STDERR][0] == &#39;-&#39;)
284     ; /* Nothing */
285   else if (argv[ARG_STDERR][0] == &#39;z&#39;)
286     {
287       fd = open (&quot;NUL:&quot;, O_WRONLY);
288       if (fd != 2)
<span class="line-modified">289     {</span>
<span class="line-modified">290       dup2 (fd, 2);</span>
<span class="line-modified">291       close (fd);</span>
<span class="line-modified">292     }</span>
293     }
294   else
295     {
296       fd = atoi (argv[ARG_STDERR]);
297       if (fd != 2)
<span class="line-modified">298     {</span>
<span class="line-modified">299       dup2 (fd, 2);</span>
<span class="line-modified">300       close (fd);</span>
<span class="line-modified">301     }</span>
302     }
303 
304   /* argv[ARG_WORKING_DIRECTORY] is the directory in which to run the
305    * process.  If &quot;-&quot;, don&#39;t change directory.
306    */
307   if (argv[ARG_WORKING_DIRECTORY][0] == &#39;-&#39; &amp;&amp;
308       argv[ARG_WORKING_DIRECTORY][1] == 0)
309     ; /* Nothing */
310   else if (_wchdir (wargv[ARG_WORKING_DIRECTORY]) &lt; 0)
311     write_err_and_exit (child_err_report_fd, CHILD_CHDIR_FAILED);
312 
313   /* argv[ARG_CLOSE_DESCRIPTORS] is &quot;y&quot; if file descriptors from 3
314    *  upwards should be closed
315    */
316   if (argv[ARG_CLOSE_DESCRIPTORS][0] == &#39;y&#39;)
317     for (i = 3; i &lt; 1000; i++)  /* FIXME real limit? */
<span class="line-modified">318       if (i != child_err_report_fd &amp;&amp; i != helper_sync_fd)</span>
319         if (_get_osfhandle (i) != -1)
320           close (i);
321 
322   /* We don&#39;t want our child to inherit the error report and
323    * helper sync fds.
324    */
<span class="line-modified">325   child_err_report_fd = dup_noninherited (child_err_report_fd, _O_WRONLY);</span>
<span class="line-modified">326   helper_sync_fd = dup_noninherited (helper_sync_fd, _O_RDONLY);</span>
327 
328   /* argv[ARG_WAIT] is &quot;w&quot; to wait for the program to exit */
329   if (argv[ARG_WAIT][0] == &#39;w&#39;)
330     mode = P_WAIT;
331   else
332     mode = P_NOWAIT;
333 
334   /* argv[ARG_USE_PATH] is &quot;y&quot; to use PATH, otherwise not */
335 
336   /* argv[ARG_PROGRAM] is executable file to run,
337    * argv[argv_zero_offset]... is its argv. argv_zero_offset equals
338    * ARG_PROGRAM unless G_SPAWN_FILE_AND_ARGV_ZERO was used, in which
339    * case we have a separate executable name and argv[0].
340    */
341 
342   /* For the program name passed to spawnv(), don&#39;t use the quoted
343    * version.
344    */
345   protect_wargv (argc - argv_zero_offset, wargv + argv_zero_offset, &amp;new_wargv);
346 
347   if (argv[ARG_USE_PATH][0] == &#39;y&#39;)
348     handle = _wspawnvp (mode, wargv[ARG_PROGRAM], (const wchar_t **) new_wargv);
349   else
350     handle = _wspawnv (mode, wargv[ARG_PROGRAM], (const wchar_t **) new_wargv);
351 
352   saved_errno = errno;
353 





354   if (handle == -1 &amp;&amp; saved_errno != 0)
355     {
356       int ec = (saved_errno == ENOENT)
357           ? CHILD_SPAWN_NOENT
358           : CHILD_SPAWN_FAILED;
359       write_err_and_exit (child_err_report_fd, ec);
360     }
361 
362   write (child_err_report_fd, &amp;no_error, sizeof (no_error));
363   write (child_err_report_fd, &amp;handle, sizeof (handle));
364 
365   read (helper_sync_fd, &amp;c, 1);
366 
367   LocalFree (wargv);
368   g_strfreev (argv);
369 
370   return 0;
371 }
372 #endif // GSTREAMER_LITE
</pre>
</td>
<td>
<hr />
<pre>
 21 
 22 #include &lt;fcntl.h&gt;
 23 
 24 /* For _CrtSetReportMode, we don&#39;t want Windows CRT (2005 and later)
 25  * to terminate the process if a bad file descriptor is passed into
 26  * _get_osfhandle().  This is necessary because we use _get_osfhandle()
 27  * to check the validity of the fd before we try to call close() on
 28  * it as attempting to close an invalid fd will cause the Windows CRT
 29  * to abort() this program internally.
 30  *
 31  * Please see http://msdn.microsoft.com/zh-tw/library/ks2530z6%28v=vs.80%29.aspx
 32  * for an explanation on this.
 33  */
 34 #if (defined (_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1400)
 35 #include &lt;crtdbg.h&gt;
 36 #endif
 37 
 38 #undef G_LOG_DOMAIN
 39 #include &quot;glib.h&quot;
 40 #define GSPAWN_HELPER
<span class="line-modified"> 41 #include &quot;gspawn-win32.c&quot; /* For shared definitions */</span>
 42 
 43 
 44 static void
 45 write_err_and_exit (gint    fd,
<span class="line-modified"> 46         gintptr msg)</span>
 47 {
 48   gintptr en = errno;
 49 
 50   write (fd, &amp;msg, sizeof(gintptr));
 51   write (fd, &amp;en, sizeof(gintptr));
 52 
 53   _exit (1);
 54 }
 55 
 56 #ifdef __GNUC__
 57 #  ifndef _stdcall
 58 #    define _stdcall  __attribute__((stdcall))
 59 #  endif
 60 #endif
 61 
 62 /* We build gspawn-win32-helper.exe as a Windows GUI application
 63  * to avoid any temporarily flashing console windows in case
 64  * the gspawn function is invoked by a GUI program. Thus, no main()
 65  * but a WinMain().
 66  */
 67 
 68 /* Copy of protect_argv that handles wchar_t strings */
 69 
 70 static gint
 71 protect_wargv (gint       argc,
<span class="line-modified"> 72          wchar_t  **wargv,</span>
<span class="line-modified"> 73          wchar_t ***new_wargv)</span>
 74 {
 75   gint i;
 76 
 77   *new_wargv = g_new (wchar_t *, argc+1);
 78 
 79   /* Quote each argv element if necessary, so that it will get
 80    * reconstructed correctly in the C runtime startup code.  Note that
 81    * the unquoting algorithm in the C runtime is really weird, and
 82    * rather different than what Unix shells do. See stdargv.c in the C
 83    * runtime sources (in the Platform SDK, in src/crt).
 84    *
<span class="line-modified"> 85    * Note that a new_wargv[0] constructed by this function should</span>
 86    * *not* be passed as the filename argument to a _wspawn* or _wexec*
 87    * family function. That argument should be the real file name
 88    * without any quoting.
 89    */
 90   for (i = 0; i &lt; argc; i++)
 91     {
 92       wchar_t *p = wargv[i];
 93       wchar_t *q;
 94       gint len = 0;
<span class="line-added"> 95       gint pre_bslash = 0;</span>
 96       gboolean need_dblquotes = FALSE;
 97       while (*p)
<span class="line-modified"> 98   {</span>
<span class="line-modified"> 99     if (*p == &#39; &#39; || *p == &#39;\t&#39;)</span>
<span class="line-modified">100       need_dblquotes = TRUE;</span>
<span class="line-modified">101     /* estimate max len, assuming that all escapable chracters will be escaped */</span>
<span class="line-modified">102     if (*p == &#39;&quot;&#39; || *p == &#39;\\&#39;)</span>
<span class="line-modified">103       len += 2;</span>
<span class="line-modified">104     else</span>
<span class="line-modified">105       len += 1;</span>
<span class="line-modified">106     p++;</span>
<span class="line-modified">107   }</span>






108 
109       q = (*new_wargv)[i] = g_new (wchar_t, len + need_dblquotes*2 + 1);
110       p = wargv[i];
111 
112       if (need_dblquotes)
<span class="line-modified">113   *q++ = &#39;&quot;&#39;;</span>
114 
<span class="line-added">115       /* Only quotes and backslashes preceeding quotes are escaped:</span>
<span class="line-added">116        * see &quot;Parsing C Command-Line Arguments&quot; at</span>
<span class="line-added">117        * https://docs.microsoft.com/en-us/cpp/c-language/parsing-c-command-line-arguments</span>
<span class="line-added">118        */</span>
119       while (*p)
<span class="line-modified">120   {</span>
<span class="line-modified">121     if (*p == &#39;&quot;&#39;)</span>
<span class="line-modified">122       {</span>
<span class="line-modified">123         /* Add backslash for escaping quote itself */</span>





124         *q++ = &#39;\\&#39;;
<span class="line-modified">125         /* Add backslash for every preceeding backslash for escaping it */</span>
<span class="line-modified">126         for (;pre_bslash &gt; 0; --pre_bslash)</span>
<span class="line-modified">127     *q++ = &#39;\\&#39;;</span>
<span class="line-modified">128       }</span>
<span class="line-added">129 </span>
<span class="line-added">130     /* Count length of continuous sequence of preceeding backslashes. */</span>
<span class="line-added">131     if (*p == &#39;\\&#39;)</span>
<span class="line-added">132       ++pre_bslash;</span>
<span class="line-added">133     else</span>
<span class="line-added">134       pre_bslash = 0;</span>
<span class="line-added">135 </span>
<span class="line-added">136     *q++ = *p;</span>
<span class="line-added">137     p++;</span>
<span class="line-added">138   }</span>
139 
140       if (need_dblquotes)
<span class="line-added">141   {</span>
<span class="line-added">142     /* Add backslash for every preceeding backslash for escaping it,</span>
<span class="line-added">143      * do NOT escape quote itself.</span>
<span class="line-added">144      */</span>
<span class="line-added">145     for (;pre_bslash &gt; 0; --pre_bslash)</span>
<span class="line-added">146       *q++ = &#39;\\&#39;;</span>
147     *q++ = &#39;&quot;&#39;;
<span class="line-added">148   }</span>
149       *q++ = &#39;\0&#39;;
150     }
151   (*new_wargv)[argc] = NULL;
152 
153   return argc;
154 }
155 
156 #if (defined (_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1400)
157 /*
158  * This is the (empty) invalid parameter handler
159  * that is used for Visual C++ 2005 (and later) builds
160  * so that we can use this instead of the system automatically
161  * aborting the process.
162  *
163  * This is necessary as we use _get_oshandle() to check the validity
164  * of the file descriptors as we close them, so when an invalid file
165  * descriptor is passed into that function as we check on it, we get
166  * -1 as the result, instead of the gspawn helper program aborting.
167  *
168  * Please see http://msdn.microsoft.com/zh-tw/library/ks2530z6%28v=vs.80%29.aspx
169  * for an explanation on this.
170  */
171 extern void
172 myInvalidParameterHandler(const wchar_t *expression,
173                           const wchar_t *function,
174                           const wchar_t *file,
175                           unsigned int   line,
176                           uintptr_t      pReserved);
177 #endif
178 
179 #ifndef GSTREAMER_LITE
180 #ifndef HELPER_CONSOLE
181 int _stdcall
182 WinMain (struct HINSTANCE__ *hInstance,
<span class="line-modified">183    struct HINSTANCE__ *hPrevInstance,</span>
<span class="line-modified">184    char               *lpszCmdLine,</span>
<span class="line-modified">185    int                 nCmdShow)</span>
186 #else
187 int
188 main (int ignored_argc, char **ignored_argv)
189 #endif
190 {
191   int child_err_report_fd = -1;
192   int helper_sync_fd = -1;
<span class="line-added">193   int saved_stderr_fd = -1;</span>
194   int i;
195   int fd;
196   int mode;
197   gintptr handle;
198   int saved_errno;
199   gintptr no_error = CHILD_NO_ERROR;
200   gint argv_zero_offset = ARG_PROGRAM;
201   wchar_t **new_wargv;
202   int argc;
203   char **argv;
204   wchar_t **wargv;
205   char c;
206 
207 #if (defined (_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1400)
208   /* set up our empty invalid parameter handler */
209   _invalid_parameter_handler oldHandler, newHandler;
210   newHandler = myInvalidParameterHandler;
211   oldHandler = _set_invalid_parameter_handler(newHandler);
212 
213   /* Disable the message box for assertions. */
</pre>
<hr />
<pre>
239 
240   /* argv[ARG_HELPER_SYNC] is the file descriptor number we read a
241    * byte that tells us it is OK to exit. We have to wait until the
242    * parent allows us to exit, so that the parent has had time to
243    * duplicate the process handle we sent it. Duplicating a handle
244    * from another process works only if that other process exists.
245    */
246   helper_sync_fd = atoi (argv[ARG_HELPER_SYNC]);
247 
248   /* argv[ARG_STDIN..ARG_STDERR] are the file descriptor numbers that
249    * should be dup2&#39;d to 0, 1 and 2. &#39;-&#39; if the corresponding fd
250    * should be left alone, and &#39;z&#39; if it should be connected to the
251    * bit bucket NUL:.
252    */
253   if (argv[ARG_STDIN][0] == &#39;-&#39;)
254     ; /* Nothing */
255   else if (argv[ARG_STDIN][0] == &#39;z&#39;)
256     {
257       fd = open (&quot;NUL:&quot;, O_RDONLY);
258       if (fd != 0)
<span class="line-modified">259   {</span>
<span class="line-modified">260     dup2 (fd, 0);</span>
<span class="line-modified">261     close (fd);</span>
<span class="line-modified">262   }</span>
263     }
264   else
265     {
266       fd = atoi (argv[ARG_STDIN]);
267       if (fd != 0)
<span class="line-modified">268   {</span>
<span class="line-modified">269     dup2 (fd, 0);</span>
<span class="line-modified">270     close (fd);</span>
<span class="line-modified">271   }</span>
272     }
273 
274   if (argv[ARG_STDOUT][0] == &#39;-&#39;)
275     ; /* Nothing */
276   else if (argv[ARG_STDOUT][0] == &#39;z&#39;)
277     {
278       fd = open (&quot;NUL:&quot;, O_WRONLY);
279       if (fd != 1)
<span class="line-modified">280   {</span>
<span class="line-modified">281     dup2 (fd, 1);</span>
<span class="line-modified">282     close (fd);</span>
<span class="line-modified">283   }</span>
284     }
285   else
286     {
287       fd = atoi (argv[ARG_STDOUT]);
288       if (fd != 1)
<span class="line-modified">289   {</span>
<span class="line-modified">290     dup2 (fd, 1);</span>
<span class="line-modified">291     close (fd);</span>
<span class="line-modified">292   }</span>
293     }
294 
<span class="line-added">295   saved_stderr_fd = reopen_noninherited (dup (2), _O_WRONLY);</span>
296   if (argv[ARG_STDERR][0] == &#39;-&#39;)
297     ; /* Nothing */
298   else if (argv[ARG_STDERR][0] == &#39;z&#39;)
299     {
300       fd = open (&quot;NUL:&quot;, O_WRONLY);
301       if (fd != 2)
<span class="line-modified">302   {</span>
<span class="line-modified">303     dup2 (fd, 2);</span>
<span class="line-modified">304     close (fd);</span>
<span class="line-modified">305   }</span>
306     }
307   else
308     {
309       fd = atoi (argv[ARG_STDERR]);
310       if (fd != 2)
<span class="line-modified">311   {</span>
<span class="line-modified">312     dup2 (fd, 2);</span>
<span class="line-modified">313     close (fd);</span>
<span class="line-modified">314   }</span>
315     }
316 
317   /* argv[ARG_WORKING_DIRECTORY] is the directory in which to run the
318    * process.  If &quot;-&quot;, don&#39;t change directory.
319    */
320   if (argv[ARG_WORKING_DIRECTORY][0] == &#39;-&#39; &amp;&amp;
321       argv[ARG_WORKING_DIRECTORY][1] == 0)
322     ; /* Nothing */
323   else if (_wchdir (wargv[ARG_WORKING_DIRECTORY]) &lt; 0)
324     write_err_and_exit (child_err_report_fd, CHILD_CHDIR_FAILED);
325 
326   /* argv[ARG_CLOSE_DESCRIPTORS] is &quot;y&quot; if file descriptors from 3
327    *  upwards should be closed
328    */
329   if (argv[ARG_CLOSE_DESCRIPTORS][0] == &#39;y&#39;)
330     for (i = 3; i &lt; 1000; i++)  /* FIXME real limit? */
<span class="line-modified">331       if (i != child_err_report_fd &amp;&amp; i != helper_sync_fd &amp;&amp; i != saved_stderr_fd)</span>
332         if (_get_osfhandle (i) != -1)
333           close (i);
334 
335   /* We don&#39;t want our child to inherit the error report and
336    * helper sync fds.
337    */
<span class="line-modified">338   child_err_report_fd = reopen_noninherited (child_err_report_fd, _O_WRONLY);</span>
<span class="line-modified">339   helper_sync_fd = reopen_noninherited (helper_sync_fd, _O_RDONLY);</span>
340 
341   /* argv[ARG_WAIT] is &quot;w&quot; to wait for the program to exit */
342   if (argv[ARG_WAIT][0] == &#39;w&#39;)
343     mode = P_WAIT;
344   else
345     mode = P_NOWAIT;
346 
347   /* argv[ARG_USE_PATH] is &quot;y&quot; to use PATH, otherwise not */
348 
349   /* argv[ARG_PROGRAM] is executable file to run,
350    * argv[argv_zero_offset]... is its argv. argv_zero_offset equals
351    * ARG_PROGRAM unless G_SPAWN_FILE_AND_ARGV_ZERO was used, in which
352    * case we have a separate executable name and argv[0].
353    */
354 
355   /* For the program name passed to spawnv(), don&#39;t use the quoted
356    * version.
357    */
358   protect_wargv (argc - argv_zero_offset, wargv + argv_zero_offset, &amp;new_wargv);
359 
360   if (argv[ARG_USE_PATH][0] == &#39;y&#39;)
361     handle = _wspawnvp (mode, wargv[ARG_PROGRAM], (const wchar_t **) new_wargv);
362   else
363     handle = _wspawnv (mode, wargv[ARG_PROGRAM], (const wchar_t **) new_wargv);
364 
365   saved_errno = errno;
366 
<span class="line-added">367   /* Some coverage warnings may be printed on stderr during this process exit.</span>
<span class="line-added">368    * Remove redirection so that they would go to original stderr</span>
<span class="line-added">369    * instead of being treated as part of stderr of child process.</span>
<span class="line-added">370    */</span>
<span class="line-added">371   dup2 (saved_stderr_fd, 2);</span>
372   if (handle == -1 &amp;&amp; saved_errno != 0)
373     {
374       int ec = (saved_errno == ENOENT)
375           ? CHILD_SPAWN_NOENT
376           : CHILD_SPAWN_FAILED;
377       write_err_and_exit (child_err_report_fd, ec);
378     }
379 
380   write (child_err_report_fd, &amp;no_error, sizeof (no_error));
381   write (child_err_report_fd, &amp;handle, sizeof (handle));
382 
383   read (helper_sync_fd, &amp;c, 1);
384 
385   LocalFree (wargv);
386   g_strfreev (argv);
387 
388   return 0;
389 }
390 #endif // GSTREAMER_LITE
</pre>
</td>
</tr>
</table>
<center><a href="gslist.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gspawn-win32.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>