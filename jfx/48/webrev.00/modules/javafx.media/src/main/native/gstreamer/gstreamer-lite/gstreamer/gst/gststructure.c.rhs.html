<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gststructure.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 2003 David A. Schleef &lt;ds@schleef.org&gt;
   3  *
   4  * gststructure.c: lists of { GQuark, GValue } tuples
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 /**
  23  * SECTION:gststructure
  24  * @title: GstStructure
  25  * @short_description: Generic structure containing fields of names and values
  26  * @see_also: #GstCaps, #GstMessage, #GstEvent, #GstQuery
  27  *
  28  * A #GstStructure is a collection of key/value pairs. The keys are expressed
  29  * as GQuarks and the values can be of any GType.
  30  *
  31  * In addition to the key/value pairs, a #GstStructure also has a name. The name
  32  * starts with a letter and can be filled by letters, numbers and any of &quot;/-_.:&quot;.
  33  *
  34  * #GstStructure is used by various GStreamer subsystems to store information
  35  * in a flexible and extensible way. A #GstStructure does not have a refcount
  36  * because it usually is part of a higher level object such as #GstCaps,
  37  * #GstMessage, #GstEvent, #GstQuery. It provides a means to enforce mutability
  38  * using the refcount of the parent with the gst_structure_set_parent_refcount()
  39  * method.
  40  *
  41  * A #GstStructure can be created with gst_structure_new_empty() or
  42  * gst_structure_new(), which both take a name and an optional set of
  43  * key/value pairs along with the types of the values.
  44  *
  45  * Field values can be changed with gst_structure_set_value() or
  46  * gst_structure_set().
  47  *
  48  * Field values can be retrieved with gst_structure_get_value() or the more
  49  * convenient gst_structure_get_*() functions.
  50  *
  51  * Fields can be removed with gst_structure_remove_field() or
  52  * gst_structure_remove_fields().
  53  *
  54  * Strings in structures must be ASCII or UTF-8 encoded. Other encodings are
  55  * not allowed. Strings may be %NULL however.
  56  *
  57  * Be aware that the current #GstCaps / #GstStructure serialization into string
  58  * has limited support for nested #GstCaps / #GstStructure fields. It can only
  59  * support one level of nesting. Using more levels will lead to unexpected
  60  * behavior when using serialization features, such as gst_caps_to_string() or
  61  * gst_value_serialize() and their counterparts.
  62  */
  63 
  64 #ifdef HAVE_CONFIG_H
  65 #include &quot;config.h&quot;
  66 #endif
  67 
  68 /* FIXME 2.0: suppress warnings for deprecated API such as GValueArray
  69  * with newer GLib versions (&gt;= 2.31.0) */
  70 #define GLIB_DISABLE_DEPRECATION_WARNINGS
  71 
  72 #include &lt;string.h&gt;
  73 
  74 #include &quot;gst_private.h&quot;
  75 #include &quot;gstquark.h&quot;
  76 #include &lt;gst/gst.h&gt;
  77 #include &lt;gobject/gvaluecollector.h&gt;
  78 
  79 GST_DEBUG_CATEGORY_STATIC (gst_structure_debug);
  80 #define GST_CAT_DEFAULT gst_structure_debug
  81 
  82 typedef struct _GstStructureField GstStructureField;
  83 
  84 struct _GstStructureField
  85 {
  86   GQuark name;
  87   GValue value;
  88 };
  89 
  90 typedef struct
  91 {
  92   GstStructure s;
  93 
  94   /* owned by parent structure, NULL if no parent */
  95   gint *parent_refcount;
  96 
  97   GArray *fields;
  98 } GstStructureImpl;
  99 
 100 #define GST_STRUCTURE_REFCOUNT(s) (((GstStructureImpl*)(s))-&gt;parent_refcount)
 101 #define GST_STRUCTURE_FIELDS(s) (((GstStructureImpl*)(s))-&gt;fields)
 102 
 103 #define GST_STRUCTURE_FIELD(structure, index) \
 104     &amp;g_array_index(GST_STRUCTURE_FIELDS(structure), GstStructureField, (index))
 105 
 106 #define IS_MUTABLE(structure) \
 107     (!GST_STRUCTURE_REFCOUNT(structure) || \
 108      g_atomic_int_get (GST_STRUCTURE_REFCOUNT(structure)) == 1)
 109 
 110 #define IS_TAGLIST(structure) \
 111     (structure-&gt;name == GST_QUARK (TAGLIST))
 112 
 113 static void gst_structure_set_field (GstStructure * structure,
 114     GstStructureField * field);
 115 static GstStructureField *gst_structure_get_field (const GstStructure *
 116     structure, const gchar * fieldname);
 117 static GstStructureField *gst_structure_id_get_field (const GstStructure *
 118     structure, GQuark field);
 119 static void gst_structure_transform_to_string (const GValue * src_value,
 120     GValue * dest_value);
 121 static GstStructure *gst_structure_copy_conditional (const GstStructure *
 122     structure);
 123 
 124 GType _gst_structure_type = 0;
 125 
 126 
 127 G_DEFINE_BOXED_TYPE (GstStructure, gst_structure,
 128     gst_structure_copy_conditional, gst_structure_free);
 129 
 130 void
 131 _priv_gst_structure_initialize (void)
 132 {
 133   _gst_structure_type = gst_structure_get_type ();
 134 
 135   g_value_register_transform_func (_gst_structure_type, G_TYPE_STRING,
 136       gst_structure_transform_to_string);
 137 
 138   GST_DEBUG_CATEGORY_INIT (gst_structure_debug, &quot;structure&quot;, 0,
 139       &quot;GstStructure debug&quot;);
 140 }
 141 
 142 static GstStructure *
 143 gst_structure_new_id_empty_with_size (GQuark quark, guint prealloc)
 144 {
 145   GstStructureImpl *structure;
 146 
 147   structure = g_slice_new (GstStructureImpl);
 148   ((GstStructure *) structure)-&gt;type = _gst_structure_type;
 149   ((GstStructure *) structure)-&gt;name = quark;
 150   GST_STRUCTURE_REFCOUNT (structure) = NULL;
 151   GST_STRUCTURE_FIELDS (structure) =
 152       g_array_sized_new (FALSE, FALSE, sizeof (GstStructureField), prealloc);
 153 
 154   GST_TRACE (&quot;created structure %p&quot;, structure);
 155 
 156   return GST_STRUCTURE_CAST (structure);
 157 }
 158 
 159 /**
 160  * gst_structure_new_id_empty:
 161  * @quark: name of new structure
 162  *
 163  * Creates a new, empty #GstStructure with the given name as a GQuark.
 164  *
 165  * Free-function: gst_structure_free
 166  *
 167  * Returns: (transfer full): a new, empty #GstStructure
 168  */
 169 GstStructure *
 170 gst_structure_new_id_empty (GQuark quark)
 171 {
 172   g_return_val_if_fail (quark != 0, NULL);
 173 
 174   return gst_structure_new_id_empty_with_size (quark, 0);
 175 }
 176 
 177 #ifndef G_DISABLE_CHECKS
 178 static gboolean
 179 gst_structure_validate_name (const gchar * name)
 180 {
 181   const gchar *s;
 182 
 183   g_return_val_if_fail (name != NULL, FALSE);
 184 
 185   if (G_UNLIKELY (!g_ascii_isalpha (*name))) {
 186     GST_WARNING (&quot;Invalid character &#39;%c&#39; at offset 0 in structure name: %s&quot;,
 187         *name, name);
 188     return FALSE;
 189   }
 190 
 191   /* FIXME: test name string more */
 192   s = &amp;name[1];
 193   while (*s &amp;&amp; (g_ascii_isalnum (*s) || strchr (&quot;/-_.:+&quot;, *s) != NULL))
 194     s++;
 195   if (G_UNLIKELY (*s != &#39;\0&#39;)) {
 196     GST_WARNING (&quot;Invalid character &#39;%c&#39; at offset %&quot; G_GUINTPTR_FORMAT &quot; in&quot;
 197         &quot; structure name: %s&quot;, *s, ((guintptr) s - (guintptr) name), name);
 198     return FALSE;
 199   }
 200 
 201 #ifndef GSTREAMER_LITE
 202   if (strncmp (name, &quot;video/x-raw-&quot;, 12) == 0) {
 203     g_warning (&quot;0.10-style raw video caps are being created. Should be &quot;
 204         &quot;video/x-raw,format=(string).. now.&quot;);
 205   } else if (strncmp (name, &quot;audio/x-raw-&quot;, 12) == 0) {
 206     g_warning (&quot;0.10-style raw audio caps are being created. Should be &quot;
 207         &quot;audio/x-raw,format=(string).. now.&quot;);
 208   }
 209 #endif // GSTREAMER_LITE
 210 
 211   return TRUE;
 212 }
 213 #endif
 214 
 215 /**
 216  * gst_structure_new_empty:
 217  * @name: name of new structure
 218  *
 219  * Creates a new, empty #GstStructure with the given @name.
 220  *
 221  * See gst_structure_set_name() for constraints on the @name parameter.
 222  *
 223  * Free-function: gst_structure_free
 224  *
 225  * Returns: (transfer full): a new, empty #GstStructure
 226  */
 227 GstStructure *
 228 gst_structure_new_empty (const gchar * name)
 229 {
 230   g_return_val_if_fail (gst_structure_validate_name (name), NULL);
 231 
 232   return gst_structure_new_id_empty_with_size (g_quark_from_string (name), 0);
 233 }
 234 
 235 /**
 236  * gst_structure_new:
 237  * @name: name of new structure
 238  * @firstfield: name of first field to set
 239  * @...: additional arguments
 240  *
 241  * Creates a new #GstStructure with the given name.  Parses the
 242  * list of variable arguments and sets fields to the values listed.
 243  * Variable arguments should be passed as field name, field type,
 244  * and value.  Last variable argument should be %NULL.
 245  *
 246  * Free-function: gst_structure_free
 247  *
 248  * Returns: (transfer full): a new #GstStructure
 249  */
 250 GstStructure *
 251 gst_structure_new (const gchar * name, const gchar * firstfield, ...)
 252 {
 253   GstStructure *structure;
 254   va_list varargs;
 255 
 256   va_start (varargs, firstfield);
 257   structure = gst_structure_new_valist (name, firstfield, varargs);
 258   va_end (varargs);
 259 
 260   return structure;
 261 }
 262 
 263 /**
 264  * gst_structure_new_valist:
 265  * @name: name of new structure
 266  * @firstfield: name of first field to set
 267  * @varargs: variable argument list
 268  *
 269  * Creates a new #GstStructure with the given @name.  Structure fields
 270  * are set according to the varargs in a manner similar to
 271  * gst_structure_new().
 272  *
 273  * See gst_structure_set_name() for constraints on the @name parameter.
 274  *
 275  * Free-function: gst_structure_free
 276  *
 277  * Returns: (transfer full): a new #GstStructure
 278  */
 279 GstStructure *
 280 gst_structure_new_valist (const gchar * name,
 281     const gchar * firstfield, va_list varargs)
 282 {
 283   GstStructure *structure;
 284 
 285   structure = gst_structure_new_empty (name);
 286 
 287   if (structure)
 288     gst_structure_set_valist (structure, firstfield, varargs);
 289 
 290   return structure;
 291 }
 292 
 293 /**
 294  * gst_structure_set_parent_refcount:
 295  * @structure: a #GstStructure
 296  * @refcount: (in): a pointer to the parent&#39;s refcount
 297  *
 298  * Sets the parent_refcount field of #GstStructure. This field is used to
 299  * determine whether a structure is mutable or not. This function should only be
 300  * called by code implementing parent objects of #GstStructure, as described in
 301  * the MT Refcounting section of the design documents.
 302  *
 303  * Returns: %TRUE if the parent refcount could be set.
 304  */
 305 gboolean
 306 gst_structure_set_parent_refcount (GstStructure * structure, gint * refcount)
 307 {
 308   g_return_val_if_fail (structure != NULL, FALSE);
 309 
 310   /* if we have a parent_refcount already, we can only clear
 311    * if with a NULL refcount */
 312   if (GST_STRUCTURE_REFCOUNT (structure)) {
 313     if (refcount != NULL) {
 314       g_return_val_if_fail (refcount == NULL, FALSE);
 315       return FALSE;
 316     }
 317   } else {
 318     if (refcount == NULL) {
 319       g_return_val_if_fail (refcount != NULL, FALSE);
 320       return FALSE;
 321     }
 322   }
 323 
 324   GST_STRUCTURE_REFCOUNT (structure) = refcount;
 325 
 326   return TRUE;
 327 }
 328 
 329 /**
 330  * gst_structure_copy:
 331  * @structure: a #GstStructure to duplicate
 332  *
 333  * Duplicates a #GstStructure and all its fields and values.
 334  *
 335  * Free-function: gst_structure_free
 336  *
 337  * Returns: (transfer full): a new #GstStructure.
 338  */
 339 GstStructure *
 340 gst_structure_copy (const GstStructure * structure)
 341 {
 342   GstStructure *new_structure;
 343   GstStructureField *field;
 344   guint i, len;
 345 
 346   g_return_val_if_fail (structure != NULL, NULL);
 347 
 348   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
 349   new_structure = gst_structure_new_id_empty_with_size (structure-&gt;name, len);
 350 
 351   for (i = 0; i &lt; len; i++) {
 352     GstStructureField new_field = { 0 };
 353 
 354     field = GST_STRUCTURE_FIELD (structure, i);
 355 
 356     new_field.name = field-&gt;name;
 357     gst_value_init_and_copy (&amp;new_field.value, &amp;field-&gt;value);
 358     g_array_append_val (GST_STRUCTURE_FIELDS (new_structure), new_field);
 359   }
 360   GST_CAT_TRACE (GST_CAT_PERFORMANCE, &quot;doing copy %p -&gt; %p&quot;,
 361       structure, new_structure);
 362 
 363   return new_structure;
 364 }
 365 
 366 /**
 367  * gst_structure_free:
 368  * @structure: (in) (transfer full): the #GstStructure to free
 369  *
 370  * Frees a #GstStructure and all its fields and values. The structure must not
 371  * have a parent when this function is called.
 372  */
 373 void
 374 gst_structure_free (GstStructure * structure)
 375 {
 376   GstStructureField *field;
 377   guint i, len;
 378 
 379   g_return_if_fail (structure != NULL);
 380   g_return_if_fail (GST_STRUCTURE_REFCOUNT (structure) == NULL);
 381 
 382   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
 383   for (i = 0; i &lt; len; i++) {
 384     field = GST_STRUCTURE_FIELD (structure, i);
 385 
 386     if (G_IS_VALUE (&amp;field-&gt;value)) {
 387       g_value_unset (&amp;field-&gt;value);
 388     }
 389   }
 390   g_array_free (GST_STRUCTURE_FIELDS (structure), TRUE);
 391 #ifdef USE_POISONING
 392   memset (structure, 0xff, sizeof (GstStructure));
 393 #endif
 394   GST_TRACE (&quot;free structure %p&quot;, structure);
 395 
 396   g_slice_free1 (sizeof (GstStructureImpl), structure);
 397 }
 398 
<a name="1" id="anc1"></a><span class="line-added"> 399 /**</span>
<span class="line-added"> 400  * gst_clear_structure: (skip)</span>
<span class="line-added"> 401  * @structure_ptr: a pointer to a #GstStructure reference</span>
<span class="line-added"> 402  *</span>
<span class="line-added"> 403  * Clears a reference to a #GstStructure.</span>
<span class="line-added"> 404  *</span>
<span class="line-added"> 405  * @structure_ptr must not be %NULL.</span>
<span class="line-added"> 406  *</span>
<span class="line-added"> 407  * If the reference is %NULL then this function does nothing.</span>
<span class="line-added"> 408  * Otherwise, the structure is free&#39;d using gst_structure_free() and the</span>
<span class="line-added"> 409  * pointer is set to %NULL.</span>
<span class="line-added"> 410  *</span>
<span class="line-added"> 411  * A macro is also included that allows this function to be used without</span>
<span class="line-added"> 412  * pointer casts.</span>
<span class="line-added"> 413  *</span>
<span class="line-added"> 414  * Since: 1.16</span>
<span class="line-added"> 415  **/</span>
<span class="line-added"> 416 #undef gst_clear_structure</span>
<span class="line-added"> 417 void</span>
<span class="line-added"> 418 gst_clear_structure (GstStructure ** structure_ptr)</span>
<span class="line-added"> 419 {</span>
<span class="line-added"> 420   g_clear_pointer (structure_ptr, gst_structure_free);</span>
<span class="line-added"> 421 }</span>
<span class="line-added"> 422 </span>
 423 /**
 424  * gst_structure_get_name:
 425  * @structure: a #GstStructure
 426  *
 427  * Get the name of @structure as a string.
 428  *
 429  * Returns: the name of the structure.
 430  */
 431 const gchar *
 432 gst_structure_get_name (const GstStructure * structure)
 433 {
 434   g_return_val_if_fail (structure != NULL, NULL);
 435 
 436   return g_quark_to_string (structure-&gt;name);
 437 }
 438 
 439 /**
 440  * gst_structure_has_name:
 441  * @structure: a #GstStructure
 442  * @name: structure name to check for
 443  *
 444  * Checks if the structure has the given name
 445  *
 446  * Returns: %TRUE if @name matches the name of the structure.
 447  */
 448 gboolean
 449 gst_structure_has_name (const GstStructure * structure, const gchar * name)
 450 {
 451   const gchar *structure_name;
 452 
 453   g_return_val_if_fail (structure != NULL, FALSE);
 454   g_return_val_if_fail (name != NULL, FALSE);
 455 
 456   /* getting the string is cheap and comparing short strings is too
 457    * should be faster than getting the quark for name and comparing the quarks
 458    */
 459   structure_name = g_quark_to_string (structure-&gt;name);
 460 
 461   return (structure_name &amp;&amp; strcmp (structure_name, name) == 0);
 462 }
 463 
 464 /**
 465  * gst_structure_get_name_id:
 466  * @structure: a #GstStructure
 467  *
 468  * Get the name of @structure as a GQuark.
 469  *
 470  * Returns: the quark representing the name of the structure.
 471  */
 472 GQuark
 473 gst_structure_get_name_id (const GstStructure * structure)
 474 {
 475   g_return_val_if_fail (structure != NULL, 0);
 476 
 477   return structure-&gt;name;
 478 }
 479 
 480 /**
 481  * gst_structure_set_name:
 482  * @structure: a #GstStructure
 483  * @name: the new name of the structure
 484  *
 485  * Sets the name of the structure to the given @name.  The string
 486  * provided is copied before being used. It must not be empty, start with a
 487  * letter and can be followed by letters, numbers and any of &quot;/-_.:&quot;.
 488  */
 489 void
 490 gst_structure_set_name (GstStructure * structure, const gchar * name)
 491 {
 492   g_return_if_fail (structure != NULL);
 493   g_return_if_fail (IS_MUTABLE (structure));
 494   g_return_if_fail (gst_structure_validate_name (name));
 495 
 496   structure-&gt;name = g_quark_from_string (name);
 497 }
 498 
 499 static inline void
 500 gst_structure_id_set_value_internal (GstStructure * structure, GQuark field,
 501     const GValue * value)
 502 {
 503   GstStructureField gsfield = { 0, {0,} };
 504 
 505   gsfield.name = field;
 506   gst_value_init_and_copy (&amp;gsfield.value, value);
 507 
 508   gst_structure_set_field (structure, &amp;gsfield);
 509 }
 510 
 511 /**
 512  * gst_structure_id_set_value:
 513  * @structure: a #GstStructure
 514  * @field: a #GQuark representing a field
 515  * @value: the new value of the field
 516  *
 517  * Sets the field with the given GQuark @field to @value.  If the field
 518  * does not exist, it is created.  If the field exists, the previous
 519  * value is replaced and freed.
 520  */
 521 void
 522 gst_structure_id_set_value (GstStructure * structure,
 523     GQuark field, const GValue * value)
 524 {
 525 
 526   g_return_if_fail (structure != NULL);
 527   g_return_if_fail (G_IS_VALUE (value));
 528   g_return_if_fail (IS_MUTABLE (structure));
 529 
 530   gst_structure_id_set_value_internal (structure, field, value);
 531 }
 532 
 533 /**
 534  * gst_structure_set_value:
 535  * @structure: a #GstStructure
 536  * @fieldname: the name of the field to set
 537  * @value: the new value of the field
 538  *
 539  * Sets the field with the given name @field to @value.  If the field
 540  * does not exist, it is created.  If the field exists, the previous
 541  * value is replaced and freed.
 542  */
 543 void
 544 gst_structure_set_value (GstStructure * structure,
 545     const gchar * fieldname, const GValue * value)
 546 {
 547   g_return_if_fail (structure != NULL);
 548   g_return_if_fail (fieldname != NULL);
 549   g_return_if_fail (G_IS_VALUE (value));
 550   g_return_if_fail (IS_MUTABLE (structure));
 551 
 552   gst_structure_id_set_value_internal (structure,
 553       g_quark_from_string (fieldname), value);
 554 }
 555 
 556 static inline void
 557 gst_structure_id_take_value_internal (GstStructure * structure, GQuark field,
 558     GValue * value)
 559 {
 560   GstStructureField gsfield = { 0, {0,} };
 561 
 562   gsfield.name = field;
 563   gsfield.value = *value;
 564 
 565   gst_structure_set_field (structure, &amp;gsfield);
 566 
 567   /* we took ownership */
 568 #ifdef USE_POISONING
 569   memset (value, 0, sizeof (GValue));
 570 #else
 571   value-&gt;g_type = G_TYPE_INVALID;
 572 #endif
 573 }
 574 
 575 /**
 576  * gst_structure_id_take_value:
 577  * @structure: a #GstStructure
 578  * @field: a #GQuark representing a field
 579  * @value: (transfer full): the new value of the field
 580  *
 581  * Sets the field with the given GQuark @field to @value.  If the field
 582  * does not exist, it is created.  If the field exists, the previous
 583  * value is replaced and freed.
 584  */
 585 void
 586 gst_structure_id_take_value (GstStructure * structure, GQuark field,
 587     GValue * value)
 588 {
 589   g_return_if_fail (structure != NULL);
 590   g_return_if_fail (G_IS_VALUE (value));
 591   g_return_if_fail (IS_MUTABLE (structure));
 592 
 593   gst_structure_id_take_value_internal (structure, field, value);
 594 }
 595 
 596 /**
 597  * gst_structure_take_value:
 598  * @structure: a #GstStructure
 599  * @fieldname: the name of the field to set
 600  * @value: (transfer full): the new value of the field
 601  *
 602  * Sets the field with the given name @field to @value.  If the field
 603  * does not exist, it is created.  If the field exists, the previous
 604  * value is replaced and freed. The function will take ownership of @value.
 605  */
 606 void
 607 gst_structure_take_value (GstStructure * structure, const gchar * fieldname,
 608     GValue * value)
 609 {
 610   g_return_if_fail (structure != NULL);
 611   g_return_if_fail (fieldname != NULL);
 612   g_return_if_fail (G_IS_VALUE (value));
 613   g_return_if_fail (IS_MUTABLE (structure));
 614 
 615   gst_structure_id_take_value_internal (structure,
 616       g_quark_from_string (fieldname), value);
 617 }
 618 
 619 static void
 620 gst_structure_set_valist_internal (GstStructure * structure,
 621     const gchar * fieldname, va_list varargs)
 622 {
 623   gchar *err = NULL;
 624   GType type;
 625 
 626   while (fieldname) {
 627     GstStructureField field = { 0 };
 628 
 629     field.name = g_quark_from_string (fieldname);
 630 
 631     type = va_arg (varargs, GType);
 632 
 633     G_VALUE_COLLECT_INIT (&amp;field.value, type, varargs, 0, &amp;err);
 634     if (G_UNLIKELY (err)) {
 635       g_critical (&quot;%s&quot;, err);
<a name="2" id="anc2"></a><span class="line-added"> 636       g_free (err);</span>
 637       return;
 638     }
 639     gst_structure_set_field (structure, &amp;field);
 640 
 641     fieldname = va_arg (varargs, gchar *);
 642   }
 643 }
 644 
 645 /**
 646  * gst_structure_set:
 647  * @structure: a #GstStructure
 648  * @fieldname: the name of the field to set
 649  * @...: variable arguments
 650  *
 651  * Parses the variable arguments and sets fields accordingly. Fields that
 652  * weren&#39;t already part of the structure are added as needed.
 653  * Variable arguments should be in the form field name, field type
 654  * (as a GType), value(s).  The last variable argument should be %NULL.
 655  */
 656 void
 657 gst_structure_set (GstStructure * structure, const gchar * field, ...)
 658 {
 659   va_list varargs;
 660 
 661   g_return_if_fail (structure != NULL);
 662   g_return_if_fail (IS_MUTABLE (structure) || field == NULL);
 663 
 664   va_start (varargs, field);
 665   gst_structure_set_valist_internal (structure, field, varargs);
 666   va_end (varargs);
 667 }
 668 
 669 /**
 670  * gst_structure_set_valist:
 671  * @structure: a #GstStructure
 672  * @fieldname: the name of the field to set
 673  * @varargs: variable arguments
 674  *
 675  * va_list form of gst_structure_set().
 676  */
 677 void
 678 gst_structure_set_valist (GstStructure * structure,
 679     const gchar * fieldname, va_list varargs)
 680 {
 681   g_return_if_fail (structure != NULL);
 682   g_return_if_fail (IS_MUTABLE (structure));
 683 
 684   gst_structure_set_valist_internal (structure, fieldname, varargs);
 685 }
 686 
 687 static void
 688 gst_structure_id_set_valist_internal (GstStructure * structure,
 689     GQuark fieldname, va_list varargs)
 690 {
 691   gchar *err = NULL;
 692   GType type;
 693 
 694   while (fieldname) {
 695     GstStructureField field = { 0 };
 696 
 697     field.name = fieldname;
 698     type = va_arg (varargs, GType);
 699 
 700     G_VALUE_COLLECT_INIT (&amp;field.value, type, varargs, 0, &amp;err);
 701     if (G_UNLIKELY (err)) {
 702       g_critical (&quot;%s&quot;, err);
<a name="3" id="anc3"></a><span class="line-added"> 703       g_free (err);</span>
 704       return;
 705     }
 706     gst_structure_set_field (structure, &amp;field);
 707 
 708     fieldname = va_arg (varargs, GQuark);
 709   }
 710 }
 711 
 712 /**
 713  * gst_structure_id_set:
 714  * @structure: a #GstStructure
 715  * @fieldname: the GQuark for the name of the field to set
 716  * @...: variable arguments
 717  *
 718  * Identical to gst_structure_set, except that field names are
 719  * passed using the GQuark for the field name. This allows more efficient
 720  * setting of the structure if the caller already knows the associated
 721  * quark values.
 722  * The last variable argument must be %NULL.
 723  */
 724 void
 725 gst_structure_id_set (GstStructure * structure, GQuark field, ...)
 726 {
 727   va_list varargs;
 728 
 729   g_return_if_fail (structure != NULL);
 730 
 731   va_start (varargs, field);
 732   gst_structure_id_set_valist_internal (structure, field, varargs);
 733   va_end (varargs);
 734 }
 735 
 736 /**
 737  * gst_structure_id_set_valist:
 738  * @structure: a #GstStructure
 739  * @fieldname: the name of the field to set
 740  * @varargs: variable arguments
 741  *
 742  * va_list form of gst_structure_id_set().
 743  */
 744 void
 745 gst_structure_id_set_valist (GstStructure * structure,
 746     GQuark fieldname, va_list varargs)
 747 {
 748   g_return_if_fail (structure != NULL);
 749   g_return_if_fail (IS_MUTABLE (structure));
 750 
 751   gst_structure_id_set_valist_internal (structure, fieldname, varargs);
 752 }
 753 
 754 /**
 755  * gst_structure_new_id:
 756  * @name_quark: name of new structure
 757  * @field_quark: the GQuark for the name of the field to set
 758  * @...: variable arguments
 759  *
 760  * Creates a new #GstStructure with the given name as a GQuark, followed by
 761  * fieldname quark, GType, argument(s) &quot;triplets&quot; in the same format as
 762  * gst_structure_id_set(). Basically a convenience wrapper around
 763  * gst_structure_new_id_empty() and gst_structure_id_set().
 764  *
 765  * The last variable argument must be %NULL (or 0).
 766  *
 767  * Free-function: gst_structure_free
 768  *
 769  * Returns: (transfer full): a new #GstStructure
 770  */
 771 GstStructure *
 772 gst_structure_new_id (GQuark name_quark, GQuark field_quark, ...)
 773 {
 774   GstStructure *s;
 775   va_list varargs;
 776 
 777   g_return_val_if_fail (name_quark != 0, NULL);
 778   g_return_val_if_fail (field_quark != 0, NULL);
 779 
 780   s = gst_structure_new_id_empty (name_quark);
 781 
 782   va_start (varargs, field_quark);
 783   gst_structure_id_set_valist_internal (s, field_quark, varargs);
 784   va_end (varargs);
 785 
 786   return s;
 787 }
 788 
 789 #if GST_VERSION_NANO == 1
 790 #define GIT_G_WARNING g_warning
 791 #else
 792 #define GIT_G_WARNING GST_WARNING
 793 #endif
 794 
 795 /* If the structure currently contains a field with the same name, it is
 796  * replaced with the provided field. Otherwise, the field is added to the
 797  * structure. The field&#39;s value is not deeply copied.
 798  */
 799 static void
 800 gst_structure_set_field (GstStructure * structure, GstStructureField * field)
 801 {
 802   GstStructureField *f;
 803   GType field_value_type;
 804   guint i, len;
 805 
 806   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
 807 
 808   field_value_type = G_VALUE_TYPE (&amp;field-&gt;value);
 809   if (field_value_type == G_TYPE_STRING) {
 810     const gchar *s;
 811 
 812     s = g_value_get_string (&amp;field-&gt;value);
 813     /* only check for NULL strings in taglists, as they are allowed in message
 814      * structs, e.g. error message debug strings */
 815     if (G_UNLIKELY (IS_TAGLIST (structure) &amp;&amp; (s == NULL || *s == &#39;\0&#39;))) {
 816       if (s == NULL) {
 817         GIT_G_WARNING (&quot;Trying to set NULL string on field &#39;%s&#39; on taglist. &quot;
 818             &quot;Please file a bug.&quot;, g_quark_to_string (field-&gt;name));
 819         g_value_unset (&amp;field-&gt;value);
 820         return;
 821       } else {
 822         /* empty strings never make sense */
 823         GIT_G_WARNING (&quot;Trying to set empty string on taglist field &#39;%s&#39;. &quot;
 824             &quot;Please file a bug.&quot;, g_quark_to_string (field-&gt;name));
 825         g_value_unset (&amp;field-&gt;value);
 826         return;
 827       }
 828     } else if (G_UNLIKELY (s != NULL &amp;&amp; !g_utf8_validate (s, -1, NULL))) {
 829       g_warning (&quot;Trying to set string on %s field &#39;%s&#39;, but string is not &quot;
 830           &quot;valid UTF-8. Please file a bug.&quot;,
 831           IS_TAGLIST (structure) ? &quot;taglist&quot; : &quot;structure&quot;,
 832           g_quark_to_string (field-&gt;name));
 833       g_value_unset (&amp;field-&gt;value);
 834       return;
 835     }
 836   } else if (G_UNLIKELY (field_value_type == G_TYPE_DATE)) {
 837     const GDate *d;
 838 
 839     d = g_value_get_boxed (&amp;field-&gt;value);
 840     /* only check for NULL GDates in taglists, as they might make sense
 841      * in other, generic structs */
 842     if (G_UNLIKELY ((IS_TAGLIST (structure) &amp;&amp; d == NULL))) {
 843       GIT_G_WARNING (&quot;Trying to set NULL GDate on field &#39;%s&#39; on taglist. &quot;
 844           &quot;Please file a bug.&quot;, g_quark_to_string (field-&gt;name));
 845       g_value_unset (&amp;field-&gt;value);
 846       return;
 847     } else if (G_UNLIKELY (d != NULL &amp;&amp; !g_date_valid (d))) {
 848       g_warning
 849           (&quot;Trying to set invalid GDate on %s field &#39;%s&#39;. Please file a bug.&quot;,
 850           IS_TAGLIST (structure) ? &quot;taglist&quot; : &quot;structure&quot;,
 851           g_quark_to_string (field-&gt;name));
 852       g_value_unset (&amp;field-&gt;value);
 853       return;
 854     }
 855   }
 856 
 857   for (i = 0; i &lt; len; i++) {
 858     f = GST_STRUCTURE_FIELD (structure, i);
 859 
 860     if (G_UNLIKELY (f-&gt;name == field-&gt;name)) {
 861       g_value_unset (&amp;f-&gt;value);
 862       memcpy (f, field, sizeof (GstStructureField));
 863       return;
 864     }
 865   }
 866 
 867   g_array_append_val (GST_STRUCTURE_FIELDS (structure), *field);
 868 }
 869 
 870 /* If there is no field with the given ID, NULL is returned.
 871  */
 872 static GstStructureField *
 873 gst_structure_id_get_field (const GstStructure * structure, GQuark field_id)
 874 {
 875   GstStructureField *field;
 876   guint i, len;
 877 
 878   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
 879 
 880   for (i = 0; i &lt; len; i++) {
 881     field = GST_STRUCTURE_FIELD (structure, i);
 882 
 883     if (G_UNLIKELY (field-&gt;name == field_id))
 884       return field;
 885   }
 886 
 887   return NULL;
 888 }
 889 
 890 /* If there is no field with the given ID, NULL is returned.
 891  */
 892 static GstStructureField *
 893 gst_structure_get_field (const GstStructure * structure,
 894     const gchar * fieldname)
 895 {
 896   g_return_val_if_fail (structure != NULL, NULL);
 897   g_return_val_if_fail (fieldname != NULL, NULL);
 898 
 899   return gst_structure_id_get_field (structure,
 900       g_quark_from_string (fieldname));
 901 }
 902 
 903 /**
 904  * gst_structure_get_value:
 905  * @structure: a #GstStructure
 906  * @fieldname: the name of the field to get
 907  *
 908  * Get the value of the field with name @fieldname.
 909  *
 910  * Returns: (nullable): the #GValue corresponding to the field with the given
 911  * name.
 912  */
 913 const GValue *
 914 gst_structure_get_value (const GstStructure * structure,
 915     const gchar * fieldname)
 916 {
 917   GstStructureField *field;
 918 
 919   g_return_val_if_fail (structure != NULL, NULL);
 920   g_return_val_if_fail (fieldname != NULL, NULL);
 921 
 922   field = gst_structure_get_field (structure, fieldname);
 923   if (field == NULL)
 924     return NULL;
 925 
 926   return &amp;field-&gt;value;
 927 }
 928 
 929 /**
 930  * gst_structure_id_get_value:
 931  * @structure: a #GstStructure
 932  * @field: the #GQuark of the field to get
 933  *
 934  * Get the value of the field with GQuark @field.
 935  *
 936  * Returns: (nullable): the #GValue corresponding to the field with the given
 937  * name identifier.
 938  */
 939 const GValue *
 940 gst_structure_id_get_value (const GstStructure * structure, GQuark field)
 941 {
 942   GstStructureField *gsfield;
 943 
 944   g_return_val_if_fail (structure != NULL, NULL);
 945 
 946   gsfield = gst_structure_id_get_field (structure, field);
 947   if (gsfield == NULL)
 948     return NULL;
 949 
 950   return &amp;gsfield-&gt;value;
 951 }
 952 
 953 /**
 954  * gst_structure_remove_field:
 955  * @structure: a #GstStructure
 956  * @fieldname: the name of the field to remove
 957  *
 958  * Removes the field with the given name.  If the field with the given
 959  * name does not exist, the structure is unchanged.
 960  */
 961 void
 962 gst_structure_remove_field (GstStructure * structure, const gchar * fieldname)
 963 {
 964   GstStructureField *field;
 965   GQuark id;
 966   guint i, len;
 967 
 968   g_return_if_fail (structure != NULL);
 969   g_return_if_fail (fieldname != NULL);
 970   g_return_if_fail (IS_MUTABLE (structure));
 971 
 972   id = g_quark_from_string (fieldname);
 973   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
 974 
 975   for (i = 0; i &lt; len; i++) {
 976     field = GST_STRUCTURE_FIELD (structure, i);
 977 
 978     if (field-&gt;name == id) {
 979       if (G_IS_VALUE (&amp;field-&gt;value)) {
 980         g_value_unset (&amp;field-&gt;value);
 981       }
 982       GST_STRUCTURE_FIELDS (structure) =
 983           g_array_remove_index (GST_STRUCTURE_FIELDS (structure), i);
 984       return;
 985     }
 986   }
 987 }
 988 
 989 /**
 990  * gst_structure_remove_fields:
 991  * @structure: a #GstStructure
 992  * @fieldname: the name of the field to remove
 993  * @...: %NULL-terminated list of more fieldnames to remove
 994  *
 995  * Removes the fields with the given names. If a field does not exist, the
 996  * argument is ignored.
 997  */
 998 void
 999 gst_structure_remove_fields (GstStructure * structure,
1000     const gchar * fieldname, ...)
1001 {
1002   va_list varargs;
1003 
1004   g_return_if_fail (structure != NULL);
1005   g_return_if_fail (fieldname != NULL);
1006   /* mutability checked in remove_field */
1007 
1008   va_start (varargs, fieldname);
1009   gst_structure_remove_fields_valist (structure, fieldname, varargs);
1010   va_end (varargs);
1011 }
1012 
1013 /**
1014  * gst_structure_remove_fields_valist:
1015  * @structure: a #GstStructure
1016  * @fieldname: the name of the field to remove
1017  * @varargs: %NULL-terminated list of more fieldnames to remove
1018  *
1019  * va_list form of gst_structure_remove_fields().
1020  */
1021 void
1022 gst_structure_remove_fields_valist (GstStructure * structure,
1023     const gchar * fieldname, va_list varargs)
1024 {
1025   gchar *field = (gchar *) fieldname;
1026 
1027   g_return_if_fail (structure != NULL);
1028   g_return_if_fail (fieldname != NULL);
1029   /* mutability checked in remove_field */
1030 
1031   while (field) {
1032     gst_structure_remove_field (structure, field);
1033     field = va_arg (varargs, char *);
1034   }
1035 }
1036 
1037 /**
1038  * gst_structure_remove_all_fields:
1039  * @structure: a #GstStructure
1040  *
1041  * Removes all fields in a GstStructure.
1042  */
1043 void
1044 gst_structure_remove_all_fields (GstStructure * structure)
1045 {
1046   GstStructureField *field;
1047   int i;
1048 
1049   g_return_if_fail (structure != NULL);
1050   g_return_if_fail (IS_MUTABLE (structure));
1051 
1052   for (i = GST_STRUCTURE_FIELDS (structure)-&gt;len - 1; i &gt;= 0; i--) {
1053     field = GST_STRUCTURE_FIELD (structure, i);
1054 
1055     if (G_IS_VALUE (&amp;field-&gt;value)) {
1056       g_value_unset (&amp;field-&gt;value);
1057     }
1058     GST_STRUCTURE_FIELDS (structure) =
1059         g_array_remove_index (GST_STRUCTURE_FIELDS (structure), i);
1060   }
1061 }
1062 
1063 /**
1064  * gst_structure_get_field_type:
1065  * @structure: a #GstStructure
1066  * @fieldname: the name of the field
1067  *
1068  * Finds the field with the given name, and returns the type of the
1069  * value it contains.  If the field is not found, G_TYPE_INVALID is
1070  * returned.
1071  *
1072  * Returns: the #GValue of the field
1073  */
1074 GType
1075 gst_structure_get_field_type (const GstStructure * structure,
1076     const gchar * fieldname)
1077 {
1078   GstStructureField *field;
1079 
1080   g_return_val_if_fail (structure != NULL, G_TYPE_INVALID);
1081   g_return_val_if_fail (fieldname != NULL, G_TYPE_INVALID);
1082 
1083   field = gst_structure_get_field (structure, fieldname);
1084   if (field == NULL)
1085     return G_TYPE_INVALID;
1086 
1087   return G_VALUE_TYPE (&amp;field-&gt;value);
1088 }
1089 
1090 /**
1091  * gst_structure_n_fields:
1092  * @structure: a #GstStructure
1093  *
1094  * Get the number of fields in the structure.
1095  *
1096  * Returns: the number of fields in the structure
1097  */
1098 gint
1099 gst_structure_n_fields (const GstStructure * structure)
1100 {
1101   g_return_val_if_fail (structure != NULL, 0);
1102 
1103   return GST_STRUCTURE_FIELDS (structure)-&gt;len;
1104 }
1105 
1106 /**
1107  * gst_structure_nth_field_name:
1108  * @structure: a #GstStructure
1109  * @index: the index to get the name of
1110  *
1111  * Get the name of the given field number, counting from 0 onwards.
1112  *
1113  * Returns: the name of the given field number
1114  */
1115 const gchar *
1116 gst_structure_nth_field_name (const GstStructure * structure, guint index)
1117 {
1118   GstStructureField *field;
1119 
1120   g_return_val_if_fail (structure != NULL, NULL);
1121   g_return_val_if_fail (index &lt; GST_STRUCTURE_FIELDS (structure)-&gt;len, NULL);
1122 
1123   field = GST_STRUCTURE_FIELD (structure, index);
1124 
1125   return g_quark_to_string (field-&gt;name);
1126 }
1127 
1128 /**
1129  * gst_structure_foreach:
1130  * @structure: a #GstStructure
1131  * @func: (scope call): a function to call for each field
1132  * @user_data: (closure): private data
1133  *
1134  * Calls the provided function once for each field in the #GstStructure. The
1135  * function must not modify the fields. Also see gst_structure_map_in_place()
1136  * and gst_structure_filter_and_map_in_place().
1137  *
1138  * Returns: %TRUE if the supplied function returns %TRUE For each of the fields,
1139  * %FALSE otherwise.
1140  */
1141 gboolean
1142 gst_structure_foreach (const GstStructure * structure,
1143     GstStructureForeachFunc func, gpointer user_data)
1144 {
1145   guint i, len;
1146   GstStructureField *field;
1147   gboolean ret;
1148 
1149   g_return_val_if_fail (structure != NULL, FALSE);
1150   g_return_val_if_fail (func != NULL, FALSE);
1151 
1152   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
1153 
1154   for (i = 0; i &lt; len; i++) {
1155     field = GST_STRUCTURE_FIELD (structure, i);
1156 
1157     ret = func (field-&gt;name, &amp;field-&gt;value, user_data);
1158     if (G_UNLIKELY (!ret))
1159       return FALSE;
1160   }
1161 
1162   return TRUE;
1163 }
1164 
1165 /**
1166  * gst_structure_map_in_place:
1167  * @structure: a #GstStructure
1168  * @func: (scope call): a function to call for each field
1169  * @user_data: (closure): private data
1170  *
1171  * Calls the provided function once for each field in the #GstStructure. In
1172  * contrast to gst_structure_foreach(), the function may modify but not delete the
1173  * fields. The structure must be mutable.
1174  *
1175  * Returns: %TRUE if the supplied function returns %TRUE For each of the fields,
1176  * %FALSE otherwise.
1177  */
1178 gboolean
1179 gst_structure_map_in_place (GstStructure * structure,
1180     GstStructureMapFunc func, gpointer user_data)
1181 {
1182   guint i, len;
1183   GstStructureField *field;
1184   gboolean ret;
1185 
1186   g_return_val_if_fail (structure != NULL, FALSE);
1187   g_return_val_if_fail (IS_MUTABLE (structure), FALSE);
1188   g_return_val_if_fail (func != NULL, FALSE);
1189   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
1190 
1191   for (i = 0; i &lt; len; i++) {
1192     field = GST_STRUCTURE_FIELD (structure, i);
1193 
1194     ret = func (field-&gt;name, &amp;field-&gt;value, user_data);
1195     if (!ret)
1196       return FALSE;
1197   }
1198 
1199   return TRUE;
1200 }
1201 
1202 /**
1203  * gst_structure_filter_and_map_in_place:
1204  * @structure: a #GstStructure
1205  * @func: (scope call): a function to call for each field
1206  * @user_data: (closure): private data
1207  *
1208  * Calls the provided function once for each field in the #GstStructure. In
1209  * contrast to gst_structure_foreach(), the function may modify the fields.
1210  * In contrast to gst_structure_map_in_place(), the field is removed from
1211  * the structure if %FALSE is returned from the function.
1212  * The structure must be mutable.
1213  *
1214  * Since: 1.6
1215  */
1216 void
1217 gst_structure_filter_and_map_in_place (GstStructure * structure,
1218     GstStructureFilterMapFunc func, gpointer user_data)
1219 {
1220   guint i, len;
1221   GstStructureField *field;
1222   gboolean ret;
1223 
1224   g_return_if_fail (structure != NULL);
1225   g_return_if_fail (IS_MUTABLE (structure));
1226   g_return_if_fail (func != NULL);
1227   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
1228 
1229   for (i = 0; i &lt; len;) {
1230     field = GST_STRUCTURE_FIELD (structure, i);
1231 
1232     ret = func (field-&gt;name, &amp;field-&gt;value, user_data);
1233 
1234     if (!ret) {
1235       if (G_IS_VALUE (&amp;field-&gt;value)) {
1236         g_value_unset (&amp;field-&gt;value);
1237       }
1238       GST_STRUCTURE_FIELDS (structure) =
1239           g_array_remove_index (GST_STRUCTURE_FIELDS (structure), i);
1240       len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
1241     } else {
1242       i++;
1243     }
1244   }
1245 }
1246 
1247 /**
1248  * gst_structure_id_has_field:
1249  * @structure: a #GstStructure
1250  * @field: #GQuark of the field name
1251  *
1252  * Check if @structure contains a field named @field.
1253  *
1254  * Returns: %TRUE if the structure contains a field with the given name
1255  */
1256 gboolean
1257 gst_structure_id_has_field (const GstStructure * structure, GQuark field)
1258 {
1259   GstStructureField *f;
1260 
1261   g_return_val_if_fail (structure != NULL, FALSE);
1262   g_return_val_if_fail (field != 0, FALSE);
1263 
1264   f = gst_structure_id_get_field (structure, field);
1265 
1266   return (f != NULL);
1267 }
1268 
1269 /**
1270  * gst_structure_has_field:
1271  * @structure: a #GstStructure
1272  * @fieldname: the name of a field
1273  *
1274  * Check if @structure contains a field named @fieldname.
1275  *
1276  * Returns: %TRUE if the structure contains a field with the given name
1277  */
1278 gboolean
1279 gst_structure_has_field (const GstStructure * structure,
1280     const gchar * fieldname)
1281 {
1282   g_return_val_if_fail (structure != NULL, FALSE);
1283   g_return_val_if_fail (fieldname != NULL, FALSE);
1284 
1285   return gst_structure_id_has_field (structure,
1286       g_quark_from_string (fieldname));
1287 }
1288 
1289 /**
1290  * gst_structure_id_has_field_typed:
1291  * @structure: a #GstStructure
1292  * @field: #GQuark of the field name
1293  * @type: the type of a value
1294  *
1295  * Check if @structure contains a field named @field and with GType @type.
1296  *
1297  * Returns: %TRUE if the structure contains a field with the given name and type
1298  */
1299 gboolean
1300 gst_structure_id_has_field_typed (const GstStructure * structure,
1301     GQuark field, GType type)
1302 {
1303   GstStructureField *f;
1304 
1305   g_return_val_if_fail (structure != NULL, FALSE);
1306   g_return_val_if_fail (field != 0, FALSE);
1307 
1308   f = gst_structure_id_get_field (structure, field);
1309   if (f == NULL)
1310     return FALSE;
1311 
1312   return (G_VALUE_TYPE (&amp;f-&gt;value) == type);
1313 }
1314 
1315 /**
1316  * gst_structure_has_field_typed:
1317  * @structure: a #GstStructure
1318  * @fieldname: the name of a field
1319  * @type: the type of a value
1320  *
1321  * Check if @structure contains a field named @fieldname and with GType @type.
1322  *
1323  * Returns: %TRUE if the structure contains a field with the given name and type
1324  */
1325 gboolean
1326 gst_structure_has_field_typed (const GstStructure * structure,
1327     const gchar * fieldname, GType type)
1328 {
1329   g_return_val_if_fail (structure != NULL, FALSE);
1330   g_return_val_if_fail (fieldname != NULL, FALSE);
1331 
1332   return gst_structure_id_has_field_typed (structure,
1333       g_quark_from_string (fieldname), type);
1334 }
1335 
1336 /* utility functions */
1337 
1338 /**
1339  * gst_structure_get_boolean:
1340  * @structure: a #GstStructure
1341  * @fieldname: the name of a field
1342  * @value: (out): a pointer to a #gboolean to set
1343  *
1344  * Sets the boolean pointed to by @value corresponding to the value of the
1345  * given field.  Caller is responsible for making sure the field exists
1346  * and has the correct type.
1347  *
1348  * Returns: %TRUE if the value could be set correctly. If there was no field
1349  * with @fieldname or the existing field did not contain a boolean, this
1350  * function returns %FALSE.
1351  */
1352 gboolean
1353 gst_structure_get_boolean (const GstStructure * structure,
1354     const gchar * fieldname, gboolean * value)
1355 {
1356   GstStructureField *field;
1357 
1358   g_return_val_if_fail (structure != NULL, FALSE);
1359   g_return_val_if_fail (fieldname != NULL, FALSE);
1360 
1361   field = gst_structure_get_field (structure, fieldname);
1362 
1363   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != G_TYPE_BOOLEAN)
1364     return FALSE;
1365 
1366   *value = gst_g_value_get_boolean_unchecked (&amp;field-&gt;value);
1367 
1368   return TRUE;
1369 }
1370 
1371 /**
1372  * gst_structure_get_int:
1373  * @structure: a #GstStructure
1374  * @fieldname: the name of a field
1375  * @value: (out): a pointer to an int to set
1376  *
1377  * Sets the int pointed to by @value corresponding to the value of the
1378  * given field.  Caller is responsible for making sure the field exists
1379  * and has the correct type.
1380  *
1381  * Returns: %TRUE if the value could be set correctly. If there was no field
1382  * with @fieldname or the existing field did not contain an int, this function
1383  * returns %FALSE.
1384  */
1385 gboolean
1386 gst_structure_get_int (const GstStructure * structure,
1387     const gchar * fieldname, gint * value)
1388 {
1389   GstStructureField *field;
1390 
1391   g_return_val_if_fail (structure != NULL, FALSE);
1392   g_return_val_if_fail (fieldname != NULL, FALSE);
1393   g_return_val_if_fail (value != NULL, FALSE);
1394 
1395   field = gst_structure_get_field (structure, fieldname);
1396 
1397   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != G_TYPE_INT)
1398     return FALSE;
1399 
1400   *value = gst_g_value_get_int_unchecked (&amp;field-&gt;value);
1401 
1402   return TRUE;
1403 }
1404 
1405 /**
1406  * gst_structure_get_uint:
1407  * @structure: a #GstStructure
1408  * @fieldname: the name of a field
1409  * @value: (out): a pointer to a uint to set
1410  *
1411  * Sets the uint pointed to by @value corresponding to the value of the
1412  * given field.  Caller is responsible for making sure the field exists
1413  * and has the correct type.
1414  *
1415  * Returns: %TRUE if the value could be set correctly. If there was no field
1416  * with @fieldname or the existing field did not contain a uint, this function
1417  * returns %FALSE.
1418  */
1419 gboolean
1420 gst_structure_get_uint (const GstStructure * structure,
1421     const gchar * fieldname, guint * value)
1422 {
1423   GstStructureField *field;
1424 
1425   g_return_val_if_fail (structure != NULL, FALSE);
1426   g_return_val_if_fail (fieldname != NULL, FALSE);
1427   g_return_val_if_fail (value != NULL, FALSE);
1428 
1429   field = gst_structure_get_field (structure, fieldname);
1430 
1431   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != G_TYPE_UINT)
1432     return FALSE;
1433 
1434   *value = gst_g_value_get_uint_unchecked (&amp;field-&gt;value);
1435 
1436   return TRUE;
1437 }
1438 
1439 /**
1440  * gst_structure_get_int64:
1441  * @structure: a #GstStructure
1442  * @fieldname: the name of a field
1443  * @value: (out): a pointer to a #gint64 to set
1444  *
1445  * Sets the #gint64 pointed to by @value corresponding to the value of the
1446  * given field. Caller is responsible for making sure the field exists
1447  * and has the correct type.
1448  *
1449  * Returns: %TRUE if the value could be set correctly. If there was no field
1450  * with @fieldname or the existing field did not contain a #gint64, this function
1451  * returns %FALSE.
1452  *
1453  * Since: 1.4
1454  */
1455 gboolean
1456 gst_structure_get_int64 (const GstStructure * structure,
1457     const gchar * fieldname, gint64 * value)
1458 {
1459   GstStructureField *field;
1460 
1461   g_return_val_if_fail (structure != NULL, FALSE);
1462   g_return_val_if_fail (fieldname != NULL, FALSE);
1463   g_return_val_if_fail (value != NULL, FALSE);
1464 
1465   field = gst_structure_get_field (structure, fieldname);
1466 
1467   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != G_TYPE_INT64)
1468     return FALSE;
1469 
1470   *value = gst_g_value_get_int64_unchecked (&amp;field-&gt;value);
1471 
1472   return TRUE;
1473 }
1474 
1475 /**
1476  * gst_structure_get_uint64:
1477  * @structure: a #GstStructure
1478  * @fieldname: the name of a field
1479  * @value: (out): a pointer to a #guint64 to set
1480  *
1481  * Sets the #guint64 pointed to by @value corresponding to the value of the
1482  * given field. Caller is responsible for making sure the field exists
1483  * and has the correct type.
1484  *
1485  * Returns: %TRUE if the value could be set correctly. If there was no field
1486  * with @fieldname or the existing field did not contain a #guint64, this function
1487  * returns %FALSE.
1488  *
1489  * Since: 1.4
1490  */
1491 gboolean
1492 gst_structure_get_uint64 (const GstStructure * structure,
1493     const gchar * fieldname, guint64 * value)
1494 {
1495   GstStructureField *field;
1496 
1497   g_return_val_if_fail (structure != NULL, FALSE);
1498   g_return_val_if_fail (fieldname != NULL, FALSE);
1499   g_return_val_if_fail (value != NULL, FALSE);
1500 
1501   field = gst_structure_get_field (structure, fieldname);
1502 
1503   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != G_TYPE_UINT64)
1504     return FALSE;
1505 
1506   *value = gst_g_value_get_uint64_unchecked (&amp;field-&gt;value);
1507 
1508   return TRUE;
1509 }
1510 
1511 /**
1512  * gst_structure_get_date:
1513  * @structure: a #GstStructure
1514  * @fieldname: the name of a field
1515  * @value: (out callee-allocates): a pointer to a #GDate to set
1516  *
1517  * Sets the date pointed to by @value corresponding to the date of the
1518  * given field.  Caller is responsible for making sure the field exists
1519  * and has the correct type.
1520  *
1521  * On success @value will point to a newly-allocated copy of the date which
1522  * should be freed with g_date_free() when no longer needed (note: this is
1523  * inconsistent with e.g. gst_structure_get_string() which doesn&#39;t return a
1524  * copy of the string).
1525  *
1526  * Returns: %TRUE if the value could be set correctly. If there was no field
1527  * with @fieldname or the existing field did not contain a data, this function
1528  * returns %FALSE.
1529  */
1530 gboolean
1531 gst_structure_get_date (const GstStructure * structure, const gchar * fieldname,
1532     GDate ** value)
1533 {
1534   GstStructureField *field;
1535 
1536   g_return_val_if_fail (structure != NULL, FALSE);
1537   g_return_val_if_fail (fieldname != NULL, FALSE);
1538   g_return_val_if_fail (value != NULL, FALSE);
1539 
1540   field = gst_structure_get_field (structure, fieldname);
1541 
1542   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != G_TYPE_DATE)
1543     return FALSE;
1544 
1545   /* FIXME: 2.0 g_value_dup_boxed() -&gt; g_value_get_boxed() */
1546   *value = g_value_dup_boxed (&amp;field-&gt;value);
1547 
1548   return TRUE;
1549 }
1550 
1551 /**
1552  * gst_structure_get_date_time:
1553  * @structure: a #GstStructure
1554  * @fieldname: the name of a field
1555  * @value: (out callee-allocates): a pointer to a #GstDateTime to set
1556  *
1557  * Sets the datetime pointed to by @value corresponding to the datetime of the
1558  * given field. Caller is responsible for making sure the field exists
1559  * and has the correct type.
1560  *
1561  * On success @value will point to a reference of the datetime which
1562  * should be unreffed with gst_date_time_unref() when no longer needed
1563  * (note: this is inconsistent with e.g. gst_structure_get_string()
1564  * which doesn&#39;t return a copy of the string).
1565  *
1566  * Returns: %TRUE if the value could be set correctly. If there was no field
1567  * with @fieldname or the existing field did not contain a data, this function
1568  * returns %FALSE.
1569  */
1570 gboolean
1571 gst_structure_get_date_time (const GstStructure * structure,
1572     const gchar * fieldname, GstDateTime ** value)
1573 {
1574   GstStructureField *field;
1575 
1576   g_return_val_if_fail (structure != NULL, FALSE);
1577   g_return_val_if_fail (fieldname != NULL, FALSE);
1578   g_return_val_if_fail (value != NULL, FALSE);
1579 
1580   field = gst_structure_get_field (structure, fieldname);
1581 
1582   if (field == NULL)
1583     return FALSE;
1584   if (!GST_VALUE_HOLDS_DATE_TIME (&amp;field-&gt;value))
1585     return FALSE;
1586 
1587   /* FIXME 2.0: g_value_dup_boxed() -&gt; g_value_get_boxed() */
1588   *value = g_value_dup_boxed (&amp;field-&gt;value);
1589 
1590   return TRUE;
1591 }
1592 
1593 /**
1594  * gst_structure_get_clock_time:
1595  * @structure: a #GstStructure
1596  * @fieldname: the name of a field
1597  * @value: (out): a pointer to a #GstClockTime to set
1598  *
1599  * Sets the clock time pointed to by @value corresponding to the clock time
1600  * of the given field.  Caller is responsible for making sure the field exists
1601  * and has the correct type.
1602  *
1603  * Returns: %TRUE if the value could be set correctly. If there was no field
1604  * with @fieldname or the existing field did not contain a #GstClockTime, this
1605  * function returns %FALSE.
1606  */
1607 gboolean
1608 gst_structure_get_clock_time (const GstStructure * structure,
1609     const gchar * fieldname, GstClockTime * value)
1610 {
1611   return gst_structure_get_uint64 (structure, fieldname, value);
1612 }
1613 
1614 /**
1615  * gst_structure_get_double:
1616  * @structure: a #GstStructure
1617  * @fieldname: the name of a field
1618  * @value: (out): a pointer to a gdouble to set
1619  *
1620  * Sets the double pointed to by @value corresponding to the value of the
1621  * given field.  Caller is responsible for making sure the field exists
1622  * and has the correct type.
1623  *
1624  * Returns: %TRUE if the value could be set correctly. If there was no field
1625  * with @fieldname or the existing field did not contain a double, this
1626  * function returns %FALSE.
1627  */
1628 gboolean
1629 gst_structure_get_double (const GstStructure * structure,
1630     const gchar * fieldname, gdouble * value)
1631 {
1632   GstStructureField *field;
1633 
1634   g_return_val_if_fail (structure != NULL, FALSE);
1635   g_return_val_if_fail (fieldname != NULL, FALSE);
1636   g_return_val_if_fail (value != NULL, FALSE);
1637 
1638   field = gst_structure_get_field (structure, fieldname);
1639 
1640   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != G_TYPE_DOUBLE)
1641     return FALSE;
1642 
1643   *value = gst_g_value_get_double_unchecked (&amp;field-&gt;value);
1644 
1645   return TRUE;
1646 }
1647 
1648 /**
1649  * gst_structure_get_string:
1650  * @structure: a #GstStructure
1651  * @fieldname: the name of a field
1652  *
1653  * Finds the field corresponding to @fieldname, and returns the string
1654  * contained in the field&#39;s value.  Caller is responsible for making
1655  * sure the field exists and has the correct type.
1656  *
1657  * The string should not be modified, and remains valid until the next
1658  * call to a gst_structure_*() function with the given structure.
1659  *
1660  * Returns: (nullable): a pointer to the string or %NULL when the
1661  * field did not exist or did not contain a string.
1662  */
1663 const gchar *
1664 gst_structure_get_string (const GstStructure * structure,
1665     const gchar * fieldname)
1666 {
1667   GstStructureField *field;
1668 
1669   g_return_val_if_fail (structure != NULL, NULL);
1670   g_return_val_if_fail (fieldname != NULL, NULL);
1671 
1672   field = gst_structure_get_field (structure, fieldname);
1673 
1674   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != G_TYPE_STRING)
1675     return NULL;
1676 
1677   return gst_g_value_get_string_unchecked (&amp;field-&gt;value);
1678 }
1679 
1680 /**
1681  * gst_structure_get_enum:
1682  * @structure: a #GstStructure
1683  * @fieldname: the name of a field
1684  * @enumtype: the enum type of a field
1685  * @value: (out): a pointer to an int to set
1686  *
1687  * Sets the int pointed to by @value corresponding to the value of the
1688  * given field.  Caller is responsible for making sure the field exists,
1689  * has the correct type and that the enumtype is correct.
1690  *
1691  * Returns: %TRUE if the value could be set correctly. If there was no field
1692  * with @fieldname or the existing field did not contain an enum of the given
1693  * type, this function returns %FALSE.
1694  */
1695 gboolean
1696 gst_structure_get_enum (const GstStructure * structure,
1697     const gchar * fieldname, GType enumtype, gint * value)
1698 {
1699   GstStructureField *field;
1700 
1701   g_return_val_if_fail (structure != NULL, FALSE);
1702   g_return_val_if_fail (fieldname != NULL, FALSE);
1703   g_return_val_if_fail (enumtype != G_TYPE_INVALID, FALSE);
1704   g_return_val_if_fail (value != NULL, FALSE);
1705 
1706   field = gst_structure_get_field (structure, fieldname);
1707 
1708   if (field == NULL)
1709     return FALSE;
1710   if (!G_TYPE_CHECK_VALUE_TYPE (&amp;field-&gt;value, enumtype))
1711     return FALSE;
1712 
1713   *value = g_value_get_enum (&amp;field-&gt;value);
1714 
1715   return TRUE;
1716 }
1717 
1718 /**
1719  * gst_structure_get_fraction:
1720  * @structure: a #GstStructure
1721  * @fieldname: the name of a field
1722  * @value_numerator: (out): a pointer to an int to set
1723  * @value_denominator: (out): a pointer to an int to set
1724  *
1725  * Sets the integers pointed to by @value_numerator and @value_denominator
1726  * corresponding to the value of the given field.  Caller is responsible
1727  * for making sure the field exists and has the correct type.
1728  *
1729  * Returns: %TRUE if the values could be set correctly. If there was no field
1730  * with @fieldname or the existing field did not contain a GstFraction, this
1731  * function returns %FALSE.
1732  */
1733 gboolean
1734 gst_structure_get_fraction (const GstStructure * structure,
1735     const gchar * fieldname, gint * value_numerator, gint * value_denominator)
1736 {
1737   GstStructureField *field;
1738 
1739   g_return_val_if_fail (structure != NULL, FALSE);
1740   g_return_val_if_fail (fieldname != NULL, FALSE);
1741   g_return_val_if_fail (value_numerator != NULL, FALSE);
1742   g_return_val_if_fail (value_denominator != NULL, FALSE);
1743 
1744   field = gst_structure_get_field (structure, fieldname);
1745 
1746   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != GST_TYPE_FRACTION)
1747     return FALSE;
1748 
1749   *value_numerator = gst_value_get_fraction_numerator (&amp;field-&gt;value);
1750   *value_denominator = gst_value_get_fraction_denominator (&amp;field-&gt;value);
1751 
1752   return TRUE;
1753 }
1754 
1755 /**
1756  * gst_structure_get_flagset:
1757  * @structure: a #GstStructure
1758  * @fieldname: the name of a field
1759  * @value_flags: (out) (allow-none): a pointer to a guint for the flags field
1760  * @value_mask: (out) (allow-none): a pointer to a guint for the mask field
1761  *
1762  * Read the GstFlagSet flags and mask out of the structure into the
1763  * provided pointers.
1764  *
1765  * Returns: %TRUE if the values could be set correctly. If there was no field
1766  * with @fieldname or the existing field did not contain a GstFlagSet, this
1767  * function returns %FALSE.
1768  *
1769  * Since: 1.6
1770  */
1771 gboolean
1772 gst_structure_get_flagset (const GstStructure * structure,
1773     const gchar * fieldname, guint * value_flags, guint * value_mask)
1774 {
1775   GstStructureField *field;
1776 
1777   g_return_val_if_fail (structure != NULL, FALSE);
1778   g_return_val_if_fail (fieldname != NULL, FALSE);
1779 
1780   field = gst_structure_get_field (structure, fieldname);
1781 
1782   if (field == NULL || !GST_VALUE_HOLDS_FLAG_SET (&amp;field-&gt;value))
1783     return FALSE;
1784 
1785   if (value_flags)
1786     *value_flags = gst_value_get_flagset_flags (&amp;field-&gt;value);
1787   if (value_mask)
1788     *value_mask = gst_value_get_flagset_mask (&amp;field-&gt;value);
1789 
1790   return TRUE;
<a name="4" id="anc4"></a><span class="line-modified">1791 }</span>
1792 
1793 static GType
1794 gst_structure_value_get_generic_type (const GValue * val)
1795 {
1796   if (G_VALUE_TYPE (val) == GST_TYPE_LIST
1797       || G_VALUE_TYPE (val) == GST_TYPE_ARRAY) {
1798     GArray *array = g_value_peek_pointer (val);
1799 
1800     if (array-&gt;len &gt; 0) {
1801       GValue *value = &amp;g_array_index (array, GValue, 0);
1802 
1803       return gst_structure_value_get_generic_type (value);
1804     } else {
1805       return G_TYPE_INT;
1806     }
1807   } else if (G_VALUE_TYPE (val) == GST_TYPE_INT_RANGE) {
1808     return G_TYPE_INT;
1809   } else if (G_VALUE_TYPE (val) == GST_TYPE_INT64_RANGE) {
1810     return G_TYPE_INT64;
1811   } else if (G_VALUE_TYPE (val) == GST_TYPE_DOUBLE_RANGE) {
1812     return G_TYPE_DOUBLE;
1813   } else if (G_VALUE_TYPE (val) == GST_TYPE_FRACTION_RANGE) {
1814     return GST_TYPE_FRACTION;
1815   }
1816   return G_VALUE_TYPE (val);
1817 }
1818 
1819 gboolean
1820 priv_gst_structure_append_to_gstring (const GstStructure * structure,
1821     GString * s)
1822 {
1823   GstStructureField *field;
1824   guint i, len;
1825 
1826   g_return_val_if_fail (s != NULL, FALSE);
1827 
1828   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
1829   for (i = 0; i &lt; len; i++) {
1830     char *t;
1831     GType type;
1832 
1833     field = GST_STRUCTURE_FIELD (structure, i);
1834 
1835     if (G_VALUE_TYPE (&amp;field-&gt;value) == GST_TYPE_ARRAY) {
1836       t = _priv_gst_value_serialize_any_list (&amp;field-&gt;value, &quot;&lt; &quot;, &quot; &gt;&quot;, FALSE);
1837     } else if (G_VALUE_TYPE (&amp;field-&gt;value) == GST_TYPE_LIST) {
1838       t = _priv_gst_value_serialize_any_list (&amp;field-&gt;value, &quot;{ &quot;, &quot; }&quot;, FALSE);
1839     } else {
<a name="5" id="anc5"></a><span class="line-modified">1840       t = gst_value_serialize (&amp;field-&gt;value);</span>
1841     }
1842 
1843     type = gst_structure_value_get_generic_type (&amp;field-&gt;value);
1844 
1845     g_string_append_len (s, &quot;, &quot;, 2);
1846     /* FIXME: do we need to escape fieldnames? */
1847     g_string_append (s, g_quark_to_string (field-&gt;name));
1848     g_string_append_len (s, &quot;=(&quot;, 2);
1849     g_string_append (s, _priv_gst_value_gtype_to_abbr (type));
1850     g_string_append_c (s, &#39;)&#39;);
1851     if (t) {
1852       g_string_append (s, t);
<a name="6" id="anc6"></a><span class="line-modified">1853       g_free (t);</span>
<span class="line-added">1854     } else if (G_TYPE_CHECK_VALUE_TYPE (&amp;field-&gt;value, G_TYPE_POINTER)) {</span>
<span class="line-added">1855       gpointer ptr = g_value_get_pointer (&amp;field-&gt;value);</span>
<span class="line-added">1856 </span>
<span class="line-added">1857       if (!ptr)</span>
<span class="line-added">1858         g_string_append (s, &quot;NULL&quot;);</span>
<span class="line-added">1859       else</span>
<span class="line-added">1860         g_string_append_printf (s, &quot;%p&quot;, ptr);</span>
1861     } else {
<a name="7" id="anc7"></a><span class="line-modified">1862       if (!G_TYPE_CHECK_VALUE_TYPE (&amp;field-&gt;value, G_TYPE_STRING))</span>


1863         GST_WARNING (&quot;No value transform to serialize field &#39;%s&#39; of type &#39;%s&#39;&quot;,
1864             g_quark_to_string (field-&gt;name),
1865             _priv_gst_value_gtype_to_abbr (type));
1866       /* TODO(ensonic): don&#39;t print NULL if field-&gt;value is not empty */
1867       g_string_append (s, &quot;NULL&quot;);
<a name="8" id="anc8"></a><span class="line-modified">1868     }</span>
1869   }
1870 
1871   g_string_append_c (s, &#39;;&#39;);
1872   return TRUE;
1873 }
1874 
1875 gboolean
1876 priv__gst_structure_append_template_to_gstring (GQuark field_id,
1877     const GValue * value, gpointer user_data)
1878 {
1879   GType type = gst_structure_value_get_generic_type (value);
1880   GString *s = (GString *) user_data;
1881 
1882   g_string_append_len (s, &quot;, &quot;, 2);
1883   /* FIXME: do we need to escape fieldnames? */
1884   g_string_append (s, g_quark_to_string (field_id));
1885   g_string_append_len (s, &quot;=(&quot;, 2);
1886   g_string_append (s, _priv_gst_value_gtype_to_abbr (type));
1887   g_string_append_c (s, &#39;)&#39;);
1888 
1889   //TODO(ensonic): table like GstStructureAbbreviation (or extend it)
1890   if (type == G_TYPE_INT) {
1891     g_string_append_len (s, &quot;%i&quot;, 2);
1892   } else if (type == G_TYPE_UINT) {
1893     g_string_append_len (s, &quot;%u&quot;, 2);
1894   } else if (type == G_TYPE_FLOAT) {
1895     g_string_append_len (s, &quot;%f&quot;, 2);
1896   } else if (type == G_TYPE_DOUBLE) {
1897     g_string_append_len (s, &quot;%lf&quot;, 3);
1898   } else if (type == G_TYPE_STRING) {
1899     g_string_append_len (s, &quot;%s&quot;, 2);
1900   } else if (type == G_TYPE_BOOLEAN) {
1901     /* we normally store this as a string, but can parse it also from an int */
1902     g_string_append_len (s, &quot;%i&quot;, 2);
1903   } else if (type == G_TYPE_INT64) {
1904     g_string_append (s, &quot;%&quot; G_GINT64_FORMAT);
1905   } else if (type == G_TYPE_UINT64) {
1906     g_string_append (s, &quot;%&quot; G_GUINT64_FORMAT);
1907   } else if (type == GST_TYPE_STRUCTURE) {
1908     g_string_append (s, &quot;%&quot; GST_WRAPPED_PTR_FORMAT);
1909   } else if (g_type_is_a (type, G_TYPE_ENUM)
1910       || g_type_is_a (type, G_TYPE_FLAGS)) {
1911     g_string_append_len (s, &quot;%i&quot;, 2);
1912   } else if (type == G_TYPE_GTYPE) {
1913     g_string_append_len (s, &quot;%s&quot;, 2);
1914   } else if (type == G_TYPE_POINTER) {
1915     g_string_append_len (s, &quot;%p&quot;, 2);
1916   } else {
1917     GST_WARNING (&quot;unhandled type: %s&quot;, g_type_name (type));
1918     g_string_append (s, &quot;%&quot; GST_WRAPPED_PTR_FORMAT);
1919   }
1920 
1921   return TRUE;
1922 }
1923 
1924 /**
1925  * gst_structure_to_string:
1926  * @structure: a #GstStructure
1927  *
1928  * Converts @structure to a human-readable string representation.
1929  *
1930  * For debugging purposes its easier to do something like this:
1931  * |[&lt;!-- language=&quot;C&quot; --&gt;
1932  * GST_LOG (&quot;structure is %&quot; GST_PTR_FORMAT, structure);
1933  * ]|
1934  * This prints the structure in human readable form.
1935  *
1936  * The current implementation of serialization will lead to unexpected results
1937  * when there are nested #GstCaps / #GstStructure deeper than one level.
1938  *
1939  * Free-function: g_free
1940  *
1941  * Returns: (transfer full): a pointer to string allocated by g_malloc().
1942  *     g_free() after usage.
1943  */
1944 gchar *
1945 gst_structure_to_string (const GstStructure * structure)
1946 {
1947   GString *s;
1948 
1949   /* NOTE:  This function is potentially called by the debug system,
1950    * so any calls to gst_log() (and GST_DEBUG(), GST_LOG(), etc.)
1951    * should be careful to avoid recursion.  This includes any functions
1952    * called by gst_structure_to_string.  In particular, calls should
1953    * not use the GST_PTR_FORMAT extension.  */
1954 
1955   g_return_val_if_fail (structure != NULL, NULL);
1956 
1957   /* we estimate a minimum size based on the number of fields in order to
1958    * avoid unnecessary reallocs within GString */
1959   s = g_string_sized_new (STRUCTURE_ESTIMATED_STRING_LEN (structure));
1960   g_string_append (s, g_quark_to_string (structure-&gt;name));
1961   priv_gst_structure_append_to_gstring (structure, s);
1962   return g_string_free (s, FALSE);
1963 }
1964 
1965 static gboolean
1966 gst_structure_parse_field (gchar * str,
1967     gchar ** after, GstStructureField * field)
1968 {
1969   gchar *name;
1970   gchar *name_end;
1971   gchar *s;
1972   gchar c;
1973 
1974   s = str;
1975 
1976   while (g_ascii_isspace (*s) || (s[0] == &#39;\\&#39; &amp;&amp; g_ascii_isspace (s[1])))
1977     s++;
1978   name = s;
1979   if (G_UNLIKELY (!_priv_gst_value_parse_simple_string (s, &amp;name_end))) {
1980     GST_WARNING (&quot;failed to parse simple string, str=%s&quot;, str);
1981     return FALSE;
1982   }
1983 
1984   s = name_end;
1985   while (g_ascii_isspace (*s) || (s[0] == &#39;\\&#39; &amp;&amp; g_ascii_isspace (s[1])))
1986     s++;
1987 
1988   if (G_UNLIKELY (*s != &#39;=&#39;)) {
1989     GST_WARNING (&quot;missing assignment operator in the field, str=%s&quot;, str);
1990     return FALSE;
1991   }
1992   s++;
1993 
1994   c = *name_end;
1995   *name_end = &#39;\0&#39;;
1996   field-&gt;name = g_quark_from_string (name);
1997   GST_DEBUG (&quot;trying field name &#39;%s&#39;&quot;, name);
1998   *name_end = c;
1999 
2000   if (G_UNLIKELY (!_priv_gst_value_parse_value (s, &amp;s, &amp;field-&gt;value,
2001               G_TYPE_INVALID))) {
2002     GST_WARNING (&quot;failed to parse value %s&quot;, str);
2003     return FALSE;
2004   }
2005 
2006   *after = s;
2007   return TRUE;
2008 }
2009 
2010 gboolean
2011 priv_gst_structure_parse_name (gchar * str, gchar ** start, gchar ** end,
2012     gchar ** next)
2013 {
2014   char *w;
2015   char *r;
2016 
2017   r = str;
2018 
2019   /* skip spaces (FIXME: _isspace treats tabs and newlines as space!) */
2020   while (*r &amp;&amp; (g_ascii_isspace (*r) || (r[0] == &#39;\\&#39;
2021               &amp;&amp; g_ascii_isspace (r[1]))))
2022     r++;
2023 
2024   *start = r;
2025 
2026   if (G_UNLIKELY (!_priv_gst_value_parse_string (r, &amp;w, &amp;r, TRUE))) {
2027     GST_WARNING (&quot;Failed to parse structure string &#39;%s&#39;&quot;, str);
2028     return FALSE;
2029   }
2030 
2031   *end = w;
2032   *next = r;
2033 
2034   return TRUE;
2035 }
2036 
2037 gboolean
2038 priv_gst_structure_parse_fields (gchar * str, gchar ** end,
2039     GstStructure * structure)
2040 {
2041   gchar *r;
2042   GstStructureField field;
2043 
2044   r = str;
2045 
2046   do {
2047     while (*r &amp;&amp; (g_ascii_isspace (*r) || (r[0] == &#39;\\&#39;
2048                 &amp;&amp; g_ascii_isspace (r[1]))))
2049       r++;
2050     if (*r == &#39;;&#39;) {
2051       /* end of structure, get the next char and finish */
2052       r++;
2053       break;
2054     }
2055     if (*r == &#39;\0&#39;) {
2056       /* accept \0 as end delimiter */
2057       break;
2058     }
2059     if (G_UNLIKELY (*r != &#39;,&#39;)) {
2060       GST_WARNING (&quot;Failed to find delimiter, r=%s&quot;, r);
2061       return FALSE;
2062     }
2063     r++;
2064     while (*r &amp;&amp; (g_ascii_isspace (*r) || (r[0] == &#39;\\&#39;
2065                 &amp;&amp; g_ascii_isspace (r[1]))))
2066       r++;
2067 
2068     memset (&amp;field, 0, sizeof (field));
2069     if (G_UNLIKELY (!gst_structure_parse_field (r, &amp;r, &amp;field))) {
2070       GST_WARNING (&quot;Failed to parse field, r=%s&quot;, r);
2071       return FALSE;
2072     }
2073     gst_structure_set_field (structure, &amp;field);
2074   } while (TRUE);
2075 
2076   *end = r;
2077 
2078   return TRUE;
2079 }
2080 
2081 /**
2082  * gst_structure_new_from_string:
2083  * @string: a string representation of a #GstStructure
2084  *
2085  * Creates a #GstStructure from a string representation.
2086  * If end is not %NULL, a pointer to the place inside the given string
2087  * where parsing ended will be returned.
2088  *
2089  * The current implementation of serialization will lead to unexpected results
2090  * when there are nested #GstCaps / #GstStructure deeper than one level.
2091  *
2092  * Free-function: gst_structure_free
2093  *
2094  * Returns: (transfer full) (nullable): a new #GstStructure or %NULL
2095  *     when the string could not be parsed. Free with
2096  *     gst_structure_free() after use.
2097  *
2098  * Since: 1.2
2099  */
2100 GstStructure *
2101 gst_structure_new_from_string (const gchar * string)
2102 {
2103   return gst_structure_from_string (string, NULL);
2104 }
2105 
2106 /**
2107  * gst_structure_from_string:
2108  * @string: a string representation of a #GstStructure.
2109  * @end: (out) (allow-none) (transfer none) (skip): pointer to store the end of the string in.
2110  *
2111  * Creates a #GstStructure from a string representation.
2112  * If end is not %NULL, a pointer to the place inside the given string
2113  * where parsing ended will be returned.
2114  *
2115  * Free-function: gst_structure_free
2116  *
2117  * Returns: (transfer full) (nullable): a new #GstStructure or %NULL
2118  *     when the string could not be parsed. Free with
2119  *     gst_structure_free() after use.
2120  */
2121 GstStructure *
2122 gst_structure_from_string (const gchar * string, gchar ** end)
2123 {
2124   char *name;
2125   char *copy;
2126   char *w;
2127   char *r;
2128   char save;
2129   GstStructure *structure = NULL;
2130 
2131   g_return_val_if_fail (string != NULL, NULL);
2132 
2133   copy = g_strdup (string);
2134   r = copy;
2135 
2136   if (!priv_gst_structure_parse_name (r, &amp;name, &amp;w, &amp;r))
2137     goto error;
2138 
2139   save = *w;
2140   *w = &#39;\0&#39;;
2141   structure = gst_structure_new_empty (name);
2142   *w = save;
2143 
2144   if (G_UNLIKELY (structure == NULL))
2145     goto error;
2146 
2147   if (!priv_gst_structure_parse_fields (r, &amp;r, structure))
2148     goto error;
2149 
2150   if (end)
2151     *end = (char *) string + (r - copy);
2152   else if (*r)
2153     g_warning (&quot;gst_structure_from_string did not consume whole string,&quot;
2154         &quot; but caller did not provide end pointer (\&quot;%s\&quot;)&quot;, string);
2155 
2156   g_free (copy);
2157   return structure;
2158 
2159 error:
2160   if (structure)
2161     gst_structure_free (structure);
2162   g_free (copy);
2163   return NULL;
2164 }
2165 
2166 static void
2167 gst_structure_transform_to_string (const GValue * src_value,
2168     GValue * dest_value)
2169 {
2170   g_return_if_fail (src_value != NULL);
2171   g_return_if_fail (dest_value != NULL);
2172 
2173   dest_value-&gt;data[0].v_pointer =
2174       gst_structure_to_string (src_value-&gt;data[0].v_pointer);
2175 }
2176 
2177 static GstStructure *
2178 gst_structure_copy_conditional (const GstStructure * structure)
2179 {
2180   if (structure)
2181     return gst_structure_copy (structure);
2182   return NULL;
2183 }
2184 
2185 /* fixate utility functions */
2186 
2187 /**
2188  * gst_structure_fixate_field_nearest_int:
2189  * @structure: a #GstStructure
2190  * @field_name: a field in @structure
2191  * @target: the target value of the fixation
2192  *
2193  * Fixates a #GstStructure by changing the given field to the nearest
2194  * integer to @target that is a subset of the existing field.
2195  *
2196  * Returns: %TRUE if the structure could be fixated
2197  */
2198 gboolean
2199 gst_structure_fixate_field_nearest_int (GstStructure * structure,
2200     const char *field_name, int target)
2201 {
2202   const GValue *value;
2203 
2204   g_return_val_if_fail (gst_structure_has_field (structure, field_name), FALSE);
2205   g_return_val_if_fail (IS_MUTABLE (structure), FALSE);
2206 
2207   value = gst_structure_get_value (structure, field_name);
2208 #ifdef GSTREAMER_LITE
2209   if (value == NULL) {
2210     return FALSE;
2211   }
2212 #endif // GSTREAMER_LITE
2213 
2214   if (G_VALUE_TYPE (value) == G_TYPE_INT) {
2215     /* already fixed */
2216     return FALSE;
2217   } else if (G_VALUE_TYPE (value) == GST_TYPE_INT_RANGE) {
<a name="9" id="anc9"></a><span class="line-modified">2218     int min, max, step;</span>
<span class="line-added">2219 </span>
<span class="line-added">2220     min = gst_value_get_int_range_min (value);</span>
<span class="line-added">2221     max = gst_value_get_int_range_max (value);</span>
<span class="line-added">2222     step = gst_value_get_int_range_step (value);</span>
<span class="line-added">2223 </span>
<span class="line-added">2224     target = CLAMP (target, min, max);</span>
<span class="line-added">2225     if (G_UNLIKELY (step != 1)) {</span>
<span class="line-added">2226       gint rem = target % step;</span>
<span class="line-added">2227       target -= rem;</span>
<span class="line-added">2228       if (rem &gt; step / 2)</span>
<span class="line-added">2229         target += step;</span>
<span class="line-added">2230     }</span>
2231 
<a name="10" id="anc10"></a>





2232     gst_structure_set (structure, field_name, G_TYPE_INT, target, NULL);
2233     return TRUE;
2234   } else if (G_VALUE_TYPE (value) == GST_TYPE_LIST) {
2235     const GValue *list_value;
2236     int i, n;
2237     int best = 0;
2238     int best_index = -1;
2239 
2240     n = gst_value_list_get_size (value);
2241     for (i = 0; i &lt; n; i++) {
2242       list_value = gst_value_list_get_value (value, i);
2243       if (G_VALUE_TYPE (list_value) == G_TYPE_INT) {
2244         int x = gst_g_value_get_int_unchecked (list_value);
2245 
2246         if (best_index == -1 || (ABS (target - x) &lt; ABS (target - best))) {
2247           best_index = i;
2248           best = x;
2249         }
2250       }
2251     }
2252     if (best_index != -1) {
2253       gst_structure_set (structure, field_name, G_TYPE_INT, best, NULL);
2254       return TRUE;
2255     }
2256     return FALSE;
2257   }
2258 
2259   return FALSE;
2260 }
2261 
2262 /**
2263  * gst_structure_fixate_field_nearest_double:
2264  * @structure: a #GstStructure
2265  * @field_name: a field in @structure
2266  * @target: the target value of the fixation
2267  *
2268  * Fixates a #GstStructure by changing the given field to the nearest
2269  * double to @target that is a subset of the existing field.
2270  *
2271  * Returns: %TRUE if the structure could be fixated
2272  */
2273 gboolean
2274 gst_structure_fixate_field_nearest_double (GstStructure * structure,
2275     const char *field_name, double target)
2276 {
2277   const GValue *value;
2278 
2279   g_return_val_if_fail (gst_structure_has_field (structure, field_name), FALSE);
2280   g_return_val_if_fail (IS_MUTABLE (structure), FALSE);
2281 
2282   value = gst_structure_get_value (structure, field_name);
2283 #ifdef GSTREAMER_LITE
2284   if (value == NULL) {
2285     return FALSE;
2286   }
2287 #endif // GSTREAMER_LITE
2288 
2289   if (G_VALUE_TYPE (value) == G_TYPE_DOUBLE) {
2290     /* already fixed */
2291     return FALSE;
2292   } else if (G_VALUE_TYPE (value) == GST_TYPE_DOUBLE_RANGE) {
2293     double x;
2294 
2295     x = gst_value_get_double_range_min (value);
2296     if (target &lt; x)
2297       target = x;
2298     x = gst_value_get_double_range_max (value);
2299     if (target &gt; x)
2300       target = x;
2301     gst_structure_set (structure, field_name, G_TYPE_DOUBLE, target, NULL);
2302     return TRUE;
2303   } else if (G_VALUE_TYPE (value) == GST_TYPE_LIST) {
2304     const GValue *list_value;
2305     int i, n;
2306     double best = 0;
2307     int best_index = -1;
2308 
2309     n = gst_value_list_get_size (value);
2310     for (i = 0; i &lt; n; i++) {
2311       list_value = gst_value_list_get_value (value, i);
2312       if (G_VALUE_TYPE (list_value) == G_TYPE_DOUBLE) {
2313         double x = gst_g_value_get_double_unchecked (list_value);
2314 
2315         if (best_index == -1 || (ABS (target - x) &lt; ABS (target - best))) {
2316           best_index = i;
2317           best = x;
2318         }
2319       }
2320     }
2321     if (best_index != -1) {
2322       gst_structure_set (structure, field_name, G_TYPE_DOUBLE, best, NULL);
2323       return TRUE;
2324     }
2325     return FALSE;
2326   }
2327 
2328   return FALSE;
2329 
2330 }
2331 
2332 /**
2333  * gst_structure_fixate_field_boolean:
2334  * @structure: a #GstStructure
2335  * @field_name: a field in @structure
2336  * @target: the target value of the fixation
2337  *
2338  * Fixates a #GstStructure by changing the given @field_name field to the given
2339  * @target boolean if that field is not fixed yet.
2340  *
2341  * Returns: %TRUE if the structure could be fixated
2342  */
2343 gboolean
2344 gst_structure_fixate_field_boolean (GstStructure * structure,
2345     const char *field_name, gboolean target)
2346 {
2347   const GValue *value;
2348 
2349   g_return_val_if_fail (gst_structure_has_field (structure, field_name), FALSE);
2350   g_return_val_if_fail (IS_MUTABLE (structure), FALSE);
2351 
2352   value = gst_structure_get_value (structure, field_name);
2353 #ifdef GSTREAMER_LITE
2354   if (value == NULL) {
2355     return FALSE;
2356   }
2357 #endif // GSTREAMER_LITE
2358 
2359   if (G_VALUE_TYPE (value) == G_TYPE_BOOLEAN) {
2360     /* already fixed */
2361     return FALSE;
2362   } else if (G_VALUE_TYPE (value) == GST_TYPE_LIST) {
2363     const GValue *list_value;
2364     int i, n;
2365     int best = 0;
2366     int best_index = -1;
2367 
2368     n = gst_value_list_get_size (value);
2369     for (i = 0; i &lt; n; i++) {
2370       list_value = gst_value_list_get_value (value, i);
2371       if (G_VALUE_TYPE (list_value) == G_TYPE_BOOLEAN) {
2372         gboolean x = gst_g_value_get_boolean_unchecked (list_value);
2373 
2374         if (best_index == -1 || x == target) {
2375           best_index = i;
2376           best = x;
2377         }
2378       }
2379     }
2380     if (best_index != -1) {
2381       gst_structure_set (structure, field_name, G_TYPE_BOOLEAN, best, NULL);
2382       return TRUE;
2383     }
2384     return FALSE;
2385   }
2386 
2387   return FALSE;
2388 }
2389 
2390 /**
2391  * gst_structure_fixate_field_string:
2392  * @structure: a #GstStructure
2393  * @field_name: a field in @structure
2394  * @target: the target value of the fixation
2395  *
2396  * Fixates a #GstStructure by changing the given @field_name field to the given
2397  * @target string if that field is not fixed yet.
2398  *
2399  * Returns: %TRUE if the structure could be fixated
2400  */
2401 gboolean
2402 gst_structure_fixate_field_string (GstStructure * structure,
2403     const gchar * field_name, const gchar * target)
2404 {
2405   const GValue *value;
2406 
2407   g_return_val_if_fail (gst_structure_has_field (structure, field_name), FALSE);
2408   g_return_val_if_fail (IS_MUTABLE (structure), FALSE);
2409 
2410   value = gst_structure_get_value (structure, field_name);
2411 #ifdef GSTREAMER_LITE
2412   if (value == NULL) {
2413     return FALSE;
2414   }
2415 #endif // GSTREAMER_LITE
2416 
2417   if (G_VALUE_TYPE (value) == G_TYPE_STRING) {
2418     /* already fixed */
2419     return FALSE;
2420   } else if (G_VALUE_TYPE (value) == GST_TYPE_LIST) {
2421     const GValue *list_value;
2422     int i, n;
2423     const gchar *best = NULL;
2424     int best_index = -1;
2425 
2426     n = gst_value_list_get_size (value);
2427     for (i = 0; i &lt; n; i++) {
2428       list_value = gst_value_list_get_value (value, i);
2429       if (G_VALUE_TYPE (list_value) == G_TYPE_STRING) {
2430         const gchar *x = g_value_get_string (list_value);
2431 
2432         if (best_index == -1 || g_str_equal (x, target)) {
2433           best_index = i;
2434           best = x;
2435         }
2436       }
2437     }
2438     if (best_index != -1) {
2439       gst_structure_set (structure, field_name, G_TYPE_STRING, best, NULL);
2440       return TRUE;
2441     }
2442     return FALSE;
2443   }
2444 
2445   return FALSE;
2446 }
2447 
2448 /**
2449  * gst_structure_fixate_field_nearest_fraction:
2450  * @structure: a #GstStructure
2451  * @field_name: a field in @structure
2452  * @target_numerator: The numerator of the target value of the fixation
2453  * @target_denominator: The denominator of the target value of the fixation
2454  *
2455  * Fixates a #GstStructure by changing the given field to the nearest
2456  * fraction to @target_numerator/@target_denominator that is a subset
2457  * of the existing field.
2458  *
2459  * Returns: %TRUE if the structure could be fixated
2460  */
2461 gboolean
2462 gst_structure_fixate_field_nearest_fraction (GstStructure * structure,
2463     const char *field_name, const gint target_numerator,
2464     const gint target_denominator)
2465 {
2466   const GValue *value;
2467 
2468   g_return_val_if_fail (gst_structure_has_field (structure, field_name), FALSE);
2469   g_return_val_if_fail (IS_MUTABLE (structure), FALSE);
2470   g_return_val_if_fail (target_denominator != 0, FALSE);
2471 
2472   value = gst_structure_get_value (structure, field_name);
2473 #ifdef GSTREAMER_LITE
2474   if (value == NULL) {
2475     return FALSE;
2476   }
2477 #endif // GSTREAMER_LITE
2478 
2479   if (G_VALUE_TYPE (value) == GST_TYPE_FRACTION) {
2480     /* already fixed */
2481     return FALSE;
2482   } else if (G_VALUE_TYPE (value) == GST_TYPE_FRACTION_RANGE) {
2483     const GValue *x, *new_value;
2484     GValue target = { 0 };
2485     g_value_init (&amp;target, GST_TYPE_FRACTION);
2486     gst_value_set_fraction (&amp;target, target_numerator, target_denominator);
2487 
2488     new_value = &amp;target;
2489     x = gst_value_get_fraction_range_min (value);
2490     if (gst_value_compare (&amp;target, x) == GST_VALUE_LESS_THAN)
2491       new_value = x;
2492     x = gst_value_get_fraction_range_max (value);
2493     if (gst_value_compare (&amp;target, x) == GST_VALUE_GREATER_THAN)
2494       new_value = x;
2495 
2496     gst_structure_set_value (structure, field_name, new_value);
2497     g_value_unset (&amp;target);
2498     return TRUE;
2499   } else if (G_VALUE_TYPE (value) == GST_TYPE_LIST) {
2500     const GValue *list_value;
2501     int i, n;
2502     const GValue *best = NULL;
2503     gdouble target;
2504     gdouble cur_diff;
2505     gdouble best_diff = G_MAXDOUBLE;
2506 
2507     target = (gdouble) target_numerator / (gdouble) target_denominator;
2508 
2509     GST_DEBUG (&quot;target %g, best %g&quot;, target, best_diff);
2510 
2511     best = NULL;
2512 
2513     n = gst_value_list_get_size (value);
2514     for (i = 0; i &lt; n; i++) {
2515       list_value = gst_value_list_get_value (value, i);
2516       if (G_VALUE_TYPE (list_value) == GST_TYPE_FRACTION) {
2517         gint num, denom;
2518         gdouble list_double;
2519 
2520         num = gst_value_get_fraction_numerator (list_value);
2521         denom = gst_value_get_fraction_denominator (list_value);
2522 
2523         list_double = ((gdouble) num / (gdouble) denom);
2524         cur_diff = target - list_double;
2525 
2526         GST_DEBUG (&quot;curr diff %g, list %g&quot;, cur_diff, list_double);
2527 
2528         if (cur_diff &lt; 0)
2529           cur_diff = -cur_diff;
2530 
2531         if (!best || cur_diff &lt; best_diff) {
2532           GST_DEBUG (&quot;new best %g&quot;, list_double);
2533           best = list_value;
2534           best_diff = cur_diff;
2535         }
2536       }
2537     }
2538     if (best != NULL) {
2539       gst_structure_set_value (structure, field_name, best);
2540       return TRUE;
2541     }
2542   }
2543 
2544   return FALSE;
2545 }
2546 
2547 static gboolean
2548 default_fixate (GQuark field_id, const GValue * value, gpointer data)
2549 {
2550   GstStructure *s = data;
2551   GValue v = { 0 };
2552 
2553   if (gst_value_fixate (&amp;v, value)) {
2554     gst_structure_id_take_value (s, field_id, &amp;v);
2555   }
2556   return TRUE;
2557 }
2558 
2559 /**
2560  * gst_structure_fixate_field:
2561  * @structure: a #GstStructure
2562  * @field_name: a field in @structure
2563  *
2564  * Fixates a #GstStructure by changing the given field with its fixated value.
2565  *
2566  * Returns: %TRUE if the structure field could be fixated
2567  */
2568 gboolean
2569 gst_structure_fixate_field (GstStructure * structure, const char *field_name)
2570 {
2571   GstStructureField *field;
2572 
2573   g_return_val_if_fail (structure != NULL, FALSE);
2574   g_return_val_if_fail (IS_MUTABLE (structure), FALSE);
2575 
2576   if (!(field = gst_structure_get_field (structure, field_name)))
2577     return FALSE;
2578 
2579   return default_fixate (field-&gt;name, &amp;field-&gt;value, structure);
2580 }
2581 
2582 /* our very own version of G_VALUE_LCOPY that allows NULL return locations
2583  * (useful for message parsing functions where the return location is user
2584  * supplied and the user may pass %NULL if the value isn&#39;t of interest) */
2585 #define GST_VALUE_LCOPY(value, var_args, flags, __error, fieldname)           \
2586 G_STMT_START {                                                                \
2587   const GValue *_value = (value);                                             \
2588   guint _flags = (flags);                                                     \
2589   GType _value_type = G_VALUE_TYPE (_value);                                  \
2590   GTypeValueTable *_vtable = g_type_value_table_peek (_value_type);           \
2591   const gchar *_lcopy_format = _vtable-&gt;lcopy_format;                         \
2592   GTypeCValue _cvalues[G_VALUE_COLLECT_FORMAT_MAX_LENGTH] = { { 0, }, };      \
2593   guint _n_values = 0;                                                        \
2594                                                                               \
2595   while (*_lcopy_format != &#39;\0&#39;) {                                            \
2596     g_assert (*_lcopy_format == G_VALUE_COLLECT_POINTER);                     \
2597     _cvalues[_n_values++].v_pointer = va_arg ((var_args), gpointer);          \
2598     _lcopy_format++;                                                          \
2599   }                                                                           \
2600   if (_n_values == 2 &amp;&amp; !!_cvalues[0].v_pointer != !!_cvalues[1].v_pointer) { \
2601     *(__error) = g_strdup_printf (&quot;either all or none of the return &quot;         \
2602         &quot;locations for field &#39;%s&#39; need to be NULL&quot;, fieldname);               \
2603   } else if (_cvalues[0].v_pointer != NULL) {                                 \
2604     *(__error) = _vtable-&gt;lcopy_value (_value, _n_values, _cvalues, _flags);  \
2605   }                                                                           \
2606 } G_STMT_END
2607 
2608 /**
2609  * gst_structure_get_valist:
2610  * @structure: a #GstStructure
2611  * @first_fieldname: the name of the first field to read
2612  * @args: variable arguments
2613  *
2614  * Parses the variable arguments and reads fields from @structure accordingly.
2615  * valist-variant of gst_structure_get(). Look at the documentation of
2616  * gst_structure_get() for more details.
2617  *
2618  * Returns: %TRUE, or %FALSE if there was a problem reading any of the fields
2619  */
2620 gboolean
2621 gst_structure_get_valist (const GstStructure * structure,
2622     const char *first_fieldname, va_list args)
2623 {
2624   const char *field_name;
2625   GType expected_type = G_TYPE_INVALID;
2626 
2627   g_return_val_if_fail (GST_IS_STRUCTURE (structure), FALSE);
2628   g_return_val_if_fail (first_fieldname != NULL, FALSE);
2629 
2630   field_name = first_fieldname;
2631   while (field_name) {
2632     const GValue *val = NULL;
2633     gchar *err = NULL;
2634 
2635     expected_type = va_arg (args, GType);
2636 
2637     val = gst_structure_get_value (structure, field_name);
2638 
2639     if (val == NULL)
2640       goto no_such_field;
2641 
2642     if (G_VALUE_TYPE (val) != expected_type)
2643       goto wrong_type;
2644 
2645     GST_VALUE_LCOPY (val, args, 0, &amp;err, field_name);
2646     if (err) {
2647       g_warning (&quot;%s: %s&quot;, G_STRFUNC, err);
2648       g_free (err);
2649       return FALSE;
2650     }
2651 
2652     field_name = va_arg (args, const gchar *);
2653   }
2654 
2655   return TRUE;
2656 
2657 /* ERRORS */
2658 no_such_field:
2659   {
2660     GST_INFO (&quot;Expected field &#39;%s&#39; in structure: %&quot; GST_PTR_FORMAT,
2661         field_name, structure);
2662     return FALSE;
2663   }
2664 wrong_type:
2665   {
2666     GST_INFO (&quot;Expected field &#39;%s&#39; in structure to be of type &#39;%s&#39;, but &quot;
2667         &quot;field was of type &#39;%s&#39;: %&quot; GST_PTR_FORMAT, field_name,
2668         GST_STR_NULL (g_type_name (expected_type)),
2669         G_VALUE_TYPE_NAME (gst_structure_get_value (structure, field_name)),
2670         structure);
2671     return FALSE;
2672   }
2673 }
2674 
2675 /**
2676  * gst_structure_id_get_valist:
2677  * @structure: a #GstStructure
2678  * @first_field_id: the quark of the first field to read
2679  * @args: variable arguments
2680  *
2681  * Parses the variable arguments and reads fields from @structure accordingly.
2682  * valist-variant of gst_structure_id_get(). Look at the documentation of
2683  * gst_structure_id_get() for more details.
2684  *
2685  * Returns: %TRUE, or %FALSE if there was a problem reading any of the fields
2686  */
2687 gboolean
2688 gst_structure_id_get_valist (const GstStructure * structure,
2689     GQuark first_field_id, va_list args)
2690 {
2691   GQuark field_id;
2692   GType expected_type = G_TYPE_INVALID;
2693 
2694   g_return_val_if_fail (GST_IS_STRUCTURE (structure), FALSE);
2695   g_return_val_if_fail (first_field_id != 0, FALSE);
2696 
2697   field_id = first_field_id;
2698   while (field_id) {
2699     const GValue *val = NULL;
2700     gchar *err = NULL;
2701 
2702     expected_type = va_arg (args, GType);
2703 
2704     val = gst_structure_id_get_value (structure, field_id);
2705 
2706     if (val == NULL)
2707       goto no_such_field;
2708 
2709     if (G_VALUE_TYPE (val) != expected_type)
2710       goto wrong_type;
2711 
2712     GST_VALUE_LCOPY (val, args, 0, &amp;err, g_quark_to_string (field_id));
2713     if (err) {
2714       g_warning (&quot;%s: %s&quot;, G_STRFUNC, err);
2715       g_free (err);
2716       return FALSE;
2717     }
2718 
2719     field_id = va_arg (args, GQuark);
2720   }
2721 
2722   return TRUE;
2723 
2724 /* ERRORS */
2725 no_such_field:
2726   {
2727     GST_DEBUG (&quot;Expected field &#39;%s&#39; in structure: %&quot; GST_PTR_FORMAT,
2728         GST_STR_NULL (g_quark_to_string (field_id)), structure);
2729     return FALSE;
2730   }
2731 wrong_type:
2732   {
2733     GST_DEBUG (&quot;Expected field &#39;%s&#39; in structure to be of type &#39;%s&#39;, but &quot;
2734         &quot;field was of type &#39;%s&#39;: %&quot; GST_PTR_FORMAT,
2735         g_quark_to_string (field_id),
2736         GST_STR_NULL (g_type_name (expected_type)),
2737         G_VALUE_TYPE_NAME (gst_structure_id_get_value (structure, field_id)),
2738         structure);
2739     return FALSE;
2740   }
2741 }
2742 
2743 /**
2744  * gst_structure_get:
2745  * @structure: a #GstStructure
2746  * @first_fieldname: the name of the first field to read
2747  * @...: variable arguments
2748  *
2749  * Parses the variable arguments and reads fields from @structure accordingly.
2750  * Variable arguments should be in the form field name, field type
2751  * (as a GType), pointer(s) to a variable(s) to hold the return value(s).
2752  * The last variable argument should be %NULL.
2753  *
2754  * For refcounted (mini)objects you will receive a new reference which
2755  * you must release with a suitable _unref() when no longer needed. For
2756  * strings and boxed types you will receive a copy which you will need to
2757  * release with either g_free() or the suitable function for the boxed type.
2758  *
2759  * Returns: %FALSE if there was a problem reading any of the fields (e.g.
2760  *     because the field requested did not exist, or was of a type other
2761  *     than the type specified), otherwise %TRUE.
2762  */
2763 gboolean
2764 gst_structure_get (const GstStructure * structure, const char *first_fieldname,
2765     ...)
2766 {
2767   gboolean ret;
2768   va_list args;
2769 
2770   g_return_val_if_fail (GST_IS_STRUCTURE (structure), FALSE);
2771   g_return_val_if_fail (first_fieldname != NULL, FALSE);
2772 
2773   va_start (args, first_fieldname);
2774   ret = gst_structure_get_valist (structure, first_fieldname, args);
2775   va_end (args);
2776 
2777   return ret;
2778 }
2779 
2780 /**
2781  * gst_structure_id_get:
2782  * @structure: a #GstStructure
2783  * @first_field_id: the quark of the first field to read
2784  * @...: variable arguments
2785  *
2786  * Parses the variable arguments and reads fields from @structure accordingly.
2787  * Variable arguments should be in the form field id quark, field type
2788  * (as a GType), pointer(s) to a variable(s) to hold the return value(s).
2789  * The last variable argument should be %NULL (technically it should be a
2790  * 0 quark, but we require %NULL so compilers that support it can check for
2791  * the %NULL terminator and warn if it&#39;s not there).
2792  *
2793  * This function is just like gst_structure_get() only that it is slightly
2794  * more efficient since it saves the string-to-quark lookup in the global
2795  * quark hashtable.
2796  *
2797  * For refcounted (mini)objects you will receive a new reference which
2798  * you must release with a suitable _unref() when no longer needed. For
2799  * strings and boxed types you will receive a copy which you will need to
2800  * release with either g_free() or the suitable function for the boxed type.
2801  *
2802  * Returns: %FALSE if there was a problem reading any of the fields (e.g.
2803  *     because the field requested did not exist, or was of a type other
2804  *     than the type specified), otherwise %TRUE.
2805  */
2806 gboolean
2807 gst_structure_id_get (const GstStructure * structure, GQuark first_field_id,
2808     ...)
2809 {
2810   gboolean ret;
2811   va_list args;
2812 
2813   g_return_val_if_fail (GST_IS_STRUCTURE (structure), FALSE);
2814   g_return_val_if_fail (first_field_id != 0, FALSE);
2815 
2816   va_start (args, first_field_id);
2817   ret = gst_structure_id_get_valist (structure, first_field_id, args);
2818   va_end (args);
2819 
2820   return ret;
2821 }
2822 
2823 static gboolean
2824 gst_structure_is_equal_foreach (GQuark field_id, const GValue * val2,
2825     gpointer data)
2826 {
2827   const GstStructure *struct1 = (const GstStructure *) data;
2828   const GValue *val1 = gst_structure_id_get_value (struct1, field_id);
2829 
2830   if (G_UNLIKELY (val1 == NULL))
2831     return FALSE;
2832   if (gst_value_compare (val1, val2) == GST_VALUE_EQUAL) {
2833     return TRUE;
2834   }
2835 
2836   return FALSE;
2837 }
2838 
2839 /**
2840  * gst_structure_is_equal:
2841  * @structure1: a #GstStructure.
2842  * @structure2: a #GstStructure.
2843  *
2844  * Tests if the two #GstStructure are equal.
2845  *
2846  * Returns: %TRUE if the two structures have the same name and field.
2847  **/
2848 gboolean
2849 gst_structure_is_equal (const GstStructure * structure1,
2850     const GstStructure * structure2)
2851 {
2852   g_return_val_if_fail (GST_IS_STRUCTURE (structure1), FALSE);
2853   g_return_val_if_fail (GST_IS_STRUCTURE (structure2), FALSE);
2854 
2855   if (G_UNLIKELY (structure1 == structure2))
2856     return TRUE;
2857 
2858   if (structure1-&gt;name != structure2-&gt;name) {
2859     return FALSE;
2860   }
2861   if (GST_STRUCTURE_FIELDS (structure1)-&gt;len !=
2862       GST_STRUCTURE_FIELDS (structure2)-&gt;len) {
2863     return FALSE;
2864   }
2865 
2866   return gst_structure_foreach (structure1, gst_structure_is_equal_foreach,
2867       (gpointer) structure2);
2868 }
2869 
2870 
2871 typedef struct
2872 {
2873   GstStructure *dest;
2874   const GstStructure *intersect;
2875 }
2876 IntersectData;
2877 
2878 static gboolean
2879 gst_structure_intersect_field1 (GQuark id, const GValue * val1, gpointer data)
2880 {
2881   IntersectData *idata = (IntersectData *) data;
2882   const GValue *val2 = gst_structure_id_get_value (idata-&gt;intersect, id);
2883 
2884   if (G_UNLIKELY (val2 == NULL)) {
2885     gst_structure_id_set_value (idata-&gt;dest, id, val1);
2886   } else {
2887     GValue dest_value = { 0 };
2888     if (gst_value_intersect (&amp;dest_value, val1, val2)) {
2889       gst_structure_id_take_value (idata-&gt;dest, id, &amp;dest_value);
2890     } else {
2891       return FALSE;
2892     }
2893   }
2894   return TRUE;
2895 }
2896 
2897 static gboolean
2898 gst_structure_intersect_field2 (GQuark id, const GValue * val1, gpointer data)
2899 {
2900   IntersectData *idata = (IntersectData *) data;
2901   const GValue *val2 = gst_structure_id_get_value (idata-&gt;intersect, id);
2902 
2903   if (G_UNLIKELY (val2 == NULL)) {
2904     gst_structure_id_set_value (idata-&gt;dest, id, val1);
2905   }
2906   return TRUE;
2907 }
2908 
2909 /**
2910  * gst_structure_intersect:
2911  * @struct1: a #GstStructure
2912  * @struct2: a #GstStructure
2913  *
2914  * Intersects @struct1 and @struct2 and returns the intersection.
2915  *
2916  * Returns: (nullable): Intersection of @struct1 and @struct2
2917  */
2918 GstStructure *
2919 gst_structure_intersect (const GstStructure * struct1,
2920     const GstStructure * struct2)
2921 {
2922   IntersectData data;
2923 
2924   g_assert (struct1 != NULL);
2925   g_assert (struct2 != NULL);
2926 
2927   if (G_UNLIKELY (struct1-&gt;name != struct2-&gt;name))
2928     return NULL;
2929 
2930   /* copy fields from struct1 which we have not in struct2 to target
2931    * intersect if we have the field in both */
2932   data.dest = gst_structure_new_id_empty (struct1-&gt;name);
2933   data.intersect = struct2;
2934   if (G_UNLIKELY (!gst_structure_foreach ((GstStructure *) struct1,
2935               gst_structure_intersect_field1, &amp;data)))
2936     goto error;
2937 
2938   /* copy fields from struct2 which we have not in struct1 to target */
2939   data.intersect = struct1;
2940   if (G_UNLIKELY (!gst_structure_foreach ((GstStructure *) struct2,
2941               gst_structure_intersect_field2, &amp;data)))
2942     goto error;
2943 
2944   return data.dest;
2945 
2946 error:
2947   gst_structure_free (data.dest);
2948   return NULL;
2949 }
2950 
2951 static gboolean
2952 gst_caps_structure_can_intersect_field (GQuark id, const GValue * val1,
2953     gpointer data)
2954 {
2955   GstStructure *other = (GstStructure *) data;
2956   const GValue *val2 = gst_structure_id_get_value (other, id);
2957 
2958   if (G_LIKELY (val2)) {
2959     if (!gst_value_can_intersect (val1, val2)) {
2960       return FALSE;
2961     } else {
2962       gint eq = gst_value_compare (val1, val2);
2963 
2964       if (eq == GST_VALUE_UNORDERED) {
2965         /* we need to try interseting */
2966         if (!gst_value_intersect (NULL, val1, val2)) {
2967           return FALSE;
2968         }
2969       } else if (eq != GST_VALUE_EQUAL) {
2970         return FALSE;
2971       }
2972     }
2973   }
2974   return TRUE;
2975 }
2976 
2977 /**
2978  * gst_structure_can_intersect:
2979  * @struct1: a #GstStructure
2980  * @struct2: a #GstStructure
2981  *
2982  * Tries intersecting @struct1 and @struct2 and reports whether the result
2983  * would not be empty.
2984  *
2985  * Returns: %TRUE if intersection would not be empty
2986  */
2987 gboolean
2988 gst_structure_can_intersect (const GstStructure * struct1,
2989     const GstStructure * struct2)
2990 {
2991   g_return_val_if_fail (GST_IS_STRUCTURE (struct1), FALSE);
2992   g_return_val_if_fail (GST_IS_STRUCTURE (struct2), FALSE);
2993 
2994   if (G_UNLIKELY (struct1-&gt;name != struct2-&gt;name))
2995     return FALSE;
2996 
2997   /* tries to intersect if we have the field in both */
2998   return gst_structure_foreach ((GstStructure *) struct1,
2999       gst_caps_structure_can_intersect_field, (gpointer) struct2);
3000 }
3001 
3002 static gboolean
3003 gst_caps_structure_is_superset_field (GQuark field_id, const GValue * value,
3004     gpointer user_data)
3005 {
3006   GstStructure *subset = user_data;
3007   const GValue *other;
3008   int comparison;
3009 
3010   if (!(other = gst_structure_id_get_value (subset, field_id)))
3011     /* field is missing in the subset =&gt; no subset */
3012     return FALSE;
3013 
3014   comparison = gst_value_compare (value, other);
3015 
3016   /* equal values are subset */
3017   if (comparison == GST_VALUE_EQUAL)
3018     return TRUE;
3019 
3020   /* ordered, but unequal, values are not */
3021   if (comparison != GST_VALUE_UNORDERED)
3022     return FALSE;
3023 
3024   return gst_value_is_subset (other, value);
3025 }
3026 
3027 /**
3028  * gst_structure_is_subset:
3029  * @subset: a #GstStructure
3030  * @superset: a potentially greater #GstStructure
3031  *
3032  * Checks if @subset is a subset of @superset, i.e. has the same
3033  * structure name and for all fields that are existing in @superset,
3034  * @subset has a value that is a subset of the value in @superset.
3035  *
3036  * Returns: %TRUE if @subset is a subset of @superset
3037  */
3038 gboolean
3039 gst_structure_is_subset (const GstStructure * subset,
3040     const GstStructure * superset)
3041 {
3042   if ((superset-&gt;name != subset-&gt;name) ||
3043       (gst_structure_n_fields (superset) &gt; gst_structure_n_fields (subset)))
3044     return FALSE;
3045 
3046   return gst_structure_foreach ((GstStructure *) superset,
3047       gst_caps_structure_is_superset_field, (gpointer) subset);
3048 }
3049 
3050 
3051 /**
3052  * gst_structure_fixate:
3053  * @structure: a #GstStructure
3054  *
3055  * Fixate all values in @structure using gst_value_fixate().
3056  * @structure will be modified in-place and should be writable.
3057  */
3058 void
3059 gst_structure_fixate (GstStructure * structure)
3060 {
3061   g_return_if_fail (GST_IS_STRUCTURE (structure));
3062 
3063   gst_structure_foreach (structure, default_fixate, structure);
3064 }
3065 
3066 static gboolean
3067 _gst_structure_get_any_list (GstStructure * structure, GType type,
3068     const gchar * fieldname, GValueArray ** array)
3069 {
3070   GstStructureField *field;
3071   GValue val = G_VALUE_INIT;
3072 
3073   g_return_val_if_fail (structure != NULL, FALSE);
3074   g_return_val_if_fail (fieldname != NULL, FALSE);
3075   g_return_val_if_fail (array != NULL, FALSE);
3076 
3077   field = gst_structure_get_field (structure, fieldname);
3078 
3079   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != type)
3080     return FALSE;
3081 
3082   g_value_init (&amp;val, G_TYPE_VALUE_ARRAY);
3083 
3084   if (g_value_transform (&amp;field-&gt;value, &amp;val)) {
3085     *array = g_value_get_boxed (&amp;val);
3086     return TRUE;
3087   }
3088 
3089   g_value_unset (&amp;val);
3090   return FALSE;
3091 }
3092 
3093 /**
3094  * gst_structure_get_array:
3095  * @structure: a #GstStructure
3096  * @fieldname: the name of a field
3097  * @array: (out): a pointer to a #GValueArray
3098  *
3099  * This is useful in language bindings where unknown #GValue types are not
<a name="11" id="anc11"></a><span class="line-modified">3100  * supported. This function will convert the %GST_TYPE_ARRAY into a newly</span>
<span class="line-modified">3101  * allocated #GValueArray and return it through @array. Be aware that this is</span>
<span class="line-modified">3102  * slower then getting the #GValue directly.</span>
3103  *
3104  * Returns: %TRUE if the value could be set correctly. If there was no field
<a name="12" id="anc12"></a><span class="line-modified">3105  * with @fieldname or the existing field did not contain a %GST_TYPE_ARRAY,</span>
<span class="line-modified">3106  * this function returns %FALSE.</span>
3107  */
3108 gboolean
3109 gst_structure_get_array (GstStructure * structure, const gchar * fieldname,
3110     GValueArray ** array)
3111 {
3112   return _gst_structure_get_any_list (structure, GST_TYPE_ARRAY, fieldname,
3113       array);
3114 }
3115 
3116 /**
3117  * gst_structure_get_list:
3118  * @structure: a #GstStructure
3119  * @fieldname: the name of a field
3120  * @array: (out): a pointer to a #GValueArray
3121  *
3122  * This is useful in language bindings where unknown #GValue types are not
<a name="13" id="anc13"></a><span class="line-modified">3123  * supported. This function will convert the %GST_TYPE_LIST into a newly</span>
<span class="line-modified">3124  * allocated GValueArray and return it through @array. Be aware that this is</span>
<span class="line-modified">3125  * slower then getting the #GValue directly.</span>
3126  *
3127  * Returns: %TRUE if the value could be set correctly. If there was no field
<a name="14" id="anc14"></a><span class="line-modified">3128  * with @fieldname or the existing field did not contain a %GST_TYPE_LIST, this</span>
<span class="line-modified">3129  * function returns %FALSE.</span>
3130  *
<a name="15" id="anc15"></a><span class="line-modified">3131  * Since: 1.12</span>
3132  */
3133 gboolean
3134 gst_structure_get_list (GstStructure * structure, const gchar * fieldname,
3135     GValueArray ** array)
3136 {
3137   return _gst_structure_get_any_list (structure, GST_TYPE_LIST, fieldname,
3138       array);
3139 }
3140 
3141 static void
3142 _gst_structure_set_any_list (GstStructure * structure, GType type,
3143     const gchar * fieldname, const GValueArray * array)
3144 {
3145   GValue arval = G_VALUE_INIT;
3146   GValue value = G_VALUE_INIT;
3147 
3148   g_return_if_fail (structure != NULL);
3149   g_return_if_fail (fieldname != NULL);
3150   g_return_if_fail (array != NULL);
3151   g_return_if_fail (IS_MUTABLE (structure));
3152 
3153   g_value_init (&amp;value, type);
3154   g_value_init (&amp;arval, G_TYPE_VALUE_ARRAY);
3155   g_value_set_static_boxed (&amp;arval, array);
3156 
3157   if (g_value_transform (&amp;arval, &amp;value)) {
3158     gst_structure_id_set_value_internal (structure,
3159         g_quark_from_string (fieldname), &amp;value);
3160   } else {
3161     g_warning (&quot;Failed to convert a GValueArray&quot;);
3162   }
3163 
3164   g_value_unset (&amp;arval);
3165   g_value_unset (&amp;value);
3166 }
3167 
3168 /**
3169  * gst_structure_set_array:
3170  * @structure: a #GstStructure
3171  * @fieldname: the name of a field
3172  * @array: a pointer to a #GValueArray
3173  *
3174  * This is useful in language bindings where unknown GValue types are not
3175  * supported. This function will convert a @array to %GST_TYPE_ARRAY and set
3176  * the field specified by @fieldname.  Be aware that this is slower then using
3177  * %GST_TYPE_ARRAY in a #GValue directly.
3178  *
<a name="16" id="anc16"></a><span class="line-modified">3179  * Since: 1.12</span>
3180  */
3181 void
3182 gst_structure_set_array (GstStructure * structure, const gchar * fieldname,
3183     const GValueArray * array)
3184 {
3185   _gst_structure_set_any_list (structure, GST_TYPE_ARRAY, fieldname, array);
3186 }
3187 
3188 /**
3189  * gst_structure_set_list:
3190  * @structure: a #GstStructure
3191  * @fieldname: the name of a field
3192  * @array: a pointer to a #GValueArray
3193  *
3194  * This is useful in language bindings where unknown GValue types are not
<a name="17" id="anc17"></a><span class="line-modified">3195  * supported. This function will convert a @array to %GST_TYPE_LIST and set</span>
3196  * the field specified by @fieldname. Be aware that this is slower then using
<a name="18" id="anc18"></a><span class="line-modified">3197  * %GST_TYPE_LIST in a #GValue directly.</span>
3198  *
<a name="19" id="anc19"></a><span class="line-modified">3199  * Since: 1.12</span>
3200  */
3201 void
3202 gst_structure_set_list (GstStructure * structure, const gchar * fieldname,
3203     const GValueArray * array)
3204 {
3205   _gst_structure_set_any_list (structure, GST_TYPE_LIST, fieldname, array);
3206 }
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>