<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gstdio.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* gstdio.c - wrappers for C library functions
   2  *
   3  * Copyright 2004 Tor Lillqvist
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public License
  16  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  */
  18 
  19 #include &quot;config.h&quot;
  20 #include &quot;glibconfig.h&quot;
  21 
<a name="1" id="anc1"></a><span class="line-modified">  22 #define G_STDIO_NO_WRAP_ON_UNIX</span>


  23 
  24 #include &lt;sys/types.h&gt;
  25 #include &lt;sys/stat.h&gt;
  26 #include &lt;fcntl.h&gt;
  27 
  28 #ifdef G_OS_UNIX
  29 #include &lt;unistd.h&gt;
  30 #endif
  31 
  32 #ifdef G_OS_WIN32
  33 #include &lt;windows.h&gt;
  34 #include &lt;errno.h&gt;
  35 #include &lt;wchar.h&gt;
  36 #include &lt;direct.h&gt;
  37 #include &lt;io.h&gt;
  38 #include &lt;sys/utime.h&gt;
<a name="2" id="anc2"></a>
  39 #else
  40 #include &lt;utime.h&gt;
  41 #include &lt;errno.h&gt;
  42 #endif
  43 
  44 #include &quot;gstdio.h&quot;
  45 #include &quot;gstdioprivate.h&quot;
  46 
  47 #if !defined (G_OS_UNIX) &amp;&amp; !defined (G_OS_WIN32)
  48 #error Please port this to your operating system
  49 #endif
  50 
  51 #if defined (_MSC_VER) &amp;&amp; !defined(_WIN64)
  52 #undef _wstat
  53 #define _wstat _wstat32
  54 #endif
  55 
  56 #if defined (G_OS_WIN32)
  57 
  58 /* We can&#39;t include Windows DDK and Windows SDK simultaneously,
  59  * so let&#39;s copy this here from MinGW-w64 DDK.
  60  * The structure is ultimately documented here:
  61  * https://msdn.microsoft.com/en-us/library/ff552012(v=vs.85).aspx
  62  */
  63 typedef struct _REPARSE_DATA_BUFFER
  64 {
  65   ULONG  ReparseTag;
  66   USHORT ReparseDataLength;
  67   USHORT Reserved;
  68   union
  69   {
  70     struct
  71     {
  72       USHORT SubstituteNameOffset;
  73       USHORT SubstituteNameLength;
  74       USHORT PrintNameOffset;
  75       USHORT PrintNameLength;
  76       ULONG  Flags;
  77       WCHAR  PathBuffer[1];
  78     } SymbolicLinkReparseBuffer;
  79     struct
  80     {
  81       USHORT SubstituteNameOffset;
  82       USHORT SubstituteNameLength;
  83       USHORT PrintNameOffset;
  84       USHORT PrintNameLength;
  85       WCHAR  PathBuffer[1];
  86     } MountPointReparseBuffer;
  87     struct
  88     {
  89       UCHAR  DataBuffer[1];
  90     } GenericReparseBuffer;
  91   };
  92 } REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;
  93 
  94 static int
  95 w32_error_to_errno (DWORD error_code)
  96 {
  97   switch (error_code)
  98     {
  99     case ERROR_ACCESS_DENIED:
 100       return EACCES;
 101       break;
<a name="3" id="anc3"></a><span class="line-modified"> 102     case ERROR_INVALID_HANDLE:</span>
<span class="line-modified"> 103       return EBADF;</span>



 104       break;
 105     case ERROR_INVALID_FUNCTION:
 106       return EFAULT;
 107       break;
<a name="4" id="anc4"></a><span class="line-modified"> 108     case ERROR_FILE_NOT_FOUND:</span>
<span class="line-modified"> 109       return ENOENT;</span>
 110       break;
<a name="5" id="anc5"></a><span class="line-modified"> 111     case ERROR_PATH_NOT_FOUND:</span>
<span class="line-modified"> 112       return ENOENT; /* or ELOOP, or ENAMETOOLONG */</span>




 113       break;
 114     case ERROR_NOT_ENOUGH_MEMORY:
 115     case ERROR_OUTOFMEMORY:
 116       return ENOMEM;
 117       break;
<a name="6" id="anc6"></a>





 118     default:
 119       return EIO;
 120       break;
 121     }
 122 }
 123 
 124 #include &quot;gstdio-private.c&quot;
 125 
<a name="7" id="anc7"></a>








































































































































































































































































































































































































































 126 static int
 127 _g_win32_stat_utf16_no_trailing_slashes (const gunichar2    *filename,
<a name="8" id="anc8"></a><span class="line-removed"> 128                                          int                 fd,</span>
 129                                          GWin32PrivateStat  *buf,
 130                                          gboolean            for_symlink)
 131 {
<a name="9" id="anc9"></a><span class="line-removed"> 132   HANDLE file_handle;</span>
<span class="line-removed"> 133   gboolean succeeded_so_far;</span>
<span class="line-removed"> 134   DWORD error_code;</span>
 135   struct __stat64 statbuf;
 136   BY_HANDLE_FILE_INFORMATION handle_info;
 137   FILE_STANDARD_INFO std_info;
<a name="10" id="anc10"></a><span class="line-removed"> 138   WIN32_FIND_DATAW finddata;</span>
<span class="line-removed"> 139   DWORD immediate_attributes;</span>
 140   gboolean is_symlink = FALSE;
<a name="11" id="anc11"></a><span class="line-removed"> 141   gboolean is_directory;</span>
<span class="line-removed"> 142   DWORD open_flags;</span>
 143   wchar_t *filename_target = NULL;
<a name="12" id="anc12"></a><span class="line-modified"> 144   int result;</span>






 145 
<a name="13" id="anc13"></a><span class="line-modified"> 146   if (fd &lt; 0)</span>
<span class="line-removed"> 147     {</span>
<span class="line-removed"> 148       immediate_attributes = GetFileAttributesW (filename);</span>
 149 
<a name="14" id="anc14"></a><span class="line-modified"> 150       if (immediate_attributes == INVALID_FILE_ATTRIBUTES)</span>
<span class="line-modified"> 151         {</span>
<span class="line-modified"> 152           error_code = GetLastError ();</span>
<span class="line-modified"> 153           errno = w32_error_to_errno (error_code);</span>
 154 
<a name="15" id="anc15"></a><span class="line-modified"> 155           return -1;</span>
<span class="line-modified"> 156         }</span>
 157 
<a name="16" id="anc16"></a><span class="line-modified"> 158       is_symlink = (immediate_attributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;</span>
<span class="line-modified"> 159       is_directory = (immediate_attributes &amp; FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY;</span>
 160 
<a name="17" id="anc17"></a><span class="line-modified"> 161       open_flags = FILE_ATTRIBUTE_NORMAL;</span>
 162 
<a name="18" id="anc18"></a><span class="line-modified"> 163       if (for_symlink &amp;&amp; is_symlink)</span>
<span class="line-modified"> 164         open_flags |= FILE_FLAG_OPEN_REPARSE_POINT;</span>
 165 
<a name="19" id="anc19"></a><span class="line-modified"> 166       if (is_directory)</span>
<span class="line-modified"> 167         open_flags |= FILE_FLAG_BACKUP_SEMANTICS;</span>
 168 
<a name="20" id="anc20"></a><span class="line-modified"> 169       file_handle = CreateFileW (filename, FILE_READ_ATTRIBUTES,</span>
<span class="line-modified"> 170                                  FILE_SHARE_READ, NULL, OPEN_EXISTING,</span>
<span class="line-modified"> 171                                  open_flags,</span>
<span class="line-modified"> 172                                  NULL);</span>

 173 
<a name="21" id="anc21"></a><span class="line-modified"> 174       if (file_handle == INVALID_HANDLE_VALUE)</span>
<span class="line-removed"> 175         {</span>
<span class="line-removed"> 176           error_code = GetLastError ();</span>
<span class="line-removed"> 177           errno = w32_error_to_errno (error_code);</span>
<span class="line-removed"> 178           return -1;</span>
<span class="line-removed"> 179         }</span>
<span class="line-removed"> 180     }</span>
<span class="line-removed"> 181   else</span>
 182     {
<a name="22" id="anc22"></a><span class="line-modified"> 183       file_handle = (HANDLE) _get_osfhandle (fd);</span>
<span class="line-modified"> 184 </span>
<span class="line-modified"> 185       if (file_handle == INVALID_HANDLE_VALUE)</span>
<span class="line-removed"> 186         return -1;</span>
 187     }
 188 
 189   succeeded_so_far = GetFileInformationByHandle (file_handle,
 190                                                  &amp;handle_info);
 191   error_code = GetLastError ();
 192 
 193   if (succeeded_so_far)
 194     {
 195       succeeded_so_far = GetFileInformationByHandleEx (file_handle,
 196                                                        FileStandardInfo,
 197                                                        &amp;std_info,
 198                                                        sizeof (std_info));
 199       error_code = GetLastError ();
 200     }
 201 
 202   if (!succeeded_so_far)
 203     {
<a name="23" id="anc23"></a><span class="line-modified"> 204       if (fd &lt; 0)</span>
<span class="line-removed"> 205         CloseHandle (file_handle);</span>
 206       errno = w32_error_to_errno (error_code);
 207       return -1;
 208     }
 209 
 210   /* It&#39;s tempting to use GetFileInformationByHandleEx(FileAttributeTagInfo),
 211    * but it always reports that the ReparseTag is 0.
<a name="24" id="anc24"></a>


 212    */
<a name="25" id="anc25"></a><span class="line-modified"> 213   if (fd &lt; 0)</span>






 214     {
<a name="26" id="anc26"></a><span class="line-modified"> 215       memset (&amp;finddata, 0, sizeof (finddata));</span>


 216 
<a name="27" id="anc27"></a><span class="line-modified"> 217       if (handle_info.dwFileAttributes &amp; FILE_ATTRIBUTE_REPARSE_POINT)</span>
<span class="line-removed"> 218         {</span>
<span class="line-removed"> 219           HANDLE tmp = FindFirstFileW (filename,</span>
<span class="line-removed"> 220                                        &amp;finddata);</span>
<span class="line-removed"> 221 </span>
<span class="line-removed"> 222           if (tmp == INVALID_HANDLE_VALUE)</span>
<span class="line-removed"> 223             {</span>
<span class="line-removed"> 224               error_code = GetLastError ();</span>
<span class="line-removed"> 225               errno = w32_error_to_errno (error_code);</span>
<span class="line-removed"> 226               CloseHandle (file_handle);</span>
<span class="line-removed"> 227               return -1;</span>
<span class="line-removed"> 228             }</span>
<span class="line-removed"> 229 </span>
<span class="line-removed"> 230           FindClose (tmp);</span>
<span class="line-removed"> 231         }</span>
 232 
<a name="28" id="anc28"></a><span class="line-modified"> 233       if (is_symlink &amp;&amp; !for_symlink)</span>
<span class="line-modified"> 234         {</span>
<span class="line-modified"> 235           /* If filename is a symlink, _wstat64 obtains information about</span>
<span class="line-modified"> 236            * the symlink (except that st_size will be 0).</span>
<span class="line-modified"> 237            * To get information about the target we need to resolve</span>
<span class="line-modified"> 238            * the symlink first. And we need _wstat64() to get st_dev,</span>
<span class="line-modified"> 239            * it&#39;s a bother to try finding it ourselves.</span>
<span class="line-modified"> 240            */</span>
<span class="line-modified"> 241           DWORD filename_target_len;</span>
<span class="line-modified"> 242           DWORD new_len;</span>
<span class="line-removed"> 243 </span>
<span class="line-removed"> 244           /* Just in case, give it a real memory location instead of NULL */</span>
<span class="line-removed"> 245           new_len = GetFinalPathNameByHandleW (file_handle,</span>
<span class="line-removed"> 246                                                (wchar_t *) &amp;filename_target_len,</span>
<span class="line-removed"> 247                                                0,</span>
<span class="line-removed"> 248                                                FILE_NAME_NORMALIZED);</span>
<span class="line-removed"> 249 </span>
<span class="line-removed"> 250 #define SANE_LIMIT 1024 * 10</span>
<span class="line-removed"> 251           if (new_len &gt;= SANE_LIMIT)</span>
<span class="line-removed"> 252 #undef SANE_LIMIT</span>
<span class="line-removed"> 253             {</span>
<span class="line-removed"> 254               new_len = 0;</span>
<span class="line-removed"> 255               error_code = ERROR_BUFFER_OVERFLOW;</span>
<span class="line-removed"> 256             }</span>
<span class="line-removed"> 257           else if (new_len == 0)</span>
<span class="line-removed"> 258             {</span>
<span class="line-removed"> 259               error_code = GetLastError ();</span>
<span class="line-removed"> 260             }</span>
<span class="line-removed"> 261 </span>
<span class="line-removed"> 262           if (new_len &gt; 0)</span>
<span class="line-removed"> 263             {</span>
<span class="line-removed"> 264               /* Pretend that new_len doesn&#39;t count the terminating NUL char,</span>
<span class="line-removed"> 265                * and ask for a bit more space than is needed, and allocate even more.</span>
<span class="line-removed"> 266                */</span>
<span class="line-removed"> 267               filename_target_len = new_len + 3;</span>
<span class="line-removed"> 268               filename_target = g_malloc ((filename_target_len + 1) * sizeof (wchar_t));</span>
<span class="line-removed"> 269 </span>
<span class="line-removed"> 270               new_len = GetFinalPathNameByHandleW (file_handle,</span>
<span class="line-removed"> 271                                                    filename_target,</span>
<span class="line-removed"> 272                                                    filename_target_len,</span>
<span class="line-removed"> 273                                                    FILE_NAME_NORMALIZED);</span>
<span class="line-removed"> 274 </span>
<span class="line-removed"> 275               /* filename_target_len is already larger than needed,</span>
<span class="line-removed"> 276                * new_len should be smaller than that, even if the size</span>
<span class="line-removed"> 277                * is off by 1 for some reason.</span>
<span class="line-removed"> 278                */</span>
<span class="line-removed"> 279               if (new_len &gt;= filename_target_len - 1)</span>
<span class="line-removed"> 280                 {</span>
<span class="line-removed"> 281                   new_len = 0;</span>
<span class="line-removed"> 282                   error_code = ERROR_BUFFER_OVERFLOW;</span>
<span class="line-removed"> 283                   g_clear_pointer (&amp;filename_target, g_free);</span>
<span class="line-removed"> 284                 }</span>
<span class="line-removed"> 285               else if (new_len == 0)</span>
<span class="line-removed"> 286                 {</span>
<span class="line-removed"> 287                   g_clear_pointer (&amp;filename_target, g_free);</span>
<span class="line-removed"> 288                 }</span>
<span class="line-removed"> 289               /* GetFinalPathNameByHandle() is documented to return extended paths,</span>
<span class="line-removed"> 290                * strip the extended prefix, if it is followed by a drive letter</span>
<span class="line-removed"> 291                * and a colon. Otherwise keep it (the path could be</span>
<span class="line-removed"> 292                * \\\\?\\Volume{GUID}\\ - it&#39;s only usable in extended form).</span>
<span class="line-removed"> 293                */</span>
<span class="line-removed"> 294               else if (new_len &gt; 0)</span>
<span class="line-removed"> 295                 {</span>
<span class="line-removed"> 296                   gsize len = new_len;</span>
<span class="line-removed"> 297 </span>
<span class="line-removed"> 298                   /* Account for NUL-terminator maybe not being counted.</span>
<span class="line-removed"> 299                    * This is why we overallocated earlier.</span>
<span class="line-removed"> 300                    */</span>
<span class="line-removed"> 301                   if (filename_target[len] != L&#39;\0&#39;)</span>
<span class="line-removed"> 302                     {</span>
<span class="line-removed"> 303                       len++;</span>
<span class="line-removed"> 304                       filename_target[len] = L&#39;\0&#39;;</span>
<span class="line-removed"> 305                 }</span>
<span class="line-removed"> 306 </span>
<span class="line-removed"> 307                   _g_win32_strip_extended_ntobjm_prefix (filename_target, &amp;len);</span>
<span class="line-removed"> 308                   new_len = len;</span>
<span class="line-removed"> 309             }</span>
<span class="line-removed"> 310 </span>
<span class="line-removed"> 311             }</span>
<span class="line-removed"> 312 </span>
<span class="line-removed"> 313           if (new_len == 0)</span>
<span class="line-removed"> 314             succeeded_so_far = FALSE;</span>
<span class="line-removed"> 315         }</span>
 316 
<a name="29" id="anc29"></a><span class="line-modified"> 317       CloseHandle (file_handle);</span>
<span class="line-modified"> 318     }</span>
<span class="line-removed"> 319   /* else if fd &gt;= 0 the file_handle was obtained via _get_osfhandle()</span>
<span class="line-removed"> 320    * and must not be closed, it is owned by fd.</span>
<span class="line-removed"> 321    */</span>
 322 
<a name="30" id="anc30"></a><span class="line-modified"> 323   if (!succeeded_so_far)</span>
<span class="line-modified"> 324     {</span>
<span class="line-modified"> 325       errno = w32_error_to_errno (error_code);</span>
<span class="line-modified"> 326       return -1;</span>
<span class="line-modified"> 327     }</span>








 328 
<a name="31" id="anc31"></a><span class="line-modified"> 329   if (fd &lt; 0)</span>
<span class="line-removed"> 330     result = _wstat64 (filename_target != NULL ? filename_target : filename, &amp;statbuf);</span>
<span class="line-removed"> 331   else</span>
<span class="line-removed"> 332     result = _fstat64 (fd, &amp;statbuf);</span>
 333 
<a name="32" id="anc32"></a><span class="line-modified"> 334   if (result != 0)</span>
<span class="line-modified"> 335     {</span>
<span class="line-removed"> 336       int errsv = errno;</span>
 337 
<a name="33" id="anc33"></a><span class="line-modified"> 338       g_free (filename_target);</span>
<span class="line-modified"> 339       errno = errsv;</span>

 340 
<a name="34" id="anc34"></a>











 341       return -1;
 342     }
 343 
<a name="35" id="anc35"></a><span class="line-modified"> 344   g_free (filename_target);</span>
 345 
<a name="36" id="anc36"></a><span class="line-modified"> 346   buf-&gt;st_dev = statbuf.st_dev;</span>
<span class="line-modified"> 347   buf-&gt;st_mode = statbuf.st_mode;</span>
<span class="line-modified"> 348   buf-&gt;volume_serial = handle_info.dwVolumeSerialNumber;</span>
<span class="line-removed"> 349   buf-&gt;file_index = (((guint64) handle_info.nFileIndexHigh) &lt;&lt; 32) | handle_info.nFileIndexLow;</span>
<span class="line-removed"> 350   /* Note that immediate_attributes is for the symlink</span>
<span class="line-removed"> 351    * (if it&#39;s a symlink), while handle_info contains info</span>
<span class="line-removed"> 352    * about the symlink or the target, depending on the flags</span>
<span class="line-removed"> 353    * we used earlier.</span>
<span class="line-removed"> 354    */</span>
<span class="line-removed"> 355   buf-&gt;attributes = handle_info.dwFileAttributes;</span>
<span class="line-removed"> 356   buf-&gt;st_nlink = handle_info.nNumberOfLinks;</span>
<span class="line-removed"> 357   buf-&gt;st_size = (((guint64) handle_info.nFileSizeHigh) &lt;&lt; 32) | handle_info.nFileSizeLow;</span>
<span class="line-removed"> 358   buf-&gt;allocated_size = std_info.AllocationSize.QuadPart;</span>
 359 
<a name="37" id="anc37"></a><span class="line-modified"> 360   if (fd &lt; 0 &amp;&amp; buf-&gt;attributes &amp; FILE_ATTRIBUTE_REPARSE_POINT)</span>
<span class="line-modified"> 361     buf-&gt;reparse_tag = finddata.dwReserved0;</span>
<span class="line-removed"> 362   else</span>
<span class="line-removed"> 363     buf-&gt;reparse_tag = 0;</span>
 364 
<a name="38" id="anc38"></a><span class="line-modified"> 365   buf-&gt;st_ctime = statbuf.st_ctime;</span>
<span class="line-modified"> 366   buf-&gt;st_atime = statbuf.st_atime;</span>
<span class="line-modified"> 367   buf-&gt;st_mtime = statbuf.st_mtime;</span>


 368 
 369   return 0;
 370 }
 371 
<a name="39" id="anc39"></a>


 372 static int
 373 _g_win32_stat_utf8 (const gchar       *filename,
 374                     GWin32PrivateStat *buf,
 375                     gboolean           for_symlink)
 376 {
 377   wchar_t *wfilename;
 378   int result;
 379   gsize len;
 380 
 381   if (filename == NULL)
 382     {
 383       errno = EINVAL;
 384       return -1;
 385     }
 386 
 387   len = strlen (filename);
 388 
 389   while (len &gt; 0 &amp;&amp; G_IS_DIR_SEPARATOR (filename[len - 1]))
 390     len--;
 391 
 392   if (len &lt;= 0 ||
 393       (g_path_is_absolute (filename) &amp;&amp; len &lt;= g_path_skip_root (filename) - filename))
 394     len = strlen (filename);
 395 
 396   wfilename = g_utf8_to_utf16 (filename, len, NULL, NULL, NULL);
 397 
 398   if (wfilename == NULL)
 399     {
 400       errno = EINVAL;
 401       return -1;
 402     }
 403 
<a name="40" id="anc40"></a><span class="line-modified"> 404   result = _g_win32_stat_utf16_no_trailing_slashes (wfilename, -1, buf, for_symlink);</span>
 405 
 406   g_free (wfilename);
 407 
 408   return result;
 409 }
 410 
<a name="41" id="anc41"></a>


 411 int
 412 g_win32_stat_utf8 (const gchar       *filename,
 413                    GWin32PrivateStat *buf)
 414 {
 415   return _g_win32_stat_utf8 (filename, buf, FALSE);
 416 }
 417 
<a name="42" id="anc42"></a>


 418 int
 419 g_win32_lstat_utf8 (const gchar       *filename,
 420                     GWin32PrivateStat *buf)
 421 {
 422   return _g_win32_stat_utf8 (filename, buf, TRUE);
 423 }
 424 
<a name="43" id="anc43"></a>


 425 int
 426 g_win32_fstat (int                fd,
 427                GWin32PrivateStat *buf)
 428 {
<a name="44" id="anc44"></a><span class="line-modified"> 429   return _g_win32_stat_utf16_no_trailing_slashes (NULL, fd, buf, FALSE);</span>
 430 }
 431 
<a name="45" id="anc45"></a><span class="line-modified"> 432 static int</span>
<span class="line-modified"> 433 _g_win32_readlink_utf16_raw (const gunichar2 *filename,</span>
<span class="line-modified"> 434                              gunichar2       *buf,</span>
<span class="line-modified"> 435                              gsize            buf_size)</span>


































 436 {
<a name="46" id="anc46"></a><span class="line-modified"> 437   DWORD returned_bytes;</span>
<span class="line-modified"> 438   BYTE returned_data[MAXIMUM_REPARSE_DATA_BUFFER_SIZE]; /* This is 16k, by the way */</span>
<span class="line-modified"> 439   HANDLE h;</span>
<span class="line-modified"> 440   DWORD attributes;</span>
<span class="line-modified"> 441   REPARSE_DATA_BUFFER *rep_buf;</span>
<span class="line-removed"> 442   DWORD to_copy;</span>
<span class="line-removed"> 443   DWORD error_code;</span>
 444 
<a name="47" id="anc47"></a><span class="line-modified"> 445   if (buf_size &gt; G_MAXSIZE / sizeof (wchar_t))</span>
<span class="line-modified"> 446     {</span>
<span class="line-modified"> 447       /* &quot;buf_size * sizeof (wchar_t)&quot; overflows */</span>
<span class="line-removed"> 448       errno = EFAULT;</span>
<span class="line-removed"> 449       return -1;</span>
<span class="line-removed"> 450     }</span>
 451 
<a name="48" id="anc48"></a><span class="line-modified"> 452   if ((attributes = GetFileAttributesW (filename)) == 0)</span>
<span class="line-removed"> 453     {</span>
<span class="line-removed"> 454       error_code = GetLastError ();</span>
<span class="line-removed"> 455       errno = w32_error_to_errno (error_code);</span>
<span class="line-removed"> 456       return -1;</span>
<span class="line-removed"> 457     }</span>
 458 
<a name="49" id="anc49"></a><span class="line-modified"> 459   if ((attributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) == 0)</span>
 460     {
 461       errno = EINVAL;
 462       return -1;
 463     }
 464 
<a name="50" id="anc50"></a><span class="line-modified"> 465   /* To read symlink target we need to open the file as a reparse</span>
<span class="line-modified"> 466    * point and use DeviceIoControl() on it.</span>
<span class="line-removed"> 467    */</span>
<span class="line-removed"> 468   h = CreateFileW (filename,</span>
<span class="line-removed"> 469                    FILE_READ_EA,</span>
<span class="line-removed"> 470                    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,</span>
<span class="line-removed"> 471                    NULL, OPEN_EXISTING,</span>
<span class="line-removed"> 472                    FILE_ATTRIBUTE_NORMAL</span>
<span class="line-removed"> 473                    | FILE_FLAG_OPEN_REPARSE_POINT</span>
<span class="line-removed"> 474                    | (attributes &amp; FILE_ATTRIBUTE_DIRECTORY ? FILE_FLAG_BACKUP_SEMANTICS : 0),</span>
<span class="line-removed"> 475                    NULL);</span>
<span class="line-removed"> 476 </span>
<span class="line-removed"> 477   if (h == INVALID_HANDLE_VALUE)</span>
<span class="line-removed"> 478     {</span>
<span class="line-removed"> 479       error_code = GetLastError ();</span>
<span class="line-removed"> 480       errno = w32_error_to_errno (error_code);</span>
<span class="line-removed"> 481       return -1;</span>
<span class="line-removed"> 482     }</span>
<span class="line-removed"> 483 </span>
<span class="line-removed"> 484   if (!DeviceIoControl (h, FSCTL_GET_REPARSE_POINT, NULL, 0,</span>
<span class="line-removed"> 485                         returned_data, MAXIMUM_REPARSE_DATA_BUFFER_SIZE,</span>
<span class="line-removed"> 486                         &amp;returned_bytes, NULL))</span>
<span class="line-removed"> 487     {</span>
<span class="line-removed"> 488       error_code = GetLastError ();</span>
<span class="line-removed"> 489       errno = w32_error_to_errno (error_code);</span>
<span class="line-removed"> 490       CloseHandle (h);</span>
<span class="line-removed"> 491       return -1;</span>
<span class="line-removed"> 492     }</span>
<span class="line-removed"> 493 </span>
<span class="line-removed"> 494   rep_buf = (REPARSE_DATA_BUFFER *) returned_data;</span>
<span class="line-removed"> 495   to_copy = 0;</span>
 496 
<a name="51" id="anc51"></a><span class="line-modified"> 497   if (rep_buf-&gt;ReparseTag == IO_REPARSE_TAG_SYMLINK)</span>
<span class="line-removed"> 498     {</span>
<span class="line-removed"> 499       to_copy = rep_buf-&gt;SymbolicLinkReparseBuffer.SubstituteNameLength;</span>
<span class="line-removed"> 500 </span>
<span class="line-removed"> 501       if (to_copy &gt; buf_size * sizeof (wchar_t))</span>
<span class="line-removed"> 502         to_copy = buf_size * sizeof (wchar_t);</span>
<span class="line-removed"> 503 </span>
<span class="line-removed"> 504       memcpy (buf,</span>
<span class="line-removed"> 505               &amp;((BYTE *) rep_buf-&gt;SymbolicLinkReparseBuffer.PathBuffer)[rep_buf-&gt;SymbolicLinkReparseBuffer.SubstituteNameOffset],</span>
<span class="line-removed"> 506               to_copy);</span>
<span class="line-removed"> 507     }</span>
<span class="line-removed"> 508   else if (rep_buf-&gt;ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)</span>
<span class="line-removed"> 509     {</span>
<span class="line-removed"> 510       to_copy = rep_buf-&gt;MountPointReparseBuffer.SubstituteNameLength;</span>
<span class="line-removed"> 511 </span>
<span class="line-removed"> 512       if (to_copy &gt; buf_size * sizeof (wchar_t))</span>
<span class="line-removed"> 513         to_copy = buf_size * sizeof (wchar_t);</span>
<span class="line-removed"> 514 </span>
<span class="line-removed"> 515       memcpy (buf,</span>
<span class="line-removed"> 516               &amp;((BYTE *) rep_buf-&gt;MountPointReparseBuffer.PathBuffer)[rep_buf-&gt;MountPointReparseBuffer.SubstituteNameOffset],</span>
<span class="line-removed"> 517               to_copy);</span>
<span class="line-removed"> 518     }</span>
<span class="line-removed"> 519 </span>
<span class="line-removed"> 520   CloseHandle (h);</span>
<span class="line-removed"> 521 </span>
<span class="line-removed"> 522   return to_copy;</span>
<span class="line-removed"> 523 }</span>
<span class="line-removed"> 524 </span>
<span class="line-removed"> 525 static int</span>
<span class="line-removed"> 526 _g_win32_readlink_utf16 (const gunichar2 *filename,</span>
<span class="line-removed"> 527                          gunichar2       *buf,</span>
<span class="line-removed"> 528                          gsize            buf_size)</span>
<span class="line-removed"> 529 {</span>
<span class="line-removed"> 530   int   result = _g_win32_readlink_utf16_raw (filename, buf, buf_size);</span>
<span class="line-removed"> 531   gsize string_size;</span>
<span class="line-removed"> 532 </span>
<span class="line-removed"> 533   if (result &lt;= 0)</span>
<span class="line-removed"> 534     return result;</span>
<span class="line-removed"> 535 </span>
<span class="line-removed"> 536   /* Ensure that output is a multiple of sizeof (gunichar2),</span>
<span class="line-removed"> 537    * cutting any trailing partial gunichar2, if present.</span>
<span class="line-removed"> 538    */</span>
<span class="line-removed"> 539   result -= result % sizeof (gunichar2);</span>
 540 
 541   if (result &lt;= 0)
 542     return result;
 543 
<a name="52" id="anc52"></a><span class="line-modified"> 544   /* DeviceIoControl () tends to return filenames as NT Object Manager</span>
<span class="line-modified"> 545    * names , i.e. &quot;\\??\\C:\\foo\\bar&quot;.</span>
<span class="line-modified"> 546    * Remove the leading 4-byte \??\ prefix, as glib (as well as many W32 API</span>
<span class="line-modified"> 547    * functions) is unprepared to deal with it. Unless it has no &#39;x:&#39; drive</span>
<span class="line-modified"> 548    * letter part after the prefix, in which case we leave everything</span>
<span class="line-removed"> 549    * as-is, because the path could be &quot;\??\Volume{GUID}&quot; - stripping</span>
<span class="line-removed"> 550    * the prefix will allow it to be confused with relative links</span>
<span class="line-removed"> 551    * targeting &quot;Volume{GUID}&quot;.</span>
<span class="line-removed"> 552    */</span>
<span class="line-removed"> 553   string_size = result / sizeof (gunichar2);</span>
<span class="line-removed"> 554   _g_win32_strip_extended_ntobjm_prefix (buf, &amp;string_size);</span>
 555 
<a name="53" id="anc53"></a><span class="line-modified"> 556   return string_size * sizeof (gunichar2);</span>
<span class="line-removed"> 557 }</span>
 558 
<a name="54" id="anc54"></a><span class="line-modified"> 559 static gchar *</span>
<span class="line-removed"> 560 _g_win32_get_mode_alias (const gchar *mode)</span>
<span class="line-removed"> 561     {</span>
<span class="line-removed"> 562   gchar *alias;</span>
<span class="line-removed"> 563 </span>
<span class="line-removed"> 564   alias = g_strdup (mode);</span>
<span class="line-removed"> 565   if (strlen (mode) &gt; 2 &amp;&amp; mode[2] == &#39;+&#39;)</span>
<span class="line-removed"> 566     {</span>
<span class="line-removed"> 567       /* Windows implementation of fopen() does not accept modes such as</span>
<span class="line-removed"> 568        * &quot;wb+&quot;. The &#39;b&#39; needs to be appended to &quot;w+&quot;, i.e. &quot;w+b&quot;. Note</span>
<span class="line-removed"> 569        * that otherwise these 2 modes are supposed to be aliases, hence</span>
<span class="line-removed"> 570        * swappable at will.</span>
<span class="line-removed"> 571        */</span>
<span class="line-removed"> 572       alias[1] = &#39;+&#39;;</span>
<span class="line-removed"> 573       alias[2] = mode[1];</span>
<span class="line-removed"> 574     }</span>
<span class="line-removed"> 575 </span>
<span class="line-removed"> 576   return alias;</span>
<span class="line-removed"> 577 }</span>
<span class="line-removed"> 578 </span>
<span class="line-removed"> 579 int</span>
<span class="line-removed"> 580 g_win32_readlink_utf8 (const gchar *filename,</span>
<span class="line-removed"> 581                        gchar       *buf,</span>
<span class="line-removed"> 582                        gsize        buf_size)</span>
<span class="line-removed"> 583 {</span>
<span class="line-removed"> 584   wchar_t *wfilename;</span>
<span class="line-removed"> 585   int result;</span>
<span class="line-removed"> 586 </span>
<span class="line-removed"> 587   wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);</span>
<span class="line-removed"> 588 </span>
<span class="line-removed"> 589   if (wfilename == NULL)</span>
 590     {
 591       errno = EINVAL;
 592       return -1;
 593     }
 594 
<a name="55" id="anc55"></a><span class="line-modified"> 595   result = _g_win32_readlink_utf16 (wfilename, (gunichar2 *) buf, buf_size);</span>
<span class="line-removed"> 596 </span>
<span class="line-removed"> 597   g_free (wfilename);</span>
<span class="line-removed"> 598 </span>
<span class="line-removed"> 599   if (result &gt; 0)</span>
 600     {
<a name="56" id="anc56"></a><span class="line-modified"> 601       glong tmp_len;</span>
<span class="line-modified"> 602       gchar *tmp = g_utf16_to_utf8 ((const gunichar2 *) buf,</span>
<span class="line-removed"> 603                                     result / sizeof (gunichar2),</span>
<span class="line-removed"> 604                                     NULL,</span>
<span class="line-removed"> 605                                     &amp;tmp_len,</span>
<span class="line-removed"> 606                                     NULL);</span>
<span class="line-removed"> 607 </span>
<span class="line-removed"> 608       if (tmp == NULL)</span>
<span class="line-removed"> 609         {</span>
<span class="line-removed"> 610           errno = EINVAL;</span>
<span class="line-removed"> 611           return -1;</span>
<span class="line-removed"> 612         }</span>
<span class="line-removed"> 613 </span>
<span class="line-removed"> 614       if (tmp_len &gt; buf_size - 1)</span>
<span class="line-removed"> 615         tmp_len = buf_size - 1;</span>
<span class="line-removed"> 616 </span>
<span class="line-removed"> 617       memcpy (buf, tmp, tmp_len);</span>
<span class="line-removed"> 618       /* readlink() doesn&#39;t NUL-terminate, but we do.</span>
<span class="line-removed"> 619        * To be compliant, however, we return the</span>
<span class="line-removed"> 620        * number of bytes without the NUL-terminator.</span>
<span class="line-removed"> 621        */</span>
<span class="line-removed"> 622       buf[tmp_len] = &#39;\0&#39;;</span>
<span class="line-removed"> 623       result = tmp_len;</span>
<span class="line-removed"> 624       g_free (tmp);</span>
 625     }
 626 
<a name="57" id="anc57"></a><span class="line-modified"> 627   return result;</span>






 628 }
 629 
 630 #endif
 631 
 632 /**
 633  * g_access:
 634  * @filename: (type filename): a pathname in the GLib file name encoding
 635  *     (UTF-8 on Windows)
 636  * @mode: as in access()
 637  *
 638  * A wrapper for the POSIX access() function. This function is used to
 639  * test a pathname for one or several of read, write or execute
 640  * permissions, or just existence.
 641  *
 642  * On Windows, the file protection mechanism is not at all POSIX-like,
 643  * and the underlying function in the C library only checks the
 644  * FAT-style READONLY attribute, and does not look at the ACL of a
 645  * file at all. This function is this in practise almost useless on
 646  * Windows. Software that needs to handle file permissions on Windows
 647  * more exactly should use the Win32 API.
 648  *
 649  * See your C library manual for more details about access().
 650  *
 651  * Returns: zero if the pathname refers to an existing file system
 652  *     object that has all the tested permissions, or -1 otherwise
 653  *     or on error.
 654  *
 655  * Since: 2.8
 656  */
 657 int
 658 g_access (const gchar *filename,
<a name="58" id="anc58"></a><span class="line-modified"> 659       int          mode)</span>
 660 {
 661 #ifdef G_OS_WIN32
 662   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 663   int retval;
 664   int save_errno;
 665 
 666   if (wfilename == NULL)
 667     {
 668       errno = EINVAL;
 669       return -1;
 670     }
 671 
 672 #ifndef X_OK
 673 #define X_OK 1
 674 #endif
 675 
 676   retval = _waccess (wfilename, mode &amp; ~X_OK);
 677   save_errno = errno;
 678 
 679   g_free (wfilename);
 680 
 681   errno = save_errno;
 682   return retval;
 683 #else
 684   return access (filename, mode);
 685 #endif
 686 }
 687 
 688 /**
 689  * g_chmod:
 690  * @filename: (type filename): a pathname in the GLib file name encoding
 691  *     (UTF-8 on Windows)
 692  * @mode: as in chmod()
 693  *
 694  * A wrapper for the POSIX chmod() function. The chmod() function is
 695  * used to set the permissions of a file system object.
 696  *
 697  * On Windows the file protection mechanism is not at all POSIX-like,
 698  * and the underlying chmod() function in the C library just sets or
 699  * clears the FAT-style READONLY attribute. It does not touch any
 700  * ACL. Software that needs to manage file permissions on Windows
 701  * exactly should use the Win32 API.
 702  *
 703  * See your C library manual for more details about chmod().
 704  *
 705  * Returns: 0 if the operation succeeded, -1 on error
 706  *
 707  * Since: 2.8
 708  */
 709 int
 710 g_chmod (const gchar *filename,
<a name="59" id="anc59"></a><span class="line-modified"> 711      int          mode)</span>
 712 {
 713 #ifdef G_OS_WIN32
 714   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 715   int retval;
 716   int save_errno;
 717 
 718   if (wfilename == NULL)
 719     {
 720       errno = EINVAL;
 721       return -1;
 722     }
 723 
 724   retval = _wchmod (wfilename, mode);
 725   save_errno = errno;
 726 
 727   g_free (wfilename);
 728 
 729   errno = save_errno;
 730   return retval;
 731 #else
 732   return chmod (filename, mode);
 733 #endif
 734 }
 735 /**
 736  * g_open:
 737  * @filename: (type filename): a pathname in the GLib file name encoding
 738  *     (UTF-8 on Windows)
 739  * @flags: as in open()
 740  * @mode: as in open()
 741  *
 742  * A wrapper for the POSIX open() function. The open() function is
 743  * used to convert a pathname into a file descriptor.
 744  *
 745  * On POSIX systems file descriptors are implemented by the operating
 746  * system. On Windows, it&#39;s the C library that implements open() and
 747  * file descriptors. The actual Win32 API for opening files is quite
 748  * different, see MSDN documentation for CreateFile(). The Win32 API
 749  * uses file handles, which are more randomish integers, not small
 750  * integers like file descriptors.
 751  *
 752  * Because file descriptors are specific to the C library on Windows,
 753  * the file descriptor returned by this function makes sense only to
 754  * functions in the same C library. Thus if the GLib-using code uses a
 755  * different C library than GLib does, the file descriptor returned by
 756  * this function cannot be passed to C library functions like write()
 757  * or read().
 758  *
 759  * See your C library manual for more details about open().
 760  *
 761  * Returns: a new file descriptor, or -1 if an error occurred.
 762  *     The return value can be used exactly like the return value
 763  *     from open().
 764  *
 765  * Since: 2.6
 766  */
 767 int
 768 g_open (const gchar *filename,
<a name="60" id="anc60"></a><span class="line-modified"> 769     int          flags,</span>
<span class="line-modified"> 770     int          mode)</span>
 771 {
 772 #ifdef G_OS_WIN32
 773   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 774   int retval;
 775   int save_errno;
 776 
 777   if (wfilename == NULL)
 778     {
 779       errno = EINVAL;
 780       return -1;
 781     }
 782 
 783   retval = _wopen (wfilename, flags, mode);
 784   save_errno = errno;
 785 
 786   g_free (wfilename);
 787 
 788   errno = save_errno;
 789   return retval;
 790 #else
 791   int fd;
 792   do
 793     fd = open (filename, flags, mode);
 794   while (G_UNLIKELY (fd == -1 &amp;&amp; errno == EINTR));
 795   return fd;
 796 #endif
 797 }
 798 
 799 /**
 800  * g_creat:
 801  * @filename: (type filename): a pathname in the GLib file name encoding
 802  *     (UTF-8 on Windows)
 803  * @mode: as in creat()
 804  *
 805  * A wrapper for the POSIX creat() function. The creat() function is
 806  * used to convert a pathname into a file descriptor, creating a file
 807  * if necessary.
 808  *
 809  * On POSIX systems file descriptors are implemented by the operating
 810  * system. On Windows, it&#39;s the C library that implements creat() and
 811  * file descriptors. The actual Windows API for opening files is
 812  * different, see MSDN documentation for CreateFile(). The Win32 API
 813  * uses file handles, which are more randomish integers, not small
 814  * integers like file descriptors.
 815  *
 816  * Because file descriptors are specific to the C library on Windows,
 817  * the file descriptor returned by this function makes sense only to
 818  * functions in the same C library. Thus if the GLib-using code uses a
 819  * different C library than GLib does, the file descriptor returned by
 820  * this function cannot be passed to C library functions like write()
 821  * or read().
 822  *
 823  * See your C library manual for more details about creat().
 824  *
 825  * Returns: a new file descriptor, or -1 if an error occurred.
 826  *     The return value can be used exactly like the return value
 827  *     from creat().
 828  *
 829  * Since: 2.8
 830  */
 831 int
 832 g_creat (const gchar *filename,
<a name="61" id="anc61"></a><span class="line-modified"> 833      int          mode)</span>
 834 {
 835 #ifdef G_OS_WIN32
 836   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 837   int retval;
 838   int save_errno;
 839 
 840   if (wfilename == NULL)
 841     {
 842       errno = EINVAL;
 843       return -1;
 844     }
 845 
 846   retval = _wcreat (wfilename, mode);
 847   save_errno = errno;
 848 
 849   g_free (wfilename);
 850 
 851   errno = save_errno;
 852   return retval;
 853 #else
 854   return creat (filename, mode);
 855 #endif
 856 }
 857 
 858 /**
 859  * g_rename:
 860  * @oldfilename: (type filename): a pathname in the GLib file name encoding
 861  *     (UTF-8 on Windows)
 862  * @newfilename: (type filename): a pathname in the GLib file name encoding
 863  *
 864  * A wrapper for the POSIX rename() function. The rename() function
 865  * renames a file, moving it between directories if required.
 866  *
 867  * See your C library manual for more details about how rename() works
 868  * on your system. It is not possible in general on Windows to rename
 869  * a file that is open to some process.
 870  *
 871  * Returns: 0 if the renaming succeeded, -1 if an error occurred
 872  *
 873  * Since: 2.6
 874  */
 875 int
 876 g_rename (const gchar *oldfilename,
<a name="62" id="anc62"></a><span class="line-modified"> 877       const gchar *newfilename)</span>
 878 {
 879 #ifdef G_OS_WIN32
 880   wchar_t *woldfilename = g_utf8_to_utf16 (oldfilename, -1, NULL, NULL, NULL);
 881   wchar_t *wnewfilename;
 882   int retval;
 883   int save_errno = 0;
 884 
 885   if (woldfilename == NULL)
 886     {
 887       errno = EINVAL;
 888       return -1;
 889     }
 890 
 891   wnewfilename = g_utf8_to_utf16 (newfilename, -1, NULL, NULL, NULL);
 892 
 893   if (wnewfilename == NULL)
 894     {
 895       g_free (woldfilename);
 896       errno = EINVAL;
 897       return -1;
 898     }
 899 
 900   if (MoveFileExW (woldfilename, wnewfilename, MOVEFILE_REPLACE_EXISTING))
 901     retval = 0;
 902   else
 903     {
 904       retval = -1;
<a name="63" id="anc63"></a><span class="line-modified"> 905       switch (GetLastError ())</span>
<span class="line-removed"> 906     {</span>
<span class="line-removed"> 907 #define CASE(a,b) case ERROR_##a: save_errno = b; break</span>
<span class="line-removed"> 908       CASE (FILE_NOT_FOUND, ENOENT);</span>
<span class="line-removed"> 909       CASE (PATH_NOT_FOUND, ENOENT);</span>
<span class="line-removed"> 910       CASE (ACCESS_DENIED, EACCES);</span>
<span class="line-removed"> 911       CASE (NOT_SAME_DEVICE, EXDEV);</span>
<span class="line-removed"> 912       CASE (LOCK_VIOLATION, EACCES);</span>
<span class="line-removed"> 913       CASE (SHARING_VIOLATION, EACCES);</span>
<span class="line-removed"> 914       CASE (FILE_EXISTS, EEXIST);</span>
<span class="line-removed"> 915       CASE (ALREADY_EXISTS, EEXIST);</span>
<span class="line-removed"> 916 #undef CASE</span>
<span class="line-removed"> 917     default: save_errno = EIO;</span>
<span class="line-removed"> 918     }</span>
 919     }
 920 
 921   g_free (woldfilename);
 922   g_free (wnewfilename);
 923 
 924   errno = save_errno;
 925   return retval;
 926 #else
 927   return rename (oldfilename, newfilename);
 928 #endif
 929 }
 930 
 931 /**
 932  * g_mkdir:
 933  * @filename: (type filename): a pathname in the GLib file name encoding
 934  *     (UTF-8 on Windows)
 935  * @mode: permissions to use for the newly created directory
 936  *
 937  * A wrapper for the POSIX mkdir() function. The mkdir() function
 938  * attempts to create a directory with the given name and permissions.
 939  * The mode argument is ignored on Windows.
 940  *
 941  * See your C library manual for more details about mkdir().
 942  *
 943  * Returns: 0 if the directory was successfully created, -1 if an error
 944  *    occurred
 945  *
 946  * Since: 2.6
 947  */
 948 int
 949 g_mkdir (const gchar *filename,
<a name="64" id="anc64"></a><span class="line-modified"> 950      int          mode)</span>
 951 {
 952 #ifdef G_OS_WIN32
 953   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 954   int retval;
 955   int save_errno;
 956 
 957   if (wfilename == NULL)
 958     {
 959       errno = EINVAL;
 960       return -1;
 961     }
 962 
 963   retval = _wmkdir (wfilename);
 964   save_errno = errno;
 965 
 966   g_free (wfilename);
 967 
 968   errno = save_errno;
 969   return retval;
 970 #else
 971   return mkdir (filename, mode);
 972 #endif
 973 }
 974 
 975 /**
 976  * g_chdir:
 977  * @path: (type filename): a pathname in the GLib file name encoding
 978  *     (UTF-8 on Windows)
 979  *
 980  * A wrapper for the POSIX chdir() function. The function changes the
 981  * current directory of the process to @path.
 982  *
 983  * See your C library manual for more details about chdir().
 984  *
 985  * Returns: 0 on success, -1 if an error occurred.
 986  *
 987  * Since: 2.8
 988  */
 989 int
 990 g_chdir (const gchar *path)
 991 {
 992 #ifdef G_OS_WIN32
 993   wchar_t *wpath = g_utf8_to_utf16 (path, -1, NULL, NULL, NULL);
 994   int retval;
 995   int save_errno;
 996 
 997   if (wpath == NULL)
 998     {
 999       errno = EINVAL;
1000       return -1;
1001     }
1002 
1003   retval = _wchdir (wpath);
1004   save_errno = errno;
1005 
1006   g_free (wpath);
1007 
1008   errno = save_errno;
1009   return retval;
1010 #else
1011   return chdir (path);
1012 #endif
1013 }
1014 
1015 /**
1016  * GStatBuf:
1017  *
1018  * A type corresponding to the appropriate struct type for the stat()
1019  * system call, depending on the platform and/or compiler being used.
1020  *
1021  * See g_stat() for more information.
1022  */
1023 /**
1024  * g_stat:
1025  * @filename: (type filename): a pathname in the GLib file name encoding
1026  *     (UTF-8 on Windows)
1027  * @buf: a pointer to a stat struct, which will be filled with the file
1028  *     information
1029  *
1030  * A wrapper for the POSIX stat() function. The stat() function
1031  * returns information about a file. On Windows the stat() function in
1032  * the C library checks only the FAT-style READONLY attribute and does
1033  * not look at the ACL at all. Thus on Windows the protection bits in
1034  * the @st_mode field are a fabrication of little use.
1035  *
1036  * On Windows the Microsoft C libraries have several variants of the
1037  * stat struct and stat() function with names like _stat(), _stat32(),
1038  * _stat32i64() and _stat64i32(). The one used here is for 32-bit code
1039  * the one with 32-bit size and time fields, specifically called _stat32().
1040  *
1041  * In Microsoft&#39;s compiler, by default struct stat means one with
1042  * 64-bit time fields while in MinGW struct stat is the legacy one
1043  * with 32-bit fields. To hopefully clear up this messs, the gstdio.h
1044  * header defines a type #GStatBuf which is the appropriate struct type
1045  * depending on the platform and/or compiler being used. On POSIX it
1046  * is just struct stat, but note that even on POSIX platforms, stat()
1047  * might be a macro.
1048  *
1049  * See your C library manual for more details about stat().
1050  *
1051  * Returns: 0 if the information was successfully retrieved,
1052  *     -1 if an error occurred
1053  *
1054  * Since: 2.6
1055  */
1056 int
1057 g_stat (const gchar *filename,
<a name="65" id="anc65"></a><span class="line-modified">1058     GStatBuf    *buf)</span>
1059 {
1060 #ifdef G_OS_WIN32
1061   GWin32PrivateStat w32_buf;
1062   int retval = g_win32_stat_utf8 (filename, &amp;w32_buf);
1063 
1064   buf-&gt;st_dev = w32_buf.st_dev;
1065   buf-&gt;st_ino = w32_buf.st_ino;
1066   buf-&gt;st_mode = w32_buf.st_mode;
1067   buf-&gt;st_nlink = w32_buf.st_nlink;
1068   buf-&gt;st_uid = w32_buf.st_uid;
1069   buf-&gt;st_gid = w32_buf.st_gid;
1070   buf-&gt;st_rdev = w32_buf.st_dev;
1071   buf-&gt;st_size = w32_buf.st_size;
1072   buf-&gt;st_atime = w32_buf.st_atime;
1073   buf-&gt;st_mtime = w32_buf.st_mtime;
1074   buf-&gt;st_ctime = w32_buf.st_ctime;
1075 
1076   return retval;
1077 #else
1078   return stat (filename, buf);
1079 #endif
1080 }
1081 
1082 /**
1083  * g_lstat:
1084  * @filename: (type filename): a pathname in the GLib file name encoding
1085  *     (UTF-8 on Windows)
1086  * @buf: a pointer to a stat struct, which will be filled with the file
1087  *     information
1088  *
1089  * A wrapper for the POSIX lstat() function. The lstat() function is
1090  * like stat() except that in the case of symbolic links, it returns
1091  * information about the symbolic link itself and not the file that it
1092  * refers to. If the system does not support symbolic links g_lstat()
1093  * is identical to g_stat().
1094  *
1095  * See your C library manual for more details about lstat().
1096  *
1097  * Returns: 0 if the information was successfully retrieved,
1098  *     -1 if an error occurred
1099  *
1100  * Since: 2.6
1101  */
1102 int
1103 g_lstat (const gchar *filename,
<a name="66" id="anc66"></a><span class="line-modified">1104      GStatBuf    *buf)</span>
1105 {
1106 #ifdef HAVE_LSTAT
1107   /* This can&#39;t be Win32, so don&#39;t do the widechar dance. */
1108   return lstat (filename, buf);
1109 #elif defined (G_OS_WIN32)
1110   GWin32PrivateStat w32_buf;
1111   int retval = g_win32_lstat_utf8 (filename, &amp;w32_buf);
1112 
1113   buf-&gt;st_dev = w32_buf.st_dev;
1114   buf-&gt;st_ino = w32_buf.st_ino;
1115   buf-&gt;st_mode = w32_buf.st_mode;
1116   buf-&gt;st_nlink = w32_buf.st_nlink;
1117   buf-&gt;st_uid = w32_buf.st_uid;
1118   buf-&gt;st_gid = w32_buf.st_gid;
1119   buf-&gt;st_rdev = w32_buf.st_dev;
1120   buf-&gt;st_size = w32_buf.st_size;
1121   buf-&gt;st_atime = w32_buf.st_atime;
1122   buf-&gt;st_mtime = w32_buf.st_mtime;
1123   buf-&gt;st_ctime = w32_buf.st_ctime;
1124 
1125   return retval;
1126 #else
1127   return g_stat (filename, buf);
1128 #endif
1129 }
1130 
1131 /**
1132  * g_unlink:
1133  * @filename: (type filename): a pathname in the GLib file name encoding
1134  *     (UTF-8 on Windows)
1135  *
1136  * A wrapper for the POSIX unlink() function. The unlink() function
1137  * deletes a name from the filesystem. If this was the last link to the
1138  * file and no processes have it opened, the diskspace occupied by the
1139  * file is freed.
1140  *
1141  * See your C library manual for more details about unlink(). Note
1142  * that on Windows, it is in general not possible to delete files that
1143  * are open to some process, or mapped into memory.
1144  *
1145  * Returns: 0 if the name was successfully deleted, -1 if an error
1146  *    occurred
1147  *
1148  * Since: 2.6
1149  */
1150 int
1151 g_unlink (const gchar *filename)
1152 {
1153 #ifdef G_OS_WIN32
1154   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1155   int retval;
1156   int save_errno;
1157 
1158   if (wfilename == NULL)
1159     {
1160       errno = EINVAL;
1161       return -1;
1162     }
1163 
1164   retval = _wunlink (wfilename);
1165   save_errno = errno;
1166 
1167   g_free (wfilename);
1168 
1169   errno = save_errno;
1170   return retval;
1171 #else
1172   return unlink (filename);
1173 #endif
1174 }
1175 
1176 /**
1177  * g_remove:
1178  * @filename: (type filename): a pathname in the GLib file name encoding
1179  *     (UTF-8 on Windows)
1180  *
1181  * A wrapper for the POSIX remove() function. The remove() function
1182  * deletes a name from the filesystem.
1183  *
1184  * See your C library manual for more details about how remove() works
1185  * on your system. On Unix, remove() removes also directories, as it
1186  * calls unlink() for files and rmdir() for directories. On Windows,
1187  * although remove() in the C library only works for files, this
1188  * function tries first remove() and then if that fails rmdir(), and
1189  * thus works for both files and directories. Note however, that on
1190  * Windows, it is in general not possible to remove a file that is
1191  * open to some process, or mapped into memory.
1192  *
1193  * If this function fails on Windows you can&#39;t infer too much from the
1194  * errno value. rmdir() is tried regardless of what caused remove() to
1195  * fail. Any errno value set by remove() will be overwritten by that
1196  * set by rmdir().
1197  *
1198  * Returns: 0 if the file was successfully removed, -1 if an error
1199  *    occurred
1200  *
1201  * Since: 2.6
1202  */
1203 int
1204 g_remove (const gchar *filename)
1205 {
1206 #ifdef G_OS_WIN32
1207   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1208   int retval;
1209   int save_errno;
1210 
1211   if (wfilename == NULL)
1212     {
1213       errno = EINVAL;
1214       return -1;
1215     }
1216 
1217   retval = _wremove (wfilename);
1218   if (retval == -1)
1219     retval = _wrmdir (wfilename);
1220   save_errno = errno;
1221 
1222   g_free (wfilename);
1223 
1224   errno = save_errno;
1225   return retval;
1226 #else
1227   return remove (filename);
1228 #endif
1229 }
1230 
1231 /**
1232  * g_rmdir:
1233  * @filename: (type filename): a pathname in the GLib file name encoding
1234  *     (UTF-8 on Windows)
1235  *
1236  * A wrapper for the POSIX rmdir() function. The rmdir() function
1237  * deletes a directory from the filesystem.
1238  *
1239  * See your C library manual for more details about how rmdir() works
1240  * on your system.
1241  *
1242  * Returns: 0 if the directory was successfully removed, -1 if an error
1243  *    occurred
1244  *
1245  * Since: 2.6
1246  */
1247 int
1248 g_rmdir (const gchar *filename)
1249 {
1250 #ifdef G_OS_WIN32
1251   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1252   int retval;
1253   int save_errno;
1254 
1255   if (wfilename == NULL)
1256     {
1257       errno = EINVAL;
1258       return -1;
1259     }
1260 
1261   retval = _wrmdir (wfilename);
1262   save_errno = errno;
1263 
1264   g_free (wfilename);
1265 
1266   errno = save_errno;
1267   return retval;
1268 #else
1269   return rmdir (filename);
1270 #endif
1271 }
1272 
1273 /**
1274  * g_fopen:
1275  * @filename: (type filename): a pathname in the GLib file name encoding
1276  *     (UTF-8 on Windows)
1277  * @mode: a string describing the mode in which the file should be opened
1278  *
1279  * A wrapper for the stdio fopen() function. The fopen() function
1280  * opens a file and associates a new stream with it.
1281  *
1282  * Because file descriptors are specific to the C library on Windows,
1283  * and a file descriptor is part of the FILE struct, the FILE* returned
1284  * by this function makes sense only to functions in the same C library.
1285  * Thus if the GLib-using code uses a different C library than GLib does,
1286  * the FILE* returned by this function cannot be passed to C library
1287  * functions like fprintf() or fread().
1288  *
1289  * See your C library manual for more details about fopen().
1290  *
1291  * Returns: A FILE* if the file was successfully opened, or %NULL if
1292  *     an error occurred
1293  *
1294  * Since: 2.6
1295  */
1296 FILE *
1297 g_fopen (const gchar *filename,
<a name="67" id="anc67"></a><span class="line-modified">1298      const gchar *mode)</span>
1299 {
1300 #ifdef G_OS_WIN32
1301   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1302   wchar_t *wmode;
<a name="68" id="anc68"></a><span class="line-removed">1303   gchar   *mode2;</span>
1304   FILE *retval;
1305   int save_errno;
1306 
1307   if (wfilename == NULL)
1308     {
1309       errno = EINVAL;
1310       return NULL;
1311     }
1312 
<a name="69" id="anc69"></a><span class="line-modified">1313   mode2 = _g_win32_get_mode_alias (mode);</span>
<span class="line-removed">1314   wmode = g_utf8_to_utf16 (mode2, -1, NULL, NULL, NULL);</span>
<span class="line-removed">1315   g_free (mode2);</span>
1316 
1317   if (wmode == NULL)
1318     {
1319       g_free (wfilename);
1320       errno = EINVAL;
1321       return NULL;
1322     }
1323 
<a name="70" id="anc70"></a>
1324   retval = _wfopen (wfilename, wmode);
1325   save_errno = errno;
1326 
1327   g_free (wfilename);
1328   g_free (wmode);
1329 
1330   errno = save_errno;
1331   return retval;
1332 #else
1333   return fopen (filename, mode);
1334 #endif
1335 }
1336 
1337 /**
1338  * g_freopen:
1339  * @filename: (type filename): a pathname in the GLib file name encoding
1340  *     (UTF-8 on Windows)
1341  * @mode: a string describing the mode in which the file should be  opened
1342  * @stream: (nullable): an existing stream which will be reused, or %NULL
1343  *
1344  * A wrapper for the POSIX freopen() function. The freopen() function
1345  * opens a file and associates it with an existing stream.
1346  *
1347  * See your C library manual for more details about freopen().
1348  *
1349  * Returns: A FILE* if the file was successfully opened, or %NULL if
1350  *     an error occurred.
1351  *
1352  * Since: 2.6
1353  */
1354 FILE *
1355 g_freopen (const gchar *filename,
<a name="71" id="anc71"></a><span class="line-modified">1356        const gchar *mode,</span>
<span class="line-modified">1357        FILE        *stream)</span>
1358 {
1359 #ifdef G_OS_WIN32
1360   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1361   wchar_t *wmode;
<a name="72" id="anc72"></a><span class="line-removed">1362   gchar   *mode2;</span>
1363   FILE *retval;
1364   int save_errno;
1365 
1366   if (wfilename == NULL)
1367     {
1368       errno = EINVAL;
1369       return NULL;
1370     }
1371 
<a name="73" id="anc73"></a><span class="line-modified">1372   mode2 = _g_win32_get_mode_alias (mode);</span>
<span class="line-removed">1373   wmode = g_utf8_to_utf16 (mode2, -1, NULL, NULL, NULL);</span>
<span class="line-removed">1374   g_free (mode2);</span>
1375 
1376   if (wmode == NULL)
1377     {
1378       g_free (wfilename);
1379       errno = EINVAL;
1380       return NULL;
1381     }
1382 
<a name="74" id="anc74"></a>
1383   retval = _wfreopen (wfilename, wmode, stream);
1384   save_errno = errno;
1385 
1386   g_free (wfilename);
1387   g_free (wmode);
1388 
1389   errno = save_errno;
1390   return retval;
1391 #else
1392   return freopen (filename, mode, stream);
1393 #endif
1394 }
1395 
1396 /**
1397  * g_utime:
1398  * @filename: (type filename): a pathname in the GLib file name encoding
1399  *     (UTF-8 on Windows)
1400  * @utb: a pointer to a struct utimbuf.
1401  *
1402  * A wrapper for the POSIX utime() function. The utime() function
1403  * sets the access and modification timestamps of a file.
1404  *
1405  * See your C library manual for more details about how utime() works
1406  * on your system.
1407  *
1408  * Returns: 0 if the operation was successful, -1 if an error occurred
1409  *
1410  * Since: 2.18
1411  */
1412 int
1413 g_utime (const gchar    *filename,
<a name="75" id="anc75"></a><span class="line-modified">1414      struct utimbuf *utb)</span>
1415 {
1416 #ifdef G_OS_WIN32
1417   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1418   int retval;
1419   int save_errno;
1420 
1421   if (wfilename == NULL)
1422     {
1423       errno = EINVAL;
1424       return -1;
1425     }
1426 
1427   retval = _wutime (wfilename, (struct _utimbuf*) utb);
1428   save_errno = errno;
1429 
1430   g_free (wfilename);
1431 
1432   errno = save_errno;
1433   return retval;
1434 #else
1435   return utime (filename, utb);
1436 #endif
1437 }
1438 
1439 /**
1440  * g_close:
1441  * @fd: A file descriptor
1442  * @error: a #GError
1443  *
1444  * This wraps the close() call; in case of error, %errno will be
1445  * preserved, but the error will also be stored as a #GError in @error.
1446  *
1447  * Besides using #GError, there is another major reason to prefer this
1448  * function over the call provided by the system; on Unix, it will
1449  * attempt to correctly handle %EINTR, which has platform-specific
1450  * semantics.
1451  *
1452  * Returns: %TRUE on success, %FALSE if there was an error.
1453  *
1454  * Since: 2.36
1455  */
1456 gboolean
1457 g_close (gint       fd,
1458          GError   **error)
1459 {
1460   int res;
1461   res = close (fd);
1462   /* Just ignore EINTR for now; a retry loop is the wrong thing to do
1463    * on Linux at least.  Anyone who wants to add a conditional check
1464    * for e.g. HP-UX is welcome to do so later...
1465    *
1466    * http://lkml.indiana.edu/hypermail/linux/kernel/0509.1/0877.html
1467    * https://bugzilla.gnome.org/show_bug.cgi?id=682819
1468    * http://utcc.utoronto.ca/~cks/space/blog/unix/CloseEINTR
1469    * https://sites.google.com/site/michaelsafyan/software-engineering/checkforeintrwheninvokingclosethinkagain
1470    */
1471   if (G_UNLIKELY (res == -1 &amp;&amp; errno == EINTR))
1472     return TRUE;
1473   else if (res == -1)
1474     {
1475       int errsv = errno;
1476       g_set_error_literal (error, G_FILE_ERROR,
1477                            g_file_error_from_errno (errsv),
1478                            g_strerror (errsv));
1479       errno = errsv;
1480       return FALSE;
1481     }
1482   return TRUE;
1483 }
1484 
<a name="76" id="anc76"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="76" type="hidden" />
</body>
</html>