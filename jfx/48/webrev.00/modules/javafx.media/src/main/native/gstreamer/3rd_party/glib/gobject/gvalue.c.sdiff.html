<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gvalue.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gtypeplugin.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gvalue.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gvalue.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 #include &quot;gvaluecollector.h&quot;
 28 #include &quot;gbsearcharray.h&quot;
 29 #include &quot;gtype-private.h&quot;
 30 
 31 
 32 /**
 33  * SECTION:generic_values
 34  * @short_description: A polymorphic type that can hold values of any
 35  *     other type
 36  * @see_also: The fundamental types which all support #GValue
 37  *     operations and thus can be used as a type initializer for
 38  *     g_value_init() are defined by a separate interface.  See the
 39  *     [standard values API][gobject-Standard-Parameter-and-Value-Types]
 40  *     for details
 41  * @title: Generic values
 42  *
 43  * The #GValue structure is basically a variable container that consists
 44  * of a type identifier and a specific value of that type.
 45  * The type identifier within a #GValue structure always determines the
 46  * type of the associated value.
<span class="line-modified"> 47  * To create a undefined #GValue structure, simply create a zero-filled</span>
 48  * #GValue structure. To initialize the #GValue, use the g_value_init()
 49  * function. A #GValue cannot be used until it is initialized.
 50  * The basic type operations (such as freeing and copying) are determined
 51  * by the #GTypeValueTable associated with the type ID stored in the #GValue.
 52  * Other #GValue operations (such as converting values between types) are
 53  * provided by this interface.
 54  *
 55  * The code in the example program below demonstrates #GValue&#39;s
 56  * features.
 57  *
 58  * |[&lt;!-- language=&quot;C&quot; --&gt;
 59  * #include &lt;glib-object.h&gt;
 60  *
 61  * static void
 62  * int2string (const GValue *src_value,
 63  *             GValue       *dest_value)
 64  * {
 65  *   if (g_value_get_int (src_value) == 42)
 66  *     g_value_set_static_string (dest_value, &quot;An important number&quot;);
 67  *   else
</pre>
<hr />
<pre>
104  *
105  *   // Attempt to transform it again using a custom transform function
106  *   g_value_register_transform_func (G_TYPE_INT, G_TYPE_STRING, int2string);
107  *   g_value_transform (&amp;a, &amp;b);
108  *   g_printf (&quot;%s\n&quot;, g_value_get_string (&amp;b));
109  *   return 0;
110  * }
111  * ]|
112  */
113 
114 
115 /* --- typedefs &amp; structures --- */
116 typedef struct {
117   GType src_type;
118   GType dest_type;
119   GValueTransform func;
120 } TransformEntry;
121 
122 
123 /* --- prototypes --- */
<span class="line-modified">124 static gint transform_entries_cmp   (gconstpointer bsearch_node1,</span>
<span class="line-modified">125                      gconstpointer bsearch_node2);</span>
126 
127 
128 /* --- variables --- */
129 static GBSearchArray *transform_array = NULL;
130 static GBSearchConfig transform_bconfig = {
131   sizeof (TransformEntry),
132   transform_entries_cmp,
133   G_BSEARCH_ARRAY_ALIGN_POWER2,
134 };
135 
136 
137 /* --- functions --- */
138 void
139 _g_value_c_init (void)
140 {
141   transform_array = g_bsearch_array_create (&amp;transform_bconfig);
142 }
143 
<span class="line-modified">144 static inline void      /* keep this function in sync with gvaluecollector.h and gboxed.c */</span>
145 value_meminit (GValue *value,
<span class="line-modified">146            GType   value_type)</span>
147 {
148   value-&gt;g_type = value_type;
149   memset (value-&gt;data, 0, sizeof (value-&gt;data));
150 }
151 
152 /**
153  * g_value_init:
154  * @value: A zero-filled (uninitialized) #GValue structure.
155  * @g_type: Type the #GValue should hold values of.
156  *
157  * Initializes @value with the default value of @type.
158  *
159  * Returns: (transfer none): the #GValue structure that has been passed in
160  */
161 GValue*
162 g_value_init (GValue *value,
<span class="line-modified">163           GType   g_type)</span>
164 {

165   /* g_return_val_if_fail (G_TYPE_IS_VALUE (g_type), NULL); be more elaborate below */
166   g_return_val_if_fail (value != NULL, NULL);
<span class="line-modified">167   /* g_return_val_if_fail (G_VALUE_TYPE (value) == 0, NULL);    be more elaborate below */</span>
168 
<span class="line-modified">169   if (G_TYPE_IS_VALUE (g_type) &amp;&amp; G_VALUE_TYPE (value) == 0)</span>
<span class="line-removed">170     {</span>
<span class="line-removed">171       GTypeValueTable *value_table = g_type_value_table_peek (g_type);</span>
172 


173       /* setup and init */
174       value_meminit (value, g_type);
175       value_table-&gt;value_init (value);
176     }
177   else if (G_VALUE_TYPE (value))
178     g_warning (&quot;%s: cannot initialize GValue with type &#39;%s&#39;, the value has already been initialized as &#39;%s&#39;&quot;,
<span class="line-modified">179            G_STRLOC,</span>
<span class="line-modified">180            g_type_name (g_type),</span>
<span class="line-modified">181            g_type_name (G_VALUE_TYPE (value)));</span>
182   else /* !G_TYPE_IS_VALUE (g_type) */
183     g_warning (&quot;%s: cannot initialize GValue with type &#39;%s&#39;, %s&quot;,
<span class="line-modified">184            G_STRLOC,</span>
<span class="line-modified">185            g_type_name (g_type),</span>
<span class="line-modified">186            g_type_value_table_peek (g_type) ?</span>
<span class="line-removed">187            &quot;this type is abstract with regards to GValue use, use a more specific (derived) type&quot; :</span>
<span class="line-removed">188            &quot;this type has no GTypeValueTable implementation&quot;);</span>
189   return value;
190 }
191 
192 /**
193  * g_value_copy:
194  * @src_value: An initialized #GValue structure.
195  * @dest_value: An initialized #GValue structure of the same type as @src_value.
196  *
197  * Copies the value of @src_value into @dest_value.
198  */
199 void
200 g_value_copy (const GValue *src_value,
<span class="line-modified">201           GValue       *dest_value)</span>
202 {
<span class="line-modified">203   g_return_if_fail (G_IS_VALUE (src_value));</span>
<span class="line-modified">204   g_return_if_fail (G_IS_VALUE (dest_value));</span>
205   g_return_if_fail (g_value_type_compatible (G_VALUE_TYPE (src_value), G_VALUE_TYPE (dest_value)));
206 
207   if (src_value != dest_value)
208     {
209       GType dest_type = G_VALUE_TYPE (dest_value);
210       GTypeValueTable *value_table = g_type_value_table_peek (dest_type);
211 


212       /* make sure dest_value&#39;s value is free()d */
213       if (value_table-&gt;value_free)
<span class="line-modified">214     value_table-&gt;value_free (dest_value);</span>
215 
216       /* setup and copy */
217       value_meminit (dest_value, dest_type);
218       value_table-&gt;value_copy (src_value, dest_value);
219     }
220 }
221 
222 /**
223  * g_value_reset:
224  * @value: An initialized #GValue structure.
225  *
226  * Clears the current value in @value and resets it to the default value
227  * (as if the value had just been initialized).
228  *
229  * Returns: the #GValue structure that has been passed in
230  */
231 GValue*
232 g_value_reset (GValue *value)
233 {
234   GTypeValueTable *value_table;
235   GType g_type;
236 
<span class="line-modified">237   g_return_val_if_fail (G_IS_VALUE (value), NULL);</span>
<span class="line-removed">238 </span>
239   g_type = G_VALUE_TYPE (value);

240   value_table = g_type_value_table_peek (g_type);

241 
242   /* make sure value&#39;s value is free()d */
243   if (value_table-&gt;value_free)
244     value_table-&gt;value_free (value);
245 
246   /* setup and init */
247   value_meminit (value, g_type);
248   value_table-&gt;value_init (value);
249 
250   return value;
251 }
252 
253 /**
254  * g_value_unset:
255  * @value: An initialized #GValue structure.
256  *
257  * Clears the current value in @value (if any) and &quot;unsets&quot; the type,
258  * this releases all resources associated with this GValue. An unset
259  * value is the same as an uninitialized (zero-filled) #GValue
260  * structure.
261  */
262 void
263 g_value_unset (GValue *value)
264 {
265   GTypeValueTable *value_table;
266 
267   if (value-&gt;g_type == 0)
268     return;
269 
<span class="line-modified">270   g_return_if_fail (G_IS_VALUE (value));</span>
271 
272   value_table = g_type_value_table_peek (G_VALUE_TYPE (value));

273 
274   if (value_table-&gt;value_free)
275     value_table-&gt;value_free (value);
276   memset (value, 0, sizeof (*value));
277 }
278 
279 /**
280  * g_value_fits_pointer:
281  * @value: An initialized #GValue structure.
282  *
283  * Determines if @value will fit inside the size of a pointer value.
284  * This is an internal function introduced mainly for C marshallers.
285  *
286  * Returns: %TRUE if @value will fit inside a pointer value.
287  */
288 gboolean
289 g_value_fits_pointer (const GValue *value)
290 {
291   GTypeValueTable *value_table;
292 
<span class="line-modified">293   g_return_val_if_fail (G_IS_VALUE (value), FALSE);</span>
294 
295   value_table = g_type_value_table_peek (G_VALUE_TYPE (value));

296 
297   return value_table-&gt;value_peek_pointer != NULL;
298 }
299 
300 /**
301  * g_value_peek_pointer:
302  * @value: An initialized #GValue structure
303  *
304  * Returns the value contents as pointer. This function asserts that
305  * g_value_fits_pointer() returned %TRUE for the passed in value.
306  * This is an internal function introduced mainly for C marshallers.
307  *
308  * Returns: (transfer none): the value contents as pointer
309  */
310 gpointer
311 g_value_peek_pointer (const GValue *value)
312 {
313   GTypeValueTable *value_table;
314 
<span class="line-modified">315   g_return_val_if_fail (G_IS_VALUE (value), NULL);</span>
316 
317   value_table = g_type_value_table_peek (G_VALUE_TYPE (value));


318   if (!value_table-&gt;value_peek_pointer)
319     {
320       g_return_val_if_fail (g_value_fits_pointer (value) == TRUE, NULL);
321       return NULL;
322     }
323 
324   return value_table-&gt;value_peek_pointer (value);
325 }
326 
327 /**
328  * g_value_set_instance:
329  * @value: An initialized #GValue structure.
330  * @instance: (nullable): the instance
331  *
332  * Sets @value from an instantiatable type via the
333  * value_table&#39;s collect_value() function.
334  */
335 void
336 g_value_set_instance (GValue  *value,
<span class="line-modified">337               gpointer instance)</span>
338 {
339   GType g_type;
340   GTypeValueTable *value_table;
341   GTypeCValue cvalue;
342   gchar *error_msg;
343 
<span class="line-modified">344   g_return_if_fail (G_IS_VALUE (value));</span>




345   if (instance)
346     {
347       g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
348       g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (instance), G_VALUE_TYPE (value)));
349     }
350 
<span class="line-removed">351   g_type = G_VALUE_TYPE (value);</span>
<span class="line-removed">352   value_table = g_type_value_table_peek (g_type);</span>
<span class="line-removed">353 </span>
354   g_return_if_fail (strcmp (value_table-&gt;collect_format, &quot;p&quot;) == 0);
355 
356   memset (&amp;cvalue, 0, sizeof (cvalue));
357   cvalue.v_pointer = instance;
358 
359   /* make sure value&#39;s value is free()d */
360   if (value_table-&gt;value_free)
361     value_table-&gt;value_free (value);
362 
363   /* setup and collect */
364   value_meminit (value, g_type);
365   error_msg = value_table-&gt;collect_value (value, 1, &amp;cvalue, 0);
366   if (error_msg)
367     {
368       g_warning (&quot;%s: %s&quot;, G_STRLOC, error_msg);
369       g_free (error_msg);
370 
371       /* we purposely leak the value here, it might not be
372        * in a sane state if an error condition occoured
373        */
</pre>
<hr />
<pre>
426       /* setup and collect */
427       value_meminit (value, g_type);
428       value_table-&gt;value_init (value);
429       error_msg = value_table-&gt;collect_value (value, 1, &amp;cvalue, 0);
430       if (error_msg)
431         {
432           g_warning (&quot;%s: %s&quot;, G_STRLOC, error_msg);
433           g_free (error_msg);
434 
435           /* we purposely leak the value here, it might not be
436            * in a sane state if an error condition occoured
437            */
438           value_meminit (value, g_type);
439           value_table-&gt;value_init (value);
440         }
441     }
442 }
443 
444 static GValueTransform
445 transform_func_lookup (GType src_type,
<span class="line-modified">446                GType dest_type)</span>
447 {
448   TransformEntry entry;
449 
450   entry.src_type = src_type;
451   do
452     {
453       entry.dest_type = dest_type;
454       do
<span class="line-modified">455     {</span>
<span class="line-modified">456       TransformEntry *e;</span>
<span class="line-modified">457 </span>
<span class="line-modified">458       e = g_bsearch_array_lookup (transform_array, &amp;transform_bconfig, &amp;entry);</span>
<span class="line-modified">459       if (e)</span>
<span class="line-modified">460         {</span>
<span class="line-modified">461           /* need to check that there hasn&#39;t been a change in value handling */</span>
<span class="line-modified">462           if (g_type_value_table_peek (entry.dest_type) == g_type_value_table_peek (dest_type) &amp;&amp;</span>
<span class="line-modified">463           g_type_value_table_peek (entry.src_type) == g_type_value_table_peek (src_type))</span>
<span class="line-modified">464         return e-&gt;func;</span>
<span class="line-modified">465         }</span>
<span class="line-modified">466       entry.dest_type = g_type_parent (entry.dest_type);</span>
<span class="line-modified">467     }</span>
468       while (entry.dest_type);
469 
470       entry.src_type = g_type_parent (entry.src_type);
471     }
472   while (entry.src_type);
473 
474   return NULL;
475 }
476 
477 static gint
478 transform_entries_cmp (gconstpointer bsearch_node1,
<span class="line-modified">479                gconstpointer bsearch_node2)</span>
480 {
481   const TransformEntry *e1 = bsearch_node1;
482   const TransformEntry *e2 = bsearch_node2;
483   gint cmp = G_BSEARCH_ARRAY_CMP (e1-&gt;src_type, e2-&gt;src_type);
484 
485   if (cmp)
486     return cmp;
487   else
488     return G_BSEARCH_ARRAY_CMP (e1-&gt;dest_type, e2-&gt;dest_type);
489 }
490 
491 /**
492  * g_value_register_transform_func: (skip)
493  * @src_type: Source type.
494  * @dest_type: Target type.
495  * @transform_func: a function which transforms values of type @src_type
496  *  into value of type @dest_type
497  *
498  * Registers a value transformation function for use in g_value_transform().
499  * A previously registered transformation function for @src_type and @dest_type
500  * will be replaced.
501  */
502 void
503 g_value_register_transform_func (GType           src_type,
<span class="line-modified">504                  GType           dest_type,</span>
<span class="line-modified">505                  GValueTransform transform_func)</span>
506 {
507   TransformEntry entry;
508 
509   /* these checks won&#39;t pass for dynamic types.
510    * g_return_if_fail (G_TYPE_HAS_VALUE_TABLE (src_type));
511    * g_return_if_fail (G_TYPE_HAS_VALUE_TABLE (dest_type));
512    */
513   g_return_if_fail (transform_func != NULL);
514 
515   entry.src_type = src_type;
516   entry.dest_type = dest_type;
517 
518 #if 0 /* let transform function replacement be a valid operation */
519   if (g_bsearch_array_lookup (transform_array, &amp;transform_bconfig, &amp;entry))
520     g_warning (&quot;reregistering value transformation function (%p) for &#39;%s&#39; to &#39;%s&#39;&quot;,
<span class="line-modified">521            transform_func,</span>
<span class="line-modified">522            g_type_name (src_type),</span>
<span class="line-modified">523            g_type_name (dest_type));</span>
524 #endif
525 
526   entry.func = transform_func;
527   transform_array = g_bsearch_array_replace (transform_array, &amp;transform_bconfig, &amp;entry);
528 }
529 
530 /**
531  * g_value_type_transformable:
532  * @src_type: Source type.
533  * @dest_type: Target type.
534  *
535  * Check whether g_value_transform() is able to transform values
536  * of type @src_type into values of type @dest_type. Note that for
537  * the types to be transformable, they must be compatible or a
538  * transformation function must be registered.
539  *
540  * Returns: %TRUE if the transformation is possible, %FALSE otherwise.
541  */
542 gboolean
543 g_value_type_transformable (GType src_type,
<span class="line-modified">544                 GType dest_type)</span>
545 {
<span class="line-modified">546   g_return_val_if_fail (G_TYPE_IS_VALUE (src_type), FALSE);</span>
<span class="line-modified">547   g_return_val_if_fail (G_TYPE_IS_VALUE (dest_type), FALSE);</span>
548 
549   return (g_value_type_compatible (src_type, dest_type) ||
<span class="line-modified">550       transform_func_lookup (src_type, dest_type) != NULL);</span>
551 }
552 
553 /**
554  * g_value_type_compatible:
555  * @src_type: source type to be copied.
556  * @dest_type: destination type for copying.
557  *
558  * Returns whether a #GValue of type @src_type can be copied into
559  * a #GValue of type @dest_type.
560  *
561  * Returns: %TRUE if g_value_copy() is possible with @src_type and @dest_type.
562  */
563 gboolean
564 g_value_type_compatible (GType src_type,
<span class="line-modified">565              GType dest_type)</span>
566 {
<span class="line-modified">567   g_return_val_if_fail (G_TYPE_IS_VALUE (src_type), FALSE);</span>
<span class="line-modified">568   g_return_val_if_fail (G_TYPE_IS_VALUE (dest_type), FALSE);</span>




569 
570   return (g_type_is_a (src_type, dest_type) &amp;&amp;
<span class="line-modified">571       g_type_value_table_peek (dest_type) == g_type_value_table_peek (src_type));</span>
572 }
573 
574 /**
575  * g_value_transform:
576  * @src_value: Source value.
577  * @dest_value: Target value.
578  *
579  * Tries to cast the contents of @src_value into a type appropriate
580  * to store in @dest_value, e.g. to transform a %G_TYPE_INT value
581  * into a %G_TYPE_FLOAT value. Performing transformations between
582  * value types might incur precision lossage. Especially
583  * transformations into strings might reveal seemingly arbitrary
584  * results and shouldn&#39;t be relied upon for production code (such
585  * as rcfile value or object property serialization).
586  *
587  * Returns: Whether a transformation rule was found and could be applied.
588  *  Upon failing transformations, @dest_value is left untouched.
589  */
590 gboolean
591 g_value_transform (const GValue *src_value,
<span class="line-modified">592            GValue       *dest_value)</span>
593 {
594   GType dest_type;
595 
<span class="line-modified">596   g_return_val_if_fail (G_IS_VALUE (src_value), FALSE);</span>
<span class="line-modified">597   g_return_val_if_fail (G_IS_VALUE (dest_value), FALSE);</span>
598 
599   dest_type = G_VALUE_TYPE (dest_value);
600   if (g_value_type_compatible (G_VALUE_TYPE (src_value), dest_type))
601     {
602       g_value_copy (src_value, dest_value);
603 
604       return TRUE;
605     }
606   else
607     {
608       GValueTransform transform = transform_func_lookup (G_VALUE_TYPE (src_value), dest_type);
609 
610       if (transform)
<span class="line-modified">611     {</span>
<span class="line-modified">612       g_value_unset (dest_value);</span>
613 
<span class="line-modified">614       /* setup and transform */</span>
<span class="line-modified">615       value_meminit (dest_value, dest_type);</span>
<span class="line-modified">616       transform (src_value, dest_value);</span>
617 
<span class="line-modified">618       return TRUE;</span>
<span class="line-modified">619     }</span>
620     }
621   return FALSE;
622 }
</pre>
</td>
<td>
<hr />
<pre>
 27 #include &quot;gvaluecollector.h&quot;
 28 #include &quot;gbsearcharray.h&quot;
 29 #include &quot;gtype-private.h&quot;
 30 
 31 
 32 /**
 33  * SECTION:generic_values
 34  * @short_description: A polymorphic type that can hold values of any
 35  *     other type
 36  * @see_also: The fundamental types which all support #GValue
 37  *     operations and thus can be used as a type initializer for
 38  *     g_value_init() are defined by a separate interface.  See the
 39  *     [standard values API][gobject-Standard-Parameter-and-Value-Types]
 40  *     for details
 41  * @title: Generic values
 42  *
 43  * The #GValue structure is basically a variable container that consists
 44  * of a type identifier and a specific value of that type.
 45  * The type identifier within a #GValue structure always determines the
 46  * type of the associated value.
<span class="line-modified"> 47  * To create an undefined #GValue structure, simply create a zero-filled</span>
 48  * #GValue structure. To initialize the #GValue, use the g_value_init()
 49  * function. A #GValue cannot be used until it is initialized.
 50  * The basic type operations (such as freeing and copying) are determined
 51  * by the #GTypeValueTable associated with the type ID stored in the #GValue.
 52  * Other #GValue operations (such as converting values between types) are
 53  * provided by this interface.
 54  *
 55  * The code in the example program below demonstrates #GValue&#39;s
 56  * features.
 57  *
 58  * |[&lt;!-- language=&quot;C&quot; --&gt;
 59  * #include &lt;glib-object.h&gt;
 60  *
 61  * static void
 62  * int2string (const GValue *src_value,
 63  *             GValue       *dest_value)
 64  * {
 65  *   if (g_value_get_int (src_value) == 42)
 66  *     g_value_set_static_string (dest_value, &quot;An important number&quot;);
 67  *   else
</pre>
<hr />
<pre>
104  *
105  *   // Attempt to transform it again using a custom transform function
106  *   g_value_register_transform_func (G_TYPE_INT, G_TYPE_STRING, int2string);
107  *   g_value_transform (&amp;a, &amp;b);
108  *   g_printf (&quot;%s\n&quot;, g_value_get_string (&amp;b));
109  *   return 0;
110  * }
111  * ]|
112  */
113 
114 
115 /* --- typedefs &amp; structures --- */
116 typedef struct {
117   GType src_type;
118   GType dest_type;
119   GValueTransform func;
120 } TransformEntry;
121 
122 
123 /* --- prototypes --- */
<span class="line-modified">124 static gint transform_entries_cmp (gconstpointer bsearch_node1,</span>
<span class="line-modified">125            gconstpointer bsearch_node2);</span>
126 
127 
128 /* --- variables --- */
129 static GBSearchArray *transform_array = NULL;
130 static GBSearchConfig transform_bconfig = {
131   sizeof (TransformEntry),
132   transform_entries_cmp,
133   G_BSEARCH_ARRAY_ALIGN_POWER2,
134 };
135 
136 
137 /* --- functions --- */
138 void
139 _g_value_c_init (void)
140 {
141   transform_array = g_bsearch_array_create (&amp;transform_bconfig);
142 }
143 
<span class="line-modified">144 static inline void    /* keep this function in sync with gvaluecollector.h and gboxed.c */</span>
145 value_meminit (GValue *value,
<span class="line-modified">146          GType   value_type)</span>
147 {
148   value-&gt;g_type = value_type;
149   memset (value-&gt;data, 0, sizeof (value-&gt;data));
150 }
151 
152 /**
153  * g_value_init:
154  * @value: A zero-filled (uninitialized) #GValue structure.
155  * @g_type: Type the #GValue should hold values of.
156  *
157  * Initializes @value with the default value of @type.
158  *
159  * Returns: (transfer none): the #GValue structure that has been passed in
160  */
161 GValue*
162 g_value_init (GValue *value,
<span class="line-modified">163         GType   g_type)</span>
164 {
<span class="line-added">165   GTypeValueTable *value_table;</span>
166   /* g_return_val_if_fail (G_TYPE_IS_VALUE (g_type), NULL); be more elaborate below */
167   g_return_val_if_fail (value != NULL, NULL);
<span class="line-modified">168   /* g_return_val_if_fail (G_VALUE_TYPE (value) == 0, NULL);  be more elaborate below */</span>
169 
<span class="line-modified">170   value_table = g_type_value_table_peek (g_type);</span>


171 
<span class="line-added">172   if (value_table &amp;&amp; G_VALUE_TYPE (value) == 0)</span>
<span class="line-added">173     {</span>
174       /* setup and init */
175       value_meminit (value, g_type);
176       value_table-&gt;value_init (value);
177     }
178   else if (G_VALUE_TYPE (value))
179     g_warning (&quot;%s: cannot initialize GValue with type &#39;%s&#39;, the value has already been initialized as &#39;%s&#39;&quot;,
<span class="line-modified">180          G_STRLOC,</span>
<span class="line-modified">181          g_type_name (g_type),</span>
<span class="line-modified">182          g_type_name (G_VALUE_TYPE (value)));</span>
183   else /* !G_TYPE_IS_VALUE (g_type) */
184     g_warning (&quot;%s: cannot initialize GValue with type &#39;%s&#39;, %s&quot;,
<span class="line-modified">185                G_STRLOC,</span>
<span class="line-modified">186                g_type_name (g_type),</span>
<span class="line-modified">187                value_table ? &quot;this type is abstract with regards to GValue use, use a more specific (derived) type&quot; : &quot;this type has no GTypeValueTable implementation&quot;);</span>


188   return value;
189 }
190 
191 /**
192  * g_value_copy:
193  * @src_value: An initialized #GValue structure.
194  * @dest_value: An initialized #GValue structure of the same type as @src_value.
195  *
196  * Copies the value of @src_value into @dest_value.
197  */
198 void
199 g_value_copy (const GValue *src_value,
<span class="line-modified">200         GValue       *dest_value)</span>
201 {
<span class="line-modified">202   g_return_if_fail (src_value);</span>
<span class="line-modified">203   g_return_if_fail (dest_value);</span>
204   g_return_if_fail (g_value_type_compatible (G_VALUE_TYPE (src_value), G_VALUE_TYPE (dest_value)));
205 
206   if (src_value != dest_value)
207     {
208       GType dest_type = G_VALUE_TYPE (dest_value);
209       GTypeValueTable *value_table = g_type_value_table_peek (dest_type);
210 
<span class="line-added">211       g_return_if_fail (value_table);</span>
<span class="line-added">212 </span>
213       /* make sure dest_value&#39;s value is free()d */
214       if (value_table-&gt;value_free)
<span class="line-modified">215   value_table-&gt;value_free (dest_value);</span>
216 
217       /* setup and copy */
218       value_meminit (dest_value, dest_type);
219       value_table-&gt;value_copy (src_value, dest_value);
220     }
221 }
222 
223 /**
224  * g_value_reset:
225  * @value: An initialized #GValue structure.
226  *
227  * Clears the current value in @value and resets it to the default value
228  * (as if the value had just been initialized).
229  *
230  * Returns: the #GValue structure that has been passed in
231  */
232 GValue*
233 g_value_reset (GValue *value)
234 {
235   GTypeValueTable *value_table;
236   GType g_type;
237 
<span class="line-modified">238   g_return_val_if_fail (value, NULL);</span>

239   g_type = G_VALUE_TYPE (value);
<span class="line-added">240 </span>
241   value_table = g_type_value_table_peek (g_type);
<span class="line-added">242   g_return_val_if_fail (value_table, NULL);</span>
243 
244   /* make sure value&#39;s value is free()d */
245   if (value_table-&gt;value_free)
246     value_table-&gt;value_free (value);
247 
248   /* setup and init */
249   value_meminit (value, g_type);
250   value_table-&gt;value_init (value);
251 
252   return value;
253 }
254 
255 /**
256  * g_value_unset:
257  * @value: An initialized #GValue structure.
258  *
259  * Clears the current value in @value (if any) and &quot;unsets&quot; the type,
260  * this releases all resources associated with this GValue. An unset
261  * value is the same as an uninitialized (zero-filled) #GValue
262  * structure.
263  */
264 void
265 g_value_unset (GValue *value)
266 {
267   GTypeValueTable *value_table;
268 
269   if (value-&gt;g_type == 0)
270     return;
271 
<span class="line-modified">272   g_return_if_fail (value);</span>
273 
274   value_table = g_type_value_table_peek (G_VALUE_TYPE (value));
<span class="line-added">275   g_return_if_fail (value_table);</span>
276 
277   if (value_table-&gt;value_free)
278     value_table-&gt;value_free (value);
279   memset (value, 0, sizeof (*value));
280 }
281 
282 /**
283  * g_value_fits_pointer:
284  * @value: An initialized #GValue structure.
285  *
286  * Determines if @value will fit inside the size of a pointer value.
287  * This is an internal function introduced mainly for C marshallers.
288  *
289  * Returns: %TRUE if @value will fit inside a pointer value.
290  */
291 gboolean
292 g_value_fits_pointer (const GValue *value)
293 {
294   GTypeValueTable *value_table;
295 
<span class="line-modified">296   g_return_val_if_fail (value, FALSE);</span>
297 
298   value_table = g_type_value_table_peek (G_VALUE_TYPE (value));
<span class="line-added">299   g_return_val_if_fail (value_table, FALSE);</span>
300 
301   return value_table-&gt;value_peek_pointer != NULL;
302 }
303 
304 /**
305  * g_value_peek_pointer:
306  * @value: An initialized #GValue structure
307  *
308  * Returns the value contents as pointer. This function asserts that
309  * g_value_fits_pointer() returned %TRUE for the passed in value.
310  * This is an internal function introduced mainly for C marshallers.
311  *
312  * Returns: (transfer none): the value contents as pointer
313  */
314 gpointer
315 g_value_peek_pointer (const GValue *value)
316 {
317   GTypeValueTable *value_table;
318 
<span class="line-modified">319   g_return_val_if_fail (value, NULL);</span>
320 
321   value_table = g_type_value_table_peek (G_VALUE_TYPE (value));
<span class="line-added">322   g_return_val_if_fail (value_table, NULL);</span>
<span class="line-added">323 </span>
324   if (!value_table-&gt;value_peek_pointer)
325     {
326       g_return_val_if_fail (g_value_fits_pointer (value) == TRUE, NULL);
327       return NULL;
328     }
329 
330   return value_table-&gt;value_peek_pointer (value);
331 }
332 
333 /**
334  * g_value_set_instance:
335  * @value: An initialized #GValue structure.
336  * @instance: (nullable): the instance
337  *
338  * Sets @value from an instantiatable type via the
339  * value_table&#39;s collect_value() function.
340  */
341 void
342 g_value_set_instance (GValue  *value,
<span class="line-modified">343           gpointer instance)</span>
344 {
345   GType g_type;
346   GTypeValueTable *value_table;
347   GTypeCValue cvalue;
348   gchar *error_msg;
349 
<span class="line-modified">350   g_return_if_fail (value);</span>
<span class="line-added">351   g_type = G_VALUE_TYPE (value);</span>
<span class="line-added">352   value_table = g_type_value_table_peek (g_type);</span>
<span class="line-added">353   g_return_if_fail (value_table);</span>
<span class="line-added">354 </span>
355   if (instance)
356     {
357       g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
358       g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (instance), G_VALUE_TYPE (value)));
359     }
360 



361   g_return_if_fail (strcmp (value_table-&gt;collect_format, &quot;p&quot;) == 0);
362 
363   memset (&amp;cvalue, 0, sizeof (cvalue));
364   cvalue.v_pointer = instance;
365 
366   /* make sure value&#39;s value is free()d */
367   if (value_table-&gt;value_free)
368     value_table-&gt;value_free (value);
369 
370   /* setup and collect */
371   value_meminit (value, g_type);
372   error_msg = value_table-&gt;collect_value (value, 1, &amp;cvalue, 0);
373   if (error_msg)
374     {
375       g_warning (&quot;%s: %s&quot;, G_STRLOC, error_msg);
376       g_free (error_msg);
377 
378       /* we purposely leak the value here, it might not be
379        * in a sane state if an error condition occoured
380        */
</pre>
<hr />
<pre>
433       /* setup and collect */
434       value_meminit (value, g_type);
435       value_table-&gt;value_init (value);
436       error_msg = value_table-&gt;collect_value (value, 1, &amp;cvalue, 0);
437       if (error_msg)
438         {
439           g_warning (&quot;%s: %s&quot;, G_STRLOC, error_msg);
440           g_free (error_msg);
441 
442           /* we purposely leak the value here, it might not be
443            * in a sane state if an error condition occoured
444            */
445           value_meminit (value, g_type);
446           value_table-&gt;value_init (value);
447         }
448     }
449 }
450 
451 static GValueTransform
452 transform_func_lookup (GType src_type,
<span class="line-modified">453            GType dest_type)</span>
454 {
455   TransformEntry entry;
456 
457   entry.src_type = src_type;
458   do
459     {
460       entry.dest_type = dest_type;
461       do
<span class="line-modified">462   {</span>
<span class="line-modified">463     TransformEntry *e;</span>
<span class="line-modified">464 </span>
<span class="line-modified">465     e = g_bsearch_array_lookup (transform_array, &amp;transform_bconfig, &amp;entry);</span>
<span class="line-modified">466     if (e)</span>
<span class="line-modified">467       {</span>
<span class="line-modified">468         /* need to check that there hasn&#39;t been a change in value handling */</span>
<span class="line-modified">469         if (g_type_value_table_peek (entry.dest_type) == g_type_value_table_peek (dest_type) &amp;&amp;</span>
<span class="line-modified">470       g_type_value_table_peek (entry.src_type) == g_type_value_table_peek (src_type))</span>
<span class="line-modified">471     return e-&gt;func;</span>
<span class="line-modified">472       }</span>
<span class="line-modified">473     entry.dest_type = g_type_parent (entry.dest_type);</span>
<span class="line-modified">474   }</span>
475       while (entry.dest_type);
476 
477       entry.src_type = g_type_parent (entry.src_type);
478     }
479   while (entry.src_type);
480 
481   return NULL;
482 }
483 
484 static gint
485 transform_entries_cmp (gconstpointer bsearch_node1,
<span class="line-modified">486            gconstpointer bsearch_node2)</span>
487 {
488   const TransformEntry *e1 = bsearch_node1;
489   const TransformEntry *e2 = bsearch_node2;
490   gint cmp = G_BSEARCH_ARRAY_CMP (e1-&gt;src_type, e2-&gt;src_type);
491 
492   if (cmp)
493     return cmp;
494   else
495     return G_BSEARCH_ARRAY_CMP (e1-&gt;dest_type, e2-&gt;dest_type);
496 }
497 
498 /**
499  * g_value_register_transform_func: (skip)
500  * @src_type: Source type.
501  * @dest_type: Target type.
502  * @transform_func: a function which transforms values of type @src_type
503  *  into value of type @dest_type
504  *
505  * Registers a value transformation function for use in g_value_transform().
506  * A previously registered transformation function for @src_type and @dest_type
507  * will be replaced.
508  */
509 void
510 g_value_register_transform_func (GType           src_type,
<span class="line-modified">511          GType           dest_type,</span>
<span class="line-modified">512          GValueTransform transform_func)</span>
513 {
514   TransformEntry entry;
515 
516   /* these checks won&#39;t pass for dynamic types.
517    * g_return_if_fail (G_TYPE_HAS_VALUE_TABLE (src_type));
518    * g_return_if_fail (G_TYPE_HAS_VALUE_TABLE (dest_type));
519    */
520   g_return_if_fail (transform_func != NULL);
521 
522   entry.src_type = src_type;
523   entry.dest_type = dest_type;
524 
525 #if 0 /* let transform function replacement be a valid operation */
526   if (g_bsearch_array_lookup (transform_array, &amp;transform_bconfig, &amp;entry))
527     g_warning (&quot;reregistering value transformation function (%p) for &#39;%s&#39; to &#39;%s&#39;&quot;,
<span class="line-modified">528          transform_func,</span>
<span class="line-modified">529          g_type_name (src_type),</span>
<span class="line-modified">530          g_type_name (dest_type));</span>
531 #endif
532 
533   entry.func = transform_func;
534   transform_array = g_bsearch_array_replace (transform_array, &amp;transform_bconfig, &amp;entry);
535 }
536 
537 /**
538  * g_value_type_transformable:
539  * @src_type: Source type.
540  * @dest_type: Target type.
541  *
542  * Check whether g_value_transform() is able to transform values
543  * of type @src_type into values of type @dest_type. Note that for
544  * the types to be transformable, they must be compatible or a
545  * transformation function must be registered.
546  *
547  * Returns: %TRUE if the transformation is possible, %FALSE otherwise.
548  */
549 gboolean
550 g_value_type_transformable (GType src_type,
<span class="line-modified">551           GType dest_type)</span>
552 {
<span class="line-modified">553   g_return_val_if_fail (src_type, FALSE);</span>
<span class="line-modified">554   g_return_val_if_fail (dest_type, FALSE);</span>
555 
556   return (g_value_type_compatible (src_type, dest_type) ||
<span class="line-modified">557     transform_func_lookup (src_type, dest_type) != NULL);</span>
558 }
559 
560 /**
561  * g_value_type_compatible:
562  * @src_type: source type to be copied.
563  * @dest_type: destination type for copying.
564  *
565  * Returns whether a #GValue of type @src_type can be copied into
566  * a #GValue of type @dest_type.
567  *
568  * Returns: %TRUE if g_value_copy() is possible with @src_type and @dest_type.
569  */
570 gboolean
571 g_value_type_compatible (GType src_type,
<span class="line-modified">572        GType dest_type)</span>
573 {
<span class="line-modified">574   g_return_val_if_fail (src_type, FALSE);</span>
<span class="line-modified">575   g_return_val_if_fail (dest_type, FALSE);</span>
<span class="line-added">576 </span>
<span class="line-added">577   /* Fast path */</span>
<span class="line-added">578   if (src_type == dest_type)</span>
<span class="line-added">579     return TRUE;</span>
580 
581   return (g_type_is_a (src_type, dest_type) &amp;&amp;
<span class="line-modified">582     g_type_value_table_peek (dest_type) == g_type_value_table_peek (src_type));</span>
583 }
584 
585 /**
586  * g_value_transform:
587  * @src_value: Source value.
588  * @dest_value: Target value.
589  *
590  * Tries to cast the contents of @src_value into a type appropriate
591  * to store in @dest_value, e.g. to transform a %G_TYPE_INT value
592  * into a %G_TYPE_FLOAT value. Performing transformations between
593  * value types might incur precision lossage. Especially
594  * transformations into strings might reveal seemingly arbitrary
595  * results and shouldn&#39;t be relied upon for production code (such
596  * as rcfile value or object property serialization).
597  *
598  * Returns: Whether a transformation rule was found and could be applied.
599  *  Upon failing transformations, @dest_value is left untouched.
600  */
601 gboolean
602 g_value_transform (const GValue *src_value,
<span class="line-modified">603        GValue       *dest_value)</span>
604 {
605   GType dest_type;
606 
<span class="line-modified">607   g_return_val_if_fail (src_value, FALSE);</span>
<span class="line-modified">608   g_return_val_if_fail (dest_value, FALSE);</span>
609 
610   dest_type = G_VALUE_TYPE (dest_value);
611   if (g_value_type_compatible (G_VALUE_TYPE (src_value), dest_type))
612     {
613       g_value_copy (src_value, dest_value);
614 
615       return TRUE;
616     }
617   else
618     {
619       GValueTransform transform = transform_func_lookup (G_VALUE_TYPE (src_value), dest_type);
620 
621       if (transform)
<span class="line-modified">622   {</span>
<span class="line-modified">623     g_value_unset (dest_value);</span>
624 
<span class="line-modified">625     /* setup and transform */</span>
<span class="line-modified">626     value_meminit (dest_value, dest_type);</span>
<span class="line-modified">627     transform (src_value, dest_value);</span>
628 
<span class="line-modified">629     return TRUE;</span>
<span class="line-modified">630   }</span>
631     }
632   return FALSE;
633 }
</pre>
</td>
</tr>
</table>
<center><a href="gtypeplugin.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gvalue.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>