<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/plugins/elements/gstqueue.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../libs/gst/controller/gsttriggercontrolsource.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="gsttypefindelement.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/plugins/elements/gstqueue.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 922       GST_EVENT_TYPE_NAME (event));
 923 
 924   switch (GST_EVENT_TYPE (event)) {
 925     case GST_EVENT_FLUSH_START:
 926       /* forward event */
 927       ret = gst_pad_push_event (queue-&gt;srcpad, event);
 928 
 929       /* now unblock the chain function */
 930       GST_QUEUE_MUTEX_LOCK (queue);
 931       queue-&gt;srcresult = GST_FLOW_FLUSHING;
 932       /* unblock the loop and chain functions */
 933       GST_QUEUE_SIGNAL_ADD (queue);
 934       GST_QUEUE_SIGNAL_DEL (queue);
 935       GST_QUEUE_MUTEX_UNLOCK (queue);
 936 
 937       /* make sure it pauses, this should happen since we sent
 938        * flush_start downstream. */
 939 #ifdef GSTREAMER_LITE
 940       // Pause task on pad only if it is linked
 941       if (gst_pad_is_linked (queue-&gt;srcpad)) {
<span class="line-modified"> 942           gst_pad_pause_task (queue-&gt;srcpad);</span>
 943       }
 944 #else // GSTREAMER_LITE
 945       gst_pad_pause_task (queue-&gt;srcpad);
 946 #endif // GSTREAMER_LITE
 947       GST_CAT_LOG_OBJECT (queue_dataflow, queue, &quot;loop stopped&quot;);
 948 
 949       /* unblock query handler after the streaming thread is shut down.
 950        * Otherwise downstream might have a query that is already unreffed
 951        * upstream */
 952       GST_QUEUE_MUTEX_LOCK (queue);
 953       queue-&gt;last_query = FALSE;
 954       g_cond_signal (&amp;queue-&gt;query_handled);
 955       GST_QUEUE_MUTEX_UNLOCK (queue);
 956       break;
 957     case GST_EVENT_FLUSH_STOP:
 958       /* forward event */
 959       ret = gst_pad_push_event (queue-&gt;srcpad, event);
 960 
 961       GST_QUEUE_MUTEX_LOCK (queue);
 962       gst_queue_locked_flush (queue, FALSE);
</pre>
<hr />
<pre>
1009 
1010         /* refuse more events on EOS unless they unset the EOS status */
1011         if (queue-&gt;eos) {
1012           switch (GST_EVENT_TYPE (event)) {
1013             case GST_EVENT_STREAM_START:
1014             case GST_EVENT_SEGMENT:
1015               /* Restart the loop */
1016               if (GST_PAD_MODE (queue-&gt;srcpad) == GST_PAD_MODE_PUSH) {
1017                 queue-&gt;srcresult = GST_FLOW_OK;
1018                 queue-&gt;eos = FALSE;
1019                 queue-&gt;unexpected = FALSE;
1020                 gst_pad_start_task (queue-&gt;srcpad,
1021                     (GstTaskFunction) gst_queue_loop, queue-&gt;srcpad, NULL);
1022               } else {
1023                 queue-&gt;eos = FALSE;
1024                 queue-&gt;unexpected = FALSE;
1025               }
1026 
1027               break;
1028             default:
<span class="line-modified">1029           goto out_eos;</span>
1030           }
1031         }
1032 
1033         gst_queue_locked_enqueue_event (queue, event);
1034         GST_QUEUE_MUTEX_UNLOCK (queue);
1035       } else {
1036         /* non-serialized events are forwarded downstream immediately */
1037         ret = gst_pad_push_event (queue-&gt;srcpad, event);
1038       }
1039       break;
1040   }
1041   if (ret == FALSE) {
1042     GST_ERROR_OBJECT (queue, &quot;Failed to push event&quot;);
1043     return GST_FLOW_ERROR;
1044   }
1045   return GST_FLOW_OK;
1046 
1047   /* ERRORS */
1048 out_eos:
1049   {
</pre>
<hr />
<pre>
1066 gst_queue_handle_sink_query (GstPad * pad, GstObject * parent, GstQuery * query)
1067 {
1068   GstQueue *queue = GST_QUEUE_CAST (parent);
1069   gboolean res;
1070 
1071   switch (GST_QUERY_TYPE (query)) {
1072     default:
1073       if (G_UNLIKELY (GST_QUERY_IS_SERIALIZED (query))) {
1074         GstQueueItem qitem;
1075 
1076         GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1077         GST_LOG_OBJECT (queue, &quot;queuing query %p (%s)&quot;, query,
1078             GST_QUERY_TYPE_NAME (query));
1079         qitem.item = GST_MINI_OBJECT_CAST (query);
1080         qitem.is_query = TRUE;
1081         qitem.size = 0;
1082         gst_queue_array_push_tail_struct (queue-&gt;queue, &amp;qitem);
1083         GST_QUEUE_SIGNAL_ADD (queue);
1084         while (queue-&gt;srcresult == GST_FLOW_OK &amp;&amp;
1085             queue-&gt;last_handled_query != query)
<span class="line-modified">1086         g_cond_wait (&amp;queue-&gt;query_handled, &amp;queue-&gt;qlock);</span>
1087         queue-&gt;last_handled_query = NULL;
1088         if (queue-&gt;srcresult != GST_FLOW_OK)
1089           goto out_flushing;
1090         res = queue-&gt;last_query;
1091         GST_QUEUE_MUTEX_UNLOCK (queue);
1092       } else {
1093         res = gst_pad_query_default (pad, parent, query);
1094       }
1095       break;
1096   }
1097   return res;
1098 
1099   /* ERRORS */
1100 out_flushing:
1101   {
1102     GST_DEBUG_OBJECT (queue, &quot;we are flushing&quot;);
1103     GST_QUEUE_MUTEX_UNLOCK (queue);
1104     return FALSE;
1105   }
1106 }
</pre>
<hr />
<pre>
1192 gst_queue_chain_buffer_or_list (GstPad * pad, GstObject * parent,
1193     GstMiniObject * obj, gboolean is_list)
1194 {
1195   GstQueue *queue;
1196 
1197   queue = GST_QUEUE_CAST (parent);
1198 
1199   /* we have to lock the queue since we span threads */
1200   GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1201   /* when we received EOS, we refuse any more data */
1202   if (queue-&gt;eos)
1203     goto out_eos;
1204   if (queue-&gt;unexpected)
1205     goto out_unexpected;
1206 
1207   if (!is_list) {
1208     GstClockTime duration, timestamp;
1209     GstBuffer *buffer = GST_BUFFER_CAST (obj);
1210 
1211     timestamp = GST_BUFFER_DTS_OR_PTS (buffer);
<span class="line-modified">1212   duration = GST_BUFFER_DURATION (buffer);</span>
1213 
<span class="line-modified">1214   GST_CAT_LOG_OBJECT (queue_dataflow, queue, &quot;received buffer %p of size %&quot;</span>
<span class="line-modified">1215       G_GSIZE_FORMAT &quot;, time %&quot; GST_TIME_FORMAT &quot;, duration %&quot;</span>
<span class="line-modified">1216       GST_TIME_FORMAT, buffer, gst_buffer_get_size (buffer),</span>
<span class="line-modified">1217       GST_TIME_ARGS (timestamp), GST_TIME_ARGS (duration));</span>
1218   } else {
1219     GST_CAT_LOG_OBJECT (queue_dataflow, queue,
1220         &quot;received buffer list %p with %u buffers&quot;, obj,
1221         gst_buffer_list_length (GST_BUFFER_LIST_CAST (obj)));
1222   }
1223 
1224   /* We make space available if we&#39;re &quot;full&quot; according to whatever
1225    * the user defined as &quot;full&quot;. Note that this only applies to buffers.
1226    * We always handle events and they don&#39;t count in our statistics. */
1227   while (gst_queue_is_filled (queue)) {
1228     if (!queue-&gt;silent) {
1229       GST_QUEUE_MUTEX_UNLOCK (queue);
1230       g_signal_emit (queue, gst_queue_signals[SIGNAL_OVERRUN], 0);
1231       GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1232       /* we recheck, the signal could have changed the thresholds */
1233       if (!gst_queue_is_filled (queue))
1234         break;
1235     }
1236 
1237     /* how are we going to make space for this buffer? */
</pre>
<hr />
<pre>
1259         do {
1260           /* for as long as the queue is filled, wait till an item was deleted. */
1261           GST_QUEUE_WAIT_DEL_CHECK (queue, out_flushing);
1262         } while (gst_queue_is_filled (queue));
1263 
1264         GST_CAT_DEBUG_OBJECT (queue_dataflow, queue, &quot;queue is not full&quot;);
1265 
1266         if (!queue-&gt;silent) {
1267           GST_QUEUE_MUTEX_UNLOCK (queue);
1268           g_signal_emit (queue, gst_queue_signals[SIGNAL_RUNNING], 0);
1269           GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1270         }
1271         break;
1272       }
1273     }
1274   }
1275 
1276   if (queue-&gt;tail_needs_discont) {
1277     if (!is_list) {
1278       GstBuffer *buffer = GST_BUFFER_CAST (obj);
<span class="line-modified">1279     GstBuffer *subbuffer = gst_buffer_make_writable (buffer);</span>
1280 
<span class="line-modified">1281     if (subbuffer) {</span>
<span class="line-modified">1282       buffer = subbuffer;</span>
<span class="line-modified">1283       GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);</span>
<span class="line-modified">1284     } else {</span>
<span class="line-modified">1285       GST_DEBUG_OBJECT (queue, &quot;Could not mark buffer as DISCONT&quot;);</span>
<span class="line-modified">1286     }</span>
1287 
1288       obj = GST_MINI_OBJECT_CAST (buffer);
1289     } else {
1290       GstBufferList *buffer_list = GST_BUFFER_LIST_CAST (obj);
1291 
1292       buffer_list = gst_buffer_list_make_writable (buffer_list);
1293       gst_buffer_list_foreach (buffer_list, discont_first_buffer, queue);
1294       obj = GST_MINI_OBJECT_CAST (buffer_list);
1295     }
1296     queue-&gt;tail_needs_discont = FALSE;
1297   }
1298 
1299   /* put buffer in queue now */
1300   if (is_list)
1301     gst_queue_locked_enqueue_buffer_list (queue, obj);
1302   else
1303     gst_queue_locked_enqueue_buffer (queue, obj);
1304   GST_QUEUE_MUTEX_UNLOCK (queue);
1305 
1306   return GST_FLOW_OK;
</pre>
<hr />
<pre>
1361 }
1362 
1363 /* dequeue an item from the queue an push it downstream. This functions returns
1364  * the result of the push. */
1365 static GstFlowReturn
1366 gst_queue_push_one (GstQueue * queue)
1367 {
1368   GstFlowReturn result = queue-&gt;srcresult;
1369   GstMiniObject *data;
1370   gboolean is_list;
1371 
1372   data = gst_queue_locked_dequeue (queue);
1373   if (data == NULL)
1374     goto no_item;
1375 
1376 next:
1377   is_list = GST_IS_BUFFER_LIST (data);
1378 
1379   if (GST_IS_BUFFER (data) || is_list) {
1380     if (!is_list) {
<span class="line-modified">1381     GstBuffer *buffer;</span>
1382 
<span class="line-modified">1383     buffer = GST_BUFFER_CAST (data);</span>
1384 
<span class="line-modified">1385     if (queue-&gt;head_needs_discont) {</span>
<span class="line-modified">1386       GstBuffer *subbuffer = gst_buffer_make_writable (buffer);</span>
1387 
<span class="line-modified">1388       if (subbuffer) {</span>
<span class="line-modified">1389         buffer = subbuffer;</span>
<span class="line-modified">1390         GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);</span>
<span class="line-modified">1391       } else {</span>
<span class="line-modified">1392         GST_DEBUG_OBJECT (queue, &quot;Could not mark buffer as DISCONT&quot;);</span>


1393       }
<span class="line-removed">1394       queue-&gt;head_needs_discont = FALSE;</span>
<span class="line-removed">1395     }</span>
1396 
<span class="line-modified">1397     GST_QUEUE_MUTEX_UNLOCK (queue);</span>
<span class="line-modified">1398     result = gst_pad_push (queue-&gt;srcpad, buffer);</span>
1399     } else {
1400       GstBufferList *buffer_list;
1401 
1402       buffer_list = GST_BUFFER_LIST_CAST (data);
1403 
1404       if (queue-&gt;head_needs_discont) {
1405         buffer_list = gst_buffer_list_make_writable (buffer_list);
1406         gst_buffer_list_foreach (buffer_list, discont_first_buffer, queue);
1407         queue-&gt;head_needs_discont = FALSE;
1408       }
1409 
1410       GST_QUEUE_MUTEX_UNLOCK (queue);
1411       result = gst_pad_push_list (queue-&gt;srcpad, buffer_list);
1412     }
1413 
1414     /* need to check for srcresult here as well */
1415     GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1416 
1417     if (result == GST_FLOW_EOS) {
1418       GST_CAT_LOG_OBJECT (queue_dataflow, queue, &quot;got EOS from downstream&quot;);
</pre>
<hr />
<pre>
1552       GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1553     }
1554   }
1555 
1556   ret = gst_queue_push_one (queue);
1557   queue-&gt;srcresult = ret;
1558   if (ret != GST_FLOW_OK)
1559     goto out_flushing;
1560 
1561   GST_QUEUE_MUTEX_UNLOCK (queue);
1562 
1563   return;
1564 
1565   /* ERRORS */
1566 out_flushing:
1567   {
1568     gboolean eos = queue-&gt;eos;
1569     GstFlowReturn ret = queue-&gt;srcresult;
1570 
1571 #ifdef GSTREAMER_LITE
<span class="line-modified">1572       // Pause task on pad only if it is linked</span>
<span class="line-modified">1573       if (gst_pad_is_linked (queue-&gt;srcpad)) {</span>
<span class="line-removed">1574           gst_pad_pause_task (queue-&gt;srcpad);</span>
<span class="line-removed">1575       }</span>
<span class="line-removed">1576 #else // GSTREAMER_LITE</span>
1577       gst_pad_pause_task (queue-&gt;srcpad);



1578 #endif // GSTREAMER_LITE
1579 
1580     GST_CAT_LOG_OBJECT (queue_dataflow, queue,
1581         &quot;pause task, reason:  %s&quot;, gst_flow_get_name (ret));
1582     if (ret == GST_FLOW_FLUSHING) {
1583       gst_queue_locked_flush (queue, FALSE);
1584     } else {
1585       GST_QUEUE_SIGNAL_DEL (queue);
1586       queue-&gt;last_query = FALSE;
1587       g_cond_signal (&amp;queue-&gt;query_handled);
1588     }
1589     GST_QUEUE_MUTEX_UNLOCK (queue);
1590     /* let app know about us giving up if upstream is not expected to do so */
1591     /* EOS is already taken care of elsewhere */
1592     if (eos &amp;&amp; (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS)) {
1593       GST_ELEMENT_FLOW_ERROR (queue, ret);
1594       gst_pad_push_event (queue-&gt;srcpad, gst_event_new_eos ());
1595     }
1596     return;
1597   }
</pre>
</td>
<td>
<hr />
<pre>
 922       GST_EVENT_TYPE_NAME (event));
 923 
 924   switch (GST_EVENT_TYPE (event)) {
 925     case GST_EVENT_FLUSH_START:
 926       /* forward event */
 927       ret = gst_pad_push_event (queue-&gt;srcpad, event);
 928 
 929       /* now unblock the chain function */
 930       GST_QUEUE_MUTEX_LOCK (queue);
 931       queue-&gt;srcresult = GST_FLOW_FLUSHING;
 932       /* unblock the loop and chain functions */
 933       GST_QUEUE_SIGNAL_ADD (queue);
 934       GST_QUEUE_SIGNAL_DEL (queue);
 935       GST_QUEUE_MUTEX_UNLOCK (queue);
 936 
 937       /* make sure it pauses, this should happen since we sent
 938        * flush_start downstream. */
 939 #ifdef GSTREAMER_LITE
 940       // Pause task on pad only if it is linked
 941       if (gst_pad_is_linked (queue-&gt;srcpad)) {
<span class="line-modified"> 942         gst_pad_pause_task (queue-&gt;srcpad);</span>
 943       }
 944 #else // GSTREAMER_LITE
 945       gst_pad_pause_task (queue-&gt;srcpad);
 946 #endif // GSTREAMER_LITE
 947       GST_CAT_LOG_OBJECT (queue_dataflow, queue, &quot;loop stopped&quot;);
 948 
 949       /* unblock query handler after the streaming thread is shut down.
 950        * Otherwise downstream might have a query that is already unreffed
 951        * upstream */
 952       GST_QUEUE_MUTEX_LOCK (queue);
 953       queue-&gt;last_query = FALSE;
 954       g_cond_signal (&amp;queue-&gt;query_handled);
 955       GST_QUEUE_MUTEX_UNLOCK (queue);
 956       break;
 957     case GST_EVENT_FLUSH_STOP:
 958       /* forward event */
 959       ret = gst_pad_push_event (queue-&gt;srcpad, event);
 960 
 961       GST_QUEUE_MUTEX_LOCK (queue);
 962       gst_queue_locked_flush (queue, FALSE);
</pre>
<hr />
<pre>
1009 
1010         /* refuse more events on EOS unless they unset the EOS status */
1011         if (queue-&gt;eos) {
1012           switch (GST_EVENT_TYPE (event)) {
1013             case GST_EVENT_STREAM_START:
1014             case GST_EVENT_SEGMENT:
1015               /* Restart the loop */
1016               if (GST_PAD_MODE (queue-&gt;srcpad) == GST_PAD_MODE_PUSH) {
1017                 queue-&gt;srcresult = GST_FLOW_OK;
1018                 queue-&gt;eos = FALSE;
1019                 queue-&gt;unexpected = FALSE;
1020                 gst_pad_start_task (queue-&gt;srcpad,
1021                     (GstTaskFunction) gst_queue_loop, queue-&gt;srcpad, NULL);
1022               } else {
1023                 queue-&gt;eos = FALSE;
1024                 queue-&gt;unexpected = FALSE;
1025               }
1026 
1027               break;
1028             default:
<span class="line-modified">1029               goto out_eos;</span>
1030           }
1031         }
1032 
1033         gst_queue_locked_enqueue_event (queue, event);
1034         GST_QUEUE_MUTEX_UNLOCK (queue);
1035       } else {
1036         /* non-serialized events are forwarded downstream immediately */
1037         ret = gst_pad_push_event (queue-&gt;srcpad, event);
1038       }
1039       break;
1040   }
1041   if (ret == FALSE) {
1042     GST_ERROR_OBJECT (queue, &quot;Failed to push event&quot;);
1043     return GST_FLOW_ERROR;
1044   }
1045   return GST_FLOW_OK;
1046 
1047   /* ERRORS */
1048 out_eos:
1049   {
</pre>
<hr />
<pre>
1066 gst_queue_handle_sink_query (GstPad * pad, GstObject * parent, GstQuery * query)
1067 {
1068   GstQueue *queue = GST_QUEUE_CAST (parent);
1069   gboolean res;
1070 
1071   switch (GST_QUERY_TYPE (query)) {
1072     default:
1073       if (G_UNLIKELY (GST_QUERY_IS_SERIALIZED (query))) {
1074         GstQueueItem qitem;
1075 
1076         GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1077         GST_LOG_OBJECT (queue, &quot;queuing query %p (%s)&quot;, query,
1078             GST_QUERY_TYPE_NAME (query));
1079         qitem.item = GST_MINI_OBJECT_CAST (query);
1080         qitem.is_query = TRUE;
1081         qitem.size = 0;
1082         gst_queue_array_push_tail_struct (queue-&gt;queue, &amp;qitem);
1083         GST_QUEUE_SIGNAL_ADD (queue);
1084         while (queue-&gt;srcresult == GST_FLOW_OK &amp;&amp;
1085             queue-&gt;last_handled_query != query)
<span class="line-modified">1086           g_cond_wait (&amp;queue-&gt;query_handled, &amp;queue-&gt;qlock);</span>
1087         queue-&gt;last_handled_query = NULL;
1088         if (queue-&gt;srcresult != GST_FLOW_OK)
1089           goto out_flushing;
1090         res = queue-&gt;last_query;
1091         GST_QUEUE_MUTEX_UNLOCK (queue);
1092       } else {
1093         res = gst_pad_query_default (pad, parent, query);
1094       }
1095       break;
1096   }
1097   return res;
1098 
1099   /* ERRORS */
1100 out_flushing:
1101   {
1102     GST_DEBUG_OBJECT (queue, &quot;we are flushing&quot;);
1103     GST_QUEUE_MUTEX_UNLOCK (queue);
1104     return FALSE;
1105   }
1106 }
</pre>
<hr />
<pre>
1192 gst_queue_chain_buffer_or_list (GstPad * pad, GstObject * parent,
1193     GstMiniObject * obj, gboolean is_list)
1194 {
1195   GstQueue *queue;
1196 
1197   queue = GST_QUEUE_CAST (parent);
1198 
1199   /* we have to lock the queue since we span threads */
1200   GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1201   /* when we received EOS, we refuse any more data */
1202   if (queue-&gt;eos)
1203     goto out_eos;
1204   if (queue-&gt;unexpected)
1205     goto out_unexpected;
1206 
1207   if (!is_list) {
1208     GstClockTime duration, timestamp;
1209     GstBuffer *buffer = GST_BUFFER_CAST (obj);
1210 
1211     timestamp = GST_BUFFER_DTS_OR_PTS (buffer);
<span class="line-modified">1212     duration = GST_BUFFER_DURATION (buffer);</span>
1213 
<span class="line-modified">1214     GST_CAT_LOG_OBJECT (queue_dataflow, queue, &quot;received buffer %p of size %&quot;</span>
<span class="line-modified">1215         G_GSIZE_FORMAT &quot;, time %&quot; GST_TIME_FORMAT &quot;, duration %&quot;</span>
<span class="line-modified">1216         GST_TIME_FORMAT, buffer, gst_buffer_get_size (buffer),</span>
<span class="line-modified">1217         GST_TIME_ARGS (timestamp), GST_TIME_ARGS (duration));</span>
1218   } else {
1219     GST_CAT_LOG_OBJECT (queue_dataflow, queue,
1220         &quot;received buffer list %p with %u buffers&quot;, obj,
1221         gst_buffer_list_length (GST_BUFFER_LIST_CAST (obj)));
1222   }
1223 
1224   /* We make space available if we&#39;re &quot;full&quot; according to whatever
1225    * the user defined as &quot;full&quot;. Note that this only applies to buffers.
1226    * We always handle events and they don&#39;t count in our statistics. */
1227   while (gst_queue_is_filled (queue)) {
1228     if (!queue-&gt;silent) {
1229       GST_QUEUE_MUTEX_UNLOCK (queue);
1230       g_signal_emit (queue, gst_queue_signals[SIGNAL_OVERRUN], 0);
1231       GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1232       /* we recheck, the signal could have changed the thresholds */
1233       if (!gst_queue_is_filled (queue))
1234         break;
1235     }
1236 
1237     /* how are we going to make space for this buffer? */
</pre>
<hr />
<pre>
1259         do {
1260           /* for as long as the queue is filled, wait till an item was deleted. */
1261           GST_QUEUE_WAIT_DEL_CHECK (queue, out_flushing);
1262         } while (gst_queue_is_filled (queue));
1263 
1264         GST_CAT_DEBUG_OBJECT (queue_dataflow, queue, &quot;queue is not full&quot;);
1265 
1266         if (!queue-&gt;silent) {
1267           GST_QUEUE_MUTEX_UNLOCK (queue);
1268           g_signal_emit (queue, gst_queue_signals[SIGNAL_RUNNING], 0);
1269           GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1270         }
1271         break;
1272       }
1273     }
1274   }
1275 
1276   if (queue-&gt;tail_needs_discont) {
1277     if (!is_list) {
1278       GstBuffer *buffer = GST_BUFFER_CAST (obj);
<span class="line-modified">1279       GstBuffer *subbuffer = gst_buffer_make_writable (buffer);</span>
1280 
<span class="line-modified">1281       if (subbuffer) {</span>
<span class="line-modified">1282         buffer = subbuffer;</span>
<span class="line-modified">1283         GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);</span>
<span class="line-modified">1284       } else {</span>
<span class="line-modified">1285         GST_DEBUG_OBJECT (queue, &quot;Could not mark buffer as DISCONT&quot;);</span>
<span class="line-modified">1286       }</span>
1287 
1288       obj = GST_MINI_OBJECT_CAST (buffer);
1289     } else {
1290       GstBufferList *buffer_list = GST_BUFFER_LIST_CAST (obj);
1291 
1292       buffer_list = gst_buffer_list_make_writable (buffer_list);
1293       gst_buffer_list_foreach (buffer_list, discont_first_buffer, queue);
1294       obj = GST_MINI_OBJECT_CAST (buffer_list);
1295     }
1296     queue-&gt;tail_needs_discont = FALSE;
1297   }
1298 
1299   /* put buffer in queue now */
1300   if (is_list)
1301     gst_queue_locked_enqueue_buffer_list (queue, obj);
1302   else
1303     gst_queue_locked_enqueue_buffer (queue, obj);
1304   GST_QUEUE_MUTEX_UNLOCK (queue);
1305 
1306   return GST_FLOW_OK;
</pre>
<hr />
<pre>
1361 }
1362 
1363 /* dequeue an item from the queue an push it downstream. This functions returns
1364  * the result of the push. */
1365 static GstFlowReturn
1366 gst_queue_push_one (GstQueue * queue)
1367 {
1368   GstFlowReturn result = queue-&gt;srcresult;
1369   GstMiniObject *data;
1370   gboolean is_list;
1371 
1372   data = gst_queue_locked_dequeue (queue);
1373   if (data == NULL)
1374     goto no_item;
1375 
1376 next:
1377   is_list = GST_IS_BUFFER_LIST (data);
1378 
1379   if (GST_IS_BUFFER (data) || is_list) {
1380     if (!is_list) {
<span class="line-modified">1381       GstBuffer *buffer;</span>
1382 
<span class="line-modified">1383       buffer = GST_BUFFER_CAST (data);</span>
1384 
<span class="line-modified">1385       if (queue-&gt;head_needs_discont) {</span>
<span class="line-modified">1386         GstBuffer *subbuffer = gst_buffer_make_writable (buffer);</span>
1387 
<span class="line-modified">1388         if (subbuffer) {</span>
<span class="line-modified">1389           buffer = subbuffer;</span>
<span class="line-modified">1390           GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);</span>
<span class="line-modified">1391         } else {</span>
<span class="line-modified">1392           GST_DEBUG_OBJECT (queue, &quot;Could not mark buffer as DISCONT&quot;);</span>
<span class="line-added">1393         }</span>
<span class="line-added">1394         queue-&gt;head_needs_discont = FALSE;</span>
1395       }


1396 
<span class="line-modified">1397       GST_QUEUE_MUTEX_UNLOCK (queue);</span>
<span class="line-modified">1398       result = gst_pad_push (queue-&gt;srcpad, buffer);</span>
1399     } else {
1400       GstBufferList *buffer_list;
1401 
1402       buffer_list = GST_BUFFER_LIST_CAST (data);
1403 
1404       if (queue-&gt;head_needs_discont) {
1405         buffer_list = gst_buffer_list_make_writable (buffer_list);
1406         gst_buffer_list_foreach (buffer_list, discont_first_buffer, queue);
1407         queue-&gt;head_needs_discont = FALSE;
1408       }
1409 
1410       GST_QUEUE_MUTEX_UNLOCK (queue);
1411       result = gst_pad_push_list (queue-&gt;srcpad, buffer_list);
1412     }
1413 
1414     /* need to check for srcresult here as well */
1415     GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1416 
1417     if (result == GST_FLOW_EOS) {
1418       GST_CAT_LOG_OBJECT (queue_dataflow, queue, &quot;got EOS from downstream&quot;);
</pre>
<hr />
<pre>
1552       GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1553     }
1554   }
1555 
1556   ret = gst_queue_push_one (queue);
1557   queue-&gt;srcresult = ret;
1558   if (ret != GST_FLOW_OK)
1559     goto out_flushing;
1560 
1561   GST_QUEUE_MUTEX_UNLOCK (queue);
1562 
1563   return;
1564 
1565   /* ERRORS */
1566 out_flushing:
1567   {
1568     gboolean eos = queue-&gt;eos;
1569     GstFlowReturn ret = queue-&gt;srcresult;
1570 
1571 #ifdef GSTREAMER_LITE
<span class="line-modified">1572     // Pause task on pad only if it is linked</span>
<span class="line-modified">1573     if (gst_pad_is_linked (queue-&gt;srcpad)) {</span>



1574       gst_pad_pause_task (queue-&gt;srcpad);
<span class="line-added">1575     }</span>
<span class="line-added">1576 #else // GSTREAMER_LITE</span>
<span class="line-added">1577     gst_pad_pause_task (queue-&gt;srcpad);</span>
1578 #endif // GSTREAMER_LITE
1579 
1580     GST_CAT_LOG_OBJECT (queue_dataflow, queue,
1581         &quot;pause task, reason:  %s&quot;, gst_flow_get_name (ret));
1582     if (ret == GST_FLOW_FLUSHING) {
1583       gst_queue_locked_flush (queue, FALSE);
1584     } else {
1585       GST_QUEUE_SIGNAL_DEL (queue);
1586       queue-&gt;last_query = FALSE;
1587       g_cond_signal (&amp;queue-&gt;query_handled);
1588     }
1589     GST_QUEUE_MUTEX_UNLOCK (queue);
1590     /* let app know about us giving up if upstream is not expected to do so */
1591     /* EOS is already taken care of elsewhere */
1592     if (eos &amp;&amp; (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS)) {
1593       GST_ELEMENT_FLOW_ERROR (queue, ret);
1594       gst_pad_push_event (queue-&gt;srcpad, gst_event_new_eos ());
1595     }
1596     return;
1597   }
</pre>
</td>
</tr>
</table>
<center><a href="../../libs/gst/controller/gsttriggercontrolsource.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="gsttypefindelement.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>