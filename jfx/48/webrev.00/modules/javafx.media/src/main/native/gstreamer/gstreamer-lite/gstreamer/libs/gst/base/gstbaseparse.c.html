<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstbaseparse.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 2008 Nokia Corporation. All rights reserved.
   3  *   Contact: Stefan Kost &lt;stefan.kost@nokia.com&gt;
   4  * Copyright (C) 2008 Sebastian Dröge &lt;sebastian.droege@collabora.co.uk&gt;.
   5  * Copyright (C) 2011, Hewlett-Packard Development Company, L.P.
   6  *   Author: Sebastian Dröge &lt;sebastian.droege@collabora.co.uk&gt;, Collabora Ltd.
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public
  19  * License along with this library; if not, write to the
  20  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 /**
  25  * SECTION:gstbaseparse
  26  * @title: GstBaseParse
  27  * @short_description: Base class for stream parsers
  28  * @see_also: #GstBaseTransform
  29  *
  30  * This base class is for parser elements that process data and splits it
  31  * into separate audio/video/whatever frames.
  32  *
  33  * It provides for:
  34  *
  35  *   * provides one sink pad and one source pad
  36  *   * handles state changes
  37  *   * can operate in pull mode or push mode
  38  *   * handles seeking in both modes
  39  *   * handles events (SEGMENT/EOS/FLUSH)
  40  *   * handles queries (POSITION/DURATION/SEEKING/FORMAT/CONVERT)
  41  *   * handles flushing
  42  *
  43  * The purpose of this base class is to provide the basic functionality of
  44  * a parser and share a lot of rather complex code.
  45  *
  46  * # Description of the parsing mechanism:
  47  *
  48  * ## Set-up phase
  49  *
  50  *  * #GstBaseParse calls #GstBaseParseClass.start() to inform subclass
  51  *    that data processing is about to start now.
  52  *
  53  *  * #GstBaseParse class calls #GstBaseParseClass.set_sink_caps() to
  54  *    inform the subclass about incoming sinkpad caps. Subclass could
  55  *    already set the srcpad caps accordingly, but this might be delayed
  56  *    until calling gst_base_parse_finish_frame() with a non-queued frame.
  57  *
  58  *  * At least at this point subclass needs to tell the #GstBaseParse class
  59  *    how big data chunks it wants to receive (minimum frame size ). It can
  60  *    do this with gst_base_parse_set_min_frame_size().
  61  *
  62  *  * #GstBaseParse class sets up appropriate data passing mode (pull/push)
  63  *    and starts to process the data.
  64  *
  65  * ## Parsing phase
  66  *
  67  *  * #GstBaseParse gathers at least min_frame_size bytes of data either
  68  *    by pulling it from upstream or collecting buffers in an internal
  69  *    #GstAdapter.
  70  *
  71  *  * A buffer of (at least) min_frame_size bytes is passed to subclass
  72  *    with #GstBaseParseClass.handle_frame(). Subclass checks the contents
  73  *    and can optionally return #GST_FLOW_OK along with an amount of data
  74  *    to be skipped to find a valid frame (which will result in a
  75  *    subsequent DISCONT).  If, otherwise, the buffer does not hold a
  76  *    complete frame, #GstBaseParseClass.handle_frame() can merely return
  77  *    and will be called again when additional data is available.  In push
  78  *    mode this amounts to an additional input buffer (thus minimal
  79  *    additional latency), in pull mode this amounts to some arbitrary
  80  *    reasonable buffer size increase.
  81  *
  82  *    Of course, gst_base_parse_set_min_frame_size() could also be used if
  83  *    a very specific known amount of additional data is required.  If,
  84  *    however, the buffer holds a complete valid frame, it can pass the
  85  *    size of this frame to gst_base_parse_finish_frame().
  86  *
  87  *    If acting as a converter, it can also merely indicate consumed input
  88  *    data while simultaneously providing custom output data.  Note that
  89  *    baseclass performs some processing (such as tracking overall consumed
  90  *    data rate versus duration) for each finished frame, but other state
  91  *    is only updated upon each call to #GstBaseParseClass.handle_frame()
  92  *    (such as tracking upstream input timestamp).
  93  *
  94  *    Subclass is also responsible for setting the buffer metadata
  95  *    (e.g. buffer timestamp and duration, or keyframe if applicable).
  96  *    (although the latter can also be done by #GstBaseParse if it is
  97  *    appropriately configured, see below).  Frame is provided with
  98  *    timestamp derived from upstream (as much as generally possible),
  99  *    duration obtained from configuration (see below), and offset
 100  *    if meaningful (in pull mode).
 101  *
 102  *    Note that #GstBaseParseClass.handle_frame() might receive any small
 103  *    amount of input data when leftover data is being drained (e.g. at
 104  *    EOS).
 105  *
 106  *  * As part of finish frame processing, just prior to actually pushing
 107  *    the buffer in question, it is passed to
 108  *    #GstBaseParseClass.pre_push_frame() which gives subclass yet one last
 109  *    chance to examine buffer metadata, or to send some custom (tag)
 110  *    events, or to perform custom (segment) filtering.
 111  *
 112  *  * During the parsing process #GstBaseParseClass will handle both srcpad
 113  *    and sinkpad events. They will be passed to subclass if
 114  *    #GstBaseParseClass.event() or #GstBaseParseClass.src_event()
 115  *    implementations have been provided.
 116  *
 117  * ## Shutdown phase
 118  *
 119  * * #GstBaseParse class calls #GstBaseParseClass.stop() to inform the
 120  *   subclass that data parsing will be stopped.
 121  *
 122  * Subclass is responsible for providing pad template caps for source and
 123  * sink pads. The pads need to be named &quot;sink&quot; and &quot;src&quot;. It also needs to
 124  * set the fixed caps on srcpad, when the format is ensured (e.g.  when
 125  * base class calls subclass&#39; #GstBaseParseClass.set_sink_caps() function).
 126  *
 127  * This base class uses %GST_FORMAT_DEFAULT as a meaning of frames. So,
 128  * subclass conversion routine needs to know that conversion from
 129  * %GST_FORMAT_TIME to %GST_FORMAT_DEFAULT must return the
 130  * frame number that can be found from the given byte position.
 131  *
 132  * #GstBaseParse uses subclasses conversion methods also for seeking (or
 133  * otherwise uses its own default one, see also below).
 134  *
 135  * Subclass @start and @stop functions will be called to inform the beginning
 136  * and end of data processing.
 137  *
 138  * Things that subclass need to take care of:
 139  *
 140  * * Provide pad templates
 141  * * Fixate the source pad caps when appropriate
 142  * * Inform base class how big data chunks should be retrieved. This is
 143  *   done with gst_base_parse_set_min_frame_size() function.
 144  * * Examine data chunks passed to subclass with
 145  *   #GstBaseParseClass.handle_frame() and pass proper frame(s) to
 146  *   gst_base_parse_finish_frame(), and setting src pad caps and timestamps
 147  *   on frame.
 148  * * Provide conversion functions
 149  * * Update the duration information with gst_base_parse_set_duration()
 150  * * Optionally passthrough using gst_base_parse_set_passthrough()
 151  * * Configure various baseparse parameters using
 152  *   gst_base_parse_set_average_bitrate(), gst_base_parse_set_syncable()
 153  *   and gst_base_parse_set_frame_rate().
 154  *
 155  * * In particular, if subclass is unable to determine a duration, but
 156  *   parsing (or specs) yields a frames per seconds rate, then this can be
 157  *   provided to #GstBaseParse to enable it to cater for buffer time
 158  *   metadata (which will be taken from upstream as much as
 159  *   possible). Internally keeping track of frame durations and respective
 160  *   sizes that have been pushed provides #GstBaseParse with an estimated
 161  *   bitrate. A default #GstBaseParseClass.convert() (used if not
 162  *   overridden) will then use these rates to perform obvious conversions.
 163  *   These rates are also used to update (estimated) duration at regular
 164  *   frame intervals.
 165  *
 166  */
 167 
 168 /* TODO:
 169  *  - In push mode provide a queue of adapter-&quot;queued&quot; buffers for upstream
 170  *    buffer metadata
 171  *  - Queue buffers/events until caps are set
 172  */
 173 
 174 #ifdef HAVE_CONFIG_H
 175 #  include &quot;config.h&quot;
 176 #endif
 177 
 178 #include &lt;stdlib.h&gt;
 179 #include &lt;string.h&gt;
 180 
 181 #include &lt;gst/base/gstadapter.h&gt;
 182 
 183 #include &quot;gstbaseparse.h&quot;
 184 
 185 /* FIXME: get rid of old GstIndex code */
 186 #include &quot;gstindex.h&quot;
 187 #include &quot;gstindex.c&quot;
 188 #include &quot;gstmemindex.c&quot;
 189 
 190 #ifdef GSTREAMER_LITE
 191 #undef GST_FUNCTION
 192 #define GST_FUNCTION &quot;&quot;
 193 #endif // GSTREAMER_LITE
 194 
 195 #define GST_BASE_PARSE_FRAME_PRIVATE_FLAG_NOALLOC  (1 &lt;&lt; 0)
 196 
 197 #define MIN_FRAMES_TO_POST_BITRATE 10
 198 #define TARGET_DIFFERENCE          (20 * GST_SECOND)
 199 #define MAX_INDEX_ENTRIES          4096
 200 #define UPDATE_THRESHOLD           2
 201 
 202 #define ABSDIFF(a,b) (((a) &gt; (b)) ? ((a) - (b)) : ((b) - (a)))
 203 
 204 GST_DEBUG_CATEGORY_STATIC (gst_base_parse_debug);
 205 #define GST_CAT_DEFAULT gst_base_parse_debug
 206 
 207 /* Supported formats */
 208 static const GstFormat fmtlist[] = {
 209   GST_FORMAT_DEFAULT,
 210   GST_FORMAT_BYTES,
 211   GST_FORMAT_TIME,
 212   GST_FORMAT_UNDEFINED
 213 };
 214 
 215 struct _GstBaseParsePrivate
 216 {
 217   GstPadMode pad_mode;
 218 
 219   GstAdapter *adapter;
 220 
 221   gint64 duration;
 222   GstFormat duration_fmt;
 223   gint64 estimated_duration;
 224   gint64 estimated_drift;
 225 
 226   guint min_frame_size;
 227   gboolean disable_passthrough;
 228   gboolean passthrough;
 229   gboolean pts_interpolate;
 230   gboolean infer_ts;
 231   gboolean syncable;
 232   gboolean has_timing_info;
 233   guint fps_num, fps_den;
 234   gint update_interval;
 235   guint bitrate;
 236   guint lead_in, lead_out;
 237   GstClockTime lead_in_ts, lead_out_ts;
 238   GstClockTime min_latency, max_latency;
 239 
 240   gboolean discont;
 241   gboolean flushing;
 242   gboolean drain;
 243   gboolean saw_gaps;
 244 
 245   gint64 offset;
 246   gint64 sync_offset;
 247   GstClockTime next_pts;
 248   GstClockTime next_dts;
 249   GstClockTime prev_pts;
 250   GstClockTime prev_dts;
 251   gboolean prev_dts_from_pts;
 252   GstClockTime frame_duration;
 253   gboolean seen_keyframe;
 254   gboolean is_video;
 255   gint flushed;
 256 
 257   guint64 framecount;
 258   guint64 bytecount;
 259   guint64 data_bytecount;
 260   guint64 acc_duration;
 261   GstClockTime first_frame_pts;
 262   GstClockTime first_frame_dts;
 263   gint64 first_frame_offset;
 264 
 265   gboolean post_min_bitrate;
 266   gboolean post_avg_bitrate;
 267   gboolean post_max_bitrate;
 268 
 269   guint min_bitrate;
 270   guint avg_bitrate;
 271   guint max_bitrate;
 272   guint posted_avg_bitrate;
 273 
 274   /* frames/buffers that are queued and ready to go on OK */
 275   GQueue queued_frames;
 276 
 277   GstBuffer *cache;
 278 
 279   /* index entry storage, either ours or provided */
 280   GstIndex *index;
 281   gint index_id;
 282   gboolean own_index;
 283   GMutex index_lock;
 284 
 285   /* seek table entries only maintained if upstream is BYTE seekable */
 286   gboolean upstream_seekable;
 287   gboolean upstream_has_duration;
 288   gint64 upstream_size;
 289   GstFormat upstream_format;
 290   /* minimum distance between two index entries */
 291   GstClockTimeDiff idx_interval;
 292   guint64 idx_byte_interval;
 293   /* ts and offset of last entry added */
 294   GstClockTime index_last_ts;
 295   gint64 index_last_offset;
 296   gboolean index_last_valid;
 297 
 298   /* timestamps currently produced are accurate, e.g. started from 0 onwards */
 299   gboolean exact_position;
 300   /* seek events are temporarily kept to match them with newsegments */
 301   GSList *pending_seeks;
 302 
 303   /* reverse playback */
 304   GSList *buffers_pending;
 305   GSList *buffers_head;
 306   GSList *buffers_queued;
 307   GSList *buffers_send;
 308   GstClockTime last_pts;
 309   GstClockTime last_dts;
 310   gint64 last_offset;
 311 
 312   /* Pending serialized events */
 313   GList *pending_events;
 314 
 315   /* If baseparse has checked the caps to identify if it is
 316    * handling video or audio */
 317   gboolean checked_media;
 318 
 319   /* offset of last parsed frame/data */
 320   gint64 prev_offset;
 321   /* force a new frame, regardless of offset */
 322   gboolean new_frame;
 323   /* whether we are merely scanning for a frame */
 324   gboolean scanning;
 325   /* ... and resulting frame, if any */
 326   GstBaseParseFrame *scanned_frame;
 327 
 328   /* TRUE if we&#39;re still detecting the format, i.e.
 329    * if ::detect() is still called for future buffers */
 330   gboolean detecting;
 331   GList *detect_buffers;
 332   guint detect_buffers_size;
 333 
 334   /* True when no buffers have been received yet */
 335   gboolean first_buffer;
 336 
 337   /* if TRUE, a STREAM_START event needs to be pushed */
 338   gboolean push_stream_start;
 339 
 340   /* When we need to skip more data than we have currently */
 341   guint skip;
 342 
 343   /* Tag handling (stream tags only, global tags are passed through as-is) */
 344   GstTagList *upstream_tags;
 345   GstTagList *parser_tags;
 346   GstTagMergeMode parser_tags_merge_mode;
 347   gboolean tags_changed;
 348 
 349   /* Current segment seqnum */
 350   guint32 segment_seqnum;
 351 };
 352 
 353 typedef struct _GstBaseParseSeek
 354 {
 355   GstSegment segment;
 356   gboolean accurate;
 357   gint64 offset;
 358   GstClockTime start_ts;
 359 } GstBaseParseSeek;
 360 
 361 #define DEFAULT_DISABLE_PASSTHROUGH        FALSE
 362 
 363 enum
 364 {
 365   PROP_0,
 366   PROP_DISABLE_PASSTHROUGH,
 367   PROP_LAST
 368 };
 369 
 370 #define GST_BASE_PARSE_INDEX_LOCK(parse) \
 371   g_mutex_lock (&amp;parse-&gt;priv-&gt;index_lock);
 372 #define GST_BASE_PARSE_INDEX_UNLOCK(parse) \
 373   g_mutex_unlock (&amp;parse-&gt;priv-&gt;index_lock);
 374 
 375 static GstElementClass *parent_class = NULL;
 376 static gint base_parse_private_offset = 0;
 377 
 378 static void gst_base_parse_class_init (GstBaseParseClass * klass);
 379 static void gst_base_parse_init (GstBaseParse * parse,
 380     GstBaseParseClass * klass);
 381 
 382 GType
 383 gst_base_parse_get_type (void)
 384 {
 385   static volatile gsize base_parse_type = 0;
 386 
 387   if (g_once_init_enter (&amp;base_parse_type)) {
 388     static const GTypeInfo base_parse_info = {
 389       sizeof (GstBaseParseClass),
 390       (GBaseInitFunc) NULL,
 391       (GBaseFinalizeFunc) NULL,
 392       (GClassInitFunc) gst_base_parse_class_init,
 393       NULL,
 394       NULL,
 395       sizeof (GstBaseParse),
 396       0,
 397       (GInstanceInitFunc) gst_base_parse_init,
 398     };
 399     GType _type;
 400 
 401     _type = g_type_register_static (GST_TYPE_ELEMENT,
 402         &quot;GstBaseParse&quot;, &amp;base_parse_info, G_TYPE_FLAG_ABSTRACT);
 403 
 404     base_parse_private_offset =
 405         g_type_add_instance_private (_type, sizeof (GstBaseParsePrivate));
 406 
 407     g_once_init_leave (&amp;base_parse_type, _type);
 408   }
 409   return (GType) base_parse_type;
 410 }
 411 
 412 static inline GstBaseParsePrivate *
 413 gst_base_parse_get_instance_private (GstBaseParse * self)
 414 {
 415   return (G_STRUCT_MEMBER_P (self, base_parse_private_offset));
 416 }
 417 
 418 static void gst_base_parse_finalize (GObject * object);
 419 
 420 static GstStateChangeReturn gst_base_parse_change_state (GstElement * element,
 421     GstStateChange transition);
 422 static void gst_base_parse_reset (GstBaseParse * parse);
 423 
 424 #if 0
 425 static void gst_base_parse_set_index (GstElement * element, GstIndex * index);
 426 static GstIndex *gst_base_parse_get_index (GstElement * element);
 427 #endif
 428 
 429 static gboolean gst_base_parse_sink_activate (GstPad * sinkpad,
 430     GstObject * parent);
 431 static gboolean gst_base_parse_sink_activate_mode (GstPad * pad,
 432     GstObject * parent, GstPadMode mode, gboolean active);
 433 static gboolean gst_base_parse_handle_seek (GstBaseParse * parse,
 434     GstEvent * event);
 435 static void gst_base_parse_set_upstream_tags (GstBaseParse * parse,
 436     GstTagList * taglist);
 437 
 438 static void gst_base_parse_set_property (GObject * object, guint prop_id,
 439     const GValue * value, GParamSpec * pspec);
 440 static void gst_base_parse_get_property (GObject * object, guint prop_id,
 441     GValue * value, GParamSpec * pspec);
 442 
 443 static gboolean gst_base_parse_src_event (GstPad * pad, GstObject * parent,
 444     GstEvent * event);
 445 static gboolean gst_base_parse_src_query (GstPad * pad, GstObject * parent,
 446     GstQuery * query);
 447 
 448 static gboolean gst_base_parse_sink_event (GstPad * pad, GstObject * parent,
 449     GstEvent * event);
 450 static gboolean gst_base_parse_sink_query (GstPad * pad, GstObject * parent,
 451     GstQuery * query);
 452 
 453 static GstFlowReturn gst_base_parse_chain (GstPad * pad, GstObject * parent,
 454     GstBuffer * buffer);
 455 static void gst_base_parse_loop (GstPad * pad);
 456 
 457 static GstFlowReturn gst_base_parse_parse_frame (GstBaseParse * parse,
 458     GstBaseParseFrame * frame);
 459 
 460 static gboolean gst_base_parse_sink_event_default (GstBaseParse * parse,
 461     GstEvent * event);
 462 
 463 static gboolean gst_base_parse_src_event_default (GstBaseParse * parse,
 464     GstEvent * event);
 465 
 466 static gboolean gst_base_parse_sink_query_default (GstBaseParse * parse,
 467     GstQuery * query);
 468 static gboolean gst_base_parse_src_query_default (GstBaseParse * parse,
 469     GstQuery * query);
 470 
 471 static gint64 gst_base_parse_find_offset (GstBaseParse * parse,
 472     GstClockTime time, gboolean before, GstClockTime * _ts);
 473 static GstFlowReturn gst_base_parse_locate_time (GstBaseParse * parse,
 474     GstClockTime * _time, gint64 * _offset);
 475 
 476 static GstFlowReturn gst_base_parse_start_fragment (GstBaseParse * parse);
 477 static GstFlowReturn gst_base_parse_finish_fragment (GstBaseParse * parse,
 478     gboolean prev_head);
 479 static GstFlowReturn gst_base_parse_send_buffers (GstBaseParse * parse);
 480 
 481 static inline GstFlowReturn gst_base_parse_check_sync (GstBaseParse * parse);
 482 
 483 static gboolean gst_base_parse_is_seekable (GstBaseParse * parse);
 484 
 485 static void gst_base_parse_push_pending_events (GstBaseParse * parse);
 486 
 487 static void
 488 gst_base_parse_clear_queues (GstBaseParse * parse)
 489 {
 490   g_slist_foreach (parse-&gt;priv-&gt;buffers_queued, (GFunc) gst_buffer_unref, NULL);
 491   g_slist_free (parse-&gt;priv-&gt;buffers_queued);
 492   parse-&gt;priv-&gt;buffers_queued = NULL;
 493   g_slist_foreach (parse-&gt;priv-&gt;buffers_pending, (GFunc) gst_buffer_unref,
 494       NULL);
 495   g_slist_free (parse-&gt;priv-&gt;buffers_pending);
 496   parse-&gt;priv-&gt;buffers_pending = NULL;
 497   g_slist_foreach (parse-&gt;priv-&gt;buffers_head, (GFunc) gst_buffer_unref, NULL);
 498   g_slist_free (parse-&gt;priv-&gt;buffers_head);
 499   parse-&gt;priv-&gt;buffers_head = NULL;
 500   g_slist_foreach (parse-&gt;priv-&gt;buffers_send, (GFunc) gst_buffer_unref, NULL);
 501   g_slist_free (parse-&gt;priv-&gt;buffers_send);
 502   parse-&gt;priv-&gt;buffers_send = NULL;
 503 
 504   g_list_foreach (parse-&gt;priv-&gt;detect_buffers, (GFunc) gst_buffer_unref, NULL);
 505   g_list_free (parse-&gt;priv-&gt;detect_buffers);
 506   parse-&gt;priv-&gt;detect_buffers = NULL;
 507   parse-&gt;priv-&gt;detect_buffers_size = 0;
 508 
 509   g_queue_foreach (&amp;parse-&gt;priv-&gt;queued_frames,
 510       (GFunc) gst_base_parse_frame_free, NULL);
 511   g_queue_clear (&amp;parse-&gt;priv-&gt;queued_frames);
 512 
 513   gst_buffer_replace (&amp;parse-&gt;priv-&gt;cache, NULL);
 514 
 515   g_list_foreach (parse-&gt;priv-&gt;pending_events, (GFunc) gst_event_unref, NULL);
 516   g_list_free (parse-&gt;priv-&gt;pending_events);
 517   parse-&gt;priv-&gt;pending_events = NULL;
 518 
 519   parse-&gt;priv-&gt;checked_media = FALSE;
 520 }
 521 
 522 static void
 523 gst_base_parse_finalize (GObject * object)
 524 {
 525   GstBaseParse *parse = GST_BASE_PARSE (object);
 526 
 527   g_object_unref (parse-&gt;priv-&gt;adapter);
 528 
 529   if (parse-&gt;priv-&gt;index) {
 530     gst_object_unref (parse-&gt;priv-&gt;index);
 531     parse-&gt;priv-&gt;index = NULL;
 532   }
 533   g_mutex_clear (&amp;parse-&gt;priv-&gt;index_lock);
 534 
 535   gst_base_parse_clear_queues (parse);
 536 
 537   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 538 }
 539 
 540 static void
 541 gst_base_parse_class_init (GstBaseParseClass * klass)
 542 {
 543   GObjectClass *gobject_class;
 544   GstElementClass *gstelement_class;
 545 
 546   gobject_class = G_OBJECT_CLASS (klass);
 547 
 548   if (base_parse_private_offset != 0)
 549     g_type_class_adjust_private_offset (klass, &amp;base_parse_private_offset);
 550 
 551   parent_class = g_type_class_peek_parent (klass);
 552 
 553   gobject_class-&gt;finalize = GST_DEBUG_FUNCPTR (gst_base_parse_finalize);
 554   gobject_class-&gt;set_property = GST_DEBUG_FUNCPTR (gst_base_parse_set_property);
 555   gobject_class-&gt;get_property = GST_DEBUG_FUNCPTR (gst_base_parse_get_property);
 556 
 557   /**
 558    * GstBaseParse:disable-passthrough:
 559    *
 560    * If set to %TRUE, baseparse will unconditionally force parsing of the
 561    * incoming data. This can be required in the rare cases where the incoming
 562    * side-data (caps, pts, dts, ...) is not trusted by the user and wants to
 563    * force validation and parsing of the incoming data.
 564    * If set to %FALSE, decision of whether to parse the data or not is up to
 565    * the implementation (standard behaviour).
 566    */
 567   g_object_class_install_property (gobject_class, PROP_DISABLE_PASSTHROUGH,
 568       g_param_spec_boolean (&quot;disable-passthrough&quot;, &quot;Disable passthrough&quot;,
 569           &quot;Force processing (disables passthrough)&quot;,
 570           DEFAULT_DISABLE_PASSTHROUGH,
 571           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 572 
 573   gstelement_class = (GstElementClass *) klass;
 574   gstelement_class-&gt;change_state =
 575       GST_DEBUG_FUNCPTR (gst_base_parse_change_state);
 576 
 577 #if 0
 578   gstelement_class-&gt;set_index = GST_DEBUG_FUNCPTR (gst_base_parse_set_index);
 579   gstelement_class-&gt;get_index = GST_DEBUG_FUNCPTR (gst_base_parse_get_index);
 580 #endif
 581 
 582   /* Default handlers */
 583   klass-&gt;sink_event = gst_base_parse_sink_event_default;
 584   klass-&gt;src_event = gst_base_parse_src_event_default;
 585   klass-&gt;sink_query = gst_base_parse_sink_query_default;
 586   klass-&gt;src_query = gst_base_parse_src_query_default;
 587   klass-&gt;convert = gst_base_parse_convert_default;
 588 
 589   GST_DEBUG_CATEGORY_INIT (gst_base_parse_debug, &quot;baseparse&quot;, 0,
 590       &quot;baseparse element&quot;);
 591 }
 592 
 593 static void
 594 gst_base_parse_init (GstBaseParse * parse, GstBaseParseClass * bclass)
 595 {
 596   GstPadTemplate *pad_template;
 597 
 598   GST_DEBUG_OBJECT (parse, &quot;gst_base_parse_init&quot;);
 599 
 600   parse-&gt;priv = gst_base_parse_get_instance_private (parse);
 601 
 602   pad_template =
 603       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;sink&quot;);
 604   g_return_if_fail (pad_template != NULL);
 605   parse-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 606   gst_pad_set_event_function (parse-&gt;sinkpad,
 607       GST_DEBUG_FUNCPTR (gst_base_parse_sink_event));
 608   gst_pad_set_query_function (parse-&gt;sinkpad,
 609       GST_DEBUG_FUNCPTR (gst_base_parse_sink_query));
 610   gst_pad_set_chain_function (parse-&gt;sinkpad,
 611       GST_DEBUG_FUNCPTR (gst_base_parse_chain));
 612   gst_pad_set_activate_function (parse-&gt;sinkpad,
 613       GST_DEBUG_FUNCPTR (gst_base_parse_sink_activate));
 614   gst_pad_set_activatemode_function (parse-&gt;sinkpad,
 615       GST_DEBUG_FUNCPTR (gst_base_parse_sink_activate_mode));
 616   GST_PAD_SET_PROXY_ALLOCATION (parse-&gt;sinkpad);
 617   gst_element_add_pad (GST_ELEMENT (parse), parse-&gt;sinkpad);
 618 
 619   GST_DEBUG_OBJECT (parse, &quot;sinkpad created&quot;);
 620 
 621   pad_template =
 622       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;src&quot;);
 623   g_return_if_fail (pad_template != NULL);
 624   parse-&gt;srcpad = gst_pad_new_from_template (pad_template, &quot;src&quot;);
 625   gst_pad_set_event_function (parse-&gt;srcpad,
 626       GST_DEBUG_FUNCPTR (gst_base_parse_src_event));
 627   gst_pad_set_query_function (parse-&gt;srcpad,
 628       GST_DEBUG_FUNCPTR (gst_base_parse_src_query));
 629   gst_pad_use_fixed_caps (parse-&gt;srcpad);
 630   gst_element_add_pad (GST_ELEMENT (parse), parse-&gt;srcpad);
 631   GST_DEBUG_OBJECT (parse, &quot;src created&quot;);
 632 
 633   g_queue_init (&amp;parse-&gt;priv-&gt;queued_frames);
 634 
 635   parse-&gt;priv-&gt;adapter = gst_adapter_new ();
 636 
 637   parse-&gt;priv-&gt;pad_mode = GST_PAD_MODE_NONE;
 638 
 639   g_mutex_init (&amp;parse-&gt;priv-&gt;index_lock);
 640 
 641   /* init state */
 642   gst_base_parse_reset (parse);
 643   GST_DEBUG_OBJECT (parse, &quot;init ok&quot;);
 644 
 645   GST_OBJECT_FLAG_SET (parse, GST_ELEMENT_FLAG_INDEXABLE);
 646 
 647   parse-&gt;priv-&gt;upstream_tags = NULL;
 648   parse-&gt;priv-&gt;parser_tags = NULL;
 649   parse-&gt;priv-&gt;parser_tags_merge_mode = GST_TAG_MERGE_APPEND;
 650   parse-&gt;priv-&gt;disable_passthrough = DEFAULT_DISABLE_PASSTHROUGH;
 651 }
 652 
 653 static void
 654 gst_base_parse_set_property (GObject * object, guint prop_id,
 655     const GValue * value, GParamSpec * pspec)
 656 {
 657   GstBaseParse *parse = GST_BASE_PARSE (object);
 658 
 659   switch (prop_id) {
 660     case PROP_DISABLE_PASSTHROUGH:
 661       parse-&gt;priv-&gt;disable_passthrough = g_value_get_boolean (value);
 662       break;
 663     default:
 664       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 665       break;
 666   }
 667 }
 668 
 669 static void
 670 gst_base_parse_get_property (GObject * object, guint prop_id, GValue * value,
 671     GParamSpec * pspec)
 672 {
 673   GstBaseParse *parse = GST_BASE_PARSE (object);
 674 
 675   switch (prop_id) {
 676     case PROP_DISABLE_PASSTHROUGH:
 677       g_value_set_boolean (value, parse-&gt;priv-&gt;disable_passthrough);
 678       break;
 679     default:
 680       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 681       break;
 682   }
 683 }
 684 
 685 /**
 686  * gst_base_parse_frame_copy:
 687  * @frame: a #GstBaseParseFrame
 688  *
 689  * Copies a #GstBaseParseFrame.
 690  *
 691  * Returns: A copy of @frame
 692  */
 693 
 694 GstBaseParseFrame *
 695 gst_base_parse_frame_copy (GstBaseParseFrame * frame)
 696 {
 697   GstBaseParseFrame *copy;
 698 
 699   copy = g_slice_dup (GstBaseParseFrame, frame);
 700   copy-&gt;buffer = gst_buffer_ref (frame-&gt;buffer);
 701   copy-&gt;_private_flags &amp;= ~GST_BASE_PARSE_FRAME_PRIVATE_FLAG_NOALLOC;
 702 
 703   GST_TRACE (&quot;copied frame %p -&gt; %p&quot;, frame, copy);
 704 
 705   return copy;
 706 }
 707 
 708 /**
 709  * gst_base_parse_frame_free:
 710  * @frame: A #GstBaseParseFrame
 711  *
 712  * Frees the provided @frame.
 713  */
 714 void
 715 gst_base_parse_frame_free (GstBaseParseFrame * frame)
 716 {
 717   GST_TRACE (&quot;freeing frame %p&quot;, frame);
 718 
 719   if (frame-&gt;buffer) {
 720     gst_buffer_unref (frame-&gt;buffer);
 721     frame-&gt;buffer = NULL;
 722   }
 723 
 724   if (!(frame-&gt;_private_flags &amp; GST_BASE_PARSE_FRAME_PRIVATE_FLAG_NOALLOC)) {
 725     g_slice_free (GstBaseParseFrame, frame);
 726   } else {
 727     memset (frame, 0, sizeof (*frame));
 728   }
 729 }
 730 
 731 G_DEFINE_BOXED_TYPE (GstBaseParseFrame, gst_base_parse_frame,
 732     (GBoxedCopyFunc) gst_base_parse_frame_copy,
 733     (GBoxedFreeFunc) gst_base_parse_frame_free);
 734 
 735 /**
 736  * gst_base_parse_frame_init:
 737  * @frame: #GstBaseParseFrame.
 738  *
 739  * Sets a #GstBaseParseFrame to initial state.  Currently this means
 740  * all public fields are zero-ed and a private flag is set to make
 741  * sure gst_base_parse_frame_free() only frees the contents but not
 742  * the actual frame. Use this function to initialise a #GstBaseParseFrame
 743  * allocated on the stack.
 744  */
 745 void
 746 gst_base_parse_frame_init (GstBaseParseFrame * frame)
 747 {
 748   memset (frame, 0, sizeof (GstBaseParseFrame));
 749   frame-&gt;_private_flags = GST_BASE_PARSE_FRAME_PRIVATE_FLAG_NOALLOC;
 750   GST_TRACE (&quot;inited frame %p&quot;, frame);
 751 }
 752 
 753 /**
 754  * gst_base_parse_frame_new:
 755  * @buffer: (transfer none): a #GstBuffer
 756  * @flags: the flags
 757  * @overhead: number of bytes in this frame which should be counted as
 758  *     metadata overhead, ie. not used to calculate the average bitrate.
 759  *     Set to -1 to mark the entire frame as metadata. If in doubt, set to 0.
 760  *
 761  * Allocates a new #GstBaseParseFrame. This function is mainly for bindings,
 762  * elements written in C should usually allocate the frame on the stack and
 763  * then use gst_base_parse_frame_init() to initialise it.
 764  *
 765  * Returns: a newly-allocated #GstBaseParseFrame. Free with
 766  *     gst_base_parse_frame_free() when no longer needed.
 767  */
 768 GstBaseParseFrame *
 769 gst_base_parse_frame_new (GstBuffer * buffer, GstBaseParseFrameFlags flags,
 770     gint overhead)
 771 {
 772   GstBaseParseFrame *frame;
 773 
 774   frame = g_slice_new0 (GstBaseParseFrame);
 775   frame-&gt;buffer = gst_buffer_ref (buffer);
 776 
 777   GST_TRACE (&quot;created frame %p&quot;, frame);
 778   return frame;
 779 }
 780 
 781 static inline void
 782 gst_base_parse_update_flags (GstBaseParse * parse)
 783 {
 784   parse-&gt;flags = 0;
 785 
 786   /* set flags one by one for clarity */
 787   if (G_UNLIKELY (parse-&gt;priv-&gt;drain))
 788     parse-&gt;flags |= GST_BASE_PARSE_FLAG_DRAINING;
 789 
 790   /* losing sync is pretty much a discont (and vice versa), no ? */
 791   if (G_UNLIKELY (parse-&gt;priv-&gt;discont))
 792     parse-&gt;flags |= GST_BASE_PARSE_FLAG_LOST_SYNC;
 793 }
 794 
 795 static inline void
 796 gst_base_parse_update_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
 797 {
 798   if (G_UNLIKELY (parse-&gt;priv-&gt;discont)) {
 799     GST_DEBUG_OBJECT (parse, &quot;marking DISCONT&quot;);
 800     GST_BUFFER_FLAG_SET (frame-&gt;buffer, GST_BUFFER_FLAG_DISCONT);
 801   } else {
 802     GST_BUFFER_FLAG_UNSET (frame-&gt;buffer, GST_BUFFER_FLAG_DISCONT);
 803   }
 804 
 805   if (parse-&gt;priv-&gt;prev_offset != parse-&gt;priv-&gt;offset || parse-&gt;priv-&gt;new_frame) {
 806     GST_LOG_OBJECT (parse, &quot;marking as new frame&quot;);
 807     frame-&gt;flags |= GST_BASE_PARSE_FRAME_FLAG_NEW_FRAME;
 808   }
 809 
 810   frame-&gt;offset = parse-&gt;priv-&gt;prev_offset = parse-&gt;priv-&gt;offset;
 811 }
 812 
 813 static void
 814 gst_base_parse_reset (GstBaseParse * parse)
 815 {
 816   GST_OBJECT_LOCK (parse);
 817   gst_segment_init (&amp;parse-&gt;segment, GST_FORMAT_TIME);
 818   parse-&gt;priv-&gt;duration = -1;
 819   parse-&gt;priv-&gt;min_frame_size = 1;
 820   parse-&gt;priv-&gt;discont = TRUE;
 821   parse-&gt;priv-&gt;flushing = FALSE;
 822   parse-&gt;priv-&gt;saw_gaps = FALSE;
 823   parse-&gt;priv-&gt;offset = 0;
 824   parse-&gt;priv-&gt;sync_offset = 0;
 825   parse-&gt;priv-&gt;update_interval = -1;
 826   parse-&gt;priv-&gt;fps_num = parse-&gt;priv-&gt;fps_den = 0;
 827   parse-&gt;priv-&gt;frame_duration = GST_CLOCK_TIME_NONE;
 828   parse-&gt;priv-&gt;lead_in = parse-&gt;priv-&gt;lead_out = 0;
 829   parse-&gt;priv-&gt;lead_in_ts = parse-&gt;priv-&gt;lead_out_ts = 0;
 830   parse-&gt;priv-&gt;bitrate = 0;
 831   parse-&gt;priv-&gt;framecount = 0;
 832   parse-&gt;priv-&gt;bytecount = 0;
 833   parse-&gt;priv-&gt;acc_duration = 0;
 834   parse-&gt;priv-&gt;first_frame_pts = GST_CLOCK_TIME_NONE;
 835   parse-&gt;priv-&gt;first_frame_dts = GST_CLOCK_TIME_NONE;
 836   parse-&gt;priv-&gt;first_frame_offset = -1;
 837   parse-&gt;priv-&gt;estimated_duration = -1;
 838   parse-&gt;priv-&gt;estimated_drift = 0;
 839   parse-&gt;priv-&gt;next_pts = GST_CLOCK_TIME_NONE;
 840   parse-&gt;priv-&gt;next_dts = 0;
 841   parse-&gt;priv-&gt;syncable = TRUE;
 842   parse-&gt;priv-&gt;passthrough = FALSE;
 843   parse-&gt;priv-&gt;pts_interpolate = TRUE;
 844   parse-&gt;priv-&gt;infer_ts = TRUE;
 845   parse-&gt;priv-&gt;has_timing_info = FALSE;
 846   parse-&gt;priv-&gt;min_bitrate = G_MAXUINT;
 847   parse-&gt;priv-&gt;max_bitrate = 0;
 848   parse-&gt;priv-&gt;avg_bitrate = 0;
 849   parse-&gt;priv-&gt;posted_avg_bitrate = 0;
 850 
 851   parse-&gt;priv-&gt;index_last_ts = GST_CLOCK_TIME_NONE;
 852   parse-&gt;priv-&gt;index_last_offset = -1;
 853   parse-&gt;priv-&gt;index_last_valid = TRUE;
 854   parse-&gt;priv-&gt;upstream_seekable = FALSE;
 855   parse-&gt;priv-&gt;upstream_size = 0;
 856   parse-&gt;priv-&gt;upstream_has_duration = FALSE;
 857   parse-&gt;priv-&gt;upstream_format = GST_FORMAT_UNDEFINED;
 858   parse-&gt;priv-&gt;idx_interval = 0;
 859   parse-&gt;priv-&gt;idx_byte_interval = 0;
 860   parse-&gt;priv-&gt;exact_position = TRUE;
 861   parse-&gt;priv-&gt;seen_keyframe = FALSE;
 862   parse-&gt;priv-&gt;checked_media = FALSE;
 863 
 864   parse-&gt;priv-&gt;last_dts = GST_CLOCK_TIME_NONE;
 865   parse-&gt;priv-&gt;last_pts = GST_CLOCK_TIME_NONE;
 866   parse-&gt;priv-&gt;last_offset = 0;
 867 
 868   parse-&gt;priv-&gt;skip = 0;
 869 
 870   g_list_foreach (parse-&gt;priv-&gt;pending_events, (GFunc) gst_mini_object_unref,
 871       NULL);
 872   g_list_free (parse-&gt;priv-&gt;pending_events);
 873   parse-&gt;priv-&gt;pending_events = NULL;
 874 
 875   if (parse-&gt;priv-&gt;cache) {
 876     gst_buffer_unref (parse-&gt;priv-&gt;cache);
 877     parse-&gt;priv-&gt;cache = NULL;
 878   }
 879 
 880   g_slist_foreach (parse-&gt;priv-&gt;pending_seeks, (GFunc) g_free, NULL);
 881   g_slist_free (parse-&gt;priv-&gt;pending_seeks);
 882   parse-&gt;priv-&gt;pending_seeks = NULL;
 883 
 884   if (parse-&gt;priv-&gt;adapter)
 885     gst_adapter_clear (parse-&gt;priv-&gt;adapter);
 886 
 887   gst_base_parse_set_upstream_tags (parse, NULL);
 888 
 889   if (parse-&gt;priv-&gt;parser_tags) {
 890     gst_tag_list_unref (parse-&gt;priv-&gt;parser_tags);
 891     parse-&gt;priv-&gt;parser_tags = NULL;
 892   }
 893   parse-&gt;priv-&gt;parser_tags_merge_mode = GST_TAG_MERGE_APPEND;
 894 
 895   parse-&gt;priv-&gt;new_frame = TRUE;
 896 
 897   parse-&gt;priv-&gt;first_buffer = TRUE;
 898 
 899   g_list_foreach (parse-&gt;priv-&gt;detect_buffers, (GFunc) gst_buffer_unref, NULL);
 900   g_list_free (parse-&gt;priv-&gt;detect_buffers);
 901   parse-&gt;priv-&gt;detect_buffers = NULL;
 902   parse-&gt;priv-&gt;detect_buffers_size = 0;
 903 
 904   parse-&gt;priv-&gt;segment_seqnum = GST_SEQNUM_INVALID;
 905   GST_OBJECT_UNLOCK (parse);
 906 }
 907 
 908 static gboolean
 909 gst_base_parse_check_bitrate_tag (GstBaseParse * parse, const gchar * tag)
 910 {
 911   gboolean got_tag = FALSE;
 912   guint n = 0;
 913 
 914   if (parse-&gt;priv-&gt;upstream_tags != NULL)
 915     got_tag = gst_tag_list_get_uint (parse-&gt;priv-&gt;upstream_tags, tag, &amp;n);
 916 
 917   if (!got_tag &amp;&amp; parse-&gt;priv-&gt;parser_tags != NULL)
 918     got_tag = gst_tag_list_get_uint (parse-&gt;priv-&gt;parser_tags, tag, &amp;n);
 919 
 920   return got_tag;
 921 }
 922 
 923 /* check if upstream or subclass tags contain bitrates already */
 924 static void
 925 gst_base_parse_check_bitrate_tags (GstBaseParse * parse)
 926 {
 927   parse-&gt;priv-&gt;post_min_bitrate =
 928       !gst_base_parse_check_bitrate_tag (parse, GST_TAG_MINIMUM_BITRATE);
 929   parse-&gt;priv-&gt;post_avg_bitrate =
 930       !gst_base_parse_check_bitrate_tag (parse, GST_TAG_BITRATE);
 931   parse-&gt;priv-&gt;post_max_bitrate =
 932       !gst_base_parse_check_bitrate_tag (parse, GST_TAG_MAXIMUM_BITRATE);
 933 }
 934 
 935 /* Queues new tag event with the current combined state of the stream tags
 936  * (i.e. upstream tags merged with subclass tags and current baseparse tags) */
 937 static void
 938 gst_base_parse_queue_tag_event_update (GstBaseParse * parse)
 939 {
 940   GstTagList *merged_tags;
 941 
 942   GST_LOG_OBJECT (parse, &quot;upstream : %&quot; GST_PTR_FORMAT,
 943       parse-&gt;priv-&gt;upstream_tags);
 944   GST_LOG_OBJECT (parse, &quot;parser   : %&quot; GST_PTR_FORMAT,
 945       parse-&gt;priv-&gt;parser_tags);
 946   GST_LOG_OBJECT (parse, &quot;mode     : %d&quot;, parse-&gt;priv-&gt;parser_tags_merge_mode);
 947 
 948   merged_tags =
 949       gst_tag_list_merge (parse-&gt;priv-&gt;upstream_tags, parse-&gt;priv-&gt;parser_tags,
 950       parse-&gt;priv-&gt;parser_tags_merge_mode);
 951 
 952   GST_DEBUG_OBJECT (parse, &quot;merged   : %&quot; GST_PTR_FORMAT, merged_tags);
 953 
 954   if (merged_tags == NULL)
 955     return;
 956 
 957   if (gst_tag_list_is_empty (merged_tags)) {
 958     gst_tag_list_unref (merged_tags);
 959     return;
 960   }
 961 
 962   if (parse-&gt;priv-&gt;framecount &gt;= MIN_FRAMES_TO_POST_BITRATE) {
 963     /* only add bitrate tags to non-empty taglists for now, and only if neither
 964      * upstream tags nor the subclass sets the bitrate tag in question already */
 965     if (parse-&gt;priv-&gt;min_bitrate != G_MAXUINT &amp;&amp; parse-&gt;priv-&gt;post_min_bitrate) {
 966       GST_LOG_OBJECT (parse, &quot;adding min bitrate %u&quot;, parse-&gt;priv-&gt;min_bitrate);
 967       gst_tag_list_add (merged_tags, GST_TAG_MERGE_KEEP,
 968           GST_TAG_MINIMUM_BITRATE, parse-&gt;priv-&gt;min_bitrate, NULL);
 969     }
 970     if (parse-&gt;priv-&gt;max_bitrate != 0 &amp;&amp; parse-&gt;priv-&gt;post_max_bitrate) {
 971       GST_LOG_OBJECT (parse, &quot;adding max bitrate %u&quot;, parse-&gt;priv-&gt;max_bitrate);
 972       gst_tag_list_add (merged_tags, GST_TAG_MERGE_KEEP,
 973           GST_TAG_MAXIMUM_BITRATE, parse-&gt;priv-&gt;max_bitrate, NULL);
 974     }
 975     if (parse-&gt;priv-&gt;avg_bitrate != 0 &amp;&amp; parse-&gt;priv-&gt;post_avg_bitrate) {
 976       parse-&gt;priv-&gt;posted_avg_bitrate = parse-&gt;priv-&gt;avg_bitrate;
 977       GST_LOG_OBJECT (parse, &quot;adding avg bitrate %u&quot;, parse-&gt;priv-&gt;avg_bitrate);
 978       gst_tag_list_add (merged_tags, GST_TAG_MERGE_KEEP,
 979           GST_TAG_BITRATE, parse-&gt;priv-&gt;avg_bitrate, NULL);
 980     }
 981   }
 982 
 983   parse-&gt;priv-&gt;pending_events =
 984       g_list_prepend (parse-&gt;priv-&gt;pending_events,
 985       gst_event_new_tag (merged_tags));
 986 }
 987 
 988 /* gst_base_parse_parse_frame:
 989  * @parse: #GstBaseParse.
 990  * @buffer: #GstBuffer.
 991  *
 992  * Default callback for parse_frame.
 993  */
 994 static GstFlowReturn
 995 gst_base_parse_parse_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
 996 {
 997   GstBuffer *buffer = frame-&gt;buffer;
 998 
 999   if (!GST_BUFFER_PTS_IS_VALID (buffer) &amp;&amp;
1000       GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;next_pts)) {
1001     GST_BUFFER_PTS (buffer) = parse-&gt;priv-&gt;next_pts;
1002   }
1003   if (!GST_BUFFER_DTS_IS_VALID (buffer) &amp;&amp;
1004       GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;next_dts)) {
1005     GST_BUFFER_DTS (buffer) = parse-&gt;priv-&gt;next_dts;
1006   }
1007   if (!GST_BUFFER_DURATION_IS_VALID (buffer) &amp;&amp;
1008       GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;frame_duration)) {
1009     GST_BUFFER_DURATION (buffer) = parse-&gt;priv-&gt;frame_duration;
1010   }
1011   return GST_FLOW_OK;
1012 }
1013 
1014 /* gst_base_parse_convert:
1015  * @parse: #GstBaseParse.
1016  * @src_format: #GstFormat describing the source format.
1017  * @src_value: Source value to be converted.
1018  * @dest_format: #GstFormat defining the converted format.
1019  * @dest_value: Pointer where the conversion result will be put.
1020  *
1021  * Converts using configured &quot;convert&quot; vmethod in #GstBaseParse class.
1022  *
1023  * Returns: %TRUE if conversion was successful.
1024  */
1025 static gboolean
1026 gst_base_parse_convert (GstBaseParse * parse,
1027     GstFormat src_format,
1028     gint64 src_value, GstFormat dest_format, gint64 * dest_value)
1029 {
1030   GstBaseParseClass *klass = GST_BASE_PARSE_GET_CLASS (parse);
1031   gboolean ret;
1032 
1033   g_return_val_if_fail (dest_value != NULL, FALSE);
1034 
1035   if (!klass-&gt;convert)
1036     return FALSE;
1037 
1038   ret = klass-&gt;convert (parse, src_format, src_value, dest_format, dest_value);
1039 
1040 #ifndef GST_DISABLE_GST_DEBUG
1041   {
1042     if (ret) {
1043       if (src_format == GST_FORMAT_TIME &amp;&amp; dest_format == GST_FORMAT_BYTES) {
1044         GST_LOG_OBJECT (parse,
1045             &quot;TIME -&gt; BYTES: %&quot; GST_TIME_FORMAT &quot; -&gt; %&quot; G_GINT64_FORMAT,
1046             GST_TIME_ARGS (src_value), *dest_value);
1047       } else if (dest_format == GST_FORMAT_TIME &amp;&amp;
1048           src_format == GST_FORMAT_BYTES) {
1049         GST_LOG_OBJECT (parse,
1050             &quot;BYTES -&gt; TIME: %&quot; G_GINT64_FORMAT &quot; -&gt; %&quot; GST_TIME_FORMAT,
1051             src_value, GST_TIME_ARGS (*dest_value));
1052       } else {
1053         GST_LOG_OBJECT (parse,
1054             &quot;%s -&gt; %s: %&quot; G_GINT64_FORMAT &quot; -&gt; %&quot; G_GINT64_FORMAT,
1055             GST_STR_NULL (gst_format_get_name (src_format)),
1056             GST_STR_NULL (gst_format_get_name (dest_format)),
1057             src_value, *dest_value);
1058       }
1059     } else {
1060       GST_DEBUG_OBJECT (parse, &quot;conversion failed&quot;);
1061     }
1062   }
1063 #endif
1064 
1065   return ret;
1066 }
1067 
1068 static gboolean
1069 update_upstream_provided (GQuark field_id, const GValue * value,
1070     gpointer user_data)
1071 {
1072   GstCaps *default_caps = user_data;
1073   gint i;
1074   gint caps_size;
1075 
1076   caps_size = gst_caps_get_size (default_caps);
1077   for (i = 0; i &lt; caps_size; i++) {
1078     GstStructure *structure = gst_caps_get_structure (default_caps, i);
1079     if (gst_structure_id_has_field (structure, field_id))
1080       gst_structure_id_set_value (structure, field_id, value);
1081   }
1082 
1083   return TRUE;
1084 }
1085 
1086 static GstCaps *
1087 gst_base_parse_negotiate_default_caps (GstBaseParse * parse)
1088 {
1089   GstCaps *caps, *templcaps;
1090   GstCaps *sinkcaps = NULL;
1091   GstCaps *default_caps = NULL;
1092   GstStructure *structure;
1093 
1094   templcaps = gst_pad_get_pad_template_caps (GST_BASE_PARSE_SRC_PAD (parse));
1095   caps = gst_pad_peer_query_caps (GST_BASE_PARSE_SRC_PAD (parse), templcaps);
1096   if (caps)
1097     gst_caps_unref (templcaps);
1098   else
1099     caps = templcaps;
1100   templcaps = NULL;
1101 
1102   if (!caps || gst_caps_is_empty (caps) || gst_caps_is_any (caps)) {
1103     goto caps_error;
1104   }
1105 
1106   GST_LOG_OBJECT (parse, &quot;peer caps  %&quot; GST_PTR_FORMAT, caps);
1107 
1108   /* before fixating, try to use whatever upstream provided */
1109   default_caps = gst_caps_copy (caps);
1110   sinkcaps = gst_pad_get_current_caps (GST_BASE_PARSE_SINK_PAD (parse));
1111 
1112   GST_LOG_OBJECT (parse, &quot;current caps %&quot; GST_PTR_FORMAT &quot; for sinkpad&quot;,
1113       sinkcaps);
1114 
1115   if (sinkcaps) {
1116     structure = gst_caps_get_structure (sinkcaps, 0);
1117     gst_structure_foreach (structure, update_upstream_provided, default_caps);
1118   }
1119 
1120   default_caps = gst_caps_fixate (default_caps);
1121 
1122   if (!default_caps) {
1123     GST_WARNING_OBJECT (parse, &quot;Failed to create default caps !&quot;);
1124     goto caps_error;
1125   }
1126 
1127   GST_INFO_OBJECT (parse,
1128       &quot;Chose default caps %&quot; GST_PTR_FORMAT &quot; for initial gap&quot;, default_caps);
1129 
1130   if (sinkcaps)
1131     gst_caps_unref (sinkcaps);
1132   gst_caps_unref (caps);
1133 
1134   return default_caps;
1135 
1136 caps_error:
1137   {
1138     if (caps)
1139       gst_caps_unref (caps);
1140     if (sinkcaps)
1141       gst_caps_unref (sinkcaps);
1142     return NULL;
1143   }
1144 }
1145 
1146 /* gst_base_parse_sink_event:
1147  * @pad: #GstPad that received the event.
1148  * @event: #GstEvent to be handled.
1149  *
1150  * Handler for sink pad events.
1151  *
1152  * Returns: %TRUE if the event was handled.
1153  */
1154 static gboolean
1155 gst_base_parse_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
1156 {
1157   GstBaseParse *parse = GST_BASE_PARSE (parent);
1158   GstBaseParseClass *bclass = GST_BASE_PARSE_GET_CLASS (parse);
1159   gboolean ret;
1160 
1161   ret = bclass-&gt;sink_event (parse, event);
1162 
1163   return ret;
1164 }
1165 
1166 /* gst_base_parse_sink_event_default:
1167  * @parse: #GstBaseParse.
1168  * @event: #GstEvent to be handled.
1169  *
1170  * Element-level event handler function.
1171  *
1172  * The event will be unreffed only if it has been handled and this
1173  * function returns %TRUE
1174  *
1175  * Returns: %TRUE if the event was handled and not need forwarding.
1176  */
1177 static gboolean
1178 gst_base_parse_sink_event_default (GstBaseParse * parse, GstEvent * event)
1179 {
1180   GstBaseParseClass *klass = GST_BASE_PARSE_GET_CLASS (parse);
1181   gboolean ret = FALSE;
1182   gboolean forward_immediate = FALSE;
1183 
1184   GST_DEBUG_OBJECT (parse, &quot;handling event %d, %s&quot;, GST_EVENT_TYPE (event),
1185       GST_EVENT_TYPE_NAME (event));
1186 
1187   switch (GST_EVENT_TYPE (event)) {
1188     case GST_EVENT_CAPS:
1189     {
1190       GstCaps *caps;
1191 
1192       gst_event_parse_caps (event, &amp;caps);
1193       GST_DEBUG_OBJECT (parse, &quot;caps: %&quot; GST_PTR_FORMAT, caps);
1194 
1195       if (klass-&gt;set_sink_caps)
1196         ret = klass-&gt;set_sink_caps (parse, caps);
1197       else
1198         ret = TRUE;
1199 
1200       /* will send our own caps downstream */
1201       gst_event_unref (event);
1202       event = NULL;
1203       break;
1204     }
1205     case GST_EVENT_SEGMENT:
1206     {
1207       const GstSegment *in_segment;
1208       GstSegment out_segment;
1209       gint64 offset = 0, next_dts;
1210 
1211       parse-&gt;priv-&gt;segment_seqnum = gst_event_get_seqnum (event);
1212       gst_event_parse_segment (event, &amp;in_segment);
1213       gst_segment_init (&amp;out_segment, GST_FORMAT_TIME);
1214       out_segment.rate = in_segment-&gt;rate;
1215       out_segment.applied_rate = in_segment-&gt;applied_rate;
1216 
1217       GST_DEBUG_OBJECT (parse, &quot;New segment %&quot; GST_SEGMENT_FORMAT, in_segment);
1218       GST_DEBUG_OBJECT (parse, &quot;Current segment %&quot; GST_SEGMENT_FORMAT,
1219           &amp;parse-&gt;segment);
1220 
1221       parse-&gt;priv-&gt;upstream_format = in_segment-&gt;format;
1222       if (in_segment-&gt;format == GST_FORMAT_BYTES) {
1223         GstBaseParseSeek *seek = NULL;
1224         GSList *node;
1225 
1226         /* stop time is allowed to be open-ended, but not start &amp; pos */
1227         offset = in_segment-&gt;time;
1228 
1229         GST_OBJECT_LOCK (parse);
1230         for (node = parse-&gt;priv-&gt;pending_seeks; node; node = node-&gt;next) {
1231           GstBaseParseSeek *tmp = node-&gt;data;
1232 
1233           if (tmp-&gt;offset == offset) {
1234             seek = tmp;
1235             break;
1236           }
1237         }
1238         parse-&gt;priv-&gt;pending_seeks =
1239             g_slist_remove (parse-&gt;priv-&gt;pending_seeks, seek);
1240         GST_OBJECT_UNLOCK (parse);
1241 
1242         if (seek) {
1243           GST_DEBUG_OBJECT (parse,
1244               &quot;Matched newsegment to%s seek: %&quot; GST_SEGMENT_FORMAT,
1245               seek-&gt;accurate ? &quot; accurate&quot; : &quot;&quot;, &amp;seek-&gt;segment);
1246 
1247           out_segment.start = seek-&gt;segment.start;
1248           out_segment.stop = seek-&gt;segment.stop;
1249           out_segment.time = seek-&gt;segment.start;
1250 
1251           next_dts = seek-&gt;start_ts;
1252           parse-&gt;priv-&gt;exact_position = seek-&gt;accurate;
1253           g_free (seek);
1254         } else {
1255           /* best attempt convert */
1256           /* as these are only estimates, stop is kept open-ended to avoid
1257            * premature cutting */
1258           gst_base_parse_convert (parse, GST_FORMAT_BYTES, in_segment-&gt;start,
1259               GST_FORMAT_TIME, (gint64 *) &amp; next_dts);
1260 
1261           out_segment.start = next_dts;
1262           out_segment.stop = GST_CLOCK_TIME_NONE;
1263           out_segment.time = next_dts;
1264 
1265           parse-&gt;priv-&gt;exact_position = (in_segment-&gt;start == 0);
1266         }
1267 
1268         gst_event_unref (event);
1269 
1270         event = gst_event_new_segment (&amp;out_segment);
1271         gst_event_set_seqnum (event, parse-&gt;priv-&gt;segment_seqnum);
1272 
1273         GST_DEBUG_OBJECT (parse, &quot;Converted incoming segment to TIME. %&quot;
1274             GST_SEGMENT_FORMAT, in_segment);
1275 
1276       } else if (in_segment-&gt;format != GST_FORMAT_TIME) {
1277         /* Unknown incoming segment format. Output a default open-ended
1278          * TIME segment */
1279         gst_event_unref (event);
1280 
1281         out_segment.start = 0;
1282         out_segment.stop = GST_CLOCK_TIME_NONE;
1283         out_segment.time = 0;
1284 
1285         event = gst_event_new_segment (&amp;out_segment);
1286         gst_event_set_seqnum (event, parse-&gt;priv-&gt;segment_seqnum);
1287 
1288         next_dts = 0;
1289       } else {
1290         /* not considered BYTE seekable if it is talking to us in TIME,
1291          * whatever else it might claim */
1292         parse-&gt;priv-&gt;upstream_seekable = FALSE;
1293         next_dts = in_segment-&gt;start;
1294         gst_event_copy_segment (event, &amp;out_segment);
1295       }
1296 
1297       GST_DEBUG_OBJECT (parse, &quot;OUT segment %&quot; GST_SEGMENT_FORMAT,
1298           &amp;out_segment);
1299       memcpy (&amp;parse-&gt;segment, &amp;out_segment, sizeof (GstSegment));
1300 
1301       /*
1302          gst_segment_set_newsegment (&amp;parse-&gt;segment, update, rate,
1303          applied_rate, format, start, stop, start);
1304        */
1305 
1306       ret = TRUE;
1307 
1308       /* save the segment for later, right before we push a new buffer so that
1309        * the caps are fixed and the next linked element can receive
1310        * the segment but finish the current segment */
1311       GST_DEBUG_OBJECT (parse, &quot;draining current segment&quot;);
1312       if (in_segment-&gt;rate &gt; 0.0)
1313         gst_base_parse_drain (parse);
1314       else
1315         gst_base_parse_finish_fragment (parse, FALSE);
1316       gst_adapter_clear (parse-&gt;priv-&gt;adapter);
1317 
1318       parse-&gt;priv-&gt;offset = offset;
1319       parse-&gt;priv-&gt;sync_offset = offset;
1320       parse-&gt;priv-&gt;next_dts = next_dts;
1321       parse-&gt;priv-&gt;next_pts = GST_CLOCK_TIME_NONE;
1322       parse-&gt;priv-&gt;last_pts = GST_CLOCK_TIME_NONE;
1323       parse-&gt;priv-&gt;last_dts = GST_CLOCK_TIME_NONE;
1324       parse-&gt;priv-&gt;prev_pts = GST_CLOCK_TIME_NONE;
1325       parse-&gt;priv-&gt;prev_dts = GST_CLOCK_TIME_NONE;
1326       parse-&gt;priv-&gt;prev_dts_from_pts = FALSE;
1327       parse-&gt;priv-&gt;discont = TRUE;
1328       parse-&gt;priv-&gt;seen_keyframe = FALSE;
1329       parse-&gt;priv-&gt;skip = 0;
1330       break;
1331     }
1332 
1333     case GST_EVENT_SEGMENT_DONE:
1334       /* need to drain now, rather than upon a new segment,
1335        * since that would have SEGMENT_DONE come before potential
1336        * delayed last part of the current segment */
1337       GST_DEBUG_OBJECT (parse, &quot;draining current segment&quot;);
1338       if (parse-&gt;segment.rate &gt; 0.0)
1339         gst_base_parse_drain (parse);
1340       else
1341         gst_base_parse_finish_fragment (parse, FALSE);
1342       /* Also forward event immediately, there might be no new data
1343        * coming afterwards that would allow us to forward it later */
1344       forward_immediate = TRUE;
1345       break;
1346 
1347     case GST_EVENT_FLUSH_START:
1348       GST_OBJECT_LOCK (parse);
1349       parse-&gt;priv-&gt;flushing = TRUE;
1350       GST_OBJECT_UNLOCK (parse);
1351       break;
1352 
1353     case GST_EVENT_FLUSH_STOP:
1354       gst_adapter_clear (parse-&gt;priv-&gt;adapter);
1355       gst_base_parse_clear_queues (parse);
1356       parse-&gt;priv-&gt;flushing = FALSE;
1357       parse-&gt;priv-&gt;discont = TRUE;
1358       parse-&gt;priv-&gt;last_pts = GST_CLOCK_TIME_NONE;
1359       parse-&gt;priv-&gt;last_dts = GST_CLOCK_TIME_NONE;
1360       parse-&gt;priv-&gt;new_frame = TRUE;
1361       parse-&gt;priv-&gt;skip = 0;
1362 
1363       forward_immediate = TRUE;
1364       break;
1365 
1366     case GST_EVENT_EOS:
1367       if (parse-&gt;segment.rate &gt; 0.0)
1368         gst_base_parse_drain (parse);
1369       else
1370         gst_base_parse_finish_fragment (parse, TRUE);
1371 
1372       /* If we STILL have zero frames processed, fire an error */
1373       if (parse-&gt;priv-&gt;framecount == 0 &amp;&amp; !parse-&gt;priv-&gt;saw_gaps &amp;&amp;
1374           !parse-&gt;priv-&gt;first_buffer) {
1375         GST_ELEMENT_ERROR (parse, STREAM, WRONG_TYPE,
1376             (&quot;No valid frames found before end of stream&quot;), (NULL));
1377       }
1378 
1379       if (!parse-&gt;priv-&gt;saw_gaps
1380           &amp;&amp; parse-&gt;priv-&gt;framecount &lt; MIN_FRAMES_TO_POST_BITRATE) {
1381         /* We&#39;ve not posted bitrate tags yet - do so now */
1382         gst_base_parse_queue_tag_event_update (parse);
1383       }
1384 
1385       /* newsegment and other serialized events before eos */
1386       gst_base_parse_push_pending_events (parse);
1387 
1388       forward_immediate = TRUE;
1389       break;
1390     case GST_EVENT_CUSTOM_DOWNSTREAM:{
1391       /* FIXME: Code duplicated from libgstvideo because core can&#39;t depend on -base */
1392 #ifndef GST_VIDEO_EVENT_STILL_STATE_NAME
1393 #define GST_VIDEO_EVENT_STILL_STATE_NAME &quot;GstEventStillFrame&quot;
1394 #endif
1395 
1396       const GstStructure *s;
1397       gboolean ev_still_state;
1398 
1399       s = gst_event_get_structure (event);
1400       if (s != NULL &amp;&amp;
1401           gst_structure_has_name (s, GST_VIDEO_EVENT_STILL_STATE_NAME) &amp;&amp;
1402           gst_structure_get_boolean (s, &quot;still-state&quot;, &amp;ev_still_state)) {
1403         if (ev_still_state) {
1404           GST_DEBUG_OBJECT (parse, &quot;draining current data for still-frame&quot;);
1405           if (parse-&gt;segment.rate &gt; 0.0)
1406             gst_base_parse_drain (parse);
1407           else
1408             gst_base_parse_finish_fragment (parse, TRUE);
1409         }
1410         forward_immediate = TRUE;
1411       }
1412       break;
1413     }
1414     case GST_EVENT_GAP:
1415     {
1416       GST_DEBUG_OBJECT (parse, &quot;draining current data due to gap event&quot;);
1417 
1418       /* Ensure we have caps before forwarding the event */
1419       if (!gst_pad_has_current_caps (GST_BASE_PARSE_SRC_PAD (parse))) {
1420         GstCaps *default_caps = NULL;
1421         if ((default_caps = gst_base_parse_negotiate_default_caps (parse))) {
1422           GList *l;
1423           GstEvent *caps_event = gst_event_new_caps (default_caps);
1424 
1425           GST_DEBUG_OBJECT (parse,
1426               &quot;Store caps event to pending list for initial pre-rolling&quot;);
1427 
1428           /* Events are in decreasing order. Go down the list until we
1429            * find the first pre-CAPS event and insert our CAPS event there.
1430            *
1431            * There should be a SEGMENT event already, which is &gt; CAPS */
1432           for (l = parse-&gt;priv-&gt;pending_events; l; l = l-&gt;next) {
1433             GstEvent *e = l-&gt;data;
1434 
1435             if (GST_EVENT_TYPE (e) &lt; GST_EVENT_CAPS) {
1436               parse-&gt;priv-&gt;pending_events =
1437                   g_list_insert_before (parse-&gt;priv-&gt;pending_events, l,
1438                   caps_event);
1439               break;
1440             }
1441           }
1442           /* No pending event that is &lt; CAPS, so we have to add it at the very
1443            * end of the list */
1444           if (!l) {
1445             parse-&gt;priv-&gt;pending_events =
1446                 g_list_append (parse-&gt;priv-&gt;pending_events, caps_event);
1447           }
1448           gst_caps_unref (default_caps);
1449         } else {
1450           gst_event_unref (event);
1451           event = NULL;
1452           ret = FALSE;
1453           GST_ELEMENT_ERROR (parse, STREAM, FORMAT, (NULL),
1454               (&quot;Parser output not negotiated before GAP event.&quot;));
1455           break;
1456         }
1457       }
1458 
1459       gst_base_parse_push_pending_events (parse);
1460 
1461       if (parse-&gt;segment.rate &gt; 0.0)
1462         gst_base_parse_drain (parse);
1463       else
1464         gst_base_parse_finish_fragment (parse, TRUE);
1465       forward_immediate = TRUE;
1466       parse-&gt;priv-&gt;saw_gaps = TRUE;
1467       break;
1468     }
1469     case GST_EVENT_TAG:
1470     {
1471       GstTagList *tags = NULL;
1472 
1473       gst_event_parse_tag (event, &amp;tags);
1474 
1475       /* We only care about stream tags here, global tags we just forward */
1476       if (gst_tag_list_get_scope (tags) != GST_TAG_SCOPE_STREAM)
1477         break;
1478 
1479       gst_base_parse_set_upstream_tags (parse, tags);
1480       gst_base_parse_queue_tag_event_update (parse);
1481       parse-&gt;priv-&gt;tags_changed = FALSE;
1482       gst_event_unref (event);
1483       event = NULL;
1484       ret = TRUE;
1485       break;
1486     }
1487     case GST_EVENT_STREAM_START:
1488     {
1489       if (parse-&gt;priv-&gt;pad_mode != GST_PAD_MODE_PULL)
1490         forward_immediate = TRUE;
1491 
1492       gst_base_parse_set_upstream_tags (parse, NULL);
1493       parse-&gt;priv-&gt;tags_changed = TRUE;
1494       break;
1495     }
1496     default:
1497       break;
1498   }
1499 
1500   /* Forward non-serialized events and EOS/FLUSH_STOP immediately.
1501    * For EOS this is required because no buffer or serialized event
1502    * will come after EOS and nothing could trigger another
1503    * _finish_frame() call.   *
1504    * If the subclass handles sending of EOS manually it can return
1505    * _DROPPED from ::finish() and all other subclasses should have
1506    * decoded/flushed all remaining data before this
1507    *
1508    * For FLUSH_STOP this is required because it is expected
1509    * to be forwarded immediately and no buffers are queued anyway.
1510    */
1511   if (event) {
1512     if (!GST_EVENT_IS_SERIALIZED (event) || forward_immediate) {
1513       ret = gst_pad_push_event (parse-&gt;srcpad, event);
1514     } else {
1515       parse-&gt;priv-&gt;pending_events =
1516           g_list_prepend (parse-&gt;priv-&gt;pending_events, event);
1517       ret = TRUE;
1518     }
1519   }
1520 
1521   GST_DEBUG_OBJECT (parse, &quot;event handled&quot;);
1522 
1523   return ret;
1524 }
1525 
1526 static gboolean
1527 gst_base_parse_sink_query_default (GstBaseParse * parse, GstQuery * query)
1528 {
1529   GstPad *pad;
1530   gboolean res;
1531 
1532   pad = GST_BASE_PARSE_SINK_PAD (parse);
1533 
1534   switch (GST_QUERY_TYPE (query)) {
1535     case GST_QUERY_CAPS:
1536     {
1537       GstBaseParseClass *bclass;
1538 
1539       bclass = GST_BASE_PARSE_GET_CLASS (parse);
1540 
1541       if (bclass-&gt;get_sink_caps) {
1542         GstCaps *caps, *filter;
1543 
1544         gst_query_parse_caps (query, &amp;filter);
1545         caps = bclass-&gt;get_sink_caps (parse, filter);
1546         GST_LOG_OBJECT (parse, &quot;sink getcaps returning caps %&quot; GST_PTR_FORMAT,
1547             caps);
1548         gst_query_set_caps_result (query, caps);
1549         gst_caps_unref (caps);
1550 
1551         res = TRUE;
1552       } else {
1553         GstCaps *caps, *template_caps, *filter;
1554 
1555         gst_query_parse_caps (query, &amp;filter);
1556         template_caps = gst_pad_get_pad_template_caps (pad);
1557         if (filter != NULL) {
1558           caps =
1559               gst_caps_intersect_full (filter, template_caps,
1560               GST_CAPS_INTERSECT_FIRST);
1561           gst_caps_unref (template_caps);
1562         } else {
1563           caps = template_caps;
1564         }
1565         gst_query_set_caps_result (query, caps);
1566         gst_caps_unref (caps);
1567 
1568         res = TRUE;
1569       }
1570       break;
1571     }
1572     default:
1573     {
1574       res = gst_pad_query_default (pad, GST_OBJECT_CAST (parse), query);
1575       break;
1576     }
1577   }
1578 
1579   return res;
1580 }
1581 
1582 static gboolean
1583 gst_base_parse_sink_query (GstPad * pad, GstObject * parent, GstQuery * query)
1584 {
1585   GstBaseParseClass *bclass;
1586   GstBaseParse *parse;
1587   gboolean ret;
1588 
1589   parse = GST_BASE_PARSE (parent);
1590   bclass = GST_BASE_PARSE_GET_CLASS (parse);
1591 
1592   GST_DEBUG_OBJECT (parse, &quot;%s query&quot;, GST_QUERY_TYPE_NAME (query));
1593 
1594   if (bclass-&gt;sink_query)
1595     ret = bclass-&gt;sink_query (parse, query);
1596   else
1597     ret = FALSE;
1598 
1599   GST_LOG_OBJECT (parse, &quot;%s query result: %d %&quot; GST_PTR_FORMAT,
1600       GST_QUERY_TYPE_NAME (query), ret, query);
1601 
1602   return ret;
1603 }
1604 
1605 static gboolean
1606 gst_base_parse_src_query (GstPad * pad, GstObject * parent, GstQuery * query)
1607 {
1608   GstBaseParseClass *bclass;
1609   GstBaseParse *parse;
1610   gboolean ret;
1611 
1612   parse = GST_BASE_PARSE (parent);
1613   bclass = GST_BASE_PARSE_GET_CLASS (parse);
1614 
1615   GST_DEBUG_OBJECT (parse, &quot;%s query: %&quot; GST_PTR_FORMAT,
1616       GST_QUERY_TYPE_NAME (query), query);
1617 
1618   if (bclass-&gt;src_query)
1619     ret = bclass-&gt;src_query (parse, query);
1620   else
1621     ret = FALSE;
1622 
1623   GST_LOG_OBJECT (parse, &quot;%s query result: %d %&quot; GST_PTR_FORMAT,
1624       GST_QUERY_TYPE_NAME (query), ret, query);
1625 
1626   return ret;
1627 }
1628 
1629 /* gst_base_parse_src_event:
1630  * @pad: #GstPad that received the event.
1631  * @event: #GstEvent that was received.
1632  *
1633  * Handler for source pad events.
1634  *
1635  * Returns: %TRUE if the event was handled.
1636  */
1637 static gboolean
1638 gst_base_parse_src_event (GstPad * pad, GstObject * parent, GstEvent * event)
1639 {
1640   GstBaseParse *parse;
1641   GstBaseParseClass *bclass;
1642   gboolean ret = TRUE;
1643 
1644   parse = GST_BASE_PARSE (parent);
1645   bclass = GST_BASE_PARSE_GET_CLASS (parse);
1646 
1647   GST_DEBUG_OBJECT (parse, &quot;event %d, %s&quot;, GST_EVENT_TYPE (event),
1648       GST_EVENT_TYPE_NAME (event));
1649 
1650   if (bclass-&gt;src_event)
1651     ret = bclass-&gt;src_event (parse, event);
1652   else
1653     gst_event_unref (event);
1654 
1655   return ret;
1656 }
1657 
1658 static gboolean
1659 gst_base_parse_is_seekable (GstBaseParse * parse)
1660 {
1661   /* FIXME: could do more here, e.g. check index or just send data from 0
1662    * in pull mode and let decoder/sink clip */
1663   return parse-&gt;priv-&gt;syncable;
1664 }
1665 
1666 /* gst_base_parse_src_event_default:
1667  * @parse: #GstBaseParse.
1668  * @event: #GstEvent that was received.
1669  *
1670  * Default srcpad event handler.
1671  *
1672  * Returns: %TRUE if the event was handled and can be dropped.
1673  */
1674 static gboolean
1675 gst_base_parse_src_event_default (GstBaseParse * parse, GstEvent * event)
1676 {
1677   gboolean res = FALSE;
1678 
1679   switch (GST_EVENT_TYPE (event)) {
1680     case GST_EVENT_SEEK:
1681       if (gst_base_parse_is_seekable (parse))
1682         res = gst_base_parse_handle_seek (parse, event);
1683       break;
1684     default:
1685       res = gst_pad_event_default (parse-&gt;srcpad, GST_OBJECT_CAST (parse),
1686           event);
1687       break;
1688   }
1689   return res;
1690 }
1691 
1692 
1693 /**
1694  * gst_base_parse_convert_default:
1695  * @parse: #GstBaseParse.
1696  * @src_format: #GstFormat describing the source format.
1697  * @src_value: Source value to be converted.
1698  * @dest_format: #GstFormat defining the converted format.
1699  * @dest_value: (out): Pointer where the conversion result will be put.
1700  *
1701  * Default implementation of #GstBaseParseClass.convert().
1702  *
1703  * Returns: %TRUE if conversion was successful.
1704  */
1705 gboolean
1706 gst_base_parse_convert_default (GstBaseParse * parse,
1707     GstFormat src_format,
1708     gint64 src_value, GstFormat dest_format, gint64 * dest_value)
1709 {
1710   gboolean ret = FALSE;
1711   guint64 bytes, duration;
1712 
1713   if (G_UNLIKELY (src_format == dest_format)) {
1714     *dest_value = src_value;
1715     return TRUE;
1716   }
1717 
1718   if (G_UNLIKELY (src_value == -1)) {
1719     *dest_value = -1;
1720     return TRUE;
1721   }
1722 
1723   if (G_UNLIKELY (src_value == 0)) {
1724     *dest_value = 0;
1725     return TRUE;
1726   }
1727 
1728   if (parse-&gt;priv-&gt;upstream_format != GST_FORMAT_BYTES) {
1729     /* don&#39;t do byte format conversions if we&#39;re not really parsing
1730      * a raw elementary stream, since we don&#39;t really have BYTES
1731      * position / duration info */
1732     if (src_format == GST_FORMAT_BYTES || dest_format == GST_FORMAT_BYTES)
1733       goto no_slaved_conversions;
1734   }
1735 
1736   /* need at least some frames */
1737   if (!parse-&gt;priv-&gt;framecount)
1738     goto no_framecount;
1739 
1740   duration = parse-&gt;priv-&gt;acc_duration / GST_MSECOND;
1741   bytes = parse-&gt;priv-&gt;bytecount;
1742 
1743   if (G_UNLIKELY (!duration || !bytes))
1744     goto no_duration_bytes;
1745 
1746   if (src_format == GST_FORMAT_BYTES) {
1747     if (dest_format == GST_FORMAT_TIME) {
1748       /* BYTES -&gt; TIME conversion */
1749       GST_DEBUG_OBJECT (parse, &quot;converting bytes -&gt; time&quot;);
1750       *dest_value = gst_util_uint64_scale (src_value, duration, bytes);
1751       *dest_value *= GST_MSECOND;
1752       GST_DEBUG_OBJECT (parse, &quot;conversion result: %&quot; G_GINT64_FORMAT &quot; ms&quot;,
1753           *dest_value / GST_MSECOND);
1754       ret = TRUE;
1755     } else {
1756       GST_DEBUG_OBJECT (parse, &quot;converting bytes -&gt; other not implemented&quot;);
1757     }
1758   } else if (src_format == GST_FORMAT_TIME) {
1759     if (dest_format == GST_FORMAT_BYTES) {
1760       GST_DEBUG_OBJECT (parse, &quot;converting time -&gt; bytes&quot;);
1761       *dest_value = gst_util_uint64_scale (src_value / GST_MSECOND, bytes,
1762           duration);
1763       GST_DEBUG_OBJECT (parse,
1764           &quot;time %&quot; G_GINT64_FORMAT &quot; ms in bytes = %&quot; G_GINT64_FORMAT,
1765           src_value / GST_MSECOND, *dest_value);
1766       ret = TRUE;
1767     } else {
1768       GST_DEBUG_OBJECT (parse, &quot;converting time -&gt; other not implemented&quot;);
1769     }
1770   } else if (src_format == GST_FORMAT_DEFAULT) {
1771     /* DEFAULT == frame-based */
1772     if (dest_format == GST_FORMAT_TIME) {
1773       GST_DEBUG_OBJECT (parse, &quot;converting default -&gt; time&quot;);
1774       if (parse-&gt;priv-&gt;fps_den) {
1775         *dest_value = gst_util_uint64_scale (src_value,
1776             GST_SECOND * parse-&gt;priv-&gt;fps_den, parse-&gt;priv-&gt;fps_num);
1777         ret = TRUE;
1778       }
1779     } else {
1780       GST_DEBUG_OBJECT (parse, &quot;converting default -&gt; other not implemented&quot;);
1781     }
1782   } else {
1783     GST_DEBUG_OBJECT (parse, &quot;conversion not implemented&quot;);
1784   }
1785   return ret;
1786 
1787   /* ERRORS */
1788 no_framecount:
1789   {
1790     GST_DEBUG_OBJECT (parse, &quot;no framecount&quot;);
1791     return FALSE;
1792   }
1793 no_duration_bytes:
1794   {
1795     GST_DEBUG_OBJECT (parse, &quot;no duration %&quot; G_GUINT64_FORMAT &quot;, bytes %&quot;
1796         G_GUINT64_FORMAT, duration, bytes);
1797     return FALSE;
1798   }
1799 no_slaved_conversions:
1800   {
1801     GST_DEBUG_OBJECT (parse,
1802         &quot;Can&#39;t do format conversions when upstream format is not BYTES&quot;);
1803     return FALSE;
1804   }
1805 }
1806 
1807 static void
1808 gst_base_parse_update_duration (GstBaseParse * parse)
1809 {
1810   gint64 ptot, dest_value;
1811 
1812   if (!gst_pad_peer_query_duration (parse-&gt;sinkpad, GST_FORMAT_BYTES, &amp;ptot))
1813     return;
1814 
1815   if (!gst_base_parse_convert (parse, GST_FORMAT_BYTES, ptot,
1816           GST_FORMAT_TIME, &amp;dest_value))
1817     return;
1818 
1819   /* inform if duration changed, but try to avoid spamming */
1820   parse-&gt;priv-&gt;estimated_drift += dest_value - parse-&gt;priv-&gt;estimated_duration;
1821 
1822   parse-&gt;priv-&gt;estimated_duration = dest_value;
1823   GST_LOG_OBJECT (parse,
1824       &quot;updated estimated duration to %&quot; GST_TIME_FORMAT,
1825       GST_TIME_ARGS (dest_value));
1826 
1827   if (parse-&gt;priv-&gt;estimated_drift &gt; GST_SECOND ||
1828       parse-&gt;priv-&gt;estimated_drift &lt; -GST_SECOND) {
1829     gst_element_post_message (GST_ELEMENT (parse),
1830         gst_message_new_duration_changed (GST_OBJECT (parse)));
1831     parse-&gt;priv-&gt;estimated_drift = 0;
1832   }
1833 }
1834 
1835 /* gst_base_parse_update_bitrates:
1836  * @parse: #GstBaseParse.
1837  * @buffer: Current frame as a #GstBuffer
1838  *
1839  * Keeps track of the minimum and maximum bitrates, and also maintains a
1840  * running average bitrate of the stream so far.
1841  */
1842 static void
1843 gst_base_parse_update_bitrates (GstBaseParse * parse, GstBaseParseFrame * frame)
1844 {
1845   guint64 data_len, frame_dur;
1846   gint overhead;
1847   guint frame_bitrate;
1848   guint64 frame_bitrate64;
1849   GstBuffer *buffer = frame-&gt;buffer;
1850 
1851   overhead = frame-&gt;overhead;
1852   if (overhead == -1)
1853     return;
1854 
1855   data_len = gst_buffer_get_size (buffer) - overhead;
1856   parse-&gt;priv-&gt;data_bytecount += data_len;
1857 
1858   /* duration should be valid by now,
1859    * either set by subclass or maybe based on fps settings */
1860   if (GST_BUFFER_DURATION_IS_VALID (buffer) &amp;&amp; parse-&gt;priv-&gt;acc_duration != 0) {
1861     guint64 avg_bitrate;
1862 
1863     /* Calculate duration of a frame from buffer properties */
1864     frame_dur = GST_BUFFER_DURATION (buffer);
1865     avg_bitrate = gst_util_uint64_scale (GST_SECOND,
1866         8 * parse-&gt;priv-&gt;data_bytecount, parse-&gt;priv-&gt;acc_duration);
1867 
1868     if (avg_bitrate &gt; G_MAXUINT)
1869       return;
1870 
1871     parse-&gt;priv-&gt;avg_bitrate = (guint) avg_bitrate;
1872   } else {
1873     /* No way to figure out frame duration (is this even possible?) */
1874     return;
1875   }
1876 
1877   /* override if subclass provided bitrate, e.g. metadata based */
1878   if (parse-&gt;priv-&gt;bitrate) {
1879     parse-&gt;priv-&gt;avg_bitrate = parse-&gt;priv-&gt;bitrate;
1880     /* spread this (confirmed) info ASAP */
1881     if (parse-&gt;priv-&gt;post_avg_bitrate &amp;&amp;
1882         parse-&gt;priv-&gt;posted_avg_bitrate != parse-&gt;priv-&gt;avg_bitrate)
1883       parse-&gt;priv-&gt;tags_changed = TRUE;
1884   }
1885 
1886   if (!frame_dur)
1887     return;
1888 
1889   frame_bitrate64 = gst_util_uint64_scale (GST_SECOND, 8 * data_len, frame_dur);
1890 
1891   if (frame_bitrate64 &gt; G_MAXUINT)
1892     return;
1893 
1894   frame_bitrate = (guint) frame_bitrate64;
1895 
1896   GST_LOG_OBJECT (parse, &quot;frame bitrate %u, avg bitrate %u&quot;, frame_bitrate,
1897       parse-&gt;priv-&gt;avg_bitrate);
1898 
1899   if (parse-&gt;priv-&gt;framecount &lt; MIN_FRAMES_TO_POST_BITRATE)
1900     return;
1901 
1902   if (parse-&gt;priv-&gt;framecount == MIN_FRAMES_TO_POST_BITRATE &amp;&amp;
1903       (parse-&gt;priv-&gt;post_min_bitrate || parse-&gt;priv-&gt;post_avg_bitrate
1904           || parse-&gt;priv-&gt;post_max_bitrate))
1905     parse-&gt;priv-&gt;tags_changed = TRUE;
1906 
1907   if (G_LIKELY (parse-&gt;priv-&gt;framecount &gt;= MIN_FRAMES_TO_POST_BITRATE)) {
1908     if (frame_bitrate &lt; parse-&gt;priv-&gt;min_bitrate) {
1909       parse-&gt;priv-&gt;min_bitrate = frame_bitrate;
1910       if (parse-&gt;priv-&gt;post_min_bitrate)
1911         parse-&gt;priv-&gt;tags_changed = TRUE;
1912     }
1913 
1914     if (frame_bitrate &gt; parse-&gt;priv-&gt;max_bitrate) {
1915       parse-&gt;priv-&gt;max_bitrate = frame_bitrate;
1916       if (parse-&gt;priv-&gt;post_max_bitrate)
1917         parse-&gt;priv-&gt;tags_changed = TRUE;
1918     }
1919 
1920     /* Only update the tag on a 2% change */
1921     if (parse-&gt;priv-&gt;post_avg_bitrate &amp;&amp; parse-&gt;priv-&gt;avg_bitrate) {
1922       guint64 diffprev = gst_util_uint64_scale (100,
1923           ABSDIFF (parse-&gt;priv-&gt;avg_bitrate, parse-&gt;priv-&gt;posted_avg_bitrate),
1924           parse-&gt;priv-&gt;avg_bitrate);
1925       if (diffprev &gt;= UPDATE_THRESHOLD)
1926         parse-&gt;priv-&gt;tags_changed = TRUE;
1927     }
1928   }
1929 }
1930 
1931 /**
1932  * gst_base_parse_add_index_entry:
1933  * @parse: #GstBaseParse.
1934  * @offset: offset of entry
1935  * @ts: timestamp associated with offset
1936  * @key: whether entry refers to keyframe
1937  * @force: add entry disregarding sanity checks
1938  *
1939  * Adds an entry to the index associating @offset to @ts.  It is recommended
1940  * to only add keyframe entries.  @force allows to bypass checks, such as
1941  * whether the stream is (upstream) seekable, another entry is already &quot;close&quot;
1942  * to the new entry, etc.
1943  *
1944  * Returns: #gboolean indicating whether entry was added
1945  */
1946 gboolean
1947 gst_base_parse_add_index_entry (GstBaseParse * parse, guint64 offset,
1948     GstClockTime ts, gboolean key, gboolean force)
1949 {
1950   gboolean ret = FALSE;
1951   GstIndexAssociation associations[2];
1952 
1953   GST_LOG_OBJECT (parse, &quot;Adding key=%d index entry %&quot; GST_TIME_FORMAT
1954       &quot; @ offset 0x%08&quot; G_GINT64_MODIFIER &quot;x&quot;, key, GST_TIME_ARGS (ts), offset);
1955 
1956   if (G_LIKELY (!force)) {
1957 
1958     if (!parse-&gt;priv-&gt;upstream_seekable) {
1959       GST_DEBUG_OBJECT (parse, &quot;upstream not seekable; discarding&quot;);
1960       goto exit;
1961     }
1962 
1963     /* FIXME need better helper data structure that handles these issues
1964      * related to ongoing collecting of index entries */
1965     if (parse-&gt;priv-&gt;index_last_offset + parse-&gt;priv-&gt;idx_byte_interval &gt;=
1966         (gint64) offset) {
1967       GST_LOG_OBJECT (parse,
1968           &quot;already have entries up to offset 0x%08&quot; G_GINT64_MODIFIER &quot;x&quot;,
1969           parse-&gt;priv-&gt;index_last_offset + parse-&gt;priv-&gt;idx_byte_interval);
1970       goto exit;
1971     }
1972 
1973     if (GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;index_last_ts) &amp;&amp;
1974         GST_CLOCK_DIFF (parse-&gt;priv-&gt;index_last_ts, ts) &lt;
1975         parse-&gt;priv-&gt;idx_interval) {
1976       GST_LOG_OBJECT (parse, &quot;entry too close to last time %&quot; GST_TIME_FORMAT,
1977           GST_TIME_ARGS (parse-&gt;priv-&gt;index_last_ts));
1978       goto exit;
1979     }
1980 
1981     /* if last is not really the last one */
1982     if (!parse-&gt;priv-&gt;index_last_valid) {
1983       GstClockTime prev_ts;
1984 
1985       gst_base_parse_find_offset (parse, ts, TRUE, &amp;prev_ts);
1986       if (GST_CLOCK_DIFF (prev_ts, ts) &lt; parse-&gt;priv-&gt;idx_interval) {
1987         GST_LOG_OBJECT (parse,
1988             &quot;entry too close to existing entry %&quot; GST_TIME_FORMAT,
1989             GST_TIME_ARGS (prev_ts));
1990         parse-&gt;priv-&gt;index_last_offset = offset;
1991         parse-&gt;priv-&gt;index_last_ts = ts;
1992         goto exit;
1993       }
1994     }
1995   }
1996 
1997   associations[0].format = GST_FORMAT_TIME;
1998   associations[0].value = ts;
1999   associations[1].format = GST_FORMAT_BYTES;
2000   associations[1].value = offset;
2001 
2002   /* index might change on-the-fly, although that would be nutty app ... */
2003   GST_BASE_PARSE_INDEX_LOCK (parse);
2004   gst_index_add_associationv (parse-&gt;priv-&gt;index, parse-&gt;priv-&gt;index_id,
2005       (key) ? GST_INDEX_ASSOCIATION_FLAG_KEY_UNIT :
2006       GST_INDEX_ASSOCIATION_FLAG_DELTA_UNIT, 2,
2007       (const GstIndexAssociation *) &amp;associations);
2008   GST_BASE_PARSE_INDEX_UNLOCK (parse);
2009 
2010   if (key) {
2011     parse-&gt;priv-&gt;index_last_offset = offset;
2012     parse-&gt;priv-&gt;index_last_ts = ts;
2013   }
2014 
2015   ret = TRUE;
2016 
2017 exit:
2018   return ret;
2019 }
2020 
2021 /* check for seekable upstream, above and beyond a mere query */
2022 static void
2023 gst_base_parse_check_seekability (GstBaseParse * parse)
2024 {
2025   GstQuery *query;
2026   gboolean seekable = FALSE;
2027   gint64 start = -1, stop = -1;
2028   guint idx_interval = 0;
2029   guint64 idx_byte_interval = 0;
2030 
2031   query = gst_query_new_seeking (GST_FORMAT_BYTES);
2032   if (!gst_pad_peer_query (parse-&gt;sinkpad, query)) {
2033     GST_DEBUG_OBJECT (parse, &quot;seeking query failed&quot;);
2034     goto done;
2035   }
2036 
2037   gst_query_parse_seeking (query, NULL, &amp;seekable, &amp;start, &amp;stop);
2038 
2039   /* try harder to query upstream size if we didn&#39;t get it the first time */
2040   if (seekable &amp;&amp; stop == -1) {
2041     GST_DEBUG_OBJECT (parse, &quot;doing duration query to fix up unset stop&quot;);
2042     gst_pad_peer_query_duration (parse-&gt;sinkpad, GST_FORMAT_BYTES, &amp;stop);
2043   }
2044 
2045   /* if upstream doesn&#39;t know the size, it&#39;s likely that it&#39;s not seekable in
2046    * practice even if it technically may be seekable */
2047   if (seekable &amp;&amp; (start != 0 || stop &lt;= start)) {
2048     GST_DEBUG_OBJECT (parse, &quot;seekable but unknown start/stop -&gt; disable&quot;);
2049     seekable = FALSE;
2050   }
2051 
2052   /* let&#39;s not put every single frame into our index */
2053   if (seekable) {
2054     if (stop &lt; 10 * 1024 * 1024)
2055       idx_interval = 100;
2056     else if (stop &lt; 100 * 1024 * 1024)
2057       idx_interval = 500;
2058     else
2059       idx_interval = 1000;
2060 
2061     /* ensure that even for large files (e.g. very long audio files), the index
2062      * stays reasonably-size, with some arbitrary limit to the total number of
2063      * index entries */
2064     idx_byte_interval = (stop - start) / MAX_INDEX_ENTRIES;
2065     GST_DEBUG_OBJECT (parse,
2066         &quot;Limiting index entries to %d, indexing byte interval %&quot;
2067         G_GUINT64_FORMAT &quot; bytes&quot;, MAX_INDEX_ENTRIES, idx_byte_interval);
2068   }
2069 
2070 done:
2071   gst_query_unref (query);
2072 
2073   GST_DEBUG_OBJECT (parse, &quot;seekable: %d (%&quot; G_GUINT64_FORMAT &quot; - %&quot;
2074       G_GUINT64_FORMAT &quot;)&quot;, seekable, start, stop);
2075   parse-&gt;priv-&gt;upstream_seekable = seekable;
2076   parse-&gt;priv-&gt;upstream_size = seekable ? stop : 0;
2077 
2078   GST_DEBUG_OBJECT (parse, &quot;idx_interval: %ums&quot;, idx_interval);
2079   parse-&gt;priv-&gt;idx_interval = idx_interval * GST_MSECOND;
2080   parse-&gt;priv-&gt;idx_byte_interval = idx_byte_interval;
2081 }
2082 
2083 /* some misc checks on upstream */
2084 static void
2085 gst_base_parse_check_upstream (GstBaseParse * parse)
2086 {
2087   gint64 stop;
2088 
2089   if (gst_pad_peer_query_duration (parse-&gt;sinkpad, GST_FORMAT_TIME, &amp;stop))
2090     if (GST_CLOCK_TIME_IS_VALID (stop) &amp;&amp; stop) {
2091       /* upstream has one, accept it also, and no further updates */
2092       gst_base_parse_set_duration (parse, GST_FORMAT_TIME, stop, 0);
2093       parse-&gt;priv-&gt;upstream_has_duration = TRUE;
2094     }
2095 
2096   GST_DEBUG_OBJECT (parse, &quot;upstream_has_duration: %d&quot;,
2097       parse-&gt;priv-&gt;upstream_has_duration);
2098 }
2099 
2100 /* checks src caps to determine if dealing with audio or video */
2101 /* TODO maybe forego automagic stuff and let subclass configure it ? */
2102 static void
2103 gst_base_parse_check_media (GstBaseParse * parse)
2104 {
2105   GstCaps *caps;
2106   GstStructure *s;
2107 
2108   caps = gst_pad_get_current_caps (parse-&gt;srcpad);
2109   if (G_LIKELY (caps) &amp;&amp; (s = gst_caps_get_structure (caps, 0))) {
2110     parse-&gt;priv-&gt;is_video =
2111         g_str_has_prefix (gst_structure_get_name (s), &quot;video&quot;);
2112   } else {
2113     /* historical default */
2114     parse-&gt;priv-&gt;is_video = FALSE;
2115   }
2116   if (caps)
2117     gst_caps_unref (caps);
2118 
2119   parse-&gt;priv-&gt;checked_media = TRUE;
2120   GST_DEBUG_OBJECT (parse, &quot;media is video: %d&quot;, parse-&gt;priv-&gt;is_video);
2121 }
2122 
2123 /* takes ownership of frame */
2124 static void
2125 gst_base_parse_queue_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
2126 {
2127   if (!(frame-&gt;_private_flags &amp; GST_BASE_PARSE_FRAME_PRIVATE_FLAG_NOALLOC)) {
2128     /* frame allocated on the heap, we can just take ownership */
2129     g_queue_push_tail (&amp;parse-&gt;priv-&gt;queued_frames, frame);
2130     GST_TRACE (&quot;queued frame %p&quot;, frame);
2131   } else {
2132     GstBaseParseFrame *copy;
2133 
2134     /* probably allocated on the stack, must make a proper copy */
2135     copy = gst_base_parse_frame_copy (frame);
2136     g_queue_push_tail (&amp;parse-&gt;priv-&gt;queued_frames, copy);
2137     GST_TRACE (&quot;queued frame %p (copy of %p)&quot;, copy, frame);
2138     gst_base_parse_frame_free (frame);
2139   }
2140 }
2141 
2142 /* makes sure that @buf is properly prepared and decorated for passing
2143  * to baseclass, and an equally setup frame is returned setup with @buf.
2144  * Takes ownership of @buf. */
2145 static GstBaseParseFrame *
2146 gst_base_parse_prepare_frame (GstBaseParse * parse, GstBuffer * buffer)
2147 {
2148   GstBaseParseFrame *frame = NULL;
2149 
2150   buffer = gst_buffer_make_writable (buffer);
2151 
2152   GST_LOG_OBJECT (parse,
2153       &quot;preparing frame at offset %&quot; G_GUINT64_FORMAT
2154       &quot; (%#&quot; G_GINT64_MODIFIER &quot;x) of size %&quot; G_GSIZE_FORMAT,
2155       GST_BUFFER_OFFSET (buffer), GST_BUFFER_OFFSET (buffer),
2156       gst_buffer_get_size (buffer));
2157 
2158   GST_BUFFER_OFFSET (buffer) = parse-&gt;priv-&gt;offset;
2159 
2160   gst_base_parse_update_flags (parse);
2161 
2162   frame = gst_base_parse_frame_new (buffer, 0, 0);
2163   gst_buffer_unref (buffer);
2164   gst_base_parse_update_frame (parse, frame);
2165 
2166   /* clear flags for next frame */
2167   parse-&gt;priv-&gt;discont = FALSE;
2168   parse-&gt;priv-&gt;new_frame = FALSE;
2169 
2170   /* use default handler to provide initial (upstream) metadata */
2171   gst_base_parse_parse_frame (parse, frame);
2172 
2173   return frame;
2174 }
2175 
2176 /* Wraps buffer in a frame and dispatches to subclass.
2177  * Also manages data skipping and offset handling (including adapter flushing).
2178  * Takes ownership of @buffer */
2179 static GstFlowReturn
2180 gst_base_parse_handle_buffer (GstBaseParse * parse, GstBuffer * buffer,
2181     gint * skip, gint * flushed)
2182 {
2183   GstBaseParseClass *klass = GST_BASE_PARSE_GET_CLASS (parse);
2184   GstBaseParseFrame *frame;
2185   GstFlowReturn ret;
2186 
2187   g_return_val_if_fail (skip != NULL || flushed != NULL, GST_FLOW_ERROR);
2188 
2189   GST_LOG_OBJECT (parse,
2190       &quot;handling buffer of size %&quot; G_GSIZE_FORMAT &quot; with dts %&quot; GST_TIME_FORMAT
2191       &quot;, pts %&quot; GST_TIME_FORMAT &quot;, duration %&quot; GST_TIME_FORMAT,
2192       gst_buffer_get_size (buffer), GST_TIME_ARGS (GST_BUFFER_DTS (buffer)),
2193       GST_TIME_ARGS (GST_BUFFER_PTS (buffer)),
2194       GST_TIME_ARGS (GST_BUFFER_DURATION (buffer)));
2195 
2196   /* track what is being flushed during this single round of frame processing */
2197   parse-&gt;priv-&gt;flushed = 0;
2198   *skip = 0;
2199 
2200   /* make it easy for _finish_frame to pick up input data */
2201   if (parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_PULL) {
2202     gst_buffer_ref (buffer);
2203     gst_adapter_push (parse-&gt;priv-&gt;adapter, buffer);
2204   }
2205 
2206   frame = gst_base_parse_prepare_frame (parse, buffer);
2207   ret = klass-&gt;handle_frame (parse, frame, skip);
2208 
2209   *flushed = parse-&gt;priv-&gt;flushed;
2210 
2211   GST_LOG_OBJECT (parse, &quot;handle_frame skipped %d, flushed %d&quot;,
2212       *skip, *flushed);
2213 
2214   /* subclass can only do one of these, or semantics are too unclear */
2215   g_assert (*skip == 0 || *flushed == 0);
2216 
2217   /* track skipping */
2218   if (*skip &gt; 0) {
2219     GstClockTime pts, dts;
2220     GstBuffer *outbuf;
2221 
2222     GST_LOG_OBJECT (parse, &quot;finding sync, skipping %d bytes&quot;, *skip);
2223     if (parse-&gt;segment.rate &lt; 0.0 &amp;&amp; !parse-&gt;priv-&gt;buffers_queued) {
2224       /* reverse playback, and no frames found yet, so we are skipping
2225        * the leading part of a fragment, which may form the tail of
2226        * fragment coming later, hopefully subclass skips efficiently ... */
2227       pts = gst_adapter_prev_pts (parse-&gt;priv-&gt;adapter, NULL);
2228       dts = gst_adapter_prev_dts (parse-&gt;priv-&gt;adapter, NULL);
2229       outbuf = gst_adapter_take_buffer (parse-&gt;priv-&gt;adapter, *skip);
2230 #ifdef GSTREAMER_LITE
2231       if (outbuf != NULL) {
2232 #endif // GSTREAMER_LITE
2233       outbuf = gst_buffer_make_writable (outbuf);
2234       GST_BUFFER_PTS (outbuf) = pts;
2235       GST_BUFFER_DTS (outbuf) = dts;
2236       parse-&gt;priv-&gt;buffers_head =
2237           g_slist_prepend (parse-&gt;priv-&gt;buffers_head, outbuf);
2238       outbuf = NULL;
2239 #ifdef GSTREAMER_LITE
2240       }
2241 #endif // GSTREAMER_LITE
2242     } else {
2243       /* If we&#39;re asked to skip more than is available in the adapter,
2244          we need to remember what we need to skip for next iteration */
2245       gsize av = gst_adapter_available (parse-&gt;priv-&gt;adapter);
2246       GST_DEBUG (&quot;Asked to skip %u (%&quot; G_GSIZE_FORMAT &quot; available)&quot;, *skip, av);
2247       if (av &gt;= *skip) {
2248         gst_adapter_flush (parse-&gt;priv-&gt;adapter, *skip);
2249       } else {
2250         GST_DEBUG
2251             (&quot;This is more than available, flushing %&quot; G_GSIZE_FORMAT
2252             &quot;, storing %u to skip&quot;, av, (guint) (*skip - av));
2253         parse-&gt;priv-&gt;skip = *skip - av;
2254         gst_adapter_flush (parse-&gt;priv-&gt;adapter, av);
2255         *skip = av;
2256       }
2257     }
2258     if (!parse-&gt;priv-&gt;discont)
2259       parse-&gt;priv-&gt;sync_offset = parse-&gt;priv-&gt;offset;
2260     parse-&gt;priv-&gt;offset += *skip;
2261     parse-&gt;priv-&gt;discont = TRUE;
2262     /* check for indefinite skipping */
2263     if (ret == GST_FLOW_OK)
2264       ret = gst_base_parse_check_sync (parse);
2265   }
2266 
2267   parse-&gt;priv-&gt;offset += *flushed;
2268 
2269   if (parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_PULL) {
2270     gst_adapter_clear (parse-&gt;priv-&gt;adapter);
2271   }
2272 
2273   if (*skip == 0 &amp;&amp; *flushed == 0) {
2274     /* Carry over discont if we need more data */
2275     if (GST_BUFFER_IS_DISCONT (frame-&gt;buffer))
2276       parse-&gt;priv-&gt;discont = TRUE;
2277   }
2278 
2279   gst_base_parse_frame_free (frame);
2280 
2281   return ret;
2282 }
2283 
2284 /* gst_base_parse_push_pending_events:
2285  * @parse: #GstBaseParse
2286  *
2287  * Pushes the pending events
2288  */
2289 static void
2290 gst_base_parse_push_pending_events (GstBaseParse * parse)
2291 {
2292   if (G_UNLIKELY (parse-&gt;priv-&gt;pending_events)) {
2293     GList *r = g_list_reverse (parse-&gt;priv-&gt;pending_events);
2294     GList *l;
2295 
2296     parse-&gt;priv-&gt;pending_events = NULL;
2297     for (l = r; l != NULL; l = l-&gt;next) {
2298       gst_pad_push_event (parse-&gt;srcpad, GST_EVENT_CAST (l-&gt;data));
2299     }
2300     g_list_free (r);
2301   }
2302 }
2303 
2304 /* gst_base_parse_handle_and_push_frame:
2305  * @parse: #GstBaseParse.
2306  * @klass: #GstBaseParseClass.
2307  * @frame: (transfer full): a #GstBaseParseFrame
2308  *
2309  * Parses the frame from given buffer and pushes it forward. Also performs
2310  * timestamp handling and checks the segment limits.
2311  *
2312  * This is called with srcpad STREAM_LOCK held.
2313  *
2314  * Returns: #GstFlowReturn
2315  */
2316 static GstFlowReturn
2317 gst_base_parse_handle_and_push_frame (GstBaseParse * parse,
2318     GstBaseParseFrame * frame)
2319 {
2320   gint64 offset;
2321   GstBuffer *buffer;
2322 
2323   g_return_val_if_fail (frame != NULL, GST_FLOW_ERROR);
2324 
2325   buffer = frame-&gt;buffer;
2326   offset = frame-&gt;offset;
2327 
2328   /* check if subclass/format can provide ts.
2329    * If so, that allows and enables extra seek and duration determining options */
2330   if (G_UNLIKELY (parse-&gt;priv-&gt;first_frame_offset &lt; 0)) {
2331     if (GST_BUFFER_PTS_IS_VALID (buffer) &amp;&amp; parse-&gt;priv-&gt;has_timing_info
2332         &amp;&amp; parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_PULL) {
2333       parse-&gt;priv-&gt;first_frame_offset = offset;
2334       parse-&gt;priv-&gt;first_frame_pts = GST_BUFFER_PTS (buffer);
2335       parse-&gt;priv-&gt;first_frame_dts = GST_BUFFER_DTS (buffer);
2336       GST_DEBUG_OBJECT (parse, &quot;subclass provided dts %&quot; GST_TIME_FORMAT
2337           &quot;, pts %&quot; GST_TIME_FORMAT &quot; for first frame at offset %&quot;
2338           G_GINT64_FORMAT, GST_TIME_ARGS (parse-&gt;priv-&gt;first_frame_dts),
2339           GST_TIME_ARGS (parse-&gt;priv-&gt;first_frame_pts),
2340           parse-&gt;priv-&gt;first_frame_offset);
2341       if (!GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;duration)) {
2342         gint64 off;
2343         GstClockTime last_ts = G_MAXINT64;
2344 
2345         GST_DEBUG_OBJECT (parse, &quot;no duration; trying scan to determine&quot;);
2346         gst_base_parse_locate_time (parse, &amp;last_ts, &amp;off);
2347         if (GST_CLOCK_TIME_IS_VALID (last_ts))
2348           gst_base_parse_set_duration (parse, GST_FORMAT_TIME, last_ts, 0);
2349       }
2350     } else {
2351       /* disable further checks */
2352       parse-&gt;priv-&gt;first_frame_offset = 0;
2353     }
2354   }
2355 
2356   /* track upstream time if provided, not subclass&#39; internal notion of it */
2357   if (parse-&gt;priv-&gt;upstream_format == GST_FORMAT_TIME) {
2358     GST_BUFFER_PTS (frame-&gt;buffer) = GST_CLOCK_TIME_NONE;
2359     GST_BUFFER_DTS (frame-&gt;buffer) = GST_CLOCK_TIME_NONE;
2360   }
2361 
2362   /* interpolating and no valid pts yet,
2363    * start with dts and carry on from there */
2364   if (parse-&gt;priv-&gt;infer_ts &amp;&amp; parse-&gt;priv-&gt;pts_interpolate
2365       &amp;&amp; !GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;next_pts))
2366     parse-&gt;priv-&gt;next_pts = parse-&gt;priv-&gt;next_dts;
2367 
2368   /* again use default handler to add missing metadata;
2369    * we may have new information on frame properties */
2370   gst_base_parse_parse_frame (parse, frame);
2371 
2372   parse-&gt;priv-&gt;next_pts = GST_CLOCK_TIME_NONE;
2373   if (GST_BUFFER_DTS_IS_VALID (buffer) &amp;&amp; GST_BUFFER_DURATION_IS_VALID (buffer)) {
2374     parse-&gt;priv-&gt;next_dts =
2375         GST_BUFFER_DTS (buffer) + GST_BUFFER_DURATION (buffer);
2376     if (parse-&gt;priv-&gt;pts_interpolate &amp;&amp; GST_BUFFER_PTS_IS_VALID (buffer)) {
2377       GstClockTime next_pts =
2378           GST_BUFFER_PTS (buffer) + GST_BUFFER_DURATION (buffer);
2379       if (next_pts &gt;= parse-&gt;priv-&gt;next_dts)
2380         parse-&gt;priv-&gt;next_pts = next_pts;
2381     }
2382   } else {
2383     /* we lost track, do not produce bogus time next time around
2384      * (probably means parser subclass has given up on parsing as well) */
2385     GST_DEBUG_OBJECT (parse, &quot;no next fallback timestamp&quot;);
2386     parse-&gt;priv-&gt;next_dts = GST_CLOCK_TIME_NONE;
2387   }
2388 
2389   if (parse-&gt;priv-&gt;upstream_seekable &amp;&amp; parse-&gt;priv-&gt;exact_position &amp;&amp;
2390       GST_BUFFER_PTS_IS_VALID (buffer))
2391     gst_base_parse_add_index_entry (parse, offset,
2392         GST_BUFFER_PTS (buffer),
2393         !GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DELTA_UNIT), FALSE);
2394 
2395   /* All OK, push queued frames if there are any */
2396   if (G_UNLIKELY (!g_queue_is_empty (&amp;parse-&gt;priv-&gt;queued_frames))) {
2397     GstBaseParseFrame *queued_frame;
2398 
2399     while ((queued_frame = g_queue_pop_head (&amp;parse-&gt;priv-&gt;queued_frames))) {
2400       gst_base_parse_push_frame (parse, queued_frame);
2401       gst_base_parse_frame_free (queued_frame);
2402     }
2403   }
2404 
2405   return gst_base_parse_push_frame (parse, frame);
2406 }
2407 
2408 /**
2409  * gst_base_parse_push_frame:
2410  * @parse: #GstBaseParse.
2411  * @frame: (transfer none): a #GstBaseParseFrame
2412  *
2413  * Pushes the frame&#39;s buffer downstream, sends any pending events and
2414  * does some timestamp and segment handling. Takes ownership of
2415  * frame&#39;s buffer, though caller retains ownership of @frame.
2416  *
2417  * This must be called with sinkpad STREAM_LOCK held.
2418  *
2419  * Returns: #GstFlowReturn
2420  */
2421 GstFlowReturn
2422 gst_base_parse_push_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
2423 {
2424   GstFlowReturn ret = GST_FLOW_OK;
2425   GstClockTime last_start = GST_CLOCK_TIME_NONE;
2426   GstClockTime last_stop = GST_CLOCK_TIME_NONE;
2427   GstBaseParseClass *klass = GST_BASE_PARSE_GET_CLASS (parse);
2428   GstBuffer *buffer;
2429   gsize size;
2430 
2431   g_return_val_if_fail (frame != NULL, GST_FLOW_ERROR);
2432   g_return_val_if_fail (frame-&gt;buffer != NULL, GST_FLOW_ERROR);
2433 
2434   GST_TRACE_OBJECT (parse, &quot;pushing frame %p&quot;, frame);
2435 
2436   buffer = frame-&gt;buffer;
2437 
2438   GST_LOG_OBJECT (parse,
2439       &quot;processing buffer of size %&quot; G_GSIZE_FORMAT &quot; with dts %&quot; GST_TIME_FORMAT
2440       &quot;, pts %&quot; GST_TIME_FORMAT &quot;, duration %&quot; GST_TIME_FORMAT,
2441       gst_buffer_get_size (buffer),
2442       GST_TIME_ARGS (GST_BUFFER_DTS (buffer)),
2443       GST_TIME_ARGS (GST_BUFFER_PTS (buffer)),
2444       GST_TIME_ARGS (GST_BUFFER_DURATION (buffer)));
2445 
2446   /* update stats */
2447   parse-&gt;priv-&gt;bytecount += frame-&gt;size;
2448   if (G_LIKELY (!(frame-&gt;flags &amp; GST_BASE_PARSE_FRAME_FLAG_NO_FRAME))) {
2449     parse-&gt;priv-&gt;framecount++;
2450     if (GST_BUFFER_DURATION_IS_VALID (buffer)) {
2451       parse-&gt;priv-&gt;acc_duration += GST_BUFFER_DURATION (buffer);
2452     }
2453   }
2454   /* 0 means disabled */
2455   if (parse-&gt;priv-&gt;update_interval &lt; 0)
2456     parse-&gt;priv-&gt;update_interval = 50;
2457   else if (parse-&gt;priv-&gt;update_interval &gt; 0 &amp;&amp;
2458       (parse-&gt;priv-&gt;framecount % parse-&gt;priv-&gt;update_interval) == 0)
2459     gst_base_parse_update_duration (parse);
2460 
2461   if (GST_BUFFER_PTS_IS_VALID (buffer))
2462     last_start = last_stop = GST_BUFFER_PTS (buffer);
2463   if (last_start != GST_CLOCK_TIME_NONE
2464       &amp;&amp; GST_BUFFER_DURATION_IS_VALID (buffer))
2465     last_stop = last_start + GST_BUFFER_DURATION (buffer);
2466 
2467   /* should have caps by now */
2468   if (!gst_pad_has_current_caps (parse-&gt;srcpad))
2469     goto no_caps;
2470 
2471   if (G_UNLIKELY (!parse-&gt;priv-&gt;checked_media)) {
2472     /* have caps; check identity */
2473     gst_base_parse_check_media (parse);
2474   }
2475 
2476   if (parse-&gt;priv-&gt;tags_changed) {
2477     gst_base_parse_queue_tag_event_update (parse);
2478     parse-&gt;priv-&gt;tags_changed = FALSE;
2479   }
2480 
2481   /* Push pending events, including SEGMENT events */
2482   gst_base_parse_push_pending_events (parse);
2483 
2484   /* segment adjustment magic; only if we are running the whole show */
2485   if (!parse-&gt;priv-&gt;passthrough &amp;&amp; parse-&gt;segment.rate &gt; 0.0 &amp;&amp;
2486       (parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_PULL ||
2487           parse-&gt;priv-&gt;upstream_seekable)) {
2488     /* handle gaps */
2489     if (GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.position) &amp;&amp;
2490         GST_CLOCK_TIME_IS_VALID (last_start)) {
2491       GstClockTimeDiff diff;
2492 
2493       /* only send newsegments with increasing start times,
2494        * otherwise if these go back and forth downstream (sinks) increase
2495        * accumulated time and running_time */
2496       diff = GST_CLOCK_DIFF (parse-&gt;segment.position, last_start);
2497       if (G_UNLIKELY (diff &gt; 2 * GST_SECOND
2498               &amp;&amp; last_start &gt; parse-&gt;segment.start
2499               &amp;&amp; (!GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.stop)
2500                   || last_start &lt; parse-&gt;segment.stop))) {
2501         GstEvent *topush;
2502 
2503         GST_DEBUG_OBJECT (parse,
2504             &quot;Gap of %&quot; G_GINT64_FORMAT &quot; ns detected in stream &quot; &quot;(%&quot;
2505             GST_TIME_FORMAT &quot; -&gt; %&quot; GST_TIME_FORMAT &quot;). &quot;
2506             &quot;Sending updated SEGMENT events&quot;, diff,
2507             GST_TIME_ARGS (parse-&gt;segment.position),
2508             GST_TIME_ARGS (last_start));
2509 
2510         /* skip gap FIXME */
2511         topush = gst_event_new_segment (&amp;parse-&gt;segment);
2512         if (parse-&gt;priv-&gt;segment_seqnum != GST_SEQNUM_INVALID)
2513           gst_event_set_seqnum (topush, parse-&gt;priv-&gt;segment_seqnum);
2514         gst_pad_push_event (parse-&gt;srcpad, topush);
2515 
2516         parse-&gt;segment.position = last_start;
2517       }
2518     }
2519   }
2520 
2521   /* update bitrates and optionally post corresponding tags
2522    * (following newsegment) */
2523   gst_base_parse_update_bitrates (parse, frame);
2524 
2525   if (klass-&gt;pre_push_frame) {
2526     ret = klass-&gt;pre_push_frame (parse, frame);
2527   } else {
2528     frame-&gt;flags |= GST_BASE_PARSE_FRAME_FLAG_CLIP;
2529   }
2530 
2531   /* Push pending events, if there are any new ones
2532    * like tags added by pre_push_frame */
2533   if (parse-&gt;priv-&gt;tags_changed) {
2534     gst_base_parse_queue_tag_event_update (parse);
2535     parse-&gt;priv-&gt;tags_changed = FALSE;
2536   }
2537   gst_base_parse_push_pending_events (parse);
2538 
2539   /* take final ownership of frame buffer */
2540   if (frame-&gt;out_buffer) {
2541     buffer = frame-&gt;out_buffer;
2542     frame-&gt;out_buffer = NULL;
2543     gst_buffer_replace (&amp;frame-&gt;buffer, NULL);
2544   } else {
2545     buffer = frame-&gt;buffer;
2546     frame-&gt;buffer = NULL;
2547   }
2548 
2549   /* subclass must play nice */
2550   g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
2551 
2552   size = gst_buffer_get_size (buffer);
2553 
2554   parse-&gt;priv-&gt;seen_keyframe |= parse-&gt;priv-&gt;is_video &amp;&amp;
2555       !GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DELTA_UNIT);
2556 
2557   if (frame-&gt;flags &amp; GST_BASE_PARSE_FRAME_FLAG_CLIP) {
2558     if (GST_BUFFER_TIMESTAMP_IS_VALID (buffer) &amp;&amp;
2559         GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.stop) &amp;&amp;
2560         GST_BUFFER_TIMESTAMP (buffer) &gt;
2561         parse-&gt;segment.stop + parse-&gt;priv-&gt;lead_out_ts) {
2562       GST_LOG_OBJECT (parse, &quot;Dropped frame, after segment&quot;);
2563       ret = GST_FLOW_EOS;
2564     } else if (GST_BUFFER_TIMESTAMP_IS_VALID (buffer) &amp;&amp;
2565         GST_BUFFER_DURATION_IS_VALID (buffer) &amp;&amp;
2566         GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.start) &amp;&amp;
2567         GST_BUFFER_TIMESTAMP (buffer) + GST_BUFFER_DURATION (buffer) +
2568         parse-&gt;priv-&gt;lead_in_ts &lt; parse-&gt;segment.start) {
2569       if (parse-&gt;priv-&gt;seen_keyframe) {
2570         GST_LOG_OBJECT (parse, &quot;Frame before segment, after keyframe&quot;);
2571         ret = GST_FLOW_OK;
2572       } else {
2573         GST_LOG_OBJECT (parse, &quot;Dropped frame, before segment&quot;);
2574         ret = GST_BASE_PARSE_FLOW_DROPPED;
2575       }
2576     } else {
2577       ret = GST_FLOW_OK;
2578     }
2579   }
2580 
2581   if (ret == GST_BASE_PARSE_FLOW_DROPPED) {
2582     GST_LOG_OBJECT (parse, &quot;frame (%&quot; G_GSIZE_FORMAT &quot; bytes) dropped&quot;, size);
2583     if (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT))
2584       parse-&gt;priv-&gt;discont = TRUE;
2585     gst_buffer_unref (buffer);
2586     ret = GST_FLOW_OK;
2587   } else if (ret == GST_FLOW_OK) {
2588     if (parse-&gt;segment.rate &gt; 0.0) {
2589       GST_LOG_OBJECT (parse, &quot;pushing frame (%&quot; G_GSIZE_FORMAT &quot; bytes) now..&quot;,
2590           size);
2591       ret = gst_pad_push (parse-&gt;srcpad, buffer);
2592       GST_LOG_OBJECT (parse, &quot;frame pushed, flow %s&quot;, gst_flow_get_name (ret));
2593     } else if (!parse-&gt;priv-&gt;disable_passthrough &amp;&amp; parse-&gt;priv-&gt;passthrough) {
2594 
2595       /* in backwards playback mode, if on passthrough we need to push buffers
2596        * directly without accumulating them into the buffers_queued as baseparse
2597        * will never check for a DISCONT while on passthrough and those buffers
2598        * will never be pushed.
2599        *
2600        * also, as we are on reverse playback, it might be possible that
2601        * passthrough might have just been enabled, so make sure to drain the
2602        * buffers_queued list */
2603       if (G_UNLIKELY (parse-&gt;priv-&gt;buffers_queued != NULL)) {
2604         gst_base_parse_finish_fragment (parse, TRUE);
2605         ret = gst_base_parse_send_buffers (parse);
2606       }
2607 
2608       if (ret == GST_FLOW_OK) {
2609         GST_LOG_OBJECT (parse,
2610             &quot;pushing frame (%&quot; G_GSIZE_FORMAT &quot; bytes) now..&quot;, size);
2611         ret = gst_pad_push (parse-&gt;srcpad, buffer);
2612         GST_LOG_OBJECT (parse, &quot;frame pushed, flow %s&quot;,
2613             gst_flow_get_name (ret));
2614       } else {
2615         GST_LOG_OBJECT (parse,
2616             &quot;frame (%&quot; G_GSIZE_FORMAT &quot; bytes) not pushed: %s&quot;, size,
2617             gst_flow_get_name (ret));
2618         gst_buffer_unref (buffer);
2619       }
2620 
2621     } else {
2622       GST_LOG_OBJECT (parse, &quot;frame (%&quot; G_GSIZE_FORMAT &quot; bytes) queued for now&quot;,
2623           size);
2624       parse-&gt;priv-&gt;buffers_queued =
2625           g_slist_prepend (parse-&gt;priv-&gt;buffers_queued, buffer);
2626       ret = GST_FLOW_OK;
2627     }
2628   } else {
2629     GST_LOG_OBJECT (parse, &quot;frame (%&quot; G_GSIZE_FORMAT &quot; bytes) not pushed: %s&quot;,
2630         size, gst_flow_get_name (ret));
2631     gst_buffer_unref (buffer);
2632     /* if we are not sufficiently in control, let upstream decide on EOS */
2633     if (ret == GST_FLOW_EOS &amp;&amp; !parse-&gt;priv-&gt;disable_passthrough &amp;&amp;
2634         (parse-&gt;priv-&gt;passthrough ||
2635             (parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_PUSH &amp;&amp;
2636                 !parse-&gt;priv-&gt;upstream_seekable)))
2637       ret = GST_FLOW_OK;
2638   }
2639 
2640   /* Update current running segment position */
2641   if ((ret == GST_FLOW_OK || ret == GST_FLOW_NOT_LINKED)
2642       &amp;&amp; last_stop != GST_CLOCK_TIME_NONE
2643       &amp;&amp; parse-&gt;segment.position &lt; last_stop)
2644     parse-&gt;segment.position = last_stop;
2645 
2646   return ret;
2647 
2648   /* ERRORS */
2649 no_caps:
2650   {
2651     if (GST_PAD_IS_FLUSHING (parse-&gt;srcpad))
2652       return GST_FLOW_FLUSHING;
2653 
2654     GST_ELEMENT_ERROR (parse, STREAM, DECODE, (&quot;No caps set&quot;), (NULL));
2655     return GST_FLOW_ERROR;
2656   }
2657 }
2658 
2659 /**
2660  * gst_base_parse_finish_frame:
2661  * @parse: a #GstBaseParse
2662  * @frame: a #GstBaseParseFrame
2663  * @size: consumed input data represented by frame
2664  *
2665  * Collects parsed data and pushes this downstream.
2666  * Source pad caps must be set when this is called.
2667  *
2668  * If @frame&#39;s out_buffer is set, that will be used as subsequent frame data.
2669  * Otherwise, @size samples will be taken from the input and used for output,
2670  * and the output&#39;s metadata (timestamps etc) will be taken as (optionally)
2671  * set by the subclass on @frame&#39;s (input) buffer (which is otherwise
2672  * ignored for any but the above purpose/information).
2673  *
2674  * Note that the latter buffer is invalidated by this call, whereas the
2675  * caller retains ownership of @frame.
2676  *
2677  * Returns: a #GstFlowReturn that should be escalated to caller (of caller)
2678  */
2679 GstFlowReturn
2680 gst_base_parse_finish_frame (GstBaseParse * parse, GstBaseParseFrame * frame,
2681     gint size)
2682 {
2683   GstFlowReturn ret = GST_FLOW_OK;
2684 
2685   g_return_val_if_fail (frame != NULL, GST_FLOW_ERROR);
2686   g_return_val_if_fail (frame-&gt;buffer != NULL, GST_FLOW_ERROR);
2687   g_return_val_if_fail (size &gt; 0 || frame-&gt;out_buffer, GST_FLOW_ERROR);
2688   g_return_val_if_fail (gst_adapter_available (parse-&gt;priv-&gt;adapter) &gt;= size,
2689       GST_FLOW_ERROR);
2690 
2691   GST_LOG_OBJECT (parse, &quot;finished frame at offset %&quot; G_GUINT64_FORMAT &quot;, &quot;
2692       &quot;flushing size %d&quot;, frame-&gt;offset, size);
2693 
2694   /* some one-time start-up */
2695   if (G_UNLIKELY (parse-&gt;priv-&gt;framecount == 0)) {
2696     gst_base_parse_check_seekability (parse);
2697     gst_base_parse_check_upstream (parse);
2698   }
2699 
2700   parse-&gt;priv-&gt;flushed += size;
2701 
2702   if (parse-&gt;priv-&gt;scanning &amp;&amp; frame-&gt;buffer) {
2703     if (!parse-&gt;priv-&gt;scanned_frame) {
2704       parse-&gt;priv-&gt;scanned_frame = gst_base_parse_frame_copy (frame);
2705     }
2706     goto exit;
2707   }
2708 
2709   /* either PUSH or PULL mode arranges for adapter data */
2710   /* ensure output buffer */
2711   if (!frame-&gt;out_buffer) {
2712     GstBuffer *src, *dest;
2713 
2714     frame-&gt;out_buffer = gst_adapter_take_buffer (parse-&gt;priv-&gt;adapter, size);
2715     dest = frame-&gt;out_buffer;
2716     src = frame-&gt;buffer;
2717     GST_BUFFER_PTS (dest) = GST_BUFFER_PTS (src);
2718     GST_BUFFER_DTS (dest) = GST_BUFFER_DTS (src);
2719     GST_BUFFER_OFFSET (dest) = GST_BUFFER_OFFSET (src);
2720     GST_BUFFER_DURATION (dest) = GST_BUFFER_DURATION (src);
2721     GST_BUFFER_OFFSET_END (dest) = GST_BUFFER_OFFSET_END (src);
2722     GST_MINI_OBJECT_FLAGS (dest) = GST_MINI_OBJECT_FLAGS (src);
2723   } else {
2724     gst_adapter_flush (parse-&gt;priv-&gt;adapter, size);
2725   }
2726 
2727   /* use as input for subsequent processing */
2728   gst_buffer_replace (&amp;frame-&gt;buffer, frame-&gt;out_buffer);
2729   gst_buffer_unref (frame-&gt;out_buffer);
2730   frame-&gt;out_buffer = NULL;
2731 
2732   /* mark input size consumed */
2733   frame-&gt;size = size;
2734 
2735   /* subclass might queue frames/data internally if it needs more
2736    * frames to decide on the format, or might request us to queue here. */
2737   if (frame-&gt;flags &amp; GST_BASE_PARSE_FRAME_FLAG_DROP) {
2738     gst_buffer_replace (&amp;frame-&gt;buffer, NULL);
2739     goto exit;
2740   } else if (frame-&gt;flags &amp; GST_BASE_PARSE_FRAME_FLAG_QUEUE) {
2741     GstBaseParseFrame *copy;
2742 
2743     copy = gst_base_parse_frame_copy (frame);
2744     copy-&gt;flags &amp;= ~GST_BASE_PARSE_FRAME_FLAG_QUEUE;
2745     gst_base_parse_queue_frame (parse, copy);
2746     goto exit;
2747   }
2748 
2749   ret = gst_base_parse_handle_and_push_frame (parse, frame);
2750 
2751 exit:
2752   return ret;
2753 }
2754 
2755 /**
2756  * gst_base_parse_drain:
2757  * @parse: a #GstBaseParse
2758  *
2759  * Drains the adapter until it is empty. It decreases the min_frame_size to
2760  * match the current adapter size and calls chain method until the adapter
2761  * is emptied or chain returns with error.
2762  *
2763  * Since: 1.12
2764  */
2765 void
2766 gst_base_parse_drain (GstBaseParse * parse)
2767 {
2768   guint avail;
2769 
2770   GST_DEBUG_OBJECT (parse, &quot;draining&quot;);
2771   parse-&gt;priv-&gt;drain = TRUE;
2772 
2773   for (;;) {
2774     avail = gst_adapter_available (parse-&gt;priv-&gt;adapter);
2775     if (!avail)
2776       break;
2777 
2778     if (gst_base_parse_chain (parse-&gt;sinkpad, GST_OBJECT_CAST (parse),
2779             NULL) != GST_FLOW_OK) {
2780       break;
2781     }
2782 
2783     /* nothing changed, maybe due to truncated frame; break infinite loop */
2784     if (avail == gst_adapter_available (parse-&gt;priv-&gt;adapter)) {
2785       GST_DEBUG_OBJECT (parse, &quot;no change during draining; flushing&quot;);
2786       gst_adapter_clear (parse-&gt;priv-&gt;adapter);
2787     }
2788   }
2789 
2790   parse-&gt;priv-&gt;drain = FALSE;
2791 }
2792 
2793 /* gst_base_parse_send_buffers
2794  *
2795  * Sends buffers collected in send_buffers downstream, and ensures that list
2796  * is empty at the end (errors or not).
2797  */
2798 static GstFlowReturn
2799 gst_base_parse_send_buffers (GstBaseParse * parse)
2800 {
2801   GSList *send = NULL;
2802   GstBuffer *buf;
2803   GstFlowReturn ret = GST_FLOW_OK;
2804   gboolean first = TRUE;
2805 
2806   send = parse-&gt;priv-&gt;buffers_send;
2807 
2808   /* send buffers */
2809   while (send) {
2810     buf = GST_BUFFER_CAST (send-&gt;data);
2811     GST_LOG_OBJECT (parse, &quot;pushing buffer %p, dts %&quot;
2812         GST_TIME_FORMAT &quot;, pts %&quot; GST_TIME_FORMAT &quot;, duration %&quot; GST_TIME_FORMAT
2813         &quot;, offset %&quot; G_GINT64_FORMAT, buf,
2814         GST_TIME_ARGS (GST_BUFFER_DTS (buf)),
2815         GST_TIME_ARGS (GST_BUFFER_PTS (buf)),
2816         GST_TIME_ARGS (GST_BUFFER_DURATION (buf)), GST_BUFFER_OFFSET (buf));
2817 
2818     /* Make sure the first buffer is always DISCONT. If we split
2819      * GOPs inside the parser this is otherwise not guaranteed */
2820     if (first) {
2821       GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);
2822       first = FALSE;
2823     } else {
2824       /* likewise, subsequent buffers should never have DISCONT
2825        * according to the &quot;reverse fragment protocol&quot;, or such would
2826        * confuse a downstream decoder
2827        * (could be DISCONT due to aggregating upstream fragments by parsing) */
2828       GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DISCONT);
2829     }
2830 
2831     /* iterate output queue an push downstream */
2832     ret = gst_pad_push (parse-&gt;srcpad, buf);
2833     send = g_slist_delete_link (send, send);
2834 
2835     /* clear any leftover if error */
2836     if (G_UNLIKELY (ret != GST_FLOW_OK)) {
2837       while (send) {
2838         buf = GST_BUFFER_CAST (send-&gt;data);
2839         gst_buffer_unref (buf);
2840         send = g_slist_delete_link (send, send);
2841       }
2842     }
2843   }
2844 
2845   parse-&gt;priv-&gt;buffers_send = send;
2846 
2847   return ret;
2848 }
2849 
2850 /* gst_base_parse_start_fragment:
2851  *
2852  * Prepares for processing a reverse playback (forward) fragment
2853  * by (re)setting proper state variables.
2854  */
2855 static GstFlowReturn
2856 gst_base_parse_start_fragment (GstBaseParse * parse)
2857 {
2858   GST_LOG_OBJECT (parse, &quot;starting fragment&quot;);
2859 
2860   /* invalidate so no fall-back timestamping is performed;
2861    * ok if taken from subclass or upstream */
2862   parse-&gt;priv-&gt;next_pts = GST_CLOCK_TIME_NONE;
2863   parse-&gt;priv-&gt;prev_pts = GST_CLOCK_TIME_NONE;
2864   parse-&gt;priv-&gt;next_dts = GST_CLOCK_TIME_NONE;
2865   parse-&gt;priv-&gt;prev_dts = GST_CLOCK_TIME_NONE;
2866   parse-&gt;priv-&gt;prev_dts_from_pts = FALSE;
2867   /* prevent it hanging around stop all the time */
2868   parse-&gt;segment.position = GST_CLOCK_TIME_NONE;
2869   /* mark next run */
2870   parse-&gt;priv-&gt;discont = TRUE;
2871 
2872   /* head of previous fragment is now pending tail of current fragment */
2873   parse-&gt;priv-&gt;buffers_pending = parse-&gt;priv-&gt;buffers_head;
2874   parse-&gt;priv-&gt;buffers_head = NULL;
2875 
2876   return GST_FLOW_OK;
2877 }
2878 
2879 
2880 /* gst_base_parse_finish_fragment:
2881  *
2882  * Processes a reverse playback (forward) fragment:
2883  * - append head of last fragment that was skipped to current fragment data
2884  * - drain the resulting current fragment data (i.e. repeated chain)
2885  * - add time/duration (if needed) to frames queued by chain
2886  * - push queued data
2887  */
2888 static GstFlowReturn
2889 gst_base_parse_finish_fragment (GstBaseParse * parse, gboolean prev_head)
2890 {
2891   GstBuffer *buf;
2892   GstFlowReturn ret = GST_FLOW_OK;
2893   gboolean seen_key = FALSE, seen_delta = FALSE;
2894 
2895   GST_LOG_OBJECT (parse, &quot;finishing fragment&quot;);
2896 
2897   /* restore order */
2898   parse-&gt;priv-&gt;buffers_pending = g_slist_reverse (parse-&gt;priv-&gt;buffers_pending);
2899   while (parse-&gt;priv-&gt;buffers_pending) {
2900     buf = GST_BUFFER_CAST (parse-&gt;priv-&gt;buffers_pending-&gt;data);
2901     if (prev_head) {
2902       GST_LOG_OBJECT (parse, &quot;adding pending buffer (size %&quot; G_GSIZE_FORMAT &quot;)&quot;,
2903           gst_buffer_get_size (buf));
2904       gst_adapter_push (parse-&gt;priv-&gt;adapter, buf);
2905     } else {
2906       GST_LOG_OBJECT (parse, &quot;discarding head buffer&quot;);
2907       gst_buffer_unref (buf);
2908     }
2909     parse-&gt;priv-&gt;buffers_pending =
2910         g_slist_delete_link (parse-&gt;priv-&gt;buffers_pending,
2911         parse-&gt;priv-&gt;buffers_pending);
2912   }
2913 
2914   /* chain looks for frames and queues resulting ones (in stead of pushing) */
2915   /* initial skipped data is added to buffers_pending */
2916   gst_base_parse_drain (parse);
2917 
2918   if (parse-&gt;priv-&gt;buffers_send) {
2919     buf = GST_BUFFER_CAST (parse-&gt;priv-&gt;buffers_send-&gt;data);
2920     seen_key |= !GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
2921   }
2922 
2923   /* add metadata (if needed to queued buffers */
2924   GST_LOG_OBJECT (parse, &quot;last timestamp: %&quot; GST_TIME_FORMAT,
2925       GST_TIME_ARGS (parse-&gt;priv-&gt;last_pts));
2926   while (parse-&gt;priv-&gt;buffers_queued) {
2927     buf = GST_BUFFER_CAST (parse-&gt;priv-&gt;buffers_queued-&gt;data);
2928 
2929     /* no touching if upstream or parsing provided time */
2930     if (GST_BUFFER_PTS_IS_VALID (buf)) {
2931       GST_LOG_OBJECT (parse, &quot;buffer has time %&quot; GST_TIME_FORMAT,
2932           GST_TIME_ARGS (GST_BUFFER_PTS (buf)));
2933     } else if (GST_BUFFER_DURATION_IS_VALID (buf)) {
2934       if (GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;last_pts)) {
2935         if (G_LIKELY (GST_BUFFER_DURATION (buf) &lt;= parse-&gt;priv-&gt;last_pts))
2936           parse-&gt;priv-&gt;last_pts -= GST_BUFFER_DURATION (buf);
2937         else
2938           parse-&gt;priv-&gt;last_pts = 0;
2939         GST_BUFFER_PTS (buf) = parse-&gt;priv-&gt;last_pts;
2940         GST_LOG_OBJECT (parse, &quot;applied time %&quot; GST_TIME_FORMAT,
2941             GST_TIME_ARGS (GST_BUFFER_PTS (buf)));
2942       }
2943       if (GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;last_dts)) {
2944         if (G_LIKELY (GST_BUFFER_DURATION (buf) &lt;= parse-&gt;priv-&gt;last_dts))
2945           parse-&gt;priv-&gt;last_dts -= GST_BUFFER_DURATION (buf);
2946         else
2947           parse-&gt;priv-&gt;last_dts = 0;
2948         GST_BUFFER_DTS (buf) = parse-&gt;priv-&gt;last_dts;
2949         GST_LOG_OBJECT (parse, &quot;applied dts %&quot; GST_TIME_FORMAT,
2950             GST_TIME_ARGS (GST_BUFFER_DTS (buf)));
2951       }
2952     } else {
2953       /* no idea, very bad */
2954       GST_WARNING_OBJECT (parse, &quot;could not determine time for buffer&quot;);
2955     }
2956 
2957     parse-&gt;priv-&gt;last_pts = GST_BUFFER_PTS (buf);
2958     parse-&gt;priv-&gt;last_dts = GST_BUFFER_DTS (buf);
2959 
2960     /* reverse order for ascending sending */
2961     /* send downstream at keyframe not preceded by a keyframe
2962      * (e.g. that should identify start of collection of IDR nals) */
2963     if (GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT)) {
2964       if (seen_key) {
2965         ret = gst_base_parse_send_buffers (parse);
2966         /* if a problem, throw all to sending */
2967         if (ret != GST_FLOW_OK) {
2968           parse-&gt;priv-&gt;buffers_send =
2969               g_slist_reverse (parse-&gt;priv-&gt;buffers_queued);
2970           parse-&gt;priv-&gt;buffers_queued = NULL;
2971           break;
2972         }
2973         seen_key = FALSE;
2974       }
2975       seen_delta = TRUE;
2976     } else {
2977       seen_key = TRUE;
2978     }
2979 
2980     parse-&gt;priv-&gt;buffers_send =
2981         g_slist_prepend (parse-&gt;priv-&gt;buffers_send, buf);
2982     parse-&gt;priv-&gt;buffers_queued =
2983         g_slist_delete_link (parse-&gt;priv-&gt;buffers_queued,
2984         parse-&gt;priv-&gt;buffers_queued);
2985   }
2986 
2987   /* audio may have all marked as keyframe, so arrange to send here. Also
2988    * we might have ended the loop above on a keyframe, in which case we
2989    * should */
2990   if (!seen_delta || seen_key)
2991     ret = gst_base_parse_send_buffers (parse);
2992 
2993   /* any trailing unused no longer usable (ideally none) */
2994   if (G_UNLIKELY (gst_adapter_available (parse-&gt;priv-&gt;adapter))) {
2995     GST_DEBUG_OBJECT (parse, &quot;discarding %&quot; G_GSIZE_FORMAT &quot; trailing bytes&quot;,
2996         gst_adapter_available (parse-&gt;priv-&gt;adapter));
2997     gst_adapter_clear (parse-&gt;priv-&gt;adapter);
2998   }
2999 
3000   return ret;
3001 }
3002 
3003 /* small helper that checks whether we have been trying to resync too long */
3004 static inline GstFlowReturn
3005 gst_base_parse_check_sync (GstBaseParse * parse)
3006 {
3007   if (G_UNLIKELY (parse-&gt;priv-&gt;discont &amp;&amp;
3008           parse-&gt;priv-&gt;offset - parse-&gt;priv-&gt;sync_offset &gt; 2 * 1024 * 1024)) {
3009     GST_ELEMENT_ERROR (parse, STREAM, DECODE,
3010         (&quot;Failed to parse stream&quot;), (NULL));
3011     return GST_FLOW_ERROR;
3012   }
3013 
3014   return GST_FLOW_OK;
3015 }
3016 
3017 static GstFlowReturn
3018 gst_base_parse_process_streamheader (GstBaseParse * parse)
3019 {
3020   GstCaps *caps;
3021   GstStructure *str;
3022   const GValue *value;
3023   GstFlowReturn ret = GST_FLOW_OK;
3024 
3025   caps = gst_pad_get_current_caps (GST_BASE_PARSE_SINK_PAD (parse));
3026   if (caps == NULL)
3027     goto notfound;
3028 
3029   str = gst_caps_get_structure (caps, 0);
3030   value = gst_structure_get_value (str, &quot;streamheader&quot;);
3031   if (value == NULL)
3032     goto notfound;
3033 
3034   GST_DEBUG_OBJECT (parse, &quot;Found streamheader field on input caps&quot;);
3035 
3036   if (GST_VALUE_HOLDS_ARRAY (value)) {
3037     gint i;
3038     gsize len = gst_value_array_get_size (value);
3039 
3040     for (i = 0; i &lt; len; i++) {
3041       GstBuffer *buffer =
3042           gst_value_get_buffer (gst_value_array_get_value (value, i));
3043       ret =
3044           gst_base_parse_chain (GST_BASE_PARSE_SINK_PAD (parse),
3045           GST_OBJECT_CAST (parse), gst_buffer_ref (buffer));
3046     }
3047 
3048   } else if (GST_VALUE_HOLDS_BUFFER (value)) {
3049     GstBuffer *buffer = gst_value_get_buffer (value);
3050     ret =
3051         gst_base_parse_chain (GST_BASE_PARSE_SINK_PAD (parse),
3052         GST_OBJECT_CAST (parse), gst_buffer_ref (buffer));
3053   }
3054 
3055   gst_caps_unref (caps);
3056 
3057   return ret;
3058 
3059 notfound:
3060   {
3061     if (caps) {
3062       gst_caps_unref (caps);
3063     }
3064 
3065     GST_DEBUG_OBJECT (parse, &quot;No streamheader on caps&quot;);
3066     return GST_FLOW_OK;
3067   }
3068 }
3069 
3070 static GstFlowReturn
3071 gst_base_parse_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
3072 {
3073   GstBaseParseClass *bclass;
3074   GstBaseParse *parse;
3075   GstFlowReturn ret = GST_FLOW_OK;
3076   GstFlowReturn old_ret = GST_FLOW_OK;
3077   GstBuffer *tmpbuf = NULL;
3078   guint fsize = 1;
3079   gint skip = -1;
3080   guint min_size, av;
3081   GstClockTime pts, dts;
3082 
3083   parse = GST_BASE_PARSE (parent);
3084   bclass = GST_BASE_PARSE_GET_CLASS (parse);
3085   GST_DEBUG_OBJECT (parent, &quot;chain&quot;);
3086 
3087   /* early out for speed, if we need to skip */
3088   if (buffer &amp;&amp; GST_BUFFER_IS_DISCONT (buffer))
3089     parse-&gt;priv-&gt;skip = 0;
3090   if (parse-&gt;priv-&gt;skip &gt; 0) {
3091     gsize bsize = gst_buffer_get_size (buffer);
3092     GST_DEBUG (&quot;Got %&quot; G_GSIZE_FORMAT &quot; buffer, need to skip %u&quot;, bsize,
3093         parse-&gt;priv-&gt;skip);
3094     if (parse-&gt;priv-&gt;skip &gt;= bsize) {
3095       parse-&gt;priv-&gt;skip -= bsize;
3096       GST_DEBUG (&quot;All the buffer is skipped&quot;);
3097       parse-&gt;priv-&gt;offset += bsize;
3098       parse-&gt;priv-&gt;sync_offset = parse-&gt;priv-&gt;offset;
3099       return GST_FLOW_OK;
3100     }
3101     buffer = gst_buffer_make_writable (buffer);
3102     gst_buffer_resize (buffer, parse-&gt;priv-&gt;skip, bsize - parse-&gt;priv-&gt;skip);
3103     parse-&gt;priv-&gt;offset += parse-&gt;priv-&gt;skip;
3104     GST_DEBUG (&quot;Done skipping, we have %u left on this buffer&quot;,
3105         (unsigned) (bsize - parse-&gt;priv-&gt;skip));
3106     parse-&gt;priv-&gt;skip = 0;
3107     parse-&gt;priv-&gt;discont = TRUE;
3108   }
3109 
3110   if (G_UNLIKELY (parse-&gt;priv-&gt;first_buffer)) {
3111     parse-&gt;priv-&gt;first_buffer = FALSE;
3112     if (!GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_HEADER)) {
3113       /* this stream has no header buffers, check if we just prepend the
3114        * streamheader from caps to the stream */
3115       GST_DEBUG_OBJECT (parse, &quot;Looking for streamheader field on caps to &quot;
3116           &quot;prepend to the stream&quot;);
3117       gst_base_parse_process_streamheader (parse);
3118     } else {
3119       GST_DEBUG_OBJECT (parse, &quot;Stream has header buffers, not prepending &quot;
3120           &quot;streamheader from caps&quot;);
3121     }
3122   }
3123 
3124   if (parse-&gt;priv-&gt;detecting) {
3125     GstBuffer *detect_buf;
3126 
3127     if (parse-&gt;priv-&gt;detect_buffers_size == 0) {
3128       detect_buf = gst_buffer_ref (buffer);
3129     } else {
3130       GList *l;
3131       guint offset = 0;
3132 
3133       detect_buf = gst_buffer_new ();
3134 
3135       for (l = parse-&gt;priv-&gt;detect_buffers; l; l = l-&gt;next) {
3136         gsize tmpsize = gst_buffer_get_size (l-&gt;data);
3137 
3138         gst_buffer_copy_into (detect_buf, GST_BUFFER_CAST (l-&gt;data),
3139             GST_BUFFER_COPY_MEMORY, offset, tmpsize);
3140         offset += tmpsize;
3141       }
3142       if (buffer)
3143         gst_buffer_copy_into (detect_buf, buffer, GST_BUFFER_COPY_MEMORY,
3144             offset, gst_buffer_get_size (buffer));
3145     }
3146 
3147     ret = bclass-&gt;detect (parse, detect_buf);
3148     gst_buffer_unref (detect_buf);
3149 
3150     if (ret == GST_FLOW_OK) {
3151       GList *l;
3152 
3153       /* Detected something */
3154       parse-&gt;priv-&gt;detecting = FALSE;
3155 
3156       for (l = parse-&gt;priv-&gt;detect_buffers; l; l = l-&gt;next) {
3157         if (ret == GST_FLOW_OK &amp;&amp; !parse-&gt;priv-&gt;flushing)
3158           ret =
3159               gst_base_parse_chain (GST_BASE_PARSE_SINK_PAD (parse),
3160               parent, GST_BUFFER_CAST (l-&gt;data));
3161         else
3162           gst_buffer_unref (GST_BUFFER_CAST (l-&gt;data));
3163       }
3164       g_list_free (parse-&gt;priv-&gt;detect_buffers);
3165       parse-&gt;priv-&gt;detect_buffers = NULL;
3166       parse-&gt;priv-&gt;detect_buffers_size = 0;
3167 
3168       if (ret != GST_FLOW_OK) {
3169         return ret;
3170       }
3171 
3172       /* Handle the current buffer */
3173     } else if (ret == GST_FLOW_NOT_NEGOTIATED) {
3174       /* Still detecting, append buffer or error out if draining */
3175 
3176       if (parse-&gt;priv-&gt;drain) {
3177         GST_DEBUG_OBJECT (parse, &quot;Draining but did not detect format yet&quot;);
3178         return GST_FLOW_ERROR;
3179       } else if (parse-&gt;priv-&gt;flushing) {
3180         g_list_foreach (parse-&gt;priv-&gt;detect_buffers, (GFunc) gst_buffer_unref,
3181             NULL);
3182         g_list_free (parse-&gt;priv-&gt;detect_buffers);
3183         parse-&gt;priv-&gt;detect_buffers = NULL;
3184         parse-&gt;priv-&gt;detect_buffers_size = 0;
3185       } else {
3186         parse-&gt;priv-&gt;detect_buffers =
3187             g_list_append (parse-&gt;priv-&gt;detect_buffers, buffer);
3188         parse-&gt;priv-&gt;detect_buffers_size += gst_buffer_get_size (buffer);
3189         return GST_FLOW_OK;
3190       }
3191     } else {
3192       /* Something went wrong, subclass responsible for error reporting */
3193       return ret;
3194     }
3195 
3196     /* And now handle the current buffer if detection worked */
3197   }
3198 
3199   if (G_LIKELY (buffer)) {
3200     GST_LOG_OBJECT (parse,
3201         &quot;buffer size: %&quot; G_GSIZE_FORMAT &quot;, offset = %&quot; G_GINT64_FORMAT
3202         &quot;, dts %&quot; GST_TIME_FORMAT &quot;, pts %&quot; GST_TIME_FORMAT,
3203         gst_buffer_get_size (buffer), GST_BUFFER_OFFSET (buffer),
3204         GST_TIME_ARGS (GST_BUFFER_DTS (buffer)),
3205         GST_TIME_ARGS (GST_BUFFER_PTS (buffer)));
3206 
3207     if (G_UNLIKELY (!parse-&gt;priv-&gt;disable_passthrough
3208             &amp;&amp; parse-&gt;priv-&gt;passthrough)) {
3209       GstBaseParseFrame frame;
3210 
3211       gst_base_parse_frame_init (&amp;frame);
3212       frame.buffer = gst_buffer_make_writable (buffer);
3213       ret = gst_base_parse_push_frame (parse, &amp;frame);
3214       gst_base_parse_frame_free (&amp;frame);
3215       return ret;
3216     }
3217     if (G_UNLIKELY (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT))) {
3218       /* upstream feeding us in reverse playback;
3219        * finish previous fragment and start new upon DISCONT */
3220       if (parse-&gt;segment.rate &lt; 0.0) {
3221         GST_DEBUG_OBJECT (parse, &quot;buffer starts new reverse playback fragment&quot;);
3222         ret = gst_base_parse_finish_fragment (parse, TRUE);
3223         gst_base_parse_start_fragment (parse);
3224       } else {
3225         /* discont in the stream, drain and mark discont for next output */
3226         gst_base_parse_drain (parse);
3227         parse-&gt;priv-&gt;discont = TRUE;
3228       }
3229     }
3230     gst_adapter_push (parse-&gt;priv-&gt;adapter, buffer);
3231   }
3232 
3233   /* Parse and push as many frames as possible */
3234   /* Stop either when adapter is empty or we are flushing */
3235   while (!parse-&gt;priv-&gt;flushing) {
3236     gint flush = 0;
3237     gboolean updated_prev_pts = FALSE;
3238 
3239     /* note: if subclass indicates MAX fsize,
3240      * this will not likely be available anyway ... */
3241     min_size = MAX (parse-&gt;priv-&gt;min_frame_size, fsize);
3242     av = gst_adapter_available (parse-&gt;priv-&gt;adapter);
3243 
3244     if (G_UNLIKELY (parse-&gt;priv-&gt;drain)) {
3245       min_size = av;
3246       GST_DEBUG_OBJECT (parse, &quot;draining, data left: %d&quot;, min_size);
3247       if (G_UNLIKELY (!min_size)) {
3248         goto done;
3249       }
3250     }
3251 
3252     /* Collect at least min_frame_size bytes */
3253     if (av &lt; min_size) {
3254       GST_DEBUG_OBJECT (parse, &quot;not enough data available (only %d bytes)&quot;, av);
3255       goto done;
3256     }
3257 
3258     /* move along with upstream timestamp (if any),
3259      * but interpolate in between */
3260     pts = gst_adapter_prev_pts (parse-&gt;priv-&gt;adapter, NULL);
3261     dts = gst_adapter_prev_dts (parse-&gt;priv-&gt;adapter, NULL);
3262     if (GST_CLOCK_TIME_IS_VALID (pts) &amp;&amp; (parse-&gt;priv-&gt;prev_pts != pts)) {
3263       parse-&gt;priv-&gt;prev_pts = parse-&gt;priv-&gt;next_pts = pts;
3264       updated_prev_pts = TRUE;
3265     }
3266 
3267     if (GST_CLOCK_TIME_IS_VALID (dts) &amp;&amp; (parse-&gt;priv-&gt;prev_dts != dts)) {
3268       parse-&gt;priv-&gt;prev_dts = parse-&gt;priv-&gt;next_dts = dts;
3269       parse-&gt;priv-&gt;prev_dts_from_pts = FALSE;
3270     }
3271 
3272     /* we can mess with, erm interpolate, timestamps,
3273      * and incoming stuff has PTS but no DTS seen so far,
3274      * then pick up DTS from PTS and hope for the best ... */
3275     if (parse-&gt;priv-&gt;infer_ts &amp;&amp;
3276         parse-&gt;priv-&gt;pts_interpolate &amp;&amp;
3277         !GST_CLOCK_TIME_IS_VALID (dts) &amp;&amp;
3278         (!GST_CLOCK_TIME_IS_VALID (parse-&gt;priv-&gt;prev_dts)
3279             || (parse-&gt;priv-&gt;prev_dts_from_pts &amp;&amp; updated_prev_pts))
3280         &amp;&amp; GST_CLOCK_TIME_IS_VALID (pts)) {
3281       parse-&gt;priv-&gt;prev_dts = parse-&gt;priv-&gt;next_dts = pts;
3282       parse-&gt;priv-&gt;prev_dts_from_pts = TRUE;
3283     }
3284 
3285     /* always pass all available data */
3286     tmpbuf = gst_adapter_get_buffer (parse-&gt;priv-&gt;adapter, av);
3287 
3288     /* already inform subclass what timestamps we have planned,
3289      * at least if provided by time-based upstream */
3290     if (parse-&gt;priv-&gt;upstream_format == GST_FORMAT_TIME) {
3291       tmpbuf = gst_buffer_make_writable (tmpbuf);
3292       GST_BUFFER_PTS (tmpbuf) = parse-&gt;priv-&gt;next_pts;
3293       GST_BUFFER_DTS (tmpbuf) = parse-&gt;priv-&gt;next_dts;
3294       GST_BUFFER_DURATION (tmpbuf) = GST_CLOCK_TIME_NONE;
3295     }
3296 
3297     /* keep the adapter mapped, so keep track of what has to be flushed */
3298     ret = gst_base_parse_handle_buffer (parse, tmpbuf, &amp;skip, &amp;flush);
3299     tmpbuf = NULL;
3300 
3301     if (ret != GST_FLOW_OK &amp;&amp; ret != GST_FLOW_NOT_LINKED) {
3302       goto done;
3303     }
3304     if (skip == 0 &amp;&amp; flush == 0) {
3305       GST_LOG_OBJECT (parse, &quot;nothing skipped and no frames finished, &quot;
3306           &quot;breaking to get more data&quot;);
3307       /* ignore this return as it produced no data */
3308       ret = old_ret;
3309       goto done;
3310     }
3311     if (old_ret == GST_FLOW_OK)
3312       old_ret = ret;
3313   }
3314 
3315 done:
3316   GST_LOG_OBJECT (parse, &quot;chain leaving&quot;);
3317   return ret;
3318 }
3319 
3320 /* pull @size bytes at current offset,
3321  * i.e. at least try to and possibly return a shorter buffer if near the end */
3322 static GstFlowReturn
3323 gst_base_parse_pull_range (GstBaseParse * parse, guint size,
3324     GstBuffer ** buffer)
3325 {
3326   GstFlowReturn ret = GST_FLOW_OK;
3327 
3328   g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
3329 
3330   /* Caching here actually makes much less difference than one would expect.
3331    * We do it mainly to avoid pulling buffers of 1 byte all the time */
3332   if (parse-&gt;priv-&gt;cache) {
3333     gint64 cache_offset = GST_BUFFER_OFFSET (parse-&gt;priv-&gt;cache);
3334     gint cache_size = gst_buffer_get_size (parse-&gt;priv-&gt;cache);
3335 
3336     if (cache_offset &lt;= parse-&gt;priv-&gt;offset &amp;&amp;
3337         (parse-&gt;priv-&gt;offset + size) &lt;= (cache_offset + cache_size)) {
3338       *buffer = gst_buffer_copy_region (parse-&gt;priv-&gt;cache, GST_BUFFER_COPY_ALL,
3339           parse-&gt;priv-&gt;offset - cache_offset, size);
3340 #ifdef GSTREAMER_LITE
3341       if (buffer == NULL)
3342         return GST_FLOW_ERROR;
3343 #endif // GSTREAMER_LITE
3344       GST_BUFFER_OFFSET (*buffer) = parse-&gt;priv-&gt;offset;
3345       return GST_FLOW_OK;
3346     }
3347     /* not enough data in the cache, free cache and get a new one */
3348     gst_buffer_unref (parse-&gt;priv-&gt;cache);
3349     parse-&gt;priv-&gt;cache = NULL;
3350   }
3351 
3352   /* refill the cache */
3353   ret =
3354       gst_pad_pull_range (parse-&gt;sinkpad, parse-&gt;priv-&gt;offset, MAX (size,
3355           64 * 1024), &amp;parse-&gt;priv-&gt;cache);
3356   if (ret != GST_FLOW_OK) {
3357     parse-&gt;priv-&gt;cache = NULL;
3358     return ret;
3359   }
3360 
3361   if (gst_buffer_get_size (parse-&gt;priv-&gt;cache) &lt; size) {
3362     GST_DEBUG_OBJECT (parse, &quot;Returning short buffer at offset %&quot;
3363         G_GUINT64_FORMAT &quot;: wanted %u bytes, got %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
3364         parse-&gt;priv-&gt;offset, size, gst_buffer_get_size (parse-&gt;priv-&gt;cache));
3365 
3366     *buffer = parse-&gt;priv-&gt;cache;
3367     parse-&gt;priv-&gt;cache = NULL;
3368 
3369     return GST_FLOW_OK;
3370   }
3371 
3372   *buffer =
3373       gst_buffer_copy_region (parse-&gt;priv-&gt;cache, GST_BUFFER_COPY_ALL, 0, size);
3374 #ifdef GSTREAMER_LITE
3375   if (buffer == NULL)
3376     return GST_FLOW_ERROR;
3377 #endif // GSTREAMER_LITE
3378   GST_BUFFER_OFFSET (*buffer) = parse-&gt;priv-&gt;offset;
3379 
3380   return GST_FLOW_OK;
3381 }
3382 
3383 static GstFlowReturn
3384 gst_base_parse_handle_previous_fragment (GstBaseParse * parse)
3385 {
3386   gint64 offset = 0;
3387   GstClockTime ts = 0;
3388   GstBuffer *buffer;
3389   GstFlowReturn ret;
3390 
3391   GST_DEBUG_OBJECT (parse, &quot;fragment ended; last_ts = %&quot; GST_TIME_FORMAT
3392       &quot;, last_offset = %&quot; G_GINT64_FORMAT,
3393       GST_TIME_ARGS (parse-&gt;priv-&gt;last_pts), parse-&gt;priv-&gt;last_offset);
3394 
3395   if (!parse-&gt;priv-&gt;last_offset
3396       || parse-&gt;priv-&gt;last_pts &lt;= parse-&gt;segment.start) {
3397     GST_DEBUG_OBJECT (parse, &quot;past start of segment %&quot; GST_TIME_FORMAT,
3398         GST_TIME_ARGS (parse-&gt;segment.start));
3399     ret = GST_FLOW_EOS;
3400     goto exit;
3401   }
3402 
3403   /* last fragment started at last_offset / last_ts;
3404    * seek back 10s capped at 1MB */
3405   if (parse-&gt;priv-&gt;last_pts &gt;= 10 * GST_SECOND)
3406     ts = parse-&gt;priv-&gt;last_pts - 10 * GST_SECOND;
3407   /* if we are exact now, we will be more so going backwards */
3408   if (parse-&gt;priv-&gt;exact_position) {
3409     offset = gst_base_parse_find_offset (parse, ts, TRUE, NULL);
3410   } else {
3411     if (!gst_base_parse_convert (parse, GST_FORMAT_TIME, ts,
3412             GST_FORMAT_BYTES, &amp;offset)) {
3413       GST_DEBUG_OBJECT (parse, &quot;conversion failed, only BYTE based&quot;);
3414     }
3415   }
3416   offset = CLAMP (offset, parse-&gt;priv-&gt;last_offset - 1024 * 1024,
3417       parse-&gt;priv-&gt;last_offset - 1024);
3418   offset = MAX (0, offset);
3419 
3420   GST_DEBUG_OBJECT (parse, &quot;next fragment from offset %&quot; G_GINT64_FORMAT,
3421       offset);
3422   parse-&gt;priv-&gt;offset = offset;
3423 
3424   ret = gst_base_parse_pull_range (parse, parse-&gt;priv-&gt;last_offset - offset,
3425       &amp;buffer);
3426   if (ret != GST_FLOW_OK)
3427     goto exit;
3428 
3429   /* offset will increase again as fragment is processed/parsed */
3430   parse-&gt;priv-&gt;last_offset = offset;
3431 
3432   gst_base_parse_start_fragment (parse);
3433   gst_adapter_push (parse-&gt;priv-&gt;adapter, buffer);
3434   ret = gst_base_parse_finish_fragment (parse, TRUE);
3435   if (ret != GST_FLOW_OK)
3436     goto exit;
3437 
3438   /* force previous fragment */
3439   parse-&gt;priv-&gt;offset = -1;
3440 
3441 exit:
3442   return ret;
3443 }
3444 
3445 /* PULL mode:
3446  * pull and scan for next frame starting from current offset
3447  * ajusts sync, drain and offset going along */
3448 static GstFlowReturn
3449 gst_base_parse_scan_frame (GstBaseParse * parse, GstBaseParseClass * klass)
3450 {
3451   GstBuffer *buffer;
3452   GstFlowReturn ret = GST_FLOW_OK;
3453   guint fsize, min_size;
3454   gint flushed = 0;
3455   gint skip = 0;
3456 
3457   GST_LOG_OBJECT (parse, &quot;scanning for frame at offset %&quot; G_GUINT64_FORMAT
3458       &quot; (%#&quot; G_GINT64_MODIFIER &quot;x)&quot;, parse-&gt;priv-&gt;offset, parse-&gt;priv-&gt;offset);
3459 
3460   /* let&#39;s make this efficient for all subclass once and for all;
3461    * maybe it does not need this much, but in the latter case, we know we are
3462    * in pull mode here and might as well try to read and supply more anyway
3463    * (so does the buffer caching mechanism) */
3464   fsize = 64 * 1024;
3465 
3466   while (TRUE) {
3467     min_size = MAX (parse-&gt;priv-&gt;min_frame_size, fsize);
3468 
3469     GST_LOG_OBJECT (parse, &quot;reading buffer size %u&quot;, min_size);
3470 
3471     ret = gst_base_parse_pull_range (parse, min_size, &amp;buffer);
3472     if (ret != GST_FLOW_OK)
3473       goto done;
3474 
3475     /* if we got a short read, inform subclass we are draining leftover
3476      * and no more is to be expected */
3477     if (gst_buffer_get_size (buffer) &lt; min_size) {
3478       GST_LOG_OBJECT (parse, &quot;... but did not get that; marked draining&quot;);
3479       parse-&gt;priv-&gt;drain = TRUE;
3480     }
3481 
3482     if (parse-&gt;priv-&gt;detecting) {
3483       ret = klass-&gt;detect (parse, buffer);
3484       if (ret == GST_FLOW_NOT_NEGOTIATED) {
3485         /* If draining we error out, otherwise request a buffer
3486          * with 64kb more */
3487         if (parse-&gt;priv-&gt;drain) {
3488           gst_buffer_unref (buffer);
3489           GST_ERROR_OBJECT (parse, &quot;Failed to detect format but draining&quot;);
3490           return GST_FLOW_ERROR;
3491         } else {
3492           fsize += 64 * 1024;
3493           gst_buffer_unref (buffer);
3494           continue;
3495         }
3496       } else if (ret != GST_FLOW_OK) {
3497         gst_buffer_unref (buffer);
3498         GST_ERROR_OBJECT (parse, &quot;detect() returned %s&quot;,
3499             gst_flow_get_name (ret));
3500         return ret;
3501       }
3502 
3503       /* Else handle this buffer normally */
3504     }
3505 
3506     ret = gst_base_parse_handle_buffer (parse, buffer, &amp;skip, &amp;flushed);
3507     if (ret != GST_FLOW_OK)
3508       break;
3509 
3510     /* If a large amount of data was requested to be skipped, _handle_buffer
3511        might have set the priv-&gt;skip flag to an extra amount on top of skip.
3512        In pull mode, we can just pull from the new offset directly. */
3513     parse-&gt;priv-&gt;offset += parse-&gt;priv-&gt;skip;
3514     parse-&gt;priv-&gt;skip = 0;
3515 
3516     /* something flushed means something happened,
3517      * and we should bail out of this loop so as not to occupy
3518      * the task thread indefinitely */
3519     if (flushed) {
3520       GST_LOG_OBJECT (parse, &quot;frame finished, breaking loop&quot;);
3521       break;
3522     }
3523     /* nothing flushed, no skip and draining, so nothing left to do */
3524     if (!skip &amp;&amp; parse-&gt;priv-&gt;drain) {
3525       GST_LOG_OBJECT (parse, &quot;no activity or result when draining; &quot;
3526           &quot;breaking loop and marking EOS&quot;);
3527       ret = GST_FLOW_EOS;
3528       break;
3529     }
3530     /* otherwise, get some more data
3531      * note that is checked this does not happen indefinitely */
3532     if (!skip) {
3533       GST_LOG_OBJECT (parse, &quot;getting some more data&quot;);
3534       fsize += 64 * 1024;
3535     }
3536     parse-&gt;priv-&gt;drain = FALSE;
3537   }
3538 
3539 done:
3540   return ret;
3541 }
3542 
3543 /* Loop that is used in pull mode to retrieve data from upstream */
3544 static void
3545 gst_base_parse_loop (GstPad * pad)
3546 {
3547   GstBaseParse *parse;
3548   GstBaseParseClass *klass;
3549   GstFlowReturn ret = GST_FLOW_OK;
3550 
3551   parse = GST_BASE_PARSE (gst_pad_get_parent (pad));
3552   klass = GST_BASE_PARSE_GET_CLASS (parse);
3553 
3554   GST_LOG_OBJECT (parse, &quot;Entering parse loop&quot;);
3555 
3556   if (G_UNLIKELY (parse-&gt;priv-&gt;push_stream_start)) {
3557     gchar *stream_id;
3558     GstEvent *event;
3559 
3560     stream_id =
3561         gst_pad_create_stream_id (parse-&gt;srcpad, GST_ELEMENT_CAST (parse),
3562         NULL);
3563 
3564     event = gst_event_new_stream_start (stream_id);
3565     gst_event_set_group_id (event, gst_util_group_id_next ());
3566 
3567     GST_DEBUG_OBJECT (parse, &quot;Pushing STREAM_START&quot;);
3568     gst_pad_push_event (parse-&gt;srcpad, event);
3569     parse-&gt;priv-&gt;push_stream_start = FALSE;
3570     g_free (stream_id);
3571   }
3572 
3573   /* reverse playback:
3574    * first fragment (closest to stop time) is handled normally below,
3575    * then we pull in fragments going backwards */
3576   if (parse-&gt;segment.rate &lt; 0.0) {
3577     /* check if we jumped back to a previous fragment,
3578      * which is a post-first fragment */
3579     if (parse-&gt;priv-&gt;offset &lt; 0) {
3580       ret = gst_base_parse_handle_previous_fragment (parse);
3581       goto done;
3582     }
3583   }
3584 
3585   ret = gst_base_parse_scan_frame (parse, klass);
3586 
3587   /* eat expected eos signalling past segment in reverse playback */
3588   if (parse-&gt;segment.rate &lt; 0.0 &amp;&amp; ret == GST_FLOW_EOS &amp;&amp;
3589       parse-&gt;segment.position &gt;= parse-&gt;segment.stop) {
3590     GST_DEBUG_OBJECT (parse, &quot;downstream has reached end of segment&quot;);
3591     /* push what was accumulated during loop run */
3592     gst_base_parse_finish_fragment (parse, FALSE);
3593     /* force previous fragment */
3594     parse-&gt;priv-&gt;offset = -1;
3595     goto eos;
3596   }
3597 
3598   if (ret != GST_FLOW_OK)
3599     goto done;
3600 
3601 done:
3602   if (ret == GST_FLOW_EOS)
3603     goto eos;
3604   else if (ret != GST_FLOW_OK)
3605     goto pause;
3606 
3607   gst_object_unref (parse);
3608   return;
3609 
3610   /* ERRORS */
3611 eos:
3612   {
3613     ret = GST_FLOW_EOS;
3614     GST_DEBUG_OBJECT (parse, &quot;eos&quot;);
3615     /* fall-through */
3616   }
3617 pause:
3618   {
3619     gboolean push_eos = FALSE;
3620 
3621     GST_DEBUG_OBJECT (parse, &quot;pausing task, reason %s&quot;,
3622         gst_flow_get_name (ret));
3623     gst_pad_pause_task (parse-&gt;sinkpad);
3624 
3625     if (ret == GST_FLOW_EOS) {
3626       /* handle end-of-stream/segment */
3627       if (parse-&gt;segment.flags &amp; GST_SEGMENT_FLAG_SEGMENT) {
3628         gint64 stop;
3629 
3630         if ((stop = parse-&gt;segment.stop) == -1)
3631           stop = parse-&gt;segment.duration;
3632 
3633         GST_DEBUG_OBJECT (parse, &quot;sending segment_done&quot;);
3634 
3635         gst_element_post_message
3636             (GST_ELEMENT_CAST (parse),
3637             gst_message_new_segment_done (GST_OBJECT_CAST (parse),
3638                 GST_FORMAT_TIME, stop));
3639         gst_pad_push_event (parse-&gt;srcpad,
3640             gst_event_new_segment_done (GST_FORMAT_TIME, stop));
3641       } else {
3642         /* If we STILL have zero frames processed, fire an error */
3643         if (parse-&gt;priv-&gt;framecount == 0) {
3644           GST_ELEMENT_ERROR (parse, STREAM, WRONG_TYPE,
3645               (&quot;No valid frames found before end of stream&quot;), (NULL));
3646         }
3647         push_eos = TRUE;
3648       }
3649     } else if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS) {
3650       /* for fatal errors we post an error message, wrong-state is
3651        * not fatal because it happens due to flushes and only means
3652        * that we should stop now. */
3653       GST_ELEMENT_FLOW_ERROR (parse, ret);
3654       push_eos = TRUE;
3655     }
3656     if (push_eos) {
3657       GstEvent *topush;
3658       if (parse-&gt;priv-&gt;estimated_duration &lt;= 0) {
3659         gst_base_parse_update_duration (parse);
3660       }
3661       /* Push pending events, including SEGMENT events */
3662       gst_base_parse_push_pending_events (parse);
3663 
3664       topush = gst_event_new_eos ();
3665       GST_DEBUG_OBJECT (parse, &quot;segment_seqnum:%&quot; G_GUINT32_FORMAT,
3666           parse-&gt;priv-&gt;segment_seqnum);
3667       if (parse-&gt;priv-&gt;segment_seqnum != GST_SEQNUM_INVALID)
3668         gst_event_set_seqnum (topush, parse-&gt;priv-&gt;segment_seqnum);
3669       gst_pad_push_event (parse-&gt;srcpad, topush);
3670     }
3671     gst_object_unref (parse);
3672   }
3673 }
3674 
3675 static gboolean
3676 gst_base_parse_sink_activate (GstPad * sinkpad, GstObject * parent)
3677 {
3678   GstSchedulingFlags sched_flags;
3679   GstBaseParse *parse;
3680   GstQuery *query;
3681   gboolean pull_mode;
3682 
3683   parse = GST_BASE_PARSE (parent);
3684 
3685   GST_DEBUG_OBJECT (parse, &quot;sink activate&quot;);
3686 
3687   query = gst_query_new_scheduling ();
3688   if (!gst_pad_peer_query (sinkpad, query)) {
3689     gst_query_unref (query);
3690     goto baseparse_push;
3691   }
3692 
3693   gst_query_parse_scheduling (query, &amp;sched_flags, NULL, NULL, NULL);
3694 
3695   pull_mode = gst_query_has_scheduling_mode (query, GST_PAD_MODE_PULL)
3696       &amp;&amp; ((sched_flags &amp; GST_SCHEDULING_FLAG_SEEKABLE) != 0);
3697 
3698   gst_query_unref (query);
3699 
3700   if (!pull_mode)
3701     goto baseparse_push;
3702 
3703   GST_DEBUG_OBJECT (parse, &quot;trying to activate in pull mode&quot;);
3704   if (!gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PULL, TRUE))
3705     goto baseparse_push;
3706 
3707   parse-&gt;priv-&gt;push_stream_start = TRUE;
3708   /* In pull mode, upstream is BYTES */
3709   parse-&gt;priv-&gt;upstream_format = GST_FORMAT_BYTES;
3710 
3711   return gst_pad_start_task (sinkpad, (GstTaskFunction) gst_base_parse_loop,
3712       sinkpad, NULL);
3713   /* fallback */
3714 baseparse_push:
3715   {
3716     GST_DEBUG_OBJECT (parse, &quot;trying to activate in push mode&quot;);
3717     return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PUSH, TRUE);
3718   }
3719 }
3720 
3721 static gboolean
3722 gst_base_parse_activate (GstBaseParse * parse, gboolean active)
3723 {
3724   GstBaseParseClass *klass;
3725   gboolean result = TRUE;
3726 
3727   GST_DEBUG_OBJECT (parse, &quot;activate %d&quot;, active);
3728 
3729   klass = GST_BASE_PARSE_GET_CLASS (parse);
3730 
3731   if (active) {
3732     if (parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_NONE &amp;&amp; klass-&gt;start)
3733       result = klass-&gt;start (parse);
3734 
3735     /* If the subclass implements ::detect we want to
3736      * call it for the first buffers now */
3737     parse-&gt;priv-&gt;detecting = (klass-&gt;detect != NULL);
3738   } else {
3739     /* We must make sure streaming has finished before resetting things
3740      * and calling the ::stop vfunc */
3741     GST_PAD_STREAM_LOCK (parse-&gt;sinkpad);
3742     GST_PAD_STREAM_UNLOCK (parse-&gt;sinkpad);
3743 
3744     if (parse-&gt;priv-&gt;pad_mode != GST_PAD_MODE_NONE &amp;&amp; klass-&gt;stop)
3745       result = klass-&gt;stop (parse);
3746 
3747     parse-&gt;priv-&gt;pad_mode = GST_PAD_MODE_NONE;
3748     parse-&gt;priv-&gt;upstream_format = GST_FORMAT_UNDEFINED;
3749   }
3750   GST_DEBUG_OBJECT (parse, &quot;activate return: %d&quot;, result);
3751   return result;
3752 }
3753 
3754 static gboolean
3755 gst_base_parse_sink_activate_mode (GstPad * pad, GstObject * parent,
3756     GstPadMode mode, gboolean active)
3757 {
3758   gboolean result;
3759   GstBaseParse *parse;
3760 
3761   parse = GST_BASE_PARSE (parent);
3762 
3763   GST_DEBUG_OBJECT (parse, &quot;sink %sactivate in %s mode&quot;,
3764       (active) ? &quot;&quot; : &quot;de&quot;, gst_pad_mode_get_name (mode));
3765 
3766   if (!gst_base_parse_activate (parse, active))
3767     goto activate_failed;
3768 
3769   switch (mode) {
3770     case GST_PAD_MODE_PULL:
3771       if (active) {
3772         GstEvent *ev = gst_event_new_segment (&amp;parse-&gt;segment);
3773         parse-&gt;priv-&gt;segment_seqnum = gst_event_get_seqnum (ev);
3774         parse-&gt;priv-&gt;pending_events =
3775             g_list_prepend (parse-&gt;priv-&gt;pending_events, ev);
3776         result = TRUE;
3777       } else {
3778         result = gst_pad_stop_task (pad);
3779       }
3780       break;
3781     default:
3782       result = TRUE;
3783       break;
3784   }
3785   if (result)
3786     parse-&gt;priv-&gt;pad_mode = active ? mode : GST_PAD_MODE_NONE;
3787 
3788   GST_DEBUG_OBJECT (parse, &quot;sink activate return: %d&quot;, result);
3789 
3790   return result;
3791 
3792   /* ERRORS */
3793 activate_failed:
3794   {
3795     GST_DEBUG_OBJECT (parse, &quot;activate failed&quot;);
3796     return FALSE;
3797   }
3798 }
3799 
3800 /**
3801  * gst_base_parse_set_duration:
3802  * @parse: #GstBaseParse.
3803  * @fmt: #GstFormat.
3804  * @duration: duration value.
3805  * @interval: how often to update the duration estimate based on bitrate, or 0.
3806  *
3807  * Sets the duration of the currently playing media. Subclass can use this
3808  * when it is able to determine duration and/or notices a change in the media
3809  * duration.  Alternatively, if @interval is non-zero (default), then stream
3810  * duration is determined based on estimated bitrate, and updated every @interval
3811  * frames.
3812  */
3813 void
3814 gst_base_parse_set_duration (GstBaseParse * parse,
3815     GstFormat fmt, gint64 duration, gint interval)
3816 {
3817   g_return_if_fail (parse != NULL);
3818 
3819   if (parse-&gt;priv-&gt;upstream_has_duration) {
3820     GST_DEBUG_OBJECT (parse, &quot;using upstream duration; discarding update&quot;);
3821     goto exit;
3822   }
3823 
3824   if (duration != parse-&gt;priv-&gt;duration) {
3825     GstMessage *m;
3826 
3827     m = gst_message_new_duration_changed (GST_OBJECT (parse));
3828     gst_element_post_message (GST_ELEMENT (parse), m);
3829 
3830     /* TODO: what about duration tag? */
3831   }
3832   parse-&gt;priv-&gt;duration = duration;
3833   parse-&gt;priv-&gt;duration_fmt = fmt;
3834   GST_DEBUG_OBJECT (parse, &quot;set duration: %&quot; G_GINT64_FORMAT, duration);
3835   if (fmt == GST_FORMAT_TIME &amp;&amp; GST_CLOCK_TIME_IS_VALID (duration)) {
3836     if (interval != 0) {
3837       GST_DEBUG_OBJECT (parse, &quot;valid duration provided, disabling estimate&quot;);
3838       interval = 0;
3839     }
3840   }
3841   GST_DEBUG_OBJECT (parse, &quot;set update interval: %d&quot;, interval);
3842   parse-&gt;priv-&gt;update_interval = interval;
3843 exit:
3844   return;
3845 }
3846 
3847 /**
3848  * gst_base_parse_set_average_bitrate:
3849  * @parse: #GstBaseParse.
3850  * @bitrate: average bitrate in bits/second
3851  *
3852  * Optionally sets the average bitrate detected in media (if non-zero),
3853  * e.g. based on metadata, as it will be posted to the application.
3854  *
3855  * By default, announced average bitrate is estimated. The average bitrate
3856  * is used to estimate the total duration of the stream and to estimate
3857  * a seek position, if there&#39;s no index and the format is syncable
3858  * (see gst_base_parse_set_syncable()).
3859  */
3860 void
3861 gst_base_parse_set_average_bitrate (GstBaseParse * parse, guint bitrate)
3862 {
3863   parse-&gt;priv-&gt;bitrate = bitrate;
3864   GST_DEBUG_OBJECT (parse, &quot;bitrate %u&quot;, bitrate);
3865 }
3866 
3867 /**
3868  * gst_base_parse_set_min_frame_size:
3869  * @parse: #GstBaseParse.
3870  * @min_size: Minimum size in bytes of the data that this base class should
3871  *       give to subclass.
3872  *
3873  * Subclass can use this function to tell the base class that it needs to
3874  * be given buffers of at least @min_size bytes.
3875  */
3876 void
3877 gst_base_parse_set_min_frame_size (GstBaseParse * parse, guint min_size)
3878 {
3879   g_return_if_fail (parse != NULL);
3880 
3881   parse-&gt;priv-&gt;min_frame_size = min_size;
3882   GST_LOG_OBJECT (parse, &quot;set frame_min_size: %d&quot;, min_size);
3883 }
3884 
3885 /**
3886  * gst_base_parse_set_frame_rate:
3887  * @parse: the #GstBaseParse to set
3888  * @fps_num: frames per second (numerator).
3889  * @fps_den: frames per second (denominator).
3890  * @lead_in: frames needed before a segment for subsequent decode
3891  * @lead_out: frames needed after a segment
3892  *
3893  * If frames per second is configured, parser can take care of buffer duration
3894  * and timestamping.  When performing segment clipping, or seeking to a specific
3895  * location, a corresponding decoder might need an initial @lead_in and a
3896  * following @lead_out number of frames to ensure the desired segment is
3897  * entirely filled upon decoding.
3898  */
3899 void
3900 gst_base_parse_set_frame_rate (GstBaseParse * parse, guint fps_num,
3901     guint fps_den, guint lead_in, guint lead_out)
3902 {
3903   g_return_if_fail (parse != NULL);
3904 
3905   parse-&gt;priv-&gt;fps_num = fps_num;
3906   parse-&gt;priv-&gt;fps_den = fps_den;
3907   if (!fps_num || !fps_den) {
3908     GST_DEBUG_OBJECT (parse, &quot;invalid fps (%d/%d), ignoring parameters&quot;,
3909         fps_num, fps_den);
3910     fps_num = fps_den = 0;
3911     parse-&gt;priv-&gt;frame_duration = GST_CLOCK_TIME_NONE;
3912     parse-&gt;priv-&gt;lead_in = parse-&gt;priv-&gt;lead_out = 0;
3913     parse-&gt;priv-&gt;lead_in_ts = parse-&gt;priv-&gt;lead_out_ts = 0;
3914   } else {
3915     parse-&gt;priv-&gt;frame_duration =
3916         gst_util_uint64_scale (GST_SECOND, fps_den, fps_num);
3917     parse-&gt;priv-&gt;lead_in = lead_in;
3918     parse-&gt;priv-&gt;lead_out = lead_out;
3919     parse-&gt;priv-&gt;lead_in_ts =
3920         gst_util_uint64_scale (GST_SECOND, fps_den * lead_in, fps_num);
3921     parse-&gt;priv-&gt;lead_out_ts =
3922         gst_util_uint64_scale (GST_SECOND, fps_den * lead_out, fps_num);
3923     /* aim for about 1.5s to estimate duration */
3924     if (parse-&gt;priv-&gt;update_interval &lt; 0) {
3925       guint64 interval = gst_util_uint64_scale (fps_num, 3,
3926           G_GUINT64_CONSTANT (2) * fps_den);
3927 
3928       parse-&gt;priv-&gt;update_interval = MIN (interval, G_MAXINT);
3929 
3930       GST_LOG_OBJECT (parse, &quot;estimated update interval to %d frames&quot;,
3931           parse-&gt;priv-&gt;update_interval);
3932     }
3933   }
3934   GST_LOG_OBJECT (parse, &quot;set fps: %d/%d =&gt; duration: %&quot; G_GINT64_FORMAT &quot; ms&quot;,
3935       fps_num, fps_den, parse-&gt;priv-&gt;frame_duration / GST_MSECOND);
3936   GST_LOG_OBJECT (parse, &quot;set lead in: %d frames = %&quot; G_GUINT64_FORMAT &quot; ms, &quot;
3937       &quot;lead out: %d frames = %&quot; G_GUINT64_FORMAT &quot; ms&quot;,
3938       lead_in, parse-&gt;priv-&gt;lead_in_ts / GST_MSECOND,
3939       lead_out, parse-&gt;priv-&gt;lead_out_ts / GST_MSECOND);
3940 }
3941 
3942 /**
3943  * gst_base_parse_set_has_timing_info:
3944  * @parse: a #GstBaseParse
3945  * @has_timing: whether frames carry timing information
3946  *
3947  * Set if frames carry timing information which the subclass can (generally)
3948  * parse and provide.  In particular, intrinsic (rather than estimated) time
3949  * can be obtained following a seek.
3950  */
3951 void
3952 gst_base_parse_set_has_timing_info (GstBaseParse * parse, gboolean has_timing)
3953 {
3954   parse-&gt;priv-&gt;has_timing_info = has_timing;
3955   GST_INFO_OBJECT (parse, &quot;has_timing: %s&quot;, (has_timing) ? &quot;yes&quot; : &quot;no&quot;);
3956 }
3957 
3958 /**
3959  * gst_base_parse_set_syncable:
3960  * @parse: a #GstBaseParse
3961  * @syncable: set if frame starts can be identified
3962  *
3963  * Set if frame starts can be identified. This is set by default and
3964  * determines whether seeking based on bitrate averages
3965  * is possible for a format/stream.
3966  */
3967 void
3968 gst_base_parse_set_syncable (GstBaseParse * parse, gboolean syncable)
3969 {
3970   parse-&gt;priv-&gt;syncable = syncable;
3971   GST_INFO_OBJECT (parse, &quot;syncable: %s&quot;, (syncable) ? &quot;yes&quot; : &quot;no&quot;);
3972 }
3973 
3974 /**
3975  * gst_base_parse_set_passthrough:
3976  * @parse: a #GstBaseParse
3977  * @passthrough: %TRUE if parser should run in passthrough mode
3978  *
3979  * Set if the nature of the format or configuration does not allow (much)
3980  * parsing, and the parser should operate in passthrough mode (which only
3981  * applies when operating in push mode). That is, incoming buffers are
3982  * pushed through unmodified, i.e. no #GstBaseParseClass.handle_frame()
3983  * will be invoked, but #GstBaseParseClass.pre_push_frame() will still be
3984  * invoked, so subclass can perform as much or as little is appropriate for
3985  * passthrough semantics in #GstBaseParseClass.pre_push_frame().
3986  */
3987 void
3988 gst_base_parse_set_passthrough (GstBaseParse * parse, gboolean passthrough)
3989 {
3990   parse-&gt;priv-&gt;passthrough = passthrough;
3991   GST_INFO_OBJECT (parse, &quot;passthrough: %s&quot;, (passthrough) ? &quot;yes&quot; : &quot;no&quot;);
3992 }
3993 
3994 /**
3995  * gst_base_parse_set_pts_interpolation:
3996  * @parse: a #GstBaseParse
3997  * @pts_interpolate: %TRUE if parser should interpolate PTS timestamps
3998  *
3999  * By default, the base class will guess PTS timestamps using a simple
4000  * interpolation (previous timestamp + duration), which is incorrect for
4001  * data streams with reordering, where PTS can go backward. Sub-classes
4002  * implementing such formats should disable PTS interpolation.
4003  */
4004 void
4005 gst_base_parse_set_pts_interpolation (GstBaseParse * parse,
4006     gboolean pts_interpolate)
4007 {
4008   parse-&gt;priv-&gt;pts_interpolate = pts_interpolate;
4009   GST_INFO_OBJECT (parse, &quot;PTS interpolation: %s&quot;,
4010       (pts_interpolate) ? &quot;yes&quot; : &quot;no&quot;);
4011 }
4012 
4013 /**
4014  * gst_base_parse_set_infer_ts:
4015  * @parse: a #GstBaseParse
4016  * @infer_ts: %TRUE if parser should infer DTS/PTS from each other
4017  *
4018  * By default, the base class might try to infer PTS from DTS and vice
4019  * versa.  While this is generally correct for audio data, it may not
4020  * be otherwise. Sub-classes implementing such formats should disable
4021  * timestamp inferring.
4022  */
4023 void
4024 gst_base_parse_set_infer_ts (GstBaseParse * parse, gboolean infer_ts)
4025 {
4026   parse-&gt;priv-&gt;infer_ts = infer_ts;
4027   GST_INFO_OBJECT (parse, &quot;TS inferring: %s&quot;, (infer_ts) ? &quot;yes&quot; : &quot;no&quot;);
4028 }
4029 
4030 /**
4031  * gst_base_parse_set_latency:
4032  * @parse: a #GstBaseParse
4033  * @min_latency: minimum parse latency
4034  * @max_latency: maximum parse latency
4035  *
4036  * Sets the minimum and maximum (which may likely be equal) latency introduced
4037  * by the parsing process.  If there is such a latency, which depends on the
4038  * particular parsing of the format, it typically corresponds to 1 frame duration.
4039  */
4040 void
4041 gst_base_parse_set_latency (GstBaseParse * parse, GstClockTime min_latency,
4042     GstClockTime max_latency)
4043 {
4044   g_return_if_fail (min_latency != GST_CLOCK_TIME_NONE);
4045   g_return_if_fail (min_latency &lt;= max_latency);
4046 
4047   GST_OBJECT_LOCK (parse);
4048   parse-&gt;priv-&gt;min_latency = min_latency;
4049   parse-&gt;priv-&gt;max_latency = max_latency;
4050   GST_OBJECT_UNLOCK (parse);
4051   GST_INFO_OBJECT (parse, &quot;min/max latency %&quot; GST_TIME_FORMAT &quot;, %&quot;
4052       GST_TIME_FORMAT, GST_TIME_ARGS (min_latency),
4053       GST_TIME_ARGS (max_latency));
4054 }
4055 
4056 static gboolean
4057 gst_base_parse_get_duration (GstBaseParse * parse, GstFormat format,
4058     GstClockTime * duration)
4059 {
4060   gboolean res = FALSE;
4061 
4062   g_return_val_if_fail (duration != NULL, FALSE);
4063 
4064   *duration = GST_CLOCK_TIME_NONE;
4065   if (parse-&gt;priv-&gt;duration != -1 &amp;&amp; format == parse-&gt;priv-&gt;duration_fmt) {
4066     GST_LOG_OBJECT (parse, &quot;using provided duration&quot;);
4067     *duration = parse-&gt;priv-&gt;duration;
4068     res = TRUE;
4069   } else if (parse-&gt;priv-&gt;duration != -1) {
4070     GST_LOG_OBJECT (parse, &quot;converting provided duration&quot;);
4071     res = gst_base_parse_convert (parse, parse-&gt;priv-&gt;duration_fmt,
4072         parse-&gt;priv-&gt;duration, format, (gint64 *) duration);
4073   } else if (format == GST_FORMAT_TIME &amp;&amp; parse-&gt;priv-&gt;estimated_duration != -1) {
4074     GST_LOG_OBJECT (parse, &quot;using estimated duration&quot;);
4075     *duration = parse-&gt;priv-&gt;estimated_duration;
4076     res = TRUE;
4077   } else {
4078     GST_LOG_OBJECT (parse, &quot;cannot estimate duration&quot;);
4079   }
4080 
4081   GST_LOG_OBJECT (parse, &quot;res: %d, duration %&quot; GST_TIME_FORMAT, res,
4082       GST_TIME_ARGS (*duration));
4083   return res;
4084 }
4085 
4086 static gboolean
4087 gst_base_parse_src_query_default (GstBaseParse * parse, GstQuery * query)
4088 {
4089   gboolean res = FALSE;
4090   GstPad *pad;
4091 
4092   pad = GST_BASE_PARSE_SRC_PAD (parse);
4093 
4094   switch (GST_QUERY_TYPE (query)) {
4095     case GST_QUERY_POSITION:
4096     {
4097       gint64 dest_value;
4098       GstFormat format;
4099 
4100       GST_DEBUG_OBJECT (parse, &quot;position query&quot;);
4101       gst_query_parse_position (query, &amp;format, NULL);
4102 
4103       /* try upstream first */
4104       res = gst_pad_query_default (pad, GST_OBJECT_CAST (parse), query);
4105       if (!res) {
4106         /* Fall back on interpreting segment */
4107         GST_OBJECT_LOCK (parse);
4108         /* Only reply BYTES if upstream is in BYTES already, otherwise
4109          * we&#39;re not in charge */
4110         if (format == GST_FORMAT_BYTES
4111             &amp;&amp; parse-&gt;priv-&gt;upstream_format == GST_FORMAT_BYTES) {
4112           dest_value = parse-&gt;priv-&gt;offset;
4113           res = TRUE;
4114         } else if (format == parse-&gt;segment.format &amp;&amp;
4115             GST_CLOCK_TIME_IS_VALID (parse-&gt;segment.position)) {
4116           dest_value = gst_segment_to_stream_time (&amp;parse-&gt;segment,
4117               parse-&gt;segment.format, parse-&gt;segment.position);
4118           res = TRUE;
4119         }
4120         GST_OBJECT_UNLOCK (parse);
4121         if (!res &amp;&amp; parse-&gt;priv-&gt;upstream_format == GST_FORMAT_BYTES) {
4122           /* no precise result, upstream no idea either, then best estimate */
4123           /* priv-&gt;offset is updated in both PUSH/PULL modes, *iff* we&#39;re
4124            * in charge of things */
4125           res = gst_base_parse_convert (parse,
4126               GST_FORMAT_BYTES, parse-&gt;priv-&gt;offset, format, &amp;dest_value);
4127         }
4128         if (res)
4129           gst_query_set_position (query, format, dest_value);
4130       }
4131       break;
4132     }
4133     case GST_QUERY_DURATION:
4134     {
4135       GstFormat format;
4136       GstClockTime duration;
4137 
4138       GST_DEBUG_OBJECT (parse, &quot;duration query&quot;);
4139       gst_query_parse_duration (query, &amp;format, NULL);
4140 
4141       /* consult upstream */
4142       res = gst_pad_query_default (pad, GST_OBJECT_CAST (parse), query);
4143 
4144       /* otherwise best estimate from us */
4145       if (!res) {
4146         res = gst_base_parse_get_duration (parse, format, &amp;duration);
4147         if (res)
4148           gst_query_set_duration (query, format, duration);
4149       }
4150       break;
4151     }
4152     case GST_QUERY_SEEKING:
4153     {
4154       GstFormat fmt;
4155       GstClockTime duration = GST_CLOCK_TIME_NONE;
4156       gboolean seekable = FALSE;
4157 
4158       GST_DEBUG_OBJECT (parse, &quot;seeking query&quot;);
4159       gst_query_parse_seeking (query, &amp;fmt, NULL, NULL, NULL);
4160 
4161       /* consult upstream */
4162       res = gst_pad_query_default (pad, GST_OBJECT_CAST (parse), query);
4163 
4164       /* we may be able to help if in TIME */
4165       if (fmt == GST_FORMAT_TIME &amp;&amp; gst_base_parse_is_seekable (parse)) {
4166         gst_query_parse_seeking (query, &amp;fmt, &amp;seekable, NULL, NULL);
4167         /* already OK if upstream takes care */
4168         GST_LOG_OBJECT (parse, &quot;upstream handled %d, seekable %d&quot;,
4169             res, seekable);
4170         if (!(res &amp;&amp; seekable)) {
4171           if (!gst_base_parse_get_duration (parse, GST_FORMAT_TIME, &amp;duration)
4172               || duration == -1) {
4173             /* seekable if we still have a chance to get duration later on */
4174             seekable = parse-&gt;priv-&gt;upstream_seekable &amp;&amp;
4175                 (parse-&gt;priv-&gt;update_interval &gt; 0);
4176           } else {
4177             seekable = parse-&gt;priv-&gt;upstream_seekable;
4178             GST_LOG_OBJECT (parse, &quot;already determine upstream seekabled: %d&quot;,
4179                 seekable);
4180           }
4181           gst_query_set_seeking (query, GST_FORMAT_TIME, seekable, 0, duration);
4182           res = TRUE;
4183         }
4184       }
4185       break;
4186     }
4187     case GST_QUERY_FORMATS:
4188       gst_query_set_formatsv (query, 3, fmtlist);
4189       res = TRUE;
4190       break;
4191     case GST_QUERY_CONVERT:
4192     {
4193       GstFormat src_format, dest_format;
4194       gint64 src_value, dest_value;
4195 
4196       gst_query_parse_convert (query, &amp;src_format, &amp;src_value,
4197           &amp;dest_format, &amp;dest_value);
4198 
4199       res = gst_base_parse_convert (parse, src_format, src_value,
4200           dest_format, &amp;dest_value);
4201       if (res) {
4202         gst_query_set_convert (query, src_format, src_value,
4203             dest_format, dest_value);
4204       }
4205       break;
4206     }
4207     case GST_QUERY_LATENCY:
4208     {
4209       if ((res = gst_pad_peer_query (parse-&gt;sinkpad, query))) {
4210         gboolean live;
4211         GstClockTime min_latency, max_latency;
4212 
4213         gst_query_parse_latency (query, &amp;live, &amp;min_latency, &amp;max_latency);
4214         GST_DEBUG_OBJECT (parse, &quot;Peer latency: live %d, min %&quot;
4215             GST_TIME_FORMAT &quot; max %&quot; GST_TIME_FORMAT, live,
4216             GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
4217 
4218         GST_OBJECT_LOCK (parse);
4219         /* add our latency */
4220         min_latency += parse-&gt;priv-&gt;min_latency;
4221         if (max_latency == -1 || parse-&gt;priv-&gt;max_latency == -1)
4222           max_latency = -1;
4223         else
4224           max_latency += parse-&gt;priv-&gt;max_latency;
4225         GST_OBJECT_UNLOCK (parse);
4226 
4227         gst_query_set_latency (query, live, min_latency, max_latency);
4228       }
4229       break;
4230     }
4231     case GST_QUERY_SEGMENT:
4232     {
4233       GstFormat format;
4234       gint64 start, stop;
4235 
4236       format = parse-&gt;segment.format;
4237 
4238       start =
4239           gst_segment_to_stream_time (&amp;parse-&gt;segment, format,
4240           parse-&gt;segment.start);
4241       if ((stop = parse-&gt;segment.stop) == -1)
4242         stop = parse-&gt;segment.duration;
4243       else
4244         stop = gst_segment_to_stream_time (&amp;parse-&gt;segment, format, stop);
4245 
4246       gst_query_set_segment (query, parse-&gt;segment.rate, format, start, stop);
4247       res = TRUE;
4248       break;
4249     }
4250     default:
4251       res = gst_pad_query_default (pad, GST_OBJECT_CAST (parse), query);
4252       break;
4253   }
4254   return res;
4255 }
4256 
4257 /* scans for a cluster start from @pos,
4258  * return GST_FLOW_OK and frame position/time in @pos/@time if found */
4259 static GstFlowReturn
4260 gst_base_parse_find_frame (GstBaseParse * parse, gint64 * pos,
4261     GstClockTime * time, GstClockTime * duration)
4262 {
4263   GstBaseParseClass *klass;
4264   gint64 orig_offset;
4265   gboolean orig_drain, orig_discont;
4266   GstFlowReturn ret = GST_FLOW_OK;
4267   GstBuffer *buf = NULL;
4268   GstBaseParseFrame *sframe = NULL;
4269 
4270   g_return_val_if_fail (pos != NULL, GST_FLOW_ERROR);
4271   g_return_val_if_fail (time != NULL, GST_FLOW_ERROR);
4272   g_return_val_if_fail (duration != NULL, GST_FLOW_ERROR);
4273 
4274   klass = GST_BASE_PARSE_GET_CLASS (parse);
4275 
4276   *time = GST_CLOCK_TIME_NONE;
4277   *duration = GST_CLOCK_TIME_NONE;
4278 
4279   /* save state */
4280   orig_offset = parse-&gt;priv-&gt;offset;
4281   orig_discont = parse-&gt;priv-&gt;discont;
4282   orig_drain = parse-&gt;priv-&gt;drain;
4283 
4284   GST_DEBUG_OBJECT (parse, &quot;scanning for frame starting at %&quot; G_GINT64_FORMAT
4285       &quot; (%#&quot; G_GINT64_MODIFIER &quot;x)&quot;, *pos, *pos);
4286 
4287   /* jump elsewhere and locate next frame */
4288   parse-&gt;priv-&gt;offset = *pos;
4289   /* mark as scanning so frames don&#39;t get processed all the way */
4290   parse-&gt;priv-&gt;scanning = TRUE;
4291   ret = gst_base_parse_scan_frame (parse, klass);
4292   parse-&gt;priv-&gt;scanning = FALSE;
4293   /* retrieve frame found during scan */
4294   sframe = parse-&gt;priv-&gt;scanned_frame;
4295   parse-&gt;priv-&gt;scanned_frame = NULL;
4296 
4297   if (ret != GST_FLOW_OK || !sframe)
4298     goto done;
4299 
4300   /* get offset first, subclass parsing might dump other stuff in there */
4301   *pos = sframe-&gt;offset;
4302   buf = sframe-&gt;buffer;
4303   g_assert (buf);
4304 
4305   /* but it should provide proper time */
4306   *time = GST_BUFFER_TIMESTAMP (buf);
4307   *duration = GST_BUFFER_DURATION (buf);
4308 
4309   GST_LOG_OBJECT (parse,
4310       &quot;frame with time %&quot; GST_TIME_FORMAT &quot; at offset %&quot; G_GINT64_FORMAT,
4311       GST_TIME_ARGS (*time), *pos);
4312 
4313 done:
4314   if (sframe)
4315     gst_base_parse_frame_free (sframe);
4316 
4317   /* restore state */
4318   parse-&gt;priv-&gt;offset = orig_offset;
4319   parse-&gt;priv-&gt;discont = orig_discont;
4320   parse-&gt;priv-&gt;drain = orig_drain;
4321 
4322   return ret;
4323 }
4324 
4325 /* bisect and scan through file for frame starting before @time,
4326  * returns OK and @time/@offset if found, NONE and/or error otherwise
4327  * If @time == G_MAXINT64, scan for duration ( == last frame) */
4328 static GstFlowReturn
4329 gst_base_parse_locate_time (GstBaseParse * parse, GstClockTime * _time,
4330     gint64 * _offset)
4331 {
4332   GstFlowReturn ret = GST_FLOW_OK;
4333   gint64 lpos, hpos, newpos;
4334   GstClockTime time, ltime, htime, newtime, dur;
4335   gboolean cont = TRUE;
4336   const GstClockTime tolerance = TARGET_DIFFERENCE;
4337   const guint chunk = 4 * 1024;
4338 
4339   g_return_val_if_fail (_time != NULL, GST_FLOW_ERROR);
4340   g_return_val_if_fail (_offset != NULL, GST_FLOW_ERROR);
4341 
4342   GST_DEBUG_OBJECT (parse, &quot;Bisecting for time %&quot; GST_TIME_FORMAT,
4343       GST_TIME_ARGS (*_time));
4344 
4345   /* TODO also make keyframe aware if useful some day */
4346 
4347   time = *_time;
4348 
4349   /* basic cases */
4350   if (time == 0) {
4351     *_offset = 0;
4352     return GST_FLOW_OK;
4353   }
4354 
4355   if (time == -1) {
4356     *_offset = -1;
4357     return GST_FLOW_OK;
4358   }
4359 
4360   /* do not know at first */
4361   *_offset = -1;
4362   *_time = GST_CLOCK_TIME_NONE;
4363 
4364   /* need initial positions; start and end */
4365   lpos = parse-&gt;priv-&gt;first_frame_offset;
4366   ltime = parse-&gt;priv-&gt;first_frame_pts;
4367   /* try other one if no luck */
4368   if (!GST_CLOCK_TIME_IS_VALID (ltime))
4369     ltime = parse-&gt;priv-&gt;first_frame_dts;
4370   if (!gst_base_parse_get_duration (parse, GST_FORMAT_TIME, &amp;htime)) {
4371     GST_DEBUG_OBJECT (parse, &quot;Unknown time duration, cannot bisect&quot;);
4372     return GST_FLOW_ERROR;
4373   }
4374   hpos = parse-&gt;priv-&gt;upstream_size;
4375 
4376   GST_DEBUG_OBJECT (parse,
4377       &quot;Bisection initial bounds: bytes %&quot; G_GINT64_FORMAT &quot; %&quot; G_GINT64_FORMAT
4378       &quot;, times %&quot; GST_TIME_FORMAT &quot; %&quot; GST_TIME_FORMAT, lpos, hpos,
4379       GST_TIME_ARGS (ltime), GST_TIME_ARGS (htime));
4380 
4381   /* check preconditions are satisfied;
4382    * start and end are needed, except for special case where we scan for
4383    * last frame to determine duration */
4384   if (parse-&gt;priv-&gt;pad_mode != GST_PAD_MODE_PULL || !hpos ||
4385       !GST_CLOCK_TIME_IS_VALID (ltime) ||
4386       (!GST_CLOCK_TIME_IS_VALID (htime) &amp;&amp; time != G_MAXINT64)) {
4387     return GST_FLOW_OK;
4388   }
4389 
4390   /* shortcut cases */
4391   if (time &lt; ltime) {
4392     goto exit;
4393   } else if (time &lt; ltime + tolerance) {
4394     *_offset = lpos;
4395     *_time = ltime;
4396     goto exit;
4397   } else if (time &gt;= htime) {
4398     *_offset = hpos;
4399     *_time = htime;
4400     goto exit;
4401   }
4402 
4403   while (htime &gt; ltime &amp;&amp; cont) {
4404     GST_LOG_OBJECT (parse,
4405         &quot;lpos: %&quot; G_GUINT64_FORMAT &quot;, ltime: %&quot; GST_TIME_FORMAT, lpos,
4406         GST_TIME_ARGS (ltime));
4407     GST_LOG_OBJECT (parse,
4408         &quot;hpos: %&quot; G_GUINT64_FORMAT &quot;, htime: %&quot; GST_TIME_FORMAT, hpos,
4409         GST_TIME_ARGS (htime));
4410     if (G_UNLIKELY (time == G_MAXINT64)) {
4411       newpos = hpos;
4412     } else if (G_LIKELY (hpos &gt; lpos)) {
4413       newpos =
4414           gst_util_uint64_scale (hpos - lpos, time - ltime, htime - ltime) +
4415           lpos - chunk;
4416     } else {
4417       /* should mean lpos == hpos, since lpos &lt;= hpos is invariant */
4418       newpos = lpos;
4419       /* we check this case once, but not forever, so break loop */
4420       cont = FALSE;
4421     }
4422 
4423     /* ensure */
4424     newpos = CLAMP (newpos, lpos, hpos);
4425     GST_LOG_OBJECT (parse,
4426         &quot;estimated _offset for %&quot; GST_TIME_FORMAT &quot;: %&quot; G_GINT64_FORMAT,
4427         GST_TIME_ARGS (time), newpos);
4428 
4429     ret = gst_base_parse_find_frame (parse, &amp;newpos, &amp;newtime, &amp;dur);
4430     if (ret == GST_FLOW_EOS) {
4431       /* heuristic HACK */
4432       hpos = MAX (lpos, hpos - chunk);
4433       continue;
4434     } else if (ret != GST_FLOW_OK) {
4435       goto exit;
4436     }
4437 
4438     if (newtime == -1 || newpos == -1) {
4439       GST_DEBUG_OBJECT (parse, &quot;subclass did not provide metadata; aborting&quot;);
4440       break;
4441     }
4442 
4443     if (G_UNLIKELY (time == G_MAXINT64)) {
4444       *_offset = newpos;
4445       *_time = newtime;
4446       if (GST_CLOCK_TIME_IS_VALID (dur))
4447         *_time += dur;
4448       break;
4449     } else if (newtime &gt; time) {
4450       /* overshoot */
4451       hpos = (newpos &gt;= hpos) ? MAX (lpos, hpos - chunk) : MAX (lpos, newpos);
4452       htime = newtime;
4453     } else if (newtime + tolerance &gt; time) {
4454       /* close enough undershoot */
4455       *_offset = newpos;
4456       *_time = newtime;
4457       break;
4458     } else if (newtime &lt; ltime) {
4459       /* so a position beyond lpos resulted in earlier time than ltime ... */
4460       GST_DEBUG_OBJECT (parse, &quot;non-ascending time; aborting&quot;);
4461       break;
4462     } else {
4463       /* undershoot too far */
4464       newpos += newpos == lpos ? chunk : 0;
4465       lpos = CLAMP (newpos, lpos, hpos);
4466       ltime = newtime;
4467     }
4468   }
4469 
4470 exit:
4471   GST_LOG_OBJECT (parse, &quot;return offset %&quot; G_GINT64_FORMAT &quot;, time %&quot;
4472       GST_TIME_FORMAT, *_offset, GST_TIME_ARGS (*_time));
4473   return ret;
4474 }
4475 
4476 static gint64
4477 gst_base_parse_find_offset (GstBaseParse * parse, GstClockTime time,
4478     gboolean before, GstClockTime * _ts)
4479 {
4480   gint64 bytes = 0, ts = 0;
4481   GstIndexEntry *entry = NULL;
4482 
4483   if (time == GST_CLOCK_TIME_NONE) {
4484     ts = time;
4485     bytes = -1;
4486     goto exit;
4487   }
4488 
4489   GST_BASE_PARSE_INDEX_LOCK (parse);
4490   if (parse-&gt;priv-&gt;index) {
4491     /* Let&#39;s check if we have an index entry for that time */
4492     entry = gst_index_get_assoc_entry (parse-&gt;priv-&gt;index,
4493         parse-&gt;priv-&gt;index_id,
4494         before ? GST_INDEX_LOOKUP_BEFORE : GST_INDEX_LOOKUP_AFTER,
4495         GST_INDEX_ASSOCIATION_FLAG_KEY_UNIT, GST_FORMAT_TIME, time);
4496   }
4497 
4498   if (entry) {
4499     gst_index_entry_assoc_map (entry, GST_FORMAT_BYTES, &amp;bytes);
4500     gst_index_entry_assoc_map (entry, GST_FORMAT_TIME, &amp;ts);
4501 
4502     GST_DEBUG_OBJECT (parse, &quot;found index entry for %&quot; GST_TIME_FORMAT
4503         &quot; at %&quot; GST_TIME_FORMAT &quot;, offset %&quot; G_GINT64_FORMAT,
4504         GST_TIME_ARGS (time), GST_TIME_ARGS (ts), bytes);
4505   } else {
4506     GST_DEBUG_OBJECT (parse, &quot;no index entry found for %&quot; GST_TIME_FORMAT,
4507         GST_TIME_ARGS (time));
4508     if (!before) {
4509       bytes = -1;
4510       ts = GST_CLOCK_TIME_NONE;
4511     }
4512   }
4513   GST_BASE_PARSE_INDEX_UNLOCK (parse);
4514 
4515 exit:
4516   if (_ts)
4517     *_ts = ts;
4518 
4519   return bytes;
4520 }
4521 
4522 /* returns TRUE if seek succeeded */
4523 static gboolean
4524 gst_base_parse_handle_seek (GstBaseParse * parse, GstEvent * event)
4525 {
4526   gdouble rate;
4527   GstFormat format;
4528   GstSeekFlags flags;
4529   GstSeekType start_type = GST_SEEK_TYPE_NONE, stop_type;
4530   gboolean flush, update, res = TRUE, accurate;
4531   gint64 start, stop, seekpos, seekstop;
4532   GstSegment seeksegment = { 0, };
4533   GstClockTime start_ts;
4534   guint32 seqnum;
4535   GstEvent *segment_event;
4536 
4537   /* try upstream first, unless we&#39;re driving the streaming thread ourselves */
4538   if (parse-&gt;priv-&gt;pad_mode != GST_PAD_MODE_PULL) {
4539     res = gst_pad_push_event (parse-&gt;sinkpad, gst_event_ref (event));
4540     if (res)
4541       goto done;
4542   }
4543 
4544   gst_event_parse_seek (event, &amp;rate, &amp;format, &amp;flags,
4545       &amp;start_type, &amp;start, &amp;stop_type, &amp;stop);
4546   seqnum = gst_event_get_seqnum (event);
4547 
4548   GST_DEBUG_OBJECT (parse, &quot;seek to format %s, rate %f, &quot;
4549       &quot;start type %d at %&quot; GST_TIME_FORMAT &quot;, end type %d at %&quot;
4550       GST_TIME_FORMAT, gst_format_get_name (format), rate,
4551       start_type, GST_TIME_ARGS (start), stop_type, GST_TIME_ARGS (stop));
4552 
4553   /* we can only handle TIME, so check if subclass can convert
4554    * to TIME format if it&#39;s some other format (such as DEFAULT) */
4555   if (format != GST_FORMAT_TIME) {
4556     if (!gst_base_parse_convert (parse, format, start, GST_FORMAT_TIME, &amp;start)
4557         || !gst_base_parse_convert (parse, format, stop, GST_FORMAT_TIME,
4558             &amp;stop))
4559       goto no_convert_to_time;
4560 
4561     GST_INFO_OBJECT (parse, &quot;converted %s format to start time &quot;
4562         &quot;%&quot; GST_TIME_FORMAT &quot; and stop time %&quot; GST_TIME_FORMAT,
4563         gst_format_get_name (format), GST_TIME_ARGS (start),
4564         GST_TIME_ARGS (stop));
4565 
4566     format = GST_FORMAT_TIME;
4567   }
4568 
4569   /* no negative rates in push mode (unless upstream takes care of that, but
4570    * we&#39;ve already tried upstream and it didn&#39;t handle the seek request) */
4571   if (rate &lt; 0.0 &amp;&amp; parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_PUSH)
4572     goto negative_rate;
4573 
4574   if (start_type != GST_SEEK_TYPE_SET ||
4575       (stop_type != GST_SEEK_TYPE_SET &amp;&amp; stop_type != GST_SEEK_TYPE_NONE))
4576     goto wrong_type;
4577 
4578   /* get flush flag */
4579   flush = flags &amp; GST_SEEK_FLAG_FLUSH;
4580 
4581   /* copy segment, we need this because we still need the old
4582    * segment when we close the current segment. */
4583   gst_segment_copy_into (&amp;parse-&gt;segment, &amp;seeksegment);
4584 
4585   GST_DEBUG_OBJECT (parse, &quot;configuring seek&quot;);
4586   gst_segment_do_seek (&amp;seeksegment, rate, format, flags,
4587       start_type, start, stop_type, stop, &amp;update);
4588 
4589   /* accurate seeking implies seek tables are used to obtain position,
4590    * and the requested segment is maintained exactly, not adjusted any way */
4591   accurate = flags &amp; GST_SEEK_FLAG_ACCURATE;
4592 
4593   /* maybe we can be accurate for (almost) free */
4594   gst_base_parse_find_offset (parse, seeksegment.position, TRUE, &amp;start_ts);
4595   if (seeksegment.position &lt;= start_ts + TARGET_DIFFERENCE) {
4596     GST_DEBUG_OBJECT (parse, &quot;accurate seek possible&quot;);
4597     accurate = TRUE;
4598   }
4599 
4600   if (accurate) {
4601     GstClockTime startpos;
4602     if (rate &gt;= 0)
4603       startpos = seeksegment.position;
4604     else
4605       startpos = start;
4606 
4607     /* accurate requested, so ... seek a bit before target */
4608     if (startpos &lt; parse-&gt;priv-&gt;lead_in_ts)
4609       startpos = 0;
4610     else
4611       startpos -= parse-&gt;priv-&gt;lead_in_ts;
4612 
4613     if (seeksegment.stop == -1 &amp;&amp; seeksegment.duration != -1)
4614       seeksegment.stop = seeksegment.start + seeksegment.duration;
4615 
4616     seekpos = gst_base_parse_find_offset (parse, startpos, TRUE, &amp;start_ts);
4617     seekstop = gst_base_parse_find_offset (parse, seeksegment.stop, FALSE,
4618         NULL);
4619   } else {
4620     if (rate &gt;= 0)
4621       start_ts = seeksegment.position;
4622     else
4623       start_ts = start;
4624 
4625     if (seeksegment.stop == -1 &amp;&amp; seeksegment.duration != -1)
4626       seeksegment.stop = seeksegment.start + seeksegment.duration;
4627 
4628     if (!gst_base_parse_convert (parse, format, start_ts,
4629             GST_FORMAT_BYTES, &amp;seekpos))
4630       goto convert_failed;
4631     if (!gst_base_parse_convert (parse, format, seeksegment.stop,
4632             GST_FORMAT_BYTES, &amp;seekstop))
4633       goto convert_failed;
4634   }
4635 
4636   GST_DEBUG_OBJECT (parse,
4637       &quot;seek position %&quot; G_GINT64_FORMAT &quot; in bytes: %&quot; G_GINT64_FORMAT,
4638       start_ts, seekpos);
4639   GST_DEBUG_OBJECT (parse,
4640       &quot;seek stop %&quot; G_GINT64_FORMAT &quot; in bytes: %&quot; G_GINT64_FORMAT,
4641       seeksegment.stop, seekstop);
4642 
4643   if (parse-&gt;priv-&gt;pad_mode == GST_PAD_MODE_PULL) {
4644     gint64 last_stop;
4645 
4646     GST_DEBUG_OBJECT (parse, &quot;seek in PULL mode&quot;);
4647 
4648     if (flush) {
4649       if (parse-&gt;srcpad) {
4650         GstEvent *fevent = gst_event_new_flush_start ();
4651         GST_DEBUG_OBJECT (parse, &quot;sending flush start&quot;);
4652 
4653         gst_event_set_seqnum (fevent, seqnum);
4654 
4655         gst_pad_push_event (parse-&gt;srcpad, gst_event_ref (fevent));
4656         /* unlock upstream pull_range */
4657         gst_pad_push_event (parse-&gt;sinkpad, fevent);
4658       }
4659     } else {
4660       gst_pad_pause_task (parse-&gt;sinkpad);
4661     }
4662 
4663     /* we should now be able to grab the streaming thread because we stopped it
4664      * with the above flush/pause code */
4665     GST_PAD_STREAM_LOCK (parse-&gt;sinkpad);
4666 
4667     /* save current position */
4668     last_stop = parse-&gt;segment.position;
4669     GST_DEBUG_OBJECT (parse, &quot;stopped streaming at %&quot; G_GINT64_FORMAT,
4670         last_stop);
4671 
4672     /* now commit to new position */
4673 
4674     /* prepare for streaming again */
4675     if (flush) {
4676       GstEvent *fevent = gst_event_new_flush_stop (TRUE);
4677       GST_DEBUG_OBJECT (parse, &quot;sending flush stop&quot;);
4678       gst_event_set_seqnum (fevent, seqnum);
4679       gst_pad_push_event (parse-&gt;srcpad, gst_event_ref (fevent));
4680       gst_pad_push_event (parse-&gt;sinkpad, fevent);
4681       gst_base_parse_clear_queues (parse);
4682     }
4683 
4684     memcpy (&amp;parse-&gt;segment, &amp;seeksegment, sizeof (GstSegment));
4685 
4686     /* store the newsegment event so it can be sent from the streaming thread. */
4687     /* This will be sent later in _loop() */
4688     segment_event = gst_event_new_segment (&amp;parse-&gt;segment);
4689     gst_event_set_seqnum (segment_event, seqnum);
4690     parse-&gt;priv-&gt;pending_events =
4691         g_list_prepend (parse-&gt;priv-&gt;pending_events, segment_event);
4692 
4693     GST_DEBUG_OBJECT (parse, &quot;Created newseg format %d, &quot;
4694         &quot;start = %&quot; GST_TIME_FORMAT &quot;, stop = %&quot; GST_TIME_FORMAT
4695         &quot;, time = %&quot; GST_TIME_FORMAT, format,
4696         GST_TIME_ARGS (parse-&gt;segment.start),
4697         GST_TIME_ARGS (parse-&gt;segment.stop),
4698         GST_TIME_ARGS (parse-&gt;segment.time));
4699 
4700     /* one last chance in pull mode to stay accurate;
4701      * maybe scan and subclass can find where to go */
4702     if (!accurate) {
4703       gint64 scanpos;
4704       GstClockTime ts = seeksegment.position;
4705 
4706       gst_base_parse_locate_time (parse, &amp;ts, &amp;scanpos);
4707       if (scanpos &gt;= 0) {
4708         accurate = TRUE;
4709         seekpos = scanpos;
4710         /* running collected index now consists of several intervals,
4711          * so optimized check no longer possible */
4712         parse-&gt;priv-&gt;index_last_valid = FALSE;
4713         parse-&gt;priv-&gt;index_last_offset = 0;
4714         parse-&gt;priv-&gt;index_last_ts = 0;
4715       }
4716     }
4717 
4718     /* mark discont if we are going to stream from another position. */
4719     if (seekpos != parse-&gt;priv-&gt;offset) {
4720       GST_DEBUG_OBJECT (parse,
4721           &quot;mark DISCONT, we did a seek to another position&quot;);
4722       parse-&gt;priv-&gt;offset = seekpos;
4723       parse-&gt;priv-&gt;last_offset = seekpos;
4724       parse-&gt;priv-&gt;seen_keyframe = FALSE;
4725       parse-&gt;priv-&gt;discont = TRUE;
4726       parse-&gt;priv-&gt;next_dts = start_ts;
4727       parse-&gt;priv-&gt;next_pts = GST_CLOCK_TIME_NONE;
4728       parse-&gt;priv-&gt;last_dts = GST_CLOCK_TIME_NONE;
4729       parse-&gt;priv-&gt;last_pts = GST_CLOCK_TIME_NONE;
4730       parse-&gt;priv-&gt;sync_offset = seekpos;
4731       parse-&gt;priv-&gt;exact_position = accurate;
4732     }
4733 
4734     /* Start streaming thread if paused */
4735     gst_pad_start_task (parse-&gt;sinkpad,
4736         (GstTaskFunction) gst_base_parse_loop, parse-&gt;sinkpad, NULL);
4737 
4738     GST_PAD_STREAM_UNLOCK (parse-&gt;sinkpad);
4739 
4740     /* handled seek */
4741     res = TRUE;
4742   } else {
4743     GstEvent *new_event;
4744     GstBaseParseSeek *seek;
4745     GstSeekFlags flags = (flush ? GST_SEEK_FLAG_FLUSH : GST_SEEK_FLAG_NONE);
4746 
4747     /* The only thing we need to do in PUSH-mode is to send the
4748        seek event (in bytes) to upstream. Segment / flush handling happens
4749        in corresponding src event handlers */
4750     GST_DEBUG_OBJECT (parse, &quot;seek in PUSH mode&quot;);
4751     if (seekstop &gt;= 0 &amp;&amp; seekstop &lt;= seekpos)
4752       seekstop = seekpos;
4753     new_event = gst_event_new_seek (rate, GST_FORMAT_BYTES, flags,
4754         GST_SEEK_TYPE_SET, seekpos, stop_type, seekstop);
4755     gst_event_set_seqnum (new_event, seqnum);
4756 
4757     /* store segment info so its precise details can be reconstructed when
4758      * receiving newsegment;
4759      * this matters for all details when accurate seeking,
4760      * is most useful to preserve NONE stop time otherwise */
4761     seek = g_new0 (GstBaseParseSeek, 1);
4762     seek-&gt;segment = seeksegment;
4763     seek-&gt;accurate = accurate;
4764     seek-&gt;offset = seekpos;
4765     seek-&gt;start_ts = start_ts;
4766     GST_OBJECT_LOCK (parse);
4767     /* less optimal, but preserves order */
4768     parse-&gt;priv-&gt;pending_seeks =
4769         g_slist_append (parse-&gt;priv-&gt;pending_seeks, seek);
4770     GST_OBJECT_UNLOCK (parse);
4771 
4772     res = gst_pad_push_event (parse-&gt;sinkpad, new_event);
4773 
4774     if (!res) {
4775       GST_OBJECT_LOCK (parse);
4776       parse-&gt;priv-&gt;pending_seeks =
4777           g_slist_remove (parse-&gt;priv-&gt;pending_seeks, seek);
4778       GST_OBJECT_UNLOCK (parse);
4779       g_free (seek);
4780     }
4781   }
4782 
4783 done:
4784   gst_event_unref (event);
4785   return res;
4786 
4787   /* ERRORS */
4788 negative_rate:
4789   {
4790     GST_DEBUG_OBJECT (parse, &quot;negative playback rates delegated upstream.&quot;);
4791     res = FALSE;
4792     goto done;
4793   }
4794 wrong_type:
4795   {
4796     GST_DEBUG_OBJECT (parse, &quot;unsupported seek type.&quot;);
4797     res = FALSE;
4798     goto done;
4799   }
4800 no_convert_to_time:
4801   {
4802     GST_DEBUG_OBJECT (parse, &quot;seek in %s format was requested, but subclass &quot;
4803         &quot;couldn&#39;t convert that into TIME format&quot;, gst_format_get_name (format));
4804     res = FALSE;
4805     goto done;
4806   }
4807 convert_failed:
4808   {
4809     GST_DEBUG_OBJECT (parse, &quot;conversion TIME to BYTES failed.&quot;);
4810     res = FALSE;
4811     goto done;
4812   }
4813 }
4814 
4815 static void
4816 gst_base_parse_set_upstream_tags (GstBaseParse * parse, GstTagList * taglist)
4817 {
4818   if (taglist == parse-&gt;priv-&gt;upstream_tags)
4819     return;
4820 
4821   if (parse-&gt;priv-&gt;upstream_tags) {
4822     gst_tag_list_unref (parse-&gt;priv-&gt;upstream_tags);
4823     parse-&gt;priv-&gt;upstream_tags = NULL;
4824   }
4825 
4826   GST_INFO_OBJECT (parse, &quot;upstream tags: %&quot; GST_PTR_FORMAT, taglist);
4827 
4828   if (taglist != NULL)
4829     parse-&gt;priv-&gt;upstream_tags = gst_tag_list_ref (taglist);
4830 
4831   gst_base_parse_check_bitrate_tags (parse);
4832 }
4833 
4834 #if 0
4835 static void
4836 gst_base_parse_set_index (GstElement * element, GstIndex * index)
4837 {
4838   GstBaseParse *parse = GST_BASE_PARSE (element);
4839 
4840   GST_BASE_PARSE_INDEX_LOCK (parse);
4841   if (parse-&gt;priv-&gt;index)
4842     gst_object_unref (parse-&gt;priv-&gt;index);
4843   if (index) {
4844     parse-&gt;priv-&gt;index = gst_object_ref (index);
4845     gst_index_get_writer_id (index, GST_OBJECT_CAST (element),
4846         &amp;parse-&gt;priv-&gt;index_id);
4847     parse-&gt;priv-&gt;own_index = FALSE;
4848   } else {
4849     parse-&gt;priv-&gt;index = NULL;
4850   }
4851   GST_BASE_PARSE_INDEX_UNLOCK (parse);
4852 }
4853 
4854 static GstIndex *
4855 gst_base_parse_get_index (GstElement * element)
4856 {
4857   GstBaseParse *parse = GST_BASE_PARSE (element);
4858   GstIndex *result = NULL;
4859 
4860   GST_BASE_PARSE_INDEX_LOCK (parse);
4861   if (parse-&gt;priv-&gt;index)
4862     result = gst_object_ref (parse-&gt;priv-&gt;index);
4863   GST_BASE_PARSE_INDEX_UNLOCK (parse);
4864 
4865   return result;
4866 }
4867 #endif
4868 
4869 static GstStateChangeReturn
4870 gst_base_parse_change_state (GstElement * element, GstStateChange transition)
4871 {
4872   GstBaseParse *parse;
4873   GstStateChangeReturn result;
4874 
4875   parse = GST_BASE_PARSE (element);
4876 
4877   switch (transition) {
4878     case GST_STATE_CHANGE_READY_TO_PAUSED:
4879       /* If this is our own index destroy it as the
4880        * old entries might be wrong for the new stream */
4881       GST_BASE_PARSE_INDEX_LOCK (parse);
4882       if (parse-&gt;priv-&gt;own_index) {
4883         gst_object_unref (parse-&gt;priv-&gt;index);
4884         parse-&gt;priv-&gt;index = NULL;
4885         parse-&gt;priv-&gt;own_index = FALSE;
4886       }
4887 
4888       /* If no index was created, generate one */
4889       if (G_UNLIKELY (!parse-&gt;priv-&gt;index)) {
4890         GST_DEBUG_OBJECT (parse, &quot;no index provided creating our own&quot;);
4891 
4892         parse-&gt;priv-&gt;index = g_object_new (gst_mem_index_get_type (), NULL);
4893         gst_index_get_writer_id (parse-&gt;priv-&gt;index, GST_OBJECT (parse),
4894             &amp;parse-&gt;priv-&gt;index_id);
4895         parse-&gt;priv-&gt;own_index = TRUE;
4896       }
4897       GST_BASE_PARSE_INDEX_UNLOCK (parse);
4898       break;
4899     default:
4900       break;
4901   }
4902 
4903   result = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
4904 
4905   switch (transition) {
4906     case GST_STATE_CHANGE_PAUSED_TO_READY:
4907       gst_base_parse_reset (parse);
4908       break;
4909     default:
4910       break;
4911   }
4912 
4913   return result;
4914 }
4915 
4916 /**
4917  * gst_base_parse_set_ts_at_offset:
4918  * @parse: a #GstBaseParse
4919  * @offset: offset into current buffer
4920  *
4921  * This function should only be called from a @handle_frame implementation.
4922  *
4923  * #GstBaseParse creates initial timestamps for frames by using the last
4924  * timestamp seen in the stream before the frame starts.  In certain
4925  * cases, the correct timestamps will occur in the stream after the
4926  * start of the frame, but before the start of the actual picture data.
4927  * This function can be used to set the timestamps based on the offset
4928  * into the frame data that the picture starts.
4929  *
4930  * Since: 1.2
4931  */
4932 void
4933 gst_base_parse_set_ts_at_offset (GstBaseParse * parse, gsize offset)
4934 {
4935   GstClockTime pts, dts;
4936 
4937   g_return_if_fail (GST_IS_BASE_PARSE (parse));
4938 
4939   pts = gst_adapter_prev_pts_at_offset (parse-&gt;priv-&gt;adapter, offset, NULL);
4940   dts = gst_adapter_prev_dts_at_offset (parse-&gt;priv-&gt;adapter, offset, NULL);
4941 
4942   if (!GST_CLOCK_TIME_IS_VALID (pts) || !GST_CLOCK_TIME_IS_VALID (dts)) {
4943     GST_DEBUG_OBJECT (parse,
4944         &quot;offset adapter timestamps dts=%&quot; GST_TIME_FORMAT &quot; pts=%&quot;
4945         GST_TIME_FORMAT, GST_TIME_ARGS (dts), GST_TIME_ARGS (pts));
4946   }
4947   if (GST_CLOCK_TIME_IS_VALID (pts) &amp;&amp; (parse-&gt;priv-&gt;prev_pts != pts))
4948     parse-&gt;priv-&gt;prev_pts = parse-&gt;priv-&gt;next_pts = pts;
4949 
4950   if (GST_CLOCK_TIME_IS_VALID (dts) &amp;&amp; (parse-&gt;priv-&gt;prev_dts != dts)) {
4951     parse-&gt;priv-&gt;prev_dts = parse-&gt;priv-&gt;next_dts = dts;
4952     parse-&gt;priv-&gt;prev_dts_from_pts = FALSE;
4953   }
4954 }
4955 
4956 /**
4957  * gst_base_parse_merge_tags:
4958  * @parse: a #GstBaseParse
4959  * @tags: (allow-none): a #GstTagList to merge, or NULL to unset
4960  *     previously-set tags
4961  * @mode: the #GstTagMergeMode to use, usually #GST_TAG_MERGE_REPLACE
4962  *
4963  * Sets the parser subclass&#39;s tags and how they should be merged with any
4964  * upstream stream tags. This will override any tags previously-set
4965  * with gst_base_parse_merge_tags().
4966  *
4967  * Note that this is provided for convenience, and the subclass is
4968  * not required to use this and can still do tag handling on its own.
4969  *
4970  * Since: 1.6
4971  */
4972 void
4973 gst_base_parse_merge_tags (GstBaseParse * parse, GstTagList * tags,
4974     GstTagMergeMode mode)
4975 {
4976   g_return_if_fail (GST_IS_BASE_PARSE (parse));
4977   g_return_if_fail (tags == NULL || GST_IS_TAG_LIST (tags));
4978   g_return_if_fail (tags == NULL || mode != GST_TAG_MERGE_UNDEFINED);
4979 
4980   GST_OBJECT_LOCK (parse);
4981 
4982   if (tags != parse-&gt;priv-&gt;parser_tags) {
4983     if (parse-&gt;priv-&gt;parser_tags) {
4984       gst_tag_list_unref (parse-&gt;priv-&gt;parser_tags);
4985       parse-&gt;priv-&gt;parser_tags = NULL;
4986       parse-&gt;priv-&gt;parser_tags_merge_mode = GST_TAG_MERGE_APPEND;
4987     }
4988     if (tags) {
4989       parse-&gt;priv-&gt;parser_tags = gst_tag_list_ref (tags);
4990       parse-&gt;priv-&gt;parser_tags_merge_mode = mode;
4991     }
4992 
4993     GST_DEBUG_OBJECT (parse, &quot;setting parser tags to %&quot; GST_PTR_FORMAT
4994         &quot; (mode %d)&quot;, tags, parse-&gt;priv-&gt;parser_tags_merge_mode);
4995 
4996     gst_base_parse_check_bitrate_tags (parse);
4997     parse-&gt;priv-&gt;tags_changed = TRUE;
4998   }
4999 
5000   GST_OBJECT_UNLOCK (parse);
5001 }
    </pre>
  </body>
</html>